<html>
<head>
<title>Capture and forward correlation IDs through different Lambda event sources</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过不同的Lambda事件源捕获和转发相关id</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/capture-and-forward-correlation-ids-through-different-lambda-event-sources-220c227c65f5?source=collection_archive---------3-----------------------#2017-09-01">https://medium.com/hackernoon/capture-and-forward-correlation-ids-through-different-lambda-event-sources-220c227c65f5?source=collection_archive---------3-----------------------#2017-09-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="f616" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">默认情况下，无服务器架构是微服务，您需要关联id来帮助调试跨多个功能的问题，以及可能不同的事件源类型—异步、同步和流。</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/90788c781805f5af28e7651286422b40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hlat_2akk4kxA_US-1bPSg.png"/></div></div></figure><p id="20fe" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这是关于管理AWS Lambda日志的3部分迷你系列的最后一部分。</p><p id="d350" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果你还没有读过第一部分，请现在读一读。我们将在这篇文章中详细描述的CloudWatch日志的基础设施之上构建日志。</p><p id="35bd" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">第一部分:</strong> <a class="ae kr" rel="noopener" href="/@theburningmonk/centralised-logging-for-aws-lambda-b765b7ca9152">集中伐木</a></p><p id="c48b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">第二部分:</strong> <a class="ae kr" rel="noopener" href="/@theburningmonk/tips-and-tricks-for-logging-and-monitoring-aws-lambda-functions-885af6da29a5">小窍门</a></p><h1 id="0128" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">为什么是关联id？</h1><p id="71d2" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">随着您的架构变得越来越复杂，许多服务必须协同工作才能提供您的用户想要的功能。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff lp"><img src="../Images/ad5f21b77b5a9141ad39faecf84488fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fb4zqgd-XqrDkoV9ZCRafQ.png"/></div></div><figcaption class="lq lr fg fe ff ls lt bd b be z ek">Microservice death stars, circa 2015.</figcaption></figure><p id="0f4f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">当一切都运作时，就像看一个管弦乐队，许多小片段都独立地演奏，同时合作形成一个整体，这个整体大于其各部分的总和。</p><p id="5a9f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">但是，东西不行的时候，调试起来很痛苦。找到那一条线索就像大海捞针一样，因为有这么多移动的部分，而且它们都在不停地移动。</p><p id="0a68" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">想象一下，你是Twitter的一名工程师，正在试图调试为什么一个用户的推文没有被发送到他的一个追随者的时间线。</p><p id="0608" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><em class="lu">“让我交叉参考来自数百个服务的日志，找到提到作者的用户ID、推文ID或接收者的用户ID的日志，并整理出一个关于推文如何通过我们的系统以及为什么它没有被发送到接收者的时间线的故事。”</em></p><p id="0b3c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><em class="lu">“没有明确提到这些字段的日志怎么办？”</em></p><p id="4de3" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><em class="lu">“嗯……我会再联系你的……”</em></p><p id="0b05" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">大海捞针。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff lv"><img src="../Images/81d4db0ab963cb5da8a080a2bd98b347.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HicW4DLqz4vBTh-EO5wrcA.png"/></div></div></figure><p id="f4dc" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这就是关联id在微服务世界中解决的问题——用相关的上下文标记每个日志消息，以便以后很容易找到它们。</p><p id="bf39" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">除了常见的ID，如用户ID、订单ID、tweet ID等。您可能还想在每个日志消息中包含X射线跟踪ID。这样，如果您使用带有Lambda的X射线，那么您可以使用它在X射线控制台中快速加载相关的轨迹。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff lw"><img src="../Images/05e3af2aeb4e28ede4f57757eee26179.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GovI2qoCwEsOidOFR99KOA.png"/></div></div><figcaption class="lq lr fg fe ff ls lt bd b be z ek">By default, Lambda automatically generates a _X_AMZN_TRACE_ID value in the environment variable.</figcaption></figure><p id="475d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">此外，如果您打算给每个日志消息添加一堆相关id，那么您应该考虑切换到JSON。然后您需要更新我们在第1部分中介绍的<code class="eh lx ly lz ma b">ship-logs</code>函数来处理JSON格式的日志消息。</p><h1 id="9e24" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated"><strong class="ak">启用整个调用链的调试日志</strong></h1><p id="23a8" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">人们遇到的另一个常见问题是，当我们意识到生产中有问题时，我们发现调试问题所需的关键信息被记录为debug，我们在生产中禁用调试日志，因为它们太嘈杂。</p><p id="2661" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><em class="lu">“糟糕，现在我们必须启用调试日志并重新部署所有这些服务！真痛苦！”</em></p><p id="71f3" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><em class="lu">“找到问题后，不要忘记禁用调试日志并重新部署它们；——)"</em></p><p id="2cae" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">幸运的是，这并不一定是一个进退两难的局面。您可以通过以下方式在整个调用链上启用调试日志记录:</p><ol class=""><li id="8619" class="mb mc hu jx b jy jz kb kc ke md ki me km mf kq mg mh mi mj dt translated">决定在边缘服务上启用调试日志记录(例如，所有请求的5%)</li><li id="0234" class="mb mc hu jx b jy mk kb ml ke mm ki mn km mo kq mg mh mi mj dt translated">将对所有向外请求的决策与相关id一起传递</li><li id="5d17" class="mb mc hu jx b jy mk kb ml ke mm ki mn km mo kq mg mh mi mj dt translated">当收到来自边缘服务的请求时，可能通过SNS等异步事件源，中间服务将捕获该决定，并在被要求时打开调试日志记录</li><li id="21c9" class="mb mc hu jx b jy mk kb ml ke mm ki mn km mo kq mg mh mi mj dt translated">中间服务还会将该决定连同相关id一起传递给所有向外的请求</li></ol><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mp"><img src="../Images/dbb7dfeab8bac56ba8735e8fdc120428.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DFOdXzHDXer_jB9Ts0oW9A.png"/></div></div><figcaption class="lq lr fg fe ff ls lt bd b be z ek">The edge service decides to turn DEBUG logging on for 5% of requests, that decision is captured and passed along throughout the entire call chain, through HTTP requests, SNS message and Kinesis events.</figcaption></figure><h1 id="42a3" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">捕获和转发相关id</h1><p id="a078" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">说完这些，让我们深入一些代码，看看如何让它真正工作。如果您想跟进，那么代码可以在这个<a class="ae kr" href="https://github.com/theburningmonk/lambda-correlation-id-demo" rel="noopener ugc nofollow" target="_blank"> repo </a>中找到，演示项目的架构如下所示:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mq"><img src="../Images/73ba90276b6ab4c984eaa9bbce1ccd63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DIhWeMy87eOfUdBDNLYM0w.png"/></div></div><figcaption class="lq lr fg fe ff ls lt bd b be z ek">The demo project consists of an edge API, api-a, which initialises a bunch of correlation IDs as well as the decision on whether or not to turn on debug logging. It’ll pass these along through HTTP requests to api-b, Kinesis events and SNS messages. Each of these downstream function would in turn capture and pass them along to api-c.</figcaption></figure><div class="mr ms fm fo mt mu"><a href="https://github.com/theburningmonk/lambda-correlation-id-demo" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab ej"><div class="mw ab mx cl cj my"><h2 class="bd hv fv z el mz eo ep na er et ht dt translated">燃烧monk/lambda-关联-id-演示</h2><div class="nb l"><h3 class="bd b fv z el mz eo ep na er et ek translated">lambda-correlation-id-demo -如何跨API、SNS和Kinesis事件跟踪关联id</h3></div><div class="nc l"><p class="bd b gc z el mz eo ep na er et ek translated">github.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni jt mu"/></div></div></a></div><p id="0635" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们可以利用现在由平台管理并发的事实，这意味着我们可以安全地使用全局变量来存储与当前调用相关的上下文信息。</p><p id="6c28" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在处理函数中，我们可以在全局变量中捕获传入的相关性id，然后将它们包含在日志消息中，以及任何传出的消息/HTTP请求/事件等。</p><p id="d397" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">为了抽象出实现细节，让我们创建一个<code class="eh lx ly lz ma b">requestContext</code>模块，使获取和更新这些上下文数据变得容易:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nj nk l"/></div></figure><p id="e327" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">然后添加一个<code class="eh lx ly lz ma b">log</code>模块:</p><ul class=""><li id="b9f5" class="mb mc hu jx b jy jz kb kc ke md ki me km mf kq nl mh mi mj dt translated">默认情况下禁用调试日志记录</li><li id="53f4" class="mb mc hu jx b jy mk kb ml ke mm ki mn km mo kq nl mh mi mj dt translated">如果通过环境变量被显式覆盖，或者在传入请求中捕获到一个<code class="eh lx ly lz ma b">Debug-Log-Enabled</code>字段以及其他相关id，则启用调试日志记录</li><li id="3c2a" class="mb mc hu jx b jy mk kb ml ke mm ki mn km mo kq nl mh mi mj dt translated">将消息记录为JSON</li></ul><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nj nk l"/></div></figure><p id="1001" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">一旦我们开始捕获相关id，我们的日志消息将如下所示:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nm"><img src="../Images/261ad0653935392c96e5d784b82986cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SE4tw4pUv1Wgri4iOssBrA.png"/></div></div></figure><p id="abc6" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">注意，我还从传入的请求中捕获了<code class="eh lx ly lz ma b">User-Agent</code>，以及不启用调试日志记录的决定。</p><p id="c9ae" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在让我们看看如何通过API网关和传出的HTTP请求来捕获和转发相关id。</p><h1 id="b810" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">API网关</h1><p id="0a5f" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">您可以通过HTTP头捕获并传递相关id。诀窍是确保团队中的每个人都遵循相同的约定。</p><p id="f66c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">为了标准化这些约定(如何命名作为相关id的报头，等等。)您可以提供一个工厂函数，开发人员可以用它来创建API处理程序。大概是这样的:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nj nk l"/></div></figure><p id="c1a1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">当您需要实现另一个HTTP端点时，将您的处理程序代码传递给这个工厂函数。现在，经过最小的改动，所有的日志都将拥有捕获的关联id(以及<code class="eh lx ly lz ma b">User-Agent</code>、是否启用调试日志记录等)。).</p><p id="1cd9" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们早期架构中的<code class="eh lx ly lz ma b">api-a</code>函数如下所示:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nj nk l"/></div></figure><p id="6ff7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">因为这是边缘上的API，所以它使用AWS请求ID来初始化<code class="eh lx ly lz ma b">x-correlation-id</code>进行调用。每个日志消息都会记录这一点以及其他几条上下文信息。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nn"><img src="../Images/2a8f6e9604973f9a0ca75f1ecb31725c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tZJ9ETh6KmPVQe8DkqazGg.png"/></div></div></figure><p id="0ced" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">通过添加一个像<a class="ae kr" href="https://github.com/theburningmonk/lambda-correlation-id-demo/blob/master/lib/http.js" rel="noopener ugc nofollow" target="_blank">这个</a>一样的定制HTTP模块，您还可以很容易地将这些上下文信息包含在传出的HTTP请求中。将这些约定封装在一个易于使用的库中也有助于您在整个团队中标准化方法。</p><p id="329b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在上面的<code class="eh lx ly lz ma b">api-a</code>函数中，我们向<code class="eh lx ly lz ma b">api-b</code>端点发出了一个HTTP请求。查看日志，您可以看到前面提到的上下文信息已经被传递了。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff no"><img src="../Images/0dbec3e692e3355627a1586359f14be7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E39zAlXUJE9RhQjTl3-ezQ.png"/></div></div></figure><p id="8b3f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在这种情况下，我们也有从最初的用户发起的请求到<code class="eh lx ly lz ma b">api-a</code>的<code class="eh lx ly lz ma b">User-Agent</code>。这很有用，因为当我查看中间服务的日志时，我经常会错过用户正在使用的平台的上下文，这使得我更难将从日志中收集的信息与用户在其错误报告中描述的症状相关联。</p><p id="a47d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">当<code class="eh lx ly lz ma b">api-b</code>函数(参见这里的<a class="ae kr" href="https://github.com/theburningmonk/lambda-correlation-id-demo/blob/master/functions/api-b.js" rel="noopener ugc nofollow" target="_blank"/>)向<code class="eh lx ly lz ma b">api-c</code>发出自己的出站HTTP请求时，它将传递所有这些上下文信息以及我们在<code class="eh lx ly lz ma b">api-b</code>函数本身中添加的任何内容。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff np"><img src="../Images/49b64b82bba4f55a277742ec0223f285.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KAFPL6hNb-fNCx0-2gY7dw.png"/></div></div><figcaption class="lq lr fg fe ff ls lt bd b be z ek">Log message for when api-b calls api-c with the custom HTTP module. Notice it includes the “x-correlation-character-b” header which is set by the api-b function.</figcaption></figure><p id="e1f4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">当您在<code class="eh lx ly lz ma b">api-c</code>的日志中看到相应的日志消息时，您将看到来自<code class="eh lx ly lz ma b">api-a</code>和<code class="eh lx ly lz ma b">api-b</code>的所有上下文。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nq"><img src="../Images/61b97879169bd945c5401de7ce58ebf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-gCSwTvGbr5ai4Wqma01iA.png"/></div></div></figure><h1 id="1e6c" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">社交网站（Social Network Site的缩写）</h1><p id="4ed0" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">要通过SNS消息捕获和转发关联id，可以使用消息属性。</p><p id="d1c8" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在上面的<code class="eh lx ly lz ma b">api-a</code>函数中，我们还用一个定制的<code class="eh lx ly lz ma b">sns</code>模块向SNS发布了一条消息(从上面的代码片段中省略了),该模块将捕获的相关性id作为消息属性，见下文。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nj nk l"/></div></figure><p id="5a09" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">当这个SNS消息被传递给Lambda函数时，您可以在SNS事件的<code class="eh lx ly lz ma b">MessageAttributes</code>字段中看到相关id。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nr"><img src="../Images/e30d2dfd5117dba320d92e1525aa4f2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*up9g8BikzxiR_qJrHYK9NQ.png"/></div></div></figure><p id="b98b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">让我们创建一个<code class="eh lx ly lz ma b">snsHandler</code>工厂函数来标准化通过SNS消息属性捕获传入关联id的过程。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nj nk l"/></div></figure><p id="e3f7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们可以使用这个工厂函数来快速创建SNS处理函数。来自这些处理函数的日志消息将可以访问捕获的相关id。如果您使用前面提到的定制<code class="eh lx ly lz ma b">http</code>模块来发出HTTP请求，那么它们将自动作为HTTP头包含进来。</p><p id="a7b1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">例如，下面的SNS处理函数将捕获传入的关联id，将它们包含在日志消息中，并在向<code class="eh lx ly lz ma b">api-c</code>发出HTTP请求时传递它们(参见架构图)。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nj nk l"/></div></figure><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nn"><img src="../Images/f0d86a515929d4ede335c4499bb2c4e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WI03hguMcREKNUs0ZDnnIQ.png"/></div></div><figcaption class="lq lr fg fe ff ls lt bd b be z ek">Log message for when the SNS handler function calls api-c with the custom HTTP module. Notice it includes the “x-correlation-source-type” header which is set by the SNS handler function.</figcaption></figure><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ns"><img src="../Images/da6107a53103904541cffb69a7b6152d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qrXnqU1Z84WZcF09kB5NCw.png"/></div></div><figcaption class="lq lr fg fe ff ls lt bd b be z ek">Those correlation IDs (including the one added by the SNS handler function) are included as HTTP headers.</figcaption></figure><h1 id="cc76" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">Kinesis流</h1><p id="77fa" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">不幸的是，对于Kinesis和DynamoDB流，无法用有效载荷标记附加信息。相反，为了传递相关id，我们必须修改实际的有效负载本身。</p><p id="9259" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">让我们创建一个<code class="eh lx ly lz ma b">kinesis</code>模块来将事件发送到Kinesis流，这样我们就可以在有效载荷中插入一个<code class="eh lx ly lz ma b">__context</code>字段来携带相关id。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nj nk l"/></div></figure><p id="a63a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在接收端，我们可以取出它，用它来设置当前的<code class="eh lx ly lz ma b">requestContext</code>，并在将它传递给Kinesis处理函数进行处理之前删除这个<code class="eh lx ly lz ma b">__context</code>字段。发送方和接收方函数甚至不会注意到我们修改了有效载荷。</p><p id="e2cb" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">等等，还有一个问题—我们的Lambda函数将接收一批Kinesis记录，每个记录都有自己的上下文。我们将如何巩固这一点？</p><p id="8814" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">最简单的方法是强制处理函数一次处理一条记录。这就是我们在这里的<code class="eh lx ly lz ma b">kinesisHandler</code>工厂函数中所做的。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nj nk l"/></div></figure><p id="052e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">处理函数(用<code class="eh lx ly lz ma b">kinesisHandler</code>工厂函数创建)将一次处理一条记录，并且不必担心管理请求上下文。它的所有日志消息都有正确的关联id，传出的HTTP请求、SNS消息和Kinesis事件也会传递这些关联id。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nj nk l"/></div></figure><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff np"><img src="../Images/de3a0e6330353671fed74edbed5ee675.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IlrsrItfJZHMsKwEzOtcwA.png"/></div></div><figcaption class="lq lr fg fe ff ls lt bd b be z ek">Log message for when the kinesis handler function calls api-c.</figcaption></figure><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nt"><img src="../Images/e6d59bfaebc81752f4227a18987182f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a1RSXT42G9EaNeSZwhvP_Q.png"/></div></div><figcaption class="lq lr fg fe ff ls lt bd b be z ek">When api-c receives the invocation event, you can see the correlation IDs have been passed along via HTTP headers.</figcaption></figure><p id="5d11" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这种方法很简单，开发Kinesis处理函数的开发人员不必担心如何捕获和传递相关id的实现细节，事情“就这样工作了”。</p><p id="4e80" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">但是，它也消除了通过成批处理所有记录来进行优化的机会。也许您的处理函数必须将事件持久化到持久性存储中，持久性存储更适合存储大的有效负载，而不是大量的小负载。</p><p id="4a2b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这种简单的方法并不适合每种情况，一种替代方法是将<code class="eh lx ly lz ma b">__context</code>字段留在Kinesis记录上，让处理函数按照它认为合适的方式处理它们。在这种情况下，您还需要更新共享库——到目前为止我们已经讨论过的<code class="eh lx ly lz ma b">log</code>、<code class="eh lx ly lz ma b">http</code>、<code class="eh lx ly lz ma b">sns</code>和<code class="eh lx ly lz ma b">kinesis</code>模块——让调用者可以选择传入一个<code class="eh lx ly lz ma b">requestContext</code>作为覆盖。</p><p id="58e3" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这样，handler函数可以批量处理Kinesis记录。如果需要在特定记录的上下文中记录日志或进行网络调用，它可以提取请求上下文并根据需要传递。</p><h1 id="2381" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">结束了</h1><p id="2eaf" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">就这样了，伙计们。如何通过Lambda最常用的3个事件源捕获和转发关联id的蓝图。</p><p id="8d66" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这是之前架构图的注释版本，显示了通过HTTP头、消息属性、Kinesis记录数据从一个调用捕获并转发到另一个调用的数据流。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nu"><img src="../Images/666ea29a47a24f1bab97ba6f4a1ec8ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CPtfxdmQQLUeK-g2l-2WLg.png"/></div></div></figure><p id="c0aa" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">你可以在这个<a class="ae kr" href="https://github.com/theburningmonk/lambda-correlation-id-demo" rel="noopener ugc nofollow" target="_blank">报告</a>中找到你在这篇文章中看到的代码的可部署版本。这是为我的O'Reilly课程的演示会议准备的，下面会详细介绍，所以目前文档非常缺乏，但希望这篇文章能让你对这个项目是如何组织的有个大致的了解。</p><h2 id="549e" class="nv kt hu bd ku nw nx ny ky nz oa ob lc ke oc od le ki oe of lg km og oh li oi dt translated">其他事件源</h2><p id="b7f9" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">有很多<a class="ae kr" href="http://docs.aws.amazon.com/lambda/latest/dg/invoking-lambda-function.html" rel="noopener ugc nofollow" target="_blank">事件源</a>我们没有在这篇文章中提到。</p><p id="804e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">不可能通过每个事件源传递关联id，因为有些事件源不是来自您的系统，例如由AWS服务发出的API调用触发的CloudWatch事件。</p><p id="e118" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">而且可能很难通过DynamoDB流传递相关id——我能想到的唯一可行的方法是将相关id作为字段包含在行中(这可能不是一个坏主意，但确实有成本问题)。</p></div><div class="ab cl oj ok hc ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="hn ho hp hq hr"><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="ab fr cl oq"><img src="../Images/8b4e4721bb1973db389b5b533d727ad1.png" data-original-src="https://miro.medium.com/v2/format:webp/0*b_1R345KzKSaI8sg.png"/></div></figure><p id="f870" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">嗨，我的名字是<strong class="jx hv">崔琰</strong>。我是一个<a class="ae kr" href="https://aws.amazon.com/developer/community/heroes/yan-cui/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx hv"> AWS无服务器英雄</strong> </a>和<a class="ae kr" href="https://bit.ly/production-ready-serverless" rel="noopener ugc nofollow" target="_blank"> <strong class="jx hv">量产无服务器</strong> </a>的作者。我已经在AWS中运行了近10年的大规模生产工作负载，我是一名架构师或首席工程师，涉足从银行、电子商务、体育流媒体到移动游戏等多个行业。我目前是一名专注于AWS和无服务器的独立顾问。</p><p id="c37e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">你可以通过<a class="ae kr" href="mailto:theburningmonk.com" rel="noopener ugc nofollow" target="_blank">邮箱</a>、<a class="ae kr" href="https://twitter.com/theburningmonk" rel="noopener ugc nofollow" target="_blank"> Twitter </a>和<a class="ae kr" href="https://www.linkedin.com/in/theburningmonk/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我。</p></div><div class="ab cl oj ok hc ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="hn ho hp hq hr"><p id="404d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">查看我的新课程，<a class="ae kr" href="https://theburningmonk.thinkific.com/courses/complete-guide-to-aws-step-functions" rel="noopener ugc nofollow" target="_blank"><strong class="jx hv">AWS步骤功能完整指南</strong> </a>。</p><p id="a329" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在本课程中，我们将介绍有效使用AWS Step Functions服务所需了解的一切。包括基本概念、HTTP和事件触发器、活动、设计模式和最佳实践。</p><p id="cd40" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在这里拿到你的副本。</p></div><div class="ab cl oj ok hc ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="hn ho hp hq hr"><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff lv"><img src="../Images/2faf40b47320300fed81b3e09483ffb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZYcHhOOzUf5VB-Ri.png"/></div></div></figure><p id="ee8c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">来了解AWS Lambda: CI/CD的操作性<strong class="jx hv">最佳实践</strong>，本地测试&amp;调试功能、日志记录、监控、分布式跟踪、canary部署、配置管理、认证&amp;授权、VPC、安全性、错误处理等等。</p><p id="8bb5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">还可以用代码<strong class="jx hv"> ytcui </strong>获得<strong class="jx hv">票面价格6折</strong>。</p><p id="f62a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">点击获取您的副本<a class="ae kr" href="https://bit.ly/production-ready-serverless" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>