# 实时编辑有点难

> 原文：<https://medium.com/hackernoon/real-time-editing-is-kind-of-hard-785622043b7b>

![](img/463dfed38d02f8076c78ec6c003030ec.png)

(image from [Figma](https://blog.figma.com/realtime-editing-of-ordered-sequences-c1e6b46fcd67) real-time editing post)

我刚刚浏览了 Quip 最近发布的 [Live Apps](https://quip.com/about/live-apps) 文档。如果你不熟悉 Quip，它是一个文档系统，从一开始就包含实时编辑、交流和协作。它由脸书前首席技术官 Bret Taylor 创建，并于 2016 年被 SalesForce 收购。

Quip 开始走复合文档/通用画布的道路，在最初相当基础的富文本画布上添加嵌入式电子表格。Live Apps 可扩展性模型现在允许创建新类型的组件并嵌入到文档画布中。

这些是有效的迷你网络应用程序，可以利用 Quip SDK 来支持实时编辑。自从 80 年代中期以来，我一直在构建复合文档编辑器，所以看到这方面的另一个进展是很有趣的。现在，基于 JavaScript 和 web 技术进行构建是完全有意义的，因为有如此多的技术可供开发人员进行构建。事实上，Quip 的文档画布(网络和移动)使用了 HTML 界面，这也使得这成为他们的一种自然方法。出于类似的原因，Microsoft Office 也使用 web 技术作为最近几年发布的最新扩展机制的基础。

当你开始在一个文档表面嵌入对象时，你很快就会明白链接和嵌入的区别。问题是对象的状态是直接存储在文档中，还是只是链接到存储在其他服务中的状态。嵌入的优点是文档表面内的剪切/复制/粘贴工作很自然。如果文档作为一个整体以某种其他方式被复制或管理，这种直接的行为也适用。

链接变得复杂(一般来说，不仅仅是 Quip)。我将避免在这里探讨这些问题，因为我想把重点放在实时编辑和 Quip 为嵌入状态提供的功能上。因此，让我们继续关注本文的嵌入案例。

Quip 的整个重点是实时编辑和协作，所以他们真的想确保他们的新 Live Apps 对象支持这一点。他们采用的方法是公开一组 API，允许应用程序将其状态构建为一组键值字典(“记录”)和这些字典的数组(“记录列表”)。通过编辑操作对这些对象进行的本地更改会在应用程序的不同实例之间实时同步，然后这种状态会随文档一起保留。

文档中没有讨论它(或者至少我在那里找不到任何东西)，但是我推测他们使用了类似于[操作转换](https://en.wikipedia.org/wiki/Operational_transformation) (OT)的东西，以便在多个用户同时编辑单个对象时，允许实时合并对对象状态的更改。OT 是谷歌用于他们的[实时 API](https://developers.google.com/google-apps/realtime/overview)的东西。这些 API 来自 Google Wave 项目，并最终成为 Google Apps 基础的关键部分。Quip 公开的数组和字典的 OT 协议已经很好理解了(我在 [GitHub](https://github.com/terrencecrowley/ot-js) 上写了一个非常完整的实现，供想要深入了解这项技术的人使用)。

在过去的几年里，实时协作数据 API 走过了一段艰难的路。苹果扩展了 CoreData 以支持 iCloud 数据同步，但遭到了不高兴的开发者的沉重打击，他们试图使用这些 API 并遇到了问题。他们现在正在贬低这些 API，而不是增强它们。DropBox 提供了一组数据 API，其功能与 Quip 提供的类似，但后来也弃用了它们。谷歌的 API 仍然可用，但根据 StackOverflow 上的流量，似乎没有被广泛采用(很高兴发现我错了，但我没有听到太多关于它们的消息)。

这些 API 的失败肯定有一系列的原因。如果“数据是新的石油”，把你的数据放在别人的数据存储中是一个有风险的提议。(请注意，在这些场景中，应用程序可以访问数据，但应用程序编写器不能，因为数据存储在外部服务中，并由用户身份验证控制。)这是一个显著限制你未来选择的平台选择——你已经把你的应用程序的核心和灵魂(包括用户认证)绑在了谷歌或 Dropbox 或苹果的 iCloud 上。

我认为问题的一个更基本的原因是 API 无法工作——这直接影响了 Quip 的实时应用。这种说法有点不公平 APIs 按照定义工作，但实际上并不做开发人员想要或需要的事情。问题是应用程序很复杂——这种复杂性最终会以混乱的方式与实时合并相交。从语义建模的角度来看，使用对象和数组的限制并不过分——任何构建 web 应用程序的人本质上都在使用这些原语。挑战在于，合并发生在这些原始元素的级别，并且当合并发生时，附加的特定于应用的语义约束不能被强制。因此，尽管冲突的编辑通过 OT 在原语级别得到了正确的解决，但是应用程序仍然处于语义不一致的状态。

这些问题可能很微妙——这有点像在多线程编程中寻找数据竞争错误。只有当你的应用被多个用户冲击时，它们才会出现——当然，这正是应用开发者最受瞩目的高价值时期。

让我探索一个非常简单的应用程序，让您对这些问题有所了解。比方说我要建一个“山丘之王”直播 App。我可以添加和删除“球员”的名字，我可以指定一个球员作为国王的山。约束是我要保证如果有一个或多个玩家，其中一个是王者。让我们看看建模的不同方法，以及合并会发生什么。

假设我有一个根记录，它指向一个非国王玩家的记录列表，还指向一个代表国王的记录。要创建一个新的国王，我将当前的国王插入到玩家记录列表中，从该记录列表中删除我想让其成为国王的玩家，并将该玩家设置为根中的国王。在加班水平，这变得很难看。如果这些动作在两个不同的实例中同时发生，OT 解析会将旧的国王插入到玩家列表中两次，并且会用根记录中最后到达的国王覆盖当前的国王，实质上失去了另一个新国王。所以我在两个方面崩溃了——我有同一个球员两次出现在名单上，同时我失去了一个球员。这是对我的应用程序建模的完美方式，但在 OT 层面上却非常失败。

好吧，我们再试一次。让我们有一个玩家的记录列表，然后在其中一个上设置一个“king”布尔属性。设定新国王需要清除旧国王的这个属性，然后在新国王身上设定。这很容易失败——如果我合并两个操作，我会得到两个 king 属性设置为 true 的记录。

请注意，这与您是否可以在对数据结构的多个独立编辑周围放置事务边界(在这种情况下，设置和清除 king 属性)无关。问题是 OT 没有应用在这个更高的语义层次上——它仍然应用在原始数据结构的层次上。Google 的实时 API 所展示的事务性功能并不是解决 ot 合并问题，而是仅仅关注于确保来自一个客户端的单独编辑不会独立地到达其他客户端并展示中间的不一致状态。我假设 Quip 定义了一个隐式事务来处理由一个活动应用程序对象顺序执行的所有编辑，以解决这个问题，而不必使公开的 API 更加复杂。

好，再来一个。与其将王者作为显式记录存储，不如让我们将所有球员都保存在记录列表中，只将王者记录的 ID 存储在根中。所以设置一个新的国王只是涉及到设置这个 ID。如果两个实例同时这样做，最后一个实例获胜，我仍然保持语义一致。哎呀，删除玩家怎么办？现在，如果一个实例将一个玩家设置为国王，同时另一个实例删除该玩家，那么我最终会得到一个指向一个不存在的玩家的国王 ID。

我确实有一个方法，将工作的灵感来自我上面链接的 Figma 帖子(本质上使用任意精度的实数来指定玩家的排序，并让排序最低的玩家成为国王)。另一种常见的方法是，不要对显式状态建模，而是将操作本身建模为操作日志。OT 是微不足道的，因为我总是将动作附加到记录列表中。客户端中的应用程序逻辑“播放”日志，并可以根据需要应用语义更正，因为它具有完整的历史记录。这种方法实际上类似于我在上面的 GitHub 链接中建模象棋游戏时使用的方法。这确实有点像作弊。它还有一个后果，就是国家可以无限制地发展。

如果我真的在构建一个带有服务后端的 web 应用程序，我很清楚，我只需要定义一组由服务公开的动作，服务就会序列化它们，并保证在应用动作时语义得到维护。如果我试图用 OT 来实现它，我会在比数组和字典更高的语义层次上定义操作和转换。关键是我有一个地方可以编写自定义代码来执行自定义语义。另一个关键点是，试图理解 OT 是否会破坏您的应用程序语义是相当困难的——即使对于像这样一个非常琐碎的例子。

如果我的 Microsoft Office 经验具有指导意义，那么现实情况是，最有用的 Live 应用程序实际上将是存储在其他地方并可从其他地方访问的信息的链接(如他们在一组示例应用程序中提供的 Salesforce record Live 应用程序示例)，而不是具有复杂嵌入状态的复杂对象。试图通过构建这些孤立的可扩展对象来实际创建一个通用画布，最终会遇到实时编辑之外的许多深层挑战。但这是另一篇文章的主题。

[编辑和澄清:与 Quip engineering 的对话澄清了他们没有使用 OT 来解决和合并冲突的编辑，但他们使用的机制具有类似的约束——这是必然的，因为 API 无法为实时应用程序开发人员提供关于状态树不同部分之间的相互依赖性的附加语义信息，这些信息可能会影响合并过程。]