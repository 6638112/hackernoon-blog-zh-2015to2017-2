<html>
<head>
<title>ES6 for beginners Part-2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向初学者的ES6第2部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/es6-for-beginners-part-2-ee8a77f7f4c7?source=collection_archive---------1-----------------------#2017-10-14">https://medium.com/hackernoon/es6-for-beginners-part-2-ee8a77f7f4c7?source=collection_archive---------1-----------------------#2017-10-14</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/cc98039e56ebea183247ce3f31f8b7f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I6AGiW7tRv5IYsMwpa3fzQ.jpeg"/></div></div></figure><blockquote class="jc jd je"><p id="1f87" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这篇文章最初发表在我的博客<a class="ae ke" href="https://srebalaji.rocks/es6-for-beginners-part-2/" rel="noopener ugc nofollow" target="_blank"> Es6上，面向初学者</a></p></blockquote><p id="922f" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">本文第一部分出现在<a class="ae ke" href="https://hackernoon.com/es6-for-beginners-f98120b57414" rel="noopener ugc nofollow" target="_blank">这里</a>。我在那里介绍了一些有趣的特性。:)</p><p id="3027" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">我将在这篇文章中讨论的话题</p><ol class=""><li id="219f" class="ki kj hu ji b jj jk jn jo kf kk kg kl kh km kd kn ko kp kq dt translated">承诺</li><li id="10f2" class="ki kj hu ji b jj kr jn ks kf kt kg ku kh kv kd kn ko kp kq dt translated">异步/等待</li></ol><p id="f724" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated"><strong class="ji hv">承诺</strong></p><p id="51e1" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">承诺是ES6中有用的特性之一。它们用于进行<strong class="ji hv">异步</strong>操作，如API请求、文件处理、下载图像等。</p><p id="0975" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">那么，什么是异步呢？(如果您已经知道，请稍等)</p><p id="b5f3" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">异步操作需要一些时间来完成。</p><p id="c83a" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">例如，假设您正在定义一个向服务器发出API请求的函数。该函数不会立即返回输出。从服务器获得响应只需几秒钟。</p><p id="7ff6" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">因此，如果你调用那个函数，并把它的值(即输出)赋给某个变量，它将是<strong class="ji hv">未定义的。</strong>因为Javascript不知道函数在处理一些异步操作。</p><p id="8ad1" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">那我们怎么处理呢？</p><p id="97b6" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">在此之前，让我们来谈谈历史。</p><p id="55bc" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">在承诺之前，程序员习惯定义<strong class="ji hv">回调。</strong>回调是Javascript中的普通函数，在异步操作完成时执行。</p><p id="a2ce" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">例如，您定义了一个向服务器发出API请求的函数。然后你提到了一个回调函数，当我们得到服务器的响应时，这个函数就会被执行。</p><p id="f321" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">所以在上面的例子中，Javascript不会停止执行，直到我们从API得到响应。我们已经定义了一个函数(callback ),它将在我们得到响应后执行。我想你明白了。</p><p id="8fa4" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated"><strong class="ji hv">那么，什么是承诺呢？</strong></p><figure class="kw kx ky kz fq iv"><div class="bz el l di"><div class="la lb l"/></div></figure><p id="b728" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">承诺是帮助进行异步操作的对象。</p><p id="1332" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">从技术上讲，它们是代表异步操作完成的对象。(如果你不明白，和我呆一会儿。)</p><p id="f844" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">在解释如何定义承诺之前，我先解释一下承诺的生命周期。</p><p id="ff35" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">我们有三种状态的承诺</p><ol class=""><li id="eb91" class="ki kj hu ji b jj jk jn jo kf kk kg kl kh km kd kn ko kp kq dt translated"><strong class="ji hv"> Pending </strong>:在这种状态下，promise只是执行异步操作。例如，它向服务器发出一些API请求，或者从cdn下载一些图像。从这种状态，承诺可以移动到<strong class="ji hv">履行</strong>或<strong class="ji hv">拒绝</strong></li><li id="4bdc" class="ki kj hu ji b jj kr jn ks kf kt kg ku kh kv kd kn ko kp kq dt translated"><strong class="ji hv">完成</strong>:如果承诺已经达到这个状态，那么就意味着异步操作已经完成，我们已经有了输出。例如，我们有来自API的响应。</li><li id="c30d" class="ki kj hu ji b jj kr jn ks kf kt kg ku kh kv kd kn ko kp kq dt translated"><strong class="ji hv">拒绝:</strong>如果承诺已经达到这种状态，说明异步操作不成功，我们存在导致操作失败的错误。</li></ol><p id="69c1" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">行..让我们看一些代码。</p><pre class="kw kx ky kz fq lc ld le lf aw lg dt"><span id="5fd6" class="lh li hu ld b fv lj lk l ll lm">const apiCall = new Promise(function(resolve, reject) {<br/> // async operation is defined here...<br/>});</span></pre><p id="ae4b" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">Promise是通过使用<strong class="ji hv"> new </strong>关键字创建构造函数来定义的。然后构造函数会有一个函数(我们称之为<strong class="ji hv">执行器函数</strong>)。)</p><p id="81d3" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">异步操作是在executor函数中定义的。</p><p id="8371" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">注意，executor函数有两个参数<strong class="ji hv"> resolve </strong>和<strong class="ji hv"> reject </strong>。</p><p id="3a4f" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">第一个参数<strong class="ji hv"> resolve </strong>实际上是一个函数。它在executor函数中被调用，表示异步操作成功，我们得到了输出。<strong class="ji hv"> Resolve </strong>功能帮助承诺从<strong class="ji hv"> pending </strong>状态转移到<strong class="ji hv"> fulfilled </strong>状态。希望你明白了。:)</p><p id="45cb" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">和resolve一样，<strong class="ji hv"> reject </strong>也是一个函数。它也在executor函数中被调用，它表示异步操作不成功，我们得到了一个错误。<strong class="ji hv">拒绝</strong>帮助承诺从<strong class="ji hv">待定</strong>状态转移到<strong class="ji hv">拒绝</strong>状态。:)</p><pre class="kw kx ky kz fq lc ld le lf aw lg dt"><span id="30e5" class="lh li hu ld b fv lj lk l ll lm">const apiCall = new Promise(function(resolve, reject) {<br/> if ( API request to get some data ) {<br/>  resolve("The request is successful and the response is "+ response);<br/> }<br/> else {<br/>  reject("The request is not successful. The error is "+error);<br/> }<br/>});</span></pre><p id="10f4" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">在上面的代码中，你可以看到我们在executor函数中做了一些异步操作。然后，如果我们从服务器得到响应，就调用<strong class="ji hv"> resolve </strong>函数。如果有一些错误<strong class="ji hv">拒绝</strong>函数被调用并显示错误信息。</p><p id="973b" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">我们已经完成了对承诺的定义。让我们看看如何执行promise并处理输出。</p><pre class="kw kx ky kz fq lc ld le lf aw lg dt"><span id="990a" class="lh li hu ld b fv lj lk l ll lm">// calling the promise.<br/>apiCall</span></pre><p id="7e75" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">就是这样。我们完了。:) :)</p><p id="9079" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">开玩笑的。还没完呢。</p><p id="1a21" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">在上面的代码中，调用函数并执行承诺(即执行<strong class="ji hv">执行器</strong>函数)。然后根据输出调用<strong class="ji hv">解决</strong>或<strong class="ji hv">拒绝</strong>功能。</p><p id="146b" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">但是你可以看到我们没有处理从承诺返回的输出。</p><p id="bb8a" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">例如，如果我们从API获得响应，那么我们必须处理响应。或者如果我们得到了错误，我们需要正确地处理它。</p><p id="7b78" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">那我们怎么处理呢？</p><p id="454d" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">我们使用<strong class="ji hv">处理程序</strong>来获得承诺的输出。</p><p id="fed5" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">处理程序只是一些在事件发生时执行的函数，比如点击按钮，移动光标等等。</p><p id="c1a2" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">所以我们可以使用处理程序来处理<strong class="ji hv"> resolve </strong>函数被调用或者<strong class="ji hv"> reject </strong>函数被调用的情况。</p><p id="a840" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">简单。:)</p><p id="5f5e" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">让我们看看一些代码</p><pre class="kw kx ky kz fq lc ld le lf aw lg dt"><span id="a45d" class="lh li hu ld b fv lj lk l ll lm">// calling the promise with some handlers.<br/>apiCall.then(function(x) {console.log(x); })</span></pre><p id="162c" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">在上面的代码中，我们为承诺附加了一个处理程序<strong class="ji hv">和</strong>。处理程序<strong class="ji hv">然后</strong>得到一个函数参数。那么函数参数本身就有一个参数<strong class="ji hv"> x </strong>。</p><p id="fc4e" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">到底发生了什么？</p><p id="2f0f" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">当在承诺中调用<strong class="ji hv"> resolve </strong>函数时，处理程序<strong class="ji hv">然后</strong>执行其<strong class="ji hv">函数参数</strong>。</p><p id="876e" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">我试着再解释一遍。</p><p id="3ad5" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated"><strong class="ji hv">然后</strong>处理程序寻找调用<strong class="ji hv">解析</strong>函数的事件。所以当resolve函数被调用<strong class="ji hv">时，</strong>处理程序执行它的函数参数。</p><pre class="kw kx ky kz fq lc ld le lf aw lg dt"><span id="bec8" class="lh li hu ld b fv lj lk l ll lm">apiCall.then(function(x) {console.log(x); })</span><span id="86a8" class="lh li hu ld b fv ln lk l ll lm">// Output<br/>The request is successful and the response is {name: "Jon Snow"}</span></pre><p id="acc6" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">同样，还有另一个处理程序<strong class="ji hv">捕捉</strong>。</p><p id="46f5" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated"><strong class="ji hv">捕捉</strong>处理器寻找<strong class="ji hv">拒绝</strong>功能。</p><p id="90fe" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated"><strong class="ji hv"> Catch </strong>函数在调用<strong class="ji hv"> reject </strong>函数时执行其函数参数。</p><pre class="kw kx ky kz fq lc ld le lf aw lg dt"><span id="039c" class="lh li hu ld b fv lj lk l ll lm">apiCall.then(function(x) {console.log(x); }).catch(function(x) {console.log(x); })</span><span id="7725" class="lh li hu ld b fv ln lk l ll lm">// Assuming the request is not successful ( reject function is called in the promise. )</span><span id="66c6" class="lh li hu ld b fv ln lk l ll lm">Output:<br/>The request is not successful</span></pre><p id="287d" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">我想你明白了。</p><p id="160c" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">上面的代码可读性不太好。所以我们试着重构一下。</p><pre class="kw kx ky kz fq lc ld le lf aw lg dt"><span id="09e4" class="lh li hu ld b fv lj lk l ll lm">apiCall<br/>.then(function(x) {<br/> console.log(x); <br/>})<br/>.catch(function(x) {<br/> console.log(x);<br/>}) </span></pre><p id="6b72" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">啊…现在可以看了。大多数程序员都是这样写的。</p><p id="3da0" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">好的..所以我认为你已经取得了很大的进步。</p><p id="fabd" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">让我们回顾一下。</p><ol class=""><li id="823e" class="ki kj hu ji b jj jk jn jo kf kk kg kl kh km kd kn ko kp kq dt translated">Promise用带函数参数的<strong class="ji hv"> new </strong>关键字定义。那么函数本身有两个函数参数<strong class="ji hv"> resolve </strong>和<strong class="ji hv"> reject。</strong></li><li id="565c" class="ki kj hu ji b jj kr jn ks kf kt kg ku kh kv kd kn ko kp kq dt translated">当操作成功时，应该调用函数<strong class="ji hv"> resolve </strong>。</li><li id="1298" class="ki kj hu ji b jj kr jn ks kf kt kg ku kh kv kd kn ko kp kq dt translated">当操作失败时，应调用函数<strong class="ji hv"> reject </strong>。</li><li id="fb56" class="ki kj hu ji b jj kr jn ks kf kt kg ku kh kv kd kn ko kp kq dt translated"><strong class="ji hv">然后</strong>处理器寻找<strong class="ji hv">解析</strong>功能。</li><li id="39be" class="ki kj hu ji b jj kr jn ks kf kt kg ku kh kv kd kn ko kp kq dt translated"><strong class="ji hv">捕捉</strong>处理器寻找<strong class="ji hv">拒绝</strong>功能。</li><li id="f526" class="ki kj hu ji b jj kr jn ks kf kt kg ku kh kv kd kn ko kp kq dt translated">确保代码的可读性:)</li></ol><p id="bee0" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">下面是工作示例。如果你是新手，请练习。</p><figure class="kw kx ky kz fq iv"><div class="bz el l di"><div class="lo lb l"/></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek">Promises in Javascript.</figcaption></figure><p id="f212" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">希望你理解这个例子。直截了当。</p><p id="b3b6" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated"><strong class="ji hv">异步/等待</strong></p><p id="0e13" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">如果你理解承诺，那么Async/Await是很容易的。如果你没有得到承诺，Async/Await可以帮助你理解它。也许你也能从承诺中得到明确的解脱。:)</p><p id="b787" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated"><strong class="ji hv">异步</strong></p><p id="69bb" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">Async关键字使任何函数只返回承诺。</p><p id="9f42" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">例如，考虑下面的代码</p><pre class="kw kx ky kz fq lc ld le lf aw lg dt"><span id="183b" class="lh li hu ld b fv lj lk l ll lm">async function hello() {<br/> return "Hello Promise..!"<br/>}</span></pre><p id="f75a" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">函数<strong class="ji hv"> hello </strong>会返回一个承诺。</p><p id="a82f" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">上面的代码等同于下面的代码。</p><pre class="kw kx ky kz fq lc ld le lf aw lg dt"><span id="2983" class="lh li hu ld b fv lj lk l ll lm">function hello() {<br/> return new Promise(function(resolve, reject) {<br/> // executor function body.<br/> });<br/>}</span></pre><p id="088a" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">简单吧？</p><p id="0f6f" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">另一个例子:</p><pre class="kw kx ky kz fq lc ld le lf aw lg dt"><span id="4a59" class="lh li hu ld b fv lj lk l ll lm">async function hello(a, b) {<br/> if (a &lt; b) {<br/>  return "Greater";<br/> }<br/> else {<br/>  return new Error("Not Greater");<br/> }<br/>}</span><span id="ae97" class="lh li hu ld b fv ln lk l ll lm">hello(14, 10)<br/>.then(function(x) {<br/> console.log("Good..! " + x); <br/>})<br/>.catch(function(x) {<br/> console.log("Oops..! " + x); <br/>})</span><span id="13f9" class="lh li hu ld b fv ln lk l ll lm">Output:<br/>Oops..! Not Greater. </span><span id="21c9" class="lh li hu ld b fv ln lk l ll lm">// if you call hello(4, 10) you get "Good..! Greater"</span></pre><p id="f346" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">在上面的代码中，我们定义了一个<strong class="ji hv">异步</strong>函数，并返回一些值或返回一些错误。</p><p id="c4be" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">如果在async函数中返回某个值，就相当于调用resolve函数。</p><p id="86a3" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">如果你通过使用‘new’调用<strong class="ji hv">错误构造函数返回一些错误，那么它等同于拒绝函数。</strong></p><p id="9769" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">别忘了异步函数会返回一个承诺。当然，你也可以在<strong class="ji hv"> async </strong>函数中调用<strong class="ji hv"> resolve </strong>和<strong class="ji hv"> reject </strong>函数。</p><p id="a0c4" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">让我们看看它是如何工作的。</p><pre class="kw kx ky kz fq lc ld le lf aw lg dt"><span id="e07c" class="lh li hu ld b fv lj lk l ll lm">async function Max(a, b) {<br/> if (a &gt; b) {<br/>  return Promise.resolve("Success");<br/> }<br/> else {<br/>  return Promise.reject("Error");<br/> }<br/>}</span><span id="bbd2" class="lh li hu ld b fv ln lk l ll lm">Max(4, 10)<br/>.then(function(x) {<br/> console.log("Good " + x); <br/>})<br/>.catch(function(x) {<br/> console.log("Oops " + x); <br/>});</span><span id="c77c" class="lh li hu ld b fv ln lk l ll lm">Output:<br/>Oops Error</span><span id="ca44" class="lh li hu ld b fv ln lk l ll lm">// If we pass Max(14, 10) then we should get "Good Success" :)</span></pre><p id="d187" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated"><strong class="ji hv">等待</strong></p><p id="3759" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">顾名思义，它让Javascript等待操作完成。假设您使用关键字<strong class="ji hv"> await </strong>发出一个API请求。它让Javascript等待，直到从端点得到响应。然后它继续执行。</p><p id="cfb1" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">好的..让我们深入一点</p><p id="9ca2" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated"><strong class="ji hv"> Await只能在异步函数中使用。在异步功能</strong>之外不起作用</p><p id="8913" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">让我们看一个例子</p><pre class="kw kx ky kz fq lc ld le lf aw lg dt"><span id="e402" class="lh li hu ld b fv lj lk l ll lm">async function hello() {<br/> let response = await fetch('https://api.github.com/');<br/> // above line fetches the response from the given API endpoint.<br/> return response;<br/>}</span><span id="08c9" class="lh li hu ld b fv ln lk l ll lm">hello()<br/>.then(function(x) {<br/> console.log(x); <br/>});<br/>...<br/>...</span><span id="a6e4" class="lh li hu ld b fv ln lk l ll lm">Output:<br/>Response from the API.</span></pre><p id="b677" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">在上面的代码中，你可以看到我们在从API获取响应时使用了<strong class="ji hv"> await </strong>。</p><p id="fbda" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">获取操作可能需要几秒钟的时间来获得响应，直到执行暂停，稍后再继续。</p><p id="7057" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">注意，await操作只是暂停了<strong class="ji hv"> hello函数</strong>内部的执行。<strong class="ji hv"> hello </strong>函数之外的剩余代码不会受到影响。在函数之外继续执行。当我们得到响应时，里面的<strong class="ji hv">函数参数然后</strong> <strong class="ji hv">处理程序</strong>被执行。</p><p id="1ba4" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">希望你明白了。</p><p id="2e39" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">让我们看一个例子</p><figure class="kw kx ky kz fq iv"><div class="bz el l di"><div class="lo lb l"/></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek">Async/Await in Javascript</figcaption></figure><p id="5f38" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">在上面的例子中，你可以看到我们已经为<strong class="ji hv"> getResponse </strong>函数使用了<strong class="ji hv"> await </strong>。并且<strong class="ji hv"> getResponse </strong>将在5秒后返回输出或错误。因此，在此之前，执行会暂停，然后返回响应。</p><p id="80e7" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">让我们看一些实时的例子。</p><figure class="kw kx ky kz fq iv"><div class="bz el l di"><div class="lo lb l"/></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek">Async/Await in Javascript</figcaption></figure><p id="ef30" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">在上面的例子中，你可以看到我们使用了多个<strong class="ji hv">等待。</strong>因此，对于每个wait，执行都会停止，直到收到响应，然后继续执行。</p><p id="c69a" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">用一些无效的url尝试同样的例子。您可以看到出现了错误。</p><p id="9317" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">在<strong class="ji hv">异步</strong>函数中，错误处理非常简单。如果异步函数内部出现错误，或者使用<strong class="ji hv"> await </strong>从异步函数内部调用的其他函数中出现错误，则调用<strong class="ji hv">拒绝函数</strong>。简单。</p><p id="7032" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">希望你喜欢。在下一部分中，我将讨论更有趣的主题，如数组映射、数组过滤、reduce等。仔细讨论</p><div class="lt lu fm fo lv lw"><a href="https://hackernoon.com/es6-for-beginners-77bf34bec2d1" rel="noopener  ugc nofollow" target="_blank"><div class="lx ab ej"><div class="ly ab lz cl cj ma"><h2 class="bd hv fv z el mb eo ep mc er et ht dt translated">初学者ES6第3部分</h2><div class="md l"><h3 class="bd b fv z el mb eo ep mc er et ek translated">ES6数组过滤器、数组映射、数组缩减、模板文字、导入和导出、析构对象和数组…</h3></div><div class="me l"><p class="bd b gc z el mb eo ep mc er et ek translated">hackernoon.com</p></div></div><div class="mf l"><div class="mg l mh mi mj mf mk ja lw"/></div></div></a></div><p id="c486" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">如果你喜欢这篇文章，试着给点掌声并分享它:)</p></div></div>    
</body>
</html>