<html>
<head>
<title>Kotlin Functors, Applicatives, And Monads in Pictures. Part 1/3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图中的科特林函子、应用和单子。第1/3部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/kotlin-functors-applicatives-and-monads-in-pictures-part-1-3-c47a1b1ce251?source=collection_archive---------3-----------------------#2017-03-28">https://medium.com/hackernoon/kotlin-functors-applicatives-and-monads-in-pictures-part-1-3-c47a1b1ce251?source=collection_archive---------3-----------------------#2017-03-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir is it"><p id="872b" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">这是图片中的</em> <a class="ae jt" href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" rel="noopener ugc nofollow" target="_blank"> <em class="hu">函子、适用子、单子</em> </a> <em class="hu">从</em> <a class="ae jt" href="https://www.haskell.org/" rel="noopener ugc nofollow" target="_blank"> <em class="hu">哈斯克尔</em> </a> <em class="hu">翻译成</em> <a class="ae jt" href="https://hackernoon.com/tagged/kotlin" rel="noopener ugc nofollow" target="_blank"> <em class="hu">科特林</em> </a> <em class="hu">。</em></p><p id="1f50" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">其实这是一个</em> <a class="ae jt" href="http://www.mokacoding.com/blog/functor-applicative-monads-in-pictures/" rel="noopener ugc nofollow" target="_blank"> <em class="hu">的翻译，另一个是从Haskell到Swift </em> </a> <em class="hu">的翻译。</em></p><p id="da48" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">我通读了最初的帖子，我发现学习FP的新概念真的很有趣，所以我决定做一个额外的翻译(也有一些乐趣)。</p><p id="d591" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">我也想看看科特林和斯威夫特相比能走多远:)</em></p><p id="0e37" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">如果你喜欢这篇文章，一定要在Twitter上感谢原版本的作者:</em><a class="ae jt" href="http://adit.io/index.html" rel="noopener ugc nofollow" target="_blank"><em class="hu">Aditya Bhargava</em></a><em class="hu"/><a class="ae jt" href="https://twitter.com/_egonschiele" rel="noopener ugc nofollow" target="_blank"><em class="hu">@ _ egonschiele</em></a><em class="hu">。</em></p></blockquote><p id="1252" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">这里有一个简单的值:</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div class="fe ff jx"><img src="../Images/81f326dda24642ed8a12d6922451bb76.png" data-original-src="https://miro.medium.com/v2/resize:fit:178/format:webp/0*cWvHYgZpw85fz_QW.png"/></div></figure><p id="0b60" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">我们知道如何对这个值应用一个函数:</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div class="fe ff kf"><img src="../Images/2e0a97ada72f23acc6c34b88b2551d69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/0*XphGzXumvbJTBycX.png"/></div></figure><p id="cba3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">很简单。让我们扩展一下，任何值都可以在上下文中。现在，您可以将上下文视为一个可以放入值的盒子:</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div class="fe ff kg"><img src="../Images/81868662c399e6581ef107292dfb4f3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:320/format:webp/0*7ZPc_kKNSlCqiRXR.png"/></div></figure><p id="5256" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">现在，当你对这个值应用一个函数时，你会得到不同的结果<strong class="ix hv">，这取决于上下文</strong>。这是函子、应用、单子、箭头等都基于的思想。<code class="eh kh ki kj kk b">Option</code>数据类型定义了两个相关的上下文:</p><blockquote class="ir is it"><p id="14a2" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><strong class="ix hv"> <em class="hu">注:</em> </strong> <em class="hu">图片使用的是Haskell的Maybe (Just | None)，对应的是一个自定义的Kotlin的</em>选项<em class="hu"> (Some | None)实现。</em></p></blockquote><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div class="fe ff kl"><img src="../Images/f11872c9e063960150aed809f884a089.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/0*1NCb7mGijOSflxhO.png"/></div></figure><pre class="jy jz ka kb fq km kk kn ko aw kp dt"><span id="6d71" class="kq kr hu kk b fv ks kt l ku kv">sealed class Option&lt;out A&gt; {<br/>  object None : Option&lt;Nothing&gt;()<br/>  data class Some&lt;out A&gt;(val value: A) : Option&lt;A&gt;()<br/>}</span></pre><p id="6a1a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">接下来我们将看到当某个东西是一个<code class="eh kh ki kj kk b">Some(T)</code>和一个<code class="eh kh ki kj kk b">None</code>时，函数应用是如何不同的。首先来说说<a class="ae jt" href="https://hackernoon.com/tagged/functors" rel="noopener ugc nofollow" target="_blank">函子</a>！</p><h1 id="0ca8" class="kw kr hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">函子</h1><p id="38f0" class="pw-post-body-paragraph iu iv hu ix b iy lt ja jb jc lu je jf ju lv ji jj jv lw jm jn jw lx jq jr js hn dt translated">当值被包装在上下文中时，您不能对其应用普通函数:</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div class="fe ff ly"><img src="../Images/489bfdbbf3aecee23027ef4999c94cee.png" data-original-src="https://miro.medium.com/v2/resize:fit:376/format:webp/0*M7c-lRRTz8pKWpN4.png"/></div></figure><p id="fb0e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">这就是<code class="eh kh ki kj kk b">map</code>的用武之地(Haskell中的<code class="eh kh ki kj kk b">fmap</code>)。<code class="eh kh ki kj kk b">map</code>是来自街头，<code class="eh kh ki kj kk b">map</code>是hip to contexts。<code class="eh kh ki kj kk b">map</code>知道如何将函数应用于包含在上下文中的值。例如，假设您要应用一个将3加到<code class="eh kh ki kj kk b">Some(2)</code>的函数。使用<code class="eh kh ki kj kk b">map</code>:</p><pre class="jy jz ka kb fq km kk kn ko aw kp dt"><span id="4f77" class="kq kr hu kk b fv ks kt l ku kv">fun sumThree(n: Int) = n + 3<br/><br/>Option.Some(2).map(::sumThree)<br/>// =&gt; Some(5)</span></pre><p id="2e43" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">或者通过使用匿名lambda的简单语法:</p><pre class="jy jz ka kb fq km kk kn ko aw kp dt"><span id="595d" class="kq kr hu kk b fv ks kt l ku kv">Option.Some(2).map<!-- --> { it + 3 }<br/>// =&gt; Some(5)</span></pre><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="fe ff lz"><img src="../Images/347491fcbad4cae7016cf7de26cce829.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iAU0E7CdHqjfQ9RK.png"/></div></div></figure><p id="5c0a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated"><strong class="ix hv">嘭！</strong> <code class="eh kh ki kj kk b">map</code>向我们展示了它是如何做到的！但是<code class="eh kh ki kj kk b">map</code>怎么知道如何应用函数呢？</p><h1 id="5744" class="kw kr hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">究竟什么是函子？</h1><p id="c10a" class="pw-post-body-paragraph iu iv hu ix b iy lt ja jb jc lu je jf ju lv ji jj jv lw jm jn jw lx jq jr js hn dt translated">函子是定义如何应用<code class="eh kh ki kj kk b">map</code>(Haskell中的<code class="eh kh ki kj kk b">fmap</code>)的任何类型。下面是<code class="eh kh ki kj kk b">map</code>的工作原理:</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div class="fe ff me"><img src="../Images/af44241d1aa59a73660e204cc53b3687.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/0*egb47QB6zSr1jbl2.png"/></div></figure><p id="fe11" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">所以我们可以这样做:</p><pre class="jy jz ka kb fq km kk kn ko aw kp dt"><span id="523b" class="kq kr hu kk b fv ks kt l ku kv">Option.Some(2).map<!-- --> { it + 3 }<br/>// =&gt; Some(5)</span></pre><p id="5f3f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">而<code class="eh kh ki kj kk b">map</code>神奇地应用了这个函数，因为<code class="eh kh ki kj kk b">Option</code>是一个函子。它规定了<code class="eh kh ki kj kk b">map</code>如何应用于<code class="eh kh ki kj kk b">Some</code>和<code class="eh kh ki kj kk b">None</code>s；</p><pre class="jy jz ka kb fq km kk kn ko aw kp dt"><span id="1f1b" class="kq kr hu kk b fv ks kt l ku kv">inline fun &lt;B&gt; map(f: (A) -&gt; B): Option&lt;B&gt; = when (this) {<br/>    is None -&gt; this<br/>    is Some -&gt; Some(f(value))<br/>}</span></pre><p id="689e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">下面是我们写<code class="eh kh ki kj kk b">Option.Some(2).map { it + 3 }</code>时幕后发生的事情:</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="fe ff mf"><img src="../Images/c1d1897dc7e1cb2e0250d1ed83e53013.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2ePtQNke8BGZT5MN.png"/></div></div></figure><p id="d15e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">然后你会想，好吧<code class="eh kh ki kj kk b">map</code>，请将<code class="eh kh ki kj kk b">{ it + 3 }</code>应用于<code class="eh kh ki kj kk b">None</code>？</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div class="fe ff mg"><img src="../Images/731e838c656b965b0942393128f8fe5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/0*w6a1JBnkBrpKlW1N.png"/></div></figure><pre class="jy jz ka kb fq km kk kn ko aw kp dt"><span id="42cf" class="kq kr hu kk b fv ks kt l ku kv">Option.None.map { it + 3 }<br/>// =&gt; None</span></pre><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div class="fe ff mh"><img src="../Images/90eed1b0d2ca29ce49f79cea706f6aba.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/0*HJUxTnL7aNTGmuG-.png"/></div></figure><p id="b019" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">这里有一个问题，因为上面的代码无法编译。为什么？因为在这种情况下，没有一个有合适的类型，所以你不能用类型<code class="eh kh ki kj kk b">Nothing</code>做加法。但这应该没问题，因为您通常不会编写这样的代码，但类似于:</p><pre class="jy jz ka kb fq km kk kn ko aw kp dt"><span id="dec4" class="kq kr hu kk b fv ks kt l ku kv">val option: Option&lt;Int&gt; = someCallThatMightReturnNone()<br/>option.map { it + 3 }<br/>// =&gt; None</span></pre><p id="c9a6" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">就像《黑客帝国》中的墨菲斯一样，<code class="eh kh ki kj kk b">map</code>知道该做什么；你以<code class="eh kh ki kj kk b">None</code>开头，你以<code class="eh kh ki kj kk b">None</code>结尾！<code class="eh kh ki kj kk b">map</code>是禅。现在明白了<code class="eh kh ki kj kk b">Option</code>型为什么存在了。例如，下面是如何在没有<code class="eh kh ki kj kk b">Option</code>的语言中处理数据库记录:</p><pre class="jy jz ka kb fq km kk kn ko aw kp dt"><span id="c08d" class="kq kr hu kk b fv ks kt l ku kv">val post = Post.findByID(1)<br/>return post?.title</span></pre><p id="212e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">但是在Kotlin中使用了<code class="eh kh ki kj kk b">Option</code>仿函数:</p><pre class="jy jz ka kb fq km kk kn ko aw kp dt"><span id="e10b" class="kq kr hu kk b fv ks kt l ku kv">findPost(1).map(::getPostTitle)</span></pre><p id="6023" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">如果<code class="eh kh ki kj kk b">findPost(1)</code>回一个帖子，我们就用<code class="eh kh ki kj kk b">getPostTitle</code>得到标题。如果它返回<code class="eh kh ki kj kk b">None</code>，我们就返回<code class="eh kh ki kj kk b">None</code>！</p><p id="5f71" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">我们甚至可以将<code class="eh kh ki kj kk b">map</code>定义为(Haskell中的<code class="eh kh ki kj kk b">&lt;$&gt;</code>)的中缀函数，这样做:</p><pre class="jy jz ka kb fq km kk kn ko aw kp dt"><span id="bac0" class="kq kr hu kk b fv ks kt l ku kv">inline infix fun &lt;B&gt; map(f: (A) -&gt; B): Option&lt;B&gt; { ... }<br/><br/><em class="iw">findPost</em>(1) map ::getPostTitle</span></pre><blockquote class="ir is it"><p id="3902" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><strong class="ix hv"> <em class="hu">注意:</em> </strong> <em class="hu">我们只能用</em> <code class="eh kh ki kj kk b"><em class="hu">map</em></code> <em class="hu">因为</em> <code class="eh kh ki kj kk b"><em class="hu">&lt;$&gt;</em></code> <em class="hu">不会编译。另一个选择是覆盖一个普通的操作符，如</em> <code class="eh kh ki kj kk b"><em class="hu">/</em></code> <em class="hu">或</em> <code class="eh kh ki kj kk b"><em class="hu">*</em></code></p></blockquote><p id="d9f2" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">这里还有一个例子:当你对一个数组应用一个函数时会发生什么？</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="fe ff mi"><img src="../Images/5ffe305652e0b117d56f73a1f13209d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lcScORdRNawytDNN.png"/></div></div></figure><p id="1c74" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">数组也是函子。</p><p id="53fe" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">*基本上，Kotlin为以下形式的所有iterables提供了一个扩展函数:</p><pre class="jy jz ka kb fq km kk kn ko aw kp dt"><span id="a279" class="kq kr hu kk b fv ks kt l ku kv">inline fun &lt;T, R&gt; Iterable&lt;T&gt;.map(transform: (T) -&gt; R): List&lt;R&gt; {..}</span></pre><p id="5619" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">好吧，好吧，最后一个例子:当你把一个函数应用到另一个函数时会发生什么？</p><pre class="jy jz ka kb fq km kk kn ko aw kp dt"><span id="1a9a" class="kq kr hu kk b fv ks kt l ku kv">{ a: Int -&gt; a + 2 } map { a: Int -&gt; a + 3 }<br/>// =&gt; ???</span></pre><p id="2c16" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">这里有一个函数:</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div class="fe ff mj"><img src="../Images/5d047d247fa58149d89edc09329b2566.png" data-original-src="https://miro.medium.com/v2/resize:fit:594/format:webp/0*fT23UDVq18hzvatb.png"/></div></figure><p id="f769" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">下面是一个应用于另一个函数的函数:</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div class="fe ff mk"><img src="../Images/fec305ea21ba2746c4c8e8751ffa891b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/0*kKizWpvf5xsrDDaj.png"/></div></figure><p id="b49f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">结果只是另一个函数！</p><pre class="jy jz ka kb fq km kk kn ko aw kp dt"><span id="df65" class="kq kr hu kk b fv ks kt l ku kv">typealias IntFunction = (Int) -&gt; Int<br/><br/>infix fun IntFunction.map(g: IntFunction): IntFunction {<br/>    return { x -&gt; this(g(x)) }<br/>}<br/><br/>val foo = { a: Int -&gt; a + 2 } <em class="iw">map </em>{ a: Int -&gt; a + 3 }<strong class="kk hv"><br/></strong>foo(10)<br/>// =&gt; 15</span></pre><p id="7e2f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">所以函数也可以是函子！当你在一个函数上使用<code class="eh kh ki kj kk b">map</code>时，你只是在做函数合成！</p><h2 id="94a2" class="kq kr hu bd kx ml mm mn lb mo mp mq lf ju mr ms lj jv mt mu ln jw mv mw lr mx dt translated">好了，今天就到这里，我希望你已经知道什么是函子了。由于最初的帖子相当长，我将在下一个系列中继续讨论应用程序。现在试着用Kotlin写一些函子！</h2><h2 id="4d32" class="kq kr hu bd kx ml mm mn lb mo mp mq lf ju mr ms lj jv mt mu ln jw mv mw lr mx dt translated">想玩玩代码吗？看一看<a class="ae jt" href="https://github.com/aballano/FAM-Playground" rel="noopener ugc nofollow" target="_blank">https://github.com/aballano/FAM-Playground</a></h2><p id="6ca2" class="pw-post-body-paragraph iu iv hu ix b iy lt ja jb jc lu je jf ju lv ji jj jv lw jm jn jw lx jq jr js hn dt translated">想要更多吗？去试试第二部分中的应用程序吧！</p><div class="my mz fm fo na nb"><a rel="noopener follow" target="_blank" href="/@aballano/kotlin-functors-applicatives-and-monads-in-pictures-part-2-3-f99a09efd1ec"><div class="nc ab ej"><div class="nd ab ne cl cj nf"><h2 class="bd hv fv z el ng eo ep nh er et ht dt translated">图中的科特林函子、应用和单子。第2/3部分</h2><div class="ni l"><h3 class="bd b fv z el ng eo ep nh er et ek translated">这是从Haskell到Kotlin的图片中的函子、应用程序和单子的翻译。</h3></div><div class="nj l"><p class="bd b gc z el ng eo ep nh er et ek translated">medium.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np kd nb"/></div></div></a></div><div class="jy jz ka kb fq ab cb"><figure class="nq kc nr ns nt nu nv paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nq kc nr ns nt nu nv paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nq kc nr ns nt nu nv paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ir is it"><p id="f922" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><a class="ae jt" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jt" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jt" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jt" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jt" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jt" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="fe ff nw"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="nx ny l"/></div></figure></div></div>    
</body>
</html>