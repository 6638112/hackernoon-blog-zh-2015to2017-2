<html>
<head>
<title>File processing in Clojure can easily become CPU bound</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Clojure中的文件处理很容易受到CPU的限制</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/file-processing-in-clojure-can-easily-become-cpu-bound-3c1c38669daf?source=collection_archive---------4-----------------------#2017-03-01">https://medium.com/hackernoon/file-processing-in-clojure-can-easily-become-cpu-bound-3c1c38669daf?source=collection_archive---------4-----------------------#2017-03-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="65c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" rel="noopener" href="/@atroche/an-initial-exploration-of-wikireading-googles-huge-new-nlp-dataset-c17d859db9d0">最近</a>我一直在<a class="ae jp" rel="noopener" href="/@atroche/using-dataflow-in-clojure-to-process-googles-huge-new-wikireading-dataset-832af367539c">玩</a>一个名为<a class="ae jp" href="https://github.com/dmorr-google/wiki-reading" rel="noopener ugc nofollow" target="_blank">维基阅读</a>的大型数据集，谷歌的研究人员在一对<a class="ae jp" href="https://arxiv.org/abs/1608.03542" rel="noopener ugc nofollow" target="_blank">新</a><a class="ae jp" href="https://arxiv.org/abs/1611.01839" rel="noopener ugc nofollow" target="_blank">NLP论文</a>中使用了这个数据集。它由映射到Wikidata语句的Wikipedia文章的文本组成(例如，澳大利亚→(最深点，<a class="ae jp" href="https://www.wikidata.org/wiki/Q179970" rel="noopener ugc nofollow" target="_blank">爱湖</a>))，加起来有208GB的JSON。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/5a27a7c0ebb1df02991ced7b57d8b526.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A9FadghmGFX0iKf_QJpR3g.png"/></div></div></figure><p id="f55f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我最初的目标是通过脸书的<a class="ae jp" href="https://github.com/facebookresearch/fastText" rel="noopener ugc nofollow" target="_blank"> fastText </a>运行它，并将文本分类性能与谷歌的深度学习方法进行比较。所以我将JSON转换成fastText可以使用的格式，当我等待它运行时(它毕竟是快速文本，而不是即时文本)，我发现论文中使用的数据和公开数据之间似乎存在严重差异(以及令人担忧的数据质量问题),这使得很难进行有意义的比较。</p><p id="d2fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">然而</strong>！当我用不同的方法处理这些大型JSON文件时，我无意中发现了一些我觉得很神秘的东西，今天我将尝试解开这个谜，并在这个过程中学习一些东西。</p><p id="221d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我运行了一些<a class="ae jp" href="https://hackernoon.com/tagged/clojure" rel="noopener ugc nofollow" target="_blank"> Clojure </a>代码来读入JSON行，解析它们，进行一些计算，并给出结果图。我使用的计算机(Google计算引擎实例)可以:</p><ul class=""><li id="3bd5" class="kc kd hu it b iu iv iy iz jc ke jg kf jk kg jo kh ki kj kk dt translated">以大约240 MB/秒的速度从磁盘读取</li><li id="a134" class="kc kd hu it b iu kl iy km jc kn jg ko jk kp jo kh ki kj kk dt translated">从RAM中解析1.2GB的JSON(并用它做一些有用的事情)只需要3.7秒，大约324MB/s</li></ul><p id="8a45" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，当我试图在程序中读取磁盘并解析JSON时，我最多只能在21分钟内完成208GB，或者说大约166MB/s。</p><p id="f5e0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我在htop运行时观察了一下，发现内核并没有达到最大限度:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff kq"><img src="../Images/058571051bb6bb94c1f29e6970c9cbff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KR9sm8BwYPHRZR3J.png"/></div></div><figcaption class="kr ks fg fe ff kt ku bd b be z ek">Please ignore the fact that I’m running Clojure as root. I have reasons!</figcaption></figure><p id="ffd9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是iotop显示磁盘吞吐量也不是:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff kv"><img src="../Images/b30a65607190621293148fdd62249dc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yn0rE2lBzQu8QEee.png"/></div></div></figure><p id="b250" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一个问题是:它似乎在240开始处理，然后在大约10秒的时间内，它下降到140。</p><p id="e62a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了彻底起见，下面是JvmTop显示的内存使用情况，看起来不错:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff kw"><img src="../Images/38208202e957eb6798c9896a00b2357a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*N6OFFqymFH3K-chg.png"/></div></div></figure><p id="82e4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">16个核心中有一个快疯了:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff kx"><img src="../Images/563c3d9f81993c6148d0f3e8d073a92a.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/0*aglRGG7EkN1eLJO_.png"/></div></figure><p id="38dc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">瓶颈在那里吗？它到底在做什么？</p><p id="b40b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了回答这个问题，我想暂时离开混乱的现实世界，在我的笔记本电脑上建立一个小工作台，在那里我可以了解磁盘和并行性。</p><p id="e984" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">首先，我的固态硬盘有多快？</strong></p><p id="34f2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我有一个10GB的JSON文件，当我运行</p><blockquote class="ky kz la"><p id="2a19" class="ir is lb it b iu iv iw ix iy iz ja jb lc jd je jf ld jh ji jj le jl jm jn jo hn dt translated">time cat ten.json &gt; /dev/null</p></blockquote><p id="621e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我发现需要6.3秒，那我们就以1750MB/s读取为上限吧。</p><p id="6e13" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">我能多快计算出文件中的行数？</strong></p><p id="ecde" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">内置的<em class="lb"> wc </em>命令耗时~11秒，所以平均约900MB/s。这是我运行wc时活动监视器的截图:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff lf"><img src="../Images/f3be7f7ede01f5c27af32e653950f315.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/0*mQFRnpKOmL6jKmJQ.png"/></div></figure><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff lg"><img src="../Images/29f11f90e43de1c6e0c344e8a9c534e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/0*unzZZDMUbPeBStLq.png"/></div></figure><p id="cd06" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有趣的是，wc <a class="ae jp" href="http://unix.stackexchange.com/questions/96563/why-is-wc-so-slow" rel="noopener ugc nofollow" target="_blank">看起来像是CPU绑定的</a>，这是我在尝试之前没有预料到的。阅读了它的工作原理后，我看到了Brendan Gregg的一篇有趣的博客文章，他展示了他如何使用dtrace将grep + wc的速度提高了2000倍。</p><p id="74f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">反正如果wc能做到900MB/s，Clojure怎么样？</p><p id="91b0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lh li lj lk b">(<strong class="it hv">time </strong>(<strong class="it hv">count </strong>(<strong class="it hv">line-seq </strong>(clojure.java.<strong class="it hv">io/reader </strong>ten-gb-json-file))))</code></p><p id="17bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我的2015年中期MBP上，这需要30秒，并在其中一个内核上显示100%。我们看到的是大约166MB/s，这不是我们想要的。</p><p id="23ca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">出于好奇，我尝试在没有缓冲区的情况下逐字节读取文件:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="3923" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">大约2.5MB/s。缓冲区很重要！上面的代码导致了太多昂贵的系统调用。</p><p id="5e6f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我还尝试删除代码的line-seq部分，它构造了一个惰性序列，只是为了看看它会有什么影响:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="7a08" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它几乎将行计数的速度提高了一倍！但是300MB/s仍然不够好，而且从这个紧密的循环中已经没有多少可以优化的了(我也用类型提示试过了；几乎没什么区别)。为了检查一下Clojure是否有问题，我写了一个Java程序(这是我的第一次！)本质上做同样的事情:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="1241" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">花的时间差不多。</p><p id="03ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此时，我跳到了<a class="ae jp" href="http://docs.oracle.com/javase/7/docs/api/java/io/BufferedReader.html?is-external=true" rel="noopener ugc nofollow" target="_blank"> BufferedReader </a>后面的源代码中。比我想象的要复杂！600行密密麻麻的Java。这让我们想在最基本的IO原语之上编写一个纯Clojure编写的缓冲系统，只是想知道如何去做。但是改天吧！</p><p id="f8d4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以，我很好奇readLine到底在做什么，速度这么慢。在上面的程序运行时，我将YourKit profiler附加到上面的程序中，看到了以下内容:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff ln"><img src="../Images/f9d44c36aa1736686d5e1a22e09d7d08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ecA5Ue1NjSbm9QwH.png"/></div></div></figure><p id="3a75" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">。readLine()在字节进来时对其进行解码，显然这是一件相当昂贵的事情。我可以想象一个系统，它拥有BufferedReader所有合理的缓冲属性，但不进行UTF-8解码，只是将字节交给其他内核处理，这将使它能够从磁盘中获取更多数据。但是好像不存在？我想我得自己写了！(如果不是这样，请告诉我！)</p><p id="63e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有什么方法可以解决这个问题？</p><p id="03ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在阅读了Clojure Cookbook中“用Reducers 并行化文件处理”这个充满希望的名字之后，我尝试将<a class="ae jp" href="https://github.com/thebusby/iota" rel="noopener ugc nofollow" target="_blank"> iota </a>与core.reducers结合使用，然后与<a class="ae jp" href="https://github.com/aphyr/tesser" rel="noopener ugc nofollow" target="_blank"> tesser </a>结合使用。这根本没有带来多大的改善。我希望我知道更多关于内存映射文件的信息，这样我就可以指出原因，但是那将不得不等待下一次。</p><p id="70c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，我尝试分割文件(使用分割命令行工具),这样我可以用pmap并行处理它们:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="ef3c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">9秒！超过1GB/s，比字数还快。这都是因为它能够在不同的线程上运行令人惊讶的CPU密集型读取行。</p><p id="a502" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以！我今天了解到，有了足够快的SSD，对文件进行最基本的处理实际上是CPU受限的。</p><p id="a806" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我很好奇是否有办法用更好地利用多核的东西来取代BufferedReader + readLines。</p><p id="549a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一个有趣的项目是用Rust或C编写一个行计数程序，看看我可以在一个内核上获得什么样的吞吐量。</p><p id="7426" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="lb">【编辑:控制不住自己】</em></p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff lo"><img src="../Images/89c00a777034b80434027ce2f17ed2ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*IGB7aKeouvuQPh6PJbqYBg.png"/></div></figure><div class="jr js jt ju fq ab cb"><figure class="lp jv lq lr ls lt lu paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="lp jv lq lr ls lt lu paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="lp jv lq lr ls lt lu paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ky kz la"><p id="f922" class="ir is lb it b iu iv iw ix iy iz ja jb lc jd je jf ld jh ji jj le jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是阿妹家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is lb it b iu iv iw ix iy iz ja jb lc jd je jf ld jh ji jj le jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff lv"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lw lm l"/></div></figure></div></div>    
</body>
</html>