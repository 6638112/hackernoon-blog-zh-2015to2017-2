<html>
<head>
<title>FunctionCI — Continuous Integration for Serverless Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">FunctionCI —无服务器功能的持续集成</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/functionci-continuous-integration-for-serverless-functions-c20b8a29b49a?source=collection_archive---------23-----------------------#2017-11-13">https://medium.com/hackernoon/functionci-continuous-integration-for-serverless-functions-c20b8a29b49a?source=collection_archive---------23-----------------------#2017-11-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="21f9" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">产品搜索黑客马拉松构建</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/f2f1a65f11f9080d1a6749392e1b34a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jx8n-4dh96NR8CWMeucD1A.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Continuous Integration for Serverless Functions</figcaption></figure><p id="6fe6" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我最近构建了<a class="ae kv" href="https://github.com/rgfindl/functionci" rel="noopener ugc nofollow" target="_blank">函数CI </a>作为<a class="ae kv" href="https://www.producthunt.com/hackathon" rel="noopener ugc nofollow" target="_blank">产品搜索全球黑客马拉松</a>的一部分，以解决我在AWS Lambdas上遇到的一个痛点。特别是持续集成、部署和审计跟踪。在我深入函数之前，让我解释一下什么是持续集成和无服务器Lambda函数。</p><h2 id="3589" class="kw kx hu bd ky kz la lb lc ld le lf lg ki lh li lj km lk ll lm kq ln lo lp lq dt translated">连续累计</h2><p id="94e6" class="pw-post-body-paragraph jz ka hu kb b kc lr iv ke kf ls iy kh ki lt kk kl km lu ko kp kq lv ks kt ku hn dt translated">持续集成是在每次源代码管理提交时合并、构建、测试和打包代码的过程。</p><p id="885c" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这很重要，因为它有助于快速捕捉合并错误。</p><p id="12f4" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">它也有助于审计。如果您的CI工具将源代码控制提交ID与构建工件相关联，您就可以知道在任何时间点运行的代码版本。</p><h2 id="4033" class="kw kx hu bd ky kz la lb lc ld le lf lg ki lh li lj km lk ll lm kq ln lo lp lq dt translated">无服务器Lambda函数</h2><p id="f06d" class="pw-post-body-paragraph jz ka hu kb b kc lr iv ke kf ls iy kh ki lt kk kl km lu ko kp kq lv ks kt ku hn dt translated">AWS Lambda允许您在不提供或管理服务器的情况下运行代码。您只需为您消耗的计算时间付费，当您的代码不运行时，则不收费。有了Lambda，你可以为几乎任何类型的应用程序或后端服务运行代码——所有这些都无需管理。只需上传你的代码，Lambda就会为你的代码提供高可用性的运行和扩展。您可以将代码设置为从其他AWS服务自动触发，或者直接从任何web或移动应用程序调用它。</p><h1 id="cbce" class="lw kx hu bd ky lx ly lz lc ma mb mc lg ja md jb lj jd me je lm jg mf jh lp mg dt translated">函数CI</h1><p id="7748" class="pw-post-body-paragraph jz ka hu kb b kc lr iv ke kf ls iy kh ki lt kk kl km lu ko kp kq lv ks kt ku hn dt translated">FunctionCI是一个开源应用程序，您可以在AWS帐户中运行它来管理您的Lambda函数。</p><ul class=""><li id="6c81" class="mh mi hu kb b kc kd kf kg ki mj km mk kq ml ku mm mn mo mp dt translated">FunctionCI构建、测试、打包和发布您的Lambda函数</li><li id="abe6" class="mh mi hu kb b kc mq kf mr ki ms km mt kq mu ku mm mn mo mp dt translated">构建由AWS CodeBuild和AWS CodePipeline完成</li><li id="ee0f" class="mh mi hu kb b kc mq kf mr ki ms km mt kq mu ku mm mn mo mp dt translated">通过Slack接收构建通知</li><li id="94ad" class="mh mi hu kb b kc mq kf mr ki ms km mt kq mu ku mm mn mo mp dt translated">通过Slack将构建工件部署到Lambda函数中</li><li id="49cd" class="mh mi hu kb b kc mq kf mr ki ms km mt kq mu ku mm mn mo mp dt translated">通过Slack查看构建历史和部署审计跟踪</li></ul><p id="0849" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">FunctionCI是一个Slack bot。与FunctionCI的所有消息和交互都通过您的Slack团队进行。</p><h2 id="b31d" class="kw kx hu bd ky kz la lb lc ld le lf lg ki lh li lj km lk ll lm kq ln lo lp lq dt translated">使用</h2><p id="64a1" class="pw-post-body-paragraph jz ka hu kb b kc lr iv ke kf ls iy kh ki lt kk kl km lu ko kp kq lv ks kt ku hn dt translated">一旦FunctionCI启动并运行，您就可以使用<code class="eh mv mw mx my b">/fn create project</code> Slack命令来创建一个新的构建项目。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mz"><img src="../Images/2354bfd28bb1a224887a22c0a0b7bc29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*WbC3REfgyW87cAJ8YyFjow.png"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">FunctionCI — Create project</figcaption></figure><p id="cf7b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">一旦您的构建版本准备就绪，您将收到以下构建通知。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff na"><img src="../Images/64759a3c7950879b3e2bd40ce0b9e655.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*rDh7r3eXK0tX0INanpLPtQ.png"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">FunctionCI — Build notifications</figcaption></figure><p id="b785" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">然后，您可以使用<code class="eh mv mw mx my b">/fn deploy fn &lt;fn-name&gt; &lt;project-name&gt; &lt;version&gt;</code> Slack命令将构建工件部署到Lambda函数中。</p><p id="95b5" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如果您希望查看最新部署的审计跟踪，您可以使用<code class="eh mv mw mx my b">/fn show fn &lt;fn-name&gt;</code> Slack命令。最棒的是，它还向您显示了谁<strong class="kb hv">做了部署，以及<strong class="kb hv">何时</strong>。</strong></p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff nb"><img src="../Images/49302ef981e39c9861d9469906035b4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*4V7Ar2SO0yk1dhj5NTUW5w.png"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">FunctionCI — Show function</figcaption></figure><p id="2f78" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">您还可以通过<code class="eh mv mw mx my b">/fn show project &lt;project&gt;</code> Slack命令查看最新构建的列表。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff nc"><img src="../Images/32f04d7c94a53ece857cc98c2479d31e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*exB99urrGwFLASIkOTxDVQ.png"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">FunctionCI — Show project</figcaption></figure><p id="f847" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这是FunctionCI的基本用法。</p><p id="0e2f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这是一个示例项目:<a class="ae kv" href="https://github.com/rgfindl/functionci-demo" rel="noopener ugc nofollow" target="_blank">https://github.com/rgfindl/functionci-demo</a></p><h2 id="a897" class="kw kx hu bd ky kz la lb lc ld le lf lg ki lh li lj km lk ll lm kq ln lo lp lq dt translated">体系结构</h2><p id="a9bd" class="pw-post-body-paragraph jz ka hu kb b kc lr iv ke kf ls iy kh ki lt kk kl km lu ko kp kq lv ks kt ku hn dt translated">FunctionCI也是一款无服务器的Lambda app。它包括以下AWS资源:</p><ul class=""><li id="3db7" class="mh mi hu kb b kc kd kf kg ki mj km mk kq ml ku mm mn mo mp dt translated">API网关(为我们的Slack bot公开一个API)</li><li id="b169" class="mh mi hu kb b kc mq kf mr ki ms km mt kq mu ku mm mn mo mp dt translated">Lambda (Slack bot API、SNS事件、CloudWatch事件、代码管道事件)</li><li id="0334" class="mh mi hu kb b kc mq kf mr ki ms km mt kq mu ku mm mn mo mp dt translated">文件存储</li><li id="b12d" class="mh mi hu kb b kc mq kf mr ki ms km mt kq mu ku mm mn mo mp dt translated">S3(构建工件)</li><li id="3e71" class="mh mi hu kb b kc mq kf mr ki ms km mt kq mu ku mm mn mo mp dt translated">CloudFormation(为每个项目构建一个管道)</li><li id="d3a6" class="mh mi hu kb b kc mq kf mr ki ms km mt kq mu ku mm mn mo mp dt translated">代码管道和代码构建(执行构建)</li></ul><p id="d59a" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">对于每个添加到FunctionCI的项目，FunctionCI都会通过CloudFormation创建一个CodePipeline/CodeBuild堆栈。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nd"><img src="../Images/c335a45d1df3ddd2ad617e24dc554f03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EFfNTRTg1KGuGLlVmIVK2w.png"/></div></div></figure><p id="9da6" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">CodePipeline通过Github触发。第一个代码管道阶段是代码构建。CodeBuild构建、测试并打包您的应用程序。最后阶段对构建工件进行版本化和归档。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ne"><img src="../Images/f0b5a015c914300a34252c679058b969.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AlzAPWXIvboR66Bi3J6dbw.png"/></div></div></figure><p id="ee9a" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">既然您所有的提交都被版本化为构建工件，那么您就准备好部署到您的Lambda了。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nf"><img src="../Images/03368db5c6b4e870241e57e653cabb70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DNXNWcgGjPOsd4z36rOisA.png"/></div></div></figure><h2 id="2cff" class="kw kx hu bd ky kz la lb lc ld le lf lg ki lh li lj km lk ll lm kq ln lo lp lq dt translated">设置</h2><p id="f3aa" class="pw-post-body-paragraph jz ka hu kb b kc lr iv ke kf ls iy kh ki lt kk kl km lu ko kp kq lv ks kt ku hn dt translated">如果您希望运行函数CI，设置非常简单。只需遵循以下步骤:</p><ol class=""><li id="0621" class="mh mi hu kb b kc kd kf kg ki mj km mk kq ml ku ng mn mo mp dt translated">派生和克隆<a class="ae kv" href="https://github.com/rgfindl/functionci" rel="noopener ugc nofollow" target="_blank">功能CI </a></li><li id="e5e9" class="mh mi hu kb b kc mq kf mr ki ms km mt kq mu ku ng mn mo mp dt translated">安装<a class="ae kv" href="https://github.com/thestackshack/cim" rel="noopener ugc nofollow" target="_blank"> CIM </a>(云形成实用程序)</li><li id="9d43" class="mh mi hu kb b kc mq kf mr ki ms km mt kq mu ku ng mn mo mp dt translated">安装<a class="ae kv" href="https://github.com/rgfindl/functionci/blob/master/kms/README.md" rel="noopener ugc nofollow" target="_blank"> kms </a>堆栈</li><li id="621e" class="mh mi hu kb b kc mq kf mr ki ms km mt kq mu ku ng mn mo mp dt translated">安装<a class="ae kv" href="https://github.com/rgfindl/functionci/blob/master/app/README.md" rel="noopener ugc nofollow" target="_blank">应用程序</a>堆栈</li></ol></div><div class="ab cl nh ni hc nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="hn ho hp hq hr"><p id="1c04" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">希望FunctionCI能帮你管理好自己的Lambda函数。请告诉我你的想法以及FunctionCI是否对你有帮助。</p></div></div>    
</body>
</html>