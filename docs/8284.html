<html>
<head>
<title>Transmission Architecture (TX)— a Flux alternative</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">传输架构(TX)—通量替代方案</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/transmission-tx-a-flux-alternative-fe0630eed2a3?source=collection_archive---------15-----------------------#2017-11-27">https://medium.com/hackernoon/transmission-tx-a-flux-alternative-fe0630eed2a3?source=collection_archive---------15-----------------------#2017-11-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/9cc6c2ce2859235188dfbf9bddd6603f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RNRRMBwBUD3RnFlmLNBB4A.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">“Transmission” in a nutshell</figcaption></figure><p id="6fa9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><a class="ae ke" href="https://github.com/facebook/flux/tree/master/examples/flux-concepts" rel="noopener ugc nofollow" target="_blank"> Flux architecture </a>旨在使前端开发的复杂性更易于管理。虽然Flux(及其变体，如<a class="ae ke" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>)似乎在消除双向数据绑定的陷阱方面做了很大的工作，但我不禁想知道它是否实际上使事情变得更糟:<strong class="ji hv">许多开发人员花更多的时间试图找出粘合代码(动作、动作创建者、调度器、存储、减少器)，而不是编写实际完成工作的代码</strong>。</p><p id="7a2a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在这里，我提出了Flux和MVC的替代方案。在某种程度上，你可以认为它是两者的混合体。考虑具有以下三个元素的架构:</p><ol class=""><li id="a849" class="kf kg hu ji b jj jk jn jo jr kh jv ki jz kj kd kk kl km kn dt translated">一个完全独立于用户界面的“应用程序引擎”,它封装了所有的业务逻辑和状态，包装在一个API中</li><li id="58eb" class="kf kg hu ji b jj ko jn kp jr kq jv kr jz ks kd kk kl km kn dt translated">一个薄的、无逻辑的“外壳”或接口，公开一个API来控制UI(图形或其他)</li><li id="689f" class="kf kg hu ji b jj ko jn kp jr kq jv kr jz ks kd kk kl km kn dt translated">引擎和外壳之间的“传输”层，通过将<em class="kt">外壳事件映射到引擎API调用</em>，将<em class="kt">引擎事件映射到外壳API调用</em>来连接两者</li></ol><p id="acde" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果您看不出MVC和TX之间的区别，下面的示例代码可能会有所帮助。</p><h2 id="ea7c" class="ku kv hu bd kw kx ky kz la lb lc ld le jr lf lg lh jv li lj lk jz ll lm ln lo dt translated">例子</h2><p id="ac01" class="pw-post-body-paragraph jg jh hu ji b jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd hn dt translated">这里我将只实现一个简单的待办事项应用程序的“创建待办事项”部分。为了证明引擎必须完全独立于用户界面，本例中的用户界面将是一个命令行界面。</p><p id="b48c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">首先，让我们看看<em class="kt"> TodoEngine </em>。它将API实现为简单的函数，这些函数完成它们的任务并发出事件。</p><figure class="lu lv lw lx fq iv"><div class="bz el l di"><div class="ly lz l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">todo-engine.js</figcaption></figure><p id="f673" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">TodoShell(或UI)通过简单地发出事件来对用户交互做出反应(Shell本身什么也不做)。还需要其他东西来监听这些事件，做出决定，并使用其API告诉shell下一步做什么(例如，导航到不同的屏幕，显示错误，向列表中添加项目等)。)</p><p id="e0a6" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">注意，在这个例子中，为了简单起见，API函数名与引擎名相同——不一定是这样。传输可以按照您想要的任何方式映射这两个API。</p><figure class="lu lv lw lx fq iv"><div class="bz el l di"><div class="ly lz l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">todo-shell.js</figcaption></figure><p id="2e34" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">下面是传输层如何连接引擎和外壳。它只包含连接——完全没有逻辑、状态或视图问题。<em class="kt"> onShellEvent() </em>监听shell事件并调用引擎API作为响应。<em class="kt"> onEngineEvent() </em>监听引擎事件并调用shell API作为响应。</p><figure class="lu lv lw lx fq iv"><div class="bz el l di"><div class="ly lz l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">todo-tx.js</figcaption></figure><p id="941a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">下面是运行该应用程序的方法:</p><figure class="lu lv lw lx fq iv"><div class="bz el l di"><div class="ly lz l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">index.js</figcaption></figure><p id="a279" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">完整的源代码:</p><pre class="lu lv lw lx fq ma mb mc md aw me dt"><span id="068f" class="ku kv hu mb b fv mf mg l mh mi">git clone <a class="ae ke" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:hliyan/epc-test.git<br/>cd epc-test<br/>npm install<br/>npm install -g jest<br/>npm test # run unit tests</span><span id="4f50" class="ku kv hu mb b fv mj mg l mh mi">npm start # run the command line app<br/>todo&gt; add hello # how to add a new todo item from the app prompt</span></pre><h2 id="0b72" class="ku kv hu bd kw kx ky kz la lb lc ld le jr lf lg lh jv li lj lk jz ll lm ln lo dt translated">设计目标</h2><ol class=""><li id="d628" class="kf kg hu ji b jj lp jn lq jr mk jv ml jz mm kd kk kl km kn dt translated">防止UI代码中对逻辑函数的任何直接引用，这样UI就可以像逻辑模块(引擎)一样独立开发和测试。UI测试甚至不需要Selenium(因为您有API来驱动它)。</li><li id="6920" class="kf kg hu ji b jj ko jn kp jr kq jv kr jz ks kd kk kl km kn dt translated">具有最少语义的架构——没有动作、存储、减少器、中间件等。只有API函数和事件。</li><li id="9ce5" class="kf kg hu ji b jj ko jn kp jr kq jv kr jz ks kd kk kl km kn dt translated">代码中相对较短、平坦、外观一致的路径。我们选择事件发射来支持异步操作的承诺或回调；使用类似Flux的switch-case语句。</li><li id="3d65" class="kf kg hu ji b jj ko jn kp jr kq jv kr jz ks kd kk kl km kn dt translated">可组合性:对于具有复杂ui和业务逻辑的系统，我们可以并行设置多个Shell-TX-Engine链。</li></ol><h2 id="5c67" class="ku kv hu bd kw kx ky kz la lb lc ld le jr lf lg lh jv li lj lk jz ll lm ln lo dt translated">与React.js一起使用</h2><p id="db1f" class="pw-post-body-paragraph jg jh hu ji b jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd hn dt translated">我还没有一个例子，但基于React的shell相当简单:只需在onClick上触发事件，在界面元素上触发onKey*事件(例如<em class="kt">shell . events . todo _ TEXT _ ENTER _ KEY</em>，并公开一个最终改变组件属性的API(例如<em class="kt">addtotototolist(todo)</em>，<em class="kt">filter list(‘completed’)</em>)。我希望很快能创造出一个<a class="ae ke" href="http://todomvc.com/" rel="noopener ugc nofollow" target="_blank"> TodoMVC </a>的例子。</p><h2 id="237e" class="ku kv hu bd kw kx ky kz la lb lc ld le jr lf lg lh jv li lj lk jz ll lm ln lo dt translated">真实世界的应用</h2><p id="4308" class="pw-post-body-paragraph jg jh hu ji b jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd hn dt translated">我已经有七个开发人员在三个不同的前端应用程序上使用了这个架构的一个更基本的版本。每一个都比以前的Redux实现更成功(编码更容易、更快、更不容易出错、更容易调试)。对于我的下一个项目，我计划完全使用传输架构。当然，我会汇报我的观察和更多的收获。</p><p id="a354" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">鸣谢:感谢<a class="mn mo gr" href="https://medium.com/u/88498c0c40e4?source=post_page-----fe0630eed2a3--------------------------------" rel="noopener" target="_blank">Pasindu Rumal Perera</a>(@ udnisap)对我的工作进行复查并提出改进建议。</p></div></div>    
</body>
</html>