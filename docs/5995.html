<html>
<head>
<title>Kubernetes Adventures on Azure — Part 3 (ACS Engine &amp; Hybrid Cluster)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Azure上的Kubernetes冒险—第3部分(ACS引擎和混合集群)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/kubernetes-adventures-on-azure-part-3-acs-engine-hybrid-cluster-bc453c13b451?source=collection_archive---------13-----------------------#2017-08-28">https://medium.com/hackernoon/kubernetes-adventures-on-azure-part-3-acs-engine-hybrid-cluster-bc453c13b451?source=collection_archive---------13-----------------------#2017-08-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/8dcac0001fbf6400b9e16eaa0e1e535e.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*-0hNhIBAFd_u-3yW7zXi4g.png"/></div></figure><p id="e4ff" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我今天的目标是在微软Azure上安装一个简单的混合Kubernetes集群:</p><ul class=""><li id="bf7f" class="jx jy hu ja b jb jc jf jg jj jz jn ka jr kb jv kc kd ke kf dt translated">1个Linux主机</li><li id="eda3" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">一个Linux代理池中有2个Linux节点</li><li id="5c48" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">WindowsAgentPool中的2个Windows节点</li></ul><p id="c319" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这是当前版本的Azure Container Services无法实现的，但昨天<a class="kl km gr" href="https://medium.com/u/2f3dfd00c443?source=post_page-----bc453c13b451--------------------------------" rel="noopener" target="_blank"> Brendan Burns </a>证实他们正在努力！</p><figure class="ko kp kq kr fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="fe ff kn"><img src="../Images/a98044ba79c535999865bff7e515bdff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j_9eOS19bAQFBZL8qcyu7w.png"/></div></div></figure><p id="b474" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">那么，我们现在如何安装这个集群呢？答案是<a class="ae jw" href="https://github.com/Azure/acs-engine" rel="noopener ugc nofollow" target="_blank"> ACS-Engine </a>这是微软的一个开源项目，它接受“集群定义”作为输入，并返回一个带有附加工件(即kubectl导出文件)的ARM模板作为输出。</p><h2 id="82fb" class="kw kx hu bd ky kz la lb lc ld le lf lg jj lh li lj jn lk ll lm jr ln lo lp lq dt translated">开始吧！</h2><p id="c061" class="pw-post-body-paragraph iy iz hu ja b jb lr jd je jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv hn dt translated">为了使事情更简单，我将重用在第1部分和第2部分中创建的一些工件。</p><ul class=""><li id="9286" class="jx jy hu ja b jb jc jf jg jj jz jn ka jr kb jv kc kd ke kf dt translated">创建一个名为<code class="eh lw lx ly lz b">acs</code>的文件夹来存储您所有的工作工件</li><li id="e8a5" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">克隆ACS引擎库:<code class="eh lw lx ly lz b">git clone <a class="ae jw" href="https://github.com/Azure/acs-engine" rel="noopener ugc nofollow" target="_blank">https://github.com/Azure/acs-engine</a></code></li><li id="8588" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">进入示例文件夹:<code class="eh lw lx ly lz b">cd acs-engine/examples</code>，在那里你可以找到许多集群定义的例子。这里你可以看到一个<code class="eh lw lx ly lz b">windows</code>文件夹，它包含了需要的定义:<code class="eh lw lx ly lz b">kubernetes-hybrid.json</code></li></ul><p id="654f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">重要提示</strong>:当前<a class="ae jw" href="https://github.com/Azure/acs-engine/releases/tag/v0.5.0" rel="noopener ugc nofollow" target="_blank">版本0.5.0 </a>存在一个<a class="ae jw" href="https://github.com/Azure/acs-engine/issues/1359" rel="noopener ugc nofollow" target="_blank">问题</a>，导致源代码中的示例与其不兼容(它们更新更多)。这里我们有两个解决方案:</p><ul class=""><li id="48b1" class="jx jy hu ja b jb jc jf jg jj jz jn ka jr kb jv kc kd ke kf dt translated">复杂:在本地编译一个新版本</li><li id="b3e0" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated"><strong class="ja hv">简单</strong>:更改示例，使其与旧版本兼容</li></ul><p id="cb15" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们就选复杂的！开玩笑……我跟踪了这个复杂的东西，但是目前在macOS上它并不简单，因为你需要在＄GOPATH/src中克隆acs-engine源代码，并且需要一个单独的文章。所以让我们来看看简单的解决方案。</p><ul class=""><li id="74cc" class="jx jy hu ja b jb jc jf jg jj jz jn ka jr kb jv kc kd ke kf dt translated">在您最喜欢的编辑器中打开<code class="eh lw lx ly lz b">kubernets-hybrid.json</code>文件，并更改下面的行</li></ul><p id="4b31" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">出发地:</p><pre class="ko kp kq kr fq ma lz mb mc aw md dt"><span id="1ac4" class="kw kx hu lz b fv me mf l mg mh">"servicePrincipalProfile": {<br/>  "clientId": "",<br/>  "secret": ""<br/>}</span></pre><p id="beea" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">收件人:</p><pre class="ko kp kq kr fq ma lz mb mc aw md dt"><span id="87f0" class="kw kx hu lz b fv me mf l mg mh">"servicePrincipalProfile": {<br/>  "<strong class="lz hv">servicePrincipalClientID</strong>": "",<br/>  "<strong class="lz hv">servicePrincipalClientSecret</strong>": ""<br/>}</span></pre><p id="4e36" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">等等，不要关闭文件！我们想在集群中使用最新的Kubernetes版本，对吗？所以加粗一行:</p><pre class="ko kp kq kr fq ma lz mb mc aw md dt"><span id="46ea" class="kw kx hu lz b fv me mf l mg mh">"orchestratorProfile": {<br/>  "orchestratorType": "Kubernetes",<br/>  <strong class="lz hv">"orchestratorVersion": "1.7.2"</strong><br/>},</span></pre><p id="7337" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们可以按照<a class="ae jw" href="https://github.com/Azure/acs-engine/blob/master/docs/kubernetes/deploy.md" rel="noopener ugc nofollow" target="_blank">部署一个Kubernetes集群</a>中的步骤，它描述了一种<strong class="ja hv">短</strong>和<strong class="ja hv">长</strong>的方式来部署您的集群。</p><h2 id="c684" class="kw kx hu bd ky kz la lb lc ld le lf lg jj lh li lj jn lk ll lm jr ln lo lp lq dt translated">短程缺点</h2><p id="0792" class="pw-post-body-paragraph iy iz hu ja b jb lr jd je jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv hn dt translated">在这里，我们将按照简短的方式，但在开始之前，我想强调这里的一些缺点:</p><ul class=""><li id="5637" class="jx jy hu ja b jb jc jf jg jj jz jn ka jr kb jv kc kd ke kf dt translated">DNS前缀:一个随机数将被添加到作为参数传递的前缀中，以使其唯一</li><li id="5b62" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">每次运行deploy命令时，将在您的订阅上创建一个新的应用程序(ServicePrincipal ),当您删除ResourceGroup时，该应用程序将保留在订阅上，因为它不是resource group的一部分</li><li id="08c7" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">将为部署创建一个新的SSH密钥对</li></ul><p id="5d6a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">解决方案1 </strong>:我们可以避免所有这些缺点，只需创建一次工件(应用程序、SSH密钥对、DNS)并将它们的值添加到用于部署的模板json文件中。我会为了宋承宪这样做。</p><p id="d821" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">解决方案2 </strong>:在第一次部署结束时，acs-engine用生成的工件生成一个_output文件夹。这里有一个名为<strong class="ja hv">azure deploy . parameters . JSON</strong>的文件，它包含可以在所使用的集群定义文件中复制的所有参数值。仅此而已。</p><h2 id="6159" class="kw kx hu bd ky kz la lb lc ld le lf lg jj lh li lj jn lk ll lm jr ln lo lp lq dt translated">部署</h2><p id="275c" class="pw-post-body-paragraph iy iz hu ja b jb lr jd je jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv hn dt translated">在本文的前几部分，我创建了一个SSH密钥对，我想使用它而不是生成一个新的。这可以通过复制。json文件下面部分的pub文件。下一步将跳过ssh密钥对的生成，因为已经在模板中找到了。</p><pre class="ko kp kq kr fq ma lz mb mc aw md dt"><span id="629c" class="kw kx hu lz b fv me mf l mg mh">"linuxProfile": {<br/>  "adminUsername": "azureuser",<br/>  "ssh": {<br/>    "publicKeys": [<br/>      {<br/>        "keyData": "YOURKEY starts with ssh-rsa"<br/>      }<br/>    ]<br/>  }<br/>},</span></pre><p id="046c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">对于部署，您需要您正在使用的订阅id，该id可以通过<code class="eh lw lx ly lz b">az account show</code>轻松检索</p><p id="fcee" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">。/ACS-engine deploy-subscription-id your subscription id where-DNS-prefix ivank8 stest-location westeurope-auto-suffix-API-model ~/ACS/ACS-engine/examples/windows/kubernetes-hybrid . JSON</p><p id="06e5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">注意</strong>:如果你想避免传递dns前缀作为参数，你可以把它添加到template.json文件中，就像我们对<code class="eh lw lx ly lz b">keyData</code>所做的一样，同样的技巧可以用于文件中的任何元素。acs-engine足够智能，如果有数据，可以跳过这些步骤。即ServicePrincipalProfile创建。</p><p id="baa2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果一切顺利，您应该会看到如下内容:</p><pre class="ko kp kq kr fq ma lz mb mc aw md dt"><span id="2e5f" class="kw kx hu lz b fv me mf l mg mh">WARN[0002] apimodel: missing masterProfile.dnsPrefix will use “ivank8stest-59a13555”<br/>WARN[0002] apimodel: ServicePrincipalProfile was missing or empty, creating application…<br/>WARN[0004] created application with applicationID (11111111-048e-420f-afad-1fe450036077) and servicePrincipalObjectID (22222222-b0fb-4395–9576–6bb18481f88f).<br/>WARN[0004] apimodel: ServicePrincipalProfile was empty, assigning role to application…<br/>INFO[0030] Starting ARM Deployment (myAcsTest-1222046555). This will take some time…</span></pre><figure class="ko kp kq kr fq iv fe ff paragraph-image"><div class="fe ff mi"><img src="../Images/eb3a72a9ecd1c1a19c6fdfd95217fb66.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*-tK9BJzI1FhxXiw6urHwqQ.jpeg"/></div><figcaption class="mj mk fg fe ff ml mm bd b be z ek">Coffee break is needed!</figcaption></figure><p id="6df0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv"> INFO[0526]已完成ARM部署(myacstest 2–676730522)。</strong></p><p id="65ab" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们做到了！我们的混合Kubernetes集群似乎已经开始运行了！让我们现在测试它。</p><h2 id="e362" class="kw kx hu bd ky kz la lb lc ld le lf lg jj lh li lj jn lk ll lm jr ln lo lp lq dt translated">连接到您的Kubernetes集群</h2><p id="7b33" class="pw-post-body-paragraph iy iz hu ja b jb lr jd je jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv hn dt translated">部署完成后，您应该有一个<code class="eh lw lx ly lz b">_output</code>文件夹，其中有一个名为超级集群的dns前缀的子文件夹。进去吧。</p><p id="9c78" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">它包含由acs-engine生成的工件，并且如步骤9中的<a class="ae jw" href="https://github.com/Azure/acs-engine/blob/master/docs/kubernetes/walkthrough.md" rel="noopener ugc nofollow" target="_blank">所述<code class="eh lw lx ly lz b">kubeconfig</code>对我们非常有用。我会尽量让它超级简单。</a></p><p id="6706" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">从您的终端运行以下命令指向您的_output文件夹</p><pre class="ko kp kq kr fq ma lz mb mc aw md dt"><span id="9bf7" class="kw kx hu lz b fv me mf l mg mh">export KUBECONFIG=~/acs/acs-engine/_output/ivank8stest-59a13ac6/kubeconfig/kubeconfig.westeurope.json<br/>kubectl get nodes</span><span id="d87d" class="kw kx hu lz b fv mn mf l mg mh">NAME                        STATUS                        AGE       VERSION<br/>23586acs9010                Ready                         1s        v1.7.2-4+b0c9ea2463aba4<br/>23586acs9011                Ready                         3s        v1.7.2-4+b0c9ea2463aba4<br/>k8s-linuxpool1-23586643-0   NotReady                      2s        v1.7.2<br/>k8s-linuxpool1-23586643-1   NotReady                      5s        v1.7.2<br/>k8s-master-23586643-0       NotReady,SchedulingDisabled   7s        v1.7.2</span></pre><p id="c51c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">它已经启动并运行了，我们可以在本地的kubectl上使用它！</p><figure class="ko kp kq kr fq iv fe ff paragraph-image"><div class="fe ff mo"><img src="../Images/f5cfeedb26cc5f91cc2908fd7adae8e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*1xNQX7EXkgL265j8ztTidA.jpeg"/></div></figure><p id="a8cb" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">一切都准备好了，让我们试着部署一些Linux和Windows容器吧！</p><h2 id="dfdd" class="kw kx hu bd ky kz la lb lc ld le lf lg jj lh li lj jn lk ll lm jr ln lo lp lq dt translated"><strong class="ak"> Linux容器</strong></h2><p id="ea59" class="pw-post-body-paragraph iy iz hu ja b jb lr jd je jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv hn dt translated">我们将部署与第1部分中部署的相同的azure vote应用程序，但是对部署在os:linux节点上所需的yaml文件做了一些小的修改。</p><p id="a3c5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">下面是azure-vote.yaml文件的内容，其中突出显示了更改:</p><pre class="ko kp kq kr fq ma lz mb mc aw md dt"><span id="b14c" class="kw kx hu lz b fv me mf l mg mh">apiVersion: apps/v1beta1<br/>kind: Deployment<br/>metadata:<br/>  name: azure-vote-back<br/>spec:<br/>  replicas: 1<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: azure-vote-back<br/>    spec:<br/>      containers:<br/>      - name: azure-vote-back<br/>        image: redis<br/>        ports:<br/>        — containerPort: 6379<br/>          name: redis<br/><strong class="lz hv">      nodeSelector:<br/>        beta.kubernetes.io/os: linux</strong><br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: azure-vote-back<br/>spec:<br/>  ports:<br/>  — port: 6379<br/>  selector:<br/>    app: azure-vote-back<br/>---<br/>apiVersion: apps/v1beta1<br/>kind: Deployment<br/>metadata:<br/>  name: azure-vote-front<br/>spec:<br/>  replicas: 1<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: azure-vote-front<br/>    spec:<br/>      containers:<br/>      — name: azure-vote-front<br/>        image: microsoft/azure-vote-front:redis-v1<br/>        ports:<br/>        — containerPort: 80<br/>        env:<br/>        — name: REDIS<br/>          value: "azure-vote-back"<br/><strong class="lz hv">      nodeSelector:<br/>        beta.kubernetes.io/os: linux<br/></strong>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: azure-vote-front<br/>spec:<br/>  type: LoadBalancer<br/>  ports:<br/>  — port: 80<br/>  selector:<br/>    app: azure-vote-front</span></pre><p id="16ef" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">您现在可以使用<code class="eh lw lx ly lz b">kubectl create -f azure-vote.yaml</code>来部署它</p><p id="fb84" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让Kubernetes继续工作，让我们转移到…</p><h2 id="de34" class="kw kx hu bd ky kz la lb lc ld le lf lg jj lh li lj jn lk ll lm jr ln lo lp lq dt translated"><strong class="ak"> Windows容器</strong></h2><p id="a866" class="pw-post-body-paragraph iy iz hu ja b jb lr jd je jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv hn dt translated">这里我们将使用来自第2部分的工件，但是压缩在一个描述整个部署的iisdeploymentfull.yaml文件中。</p><pre class="ko kp kq kr fq ma lz mb mc aw md dt"><span id="0b1e" class="kw kx hu lz b fv me mf l mg mh">apiVersion: apps/v1beta1<br/>kind: Deployment<br/>metadata:<br/>  name: iis<br/>spec<br/>  replicas: 2<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: iis<br/>    spec:<br/>      containers:<br/>      - name: iis<br/>        image: microsoft/iis<br/>        ports:<br/>        - containerPort: 80<br/>          name: iis<br/>      nodeSelector:<br/>        beta.kubernetes.io/os: windows  <br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: iis<br/>spec:<br/>  ports:<br/>  - port: 80<br/>  selector:<br/>    app: iis</span></pre><p id="f310" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">同样，我们可以使用<code class="eh lw lx ly lz b">kubectl create -f iisdeploymentfull.yaml</code>来部署它</p><p id="0af2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，我们需要等待几分钟，让一切正常运行。</p><h2 id="d44a" class="kw kx hu bd ky kz la lb lc ld le lf lg jj lh li lj jn lk ll lm jr ln lo lp lq dt translated">从Kubernetes仪表板检查状态</h2><p id="2e94" class="pw-post-body-paragraph iy iz hu ja b jb lr jd je jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv hn dt translated">通过常用的代理渠道:<code class="eh lw lx ly lz b">kubectl proxy</code>连接到您的Kubernetes仪表盘，打开浏览器:<code class="eh lw lx ly lz b">http://127.0.0.1:8001/ui</code></p><p id="c5bf" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在这里，您可以随意浏览各个部分，以检查您的集群、pod、部署和服务的状态。</p><p id="22a0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">从服务中，您将能够检索可用于测试iis和azure-vote部署的外部端点。</p><figure class="ko kp kq kr fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="fe ff mp"><img src="../Images/0726b754246e365a931c1272b694ba45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sTdndYU-HBJg6pdOfk_29Q.png"/></div></div></figure><p id="4dba" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们以快速扩展两种部署来推动我们的群集来结束本文:</p><p id="7fa0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><code class="eh lw lx ly lz b">kubectl scale deployments/azure-vote-front --replicas 100</code></p><p id="9e1b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><code class="eh lw lx ly lz b">kubectl scale deployments/iis --replicas 4</code></p><p id="5230" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">最终结果:</p><figure class="ko kp kq kr fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="fe ff mq"><img src="../Images/25af0c8e7928d246065e25d34369f94c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZXVcfbl3gptLM7_bwnCP4Q.png"/></div></div><figcaption class="mj mk fg fe ff ml mm bd b be z ek">Kubernetes Hybrid Cluster running on Microsoft Azure</figcaption></figure><p id="51c8" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">像往常一样，你可以用一个简单的Azure CLI 2命令删除一切:<code class="eh lw lx ly lz b">az group delete --name myAcsTest --yes --no-wait</code></p><p id="086d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们又做到了！现在我们是Azure Kubernetes的主人，我们可以轻松地部署我们想要的任何东西！</p><p id="8e66" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我的冒险将继续，在Linux和Windows节点上分发ingress，监控，Azure上的Autoscale等等。</p><figure class="ko kp kq kr fq iv"><div class="bz el l di"><div class="mr ms l"/></div></figure></div></div>    
</body>
</html>