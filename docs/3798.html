<html>
<head>
<title>Create lean Node.js image with Docker multi-stage build</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker多阶段构建创建精益Node.js映像</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/create-lean-node-js-image-with-docker-multi-stage-build-252e927cbf3e?source=collection_archive---------7-----------------------#2017-04-24">https://medium.com/hackernoon/create-lean-node-js-image-with-docker-multi-stage-build-252e927cbf3e?source=collection_archive---------7-----------------------#2017-04-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="f416" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从<a class="ae jp" href="https://hackernoon.com/tagged/docker" rel="noopener ugc nofollow" target="_blank"> Docker </a> <strong class="it hv"> 17.05+ </strong>开始，你可以创建一个单独的<code class="eh jq jr js jt b">Dockerfile</code>，它可以用编译器、<a class="ae jp" href="https://hackernoon.com/tagged/tools" rel="noopener ugc nofollow" target="_blank">工具</a>构建多个辅助映像，并测试和使用来自上述映像的文件来生成<strong class="it hv">最终的</strong> Docker映像。</p><figure class="jv jw jx jy fq jz fe ff paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="fe ff ju"><img src="../Images/d76999c37449074429103bcf330c96be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aTJT_LcNdbF3IVCAvLWuTA.png"/></div></div></figure><h1 id="9198" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">Dockerfile的“核心原则”</h1><p id="4777" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">Docker可以通过读取来自<code class="eh jq jr js jt b">Dockerfile</code>的指令来构建图像。一个<code class="eh jq jr js jt b">Dockerfile</code>是一个文本文件，包含构建一个新的Docker映像所需的所有命令的列表。<code class="eh jq jr js jt b">Dockerfile</code>的语法非常简单，Docker团队试图在Docker引擎发布之间保持它的完整性。</p><p id="b8c5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">核心原理很简单:<code class="eh jq jr js jt b">1 Dockerfile -&gt; 1 Docker Image</code>。</p><p id="7cbd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个原则非常适合基本的用例，在这些用例中，您只需要展示Docker的功能或者将一些“静态”内容放入Docker图像中。</p><p id="7580" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦你使用Docker并想要创建安全和精简的Docker映像，一个<code class="eh jq jr js jt b">Dockerfile</code>是不够的。</p><p id="ab29" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">坚持遵循上述原则的人发现他们自己有缓慢的Docker构建、巨大的Docker映像(几GB大小的映像)、缓慢的部署时间和嵌入到这些映像中的大量CVE违规。</p><h1 id="41d0" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">Docker构建容器模式</h1><p id="2b89" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated"><a class="ae jp" rel="noopener" href="/@alexeiled/docker-pattern-the-build-container-b0d0e86ad601"> Docker模式:构建容器</a></p><p id="35ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">构建容器</strong>模式背后的基本思想很简单:</p><blockquote class="lj lk ll"><p id="dd2a" class="ir is lm it b iu iv iw ix iy iz ja jb ln jd je jf lo jh ji jj lp jl jm jn jo hn dt translated"><em class="hu">使用所需的工具(编译器、linters、测试工具)创建额外的Docker映像，并使用这些映像生成精简、安全且生产就绪的Docker映像。</em></p></blockquote><p id="75d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">典型Node.js应用程序的<strong class="it hv">构建容器</strong>模式示例:</p><ol class=""><li id="5dde" class="lq lr hu it b iu iv iy iz jc ls jg lt jk lu jo lv lw lx ly dt translated">派生<code class="eh jq jr js jt b">FROM</code>一个节点基础映像(例如<code class="eh jq jr js jt b">node:6.10-alpine</code> ) <code class="eh jq jr js jt b">node</code>和<code class="eh jq jr js jt b">npm</code>已安装(<code class="eh jq jr js jt b">Dockerfile.build</code>)</li><li id="cfeb" class="lq lr hu it b iu lz iy ma jc mb jg mc jk md jo lv lw lx ly dt translated">添加<code class="eh jq jr js jt b">package.json</code></li><li id="77f5" class="lq lr hu it b iu lz iy ma jc mb jg mc jk md jo lv lw lx ly dt translated">从<code class="eh jq jr js jt b">dependency</code>和<code class="eh jq jr js jt b">devDependency</code>安装所有节点模块</li><li id="d2cd" class="lq lr hu it b iu lz iy ma jc mb jg mc jk md jo lv lw lx ly dt translated">复制应用程序代码</li><li id="ed39" class="lq lr hu it b iu lz iy ma jc mb jg mc jk md jo lv lw lx ly dt translated">运行编译器、代码覆盖率、linters、代码分析和测试工具</li><li id="7dbf" class="lq lr hu it b iu lz iy ma jc mb jg mc jk md jo lv lw lx ly dt translated">创建<strong class="it hv">生产</strong>码头工人形象；派生<code class="eh jq jr js jt b">FROM</code>相同或其他节点基础映像</li><li id="9d44" class="lq lr hu it b iu lz iy ma jc mb jg mc jk md jo lv lw lx ly dt translated">安装运行时所需的节点模块(<code class="eh jq jr js jt b">npm install --only=production</code>)</li><li id="c9dd" class="lq lr hu it b iu lz iy ma jc mb jg mc jk md jo lv lw lx ly dt translated">公开<code class="eh jq jr js jt b">PORT</code>并定义默认的<code class="eh jq jr js jt b">CMD</code>(运行应用程序的命令)</li><li id="66e1" class="lq lr hu it b iu lz iy ma jc mb jg mc jk md jo lv lw lx ly dt translated">将<strong class="it hv">生产</strong>映像推送到某个Docker注册表</li></ol><p id="7bf6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个流程假设您使用两个或更多的<code class="eh jq jr js jt b">Dockerfile</code>和一个shell脚本或流程工具来编排上面的所有步骤。</p><h1 id="51ca" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">例子</h1><p id="23ea" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">我用的是<a class="ae jp" href="https://github.com/sdelements/lets-chat" rel="noopener ugc nofollow" target="_blank"> Let's Chat </a> node.js应用的一个分叉。</p><h2 id="087b" class="me kh hu bd ki mf mg mh km mi mj mk kq jc ml mm ku jg mn mo ky jk mp mq lc mr dt translated">带有eslint、摩卡和gulp的构建者Docker图像</h2><pre class="jv jw jx jy fq ms jt mt mu aw mv dt"><span id="dbeb" class="me kh hu jt b fv mw mx l my mz">FROM alpine:3.5<br/># install node <br/>RUN apk add --no-cache nodejs<br/># set working directory<br/>WORKDIR /root/chat<br/># copy project file<br/>COPY package.json .<br/># install node packages<br/>RUN npm set progress=false &amp;&amp; \<br/>    npm config set depth 0 &amp;&amp; \<br/>    npm install<br/># copy app files<br/>COPY . .<br/># run linter, setup and tests<br/>CMD npm run lint &amp;&amp; npm run setup &amp;&amp; npm run test</span></pre><h2 id="4135" class="me kh hu bd ki mf mg mh km mi mj mk kq jc ml mm ku jg mn mo ky jk mp mq lc mr dt translated">仅带有“生产”节点模块的生产停靠站映像</h2><pre class="jv jw jx jy fq ms jt mt mu aw mv dt"><span id="6933" class="me kh hu jt b fv mw mx l my mz">FROM alpine:3.5<br/> <br/># install node<br/>RUN apk add --no-cache nodejs tini<br/># set working directory<br/>WORKDIR /root/chat<br/># copy project file<br/>COPY package.json .<br/># install node packages<br/>RUN npm set progress=false &amp;&amp; \<br/>    npm config set depth 0 &amp;&amp; \<br/>    npm install --only=production &amp;&amp; \<br/>    npm cache clean<br/># copy app files<br/>COPY . .<br/># Set tini as entrypoint<br/>ENTRYPOINT [“/sbin/tini”, “--”]<br/># application server port<br/>EXPOSE 5000<br/># default run command<br/>CMD npm run start</span></pre><h1 id="b700" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">什么是Docker多阶段构建？</h1><p id="68e0" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">Docker 17.0.5通过扩展两个命令:<code class="eh jq jr js jt b">FROM</code>和<code class="eh jq jr js jt b">COPY</code>，扩展了<code class="eh jq jr js jt b">Dockerfile</code>语法以支持新的<strong class="it hv">多阶段</strong>构建。</p><p id="acfd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">多阶段</strong>构建允许在同一个Dockerfile文件中使用多个<code class="eh jq jr js jt b">FROM</code>命令。最后的<code class="eh jq jr js jt b">FROM</code>命令产生最终的Docker图像，所有其他图像都是中间图像(不产生最终的Docker图像，但是<em class="lm">所有层都被缓存</em>)。</p><p id="e592" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jq jr js jt b">FROM</code>语法也支持<code class="eh jq jr js jt b">AS</code>关键字。使用<code class="eh jq jr js jt b">AS</code>关键字给当前图像一个逻辑名称，并通过该名称引用它。</p><p id="2121" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用<code class="eh jq jr js jt b">COPY --from=&lt;image_AS_name|image_number&gt;</code>从中间映像复制文件，其中数字从<code class="eh jq jr js jt b">0</code>开始(但最好通过<code class="eh jq jr js jt b">AS</code>关键字使用逻辑名称)。</p><h1 id="96d8" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">为Node.js应用程序创建多阶段docker文件</h1><p id="730a" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">下面的<code class="eh jq jr js jt b">Dockerfile</code>使<strong class="it hv">构建容器</strong>模式过时，允许用单个文件实现相同的结果。</p><pre class="jv jw jx jy fq ms jt mt mu aw mv dt"><span id="db78" class="me kh hu jt b fv mw mx l my mz">#<br/># ---- Base Node ----<br/>FROM alpine:3.5 AS base<br/># install node<br/>RUN apk add --no-cache nodejs-npm tini<br/># set working directory<br/>WORKDIR /root/chat<br/># Set tini as entrypoint<br/>ENTRYPOINT ["/sbin/tini", "--"]<br/># copy project file<br/>COPY package.json .<br/> <br/>#<br/># ---- Dependencies ----<br/>FROM base AS dependencies<br/># install node packages<br/>RUN npm set progress=false &amp;&amp; npm config set depth 0<br/>RUN npm install --only=production <br/># copy production node_modules aside<br/>RUN cp -R node_modules prod_node_modules<br/># install ALL node_modules, including 'devDependencies'<br/>RUN npm install<br/> <br/>#<br/># ---- Test ----<br/># run linters, setup and tests<br/>FROM dependencies AS test<br/>COPY . .<br/>RUN  npm run lint &amp;&amp; npm run setup &amp;&amp; npm run test<br/> <br/>#<br/># ---- Release ----<br/>FROM base AS release<br/># copy production node_modules<br/>COPY --from=dependencies /root/chat/prod_node_modules ./node_modules<br/># copy app sources<br/>COPY . .<br/># expose port and define CMD<br/>EXPOSE 5000<br/>CMD npm run start</span></pre><p id="6ffe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以上<code class="eh jq jr js jt b">Dockerfile</code>创建了3个中间Docker图像和单个<strong class="it hv"> release </strong> Docker图像(最终<code class="eh jq jr js jt b">FROM</code>)。</p><ol class=""><li id="2624" class="lq lr hu it b iu iv iy iz jc ls jg lt jk lu jo lv lw lx ly dt translated">第一个图像<code class="eh jq jr js jt b">FROM alpine:3.5 AS base</code>–是一个基本节点图像，包含:<code class="eh jq jr js jt b">node</code>、<code class="eh jq jr js jt b">npm</code>、<code class="eh jq jr js jt b">tini</code>(初始化应用程序)和<code class="eh jq jr js jt b">package.json</code></li><li id="27dc" class="lq lr hu it b iu lz iy ma jc mb jg mc jk md jo lv lw lx ly dt translated">第二个映像<code class="eh jq jr js jt b">FROM base AS dependencies</code>–包含来自<code class="eh jq jr js jt b">dependencies</code>和<code class="eh jq jr js jt b">devDependencies</code>的所有节点模块，仅最终映像需要<code class="eh jq jr js jt b">dependencies</code>的额外副本</li><li id="4c6a" class="lq lr hu it b iu lz iy ma jc mb jg mc jk md jo lv lw lx ly dt translated">第三张图片<code class="eh jq jr js jt b">FROM dependencies AS test</code>——运行棉绒机，设置和测试(用<code class="eh jq jr js jt b">mocha</code>)；如果该运行命令失败，则不会生成最终图像</li><li id="dd10" class="lq lr hu it b iu lz iy ma jc mb jg mc jk md jo lv lw lx ly dt translated">最后一个映像<code class="eh jq jr js jt b">FROM base AS release</code>–是一个基本节点映像，包含来自<code class="eh jq jr js jt b">dependencies</code>的应用程序代码和所有节点模块</li></ol><h1 id="7085" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">立即尝试Docker多阶段构建</h1><p id="3a3f" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">为了尝试Docker <strong class="it hv">多阶段</strong> build，你需要获得Docker 17.0.5，该版本将于5月发布，目前已在<em class="lm"> beta </em>频道发售。</p><p id="b77a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以，你有两个选择:</p><ol class=""><li id="3897" class="lq lr hu it b iu iv iy iz jc ls jg lt jk lu jo lv lw lx ly dt translated">使用<em class="lm"> beta </em>通道获取Docker 17.0.5</li><li id="f940" class="lq lr hu it b iu lz iy ma jc mb jg mc jk md jo lv lw lx ly dt translated">运行<em class="lm">和</em>容器(对接器中的对接器)</li></ol><h1 id="0f79" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">运行Docker-in-Docker 17.0.5(测试版)</h1><p id="fb12" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">在Docker容器中运行Docker 17.0.5(测试版)(需要<code class="eh jq jr js jt b">--privileged</code>):</p><pre class="jv jw jx jy fq ms jt mt mu aw mv dt"><span id="566b" class="me kh hu jt b fv mw mx l my mz">$ docker run -d --rm --privileged -p 23751:2375 --name dind \ <br/>         docker:17.05.0-ce-dind --storage-driver overlay2</span></pre><p id="60e2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尝试<strong class="it hv">多阶段</strong>构建。将<code class="eh jq jr js jt b">--host=:23751</code>添加到每个Docker命令中，或者设置<code class="eh jq jr js jt b">DOCKER_HOST</code>环境变量。</p><pre class="jv jw jx jy fq ms jt mt mu aw mv dt"><span id="2385" class="me kh hu jt b fv mw mx l my mz">$ # using --host<br/>$ docker --host=:23751 build -t local/chat:multi-stage .<br/> <br/>$ # OR: setting DOCKER_HOST<br/>$ export DOCKER_HOST=localhost:23751<br/>$ docker build -t local/chat:multi-stage .</span></pre><h1 id="8551" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">摘要</h1><p id="1e6c" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">借助Docker <strong class="it hv">多阶段</strong>构建特性，可以使用单个Docker文件实现高级Docker映像构建流水线。</p><p id="c7f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Docker团队如此有用的功能值得称赞！</p><p id="9663" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">希望，你觉得这篇帖子有用。我期待您的评论和任何问题。</p></div><div class="ab cl na nb hc nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="hn ho hp hq hr"><p id="2b94" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="lm">原载于2017年4月24日</em><a class="ae jp" href="https://codefresh.io/blog/node_docker_multistage/" rel="noopener ugc nofollow" target="_blank"><em class="lm">code fresh . io</em></a><em class="lm">。</em></p><div class="jv jw jx jy fq ab cb"><figure class="nh jz ni nj nk nl nm paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nh jz ni nj nk nl nm paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nh jz ni nj nk nl nm paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="lj lk ll"><p id="f922" class="ir is lm it b iu iv iw ix iy iz ja jb ln jd je jf lo jh ji jj lp jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is lm it b iu iv iw ix iy iz ja jb ln jd je jf lo jh ji jj lp jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jv jw jx jy fq jz fe ff paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="fe ff nn"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="jv jw jx jy fq jz"><div class="bz el l di"><div class="no np l"/></div></figure></div></div>    
</body>
</html>