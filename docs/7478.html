<html>
<head>
<title>Auto Value</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自动赋值</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/auto-value-for-java-a80431189f0?source=collection_archive---------13-----------------------#2017-10-29">https://medium.com/hackernoon/auto-value-for-java-a80431189f0?source=collection_archive---------13-----------------------#2017-10-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/883fccea7e85f223d6283482f73bf867.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gmkZNQx39ZQ1abodV25q2Q.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/utIhBw00Jxs?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Matthew Szlichta</a> on <a class="ae jg" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1d86" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Auto Value是一个帮助您轻松构建值类的库。它会在构建时自动生成代码，以减少源代码中大量样板文件。</p><h1 id="0aea" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">以前</h1><p id="c622" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">让我们从一个简单的POJO开始，看看我们可以改进什么。</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="a7c8" class="lr kg hu ln b fv ls lt l lu lv">public class Point {</span><span id="e3fe" class="lr kg hu ln b fv lw lt l lu lv">    private double x;<br/>    private double y;</span><span id="a57a" class="lr kg hu ln b fv lw lt l lu lv">    public double getX() { return x; }<br/>    public double getY() { return y; }</span><span id="dedd" class="lr kg hu ln b fv lw lt l lu lv">    public void setX(double x) { x = x; }<br/>    public void setY(double y) { y = y; }</span><span id="81c2" class="lr kg hu ln b fv lw lt l lu lv">    @Override<br/>    public int hashCode() {...}</span><span id="6c1e" class="lr kg hu ln b fv lw lt l lu lv">    @Override<br/>    public boolean equals(Object other) {...}</span><span id="f768" class="lr kg hu ln b fv lw lt l lu lv">    @Override<br/>    public String toString() {...}<br/>}</span></pre><p id="2359" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个简单的代码有什么问题？</p><ol class=""><li id="83e0" class="lx ly hu jj b jk jl jo jp js lz jw ma ka mb ke mc md me mf dt translated">Getter和setter看起来像样板文件，但是我们仍然必须添加以符合封装规则。</li><li id="1108" class="lx ly hu jj b jk mg jo mh js mi jw mj ka mk ke mc md me mf dt translated">手动覆盖<code class="eh ml mm mn ln b">hasCode()</code>和<code class="eh ml mm mn ln b">equals()</code>以区分不同的对象。</li><li id="4b83" class="lx ly hu jj b jk mg jo mh js mi jw mj ka mk ke mc md me mf dt translated">为了更好地记录，手动超越<code class="eh ml mm mn ln b">toString()</code>。</li></ol><p id="3a67" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv"> AutoValue来救援了。</strong></p><h1 id="7181" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">开始吧</h1><p id="9630" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">汽车价值如何帮助我们？这是我们使用AutoValue后的示例代码。</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="44b5" class="lr kg hu ln b fv ls lt l lu lv">import com.google.auto.value.AutoValue;<br/><br/>@AutoValue<br/>public abstract class Point {</span><span id="a073" class="lr kg hu ln b fv lw lt l lu lv">  public abstract double x();</span><span id="d859" class="lr kg hu ln b fv lw lt l lu lv">  public abstract double y();</span><span id="ac3a" class="lr kg hu ln b fv lw lt l lu lv">  public static Point create(double x, double y) {<br/>    return new AutoValue_Point(x, y);<br/>  }<br/>}</span></pre><p id="17e0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通过添加<code class="eh ml mm mn ln b">@AutoValue</code>注释，Auto Value为我们自动生成了<code class="eh ml mm mn ln b">AutoValue_Point</code>类。我们通过抽象接口<code class="eh ml mm mn ln b">Point</code>访问真实的类。我们解决了什么问题？</p><ol class=""><li id="4830" class="lx ly hu jj b jk jl jo jp js lz jw ma ka mb ke mc md me mf dt translated">不再有吸气剂了</li><li id="97a1" class="lx ly hu jj b jk mg jo mh js mi jw mj ka mk ke mc md me mf dt translated">没有setter，这意味着在大多数情况下不可变</li><li id="9d1f" class="lx ly hu jj b jk mg jo mh js mi jw mj ka mk ke mc md me mf dt translated">隐藏生成类中所有基本函数(equals，hashCode)的细节</li></ol><p id="896f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="mo">另外，需要注意的一点是，如果是数组类型，比如</em> <code class="eh ml mm mn ln b"><em class="mo">List</em></code> <em class="mo">，我们仍然可以修改值。</em></p><h1 id="07ff" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">生成类做什么？</h1><p id="8098" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">我们还可以检查<code class="eh ml mm mn ln b">AutoValue_Point</code>为我们做了什么。</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="2c55" class="lr kg hu ln b fv ls lt l lu lv">final class AutoValue_Point extends Point {</span><span id="e098" class="lr kg hu ln b fv lw lt l lu lv">  private final double x;<br/>  private final double y;<br/><br/>  AutoValue_Point(<br/>      double x,<br/>      double y) {<br/>    this.x = x;<br/>    this.y = y;<br/>  }<br/><br/>  @Override<br/>  public double x() {<br/>    return x;<br/>  }<br/><br/>  @Override<br/>  public double y() {<br/>    return y;<br/>  }<br/><br/>  @Override<br/>  public String toString() {<br/>    return "Point{"<br/>        + "x=" + x + ", "<br/>        + "y=" + y<br/>        + "}";<br/>  }<br/><br/>  @Override<br/>  public boolean equals(Object o) {<br/>    if (o == this) {<br/>      return true;<br/>    }<br/>    if (o instanceof Point) {<br/>      Point that = (Point) o;<br/>      return (Double.<em class="mo">doubleToLongBits</em>(this.x) == Double.<em class="mo">doubleToLongBits</em>(that.x()))<br/>          &amp;&amp; (Double.<em class="mo">doubleToLongBits</em>(this.y) == Double.<em class="mo">doubleToLongBits</em>(that.y()));<br/>    }<br/>    return false;<br/>  }<br/><br/>  @Override<br/>  public int hashCode() {<br/>    int h = 1;<br/>    h *= 1000003;<br/>    h ^= (Double.<em class="mo">doubleToLongBits</em>(this.x) &gt;&gt;&gt; 32) ^ Double.<em class="mo">doubleToLongBits</em>(this.x);<br/>    h *= 1000003;<br/>    h ^= (Double.<em class="mo">doubleToLongBits</em>(this.y) &gt;&gt;&gt; 32) ^ Double.<em class="mo">doubleToLongBits</em>(this.y);<br/>    return h;<br/>  }<br/>}</span></pre><h1 id="77c0" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">构建器模式</h1><p id="e8c5" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">如果参数太多，很难读取怎么办？AutoValue还支持构建器模式来实例化对象。</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="a389" class="lr kg hu ln b fv ls lt l lu lv">import com.google.auto.value.AutoValue;<br/><br/>@AutoValue<br/>public abstract class Point {<br/><br/>  public abstract double x();<br/><br/>  public abstract double y();<br/><br/>  public static Builder builder() {<br/>    return new AutoValue_Point.Builder();<br/>  }<br/><br/>  <strong class="ln hv">@AutoValue.Builder<br/>  public abstract static class Builder {</strong></span><span id="3f9b" class="lr kg hu ln b fv lw lt l lu lv"><strong class="ln hv">    public abstract Builder x(double x);<br/><br/>    public abstract Builder y(double y);<br/><br/>    public abstract Point build();<br/>  }</strong><br/>}</span></pre><p id="5b84" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">用法和普通的构建器一样简单。</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="2c02" class="lr kg hu ln b fv ls lt l lu lv">Point p = Point.builder().x(100).y(100).build();</span></pre><h1 id="9b2c" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">更新值</h1><p id="eea3" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">AutoValue对象的设计是不可变的，但是builder模式也有利于我们在必要时克隆对象。只需添加一个抽象的<code class="eh ml mm mn ln b">toBuilder</code>来表明我们有通过现有值创建构建器的功能。然后，我们可以在更新值之后或在任何时候将构建器转换回对象。</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="4342" class="lr kg hu ln b fv ls lt l lu lv">@AutoValue<br/>public abstract class Point {<br/><br/>  public abstract double x();<br/><br/>  public abstract double y();<br/><br/>  public static Builder builder() {<br/>    return new AutoValue_Point.Builder();<br/>  }<br/><br/>  <strong class="ln hv">public abstract Builder toBuilder();</strong><br/><br/>  <strong class="ln hv">public Point withX(double x) {<br/>    return toBuilder().x(x).build();<br/>  }</strong><br/><br/>  @AutoValue.Builder<br/>  public abstract static class Builder {<br/>    public abstract Builder x(double x);<br/><br/>    public abstract Builder y(double y);<br/><br/>    public abstract Point build();<br/>  }<br/>}</span></pre><h1 id="2c15" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">参考</h1><div class="mp mq fm fo mr ms"><a href="https://github.com/google/auto/tree/master/value" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab ej"><div class="mu ab mv cl cj mw"><h2 class="bd hv fv z el mx eo ep my er et ht dt translated">谷歌/汽车</h2><div class="mz l"><h3 class="bd b fv z el mx eo ep my er et ek translated">auto-Java源代码生成器的集合。</h3></div><div class="na l"><p class="bd b gc z el mx eo ep my er et ek translated">github.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng ja ms"/></div></div></a></div></div></div>    
</body>
</html>