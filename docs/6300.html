<html>
<head>
<title>Think first, test later</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">先思考，后测试</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/think-first-test-later-2a258bed05cf?source=collection_archive---------8-----------------------#2017-09-12">https://medium.com/hackernoon/think-first-test-later-2a258bed05cf?source=collection_archive---------8-----------------------#2017-09-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/e39ae07c9b9174b2f5bd16043a7e8e13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*05buQX-OWGjI_nRD5ys2cQ.png"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">photo by <a class="ae ih" href="https://unsplash.com/@korabelnikova?utm_medium=referral&amp;utm_campaign=photographer-credit&amp;utm_content=creditBadge" rel="noopener ugc nofollow" target="_blank">Elizaveta Korabelnikova</a></figcaption></figure><div class=""/><p id="6211" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我从事测试驱动开发(TDD)已经有一段时间了，这很棒。它给了我一个画布(测试文件)来起草设计和思考与其他组件的交互应该是什么样子，期望的行为是什么，最重要的是，它给了我一个非常快速的反馈循环。</p><p id="df0a" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">到时候你要重构。做TDD已经给了你安全网，它是你写的一堆测试用例来驱动你的实现。根据Martin Fowler的定义，当你重构时，你不会改变可观察到的行为。</p><blockquote class="kf kg kh"><p id="ab0d" class="jh ji ki jj b jk jl jm jn jo jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd ke hn dt translated">重构(名词):在不改变软件可观察行为的情况下，对软件内部结构进行的修改，使其更容易理解，修改成本更低。</p></blockquote><p id="0d81" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">那么，重构的时候，测试需要改变吗？</p><p id="ddb5" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这取决于你说你没有改变行为的水平。观察者是谁？界面变化需要改变测试。在这里，一切照旧；只是输入和输出的形式改变了，即使它们与以前的同构。这算不算改变行为？</p><p id="bdac" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最终用户可能不会注意到，但是其他消费者(你的开发伙伴和代码库的其他部分)会注意到接口的变化。</p><p id="96d0" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">更糟糕的是，测试可能知道太多关于实现的东西。您既没有改变任何行为也没有改变任何接口，但是您仍然需要改变测试。</p><p id="0da3" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">TDD对于驱动设计是有用的，但是并不意味着它总是产生好的设计。如果出了问题，安全网最终会变成蜘蛛网，阻止你离开。事实证明，你在维护测试上花费了更多的时间，这阻碍了人们进行重构，因为这需要大量的工作。</p><p id="3773" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">那么我们怎样才能保持理智呢？</p><h1 id="cbfc" class="km kn ik bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">在做任何事情之前，想一想。</h1><p id="059f" class="pw-post-body-paragraph jh ji ik jj b jk lk jm jn jo ll jq jr js lm ju jv jw ln jy jz ka lo kc kd ke hn dt translated">有时候人们把TDD带得太远，他们可能会说“不要想，先写个测试就好了”，并希望TDD最终能指导我们更好地设计。如果没有，我们可以稍后重构。这并不总是奏效。</p><p id="07d0" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">问题是，如果我们在编写第一个测试之前没有考虑充分，糟糕的问题建模将会泄漏到实现中，并像野火一样蔓延。在某些时候，你会意识到你刚刚写的东西并不适合更大的图景，你会花越来越多的时间来重构，甚至更糟的是，因为所谓的交付压力，你没有足够的时间来重构它。你的队友开始在它的基础上构建东西，重构的成本变得更高。领域理解是成功软件开发的一个非常重要的关键。</p><p id="6172" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以在编写任何测试之前，问问你自己</p><blockquote class="lp"><p id="40ab" class="lq lr ik bd ls lt lu lv lw lx ly ke ek translated">我们试图解决什么问题？</p></blockquote><p id="ea8f" class="pw-post-body-paragraph jh ji ik jj b jk lz jm jn jo ma jq jr js mb ju jv jw mc jy jz ka md kc kd ke hn dt translated">我们正在解决问题，而不仅仅是构建功能。所以我们应该知道问题是什么，并把它写下来。一旦我们知道它是什么，考虑如何建模它以适应我们的环境和约束。当我在工作的时候，我经常打扰业务分析师和UX设计师(其他角色也是，但是不太频繁)，以便在深入技术细节之前理解用户故事背后的逻辑和原因。理解我们试图解决的问题是好的问题建模的第一步。</p><figure class="me mf mg mh fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/442e5f4f34e7768d12563009026e0619.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*avT4HrsKwl1hwLKsPYo-5Q.png"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Photo by <a class="ae ih" href="https://unsplash.com/@jdsimcoe" rel="noopener ugc nofollow" target="_blank">Jonathan Simcoe</a></figcaption></figure><p id="b9b9" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">笔和纸或白板是问题建模的绝佳工具。电脑往往会分散我们的注意力，因为它会让我们在没有足够仔细思考的情况下就去实施。</p><p id="4831" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以，对我来说，这就像是传统分析和设计的微型版本。预先避免大的设计并不意味着你应该忽略计划，盲目地去编码。如果你不为那些容易改变、进化甚至抛弃的设计做计划，你就不可能敏捷。</p><p id="8537" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你从未看过Rich Hickey(clo jure的创始人)的《吊床驱动的开发》,我会推荐你去看。它会给你一些关于如何思考问题的有趣想法。</p><p id="cf48" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们对这个问题有了更多的了解，让我们把我们的理解放到…</p><h1 id="2781" class="km kn ik bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">合同</h1><p id="4ec2" class="pw-post-body-paragraph jh ji ik jj b jk lk jm jn jo ll jq jr js lm ju jv jw ln jy jz ka lo kc kd ke hn dt translated">当我们编码时，我们需要考虑一个函数、模块或类将如何被使用，输入和输出看起来如何，我们想要加上什么约束。我们在代码中写下契约，以过滤掉我们需要处理的不必要的可能性。</p><p id="8c72" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一种方法是使用类型。</p><p id="f448" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">类型表示一组可能的输入和输出。有了好的类型系统，编译器会给你类型级的反馈，这甚至比测试还要快。那时你更关注于设计界面，而不是底层实现。您可以使用类型来消除潜在的错误，但是您能走多远还取决于您选择的语言的类型系统有多复杂。</p><p id="7d9b" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在类型函数设置中，人们倾向于使用代数数据类型来建模问题。这个想法很简单，<a class="ae ih" href="http://tpolecat.github.io/presentations/algebraic_types.html#1" rel="noopener ugc nofollow" target="_blank">也可以在类中编码</a>。</p><p id="a94b" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但这不是唯一的方法。目标是对输入和输出设置一些约束，并记录下来。例如，Clojure是一种动态类型语言，它有<a class="ae ih" href="https://clojure.org/about/spec" rel="noopener ugc nofollow" target="_blank"> clojure.spec </a>让您能够这样做。它附带了<a class="ae ih" href="https://github.com/clojure/test.check" rel="noopener ugc nofollow" target="_blank"> test.check </a>也可以根据你定义的规范生成测试。或者在JavaScript中，有一个名为<a class="ae ih" href="https://github.com/gcanti/tcomb" rel="noopener ugc nofollow" target="_blank"> tcomb </a>的库，它允许你在运行时执行类型检查，并且定制检查非常灵活。</p><p id="b2c5" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">即使没有所有的工具，理解它应该是什么样子也是很好的。至少在你开始写测试之前考虑一下。设计与问题性质相匹配的数据结构减少了您需要编写的测试数量，也使您的实现更简单。</p><p id="0367" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你想对这个话题了解更多，我推荐<a class="ae ih" href="https://www.youtube.com/watch?v=IcgmSRJHu_8" rel="noopener ugc nofollow" target="_blank">让不可能的状态变得不可能</a>和<a class="ae ih" href="https://fsharpforfunandprofit.com/posts/designing-with-types-intro/" rel="noopener ugc nofollow" target="_blank">用类型</a>设计。他们都使用类型函数语言来演示，但我认为这个想法也适用于OOP。</p><h1 id="1236" class="km kn ik bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">然后编写第一个测试</h1><p id="b097" class="pw-post-body-paragraph jh ji ik jj b jk lk jm jn jo ll jq jr js lm ju jv jw ln jy jz ka lo kc kd ke hn dt translated">在我们按类型过滤掉大量不需要的状态之后，是时候变得更具体了。在示例的指导下，TDD是驱动函数或类的内部实现设计的好工具。正如我之前提到的，测试文件就像一块画布，让我们描绘我们的设计。它将向您展示它将如何被使用，并且它是定义类型不能表达的期望行为的地方。如果设置测试花费了太多的精力，或者很难断言行为，你会感觉到这种味道。</p><figure class="me mf mg mh fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/0fc51f732cce9cc1312c8b4e3d7110b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UBSocVjkTCXwgjesHfxOtg.png"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Photo by <a class="ae ih" href="https://unsplash.com/@aarondnbb" rel="noopener ugc nofollow" target="_blank">Aaron Mello</a></figcaption></figure><p id="3296" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">随着我们一步一步地从非常基本的情况到更复杂的情况，我们的设计在我们定义的边界内成长。我们增加测试。我们添加新代码。我们有回归测试的所有测试，然后重构。在这个过程中要记住的一件事是，我们应该让测试尽可能远离实现细节，否则我们将会陷入测试阻碍你重构的状态。</p><p id="551a" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我觉得有效率的一个技巧是列出所有的案例，即使没有任何断言(又名。待定测试)来获得实现的里程碑。通过这样做，您将看到函数或类行为的清晰轮廓。</p><p id="50ea" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果我们能想到其他有价值的案例，还可以增加更多的案例。请记住，更多的测试并不总是意味着好，但总是意味着要维护更多的代码。编写足够自信的测试，并将它们保持在像应用程序代码一样可维护的状态。</p><h1 id="720a" class="km kn ik bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">这完全是质量问题</h1><p id="bd42" class="pw-post-body-paragraph jh ji ik jj b jk lk jm jn jo ll jq jr js lm ju jv jw ln jy jz ka lo kc kd ke hn dt translated">好的设计是防止bug最便宜的方法。从仔细的思考到类型，然后测试提供了系统更抽象的画面:组件如何相互通信，接口是什么，行为是什么。它们都影响我们如何实现系统的一小部分。在其他事情之前写测试可能会导致设计过程中错误的焦点。</p><p id="78ea" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">它是关于迭代和增量的变化，但是在不同的级别和不同的周期时间。TDD是最短的一个，其余的都比较长。</p><p id="8195" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">也有TDD不好用的时候。如果是这样的话，试试别的。</p><blockquote class="lp"><p id="0f4f" class="lq lr ik bd ls lt lu lv lw lx ly ke ek translated">TDD不是达到目的的手段，高质量的软件才是。</p></blockquote></div><div class="ab cl mi mj hc mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hn ho hp hq hr"><p id="5a04" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在twitter上关注我<a class="ae ih" href="https://twitter.com/ibossptk" rel="noopener ugc nofollow" target="_blank"> @ibossptk </a></p></div></div>    
</body>
</html>