<html>
<head>
<title>Take Your Unit Tests to the Next Level</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让你的单元测试更上一层楼</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/unit-test-naming-given-when-then-java-84407911b858?source=collection_archive---------2-----------------------#2017-07-06">https://medium.com/hackernoon/unit-test-naming-given-when-then-java-84407911b858?source=collection_archive---------2-----------------------#2017-07-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/1baf0f58c1d507fc541abafef9c37db4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YH1NKqYXOl5-d9GSeMkpQw.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="http://www.flickr.com/photos/16446716@N05/4652680633" rel="noopener ugc nofollow" target="_blank">http://www.flickr.com/photos/16446716@N05/4652680633</a></figcaption></figure><p id="2de6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这篇文章的目的不是强调编写单元测试或者测试驱动开发过程的重要性。有大量的文章证明了这一点，并介绍了各种单元测试方法。相反，我将分享我写我认为有效的和<em class="kf">自我记录</em>单元测试的经验。代码示例在<a class="ae jg" href="https://hackernoon.com/tagged/java" rel="noopener ugc nofollow" target="_blank"> Java </a>和JUnit 4中。</p><h1 id="dd71" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">编写单元测试很有趣，如果…</h1><ol class=""><li id="01e1" class="le lf hu jj b jk lg jo lh js li jw lj ka lk ke ll lm ln lo dt translated">您遵循一致的<em class="kf">方法，这使您能够更快地编写测试。</em></li><li id="56d9" class="le lf hu jj b jk lp jo lq js lr jw ls ka lt ke ll lm ln lo dt translated">您的测试代码被分解成易于管理的小块(工作单元)。</li><li id="cb35" class="le lf hu jj b jk lp jo lq js lr jw ls ka lt ke ll lm ln lo dt translated">您的测试方法使用有效的、易于遵循的命名约定和结构。</li><li id="952a" class="le lf hu jj b jk lp jo lq js lr jw ls ka lt ke ll lm ln lo dt translated">您可以通过像<a class="ae jg" href="https://github.com/jacoco/jacoco" rel="noopener ugc nofollow" target="_blank"> JaCoCo </a>这样的工具生成代码覆盖报告来量化您的进度。</li></ol><p id="3f69" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">本文集中讨论这个列表中的前三项。</p></div><div class="ab cl lu lv hc lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hn ho hp hq hr"><p id="3c43" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们测试一个简单的<code class="eh mb mc md me b">Customer</code>类，它在构造时执行自己的验证:</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="mj mk l"/></div></figure><p id="b14a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我看到了3个潜在的测试候选人:</p><ol class=""><li id="4bc4" class="le lf hu jj b jk jl jo jp js ml jw mm ka mn ke ll lm ln lo dt translated">如果传入了空参数，则测试构造函数。</li><li id="74dd" class="le lf hu jj b jk lp jo lq js lr jw ls ka lt ke ll lm ln lo dt translated">如果传入了非空参数，则测试构造函数。</li><li id="7848" class="le lf hu jj b jk lp jo lq js lr jw ls ka lt ke ll lm ln lo dt translated">测试<code class="eh mb mc md me b">getName()</code>方法。</li></ol><p id="bb67" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一旦我们测试了上面的所有内容，这个类将被完全测试(100%代码覆盖率)。让我们来实现这些测试:</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="mj mk l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">g</figcaption></figure><h1 id="e492" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">测试方法名称</h1><p id="5ab6" class="pw-post-body-paragraph jh ji hu jj b jk lg jm jn jo lh jq jr js mo ju jv jw mp jy jz ka mq kc kd ke hn dt translated">我建议您的测试方法名称遵循<em class="kf">methodnameundest _ given condition _ expected behavior</em>的命名约定，其中<em class="kf"> givenCondition </em>是可选的。让我们看看它如何适用于<code class="eh mb mc md me b">CustomerTest</code>。</p><p id="1d5a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh mb mc md me b">ctor_givenNameIsNull_throwsException()</code>包括:</p><ol class=""><li id="7c0b" class="le lf hu jj b jk jl jo jp js ml jw mm ka mn ke ll lm ln lo dt translated">ctor表示我们正在测试构造函数的行为</li><li id="3b88" class="le lf hu jj b jk lp jo lq js lr jw ls ka lt ke ll lm ln lo dt translated"><em class="kf"> givenNameIsNull </em>指定空值<code class="eh mb mc md me b">name</code>传入构造函数时的条件</li><li id="d1df" class="le lf hu jj b jk lp jo lq js lr jw ls ka lt ke ll lm ln lo dt translated"><em class="kf"> throwsException </em>表示当条件满足时(<code class="eh mb mc md me b">name</code>为null)，我们将抛出一个异常。注意<code class="eh mb mc md me b">@Test(expected = IllegalArgumentException.class)</code>定义了我们期望的具体异常。</li></ol><p id="043b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh mb mc md me b">ctor_givenNameIsValid_setsName()</code>包括:</p><ol class=""><li id="bc49" class="le lf hu jj b jk jl jo jp js ml jw mm ka mn ke ll lm ln lo dt translated">ctr表示我们正在测试构造函数的行为</li><li id="7f2f" class="le lf hu jj b jk lp jo lq js lr jw ls ka lt ke ll lm ln lo dt translated"><em class="kf"> givenNameIsValid </em>指定将非空值<code class="eh mb mc md me b">name</code>传递给构造函数时的条件</li><li id="c5f1" class="le lf hu jj b jk lp jo lq js lr jw ls ka lt ke ll lm ln lo dt translated"><em class="kf"> setsName </em>表示当条件满足时(<code class="eh mb mc md me b">name</code>非空)，应该设置我们测试<code class="eh mb mc md me b">Customer</code>的类成员<code class="eh mb mc md me b">name</code>。</li></ol><p id="77cd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh mb mc md me b">getName_returnsName()</code>包括:</p><ol class=""><li id="10b1" class="le lf hu jj b jk jl jo jp js ml jw mm ka mn ke ll lm ln lo dt translated">getName 表示我们正在测试<code class="eh mb mc md me b">getName()</code>方法的行为</li><li id="23ed" class="le lf hu jj b jk lp jo lq js lr jw ls ka lt ke ll lm ln lo dt translated"><em class="kf"> returnsName </em>表示应该返回一个有效的非空值<code class="eh mb mc md me b">name</code>。</li></ol><blockquote class="mr"><p id="b0ff" class="ms mt hu bd mu mv mw mx my mz na ke ek translated">您的测试方法名称应该提供一个关于被测试类的功能的好主意。</p></blockquote><p id="fb64" class="pw-post-body-paragraph jh ji hu jj b jk nb jm jn jo nc jq jr js nd ju jv jw ne jy jz ka nf kc kd ke hn dt translated">另外，请注意，每个测试只有几行代码，并且只验证一部分功能(被测试的代码的一个<em class="kf">单元)。</em></p><h1 id="c7b1" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">当时给定的</h1><p id="f0cc" class="pw-post-body-paragraph jh ji hu jj b jk lg jm jn jo lh jq jr js mo ju jv jw mp jy jz ka mq kc kd ke hn dt translated">让我们看看测试方法本身的内容。注意，所有的测试都遵循<a class="ae jg" href="https://martinfowler.com/bliki/GivenWhenThen.html" rel="noopener ugc nofollow" target="_blank"> <em class="kf">给定-何时-然后</em> </a>的风格来表示测试步骤。这使得每个单独的测试成为一个逻辑的、易于理解的、一致的步骤序列。</p><p id="effe" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们更详细地描述一下每个给定时间步骤:</p><p id="5330" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">给定</strong> —在执行核心测试逻辑之前，设置特定条件或创建执行测试所需的对象。这实际上是测试的先决条件。</p><pre class="mf mg mh mi fq ng me nh ni aw nj dt"><span id="4173" class="nk kh hu me b fv nl nm l nn no">// GIVEN<br/>String expectedName = "linda";<br/>testSubject = new Customer(expectedName);</span></pre><p id="1fdd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">注意，给定的<strong class="jj hv">并不总是必要的——有时某个特定的测试不需要设置，或者在用<code class="eh mb mc md me b">@Before</code>注释的方法内部的每个测试之前都执行了普通的设置。</strong></p></div><div class="ab cl lu lv hc lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hn ho hp hq hr"><p id="0813" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv"> When </strong> —这是我们测试的动作被触发的地方。</p><pre class="mf mg mh mi fq ng me nh ni aw nj dt"><span id="6a82" class="nk kh hu me b fv nl nm l nn no">// WHEN<br/>String actualName = testSubject.getName();</span></pre></div><div class="ab cl lu lv hc lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hn ho hp hq hr"><p id="0c2a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">然后</strong>——这是我们断言一旦测试动作发生，应用程序的状态就像预期的那样(我们测试中的代码按照我们预期的方式运行)。</p><pre class="mf mg mh mi fq ng me nh ni aw nj dt"><span id="0d84" class="nk kh hu me b fv nl nm l nn no">// THEN<br/><em class="kf">assertTrue</em>(expectedName.equals(actualName));</span></pre><p id="2214" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有些情况下，显式<em class="kf">则</em>是不必要的。例如，如果<em class="kf">当</em>步预计抛出异常(如上例所示)。</p><h1 id="99b8" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">活文档</h1><p id="8e64" class="pw-post-body-paragraph jh ji hu jj b jk lg jm jn jo lh jq jr js mo ju jv jw mp jy jz ka mq kc kd ke hn dt translated">有效地应用以上建议，为您的项目创建简洁、易读的<em class="kf">活</em> <em class="kf">文档</em>。当您的产品代码发生变化时，相应的测试也会发生变化，从而更新您的项目文档。此外，这个<em class="kf">活文档</em>对于你的整个技术团队来说是一个重要的<strong class="jj hv">知识资源</strong>，尤其是对于那些刚刚加入你的项目的开发人员和测试人员。</p><h1 id="7bb3" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">结论</h1><p id="8130" class="pw-post-body-paragraph jh ji hu jj b jk lg jm jn jo lh jq jr js mo ju jv jw mp jy jz ka mq kc kd ke hn dt translated">我希望您看到在您的单元测试中应用这些约定的价值。如果这对你来说是新的，我相信一旦你尝试采用这些指导方针，写测试会突然变得更容易，更快，我敢说很有趣！除了导致更少的错误之外，您将发现未来的代码重构也明显更容易，因为现在您的代码由一致的自我记录测试支持。</p><p id="d877" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">附注:编写好的测试是一项非常抢手的技能！；)</p></div><div class="ab cl lu lv hc lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hn ho hp hq hr"><p id="6ed3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">访问我的</strong> <a class="ae jg" href="http://www.valueof.io" rel="noopener ugc nofollow" target="_blank"> <strong class="jj hv"> Android博客</strong> </a> <strong class="jj hv">阅读关于Jetpack Compose和其他Android主题</strong></p></div></div>    
</body>
</html>