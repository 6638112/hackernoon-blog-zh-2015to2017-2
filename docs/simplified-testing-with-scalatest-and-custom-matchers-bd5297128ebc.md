# 利用 ScalaTest 和定制匹配器简化测试

> 原文：<https://medium.com/hackernoon/simplified-testing-with-scalatest-and-custom-matchers-bd5297128ebc>

![](img/e7b15b5e671aa64ca85d87cc08975a0c.png)

首先测试对我们来说很重要。我们的一切都是建立在这个原则之上的，它对我们来说非常有效。然而，并不是每一个测试框架都是为了简单而设计的，有时我们不得不在它们的基础上构建一个更加精炼的产品，更好地满足我们对简单性的特殊需求。

ScalaTest 令人印象深刻，它有非常有趣的功能。我们最喜欢的一点是，我们可以通过添加我们自己的匹配器来扩展它，这最终会给我们带来我们正在寻找的抽象层次。

让我们从假设我们想测试一个函数的后续签名开始。

一个非常简单的测试是

正如我们所看到的，这是一个非常简单的测试，但是现在让我们找到一个给定了用户 id 的用户。

我们可以为它编写一个测试，如下所示。

等等什么？我们真的必须打开单子吗？另一个选择是休耕。

这是一样的，不同的是我们现在把`User`包装成`Some`，这基本上是一样的。

我们实际上想写的是类似下面这样的东西。

正如我们所看到的，在这里我们的意图更加明确 ***(这段代码还不会编译)***

## 我们如何扩展 ScalaTest 以获得我们想要的功能(或编写测试的方式)？

这种方法需要预先做一些工作，但是回报很快。

首先，我们需要创建一个将与我们的测试类混合的特征。

然后，我们创建`matchTo`函数，作为测试的一部分。这个函数实际上是返回一个负责匹配`User`和`Option[User]`的`Matcher`实例。

这让我们能够改变

到

在这里，你也应该注意到我们将`User` 与`Option[User]`进行匹配，但是比较是在幕后进行的。我们已经从测试中去除了这种复杂性。

我们可以为用户添加一个新的匹配器，这样我们就可以用下面的形状编写一个测试。

让我们给`UserMatchers.`添加必要的代码

现在，我们可以通过`Name`来匹配`User`，同样，在幕后，我们正在进行所有需要的比较，以确保名称与`Option[User]`中的用户名匹配。

这个例子很简单，但是考虑一个更复杂的堆栈。假设我们有一个想要测试的函数，它的形状如下。

对于这个特殊的功能，我们需要解开`Future`和`Either`和`Seq`。

其中一个测试可能与此类似。

能写下以下内容该多好？

我们可以为它编写一个自定义匹配器，让我们看看如何实现。

如你所见，这个有点复杂。我们把所有脏东西都推给了匹配器，`ValidUsersMatchers`。我们可以说这和我们以前做的是一样的，我们只是把复杂性移到了不同的地方，但是我们的测试现在更干净了，我们也可以在不同的测试中重用匹配器。

此外，我们的测试以一种非常清晰的方式表达了我们的意图，而不会因为来自 monads 等堆叠结构的语法复杂性而污染代码。

## 结论

保持你的测试干净。ScalaTest 有几种不同的方法可以做到这一点。为你的结构编写匹配器，这样你就可以在多个测试中重用它们。根据需要混合尽可能多的自定义匹配器，以获得尽可能多的简单性。把测试的复杂性推给你的匹配者，让他们在一个地方做脏活。