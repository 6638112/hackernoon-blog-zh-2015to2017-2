<html>
<head>
<title>Git in 2016</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2016年Git</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/git-in-2016-fad96ae22a15?source=collection_archive---------3-----------------------#2017-01-11">https://medium.com/hackernoon/git-in-2016-fad96ae22a15?source=collection_archive---------3-----------------------#2017-01-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/d94d04b8e83dcc486e7772394670b3d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1SiSsLMsNSyAk6khb63W9g.png"/></div></div></figure><div class=""/><p id="e253" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://hackernoon.com/tagged/git" rel="noopener ugc nofollow" target="_blank"> Git </a>在2016年度过了<em class="kb">巨大的</em>年，五个特性版本<a class="ae ka" href="#c8e9" rel="noopener ugc nofollow"> </a> ( <em class="kb"> v2.7 </em>到<em class="kb"> v2.11 </em>)和十六个补丁版本<a class="ae ka" href="#408a" rel="noopener ugc nofollow"> </a>。189位作者<a class="ae ka" href="#315b" rel="noopener ugc nofollow"> </a>向<code class="eh kc kd ke kf b">master</code>贡献了3676条提交<a class="ae ka" href="#dbfb" rel="noopener ugc nofollow"> ⁴ </a>，比2015年上升了15% <a class="ae ka" href="#2220" rel="noopener ugc nofollow"> ⁵ </a>！总共修改了1545个文件，增加了276799行，删除了100973行<a class="ae ka" href="#bc78" rel="noopener ugc nofollow"> ⁶ </a>。</p><p id="d63e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，提交计数和LOC是衡量生产率的非常糟糕的方法。在深度学习发展到可以定性搜索代码的程度之前，我们将一直依赖人类的判断作为生产力的仲裁者。</p><p id="4fe4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">考虑到这一点，我决定做一个回顾，涵盖这一年中我最喜欢的六个Git特性的变化和改进。对于一篇中型文章来说，这篇文章实在太长了，所以如果你想跳到你特别感兴趣的一个特性，我会原谅你的:</p><ul class=""><li id="ebdf" class="kg kh if je b jf jg jj jk jn ki jr kj jv kk jz kl km kn ko dt translated"><a class="ae ka" href="#fd10" rel="noopener ugc nofollow">四舍五入出</a> <code class="eh kc kd ke kf b"><a class="ae ka" href="#fd10" rel="noopener ugc nofollow">git worktree</a></code> <a class="ae ka" href="#fd10" rel="noopener ugc nofollow">命令</a></li><li id="2aeb" class="kg kh if je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko dt translated"><a class="ae ka" href="#cc52" rel="noopener ugc nofollow">更方便</a> <code class="eh kc kd ke kf b"><a class="ae ka" href="#cc52" rel="noopener ugc nofollow">git rebase</a></code> <a class="ae ka" href="#cc52" rel="noopener ugc nofollow">选项</a></li><li id="4da1" class="kg kh if je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko dt translated"><a class="ae ka" href="#42b9" rel="noopener ugc nofollow">戏剧性的性能提升为</a> <code class="eh kc kd ke kf b"><a class="ae ka" href="#42b9" rel="noopener ugc nofollow">git lfs</a></code></li><li id="64a1" class="kg kh if je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko dt translated"><a class="ae ka" href="#4208" rel="noopener ugc nofollow">实验算法和更好的默认值</a> <code class="eh kc kd ke kf b"><a class="ae ka" href="#4208" rel="noopener ugc nofollow">git diff</a></code></li><li id="a5b2" class="kg kh if je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko dt translated"><code class="eh kc kd ke kf b"><a class="ae ka" href="#a5c3" rel="noopener ugc nofollow">git submodules</a></code> <a class="ae ka" href="#a5c3" rel="noopener ugc nofollow">以少吸多</a></li><li id="5296" class="kg kh if je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko dt translated"><a class="ae ka" href="#c230" rel="noopener ugc nofollow">对</a>的俏皮增强<code class="eh kc kd ke kf b"><a class="ae ka" href="#c230" rel="noopener ugc nofollow">git stash</a></code></li></ul><p id="5567" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们开始之前，请注意许多操作系统都附带了Git的遗留版本，所以有必要检查一下您使用的是不是最新最好的版本。如果从你的终端运行<code class="eh kc kd ke kf b">git --version</code>返回任何比Git <code class="eh kc kd ke kf b">v2.11.0</code>少的东西，直接去Atlassian的快速指南<a class="ae ka" href="https://www.atlassian.com/git/tutorials/install-git/" rel="noopener ugc nofollow" target="_blank">升级或者在你选择的平台上安装Git </a>。</p><h1 id="87c4" class="ku kv if bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">[ <code class="eh kc kd ke kf b">Citation</code>需要]</h1><p id="5bd5" class="pw-post-body-paragraph jc jd if je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">在我们进入定性内容之前，还有一个快速的停顿:我想向您展示我是如何从开篇段落(以及夸张的封面图片)中生成统计数据的。您也可以使用下面的命令为您自己的存储库做一个快速的<em class="kb">年回顾</em>！</p><pre class="lx ly lz ma fq mb kf mc md aw me dt"><span id="c8e9" class="mf kv if kf b fv mg mh l mi mj">¹ <strong class="kf ig"><em class="kb">Tags from 2016 matching the form vX.Y.0</em></strong></span><span id="1b56" class="mf kv if kf b fv mk mh l mi mj">$ git for-each-ref --sort=-taggerdate --format \<br/>'%(refname) %(taggerdate)' refs/tags | grep "v\d\.\d*\.0 .* 2016"</span><span id="408a" class="mf kv if kf b fv mk mh l mi mj">² <strong class="kf ig"><em class="kb">Tags from 2016 matching the form vX.Y.Z</em></strong></span><span id="a6a6" class="mf kv if kf b fv mk mh l mi mj">$ git for-each-ref --sort=-taggerdate --format '%(refname) %(taggerdate)' refs/tags | grep "v\d\.\d*\.[^0] .* 2016"</span><span id="315b" class="mf kv if kf b fv mk mh l mi mj">³ <strong class="kf ig"><em class="kb">Commits by author in 2016</em></strong></span><span id="a0f0" class="mf kv if kf b fv mk mh l mi mj">$ <!-- -->git shortlog -s -n --since=2016-01-01 --until=2017-01-01</span><span id="dbfb" class="mf kv if kf b fv mk mh l mi mj">⁴ <strong class="kf ig"><em class="kb">Count commits in 2016</em></strong></span><span id="cf9f" class="mf kv if kf b fv mk mh l mi mj">$ <!-- -->git log --oneline --since=2016-01-01 --until=2017-01-01 | wc -l</span><span id="2220" class="mf kv if kf b fv mk mh l mi mj">⁵ <strong class="kf ig"><em class="kb">... and in 2015</em></strong></span><span id="d80c" class="mf kv if kf b fv mk mh l mi mj">$ <!-- -->git log --oneline --since=2015-01-01 --until=2016-01-01 | wc -l</span><span id="bc78" class="mf kv if kf b fv mk mh l mi mj">⁶ <strong class="kf ig">Net LOC added/removed in 2016</strong></span><span id="d68d" class="mf kv if kf b fv mk mh l mi mj">$ <!-- -->git diff --shortstat `git rev-list -1 --until=2016-01-01 master` \<br/> `git rev-list -1 --until=2017-01-01 master`</span></pre><p id="7cf0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面的命令是在Git的<code class="eh kc kd ke kf b">master</code>分支上运行的，所以不代表任何未合并的工作。如果您使用这些命令，请记住提交计数和锁定不是衡量标准。请不要用它们来给队友的表现打分！</p><p id="d86b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，回顾过去…</p><h1 id="fd10" class="ku kv if bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">舍入Git工作树</h1><p id="7028" class="pw-post-body-paragraph jc jd if je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated"><code class="eh kc kd ke kf b">git worktree</code>命令最早出现在Git v2.5中，但在2016年有了一些显著的增强。v2.7中引入了两个有价值的新特性——<code class="eh kc kd ke kf b">list</code>子命令和用于二等分的命名空间引用——<code class="eh kc kd ke kf b">lock</code>/<code class="eh kc kd ke kf b">unlock</code>子命令在v2.10中实现。</p><h2 id="3e82" class="mf kv if bd kw ml mm mn la mo mp mq le jn mr ms li jr mt mu lm jv mv mw lq mx dt translated">什么是工作树？</h2><p id="c9b9" class="pw-post-body-paragraph jc jd if je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated"><code class="eh kc kd ke kf b"><a class="ae ka" href="https://git-scm.com/docs/git-worktree" rel="noopener ugc nofollow" target="_blank">git worktree</a></code>命令允许您同时检查和处理不同目录中的多个存储库分支。例如，如果您需要快速修复，但又不想弄乱您的工作副本，您可以使用以下命令在新目录中签出一个新分支:</p><pre class="lx ly lz ma fq mb kf mc md aw me dt"><span id="1dd3" class="mf kv if kf b fv mg mh l mi mj"><strong class="kf ig">$ git worktree add -b hotfix/BB-1234 ../hotfix/BB-1234</strong><br/>Preparing ../hotfix/BB-1234 (identifier BB-1234)<br/>HEAD is now at 886e0ba Merged in bedwards/BB-13430-api-merge-pr (pull request #7822)</span></pre><p id="8344" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">工作树不仅仅是树枝。您可以将多个标签检出为不同的工作树，以便并行构建或测试它们。例如，我从Git v2.6和v2.7标签创建了工作树，以便检查不同版本Git的行为:</p><pre class="lx ly lz ma fq mb kf mc md aw me dt"><span id="25d1" class="mf kv if kf b fv mg mh l mi mj"><strong class="kf ig">$ git worktree add ../git-v2.6.0 v2.6.0</strong><br/>Preparing ../git-v2.6.0 (identifier git-v2.6.0)<br/>HEAD is now at be08dee Git 2.6</span><span id="dc93" class="mf kv if kf b fv mk mh l mi mj"><strong class="kf ig">$ git worktree add ../git-v2.7.0 v2.7.0</strong><br/>Preparing ../git-v2.7.0 (identifier git-v2.7.0)<br/>HEAD is now at 7548842 Git 2.7</span><span id="bf2e" class="mf kv if kf b fv mk mh l mi mj"><strong class="kf ig">$ git worktree list</strong><br/>/Users/kannonboy/src/git         7548842 [master]<br/>/Users/kannonboy/src/git-v2.6.0  be08dee (detached HEAD)<br/>/Users/kannonboy/src/git-v2.7.0  7548842 (detached HEAD)</span><span id="e100" class="mf kv if kf b fv mk mh l mi mj"><strong class="kf ig">$ cd ../git-v2.7.0 &amp;&amp; make</strong></span></pre><p id="f47e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以使用相同的技术并行构建和运行不同版本的应用程序。</p><h2 id="ce60" class="mf kv if bd kw ml mm mn la mo mp mq le jn mr ms li jr mt mu lm jv mv mw lq mx dt translated">列出工作树</h2><p id="cea6" class="pw-post-body-paragraph jc jd if je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated"><code class="eh kc kd ke kf b">git worktree list</code>子命令(在Git v2.7中引入)显示了与存储库相关的所有工作树:</p><pre class="lx ly lz ma fq mb kf mc md aw me dt"><span id="c0ab" class="mf kv if kf b fv mg mh l mi mj"><strong class="kf ig">$ git worktree list</strong><br/>/Users/kannonboy/src/bitbucket/bitbucket       37732bd [master]<br/>/Users/kannonboy/src/bitbucket/staging         d5924bc [staging]<br/>/Users/kannonboy/src/bitbucket/hotfix-1234     37732bd [hotfix/1234]</span></pre><h2 id="1113" class="mf kv if bd kw ml mm mn la mo mp mq le jn mr ms li jr mt mu lm jv mv mw lq mx dt translated">平分工作树</h2><p id="ffa0" class="pw-post-body-paragraph jc jd if je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated"><code class="eh kc kd ke kf b"><a class="ae ka" href="https://git-scm.com/book/en/v2/Git-Tools-Debugging-with-Git#Binary-Search" rel="noopener ugc nofollow" target="_blank">git bisect</a></code>是一个简洁的Git命令，允许您执行提交历史的二分搜索法。它通常用于找出哪个提交引入了特定的回归。例如，如果一个测试在我的<code class="eh kc kd ke kf b">master</code>分支的tip commit上失败了，我可以使用<code class="eh kc kd ke kf b">git bisect</code>遍历我的存储库的历史，寻找第一个破坏它的提交:</p><pre class="lx ly lz ma fq mb kf mc md aw me dt"><span id="025f" class="mf kv if kf b fv mg mh l mi mj"><strong class="kf ig">$ git bisect start</strong></span><span id="c384" class="mf kv if kf b fv mk mh l mi mj"><em class="kb"># indicate the last commit known to be passing the tests <br/># (e.g. the latest release tag)</em><br/><strong class="kf ig">$ git bisect good v2.0.0</strong></span><span id="0310" class="mf kv if kf b fv mk mh l mi mj"><em class="kb"># indicate a known broken commit (e.g. the tip of master)</em><br/><strong class="kf ig">$ git bisect bad master</strong></span><span id="3a8e" class="mf kv if kf b fv mk mh l mi mj"><em class="kb"># tell git bisect a script/command to run; git bisect will <br/># find the oldest commit between "good" and "bad" that causes <br/># this script to exit with a non-zero status</em><br/><strong class="kf ig">$ git bisect run npm test</strong></span></pre><p id="7da7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在引擎盖下，二等分使用refs来跟踪好的和坏的提交，用作二分搜索法范围的上限和下限。不幸的是，对于工作树爱好者来说，这些引用存储在通用的<code class="eh kc kd ke kf b">.git/refs/bisect</code>名称空间下，这意味着在不同工作树中运行的<code class="eh kc kd ke kf b">git bisect</code>操作可能会相互干扰。</p><p id="358e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从v2.7开始，等分引用被移到了<code class="eh kc kd ke kf b">.git/worktrees/$worktree_name/refs/bisect</code>，因此您可以跨多个工作树同时运行等分操作。</p><h2 id="ccc8" class="mf kv if bd kw ml mm mn la mo mp mq le jn mr ms li jr mt mu lm jv mv mw lq mx dt translated">锁定工作树</h2><p id="d811" class="pw-post-body-paragraph jc jd if je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">当你完成一个工作树时，你可以简单地删除它，然后运行<code class="eh kc kd ke kf b">git worktree prune</code>或者等待它被自动垃圾收集。但是，如果您将工作树存储在网络共享或可移动介质上，那么如果在清理过程中无法访问工作树目录，它将被清理-无论您喜欢与否！Git v2.10引入了<code class="eh kc kd ke kf b">git worktree lock</code>和<code class="eh kc kd ke kf b">unlock</code>子命令来防止这种情况发生:</p><pre class="lx ly lz ma fq mb kf mc md aw me dt"><span id="607f" class="mf kv if kf b fv mg mh l mi mj"><em class="kb"># to lock the git-v2.7 worktree on my USB drive<br/></em><strong class="kf ig">$ git worktree lock /Volumes/Flash_Gordon/git-v2.7 --reason \<br/>"In case I remove my removable media"</strong></span><span id="a3f1" class="mf kv if kf b fv mk mh l mi mj"><em class="kb"># to unlock (and delete) the worktree when I'm finished with it</em><br/><strong class="kf ig">$ git worktree unlock /Volumes/Flash_Gordon/git-v2.7<br/>$ rm -rf /Volumes/Flash_Gordon/git-v2.7<br/>$ git worktree prune</strong></span></pre><p id="8998" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kc kd ke kf b">--reason</code>标志可以让你为未来的自己留下一个注释，描述为什么工作树被锁定。<code class="eh kc kd ke kf b">git worktree unlock</code>和<code class="eh kc kd ke kf b">lock</code>都要求你指定工作树的路径。或者，您可以<code class="eh kc kd ke kf b">cd</code>到工作树目录并运行<code class="eh kc kd ke kf b">git worktree lock .</code>获得相同的效果。</p><h1 id="cc52" class="ku kv if bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">更多Git r <code class="eh kc kd ke kf b">ebase</code>选项</h1><p id="0fae" class="pw-post-body-paragraph jc jd if je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">在三月份，Git v2.8增加了在用<code class="eh kc kd ke kf b">git pull --rebase=interactive</code>拉动的同时交互式地重置基础的能力。相反，6月的Git v2.9版本实现了对执行rebase exec的支持，而无需通过<code class="eh kc kd ke kf b">git rebase -x</code>进入交互模式。</p><h2 id="6148" class="mf kv if bd kw ml mm mn la mo mp mq le jn mr ms li jr mt mu lm jv mv mw lq mx dt translated">再华？</h2><p id="ed54" class="pw-post-body-paragraph jc jd if je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">在我们开始之前，我怀疑可能有一些读者不熟悉或不完全熟悉rebase命令或交互式rebase。从概念上来说，这很简单，但是和Git的许多强大特性一样，rebase中充满了一些听起来很复杂的术语。因此，在我们开始之前，让我们快速回顾一下什么是重定基础。</p><p id="60cf" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">重定基础意味着重写特定分支上的一个或多个提交。<code class="eh kc kd ke kf b">git rebase</code>命令严重超载，但是rebase这个名字来源于这样一个事实，即它经常被用来改变分支的基本提交(创建分支的提交)。</p><p id="6207" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从概念上讲，rebase通过将分支上的提交临时存储为一系列补丁，然后在目标提交的顶部按顺序重新应用它们，来展开提交。</p><figure class="lx ly lz ma fq hw fe ff paragraph-image"><div class="fe ff my"><img src="../Images/0e714d9b546c7e16fcb4b2be3c617607.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*mgyl38slmqmcE4STS56nXA.gif"/></div></figure><p id="1dfe" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在master ( <code class="eh kc kd ke kf b">git rebase master</code>)上重新建立一个特征分支是用master的最新变化来“更新”你的特征分支的好方法。对于长期存在的特性分支，定期的重定基础可以最小化未来冲突的可能性和严重性。</p><p id="3aa2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一些团队也选择在将他们的变更合并到master上之前立即重新定基，以便实现快速合并(<code class="eh kc kd ke kf b">git merge --ff &lt;feature&gt;</code>)。快速转发将您的提交合并到主服务器上，只需使主服务器引用点位于您重写的分支的顶端，而无需创建合并提交:</p><figure class="lx ly lz ma fq hw fe ff paragraph-image"><div class="fe ff my"><img src="../Images/d9ea44b74354b0fff367a55808ec769b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*QXa3znQiuNWDjxroX628VA.gif"/></div></figure><p id="5e3f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Rebasing如此方便和强大，以至于它已经被嵌入到其他一些常见的Git命令中，比如<code class="eh kc kd ke kf b">git pull</code>。如果您在本地主分支上有一些未推送的变更，运行<code class="eh kc kd ke kf b">git pull</code>从原点拉您队友的变更将创建一个不必要的合并提交:</p><figure class="lx ly lz ma fq hw fe ff paragraph-image"><div class="fe ff my"><img src="../Images/6abf9505009d01bd348bd56467cc6098.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*IxDdJ5CygvSWdD8MCNpZNg.gif"/></div></figure><p id="65aa" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这有点混乱，在繁忙的团队中，您会得到大量不必要的合并提交。<code class="eh kc kd ke kf b">git pull --rebase</code>在不创建合并提交的情况下，将您的本地更改基于队友的更改:</p><figure class="lx ly lz ma fq hw fe ff paragraph-image"><div class="fe ff my"><img src="../Images/02ab852713431e05a0e55cab3263b1ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*HcroDMwBE9m21-hOeIwRmw.gif"/></div></figure><p id="27dd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这真是太棒了！更酷的是，Git v2.8引入了一个特性，让你在拉的时候交互地重置<em class="kb">。</em></p><h2 id="ea93" class="mf kv if bd kw ml mm mn la mo mp mq le jn mr ms li jr mt mu lm jv mv mw lq mx dt translated">交互式重置基础</h2><p id="f7bd" class="pw-post-body-paragraph jc jd if je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">交互式重定基础是一种更强大的重定基础形式。像标准的rebase一样，它重写提交，但是当它们被重新应用到新的基础上时，它也给你一个交互修改它们的机会。</p><p id="c105" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当您运行<code class="eh kc kd ke kf b">git rebase --interactive</code>(或<code class="eh kc kd ke kf b">git pull --rebase=interactive</code>)时，您将在您选择的文本编辑器中看到一个提交列表:</p><pre class="lx ly lz ma fq mb kf mc md aw me dt"><span id="0684" class="mf kv if kf b fv mg mh l mi mj"><strong class="kf ig">$ git rebase master --interactive</strong></span><span id="fe96" class="mf kv if kf b fv mk mh l mi mj"><strong class="kf ig">pick</strong> 2fde787 ACE-1294: replaced miniamalCommit with string in test<br/><strong class="kf ig">pick</strong> ed93626 ACE-1294: removed pull request service from test<br/><strong class="kf ig">pick</strong> b02eb9a ACE-1294: moved fromHash, toHash and diffType to batch<br/><strong class="kf ig">pick</strong> e68f710 ACE-1294: added testing data to batch email file</span><span id="ac32" class="mf kv if kf b fv mk mh l mi mj"><em class="kb"># Rebase f32fa9d..0ddde5f onto f32fa9d (4 commands)<br/>#<br/># Commands:<br/># p, </em><strong class="kf ig"><em class="kb">pick</em></strong><em class="kb"> = use commit<br/># r, </em><strong class="kf ig"><em class="kb">reword</em></strong><em class="kb"> = use commit, but edit the commit message<br/># e, </em><strong class="kf ig"><em class="kb">edit</em></strong><em class="kb"> = use commit, but stop for amending<br/># s, </em><strong class="kf ig"><em class="kb">squash</em></strong><em class="kb"> = use commit, but meld into previous commit<br/># f, </em><strong class="kf ig"><em class="kb">fixup</em></strong><em class="kb"> = like "squash", but discard this commit's log message<br/># x, </em><strong class="kf ig"><em class="kb">exec</em></strong><em class="kb"> = run command (the rest of the line) using shell<br/># d, </em><strong class="kf ig"><em class="kb">drop</em></strong><em class="kb"> = remove commit<br/>#<br/># These lines can be re-ordered; they are executed from top to <br/># bottom.<br/>#<br/># If you remove a line here THAT COMMIT WILL BE LOST.</em></span></pre><p id="d16f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，每个提交旁边都有单词<code class="eh kc kd ke kf b">pick</code>。这就是“保持提交原样”的意思如果你现在退出你的文本编辑器，它会像上一节描述的那样执行一个正常的重设基础。但是，如果您将<code class="eh kc kd ke kf b">pick</code>更改为<code class="eh kc kd ke kf b">edit</code>或其他rebase命令之一，rebase将允许您在重新应用提交之前对其进行修改！有几个可用的重设基础命令:</p><ul class=""><li id="9baa" class="kg kh if je b jf jg jj jk jn ki jr kj jv kk jz kl km kn ko dt translated"><code class="eh kc kd ke kf b"><strong class="je ig">reword</strong></code> <strong class="je ig"> : </strong>编辑提交消息。</li><li id="5ec6" class="kg kh if je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko dt translated"><code class="eh kc kd ke kf b"><strong class="je ig">edit</strong></code> <strong class="je ig"> : </strong>编辑已提交的文件。</li><li id="9a62" class="kg kh if je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko dt translated"><code class="eh kc kd ke kf b"><strong class="je ig">squash</strong></code> <strong class="je ig"> : </strong>将提交与之前的提交(文件中它上面的那个)结合起来，连接提交消息。</li><li id="eab9" class="kg kh if je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko dt translated"><code class="eh kc kd ke kf b"><strong class="je ig">fixup</strong></code></li><li id="8375" class="kg kh if je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko dt translated"><code class="eh kc kd ke kf b"><strong class="je ig">exec</strong></code> <strong class="je ig"> : </strong>运行一个任意的shell命令(稍后，在下一节中，我们将看到一个简洁的用例)。</li><li id="6690" class="kg kh if je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko dt translated"><code class="eh kc kd ke kf b"><strong class="je ig">drop</strong></code> <strong class="je ig"> : </strong>这杀死了提交者。</li></ul><p id="6559" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您还可以在文件内对提交进行重新排序，这将改变重新应用提交的顺序。如果您有处理不同主题的交叉提交，并且您想使用<code class="eh kc kd ke kf b">squash</code>或<code class="eh kc kd ke kf b">fixup</code>将它们组合成逻辑上的原子提交，这是很方便的。</p><p id="5f8b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦您设置了命令并保存了文件，Git将遍历每个提交，在每个<code class="eh kc kd ke kf b">reword</code>和<code class="eh kc kd ke kf b">edit</code>处暂停以进行您想要的更改，并自动为您应用任何<code class="eh kc kd ke kf b">squash</code>、<code class="eh kc kd ke kf b">fixup</code>、<code class="eh kc kd ke kf b">exec</code>和<code class="eh kc kd ke kf b">drop</code>命令。</p><h2 id="74ff" class="mf kv if bd kw ml mm mn la mo mp mq le jn mr ms li jr mt mu lm jv mv mw lq mx dt translated">非交互式执行</h2><p id="4e17" class="pw-post-body-paragraph jc jd if je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">当你重定基础时，你实际上是通过在指定的基础上应用你的每一个新的提交来重写历史。<code class="eh kc kd ke kf b">git pull --rebase</code>可能有点冒险，因为根据上游分支变更的性质，您可能会在新创建的历史中遇到测试失败甚至某些提交的编译问题。如果这些更改导致合并冲突，重置基础过程将暂停并允许您解决这些冲突。然而，完全合并的更改仍然可能会中断编译或测试，让中断的提交在您的历史中留下痕迹。</p><p id="733e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是，您可以指示Git为每个重写的提交运行项目的测试套件。在Git v2.9之前，您可以通过组合使用<code class="eh kc kd ke kf b">git rebase −−interactive</code>和<code class="eh kc kd ke kf b">exec</code>命令来完成这项工作。例如，这个:</p><pre class="lx ly lz ma fq mb kf mc md aw me dt"><span id="97a5" class="mf kv if kf b fv mg mh l mi mj">$ git rebase master −−interactive −−exec=”npm test”</span></pre><p id="8e3b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">…将生成一个交互式的rebase计划，在重写每个提交后调用<code class="eh kc kd ke kf b">npm test</code>，确保您的测试仍然通过:</p><pre class="lx ly lz ma fq mb kf mc md aw me dt"><span id="1df2" class="mf kv if kf b fv mg mh l mi mj"><strong class="kf ig">pick</strong> 2fde787 <em class="kb">ACE-1294: replaced miniamalCommit with string in test</em><br/><strong class="kf ig">exec</strong> npm test<br/><strong class="kf ig">pick</strong> ed93626 <em class="kb">ACE-1294: removed pull request service from test</em><br/><strong class="kf ig">exec</strong> npm test<br/><strong class="kf ig">pick</strong> b02eb9a <em class="kb">ACE-1294: moved fromHash, toHash and diffType to batch</em><br/><strong class="kf ig">exec</strong> npm test<br/><strong class="kf ig">pick</strong> e68f710 <em class="kb">ACE-1294: added testing data to batch email file</em><br/><strong class="kf ig">exec</strong> npm test</span><span id="fb26" class="mf kv if kf b fv mk mh l mi mj"># Rebase f32fa9d..0ddde5f onto f32fa9d (4 command(s))</span></pre><p id="03c9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果测试失败，rebase将暂停，让您修复测试(并将您的更改应用到提交中):</p><pre class="lx ly lz ma fq mb kf mc md aw me dt"><span id="e61f" class="mf kv if kf b fv mg mh l mi mj">291 passing<br/><strong class="kf ig">1 failing</strong></span><span id="fa81" class="mf kv if kf b fv mk mh l mi mj">1) Host request “after all” hook:<br/>Uncaught Error: connect ECONNRESET 127.0.0.1:3001<br/>…<br/><strong class="kf ig">npm ERR! Test failed.</strong><br/>Execution failed: npm test<br/>You can fix the problem, and then run<br/>        <strong class="kf ig">git rebase −−continue</strong></span></pre><p id="8556" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这很方便，但是需要做一个交互式的rebase有点笨拙。从Git v2.9开始，您可以执行非交互式rebase exec，使用:</p><pre class="lx ly lz ma fq mb kf mc md aw me dt"><span id="8708" class="mf kv if kf b fv mg mh l mi mj">$ git rebase master -x “npm test”</span></pre><p id="161c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">只需将<code class="eh kc kd ke kf b">npm test</code>替换为<code class="eh kc kd ke kf b">make</code>、<code class="eh kc kd ke kf b">rake</code>、<code class="eh kc kd ke kf b">mvn clean install</code>，或者您用来构建和测试项目的任何东西。</p><h2 id="66ad" class="mf kv if bd kw ml mm mn la mo mp mq le jn mr ms li jr mt mu lm jv mv mw lq mx dt translated">一句警告</h2><p id="79dc" class="pw-post-body-paragraph jc jd if je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">就像电影里一样，重写历史是件冒险的事情。任何被重写为rebase的一部分的提交都将改变它的SHA-1 ID，这意味着Git将把它视为完全不同的提交。如果重写的历史与原始历史混合在一起，您将得到重复的提交，这会给您的团队带来很多混乱。</p><p id="82bb" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了避免这个问题，你只需要遵循一个简单的规则:</p><blockquote class="mz"><p id="0766" class="na nb if bd nc nd ne nf ng nh ni jz ek translated">不要改变已经提交的承诺！</p></blockquote><p id="dac1" class="pw-post-body-paragraph jc jd if je b jf nk jh ji jj nl jl jm jn nm jp jq jr nn jt ju jv no jx jy jz hn dt translated">坚持下去，你会没事的。</p><h1 id="42b9" class="ku kv if bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated"><code class="eh kc kd ke kf b">Git LFS</code>的性能提升</h1><p id="5a62" class="pw-post-body-paragraph jc jd if je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated"><a class="ae ka" href="https://www.atlassian.com/git/tutorials/what-is-git/" rel="noopener ugc nofollow" target="_blank"> Git是一个分布式版本控制系统</a>，这意味着在克隆过程中，存储库的整个历史被转移到客户端。对于包含大文件的项目，尤其是定期修改的大文件<em class="kb"> — </em>初始克隆可能会很昂贵，因为每个文件的每个版本都必须由客户端下载。<a class="ae ka" href="https://www.atlassian.com/git/tutorials/git-lfs/" rel="noopener ugc nofollow" target="_blank"> Git LFS(大文件存储)</a>是由<a class="ae ka" href="https://hackernoon.com/tagged/atlassian" rel="noopener ugc nofollow" target="_blank"> Atlassian </a>、GitHub和其他一些开源贡献者开发的Git扩展，它通过延迟下载相关版本的大文件来减少大文件对存储库的影响。具体来说，大文件是在签出过程中按需下载的，而不是在克隆或获取过程中下载的。</p><p id="2e9f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">除了Git在2016年发布的五个巨大版本，Git LFS还有四个功能丰富的版本:1.2到1.5版本。<strong class="je ig"> </strong>你可以就Git LFS本身写一个回顾系列，但对于这篇文章，我将专注于2016年解决的最重要的主题之一:速度。对Git和Git LFS的一系列改进极大地提高了与服务器之间传输文件的性能。</p><h2 id="a9e2" class="mf kv if bd kw ml mm mn la mo mp mq le jn mr ms li jr mt mu lm jv mv mw lq mx dt translated">长期运行的过滤过程</h2><p id="fb0d" class="pw-post-body-paragraph jc jd if je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">当您<code class="eh kc kd ke kf b">git add</code>一个文件时，Git的干净过滤器系统可以用来在文件内容被写入Git对象存储之前对其进行转换。Git LFS通过使用干净的过滤器将大文件内容存放在LFS缓存中，并向Git对象存储中添加一个微小的“指针”文件，从而减小了存储库的大小。</p><figure class="lx ly lz ma fq hw fe ff paragraph-image"><div class="fe ff np"><img src="../Images/f2e9629541b1445eaee3b79aed768e8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/0*Ku328eca7GLOo7sS.png"/></div></figure><p id="0db5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">涂抹滤镜与清洁滤镜相反，因此得名。当在<code class="eh kc kd ke kf b">git checkout</code>期间从Git对象存储中读取文件内容时，涂抹过滤器有机会在它被写入用户的工作副本之前转换它。Git LFS涂抹滤镜通过将指针文件替换为相应的大文件来转换指针文件，这些大文件可以来自LFS缓存，也可以直接读取到Bitbucket上的Git LFS存储中。</p><figure class="lx ly lz ma fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nq"><img src="../Images/b6310945f052c04562a85f86735bfa06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CU60meE1lbCuivn7.png"/></div></div></figure><p id="12da" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">传统上，涂抹和清洁过滤过程为每个被添加或签出的文件调用一次。因此，Git LFS跟踪了一个包含1000个文件的项目，调用了1000次<code class="eh kc kd ke kf b">git-lfs-smudge</code>命令进行新的签出！虽然每个操作相对较快，但旋转1000个单独的涂抹过程的开销是昂贵的。</p><p id="d0da" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从Git v2.11(和Git LFS v1.5)开始，涂抹和清理过滤器可以被定义为长时间运行的进程，该进程为第一个过滤的文件调用一次，然后馈送需要涂抹或清理的后续文件，直到父Git操作退出。<a class="ae ka" href="https://twitter.com/kit3bus" rel="noopener ugc nofollow" target="_blank">为Git贡献长期运行过滤器的Lars Schneider </a>简洁地总结了这一变化对Git LFS性能的影响:</p><blockquote class="mz"><p id="0f11" class="na nb if bd nc nd ne nf ng nh ni jz ek translated">对于12k文件的测试报告，过滤过程在macOS上快80倍，在Windows上快58倍。在Windows上，这意味着测试在57秒内运行，而不是55分钟！</p></blockquote><p id="f914" class="pw-post-body-paragraph jc jd if je b jf nk jh ji jj nl jl jm jn nm jp jq jr nn jt ju jv no jx jy jz hn dt translated">这是一个令人印象深刻的性能提升！</p><h2 id="829e" class="mf kv if bd kw ml mm mn la mo mp mq le jn mr ms li jr mt mu lm jv mv mw lq mx dt translated">专门化的LFS克隆体</h2><p id="c4f3" class="pw-post-body-paragraph jc jd if je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">长时间运行的涂抹和清洁过滤器对于加速对本地LFS缓存的读写是很好的，但是对于加速大对象在Git LFS服务器上的来回传输却没什么帮助。每次Git LFS涂抹过滤器在本地LFS缓存中找不到文件时，它必须进行两次HTTP调用来检索它:一次定位文件，一次下载文件。在<code class="eh kc kd ke kf b">git clone</code>期间，您的本地LFS缓存是空的，所以Git LFS将天真地为您的存储库中每个LFS跟踪的文件进行两次HTTP调用:</p><figure class="lx ly lz ma fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nr"><img src="../Images/ea331cffa383be905dfddfedc8510a6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ViL7r3ZhkGvF0z3-.png"/></div></div></figure><p id="2ed8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">幸运的是，Git LFS 1.2版提供了专门的<code class="eh kc kd ke kf b"><a class="ae ka" href="https://www.atlassian.com/git/tutorials/git-lfs/#speeding-up-clones" rel="noopener ugc nofollow" target="_blank">git lfs clone</a></code>命令。而不是一次下载一个文件；<code class="eh kc kd ke kf b">git lfs clone</code>禁用Git LFS涂抹滤镜，等到结账完成，然后从Git LFS商店批量下载任何需要的文件。这允许并行下载，并将所需的HTTP请求数量减半:</p><figure class="lx ly lz ma fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ns"><img src="../Images/4cf82b3444bd2a1bf0944260db1a60e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*T43VA0DYTujDNgkH.png"/></div></div></figure><h1 id="2516" class="ku kv if bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">自定义传输适配器</h1><p id="3051" class="pw-post-body-paragraph jc jd if je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">如前所述，Git LFS在1.5版中发布了对长时间运行的过滤器进程的支持。然而，对另一种类型的可插拔进程的支持实际上是在今年早些时候发布的。Git LFS 1.3版包含了对可插拔传输适配器的支持，因此不同的Git LFS托管服务可以定义自己的协议，在LFS存储器之间传输文件。</p><p id="8c0b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">截至2016年底，Bitbucket是唯一一家通过<a class="ae ka" href="https://confluence.atlassian.com/bitbucket/bitbucket-lfs-media-adapter-856699998.html" rel="noopener ugc nofollow" target="_blank"> Bitbucket LFS媒体适配器</a>实现自己的Git LFS传输协议的托管服务。这样做是为了利用Bitbucket的LFS存储API的一个独特功能，即分块。分块意味着大文件在上传或下载前被分解成4MB的块。</p><figure class="lx ly lz ma fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nt"><img src="../Images/471a9f9b0b9e4d3fee64af3ccb5040c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*N3SpjQZQ1Ge8OwvWrtS1og.gif"/></div></div></figure><p id="ea74" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">分块给Bitbucket的Git LFS支持带来了三大优势:</p><ol class=""><li id="e7b0" class="kg kh if je b jf jg jj jk jn ki jr kj jv kk jz nu km kn ko dt translated"><strong class="je ig">并行下载和上传。默认情况下，Git LFS并行传输多达三个文件。但是，如果只传输一个文件(这是Git LFS涂抹滤镜的默认行为)，它将通过单个流传输。Bitbucket的分块功能允许同时上传或下载来自同一个文件的多个块，通常可以显著提高传输速度。</strong></li><li id="cf0c" class="kg kh if je b jf kp jj kq jn kr jr ks jv kt jz nu km kn ko dt translated"><strong class="je ig">可恢复的块传输。</strong>文件块在本地缓存，因此如果您的下载或上传被中断，Bitbucket的自定义LFS媒体适配器将在您下次推送或拉入时仅恢复传输丢失的块。</li><li id="41e0" class="kg kh if je b jf kp jj kq jn kr jr ks jv kt jz nu km kn ko dt translated"><strong class="je ig">重复数据删除。</strong> Git LFS和Git本身一样，是内容可寻址的；每个LFS文件由其内容的阿沙-256散列来标识。因此，如果你翻转一个比特，文件的SHA-256就会改变，你必须重新上传整个文件。分块允许您仅重新上传文件中实际发生更改的部分。举例来说，假设我们有一个41MB的spritesheet，用于在Git LFS跟踪的视频游戏。如果我们向spritesheet添加一个新的2MB层并提交它，我们通常需要将整个新的43MB文件推送到服务器。然而，使用Bitbucket的自定义传输适配器，我们只需要推送大约7Mb:第一个4MB的块(因为文件的头信息已经改变)和最后一个包含我们刚刚添加的新层的3MB块！在上传过程中，其他未更改的块会被自动跳过，从而节省大量带宽和时间。</li></ol><p id="3c30" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">可定制的传输适配器是Git LFS的一个很好的特性，因为它们允许不同的主机试验优化的传输协议来适应它们的服务，而不会使核心项目过载。</p><h1 id="4208" class="ku kv if bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">更好的<code class="eh kc kd ke kf b">git diff</code>算法和默认值</h1><p id="20d0" class="pw-post-body-paragraph jc jd if je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">与其他一些版本控制系统不同，Git不会显式存储文件已被重命名的事实。例如，如果我编辑了一个简单的Node.js应用程序，并将<code class="eh kc kd ke kf b">index.js</code>重命名为<code class="eh kc kd ke kf b">app.js</code>，然后运行<code class="eh kc kd ke kf b">git diff</code>，我将得到看起来像是文件删除和添加的结果:</p><figure class="lx ly lz ma fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nv"><img src="../Images/2dc2d5af8d3384c3dc6dff55209cd223.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ohMUBpSh_jqz2ffScJ7ApQ.png"/></div></div></figure><p id="8e06" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我想移动或重命名一个文件从技术上来说只是一个删除和一个添加，但这不是最人性化的表达方式。相反，您可以使用<code class="eh kc kd ke kf b">-M</code>标志来指示Git在计算diff时尝试动态检测重命名的文件。对于上面的例子，<code class="eh kc kd ke kf b">git diff -M</code>给了我们:</p><figure class="lx ly lz ma fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nw"><img src="../Images/f50c153bead909f31df87d285023c416.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ywYjxBc1wii5O8EhHbpCTA.png"/></div></div></figure><p id="49cc" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第二行的相似性指数告诉我们所比较的文件内容有多相似。默认情况下，<code class="eh kc kd ke kf b">-M</code>将考虑任何两个相似度超过50%的文件。也就是说，您需要修改少于50%的行，以使它们与重命名的文件相同。您可以通过附加一个百分比来选择自己的相似性指数，即<code class="eh kc kd ke kf b">-M80%</code>。</p><p id="fd94" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从Git v2.9开始，<code class="eh kc kd ke kf b">git diff</code>和<code class="eh kc kd ke kf b">git log</code>命令都会默认检测重命名，就好像你已经通过了<code class="eh kc kd ke kf b">-M</code>标志一样。如果您不喜欢这种行为(或者更现实地说，通过脚本解析diff输出)，那么您可以通过显式传递<code class="eh kc kd ke kf b">−−no-renames</code>标志来禁用它。</p><h2 id="ee96" class="mf kv if bd kw ml mm mn la mo mp mq le jn mr ms li jr mt mu lm jv mv mw lq mx dt translated">详细提交</h2><p id="942a" class="pw-post-body-paragraph jc jd if je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">你是否曾经调用过<code class="eh kc kd ke kf b">git commit</code>，然后茫然地看着你的shell，试图记住你刚刚做的所有更改？详细标志是给你的！</p><p id="27d8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">而不是:</p><pre class="lx ly lz ma fq mb kf mc md aw me dt"><span id="86f4" class="mf kv if kf b fv mg mh l mi mj"><em class="kb">Ah crap, which dependency did I just rev?</em></span><span id="362f" class="mf kv if kf b fv mk mh l mi mj"># Please enter the commit message for your changes. Lines starting<br/># with ‘#’ will be ignored, and an empty message aborts the commit.<br/># On branch master<br/># Your branch is up-to-date with ‘origin/master’.<br/>#<br/># Changes to be committed:<br/># new file: package.json<br/>#</span></pre><p id="31b1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">…您可以调用<code class="eh kc kd ke kf b">git commit −−verbose</code>来查看您的更改的内联差异。别担心，它不会包含在您的提交消息中:</p><figure class="lx ly lz ma fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nx"><img src="../Images/5d040e030be223eece95332a1650b276.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1vOYE2ow3ZDS8BP_QfssQw.png"/></div></div></figure><p id="095b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kc kd ke kf b">−−verbose</code>标志不是新的，但是从Git v2.9开始，您可以使用<code class="eh kc kd ke kf b">git config --global <strong class="je ig">commit.verbose </strong>true</code>永久启用它。</p><h2 id="9177" class="mf kv if bd kw ml mm mn la mo mp mq le jn mr ms li jr mt mu lm jv mv mw lq mx dt translated">实验差异改进</h2><p id="f2f2" class="pw-post-body-paragraph jc jd if je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated"><code class="eh kc kd ke kf b">git diff</code>当修改部分前后的行相同时，可能会产生一些稍微令人困惑的输出。当一个文件中有两个或更多结构相似的函数时，就会发生这种情况。对于一个略显做作的例子，假设我们有一个包含单一函数的JS文件:</p><pre class="lx ly lz ma fq mb kf mc md aw me dt"><span id="374a" class="mf kv if kf b fv mg mh l mi mj"><em class="kb">/* @return {string} "Bitbucket" */</em><br/><strong class="kf ig">function</strong> productName() {<br/>  <strong class="kf ig">return</strong> "Bitbucket";<br/>}</span></pre><p id="bd5f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，假设我们已经提交了一个变更，在<em class="kb">前添加了另一个</em>函数，该函数具有类似的功能:</p><pre class="lx ly lz ma fq mb kf mc md aw me dt"><span id="5936" class="mf kv if kf b fv mg mh l mi mj"><em class="kb">/* @return {string} "Bitbucket" */</em><br/><strong class="kf ig">function</strong> productId() {<br/>  <strong class="kf ig">return</strong> "Bitbucket";<br/>}</span><span id="b315" class="mf kv if kf b fv mk mh l mi mj"><em class="kb">/* @return {string} "Bitbucket" */</em><br/><strong class="kf ig">function</strong> productName() {<br/>  <strong class="kf ig">return</strong> "Bitbucket";<br/>}</span></pre><p id="c554" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可能希望<code class="eh kc kd ke kf b">git diff</code>显示添加的前五行，但是它实际上错误地将第一行归属于原始提交:</p><figure class="lx ly lz ma fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nv"><img src="../Images/e8756ae4d8bd2aa787ed5e45f809f558.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9C7DWMObGHMEqD-QFGHmew.png"/></div></div></figure><p id="bdeb" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">diff中包含错误的注释！不是世界末日，而是来自<em class="kb"> Whaaat的几秒认知开销？</em>每次发生这种情况都会累加起来。</p><p id="4581" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">12月，Git v2.11引入了一个新的实验性差异选项<code class="eh kc kd ke kf b">--indent-heuristic</code>，试图产生更具美感的差异:</p><figure class="lx ly lz ma fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ny"><img src="../Images/cd0a9b082c34e6a4915b90ba2e699ab3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UyWZ6JjC-izDquyWCA4bow.png"/></div></div></figure><p id="f598" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在引擎盖下，<code class="eh kc kd ke kf b">--indent-heuristic</code>循环遍历每个变更的可能差异，并给每个差异分配一个“不良”分数。这是基于试探法的，比如diff块是否以不同级别的缩进开始和结束(这在美学上是不好的)，以及diff块是否有前导和尾随空行(这在美学上是令人愉快的)。然后，输出具有最低不良分数的块。</p><p id="d21c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个特性是实验性的，但是您可以通过将<code class="eh kc kd ke kf b">--indent-heuristic</code>选项应用到任何<code class="eh kc kd ke kf b">git diff</code>命令来测试它。或者，如果您喜欢生活在危险边缘，您可以通过以下方式在您的系统中启用它:</p><pre class="lx ly lz ma fq mb kf mc md aw me dt"><span id="ebf8" class="mf kv if kf b fv mg mh l mi mj">$ git config --global <strong class="kf ig">diff.indentHeuristic</strong> true</span></pre><h1 id="a5c3" class="ku kv if bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">吸得少的子模块</h1><p id="4027" class="pw-post-body-paragraph jc jd if je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">子模块允许您从您的Git存储库中引用和包含其他Git存储库。这通常被一些项目用来管理也在Git中被跟踪的源代码依赖，或者被一些公司用来替代包含相关项目集合的monorepo。</p><p id="74a8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于一些用法的复杂性，以及用一个错误的命令很容易破坏子模块的事实，子模块得到了一些不好的评价。</p><figure class="lx ly lz ma fq hw fe ff paragraph-image"><div class="fe ff my"><img src="../Images/4c8b7a54698a99e409d8d9469e0c6074.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*xNffiElY7BZNMDM0jm0JNQ.gif"/></div></figure><p id="9e11" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，它们确实有它们的用途，我认为它们仍然是出售依赖项的最佳选择。幸运的是，2016年对于子模块用户来说是很棒的一年，几个版本都有一些重大的性能和功能改进。</p><h2 id="88ea" class="mf kv if bd kw ml mm mn la mo mp mq le jn mr ms li jr mt mu lm jv mv mw lq mx dt translated">并行提取</h2><p id="f890" class="pw-post-body-paragraph jc jd if je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">当克隆或获取一个存储库时，附加<code class="eh kc kd ke kf b">--recurse-submodules</code>选项意味着任何被引用的子模块也将被克隆或更新。传统上，这是串行完成的，每次取一个子模块。从Git v2.8开始，您可以添加<code class="eh kc kd ke kf b">--jobs=n</code>选项来获取<em class="kb"> n </em>并行线程中的子模块。</p><p id="324c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我建议使用以下选项永久配置此选项:</p><pre class="lx ly lz ma fq mb kf mc md aw me dt"><span id="1bc1" class="mf kv if kf b fv mg mh l mi mj">$ git config --global <strong class="kf ig">submodule.fetchJobs</strong> 4</span></pre><p id="ead8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">…或者您选择使用的任何并行度。</p><h2 id="1004" class="mf kv if bd kw ml mm mn la mo mp mq le jn mr ms li jr mt mu lm jv mv mw lq mx dt translated">浅层子模块</h2><p id="fe99" class="pw-post-body-paragraph jc jd if je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">Git v2.9引入了<code class="eh kc kd ke kf b">git clone -−shallow-submodules</code>标志。它允许您获取存储库的完整克隆，然后递归地浅层克隆任何被引用的子模块，直到一次提交的深度。如果您不需要项目依赖项的完整历史，这将非常有用。</p><p id="b024" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如，考虑一个混合了子模块的存储库，这些子模块包含供应商提供的依赖项和您拥有的其他项目。您可能希望最初克隆较浅的子模块，然后有选择地深化您想要使用的几个项目。</p><p id="379d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一个场景是配置持续集成或部署作业。Git需要超级存储库以及来自每个子模块的最新提交，以便实际执行构建。然而，您可能不需要每个子模块的完整历史，所以只检索最近的提交将节省您的时间和带宽。</p><h2 id="b303" class="mf kv if bd kw ml mm mn la mo mp mq le jn mr ms li jr mt mu lm jv mv mw lq mx dt translated">子模块交替</h2><p id="22cf" class="pw-post-body-paragraph jc jd if je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated"><code class="eh kc kd ke kf b">--reference</code>选项可以和<code class="eh kc kd ke kf b">git clone</code>一起使用，指定另一个本地存储库作为备用对象存储库，以保存网络上已有的本地复制对象。语法是:</p><pre class="lx ly lz ma fq mb kf mc md aw me dt"><span id="688e" class="mf kv if kf b fv mg mh l mi mj">$ git clone <strong class="kf ig">--reference &lt;local repo&gt;</strong> &lt;url&gt;</span></pre><p id="3b7a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从Git v2.11开始，您可以结合使用<code class="eh kc kd ke kf b">--reference</code>选项和<code class="eh kc kd ke kf b">--recurse-submodules</code>来设置指向另一个本地存储库中的子模块的子模块替换。语法是:</p><pre class="lx ly lz ma fq mb kf mc md aw me dt"><span id="0588" class="mf kv if kf b fv mg mh l mi mj">$ git clone <strong class="kf ig">--recurse-submodules</strong> --reference &lt;local repo&gt; &lt;url&gt;</span></pre><p id="6f69" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这可能会节省大量的带宽和本地磁盘，但是如果引用的本地存储库没有您要从中克隆的远程存储库的所有必需的子模块，这将会失败。</p><p id="ba96" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">幸运的是，方便的<code class="eh kc kd ke kf b">--reference-if-able</code>选项将会正常失败，并且对于引用的本地存储库中缺失的任何子模块，将会退回到正常的克隆:</p><pre class="lx ly lz ma fq mb kf mc md aw me dt"><span id="912f" class="mf kv if kf b fv mg mh l mi mj">$ git clone --recurse-submodules <strong class="kf ig">--reference-if-able</strong> \<br/>&lt;local repo&gt; &lt;url&gt;</span></pre><h2 id="18ef" class="mf kv if bd kw ml mm mn la mo mp mq le jn mr ms li jr mt mu lm jv mv mw lq mx dt translated">子模块差异</h2><p id="45fa" class="pw-post-body-paragraph jc jd if je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">在Git v2.11之前，Git有两种模式来显示更新存储库子模块的提交差异:</p><p id="20e0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kc kd ke kf b">git diff --submodule=short</code>显示您的项目所引用的子模块中的旧提交和新提交(如果您完全省略了<code class="eh kc kd ke kf b">--submodule</code>选项，这也是默认设置):</p><figure class="lx ly lz ma fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nz"><img src="../Images/c60b4e8dd105f5f781cef2aac28d4f29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K71cJ30NokO5B69-a470NA.png"/></div></div></figure><p id="8021" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kc kd ke kf b">git diff --submodule=log</code>稍微详细一些，在更新的子模块中显示任何新的或删除的提交的提交消息的摘要行:</p><figure class="lx ly lz ma fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff oa"><img src="../Images/c96a6a80fd35f5902eb45ae2fabac37a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*frvsd_T44De8_q0uvNHB1g.png"/></div></div></figure><p id="19dd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Git v2.11引入了第三个更有用的选项:<code class="eh kc kd ke kf b">--submodule=diff</code>。这将显示更新的子模块中所有更改的完整差异:</p><figure class="lx ly lz ma fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff oa"><img src="../Images/a52d15113a14572b101a1cf75f732d10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nPhJTjP8tcJ0cD8s3YOmjw.png"/></div></div></figure><h1 id="c230" class="ku kv if bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">对<code class="eh kc kd ke kf b">git stash</code>的巧妙增强</h1><p id="5171" class="pw-post-body-paragraph jc jd if je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">与子模块不同，<code class="eh kc kd ke kf b"><a class="ae ka" href="https://www.atlassian.com/git/tutorials/git-stash/" rel="noopener ugc nofollow" target="_blank">git stash</a></code>几乎普遍受到Git用户的喜爱。暂时搁置(或<em class="kb">隐藏</em>)您对工作副本所做的更改，以便您可以处理其他内容，然后回来重新应用它们。</p><h2 id="9de2" class="mf kv if bd kw ml mm mn la mo mp mq le jn mr ms li jr mt mu lm jv mv mw lq mx dt translated">自动堆叠</h2><p id="0c3a" class="pw-post-body-paragraph jc jd if je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">如果你是<code class="eh kc kd ke kf b">git rebase</code>的粉丝，你可能对<code class="eh kc kd ke kf b">--autostash</code>选项很熟悉。它会在重置基础前自动隐藏对工作副本所做的任何本地更改，并在重置基础完成后重新应用这些更改。</p><pre class="lx ly lz ma fq mb kf mc md aw me dt"><span id="fe0e" class="mf kv if kf b fv mg mh l mi mj"><strong class="kf ig">$ git rebase master --autostash</strong><br/>Created autostash: 54f212a<br/>HEAD is now at 8303dca <em class="kb">It's a kludge, but put the tuple from the database in the cache.</em><br/>First, rewinding head to replay your work on top of it...<br/>Applied autostash.</span></pre><p id="889a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这很方便，因为它允许你从一个脏的工作树重新开始。还有一个名为<code class="eh kc kd ke kf b">rebase.autostash</code>的便利的配置标志使这种行为成为默认，您可以使用以下命令全局启用它:</p><pre class="lx ly lz ma fq mb kf mc md aw me dt"><span id="c047" class="mf kv if kf b fv mg mh l mi mj">$ git config --global <strong class="kf ig">rebase.autostash</strong> true</span></pre><p id="6685" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kc kd ke kf b">rebase.autostash</code>实际上从<a class="ae ka" href="https://blogs.atlassian.com/2013/08/what-you-need-to-know-about-the-new-git-1-8-4/" rel="noopener ugc nofollow" target="_blank"> Git v1.8.4 </a>开始就可用了，但是v2.7引入了用<code class="eh kc kd ke kf b">--no-autostash</code>选项取消该标志的能力。如果您将此选项用于未分级的更改，重置基础将中止，并显示一个脏工作树警告:</p><pre class="lx ly lz ma fq mb kf mc md aw me dt"><span id="528c" class="mf kv if kf b fv mg mh l mi mj"><strong class="kf ig">$ git rebase master --no-autostash</strong><br/>Cannot rebase: You have unstaged changes.<br/>Please commit or stash them.</span></pre><h2 id="8441" class="mf kv if bd kw ml mm mn la mo mp mq le jn mr ms li jr mt mu lm jv mv mw lq mx dt translated">作为补丁存储</h2><p id="e5dd" class="pw-post-body-paragraph jc jd if je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">说到配置标志，Git v2.7也引入了<code class="eh kc kd ke kf b">stash.showPatch</code>。<code class="eh kc kd ke kf b">git stash show</code>的默认行为是显示你的隐藏文件的摘要。</p><pre class="lx ly lz ma fq mb kf mc md aw me dt"><span id="be7c" class="mf kv if kf b fv mg mh l mi mj"><strong class="kf ig">$ git stash show</strong><br/>package.json | 2 +-<br/>1 file changed, 1 insertion(+), 1 deletion(-)</span></pre><p id="5a1a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">传递<code class="eh kc kd ke kf b">-p</code>标志将<code class="eh kc kd ke kf b">git stash show</code>置于“补丁模式”，显示完整的差异:</p><figure class="lx ly lz ma fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ob"><img src="../Images/abaf3d71f12c6279aeed5e7473ffb58e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HpcT3quuKKQj9CneqPuufw.png"/></div></div></figure><p id="5b4d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kc kd ke kf b">stash.showPatch</code>将此行为设为默认。您可以通过以下方式全局启用它:</p><pre class="lx ly lz ma fq mb kf mc md aw me dt"><span id="5d70" class="mf kv if kf b fv mg mh l mi mj">$ git config --global <strong class="kf ig">stash.showPatch</strong> true</span></pre><p id="6957" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您启用了<code class="eh kc kd ke kf b">stash.showPatch</code>,但随后决定只查看文件摘要，您可以通过传递<code class="eh kc kd ke kf b">--stat</code>选项来恢复原来的行为。</p><pre class="lx ly lz ma fq mb kf mc md aw me dt"><span id="41e1" class="mf kv if kf b fv mg mh l mi mj"><strong class="kf ig">$ git stash show --stat<br/></strong>package.json | 2 +-<br/>1 file changed, 1 insertion(+), 1 deletion(-)</span></pre><p id="f074" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作为题外话:<code class="eh kc kd ke kf b">--no-patch</code>是一个有效的选项，但它不会像你所期望的那样否定<code class="eh kc kd ke kf b">stash.showPatch</code>。相反，它被传递给用于生成补丁的底层<code class="eh kc kd ke kf b">git diff</code>命令，最终您将没有任何输出！</p><h2 id="7635" class="mf kv if bd kw ml mm mn la mo mp mq le jn mr ms li jr mt mu lm jv mv mw lq mx dt translated">简单的隐藏id</h2><p id="8e2c" class="pw-post-body-paragraph jc jd if je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">如果您是一个<code class="eh kc kd ke kf b">git stash</code>爱好者，您可能知道您可以搁置多组变更，然后用<code class="eh kc kd ke kf b">git stash list</code>查看它们:</p><pre class="lx ly lz ma fq mb kf mc md aw me dt"><span id="ef5c" class="mf kv if kf b fv mg mh l mi mj"><strong class="kf ig">$ git stash list</strong><br/>stash@{0}: On master: crazy idea that might work one day<br/>stash@{1}: On master: desperate samurai refactor; don't apply<br/>stash@{2}: On master: perf improvement that I forgot I stashed<br/>stash@{3}: On master: pop this when we use Docker in production</span></pre><p id="3702" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是，你可能不知道为什么Git的stashes有这么别扭的标识符(<code class="eh kc kd ke kf b">stash@{1}</code>、<code class="eh kc kd ke kf b">stash@{2}</code>等)。)并且可能已经把它们当作“Git的一种特质”而一笔勾销了事实证明，像许多Git特性一样，这些奇怪的id实际上是Git数据模型的一种非常巧妙的使用(或滥用)的症状。</p><p id="b82b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在幕后，<code class="eh kc kd ke kf b">git stash</code>命令实际上创建了一组特殊的提交对象，这些对象对您隐藏的更改进行编码，并维护了一个<a class="ae ka" href="https://www.atlassian.com/git/tutorials/refs-and-the-reflog/" rel="noopener ugc nofollow" target="_blank"> reflog </a>，其中保存了对这些特殊提交的引用。这就是为什么<code class="eh kc kd ke kf b">git stash list</code>的输出看起来很像<code class="eh kc kd ke kf b">git reflog</code>命令的输出。当您运行<code class="eh kc kd ke kf b">git stash apply stash@{1}</code>时，您实际上是在说，“从stash reflog的位置1应用提交。”</p><p id="6925" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从Git v2.11开始，您不再需要使用完整的<code class="eh kc kd ke kf b">stash@{n}</code>语法。相反，您可以用一个简单的整数来引用stash，该整数表示它们在stash reflog中的位置:</p><pre class="lx ly lz ma fq mb kf mc md aw me dt"><span id="1b05" class="mf kv if kf b fv mg mh l mi mj">$ git stash show 1<br/>$ git stash apply 1<br/>$ git stash pop 1</span></pre><p id="319c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">诸如此类。如果你想了解更多关于如何储存物品的信息，我在<a class="ae ka" href="https://www.atlassian.com/git/tutorials/git-stash/#how-git-stash-works" rel="noopener ugc nofollow" target="_blank">这篇教程</a>中写了一点。</p><h1 id="eaf8" class="ku kv if bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt">&lt;/2016&gt; &lt;2017&gt;</h1><p id="79f3" class="pw-post-body-paragraph jc jd if je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">我们结束了。感谢阅读！我希望你喜欢阅读这个庞然大物，就像我喜欢钻研Git的源代码、发行说明和编写它的页面一样。如果你认为我错过了什么大事，请留下评论或在推特上告诉我<a class="ae ka" href="https://twitter.com/kannonboy" rel="noopener ugc nofollow" target="_blank">，我会努力写一篇后续文章。</a></p><p id="6648" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">至于Git的下一步是什么，这取决于维护者和贡献者(其中<a class="ae ka" href="https://git.kernel.org/cgit/git/git.git/tree/Documentation/SubmittingPatches" rel="noopener ugc nofollow" target="_blank">可能是你！</a>)。随着越来越多的采用，我猜想简化、改进的UX和更好的默认值将是Git在2017年的主题。随着Git存储库变得越来越大，我怀疑我们还会看到对性能的持续关注和对大文件、深树和长历史的改进处理。</p><p id="3201" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你对Git感兴趣，并且很想见到项目背后的一些开发者，可以考虑几周后来布鲁塞尔参加<a class="ae ka" href="http://git-merge.com/" rel="noopener ugc nofollow" target="_blank"> Git Merge </a>。我是<a class="ae ka" href="http://git-merge.com/#git-aliases" rel="noopener ugc nofollow" target="_blank">在那里说话</a>！但更重要的是，许多维护Git的开发人员将会出席会议和年度Git贡献者峰会，这很可能会推动未来一年的发展方向。</p><p id="23cd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">或者，如果你不能等到那个时候，去看看Atlassian精选的<a class="ae ka" href="https://www.atlassian.com/git/tutorials" rel="noopener ugc nofollow" target="_blank"> Git教程</a>，获得更多的技巧和窍门来改进你的工作流程。</p><p id="1124" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="kb">如果您滚动到末尾寻找第一段的脚注，请跳转到</em> <a class="ae ka" href="#87c4" rel="noopener ugc nofollow"> <em class="kb">【需要引用】</em> </a> <em class="kb">部分了解用于生成统计数据的命令。免费封面图片使用</em><a class="ae ka" href="http://instaco.de/" rel="noopener ugc nofollow" target="_blank"><em class="kb">insta co . de</em></a><em class="kb">❤️</em>生成</p><div class="lx ly lz ma fq ab cb"><figure class="oc hw od oe of og oh paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="oc hw od oe of og oh paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="oc hw od oe of og oh paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="oi oj ok"><p id="f922" class="jc jd kb je b jf jg jh ji jj jk jl jm ol jo jp jq om js jt ju on jw jx jy jz hn dt translated"><a class="ae ka" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是阿美族家庭的一员。我们现在<a class="ae ka" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ka" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd kb je b jf jg jh ji jj jk jl jm ol jo jp jq om js jt ju on jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ka" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ka" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lx ly lz ma fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff oo"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="lx ly lz ma fq hw"><div class="bz el l di"><div class="op oq l"/></div></figure></div></div>    
</body>
</html>