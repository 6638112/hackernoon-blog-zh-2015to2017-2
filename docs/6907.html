<html>
<head>
<title>Serve it up with Servant!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用仆人端上来！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/serve-it-up-with-servant-774185858d19?source=collection_archive---------27-----------------------#2017-10-09">https://medium.com/hackernoon/serve-it-up-with-servant-774185858d19?source=collection_archive---------27-----------------------#2017-10-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="de35" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://www.mmhaskell.com/blog/2017/10/2/trouble-with-databases-persevere-with-persistent" rel="noopener ugc nofollow" target="_blank">上周</a>我们通过学习<a class="ae jp" href="https://hackage.haskell.org/package/persistent" rel="noopener ugc nofollow" target="_blank">持久</a>开始了我们关于生产Haskell技术的系列。我们创建了一个包含单个<code class="eh jq jr js jt b">User</code>类型的模式，可以存储在Postgresql数据库中。我们研究了几个允许我们对这些用户进行SQL查询的函数。</p><p id="aa9e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本周，我们将看到如何使用API向外界公开这个数据库。我们将使用<a class="ae jp" href="https://hackage.haskell.org/package/servant" rel="noopener ugc nofollow" target="_blank">服务</a>库来构建我们的API。Servant涉及一些高级类型级别的构造，所以有很多东西需要考虑。肯定有比Servant使用的方法更简单的HTTP服务器方法。但是我发现仆人给我们的力量是值得努力的。</p><p id="3a7f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本文将对仆人做一个简要的概述。但是如果你想要更深入的介绍，你应该看看我去年春天在Bayhac 的<a class="ae jp" href="https://www.youtube.com/watch?v=19HTfXFmwvA" rel="noopener ugc nofollow" target="_blank">演讲！那次演讲更加详尽地介绍了可以在API中使用的不同组合子。它还展示了身份验证技术、客户机功能和文档。您还可以查看该演示的</a><a class="ae jp" href="https://www.mmhaskell.com/bayhac" rel="noopener ugc nofollow" target="_blank">幻灯片和代码</a>！</p><p id="cd9a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另外，看看这个项目的Github repo上的<a class="ae jp" href="https://github.com/jhb563/ProdHaskellSeries/tree/servant" rel="noopener ugc nofollow" target="_blank"> servant branch </a>来查看本文的所有代码！</p><h1 id="2b3d" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">定义我们的API</h1><p id="8f31" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">为我们的用户数据库编写API的第一步是决定不同的端点是什么。我们可以独立于使用什么语言或库来决定这一点。对于本文，我们的API将有两个不同的端点。第一个是对<code class="eh jq jr js jt b">/users</code>的POST请求。这个请求的主体将包含一个“用户”定义，结果是我们将在数据库中创建一个用户。以下是这种情况的一个示例:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="c39c" class="lf jv hu jt b fv lg lh l li lj">POST /users<br/>{<br/>  userName : “John Doe”,<br/>  userEmail : “john@doe.com”,<br/>  userAge : 29,<br/>  userOccupation: “Teacher”<br/>}</span></pre><p id="d227" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，它将返回一个包含我们创建的用户的数据库密钥的响应。这将允许任何客户端再次获取用户。第二个端点将使用ID通过数据库标识符获取用户。这将是对<code class="eh jq jr js jt b">/users/:userid</code>的一个GET请求。例如，最后一个请求可能会返回类似于<code class="eh jq jr js jt b">16</code>的内容。然后，我们可以执行以下操作:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="caf7" class="lf jv hu jt b fv lg lh l li lj">GET /users/16</span></pre><p id="7894" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的响应看起来就像上面的请求体。</p><h1 id="6ddb" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">作为类型的API</h1><p id="cb50" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">所以我们有了非常简单的API。在Haskell中，具体来说，在Servant中，我们如何定义它呢？嗯，Servant做了一些非常独特的事情(据我所知)。在Servant中，我们通过使用类型来定义我们的API。我们的类型将包括API的每个端点的子类型。我们通过使用<code class="eh jq jr js jt b">(:&lt;|&gt;)</code>操作符来组合不同的端点。我有时会称之为“E-plus”，意为“endpoint-plus”。这是一个类型运算符，就像我们在<a class="ae jp" href="https://mmhaskell.com/blog/2017/9/11/deep-learning-and-deep-types-tensor-flow-and-dependent-types" rel="noopener ugc nofollow" target="_blank">依赖类型和张量流</a>中看到的一些运算符一样。这是我们API的蓝图:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="64c9" class="lf jv hu jt b fv lg lh l li lj">type UsersAPI = <br/>  fetchEndpoint<br/>  :&lt;|&gt; createEndpoint</span></pre><p id="c3dd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们定义一下<code class="eh jq jr js jt b">fetchEndpoint</code>和<code class="eh jq jr js jt b">createEndpoint</code>的含义。端点组合了描述端点不同信息的不同组合符。我们用<code class="eh jq jr js jt b">(:&gt;)</code>操作符将组合子联系在一起，我称之为“C-plus”(组合子加)。这是我们最终的API的样子。我们将在下一节讨论每个组合子的含义:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="a6e8" class="lf jv hu jt b fv lg lh l li lj">type UsersAPI =<br/>       “users” :&gt; Capture “userid” Int64 :&gt; Get ‘[JSON] User<br/>  :&lt;|&gt; “users” :&gt; ReqBody ‘[JSON] User :&gt; Post ‘[JSON] Int64</span></pre><h1 id="5c49" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">不同的组合子</h1><p id="cc46" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">这两个端点都有三个不同的组合子。让我们从检查获取端点开始。它从一个字符串组合子开始。这是一个路径组件，允许我们指定调用者应该使用什么url扩展来访问端点。我们可以多次使用这个组合子，为端点创建一个更复杂的路径。如果我们想让这个端点在<code class="eh jq jr js jt b">/api/users/:userid</code>，那么我们可以把它改成:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="6b04" class="lf jv hu jt b fv lg lh l li lj">“api” :&gt; “users” :&gt; Capture “userid” Int64 :&gt; Get ‘[JSON] User</span></pre><p id="6d2d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第二个组合子(<code class="eh jq jr js jt b">Capture</code>)允许我们从URL本身获取一个值。我们给这个值一个名字，然后提供一个类型参数。我们不需要自己做任何路径解析或操作。Servant将处理解析URL并传递给我们一个<code class="eh jq jr js jt b">Int64</code>的棘手任务。如果您想将自己的自定义类用作一段HTTP数据，这并不太难。您只需从HttpApiData 类中编写一个<a class="ae jp" href="https://hackage.haskell.org/package/http-api-data-0.3.7.1/docs/Web-HttpApiData.html#t:FromHttpApiData" rel="noopener ugc nofollow" target="_blank">的实例。所有像<code class="eh jq jr js jt b">Int64</code>这样的基本类型都已经有了实例。</a></p><p id="ef57" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最终的组合符本身包含这个端点的三条重要信息。首先，它告诉我们这实际上是一个<code class="eh jq jr js jt b">GET</code>请求。其次，它给出了响应中允许的内容类型列表。这是内容格式的类型级别列表。这个列表中的每个类型都必须有不同的类来序列化和反序列化我们的数据。我们可以使用更复杂的列表，比如<code class="eh jq jr js jt b">’[JSON, PlainText, OctetStream]</code>。但是对于本文的其余部分，我们将只使用<code class="eh jq jr js jt b">JSON</code>。这意味着我们将使用<code class="eh jq jr js jt b">ToJSON</code>和<code class="eh jq jr js jt b">FromJSON</code>类型类进行序列化。</p><p id="7a76" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个组合子的最后一部分是我们的端点返回的类型。因此，一个成功的请求将向调用者返回一个包含JSON格式的<code class="eh jq jr js jt b">User</code>的响应。注意这不是一个<code class="eh jq jr js jt b">Maybe User</code>。如果ID不在我们的数据库中，我们将返回401错误来指示失败，而不是返回<code class="eh jq jr js jt b">Nothing</code>。</p><p id="60ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的第二个端点有许多相似之处。它使用相同的字符串路径组件。那么它的最终组合符是相同的，除了它表明它是一个<code class="eh jq jr js jt b">POST</code>请求而不是一个<code class="eh jq jr js jt b">GET</code>请求。第二个组合子告诉我们，我们可以期望请求体看起来像什么。在这种情况下，请求体应该包含一个<code class="eh jq jr js jt b">User</code>的JSON表示。它需要一个可接受的内容类型列表，然后是我们想要的类型，比如<code class="eh jq jr js jt b">Get</code>和<code class="eh jq jr js jt b">Post</code>组合子。</p><p id="0cf5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就完成了我们API的“定义”。我们将需要添加我们的<code class="eh jq jr js jt b">User</code>类型的<code class="eh jq jr js jt b">ToJSON</code>和<code class="eh jq jr js jt b">FromJSON</code>实例，以使其发挥作用。你可以看看那些在<a class="ae jp" href="https://github.com/jhb563/ProdHaskellSeries/blob/servant/src/Schema.hs" rel="noopener ugc nofollow" target="_blank"> Github </a>上的，并且查看<a class="ae jp" href="https://mmhaskell.com/blog/2017/6/5/flexible-data-with-aeson" rel="noopener ugc nofollow" target="_blank">这篇文章</a>来获得关于创建那些实例的更多细节！</p><h1 id="532e" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">编写处理程序</h1><p id="b2ce" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">既然我们已经定义了API的类型，我们需要为每个端点编写处理函数。这就是仆人的魅力所在。我们可以根据端点中的组合子将每个端点映射到一个具有特定类型的函数。因此，首先让我们记住获取用户的端点:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="7872" class="lf jv hu jt b fv lg lh l li lj">“users” :&gt; Capture “userid” Int64 :&gt; Get ‘[JSON] User</span></pre><p id="0fdb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">字符串路径组件没有给我们的函数添加任何参数。组件<code class="eh jq jr js jt b">Capture</code>将产生一个类型为<code class="eh jq jr js jt b">Int64</code>的参数，这是我们在函数中需要的。那么我们函数的返回类型应该是<code class="eh jq jr js jt b">User</code>。这几乎完全定义了我们的处理程序的类型签名。不过我们会注意到它需要在<code class="eh jq jr js jt b">Handler</code>单子上。这是它看起来的样子:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="7591" class="lf jv hu jt b fv lg lh l li lj">fetchUsersHandler :: Int64 -&gt; Handler User<br/>...</span></pre><p id="5983" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Servant还可以查看我们的创建端点的类型:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="b039" class="lf jv hu jt b fv lg lh l li lj">“users” :&gt; ReqBody ‘[JSON] User :&gt; Post ‘[JSON] Int64</span></pre><p id="4989" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jq jr js jt b">ReqBody</code>参数的参数只是类型参数。因此它会将端点解析为处理程序类型:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="f68a" class="lf jv hu jt b fv lg lh l li lj">createUserHandler :: User -&gt; Handler Int64<br/>...</span></pre><p id="b779" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们需要能够通过这两个处理程序访问我们的Postgres数据库。所以他们每个人都会得到一个额外的参数来引用<code class="eh jq jr js jt b">ConnectionString</code>。我们将从代码中传递该参数，以便Servant解析类型时，该参数已被计算在内:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="2072" class="lf jv hu jt b fv lg lh l li lj">fetchUsersHandler :: ConnectionString -&gt; Int64 -&gt; Handler User<br/>createUserHandler :: ConnectionString -&gt; User -&gt; Handler Int64</span></pre><p id="7106" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们继续之前，我们应该讨论一下<code class="eh jq jr js jt b">Handler</code>单子。这是单子<code class="eh jq jr js jt b">ExceptT ServantErr IO</code>的包装。换句话说，这些请求中的每一个都可能失败。为了使它失败，我们可以抛出类型为<code class="eh jq jr js jt b">ServantErr</code>的错误。那么当然我们也可以调用<code class="eh jq jr js jt b">IO</code>函数，因为这些都是网络操作。</p><p id="4fac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们实现这些函数之前，让我们先写几个简单的助手。这些将使用上周文章中的<code class="eh jq jr js jt b">runAction</code>函数来运行数据库操作:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="5498" class="lf jv hu jt b fv lg lh l li lj">fetchUserPG :: ConnectionString -&gt; Int64 -&gt; IO (Maybe User)<br/>fetchUserPG connString uid = runAction connString (get (toSqlKey uid))</span><span id="a2ad" class="lf jv hu jt b fv lk lh l li lj">createUserPG :: ConnectionString -&gt; User -&gt; IO Int64<br/>createUserPG connString user = fromSqlKey &lt;$&gt; runAction connString (insert user)</span></pre><p id="ae29" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了完整性(并在稍后的测试中使用)，我们还将添加一个简单的<code class="eh jq jr js jt b">delete</code>函数。我们需要<code class="eh jq jr js jt b">where</code>子句进行类型推断:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="968c" class="lf jv hu jt b fv lg lh l li lj">deleteUserPG :: ConnectionString -&gt; Int64 -&gt; IO ()<br/>deleteUserPG connString uid = runAction connString (delete userKey)<br/>  where<br/>    userKey :: Key User<br/>    userKey = toSqlKey uid</span></pre><p id="3ea2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在从我们的服务处理程序中，我们将调用这两个函数。这将完全涵盖创建端点的情况。但是我们需要更多的逻辑来获取端点。因为我们的函数在<code class="eh jq jr js jt b">IO</code>单子上，我们必须把它们提升到<code class="eh jq jr js jt b">Handler</code>。</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="1f69" class="lf jv hu jt b fv lg lh l li lj">fetchUsersHandler :: ConnectionString -&gt; Int64 -&gt; Handler User<br/>fetchUserHandler connString uid = do<br/>  maybeUser &lt;- liftIO $ fetchUserPG connString uid<br/>  ...</span><span id="e13e" class="lf jv hu jt b fv lk lh l li lj">createUserHandler :: ConnectionString -&gt; User -&gt; Handler Int64<br/>createuserHandler connString user = liftIO $ createUserPG connString user</span></pre><p id="e66c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了完成我们的获取处理程序，我们需要考虑一个不存在的用户。在这种情况下，我们将抛出一个<code class="eh jq jr js jt b">ServantErr</code>，而不是将整个端点的类型设为<code class="eh jq jr js jt b">Maybe</code>。我们可以使用一个内置的Servant error函数，它对应于正常的错误代码。然后我们可以更新身体。在这种情况下，我们将抛出一个401错误。我们是这样做的:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="48d8" class="lf jv hu jt b fv lg lh l li lj">fetchUsersHandler :: ConnectionString -&gt; Int64 -&gt; Handler User<br/>fetchUserHandler connString uid = do<br/>  maybeUser &lt;- lift $ fetchUserPG connString uid<br/>  case maybeUser of<br/>    Just user -&gt; return user<br/>    Nothing -&gt; Handler $ (throwE $ err401 { errBody = “Could not find user with ID: “ ++ (show uid)})</span><span id="d90d" class="lf jv hu jt b fv lk lh l li lj">createUserHandler :: ConnectionString -&gt; User -&gt; Handler Int64<br/>createuserHandler connString user = lift $ createUserPG connString user</span></pre><p id="ff43" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就是这样！我们已经完成了处理函数！</p><h1 id="7237" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">将所有这些整合到一个服务器中</h1><p id="c6ee" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">我们的下一步是在API上创建一个类型为<code class="eh jq jr js jt b">Server</code>的对象。这实际上非常简单。当我们定义原始类型时，我们用<code class="eh jq jr js jt b">(:&lt;|&gt;)</code>操作符组合了端点。为了制作我们的<code class="eh jq jr js jt b">Server</code>，我们做了同样的事情，但是使用了处理函数:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="dc78" class="lf jv hu jt b fv lg lh l li lj">usersServer :: ConnectionString -&gt; Server UsersAPI<br/>usersServer pgInfo = <br/>  (fetchUsersHandler pgInfo) :&lt;|&gt; <br/>  (createUserHandler pgInfo)</span></pre><p id="779b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Servant负责确保每个端点的类型与处理程序的类型相匹配。挺牛逼的。假设我们改变了我们的<code class="eh jq jr js jt b">fetchUsersHandler</code>的类型，这样它用了一个<code class="eh jq jr js jt b">Key User</code>而不是一个<code class="eh jq jr js jt b">Int64</code>。我们会得到一个编译错误:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="f796" class="lf jv hu jt b fv lg lh l li lj">fetchUsersHandler :: ConnectionString -&gt; Int64 -&gt; Handler User<br/>…</span><span id="9312" class="lf jv hu jt b fv lk lh l li lj">-- Compile Error!<br/>• Couldn't match type ‘Key User’ with ‘Int’<br/>      Expected type: Server UsersAPI<br/>        Actual type: (Key User -&gt; Handler User)<br/>                     :&lt;|&gt; (User -&gt; Handler Int64)</span></pre><p id="824f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们的API定义和处理程序定义之间存在不匹配。所以仆人知道抛出一个错误！一个问题是错误消息有时很难解释。尤其是当你的API变得非常大的时候！上面错误的“实际类型”部分会变得海量！因此，在更改您的端点时一定要小心！<a class="ae jp" href="https://mmhaskell.com/blog/2017/4/3/compile-driven-learning" rel="noopener ugc nofollow" target="_blank">勤编</a>是你的朋友！</p><h1 id="6594" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">构建应用程序</h1><p id="bb21" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">拼图的最后一块是在我们的服务器上实际构建一个<code class="eh jq jr js jt b">Application</code>对象。这个过程的第一步是为我们的API创建一个<code class="eh jq jr js jt b">Proxy</code>。请记住，我们的API是一种类型，而不是一个术语。但是一个<code class="eh jq jr js jt b">Proxy</code>允许我们在术语层次上表示这种类型。概念有点复杂，但代码并不复杂！</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="378a" class="lf jv hu jt b fv lg lh l li lj">import Data.Proxy</span><span id="3084" class="lf jv hu jt b fv lk lh l li lj">…</span><span id="b385" class="lf jv hu jt b fv lk lh l li lj">usersAPI :: Proxy UsersAPI<br/>usersAPI = Proxy :: Proxy UsersAPI</span></pre><p id="c952" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们可以这样创建我们的runnable <code class="eh jq jr js jt b">Application</code>(假设我们有一个Postgres连接):</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="faba" class="lf jv hu jt b fv lg lh l li lj">serve usersAPI (usersServer connString)</span></pre><p id="4c53" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将通过使用<code class="eh jq jr js jt b">run</code>函数从端口8000运行这个服务器，也是从<code class="eh jq jr js jt b">Network.Wai</code>运行。(完整的进口清单见<a class="ae jp" href="https://github.com/jhb563/ProdHaskellSeries/blob/servant/src/API.hs" rel="noopener ugc nofollow" target="_blank"> Github </a>)。我们将获取我们的连接字符串，然后我们就可以开始了！</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="a1e8" class="lf jv hu jt b fv lg lh l li lj">runServer :: IO ()<br/>runServer = do<br/>  pgInfo &lt;- fetchPostgresConnection<br/>  run 8000 (serve usersAPI (usersServer pgInfo))</span></pre><h1 id="c472" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">结论</h1><p id="a6bc" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">仆人库提供了一些真正令人敬畏的可能性。我们能够在类型级别定义web API。然后，我们可以使用端点期望的参数来定义处理函数。Servant处理所有在HTTP请求和本地Haskell类型之间来回编组的工作。它还确保了端点和处理函数类型之间的匹配！</p><p id="8c60" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你想看到Servant提供的更多可能性，你应该看看我在Bayhac的演讲。它经历了一些更高级的概念，如认证和客户端功能。你可以在这里获得那个演讲<a class="ae jp" href="https://www.mmhaskell.com/bayhac" rel="noopener ugc nofollow" target="_blank">的幻灯片和所有代码示例。</a></p><p id="324e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您以前从未尝试过Haskell，那么现在是开始的最佳时机！下载我们的<a class="ae jp" href="https://www.mmhaskell.com/checklist" rel="noopener ugc nofollow" target="_blank">入门清单</a>，获取一些工具来帮助您开始Haskell之旅！</p></div></div>    
</body>
</html>