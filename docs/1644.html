<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://medium.com/hackernoon/timestamp-extraction-from-abstract-and-definite-time-specifications-in-online-promotions-text-2a6ee591bb9?source=collection_archive---------4-----------------------#2016-11-24">https://medium.com/hackernoon/timestamp-extraction-from-abstract-and-definite-time-specifications-in-online-promotions-text-2a6ee591bb9?source=collection_archive---------4-----------------------#2016-11-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><h2 id="260d" class="hs ht hu bd hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq dt translated">在线促销文本中抽象和明确时间规范的时间戳提取</h2><p id="ac48" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb ie jc jd je ii jf jg jh im ji jj jk jl hn dt translated"><em class="jm">“一个</em> <strong class="it jn"> <em class="jm">时间戳</em> </strong> <em class="jm">是识别某一事件何时发生的一系列字符或编码信息，通常给出日期和时间，有时精确到几分之一秒。”</em>(来源维基百科——2016年11月23日)</p><p id="cbde" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated">抽象的时间说明以及明确的时间框架参考通常用于在线促销的文本中，尤其是在提及与报价有效性相关的细节时。即使在我们人与人之间的日常对话中，时间也不总是用精确的术语来描述。自然语言在书面和口头对话中充满了抽象的时间规范。例如，我们经常使用“时间不多了”、“几个小时”这样的短语。然而，在这里量化紧急程度并根据时间表示的通俗用法确定时间戳并不简单。</p><p id="b0a1" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated">当任务是根据促销的有效性对不同的促销进行排序时，自然语言处理技术可以非常方便地根据促销的有效持续时间来计算优惠券(促销)何时可以使用。以下是从不同来源收集的促销数据中摘录的一些例句。</p><p id="3d94" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated">"<em class="jm">优惠将在7天后到期。适用除外条款。结账时享受折扣。详见免责声明"</em></p><p id="3fc3" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated"><em class="jm">“优先客户私人销售—2月11日星期四下午2点—今天结账时兑换使用代码。”</em></p><p id="8f3a" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated"><em class="jm">“由HauteLook支持的限时销售活动”</em></p><p id="b14a" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated">给定一个参考日期(发送促销活动的时间)，前两句话准确地指定了促销活动有效的日期和时间，最后一句话虽然没有给出这样一个具体的时间框架，但它清楚地表明了销售活动在很短的时间内有效。在促销数据中发现这样的句子并不罕见，其中没有明确指定确切的结束时间(优惠券到期)或开始时间(优惠券生效的时间)。</p><p id="575f" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated"><strong class="it jn">单词序列建模— </strong>如果使用简单的基于规则的方法来寻找特定的单词序列以确定持续时间，那么考虑到确定时间戳(月、年、日、小时和分钟等)的标记的可能组合的数量，这种方法会很快变得难以管理。如果我们必须确定促销的开始和结束时间，组合只会增加。目标是最小化硬编码规则的数量，并利用在指定时间的句子中使用的可能模式或公共底层结构，以及底层结构上的工艺规则。</p><p id="0180" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated">考虑一个句子<em class="jm">“有效期从10月10日到11月15日”，</em>句子里有两个时间戳，一个是10月10日，一个是11月15日。促销在提到的日期之间有效，开始和结束日期可以通过查看句子中实际日期之前的词序来确定。“有效期自”表示10月10日为开始日期，“至”表示11月15日为结束日期。这个例子说明了使用上下文[周围的词]来确定促销活动有效期的重要性。</p><p id="555a" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated"><strong class="it jn">时间点vs持续时间— </strong>上面提到的三个句子也突出了一般文本中时间描写的另一个方面。像<em class="jm">“7周内”和“限时”</em>这样的短语表示相对于参考日期的持续时间，像<em class="jm">“11月15日”</em>这样的短语表示优惠券有效期开始或结束的确切时间点。基于这个观察，我们可以提出一个语法(或一组标签)来解释给定句子中的时间描述结构。</p><p id="fc24" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated"><strong class="it jn">语法(描述句子中表示时间的词的标签)——</strong>标签方案遵循以下设计:</p><p id="d00f" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated">任何以字母“B”开头的标签对应于促销有效的开始时间，而“E”对应于结束时间。如果标签中的最后一个字母是“S ”,则表示它是一个字符串，而“N”则表示该单词是“整数”或“数字”。标签中的“TP”表示“时间点”或“时间点”，“TD”表示“持续时间”。其他字符“D”、“H”、“M”、“Y”、“M”分别赋给“日”、“时”、“月”、“年”和“分”。标签中的“AP”表示AM/PM。“Z”表示时区，持续时间标签中的单个P和s (TDPS、TDSS)分别用于表示“前缀”和“后缀”。持续时间通常在句子中被指定为(前缀、后缀)元组，例如“7周”、“2天”、“9小时”等。</p><p id="59f0" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated">因此，标签的完整列表是——TDPS、TDPN、TDSS、(英国)TPDN、(英国)TPDS、(英国)TPMS、(英国)TPMN、(英国)TPHS、(英国)TPHN、(英国)TPYN、(英国)TPZ、(英国)TPAP</p><p id="582c" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated">对应于以字母“N”结尾的标签的所有单词都是数字。一些时区字符串是“et”、“pt”、“pdt”等。持续时间后缀始终是字符串(如“小时”、“周”、“天”等)，持续时间前缀可以是字符串和数字(如2、“两个”、“有限”、“几个”等)。小时字符串包括像“午夜”、“中午”等词，而日字符串是“星期日”、“星期六”、“明天”等。月份字符串是以不同格式提及月份名称的字符串，例如“一月”、“一月”、“四月”等。像“父亲节”、“阵亡将士纪念日”等特殊的日子被标记为(TDPS，TDSS)持续时间前缀后缀元组。以下是前面提到的三个句子的标注版本。在某些情况下，开始和结束时间没有分开提及(第二句)，我将它们标记为“end)标签，因为报价的有效期在当天或该时间点结束。</p><p id="e985" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated">"<em class="jm">优惠将在7_TDPN天后到期。_TDSS除外条款适用。结账时享受折扣。详见免责声明"</em></p><p id="23ce" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated"><em class="jm">“优先客户私人销售—周四_ETPDS二月_ et PMS 11 _ et PDN at 2 _ et phn pm _ et pap—在今天结账时兑换使用代码。”</em></p><p id="7049" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated"><em class="jm">《限时_TDPS时间_TDSS特卖活动由HauteLook提供支持》</em></p><p id="91d3" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated">在确定了对结构/语法定义和上下文规范的需求之后，下一步是选择一个模型，该模型可以对句子中的单词序列进行建模，并预测其中每个单词的标签。然后，可以针对标签编写规则，这些标签的数量少于英语词汇<em class="jm">(准确地说是训练数据中的词汇)</em>中的整个单词集。我们可以用来模拟单词序列的最简单的模型是HMM模型。</p><p id="a83b" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated"><strong class="it jn">监督HMM模型— </strong></p><p id="a6dc" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated">一个<strong class="it jn">隐马尔可夫模型</strong> ( <strong class="it jn"> HMM </strong>)是一个马尔可夫模型，在这个模型中，被建模的系统被假设为一个具有未被观察到的(<em class="jm">隐</em>)状态的马尔可夫过程。这里，变量或状态的隐藏序列由来自语法的标签组成，这些标签被认为是未被观察到的<em class="jm">(隐藏)</em>，并且每个状态以一定的发射概率发射一个单词(<em class="jm">观察到的</em>)。根据一定的转移概率分布，给定序列中的每个状态或标签依赖于“n”个先前的标签。此处“n”的选择决定了HMM模型的<strong class="it jn">阶。</strong> <br/> <strong class="it jn">图1 </strong>显示了句子<em class="jm">“2天销售”的HMM状态。</em>我之前提到的标签列表中没有“销售”这样的词，但是在这里我们看到“销售”既是一个观察词，也是一个标签。这又回到了我在“<strong class="it jn">单词序列建模</strong>”一节中描述的<strong class="it jn">上下文窗口</strong>的想法。接下来的两节将进一步解释这个想法，并介绍一种处理未知单词的创新方法。</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff jt"><img src="../Images/b2bc1fafe24e61219d84a6ad4f5b5ab7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vys-IZ1ZUs1QWdOzmr3Llw.png"/></div></div></figure><p id="841d" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated"><strong class="it jn">上下文窗口和伪标签— </strong>为了更好地理解这一概念，让我们来看看带标签的句子<em class="jm">“本次促销活动将在10天内到期_ TDPS _ TDSS优惠有效期仅至11月20日_ etp dn _ etpm，但对于我们的首选客户，优惠有效期至11月底_ etpm”。</em>标记单词周围的短语，如<em class="jm">“过期于”、“有效期至”、“结束于”</em>是一种指示，表明句子中跟随它们的单词可能包含时间相关信息。上下文窗口本质上试图识别这样的短语，并通过使它们自己成为标签来赋予它们重要性。例如，在提到的句子中，如果上下文窗口是2，这意味着在实际标记单词之前或之前2个单词的任何单词也将是标记单词，并且标签将是单词本身。该步骤在学习训练数据的转换和发射概率之前完成。考虑上下文窗口(大小为2)后，完整的带标签的句子如下所示:</p><p id="e0b1" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated"><em class="jm">本_ &lt;娜&gt;促销_ &lt;娜&gt;过期_ &lt;过期_&gt;中_&gt;10 _&lt;TDPS&gt;天_ &lt; TDSS &gt;报价_ &lt;报价&gt;有效_ &lt;仅有效_&gt;仅&lt;直到_ &lt;直到&gt; 20_ &lt; ETPDN _ &lt; NA &gt;有效期_ &lt; NA &gt;到_&lt;NA&gt;END _&lt;END _&lt;OF _&gt;11月_&lt;ETPMS&gt;</em></p><p id="3606" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated">请注意，单词“valid”在一个实例中被标记为“<valid>”，在另一个实例中被标记为“<na>”，因此给定的单词可以根据其使用的上下文有多个标签，在这种情况下，上下文是由窗口的大小定义的。如果你注意到<strong class="it jn">&lt;【那】&gt;</strong>这个标签突然不知从哪里冒出来，下一节将完全用来解释这个神秘的标签及其在解决<strong class="it jn"> <em class="jm">“未知问题”中的重要性。</em> </strong></na></valid></p><p id="d8fa" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated"><strong class="it jn">我所说的一般化是指这样的场景:一个含有未见过的单词的句子被提供给模型，我们必须预测未知序列的标签。这通常是一个难以解决的问题，不同的方法，如使用Maxent模型和根据某些相似性将单词分类等。已经被提出。</strong></p><p id="12de" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated">在这里，我使用了一种新的方法来解决这个问题，预测未知或看不见的单词的标签。灵感来自于这样一个事实，即上下文窗口(如上定义)之外的单词通常不携带关于嵌入在句子中的实际时间戳的太多信息。例如，在前面提到的句子中，像“这”、“促销”、“顾客”这样的词无助于识别优惠券到期时间。我们可以使用这样的词(在上下文窗口之外)，并将其标记为“未知”。我的做法是给它们分配一个标签“<na>”。未知发射概率通过对标签为&lt; NA &gt;的(标签，字)对<strong class="it jn">加1平滑(拉普拉斯平滑)</strong>得到。未知单词上的发射概率，<strong class="it jn">P _ e(&lt;&gt;|&lt;NA&gt;)= 1/(N+C)</strong>，其中N是我们在训练数据中遇到(&lt; NA &gt;，word)组合的总次数，而‘C’是分配给“&lt; NA &gt;标签的唯一单词的数量。因此，看到任何标签的未知单词的概率被替换为(&lt; NA &gt;，&lt; UNK &gt;)标签单词对的发射概率。</na></p><p id="08fd" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated">我使用<a class="ae kf" href="https://en.wikipedia.org/wiki/Viterbi_algorithm" rel="noopener ugc nofollow" target="_blank"> <strong class="it jn">维特比解码</strong> </a> <strong class="it jn"> </strong>到<strong class="it jn">根据观察到的单词序列推断</strong>标签序列，在执行推断任务之前计算出未知单词的发射概率是非常必要的。如果发射概率为零，因为我们从未在训练词汇中看到该单词，则不可能解码该句子，因为状态之间的所有转换路径都将携带“零”值。这意味着，如果句子中包含我们只在测试数据中看到而在训练集中看不到的单词，就不可能对句子进行解码。</p><p id="f0be" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated">使用随机抽样(替换)的80%的数据作为训练数据(大约960个句子)，剩余的20%作为测试数据(大约240个句子)，我计算了测试数据的平均指标(使用3折交叉验证)。下表显示了不同上下文窗口大小的真实标签(来自语法的标签)的平均标签准确度。</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff kg"><img src="../Images/148fc9e79dac847ee8e93b130471a19c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LXQUIGdE7OE6s9E7nG6J5Q.png"/></div></div></figure><p id="dd80" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated">请注意“%解码失败”列，该列告诉我们测试数据中的句子数量，对于这些句子，模型无法根据可用的训练数据推断出标签序列。在以下情况下，对句子的解码会失败:</p><ul class=""><li id="50d4" class="kh ki hu it b iu jo iy jp ie kj ii kk im kl jl km kn ko kp dt translated">如前所述，当单词未知并且训练数据中的发射概率P_e(unknown_word|label) = 0(对于所有标签)时，网格中的所有路径都变为零。我们通过使用P_e( <unk> | <na>)值作为排放概率来处理这种情况。</na></unk></li><li id="59bd" class="kh ki hu it b iu kq iy kr ie ks ii kt im ku jl km kn ko kp dt translated">假设我们有一条权重不为零的路径，直到我们看到word (w_t)的时候。让“w_t”的索引为3，这意味着它是句子中的第三个单词。让我们还假设对于一阶HMM，到目前为止网格中的非零权重路径包括序列((标签1，字1)，(标签2，字2))。如果转移概率P_t(label3|label2)！=0，对于来自label2的所有其他转换为零，即P_t(label_i|label2) = 0(对于所有I！= 3)和P_e(w_t|label3) = 0，则在到达句子中的最后一个单词之前，路径的权重变为零。一般来说，对于一个以上的路径，如果在看到w_t之前在网格中携带非零权重的所有路径只能以非零概率转换到该字的发射概率为零的状态(标签)(即P _ e(w _ t |标签)= 0)，则解码失败，因为所有路径的权重在到达最后一个字之前下降到零。</li></ul><p id="1e7c" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated">上表中的两行有%解码失败的句子= 0(或接近零)。在以下情况下，我们可以做到这一点:</p><ul class=""><li id="2b90" class="kh ki hu it b iu jo iy jp ie kj ii kk im kl jl km kn ko kp dt translated"><strong class="it jn">零上下文窗口— </strong>当上下文窗口大小为零时，标记有来自语法的标签的所有单词将保持原样，并且每隔一个单词将获得标签&lt; NA &gt;。这是因为给定单词的标签不依赖于其相邻单词(或标签)。如果你看这个句子——<em class="jm">“sale _ NA ends _ NA in _ NA 2 _ TDPN days _ TDSS”，</em>只有“2天”被标注，其余的单词都以“NA”作为默认标签。在这种情况下，假设有非常有限的标签集，来自这些标签之一的已知单词的发射概率不可能为零。像以前一样，使用P_e( &lt; UNK &gt; | &lt;纳&gt;)来获得未知单词的发射概率。当上下文窗口为零时，平均标签预测准确度相当低，并且这是预期的，因为这里没有考虑上下文信息。</li><li id="a1a4" class="kh ki hu it b iu kq iy kr ie ks ii kt im ku jl km kn ko kp dt translated"><strong class="it jn">依赖于发射概率为零时的转移概率— </strong>注意表格中标有IgnoreVocab的行。HMM顺序和上下文窗口大小与行3没有不同。这里唯一的区别是，每当遇到一个已知单词，并且对于一个标签，该单词的发射概率(比如‘w _ t’)为零，那么它就被替换为P_e的发射概率(&lt; UNK &gt; | &lt; NA &gt;)。这意味着在到达最后一个字之前，网格中的所有路径都不可能降到零权重。这是有保证的，因为，假设我们只能转换到‘n’(状态)标签，并且每个标签对于单词具有相同的发射概率(这是P_e( &lt; UNK &gt; | &lt;纳&gt;))，那么转换到后续状态完全取决于转换概率。这确保了没有具有零发射概率的(标签，单词)元组。然而，这种方法并不完全可靠，例如，当我们有两个状态时，我们可以转换到- label1和label2以及P_e(w_t|label2) = 0和P_e(w_t|label1)！=0，那么我们就用P_e( &lt; UNK &gt; | &lt;娜&gt;)代替P_e(w_t|label2)。如果P _ e(&lt;UNK&gt;|&lt;NA&gt;)&gt;P _ e(w _ t | label1)，则在推断步骤期间，解码器有可能会选择&lt; NA &gt;而不是label 1作为单词的目标标签。因此，这里的期望是P_e( &lt; UNK &gt; | &lt; NA &gt;)非常小，并且它只在所有路径都导致零权重时有助于打破平局，因为排放概率为零。对于解码240个句子，运行时间也显著增加，从80秒(HMM阶数=1，窗口大小= 2)增加到2300秒，因为在解码或推断步骤期间，由于零发射概率，没有可以消除的路径。</li></ul><p id="242c" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated">另一种极端情况是当上下文窗口为-1时，我们没有<na>标签，每个单词都有一个不同的标签(或者是来自语法的标签，或者是单词本身)，在这种情况下，正确解码的句子的准确度很高。然而，几乎50%的句子没有被解码，这是一个经典的过度拟合的例子。<strong class="it jn">窗口大小为2且阶数为1的</strong>似乎在平均标签准确度和平均结束时间预测方面表现更好。平均开始时间预测精度几乎总是很高，因为翻译器的设计方式是从参考日期开始迭代，并试图从句子中找出最佳开始日期(见下一节—翻译层)。</na></p><p id="2f4e" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated"><strong class="it jn">翻译层</strong></p><p id="70cd" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated">一旦使用前面提到的解码技术获得了标签。下一步是解析这些标签，并计算出实际的时间戳。该翻译步骤主要是规则驱动的，并且针对有限的标签集而不是针对训练词汇表中的整个单词集来编译规则。在为促销数据设计翻译图层之前，需要记住以下几点:</p><ul class=""><li id="f28e" class="kh ki hu it b iu jo iy jp ie kj ii kk im kl jl km kn ko kp dt translated">促销总是向前看的—给定发送促销的参考日期，促销很可能已经过期。这意味着类似于<em class="jm">、【工作日】、【周末】、【星期四】、</em>等的引用被用在当前或未来的参考系中。</li><li id="0bb5" class="kh ki hu it b iu kq iy kr ie ks ii kt im ku jl km kn ko kp dt translated">促销活动可以包含多个嵌入日期，例如在句子<em class="jm">“此促销活动将在10天内到期_ TDPS _ TDSS优惠仅在11月20日有效_ETPMS，但对于我们的优先客户，优惠在11月底有效_ETPMS”，</em>对于优先客户，促销活动在11月30日有效，对于其他客户，促销活动在11月20日有效。在翻译层，我试图提取最大范围，即最早开始时间到最远结束时间。</li><li id="4bf8" class="kh ki hu it b iu kq iy kr ie ks ii kt im ku jl km kn ko kp dt translated">我假设抽象短语有一定的标准翻译，如(“有限”、“时间”)、(“很少”、“几天”)，它们是持续时间元组— (TDPS，TDSS)。例如，标准翻译将(' limited '，' time ')翻译为(' 2 '，' days ')，将(' last '，' chance ')翻译为(' 1 '，' day ')等。</li><li id="f37c" class="kh ki hu it b iu kq iy kr ie ks ii kt im ku jl km kn ko kp dt translated">持续时间元组的另一种形式是特殊的日历日，如—(母亲节)、(纪念日)、(黑色星期五)。对于这些天来说，一个标准的日历服务可以用来计算出准确的日期。</li></ul><p id="1abc" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated">以下两个图<strong class="it jn">(对于HMM顺序— 1，上下文窗口大小— 2)，</strong>显示了预测的和实际的开始和结束时间之间的比较，按实际开始时间和到期时间排序。预测时间和实际时间之间存在不匹配的点可以通过偏离实线的三角形看到。y轴上的时间是unix纪元时间。</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff kv"><img src="../Images/d318308cb7f70122530117615f5c5e87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5YOLl8wWUJm8FRlCekYAiQ.png"/></div></div></figure><p id="8d61" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated">不难看出，当预测的标签不正确时，翻译层就不能很好地估计促销的开始和结束时间。然而，查看给定句子中的不同时间签名，希望即使标签的子集被正确预测，我们也可以获得嵌入其中的时间戳的近似估计。</p><p id="45b2" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated"><strong class="it jn">扩展到一般用例— </strong>我构建的用于估算促销有效时间的框架可以主要分为3个步骤</p><ul class=""><li id="78b3" class="kh ki hu it b iu jo iy jp ie kj ii kk im kl jl km kn ko kp dt translated"><strong class="it jn">解析</strong> —处理句子并将其转换成标准形式，以便可以传递给模型。</li><li id="cbed" class="kh ki hu it b iu kq iy kr ie ks ii kt im ku jl km kn ko kp dt translated"><strong class="it jn">预测标签— </strong>选择一个合适的上下文窗口来合并上下文信息，并处理未知单词和标签。在这一步中，我们使用序列模型来预测句子中的标签。</li><li id="4220" class="kh ki hu it b iu kq iy kr ie ks ii kt im ku jl km kn ko kp dt translated"><strong class="it jn"> Translate — </strong>这一步包括在预测的标签上应用规则，以便我们可以估计促销的开始和结束时间，从而确定其有效性。</li></ul><p id="a6c9" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated">这些步骤通常可以应用于不一定来自促销数据的句子。例如，当我们查看聊天机器人的对话时，当用户要求在某个时间做某事时，尽可能准确地计算出时间戳是至关重要的。</p><p id="e103" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated">考虑以下4个句子，其中第一列显示参考时间或说出句子的时间点。元组输出显示开始时间和结束时间。当我们查看预测的结束时间时，很明显，根据促销数据训练的模型可以用于预测促销领域之外的句子的时间戳。在第2行，开始时间在结束时间之后，但是结束时间指示事件发生的准确时间。这也是一个句子的例子，我们不一定有一个事件的准确开始时间。</p><ul class=""><li id="2d16" class="kh ki hu it b iu jo iy jp ie kj ii kk im kl jl km kn ko kp dt translated"><em class="jm"> 11/17/16 14:00，2小时后开始上课— (11/17/2016 14:0:0，</em><strong class="it jn"><em class="jm">11/17/2016 16:0:</em></strong><em class="jm">)</em></li><li id="e4fd" class="kh ki hu it b iu kq iy kr ie ks ii kt im ku jl km kn ko kp dt translated"><em class="jm"> 11/17/16 14:00，期中考试于11月16日下午5点举行— (11/17/2016 14:0，</em><strong class="it jn"><em class="jm">11/16/2016 17:0</em></strong><em class="jm">)</em></li><li id="d9c1" class="kh ki hu it b iu kq iy kr ie ks ii kt im ku jl km kn ko kp dt translated"><em class="jm"> 11/17/16 14:00，投稿截止时间为明天— (11/17/2016 14:0:0，</em><strong class="it jn"><em class="jm">11/18/2016 23:59:59</em></strong><em class="jm">)</em></li><li id="7910" class="kh ki hu it b iu kq iy kr ie ks ii kt im ku jl km kn ko kp dt translated"><em class="jm"> 11/17/16 14:00，周末可能下雨— (11/17/16 14:00，</em><strong class="it jn"><em class="jm">11/20/2016 23:59:59</em></strong><em class="jm">)</em></li></ul><p id="fac8" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated">如前所述，转换器的实现也对结束时间和开始时间预测的准确性有影响。所采用的方法或为解析预测标签而设计的规则可以确定如何计算开始和结束时间。</p><p id="3099" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated"><strong class="it jn">代码</strong></p><p id="0706" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated">我在这里提供了解析器、HMM模型和翻译器的初步实现:<a class="ae kf" href="https://github.com/bpraveenk/github-abstractTimeParser" rel="noopener ugc nofollow" target="_blank">抽象时间解析器</a></p><ul class=""><li id="787d" class="kh ki hu it b iu jo iy jp ie kj ii kk im kl jl km kn ko kp dt translated"><a class="ae kf" href="https://github.com/bpraveenk/github-abstractTimeParser/blob/master/Main.py" rel="noopener ugc nofollow" target="_blank"> <strong class="it jn"> Main.py </strong> </a> <strong class="it jn"> </strong>包含调用解析器的代码，解析器在内部调用模型来预测句子中单词的标签。在主函数中也调用了转换器类“BeginEndTime”。</li><li id="411e" class="kh ki hu it b iu kq iy kr ie ks ii kt im ku jl km kn ko kp dt translated">培训数据-<a class="ae kf" href="https://github.com/bpraveenk/github-abstractTimeParser/blob/master/data/labeledSentences.csv" rel="noopener ugc nofollow" target="_blank">标注句子。csv </a>可在数据文件夹下找到。参考时间、开始时间、结束时间、带标签的句子列是不言自明的。忽略评论栏和ETU栏。前者表示一些特殊情况，ETU表示结束时间未知。每当结束时间未知时，我就在那些地方插入一些有根据的猜测。</li><li id="ed54" class="kh ki hu it b iu kq iy kr ie ks ii kt im ku jl km kn ko kp dt translated"><a class="ae kf" href="https://github.com/bpraveenk/github-abstractTimeParser/blob/master/data/generalSentences.csv" rel="noopener ugc nofollow" target="_blank">一般句子</a>文件包含非常小的一组不在促销上下文中的例句。</li><li id="fc0f" class="kh ki hu it b iu kq iy kr ie ks ii kt im ku jl km kn ko kp dt translated"><a class="ae kf" href="https://github.com/bpraveenk/github-abstractTimeParser/blob/master/data/unlabeledSentences.csv" rel="noopener ugc nofollow" target="_blank">未标记的句子</a>在这里是可用的——作为一个例子来说明代码正确解析文件所需的格式</li><li id="efa0" class="kh ki hu it b iu kq iy kr ie ks ii kt im ku jl km kn ko kp dt translated"><a class="ae kf" href="https://github.com/bpraveenk/github-abstractTimeParser/tree/master/results" rel="noopener ugc nofollow" target="_blank">结果文件夹</a>包含样本输出/结果文件，每个输出文件的描述包含在<a class="ae kf" href="https://github.com/bpraveenk/github-abstractTimeParser/blob/master/Main.py" rel="noopener ugc nofollow" target="_blank"> Main.py </a>代码文档中。</li></ul><p id="6d2d" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated"><strong class="it jn">我在代码中做的一些假设和改进的范围</strong></p><ul class=""><li id="33c3" class="kh ki hu it b iu jo iy jp ie kj ii kk im kl jl km kn ko kp dt translated">由于我掌握的促销数据来自2015年和2016年期间发送的在线促销，我检查了一下，看看预测的年份是否在这个范围内。</li><li id="7615" class="kh ki hu it b iu kq iy kr ie ks ii kt im ku jl km kn ko kp dt translated">鉴于培训数据的性质，培训数据采用的格式为MM/DD/YY，但根据促销活动发送到的地区，情况可能并不总是如此。我假设这里也是统一时区。</li><li id="2e6b" class="kh ki hu it b iu kq iy kr ie ks ii kt im ku jl km kn ko kp dt translated">当谈到抽象短语的持续时间时，我做了一个假设，比如“有限的”、“时间”等等。这些在<a class="ae kf" href="https://github.com/bpraveenk/github-abstractTimeParser/blob/master/translator.py" rel="noopener ugc nofollow" target="_blank">转换器</a>实现中指定的<em class="jm">timeDurationOffsetAliases</em>映射中可用。不是将其设置为一个数字，而是可以用单个短语的持续时间分布来代替，这可以通过分析来自使用这些短语的不同供应商的促销的有效性来获得。</li><li id="ba77" class="kh ki hu it b iu kq iy kr ie ks ii kt im ku jl km kn ko kp dt translated">类似地，对于重要的日历日期，如假期、节日等，也有专门的地图。目前，这是翻译文件中2016年日期的硬编码。这可以很容易地被返回不同年份的有效日期的通用假日/特殊日历服务所取代。</li><li id="482a" class="kh ki hu it b iu kq iy kr ie ks ii kt im ku jl km kn ko kp dt translated">翻译器代码以这样的方式编写，即开始时间首先被设置为参考时间，并且基于每个预测的标签，它试图通过对每个单词分别应用定义的规则来计算月、年、小时、日的值。这可能会导致创建一个值组合错误的日期。例如，如果在句子“2月2日和3月30日”中提到了两个日期，根据标签预测，如果30日被标记为促销开始的日期，2月是相应的月份，2被标记为促销结束日期。那么翻译器将输出2月30日作为开始日期，这不是一个有效的日期。代码中有验证检查，以确保返回的日期是有效的，但是代码肯定可以改进，以确保返回多个开始日期和结束时间，并从中选择最佳日期，这更像是一种并行方法，而不是级联方法。</li><li id="3551" class="kh ki hu it b iu kq iy kr ie ks ii kt im ku jl km kn ko kp dt translated">如前所述，促销是“前瞻性的”，如果想要为过去的抽象时间上下文实现解析器/标注器/翻译器，例如上周的<em class="jm">，2周前的</em>等等，那么这个代码就不适用于那个用例。我相信这应该不难实现，通过语法中的一些附加标签和翻译逻辑的改变，使用当前的设置就可以实现。</li><li id="775c" class="kh ki hu it b iu kq iy kr ie ks ii kt im ku jl km kn ko kp dt translated">在维特比解码步骤中，当有两个先前状态是从其到达当前状态的最佳状态时，<a class="ae kf" href="https://github.com/bpraveenk/github-abstractTimeParser/blob/master/HMModel.py" rel="noopener ugc nofollow" target="_blank"> HMModel.py </a>中的代码只是随机选择两个中的一个。这肯定可以被改变以在每一步保持多个先前的最佳状态。</li><li id="6eed" class="kh ki hu it b iu kq iy kr ie ks ii kt im ku jl km kn ko kp dt translated">当然，为函数选择正确的名称和格式不是我的核心优势，所以如果函数名、类名的命名很奇怪，请原谅。</li></ul><p id="7f18" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated"><strong class="it jn">进一步的改进— </strong>我将在这篇博客的结尾讨论对这里讨论的方法可能的改进，以构建我称之为“抽象时间解析器”的方法</p><ul class=""><li id="7e8a" class="kh ki hu it b iu jo iy jp ie kj ii kk im kl jl km kn ko kp dt translated">重复——在预测标签中有一个神秘的标签“TPRD ”(如果你足够仔细地观察训练数据)。目的是捕捉重复的事件——比如每天/每周/每小时等。标记部分确实做了一些努力来识别这样的序列，但是我还没有实现代码来翻译它(将留待将来某一天)。</li><li id="5290" class="kh ki hu it b iu kq iy kr ie ks ii kt im ku jl km kn ko kp dt translated">因为我们正在讨论与序列相关的模型，所以可以考虑的其他相当高级的模型是— <a class="ae kf" href="http://homepages.inf.ed.ac.uk/csutton/publications/crftut-fnt.pdf" rel="noopener ugc nofollow" target="_blank"> CRFs </a>(条件随机场)和<a class="ae kf" href="https://en.wikipedia.org/wiki/Recurrent_neural_network" rel="noopener ugc nofollow" target="_blank"> RNNs </a>(递归神经网络)，它们考虑整个句子，而不是只查看前面的单词来确定句子中的单个单词的标签。</li><li id="0c2e" class="kh ki hu it b iu kq iy kr ie ks ii kt im ku jl km kn ko kp dt translated">一般来说，这个模型对于简单的句子做得不错，但是请记住，我在这里讨论的方法只关心一个开始时间和一个结束时间值。如果嵌入了多个日期或时间戳，并且想要从一个句子中提取，您应该查看上面的<strong class="it jn">代码</strong>部分，在那里我已经讨论了如何实现这样的改进。</li></ul><p id="81e1" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated"><strong class="it jn"> <em class="jm">鸣谢</em> </strong></p><p id="f8ca" class="pw-post-body-paragraph ir is hu it b iu jo iw ix iy jp ja jb ie jq jd je ii jr jg jh im js jj jk jl hn dt translated"><em class="jm">特别感谢</em><strong class="it jn"><em class="jm">kyung hyun Cho</em></strong><em class="jm">教授审阅帖子，并对我正在进行的整个项目提供宝贵的反馈和指导，该项目将应用自然语言处理、</em> <a class="ae kf" href="https://hackernoon.com/tagged/machine-learning" rel="noopener ugc nofollow" target="_blank"> <em class="jm">机器学习</em> </a> <em class="jm">和</em> <a class="ae kf" href="https://hackernoon.com/tagged/deep-learning" rel="noopener ugc nofollow" target="_blank"> <em class="jm">深度学习</em> </a> <em class="jm">技术来分析在线营销数据，并向最终用户提供按需、智能和相关的促销活动，同时</em></p><div class="ju jv jw jx fq ab cb"><figure class="kw jy kx ky kz la lb paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="kw jy kx ky kz la lb paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="kw jy kx ky kz la lb paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="lc ld le"><p id="f922" class="ir is jm it b iu jo iw ix iy jp ja jb lf jq jd je lg jr jg jh lh js jj jk jl hn dt translated"><a class="ae kf" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kf" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kf" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae kf" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is jm it b iu jo iw ix iy jp ja jb lf jq jd je lg jr jg jh lh js jj jk jl hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kf" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kf" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff li"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="lj lk l"/></div></figure></div></div>    
</body>
</html>