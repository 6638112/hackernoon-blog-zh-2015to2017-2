<html>
<head>
<title>Rendering Performance in Android - Overdraw</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android中的渲染性能- Overdraw</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/rendering-performance-in-android-overdraw-3968ae63dfbd?source=collection_archive---------0-----------------------#2016-09-14">https://medium.com/hackernoon/rendering-performance-in-android-overdraw-3968ae63dfbd?source=collection_archive---------0-----------------------#2016-09-14</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="9d2c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">渲染性能是构建<a class="ae jp" href="https://hackernoon.com/tagged/android" rel="noopener ugc nofollow" target="_blank"> Android </a>应用时经常被忽视的最常见的性能问题之一。鉴于大多数Android手机运行在功能较弱的CPU和GPU上，我们开发人员应该确保我们开发的应用程序不会使用不需要的和/或重复的指令使两个处理器过载。</p><p id="6f2b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">两个处理器一起工作来渲染图像、颜色、可画性等。不必要的布局和频繁和/或不必要的失效(视图被测量、拆除并重新构建或重新绘制，例如:当用户滚动时，列表视图被重新构建/重新绘制太多次)导致CPU上的性能开销。然而，在GPU上，一个主要且常见的性能开销来自于<em class="jq">的透支</em></p></div><div class="ab cl jr js hc jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hn ho hp hq hr"><p id="2736" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> Overdraw </strong>顾名思义，是一个用来描述屏幕上的一个像素在单帧中被重画了多少次的术语。想象一下，粉刷一个房间，重新粉刷一遍；这导致第一次粉刷房间时浪费时间和精力。在Android的overdraw中，我们浪费了GPU的时间来给屏幕上的像素着色，而这些像素最终会被其他东西再次着色。</p></div><div class="ab cl jr js hc jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hn ho hp hq hr"><h1 id="f2ff" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">检测和修复透支</h1><p id="d994" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">幸运的是，我们可以通过选择手机设置中<em class="jq">“开发者选项”</em>下<em class="jq">“调试GPU透支”</em>中的<em class="jq">“显示透支区域”</em>来检测安卓手机中的透支。</p><p id="17b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">调试GPU overdraw <a class="ae jp" href="https://hackernoon.com/tagged/tool" rel="noopener ugc nofollow" target="_blank">工具</a>用红、绿、蓝给屏幕上色；红色是屏幕上过度绘制程度最高的区域，蓝色是屏幕上过度绘制程度最低的区域。</p><p id="e958" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在附上的截图中，我有两个垂直方向的LinearLayout。第一个LinearLayout在EditText和ImageView等小部件上以及在布局上有不需要的背景。图像中的所有红色区域表明视图是在另一个视图的顶部重新绘制的，因此导致了过度绘制。</p><figure class="lc ld le lf fq lg fe ff paragraph-image"><div class="fe ff lb"><img src="../Images/e4eba3d2b02c4573b19f9c2563bb3f03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*-iZ6ifqJY3EIxdn7_GODoQ.png"/></div><figcaption class="lj lk fg fe ff ll lm bd b be z ek">An example of Views being overdrawn</figcaption></figure><p id="aed9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们看看第一个LinearLayout，并找出问题所在。</p><pre class="lc ld le lf fq ln lo lp lq aw lr dt"><span id="4f20" class="ls jz hu lo b fv lt lu l lv lw">&lt;LinearLayout<br/>    xmlns:android="http://schemas.android.com/apk/res/android"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"<br/>    <strong class="lo hv">android:background="@color/white"</strong>&gt;<br/><br/>    &lt;LinearLayout<br/>        android:id="@+id/unwanted_background_layout"<br/>        android:layout_width="match_parent"<br/>        android:layout_height="wrap_content"<br/><strong class="lo hv">        android:background="@color/white"</strong><br/>        android:orientation="vertical"<br/>        android:padding="@dimen/button_margin"&gt;<br/><br/>        &lt;TextView<br/>            android:layout_width="match_parent"<br/>            android:layout_height="wrap_content"<br/><strong class="lo hv">            android:background="@color/grey"</strong><br/>            android:padding="8dp"<br/>            android:text="@string/layout_with_unwanted_backgrounds"<br/>            android:textSize="17sp" /&gt;<br/><br/>        &lt;ImageView<br/>            android:id="@+id/image_view"<br/>            android:layout_width="100dp"<br/>            android:layout_height="100dp"<br/>            android:layout_gravity="center"<br/>            android:layout_marginTop="8dp"<br/>            android:src="@mipmap/ic_launcher_round" /&gt;<br/><br/>        &lt;EditText<br/>            android:layout_width="match_parent"<br/>            android:layout_height="wrap_content"<br/>            android:layout_gravity="center"<br/>            android:layout_marginTop="8dp"<br/>            android:inputType="text"<br/>            android:padding="16dp" /&gt;<br/><br/>    &lt;/LinearLayout&gt;</span><span id="9bcf" class="ls jz hu lo b fv lx lu l lv lw">    &lt;LinearLayout<br/>        ....<br/>        android:id="@+id/fixed_background_layout"<br/>        ....&gt;<br/>        ....<br/>    &lt;/LinearLayout&gt;</span><span id="a67d" class="ls jz hu lo b fv lx lu l lv lw">&lt;/LinearLayout&gt;</span></pre><p id="1899" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">粗体的XML代码显示了明显的错误。</p><p id="527d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们已经为第一个LinearLayout视图组中的每个孩子声明了背景色。我们还在父视图组中设置了背景颜色。请注意，为视图设置背景颜色会增加过度绘制，并且不取决于使用哪种颜色。同样的颜色和不同的颜色也会发生过度绘制。</p><p id="82ea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先在屏幕上画出最上面的LinearLayout。背景设置为白色。接下来绘制子LinearLayout，它的背景色也是白色。此时的系统不知道颜色和以前一样。它所知道的就是有了新的颜色，像素又用新的颜色重画了一遍。子TextView和ImageView都设置了背景，这使得系统可以用新的颜色重新绘制像素。绘制和重绘相同的像素会浪费GPU周期。对于渲染性能来说，使用先前存在的相同数据在相同像素上重新绘制将被证明是代价高昂的。</p><p id="c57f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">我们如何减少透支，提高业绩？</strong></p><p id="c263" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们知道相同的颜色在子视图中绘制了多次。让我们先去掉它，因为它不是一个设计约束。</p><pre class="lc ld le lf fq ln lo lp lq aw lr dt"><span id="b0da" class="ls jz hu lo b fv lt lu l lv lw">&lt;LinearLayout<br/> android:id=”@+id/fixed_background_layout”<br/> android:layout_width=”match_parent”<br/> android:layout_height=”wrap_content”<br/> android:orientation=”vertical”<br/> android:padding=”@dimen/button_margin”&gt;</span></pre><p id="318c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">去掉子线条布局上的白色背景会显示出更少的过度绘制-</p><figure class="lc ld le lf fq lg fe ff paragraph-image"><div class="fe ff ly"><img src="../Images/6f2a8b3b6ebb5ffef04e75f232d6ad31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*KqUHqhd8HhCqh-XqEhktOg.png"/></div><figcaption class="lj lk fg fe ff ll lm bd b be z ek">Reduced overdraw shown by less red marks</figcaption></figure><p id="16c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果设计允许，你甚至可以去掉文本视图的背景来提高性能。</p><p id="86d7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">红色标记是看不见的，表明透支很少或没有透支。GPU渲染该视图的速度更快，消耗的时间更少，有助于整体用户体验更加流畅和快速。</p><p id="0823" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了进一步提高性能，尽可能使用平面布局。嵌套视图的几个实例可能非常昂贵，因为子视图应该测量两次。由于这超出了本文的范围，你可以在Android开发者官方网站上研究<a class="ae jp" href="https://developer.android.com/training/improving-layouts/optimizing-layout.html" rel="noopener ugc nofollow" target="_blank">优化布局层次</a>。</p></div><div class="ab cl jr js hc jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hn ho hp hq hr"><p id="14e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在GitHub上克隆透支回购查看完整代码——【https://github.com/vishnusosale/Android-Overdraw<a class="ae jp" href="https://github.com/vishnusosale/Android-Overdraw" rel="noopener ugc nofollow" target="_blank"/></p><p id="e50e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你觉得这篇文章对你或者你的安卓开发者朋友超级有帮助，请分享。你的掌声有助于我们被激励，写更多的内容。</p><figure class="lc ld le lf fq lg"><div class="bz el l di"><div class="lz ma l"/></div></figure></div></div>    
</body>
</html>