<html>
<head>
<title>Namespace Dependency Injection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">命名空间依赖注入</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/https-medium-com-cn007b-namespace-dependency-injection-77cc3ee6b93d?source=collection_archive---------15-----------------------#2017-12-13">https://medium.com/hackernoon/https-medium-com-cn007b-namespace-dependency-injection-77cc3ee6b93d?source=collection_archive---------15-----------------------#2017-12-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/a2f640ee94f0ec6798462ee38eecb768.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kf-rGHyeGMUlOU1ZjT2OTw.jpeg"/></div></div></figure><div class=""/><p id="6815" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我确信您已经熟悉了依赖注入(DI)设计模式和依赖注入的类型:构造函数、设置器、接口。同样在一些源代码中，你可以找到参数依赖注入类型。<br/>在本主题中，您将发现另一种类型的DI——名称空间！</p><h2 id="89f0" class="ka kb if bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">先决条件</h2><p id="adad" class="pw-post-body-paragraph jc jd if je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">我希望你已经熟悉DI背后的想法，并且你清楚地了解你为什么需要它。如果不是，请先阅读关于DI的基本信息。</p><p id="48be" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们假设我们的应用程序是乌克兰🇺🇦签证中心，它可以提供，批准或拒绝世界上任何国家的签证，为简单起见，这里只考虑欧盟。首先，我们需要接口，<br/>文件<code class="eh la lb lc ld b">src/Domain/Interfaces/VISA/EuropeanUnion.php</code>:</p><figure class="le lf lg lh fq hw"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="fabe" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们对非免签案件进行执行(姑且称此案为“审查”)，文件<code class="eh la lb lc ld b">src/Infrastructure/VISA/Review/EuropeanUnion.php</code>:</p><figure class="le lf lg lh fq hw"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="f40b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">而另一个实施为免签证的案例，<br/>文件<code class="eh la lb lc ld b">src/Infrastructure/VISA/Free/EuropeanUnion.php</code>:</p><figure class="le lf lg lh fq hw"><div class="bz el l di"><div class="li lj l"/></div></figure><h2 id="2d0c" class="ka kb if bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated"><strong class="ak">目标</strong></h2><p id="350b" class="pw-post-body-paragraph jc jd if je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">主要目的是在某个地方(例如在文件<code class="eh la lb lc ld b">index.php</code> ) <br/>有这样超级简单的代码:</p><figure class="le lf lg lh fq hw"><div class="bz el l di"><div class="li lj l"/></div></figure><h2 id="11e1" class="ka kb if bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">解决办法</h2><p id="a977" class="pw-post-body-paragraph jc jd if je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">使用名称空间依赖注入并配置您的<code class="eh la lb lc ld b">composer.json</code>文件:</p><figure class="le lf lg lh fq hw"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="ecb7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">并且运行:<code class="eh la lb lc ld b">php composer dump-autoload</code>(很重要，请不要忘记运行这个命令)。</p><h2 id="bc07" class="ka kb if bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">试验</h2><p id="44bc" class="pw-post-body-paragraph jc jd if je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">现在只需运行命令:<code class="eh la lb lc ld b">php index.php</code>，您将看到:</p><pre class="le lf lg lh fq lk ld ll lm aw ln dt"><span id="b256" class="ka kb if ld b fv lo lp l lq lr">'You have to provide documents for review.'</span></pre><p id="2b34" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在请用下一个内容更新<code class="eh la lb lc ld b">composer.json</code>:</p><figure class="le lf lg lh fq hw"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="83dc" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">和run: <code class="eh la lb lc ld b">php composer dump-autoload</code>和run: <code class="eh la lb lc ld b">php index.php</code>你会看到:</p><pre class="le lf lg lh fq lk ld ll lm aw ln dt"><span id="942a" class="ka kb if ld b fv lo lp l lq lr">'Your request is approved!'</span></pre><p id="2737" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就是这样！恭喜你。</p><h2 id="1f5d" class="ka kb if bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">与其他方法的比较</h2><p id="f749" class="pw-post-body-paragraph jc jd if je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">备选方案:工厂方法(甚至抽象工厂)、构造器或设置器依赖注入或策略设计模式。是的，这些模式可以被认为是一种替代方案，但是它们都需要您编写技术代码，例如:</p><pre class="le lf lg lh fq lk ld ll lm aw ln dt"><span id="9d92" class="ka kb if ld b fv lo lp l lq lr">class Factory<br/>{<br/>    public static function create($name)<br/>    {<br/>        if (class_exists($name)) {<br/>            return new $name();<br/>        }<br/>    }<br/>}</span></pre><p id="5b46" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">或者</p><pre class="le lf lg lh fq lk ld ll lm aw ln dt"><span id="3e95" class="ka kb if ld b fv lo lp l lq lr">public static function getInstance(string $name)<br/>{<br/>    if (!isset(self::$instances[$name])) {<br/>        $className = "App\\Infrastructure\\" . ucfirst($name);<br/>        if (!class_exists($className)) {<br/>            throw new RuntimeException("Unknown class: $className");<br/>        }<br/>        self::$instances[$name] = new $className();<br/>    }<br/>    return self::$instances[$name];<br/>}</span></pre><p id="4754" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">同样在现实世界的项目中，它看起来会更复杂，也许像这样的。此外，您还将把声明式代码与如下内容混合在一起:</p><pre class="le lf lg lh fq lk ld ll lm aw ln dt"><span id="e315" class="ka kb if ld b fv lo lp l lq lr">$name = ($parameter === 'free') ? 'VISA/Free' : 'VISA/Review';<br/>$visa = Factory::create($name);<br/>// and only now<br/>$visa-&gt;approve();</span></pre><p id="39b9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">同样，在使用这些模式的情况下，你必须将所有代码放在一个地方(一个回购)，但是想象一下<code class="eh la lb lc ld b">VISA/Review</code>和<code class="eh la lb lc ld b">VISA/Free</code>可能是拥有自己的工厂、策略、微服务、内部业务逻辑实现等的巨大子系统——这可能是一场噩梦。</p><p id="bbd0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过名称空间依赖注入，你可以为接口、<code class="eh la lb lc ld b">VISA/Review</code>、<code class="eh la lb lc ld b">VISA/Free</code>等创建专用包(repos)。每个包只需要知道接口，不需要更多。所以它更灵活，更容易维护，扩展和重用！如果你有一个非常大的项目，你甚至可以为每个包建立独立的开发团队。</p><p id="debd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最重要的是——在应用程序层面上，你将拥有超级简单的声明式代码，所有的内部细节都不会让你困惑。您的项目将更加可预测，因为运行时的行为不会根据不同的环境而变化，它将严格按照您的配置工作。另外，IDE(像PHPStorm一样)会给你更多的帮助，因为它不会像<code class="eh la lb lc ld b">new $className();</code>那样对代码大喊大叫。</p><h2 id="8c07" class="ka kb if bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">性能比较</h2><p id="6b9f" class="pw-post-body-paragraph jc jd if je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">名称空间DI比所有其他类型的依赖注入都要快！！！因为这种方法没有前面提到的<code class="eh la lb lc ld b">yaml</code>配置或基础设施，也没有<code class="eh la lb lc ld b">DI Container</code>或其他什么…，因此这样PHP就不会浪费时间在每个http请求中执行多余的代码！</p><h2 id="744d" class="ka kb if bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">为什么这种方法不受欢迎</h2><ol class=""><li id="1c82" class="lt lu if je b jf kv jj kw jn lv jr lw jv lx jz ly lz ma mb dt translated">因为由于自动加载的工作方式，这种类型的依赖注入只可能出现在PHP中。用JavaScript不可能做同样的事情，用其他语言也没用。因此，这种技术没有广泛应用。</li><li id="31c1" class="lt lu if je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">对于其他类型的依赖注入，可以在运行时改变应用程序的行为，但是对于名称空间DI，这是不可能的。</li></ol><h2 id="72e3" class="ka kb if bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">结论</h2><p id="774f" class="pw-post-body-paragraph jc jd if je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">如果您不需要在运行时改变应用程序的行为(或内部实现),但需要有机会从配置文件中改变它(甚至是<code class="eh la lb lc ld b">composer.json</code>),并减少执行时间——您可以考虑一个选项名称空间依赖注入！</p></div></div>    
</body>
</html>