<html>
<head>
<title>Ufo — Easily Build Docker Images and Deploy Containers to AWS ECS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ufo —轻松构建Docker映像并将容器部署到AWS ECS</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/ufo-easily-build-docker-containers-and-ship-them-to-aws-ecs-15556a2b39f?source=collection_archive---------9-----------------------#2016-12-01">https://medium.com/hackernoon/ufo-easily-build-docker-containers-and-ship-them-to-aws-ecs-15556a2b39f?source=collection_archive---------9-----------------------#2016-12-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/610337d7d742e933e064958d143d3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0moFXxbSr2h8-Slmlm3u1Q.png"/></div></div></figure><div class=""/><figure class="fi fk jc jd je hw"><div class="bz el l di"><div class="jf jg l"/></div></figure><p id="b782" class="pw-post-body-paragraph jh ji if jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj ig">更新</strong>:做了一个关于ufo的<a class="ae kf" href="https://www.meetup.com/SF-DevOps-for-Startups/events/235750382/?eventId=235750382" rel="noopener ugc nofollow" target="_blank">演示</a>，幻灯片在这里:<a class="ae kf" href="http://www.slideshare.net/tongueroo/ufo-ship-for-aws-ecs-70885296" rel="noopener ugc nofollow" target="_blank"> UFO飞船对于AWS ECS </a>。</p><h1 id="5982" class="kg kh if bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">快速介绍</h1><p id="b1e7" class="pw-post-body-paragraph jh ji if jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated"><a class="ae kf" href="https://aws.amazon.com/ecs/" rel="noopener ugc nofollow" target="_blank"> Amazon EC2容器服务</a>，ECS，是一个<a class="ae kf" href="https://hackernoon.com/tagged/aws" rel="noopener ugc nofollow" target="_blank"> AWS </a>服务，在EC2实例集群上提供和管理<a class="ae kf" href="https://hackernoon.com/tagged/docker" rel="noopener ugc nofollow" target="_blank"> Docker </a>容器。与大多数AWS服务一样，它很棒，只需要一点工具就可以创建一个流畅的流程。Ufo 是一个简单的工具，它使得构建Docker容器并将其运送到AWS ECS变得非常容易。</p><p id="1105" class="pw-post-body-paragraph jh ji if jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Ufo提供了一个名为<code class="eh lj lk ll lm b">ufo ship</code>的命令，它执行以下操作:</p><ol class=""><li id="972d" class="ln lo if jj b jk jl jo jp js lp jw lq ka lr ke ls lt lu lv dt translated">构建docker映像。</li><li id="13f5" class="ln lo if jj b jk lw jo lx js ly jw lz ka ma ke ls lt lu lv dt translated">生成并注册ECS模板定义。</li><li id="82a6" class="ln lo if jj b jk lw jo lx js ly jw lz ka ma ke ls lt lu lv dt translated">将ECS模板定义部署到指定的服务。</li></ol><p id="2190" class="pw-post-body-paragraph jh ji if jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Ufo部署了一个任务定义，它是通过一个模板生成器创建的，这个模板生成器是<strong class="jj ig">完全可控的</strong>。我们将通过一个简单的例子来展示模板的外观和工作原理。</p><h1 id="6481" class="kg kh if bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">任务定义ERB模板和DSL生成器</h1><p id="e32c" class="pw-post-body-paragraph jh ji if jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">任务定义是从<code class="eh lj lk ll lm b">ufo/templates</code>文件夹中的ERB模板创建的。这里有一个例子:<code class="eh lj lk ll lm b">ufo/templates/main.json.erb</code>。</p><pre class="mb mc md me fq mf lm mg mh aw mi dt"><span id="a4e3" class="mj kh if lm b fv mk ml l mm mn">{<br/>    "family": "&lt;%= <a class="ae kf" href="http://twitter.com/family" rel="noopener ugc nofollow" target="_blank">@family</a> %&gt;",<br/>    "containerDefinitions": [<br/>        {<br/>            "name": "&lt;%= <a class="ae kf" href="http://twitter.com/name" rel="noopener ugc nofollow" target="_blank">@name</a> %&gt;",<br/>            "image": "&lt;%= <a class="ae kf" href="http://twitter.com/image" rel="noopener ugc nofollow" target="_blank">@image</a> %&gt;",<br/>            "cpu": &lt;%= <a class="ae kf" href="http://twitter.com/cpu" rel="noopener ugc nofollow" target="_blank">@cpu</a> %&gt;,<br/>            &lt;% if <a class="ae kf" href="http://twitter.com/memory" rel="noopener ugc nofollow" target="_blank">@memory</a> %&gt;<br/>            "memory": &lt;%= <a class="ae kf" href="http://twitter.com/memory" rel="noopener ugc nofollow" target="_blank">@memory</a> %&gt;,<br/>            &lt;% end %&gt;<br/>            &lt;% if <a class="ae kf" href="http://twitter.com/memory_reservation" rel="noopener ugc nofollow" target="_blank">@memory_reservation</a> %&gt;<br/>            "memoryReservation": &lt;%= <a class="ae kf" href="http://twitter.com/memory_reservation" rel="noopener ugc nofollow" target="_blank">@memory_reservation</a> %&gt;,<br/>            &lt;% end %&gt;<br/>            &lt;% if <a class="ae kf" href="http://twitter.com/container_port" rel="noopener ugc nofollow" target="_blank">@container_port</a> %&gt;<br/>            "portMappings": [<br/>                {<br/>                    "containerPort": "&lt;%= <a class="ae kf" href="http://twitter.com/container_port" rel="noopener ugc nofollow" target="_blank">@container_port</a> %&gt;",<br/>                    "protocol": "tcp"<br/>                }<br/>            ],<br/>            &lt;% end %&gt;<br/>            "command": &lt;%= <a class="ae kf" href="http://twitter.com/command" rel="noopener ugc nofollow" target="_blank">@command</a>.to_json %&gt;,<br/>            &lt;% if <a class="ae kf" href="http://twitter.com/environment" rel="noopener ugc nofollow" target="_blank">@environment</a> %&gt;<br/>            "environment": &lt;%= <a class="ae kf" href="http://twitter.com/environment" rel="noopener ugc nofollow" target="_blank">@environment</a>.to_json %&gt;,<br/>            &lt;% end %&gt;<br/>            "essential": true<br/>        }<br/>    ]<br/>}</span></pre><p id="4cc5" class="pw-post-body-paragraph jh ji if jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">要使用的ERB模板在<code class="eh lj lk ll lm b">ufo/task_definitions.rb</code>中用<code class="eh lj lk ll lm b">source</code>方法指定。Ufo在评估<code class="eh lj lk ll lm b">ufo/task_definition.rb</code>中的<code class="eh lj lk ll lm b">task_definition</code>块时加载ERB模板。</p><pre class="mb mc md me fq mf lm mg mh aw mi dt"><span id="dda9" class="mj kh if lm b fv mk ml l mm mn">task_definition "hi-web" do<br/>  source "main" # will use ufo/templates/main.json.erb<br/>  variables(<br/>    family: task_definition_name,<br/>    # image: tongueroo/hi:ufo-[timestamp]-[sha]<br/>    image: helper.full_image_name, <br/>    environment: helper.env_file('.env.prod')<br/>    name: "web",<br/>    container_port: helper.dockerfile_port,<br/>    command: ["bin/web"]<br/>  )<br/>end</span></pre><p id="3404" class="pw-post-body-paragraph jh ji if jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">正如你在上面看到的，<code class="eh lj lk ll lm b">task_definitions.rb</code>文件有一些特殊的变量和帮助方法。这些帮助器方法提供了项目中有用的上下文信息，因此您不必在多个地方复制、粘贴和更新代码。例如，其中一个变量在项目的docker文件中提供了公开的端口。以下是一些重要的例子:</p><ul class=""><li id="11ec" class="ln lo if jj b jk jl jo jp js lp jw lq ka lr ke mo lt lu lv dt translated"><strong class="jj ig">helper . full _ image _ name</strong>—UFO构建的完整docker映像名称。docker图像名的“基本”部分在ufo/settings.yml中定义，例如，基本部分是“tongueroo/hi”，完整的图像名是tongueroo/hi:UFO-[timestamp]-[sha]。因此，基本名称不包括Docker标记，完整的图像名称包括标记。</li><li id="db5a" class="ln lo if jj b jk lw jo lx js ly jw lz ka ma ke mo lt lu lv dt translated"><strong class="jj ig"> helper.dockerfile_port </strong> —从项目的dockerfile中提取的暴露端口。</li><li id="78d8" class="ln lo if jj b jk lw jo lx js ly jw lz ka ma ke mo lt lu lv dt translated"><strong class="jj ig"> helper.env_file </strong> —该方法采用一个。env文件，包含环境变量的简单键值列表，并将列表转换为适当的任务定义json格式。</li></ul><p id="f767" class="pw-post-body-paragraph jh ji if jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">提供这些特殊帮助方法的两个类在<a class="ae kf" href="https://github.com/tongueroo/ufo/blob/master/lib/ufo/dsl.rb" rel="noopener ugc nofollow" target="_blank"> ufo/dsl.rb </a>和<a class="ae kf" href="https://github.com/tongueroo/ufo/blob/master/lib/ufo/dsl/helper.rb" rel="noopener ugc nofollow" target="_blank"> ufo/dsl/helper.rb </a>中。有关特殊变量和方法的完整列表，请参考这些类。</p><h1 id="0fb5" class="kg kh if bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">用法示例</h1><p id="76fc" class="pw-post-body-paragraph jh ji if jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">一个例子将展示使用ufo是多么容易。该项目的官方文件提供了更多细节:<a class="ae kf" href="http://ufoships.com/" rel="noopener ugc nofollow" target="_blank">http://ufoships.com</a>。</p><p id="2a65" class="pw-post-body-paragraph jh ji if jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个例子是一个演示rails应用程序，它返回rails欢迎页面。我还创建了<code class="eh lj lk ll lm b">bin/worker</code>和<code class="eh lj lk ll lm b">bin/clock</code>脚本，它们运行一个无限循环来模拟工人和时钟进程进行测试。演示项目的完整源代码可以在GitHub上找到:<a class="ae kf" href="https://github.com/tongueroo/hi" rel="noopener ugc nofollow" target="_blank"> tongueroo/hi </a>。</p><h1 id="05e4" class="kg kh if bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">在Mac OSX本地测试演示项目</h1><p id="a602" class="pw-post-body-paragraph jh ji if jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">让我们设置应用程序，安装依赖项并启动web流程。</p><pre class="mb mc md me fq mf lm mg mh aw mi dt"><span id="f91c" class="mj kh if lm b fv mk ml l mm mn">$ git clone <a class="ae kf" href="https://github.com/tongueroo/hi.git" rel="noopener ugc nofollow" target="_blank">https://github.com/tongueroo/hi</a><br/>$ cd hi<br/>$ bundle<br/>$ bin/web # start the web server</span></pre><p id="2b32" class="pw-post-body-paragraph jh ji if jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们卷曲为200响应代码。</p><pre class="mb mc md me fq mf lm mg mh aw mi dt"><span id="312d" class="mj kh if lm b fv mk ml l mm mn">$ curl -svo /dev/null localhost:3000 2&gt;&amp;1 | grep ‘&lt; HTTP’<br/>&lt; HTTP/1.1 200 OK <br/>$</span></pre><h1 id="47f6" class="kg kh if bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">用Docker构建和测试演示项目</h1><p id="2dab" class="pw-post-body-paragraph jh ji if jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">现在让我们用ufo构建docker映像，并测试它在本地的工作情况。我只展示了一些shell输出，以保持粘贴的大小较小，并在上下文中有用。</p><pre class="mb mc md me fq mf lm mg mh aw mi dt"><span id="28d2" class="mj kh if lm b fv mk ml l mm mn">$ ufo init --app hi --image tongueroo/hi<br/>Setting up ufo project…<br/>created: ./bin/deploy<br/>exists: ./Dockerfile<br/>created: ./ufo/settings.yml<br/>created: ./ufo/task_definitions.rb<br/>created: ./ufo/templates/main.json.erb<br/>created: ./.env<br/>Starter ufo files created.<br/>$ ufo docker build<br/>$ docker images | grep “tongueroo/hi”<br/>tongueroo/hi ufo-2016–11–30T16–25–26-e1d57ce e511ec8a328a About a minute ago 826.8 MB<br/>$ docker run -d -p 3000:3000 — name hi tongueroo/hi:ufo-2016–11–30T16–25–26-e1d57ce<br/>$ docker ps<br/>$ curl -svo /dev/null localhost:3000 2&gt;&amp;1 | grep ‘&lt; HTTP’<br/>&lt; HTTP/1.1 200 OK <br/>$ docker stop hi ; docker rm hi<br/>$</span></pre><p id="9601" class="pw-post-body-paragraph jh ji if jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在上面的代码片段中，我运行了两个ufo命令:<code class="eh lj lk ll lm b">ufo init</code>和<code class="eh lj lk ll lm b">ufo docker build</code>。让我们回顾一下<code class="eh lj lk ll lm b">ufo init</code>创建的一些文件:</p><ul class=""><li id="42f0" class="ln lo if jj b jk jl jo jp js lp jw lq ka lr ke mo lt lu lv dt translated">bin/deploy——包装器部署脚本，展示了如何使用ufo同时将3个常见的web、worker和clock进程部署为服务。</li><li id="f010" class="ln lo if jj b jk lw jo lx js ly jw lz ka ma ke mo lt lu lv dt translated">ufo/settings.yml —这是您设置要构建的Docker图像名称的地方。有一个service_cluster映射选项，您可以使用它来避免总是在CLI中提供<code class="eh lj lk ll lm b">--cluster</code>选项。这很方便。</li><li id="deaa" class="ln lo if jj b jk lw jo lx js ly jw lz ka ma ke mo lt lu lv dt translated">UFO/task _ definitions . Rb-这是您定义要替换到ERB模板中的变量的地方。</li><li id="18d8" class="ln lo if jj b jk lw jo lx js ly jw lz ka ma ke mo lt lu lv dt translated">UFO/templates/main . JSON . erb-这是任务定义erb模板。您可以对此进行修改，并完全控制注册到ECS的任务定义模板。</li><li id="aba2" class="ln lo if jj b jk lw jo lx js ly jw lz ka ma ke mo lt lu lv dt translated">。env——开胃菜。如果项目中不存在env文件，则会提供一个。如果对您的需求更有意义，您可以将其重命名为<code class="eh lj lk ll lm b">.env.prod</code>和<code class="eh lj lk ll lm b">.env.stag</code>。如果重命名<code class="eh lj lk ll lm b">.env</code>文件，记得更新<code class="eh lj lk ll lm b">task_definitions.rb</code>中的env_file行。</li></ul><p id="3eb8" class="pw-post-body-paragraph jh ji if jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh lj lk ll lm b">ufo docker build</code>命令创建了一个tongueroo/hi:UFO-2016–11–30t 16–25–26-E1 d 57 ce Docker映像。</p><h1 id="cd0c" class="kg kh if bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">将Docker映像发送到ECS</h1><p id="5a10" class="pw-post-body-paragraph jh ji if jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">让我们将web流程作为ECS服务发布。首先，创建一个名为<code class="eh lj lk ll lm b">stag</code>的ECS集群，我们将使用它将web服务发送到那里。您还需要与web服务相关联的ELB目标群体，以便从世界任何地方都可以访问该应用程序。我已经为这个例子创建了一个<code class="eh lj lk ll lm b">stag</code>集群，一个“hi-elb”和“hi-target-group”。你可以从负载平衡/目标组中抓取目标组ARN:</p><figure class="mb mc md me fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mp"><img src="../Images/947b4c0dbe63c003f2162bd3019037cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OoZUsgEvr06bmy_l8m03hQ.png"/></div></div></figure><p id="65d6" class="pw-post-body-paragraph jh ji if jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您只需要在第一次使用ufo部署时提供ELB目标组ARN，因为您无法在以后更新ECS服务的目标组。如果要更改目标组，则必须创建并部署新的服务。这是一个AWS ECS设计决策。</p><h1 id="b4b4" class="kg kh if bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">飞碟船</h1><p id="03f5" class="pw-post-body-paragraph jh ji if jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">现在我们可以用<code class="eh lj lk ll lm b">ufo ship</code>将docker容器运送到ECS！</p><pre class="mb mc md me fq mf lm mg mh aw mi dt"><span id="d318" class="mj kh if lm b fv mk ml l mm mn">$ ufo ship hi-web --cluster stag --target-group=arn:aws:elasticloadbalancing:us-east-1:467446852200:targetgroup/hi-target-group/f61e87b3c4761922<br/>Building docker image with:<br/>  docker build -t tongueroo/hi:ufo-2016-12-01T07-37-53-e1d57ce -f Dockerfile .<br/>Docker image tongueroo/hi:ufo-2016-12-01T07-38-32-e1d57ce built.  Took 2s.<br/>Pushed tongueroo/hi:ufo-2016-12-01T07-38-32-e1d57ce docker image. Took 4s.<br/>Building Task Definitions...<br/>Generating Task Definitions:<br/>Generated task definition at: ./ufo/output/hi-web.json<br/>Generated task definition at: ./ufo/output/hi-worker.json<br/>Generated task definition at: ./ufo/output/hi-clock.json<br/>Task Definitions built in ufo/output.<br/>hi-web task definition registered.<br/>Shipping hi-web...<br/>hi-web service created on stag cluster<br/>Waiting for deployment of task definition hi-web:3 to complete<br/>...........<br/>Time waiting for ECS deployment: 58s.<br/>Software shipped!</span></pre><p id="6105" class="pw-post-body-paragraph jh ji if jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们检查并回顾一下<code class="eh lj lk ll lm b">ufo ship</code>命令实际上做了什么。首先，它构建了名为<code class="eh lj lk ll lm b">tongueroo/hi:ufo-2016-12-01T07-37-53-ec1d57ce</code>的docker映像。可以用<code class="eh lj lk ll lm b">docker images</code>查一下。</p><pre class="mb mc md me fq mf lm mg mh aw mi dt"><span id="108c" class="mj kh if lm b fv mk ml l mm mn">$ docker images                                                   ufo-2016-12-01T07-38-32-e1d57ce    a9e97fa264ab        5 minutes ago       826.8 MB<br/>$</span></pre><p id="c709" class="pw-post-body-paragraph jh ji if jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">其次，ufo在ufo/output文件夹中生成了所有的任务定义，并且只注册了一个已部署的任务定义:hi-web。让我们来看看生成的任务定义之一:<code class="eh lj lk ll lm b">ufo/output/hi-web.json</code>。</p><pre class="mb mc md me fq mf lm mg mh aw mi dt"><span id="3e8f" class="mj kh if lm b fv mk ml l mm mn">{<br/>  "family": "hi-web",<br/>  "containerDefinitions": [<br/>    {<br/>      "name": "web",<br/>      "image": "tongueroo/hi:ufo-2016-12-01T08-07-08-e1d57ce",<br/>      "cpu": 128,<br/>      "memoryReservation": 256,<br/>      "portMappings": [<br/>        {<br/>          "containerPort": "3000",<br/>          "protocol": "tcp"<br/>        }<br/>      ],<br/>      "command": [<br/>        "bin/web"<br/>      ],<br/>      "environment": [<br/>        {<br/>          "name": "ADMIN_PASSWORD",<br/>          "value": "secret"<br/>        }<br/>      ],<br/>      "essential": true<br/>    }<br/>  ]<br/>}</span></pre><p id="9d70" class="pw-post-body-paragraph jh ji if jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">第三，ufo将新注册的hi-web:3任务定义部署到ECS。</p><h1 id="5e1e" class="kg kh if bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">确认它有效</h1><p id="f9df" class="pw-post-body-paragraph jh ji if jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">从EC2控制台/负载平衡/负载平衡器获取ELB DNS端点。</p><figure class="mb mc md me fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mq"><img src="../Images/97fb8f8c09f2663c605df99f77c2dc4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W5-iK2JM3zhYoc7ZGMB2zA.png"/></div></div></figure><p id="0719" class="pw-post-body-paragraph jh ji if jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">确认应用程序已启动curl:</p><pre class="mb mc md me fq mf lm mg mh aw mi dt"><span id="d2d9" class="mj kh if lm b fv mk ml l mm mn">$ curl -svo /dev/null hi-elb-1381308520.us-east-1.elb.amazonaws.com 2&gt;&amp;1 | grep '&lt; HTTP'<br/>&lt; HTTP/1.1 200 OK<br/>$</span></pre><p id="2f1a" class="pw-post-body-paragraph jh ji if jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">就是这样！此<a class="ae kf" href="https://github.com/tongueroo/hi" rel="noopener ugc nofollow" target="_blank"> tongueroo/hi </a>应用程序的web流程已部署到ECS。</p><h1 id="e267" class="kg kh if bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">使用绑定/部署</h1><p id="7220" class="pw-post-body-paragraph jh ji if jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">当我们在这个例子的开头使用<code class="eh lj lk ll lm b">ufo init</code>时，它生成了一个<code class="eh lj lk ll lm b">bin/deploy</code>脚本。这个脚本一次性处理web、worker和clock等常见应用程序进程的部署。这些进程通常使用相同的代码库，即:相同的docker映像，但运行时设置略有不同。例如，web进程的docker run命令可以是<a class="ae kf" href="http://puma.io/" rel="noopener ugc nofollow" target="_blank"> puma </a>，而工作进程的命令可以是<a class="ae kf" href="http://sidekiq.org/" rel="noopener ugc nofollow" target="_blank"> sidekiq </a>。环境变量有时也不同。</p><p id="1efc" class="pw-post-body-paragraph jh ji if jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们快速测试一下，确保worker和clock进程首先在本地工作。worker和clock进程脚本实际上是模拟出来的，只是简单的无限bash循环。这就是我们需要测试的东西。这里有一个快速的本地测试:</p><pre class="mb mc md me fq mf lm mg mh aw mi dt"><span id="1785" class="mj kh if lm b fv mk ml l mm mn">$ bin/worker <br/>+ true<br/>+ echo 'fake worker process running...'<br/>fake worker process running...<br/>+ sleep 5<br/>^C<br/>$ bin/clock <br/>+ true<br/>+ echo 'fake clock process running...'<br/>fake clock process running...<br/>+ sleep 5<br/>^C<br/>$</span></pre><p id="b8ec" class="pw-post-body-paragraph jh ji if jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在让我们来看看<code class="eh lj lk ll lm b">bin/deploy</code>的剧本。</p><pre class="mb mc md me fq mf lm mg mh aw mi dt"><span id="90c3" class="mj kh if lm b fv mk ml l mm mn">#!/bin/bash -xe</span><span id="a0e1" class="mj kh if lm b fv mr ml l mm mn">ufo ships hi-{web,clock,worker}-stag --cluster stag</span></pre><p id="ed07" class="pw-post-body-paragraph jh ji if jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">bin/deploy包装器脚本只调用<code class="eh lj lk ll lm b">ufo ships</code>命令，该命令用于构建1个docker映像并将其发送给多个ECS服务。现在，让我们将所有3个流程作为服务交付给ECS！</p><pre class="mb mc md me fq mf lm mg mh aw mi dt"><span id="dcb5" class="mj kh if lm b fv mk ml l mm mn">bin/deploy # deploys clock, worker and web!</span></pre><h1 id="093f" class="kg kh if bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">摘要</h1><p id="3dde" class="pw-post-body-paragraph jh ji if jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">ufo工具自动构建docker映像，注册ECS任务定义，并将容器部署到ECS服务。项目页面可在GitHub上的<a class="ae kf" href="https://github.com/tongueroo/ufo" rel="noopener ugc nofollow" target="_blank"> tongueroo/ufo </a>获得。试试吧，让我知道你的想法！</p><blockquote class="ms"><p id="9285" class="mt mu if bd mv mw mx my mz na nb ke ek translated">谢谢你读到这里。如果你觉得这篇文章有用，如果你推荐这篇文章(点击拍手按钮)让其他人也能找到它，我会非常感激！还有，在<a class="ae kf" href="https://www.linkedin.com/in/tongueroo/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上和我联系。</p></blockquote></div><div class="ab cl nc nd hc ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="hn ho hp hq hr"><div class="mb mc md me fq ab cb"><figure class="nj hw nk nl nm nn no paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nj hw nk nl nm nn no paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nj hw nk nl nm nn no paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="np nq nr"><p id="f922" class="jh ji ns jj b jk jl jm jn jo jp jq jr nt jt ju jv nu jx jy jz nv kb kc kd ke hn dt translated"><a class="ae kf" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是AMI家庭的一员。我们现在<a class="ae kf" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae kf" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jh ji ns jj b jk jl jm jn jo jp jq jr nt jt ju jv nu jx jy jz nv kb kc kd ke hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kf" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kf" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="mb mc md me fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nw"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="mb mc md me fq hw"><div class="bz el l di"><div class="nx jg l"/></div></figure></div></div>    
</body>
</html>