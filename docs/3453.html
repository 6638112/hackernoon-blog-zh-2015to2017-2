<html>
<head>
<title>Let’s Build a Programming Language</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们建立一种编程语言</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/lets-build-a-programming-language-2612349105c6?source=collection_archive---------0-----------------------#2017-04-03">https://medium.com/hackernoon/lets-build-a-programming-language-2612349105c6?source=collection_archive---------0-----------------------#2017-04-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/55c4d4e927933a3558de297880557aaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_376jkknhFvBPrta0YHCIA.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="https://en.wikipedia.org/wiki/The_Great_Wave_off_Kanagawa" rel="noopener ugc nofollow" target="_blank">The Great Wave off Kanagawa</a>, <a class="ae jg" href="https://en.wikipedia.org/wiki/Katsushika_Hokusai" rel="noopener ugc nofollow" target="_blank">Katsushika Hokusai</a></figcaption></figure><p id="4530" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">作为一个编写代码的人，你无疑会使用一种或多种编程语言。你可能喜欢用一些编程语言编写代码，因为它们的优雅、表达能力或任何其他原因，你也可能与其他编程语言保持距离，可能是因为它们的一些特性你认为实现得不好。</p><p id="9d22" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然而，你想过那些我们又爱又恨的编程语言是怎么来的吗？我们喜欢(或不喜欢)的特定功能是如何设计和实现的，为什么？那些作为编译器和解释器的神奇黑盒是如何工作的？用JavaScript、Ruby、Python等语言编写的代码如何变成可执行程序？或者有没有想过构建自己的编程语言？</p><p id="87f3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你对以上任何一个问题的回答是肯定的，欢迎阅读关于<strong class="jj hv">构建编程语言</strong>的系列文章。</p><p id="608c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">本系列将带您从0到1构建一种编程语言的函数解释器。在本系列的最后，您将拥有一个解释器，它是您从头构建的，运行用我们一起设计的编程语言编写的程序。</p><h1 id="6002" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">为什么？</h1><p id="e246" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">为什么要学习如何实现一门编程语言？</p><ul class=""><li id="016c" class="li lj hu jj b jk jl jo jp js lk jw ll ka lm ke ln lo lp lq dt translated"><strong class="jj hv">构建编译器或解释器会让你成为更好的程序员。</strong>编译器和解释器包含有趣的数据结构和算法，其知识对其他领域是适用和有用的。您可以将这些知识应用于编写不同文件格式的解析器，构建特定领域的语言，例如数据库查询语言等等。您还将更好地理解如何以及何时优化代码，更好地为特定任务选择最佳编程语言，并且您将最终理解您的编译器/解释器有时会抛出的一些奇怪的错误消息:)。</li><li id="c82a" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke ln lo lp lq dt translated"><strong class="jj hv">为开发你最喜欢的编程语言</strong>做出贡献。许多有趣的编程语言都是开源的，并欢迎新的贡献者，但通常，对于大多数从未上过CS编译器课程的人来说，贡献所需的知识是一个入门障碍。如果你关心你喜欢的编程语言和/或曾经想过为它的发展作出贡献，在你已经建立了一个玩具编译器或解释器之后，你将会更好地做好准备。</li><li id="9937" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke ln lo lp lq dt translated">很有意思。:)</li></ul><h1 id="6472" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">怎么会？</h1><p id="1973" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">本文是一个系列的介绍，其中的每一篇文章都将介绍在实现编程语言中完成一个特定步骤所必需的概念和知识。每篇文章都以挑战结尾(没有挑战就不好玩了吧？).这个挑战将提示你实现一个定义良好的解释器组件。在每篇文章的结尾都有一些测试文件可以下载，你可以通过编写代码来完成所有的测试。当你完成所有的挑战时，你将拥有一个完整的工作解释器，可以运行用我们的编程语言编写的代码。</p><p id="c2ed" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">尽管任何编程语言都可以用来完成这些挑战，但是对于本系列，我们的实现语言将主要是<a class="ae jg" href="https://en.wikipedia.org/wiki/JavaScript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>，<a class="ae jg" href="https://en.wikipedia.org/wiki/ECMAScript#Harmony.2C_6th_Edition" rel="noopener ugc nofollow" target="_blank"> ES6 </a>更准确地说，以便本系列可以被更广泛的受众访问。</p><h1 id="cc94" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">什么？</h1><p id="6232" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">如果以上听起来都不错，那么让我们从描述我们将要实现的编程语言开始。我们专门为这个系列设计的编程语言叫做<strong class="jj hv"> Blink </strong>。这是一种受Swift、Kotlin和Scala启发的解释型、面向对象和静态类型的编程语言。</p></div><div class="ab cl lw lx hc ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hn ho hp hq hr"><h1 id="1d67" class="kf kg hu bd kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc dt translated">眨眼之旅</h1><h2 id="1854" class="mi kg hu bd kh mj mk ml kl mm mn mo kp js mp mq kt jw mr ms kx ka mt mu lb mv dt translated">你好，眨眼！</h2><p id="092e" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">典型的<em class="mw">《你好，世界》</em>是这样写的。</p><pre class="mx my mz na fq nb nc nd ne aw nf dt"><span id="c87f" class="mi kg hu nc b fv ng nh l ni nj">Console.println("Hello, Blink!")</span></pre><h2 id="e077" class="mi kg hu bd kh mj mk ml kl mm mn mo kp js mp mq kt jw mr ms kx ka mt mu lb mv dt translated">数据类型</h2><p id="cbd1" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">Blink支持常见类型的值，如<code class="eh nk nl nm nc b">Int</code>、<code class="eh nk nl nm nc b">Double</code>、<code class="eh nk nl nm nc b">String</code>和<code class="eh nk nl nm nc b">Bool</code>。此外，还有一个特殊的类型<code class="eh nk nl nm nc b">Unit</code>来表示值的缺失(类似于Java中的<code class="eh nk nl nm nc b">void</code>)，并且Blink中的所有类型都继承自一个超类型<code class="eh nk nl nm nc b">Object</code>。</p><h2 id="9359" class="mi kg hu bd kh mj mk ml kl mm mn mo kp js mp mq kt jw mr ms kx ka mt mu lb mv dt translated">评论</h2><p id="274a" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">Blink中的一条评论以<code class="eh nk nl nm nc b">//</code>开头。从<code class="eh nk nl nm nc b">//</code>符号到行尾的任何内容都将被Blink解释器忽略。</p><pre class="mx my mz na fq nb nc nd ne aw nf dt"><span id="fb45" class="mi kg hu nc b fv ng nh l ni nj">// This is a comment.</span></pre><h2 id="ad00" class="mi kg hu bd kh mj mk ml kl mm mn mo kp js mp mq kt jw mr ms kx ka mt mu lb mv dt translated">声明变量</h2><p id="2ecd" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">使用<code class="eh nk nl nm nc b">let</code> <em class="mw">表达式</em>声明变量。</p><pre class="mx my mz na fq nb nc nd ne aw nf dt"><span id="7396" class="mi kg hu nc b fv ng nh l ni nj"><strong class="nc hv">let</strong> message: <strong class="nc hv">String</strong> = "Hello, Blink!" <strong class="nc hv">in</strong> {<br/>    Console.println(message)<br/>}</span></pre><p id="8d3b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一个<code class="eh nk nl nm nc b">let</code>表达式由两部分组成:</p><ul class=""><li id="84d5" class="li lj hu jj b jk jl jo jp js lk jw ll ka lm ke ln lo lp lq dt translated"><strong class="jj hv">声明</strong>(在<code class="eh nk nl nm nc b">in</code>关键字之前)，在这里变量被声明并可能被初始化。变量声明由变量的名称、冒号<code class="eh nk nl nm nc b">:</code>和变量的类型<code class="eh nk nl nm nc b">message: String</code>组成。要在声明时初始化变量，需要添加equal <code class="eh nk nl nm nc b">=</code>和变量的值<code class="eh nk nl nm nc b">message: String = "Hello, Blink!"</code>。</li><li id="d978" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke ln lo lp lq dt translated">可以访问变量的<strong class="jj hv">主体</strong>(在<code class="eh nk nl nm nc b">in</code>关键字之后)。用<code class="eh nk nl nm nc b">let</code>声明的变量只能在关联体中访问。</li></ul><p id="9dfd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">省略变量的类型。</strong> Blink支持<a class="ae jg" href="https://en.wikipedia.org/wiki/Type_inference" rel="noopener ugc nofollow" target="_blank">类型推断</a>，这意味着如果变量在声明时被初始化，那么它的类型可以被省略，Blink将根据它的值推断出变量的正确类型。前面的例子可以写成这样:</p><pre class="mx my mz na fq nb nc nd ne aw nf dt"><span id="5784" class="mi kg hu nc b fv ng nh l ni nj"><strong class="nc hv">let</strong> message = "Hello, World!" <strong class="nc hv">in</strong> {<br/>    Console.println(message)<br/>}</span></pre><p id="8185" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">一次声明多个变量。</strong>声明多个变量，在<code class="eh nk nl nm nc b">let</code> <em class="mw">表达式</em>的声明部分用逗号<code class="eh nk nl nm nc b">,</code>隔开。</p><pre class="mx my mz na fq nb nc nd ne aw nf dt"><span id="609e" class="mi kg hu nc b fv ng nh l ni nj"><strong class="nc hv">let</strong> a = 42<strong class="nc hv">,</strong> b = 12<strong class="nc hv">,</strong> c = 24 <strong class="nc hv">in</strong> {<br/>    Console.println(a + b + c)<br/>}</span></pre><p id="18ef" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">每个变量都可以访问在其初始化表达式中在它之前声明的所有变量。所以像下面这样的事情是完全可能的。</p><pre class="mx my mz na fq nb nc nd ne aw nf dt"><span id="5d58" class="mi kg hu nc b fv ng nh l ni nj"><strong class="nc hv">let</strong> a = 42, b = <strong class="nc hv">a * 2</strong>, c = <strong class="nc hv">b * 3</strong> <strong class="nc hv">in</strong> {<br/>    Console.println(a)<br/>    Console.println(b)<br/>    Console.println(c)<br/>}</span></pre><p id="5ce4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">上面的内容会打印出来</p><pre class="mx my mz na fq nb nc nd ne aw nf dt"><span id="69ff" class="mi kg hu nc b fv ng nh l ni nj">42<br/>84<br/>252</span></pre><p id="9d40" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">省略花括号。</strong>关于<code class="eh nk nl nm nc b">let</code> <em class="mw">表达式</em>的最后一个注意事项是，如果主体仅由一个<em class="mw">表达式</em>组成，则可以省略花括号。第一个示例可以更简洁地编写如下。</p><pre class="mx my mz na fq nb nc nd ne aw nf dt"><span id="83a3" class="mi kg hu nc b fv ng nh l ni nj"><strong class="nc hv">let</strong> message = "Hello, Blink!" <strong class="nc hv">in</strong> Console.println(message)</span></pre><h2 id="09b1" class="mi kg hu bd kh mj mk ml kl mm mn mo kp js mp mq kt jw mr ms kx ka mt mu lb mv dt translated">情况</h2><p id="4620" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">像在大多数编程语言中一样，条件用一个<code class="eh nk nl nm nc b">if-else</code> <em class="mw">表达式</em>来表达。</p><pre class="mx my mz na fq nb nc nd ne aw nf dt"><span id="3ed8" class="mi kg hu nc b fv ng nh l ni nj"><strong class="nc hv">if</strong> (&lt;condition&gt;) {<br/>    &lt;do something&gt;<br/>} <strong class="nc hv">else</strong> {<br/>    &lt;do something&gt;<br/>}</span></pre><p id="b13f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">条件必须评估为类型<code class="eh nk nl nm nc b">Bool</code>的值。如果需要，可以省略<code class="eh nk nl nm nc b">else</code>块，如果块仅由一个<em class="mw">表达式</em>组成，则<code class="eh nk nl nm nc b">if</code>或<code class="eh nk nl nm nc b">else</code>块可以省略花括号。</p><pre class="mx my mz na fq nb nc nd ne aw nf dt"><span id="27c0" class="mi kg hu nc b fv ng nh l ni nj"><strong class="nc hv">if</strong> (answer == 42) {<br/>    Console.println("That's the answer of life!")<br/>} <strong class="nc hv">else</strong> {<br/>    Console.println("That's not the answer of life.")<br/>}</span></pre><h2 id="b172" class="mi kg hu bd kh mj mk ml kl mm mn mo kp js mp mq kt jw mr ms kx ka mt mu lb mv dt translated">环</h2><p id="f5b3" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">一个<code class="eh nk nl nm nc b">while</code> <em class="mw">表达式</em>用于在条件成立时执行一个或多个<em class="mw">表达式</em>。</p><pre class="mx my mz na fq nb nc nd ne aw nf dt"><span id="9c27" class="mi kg hu nc b fv ng nh l ni nj"><strong class="nc hv">while</strong> (&lt;condition&gt;) {<br/>    &lt;do something&gt;<br/>}</span></pre><p id="9be4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">同样，如果<code class="eh nk nl nm nc b">while</code>的主体仅由一个<em class="mw">表达式组成，可以省略花括号。</em></p><h2 id="7594" class="mi kg hu bd kh mj mk ml kl mm mn mo kp js mp mq kt jw mr ms kx ka mt mu lb mv dt translated">定义函数</h2><p id="b78c" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">使用<code class="eh nk nl nm nc b">func</code>关键字定义函数。</p><pre class="mx my mz na fq nb nc nd ne aw nf dt"><span id="2f9b" class="mi kg hu nc b fv ng nh l ni nj"><strong class="nc hv">func</strong> sum(a: <strong class="nc hv">Int</strong>, b: <strong class="nc hv">Int</strong>)<strong class="nc hv">: Int</strong> <strong class="nc hv">=</strong> {<br/>    a + b<br/>}</span></pre><p id="c0f9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">Blink<strong class="jj hv"/>中的功能参数</strong>用逗号<code class="eh nk nl nm nc b">,</code>隔开，并用括号<code class="eh nk nl nm nc b">(a: Int, b: Int)</code>括起来。每个参数都是由其名称后跟冒号<code class="eh nk nl nm nc b">:</code>和类型<code class="eh nk nl nm nc b">a: Int</code>定义的。</p><p id="0ca2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">返回类型。</strong>返回类型是通过在参数列表后添加一个冒号<code class="eh nk nl nm nc b">:</code>，后跟函数返回值的类型来定义的。如果函数不返回值，返回类型必须是<code class="eh nk nl nm nc b">Unit</code>。</p><pre class="mx my mz na fq nb nc nd ne aw nf dt"><span id="b2f7" class="mi kg hu nc b fv ng nh l ni nj"><strong class="nc hv">func</strong> greet()<strong class="nc hv">: Unit</strong> = {<br/>    Console.println("Hello, Blink!")<br/>}</span></pre><p id="0cc3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是作为一个语法糖，如果一个函数没有声明任何返回类型，Blink会自动假设返回类型是<code class="eh nk nl nm nc b">Unit</code>。所以前面的例子可以写成如下形式。</p><pre class="mx my mz na fq nb nc nd ne aw nf dt"><span id="f61c" class="mi kg hu nc b fv ng nh l ni nj"><strong class="nc hv">func</strong> greet() = {<br/>    Console.println("Hello, Blink!")<br/>}</span></pre><p id="3ef1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">功能体。在返回类型之后，是等号运算符，然后是用花括号括起来的函数体。Blink中没有<strong class="jj hv">无返回关键字</strong>，函数<strong class="jj hv">体中最后一个<em class="mw">表达式</em>的值就是函数返回的</strong>值。</strong></p><p id="2bfe" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果主体仅由一个<em class="mw">表达式</em>组成，则可以省略花括号。我们的第一个例子可以改写成这样:</p><pre class="mx my mz na fq nb nc nd ne aw nf dt"><span id="f53c" class="mi kg hu nc b fv ng nh l ni nj"><strong class="nc hv">func</strong> sum(a: Int, b: Int) <strong class="nc hv">=</strong> a + b</span></pre><h2 id="7f8f" class="mi kg hu bd kh mj mk ml kl mm mn mo kp js mp mq kt jw mr ms kx ka mt mu lb mv dt translated">定义类别</h2><p id="d36a" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">使用<code class="eh nk nl nm nc b">class</code>关键字定义类。</p><pre class="mx my mz na fq nb nc nd ne aw nf dt"><span id="ce4f" class="mi kg hu nc b fv ng nh l ni nj"><strong class="nc hv">class</strong> Person {<br/>}</span></pre><p id="214a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这定义了一个简单(尽管没用)的类<code class="eh nk nl nm nc b">Person</code>。现在可以使用关键字<code class="eh nk nl nm nc b">new</code>创建类<code class="eh nk nl nm nc b">Person</code>的对象。</p><pre class="mx my mz na fq nb nc nd ne aw nf dt"><span id="390f" class="mi kg hu nc b fv ng nh l ni nj"><strong class="nc hv">let</strong> p = <em class="mw">new</em><strong class="nc hv"> Person()</strong> <strong class="nc hv">in</strong> { }</span></pre><p id="5277" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">属性。</strong>一个类可以有一个或多个用<code class="eh nk nl nm nc b">var</code>关键字声明的属性。</p><pre class="mx my mz na fq nb nc nd ne aw nf dt"><span id="feb1" class="mi kg hu nc b fv ng nh l ni nj"><strong class="nc hv">class</strong> Person {<br/>    <strong class="nc hv">var</strong> firstname: <strong class="nc hv">String</strong> = "Klaus"<br/>    <strong class="nc hv">var</strong> lastname: <strong class="nc hv">String</strong><br/>    <strong class="nc hv">var</strong> age: <strong class="nc hv">Int</strong><br/>}</span></pre><p id="dcb2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">属性可以在声明时进行初始化。如果一个属性被初始化，初始化<em class="mw">表达式</em>将在创建对象时被评估。</p><p id="4dbf" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">Blink中的属性是私有的</strong>。他们不能被公开。可以创建Getters和setters(只是函数)来访问类外部的属性。</p><p id="770c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">功能。</strong>一个类可以有函数(或者<code class="eh nk nl nm nc b">methods</code>，如果你喜欢的话)。</p><pre class="mx my mz na fq nb nc nd ne aw nf dt"><span id="329e" class="mi kg hu nc b fv ng nh l ni nj"><strong class="nc hv">class</strong> Person {<br/>    <strong class="nc hv">var</strong> firstname: <strong class="nc hv">String</strong> = "Klaus"<br/>    <strong class="nc hv">var</strong> lastname: <strong class="nc hv">String</strong><br/>    <strong class="nc hv">var</strong> age: <strong class="nc hv">Int</strong></span><span id="7d91" class="mi kg hu nc b fv nn nh l ni nj">    <strong class="nc hv">func</strong> firstname(): <strong class="nc hv">String</strong> = {<br/>        firstname<br/>    }</span><span id="3241" class="mi kg hu nc b fv nn nh l ni nj">    <strong class="nc hv">func</strong> setFirstname(name: <strong class="nc hv">String</strong>) = {<br/>        firstname = name<br/>    }<br/>}</span></pre><p id="d975" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在上面的例子中，属性<code class="eh nk nl nm nc b">firstname</code>有一个getter和一个setter。编写这些函数的更惯用的方法是省略花括号，因为在每个函数的主体中只有一个<em class="mw">表达式</em>。</p><pre class="mx my mz na fq nb nc nd ne aw nf dt"><span id="c26e" class="mi kg hu nc b fv ng nh l ni nj"><strong class="nc hv">class</strong> Person {<br/>    <strong class="nc hv">var</strong> firstname: <strong class="nc hv">String</strong> = "Klaus"<br/>    <strong class="nc hv">var</strong> lastname: <strong class="nc hv">String</strong><br/>    <strong class="nc hv">var</strong> age: <strong class="nc hv">Int</strong></span><span id="7cbb" class="mi kg hu nc b fv nn nh l ni nj"><strong class="nc hv">    func</strong> firstname(): <strong class="nc hv">String</strong> = firstname<br/>    <strong class="nc hv">func</strong> setFirstname(name: <strong class="nc hv">String</strong>) = firstname = name<br/>}</span></pre><p id="ae94" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">默认情况下，Blink </strong>中的功能是公共的。然而，可以通过在<code class="eh nk nl nm nc b">func</code>关键字前添加<code class="eh nk nl nm nc b">private</code>修饰符来使函数私有。</p><pre class="mx my mz na fq nb nc nd ne aw nf dt"><span id="9b5f" class="mi kg hu nc b fv ng nh l ni nj"><strong class="nc hv">private func</strong> age(): Int = // ...</span></pre><p id="324f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">建造师。Blink中的一个类有且只有一个构造函数。默认情况下，Blink中的类有一个不带参数的默认构造函数。显式自定义构造函数可以通过在类名中添加一组括在括号中的参数来定义。</strong></p><pre class="mx my mz na fq nb nc nd ne aw nf dt"><span id="829a" class="mi kg hu nc b fv ng nh l ni nj"><strong class="nc hv">class</strong> Person<strong class="nc hv">(</strong>firstname<strong class="nc hv">: String, </strong>lastname<strong class="nc hv">: String)</strong> {<br/>    <strong class="nc hv">func</strong> firstname(): <strong class="nc hv">String</strong> = firstname<br/>    <strong class="nc hv">func</strong> setFirstname(name: <strong class="nc hv">String</strong>) = firstname = name</span><span id="2fa1" class="mi kg hu nc b fv nn nh l ni nj">    <strong class="nc hv">func</strong> lastname(): <strong class="nc hv">String</strong> = lastname<br/>    <strong class="nc hv">func</strong> setLastname(name: <strong class="nc hv">String</strong>) = lastname = name<br/>}</span></pre><p id="67e1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">构造函数参数自动充当类的属性，可以从类中所有函数的主体或任何附加属性的初始化表达式<em class="mw">中访问。</em></p><pre class="mx my mz na fq nb nc nd ne aw nf dt"><span id="8b52" class="mi kg hu nc b fv ng nh l ni nj"><strong class="nc hv">let</strong> person = <em class="mw">new</em><strong class="nc hv"> Person("</strong>Klaus"<strong class="nc hv">, </strong>"Baudelaire"<strong class="nc hv">)</strong> <strong class="nc hv">in</strong> {<br/>    Console.println(person<strong class="nc hv">.firstname()</strong>)<br/>    Console.println(person<strong class="nc hv">.lastname()</strong>)<br/>}</span></pre><p id="5e87" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">上面的内容会打印出来</p><pre class="mx my mz na fq nb nc nd ne aw nf dt"><span id="f21e" class="mi kg hu nc b fv ng nh l ni nj">Klaus<br/>Baudelaire</span></pre><p id="b4fa" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">传承。</strong>Blink中的继承用<code class="eh nk nl nm nc b">extends</code>关键字表示。</p><pre class="mx my mz na fq nb nc nd ne aw nf dt"><span id="0377" class="mi kg hu nc b fv ng nh l ni nj"><strong class="nc hv">class</strong> Employee <strong class="nc hv">extends</strong> Person {<br/>}</span></pre><p id="355a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果被继承的类(超类)有一个显式的构造函数，继承类必须通过传递创建超类的对象所必需的参数来遵循超类的构造函数。</p><pre class="mx my mz na fq nb nc nd ne aw nf dt"><span id="b0bf" class="mi kg hu nc b fv ng nh l ni nj"><strong class="nc hv">class</strong> Employee<strong class="nc hv">(</strong>firstname<strong class="nc hv">: String, </strong>lastname<strong class="nc hv">: String, </strong>company<strong class="nc hv">: String)</strong> <strong class="nc hv">extends</strong> Person<strong class="nc hv">(firstname, lastname)</strong> {<br/>}</span></pre><p id="d3e8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">超驰功能。</strong><code class="eh nk nl nm nc b">override</code>修饰符用于覆盖超类中的一个函数。</p><pre class="mx my mz na fq nb nc nd ne aw nf dt"><span id="0b7d" class="mi kg hu nc b fv ng nh l ni nj"><strong class="nc hv">class</strong> Person(firstname: <strong class="nc hv">String</strong>, lastname: <strong class="nc hv">String</strong>) {<br/>    <strong class="nc hv">override</strong> <strong class="nc hv">func</strong> toString(): <strong class="nc hv">String</strong> = firstname + " " + lastname<br/>}</span></pre><p id="693e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在上面的例子中，我们覆盖了<code class="eh nk nl nm nc b">Object</code>类中可用的<code class="eh nk nl nm nc b">toString</code>。Blink中的所有类都继承自<code class="eh nk nl nm nc b">Object</code>。</p><h2 id="a487" class="mi kg hu bd kh mj mk ml kl mm mn mo kp js mp mq kt jw mr ms kx ka mt mu lb mv dt translated">定义运算符</h2><p id="403a" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">就像可以使用算术运算符<code class="eh nk nl nm nc b">+</code>、<code class="eh nk nl nm nc b">-</code>、<code class="eh nk nl nm nc b">*</code>或<code class="eh nk nl nm nc b">/</code>来执行两个或多个<code class="eh nk nl nm nc b">Int</code>之间的运算一样，Blink允许我们为自己的类定义二元运算符<code class="eh nk nl nm nc b">+</code>、<code class="eh nk nl nm nc b">-</code>、<code class="eh nk nl nm nc b">*</code>、<code class="eh nk nl nm nc b">/</code>、<code class="eh nk nl nm nc b">%</code>和一元运算符<code class="eh nk nl nm nc b">—</code>和<code class="eh nk nl nm nc b">!</code>的行为。</p><p id="4a3a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">二元运算符</strong>通过添加一个函数来定义，该函数的名称是要定义的运算符的符号。例如，让我们为类<code class="eh nk nl nm nc b">Rational</code>定义一个<code class="eh nk nl nm nc b">+</code>操作符(代表像<code class="eh nk nl nm nc b">3/4</code>这样的有理数)。</p><pre class="mx my mz na fq nb nc nd ne aw nf dt"><span id="8b81" class="mi kg hu nc b fv ng nh l ni nj"><strong class="nc hv">class</strong> Rational(num: <strong class="nc hv">Int</strong>, den: <strong class="nc hv">Int</strong>) {<br/>   <strong class="nc hv">func</strong> +(other: <strong class="nc hv">Rational</strong>): <strong class="nc hv">Rational</strong> = // ...<br/>}</span></pre><p id="eadd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">给定类型为<code class="eh nk nl nm nc b">Rational</code>的两个变量<code class="eh nk nl nm nc b">a</code>和<code class="eh nk nl nm nc b">b</code>，我们现在可以写<code class="eh nk nl nm nc b">let c: Rational = a + b</code>。Blink自动将表达式<code class="eh nk nl nm nc b">a + b</code>转换为函数调用<code class="eh nk nl nm nc b">a.+(b)</code>。</p><p id="bd3c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">一元运算符</strong>是通过添加<strong class="jj hv"> </strong>一个函数来定义的，该函数的名称以<code class="eh nk nl nm nc b">unary_</code>开头，后面跟有被定义运算符的符号。</p><pre class="mx my mz na fq nb nc nd ne aw nf dt"><span id="b3e1" class="mi kg hu nc b fv ng nh l ni nj"><strong class="nc hv">class</strong> Rational(num: <strong class="nc hv">Int</strong>, den: <strong class="nc hv">Int</strong>) {<br/>    <strong class="nc hv">func</strong> unary_-(): <strong class="nc hv">Rational</strong> = <em class="mw">new</em> <strong class="nc hv">Rational</strong>(-num, -den)<br/>}</span></pre><p id="b348" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在上面的例子中，我们在类<code class="eh nk nl nm nc b">Rational</code>上定义了一元<code class="eh nk nl nm nc b">—</code>操作符的行为。给定一个<code class="eh nk nl nm nc b">Rational</code>类型的变量<code class="eh nk nl nm nc b">a</code>，我们可以写<code class="eh nk nl nm nc b">let b: Rational = -a</code>。Blink将<em class="mw">表达式</em> <code class="eh nk nl nm nc b">-a</code>转换为函数调用<code class="eh nk nl nm nc b">a.unary_-()</code>。</p><p id="3d14" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">Blink中也支持运算符重载</strong>，这意味着可以定义多个<code class="eh nk nl nm nc b">+</code>运算符，例如，只要每个运算符函数的参数表不同。</p><p id="ca6d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">例如，对于我们的<code class="eh nk nl nm nc b">Rational</code>类，我们可能想要将2个<code class="eh nk nl nm nc b">Rational</code>加在一起，但是也想要添加一个<code class="eh nk nl nm nc b">Rational</code>和一个<code class="eh nk nl nm nc b">Int</code>。运算符重载允许我们这样做。</p><pre class="mx my mz na fq nb nc nd ne aw nf dt"><span id="5923" class="mi kg hu nc b fv ng nh l ni nj"><strong class="nc hv">class</strong> Rational(num: <strong class="nc hv">Int</strong>, den: <strong class="nc hv">Int</strong>) {<br/>   <strong class="nc hv">func</strong> +(other: <strong class="nc hv">Rational</strong>): <strong class="nc hv">Rational</strong> = // ...<br/>   <strong class="nc hv">func</strong> +(integer: <strong class="nc hv">Int</strong>): <strong class="nc hv">Rational</strong> = // ...<br/>   <strong class="nc hv">func</strong> +(double: <strong class="nc hv">Double</strong>): <strong class="nc hv">Rational</strong> = // ...<br/>}</span></pre><p id="c8bb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有了上面的例子，给定两个<code class="eh nk nl nm nc b">Rational</code>类型的变量<code class="eh nk nl nm nc b">a</code>和<code class="eh nk nl nm nc b">b</code>，我们可以写出<em class="mw">表达式</em>，像<code class="eh nk nl nm nc b">a + b</code>、<code class="eh nk nl nm nc b">a + 42</code>或<code class="eh nk nl nm nc b">b + 3.14</code>。</p><h2 id="345c" class="mi kg hu bd kh mj mk ml kl mm mn mo kp js mp mq kt jw mr ms kx ka mt mu lb mv dt translated">一切都是物体</h2><p id="3050" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">Blink里的一切都是对象。甚至像<code class="eh nk nl nm nc b">Int</code> s或<code class="eh nk nl nm nc b">Double</code> s这样的原语实际上也是对象。而像<code class="eh nk nl nm nc b">32 + 21</code>这样的算术表达式，其实就是函数调用<code class="eh nk nl nm nc b">32.+(21)</code>。这是一个很好的特性，它使我们能够在Blink中为自己的类型定义操作符。</p><h2 id="dcde" class="mi kg hu bd kh mj mk ml kl mm mn mo kp js mp mq kt jw mr ms kx ka mt mu lb mv dt translated">Blink中没有语句，只有表达式(和定义)</h2><p id="bd00" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">总结我们的Blink之旅，值得注意的是，与Java或JavaScript等其他编程语言不同，Blink中没有语句，只有<em class="mw">表达式</em>(以及函数或属性定义等定义)<em class="mw">。</em>一个<em class="mw">表达式</em>和一个语句的区别在于，一个<em class="mw">表达式</em>总是计算出一个<em class="mw">值</em>，而一个语句只是执行一些动作。</p><p id="928a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">例如，在JavaScript中，如果条件为<code class="eh nk nl nm nc b">true</code>或<code class="eh nk nl nm nc b">false</code>，则<code class="eh nk nl nm nc b">if</code>语句会执行特定的代码块。在Blink中，<code class="eh nk nl nm nc b">if</code>是一个表达式，其计算结果为一个值。</p><p id="c400" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这意味着，在眨眼之间，它是完全有效的写作</p><pre class="mx my mz na fq nb nc nd ne aw nf dt"><span id="e57a" class="mi kg hu nc b fv ng nh l ni nj"><strong class="nc hv">let</strong> isLegallyAdult = <strong class="nc hv">if</strong> (age &gt; 18) { <strong class="nc hv">true</strong> } else { <strong class="nc hv">false</strong> }</span></pre><p id="59a6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果是<code class="eh nk nl nm nc b">age &gt; 18</code>，则<code class="eh nk nl nm nc b">isLegallyAdult</code>将等于<code class="eh nk nl nm nc b">true</code>，否则将等于<code class="eh nk nl nm nc b">false</code>。</p><p id="6578" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们对Blink的快速浏览到此结束。正如你所看到的，Blink拥有表达几乎任何程序的必要概念，足够简单，可以在相对较短的时间内为它编写解释器，并且有一些有趣的特性，比如它对对象和表达式的使用。</p><p id="7353" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你已经准备好了，请阅读第二篇文章，它将给出编译器和解释器的高级概述。</p></div><div class="ab cl lw lx hc ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hn ho hp hq hr"><p id="ae77" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了更深入地了解Blink构造如何协同工作，下面是一些完整的Blink程序。</p><figure class="mx my mz na fq iv"><div class="bz el l di"><div class="no np l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">A simple Guess The Number game in Blink</figcaption></figure><figure class="mx my mz na fq iv"><div class="bz el l di"><div class="no np l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">A Fraction class in Blink</figcaption></figure><figure class="mx my mz na fq iv"><div class="bz el l di"><div class="no np l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">A simple linked list in Blink.</figcaption></figure><p id="58c9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你已经到达终点了。🎉</p><blockquote class="nq nr ns"><p id="f922" class="jh ji mw jj b jk jl jm jn jo jp jq jr nt jt ju jv nu jx jy jz nv kb kc kd ke hn dt translated">黑客中午是黑客如何开始他们的下午。我们是这个家庭的一员。我们现在<a class="ae jg" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jg" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jh ji mw jj b jk jl jm jn jo jp jq jr nt jt ju jv nu jx jy jz nv kb kc kd ke hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jg" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jg" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>