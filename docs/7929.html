<html>
<head>
<title>Keep Your UI Clean With Redux Middleware</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Redux中间件保持用户界面整洁</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/keep-your-ui-clean-with-redux-middleware-752383016c50?source=collection_archive---------12-----------------------#2017-11-13">https://medium.com/hackernoon/keep-your-ui-clean-with-redux-middleware-752383016c50?source=collection_archive---------12-----------------------#2017-11-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="bcf5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Bob叔叔开创性的<a class="ae jp" href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank"> Clean Architecture </a>帖子激励了许多软件设计师，随着JavaScript允许业务逻辑代码被重用，它变得越来越重要。从来没有借口将业务逻辑分散到整个代码库中，但是现在我们甚至可以在需要的任何地方使用<code class="eh jr js jt ju b">npm publish core-logic</code>和<code class="eh jr js jt ju b">npm install --save core-logic</code>来减少<em class="jq">和</em>。</p><p id="187e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本文以Bob叔叔定义的<strong class="it hv">用例</strong>为出发点:</p><blockquote class="jv jw jx"><p id="65f5" class="ir is jq it b iu iv iw ix iy iz ja jb jy jd je jf jz jh ji jj ka jl jm jn jo hn dt translated">这一层中的软件包含<em class="hu">应用特定的</em>业务规则。它封装并实现了系统的所有用例。这些用例编排了实体之间的数据流，并指导这些实体使用它们的<em class="hu">企业级</em>业务规则来实现用例的目标。</p></blockquote><p id="cd7b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">用例通常被描述为:</p><ul class=""><li id="afe6" class="kb kc hu it b iu iv iy iz jc kd jg ke jk kf jo kg kh ki kj dt translated">贴一张<a class="ae jp" href="http://www.findcatnames.com/wp-content/uploads/2014/09/453768-cats-cute.jpg" rel="noopener ugc nofollow" target="_blank">我可爱的猫</a>的图片；或者</li><li id="8955" class="kb kc hu it b iu kk iy kl jc km jg kn jk ko jo kg kh ki kj dt translated">获取J.R. Bookwalter制作的电影列表</li></ul><p id="8193" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，软件是混乱的，抽象是有漏洞的，如果你和我一样，你经常会发现自己在幻想失控的利维坦用例，或者你已经将逻辑编码到UI中并且不会很快删除的琐碎用例。</p><p id="6887" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面我想为大叔呈现的是一些唾手可得的水果——用中间件来浮动你的Redux应用。Redux是一个简单的JavaScript状态容器，它已经成为一种模式，在Kotlin和Swift T21的库中重现。我强烈建议你使用它——将它引入你的应用程序是微不足道的，在用redux状态工作10分钟后，你会爱上它，再也不会回头。</p><h1 id="9f9a" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">激励示例—登录屏幕</h1><p id="0c9b" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">作为一个激励性的例子，我将使用实际应用这种模式的<a class="ae jp" href="https://play.google.com/store/apps/details?id=com.meeshkan.android" rel="noopener ugc nofollow" target="_blank"> Meeshkan </a>登录屏幕。顺便说一句，整个应用程序都应用了这种模式，所以如果你想知道某些事情是如何完成的，请随意下载，四处看看，并联系我们。</p><figure class="lt lu lv lw fq lx fe ff paragraph-image"><div class="fe ff ls"><img src="../Images/d75b6fae24a77b4197b3dd0ea8c20416.png" data-original-src="https://miro.medium.com/v2/resize:fit:378/1*iULGbD1mmtfOF90CerZnRQ.gif"/></div></figure><p id="2218" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们从这个登录屏幕的简化版本开始:</p><pre class="lt lu lv lw fq ma ju mb mc aw md dt"><span id="aab5" class="me kq hu ju b fv mf mg l mh mi">// login.js<br/>import React from 'react';<br/>import { reduxForm, Field } from 'redux-form';<br/>import { connect } from 'react-redux';<br/>import { Button, MyTextComponent } from 'ui-lib';<br/>import { Text, Alert } from 'react-native';<br/>import Actions from 'react-native-router-flux';<br/>import analytics from 'analytics-lib';<br/>import { login } from 'kludgy-implementation';</span><span id="bf3b" class="me kq hu ju b fv mj mg l mh mi">const onSuccess = () =&gt; {<br/>  analytics.report('successfully logged in');<br/>  Actions.main(); // this is our navigation action<br/>}</span><span id="b194" class="me kq hu ju b fv mj mg l mh mi">const onFailure = () =&gt; {<br/>  analytics.report('log in error');<br/>  Alert.alert("Sorry...", "Something went wrong");<br/>}</span><span id="3bc0" class="me kq hu ju b fv mj mg l mh mi">const submitter = ({email, password}) =&gt;<br/>  login(email, password, onSuccess, onFailure);</span><span id="95bf" class="me kq hu ju b fv mj mg l mh mi">const LogIn = ({handleSubmit}) =&gt; (<br/>  &lt;View&gt;<br/>    &lt;Field component={MyTextComponent} name="email" /&gt;<br/>    &lt;Field component={MyTextComponent} name="password" /&gt;<br/>    &lt;Button onPress={handleSubmit(submitter)}&gt;<br/>      &lt;Text&gt;Log In&lt;/Text&gt;<br/>    &lt;/Button&gt;<br/>  &lt;/View&gt;);</span><span id="d0de" class="me kq hu ju b fv mj mg l mh mi">export default connect()(reduxForm({form: 'LogIn'})(LogIn));</span></pre><p id="40a5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种实现有几个问题:</p><ul class=""><li id="4e51" class="kb kc hu it b iu iv iy iz jc kd jg ke jk kf jo kg kh ki kj dt translated">我们的<code class="eh jr js jt ju b">login</code>函数必须冒泡到UI来接受成功和失败的回调。如果我们想改变登录过程中的步骤数量，或者添加除成功和失败之外的更多选项，该怎么办？重构厄运…</li><li id="e5a8" class="kb kc hu it b iu kk iy kl jc km jg kn jk ko jo kg kh ki kj dt translated">我们的分析函数也是如此，更糟糕的是，我们现在必须测试每个组件是否正确调用它。真是一团糟！</li><li id="44c3" class="kb kc hu it b iu kk iy kl jc km jg kn jk ko jo kg kh ki kj dt translated">我们必须记住成功和失败的顺序，以及它为什么/如何重要，在整个UI中散布逻辑，而没有任何规范告诉我们为什么会这样。</li><li id="9439" class="kb kc hu it b iu kk iy kl jc km jg kn jk ko jo kg kh ki kj dt translated">当我们想改变导航、分析或提醒库的时候，我们就要对每个UI组件进行为期一周的重构。你好微妙的代码破损。</li></ul><h1 id="d5ca" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">中间件拯救世界！</h1><p id="1504" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">让我们用中间件重写上面的例子。首先，我将直接展示我们改进后的新组件:</p><pre class="lt lu lv lw fq ma ju mb mc aw md dt"><span id="14ad" class="me kq hu ju b fv mf mg l mh mi">// login.js<br/>import React from 'react';<br/>import { reduxForm, Field } from 'redux-form';<br/>import { connect } from 'react-redux';<br/>import { Button, MyTextComponent } from 'ui-lib';<br/>import { Text} from 'react-native';<br/>import { loginAction } from 'better-implementation';<br/>import Ize, { navSuccessIze, alertIze, alertFailureIze } from 'ize';</span><span id="3b6c" class="me kq hu ju b fv mj mg l mh mi">const login = Ize(<br/>  loginAction,<br/>  navSuccessIze('main'),<br/>  analyticsIze(),<br/>  alertFailureIze("Sorry...", Something went wrong")<br/>);</span><span id="11eb" class="me kq hu ju b fv mj mg l mh mi">const LogIn = ({handleSubmit, login}) =&gt; (<br/>  &lt;View&gt;<br/>    &lt;Field component={MyTextComponent} name="email" /&gt;<br/>    &lt;Field component={MyTextComponent} name="password" /&gt;<br/>    &lt;Button onPress={handleSubmit(login)}&gt;<br/>      &lt;Text&gt;Log In&lt;/Text&gt;<br/>    &lt;/Button&gt;<br/>  &lt;/View&gt;);</span><span id="ba47" class="me kq hu ju b fv mj mg l mh mi">export default connect(null, {<br/>  login<br/>})(reduxForm({form: 'LogIn'})(LogIn));</span></pre><p id="ba94" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一些值得庆祝的理由:</p><ul class=""><li id="3ca9" class="kb kc hu it b iu iv iy iz jc kd jg ke jk kf jo kg kh ki kj dt translated">导航或分析等对库的显式调用不复存在！</li><li id="01c9" class="kb kc hu it b iu kk iy kl jc km jg kn jk ko jo kg kh ki kj dt translated">在<code class="eh jr js jt ju b">onSuccess</code>和<code class="eh jr js jt ju b">onFailure</code>回调中散布逻辑已经一去不复返了，我们无法在不触发各种副作用的情况下进行单元测试！</li><li id="8c43" class="kb kc hu it b iu kk iy kl jc km jg kn jk ko jo kg kh ki kj dt translated">这要短得多。</li><li id="f144" class="kb kc hu it b iu kk iy kl jc km jg kn jk ko jo kg kh ki kj dt translated">这更容易阅读！</li><li id="bacc" class="kb kc hu it b iu kk iy kl jc km jg kn jk ko jo kg kh ki kj dt translated">这更容易测试！</li></ul><p id="c5a2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好的，但是我们如何通过中间件实现呢？</p><h2 id="de66" class="me kq hu bd kr mk ml mm kv mn mo mp kz jc mq mr ld jg ms mt lh jk mu mv ll mw dt translated">1.通过Ize模式使用动作创建者</h2><p id="dc71" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">我们使用<code class="eh jr js jt ju b"><a class="ae jp" href="https://www.npmjs.com/package/redux-ize" rel="noopener ugc nofollow" target="_blank">redux-ize</a></code>来实现Action Creator Creator模式。基本上，所有这些<code class="eh jr js jt ju b">Ize</code>的东西都采取了行动，为中间件添加了一堆有用的元数据。</p><h2 id="208f" class="me kq hu bd kr mk ml mm kv mn mo mp kz jc mq mr ld jg ms mt lh jk mu mv ll mw dt translated">2.使用像redux saga这样的库来处理异步调用</h2><p id="4d87" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">查看<code class="eh jr js jt ju b"><a class="ae jp" href="https://redux-saga.js.org/" rel="noopener ugc nofollow" target="_blank">redux-saga</a></code>以了解如何处理我们的异步登录呼叫和调度成功或失败事件。举个例子:</p><pre class="lt lu lv lw fq ma ju mb mc aw md dt"><span id="e450" class="me kq hu ju b fv mf mg l mh mi">import { call, put } from 'redux-saga';<br/>import { loginSuccessAction, loginFailureAction } from 'actions';<br/>import Ize, { navIze, alertIze } from 'ize';</span><span id="b342" class="me kq hu ju b fv mj mg l mh mi">function* logInSideEffect({<br/>  payload: {email, password},<br/>  meta: {navSuccess, alertFailure}<br/>}) {<br/>  try {<br/>    call(login, email, password);<br/>    put(Ize(loginSuccessAction, navIze(navSuccess)));<br/>  } catch(e) {<br/>    put(Ize(loginFailureAction, alertIze(alertFailure)));<br/>  }<br/>}</span></pre><p id="a8c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意我们如何再次使用<code class="eh jr js jt ju b">ize</code>模式将<code class="eh jr js jt ju b">navSuccess</code>和<code class="eh jr js jt ju b">alertFailure</code>信息移动到正常的<code class="eh jr js jt ju b">nav</code>和<code class="eh jr js jt ju b">alert</code>轨道。这将确保当成功或失败动作被分派时，它被中间件拾取。</p><h2 id="eb6f" class="me kq hu bd kr mk ml mm kv mn mo mp kz jc mq mr ld jg ms mt lh jk mu mv ll mw dt translated">3.创建一些中间件来处理分析、导航和警报</h2><p id="5490" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">像星期天早上一样简单…</p><pre class="lt lu lv lw fq ma ju mb mc aw md dt"><span id="1d0b" class="me kq hu ju b fv mf mg l mh mi">// analytics.js<br/>import analytics from 'my-awesome-analytics-provider';</span><span id="1f1a" class="me kq hu ju b fv mj mg l mh mi">export default store =&gt; next =&gt; action =&gt; {<br/>  action.meta &amp;&amp; action.meta.analytics &amp;&amp; analytics(action.type);    <br/>  next(action);<br/>}</span><span id="40da" class="me kq hu ju b fv mj mg l mh mi">// nav.js<br/>import Actions from 'react-native-router-flux';</span><span id="ee50" class="me kq hu ju b fv mj mg l mh mi">export default store =&gt; next =&gt; action =&gt; {<br/>  action.meta &amp;&amp; action.meta.nav &amp;&amp; Actions[action.meta.nav]();  <br/>  next(action);<br/>}</span><span id="a90f" class="me kq hu ju b fv mj mg l mh mi">// alert.js<br/>import Alert from 'react-native';</span><span id="1f08" class="me kq hu ju b fv mj mg l mh mi">export default store =&gt; next =&gt; action =&gt; {<br/>  action.meta &amp;&amp;<br/>    action.meta.alert &amp;&amp;<br/>    Alert.alert(...action.meta.alert); <br/>  next(action);<br/>}</span></pre><p id="985d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们有更多的理由庆祝！</p><ul class=""><li id="b20c" class="kb kc hu it b iu iv iy iz jc kd jg ke jk kf jo kg kh ki kj dt translated">想改变你的分析提供商？没问题—两行代码。</li><li id="a8ac" class="kb kc hu it b iu kk iy kl jc km jg kn jk ko jo kg kh ki kj dt translated">想要测试您的中间件吗？没问题—在一个地方使用一个<code class="eh jr js jt ju b">sinon</code>短截线。</li><li id="e1e5" class="kb kc hu it b iu kk iy kl jc km jg kn jk ko jo kg kh ki kj dt translated">想根据应用程序的状态关闭某些导航或提醒吗？你现在可以进入商店了！</li><li id="2a05" class="kb kc hu it b iu kk iy kl jc km jg kn jk ko jo kg kh ki kj dt translated">想测试所有这些东西的顺序吗？没问题——只需编写一个测试来验证您的redux store配置。</li></ul><h1 id="22a2" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">总而言之——Redux不仅仅是一个状态容器</h1><p id="c751" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">Redux将自己标榜为“JavaScript应用的可预测状态容器”这是真的，但是有一点你会注意到，我没有提到一个将这些动作传播到一个状态的reducer。当然，这些动作<em class="jq">可以</em>绑定到一个状态，实际上通常都是这样，但是我想保持简单，这样你就可以看到中间件有多强大。</p><p id="86fe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">很容易开始使用Redux中间件(或任何中间件，如组合Rx对象转换)来处理导航、分析和警报等事情。你的应用更可预测，更少的编码工作，更容易测试，更容易阅读，最重要的是，非常干净。谁不想这样呢？谢谢鲍勃叔叔！</p><figure class="lt lu lv lw fq lx fe ff paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="fe ff mx"><img src="../Images/8aacf94a89f3457ee70d05f5e2a49b8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fZrv-rhFIvidhqeVh0cvvA.png"/></div></div></figure></div></div>    
</body>
</html>