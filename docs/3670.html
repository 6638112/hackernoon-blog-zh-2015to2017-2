<html>
<head>
<title>SICP 1.1: “The Elements of Programming”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SICP 1.1:“程序设计的要素”</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/sicp-1-1-the-elements-of-programming-e9728929e907?source=collection_archive---------7-----------------------#2017-04-16">https://medium.com/hackernoon/sicp-1-1-the-elements-of-programming-e9728929e907?source=collection_archive---------7-----------------------#2017-04-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="e4b2" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">(计算机程序的结构和解释)1.1</h2></div><p id="4458" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我的1.1习题解答也在Github这里:<a class="ae kf" href="https://github.com/bolducp/SICP/tree/master/exercises/chapter_01/1.1_exercises" rel="noopener ugc nofollow" target="_blank">https://Github . com/bold UCP/SICP/tree/master/exercises/chapter _ 01/1.1 _ exercises</a></p></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><figure class="ko kp kq kr fq ks fe ff paragraph-image"><div class="fe ff kn"><img src="../Images/7222bbdbeff34d33624f4995bb57b721.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*j3LRroc_VI6pVobVijkAMw.jpeg"/></div></figure><p id="8e85" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我喜欢第一小节的标题——“T2编程的要素”。我不确定作者是否打算引用Strunk和White的经典<em class="kv">风格的元素</em>文本，但我相信他们对原始元素、组合方法和编程中抽象手段的分析为Strunk和White描述组合艺术的方式提供了恰当的相似之处。</p><h1 id="fab1" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated">注意事项</h1><p id="87b5" class="pw-post-body-paragraph jj jk hu jl b jm lo iv jo jp lp iy jr js lq ju jv jw lr jy jz ka ls kc kd ke hn dt translated">1.1节主要是关于计算机语言如何提供概念化和结构化计算机程序的方法来实现过程。作者不可思议地将这种语言用简单的术语分解如下。</p><p id="7d1e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">“语言提供了将简单的概念组合成更复杂的概念的手段”:</p><blockquote class="lt lu lv"><p id="1c0d" class="jj jk kv jl b jm jn iv jo jp jq iy jr lw jt ju jv lx jx jy jz ly kb kc kd ke hn dt translated"><strong class="jl hv">原语表达式</strong>，表示语言所涉及的最简单的实体，</p><p id="4a23" class="jj jk kv jl b jm jn iv jo jp jq iy jr lw jt ju jv lx jx jy jz ly kb kc kd ke hn dt translated"><strong class="jl hv">组合方式</strong>，通过这种方式，复合元素由更简单的元素构建而成，以及</p><p id="e3b4" class="jj jk kv jl b jm jn iv jo jp jq iy jr lw jt ju jv lx jx jy jz ly kb kc kd ke hn dt translated"><strong class="jl hv">抽象手段</strong>，通过它可以将复合元素命名并作为单元进行操作。</p></blockquote><h2 id="bdc2" class="lz kx hu bd ky ma mb mc lc md me mf lg js mg mh li jw mi mj lk ka mk ml lm mm dt translated">程序应用模型</h2><ul class=""><li id="82c2" class="mn mo hu jl b jm lo jp lp js mp jw mq ka mr ke ms mt mu mv dt translated"><em class="kv">程序应用的替代模型</em></li><li id="ba0e" class="mn mo hu jl b jm mw jp mx js my jw mz ka na ke ms mt mu mv dt translated">应用顺序与正常顺序</li></ul><h2 id="3f94" class="lz kx hu bd ky ma mb mc lc md me mf lg js mg mh li jw mi mj lk ka mk ml lm mm dt translated">方案语法</h2><ul class=""><li id="ea41" class="mn mo hu jl b jm lo jp lp js mp jw mq ka mr ke ms mt mu mv dt translated">命名和环境—函数和变量定义</li><li id="ab2d" class="mn mo hu jl b jm mw jp mx js my jw mz ka na ke ms mt mu mv dt translated">条件表达式和谓词</li><li id="a0f0" class="mn mo hu jl b jm mw jp mx js my jw mz ka na ke ms mt mu mv dt translated">简洁明了的定义:“单词<em class="kv">谓词</em>用于返回true或false的过程，以及计算结果为true或false的表达式”</li></ul><h1 id="d3c0" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated">1.1练习</h1><p id="8b4b" class="pw-post-body-paragraph jj jk hu jl b jm lo iv jo jp lp iy jr js lq ju jv jw lr jy jz ka ls kc kd ke hn dt translated">我的答案在每个练习题下面的灰色文本块中提供。</p><h2 id="b36b" class="lz kx hu bd ky ma mb mc lc md me mf lg js mg mh li jw mi mj lk ka mk ml lm mm dt translated">练习1.1</h2><blockquote class="lt lu lv"><p id="2f76" class="jj jk kv jl b jm jn iv jo jp jq iy jr lw jt ju jv lx jx jy jz ly kb kc kd ke hn dt translated">下面是一系列的表达式。解释器响应每个表达式打印出来的结果是什么？假设序列将按照其出现的顺序进行评估。</p></blockquote><p id="fb50" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">(我的答案作为注释插入到每个表达式的右侧)</p><pre class="ko kp kq kr fq nb nc nd ne aw nf dt"><span id="be5c" class="lz kx hu nc b fv ng nh l ni nj">10                      ;10<br/>(+ 5 3 4)               ;12<br/>(- 9 1)                 ;8<br/>(/ 6 2)                 ;3<br/>(+ (* 2 4) (- 4 6))     ;6<br/>(define a 3)            ;a<br/>(define b (+ a 1))      ;b<br/>(+ a b (* a b))         ;19<br/>(= a b)                 ;#f</span><span id="dda1" class="lz kx hu nc b fv nk nh l ni nj">(if (and (&gt; b a) (&lt; b (* a b)))<br/>    b<br/>    a)                  ;4</span><span id="2b0a" class="lz kx hu nc b fv nk nh l ni nj">(cond ((= a 4) 6)<br/>      ((= b 4) (+ 6 7 a))<br/>      (else 25))        ;16</span><span id="6bef" class="lz kx hu nc b fv nk nh l ni nj">(+ 2 (if (&gt; b a) b a))  ;6<br/>(* (cond ((&gt; a b) a)<br/>         ((&lt; a b) b)<br/>         (else -1))<br/>   (+ a 1))             ;16</span></pre><h2 id="95f8" class="lz kx hu bd ky ma mb mc lc md me mf lg js mg mh li jw mi mj lk ka mk ml lm mm dt translated">练习1.2</h2><blockquote class="lt lu lv"><p id="6cc4" class="jj jk kv jl b jm jn iv jo jp jq iy jr lw jt ju jv lx jx jy jz ly kb kc kd ke hn dt translated">将下列表达式翻译成前缀形式。</p></blockquote><figure class="ko kp kq kr fq ks fe ff paragraph-image"><div class="fe ff nl"><img src="../Images/06cccb340d4878cc6eb8e5aaa8737d5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*FjI3haX-_bLUwwb4A3Y7pQ.png"/></div></figure><pre class="ko kp kq kr fq nb nc nd ne aw nf dt"><span id="a223" class="lz kx hu nc b fv ng nh l ni nj">(/ (+ 5      <br/>      4     <br/>     (- 2 (- 3 (+ 6 (/ 4 5)))))   <br/>   (* 3   <br/>     (- 6 2)     <br/>     (- 2 7)))</span></pre><h2 id="bda8" class="lz kx hu bd ky ma mb mc lc md me mf lg js mg mh li jw mi mj lk ka mk ml lm mm dt translated">练习1.3</h2><blockquote class="lt lu lv"><p id="1800" class="jj jk kv jl b jm jn iv jo jp jq iy jr lw jt ju jv lx jx jy jz ly kb kc kd ke hn dt translated">定义一个将三个数字作为参数并返回两个较大数字的平方和的过程。</p></blockquote><pre class="ko kp kq kr fq nb nc nd ne aw nf dt"><span id="3dcb" class="lz kx hu nc b fv ng nh l ni nj">(define (square x) (* x x))<br/>(define (sum-of-squares x y) (+ (square x) (square y))) <br/>(define (sum-two-largest-squares x y z)   <br/>    (if (&gt; x y)     <br/>        (if (&gt; y z) (sum-of-squares x y) (sum-of-squares x z))  <br/>    (if (&gt; x z) (sum-of-squares x y) (sum-of-squares y z))))  </span><span id="312c" class="lz kx hu nc b fv nk nh l ni nj"><br/>;; test(= 34 (sum-two-largest-squares 3 2 5))</span></pre><h2 id="3c28" class="lz kx hu bd ky ma mb mc lc md me mf lg js mg mh li jw mi mj lk ka mk ml lm mm dt translated">练习1.4</h2><blockquote class="lt lu lv"><p id="8aa9" class="jj jk kv jl b jm jn iv jo jp jq iy jr lw jt ju jv lx jx jy jz ly kb kc kd ke hn dt translated">请注意，我们的评估模型允许运算符为复合表达式的组合。使用此观察来描述以下过程的行为:</p><p id="04f5" class="jj jk kv jl b jm jn iv jo jp jq iy jr lw jt ju jv lx jx jy jz ly kb kc kd ke hn dt translated">(定义(a-加-ABS-b a b)<br/>((if(&gt;B0)+-)a b))</p></blockquote><pre class="ko kp kq kr fq nb nc nd ne aw nf dt"><span id="a993" class="lz kx hu nc b fv ng nh l ni nj">The if-statement returns either the primitive procedure - or the primitive procedure +, depending on whether b is greater than 0. This procedure is then applied to the operands a and b.</span></pre><h2 id="f71a" class="lz kx hu bd ky ma mb mc lc md me mf lg js mg mh li jw mi mj lk ka mk ml lm mm dt translated">练习1.5</h2><blockquote class="lt lu lv"><p id="da01" class="jj jk kv jl b jm jn iv jo jp jq iy jr lw jt ju jv lx jx jy jz ly kb kc kd ke hn dt translated">Ben Bitdiddle发明了一个测试来确定他面对的解释器是使用应用顺序求值还是正常顺序求值。他定义了以下两个过程:</p><p id="993b" class="jj jk kv jl b jm jn iv jo jp jq iy jr lw jt ju jv lx jx jy jz ly kb kc kd ke hn dt translated">(定义(p) (p))</p><p id="f904" class="jj jk kv jl b jm jn iv jo jp jq iy jr lw jt ju jv lx jx jy jz ly kb kc kd ke hn dt translated">(定义(测试x y) <br/> (if (= x 0) <br/> 0 <br/> y))</p><p id="aaf6" class="jj jk kv jl b jm jn iv jo jp jq iy jr lw jt ju jv lx jx jy jz ly kb kc kd ke hn dt translated">然后他对表达式求值</p><p id="4c50" class="jj jk kv jl b jm jn iv jo jp jq iy jr lw jt ju jv lx jx jy jz ly kb kc kd ke hn dt translated">(测试0 (p))</p><p id="2299" class="jj jk kv jl b jm jn iv jo jp jq iy jr lw jt ju jv lx jx jy jz ly kb kc kd ke hn dt translated">对于使用应用顺序求值的解释器，Ben会观察到什么行为？对于使用正常顺序求值的解释器，他会观察到什么行为？解释一下你的答案。(假设无论解释器使用正常顺序还是应用顺序，特殊形式<code class="eh nm nn no nc b">if</code>的求值规则都是一样的:首先对谓词表达式求值，结果决定是对结果表达式求值还是对替代表达式求值。)</p></blockquote><pre class="ko kp kq kr fq nb nc nd ne aw nf dt"><span id="86c3" class="lz kx hu nc b fv ng nh l ni nj">With applicative-order, the expression will try to evaluate all of the operands so that the procedure is fully expanded before it is reduced. Thus, it will try to evaluate p, which just calls itself in a recursive loop, and test will never end up getting invoked.</span><span id="68b9" class="lz kx hu nc b fv nk nh l ni nj">With normal order, p will never be evaluated (and thus will never have the chance to enter into its infinite loop), because the first condition of the if-statement in test (x = 0) evaluates to true and the procedure returns 0 without calling p.</span></pre><h2 id="7a0d" class="lz kx hu bd ky ma mb mc lc md me mf lg js mg mh li jw mi mj lk ka mk ml lm mm dt translated">练习1.6</h2><blockquote class="lt lu lv"><p id="9193" class="jj jk kv jl b jm jn iv jo jp jq iy jr lw jt ju jv lx jx jy jz ly kb kc kd ke hn dt translated">Alyssa P. Hacker不明白为什么需要以特殊形式提供<code class="eh nm nn no nc b">if</code>。"为什么我不能用<code class="eh nm nn no nc b">cond</code>来定义它为一个普通的程序？"她问道。Alyssa的朋友Eva Lu Ator声称这确实可以做到，她定义了一个新版本的<code class="eh nm nn no nc b">if</code>:</p><p id="ad84" class="jj jk kv jl b jm jn iv jo jp jq iy jr lw jt ju jv lx jx jy jz ly kb kc kd ke hn dt translated">(define (new-if谓词<br/>then-clause<br/>else-clause)<br/>(cond(谓词then-clause)<br/>(else-clause))</p><p id="8370" class="jj jk kv jl b jm jn iv jo jp jq iy jr lw jt ju jv lx jx jy jz ly kb kc kd ke hn dt translated">Eva为Alyssa演示了该计划:</p><p id="2a1f" class="jj jk kv jl b jm jn iv jo jp jq iy jr lw jt ju jv lx jx jy jz ly kb kc kd ke hn dt translated">(new-if(= 2 3)0 5)<br/>T13】5</p><p id="7ed5" class="jj jk kv jl b jm jn iv jo jp jq iy jr lw jt ju jv lx jx jy jz ly kb kc kd ke hn dt translated">(new-if(= 1 1)0 5)<br/>T16】0</p><p id="8698" class="jj jk kv jl b jm jn iv jo jp jq iy jr lw jt ju jv lx jx jy jz ly kb kc kd ke hn dt translated">高兴之余，艾丽莎用<code class="eh nm nn no nc b">new-if</code>重写了平方根程序:</p><p id="a6d4" class="jj jk kv jl b jm jn iv jo jp jq iy jr lw jt ju jv lx jx jy jz ly kb kc kd ke hn dt translated">(define(sqrt-ITER guess x)<br/>(new-if(足够好？猜测x) <br/>猜测<br/> (sqrt-iter(改进猜测x) x)))</p><p id="a809" class="jj jk kv jl b jm jn iv jo jp jq iy jr lw jt ju jv lx jx jy jz ly kb kc kd ke hn dt translated">当Alyssa试图用这个来计算平方根时会发生什么？解释一下。</p></blockquote><pre class="ko kp kq kr fq nb nc nd ne aw nf dt"><span id="5e29" class="lz kx hu nc b fv ng nh l ni nj">I had some trouble with this question at first, because I was missing what the question was really trying to ask. I thought that the comparison under discussion was using "cond" as opposed to "if", and this does, in fact, work:</span><span id="2510" class="lz kx hu nc b fv nk nh l ni nj">(define (sqrt x)<br/>  (sqrt-iter 1.0 x))</span><span id="54f9" class="lz kx hu nc b fv nk nh l ni nj">(define (sqrt-iter guess x)<br/>  (cond ((good-enough? guess x) guess)<br/>      (else (sqrt-iter (improve guess x)<br/>                 x))))</span><span id="c8dc" class="lz kx hu nc b fv nk nh l ni nj">(define (improve guess x)<br/>  (average guess (/ x guess)))</span><span id="2295" class="lz kx hu nc b fv nk nh l ni nj">(define (average x y)<br/>  (/ (+ x y) 2))</span><span id="b9cd" class="lz kx hu nc b fv nk nh l ni nj">(define (good-enough? guess x)<br/>  (&lt; (abs (- (square guess) x)) 0.001))</span><span id="fdc3" class="lz kx hu nc b fv nk nh l ni nj">This code above, which replaces the "if" statement with the "cond" statement in `sqrt-iter` works. </span><span id="fa87" class="lz kx hu nc b fv nk nh l ni nj">However, the question is <strong class="nc hv">actually</strong> asking about what happens when you replace the if-statement with a custom designed function, which fails because since Scheme is an <em class="kv">applicative-order</em> language, it evaluates all of the arguments as soon as a function is called. Since `new-if` is a procedure, all of its subexpressions get evaluated as soon as it is applied, before it acts upon the operands provided. This includes a call to `sqrt-izer`, which then recursively calls `new-if`, and creates an infinite loop.</span></pre><p id="6b45" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">习题1.7。</strong></p><blockquote class="lt lu lv"><p id="7536" class="jj jk kv jl b jm jn iv jo jp jq iy jr lw jt ju jv lx jx jy jz ly kb kc kd ke hn dt translated">够好了吗？计算平方根时使用的测试对于寻找非常小的数的平方根不是非常有效。此外，在真实的计算机中，算术运算几乎总是以有限的精度执行。这使得我们的测试不适用于非常大的数量。请解释这些陈述，并举例说明测试在小数字和大数字情况下是如何失败的。</p><p id="56bc" class="jj jk kv jl b jm jn iv jo jp jq iy jr lw jt ju jv lx jx jy jz ly kb kc kd ke hn dt translated">实现“足够好”的另一种策略？观察guess从一次迭代到下一次迭代是如何变化的，当变化只占guess的很小一部分时就停止。设计一个使用这种终结测试的平方根过程。这对小数字和大数字更有效吗？</p></blockquote><pre class="ko kp kq kr fq nb nc nd ne aw nf dt"><span id="0b62" class="lz kx hu nc b fv ng nh l ni nj">Here's an example of the `sqrt` function not working as well for very small numbers: (sqrt .00004) returns .03167509508023218, instead of the accurate 0.02 value. This happens because, currently, `good-enough?` returns true when the our original number and the square of our next guess have a difference of less than 0.001.</span><span id="3d85" class="lz kx hu nc b fv nk nh l ni nj">For understanding why calling our `sqrt` function on very large numbers never returns a value, I had to look for help online. It seems that this is a result of losing precision for storing very large floating point numbers. </span><span id="72f0" class="lz kx hu nc b fv nk nh l ni nj">(define (sqrt x)<br/>  (sqrt-iter 1.0 0 x))</span><span id="07de" class="lz kx hu nc b fv nk nh l ni nj">(define (sqrt-iter guess old-guess x)<br/>  (if (good-enough? guess old-guess)<br/>      guess<br/>      (sqrt-iter (improve guess x)<br/>                guess<br/>                 x)))</span><span id="f89c" class="lz kx hu nc b fv nk nh l ni nj">(define (improve guess x)<br/>  (average guess (/ x guess)))</span><span id="050c" class="lz kx hu nc b fv nk nh l ni nj">(define (average x y)<br/>  (/ (+ x y) 2))</span><span id="e540" class="lz kx hu nc b fv nk nh l ni nj">(define (good-enough? guess old-guess)<br/>  (&lt; (abs (- guess old-guess)) 0.001))</span><span id="104f" class="lz kx hu nc b fv nk nh l ni nj">(sqrt 9999999999998)<br/>(sqrt 0.001)</span><span id="de7b" class="lz kx hu nc b fv nk nh l ni nj">; Yes, this does seem to improve for both very large and very small numbers.</span></pre><p id="f4c2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">习题1.8。</strong></p><blockquote class="lt lu lv"><p id="a5fe" class="jj jk kv jl b jm jn iv jo jp jq iy jr lw jt ju jv lx jx jy jz ly kb kc kd ke hn dt translated">牛顿的立方根方法是基于这样一个事实，即如果y是x的立方根的近似值，那么更好的近似值由值给出</p><p id="1c9b" class="jj jk kv jl b jm jn iv jo jp jq iy jr lw jt ju jv lx jx jy jz ly kb kc kd ke hn dt translated">(x/y^2 +2y) / 3</p><p id="40eb" class="jj jk kv jl b jm jn iv jo jp jq iy jr lw jt ju jv lx jx jy jz ly kb kc kd ke hn dt translated">使用此公式实现类似于平方根过程的立方根过程。(在1.3.4节中，我们将看到如何实现牛顿法作为这些平方根和立方根过程的抽象。)</p></blockquote><pre class="ko kp kq kr fq nb nc nd ne aw nf dt"><span id="ddae" class="lz kx hu nc b fv ng nh l ni nj">(define (cube-root x)<br/>  (cube-root-iter 1.0 0 x))</span><span id="f59e" class="lz kx hu nc b fv nk nh l ni nj">(define (cube-root-iter guess old-guess x)<br/>  (if (good-enough? guess old-guess)<br/>      guess<br/>      (cube-root-iter (improve guess x)<br/>                guess<br/>                 x)))</span><span id="135e" class="lz kx hu nc b fv nk nh l ni nj">(define (improve guess x)<br/>  (/ (+ (/ x (square guess))<br/>        (* 2 guess))  <br/>    3))</span><span id="374c" class="lz kx hu nc b fv nk nh l ni nj">(define (square x) (* x x))</span><span id="3ddc" class="lz kx hu nc b fv nk nh l ni nj">(define (average x y)<br/>  (/ (+ x y) 2))</span><span id="b60f" class="lz kx hu nc b fv nk nh l ni nj">(define (good-enough? guess old-guess)<br/>  (&lt; (abs (- guess old-guess)) 0.001))</span><span id="1f8b" class="lz kx hu nc b fv nk nh l ni nj">(cube-root 25)</span></pre><div class="ko kp kq kr fq ab cb"><figure class="np ks nq nr ns nt nu paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="np ks nq nr ns nt nu paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="np ks nq nr ns nt nu paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="lt lu lv"><p id="f922" class="jj jk kv jl b jm jn iv jo jp jq iy jr lw jt ju jv lx jx jy jz ly kb kc kd ke hn dt translated"><a class="ae kf" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kf" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kf" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae kf" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jj jk kv jl b jm jn iv jo jp jq iy jr lw jt ju jv lx jx jy jz ly kb kc kd ke hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kf" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kf" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ko kp kq kr fq ks fe ff paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="fe ff nv"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="ko kp kq kr fq ks"><div class="bz el l di"><div class="oa ob l"/></div></figure></div></div>    
</body>
</html>