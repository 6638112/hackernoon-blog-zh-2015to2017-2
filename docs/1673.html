<html>
<head>
<title>Async / Await Warm Up</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步/等待预热</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/async-await-warm-up-229676224319?source=collection_archive---------6-----------------------#2016-11-28">https://medium.com/hackernoon/async-await-warm-up-229676224319?source=collection_archive---------6-----------------------#2016-11-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/3daed7af1949789968746d9155865fae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*taQX1-K34z3Fe7uaJILJTA.jpeg"/></div></div></figure><div class=""/><p id="af02" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你习惯于使用承诺，<a class="ae ka" href="https://hackernoon.com/tagged/async" rel="noopener ugc nofollow" target="_blank"><em class="kb">async</em></a><em class="kb">/await</em>是让你的<a class="ae ka" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> javascript </a>更易读的一种优雅方式。它评估为同步代码，但返回一个在下一个<a class="ae ka" href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" rel="noopener ugc nofollow" target="_blank">微任务</a>上执行的承诺。</p><p id="58f1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们直接跳进去四处看看。打开<a class="ae ka" href="https://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=false&amp;presets=es2015%2Cstage-3&amp;code=" rel="noopener ugc nofollow" target="_blank"> babel repl </a>和我一起编码。取一个简单的函数，并将<em class="kb">异步</em>添加到开头:</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="c812" class="kl km if kh b fv kn ko l kp kq"><strong class="kh ig">async function sayHello() {<br/> return 'hello';<br/>}</strong></span><span id="8517" class="kl km if kh b fv kr ko l kp kq"><strong class="kh ig">console.log(sayHello()); </strong>// =&gt; Promise {}</span></pre><p id="ed41" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您将看到调用这个函数返回一个<em class="kb">承诺</em>而不是“hello”。这是因为从一个<em class="kb">异步</em>函数返回的任何东西都被自动包装在一个承诺中。为了记录“你好”，我们可以这样做:</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="eb97" class="kl km if kh b fv kn ko l kp kq"><strong class="kh ig">sayHello()<br/>  .then(str =&gt; console.log(str))</strong> <em class="kb">// =&gt; 'hello'</em></span></pre><h2 id="4755" class="kl km if bd ks kt ku kv kw kx ky kz la jn lb lc ld jr le lf lg jv lh li lj lk dt translated">好吧，那等待呢？</h2><p id="f4b8" class="pw-post-body-paragraph jc jd if je b jf ll jh ji jj lm jl jm jn ln jp jq jr lo jt ju jv lp jx jy jz hn dt translated">首先，编写一个返回承诺的函数:</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="4804" class="kl km if kh b fv kn ko l kp kq"><strong class="kh ig">function mapLater(arr, fn, time) {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    setTimeout(() =&gt; {<br/>      resolve(arr.map(fn));<br/>    }, time);<br/>  });<br/>}</strong></span></pre><p id="6318" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">很简单，我们在给定的时间后映射一个数组。现在让我们在一个<em class="kb">异步</em>函数中使用它。</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="5bf8" class="kl km if kh b fv kn ko l kp kq"><strong class="kh ig">async function addAndMultiply(arr) {<br/>  const added = await mapLater(arr, i =&gt; i + 2, 2000);<br/>  const multiplied = await mapLater(added, i =&gt; i * 2, 2000);<br/>  <br/>  console.log(multiplied);<br/>}</strong></span><span id="28ab" class="kl km if kh b fv kr ko l kp kq"><strong class="kh ig">addAndMultiply([1, 3, 6, 20]); </strong><em class="kb"><br/></em><strong class="kh ig">console.log('hello')</strong></span><span id="4207" class="kl km if kh b fv kr ko l kp kq"><em class="kb">// =&gt; </em>'hello'<em class="kb"><br/>// 4 secs later =&gt; </em>[6, 10, 16, 44]</span></pre><p id="f25f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们返回数组之前，您会看到记录了“hello”。我们的<em class="kb">异步</em>函数是非阻塞的。</p><p id="342d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">需要注意的是<em class="kb">等待</em>必须总是在<em class="kb">异步</em>闭包内。在全局范围内或在没有async关键字的函数中调用它将引发错误。</p><h2 id="6c82" class="kl km if bd ks kt ku kv kw kx ky kz la jn lb lc ld jr le lf lg jv lh li lj lk dt translated">处理错误</h2><p id="13c4" class="pw-post-body-paragraph jc jd if je b jf ll jh ji jj lm jl jm jn ln jp jq jr lo jt ju jv lp jx jy jz hn dt translated">想象一下我们最初的<em class="kb"> mapLater </em>功能出了问题:</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="1e22" class="kl km if kh b fv kn ko l kp kq">...<br/>setTimeout(() =&gt; {<br/><strong class="kh ig">  reject('nope');</strong><br/>}, time);</span></pre><p id="4a6f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">目前，我们没有办法暴露我们的async <em class="kb"> addAndMultiply </em>函数中的错误。当我们运行它的时候，函数会无声地失败。为了处理错误，一个解决方案是使用<em class="kb"> try / catch </em>:</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="6216" class="kl km if kh b fv kn ko l kp kq">async function addAndMultiply(arr) {<br/><strong class="kh ig">  try {<br/></strong>    const added = await mapLater(arr, i =&gt; i + 2, 2000);<br/>    const multiplied = await mapLater(added, i =&gt; i * 2, 2000);<br/>    console.log(multiplied); <br/><strong class="kh ig">  } catch(err) {<br/></strong>    <strong class="kh ig">console.error(err);</strong> <em class="kb">// 2 secs later =&gt; 'nope'</em><br/><strong class="kh ig">  }<br/></strong>}</span></pre><p id="4e57" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为默认情况下会出现错误，所以另一个实用的解决方案是在异步入口点处理错误:</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="f4e9" class="kl km if kh b fv kn ko l kp kq">intricatelyNestedAsyncFunc().catch(err =&gt; console.error(err));</span></pre><h2 id="4d14" class="kl km if bd ks kt ku kv kw kx ky kz la jn lb lc ld jr le lf lg jv lh li lj lk dt translated">现实世界</h2><p id="26e5" class="pw-post-body-paragraph jc jd if je b jf ll jh ji jj lm jl jm jn ln jp jq jr lo jt ju jv lp jx jy jz hn dt translated">今天就用吧！如此多伟大的库提供了返回承诺的API。例如，如果您正在使用<a class="ae ka" href="https://github.com/github/fetch" rel="noopener ugc nofollow" target="_blank"> <em class="kb">获取</em> </a>来检索数据，您可以开始这样做:</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="d61b" class="kl km if kh b fv kn ko l kp kq">async function getProfileData(id) {<br/>  try {<br/><strong class="kh ig">    const users = await getUser(id);</strong><br/>    ...  <br/>  } catch {<br/>    ...<br/>  }<br/>}</span></pre><p id="96f0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要使用<em class="kb">async/await</em>now<em class="kb"/>你需要使用Babel的<a class="ae ka" href="https://babeljs.io/docs/plugins/transform-async-to-generator/" rel="noopener ugc nofollow" target="_blank"><em class="kb">transform-async-to-generator</em></a>。</p><figure class="kc kd ke kf fq hw"><div class="bz el l di"><div class="lq lr l"/></div></figure></div></div>    
</body>
</html>