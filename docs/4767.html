<html>
<head>
<title>The 3 Tenets of Service Objects in Ruby on Rails</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby on Rails中服务对象的三个原则</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-3-tenets-of-service-objects-c936b891b3c2?source=collection_archive---------3-----------------------#2017-06-21">https://medium.com/hackernoon/the-3-tenets-of-service-objects-c936b891b3c2?source=collection_archive---------3-----------------------#2017-06-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/aa320538f8a141ceb2ad215a623a8cf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O7sLvXQf2osB6RX1turdmw.png"/></div></div></figure><p id="ce86" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">服务对象正在成为精简控制器和模型的工具带中的一个主要部分。欢迎来到脂肪服务的世界[文件夹]！对那些可能不知道服务对象是什么的人进行快速复习…</p><p id="d1c5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">服务对象是一个PORO(普通的老式Ruby对象)，意在将业务对象分解成可管理的类和方法。在不深入讨论可靠的OOP原则以及它们如何应用于Ruby的情况下，一个服务对象应该有一个单一的职责，易于测试，以及其他一些我将进一步深入讨论的方面。</p><p id="aafd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这可能背离了过去的Rails设计原则。以前，您可能会直接向您的“胖”模型添加另一种方法，或者最近向mixin或模型关注点添加逻辑。虽然这可能有助于代码分离，但我发现它并没有使服务对象可以执行的活动变得简单、有组织和容易发现。此外，当它们被“混合”到模型类中时，模型仍然会变大，并将所有东西都绑定到模型类中。</p></div><div class="ab cl ka kb hc kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hn ho hp hq hr"><p id="0f46" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意:这篇文章是对我即将出版的书<a class="ae kh" href="https://buildasaasappinrails.com" rel="noopener ugc nofollow" target="_blank">在Rails 6 </a>中构建一个SaaS应用的服务对象章节的评论。这本书指导你从卑微的开始，通过部署一个应用到生产。这本书现在已经开始预售了，你可以马上拿到免费的一章！</p><p id="fe3d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另外，我的新项目<a class="ae kh" href="https://pullmanager.com" rel="noopener ugc nofollow" target="_blank">的测试版已经发布了。如果你失去了对拉取请求的跟踪，让旧的请求留在身边，或者只是喜欢一个通过多个服务(Github、Gitlab和Bitbucket)聚集这些请求的仪表板，</a><a class="ae kh" href="https://pullmanager.com" rel="noopener ugc nofollow" target="_blank">查看一下</a>。</p></div><div class="ab cl ka kb hc kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hn ho hp hq hr"><h1 id="03a1" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">所以…一个服务对象？</h1><p id="0732" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">在深入研究服务对象之前，最好先讨论一下服务对象的名称。事实上，我最近在Reddit、Twitter等网站上越来越多地看到这种情况。</p><p id="db71" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里有几个选择。其中最大的一个是使用名称“<strong class="je hv"> Operations </strong>”，这个名称取自TrailBlazer框架(位于Rails框架之上)。</p><p id="1b64" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我见过的另一种方法是称它们为对象，并从类名、文件夹等中完全删除服务。</p><p id="de8d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就我个人而言，我不介意服务对象的名称，我觉得它描述了类/对象的目的是执行一个动作或服务的事实。然而，操作紧随其后，因为它以类似的方式描述服务对象。尽管如此，不打破当前服务对象的一些最佳实践是坚持“服务”的一个足够好的理由。</p><h1 id="5c84" class="ki kj hu bd kk kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf dt translated">原则1:尽最大努力只拥有一个公共方法。</h1><p id="6b5c" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">就我个人而言，我觉得这与课程的SRP密切相关。如果类/对象只负责一件事，那么应该只有一个公共方法使对象提供单一的服务操作。一个公共方法约束最常用的方法是<code class="eh lq lr ls lt b">.call</code>。</p><p id="0688" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，虽然这是服务对象最佳实践的最一致的方面之一，但是服务对象实例化的方法可以分为两大类。</p><p id="afe1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先:</p><pre class="lu lv lw lx fq ly lt lz ma aw mb dt"><span id="9b04" class="mc kj hu lt b fv md me l mf mg">#services/thing_service.rb<br/>class ThingService<br/>  <br/>  def initialize(param1)<br/>    @param1 = param1<br/>  end</span><span id="fcd7" class="mc kj hu lt b fv mh me l mf mg">  def call<br/>    private_method<br/>  end</span><span id="bf82" class="mc kj hu lt b fv mh me l mf mg">  private<br/>  attr_reader :param1</span><span id="aecf" class="mc kj hu lt b fv mh me l mf mg">...<br/>end</span><span id="2f56" class="mc kj hu lt b fv mh me l mf mg">### and calling by ThingService.new(param1).call</span></pre><p id="4ef0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">或者二:</p><pre class="lu lv lw lx fq ly lt lz ma aw mb dt"><span id="ccca" class="mc kj hu lt b fv md me l mf mg">#services/thing_service.rb<br/>class ThingService<br/>  </span><span id="0a45" class="mc kj hu lt b fv mh me l mf mg">  def self.call(param1)<br/>    new(param1).call<br/>  end<br/>  <br/>  def call<br/>    private_method<br/>  end</span><span id="146a" class="mc kj hu lt b fv mh me l mf mg">  private</span><span id="3e22" class="mc kj hu lt b fv mh me l mf mg">  def initialize(param1)<br/>    @param1 = param1<br/>  end</span><span id="e217" class="mc kj hu lt b fv mh me l mf mg">  <br/>  attr_reader :param1</span><span id="bb35" class="mc kj hu lt b fv mh me l mf mg">...<br/>end</span><span id="157c" class="mc kj hu lt b fv mh me l mf mg">### and calling by ThingService.call(param1)</span></pre><p id="2661" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就个人而言，我更倾向于第一种方式，因为它符合经验和大多数其他Ruby开发人员创建POROs的经验。然而，第二种方法在调用时会更简洁，可读性更强。</p><p id="0ab2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里的主要思想是，您正在努力将您的对象限制为一个公共方法，该方法将在整个应用程序(主要是控制器)中被调用。</p><p id="714d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个或最少的公共方法的额外好处是，您将更容易重构服务对象，并且通常不需要在整个应用程序中更改太多的服务对象调用。</p><h1 id="67e0" class="ki kj hu bd kk kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf dt translated">原则2:管理依赖关系可能很难。私下做，最好。</h1><p id="8102" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">在最简单的服务对象之外，几乎不可能不包含另一个依赖的服务对象。那么包含它们的最佳方式是什么呢？</p><p id="319c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">可能想到的一种方法是实例化对象并将它们作为参数包含进来。这种方法虽然可行，但很可能会导致重构问题和在许多地方更改方法签名。</p><p id="b542" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一种方法是在服务对象的公共方法或主私有方法(如果有的话)中实例化依赖服务。虽然这更好，但是它开始分解一个方法的SRP。它使该方法直接负责并了解依赖关系。</p><p id="c54e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">根据我的经验，这里最好的方法是创建一个私有方法，该方法将返回注入依赖的一个记忆版本。这里有一个例子:</p><pre class="lu lv lw lx fq ly lt lz ma aw mb dt"><span id="2975" class="mc kj hu lt b fv md me l mf mg">#services/thing_service.rb<br/>class ThingService<br/>  <br/>  def initialize(param1)<br/>    @param1 = param1<br/>  end</span><span id="c415" class="mc kj hu lt b fv mh me l mf mg">  def call<br/>    result = other_service.call<br/>    private_method(result)<br/>  end</span><span id="e3b6" class="mc kj hu lt b fv mh me l mf mg">  private<br/>  attr_reader :param1</span><span id="5a3d" class="mc kj hu lt b fv mh me l mf mg">  def other_service<br/>    @other_service ||= OtherService.new(param1)<br/>  end</span><span id="3867" class="mc kj hu lt b fv mh me l mf mg">...<br/>end</span></pre><p id="b314" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然与其他依赖注入方法相比，这并不是一个巨大的变化，但这可以使您在重构时更容易地更改公共方法，因为它不再直接负责另一个服务的实例化。</p><h1 id="2f5f" class="ki kj hu bd kk kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf dt translated">原则3返回有意义的东西。一个物体。</h1><p id="3fa1" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">虽然您的直觉是返回一个布尔值作为服务对象的结果，但这可能不是您的最佳选择。是的，Rails中的默认习语是运行ActiveRecord更新/创建的条件关闭，从长远来看，一个丰富的响应对象将会带来好处。</p><p id="2e97" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这么想吧。一个服务对象不仅仅有两种结果。1.成功。2.失败。3.未处理的异常。仅仅在布尔响应中处理这样的结果会对您的服务造成损害。</p><p id="990f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当更深入地研究这些结果时，就更有理由使用响应对象了。让我们以<em class="mi">成功</em>为例。首先，一个结果对象可以包含一个<code class="eh lq lr ls lt b">success?</code>谓词方法来处理控制器响应的条件分支，等等。此外，因为它是您自己的响应对象，所以您可以随意命名成功/失败方法。如果<code class="eh lq lr ls lt b">signed_up? </code>更有意义，那就像在你的对象中定义它一样简单。</p><p id="f512" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">服务对象也可能有一组甚至多组数据作为响应。假设您正在创建一个信用卡处理服务。您可能需要记录来自处理器的多个不同的令牌，或者要向用户显示的其他数据集。如果没有某种响应对象，这可能会很麻烦。</p><p id="856b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在让我们看看服务对象失败和异常的后两种结果。乍一看，似乎很简单。只需将任何一个结果设为falsey，并强制某种错误/失败浏览器响应。然而，这可能无法向最终用户或开发人员提供完整的意图或上下文。假设由于表单中缺少数据而触发了一个异常。该异常可以被挽救，通过结果对象设置或传递消息，并用于在浏览器中正确地通知最终用户。现在，有了来自响应对象的一点点信息，您就有了一个更有意义的请求/响应周期。比你仅仅从一个<code class="eh lq lr ls lt b">true</code>或者<code class="eh lq lr ls lt b">false</code>那里得到的还要多。</p><p id="ae99" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那么，如何使用响应对象呢？最简单的用法通常是使用Ruby库中的<code class="eh lq lr ls lt b">Struct</code>或<code class="eh lq lr ls lt b">OpenStruct</code>。</p><pre class="lu lv lw lx fq ly lt lz ma aw mb dt"><span id="4ad0" class="mc kj hu lt b fv md me l mf mg">#services/thing_service.rb<br/>class ThingService<br/>  <br/>  def initialize(param1)<br/>    @param1 = param1<br/>  end</span><span id="c46d" class="mc kj hu lt b fv mh me l mf mg">  def call<br/>    private_method<br/>  end</span><span id="0bda" class="mc kj hu lt b fv mh me l mf mg">  private<br/>  attr_reader :param1</span><span id="000c" class="mc kj hu lt b fv mh me l mf mg">  def private_method<br/>    things = do_something(param1)<br/>  rescue SomeSpecificException =&gt; exception<br/>    OpenStruct(success?: false, things: nil, error: exception.message)<br/>  else<br/>    OpenStruct(success?: true, things: thingserror: nil)<br/>  end<br/>end</span></pre><p id="41fe" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然这是一个非常模糊的例子，但您应该能够明白这里的意思。除了结构之外，您甚至可以创建自己的响应类/对象，或者使用一些漂亮的宝石来很好地包装响应/结果对象功能。如果我走那条路线，我的一个go to gems是<a class="ae kh" href="https://github.com/github/github-ds/" rel="noopener ugc nofollow" target="_blank"> Github::DS gem </a>，它有一个Github::Result对象。</p><h1 id="b86a" class="ki kj hu bd kk kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf dt translated">还有什么？</h1><p id="9317" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">虽然这些是我认为服务对象的三个主要必须做的部分，但是还可以有其他方法来使它们变得更好。</p><p id="8cb8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">其中之一是尝试将类方法限制到绝对最小，并允许服务对象作为实例化对象工作。这看起来很简单，甚至可能消耗更多的内存，但是在允许服务对象作为实例工作时会有更大的灵活性。这可能会让你以后不再头疼。</p><p id="960e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一个技巧可能是用非常功能化的方法来考虑服务对象。在函数式编程中，你把方法看做更多的输入/输出方法。参数进去，值出来。在“服务对象领域”中，这应该解释为，您应该将简单的参数作为响应对象的一部分传入，并将简单的值作为响应对象的一部分传出。它不是纯功能性的，但是它应该有助于降低您的服务对象开销。</p></div><div class="ab cl ka kb hc kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hn ho hp hq hr"><p id="c9dc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你有什么一直遵循的服务对象的信条吗？请分享！</p><div class="lu lv lw lx fq ab cb"><figure class="mj iv mk ml mm mn mo paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mj iv mk ml mm mn mo paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mj iv mk ml mm mn mo paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mp mq mr"><p id="f922" class="jc jd mi je b jf jg jh ji jj jk jl jm ms jo jp jq mt js jt ju mu jw jx jy jz hn dt translated"><a class="ae kh" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kh" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kh" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae kh" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd mi je b jf jg jh ji jj jk jl jm ms jo jp jq mt js jt ju mu jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kh" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kh" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lu lv lw lx fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mv"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>