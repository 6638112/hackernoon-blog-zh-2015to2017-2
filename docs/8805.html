<html>
<head>
<title>Crossing Over to Web3–02 Smart Contracts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">过渡到web 3–02智能合同</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/crossing-over-to-web3-02-smart-contracts-d93b898b4b9?source=collection_archive---------12-----------------------#2017-12-15">https://medium.com/hackernoon/crossing-over-to-web3-02-smart-contracts-d93b898b4b9?source=collection_archive---------12-----------------------#2017-12-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="1296" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">从web2到web3的最终开发者指南第2期</h2></div><blockquote class="jj jk jl"><p id="f56e" class="jm jn jo jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">最初作为JAAK的<a class="ae kj" href="https://blog.jaak.io/" rel="noopener ugc nofollow" target="_blank">开发博客系列</a>的一部分发布</p></blockquote><h2 id="0d32" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt">🙌</h2><p id="1159" class="pw-post-body-paragraph jm jn hu jp b jq li iv js jt lj iy jv kv lk jy jz kz ll kc kd ld lm kg kh ki hn dt translated"><em class="jo">欢迎回到博客系列文章，该系列文章旨在让web开发者以最简单的方式</em><strong class="jp hv"><em class="jo"/></strong><em class="jo">在以太坊上构建去中心化的应用和智能合约。</em></p><p id="75d7" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated"><em class="jo">如果你错过了第一期——</em><a class="ae kj" href="https://hackernoon.com/crossing-over-to-web3-an-introduction-to-decentralised-development-5eb09e95edb0" rel="noopener ugc nofollow" target="_blank"><em class="jo">时光倒流读一读</em> </a> <em class="jo">。这第二期将是所有关于写以太坊智能合同，伴随着一个例子项目。</em></p></div><div class="ab cl ln lo hc lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hn ho hp hq hr"><h1 id="13d7" class="lu kl hu bd km lv lw lx kq ly lz ma ku ja mb jb ky jd mc je lc jg md jh lg me dt translated">什么是智能合同？</h1><p id="5b8d" class="pw-post-body-paragraph jm jn hu jp b jq li iv js jt lj iy jv kv lk jy jz kz ll kc kd ld lm kg kh ki hn dt translated">如本系列第一期所述:</p><blockquote class="jj jk jl"><p id="e499" class="jm jn jo jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">以太坊环境中的智能合约是在全球公共节点网络(EVM(以太坊虚拟机))上执行的脚本，可以从/向区块链读取/写入交易。</p></blockquote><p id="002d" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated"><strong class="jp hv"> <em class="jo">合同</em> </strong>是“双方或多方之间的自愿安排”(<a class="ae kj" href="https://en.wikipedia.org/wiki/Contract" rel="noopener ugc nofollow" target="_blank">维基百科</a>)。</p><p id="1eb2" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">那么，<strong class="jp hv"> <em class="jo">智能合同</em> </strong>就是“一种旨在促进、核实或执行合同谈判或履行的计算机协议”(<a class="ae kj" href="https://en.wikipedia.org/wiki/Smart_contract" rel="noopener ugc nofollow" target="_blank">维基百科</a>)。</p><p id="d6b4" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">早在90年代，密码学家Nick Szabo就首次提出了智能合约的概念，并在许多基于加密货币的项目中发挥了重要作用，最著名的是以太坊。</p><blockquote class="jj jk jl"><p id="042f" class="jm jn jo jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">智能合约的原始祖先是不起眼的自动售货机。在有限的潜在损失金额内(钱柜中的金额应小于违反该机制的成本)，该机器接收硬币，并通过一个简单的机制，根据显示的价格分配零钱和产品。</p></blockquote><p id="bfb2" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">因此，将我们的定义扩展到以太坊的上下文之外:<strong class="jp hv">智能契约可以用于以编程方式和<em class="jo">自主地</em>执行协议</strong>。这当然意味着取消集中的中介机构。因此在分散软件中是有用的。</p><h1 id="ce41" class="lu kl hu bd km lv mf lx kq ly mg ma ku ja mh jb ky jd mi je lc jg mj jh lg me dt translated">设置</h1><p id="91b6" class="pw-post-body-paragraph jm jn hu jp b jq li iv js jt lj iy jv kv lk jy jz kz ll kc kd ld lm kg kh ki hn dt translated">事不宜迟，继续获取示例项目代码库:</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="d373" class="kk kl hu mp b fv mt mu l mv mw">git clone <a class="ae kj" href="https://github.com/lukehedger/todoeth.git" rel="noopener ugc nofollow" target="_blank">https://github.com/lukehedger/todoeth.git</a><br/>cd todoeth<br/>git checkout issue#2-smart-contracts</span></pre><p id="2222" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">我们将看看<strong class="jp hv">一个加密经济激励的待办事项列表</strong>——姑且称之为<strong class="jp hv">待办事项</strong>🤑。在接下来的两个问题中，我们将开始构建一个待办事项应用程序，它将迫使用户完成他们的待办事项，并有可能失去他们的钱！</p><figure class="mk ml mm mn fq my fe ff paragraph-image"><div class="fe ff mx"><img src="../Images/18b64028101cbf484da55e4005a7f989.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*f-YOYC8RydzefkChuEaCgg.png"/></div><figcaption class="nb nc fg fe ff nd ne bd b be z ek">Wireframe for Todoeth. Icon by <a class="ae kj" href="https://thenounproject.com/charlenehea/" rel="noopener ugc nofollow" target="_blank">Hea Poh Lin</a>.</figcaption></figure><p id="6731" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">运行以下命令来安装项目的依赖项，然后我们将开始智能合同开发:</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="9353" class="kk kl hu mp b fv mt mu l mv mw">npm install</span></pre><blockquote class="nf"><p id="18ef" class="ng nh hu bd ni nj nk nl nm nn no ki ek translated">让我们看看智能合同开发的各个阶段</p></blockquote><h1 id="3940" class="lu kl hu bd km lv mf lx kq ly mg ma ku ja np jb ky jd nq je lc jg nr jh lg me dt translated">设计</h1><p id="7ed6" class="pw-post-body-paragraph jm jn hu jp b jq li iv js jt lj iy jv kv lk jy jz kz ll kc kd ld lm kg kh ki hn dt translated">每一个健壮的程序都从一个清晰完整的架构设计开始，这在撰写智能合同时尤为重要。鉴于以太坊区块链合约的不可更改性，必须考虑所有可能发生的情况。</p><p id="34cb" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">在客户机-服务器web应用程序中，当发现一个bug时，我们可以简单地(！)将一个补丁部署到生产服务器上，所有将来访问我们网站的人都会收到这个补丁。以太坊上永久的、可验证的、防篡改的数据记录不能简单地以这种方式升级——否则，所有这些记录都将丢失！</p><p id="321b" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">设计可升级合同系统的关键是<strong class="jp hv">将存储合同与代理合同</strong>分开(我们稍后将更详细地讨论这一点)。</p><p id="8f8b" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">我们的分散式todo应用程序需要三个契约:</p><ul class=""><li id="4a92" class="ns nt hu jp b jq jr jt ju kv nu kz nv ld nw ki nx ny nz oa dt translated">存储每个用户及其待办事项的主存储合同</li><li id="74e0" class="ns nt hu jp b jq ob jt oc kv od kz oe ld of ki nx ny nz oa dt translated">跟踪针对todos的存款的二级存储合同</li><li id="c05e" class="ns nt hu jp b jq ob jt oc kv od kz oe ld of ki nx ny nz oa dt translated">一个代理契约，用于促进来自web应用程序的交互</li></ul><h1 id="3127" class="lu kl hu bd km lv mf lx kq ly mg ma ku ja mh jb ky jd mi je lc jg mj jh lg me dt translated">写</h1><blockquote class="jj jk jl"><p id="e739" class="jm jn jo jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">关于<strong class="jp hv">可靠性</strong>的说明:虽然有几种语言可以编写以太坊智能合约，但我们将使用可靠性来编写我们的合约，因为它是目前使用最广泛的。我们将使用0.4.18版本，这是撰写本文时最新的稳定版本。有针对<a class="ae kj" href="https://atom.io/packages/language-ethereum" rel="noopener ugc nofollow" target="_blank"> Atom </a>和<a class="ae kj" href="https://packagecontrol.io/packages/Ethereum" rel="noopener ugc nofollow" target="_blank"> Sublime </a>的语法高亮器。</p></blockquote><p id="1f68" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">让我们从无处不在的“Hello，World”的例子开始，但是，我们不是问候整个世界，我们只是向调用该函数的人问好:</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="cc27" class="kk kl hu mp b fv mt mu l mv mw">pragma solidity ^0.4.18;</span><span id="0043" class="kk kl hu mp b fv og mu l mv mw">// import './SomeContract.sol';</span><span id="9d01" class="kk kl hu mp b fv og mu l mv mw">contract HelloYou {<br/>  event Hello(address you);<br/>  <br/>  function sayHello() public {<br/>    address _person = msg.sender;<br/>    <br/>    Hello(_person);<br/>  }<br/>}</span></pre><p id="8bf3" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">契约顶部的<strong class="jp hv">杂注</strong>只是一个<a class="ae kj" href="https://en.wikipedia.org/wiki/Directive_(programming)" rel="noopener ugc nofollow" target="_blank">指令</a>，告诉Solidity编译器使用哪个版本。</p><p id="5987" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">该契约没有任何导入，但如果有，我们将使用相对文件路径在pragma下定义这些导入。</p><p id="cac6" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">接下来是<strong class="jp hv">合同申报</strong>。要声明一个契约，可以在契约的名称中使用<code class="eh oh oi oj mp b">contract</code>关键字，在本例中为“HelloYou”。</p><p id="cbf9" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">该契约由一个<strong class="jp hv">事件</strong>和一个<strong class="jp hv">功能</strong>组成。事件只是用关键字<code class="eh oh oi oj mp b">event</code>和函数签名声明:事件名和带括号的类型化参数。在上面的例子中，事件被称为“Hello”并接受一个类型为“address”的参数“you”(<code class="eh oh oi oj mp b">address</code>只是Solidity中描述以太坊公共地址的一个特殊类型)。</p><blockquote class="jj jk jl"><p id="7a57" class="jm jn jo jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">关于<strong class="jp hv">类型</strong>的说明:与JavaScript(动态类型)不同，Solidity是一种静态类型的语言，因此必须指定每个变量的类型。如果您一直在使用Typescript或Flow编写JavaScript(或者使用其他静态类型的语言)，那么您会感觉很舒服。不然你很快就会习惯的。</p></blockquote><p id="227e" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated"><code class="eh oh oi oj mp b">sayHello</code>函数使用Solidity的一个<a class="ae kj" href="https://solidity.readthedocs.io/en/develop/units-and-global-variables.html" rel="noopener ugc nofollow" target="_blank">全局名称空间变量</a> <code class="eh oh oi oj mp b">msg.sender</code>。这个值和其他有用的值对所有契约方法都可用。<code class="eh oh oi oj mp b">msg.sender</code>变量(也许，可以预见)包含消息发送者的以太坊地址。因此，我们将该值存储在<code class="eh oh oi oj mp b">_person</code>变量中(不需要<code class="eh oh oi oj mp b">var</code>关键字，只需要类型、名称和<code class="eh oh oi oj mp b">=</code>)，并将其传递给<code class="eh oh oi oj mp b">Hello</code>事件，该事件将触发EVM上的事件。</p><p id="dbd8" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">就是这样！我们刚刚通过智能合约向某人问好。可以在web应用程序中调用这个函数并监听事件，但我们将把它留到下一期讨论！正如古老的以太坊谚语所说:<em class="jo">“如果没有人听，EVM上的事件会发出声音吗？”</em>。</p><h2 id="4582" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">模式</h2><p id="3deb" class="pw-post-body-paragraph jm jn hu jp b jq li iv js jt lj iy jv kv lk jy jz kz ll kc kd ld lm kg kh ki hn dt translated">如前所述，我们必须以一种能够在不丢失数据的情况下进行<strong class="jp hv">代码升级的方式来构建我们的契约。这是通过将包含永久状态(数据存储在契约中的任何时候)的代码与代理分离来实现的，代理将数据汇集到这些契约中以供外部来源使用，如web应用程序。存储合同可以非常简单，并且服务于不太可能需要升级的单一目的。我们将在几段时间内详细了解存储合同。</strong></p><figure class="mk ml mm mn fq my fe ff paragraph-image"><div class="fe ff mx"><img src="../Images/3cb123f661870ea6996038d2f361d994.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*ZgBBLn9qHfayrS5nRpIqNg.png"/></div><figcaption class="nb nc fg fe ff nd ne bd b be z ek">Data flow for adding a new todo</figcaption></figure><p id="9854" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated"><code class="eh oh oi oj mp b"><strong class="jp hv">Todo.sol</strong></code></p><p id="8ac9" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated"><code class="eh oh oi oj mp b">Todo</code>合同是我们的存储合同的“代理”,也是唯一将向我们的web应用程序公开的合同。它不会存储任何数据。这样，<strong class="jp hv">所有操作都通过此合同</strong>进行，任何升级都不会丢失数据。</p><p id="1342" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">它有三种方法:</p><ul class=""><li id="3a38" class="ns nt hu jp b jq jr jt ju kv nu kz nv ld nw ki nx ny nz oa dt translated"><code class="eh oh oi oj mp b">addTodo(todoId)</code>将todo ID与作为用户ID的<code class="eh oh oi oj mp b">msg.sender</code>一起传递给<code class="eh oh oi oj mp b">TodoStorage</code>合同，并将<code class="eh oh oi oj mp b">msg.value</code>(一些令牌)作为存款金额传递给<code class="eh oh oi oj mp b">TodoBank</code>合同</li><li id="e4d7" class="ns nt hu jp b jq ob jt oc kv od kz oe ld of ki nx ny nz oa dt translated"><code class="eh oh oi oj mp b">getTodo(index)</code>通过用户的todo数组中的索引从<code class="eh oh oi oj mp b">TodoStorage</code>契约中获取todo</li><li id="f47a" class="ns nt hu jp b jq ob jt oc kv od kz oe ld of ki nx ny nz oa dt translated"><code class="eh oh oi oj mp b">getTodoCount()</code>获取用户存储的待办事项数量</li></ul><p id="95b8" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">从存储中检索todo分为两个方法的原因是由于当前的可靠性限制，限制了动态大小值的返回，如数组。因此，我们首先必须获得todos数组的长度，然后通过索引分别获得每个todo🙈。不用担心，这个限制将在下一个小版本<code class="eh oh oi oj mp b">0.5.0</code>中被移除。</p><h2 id="3650" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">储存；储备</h2><p id="60a7" class="pw-post-body-paragraph jm jn hu jp b jq li iv js jt lj iy jv kv lk jy jz kz ll kc kd ld lm kg kh ki hn dt translated">智能合约可以用来在以太坊区块链上存储不可变的、可验证的数据。这是一个超级强大的工具，可以用来实现一系列有趣的数字交易和协议形式。</p><p id="7102" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">在我们的todo示例中，我们将永久存储对每个任务的引用！我们还将针对每个todo存储一些Ether(以太坊的本地令牌)。</p><blockquote class="jj jk jl"><p id="4b81" class="jm jn jo jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">关于<strong class="jp hv">元数据存储</strong>的一个注意事项:在以太坊上存储数据是故意昂贵的，因为涉及到持久性和计算能力。针对这一限制，出现了许多创新的解决方案。我们将在这里采用的一种常见模式是将元数据存储在分布式存储系统中(如<a class="ae kj" href="http://swarm-gateways.net/bzz:/theswarm.eth/" rel="noopener ugc nofollow" target="_blank"> Swarm </a>或<a class="ae kj" href="https://ipfs.io/" rel="noopener ugc nofollow" target="_blank"> IPFS </a>)，并将对元数据的引用存储在以太坊上。我们将在下一期讨论如何做到这一点。</p></blockquote><p id="8e20" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated"><code class="eh oh oi oj mp b"><strong class="jp hv">TodoStorage.sol</strong></code></p><p id="9d6c" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated"><code class="eh oh oi oj mp b">TodoStorage</code>契约只包含获取和设置todos的方法。关于todo的元数据将存储在Swarm上，因此，我们实际存储在合同中的唯一数据将是对该元数据的Swarm引用(在Swarm网络中找到数据的地址)。</p><p id="8f2c" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">我们将使用这些引用作为<code class="eh oh oi oj mp b">todoId</code>，它们存储在一个数组中，并由<code class="eh oh oi oj mp b">TodoStore</code>对象中的<code class="eh oh oi oj mp b">userId</code>(todo所有者的以太坊地址)作为键。</p><p id="289b" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">这给了我们一个这样的数据结构:</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="be3b" class="kk kl hu mp b fv mt mu l mv mw">TodoStore: {<br/>  userId: [<br/>    todoId<br/>  ]<br/>}</span></pre><p id="c17f" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated"><code class="eh oh oi oj mp b"><strong class="jp hv">TodoBank.sol</strong></code></p><p id="2332" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">另一个用于存储的合同是<code class="eh oh oi oj mp b">TodoBank</code>。这是我们存放每笔托多存款的地方——资金将在这里得到保护，直到它们被合法提取。同样，这个契约只包含获取和设置存款的方法。</p><p id="6717" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">数据结构如下所示:</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="7968" class="kk kl hu mp b fv mt mu l mv mw">TodoVault: {<br/>  todoId: deposit<br/>}</span></pre><p id="c92f" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">这超出了本例的范围，但是您可以看到如何将激励机制构建到这个系统中。例如，如果todo在某个时间完成，存款将返回到所有者的地址，但如果错过了截止日期，资金将被发送到另一个地址，该地址可能打赌所有者不会完成它！</p><p id="11a9" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">因此，您必须完成待办事项，否则将面临存款损失💸。我们将把这篇文章留到以后发表！</p><h2 id="5383" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">安全性</h2><p id="7672" class="pw-post-body-paragraph jm jn hu jp b jq li iv js jt lj iy jv kv lk jy jz kz ll kc kd ld lm kg kh ki hn dt translated">当涉及到个人数据和资金时，软件安全至关重要。鉴于智能合约固有的经济本质，以及用于编写智能合约的语言的不成熟性，它们的安全性尤为重要——安全机制必须构建到合约的设计和代码中。</p><p id="60b5" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">在对可靠性进行实验的同时，记住这一点就足够了，并且要意识到契约可能面临的一些攻击。当你准备钻研安全问题时，<a class="ae kj" href="https://consensys.github.io/smart-contract-best-practices/" rel="noopener ugc nofollow" target="_blank">以太坊智能合约安全最佳实践</a>指南是一个很好的资源。</p><h2 id="6ce7" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">林挺</h2><p id="380e" class="pw-post-body-paragraph jm jn hu jp b jq li iv js jt lj iy jv kv lk jy jz kz ll kc kd ld lm kg kh ki hn dt translated">你可以用<a class="ae kj" href="https://github.com/duaraghav8/Solium" rel="noopener ugc nofollow" target="_blank">sol ium</a>lint你的合同，这是一个遵循类似ESLint惯例的整洁工具。</p><p id="1e67" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">要lint示例项目中的合同，请运行以下命令:</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="5c38" class="kk kl hu mp b fv mt mu l mv mw">npm run lint</span></pre><h2 id="637c" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">证明文件</h2><p id="0c31" class="pw-post-body-paragraph jm jn hu jp b jq li iv js jt lj iy jv kv lk jy jz kz ll kc kd ld lm kg kh ki hn dt translated">Solidity契约可以用<a class="ae kj" href="https://github.com/ethereum/wiki/wiki/Ethereum-Natural-Specification-Format" rel="noopener ugc nofollow" target="_blank">以太坊自然规范格式</a>(或者，NatSpec)的注释进行文档化，类似于JSDoc。</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="8fcf" class="kk kl hu mp b fv mt mu l mv mw">/*<br/> * <a class="ae kj" href="http://twitter.com/notice" rel="noopener ugc nofollow" target="_blank">@notice</a> TodoAdded event<br/> * <a class="ae kj" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {bytes32} todoId<br/> */<br/>event TodoAdded(bytes32 todoId);</span></pre><h1 id="1582" class="lu kl hu bd km lv mf lx kq ly mg ma ku ja mh jb ky jd mi je lc jg mj jh lg me dt translated">编制</h1><p id="f233" class="pw-post-body-paragraph jm jn hu jp b jq li iv js jt lj iy jv kv lk jy jz kz ll kc kd ld lm kg kh ki hn dt translated">契约需要用Solidity编译器<strong class="jp hv">编译成EVM可以读取的字节码</strong>。</p><p id="0273" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">可以通过一个名为<code class="eh oh oi oj mp b"><a class="ae kj" href="https://github.com/ethereum/solc-js" rel="noopener ugc nofollow" target="_blank">solc-js</a></code>的JavaScript工具直接使用Solidity编译器，该工具由以太坊基金会开发人员维护。</p><p id="5331" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">编译器接受一个契约名称和该契约的字符串化内容的对象，<a class="ae kj" href="https://solidity.readthedocs.io/en/develop/using-the-compiler.html#output-description" rel="noopener ugc nofollow" target="_blank">返回编译后的字节码</a>和<a class="ae kj" href="https://solidity.readthedocs.io/en/develop/abi-spec.html" rel="noopener ugc nofollow" target="_blank">一个用于与契约代码交互的接口，称为ABI </a>(或者，应用程序二进制接口)。</p><p id="9500" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">我发现可以通过将重复的任务(解析合同输入并将输出写到磁盘)抽象到一个库中，并用一个配置文件控制输入/输出，来简化这个工作流。这个工具叫做<a class="ae kj" href="https://github.com/lukehedger/sulk" rel="noopener ugc nofollow" target="_blank"><strong class="jp hv"/></a><strong class="jp hv"/>😂！</p><p id="0c25" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">Sulk采用一个简单的配置文件，最简单的形式如下:</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="13e8" class="kk kl hu mp b fv mt mu l mv mw">module.exports = {<br/>  contracts: [<br/>    'Todo',<br/>  ],<br/>  inputPath: './path/to/contracts',<br/>}</span></pre><p id="f20e" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">并将一个<code class="eh oh oi oj mp b"><a class="ae kj" href="https://github.com/lukehedger/todoeth/blob/issue%232-smart-contracts/contracts/contracts.json" rel="noopener ugc nofollow" target="_blank">contracts.json</a></code>文件写入您的项目，该文件包含字节码和ABI，可以在“部署”您的合同时使用。</p><p id="99e5" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">要编译示例项目中的协定，请运行以下命令:</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="b560" class="kk kl hu mp b fv mt mu l mv mw">npm run compile</span></pre><h1 id="aa23" class="lu kl hu bd km lv mf lx kq ly mg ma ku ja mh jb ky jd mi je lc jg mj jh lg me dt translated">部署</h1><p id="1054" class="pw-post-body-paragraph jm jn hu jp b jq li iv js jt lj iy jv kv lk jy jz kz ll kc kd ld lm kg kh ki hn dt translated">为了公开你的契约及其方法，你需要<strong class="jp hv">将它部署到以太坊区块链</strong>。这类似于将微服务部署到服务器上，与服务器基础设施一样，以太坊有生产、开发和本地网络的概念。生产网络(显然只有一个)通常被称为“mainnet ”,而开发网络(有几个，每个都有不同的属性和功能)被称为“testnets”。</p><p id="9f5f" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">开始与您的合同交互的最简单方法是将其部署到本地以太网。<code class="eh oh oi oj mp b"><a class="ae kj" href="https://github.com/trufflesuite/ganache-cli" rel="noopener ugc nofollow" target="_blank"><strong class="jp hv">ganache-cli</strong></a></code>(以前称为<code class="eh oh oi oj mp b">testrpc</code>)是一个基于Node.js的“以太坊开发个人区块链”，它简化了这个过程。</p><p id="29d7" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">从示例项目中，您可以运行下面的命令，它只是运行本地安装的<code class="eh oh oi oj mp b">ganache-cli</code>二进制文件，没有任何参数(并且<strong class="jp hv">让您感觉像神一样</strong>):</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="16be" class="kk kl hu mp b fv mt mu l mv mw">npm run <!-- -->blockchain</span></pre><p id="e5be" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">一旦<code class="eh oh oi oj mp b">ganache</code>运行，您就可以使用示例项目中包含的部署脚本将契约部署到本地以太坊节点:</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="43b9" class="kk kl hu mp b fv mt mu l mv mw">npm run deploy</span></pre><p id="5dc9" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated"><a class="ae kj" href="https://github.com/lukehedger/todoeth/blob/issue%232-smart-contracts/scripts/deploy-contracts.js" rel="noopener ugc nofollow" target="_blank">部署脚本</a>使用<a class="ae kj" href="https://github.com/ethereum/web3.js" rel="noopener ugc nofollow" target="_blank"> <strong class="jp hv"> Web3.js </strong> </a>库与以太坊节点进行交互。通读代码和注释，查看部署契约所需的步骤。请关注这一领域，寻找简化这一过程的工具👀。</p><blockquote class="jj jk jl"><p id="1ccd" class="jm jn jo jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">关于<strong class="jp hv"> Web3.js </strong>的一个说明:Web3.js库由以太坊基金会维护，并且已经成为流行的库，但是还有其他库，例如<a class="ae kj" href="https://github.com/L4ventures/ethers.js" rel="noopener ugc nofollow" target="_blank"> ethers.js </a>和<a class="ae kj" href="https://github.com/ethjs/ethjs" rel="noopener ugc nofollow" target="_blank"> ethjs </a>，当您使用这个栈时，它们是值得探索的。</p></blockquote><p id="2b6e" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">部署脚本还将把<strong class="jp hv">部署的契约地址</strong>存储在一个JSON文件中，以备后用(<code class="eh oh oi oj mp b"><a class="ae kj" href="https://github.com/lukehedger/todoeth/blob/issue%232-smart-contracts/contracts/addresses.json" rel="noopener ugc nofollow" target="_blank">addresses.json</a></code>)。每个部署的契约都有一个以太坊地址(就像一个API有一个HTTP端点一样)，当实例化契约以通过测试和应用程序与它们交互时，需要这些地址。</p><h2 id="e6ce" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">气体</h2><p id="3452" class="pw-post-body-paragraph jm jn hu jp b jq li iv js jt lj iy jv kv lk jy jz kz ll kc kd ld lm kg kh ki hn dt translated">您可能听说过术语“gas ”,或者注意到在部署脚本和示例代码中提到了它。<strong class="jp hv">气简单来说就是以太坊运营收取的交易费</strong>；EVM的燃料。最终，需要gas来防止虚拟机的过度使用。</p><blockquote class="jj jk jl"><p id="7d4c" class="jm jn jo jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">气体:大致相当于计算步骤的度量。每笔交易都必须包括一个汽油限额和愿意支付的费用。如果事务产生的计算使用的gas总数小于或等于gas限制，则事务处理。如果总气体量超过气体量限制，则所有更改都将恢复。</p></blockquote><p id="09a9" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated"><a class="ae kj" href="https://github.com/ethereum/wiki/blob/master/Glossary.md" rel="noopener ugc nofollow" target="_blank">https://github.com/ethereum/wiki/blob/master/Glossary.md</a></p><h1 id="c4f7" class="lu kl hu bd km lv mf lx kq ly mg ma ku ja mh jb ky jd mi je lc jg mj jh lg me dt translated">试验</h1><p id="0d49" class="pw-post-body-paragraph jm jn hu jp b jq li iv js jt lj iy jv kv lk jy jz kz ll kc kd ld lm kg kh ki hn dt translated">用JavaScript编写智能契约单元测试是可能的。然而，这带来了一个开销，对于习惯于为传统的客户机-服务器应用程序编写单元测试的开发人员来说，这似乎是违反直觉的:必须运行一个本地以太坊节点来执行来自JavaScript测试的契约方法。</p><p id="55a2" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">围绕模拟或存根网络响应的工具(如<a class="ae kj" href="http://sinonjs.org/" rel="noopener ugc nofollow" target="_blank"> Sinon。JS【以太坊的T2】会很棒，而且肯定会随着需求的增加而发展——Go和Python已经有了这样的工具。但是现在，我们必须打破单元测试的基本规则，触发网络活动。</a></p><p id="67af" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">示例项目测试可以通过以下方式运行:</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="c285" class="kk kl hu mp b fv mt mu l mv mw">npm test</span></pre><p id="bea7" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated"><strong class="jp hv">我们将在下一期</strong>中详细探讨如何从web应用程序中与智能合约交互，但现在你可以通读测试，了解如何使用Web3.js执行合约方法</p><h1 id="5550" class="lu kl hu bd km lv mf lx kq ly mg ma ku ja mh jb ky jd mi je lc jg mj jh lg me dt translated">调试</h1><p id="b0d8" class="pw-post-body-paragraph jm jn hu jp b jq li iv js jt lj iy jv kv lk jy jz kz ll kc kd ld lm kg kh ki hn dt translated">更新合同代码、编译、部署和运行单元测试的过程过于繁琐，不利于有效的调试。因此，为了调试，你可以使用<strong class="jp hv"> Remix </strong>，一个用于编写、编译、部署和执行方法的web IDE。</p><p id="9a97" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">还有一个名为<code class="eh oh oi oj mp b">remixd</code>的CLI工具，可以用来与Remix IDE共享您的本地合同。该示例项目包含一个启用该功能的命令，然后单击🔗Remix工具栏中的按钮进行连接:</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="8824" class="kk kl hu mp b fv mt mu l mv mw">npm run remix</span></pre><p id="4b8d" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">你也可以从这个要点中<a class="ae kj" href="https://gist.github.com/lukehedger/8e0169c74080f44c3752568a03d51f15" rel="noopener ugc nofollow" target="_blank">加载合同到Remix中。</a></p></div><div class="ab cl ln lo hc lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hn ho hp hq hr"><h2 id="f070" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">下次…</h2><p id="7884" class="pw-post-body-paragraph jm jn hu jp b jq li iv js jt lj iy jv kv lk jy jz kz ll kc kd ld lm kg kh ki hn dt translated">我们将介绍如何构建一个与todo智能合约交互的分散式web应用程序。</p></div><div class="ab cl ln lo hc lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hn ho hp hq hr"><h2 id="6909" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">一些进一步的阅读</h2><ul class=""><li id="6817" class="ns nt hu jp b jq li jt lj kv ok kz ol ld om ki nx ny nz oa dt translated">📖<a class="ae kj" href="http://solidity.readthedocs.io/en/develop/introduction-to-smart-contracts.html" rel="noopener ugc nofollow" target="_blank">正式的可靠性文件</a></li><li id="3609" class="ns nt hu jp b jq ob jt oc kv od kz oe ld of ki nx ny nz oa dt translated">🏊<a class="ae kj" href="https://github.com/androlo/solidity-workshop" rel="noopener ugc nofollow" target="_blank">更深入地了解可靠性</a></li><li id="26af" class="ns nt hu jp b jq ob jt oc kv od kz oe ld of ki nx ny nz oa dt translated">🏪<a class="ae kj" rel="noopener" href="/@robhitchens/solidity-crud-part-1-824ffa69509a">固体污垢</a></li><li id="57e7" class="ns nt hu jp b jq ob jt oc kv od kz oe ld of ki nx ny nz oa dt translated">☝️ <a class="ae kj" href="https://blog.colony.io/writing-upgradeable-contracts-in-solidity-6743f0eecc88" rel="noopener ugc nofollow" target="_blank">撰写可升级合同</a></li></ul></div><div class="ab cl ln lo hc lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hn ho hp hq hr"><h2 id="847f" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">项目更新</h2><p id="22ea" class="pw-post-body-paragraph jm jn hu jp b jq li iv js jt lj iy jv kv lk jy jz kz ll kc kd ld lm kg kh ki hn dt translated">由热衷于去中心化应用程序的人运营的项目的一个令人敬畏的副产品是绝大多数代码是开源的。这是一个在回购中挖掘灵感和最佳实践的绝佳机会——更不用说贡献了！</p><p id="21fc" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated">在JAAK，我们正在构建<a class="ae kj" href="https://github.com/meta-network/docs" rel="noopener ugc nofollow" target="_blank">元网络和协议</a>，目前正在<a class="ae kj" href="https://cointelegraph.com/news/jaak-announces-meta-decentralized-network-backed-by-ethereum-and-swarm" rel="noopener ugc nofollow" target="_blank">的私有alpha </a>中进行试点，用来自我们行业合作伙伴的数据填充网络。花一个<a class="ae kj" href="https://github.com/meta-network" rel="noopener ugc nofollow" target="_blank">看看我们的代码</a>并跳到我们的<a class="ae kj" href="https://community.meta-network.io/" rel="noopener ugc nofollow" target="_blank">松弛频道</a>来谈论你发现的任何事情！</p><h2 id="816e" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">在<a class="ae kj" href="https://twitter.com/jaak_io" rel="noopener ugc nofollow" target="_blank">推特</a>和<a class="ae kj" href="https://www.facebook.com/JAAK.io/" rel="noopener ugc nofollow" target="_blank">脸书</a>上找到<a class="ae kj" href="https://jaak.io" rel="noopener ugc nofollow" target="_blank">美国</a>。</h2></div><div class="ab cl ln lo hc lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hn ho hp hq hr"><p id="0478" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kv jx jy jz kz kb kc kd ld kf kg kh ki hn dt translated"><em class="jo">原载于2017年11月27日</em><a class="ae kj" href="https://blog.jaak.io/crossing-over-to-web3-smart-contracts-3a295e35e5c0" rel="noopener ugc nofollow" target="_blank"><em class="jo">blog . jaak . io</em></a><em class="jo">。</em></p></div></div>    
</body>
</html>