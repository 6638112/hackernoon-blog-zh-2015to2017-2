<html>
<head>
<title>Docker as Build Environment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker作为构建环境</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/docker-as-build-environment-50d6797e2e7a?source=collection_archive---------11-----------------------#2017-09-30">https://medium.com/hackernoon/docker-as-build-environment-50d6797e2e7a?source=collection_archive---------11-----------------------#2017-09-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="9f00" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我想说明一下<a class="ae jp" href="https://hackernoon.com/tagged/docker" rel="noopener ugc nofollow" target="_blank"> Docker </a>作为构建<a class="ae jp" href="https://hackernoon.com/tagged/enviroment" rel="noopener ugc nofollow" target="_blank">环境</a>在大型遗留应用程序中经常被忽略的角色，这些应用程序必须定期维护和扩展。特别是，我想强调Docker在构建过程中的作用。</p><p id="3dba" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我看来，这一点没有得到应有的重视，因为Docker由于提高了生产率而越来越多地用于运行应用程序。</p><h1 id="d230" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">构建工具</h1><p id="f6e7" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">每一项主要技术都有一套构建工具，可以围绕实际编码自动执行任务，比如下载依赖项、编译或捆绑。一般来说，你有一个主要的构建工具，它提供了工作流和执行特定任务的插件。</p><p id="d2cb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在项目开始时，开发人员自己安装构建工具没有问题。这些工具只是一些不需要任何定制的程序。比如Java给你gradle或者maven之类的选择。NET主要是MSBuild，而JavaScript webpack或gulp。</p><h1 id="41cf" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">构建工具如何成为构建环境</h1><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="fe ff kt"><img src="../Images/826a1864fa33f765c5681e70c3eab858.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JddJIcTK7GVcayf4.jpg"/></div></div><figcaption class="lf lg fg fe ff lh li bd b be z ek">Complicated Build Environment</figcaption></figure><p id="c7e7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">随着时间的推移，这种简单性会发生变化，因为您的构建工具已经到了不能简单地将其定义为工具的地步。推动这一转变的两个主要原因是:</p><ul class=""><li id="31b9" class="lj lk hu it b iu iv iy iz jc ll jg lm jk ln jo lo lp lq lr dt translated">复杂性增加</li><li id="5daf" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">传统技术</li></ul><p id="24ca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">随着您添加新工具、定制现有工具、更改操作系统设置等等，事情会变得更加复杂。此外，您将面临无法找到现有工具来自动化的任务，因此您必须自己编写。</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="fe ff kt"><img src="../Images/607bcb7c8a4e9db697a922e59cb9a97a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kd_rrOZccSE_EsjI.jpg"/></div></div><figcaption class="lf lg fg fe ff lh li bd b be z ek">Outdated Technology</figcaption></figure><p id="e539" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当一个应用程序成功运行多年时，它很有可能会经历几代技术的兴衰。通常，应用程序的某些部分——以及构建工具——是基于过时的技术，因为移植整个应用程序并不总是可能的。</p><p id="a016" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最初的几个程序变得越来越复杂，并使用不同的技术，直到它演变成一个工具的集合——甚至是黑客——我称之为构建环境。</p><h1 id="dfa9" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">将环境构建为问题孩子</h1><p id="bc83" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">构建环境一旦被安装到开发人员的机器上，就很难改变。开发人员只是很高兴它能工作，并遵循“永远不要改变一个运行中的系统”的原则，根本不会去碰它。</p><p id="067a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">毫无疑问，随着时间的推移，关于每个工具的知识会逐渐消失，并且不会进行维护。</p><p id="7710" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最终，这阻碍了新技术的采用。</p><p id="8ab8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">应该允许专业软件开发人员建立他们自己的开发环境。通过这种方式，你鼓励他们尝试新事物和创新。然而，最终，构建环境变得如此复杂，以至于每个开发人员都需要一个虚拟机的副本，或者通过Ansible之类的配置管理工具来设置机器。</p><p id="33af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是你应该意识到事情不对劲的时刻。</p><h1 id="cd1d" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">在Docker中运行构建环境</h1><p id="9717" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">正如我们已经看到的，构建工具因为复杂性和遗留性而增长。它们最终处于一个难以维护和扩展的构建环境中。它甚至会导致对开发环境的严重限制，减少开发人员的行动自由。</p><p id="0721" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是Docker出场的时刻。它允许我们将完整的应用程序放入容器中，我们可以在任何安装了Docker运行时的机器上执行这些应用程序。这消除了重复的管理任务，如配置和安装。</p><p id="8531" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">整个构建环境可以打包到一个Docker容器(Dockerfile)中，完整的安装和配置必须在其中进行。粗略地说，Docker文件是在创建Docker映像期间执行的命令的集合。这迫使我们完全自动化我们的构建环境，因为手动任务是不可能的。</p><p id="7661" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">基于Docker的方法保证每个开发人员都有相同的构建环境，这对于您的CI也是如此。不存在由不同版本的bug引起的“在我的机器上工作综合症”的可能性。此外，Docker容器可以在每个开发人员的机器上立即启动。通过添加使用适当参数运行容器的shell脚本，新开发人员甚至可以在第一天就开始开发代码库。</p><h1 id="6f41" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">Docker构建环境提高了生产率</h1><p id="07d0" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">当然Docker不能去除复杂性和遗留的负担，但是它让事情变得更简单。</p><p id="c2a2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">容器没有启动时间，所以执行会立即开始。这使得容器化比VirtualBox、VMware等虚拟映像更快，也比物理机器快得多。</p><p id="242d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以重用现有的配置管理工具，如Ansible或Puppet，并且由于Dockerfile处于版本控制中，您可以毫不费力地尝试新事物。</p><p id="2afc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于开发者体验也有巨大的改善。Docker与主机系统共享目录的能力让我们的开发人员可以使用他们想要的任何IDE，因为现代IDE已经配备了Docker支持。不需要同步源文件，他们只需编写他们习惯的代码并触发构建的创建。</p><p id="b9fa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您的技术允许通过网络进行调试(Java允许)，那么Docker也可以这样做。下图显示了Java相关场景的原理。</p><h1 id="7279" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">陈列柜</h1><p id="8098" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">因为每个构建环境都有自己的特点，所以我只展示了一个运行Spring并使用ant作为构建工具的应用程序的极简示例。这个星座可以追溯到2004年。</p><p id="d648" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我让你去想象构建环境是如何在这么长的时间内进化的。我的主要意图是给出一个抓住大意的起点。</p><p id="3a9c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">完整的项目可以在<a class="ae jp" href="https://github.com/rainerhahnekamp/docker-build-environment" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。请注意，Dockerfile使用17.06 CE版本中引入的新的多阶段构建功能:</p><pre class="ku kv kw kx fq lx ly lz ma aw mb dt"><span id="aa13" class="mc jr hu ly b fv md me l mf mg">FROM java:6 as builder<br/>ADD . /data RUN wget <a class="ae jp" href="http://archive.apache.org/dist/ant/binaries/apache-ant-1.6.3-bin.tar.bz2" rel="noopener ugc nofollow" target="_blank">http://archive.apache.org/dist/ant/binaries/apache-ant-1.6.3-bin.tar.bz2</a><br/>RUN tar xfj apache-ant-1.6.3-bin.tar.bz2<br/>RUN /apache-ant-1.6.3/bin/ant -buildfile data/build.xml jar </span><span id="11aa" class="mc jr hu ly b fv mh me l mf mg">FROM java:6 <br/>COPY — from=builder /data/build/legacy.jar /legacy.jar <br/>CMD [“java”, “-jar”, “/legacy.jar”]<br/>RUN wget <a class="ae jp" href="http://archive.apache.org/dist/ant/binaries/apache-ant-1.6.3-bin.tar.bz2" rel="noopener ugc nofollow" target="_blank">http://archive.apache.org/dist/ant/binaries/apache-ant-1.6.3-bin.tar.bz2</a><br/>RUN tar xfj apache-ant-1.6.3-bin.tar.bz2<br/>RUN /apache-ant-1.6.3/bin/ant -buildfile data/build.xml jar<br/>COPY — from=builder /data/build/legacy.jar /legacy.jar<br/>`CMD [“java”, “-jar”, “/legacy.jar”]</span></pre><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="fe ff mi"><img src="../Images/30528a3bee5784b40d559cf9e76f3a1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6REgsjx5whsUJt7i9ba5dw.png"/></div></div></figure><h1 id="4d94" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">进一步阅读</h1><ul class=""><li id="bbc8" class="lj lk hu it b iu ko iy kp jc mj jg mk jk ml jo lo lp lq lr dt translated">https://blog.alexellis.io/mutli-stage-docker-builds/<a class="ae jp" href="https://blog.alexellis.io/mutli-stage-docker-builds/" rel="noopener ugc nofollow" target="_blank"/></li><li id="e362" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">【https://blog.docker.com/2017/07/multi-stage-builds/ T4】</li><li id="8d2b" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated"><a class="ae jp" href="https://docs.docker.com/engine/userguide/eng-image/multistage-build/#name-your-build-stages" rel="noopener ugc nofollow" target="_blank">https://docs . docker . com/engine/user guide/eng-image/stage-build/# name-your-build-stages</a></li><li id="5ec5" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated"><a class="ae jp" href="https://www.rainerhahnekamp.com/en/single-instance-ecs-setup/" rel="noopener ugc nofollow" target="_blank">https://www . rainerhanekamp . com/en/single-instance-ECS-setup/</a></li></ul></div><div class="ab cl mm mn hc mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hn ho hp hq hr"><p id="7c09" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="mt">原载于2017年9月30日www.rainerhahnekamp.com</em><a class="ae jp" href="https://www.rainerhahnekamp.com/en/docker-build-environment/" rel="noopener ugc nofollow" target="_blank"><em class="mt"/></a><em class="mt">。</em></p><figure class="ku kv kw kx fq ky"><div class="bz el l di"><div class="mu mv l"/></div></figure></div></div>    
</body>
</html>