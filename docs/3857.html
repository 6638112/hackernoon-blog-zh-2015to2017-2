<html>
<head>
<title>A Test Is As Good As Its Ability To Fail When It Needs To</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个测试的好坏取决于它在必要时失败的能力</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-test-is-as-good-as-its-ability-to-fail-when-it-needs-to-b4b8f212119a?source=collection_archive---------3-----------------------#2017-04-27">https://medium.com/hackernoon/a-test-is-as-good-as-its-ability-to-fail-when-it-needs-to-b4b8f212119a?source=collection_archive---------3-----------------------#2017-04-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="bacf" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">有时仅仅编写测试是不够的</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/2b27fc3ed4067c56d766b8dbfceb4d7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qDimiQygBNBOQZ2cgopIJg.jpeg"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">The picture of a notebook and a female hand writing something on it</figcaption></figure><p id="127b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">有一种组织内部测试代码的模式叫做<a class="ae kv" href="http://wiki.c2.com/?ArrangeActAssert" rel="noopener ugc nofollow" target="_blank"> Arrange Act Assert </a> (AAA)。其结构是:</p><blockquote class="kw kx ky"><p id="6b03" class="jz ka kz kb b kc kd iv ke kf kg iy kh la kj kk kl lb kn ko kp lc kr ks kt ku hn dt translated">1.<strong class="kb hv">安排</strong>所有必要的前提条件和输入。</p><p id="511a" class="jz ka kz kb b kc kd iv ke kf kg iy kh la kj kk kl lb kn ko kp lc kr ks kt ku hn dt translated">2.<strong class="kb hv">对<a class="ae kv" href="https://hackernoon.com/tagged/test" rel="noopener ugc nofollow" target="_blank">测试</a>下的对象或方法进行</strong>动作。</p><p id="1757" class="jz ka kz kb b kc kd iv ke kf kg iy kh la kj kk kl lb kn ko kp lc kr ks kt ku hn dt translated">3.<strong class="kb hv">断言</strong>预期的结果已经出现。</p><p id="f6f3" class="jz ka kz kb b kc kd iv ke kf kg iy kh la kj kk kl lb kn ko kp lc kr ks kt ku hn dt translated">—从<a class="ae kv" href="http://wiki.c2.com/" rel="noopener ugc nofollow" target="_blank">wiki.c2.com</a>安排动作断言定义</p></blockquote><p id="3269" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">假设我们想测试一个组件。假设我们使用测试驱动的方法和基于组件的架构，实现可能是这样的:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ld le l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><a class="ae kv" href="https://jsfiddle.net/qegb2xan/10/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/qegb2xan/10/</a></figcaption></figure><p id="0bc9" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">默认情况下，模型是打开的，因为这个测试只是为了确保我们创建了一些东西并添加到DOM中。现在让我们创建一个测试，它将驱动我们创建关闭它的功能:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ld le l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><a class="ae kv" href="https://jsfiddle.net/wotyLkLw/6/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/wotyLkLw/6/</a></figcaption></figure><p id="801f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这个失败的测试迫使我们创建关闭模态的功能。让我们使用一个使用<code class="eh lf lg lh li b">display</code>来显示/隐藏内容的<code class="eh lf lg lh li b">.active</code>类来构建它(参见<code class="eh lf lg lh li b">compiledComponent</code>函数):</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ld le l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><a class="ae kv" href="https://jsfiddle.net/e6bvt39b/7/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/e6bvt39b/7/</a></figcaption></figure><p id="f6e3" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">但是我们只能在事件发生时打开模态，它不应该默认对用户打开。让我们编辑现有的测试，以便默认情况下不打开模态(参见测试<code class="eh lf lg lh li b">the modal is NOT open by default</code>上的更改):</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ld le l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><a class="ae kv" href="https://jsfiddle.net/1ytcfx1s/4/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/1ytcfx1s/4/</a></figcaption></figure><p id="6c0f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在问题来了:在开发模型的某个时候，我们很可能犯了一个错误，从DOM中删除了关闭模型的按钮。这将破坏功能，我们预计至少会有一个测试失败(见<code class="eh lf lg lh li b">compiledComponent</code>功能，按钮已被移除):</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ld le l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><a class="ae kv" href="https://jsfiddle.net/8braft4t/3/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/8braft4t/3/</a></figcaption></figure><p id="3807" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">然而，没有测试失败。</p><p id="0e3a" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这是因为默认情况下，jQuery API不会为不存在的元素抛出任何东西。它会自动失败，并且不会将目标元素添加到jQuery集合中。因为我们正在检查模态是关闭的，并且默认情况下是关闭的，所以测试永远不会失败，即使代码被破坏。</p><pre class="jk jl jm jn fq lj li lk ll aw lm dt"><span id="6536" class="ln lo hu li b fv lp lq l lr ls">// This doesn't break, it just runs and do nothing<br/>$('.modal').find('.close').click();</span></pre><p id="cd83" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如果我们有一个在元素不存在的情况下失败的API，那么在测试中就不会有假阳性:</p><pre class="jk jl jm jn fq lj li lk ll aw lm dt"><span id="3b82" class="ln lo hu li b fv lp lq l lr ls">document.querySelector('.modal .close').click();</span></pre><p id="36eb" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">然而，当我们使用<code class="eh lf lg lh li b">querySelector</code>时，一个不存在的元素的误差是不够描述的:</p><blockquote class="kw kx ky"><p id="a1e9" class="jz ka kz kb b kc kd iv ke kf kg iy kh la kj kk kl lb kn ko kp lc kr ks kt ku hn dt translated">未捕获的类型错误:无法读取null的属性“click”</p></blockquote><p id="8b14" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们可以通过将操作包装在一个自定义函数中，用一个更清晰的消息让它失败:</p><pre class="jk jl jm jn fq lj li lk ll aw lm dt"><span id="ec37" class="ln lo hu li b fv lp lq l lr ls">// This wrapper throws if the element is not there<br/>findElement($('.modal'), '.close').click();</span></pre><blockquote class="kw kx ky"><p id="daf8" class="jz ka kz kb b kc kd iv ke kf kg iy kh la kj kk kl lb kn ko kp lc kr ks kt ku hn dt translated">错误:未找到选择器的元素。关闭"</p></blockquote><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ld le l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><a class="ae kv" href="https://jsfiddle.net/4cvprc9m/2/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/4cvprc9m/2/</a></figcaption></figure><p id="3a33" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在不应该通过测试的时候通过测试的问题是，当特定的bug发生时，开发人员不知道要调查哪些测试。一个通过的测试很可能被忽略，尤其是如果模态测试更复杂，并且它处于其他几个测试的中间。</p><blockquote class="lt"><p id="7b39" class="lu lv hu bd lw lx ly lz ma mb mc ku ek translated">在测试环境中，假阴性比假阳性好。如果测试失败，它会被突出显示，如果没有，它会被开发人员忽略，因为它被认为是有效的。</p></blockquote><p id="0304" class="pw-post-body-paragraph jz ka hu kb b kc md iv ke kf me iy kh ki mf kk kl km mg ko kp kq mh ks kt ku hn dt translated">这是一个当<a class="ae kv" rel="noopener" href="/@fagnerbrack/mocking-can-lean-to-nondeterministic-tests-4ba8aef977a0">嘲笑会导致假阳性</a>的同类问题。不同之处在于，我们没有嘲笑，而是使用不正确的DOM API进行<a class="ae kv" href="https://hackernoon.com/tagged/testing" rel="noopener ugc nofollow" target="_blank">测试</a>。</p><p id="e14c" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">作为正式的问题陈述，我们可以说一组测试在下列情况下会导致假阳性结果</p><ul class=""><li id="0b26" class="mi mj hu kb b kc kd kf kg ki mk km ml kq mm ku mn mo mp mq dt translated">默认情况下某些东西是否定的(模态是封闭的)</li><li id="8b5f" class="mi mj hu kb b kc mr kf ms ki mt km mu kq mv ku mn mo mp mq dt translated">测试需要一个动作(关闭模态)</li><li id="9473" class="mi mj hu kb b kc mr kf ms ki mt km mu kq mv ku mn mo mp mq dt translated">这将我们正在测试的组件的状态更改为初始状态(模态是关闭的)</li></ul><p id="1c09" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在这种情况下，我们不能保证功能真的被覆盖。即使有为此编写的测试，更改组件代码仍然可以使测试通过。</p><p id="c4c8" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">有几个选项可以防止这种情况发生:</p><ol class=""><li id="e06d" class="mi mj hu kb b kc kd kf kg ki mk km ml kq mm ku mw mo mp mq dt translated">在确保模态可以被关闭的测试中，断言模态应该在关闭模态之前打开。不幸的是，这违反了AAA，因为我们将在Arrange和Act之间有一个断言来检查模态是否是开放的。<a class="ae kv" href="https://jsfiddle.net/q4bnqepw/1/" rel="noopener ugc nofollow" target="_blank">这里有一个例子</a>。</li><li id="880f" class="mi mj hu kb b kc mr kf ms ki mt km mu kq mv ku mw mo mp mq dt translated">使用当元素不存在时抛出的API。这样，如果我们从模态中移除目标元素，测试将会失败，我们将会确切地知道原因。<a class="ae kv" href="https://jsfiddle.net/4cvprc9m/2/" rel="noopener ugc nofollow" target="_blank">如上图</a>的例子。</li></ol><p id="30df" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">仅仅编写测试不足以确保应用程序正常工作。您需要正确地编写它们，这样就不会发生像这样的假阳性。这意味着使用合适的API来实现你的目标。</p><p id="b922" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">单独的jQuery不适合这类测试。</p><p id="1675" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">还有你。你踩过类似的东西吗？当测试一个对象或组件的默认状态时，你有什么建议来防止这个问题发生？</p></div><div class="ab cl mx my hc mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="hn ho hp hq hr"><p id="a314" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">感谢阅读。如果你有一些反馈，请在Twitter、脸书或Github上联系我。</p></div></div>    
</body>
</html>