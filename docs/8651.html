<html>
<head>
<title>From callbacks to async/await</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从回调到异步/等待</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/from-callbacks-to-async-await-25331b7f73?source=collection_archive---------10-----------------------#2017-12-09">https://medium.com/hackernoon/from-callbacks-to-async-await-25331b7f73?source=collection_archive---------10-----------------------#2017-12-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/bbbab6fc99628470add15052bb51d73c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H-25KB7EbSHjv70HXrdl6w.png"/></div></div></figure><p id="8caf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我用4种不同的方式构建了同一个程序。我从回调开始，到承诺，使用生成器，最后用async/await结束。</p><p id="6da3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该计划:</p><ol class=""><li id="fbc7" class="ka kb hu je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki dt translated">向Github的用户端点发出请求</li><li id="6338" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">撤回我的Github档案</li><li id="7ce2" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">记录响应</li></ol><p id="adbc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是我想到的。</p><h1 id="51b9" class="ko kp hu bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">复试</h1><p id="f7d3" class="pw-post-body-paragraph jc jd hu je b jf lm jh ji jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz hn dt translated">我努力使用回调发出一个HTTP请求。我大多使用Promises来编写异步的JavaScript。在我的应用程序中，我通常使用<a class="ae lr" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> axios </a>或<a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch" rel="noopener ugc nofollow" target="_blank"> fetch </a>，它们都是基于承诺的。</p><p id="0869" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我最终不得不求助于<a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" rel="noopener ugc nofollow" target="_blank"> XMLHTTPRequest </a>来获得这个版本的应用程序，这是我以前从未使用过的！</p><figure class="ls lt lu lv fq iv"><div class="bz el l di"><div class="lw lx l"/></div><figcaption class="ly lz fg fe ff ma mb bd b be z ek">Using Callbacks</figcaption></figure><p id="b2c6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我将带您了解这段代码的作用:</p><ol class=""><li id="f643" class="ka kb hu je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki dt translated">我定义了一个叫做<code class="eh mc md me mf b">makeHTTPRequest</code>的函数。它被设计成实际上向Github发出请求。</li><li id="34e3" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">我将三个方法传递给<code class="eh mc md me mf b">makeHTTPRequest</code>、<code class="eh mc md me mf b">url</code>、<code class="eh mc md me mf b">methodType</code>和<code class="eh mc md me mf b">callback</code>。<code class="eh mc md me mf b">url</code>是我要打的终点。<code class="eh mc md me mf b">methodType</code>是我要用的HTTP方法。而<code class="eh mc md me mf b">callback</code>是我实际得到Github返回的响应时想要调用的函数。</li><li id="b64f" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">我定义了一个名为<code class="eh mc md me mf b">getLogin</code>的函数，并把它<code class="eh mc md me mf b">response</code>作为参数传递。该函数获取我从Github收到的响应，并将其解析为JSON。然后，它记录解析后的响应。</li><li id="bc2b" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">我将<code class="eh mc md me mf b">getLogin</code>作为<code class="eh mc md me mf b">callback</code>传入<code class="eh mc md me mf b">makeHTTPRequest</code>。这意味着<code class="eh mc md me mf b">getLogin</code>将接受来自Github的响应。</li></ol><h1 id="18e5" class="ko kp hu bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">承诺</h1><p id="f06d" class="pw-post-body-paragraph jc jd hu je b jf lm jh ji jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz hn dt translated">在通过复试实现我的目标后，我尝试承诺。这感觉很简单，因为我以前做过很多次。</p><figure class="ls lt lu lv fq iv"><div class="bz el l di"><div class="lw lx l"/></div><figcaption class="ly lz fg fe ff ma mb bd b be z ek">Using Promises</figcaption></figure><ol class=""><li id="607d" class="ka kb hu je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki dt translated">我定义了一个名为<code class="eh mc md me mf b">makeHTTPRequest</code>的函数，并给它传递了一个用户名。</li><li id="fa01" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">我用<code class="eh mc md me mf b">fetch</code>向Github发出请求。</li><li id="d7d2" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">我使用<code class="eh mc md me mf b">.then()</code>等待对Github的请求完成，然后将响应转换成JSON。</li><li id="63a7" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">我记录响应</li></ol><h1 id="9a89" class="ko kp hu bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">发电机</h1><p id="43a5" class="pw-post-body-paragraph jc jd hu je b jf lm jh ji jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz hn dt translated">这是我第一次涉足发电机。在面对这个挑战时，语法和概念对我来说完全陌生。</p><figure class="ls lt lu lv fq iv"><div class="bz el l di"><div class="lw lx l"/></div><figcaption class="ly lz fg fe ff ma mb bd b be z ek">Using Generators</figcaption></figure><ol class=""><li id="2a1e" class="ka kb hu je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki dt translated">我用*语法定义了<code class="eh mc md me mf b">getUser</code>并说它是一个生成器。我将<code class="eh mc md me mf b">username</code>作为参数传入。</li></ol><p id="b7e8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">2.我创建了一个名为<code class="eh mc md me mf b">response</code>的变量，并将其设置为使用<code class="eh mc md me mf b">fetch</code>发出HTTP请求后从Github收到的响应。第3行的重要部分是我使用了关键字<code class="eh mc md me mf b">yield</code>。<code class="eh mc md me mf b">yield</code>告诉我的程序我确实想将<code class="eh mc md me mf b">response</code>设置为我从Github得到的响应，但只是在请求完成之后。</p><p id="7f04" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">3.当我设置<code class="eh mc md me mf b">parsedResponse</code>等于<code class="eh mc md me mf b">response.json()</code>时，我再次遵循相同的模式。在设置变量之前，我必须等待承诺解决。如果我不使用<code class="eh mc md me mf b">yield</code>，当我尝试登录<code class="eh mc md me mf b">parsedResponse</code>时，我得到:<code class="eh mc md me mf b">Promise {&lt;pending&gt;}</code>返回。</p><h1 id="cfdb" class="ko kp hu bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">异步/等待</h1><p id="2c58" class="pw-post-body-paragraph jc jd hu je b jf lm jh ji jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz hn dt translated">最后，我使用ES7 async/await再次编写了应用程序。因为我是在用生成器构建了相同的应用程序之后才这么做的，所以async/await是如何构建在生成器之上的就变得非常明显了。</p><figure class="ls lt lu lv fq iv"><div class="bz el l di"><div class="lw lx l"/></div></figure><ol class=""><li id="cde2" class="ka kb hu je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki dt translated">我定义了一个名为<code class="eh mc md me mf b">getUser</code>的<code class="eh mc md me mf b">async</code>函数，它将<code class="eh mc md me mf b">username</code>作为参数。</li><li id="5928" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">我创建了一个名为<code class="eh mc md me mf b">response</code>的变量，并将其设置为向<code class="eh mc md me mf b">/users/:id</code>端点发出请求后从Github收到的响应。关键是我使用关键字<code class="eh mc md me mf b">await</code>告诉我的程序在设置<code class="eh mc md me mf b">response</code>等于我得到的响应之前等待请求自行解决。</li><li id="2773" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">我在第4行再次使用相同的模式。</li><li id="07fa" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">然后，我记录解析后的响应。</li></ol><h1 id="889a" class="ko kp hu bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">外卖食品</h1><p id="b4c0" class="pw-post-body-paragraph jc jd hu je b jf lm jh ji jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz hn dt translated">出于几个原因，这是一项有价值的努力。首先，我没怎么用过回调，所以我真的不知道承诺有多大。我也一直认为fetch和axios是理所当然的，因为它们使得HTTP请求变得更加简单。</p><p id="7983" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我也从未使用过生成器或async/await。尽管我发现async/await比generators更容易使用，但了解async/await是如何构建在generators之上的还是很有帮助的。接触一些ES7语法也很有趣。</p><figure class="ls lt lu lv fq iv"><div class="bz el l di"><div class="mg lx l"/></div></figure></div></div>    
</body>
</html>