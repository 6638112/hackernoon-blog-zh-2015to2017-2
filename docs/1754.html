<html>
<head>
<title>From callback swamp to typescript heaven: why we rewrote our entire api in typescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从回调沼泽到typescript天堂:为什么我们用typescript重写了整个api</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/from-callback-swamp-to-typescript-heaven-why-we-rewrote-our-entire-api-in-typescript-d1a1e05ad6df?source=collection_archive---------6-----------------------#2016-12-05">https://medium.com/hackernoon/from-callback-swamp-to-typescript-heaven-why-we-rewrote-our-entire-api-in-typescript-d1a1e05ad6df?source=collection_archive---------6-----------------------#2016-12-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/3de841831a4aa847bf85170c71b3da6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t-cUplsj9p0vYyDSVXw8FQ.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Theseus also went back from (callback) hell</figcaption></figure><p id="5a46" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在<a class="ae ke" href="https://hunteed.com" rel="noopener ugc nofollow" target="_blank"> Hunteed </a>，我们最近重写了整个api代码库，从标准的node-express api迁移到全新的typescript应用。这是一个相当大的挑战，需要相当长的时间，所以当时并不清楚该如何选择。</p><p id="a387" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在我们已经完成了，我们认为这样做的好处是巨大的。原因如下。</p><h2 id="e537" class="kf kg hu bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz dt translated">TL；速度三角形定位法(dead reckoning)</h2><ul class=""><li id="5782" class="la lb hu ji b jj lc jn ld jr le jv lf jz lg kd lh li lj lk dt translated">它更健壮</li><li id="7bc8" class="la lb hu ji b jj ll jn lm jr ln jv lo jz lp kd lh li lj lk dt translated">理解/维护起来更容易、更快</li><li id="56c4" class="la lb hu ji b jj ll jn lm jr ln jv lo jz lp kd lh li lj lk dt translated">代码行减少了25%</li><li id="5749" class="la lb hu ji b jj ll jn lm jr ln jv lo jz lp kd lh li lj lk dt translated">不再有回电-见鬼</li><li id="7176" class="la lb hu ji b jj ll jn lm jr ln jv lo jz lp kd lh li lj lk dt translated">打字稿学习曲线:非常低</li></ul><h1 id="fa25" class="lq kg hu bd kh lr ls lt kl lu lv lw kp lx ly lz ks ma mb mc kv md me mf ky mg dt translated">我们从什么开始(又名<em class="mh">)何必呢？)</em></h1><p id="e0c8" class="pw-post-body-paragraph jg jh hu ji b jj lc jl jm jn ld jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd hn dt translated">我们从一个node-express <a class="ae ke" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> javascript </a>应用开始，最初是用一个流行的yeoman版本引导的。</p><p id="cab4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">代码是es6编写的，一些令人困惑的babel配置不知何故让事情变得可行，尽管我不太确定为什么和如何。我们也忽略了大红旗说巴别塔应该<em class="ml">而不是</em>用于生产(但真的是这样吗？).</p><p id="0fb2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">应用程序代码覆盖率很好。然而，在实际编写测试之前，测试新特性需要大量的样板文件和复杂的回调。这是一个真正的麻烦，因为只编写未经测试的代码的诱惑只会越来越大。</p><p id="8c6f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我开始认为使用大量的mongoose钩子使得代码有点难以理解。首先，它看起来很好，很有效率，但是在某些时候，当你调用一个方法时，看不出发生了什么。事情可以更清楚。</p><p id="29e6" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">很多次试镜。到处都有试镜。当时并不觉得这是个问题，因为我们已经习惯了使用它们。你会看到我们是如何改变想法的:)</p><h1 id="895b" class="lq kg hu bd kh lr ls lt kl lu lv lw kp lx ly lz ks ma mb mc kv md me mf ky mg dt translated">为什么打字稿？</h1><h2 id="2a84" class="kf kg hu bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz dt translated">1.打字的明显优势</h2><p id="5ff0" class="pw-post-body-paragraph jg jh hu ji b jj lc jl jm jn ld jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd hn dt translated">键入您的代码为您的项目增加了很多健壮性。这一点在其他地方已经讨论了很多，但这里仍然可以提到一些主要优势:</p><ul class=""><li id="3e5e" class="la lb hu ji b jj jk jn jo jr mm jv mn jz mo kd lh li lj lk dt translated"><em class="ml">一致性</em>:有人说如果你的函数有很多参数，那么在某个时候，有人<strong class="ji hv">会</strong>反转它们。调用<code class="eh mp mq mr ms b">f(foo, bar)</code>而不是<code class="eh mp mq mr ms b">f(bar, foo</code>现在已经不可能了。Typescript检查输入/输出，这样您就不会犯这样的错误。</li><li id="4841" class="la lb hu ji b jj ll jn lm jr ln jv lo jz lp kd lh li lj lk dt translated"><em class="ml">空错误检查</em>:在typescript2中，可以在编译时检查空错误:</li></ul><figure class="mt mu mv mw fq iv"><div class="bz el l di"><div class="mx my l"/></div></figure><ul class=""><li id="a8c1" class="la lb hu ji b jj jk jn jo jr mm jv mn jz mo kd lh li lj lk dt translated"><em class="ml"> I/O类型检查</em>:编译器知道你的函数的输入/输出类型。</li></ul><figure class="mt mu mv mw fq iv"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="8ba5" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">注意，<code class="eh mp mq mr ms b">[1, 2, 3, 4].map(x =&gt; add(x, 1))</code>将产生一个数字数组<code class="eh mp mq mr ms b">[2, 3, 4, 5]</code>。编译器能够自己解决这个问题。</p><h2 id="4f57" class="kf kg hu bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz dt translated">2.Await是新的回调</h2><p id="29ae" class="pw-post-body-paragraph jg jh hu ji b jj lc jl jm jn ld jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd hn dt translated">我最喜欢的一个typescript特性是类似ES7的<code class="eh mp mq mr ms b">async/await</code>。尽管这是目前ES7的一个提议，typescript已经支持它，并且它知道如何将<code class="eh mp mq mr ms b">await</code>转换成ES6代码(通过利用ES6迭代器，但是作为开发人员，您不必担心这一点)。</p><p id="6547" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="ml">【编辑】:</em> <a class="ae ke" href="http://react-etc.net/entry/async-await-support-for-es5-browsers-pushed-to-typescript-2-1" rel="noopener ugc nofollow" target="_blank"> <em class="ml">从typescript 2.1开始，可以将</em> </a> <code class="eh mp mq mr ms b"><a class="ae ke" href="http://react-etc.net/entry/async-await-support-for-es5-browsers-pushed-to-typescript-2-1" rel="noopener ugc nofollow" target="_blank"><em class="ml">await</em></a></code> <a class="ae ke" href="http://react-etc.net/entry/async-await-support-for-es5-browsers-pushed-to-typescript-2-1" rel="noopener ugc nofollow" target="_blank"> <em class="ml">移植到es 2015</em></a><em class="ml">【o/</em></p><p id="f510" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><a class="ae ke" href="https://blogs.msdn.microsoft.com/typescript/2015/11/03/what-about-asyncawait/" rel="noopener ugc nofollow" target="_blank">本帖</a>涵盖了关于<code class="eh mp mq mr ms b">async/await</code>的细节。长话短说，只要一个函数被声明为<code class="eh mp mq mr ms b">async,</code>，它就会返回一个承诺。此外，它将允许使用<code class="eh mp mq mr ms b">await,</code>，它告诉编译器等待一个承诺来解决，而不阻塞线程。举个例子，</p><figure class="mt mu mv mw fq iv"><div class="bz el l di"><div class="mx my l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">This is non blocking, although it looks like regular synchronous code we all dream of</figcaption></figure><p id="ad08" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这让我们可以修改一些代码</p><figure class="mt mu mv mw fq iv"><div class="bz el l di"><div class="mx my l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">our old, tedious, cb syntax</figcaption></figure><p id="c269" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">到现在的幻想</p><figure class="mt mu mv mw fq iv"><div class="bz el l di"><div class="mx my l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">new await syntax</figcaption></figure><p id="c7c7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">结论摆脱繁琐的回调/回调错误处理过程让我们减少了25%的代码库！</p><p id="2e62" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">想“许诺”你的一个功能吗？易如反掌:</p><figure class="mt mu mv mw fq iv"><div class="bz el l di"><div class="mx my l"/></div></figure><h2 id="5905" class="kf kg hu bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz dt translated">3.奇特的测试</h2><p id="a029" class="pw-post-body-paragraph jg jh hu ji b jj lc jl jm jn ld jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd hn dt translated">我们过去在测试中有很多回电/承诺。结果，正确初始化一个测试变得越来越困难。</p><p id="0664" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">拥有一个乏味的测试环境是一件灾难性的事情。在某些时候，有人会跳过测试，因为这太麻烦了。</p><p id="bd31" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">有了令人敬畏的<a class="ae ke" href="https://github.com/WhoopInc/supertest-as-promised" rel="noopener ugc nofollow" target="_blank">super test-as-promised</a>lib和<code class="eh mp mq mr ms b">async</code>函数，测试路线现在变得相当优雅:</p><figure class="mt mu mv mw fq iv"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="9453" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">听着，妈，没有复试！</p><h1 id="6feb" class="lq kg hu bd kh lr ls lt kl lu lv lw kp lx ly lz ks ma mb mc kv md me mf ky mg dt translated">是啊，但是我怎么部署？</h1><p id="2066" class="pw-post-body-paragraph jg jh hu ji b jj lc jl jm jn ld jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd hn dt translated">和平常一样，除了你应该在上传代码之前先转换它。如果您选择使用<code class="eh mp mq mr ms b">await</code>，请注意您至少需要转换到ES6。所以你需要运行一个足够新的版本。大多数现代工具都是这样(比如heroku、module……)，这对于后端api部署来说应该不是问题。</p><p id="0d04" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在<a class="ae ke" href="https://hunteed.com" rel="noopener ugc nofollow" target="_blank"> Hunteed </a>我们开源了<a class="ae ke" href="https://github.com/aherve/typescript-express-docker" rel="noopener ugc nofollow" target="_blank">一个你可以使用的构建</a>(查看<a class="ae ke" href="https://hackernoon.com/edge-node-express-api-using-docker-typescript-codeship-mongoose-37397cd07955#.oxz4ltb63" rel="noopener ugc nofollow" target="_blank">这个故事</a>了解更多细节)。工作流程可以总结为:</p><ul class=""><li id="f74d" class="la lb hu ji b jj jk jn jo jr mm jv mn jz mo kd lh li lj lk dt translated">编写打字稿代码</li><li id="d4a9" class="la lb hu ji b jj ll jn lm jr ln jv lo jz lp kd lh li lj lk dt translated">保存文件触发代码转换，在<code class="eh mp mq mr ms b">/dist</code>中输出新的js</li><li id="0728" class="la lb hu ji b jj ll jn lm jr ln jv lo jz lp kd lh li lj lk dt translated">更改js文件会触发测试运行。注意，测试实际上是针对传输的javascript文件运行的。这很好，因为transpiled javascript实际上将在prod中运行。当然，映射文件允许将错误链接到您的typescript文件。</li><li id="1028" class="la lb hu ji b jj ll jn lm jr ln jv lo jz lp kd lh li lj lk dt translated">一旦你的<code class="eh mp mq mr ms b">dist</code>目录被编译和测试，它就是一个很好的旧的ES6 node-express应用程序，你可以安全地发送到prod。显然这是一个CI-server作品。你可以，但你不会从你的电脑上做。</li></ul><h2 id="6411" class="kf kg hu bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz dt translated">学习曲线怎么样？</h2><p id="7db8" class="pw-post-body-paragraph jg jh hu ji b jj lc jl jm jn ld jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd hn dt translated">在我看来，对于一个有经验的javascript开发人员来说，用typescript编写代码只需要不到一天的时间。将你的<code class="eh mp mq mr ms b">function (user) {...}</code>改为<code class="eh mp mq mr ms b">function (user: User) {...}</code>已经足够受益于ts编译器的强大了。如果你觉得足够勇敢，那么你可以打开<code class="eh mp mq mr ms b">noImplicitAny</code>编译器选项，这将确保没有变量是未声明的</p><p id="d56d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">然而，理解如何从外部库导入类型并不那么明显。有了typescript 2就更容易了，因为大多数时候你只需从npm registery安装<code class="eh mp mq mr ms b">@types/something</code>就能让事情正常运行。</p><p id="be10" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">不过，总的来说，它非常快，不到一周我们就注意到用typescript编码是多么的快速和安全。</p><h2 id="3123" class="kf kg hu bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz dt translated">结论</h2><p id="1d0b" class="pw-post-body-paragraph jg jh hu ji b jj lc jl jm jn ld jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd hn dt translated">我们观察到在typescript环境中工作的好处:</p><ul class=""><li id="6941" class="la lb hu ji b jj jk jn jo jr mm jv mn jz mo kd lh li lj lk dt translated">让我改变了对javascript的看法。我们现在有了一种看起来不错的编程语言，支持并发。</li><li id="eba9" class="la lb hu ji b jj ll jn lm jr ln jv lo jz lp kd lh li lj lk dt translated">添加测试比以前更容易。</li><li id="433c" class="la lb hu ji b jj ll jn lm jr ln jv lo jz lp kd lh li lj lk dt translated">现在重构东西非常容易。想要更改函数的签名？只需重新编写，编译器就会告诉你每一行代码应该进行修改。当编译器最终满意时，你也一样，因为它可能会工作。</li><li id="a76f" class="la lb hu ji b jj ll jn lm jr ln jv lo jz lp kd lh li lj lk dt translated">代码更容易理解。函数在它们的定义中是有符号的，接口使得知道任何对象上有什么方法/属性变得非常容易。额外收获:如果你搞砸了，编译器会警告你。</li></ul><p id="9ea6" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">非常感谢每一个为这份令人惊叹的打字稿负责的人。你们统治一切。</p><figure class="mt mu mv mw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mz"><img src="../Images/0d54e8100158db49b8f6088a89d90a26.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/1*gqDvUU7A_qAiN0DtLVQbiQ.gif"/></div></div></figure><p id="2700" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果您有关于ts过渡的反馈，请随时分享！</p><p id="5156" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">相关链接:</p><ul class=""><li id="7e2e" class="la lb hu ji b jj jk jn jo jr mm jv mn jz mo kd lh li lj lk dt translated"><a class="ae ke" href="https://hackernoon.com/edge-node-express-api-using-docker-typescript-codeship-mongoose-37397cd07955" rel="noopener ugc nofollow" target="_blank"> Edge node-express api使用Docker，Typescript，codeship&amp;mongose</a></li><li id="c6d4" class="la lb hu ji b jj ll jn lm jr ln jv lo jz lp kd lh li lj lk dt translated"><a class="ae ke" href="https://hackernoon.com/how-we-happily-dockerized-our-development-environment-part-1-2-b05fd6927a53" rel="noopener ugc nofollow" target="_blank">我们是如何愉快地将我们的开发环境进行文档化的</a></li></ul><div class="mt mu mv mw fq ab cb"><figure class="na iv nb nc nd ne nf paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="na iv nb nc nd ne nf paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="na iv nb nc nd ne nf paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ng nh ni"><p id="f922" class="jg jh ml ji b jj jk jl jm jn jo jp jq nj js jt ju nk jw jx jy nl ka kb kc kd hn dt translated"><a class="ae ke" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ke" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ke" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ke" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jg jh ml ji b jj jk jl jm jn jo jp jq nj js jt ju nk jw jx jy nl ka kb kc kd hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ke" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ke" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="mt mu mv mw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nm"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="mt mu mv mw fq iv"><div class="bz el l di"><div class="nn my l"/></div></figure></div></div>    
</body>
</html>