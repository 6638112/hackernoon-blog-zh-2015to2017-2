<html>
<head>
<title>Applying principles of chaos engineering to AWS Lambda with latency injection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将混沌工程原理应用于具有延迟注入的AWS Lambda</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/chaos-engineering-and-aws-lambda-latency-injection-ddeb4ff8d983?source=collection_archive---------13-----------------------#2017-11-06">https://medium.com/hackernoon/chaos-engineering-and-aws-lambda-latency-injection-ddeb4ff8d983?source=collection_archive---------13-----------------------#2017-11-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="e2fe" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">我们可以对用API Gateway和AWS Lambda创建的API应用延迟注入。我们的方法应该允许我们配置何时向我们的API端点添加任意延迟(以及添加多少),以确保使用适当的超时值来调整服务间通信。</h2></div><p id="df94" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是一个多部分系列的第2部分，探讨了如何将混沌工程的原理应用于围绕Lambda函数构建的无服务器架构。</p><ul class=""><li id="f9f8" class="kf kg hu jl b jm jn jp jq js kh jw ki ka kj ke kk kl km kn dt translated">第一部分:我们如何将混沌工程的原理应用于Lambda？</li><li id="ecc3" class="kf kg hu jl b jm kp jp kq js kr jw ks ka kt ke kk kl km kn dt translated"><strong class="jl hv">第2部分:为API应用延迟注入</strong></li><li id="552f" class="kf kg hu jl b jm kp jp kq js kr jw ks ka kt ke kk kl km kn dt translated">第3部分:处理延迟峰值和超时(将于2017年11月21日发布)</li><li id="bb4d" class="kf kg hu jl b jm kp jp kq js kr jw ks ka kt ke kk kl km kn dt translated">第4部分:为Lambda函数应用故障注入(来了？)</li></ul></div><div class="ab cl ku kv hc kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hn ho hp hq hr"><p id="7537" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我在生产中遇到的最常见的问题是与延迟/性能相关的。它们可能是一系列潜在原因的症状，从AWS网络问题(也可能表现为任何AWS服务中的延迟/错误率峰值)、过载的服务器到简单的GC暂停。</p><p id="1c0e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">延迟峰值是不可避免的</strong>——尽管你可以提高应用程序的性能，但事情最终还是会出错，而且往往超出你的控制。</p><p id="f789" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以你必须为他们设计，优雅地降低你的应用程序的质量<strong class="jl hv"/>以最小化对你的用户的影响。</p><p id="2162" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于API Gateway和Lambda，还有一些额外的考虑:</p><ul class=""><li id="f75e" class="kf kg hu jl b jm jn jp jq js kh jw ki ka kj ke kk kl km kn dt translated"><strong class="jl hv"> API Gateway对于集成点有一个29秒超时的硬限制</strong>，所以即使您的Lambda函数可以运行5分钟，API Gateway也会在此之前超时</li></ul><figure class="lc ld le lf fq lg fe ff paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="fe ff lb"><img src="../Images/49e90a022b33438c1934cec94290bda3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cf9p6pTcE4VoxXiyX78HIw.png"/></div></div></figure><ul class=""><li id="93f7" class="kf kg hu jl b jm jn jp jq js kh jw ki ka kj ke kk kl km kn dt translated">你需要考虑<strong class="jl hv">冷启动</strong>的效果，这<a class="ae ko" href="https://read.acloud.guru/does-coding-language-memory-or-package-size-affect-cold-starts-of-aws-lambda-a15e26d12c76" rel="noopener ugc nofollow" target="_blank">受到语言运行时和内存分配</a>的严重影响。中间服务的冷启动很容易导致外部服务超时。</li></ul><figure class="lc ld le lf fq lg fe ff paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="fe ff ln"><img src="../Images/9320fd8cedb747f19ded9664eb2a3d51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tfdm5N79JkjBqK_8v0POaQ.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">If you use moderate timeout settings for your API functions (and you should!) then you need to consider the effects of cold starts when calling an intermediate service.</figcaption></figure><h1 id="02b4" class="ls lt hu bd lu lv lw lx ly lz ma mb mc ja md jb me jd mf je mg jg mh jh mi mj dt translated">在哪里注入延迟</h1><p id="88c8" class="pw-post-body-paragraph jj jk hu jl b jm mk iv jo jp ml iy jr js mm ju jv jw mn jy jz ka mo kc kd ke hn dt translated">假设我们的客户端应用程序直接与两个面向公众的API通信，而这两个API又依赖于一个内部API。</p><figure class="lc ld le lf fq lg fe ff paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="fe ff mp"><img src="../Images/0a55a68566015d9eab64389b1a9d27ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Tr-ro9LHu_4NXpH491PYw.png"/></div></div></figure><p id="80b7" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这个设置中，我可以想到3个可以注入延迟的地方，每个地方都可以验证不同的假设。</p><h2 id="6406" class="mq lt hu bd lu mr ms mt ly mu mv mw mc js mx my me jw mz na mg ka nb nc mi nd dt translated">在HTTP客户端注入延迟</h2><p id="2c05" class="pw-post-body-paragraph jj jk hu jl b jm mk iv jo jp ml iy jr js mm ju jv jw mn jy jz ka mo kc kd ke hn dt translated">第一个也是最容易引入延迟的地方是我们用来与内部API通信的HTTP客户端库。</p><p id="e3d4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这将测试我们的函数<strong class="jl hv">在这个HTTP通信上有适当的超时，并且当这个请求超时</strong>时可以正常降级。</p><figure class="lc ld le lf fq lg fe ff paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="fe ff ne"><img src="../Images/76c5d11e3108d5acdd568b2d37c19700.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JKqlzibh1ifRRiwqoFFALw.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">We can inject latency to the HTTP client libraries for our internal APIs, hence validating that the caller function has configured appropriate timeout and error handling for timeouts.</figcaption></figure><p id="d0ea" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">此外，这种做法<strong class="jl hv">也应该适用于我们依赖的其他第三方服务</strong>，比如DynamoDB。我们将在稍后的帖子中讨论<em class="nf">如何</em>给这些第三方库注入延迟。</p><figure class="lc ld le lf fq lg fe ff paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="fe ff ng"><img src="../Images/d2e8d5797d7c03d6a94948340f77fc7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kNipjjJ4jtv5FOTrZqK3Fg.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">We can also inject latency to 3rd party client libraries for other managed services we depend on.</figcaption></figure><p id="f6b0" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是一个相当安全的注入延迟的地方，因为<em class="nf">即时</em>爆炸半径受限于这个函数。</p><p id="d63f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是，您可以(也可以说应该)考虑将这种类型的延迟注入也应用到中间服务中。这样做确实会带来额外的风险，因为它在故障情况下有更大的爆炸半径。如果测试中的功能没有正常降级，那么它可能会给外部服务带来意想不到的问题。在这种情况下，这些故障案例的爆炸半径与您直接向中间功能注入延迟的情况相同。</p><h2 id="3e4a" class="mq lt hu bd lu mr ms mt ly mu mv mw mc js mx my me jw mz na mg ka nb nc mi nd dt translated">给中间函数注入延迟</h2><p id="a1b5" class="pw-post-body-paragraph jj jk hu jl b jm mk iv jo jp ml iy jr js mm ju jv jw mn jy jz ka mo kc kd ke hn dt translated">您也可以直接向函数本身注入延迟(稍后我们将查看<em class="nf">如何</em>)。这与向HTTP客户端的每个依赖项注入延迟具有相同的效果，只是它会立即影响所有的依赖项。</p><figure class="lc ld le lf fq lg fe ff paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="fe ff nh"><img src="../Images/0d58ee9a5def5147932adb2d621f87a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ba9MJEiII4ho0TyGzWXx7g.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">We can inject latency to a function’s invocation. If that function is behind an internal API that are used by multiple public-facing APIs then it can cause all its dependents to experience timeouts.</figcaption></figure><p id="683f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这看起来有风险(有可能)，但这是一种有效的方法来验证依赖于这个API端点的每个服务都是<em class="nf">期望</em>的，并且优雅地处理超时。</p><p id="2573" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当应用于由同一个开发团队维护的有界上下文(或微服务)的中间API时，这是最有意义的。这样，您可以避免将混乱释放给那些可能没有准备好处理混乱的毫无戒心的开发人员。</p><p id="118b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">也就是说，我认为这样做有一个很好的反驳理由。</p><p id="64e2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们经常陷入使用开发环境的性能特征作为生产环境的预测器的陷阱。虽然我们在开发环境中很少遇到与负载相关的延迟问题——因为我们在这些环境中没有足够的负载——但生产却完全是另一回事。这意味着，我们没有被<em class="nf">编程为</em>在开发过程中考虑这些故障模式。</p><p id="4261" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，<a class="ae ko" href="http://jlouisramblings.blogspot.co.uk/2012/12/hacking-brains-of-other-people-with-api.html" rel="noopener ugc nofollow" target="_blank">侵入你的开发伙伴的大脑</a>并对他们进行编程以期待超时的一个好方法是，通过在开发环境中向我们的内部API注入延迟，在开发环境中定期向他们暴露这些故障模式。</p><p id="4ac1" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">事实上，如果我们让我们的开发环境展现出我们的系统<strong class="jl hv">应该处理</strong>的最恶劣和最混乱的条件，那么我们肯定知道任何进入生产的系统都<strong class="jl hv">准备好面对在野外等待它的事情</strong>。</p><figure class="lc ld le lf fq lg fe ff paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="fe ff ni"><img src="../Images/8bfebd0da1142bb03abc0b872227b60e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dkzCDMKU87Yqgcxvp9c-Eg.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">We can figuratively hold up a sign and tell other developers to expect latency spikes and timeouts by literally exposing them to these scenarios in dev environments, regularly, so they know to expect it.</figcaption></figure><h2 id="3d7b" class="mq lt hu bd lu mr ms mt ly mu mv mw mc js mx my me jw mz na mg ka nb nc mi nd dt translated">向面向公众的函数注入延迟</h2><p id="596c" class="pw-post-body-paragraph jj jk hu jl b jm mk iv jo jp ml iy jr js mm ju jv jw mn jy jz ka mo kc kd ke hn dt translated">到目前为止，我们一直专注于验证API中延迟峰值和超时的处理。我们的客户端应用程序需要同样的验证。</p><p id="f376" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以在这里应用上面提到的所有相同的论点。通过向面向公众的API函数注入延迟(在生产和开发环境中)，我们可以:</p><ul class=""><li id="daa6" class="kf kg hu jl b jm jn jp jq js kh jw ki ka kj ke kk kl km kn dt translated">验证客户端应用程序是否恰当地处理延迟峰值和超时，并在这些情况下尽可能提供最佳UX</li><li id="89c2" class="kf kg hu jl b jm kp jp kq js kr jw ks ka kt ke kk kl km kn dt translated">培训我们的客户端开发人员，以应对延迟峰值和超时</li></ul><figure class="lc ld le lf fq lg fe ff paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="fe ff nj"><img src="../Images/0cd4c90533f8ce11efed97cbef9a02cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fc4I9eweoLw1dkHnXsSxWw.png"/></div></div></figure><p id="2d5c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">几年前我在Gamesys开发MMORPG的时候，当我们<a class="ae ko" href="http://theburningmonk.com/2015/04/design-for-latency-issues/" rel="noopener ugc nofollow" target="_blank">向我们的API注入延迟峰值和故障</a>时，我们发现了游戏中的许多弱点。如果最初几个请求中的任何一个失败，游戏就会在启动时崩溃。在某些情况下，如果响应时间超过几秒钟，那么游戏也会因为竞争条件而进入一个奇怪的状态。</p><p id="9149" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">结果是我让我的同事在生产中失败，因为开发环境太宽容了，给了他们一种虚假的舒适感。</p><p id="94d9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">至此，我们来谈谈<em class="nf">如何</em>应用延迟注入的实践。</p></div><div class="ab cl ku kv hc kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hn ho hp hq hr"><p id="5d22" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是等等，你不能在客户端HTTP客户端也注入延迟吗？</p><p id="3008" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="nf">绝对！你应该这么做！然而，为了这篇文章的目的，我们将看看如何以及在哪里我们可以只给我们的Lambda函数注入延迟，因此我故意忽略了等式的这一部分。</em></p></div><div class="ab cl ku kv hc kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hn ho hp hq hr"><h1 id="ef5e" class="ls lt hu bd lu lv nk lx ly lz nl mb mc ja nm jb me jd nn je mg jg no jh mi mj dt translated">如何注入延迟</h1><p id="1f56" class="pw-post-body-paragraph jj jk hu jl b jm mk iv jo jp ml iy jr js mm ju jv jw mn jy jz ka mo kc kd ke hn dt translated">实际引入延迟有两个方面:</p><ol class=""><li id="fcef" class="kf kg hu jl b jm jn jp jq js kh jw ki ka kj ke np kl km kn dt translated">增加操作延迟</li><li id="d2ce" class="kf kg hu jl b jm kp jp kq js kr jw ks ka kt ke np kl km kn dt translated">配置添加频率和延迟时间</li></ol><p id="a5c4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你读过我以前的关于<a class="ae ko" href="https://hackernoon.com/capture-and-forward-correlation-ids-through-different-lambda-event-sources-220c227c65f5" rel="noopener ugc nofollow" target="_blank">捕获和转发关联id</a>和<a class="ae ko" href="https://hackernoon.com/you-should-use-ssm-parameter-store-over-lambda-env-variables-5197fc6ea45b" rel="noopener ugc nofollow" target="_blank">用SSM参数存储管理配置</a>的帖子，那么你已经看到了我们需要做这两项工作的基本构件。</p><h2 id="c911" class="mq lt hu bd lu mr ms mt ly mu mv mw mc js mx my me jw mz na mg ka nb nc mi nd dt translated">如何给HTTP客户端注入延迟</h2><p id="064c" class="pw-post-body-paragraph jj jk hu jl b jm mk iv jo jp ml iy jr js mm ju jv jw mn jy jz ka mo kc kd ke hn dt translated">由于您不太可能从头开始编写HTTP客户端，所以我认为向HTTP客户端和第三方客户端(如AWS SDK)注入延迟的问题是同一个问题。</p><p id="b383" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我想到了几个解决方案:</p><ul class=""><li id="ff96" class="kf kg hu jl b jm jn jp jq js kh jw ki ka kj ke kk kl km kn dt translated">在静态语言中，你可以考虑使用静态weaver，比如AspectJ或PostSharp，这是我之前采用的方法</li><li id="cddd" class="kf kg hu jl b jm kp jp kq js kr jw ks ka kt ke kk kl km kn dt translated">在静态语言中，您可以考虑使用动态代理，这是许多IoC框架提供的(AOP的另一种形式)</li><li id="f1ea" class="kf kg hu jl b jm kp jp kq js kr jw ks ka kt ke kk kl km kn dt translated">您可以<strong class="jl hv">为客户端</strong>创建一个包装器，既可以手动创建，也可以使用工厂函数创建(bluebirdjs 的<code class="eh nq nr ns nt b">promisifyAll</code>函数就是一个很好的例子)</li></ul><p id="1211" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因为我将使用Node.js作为例子，所以我将把重点放在包装器上。</p><p id="25e6" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于HTTP客户端，考虑到您需要的方法数量相对较少，手工制作包装器是可行的，尤其是如果您有特定的API设计的话。</p><p id="323f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">使用我为<a class="ae ko" href="https://hackernoon.com/capture-and-forward-correlation-ids-through-different-lambda-event-sources-220c227c65f5" rel="noopener ugc nofollow" target="_blank"> correlation ID post </a>创建的HTTP客户端作为基础，我修改了它以接受一个配置对象来控制延迟注入行为。</p><pre class="lc ld le lf fq nu nt nv nw aw nx dt"><span id="fe1f" class="mq lt hu nt b fv ny nz l oa ob">{<br/>  "isEnabled": true,<br/>  "probability": 0.5,<br/>  "minDelay": 100,<br/>  "maxDelay": 5000<br/>}</span></pre><p id="e1ca" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可以在这里找到这个修改过的HTTP客户端<a class="ae ko" href="https://github.com/theburningmonk/lambda-latency-injection-demo/blob/master/lib/http.js" rel="noopener ugc nofollow" target="_blank">，下面是这个客户端的简化版本(它在引擎盖下使用了<code class="eh nq nr ns nt b">superagent</code>)。</a></p><figure class="lc ld le lf fq lg"><div class="bz el l di"><div class="oc od l"/></div></figure><p id="167b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了配置函数和延迟注入行为，我们可以使用我最初在<a class="ae ko" href="https://hackernoon.com/you-should-use-ssm-parameter-store-over-lambda-env-variables-5197fc6ea45b" rel="noopener ugc nofollow" target="_blank"> SSM参数存储帖子</a>中创建的<code class="eh nq nr ns nt b">configClient</code>。</p><p id="6cc4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">首先，让我们在SSM参数存储中创建配置。</p><figure class="lc ld le lf fq lg fe ff paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="fe ff oe"><img src="../Images/855be5f44dac1d0ce81e15346e1c5c82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PYjvT-0C_7h4Ik-bRJzq5Q.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">You can create and optionally encrypt parameter values in the SSM Parameter Store.</figcaption></figure><p id="3ec1" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">配置包含内部API的URL，以及一个<code class="eh nq nr ns nt b">chaosConfig</code>对象。目前，我们只有一个<code class="eh nq nr ns nt b">httpClientLatencyInjectionConfig</code>属性，用于控制HTTP客户端的延迟注入行为。</p><pre class="lc ld le lf fq nu nt nv nw aw nx dt"><span id="73dd" class="mq lt hu nt b fv ny nz l oa ob">{ <br/>  "internalApi": "https://xx.amazonaws.com/dev/internal", <br/>  "chaosConfig": {<br/>    "httpClientLatencyInjectionConfig": {<br/>      "isEnabled": true,<br/>      "probability": 0.5,<br/>      "minDelay": 100,<br/>      "maxDelay": 5000<br/>    }<br/>  } <br/>}</span></pre><p id="59c6" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">使用前面提到的<code class="eh nq nr ns nt b">configClient</code>，我们可以在运行时从SSM参数存储中获取JSON配置。</p><pre class="lc ld le lf fq nu nt nv nw aw nx dt"><span id="f87e" class="mq lt hu nt b fv ny nz l oa ob">const configKey = "public-api-a.config";<br/>const configObj = configClient.loadConfigs([ configKey ]);</span><span id="c2c0" class="mq lt hu nt b fv of nz l oa ob">let config = JSON.parse(yield configObj["public-api-a.config"]);<br/>let internalApiUrl = config.internalApi;<br/>let chaosConfig = config.chaosConfig || {};<br/>let injectionConfig = chaosConfig.httpClientLatencyInjectionConfig;</span><span id="09a6" class="mq lt hu nt b fv of nz l oa ob">let reply = yield http({ <br/>  method : 'GET', <br/>  uri : internalApiUrl, <br/>  latencyInjectionConfig: injectionConfig <br/>});</span></pre><p id="0920" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当我们向<code class="eh nq nr ns nt b">internal-api</code>发出HTTP请求时，上面的配置给了我们50%的机会注入100毫秒到5秒之间的延迟。</p><p id="7788" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这反映在下面的X射线跟踪中。</p><figure class="lc ld le lf fq lg fe ff paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="fe ff og"><img src="../Images/418e7464344b9385f46e7bca3d131ac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9P-2pdNwjURMuXncAeHUXg.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">From this X-Ray trace, you can see that 287ms of latency was injected to the HTTP request.</figcaption></figure><figure class="lc ld le lf fq lg fe ff paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="fe ff oh"><img src="../Images/f3a9856a61944be9774914cebc68e992.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tIZPJpE2zU6byCnyWjP-Sw.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">In this trace, you see the amount of latency injected was a hefty 3.4 sec!</figcaption></figure><figure class="lc ld le lf fq lg fe ff paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="fe ff oi"><img src="../Images/c34004c9ee2383111502cb5b779a4114.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NPRbkqFjCwXiVnjfwhA1pA.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">From this X-Ray trace, you can see no latency was injected to the HTTP request, so the overall invocation time was also very small by comparison.</figcaption></figure><h2 id="1574" class="mq lt hu bd lu mr ms mt ly mu mv mw mc js mx my me jw mz na mg ka nb nc mi nd dt translated">如何给AWSSDK注入延迟</h2><p id="b0de" class="pw-post-body-paragraph jj jk hu jl b jm mk iv jo jp ml iy jr js mm ju jv jw mn jy jz ka mo kc kd ke hn dt translated">使用AWS SDK，手工制作包装器是不可行的。相反，我们可以使用类似于蓝鸟的工厂功能。</p><p id="b5e3" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以在这里应用同样的方法，我做了一个简单的尝试。<em class="nf">我必须补充一点，虽然我认为自己是一名</em> <a class="ae ko" href="https://en.wikipedia.org/wiki/Dreyfus_model_of_skill_acquisition" rel="noopener ugc nofollow" target="_blank"> <em class="nf">称职的</em></a><em class="nf">Node.js/Javascript程序员，但我确信有更好的方法来实现这个工厂功能。</em></p><p id="0bad" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我的工厂函数只适用于承诺对象(告诉过你这很粗糙)..)，并用一个包装器替换它们的<code class="eh nq nr ns nt b">xxxAsync</code>函数，该包装器接受该形状的另一个参数:</p><pre class="lc ld le lf fq nu nt nv nw aw nx dt"><span id="8d80" class="mq lt hu nt b fv ny nz l oa ob">{<br/>  "isEnabled": true,<br/>  "probability": 0.5,<br/>  "minDelay": 100,<br/>  "maxDelay": 3000<br/>}</span></pre><p id="85bd" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">同样，这很笨拙，但是我们可以从AWS SDK中取出<code class="eh nq nr ns nt b">DocumentClient</code>,用bluebird对其进行承诺，然后用我们自己的包装器工厂包装承诺的对象。然后，我们可以用可选参数调用它的异步函数来控制延迟注入行为。</p><p id="51af" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您可以在<code class="eh nq nr ns nt b">public-api-b</code>的处理函数中看到这一点。</p><figure class="lc ld le lf fq lg"><div class="bz el l di"><div class="oc od l"/></div></figure><p id="1dfd" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">出于某种原因，包装功能无法记录X射线中的子段。我怀疑这是Javascript或X-Ray SDK的一些细微差别，我没有完全理解。</p><p id="c247" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">尽管如此，从日志判断，我可以确认包装的函数确实给对DynamoDB的<code class="eh nq nr ns nt b">getAsync</code>调用增加了延迟。</p><figure class="lc ld le lf fq lg fe ff paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="fe ff oj"><img src="../Images/51349c539e6e7e2cc1886b63b6bb907f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w3Do1LX9r9naM7jcMs2XsQ.png"/></div></div></figure><p id="5c84" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你知道一种改进工厂功能的方法，或者通过包装功能获得X射线追踪工作，请在评论中告诉我。</p><h2 id="4d5e" class="mq lt hu bd lu mr ms mt ly mu mv mw mc js mx my me jw mz na mg ka nb nc mi nd dt translated">如何给函数调用注入延迟</h2><p id="ad69" class="pw-post-body-paragraph jj jk hu jl b jm mk iv jo jp ml iy jr js mm ju jv jw mn jy jz ka mo kc kd ke hn dt translated">我在<a class="ae ko" href="https://hackernoon.com/capture-and-forward-correlation-ids-through-different-lambda-event-sources-220c227c65f5" rel="noopener ugc nofollow" target="_blank">关联ID帖子</a>中创建的<code class="eh nq nr ns nt b">apiHandler</code>工厂函数是应用我们希望从API函数中得到的<strong class="jl hv">通用实现模式</strong>的好地方，包括:</p><ul class=""><li id="7e6c" class="kf kg hu jl b jm jn jp jq js kh jw ki ka kj ke kk kl km kn dt translated">将事件源记录为调试</li><li id="f697" class="kf kg hu jl b jm kp jp kq js kr jw ks ka kt ke kk kl km kn dt translated">记录调用的响应和/或错误(令人惊讶的是，Lambda在默认情况下并不捕捉这些)</li><li id="27fd" class="kf kg hu jl b jm kp jp kq js kr jw ks ka kt ke kk kl km kn dt translated">初始化全局上下文(例如，用于跟踪相关id)</li><li id="caa6" class="kf kg hu jl b jm kp jp kq js kr jw ks ka kt ke kk kl km kn dt translated">处理响应对象的序列化</li><li id="8ea9" class="kf kg hu jl b jm kp jp kq js kr jw ks ka kt ke kk kl km kn dt translated">等等..</li></ul><pre class="lc ld le lf fq nu nt nv nw aw nx dt"><span id="8e21" class="mq lt hu nt b fv ny nz l oa ob">// this is how you use the apiHandler factory function to create a<br/>// handler function for API Gateway event source<br/>module.exports.handler = apiHandler(<br/>  co.wrap(function* (event, context) {<br/>    ... // do bunch of stuff<br/>    <br/>    // instead of invoking the callback directly, you return the<br/>    // response you want to send, and the wrapped handler function<br/>    // would handle the serialization and invoking callback for you<br/>    // also, it takes care of other things for you, like logging<br/>    // the event source, and logging unhandled exceptions, etc.<br/>   return { message : "everything is awesome" };<br/>  })<br/>);</span></pre><p id="fcd6" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这种情况下，这也是我们向API函数注入延迟的好地方。</p><p id="d3d7" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然而，要做到这一点，我们需要访问该功能的配置。是时候解除将配置提取到<code class="eh nq nr ns nt b">apiHandler</code>工厂的责任了！</p><p id="02b6" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">完整的<code class="eh nq nr ns nt b">apiHandler</code>工厂函数可以在<a class="ae ko" href="https://github.com/theburningmonk/lambda-latency-injection-demo/blob/master/lib/apiHandler.js" rel="noopener ugc nofollow" target="_blank">这里</a>找到，下面是说明这一点的简化版本。</p><figure class="lc ld le lf fq lg"><div class="bz el l di"><div class="oc od l"/></div></figure><p id="5a60" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，我们可以像下面这样编写我们的API函数。</p><figure class="lc ld le lf fq lg"><div class="bz el l di"><div class="oc od l"/></div></figure><p id="db7b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">既然<code class="eh nq nr ns nt b">apiHandler</code>已经可以访问函数的配置，那么它也可以访问<code class="eh nq nr ns nt b">chaosConfig</code>对象。</p><p id="5fc9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们扩展<code class="eh nq nr ns nt b">chaosConfig</code>对象的定义，添加一个<code class="eh nq nr ns nt b">functionLatencyInjectionConfig</code>属性。</p><pre class="lc ld le lf fq nu nt nv nw aw nx dt"><span id="4c38" class="mq lt hu nt b fv ny nz l oa ob">"chaosConfig": {<br/>  "functionLatencyInjectionConfig": {<br/>    "isEnabled": true,<br/>    "probability": 0.5,<br/>    "minDelay": 100,<br/>    "maxDelay": 5000<br/>  },<br/>  "httpClientLatencyInjectionConfig": {<br/>    "isEnabled": true,<br/>    "probability": 0.5,<br/>    "minDelay": 100,<br/>    "maxDelay": 5000<br/>  }<br/>}</span></pre><p id="7a31" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有了这个额外的配置，我们可以修改<code class="eh nq nr ns nt b">apiHandler</code>工厂函数，用它给函数调用注入延迟，就像我们在HTTP客户端所做的一样。</p><figure class="lc ld le lf fq lg"><div class="bz el l di"><div class="oc od l"/></div></figure><p id="1a42" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">就像这样，我们现在可以通过配置给函数调用注入延迟。这将适用于任何使用<code class="eh nq nr ns nt b">apiHandler</code>工厂创建的API函数。</p><p id="6be2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有了这一改变和两种类型的延迟注入，我可以通过X射线观察所有预期的场景:</p><ul class=""><li id="4477" class="kf kg hu jl b jm jn jp jq js kh jw ki ka kj ke kk kl km kn dt translated">没有注入延迟</li></ul><figure class="lc ld le lf fq lg fe ff paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="fe ff ok"><img src="../Images/b9258db68383e8ae80302461c8abb7c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-V6X-GlJfQEaDQ5w1bC8Qg.png"/></div></div></figure><ul class=""><li id="4584" class="kf kg hu jl b jm jn jp jq js kh jw ki ka kj ke kk kl km kn dt translated">延迟仅被注入到函数调用中</li></ul><figure class="lc ld le lf fq lg fe ff paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="fe ff ol"><img src="../Images/9368de7bb622e2e23be03833c03ec05e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y_e8kFa3W1amtYlxuJNFsQ.png"/></div></div></figure><ul class=""><li id="04a8" class="kf kg hu jl b jm jn jp jq js kh jw ki ka kj ke kk kl km kn dt translated">延迟仅注入到HTTP客户端</li></ul><figure class="lc ld le lf fq lg fe ff paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="fe ff om"><img src="../Images/269e46f9be525f21a54bbfe7f2b0e979.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*08ww8O1piVS09_nEfNViEw.png"/></div></div></figure><ul class=""><li id="b4f5" class="kf kg hu jl b jm jn jp jq js kh jw ki ka kj ke kk kl km kn dt translated">HTTP客户端和函数调用都有延迟，但是调用并没有因此超时</li></ul><figure class="lc ld le lf fq lg fe ff paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="fe ff on"><img src="../Images/280e3e3eebf0866141f04d3526374089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XEgx4nzoAG-6qHOUE3FhGg.png"/></div></div></figure><ul class=""><li id="2fb9" class="kf kg hu jl b jm jn jp jq js kh jw ki ka kj ke kk kl km kn dt translated">HTTP客户端和函数调用都存在延迟，结果导致调用超时</li></ul><figure class="lc ld le lf fq lg fe ff paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="fe ff oo"><img src="../Images/a73fefb1fcef14d163a66602b891ee57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B0T-Ug0da6qYIBlKsjv03A.png"/></div></div></figure><p id="3a84" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我可以通过日志和X射线轨迹中记录的元数据进一步确认预期的行为。</p><figure class="lc ld le lf fq lg fe ff paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="fe ff op"><img src="../Images/60f868f60bd7b5722d69ab9beb811013.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1z7Ne-x_jNSRYBTPBrSQMQ.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">From the logs, you can see how much latency was injected.</figcaption></figure><figure class="lc ld le lf fq lg fe ff paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="fe ff oq"><img src="../Images/57a4a211c00ebdf7e4b4f1df1df8cde5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q3LUlxuKmyYfHsnQVPjHMA.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">The amount of injected latency was also recorded as metadata in the X-Ray trace as well.</figcaption></figure><h1 id="ce33" class="ls lt hu bd lu lv lw lx ly lz ma mb mc ja md jb me jd mf je mg jg mh jh mi mj dt translated">总结和未来的工作</h1><p id="9ff0" class="pw-post-body-paragraph jj jk hu jl b jm mk iv jo jp ml iy jr js mm ju jv jw mn jy jz ka mo kc kd ke hn dt translated">在这篇文章中，我们讨论了:</p><ul class=""><li id="0f64" class="kf kg hu jl b jm jn jp jq js kh jw ki ka kj ke kk kl km kn dt translated">为什么您应该考虑将延迟注入的实践应用到用API Gateway和Lambda创建的API中</li><li id="50ed" class="kf kg hu jl b jm kp jp kq js kr jw ks ka kt ke kk kl km kn dt translated">特定于API网关和Lambda的其他注意事项</li><li id="46e1" class="kf kg hu jl b jm kp jp kq js kr jw ks ka kt ke kk kl km kn dt translated">您可以在哪些地方引入延迟，以及为什么应该考虑在这些地方引入延迟</li><li id="6f86" class="kf kg hu jl b jm kp jp kq js kr jw ks ka kt ke kk kl km kn dt translated">如何在HTTP客户端、AWS SDK以及函数调用中引入延迟</li></ul><p id="867a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们在这里讨论的方法是由配置驱动的，默认情况下配置<a class="ae ko" href="https://github.com/theburningmonk/lambda-latency-injection-demo/blob/master/lib/configClient.js#L9" rel="noopener ugc nofollow" target="_blank">每3分钟刷新一次</a>。</p><p id="4f19" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以更进一步。</p><h2 id="9bca" class="mq lt hu bd lu mr ms mt ly mu mv mw mc js mx my me jw mz na mg ka nb nc mi nd dt translated">细粒度配置</h2><p id="9650" class="pw-post-body-paragraph jj jk hu jl b jm mk iv jo jp ml iy jr js mm ju jv jw mn jy jz ka mo kc kd ke hn dt translated">配置可以更细粒度，并允许您控制特定资源的延迟注入。</p><p id="fcf5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">例如，配置可以特定于一个API或一个DynamoDB表，而不是针对所有HTTP请求(包括对AWS服务的请求)的一揽子<code class="eh nq nr ns nt b">httpClientLatencyInjectionConfig</code>。</p><h2 id="fc8c" class="mq lt hu bd lu mr ms mt ly mu mv mw mc js mx my me jw mz na mg ka nb nc mi nd dt translated">自动化</h2><p id="84e5" class="pw-post-body-paragraph jj jk hu jl b jm mk iv jo jp ml iy jr js mm ju jv jw mn jy jz ka mo kc kd ke hn dt translated">这些配置可以通过自动化流程进行更改，以便:</p><ul class=""><li id="acd6" class="kf kg hu jl b jm jn jp jq js kh jw ki ka kj ke kk kl km kn dt translated">每天运行例行验证</li><li id="fa89" class="kf kg hu jl b jm kp jp kq js kr jw ks ka kt ke kk kl km kn dt translated">在下班时间和节假日停止所有延迟注入</li><li id="607c" class="kf kg hu jl b jm kp jp kq js kr jw ks ka kt ke kk kl km kn dt translated">强制停止所有延迟注入，例如在实际断电期间</li><li id="ee3c" class="kf kg hu jl b jm kp jp kq js kr jw ks ka kt ke kk kl km kn dt translated">编排难以手动管理的复杂场景，例如，同时在几个地方启用延迟注入</li></ul><p id="a24d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">同样，我们可以向网飞寻求这样一个自动化平台的灵感。</p><p id="db1a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通常，您会希望在有限的上下文中一次启用一个延迟注入。这有助于控制意外伤害的爆炸半径，并确保你的实验实际上是由<em class="nf">控制的</em>。此外，当潜伏期在几个地方注入时，由于有多个变量需要考虑，因此更难理解我们观察到的因果关系。</p><p id="8176" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当然，除非你在验证特定的假设，比如:</p><blockquote class="or os ot"><p id="b6ce" class="jj jk nf jl b jm jn iv jo jp jq iy jr ou jt ju jv ov jx jy jz ow kb kc kd ke hn dt translated">根据用户偏好，系统可以容忍<strong class="jl hv">主存储(DynamoDB)和备份存储(S3)的中断，并在这种情况下返回硬编码的默认值。</strong></p></blockquote><h2 id="fd2c" class="mq lt hu bd lu mr ms mt ly mu mv mw mc js mx my me jw mz na mg ka nb nc mi nd dt translated">更好的沟通</h2><p id="7b9d" class="pw-post-body-paragraph jj jk hu jl b jm mk iv jo jp ml iy jr js mm ju jv jw mn jy jz ka mo kc kd ke hn dt translated">另一件要做的事情是通知调用者延迟已经被故意添加到调用中。</p><p id="1426" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这可能采取响应中HTTP头的形式，告诉调用者总共注入了多少延迟。如果您使用自动化过程来生成这些实验，那么您还应该将实验的特定实例的id/tag/name作为HTTP头包含进来。</p><h1 id="12b4" class="ls lt hu bd lu lv lw lx ly lz ma mb mc ja md jb me jd mf je mg jg mh jh mi mj dt translated">下一步是什么？</h1><p id="2084" class="pw-post-body-paragraph jj jk hu jl b jm mk iv jo jp ml iy jr js mm ju jv jw mn jy jz ka mo kc kd ke hn dt translated">正如我在上一篇文章中提到的，在决定何时何地应用混沌工程实践时，你需要运用常识。</p><p id="4385" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不要尝试你知道超出你能力的练习。</p><p id="551c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在您考虑将延迟注入应用到生产中的API之前，您需要考虑如何在API Gateway和Lambda的内在约束下处理这些延迟峰值。</p><p id="e867" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不幸的是，我们已经没有时间在本帖中讨论这个问题了，但是两周后再回来，我们将在第3部分讨论你可以采用的几种策略。</p><p id="00dd" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这篇文章中演示的代码可以在github <a class="ae ko" href="https://github.com/theburningmonk/lambda-latency-injection-demo/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。请随意使用它，如果您有任何改进的建议，请告诉我！</p><h1 id="10d8" class="ls lt hu bd lu lv lw lx ly lz ma mb mc ja md jb me jd mf je mg jg mh jh mi mj dt translated">参考</h1><ul class=""><li id="b1ca" class="kf kg hu jl b jm mk jp ml js ox jw oy ka oz ke kk kl km kn dt translated"><a class="ae ko" href="http://jlouisramblings.blogspot.co.uk/2012/12/hacking-brains-of-other-people-with-api.html" rel="noopener ugc nofollow" target="_blank">用API设计黑别人的脑子</a></li><li id="2e57" class="kf kg hu jl b jm kp jp kq js kr jw ks ka kt ke kk kl km kn dt translated"><a class="ae ko" href="http://theburningmonk.com/2015/04/design-for-latency-issues/" rel="noopener ugc nofollow" target="_blank">针对延迟问题的设计</a></li><li id="8e7f" class="kf kg hu jl b jm kp jp kq js kr jw ks ka kt ke kk kl km kn dt translated"><a class="ae ko" href="https://hackernoon.com/capture-and-forward-correlation-ids-through-different-lambda-event-sources-220c227c65f5" rel="noopener ugc nofollow" target="_blank">通过不同的Lambda事件源捕获和转发关联id</a></li><li id="e1db" class="kf kg hu jl b jm kp jp kq js kr jw ks ka kt ke kk kl km kn dt translated"><a class="ae ko" href="https://hackernoon.com/you-should-use-ssm-parameter-store-over-lambda-env-variables-5197fc6ea45b" rel="noopener ugc nofollow" target="_blank">你应该在Lambda环境变量上使用SSM参数存储</a></li><li id="dea3" class="kf kg hu jl b jm kp jp kq js kr jw ks ka kt ke kk kl km kn dt translated"><a class="ae ko" rel="noopener" href="/netflix-techblog/chap-chaos-automation-platform-53e6d528371f">章节:混沌自动化平台</a></li></ul></div><div class="ab cl ku kv hc kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hn ho hp hq hr"><figure class="lc ld le lf fq lg fe ff paragraph-image"><div class="ab fr cl pa"><img src="../Images/8b4e4721bb1973db389b5b533d727ad1.png" data-original-src="https://miro.medium.com/v2/format:webp/0*b_1R345KzKSaI8sg.png"/></div></figure><p id="f870" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">嗨，我叫<strong class="jl hv">崔琰</strong>。我是一个<a class="ae ko" href="https://aws.amazon.com/developer/community/heroes/yan-cui/" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hv"> AWS无服务器英雄</strong> </a>和<a class="ae ko" href="https://bit.ly/production-ready-serverless" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hv">量产无服务器</strong> </a>的作者。我已经在AWS中运行了近10年的大规模生产工作负载，我是一名架构师或首席工程师，涉足从银行、电子商务、体育流媒体到移动游戏等多个行业。我目前是一名专注于AWS和无服务器的独立顾问。</p><p id="c37e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可以通过<a class="ae ko" href="mailto:theburningmonk.com" rel="noopener ugc nofollow" target="_blank">邮箱</a>、<a class="ae ko" href="https://twitter.com/theburningmonk" rel="noopener ugc nofollow" target="_blank">推特</a>和<a class="ae ko" href="https://www.linkedin.com/in/theburningmonk/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我。</p></div><div class="ab cl ku kv hc kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hn ho hp hq hr"><p id="404d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">查看我的新课程，<a class="ae ko" href="https://theburningmonk.thinkific.com/courses/complete-guide-to-aws-step-functions" rel="noopener ugc nofollow" target="_blank"><strong class="jl hv">AWS步骤功能完全指南</strong> </a>。</p><p id="a329" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在本课程中，我们将介绍有效使用AWS Step Functions服务所需了解的一切。包括基本概念、HTTP和事件触发器、活动、设计模式和最佳实践。</p><p id="cd40" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">点击获取您的副本<a class="ae ko" href="https://theburningmonk.thinkific.com/courses/complete-guide-to-aws-step-functions" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl ku kv hc kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hn ho hp hq hr"><figure class="lc ld le lf fq lg fe ff paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="fe ff pb"><img src="../Images/2faf40b47320300fed81b3e09483ffb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZYcHhOOzUf5VB-Ri.png"/></div></div></figure><p id="ee8c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">来了解AWS Lambda: CI/CD的操作性<strong class="jl hv">最佳实践</strong>，本地测试&amp;调试功能、日志记录、监控、分布式跟踪、canary部署、配置管理、认证&amp;授权、VPC、安全性、错误处理等等。</p><p id="8bb5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">还可以用代码<strong class="jl hv"> ytcui </strong>获得<strong class="jl hv">票面价格4折</strong>。</p><p id="f62a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">点击获取您的副本<a class="ae ko" href="https://bit.ly/production-ready-serverless" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>