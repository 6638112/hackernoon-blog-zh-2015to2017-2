<html>
<head>
<title>Tangled Webs: Testing an Integrated System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">纠结的网:测试集成系统</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/tangled-webs-testing-an-integrated-system-d65cd40bf27e?source=collection_archive---------33-----------------------#2017-10-23">https://medium.com/hackernoon/tangled-webs-testing-an-integrated-system-d65cd40bf27e?source=collection_archive---------33-----------------------#2017-10-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="396c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在过去的几篇文章中，我们结合了几个有用的Haskell库来制作一个小型的web应用程序。我们使用<a class="ae jp" href="https://hackage.haskell.org/package/persistent" rel="noopener ugc nofollow" target="_blank"> Persistent </a>为我们的数据库创建一个自动迁移的模式。然后我们使用<a class="ae jp" href="https://hackage.haskell.org/package/servant" rel="noopener ugc nofollow" target="_blank"> Servant </a>通过几个简单的查询将这个数据库公开为API。最后，我们使用<a class="ae jp" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>作为缓存，以便对同一用户的重复请求发生得更快。</p><p id="262d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下一步，我们将处理一个棘手的问题:测试。我们如何测试一个有这么多移动部件的系统？我们可以采用几种不同的通用方法。在光谱的一端，我们可以模仿我们的大多数API调用和服务。这有助于给我们的测试确定性的行为。这是可取的，因为我们希望将部署与测试结果联系起来。但是我们也想忠实地测试我们的API。另一方面，这是我们将在本文中尝试的方法。我们将设置函数来运行我们的API和其他服务，然后使用before和after钩子来使用它们。</p><h1 id="5d30" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">为我们的API创建客户端函数</h1><p id="d10c" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">从测试中调用我们的API意味着我们需要一种以编程方式进行API调用的方法。通过使用<code class="eh kt ku kv kw b">servant-client</code>库，我们可以用一个服务API非常轻松地做到这一点。这个库有一个主要功能:<code class="eh kt ku kv kw b">client</code>。这个函数接受我们的API的代理，并生成可编程的客户端函数。让我们记住我们的基本端点类型(在解析连接信息参数之后):</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="0057" class="lf jr hu kw b fv lg lh l li lj">fetchUsersHandler :: Int64 -&gt; Handler User<br/>createUserHandler :: User -&gt; Handler Int64</span></pre><p id="3b61" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们希望能够用使用相同参数的函数调用这些API。这些类型可能如下所示:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="3e60" class="lf jr hu kw b fv lg lh l li lj">fetchUserClient :: Int64 -&gt; m User<br/>createUserClient :: User -&gt; m Int64</span></pre><p id="a734" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">其中<code class="eh kt ku kv kw b">m</code>是一些单子。在这种情况下，<code class="eh kt ku kv kw b">ServantClient</code>库提供了这样一个单子，<code class="eh kt ku kv kw b">ClientM</code>。所以让我们重写这些类型签名，但是让它们看起来没有实现:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="a782" class="lf jr hu kw b fv lg lh l li lj">fetchUserClient :: Int64 -&gt; ClientM User<br/>createUserClient :: User -&gt; ClientM Int64</span></pre><p id="4ad3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们将构建一个模式匹配，用<code class="eh kt ku kv kw b">:&lt;|&gt;</code>操作符组合这些函数名。和往常一样，我们需要确保我们按照与原始API类型相同的顺序来做这件事。然后，我们将这个模式设置为在API的代理上调用<code class="eh kt ku kv kw b">client</code>的结果:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="4b38" class="lf jr hu kw b fv lg lh l li lj">fetchUserClient :: Int64 -&gt; ClientM User<br/>createUserClient :: User -&gt; ClientM Int64<br/>(fetchUserClient :&lt;|&gt; createUserClient) = client (Proxy :: Proxy UsersAPI)</span></pre><p id="928d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就是这样！仆人库为我们填充细节并实现这些功能！我们将在本文的后面看到如何实际调用这些函数。</p><h1 id="c3b8" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">设置测试</h1><p id="ab8c" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们想要开始决定我们的测试用例并编写它们。但是首先我们需要确保我们的测试有一个合适的环境。这意味着三件事。首先，我们需要获取数据存储和API的连接信息。这意味着我们将使用<code class="eh kt ku kv kw b">PGInfo</code>、<code class="eh kt ku kv kw b">RedisInfo</code>和<code class="eh kt ku kv kw b">ClientEnv</code>来调用我们编写的客户端函数。第二，我们需要实际迁移我们的数据库，以便它有正确的表。第三，我们需要确保我们的服务器确实在运行。让我们从连接信息开始，因为这很简单:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="6d1d" class="lf jr hu kw b fv lg lh l li lj">import Database (fetchPostgresConnection, fetchRedisConnection)</span><span id="b722" class="lf jr hu kw b fv lk lh l li lj">...</span><span id="6129" class="lf jr hu kw b fv lk lh l li lj">setupTests = do<br/>  pgInfo &lt;- fetchPostgresConnection<br/>  redisInfo &lt;- fetchRedisConnection<br/>  ...</span></pre><p id="c02a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在要创建我们的客户机环境，我们需要两件主要的东西。我们需要一个网络连接管理器和API的基本URL。因为我们在本地运行API，所以我们将使用本地主机URL。来自<code class="eh kt ku kv kw b">Network</code>库的默认管理器对我们来说很好:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="29f1" class="lf jr hu kw b fv lg lh l li lj">import Network.HTTP.Client (newManager)<br/>import Network.HTTP.Client.TLS (tlsManagerSettings)<br/>import Servant.Client (ClientEnv(..))</span><span id="59c8" class="lf jr hu kw b fv lk lh l li lj">main = do<br/>  pgInfo &lt;- fetchPostgresConnection<br/>  redisInfo &lt;- fetchRedisConnection<br/>  mgr &lt;- newManager tlsManagerSettings<br/>  baseUrl &lt;- parseBaseUrl "http://127.0.0.1:8000"<br/>  let clientEnv = ClientEnv mgr baseUrl</span></pre><p id="d744" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们可以运行我们的迁移，这将确保我们的<code class="eh kt ku kv kw b">users</code>表存在:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="13bc" class="lf jr hu kw b fv lg lh l li lj">import Schema (migrateAll)</span><span id="0ba1" class="lf jr hu kw b fv lk lh l li lj">main = do<br/>  pgInfo &lt;- fetchPostgresConnection<br/>  ...<br/>  runStdoutLoggingT $ withPostgresqlConn pgInfo $ \dbConn -&gt;<br/>    runReaderT (runMigrationSilent migrateAll) dbConn</span></pre><p id="4440" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我们将使用API模块中的<code class="eh kt ku kv kw b">runServer</code>来启动服务器。我们将把它分叉到一个单独的线程，否则它将阻塞测试线程！之后，我们将等待一秒钟，以确保它在测试运行之前实际加载(当然，有更简单的方法可以做到这一点)。但是我们将返回我们需要的所有重要信息，并且我们完成了测试设置:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="6b49" class="lf jr hu kw b fv lg lh l li lj">main :: IO (PGInfo, RedisInfo, ClientEnv, ThreadID)<br/>main = do<br/>  pgInfo &lt;- fetchPostgresConnection<br/>  redisInfo &lt;- fetchRedisConnection<br/>  mgr &lt;- newManager tlsManagerSettings<br/>  baseUrl &lt;- parseBaseUrl "http://127.0.0.1:8000"<br/>  let clientEnv = ClientEnv mgr baseUrl<br/>  runStdoutLoggingT $ withPostgresqlConn pgInfo $ \dbConn -&gt;<br/>    runReaderT (runMigrationSilent migrateAll) dbConn<br/>  threadId &lt;- forkIO runServer<br/>  threadDelay 1000000<br/>  return (pgInfo, redisInfo, clientEnv, serverThreadId)</span></pre><h1 id="9a60" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">组织我们的3个测试案例</h1><p id="6893" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">现在我们都设置好了，我们可以决定我们的测试用例了。我们来看看3。首先，如果我们有一个空的数据库，我们通过任意的ID获取一个用户，我们将会遇到一个错误。此外，我们应该预期用户不存在于数据库或缓存中，即使在调用了<code class="eh kt ku kv kw b">fetch</code>之后。</p><p id="cf52" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们的第二个测试案例中，我们将看看调用创建端点的效果。我们将保存从该端点获得的密钥。然后，我们将验证该用户存在于数据库中，但不存在于缓存中。最后，我们的第三个案例将使用创建端点插入用户，然后获取用户。我们希望在结束时，用户实际上同时存在于数据库和缓存中。</p><p id="81b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将每个测试组织成三个部分:“挂钩之前”、测试断言和“挂钩之后”。“挂钩之前”是我们将运行的一些IO代码，它将向我们的测试断言返回特定的结果。我们想确保它在任何测试断言之前都已经运行了。这样，在我们的测试输出和API调用之间就不会有交错的影响。每个before hook将首先进行我们想要的API调用。然后他们会调查我们不同的数据库，并确定是否存在某些用户。</p><p id="4f9b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还希望我们的测试是数据库中立的。也就是说，在测试之后，数据库和缓存应该处于与之前相同的状态。所以我们还会有“after hooks”在我们的测试完成后运行(如果我们真的创建了什么的话)。after挂钩将删除任何新条目。这意味着我们的before钩子也必须为它们创建的任何数据库实体传递键。这样after钩子就知道该删除什么了。</p><p id="2248" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，当然，我们实际上需要断言结果的测试代码。这些将非常简单，我们将在下面看到。</p><h1 id="8d7a" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">测试#1</h1><p id="0771" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">对于我们的第一个测试，我们将从客户端调用我们的API开始。我们用<code class="eh kt ku kv kw b">runClientM</code>结合我们的<code class="eh kt ku kv kw b">clientEnv</code>和<code class="eh kt ku kv kw b">fetchUserClient</code>函数。接下来，我们将确定该调用实际上会返回一个错误。然后，我们将添加两行代码，检查我们的数据库和缓存中是否有任意ID的条目。最后，我们返回所有三个布尔值:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="21b2" class="lf jr hu kw b fv lg lh l li lj">beforeHook1 :: ClientEnv -&gt; PGInfo -&gt; RedisInfo -&gt; IO (Bool, Bool, Bool)<br/>beforeHook1 clientEnv pgInfo redisInfo = do<br/>  callResult &lt;- runClientM (fetchUserClient 1) clientEnv<br/>  let throwsError = isLeft (callResult)<br/>  inPG &lt;- isJust &lt;$&gt; fetchUserPG pgInfo 1<br/>  inRedis &lt;- isJust &lt;$&gt; fetchUserRedis redisInfo 1<br/>  return (throwsError, inPG, inRedis)</span></pre><p id="76dd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们将写出我们的断言。因为我们使用一个before hook返回三个布尔值，所以我们的<code class="eh kt ku kv kw b">Spec</code>的类型将是<code class="eh kt ku kv kw b">SpecWith (Bool, Bool, Bool)</code>。每个<code class="eh kt ku kv kw b">it</code>断言都将这个布尔元组作为参数，尽管我们每行只使用一个。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="bdec" class="lf jr hu kw b fv lg lh l li lj">spec1 :: SpecWith (Bool, Bool, Bool)<br/>spec1 = describe "After fetching on an empty database" $ do<br/>  it "The fetch call should throw an error" $ \(throwsError, _, _) -&gt; throwsError `shouldBe` True<br/>  it "There should be no user in Postgres" $ \(_, inPG, _) -&gt; inPG `shouldBe` False<br/>  it "There should be no user in Redis" $ \(_, _, inRedis) -&gt; inRedis `shouldBe` False</span></pre><p id="3c60" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是我们第一次测试所需要的！我们不需要after挂钩，因为它不会给我们的数据库添加任何东西。</p><h1 id="74ba" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">测试2和3</h1><p id="3908" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">现在我们对这段代码的工作原理有了更多的了解，让我们快速看一下下一个before hook。这次我们将首先尝试创建我们的用户。如果由于某种原因失败了，我们将抛出一个错误并停止测试。然后，我们可以使用密钥来检查用户是否存在于我们的数据库和Redis中。我们返回布尔值和密钥。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="09bc" class="lf jr hu kw b fv lg lh l li lj">beforeHook2 :: ClientEnv -&gt; PGInfo -&gt; RedisInfo -&gt; IO (Bool, Bool, Int64)<br/>beforeHook2 clientEnv pgInfo redisInfo = do<br/>  userKeyEither &lt;- runClientM (createUserClient testUser) clientEnv<br/>  case userKeyEither of<br/>    Left _ -&gt; error "DB call failed on spec 2!"<br/>    Right userKey -&gt; do <br/>      inPG &lt;- isJust &lt;$&gt; fetchUserPG pgInfo userKey<br/>      inRedis &lt;- isJust &lt;$&gt; fetchUserRedis redisInfo userKey<br/>      return (inPG, inRedis, userKey)</span></pre><p id="1979" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们的规范看起来很相似。这次我们期望在Postgres中找到一个用户，而不是在Redis中。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="a342" class="lf jr hu kw b fv lg lh l li lj">spec2 :: SpecWith (Bool, Bool, Int64)<br/>spec2 = describe "After creating the user but not fetching" $ do<br/>  it "There should be a user in Postgres" $ \(inPG, _, _) -&gt; inPG `shouldBe` True<br/>  it "There should be no user in Redis" $ \(_, inRedis, _) -&gt; inRedis `shouldBe` False</span></pre><p id="a35d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们需要添加after钩子，它将从数据库和缓存中删除用户。当然，我们预计用户不会存在于缓存中，但是我们包括了这一点，因为我们在最后的示例中需要它:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="4bc2" class="lf jr hu kw b fv lg lh l li lj">afterHook :: PGInfo -&gt; RedisInfo -&gt; (Bool, Bool, Int64) -&gt; IO ()<br/>afterHook pgInfo redisInfo (_, _, key) = do<br/>  deleteUserCache redisInfo key<br/>  deleteUserPG pgInfo key</span></pre><p id="0b15" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我们将再编写一个测试用例。这将模拟前一种情况，除了我们将在中间加入一个对<code class="eh kt ku kv kw b">fetch</code>的调用。因此，我们希望用户同时在Postgres和Redis中:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="eb68" class="lf jr hu kw b fv lg lh l li lj">beforeHook3 :: ClientEnv -&gt; PGInfo -&gt; RedisInfo -&gt; IO (Bool, Bool, Int64)<br/>beforeHook3 clientEnv pgInfo redisInfo = do<br/>  userKeyEither &lt;- runClientM (createUserClient testUser) clientEnv<br/>  case userKeyEither of<br/>    Left _ -&gt; error "DB call failed on spec 3!"<br/>    Right userKey -&gt; do <br/>      _ &lt;- runClientM (fetchUserClient userKey) clientEnv <br/>      inPG &lt;- isJust &lt;$&gt; fetchUserPG pgInfo userKey<br/>      inRedis &lt;- isJust &lt;$&gt; fetchUserRedis redisInfo userKey<br/>      return (inPG, inRedis, userKey)</span><span id="8098" class="lf jr hu kw b fv lk lh l li lj">spec3 :: SpecWith (Bool, Bool, Int64)<br/>spec3 = describe "After creating the user and fetching" $ do<br/>  it "There should be a user in Postgres" $ \(inPG, _, _) -&gt; inPG `shouldBe` True<br/>  it "There should be a user in Redis" $ \(_, inRedis, _) -&gt; inRedis `shouldBe` True</span></pre><p id="fbfc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它将使用与案例2相同的after hook，所以我们完成了！</p><h1 id="67d8" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">连接并运行测试</h1><p id="7f4d" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">最后一步是用<code class="eh kt ku kv kw b">hspec</code>、<code class="eh kt ku kv kw b">before</code>和<code class="eh kt ku kv kw b">after</code>把我们所有的碎片粘在一起。下面是我们的主函数，一旦完成，它也会杀死运行服务器的线程:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="dae3" class="lf jr hu kw b fv lg lh l li lj">main :: IO ()<br/>main = do<br/>  (pgInfo, redisInfo, clientEnv, tid) &lt;- setupTests<br/>  hspec $ before (beforeHook1 clientEnv pgInfo redisInfo) spec1<br/>  hspec $ before (beforeHook2 clientEnv pgInfo redisInfo) $ after (afterHook pgInfo redisInfo) $ spec2<br/>  hspec $ before (beforeHook3 clientEnv pgInfo redisInfo) $ after (afterHook pgInfo redisInfo) $ spec3<br/>  killThread tid <br/>  return ()</span></pre><p id="279b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们的测试应该通过了！</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="61e2" class="lf jr hu kw b fv lg lh l li lj">After fetching on an empty database<br/>  The fetch call should throw an error<br/>  There should be no user in Postgres<br/>  There should be no user in Redis</span><span id="04e8" class="lf jr hu kw b fv lk lh l li lj">Finished in 0.0410 seconds<br/>3 examples, 0 failures</span><span id="c6a6" class="lf jr hu kw b fv lk lh l li lj">After creating the user but not fetching<br/>  There should be a user in Postgres<br/>  There should be no user in Redis</span><span id="c84b" class="lf jr hu kw b fv lk lh l li lj">Finished in 0.0585 seconds<br/>2 examples, 0 failures</span><span id="6bdc" class="lf jr hu kw b fv lk lh l li lj">After creating the user and fetching<br/>  There should be a user in Postgres<br/>  There should be a user in Redis</span><span id="524d" class="lf jr hu kw b fv lk lh l li lj">Finished in 0.0813 seconds<br/>2 examples, 0 failures</span></pre><h1 id="8095" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">使用Docker</h1><p id="9c7c" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">所以当我说“测试通过”时，它们现在在我的系统上工作。但是如果你克隆代码并试图运行它们，你将会失败。测试依赖于Postgres和Redis，所以如果你不运行它们，它们就会失败！让你的测试依赖于这些外部服务是很烦人的。这是我们设计测试的弱点。它增加了任何人进入你的代码库的时间。新人必须弄清楚他们需要运行哪些东西，安装它们，等等。</p><p id="ca49" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么我们如何解决这个问题呢？一个答案是通过使用<a class="ae jp" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>。Docker允许您创建包含特定服务的容器。这使您不必担心在本地机器上设置服务的细节。更重要的是，您可以将docker映像部署到远程环境中。因此develop和prod将与您的本地系统相匹配。为了设置这个过程，我们将创建一个我们希望在Docker容器上运行的服务的描述。我们用一个<code class="eh kt ku kv kw b">docker-compose</code>文件来做这件事。这是我们的样子:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="d3ee" class="lf jr hu kw b fv lg lh l li lj">version: '2'</span><span id="799f" class="lf jr hu kw b fv lk lh l li lj">services:<br/>  postgres:<br/>    image: postgres:9.6<br/>    container_name: prod-haskell-series-postgres<br/>    ports:<br/>      - "5432:5432"</span><span id="06c9" class="lf jr hu kw b fv lk lh l li lj">  redis:<br/>    image: redis:4.0<br/>    container_name: prod-haskell-series-redis<br/>    ports:<br/>      - "6379:6379"</span></pre><p id="2c23" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，您可以使用<code class="eh kt ku kv kw b">docker-compose up</code>为您的Docker机器启动这些服务。当然，你必须安装并运行Docker。但如果你有几种不同的服务，这是一个更容易的入门过程。更好的是,“compose”文件确保每个人都使用这些服务的相同版本。</p><p id="01fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">即使这个容器在运行，测试仍然会失败！这是因为您还需要测试本身在您的Docker集群上运行。但是有了Stack，这就简单了！我们将把以下标志添加到我们的<code class="eh kt ku kv kw b">stack.yaml</code>文件中:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="31e9" class="lf jr hu kw b fv lg lh l li lj">docker:<br/>  enable: true</span></pre><p id="71dd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，无论你何时构建和测试你的程序，你都可以在Docker上完成。第一次这样做时，Docker需要在容器上设置好一切。这意味着它将不得不下载栈和你使用的所有不同的软件包。所以第一次运行需要一段时间。但是随后的运行将是正常的。所有这些完成后，现在测试应该工作了！</p><h1 id="4858" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">结论</h1><p id="aace" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">测试集成系统很难。我们可以尝试模仿外部服务的行为。但是这可能导致我们的程序的测试表示不忠实于生产系统。但是使用Hspec的<code class="eh kt ku kv kw b">before</code>和<code class="eh kt ku kv kw b">after</code>挂钩是确保所有外部事件首先发生的好方法。然后，您可以将这些结果传递给更简单的测试断言。</p><p id="74bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当需要运行您的系统时，如果您可以用一个命令调出所有的外部服务，那会很有帮助！Docker允许您通过在<code class="eh kt ku kv kw b">docker-compose</code>文件中列出不同的服务来做到这一点。然后，Stack使得在docker容器上运行您的程序和测试变得容易，因此您可以使用这些服务！</p><p id="bd66" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">栈是所有这些集成的关键。如果你以前从未使用过Stack，你应该看看我们的<a class="ae jp" href="http://academy.mondaymorninghaskell.com/p/your-first-haskell-project" rel="noopener ugc nofollow" target="_blank">免费迷你课程</a>。它将教你使用Stack组织一个Haskell项目的所有基础知识。</p><p id="bd0a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果这是你第一次接触Haskell，我希望它有一些令人敬畏的可能性！看看我们的<a class="ae jp" href="https://www.mmhaskell.com/checklist" rel="noopener ugc nofollow" target="_blank">入门清单</a>，开始学习吧！</p></div></div>    
</body>
</html>