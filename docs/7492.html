<html>
<head>
<title>Towards LaTeX in the Browser</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">浏览器中的LaTeX</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/towards-latex-in-the-browser-2ff4d94a0c08?source=collection_archive---------1-----------------------#2017-10-30">https://medium.com/hackernoon/towards-latex-in-the-browser-2ff4d94a0c08?source=collection_archive---------1-----------------------#2017-10-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div class="fe ff hs"><img src="../Images/8e6aff9565eb4985a605b2b412c658f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*HlpVE5TFBUp17ua1AdiKpw.gif"/></div><figcaption class="hz ia fg fe ff ib ic bd b be z ek">The way we used to do it.</figcaption></figure><div class=""/><p id="7c74" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">TeX(希腊语中的/ˈtɛx/ tekh)</p><p id="16ea" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae kb" href="https://jxxcarlson.github.io/app/miniLatexLive/index.html" rel="noopener ugc nofollow" target="_blank">MiniLatex Live</a><a class="ae kb" href="https://jxxcarlson.github.io/app/meenylatexdemo2/index.html" rel="noopener ugc nofollow" target="_blank">试玩App二</a></p><p id="1652" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae kb" href="https://minilatex.com/" rel="noopener ugc nofollow" target="_blank">近期新闻</a></p><p id="34cf" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">著名的计算机科学家唐纳德·克努特对他的《计算机编程的艺术》第二卷的校样的外观和美学感到失望，他开始为设置数学文本制作合适的工具，他觉得这项工作需要大约六个月的时间。这是1977年。到1978年，他有了工作程序，命名为<em class="ka"> TeX，</em>并于<a class="ae kb" href="https://en.wikipedia.org/wiki/TeX" rel="noopener ugc nofollow" target="_blank"> 1989年</a>以最终形式发布。从那以后，它一直是数学排版的基础。因此，为了产生公式</p><figure class="kd ke kf kg fq hw fe ff paragraph-image"><div class="fe ff kc"><img src="../Images/939fde4759ffaa13fac2246a86bdcae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/1*p1CKV5oEcVbT27MFB8DjlA.png"/></div></figure><p id="5822" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个人写了咒语</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="a130" class="km kn if ki b fv ko kp l kq kr">$$<br/>  \int_{-\infty}^\infty e^{-x^2/2} dx = \sqrt{2\pi}<br/>$$</span></pre><p id="7304" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Knuth的程序扮演了魔术师大师的角色，将咒语变成了上面显示的美丽公式。写这样一个神秘的符号序列来获得想要的艺术效果似乎是倒退，或者仅仅是复古。在鼠标和触摸屏的时代，肯定有更好的东西！也许吧，但是那些日复一日做数学的人是这样做的，不是出于无知或固执，而是因为这是更好的方法:更快，一旦你知道你在做什么，保证给你一个漂亮的结果而不浪费时间，并且能够处理你可能发现或发明的最古怪的数学。</p><h2 id="3047" class="km kn if bd ks kt ku kv kw kx ky kz la jn lb lc ld jr le lf lg jv lh li lj lk dt translated">MathJax</h2><p id="7d3c" class="pw-post-body-paragraph jc jd if je b jf ll jh ji jj lm jl jm jn ln jp jq jr lo jt ju jv lp jx jy jz hn dt translated">TeX、LaTeX和Postscript一起解决了为打印而编写数学文本的问题。将PDF加入其中，以电子方式分发整个数学文本的问题也就解决了。但是万维网呢？可以在浏览器中编辑和显示LaTeX吗？</p><p id="7d20" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">MathJax(见<a class="ae kb" href="http://www.mathjax.org" rel="noopener ugc nofollow" target="_blank">mathjax.org</a>)解决了浏览器问题的一半——数学文本本身的显示，它被美元符号或双美元符号隔开，就像上面的例子。结果非常漂亮，这是对MathJax团队技术和工艺的致敬。MathJax是你在互联网上找到的处理数学文本的博客。</p><p id="1bf1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">尽管如此，还是有差距，因为LaTeX不仅仅是显示公式——还有自动编号的部分和子部分、由方便的标签系统交叉引用的公式、定理的特殊“环境”、逐项列表、逐字文本等。等。那么问题来了:对于美元符号之外的乳胶部分能做什么呢？</p><h2 id="e61e" class="km kn if bd ks kt ku kv kw kx ky kz la jn lb lc ld jr le lf lg jv lh li lj lk dt translated">微小胶乳</h2><p id="7079" class="pw-post-body-paragraph jc jd if je b jf ll jh ji jj lm jl jm jn ln jp jq jr lo jt ju jv lp jx jy jz hn dt translated">在浏览器中复制所有的LaTeX是一个过分的要求，但不过分的是定义一个合理的子集，可以用常用工具或一些新的基于浏览器的工具来处理。做到这一点是微型乳胶项目的目标。虽然仍处于实验阶段，但该项目显示出了希望——例如，看看这些文件和草案:<a class="ae kb" href="http://www.knode.io/#@public/445" rel="noopener ugc nofollow" target="_blank"> MiniLaTeX </a>、<a class="ae kb" href="http://www.knode.io/#@public/378" rel="noopener ugc nofollow" target="_blank"> Infinity </a>、<a class="ae kb" href="http://www.knode.io/#@public/424" rel="noopener ugc nofollow" target="_blank">量子场论笔记</a>和<a class="ae kb" href="http://www.knode.io/#@public/480" rel="noopener ugc nofollow" target="_blank"> Elm by Example </a>。它们是使用MiniLatex使用编辑工具编写的，因此提供了一个原始的概念证明。</p><p id="5e3f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以使用<a class="ae kb" href="https://jxxcarlson.github.io/app/minilatex/src/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="je ig"> MiniLaTeX演示应用</strong> </a>来试验MiniLaTeX。要用MiniLaTeX写文档，试试<a class="ae kb" href="http://www.knode.io." rel="noopener ugc nofollow" target="_blank"> <strong class="je ig"> www.knode.io </strong>。由于这个项目处于非常不稳定的发展阶段，我欢迎(也需要)评论、批评和错误报告。</a></p><h2 id="1743" class="km kn if bd ks kt ku kv kw kx ky kz la jn lb lc ld jr le lf lg jv lh li lj lk dt translated">具体细节</h2><p id="474b" class="pw-post-body-paragraph jc jd if je b jf ll jh ji jj lm jl jm jn ln jp jq jr lo jt ju jv lp jx jy jz hn dt translated">MiniLaTeX项目采用分而治之的策略，使用MathJax呈现所有用美元符号隔开的文本。为了处理LaTeX在围栏之外的部分，我们使用了一个<em class="ka">解析器</em>——一个专门的程序——它读取LaTeX源文本并将其转换为一种称为抽象语法树(AST)的中间形式。AST“知道”LaTeX的语法，并以这样一种方式对这种知识进行编码，使得第二个程序<em class="ka"> renderer </em>可以很容易地将其转换成HTML，HTML是编写网页的语言。简言之，就是把一种语言翻译成另一种语言。</p><h2 id="737c" class="km kn if bd ks kt ku kv kw kx ky kz la jn lb lc ld jr le lf lg jv lh li lj lk dt translated">变得技术化</h2><p id="89c4" class="pw-post-body-paragraph jc jd if je b jf ll jh ji jj lm jl jm jn ln jp jq jr lo jt ju jv lp jx jy jz hn dt translated">现在让我们来谈技术，或者至少谈一点技术。真实交易见<a class="ae kb" href="http://www.knode.io/#@public/525" rel="noopener ugc nofollow" target="_blank">微小胶乳技术说明和进度报告</a>。</p><p id="0f85" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">建立语言翻译工具链的第一步是定义要翻译的语言。为此，从一门表达能力足够强的<em class="ka">编程</em>语言开始是一个好主意，它可以让编写解析器变得容易(更不用说可能了)。我选择的是最近的一种语言，<a class="ae kb" href="http://elm-lang.org" rel="noopener ugc nofollow" target="_blank"> Elm </a>，由Evan Czaplicki创造和开发，他将其作为2012年哈佛大学毕业论文的一部分。Elm是一种用于构建前端web应用程序的纯函数式语言。它编译成<a class="ae kb" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> Javascript </a>并且有许多显著的特性:(1)没有运行时异常，(2)编译器给出了这个星球上最好的错误消息，把它从一个烦人的唠叨变成了一个非常友好和有帮助的助手，(3)重构，即使是最激烈的那种，也很容易；因此，长期维护代码也是如此。哦——还有一件事。它很快。然而，这个项目的决定性因素是有<a class="ae kb" href="http://package.elm-lang.org/packages/elm-tools/parser/latest/Parser" rel="noopener ugc nofollow" target="_blank">优秀的解析器编写工具</a>，类似于Haskell的parsec中的解析器组合子。</p><p id="00aa" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在的MiniLaTeX语言定义非常小，只有九行代码:</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="d797" class="km kn if ki b fv ko kp l kq kr">type LatexExpression<br/>    = LXString String<br/>    | Comment String<br/>    | Item Int LatexExpression<br/>    | InlineMath String<br/>    | DisplayMath String<br/>    | Macro String (List LatexExpression)<br/>    | Environment String LatexExpression<br/>    | LatexList (List LatexExpression)</span></pre><p id="4be1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">解析器也很小——目前只有304行。(参见<a class="ae kb" href="https://github.com/jxxcarlson/koko_elm_client/blob/master/src/MiniLatex/Parser.elm" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>)。当然，还有更多，因为一旦一段MiniLaTeX源文本被解析成AST，它就必须被呈现成HTML。渲染器更大(548行)。然而，写起来要容易得多，实际上几乎是例行公事。更多详情，请参见<a class="ae kb" href="http://www.knode.io/#@public/525" rel="noopener ugc nofollow" target="_blank"> MiniLaTeX技术说明和进度报告</a>。</p><h2 id="d38e" class="km kn if bd ks kt ku kv kw kx ky kz la jn lb lc ld jr le lf lg jv lh li lj lk dt translated">在引擎盖下偷窥</h2><p id="9e8b" class="pw-post-body-paragraph jc jd if je b jf ll jh ji jj lm jl jm jn ln jp jq jr lo jt ju jv lp jx jy jz hn dt translated">对于那些想在引擎盖下窥视更多一点的人来说，请考虑这段奇特的乳胶文本:</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="b29a" class="km kn if ki b fv ko kp l kq kr">This is MiniLaTeX:<br/>\begin{theorem} <br/>  This is a test: $\alpha^2 = 7$ \foo{1}<br/>  \begin{a} <br/>    la di dah <br/>  \end{a} <br/>\end{theorem}</span></pre><p id="cdf0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">实验性解析器1.0版将它转换成以下AST:</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="c696" class="km kn if ki b fv ko kp l kq kr">Ok (LatexList (<br/>  LXString "This is MiniLaTeX:", <br/>  [Environment "theorem" (<br/>    LatexList ([<br/>         LXString "This is a test:",<br/>         InlineMath "\alpha^2 = 7",<br/>         Macro "foo" ["1"],<br/>         Environment "a" (<br/>              LatexList ([LXString "la di dah"])<br/>     )]))]))</span></pre><p id="85c7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是AST的呈现方式:</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="c504" class="km kn if ki b fv ko kp l kq kr">This is MiniLaTeX:<br/>&lt;div class="environment"&gt;<br/>   &lt;strong&gt;Theorem&lt;/strong&gt;<br/>   &lt;div class="italic"&gt;<br/>      This is a test: $\alpha^2 = 7$ \foo{1}<br/>      &lt;div class="environment"&gt;<br/>         &lt;strong&gt;A&lt;/strong&gt;<br/>         &lt;div class="italic"&gt;<br/>            la di dah<br/>         &lt;/div&gt;<br/>      &lt;/div&gt;<br/>   &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><h2 id="37b1" class="km kn if bd ks kt ku kv kw kx ky kz la jn lb lc ld jr le lf lg jv lh li lj lk dt translated">渲染意见</h2><p id="fb51" class="pw-post-body-paragraph jc jd if je b jf ll jh ji jj lm jl jm jn ln jp jq jr lo jt ju jv lp jx jy jz hn dt translated">你可能会问，“这是怎么回事？”它是按原样传递的。事实证明这是个好策略。如果MiniLaTeX理解一个TeX宏，它会相应地执行。例如，在案例<code class="eh lq lr ls ki b">\emph{Wow!}</code>中，文本“哇！”是斜体的。但是如果MiniLaTeX不知道这个宏，它只是传递它。如果宏出现在类似方程式环境的东西中，那么MathJax可能知道如何处理它，所以按原样传递它是正确的做法。如果MiniLaTeX和MathJax都不知道如何处理它，作者就可以看出有问题，并采取纠正措施。</p><p id="5336" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可能还会问:“<code class="eh lq lr ls ki b">\begin{a}</code>是怎么回事？”LaTeX中没有名为“a”的环境。当然是真的。这里的想法是用一种默认的方式来处理MiniLaTeX不知道的环境，这样它们就“正常工作”当通过传统工具如<code class="eh lq lr ls ki b">pdflatex</code>运行MiniLaTeX文档时，用户可以定制这些环境，或者使用定义它们的宏包。例如，出庭律师可能希望使用“反对”环境，或者灵媒可能希望拥有“预测”环境。随便啦。与此同时，律师和灵媒都可以在MiniLaTeX中使用这些环境。因此，即使预测环境没有连接到MiniLaTeX中，文本</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="a3df" class="km kn if ki b fv ko kp l kq kr">\begin{prediction} MiniLaTeX will be a big success. \end{prediction}<br/>\begin{prediction} You will win the lottery. \end{prediction}</span></pre><p id="269a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">渲染为</p><p id="a372" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">预测1 </strong> <em class="ka"> MiniLaTeX会大获成功。<br/> </em> <strong class="je ig">预测2 </strong> <em class="ka">你会中彩票。</em></p><p id="74b0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">是啊！</p><h2 id="3646" class="km kn if bd ks kt ku kv kw kx ky kz la jn lb lc ld jr le lf lg jv lh li lj lk dt translated"><strong class="ak">注意事项</strong></h2><ol class=""><li id="af96" class="lt lu if je b jf ll jj lm jn lv jr lw jv lx jz ly lz ma mb dt translated">我们正在探索让用户在浏览器中定义非默认环境行为的方法。这同样适用于在美元和双美元围栏之外使用的宏。</li><li id="1d30" class="lt lu if je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">使用<a class="ae kb" href="http://www.knode.io" rel="noopener ugc nofollow" target="_blank"> www.knode.io </a>的作者可以为MiniLaTeX文档的MathJax部分使用他们需要的任何宏定义。一种方法是将它们的定义放在文档文本中的双美元符号内。另一种方法是建立一个包含在其他MiniLatex文档中的宏定义文档。</li><li id="07df" class="lt lu if je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">MiniLatex语法 —草稿，但是给出了正在发生的事情的想法。语法是LL(*)，因为它必须任意向前看以识别begin-end块。由于被解析的最大单元是一个逻辑段落，所以应该将其视为LL(N)，其中N是要被解析的段落中的字符数。一个逻辑段落或者是一个普通的段落，或者是一个外部的开始-结束块。</li><li id="13ed" class="lt lu if je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">knode.io似乎在Firefox中比在Chrome中运行得更好——至少对我来说是这样。</li></ol><h2 id="0cd2" class="km kn if bd ks kt ku kv kw kx ky kz la jn lb lc ld jr le lf lg jv lh li lj lk dt translated">信用</h2><p id="f8e9" class="pw-post-body-paragraph jc jd if je b jf ll jh ji jj lm jl jm jn ln jp jq jr lo jt ju jv lp jx jy jz hn dt translated">我希望感谢在整个项目工作过程中，我在<a class="ae kb" href="https://elmlang.slack.com" rel="noopener ugc nofollow" target="_blank">elmlang.slack.com</a>从社区获得的慷慨帮助，特别感谢Ilias van Peer。</p><p id="28d1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">— <a class="ae kb" href="http://jxxcarlson.github,io" rel="noopener ugc nofollow" target="_blank">吉姆·卡尔森</a></p><figure class="kd ke kf kg fq hw"><div class="bz el l di"><div class="mh mi l"/></div></figure></div></div>    
</body>
</html>