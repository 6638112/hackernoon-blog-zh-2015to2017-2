<html>
<head>
<title>Debugging remote Node.js application running in a Docker container</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">调试Docker容器中运行的远程Node.js应用程序</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/debugging-remote-node-js-application-running-in-a-docker-container-b7c8ff377d5d?source=collection_archive---------14-----------------------#2017-06-06">https://medium.com/hackernoon/debugging-remote-node-js-application-running-in-a-docker-container-b7c8ff377d5d?source=collection_archive---------14-----------------------#2017-06-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="b2cb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设您想要调试一个已经在远程机器上运行的<a class="ae jp" href="https://hackernoon.com/tagged/nodejs" rel="noopener ugc nofollow" target="_blank"> Node.js </a>应用程序，该应用程序位于<a class="ae jp" href="https://hackernoon.com/tagged/docker" rel="noopener ugc nofollow" target="_blank"> Docker </a>容器中。并且希望在不修改命令参数(启用<code class="eh jq jr js jt b">debug</code>模式)和向全世界开放remote Node.js调试器代理端口的情况下实现它。</p><blockquote class="ju jv jw"><p id="adc9" class="ir is jx it b iu iv iw ix iy iz ja jb jy jd je jf jz jh ji jj ka jl jm jn jo hn dt translated">我打赌你不知道这是可能的，也不知道如何去做。</p></blockquote><p id="ee90" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你渴望学习一些新的很酷的东西，我鼓励你继续阅读这篇文章。</p><h1 id="8654" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">TdodoMVC演示应用程序</h1><p id="ed27" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">我将使用<strong class="it hv"> TodoMVC </strong> Node.js应用程序(由Gleb Bahmutov开发)的<a class="ae jp" href="https://github.com/alexei-led/todomvc-express" rel="noopener ugc nofollow" target="_blank"> fork </a>作为这篇博文的演示应用程序。随意克隆和使用这个库。</p><p id="008c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里是我为TodoMVC应用程序添加的<code class="eh jq jr js jt b">Dockerfile</code>。它允许在Docker容器中运行TodoMVC应用程序。</p><pre class="le lf lg lh fq li jt lj lk aw ll dt"><span id="7b74" class="lm kc hu jt b fv ln lo l lp lq">FROM alpine:3.5 </span><span id="5d8e" class="lm kc hu jt b fv lr lo l lp lq"># install node <br/>RUN apk add --no-cache nodejs-current tini <br/>RUN mkdir -p /usr/src/app <br/>WORKDIR /usr/src/app </span><span id="2e52" class="lm kc hu jt b fv lr lo l lp lq"># Build time argument to set NODE_ENV (‘production’’ by default) <br/>ARG NODE_ENV <br/>ENV NODE_ENV ${NODE_ENV:-production} </span><span id="4bfa" class="lm kc hu jt b fv lr lo l lp lq"># install npm packages: clean obsolete files <br/>COPY package.json /usr/src/app/ <br/>RUN npm config set depth 0 &amp;&amp; \ <br/>    npm install &amp;&amp; \ <br/>    npm cache clean &amp;&amp; \ <br/>    rm -rf /tmp/* </span><span id="a655" class="lm kc hu jt b fv lr lo l lp lq"># copy source files <br/>COPY . /usr/src/app <br/>EXPOSE 3000 </span><span id="c512" class="lm kc hu jt b fv lr lo l lp lq"># Set tini as entrypoint <br/>ENTRYPOINT [“/sbin/tini”, “--“] </span><span id="bf9c" class="lm kc hu jt b fv lr lo l lp lq">CMD [ “npm”, “start” ] </span><span id="5acf" class="lm kc hu jt b fv lr lo l lp lq"># add VCS labels for code sync and nice reports <br/>ARG VCS_REF=”local” <br/>LABEL org.label-schema.vcs-ref=$VCS_REF \ <br/>      org.label-schema.vcs-url="https://github.com/alexei-led/todomvc-express.git"</span></pre><h2 id="11f2" class="lm kc hu bd kd ls lt lu kh lv lw lx kl jc ly lz kp jg ma mb kt jk mc md kx me dt translated">在Docker容器中构建和运行TodoMVC:</h2><p id="6f92" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">要为TodoMVC应用程序构建一个新的Docker映像，运行<code class="eh jq jr js jt b">docker build</code>命令。</p><pre class="le lf lg lh fq li jt lj lk aw ll dt"><span id="4d4c" class="lm kc hu jt b fv ln lo l lp lq">$ # build Docker image; set VCS_REF to current HEAD commit (short) <br/>$ docker build -t local/todomvc --build-arg VCS_REF=`git rev-parse ---short HEAD` . <br/>$ # run TodoMVC in a Docker container <br/>$ docker run -d -p 3000:3000 --name todomvc local/todomvc node src/start.js</span></pre><h1 id="82b3" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">这个计划</h1><p id="1a8c" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated"><strong class="it hv">最终目标</strong> —我希望能够将Node.js调试器附加到已经在Docker容器中启动并运行的Node.js应用程序，该应用程序运行在AWS云中的远程主机上，而无需修改应用程序、容器、容器配置，或者使用额外的<code class="eh jq jr js jt b">debug</code>标志重新启动它。假设应用程序正在运行，现在出现了一些问题——我想用调试器连接到它，并开始查看问题。</p><p id="607a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以，我需要一个计划——一个帮助我实现最终目标的循序渐进的流程。</p><p id="9a0c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jx">先来探究一下库存。</em></p><p id="779b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在服务器(AWS EC2 VM)上，我有一个Node.js应用程序运行在Docker容器中。在客户端(我的笔记本电脑)，我有一个IDE(在我的例子中是Visual Studio代码)、Node.js应用程序代码(<code class="eh jq jr js jt b">git pull/clone</code>)和一个Node.js调试器。</p><p id="67b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以，这是我的计划:</p><ol class=""><li id="8862" class="mf mg hu it b iu iv iy iz jc mh jg mi jk mj jo mk ml mm mn dt translated">将已经运行的应用程序设置为<code class="eh jq jr js jt b">debug</code>模式</li><li id="598e" class="mf mg hu it b iu mo iy mp jc mq jg mr jk ms jo mk ml mm mn dt translated">公开一个新的Node.js调试器代理端口，以安全的方式启用远程调试</li><li id="1d2a" class="mf mg hu it b iu mo iy mp jc mq jg mr jk ms jo mk ml mm mn dt translated">同步客户机-服务器代码:两者应该在一个<code class="eh jq jr js jt b">git</code>树中进行相同的提交</li><li id="100e" class="mf mg hu it b iu mo iy mp jc mq jg mr jk ms jo mk ml mm mn dt translated">将本地Node.js调试器连接到远程服务器上的Node.js调试器代理端口，并以安全的方式进行连接</li><li id="037f" class="mf mg hu it b iu mo iy mp jc mq jg mr jk ms jo mk ml mm mn dt translated">如果一切正常，我应该能够执行常规的调试任务，比如设置断点、检查变量、暂停执行等。</li></ol><h1 id="4843" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">步骤1:将已经运行的Node.js应用程序设置为<code class="eh jq jr js jt b">debug</code>模式</h1><blockquote class="ju jv jw"><p id="290d" class="ir is jx it b iu iv iw ix iy iz ja jb jy jd je jf jz jh ji jj ka jl jm jn jo hn dt translated"><em class="hu">V8调试器可以通过使用</em> <code class="eh jq jr js jt b"><em class="hu">--debug</em></code> <em class="hu">命令行标志启动节点或使用</em> <code class="eh jq jr js jt b"><em class="hu">SIGUSR1</em></code> <em class="hu">向现有节点进程发送信号来启用和访问。(节点API文档)</em></p></blockquote><p id="df5c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jx">爽！</em>所以，为了打开节点调试器代理，我只需要发送<code class="eh jq jr js jt b">SIGUSR1</code>信号给TodoMVC应用程序的Node.js进程。记住，它是在Docker容器中运行的。我可以使用什么命令向Docker容器中运行的应用程序发送进程信号？</p><p id="4ef3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个<code class="eh jq jr js jt b">docker kill</code>命令——是我的选择！这个命令实际上并没有“杀死”运行在Docker容器中的<code class="eh jq jr js jt b">PID 1</code>进程，而是向它发送一个<a class="ae jp" href="https://en.wikipedia.org/wiki/Unix_signal" rel="noopener ugc nofollow" target="_blank"> Unix信号</a>(默认情况下它发送<code class="eh jq jr js jt b">SIGKILL</code>)。</p><h2 id="15e2" class="lm kc hu bd kd ls lt lu kh lv lw lx kl jc ly lz kp jg ma mb kt jk mc md kx me dt translated">将TodoMVC设置为<code class="eh jq jr js jt b">debug</code>模式</h2><p id="f6ba" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">因此，我需要做的就是将<code class="eh jq jr js jt b">SIGUSR1</code>发送到我的TodoMVC应用程序，该应用程序运行在<code class="eh jq jr js jt b">todomvc</code> Docker容器中。</p><p id="fae8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有两种方法可以做到这一点:</p><ol class=""><li id="ca42" class="mf mg hu it b iu iv iy iz jc mh jg mi jk mj jo mk ml mm mn dt translated">使用<code class="eh jq jr js jt b">docker kill --signal</code>命令将<code class="eh jq jr js jt b">SIGUSR1</code>发送到Docker容器内运行的<code class="eh jq jr js jt b">PID 1</code>进程，如果它是一个“正确的”(信号转发正确)init应用程序(如<code class="eh jq jr js jt b">tini</code>)，那么它将工作</li><li id="1ed8" class="mf mg hu it b iu mo iy mp jc mq jg mr jk ms jo mk ml mm mn dt translated">或者，在已经运行的Docker容器中执行<code class="eh jq jr js jt b">kill -s SIGUSR1</code>，向主Node.js进程发送<code class="eh jq jr js jt b">SIGUSR1</code>信号。</li></ol><pre class="le lf lg lh fq li jt lj lk aw ll dt"><span id="ba96" class="lm kc hu jt b fv ln lo l lp lq">$ # send SIGUSR1 with docker kill (if using proper init process) <br/>$ docker kill --signal SIGUSR1 todomvc <br/>$ # OR run kill command for node process inside todomvc container <br/>$ docker exec -it todomvc sh -c ‘kill -s SIGUSR1 $(pidof -s node)’</span></pre><p id="e703" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们验证节点应用程序是否设置为<code class="eh jq jr js jt b">debug</code>模式。</p><pre class="le lf lg lh fq li jt lj lk aw ll dt"><span id="4831" class="lm kc hu jt b fv ln lo l lp lq">$ docker logs todomvc </span><span id="c56d" class="lm kc hu jt b fv lr lo l lp lq">TodoMVC server listening at <a class="ae jp" href="http://:::3000" rel="noopener ugc nofollow" target="_blank">http://:::3000</a> <br/>emitting 2 todos server has new 2 todos <br/>GET / 200 31.439 ms — 3241 <br/>GET /app.css 304 4.907 ms <br/>— — <br/>Starting debugger agent. <br/>Debugger listening on 127.0.0.1:5858</span></pre><p id="bf17" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如您所看到的，Node.js调试器代理已经启动，但是它只能接受来自<code class="eh jq jr js jt b">localhost</code>的连接，请参见最后一行输出:<code class="eh jq jr js jt b">Debugger listening on 127.0.0.1:5858</code></p><h1 id="2e58" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">步骤2:公开节点调试端口</h1><p id="ddb0" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">为了将远程Node.js调试器附加到运行在<code class="eh jq jr js jt b">debug</code>模式下的节点应用程序，我需要:</p><ol class=""><li id="d3c2" class="mf mg hu it b iu iv iy iz jc mh jg mi jk mj jo mk ml mm mn dt translated">允许从任何(或特定)IP(或IP范围)连接到调试器代理</li><li id="4c04" class="mf mg hu it b iu mo iy mp jc mq jg mr jk ms jo mk ml mm mn dt translated">在Docker容器外打开Node.js调试器代理的端口</li></ol><p id="6cbf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当一个应用程序已经在Docker容器中运行，Node.js调试器代理准备好只与同一台机器上运行的Node.js调试器进行对话，并且Node.js调试器代理端口无法从Docker容器外部访问时，如何做到这一点？</p><p id="5418" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然，可以使用暴露的调试器端口启动每个Node.js Docker容器，并允许来自任何IP的连接(使用特殊的<code class="eh jq jr js jt b">--debug-port</code>和<code class="eh jq jr js jt b">--debug</code> Node.js标志)，但我们并不寻找简单的方法:)。</p><p id="500c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从安全角度来看这不是一个好主意(允许对Node.js调试器进行无保护的访问)。此外，如果我使用调试标志重新启动一个已经运行的应用程序，我将失去当前的执行上下文，并且可能无法重现我想要调试的问题。</p><p id="89e0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jx">我需要更好的解决方案！</em></p><p id="b521" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不幸的是，Docker不允许为已经运行的Docker容器暴露额外的端口。因此，我需要以某种方式连接到一个正在运行的容器网络，并为Node.js调试器代理公开一个新端口。</p><p id="0766" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，当Node.js进程已经启动时，不可能告诉Node.js调试器代理接受来自不同IP地址的连接。</p><p id="0c33" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以上两个问题都可以在Linux的小工具<code class="eh jq jr js jt b">socat</code> (SOcket CAT)的帮助下解决。这就像<code class="eh jq jr js jt b">netcat</code>一样，但考虑到了安全性(例如，它支持chrooting ),并通过文件、管道、设备、TCP套接字、Unix套接字、SOCKS4客户端、代理连接或SSL等在各种协议上工作。</p><p id="10f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">来自<code class="eh jq jr js jt b">socat</code>手册页:</p><blockquote class="ju jv jw"><p id="5f05" class="ir is jx it b iu iv iw ix iy iz ja jb jy jd je jf jz jh ji jj ka jl jm jn jo hn dt translated"><code class="eh jq jr js jt b"><em class="hu">socat</em></code> <em class="hu">是一个基于命令行的实用程序，建立两个双向字节流并在它们之间传输数据。因为流可以由大量不同类型的数据汇和数据源构成(参见地址类型)，并且因为许多地址选项可以应用于流，</em> <code class="eh jq jr js jt b"><em class="hu">socat</em></code> <em class="hu">可以用于许多不同的目的。</em></p></blockquote><p id="7607" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jx">正是，我所需要的！</em></p><p id="7e45" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，计划是这样的:我将运行一个新的Docker容器，并在其上运行<code class="eh jq jr js jt b">socat</code>实用程序，并为TodoMVC容器配置Node.js调试器端口转发。</p><p id="bb32" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jq jr js jt b">socat.Dockerfile</code>:</p><pre class="le lf lg lh fq li jt lj lk aw ll dt"><span id="9819" class="lm kc hu jt b fv ln lo l lp lq">FROM alpine:3.5 <br/>RUN apk add --no-cache socat <br/>CMD socat -h</span></pre><h2 id="e04a" class="lm kc hu bd kd ls lt lu kh lv lw lx kl jc ly lz kp jg ma mb kt jk mc md kx me dt translated">建筑码头集装箱</h2><pre class="le lf lg lh fq li jt lj lk aw ll dt"><span id="a26c" class="lm kc hu jt b fv ln lo l lp lq">$ docker build -t local/socat — &lt; socat.Dockerfile</span></pre><h2 id="27ac" class="lm kc hu bd kd ls lt lu kh lv lw lx kl jc ly lz kp jg ma mb kt jk mc md kx me dt translated">允许从任何IP连接到节点调试器代理</h2><p id="67f8" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">我需要在与<code class="eh jq jr js jt b">todomvc</code>容器相同的网络名称空间中运行一个“sidecar”<code class="eh jq jr js jt b">socat</code>容器，并定义一个端口转发。</p><pre class="le lf lg lh fq li jt lj lk aw ll dt"><span id="6d73" class="lm kc hu jt b fv ln lo l lp lq">$ # define local port forwarding <br/>$ docker run -d --name socat-nip --network=container:todomvc \<br/>      local/socat socat TCP-LISTEN:4848,fork TCP:127.0.0.1:5858</span></pre><p id="0e98" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，到达<code class="eh jq jr js jt b">4848</code>端口的任何流量都将被路由到Node.js调试器代理侦听<code class="eh jq jr js jt b">127.0.0.1:5858</code>。<code class="eh jq jr js jt b">4848</code>端口可以接受来自任何IP的流量。<br/>也可以使用IP范围来限制连接到<code class="eh jq jr js jt b">socat</code>监听端口，增加了<code class="eh jq jr js jt b">range=&amp;lt;ANY IP RANGE&amp;gt;</code>选项。</p><h2 id="b248" class="lm kc hu bd kd ls lt lu kh lv lw lx kl jc ly lz kp jg ma mb kt jk mc md kx me dt translated">从Docker容器公开Node.js调试器端口</h2><p id="9522" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">首先，我们将获得<code class="eh jq jr js jt b">todomvc</code> Docker容器的IP。</p><pre class="le lf lg lh fq li jt lj lk aw ll dt"><span id="f180" class="lm kc hu jt b fv ln lo l lp lq">$ # get IP of todomvc container <br/>$ TODOMVC_IP=$(docker inspect -f “{{.NetworkSettings.IPAddress}}” todomvc)</span></pre><p id="970f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，配置端口转发到我们之前定义的“sidecar”<code class="eh jq jr js jt b">socat</code>端口，它与<code class="eh jq jr js jt b">todomvc</code>容器运行在同一个网络上。</p><pre class="le lf lg lh fq li jt lj lk aw ll dt"><span id="72b6" class="lm kc hu jt b fv ln lo l lp lq">$ # run socat container to expose Node.js <br/>$ # debugger agent port forwarder <br/>$ docker run -d -p 5858:5858 --name socat local/socat \<br/>      socat TCP-LISTEN:5858,fork TCP:${TODOMVC_IP}:4848</span></pre><p id="d6e6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">将到达Docker主机上的<code class="eh jq jr js jt b">5858</code>端口的任何流量将首先被转发到<code class="eh jq jr js jt b">4848</code> socat端口，然后被转发到在<code class="eh jq jr js jt b">todomvc</code> Docker容器内运行的Node.js调试器代理。</p><h2 id="e34d" class="lm kc hu bd kd ls lt lu kh lv lw lx kl jc ly lz kp jg ma mb kt jk mc md kx me dt translated">为远程访问公开Node.js调试器端口</h2><p id="8e9c" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">在大多数情况下，我希望调试运行在远程机器上的应用程序(例如，AWS EC2实例)。我也不想将Node.js调试器代理端口暴露给全世界。</p><p id="a0b9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个可行的解决方案是使用SSH隧道来访问这个端口。</p><pre class="le lf lg lh fq li jt lj lk aw ll dt"><span id="67c5" class="lm kc hu jt b fv ln lo l lp lq">$ # Open SSH Tunnel to gain access to servers port 5858. <br/>$ # Set `SSH_KEY_FILE` to ssh key location or add it to ssh-agent <br/>$ # <br/>$ # open an ssh tunnel, send it to the bg, and wait 20 seconds <br/>$ # for connections, once all connections are closed <br/>$ # after 20 seconds then close the tunnel <br/>$ ssh -i ${SSH_KEY_FILE} -f -o ExitOnForwardFailure=yes \<br/>      -L 5858:127.0.0.1:5858 ec2_user@some.ec2.host.com sleep 20</span></pre><p id="9320" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，<code class="eh jq jr js jt b">localhost:5858</code>的所有流量将通过<code class="eh jq jr js jt b">SSH</code>隧道传输到远程Docker主机，并在<code class="eh jq jr js jt b">socat</code>转发到运行在<code class="eh jq jr js jt b">todomvc</code>容器内的Node.js调试器代理。</p><h1 id="7622" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">步骤3:在相同的代码提交上同步</h1><p id="bb90" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">为了能够调试远程应用程序，您需要确保您在IDE中使用的代码与在远程服务器上运行的代码相同。</p><p id="cc6f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我也将尝试自动化这一步。还记得我在TodoMVC <code class="eh jq jr js jt b">Dockerfile</code>中用过的<code class="eh jq jr js jt b">LABEL</code>命令吗？</p><p id="6ba9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些标签帮助我识别git存储库并提交应用程序Docker映像:</p><ol class=""><li id="13de" class="mf mg hu it b iu iv iy iz jc mh jg mi jk mj jo mk ml mm mn dt translated"><code class="eh jq jr js jt b">org.label-schema.vcs-ref</code>–包含用于<code class="eh jq jr js jt b">HEAD</code>提交的短SHA</li><li id="6fa3" class="mf mg hu it b iu mo iy mp jc mq jg mr jk ms jo mk ml mm mn dt translated"><code class="eh jq jr js jt b">org.label-schema.vcs-url</code>–包含一个应用程序git存储库URL(我可以在<code class="eh jq jr js jt b">clone/pull</code>中使用)</li></ol><p id="af84" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我使用(标签模式约定)[http://label-schema.org/rc1/]，因为我真的很喜欢它，并且发现它很有用，但是您也可以选择任何其他约定。</p><p id="e512" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种方法允许我为每个正确标记的Docker映像识别应用程序代码库和创建它的提交。</p><pre class="le lf lg lh fq li jt lj lk aw ll dt"><span id="09a0" class="lm kc hu jt b fv ln lo l lp lq">$ # get git repository url form Docker image <br/>$ GIT_URL=$(docker inspect local/todomvc <br/>    | jq -r ‘.[].ContainerConfig.Labels.”org.label-schema.vcs-url”’)<br/>$ # get git commit from Docker image <br/>$ GIT_COMMIT=$(docker inspect local/todomvc <br/>    | jq -r ‘.[].ContainerConfig.Labels.”org.label-schema.vcs-ref”’)<br/>$ <br/>$ # clone git repository, if needed <br/>$ git clone $GIT_URL <br/>$ # set HEAD to same commit as server <br/>$ git checkout $GIT_COMMIT</span></pre><p id="57da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我的本地开发环境和远程应用程序都在同一个git commit上。我终于可以开始调试我的代码了！</p><h1 id="106f" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">步骤4:将本地Node.js调试器附加到调试器代理端口</h1><p id="8210" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">要开始调试，我需要配置我的IDE。在我的例子中，它是<a class="ae jp" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> Visual Studio代码</a>，我需要添加一个新的<code class="eh jq jr js jt b">Launch</code>配置。</p><p id="ee62" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此启动配置指定要附加的远程调试器服务器和端口，以及应用程序源文件的远程位置，这些文件应该与本地文件同步(请参见上一步)。</p><pre class="le lf lg lh fq li jt lj lk aw ll dt"><span id="509c" class="lm kc hu jt b fv ln lo l lp lq">{ // For more information about Node.js debug attributes, visit: <a class="ae jp" href="https://go.microsoft.com/fwlink/?linkid=830387" rel="noopener ugc nofollow" target="_blank">https://go.microsoft.com/fwlink/?linkid=830387</a> <br/>“version”: “0.2.0”, <br/>“configurations”: [ { <br/>    “type”: “node”, <br/>    “request”: “attach”, <br/>    “name”: “Debug Remote Docker”, <br/>    “address”: “127.0.0.1”, <br/>    “port”: 5858, “localRoot”: <br/>    “${workspaceRoot}/”, <br/>    “remoteRoot”: “/usr/src/app/” } <br/>] }</span></pre><h1 id="d921" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">摘要</h1><p id="2274" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">最后，我实现了我的目标:我能够将Node.js调试器附加到Node.js应用程序，该应用程序已经在远程机器上的Docker容器中启动并运行。找到合适的解决方案是一个漫长的旅程，但在我找到它之后，这个过程看起来一点也不复杂。</p><p id="7e61" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，一旦我在我们的环境中遇到新问题，我可以轻松地将Node.js调试器附加到正在运行的应用程序，并开始探索问题。很好，不是吗？</p><p id="9b10" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我已经录制了一个短片，只是为了演示所有步骤，证明事情正在顺利进行，正如我在这篇文章中描述的那样。</p><figure class="le lf lg lh fq mt"><div class="bz el l di"><div class="mu mv l"/></div></figure><p id="7345" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">希望，你觉得这篇帖子有用。我期待您的评论和任何问题。</p></div><div class="ab cl mw mx hc my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="hn ho hp hq hr"><p id="42d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jx">原载于2017年6月6日</em><a class="ae jp" href="https://www.codefresh.io/blog/debug_node_in_docker/" rel="noopener ugc nofollow" target="_blank"><em class="jx">code fresh . io</em></a><em class="jx">。</em></p><blockquote class="ju jv jw"><p id="4155" class="ir is jx it b iu iv iw ix iy iz ja jb jy jd je jf jz jh ji jj ka jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是阿妹家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is jx it b iu iv iw ix iy iz ja jb jy jd je jf jz jh ji jj ka jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">赞/在脸书给我们发消息</a>，或者简单地说，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is jx it b iu iv iw ix iy iz ja jb jy jd je jf jz jh ji jj ka jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="le lf lg lh fq mt"><div class="bz el l di"><div class="nd mv l"/></div></figure></div></div>    
</body>
</html>