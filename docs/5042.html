<html>
<head>
<title>Lattice 4.0: A solution to the View-State problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Lattice 4.0:视图状态问题的解决方案</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/lattice-4-0-a-solution-to-the-view-state-problem-9cc44a4bd9d7?source=collection_archive---------18-----------------------#2017-07-06">https://medium.com/hackernoon/lattice-4-0-a-solution-to-the-view-state-problem-9cc44a4bd9d7?source=collection_archive---------18-----------------------#2017-07-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="daf8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">文本框是一个复杂而敏感的问题:如何以及在哪里存储文本，以及当发生变化时如何更新事件侦听器。</p><p id="ee13" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">HTML模型只是将文本框内容存储在DOM中，并在触发相关事件时调用更新监听器。这种模型经过了时间的考验，能够很好地处理Javascript如何将变量作用于匿名函数的问题。大多数编程语言(函数式之外的)不会将外部变量纳入闭包。<a class="ae jp" href="https://github.com/andrew-lucker/Lattice" rel="noopener ugc nofollow" target="_blank">格子</a>内置铁锈，多多少少都有这个问题。</p><p id="41bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">视图状态的“问题”是，当一个事件被触发时，我们可能希望引用两个变量，一个是在创建文本框时创建的，另一个是在创建后绑定到视图组件的。对于Javascript来说，这听起来微不足道，但是相比之下，Rust关于变量生命周期的安全特性阻止了我们在这里使用简单的解决方案。</p><p id="9fc6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">HTML在DOM中的状态存储是将信息存储到视图组件本身。让我们称这个策略为“绑定到左侧”。另一种方法是将信息存储到管理和调用侦听器的环境中。让我们把第二个策略称为“绑定到右侧”。从这个角度我们可以看到，在HTML/JS中，数据是左右两边共享的。这基本上是视图状态问题的理想解决方案，然而现在的问题是“我们如何在Rust中做同样的事情”？</p><p id="f168" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第一种解决方案是复制Javascript的方法，虽然很丑，但非常合理。为了在Rust中共享一个变量，我们可以将该值放入一个引用单元格(Rc、RefCell、Box等。)并从左侧和右侧检索和/或更新该值。这种方法的缺点是，客户端代码变得非常脏，难以阅读；更不用说，每个共享变量都必须使用所有权和生存期的迟钝规则进行显式绑定、解包和变异。也许这种方法在未来的Rust中会变得更容易，但是现在它对我来说是一个太大的负担。</p><p id="c057" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第二种解决方案，在网格中使用，是使用受限的FRP样式。这意味着对象状态存储在“靠近”左侧，但不完全在视图组件上。由引擎管理，每个视图组件和听众可以订阅的<em class="jq">频道</em>都有一个关联值。当一个组件想要更新它的状态时，它会调用每个组件内置的状态设置函数。每个组件可能有多个不同类型的绑定值。然后，该引擎检查是否应该将更改通知给订阅者，如果是，则向侦听器发出一个事件。</p><p id="e75e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以这种方式，可以通过使用引擎作为中介来引用左侧和右侧状态。状态的所有权交给中介，组件和侦听器总是接收借用的值。从用户的角度来看，这种方法非常简洁，并且在实践中非常类似于Javascript方法。</p><p id="598e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我仍然希望在未来，Rust闭包会有更多的选项和更好的关于作用域变量的默认值，但是现在有很多变通方法。</p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="fe ff jr"><img src="../Images/30c51516b6205863fb9202959c603783.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TZoVshUZODWClGlbJUFr3A.jpeg"/></div></div><figcaption class="kd ke fg fe ff kf kg bd b be z ek">This is what my git repositories usually look like</figcaption></figure></div></div>    
</body>
</html>