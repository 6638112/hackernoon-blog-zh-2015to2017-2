<html>
<head>
<title>Serverless: Moderate fun with Modular Functions in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器:Node.js中模块化功能的适度乐趣</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/serverless-moderate-fun-with-modular-functions-df98ca6cb981?source=collection_archive---------3-----------------------#2017-11-04">https://medium.com/hackernoon/serverless-moderate-fun-with-modular-functions-df98ca6cb981?source=collection_archive---------3-----------------------#2017-11-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="b61e" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">以纯功能和可组合的方式，高效地构建和部署Javascript模块到无服务器云。</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/3ed819b5480c7ad0a2545cd4892988a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6_GI4vLNInQOKBnoG_e7ZQ.jpeg"/></div></div></figure><p id="9c8f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我爱<a class="ae kr" href="https://nodejs.org" rel="noopener ugc nofollow" target="_blank"> Node.js </a>。通过它我重新发现了<a class="ae kr" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> Javascript </a>，我再也不会回去了。我也爱<a class="ae kr" href="http://expressjs.com" rel="noopener ugc nofollow" target="_blank">快车</a>。它使编写服务器应用程序变得如此简单，并且其基于<a class="ae kr" href="https://github.com/senchalabs/connect" rel="noopener ugc nofollow" target="_blank"> Connect </a>的中间件堆栈方法使扩展和编写应用程序变得简单而有趣。<a class="ae kr" href="https://hackernoon.com/tagged/nodejs" rel="noopener ugc nofollow" target="_blank"> Node.js </a>，结合Express这样的框架，对于微服务来说非常棒。由于它的轻量级特性、非阻塞特性和快速开发经验，它击败了(imho)其他微服务技术，如Spring Boot。将它与Docker结合起来，就没有限制了(…只要您为您的容器集群分配足够的资源)。</p><h1 id="fb09" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">比小更小</h1><p id="e1d0" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">首先，他们给了我们<em class="lp">服务器</em>，所以我们构建了<em class="lp">面向服务的架构</em>。<br/>然后他们给了我们<em class="lp">容器</em>，于是我们建立了<em class="lp">微服务</em>。</p><p id="ed12" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在他们给了我们<strong class="jx hv">事件处理程序</strong>，所以我们将构建<strong class="jx hv">云函数</strong>。</p><p id="2b06" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">随着我们使我们的托管平台更适合于部署更小的单元，我们的应用程序也被分解成更小的软件包。这有很多原因，是否是好事众说纷纭。但是，如果我们回头看看云计算背后的最初概念，人们曾梦想让代码无限分布在一个由连接的计算节点组成的网络中。随着无服务器平台的出现，我们离成功越来越近了。</p><h1 id="c9f0" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">但不要太小</h1><p id="17c4" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">我们不能太小，因为我们有由计算步骤序列组成的块(过程),这些计算步骤需要共享内存来有效地执行。然后，我们将它们包装在一个函数定义中，该定义为其输入和输出定义了一个契约，这允许它与其他这样的函数组合在一起。</p><p id="3ba4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这种方法在Unix架构中非常成功，这也是它经久不衰和无处不在的原因之一。我并不是说Web应用程序应该遵循类似的基于云的共享生态系统(尽管<a class="ae kr" href="https://stdlib.com" rel="noopener ugc nofollow" target="_blank">有些</a>正在尝试)，但是我确实相信我们可以从构建Web应用程序时应用类似的原则中受益。</p></div><div class="ab cl lq lr hc ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hn ho hp hq hr"><p id="b4f5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">除了函数定义，我们还将密切相关的函数分组到模块中。一个例子是给定域内数据的CRUD操作(例如用户管理)。那些倾向于共享代码，例如公共对象模型、解析逻辑、格式等。因此，如果我们在无服务器环境中部署单独的功能，我们最终会得到一堆重复的代码。</p><p id="d7ab" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">但是让我们假设我们不介意重复的代码部署。毕竟，我们仍然可以在我们的代码库中适当地管理它。但是，我们可能仍然希望共享临时资源，比如数据库连接。我们可能还希望确保同一个域的所有操作都作为一个单元进行部署和管理。</p><p id="c5ec" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这非常符合<a class="ae kr" href="http://programmer.97things.oreilly.com/wiki/index.php/The_Single_Responsibility_Principle" rel="noopener ugc nofollow" target="_blank">单一责任原则</a>:</p><blockquote class="lx ly lz"><p id="7f0e" class="jv jw lp jx b jy jz iv ka kb kc iy kd ma kf kg kh mb kj kk kl mc kn ko kp kq hn dt translated">把那些因同一原因而改变的东西集合在一起，把那些因不同原因而改变的东西分开。</p></blockquote><h1 id="7758" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">走向无服务器</h1><p id="5fb8" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">所以，Node.js非常适合微服务。而且对于编写更小的功能模块也很棒。Express非常适合在Node.js中构建Web应用程序。</p><p id="fabc" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">然而，大多数无服务器环境(AWS Lambda、Google Cloud Functions等)已经提供了许多现成的工具来处理Web服务器的常见功能。对于这些<em class="lp">纳米服务</em>，不应该有太多的功能，我们真的不应该被复杂的网络服务器逻辑的开销所困扰。我们当然应该利用HTTP，因为它是在Web服务之间传输消息的无处不在的传输机制，但是我们应该以一种更像RPC的方式来做。</p><p id="953f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这是大多数当前框架为我们正在寻找的小足迹提供太大工具的地方。如果有什么不同的话，我认为无服务器化应该让我们从框架中解放出来，转而专注于构建更纯粹的T2功能。然而，在<em class="lp">纳米服务</em>中仍然需要基本的路由，以便将传入的请求映射到适当的处理函数。此外，由于这些商业无服务器环境的专有性质，有必要进行一定程度的抽象，以便我们的功能可以与执行它们的平台的细节分离。</p></div><div class="ab cl lq lr hc ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hn ho hp hq hr"><p id="e1b5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我认为，更多的应用程序将很快出现，这些应用程序专注于支持应用于无服务器部署的函数式编程，我对此充满希望，因为这感觉像是朝着正确方向迈出的一步。当然，还有许多现实世界的问题需要解决，比如延迟、性能、内存使用等。但就像微服务一样，我相信我们会找到一套正确的工具和实践来实现这一点，不仅实用，而且在现实世界的应用中具有高性能。</p><h1 id="e2ba" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">模块化功能</h1><p id="3bad" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">当我开始部署无服务器应用程序时，我编写了一个小的包来解决这些需求:<a class="ae kr" href="https://modofun.js.org" rel="noopener ugc nofollow" target="_blank"> modofun </a>。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff md"><img src="../Images/9bd16cd7fa341053241df302822a439f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h555w9EzrmhNvKg_3FtagQ.png"/></div></div></figure><p id="3172" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">它没有额外的依赖性，因为我们希望我们的部署尽可能小，并且它被限制在大约100行代码。它的目标是添加足够的(而不是更多的)功能，使在无服务器平台上部署功能模块更容易，并利用为现有框架(如Express)构建的现有中间件的额外好处。以下是它的一些特点:</p><ul class=""><li id="ac15" class="me mf hu jx b jy jz kb kc ke mg ki mh km mi kq mj mk ml mm dt translated">功能的基本路由</li><li id="51dd" class="me mf hu jx b jy mn kb mo ke mp ki mq km mr kq mj mk ml mm dt translated">参数解析</li><li id="f7ac" class="me mf hu jx b jy mn kb mo ke mp ki mq km mr kq mj mk ml mm dt translated">自动HTTP响应构建</li><li id="2301" class="me mf hu jx b jy mn kb mo ke mp ki mq km mr kq mj mk ml mm dt translated">支持ES6承诺(或任何其他当时可能的承诺)</li><li id="990c" class="me mf hu jx b jy mn kb mo ke mp ki mq km mr kq mj mk ml mm dt translated">类似连接/快速的中间件支持</li><li id="52ba" class="me mf hu jx b jy mn kb mo ke mp ki mq km mr kq mj mk ml mm dt translated"><strong class="jx hv">谷歌云功能</strong></li><li id="d343" class="me mf hu jx b jy mn kb mo ke mp ki mq km mr kq mj mk ml mm dt translated"><strong class="jx hv"> AWS Lambda </strong>(带有AWS API网关事件)</li><li id="a0fb" class="me mf hu jx b jy mn kb mo ke mp ki mq km mr kq mj mk ml mm dt translated">自动错误处理</li></ul><p id="f621" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">将现有模块公开为无服务器云功能很容易:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ms mt l"/></div></figure><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mu"><img src="../Images/80d23e5b8bc0f13829b0578f24a35d91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*caoa_S2By0fMnsyAErSDOA.png"/></div></div></figure><p id="a152" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">一个<em class="lp">有意地</em>简化的路由器将传入的请求映射到函数，并将URL路径的附加部分作为函数参数传递。额外的请求数据也可以作为函数调用的上下文(this)使用。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ms mt l"/></div></figure><p id="0f02" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">将modofun应用于功能模块时，您还可以重复使用现有的中间件组件，每次都可以执行，或者只用于某些功能(更多详细信息请参见<a class="ae kr" href="https://modofun.js.org/#configuration" rel="noopener ugc nofollow" target="_blank">文档</a>)。然后，它返回由无服务器平台(目前支持AWS和Google Cloud)生成的事件的处理程序。</p><p id="28d0" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">用<a class="ae kr" href="https://www.npmjs.com/package/modofun" rel="noopener ugc nofollow" target="_blank"> npm </a>得到它:</p><pre class="jk jl jm jn fq mv mw mx my aw mz dt"><span id="0020" class="na kt hu mw b fv nb nc l nd ne">npm install modofun</span></pre><p id="4e23" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">你可以在官方网站找到更多的例子和详细的文档:【https://modofun.js.org<a class="ae kr" href="https://modofun.js.org" rel="noopener ugc nofollow" target="_blank">。你也可以在GitHub上找到完整的源代码:【https://github.com/modofunjs/modofun</a><a class="ae kr" href="https://github.com/modofunjs/modofun" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl lq lr hc ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hn ho hp hq hr"><p id="44ce" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">还有一个<a class="ae kr" href="https://github.com/fptavares/record-scrobbler" rel="noopener ugc nofollow" target="_blank">真实世界的例子</a>，包括暴露<a class="ae kr" href="https://github.com/fptavares/record-scrobbler/tree/master/web-api" rel="noopener ugc nofollow" target="_blank">一个GraphQL端点</a>、<a class="ae kr" href="https://github.com/fptavares/record-scrobbler/tree/master/lastfm-service" rel="noopener ugc nofollow" target="_blank">一个使用类似Express的请求/响应模式的Google Cloud Functions部署</a>，以及<a class="ae kr" href="https://github.com/fptavares/record-scrobbler/tree/master/discogs-service" rel="noopener ugc nofollow" target="_blank">一个AWS Lambda部署</a>。全部采用<a class="ae kr" href="https://github.com/fptavares/modofun" rel="noopener ugc nofollow" target="_blank">魔多芬</a>，结合<a class="ae kr" href="https://babeljs.io" rel="noopener ugc nofollow" target="_blank">巴别塔</a>等炫酷技术。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nf mt l"/></div></figure></div></div>    
</body>
</html>