<html>
<head>
<title>Is There Room for One More?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">还有多一个人的地方吗？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/is-there-room-for-one-more-3462fc7e4a3e?source=collection_archive---------4-----------------------#2017-06-08">https://medium.com/hackernoon/is-there-room-for-one-more-3462fc7e4a3e?source=collection_archive---------4-----------------------#2017-06-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="b0c3" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">关于谷歌Android新房间图书馆的一些想法。</h2></div><p id="8edf" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在上一次Google I/O中，Google宣布了新的<a class="ae kf" href="https://developer.android.com/topic/libraries/architecture/index.html" rel="noopener ugc nofollow" target="_blank">架构组件</a>。其中之一是房间。Room是Android开发者的另一个ORM解决方案。结合谷歌发布的一些其他元素(如LiveData、ViewModel和Lifecycle Listeners)，基本应用的流程应该简单得多。</p><p id="25a0" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">的确——谷歌在这方面做了一些不错的工作。像显示DB中的项目并更新它们这样简单的任务是一件痛苦的事情，而且您必须一遍又一遍地编写大量代码。<a class="ae kf" rel="noopener" href="/proandroiddev/clean-easy-new-how-to-architect-your-app-part-1-e439668a523d">现在你可以使用那些开箱即用的组件</a>。这将为开发人员节省时间:您将编写更少的代码，并且您将有更少的bug。</p><p id="b34e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当检查这些组件时，我感觉它们中的大多数都带来了新的东西。但是关于<a class="ae kf" href="https://developer.android.com/topic/libraries/architecture/room.html" rel="noopener ugc nofollow" target="_blank">室</a>——是否需要另一个ORM图书馆？</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff kg"><img src="../Images/8dfc38d80cdfdee1a55b3a2ad767fb4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SNKm1O99R6gNFHRizgaDGQ.png"/></div></div><figcaption class="ks kt fg fe ff ku kv bd b be z ek">Photo credit: <a class="ae kf" href="http://7-themes.com/7021413-android-wallpaper-3d.html" rel="noopener ugc nofollow" target="_blank">http://7-themes.com/7021413-android-wallpaper-3d.html</a></figcaption></figure><h1 id="8828" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated">ORM？</h1><p id="1267" class="pw-post-body-paragraph jj jk hu jl b jm lo iv jo jp lp iy jr js lq ju jv jw lr jy jz ka ls kc kd ke hn dt translated">让我们从头开始:对于不熟悉的人，ORM代表“对象关系映射”。这是一种更好的方式，让开发人员用持久对象来代替表或行。</p><p id="a8b4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这意味着如果我想在数据库中保存我所有的用户数据，我需要使用用户对象，ORM层将为我处理所有的持久性问题。好玩。</p><h1 id="5d17" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated">当前解决方案</h1><p id="8c66" class="pw-post-body-paragraph jj jk hu jl b jm lo iv jo jp lp iy jr js lq ju jv jw lr jy jz ka ls kc kd ke hn dt translated">这个概念并不新鲜，开发人员使用这种技术已经很长时间了，Android开发人员自然也需要这种东西。</p><p id="a969" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">很快我们就有了几个第三库来处理它，只要看一下<a class="ae kf" href="https://android-arsenal.com/tag/69" rel="noopener ugc nofollow" target="_blank"> AndroidArsenal page </a>就知道我们进入了拥挤的空间。最受欢迎的大概是<a class="ae kf" href="http://ormlite.com/" rel="noopener ugc nofollow" target="_blank"> ORMLite </a>、<a class="ae kf" href="http://greenrobot.org/greendao/" rel="noopener ugc nofollow" target="_blank"> GreenDAO </a>和<a class="ae kf" href="https://github.com/Raizlabs/DBFlow" rel="noopener ugc nofollow" target="_blank"> DbFlow </a>。</p><h1 id="9046" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated">创建模型</h1><p id="04ed" class="pw-post-body-paragraph jj jk hu jl b jm lo iv jo jp lp iy jr js lq ju jv jw lr jy jz ka ls kc kd ke hn dt translated">在Java中定义对象和表之间的映射有两种主要方法:一些DSL +代码生成器(像GreenDAO正在使用的)，或者使用注释(像ORMLite、DBFlow和大多数库)。虽然我不太喜欢注释，但我必须说后者是一个更容易的解决方案。</p><p id="8328" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这就是Android团队选择采用这种方法的原因，简单的数据模型如下所示:</p><pre class="kh ki kj kk fq lt lu lv lw aw lx dt"><span id="8c31" class="ly kx hu lu b fv lz ma l mb mc">@Entity<br/>public class User <strong class="lu hv">{</strong><br/>    @PrimaryKey<br/>    private int uid<strong class="lu hv">;</strong><br/><br/>    @ColumnInfo<strong class="lu hv">(</strong>name <strong class="lu hv">=</strong> "first_name"<strong class="lu hv">)</strong><br/>    private String firstName<strong class="lu hv">;</strong><br/><br/>    @ColumnInfo<strong class="lu hv">(</strong>name <strong class="lu hv">=</strong> "last_name"<strong class="lu hv">)</strong><br/>    private String lastName<strong class="lu hv">;</strong><br/><br/>    <em class="md">// Getters and setters are ignored for brevity,</em><br/>    <em class="md">// but they're required for Room to work.</em><br/>    <em class="md">//</em><br/>    <em class="md">// (Author note: please go and switch to Kotlin)</em><br/>    <em class="md">// (Author note #2: ok maybe you </em><a class="ae kf" href="https://stackoverflow.com/questions/44142964/room-persistence-lib-implementation-in-kotlin" rel="noopener ugc nofollow" target="_blank"><em class="md">should wait a bit</em></a><em class="md">)</em><br/><strong class="lu hv">}</strong></span></pre><p id="990c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">像在任何其他库中一样——您可以为表或列设置自定义名称，您可以选择索引一些内容并指定模型之间的关系。</p><h1 id="614f" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated">API</h1><p id="3bce" class="pw-post-body-paragraph jj jk hu jl b jm lo iv jo jp lp iy jr js lq ju jv jw lr jy jz ka ls kc kd ke hn dt translated">为了与数据模型交互，我们使用DAO-数据访问对象。所以谷歌也没有什么新东西。对于每个模型，我们需要声明一个具有CRUD操作的DAO。每个库都包含了主要的功能，并提供了一些相同的特性。</p><p id="717f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">但是</strong>虽然大多数ORM库使用了一些代码内查询构建器，Room做了一些好事，让你用巧妙的SQL格式声明你的查询。</p><p id="d8d0" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">例如，您将如何在每个平台中为特定用户执行简单的查询:</p><pre class="kh ki kj kk fq lt lu lv lw aw lx dt"><span id="2d49" class="ly kx hu lu b fv lz ma l mb mc"><em class="md">//Room:</em><br/>@Query<strong class="lu hv">(</strong>"SELECT * FROM user WHERE age &gt; :minAge"<strong class="lu hv">)</strong><br/>public User<strong class="lu hv">[]</strong> <strong class="lu hv">loadAllUsersOlderThan(</strong>int minAge<strong class="lu hv">);</strong><br/><br/><em class="md">//DbFlow:</em><br/>List<strong class="lu hv">&lt;</strong>User<strong class="lu hv">&gt;</strong> users <strong class="lu hv">=</strong> SQLite<strong class="lu hv">.</strong>select<strong class="lu hv">()</strong><br/>                         <strong class="lu hv">.</strong>from<strong class="lu hv">(</strong>User<strong class="lu hv">.</strong>class<strong class="lu hv">)</strong><br/>                         <strong class="lu hv">.</strong>where<strong class="lu hv">(</strong>User_Table<strong class="lu hv">.</strong>age<strong class="lu hv">.</strong>greaterThan<strong class="lu hv">(</strong>minAge<strong class="lu hv">)</strong><br/>                         <strong class="lu hv">.</strong>queryList<strong class="lu hv">();</strong><br/><br/><em class="md">//ORMLite:</em><br/>List<strong class="lu hv">&lt;</strong>User<strong class="lu hv">&gt;</strong> users <strong class="lu hv">=</strong> userDao<strong class="lu hv">.</strong>queryBuilder<strong class="lu hv">()</strong><br/>                          <strong class="lu hv">.</strong>where<strong class="lu hv">()</strong><br/>                          <strong class="lu hv">.</strong>gt<strong class="lu hv">(</strong>"age"<strong class="lu hv">,</strong> minAge<strong class="lu hv">)</strong><br/>                          <strong class="lu hv">.</strong>query<strong class="lu hv">();</strong><br/><em class="md">//GreenDAO:</em><br/>List<strong class="lu hv">&lt;</strong>User<strong class="lu hv">&gt;</strong> users <strong class="lu hv">=</strong> userDao<strong class="lu hv">.</strong>queryBuilder<strong class="lu hv">()</strong><br/>                          <strong class="lu hv">.</strong>where<strong class="lu hv">(</strong>Properties<strong class="lu hv">.</strong>Age<strong class="lu hv">.</strong>gt<strong class="lu hv">(</strong>minAge<strong class="lu hv">))</strong><br/>                          <strong class="lu hv">.</strong>list<strong class="lu hv">();</strong></span></pre><p id="e908" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一方面——它更干净，我们大多数人都熟悉SQL语法，但相反，您正在失去一些对象映射的能力(没有自动完成，您需要记住对象的表)。</p><h1 id="e6f4" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated">实时数据</h1><p id="4cd6" class="pw-post-body-paragraph jj jk hu jl b jm lo iv jo jp lp iy jr js lq ju jv jw lr jy jz ka ls kc kd ke hn dt translated">房间图书馆与谷歌宣布的其他架构组件配合得很好，特别是与<a class="ae kf" href="https://developer.android.com/topic/libraries/architecture/livedata.html" rel="noopener ugc nofollow" target="_blank">实时数据</a>的配合。因此，你可以很容易地得到关于数据变化的通知(通过<a class="ae kf" href="https://developer.android.com/topic/libraries/architecture/room.html#daos-query-observable" rel="noopener ugc nofollow" target="_blank">实时查询</a>或<a class="ae kf" href="https://developer.android.com/topic/libraries/architecture/room.html#daos-query-rxjava" rel="noopener ugc nofollow" target="_blank"> RxJava </a>),你不需要担心数据的实时更新。</p><p id="8df3" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这很棒，我觉得这是Room的优势之一。然而，我相信这种行为也可以通过在现有的库上添加另一层来处理所有的更改来实现。</p><blockquote class="me mf mg"><p id="d431" class="jj jk md jl b jm jn iv jo jp jq iy jr mh jt ju jv mi jx jy jz mj kb kc kd ke hn dt translated">(我编辑了文章并添加了实时数据部分，感谢<a class="mk ml gr" href="https://medium.com/u/7a8d96da8cb6?source=post_page-----3462fc7e4a3e--------------------------------" rel="noopener" target="_blank"> Zhuinden </a>评论)</p></blockquote><h1 id="0abb" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated">表演</h1><p id="6c71" class="pw-post-body-paragraph jj jk hu jl b jm lo iv jo jp lp iy jr js lq ju jv jw lr jy jz ka ls kc kd ke hn dt translated">读写数据库是一项开销很大的IO操作。如果你在应用程序中使用大量的实体，这可能是一个瓶颈。这就是为什么绿岛和DbFlow在性能上投入巨资(<a class="ae kf" href="https://github.com/Raizlabs/AndroidDatabaseLibraryComparison/issues/16" rel="noopener ugc nofollow" target="_blank">有时甚至会变得很难看</a>)。</p><p id="c5a4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我决定检查一下Room相对于其他性能的表现，所以我选择了GreenDAO基准测试(我也看了Raizlabs基准测试，但是我觉得它太偏了)，并添加了Room。你可以在这里看到源代码<a class="ae kf" href="https://github.com/greenrobot/android-database-performance/pull/19" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="aca6" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我将结果与帖子中讨论的库进行了比较。我在模拟器上运行了所有测试，并取了每个库结果的平均值(我将附上每个库的完整结果，这样您可以更仔细地查看)。</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div class="fe ff mm"><img src="../Images/a67fa54781dabe98f6d3d1d7a86dae56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*opzwkE_hmXw2qpsg.png"/></div></figure><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div class="fe ff mm"><img src="../Images/8b13d666b8829004cf1832f404fc8a1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*ZoBbjJP6OoGplix7.png"/></div></figure><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div class="fe ff mm"><img src="../Images/63304b87ac8f987f3c7eafbf9b4f9c5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*XQ_PHuFdPWtsIS-G.png"/></div></figure><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div class="fe ff mm"><img src="../Images/8d551ffe5c1bc4eb0767fbc9b2479bb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*Y91jYyhTuk4lxAl9.png"/></div></figure><p id="e4b4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是一个简单、快速的设置基准，我没有对结果进行过多的分析。从第一次看结果——您可以看到，与其他库相比，Room在任何性能方面都没有优势。而一个一个做小操作——ORMLite有自己的优势，在移动更大规模的时候——db flow和GreenDAO明显胜出(因为他们使用的缓存)。</p><h1 id="9ff6" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated">摘要</h1><p id="0d40" class="pw-post-body-paragraph jj jk hu jl b jm lo iv jo jp lp iy jr js lq ju jv jw lr jy jz ka ls kc kd ke hn dt translated">谷歌在帮助开发者更好地设计他们的应用方面做得非常出色。Google引入的最新组件已经就位，应该可以帮助我们每个人在更短的时间内写出更好的代码。</p><p id="4deb" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是，选择向<em class="md">提供另一个</em> ORM解决方案，而不是采用一个，这是我不理解的。我希望团队会采用一个有效的现有解决方案，甚至只是推荐一个(<a class="ae kf" href="https://developer.android.com/topic/libraries/architecture/guide.html#fetching_data" rel="noopener ugc nofollow" target="_blank">就像他们正在做的翻新</a>)。</p></div><div class="ab cl mn mo hc mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hn ho hp hq hr"><p id="a158" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你喜欢这篇文章，请点击下面的♡。作为一个作家，它意味着整个世界。</p><p id="6683" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">如果您想让Medium告诉您有关新帖子的信息，请单击关注按钮。</strong></p></div><div class="ab cl mn mo hc mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hn ho hp hq hr"><p id="37ca" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="md">完整报道:</em><br/><a class="ae kf" href="http://shem8.github.io/files/posts/room/PerfTestDbFlow-1by1.tsv" rel="noopener ugc nofollow" target="_blank"><em class="md">PerfTestDbFlow-1by 1 . tsv</em></a><br/><a class="ae kf" href="http://shem8.github.io/files/posts/room/PerfTestDbFlow-batch.tsv" rel="noopener ugc nofollow" target="_blank"><em class="md">PerfTestDbFlow-batch . tsv</em></a><br/><a class="ae kf" href="http://shem8.github.io/files/posts/room/PerfTestNotNull-1by1.tsv" rel="noopener ugc nofollow" target="_blank"><em class="md">PerfTestNotNull-1by 1 . tsv(绿岛)</em></a><br/><a class="ae kf" href="http://shem8.github.io/files/posts/room/PerfTestNotNull-batch.tsv" rel="noopener ugc nofollow" target="_blank"><em class="md">PerfTestNotNull-batch . tsv(绿岛)</em></a><br/><a class="ae kf" href="http://shem8.github.io/files/posts/room/PerfTestOrmLite-1by1.tsv" rel="noopener ugc nofollow" target="_blank"><em class="md">perftestorm</em></a></p></div><div class="ab cl mn mo hc mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hn ho hp hq hr"><p id="31db" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="md">原载于2017年6月2日</em><a class="ae kf" href="http://shem8.github.io/blog/2017/06/02/room-performance/" rel="noopener ugc nofollow" target="_blank"><em class="md">she M8 . github . io</em></a><em class="md">。</em></p><div class="kh ki kj kk fq ab cb"><figure class="mu kl mv mw mx my mz paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mu kl mv mw mx my mz paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mu kl mv mw mx my mz paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="me mf mg"><p id="f922" class="jj jk md jl b jm jn iv jo jp jq iy jr mh jt ju jv mi jx jy jz mj kb kc kd ke hn dt translated"><a class="ae kf" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客们如何开始他们的下午。我们是<a class="ae kf" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kf" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae kf" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jj jk md jl b jm jn iv jo jp jq iy jr mh jt ju jv mi jx jy jz mj kb kc kd ke hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kf" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kf" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff na"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>