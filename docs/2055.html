<html>
<head>
<title>Functional JavaScript: Resolving Promises Sequentially</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数式JavaScript:顺序解析承诺</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/functional-javascript-resolving-promises-sequentially-7aac18c4431e?source=collection_archive---------0-----------------------#2017-01-04">https://medium.com/hackernoon/functional-javascript-resolving-promises-sequentially-7aac18c4431e?source=collection_archive---------0-----------------------#2017-01-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/15f5d3529e690d31554750fde2e3eb7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*irPXj5W9eigW-VY7LvYX8Q.jpeg"/></div></div></figure><p id="49cb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我喜欢ES6附带的新的<a class="ae ka" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank"> Promise </a>库，尽管有一点被遗漏了，那就是一个顺序执行多个承诺的功能。</p><p id="9bac" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以使用类似<a class="ae ka" href="https://github.com/kriskowal/q" rel="noopener ugc nofollow" target="_blank"> Q </a>、<a class="ae ka" href="https://github.com/petkaantonov/bluebird" rel="noopener ugc nofollow" target="_blank">蓝鸟</a>、<a class="ae ka" href="https://github.com/tildeio/rsvp.js/" rel="noopener ugc nofollow" target="_blank"> RSVP.js </a>、<a class="ae ka" href="https://github.com/caolan/async" rel="noopener ugc nofollow" target="_blank"> Async </a>等库。或者我们可以自己做。我真的只需要一个函数，为一个函数导入整个库似乎有点沉重，这就是我创建这个的原因。</p><p id="7c21" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个承诺的一个特点是它立即执行。这实际上对我们不利，当我们准备好执行时，我们需要承诺来执行。</p><p id="62b1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我这样做的方法是将每个承诺转换成一个工厂函数。工厂函数将是一个返回承诺的简单函数。现在，当我们做出决定时，我们的承诺就会实现。</p><p id="8ae1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于这个虚构的例子，我决定使用jQuery的ajax方法作为我的承诺。</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="1b1c" class="kl km hu kh b fv kn ko l kp kq">// some dummy urls to resolve<br/>const urls = ['/url1', '/url2', '/url3']<br/><br/>// convert each url to a function that returns an ajax call<br/>const funcs = urls.map(url =&gt; () =&gt; $.ajax(url))</span></pre><p id="fa69" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">解决这个问题有点复杂，我发现它有助于我提前考虑我们的函数应该输出什么。大概是这样的:</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="83a2" class="kl km hu kh b fv kn ko l kp kq">Promise.resolve()<br/>  .then(x =&gt; funcs[0]()) // resolve func[0]<br/>  .then(x =&gt; funcs[1]()) // resolve func[1]<br/>  .then(x =&gt; funcs[2]()) // resolve func[2]</span></pre><p id="f5b2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我还希望最终承诺返回一个包含每个承诺结果的数组。</p><p id="00ab" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是最复杂的部分。我需要用一个空数组<code class="eh kr ks kt kh b">[]</code>开始每个承诺，然后将每个承诺的结果连接到该数组。跟着我，我会尽力分解它。</p><p id="6cbf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我将用一个空数组的初始值开始这个承诺，就像这个<code class="eh kr ks kt kh b">Promise.resolve([])</code>。然后使用Promise的<code class="eh kr ks kt kh b">then</code>功能执行每个工厂功能。</p><p id="506f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了简单起见，这个例子只解析func的索引<code class="eh kr ks kt kh b">0</code>。剩下的我们以后再做。</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="48f4" class="kl km hu kh b fv kn ko l kp kq">// start our promise off with an empty array. this becomes all.<br/>Promise.resolve([])<br/>  // all is the array we will append each result to.<br/>  .then(all =&gt; {<br/>    return funcs[0]().then(result =&gt; {<br/>      // concat the resolved promise result to all<br/>      return all.concat(result)<br/>    })<br/>   })</span></pre><p id="a350" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这段代码可以通过从我们的代码中删除所有的<code class="eh kr ks kt kh b">{</code>、<code class="eh kr ks kt kh b">}</code>和<code class="eh kr ks kt kh b">return</code>以更简洁的方式来表达。</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="ee8c" class="kl km hu kh b fv kn ko l kp kq">Promise.resolve([])<br/>  .then(all =&gt; funcs[0]().then(result =&gt; all.concat(result)))</span></pre><p id="0b16" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">去掉箭头函数一个巧妙方法是像这样直接调用<code class="eh kr ks kt kh b">concat</code>:</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="a544" class="kl km hu kh b fv kn ko l kp kq">Promise.resolve([])<br/>  .then(all =&gt; funcs[0]().then(Array.prototype.concat.bind(all)))</span></pre><p id="a4b4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，这将是我们函数的输出:</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="aa35" class="kl km hu kh b fv kn ko l kp kq">Promise.resolve([])<br/>  .then(x =&gt; funcs[0]().then(Array.prototype.concat.bind(x)))<br/>  .then(x =&gt; funcs[1]().then(Array.prototype.concat.bind(x)))<br/>  .then(x =&gt; funcs[2]().then(Array.prototype.concat.bind(x)))</span></pre><p id="fc1d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还不算太糟吧？现在我们知道了我们的输入和输出，让我们开始吧！</p><p id="e841" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以使用一个<code class="eh kr ks kt kh b">for</code>循环(但这不是很实用)，我们也可以使用递归，但我真正喜欢这个问题的是<code class="eh kr ks kt kh b">reduce</code>。</p><blockquote class="ku"><p id="c103" class="kv kw hu bd kx ky kz la lb lc ld jz ek translated">每当需要将一个列表转换成一个对象时，可以考虑使用reduce。</p></blockquote><p id="1103" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">我们的<code class="eh kr ks kt kh b">promiseSerial</code>函数应该接受一个工厂函数数组(每个函数返回一个承诺),并将它们简化为上面表示的单个承诺链。</p><p id="52b7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的初始值<code class="eh kr ks kt kh b">Promise.resolve([])</code>像这样传递给我们的reduce方法:</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="8bd6" class="kl km hu kh b fv kn ko l kp kq">const promiseSerial = funcs =&gt;<br/>  funcs.reduce((promise, func) =&gt; ???, Promise.resolve([]))</span></pre><p id="bdf8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后一部分是从上面概括我们的一个承诺<code class="eh kr ks kt kh b">then</code>，并更新一些参数名称。(新部分以粗体显示)</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="70ba" class="kl km hu kh b fv kn ko l kp kq">const promiseSerial = funcs =&gt;<br/>  funcs.reduce((promise, func) =&gt;<br/>    promise.then(result =&gt;<br/>      <strong class="kh hv">func().then(Array.prototype.concat.bind(result)))</strong>,<br/>      Promise.resolve([]))</span></pre><p id="ac4b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就是这样！一个非常简单的…划掉那个…短函数，它将依次解析承诺。</p><p id="ecdf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，让我们一起拍击它。</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="5d16" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我们已经不再需要安装第三方库，因为我们有了全新的<code class="eh kr ks kt kh b">promiseSerial</code>功能。</p><p id="4a0f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">嘿！你居然坚持到了这篇文章的结尾！</p><p id="20d0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你在顺序解决承诺的用例是什么？你是怎么解决的？请分享你的经历。</p><p id="f4ed" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我知道这是一件小事，但当我在媒体和Twitter上收到这些后续通知时，我感到非常高兴。或者你觉得我满嘴屁话，在下面的评论里告诉我。</p><p id="dea4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">干杯！</p><h1 id="cbff" class="ll km hu bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh dt translated">相关文章</h1><div class="mi mj fm fo mk ml"><a rel="noopener follow" target="_blank" href="/@joelthoms/rethinking-javascript-break-is-the-goto-of-loops-51b27b1c85f8"><div class="mm ab ej"><div class="mn ab mo cl cj mp"><h2 class="bd hv fv z el mq eo ep mr er et ht dt translated">重新思考JavaScript: Break是循环的归宿</h2><div class="ms l"><h3 class="bd b fv z el mq eo ep mr er et ek translated">在我的上一篇文章《for循环之死》中，我试图说服您放弃for循环，转而使用一个更具功能性的…</h3></div><div class="mt l"><p class="bd b gc z el mq eo ep mr er et ek translated">medium.com</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz ja ml"/></div></div></a></div><div class="mi mj fm fo mk ml"><a href="https://hackernoon.com/rethinking-javascript-death-of-the-for-loop-c431564c84a8" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab ej"><div class="mn ab mo cl cj mp"><h2 class="bd hv fv z el mq eo ep mr er et ht dt translated">重新思考JavaScript:For循环的死亡</h2><div class="ms l"><h3 class="bd b fv z el mq eo ep mr er et ek translated">JavaScript的for循环为我们提供了很好的服务，但是它现在已经过时了，应该被更新的函数所取代…</h3></div><div class="mt l"><p class="bd b gc z el mq eo ep mr er et ek translated">hackernoon.com</p></div></div><div class="mu l"><div class="na l mw mx my mu mz ja ml"/></div></div></a></div><div class="mi mj fm fo mk ml"><a rel="noopener follow" target="_blank" href="/@joelthoms/rethinking-javascript-the-if-statement-b158a61cd6cb"><div class="mm ab ej"><div class="mn ab mo cl cj mp"><h2 class="bd hv fv z el mq eo ep mr er et ht dt translated">重新思考JavaScript:if语句</h2><div class="ms l"><h3 class="bd b fv z el mq eo ep mr er et ek translated">功能性思维打开了我对编程的思维。</h3></div><div class="mt l"><p class="bd b gc z el mq eo ep mr er et ek translated">medium.com</p></div></div><div class="mu l"><div class="nb l mw mx my mu mz ja ml"/></div></div></a></div><div class="kc kd ke kf fq ab cb"><figure class="nc iv nd ne nf ng nh paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nc iv nd ne nf ng nh paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nc iv nd ne nf ng nh paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ni nj nk"><p id="f922" class="jc jd kb je b jf jg jh ji jj jk jl jm nl jo jp jq nm js jt ju nn jw jx jy jz hn dt translated"><a class="ae ka" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ka" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ka" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ka" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd kb je b jf jg jh ji jj jk jl jm nl jo jp jq nm js jt ju nn jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ka" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ka" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff no"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>