<html>
<head>
<title>Obey the (Type) Laws!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">遵守法律！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/obey-the-type-laws-ffb2fa4e5fe2?source=collection_archive---------19-----------------------#2017-03-20">https://medium.com/hackernoon/obey-the-type-laws-ffb2fa4e5fe2?source=collection_archive---------19-----------------------#2017-03-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="7ca6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们现在应该对<a class="ae jp" href="https://mmhaskell.com/blog/2017/1/30/the-easiest-haskell-idiom" rel="noopener ugc nofollow" target="_blank">函子</a>、<a class="ae jp" href="https://mmhaskell.com/blog/2017/2/6/applicatives-one-step-further" rel="noopener ugc nofollow" target="_blank">应用函子</a>和<a class="ae jp" href="https://mmhaskell.com/blog/2017/2/13/finally-understanding-monads-part-1" rel="noopener ugc nofollow" target="_blank">单子</a>有了相当好的理解。如果你需要复习，一定要看看这些文章！现在我们理解了这些概念，所以是时候学习它们周围的<strong class="it hv">定律</strong>了。</p><p id="48b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">记住Haskell用一个类型类来表示每一个数学类。每个类型类都有一个或两个主要功能。所以，只要我们实现了那些函数和类型检查，我们就有了一个新的函子/应用/单子，对吗？</p><p id="87b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不完全是。是的，你的程序将被编译，你将能够使用这些实例。但这并不意味着你的实例遵循数学构造。如果他们不这样做，你的实例就不会满足其他程序员的期望。每个类型类都有自己的“法则”。例如，让我们回想一下我们在函子文章中创建的<code class="eh jq jr js jt b">GovDirectory</code>类型。假设我们创建了一个不同的仿函数实例:</p><pre class="ju jv jw jx fq jy jt jz ka aw kb dt"><span id="0a1a" class="kc kd hu jt b fv ke kf l kg kh">data GovDirectory a = GovDirectory {<br/>  mayor :: a,<br/>  interimMayor :: Maybe a,<br/>  cabinet :: Map String a,<br/>  councilMembers :: [a]<br/>}</span><span id="ccf7" class="kc kd hu jt b fv ki kf l kg kh">instance Functor GovDirectory where<br/>  fmap f oldDirectory = GovDirectory {<br/>    mayor = f (mayor oldDirectory),<br/>    interimMayor = Nothing,<br/>    cabinet = f &lt;$&gt; cabinet oldDirectory,<br/>    councilMembers = f &lt;$&gt; councilMembers oldDirectory<br/>  }</span></pre><p id="b69a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如我们将看到的，这将违反函子定律之一。在这种情况下，它不是真正的函子。它的行为会让任何试图使用它的程序员感到困惑。我们应该注意确保我们的实例有意义。一旦您对这些类型类有了感觉，您将创建的实例就有可能遵循这些规律。所以，如果其中一些令人困惑，不要担心。这篇文章将非常数学化，我们不会在概念上纠缠太多。不用背熟这些规律也能理解和使用这些类<strong class="it hv">。所以事不宜迟，让我们深入法律！</strong></p><h1 id="9be0" class="kj kd hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">函子定律</h1><p id="81c2" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">有两个函子定律。首先是一个<strong class="it hv">同一律</strong>。对于每个类型类，我们会看到这种思想的一些变化。记住<code class="eh jq jr js jt b">fmap</code>如何在我们的容器上“映射”一个函数。如果我们将identity函数映射到一个容器，结果应该是相同的容器对象:</p><pre class="ju jv jw jx fq jy jt jz ka aw kb dt"><span id="0a6d" class="kc kd hu jt b fv ke kf l kg kh">fmap id = id</span></pre><p id="7f32" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">换句话说，我们的函子不应该应用任何额外的变化或副作用。它应该只应用函数。第二个定律是一个<strong class="it hv">合成定律</strong>。它声明我们的仿函数实现不应该破坏函数的组成:</p><pre class="ju jv jw jx fq jy jt jz ka aw kb dt"><span id="db81" class="kc kd hu jt b fv ke kf l kg kh">fmap (g . f) = fmap g . fmap f</span><span id="24f6" class="kc kd hu jt b fv ki kf l kg kh">-- For reference, remember the type of the composition operator:<br/>(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)</span></pre><p id="46df" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一方面，我们组合了两个函数，并将结果函数映射到我们的容器上。另一方面，我们映射第一个函数，得到结果，然后映射第二个函数。函子合成法则规定这些结果应该是相同的。这听起来很复杂。但是你不需要太担心。如果你违反了Haskell中的合成法则，你也很可能违反了同一性法则。</p><p id="b47e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是函子仅有的两条定律！让我们继续讨论应用函子。</p><h1 id="414d" class="kj kd hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">适用法律</h1><p id="a1ba" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">应用函子稍微复杂一点。他们有<strong class="it hv">四种不同的法律</strong>。不过，第一个很简单。这是另一个简单的恒等式。上面写着:</p><pre class="ju jv jw jx fq jy jt jz ka aw kb dt"><span id="cc8f" class="kc kd hu jt b fv ke kf l kg kh">pure id &lt;*&gt; v = v</span></pre><p id="9a1d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在左侧，我们包装了标识函数。然后我们把它涂在我们的容器上。适用的同一律规定这应该导致一个相同的对象。很简单。</p><p id="bbe8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第二个定律是<strong class="it hv">同态</strong>定律。假设我们在<code class="eh jq jr js jt b">pure</code>中包装了一个函数和一个对象。然后，我们可以对包装的对象应用包装的函数。当然，我们也可以在普通对象上应用普通函数，然后用pure包装它。同态定律表明这些结果应该是相同的。</p><pre class="ju jv jw jx fq jy jt jz ka aw kb dt"><span id="806b" class="kc kd hu jt b fv ke kf l kg kh">pure f &lt;*&gt; pure x = pure (f x)</span></pre><p id="3784" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们应该在这里看到一个独特的模式。几乎所有这些法律的首要主题是我们的类型类是容器。类型类函数不应该有任何副作用。他们应该做的就是促进数据的<strong class="it hv">包装、解包和转换</strong>。</p><p id="8f1f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第三个定律是交换定律。有点复杂，不要太多心。它指出我们包装东西的顺序并不重要。一方面，我们将任何应用程序应用到一个纯包装的对象上。另一方面，首先我们包装一个函数<strong class="it hv">，将对象</strong>作为参数。然后我们将它应用于第一个应用程序。这些应该是一样的。</p><pre class="ju jv jw jx fq jy jt jz ka aw kb dt"><span id="f61e" class="kc kd hu jt b fv ke kf l kg kh">u &lt;*&gt; pure y = pure ($ y) &lt;*&gt; u</span></pre><p id="9261" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最终的适用法则模仿第二函子法则。这是一个合成定律。它指出函数组合适用于函子内的应用程序:</p><pre class="ju jv jw jx fq jy jt jz ka aw kb dt"><span id="74f3" class="kc kd hu jt b fv ke kf l kg kh">pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w)</span></pre><p id="a1f5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里法律的数量可能有点多。记住，你做的例子可能会遵循法律！让我们继续最后一个例子:单子。</p><h1 id="5ae6" class="kj kd hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">单子定律</h1><p id="422c" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">单子有三个定律。前两个是简单的<strong class="it hv">恒等法则</strong>，就像我们其他的职业一样:</p><pre class="ju jv jw jx fq jy jt jz ka aw kb dt"><span id="d5bc" class="kc kd hu jt b fv ke kf l kg kh">return a &gt;&gt;= f = f<br/>m &gt;&gt;= return = m</span></pre><p id="df62" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是左右身份。它们有效地声明了<code class="eh jq jr js jt b">return</code>函数唯一被允许做的<strong class="it hv">事情是包装对象(听起来熟悉吗？).它<strong class="it hv">不能以任何方式操纵数据</strong>。我们的主要收获是，以下代码示例是等效的:</strong></p><pre class="ju jv jw jx fq jy jt jz ka aw kb dt"><span id="67b0" class="kc kd hu jt b fv ke kf l kg kh">func1 :: IO String<br/>func1 = do<br/>  str &lt;- getLine<br/>  return str</span><span id="cf2e" class="kc kd hu jt b fv ki kf l kg kh">func2 :: IO String<br/>func2 = getLine</span></pre><p id="02ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第三定律更有趣一点。它告诉我们单子中的结合律成立:</p><pre class="ju jv jw jx fq jy jt jz ka aw kb dt"><span id="03af" class="kc kd hu jt b fv ke kf l kg kh">(m &gt;&gt;= f) &gt;&gt;= g = m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)</span></pre><p id="b550" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是我们看到第三个定律和其他合成定律有相似的结构。在第一种情况下，我们分两步应用两个函数。在第二种情况下，我们首先组合函数，然后应用结果。这些应该是一样的。</p><p id="6bd9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">综上所述，所有定律都有两个主要观点。首先，<strong class="it hv">身份</strong>应该保留在包装函数上，像<code class="eh jq jr js jt b">pure</code>和<code class="eh jq jr js jt b">return</code>。第二，<strong class="it hv">功能组合</strong>应该贯穿我们的结构。</p><h1 id="3574" class="kj kd hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">检查法律</h1><p id="73dc" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">正如我之前所说的，你想出的大多数实例会自然地遵循这些规则。随着你对不同类型的类有了更多的经验，这将会更加真实。然而，确保万无一失也是值得的。Haskell有一个很好的工具来验证你的实例是否通过了某个法律。</p><p id="fb0b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个工具是快速检查。它可以采用任何特定的规则，根据该规则生成<strong class="it hv">许多不同的测试用例</strong>，并验证该规则是否成立。在这一节中，我们将对我们的<code class="eh jq jr js jt b">GovDirectory</code>仿函数实例进行一些测试。我们将看到<code class="eh jq jr js jt b">QuickCheck</code>如何证明它最初的失败，以及最终的成功。首先，我们需要在我们的类型上实现<code class="eh jq jr js jt b">Arbitrary</code>类型类。只要内部类型也是<code class="eh jq jr js jt b">Arbitrary</code>，比如内置的string类型，我们就可以这么做。然后我们将使用存在于我们内部类型上的所有其他<code class="eh jq jr js jt b">Arbitrary</code>实例:</p><pre class="ju jv jw jx fq jy jt jz ka aw kb dt"><span id="d0a4" class="kc kd hu jt b fv ke kf l kg kh">instance Arbitrary a =&gt; Arbitrary (GovDirectory a) where<br/>  arbitrary = do<br/>    m &lt;- arbitrary<br/>    im &lt;- arbitrary<br/>    cab &lt;- arbitrary<br/>    cm &lt;- arbitrary<br/>    return $ GovDirectory<br/>      { mayor = m<br/>      , interimMayor = im<br/>      , cabinet = cab<br/>      , councilMembers = cm }</span></pre><p id="52d7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦你完成了这些，你就可以为一个特定的规则编写一个测试用例。在这种情况下，我们检查函子的单位函数:</p><pre class="ju jv jw jx fq jy jt jz ka aw kb dt"><span id="cc31" class="kc kd hu jt b fv ke kf l kg kh">main :: IO ()<br/>main = quickCheck govDirectoryFunctorCheck</span><span id="c931" class="kc kd hu jt b fv ki kf l kg kh">govDirectoryFunctorCheck :: GovDirectory String -&gt; Bool<br/>govDirectoryFunctorCheck gd = fmap id gd == gd</span></pre><p id="1802" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们在上面使用的错误实例上测试一下。我们可以看到一个特定的测试<strong class="it hv">将会失败</strong>:</p><pre class="ju jv jw jx fq jy jt jz ka aw kb dt"><span id="ed44" class="kc kd hu jt b fv ke kf l kg kh">*** Failed! Falsifiable (after 2 tests):<br/>GovDirectory {mayor = "", interimMayor = Just "\156", cabinet = fromList [("","")], councilMembers = []}</span></pre><p id="2df6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它为我们指定了一个测试失败的任意实例。现在假设我们纠正了这个实例:</p><pre class="ju jv jw jx fq jy jt jz ka aw kb dt"><span id="8c54" class="kc kd hu jt b fv ke kf l kg kh">interimMayor = f &lt;$&gt; (interimMayor oldDirectory),</span></pre><p id="9832" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们会看到测试通过的！</p><pre class="ju jv jw jx fq jy jt jz ka aw kb dt"><span id="3e17" class="kc kd hu jt b fv ke kf l kg kh">+++ OK, passed 100 tests.</span></pre><h1 id="e762" class="kj kd hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">摘要</h1><p id="258a" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">我们已经讨论了三个主要的类型类:函子、应用函子和单子。他们都有他们应该遵循的特定法律。其他使用你的代码的程序员会希望你做的任何实例都遵循这些法则。一旦你熟悉了这些类型，你就有可能创建遵循这些规律的实例。但是如果您不确定，您可以使用快速检查实用程序来验证它们。</p><p id="acbc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的单子系列到此结束！现在，您应该拥有了在实践中开始使用它们所需的所有工具。请记住，它们是一个很难的概念，您可能需要复习几次。但最终，你会明白的！</p><p id="8169" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你现在想开始使用Haskell，一定要看看我们免费的<a class="ae jp" href="https://www.mmhaskell.com/checklist" rel="noopener ugc nofollow" target="_blank">入门清单</a>！它将通过帮助您完成下载过程和使用Stack制作您的第一个项目来帮助您开始Haskell体验！</p><p id="4335" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你准备迎接更大的挑战，你应该得到我们的<a class="ae jp" href="https://www.mmhaskell.com/workbook" rel="noopener ugc nofollow" target="_blank">递归练习册</a>。也是免费的！它有几章关于递归和高阶函数的内容。它还有10道练习题供你试用！</p><blockquote class="ll lm ln"><p id="1f31" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>