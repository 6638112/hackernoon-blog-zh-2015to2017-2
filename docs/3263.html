<html>
<head>
<title>Using Observables in real life</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在现实生活中使用可观察的事物</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/using-observables-to-make-our-app-work-with-barcode-scanners-e8a673fba625?source=collection_archive---------2-----------------------#2017-03-23">https://medium.com/hackernoon/using-observables-to-make-our-app-work-with-barcode-scanners-e8a673fba625?source=collection_archive---------2-----------------------#2017-03-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/583d4bbcdb16d630df2690c870b44ce7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QZeaDUnnivTffm_slGKFLw.jpeg"/></div></div></figure><p id="4890" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">这个故事也被贴在了我的个人博客</em>  <em class="ka">上的</em> <a class="ae kb" href="https://www.nicoespeon.com/en/2017/03/using-observables-in-real-life/" rel="noopener ugc nofollow" target="_blank"> <em class="ka">。</em></a></p><p id="48ba" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这篇文章中，我将讨论一个具体的用例，在这个用例中，可观察性变得非常重要，使我们的代码更加整洁，更易于维护。</p><h2 id="b6c2" class="kc kd hu bd ke kf kg kh ki kj kk kl km jn kn ko kp jr kq kr ks jv kt ku kv kw dt translated">如何识别条形码扫描仪？！</h2><p id="0603" class="pw-post-body-paragraph jc jd hu je b jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv lb jx jy jz hn dt translated">没错。这是一个特殊的例子。但它完美地说明了一些问题，这些问题会让你乞求使用Observables。</p><p id="716e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个<a class="ae kb" href="https://hackernoon.com/tagged/barcode" rel="noopener ugc nofollow" target="_blank">条形码</a>扫描仪简单地模仿键盘。它复制扫描的代码，发出按键信号，以“输入”键结束——该键码是<em class="ka"> 13 </em>。</p><p id="7fc2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设我们正在开发一个应用程序，允许用户从他们的16个字符的代码参考中搜索产品。用户应该能够使用条形码扫描仪来触发搜索，而不是手动输入。</p><blockquote class="lc ld le"><p id="80d3" class="jc jd ka je b jf jg jh ji jj jk jl jm lf jo jp jq lg js jt ju lh jw jx jy jz hn dt translated">"只要让用户集中搜索输入，扫描就大功告成了！"</p></blockquote><p id="ad71" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当然，这是天生的行为。</p><p id="7e88" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是搜索功能包含在一个弹出窗口中，可以用一个按钮打开。我们被告知该应用程序应该是超级符合人体工程学的！每当用户扫描条形码时，我们应该打开弹出窗口，并用扫描的代码填充输入。</p><p id="2868" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，问题是:我们如何将扫描的代码与其他按键事件区分开来？假设用户在扫描代码之前按了一个键:我们不希望这个键是被扫描代码的一部分！</p><h2 id="7015" class="kc kd hu bd ke kf kg kh ki kj kk kl km jn kn ko kp jr kq kr ks jv kt ku kv kw dt translated">解决这个问题，当务之急是</h2><p id="d01f" class="pw-post-body-paragraph jc jd hu je b jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv lb jx jy jz hn dt translated">我们当然需要监听按键事件…然后我们必须…记住按键代码，可能要使用缓冲区！如果按下的键是“输入”键，则填充输入并清理缓冲区。否则，将密钥添加到缓冲区中！</p><p id="b70d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们试试第一个镜头:</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="57bb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">很好。</p><p id="6d5e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但这还不够:它不能区分扫描代码和常规按键！</p><p id="0ba0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们知道，如果大约50毫秒后没有发出新的按键，这肯定不是扫描代码，我们可以清理缓冲区。</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="8147" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">嗯……还不错。但是这里有一个微妙的错误:如果代码扫描时间超过50毫秒，它将丢失开头…</p><p id="7858" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">事实上，如果新的按键在50毫秒内发生，我们应该清除超时。</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="aa91" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们有工作了。</p><p id="f820" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们退一步想一想:如果我们有按键事件的完整历史，我们可以操纵过滤扫描代码序列？代码会更简单吗？让我们来解决这个问题…</p><h2 id="65d3" class="kc kd hu bd ke kf kg kh ki kj kk kl km jn kn ko kp jr kq kr ks jv kt ku kv kw dt translated">解决这个问题，用可观的</h2><p id="70bf" class="pw-post-body-paragraph jc jd hu je b jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv lb jx jy jz hn dt translated">对于这种用例，我发现Observables是一个强大的抽象来表示我们的数据。</p><blockquote class="lo"><p id="4399" class="lp lq hu bd lr ls lt lu lv lw lx jz ek translated">可观察对象是<strong class="ak">不可变的异步事件集合</strong>，您可以通过<strong class="ak">操作符</strong>对其进行操作。</p></blockquote><p id="98eb" class="pw-post-body-paragraph jc jd hu je b jf ly jh ji jj lz jl jm jn ma jp jq jr mb jt ju jv mc jx jy jz hn dt translated">如果我们在数组上使用类似于<em class="ka">映射</em>和<em class="ka">过滤</em>的东西，那么我们已经熟悉了这种思维方式。</p><blockquote class="lc ld le"><p id="5afa" class="jc jd ka je b jf jg jh ji jj jk jl jm lf jo jp jq lg js jt ju lh jw jx jy jz hn dt translated">如果到目前为止可观测量对你来说仍然是神秘的，我建议你去读读<a class="ae kb" href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754" rel="noopener ugc nofollow" target="_blank">这篇来自安德烈·斯塔尔茨的关于反应式编程的精彩介绍</a>。</p></blockquote><p id="dd0c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，让我们将所有事件收集到一个可以转换的流中，而不是单独地响应每个事件。</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><blockquote class="lc ld le"><p id="9f60" class="jc jd ka je b jf jg jh ji jj jk jl jm lf jo jp jq lg js jt ju lh jw jx jy jz hn dt translated">变量名末尾的<strong class="je hv"> <em class="hu"> $ </em> </strong>符号表示“流”。<br/>这是一个约定，我用它来知道我操作的变量在非类型化语言中是可观察的，就像我会把<strong class="je hv"> <em class="hu">元素</em> </strong>称为一个由<strong class="je hv"> <em class="hu">元素</em> </strong>组成的数组，或者把<strong class="je hv"> <em class="hu"> $header </em> </strong>称为头部的jQuery表示。</p></blockquote><p id="d37b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们有了一串关键代码。每当发生按键事件时，都会发出一个新事件，该事件的值是相应的按键代码。</p><p id="bee7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这个过程的最后，我们希望有一个可以订阅的流。流中的每个事件应该代表被扫描的代码。因此，我们需要批量生产按键代码，将扫描代码与寄生按键隔离开来。</p><p id="b058" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为此，我们可以使用<strong class="je hv">去抖</strong>策略<strong class="je hv">缓冲</strong>我们的流:当一个事件发生时，等待50毫秒等待下一个事件。如果在此时间范围内发出另一个事件，再等待50毫秒。如果在此时间范围内没有发生其他事件，则创建一批传递的事件。</p><figure class="li lj lk ll fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff md"><img src="../Images/27dfb801b3f8c1604d238426e6ac76ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m382rBb8PLofAu6_rZ4mRA.png"/></div></div><figcaption class="me mf fg fe ff mg mh bd b be z ek">This is what we want to achieve with <a class="ae kb" href="http://reactivex.io/documentation/operators/buffer.html" rel="noopener ugc nofollow" target="_blank">the buffer operator</a></figcaption></figure><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="0485" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">到目前为止，一切顺利！</p><p id="04cb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我们要做的就是过滤掉那些看起来不像扫描码的批次。我们知道，扫描的代码是一个以“回车”键结束的序列。</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="d1e6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，让我们订阅我们创建的这个流，并在每次发出新事件时执行回调。</p><blockquote class="lo"><p id="124e" class="lp lq hu bd lr ls lt lu lv lw lx jz ek translated">除非我们认同可观察的事物，否则什么都不会发生，因为它们是懒惰的。</p></blockquote><figure class="mi mj mk ml mm iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><h2 id="b411" class="kc kd hu bd ke kf kg kh ki kj kk kl km jn kn ko kp jr kq kr ks jv kt ku kv kw dt translated">我们在这里做了什么</h2><p id="81ff" class="pw-post-body-paragraph jc jd hu je b jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv lb jx jy jz hn dt translated">这是我们从<em class="ka"> keyCode$ </em>到<em class="ka"> keyCodesBuffer$ </em>的可视化演示，keyCode$ 是通过按键事件创建的，我们订阅了:</p><figure class="li lj lk ll fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mn"><img src="../Images/c11c7bb15c46b8fe6d2abd791f9ae008.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*D72UTQdF5w7dx0AsfvEN3Q.gif"/></div></div><figcaption class="me mf fg fe ff mg mh bd b be z ek">Transforming the stream of key codes into a stream of scanned codes</figcaption></figure><p id="6281" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于我们的最终代码，有一些事情需要注意:</p><ul class=""><li id="be94" class="mo mp hu je b jf jg jj jk jn mq jr mr jv ms jz mt mu mv mw dt translated">我们不必手动管理诸如超时和缓冲之类的事情</li><li id="f7ba" class="mo mp hu je b jf mx jj my jn mz jr na jv nb jz mt mu mv mw dt translated">因此，代码更短，<strong class="je hv">关注于实际工作</strong></li><li id="5739" class="mo mp hu je b jf mx jj my jn mz jr na jv nb jz mt mu mv mw dt translated"><em class="ka"> fillInputWith() </em>不依赖于全局缓冲区，这更加<strong class="je hv">可测试</strong>和<strong class="je hv">可重用</strong>——实际上，我们离使整个逻辑完全功能化只有几步之遥</li><li id="1fe0" class="mo mp hu je b jf mx jj my jn mz jr na jv nb jz mt mu mv mw dt translated">我们只是操纵<em class="ka">常量</em> s，没有任何东西被重新分配，这使得<strong class="je hv">推理</strong>更加简单</li><li id="e4bd" class="mo mp hu je b jf mx jj my jn mz jr na jv nb jz mt mu mv mw dt translated">创建的流可以被<strong class="je hv">重用</strong>来做其他事情；我们可以<strong class="je hv">添加功能，而不用担心</strong>破坏这个功能</li><li id="446c" class="mo mp hu je b jf mx jj my jn mz jr na jv nb jz mt mu mv mw dt translated">我们可以很容易地修复这个代码中的问题，如果必要的话，在流创建管道中注入操作符——例如，我们可能会从<em class="ka"> keyCode$ </em>中过滤掉不感兴趣的键码，就像<em class="ka">一样简单。过滤器(isValidKeyCode) </em></li></ul><p id="a503" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我看来，一个困难的事情是用流来推理，并理解如何用给定的操作符来解决我们的用例。</p><p id="7160" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是，我相信这只是需要练习😉</p><div class="li lj lk ll fq ab cb"><figure class="nc iv nd ne nf ng nh paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nc iv nd ne nf ng nh paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nc iv nd ne nf ng nh paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="lc ld le"><p id="f922" class="jc jd ka je b jf jg jh ji jj jk jl jm lf jo jp jq lg js jt ju lh jw jx jy jz hn dt translated"><a class="ae kb" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kb" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kb" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae kb" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd ka je b jf jg jh ji jj jk jl jm lf jo jp jq lg js jt ju lh jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kb" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kb" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="li lj lk ll fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ni"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="nj ln l"/></div></figure></div></div>    
</body>
</html>