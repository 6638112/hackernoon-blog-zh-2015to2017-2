<html>
<head>
<title>Experimenting with Small Buffer Optimization for C++ Lambdas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++ Lambdas的小缓冲区优化实验</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/experimenting-with-small-buffer-optimization-for-c-lambdas-d5b703fb47e4?source=collection_archive---------6-----------------------#2017-09-19">https://medium.com/hackernoon/experimenting-with-small-buffer-optimization-for-c-lambdas-d5b703fb47e4?source=collection_archive---------6-----------------------#2017-09-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="b66f" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">TL；速度三角形定位法(dead reckoning)</h1><p id="559e" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我们实现了<code class="eh kn ko kp kq b">SmallFun</code>，它是<code class="eh kn ko kp kq b">std::function</code>的替代方案，实现了<em class="kr">固定大小的捕获优化</em>(一种小缓冲区优化的形式)。虽然<code class="eh kn ko kp kq b">SmallFun</code>比<code class="eh kn ko kp kq b">std::function</code>稍逊一筹，但在一些基准测试中，它比快<strong class="jr hv">3-5倍。</strong></p><p id="10fc" class="pw-post-body-paragraph jp jq hu jr b js ks ju jv jw kt jy jz ka ku kc kd ke kv kg kh ki kw kk kl km hn dt translated">你可以<a class="ae kx" href="https://github.com/LoopPerfect/smallfunction" rel="noopener ugc nofollow" target="_blank">在GitHub </a>上查看代码。</p><figure class="kz la lb lc fq ld fe ff paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="fe ff ky"><img src="../Images/e395fa0c102f946ca69d6ba89e72098d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q2X85fCAiULppjBiV9SC5A.jpeg"/></div></div><figcaption class="lk ll fg fe ff lm ln bd b be z ek">Photo by <a class="ae kx" href="https://unsplash.com/photos/ECju13NcBzg?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Pascal Richier</a> on <a class="ae kx" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="7c4e" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">背景</h1><p id="db2e" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated"><code class="eh kn ko kp kq b">std::function</code>是一种用闭包存储lambdas(也称为捕获)的便捷方式，同时提供了一个统一的接口。如果你来自面向对象的世界，那么将它们理解为<a class="ae kx" href="https://en.wikipedia.org/wiki/Strategy_pattern" rel="noopener ugc nofollow" target="_blank">策略模式</a>的概括可能会有所帮助。</p><p id="1fc6" class="pw-post-body-paragraph jp jq hu jr b js ks ju jv jw kt jy jz ka ku kc kd ke kv kg kh ki kw kk kl km hn dt translated">在<code class="eh kn ko kp kq b">std::function</code>和lambdas之前，我们将创建一个手工制作的仿函数对象，如下所示:</p><figure class="kz la lb lc fq ld"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="b00a" class="pw-post-body-paragraph jp jq hu jr b js ks ju jv jw kt jy jz ka ku kc kd ke kv kg kh ki kw kk kl km hn dt translated">这个库比较了<code class="eh kn ko kp kq b">std::function</code>，手工制作的<code class="eh kn ko kp kq b">Functor</code>和<code class="eh kn ko kp kq b">SmallFun</code>。我们发现<code class="eh kn ko kp kq b">SmallFun</code>比<code class="eh kn ko kp kq b">std::function</code>表现得更好，因为它不那么通用。</p><h1 id="ba09" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">std::函数错过的机会</h1><p id="d4e9" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated"><code class="eh kn ko kp kq b">std::function</code>使用<a class="ae kx" href="http://en.cppreference.com/w/cpp/language/pimpl" rel="noopener ugc nofollow" target="_blank"> PImpl模式</a>为给定签名的所有仿函数提供统一接口。</p><p id="1e57" class="pw-post-body-paragraph jp jq hu jr b js ks ju jv jw kt jy jz ka ku kc kd ke kv kg kh ki kw kk kl km hn dt translated">例如，这两个实例<code class="eh kn ko kp kq b">f</code>和<code class="eh kn ko kp kq b">g</code>具有相同的大小，尽管它们具有不同的捕获:</p><figure class="kz la lb lc fq ld"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="a469" class="pw-post-body-paragraph jp jq hu jr b js ks ju jv jw kt jy jz ka ku kc kd ke kv kg kh ki kw kk kl km hn dt translated">这是因为<code class="eh kn ko kp kq b">std::function</code>将捕获存储在<em class="kr">堆</em>中。这统一了所有实例的大小，但也是优化的机会！</p><h1 id="0748" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">怎么会？</h1><p id="93f3" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我们可以将函数对象(包括它的虚拟表)放入<em class="kr">栈</em>中预先分配的位置，而不是在<em class="kr">堆</em>上动态分配内存。</p><p id="5c60" class="pw-post-body-paragraph jp jq hu jr b js ks ju jv jw kt jy jz ka ku kc kd ke kv kg kh ki kw kk kl km hn dt translated">这就是我们如何实现<code class="eh kn ko kp kq b">SmallFun</code>，它的用法很像<code class="eh kn ko kp kq b">std::function</code>:</p><figure class="kz la lb lc fq ld"><div class="bz el l di"><div class="lo lp l"/></div></figure><h1 id="f02b" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">基准</h1><figure class="kz la lb lc fq ld"><div class="bz el l di"><div class="lo lp l"/></div></figure><h1 id="ed4b" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">测试</h1><p id="64d4" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">为了测试我们分配和调用函子的速度，我们将把所有实例保存在一个vector中，并在一个循环中执行它们。结果被保存到另一个向量中，以确保优化器不会优化掉我们正在测试的内容。</p><figure class="kz la lb lc fq ld"><div class="bz el l di"><div class="lo lp l"/></div></figure><h1 id="dbd8" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">SmallFun实现细节</h1><p id="27a3" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">要实现<code class="eh kn ko kp kq b">SmallFun</code>，需要结合三种C++模式:<a class="ae kx" href="https://akrzemi1.wordpress.com/2013/11/18/type-erasure-part-i/" rel="noopener ugc nofollow" target="_blank"> type-erasure </a>、<a class="ae kx" href="http://en.cppreference.com/w/cpp/language/pimpl" rel="noopener ugc nofollow" target="_blank"> PImpl </a>和<a class="ae kx" href="https://stackoverflow.com/a/222578/1256041" rel="noopener ugc nofollow" target="_blank"> placement-new </a>。</p><h2 id="9358" class="lq is hu bd it lr ls lt ix lu lv lw jb ka lx ly jf ke lz ma jj ki mb mc jn md dt translated">类型擦除</h2><p id="e506" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">类型擦除将许多实现统一到一个接口中。在我们的例子中，每个lambda(或functor)都有一个自定义的调用操作符和析构函数。我们需要为API消费者将要使用的任何类型自动生成一个实现。</p><p id="c058" class="pw-post-body-paragraph jp jq hu jr b js ks ju jv jw kt jy jz ka ku kc kd ke kv kg kh ki kw kk kl km hn dt translated">这将是我们的公共接口:</p><figure class="kz la lb lc fq ld"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="2e6b" class="pw-post-body-paragraph jp jq hu jr b js ks ju jv jw kt jy jz ka ku kc kd ke kv kg kh ki kw kk kl km hn dt translated">对于任何具有给定签名的可调用类型:</p><figure class="kz la lb lc fq ld"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="5330" class="pw-post-body-paragraph jp jq hu jr b js ks ju jv jw kt jy jz ka ku kc kd ke kv kg kh ki kw kk kl km hn dt translated">现在我们可以这样使用它:</p><figure class="kz la lb lc fq ld"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="5cae" class="pw-post-body-paragraph jp jq hu jr b js ks ju jv jw kt jy jz ka ku kc kd ke kv kg kh ki kw kk kl km hn dt translated">这相当麻烦而且容易出错。下一步将是容器。</p><h2 id="54a6" class="lq is hu bd it lr ls lt ix lu lv lw jb ka lx ly jf ke lz ma jj ki mb mc jn md dt translated">PImpl</h2><p id="f25c" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">PImpl分离、隐藏、管理实际实现的生命周期，并公开有限的公共API。</p><p id="dfcc" class="pw-post-body-paragraph jp jq hu jr b js ks ju jv jw kt jy jz ka ku kc kd ke kv kg kh ki kw kk kl km hn dt translated">一个简单的实现如下所示:</p><figure class="kz la lb lc fq ld"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="b959" class="pw-post-body-paragraph jp jq hu jr b js ks ju jv jw kt jy jz ka ku kc kd ke kv kg kh ki kw kk kl km hn dt translated">这或多或少就是<code class="eh kn ko kp kq b">std::function</code>的实现方式。</p><p id="75c3" class="pw-post-body-paragraph jp jq hu jr b js ks ju jv jw kt jy jz ka ku kc kd ke kv kg kh ki kw kk kl km hn dt translated">那么我们如何移除堆分配呢？</p><h2 id="3295" class="lq is hu bd it lr ls lt ix lu lv lw jb ka lx ly jf ke lz ma jj ki mb mc jn md dt translated">位置-新建</h2><p id="c198" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">Placement-new在给定的地址分配内存。例如:</p><figure class="kz la lb lc fq ld"><div class="bz el l di"><div class="lo lp l"/></div></figure><h2 id="3f13" class="lq is hu bd it lr ls lt ix lu lv lw jb ka lx ly jf ke lz ma jj ki mb mc jn md dt translated">把所有的放在一起</h2><p id="f804" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">现在，我们只需要做一些小的更改来删除堆分配:</p><figure class="kz la lb lc fq ld"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="88be" class="pw-post-body-paragraph jp jq hu jr b js ks ju jv jw kt jy jz ka ku kc kd ke kv kg kh ki kw kk kl km hn dt translated">正如你可能注意到的，如果<code class="eh kn ko kp kq b">Model&lt;...&gt;</code>的尺寸大于<code class="eh kn ko kp kq b">SIZE</code>，就会发生不好的事情！一个断言只会在运行时捕捉到这一点，但为时已晚……幸运的是，这可以在编译时使用<code class="eh kn ko kp kq b">enable_if_t</code>捕捉到。</p><p id="a6a6" class="pw-post-body-paragraph jp jq hu jr b js ks ju jv jw kt jy jz ka ku kc kd ke kv kg kh ki kw kk kl km hn dt translated">但是首先，复制构造函数怎么样？</p><h2 id="7072" class="lq is hu bd it lr ls lt ix lu lv lw jb ka lx ly jf ke lz ma jj ki mb mc jn md dt translated">复制构造函数</h2><p id="86e4" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">与<code class="eh kn ko kp kq b">std::function</code>的实现不同，我们不能只是复制或移动一个<code class="eh kn ko kp kq b">std::shared_ptr</code>。我们也不能只按位复制内存，因为lambda可能管理一个由于副作用而只能释放一次的资源。因此，我们需要让模型能够为给定的内存位置复制构造自己。</p><p id="f76e" class="pw-post-body-paragraph jp jq hu jr b js ks ju jv jw kt jy jz ka ku kc kd ke kv kg kh ki kw kk kl km hn dt translated">我们只需要补充一点:</p><figure class="kz la lb lc fq ld"><div class="bz el l di"><div class="lo lp l"/></div></figure><h1 id="a534" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">进一步说明</h1><ul class=""><li id="fa7d" class="me mf hu jr b js jt jw jx ka mg ke mh ki mi km mj mk ml mm dt translated">正如我们看到的，我们可以在编译时验证一个Lambda是否适合我们的内存。如果没有，我们可以提供一个回退到堆分配的方法。</li><li id="651b" class="me mf hu jr b js mn jw mo ka mp ke mq ki mr km mj mk ml mm dt translated">一个更通用的<code class="eh kn ko kp kq b">SmallFun</code>实现需要一个通用分配器。</li><li id="fdd3" class="me mf hu jr b js mn jw mo ka mp ke mq ki mr km mj mk ml mm dt translated">我们注意到我们不能仅仅通过逐位复制内存来复制内存。然而，使用类型特征，我们可以检查底层数据类型是否是POD，然后按位复制。</li></ul><h1 id="373d" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">既然你在这里…</h1><p id="a11f" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我们创建了<a class="ae kx" href="https://github.com/LoopPerfect/buckaroo" rel="noopener ugc nofollow" target="_blank"> Buckaroo </a>来使集成C++库变得更容易。如果你想尝试一下，最好从<a class="ae kx" href="http://buckaroo.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">文档</a>开始。你可以在<a class="ae kx" href="https://buckaroo.pm/" rel="noopener ugc nofollow" target="_blank"> Buckaroo.pm </a>上浏览现有套餐，或者在<a class="ae kx" href="https://github.com/LoopPerfect/buckaroo-wishlist" rel="noopener ugc nofollow" target="_blank">愿望清单</a>上申请更多套餐。</p><div class="ms mt fm fo mu mv"><a href="https://hackernoon.com/approaches-to-c-dependency-management-or-why-we-built-buckaroo-26049d4646e7" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab ej"><div class="mx ab my cl cj mz"><h2 class="bd hv fv z el na eo ep nb er et ht dt translated">C++依赖管理的方法，或者我们为什么要建立Buckaroo</h2><div class="nc l"><h3 class="bd b fv z el na eo ep nb er et ek translated">C++是一种不寻常的语言，因为它还没有一个占主导地位的包管理器(我们正在努力！).结果是…</h3></div><div class="nd l"><p class="bd b gc z el na eo ep nb er et ek translated">hackernoon.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj li mv"/></div></div></a></div><div class="ms mt fm fo mu mv"><a href="https://hackernoon.com/error-handling-in-c-or-why-you-should-use-eithers-in-favor-of-exceptions-and-error-codes-f0640912eb45" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab ej"><div class="mx ab my cl cj mz"><h2 class="bd hv fv z el na eo ep nb er et ht dt translated">C++中的错误处理或:为什么你应该使用这两者之一来支持异常和错误代码</h2><div class="nc l"><h3 class="bd b fv z el na eo ep nb er et ek translated">TL；速度三角形定位法(dead reckoning)</h3></div><div class="nd l"><p class="bd b gc z el na eo ep nb er et ek translated">hackernoon.com</p></div></div><div class="ne l"><div class="nk l ng nh ni ne nj li mv"/></div></div></a></div></div></div>    
</body>
</html>