<html>
<head>
<title>Go Testing at Stream</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">进行流测试</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/go-testing-at-stream-bd361d0086e?source=collection_archive---------20-----------------------#2017-10-02">https://medium.com/hackernoon/go-testing-at-stream-bd361d0086e?source=collection_archive---------20-----------------------#2017-10-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/f860386d2a3e443be8da108ddc3c24df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pIpM5E_pmBSvwWZD.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><strong class="bd jg">Brought to you by </strong><a class="ae jh" href="https://goo.gl/LxzcfX" rel="noopener ugc nofollow" target="_blank"><strong class="bd jg">Stream</strong></a><strong class="bd jg">.</strong></figcaption></figure><figure class="jj jk jl jm fq iv fe ff paragraph-image"><div class="fe ff ji"><img src="../Images/54797f947f87581c2f0a426640d81695.png" data-original-src="https://miro.medium.com/v2/resize:fit:322/format:webp/0*IST95wgMtOdp-kPI.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">XKCD making fun of Facebook’s original Move Fast and Break Things motto</figcaption></figure><blockquote class="jn jo jp"><p id="82c7" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">披露:<a class="ae jh" href="https://goo.gl/LxzcfX" rel="noopener ugc nofollow" target="_blank"> Stream </a>，可伸缩提要的API，之前赞助过Hacker Noon。</p></blockquote><p id="71ef" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">超过500家公司和2亿终端用户在生产中使用Stream的API。虽然我们喜欢快速移动，但我们绝对不喜欢打破东西。</p><p id="eab6" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">广泛的测试基础设施使我们能够快速行动并自信地部署代码。随着您的团队和<a class="ae jh" href="https://hackernoon.com/tagged/codebase" rel="noopener ugc nofollow" target="_blank">代码库</a>的增长，一个可靠的测试工作流程对于保持生产力是必不可少的。</p><p id="7d63" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">大多数支持Stream的服务都是用Go编写的。这篇博文将详细介绍我们在为大型Go代码库编写测试时学到的东西。</p><h2 id="5def" class="ks kt hu bd ku kv kw kx ky kz la lb lc kp ld le lf kq lg lh li kr lj lk ll lm dt translated">我们的测试工作流程</h2><p id="db43" class="pw-post-body-paragraph jq jr hu jt b ju ln jw jx jy lo ka kb kp lp ke kf kq lq ki kj kr lr km kn ko hn dt translated">测试是我们开发过程的核心部分。在正确测试和同行评审之前，没有一行代码被部署到实际系统中。我们的工作流程如下所示:</p><ol class=""><li id="4256" class="ls lt hu jt b ju jv jy jz kp lu kq lv kr lw ko lx ly lz ma dt translated">使用Go的<code class="eh mb mc md me b">testing</code>包和来自<code class="eh mb mc md me b">stretchr/testify</code>的一些好东西实现TDD的新特性</li><li id="ec38" class="ls lt hu jt b ju mf jy mg kp mh kq mi kr mj ko lx ly lz ma dt translated">用<code class="eh mb mc md me b">onsi/ginkgo</code>和我们自己即将发布的<code class="eh mb mc md me b">bdd</code>库编写集成测试和验收测试</li><li id="8bcb" class="ls lt hu jt b ju mf jy mg kp mh kq mi kr mj ko lx ly lz ma dt translated">等待来自<a class="ae jh" href="https://travis-ci.com/" rel="noopener ugc nofollow" target="_blank">特拉维斯CI </a>的绿灯</li><li id="20c9" class="ls lt hu jt b ju mf jy mg kp mh kq mi kr mj ko lx ly lz ma dt translated">检查<a class="ae jh" href="https://codecov.io/" rel="noopener ugc nofollow" target="_blank"> Codecov </a>上的测试覆盖率</li><li id="9aeb" class="ls lt hu jt b ju mf jy mg kp mh kq mi kr mj ko lx ly lz ma dt translated">将新功能发布到暂存区</li></ol><h2 id="736a" class="ks kt hu bd ku kv kw kx ky kz la lb lc kp ld le lf kq lg lh li kr lj lk ll lm dt translated">单元测试</h2><p id="c309" class="pw-post-body-paragraph jq jr hu jt b ju ln jw jx jy lo ka kb kp lp ke kf kq lq ki kj kr lr km kn ko hn dt translated">在编写代码时遵循TDD方法的同时，我们利用Go的标准库<code class="eh mb mc md me b">testing</code>包来编写我们所有的测试:它的简单性与惯用的Go代码相匹配，更重要的是，它与我们广泛使用的表格测试完美配合。</p><p id="a003" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">正如有经验的程序员已经知道的那样，表测试是一种简单的方法，可以用很小的代码指纹对一个方法或行为执行多个输入/输出测试。此外，由于Go的匿名和内联结构，代码看起来简单且易于扩展:</p><pre class="jj jk jl jm fq mk me ml mm aw mn dt"><span id="8183" class="ks kt hu me b fv mo mp l mq mr">testCases := []struct{<br/>  input          string<br/>  expectedOutput int<br/>}{<br/>  {<br/>    input:          "aabbcc",<br/>    expectedOutput: 3,<br/>  },<br/>  {<br/>    input:          "abcdefg",<br/>    expectedOutput: 1,<br/>  },<br/>  ...<br/>}<br/><br/>for _, tc := range testCases {<br/>  output := getRepetitions(tc.input)<br/>  assert.Equal(t, tc.expectedOutput, output)<br/>}</span></pre><p id="260b" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">大多数地鼠都熟悉Go处理错误的模式，这种模式在编写测试时也会用到:调用一个方法，捕捉错误，检查它是否不是<code class="eh mb mc md me b">nil</code>，然后采取相应的行动(向左的幸福之路！).</p><p id="0939" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">用<code class="eh mb mc md me b">testing</code>包编写测试也是同样的方式，但是我们决定在它上面添加一些东西。</p><p id="7eb4" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">假设我们正在测试一个<code class="eh mb mc md me b">IsValid(*http.Request) (bool, error)</code>函数，它检查一个HTTP请求的报头是否是格式良好的，并且我们正在使用一个基于表的测试:</p><pre class="jj jk jl jm fq mk me ml mm aw mn dt"><span id="e1d8" class="ks kt hu me b fv mo mp l mq mr">func TestIsValid(t *testing.T) {<br/>        ...<br/>        for _, tc := range testCases {<br/>                t.Run(tc.name, func(t *testing.T) {<br/>                        valid, err := IsValid(tc.req)<br/>                        if tc.shouldError &amp;&amp; err == nil {<br/>                                t.Fatal("expected error, got none")<br/>                        }<br/>                        if !tc.shouldError &amp;&amp; err != nil {<br/>                                t.Fatalf("expected no error, got %s", err)<br/>                        }<br/>                        if valid != tc.expected {<br/>                                t.Errorf("expected valid to be %t, got %t", tc.expected, valid)<br/>                        }<br/>                })<br/>        }<br/>}</span></pre><p id="d036" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">我们发现通常的Go习惯性错误检查在测试中增加了太多的噪音，这就是为什么我们在所有的单元测试中采用了<a class="ae jh" href="https://github.com/stretchr/testify" rel="noopener ugc nofollow" target="_blank">evidence</a>的<code class="eh mb mc md me b">assert</code>和<code class="eh mb mc md me b">require</code>包。</p><p id="ef1f" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">前面的代码片段变成了:</p><pre class="jj jk jl jm fq mk me ml mm aw mn dt"><span id="3f98" class="ks kt hu me b fv mo mp l mq mr">import (<br/>        "github.com/stretchr/testify/assert"<br/>        "github.com/stretchr/testify/require"<br/>)<br/><br/>func TestIsValid(t *testing.T) {<br/>        ...<br/>        for _, tc := range testCases {<br/>                t.Run(tc.name, func(t *testing.T) {<br/>                        valid, err := IsValid(tc.req)<br/>                        if tc.shouldError {<br/>                                require.Error(t, err)<br/>                        } else {<br/>                                require.NoError(t, err)<br/>                        }<br/>                        assert.Equal(t, tc.expected, valid)<br/>                })<br/>        }<br/>}</span></pre><p id="2ed0" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">测试现在更加清晰，也更容易扩展。</p><p id="9589" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">一般来说，我们在测试前提条件时依靠<code class="eh mb mc md me b">require</code>(即:在继续之前检查函数返回的错误)和<code class="eh mb mc md me b">assert</code>来测试实际的逻辑断言。这确保了我们的测试总是返回有意义的结果，并且我们不必浪费时间调试我们自己的测试。</p><p id="bfd1" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">在我们代码库的某些地方，我们决定更进一步，使用完整的<a class="ae jh" href="https://godoc.org/github.com/stretchr/testify/suite" rel="noopener ugc nofollow" target="_blank">evidence/suite</a>包。这有助于我们更快地编写一些特殊的测试。</p><p id="602f" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">专业提示:当使用表格测试时，在你的表格中包含一个<code class="eh mb mc md me b">name</code>字段，该字段包含被测试条目的简要描述:使用它作为<code class="eh mb mc md me b">testing.T.Run</code>方法的<code class="eh mb mc md me b">name</code>参数将使你和你的队友能够一眼就理解测试，无论是查看代码还是查看<code class="eh mb mc md me b">test</code>命令输出。</p><pre class="jj jk jl jm fq mk me ml mm aw mn dt"><span id="2af5" class="ks kt hu me b fv mo mp l mq mr">func TestTable(t *testing.T) {<br/>        testCases := []struct {<br/>                name        string<br/>                dividend    float64<br/>                divisor     float64<br/>                shouldError bool<br/>        }{<br/>                {<br/>                        name:        "dividing by zero",<br/>                        shouldError: true,<br/>                        dividend:    42,<br/>                        divisor:     0,<br/>                },<br/>                {<br/>                        name:        "dividing by odd numbers",<br/>                        shouldError: false,<br/>                        dividend:    42,<br/>                        divisor:     21,<br/>                },<br/>                ...<br/>        }<br/>        for _, tc := range testCases {<br/>                t.Run(tc.name, func(t *testing.T) {<br/>                        ...<br/>                })<br/>        }<br/>}</span></pre><h2 id="4792" class="ks kt hu bd ku kv kw kx ky kz la lb lc kp ld le lf kq lg lh li kr lj lk ll lm dt translated">嘲弄的</h2><p id="6b31" class="pw-post-body-paragraph jq jr hu jt b ju ln jw jx jy lo ka kb kp lp ke kf kq lq ki kj kr lr km kn ko hn dt translated">编写模拟和“沙盒”行为是单元测试的重要部分，随着代码复杂性的增加，这变得越来越重要。</p><p id="d73a" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">我们决定使用两种方法来模仿，这取决于过程的“成本”:直接依赖注入或者GoMock框架。</p><h1 id="c251" class="ms kt hu bd ku mt mu mv ky mw mx my lc mz na nb lf nc nd ne li nf ng nh ll ni dt translated">依赖注入</h1><p id="24a8" class="pw-post-body-paragraph jq jr hu jt b ju ln jw jx jy lo ka kb kp lp ke kf kq lq ki kj kr lr km kn ko hn dt translated"><a class="ae jh" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank">依赖注入</a>是Go中常见的软件设计模式，在处理嘲讽时派上了用场。通过使用接口——可以说是Go最强大的特性，阻止行为和模仿组件变得非常简单。</p><p id="8707" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">假设我们有这个在<a class="ae jh" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>上执行缓存的<code class="eh mb mc md me b">DB</code>组件:</p><pre class="jj jk jl jm fq mk me ml mm aw mn dt"><span id="827e" class="ks kt hu me b fv mo mp l mq mr">type DB struct {<br/>        cache *redis.Client<br/>}<br/><br/>func (d *DB) Get(query string) (string, error) {<br/>        ...<br/>        cached, err := d.cache.Get(query).Result()<br/>        if err == redis.Nil {<br/>                return cached, nil<br/>        }<br/>        ...<br/>}</span></pre><p id="1e48" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">当测试<code class="eh mb mc md me b">DB.Get</code>方法的实际行为时，我们可能不需要实际的Redis连接:我们需要在我们的<code class="eh mb mc md me b">DB</code>结构中模拟<code class="eh mb mc md me b">cache</code>字段的行为。我们可以轻松地重新排列前面的代码，以便使用我们可以重新实现的接口:</p><pre class="jj jk jl jm fq mk me ml mm aw mn dt"><span id="68e4" class="ks kt hu me b fv mo mp l mq mr">type DB struct {<br/>        cache Cache<br/>}<br/><br/>type Cache interface {<br/>        Get(string) (string, error)<br/>}<br/><br/>type RedisCache struct {<br/>        client *redis.Client<br/>}<br/><br/>func (c *RedisCache) Get(key string) (string, error) {<br/>        v, err := c.client.Get(query).Result()<br/>        if err == redis.Nil {<br/>                return v, nil<br/>        }<br/>        return v, err<br/>}</span></pre><p id="a103" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">因此，我们也重新安排了<code class="eh mb mc md me b">DB.Get</code>受影响的部分:</p><pre class="jj jk jl jm fq mk me ml mm aw mn dt"><span id="9d91" class="ks kt hu me b fv mo mp l mq mr">func (d *DB) Get(query string) (string, error) {<br/>        cached, err := d.cache.Get(query)<br/>        if err != nil {<br/>                return "", err<br/>        }<br/>        if cached != "" {<br/>                return cached, nil<br/>        }<br/>        ...<br/>}</span></pre><p id="2d73" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">我们现在可以在测试中模拟缓存，只需用一个模拟结构实现<code class="eh mb mc md me b">Cache</code>接口，它的行为符合我们的需要:</p><pre class="jj jk jl jm fq mk me ml mm aw mn dt"><span id="b4c1" class="ks kt hu me b fv mo mp l mq mr">type mockCache struct{}<br/><br/>func (m mockCache) Get(string) (string, error) {<br/>        return "", nil<br/>}<br/><br/>func TestDBGet(t *testing.T) {<br/>        mock := mockCache{}<br/>        db := &amp;DB{cache: mock}<br/>        db.Get(...)<br/>        ...<br/>}</span></pre><h2 id="b9ae" class="ks kt hu bd ku kv kw kx ky kz la lb lc kp ld le lf kq lg lh li kr lj lk ll lm dt translated">golang/mock</h2><p id="72ae" class="pw-post-body-paragraph jq jr hu jt b ju ln jw jx jy lo ka kb kp lp ke kf kq lq ki kj kr lr km kn ko hn dt translated">在一些场景中，以前的方法会太复杂和/或浪费太多时间(或者，更糟糕的是，混淆了底层代码)。在这种情况下，我们用<a class="ae jh" href="https://github.com/golang/mock" rel="noopener ugc nofollow" target="_blank"> GoMock </a>框架创建“适当的”模拟:通过一个命令<code class="eh mb mc md me b">mockgen</code>，它生成完整类型的模拟，我们可以通过设置关于接收到的调用和输出的期望来在我们的测试中使用这些模拟。</p><p id="3df3" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">我们典型的用例是在处理gRPCs时:重构我们的代码以获得简单的、基于接口的组件会增加太多的噪音，而使用GoMock，我们基本上可以免费获得全功能的客户端和服务器模拟，这与您想要在RPC框架这样的输入输出系统上执行的测试完全匹配。</p><p id="f534" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">GoMock是一个强大的工具，它极大地简化了Gophers的生活，我们鼓励您使用它，并看看项目Github库上的<a class="ae jh" href="https://github.com/golang/mock/tree/master/sample" rel="noopener ugc nofollow" target="_blank">示例。</a></p><h2 id="7c5b" class="ks kt hu bd ku kv kw kx ky kz la lb lc kp ld le lf kq lg lh li kr lj lk ll lm dt translated">集成测试</h2><p id="3e25" class="pw-post-body-paragraph jq jr hu jt b ju ln jw jx jy lo ka kb kp lp ke kf kq lq ki kj kr lr km kn ko hn dt translated">我们不使用Go的默认库进行集成测试和验收测试。相反，我们将它们与代码库的其余部分分开，放在一个单独的存储库中，该存储库有自己的生命周期和专门的CI作业。这样做可以让我们执行非常仔细的功能测试、性能调优、与其他相关活动部件的集成、质量保证任务以及一般的端到端测试和基准测试。</p><p id="dc8c" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">起初，我们决定使用<a class="ae jh" href="https://onsi.github.io/ginkgo/" rel="noopener ugc nofollow" target="_blank">银杏</a>进行这类测试:银杏是一个伟大的开源贡献，它让BDD for Go变得非常方便。Go的特性使得编写行为驱动的代码比其他语言(如Python和Ruby)更复杂，但最终我们发现这是易用性和有效性之间的一个很好的平衡。</p><p id="c7fc" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">我们调整了我们的设置，并提出了以下结构:我们想要测试的每个特性/组件都存在于一个<code class="eh mb mc md me b">features/</code>文件夹中的专用包中，我们可以通过一些Makefile魔术轻松地运行特定的测试。这包括许多针对特定测试的选项，包括正则表达式(使用<code class="eh mb mc md me b">--focus</code>和<code class="eh mb mc md me b">--skip</code>银杏标志)、触发并行执行、检测竞争等等。</p><p id="2f54" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">但过了一段时间，我们得出结论，生银杏对我们的目的有一些缺点。最终，我们想要写出更好的“规格”，但是银杏测试对我们来说有以下问题:</p><ol class=""><li id="99a9" class="ls lt hu jt b ju jv jy jz kp lu kq lv kr lw ko lx ly lz ma dt translated">很快就会变得很吵</li><li id="0924" class="ls lt hu jt b ju mf jy mg kp mh kq mi kr mj ko lx ly lz ma dt translated">当谈到DSL和BDD <a class="ae jh" href="http://www.betterspecs.org/" rel="noopener ugc nofollow" target="_blank">最佳实践</a>时，不要鼓励强烈的观点</li><li id="87a8" class="ls lt hu jt b ju mf jy mg kp mh kq mi kr mj ko lx ly lz ma dt translated">没有(默认的)信息输出(但是可以用自定义的<code class="eh mb mc md me b">Reporter</code>来扩展)</li><li id="21d5" class="ls lt hu jt b ju mf jy mg kp mh kq mi kr mj ko lx ly lz ma dt translated">有不适合文档的输出</li><li id="ce60" class="ls lt hu jt b ju mf jy mg kp mh kq mi kr mj ko lx ly lz ma dt translated">没有内置的报告功能</li><li id="4cf7" class="ls lt hu jt b ju mf jy mg kp mh kq mi kr mj ko lx ly lz ma dt translated">对细粒度测试采取“不友好”的方法</li></ol><p id="c07c" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">因此，我们开始实验，并提出了一个自制的图书馆，部分建立在银杏和Gomega matchers之上。我们简单的叫它<code class="eh mb mc md me b">bdd</code>，到处都用。它将尽快开源并公开发布，但现在还没有；就当这是偷偷摸摸的高峰吧！</p><p id="edc2" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated"><code class="eh mb mc md me b">bdd</code>有两个目标:编写规范a-là RSpec和编写特性测试a-làcumber，利用这两个著名工具的所有优点。它展示了我们喜欢银杏的特征，隐藏了我们不喜欢的特征，还对我们想要如何写“规格”做出了一些强有力的假设:</p><ul class=""><li id="cbce" class="ls lt hu jt b ju jv jy jz kp lu kq lv kr lw ko nj ly lz ma dt translated">一个<code class="eh mb mc md me b">Spec</code>功能是一整套逻辑连接的测试的容器(就像那些与一个单一的广泛特性相关的测试)。</li><li id="fec1" class="ls lt hu jt b ju mf jy mg kp mh kq mi kr mj ko nj ly lz ma dt translated">一个<code class="eh mb mc md me b">Spec</code>包含任意数量的<code class="eh mb mc md me b">Describe</code>模块，定义“待测物”。</li><li id="c940" class="ls lt hu jt b ju mf jy mg kp mh kq mi kr mj ko nj ly lz ma dt translated">一个<code class="eh mb mc md me b">Describe</code>块包含任意数量的<code class="eh mb mc md me b">When</code>块(或其他<code class="eh mb mc md me b">Describe</code>块)。</li><li id="2e0d" class="ls lt hu jt b ju mf jy mg kp mh kq mi kr mj ko nj ly lz ma dt translated">一个<code class="eh mb mc md me b">When</code>块包含一个要对当前“事物”进行测试的场景。它也可以包含子场景作为<code class="eh mb mc md me b">Describe</code>块。</li><li id="691c" class="ls lt hu jt b ju mf jy mg kp mh kq mi kr mj ko nj ly lz ma dt translated">所有断言都在一个<code class="eh mb mc md me b">Should</code>函数中完成。</li></ul><p id="7151" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">使用这种结构编写测试对于这些测试的正确“句子”表述非常重要，并且允许我们更快地编写测试，同时更好地理解正在发生的事情。</p><p id="b6d8" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">随着公司的快速发展，这意味着新员工的加入和更多测试的加入。我们是新的队友，对编写测试感到舒适，并且不必浪费时间考虑如何一致地编写它们(特别是在他们进入Stream的第一天)。我们简陋的测试库就是为他们而编写的！</p><p id="7e19" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">我们现在有一个一致的、严肃的“测试语法”,为公司的每个开发人员所熟悉。拥有一个确保您的测试始终与您的团队成员的测试保持一致的库，可以带来更好的代码审查、更容易的报告检查，以及更快的开发周期。</p><p id="f633" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">撰写规格时，一切都从一个<code class="eh mb mc md me b">Spec</code>功能开始:</p><pre class="jj jk jl jm fq mk me ml mm aw mn dt"><span id="f4c1" class="ks kt hu me b fv mo mp l mq mr">var _ = Spec("Adding activities", func() {<br/><br/>        When("adding to a feed group that is not configured", func() {<br/><br/>                var err error<br/><br/>                BeforeEach(func() { feedGroup = "user_bogus_group" })<br/><br/>                JustBeforeEach(func() {<br/>                        _, err = feed.AddActivity(&amp;gestream.Activity{<br/>                                Actor:  "john",<br/>                                Verb:   "like",<br/>                                Object: "apples",<br/>                        })<br/>                })<br/><br/>                Should("return a clear error", func() {<br/>                        Expect(err).To(HaveOccurred())<br/>                        Expect(err).To(BeFeedConfigExceptionError())<br/>                        Expect(err).To(BeAnErrorWithDetailMsg("user_bogus_group feed group does not exists"))<br/>                })<br/>        })<br/>})</span></pre><p id="a922" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">如前所述，我们确保一个<code class="eh mb mc md me b">Describe</code>块总是包含任意数量的<code class="eh mb mc md me b">When</code>块，并且一个<code class="eh mb mc md me b">When</code>块总是包含一些<code class="eh mb mc md me b">Should</code>块。</p><p id="a480" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">我们还确保每个块的字符串描述不会因为它们所指的动词而断断续续，所以总是得到一个好的输出:我们认为阅读测试的输出是非常重要的，所以单个期望的语法应该总是用正确的英语来表达和阅读。</p><p id="6d69" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">我们希望我们的测试在编写好几个月之后还能被人熟悉地阅读:你真的不想阅读像<em class="js">这样糟糕的东西，当我登录时，有一个注销按钮</em>，但是</p><p id="3863" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated"><strong class="jt hv"> <em class="js">当</em> </strong> <em class="js">我登录后，</em> <strong class="jt hv"> <em class="js">注销按钮</em> </strong> <strong class="jt hv"> <em class="js">应该</em> </strong> <em class="js">可见</em>。</p><p id="8517" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">说到输出，我们受<a class="ae jh" href="http://rspec.info/" rel="noopener ugc nofollow" target="_blank"> RSpec </a>文档格式的启发编写了一个定制的银杏报告，它在控制台中看起来像这样:</p><pre class="jj jk jl jm fq mk me ml mm aw mn dt"><span id="a4f0" class="ks kt hu me b fv mo mp l mq mr">FlatFeeds Suite<br/><br/>  Flat Feeds<br/>    ...<br/>    adding activities:<br/>      when verb field is missing<br/>        should return an explicit error<br/>      when verb field is too long<br/>        should return an explicit error<br/>      when no pagination is specified<br/>        should return 25 activities by default<br/>        when using the id_lt pagination parameter<br/>          should have id_lt equal to the second activity from the top<br/>        when using the id_gt pagination parameter<br/>          should have id_gt equal to the second activity from the top<br/>    ...<br/><br/>Finished in 3.8849 seconds<br/>142 examples, 0 failures, 3 skipped<br/><br/>PASS</span></pre><p id="7bbc" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">这与HTML报告相结合，并与我们的CI集成，因此我们总是知道发生了什么，何时、何地以及(很少😏)为什么会失败。</p><p id="3926" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">除此之外，我们正忙于<code class="eh mb mc md me b">bdd</code>的第二个目的，即类似黄瓜的特性测试。这部分是完全自制的，没有使用银杏(虽然它确实使用了gomega matchers)，并允许我们直接在Go中编写特征文件，同时尽可能接近你可能熟悉的整洁的特征文件。</p><pre class="jj jk jl jm fq mk me ml mm aw mn dt"><span id="bdd7" class="ks kt hu me b fv mo mp l mq mr">Feature("sample feature", func() {<br/>        Scenario("login",<br/>                        Given("i am not logged in", givenNotLoggedIn()).<br/>                                And("i am on the home page", givenOnHomePage()).<br/>                                And("i am using a mobile browser", givenOnMobileBrowser()),<br/>                        When("entering my email and password", enterEmailAndPassword()),<br/>                        Then("i should be logged in",<br/>                                func() {<br/>                                        Expect(me).To(BeLoggedIn())<br/>                                }),<br/>                )<br/>})</span></pre><p id="8a88" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated"><em class="js">这仍在积极开发中:在接下来的几周内，你会听到更多的消息……</em></p><h2 id="aaf0" class="ks kt hu bd ku kv kw kx ky kz la lb lc kp ld le lf kq lg lh li kr lj lk ll lm dt translated">包扎</h2><p id="094d" class="pw-post-body-paragraph jq jr hu jt b ju ln jw jx jy lo ka kb kp lp ke kf kq lq ki kj kr lr km kn ko hn dt translated">我们相信只有伟大的测试才能产生伟大的软件:编写测试是一项引人注目的任务，而且没有通用的规则。</p><p id="9554" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">我们的工作流程是一个不断改进和调整的过程，因为随着我们编写更多的代码，我们会发现新的测试方法。</p><p id="12e2" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">由于语言的简单性，用Go编写测试通常是一种有趣的体验:标准库提供了一个简化的测试环境，活跃的Gophers社区提供了构建在其上的很好的工具。</p><p id="3584" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">然而，Go是一种年轻的语言，当涉及到高级测试技术时，它远远不能提供你在Python或Ruby等其他语言中找到的商品:有很多实验和尝试新概念的空间，这就是为什么我们投入大量精力开发我们自己的测试工具。</p><p id="2dfc" class="pw-post-body-paragraph jq jr hu jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko hn dt translated">现在你知道我们是如何处理Go测试的了，我们希望你能受到启发，写出更好的代码，也许还能调整你的编程程序。祝你好运！</p><figure class="jj jk jl jm fq iv"><div class="bz el l di"><div class="nk nl l"/></div></figure></div></div>    
</body>
</html>