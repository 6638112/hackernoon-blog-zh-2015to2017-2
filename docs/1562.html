<html>
<head>
<title>How to write Atomic (design) CSS with Sass in Angular2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Angular2中用Sass编写原子(设计)CSS</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-write-atomic-css-with-sass-in-angular2-a18a7661f7ff?source=collection_archive---------1-----------------------#2016-11-15">https://medium.com/hackernoon/how-to-write-atomic-css-with-sass-in-angular2-a18a7661f7ff?source=collection_archive---------1-----------------------#2016-11-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="f343" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">更新:我已经<a class="ae jp" href="https://hackernoon.com/tagged/meaning" rel="noopener ugc nofollow" target="_blank">打算</a>写一篇后续文章，但是还没有时间。要点是，如果你从未经历过原子阶段，那么CSS的原子<a class="ae jp" href="https://hackernoon.com/tagged/design" rel="noopener ugc nofollow" target="_blank">设计</a>可能是一个可怕的想法。如果您想要更深入的解释或澄清，请发表评论。不管是哪种情况，我都会把这篇文章留给后人。</p></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><p id="0926" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jx">这篇文章的主要目标是回顾编写原子css的所有步骤和一些陷阱。我们将使用sass和angular2。</em></p><h1 id="77c2" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">什么是原子CSS？</h1><p id="e26e" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated"><em class="jx">这在技术上不是</em><a class="ae jp" href="http://acss.io/" rel="noopener ugc nofollow" target="_blank"><em class="jx">atomic-css</em></a><em class="jx">，而是CSS写在</em><a class="ae jp" href="http://bradfrost.com/blog/post/atomic-web-design/" rel="noopener ugc nofollow" target="_blank"><em class="jx">atomic web design</em></a><em class="jx">。前者只是更容易写。</em></p><p id="9b1c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">编写CSS有许多不同的风格和设计模式，每一种都有自己的优点和缺点。今年早些时候，我有幸与之共事的最好的首席开发人员之一向我介绍了原子CSS(T21)的概念，我完全爱上了它。不幸的是，他已经不在了。他在一个更好的地方…谷歌。</p><p id="d7a7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以原子方式编写css的一个主要好处是，最终你将不必再编写任何css(无论如何这是目标)。这有点言过其实，但是这个想法是，只有非常特殊和高度定制的元素才需要新的css。</p><p id="fcb6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">原子CSS的基本概念是你有一个属于一个属性和值对的类，这些被称为原子。</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="b80d" class="lk jz hu lg b fv ll lm l ln lo">.height20 {<br/>  height: 20px;<br/>}</span></pre><p id="b943" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当你需要一个新的高度时，你只需要为它增加一个新的等级。</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="2b9c" class="lk jz hu lg b fv ll lm l ln lo">.height30 {<br/>  height: 30px;<br/>}</span></pre><p id="fbe4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">嘣。就是这样。你甚至可以更进一步，将这些类缩写为“h20”和“h30”。</p><p id="918f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有些人会反对简洁，而赞成更加语义化。这是一个相当固执己见的话题，在这里由你做出选择，但一旦做出选择，就要坚持下去！一致性是关键。</p><p id="a8eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这似乎有点太乏味了。我不想坐在这里，写出每一个我可能用到的高度。那会有几十到几百行。我成为一名开发人员是因为我很懒，让我们看看我们能做些什么。</p><h1 id="f772" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">萨斯/SCSS</h1><p id="71cf" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">用Sass自动生成这些类非常简单。</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="dacb" class="lk jz hu lg b fv ll lm l ln lo">// heights.scss</span><span id="2e49" class="lk jz hu lg b fv lp lm l ln lo">// This is our iteratable list of key/value pairs<br/>$heights: (<br/>  6: 0.375rem,<br/>  10: 0.625rem,<br/>  11: 0.688rem,<br/>  18: 1.125rem<br/>);</span><span id="a28e" class="lk jz hu lg b fv lp lm l ln lo">// We loop through our list and use the key as the name<br/>// and the value is used as the val.<br/><a class="ae jp" href="http://twitter.com/each" rel="noopener ugc nofollow" target="_blank">@each</a> $name, $val in $heights {<br/>  .h#{$name} {<br/>    height: #{$val};<br/>  }</span><span id="7873" class="lk jz hu lg b fv lp lm l ln lo">  .min-h#{$name} {<br/>    min-height: #{$val};<br/>  }<br/>}</span><span id="89c1" class="lk jz hu lg b fv lp lm l ln lo">// heights.compiled.css<br/>.h6 {<br/> height: 0.375rem;<br/>}<br/>.h10 {<br/> height: 0.625rem;<br/>}<br/>.h11 {<br/> height: 0.688rem;<br/>}<br/>.h18 {<br/> height: 1.125rem;<br/>}<br/>.min-h6 {<br/> min-height: 0.375rem;<br/>}<br/>.min-h10 {<br/> min-height: 0.625rem;<br/>}<br/>.min-h11 {<br/> min-height: 0.688rem;<br/>}<br/>.min-h18 {<br/> min-height: 1.125rem;<br/>}</span></pre><p id="fc2e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">原子CSS的一个巨大好处是它将维护从样式表转移到模板中。如果你需要改变页面上的一些间距问题，那么你可以编辑页面html，而不是css。</p><p id="e0f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最终，你将创建足够多的原子，不再需要编写任何css。</p><h1 id="72db" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">分子</h1><p id="2a1c" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">一组常用的原子叫做分子。分子实际上不是任何新的代码，它只是重复类名的模式。卡片分子可以分为以下几类:</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="3e3c" class="lk jz hu lg b fv ll lm l ln lo">&lt;div class=”width-250 height-100 font-size-16 padding-5"&gt;&lt;/div&gt;<br/>&lt;!- or if you want to be terse -&gt;<br/>&lt;div class=”w250 h100 f16 p5"&gt;&lt;/div&gt;<br/></span></pre><p id="9ac6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也就是说:</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="cdd8" class="lk jz hu lg b fv ll lm l ln lo">{<br/>  width: 250px;<br/>  height: 100px;<br/>  font-size: 16px;<br/>  padding: 5px;<br/>}<br/></span></pre><p id="976f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这乍一看似乎很冗长，可能很难习惯，但是如果您只需要一个与其他的`. card '稍微不同的`. card ',它就消除了必须为`. card '创建另一个自定义类的问题。</p><h1 id="63d1" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">角度2</h1><p id="56c1" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">如果你从来没有玩过angular2，那么这里有一些关于css的快速信息。</p><p id="5dc6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在angular2中，有一种叫做分量的东西。该应用程序从一个主/根组件开始，然后所有其他组件都是该根组件的后代。</p><figure class="lb lc ld le fq lr fe ff paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="fe ff lq"><img src="../Images/318ac9107f2f99d0dfef8bb2822e42a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mj5Q6YkSWB1tWGc07bFrwQ.png"/></div></div><figcaption class="ly lz fg fe ff ma mb bd b be z ek">Image taken from Victor Svakin’s article: <a class="ae jp" href="https://vsavkin.com/change-detection-in-angular-2-4f216b855d4c#.a9lqubahp" rel="noopener ugc nofollow" target="_blank">CHANGE DETECTION IN ANGULAR 2</a></figcaption></figure><p id="29ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每个组件都可以附加一个样式表，它将被绑定到该组件的范围。如果<em class="jx"> FiltersCmp </em>有一个css类叫做<em class="jx">。隐藏</em>那么<em class="jx"> TodosCmp </em>将不会知道那个类。所以你可能会问自己，当我们所有的css都绑定到某个组件时，我们怎么能有全局样式呢？我们希望我们的风格是全球性的，而不是绑定到一个特定的组件范围。</p><p id="29a3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有两种方法可以让我们的原子风格全球化。最简单的方法就是让angular来处理它。首先，我们将scss包含在<em class="jx"> AppCmp </em>中，然后我们将<em class="jx"> @Component() </em>装饰器的<em class="jx">封装</em>属性设置为<em class="jx">视图封装。无</em>。这会告诉angular2，我们不希望这个组件对这些样式有贪婪和占有欲。我们希望它与它的所有后代/兄弟姐妹/祖先分享它，使它本质上是全球性的。</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="e998" class="lk jz hu lg b fv ll lm l ln lo">import { Component, ViewEncapsulation } from ‘<a class="ae jp" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>’;</span><span id="5caa" class="lk jz hu lg b fv lp lm l ln lo"><a class="ae jp" href="http://twitter.com/Component" rel="noopener ugc nofollow" target="_blank">@Component</a>({<br/>  selector: ‘app’,<br/>  templateUrl: require(‘./app.component.html’),<br/>  styles: [<br/>    require(‘./app.main.scss’)<br/>  ],<br/>  encapsulation: ViewEncapsulation.None<br/>})<br/></span></pre><p id="d31f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，困难就在这里。Angular2在运行时将<em class="jx"> &lt;样式&gt; </em>标签直接注入头部。起初看起来并不坏，但是一旦你开始进入服务器端渲染和SEO优化，你就会开始意识到在你的index.html中120，000行css是一个坏主意，尽管这可能是真的也可能不是真的。我不是SEO专家。</p><p id="91a2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">幸运的是，还有另一种方法。我们可以编译我们的scss并将其提取到一个单独的main.css文件中，然后将其包含在我们的html中。</p><h1 id="26e6" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">编译和提取</h1><p id="45dc" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">有一些不同的构建工具，比如<a class="ae jp" href="http://gulpjs.com/" rel="noopener ugc nofollow" target="_blank">吞咽</a>和<a class="ae jp" href="http://gruntjs.com/" rel="noopener ugc nofollow" target="_blank">咕噜</a>。<a class="ae jp" href="https://webpack.github.io/" rel="noopener ugc nofollow" target="_blank">在我看来，Webpack </a>可能是最简单的，进入门槛相当低。为此，我将使用webpack2，但这也可以在webpack1中轻松完成。</p><p id="8907" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Webpack运行于一个<em class="jx"> webpack.config.js </em>文件。在那个配置文件中，我们告诉它寻找某些文件，在我们的例子中是scss文件，然后用一些加载器处理它们。加载器只是一个对文件进行转换或操作的花哨术语，本质上是插件，但它们是webpack生态系统中最重要的部分。</p><p id="9e79" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">创建一个<em class="jx"> app.main.scss </em>作为你的<em class="jx"> app.component.ts </em>的兄弟，然后<em class="jx"> @import </em>你所有的其他scss文件到这个文件中。确保从所有组件装饰器中移除<em class="jx">样式</em>属性。然后再加一个<em class="jx">require(’。/path/to/app.main.scss') </em>在您的<em class="jx"> client.ts </em>中，这将确保webpack检测到该scss文件，并按照我们期望的方式处理该文件。</p><p id="5ffa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jx">有一个问题是，既然你将这些其他的scss文件导入到main.app.scss中，那么其他scss文件中的相对路径必须相对于main . app . scss。</em></p><p id="b874" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">scss需要首先转换成css，所以我们将通过<a class="ae jp" href="https://github.com/jtangelder/sass-loader" rel="noopener ugc nofollow" target="_blank"> sass-loader </a>来传输它。我们将只测试/寻找我们的<em class="jx"> app.main.scss </em>文件。所有其他scss文件应该导入到<em class="jx"> app.main.scss </em>中，加载程序不需要直接知道它们。</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="652a" class="lk jz hu lg b fv ll lm l ln lo">module.exports = {<br/>  module: {<br/>    rules: [<br/>      { test: /app\.main\.scss/, loader: ‘sass-loader’ }<br/>    ]<br/>  }<br/>}<br/></span></pre><p id="89d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们的scss是css，但是在这一点上webpack仍然不知道如何处理css。我们将不得不添加一个css加载器。这个加载器还解析所有的url源，并将它们放在。/dist文件夹，如果你有合适的文件加载器或者只使用<a class="ae jp" href="https://github.com/webpack/file-loader" rel="noopener ugc nofollow" target="_blank">文件加载器</a>。</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="cc7b" class="lk jz hu lg b fv ll lm l ln lo">module.exports = {<br/>  module: {<br/>    rules: [<br/>      {<br/>        test: /app\.main\.scss/,<br/>        loaders: [<br/>          {<br/>            loader: ‘css-loader’,<br/>            options: {<br/>              importLoaders: 1<br/>            }<br/>          },<br/>          ‘sass-loader’<br/>        ]<br/>      }<br/>    ]<br/>  }<br/>}</span></pre><p id="6de6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">既然这样，让我们也添加<a class="ae jp" href="https://github.com/postcss/postcss" rel="noopener ugc nofollow" target="_blank"> postcss </a>吧，因为我们想在css中添加浏览器特有的前缀。</p><p id="b6ba" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">将该文件放在项目的根目录下。它所做的就是告诉postcss我们想要使用一个autoprefixer，并且我们的目标是浏览器的最后6个版本。它会自动将`-moz-`、`-webkit-`和`-ms-`前缀应用到需要的地方。</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="bb3d" class="lk jz hu lg b fv ll lm l ln lo">// postcss.config.js<br/>const autoprefixer = require(‘autoprefixer’);</span><span id="91f3" class="lk jz hu lg b fv lp lm l ln lo">module.exports = {<br/>  plugins: [<br/>    autoprefixer({<br/>      browsers: [‘last 6 versions’]<br/>    })<br/>  ]<br/>}</span></pre><p id="6380" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在当前设置下，webpack将处理我们所有的SCS，并将其转换成一个css字符串。但是这个字符串对我们没有用，除非它在一个文件里。我们需要做的最后一件事是将编译后的css提取到我们的。/dist文件夹作为它自己的文件。</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="0082" class="lk jz hu lg b fv ll lm l ln lo">const ExtractTextPlugin = require(“extract-text-webpack-plugin”);</span><span id="0d57" class="lk jz hu lg b fv lp lm l ln lo">module.exports = {<br/>  module: {<br/>    rules: [<br/>      {<br/>        test: /app\.main\.scss/,<br/>        loaders: [<br/>          ExtractTextPlugin.extract({<br/>            loader: ‘exports-loader?module.exports.toString()’<br/>          }),<br/>          {<br/>            loader: ‘css-loader’,<br/>            options: {<br/>              importLoaders: 2<br/>            }<br/>          },<br/>          ‘postcss-loader’,<br/>          ‘sass-loader’<br/>        ]<br/>      }<br/>    ]<br/>  },<br/>  plugins: [<br/>    new ExtractTextPlugin({<br/>      filename: ‘assets/css/main.css’,<br/>      allChunks: true<br/>    })<br/>  ],<br/>  output: {<br/>    path: ‘./dist/client’,<br/>    filename: ‘assets/[ext]/[name].[ext]’<br/>  }<br/>}<br/></span></pre><p id="a8a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在你知道了。(几乎)完整的webpack.config，用于从原子scss文件中提取完全编译的css。当然，需要加载器来传输angular2类型脚本源文件，但这超出了本文的范围。</p><div class="lb lc ld le fq ab cb"><figure class="mc lr md me mf mg mh paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mc lr md me mf mg mh paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mc lr md me mf mg mh paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mi mj mk"><p id="f922" class="ir is jx it b iu iv iw ix iy iz ja jb ml jd je jf mm jh ji jj mn jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is jx it b iu iv iw ix iy iz ja jb ml jd je jf mm jh ji jj mn jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lb lc ld le fq lr fe ff paragraph-image"><a href="https://goo.gl/Ahtev1"><div class="fe ff mo"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></a></figure><figure class="lb lc ld le fq lr"><div class="bz el l di"><div class="mp mq l"/></div></figure></div></div>    
</body>
</html>