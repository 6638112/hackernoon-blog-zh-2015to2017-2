<html>
<head>
<title>Adding OAuth2 to Mobile Android and iOS Clients Using the AppAuth SDK</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用AppAuth SDK将OAuth2添加到移动Android和iOS客户端</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/adding-oauth2-to-mobile-android-and-ios-clients-using-the-appauth-sdk-f8562f90ecff?source=collection_archive---------1-----------------------#2017-10-24">https://medium.com/hackernoon/adding-oauth2-to-mobile-android-and-ios-clients-using-the-appauth-sdk-f8562f90ecff?source=collection_archive---------1-----------------------#2017-10-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/1e7482e590eb1f9e6011734d492e825f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XZaJAqvHlCcST9RrljJiCw.png"/></div></div></figure><p id="6c18" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通常与<a class="ae ka" href="http://openid.net/connect/" rel="noopener ugc nofollow" target="_blank"> OpenID-Connect </a>结合使用的OAuth2 是一个流行的授权框架，它使应用程序能够保护资源免受未授权的访问。它将用户身份验证委托给授权服务，然后授权第三方应用程序代表用户访问受保护的资源。OAuth 2为web和移动应用程序都提供了授权流。</p><p id="aa44" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://appauth.io/" rel="noopener ugc nofollow" target="_blank"> AppAuth </a>是一款面向原生Android和iOS应用的开源SDK，它以平台友好的方式实现了最佳实践OAuth2和OpenID-Connect规范。</p><p id="ac33" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个在Android中实现的示例应用程序提供了一个使用AppAuth授权访问私有资源的具体示例。图书应用程序使用Google Books API和<em class="kb"> Google </em>登录服务来搜索图书(受API key保护)，并显示登录用户最喜欢的图书选择(受OAuth2保护)。开源项目可在github.com/approov<a class="ae ka" href="https://github.com/approov/AppAuth-OAuth2-Books-Demo" rel="noopener ugc nofollow" target="_blank">获得。</a></p><h1 id="9e37" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">OAuth2授权授予流程</h1><p id="16bc" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">在OAuth2授权流中，资源授权与资源访问是分开的。只有授权服务器需要处理用户凭证，因此这些用户凭证永远不会向客户端或资源服务器公开。</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lf"><img src="../Images/e3460031c555c3b265ab8fe955974f47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ca4i-SixD-rEfr4vNkvVWg.png"/></div></div></figure><p id="fdd2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当客户端通过重定向将称为资源所有者的用户发送到授权服务器的网站时，授权开始。本地用户代理(通常是浏览器)获取并提交用户的凭证，并要求用户授予权限。授权服务器验证凭证，并通过用户代理将访问令牌重定向回客户端。</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div class="fe ff lk"><img src="../Images/ec6f9cf5f28522eb7d1f7d483cb1b7f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*LLl2_Yp7TASOswXFS6YKog.png"/></div></figure><p id="cc03" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在授权码授予流程中，授权分为两个步骤。在第一步中，如果授权服务器对用户凭证进行了身份验证，则向客户端返回一个授权代码。客户端使用授权代码和某种形式的客户端身份验证(通常是客户端机密)回调授权服务器。如果客户端通过了身份验证，授权服务器将直接向客户端返回访问令牌和可选的刷新令牌。通过将授权过程分为两个步骤，访问令牌不会流经用户代理。</p><p id="7f18" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从客户端传递到资源服务器的访问令牌可以由资源服务器使用用于签名它们的相同秘密来验证。授权服务器和资源服务器共享这个秘密，但是这个秘密永远不会暴露给客户机或用户代理。访问令牌具有有限的生存期，因此刷新令牌可用于请求新的访问令牌。</p><p id="3a8a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要更深入一点，请参见<a class="ae ka" href="https://hackernoon.com/mobile-api-security-techniques-fc1f577840ab" rel="noopener ugc nofollow" target="_blank">移动API安全技术，第2部分:API令牌、Oauth2和消失的秘密</a></p><h1 id="8188" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">移动客户端与Web客户端</h1><p id="b9a2" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">授权码授权流对于web和移动客户端是常见的。在代码交换步骤中，web和移动流程之间的差异经常会显现出来。</p><p id="4b4f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在授权服务器将代码交换为访问令牌之前，授权服务器必须确保客户端就是它所声称的那个人，这一点很重要。这通常是为使用HTTP基本身份验证的web客户端完成的，客户端ID和机密保存在应用服务器上。</p><p id="001c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在移动客户端上，相同的客户端机密将静态保存在本机应用程序中。静态客户端机密通常很容易从您的应用程序中提取，这使得其他人可以假冒您的应用程序并窃取用户数据。不幸的是，在移动客户端上，仅使用公开可用的客户端ID将授权码交换为访问令牌是很常见的。使用容易窃取的秘密进行认证和不使用秘密进行认证哪个更好？</p><p id="f180" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">授权码通过用户代理重定向返回给移动客户端。最初向授权服务注册移动应用程序时，开发人员可能会限制授权服务将接受的重定向URL。这有助于防止恶意参与者将授权代码重定向到不相关的URL地址。</p><p id="007a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于在代码交换期间不需要秘密，任何能够截获授权代码的人都可以用代码交换访问令牌。<a class="ae ka" href="https://tools.ietf.org/html/rfc7636" rel="noopener ugc nofollow" target="_blank">用于代码交换的证明密钥</a> (PKCE)已经被许多OAuth2提供商采用。使用普通PKCE，客户端应用程序通过对授权服务器的初始用户代理调用生成一个随机状态值。服务器保存该值。当客户端应用程序执行代码交换时，它会将原始状态值与代码一起发送，除非两个状态值匹配，否则授权服务器不会将代码交换为访问令牌。恶意参与者现在必须观察初始状态值和访问代码来获取令牌。</p><p id="30c1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在一种更强形式的PKCE中，客户端应用程序在发出授权请求时发送随机状态值的散列。在代码交换期间，它将原始状态值与代码一起发送。授权服务器将这个值的散列与它收到的原始散列进行比较。现在，观察最初的授权请求已经不够好了；黑客必须截取并修改初始散列。如果成功，客户端应用程序将无法再交换令牌，但攻击者可以。</p><p id="c13c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">PKCE是一个很好的步骤，但是使用不通过用户代理的客户端秘密将是一个更安全的方法，如果它在移动设备上静态存储时不那么容易受到攻击的话。</p><h1 id="198f" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">AppAuth</h1><p id="ea78" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">用于Android和iOS的AppAuth是一个客户端SDK，它与<a class="ae ka" href="https://tools.ietf.org/html/rfc6749" rel="noopener ugc nofollow" target="_blank"> OAuth2 </a>和<a class="ae ka" href="http://openid.net/specs/openid-connect-core-1_0.html" rel="noopener ugc nofollow" target="_blank"> OpenID Connect </a> (OIDC)提供商一起工作。它将原始协议流包装到每个本机平台熟悉的实现风格中。</p><p id="4985" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该SDK遵循用于本地应用的OAuth 2.0的最佳实践，包括PKCE扩展和定制标签浏览器。该库提供了钩子来进一步扩展基本流之外的协议。</p><p id="227c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作为一个开源项目，<a class="ae ka" href="https://appauth.io/" rel="noopener ugc nofollow" target="_blank"> AppAuth </a>拥有针对<a class="ae ka" href="https://github.com/openid/AppAuth-Android" rel="noopener ugc nofollow" target="_blank"> Android </a>和<a class="ae ka" href="https://github.com/openid/AppAuth-iOS" rel="noopener ugc nofollow" target="_blank"> iOS </a>的GitHub库，其中包括良好的文档、一个演示应用，以及与多种授权服务的集成。</p><h1 id="a7db" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">入门指南</h1><p id="8bf1" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">在Android上开发了一个搜索和查找喜欢的书籍的应用程序，以进一步探索AppAuth SDK与通用应用程序架构和支持库的使用。</p><p id="ac95" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，从克隆GitHub上的图书演示项目开始，该项目可在<a class="ae ka" href="https://github.com/approov/AppAuth-OAuth2-Books-Demo" rel="noopener ugc nofollow" target="_blank">github.com/approov</a>获得。它需要一些配置，所以它不会开箱即用。至少，您需要提供一个keystore、Google API密匙和Google OAuth2凭证，我们接下来将生成这些凭证。</p><h1 id="7e21" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">Google OAuth2和API注册</h1><p id="cb58" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">您将使用<a class="ae ka" href="https://developers.google.com/books/docs/v1/using" rel="noopener ugc nofollow" target="_blank"> Google的Books API </a>来演示如何使用AppAuth SDK在Android上执行开放和授权的搜索。这需要一个API键来访问API的公共部分，比如开卷搜索。需要OAuth2访问令牌来访问API的私有部分，比如查找您最喜欢的书籍。</p><p id="3a4d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了注册Android的API密钥和OAuth2凭证，Google需要一个公钥SHA1指纹，它通常是签名您的Android应用程序包的公钥的指纹。对于这个演示，我们将创建一个新的秘密密钥库，并将相同的密钥材料用于API密钥、OAuth2凭证和应用程序的签名配置。</p><p id="bd12" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在终端中，使用Java keytool生成一个“秘密”密钥库，并提取指纹。为了方便起见，您可以对所有参数使用“secret”。</p><pre class="lg lh li lj fq ll lm ln lo aw lp dt"><span id="3a12" class="lq kd hu lm b fv lr ls l lt lu">$ keytool -genkey -keystore secret.keystore -alias secret <br/>    -keyalg RSA -keysize 2048 -validity 10000 -keypass secret <br/>    -storepass secret -dname 'CN=secret'</span><span id="8252" class="lq kd hu lm b fv lv ls l lt lu">$ keytool -list -v -keystore secret.keystore -storepass secret | <br/>    grep SHA1</span><span id="4b86" class="lq kd hu lm b fv lv ls l lt lu">SHA1:<br/>C5:A9:B1:F8:A3:8D:07:B3:30:D2:12:06:D2:BA:1E:CF:91:FA:60:97</span></pre><p id="c0e3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">确保secret.keystore位于项目的顶层目录中。</p><p id="62b0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来进入<a class="ae ka" href="https://console.developers.google.com" rel="noopener ugc nofollow" target="_blank">谷歌开发者控制台</a>并登录。选择或创建新项目。</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div class="fe ff lw"><img src="../Images/656ed5fedb2974b67493466577b4d872.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*-17huXKWt0lMbPGX-W_6yA.png"/></div></figure><p id="ad34" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此屏幕截图中的项目显示为“验证演示”。使用秘密指纹创建API密钥:</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lx"><img src="../Images/1200e4917714f23ad865bd13bc40a0eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2vCZ_pKVi_wE1mTCriAx_g.png"/></div></div></figure><p id="0b68" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">仍然在开发人员控制台中，创建一个OAuth2客户端ID:</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ly"><img src="../Images/371510d75c2f36ff7112c80e43d5df88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q1eJYvqHEcD_UVHYxGxc7w.png"/></div></div></figure><p id="688a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">完成OAuth2同意屏幕:</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div class="fe ff lw"><img src="../Images/b2ee8e69ba95bf782aa03cb4a440a11d.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*u7Q0FfmkhY1K3wWz_kKnAQ.png"/></div></figure><p id="1b83" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，进入<a class="ae ka" href="https://console.developers.google.com/apis/library" rel="noopener ugc nofollow" target="_blank">谷歌API库</a>页面，找到并启用谷歌图书API。</p><p id="5fe1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在项目的顶层目录中，创建一个secret.gradle文件，该文件将保存您的配置信息:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="a5a7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">gradle build会在构建应用程序时将这些配置信息插入到应用程序中。git将忽略secret.keystore和secret.gradle，因此这两个文件都不会保存在您的存储库中。</p><p id="00bd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，您应该能够成功构建并试用图书应用程序了。接下来的几节将描述如何在应用程序中使用AppAuth来验证用户身份，并进行需要访问令牌的私有Google API调用。之后，在Books应用程序中演示公共、登录和私有用例。</p><h1 id="e8ba" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">应用架构</h1><p id="d978" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">图书演示应用程序使用简单的<a class="ae ka" rel="noopener" href="/upday-devs/android-architecture-patterns-part-3-model-view-viewmodel-e7eeee76b73b"> MVVM架构</a>，有两个活动用于搜索图书和查找收藏夹。收藏夹活动仅在通过Google OAuth2登录服务登录时启用。</p><p id="eb04" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">AppAuth Android repository的演示应用展示了许多AppAuth特性，但它在活动中混合了UI、AppAuth和网络调用。Books应用程序将AppAuth服务分离到一个独立的模型层中，并将授权服务与常见的库(如<a class="ae ka" href="http://square.github.io/retrofit/" rel="noopener ugc nofollow" target="_blank"> Retrofit2 </a>)集成在一起。</p><p id="0526" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在AuthRepo类中，完整的OAuth2授权代码授权流被分成单独的步骤。长时间运行的功能是通过主UI线程上的<a class="ae ka" href="https://developer.android.com/reference/android/os/AsyncTask.html" rel="noopener ugc nofollow" target="_blank">异步任务</a>实现的。以下部分重点介绍了主要步骤。有关更多详细信息，请参考应用程序代码和AppAuth库。</p><h1 id="28f7" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">配置发现</h1><p id="4eed" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">该流程从授权服务和客户端配置开始。OIDC增加了一个<a class="ae ka" href="https://openid.net/specs/openid-connect-discovery-1_0.html" rel="noopener ugc nofollow" target="_blank">服务发现</a> y功能，它查找并配置服务API端点和其他功能。如果在secret.gradle文件中指定了发现端点，则首先尝试发现。如果没有发现配置，则使用secret.gradle中直接指定的附加端点来配置服务。</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="72c8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">客户端使用secret.gradle中指定的值进行配置:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lz ma l"/></div></figure><h1 id="2193" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">授权码授予</h1><p id="cf04" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">图书应用程序使用自定义标签浏览器作为用户代理，独立于应用程序本身。AppAuth生成一个定制的制表符意图，该意图被传递给搜索活动，然后搜索活动启动浏览器。PKCE在流中得到透明的支持。</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="bffd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">浏览器启动并要求用户提供授权凭证并授予权限。</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div class="fe ff mb"><img src="../Images/194cb0ea09505c2399c9fd97d2e1786c.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*Xiou5COoQSTf3RLOByyvDg.png"/></div></figure><p id="79c4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">浏览器将授权服务器的响应重定向回通知授权报告继续的活动:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lz ma l"/></div></figure><h1 id="b5e3" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">代码交换</h1><p id="da60" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">如果重定向成功，授权报告将尝试用代码交换初始访问和刷新令牌。</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lz ma l"/></div></figure><h1 id="d05f" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">开放和授权的API调用</h1><p id="1da2" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">如果授权成功，应用程序可以使用访问令牌访问受保护的API。auth repo提供了<a class="ae ka" href="https://github.com/square/okhttp/wiki/Interceptors" rel="noopener ugc nofollow" target="_blank"> OKHTTP拦截器</a>来用适当的密钥和访问令牌包装API调用。</p><p id="0060" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">API键拦截器用于开放式API调用。拦截器根据需要向每个API调用添加API密钥、Android包证书和包名称。</p><p id="d3ad" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">访问令牌拦截器用承载访问令牌包装所有受保护的API调用。在每次调用之前，如有必要，将检查并刷新令牌。</p><p id="8136" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在成功的代码交换之后，立即使用访问令牌拦截器从Google sign in收集用户配置文件信息。</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lz ma l"/></div></figure><h1 id="0844" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">持久身份验证状态</h1><p id="484d" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">AppAuth演示应用程序提供了一个身份验证状态管理器，它经常将身份验证状态保存到共享首选项中。这种状态在应用程序重启后仍然存在，因此应用程序的用户身份验证可以在应用程序会话之间持续存在。</p><p id="5895" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每次启动时，Books应用程序不会保持这种状态来演示新的配置发现和登录。持久性是生产中的必备特性，AppAuth类为健壮的持久性机制提供了一个坚实的起点。</p><h1 id="d5d9" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">查找收藏夹</h1><p id="febe" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">你的谷歌图书库中可能没有任何你喜欢的书籍。在网络浏览器中，登录你的谷歌账户，进入<a class="ae ka" href="https://books.google.com" rel="noopener ugc nofollow" target="_blank">books.google.com</a>，点击我的图书馆链接。向下浏览到收藏夹书架，通过选择右上角的设置按钮并选择高级图书搜索来添加一些图书。在搜索结果中，单击一本书，并在下一个屏幕中将其添加到收藏夹。</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mc"><img src="../Images/4180d104b000c6edccc5f9facb426614.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rHpNVeN8MaPXrdCaMrJzJw.png"/></div></div></figure><p id="51c5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">严格地说，对收藏夹书架的读取权限是公开的，这意味着您只能通过API键来访问它。然而，有一个问题:您必须首先知道您的Google Books用户ID，它不同于您常用的Google个人资料ID。要找到您的图书ID，您必须在API中查询您的书架列表。这是一个经过身份验证的请求，Google API从您的访问令牌中识别您的图书用户ID。您可以从一个成功的bookshells响应中解析出用户ID，最后您可以使用您的访问令牌、API键或两者来查询您的Favorites bookshelf。</p><h1 id="88f4" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">图书应用程序(Android)</h1><p id="b8c9" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">下面是几个运行中的Books应用程序的屏幕截图。该应用程序在没有登录和打开图书搜索对话框的情况下启动。打开的图书搜索只使用API键，不需要OAuth授权。</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div class="fe ff mb"><img src="../Images/90ee471ff1f29ae45b14123708ad3fc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*5Ti3sNJZ7_dc7FH5CAPihg.png"/></div></figure><p id="9ec1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下一个屏幕显示了一些搜索结果。请注意，收藏夹未启用，因为没有用户登录。</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div class="fe ff mb"><img src="../Images/2f22f28ea58ecf0b6a3074f0f735c8a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*Td40XXDT4EtZ1Icb6-TpcQ.png"/></div></figure><p id="b25c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">选择登录菜单项启动登录过程，启动自定义选项卡浏览器。</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div class="fe ff mb"><img src="../Images/a95c00ee42414c7ced7c223c6159e0ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*RH8HjgRYMP4EYBcKOfYIwA.png"/></div></figure><p id="602c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">输入您的凭据后，下一个屏幕会要求您接受权限。</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div class="fe ff mb"><img src="../Images/194cb0ea09505c2399c9fd97d2e1786c.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*Xiou5COoQSTf3RLOByyvDg.png"/></div></figure><p id="9a78" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">授权成功后，用户图标会显示在顶部栏上。您现在可以找到授权用户的收藏夹。</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div class="fe ff mb"><img src="../Images/60e0414bfb8919641015ec68af917c24.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*vHzVJG_3TPayiaY2iKN9YA.png"/></div></figure><h1 id="4350" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">限制</h1><p id="6384" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">虽然这是一个相当有限的演示，但是演示了大多数登录和用例，包括服务发现、独立用户代理授权、API密钥和访问令牌API调用。模型和视图的分离有望使AppAuth流相对容易理解。</p><p id="cf80" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如所演示的，基本的移动流在代码交换期间使用静态客户端ID，但不使用客户端机密。虽然使用了PKCE，但是登录安全性不如最好的web客户端实现那样健壮，在web客户端实现中，客户端ID和密码是从应用服务器内部使用的。</p><p id="bee7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">后续文章将探讨OAuth2的动态注册功能，该功能不会在应用程序上静态存储客户端机密，但在应用程序注册期间提供有限的安全性。这可以与动态客户端认证服务相结合，以在移动设备上实现安全和完整的OAUTH2/OIDC授权码授权流。</p></div><div class="ab cl md me hc mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hn ho hp hq hr"><p id="9012" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">感谢阅读！有关移动API安全性的更多信息，请查看。</p><p id="cc4b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你推荐这篇文章(点击👏按钮)以便其他人可以找到它。</p></div></div>    
</body>
</html>