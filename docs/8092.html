<html>
<head>
<title>The XHR History Lesson You Never Wanted</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你不想要的XHR历史课</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-xhr-history-lesson-you-never-wanted-2c892678f78d?source=collection_archive---------3-----------------------#2017-11-19">https://medium.com/hackernoon/the-xhr-history-lesson-you-never-wanted-2c892678f78d?source=collection_archive---------3-----------------------#2017-11-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="b926" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尽管JavaScript本质上是一种单线程语言，但它最大的优势之一是能够发出异步请求——AJAX。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff jp"><img src="../Images/f7cda5b0309d7719ae5c43d8f0901e5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*2FhmzRzDl5-UUmVRrd90tA.gif"/></div><figcaption class="jx jy fg fe ff jz ka bd b be z ek">The Greek hero <strong class="bd kb">Ajax</strong> was good friends with <strong class="bd kb">Achilles</strong> during the Trojan War until <strong class="bd kb">Odysseus</strong> made a request for Achilles’ armor</figcaption></figure><p id="3a23" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以Instagram或Pinterest这样的应用为例。为什么我可以不停地滚动页面，而不需要重新加载页面，并且继续显示内容呢？幕后发生的事情是，这个对服务器的异步请求最终不会打扰用户？大约在2005年(【AJAX一词被创造出来)，这是一场相当具有革命性的变革。从那以后，新技术建立在旧技术的基础上，以创造更有用、更快的网络。</p><h1 id="ca2f" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">但是我们是怎么到达那里的呢？进入XHR</h1><p id="0b9a" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">在Chrome或其他浏览器上，如果你要查看任何一个页面，你可以直接进入“网络”标签，然后注意到一个名为“XHR”的子标签。在这个选项卡中，您可以看到请求的状态、请求需要多长时间等等。事实上，当你在如上所述的页面(<a class="ae kc" href="http://instagram.com" rel="noopener ugc nofollow" target="_blank"> Instagram </a>或<a class="ae kc" href="http://pinterest.com" rel="noopener ugc nofollow" target="_blank"> Pinterest </a>)上使用这个选项卡时，它会变得更加有趣，因为你可以看到AJAX在工作，每次页面点击底部并向服务器发送另一个请求。</p><p id="cd9a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是这一切是怎么开始的呢？</p><p id="50dc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">XHR是XMLHTTP请求的简称。虽然是由微软的Outlook Web Access开发的，但这种请求的一些最早实例是在你的Gmail收件箱中使用的。不用刷新页面就能看到收件箱的更新，这是一个革命性的变化。它的工作方式是每隔20-30秒，发送一个新的请求来查看你是否有新邮件。</p><p id="3bc5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你到底该怎么写这个请求:</p><pre class="jq jr js jt fq lg lh li lj aw lk dt"><span id="ba65" class="ll ke hu lh b fv lm ln l lo lp">var XHR = new XMLHttpRequest();</span><span id="d457" class="ll ke hu lh b fv lq ln l lo lp">XHR.onreadystatechange = function() {<br/>  if(XHR.readyState == 4) {<br/>    if(XHR.status == 200) {<br/>      console.log(XHR.responseText);<br/>    } else {<br/>      console.log("Error!");<br/>    }<br/>  }<br/>}</span><span id="4e70" class="ll ke hu lh b fv lq ln l lo lp">XHR.open("GET", "url");<br/>XHR.send();</span></pre><p id="17f0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上面的代码很难理解，但是请记住，这是在更新、更快的方法建立在请求之上之前。</p><p id="4d03" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个请求的有趣之处在于，虽然XML是用全大写字母写的，但HTTP不是——可能只是为了让您迷惑。这段代码的另一个不熟悉的部分是第3行:readyState是什么，为什么它应该等于4？就绪状态是一个属性，给它加标签4是一种发信号通知<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/readyState" rel="noopener ugc nofollow" target="_blank">获取操作完成</a>的方式。</p><h1 id="5484" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">取得</h1><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff lr"><img src="../Images/9f5581ce8b0074f02efdafe88096bdcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/1*WXUzjhJU7YdZNIt-QNEzxA.gif"/></div></figure><p id="b086" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">提出请求可以有很多种方式。这是计算机相互交流的标准方式。因此，最终构建上面的庞大代码是正确的。<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank">获取</a>数据是以一种更加简洁的方式完成的(见下文),使用的承诺可以被链接起来，变得更加复杂。</p><pre class="jq jr js jt fq lg lh li lj aw lk dt"><span id="d21f" class="ll ke hu lh b fv lm ln l lo lp">fetch(url)<br/>  .then(function(res){<br/>    console.log(res);<br/>  })<br/>  .catch(function(error){<br/>    console.log(error);<br/>  });<br/>});</span></pre><p id="bf7f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Fetch请求的酷之处在于，它提供了可以包含的选项，这些选项在XHR主持节目时是不可能的。观察下面，相同的获取请求，只是现在增加了一个包含POST请求的对象，与我们目前看到的默认GET相反。</p><pre class="jq jr js jt fq lg lh li lj aw lk dt"><span id="d8a6" class="ll ke hu lh b fv lm ln l lo lp">fetch(url, {<br/>      method: 'POST',<br/>      body: JSON.stringify({<br/>         username: 'Ajax_Hero_123',<br/>         password: 'iwantarmor',<br/>    })<br/>  })<br/>  .then(function(res){<br/>    console.log(res);<br/>  })<br/>  .catch(function(error){<br/>    console.log(error);<br/>  });<br/>});</span></pre><p id="7045" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Fetch最大的缺点是浏览器兼容性，尤其是与Internet Explorer的兼容性。但主要的收获是，它使XHR更平滑、更简洁，并允许更多的选择。像网络的许多其他部分一样，这是一个完美的例子，说明这些技术不是在真空中产生的，而是相互结合的。这就把我们带到了旅程的下一部分。</p><h1 id="a47b" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">美元符号和其他第三方</h1><p id="e155" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">如果你听说过JavaScript，那么很有可能你遇到过<a class="ae kc" href="https://jquery.com/" rel="noopener ugc nofollow" target="_blank"> jQuery </a>，这是有史以来最流行的第三方库。虽然用普通的JavaScript可以做任何事情，但是jQuery创建<a class="ae kc" href="http://youmightnotneedjquery.com/" rel="noopener ugc nofollow" target="_blank">更简洁代码的能力是巨大的</a>，尤其是在发出AJAX请求时。</p><p id="c3a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还记得最上面的那一大块代码吗？在那里，我们做了一个包含多行代码的XML HTTP请求，一个检查我们处于什么readyState的if语句，一个确保我们获得200状态的if语句，对我们接收到的JSON数据的解析，以及一个最终确保代码做它应该做的事情的点send。</p><p id="7680" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是用jQuery完成的相同代码:</p><pre class="jq jr js jt fq lg lh li lj aw lk dt"><span id="9a36" class="ll ke hu lh b fv lm ln l lo lp">$.getJSON('/my/url', function(data) {</span><span id="7e35" class="ll ke hu lh b fv lq ln l lo lp">});</span></pre><p id="1a46" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我认为这是一个进步。</p><p id="7245" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您不熟悉jQuery，也请注意，任何美元符号的实例都可以替换jQuery这个词。我的印象是，时间就是金钱，从编写大量代码中节省下来的时间会让你在其他方面浪费时间，因此有了美元符号。</p><p id="05cf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">jQuery是一个非常棒的库，原因有很多，包括发出AJAX请求。它创建于2006年，并从此腾飞。但是，如果您只想对这些请求使用jQuery，而不想做其他事情，该怎么办呢？为此，有其他第三方库，如<a class="ae kc" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> Axios </a>，其主要焦点是发出请求，而不是其他。所以，如果你不需要jQuery来制作淡入动画，你的代码会感谢你使用了更轻量级的东西。</p><p id="1d2a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是Axios在实践中的样子:</p><pre class="jq jr js jt fq lg lh li lj aw lk dt"><span id="fb9e" class="ll ke hu lh b fv lm ln l lo lp">axios.get(url)<br/>.then(function(res){<br/>  console.log(res.data);<br/>})<br/>.catch(function(error){<br/>  console.log(error);<br/>})</span></pre><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff ls"><img src="../Images/49587ab36210d2fcca5de75a202801a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t9sLWFfT9qVP382GoPvs5Q.png"/></div></div><figcaption class="jx jy fg fe ff jz ka bd b be z ek">Ajax’s untimely end came when he threw himself on his own sword</figcaption></figure><p id="3734" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Axios的特点是能够从Node.js发出HTTP请求。它还自动解析JSON数据，因此不需要在promise中包含一行额外的代码。</p><p id="97d4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">总结一下，看到网络在十年多一点的时间里走了多远真是令人惊讶。这四种发出请求的方式都只是XML HTTP请求，正如您可以在开发人员工具中看到的那样，但是具有更多的功能(比如流，这是2005年最初的XHR中所没有的)，并且只会随着更酷的库而变得更好。</p><p id="70a6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">📚<em class="lx">感谢阅读，如果你喜欢这篇文章，请关注我</em>📚</p></div></div>    
</body>
</html>