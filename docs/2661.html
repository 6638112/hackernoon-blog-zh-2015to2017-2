<html>
<head>
<title>Sazerac: Data-driven Testing for JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">saz erac:JavaScript的数据驱动测试</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/sazerac-data-driven-testing-for-javascript-e3408ac29d8c?source=collection_archive---------4-----------------------#2017-02-09">https://medium.com/hackernoon/sazerac-data-driven-testing-for-javascript-e3408ac29d8c?source=collection_archive---------4-----------------------#2017-02-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/be754c6a0b330aced4ea5f78eb402f0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ni9hKbXBf0EVJHYfIEjsmg.png"/></div></div></figure><p id="060a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我最近构建了<a class="ae ka" href="https://github.com/mikec/sazerac" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> Sazerac </strong> </a>来解决我在编写<a class="ae ka" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>测试时经常遇到的一个问题。我发现，为了创建一个全面的、可维护的、没有大量重复代码的测试套件，我最终使用了一种数据驱动的方法。在<a class="ae ka" href="http://www.rocketinsights.com" rel="noopener ugc nofollow" target="_blank"><strong class="je hv">Rocket Insights</strong></a><strong class="je hv"/>使用这种方法有助于我们交付测试代码，这些代码既有助于捕捉回归，也易于阅读和理解。</p><blockquote class="kb"><p id="492d" class="kc kd hu bd ke kf kg kh ki kj kk jz ek translated">“数据驱动”测试归结为一组给定的输入和预期的输出。</p></blockquote><p id="ec2a" class="pw-post-body-paragraph jc jd hu je b jf kl jh ji jj km jl jm jn kn jp jq jr ko jt ju jv kp jx jy jz hn dt translated">将您的应用程序代码封装到<a class="ae ka" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976"> <strong class="je hv">纯函数</strong> </a>中，将有助于促进这种输入/输出测试风格，这通常是一个值得遵循的良好实践。</p><p id="aeb1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然最新的JS栈(像<a class="ae ka" href="https://facebook.github.io/react/" rel="noopener ugc nofollow" target="_blank"><strong class="je hv">React</strong></a>+<a class="ae ka" href="http://redux.js.org/" rel="noopener ugc nofollow" target="_blank"><strong class="je hv">Redux</strong></a>)鼓励纯函数式方法，但是最广泛使用的测试框架(<a class="ae ka" href="https://jasmine.github.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> Jasmine </strong> </a>、<a class="ae ka" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> Mocha </strong> </a>和<a class="ae ka" href="https://facebook.github.io/jest/" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> Jest </strong> </a>)并没有按照这种方法设计<a class="ae ka" href="https://hackernoon.com/tagged/designed" rel="noopener ugc nofollow" target="_blank"/>。他们经常假设您将测试有副作用的代码。认为代码“刺探”，并(在一定程度上)嘲讽。这些特性是为测试不纯的函数而创建的，但是没有专门用于测试纯函数的东西。</p><p id="ddd7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我强烈感觉到需要一个以数据驱动方法为核心的测试框架。构建这个框架是一项艰巨的任务，所以我选择了一个更简单的方案。我将Sazerac设计成一个助手库，可以与Jasmine、Mocha和Jest一起工作。</p><p id="043a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我可能会考虑把Sazerac 变成一个独立的框架，但是我想先看看人们是否觉得它有用。</p><h1 id="c674" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">言归正传</h1><p id="c00a" class="pw-post-body-paragraph jc jd hu je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz hn dt translated">让我们看一些代码。</p><p id="8860" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个纯函数<code class="eh lt lu lv lw b">isPrime()</code>根据给定参数<code class="eh lt lu lv lw b">num</code>是否为质数，返回<code class="eh lt lu lv lw b">true</code>或<code class="eh lt lu lv lw b">false</code>。</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="2f0f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是给定数字<code class="eh lt lu lv lw b">1</code>、<code class="eh lt lu lv lw b">2</code>、<code class="eh lt lu lv lw b">3</code>、<code class="eh lt lu lv lw b">4</code>的<code class="eh lt lu lv lw b">isPrime()</code>、的一些测试。</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="c1d2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那要写很多代码。如果我想添加更多的测试用例，我必须做一些复制和粘贴。这感觉不太对。</p><p id="ffbe" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里是相同的测试，使用<a class="ae ka" href="https://github.com/mikec/sazerac" rel="noopener ugc nofollow" target="_blank"> Sazerac </a>。</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="357b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://github.com/mikec/sazerac" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> Sazerac </strong> </a> <strong class="je hv">将使用这些测试用例来运行与Jasmine、Mocha、Jest一起工作的</strong> <code class="eh lt lu lv lw b"><strong class="je hv">describe</strong></code> <strong class="je hv">和</strong> <code class="eh lt lu lv lw b"><strong class="je hv">it</strong></code> <strong class="je hv">函数。</strong></p><p id="71d2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">describe/it消息是基于给定的输入和预期的输出设置的，因此测试报告非常一致:</p><pre class="lx ly lz ma fq me lw mf mg aw mh dt"><span id="ab88" class="mi kr hu lw b fv mj mk l ml mm">isPrime()<br/>  when given 1<br/>    ✓ should return true<br/>  when given 2<br/>    ✓ should return true<br/>  when given 3<br/>    ✓ should return true<br/>  when given 4<br/>    ✓ should return false</span></pre><h1 id="3cbf" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">在现实世界中</h1><p id="9c57" class="pw-post-body-paragraph jc jd hu je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz hn dt translated">事情通常会更复杂。</p><p id="f48c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您的代码并不总是像<code class="eh lt lu lv lw b">isPrime()</code>函数那样简单。以这个React组件为例。</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="7917" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该组件需要一个具有3个属性的<code class="eh lt lu lv lw b">product</code>对象，<code class="eh lt lu lv lw b">title</code>、<code class="eh lt lu lv lw b">price</code>和<code class="eh lt lu lv lw b">inventory</code>。如果缺少这些属性中的任何一个，它就会在根元素处呈现一条错误消息和一个<code class="eh lt lu lv lw b">error</code>类。如果所有的道具都有值，它会呈现一个成功消息，并且没有<code class="eh lt lu lv lw b">error</code>类。</p><p id="1f23" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我要用<a class="ae ka" href="http://airbnb.io/enzyme/" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">酶</strong> </a>(测试React组件的牛逼)来帮助测试这个。在我的规范文件中，我将创建一个函数来挂载组件。</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="f29b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个函数的预期返回值比较复杂，所以之前用于<code class="eh lt lu lv lw b">isPrime()</code> <em class="md"> </em>的<code class="eh lt lu lv lw b">.expect()</code>方法在这里不能用。我就用萨泽拉克的<code class="eh lt lu lv lw b">.assert()</code><em class="md">T22的方法来代替。</em></p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="be80" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这个例子中，<code class="eh lt lu lv lw b">p</code>对象是给定<code class="eh lt lu lv lw b">{}</code>的<code class="eh lt lu lv lw b">ProductComponent()</code>的返回值。如果<code class="eh lt lu lv lw b">product</code>元素(在组件的根)有类<code class="eh lt lu lv lw b">error</code>，上面的测试将通过。</p><p id="0799" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">在同一个测试用例上使用额外的</strong> <code class="eh lt lu lv lw b"><strong class="je hv">.assert()</strong></code> <strong class="je hv">调用可以增加更多的期望。</strong></p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="9b22" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每个<code class="eh lt lu lv lw b">.assert()</code>调用使用给定的输入<code class="eh lt lu lv lw b">{}</code>为<code class="eh lt lu lv lw b">ProductComponent()</code>运行一个新的测试。在本例中，运行了3个测试:</p><pre class="lx ly lz ma fq me lw mf mg aw mh dt"><span id="4332" class="mi kr hu lw b fv mj mk l ml mm">ProductComponent()<br/>  when given {}<br/>    ✓ should render `error` class<br/>    ✓ should display error message<br/>    ✓ should not display success message</span></pre><h1 id="ba9a" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">而且越来越好了</h1><p id="655e" class="pw-post-body-paragraph jc jd hu je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz hn dt translated">我们刚刚测试了“空”对象的情况，但是其他可能导致类似状态的情况呢？例如，如果<code class="eh lt lu lv lw b">title</code>、<code class="eh lt lu lv lw b">price</code>或<code class="eh lt lu lv lw b">inventory</code> <em class="md"> </em>缺失，我们会期望组件呈现相同的错误状态。</p><p id="701e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Sazerac的 <code class="eh lt lu lv lw b"><strong class="je hv">forCases()</strong></code> <strong class="je hv">方法可以让你将具有相同期望的测试用例分组。</strong></p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="d5d0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">导致以下测试:</p><pre class="lx ly lz ma fq me lw mf mg aw mh dt"><span id="903e" class="mi kr hu lw b fv mj mk l ml mm">ProductComponent()<br/>  when given {}<br/>    ✓ should render `error` class<br/>    ✓ should display error message<br/>    ✓ should not display success message<br/>  when given {"price":"1.11","inventory":"111"}<br/>    ✓ should render `error` class<br/>    ✓ should display error message<br/>    ✓ should not display success message<br/>  when given {"title":"p1","inventory":"111"}<br/>    ✓ should render `error` class<br/>    ✓ should display error message<br/>    ✓ should not display success message<br/>  when given {"title":"p1","price":"1.11"}<br/>    ✓ should render `error` class<br/>    ✓ should display error message<br/>    ✓ should not display success message</span></pre><p id="51d8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这比用<code class="eh lt lu lv lw b">describe</code>、<code class="eh lt lu lv lw b">it</code>、<code class="eh lt lu lv lw b">beforeEach</code>等编写的同等测试要简洁得多。它还使添加新案例或根据需要更新现有案例变得非常容易。</p><h1 id="602d" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">尝试一下</h1><p id="20cf" class="pw-post-body-paragraph jc jd hu je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz hn dt translated">我建议采用一些现有的测试，并对它们进行重构，以使用<a class="ae ka" href="https://github.com/mikec/sazerac" rel="noopener ugc nofollow" target="_blank"> Sazerac </a>。我希望它能降低测试的复杂性，增加可读性。</p><p id="6931" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果有反馈，在twitter上联系我<a class="ae ka" href="https://twitter.com/MikeCalvanese" rel="noopener ugc nofollow" target="_blank"> @MikeCalvanese </a></p><div class="lx ly lz ma fq ab cb"><figure class="mn iv mo mp mq mr ms paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mn iv mo mp mq mr ms paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mn iv mo mp mq mr ms paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mt mu mv"><p id="f922" class="jc jd md je b jf jg jh ji jj jk jl jm mw jo jp jq mx js jt ju my jw jx jy jz hn dt translated"><a class="ae ka" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ka" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ka" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae ka" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd md je b jf jg jh ji jj jk jl jm mw jo jp jq mx js jt ju my jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ka" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ka" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mz"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="na mc l"/></div></figure></div></div>    
</body>
</html>