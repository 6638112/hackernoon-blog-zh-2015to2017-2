<html>
<head>
<title>Docker Tutorial — Getting Started with Python, Redis, and Nginx.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker教程Python、Redis和Nginx入门。</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/docker-tutorial-getting-started-with-python-redis-and-nginx-81a9d740d091?source=collection_archive---------0-----------------------#2017-03-24">https://medium.com/hackernoon/docker-tutorial-getting-started-with-python-redis-and-nginx-81a9d740d091?source=collection_archive---------0-----------------------#2017-03-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="68ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个关于Docker容器的介绍性教程。到本文结束时，您将知道如何在您的本地机器上使用Docker。除了Python，我们还将运行Nginx和Redis容器。这些例子假设您熟悉这些技术的基本概念。将会有很多shell示例，所以继续并打开终端。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/c4418756d4b6a967f092693817b03dd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RsFzFb8-ghtARn1yP56jzg.png"/></div></div></figure></div><div class="ab cl kc kd hc ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hn ho hp hq hr"><blockquote class="kj"><p id="a738" class="kk kl hu bd km kn ko kp kq kr ks jo ek translated">注意:由于降价，代码示例可能显示不正确。我建议<a class="ae kt" href="https://djangostars.com/blog/what-is-docker-and-how-to-use-it-with-python/?utm_source=medium&amp;utm_medium=hackernoon.com&amp;utm_campaign=docker%20tutorial&amp;utm_content=continue%20reading%20on%20ds%20blog" rel="noopener ugc nofollow" target="_blank">继续阅读我们博客</a>上的原文，以确保所有的例子都能正确显示。</p></blockquote></div><div class="ab cl kc kd hc ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hn ho hp hq hr"><h1 id="0939" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">Docker是什么？</h1><p id="f519" class="pw-post-body-paragraph ir is hu it b iu ls iw ix iy lt ja jb jc lu je jf jg lv ji jj jk lw jm jn jo hn dt translated"><a class="ae kt" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> <em class="jp"> Docker </em> </strong> </a>是一款开源工具，可以在软件容器内自动部署应用。要理解Docker背后的想法，最简单的方法就是将它与标准集装箱进行比较。</p><p id="fc5e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">过去，运输公司面临以下挑战:</p><ul class=""><li id="3b89" class="lx ly hu it b iu iv iy iz jc lz jg ma jk mb jo mc md me mf dt translated">如何并排运输不同(不兼容)类型的货物(如食品和化学品，或玻璃和砖块)。</li><li id="fff5" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">如何使用同一辆车处理不同尺寸的包裹？</li></ul><p id="1d52" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">容器出现后，砖块可以放在玻璃上，化学药品可以放在食物旁边。各种尺寸的货物可以放在一个标准集装箱内，并由同一辆车装卸。</p><p id="5515" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们回到<strong class="it hv"> </strong> <a class="ae kt" href="https://djangostars.com/services/python-django-development/?utm_source=medium&amp;utm_medium=hackernoon.com&amp;utm_campaign=docker%20tutorial&amp;utm_content=software%20development" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">软件开发</strong> </a>中的容器。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><a href="https://djangostars.com/services/python-django-development/?utm_source=medium&amp;utm_medium=hackernoon.com&amp;utm_campaign=docker%20tutorial&amp;utm_content=software%20development"><div class="fe ff ml"><img src="../Images/d77f00b59d51c8af54f2b60798b7dc73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8iO6FnEiFFGyvnpJinjE5A@2x.png"/></div></a></figure><p id="e952" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当你开发一个应用程序时，你需要提供你的代码以及所有可能的依赖，比如库、web服务器、数据库等等。您可能会遇到这样的情况:应用程序在您的计算机上运行，但甚至无法在临时服务器、开发人员或QA的机器上启动。</p><p id="08fe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个挑战可以通过隔离应用程序使其独立于系统来解决。</p><h1 id="0094" class="ku kv hu bd kw kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr dt translated">这与虚拟化有何不同？</h1><p id="6e8f" class="pw-post-body-paragraph ir is hu it b iu ls iw ix iy lt ja jb jc lu je jf jg lv ji jj jk lw jm jn jo hn dt translated">传统上，虚拟机用于避免这种意外行为。VM的主要问题是在主机操作系统之上的“额外操作系统”给项目增加了千兆字节的空间。大多数时候，您的服务器会托管多个虚拟机，这些虚拟机会占用更多空间。顺便说一句，目前，大多数基于云的服务器提供商将向你收取额外空间的费用。VM的另一个显著缺点是启动缓慢。</p><p id="753d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Docker通过在作为主机操作系统的独立进程运行的所有容器之间共享操作系统内核，消除了上述所有问题。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mr"><img src="../Images/05aee8d51e0ed16d11345c8d1f83108e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xxtakmb4YQjiFWFEx4kzQw.png"/></div></div></figure><p id="64c5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请记住，Docker不是第一个也不是唯一的容器化平台。然而，目前Docker是市场上最大和最有实力的玩家。</p><h1 id="4a76" class="ku kv hu bd kw kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr dt translated">我们为什么需要Docker？</h1><p id="0acb" class="pw-post-body-paragraph ir is hu it b iu ls iw ix iy lt ja jb jc lu je jf jg lv ji jj jk lw jm jn jo hn dt translated">这些优势包括:</p><ul class=""><li id="7cdc" class="lx ly hu it b iu iv iy iz jc lz jg ma jk mb jo mc md me mf dt translated">更快的开发过程</li><li id="5a5a" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">便捷的应用程序封装</li><li id="40e9" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">本地机器/开发/暂存/生产服务器上的相同行为</li><li id="d510" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">简单明了的监控</li><li id="1bb8" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">易于扩展</li></ul><h1 id="b9c3" class="ku kv hu bd kw kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr dt translated">更快的开发过程</h1><p id="efd6" class="pw-post-body-paragraph ir is hu it b iu ls iw ix iy lt ja jb jc lu je jf jg lv ji jj jk lw jm jn jo hn dt translated">没有必要在系统上安装PostgreSQL、Redis、Elasticsearch等第三方应用——你可以在容器中运行它。Docker还让你能够同时运行同一应用程序的不同版本。例如，假设您需要手动将旧版本的Postgres数据迁移到新版本。当您想要使用第三方软件的新版本创建新的微服务时，您可能会在微服务架构中遇到这种情况。</p><p id="4c20" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在一个主机操作系统上保存同一个应用程序的两个不同版本可能非常复杂。在这种情况下，Docker容器可能是一个完美的解决方案——您可以为您的应用程序和第三方接收隔离的环境。</p><h1 id="69da" class="ku kv hu bd kw kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr dt translated">便捷的应用程序封装</h1><p id="4e11" class="pw-post-body-paragraph ir is hu it b iu ls iw ix iy lt ja jb jc lu je jf jg lv ji jj jk lw jm jn jo hn dt translated">你可以完整地递交你的申请。大多数编程语言、框架和所有操作系统都有自己的打包管理器。即使您的应用程序可以用它自己的包管理器打包，也很难为另一个系统创建一个端口。</p><p id="a3e7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Docker为您提供了一个统一的映像格式，可以将您的应用程序分布在不同的主机系统和云服务上。您可以将您的应用程序与所有需要的依赖项(包含在一个映像中)一起交付，并准备好运行。</p><h1 id="a0f6" class="ku kv hu bd kw kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr dt translated">本地机器/开发/暂存/生产服务器上的相同行为</h1><p id="2845" class="pw-post-body-paragraph ir is hu it b iu ls iw ix iy lt ja jb jc lu je jf jg lv ji jj jk lw jm jn jo hn dt translated">Docker不能保证100%的开发/试运行/生产均等，因为总是存在人为因素。但是它将由不同版本的操作系统、系统依赖性等引起的错误概率降低到几乎为零。</p><p id="b422" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过构建Docker映像的正确方法，您的应用程序将使用具有相同操作系统版本和所需依赖项的相同基础映像。</p><h1 id="b986" class="ku kv hu bd kw kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr dt translated">简单明了的监控</h1><p id="f878" class="pw-post-body-paragraph ir is hu it b iu ls iw ix iy lt ja jb jc lu je jf jg lv ji jj jk lw jm jn jo hn dt translated">开箱即用，您有一个统一的方法来读取所有运行容器中的日志文件。您不需要记住应用程序及其依赖项存储日志文件的所有特定路径，也不需要编写自定义钩子来处理这些路径。<br/>您可以集成一个<a class="ae kt" href="https://docs.docker.com/config/containers/logging/configure/#supported-logging-drivers" rel="noopener ugc nofollow" target="_blank">外部日志驱动程序，并在一个地方监控</a>您的应用程序日志文件。</p><h1 id="696c" class="ku kv hu bd kw kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr dt translated">易于扩展</h1><p id="f17a" class="pw-post-body-paragraph ir is hu it b iu ls iw ix iy lt ja jb jc lu je jf jg lv ji jj jk lw jm jn jo hn dt translated">一个正确包装的应用程序将涵盖十二个因素中的大部分<a class="ae kt" href="https://12factor.net/" rel="noopener ugc nofollow" target="_blank">。通过设计，Docker强迫你遵循它的核心原则，比如环境变量上的配置，TCP/UDP端口上的通信等等。如果你的应用程序做得好，它不仅可以在Docker中扩展。</a></p><h1 id="bf52" class="ku kv hu bd kw kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr dt translated">支持的平台</h1><p id="371a" class="pw-post-body-paragraph ir is hu it b iu ls iw ix iy lt ja jb jc lu je jf jg lv ji jj jk lw jm jn jo hn dt translated">Docker的本地平台是Linux，因为它基于Linux内核提供的特性。但是，您仍然可以在macOS和Windows上运行它。唯一不同的是，在macOS和Windows上，Docker被封装在一个微小的虚拟机中。目前，macOS和Windows的Docker已经达到了相当高的可用性水平，感觉更像是一个原生应用程序。</p><h1 id="26c3" class="ku kv hu bd kw kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr dt translated">装置</h1><p id="7d9c" class="pw-post-body-paragraph ir is hu it b iu ls iw ix iy lt ja jb jc lu je jf jg lv ji jj jk lw jm jn jo hn dt translated">你可以在这里查看Docker <a class="ae kt" href="https://docs.docker.com/install/" rel="noopener ugc nofollow" target="_blank">的安装说明</a>。<br/>如果您在Linux上运行docker，您需要以root用户身份运行以下所有命令，或者将您的用户添加到Docker组并重新登录:</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="09ba" class="mx kv hu mt b fv my mz l na nb">sudo usermod -aG docker $(whoami)`</span></pre><h1 id="6084" class="ku kv hu bd kw kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr dt translated">术语</h1><ul class=""><li id="a813" class="lx ly hu it b iu ls iy lt jc nc jg nd jk ne jo mc md me mf dt translated">容器—封装所需软件的运行实例。容器总是从图像创建的。容器可以暴露端口和卷，以便与其他容器或/和外部世界进行交互。容器可以很容易地在很短的时间内被杀死/移走和重新创建。容器不会保持状态。</li><li id="1cd6" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">图像——每个容器的基本元素。当您创建一个映像时，每一步都被缓存并可以重用(<a class="ae kt" href="https://en.wikipedia.org/wiki/Copy-on-write" rel="noopener ugc nofollow" target="_blank">写模式下复制</a>)。根据映像的不同，可能需要一些时间来构建。另一方面，容器可以马上从图像开始。</li><li id="33e8" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">端口——TCP/UDP端口的原始含义。为了简单起见，让我们假设端口可以暴露给外部世界(可以从主机操作系统访问)或连接到其他容器，即只能从这些容器访问，而对外部世界不可见。</li><li id="d304" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">卷—可以描述为共享文件夹。创建容器时会初始化卷。卷旨在保存数据，与容器的生命周期无关。注册表—存储Docker图像的服务器。它可以与Github相比较——您可以从注册表中取出一个映像，将其部署到本地，并将本地构建的映像推送到注册表中。</li><li id="beb7" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated"><a class="ae kt" href="https://hub.docker.com/explore/" rel="noopener ugc nofollow" target="_blank">Docker Hub</a>—Docker Inc .提供的一个具有web界面的注册表，它存储了大量使用不同软件的Docker映像。Docker Hub是Docker团队或与原始软件制造商合作制作的“官方”Docker映像的来源(不一定意味着这些“原始”映像来自官方软件制造商)。官方图片列出了它们的潜在漏洞。任何登录的用户都可以获得此信息。有免费和付费账户。每个账户可以有一张私人图片，也可以有无限数量的免费公共图片。还有一个<a class="ae kt" href="https://store.docker.com/search?type=image&amp;source=verified" rel="noopener ugc nofollow" target="_blank"> Docker商店</a>——一个非常类似于Docker Hub的服务。这是一个有评级、评论等的市场。我个人的看法是，这是营销的东西。我对Docker Hub非常满意。</li></ul><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff nf"><img src="../Images/732cae3da184e7737c0c3fb2c75799e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Z9uWDmkYA7cRhALk.png"/></div></div></figure><h1 id="dc77" class="ku kv hu bd kw kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr dt translated">示例1: hello world</h1><p id="ba13" class="pw-post-body-paragraph ir is hu it b iu ls iw ix iy lt ja jb jc lu je jf jg lv ji jj jk lw jm jn jo hn dt translated">是时候运行您的第一个容器了:</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="f40c" class="mx kv hu mt b fv my mz l na nb">docker run ubuntu /bin/echo 'Hello world'</span></pre><p id="4398" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">控制台输出:</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="52d0" class="mx kv hu mt b fv my mz l na nb">Unable to find image 'ubuntu:latest' locally  <br/>latest: Pulling from library/ubuntu  <br/>6b98dfc16071: Pull complete  <br/>4001a1209541: Pull complete  <br/>6319fc68c576: Pull complete  <br/>b24603670dc3: Pull complete  <br/>97f170c87c6f: Pull complete  <br/>Digest:sha256:5f4bdc3467537cbbe563e80db2c3ec95d548a9145d64453b06939c4592d67b6d  <br/>Status: Downloaded newer image for ubuntu:latest  <br/>Hello world</span></pre><ul class=""><li id="0c85" class="lx ly hu it b iu iv iy iz jc lz jg ma jk mb jo mc md me mf dt translated">docker run是运行容器的命令。</li><li id="bdbb" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">ubuntu是你运行的镜像。比如Ubuntu操作系统镜像。当您指定一个映像时，Docker首先在您的Docker主机上查找该映像。如果映像不在本地，则从公共映像注册中心——Docker Hub中提取映像。</li><li id="0b4a" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">/bin/echo“Hello world”是将在新容器中运行的命令。这个容器只是打印“Hello world”并停止执行。</li></ul><p id="11ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们尝试在Docker容器中创建一个交互式shell:</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="1597" class="mx kv hu mt b fv my mz l na nb">docker run -i -t --rm ubuntu /bin/bash</span></pre><ul class=""><li id="d97d" class="lx ly hu it b iu iv iy iz jc lz jg ma jk mb jo mc md me mf dt translated">-t标志在新容器内分配一个伪tty或终端。</li><li id="3b74" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">-i flag允许您通过获取容器的标准输入(STDIN)来建立交互式连接。</li><li id="0e76" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">— rm标志在流程退出时自动移除容器。默认情况下，不会删除容器。这个容器在我们保持shell会话之前一直存在，并在我们退出会话时终止(就像与远程服务器的SSH会话一样)。</li></ul><p id="ec40" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果希望在会话结束后保持容器运行，需要对其进行守护化:</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="eb8a" class="mx kv hu mt b fv my mz l na nb">docker run --name daemon -d ubuntu /bin/sh -c "while true; do echo hello world; sleep 1; done"</span></pre><ul class=""><li id="c116" class="lx ly hu it b iu iv iy iz jc lz jg ma jk mb jo mc md me mf dt translated">—名称守护程序将守护程序名称分配给新容器。如果没有明确指定名称，Docker会自动生成并分配。</li><li id="18f8" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">-d标志在后台运行容器(即将其后台化)。</li></ul><p id="6c3b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们看看目前有哪些集装箱:</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="c919" class="mx kv hu mt b fv my mz l na nb">docker ps -a</span></pre><p id="f85c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">控制台输出:</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="500e" class="mx kv hu mt b fv my mz l na nb">CONTAINER ID  IMAGE   COMMAND                 CREATED             STATUS                         PORTS  NAMES  <br/>1fc8cee64ec2  ubuntu  "/bin/sh -c 'while..."  32 seconds ago      Up 30 seconds                         daemon  <br/>c006f1a02edf  ubuntu  "/bin/echo 'Hello ..."  About a minute ago  Exited (0) About a minute ago         gifted_nobel</span></pre><ul class=""><li id="8bda" class="lx ly hu it b iu iv iy iz jc lz jg ma jk mb jo mc md me mf dt translated">docker ps是一个列出容器的命令。</li><li id="3ee6" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">-a显示所有容器(如果没有-a标志，ps将只显示正在运行的容器)。</li></ul><p id="0944" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">ps显示我们有两个容器:<br/> * gifted_nobel(这个容器的名称是自动生成的，在您的机器上会有所不同)。这是我们创造的第一个容器，一次打印“Hello world”的容器。* daemon —我们创建的第三个容器，它作为一个守护程序运行。</p><p id="9007" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意:没有第二个容器(带有交互式shell的容器),因为我们设置了— rm选项。因此，该容器在执行后会被自动删除。</p><p id="7282" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们检查日志，看看守护进程容器现在正在做什么:</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="356f" class="mx kv hu mt b fv my mz l na nb">docker logs -f daemon</span></pre><p id="cba8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">控制台输出:</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="f7d2" class="mx kv hu mt b fv my mz l na nb">...<br/>hello world  <br/>hello world  <br/>hello world</span></pre><ul class=""><li id="1513" class="lx ly hu it b iu iv iy iz jc lz jg ma jk mb jo mc md me mf dt translated">docker日志获取容器的日志。</li><li id="6858" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">跟踪日志输出的-f标志(实际上类似于tail -f)。</li></ul><p id="460b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们停止守护进程容器:</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="3004" class="mx kv hu mt b fv my mz l na nb">docker stop daemon</span></pre><p id="c2b5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">确保容器已经停止。</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="4871" class="mx kv hu mt b fv my mz l na nb">docker ps -a</span></pre><p id="5292" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">控制台输出:</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="fd72" class="mx kv hu mt b fv my mz l na nb">CONTAINER ID  IMAGE   COMMAND                 CREATED        STATUS                      PORTS  NAMES  <br/>1fc8cee64ec2  ubuntu  "/bin/sh -c 'while..."  5 minutes ago  Exited (137) 5 seconds ago         daemon  <br/>c006f1a02edf  ubuntu  "/bin/echo 'Hello ..."  6 minutes ago  Exited (0) 6 minutes ago           gifted_nobel</span></pre><p id="f6e3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">容器被停止。我们可以重新开始:</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="9870" class="mx kv hu mt b fv my mz l na nb">docker start daemon</span></pre><p id="80ca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们确保它正在运行:</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="3def" class="mx kv hu mt b fv my mz l na nb">docker ps -a</span></pre><p id="07fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">控制台输出:</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="3e6e" class="mx kv hu mt b fv my mz l na nb">CONTAINER ID  IMAGE   COMMAND                 CREATED        STATUS                    PORTS  NAMES  <br/>1fc8cee64ec2  ubuntu  "/bin/sh -c 'while..."  5 minutes ago  Up 3 seconds                     daemon  <br/>c006f1a02edf  ubuntu  "/bin/echo 'Hello ..."  6 minutes ago  Exited (0) 7 minutes ago         gifted_nobel</span></pre><p id="120d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，再次停止并手动移除所有容器:</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="a662" class="mx kv hu mt b fv my mz l na nb">docker stop daemon  <br/>docker rm &lt;your first container name&gt;  <br/>docker rm daemon</span></pre><p id="c5c1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要删除所有容器，我们可以使用以下命令:</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="757c" class="mx kv hu mt b fv my mz l na nb">docker rm -f $(docker ps -aq)</span></pre><ul class=""><li id="00b1" class="lx ly hu it b iu iv iy iz jc lz jg ma jk mb jo mc md me mf dt translated">docker rm是移除容器的命令。</li><li id="5897" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">-f标志(用于rm)在容器运行时停止容器(即强制删除)。* -q标志(用于ps)仅打印容器id。</li></ul><h1 id="5e9b" class="ku kv hu bd kw kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr dt translated">您可能还喜欢:</h1><div class="ng nh fm fo ni nj"><a href="https://djangostars.com/blog/merging-django-orm-with-sqlalchemy-for-easier-data-analysis/?utm_source=medium&amp;utm_medium=hackernoon.com&amp;utm_campaign=docker%20tutorial&amp;utm_content=youmayalsolike1" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab ej"><div class="nl ab nm cl cj nn"><h2 class="bd hv fv z el no eo ep np er et ht dt translated">将Django ORM与SQLAlchemy合并以简化数据分析</h2><div class="nq l"><h3 class="bd b fv z el no eo ep np er et ek translated">Django产品的开发通常简单明了:优秀的文档，许多现成的工具…</h3></div><div class="nr l"><p class="bd b gc z el no eo ep np er et ek translated">djangostars.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx ka nj"/></div></div></a></div><div class="ng nh fm fo ni nj"><a href="https://djangostars.com/blog/django-performance-optimization-tips/?utm_source=medium&amp;utm_medium=hackernoon.com&amp;utm_campaign=docker%20tutorial&amp;utm_content=youmayalsolike2" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab ej"><div class="nl ab nm cl cj nn"><h2 class="bd hv fv z el no eo ep np er et ht dt translated">Django性能优化技巧</h2><div class="nq l"><h3 class="bd b fv z el no eo ep np er et ek translated">当开发人员接到一个在Django上进行性能优化的任务时，我经常会遇到这种情况…</h3></div><div class="nr l"><p class="bd b gc z el no eo ep np er et ek translated">djangostars.com</p></div></div><div class="ns l"><div class="ny l nu nv nw ns nx ka nj"/></div></div></a></div><h1 id="4759" class="ku kv hu bd kw kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr dt translated">示例2:环境变量和卷</h1><p id="2778" class="pw-post-body-paragraph ir is hu it b iu ls iw ix iy lt ja jb jc lu je jf jg lv ji jj jk lw jm jn jo hn dt translated">从这个例子开始，你需要几个可以在我的<a class="ae kt" href="https://github.com/alexryabtsev/docker-workshop/" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>上找到的附加文件。你可以克隆我的回购或简单地使用<a class="ae kt" href="https://github.com/alexryabtsev/docker-workshop/archive/master.zip" rel="noopener ugc nofollow" target="_blank">以下链接</a>下载样本文件。</p><p id="bc41" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">是时候创建和运行更有意义的容器了，比如Nginx。<br/>将目录改为examples/nginx:</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="7c03" class="mx kv hu mt b fv my mz l na nb">docker run -d --name "test-nginx" -p 8080:80 -v $(pwd):/usr/share/nginx/html:ro nginx:latest</span></pre><p id="a182" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">警告:这个命令看起来很重，但它只是解释volumes和env变量的一个例子。在99%的实际情况下，您不会手动启动Docker容器——您将使用编排服务(我们将在<a class="ae kt" href="https://github.com/alexryabtsev/docker-workshop#example-4-connection-between-containers" rel="noopener ugc nofollow" target="_blank">示例#4 </a>中介绍<a class="ae kt" href="https://docs.docker.com/compose/overview/" rel="noopener ugc nofollow" target="_blank"> docker-compose </a>)或编写自定义脚本来完成。</p><p id="a34f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">控制台输出:</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="c2f4" class="mx kv hu mt b fv my mz l na nb">Unable to find image 'nginx:latest' locally  <br/>latest: Pulling from library/nginx  <br/>683abbb4ea60: Pull complete  <br/>a470862432e2: Pull complete  <br/>977375e58a31: Pull complete  <br/>Digest: sha256:a65beb8c90a08b22a9ff6a219c2f363e16c477b6d610da28fe9cba37c2c3a2ac  <br/>Status: Downloaded newer image for nginx:latest  <br/>afa095a8b81960241ee92ecb9aa689f78d201cff2469895674cec2c2acdcc61c</span></pre><ul class=""><li id="86eb" class="lx ly hu it b iu iv iy iz jc lz jg ma jk mb jo mc md me mf dt translated">-p是端口映射主机端口:容器端口。</li><li id="08c5" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">-v是卷挂载主机目录:容器目录。</li></ul><p id="2882" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">重要提示:run命令只接受绝对路径。在我们的例子中，我们使用$(pwd)来设置当前目录的绝对路径。<br/>现在在您的网络浏览器中检查这个<a class="ae kt" href="http://127.0.0.1:8080/" rel="noopener ugc nofollow" target="_blank"> url </a>。</p><p id="d101" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以尝试更改/example/nginx/index.html(作为卷挂载到容器内部的/usr/share/nginx/html目录)并刷新页面。</p><p id="c521" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们获得关于test-nginx容器的信息:</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="249e" class="mx kv hu mt b fv my mz l na nb">docker inspect test-nginx</span></pre><p id="19d2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该命令显示关于Docker安装的系统范围的信息。这些信息包括内核版本、容器和映像的数量、公开的端口、挂载的卷等。</p><h1 id="0937" class="ku kv hu bd kw kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr dt translated">示例3:编写您的第一个docker文件</h1><p id="a637" class="pw-post-body-paragraph ir is hu it b iu ls iw ix iy lt ja jb jc lu je jf jg lv ji jj jk lw jm jn jo hn dt translated">要构建Docker映像，您需要创建一个Docker文件。它是一个带有指令和参数的纯文本文件。下面是我们将在下一个示例中使用的指令的描述:</p><ul class=""><li id="fd65" class="lx ly hu it b iu iv iy iz jc lz jg ma jk mb jo mc md me mf dt translated">从-设置基础图像</li><li id="8b01" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">运行—在容器中执行命令</li><li id="f6cc" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">ENV —设置环境变量</li><li id="5c85" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">工作目录—设置工作目录</li><li id="cfac" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">卷—为卷创建装载点</li><li id="3a98" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">CMD —为容器设置可执行文件</li></ul><p id="77b7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以查看<a class="ae kt" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank"> Dockerfile reference </a>了解更多详情。</p><p id="f034" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们创建一个图像，该图像将使用url获取网站的内容，并将其存储到文本文件中。我们需要通过环境变量SITE_url传递网站URL。生成的文件将放在一个目录中，作为一个卷挂载。</p><p id="3b16" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">将文件名Dockerfile放在examples/curl目录中，内容如下:</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="1c4d" class="mx kv hu mt b fv my mz l na nb">FROM ubuntu:latest  <br/>RUN apt-get update \  <br/>    &amp;&amp; apt-get install --no-install-recommends --no-install-suggests -y curl \<br/>    &amp;&amp; rm -rf /var/lib/apt/lists/*<br/>ENV SITE_URL <a class="ae kt" href="http://example.com/" rel="noopener ugc nofollow" target="_blank">http://example.com/</a>  <br/>WORKDIR /data  <br/>VOLUME /data  <br/>CMD sh -c "curl -Lk $SITE_URL &gt; /data/results"</span></pre><p id="4310" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Dockerfile准备好了。是时候构建实际的图像了。</p><p id="2799" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">转到examples/curl目录，执行以下命令来构建映像:</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="9706" class="mx kv hu mt b fv my mz l na nb">docker build . -t test-curl</span></pre><p id="ab89" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">控制台输出:</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="dd31" class="mx kv hu mt b fv my mz l na nb">Sending build context to Docker daemon  3.584kB  <br/>Step 1/6 : FROM ubuntu:latest  <br/> ---&gt; 113a43faa138<br/>Step 2/6 : RUN apt-get update     &amp;&amp; apt-get install --no-install-recommends --no-install-suggests -y curl     &amp;&amp; rm -rf /var/lib/apt/lists/*  <br/> ---&gt; Running in ccc047efe3c7<br/>Get:1 <a class="ae kt" href="http://archive.ubuntu.com/ubuntu" rel="noopener ugc nofollow" target="_blank">http://archive.ubuntu.com/ubuntu</a> bionic InRelease [242 kB]  <br/>Get:2 <a class="ae kt" href="http://security.ubuntu.com/ubuntu" rel="noopener ugc nofollow" target="_blank">http://security.ubuntu.com/ubuntu</a> bionic-security InRelease [83.2 kB]  <br/>...<br/>Removing intermediate container ccc047efe3c7  <br/> ---&gt; 8d10d8dd4e2d<br/>Step 3/6 : ENV SITE_URL <a class="ae kt" href="http://example.com/" rel="noopener ugc nofollow" target="_blank">http://example.com/</a>  <br/> ---&gt; Running in 7688364ef33f<br/>Removing intermediate container 7688364ef33f  <br/> ---&gt; c71f04bdf39d<br/>Step 4/6 : WORKDIR /data  <br/>Removing intermediate container 96b1b6817779  <br/> ---&gt; 1ee38cca19a5<br/>Step 5/6 : VOLUME /data  <br/> ---&gt; Running in ce2c3f68dbbb<br/>Removing intermediate container ce2c3f68dbbb  <br/> ---&gt; f499e78756be<br/>Step 6/6 : CMD sh -c "curl -Lk $SITE_URL &gt; /data/results"  <br/> ---&gt; Running in 834589c1ac03<br/>Removing intermediate container 834589c1ac03  <br/> ---&gt; 4b79e12b5c1d<br/>Successfully built 4b79e12b5c1d  <br/>Successfully tagged test-curl:latest</span></pre><ul class=""><li id="c33b" class="lx ly hu it b iu iv iy iz jc lz jg ma jk mb jo mc md me mf dt translated">docker build命令在本地构建新映像。</li><li id="caf8" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">-t flag为图像设置名称标签。</li></ul><p id="1685" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们有了新图像，我们可以在现有图像列表中看到它:</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="a0a8" class="mx kv hu mt b fv my mz l na nb">docker images</span></pre><p id="a1f6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">控制台输出:</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="be8c" class="mx kv hu mt b fv my mz l na nb">REPOSITORY  TAG     IMAGE ID      CREATED         SIZE  <br/>test-curl   latest  5ebb2a65d771  37 minutes ago  180 MB  <br/>nginx       latest  6b914bbcb89e  7 days ago      182 MB  <br/>ubuntu      latest  0ef2e08ed3fa  8 days ago      130 MB</span></pre><p id="664f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以从映像创建并运行容器。让我们用默认参数试试看:</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="5937" class="mx kv hu mt b fv my mz l na nb">docker run --rm -v $(pwd)/vol:/data/:rw test-curl</span></pre><p id="50aa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要查看保存到文件中的结果，请运行:</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="2f1b" class="mx kv hu mt b fv my mz l na nb">cat ./vol/results</span></pre><p id="e0d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们试试Facebook.com的<a class="ae kt" href="http://facebook.com/" rel="noopener ugc nofollow" target="_blank"/>:</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="70eb" class="mx kv hu mt b fv my mz l na nb">docker run --rm -e SITE_URL=<a class="ae kt" href="https://facebook.com/" rel="noopener ugc nofollow" target="_blank">https://facebook.com/</a> -v $(pwd)/vol:/data/:rw test-curl</span></pre><p id="fd33" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要查看保存到文件中的结果，请运行:</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="de4d" class="mx kv hu mt b fv my mz l na nb">cat ./vol/results</span></pre><h1 id="eff1" class="ku kv hu bd kw kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr dt translated">创建图像的最佳实践是什么</h1><ul class=""><li id="d6f7" class="lx ly hu it b iu ls iy lt jc nc jg nd jk ne jo mc md me mf dt translated">仅包含必要的上下文—使用<a class="ae kt" href="https://docs.docker.com/engine/reference/builder/#dockerignore-file" rel="noopener ugc nofollow" target="_blank">。dockerignore </a>文件(如。git中的gitignore)</li><li id="e85d" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">避免安装不必要的软件包——它会消耗额外的磁盘空间。</li><li id="35eb" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">使用缓存。在Dockerfile的末尾添加变化很大的上下文(例如，项目的源代码)——这将有效地利用Docker缓存。</li><li id="d1e1" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">小心体积。你应该记住什么是卷中的数据。因为卷是持久的，不会随着容器而消亡，所以下一个容器将使用前一个容器创建的卷中的数据。</li><li id="6241" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">使用<a class="ae kt" href="https://docs.docker.com/engine/reference/builder/#environment-replacement" rel="noopener ugc nofollow" target="_blank">环境变量</a>(在运行、曝光、卷中)。这会让你的Dockerfile更加灵活。</li></ul><h1 id="a03b" class="ku kv hu bd kw kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr dt translated">阿尔卑斯山图片</h1><p id="54d6" class="pw-post-body-paragraph ir is hu it b iu ls iw ix iy lt ja jb jc lu je jf jg lv ji jj jk lw jm jn jo hn dt translated">许多Docker映像(映像的版本)是在Alpine Linux(T9)之上创建的——这是一个轻量级发行版，允许你减少Docker映像的整体大小。</p><p id="cbb1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于第三方服务，如Redis、Postgres等，我建议您使用基于Alpine的图片。对于你的应用程序映像，使用基于<a class="ae kt" href="https://hub.docker.com/_/buildpack-deps/" rel="noopener ugc nofollow" target="_blank"> buildpack </a>的映像——在容器内部调试会很容易，而且你会有很多预装的系统级需求。</p><p id="b0a7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">只有您可以决定使用哪个基本映像，但是您可以通过对所有映像使用一个基本映像来获得最大的好处，因为在这种情况下，缓存将得到更有效的利用。</p><h1 id="7e34" class="ku kv hu bd kw kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr dt translated">示例4:容器之间的连接</h1><p id="ce15" class="pw-post-body-paragraph ir is hu it b iu ls iw ix iy lt ja jb jc lu je jf jg lv ji jj jk lw jm jn jo hn dt translated"><a class="ae kt" href="https://docs.docker.com/compose/overview/" rel="noopener ugc nofollow" target="_blank"> Docker compose </a> —是一个CLI实用程序，用于将容器相互连接。你可以通过pip 安装docker-compose <a class="ae kt" href="https://pypi.org/project/docker-compose/" rel="noopener ugc nofollow" target="_blank">:</a></p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="655d" class="mx kv hu mt b fv my mz l na nb">sudo pip install docker-compose</span></pre><p id="c443" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个例子中，我将连接Python和Redis容器。</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="777b" class="mx kv hu mt b fv my mz l na nb">version: '3.6'  <br/>services:  <br/>  app:<br/>    build:<br/>      context: ./app<br/>    depends_on:<br/>      - redis<br/>    environment:<br/>      - REDIS_HOST=redis<br/>    ports:<br/>      - "5000:5000"<br/>  redis:<br/>    image: redis:3.2-alpine<br/>    volumes:<br/>      - redis_data:/data<br/>volumes:  <br/>  redis_data:</span></pre><p id="bb0a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">转到examples/compose并执行以下命令:</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="c5d7" class="mx kv hu mt b fv my mz l na nb">docker-compose up</span></pre><p id="1020" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">控制台输出:</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="e6ec" class="mx kv hu mt b fv my mz l na nb">Building app  <br/>Step 1/9 : FROM python:3.6.3  <br/>3.6.3: Pulling from library/python  <br/>f49cf87b52c1: Pull complete  <br/>7b491c575b06: Pull complete  <br/>b313b08bab3b: Pull complete  <br/>51d6678c3f0e: Pull complete  <br/>09f35bd58db2: Pull complete  <br/>1bda3d37eead: Pull complete  <br/>9f47966d4de2: Pull complete  <br/>9fd775bfe531: Pull complete  <br/>Digest: sha256:cdef88d8625cf50ca705b7abfe99e8eb33b889652a9389b017eb46a6d2f1aaf3  <br/>Status: Downloaded newer image for python:3.6.3  <br/> ---&gt; a8f7167de312<br/>Step 2/9 : ENV BIND_PORT 5000  <br/> ---&gt; Running in 3b6fe5ca226d<br/>Removing intermediate container 3b6fe5ca226d  <br/> ---&gt; 0b84340fa920<br/>Step 3/9 : ENV REDIS_HOST localhost  <br/> ---&gt; Running in a4f9a1d6f541<br/>Removing intermediate container a4f9a1d6f541  <br/> ---&gt; ebe63bf5959e<br/>Step 4/9 : ENV REDIS_PORT 6379  <br/> ---&gt; Running in fd06aa65fd33<br/>Removing intermediate container fd06aa65fd33  <br/> ---&gt; 2a581c31ff4f<br/>Step 5/9 : COPY ./requirements.txt /requirements.txt  <br/> ---&gt; 671093a12829<br/>Step 6/9 : RUN pip install -r /requirements.txt  <br/> ---&gt; Running in b8ea53bc6ba6<br/>Collecting flask==1.0.2 (from -r /requirements.txt (line 1))  <br/>  Downloading <a class="ae kt" href="https://files.pythonhosted.org/packages/7f/e7/08578774ed4536d3242b14dacb4696386634607af824ea997202cd0edb4b/Flask-1.0.2-py2.py3-none-any.whl" rel="noopener ugc nofollow" target="_blank">https://files.pythonhosted.org/packages/7f/e7/08578774ed4536d3242b14dacb4696386634607af824ea997202cd0edb4b/Flask-1.0.2-py2.py3-none-any.whl</a> (91kB)<br/>Collecting redis==2.10.6 (from -r /requirements.txt (line 2))  <br/>  Downloading <a class="ae kt" href="https://files.pythonhosted.org/packages/3b/f6/7a76333cf0b9251ecf49efff635015171843d9b977e4ffcf59f9c4428052/redis-2.10.6-py2.py3-none-any.whl" rel="noopener ugc nofollow" target="_blank">https://files.pythonhosted.org/packages/3b/f6/7a76333cf0b9251ecf49efff635015171843d9b977e4ffcf59f9c4428052/redis-2.10.6-py2.py3-none-any.whl</a> (64kB)<br/>Collecting click&gt;=5.1 (from flask==1.0.2-&gt;-r /requirements.txt (line 1))  <br/>  Downloading <a class="ae kt" href="https://files.pythonhosted.org/packages/34/c1/8806f99713ddb993c5366c362b2f908f18269f8d792aff1abfd700775a77/click-6.7-py2.py3-none-any.whl" rel="noopener ugc nofollow" target="_blank">https://files.pythonhosted.org/packages/34/c1/8806f99713ddb993c5366c362b2f908f18269f8d792aff1abfd700775a77/click-6.7-py2.py3-none-any.whl</a> (71kB)<br/>Collecting Jinja2&gt;=2.10 (from flask==1.0.2-&gt;-r /requirements.txt (line 1))  <br/>  Downloading <a class="ae kt" href="https://files.pythonhosted.org/packages/7f/ff/ae64bacdfc95f27a016a7bed8e8686763ba4d277a78ca76f32659220a731/Jinja2-2.10-py2.py3-none-any.whl" rel="noopener ugc nofollow" target="_blank">https://files.pythonhosted.org/packages/7f/ff/ae64bacdfc95f27a016a7bed8e8686763ba4d277a78ca76f32659220a731/Jinja2-2.10-py2.py3-none-any.whl</a> (126kB)<br/>Collecting itsdangerous&gt;=0.24 (from flask==1.0.2-&gt;-r /requirements.txt (line 1))  <br/>  Downloading <a class="ae kt" href="https://files.pythonhosted.org/packages/dc/b4/a60bcdba945c00f6d608d8975131ab3f25b22f2bcfe1dab221165194b2d4/itsdangerous-0.24.tar.gz" rel="noopener ugc nofollow" target="_blank">https://files.pythonhosted.org/packages/dc/b4/a60bcdba945c00f6d608d8975131ab3f25b22f2bcfe1dab221165194b2d4/itsdangerous-0.24.tar.gz</a> (46kB)<br/>Collecting Werkzeug&gt;=0.14 (from flask==1.0.2-&gt;-r /requirements.txt (line 1))  <br/>  Downloading <a class="ae kt" href="https://files.pythonhosted.org/packages/20/c4/12e3e56473e52375aa29c4764e70d1b8f3efa6682bef8d0aae04fe335243/Werkzeug-0.14.1-py2.py3-none-any.whl" rel="noopener ugc nofollow" target="_blank">https://files.pythonhosted.org/packages/20/c4/12e3e56473e52375aa29c4764e70d1b8f3efa6682bef8d0aae04fe335243/Werkzeug-0.14.1-py2.py3-none-any.whl</a> (322kB)<br/>Collecting MarkupSafe&gt;=0.23 (from Jinja2&gt;=2.10-&gt;flask==1.0.2-&gt;-r /requirements.txt (line 1))  <br/>  Downloading <a class="ae kt" href="https://files.pythonhosted.org/packages/4d/de/32d741db316d8fdb7680822dd37001ef7a448255de9699ab4bfcbdf4172b/MarkupSafe-1.0.tar.gz" rel="noopener ugc nofollow" target="_blank">https://files.pythonhosted.org/packages/4d/de/32d741db316d8fdb7680822dd37001ef7a448255de9699ab4bfcbdf4172b/MarkupSafe-1.0.tar.gz</a><br/>Building wheels for collected packages: itsdangerous, MarkupSafe  <br/>  Running setup.py bdist_wheel for itsdangerous: started<br/>  Running setup.py bdist_wheel for itsdangerous: finished with status 'done'<br/>  Stored in directory: /root/.cache/pip/wheels/2c/4a/61/5599631c1554768c6290b08c02c72d7317910374ca602ff1e5<br/>  Running setup.py bdist_wheel for MarkupSafe: started<br/>  Running setup.py bdist_wheel for MarkupSafe: finished with status 'done'<br/>  Stored in directory: /root/.cache/pip/wheels/33/56/20/ebe49a5c612fffe1c5a632146b16596f9e64676768661e4e46<br/>Successfully built itsdangerous MarkupSafe  <br/>Installing collected packages: click, MarkupSafe, Jinja2, itsdangerous, Werkzeug, flask, redis  <br/>Successfully installed Jinja2-2.10 MarkupSafe-1.0 Werkzeug-0.14.1 click-6.7 flask-1.0.2 itsdangerous-0.24 redis-2.10.6  <br/>You are using pip version 9.0.1, however version 10.0.1 is available.  <br/>You should consider upgrading via the 'pip install --upgrade pip' command.  <br/>Removing intermediate container b8ea53bc6ba6  <br/> ---&gt; 3117d3927951<br/>Step 7/9 : COPY ./app.py /app.py  <br/> ---&gt; 84a82fa91773<br/>Step 8/9 : EXPOSE $BIND_PORT  <br/> ---&gt; Running in 8e259617b7b5<br/>Removing intermediate container 8e259617b7b5  <br/> ---&gt; 55f447f498dd<br/>Step 9/9 : CMD [ "python", "/app.py" ]  <br/> ---&gt; Running in 2ade293ecb25<br/>Removing intermediate container 2ade293ecb25  <br/> ---&gt; b85b4246e9f8</span><span id="b171" class="mx kv hu mt b fv nz mz l na nb">Successfully built b85b4246e9f8  <br/>Successfully tagged compose_app:latest  <br/>WARNING: Image for service app was built because it did not already exist. To rebuild this image you must use `docker-compose build` or `docker-compose up --build`.  <br/>Creating compose_redis_1 ... done  <br/>Creating compose_app_1   ... done  <br/>Attaching to compose_redis_1, compose_app_1  <br/>redis_1  | 1:C 08 Jul 18:12:21.851 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf  <br/>redis_1  |                 _._  <br/>redis_1  |            _.-``__ ''-._  <br/>redis_1  |       _.-``    `.  `_.  ''-._           Redis 3.2.12 (00000000/0) 64 bit  <br/>redis_1  |   .-`` .-```.  ```\/    _.,_ ''-._  <br/>redis_1  |  (    '      ,       .-`  | `,    )     Running in standalone mode  <br/>redis_1  |  |`-._`-...-` __...-.``-._|'` _.-'|     Port: 6379  <br/>redis_1  |  |    `-._   `._    /     _.-'    |     PID: 1  <br/>redis_1  |   `-._    `-._  `-./  _.-'    _.-'  <br/>redis_1  |  |`-._`-._    `-.__.-'    _.-'_.-'|  <br/>redis_1  |  |    `-._`-._        _.-'_.-'    |           <a class="ae kt" href="http://redis.io/" rel="noopener ugc nofollow" target="_blank">http://redis.io</a>  <br/>redis_1  |   `-._    `-._`-.__.-'_.-'    _.-'  <br/>redis_1  |  |`-._`-._    `-.__.-'    _.-'_.-'|  <br/>redis_1  |  |    `-._`-._        _.-'_.-'    |  <br/>redis_1  |   `-._    `-._`-.__.-'_.-'    _.-'  <br/>redis_1  |       `-._    `-.__.-'    _.-'  <br/>redis_1  |           `-._        _.-'  <br/>redis_1  |               `-.__.-'  <br/>redis_1  |  <br/>redis_1  | 1:M 08 Jul 18:12:21.852 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.  <br/>redis_1  | 1:M 08 Jul 18:12:21.852 # Server started, Redis version 3.2.12  <br/>redis_1  | 1:M 08 Jul 18:12:21.852 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.  <br/>redis_1  | 1:M 08 Jul 18:12:21.852 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.  <br/>redis_1  | 1:M 08 Jul 18:12:21.852 * The server is now ready to accept connections on port 6379  <br/>app_1    |  * Serving Flask app "app" (lazy loading)  <br/>app_1    |  * Environment: production  <br/>app_1    |    WARNING: Do not use the development server in a production environment.  <br/>app_1    |    Use a production WSGI server instead.  <br/>app_1    |  * Debug mode: on  <br/>app_1    |  * Running on <a class="ae kt" href="http://0.0.0.0:5000/" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:5000/</a> (Press CTRL+C to quit)  <br/>app_1    |  * Restarting with stat  <br/>app_1    |  * Debugger is active!  <br/>app_1    |  * Debugger PIN: 170-528-240</span></pre><p id="81da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当前示例将增加Redis中的视图计数器。在您的网络浏览器中打开下面的url 并检查它。</p><p id="5e5e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如何使用docker-compose是一个单独教程的主题。首先，您可以使用Docker Hub中的一些图像。如果您想创建自己的图像，请遵循上面列出的最佳实践。就使用docker-compose而言，我唯一可以补充的是，您应该始终在docker-compose.yml中为您的卷给出明确的名称(如果映像有卷)。这个简单的规则将使你在将来检查你的卷时避免一个问题。</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="87fe" class="mx kv hu mt b fv my mz l na nb">version: '3.6'  <br/>services:  <br/>  ...<br/>  redis:<br/>    image: redis:3.2-alpine<br/>    volumes:<br/>      - redis_data:/data<br/>volumes:  <br/>  redis_data:</span></pre><p id="43b5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这种情况下，redis_data将是docker-compose.yml文件内部的名称；对于真实的卷名，将在前面加上项目名称前缀。</p><p id="640f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要查看卷，请运行:</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="e93e" class="mx kv hu mt b fv my mz l na nb">docker volume ls</span></pre><p id="d1fc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">控制台输出:</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="53f2" class="mx kv hu mt b fv my mz l na nb">DRIVER              VOLUME NAME  <br/>local               apptest_redis_data</span></pre><p id="0fae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果没有明确的卷名，将会出现UUID。下面是我的本地机器上的一个例子:</p><pre class="jr js jt ju fq ms mt mu mv aw mw dt"><span id="ecb6" class="mx kv hu mt b fv my mz l na nb">DRIVER              VOLUME NAME  <br/>local               ec1a5ac0a2106963c2129151b27cb032ea5bb7c4bd6fe94d9dd22d3e72b2a41b  <br/>local               f3a664ce353ba24dd43d8f104871594de6024ed847054422bbdd362c5033fc4c  <br/>local               f81a397776458e62022610f38a1bfe50dd388628e2badc3d3a2553bb08a5467f  <br/>local               f84228acbf9c5c06da7be2197db37f2e3da34b7e8277942b10900f77f78c9e64  <br/>local               f9958475a011982b4dc8d8d8209899474ea4ec2c27f68d1a430c94bcc1eb0227  <br/>local               ff14e0e20d70aa57e62db0b813db08577703ff1405b2a90ec88f48eb4cdc7c19  <br/>local               polls_pg_data  <br/>local               polls_public_files  <br/>local               polls_redis_data  <br/>local               projectdev_pg_data  <br/>local               projectdev_redis_data</span></pre><h1 id="6295" class="ku kv hu bd kw kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr dt translated">码头工人路</h1><p id="c5e6" class="pw-post-body-paragraph ir is hu it b iu ls iw ix iy lt ja jb jc lu je jf jg lv ji jj jk lw jm jn jo hn dt translated">Docker有一些限制和要求，这取决于系统的架构(打包到容器中的应用程序)。您可以忽略这些需求或找到一些变通办法，但在这种情况下，您不会获得使用Docker的所有好处。我强烈建议遵循这些建议:</p><ul class=""><li id="432f" class="lx ly hu it b iu iv iy iz jc lz jg ma jk mb jo mc md me mf dt translated">1个应用程序= 1个容器。</li><li id="27d8" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">在前台运行流程(不要使用systemd、upstart或任何其他类似的工具)。</li><li id="4b45" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">将数据保存在容器之外—使用卷。不要使用SSH(如果需要进入容器，可以使用docker exec命令)。</li><li id="9163" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">避免在容器内进行手动配置(或操作)。</li></ul><h1 id="c15e" class="ku kv hu bd kw kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr dt translated">结论</h1><p id="5c55" class="pw-post-body-paragraph ir is hu it b iu ls iw ix iy lt ja jb jc lu je jf jg lv ji jj jk lw jm jn jo hn dt translated">总结一下这篇教程，Docker已经和ide、Git一起成为了一个必备的开发工具。这是一个生产就绪的工具，具有丰富和成熟的基础设施。</p><p id="83d2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Docker可以用于所有类型的项目，无论项目的规模和复杂程度如何。一开始可以先从<a class="ae kt" href="https://docs.docker.com/compose/overview/" rel="noopener ugc nofollow" target="_blank">作曲</a>和<a class="ae kt" href="https://docs.docker.com/engine/swarm/" rel="noopener ugc nofollow" target="_blank">蜂群</a>开始。当项目增长时，你可以迁移到云服务，如<a class="ae kt" href="https://aws.amazon.com/containers/" rel="noopener ugc nofollow" target="_blank">亚马逊容器服务</a>或<a class="ae kt" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>。</p><p id="9c10" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">像货物运输中使用的标准容器一样，将代码包装在Docker容器中有助于您构建更快、更高效的CI/CD流程。这不仅仅是一群极客推动的另一种技术趋势——这是一种新的范式，已经在大公司的架构中使用，如<a class="ae kt" href="https://blog.docker.com/2017/12/containers-at-paypal/" rel="noopener ugc nofollow" target="_blank"> PayPal </a>、<a class="ae kt" href="https://blog.docker.com/2017/04/visa-inc-gains-speed-operational-efficiency-docker-enterprise-edition/" rel="noopener ugc nofollow" target="_blank"> Visa </a>、<a class="ae kt" href="https://www.docker.com/customers/swisscom-goes-400vms-20vms-docker" rel="noopener ugc nofollow" target="_blank"> Swisscom </a>、<a class="ae kt" href="https://www.docker.com/customers/ge-uses-docker-enable-self-service-their-developers" rel="noopener ugc nofollow" target="_blank">通用电气</a>、<a class="ae kt" href="https://www.docker.com/customers/docker-datacenter-delivers-splunks-house-demos" rel="noopener ugc nofollow" target="_blank"> Splink </a>等。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><a href="https://djangostars.com/services/python-django-development/?utm_source=medium&amp;utm_medium=hackernoon.com&amp;utm_campaign=docker%20tutorial&amp;utm_content=banner_end"><div class="fe ff oa"><img src="../Images/6d17f1f498aa416fd7fa01921bc012f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A_uHZvyUk2wIql_cXIsZcw.png"/></div></a></figure></div><div class="ab cl kc kd hc ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hn ho hp hq hr"><blockquote class="ob oc od"><p id="9aed" class="ir is jp it b iu iv iw ix iy iz ja jb oe jd je jf of jh ji jj og jl jm jn jo hn dt translated">文章由<a class="oh oi gr" href="https://medium.com/u/2a5b28db86e2?source=post_page-----81a9d740d091--------------------------------" rel="noopener" target="_blank">亚历山大·里亚布采夫</a> ( <a class="ae kt" href="https://djangostars.com/blog/author/alexander-ryabtsev/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">亚历山大·里亚布采夫</strong></a><strong class="it hv">)</strong>——Django Stars的后端工程师撰写。在Django Stars博客上阅读更多关于docker的信息。</p><p id="4122" class="ir is jp it b iu iv iw ix iy iz ja jb oe jd je jf of jh ji jj og jl jm jn jo hn dt translated">特别分享给<a class="oh oi gr" href="https://medium.com/u/4a8a924edf41?source=post_page-----81a9d740d091--------------------------------" rel="noopener" target="_blank"> Hackernoon </a>社区。</p></blockquote><p id="0415" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们随时欢迎您提出问题，分享您想阅读的话题！</p></div><div class="ab cl kc kd hc ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hn ho hp hq hr"><p id="0a2d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt oj translated">你已经在你的项目中使用过Docker了吗？在下面给我们留言或提问吧！</p><blockquote class="kj"><p id="a607" class="kk kl hu bd km kn ko kp kq kr ks jo ek translated"><em class="os">如果你觉得这篇文章有用，请点击👏下方按钮:)</em></p></blockquote><figure class="ot ou ov ow ox jv"><div class="bz el l di"><div class="oy oz l"/></div></figure><div class="jr js jt ju fq ab cb"><figure class="pa jv pb pc pd pe pf paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="pa jv pb pc pd pe pf paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="pa jv pb pc pd pe pf paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ob oc od"><p id="f922" class="ir is jp it b iu iv iw ix iy iz ja jb oe jd je jf of jh ji jj og jl jm jn jo hn dt translated"><a class="ae kt" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kt" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kt" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae kt" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is jp it b iu iv iw ix iy iz ja jb oe jd je jf of jh ji jj og jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kt" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kt" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff pg"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>