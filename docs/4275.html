<html>
<head>
<title>Functional Programming Concepts: Pure Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数式编程概念:纯函数</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/functional-programming-concepts-pure-functions-cafa2983f757?source=collection_archive---------12-----------------------#2017-05-22">https://medium.com/hackernoon/functional-programming-concepts-pure-functions-cafa2983f757?source=collection_archive---------12-----------------------#2017-05-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/dd5a65e3a761bcc096c7b50ce11abab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D3OYmknuwbxqSvJwAMYgSA.png"/></div></div></figure><p id="1247" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于函数式编程提供的优势，例如<strong class="je hv"><em class="ka"/></strong><strong class="je hv"><em class="ka">更容易测试</em></strong><strong class="je hv"><em class="ka">可预测性</em> </strong>以及许多其他优势，函数式编程近来受到了很多关注。</p><p id="c593" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">纯函数是一个主要在函数式编程语言中使用的概念，但是它可以应用在任何编程范例中。</p><p id="8bd8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="ka">什么是纯函数？</em>T29】</strong></p><p id="9a0a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个函数要被称为<em class="ka">纯函数必须满足两个条件。<br/> </em>我们来逐一了解这两个条件。</p><h1 id="de67" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">给函数相同的参数，它应该总是返回相同的输出。</h1><p id="7bf7" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在编写纯函数时，我们如何确定上述观点成立？</p><p id="8953" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">跟着我来获取答案！</p><blockquote class="le lf lg"><p id="1ca9" class="jc jd ka je b jf jg jh ji jj jk jl jm lh jo jp jq li js jt ju lj jw jx jy jz hn dt translated">函数不能使用程序的状态来计算它的输出。</p></blockquote><pre class="lk ll lm ln fq lo lp lq lr aw ls dt"><span id="82eb" class="lt kc hu lp b fv lu lv l lw lx">x = 5        # x is a global variable</span><span id="f838" class="lt kc hu lp b fv ly lv l lw lx">multiply(y):<br/>    return y*x</span></pre><p id="26fb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh lz ma mb lp b">multiply</code>不是一个纯函数，因为它的输出是使用全局变量x计算的。如果x的值改变，对于相同的输入,<code class="eh lz ma mb lp b">multiply</code>函数的输出也会改变。</p><pre class="lk ll lm ln fq lo lp lq lr aw ls dt"><span id="a3fa" class="lt kc hu lp b fv lu lv l lw lx">x = 5<br/>multiply(2)    # returns 10</span><span id="83f8" class="lt kc hu lp b fv ly lv l lw lx">x = 10         # value of global variable x changed from 5 to 10<br/>multiply(2): 20</span></pre><p id="c8d5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在上面的例子中，<code class="eh lz ma mb lp b">multiply</code>函数的输入是相同的，但是输出根据程序的状态发生了变化。</p><p id="6df9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">全局变量x也称为程序的状态，因为它可以在程序的任何部分被访问，并在程序执行期间定义与程序相关的数据。</em></p><p id="48b4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">由于</strong> <code class="eh lz ma mb lp b"><strong class="je hv">multiply</strong></code> <strong class="je hv">功能不是对相同的输入给出相同的输出，所以不是纯粹的。</strong></p><p id="c268" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了使<code class="eh lz ma mb lp b">multiply</code>纯净，我们可以将全局变量x作为参数传递给它。</p><pre class="lk ll lm ln fq lo lp lq lr aw ls dt"><span id="12bd" class="lt kc hu lp b fv lu lv l lw lx">def multiply_pure(y, x):<br/>    return y*x</span><span id="a0bb" class="lt kc hu lp b fv ly lv l lw lx">multiply_pure(2, 3)    # returns 6<br/>multiply_pure(2, 3)    # returns 6</span></pre><p id="a093" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">无论我们用相同的输入调用<code class="eh lz ma mb lp b">multiply_pure</code>多少次，它总是返回相同的输出。</p><blockquote class="le lf lg"><p id="9bfc" class="jc jd ka je b jf jg jh ji jj jk jl jm lh jo jp jq li js jt ju lj jw jx jy jz hn dt translated">其次，当在并发编程环境中工作时，函数不能将可变对象作为参数，也不能用它来计算函数的输出。</p></blockquote><p id="e383" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是因为并发进程可以修改可变对象，并最终修改函数的输出。<br/>下面的例子说明了上述观点:</p><pre class="lk ll lm ln fq lo lp lq lr aw ls dt"><span id="6a2b" class="lt kc hu lp b fv lu lv l lw lx"># returns length of the list passed as argument<br/>def compute_length(elements):<br/>    return elements.length()</span></pre><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div class="fe ff mc"><img src="../Images/f0c376ffe004d8368984e3d97c4b6d42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*pEjX1mc0SPvATv0LZ05DRw.png"/></div><figcaption class="md me fg fe ff mf mg bd b be z ek">Mutable <strong class="bd mh">elements</strong> list being modified by multiple processes</figcaption></figure><p id="3072" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在参数<code class="eh lz ma mb lp b">elements</code>被传递给<code class="eh lz ma mb lp b">compute_length</code>和<code class="eh lz ma mb lp b">elements</code>的长度被<code class="eh lz ma mb lp b">compute_length</code>函数返回的时间之间，可能会发生<code class="eh lz ma mb lp b">elements</code>列表的长度被另一个进程修改的情况。这是因为<code class="eh lz ma mb lp b">elements</code>是一个共享的可变列表，可以被多个进程访问。</p><p id="b635" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此<code class="eh lz ma mb lp b">compute_length</code>在并发编程环境中是不纯的。</p><blockquote class="le lf lg"><p id="35d8" class="jc jd ka je b jf jg jh ji jj jk jl jm lh jo jp jq li js jt ju lj jw jx jy jz hn dt translated">第三，一个函数不能从I/O接受任何输入，这样才是纯粹的。</p></blockquote><pre class="lk ll lm ln fq lo lp lq lr aw ls dt"><span id="33b0" class="lt kc hu lp b fv lu lv l lw lx"># takes input from the user and turns it into a greeting<br/>def greet():<br/>    str = raw_input()        # take input from user<br/>    str = "Hello " + str<br/>    return str</span></pre><p id="13f6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在上面写的例子中，函数的输出可能会根据I/O的输入而改变。</p><h1 id="028f" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">对结果的评估不应该导致任何副作用，例如可变对象的突变或对I/O设备的输出</h1><blockquote class="le lf lg"><p id="30fb" class="jc jd ka je b jf jg jh ji jj jk jl jm lh jo jp jq li js jt ju lj jw jx jy jz hn dt translated">纯函数不应该改变任何可变对象。</p></blockquote><p id="7892" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们遵循下面的书面示例来验证上面写的陈述:</p><pre class="lk ll lm ln fq lo lp lq lr aw ls dt"><span id="1e00" class="lt kc hu lp b fv lu lv l lw lx">class Box:<br/>    def __init__(self, length):<br/>        self.length = length<br/></span><span id="d197" class="lt kc hu lp b fv ly lv l lw lx"># doubles length of Box object<br/># Assumption: Only box objects are passed <br/>def double_length(box):<br/>    box.length = box.length * 2 <br/>    return<br/></span><span id="b690" class="lt kc hu lp b fv ly lv l lw lx">carton = Box(5)          # a Box object is created<br/>double_length(carton)    # length of carton is doubled<br/>print carton.length      # prints 10</span></pre><p id="d112" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里的<code class="eh lz ma mb lp b">double_length</code>函数是不纯的，因为它修改了可变的<code class="eh lz ma mb lp b">Box</code>对象。</p><p id="a23f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">疑惑？？</em></p><p id="23fa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们一步步了解它</p><ul class=""><li id="7898" class="mi mj hu je b jf jg jj jk jn mk jr ml jv mm jz mn mo mp mq dt translated"><code class="eh lz ma mb lp b">carton(Box object)</code>通过引用上例中的<code class="eh lz ma mb lp b">double_length</code>函数来传递。</li><li id="eb34" class="mi mj hu je b jf mr jj ms jn mt jr mu jv mv jz mn mo mp mq dt translated">函数内对<code class="eh lz ma mb lp b">Box</code>对象的任何更改在函数外都是可见的。所以我们可以说<code class="eh lz ma mb lp b">Box</code>对象对整个程序都是可访问的，这意味着<code class="eh lz ma mb lp b">Box</code>对象只不过是程序的状态。</li><li id="1c4d" class="mi mj hu je b jf mr jj ms jn mt jr mu jv mv jz mn mo mp mq dt translated">并且函数不能修改状态以被称为纯函数。</li></ul><blockquote class="le lf lg"><p id="82f1" class="jc jd ka je b jf jg jh ji jj jk jl jm lh jo jp jq li js jt ju lj jw jx jy jz hn dt translated">纯函数不应输出到I/O。</p></blockquote><pre class="lk ll lm ln fq lo lp lq lr aw ls dt"><span id="e4ab" class="lt kc hu lp b fv lu lv l lw lx"># prints text<br/>def printer(text):<br/>    print “printing…. ” + text </span></pre><p id="61a2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">I/O可以在控制台上打印，写入数据库等。</p><h1 id="f579" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">结论</h1><p id="db26" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">任何与程序状态交互的函数都有可能导致副作用。程序的状态可以是全局变量、可变对象、I/O操作等。</p><blockquote class="le lf lg"><p id="e641" class="jc jd ka je b jf jg jh ji jj jk jl jm lh jo jp jq li js jt ju lj jw jx jy jz hn dt translated">而且任何引起副作用的功能都是不纯的！！</p></blockquote><p id="8d8e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你喜欢这篇文章，请点击♥按钮，这样其他媒体用户可能会发现它，也会喜欢它。</p></div></div>    
</body>
</html>