<html>
<head>
<title>Maximizing Debuggability with Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Redux最大化可调试性</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/maximizing-debuggability-with-redux-2f0bb43054d8?source=collection_archive---------14-----------------------#2017-06-28">https://medium.com/hackernoon/maximizing-debuggability-with-redux-2f0bb43054d8?source=collection_archive---------14-----------------------#2017-06-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/f6e8c07104724d90f409ea05cc1b66a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WmXD6cob1lj38L5StDAUfQ.png"/></div></div></figure><p id="439d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我的上一篇博客文章<a class="ae ka" href="https://blog.logrocket.com/redux-logging-in-production-3b2a4816b713" rel="noopener ugc nofollow" target="_blank"> Redux登录生产</a>中，我讨论了使用Redux最重要的好处之一——可调试性。通过使用像LogRocket这样的前端日志工具，开发人员可以通过检查导致bug的<code class="eh kb kc kd ke b">actions</code>和<code class="eh kb kc kd ke b">state</code>变更，轻松理解并修复产品中棘手的bug。</p><p id="c8b6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然这些信息在任何Redux应用程序中都非常有用，但是通过设计一个考虑到日志的应用程序，我们还可以实现更多。在这篇文章中，我将介绍一些库和抽象，它们通过将尽可能多的应用程序数据放入Redux，使得Redux日志<em class="kf">更加有用。</em></p><h1 id="62bd" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">数据提取</h1><p id="b85c" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">通过网络获取/发送数据是任何应用程序中最容易出错的部分之一。连接、意外数据或不正确的逻辑都可能导致问题。轮询、重试逻辑、乐观突变等使事情变得更加复杂。</p><p id="4ff6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">像GraphQL的<strong class="je hv"> apollo-client </strong>和REST的<strong class="je hv"> redux-query </strong>这样的库都有助于通过redux从网络获取数据。它们使用Redux作为持久层，这意味着在调试问题时，您可以检查您的Redux日志，以查看这些客户端获取了哪些数据以及正在进行的请求的状态。</p><p id="70dd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看看redux-query生成的Redux日志:</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lj"><img src="../Images/aaa3dbc6d21871988d675dc8c34208a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H_xAHVS6vKHer0velgQXnw.png"/></div></div></figure><p id="2107" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里我们看到了<code class="eh kb kc kd ke b">REQUEST_START</code>动作，它对应于一个被初始化的查询。查看action有效负载，我们可以看到请求中的所有信息，这使得调试变得很容易。一旦收到响应，<code class="eh kb kc kd ke b">redux-query</code>就会发出一个<code class="eh kb kc kd ke b">REQUEST_SUCCESS</code>动作，其中包含关于响应的所有信息。</p><p id="88e4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">记录请求和响应只是<code class="eh kb kc kd ke b">redux-query</code>魔力的一部分。深入到<code class="eh kb kc kd ke b">store</code>我们看到一个键<code class="eh kb kc kd ke b">queries</code>，在那里<code class="eh kb kc kd ke b">redux-query</code>保持其内部状态。</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lo"><img src="../Images/e708fa0b72ef918fbbfec689cd2a6a02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LAQZ7wqFPZRBnh5qOz9hzA.png"/></div></div></figure><p id="069c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面，我们看到了应用程序执行的每个查询的对象(一个到<code class="eh kb kc kd ke b">reddit.com/r/frontend.json</code>，一个到<code class="eh kb kc kd ke b">reddit.com/r/reactjs.json</code>)。在调试问题时，我们可以深入这个状态对象，查看正在进行的请求、<code class="eh kb kc kd ke b">queryCount</code>(如果我们在查询上轮询)和计时的信息。</p><p id="2a07" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Redux中存储这些信息非常重要，因为它将所有网络活动的完整上下文放在Redux日志中。</p><h2 id="81bb" class="lp kh hu bd ki lq lr ls km lt lu lv kq jn lw lx ku jr ly lz ky jv ma mb lc mc dt translated">滚动您自己的数据获取“框架”</h2><p id="43b4" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">如果您喜欢更简单的方法，您可以通过在查询和从网络接收数据时简单地分派显式操作来构建自己的数据获取“框架”。</p><p id="a663" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如，假设我们正在构建一个博客应用程序。在查询帖子时，我们会调度<code class="eh kb kc kd ke b">POSTS_QUERY_INIT</code>。然后，缩减器可以适当地更新状态，以表明posts查询正在进行中。</p><pre class="lk ll lm ln fq md ke me mf aw mg dt"><span id="cde5" class="lp kh hu ke b fv mh mi l mj mk">postsQuery: {<br/>  url: 'api.blog.com/posts',<br/>  isPending: true,<br/>  ...<br/>}</span></pre><p id="b58c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<code class="eh kb kc kd ke b">thunk</code>或<code class="eh kb kc kd ke b">saga</code>中，我们会调用<code class="eh kb kc kd ke b">fetch</code>，当承诺完成时，我们会发出类似于<code class="eh kb kc kd ke b">POSTS_QUERY_SUCCESS</code>或<code class="eh kb kc kd ke b">POSTS_QUERY_FAILURE</code>的动作。这将相应地将状态更新为:</p><pre class="lk ll lm ln fq md ke me mf aw mg dt"><span id="879d" class="lp kh hu ke b fv mh mi l mj mk">postsQuery: {<br/>  url: 'api.blog.com/posts',<br/>  isPending: true,<br/>  data: [...],<br/>}</span></pre><p id="1a74" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个例子并不全面，但是它的思想是，通过为请求生命周期的每个部分显式地使用Redux操作，可以很容易地调试任何潜在的竞争条件或网络错误。</p><h1 id="d418" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">处理非确定性的其他来源</h1><p id="babd" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">除了网络抓取之外，还有许多其他的不确定性来源会导致bug。幸运的是，我们也可以使用Redux来在出现bug时留下完整的日志。</p><h2 id="abb5" class="lp kh hu bd ki lq lr ls km lt lu lv kq jn lw lx ku jr ly lz ky jv ma mb lc mc dt translated">websockets</h2><p id="f677" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">当在websocket上侦听时，我们可以在接收到数据时调度一个动作，并适当地将数据减少到存储中。例如:</p><pre class="lk ll lm ln fq md ke me mf aw mg dt"><span id="f3b1" class="lp kh hu ke b fv mh mi l mj mk">myWebSocket.onmessage = function (event) {<br/>  store.dispatch({ <br/>    type: 'BLOG_POST_UPDATE_RECEIVED',<br/>    payload: event,<br/>  } <br/>}</span></pre><p id="7643" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这样，当查看redux日志中的错误或用户报告的问题时，我们可以看到通过websocket接收到的所有数据，更重要的是，可以及时将其与其他Redux操作和网络请求关联起来。</p><h2 id="8493" class="lp kh hu bd ki lq lr ls km lt lu lv kq jn lw lx ku jr ly lz ky jv ma mb lc mc dt translated">局部存储器</h2><p id="0899" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">通常，一个应用程序需要在第一次启动时从本地存储器中读取数据。为此，您可以使用<code class="eh kb kc kd ke b">redux-storage</code>,这是一个方便的库，便于将状态转储到本地存储，并读取/合并回状态。</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ml"><img src="../Images/45d43d1afffdf851ba668dc9b6b15923.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v1wTnBtzN6YZENxv3G4XRQ.png"/></div></div></figure><p id="9963" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每当<code class="eh kb kc kd ke b">redux-storage</code>从redux加载或保存状态时，它都会发出一个动作，显示将要减少到存储中的有效负载。</p><h2 id="f129" class="lp kh hu bd ki lq lr ls km lt lu lv kq jn lw lx ku jr ly lz ky jv ma mb lc mc dt translated">其他一切…</h2><p id="64eb" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">为不确定性的源分派Redux动作的模式适用于大多数API，如IndexedDB，甚至是Date()和Math.random()之类的函数——考虑将Redux动作与结果一起分派，以便将来可以轻松地调试它们。</p><h1 id="b550" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">反应路由器</h1><p id="fa08" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">使用<code class="eh kb kc kd ke b">react-router-redux</code>可以将react-router状态同步到Redux中。添加集成很简单，不需要对如何使用<code class="eh kb kc kd ke b">react-router</code>做任何改变。一旦您设置好库，您将在Redux存储中看到一个名为<code class="eh kb kc kd ke b">routing</code>的新密钥，其中包含当前路由器状态的信息。</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mm"><img src="../Images/1f0e2d63cbae6ed7f4b3c324e13f38c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i5lC6-CYMmeE0KF0Y9CHFA.png"/></div></div></figure><p id="f9cc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此外，<code class="eh kb kc kd ke b">react-router-redux</code>在其状态改变时会调度类似于<code class="eh kb kc kd ke b">@@router/LOCATION_CHANGE</code>的动作。</p><p id="df01" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还要注意的是，使用<code class="eh kb kc kd ke b">react-router-redux</code>可以让你在<code class="eh kb kc kd ke b">redux-devtools</code>中进行时间旅行时倒回路由器状态，因为它的状态是从Redux中的状态派生出来的。</p><h1 id="2a0e" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">关于局部vs冗余状态的一个注记</h1><p id="7650" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">我不想在这里讨论本地和Redux状态，但是在某些情况下，production Redux日志记录确实改变了这个决策的计算。当决定一个给定的状态是否应该在Redux中时，问问自己看到那个状态(以及影响它的动作)是否有助于调试问题。如果答案是肯定的，考虑将该状态放在Redux中，这样它将与崩溃报告和用户问题一起被记录。</p><h1 id="5f07" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">生产冗余记录</h1><p id="046c" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">在生产中记录Redux数据有助于修复bug和用户报告的问题。查看我之前的博文，了解更多信息:</p><div class="mn mo fm fo mp mq"><a href="https://blog.logrocket.com/redux-logging-in-production-3b2a4816b713" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab ej"><div class="ms ab mt cl cj mu"><h2 class="bd hv fv z el mv eo ep mw er et ht dt translated">生产中的冗余日志记录</h2><div class="mx l"><h3 class="bd b fv z el mv eo ep mw er et ek translated">Redux的最大优势之一是可调试性——通过记录应用执行期间的动作和状态…</h3></div><div class="my l"><p class="bd b gc z el mv eo ep mw er et ek translated">blog.logrocket.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne ja mq"/></div></div></a></div><h1 id="8559" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">TL；速度三角形定位法(dead reckoning)</h1><p id="e83c" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">使用通过Redux处理数据的库和模式，通过留下丰富的审计线索，有助于构建更多可调试的应用程序。</p><p id="baa1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当设计一个新特性时，问问自己它是否容易出错，以及能够在Redux日志中查看它的状态是否有助于解决未来的bug。</p></div><div class="ab cl nf ng hc nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="hn ho hp hq hr"><p id="34e0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="kf">很难保持前端开发的最新状态。加入我们的每周邮件列表，了解有助于您构建更好应用的新工具、库和最佳实践:</em></p><figure class="lk ll lm ln fq iv"><div class="bz el l di"><div class="nm nn l"/></div></figure><p id="2529" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://logrocket.com/?utm_source=medium&amp;utm_medium=footer" rel="noopener ugc nofollow" target="_blank"> <em class="kf"> LogRocket </em> </a> <em class="kf">是帮助你更快修复bug的JavaScript日志记录和回放工具。通过捕获应用程序的每个日志、网络请求和用户会话，您可以解决问题，而无需来回切换。</em></p><div class="lk ll lm ln fq ab cb"><figure class="no iv np nq nr ns nt paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="no iv np nq nr ns nt paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="no iv np nq nr ns nt paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="nu nv nw"><p id="f922" class="jc jd kf je b jf jg jh ji jj jk jl jm nx jo jp jq ny js jt ju nz jw jx jy jz hn dt translated"><a class="ae ka" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是阿妹家庭的一员。我们现在<a class="ae ka" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ka" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd kf je b jf jg jh ji jj jk jl jm nx jo jp jq ny js jt ju nz jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ka" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ka" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff oa"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>