# 开始考虑负载测试

> 原文：<https://medium.com/hackernoon/to-start-thinking-about-load-testing-e68384b24a12>

# 阿帕奇长凳

这是我们的 step 1 [工具](https://hackernoon.com/tagged/tool)，但是请记住这是单线程的。把 ab 想象成对性能的健全测试。**对于第一步，你可以使用一台单机，有足够的内存和 CPU。运行负载 15-30 分钟，检查是否有明显的问题。**

# wrk

wrk 是我们用于[负载测试](https://hackernoon.com/tagged/load-testing)的 step 2 工具，它类似于 ab，但是这将放置适当的负载(并发)。在第 2 步中，我们将使用一台大型计算机(比如 64 GB ram，8–16 个内核)。在这个阶段，我们仍然在单台机器上进行测试。运行负载约 30-60 分钟。在进入下一个阶段之前，这样可以很好地理解系统。

直到 1 和 2，我们可能正在测试应用程序的单个端点。这很容易设置和获得结果。但直到我们做了分布式负载测试+完成应用流程(流程完成前调用多个 API 的场景)，事情才算完成。**与 1 和 2 相比，分布式负载测试的设置时间更长，成本也更高。**

# 分布式负载测试

我们这里的 goto 工具是 jmeter。Jmeter 听起来可能是 java 特有的，但事实并非如此。这是一个很好的投资时间来拿起 jmeter。另外**因为 jmeter 是一个非常老的工具，所以很容易找到很多有用的指南和设置。**

3 的目标是得到每台机器每秒请求数的**良好估计**(一定要记下机器规格)。一旦你有了这个数字，**你就可以根据预期流量/高峰流量**来计划你的需求。还有助于决定您需要多少垂直/水平缩放。

# 对于垂直缩放

# 语言的选择

一旦您确定了需要关注性能的主要流程，您就可以用编译语言重写这些部分(这几乎总是获得性能提升的唾手可得的果实)。**但这只是在你的应用程序执行很多事情，而不仅仅是一个中间层与数据库对话的时候。**

# 体系结构

您已经处于一个很好的阶段，即跨几个服务而不是一个大的服务进行设置。尽量不要接受太多的服务。**您希望考虑每个网络呼叫(这将为每个呼叫增加至少 10ms)。有时耦合两个服务会给你带来好处。**

# 进入内存使用

对于 nodejs 来说，获得这些数字可能更难，但是在代码层面上，也可能有一些唾手可得的成果。确定 gc 的热点，或者在许多情况下，算法和数据结构本身也很重要。

# 对于水平缩放

# 负载平衡

检查你的 http 调用的安排。服务进入您的网络后要经过多少个路由器。计划如何平均分配负载。**循环法在开始是可以的，但是随着你的继续，要识别哪些呼叫是繁忙的，哪些不是，并相应地配置路由器。**

# 贮藏

如果系统是非交易/非支付系统，其中 99%的准确性和 100%一样好，那么缓存就很有帮助。但是要注意缓存的所有边缘情况。性能仅次于实际业务。**一个糟糕的缓存配置会变得非常糟糕，包括更低的性能和可能错误的结果。**还要注意已经存在的缓存(最近很多框架/ORM 都包含了隐藏缓存)

您可以在所有级别应用缓存:数据库级别、功能级别、控制器级别、api 级别。

# 数据库ˌ资料库

**对于多数读取/少数写入系统，您可以利用数据库从属服务器**来增加吞吐量(这属于缓存，尽管是不同的类型)。此外，请确保您考虑到当副本关闭时会发生什么情况。

-如果情况相反，主要写/次要读，您将需要**检查您使用的是什么数据库(有多个主数据库是有帮助的)**

-还有您如何在特定数据库中存储数据。**每个 DB 事务需要写入磁盘的数据量**。

以上是方法的简要总结。对于上面的每一点，你也应该考虑它的缺点

*   如果一台机器坏了怎么办
*   如果 5 下降了呢
*   如果网络延迟由于某种原因增加了怎么办
*   如果 io 速度由于某种原因下降了怎么办

以上的一些一般要点:

*   记下所有从您的系统发出的呼叫(给第三方)
*   如果第三方不能保证他们的 RPS/QPS，您可能希望转移到异步流(队列)
*   记下你的哪些服务是 IO 密集型的，哪些是 CPU 密集型的，哪些是网络密集型的(很多时候你可以在一个服务中加入两个)
*   负载测试时尽量减少模仿。