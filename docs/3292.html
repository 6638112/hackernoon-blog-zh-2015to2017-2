<html>
<head>
<title>6 Reasons Why JavaScript Async/Await Blows Promises Away (Tutorial)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript Async/Await背弃承诺的6个原因(教程)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9?source=collection_archive---------0-----------------------#2017-03-25">https://medium.com/hackernoon/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9?source=collection_archive---------0-----------------------#2017-03-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="4b22" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">👉这篇文章已经更新并重新发布，<a class="ae jp" href="https://dev.to/gafi/7-reasons-to-always-use-async-await-over-plain-promises-tutorial-4ej9" rel="noopener ugc nofollow" target="_blank">在这里阅读最新版本</a></p><p id="73d5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">NodeJS从7.6版开始支持异步/等待。我相信这是自2017年以来JS最大的一项增加。如果你还没有尝试过，这里有一堆理由和例子说明为什么你应该立即采用它，并且永远不要回头。</p><h1 id="55ac" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">异步/等待101</h1><p id="31d8" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">对于那些以前从未听说过这个话题的人，这里有一个简单的介绍</p><ul class=""><li id="a702" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">Async/await是一种编写异步代码的新方法。以前异步代码的替代方法是回调和承诺。</li><li id="da07" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">Async/await实际上只是建立在承诺之上的语法糖。它不能用于普通回调或节点回调。</li><li id="dab4" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">Async/await就像promises一样，是非阻塞的。</li><li id="6a14" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">Async/await使异步代码的外观和行为更像同步代码。这是它的全部力量所在。</li></ul><h1 id="a225" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">句法</h1><p id="b1f3" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">假设有一个函数<code class="eh lh li lj lk b">getJSON</code>返回一个承诺，这个承诺用某个JSON对象来解析。我们只想调用它并记录那个JSON，然后返回<code class="eh lh li lj lk b">"done"</code>。</p><p id="59b2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是你如何用承诺来实现它</p><figure class="ll lm ln lo fq lp"><div class="bz el l di"><div class="lq lr l"/></div></figure><p id="ea75" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是异步/等待的样子</p><figure class="ll lm ln lo fq lp"><div class="bz el l di"><div class="lq lr l"/></div></figure><p id="7610" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里有一些不同之处</p><ol class=""><li id="82b5" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ls kz la lb dt translated">我们的函数前面有关键字<code class="eh lh li lj lk b">async</code>。<code class="eh lh li lj lk b">await</code>关键字只能在用<code class="eh lh li lj lk b">async</code>定义的函数中使用。任何<code class="eh lh li lj lk b">async</code>函数都隐式返回一个承诺，承诺的解析值将是函数中的任何值<code class="eh lh li lj lk b">return</code>(在我们的例子中是字符串<code class="eh lh li lj lk b">"done"</code>)。</li><li id="f3f0" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ls kz la lb dt translated">上述观点暗示我们不能在代码的顶层使用await，因为它不在<code class="eh lh li lj lk b">async</code>函数中。</li></ol><figure class="ll lm ln lo fq lp"><div class="bz el l di"><div class="lq lr l"/></div></figure><p id="cf11" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">3.<code class="eh lh li lj lk b">await getJSON()</code>意味着<code class="eh lh li lj lk b">console.log</code>调用将等待，直到<code class="eh lh li lj lk b">getJSON()</code> promise解析并打印它的值。</p><h1 id="5314" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">为什么更好？</h1><h2 id="90bc" class="lt jr hu bd js lu lv lw jw lx ly lz ka jc ma mb ke jg mc md ki jk me mf km mg dt translated">1.简洁明了</h2><p id="eeee" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">看看我们没写多少代码！即使在上面这个虚构的例子中，很明显我们节省了大量的代码。我们不必编写<code class="eh lh li lj lk b">.then</code>，创建一个匿名函数来处理响应，或者给一个我们不需要使用的变量起一个名字<code class="eh lh li lj lk b">data</code>。我们也避免嵌套我们的代码。这些小优势很快就会累积起来，这在下面的代码示例中会变得更加明显。</p></div><div class="ab cl mh mi hc mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hn ho hp hq hr"><h2 id="8014" class="lt jr hu bd js lu lv lw jw lx ly lz ka jc ma mb ke jg mc md ki jk me mf km mg dt translated">2.错误处理</h2><p id="9b6e" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">Async/await使得用同一个构造处理同步和异步错误成为可能。在下面这个有承诺的例子中，如果<code class="eh lh li lj lk b">JSON.parse</code>失败了，那么<code class="eh lh li lj lk b">try/catch</code>不会处理，因为它发生在一个承诺中。我们需要在promise上调用<code class="eh lh li lj lk b">.catch</code>并复制我们的错误处理代码，这将(希望)比生产就绪代码中的<code class="eh lh li lj lk b">console.log</code>更加复杂。</p><figure class="ll lm ln lo fq lp"><div class="bz el l di"><div class="lq lr l"/></div></figure><p id="9bb2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在看一下带有async/await的相同代码。<code class="eh lh li lj lk b">catch</code>块现在将处理解析错误。</p><figure class="ll lm ln lo fq lp"><div class="bz el l di"><div class="lq lr l"/></div></figure></div><div class="ab cl mh mi hc mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hn ho hp hq hr"><h2 id="50f5" class="lt jr hu bd js lu lv lw jw lx ly lz ka jc ma mb ke jg mc md ki jk me mf km mg dt translated">3.条件式</h2><p id="96ee" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">想象一下下面的代码，它获取一些数据，并根据数据中的值决定是应该返回数据还是获取更多的细节。</p><figure class="ll lm ln lo fq lp"><div class="bz el l di"><div class="lq lr l"/></div></figure><p id="19ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">光看这个就让人头疼。很容易迷失在所有的嵌套(6层)、括号和返回语句中，这些语句只需要将最终结果传播到主承诺。</p><p id="1463" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当用async/await重写时，这个例子变得更加易读。</p><figure class="ll lm ln lo fq lp"><div class="bz el l di"><div class="lq lr l"/></div></figure></div><div class="ab cl mh mi hc mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hn ho hp hq hr"><h2 id="1f7e" class="lt jr hu bd js lu lv lw jw lx ly lz ka jc ma mb ke jg mc md ki jk me mf km mg dt translated">4.中间值</h2><p id="3255" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">您可能发现自己处于这样一种情况:调用一个<code class="eh lh li lj lk b">promise1</code>，然后使用它返回的内容调用<code class="eh lh li lj lk b">promise2</code>，然后使用两个承诺的结果调用一个<code class="eh lh li lj lk b">promise3</code>。您的代码很可能是这样的</p><figure class="ll lm ln lo fq lp"><div class="bz el l di"><div class="lq lr l"/></div></figure><p id="9f7c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果<code class="eh lh li lj lk b">promise3</code>不需要<code class="eh lh li lj lk b">value1</code>，那么将承诺嵌套变平一点就很容易了。如果你是那种无法忍受这种情况的人，你可以将两个值1 &amp; 2包装在一个<code class="eh lh li lj lk b">Promise.all</code>中，避免更深的嵌套，就像这样</p><figure class="ll lm ln lo fq lp"><div class="bz el l di"><div class="lq lr l"/></div></figure><p id="f1d4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了可读性，这种方法牺牲了语义。除了避免嵌套承诺之外，<code class="eh lh li lj lk b">value1</code> &amp; <code class="eh lh li lj lk b">value2</code>没有理由一起属于一个数组。</p><p id="6a69" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有了async/await，同样的逻辑变得简单而直观。这让你想知道，在你努力让承诺看起来不那么可怕的时候，你本可以做些什么。</p><figure class="ll lm ln lo fq lp"><div class="bz el l di"><div class="lq lr l"/></div></figure></div><div class="ab cl mh mi hc mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hn ho hp hq hr"><h2 id="6ed5" class="lt jr hu bd js lu lv lw jw lx ly lz ka jc ma mb ke jg mc md ki jk me mf km mg dt translated">5.错误堆栈</h2><p id="0015" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">想象一下，一段代码在一个链中调用多个承诺，在链的某个地方抛出了一个错误。</p><figure class="ll lm ln lo fq lp"><div class="bz el l di"><div class="lq lr l"/></div></figure><p id="e730" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从promise链返回的错误堆栈没有给出错误发生在哪里的线索。更糟糕的是，这是误导；它包含的唯一函数名是<code class="eh lh li lj lk b">callAPromise</code>,完全没有这个错误(尽管文件和行号仍然有用)。</p><p id="4891" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，来自async/await的错误堆栈指向包含错误的函数</p><figure class="ll lm ln lo fq lp"><div class="bz el l di"><div class="lq lr l"/></div></figure><p id="ed43" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当您在本地环境中开发并在编辑器中打开文件时，这不是一个很大的优势，但是当您试图理解来自生产服务器的错误日志时，这非常有用。在这种情况下，知道错误发生在<code class="eh lh li lj lk b">makeRequest</code>比知道错误来自<code class="eh lh li lj lk b">then</code>之后的<code class="eh lh li lj lk b">then</code>之后的<code class="eh lh li lj lk b">then</code>要好…</p></div><div class="ab cl mh mi hc mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hn ho hp hq hr"><h2 id="3dbf" class="lt jr hu bd js lu lv lw jw lx ly lz ka jc ma mb ke jg mc md ki jk me mf km mg dt translated">6.排除故障</h2><p id="85cf" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">最后但并非最不重要的一点是，使用async/await的一个致命优势是它更容易调试。调试承诺总是如此痛苦，原因有二</p><ol class=""><li id="3fd9" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ls kz la lb dt translated">不能在返回表达式(无体)的箭头函数中设置断点。</li></ol><figure class="ll lm ln lo fq lp fe ff paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="fe ff mo"><img src="../Images/7fd00cd1e9aab4540aaf580a055ca546.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n_V4LaVdBOFgGCbmTR_VKA.png"/></div></div><figcaption class="mv mw fg fe ff mx my bd b be z ek">Try setting a breakpoint anywhere here</figcaption></figure><p id="8ef2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2.如果您在一个<code class="eh lh li lj lk b">.then</code>块中设置了一个断点，并使用了调试快捷方式，如单步调试，调试器将不会移动到下一个<code class="eh lh li lj lk b">.then</code>，因为它只“单步执行”同步代码。</p><p id="0ecd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有了async/await，您不需要太多的arrow函数，并且您可以像正常的同步调用一样单步执行await调用。</p><figure class="ll lm ln lo fq lp fe ff paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="fe ff mz"><img src="../Images/b13a9fe44a48fc2491e0bad9b1cb1012.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GWYd4eLrs0U96MkNNVB56A.png"/></div></div></figure></div><div class="ab cl mh mi hc mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hn ho hp hq hr"><h1 id="da3c" class="jq jr hu bd js jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn dt translated">最后</h1><p id="e596" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">Async/await是过去几年中添加到<a class="ae jp" href="https://hackernoon.com/tagged/JavaScript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>中的最具革命性的特性之一。它让你意识到什么是语法混乱的承诺，并提供了一个直观的替代。</p><h1 id="e3f0" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">关系</h1><p id="c2a6" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">对于使用这个特性，你可能会有一些合理的怀疑，那就是它使异步代码变得不那么明显:我们的眼睛学会了每当我们看到回调或<code class="eh lh li lj lk b">.then</code>时识别异步代码，你的眼睛需要几个星期来适应新的迹象，但是C#拥有这个特性已经很多年了，熟悉它的人知道这是值得的，这是一个小的、暂时的不便。</p><p id="9758" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在twitter上关注我<a class="ae jp" href="https://twitter.com/imGaafar" rel="noopener ugc nofollow" target="_blank"> @imgaafar </a></p><figure class="ll lm ln lo fq lp fe ff paragraph-image"><a href="http://hackernoon.com"><div class="fe ff nf"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></a></figure><figure class="ll lm ln lo fq lp"><div class="bz el l di"><div class="ng lr l"/></div></figure></div></div>    
</body>
</html>