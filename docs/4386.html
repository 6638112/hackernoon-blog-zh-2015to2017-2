<html>
<head>
<title>Smart Data with Conduits</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带管道的智能数据</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/smart-data-with-conduits-b61fad3f4bad?source=collection_archive---------9-----------------------#2017-05-29">https://medium.com/hackernoon/smart-data-with-conduits-b61fad3f4bad?source=collection_archive---------9-----------------------#2017-05-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="ed5f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你现在是一名程序员，有一个现实你最好习惯。人们希望你知道如何处理大数据。这种数据需要一段时间来处理。如果你想同时把所有的东西都放进内存，它会让你的程序崩溃。但是您也希望避免对数据库发出单独的SQL请求来访问每一行。那会非常慢。那么如何解决这个问题呢？更具体地说，在Haskell中如何解决这个问题？</p><p id="5741" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这正是<code class="eh jp jq jr js b">Data.Conduit</code>库存在的问题类型。本文将通过一个简单的例子。我们将使用一个管道“source”来传输一些整数，并将它们加在一起。幸运的是，我们一次只需要看到来自源的一个数字，所以我们不需要把大量的数据带到内存中。让我们先来看看我们是如何创建这个源的。</p><h1 id="b42a" class="jt ju hu bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dt translated">获取我们的数据</h1><p id="9849" class="pw-post-body-paragraph ir is hu it b iu kr iw ix iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo hn dt translated">假设我们只是试图找出从1到1000万的数字的总和。最简单的方法是让我们的数字“来源”是一个原始列表，然后我们取这个列表的总和:</p><pre class="kw kx ky kz fq la js lb lc aw ld dt"><span id="87cc" class="le ju hu js b fv lf lg l lh li">myIntegerSourceBad :: [Integer]<br/>myIntegerSourceBad = [1..10000000]</span><span id="c33e" class="le ju hu js b fv lj lg l lh li">sumFromSource :: [Integer] -&gt; Integer<br/>sumFromSource lst = sum lst</span></pre><p id="878c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种方法需要同时将整个列表保存在内存中。想象一下，如果我们在查询一个拥有数千万条目的数据库。这可能会有问题。我们解决这个问题的第一步是使用<code class="eh jp jq jr js b">Data.Conduit</code>从这个列表中创建一个整数的“源”。我们可以用<code class="eh jp jq jr js b">sourceList</code>函数来做这件事。注意<code class="eh jp jq jr js b">Identity</code>是简单的恒等单子。也就是实际上不做任何事情的单子基单子:</p><pre class="kw kx ky kz fq la js lb lc aw ld dt"><span id="2405" class="le ju hu js b fv lf lg l lh li">import Control.Monad.Identity (Identity)<br/>import Data.Conduit (Source)<br/>import Data.Conduit.List (sourceList)</span><span id="43bc" class="le ju hu js b fv lj lg l lh li">myIntegerSource :: Source Identity Integer<br/>myIntegerSource = sourceList [1..10000000]</span></pre><p id="62e7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以现在不是返回一个<code class="eh jp jq jr js b">Int</code>值的集合列表，我们实际上是得到一个我们称之为<code class="eh jp jq jr js b">Source</code>的值流。让我们来描述一些导管类型的含义，以便更好地了解这里发生了什么。</p><h1 id="7601" class="jt ju hu bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dt translated">导管类型</h1><p id="fc78" class="pw-post-body-paragraph ir is hu it b iu kr iw ix iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo hn dt translated">导管类型都建立在<code class="eh jp jq jr js b">ConduitM</code>之上，这是导管的基本单子。这种类型有四个不同的参数。我们将把它的定义写成这样:</p><pre class="kw kx ky kz fq la js lb lc aw ld dt"><span id="c479" class="le ju hu js b fv lf lg l lh li">type ConduitM i o m r</span></pre><p id="0629" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您应该将每个管道视为一个数据处理漏斗。<code class="eh jp jq jr js b">i</code>类型是您可以带入漏斗的输入。<code class="eh jp jq jr js b">o</code>型代表输出。这些是你可以从漏斗中推出的价值。<code class="eh jp jq jr js b">m</code>类型是底层单子。我们将看到带有<code class="eh jp jq jr js b">Identity</code>单子和<code class="eh jp jq jr js b">IO</code>单子的例子。</p><p id="4fb8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以把最后一个<code class="eh jp jq jr js b">r</code>类型看作是“结果”。但是和输出不一样。这是函数本身在完成后返回的值。稍后我们写sink的时候会看到一个返回类型。但除此之外，我们通常只使用<code class="eh jp jq jr js b">()</code>。因此，我们可以使用<code class="eh jp jq jr js b">Conduit</code>类型同义词重写一些类型。这个同义词有助于忽略返回类型。但是它也很烦人，因为它颠倒了<code class="eh jp jq jr js b">m</code>和<code class="eh jp jq jr js b">o</code>类型的位置。不要让这个绊倒你。</p><pre class="kw kx ky kz fq la js lb lc aw ld dt"><span id="7c18" class="le ju hu js b fv lf lg l lh li">type Conduit i m o = ConduitM i o m ()</span></pre><p id="2c68" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们可以定义我们的源和接收器类型。A <code class="eh jp jq jr js b">Source</code>是一个没有输入(因此<code class="eh jp jq jr js b">i</code>是单元类型)并产生一些输出的管道。相反，<code class="eh jp jq jr js b">Sink</code>是一个接受一些输入但不产生输出的管道(因此是<code class="eh jp jq jr js b">Void</code>类型):</p><pre class="kw kx ky kz fq la js lb lc aw ld dt"><span id="8fe2" class="le ju hu js b fv lf lg l lh li">type Source m o = Conduit () m o<br/>type Sink i m r = ConduitM i Void m r</span></pre><p id="1e22" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以在上面的例子中，我们的函数是一个“源”。它创建一系列整数值，而不接受任何输入。我们将了解如何匹配具有不同匹配类型的不同导管。</p><h1 id="f54d" class="jt ju hu bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dt translated">原始函数</h1><p id="b50b" class="pw-post-body-paragraph ir is hu it b iu kr iw ix iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo hn dt translated">管道库中有三个基本函数:产出、等待和剩余。收益是我们如何将一个值传递到下游的另一个管道。换句话说，它是一种“生产”功能，或者说是价值的来源。我们只能产生与我们的管道函数的输出类型相匹配的类型。</p><p id="072b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么我们如何从上游获得价值呢？答案是<code class="eh jp jq jr js b">await</code>函数。这就像一个接收器，允许一个函数在等待接收来自上游的值时保持惰性。自然，这个值必须是管道输入的类型。现在，<code class="eh jp jq jr js b">await</code>的实际结果类型是一个<code class="eh jp jq jr js b">Maybe</code>值。我们可能会收到一个值<code class="eh jp jq jr js b">Nothing</code>。这表明我们的上游来源已经终止，我们不会再收到任何值。这通常是我们让函数返回的情况。</p><p id="a54b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后一个功能是<code class="eh jp jq jr js b">leftover</code>功能。这允许您从上游获取一个值，并将其放回上游。这样，我们可以从不同的接收器或者该接收器的不同迭代中再次使用该值。文档补充的一个警告是，您不应该对您自己创建的值使用<code class="eh jp jq jr js b">leftover</code>。您应该只使用从上游获得的值。</p><h1 id="28bc" class="jt ju hu bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dt translated">书写我们的管道</h1><p id="3822" class="pw-post-body-paragraph ir is hu it b iu kr iw ix iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo hn dt translated">所以上面我们已经为我们的玩具程序写了一个源管道。我们返回一个整数列表，这样我们就可以把它们一个接一个地输入到我们的程序中。现在，我们将编写一个接收这些值并将它们相加的接收器。这将采用带有累加器参数的递归函数的形式。接收器经常递归地接收它们的下一个输入。</p><p id="5759" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以我们将从等待来自上游管道的一些值开始。</p><pre class="kw kx ky kz fq la js lb lc aw ld dt"><span id="7ef4" class="le ju hu js b fv lf lg l lh li">myIntegerSink :: Integer -&gt; Sink Integer Identity Integer<br/>myIntegerSink accum = do<br/>  maybeFirstVal &lt;- await<br/>  ...</span></pre><p id="ee2f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果这个值是<code class="eh jp jq jr js b">Nothing</code>，我们就知道不会有更多的值出现。然后，我们可以返回我们所拥有的任何累计值。</p><pre class="kw kx ky kz fq la js lb lc aw ld dt"><span id="e002" class="le ju hu js b fv lf lg l lh li">myIntegerSink :: Integer -&gt; Sink Integer Identity Integer<br/>myIntegerSink accum = do<br/>  maybeFirstVal &lt;- await<br/>  case maybeFirstVal of<br/>    Nothing -&gt; return accum<br/>    ...</span></pre><p id="c891" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果该值包含另一个<code class="eh jp jq jr js b">Int</code>，我们将首先通过将它们相加来计算新的总和。然后，我们将使用新的累加器参数对sink函数进行递归调用:</p><pre class="kw kx ky kz fq la js lb lc aw ld dt"><span id="d79d" class="le ju hu js b fv lf lg l lh li">myIntegerSink :: Integer -&gt; Sink Integer Identity Integer<br/>myIntegerSink accum = do<br/>  maybeFirstVal &lt;- await<br/>  case maybeFirstVal of<br/>    Nothing -&gt; return accum<br/>    Just val -&gt; do<br/>      let newSum = val + accum<br/>      myIntegerSink newSum</span></pre><p id="2a9e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">真的就这样了！我们的例子很简单，所以代码也很简单。</p><h1 id="1c0f" class="jt ju hu bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dt translated">结合我们的管道</h1><p id="beb1" class="pw-post-body-paragraph ir is hu it b iu kr iw ix iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo hn dt translated">现在我们要结合我们的管道。我们用“fuse”操作符来做这件事，写成<code class="eh jp jq jr js b">=$=</code>。Haskell库因为拥有奇怪的操作符而臭名昭著。这个库不一定是个例外。但是把导管想象成一个隧道，这个操作符看起来像是连接隧道的两个部分。</p><p id="2a78" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用该操作符，第一个管道的输出类型需要与第二个管道的输入类型相匹配。就我们如何设置管道而言，情况就是这样。因此，现在为了润色，我们将<code class="eh jp jq jr js b">runConduitPure</code>与我们的组合导管一起使用:</p><pre class="kw kx ky kz fq la js lb lc aw ld dt"><span id="1d32" class="le ju hu js b fv lf lg l lh li">fullConduit :: Integer<br/>fullConduit = runConduitPure $ <br/>  myIntegerSource =$= myIntegerSink 0</span></pre><p id="cc05" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用fuse添加更多导管通常非常容易。例如，假设我们想让偶数加倍计数。我们可以在我们的源或汇中实现这一点，但我们也可以添加另一个管道。它将把一个<code class="eh jp jq jr js b">Int</code>作为输入，并产生一个<code class="eh jp jq jr js b">Int</code>作为输出。它需要输入一个整数，检查它的值，如果是偶数，就加倍它的值。然后我们将产生结果值。同样，如果我们没有看到管道的末端，我们需要递归地跳回到管道中。</p><pre class="kw kx ky kz fq la js lb lc aw ld dt"><span id="d8a9" class="le ju hu js b fv lf lg l lh li">myDoublingConduit :: Conduit Integer Identity Integer<br/>myDoublingConduit = do<br/>  maybeVal &lt;- await<br/>  case maybeVal of<br/>    Nothing -&gt; return () <br/>    Just val -&gt; do<br/>      let newVal = if val `mod` 2 == 0<br/>            then val * 2<br/>            else val<br/>      yield newVal<br/>      myDoublingConduit</span></pre><p id="0bec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我们可以用保险丝操作器将这个导管插在其他导管之间！</p><pre class="kw kx ky kz fq la js lb lc aw ld dt"><span id="baca" class="le ju hu js b fv lf lg l lh li">fullConduit :: Integer<br/>fullConduit = runConduitPure $ <br/>  myIntegerSource =$= myDoublingConduit =$= myIntegerSink 0</span></pre><h1 id="3d42" class="jt ju hu bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dt translated">矢量化</h1><p id="af5b" class="pw-post-body-paragraph ir is hu it b iu kr iw ix iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo hn dt translated">也有一些时候，您会想要批量处理某些事务。一个很好的例子就是当你想把所有结果从你的接收器插入到一个数据库中。您不希望一直发送单独的插入查询。相反，您可以等待并将一组输入组合在一起，然后发送批量插入。</p><p id="8bff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于我们的玩具示例，我们将把我们的int以100000为一组收集起来，这样我们就可以随时更新日志进度。这将需要改变我们的管道来生活在木卫一上。但是一旦我们做了这个改变，我们可以像这样使用<code class="eh jp jq jr js b">conduitVector</code>函数:</p><pre class="kw kx ky kz fq la js lb lc aw ld dt"><span id="3225" class="le ju hu js b fv lf lg l lh li">fullConduitIO :: IO Integer<br/>fullConduitIO = runConduit $ <br/>  myIntegerSourceIO =$= conduitVector 100000 =$= myIntegerVectorSink 0</span><span id="91ba" class="le ju hu js b fv lj lg l lh li">myIntegerSourceIO :: Source IO Integer<br/>myIntegerSourceIO = sourceList [1..100000000]</span><span id="2328" class="le ju hu js b fv lj lg l lh li">myIntegerVectorSink :: Integer -&gt; Sink (Vector Integer) IO Integer<br/>myIntegerVectorSink accum = do<br/>  maybeFirstVal &lt;- await<br/>  case maybeFirstVal of<br/>    Nothing -&gt; return accum<br/>    Just vals -&gt; do<br/>      let newSum = (Vec.sum vals) + accum<br/>      lift $ print newSum<br/>      myIntegerVectorSink newSum</span></pre><p id="4762" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过对管道进行矢量化，我们需要更改sink，以便它将<code class="eh jp jq jr js b">Vector Int</code>而不是<code class="eh jp jq jr js b">Int</code>作为其输入类型。然后我们从<code class="eh jp jq jr js b">await</code>得到一个向量，所以我们也必须对这些值求和。</p><h1 id="5cd9" class="jt ju hu bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dt translated">摘要</h1><p id="2225" class="pw-post-body-paragraph ir is hu it b iu kr iw ix iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo hn dt translated">数据。Conduit library允许您以可持续的方式处理大量数据。您可以使用它从数据库或其他来源传输数据。这比一次将大量信息放入内存更有效。它还允许你通过被称为管道的“隧道”传递信息。你可以让它们执行许多复杂的操作。您主要由<code class="eh jp jq jr js b">yield</code>、<code class="eh jp jq jr js b">await</code>和<code class="eh jp jq jr js b">leftover</code>功能组成管道功能。使用“融合”操作符<code class="eh jp jq jr js b">=$=</code>将导管合并成一个更大的导管。您也可以使用<code class="eh jp jq jr js b">conduitVector</code>功能来批处理某些操作符。</p><p id="3b73" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个更高级的话题。如果您以前从未编写过Haskell，那么它并不像本文描述的那样可怕！查看我们的<a class="ae lk" href="https://www.mmhaskell.com/checklist" rel="noopener ugc nofollow" target="_blank">入门清单</a>，迈出Haskell之旅的第一步！</p><p id="dc1b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你以前学过一点Haskell，但是需要更多的基础练习，你应该下载我们的<a class="ae lk" href="https://www.mmhaskell.com/workbook" rel="noopener ugc nofollow" target="_blank">递归工作簿</a>。它有一些关于递归的很棒的材料以及10个练习题！</p><p id="a6e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下周我们将继续一些更高级的话题。我们将研究<code class="eh jp jq jr js b">Data.Aeson</code>库，以及它如何允许我们将Haskell对象序列化为JSON格式！所以请继续关注周一早上的哈斯克尔！</p><h1 id="3d84" class="jt ju hu bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dt translated">附录</h1><p id="e04d" class="pw-post-body-paragraph ir is hu it b iu kr iw ix iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo hn dt translated">我前面提到过，操作符可能是Haskell中的一个主要痛点。不幸的是，文档也是如此。在为管道概念寻找合适的文档时，尤其如此。因此，作为参考，这里是我使用的所有导入:</p><pre class="kw kx ky kz fq la js lb lc aw ld dt"><span id="230b" class="le ju hu js b fv lf lg l lh li">import Conduit (conduitVector, lift)<br/>import Control.Monad.Identity (Identity)<br/>import Data.Conduit (Source, Sink, await, runConduitPure, (=$=), Conduit, yield, runConduit)<br/>import Data.Conduit.List (sourceList)<br/>import Data.Vector hiding (sum)<br/>import qualified Data.Vector as Vec</span></pre><p id="f641" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意<code class="eh jp jq jr js b">Data.Conduit</code>和<code class="eh jp jq jr js b">Data.Conduit.List</code>来自hackage上的<code class="eh jp jq jr js b">conduit</code>库。但是，<code class="eh jp jq jr js b">Conduit</code>模块其实来自<code class="eh jp jq jr js b">conduit-combinators</code>。这很有欺骗性。</p><blockquote class="ll lm ln"><p id="fe8d" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated"><a class="ae lk" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae lk" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae lk" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae lk" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae lk" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae lk" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae lk" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lk" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lk" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>