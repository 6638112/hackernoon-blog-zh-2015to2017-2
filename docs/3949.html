<html>
<head>
<title>Putting Your Haskell to the Test</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试您的Haskell</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/putting-your-haskell-to-the-test-193cc82b1823?source=collection_archive---------14-----------------------#2017-05-02">https://medium.com/hackernoon/putting-your-haskell-to-the-test-193cc82b1823?source=collection_archive---------14-----------------------#2017-05-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="127f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您在生产代码中遇到过多少次回归错误？对于软件工程师来说，这可能是最令人沮丧的经历之一。您发布了代码，并确信它可以工作。现在发现它打破了别的东西。避免这些错误的最好方法是让测试检查您的代码是否存在这些情况。那么Haskell中的测试是如何工作的呢？</p><p id="8820" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Haskell中，我们有一个口头禅，如果你的代码编译了，它应该工作。这在Haskell中可能比在其他语言中更真实。但这仍然是一个不太符合要求的半开玩笑的评论。在Haskell中，通常有不同的方法来实现相同的目标。但是我们应该努力让编译器更有可能捕捉到我们的错误。例如，我们可以使用newtypes作为类型同义词的替代来限制错误。</p><p id="6663" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，在某一点上，如果你想对你的代码有信心，你必须开始写测试。幸运的是，作为一门纯函数式语言，Haskell在测试方面有一些优势。在某些方面，它比面向对象的语言更容易测试，也更自然。它的功能特性让我们对测试Haskell更有信心。让我们来看看为什么。</p><h1 id="8f41" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">功能测试优势</h1><p id="f91d" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">当我们测试特定的功能时，测试效果最好。我们传递输入，我们得到输出，我们期望输出符合我们的期望。在Haskell中，这是一种非常合适的方法。功能是一等公民。我们的程序很大程度上是由函数的组合定义的。因此，我们的代码默认被分解成可测试的单元。</p><p id="fb6f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">相比之下，面向对象的语言，如Java。我们可以很容易地测试一个类的静态方法。这些通常与纯函数没有太大区别。但是现在考虑在对象上调用方法，尤其是void方法。因为该方法没有返回值，所以它的效果都是内部的。通常，我们无法检查内部效果，因为这些字段可能是私有的。</p><p id="7b3b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可能还想尝试检查某些边缘情况。但是这可能涉及到构造任意状态的对象。同样，我们会在私有领域遇到困难。</p><p id="7bea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Haskell中，我们所有的函数都有返回值，而不是依赖于效果。这使得我们很容易检查他们的真实结果。<strong class="it hv">纯函数</strong>也给了我们另一个巨大的胜利。我们的函数一般没有<strong class="it hv">没有副作用</strong>并且不依赖于全局状态。因此，我们不必担心许多可能影响我们系统的病理情况。</p><h1 id="28b4" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">测试驱动开发</h1><p id="6fcd" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">既然我们知道了为什么我们对我们的测试有点信心，让我们探索一下编写测试的过程。第一步是为特定模块定义公共API。为此，我们定义了一个将要公开的特定函数，以及它将作为输入输出的类型。然后我们可以像这篇关于<a class="ae ks" href="https://www.mmhaskell.com/blog/2017/4/3/compile-driven-learning" rel="noopener ugc nofollow" target="_blank">编译驱动学习</a>的文章中建议的那样，把它作为未定义的东西剔除掉。这使得调用它的代码仍然可以编译。</p><p id="fac2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，对于大多数开发人员来说，最大的诱惑就是直接开始编写函数。毕竟这是一个新功能，你应该对此感到兴奋！</p><p id="99de" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是从长远来看，如果你首先花时间定义你的测试用例，你会更好。您应该首先为您的函数定义特定的输入集。然后，您应该将它们与这些参数的预期输出相匹配。我们将在下一节讨论这方面的细节。然后，您将在测试套件中编写您的测试，并且您应该能够编译和运行测试。因为你的函数还没有定义，所以它们都会失败。但是现在你可以<strong class="it hv">逐步实现这个功能</strong>。</p><p id="5b89" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您的下一个目标是让函数运行完成。每当你发现一个你不确定如何填充的值时，试着想出一个基础值。一旦运行完成，测试将告诉您不正确的值，而不是错误。然后你就可以逐渐把越来越多的事情做对了。也许你的一些测试会得到验证，但是你忽略了一个特殊的情况。测试会让你知道的。</p><h1 id="429a" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">胡尼特</h1><p id="a034" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">测试代码的一种方法是使用<code class="eh kt ku kv kw b">QuickCheck</code>。这种方法更关注抽象的属性，而不是具体的例子。在这篇关于<a class="ae ks" href="https://mmhaskell.com/blog/2017/3/13/obey-the-type-laws" rel="noopener ugc nofollow" target="_blank">单子定律</a>的文章中，我们用这个库来看几个例子。在本文中，我们将结合使用<code class="eh kt ku kv kw b">HUnit</code>库和<code class="eh kt ku kv kw b">Tasty</code>测试框架来测试一些代码。</p><p id="17f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设一开始，我们正在编写一个接受三个输入的函数。它应该将前两个相乘，然后减去第三个。我们将从定义它开始:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="b5de" class="lf jq hu kw b fv lg lh l li lj">simpleMathFunction :: Int -&gt; Int -&gt; Int -&gt; Int<br/>simpleMathFunction a b c = undefined</span></pre><p id="6e61" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将取出输入和输出的组合，并把它们做成这样的测试用例:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="a810" class="lf jq hu kw b fv lg lh l li lj">simpleMathTests :: TestTree<br/>simpleMathTests = testGroup "Simple Math Tests"<br/>  [ testCase "Small Numbers" .<br/>      simpleMathFunction 3 4 5 @?= 7<br/>  , testCase "Bigger Numbers" .<br/>      simpleMathFunction 22 12 64 @?= 20<br/>  ]</span></pre><p id="a03b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们从定义一组具有更广泛描述的测试开始。然后我们制作单独的测试用例，每个用例都有自己的名字。然后在每一个例子中，我们使用<code class="eh kt ku kv kw b">@?=</code>操作符来检查实际值是否等于期望值。确保你的订单是正确的，把实际价值放在第一位。否则你会看到混乱的输出。然后我们可以在测试套件中运行它，我们将获得以下信息:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="6ef8" class="lf jq hu kw b fv lg lh l li lj">Simple Math Tests<br/>  Small Numbers:  FAIL<br/>    Exception: Prelude.undefined<br/>  Bigger Numbers: FAIL<br/>    Exception: Prelude.undefined</span></pre><p id="d427" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如所料，我们的测试用例失败了，所以我们知道如何改进我们的代码。所以让我们实现这个函数:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="0354" class="lf jq hu kw b fv lg lh l li lj">simpleMathFunction :: Int -&gt; Int -&gt; Int -&gt; Int<br/>simpleMathFunction a b c = a * b - c</span></pre><p id="d603" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在一切都成功了！</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="7de0" class="lf jq hu kw b fv lg lh l li lj">Simple Math Tests<br/>  Small Numbers:  OK<br/>  Bigger Numbers: OK</span><span id="ee3d" class="lf jq hu kw b fv lk lh l li lj">All 2 tests passed (0.00s)</span></pre><h1 id="8bf2" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">行为驱动发展</h1><p id="0a1d" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">当你从事更大的项目时，你会发现你不仅仅是与团队中的其他工程师互动。像项目经理和QA测试人员这样的技术涉众往往较少。这些人对代码的内部工作不太感兴趣，但仍然关心代码的更广泛的行为。在这些情况下，您可能想要采用“行为驱动开发”这就像测试驱动开发，但是有不同的味道。在这个框架中，您通过一组行为来描述您的代码及其预期效果。理想情况下，这些足够抽象，以至于不太懂技术的人也能理解。</p><p id="6935" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">作为工程师，您希望能够将这些行为转化为代码。幸运的是，Haskell是一种极具表现力的语言。你可以经常以这样一种方式定义你的函数，使得它们读起来几乎像英语。</p><h1 id="7fa3" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">Hspec</h1><p id="b7c6" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">在Haskell中，您可以使用<code class="eh kt ku kv kw b">Hspec</code>库实现行为驱动开发。有了这个库，你可以用一种特别有表现力的方式来描述你的函数。你所有的测试规范将属于一个<code class="eh kt ku kv kw b">Spec</code>单子。</p><p id="a293" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个monad中，您可以使用可组合的函数来描述测试用例。你通常会用“描述”功能来开始一个测试用例的描述。这需要一个描述测试用例总体概况的字符串。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="7210" class="lf jq hu kw b fv lg lh l li lj">simpleMathSpec :: Spec<br/>simpleMathSpec = describe "Tests of our simple math function" $ do<br/>  ...</span></pre><p id="8ef2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，您可以通过为每个单独的案例添加不同的“上下文”来修改它。上下文函数也接受一个字符串。但是<code class="eh kt ku kv kw b">context</code>的习惯用法是，你的字符串要以“when”或者“with”这样的词开头。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="226e" class="lf jq hu kw b fv lg lh l li lj">simpleMathSpec :: Spec<br/>simpleMathSpec = describe "Tests of our simple math function" $ do<br/>  context "when the numbers are small" $<br/>    ...<br/>  context "when the numbers are big" $<br/>    ...</span></pre><p id="5ad5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在你将描述每一个实际的测试用例。你将使用函数“它”，然后进行比较。<code class="eh kt ku kv kw b">Hspec</code>框架中的组合子是带有描述性名称的函数，如<code class="eh kt ku kv kw b">shouldBe</code>。所以你的案例会从一个句子般的描述和案例的背景开始。案件结束“应该有一定结果”:<code class="eh kt ku kv kw b">x</code>“应该”<code class="eh kt ku kv kw b">y</code>。实际情况是这样的:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="e567" class="lf jq hu kw b fv lg lh l li lj">main :: IO ()<br/>main = hspec simpleMathSpec<br/></span><span id="b6d9" class="lf jq hu kw b fv lk lh l li lj">simpleMathSpec :: Spec<br/>simpleMathSpec = describe "Tests of our simple math function" $ do<br/>  context "when the numbers are small" $<br/>    it "Should match the our expected value" $<br/>      simpleMathFunction 3 4 5 `shouldBe` 7<br/>  context "when the numbers are big" $<br/>    it "Should match the our expected value" $<br/>      simpleMathFunction 22 12 64 `shouldBe` 200</span></pre><p id="69f0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也可以完全省略上下文:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="1d52" class="lf jq hu kw b fv lg lh l li lj">simpleMathSpec :: Spec<br/>simpleMathSpec = describe "Tests of our simple math function" $ do<br/>  it "Should match the our expected value" $<br/>    simpleMathFunction 3 4 5 `shouldBe` 7<br/>  it "Should match the our expected value" $<br/>    simpleMathFunction 22 12 64 `shouldBe` 200</span></pre><p id="c1ca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，您将得到带有不同测试用例描述的整洁的格式化输出。通过编写表达性的函数名并添加您自己的组合子，您可以使您的测试代码更加自文档化。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="2f85" class="lf jq hu kw b fv lg lh l li lj">Tests of our simple math function<br/>  when the numbers are small<br/>    Should match the our expected value<br/>  when the numbers are big<br/>    Should match the our expected value</span><span id="bb19" class="lf jq hu kw b fv lk lh l li lj">Finished in 0.0002 seconds<br/>2 examples, 0 failures</span></pre><h1 id="406e" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">结论</h1><p id="bfa0" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">这就结束了我们对Haskell测试的概述。我们简要描述了测试驱动开发的一般实践。我们看到了为什么它在像Haskell这样的函数式类型语言中更加强大。我们讨论了一些基本的测试机制，你可以在HUnit库中找到。然后我们描述了“行为驱动开发”的过程，以及它与普通的TDD有什么不同。最后，我们展示了Haskell中的<code class="eh kt ku kv kw b">HSpec</code>库是如何将BDD带入生活的。</p><p id="44cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你想看到TDD的运行，并在此过程中了解一个很酷的函数范式，你应该看看我们的<a class="ae ks" href="https://www.mmhaskell.com/workbook" rel="noopener ugc nofollow" target="_blank">递归工作簿</a>。它有10个带测试的练习题，所以你可以逐步改进你的代码，最终看到测试通过！</p><p id="5b68" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你以前从未用Haskell编程，并且想看看这种流行是怎么回事，你应该下载我们的<a class="ae ks" href="https://www.mmhaskell.com/checklist" rel="noopener ugc nofollow" target="_blank">入门清单</a>。它将带您了解下载和安装Haskell的一些基础知识，并向您展示其他一些工具来帮助您！</p><blockquote class="ll lm ln"><p id="5c27" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated"><a class="ae ks" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客们下午的开始。我们是<a class="ae ks" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ks" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ks" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae ks" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae ks" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上给我们点赞/发消息</a>，或者简单地说，<a class="ae ks" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ks" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ks" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>