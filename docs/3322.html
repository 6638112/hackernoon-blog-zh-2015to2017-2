<html>
<head>
<title>Improve Your Python: Python Classes and Object Oriented Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">改进您的Python: Python类和面向对象编程</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/improve-your-python-python-classes-and-object-oriented-programming-d09ff461168d?source=collection_archive---------6-----------------------#2017-03-27">https://medium.com/hackernoon/improve-your-python-python-classes-and-object-oriented-programming-d09ff461168d?source=collection_archive---------6-----------------------#2017-03-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="6a4c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注:本周的每一天，我都会重新发布我最受欢迎的帖子之一。我希望第一次错过它们的人现在会发现它们很有用。这篇关于“类”和面向对象编程的帖子一直是我最受欢迎的帖子。光是这个帖子，我就收到了上百封邮件。许多人发现这是对Python和OOP的简单介绍。</p><p id="9016" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jp jq jr js b">class</code>是<a class="ae jt" href="https://hackernoon.com/tagged/python" rel="noopener ugc nofollow" target="_blank"> Python </a>中的一个基本构件。它不仅是许多流行程序和库的基础，也是Python标准库的基础。理解什么是类，何时使用它们，以及它们如何有用是至关重要的，也是本文的目标。在这个过程中，我们将探索术语<em class="ju">面向对象</em> <a class="ae jt" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank"> <em class="ju">编程</em> </a>的含义以及它如何与Python类联系在一起。</p><h1 id="7b5d" class="jv jw hu bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dt translated">一切都是物体…</h1><p id="b72e" class="pw-post-body-paragraph ir is hu it b iu kt iw ix iy ku ja jb jc kv je jf jg kw ji jj jk kx jm jn jo hn dt translated"><code class="eh jp jq jr js b">class</code>关键字到底是用来做什么的？就像它基于功能的表亲<code class="eh jp jq jr js b">def</code>一样，它关注事物的<em class="ju">定义</em>。<code class="eh jp jq jr js b">def</code>用于定义一个函数，<code class="eh jp jq jr js b">class</code>用于定义一个<em class="ju">类</em>。什么是阶级？只是数据和函数的逻辑分组(当在类中定义时，后者经常被称为“方法”)。</p><p id="c57a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们所说的“逻辑分组”是什么意思？嗯，一个类可以包含我们想要的任何数据，并且可以有我们想要的任何函数(方法)附加到它上面。我们试图创建事物之间有逻辑联系的类，而不是简单地将随机的事物放在一起命名为“类”。很多时候，类是基于现实世界中的对象的(比如<code class="eh jp jq jr js b">Customer</code>或者<code class="eh jp jq jr js b">Product</code>)。其他时候，类是基于我们系统中的概念，比如<code class="eh jp jq jr js b">HTTPRequest</code>或<code class="eh jp jq jr js b">Owner</code>。</p><p id="98f8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不管怎样，类是一种<em class="ju">建模</em>技术；一种思考程序的方式。当你以这种方式思考和实现你的系统时，你被认为是在执行面向对象的编程。“类”和“对象”是经常互换使用的词，但它们实际上不是一回事。理解它们的不同之处是理解它们是什么以及它们如何工作的关键。</p><h1 id="cecb" class="jv jw hu bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dt translated">..所以万物都有类？</h1><p id="680f" class="pw-post-body-paragraph ir is hu it b iu kt iw ix iy ku ja jb jc kv je jf jg kw ji jj jk kx jm jn jo hn dt translated">类可以被认为是创建对象的蓝图。当我<em class="ju">使用<code class="eh jp jq jr js b">class</code>关键字定义</em>一个客户类时，我实际上并没有创建一个客户。相反，我创建的是一种构造“客户”对象的指导手册。让我们看看下面的示例代码:</p><pre class="ky kz la lb fq lc js ld le aw lf dt"><span id="91e4" class="lg jw hu js b fv lh li l lj lk"><strong class="js hv">class</strong> <strong class="js hv">Customer</strong>(object):<br/>    <em class="ju">"""A customer of ABC Bank with a checking account. Customers have the</em><br/><em class="ju">    following properties:</em><br/><br/><em class="ju">    Attributes:</em><br/><em class="ju">        name: A string representing the customer's name.</em><br/><em class="ju">        balance: A float tracking the current balance of the customer's account.</em><br/><em class="ju">    """</em><br/><br/>    <strong class="js hv">def</strong> __init__(self, name, balance=0.0):<br/>        <em class="ju">"""Return a Customer object whose name is *name* and starting</em><br/><em class="ju">        balance is *balance*."""</em><br/>        self.name = name<br/>        self.balance = balance<br/><br/>    <strong class="js hv">def</strong> withdraw(self, amount):<br/>        <em class="ju">"""Return the balance remaining after withdrawing *amount*</em><br/><em class="ju">        dollars."""</em><br/>        <strong class="js hv">if</strong> amount &gt; self.balance:<br/>            <strong class="js hv">raise</strong> <strong class="js hv">RuntimeError</strong>('Amount greater than available balance.')<br/>        self.balance -= amount<br/>        <strong class="js hv">return</strong> self.balance<br/><br/>    <strong class="js hv">def</strong> deposit(self, amount):<br/>        <em class="ju">"""Return the balance remaining after depositing *amount*</em><br/><em class="ju">        dollars."""</em><br/>        self.balance += amount<br/>        <strong class="js hv">return</strong> self.balance</span></pre><p id="c840" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jp jq jr js b">class Customer(object)</code>行<em class="ju">不</em>创建新客户。也就是说，仅仅因为我们<em class="ju">定义了</em>一个<code class="eh jp jq jr js b">Customer</code>并不意味着我们<em class="ju">创造了</em>一个；我们仅仅概述了创建一个<code class="eh jp jq jr js b">Customer</code>对象的<em class="ju">蓝图</em>。为此，我们用适当数量的参数调用该类的<code class="eh jp jq jr js b">__init__</code>方法(减去<code class="eh jp jq jr js b">self</code>，我们稍后会讲到)。</p><p id="fba7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，为了使用我们通过定义<code class="eh jp jq jr js b">class Customer</code>(用于创建<code class="eh jp jq jr js b">Customer</code>对象)创建的“蓝图”，我们几乎像调用函数一样调用类名:<code class="eh jp jq jr js b">jeff = Customer('Jeff Knupp', 1000.0)</code>。这一行简单地说“使用<code class="eh jp jq jr js b">Customer</code>蓝图为我创建一个新对象，我称之为<code class="eh jp jq jr js b">jeff</code>”</p><p id="1c9a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">被称为<em class="ju">实例</em>的<code class="eh jp jq jr js b">jeff</code> <em class="ju">对象</em>，是<code class="eh jp jq jr js b">Customer</code> <em class="ju">类</em>的实现版本。在我们调用<code class="eh jp jq jr js b">Customer()</code>之前，没有<code class="eh jp jq jr js b">Customer</code>对象存在。当然，我们可以创建尽可能多的<code class="eh jp jq jr js b">Customer</code>对象。然而，仍然只有一个<code class="eh jp jq jr js b">Customer</code> <em class="ju">类</em>，不管我们创建了多少个<em class="ju">类的</em>实例。</p><h1 id="b8d9" class="jv jw hu bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dt translated"><code class="eh jp jq jr js b">self</code>？</h1><p id="5876" class="pw-post-body-paragraph ir is hu it b iu kt iw ix iy ku ja jb jc kv je jf jg kw ji jj jk kx jm jn jo hn dt translated">那么所有<code class="eh jp jq jr js b">Customer</code>方法的<code class="eh jp jq jr js b">self</code>参数是怎么回事呢？这是什么？为什么，这是实例，当然！换句话说，像<code class="eh jp jq jr js b">withdraw</code>这样的方法定义了从<em class="ju">某个抽象客户账户</em>中取钱的指令。调用<code class="eh jp jq jr js b">jeff.withdraw(100.0)</code>将那些使用<em class="ju">的指令放到</em> <code class="eh jp jq jr js b"><em class="ju">jeff</em></code> <em class="ju">实例</em>上。</p><p id="f5d4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以当我们说<code class="eh jp jq jr js b">def withdraw(self, amount):</code>时，我们是在说，“这是你如何从一个客户对象(我们称之为<code class="eh jp jq jr js b">self</code>)和一个美元数字(我们称之为<code class="eh jp jq jr js b">amount</code>)中取钱。<code class="eh jp jq jr js b">self</code>是被调用<code class="eh jp jq jr js b">withdraw</code>的<code class="eh jp jq jr js b">Customer</code>的<em class="ju">实例</em>。这也不是我在做类比。<code class="eh jp jq jr js b">jeff.withdraw(100.0)</code>只是<code class="eh jp jq jr js b">Customer.withdraw(jeff, 100.0)</code>的简写，它是完全有效的(如果不经常看到的话)代码。</p><h1 id="e2c9" class="jv jw hu bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dt translated"><code class="eh jp jq jr js b">__init__</code></h1><p id="a5f2" class="pw-post-body-paragraph ir is hu it b iu kt iw ix iy ku ja jb jc kv je jf jg kw ji jj jk kx jm jn jo hn dt translated"><code class="eh jp jq jr js b">self</code>可能对其他方法有意义，但是<code class="eh jp jq jr js b">__init__</code>呢？当我们调用<code class="eh jp jq jr js b">__init__</code>时，我们正在创建一个对象，那么怎么可能已经有了一个<code class="eh jp jq jr js b">self</code>？Python允许我们将<code class="eh jp jq jr js b">self</code>模式扩展到构造对象的时候，即使它并不<em class="ju">完全</em>适合。试想一下<code class="eh jp jq jr js b">jeff = Customer('Jeff Knupp', 1000.0)</code>和叫<code class="eh jp jq jr js b">jeff = Customer(jeff, 'Jeff Knupp', 1000.0)</code>是一样的；传入的<code class="eh jp jq jr js b">jeff</code>也是结果。</p><p id="936c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是为什么当我们调用<code class="eh jp jq jr js b">__init__</code>时，我们<em class="ju">通过说类似<code class="eh jp jq jr js b">self.name = name</code>的话来初始化</em>对象。记住，由于<code class="eh jp jq jr js b">self</code> <em class="ju">是</em>实例，这就相当于说<code class="eh jp jq jr js b">jeff.name = name</code>，和<code class="eh jp jq jr js b">jeff.name = 'Jeff Knupp</code>一样。同理，<code class="eh jp jq jr js b">self.balance = balance</code>与<code class="eh jp jq jr js b">jeff.balance = 1000.0</code>相同。在这两行之后，我们认为<code class="eh jp jq jr js b">Customer</code>对象已经“初始化”,可以使用了。</p><h2 id="a028" class="lg jw hu bd jx ll lm ln kb lo lp lq kf jc lr ls kj jg lt lu kn jk lv lw kr lx dt translated">小心你的<code class="eh jp jq jr js b">__init__</code></h2><p id="731a" class="pw-post-body-paragraph ir is hu it b iu kt iw ix iy ku ja jb jc kv je jf jg kw ji jj jk kx jm jn jo hn dt translated">在<code class="eh jp jq jr js b">__init__</code>完成之后，调用者可以正确地假设对象已经准备好使用。也就是在<code class="eh jp jq jr js b">jeff = Customer('Jeff Knupp', 1000.0)</code>之后，我们就可以开始在<code class="eh jp jq jr js b">jeff</code>上打<code class="eh jp jq jr js b">deposit</code>和<code class="eh jp jq jr js b">withdraw</code>电话了；<code class="eh jp jq jr js b">jeff</code>是一个<strong class="it hv">完全初始化的</strong>对象。</p><p id="6984" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">想象一下，我们对<code class="eh jp jq jr js b">Customer</code>类的定义略有不同:</p><pre class="ky kz la lb fq lc js ld le aw lf dt"><span id="dfe0" class="lg jw hu js b fv lh li l lj lk"><strong class="js hv">class</strong> <strong class="js hv">Customer</strong>(object):<br/>    <em class="ju">"""A customer of ABC Bank with a checking account. Customers have the</em><br/><em class="ju">    following properties:</em><br/><br/><em class="ju">    Attributes:</em><br/><em class="ju">        name: A string representing the customer's name.</em><br/><em class="ju">        balance: A float tracking the current balance of the customer's account.</em><br/><em class="ju">    """</em><br/><br/>    <strong class="js hv">def</strong> __init__(self, name):<br/>        <em class="ju">"""Return a Customer object whose name is *name*."""</em> <br/>        self.name = name<br/><br/>    <strong class="js hv">def</strong> set_balance(self, balance=0.0):<br/>        <em class="ju">"""Set the customer's starting balance."""</em><br/>        self.balance = balance<br/><br/>    <strong class="js hv">def</strong> withdraw(self, amount):<br/>        <em class="ju">"""Return the balance remaining after withdrawing *amount*</em><br/><em class="ju">        dollars."""</em><br/>        <strong class="js hv">if</strong> amount &gt; self.balance:<br/>            <strong class="js hv">raise</strong> <strong class="js hv">RuntimeError</strong>('Amount greater than available balance.')<br/>        self.balance -= amount<br/>        <strong class="js hv">return</strong> self.balance<br/><br/>    <strong class="js hv">def</strong> deposit(self, amount):<br/>        <em class="ju">"""Return the balance remaining after depositing *amount*</em><br/><em class="ju">        dollars."""</em><br/>        self.balance += amount<br/>        <strong class="js hv">return</strong> self.balance</span></pre><p id="c3cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这可能看起来是一个合理的选择；我们只需要在开始使用实例之前调用<code class="eh jp jq jr js b">set_balance</code>。然而，没有办法将这一点传达给打电话的人。即使我们详尽地记录下来，我们也不能<em class="ju">强迫</em>呼叫者在呼叫<code class="eh jp jq jr js b">jeff.withdraw(100.0)</code>之前呼叫<code class="eh jp jq jr js b">jeff.set_balance(1000.0)</code>。由于在调用<code class="eh jp jq jr js b">jeff.set_balance</code>之前<code class="eh jp jq jr js b">jeff</code>实例甚至<em class="ju">都没有</em>一个balance属性，这意味着对象还没有被“完全”初始化。</p><p id="65f2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">经验法则是，不要在<code class="eh jp jq jr js b">__init__</code>方法之外给引入新的属性，否则你已经给了调用者一个没有完全初始化的对象。当然，也有例外，但这是一个需要牢记的好原则。这是更大的对象一致性概念的一部分:不应该有任何一系列的方法调用会导致对象进入没有意义的状态。</p><p id="e1a3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不变量(比如，“balance应该总是一个非负数”)应该在进入和退出方法时都成立。一个对象不可能仅仅通过调用它的方法就进入无效状态。不言而喻，一个对象也应该在有效状态下启动，这就是为什么在方法中初始化所有东西是很重要的。</p><h1 id="03bf" class="jv jw hu bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dt translated">实例属性和方法</h1><p id="fd91" class="pw-post-body-paragraph ir is hu it b iu kt iw ix iy ku ja jb jc kv je jf jg kw ji jj jk kx jm jn jo hn dt translated">在类中定义的函数称为“方法”。方法可以访问对象实例中包含的所有数据；他们可以访问和修改之前在<code class="eh jp jq jr js b">self</code>上设置的任何内容。因为它们使用了<code class="eh jp jq jr js b">self</code>，所以它们需要一个类的实例才能被使用。因此，它们通常被称为“实例方法”。</p><p id="4b38" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果有“实例方法”，那么肯定也有其他类型的方法，对吗？是的，有，但是这些方法有点深奥。我们将在这里简单介绍一下，但是可以更深入地研究这些主题。</p><h1 id="1d64" class="jv jw hu bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dt translated">静态方法</h1><p id="c093" class="pw-post-body-paragraph ir is hu it b iu kt iw ix iy ku ja jb jc kv je jf jg kw ji jj jk kx jm jn jo hn dt translated"><em class="ju">类属性</em>是在<em class="ju">类级别</em>设置的属性，与<em class="ju">实例级别</em>相对。普通属性是在<code class="eh jp jq jr js b">__init__</code>方法中引入的，但是一个类的一些属性在所有情况下都适用于<em class="ju">所有</em>实例。例如，考虑下面一个<code class="eh jp jq jr js b">Car</code>对象的定义:</p><pre class="ky kz la lb fq lc js ld le aw lf dt"><span id="ae07" class="lg jw hu js b fv lh li l lj lk"><strong class="js hv">class</strong> <strong class="js hv">Car</strong>(object):<br/><br/>    wheels = 4<br/><br/>    <strong class="js hv">def</strong> __init__(self, make, model):<br/>        self.make = make<br/>        self.model = model<br/><br/>mustang = Car('Ford', 'Mustang')<br/><strong class="js hv">print</strong> mustang.wheels<br/><em class="ju"># 4</em><br/><strong class="js hv">print</strong> Car.wheels<br/><em class="ju"># 4</em></span></pre><p id="19fc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个<code class="eh jp jq jr js b">Car</code>总是有四个<code class="eh jp jq jr js b">wheels</code>，不管是<code class="eh jp jq jr js b">make</code>还是<code class="eh jp jq jr js b">model</code>。实例方法可以像访问常规属性一样访问这些属性:通过<code class="eh jp jq jr js b">self</code>(即<code class="eh jp jq jr js b">self.wheels</code>)。</p><p id="1065" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，有一类方法叫做<em class="ju">静态方法</em>，它们不能访问<code class="eh jp jq jr js b">self</code>。就像类属性一样，它们是不需要实例就能工作的方法。因为实例总是通过<code class="eh jp jq jr js b">self</code>被引用，所以静态方法没有<code class="eh jp jq jr js b">self</code>参数。</p><p id="a982" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是<code class="eh jp jq jr js b">Car</code>类的有效静态方法:</p><pre class="ky kz la lb fq lc js ld le aw lf dt"><span id="038e" class="lg jw hu js b fv lh li l lj lk"><strong class="js hv">class</strong> <strong class="js hv">Car</strong>(object):<br/>    ...<br/>    <strong class="js hv">def</strong> make_car_sound():<br/>        <strong class="js hv">print</strong> 'VRooooommmm!'</span></pre><p id="ebee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不管我们有什么样的车，它总是发出同样的声音(至少我这样告诉我十个月大的女儿)。为了明确这个方法不应该接收实例作为第一个参数(即“普通”方法上的<code class="eh jp jq jr js b">self</code>，使用了<code class="eh jp jq jr js b">@staticmethod</code>装饰器，将我们的定义变成:</p><pre class="ky kz la lb fq lc js ld le aw lf dt"><span id="727a" class="lg jw hu js b fv lh li l lj lk"><strong class="js hv">class</strong> <strong class="js hv">Car</strong>(object):<br/>    ...<br/>    @staticmethod<br/>    <strong class="js hv">def</strong> make_car_sound():<br/>        <strong class="js hv">print</strong> 'VRooooommmm!'</span></pre><h1 id="1e78" class="jv jw hu bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dt translated">类方法</h1><p id="289c" class="pw-post-body-paragraph ir is hu it b iu kt iw ix iy ku ja jb jc kv je jf jg kw ji jj jk kx jm jn jo hn dt translated">静态方法的一个变体是<em class="ju">类方法</em>。不是接收<em class="ju">实例</em>作为第一个参数，而是传递给<em class="ju">类</em>。它也是使用装饰器定义的:</p><pre class="ky kz la lb fq lc js ld le aw lf dt"><span id="995d" class="lg jw hu js b fv lh li l lj lk"><strong class="js hv">class</strong> <strong class="js hv">Vehicle</strong>(object):<br/>    ...<br/>    @classmethod<br/>    <strong class="js hv">def</strong> is_motorcycle(cls):<br/>        <strong class="js hv">return</strong> cls.wheels == 2</span></pre><p id="6557" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">类方法现在可能没有多大意义，但那是因为它们在我们的下一个主题中使用得最多:<em class="ju">继承</em>。</p><h1 id="0933" class="jv jw hu bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dt translated">遗产</h1><p id="e69c" class="pw-post-body-paragraph ir is hu it b iu kt iw ix iy ku ja jb jc kv je jf jg kw ji jj jk kx jm jn jo hn dt translated">虽然面向对象编程作为建模工具是有用的，但是当引入<em class="ju">继承</em>的概念时，它才真正变得强大。<em class="ju">继承</em>是一个“子”类<em class="ju">派生</em>一个“父”类的数据和行为的过程。这里举个例子肯定能帮到我们。</p><p id="8544" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">想象一下我们经营一家汽车经销商。我们出售各种类型的车辆，从摩托车到卡车。我们通过价格在竞争中脱颖而出。具体来说，我们如何确定一辆车的价格:5000美元x一辆车的车轮数量。我们也喜欢回购我们的汽车。我们提供统一费率——车辆行驶里程的10%。对于卡车，费率为10，000美元。对于汽车，8000美元。对于摩托车，4000美元。</p><p id="a450" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们想用面向对象的技术为我们的经销商创建一个销售系统，我们该怎么做呢？对象会是什么？我们可能有一个<code class="eh jp jq jr js b">Sale</code>类、一个<code class="eh jp jq jr js b">Customer</code>类、一个<code class="eh jp jq jr js b">Inventory</code>类等等，但是我们几乎肯定会有一个<code class="eh jp jq jr js b">Car</code>、<code class="eh jp jq jr js b">Truck</code>和<code class="eh jp jq jr js b">Motorcycle</code>类。</p><p id="a236" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些类看起来像什么？利用我们所学的，这里有一个<code class="eh jp jq jr js b">Car</code>类的可能实现:</p><pre class="ky kz la lb fq lc js ld le aw lf dt"><span id="8dc0" class="lg jw hu js b fv lh li l lj lk"><strong class="js hv">class</strong> <strong class="js hv">Car</strong>(object):<br/>    <em class="ju">"""A car for sale by Jeffco Car Dealership.</em><br/><br/><em class="ju">    Attributes:</em><br/><em class="ju">        wheels: An integer representing the number of wheels the car has.</em><br/><em class="ju">        miles: The integral number of miles driven on the car.</em><br/><em class="ju">        make: The make of the car as a string.</em><br/><em class="ju">        model: The model of the car as a string.</em><br/><em class="ju">        year: The integral year the car was built.</em><br/><em class="ju">        sold_on: The date the vehicle was sold.</em><br/><em class="ju">    """</em><br/><br/>    <strong class="js hv">def</strong> __init__(self, wheels, miles, make, model, year, sold_on):<br/>        <em class="ju">"""Return a new Car object."""</em><br/>        self.wheels = wheels<br/>        self.miles = miles<br/>        self.make = make<br/>        self.model = model<br/>        self.year = year<br/>        self.sold_on = sold_on<br/><br/>    <strong class="js hv">def</strong> sale_price(self):<br/>        <em class="ju">"""Return the sale price for this car as a float amount."""</em><br/>        <strong class="js hv">if</strong> self.sold_on <strong class="js hv">is</strong> <strong class="js hv">not</strong> None:<br/>            <strong class="js hv">return</strong> 0.0  <em class="ju"># Already sold</em><br/>        <strong class="js hv">return</strong> 5000.0 * self.wheels<br/><br/>    <strong class="js hv">def</strong> purchase_price(self):<br/>        <em class="ju">"""Return the price for which we would pay to purchase the car."""</em><br/>        <strong class="js hv">if</strong> self.sold_on <strong class="js hv">is</strong> None:<br/>            <strong class="js hv">return</strong> 0.0  <em class="ju"># Not yet sold</em><br/>        <strong class="js hv">return</strong> 8000 - (.10 * self.miles)<br/><br/>    ...</span></pre><p id="f7de" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好吧，这看起来很合理。当然，我们很可能在这个类中有许多其他的方法，但是我已经展示了我们特别感兴趣的两个:<code class="eh jp jq jr js b">sale_price</code>和<code class="eh jp jq jr js b">purchase_price</code>。我们稍后会看到为什么这些很重要。</p><p id="e193" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们已经有了<code class="eh jp jq jr js b">Car</code>类，也许我们应该创建一个<code class="eh jp jq jr js b">Truck</code>类？让我们遵循我们为car所做的相同模式:</p><pre class="ky kz la lb fq lc js ld le aw lf dt"><span id="73c6" class="lg jw hu js b fv lh li l lj lk"><strong class="js hv">class</strong> <strong class="js hv">Truck</strong>(object):<br/>    <em class="ju">"""A truck for sale by Jeffco Car Dealership.</em><br/><br/><em class="ju">    Attributes:</em><br/><em class="ju">        wheels: An integer representing the number of wheels the truck has.</em><br/><em class="ju">        miles: The integral number of miles driven on the truck.</em><br/><em class="ju">        make: The make of the truck as a string.</em><br/><em class="ju">        model: The model of the truck as a string.</em><br/><em class="ju">        year: The integral year the truck was built.</em><br/><em class="ju">        sold_on: The date the vehicle was sold.</em><br/><em class="ju">    """</em><br/><br/>    <strong class="js hv">def</strong> __init__(self, wheels, miles, make, model, year, sold_on):<br/>        <em class="ju">"""Return a new Truck object."""</em><br/>        self.wheels = wheels<br/>        self.miles = miles<br/>        self.make = make<br/>        self.model = model<br/>        self.year = year<br/>        self.sold_on = sold_on<br/><br/>    <strong class="js hv">def</strong> sale_price(self):<br/>        <em class="ju">"""Return the sale price for this truck as a float amount."""</em><br/>        <strong class="js hv">if</strong> self.sold_on <strong class="js hv">is</strong> <strong class="js hv">not</strong> None:<br/>            <strong class="js hv">return</strong> 0.0  <em class="ju"># Already sold</em><br/>        <strong class="js hv">return</strong> 5000.0 * self.wheels<br/><br/>    <strong class="js hv">def</strong> purchase_price(self):<br/>        <em class="ju">"""Return the price for which we would pay to purchase the truck."""</em><br/>        <strong class="js hv">if</strong> self.sold_on <strong class="js hv">is</strong> None:<br/>            <strong class="js hv">return</strong> 0.0  <em class="ju"># Not yet sold</em><br/>        <strong class="js hv">return</strong> 10000 - (.10 * self.miles)<br/><br/>    ...</span></pre><p id="6600" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">哇哦。那就是<em class="ju">几乎和</em>一模一样的汽车类。编程最重要的规则之一(一般来说，不仅仅是在处理对象时)是“干”或“T21”on t<strong class="it hv">R</strong>EPE at<strong class="it hv">Y</strong>yourself。我们肯定在这里重复了一遍。事实上，<code class="eh jp jq jr js b">Car</code>和<code class="eh jp jq jr js b">Truck</code>类的区别仅仅在于<em class="ju">一个字符</em>(除了注释)。</p><p id="b97a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么是什么原因呢？我们哪里出错了？我们的主要问题是我们直接进入了具体的领域:<code class="eh jp jq jr js b">Car</code> s和<code class="eh jp jq jr js b">Truck</code> s是真实的东西，作为类具有直观意义的有形对象。然而，它们共享如此多的共同数据和功能，似乎必须有一个我们可以在这里引入的抽象。的确有:s的概念。</p><h1 id="11c0" class="jv jw hu bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dt translated">抽象类</h1><p id="6a0f" class="pw-post-body-paragraph ir is hu it b iu kt iw ix iy ku ja jb jc kv je jf jg kw ji jj jk kx jm jn jo hn dt translated">一个<code class="eh jp jq jr js b">Vehicle</code>不是真实世界的物体。相反，它是一些现实世界的物体(如汽车、卡车和摩托车)体现的一个概念。我们希望利用这样一个事实，即这些对象中的每一个都可以被认为是一种消除重复代码的工具。我们可以通过创建一个<code class="eh jp jq jr js b">Vehicle</code>类来实现:</p><pre class="ky kz la lb fq lc js ld le aw lf dt"><span id="7952" class="lg jw hu js b fv lh li l lj lk">class Vehicle(object):<br/>    """A vehicle for sale by Jeffco Car Dealership.<br/><br/>    Attributes:<br/>        wheels: An integer representing the number of wheels the vehicle has.<br/>        miles: The integral number of miles driven on the vehicle.<br/>        make: The make of the vehicle as a string.<br/>        model: The model of the vehicle as a string.<br/>        year: The integral year the vehicle was built.<br/>        sold_on: The date the vehicle was sold.<br/>    """<br/><br/>    base_sale_price = 0<br/><br/>    def __init__(self, wheels, miles, make, model, year, sold_on):<br/>        """Return a new Vehicle object."""<br/>        self.wheels = wheels<br/>        self.miles = miles<br/>        self.make = make<br/>        self.model = model<br/>        self.year = year<br/>        self.sold_on = sold_on<br/><br/><br/>    def sale_price(self):<br/>        """Return the sale price for this vehicle as a float amount."""<br/>        <strong class="js hv">if</strong> self.sold_on is not None:<br/>            <strong class="js hv">return</strong> 0.0  # Already sold<br/>        <strong class="js hv">return</strong> 5000.0 * self.wheels<br/><br/>    def purchase_price(self):<br/>        """Return the price for which we would pay to purchase the vehicle."""<br/>        <strong class="js hv">if</strong> self.sold_on is None:<br/>            <strong class="js hv">return</strong> 0.0  # Not yet sold<br/>        <strong class="js hv">return</strong> self.base_sale_price - (.10 * self.miles)</span></pre><p id="0464" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们可以通过替换<code class="eh jp jq jr js b">class Car(object)</code>行中的<code class="eh jp jq jr js b">object</code>来使<code class="eh jp jq jr js b">Car</code>和<code class="eh jp jq jr js b">Truck</code>类<em class="ju">继承<code class="eh jp jq jr js b">Vehicle</code>类中的</em>。括号中的类是继承而来的类(<code class="eh jp jq jr js b">object</code>本质上是“没有继承”的意思)。我们稍后将讨论我们为什么要写这个)。</p><p id="1b13" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们现在可以用一种非常简单的方式定义<code class="eh jp jq jr js b">Car</code>和<code class="eh jp jq jr js b">Truck</code>:</p><pre class="ky kz la lb fq lc js ld le aw lf dt"><span id="5116" class="lg jw hu js b fv lh li l lj lk"><strong class="js hv">class</strong> <strong class="js hv">Car</strong>(Vehicle):<br/><br/>    <strong class="js hv">def</strong> __init__(self, wheels, miles, make, model, year, sold_on):<br/>        <em class="ju">"""Return a new Car object."""</em><br/>        self.wheels = wheels<br/>        self.miles = miles<br/>        self.make = make<br/>        self.model = model<br/>        self.year = year<br/>        self.sold_on = sold_on<br/>        self.base_sale_price = 8000<br/><br/><br/><strong class="js hv">class</strong> <strong class="js hv">Truck</strong>(Vehicle):<br/><br/>    <strong class="js hv">def</strong> __init__(self, wheels, miles, make, model, year, sold_on):<br/>        <em class="ju">"""Return a new Truck object."""</em><br/>        self.wheels = wheels<br/>        self.miles = miles<br/>        self.make = make<br/>        self.model = model<br/>        self.year = year<br/>        self.sold_on = sold_on<br/>        self.base_sale_price = 10000</span></pre><p id="03da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是可行的，但是有一些问题。首先，我们仍然在重复大量的代码。我们最终想要摆脱所有的重复。第二，更有问题的是，我们已经引入了<code class="eh jp jq jr js b">Vehicle</code>类，但是我们真的应该允许人们创建<code class="eh jp jq jr js b">Vehicle</code>对象吗(相对于<code class="eh jp jq jr js b">Car</code>或<code class="eh jp jq jr js b">Truck</code> s)？一个<code class="eh jp jq jr js b">Vehicle</code>只是一个概念，不是一个真实的东西，那么下面说的是什么意思:</p><pre class="ky kz la lb fq lc js ld le aw lf dt"><span id="6d8f" class="lg jw hu js b fv lh li l lj lk">v = Vehicle(4, 0, 'Honda', 'Accord', 2014, None)<br/>print v.purchase_price()</span></pre><p id="cc1e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个<code class="eh jp jq jr js b">Vehicle</code>没有一个<code class="eh jp jq jr js b">base_sale_price</code>，只有像<code class="eh jp jq jr js b">Car</code>和<code class="eh jp jq jr js b">Truck</code>这样的单个<em class="ju">子</em>类有。问题是<code class="eh jp jq jr js b">Vehicle</code>实际上应该是一个<em class="ju">抽象基类</em>。抽象基类是只能从其继承的类；您不能创建ABC的<em class="ju">实例</em>。这意味着，如果<code class="eh jp jq jr js b">Vehicle</code>是一个ABC，以下是非法的:</p><pre class="ky kz la lb fq lc js ld le aw lf dt"><span id="5e96" class="lg jw hu js b fv lh li l lj lk">v = Vehicle(4, 0, 'Honda', 'Accord', 2014, None)</span></pre><p id="7b9c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不允许这样做是有意义的，因为我们从来没有打算让车辆被直接使用。我们只是想用它来抽象出一些常见的数据和行为。那么我们如何让一个类成为ABC呢？简单！<code class="eh jp jq jr js b">abc</code>模块包含一个名为<code class="eh jp jq jr js b">ABCMeta</code>的元类(元类有点超出了本文的范围)。将一个类的元类设置为<code class="eh jp jq jr js b">ABCMeta</code>并使其方法之一<em class="ju">为虚拟的</em>会使其成为一个ABC。虚拟方法是ABC说必须存在于子类中的方法，但不一定要实际实现。例如，车辆类别可以定义如下:</p><pre class="ky kz la lb fq lc js ld le aw lf dt"><span id="e303" class="lg jw hu js b fv lh li l lj lk"><strong class="js hv">from</strong> <strong class="js hv">abc</strong> <strong class="js hv">import</strong> ABCMeta, abstractmethod<br/><br/><strong class="js hv">class</strong> <strong class="js hv">Vehicle</strong>(object):<br/>    <em class="ju">"""A vehicle for sale by Jeffco Car Dealership.</em><br/><br/><br/><em class="ju">    Attributes:</em><br/><em class="ju">        wheels: An integer representing the number of wheels the vehicle has.</em><br/><em class="ju">        miles: The integral number of miles driven on the vehicle.</em><br/><em class="ju">        make: The make of the vehicle as a string.</em><br/><em class="ju">        model: The model of the vehicle as a string.</em><br/><em class="ju">        year: The integral year the vehicle was built.</em><br/><em class="ju">        sold_on: The date the vehicle was sold.</em><br/><em class="ju">    """</em><br/><br/>    __metaclass__ = ABCMeta<br/><br/>    base_sale_price = 0<br/><br/>    <strong class="js hv">def</strong> sale_price(self):<br/>        <em class="ju">"""Return the sale price for this vehicle as a float amount."""</em><br/>        <strong class="js hv">if</strong> self.sold_on <strong class="js hv">is</strong> <strong class="js hv">not</strong> None:<br/>            <strong class="js hv">return</strong> 0.0  <em class="ju"># Already sold</em><br/>        <strong class="js hv">return</strong> 5000.0 * self.wheels<br/><br/>    <strong class="js hv">def</strong> purchase_price(self):<br/>        <em class="ju">"""Return the price for which we would pay to purchase the vehicle."""</em><br/>        <strong class="js hv">if</strong> self.sold_on <strong class="js hv">is</strong> None:<br/>            <strong class="js hv">return</strong> 0.0  <em class="ju"># Not yet sold</em><br/>        <strong class="js hv">return</strong> self.base_sale_price - (.10 * self.miles)<br/><br/>    @abstractmethod<br/>    <strong class="js hv">def</strong> vehicle_type():<br/>        <em class="ju">""""Return a string representing the type of vehicle this is."""</em><br/>        <strong class="js hv">pass</strong></span></pre><p id="9496" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，由于<code class="eh jp jq jr js b">vehicle_type</code>是一个<code class="eh jp jq jr js b">abstractmethod</code>，我们不能直接创建一个<code class="eh jp jq jr js b">Vehicle</code>的实例。只要<code class="eh jp jq jr js b">Car</code>和<code class="eh jp jq jr js b">Truck</code>继承<code class="eh jp jq jr js b">Vehicle</code> <strong class="it hv">和</strong>定义<code class="eh jp jq jr js b">vehicle_type</code>，我们就可以实例化那些类了。</p><p id="d02f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">回到我们的<code class="eh jp jq jr js b">Car</code>和<code class="eh jp jq jr js b">Truck</code>类中的重复，让我们看看是否可以通过提升基类的公共功能来消除它，<code class="eh jp jq jr js b">Vehicle</code>:</p><pre class="ky kz la lb fq lc js ld le aw lf dt"><span id="7929" class="lg jw hu js b fv lh li l lj lk"><strong class="js hv">from</strong> <strong class="js hv">abc</strong> <strong class="js hv">import</strong> ABCMeta, abstractmethod<br/><strong class="js hv">class</strong> <strong class="js hv">Vehicle</strong>(object):<br/>    <em class="ju">"""A vehicle for sale by Jeffco Car Dealership.</em><br/><br/><br/><em class="ju">    Attributes:</em><br/><em class="ju">        wheels: An integer representing the number of wheels the vehicle has.</em><br/><em class="ju">        miles: The integral number of miles driven on the vehicle.</em><br/><em class="ju">        make: The make of the vehicle as a string.</em><br/><em class="ju">        model: The model of the vehicle as a string.</em><br/><em class="ju">        year: The integral year the vehicle was built.</em><br/><em class="ju">        sold_on: The date the vehicle was sold.</em><br/><em class="ju">    """</em><br/><br/>    __metaclass__ = ABCMeta<br/><br/>    base_sale_price = 0<br/>    wheels = 0<br/><br/>    <strong class="js hv">def</strong> __init__(self, miles, make, model, year, sold_on):<br/>        self.miles = miles<br/>        self.make = make<br/>        self.model = model<br/>        self.year = year<br/>        self.sold_on = sold_on<br/><br/>    <strong class="js hv">def</strong> sale_price(self):<br/>        <em class="ju">"""Return the sale price for this vehicle as a float amount."""</em><br/>        <strong class="js hv">if</strong> self.sold_on <strong class="js hv">is</strong> <strong class="js hv">not</strong> None:<br/>            <strong class="js hv">return</strong> 0.0  <em class="ju"># Already sold</em><br/>        <strong class="js hv">return</strong> 5000.0 * self.wheels<br/><br/>    <strong class="js hv">def</strong> purchase_price(self):<br/>        <em class="ju">"""Return the price for which we would pay to purchase the vehicle."""</em><br/>        <strong class="js hv">if</strong> self.sold_on <strong class="js hv">is</strong> None:<br/>            <strong class="js hv">return</strong> 0.0  <em class="ju"># Not yet sold</em><br/>        <strong class="js hv">return</strong> self.base_sale_price - (.10 * self.miles)<br/><br/>    @abstractmethod<br/>    <strong class="js hv">def</strong> vehicle_type(self):<br/>        <em class="ju">""""Return a string representing the type of vehicle this is."""</em><br/>        <strong class="js hv">pass</strong></span></pre><p id="8bea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在<code class="eh jp jq jr js b">Car</code>和<code class="eh jp jq jr js b">Truck</code>类变成了:</p><pre class="ky kz la lb fq lc js ld le aw lf dt"><span id="9224" class="lg jw hu js b fv lh li l lj lk"><strong class="js hv">class</strong> <strong class="js hv">Car</strong>(Vehicle):<br/>    <em class="ju">"""A car for sale by Jeffco Car Dealership."""</em><br/><br/>    base_sale_price = 8000<br/>    wheels = 4<br/><br/>    <strong class="js hv">def</strong> vehicle_type(self):<br/>        <em class="ju">""""Return a string representing the type of vehicle this is."""</em><br/>        <strong class="js hv">return</strong> 'car'<br/><br/><strong class="js hv">class</strong> <strong class="js hv">Truck</strong>(Vehicle):<br/>    <em class="ju">"""A truck for sale by Jeffco Car Dealership."""</em><br/><br/>    base_sale_price = 10000<br/>    wheels = 4<br/><br/>    <strong class="js hv">def</strong> vehicle_type(self):<br/>        <em class="ju">""""Return a string representing the type of vehicle this is."""</em><br/>        <strong class="js hv">return</strong> 'truck'</span></pre><p id="527a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这完全符合我们的直觉:就我们的系统而言，轿车和卡车之间的唯一区别是基本销售价格。定义一个<code class="eh jp jq jr js b">Motorcycle</code>类也同样简单:</p><pre class="ky kz la lb fq lc js ld le aw lf dt"><span id="18c5" class="lg jw hu js b fv lh li l lj lk"><strong class="js hv">class</strong> <strong class="js hv">Motorcycle</strong>(Vehicle):<br/>    <em class="ju">"""A motorcycle for sale by Jeffco Car Dealership."""</em><br/><br/>    base_sale_price = 4000<br/>    wheels = 2<br/><br/>    <strong class="js hv">def</strong> vehicle_type(self):<br/>        <em class="ju">""""Return a string representing the type of vehicle this is."""</em><br/>        <strong class="js hv">return</strong> 'motorcycle'</span></pre><h1 id="68fc" class="jv jw hu bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dt translated">继承和长期服务协议</h1><p id="2047" class="pw-post-body-paragraph ir is hu it b iu kt iw ix iy ku ja jb jc kv je jf jg kw ji jj jk kx jm jn jo hn dt translated">尽管看起来我们使用继承来消除重复，但我们真正做的只是提供适当的抽象层次。而<em class="ju">抽象</em>是理解继承的关键。我们已经看到了使用继承的一个副作用是我们减少了重复的代码，但是从调用者的角度来看呢？使用继承如何改变代码？</p><p id="ae0b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">事实证明，相当多。假设我们有两个类，<code class="eh jp jq jr js b">Dog</code>和<code class="eh jp jq jr js b">Person</code>，我们想要编写一个函数，它接受任一类型的对象，并打印出所讨论的实例是否能说话(狗不能，人可以)。我们可以编写如下代码:</p><pre class="ky kz la lb fq lc js ld le aw lf dt"><span id="9245" class="lg jw hu js b fv lh li l lj lk"><strong class="js hv">def</strong> can_speak(animal):<br/>    <strong class="js hv">if</strong> isinstance(animal, Person):<br/>        <strong class="js hv">return</strong> True<br/>    <strong class="js hv">elif</strong> isinstance(animal, Dog):<br/>        <strong class="js hv">return</strong> False<br/>    <strong class="js hv">else</strong>:<br/>        <strong class="js hv">raise</strong> <strong class="js hv">RuntimeError</strong>('Unknown animal!')</span></pre><p id="135a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们只有两种动物时，这是可行的，但是如果我们有二十种，或者两百种动物呢？这个链条会变得很长。</p><p id="49f5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里的关键见解是<code class="eh jp jq jr js b">can_speak</code>不应该关心它在处理什么类型的动物，动物类本身应该告诉<em class="ju">我们</em>它是否会说话。通过引入一个定义了<code class="eh jp jq jr js b">can_speak</code>的公共基类<code class="eh jp jq jr js b">Animal</code>，我们减轻了它的类型检查负担。现在，只要它知道传入的是一个<code class="eh jp jq jr js b">Animal</code>,确定它是否能说话就很简单了:</p><pre class="ky kz la lb fq lc js ld le aw lf dt"><span id="a9c7" class="lg jw hu js b fv lh li l lj lk"><strong class="js hv">def</strong> can_speak(animal):<br/>    <strong class="js hv">return</strong> animal.can_speak()</span></pre><p id="7a17" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是因为<code class="eh jp jq jr js b">Person</code>和<code class="eh jp jq jr js b">Dog</code>(以及我们从<code class="eh jp jq jr js b">Animal</code>派生的任何其他类)遵循<em class="ju">利斯科夫替换原则</em>。这表明我们应该能够在任何需要父类(<code class="eh jp jq jr js b">Animal</code>)的地方使用子类(比如<code class="eh jp jq jr js b">Person</code>或<code class="eh jp jq jr js b">Dog</code>),一切都会很好。这听起来很简单，但是它是我们将在以后的文章中讨论的强大概念的基础:<em class="ju">接口</em>。</p><h1 id="2dcb" class="jv jw hu bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dt translated">摘要</h1><p id="2502" class="pw-post-body-paragraph ir is hu it b iu kt iw ix iy ku ja jb jc kv je jf jg kw ji jj jk kx jm jn jo hn dt translated">希望您已经学习了很多关于Python类是什么、为什么它们有用以及如何使用它们的知识。类和面向对象编程的主题非常深奥。事实上，它们触及了计算机科学的核心。这篇文章并不是对类的详尽研究，也不应该是你唯一的参考。网上有数以千计的关于OOP和类的解释，所以如果你没有找到一个合适的，搜索一下肯定会发现一个更适合你的。</p><p id="8be0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一如既往，欢迎评论中的更正和争论。尽量保持文明。</p><p id="9aa7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Jeff Knupp于2017年3月27日发布</p></div><div class="ab cl ly lz hc ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hn ho hp hq hr"><p id="2d05" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="ju">原载于2017年3月27日jeffknupp.com</em><a class="ae jt" href="https://jeffknupp.com/blog/2017/03/27/improve-your-python-python-classes-and-object-oriented-programming/" rel="noopener ugc nofollow" target="_blank"><em class="ju"/></a><em class="ju">。</em></p><blockquote class="mf mg mh"><p id="a033" class="ir is ju it b iu iv iw ix iy iz ja jb mi jd je jf mj jh ji jj mk jl jm jn jo hn dt translated"><a class="ae jt" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是T21家庭的一员。我们现在<a class="ae jt" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jt" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is ju it b iu iv iw ix iy iz ja jb mi jd je jf mj jh ji jj mk jl jm jn jo hn dt translated">要了解更多信息，请阅读我们的“关于”页面、<a class="ae jt" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">喜欢/在脸书上给我们发消息</a>，或者简单地发送<a class="ae jt" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is ju it b iu iv iw ix iy iz ja jb mi jd je jf mj jh ji jj mk jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jt" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jt" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ky kz la lb fq ml"><div class="bz el l di"><div class="mm mn l"/></div></figure></div></div>    
</body>
</html>