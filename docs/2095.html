<html>
<head>
<title>Tagged Unions, React, and Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">标记的联合、反应和还原</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/tagged-unions-react-and-redux-55e262e4d0ea?source=collection_archive---------15-----------------------#2017-01-05">https://medium.com/hackernoon/tagged-unions-react-and-redux-55e262e4d0ea?source=collection_archive---------15-----------------------#2017-01-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="93b5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于种种原因，Typescript 和Flow非常酷。我想在将它们与<a class="ae jp" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank"> React </a>一起使用时强调一个这样的例子。具体来说，我们将看到标记的联合如何通过redux连接的组件为我们提供更好的文档和保证。本文将假设对类型有一些基本的了解。</p><h1 id="346b" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">需求</h1><p id="7c76" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">让我们从构建一个简单的聊天应用程序开始。它将获取登录的用户、聊天的用户列表，并将其全部呈现在屏幕上。没什么特别令人兴奋的，但是这个应用有一些有趣的状态。例如，它可以是:脱机状态，我们看不到其他用户；加载状态，我们将看到一些加载指示器；加载状态，我们将看到自己和其他用户在一起。</p><h1 id="54c9" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">连接我们的组件</h1><p id="325c" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">首先，这里有一个快速而简单的解决方案，将我们的组件连接到我们的redux存储。我们还不想写视图或连接函数，我们将把注意力集中在作为我们的视图的道具传递的<code class="eh kt ku kv kw b">mapStateToProps</code>函数的返回值上。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="d933" class="lf jr hu kw b fv lg lh l li lj">type MapStateToPropsResult<br/>    = { loading?: boolean<br/>      , disconnected?: boolean<br/>      , users?: User[]<br/>      , activeUser?: User<br/>      }</span></pre><p id="3a9e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">很简单:一个具有所有可选属性的对象。这是完全可用的；我们可以继续我们的快乐之路，类型系统会很高兴地让我们在使用它们之前检查每个属性是否存在。</p><p id="44f4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你觉得有什么问题吗？业务需求在这些属性之间有明确的关系，但是通过查看这些代码无法推断出任何关系。当屏幕加载时，我们有<code class="eh kt ku kv kw b">users</code>或<code class="eh kt ku kv kw b">activeUser</code>是没有意义的。此外，如果我们可以在应用程序知道它离线时与用户交谈，那就没有意义了。如果我们简单地让一切都是可选的，那么所有这些微妙之处都会消失。</p><p id="f233" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">其次，我们错过了一个宝贵的机会<em class="lk">使用类型系统作为工具</em>。被动地处理类型、编写代码太容易了，编译器只是一个安全网，确保你不犯任何打字错误。如果我们积极地思考类型在我们的系统中是如何工作的，我们可以让编译器引导我们找到正确的解决方案。</p><p id="9341" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">记住这一点，让我们修改我们的类型签名。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="b1d2" class="lf jr hu kw b fv lg lh l li lj">type MapStateToPropsResult<br/>    = { uiState: 'loading' }<br/>    | { uiState: 'disconnected', activeUser: User }<br/>    | { uiState: 'loaded', activeUser: User, users: User[] }</span></pre><p id="043b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将所有可选属性的单个对象拆分成三个具有所有必需属性的对象的并集。现在，当您查看这个类型时，您可以很快看到属性之间的关系以及UI处于什么状态。现在很清楚，当应用程序加载时，我们将无法访问<code class="eh kt ku kv kw b">user</code>或<code class="eh kt ku kv kw b">activeUser</code>。同样，当我们断开连接时，我们也无法访问<code class="eh kt ku kv kw b">users</code>。</p><p id="6b39" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我们可以利用这种类型让编译器指导我们编写符合我们业务逻辑的代码！</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="3fbc" class="lf jr hu kw b fv lg lh l li lj">@connect((state, props): MapStateToPropsResult =&gt; {</span><span id="7ed8" class="lf jr hu kw b fv ll lh l li lj">})<br/>class UserList extends React.Component<br/>// ...</span></pre><p id="376b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们已经清除了我们的类和<code class="eh kt ku kv kw b">mapStateToProps</code>函数，并告诉编译器这个函数将返回我们刚刚定义的类型。编译器马上发现我们没有返回联合类型的值，它将开始引导我们纠正代码。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="f5b6" class="lf jr hu kw b fv lg lh l li lj">@connect((state, props): MapStateToPropsResult =&gt; {<br/>    const activeUser = selectActiveUser(state) // User | undefined<br/>    const users = selectOtherUsers(state) // User[] | undefined</span><span id="f1b8" class="lf jr hu kw b fv ll lh l li lj">    if (activeUser) {<br/>        return { uiState: 'loaded', activeUser, users } // ERROR<br/>    }<br/>})<br/>class UserList extends React.Component<br/>// ...</span></pre><p id="dac4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">举个例子，也许我们已经获取完了<code class="eh kt ku kv kw b">activeUser</code>的数据，但是我们仍然在等待<code class="eh kt ku kv kw b">users</code>从服务器返回。由于<code class="eh kt ku kv kw b">loaded</code>中需要<code class="eh kt ku kv kw b">users</code>和<code class="eh kt ku kv kw b">activeUser</code>，这种类型将迫使我们转而呈现一种<code class="eh kt ku kv kw b">loading</code>状态。</p><p id="d916" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过使所有的属性成为必需的类型，我们告诉编译器<em class="lk">强制</em>我们处理加载状态。</p><h1 id="6388" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">景色</h1><p id="c983" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">从视图的角度来看，这有什么好处呢？首先，现在我们将无法访问联盟内的属性，直到我们弄清楚我们处于什么状态。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="b5fa" class="lf jr hu kw b fv lg lh l li lj">class UserList extends React.Component {<br/>    render() {<br/>        const user = this.props.activeUser // Error!<br/>    }<br/>}</span></pre><p id="5ac3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">比如上面的例子，类型系统不知道我们是否是<code class="eh kt ku kv kw b">loading</code>等，因此不能保证<code class="eh kt ku kv kw b">activeUser</code>存在于我们的<code class="eh kt ku kv kw b">props</code>上。那么真实的例子会是什么样的呢？</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="e906" class="lf jr hu kw b fv lg lh l li lj">class UserList extends React.Component {<br/>    renderLoading() { /* ... */ }<br/>    renderDisconnected(activeUser) { /* ... */ }<br/>    renderLoaded(activeUser, users) { /* ... */ }</span><span id="8d3a" class="lf jr hu kw b fv ll lh l li lj">    render() {<br/>        const { uiState } = this.props<br/>        if (uiState === 'loading')<br/>            return this.renderLoading()</span><span id="ea5d" class="lf jr hu kw b fv ll lh l li lj">        const { activeUser } = this.props<br/>        if (uiState === 'disconnected')<br/>            return this.renderDisconnected(activeUser)</span><span id="51ec" class="lf jr hu kw b fv ll lh l li lj">        const { users } = this.props<br/>        if (uiState === 'loaded')<br/>            return this.renderLoaded(activeUser, users)<br/>    }<br/>}</span></pre><p id="c734" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这只是我们接近视图逻辑的一种方式。有趣的是，当我们缩小联盟能做什么和不能做什么的范围时，我们会看到更多的支持。在第一个条件之后，我们检查类型系统是否可以推断出剩余的状态都包含<code class="eh kt ku kv kw b">activeUser</code>，因此让我们通过props来访问它。</p><p id="8476" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一个有趣的方面是，如果我们在渲染函数中遗漏了案例，它可以通知我们。也许以后我们会在我们的联合中添加另一个案例，<code class="eh kt ku kv kw b">away,</code>，并且它的呈现略有不同。类型系统将会发现这个变化，并告诉我们渲染函数并不总是返回<code class="eh kt ku kv kw b">JSX</code>(假设我们输入了渲染函数的返回值)。</p><h1 id="6698" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">最后的想法</h1><p id="c4e6" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">如果到目前为止你一直坚持和我在一起，你可能会说我对此很感兴趣。动态语言的美妙之处有很多很多。然而，来到类型化语言的世界，有全新的表达能力领域正等待开发。</p><p id="ae36" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我知道有句谚语“工作总是会填满所有可用的时间。”对我来说，就是“如果有更懒的方法，我还是不会去做，因为这可能需要太多的努力。”任何能让别人强迫我做好工作的机会都是巨大的胜利。在这种情况下，我可以(故意)让一台冷酷无情、无所不能的计算机强迫我正确地完成我的工作。</p><p id="d8c6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">说了这么多，做了这么多，为了子孙后代，这里有一些要点:</p><ul class=""><li id="e4e2" class="lm ln hu it b iu iv iy iz jc lo jg lp jk lq jo lr ls lt lu dt translated">联合类型在原始数据之外很有用。将它们用于从connect或props返回到组件中的值。真的，他们真的真的很棒。</li><li id="5011" class="lm ln hu it b iu lv iy lw jc lx jg ly jk lz jo lr ls lt lu dt translated">如果你看到多种选择开始渗入你的类型，考虑把它分解成一个没有选择的联合。</li><li id="88fe" class="lm ln hu it b iu lv iy lw jc lx jg ly jk lz jo lr ls lt lu dt translated">首先考虑你的类型。如果你预先告诉编译器函数的形状和结果，这将有助于你写出正确的代码。</li><li id="6a54" class="lm ln hu it b iu lv iy lw jc lx jg ly jk lz jo lr ls lt lu dt translated">我真的很喜欢阅读亚龙·明斯基的<a class="ae jp" href="https://blogs.janestreet.com/effective-ml-revisited/" rel="noopener ugc nofollow" target="_blank">这首曲子</a>、T2的这首曲子和T4的这首曲子。它们都处理结构化类型，使不应该发生的状态不发生。它们都非常有启发性，并且都适用于不同的语言。</li><li id="9042" class="lm ln hu it b iu lv iy lw jc lx jg ly jk lz jo lr ls lt lu dt translated">最后，类型给了我们一个在编译时嵌入和执行业务逻辑的独特机会。为了他们将来提供的安全性和文档，添加一些字符确实是值得的。</li></ul><blockquote class="ma mb mc"><p id="cbad" class="ir is lk it b iu iv iw ix iy iz ja jb md jd je jf me jh ji jj mf jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is lk it b iu iv iw ix iy iz ja jb md jd je jf me jh ji jj mf jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上给我们点赞/发消息</a>，或者简单地说，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is lk it b iu iv iw ix iy iz ja jb md jd je jf me jh ji jj mf jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kx ky kz la fq mg"><div class="bz el l di"><div class="mh mi l"/></div></figure></div></div>    
</body>
</html>