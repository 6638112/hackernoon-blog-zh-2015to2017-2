<html>
<head>
<title>Grokking Diesel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">裂化柴油</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/grokking-diesel-652cb8886a63?source=collection_archive---------3-----------------------#2017-08-01">https://medium.com/hackernoon/grokking-diesel-652cb8886a63?source=collection_archive---------3-----------------------#2017-08-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="6852" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Diesel ( <a class="ae jp" href="http://diesel.rs" rel="noopener ugc nofollow" target="_blank"> http://diesel.rs </a>)是用Rust编写的ORM(对象关系映射器)和查询生成器。它支持Postgresql、Mysql和SQLite。它利用Rust的自定义派生功能来生成您需要的所有代码，以便在与数据库交互时获得Rust类型系统的所有功能。这意味着您获得了代码的编译时验证，从而消除了可能的运行时错误。</p><p id="e705" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Diesel的功能非常强大，但是仅仅按照例子来做可能还是会让你挠头，问一些问题，比如“这些类型是从哪里来的？”、“我应该在这里添加什么”、“这是如何工作的？”。本文旨在从一个中级Rust开发人员的角度，对这个主题进行一点阐释。</p><p id="3a51" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有许多主题，这篇文章将不会涵盖，但希望您将能够“grok”足够的柴油，以便其余的变得显而易见，并且您理解它是如何工作的，在某种程度上，您在这个机箱中探索的新领域也变得更容易理解。</p><h1 id="318a" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">第一步</h1><p id="a461" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">你应该先浏览一下Diesel官方网站上的<a class="ae jp" href="http://diesel.rs/guides/getting-started" rel="noopener ugc nofollow" target="_blank">入门指南</a>。本文主要关注Postgresql，到目前为止，让Postgresql服务器为您的测试运行的最简单的方法是使用Docker(<a class="ae jp" href="http://www.docker.com/" rel="noopener ugc nofollow" target="_blank">www.docker.com</a>)...下面的一行程序应该可以解决这个问题:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="795c" class="lc jr hu ky b fv ld le l lf lg">docker run --rm --detach --name postgres --env POSTGRES_USER=username --env POSTGRES_PASSWORD=password --publish 127.0.0.1:5432:5432 postgres</span></pre><blockquote class="lh li lj"><p id="1353" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><em class="hu">这是</em>而不是<em class="hu">用于生产，当容器停止时，整个容器将被移除(使用</em> <code class="eh lo lp lq ky b"><em class="hu">docker stop postgres</em></code> <em class="hu">),但它对于入门指南来说非常方便。</em></p></blockquote><h1 id="cc48" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">关于本文其余部分的格式</h1><p id="6490" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">本文假设您已经阅读了入门指南；它故意掩盖了一整套特征。这是有意的，这样做是为了让文章尽可能简洁。</p><h1 id="0d7d" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">核心组件和社区</h1><p id="adf7" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">其核心柴油由4个主要成分组成:</p><p id="d332" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">到目前为止，您应该已经了解了<code class="eh lo lp lq ky b">diesel</code> crate、<code class="eh lo lp lq ky b">diesel_codegen</code> crate(代码生成器)和<code class="eh lo lp lq ky b">diesel</code> cli。</p><p id="aacc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后一个主要组件，即“秘密武器”或“非官方指南”(据我所知)，是官方回购中的测试套件(<a class="ae jp" href="https://github.com/diesel-rs/diesel/tree/master/diesel_tests" rel="noopener ugc nofollow" target="_blank">https://github . com/diesel-RS/diesel/tree/master/diesel _ tests</a>)。每当我陷入困境时，它就充当我的向导，尽管随着项目的继续发展，它肯定会被文档所取代。</p><h1 id="2e9a" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">环境</h1><p id="63d1" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">当我开始使用Diesel时，我被<code class="eh lo lp lq ky b">schema.rs</code>中的<code class="eh lo lp lq ky b">infer_schema!</code>宏弄糊涂了(下面会详细介绍)，它反过来使用了<code class="eh lo lp lq ky b">"dotenv:DATABASE_URL"</code>。这个<code class="eh lo lp lq ky b">dotenv</code>箱子只是一个方便的库，允许你把你的<code class="eh lo lp lq ky b">DATABASE_URL</code>放在一个隐藏的环境文件中，ala <code class="eh lo lp lq ky b">.env</code> (dot env，明白吗？).</p><p id="b16c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，你也可以在你的环境中指定<code class="eh lo lp lq ky b">DATABASE_URL</code>，当你在一个docker容器ala <a class="ae jp" href="https://12factor.net/" rel="noopener ugc nofollow" target="_blank"> 12因子应用</a>中运行你的使用Diesel的Rust二进制时，这特别方便。</p><p id="f836" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Diesel cli工具还读取<code class="eh lo lp lq ky b">.env</code>文件，如果该文件不可用，您需要在环境中定义<code class="eh lo lp lq ky b">DATABASE_URL</code>或者将<code class="eh lo lp lq ky b">--database-url</code>参数传递给它。</p><blockquote class="lh li lj"><p id="9496" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><em class="hu">一定要查看</em> <code class="eh lo lp lq ky b"><em class="hu">examples/sqlite/getting_started_step_3/README.md</em></code> <em class="hu">文件，以便了解如何为SQLite配置</em> <code class="eh lo lp lq ky b"><em class="hu">DATABASE_URL</em></code> <em class="hu">(它不使用URI格式)。</em></p></blockquote><h1 id="f461" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">基本流程</h1><p id="392a" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">创建使用Diesel构建的应用程序的核心工作流程可以分解如下:</p><h1 id="9e9c" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">设计一个模式</h1><p id="4c49" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">对于经验丰富的SQL老手来说，这是非常明显的，幸运的是，对于我们其余的人来说,<code class="eh lo lp lq ky b">diesel</code> cli的<code class="eh lo lp lq ky b">migration</code>子命令允许我们轻松地迭代我们的设计，甚至随着时间的推移不断发展。然而，预先清楚地知道您希望数据库是什么样子是非常有用的，应该注意的是，Diesel只适用于有主键的表。</p><h1 id="d618" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">创建迁移</h1><p id="4e92" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">遵循《入门指南》中的模式，注意您可以随时使用<code class="eh lo lp lq ky b">diesel migration generate</code>子命令添加更多的迁移。每当您运行<code class="eh lo lp lq ky b">diesel migration run</code>时，迁移将按顺序运行。您可以通过发出<code class="eh lo lp lq ky b">diesel migration redo</code>命令重新运行上一次迁移，如果您确实遇到了问题，您可以运行下面的命令，但是请不要在生产数据库上这样做，<code class="eh lo lp lq ky b">diesel database reset</code>。</p><p id="2938" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">设计表格时，你应该使用复数形式的表格名称。例如，Diesel将采用模型<code class="eh lo lp lq ky b">User</code>并搜索表<code class="eh lo lp lq ky b">users</code>。您可以定义自定义的表名，但是了解Diesel开发人员的假设可能会避免一些混乱。</p><p id="6ec0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Diesel将获取<code class="eh lo lp lq ky b">PascalCase</code>Rust struct(它可能描述单个对象，或者数据库表中的行),并将它们翻译成<code class="eh lo lp lq ky b">snake_case</code>表名，并在末尾添加一个<code class="eh lo lp lq ky b">s</code>,使其“多元化”。例如，<code class="eh lo lp lq ky b">AFancyNamedObject</code>将被假设映射到一个名为<code class="eh lo lp lq ky b">a_fancy_named_objects</code>的表。</p><h1 id="c428" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">从数据库中推断模式</h1><p id="11ae" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">Diesel能够检查您的实际数据库，并推断出Rust中使用的模式，这将用于创建必要的DSL(领域特定语言),允许您以安全、快速和强类型的方式与数据库进行交互。</p><p id="c7d9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">入门指南和示例使用了<code class="eh lo lp lq ky b">infer_schema!</code>宏。使用这个宏的主要缺点是，首先，你<em class="lk">不知道Diesel实际上是如何解释你的数据库类型的(这对你的模型很重要，这将在后面揭示),其次，它在编译时需要一个自举的数据库实例，当作为管道的一部分进行编译时，可能会有点痛苦，因为你的数据库和编译器工具链不能互相使用。</em></p><p id="0866" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">建议您使用<code class="eh lo lp lq ky b">diesel print-schema</code>子命令，简单地将推断的模式复制并粘贴到项目中的一个文件中(在《入门指南》中，这是<code class="eh lo lp lq ky b">schema.rs</code>，但也可以很容易地粘贴到<code class="eh lo lp lq ky b">lib.rs</code>或<code class="eh lo lp lq ky b">main.rs</code>)。</p><p id="136f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您将看到一个类似于以下内容的<code class="eh lo lp lq ky b">table!</code>宏:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="36fc" class="lc jr hu ky b fv ld le l lf lg">table! {<br/>    users {<br/>        id -&gt; Integer,<br/>        name -&gt; VarChar,<br/>    }<br/>}</span></pre><p id="022f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您想要获取数据类型(在本例中是<code class="eh lo lp lq ky b">Integer</code>和<code class="eh lo lp lq ky b">VarChar</code>)并立即运行到<code class="eh lo lp lq ky b">docs.rs/diesel</code>并将其插入到文档搜索栏中。这将直接带您到<code class="eh lo lp lq ky b">diesel::types::Foo</code>(也探索<code class="eh lo lp lq ky b">diesel::types</code>)，并允许您检查每种类型已实现的<code class="eh lo lp lq ky b">ToSql</code>和<code class="eh lo lp lq ky b">FromSql</code>特征。举个例子，<code class="eh lo lp lq ky b">Integer</code>映射到Rust中的<code class="eh lo lp lq ky b">i32</code>。这在实现模型或处理编译时错误时非常有用。</p><h1 id="a4a4" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">创建模型</h1><p id="1e7a" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">与模式一样，您不需要<em class="lk">将您的模型放在<code class="eh lo lp lq ky b">models.rs</code>文件中。建议您使用Rust modules系统来拆分您的模型，类似下面的内容可能会有所帮助，尤其是在处理大量模型时。</em></p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="ea8b" class="lc jr hu ky b fv ld le l lf lg">models/<br/>  users/<br/>    mod.rs<br/>  posts/<br/>    mod.rs</span></pre><blockquote class="lh li lj"><p id="a066" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><em class="hu">我最初挣扎着把用来驱动柴油的“魔法”从惯用的铁锈中分裂出来。原来，一旦你知道了它是如何构造的，以及现在如何处理生成的代码，Diesel就只是一个熟悉的老东西。</em></p></blockquote><p id="b2dd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是一个用Rust struct表示的示例模型，直接摘自入门指南:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="2b23" class="lc jr hu ky b fv ld le l lf lg">#[derive(Queryable)]<br/>pub struct Post {<br/>    pub id: i32,<br/>    pub title: String,<br/>    pub body: String,<br/>    pub published: bool,<br/>}</span></pre><p id="e499" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">模型是普通的Rust结构，<em class="lk">似乎</em>映射到你的表。这通常是简单模型的情况，然而，注意到<code class="eh lo lp lq ky b">Queryable</code>结构，顾名思义，实际上映射到您想要从SQL查询中获得的<em class="lk">结果</em>是非常重要的。</p><p id="857c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lo lp lq ky b">Queryable</code> struct是您希望从SQL查询中检索的单个对象或行(部分或完整)。这个<code class="eh lo lp lq ky b">User</code>对象可以从<code class="eh lo lp lq ky b">users</code>表中查询，或者任何返回正确类型的查询，如下面的<code class="eh lo lp lq ky b">Queryable</code>部分所讨论的。</p><p id="9948" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，diesel的SQL类型不支持Postgresql中的无符号整数(这是Postgresql的一个限制)，因此查看文档中适当的<code class="eh lo lp lq ky b">diesel::*::types</code>来了解您的数据库支持什么是值得的。</p><h1 id="f2dd" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">衍生，又名“密码魔术”</h1><p id="985a" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">Diesel的代码生成器主要用于使用SQL magic嵌入您的Rust结构，而无需您手动编写大量功能。它还将Rust类型的系统变成了神奇的成分，可以用来构建快速可靠的SQL，并传输到数据库。</p><p id="61f6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了让您的结构具有SQL的优点，您可以使用Rust的自定义派生功能，例如:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="0286" class="lc jr hu ky b fv ld le l lf lg">#[derive(Queryable)]<br/>pub struct Post {<br/>    pub id: i32,<br/>    ...</span></pre><p id="e7e4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个更复杂的例子:</p><blockquote class="lh li lj"><p id="0b59" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><em class="hu">我喜欢在测试中偶然发现以下内容……这确实让我对作者的天才一笑置之，但也让我挠头，“这些东西到底用在哪里，它们是如何工作的？”</em></p></blockquote><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="c2da" class="lc jr hu ky b fv ld le l lf lg">#[derive(PartialEq, Eq, Debug, Clone, Queryable, Identifiable, Insertable, AsChangeset, Associations)]<br/>#[table_name = "users"]<br/>pub struct User {<br/>    pub id: i32,<br/>    pub name: String,<br/>    pub hair_color: Option&lt;String&gt;,<br/>}</span></pre><p id="f356" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，新手给你一个“专业建议”，你应该安装cargo子命令<code class="eh lo lp lq ky b">expand</code>:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="75ee" class="lc jr hu ky b fv ld le l lf lg">cargo install cargo-expand</span></pre><p id="c6d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这允许您运行下面的命令，并且实际上<em class="lk">看到</em>生成的内容(警告，本指南假设您了解Rust，但是下面的内容可能会让即使是经验丰富的Rust开发人员也热泪盈眶，因此可以随意跳过它或用作睡前读物)。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="a8d4" class="lc jr hu ky b fv ld le l lf lg">cargo expand</span></pre><p id="f0a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所生成的DSL的全部优点显露出来了…特别有趣的是每个模型的列。解析输出是无聊的读者或喜欢挑战的读者的一项练习。</p><p id="c984" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们更详细地看一下推导过程。</p><h2 id="3a82" class="lc jr hu bd js lr ls lt jw lu lv lw ka jc lx ly ke jg lz ma ki jk mb mc km md dt translated">PartialEq，Eq，调试，克隆</h2><p id="b52e" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">这些是大多数开发人员在适当的时候依赖的标准Rust派生。如果你喜欢使用<code class="eh lo lp lq ky b">println!</code>(或者闪亮的新<code class="eh lo lp lq ky b">eprintln!</code>)进行调试，你可能至少需要<code class="eh lo lp lq ky b">Debug</code>。</p><blockquote class="lh li lj"><p id="5943" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><code class="eh lo lp lq ky b"><em class="hu">#![deny(missing_debug_implementations)]</em></code> <em class="hu">是一个非常有用的编译器指令，因为它会在任何没有</em> <code class="eh lo lp lq ky b"><em class="hu">Debug</em></code> <em class="hu">实现的结构上出错，如果您正在开发一个库，这尤其有用。</em></p></blockquote><h2 id="7160" class="lc jr hu bd js lr ls lt jw lu lv lw ka jc lx ly ke jg lz ma ki jk mb mc km md dt translated">可查询的</h2><p id="1596" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">大多数开发人员通常想对数据库做的第一件事是查询其中的数据。为了做到这一点，你需要将你的<code class="eh lo lp lq ky b">struct</code>装饰如下:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="93c5" class="lc jr hu ky b fv ld le l lf lg">#[derive(Queryable)]<br/>struct User {<br/>    id: i32,<br/>    firstname: String,<br/>    lastname: String,<br/>    age: i32,<br/>}</span></pre><p id="a938" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将导致<code class="eh lo lp lq ky b">diesel_codegen</code>生成反序列化类型为<code class="eh lo lp lq ky b">(i32, String, String, i32)</code>的查询结果所需的查询DSL，该查询结果映射到Postgresql中的<code class="eh lo lp lq ky b">(Integer, Text, Text, Integer)</code>,更多示例见文章末尾。</p><blockquote class="lh li lj"><p id="47cf" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><em class="hu">在SQLite中，日期/时间类型也可以反序列化为</em> <code class="eh lo lp lq ky b"><em class="hu">String</em></code> <em class="hu">。</em></p></blockquote><p id="45b0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用Diesel时，主键列是必需的，但无论如何，这可能是一个好的实践。</p><p id="3153" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如何使用DSL来构造查询将在本文后面讨论。</p><h2 id="1ff3" class="lc jr hu bd js lr ls lt jw lu lv lw ka jc lx ly ke jg lz ma ki jk mb mc km md dt translated">可插入的</h2><p id="ee7d" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">除非您来自现有的系统，否则您可能也想将数据插入到数据库中。典型的“可插入”对象如下所示:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="fbc9" class="lc jr hu ky b fv ld le l lf lg">#[derive(Insertable)]<br/>#[table_name="users"]<br/>struct NewUser {<br/>    firstname: String,<br/>    lastname: String,<br/>    age: i32,<br/>}</span></pre><p id="429a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，我们已经删除了<code class="eh lo lp lq ky b">id</code>字段，因为SQL server将为我们处理这个问题(对于高级用例，这可能会有所变化)。</p><p id="f986" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还要注意，我们现在显式地命名该表为<code class="eh lo lp lq ky b">users</code>，这对于<code class="eh lo lp lq ky b">AsChangeset</code>也是需要的，并且对于<code class="eh lo lp lq ky b">Identifiable</code>是推断出来的</p><h2 id="8236" class="lc jr hu bd js lr ls lt jw lu lv lw ka jc lx ly ke jg lz ma ki jk mb mc km md dt translated">可辨认的</h2><p id="d75e" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">不可避免地，您将使用SQL连接一次从多个表中构造结果。为了使连接成功地解析目标表中的精确对象，需要对这个<code class="eh lo lp lq ky b">struct</code>进行如下注释:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="5bc6" class="lc jr hu ky b fv ld le l lf lg">struct User {<br/>    id: i32,<br/>    firstname: String,<br/>    lastname: String,<br/>    age: i32,<br/>}</span></pre><p id="6f46" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">默认情况下，Diesel将假设您的主键名为<code class="eh lo lp lq ky b">id</code>，如果不是，您可以按如下方式覆盖它:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="3ab7" class="lc jr hu ky b fv ld le l lf lg">#[derive(Identifiable)]<br/>#[primary_key(guid)]<br/>struct User {<br/>    guid: i32,<br/>    firstname: String,<br/>    lastname: String,<br/>    age: i32,<br/>}</span></pre><h2 id="a89e" class="lc jr hu bd js lr ls lt jw lu lv lw ka jc lx ly ke jg lz ma ki jk mb mc km md dt translated">联合</h2><p id="19a6" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">需要用您的<code class="eh lo lp lq ky b">Identifiable</code>数据充实的表格需要注释如下:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="4321" class="lc jr hu ky b fv ld le l lf lg">#[derive(Associations)]<br/>#[belongs_to(User)]<br/>struct ActiveUsers {<br/>    id: i32,<br/>    user_id: i32,<br/>    last_active: NaiveDateTime<br/>}</span></pre><p id="a5c8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将允许您通过查找与<code class="eh lo lp lq ky b">User</code>表中的<code class="eh lo lp lq ky b">id</code>字段相对应的<code class="eh lo lp lq ky b">user_id</code>字段定义的用户，将<code class="eh lo lp lq ky b">User</code>数据加入到该表中。如果您的外键字段没有在模式<code class="eh lo lp lq ky b">type_id</code>中指定，您需要手动映射它:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="8046" class="lc jr hu ky b fv ld le l lf lg">#[derive(Associations)]<br/>#[belongs_to(User, foreign_key="user_lookup_key")]<br/>struct ActiveUsers {<br/>    id: i32,<br/>    user_lookup_key: i32,<br/>    last_active: NaiveDateTime,<br/>}</span></pre><h2 id="8c25" class="lc jr hu bd js lr ls lt jw lu lv lw ka jc lx ly ke jg lz ma ki jk mb mc km md dt translated">AsChangeSet</h2><p id="783d" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated"><code class="eh lo lp lq ky b">#[derive(AsChangeset)]</code>用于更新，更多详情可在本进行中指南中找到:<a class="ae jp" href="https://github.com/diesel-rs/diesel/blob/master/guide_drafts/all-about-updates.md" rel="noopener ugc nofollow" target="_blank">https://github . com/diesel-RS/diesel/blob/master/guide _ drafts/all-about-updates . MD</a></p><h1 id="15c6" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">使用柴油</h1><p id="1f5d" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">此时，您已经准备好用Diesel做一些事情，可能会插入一些数据并进行一些查询。《入门指南》中有多个示例介绍了这一点。然而，有些东西需要拆开包装，希望能让灯泡继续工作。</p><p id="c740" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，在这一点上，强调你正在进入正常的生锈世界是非常重要的。我这么说的意思是，Diesel的代码和魔法部分现在退居二线了。</p><p id="cf49" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这意味着当您查看示例代码时，不会有更多的疏忽。你只需要相信编译器，像平常一样花时间解开语句和表达式。你会发现你正在调用普通的方法，传递普通的数据结构(或者对它们的引用),你可以像对待其他Rust代码一样<code class="eh lo lp lq ky b">println!</code>、调试、步进、重新排序和组织。不幸的是，我花了很长时间才理解这一点，但这是一个重要的见解，可以让你无所畏惧地编码。</p><h1 id="cb32" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">连接到数据库</h1><p id="bcb4" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated"><code class="eh lo lp lq ky b">postgresql</code>示例使用函数<code class="eh lo lp lq ky b">pub fn establish_connection() -&gt; PgConnection</code>将连接包装成一个方便的函数调用，以便在示例代码的其余部分重用。</p><p id="3fda" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lo lp lq ky b">PgConnection</code>为你封装了<code class="eh lo lp lq ky b">posgresql</code>的句柄，保留这个对象或者按需重新创建它。需要时，查看<code class="eh lo lp lq ky b">r2d2</code>创建一个数据库连接池。</p><p id="ab94" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用Diesel执行的所有操作都取决于可用的连接对象。</p><h1 id="fddf" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">插入数据</h1><p id="3be7" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">本指南在<code class="eh lo lp lq ky b">src/lib.rs</code>中指定了以下功能。让我们一步一步来:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="35a5" class="lc jr hu ky b fv ld le l lf lg">pub fn create_post(conn: &amp;PgConnection, title: &amp;str, body: &amp;str) -&gt; Post {<br/>    use schema::posts;<br/>    let new_post = NewPost {<br/>        title: title,<br/>        body: body,<br/>    };</span><span id="6a7a" class="lc jr hu ky b fv me le l lf lg">    diesel::insert(&amp;new_post).into(posts::table)<br/>        .get_result(conn)<br/>        .expect("Error saving new post")<br/>}</span></pre><p id="6ccb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先注意连接<code class="eh lo lp lq ky b">&amp;PgConnection</code>的引用。正如对<code class="eh lo lp lq ky b">src/bin/</code>中的其他一些文件所做的那样，一个新的<code class="eh lo lp lq ky b">PgConnection</code>也可以通过调用如下内容来实例化:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="0a63" class="lc jr hu ky b fv ld le l lf lg">let conn = establish_connection();</span></pre><p id="d5ee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下一行，<code class="eh lo lp lq ky b">use schema::posts;</code>，困扰了我很长时间，因为这是使用生成的代码。在<code class="eh lo lp lq ky b">diesel::insert</code>表达式中，我们看到了<code class="eh lo lp lq ky b">posts::table</code>的用法。</p><p id="abec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此时，获取<code class="eh lo lp lq ky b">cargo expand</code>的输出并在某种IDE中查看它可能是个好主意。尝试以下方法:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="06ab" class="lc jr hu ky b fv ld le l lf lg"># Check out a copy of Diesel     git clone <a class="ae jp" href="https://github.com/diesel-rs/diesel.git" rel="noopener ugc nofollow" target="_blank">https://github.com/diesel-rs/diesel.git</a><br/>cd diesel/examples/postgres/getting_started_step_3/</span><span id="3e2c" class="lc jr hu ky b fv me le l lf lg"># Build the example (assuming your postgres instance is ready<br/># and running; see the docker hint above)</span><span id="64e4" class="lc jr hu ky b fv me le l lf lg">echo DATABASE_URL=postgres://username:password@localhost/diesel_demo &gt; .env<br/>diesel setup<br/>cargo build</span><span id="dff1" class="lc jr hu ky b fv me le l lf lg"># Expand the code (assuming cargo-expand is installed)</span><span id="57e3" class="lc jr hu ky b fv me le l lf lg">cargo expand --lib &gt; expanded.rs</span></pre><p id="218a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您在输出下搜索<code class="eh lo lp lq ky b">mod schema</code>，您还会看到<code class="eh lo lp lq ky b">mod posts</code>，在那里您会找到一个<code class="eh lo lp lq ky b">table</code>结构(空的，但是有一堆特征被导入)。</p><p id="6e8c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来我们有一个新的物体(T4)，叫做T5。</p><p id="5cf4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后我们有实际的柴油方法<code class="eh lo lp lq ky b">insert</code>。如果您查阅文档，您会看到Diesel模块有5个功能，其核心是<code class="eh lo lp lq ky b">insert</code>、<code class="eh lo lp lq ky b">delete</code>、<code class="eh lo lp lq ky b">insert_default_values</code>、<code class="eh lo lp lq ky b">select</code>和<code class="eh lo lp lq ky b">update</code>。</p><p id="c00e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您查看<code class="eh lo lp lq ky b">insert</code>函数，您会看到它接受<code class="eh lo lp lq ky b">records: T</code>(在本例中是我们的新用户，但也可以是<code class="eh lo lp lq ky b">Vec&lt;T&gt;</code>)并返回一个<code class="eh lo lp lq ky b">IncompleteInsertStatement</code>对象，该对象有一个名为<code class="eh lo lp lq ky b">into()</code>的方法，该方法接受您的<code class="eh lo lp lq ky b">table</code>结构。您也可以调用<code class="eh lo lp lq ky b">into(::schema::posts::table)</code>并避免使用语句。</p><p id="4869" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这种情况下，<code class="eh lo lp lq ky b">schema</code>是<em class="lk">的名称，也就是您的</em>模块的名称，因为模式是在<code class="eh lo lp lq ky b">schema.rs</code>文件中生成的。</p><h1 id="54cd" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">查询数据</h1><p id="132a" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">同样，我们将在指南中引用一个函数，在本例中是<code class="eh lo lp lq ky b">src/bin/show_posts.rs</code>文件:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="36a9" class="lc jr hu ky b fv ld le l lf lg">extern crate diesel_demo;<br/>extern crate diesel;<br/>use self::diesel_demo::*;<br/>use self::diesel_demo::models::*;<br/>use self::diesel::prelude::*;</span><span id="afdc" class="lc jr hu ky b fv me le l lf lg">fn main() {</span><span id="a81a" class="lc jr hu ky b fv me le l lf lg">    use diesel_demo::schema::posts::dsl::*;<br/>    let connection = establish_connection();<br/>    let results = posts.filter(published.eq(true))<br/>        .limit(5)<br/>        .load::&lt;Post&gt;(&amp;connection)<br/>        .expect("Error loading posts");</span><span id="f1a8" class="lc jr hu ky b fv me le l lf lg">    println!("Displaying {} posts", results.len());</span><span id="6afc" class="lc jr hu ky b fv me le l lf lg">    for post in results {<br/>        println!("{}", post.title);<br/>        println!("----------\n");<br/>        println!("{}", post.body);<br/>    }<br/>}</span></pre><p id="a589" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从头开始，首先我们导入自己的板条箱(示例<code class="eh lo lp lq ky b">Cargo.toml</code>将<code class="eh lo lp lq ky b">crate</code>名称指定为<code class="eh lo lp lq ky b">diesel_demo</code>)。我们进口柴油箱。</p><p id="52d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lo lp lq ky b">use self::diesel_demo::*;</code>让我们访问<code class="eh lo lp lq ky b">establish_connection()</code>函数，<code class="eh lo lp lq ky b">use self::diesel_demo::models::*;</code>让我们访问我们在<code class="eh lo lp lq ky b">models.rs</code>文件中定义的实际结构，在本例中是<code class="eh lo lp lq ky b">Post</code>结构。</p><p id="0a85" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lo lp lq ky b">use self::diesel::prelude::*;</code>是一个必要的导入，将一大堆柴油特性和类型纳入范围。这是Diesel工作所必需的，超出了本文的讨论范围。</p><p id="b691" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<code class="eh lo lp lq ky b">main()</code>函数中，我们再次遇到了一些魔法的使用，特别是<code class="eh lo lp lq ky b">use diesel_demo::schema::posts::dsl::*;</code>行。当我第一次开始使用Diesel时，我被上面插入代码时使用的<code class="eh lo lp lq ky b">schema::tablename::*</code>导入和这里使用的<code class="eh lo lp lq ky b">schema::posts::dsl::*</code> dsl导入的区别难住了。</p><p id="4cd9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">看一下<code class="eh lo lp lq ky b">cargo expand</code>的输出，可以得到一些澄清:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="3959" class="lc jr hu ky b fv ld le l lf lg">pub mod dsl {<br/>    pub use super::columns::*;<br/>    pub use super::table as posts;<br/>}</span></pre><p id="6105" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">简而言之，<code class="eh lo lp lq ky b">schema::posts::dsl::*</code>将您的表的<code class="eh lo lp lq ky b">columns</code>带入范围。为您生成的每个列类型都有一个在其上实现的<code class="eh lo lp lq ky b">expression_methods</code>集合。换句话说，<code class="eh lo lp lq ky b">dsl</code>(领域特定语言)允许我们在表名中使用<code class="eh lo lp lq ky b">columns</code>(由<code class="eh lo lp lq ky b">schema.rs</code>生成的代码定义)并对其应用逻辑，以便构造我们的SQL查询。(见<a class="ae jp" href="http://docs.diesel.rs/diesel/expression_methods/global_expression_methods/trait.ExpressionMethods.html#method.desc" rel="noopener ugc nofollow" target="_blank">http://docs . diesel . RS/diesel/expression _ methods/global _ expression _ methods/trait。expression methods . html # method . desc</a></p><p id="8906" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您发现了将<code class="eh lo lp lq ky b">table</code>方便地导入到dsl模块中(我认为这是为了方便)，那么您将获得额外的加分。</p><h2 id="125a" class="lc jr hu bd js lr ls lt jw lu lv lw ka jc lx ly ke jg lz ma ki jk mb mc km md dt translated">构建查询</h2><p id="10c0" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在SQL中，我们构造一个select表达式来从我们的数据库中返回值，在Diesel中，我们使用Rust的类型系统来构造类型检查的、安全的版本。这对于任何曾经与SQL查询的脆弱性及其隐含的安全风险作斗争的人来说都是非常好的…只有有效的SQL才能成功编译。</p><p id="ef6b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下一个表达式<code class="eh lo lp lq ky b">posts.filter(published.eq(true))</code>反映了我们想要在<code class="eh lo lp lq ky b">posts</code>表上运行<code class="eh lo lp lq ky b">filter</code>方法(也可以通过<code class="eh lo lp lq ky b">use schema::posts::dsl::*</code>语句方便地导入到我们的上下文中)。<code class="eh lo lp lq ky b">filter</code>将构建的过滤器作为其输入。通过组合列及其表达式方法来构造过滤器。</p><p id="d783" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要检查结果，您可以将相关代码重写为:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="edd8" class="lc jr hu ky b fv ld le l lf lg">use diesel::debug_sql;</span><span id="c86a" class="lc jr hu ky b fv me le l lf lg">let posts_with_sql = posts.filter(published.eq(true))<br/>    .limit(5);</span><span id="1ad1" class="lc jr hu ky b fv me le l lf lg">println!("SelectStatement: {:#?}", posts_with_sql);</span><span id="c5c3" class="lc jr hu ky b fv me le l lf lg">let results = posts_with_sql<br/>    .load::&lt;Post&gt;(&amp;connection)<br/>    .expect("Error loading posts");</span></pre><p id="141d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您查看终端的输出，您会看到返回了一个<code class="eh lo lp lq ky b">SelectStatement</code>对象。您还可以使用<code class="eh lo lp lq ky b">println!("SQL: {}", debug_sql!(posts_with_sql));</code>查看将要生成的SQL(使用<code class="eh lo lp lq ky b">#[macro_use] extern crate diesel;</code>导入diesel)。</p><p id="81b6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本节的主要内容是，首先使用从<code class="eh lo lp lq ky b">dsl</code>模块导入的<code class="eh lo lp lq ky b">table</code>和<code class="eh lo lp lq ky b">columns</code>构建相关的SQL查询，这可以通过<code class="eh lo lp lq ky b">println!</code>和<code class="eh lo lp lq ky b">debug_sql</code>进行自省。</p><p id="01d4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您应该尽可能地熟悉您可以在列上调用的不同的<code class="eh lo lp lq ky b">expression_methods</code>——它将帮助您顺利地构建您想要在应用程序中使用的SQL查询。</p><h1 id="7e3b" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">获得结果</h1><p id="c96a" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">本文中我们要处理的最后一项实际上是读取您的结果。在<code class="eh lo lp lq ky b">show_posts.rs</code>二进制中，这是通过以下代码行实现的:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="ce35" class="lc jr hu ky b fv ld le l lf lg">let results = ...omitted...<br/>    .load::&lt;Post&gt;(&amp;connection)<br/>    .expect("Error loading posts");</span></pre><p id="c961" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">可以看到，我们正在调用我们前面检查过的<code class="eh lo lp lq ky b">SelectStatement</code>结构的<code class="eh lo lp lq ky b">.load()</code>方法。<code class="eh lo lp lq ky b">.load()</code>方法是通用的，所以我们需要给编译器一些提示，告诉它我们想返回什么类型。加载函数的参数是对由<code class="eh lo lp lq ky b">establish_connection</code>返回的<code class="eh lo lp lq ky b">connection</code>对象的引用(或借用)。</p><p id="cefd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lo lp lq ky b">load</code>返回一个结果对象，在这个可执行文件中，我们通过用<code class="eh lo lp lq ky b">expect()</code>方法展开结果来处理它。然后，如果成功，我们将结果传递给<code class="eh lo lp lq ky b">results</code>绑定。</p><p id="fc70" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">参见文档中的<code class="eh lo lp lq ky b">diesel::prelude::LoadDsl</code>或<code class="eh lo lp lq ky b">diesel::prelude::FirstDsl</code>了解<code class="eh lo lp lq ky b">load</code>的一些替代方案。正如将要看到的，这些方法返回一个<code class="eh lo lp lq ky b">QueryResult</code>，它只是一个<code class="eh lo lp lq ky b">Result&lt;T, Error&gt;;</code>类型的别名。</p><p id="2d1e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在刚才提到的所有方法中，要么返回单个对象(<code class="eh lo lp lq ky b">QueryResult&lt;T&gt;</code>)，要么返回对象的向量(<code class="eh lo lp lq ky b">QueryResult&lt;Vec&lt;T&gt;&gt;</code>)。换句话说，数据库表中所选列的一行或多行。</p><h2 id="be3b" class="lc jr hu bd js lr ls lt jw lu lv lw ka jc lx ly ke jg lz ma ki jk mb mc km md dt translated">与结果角力</h2><p id="6737" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">如果我们想得到所有的结果，我们可以使用代码:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="3d66" class="lc jr hu ky b fv ld le l lf lg">let results :Vec&lt;Post&gt; = posts<br/>    .load(&amp;connection)<br/>    .expect("Error loading posts");</span></pre><p id="fca5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lo lp lq ky b">load</code>和<code class="eh lo lp lq ky b">get_results</code>是等价的。也就是说，它们都返回一个<code class="eh lo lp lq ky b">Vec&lt;T&gt;</code>结果(<code class="eh lo lp lq ky b">QueryResult</code>)。注意，代码被重新格式化，以说明在绑定<code class="eh lo lp lq ky b">let results: Vec&lt;Post&gt; = ...</code>中给编译器的返回类型提示。</p><p id="fc5c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，有时你会使用一个<code class="eh lo lp lq ky b">select</code>方法或<code class="eh lo lp lq ky b">join</code>方法(本文中没有举例说明，但是请查看上面提到的‘非官方指南’又名<code class="eh lo lp lq ky b">diesel_tests</code>),它们会返回不直接映射到你的模型中的字段的行。在这种情况下，使用<code class="eh lo lp lq ky b">tuple</code>从你的<code class="eh lo lp lq ky b">load</code>方法中收集你的结果。这可能看起来像:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="58a2" class="lc jr hu ky b fv ld le l lf lg">let results: Vec&lt;(i32, String, String, bool)&gt;= posts<br/>    .load(&amp;connection)<br/>    .expect("Error loading posts");</span></pre><p id="11d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上面，我们将<code class="eh lo lp lq ky b">Post</code>型号或<code class="eh lo lp lq ky b">struct</code>表示为其组成部件的<code class="eh lo lp lq ky b">tuple</code>。</p><h1 id="edfe" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">我们没有涵盖的内容以及下一步要做什么</h1><p id="7fd8" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">本文中没有涉及到很多内容，尽管就其本身而言，这是一个相当大的信息量。如前所述，目标是解释足够多的Diesel及其结构，以便感兴趣的开发人员可以“搜索”或理解它，然后自助。</p><p id="ac50" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我希望你能走到这一步，并享受这段旅程，请发送反馈并享受Rust和Diesel。</p><p id="686d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">特别感谢《Diesel》的作者Sean Griffin，他对本文进行了事实核查。</p></div></div>    
</body>
</html>