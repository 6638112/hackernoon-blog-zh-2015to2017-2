<html>
<head>
<title>OpsWorks meets docker-compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OpsWorks遇上docker-compose</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/opsworks-meets-docker-compose-98e766cd3d6a?source=collection_archive---------0-----------------------#2016-02-11">https://medium.com/hackernoon/opsworks-meets-docker-compose-98e766cd3d6a?source=collection_archive---------0-----------------------#2016-02-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="568c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我在寻找编排我刚刚创建的应用程序容器的方法时，我发现了<a class="ae jp" href="https://hackernoon.com/tagged/aws" rel="noopener ugc nofollow" target="_blank"> AWS </a> OpsWorks。那时我正在使用shell脚本和木偶。</p><p id="5006" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在开始使用OpsWorks后，我意识到它应该是我的集装箱化关键工具，因为它的特性，比如自动修复EC2实例、自动缩放和基于时间的EC2实例。当然，还有其他解决方案，我仍在尝试，我不得不说，我有点倾向于kubernetes或deis。</p><p id="ba92" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">无论如何，我认为我可以使用定制的json OpsWorks特性来翻译docker-compose.yml，我们的开发人员已经用它来告诉<a class="ae jp" href="https://hackernoon.com/tagged/docker" rel="noopener ugc nofollow" target="_blank"> docker </a>主机应该运行哪些容器映像以及如何运行。</p><p id="aff6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">OpsWorks是一个工具，它使配置和管理主机(EC2实例)以及将它们与EC2 ELBs集成变得容易。基本上，您创建具有应用层(实例、负载平衡器、rds……)的应用程序堆栈，并使用定制的chef cookbooks配置它们。您还可以在栈创建时提供一个“自定义JSON ”,它将被传递给chef。</p><p id="6d71" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">定制JSON是这里的关键特性，因为它可以用来配置、标记和设置将运行chef recipes的EC2实例的属性。</p><p id="d429" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我做的一些事情(有<a class="ae jp" href="https://bitbucket.org/tnache/opsworks-recipes" rel="noopener ugc nofollow" target="_blank"> @tnache </a>的贡献)是:</p><ul class=""><li id="c777" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">在启动时更改EC2实例标记</li><li id="b860" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">基于EC2实例的当前公共ip更新条目中的特定路由53</li><li id="5924" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">NFS山出口</li></ul><p id="82cb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是这篇文章的主要目标是告诉你我是如何用docker-compose完成docker <br/>容器编排的。</p><p id="c318" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Docker-compose使用yaml文件来声明容器应该如何运行。而且<br/> yaml文件可以很容易的翻译成json。</p><p id="3450" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以，事情是这样的:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="28f2" class="kn ko hu kj b fv kp kq l kr ks">db:<br/> image: postgres<br/>web:<br/> build: my-djangoapp<br/> command: python manage.py runserver 0.0.0.0:8000<br/> volumes:<br/>   - /data:/data<br/> ports:<br/>   - "8000:8000"<br/> links:<br/>   - db</span></pre><p id="dab7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当用json表示时，应该是这样的:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="10db" class="kn ko hu kj b fv kp kq l kr ks">{<br/> "db": {<br/>   "image": "postgres"<br/> },<br/> "web": {<br/>   "image": "my-djangoapp",<br/>   "command": "python manage.py runserver 0.0.0.0:8000",<br/>   "volumes": [<br/>     "/data:/data"<br/>   ],<br/>   "ports": [<br/>     "8000:8000"<br/>   ],<br/>   "links": [<br/>     "db"<br/>   ]<br/> }<br/>}</span></pre><p id="8297" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">简单…</p><p id="9eab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，这里的想法是将YAML翻译成json，这样我们就可以在OpsWorks堆栈的创建中的自定义JSON字段中使用<br/>它，<br/>允许将JSON传递给chef。</p><p id="569e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然，我说过docker-compose使用yaml文件，所以我们必须使用chef将它从json转换回yaml，使用chef模板非常容易。</p><p id="378b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为我想将定制的json用于其他事情，而不是简单地<br/>编写docker-compose.yml，所以我决定将翻译成<br/> json的yaml放在一个新的JSON键中。所以json应该是这样的:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="11cd" class="kn ko hu kj b fv kp kq l kr ks">{<br/>   "applications":<br/>   {<br/>       "db": {<br/>           "image": "postgres"<br/>       },<br/>       "web": {<br/>           "image": "my-djangoapp",<br/>           "command": "python manage.py runserver 0.0.0.0:8000",<br/>           "volumes": [<br/>               "/data:/data"<br/>               ],<br/>           "ports": [<br/>               "8000:8000"<br/>               ],<br/>           "links": [<br/>               "db"<br/>               ]<br/>       }<br/>   }<br/>}</span></pre><p id="4212" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这样，我可以对特定的厨师食谱使用特定的键，用于<br/>实例标签、route53、nfs…</p><p id="d7e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后一件事。由于OpsWorks堆栈支持EC2 <br/>实例的“层”,如果我能为每一层指定应用程序json的<br/>键就好了。</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="8ac5" class="kn ko hu kj b fv kp kq l kr ks">{<br/>   "layers": {<br/>       "djangoapp":{<br/>           "applications":<br/>           {<br/>               "db": {<br/>                   "image": "postgres"<br/>               },<br/>                   "web": {<br/>                       "image": "my-djangoapp",<br/>                       "command": "python manage.py runserver 0.0.0.0:8000",<br/>                       "volumes": [<br/>                           "/data:/data"<br/>                           ],<br/>                       "ports": [<br/>                           "8000:8000"<br/>                           ],<br/>                       "links": [<br/>                           "db"<br/>                           ]<br/>                   }<br/>           }<br/>       }<br/>   }<br/>}</span></pre><p id="fdd4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在上面的例子中，chef模板文件将从“applications”键开始，将yaml翻译成OpsWorks堆栈的“djangoapp”层中所有EC2 <br/>实例的json <br/>。</p><p id="11af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以将一个docker-compose.yml文件“翻译”到每个OpsWorks堆栈的<br/>层，在“层”json层中创建更多的键。此外，我们还可以<br/>创建一个“全局”的“应用”键，该键将被合并到<br/>特定层的“应用”中。在这种情况下，更长的json应该是这样的:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="d680" class="kn ko hu kj b fv kp kq l kr ks">{<br/>   "applications":{<br/>       "postfix" {<br/>           "image": "postfix"<br/>       }<br/>   },<br/>       "layers": {<br/>           "djangoapp":{<br/>               "applications":<br/>               {<br/>                   "db": {<br/>                       "image": "postgres"<br/>                   },<br/>                   "web": {<br/>                       "image": "my-djangoapp",<br/>                       "command": "python manage.py runserver 0.0.0.0:8000",<br/>                       "volumes": [<br/>                           "/data:/data"<br/>                           ],<br/>                       "ports": [<br/>                           "8000:8000"<br/>                           ],<br/>                       "links": [<br/>                           "db"<br/>                           ]<br/>                   }<br/>               }<br/>           }<br/>       }<br/>}</span></pre><p id="199c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有了上面的json，OpsWorks堆栈上的每个EC2实例都会运行容器后缀，只有名为“djangoapp”的层上的EC2实例会运行postgres，而<br/>会运行my-djangoapp图像。</p><p id="be7f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个“特性”还扩展到了我<br/>提到的其他方法(更改标签、route53条目、nfs挂载…)，所以OpsWorks堆栈上真正<br/>完整的定制JSON应该是这样的:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="77ca" class="kn ko hu kj b fv kp kq l kr ks">{<br/>   "tags"{<br/>       "Product": "Django example"<br/>   },<br/>   "applications":{<br/>       "postfix" {<br/>           "image": "postfix"<br/>       }<br/>   },<br/>   "layers": {<br/>       "djangoapp":{<br/>           "tags": {<br/>               "Service": "the application"<br/>           },<br/>           "applications":<br/>           {<br/>               "db": {<br/>                   "image": "postgres"<br/>               },<br/>               "web": {<br/>                   "image": "my-djangoapp",<br/>                   "command": "python manage.py runserver 0.0.0.0:8000",<br/>                   "volumes": [<br/>                       "/data:/data"<br/>                       ],<br/>                   "ports": [<br/>                       "8000:8000"<br/>                       ],<br/>                   "links": [<br/>                       "db"<br/>                       ]<br/>               }<br/>           }<br/>       }<br/>   }<br/>}</span></pre><p id="04fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我将很快准备一个Youtube视频，一步一步地描述这个过程，为那些没有OpsWorks和厨师知识的人提供帮助。</p><p id="a87c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">与此同时，Thiago Nache正在提供我们写在他的bitbucket上的docker-compose食谱。你还可以在<a class="ae jp" href="https://bitbucket.org/fbueno/opsworks-recipes" rel="noopener ugc nofollow" target="_blank">矿</a>上找到一个工作叉。</p><blockquote class="kt ku kv"><p id="3648" class="ir is kw it b iu iv iw ix iy iz ja jb kx jd je jf ky jh ji jj kz jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是阿妹家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>的机会。</p><p id="dca4" class="ir is kw it b iu iv iw ix iy iz ja jb kx jd je jf ky jh ji jj kz jl jm jn jo hn dt translated">要了解更多信息，请阅读我们的“关于”页面、<a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">喜欢/在脸书上给我们发消息</a>，或者简单地发送<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is kw it b iu iv iw ix iy iz ja jb kx jd je jf ky jh ji jj kz jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ke kf kg kh fq la"><div class="bz el l di"><div class="lb lc l"/></div></figure></div></div>    
</body>
</html>