<html>
<head>
<title>From GWT to AngularDart: a case study with source code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从GWT到安古拉达特:一个有源代码的案例研究</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/from-gwt-to-angulardart-a-case-study-with-source-code-a049ba8b6df3?source=collection_archive---------6-----------------------#2017-03-10">https://medium.com/hackernoon/from-gwt-to-angulardart-a-case-study-with-source-code-a049ba8b6df3?source=collection_archive---------6-----------------------#2017-03-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="47a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">今年早些时候，有人问我是否有一个好方法来比较在<a class="ae jp" href="http://www.gwtproject.org/" rel="noopener ugc nofollow" target="_blank"> Google Web Toolkit </a> (GWT)和<a class="ae jp" href="https://www.dartlang.org/" rel="noopener ugc nofollow" target="_blank"> Dart </a>，特别是<a class="ae jp" href="https://webdev.dartlang.org/angular" rel="noopener ugc nofollow" target="_blank"> AngularDart </a>中开发web UIs。在与GWT和达特合作之后，我对它们的区别有了很好的了解，但随着我思考得越来越多，我开始怀疑将一个GWT应用程序移植到AngularDart会有多难。这篇文章描述了我在做这件事时的发现。</p><p id="e4e0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">GWT <a class="ae jp" href="http://samples.gwtproject.org/samples/Mail/Mail.html" rel="noopener ugc nofollow" target="_blank">邮件示例</a>是一个理想的起点:它不仅仅是一个简单的例子，具有多样的特性和复杂的UI交互，但是它的大小仍然是可管理的。</p><p id="ab74" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你赶时间，可以看看<a class="ae jp" href="https://isoos.github.io/gwt_mail_sample/" rel="noopener ugc nofollow" target="_blank">工作演示</a>和<a class="ae jp" href="https://github.com/isoos/gwt_mail_sample" rel="noopener ugc nofollow" target="_blank">源代码</a>，或者滚动到底部查看结论。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/ec0b172efcd41bcde0fd0bcaa7cfe6d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YHuMnCE4LRdEV_VSxgs3EQ.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Screenshot of the <a class="ae jp" href="https://isoos.github.io/gwt_mail_sample/" rel="noopener ugc nofollow" target="_blank">demo</a>.</figcaption></figure><h1 id="a0a0" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">迁移的方法</h1><p id="1a36" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">我在没有任何自动化编译器的情况下完成了移植。虽然可以编写一个工具来自动将GWT模板转换成Angular，或者将支持Java代码转换成Dart，但我不建议这样做。模板、样式或Java代码使用的模式很可能更适合新方法。我将在下一节列出其中的一些新方法。</p><p id="eea2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的过程非常简单。我将GWT和AngularDart代码放在同一个git存储库中，并执行了以下循环:</p><ol class=""><li id="b783" class="lj lk hu it b iu iv iy iz jc ll jg lm jk ln jo lo lp lq lr dt translated">从GWT代码库中选择一个小型或中型的代码块。通常这是一个单独的部件，或者是一个复杂部件的一小部分。</li><li id="cdf0" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">仔细研究代码中的特性和边缘情况。大多数专有代码库都是一些人塞进去的边缘案例。如果有5个以上的边缘情况，这很好地表明任务太大，需要分成多个块。</li><li id="d30c" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">在AngularDart中实现所选零件。这听起来很简单，因为很简单。:-)</li><li id="8f25" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">从GWT代码库中删除所选零件。GWT应用程序将不再构建，但是您可以轻松地跟踪尚未迁移的部分。</li></ol><p id="d1c5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以通过观察<a class="ae jp" href="https://github.com/isoos/gwt_mail_sample/commits/master" rel="noopener ugc nofollow" target="_blank">提交历史</a>，或者通过查看<a class="ae jp" href="https://github.com/isoos/gwt_mail_sample/blob/master/log.md" rel="noopener ugc nofollow" target="_blank"> log.md </a>文件来检查我的进度和每个步骤，我在做修改的时候一直在写这个文件。一个有趣的观察:<strong class="it hv">写下更改比在AngularDart </strong>中实现代码花费更多的时间。</p><h1 id="104a" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">旧解决方案与新解决方案</h1><p id="b5a3" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">大部分的迁移都很简单:简单的模板和样式可以很容易地映射到它们对应的角度。我不会在微小的细节上浪费你的时间；相反，我将只谈论不同的部分。</p><p id="35a8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第一个也是最明显的区别是设计:Angular版本使用了<a class="ae jp" href="https://pub.dartlang.org/packages/angular2_components" rel="noopener ugc nofollow" target="_blank"> angular2_components </a>包中的材质小部件。这个包有很多有用的组件，如果你是从AngularDart开始，你应该试着使用它。虽然这两个堆栈都有大量可供选择的现成组件，并且大多数组件在特性和设置方面都有1:1的映射，但有时您需要自己判断使用或选择哪一个。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lx ly l"/></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Watch the new version alongside the old one. AngularDart Components make it easy to have nice animations and consistent component views.</figcaption></figure><p id="3aab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我错过了AngularDart组件中还没有的一些东西，比如表和树组件。然而，正如你在日志中看到的，用Angular的<code class="eh lz ma mb mc b">*ngFor</code>模板实现它们真的很容易。例如，邮件条目列表由下面的模板处理，这比MailList.java<a class="ae jp" href="https://github.com/isoos/gwt_mail_sample/blob/master/gwt/original/src/com/google/gwt/sample/mail/client/MailList.java" rel="noopener ugc nofollow" target="_blank">中GWT的表初始化简单得多:</a></p><pre class="jr js jt ju fq md mc me mf aw mg dt"><span id="c359" class="mh kh hu mc b fv mi mj l mk ml">&lt;div *ngFor="let item of items"<br/>     class="row"<br/>     (click)="selectRow(item)"<br/>     [class.selected]="isSelectedRow(item)"&gt;<br/>  &lt;div class="col sender"&gt;{{item.sender}}&lt;/div&gt;<br/>  &lt;div class="col email"&gt;{{item.email}}&lt;/div&gt;<br/>  &lt;div class="col subject"&gt;{{item.subject}}&lt;/div&gt;<br/>  &lt;material-ripple&gt;&lt;/material-ripple&gt;<br/>&lt;/div&gt;</span></pre><p id="91a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我被告知团队正在开源更多的组件；祈祷一个更复杂的表将很快被包含进来。</p><p id="4629" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不太有趣，但一个重要的区别是缺少静态变量和对单例实例的处理。在GWT版本中，电子邮件列表存储在MailItems.java<a class="ae jp" href="https://github.com/isoos/gwt_mail_sample/blob/master/gwt/original/src/com/google/gwt/sample/mail/client/MailItems.java" rel="noopener ugc nofollow" target="_blank">的静态字段中。在Dart版本中，相同(以及更多)的功能由</a><a class="ae jp" href="https://github.com/isoos/gwt_mail_sample/blob/master/lib/mail/mail_service.dart" rel="noopener ugc nofollow" target="_blank"> MailService </a>处理，它是注入的，更适合单元测试。</p><p id="80be" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了更容易开发(也是为了匹配GWT版本)，我从一个<a class="ae jp" href="https://github.com/isoos/gwt_mail_sample/blob/master/lib/mail/mock_mail_service.dart" rel="noopener ugc nofollow" target="_blank">模拟</a>实现开始，之后很容易在web客户端后面插入一个真正的API。例如，配置注入就像下面的代码一样简单。切换到真正的实现将只是改变它的<code class="eh lz ma mb mc b">useValue:</code>部分。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff mm"><img src="../Images/f1f61f5ea0f0f96c4417a6416ab01a78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*WoBG7hyDQVbaHxczerYcag.jpeg"/></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Change to real implementation when ready.</figcaption></figure><p id="e081" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从更主观的角度来说，我发现AngularDart在代码、HTML模板和CSS样式的分离方面比GWT好得多。GWT代码库允许在Java代码中加入样式细节和模板构造，而这些部分是最难移植到更简洁版本的。</p><h1 id="dae6" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">数字的最终结果</h1><p id="a73f" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">虽然AngularDart版本有更多的功能，我也实现了像tree这样的定制组件，但总的来说，它比GWT版本的代码少。取决于你如何计算，<strong class="it hv">代码大小减少了30% </strong>。</p><p id="b1da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我使用Dartium开发应用程序，所以我不需要将Dart代码编译成JavaScript一切都是通过低延迟的类型-保存-刷新周期完成的。然而，最终结果需要被编译成JS，并且它可能提供比较数字的值。在我的Macbook Pro上，GWT应用程序的编译时间是:</p><ul class=""><li id="0e86" class="lj lk hu it b iu iv iy iz jc ll jg lm jk ln jo mn lp lq lr dt translated">1次置换需要26秒，</li><li id="6fc4" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo mn lp lq lr dt translated">如果Java源代码已经编译，则为11秒，并且</li><li id="07e0" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo mn lp lq lr dt translated">所有5种排列需要40秒。</li></ul><p id="fd67" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Dart版本花了大约15-20秒编译成跨浏览器的ES5。这并不是非常快，但是比GWT编译器快<strong class="it hv">。</strong></p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mo"><img src="../Images/f588881558835e1eb9863bcbb14593ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SmWkJptugz-EKA-MNFt8oQ.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Compile times (in seconds)</figcaption></figure><p id="dd19" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，关于输出JavaScript的大小有一些注意事项。GWT编译器为每个排列产生不同的JS版本(目标浏览器)，而Dart编译器只发出一个编译版本。GWT的输出大约是207 KB /排列(当压缩时，所有5，84kb/排列总共100万)，而AngularDart版本的输出是689 KB(压缩了178 KB)。</p><p id="5e7a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">考虑到应用程序逻辑更加复杂(例如:多样化的小部件、涟漪、更详细的邮件项目处理)，较大的JS大小并不令人惊讶，尽管我希望它会更小。对我们来说幸运的是，其中很大一部分是“固定成本”，额外的组件只增加了一点点大小(与其复杂性成比例)。</p><h1 id="5137" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">结论</h1><p id="68a2" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">这两种技术都源于Google，都能够支持更大的团队规模，但是它们代表了两个非常不同的时代。我发现GWT代码更难阅读和推理；AngularDart版本对我来说更紧凑更简单。但是不要盲目相信我的观点。我强烈建议你<a class="ae jp" href="https://isoos.github.io/gwt_mail_sample/" rel="noopener ugc nofollow" target="_blank">亲自试用</a>该应用程序并检查<a class="ae jp" href="https://github.com/isoos/gwt_mail_sample" rel="noopener ugc nofollow" target="_blank">源代码</a>。</p><p id="6282" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我还发现材料成分令人耳目一新，大多数时候它们都不碍事。相比之下，设计和定制GWT组件更难，需要的时间花在应用程序本身上会更好。</p><p id="9c4c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你想把你的GWT应用迁移到更新的T4技术上，AngularDart是一个可行的选择。毕竟，<a class="ae jp" href="https://hackernoon.com/tagged/google" rel="noopener ugc nofollow" target="_blank">谷歌</a>也在做同样的事情:他们正在将关键应用从GWT迁移到Dart(见他们的<a class="ae jp" href="http://news.dartlang.org/2016/10/google-adsense-angular-dart.html" rel="noopener ugc nofollow" target="_blank"> AdSense </a>和<a class="ae jp" href="http://news.dartlang.org/2016/03/the-new-adwords-ui-uses-dart-we-asked.html" rel="noopener ugc nofollow" target="_blank"> AdWords </a>采访)。</p><div class="jr js jt ju fq ab cb"><figure class="mp jv mq mr ms mt mu paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mp jv mq mr ms mt mu paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mp jv mq mr ms mt mu paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mv mw mx"><p id="f922" class="ir is my it b iu iv iw ix iy iz ja jb mz jd je jf na jh ji jj nb jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是AMI家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is my it b iu iv iw ix iy iz ja jb mz jd je jf na jh ji jj nb jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff nc"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="nd ly l"/></div></figure></div></div>    
</body>
</html>