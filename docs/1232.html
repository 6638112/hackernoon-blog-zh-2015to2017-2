<html>
<head>
<title>Node.js, TC-39, and Modules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js、TC-39和模块</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/node-js-tc-39-and-modules-a1118aecf95e?source=collection_archive---------0-----------------------#2016-09-29">https://medium.com/hackernoon/node-js-tc-39-and-modules-a1118aecf95e?source=collection_archive---------0-----------------------#2016-09-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="6304" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本周，我参加了第一次TC-39会议。对于那些不知道的人来说，TC-39是定义ECMAScript语言(或更常见的“JavaScript ”)的ECMA工作组的代号。在这个论坛上，JavaScript语言的各种细微差别和细节都得到了解决(通常很痛苦),以确保JavaScript编程语言继续发展，继续满足开发人员的需求。</p><p id="cb11" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我本周参加TC-39会议的原因很简单:TC-39定义的一个较新的JavaScript语言特性——即模块——给Node.js核心团队带来了一点麻烦。我们(我说的我们主要是指Bradley Farias——Twitter上的@bradleymeck)一直在试图找出如何在Node.js中最好地实现对ECMAScript模块(ESM)的支持，而不会造成不必要的麻烦和混乱。</p><p id="2824" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">问题并不在于我们不能以规范当前定义的方式在Node.js中实现ESM，而是按照规范的字面意思来做将意味着预期功能的减少和Node.js开发人员的次优体验。我们非常希望确保Node.js中的ESM实现既优化又可用。由于所涉问题的复杂性，与TC-39成员面对面坐下来谈判被认为是最有成效的前进道路。幸运的是，我认为我们取得了一些重大进展。</p><p id="8093" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，为了理解事情的现状和发展方向，让我花些时间来解释一下哪些基本问题引起了我们最大的关注。</p><p id="4330" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，首先要提出一个警告:下面的很多内容都是对代码背后实际发生的事情的过度简化。这主要是为了提供一个概述，而不是对模块系统的深入论述。</p><p id="1398" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，另一个警告:这里的一切都是基于我自己对与TC-39对话的感知。我完全有可能弄错了一些细节，对话完全有可能继续发展，事情最终看起来会与我在这里描述的大不相同。我写这些只是为了提供正在讨论的内容的一个快照。</p><h1 id="238a" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">ECMAScript模块vs. CommonJS:或者…什么是模块？</h1><p id="eb6e" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">事实证明，Node.js和TC-39对于什么是“模块”、如何定义它们以及如何将它们加载到内存中并使用它们有着非常不同的想法。</p><p id="e478" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">几乎从一开始，Node.js就有一个模块系统，它是从一个定义相当宽松的规范“CommonJS”中派生出来的。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div class="fe ff ks"><img src="../Images/c9f76ae2eddeb0a0661a43ef89aee993.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*W9dyBkQ7nRT_YiaZupFhaw.png"/></div></figure><p id="707c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">简而言之，一个JavaScript文件导出的符号(如函数和变量)可供另一个JavaScript文件使用。在Node.js中，这是使用<em class="la"> require() </em>函数完成的。当在Node.js中调用类似于<em class="la"> require("foo") </em>的调用时，会执行一系列非常特殊的步骤。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="fe ff lb"><img src="../Images/07b5b19b63ef998330790f1bdd8f74ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rn5xTqjKdPZuG7VnqMzN1w.png"/></div></div></figure><p id="0d40" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第一步是将说明符<em class="la">“foo”</em>解析为Node.js理解的某种工件的绝对文件路径。这个解析过程涉及多个内部步骤，这些步骤基本上是遍历本地文件系统，寻找任何恰好匹配的本机模块、JavaScript文件或JSON文档。解析步骤的结果是一个绝对文件路径，通过这个路径，由<em class="la"> "foo" </em>指定的工件可以被加载到Node.js中并被使用。</p><p id="e4a8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">加载完全由解析步骤产生的绝对文件路径所指向的内容决定。例如，如果解析路径指向的对象是Node.js本地模块，那么加载就需要将引用的共享库动态链接到当前Node.js进程中。如果指向的是一个JSON文件或JavaScript文件，那么在文件被验证存在后，文件的内容被读入内存。值得注意的是，加载JavaScript与评估JavaScript是不同的。前者严格处理将文件的字符串内容放入内存，而后者处理将字符串传递给JavaScript VM进行解析和评估。</p><p id="9018" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果加载的工件是一个JavaScript文件，那么Node.js当前假设该文件是一个CommonJS模块。Node.js下一步做什么是至关重要的，并且经常被创建Node.js应用程序的开发人员误解。在将加载的JavaScript字符串传递给JavaScript VM进行评估之前，字符串被<em class="la">包装在函数</em>中。</p><p id="0cee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，文件"<em class="la"> foo.js </em>"例如:</p><pre class="kt ku kv kw fq lg lh li lj aw lk dt"><span id="f121" class="ll jq hu lh b fv lm ln l lo lp">const m = 1;<br/>module.exports.m = m;</span></pre><p id="b0a7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">实际上由Node.js作为一个函数进行评估，如下所示:</p><pre class="kt ku kv kw fq lg lh li lj aw lk dt"><span id="23ec" class="ll jq hu lh b fv lm ln l lo lp">function (exports, require, module, __filename, __dirname) {<br/>  const m = 1;<br/>  module.exports.m = m;<br/>}</span></pre><p id="dbbf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Node.js然后使用JavaScript运行时来评估这个函数。Node.js模块中常用的各种“全局”工件，如“<em class="la">导出</em>”、“<em class="la">模块</em>”、“<em class="la">_ _文件名</em>”和“<em class="la">_ _目录名</em>”，并不是传统JavaScript意义上的真正全局。相反，它们是函数参数，当调用函数时，Node.js会将这些参数的值提供给包装的函数。</p><p id="5a03" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个包装函数本质上是一个<em class="la">工厂</em>方法。导出对象是一个常规的JavaScript对象。包装函数将函数和属性附加到导出对象。一旦包装函数返回，exports对象被缓存，然后作为<em class="la"> require() </em>方法的返回值返回。</p><p id="d8e6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于这个特殊的讨论，需要理解的关键概念是，在包装器函数被求值之前，无法预先确定CommonJS模块将导出哪些符号。</p><p id="19b6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是CommonJS模块和ECMAScript模块之间的一个关键区别，因为CommonJS模块的导出是在评估包装函数时动态定义的，而ESM的导出是按词汇定义的<em class="la"/>。也就是说，ESM导出的符号是在JavaScript代码被实际评估之前进行<em class="la">解析</em>时确定的。</p><p id="1748" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，给定以下简单的ECMAScript模块:</p><pre class="kt ku kv kw fq lg lh li lj aw lk dt"><span id="e6a5" class="ll jq hu lh b fv lm ln l lo lp">export const m = 1;</span></pre><p id="ca61" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当这个代码被<em class="la">解析</em>时，但是在它被评估之前，一个叫做模块记录的内部结构被创建。在这个模块记录中，除了其他关键信息位之外，还有一个由模块输出的符号的静态列表。这些由寻找使用<em class="la"> export </em>关键字的解析器识别。由于缺乏更好的术语，模块记录中的符号本质上是指向尚不存在的事物的指针。只有在构造了这个模块记录之后，才真正评估模块代码。虽然这里隐藏了许多我要掩盖的细节，但关键是确定ESM输出什么符号发生在评估之前<em class="la">。</em></p><p id="e7ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当代码使用ECMAScript模块时，它使用一个<em class="la"> import </em>语句:</p><pre class="kt ku kv kw fq lg lh li lj aw lk dt"><span id="35f5" class="ll jq hu lh b fv lm ln l lo lp">import {m} from “foo”;</span></pre><p id="df12" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这段代码基本上是在说，“我将使用模块‘foo’导出的m符号”。</p><p id="d980" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该语句是一个<em class="la">词法</em>语句，用于在<em class="la">解析</em>代码时，在导入脚本和<em class="la"> foo </em>模块之间建立链接。按照目前编写ECMAScript模块规范的方式，在评估任何代码之前必须验证这个链接，这意味着在评估两个JavaScript文件之前，实现必须确保符号“m”确实是由“foo”导出的。</p><p id="700d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于熟悉强类型面向对象编程语言(如Java或C++)的人来说，这应该很熟悉，因为它类似于通过接口处理对象。导出的符号在执行前被验证和链接，如果符号在执行步骤中没有实际完成，将会抛出错误。</p><p id="b951" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于Node.js，当"<em class="la"> foo </em>"不是一个具有一组词汇定义的导出的ESM，而是一个具有一组动态定义的导出的CommonJS模块时，挑战就出现了。具体来说:当我说<em class="la">从【foo】</em>进口{m}时，ESM目前要求在评估之前能够确定<em class="la"> m </em>是由<em class="la"> foo </em>出口的；但是正如我们已经看到的，因为"<em class="la"> foo </em>"是一个CommonJS模块，所以在求值之后的<em class="la">之前，不可能确定<em class="la"> m </em>被导出。最终结果是CommonJS的命名导出和导入(ECMAScript模块的一个非常重要的特性)在当前定义的ESM规范下根本不可能实现。</em></p><p id="9e57" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这不是特别理想，所以我们(Node.js的人)回到TC-39，询问是否可以在规范中做一些改变。起初，我们有点不敢问。然而，事实证明TC-39非常关心确保Node.js可以有效地实现ESM，并且正在考虑对规范进行一些更改，以便在Node.js环境中更好地工作。</p><h1 id="d0ed" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">操作顺序</h1><p id="95d5" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">提议的一个具体变化是考虑动态定义的模块。本质上，当我从" foo" 执行<em class="la"> import {m}时，结果是"<em class="la"> foo </em>"不是一个带有<em class="la">词汇上</em>定义的导出的ESM，而不是抛出一个错误并放弃(这正是规范当前所做的),该过程将把"<em class="la"> foo </em>和导入脚本置于一种中间挂起状态，推迟对导入符号的验证，直到可以评估动态模块的代码。一旦评估完成，CommonJS模块的模块记录就可以完成，导入的链接也可以被验证。对ECMAScript模块标准的修改允许从CommonJS模块进行命名导出和导入。(尽管如此，对于一些循环依赖边缘情况，还是有一些问题)。</em></p><p id="755c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们看几个例子。</p><p id="2b4e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我有一个应用依赖于ESM A，它依赖于CommonJS模块b。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div class="fe ff lq"><img src="../Images/d1bf3d15d70aabc205e8b38fd9bfbb7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:250/format:webp/1*qIzBmArjTZUBuf5DMGCAqA.png"/></div></figure><p id="0f99" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的应用程序(<em class="la"> myapp.js </em>)的代码是:</p><pre class="kt ku kv kw fq lg lh li lj aw lk dt"><span id="0bb2" class="ll jq hu lh b fv lm ln l lo lp">const foo = require('A').default<br/>foo()</span></pre><p id="094d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">A的代码是:</p><pre class="kt ku kv kw fq lg lh li lj aw lk dt"><span id="e8f0" class="ll jq hu lh b fv lm ln l lo lp">import {log} from "B"<br/>export default function() {<br/>  log('hello world')<br/>}</span></pre><p id="9c5a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">B的代码是:</p><pre class="kt ku kv kw fq lg lh li lj aw lk dt"><span id="48ec" class="ll jq hu lh b fv lm ln l lo lp">module.exports.log = function(msg) {<br/>  console.log(msg);<br/>}</span></pre><p id="6844" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我运行<em class="la"> node myapp.js </em>时，对require(‘A’)的调用会检测到正在加载的东西是一个ESM(见下文，了解如何进行这种检测)。Node.js将使用ECMAScript模块规范来解析、初始化和评估“A ”,而不是使用当前用于CommonJS模块的包装函数来加载模块。当解析“A”的代码并创建模块记录时，它将检测到“B”不是ESM，因此验证日志由“B”导出的验证步骤将挂起。然后，ESM加载程序将开始其评估阶段。这将首先使用现有的CommonJS包装函数评估B，其结果将被传递回ESM加载程序以完成模块记录的构造。其次，它将使用完整的模块记录来评估代码“A”。</p><p id="4dfb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">改变依赖关系的顺序怎么样？假设A是一个CommonJS，B是一个ESM。这里，事情只是工作，不需要做任何特殊的事情，因为如上面的例子所示，可能需要()一个ESM。</p><p id="8160" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于绝大多数基本用例来说，这种加载模型应该工作得很好。当模块之间存在依赖循环时，事情就变得棘手了。任何以前使用过带有循环依赖的CommonJS模块的人都知道，根据这些模块的加载顺序，会出现一些相当奇怪的边缘情况。在CommonJS模块和ESM之间存在依赖循环的情况下，会存在许多相同类型的问题。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div class="fe ff lq"><img src="../Images/2885f70e3df0e02307e41de5f787f189.png" data-original-src="https://miro.medium.com/v2/resize:fit:250/format:webp/1*nlAEac3ZEDiN8Q7c04RgpQ.png"/></div></figure><p id="9f58" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">myapp.js的代码与上面的一样。然而，A依赖于B，B又依赖于A。</p><p id="2a06" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">的代码是:</p><pre class="kt ku kv kw fq lg lh li lj aw lk dt"><span id="fa63" class="ll jq hu lh b fv lm ln l lo lp">const b = require('B')<br/>exports.b = b.foo()<br/>exports.a = 1</span></pre><p id="d9b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">B的代码是:</p><pre class="kt ku kv kw fq lg lh li lj aw lk dt"><span id="9344" class="ll jq hu lh b fv lm ln l lo lp">import {a} from "A"<br/>export const foo () =&gt; a</span></pre><p id="8696" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个相当人为的案例，主要是为了说明这个问题。这种循环在很大程度上变得不可能实现，因为当ESM“B”被链接和评估时，符号“A”还没有被CommonJS模块“A”定义和导出。这种类型的情况可能<em class="la">有</em>被视为参考误差。</p><p id="0f7a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，如果我们将B的代码改为:</p><pre class="kt ku kv kw fq lg lh li lj aw lk dt"><span id="8fab" class="ll jq hu lh b fv lm ln l lo lp">import A from “A”<br/>export foo () =&gt; A.a</span></pre><p id="e126" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">循环依赖之所以有效，是因为当使用import语句导入CommonJS模块时，module.exports对象变成了默认的<em class="la">导出。在这种情况下，ESM代码链接到CommonJS模块的默认导出，而不是链接到符号。</em></p><p id="f5d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">更简洁地说:只有在ESM和CommonJS模块之间不存在依赖循环的情况下，来自CommonJS模块的命名导入才会起作用。</p><p id="204b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">CommonJS和ESM之间的差异导致的另一个限制是，在初始评估之后，CommonJS导出的任何突变都不会作为命名导入提供。例如，假设ESM A依赖于CommonJS模块b。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div class="fe ff lq"><img src="../Images/e0ca691bc054a2c469578b7428775e5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:250/format:webp/1*3FF4cRyiwTsfgHEeESgeHg.png"/></div></figure><p id="eb79" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设B的代码是:</p><pre class="kt ku kv kw fq lg lh li lj aw lk dt"><span id="3226" class="ll jq hu lh b fv lm ln l lo lp">module.exports.foo = function(name, key) {<br/>  module.exports[name] = key<br/>}</span></pre><p id="1e4f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当“B”由“A”导入时，可用作命名导入的唯一导出符号将是默认符号和“<em class="la"> foo </em>”。调用foo函数时添加到module.exports中的任何符号都不能作为命名导入使用。但是，它们可以通过默认导出获得。例如，以下内容应该可以正常工作:</p><pre class="kt ku kv kw fq lg lh li lj aw lk dt"><span id="654e" class="ll jq hu lh b fv lm ln l lo lp">import {foo} from “B”<br/>import B from "B"<br/>foo("abc", 123)<br/>if (B.abc === 123) { /** ... **/ }</span></pre><h1 id="72ea" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">require()与import</h1><p id="d245" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">关于<em class="la"> require() </em>和<em class="la"> import </em>有一个非常明显的区别:虽然可以使用<em class="la"> require() </em>加载ESM，并且可以使用<em class="la"> import </em>导入CommonJS模块，但是不能从CommonJS模块内部使用<em class="la"> import </em>语句；默认情况下，<em class="la"> require() </em>在ESM中不可用。</p><p id="ca6e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">换句话说，如果我有一个CommonJS模块A，下面的代码将<strong class="it hv"> <em class="la">而不是</em> </strong>是可能的，因为import语句在CommonJS中是不可用的:</p><pre class="kt ku kv kw fq lg lh li lj aw lk dt"><span id="d05a" class="ll jq hu lh b fv lm ln l lo lp">const b = require(‘B’)<br/>import c from "C"</span></pre><p id="adb0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果在CommonJS模块中操作，加载和使用ESM的正确方法是使用require:</p><pre class="kt ku kv kw fq lg lh li lj aw lk dt"><span id="74f2" class="ll jq hu lh b fv lm ln l lo lp">const b = require(‘B’)<br/>const c = require('C')</span></pre><p id="e3dd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在ESM中，require()只有在专门导入的情况下才可用。用于导入require()的确切说明符尚未确定，但本质上应该是这样的:</p><pre class="kt ku kv kw fq lg lh li lj aw lk dt"><span id="374a" class="ll jq hu lh b fv lm ln l lo lp">import {require} from “nodejs”<br/>require(“foo”)</span></pre><p id="b18b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，因为可以直接从CommonJS模块导入，所以这样做的理由应该很少。</p><p id="816c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">作为一个边节点:Node.js人员有许多其他的顾虑，比如ESM的加载是否总是<em class="la">有</em>是异步的，这需要在整个依赖图中使用承诺。TC-39向我们保证(并且上面描述的变化允许)装载不必是异步的。这是一件非常好的事情。</p><h2 id="a9fa" class="ll jq hu bd jr lr ls lt jv lu lv lw jz jc lx ly kd jg lz ma kh jk mb mc kl md dt translated">进口呢()</h2><p id="498a" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">TC-39之前有一个提议，将引入一个新的<em class="la"> import() </em>功能。这与上面示例中显示的import语句截然不同。考虑下面的例子:</p><pre class="kt ku kv kw fq lg lh li lj aw lk dt"><span id="a8cb" class="ll jq hu lh b fv lm ln l lo lp">import {foo} from “bar”<br/>import(“baz”).then((module)=&gt;{/*…*/}).catch((err)=&gt;{/**…*/})</span></pre><p id="ab25" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第一个import语句是词法语句。如前所述，当代码被<em class="la">解析</em>时，它被处理和验证。另一方面，import()函数是在求值时处理的。它还导入了一个ESM(或CommonJS模块),但是像目前Node.js中的<em class="la"> require() </em>方法一样，完全在评估期间运行。然而，与<em class="la"> require() </em>不同的是，<em class="la"> import() </em>返回一个承诺，允许(但不要求)底层模块的加载完全异步地执行。</p><p id="b546" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为<em class="la"> import() </em>函数返回一个承诺，所以像<em class="la">等待导入(" foo") </em>这样的事情将成为可能。但需要注意的是，<em class="la"> import() </em>在TC-39内还远未完成，尚未成熟。也不完全清楚Node.js是否能够使用<em class="la"> import() </em>函数实现完全异步加载。</p><h1 id="ac53" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">检测常见故障与ESM故障</h1><p id="a938" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">无论代码是否使用<em class="la"> require() </em>、<em class="la"> import </em>或<em class="la"> import() </em>来加载模块，都必须能够检测正在导入的内容的种类，以便Node.js能够知道加载和处理它的适当方式。</p><p id="ac0a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">传统上，<em class="la"> require() </em>函数的Node.js实现依赖于文件扩展名来区分如何加载不同类型的东西。比如，<em class="la"> *。节点</em>文件作为本机模块<em class="la"> *加载。json </em>文件只是通过JSON.parse和<em class="la"> *传递。js </em>文件作为CommonJS模块处理。</p><p id="230e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">随着ESM的引入，需要一种机制来区分CommonJS模块和ESM。有几个建议的方法。</p><p id="3c93" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个建议是确保JavaScript文件可以被明确地解析为ESM或其他文件。换句话说，当我解析一小段JavaScript时，解析操作的结果应该很明显地表明它是否是ESM。这种方法被称为“明确语法”。不幸的是，要实现它可能会显得有点棘手。</p><p id="ff3a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">已经考虑过的另一个提议是向<em class="la"> package.json </em>文件添加元数据。如果package.json文件中有某个特定的值，那么该模块将作为ESM而不是CommonJS模块加载。</p><p id="fc5e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第三个建议是使用新的文件扩展名(<em class="la"> *)。mjs </em>)来标识ECMAScript模块。这是与Node.js目前所做的最接近的方法。</p><p id="8873" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，假设我有一个应用程序脚本<em class="la"> myapp.js </em>和一个定义在单独文件中的ESM模块。</p><p id="1890" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用明确的语法方法，Node.js应该能够解析第二个文件中的JavaScript，并自动确定它正在处理ESM。通过这种方法，ESM文件可以使用<em class="la"> *。js </em>文件扩展名之类的东西就可以了。然而，正如我所说的，明确的语法是很难正确理解的，并且有许多边缘情况使得它很难实现。</p><p id="3b81" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用<em class="la"> package.json </em>方法，ESM要么必须捆绑在它自己的目录中(本质上是它自己的包),要么必须在根目录中有一个<em class="la"> package.json </em>,它包含一些元数据，表明包含ESM文件的JavaScript实际上是一个ESM。这种方法不太理想，因为需要对<em class="la"> package.json </em>进行额外的处理。</p><p id="f751" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用<em class="la"> *。mjs </em>文件扩展方式，ESM代码放入类似<em class="la"> foo.mjs </em>的文件中。在Node.js将说明符解析为绝对文件名后，它会查看文件扩展名，就像当前处理原生插件和JSON文件一样。如果它看到了<em class="la"> *。mjs </em>文件扩展名，它知道作为一个ESM来加载和处理这个东西。如果它看到<em class="la"> *。js </em>，但是，它会后退并加载一个CommonJS模块。</p><p id="1705" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在当前时间点，<em class="la"> *。mjs </em>文件扩展名看起来是最可行的选择，除非明确语法的各种边缘情况都能解决。</p><h1 id="95e5" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">幂等问题</h1><p id="65ba" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">一般来说，多次调用<em class="la"> require('foo') </em>会返回完全相同的模块实例。然而，返回的对象是可变的，模块可以通过修改单个方法和符号或者完全替换功能来修改其他模块。这类事情目前在Node.js生态系统中极为常见。</p><p id="eaef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，假设myapp.js有两个依赖项A和b，它们都是CommonJS模块。a也依赖于B，以便扩展它。</p><p id="f6b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">myapp.js的代码是:</p><pre class="kt ku kv kw fq lg lh li lj aw lk dt"><span id="0377" class="ll jq hu lh b fv lm ln l lo lp">const A = require('A')<br/>const B = require('B')<br/>B.foo()</span></pre><p id="dc96" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">的代码是:</p><pre class="kt ku kv kw fq lg lh li lj aw lk dt"><span id="03da" class="ll jq hu lh b fv lm ln l lo lp">const B = require(‘B’)<br/>const foo = B.foo</span><span id="6d97" class="ll jq hu lh b fv me ln l lo lp">B.foo = function() {<br/>  console.log('intercepted!')<br/>  foo()<br/>}</span></pre><p id="f205" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">B的代码是:</p><pre class="kt ku kv kw fq lg lh li lj aw lk dt"><span id="d85d" class="ll jq hu lh b fv lm ln l lo lp">module.exports.foo = function() {<br/>  console.log('foo bar baz')<br/>}</span></pre><p id="398e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这种情况下，在中调用require('B ')返回的结果与在myapp.js中调用require('B ')返回的结果不同。</p><p id="6552" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有了ECMAScript模块，这种跨模块的monkeypatching】就不那么容易了。原因有两个:A)导入在求值之前被链接，B)导入需要是幂等的——每次在给定的上下文中调用导入时，总是返回完全相同的不可变符号集。这在实际意义上意味着，当使用指定的导入时，ESM A不能轻易地篡改ESM B。</p><p id="3a11" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这条规则的效果相当于myapp.js中的以下代码</p><pre class="kt ku kv kw fq lg lh li lj aw lk dt"><span id="3e0f" class="ll jq hu lh b fv lm ln l lo lp">const B = require('B')<br/>const foo = B.foo<br/>const A = require('A')<br/>foo()</span></pre><p id="7d35" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里，模块A仍然修改B中的foo，但是因为对foo的引用是在修改之前获取的，所以对foo()的调用调用了原始函数，而不是修改后的函数。在ESM中，无法导入B来返回a所做的修改。</p><p id="c3c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在许多情况下，这个等幂规则会引起问题。嘲讽、APM和测试目的的间谍就是主要的例子。幸运的是，有很多方法可以解决这个限制。一种方法是在装载阶段增加挂钩，让ESM的出口被包装起来。另一个是TC-39允许装载的ESM在装载后被替换。这里考虑了几种机制。好消息是，虽然拦截ESM与拦截CommonJS模块不同，但拦截<em class="la">将</em>成为可能。</p><h1 id="7942" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">还有很多事要做</h1><p id="5f23" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">有一个<em class="la">吨</em>的额外工作要做，上面讨论的一切都还没有最终在任何意义上。有许多细节需要解决，事情最终可能会变得非常不同。重要的是Node.js和TC-39正在共同努力解决所有这些问题，这是朝着正确方向迈出的非常好和非常受欢迎的一步。</p><div class="kt ku kv kw fq ab cb"><figure class="mf kx mg mh mi mj mk paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mf kx mg mh mi mj mk paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mf kx mg mh mi mj mk paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ml mm mn"><p id="f922" class="ir is la it b iu iv iw ix iy iz ja jb mo jd je jf mp jh ji jj mq jl jm jn jo hn dt translated"><a class="ae mr" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae mr" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae mr" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae mr" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is la it b iu iv iw ix iy iz ja jb mo jd je jf mp jh ji jj mq jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae mr" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae mr" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kt ku kv kw fq kx fe ff paragraph-image"><a href="https://goo.gl/Ahtev1"><div class="fe ff ms"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></a></figure></div></div>    
</body>
</html>