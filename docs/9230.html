<html>
<head>
<title>ECS vs. OOP by example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ECS与OOP对比示例</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/ecs-vs-oop-by-example-daa712b24869?source=collection_archive---------9-----------------------#2017-12-31">https://medium.com/hackernoon/ecs-vs-oop-by-example-daa712b24869?source=collection_archive---------9-----------------------#2017-12-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/a46ac6e38c1ec8524e9f894189db0043.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VPpdS3-4wet6nbJ-3bWfcA.jpeg"/></div></div></figure><p id="fd95" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">昨天我写了一篇<a class="ae ka" rel="noopener" href="/@icex33/when-not-to-use-ecs-48362c71cf47">博文</a>解释，什么时候不用ECS(实体组件系统)。很多人告诉我，尽管这个帖子很有趣，但它非常理论化。所以今天我决定在一个例子上比较用OOP风格和ECS风格写东西的思维过程。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><p id="6d33" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作为一个例子，我想采取一个<strong class="je hv">登录过程</strong>——在你的游戏/应用程序开始之前，用户必须输入用户名和密码，我们将它发送到后端验证，只有这样才可以开始玩/使用应用程序。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><p id="f5bc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先让我们考虑我在SDK团队中，我需要编写一个“模块”,我公司的其他开发人员，甚至其他公司的人都会购买和使用它。在这种情况下，我需要创建一个简单易懂的抽象，它隐藏了复杂性/实现细节。在这种情况下，最好遵循典型的自顶向下的OOP方法。我引入了一个<code class="eh ki kj kk kl b">LogIn</code>类，它是用户的主界面。在最好的情况下，作为用户，我将实例化<code class="eh ki kj kk kl b">LogIn</code>类，在某个时候，它将告诉我用户已成功登录。对我来说，它是一个黑匣子，它将接管UI、网络、持久数据，并可能给我一些可能性来根据一些特殊需求配置它，但除此之外，它几乎是不透明的。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><p id="5a0b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在让我们把我当成一名应用程序开发人员。登录过程只是我需要实现的功能之一。在这种情况下，我宁愿遵循ECS自下而上的方法，在这种方法中，我开始考虑我将需要的数据。不要忘记，数据不仅仅是应用程序状态，它还是事件和依赖关系。</p><p id="1e1e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，根据目前的需求，我们可以假设我们将拥有:</p><ul class=""><li id="069f" class="km kn hu je b jf jg jj jk jn ko jr kp jv kq jz kr ks kt ku dt translated">用户名</li><li id="897d" class="km kn hu je b jf kv jj kw jn kx jr ky jv kz jz kr ks kt ku dt translated">密码</li><li id="aa01" class="km kn hu je b jf kv jj kw jn kx jr ky jv kz jz kr ks kt ku dt translated">发送凭据事件</li><li id="bab3" class="km kn hu je b jf kv jj kw jn kx jr ky jv kz jz kr ks kt ku dt translated">用户令牌，我们从后端获取</li><li id="e52c" class="km kn hu je b jf kv jj kw jn kx jr ky jv kz jz kr ks kt ku dt translated">登录表单呈现器</li></ul><p id="e0a5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们可以考虑联网，如果我们已经有了一些联网的基础设施，我们可以重用它。如果没有，我们可以考虑让它成为登录过程系统的一部分，或者构建一个期望联网请求组件的联网系统。这同样适用于持久性。</p><p id="aae6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从逻辑上讲，我们可以有这样的东西:</p><ul class=""><li id="d862" class="km kn hu je b jf jg jj jk jn ko jr kp jv kq jz kr ks kt ku dt translated">在系统中显示日志</li><li id="4d65" class="km kn hu je b jf kv jj kw jn kx jr ky jv kz jz kr ks kt ku dt translated">发送登录系统</li><li id="9e8a" class="km kn hu je b jf kv jj kw jn kx jr ky jv kz jz kr ks kt ku dt translated">持久令牌系统</li><li id="71d2" class="km kn hu je b jf kv jj kw jn kx jr ky jv kz jz kr ks kt ku dt translated">加载令牌系统</li><li id="e650" class="km kn hu je b jf kv jj kw jn kx jr ky jv kz jz kr ks kt ku dt translated">要求检查凭证系统</li><li id="ebf5" class="km kn hu je b jf kv jj kw jn kx jr ky jv kz jz kr ks kt ku dt translated">通知登录成功的系统</li></ul><p id="ee58" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于我们是自下而上地构建这个系统，我们可以灵活地构建它，并且可以测试，绕过登录过程，或者只测试这个过程的一小部分是很容易的。我们不隐藏状态，我们不把抽象的容易理解的东西放在第一位。我们把问题分解成最小的部分，让它在全局状态下工作。然而，这意味着很难找到通用的解决方案。我们可以说:</p><blockquote class="la lb lc"><p id="ed09" class="jc jd ld je b jf jg jh ji jj jk jl jm le jo jp jq lf js jt ju lg jw jx jy jz hn dt translated">嗯，我们只是将那些组件和类定义放入一个单独的/可重用的模块中。</p></blockquote><p id="693c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但这并不总是那么简单——特别是如果我们的应用程序中有共享的网络组件和系统。此外，它只是一个东西的集合，形成大的东西，用户将需要理解那些小的东西。我们也可以把类似于OOP <code class="eh ki kj kk kl b">LogIn</code>类的东西放在上面，它将聚集/隐藏组件和系统。然后我们有一个面向对象的方法，在它的下面有ECS。这感觉就像一个科学怪人。我想在某些情况下这样做是可以的，但是我相信坚持一种范式是更好的选择。</p><p id="e121" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">说到这里，我才想起自己也曾建造过这样一个弗兰肯斯坦怪物。当我们共享代码进行后端验证时，我们构建了一个无状态的worker，它接收游戏状态、配置、用户事件，并返回新的游戏状态或一个错误，如果事件不可信，我们认为玩家在作弊。这个无状态的工人是我们后端的一个纯粹的功能。在内部，它基于组件和系统对游戏进行了一次小规模的重新模拟。所以FP在外面，ECS在里面。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><p id="4e82" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这段简短的自我反省强调了我之前的<a class="ae ka" rel="noopener" href="/@icex33/when-not-to-use-ecs-48362c71cf47">更理论化的博客文章</a>的结论。这完全是一个思考过程。在FP中，我会专注于不可变状态和转换它的函数。在OOP中，我专注于抽象，定义封装状态和暴露方法的类。在ECS中，我专注于解决给定问题所需的组件和系统，将数据表示提升为解决问题的关键，而不是代码。</p></div></div>    
</body>
</html>