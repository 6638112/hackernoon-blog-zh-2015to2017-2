<html>
<head>
<title>The importance of state ownership in Elm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">榆树市国有制的重要性</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-importance-of-state-ownership-in-elm-72f711ceb244?source=collection_archive---------3-----------------------#2017-06-16">https://medium.com/hackernoon/the-importance-of-state-ownership-in-elm-72f711ceb244?source=collection_archive---------3-----------------------#2017-06-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="e072" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">披露——我没有我在这里提出的所有问题的答案——一如既往，有不止一种方法！</p><p id="9cdb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Elm使用单一状态原子模式来管理状态，这种模式对于使用redux进行反应的用户来说是很熟悉的。当动作发生时，状态被初始化，然后在更新功能中被“修改”。状态通常被传递到视图函数中，以便在构建UI时使用。</p><p id="bf5c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">到目前为止还不错，但是榆树建筑在本质上也是分形的。这意味着通常在一个树中组合这种模式的多个实例。这通常意味着我们的国家也变得等级森严。</p><p id="4cfc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，在一个典型的SPA中，我们可能有这样的结构:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="2446" class="jy jz hu ju b fv ka kb l kc kd">RootComponent<br/>    PageOne<br/>    PageTwo<br/>    PageThree</span></pre><p id="88c1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这代表整个应用程序，然后是每个页面的组件(与应用程序中的每个路线相关)。在这种情况下，通常会创建如下所示的顶级模型:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="de1c" class="jy jz hu ju b fv ka kb l kc kd">type alias Root =<br/>    { pageOne: PageOne.Model<br/>    , pageTwo: PageTwo.Model <br/>    , pageThree: PageThree.Model<br/>    }</span></pre><p id="96ec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个结构可以这样初始化:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="33e4" class="jy jz hu ju b fv ka kb l kc kd">initialiase: Model <br/>initialise =<br/>    { pageOne = PageOne.initialise<br/>    , pageTwo = PageTwo.initialise<br/>    , pageThree = PageThree.initialise<br/>    }</span></pre><p id="16bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个非常有用的模式，因为它使我们能够在页面组件中隐藏页面级模型的结构和初始化逻辑。</p><p id="7e4f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是谁拥有这些数据呢？那是什么意思？我将所有权定义如下:如果数据仅在组件更新功能中更新，则组件拥有数据。所以RootComponent的更新函数可能如下所示:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="619a" class="jy jz hu ju b fv ka kb l kc kd">update: Msg -&gt; Model -&gt; (Model, Cmd Msg)<br/>update msg model =<br/>    case msg of<br/>        PageOneMsg sub -&gt;<br/>            let<br/>                (subModel, subCmd) =<br/>                    PageOne.update sub model.pageOne<br/>            in<br/>                ( { model | pageOne = subModel }<br/>                , Cmd.map PageOneMsg subCmd )<br/>    ...</span></pre><p id="b650" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们认为这是纯粹的样板文件，即我们只是委托给PageOne组件的更新功能，我们知道它负责修改其模型以响应操作。</p><p id="d69e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是如果事情没有那么简单(从来都不是这样)呢？假设我们有一个用户的概念，这通常是一个根级别的问题。这可能会将我们的RootComponent的模型更改为如下所示。</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="c4ea" class="jy jz hu ju b fv ka kb l kc kd">type alias Root =<br/>    { <strong class="ju hv">user: User</strong><br/>    , pageOne: PageOne.Model<br/>    , pageTwo: PageTwo.Model <br/>    , pageThree: PageThree.Model<br/>    }</span></pre><p id="cf21" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于我们来说，想要访问应用程序所有级别的用户信息是很常见的。那么我们如何实现这一点呢？PageOne的视图函数是通过PageOne传递的。模型，因此它不能访问RootComponent。模型的用户属性。我们自然倾向于将用户属性放在第一页。模特也是。</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="01f9" class="jy jz hu ju b fv ka kb l kc kd">initialiase: <strong class="ju hv">User </strong>-&gt; Model <br/>initialise <strong class="ju hv">user </strong>=<br/>    { pageOne = PageOne.initialise <strong class="ju hv">user</strong><br/>    , pageTwo = PageTwo.initialise <strong class="ju hv">user</strong><br/>    , pageThree = PageThree.initialise <strong class="ju hv">user</strong><br/>    }</span></pre><p id="54d8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">只要用户从不改变，这是没问题的。如果在应用程序的生命周期中有可能改变数据的事件，那么你已经为自己制造了一个你可能还没有注意到的问题。</p><p id="a763" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">问题在于所有权。你现在有两个版本的真相。RootComponent的模型和PageOne的模型。让我们假设我们的用户退出。谁处理这种类型的行动？很可能是根组件:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="2f0b" class="jy jz hu ju b fv ka kb l kc kd">update: Msg -&gt; Model -&gt; (Model, Cmd Msg)<br/>update msg model =<br/>    case msg of<br/>        SignOut -&gt;<br/>            ( { model | user = signOut model.user }<br/>            , Cmd.none )<br/>    ...</span></pre><p id="5000" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以在这种情况下，我们会说RootComponent <em class="ke">拥有</em>用户状态。上面代码的问题是，它没有更新我们也添加到PageOne模型中的用户副本。我们有两个真相来源，但它们突然不同步了。希望我们至少注意到了。</p><p id="88eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设我们注意到了，我们该怎么办？</p><h1 id="ed75" class="kf jz hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">同步数据？</h1><p id="d4ae" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">我们似乎在说，当在RootComponent中发生签出动作时，我们也需要更新某些子组件的模型。一种选择是简单地在RootComponent的更新函数中这样做。</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="bb03" class="jy jz hu ju b fv ka kb l kc kd">update : Msg -&gt; Model -&gt; ( Model, Cmd Msg )<br/>update msg model =<br/>    case msg of<br/>        SignOut -&gt;<br/>            let<br/>                pageOne =<br/>                    model.pageOne</span><span id="cd76" class="jy jz hu ju b fv lh kb l kc kd">                signedOut =<br/>                    signOut model.user<br/>            in<br/>                ( { model<br/>                    | user = signedOut<br/>                    , pageOne = { pageOne | user = signedOut }<br/>                  }<br/>                , Cmd.none<br/>                )</span></pre><p id="26d0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这有什么不好？一些事情。首先，我们打破了我们的封闭性。RootComponent现在需要知道PageOne模型的结构。这使得PageOne模型更难改变。其次，忘记做这件事太容易了。我们的问题不会马上显现出来。</p><p id="8225" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们也许可以通过将<em class="ke">如何</em>更新PageOne的模型委托给PageOne实用函数来解决第一个问题。</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="aff8" class="jy jz hu ju b fv ka kb l kc kd">update : Msg -&gt; Model -&gt; ( Model, Cmd Msg )<br/>update msg model =<br/>    case msg of<br/>        SignOut -&gt;<br/>            let<br/>                signedOut =<br/>                    signOut model.user<br/>            in<br/>                ( { model<br/>                    | user = signedOut<br/>                    , <strong class="ju hv">pageOne = PageOne.updateUser signedOut</strong><br/>                  }<br/>                , Cmd.none<br/>                )</span></pre><p id="1689" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这样更好。我们重新获得了封装。但是更严重的问题依然存在。没有什么能阻止我们忘记做这件事。</p><p id="b124" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个函数<code class="eh li lj lk ju b">PageOne.updateUser</code>看起来很像普通更新函数的特殊形式，不是吗？如果我们只是调用普通的更新函数，会不会更合适呢？</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="024b" class="jy jz hu ju b fv ka kb l kc kd">update : Msg -&gt; Model -&gt; ( Model, Cmd Msg )<br/>update msg model =<br/>    case msg of<br/>        SignOut -&gt;<br/>            let<br/>                signedOut =<br/>                    signOut model.user</span><span id="b22c" class="jy jz hu ju b fv lh kb l kc kd">                ( pageOne, pageOneCmd ) =<br/>                    PageOne.update <br/>                        (PageOneMsg PageOne.signOut) model.pageOne<br/>            in<br/>                ( { model<br/>                    | user = signedOut<br/>                    , pageOne = pageOne<br/>                  }<br/>                , Cmd.map PageOneMsg pageOneCmd<br/>                )</span></pre><p id="c0d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可能更喜欢这样，但实际上在一天结束时都是一样的。我仍然想不出一种方法来使这种级联更新自动化(或者至少由编译器强制执行)。</p><h1 id="ba9b" class="kf jz hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">朝着正确方向迈出的一步？</h1><p id="66e9" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">也许我们可以将用户添加到子组件的模型中，并约定在每次调用update / view时必须用父组件的副本替换它。所以RootComponent的更新函数可能看起来像这样:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="9bdb" class="jy jz hu ju b fv ka kb l kc kd">update: Msg -&gt; Model -&gt; (Model, Cmd Msg)<br/>update msg model =<br/>    case msg of<br/>        PageOneMsg sub -&gt;<br/>            let<br/>                (subModel, subCmd) =<br/>                    PageOne.update sub model.pageOne<br/>            in<br/>            ( { model | pageOne = <strong class="ju hv">updateUser model.user subModel</strong><br/>                , Cmd.map PageOneMsg subCmd )<br/>    ...</span><span id="ce8c" class="jy jz hu ju b fv lh kb l kc kd">-- a general util that can be used from anywhere<br/><strong class="ju hv">updateUser : User -&gt; { a | user: User} -&gt; { a | user: User}<br/>updateUser user model =<br/>    { model | user = user }</strong></span></pre><p id="310d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们不会失去同步<strong class="it hv">，但前提是每个人都记得这是使用</strong>的模式。用这种方法，当我们忘记的时候，我们会不断地被发现。</p><h1 id="bc03" class="kf jz hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">不允许易失性数据的两个副本</h1><p id="8260" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">我们必须得出结论，我们不能允许任何不稳定状态有两个副本。但这又把我们带回了问题，PageOne组件如何访问用户。答案是确保任何这样的状态都是从父组件连同子组件的模型一起传入的，而不是作为if的一部分。因此，PageOne的更新签名可能看起来像这样:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="299e" class="jy jz hu ju b fv ka kb l kc kd">update: Msg -&gt; User -&gt; Model -&gt; (Model, Cmd Msg)</span></pre><p id="5145" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们在视图中需要这种状态，我们会希望对视图签名进行类似的调整。请注意，这与React中采用的方法非常相似，在React中，我们拥有道具(从上面传递的数据，但我不拥有这些道具)并声明哪些数据是我自己可以控制的。</p><p id="852d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种方法的最大优点是，我们每次都不能不从上面传入它，并且我们不再有数据的两个副本。没有什么是不同步的，这是非常有价值的。不利的一面是，如果你要达到这个规模，你必须小心谨慎。当我发现另一个状态实际上属于一个祖先组件时会发生什么？我还得把这个加到签名上。一路向下。</p><p id="be48" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这会让人觉得已经有太多的样板文件了。但在我看来，这是唯一真正的解决办法。如果你认为还有其他选择，请告诉我！</p><blockquote class="ll lm ln"><p id="fca1" class="ir is ke it b iu iv iw ix iy iz ja jb lo jd je jf lp jh ji jj lq jl jm jn jo hn dt translated"><a class="ae lr" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae lr" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae lr" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae lr" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is ke it b iu iv iw ix iy iz ja jb lo jd je jf lp jh ji jj lq jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae lr" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae lr" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae lr" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is ke it b iu iv iw ix iy iz ja jb lo jd je jf lp jh ji jj lq jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lr" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lr" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>