<html>
<head>
<title>Fractal — A react app structure for infinite scale</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分形——一种无限尺度的反应式应用结构</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/fractal-a-react-app-structure-for-infinite-scale-4dab943092af?source=collection_archive---------0-----------------------#2017-09-24">https://medium.com/hackernoon/fractal-a-react-app-structure-for-infinite-scale-4dab943092af?source=collection_archive---------0-----------------------#2017-09-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="71ec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在与<a class="ae jp" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank"> React </a>和flux ( <a class="ae jp" href="https://hackernoon.com/tagged/redux" rel="noopener ugc nofollow" target="_blank"> Redux </a>)合作了超过8个重大项目(每个项目超过100个屏幕)之后，我们了解了一些关于React应用的事情。</p><p id="13cb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">随着时间的推移，一种构建项目的方式演变了，这是如此自然，以至于新的前端开发人员(几乎没有React经验)的入职变得轻而易举。</p><p id="e1b6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们称之为分形。这是(并将永远是)一项正在进行的工作。</p><h2 id="8586" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated"><strong class="ak">分形让你:</strong></h2><ul class=""><li id="4cb5" class="kl km hu it b iu kn iy ko jc kp jg kq jk kr jo ks kt ku kv dt translated">关于文件位置的原因</li><li id="0269" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv dt translated">管理和创建复杂的用户界面</li><li id="7c8a" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv dt translated">快速迭代</li><li id="da33" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv dt translated">并可重复缩放</li></ul></div><div class="ab cl lb lc hc ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hn ho hp hq hr"><p id="14fe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">分形的本质不是一套规则或惯例，而是可以总结为一个指导原则:<strong class="it hv">所有的单元都可以自我重复。</strong></p><h1 id="e838" class="li jr hu bd js lj lk ll jw lm ln lo ka lp lq lr kd ls lt lu kg lv lw lx kj ly dt translated">应用程序布局</h1><p id="3eec" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc lz je jf jg ma ji jj jk mb jm jn jo hn dt translated">把你的app想象成一棵树(数据结构)，每个项目给树赋予一个新的形状，但是根节点保持不变。根节点是应用程序布局。这些显示在下面的截图中。</p><figure class="md me mf mg fq mh fe ff paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="fe ff mc"><img src="../Images/af8f34b8d4862951709c3c902a9ae038.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fJnFVptiCm11gpyGSFh4uQ.png"/></div></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">App Layout (Check the sidebar, it shows all the files)</figcaption></figure><ul class=""><li id="a082" class="kl km hu it b iu iv iy iz jc ms jg mt jk mu jo ks kt ku kv dt translated"><strong class="it hv"> Pablo </strong>是产品的名称。</li><li id="bc7e" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv dt translated"><strong class="it hv"> build </strong>是所有构建好的文件存放的地方，除了需要部署的时候，你从来不碰它。</li><li id="37da" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv dt translated"><strong class="it hv"> public </strong>是你的<em class="mv">index.html</em>文件和&lt; <em class="mv">脚本src &gt; </em>资产去的地方。(在使用create-react-app时，它们会自动复制到构建中)</li><li id="c423" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv dt translated">src是你编码的地方。</li><li id="caf8" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv dt translated"><strong class="it hv"> src.pages </strong>是根级组件，直接安装在一级路由上。(例如。如果您有一个名为/login的路由，它装载了一个登录组件，那么Login.js将出现在pages目录中。</li><li id="ae88" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv dt translated"><strong class="it hv"> src.modules </strong>处理你的状态(actions + reducers使用ducks文件结构)。</li><li id="a4e6" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv dt translated"><strong class="it hv"> src.components </strong>有共享组件，如按钮、输入等。</li><li id="8fee" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv dt translated">src.utils 有API包装器、日期实用程序、字符串实用程序等实用程序。</li><li id="7523" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv dt translated">config是你存储环境变量的地方，比如API端点。不要把这个交给git。</li><li id="21fe" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv dt translated"><strong class="it hv">存储</strong>初始化redux存储。</li><li id="5e03" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv dt translated"><strong class="it hv">索引</strong>注册路线并渲染app。</li></ul><p id="3087" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们没有智能组件和非智能组件的概念，因为我们发现这种想法有局限性。</p><h1 id="7d7b" class="li jr hu bd js lj lk ll jw lm ln lo ka lp lq lr kd ls lt lu kg lv lw lx kj ly dt translated">分形图案:让所有单元重复</h1><p id="f4eb" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc lz je jf jg ma ji jj jk mb jm jn jo hn dt translated">当您试图利用这种能力来组合React组件时，神奇的事情就发生了。</p><figure class="md me mf mg fq mh fe ff paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="fe ff mw"><img src="../Images/9f750bfbe1fe8d8e5f8d6116e417314c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WAB8jgCFJq7yocolIWUbhg.png"/></div></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">A typical login screen</figcaption></figure><p id="dda6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设一个登录组件安装在/login上，有一个表单和一个打开密码重置模式的forgot按钮。</p><p id="b46a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本例中，我们将其分为3个部分:</p><ul class=""><li id="e21c" class="kl km hu it b iu iv iy iz jc ms jg mt jk mu jo ks kt ku kv dt translated">Login.js</li><li id="5de3" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv dt translated">Form.js</li><li id="7b13" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv dt translated">ForgotModal.js</li></ul><p id="09ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">其结构如下:</strong></p><figure class="md me mf mg fq mh fe ff paragraph-image"><div class="fe ff mx"><img src="../Images/db2c6b49ffc3b55c13dd4beefcf787ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*B1TjLGpnTxwIhNhzpvq3BA.png"/></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">Simple Fractal Structure</figcaption></figure><p id="4a6b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Pages目录有一个Login.js组件。</p><p id="62e6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所有部件都用骆驼壳包装。</p><p id="0580" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Login.js的子组件位于一个名为Login的文件夹中。这是有助于设置重复模式的节点。</p><p id="60f8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">所有节点都是小写字母。</strong>所以在这种情况下登录。如果ForgotModal.js有另一个子组件来显示成功消息，那么我们可以在登录节点中有一个名为<strong class="it hv"> forgotModal </strong>的文件夹，并将SuccessMessage.js组件放在那里。</p><figure class="md me mf mg fq mh fe ff paragraph-image"><div class="fe ff my"><img src="../Images/59a9732b44ddf844928ba8dde7b0fa78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*yqn4DiPp1QTre7E-SRZzSw.png"/></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">Fractal keeps repeating itself.</figcaption></figure><p id="5039" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面的截图显示了它在真实应用程序中的样子。</p><figure class="md me mf mg fq mh fe ff paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="fe ff mc"><img src="../Images/c81859da3755550e84d30f5d0a8a02d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VZh6CuBdTqTsBpFnJMAnqQ.png"/></div></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">pages have two roots: Document.js and Template.js and two sub-nodes document and template</figcaption></figure><p id="e751" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">页面所需的所有组件都位于其节点文件夹中。如果一个以上的组件需要这个组件，比如一个品牌按钮，那么它会被放到src.components文件夹中。当你需要将一个组件分解成子组件时，使用分形。下面的截图显示了我们如何以同样的方式使用Trackers组件。</p><figure class="md me mf mg fq mh fe ff paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="fe ff mc"><img src="../Images/47bcd43ba2ae7e020b8367ea24407dd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3sQLOjpG2br04PIz-ULvLg.png"/></div></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">Observe a file Trackers.js and a folder named trackers, containing all sub components required by Trackers.js</figcaption></figure><h1 id="c036" class="li jr hu bd js lj lk ll jw lm ln lo ka lp lq lr kd ls lt lu kg lv lw lx kj ly dt translated"><strong class="ak">分形状态</strong></h1><p id="833e" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc lz je jf jg ma ji jj jk mb jm jn jo hn dt translated">事实证明，管理分形模式中的组件是一种合理的做法，所以我们问自己，我们是否可以对状态做同样的事情？(是的，我们可以。)</p><p id="bc6f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们在例子中使用redux。假设一个设计，你的前端必须显示一个应用程序列表，每个应用程序可以有许多评论。一个经典的一对多细节流程。在标准redux中，我们可以有两个reducers，一个用于创建、阅读、更新和删除应用程序，另一个用于粗制滥造评论。</p><p id="a84a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为我们使用了<a class="ae jp" href="https://medium.freecodecamp.org/scaling-your-redux-app-with-ducks-6115955638be" rel="noopener ugc nofollow" target="_blank"> ducks文件结构</a>，所以我们应该在模块文件夹中有一个apps.js文件和一个reviews.js文件。但是这不会帮助我们模拟API的形状，并且随着代码库的增长，很难推理出平面存储。</p><p id="7739" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">相反，我们使用分形状态来保存模块，如下所示:</p><figure class="md me mf mg fq mh fe ff paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="fe ff mc"><img src="../Images/270f90fe28006cbcfeeeb3a65f438d27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fFBOnW6Obv0PI8b_TCm8Uw.png"/></div></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">Fractal on modules. Observe the modules folder on the left sidebar and the shape of the store on the right (line 9, 10, 11)</figcaption></figure><p id="eea4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过上面的设计，我们可以直接在商店中模拟数据库的形状。</p><p id="88df" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">问:扪心自问，如果每个应用程序都有评论对象，那么评论模块将何去何从？</strong></p><p id="d236" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">A.如果你选择将它放在<strong class="it hv"> modules.app </strong>文件夹中，那么你对分形的理解是正确的。</p><p id="83ef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这给了我们一个惊人的规模。假设每个评论都有一个与之相关联的源，这个源将从一个单独的API中获取。我们需要做的就是在<strong class="it hv"> modules.app </strong>中创建一个review文件夹，并向其中添加一个名为source.js的文件，并在第11行的<strong class="it hv"> combineReducers </strong>中添加另一个key = <strong class="it hv"> review </strong>和value =<strong class="it hv">combine reducers({ source:review source })。</strong></p><h1 id="e6b9" class="li jr hu bd js lj lk ll jw lm ln lo ka lp lq lr kd ls lt lu kg lv lw lx kj ly dt translated">背景</h1><p id="a216" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc lz je jf jg ma ji jj jk mb jm jn jo hn dt translated">分形的想法是由我的导师卡皮尔·维尔马提出的。这个想法成功地在基于Express的API中实现了，并被我用来创建可扩展的react应用程序。</p><p id="3ebc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这在所有种类和大小的应用程序中对我们都很有效。我们甚至在python代码库上试验分形模式。</p><p id="3d36" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">高级开发人员注意事项</strong></p><ul class=""><li id="c4ec" class="kl km hu it b iu iv iy iz jc ms jg mt jk mu jo ks kt ku kv dt translated">需要注意的一点是文件夹中没有index.js。这会导致与模块分辨率的冲突(因为大小写)。</li><li id="ea1b" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv dt translated">作为惯例，示例中的所有导入都是绝对的(我们更喜欢绝对的)。如果你愿意，他们可以是亲戚。</li></ul></div><div class="ab cl lb lc hc ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hn ho hp hq hr"><h2 id="0844" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">更新1:</h2><p id="619c" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc lz je jf jg ma ji jj jk mb jm jn jo hn dt translated">一些读者要求提供示例代码。我已经设法把一些小东西放在一起。</p><div class="mz na fm fo nb nc"><a href="https://github.com/shivekkhurana/appuity-frontend" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab ej"><div class="ne ab nf cl cj ng"><h2 class="bd hv fv z el nh eo ep ni er et ht dt translated">shivekkhurana/appuity-frontend</h2><div class="nj l"><h3 class="bd b fv z el nh eo ep ni er et ek translated">http://appuity.ml和Fractal演示的appuity-frontend - React代码库。</h3></div><div class="nk l"><p class="bd b gc z el nh eo ep ni er et ek translated">github.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq mm nc"/></div></div></a></div><h2 id="8442" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">更新二(2018年7月30日):</h2><p id="f939" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc lz je jf jg ma ji jj jk mb jm jn jo hn dt translated">这篇文章刚刚爆了。我在这么多的subreddits和git repos上看到这一点。人们给我发邮件，问我关于分形的问题。我真的很谦卑，也很高兴能够用我的知识来回报。</p><p id="64af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了继续这一努力，我计划创建一个slack社区。这将使你能够提出与你的用例相关的问题(关于分形和反应)。它还会让你实时访问我和其他开发人员(在不同的技能水平)。你可以在这里加入它<a class="ae jp" href="https://join.slack.com/t/iigwr/shared_invite/enQtNDEyMTI4OTM4ODcxLWJkODJjZWU1YTJiMDY1OWMxYmFkMjVjMWU4YTRjNmRhM2FiMTA2MDVjYmNmZWIxMTU4NDQwOWY0NjhlZDFlYzI" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="md me mf mg fq mh fe ff paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="fe ff nr"><img src="../Images/e95933672695ca03e1e20a79c04bb14b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GeuhdoRjZh9K3hq0Ik8Vfw.png"/></div></div></figure><blockquote class="ns"><p id="7184" class="nt nu hu bd nv nw nx ny nz oa ob jo ek translated"><strong class="ak">如果你喜欢这篇文章并想保持更新，请关注我:</strong><a class="ae jp" rel="noopener" href="/@shivekkhurana"><strong class="ak">Medium</strong></a><strong class="ak">，</strong><a class="ae jp" href="https://github.com/shivekkhurana" rel="noopener ugc nofollow" target="_blank"><strong class="ak">Github</strong></a><strong class="ak">或</strong> <a class="ae jp" href="https://twitter.com/shivek_khurana" rel="noopener ugc nofollow" target="_blank"> <strong class="ak"> Twitter </strong> </a></p></blockquote><figure class="od oe of og oh mh fe ff paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="fe ff oc"><img src="../Images/7b9e64b1cb503518606518d5611a3932.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IXzRtvecjteLH3XNKexi3A.png"/></div></div></figure><p id="57f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可能还喜欢:</p><div class="mz na fm fo nb nc"><a rel="noopener follow" target="_blank" href="/@shivekkhurana/a-simple-ui-hack-to-improve-onboarding-ux-ocd-93ed5d77247"><div class="nd ab ej"><div class="ne ab nf cl cj ng"><h2 class="bd hv fv z el nh eo ep ni er et ht dt translated">一个简单的用户界面改进UX [OCD]</h2><div class="nj l"><h3 class="bd b fv z el nh eo ep ni er et ek translated">UI模型和草图假设用户数据已经存在。例如，下面的模型假设用户…</h3></div><div class="nk l"><p class="bd b gc z el nh eo ep ni er et ek translated">medium.com</p></div></div><div class="nl l"><div class="oi l nn no np nl nq mm nc"/></div></div></a></div><figure class="md me mf mg fq mh"><div class="bz el l di"><div class="oj ok l"/></div></figure></div></div>    
</body>
</html>