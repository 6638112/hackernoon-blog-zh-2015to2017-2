<html>
<head>
<title>Testing Legacy Code: Frameworks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试遗留代码:框架</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/testing-legacy-code-frameworks-f70b8ce2b547?source=collection_archive---------5-----------------------#2016-10-13">https://medium.com/hackernoon/testing-legacy-code-frameworks-f70b8ce2b547?source=collection_archive---------5-----------------------#2016-10-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="7b58" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">遗留<a class="ae jp" href="https://hackernoon.com/tagged/code" rel="noopener ugc nofollow" target="_blank">代码</a>的一个常见特性是与外部框架或SDK的紧密耦合。它可以是“<a class="ae jp" href="https://hackernoon.com/tagged/manager" rel="noopener ugc nofollow" target="_blank">管理器</a>或“ApiClient”单例的形式，在整个应用程序中最关键的地方使用。或者可能更微妙，比如利用框架提供的“DateUtil”类。</p><p id="6373" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可能会问“你有什么问题？我为什么要重新发明轮子？”。不，你不应该。听我说完。</p></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><p id="9e45" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用库、SDK、框架等。这是一件好事，尤其是当他们成熟并经过战斗考验的时候。<a class="ae jp" href="https://www.youtube.com/watch?v=-5wpm-gesOY" rel="noopener ugc nofollow" target="_blank">开发自己的HTTP客户端或date util </a>毫无意义。问题是，当你在使用它们的时候没有考虑如何替换它们。</p><p id="1fdd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为有时候库是被弃用的。或者新版本包含重大变更。或者一个更新更好的库发布了，而你还在用恐龙时代写的代码。</p><p id="393a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者你只是想写一些单元测试。当遗留代码中夹杂着框架方法调用时，乐趣就开始了。</p><h2 id="7e29" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">一个</h2><p id="81fd" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">哦，是的，每个人都喜欢憎恨单身人士。当代码使用外部库中的单例时，情况会更糟。</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="08bf" class="jx jy hu lc b fv lg lh l li lj">public void loadImage(){<br/>  Picasso.with(context).load(url).into(view);<br/>}</span></pre><p id="eacb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一行漂亮的代码。任何Android开发者都会告诉你这一点。杰克·沃顿出版毕加索作品的那一天应该是Android社区的零年。</p><p id="d81d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是尝试为该方法编写一个单元测试。或者更好的是，想象一下真实的代码是什么样子，例如一个老化的列表适配器，带有无数错误修复和清理的伤痕。</p><p id="2334" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以修改代码，通过依赖注入提供对Picasso的引用，并在单元测试中模拟它。它会工作得很好。</p><p id="e436" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是想象一下你不得不切换到另一个库，就像<a class="ae jp" href="https://developer.android.com/training/volley/index.html" rel="noopener ugc nofollow" target="_blank">凌空</a> ( <em class="lk">为什么会有人用毕加索以外的东西？反正… </em>)。您需要将您的代码更改为如下所示:</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="b543" class="jx jy hu lc b fv lg lh l li lj">public void loadImage(){<br/>  imageLoader.get(url, ImageLoader.getImageListener(view, <br/>    R.drawable.default, R.drawable.error));<br/>}</span></pre><p id="cea9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然，你的测试也必须重写。</p><p id="54f8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你用一层薄薄的包装纸包住毕加索，像这样:</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="906b" class="jx jy hu lc b fv lg lh l li lj">public interface GenericImageLoader {<br/>  void loadImage(String url, ImageView imageView);<br/>}</span><span id="d4bd" class="jx jy hu lc b fv ll lh l li lj">public class PicassoImageLoader implements GenericImageLoader {<br/>  public void loadImage(url, view){<br/>    Picasso.with(context).load(url).into(view);<br/>  }<br/>}</span><span id="b855" class="jx jy hu lc b fv ll lh l li lj">/// usage in the code: <br/>private GenericImageLoader loader = new PicassoImageLoader();<br/>public void initializeStuff(){<br/>  this.loader.loadImage("http://...", profileImageView);<br/>}</span></pre><p id="ea64" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您将不得不接受妥协，不对包装器进行单元测试。如果你只把它作为一个包装器，方法调用将直接映射到库方法。只要你不在里面做什么疯狂的事情，你应该是安全的。</p><p id="c6cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，对<em class="lk"> initializeStuff() </em>方法进行单元测试更加简单。如果您必须切换到凌空，那么，您只需创建一个不同的<em class="lk"> GenericImageLoader </em>接口的实现:</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="0927" class="jx jy hu lc b fv lg lh l li lj">public class VolleyImageLoader implements GenericImageLoader {<br/>  public void loadImage(url, view){<br/>    imageLoader.get(url, ImageLoader.getImageListener(view,<br/>      R.drawable.default, R.drawable.error));<br/>  }<br/>}</span><span id="cf2e" class="jx jy hu lc b fv ll lh l li lj">// usage in the code:<br/>private GenericImageLoader loader = new VolleyImageLoader();<br/>public void initializeStuff(){<br/>  this.loader.loadImage("http://...", profileImageView);<br/>}</span></pre><p id="811f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="lk"> initializeStuff() </em>方法保持不变，但是有了一个<a class="ae jp" href="https://www.youtube.com/watch?v=t9-CS2v8wcc" rel="noopener ugc nofollow" target="_blank">全新的世界</a> ( <em class="lk">咳咳！)</em>后面的<em class="lk"> GenericImageLoader </em>接口。好棒的多态性！</p><h2 id="589c" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">静态方法</h2><p id="b017" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">现在，假设在您想要测试的方法中有一个包含静态方法的实用程序类。通常，如果静态方法没有任何神奇之处，它们就不是问题。但是你有一个由真正喜欢静态方法的人设计的API。像这种<a class="ae jp" href="https://developer.android.com/training/location/receive-location-updates.html#updates" rel="noopener ugc nofollow" target="_blank">请求位置更新的方式</a>在安卓:</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="6313" class="jx jy hu lc b fv lg lh l li lj">public void startLocationUpdates() {<br/>    LocationServices.FusedLocationApi.requestLocationUpdates(<br/>            mGoogleApiClient, mLocationRequest, this);<br/>}</span></pre><p id="994f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">祝你测试成功。你甚至不能嘲笑它。您唯一的机会是围绕API创建一个包装器:</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="d6aa" class="jx jy hu lc b fv lg lh l li lj">public interface LocationApi {<br/>  void requestLocationUpdates(GoogleApiClient client,                       <br/>              LocationRequest request, LocationListener listener);<br/>}</span><span id="4929" class="jx jy hu lc b fv ll lh l li lj">public class FusedLocationApiWrapper implements LocationApi {</span><span id="5885" class="jx jy hu lc b fv ll lh l li lj">  public void requestLocationUpdates(GoogleApiClient client,                       <br/>              LocationRequest request, LocationListener listener) {<br/>    LocationServices.FusedLocationApi.requestLocationUpdates(     <br/>                    client, request, listener);<br/>  }<br/>}</span><span id="9677" class="jx jy hu lc b fv ll lh l li lj">// usage in code <br/>private LocationApi wrapper = new FusedLocationApiWrapper();</span><span id="ca59" class="jx jy hu lc b fv ll lh l li lj">public void startLocationUpdates() {<br/>    wrapper.requestLocationUpdates(<br/>            mGoogleApiClient, mLocationRequest, this);<br/>}</span></pre><p id="8b86" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样，只要你只包装静态方法，你就可以不用测试。</p><p id="8efd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，您可能会意识到<em class="lk"> LocationApi </em>接口仍然与<em class="lk"> FusedLocationApi紧密耦合。</em>它使用<em class="lk"> LocationRequest </em>类，需要一个<em class="lk"> GoogleApiClient </em>和一个<em class="lk"> LocationListener，</em>Google Play服务的所有部分。</p><p id="3e7b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了在location API上创建一个真正的抽象层，您必须定义自己的方式来提供包含在<em class="lk"> LocationRequest </em>中的信息。</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="f069" class="jx jy hu lc b fv lg lh l li lj">public interface LocationApi {<br/>  void requestQuickLocation();<br/>  void requestPreciseLocation();<br/>}</span><span id="3275" class="jx jy hu lc b fv ll lh l li lj">public class FusedLocationApiWrapper implements LocationApi {<br/>  private OnLocationListener listener;</span><span id="9f47" class="jx jy hu lc b fv ll lh l li lj">  public FusedLocationApiWrapper(GoogleApiClient client){<br/>    this.client = client;<br/>  }</span><span id="de4e" class="jx jy hu lc b fv ll lh l li lj">  public void requestQuickLocation(GoogleApiClient client,                       <br/>              LocationRequest request, LocationListener listener) {<br/>    LocationRequest request = LocationRequest.create();<br/>    request.setMaxWaitTime(ONE_SECOND);<br/>    request.setPriority(<a class="ae jp" href="https://developers.google.com/android/reference/com/google/android/gms/location/LocationRequest.html#PRIORITY_BALANCED_POWER_ACCURACY" rel="noopener ugc nofollow" target="_blank">PRIORITY_BALANCED_POWER_ACCURACY</a>);<br/>    LocationServices.FusedLocationApi.requestLocationUpdates(     <br/>                    client, request, listener);<br/>  }</span><span id="e5e4" class="jx jy hu lc b fv ll lh l li lj">  public void requestPreciseLocation(GoogleApiClient client,                       <br/>              LocationRequest request, LocationListener listener) {<br/>    LocationRequest request = LocationRequest.create();<br/>    request.setMaxWaitTime(FIVE_SECONDS);<br/>    request.setPriority(<a class="ae jp" href="https://developers.google.com/android/reference/com/google/android/gms/location/LocationRequest.html#PRIORITY_HIGH_ACCURACY" rel="noopener ugc nofollow" target="_blank">PRIORITY_HIGH_ACCURACY</a>);<br/>    LocationServices.FusedLocationApi.requestLocationUpdates(     <br/>                    client, request, listener);<br/>  }<br/>}</span><span id="3332" class="jx jy hu lc b fv ll lh l li lj">// usage in code<br/>private GoogleApiClient client;<br/>private LocationApi wrapper = new FusedLocationApiWrapper(client);</span><span id="e306" class="jx jy hu lc b fv ll lh l li lj">public void startLocationUpdates() {<br/>    wrapper.requestQuickLocation();<br/>}</span></pre><p id="dd5a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">客户端代码看起来干净多了，更容易进行单元测试，也更容易换成另一个位置提供者。你可以写很多额外的代码！不喜欢什么？(<em class="lk">不要回答那个</em>)。</p><h2 id="ec94" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">最终类和方法</h2><p id="a6ef" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">库和框架有时会将它们的公共类和方法标记为final。从安全角度来看，这很有意义。作为一个API创建者，你不希望开发者对你的API内部有太多的兴趣。所以你试图让你的面向公众的接口尽可能的密闭:最终的方法，实现单个实例的单例等等。</p><p id="9fa5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是你不能嘲笑他们。见上。</p><h2 id="0e35" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">结论</h2><p id="6210" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">封装很重要。<a class="ae jp" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank">关注点分离</a>很重要。<a class="ae jp" href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)" rel="noopener ugc nofollow" target="_blank">低耦合</a>很重要。<a class="ae jp" href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" rel="noopener ugc nofollow" target="_blank">依赖倒置</a>很重要。</p><p id="e06b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但更重要的是知道它们很重要。你并不总是有时间把所有的东西抽象出来。你也不应该。只要记住外部库是强大的野兽。最好和他们保持一定的距离。</p><blockquote class="lm ln lo"><p id="4630" class="ir is lk it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is lk it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上给我们点赞/发消息</a>，或者简单地说，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is lk it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kx ky kz la fq ls"><div class="bz el l di"><div class="lt lu l"/></div></figure></div></div>    
</body>
</html>