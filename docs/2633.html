<html>
<head>
<title>Build Versatile and Intelligent Distributed Systems with Grid Ops — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用网格操作构建多功能智能分布式系统—第2部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/build-versatile-and-intelligent-distributed-systems-with-grid-ops-part-2-202fad4ff58f?source=collection_archive---------24-----------------------#2017-02-07">https://medium.com/hackernoon/build-versatile-and-intelligent-distributed-systems-with-grid-ops-part-2-202fad4ff58f?source=collection_archive---------24-----------------------#2017-02-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/68ef675d2213918f3c2758638e302227.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C_8fqOl6W1qgh2s2yZh0cg.png"/></div></div></figure><h2 id="8b73" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated"><strong class="ak">什么是网格Ops？</strong></h2><p id="9c7c" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">在帖子[ <a class="ae kv" href="https://hackernoon.com/versatile-and-intelligent-distributed-systems-with-grid-ops-part-1-8228bdfcb044#.7gg8e9we9" rel="noopener ugc nofollow" target="_blank"> 1 </a>中，我们介绍了Grid Ops，它是一个用于创建高级分布式系统的开源Java工具包。我们还写道，Grid Ops通常由一组实现分布式系统的核心工具和一组常用的分布式系统基础设施服务组成。</p><p id="388f" class="pw-post-body-paragraph ka kb hu kc b kd kw kf kg kh kx kj kk jn ky km kn jr kz kp kq jv la ks kt ku hn dt translated">我们的使命是帮助开发人员只用几行代码就能建立并运行分布式系统。尽管我们从Java实现开始，但我们希望将来能够用其他语言实现，如C#和Grid Ops的主要组件有:</p><ul class=""><li id="e1ce" class="lb lc hu kc b kd kw kh kx jn ld jr le jv lf ku lg lh li lj dt translated"><strong class="kc hv">TCP服务器</strong></li><li id="102e" class="lb lc hu kc b kd lk kh ll jn lm jr ln jv lo ku lg lh li lj dt translated"><strong class="kc hv"> TcpSocketsPort </strong></li><li id="a594" class="lb lc hu kc b kd lk kh ll jn lm jr ln jv lo ku lg lh li lj dt translated"><strong class="kc hv">主持人</strong></li><li id="251e" class="lb lc hu kc b kd lk kh ll jn lm jr ln jv lo ku lg lh li lj dt translated">节点容器</li></ul><p id="8995" class="pw-post-body-paragraph ka kb hu kc b kd kw kf kg kh kx kj kk jn ky km kn jr kz kp kq jv la ks kt ku hn dt translated">这四个组件构成了网格操作的基础，如下图所示:</p><figure class="lq lr ls lt fq iv fe ff paragraph-image"><div class="fe ff lp"><img src="../Images/0a1c40c2ab88a08f04ca412bfbfe691e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*Kqb-Tp6l6YhI_pEhxSIJEA.png"/></div></figure><p id="6fd4" class="pw-post-body-paragraph ka kb hu kc b kd kw kf kg kh kx kj kk jn ky km kn jr kz kp kq jv la ks kt ku hn dt translated">1.<code class="eh lu lv lw lx b"><strong class="kc hv">TcpServer</strong></code> <strong class="kc hv"> </strong>是消息进入<code class="eh lu lv lw lx b"><strong class="kc hv">Host</strong></code>的方式之一。<code class="eh lu lv lw lx b"><strong class="kc hv">Host</strong></code>通过<code class="eh lu lv lw lx b"><strong class="kc hv">TcpSocketsPort</strong></code>读取信息，并将它们传递给<code class="eh lu lv lw lx b"><strong class="kc hv">NodeContainer</strong></code>。</p><p id="02b2" class="pw-post-body-paragraph ka kb hu kc b kd kw kf kg kh kx kj kk jn ky km kn jr kz kp kq jv la ks kt ku hn dt translated">2.<strong class="kc hv"> </strong> <code class="eh lu lv lw lx b"><strong class="kc hv">TcpSocketsPort</strong></code>在内部管理一个或多个TCP套接字。这些TCP套接字可以来自一个<code class="eh lu lv lw lx b"><strong class="kc hv">TcpServer</strong></code>或者由应用程序作为客户端连接打开(传出连接)。因此,<code class="eh lu lv lw lx b"><strong class="kc hv">TcpSocketsPort</strong></code>可以用作传入和传出连接的接口，这意味着它既是服务器的接口，也是客户机的接口。</p><p id="aa9d" class="pw-post-body-paragraph ka kb hu kc b kd kw kf kg kh kx kj kk jn ky km kn jr kz kp kq jv la ks kt ku hn dt translated">3.<code class="eh lu lv lw lx b"><strong class="kc hv">NodeContainer</strong></code>在内部将其接收的消息路由到正确的节点。您可以将节点反应器、协议反应器和消息反应器插入<strong class="kc hv"> </strong> <code class="eh lu lv lw lx b"><strong class="kc hv">NodeContainer</strong></code>。这就是开发人员实现多租户和多协议应用程序的方式。</p><figure class="lq lr ls lt fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ly"><img src="../Images/33b0865787e05b17bd42a812ea10d78b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VSTNtfv9VqYHzspju8vkCw.png"/></div></div></figure><p id="9813" class="pw-post-body-paragraph ka kb hu kc b kd kw kf kg kh kx kj kk jn ky km kn jr kz kp kq jv la ks kt ku hn dt translated">简而言之，Grid Ops函数中的<code class="eh lu lv lw lx b"><strong class="kc hv">NodeContainer</strong></code>类可以将传入的消息路由到要处理它们的组件。<code class="eh lu lv lw lx b"><strong class="kc hv">NodeContainer</strong></code>将查看传入消息中的节点id，并将消息转发给相应的<code class="eh lu lv lw lx b"><strong class="kc hv">NodeReactor</strong></code>。<code class="eh lu lv lw lx b"><strong class="kc hv">NodeReactor</strong></code>将查看语义协议id +版本，并将消息转发给相应的协议反应器。协议反应器将查看传入消息的消息类型，并将消息转发给相应的消息反应器。</p><p id="1685" class="pw-post-body-paragraph ka kb hu kc b kd kw kf kg kh kx kj kk jn ky km kn jr kz kp kq jv la ks kt ku hn dt translated">通常通过<code class="eh lu lv lw lx b"><strong class="kc hv">TcpServer</strong></code>和<code class="eh lu lv lw lx b"><strong class="kc hv">TcpSocketsPort</strong></code>从外部接收消息，然后将其发送给<code class="eh lu lv lw lx b"><strong class="kc hv">NodeContainer</strong></code>，后者在内部将消息路由到正确的<code class="eh lu lv lw lx b"><strong class="kc hv">MessageReactor</strong></code>(通过<code class="eh lu lv lw lx b"><strong class="kc hv">NodeReactor</strong></code>和<code class="eh lu lv lw lx b"><strong class="kc hv">ProtocolReactor</strong></code>实例)。</p><h2 id="370e" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated"><strong class="ak">线程呢？</strong></h2><p id="a53e" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">Well a <code class="eh lu lv lw lx b"><strong class="kc hv">TcpServer</strong></code>有自己的线程，接受传入的连接。该线程不从传入的连接中读取任何内容。</p><p id="665b" class="pw-post-body-paragraph ka kb hu kc b kd kw kf kg kh kx kj kk jn ky km kn jr kz kp kq jv la ks kt ku hn dt translated"><code class="eh lu lv lw lx b"><strong class="kc hv">Host</strong></code>也有自己的线程，它从<code class="eh lu lv lw lx b"><strong class="kc hv">TcpSocketsPort</strong></code>中提取消息，并将它们传递给<code class="eh lu lv lw lx b"><strong class="kc hv">NodeContainer</strong></code>。运行<code class="eh lu lv lw lx b"><strong class="kc hv">Host</strong></code>循环的同一个线程调用了<code class="eh lu lv lw lx b"><strong class="kc hv">NodeContainer</strong></code>的<code class="eh lu lv lw lx b"><strong class="kc hv">react()</strong></code>方法。这样，消息的读取和处理由同一个单线程完成。因此，开发人员可以采用单线程并发模型来编写他们的节点反应器、协议反应器和消息反应器。</p><h2 id="fc5c" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated"><strong class="ak">网格运营堆栈概述</strong></h2><figure class="lq lr ls lt fq iv fe ff paragraph-image"><div class="fe ff lz"><img src="../Images/28ce4fe3a5b3cfe29cadf5c0a8baf235.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*hdTyokF8d6fm2Dzl1fP21w.jpeg"/></div></figure><p id="1b2e" class="pw-post-body-paragraph ka kb hu kc b kd kw kf kg kh kx kj kk jn ky km kn jr kz kp kq jv la ks kt ku hn dt translated">这是目前为止，我们将继续在未来的职位更多的细节。如果你想玩Grid Ops，请访问我们的<a class="ae kv" href="https://github.com/nanosai/grid-ops-java" rel="noopener ugc nofollow" target="_blank"> Github页面</a>，代码请查看<a class="ae kv" href="https://github.com/nanosai/grid-ops-java-examples" rel="noopener ugc nofollow" target="_blank"> <strong class="kc hv">这里</strong> </a>。我们正在准备推出一些服务，如果你想收到测试邀请，请<code class="eh lu lv lw lx b"><a class="ae kv" href="https://goo.gl/forms/zXQe9k2es9iombdD2" rel="noopener ugc nofollow" target="_blank"><strong class="kc hv">Subscribe here.</strong></a></code></p><div class="lq lr ls lt fq ab cb"><figure class="ma iv mb mc md me mf paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="ma iv mb mc md me mf paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="ma iv mb mc md me mf paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mg mh mi"><p id="f922" class="ka kb mj kc b kd kw kf kg kh kx kj kk mk ky km kn ml kz kp kq mm la ks kt ku hn dt translated"><a class="ae kv" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kv" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kv" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae kv" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ka kb mj kc b kd kw kf kg kh kx kj kk mk ky km kn ml kz kp kq mm la ks kt ku hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kv" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kv" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lq lr ls lt fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mn"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>