<html>
<head>
<title>Setting up angular2-universal on your node server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在节点服务器上设置angular2-universal</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/setting-up-angular2-universal-on-your-node-server-602438067b3c?source=collection_archive---------5-----------------------#2016-11-21">https://medium.com/hackernoon/setting-up-angular2-universal-on-your-node-server-602438067b3c?source=collection_archive---------5-----------------------#2016-11-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="ddb6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">截至本文撰写时，最新版本是2.1.0-RC.1，其中引入了提前编译(AoT)支持。</p><h2 id="3e63" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">什么是angular2-universal？</h2><p id="4cfa" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">首先，回顾一下AngularJS的历史。angular的版本1与<a class="ae kq" href="https://hackernoon.com/tagged/dom" rel="noopener ugc nofollow" target="_blank"> DOM </a>紧密耦合。这意味着您编写的任何应用程序都必须在浏览器或至少某种浏览器模拟器中运行。</p><p id="5a5c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">无法在任何<a class="ae kq" href="https://hackernoon.com/tagged/environment" rel="noopener ugc nofollow" target="_blank">环境下运行angular</a>是完全重写angular代码库的驱动力之一。他们想抽象出对DOM的访问，这样做，他们打开了在服务人员、节点服务器甚至. NET服务器中运行angular2的可能性。枷锁已经被打破。</p><p id="8248" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">来自<a class="ae kq" href="https://angularclass.com/" rel="noopener ugc nofollow" target="_blank"> AngularClass </a>的<a class="kr ks gr" href="https://medium.com/u/eeb0522094ff?source=post_page-----602438067b3c--------------------------------" rel="noopener" target="_blank"> PatrickJS </a>是一名非常出色的开发人员，他挺身而出，创建了<a class="ae kq" href="https://github.com/angular/universal" rel="noopener ugc nofollow" target="_blank"><em class="jp">angular2-universal</em></a>，这是位于节点服务器和angular 2之间的中间件。</p><h2 id="25d6" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">我为什么要在乎？</h2><p id="2b11" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">服务器端渲染的一个主要卖点就是它带来的SEO价值。尽管googlebot正在索引单页应用程序，所以它现在不太受关注，我有一个不同的<a class="ae kq" href="http://blog.inrhythm.com/the-current-state-of-angular-seo/" rel="noopener ugc nofollow" target="_blank">帖子关于那个</a>。除了facebook和twitter等社交媒体网站上的富媒体共享，还有其他搜索引擎可以考虑。</p><p id="a775" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一大卖点是增强的感知性能。由于服务器通过网络发送完全呈现的html页面，用户可以看到内容，并能够更快地与之交互。再加上静态页面的CDN，原始服务器几乎不会受到影响，这降低了服务器的运行成本。</p><h2 id="4b16" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">设置前端</h2><p id="d914" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">angular2有几个问题——当涉及到angular2时，这是通用的最佳实践。最主要的一点是，不要直接访问DOM。在你的代码中，任何对<em class="jp">文档</em>或<em class="jp">窗口</em>的直接引用都会导致universal崩溃，或者顶多抛出错误。这两个对象在node上都不存在，所以不要试图使用它们。</p><p id="b21d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而…</p><p id="8b3e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有一些访问DOM的库，在某些情况下它们是不可避免的。一个非常流行的例子是hammer.js，一个触摸事件库。</p><p id="57cb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Angular2在其核心用<em class="jp">hammersgetureplugin</em>支持这个库，本质上是Angular的事件绑定系统的扩展。包含hammer.js实际上不会崩溃任何东西，而是一旦你将一个触摸事件绑定到一个元素，它实际上就崩溃了。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="bcc4" class="jq jr hu ky b fv lc ld l le lf">&lt;div (swipe)=”myAction()” /&gt; // Bound touch event</span></pre><p id="0177" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">这是我和PatrickJS </em>  <em class="jp">做的非常粗糙的工作。不保证这将适用于angular2或angular universal的未来版本。</em></p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="7bfc" class="jq jr hu ky b fv lc ld l le lf">import { __platform_browser_private__ } from ‘<a class="ae kq" href="http://twitter.com/angular/platform-browser" rel="noopener ugc nofollow" target="_blank">@angular/platform-browser</a>’;</span><span id="465d" class="jq jr hu ky b fv lg ld l le lf">__platform_browser_private__.HammerGesturesPlugin.prototype.supports = function hackySupports(eventName: string): boolean {<br/>  if (!this.isCustomEvent(eventName)) {<br/>    return false;<br/>  }<br/>  return true;<br/>};</span></pre><p id="826f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你必须在你的代码中引用<em class="jp">文档</em>或<em class="jp">窗口</em>，你必须将代码包装在一个<em class="jp"> isBrowser </em>条件中，这个条件可以方便地从<em class="jp"> angular2-universal </em>中导入。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="6fa7" class="jq jr hu ky b fv lc ld l le lf">import { isBrowser } from ‘angular2-universal’;</span><span id="a42b" class="jq jr hu ky b fv lg ld l le lf">…</span><span id="8b77" class="jq jr hu ky b fv lg ld l le lf">if (isBrowser) {<br/> // Do the thing<br/>}</span></pre><p id="1638" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者，您可以在根级别提供<em class="jp"> isBrowser </em>，<em class="jp"> app.module </em>，然后根据需要将其作为依赖项注入到您的组件、指令、管道和服务中。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="25fb" class="jq jr hu ky b fv lc ld l le lf">// app.module.ts<br/>import { NgModule } from ‘<a class="ae kq" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>’;<br/>import { isBrowser } from ‘angular2-universal’;</span><span id="4be2" class="jq jr hu ky b fv lg ld l le lf"><a class="ae kq" href="http://twitter.com/NgModule" rel="noopener ugc nofollow" target="_blank">@NgModule</a>({<br/>  providers: [<br/>    { provide: ‘isBrowser’, useValue: isBrowser }<br/>  ]<br/>})</span><span id="812c" class="jq jr hu ky b fv lg ld l le lf">// my.component.ts<br/>import { Component, Inject } from ‘<a class="ae kq" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>’;</span><span id="f5ec" class="jq jr hu ky b fv lg ld l le lf"><a class="ae kq" href="http://twitter.com/Component" rel="noopener ugc nofollow" target="_blank">@Component</a>({<br/>  …<br/>})<br/>export class MyComponent {<br/>  constructor(<br/>    <a class="ae kq" href="http://twitter.com/Inject" rel="noopener ugc nofollow" target="_blank">@Inject</a>(‘isBrowser’) public isBrowser: boolean<br/>  ) { }<br/>}<br/></span></pre><p id="aa87" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">需要考虑的主要问题是<em class="jp"> angular2-universal </em>有自己的模块<em class="jp"> UniversalModule </em>。这需要在根级别导入，或者从shared.module导入然后导出。</p><p id="35bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从技术上讲，该模块有两个版本。一个从<em class="jp">angular 2-universal/browser</em>导入，一个从<em class="jp">angular 2-universal/node</em>导入。您必须分别创建两个不同的<em class="jp"> app.module </em>条目文件<em class="jp"> app.module.browers.ts </em>和<em class="jp"> app.module.node.ts </em>。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="211e" class="jq jr hu ky b fv lc ld l le lf">// app.module.browers.ts<br/>import { NgModule } from ‘<a class="ae kq" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>’;<br/>import { UniversalModule } from ‘angular2-universal/browser’;</span><span id="f9f9" class="jq jr hu ky b fv lg ld l le lf"><a class="ae kq" href="http://twitter.com/NgModule" rel="noopener ugc nofollow" target="_blank">@NgModule</a>({<br/>  import: [<br/>    UniversalModule<br/>  ]<br/>})</span></pre><p id="4baf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了将<em class="jp">angular 2-universal/browser</em>替换为<em class="jp">angular 2-universal/node</em>之外，文件节点版本完全相同。</p><p id="dc5d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">通用模块</em>已经导出<em class="jp"> JsonpModule </em>、<em class="jp"> HttpModule </em>和<em class="jp"> BrowserModule </em>。所以这些可以安全地从<em class="jp"> app.module </em>导入中移除。</p><h2 id="e842" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">设置后端</h2><p id="3053" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">为了使<em class="jp"> angular2-universal </em>与express一起工作，需要安装<em class="jp">angular 2-express-engine</em>包。这是位于universal和express之间的中间件。</p><p id="1257" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不再需要为空的<em class="jp"> html </em>文件提供服务的路由，可以从服务器配置中删除。其他途径，像资产一样，可以保持不变。这是服务器文件的基本框架，下面会详细解释。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="f652" class="jq jr hu ky b fv lc ld l le lf"><br/>import { createEngine } from ‘angular2-express-engine’;<br/>import { AppModule } from ‘./app/app.module.node’;</span><span id="8629" class="jq jr hu ky b fv lg ld l le lf">// Express View<br/>app.engine(‘.html’, createEngine({<br/>  ngModule: AppModule,<br/>  precompile: true<br/>}));</span><span id="23d9" class="jq jr hu ky b fv lg ld l le lf">app.set(‘views’, ‘./dist/client’);<br/>app.set(‘view engine’, ‘html’);</span><span id="f0fd" class="jq jr hu ky b fv lg ld l le lf">app.use(‘/*’, (req, res) =&gt; {<br/>  res.render(‘index’, {<br/>    req,<br/>    res,<br/>    preboot: false,<br/>    baseUrl: ‘/’,<br/>    requestUrl: req.originalUrl<br/>  });<br/>});<br/></span></pre><p id="3ad7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里有几件关键的事情。</p><p id="0c5b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先需要设置渲染引擎，那就是<em class="jp"> app.engine </em>部分。<em class="jp"> createEngine </em>接受一个有两个键的对象，<em class="jp"> ngModule </em>和<em class="jp">预编译</em>。前者是<em class="jp"> app.module </em>的节点版本，后者是一个标志，告诉universal应用程序是处于及时编译模式还是提前编译模式。将<em class="jp">预编译</em>设置为<em class="jp">真</em>意味着应用程序正在及时使用。</p><p id="26f3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">应用程序使用</em>和<em class="jp"> '/*' </em>作为第一个参数，以便universal引导和渲染应用程序的每个路径</p><p id="160c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，您需要确保express确实为您的所有路线提供了预先呈现的页面。确保将其添加到您在express中定义的任何其他路线的下方。如果你不这样做，这些路线将优先并覆盖其下的路线。</p><h2 id="0165" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">结论</h2><p id="9aaf" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">这就包含了在node/express服务器上设置universal的基本内容。有几件事我没有在这篇文章中讨论，比如在服务器和客户端之间设置缓存。如果您的应用程序依赖于xhr请求，那么服务器和客户端都会在页面加载和刷新时发出这些请求。这可以通过缓存来自服务器的响应并在客户端读取它来避免。</p><p id="4208" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一个难点是用universal提前设置编译。这是一个完全不同的帖子，是我的<a class="kr ks gr" href="https://medium.com/u/eb2da744f1c4?source=post_page-----602438067b3c--------------------------------" rel="noopener" target="_blank"> Bee Todo列表</a>中的下一个</p><blockquote class="lh li lj"><p id="3cab" class="ir is jp it b iu iv iw ix iy iz ja jb lk jd je jf ll jh ji jj lm jl jm jn jo hn dt translated">黑客中午是黑客如何开始他们的下午。我们是这个家庭的一员。我们现在<a class="ae kq" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae kq" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is jp it b iu iv iw ix iy iz ja jb lk jd je jf ll jh ji jj lm jl jm jn jo hn dt translated">要了解更多信息，请阅读我们的“关于”页面、<a class="ae kq" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">喜欢/在脸书上给我们发消息</a>，或者简单地发送<a class="ae kq" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is jp it b iu iv iw ix iy iz ja jb lk jd je jf ll jh ji jj lm jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kq" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kq" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kt ku kv kw fq ln"><div class="bz el l di"><div class="lo lp l"/></div></figure></div></div>    
</body>
</html>