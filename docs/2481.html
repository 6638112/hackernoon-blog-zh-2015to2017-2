<html>
<head>
<title>Building A Real-Time Event-Driven Access Log System Using Docker, Python, Amazon SNS &amp; SQS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用Docker、Python、Amazon SNS和SQS构建实时事件驱动的访问日志系统</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/building-a-real-time-event-driven-system-using-docker-python-amazon-sns-sqs-985759e660eb?source=collection_archive---------11-----------------------#2017-01-30">https://medium.com/hackernoon/building-a-real-time-event-driven-system-using-docker-python-amazon-sns-sqs-985759e660eb?source=collection_archive---------11-----------------------#2017-01-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="c379" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">放弃</h2></div><p id="2d66" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">此内容是我们在线课程/培训的一部分/灵感来源。在2019年黑色星期五期间，我们对这些材料提供高达80%的折扣。</p><p id="ede3" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您可以在这里享受您的<a class="ae kf" href="http://bf.eralabs.io" rel="noopener ugc nofollow" target="_blank">折扣。</a></p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><a href="http://bf.eralabs.io"><div class="fe ff kg"><img src="../Images/f322772403668f8316905cec24b85586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B0qBLWIa0zP-zJcrenZN8w.png"/></div></a></figure></div><div class="ab cl ko kp hc kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hn ho hp hq hr"><p id="68bf" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这篇文章是我撰写的一系列<strong class="jl hv">实用</strong>文章的<strong class="jl hv">第二部分</strong>，旨在帮助开发者和架构师理解和构建面向服务的架构和微服务。</p><p id="1363" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我在同样的背景下写了其他的故事，比如这些链接:</p><ul class=""><li id="75f9" class="kv kw hu jl b jm jn jp jq js kx jw ky ka kz ke la lb lc ld dt translated"><a class="ae kf" rel="noopener" href="/@eon01/microservices-from-development-to-production-using-docker-docker-compose-docker-swarm-3cf37f97706b">微服务从开发到生产使用Docker，Docker Compose&amp;Docker Swarm</a></li><li id="1335" class="kv kw hu jl b jm le jp lf js lg jw lh ka li ke la lb lc ld dt translated"><a class="ae kf" rel="noopener" href="/@eon01/easy-docker-orchestration-with-docker-1-12-aws-efs-and-the-swarm-mode-87d51b6d5ad2#.59os1v6fd">利用Docker 1.12、AWS EFS和Swarm模式实现简单的Docker编排</a></li></ul><p id="ecc4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这篇文章也是我“精益出版”的书的一部分，名为<a class="ae kf" href="http://painlessdocker.com" rel="noopener ugc nofollow" target="_blank">无痛码头工人:释放码头工人的力量&amp;它的生态系统</a>。无痛Docker是一个<strong class="jl hv">实用的</strong>指南，基于真实世界的例子来掌握Docker及其生态系统。</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><a href="http://painlessdocker.com"><div class="fe ff lj"><img src="../Images/a4cbf1d6bd53d9a4ee548c857c53e48c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tyDWFMOE5hplODSFE8i8tw.jpeg"/></div></a><figcaption class="lk ll fg fe ff lm ln bd b be z ek"><a class="ae kf" href="http://painlessdocker.com" rel="noopener ugc nofollow" target="_blank">http://painlessdocker.com</a></figcaption></figure><p id="ee5a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在我的上一篇文章中(<a class="ae kf" href="https://hackernoon.com/benchmarking-amazon-sns-sqs-for-inter-process-communication-in-a-microservice-architecture-de0dfa8d6ac6#.68wr4qph3" rel="noopener ugc nofollow" target="_blank">对微服务架构中进程间通信的亚马逊SNS &amp; SQS进行基准测试</a>，我使用SNS/SQS测试了消息机制，即使基准测试是在我的笔记本电脑上完成的(而不是EC2实例)，结果也很好。</p><p id="f5e7" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">上一篇文章出现在许多时事通讯上，所以我决定继续我的测试并发表这篇文章。</p><p id="0a0b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">事件驱动架构</strong> ( <strong class="jl hv"> EDA </strong>)(或<strong class="jl hv">消息驱动架构)</strong>，是一种软件架构模式，促进消息的生产和消费，同时唤起特定的事件/反应来响应消费的消息。</p><p id="50df" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">经典的系统架构会在将数据保存到数据存储(mysql、postgresql、mongodb)后促进数据读取和反应..但这并不是最好的做法，尤其是如果你正在做实时或接近实时的处理，除非你想花时间和精力建立一个即时反应系统，否则请不要使用数据库，而是流数据。</p><p id="5c5c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我创建了两台机器(您可以为发布者和订阅者使用一台机器，因为它不会改变网络中的任何东西)</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="fe ff lo"><img src="../Images/8e82c6d258f4038711d3a8b0098c2f05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fnz_LJzfqIyXkmZ3R4KOJg.png"/></div></div><figcaption class="lk ll fg fe ff lm ln bd b be z ek">Used EC2 Machines</figcaption></figure><p id="139f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是简化的架构，我是AB负载测试人员。机器和服务都托管在欧盟-西方-1地区。</p><p id="15ef" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了最大限度地减少传输时间，建议在同一地区使用发布者和消费者机器。</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="fe ff lt"><img src="../Images/498ba5e194aa429e9a5ecdb364b79b3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y3HN5d_bQY-cDCjIbYte4w.png"/></div></div></figure><h1 id="4c55" class="lu lv hu bd lw lx ly lz ma mb mc md me ja mf jb mg jd mh je mi jg mj jh mk ml dt translated">负载测试？</h1><p id="d528" class="pw-post-body-paragraph jj jk hu jl b jm mm iv jo jp mn iy jr js mo ju jv jw mp jy jz ka mq kc kd ke hn dt mr translated">让我们考虑一个web服务器将访问日志写入EC2磁盘的例子。</p><p id="fa58" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在第一台机器上，我安装了Nginx:</p><pre class="kh ki kj kk fq na nb nc nd aw ne dt"><span id="70af" class="nf lv hu nb b fv ng nh l ni nj">apt-get -y install nginx</span></pre><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="fe ff nk"><img src="../Images/315f1e096cc95b7624a1c5bc85c10d10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ju7U3CHuNJNvJHPzzTILhg.png"/></div></div><figcaption class="lk ll fg fe ff lm ln bd b be z ek">Tested Page</figcaption></figure><p id="b7f6" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了简单起见，我保留了默认的Nginx页面，我们的测试是关于网络的，而不是Nginx负载测试。</p><p id="4f56" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">从左至右:</p><ul class=""><li id="34b0" class="kv kw hu jl b jm jn jp jq js kx jw ky ka kz ke la lb lc ld dt translated">在第一台机器上，我启动了publisher容器，它将读取访问日志并将它们发送到SNS。</li><li id="0df3" class="kv kw hu jl b jm le jp lf js lg jw lh ka li ke la lb lc ld dt translated">在第二台机器上，我启动了消费者容器，它将读取从SNS发送到SQS的数据(它直接连接到SQS服务)</li><li id="ca8b" class="kv kw hu jl b jm le jp lf js lg jw lh ka li ke la lb lc ld dt translated">在第三台机器上，我的localhost，我做了一个负载测试，可以看到我发出了1000个请求，并发级别为5</li></ul><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="fe ff nl"><img src="../Images/75f8142f964e417f8a31f861564db15f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7AiWvlNVICUGbiGuexZPdA.png"/></div></div></figure><p id="8dd3" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我使用Apache基准测试对我的服务器进行负载测试:</p><pre class="kh ki kj kk fq na nb nc nd aw ne dt"><span id="38ff" class="nf lv hu nb b fv ng nh l ni nj">ab -n 1000 -c 5 http://ec2-34-248-177-221.eu-west-1.compute.amazonaws.com/</span></pre><p id="81bd" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">再说一遍，我的测试主要是关于网络和从以下位置发送的数据:</p><pre class="kh ki kj kk fq na nb nc nd aw ne dt"><span id="40a8" class="nf lv hu nb b fv ng nh l ni nj">publisher -&gt; SNS -&gt; SQS -&gt; Consumer</span></pre><p id="e2a2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果我想测试Nginx，我可能会设置更高的并发级别。</p><p id="2eb6" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是关于请求的另一个有用信息:</p><pre class="kh ki kj kk fq na nb nc nd aw ne dt"><span id="ddd1" class="nf lv hu nb b fv ng nh l ni nj">curl -I http://ec2-34-248-177-221.eu-west-1.compute.amazonaws.com<br/>HTTP/1.1 200 OK<br/>Server: nginx/1.10.0 (Ubuntu)<br/>Date: Wed, 25 Jan 2017 22:17:27 GMT<br/>Content-Type: text/html<br/>Content-Length: 612<br/>Last-Modified: Wed, 25 Jan 2017 21:53:57 GMT<br/>Connection: keep-alive<br/>ETag: “58891e75–264”<br/>Accept-Ranges: bytes</span></pre><p id="2074" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当然还有我的测试:</p><pre class="kh ki kj kk fq na nb nc nd aw ne dt"><span id="e0c6" class="nf lv hu nb b fv ng nh l ni nj">Benchmarking ec2-34-248-177-221.eu-west-1.compute.amazonaws.com (be patient)<br/>Completed 100 requests<br/>Completed 200 requests<br/>Completed 300 requests<br/>Completed 400 requests<br/>Completed 500 requests<br/>Completed 600 requests<br/>Completed 700 requests<br/>Completed 800 requests<br/>Completed 900 requests<br/>Completed 1000 requests<br/>Finished 1000 requests</span><span id="161c" class="nf lv hu nb b fv nm nh l ni nj">Server Software:        nginx/1.10.0<br/>Server Hostname:        ec2-34-248-177-221.eu-west-1.compute.amazonaws.com<br/>Server Port:            80</span><span id="21f5" class="nf lv hu nb b fv nm nh l ni nj">Document Path:          /<br/>Document Length:        612 bytes</span><span id="5648" class="nf lv hu nb b fv nm nh l ni nj">Concurrency Level:      5<br/>Time taken for tests:   14.823 seconds<br/>Complete requests:      1000<br/>Failed requests:        0<br/>Total transferred:      854000 bytes<br/>HTML transferred:       612000 bytes<br/>Requests per second:    67.46 [#/sec] (mean)<br/>Time per request:       74.114 [ms] (mean)<br/>Time per request:       14.823 [ms] (mean, across all concurrent requests)<br/>Transfer rate:          56.26 [Kbytes/sec] received</span><span id="8472" class="nf lv hu nb b fv nm nh l ni nj">Connection Times (ms)<br/>              min  mean[+/-sd] median   max<br/>Connect:       31   37  13.3     34     176<br/>Processing:    32   37  10.2     34     141<br/>Waiting:       31   37  10.2     34     141<br/>Total:         63   74  17.7     69     209</span><span id="290b" class="nf lv hu nb b fv nm nh l ni nj">Percentage of the requests served within a certain time (ms)<br/>  50%     69<br/>  66%     71<br/>  75%     73<br/>  80%     75<br/>  90%     85<br/>  95%     98<br/>  98%    150<br/>  99%    180<br/> 100%    209 (longest request)</span></pre><p id="4129" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了运行publisher容器，我启动了我的容器日志——publisher:</p><pre class="kh ki kj kk fq na nb nc nd aw ne dt"><span id="6b8a" class="nf lv hu nb b fv ng nh l ni nj">docker run -it --name publisher -v /var/log/nginx/access.log:/logs -e AWS_ACCESS_KEY_ID=xxx -e AWS_SECRET_ACCESS_KEY=xxx -e SNS_TOPIC_ARN=arn:aws:sns:eu-west-1:xxxx:test -e TAG=vm1 -e REGION=eu-west-1  eon01/log-publisher:latest</span></pre><p id="f9f6" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对订户来说也是一样:</p><pre class="kh ki kj kk fq na nb nc nd aw ne dt"><span id="0220" class="nf lv hu nb b fv ng nh l ni nj">docker run -it --name subscriber -e AWS_ACCESS_KEY_ID=xxx -e AWS_SECRET_ACCESS_KEY=xxx -e SQS_QUEUE_NAME=test -e REGION=eu-west-1  eon01/log-subscriber:latest</span></pre><p id="588f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您可以将输出重定向到一个文件中，因为这两个容器都很详细。</p><h1 id="93d5" class="lu lv hu bd lw lx ly lz ma mb mc md me ja mf jb mg jd mh je mi jg mj jh mk ml dt translated">使用Python/SNS创建发布者</h1><p id="749d" class="pw-post-body-paragraph jj jk hu jl b jm mm iv jo jp mn iy jr js mo ju jv jw mp jy jz ka mq kc kd ke hn dt mr translated"><span class="l ms mt mu bm mv mw mx my mz di"> T </span>这是我使用tailer lib一行一行地将任何映射到/logs(从容器外部)的文件发布到SNS的主要代码。</p><p id="60cc" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因为Docker支持环境变量，所以我使用这个特性让我的程序也使用我在Docker Run命令中使用的相同变量。</p><pre class="kh ki kj kk fq na nb nc nd aw ne dt"><span id="f429" class="nf lv hu nb b fv ng nh l ni nj">import boto.sns, time, json, logging<br/>from datetime import datetime</span><span id="a92e" class="nf lv hu nb b fv nm nh l ni nj">import os<br/>import tailer</span><span id="061e" class="nf lv hu nb b fv nm nh l ni nj">aws_access_key_id = os.environ['AWS_ACCESS_KEY_ID']<br/>aws_secret_access_key = os.environ['AWS_SECRET_ACCESS_KEY']<br/>region = os.environ['REGION']<br/>sns_topic_arn = os.environ["SNS_TOPIC_ARN"]<br/>tag = os.environ["TAG"]</span><span id="0433" class="nf lv hu nb b fv nm nh l ni nj">file_path = "/logs"</span><span id="f012" class="nf lv hu nb b fv nm nh l ni nj">logging.basicConfig(filename="sns-publish.log", level=logging.DEBUG)<br/>c = boto.sns.connect_to_region(region, aws_access_key_id = aws_access_key_id, aws_secret_access_key=aws_secret_access_key)</span><span id="5566" class="nf lv hu nb b fv nm nh l ni nj">while 1:<br/>    for body in tailer.follow(open(file_path)):<br/>        subject = str(time.time()) + " " + tag<br/>        print str(time.time())<br/>        publication = c.publish(sns_topic_arn, body, subject)</span></pre><h1 id="ff6e" class="lu lv hu bd lw lx ly lz ma mb mc md me ja mf jb mg jd mh je mi jg mj jh mk ml dt translated">使用Python/SQS创建订阅者</h1><p id="fa45" class="pw-post-body-paragraph jj jk hu jl b jm mm iv jo jp mn iy jr js mo ju jv jw mp jy jz ka mq kc kd ke hn dt mr translated"><span class="l ms mt mu bm mv mw mx my mz di"> T </span>他的这段代码也使用boto来连接到正确的SQS，并在收到发送的消息后打印日期。</p><p id="123d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这个脚本中，我对环境变量使用了与Python/SQS相同的东西。</p><pre class="kh ki kj kk fq na nb nc nd aw ne dt"><span id="ba5c" class="nf lv hu nb b fv ng nh l ni nj">import boto.sqs, time, json<br/>import os<br/>from datetime import datetime</span><span id="b936" class="nf lv hu nb b fv nm nh l ni nj">aws_access_key_id = os.environ['AWS_ACCESS_KEY_ID']<br/>aws_secret_access_key = os.environ['AWS_SECRET_ACCESS_KEY']<br/>region = os.environ['REGION']<br/>sqs_queue_name = os.environ["SQS_QUEUE_NAME"]</span><span id="c949" class="nf lv hu nb b fv nm nh l ni nj">conn = boto.sqs.connect_to_region(region, aws_access_key_id = aws_access_key_id, aws_secret_access_key=aws_secret_access_key)<br/>queue = conn.get_queue(sqs_queue_name)</span><span id="7359" class="nf lv hu nb b fv nm nh l ni nj">x = 0</span><span id="cf2a" class="nf lv hu nb b fv nm nh l ni nj">while 1:<br/>    try:       <br/>        result_set = queue.get_messages()<br/>        if result_set != []:<br/>            message = result_set[0]<br/>            print str(time.time())<br/>            message_body = message.get_body()<br/>            m = json.loads(message_body)            <br/>            subject = m["Subject"]<br/>            body = m["Message"]<br/>            message_id = m["MessageId"]<br/>            conn.delete_message(queue, message)<br/>    except IndexError:<br/>        pass</span></pre><h1 id="2b46" class="lu lv hu bd lw lx ly lz ma mb mc md me ja mf jb mg jd mh je mi jg mj jh mk ml dt translated">基准测试结果</h1><p id="e1ce" class="pw-post-body-paragraph jj jk hu jl b jm mm iv jo jp mn iy jr js mo ju jv jw mp jy jz ka mq kc kd ke hn dt mr translated">我使用Google Sheets来计算两个时间戳之间的差异:</p><ul class=""><li id="2d19" class="kv kw hu jl b jm jn jp jq js kx jw ky ka kz ke la lb lc ld dt translated">发送到社交网站之前的时间(H)</li><li id="9634" class="kv kw hu jl b jm le jp lf js lg jw lh ka li ke la lb lc ld dt translated">刚收到SQS消息的时间(一)</li></ul><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div class="fe ff nn"><img src="../Images/da8a9a4c4afb750aad7fe92f248d22b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*6jGA5K3ARX-OW2sjV9wGsA.png"/></div></figure><p id="7838" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是显示I和J (J = I -HI)之间时间的图表。</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="fe ff no"><img src="../Images/8a28b9aa75e1c91858591d3e538734e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W0u1F5t5ZIWhE1s4KxDhjw.png"/></div></div></figure><p id="09fc" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">测试持续了<strong class="jl hv"> 14.823秒</strong>，在此期间<strong class="jl hv">发送了1000个请求</strong>，并发级别为<strong class="jl hv"> 5个请求</strong>。IMHO，这是很好的结果，因为最高响应时间为<strong class="jl hv"> 0.28秒</strong>，最低为<strong class="jl hv"> 0.009秒。</strong></p><p id="98b0" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">下面是不同响应时间的分布情况:</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div class="fe ff np"><img src="../Images/26522f9d1bab1ae4983d07ca4eba4fb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*qGMCik8k5FbfamQYp6k79g.png"/></div><figcaption class="lk ll fg fe ff lm ln bd b be z ek">Response Time Disctribution</figcaption></figure><p id="67cb" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是另一张图表，我在上面标出了最高、最低和平均运输时间:</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="fe ff nq"><img src="../Images/cc1d139a9735c4672523e3df2eb3a108.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FQ7_uePuSt29vkLaNBHlfQ.png"/></div></div><figcaption class="lk ll fg fe ff lm ln bd b be z ek">Average / Min / Max of SNS-&gt;SQS Networking Time</figcaption></figure><p id="b4af" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是所有的乡亲，第三部分即将推出。F <strong class="jl hv">或更多更新，使用这些链接关注我↓ </strong></p><h1 id="b03b" class="lu lv hu bd lw lx ly lz ma mb mc md me ja mf jb mg jd mh je mi jg mj jh mk ml dt translated">连接更深</h1><p id="af51" class="pw-post-body-paragraph jj jk hu jl b jm mm iv jo jp mn iy jr js mo ju jv jw mp jy jz ka mq kc kd ke hn dt mr translated"><span class="l ms mt mu bm mv mw mx my mz di">M</span>micro services正在改变我们制作软件的方式，但它的缺点之一是网络部分有时会很复杂，消息传递会直接受到网络问题的影响。使用SNS/SQS和发布/订阅模型似乎是创建跨服务消息中间件的一个好的解决方案。我使用的发布者/订阅者脚本并没有真正针对负载和速度进行优化，但它们是一个很好的用例。</p><p id="48f3" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你对这篇文章产生了共鸣，请加入来自世界各地的1000多名热情的DevOps工程师、开发人员和IT专家，订阅<a class="ae kf" href="http://devopslinks.com" rel="noopener ugc nofollow" target="_blank"> DevOpsLinks </a>。</p><p id="4f86" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可以在<a class="ae kf" href="https://twitter.com/eon01" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae kf" href="https://clarity.fm/aymenelamri/" rel="noopener ugc nofollow" target="_blank"> Clarity </a>或我的<a class="ae kf" href="http://aymenelamri.com" rel="noopener ugc nofollow" target="_blank">网站</a>上找到我，你也可以查看我的书籍和培训:<a class="ae kf" href="http://saltstackfordevops.com" rel="noopener ugc nofollow" target="_blank"> SaltStack For DevOps </a>、<a class="ae kf" href="http://practicalaws.com" rel="noopener ugc nofollow" target="_blank">实用AWS </a> &amp; <a class="ae kf" href="http://painlessdocker.com" rel="noopener ugc nofollow" target="_blank">无痛码头工</a>。</p><p id="e6f4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你喜欢这篇文章，请推荐并分享给你的追随者。</p><blockquote class="nr"><p id="f5a1" class="ns nt hu bd nu nv nw nx ny nz oa ke ek translated">别忘了查看我的培训<a class="ae kf" href="http://practicalaws.com" rel="noopener ugc nofollow" target="_blank">实用AWS </a></p></blockquote><figure class="oc od oe of og kl fe ff paragraph-image"><a href="http://practicalaws.com"><div class="fe ff ob"><img src="../Images/d5d1ad8547b7e2dc12a5df0141b7411a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9WfQeLwyP7DIpDejDcN5MQ.png"/></div></a></figure></div></div>    
</body>
</html>