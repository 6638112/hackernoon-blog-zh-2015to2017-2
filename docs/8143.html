<html>
<head>
<title>Setting up Django Channels on AWS Elastic Beanstalk</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在AWS弹性豆茎上设置Django通道</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/setting-up-django-channels-on-aws-elastic-beanstalk-716fd5a49c4a?source=collection_archive---------8-----------------------#2017-11-21">https://medium.com/hackernoon/setting-up-django-channels-on-aws-elastic-beanstalk-716fd5a49c4a?source=collection_archive---------8-----------------------#2017-11-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="8636" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">TL；博士</strong></p><p id="f0c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">更新:本教程是针对频道1的。如果你们想看第二频道的教程，请给我留言。</strong></p><p id="6748" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Django一直是现代实时、异步框架和库的异类之一。例如，如果您想构建一个聊天应用程序，Django可能不是您的首选。然而，对于那些讨厌JavaScript的人，或者如果你是一个“有期限的完美主义者”，Django Channels为你提供了一个很好的选择。</p><p id="ce5c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Django Channels是一个库，它为Django带来了异步web的力量。如果你不熟悉Django频道，我强烈建议你在进一步阅读之前先熟悉一下。有很好的文章解释了Django频道是什么，以及它如何改变你使用Django的方式。<a class="ae jp" href="https://realpython.com/blog/python/getting-started-with-django-channels/" rel="noopener ugc nofollow" target="_blank">https://real python . com/blog/python/getting-started-with-django-channels/</a>和<a class="ae jp" href="https://blog.heroku.com/in_deep_with_django_channels_the_future_of_real_time_apps_in_django" rel="noopener ugc nofollow" target="_blank">https://blog . heroku . com/in _ deep _ with _ django _ channels _ the _ future _ of _ real _ time _ apps _ in _ django</a>就是两个很好的例子。它还向您展示了如何使用通道构建一个基本的聊天应用程序。这是相当简单的设置，并会让你在几分钟内！</p><p id="7bbe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">托管Django通道应用程序的问题</strong></p><p id="364b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在传统的Django中，请求由Django应用程序本身处理。它查看请求和URL，确定要执行的正确视图函数，执行它，生成响应，并将响应发送回用户。相当简单。然而，Django Channels在两者之间引入了一个接口服务器(Daphne)。这意味着接口服务器现在与外界通信。接口服务器查看请求和URL，确定正确的“通道”，处理请求并创建供工作进程使用的“消息”，然后将消息放入该通道。像Redis这样的消息代理监听这些通道，并将消息传递给工作进程。工作进程监听消息队列，处理消息(很像一个视图函数),产生响应并将其发送回接口服务器，然后接口服务器将响应返回给用户。(请随意花一分钟来理解这一点，我花了很多时间:'))</p><p id="b97e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这意味着现在，不仅仅是一个进程在运行，您将开始使用:</p><p id="9977" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jq jr js jt b">python manage.py runserver</code></p><p id="c3a9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你会跑:</p><p id="cd34" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jq jr js jt b">daphne -p 8000 your_app.asgi:channel_layer</code></p><p id="11aa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">和</p><p id="82fa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jq jr js jt b">python manage.py runworker</code></p><p id="9435" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这使得Django通道能够支持多种类型的请求(HTTP、Websockets等)。但是很明显，它比标准的Django应用程序需要更多的资源。首先，它需要一个消息代理。您可以使用内存中的消息代理，但是不建议将其用于生产目的。在本例中，我们将在EC2实例中设置Redis，并将其用作消息代理。</p><p id="e601" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您使用的是Elastic Beanstalk，默认情况下它被配置为监听端口80，这通常是您的工作进程运行的地方。但是我们希望应用程序监听Daphne，所以这需要配置负载平衡器将请求转发到Daphne正在监听的端口。</p><p id="0b27" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是在这之前，我们首先需要托管Django应用程序本身。如果您不熟悉如何操作，请遵循以下步骤:</p><div class="ju jv fm fo jw jx"><a href="https://realpython.com/blog/python/deploying-a-django-app-and-postgresql-to-aws-elastic-beanstalk/" rel="noopener  ugc nofollow" target="_blank"><div class="jy ab ej"><div class="jz ab ka cl cj kb"><h2 class="bd hv fv z el kc eo ep kd er et ht dt translated">将Django + Python 3 + PostgreSQL部署到AWS Elastic Beanstalk</h2><div class="ke l"><h3 class="bd b fv z el kc eo ep kd er et ek translated">下面是如何设置和部署一个Django应用程序的简单介绍，它由Python 3提供支持，并且…</h3></div><div class="kf l"><p class="bd b gc z el kc eo ep kd er et ek translated">realpython.com</p></div></div><div class="kg l"><div class="kh l ki kj kk kg kl km jx"/></div></div></a></div><h2 id="381f" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jc ky kz la jg lb lc ld jk le lf lg lh dt translated">唯一的变化是您应该<strong class="ak">选择应用负载平衡器，而不是传统负载平衡器，因为WebSockets仅由应用负载平衡器</strong>提供本地支持。</h2><p id="4216" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated"><strong class="it hv">下一步:</strong></p><p id="7d0c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们需要为通道层提供Redis。我们可以通过两种方式做到这一点:</p><p id="d5a7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">1.A .从EC2提供Redis实例</p><p id="7ad1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">1.B .使用ElastiCache</p><p id="09a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以选择任何一个，但是请注意<strong class="it hv">elastic cache包含了一个</strong> <strong class="it hv">自由层</strong>。<strong class="it hv">你只需要做其中一个。a或1。B </strong>。</p><h1 id="0f67" class="ln ko hu bd kp lo lp lq kt lr ls lt kx lu lv lw la lx ly lz ld ma mb mc lg md dt translated"><strong class="ak"> 1.A .为消息代理提供Redis实例</strong></h1><p id="6f58" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">登录您的AWS控制台并转到EC2。单击顶部的“启动实例”,并在侧边菜单中选择AWS Marketplace。</p><p id="81fc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">搜索Redis 4.0</p><figure class="mf mg mh mi fq mj fe ff paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="fe ff me"><img src="../Images/e89c7e89d9430d68e068ca43e3b59e77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XsKJ8BlqHZwoqPNPMMNpfQ.png"/></div></div><figcaption class="mp mq fg fe ff mr ms bd b be z ek">Selecting Redis from AWS Marketplace</figcaption></figure><p id="d73e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这之后，按照接下来的步骤。请确保存储实例的ssh-key (pem文件)。之后，点击“查看并启动”。这将使您的Redis实例启动并运行。</p><p id="5b89" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在ssh进入Redis实例并打开<code class="eh jq jr js jt b">redis.conf</code>文件。</p><p id="dc6e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jq jr js jt b">sudo nano /jet/etc/redis/redis.conf</code></p><p id="151b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">将地址从<code class="eh jq jr js jt b">127.0.0.1</code>更改为<code class="eh jq jr js jt b">0.0.0.0</code>，将端口从<code class="eh jq jr js jt b">1999</code>更改为<code class="eh jq jr js jt b">6379</code></p><p id="e54a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用以下命令保存并重启:</p><p id="1e2b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jq jr js jt b">sudo service restart redis</code></p><p id="055c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以通过运行<code class="eh jq jr js jt b">netstat -antpl</code>来检查所有配置是否正确</p><p id="acb1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个命令应该显示Redis运行在0.0.0.0:6379。</p><p id="1f66" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">之后，从EC2 Dashboard中选择实例，并在下面的菜单中选择它的安全组(这应该类似于Redis 4–0–170715-Redis _ 4 _ 0 _ 0-AutogenByAWSMP)。使用以下信息添加新的入站规则:</p><p id="5f7d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">类型:自定义TCP规则，协议:TCP，端口范围:6379，来源:0.0.0.0/0</p><p id="9d84" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果它已经存在，您不需要添加上面的内容，或者如果端口号不同，您可以只修改现有的行。现在，从EC2 Dashboard获取Redis实例的公共DNS，并保存它以供参考。</p><h1 id="da26" class="ln ko hu bd kp lo lp lq kt lr ls lt kx lu lv lw la lx ly lz ld ma mb mc lg md dt translated">1.B. <strong class="ak">用Redis实例设置ElastiCache】</strong></h1><p id="187e" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated"><strong class="it hv">本节演职员表:</strong> <a class="ae jp" rel="noopener" href="/@cpvandehey"> <strong class="it hv">查德凡德嘿</strong> </a></p><p id="603b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">登录到您的AWS控制台并转到ElastiCache服务。单击创建一个新的ElastiCache集群，或者如果您之前没有创建任何东西，请单击“开始”。我们将建立一个EC Redis集群。</p><p id="7193" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">a.单击Redis作为您的集群引擎</p><p id="4554" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">b.输入名称、描述并选择可用的最新引擎版本。</p><p id="a8ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">c.确保端口设置为6379。</p><p id="edb2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">d.将节点类型设置为最小的可用类型</p><p id="3fb1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">e.选择顶部的T2-&gt;选择cache.t2.micro(用于空闲层)</p><p id="388a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">f.为副本数量选择“无”，并取消选择“带自动故障切换的多az”。</p><p id="768c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">g.从现有选项中选择一个现有子网，或者选择与EC2s相同的AZ创建一个新子网。</p><p id="0990" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">h.选择您在Elastic Beanstalk中创建的ec2的安全组。</p><p id="35f4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">I .取消选择“启用自动备份”并单击“创建”</p><p id="cc3a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您将被重定向到您的ElastiCache集群/实例。在这里，您将看到您的实例已经启动和配置。这个过程完成后，一定要记下ElastiCache实例的url，因为稍后需要用它来配置Django应用程序。</p><h1 id="0670" class="ln ko hu bd kp lo lp lq kt lr ls lt kx lu lv lw la lx ly lz ld ma mb mc lg md dt translated">2.编辑Django配置</h1><p id="e23b" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">现在，在用于生产的<code class="eh jq jr js jt b">settings.py</code>文件中，更改redis主机和端口以使用新创建的Redis实例。</p><pre class="mf mg mh mi fq mt jt mu mv aw mw dt"><span id="9125" class="kn ko hu jt b fv mx my l mz na">CHANNEL_LAYERS = {</span><span id="c650" class="kn ko hu jt b fv nb my l mz na"> "default": {</span><span id="5db3" class="kn ko hu jt b fv nb my l mz na">  "BACKEND": "asgi_redis.RedisChannelLayer",</span><span id="fa2d" class="kn ko hu jt b fv nb my l mz na">  "CONFIG": {</span><span id="3d22" class="kn ko hu jt b fv nb my l mz na">   "hosts": ["redis://(&lt;The Public DNS of the Redis instance&gt;, 6379)"],</span><span id="5757" class="kn ko hu jt b fv nb my l mz na">  },</span><span id="38bc" class="kn ko hu jt b fv nb my l mz na"> "ROUTING": "&lt;your_app&gt;.routing.channel_routing", </span><span id="402b" class="kn ko hu jt b fv nb my l mz na"> }</span><span id="c303" class="kn ko hu jt b fv nb my l mz na">}</span></pre><p id="771a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请将<your app="">更改为您的应用程序名称。这将配置您的Django应用程序来使用我们创建的Redis实例。</your></p><h1 id="b0c5" class="ln ko hu bd kp lo lp lq kt lr ls lt kx lu lv lw la lx ly lz ld ma mb mc lg md dt translated"><strong class="ak"> 3。将Daphne服务器和工作进程作为守护进程运行</strong></h1><p id="ad11" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">在你的app目录下，打开<code class="eh jq jr js jt b">.ebextensions</code>文件夹，新建一个名为<code class="eh jq jr js jt b">daemon.config</code>的文件，内容如下:</p><figure class="mf mg mh mi fq mj"><div class="bz el l di"><div class="nc nd l"/></div></figure><p id="af54" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请将<your_project>更改为您的django应用的名称。这基本上创建了一个脚本并将其放入<code class="eh jq jr js jt b">/opt/elasticbeanstalk/hooks/appdeploy/post/</code></your_project></p><p id="4fce" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以便它在应用程序部署后执行。现在，这个脚本又创建了一个超级用户配置脚本，它负责运行守护进程和管理超级用户。(同样，请随意花一分钟来理解这一点:') )</p><h1 id="1ed7" class="ln ko hu bd kp lo lp lq kt lr ls lt kx lu lv lw la lx ly lz ld ma mb mc lg md dt translated"><strong class="ak"> 4。最后一步:配置ALB </strong></h1><p id="7537" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">现在我们已经设置了Redis，daphne和worker进程正在运行，现在我们需要做的就是配置我们的应用程序负载平衡器，将请求转发到我们的Daphne服务器，该服务器正在侦听端口5000(请检查守护进程的配置脚本)。</p><p id="4397" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在你的<code class="eh jq jr js jt b">.ebextensions</code>文件夹中创建一个名为<code class="eh jq jr js jt b">alb_listener.config</code>的新文件，并放入下面的代码。</p><pre class="mf mg mh mi fq mt jt mu mv aw mw dt"><span id="1cd1" class="kn ko hu jt b fv mx my l mz na">option_settings:<br/>  aws:elbv2:listener:80:<br/>    DefaultProcess: http<br/>    ListenerEnabled: 'true'<br/>    Protocol: HTTP<br/>  aws:elasticbeanstalk:environment:process:http:<br/>    Port: '5000'<br/>    Protocol: HTTP</span></pre><p id="8981" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请小心空格，因为这是YAML语法。</p><p id="bcb7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">重新部署您的应用程序和Viola！你的Django Channels应用已经在AWS Elastic Beanstalk上运行了。</p><p id="3407" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你有什么问题，欢迎在评论中提问！如果你喜欢这篇博文，欢迎对以后的博文提出任何建议。:')</p><p id="8d77" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">感谢阅读！</p></div></div>    
</body>
</html>