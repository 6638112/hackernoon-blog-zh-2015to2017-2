<html>
<head>
<title>Optimising your application bundle size with webpack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用webpack优化您的应用捆绑包大小</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/optimising-your-application-bundle-size-with-webpack-e85b00bab579?source=collection_archive---------1-----------------------#2017-01-15">https://medium.com/hackernoon/optimising-your-application-bundle-size-with-webpack-e85b00bab579?source=collection_archive---------1-----------------------#2017-01-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="e16e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我最近构建了一个React.js应用程序，它可以被评为中等复杂的单页面应用程序。我希望优化各种客户端的页面加载时间，并尝试在一个可用的工具上分析网站，以检查我们做得如何。</p><p id="d4a9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">偶然发现谷歌的<a class="ae jp" href="https://testmysite.thinkwithgoogle.com/" rel="noopener ugc nofollow" target="_blank"> testmysite </a>并对网页进行了分析，得到了以下结果:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/c28c759e471c4d41e9fda08b55267fa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qk8My0SLKE7BeJisYjaCSQ.png"/></div></div></figure><p id="8970" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该网站被评为在设计上非常响应，但在加载时间上却不太“响应”。我正在评估代码的各个部分，以解决页面加载时间的问题，这篇文章为那些寻求优化的人提供了指导。</p><p id="9d5b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">检查的第一步是当前的包大小，并检查是否所有的依赖包都是绝对必要的。</p><pre class="jr js jt ju fq kc kd ke kf aw kg dt"><span id="e4d6" class="kh ki hu kd b fv kj kk l kl km">$ webpack -p --progress<br/>Hash: dbce3735c9520e2dc682<br/>Version: webpack 1.14.0<br/>Time: 54264ms<br/>            Asset     Size  Chunks             Chunk Names<br/>    dist/index.js  3.29 MB       0  [emitted]  main<br/>dist/index.js.map  13.7 MB       0  [emitted]  main<br/>   [0] multi main 40 bytes {0} [built]<br/>    + 1374 hidden modules</span></pre><p id="44e2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当前的包大小超过3兆字节，这解释了性能分析工具的糟糕分数。</p><h2 id="a0e3" class="kh ki hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf dt translated">1.分析您的捆绑包依赖关系</h2><p id="f304" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">我使用了<a class="ae jp" href="https://www.npmjs.com/package/webpack-bundle-analyzer" rel="noopener ugc nofollow" target="_blank"> webpack-bundle-analyzer </a>，它分析webpack统计数据并给出一个很好的可视化效果，一眼就能知道漏桶！</p><p id="b1b2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了快速参考，我列出了安装步骤。使用以下命令安装软件包</p><pre class="jr js jt ju fq kc kd ke kf aw kg dt"><span id="080f" class="kh ki hu kd b fv kj kk l kl km">$ npm install --save-dev webpack-bundle-analyzer</span></pre><p id="43ff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">修改您的<code class="eh ll lm ln kd b">webpack.config.js</code>以包含插件。如果每个环境都有多个概要文件，那么最好在生产配置中这样做，并为该概要文件构建应用程序</p><pre class="jr js jt ju fq kc kd ke kf aw kg dt"><span id="ff83" class="kh ki hu kd b fv kj kk l kl km">var BundleAnalyzerPlugin <strong class="kd hv">=</strong> require('webpack-bundle-analyzer').BundleAnalyzerPlugin;</span><span id="bd01" class="kh ki hu kd b fv lo kk l kl km"><em class="lp">// ...<br/></em>plugins<strong class="kd hv">:</strong> [<strong class="kd hv">new</strong> BundleAnalyzerPlugin()]<br/><em class="lp">// ...</em></span></pre><p id="1bc3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在启动服务器应该会在<a class="ae jp" href="http://localhost:8888" rel="noopener ugc nofollow" target="_blank"> http://localhost:8888 </a>显示可视化效果。您应该看到类似下面的内容，并且您可以深入到任何级别，以了解需要调整或删除的包。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff lq"><img src="../Images/32c44fff422110094f27e11d34ee68b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dusVhPiL44VDoS4gJHMWSg.gif"/></div></div><figcaption class="lr ls fg fe ff lt lu bd b be z ek">webpack-bundle-analyzer sample report</figcaption></figure><p id="8b84" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这应该有助于理解重量依赖性。此外，当导入依赖项时，最好只从库中导入必要的函数/组件，这样可以更有效地打包到包中。如下图所示的第二种方法更有效。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lv lw l"/></div></figure><h2 id="be4e" class="kh ki hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf dt translated">2.构建中的正确节点环境</h2><p id="cc02" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">向webpack指明正确的环境将确保开发和测试产品不会作为捆绑包的一部分打包。为此，您可以在插件配置中将<code class="eh ll lm ln kd b">NODE_ENV</code>定义为production</p><pre class="jr js jt ju fq kc kd ke kf aw kg dt"><span id="36dc" class="kh ki hu kd b fv kj kk l kl km"><strong class="kd hv">plugins: [...<br/>    new </strong>webpack.DefinePlugin({<br/>             <strong class="kd hv">'process.env.NODE_ENV'</strong>: <strong class="kd hv">'"production"'<br/>    </strong>}),<br/>..]</span></pre><h2 id="8245" class="kh ki hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf dt translated">3.包括最少的源映射信息</h2><p id="0ea8" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">当您为生产而构建时，在缩小和组合JavaScript文件的同时，您会生成一个包含原始文件信息的源映射。可以为开发或登台环境生成具有最大详细级别的源映射。但是，我们可以为生产选择最优化形式的源地图。</p><p id="2bea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">检查您的webpack配置，通常会看到<code class="eh ll lm ln kd b"><strong class="it hv">devtool: ‘eval’</strong></code>，这是构建应用程序的最快方法之一，大多数开发代码信息都捆绑在输出中。让我们将该设置切换为<code class="eh ll lm ln kd b">eval-source-map</code>或<code class="eh ll lm ln kd b">cheap-module-source-map.</code>参考此<a class="ae jp" href="https://webpack.github.io/docs/configuration.html#devtool" rel="noopener ugc nofollow" target="_blank">文档</a>以了解关于这些配置参数的更多细节。</p><p id="d222" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们在这个阶段再次检查捆绑包的大小，看看我们节省了多少。</p><pre class="jr js jt ju fq kc kd ke kf aw kg dt"><span id="8b92" class="kh ki hu kd b fv kj kk l kl km">$ webpack -p --progress<br/>Hash: 68a52fddbcc2898a5899<br/>Version: webpack 1.14.0<br/>Time: 29757ms<br/>            Asset     Size  Chunks             Chunk Names<br/>    dist/index.js  1.71 MB       0  [emitted]  main<br/>dist/index.js.map  464 bytes       0  [emitted]  main<br/>   [0] multi main 40 bytes {0} [built]<br/>    + 1365 hidden modules</span></pre><p id="c824" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从<code class="eh ll lm ln kd b">3.29mb</code>到<code class="eh ll lm ln kd b">1.71mb</code>，我们也注意到源文件的大小已经大大减小了！</p><h2 id="11fe" class="kh ki hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf dt translated">4.优化包大小的其他著名插件</h2><p id="8da3" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">我列出了我用来进一步缩小尺寸的其他插件。评估适合您的用例的工具，并根据需要使用它们:</p><ul class=""><li id="536e" class="lx ly hu it b iu iv iy iz jc lz jg ma jk mb jo mc md me mf dt translated"><a class="ae jp" href="https://github.com/webpack/compression-webpack-plugin" rel="noopener ugc nofollow" target="_blank">compression-web pack-plugin</a>:一个用于压缩资产的插件，它将生成。gz文件以及资产，并且根据客户端，资产服务器可以被配置为按需提供服务。</li><li id="c726" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated"><a class="ae jp" href="https://webpack.github.io/docs/list-of-plugins.html#dedupeplugin" rel="noopener ugc nofollow" target="_blank">重复数据删除插件</a>:搜索相同或相似的文件，并在输出中删除重复数据。这给条目块带来了一些开销，但是可以有效地减小文件大小。[编辑:在Webpack v.2中默认可用]</li><li id="4ed8" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated"><a class="ae jp" href="https://webpack.github.io/docs/list-of-plugins.html#uglifyjsplugin" rel="noopener ugc nofollow" target="_blank"> uglifyjs-plugin </a>:最小化所有块的JavaScript输出。关于这个插件处理的过多选项，请参考文档</li><li id="c428" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated"><a class="ae jp" href="https://webpack.github.io/docs/list-of-plugins.html#ignoreplugin" rel="noopener ugc nofollow" target="_blank"> ignore-plugin </a>:当你想从一个库中导入选择性模块时很方便。例如，当使用<a class="ae jp" href="https://momentjs.com/" rel="noopener ugc nofollow" target="_blank"> moment.js </a>时，不需要包含库附带的所有语言环境，只需要包含需要的语言环境。下面的代码示例也说明了这一点。</li></ul><p id="ccbd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最终的webpack配置可能如下所示:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lv lw l"/></div></figure><p id="e609" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们在最终配置就绪后再次检查一下包的大小…</p><pre class="jr js jt ju fq kc kd ke kf aw kg dt"><span id="1f01" class="kh ki hu kd b fv kj kk l kl km">$ webpack -p --progress<br/>Hash: 68a52fddbcc2898a5899<br/>Version: webpack 1.14.0<br/>Time: 29757ms<br/>            Asset     Size  Chunks             Chunk Names<br/>    dist/index.js  1.54 MB       0  [emitted]  main<br/>dist/index.js.gz   390 KB        0  [emitted]  main<br/>dist/index.js.map  464 bytes     0  [emitted]  main   <br/>   [0] multi main 40 bytes {0} [built]<br/>    + 1365 hidden modules</span></pre><p id="2d03" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意压缩的js文件的大小，它下降到了<code class="eh ll lm ln kd b">390kb</code>这将大大改善页面加载时间。让我们再运行一次google profiler测试，看看这个网站在最新的捆绑包中表现如何。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff ml"><img src="../Images/b49a2ebeaac826900ba78ed769befecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mcG7BlaR1cbiV820QZWXgQ.png"/></div></div><figcaption class="lr ls fg fe ff lt lu bd b be z ek">Final scores after applying all optimizations</figcaption></figure><p id="6022" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">编辑:</p><h1 id="20ce" class="mm ki hu bd kn mn mo mp kr mq mr ms kv mt mu mv ky mw mx my lb mz na nb le nc dt translated">5.代码分割</h1><p id="0426" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">我想在这篇文章中加入代码分割，作为优化webpack构建的另一个重要步骤。这个想法很简单。如果您使用类似于<code class="eh ll lm ln kd b">react-router</code>的东西在应用程序中定义多个页面，那么很容易绘制一个依赖关系树，以路径中定义的组件作为起点，并将该页面所需的所有资产(js、css、images)捆绑为一个单独的块。如果你使用动态导入，这里讨论的<a class="ae jp" href="https://facebook.github.io/react/blog/2017/05/18/whats-new-in-create-react-app.html#code-splitting-with-dynamic-import" rel="noopener ugc nofollow" target="_blank"/>，webpack可以聪明地分割出每个页面所需的代码块。</p><p id="902e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">按照这篇<a class="ae jp" href="http://serverless-stack.com/chapters/code-splitting-in-create-react-app.html" rel="noopener ugc nofollow" target="_blank">写得很好的文章</a>中的步骤为你的项目实现代码拆分。</p><p id="f6dc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">完成更改后，当您启动webpack prod构建时，您应该会看到这样的输出，它为用户访问的每个页面创建了多个要下载的脚本块，从而大大减少了页面加载时间！</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff nd"><img src="../Images/7e524192befa118d1827eadba3deaf13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*W5EMzfBsMirJf5S8dN4gtA.png"/></div></figure><p id="659b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我<em class="lp">如果你喜欢这篇文章，请关注我的</em><a class="ae jp" href="https://twitter.com/rcdexta" rel="noopener ugc nofollow" target="_blank"><em class="lp">Twitter</em></a><em class="lp">以获得更多类似主题的更新..</em></p><blockquote class="ne nf ng"><p id="f922" class="ir is lp it b iu iv iw ix iy iz ja jb nh jd je jf ni jh ji jj nj jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是AMI家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is lp it b iu iv iw ix iy iz ja jb nh jd je jf ni jh ji jj nj jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff nk"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="nl lw l"/></div></figure></div></div>    
</body>
</html>