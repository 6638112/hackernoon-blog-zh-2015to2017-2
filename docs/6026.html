<html>
<head>
<title>Serverless: password protecting a static website in an AWS S3 bucket</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器:AWS S3桶中静态网站的密码保护</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/serverless-password-protecting-a-static-website-in-an-aws-s3-bucket-bfaaa01b8666?source=collection_archive---------0-----------------------#2017-08-30">https://medium.com/hackernoon/serverless-password-protecting-a-static-website-in-an-aws-s3-bucket-bfaaa01b8666?source=collection_archive---------0-----------------------#2017-08-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="2b23" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">使用Lambda@Edge对S3和CloudFront进行基本HTTP身份验证</h2></div><p id="6cb8" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">几个月来，我一直在寻找一个解决方案，为亚马逊上的S3桶添加基本的HTTP认证。有一些选项包括<a class="ae kf" href="http://docs.aws.amazon.com/cli/latest/reference/s3/presign.html" rel="noopener ugc nofollow" target="_blank">预先签名的URL</a>(仅单个对象)，使用第三方<a class="ae kf" href="http://www.s3auth.com/" rel="noopener ugc nofollow" target="_blank">免费的</a>或<a class="ae kf" href="https://storagemadeeasy.com/" rel="noopener ugc nofollow" target="_blank">商业</a>服务(隐私问题)，创建EC2/Heroku/等等。使用<a class="ae kf" href="https://www.npmjs.com/package/s3-basic-auth" rel="noopener ugc nofollow" target="_blank">中间件</a>代理请求(复杂且非无服务器)，使用<a class="ae kf" href="http://xingdig.com/blog/password-protecting-an-s3-website/" rel="noopener ugc nofollow" target="_blank">页面重定向和桶策略</a>(不安全)。它们都有一个共同的问题—都是解决方法。</p><p id="f7fc" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我几乎走上了在ECS上构建Apache或Nginx容器来充当S3代理的道路。然后，我偶然看到了一篇关于<a class="ae kf" href="http://docs.aws.amazon.com/lambda/latest/dg/lambda-edge.html" rel="noopener ugc nofollow" target="_blank"> Lambda@Edge </a>在美国东部(N. Virginia)地区(us-east-1)普遍发售的<a class="ae kf" href="https://aws.amazon.com/blogs/aws/lambdaedge-intelligent-processing-of-http-requests-at-the-edge/" rel="noopener ugc nofollow" target="_blank">博文。</a></p><p id="7c02" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">简而言之，Lambda@Edge允许您将AWS Lambda函数附加到CloudFront行为。CloudFront是亚马逊的CDN解决方案，可以坐在S3桶前，提供低延迟响应、高传输速度，支持使用亚马逊免费SSL证书的自定义域，并与其他AWS服务集成，现在包括Lambda。</p><p id="4166" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我浏览了公告中提到的用例，事情开始看起来很有希望:</p><blockquote class="kg kh ki"><p id="14d2" class="jj jk kj jl b jm jn iv jo jp jq iy jr kk jt ju jv kl jx jy jz km kb kc kd ke hn dt translated">您可以使用它:<br/> -检查cookies并重写URL以执行A/B测试。<br/> -根据用户代理头向用户发送特定对象。<br/> -在将请求传递给源之前，通过查找特定的报头来实施访问控制。<br/> -添加、删除或修改标题，将用户导向不同的缓存对象。<br/> -生成新的HTTP响应。<br/> -干净地支持传统URL。<br/> -修改或压缩标题或URL以提高缓存利用率。<br/> -向其他互联网资源发出HTTP请求，并使用结果定制响应。</p></blockquote><p id="aa0e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">拦截请求头并生成新的HTTP响应正是我们实现基本HTTP认证所需要的！</p></div><div class="ab cl kn ko hc kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hn ho hp hq hr"><h1 id="d9f7" class="ku kv hu bd kw kx ky kz la lb lc ld le ja lf jb lg jd lh je li jg lj jh lk ll dt translated">基本HTTP身份验证概述</h1><p id="d892" class="pw-post-body-paragraph jj jk hu jl b jm lm iv jo jp ln iy jr js lo ju jv jw lp jy jz ka lq kc kd ke hn dt translated">让我们快速了解一下基本的HTTP认证是如何工作的。</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff lr"><img src="../Images/7824a10ef5379e32144dd24d192a0778.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*Qg-dkUQHomX9HKt1mJTP5A.png"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Basic HTTP Authentication flow diagram (<a class="ae kf" href="https://docs.microsoft.com/en-us/aspnet/web-api/overview/security/basic-authentication/_static/image1.png" rel="noopener ugc nofollow" target="_blank">src</a>)</figcaption></figure><p id="76d1" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在引擎盖下，这是一个简单的客户端-服务器握手。如果客户端请求受保护的资源，但没有通过<code class="eh md me mf mg b">Authorization</code>请求头提供有效的auth字符串，服务器会回复一个<code class="eh md me mf mg b">401 Unauthorized</code>状态和一个<code class="eh md me mf mg b">WWW-Authenticate: Basic</code>响应头。该响应会在浏览器中触发用户名和密码提示。</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff mh"><img src="../Images/9ce5b0380b1c6cc245432fc13fe179d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*H_znfoFyjYcAP9TUtPLZ6w.png"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Basic HTTP Auth prompt in Chrome</figcaption></figure><p id="3e32" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">用户输入凭证后，浏览器会创建一个base64编码的auth字符串，并在对同一领域的所有后续请求的<code class="eh md me mf mg b">Authorization</code>请求头中使用它。因为后续请求在<code class="eh md me mf mg b">Authorization</code>头中带有有效的auth字符串，所以服务器用<code class="eh md me mf mg b">200 OK</code>代码响应并照常提供内容。</p><p id="527e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">下面是生成验证字符串的伪代码:</p><pre class="ls lt lu lv fq mi mg mj mk aw ml dt"><span id="4ef2" class="mm kv hu mg b fv mn mo l mp mq">authString = "Basic base64('username:password')"</span></pre><p id="9035" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">从技术上讲，基本HTTP Auth中使用的加密方法和认证握手并不比以纯文本形式传递凭证更安全。这就是为什么您应该在任何通过网络传递敏感信息的地方使用HTTPS。</p></div><div class="ab cl kn ko hc kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hn ho hp hq hr"><h1 id="c927" class="ku kv hu bd kw kx ky kz la lb lc ld le ja lf jb lg jd lh je li jg lj jh lk ll dt translated">在Lambda函数中实现基本的HTTP认证</h1><p id="18c4" class="pw-post-body-paragraph jj jk hu jl b jm lm iv jo jp ln iy jr js lo ju jv jw lp jy jz ka lq kc kd ke hn dt translated">这里有一个Lambda函数，它实现了基本的HTTP Auth握手:</p><figure class="ls lt lu lv fq lw"><div class="bz el l di"><div class="mr ms l"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Lambda function implementing Basic HTTP Auth handshake</figcaption></figure><p id="0a68" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您在CloudFront行为设置中将该函数附加到<strong class="jl hv">查看器请求</strong>事件类型。用户名和密码在函数中分别被硬编码为<code class="eh md me mf mg b">authUser</code>和<code class="eh md me mf mg b">authPass</code>。必要时进行调整。</p><p id="d989" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">附加到查看器响应/请求事件的Lambda函数不允许进行网络调用，因此不可能在函数外部存储或验证凭证(例如，在DynamoDB中)。</p><p id="0ee9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> <em class="kj">更新:</em> </strong> <em class="kj">现在已经不是这样了。Lambda@Edge现</em> <a class="ae kf" href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/lambda-requirements-limits.html#lambda-requirements-network-access" rel="noopener ugc nofollow" target="_blank"> <em class="kj">正式支持</em> </a> <em class="kj">网络访问查看器请求/响应事件。现在完全可以在DynamoDB表中管理凭证或使用任何外部API/提供者来验证用户，只要网络调用花费</em> <a class="ae kf" href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html#limits-lambda-at-edge" rel="noopener ugc nofollow" target="_blank"> <em class="kj">不到5s就可以完成</em> </a> <em class="kj">。</em></p></div><div class="ab cl kn ko hc kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hn ho hp hq hr"><p id="2a85" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">查看我之前提到的关于如何将Lambda函数附加到CloudFront行为的博文。我将会写一篇关于整个链设置的更详细的文章，但是你应该已经明白了要点，并且能够把这些片段放在一起。</p><p id="069b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> <em class="kj">更新:</em> </strong> <em class="kj">戴夫·谢泼德写了一个</em> <a class="ae kf" href="http://kynatro.com/blog/2018/01/03/a-step-by-step-guide-to-creating-a-password-protected-s3-bucket/" rel="noopener ugc nofollow" target="_blank"> <em class="kj">分步教程</em> </a> <em class="kj">和多米尼克·杜姆拉夫拼凑了一个</em> <a class="ae kf" href="https://github.com/dumrauf/serverless_static_website_with_basic_auth" rel="noopener ugc nofollow" target="_blank"> <em class="kj"> CloudFormation模板</em> </a> <em class="kj">来启动整个设置。看看他们。</em></p><p id="d43b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里有一个S3桶中的静态网站示例，由CloudFront和Lamda@Edge处理基本的认证密码保护。无服务器。</p><pre class="ls lt lu lv fq mi mg mj mk aw ml dt"><span id="9646" class="mm kv hu mg b fv mn mo l mp mq"><a class="ae kf" href="https://d3e48dxmnonmo7.cloudfront.net/" rel="noopener ugc nofollow" target="_blank">https://d3e48dxmnonmo7.cloudfront.net/</a></span><span id="60df" class="mm kv hu mg b fv mt mo l mp mq">username: user<br/>password: pass</span></pre></div><div class="ab cl kn ko hc kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hn ho hp hq hr"><p id="0c08" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> <em class="kj">更新</em> </strong> <em class="kj">:关于绕过CloudFront直接访问S3的资源，评论中提出了一个问题。</em></p><p id="1a70" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对<a class="ae kf" href="https://aws-website-vgsite-v1rhi.s3.amazonaws.com" rel="noopener ugc nofollow" target="_blank">原点S3桶</a>的访问仅限于CloudFront发行版。用户不能绕过CloudFront直接访问bucket中的资源(即使他们知道bucket中的<a class="ae kf" href="https://aws-website-vgsite-v1rhi.s3.amazonaws.com/index.html" rel="noopener ugc nofollow" target="_blank">直接URL </a>)。</p><p id="797e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这可以在CloudFront中的Origin Settings下轻松配置，无需手动编写S3存储桶策略:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="fe ff mu"><img src="../Images/e74638639f2cb5754d0fb3af4c751495.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O4qlTW4Fe5o3iLzoqqfbyw.png"/></div></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">S3 bucket origin settings</figcaption></figure></div><div class="ab cl kn ko hc kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hn ho hp hq hr"><p id="86f7" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我希望你喜欢阅读，并发现这篇文章很有用。<br/>如果是这样全部鼓掌50次！这有助于其他人发现媒体上的内容。</p></div></div>    
</body>
</html>