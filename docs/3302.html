<html>
<head>
<title>Building on top of Reactive Streams</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">建立在反应流之上</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/building-on-top-of-reactive-streams-86dacdbf9ad?source=collection_archive---------10-----------------------#2017-03-25">https://medium.com/hackernoon/building-on-top-of-reactive-streams-86dacdbf9ad?source=collection_archive---------10-----------------------#2017-03-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="dcb0" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">反应流</h1><p id="a045" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated"><em class="kn">反应流</em>规范允许我们创建以异步方式通信的应用程序组件，同时使用背压机制维护安全性。</p><p id="4252" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated"><em class="kn">反应流</em>正在每一种现代编程语言中实现，比如JavaScript和Scala。</p><p id="4f11" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">让我们看一个简单的例子，它将一个<strong class="jr hv"> <em class="kn">生产者</em> </strong>连接到一个<strong class="jr hv"> <em class="kn">订户</em> </strong>来看看流程是如何进行的。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="e60d" class="lc is hu ky b fv ld le l lf lg"><strong class="ky hv">val </strong>publisher = <em class="kn">Subject</em>[Int]<br/><br/><strong class="ky hv">val </strong>subscriber = publisher.subscribe(message =&gt; <em class="kn">println</em>(message))<br/><br/><br/>publisher.onNext(5)</span></pre><p id="a86d" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">在这里我们已经创建了一个<strong class="jr hv"> <em class="kn">主题【Int】</em></strong>所以我们可以调用<strong class="jr hv"> <em class="kn">。onNext </em>上的</strong>将一条消息(<strong class="jr hv">T23】IntT25)推送到<em class="kn">流</em>中。在管道的另一端，我们有一个<strong class="jr hv"> <em class="kn">订阅者</em> </strong>，即<strong class="jr hv"> <em class="kn">将</em> </strong>订阅给<strong class="jr hv"> <em class="kn">发布者</em> </strong>，并指定每个新消息都将使用一个函数进行处理。</strong></p><p id="eda2" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">如您所见，我们需要两个部分，一个发布者和一个订阅者，我们需要将它们连接在一起。</p><h2 id="bb7c" class="lc is hu bd it lh li lj ix lk ll lm jb ka ln lo jf ke lp lq jj ki lr ls jn lt dt translated">流上的操作</h2><p id="4b52" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">有时我们不需要处理每一条消息，所以我们可以<em class="kn">过滤</em>管道。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="a5b1" class="lc is hu ky b fv ld le l lf lg"><strong class="ky hv">val </strong>subscriber = publisher<br/>  .filter(_ % 2 == 0)<br/>  .subscribe(message =&gt; <em class="kn">println</em>(message))</span></pre><p id="56e1" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">其他时候，我们需要应用转换，所以我们<em class="kn">在流上映射</em>。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="a194" class="lc is hu ky b fv ld le l lf lg"><strong class="ky hv">case class </strong>EvenNumber(n: Int)</span><span id="4115" class="lc is hu ky b fv lu le l lf lg"><strong class="ky hv">val </strong>subscriber = publisher<br/>  .filter(_ % 2 == 0)<br/>  .map(EvenNumber)<br/>  .subscribe(message =&gt; <em class="kn">println</em>(message))</span></pre><p id="1ece" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">到目前为止，我们可能已经意识到流的操作与我们在任何集合中发现的操作相似。这是一个强大的功能，因为我们不必学习新的API，我们可以使用我们已经知道的东西。</p><h1 id="aeae" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">一个小问题</h1><p id="6bcc" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我们的问题是，要创建一个完整的管道，我们需要将所有部分连接在一起。这意味着当创建一个<em class="kn">订阅者</em>时，我们需要一个已经创建的<em class="kn">发布者</em>，并且我们必须能够访问它。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="2797" class="lc is hu ky b fv ld le l lf lg"><strong class="ky hv">val </strong>subscriber = publisher.subscribe(message =&gt; <em class="kn">println</em>(message))</span></pre><p id="3b29" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated"><em class="kn">订阅者需要知道发布者</em>，<em class="kn">所以我们需要将发布者传递到每个要创建订阅者的地方。</em></p><h1 id="b305" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">共同的终点</h1><p id="2a24" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我们希望创建一种机制来避免上述问题。解决这个问题的思路一点也不复杂。它实际上来自于一个艺术系统的状态，<em class="kn">阿帕奇卡夫卡</em>。</p><p id="27e9" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">Kafka使用基于<em class="kn">主题</em>的方法来划分流。我们可以在主题<code class="eh lv lw lx ky b">A</code>中放置一条消息，这样只有那些收听主题<code class="eh lv lw lx ky b">A</code>的人才能接收和处理这条消息。</p><p id="46c9" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">另一方面，<em class="kn">发布者</em>和<em class="kn">订阅者</em>完全解耦。他们不了解对方。他们使用一个中心位置来发布和订阅消息。</p><h1 id="cda6" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">建筑迷你小屋</h1><p id="15bf" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated"><strong class="jr hv"> <em class="kn"> MiniKaf </em> </strong>是我们为了克服这个问题而开发的一个库。它公开了一个由最少的类型集支持的非常干净的API。</p><p id="1c3f" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">让我们看看一些主要组件。</p><p id="4e6e" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">首先，我们为发布到系统的每个事件/消息提供了一个接口。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="151b" class="lc is hu ky b fv ld le l lf lg"><strong class="ky hv">trait </strong>Event[A] {<br/>  <strong class="ky hv">def </strong>value: A<br/>}</span></pre><p id="a0dd" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">然后，我们有了一种机制，可以在事件被发送到管道之前将类型转换为事件。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="d4cf" class="lc is hu ky b fv ld le l lf lg">@typeclass <strong class="ky hv">trait </strong>ToEvent[A] {<br/>  <strong class="ky hv">def </strong>event(a: A): Event[A]<br/>}</span></pre><p id="946e" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">当然，这是进行转换的默认方式。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="ecb0" class="lc is hu ky b fv ld le l lf lg"><strong class="ky hv">object </strong>ToEvent {<br/><br/>  <strong class="ky hv">implicit def </strong>toEvent[A]: ToEvent[A] = <strong class="ky hv">new </strong>ToEvent[A] {<br/>    <strong class="ky hv">override def </strong>event(a: A) = <em class="kn">E</em>(a)<br/>  }<br/>}</span></pre><p id="0b19" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">或者我们可以通过函数<strong class="jr hv"><em class="kn"/></strong>使用用户特定的方式进行转换。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="3337" class="lc is hu ky b fv ld le l lf lg"><strong class="ky hv">object </strong>ToEvent {<br/><br/>  <strong class="ky hv">def </strong>event[A](a: A)(f: A =&gt; Event[A]): Event[A] = f(a)<br/><br/>  <strong class="ky hv">implicit def </strong>toEvent[A]: ToEvent[A] = <strong class="ky hv">new </strong>ToEvent[A] {<br/>    <strong class="ky hv">override def </strong>event(a: A) = <em class="kn">E</em>(a)<br/>  }<br/>}</span></pre><p id="6af4" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">我们现在准备开始发送消息。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="bd9e" class="lc is hu ky b fv ld le l lf lg">val publisher = Publisher()<br/>publisher.publish(5)<br/>publisher.publish("hello")</span></pre><h2 id="93e8" class="lc is hu bd it lh li lj ix lk ll lm jb ka ln lo jf ke lp lq jj ki lr ls jn lt dt translated">但是等等！我们如何消费这些信息？</h2><p id="d0bd" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">使用消息就像订阅您想要使用的消息类型一样简单。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="97b5" class="lc is hu ky b fv ld le l lf lg">val subscriber = Subscriber()<br/>subscriber.subscribe[Int](e =&gt; println((e.topic, e.value)))</span></pre><p id="d506" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">在这里，我们订阅了类型为<code class="eh lv lw lx ky b">Int</code>的消息。下次通过流发送一个<code class="eh lv lw lx ky b">Int</code>时，函数<code class="eh lv lw lx ky b">e =&gt; println((e.topic, e.value))</code>将被执行。注意，<code class="eh lv lw lx ky b">e</code>不是一个<code class="eh lv lw lx ky b">Int</code>，而是一个<code class="eh lv lw lx ky b">EventRecord</code>，其中<code class="eh lv lw lx ky b">topic</code>是<code class="eh lv lw lx ky b">"Int"</code>，<code class="eh lv lw lx ky b">value</code>是由<strong class="jr hv"> <em class="kn">发布者推送的实际消息。</em> </strong></p><p id="ca5f" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">这里需要注意的最重要的部分是，我们没有将<strong class="jr hv"> <em class="kn">订阅者</em> </strong>连接到<strong class="jr hv"> <em class="kn">发布者</em> </strong>。我们只是创建了<strong class="jr hv"> <em class="kn">订户</em> </strong>并指定了订阅。这与Kafka的解耦水平相同，但我们依赖于底层实现的反应流。</p><h1 id="29ae" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">结论</h1><p id="f7d1" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated"><strong class="jr hv">然而，我们认为它们不应该被直接使用，而是应该通过我们自己的API来使用。</strong></p><h1 id="ed5f" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">招聘广告</h1><p id="bda1" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated"><a class="ae ly" href="https://github.com/anicolaspp/minikaf" rel="noopener ugc nofollow" target="_blank"><strong class="jr hv"><em class="kn">MiniKaf</em></strong></a>如今正处于它的最开始阶段。我们正在运行时做一些不安全的工作，这些工作可能会被编译时机制取代(可能使用<code class="eh lv lw lx ky b">Shapeless</code>)。此外，API并不完整，并且缺少一些部分。任何帮助都将不胜感激。</p><blockquote class="lz ma mb"><p id="6aa1" class="jp jq kn jr b js ko ju jv jw kp jy jz mc kq kc kd md kr kg kh me ks kk kl km hn dt translated"><a class="ae ly" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ly" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ly" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae ly" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="jp jq kn jr b js ko ju jv jw kp jy jz mc kq kc kd md kr kg kh me ks kk kl km hn dt translated">要了解更多信息，请<a class="ae ly" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae ly" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae ly" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="jp jq kn jr b js ko ju jv jw kp jy jz mc kq kc kd md kr kg kh me ks kk kl km hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ly" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ly" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>