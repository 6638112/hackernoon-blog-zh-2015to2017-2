<html>
<head>
<title>Designing Real-time Promise Component with React + .NET Core</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React +设计实时承诺组件。网络核心</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/designing-real-time-promise-component-with-react-net-core-9d2ef4162702?source=collection_archive---------10-----------------------#2017-06-03">https://medium.com/hackernoon/designing-real-time-promise-component-with-react-net-core-9d2ef4162702?source=collection_archive---------10-----------------------#2017-06-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="4e5c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">考虑下面的场景，其中web应用程序中的UI组件依赖于后端的某个资源，但是组成该资源的数据必须从几个不同的来源聚合，可能是通过异步调用从一些微服务聚合。</p><p id="9a05" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个场景中，假设我们希望UI显示一个初始的加载屏幕，然后这个屏幕会变成一个实时的进度状态来报告后端发生了什么。如果一切顺利，当接收到聚合数据时，它最终会呈现所需的组件。</p><p id="a960" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的信号/基于NET Core的库，<a class="ae jp" href="http://dotnetify.net" rel="noopener ugc nofollow" target="_blank"> dotNetify </a>，为我提供了与这个场景所需的<a class="ae jp" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank"> React </a>组件建立异步实时通信的方法；然而，代替传统的命令式风格，我想让它具有声明性和可重用性；类似于Promise对象的东西——但是是一个组件——实际上是为尚未收到的值安排另一个组件的显示。</p><h2 id="c8b7" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">基本承诺</h2><p id="667d" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">这是组件的初始设计:</p><pre class="kq kr ks kt fq ku kv kw kx aw ky dt"><span id="796d" class="jq jr hu kv b fv kz la l lb lc">&lt;Promise <strong class="kv hv">viewModel</strong>="MyComponentVM"&gt;<br/>   {resp =&gt; &lt;MyComponent {...resp} /&gt;<br/>&lt;/Promise&gt;</span></pre><p id="4f34" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过使用这种声明式风格，可以简洁地表达意图:当Promise组件被呈现时，它将向后端发起一个请求，以获取呈现<code class="eh ld le lf kv b">MyComponent</code>所需的数据，并在收到响应时呈现它。</p><p id="a701" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用dotNetify，通过与后端的富视图模型建立实时连接来完成组件的水合。我们可以让视图模型有状态，这样它就可以跟踪构建响应负载所需的多个异步调用，并在完成时将其发送到我们的前端。</p><h2 id="58a0" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">承诺与进步</h2><p id="0ae8" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">为了允许进度报告，我们将使组件接受更多的属性:</p><pre class="kq kr ks kt fq ku kv kw kx aw ky dt"><span id="8cfb" class="jq jr hu kv b fv kz la l lb lc">&lt;Promise <strong class="kv hv">viewModel</strong>="MyComponentVM"<br/>         <strong class="kv hv">isResolved</strong>={resp =&gt; resp.Result}<br/>         <strong class="kv hv">while</strong>={resp =&gt; &lt;ProgressComponent steps={resp.Steps} /&gt;}<br/>   {resp =&gt; &lt;MyComponent {...resp} /&gt;<br/>&lt;/Promise&gt;</span></pre><p id="044e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ld le lf kv b">isResolved</code>属性接收一个用于决定何时渲染<code class="eh ld le lf kv b">MyComponent</code>(当响应包含<code class="eh ld le lf kv b">Result</code>)的函数，<code class="eh ld le lf kv b">while</code>属性接收一个渲染<code class="eh ld le lf kv b">ProgressComponent</code>的函数。事实上，我可以像这样将一个组件传递给另一个组件，这是一个非常酷的特性。有了React，您的组件就是一等公民。</p><p id="9e73" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">总结一下:在呈现时，Promise组件将与<code class="eh ld le lf kv b">MyComponentVM</code>视图模型建立实时连接，该视图模型将在一段时间内发送多个响应有效载荷，包括完成的进度步骤和最终的结果。该组件将呈现传入的<code class="eh ld le lf kv b">ProgressComponent</code>,以显示到目前为止已完成的步骤，同时等待最后的有效负载。当它收到时，它切换到渲染<code class="eh ld le lf kv b">MyComponent</code>并实现它的承诺。</p><h2 id="adc0" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">视图模型</h2><p id="9047" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">后端视图模型用C#编写，运行在多平台ASP.NET Core上。它从dotNetify的基类<code class="eh ld le lf kv b">BaseVM</code>继承而来，这个基类为它提供了指定哪个属性已经更改的API，以及将更改的属性推送到前端的API。例如，下面的代码片段将把<code class="eh ld le lf kv b">Result</code>属性的值推送到前端组件:</p><pre class="kq kr ks kt fq ku kv kw kx aw ky dt"><span id="d53b" class="jq jr hu kv b fv kz la l lb lc"><strong class="kv hv">Changed</strong>(nameof(Result));<br/><strong class="kv hv">PushUpdates</strong>();</span></pre><p id="e78a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将使用<a class="ae jp" href="http://reactivex.io/" rel="noopener ugc nofollow" target="_blank">react vex</a>技术将多个异步数据请求组合成视图模型可以订阅的单个数据流。提供的API允许我们一个接一个地接收完整的请求(<code class="eh ld le lf kv b">OnNext</code>)，并在收到所有响应时得到通知(<code class="eh ld le lf kv b">OnCompleted</code>)。</p><figure class="kq kr ks kt fq lg"><div class="bz el l di"><div class="lh li l"/></div></figure><h2 id="e015" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">承诺实现</h2><p id="efc4" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">下面是Promise组件的基本实现:</p><figure class="kq kr ks kt fq lg"><div class="bz el l di"><div class="lh li l"/></div></figure><p id="e955" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当出现网络错误或后端请求本身出现问题时，您可以通过添加显示错误消息组件的机制来轻松地使这一点更加健壮。</p><p id="ef74" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<code class="eh ld le lf kv b">Promise</code>文件夹下的<a class="ae jp" href="https://github.com/dsuryd/dotnetify-react-demo" rel="noopener ugc nofollow" target="_blank">https://github.com/dsuryd/dotnetify-react-demo</a>查看一个工作演示。</p><figure class="kq kr ks kt fq lg fe ff paragraph-image"><div class="fe ff lj"><img src="../Images/1a1bfbe8e9968921ca8e7ef6c7d787ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*bjoD93lmsrfDzmqsXLNw2A.gif"/></div></figure><p id="2df1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尽管这个Promise组件是不可链接的，但是链接的需要(通常涉及数据聚合或转换)通过在后端视图模型中完成该逻辑而被有效地否定了。</p><h2 id="65b9" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">摘要</h2><p id="63af" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">为您的web应用程序从多个异步来源获取数据始终是一个挑战，并且会增加您的前端代码，而这些代码实际上并不是特定于UI的。这里显示的<a class="ae jp" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>技术带来了显著的优势:</p><ul class=""><li id="d242" class="lm ln hu it b iu iv iy iz jc lo jg lp jk lq jo lr ls lt lu dt translated">包含承诺的声明性方式使您的代码简洁、可重用、易读。</li><li id="a3cc" class="lm ln hu it b iu lv iy lw jc lx jg ly jk lz jo lr ls lt lu dt translated">将数据聚合/转换推到后端会使您的前端更干净、更精简，并鼓励关注点的分离。</li><li id="40c1" class="lm ln hu it b iu lv iy lw jc lx jg ly jk lz jo lr ls lt lu dt translated">内置的异步实时通信允许更健壮的用户交互，如真实的进度报告，并为更具创造性的方法开辟了道路。</li></ul><div class="kq kr ks kt fq ab cb"><figure class="ma lg mb mc md me mf paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="ma lg mb mc md me mf paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="ma lg mb mc md me mf paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mg mh mi"><p id="f922" class="ir is mj it b iu iv iw ix iy iz ja jb mk jd je jf ml jh ji jj mm jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is mj it b iu iv iw ix iy iz ja jb mk jd je jf ml jh ji jj mm jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kq kr ks kt fq lg fe ff paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="fe ff mn"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="kq kr ks kt fq lg"><div class="bz el l di"><div class="ms li l"/></div></figure></div></div>    
</body>
</html>