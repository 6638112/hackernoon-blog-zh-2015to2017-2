<html>
<head>
<title>Why setting up an Architecture Pattern is crucial for your App — Learn from the scratch!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么建立架构模式对你的应用程序至关重要——从头开始学习！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/why-an-setting-up-an-architecture-pattern-is-crucial-for-your-app-learn-from-the-scratch-f7752c1d468b?source=collection_archive---------8-----------------------#2017-07-02">https://medium.com/hackernoon/why-an-setting-up-an-architecture-pattern-is-crucial-for-your-app-learn-from-the-scratch-f7752c1d468b?source=collection_archive---------8-----------------------#2017-07-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="5956" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，我将给出我的2美分，关于它的需求和我们试图用<strong class="it hv">架构</strong>解决什么问题。因为一旦清楚了这一点，编码部分就非常简单和容易了。</p><p id="4c5b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(我将主要谈论MVP(Model | View | Presenter)——一种常见但令人惊奇的模式。)</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff jp"><img src="../Images/2857c0a3e9f47b6c4529c9318c769c12.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*sY96nGh2TrodB_HuhUwGaA.jpeg"/></div></figure><p id="63a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="jx">我知道，我迟到了，因为在Android博客的海洋中有很多技术和大量文章，但实际上我没有！</em> </strong></p><blockquote class="jy jz ka"><p id="23ed" class="ir is jx it b iu iv iw ix iy iz ja jb kb jd je jf kc jh ji jj kd jl jm jn jo hn dt translated">为什么？世界上的杰克·沃顿正在使用/构建/谈论/玩弄MVP、MVVM、<a class="ae ke" href="https://hackernoon.com/tagged/android" rel="noopener ugc nofollow" target="_blank"> Android </a> <a class="ae ke" href="https://hackernoon.com/tagged/architecture" rel="noopener ugc nofollow" target="_blank">架构</a>组件、ROOM、Kotlin和一个比萨饼的所有配料，但仍然有观众(就像我不久前一样的一个真正的大观众)仍然不知道一个好的架构在构建应用程序方面的好处。</p></blockquote><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff kf"><img src="../Images/8886349fb4dd748fe65a468a8edc05a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*jlN5zmoSwMKu-SQnBST9mw.jpeg"/></div></figure><h2 id="2835" class="kg kh hu bd ki kj kk kl km kn ko kp kq jc kr ks kt jg ku kv kw jk kx ky kz la dt translated">为什么我们需要一个架构？</h2><p id="3766" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">一般来说，所有的架构都是为了解决我们在不使用任何架构设计和编写<strong class="it hv"> <em class="jx">上帝</em>活动</strong>(活动/片段中的所有代码)时遇到的一些<strong class="it hv">常见问题</strong>。</p><blockquote class="lg"><p id="475c" class="lh li hu bd lj lk ll lm ln lo lp jo ek translated">我们都认识一个朋友的朋友，他有一个应用程序，其中有一千行活动，这是不可维护的，所有的业务逻辑都在活动中，因为他从<a class="ae ke" href="http://www.stackoverflow.com" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a>中复制-粘贴-编码。</p></blockquote><p id="fda2" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated"><strong class="it hv">没有架构的问题</strong>—</p><ul class=""><li id="4671" class="lv lw hu it b iu iv iy iz jc lx jg ly jk lz jo ma mb mc md dt translated">Android活动与用户界面和数据访问机制密切相关。</li><li id="b635" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo ma mb mc md dt translated">一个小的变化，不得不重做我们的整个视图(活动/片段)。</li><li id="bb65" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo ma mb mc md dt translated">视图——活动、片段……不容易测试，因为它们庞大的规模和框架的复杂性</li><li id="7c84" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo ma mb mc md dt translated">程序员卷入了视图复杂性的斗争，而不是解决业务任务。</li><li id="dab4" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo ma mb mc md dt translated">代码不能被重用、测试、调试和重构。</li></ul><p id="352b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">一个好的建筑如何让生活变得更简单？</strong></p><ul class=""><li id="573d" class="lv lw hu it b iu iv iy iz jc lx jg ly jk lz jo ma mb mc md dt translated">复杂的任务被拆分成更简单的任务，更容易解决。</li><li id="f18e" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo ma mb mc md dt translated">更小的对象，更少的错误，更容易调试。</li><li id="6f6e" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo ma mb mc md dt translated">观赏类保持整洁和优雅。</li><li id="9581" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo ma mb mc md dt translated">可测试代码——编写测试轻而易举(Aaha)。</li><li id="fcd2" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo ma mb mc md dt translated">耦合仍然是功能性与复杂性的最佳结合点。</li><li id="d545" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo ma mb mc md dt translated">如果需求发生了变化，通常很容易准确地指出您需要在代码中进行什么样的更改，而且影响最小。</li></ul><h2 id="a4f7" class="kg kh hu bd ki kj kk kl km kn ko kp kq jc kr ks kt jg ku kv kw jk kx ky kz la dt translated">为什么是MVP？</h2><p id="393c" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">嗯，这是非常有争议的。MVP和MVVM是当今最受欢迎的两个选择。而开发商的优先权也是支离破碎的。<br/>就我个人而言，我使用MVP是因为它相当简单，而且仍然服务于这个目的。MVVM很棒，我个人并不是他的超级粉丝，因为尽管它让Java文件变得小巧而强大，但是它也让XMLs变得非常复杂。<br/>(只是个人意见，不要杀我耶！)</p><h2 id="b0ba" class="kg kh hu bd ki kj kk kl km kn ko kp kq jc kr ks kt jg ku kv kw jk kx ky kz la dt translated">什么是最有价值球员？</h2><p id="d7ad" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated"><em class="jx">宇宙间每个人都知道它是</em> <strong class="it hv"> <em class="jx">模型</em></strong><em class="jx"/><strong class="it hv"><em class="jx">视图</em></strong><em class="jx"/><strong class="it hv"><em class="jx">演示者</em> </strong>(告诉我我是否在说谎)</p><p id="6e93" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它允许将表示层从逻辑中分离出来，所以关于应用程序中T21部分是如何工作的一切都与我们在屏幕上展示它的方式分离开来。</p><p id="65ea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">观点——越愚蠢越好</strong></p><ul class=""><li id="7cdb" class="lv lw hu it b iu iv iy iz jc lx jg ly jk lz jo ma mb mc md dt translated">通常是活动、片段或定制的安卓视图。只负责展示物品。</li><li id="e501" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo ma mb mc md dt translated">该视图通常由活动/片段实现，将包含对P <em class="jx">表示器</em>的引用。</li><li id="26f1" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo ma mb mc md dt translated">将用户交互引导至<em class="jx">演示者</em>。视图唯一能做的就是每次有接口动作时从<em class="jx"> Presenter </em>调用一个方法。</li></ul><p id="a7b0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">模型—数据访问层</strong></p><ul class=""><li id="b645" class="lv lw hu it b iu iv iy iz jc lx jg ly jk lz jo ma mb mc md dt translated">它是您的数据源，从数据库、网络调用或硬编码的对象列表中获取结果并不重要。</li><li id="783a" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo ma mb mc md dt translated">它控制如何创建、存储和修改数据。</li></ul><p id="87c1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">演示者-中间一章</strong></p><ul class=""><li id="f822" class="lv lw hu it b iu iv iy iz jc lx jg ly jk lz jo ma mb mc md dt translated"><em class="jx">视图</em>和<em class="jx">模型</em>之间的中间层。它从<em class="jx">模型</em>中检索数据，并将其格式化返回到<em class="jx">视图</em>。</li><li id="f54d" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo ma mb mc md dt translated">它还决定了当您与<em class="jx">视图</em>交互时会发生什么。</li></ul><h2 id="c131" class="kg kh hu bd ki kj kk kl km kn ko kp kq jc kr ks kt jg ku kv kw jk kx ky kz la dt translated">在MVP之后，测试应用程序是如何变得一帆风顺的呢？</h2><p id="fb48" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">MVP允许您轻松地为模型和演示者编写独立的测试。由于模型没有对视图或演示者的任何引用，因此可以对其进行单独测试，从而允许开发人员从任何其他组件(如数据库)中抽象出模型。</p><p id="759e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">演示者可以通过模仿<em class="jx">视图</em>和<em class="jx">模型</em>进行单元测试，这使得开发人员能够模拟不同的结果来测试演示者的不同行为。</p><h2 id="9d26" class="kg kh hu bd ki kj kk kl km kn ko kp kq jc kr ks kt jg ku kv kw jk kx ky kz la dt translated">结论</h2><p id="fd2e" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">在安卓系统中，将界面与逻辑分开并不容易，但是模型-视图-演示者模式可以更容易地防止我们的活动退化成数百甚至数千行的耦合类。在大型应用程序中，很好地组织我们的代码是非常重要的。否则，就无法维护和扩展。<br/>有了MVP，我们就可以实现以上所有的目标。</p><h2 id="c593" class="kg kh hu bd ki kj kk kl km kn ko kp kq jc kr ks kt jg ku kv kw jk kx ky kz la dt translated"><strong class="ak">接下来呢？</strong></h2><p id="8416" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">在本系列的下一篇文章中，我们将在Android中实现模型视图呈现模式。我们将遵循一条更保守的道路，只使用规范代码，不使用Android SDK之外的任何库。这种方法将有助于理解MVP各层之间的不同关系。</p><p id="a34d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">— — — — — —如果你喜欢这篇文章<strong class="it hv">点击</strong>那个💚— — — — — — — —如果你知道有人可能从中获取价值，请<strong class="it hv">分享</strong> — — —</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mj mk l"/></div></figure></div></div>    
</body>
</html>