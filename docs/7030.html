<html>
<head>
<title>Coordinators, Routers, and Back Buttons</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">协调器、路由器和后退按钮</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/coordinators-routers-and-back-buttons-c58b021b32a?source=collection_archive---------4-----------------------#2017-10-14">https://medium.com/hackernoon/coordinators-routers-and-back-buttons-c58b021b32a?source=collection_archive---------4-----------------------#2017-10-14</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="394e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你偶然发现了这篇文章，你可能会遇到和我在和流量协调员一起工作时遇到的同样的问题。如果你是协调员的新手，我建议你阅读Soroush Khanlou的博客。这项工作是我理解协调器的基础，但在尝试实现我自己的协调器时，我在处理后退按钮时遇到了一个巨大的缺陷。</p><p id="8a1b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">水平流与垂直流</strong></p><p id="a9b7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">子协调员可以代表垂直或水平流程。</p><p id="3255" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您提供的子协调器是一个<strong class="it hv">垂直流</strong>，当它完成时，您解除它并释放协调器。垂直流的一个例子是身份验证流，它以模式方式呈现，仅在身份验证被取消或用户通过登录或注册进行身份验证时才完成。</p><p id="b778" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您推入的子协调器是一个<strong class="it hv">水平流</strong>，当它完成时(从一个动作或后退按钮),它从导航控制器堆栈中弹出并被释放。为此，父协调器和子协调器需要共享同一个导航控制器。这个案例是在我进入个人资料页面时出现的。在这个profile页面上有许多其他的子流，所以我不能简单地实例化一个新的profile view控制器，并在我希望的时候推送到它。我需要一个可重用的协调器，我可以推动它。</p><p id="9edb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">实现这一点需要传递一个对UINavigationController的引用和大量处理导航控制器委托的混乱代码，以确定back按钮何时被按下，以便您可以释放子协调器。我开始寻找一种更好的方式，我遇到了Andrey Panov的协调器实现(T9 ),它包含了架构的一个新组件:路由器(T10)。您也应该阅读一下，因为为了简洁起见，我不会涵盖所有内容。</p><p id="3947" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">路由器是一个非常简单的概念。它是一个封装了UINavigationController的类，您可以在协调器之间传递它。它处理物理导航，而协调器处理流逻辑。每个水平流有一个路由器，并且可以通过依赖注入由水平流的子协调器共享。每当你有一个新的垂直流(通常是模态地呈现一个流)时，这将需要实例化一个新的路由器。</p><p id="6867" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当使用Khanlou或Andrey Panov的水平流方法时，后退按钮是最大的痛苦。Khanlou甚至有一整篇关于后退按钮和协调按钮一起使用的后续文章。我认为这些建议的解决方案是可以接受的，但仍不理想。</p><p id="9623" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第一个建议是创建一个导航控制器类，它是UIViewController的子类，目的是封装Navigation Controller，符合UINavigationControllerDelegate，并维护从视图控制器到协调器的映射，以便在弹出视图控制器时可以释放协调器。这看起来像是子类化UITabBarController，以避免将我们的应用程序的设置逻辑放在AppDelegate中。有用吗？是的，但是感觉不对。他继续说“我主要关心的是NavigationController类，它是一个视图控制器，知道并必须处理协调器”。第二种方法是将协调器扩展为导航控制器委托，然后在该委托方法触发时处理解除分配。这样做的最大缺点是，没有办法将导航控制器委托的责任移交给后续的子协调器。如果您推送到一个子流，然后推送到另一个流，第一个流将接收两个流的pop事件。我不确定这种方法是否适用于一层以上的深度。</p><p id="828e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我认为将这两种方法结合起来会更好。如果我们扩展我们的路由器类以符合UINavigationControllerDelegate，那么路由器可以处理它所包装的导航控制器的所有事件，并将在后退按钮事件上做什么的责任委托给最初推动该协调器的协调器，会怎么样？</p><p id="7987" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我看来，理想的解决方案应该是…</p><p id="8936" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">1.允许我们像对待垂直流中的取消按钮一样对待水平流中的后退按钮</p><p id="b831" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2.避免用流逻辑(协调器)污染导航(路由器)</p><p id="52b1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">3.将按下后退按钮时要做的事情(子协调器的解除分配)委托给父协调器</p><p id="e260" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">4.为展示和推送协调器和视图控制器提供一个公共界面</p><p id="06af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">5.允许我们轻松地推进到后续的水平流程</p><p id="0e5c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我看来应该是这样的:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="7daa" class="jz ka hu jv b fv kb kc l kd ke">let coordinator = ProfileCoordinator(router: router, store: store, profile: profile)</span><span id="dea5" class="jz ka hu jv b fv kf kc l kd ke">addChild(coordinator)</span><span id="f4cb" class="jz ka hu jv b fv kf kc l kd ke">router.push(coordinator) { [weak self, weak coordinator] in<br/>    // This executes when the back button is pressed<br/>    self?.removeChild(coordinator)<br/>}<br/>coordinator.start()</span></pre><p id="f023" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于协调者和视图控制器，我们应该能够与路由器进行相同的交互:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="1a29" class="jz ka hu jv b fv kb kc l kd ke">let viewController = UIViewController()<br/>router.push(viewController) {<br/>    // This executes when the back button is pressed<br/>}</span></pre><p id="aecd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，我们的push函数需要采用一个通用类型，我们的路由器需要跟踪回调，以便在back按钮被按下时执行它们。</p><p id="d99c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们常见的类型是可展示的协议:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="b9ac" class="jz ka hu jv b fv kb kc l kd ke">public protocol Presentable {<br/>    func toPresentable() -&gt; UIViewController<br/>}</span><span id="f2ab" class="jz ka hu jv b fv kf kc l kd ke">// UIViewController is already a presentable type<br/>extension UIViewController: Presentable {<br/>    public func toPresentable() -&gt; UIViewController {<br/>        return self<br/>    }<br/>}</span></pre><p id="ee7c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们的路由器接口和实现(这是Andrey Panov实现的修改版本，提供后退按钮支持):</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="971a" class="jz ka hu jv b fv kb kc l kd ke">import UIKit</span><span id="c8fe" class="jz ka hu jv b fv kf kc l kd ke">public protocol RouterType: class, Presentable {<br/>    var navigationController: UINavigationController { get }<br/>    var rootViewController: UIViewController { get }<br/>    func present(_ module: Presentable, animated: Bool)<br/>    func push(_ module: Presentable, animated: Bool, completion: (() -&gt; Void)?)<br/>    func popModule(animated: Bool)<br/>    func dismissModule(animated: Bool, completion: (() -&gt; Void)?)<br/>    func setRootModule(_ module: Presentable, hideBar: Bool)<br/>    func popToRootModule(animated: Bool)<br/>}</span><span id="9345" class="jz ka hu jv b fv kf kc l kd ke">final public class Router: NSObject, RouterType, UINavigationControllerDelegate {</span><span id="02d0" class="jz ka hu jv b fv kf kc l kd ke">    private var completions: [UIViewController : () -&gt; Void]<br/>    public var rootViewController: UIViewController...<br/>    public unowned let navigationController: UINavigationController</span><span id="7fd4" class="jz ka hu jv b fv kf kc l kd ke">    public init(navigationController: UINavigationController) {<br/>        self.navigationController = navigationController<br/>        self.completions = [:]<br/>        super.init()<br/>        self.navigationController.delegate = self<br/>    }</span><span id="4914" class="jz ka hu jv b fv kf kc l kd ke">    public func toPresentable() -&gt; UIViewController {<br/>        return navigationController<br/>    }</span><span id="7de3" class="jz ka hu jv b fv kf kc l kd ke">    public func present(_ module: Presentable, animated: Bool) {<br/>        guard let controller = module.toPresentable() else { <br/>            return<br/>        }</span><span id="4225" class="jz ka hu jv b fv kf kc l kd ke">        navigationController.present(controller, animated: animated, completion: nil)<br/>    }</span><span id="296a" class="jz ka hu jv b fv kf kc l kd ke">    public func dismissModule(animated: Bool, completion: (() -&gt; Void)?) {<br/>        navigationController.dismiss(animated: animated, completion: completion)<br/>}</span><span id="7643" class="jz ka hu jv b fv kf kc l kd ke">    public func push(_ module: Presentable, animated: Bool = true, completion: (() -&gt; Void)? = nil) {</span><span id="020c" class="jz ka hu jv b fv kf kc l kd ke">        // Avoid pushing UINavigationController onto stack<br/>        guard let controller = module.toPresentable(), <br/>            controller is UINavigationController == false else {<br/>            return<br/>        }</span><span id="a8ef" class="jz ka hu jv b fv kf kc l kd ke">        if let completion = completion {<br/>            completions[controller] = completion<br/>        }</span><span id="0fdb" class="jz ka hu jv b fv kf kc l kd ke">        navigationController.pushViewController(controller, animated: animated)<br/>    }</span><span id="26a5" class="jz ka hu jv b fv kf kc l kd ke">    public func popModule(animated: Bool = true)  {<br/>        <br/>        if let controller = navigationController.popViewController(animated: animated) {<br/>            runCompletion(for: controller)<br/>        }<br/>    }</span><span id="d450" class="jz ka hu jv b fv kf kc l kd ke">    public func setRootModule(_ module: Presentable, hideBar: Bool){<br/>        guard let controller = module.toPresentable() else { <br/>            return<br/>        }</span><span id="5bad" class="jz ka hu jv b fv kf kc l kd ke">        navigationController.setViewControllers([controller], animated: false)<br/>        navigationController.isNavigationBarHidden = hideBar<br/>    }</span><span id="9f4e" class="jz ka hu jv b fv kf kc l kd ke">    public func popToRootModule(animated: Bool) {<br/>        if let controllers = navigationController.popToRootViewController(animated: animated) {<br/>            controllers.forEach { runCompletion(for: $0) }<br/>        }<br/>    }</span><span id="215b" class="jz ka hu jv b fv kf kc l kd ke">    fileprivate func runCompletion(for controller: UIViewController) {<br/>        guard let completion = completions[controller] else {<br/>            return<br/>        }</span><span id="7757" class="jz ka hu jv b fv kf kc l kd ke">        completion()<br/>        completions.removeValue(forKey: controller)<br/>    }</span><span id="337e" class="jz ka hu jv b fv kf kc l kd ke">    // MARK: UINavigationControllerDelegate<br/>    public func navigationController(_ navigationController: UINavigationController, didShow viewController: UIViewController, animated: Bool) {<br/>        <br/>        // Ensure the view controller is popping<br/>        guard let poppedViewController = navigationController.transitionCoordinator?.viewController(forKey: .from), !navigationController.viewControllers.contains(poppedViewController) else {<br/>             return<br/>        }</span><span id="39d3" class="jz ka hu jv b fv kf kc l kd ke">        runCompletion(for: poppedViewController)<br/>    }<br/>}</span></pre><p id="4efa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的路由器应该能够执行所有可能的导航操作。它还必须充当导航控制器的委托，这样它就可以拦截back按钮的按下，并为弹出的视图控制器运行相应的完成处理程序。当一个可呈现的类型被推送时，我们使用<em class="kg">module . top Presentable()</em>访问要被推送的视图控制器，并将完成处理程序存储在一个字典中，关键字是视图控制器。当从后退按钮弹出一个视图控制器时，导航控制器委托函数确定哪个视图控制器被弹出，并执行相应的完成处理程序。</p><p id="13b8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们的协调器接口和实现:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="ab4d" class="jz ka hu jv b fv kb kc l kd ke">public protocol Coordinatable: class, Presentable {<br/>    var router: RouterType { get }<br/>    var onCompletion: (() -&gt; Void)? { get set }<br/>    func start()<br/>}</span><span id="a445" class="jz ka hu jv b fv kf kc l kd ke">open class Coordinator: NSObject, Coordinatable {<br/>    <br/>    public var childCoordinators: [Coordinator] = []<br/>    public var router: Router</span><span id="c65a" class="jz ka hu jv b fv kf kc l kd ke">    public init(router: Router) {<br/>        self.router = router<br/>        super.init()<br/>    }</span><span id="33ad" class="jz ka hu jv b fv kf kc l kd ke">    open var onCompletion: (() -&gt; Void)?</span><span id="7644" class="jz ka hu jv b fv kf kc l kd ke">    open func start() {}</span><span id="1e0a" class="jz ka hu jv b fv kf kc l kd ke">    public func addChild(_ coordinator: Coordinator) {<br/>        childCoordinators.append(coordinator)<br/>    }</span><span id="8993" class="jz ka hu jv b fv kf kc l kd ke">    public func removeChild(_ coordinator: Coordinator) {<br/>        if let coordinator = coordinator, <br/>            let index = childCoordinators.index(of: coordinator) {<br/>            childCoordinators.remove(at: index)<br/>        }<br/>    }</span><span id="791e" class="jz ka hu jv b fv kf kc l kd ke">    // Make this function open so we can override it in a different module<br/>    open func toPresentable() -&gt; UIViewController {<br/>        return router.toPresentable()<br/>    }<br/>}</span></pre><p id="d21c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的协调者必须实现Presentable，这样路由器才能呈现它。这个默认实现将返回路由器的可显示的表单，该表单将返回路由器的底层导航控制器。这在为新的垂直流程提供协调者时非常有用，但是我们不能推动这样的协调者。因此，为了推动水平流的子协调器，我们必须覆盖<em class="kg"> toPresentable() </em>来给我们一个视图控制器实例，它将在我们调用<em class="kg"> router.push(coordinator) </em>时工作。注意:在我们的路由器中，我们要确保我们推送的视图控制器不是UINavigationController。</p><p id="1f8c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，我们希望用于水平流的协调器的子类可能如下所示:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="ac83" class="jz ka hu jv b fv kb kc l kd ke">import Foundation</span><span id="6847" class="jz ka hu jv b fv kf kc l kd ke">open class ProfileCoordinator: Coordinator {</span><span id="b310" class="jz ka hu jv b fv kf kc l kd ke">    fileprivate let store: StoreType<br/>    fileprivate let profile: Profile</span><span id="478d" class="jz ka hu jv b fv kf kc l kd ke">    lazy var viewController: ProfileViewController = {<br/>        let viewModel = LocationProfileViewModel(profile: profile)<br/>        return ProfileViewController(viewModel: viewModel)<br/>    }()</span><span id="c3f3" class="jz ka hu jv b fv kf kc l kd ke">    public init(router: RouterType, store: StoreType, profile: Profile) {<br/>        self.store = store<br/>        self.profile = profile<br/>        super.init(router: router)<br/>    }</span><span id="29f9" class="jz ka hu jv b fv kf kc l kd ke">    open override func start() {}</span><span id="4224" class="jz ka hu jv b fv kf kc l kd ke">    open override func toPresentable() -&gt; UIViewController {<br/>        return viewController<br/>    }<br/>}</span></pre><p id="1cfd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">瞧啊。我们可以从父协调器中推出这个子协调器，并轻松地解除分配:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="cff1" class="jz ka hu jv b fv kb kc l kd ke">let coordinator = ProfileCoordinator(router: router, store: store, profile: profile)</span><span id="3db1" class="jz ka hu jv b fv kf kc l kd ke">addChild(coordinator)</span><span id="6e66" class="jz ka hu jv b fv kf kc l kd ke">router.push(coordinator) { [weak self, weak coordinator] in<br/>    // This executes when the back button is pressed<br/>    self?.removeChild(coordinator)<br/>}<br/>coordinator.start()</span></pre><p id="7497" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">希望这有所帮助。如果您对协调员的回调使用闭包而不是委托，那么这个解决方案将会工作得最好。欢迎任何反馈、问题或批评。</p><p id="fc8b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">查看<a class="ae jp" href="https://github.com/imaccallum/CoordinatorKit" rel="noopener ugc nofollow" target="_blank">坐标工具包</a>进行演示。</p></div></div>    
</body>
</html>