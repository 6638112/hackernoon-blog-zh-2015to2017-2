<html>
<head>
<title>[ Javascript ] Killer of Sequential Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[ Javascript ]连续承诺的黑仔</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/nodejs-javascript-killer-of-resolving-sequential-promises-pacu-a0a6b9a45045?source=collection_archive---------4-----------------------#2016-12-03">https://medium.com/hackernoon/nodejs-javascript-killer-of-resolving-sequential-promises-pacu-a0a6b9a45045?source=collection_archive---------4-----------------------#2016-12-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/cede73f2eb017dd57638310cc6d93c07.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*HPUgQE2GlNqgygpwuM1WSg.png"/></div></figure><blockquote class="iy"><p id="fa54" class="iz ja hu bd jb jc jd je jf jg jh ji ek translated">javascript的痛苦是与异步函数斗争，特别是大老板“回调地狱”，当你把数以千计的console.log代码变脏，以杀死一个回调错误。它持续了很长时间，直到我发现Promises，它遵循简单的逻辑，有组织的resolve-reject结构，它解决了大多数异步问题，所以感谢Promises。</p></blockquote><p id="794d" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf ji hn dt translated">然而，一个用参数链接N个未知数量承诺并顺序解析它们的用例，无论是通过本地ES6承诺还是通过第三方库(q、bluebird、deferred.js等)似乎都不可能完成。</p></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><h1 id="12e6" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated"><strong class="ak"> <em class="ll">失败例子:</em> </strong></h1><blockquote class="lm ln lo"><p id="6ece" class="jj jk lp jl b jm lq jo jp jq lr js jt ls lt jw jx lu lv ka kb lw lx ke kf ji hn dt translated">定义本文中会多次用到的<strong class="jl hv"> <em class="hu"> genPromist </em> </strong>函数:</p></blockquote><pre class="ly lz ma mb fq mc md me mf aw mg dt"><span id="2c71" class="mh ko hu md b fv mi mj l mk ml">var genPromist = function(para) {<br/>    return new Promise(function(resolve, reject) {<br/>        setTimeout(function() {<br/>            console.log('para: ', para)<br/>            resolve(para * para)<br/>        }, 1000)<br/>    })<br/>}</span></pre><blockquote class="lm ln lo"><p id="4b8e" class="jj jk lp jl b jm lq jo jp jq lr js jt ls lt jw jx lu lv ka kb lw lx ke kf ji hn dt translated">链4承诺并递归地解决它:</p></blockquote><pre class="ly lz ma mb fq mc md me mf aw mg dt"><span id="a9f7" class="mh ko hu md b fv mi mj l mk ml">var promises = [];<br/>promises.push(genPromist(1));<br/>promises.push(genPromist(2));<br/>promises.push(genPromist(3));</span><span id="dac9" class="mh ko hu md b fv mm mj l mk ml">var recursiveFunction = function(promisesList) {<br/>    return new Promise(function(resolve, reject) {<br/>        if (promisesList.length &lt;= 0) {<br/>            resolve()<br/>        } else {<br/>            return promisesList[0].then(function() {<br/>                promisesList.shift();<br/>                return recursiveFunction(promisesList);<br/>            });<br/>        }<br/>    });<br/>}</span><span id="c763" class="mh ko hu md b fv mm mj l mk ml">recursiveFunction(promises)</span></pre><blockquote class="lm ln lo"><p id="2266" class="jj jk lp jl b jm lq jo jp jq lr js jt ls lt jw jx lu lv ka kb lw lx ke kf ji hn dt translated">可悲的是，程序并没有按预期运行，<strong class="jl hv"> <em class="hu"> promises </em> </strong>数组被并行解析。当promise函数没有参数时，大多数库都工作良好，这意味着javascript中的一个类。</p></blockquote></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><h1 id="11ea" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">解决方案:</h1><p id="4b02" class="pw-post-body-paragraph jj jk hu jl b jm mn jo jp jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf ji hn dt translated">Javascript处理<strong class="jl hv"> <em class="lp">承诺函数</em> </strong>和<strong class="jl hv"> <em class="lp">带参数承诺函数</em> </strong>的方式不同(带参数匿名函数问题)。</p><blockquote class="iy"><p id="9547" class="iz ja hu bd jb jc ms mt mu mv mw ji ek translated">这样处理这个问题就需要将<strong class="ak"> <em class="ll">的许诺函数</em> </strong>推送到一个数组列表中</p></blockquote><blockquote class="lm ln lo"><p id="7680" class="jj jk lp jl b jm jn jo jp jq jr js jt ls jv jw jx lu jz ka kb lw kd ke kf ji hn dt translated">PACU是一个工具，用来解决将promises函数与参数链接起来并连续解析每个函数的问题。</p></blockquote><p id="2e03" class="pw-post-body-paragraph jj jk hu jl b jm lq jo jp jq lr js jt ju lt jw jx jy lv ka kb kc lx ke kf ji hn dt translated">安装:</p><pre class="ly lz ma mb fq mc md me mf aw mg dt"><span id="2eec" class="mh ko hu md b fv mi mj l mk ml">$ npm install --save pacu</span></pre><p id="b13f" class="pw-post-body-paragraph jj jk hu jl b jm lq jo jp jq lr js jt ju lt jw jx jy lv ka kb kc lx ke kf ji hn dt translated">用法:</p><pre class="ly lz ma mb fq mc md me mf aw mg dt"><span id="70c1" class="mh ko hu md b fv mi mj l mk ml">var pacu <strong class="md hv">=</strong> require("pacu")</span><span id="e6bd" class="mh ko hu md b fv mm mj l mk ml">pacu.series(promisesList).then(function(result) {</span><span id="956d" class="mh ko hu md b fv mm mj l mk ml">  console.log("Result series: ", result)</span><span id="56e7" class="mh ko hu md b fv mm mj l mk ml">},function(err){</span><span id="01ae" class="mh ko hu md b fv mm mj l mk ml">  console.log("Error series: ", result)</span><span id="41b6" class="mh ko hu md b fv mm mj l mk ml">});</span></pre><div class="ly lz ma mb fq ab cb"><figure class="mx iv my mz na nb nc paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mx iv my mz na nb nc paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mx iv my mz na nb nc paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="lm ln lo"><p id="f922" class="jj jk lp jl b jm lq jo jp jq lr js jt ls lt jw jx lu lv ka kb lw lx ke kf ji hn dt translated"><a class="ae nd" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是阿美族家庭的一员。我们现在<a class="ae nd" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae nd" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jj jk lp jl b jm lq jo jp jq lr js jt ls lt jw jx lu lv ka kb lw lx ke kf ji hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae nd" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae nd" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ly lz ma mb fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="fe ff ne"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>