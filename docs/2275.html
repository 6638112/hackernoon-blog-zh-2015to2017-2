<html>
<head>
<title>React at 60fps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以60fps的速度反应</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/react-at-60fps-4e36b8189a4c?source=collection_archive---------1-----------------------#2017-01-17">https://medium.com/hackernoon/react-at-60fps-4e36b8189a4c?source=collection_archive---------1-----------------------#2017-01-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="3962" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">React是DOM上的一个抽象，和任何抽象一样，它有它的成本和限制，你迟早会遇到。理解并能够克服这些限制是使用抽象的重要部分。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="ju jv l"/></div></figure><p id="8ad4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有一种观点认为React是开箱即用的，在某种程度上这是正确的——大多数时候用React构建用户界面时，您可能不会考虑性能优化。但是有时候，为了获得更好的性能(和更好的用户体验)，人们必须打破常规。</p><p id="551d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我想分享一些我在使用React时使用的技巧。</p><h2 id="da32" class="jw jx hu bd jy jz ka kb kc kd ke kf kg jc kh ki kj jg kk kl km jk kn ko kp kq dt translated">不要过早优化！</h2><p id="f190" class="pw-post-body-paragraph ir is hu it b iu kr iw ix iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo hn dt translated">在我们开始之前给你一个警告。无论做什么，请不要为了性能过早优化。这意味着，不要做任何事情，直到你有证据表明你有一个性能问题。使用React，优化太多可能会导致奇怪的错误。</p><p id="6a98" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每个性能优化过程应该是这样的:</p><ol class=""><li id="b2e4" class="kw kx hu it b iu iv iy iz jc ky jg kz jk la jo lb lc ld le dt translated">意识到存在性能问题</li><li id="acda" class="kw kx hu it b iu lf iy lg jc lh jg li jk lj jo lb lc ld le dt translated">使用DevTools进行测量和分析，以找到瓶颈</li><li id="535c" class="kw kx hu it b iu lf iy lg jc lh jg li jk lj jo lb lc ld le dt translated">解决这个问题</li><li id="565e" class="kw kx hu it b iu lf iy lg jc lh jg li jk lj jo lb lc ld le dt translated">再次测试以确认改进</li><li id="bc4a" class="kw kx hu it b iu lf iy lg jc lh jg li jk lj jo lb lc ld le dt translated">如果需要，转到2</li></ol><p id="851d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">顺便说一下，<a class="ae lk" href="https://facebook.github.io/react/blog/2016/11/16/react-v15.4.0.html" rel="noopener ugc nofollow" target="_blank"> React 15.4引入了新的性能工具</a>，它与Chrome的DevTools很好地集成在一起，使得在渲染树中定位缓慢的组件变得更加容易。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff ll"><img src="../Images/bb2522fe1dc0b96d968c042cd7d8a081.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*Y_VtsspatwuHYjWQyW6wzw.png"/></div></figure><p id="5be1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们深入了解一些我在各种项目中使用的常见和不常见的与React相关的性能优化技术。</p><h2 id="3ea7" class="jw jx hu bd jy jz ka kb kc kd ke kf kg jc kh ki kj jg kk kl km jk kn ko kp kq dt translated">要不要shouldComponentUpdate？</h2><p id="1099" class="pw-post-body-paragraph ir is hu it b iu kr iw ix iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo hn dt translated">许多人都熟悉React的生命周期方法，称为<a class="ae lk" href="https://facebook.github.io/react/docs/react-component.html#shouldcomponentupdate" rel="noopener ugc nofollow" target="_blank">shouldcomponentwupdate</a>。该方法返回一个布尔值，取决于哪个React将跳过实现该方法的组件的render方法调用。</p><p id="bca2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我几年前开始使用React时，我天真地认为如果状态和道具没有改变，这个库会通过不调用render来自动优化渲染。事实上，默认情况下这个方法不做任何事情，因此React.js总是在你调用<code class="eh lo lp lq lr b">this.setState</code>或者一个组件接收到新的道具时触发重新渲染。</p><p id="b726" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">实现<code class="eh lo lp lq lr b">shouldComponentUpdate</code>方法可能是让一个慢的组件更快的最简单的方法，但是这种方法有一些缺陷。通过在组件树的较高位置退出渲染，您可能会错过树的较低位置所需的重新渲染，因为它将跳过对定义该方法的组件的所有子组件的渲染。最常见的实现如<a class="ae lk" href="https://github.com/gaearon/react-pure-render/blob/master/src/function.js" rel="noopener ugc nofollow" target="_blank">shoulpurecomponentupdate</a>简单地比较下一个和当前的<code class="eh lo lp lq lr b">state</code>和<code class="eh lo lp lq lr b">props</code>也可能很棘手:</p><ol class=""><li id="4e04" class="kw kx hu it b iu iv iy iz jc ky jg kz jk la jo lb lc ld le dt translated">它不会比较深度嵌套的对象(并且比较深度嵌套的对象很慢——这就是为什么您应该考虑使用不可变的数据结构)</li><li id="9bb7" class="kw kx hu it b iu lf iy lg jc lh jg li jk lj jo lb lc ld le dt translated">通过<code class="eh lo lp lq lr b">props</code>传递回调函数的新实例也会使这个函数总是返回<code class="eh lo lp lq lr b">true</code>。提示:使用ESLint和<a class="ae lk" href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-no-bind.md" rel="noopener ugc nofollow" target="_blank"> eslint-plugin-react </a>来捕捉它。</li><li id="9d88" class="kw kx hu it b iu lf iy lg jc lh jg li jk lj jo lb lc ld le dt translated">支票不是免费的。做大量的检查会降低应用程序的速度。</li></ol><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="ju jv l"/></div></figure><p id="5c22" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">实际上，这意味着在大多数情况下，它只应用于:</p><ol class=""><li id="2473" class="kw kx hu it b iu iv iy iz jc ky jg kz jk la jo lb lc ld le dt translated">使用简单道具的纯组件(道具中没有深度对象或数组)</li><li id="bda2" class="kw kx hu it b iu lf iy lg jc lh jg li jk lj jo lb lc ld le dt translated">“叶”-位于渲染树深处的组件。</li></ol><p id="7d5a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是为什么我认为，甚至在你开始在你的类上实现shouldComponentUpdate之前(或者，如果你喜欢功能组件，用<a class="ae lk" href="https://github.com/acdlite/recompose/blob/master/docs/API.md#pure" rel="noopener ugc nofollow" target="_blank"> pure HoC </a>组合)，你应该分析并找出是什么组件使应用程序变慢。</p><h2 id="7f29" class="jw jx hu bd jy jz ka kb kc kd ke kf kg jc kh ki kj jg kk kl km jk kn ko kp kq dt translated">将昂贵的代码转移到更高级别的组件</h2><p id="958e" class="pw-post-body-paragraph ir is hu it b iu kr iw ix iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo hn dt translated">如果您在render方法中有一些开销很大的派生数据计算，您可以通过将这些计算卸载到更高级别的组件或<a class="ae lk" href="https://en.wikipedia.org/wiki/Memoization" rel="noopener ugc nofollow" target="_blank">记忆</a>结果来减少调用数量。使用像<a class="ae lk" href="https://github.com/reactjs/reselect" rel="noopener ugc nofollow" target="_blank"> reselect </a>这样的库会有很大的帮助。</p><p id="623a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我从事<a class="ae lk" href="https://status.postmarkapp.com" rel="noopener ugc nofollow" target="_blank">https://status.postmarkapp.com</a>工作期间，我能够通过以下方式提高服务指标图表的悬停性能:</p><ol class=""><li id="cdf2" class="kw kx hu it b iu iv iy iz jc ky jg kz jk la jo lb lc ld le dt translated">将可视化和覆盖信息分割成单独的组件</li><li id="c325" class="kw kx hu it b iu lf iy lg jc lh jg li jk lj jo lb lc ld le dt translated">将昂贵的数据转换卸载到包装组件</li><li id="c357" class="kw kx hu it b iu lf iy lg jc lh jg li jk lj jo lb lc ld le dt translated">为可视化和覆盖组件实现<code class="eh lo lp lq lr b">shouldComponentUpdate</code>方法</li><li id="1a79" class="kw kx hu it b iu lf iy lg jc lh jg li jk lj jo lb lc ld le dt translated">使用不可变的数据结构，这样比较就不那么昂贵了</li></ol><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff ls"><img src="../Images/6c33909792496f5dfe5f3accd1c1041d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*oT7dBpGwhyQMrxv8S54KEw.gif"/></div></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">ServiceMetric Component hover example</figcaption></figure><p id="08df" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不过，我工作过的应用程序中最慢的部分之一通常是在用户输入之后触发DOM操作。对滚动或鼠标事件做出反应是降低应用程序速度的一个好方法。从本质上讲，这类事件会以非常高的频率发生。由于浏览器只有16毫秒的时间来完成以60fps运行的所有工作，对这些事件中的每一个做出反应都会完全阻塞您的JS应用程序。</p><p id="892b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通常使用<a class="ae lk" href="http://okonet.ru/slides/debounced/" rel="noopener ugc nofollow" target="_blank"> <em class="mb">去抖</em> </a>模式来防止性能下降。它们确实减少了回调调用的次数，但同时也让我们的UI对用户输入的响应度降低了。我们还能对鼠标事件做出反应，并且保持在性能预算之内吗？</p><h2 id="226b" class="jw jx hu bd jy jz ka kb kc kd ke kf kg jc kh ki kj jg kk kl km jk kn ko kp kq dt translated">同步滚动组件示例</h2><p id="6346" class="pw-post-body-paragraph ir is hu it b iu kr iw ix iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo hn dt translated">为了说明这个过程，我构建了一个同步滚动组件，类似于我为<a class="ae lk" href="github.com/netlify/netlify-cms" rel="noopener ugc nofollow" target="_blank"> Netlify CMS </a> post editor所做的组件:</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff mc"><img src="../Images/6d273fe292f1badd3c77435898e4f3b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*nkfxhNWkMejrTorX1GpEWQ.gif"/></div></div></figure><p id="fa33" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该组件应该保持两个窗格的滚动位置同步。由于每个窗格内容的高度可能不同，组件需要以不同的速度滚动窗格。它还应该与任何其他组件一起工作，并且无论您的应用程序结构如何，都应该易于集成。</p><h2 id="82a4" class="jw jx hu bd jy jz ka kb kc kd ke kf kg jc kh ki kj jg kk kl km jk kn ko kp kq dt translated">不要滥用这个. setState</h2><p id="a229" class="pw-post-body-paragraph ir is hu it b iu kr iw ix iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo hn dt translated">我在React应用程序中经常看到的一个常见错误是使用<code class="eh lo lp lq lr b">this.setState</code>方法在组件中存储内部DOM状态。</p><blockquote class="md me mf"><p id="9708" class="ir is mb it b iu iv iw ix iy iz ja jb mg jd je jf mh jh ji jj mi jl jm jn jo hn dt translated">如果<code class="eh lo lp lq lr b">render()</code>里没有用的东西，就不应该在状态里。</p></blockquote><p id="6819" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在考虑下面的例子，这是我提出的SyncronizedPane组件的第一个实现:</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="mj jv l"/></div></figure><p id="429f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">将所有的州放入<code class="eh lo lp lq lr b">this.state</code>很有诱惑力(我猜是因为它的名字)。这样做的问题是，每次你调用<code class="eh lo lp lq lr b">this.setState</code>来改变它，React将重新呈现整个元素的结果树，这可能会花费大量的CPU时间。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff mk"><img src="../Images/931a36a9dacd6193a064f45f39f7a65d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4z_xDQzvVg99us83QeSiaQ.jpeg"/></div></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">Slide from <a class="ae lk" href="https://speakerdeck.com/vjeux/react-rally-animated-react-performance-toolbox" rel="noopener ugc nofollow" target="_blank">https://speakerdeck.com/vjeux/react-rally-animated-react-performance-toolbox</a></figcaption></figure><p id="3a63" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">问题是:您真的需要<em class="mb">使用React生命周期将<code class="eh lo lp lq lr b">scrollTop</code>值作为支柱传递到组件的树上吗？许多人忘记了您仍然可以在实例变量中存储任意状态。在上面的例子中，做</em></p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="mj jv l"/></div></figure><p id="9c7d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不会触发重新渲染。但是我们如何更新底层组件的滚动位置呢？这里的技巧是手动完成。</p><p id="a5f1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="mb"> —什么？！那不再是声明性代码了！— </em>这时候你可能会喊。</p><p id="91d4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="mb">不，不是！也不是习惯性的反应！</em></p><p id="1569" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">React的一个好处是，通过使用上下文，您仍然可以编写命令性代码或直接访问DOM，但对其他组件隐藏它，这样应用程序的其余代码仍然保持整洁和声明性。</p><p id="c5b7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上下文允许在组件之间创建父子关系。这意味着我们的子组件可以访问父组件的某些状态甚至方法。</p><h2 id="2c8d" class="jw jx hu bd jy jz ka kb kc kd ke kf kg jc kh ki kj jg kk kl km jk kn ko kp kq dt translated">直接DOM操作</h2><p id="f499" class="pw-post-body-paragraph ir is hu it b iu kr iw ix iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo hn dt translated">因此，以前面的例子为例，我们可以将其重写为(简化版):</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="mj jv l"/></div></figure><p id="84cf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里发生了什么？</p><ol class=""><li id="8bc5" class="kw kx hu it b iu iv iy iz jc ky jg kz jk la jo lb lc ld le dt translated">ScrollContainer组件实现register / unregister方法，用于添加/移除窗格和附加/分离事件侦听器</li><li id="a1bc" class="kw kx hu it b iu lf iy lg jc lh jg li jk lj jo lb lc ld le dt translated">ScrollPane组件现在做得很少:它只在挂载和卸载时调用register和unregister</li><li id="9809" class="kw kx hu it b iu lf iy lg jc lh jg li jk lj jo lb lc ld le dt translated">每当其中一个窗格触发一个<code class="eh lo lp lq lr b">onScroll</code>事件时，回调就会被触发，为所有窗格计算并设置新的<code class="eh lo lp lq lr b">scrollTop</code>位置。</li></ol><p id="cf15" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">看看我们如何完全跳过使用<code class="eh lo lp lq lr b">this.setState</code>和沿树向下传递道具。这允许更新DOM节点的滚动位置，而不会触发React的CPU密集型虚拟DOM操作。除此之外，那里还发生了一些更有趣的事情:</p><ol class=""><li id="d0a3" class="kw kx hu it b iu iv iy iz jc ky jg kz jk la jo lb lc ld le dt translated">我们现在可以在应用程序的任何地方使用ScrollPane，而不仅仅是作为ScrollContainer的子对象。</li><li id="bf47" class="kw kx hu it b iu lf iy lg jc lh jg li jk lj jo lb lc ld le dt translated">所有ScrollPane组件都通过传递对其DOM节点的引用在容器组件中注册自己。这使得scrollTop属性的计算和操作变得很简单。</li><li id="0ec6" class="kw kx hu it b iu lf iy lg jc lh jg li jk lj jo lb lc ld le dt translated">我们现在可以拥有任意数量的同步滚动的“窗格”。</li></ol><p id="bbe3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以在GitHub上找到工作组件的完整代码:<a class="ae lk" href="https://github.com/okonet/react-sync-scroll" rel="noopener ugc nofollow" target="_blank">https://github.com/okonet/react-sync-scroll</a>，还有一个工作演示和文档在这里:<a class="ae lk" href="http://react-sync-scroll.netlify.com/" rel="noopener ugc nofollow" target="_blank">http://react-sync-scroll.netlify.com/</a>。</p><p id="3a44" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">原来，这种技术也被用在React Native的<a class="ae lk" href="http://www.reactnative.com/react-native-animated/" rel="noopener ugc nofollow" target="_blank">动画</a>中。参见@vjeux的演示幻灯片:<a class="ae lk" href="https://speakerdeck.com/vjeux/react-rally-animated-react-performance-toolbox" rel="noopener ugc nofollow" target="_blank">https://speaker deck . com/vje UX/react-rally-animated-react-performance-toolbox</a></p></div><div class="ab cl ml mm hc mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hn ho hp hq hr"><h1 id="905d" class="ms jx hu bd jy mt mu mv kc mw mx my kg mz na nb kj nc nd ne km nf ng nh kp ni dt translated">结论</h1><p id="393f" class="pw-post-body-paragraph ir is hu it b iu kr iw ix iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo hn dt translated">有许多最佳实践和模式可以带来更好的应用程序架构，您一定要遵循它们，直到应用程序的用户体验开始受到影响。有时候，以不太习惯的方式做事或者不总是遵循“反应方式”可以带来更好的用户体验。</p><p id="fa8b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在良好的性能和代码可维护性之间找到平衡是很棘手的，但这是每个UI开发人员工作的一部分。最终，我们构建软件不是为了遵循模式，而是为了人。</p><h2 id="b441" class="jw jx hu bd jy jz ka kb kc kd ke kf kg jc kh ki kj jg kk kl km jk kn ko kp kq dt translated">相关阅读和观看:</h2><ol class=""><li id="17dd" class="kw kx hu it b iu kr iy ks jc nj jg nk jk nl jo lb lc ld le dt translated"><a class="ae lk" href="http://benchling.engineering/performance-engineering-with-react/" rel="noopener ugc nofollow" target="_blank">使用React的性能工程</a></li><li id="97cb" class="kw kx hu it b iu lf iy lg jc lh jg li jk lj jo lb lc ld le dt translated"><a class="ae lk" href="https://www.youtube.com/watch?v=mVVNJKv9esE" rel="noopener ugc nofollow" target="_blank">在抽象的光谱上</a>程露</li><li id="00aa" class="kw kx hu it b iu lf iy lg jc lh jg li jk lj jo lb lc ld le dt translated"><a class="ae lk" href="https://youtu.be/xDlfrcM6YBk" rel="noopener ugc nofollow" target="_blank">反应本土:构建流畅的用户体验</a>作者斯潘塞·阿伦斯</li><li id="fed5" class="kw kx hu it b iu lf iy lg jc lh jg li jk lj jo lb lc ld le dt translated">来自<a class="ae lk" href="https://speakerdeck.com/vjeux/react-rally-animated-react-performance-toolbox" rel="noopener ugc nofollow" target="_blank">的幻灯片动画！@vjeux</a></li></ol></div><div class="ab cl ml mm hc mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hn ho hp hq hr"><p id="bd01" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">感谢<a class="nm nn gr" href="https://medium.com/u/4a0f6a534c55?source=post_page-----4e36b8189a4c--------------------------------" rel="noopener" target="_blank">卡尔·霍基</a>的编辑和<a class="nm nn gr" href="https://medium.com/u/908fb8fea30c?source=post_page-----4e36b8189a4c--------------------------------" rel="noopener" target="_blank">马克斯·斯托伊伯</a>的审核。</p><div class="jp jq jr js fq ab cb"><figure class="no jt np nq nr ns nt paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="no jt np nq nr ns nt paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="no jt np nq nr ns nt paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="md me mf"><p id="f922" class="ir is mb it b iu iv iw ix iy iz ja jb mg jd je jf mh jh ji jj mi jl jm jn jo hn dt translated"><a class="ae lk" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是AMI家庭的一员。我们现在<a class="ae lk" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae lk" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is mb it b iu iv iw ix iy iz ja jb mg jd je jf mh jh ji jj mi jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lk" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lk" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff nu"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>