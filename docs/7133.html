<html>
<head>
<title>MVC vs. MVVM: How a Website Communicates With Its Data Models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MVC与MVVM:网站如何与其数据模型沟通</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/mvc-vs-mvvm-how-a-website-communicates-with-its-data-models-18553877bf7d?source=collection_archive---------0-----------------------#2017-10-18">https://medium.com/hackernoon/mvc-vs-mvvm-how-a-website-communicates-with-its-data-models-18553877bf7d?source=collection_archive---------0-----------------------#2017-10-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/d5a1c6b4f36c365b9c17d94d583fb1e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u6f8PH04YDb_KseBc22XWA.jpeg"/></div></div></figure><p id="6c81" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt ka translated">网站的构建没有单一的方式。网站设计模式的变化和网站本身的变化一样多。看一看脸书。从表面上看，脸书肯定是人们经常使用的最复杂的网站之一。用户一登陆他们的主页，网站就会发出至少六个<a class="ae kj" href="https://hackernoon.com/tagged/data" rel="noopener ugc nofollow" target="_blank">数据</a>请求，用大量组件填充一个页面。这些组件中的每一个都被设计为异步呈现，因此一个组件的失败不会对页面的其余部分产生影响。现在把它与像<a class="ae kj" href="https://hackernoon.com/tagged/google" rel="noopener ugc nofollow" target="_blank">谷歌</a>这样的网站相比。对谷歌来说，最大的吸引力之一是他们的主网站拥有全网最著名的简单用户界面。但实际上，google.com是人们能想到的逻辑上最复杂的网络应用之一。每当用户在其搜索栏中键入一个字符，谷歌就会利用之前搜索过的短语集合来生成自动完成的答案，估计这些答案与用户最相关。</p><p id="dd9f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，人们可以很容易地想象，运行像脸书这样的应用程序所需的逻辑将与运行像谷歌这样的应用程序所需的逻辑截然不同。从本质上讲，任何网站的功能都只是一种方式，前端或<strong class="je hv">视图</strong>可以到达适当的<strong class="je hv">模型</strong>来检索数据。无论如何，总会有模式，总会有观点。真正改变的是模型和视图的连接方式。</p><p id="f6bc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在web开发的世界里，有两种主要的方法可以让网站的视图操纵网站的模型，要么用<strong class="je hv">控制器</strong>要么用<strong class="je hv">视图模型</strong>。正如你将看到的，每种交流方式都有自己的优点和缺点。</p><h1 id="4e19" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">MVC:模型-视图-控制器</h1><p id="adf9" class="pw-post-body-paragraph jc jd hu je b jf li jh ji jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz hn dt translated">数据模型连接到应用程序视图的最标准方式很可能是通过一个叫做<strong class="je hv">控制器</strong>的接口。在MVC模式中，控制器作为一个工具，直接操作给定模型中的数据。</p><figure class="lo lp lq lr fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ln"><img src="../Images/f042293dd09fd018e2487b67e74d8bb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y-vLX2DGvqUOBa14-f5Prw.png"/></div></div><figcaption class="ls lt fg fe ff lu lv bd b be z ek">A standard authentication controller written in Ruby on Rails.</figcaption></figure><p id="e9c1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如今，网站的前端和后端被设置为彼此完全解耦。网站的用户界面已经变得非常复杂，MVC模式的视图组件无法像数据模型一样存储在同一个文件中。前端和后端仅通过get/post请求和JSON字符串连接，这些请求和字符串通过控制器和路由器进行组织。</p><figure class="lo lp lq lr fq iv fe ff paragraph-image"><div class="fe ff lw"><img src="../Images/0118238e8b2ea4891da4033012c63f92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*NxLSe3v3JyKyJqJtrij-wA.png"/></div><figcaption class="ls lt fg fe ff lu lv bd b be z ek">Router for the same auth controller shown above.</figcaption></figure><p id="527c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是在视图中通过获取请求来完成的，这些请求命中与控制器动作相关联的API上的特定路由。</p><figure class="lo lp lq lr fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lx"><img src="../Images/478670148bf277b6bb4d80001848cd04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Opsxrrns3DqxjYSEviBvJA.png"/></div></div><figcaption class="ls lt fg fe ff lu lv bd b be z ek">What a typical login fetch request looks like in React.</figcaption></figure><p id="6c5c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每个控制器被设计成既接收数据又基于接收的数据发回适当的信息。</p><p id="8d22" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">MVC模式是特别设计的，视图和模型不需要知道彼此的任何事情。因此，MVC模式允许开发人员同时处理web应用程序的不同组件，而不会相互影响。</p><p id="2602" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，MVC设计模式有许多缺点。首先，使用控制器来操纵数据模型会在后端造成混乱。标准情况下，数据库中的每个模型都有自己的控制器，因此当应用程序的规模变得更大，并演变成具有许多相关模型的操作时，所使用的控制器数量必须同步增长。这与大多数框架带来的新抽象层的自然引入相结合，创建了一个变得非常难以浏览的代码库。</p><p id="5ab6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">至少这些错误中的一部分可以通过使用视图模型来解决。</p><h1 id="f6f5" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">MVVM:模型-视图-视图模型</h1><p id="0e18" class="pw-post-body-paragraph jc jd hu je b jf li jh ji jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz hn dt translated">MVC格式的流行在很大程度上可以归因于这样一个事实:与其他设计模式相比，它非常容易理解。从表面上看，连接分离的模型和视图的最简单方法是创建一个控制器，允许视图操作数据模型。然而，这种允许视图与后端通信的间接方法并不适合每个应用程序。具体来说，控制器方法不能很好地用于<strong class="je hv">单页面应用</strong>。</p><p id="df3f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一种将视图和模型连接起来的流行方法是通过一个不太有创意的叫做<strong class="je hv">视图模型</strong>的东西。与控制器方法不同，ViewModel方法非常依赖于应用程序的前端。</p><figure class="lo lp lq lr fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ly"><img src="../Images/a103771151ab267cb99a263fa9b6f3a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GN22Yru4C5m9870uadzQMQ.png"/></div></div><figcaption class="ls lt fg fe ff lu lv bd b be z ek">AngularJS is a popular framework that prefers the MVVM pattern over MVC.</figcaption></figure><p id="83c5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">与MVC方法不同，ViewModel不是控制器。相反，它作为一个绑定器，在视图和模型之间绑定数据。MVC格式是专门设计来在模型和视图之间创建关注点分离的，而具有数据绑定的MVVM格式是专门设计来允许视图和模型直接相互通信的。</p><p id="9220" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是为什么单页应用程序可以很好地处理视图模型的原因。它很简单，允许视图直接与后端通信。正因为如此，MVVM的单页应用程序可以快速流畅地将信息保存到数据库中(谷歌文档就是一个完美的例子)。</p><p id="2fe9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，MVVM格式也有其自身的缺陷。因为它依赖于数据绑定，所以与它的控制对应方相比，ViewModel消耗了大量的内存。MVVM模式的创造者John Gossman说，实现MVVM的开销对于简单的UI操作来说是“多余的”。经常使用ViewModel方法的大型应用程序变得难以运行。因此，MVVM设计模式主要用于web上的单页面/功能应用程序。</p><h1 id="f0b5" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">论网站的功能性</h1><p id="a035" class="pw-post-body-paragraph jc jd hu je b jf li jh ji jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz hn dt translated">在过去的二十年里，我们看到网站的种类急剧增加。在过去的几年中，编程语言的激增和计算能力的稳步增长使得人们能够通过点击鼠标找到任何问题的解决方案。伴随这些创新而来的是组织我们代码库的新方法，以及网页连接到所需数据的新方法。</p><p id="0a9b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">网站的构建没有单一的方式。在这篇博文中，我们谈到了两个问题。前面提到的脸书的构建方式非常有利于MVC模式，而Google创建的许多单页面应用程序通常更有利于MVVM模式。</p><p id="1e84" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有了这些知识，我鼓励你走出去，用不同的眼光看待网站。下次你在浏览器中打开网页时，我希望你能深入思考它是如何制作的。</p><h2 id="7ea9" class="lz kl hu bd km ma mb mc kq md me mf ku jn mg mh ky jr mi mj lc jv mk ml lg mm dt translated"><strong class="ak">资源:</strong></h2><div class="mn mo fm fo mp mq"><a href="https://dzone.com/articles/angularjs-tutorial-lesson-1" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab ej"><div class="ms ab mt cl cj mu"><h2 class="bd hv fv z el mv eo ep mw er et ht dt translated">Angular JS教程- MVC和MVVM设计模式- DZone Mobile</h2><div class="mx l"><h3 class="bd b fv z el mv eo ep mw er et ek translated">在Angular JS教程系列的第一部分中，作者介绍了一些设计模式。</h3></div><div class="my l"><p class="bd b gc z el mv eo ep mw er et ek translated">dzone.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne ja mq"/></div></div></a></div><div class="mn mo fm fo mp mq"><a href="https://blogs.msdn.microsoft.com/johngossman/2006/03/04/advantages-and-disadvantages-of-m-v-vm/" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab ej"><div class="ms ab mt cl cj mu"><h2 class="bd hv fv z el mv eo ep mw er et ht dt translated">M-V-VM的优缺点</h2><div class="mx l"><h3 class="bd b fv z el mv eo ep mw er et ek translated">相对于其他方法，我有几个关于何时以及为什么使用M-V-VM的问题。明显的目的是抽象…</h3></div><div class="my l"><p class="bd b gc z el mv eo ep mw er et ek translated">blogs.msdn.microsoft.com</p></div></div><div class="mz l"><div class="nf l nb nc nd mz ne ja mq"/></div></div></a></div><div class="mn mo fm fo mp mq"><a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab ej"><div class="ms ab mt cl cj mu"><h2 class="bd hv fv z el mv eo ep mw er et ht dt translated">模型-视图-控制器-维基百科</h2><div class="mx l"><h3 class="bd b fv z el mv eo ep mw er et ek translated">模型-视图-控制器(MVC)是一种在计算机上实现用户界面的软件架构模式。它…</h3></div><div class="my l"><p class="bd b gc z el mv eo ep mw er et ek translated">en.wikipedia.org</p></div></div><div class="mz l"><div class="ng l nb nc nd mz ne ja mq"/></div></div></a></div><div class="mn mo fm fo mp mq"><a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab ej"><div class="ms ab mt cl cj mu"><h2 class="bd hv fv z el mv eo ep mw er et ht dt translated">模型-视图-视图模型-维基百科</h2><div class="mx l"><h3 class="bd b fv z el mv eo ep mw er et ek translated">MVVM促进了图形用户界面开发的分离——不管是通过标记语言还是GUI代码……</h3></div><div class="my l"><p class="bd b gc z el mv eo ep mw er et ek translated">en.wikipedia.org</p></div></div></div></a></div><div class="mn mo fm fo mp mq"><a rel="noopener follow" target="_blank" href="/upday-devs/android-architecture-patterns-part-3-model-view-viewmodel-e7eeee76b73b"><div class="mr ab ej"><div class="ms ab mt cl cj mu"><h2 class="bd hv fv z el mv eo ep mw er et ht dt translated">Android架构模式第3部分:模型-视图-视图模型</h2><div class="mx l"><h3 class="bd b fv z el mv eo ep mw er et ek translated">在开发upday应用程序的前六个月中，经过四种不同的设计，我们了解到一个重要的…</h3></div><div class="my l"><p class="bd b gc z el mv eo ep mw er et ek translated">medium.com</p></div></div><div class="mz l"><div class="nh l nb nc nd mz ne ja mq"/></div></div></a></div><figure class="lo lp lq lr fq iv"><div class="bz el l di"><div class="ni nj l"/></div></figure></div></div>    
</body>
</html>