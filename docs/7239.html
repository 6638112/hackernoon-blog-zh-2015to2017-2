<html>
<head>
<title>var, let, or const?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">var，let，还是const？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/js-var-let-or-const-67e51dbb716f?source=collection_archive---------2-----------------------#2017-10-21">https://medium.com/hackernoon/js-var-let-or-const-67e51dbb716f?source=collection_archive---------2-----------------------#2017-10-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="5da3" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">ES6简介</h2></div><p id="2287" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你必须理解<code class="eh kf kg kh ki b">var</code>才能领会<code class="eh kf kg kh ki b">let</code> / <code class="eh kf kg kh ki b">const</code>的好处。让我们倒回去。</p><h1 id="0fe6" class="kj kk hu bd kl km kn ko kp kq kr ks kt ja ku jb kv jd kw je kx jg ky jh kz la dt translated">复习:变量声明</h1><p id="70e2" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated">有意识地在特定的<strong class="jl hv">范围内<strong class="jl hv">声明</strong>变量，使用<code class="eh kf kg kh ki b">var</code>声明</strong>，以保持代码的清晰和可维护性，这一点很重要。</p><pre class="lg lh li lj fq lk ki ll lm aw ln dt"><span id="cc41" class="lo kk hu ki b fv lp lq l lr ls">var x = "outside";<br/>function foo() {<br/>  var x = "inside";<br/>  console.log(x);<br/>}</span><span id="35f8" class="lo kk hu ki b fv lt lq l lr ls">foo(); // inside<br/>console.log(x); // outside</span></pre><p id="d552" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">上面的代码使用<code class="eh kf kg kh ki b">var</code>在函数内外正确地声明了<code class="eh kf kg kh ki b">x</code>。<code class="eh kf kg kh ki b">foo</code>里没有<code class="eh kf kg kh ki b">var</code>会怎么样？</p><pre class="lg lh li lj fq lk ki ll lm aw ln dt"><span id="ea76" class="lo kk hu ki b fv lp lq l lr ls">var x = "outside";<br/>function foo() {<br/>  x = "inside";<br/>  console.log(x);<br/>}</span><span id="64d2" class="lo kk hu ki b fv lt lq l lr ls">foo(); // inside<br/>console.log(x); // inside</span></pre><p id="2ce7" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">啊哦！函数外的<code class="eh kf kg kh ki b">x</code>被函数内的<code class="eh kf kg kh ki b">x</code>覆盖了，因为我们没有指定<code class="eh kf kg kh ki b">x</code>的作用域仅限于<code class="eh kf kg kh ki b">foo</code>！</p><h2 id="419a" class="lo kk hu bd kl lu lv lw kp lx ly lz kt js ma mb kv jw mc md kx ka me mf kz mg dt translated">吊装最佳实践</h2><p id="e599" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated">在当前作用域的顶部使用<code class="eh kf kg kh ki b">var</code>声明变量。</p><p id="5aa1" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">好的:</p><pre class="lg lh li lj fq lk ki ll lm aw ln dt"><span id="a770" class="lo kk hu ki b fv lp lq l lr ls">console.log('sup')<br/>var i = 0;</span></pre><p id="6ae1" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">更好:</p><pre class="lg lh li lj fq lk ki ll lm aw ln dt"><span id="662c" class="lo kk hu ki b fv lp lq l lr ls">var i = 0;<br/>console.log('sup')</span></pre><h1 id="f8ae" class="kj kk hu bd kl km kn ko kp kq kr ks kt ja ku jb kv jd kw je kx jg ky jh kz la dt translated">复习:吊装</h1><p id="47ba" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated">使用<code class="eh kf kg kh ki b">var</code>声明的变量总是被<strong class="jl hv">提升</strong>到它们的<strong class="jl hv">范围</strong>的顶部。</p><pre class="lg lh li lj fq lk ki ll lm aw ln dt"><span id="1354" class="lo kk hu ki b fv lp lq l lr ls">console.log(j); // ReferenceError: j is not defined</span><span id="fa05" class="lo kk hu ki b fv lt lq l lr ls">console.log(i); // undefined<br/>var i = 0;</span></pre><p id="35b7" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">变量</strong> <code class="eh kf kg kh ki b">j</code>从未被<strong class="jl hv">声明为</strong>，所以我们得到一个错误消息“我从未听说过<code class="eh kf kg kh ki b">j</code>！”。</p><p id="9c14" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kf kg kh ki b">i</code> <em class="mh">因<strong class="jl hv">吊装</strong>而在测井前</em> <strong class="jl hv">申报</strong>。解释器是这样执行的:</p><pre class="lg lh li lj fq lk ki ll lm aw ln dt"><span id="9d2c" class="lo kk hu ki b fv lp lq l lr ls">var i;<br/>console.log(i);<br/>i = 0;</span></pre><p id="d38e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">解释器将<strong class="jl hv">变量声明</strong>移动到<strong class="jl hv">作用域</strong>的顶部。</p><p id="7d97" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是，变量<em class="mh">还没有</em> <strong class="jl hv">赋值</strong>给<code class="eh kf kg kh ki b">0</code>。<code class="eh kf kg kh ki b">undefined</code>说“我知道<code class="eh kf kg kh ki b">i</code> <em class="mh">存在</em>，但是我不知道<code class="eh kf kg kh ki b">i</code> <em class="mh">指向</em>什么值，因为你没有<strong class="jl hv">把</strong>赋值给任何东西”。</p><p id="3488" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="mh">补充1:如果</em> <code class="eh kf kg kh ki b"><em class="mh">var</em></code> <em class="mh"> </em> <a class="ae mi" rel="noopener" href="/@PrintSupWorld/function-hoisting-declarations-vs-expressions-7f4d385a5d7f"> <em class="mh">指的是一个函数</em> </a> <em class="mh">怎么办？<br/>补充2:提升并不会在物理上“移动”你的代码— </em> <a class="ae mi" href="https://developer.mozilla.org/en-US/docs/Glossary/Hoisting" rel="noopener ugc nofollow" target="_blank"> <em class="mh"> MDN </em> </a></p><h1 id="35b8" class="kj kk hu bd kl km kn ko kp kq kr ks kt ja ku jb kv jd kw je kx jg ky jh kz la dt translated">功能范围</h1><p id="a166" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated"><code class="eh kf kg kh ki b">var</code>是<strong class="jl hv">函数作用域</strong> : <strong class="jl hv"> </strong>作用域限于定义它的函数。</p><pre class="lg lh li lj fq lk ki ll lm aw ln dt"><span id="c3fc" class="lo kk hu ki b fv lp lq l lr ls">function foo() {<br/>  var i = 0;<br/>}</span><span id="4262" class="lo kk hu ki b fv lt lq l lr ls">console.log(i); // ReferenceError: i is not defined</span></pre><p id="e55d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kf kg kh ki b">i</code>只存在于<code class="eh kf kg kh ki b">foo</code>中，所以我们得到一个错误:“我从未听说过<code class="eh kf kg kh ki b">i</code>！”。</p><h1 id="1948" class="kj kk hu bd kl km kn ko kp kq kr ks kt ja ku jb kv jd kw je kx jg ky jh kz la dt translated">块范围</h1><p id="ba7b" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated"><code class="eh kf kg kh ki b">var</code>是<em class="mh">而不是</em> <strong class="jl hv">块范围的</strong>:范围是<em class="mh">而不是</em>局限于定义它的块。</p><pre class="lg lh li lj fq lk ki ll lm aw ln dt"><span id="c2f3" class="lo kk hu ki b fv lp lq l lr ls">var i = 0<br/>if (true) {<br/>  var i = 1;<br/>}</span><span id="59ef" class="lo kk hu ki b fv lt lq l lr ls">console.log(i); // 1</span></pre><p id="91f7" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kf kg kh ki b">i</code><em class="mh"/>是否仍在<strong class="jl hv">内的“全局范围”内阻塞</strong>。<code class="eh kf kg kh ki b">i</code>的<strong class="jl hv">值</strong>被覆盖，这可能不是本意。</p><figure class="lg lh li lj fq mk fe ff paragraph-image"><div class="fe ff mj"><img src="../Images/84398d281ca7257dabdff4151f71458a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*kCD_6R3UkMHkpS_YgFoU9w.jpeg"/></div></figure><h1 id="b9d5" class="kj kk hu bd kl km kn ko kp kq kr ks kt ja ku jb kv jd kw je kx jg ky jh kz la dt translated">让</h1><p id="19ac" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated"><code class="eh kf kg kh ki b">let</code>变量<em class="mh">是</em> <strong class="jl hv">块范围的</strong>！具体范围=错误少。</p><pre class="lg lh li lj fq lk ki ll lm aw ln dt"><span id="753d" class="lo kk hu ki b fv lp lq l lr ls">let i = 0;<br/>if (true) {<br/>  let i = 1;<br/>}</span><span id="7ce0" class="lo kk hu ki b fv lt lq l lr ls">console.log(i); // 0</span></pre><p id="637a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">即使<code class="eh kf kg kh ki b">i</code>在<strong class="jl hv"> if块</strong>中被<strong class="jl hv">赋值</strong>到<code class="eh kf kg kh ki b">1</code>，那个<strong class="jl hv">赋值</strong>是<strong class="jl hv"> local </strong>到<strong class="jl hv">块</strong>，因此我们的【全局】<code class="eh kf kg kh ki b">i</code>仍然是<code class="eh kf kg kh ki b">0</code>。<code class="eh kf kg kh ki b">if</code>块的作用域独立于全局作用域。</p><h1 id="deb1" class="kj kk hu bd kl km kn ko kp kq kr ks kt ja ku jb kv jd kw je kx jg ky jh kz la dt translated">const ==常数</h1><p id="e61d" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated"><code class="eh kf kg kh ki b">const</code>限制重写变量。</p><pre class="lg lh li lj fq lk ki ll lm aw ln dt"><span id="be11" class="lo kk hu ki b fv lp lq l lr ls">const i = 0;<br/>i = 1; // TypeError: Assignment to constant variable.</span></pre><p id="41ff" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kf kg kh ki b">const</code>甚至不允许你声明一个没有赋值(常量)的变量！</p><pre class="lg lh li lj fq lk ki ll lm aw ln dt"><span id="88bc" class="lo kk hu ki b fv lp lq l lr ls">const i; // SyntaxError: Missing initializer in const declaration</span></pre><p id="8165" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kf kg kh ki b">const</code>和<code class="eh kf kg kh ki b">let</code>一样，是<strong class="jl hv">块作用域</strong>。</p><pre class="lg lh li lj fq lk ki ll lm aw ln dt"><span id="edfd" class="lo kk hu ki b fv lp lq l lr ls">if (true) {<br/>  const i = 0;<br/>}</span><span id="4750" class="lo kk hu ki b fv lt lq l lr ls">console.log(i); // ReferenceError: i is not defined</span></pre><p id="3814" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kf kg kh ki b">const</code><em class="mh"/>是否允许变量<a class="ae mi" rel="noopener" href="/@PrintSupWorld/javascript-mutable-ce855ef455fd"> <strong class="jl hv">突变</strong></a><strong class="jl hv"/>(JS中只有对象/数组是可变的)。</p><p id="fc76" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">数组突变:</p><pre class="lg lh li lj fq lk ki ll lm aw ln dt"><span id="2ee4" class="lo kk hu ki b fv lp lq l lr ls">const a = [1];<br/>const b = a;<br/>console.log(a === b); // true<br/>b.push(2);<br/>console.log(a === b); // true<br/>console.log(a); /// [ 1, 2 ]</span></pre><p id="ed89" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对象突变:</p><pre class="lg lh li lj fq lk ki ll lm aw ln dt"><span id="1e62" class="lo kk hu ki b fv lp lq l lr ls">const obj = {};<br/>obj.i = 1;<br/>console.log(obj); // { i: 1 }</span></pre><h1 id="b0a9" class="kj kk hu bd kl km kn ko kp kq kr ks kt ja ku jb kv jd kw je kx jg ky jh kz la dt translated">左/const提升</h1><p id="5e6d" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated"><code class="eh kf kg kh ki b">let</code>和<code class="eh kf kg kh ki b">const</code>申报是<em class="mh">而不是</em>吊装！</p><blockquote class="mn mo mp"><p id="8a98" class="jj jk mh jl b jm jn iv jo jp jq iy jr mq jt ju jv mr jx jy jz ms kb kc kd ke hn dt translated">编辑:技术上来说它们<a class="ae mi" href="https://stackoverflow.com/questions/31219420/are-variables-declared-with-let-or-const-not-hoisted-in-es6" rel="noopener ugc nofollow" target="_blank">被吊起</a>，但是它们没有被初始化为任何东西(<code class="eh kf kg kh ki b">var</code>被初始化为<code class="eh kf kg kh ki b">undefined</code>)。</p></blockquote><pre class="lg lh li lj fq lk ki ll lm aw ln dt"><span id="445b" class="lo kk hu ki b fv lp lq l lr ls">console.log(a); // undefined<br/>var a = 2;</span><span id="cd19" class="lo kk hu ki b fv lt lq l lr ls">console.log(b); // Uncaught ReferenceError: b is not defined</span><span id="cf3e" class="lo kk hu ki b fv lt lq l lr ls">console.log(c); // Uncaught ReferenceError: c is not defined<br/>let c = 2;</span></pre><p id="4ca0" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这可以防止变量<em class="mh">声明</em>放在变量<em class="mh">引用</em>之后。</p><p id="1a31" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kf kg kh ki b">isEqualTo5</code>有一个bug——它总是返回<code class="eh kf kg kh ki b">true</code>。</p><pre class="lg lh li lj fq lk ki ll lm aw ln dt"><span id="5407" class="lo kk hu ki b fv lp lq l lr ls">function isEqualTo5(n) {<br/>  return !(n - five);<br/>  var five = 5;<br/>}<br/>console.log(isEqualTo5(4)); // true</span></pre><p id="3546" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">问题是<code class="eh kf kg kh ki b">five</code>直到被引用后才被赋值。它<em class="mh">是</em>声明的，所以当它在return语句中被引用时，它的值是<code class="eh kf kg kh ki b">undefined</code>。</p><pre class="lg lh li lj fq lk ki ll lm aw ln dt"><span id="8625" class="lo kk hu ki b fv lp lq l lr ls">!(4 - undefined) === !(NaN) === true</span></pre><p id="726f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个bug可能很难抓到。<code class="eh kf kg kh ki b">let</code> / <code class="eh kf kg kh ki b">const</code>来救援了！</p><pre class="lg lh li lj fq lk ki ll lm aw ln dt"><span id="d429" class="lo kk hu ki b fv lp lq l lr ls">function isEqualTo5(n) {<br/>  return !(n - five);<br/>  const five = 5;<br/>}<br/>console.log(isEqualTo5(4)); // ReferenceError: five is not defined</span></pre><p id="1cdb" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kf kg kh ki b">const</code>不提升声明→错误:声明前引用→防止bug。</p></div><div class="ab cl mt mu hc mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="hn ho hp hq hr"><p id="fa88" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">特定范围=更少的错误+更好的可读性/可维护性。</p><h2 id="eec4" class="lo kk hu bd kl lu lv lw kp lx ly lz kt js ma mb kv jw mc md kx ka me mf kz mg dt translated">TLDR: <code class="eh kf kg kh ki b">var</code> →🗑，<code class="eh kf kg kh ki b">const </code>哪里可以🔑，否则<code class="eh kf kg kh ki b">let</code>也很酷！🕶</h2></div></div>    
</body>
</html>