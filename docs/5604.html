<html>
<head>
<title>N-API and getting started with writing C addons for Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">N-API并开始为Node.js编写C插件</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/n-api-and-getting-started-with-writing-c-addons-for-node-js-cf061b3eae75?source=collection_archive---------1-----------------------#2017-08-05">https://medium.com/hackernoon/n-api-and-getting-started-with-writing-c-addons-for-node-js-cf061b3eae75?source=collection_archive---------1-----------------------#2017-08-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/69001d9a51ff56fa067a22624447c8d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6sSo0a1lvISaqMchhcNXEA.png"/></div></div></figure><div class=""/><p id="e7ee" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Node.js的最新版本为Node世界引入了一些重要的变化和API附加功能，但可能最少被提及的附加功能是在v8.x中发布的，它离作为Node核心的V8(JS引擎)越来越远。</p></div><div class="ab cl ka kb hc kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hn ho hp hq hr"><blockquote class="kh ki kj"><p id="c14a" class="jc jd kk je b jf jg jh ji jj jk jl jm kl jo jp jq km js jt ju kn jw jx jy jz hn dt translated">N-API允许开发人员编写C/C++插件，而不需要对V8的工作有深入的理解，并且提供了更符合Node和Javascript的抽象。</p></blockquote><p id="b05f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="kk">更新:由于N-API本身仍处于试验阶段，因此本文将根据其重大变化不断更新。当前版本的文章是基于</em> <strong class="je ig"> <em class="kk">节点8.6.x到8.8.x </em> </strong> <em class="kk">，对于较早版本的</em> <a class="ae ko" href="https://github.com/schahriar/n-api-article" rel="noopener ugc nofollow" target="_blank"> <em class="kk">参考本回购</em> </a> <em class="kk">。</em></p><h1 id="d65c" class="kp kq if bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">一点历史</h1><p id="a27e" class="pw-post-body-paragraph jc jd if je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt ls translated">C/c++插件长期以来一直是Node.js生态系统的一部分，然而开发这些插件一直是一个挑战，即使对于来自C世界的开发人员来说也是如此。文档中甚至提到“目前，实现插件的方法相当复杂，涉及到几个组件和API的知识”。也许最大的障碍是V8的内部，处理V8需要很好地理解C++、JS以及一些V8的内部工作原理。</p><blockquote class="kh ki kj"><p id="a625" class="jc jd kk je b jf jg jh ji jj jk jl jm kl jo jp jq km js jt ju kn jw jx jy jz hn dt translated"><em class="if">注意NaN (Node的节点抽象)是一个很好的抽象层，但只针对V8。</em></p></blockquote><p id="b94b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">问题是，在Node.js出现之前，V8 APIs并没有广泛流行，面向V8的消费者只有一个目的，服务js并将其快速提供给Chrome，将Webkit和Chrome的其他部分与V8集成的人是唯一需要深入了解V8的人，其他人都跟着一起做。虽然V8改变了web的景观并触及了后端世界，但它并没有考虑到日常的节点模块，而且就在不久前，微软认为他们的JS引擎Chakra必须与V8一样好或更好才能被广泛采用，所以他们决定废黜V8作为Node中唯一的虚拟机之王。</p><p id="3064" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Node-ChakraCore的创意和addons API中的简化导致了N-API的引入，不知何故它变得令人印象深刻和简单。它允许开发人员编写C/C++插件，而不需要对V8的工作有深入的理解，并提供了更符合节点和Javascript的抽象。</p></div><div class="ab cl ka kb hc kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hn ho hp hq hr"><h1 id="da7a" class="kp kq if bd kr ks mb ku kv kw mc ky kz la md lc ld le me lg lh li mf lk ll lm dt translated">N-API中的节点模块入门</h1><p id="35d2" class="pw-post-body-paragraph jc jd if je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">在这篇文章中，我将介绍这个“实验性”API的一些伟大的附加功能和好处，供想要开发插件和扩展Node范围的JS开发人员使用。对于使用N-API的普通JS/C/C++开发人员来说，原生插件世界应该没有那么可怕，因为你不会直接与V8打交道。这些抽象中的大部分是用C实现的，并且有C++的语法包装。</p><h2 id="5a84" class="mg kq if bd kr mh mi mj kv mk ml mm kz jn mn mo ld jr mp mq lh jv mr ms ll mt dt translated">使用node-gyp设置</h2><p id="6c5e" class="pw-post-body-paragraph jc jd if je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">要构建您的本机模块，您可以利用node-gyp，gyp项目是Chromium项目使用的另一个构建系统的抽象层，它是构建本机模块的一个很好的工具，并将在适用的地方生成一个makefile文件。和大多数Googly项目一样，你需要安装python。然后，您可以从NPM安装node-gyp:</p><p id="6736" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh mu mv mw mx b">npm install -g node-gyp</code></p><p id="1fd8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，您可以通过创建一个新文件夹并运行<code class="eh mu mv mw mx b">npm init</code>来创建一个简单的模块，然后在您的根目录中添加<strong class="je ig"> binding.gyp </strong>并为其设置一个目标源。</p><figure class="my mz na nb fq hw"><div class="bz el l di"><div class="nc nd l"/></div></figure><p id="e770" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">暂时让模块文件为空，它还不会构建，但是我们很快就会完成。</p><h2 id="0bcd" class="mg kq if bd kr mh mi mj kv mk ml mm kz jn mn mo ld jr mp mq lh jv mr ms ll mt dt translated">NAPI _模块和导出的属性</h2><p id="5de2" class="pw-post-body-paragraph jc jd if je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">在我们的C/C++模块文件<code class="eh mu mv mw mx b">module.c</code>中，我们首先需要包含NAPI头文件。这不同于之前可用的<code class="eh mu mv mw mx b">node.h</code>，而是被命名为<a class="ae ko" href="https://github.com/nodejs/node/blob/master/src/node_api.h" rel="noopener ugc nofollow" target="_blank"> node_api.h </a>:</p><pre class="my mz na nb fq ne mx nf ng aw nh dt"><span id="66f2" class="mg kq if mx b fv ni nj l nk nl">#include &lt;node_api.h&gt;</span></pre><p id="3fe9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">同样，一个新的函数已经被实现，用于初始化你的节点本机模块，它被称为<code class="eh mu mv mw mx b">NAPI_MODULE</code>，其行为方式与其前身相似。我们将把模块指向一个返回导出的Init方法:</p><figure class="my mz na nb fq hw"><div class="bz el l di"><div class="nc nd l"/></div></figure><p id="d65f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh mu mv mw mx b">napi_env</code>是V8隔离或其他虚拟机中的实例的抽象概念，本质上，隔离是V8的一个实例，具有自己的堆和垃圾收集器，我们将传递env以在同一个虚拟机实例中运行。</p><p id="1214" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">是对JS变量的一个漂亮的抽象，它代表了一个JS值，你可以很容易地创建和填充这些值并将它们返回到JS-land。</p><p id="ed43" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过在NAPI中填充exports或settings module.exports，你可以配置你的插件在JS需要时返回一个特定的对象。我们将在JS的上下文中创建我们的函数，并使用<code class="eh mu mv mw mx b">napi_create_function</code>将它分配给一个<code class="eh mu mv mw mx b">napi_value</code>，使用<code class="eh mu mv mw mx b">napi_set_named_property</code>将该函数分配给我们的导出对象:</p><figure class="my mz na nb fq hw"><div class="bz el l di"><div class="nc nd l"/></div></figure><p id="f932" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh mu mv mw mx b">napi_set_named_property</code>接受env，一个对象(在我们的例子中是exports)，我们属性的名称和它所指向的值，在我们的例子中是我们函数的一个<code class="eh mu mv mw mx b">napi_value</code>。</p><p id="385d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以使用define properties调用将属性分配给代码中的任何JS对象，但是这里我们使用to来复制类似于:</p><figure class="my mz na nb fq hw"><div class="bz el l di"><div class="nc nd l"/></div></figure><p id="3152" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，<code class="eh mu mv mw mx b">napi_set_named_property</code>的返回类型是一个<code class="eh mu mv mw mx b">napi_status</code>，N-API为它的几乎所有调用返回一个状态，这是抛出有意义的错误让JS处理的一个非常好的方法。我将在下面的<strong class="je ig">用N-API进行错误处理</strong>一节中介绍更多的错误处理，但是现在你只需要知道如果<code class="eh mu mv mw mx b">status == napi_ok</code>那么你就没事了。</p><h2 id="606b" class="mg kq if bd kr mh mi mj kv mk ml mm kz jn mn mo ld jr mp mq lh jv mr ms ll mt dt translated">创建我们的C函数</h2><p id="c535" class="pw-post-body-paragraph jc jd if je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">现在我们已经在module.exports中定义了我们的<code class="eh mu mv mw mx b">MyFunction</code>函数，作为descs N-API方法的一部分，让我们合理地使用我们的函数。它将接受单个JS数作为参数，将其转换为32位Int，乘以2，然后作为另一个JS数返回，在我们的例子中，这个JS数将被表示为<code class="eh mu mv mw mx b">napi_value</code>。虽然功能非常简单，但比起“Hello World”，这是一个更好的开始:</p><figure class="my mz na nb fq hw"><div class="bz el l di"><div class="nc nd l"/></div></figure><p id="4880" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的函数接受env/instance和一个<code class="eh mu mv mw mx b">napi_callback_info</code>，您可以从中提取参数和其他关于上下文的信息。我们还在函数上定义了status，作为最佳实践，我们将在多次调用中重用它。</p><p id="78e2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我们将利用<code class="eh mu mv mw mx b">napi_get_cb_info</code>来获取作为N-API值数组的参数。我们需要定义期望的参数总数或参数计数(argc ),并将最后两个参数<code class="eh mu mv mw mx b">this</code>和数据指针保留为空:</p><figure class="my mz na nb fq hw"><div class="bz el l di"><div class="nc nd l"/></div></figure><p id="7216" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">既然我们已经将JS数作为参数向量的第一个成员进行了传递，我们需要将它从JS值<code class="eh mu mv mw mx b">napi_value</code>转换为普通的int，这样我们就可以在C中将其相乘。<em class="kk">因为我们将值从JS传递到C world，所以我们的数据需要一些处理</em>。我们将调用<code class="eh mu mv mw mx b">napi_get_value_int32</code>,它也返回一个<code class="eh mu mv mw mx b">napi_status</code>,然后我们可以用它来验证操作是否成功。我们将向函数传递env/instance、N-API值和一个指向我们定义的int的指针，以便用结果填充。</p><figure class="my mz na nb fq hw"><div class="bz el l di"><div class="nc nd l"/></div></figure><p id="ffe6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以根据enum <code class="eh mu mv mw mx b">napi_ok</code>验证我们的状态，并使用接受env的<code class="eh mu mv mw mx b">napi_throw_error</code>调用抛出一个JS错误，env是一个可选的错误代码，我们将它保留为null，C字符串char*作为消息。这样，如果出现任何问题，我们将向JS-land抛出一个有意义的错误。</p><figure class="my mz na nb fq hw"><div class="bz el l di"><div class="nc nd l"/></div></figure><p id="e80d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，在这种情况下，您可以使用<code class="eh mu mv mw mx b">napi_throw_type_error</code>来提供更有效的类型错误。</p><p id="f2ae" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，我们将我们的数字乘以2，并使用<code class="eh mu mv mw mx b">napi_create_int32</code>将其转换回JS值，到现在为止，您可能已经理解了在N-API中将env/instance作为第一个参数和状态返回的模式。</p><figure class="my mz na nb fq hw"><div class="bz el l di"><div class="nc nd l"/></div></figure><p id="af2c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的函数最终看起来会像这样:</p><figure class="my mz na nb fq hw"><div class="bz el l di"><div class="nc nd l"/></div></figure><p id="aed3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦你的插件构建完成，你可以通过以下方式从JS中调用它，尽管我建议使用<a class="ae ko" href="https://www.npmjs.com/package/bindings" rel="noopener ugc nofollow" target="_blank">绑定</a>模块:</p><figure class="my mz na nb fq hw"><div class="bz el l di"><div class="nc nd l"/></div></figure></div><div class="ab cl ka kb hc kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hn ho hp hq hr"><p id="3928" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以下是完整源码:<a class="ae ko" href="https://github.com/schahriar/n-api-article/tree/master/Getting_Started" rel="noopener ugc nofollow" target="_blank">https://github . com/schahriar/n-API-article/tree/master/Getting _ Started</a></p><h1 id="fc1d" class="kp kq if bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">构建和运行你的插件</h1><p id="31a5" class="pw-post-body-paragraph jc jd if je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">现在，您拥有了运行程序所需的所有代码，该程序将输出以下事实:</p><pre class="my mz na nb fq ne mx nf ng aw nh dt"><span id="e199" class="mg kq if mx b fv ni nj l nk nl">8 times 2 equals 16</span></pre><p id="6a84" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以使用以下方式触发构建:</p><pre class="my mz na nb fq ne mx nf ng aw nh dt"><span id="abc2" class="mg kq if mx b fv ni nj l nk nl">node-gyp configure build</span></pre><p id="a840" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">并使用设置了<code class="eh mu mv mw mx b">--napi-modules</code>标志的node运行您的JS文件(仅适用于8.5.x及以下版本):</p><pre class="my mz na nb fq ne mx nf ng aw nh dt"><span id="6440" class="mg kq if mx b fv ni nj l nk nl">node --napi-modules module.js</span></pre><h1 id="d28c" class="kp kq if bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">所有这些都是为了一个乘以2的函数？</h1><p id="ebac" class="pw-post-body-paragraph jc jd if je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">你可能会说，用一行代码就可以在JS中完成:</p><figure class="my mz na nb fq hw"><div class="bz el l di"><div class="nc nd l"/></div></figure><p id="1080" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是C/C++绑定的含义比乘法函数要大得多，乘法函数应该具有与其JIT替代函数相同的性能。通过编写原生插件，你可以有效地将Node扩展到以前不适合的领域，很好的例子包括<a class="ae ko" href="https://github.com/mikeseven/node-opencl" rel="noopener ugc nofollow" target="_blank"> node-opencl </a>或<a class="ae ko" href="https://github.com/boingoing/leveldown/" rel="noopener ugc nofollow" target="_blank"> leveldown </a>。</p></div><div class="ab cl ka kb hc kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hn ho hp hq hr"><p id="8321" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我对原生绑定的第一个实验是实现一组专有的<a class="ae ko" href="https://en.wikipedia.org/wiki/OpenGL_Shading_Language" rel="noopener ugc nofollow" target="_blank"> GLSL </a>绑定，这些绑定在GPU上渲染一个着色器并返回到一个数组缓冲区，感觉好像我已经突破了Node的极限，我鼓励你将Node带到从未有过的地方，成为Node社区的一部分。</p></div></div>    
</body>
</html>