<html>
<head>
<title>Azure SQL transient errors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Azure SQL暂时性错误</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/azure-sql-transient-errors-7625ad6e0a06?source=collection_archive---------5-----------------------#2017-03-30">https://medium.com/hackernoon/azure-sql-transient-errors-7625ad6e0a06?source=collection_archive---------5-----------------------#2017-03-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="24d7" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">中处理Azure SQL瞬态错误。NET Core使用Polly</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/00fc61298cce01e2bd96948b17620957.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PZ9BTnhFVJ6a39RKq-uXTw.png"/></div></div></figure><p id="23ad" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">迁移到使用云服务时，人们会注意到的一件事是，间歇性错误的发生率比在本地运行时要高。</p><p id="e329" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这些错误通常被称为<strong class="jx hv"> <em class="kr">瞬时</em> </strong>错误，可以通过重试操作来减轻。虽然有些操作在所有情况下都可以重试，例如获取数据，但其他操作，如创建订单、扣款等。可能不需要或者至少需要更精细的颗粒控制。此外，有些错误重试是没有意义的，因此最好快速失败。</p><p id="81e7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">编写要处理的代码很容易变成意大利面条式的代码，这不是你想要复制粘贴的代码，因为它很容易出错并且难以维护——所以你真的需要一个框架来帮助你处理这些场景。</p><h2 id="fe81" class="ks kt hu bd ku kv kw kx ky kz la lb lc ke ld le lf ki lg lh li km lj lk ll lm dt translated">介绍波利</h2><p id="cdbd" class="pw-post-body-paragraph jv jw hu jx b jy ln iv ka kb lo iy kd ke lp kg kh ki lq kk kl km lr ko kp kq hn dt translated">作者是这样描述波利的:</p><blockquote class="ls lt lu"><p id="5b31" class="jv jw kr jx b jy jz iv ka kb kc iy kd lv kf kg kh lw kj kk kl lx kn ko kp kq hn dt translated">Polly是一个. NET弹性和瞬时故障处理库，允许开发人员以流畅和线程安全的方式表达策略，如重试、断路器、超时、隔板隔离和回退。</p></blockquote><p id="5c68" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这实际上总结了它的功能，它允许您使用流畅的API创建策略，这些策略可以重复使用，范围从通用到非常具体的场景。</p><p id="dd2c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Polly可作为NuGet包使用，可与两种旧的。又净又闪亮。NET Core，这将是我在这篇文章中使用的。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff lz"><img src="../Images/7017ee1e2c8647081bf1905128411150.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_vNRKpelH2e6Y4QAPRhsiA.png"/></div></div></figure><p id="5f8a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">同样值得注意的是Polly是开源的，可以在GitHub上获得。<br/>波莉也是<a class="ae ly" href="https://dotnetfoundation.org/" rel="noopener ugc nofollow" target="_blank">的成员。网基</a>。</p><h2 id="3ce2" class="ks kt hu bd ku kv kw kx ky kz la lb lc ke ld le lf ki lg lh li km lj lk ll lm dt translated">创建策略</h2><p id="3482" class="pw-post-body-paragraph jv jw hu jx b jy ln iv ka kb lo iy kd ke lp kg kh ki lq kk kl km lr ko kp kq hn dt translated">用Polly定义一个策略非常简单，只需使用你的类来创建你的策略</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="d777" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">上面我们已经通过<code class="eh ma mb mc md b">Handle&lt;TException&gt;</code>方法定义了一个策略，如果<code class="eh ma mb mc md b">TimeoutException</code>发生，它将等待<strong class="jx hv"> <em class="kr"> 3秒</em> </strong>并重试操作<strong class="jx hv"> <em class="kr"> 5次</em> </strong>，然后在使用<code class="eh ma mb mc md b">WaitAndRetry</code>方法定义的<strong class="jx hv"><em class="kr">6次</em> </strong>时间失败。</p><p id="1b35" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">因为在这种情况下，每次重试尝试的延迟是使用一个<code class="eh ma mb mc md b">Func&lt;int, TimeSpan&gt;</code>委托来检索的，所以实现更高级的场景(比如滑动延迟)真的很容易</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="124a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">为了让我们的策略处理更多的异常，我们可以在<code class="eh ma mb mc md b">Handle&lt;TException&gt;</code>调用之后使用一对多的<code class="eh ma mb mc md b">Or&lt;TException&gt;</code>方法</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="4668" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">您还可以通过用异常谓词检查异常来使您的策略更加细化</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="042b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在这种情况下，如果没有找到<code class="eh ma mb mc md b">.tmp</code>文件，我们将很快失败。您还可以根据结果值设置策略，除了重试之外，还支持断路器、超时、回退、组合策略等，因此策略“引擎”非常灵活。</p><h2 id="239e" class="ks kt hu bd ku kv kw kx ky kz la lb lc ke ld le lf ki lg lh li km lj lk ll lm dt translated">使用策略</h2><p id="0038" class="pw-post-body-paragraph jv jw hu jx b jy ln iv ka kb lo iy kd ke lp kg kh ki lq kk kl km lr ko kp kq hn dt translated">我们现在已经有了我们的策略，并且想要很好地使用它，这里policies <code class="eh ma mb mc md b">Execute</code>方法发挥作用了</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="3651" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">您还可以创建异步策略，然后我们可以利用策略的<code class="eh ma mb mc md b">ExecuteAsync</code>方法</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="3dba" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这简直好得令人难以置信，有很多事情正在发生——但在我看来“隐藏”在一个非常容易理解和维护的API之下。</p><h2 id="88d3" class="ks kt hu bd ku kv kw kx ky kz la lb lc ke ld le lf ki lg lh li km lj lk ll lm dt translated">Azure SQL策略</h2><p id="ca17" class="pw-post-body-paragraph jv jw hu jx b jy ln iv ka kb lo iy kd ke lp kg kh ki lq kk kl km lr ko kp kq hn dt translated">当涉及到SQL server时，有几个已知可以安全重试的错误，所以我们明确地寻找这些错误，所以如果我们开始，它可能看起来像这样:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="9105" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">其中<code class="eh ma mb mc md b">SqlRetryCount</code>仅仅是重试次数的常数，而<code class="eh ma mb mc md b">ExponetialBackoff</code>是指数增加每次尝试之间的延迟的方法</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="cd74" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><code class="eh ma mb mc md b">TimeoutException:s</code>将总是被重试，但是SqlExceptions将被传递给<code class="eh ma mb mc md b">AnyRetryableError</code>方法以评估它是否可重试</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="fc2d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><code class="eh ma mb mc md b">AnyRetryableError</code>将迭代所有错误，并用<code class="eh ma mb mc md b">RetryableError</code>方法检查是否是已知可重试的错误，这就是神奇的地方</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="1c53" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们将打开SqlException错误号，并使用几个已知的常数来确定它应该快速失败还是重试。</p><h2 id="51f1" class="ks kt hu bd ku kv kw kx ky kz la lb lc ke ld le lf ki lg lh li km lj lk ll lm dt translated">拿政策兜兜风</h2><p id="0c37" class="pw-post-body-paragraph jv jw hu jx b jy ln iv ka kb lo iy kd ke lp kg kh ki lq kk kl km lr ko kp kq hn dt translated">在这种情况下，我将做一个简单的API，用<code class="eh ma mb mc md b">WithRetry</code>方法扩展<code class="eh ma mb mc md b">SqlCOnnection</code>，即打开SQL连接</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="b7fb" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">给了我们一个开放的同步和异步方法，其最简单的用法如下</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="40cc" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">结合一个简单的SQL来。像<a class="ae ly" href="https://github.com/StackExchange/Dapper" rel="noopener ugc nofollow" target="_blank"> Dapper </a>这样的. NET对象映射器会产生非常干净的代码</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="ff4f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">上面的代码将使用重试策略打开sql连接，但查询将在不重试的情况下执行，这可能是您对某些操作所希望的，但对于select来说，重试整个操作通常是安全的。为此，我们添加了一个重载，允许我们在策略边界内执行代码</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="8bbb" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这将打开连接，然后调用并返回您传递给它的<code class="eh ma mb mc md b">Func</code>的结果，所有这些都在策略的范围内，只是调用代码的小的重构</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="12a4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">异步变量的用法如下所示</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="me mf l"/></div></figure><h2 id="ca63" class="ks kt hu bd ku kv kw kx ky kz la lb lc ke ld le lf ki lg lh li km lj lk ll lm dt translated">结论</h2><p id="476f" class="pw-post-body-paragraph jv jw hu jx b jy ln iv ka kb lo iy kd ke lp kg kh ki lq kk kl km lr ko kp kq hn dt translated">Polly功能非常强大，而且很容易上手，也很容易改装到现有的应用程序中——所以我绝对认为你应该尝试一下。</p><p id="72cd" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我已经用这篇文章中的代码在GitHub上创建了一个完整的样本库，感谢阅读！❤</p><div class="mg mh fm fo mi mj"><a href="https://github.com/azurevoodoo/AzureSQLTransientHandling" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab ej"><div class="ml ab mm cl cj mn"><h2 class="bd hv fv z el mo eo ep mp er et ht dt translated">azurevoodoo/AzureSQLTransientHandling</h2><div class="mq l"><h3 class="bd b fv z el mo eo ep mp er et ek translated">AzureSQLTransientHandling -处理中的Azure SQL瞬态错误。NET Core使用Polly</h3></div><div class="mr l"><p class="bd b gc z el mo eo ep mp er et ek translated">github.com</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx jt mj"/></div></div></a></div><div class="jk jl jm jn fq ab cb"><figure class="my jo mz na nb nc nd paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="my jo mz na nb nc nd paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="my jo mz na nb nc nd paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ls lt lu"><p id="f922" class="jv jw kr jx b jy jz iv ka kb kc iy kd lv kf kg kh lw kj kk kl lx kn ko kp kq hn dt translated"><a class="ae ly" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ly" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ly" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ly" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jv jw kr jx b jy jz iv ka kb kc iy kd lv kf kg kh lw kj kk kl lx kn ko kp kq hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ly" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ly" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ne"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>