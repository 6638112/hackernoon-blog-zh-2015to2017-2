<html>
<head>
<title>The Has Type Class Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有类型类模式</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-has-type-class-pattern-ca12adab70ae?source=collection_archive---------7-----------------------#2017-06-28">https://medium.com/hackernoon/the-has-type-class-pattern-ca12adab70ae?source=collection_archive---------7-----------------------#2017-06-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="5138" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">类型类模式很简单，但是令人惊讶的有用。我将介绍一些例子。</p><h1 id="fa4c" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">用例1:收集所有图像</h1><p id="b8c9" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">假设您正在开发一个游戏，并且在资产验证步骤中，您希望确保场景的图像存在。</p><p id="26cb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们需要遍历场景<a class="ae jt" href="https://hackernoon.com/tagged/description" rel="noopener ugc nofollow" target="_blank">描述</a>并收集所有图像文件路径。我们来做一个<code class="eh jp jq jr js b">Scene</code>型:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="5616" class="lf jv hu js b fv lg lh l li lj">data Scene = Scene <br/>  { backgroundImage   :: Text<br/>  , characters        :: [Character]   <br/>  , bewilderedTourist :: Maybe Character<br/>  , objects           :: [Either Rock WoodenCrate]  <br/>  }</span><span id="2ac5" class="lf jv hu js b fv lk lh l li lj">data Character = Character<br/> { hat   :: Maybe DamageArray<br/> , head  :: DamageArray<br/> , torso :: DamageArray<br/> , legs  :: DamageArray<br/> , shoes :: Maybe DamageArray<br/> }</span><span id="db84" class="lf jv hu js b fv lk lh l li lj">data DamageArray = DamageArray<br/>  { noDamage        :: Text<br/>  , someDamage      :: Text<br/>  , excessiveDamage :: Text<br/>  }</span><span id="e05b" class="lf jv hu js b fv lk lh l li lj">data Rock = Rock <br/>  { weight    :: Double<br/>  , rockImage :: Text<br/>  }</span><span id="ad0c" class="lf jv hu js b fv lk lh l li lj">data WoodenCrate = WoodenCrate<br/>  { strength         :: Double<br/>  , woodenCrateImage :: DamageArray  <br/>  }</span></pre><p id="6d5e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你明白了。有很多类型，有相当数量的嵌套。一个真实的场景可能有数百种类型和两位数级别的嵌套，但对于我们的目的来说，这是一个足够好的例子。</p><p id="47f5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以现在我们想写一个函数，<code class="eh jp jq jr js b">collectImages :: Scene -&gt; Set Text</code>。</p><h2 id="531c" class="lf jv hu bd jw ll lm ln ka lo lp lq ke jc lr ls ki jg lt lu km jk lv lw kq lx dt translated">你知道没有</h2><p id="eb1c" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">最直接的方法是只编写函数:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="2df4" class="lf jv hu js b fv lg lh l li lj">collectImages :: Scene -&gt; Set Text<br/>collectImages Scene {..} <br/>  =  singleton backgroundImage <br/>  &lt;&gt; mconcat (map collectCharacterImages characters)<br/>  &lt;&gt; maybe mempty collectCharacterImages bewilderedTourist<br/>  &lt;&gt; mconcat (map (either (singleton . collectRockImage) <br/>                          collectWoodenCrateImages)     <br/>                  objects)</span><span id="7118" class="lf jv hu js b fv lk lh l li lj">collectCharacterImages :: Character -&gt; Set Text<br/>collectCharacterImages Character {..}  <br/>  =  maybe mempty collectDamageArrayImages hat<br/>  &lt;&gt; collectDamageArrayImages head<br/>  &lt;&gt; collectDamageArrayImages torso<br/>  &lt;&gt; collectDamageArrayImages legs<br/>  &lt;&gt; maybe mempty collectDamageArrayImages shoes</span><span id="5e1d" class="lf jv hu js b fv lk lh l li lj">collectDamageArrayImages :: DamageArray -&gt; Set Text<br/>collectDamageArrayImages DamageArray {..} = fromList<br/>  [ noDamage<br/>  , someDamage<br/>  , excessiveDamage<br/>  ]</span><span id="7890" class="lf jv hu js b fv lk lh l li lj">collectRockImage :: Rock -&gt; Text<br/>collectRockImage Rock {..} = rockImage</span><span id="d67f" class="lf jv hu js b fv lk lh l li lj">collectWoodenCrateImages :: WoodenCrate -&gt; Set Text<br/>collectWoodenCrateImages WoodenCrate {..} = <br/>  collectDamageArrayImages woodenCrateImage</span></pre><p id="6889" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">代码冗长且有点乏味，但编写或理解起来并不十分困难。我遵守纪律，用一致的方式给每样东西命名，这让我很容易记住。最棘手的部分是记住在我的多态容器上操作时要调用什么帮助函数(所有的<code class="eh jp jq jr js b">maybe</code>和<code class="eh jp jq jr js b">mconcat</code>之类的东西)。</p><h2 id="6820" class="lf jv hu bd jw ll lm ln ka lo lp lq ke jc lr ls ki jg lt lu km jk lv lw kq lx dt translated">世界上所有的财富</h2><p id="0a55" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">下面是用<code class="eh jp jq jr js b">Has</code>类型类模式的变体编写的相同代码:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="bcc0" class="lf jv hu js b fv lg lh l li lj">class HasImages a where<br/>  images :: a -&gt; Set Text</span><span id="f476" class="lf jv hu js b fv lk lh l li lj">instance HasImages a =&gt; HasImages [a] where<br/>  images xs = foldr (\x accum -&gt; images x &lt;&gt; accum) mempty xs</span><span id="6035" class="lf jv hu js b fv lk lh l li lj">instance HasImages a =&gt; HasImages (Maybe a) where<br/>  images x = maybe [] images x</span><span id="40a6" class="lf jv hu js b fv lk lh l li lj">instance (HasImages a, HasImages b) =&gt; HasImages (Either a b) where<br/>  images x = either images images x</span><span id="e662" class="lf jv hu js b fv lk lh l li lj">instance HasImages Scene where<br/>  images <!-- -->Scene {..} <br/>    =  singleton <!-- -->backgroundImage <br/>    &lt;&gt; images<!-- --> <!-- -->characters<br/>    &lt;&gt; <!-- -->images<!-- --> <!-- -->bewilderedTourist<br/>    &lt;&gt; images objects</span><span id="5be3" class="lf jv hu js b fv lk lh l li lj">instance HasImages Character where<br/>  images Character {..} <br/>    =  images hat<br/>    &lt;&gt; images head<br/>    &lt;&gt; images torso<br/>    &lt;&gt; images legs<br/>    &lt;&gt; images shoes</span><span id="a2a5" class="lf jv hu js b fv lk lh l li lj">instance HasImages DamageArray where<br/>  images DamageArray {..} = fromList<br/>    [ noDamage<br/>    , someDamage<br/>    , excessiveDamage<br/>    ]</span><span id="3450" class="lf jv hu js b fv lk lh l li lj">instance HasImages Rock where<br/>  images Rock {..} = singleton rockImage</span><span id="3ff0" class="lf jv hu js b fv lk lh l li lj">instance HasImages WoodenCrate where<br/>  images WoodenCrate {..} = images woodenCrateImage</span></pre><p id="15b5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好的，这是<code class="eh jp jq jr js b">Has</code>类型职业模式的最简单的变体。我们有一个<code class="eh jp jq jr js b">HasImages</code>类型的类，它需要一个函数<code class="eh jp jq jr js b">a -&gt; Set Text</code>，由每个实例来实现。</p><p id="d255" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jp jq jr js b">Has</code>例子和前面例子的第一个区别是我为我的多态容器<code class="eh jp jq jr js b">[]</code>、<code class="eh jp jq jr js b">Maybe</code>和<code class="eh jp jq jr js b">Either</code>实现了通用函数。这种方法的价值在于，我不必考虑调用什么函数来收集图像:它总是<code class="eh jp jq jr js b">images</code>。在前面的例子中，我每次都必须考虑如何收集图像，这需要将脑力更好地用在其他地方。</p><p id="e8ea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jp jq jr js b">Has</code>模式的好处是:</p><ol class=""><li id="1007" class="ly lz hu it b iu iv iy iz jc ma jg mb jk mc jo md me mf mg dt translated">我可以为每个多态容器编写一个单独的实例，它将适用于我需要的所有专门化。</li><li id="b324" class="ly lz hu it b iu mh iy mi jc mj jg mk jk ml jo md me mf mg dt translated">我不需要做太多的决定，这样我就可以腾出脑力专注于其他事情</li><li id="9baf" class="ly lz hu it b iu mh iy mi jc mj jg mk jk ml jo md me mf mg dt translated">它为其他工程师提供了扩展的结构，而不必决定函数的名称和函数的类型(参见第一个例子中的<code class="eh jp jq jr js b">collectRockImage</code>不一致)。</li></ol><p id="b41d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">缺点是:</p><ol class=""><li id="c11f" class="ly lz hu it b iu iv iy iz jc ma jg mb jk mc jo md me mf mg dt translated">它使用类型类，这是一个比函数更复杂的概念。</li></ol><p id="8769" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2.实例声明比函数声明更嘈杂，需要更大的缩进。</p><h1 id="2873" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">用例2:可组合阅读器</h1><p id="a6fe" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated"><code class="eh jp jq jr js b">Has</code>模式也可以用来创建一个可组合的阅读器单子。</p><p id="349c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设您有一个包含以下内容的库A:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="aba0" class="lf jv hu js b fv lg lh l li lj">foo :: Reader Int Bool</span></pre><p id="a6ee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">而库B具有:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="fd42" class="lf jv hu js b fv lg lh l li lj">bar :: Reader String Int</span></pre><p id="e0ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你希望能够写作</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="e193" class="lf jv hu js b fv lg lh l li lj">foobar = do <br/>  flag &lt;- foo<br/>  <br/>  if flag then <br/>    bar<br/>  else<br/>    return 0</span></pre><p id="7017" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是它不会进行类型检查，因为<code class="eh jp jq jr js b">foo</code>需要一个<code class="eh jp jq jr js b">Int</code>环境而<code class="eh jp jq jr js b">bar</code>需要一个<code class="eh jp jq jr js b">String</code>环境。</p><p id="f1af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">诀窍是定义助手<code class="eh jp jq jr js b">Has</code>类型类:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="030b" class="lf jv hu js b fv lg lh l li lj">class HasFooEnv a where<br/>  getFooEnv :: a -&gt; Int</span><span id="bfae" class="lf jv hu js b fv lk lh l li lj">class HasBarEnv a where<br/>  getBarEnv :: a -&gt; String</span></pre><p id="0197" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我们修改类型签名以使用<code class="eh jp jq jr js b">MonadReader</code>:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="fdb9" class="lf jv hu js b fv lg lh l li lj">foo :: (MonadReader e m, HasFooEnv e) =&gt; m Bool</span></pre><p id="101f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将不得不修改对<code class="eh jp jq jr js b">ask</code>的调用来使用<code class="eh jp jq jr js b">asks getFooEnv</code>。我们对<code class="eh jp jq jr js b">bar</code>做一个类似的修改:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="020d" class="lf jv hu js b fv lg lh l li lj">bar :: (MonadReader e m, HasBarEnv e) =&gt; m Int</span></pre><p id="0ce4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">和实例:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="6e36" class="lf jv hu js b fv lg lh l li lj">instance HasFooEnv (Int, String) where<br/>  getFooEnv = fst</span><span id="12ca" class="lf jv hu js b fv lk lh l li lj">instance HasBarEnv (Int, String) where<br/>  getBarEnv = snd</span></pre><p id="713d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们得到组合版本进行类型检查:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="d3e7" class="lf jv hu js b fv lg lh l li lj">foobar :: Reader (Int, String) <br/>foobar = do <br/>  flag &lt;- foo<br/>  <br/>  if flag then <br/>    bar<br/>  else<br/>    return 0</span></pre><p id="bf37" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">迈克尔·斯诺曼也在ReaderT <a class="ae jt" href="https://www.fpcomplete.com/blog/2017/06/readert-design-pattern" rel="noopener ugc nofollow" target="_blank">的一篇文章中讨论了<code class="eh jp jq jr js b">Has</code>模式。</a></p><h1 id="c7e0" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">用例3:方便的参数传递</h1><p id="445a" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">在数据库应用程序中，具有以下类型是很常见的:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="fe6f" class="lf jv hu js b fv lg lh l li lj">newtype Key a = Key UUID<br/>data Entity a = Entity <br/>  { entityKey   :: Key a<br/>  , entityValue :: a<br/>  }</span></pre><p id="8727" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，我们将编写类似如下的查询:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="7c71" class="lf jv hu js b fv lg lh l li lj">getFriends :: Key User -&gt; [Entity User]</span></pre><p id="c381" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过从一个<code class="eh jp jq jr js b">Entity User</code>中提取一个<code class="eh jp jq jr js b">Key User</code>来经常调用它。</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="8881" class="lf jv hu js b fv lg lh l li lj">getFriends (entityKey user)</span></pre><p id="e6a5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以让API更容易使用:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="8fed" class="lf jv hu js b fv lg lh l li lj">class HasKey a k | a -&gt; k where<br/>  key :: a -&gt; Key k</span><span id="3acc" class="lf jv hu js b fv lk lh l li lj">instance HasKey (Key a) a where<br/>  key = id</span><span id="ff3a" class="lf jv hu js b fv lk lh l li lj">instance HasKey (Entity a) a where<br/>  key = entityKey</span><span id="107c" class="lf jv hu js b fv lk lh l li lj">getFriends :: HasKey a User =&gt; a -&gt; [Entity User]</span></pre><p id="695e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在可以传入一个<code class="eh jp jq jr js b">Entity User</code>或<code class="eh jp jq jr js b">Key User</code>。</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="3400" class="lf jv hu js b fv lg lh l li lj">getFriends user</span></pre><p id="7502" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一件小事，但是我以前的一个同事喜欢它，我自己也喜欢它，所以我把它包括在内。更难的错误消息是一个缺点。</p><h1 id="3dec" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">用例4:遍历</h1><p id="9787" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">目前为止我们讨论的是<code class="eh jp jq jr js b">Has</code>的简单版本，只能得到东西。这仅仅是开始。回到我们的第一个例子，假设我们不仅仅是收集图像，我们还想遍历场景并使用图像的散列作为后缀来更新图像文件路径。</p><p id="bf0b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将利用<code class="eh jp jq jr js b">lens</code>包，我们的新<code class="eh jp jq jr js b">HasImages</code>类将看起来像:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="0c71" class="lf jv hu js b fv lg lh l li lj">class HasImages a where<br/>  images :: Traversal' a Text</span></pre><p id="c7f3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的实例看起来像:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="4dfb" class="lf jv hu js b fv lg lh l li lj">instance HasImages a =&gt; HasImages [a] where<br/>  images = traversed . images</span><span id="c605" class="lf jv hu js b fv lk lh l li lj">instance HasImages a =&gt; HasImages (Maybe a) where<br/>  images = traversed . images</span><span id="7b5c" class="lf jv hu js b fv lk lh l li lj">instance (HasImages a, HasImages b) =&gt; HasImages (Either a b) where<br/>  images f e = case e of<br/>    Left  x -&gt; Left  &lt;$&gt; traverseOf images f x<br/>    Right x -&gt; Right &lt;$&gt; traverseOf images f x</span><span id="706e" class="lf jv hu js b fv lk lh l li lj">instance HasImages Scene where<br/>  images f Scene {..} <br/>    =  Scene <br/>   &lt;$&gt; f backgroundImage<br/>   &lt;*&gt; traverseOf images f characters<br/>   &lt;*&gt; traverseOf images f bewilderedTourist<br/>   &lt;*&gt; traverseOf images f objects</span><span id="dea0" class="lf jv hu js b fv lk lh l li lj">instance HasImages Character where<br/>  images f Character {..} <br/>     =  Character<br/>    &lt;$&gt; traverseOf images f hat<br/>    &lt;*&gt; traverseOf images f head<br/>    &lt;*&gt; traverseOf images f torso<br/>    &lt;*&gt; traverseOf images f legs<br/>    &lt;*&gt; traverseOf images f shoes</span><span id="3d7e" class="lf jv hu js b fv lk lh l li lj">instance HasImages DamageArray where<br/>  images f DamageArray {..} <br/>    =  DamageArray<br/>   &lt;$&gt; f noDamage<br/>   &lt;*&gt; f someDamage<br/>   &lt;*&gt; f excessiveDamage</span><span id="e71e" class="lf jv hu js b fv lk lh l li lj">instance HasImages Rock where<br/>  images f Rock {..} <br/>    =  Rock weight <br/>   &lt;$&gt; f rockImage</span><span id="1b10" class="lf jv hu js b fv lk lh l li lj">instance HasImages WoodenCrate where<br/>  images f WoodenCrate {..} <br/>    = WoodenCrate strength <br/>   &lt;$&gt; traverseOf images f woodenCrateImage</span></pre><p id="87d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以像这样应用我们的散列更新器:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="d902" class="lf jv hu js b fv lg lh l li lj">hashFilePath :: Text -&gt; IO Text<br/>hashFilePath filePath = do <br/>  let pathStr = T.unpack filePath<br/>  fileHash &lt;- hashBytes &lt;$&gt; BSL.readFile pathStr<br/>  return $ T.pack $ dropExtension pathStr <br/>         ++ "-" ++ fileHash &lt;.&gt; takeExtension pathStr</span><span id="ea9d" class="lf jv hu js b fv lk lh l li lj">hashSceneImages :: Scene -&gt; IO Scene<br/>hashSceneImages x = traverseOf images hashFilePath x</span></pre><p id="f830" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不仅如此，我们还获得了“免费”的<code class="eh jp jq jr js b">collectImages</code>(尽管性能会有所不同，这可能并不重要)。</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="35bd" class="lf jv hu js b fv lg lh l li lj">collectImages :: Scene -&gt; [Text]<br/>collectImages x = fromList $ toListOf images x</span></pre><h1 id="5b48" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">用例5:可组合状态</h1><p id="142d" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">通过使用简单函数的<code class="eh jp jq jr js b">Lens</code>实例，我们可以获得可组合的状态单子，就像我们获得可组合的读取器单子一样:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="98c9" class="lf jv hu js b fv lg lh l li lj">class HasFooState a where<br/>  fooState :: Lens' a Int</span><span id="8739" class="lf jv hu js b fv lk lh l li lj">class HasBarState a where<br/>  barState :: Lens' a String</span></pre><p id="4404" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我们修改类型签名以使用<code class="eh jp jq jr js b">MonadStates</code>:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="7ca6" class="lf jv hu js b fv lg lh l li lj">foo :: (MonadState s m, HasFooState s) =&gt; m Bool</span></pre><p id="e8a2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将不得不用<code class="eh jp jq jr js b">use fooState</code>交换对<code class="eh jp jq jr js b">get</code>的呼叫，用<code class="eh jp jq jr js b">modifying fooState</code>交换对<code class="eh jp jq jr js b">modify</code>的呼叫，并且<code class="eh jp jq jr js b">put</code>变成<code class="eh jp jq jr js b">assign fooState</code>。我们以类似的方式修改<code class="eh jp jq jr js b">bar</code>:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="79d1" class="lf jv hu js b fv lg lh l li lj">bar :: (MonadReader s m, HasBarState s) =&gt; m Int</span></pre><p id="9c5e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">和实例:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="7865" class="lf jv hu js b fv lg lh l li lj">instance HasFooState (Int, String) where<br/>  fooState = _1</span><span id="67f7" class="lf jv hu js b fv lk lh l li lj">instance HasBarState (Int, String) where<br/>  barState = _2</span></pre><p id="3619" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们把合并后的版本进行类型检查。</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="870c" class="lf jv hu js b fv lg lh l li lj">foobar :: State (Int, String) <br/>foobar = do <br/>  flag &lt;- foo<br/>  <br/>  if flag then <br/>    bar<br/>  else<br/>    return 0</span></pre><h1 id="5f06" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">用例6:可扩展异常</h1><p id="5c82" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">基于<code class="eh jp jq jr js b">Prism</code> s的<code class="eh jp jq jr js b">Has</code>类允许我们用<code class="eh jp jq jr js b">MonadError</code>扩展异常。</p><p id="ff8c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的班级将会是这样的:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="62c0" class="lf jv hu js b fv lg lh l li lj">class HasIdNotFound a where<br/>  _IdNotFound :: Prism a UUID</span></pre><p id="4254" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我们把函数写成这样:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="2edd" class="lf jv hu js b fv lg lh l li lj">foo :: (HasIdNotFound e, MonadError e m) =&gt; m a</span></pre><p id="759f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">并且可以通过调用以下命令抛出我们的异常:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="1c79" class="lf jv hu js b fv lg lh l li lj">throwError $ review _IdNotFound theId</span></pre><p id="3646" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于需要更少实例的更复杂的变体，请看这篇<a class="ae jt" rel="noopener" href="/@jonathangfischoff/prisms-open-unions-and-extendible-exceptions-e71882bb9429">帖子</a>。</p><h1 id="cf6c" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">神奇的选择</h1><p id="d7ce" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">如果你像我一样，你可能想知道是否有什么神奇的方法可以不用做任何工作就能写出<code class="eh jp jq jr js b">collectImages</code>和<code class="eh jp jq jr js b">hashSceneImages</code>。有！我们可以使用<code class="eh jp jq jr js b"><a class="ae jt" href="https://hackage.haskell.org/package/uniplate-1.6.12/docs/Data-Generics-Uniplate-Data.html" rel="noopener ugc nofollow" target="_blank">uniplate</a></code>(或者另一个类似的库)。</p><p id="57a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们需要启用<code class="eh jp jq jr js b">DeriveDataType</code>并为每种类型添加一个<code class="eh jp jq jr js b">deriving (Data)</code>。那么我们的<code class="eh jp jq jr js b">collectImages</code>就变成了:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="a6b1" class="lf jv hu js b fv lg lh l li lj">import Data.Generics.Uniplate.Data</span><span id="9926" class="lf jv hu js b fv lk lh l li lj">collectImages :: Scene -&gt; Set Text<br/>collectImages x = fromList (universeBi x)</span></pre><p id="a63e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">而我们的<code class="eh jp jq jr js b">hashSceneImages</code>现在是:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="5619" class="lf jv hu js b fv lg lh l li lj">hashSceneImages :: Scene -&gt; IO Scene<br/>hashSceneImages x = transformBiM hashFilePath x</span></pre><p id="d65f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种方法的缺点是它不加选择地收集所有的<code class="eh jp jq jr js b">Text</code>值。这不一定是我们想要的(我们可以制造一个<code class="eh jp jq jr js b">newtype ImageFile = ImageFile Text</code>来使它更安全)。另一个缺点是它比自定义遍历类慢。</p><h1 id="81f0" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">结论</h1><p id="b5d6" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">类型类很简单，但是它们可以让你的代码保持良好的结构，并帮助你处理常见的任务。此外，你也许可以用<code class="eh jp jq jr js b">uniplate</code>YOLO它。</p><p id="7e38" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">回购与更完整的例子<a class="ae jt" href="https://github.com/jfischoff/has-type-class-pattern" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><blockquote class="mm mn mo"><p id="d1be" class="ir is mp it b iu iv iw ix iy iz ja jb mq jd je jf mr jh ji jj ms jl jm jn jo hn dt translated"><a class="ae jt" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jt" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jt" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae jt" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is mp it b iu iv iw ix iy iz ja jb mq jd je jf mr jh ji jj ms jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae jt" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae jt" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae jt" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is mp it b iu iv iw ix iy iz ja jb mq jd je jf mr jh ji jj ms jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jt" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jt" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kx ky kz la fq mt"><div class="bz el l di"><div class="mu mv l"/></div></figure></div></div>    
</body>
</html>