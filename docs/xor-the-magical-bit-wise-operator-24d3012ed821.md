# XOR——神奇的按位运算符

> 原文：<https://medium.com/hackernoon/xor-the-magical-bit-wise-operator-24d3012ed821>

![](img/ec9d65b529f846d55eaee9cfb00a04e3.png)

理解位操作提供了解决特定问题的新方法。让我们做一些必要的事情来开始开发这种逐位方法。

在本文中，我们将讨论 XOR 位运算符的神奇力量。

XOR 是一个非常令人惊讶的运算符。你永远无法想象它让我们有可能做的事情。在看到它能做什么之前，让我们修改一下我们可能已经知道的关于操作符的内容。

按位 **XOR ( ^ )** 像其他运算符一样(除了~)也采用两个等长的位模式。如果位模式的比较位置中的两位都是 0 或 1，则结果位模式中的位是 0，否则是 1。

简而言之，这意味着只有在比较的两位中有一位被设置为 1 时，它才返回 1(异或)。
A = 5 = 0101，b = 3 = 0011
a ^ b = 0101 ^ 0011 = 0110 = 6

这是关于异或的基本知识。现在来看看 XOR 运算符都有哪些神通！我想通过之前给出的一些问题来解释一下，有助于你对性质的理解。

# 返回一个数的二进制表示中最右边的 1。

例如:对于 1010，您应该执行一些操作以给出 0010 作为输出。为了 1100，你应该给 0100。同样，对于 0001，您应该返回 0001。

尝试自己寻找解决方案。你得到的最大提示是，你可以使用(^)运算符。完成后，向下滚动。

**解决方案:**

对于这个问题，你需要知道二进制减法的一个性质。检查你是否能在下面的例子中找到属性，

1000 – 0001 = 0111

0100 – 0001 = 0011

1100 – 0001 = 1011

二进制数 n 和 n-1 的区别在于，最右边的 1 右边的所有位都翻转了，包括最右边的 1。利用这个惊人的性质，我们可以得到我们的解决方案

**x ^ (x & (x - 1))**

要完全理解上述解决方案的工作原理，唯一的方法是在一张纸上尝试不同的二进制数。

(如果你有 CS 背景，并且理解我到目前为止所说的话，那么恭喜你！你现在已经知道了 80%的关于一种叫做**芬威克树**或**二进制索引树的强大数据结构。**你可以查阅它来了解这 20%,或者让我知道你是否希望我的下一篇文章是关于它的。)

有意思！不是吗？让我们看看更多的功能。

# **对于给定的数组，每个元素都重复两次，只有一个除外。您需要返回不重复的元素。**

# [1, 2, 5, 4, 6, 8, 9, 2, 1, 4, 5, 8, 9]

可以参考上面的例子。你需要返回 6。

存在线性复杂度的解决方案。

**解决方案:**

这个有点简单。您需要了解以下属性

^ n = 0

^ 0 = n

**算法:**

1.  创建一个值为 0 的变量 v。
2.  从 i = 0 到 i = n-1 迭代数组
3.  执行 v ^ arr[i]并将每次迭代的结果存储在 v 中。
4.  返回。

所以，对于我的最后一个问题，我想给你一个相当具有挑战性的问题。除了上面提到的那些之外，这个不需要使用 XOR 的任何新特性。

# 写一个函数来确定将整数 A 转换成整数 b 所需的位数。

输入:31，14

输出:2

说明:你有 31 (11111)和 14 (01110)。要将 31 转换成 14，我们必须翻转 31 最左边的位和最右边的位。

翻转所需的位数是 2，所以我们返回 2 作为答案。

输入:12，7

输出:3

我建议您在查看下面的解决方案之前尝试实现它。祝你好运！

如果您觉得这对您有任何帮助，那么请喜欢并关注我，了解更多计算机科学方面的精彩见解。

**解决方案:**