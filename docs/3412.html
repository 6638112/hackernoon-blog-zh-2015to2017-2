<html>
<head>
<title>Mutability Leads to Suffering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">易变导致痛苦</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/mutability-leads-to-suffering-23671a0def6a?source=collection_archive---------6-----------------------#2017-03-31">https://medium.com/hackernoon/mutability-leads-to-suffering-23671a0def6a?source=collection_archive---------6-----------------------#2017-03-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="ae61" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可能已经阅读了十几篇关于代码可变性为何不好的清晰、合理的论证。这不是其中之一。相反，我写了一个不清楚的，粗制滥造的论点来解释为什么它不好。</p><p id="7c42" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">可变性是不好的。要理解为什么，我们得说说时间。</p><h1 id="3253" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">谈论时间</h1><p id="e23b" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">对于我们构建的任何系统，我们通常希望它做两件事。首先，它应该有属性:“客户X买了多少个部件？”其次，它应该采取行动:“给X发一封关于小部件销售的电子邮件。”我们将以一种更迟钝的方式开始重述这一点。</p><p id="a5c8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们想象一个极其简单的系统，由一个保存整数的计数器组成。计数器的值组成了系统的<em class="kt">状态</em>，这是对该系统的完美描述。一个动作做了一件事，一定有可衡量的效果。这意味着所有的行为都必须以某种方式改变状态。否则，没有变化的动作和没有动作没有区别。</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="fe ff ku"><img src="../Images/515f18c75487f618f88e551934cb8383.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PWaT7caRKbwmsZs9kMIZgA.png"/></div></div><figcaption class="lg lh fg fe ff li lj bd b be z ek">Some actions</figcaption></figure><p id="3a4e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(现在您可能已经猜到了，属性是不可变的操作，而动作是可变的。)</p><p id="074b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过这样做，我们现在引入了时间。动作前的状态不同于动作后的状态。相反，如果一个系统没有任何动作，那么状态永远不会改变，时间与系统完全无关。这意味着对于任何一种系统来说，<strong class="it hv">可变性等同于时间依赖性</strong>。</p><p id="d8a3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这可能听起来像是“那又怎样”的陈述，但是这是所有与可变性相关的头痛和痛苦的根源。要理解为什么，我们必须谈谈时间依赖。</p><h1 id="8721" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">谈论时间依赖性</h1><p id="006f" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">如果系统是时间相关的，这意味着对于任何给定的初始状态和所采取的行动列表，我们都知道系统在任何给定时间t的确切状态，这里有一些关于这个的“数学”。</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div class="fe ff lk"><img src="../Images/6cb862136532c9b4890d63eea864a488.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*rPzX4DELkzl4tJWGCvC2nA.png"/></div><figcaption class="lg lh fg fe ff li lj bd b be z ek">This doesn’t actually mean anything, I just wanted to play with <a class="ae jp" href="http://asciimath.org/" rel="noopener ugc nofollow" target="_blank">asciimath</a></figcaption></figure><p id="cef0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们如何做到这一点？想象你将计数器增加10次——也就是10次突变。在任何两次突变之间，总有一段时间系统是稳定的，无论是两微秒还是两年。这就产生了11个不同的时间段。我们可以将第一个，即初始状态，标记为从t=0开始，然后随着每一个突变或步骤将t增加1。</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="fe ff ll"><img src="../Images/680896cb14ff9d4b60bc56d139760cbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cuHbGo7hwBhrQffBPPJTDg.png"/></div></div><figcaption class="lg lh fg fe ff li lj bd b be z ek">f(2) = 3</figcaption></figure><p id="02da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于这样一个简单的系统，时间依赖不会引起任何麻烦。每个状态对应一个时间跨度，也就是一个时间值。如果我们运行这个系统，它只会有一个可能的路径。那就好分析了。</p><p id="0154" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我们到达并行系统，一切都崩溃了。</p><h1 id="9560" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">谈论并发性</h1><p id="170f" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">现在想象我们有两个这样的计数器，独立运行。虽然每个都有自己的状态，但我们可以在一个全局状态[C1 | C2]中将它们表示为两个值。我们每增加一次。在t=2时，很明显状态是[1|1]。但是t=1时的值是多少呢？在一个增量和另一个增量之间会有一段时间，所以每个案例代表它自己的一步。但是它可能是[1|0]或[0|1]，所以t=1不是明确定义的。</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="fe ff lm"><img src="../Images/12583b581eea8d1bdc9972c568eeab09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lYIVhOFVIx89aOWCBFiSPQ.png"/></div></div><figcaption class="lg lh fg fe ff li lj bd b be z ek">f(1) = wtf</figcaption></figure><p id="1c1e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">简单的解决办法是增加第二个时间(姑且称之为u ),并且在给定的步骤中只增加t和u中的一个。不是t=2对应[1 1]，而是t=1 u=1对应。那么f(1，0) = [1|0]和f(0，1) = [0|1]，我们又有一个明确定义的时间依赖关系。</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="fe ff lm"><img src="../Images/6c7b45cd795aa9a57004d681df2933b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YNQrYsZPKIyrvlBQpS1_bg.png"/></div></div><figcaption class="lg lh fg fe ff li lj bd b be z ek">f(0, 1) = [0|1]</figcaption></figure><p id="d348" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们给系统添加一个新的操作:复制。复制操作将该值设置为等于另一个系统的计数器。如果t计数器复制，而u计数器增加1，那么系统在f(1，1)的值是多少？</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="fe ff ln"><img src="../Images/57a4879bfbf9a45b2ab5a9f894931b0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yUvODcDSfHSFEhMigPW27A.png"/></div></div><figcaption class="lg lh fg fe ff li lj bd b be z ek">f(1, 1) = #ERR UNDEFINED</figcaption></figure><p id="b704" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为f(1，1)有两个同样有效的值，所以它根本没有定义！状态不再纯粹是t和u的值的函数。现在，步骤的顺序很重要，因为f( <t u="">)可能不是与f( <u t="">)相同的状态。</u></t></p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="fe ff ln"><img src="../Images/0e237e858064332bbd20329e32b62efa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c3Voq55HqsFUH-Xhg2a9uw.png"/></div></div><figcaption class="lg lh fg fe ff li lj bd b be z ek">f(&lt;t, u&gt;) = [0|1]</figcaption></figure><p id="e468" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这让一切都变得很糟糕。</p><p id="1382" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设你有两个系统。t系统变异四次，u系统变异三次。还有(3+4)！这些突变的可能排列，因子为3！和4！变得多余。总共有(3+4)！/(3!4!)= 35种可能的结束状态。它们中的每一个都可能具有完全不同的行为和完全不同的错误，您需要检查它们。如果有两种可能的开始状态，那就是另外35种准备伤害你的行为。</p><p id="12bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是易变性可怕的原因。可变性导致时间依赖，导致并发系统，导致非数值时间，导致状态空间爆炸，导致痛苦。</p><h1 id="0f69" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">避免可变性</h1><p id="e66f" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">对不起，你不能。</p><p id="6636" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个完全不变的系统是独立于时间的。这对某些系统来说是可行的，但是我们关心的大多数事情<strong class="it hv">都是依赖于时间的。例如，我想在死前的某个时候收到我的小部件。</strong></p><p id="cb34" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也就是说，你可以<strong class="it hv">减少</strong>可变性，让它在你的系统中不那么成问题。这里有一些方法可以做到这一点。</p><h2 id="e132" class="lo jr hu bd js lp lq lr jw ls lt lu ka jc lv lw ke jg lx ly ki jk lz ma km mb dt translated">完全消除并发性</h2><p id="e898" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">归根结底，可变性只是并发系统中的一个问题。否则，你只有一种可能的行为，这意味着系统是确定性的，你可以很容易地分析它。</p><p id="9eac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是<em class="kt">同步</em> <a class="ae jp" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank"> <em class="kt">编程</em> </a> <em class="kt">语言</em>背后的想法。一切都与一个单一的全球时钟联系在一起，每一秒钟都在同步变化。构建一个完全同步的系统通常是困难和低效的，但是它们实际上是没有错误的，所以对于关键任务系统来说这是一个好主意。</p><h2 id="c589" class="lo jr hu bd js lp lq lr jw ls lt lu ka jc lv lw ke jg lx ly ki jk lz ma km mb dt translated">纯函数</h2><p id="8b19" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">有时我们不需要突变，但还是要突变。例如，这里有一种测试文件在bash中是否可写的方法:</p><pre class="kv kw kx ky fq mc md me mf aw mg dt"><span id="c833" class="lo jr hu md b fv mh mi l mj mk">function file_writeable() {<br/>  touch file<br/>}</span></pre><p id="cded" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它可以工作，但是1)如果文件不存在，将创建它，2)如果文件存在，将更新访问和修改时间。相反，我们可以做</p><pre class="kv kw kx ky fq mc md me mf aw mg dt"><span id="4658" class="lo jr hu md b fv mh mi l mj mk">function file_writeable() {<br/>  test -w file<br/>}</span></pre><p id="783e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也就是说不会产生突变。我们称之为纯函数。如果我们调用前十次，那就是十个时态步骤。如果我们调用后者十次，那就是零时间步长。显然，我们不能让一切都变得纯粹(时间是个混蛋)，但我们可以去除不必要的变异，这让事情变得更简单。它还使得事务性变异更容易编写，这通常是纯函数的主要好处</p><h2 id="890d" class="lo jr hu bd js lp lq lr jw ls lt lu ka jc lv lw ke jg lx ly ki jk lz ma km mb dt translated">交易性突变</h2><p id="c01d" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">以下面的伪代码为例:</p><pre class="kv kw kx ky fq mc md me mf aw mg dt"><span id="f2f6" class="lo jr hu md b fv mh mi l mj mk">def add_to_cart(cart, items):<br/>    for item in items:<br/>       cart.add(item)</span></pre><p id="4d20" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">根据实现的不同，每个项目最多有一个变异。另一方面，我们可以通过不同的方式将突变的数量减少到一个:</p><pre class="kv kw kx ky fq mc md me mf aw mg dt"><span id="661d" class="lo jr hu md b fv mh mi l mj mk">def add_to_cart(cart, items):<br/>    newcart = cart.clone<br/>    for item in items:<br/>       newcart.add(item)<br/>    cart = newcart</span></pre><p id="02f3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里，购物车只在最后用所有新数据更新一次。我非正式地称这种突变为事务性突变，在这种突变中，你想发生的一切都发生在一个步骤中。这是因为其中最普遍的例子是数据库事务。当你在一个交易中做了一堆突变，要么全部发生，要么一个都不发生。没有并发系统会看到任何中间状态。</p><p id="bf15" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">事务性突变是原子性突变的一个子集，但是我不想深入研究它们，因为我很懒。</p><h2 id="a11c" class="lo jr hu bd js lp lq lr jw ls lt lu ka jc lv lw ke jg lx ly ki jk lz ma km mb dt translated">排他性突变</h2><p id="b6ad" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">到目前为止，我们一直假设动作何时运行是有限制的。如果我们有两个系统，每个系统有一个动作，<a b="">和<b a="">都是可能的。然而，在某些情况下，我们可以设计一切，以便强制排序。作为伪代码示例:</b></a></p><pre class="kv kw kx ky fq mc md me mf aw mg dt"><span id="5b06" class="lo jr hu md b fv mh mi l mj mk">def update:<br/>    set_status("updating")<br/>    # bunch of mutations<br/>    set_status("ready")</span><span id="068f" class="lo jr hu md b fv ml mi l mj mk">def alert:<br/>    wait_until_status("ready")<br/>    # alerting code</span></pre><p id="d7df" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">即使更新是两步，我们唯一的行为是<u1 u2="" a="">和<a u1="" u2="">。因为我们有一个锁，所以我们把三种可能的行为减少到两种。</a></u1></p><h1 id="f501" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">处理可变性</h1><p id="58d3" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">你已经把你的三个四步流程减少到三个两步流程。太好了！你没有35000种可能的行为，而是只有90种。这就是进步！不过，还有90种行为需要检查。你如何确保他们都是安全的？</p><p id="bc68" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样，我们使用了一些不同的技术。第一种是非正式推理，你让团队中的其他人相信这不是问题。在某些情况下，这很简单:如果两个系统互不影响，您可以放心地忽略它们突变的相对顺序。其他情况涉及现实世界的考虑:如果两个系统在非常不同的时间尺度上运行，你可以假设突变的顺序是固定的。问题是，作为人类，我们经常犯错误，所以很容易把危险的情况误认为是安全的，反之亦然。</p><p id="da22" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一个工具是测试和模拟，我们运行代码并确认没有错误。这没有非正式推理那么多人为错误，但是创建适当的并发条件是困难的。测试可以发现很多bug，但是用它覆盖所有东西太贵了。</p><p id="fc2a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还有一个中间地带，叫做<em class="kt">建模</em>。建模包括创建整个系统的抽象表示，并声明所有行为必须遵循的属性。然后，该模型彻底检查状态空间，并确认所有属性都成立。它不像推理那样灵活，也不像好的测试那样真实，但它也比前者更万无一失，比后者更全面。另外，一个好的模型也是文档的一部分——不像实际的文档那样清晰，但是有助于快速浏览。</p><p id="164c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">理想情况下，我们会使用所有三个。在实践中，我们广泛使用非正式推理和测试，但我们并不真正使用建模。我认为这与其说是一个技术问题，不如说是一个社会问题，因为那里有<a class="ae jp" href="http://alloy.mit.edu/alloy/" rel="noopener ugc nofollow" target="_blank">许多</a> <a class="ae jp" href="http://spinroot.com/spin/Man/Manual.html" rel="noopener ugc nofollow" target="_blank">奇妙的</a> <a class="ae jp" href="http://lamport.azurewebsites.net/tla/tla.html" rel="noopener ugc nofollow" target="_blank">建模</a> <a class="ae jp" href="http://www.spark-2014.org/about" rel="noopener ugc nofollow" target="_blank">工具</a>。这只是让他们更容易接近的问题。</p><h1 id="b181" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">TL；博士；医生</h1><ul class=""><li id="85c8" class="mm mn hu it b iu ko iy kp jc mo jg mp jk mq jo mr ms mt mu dt translated">突变本质上不是坏事，但它意味着你的系统是时间相关的。</li><li id="d694" class="mm mn hu it b iu mv iy mw jc mx jg my jk mz jo mr ms mt mu dt translated">依赖于时间的并发系统将时间视为一个序列，而不是一个数字，这显然更难分析。</li><li id="5556" class="mm mn hu it b iu mv iy mw jc mx jg my jk mz jo mr ms mt mu dt translated">虽然消除可变性通常是不可能的，但我们可以通过事务、纯函数和其他技术来减少突变的数量。</li><li id="95eb" class="mm mn hu it b iu mv iy mw jc mx jg my jk mz jo mr ms mt mu dt translated"><a class="ae jp" href="http://www.learntla.com" rel="noopener ugc nofollow" target="_blank">造型很酷，你应该学学。</a></li></ul><p id="9ca8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="kt">你可以</em> <a class="ae jp" href="http://twitter.com/hillelogram" rel="noopener ugc nofollow" target="_blank"> <em class="kt">在Twitter上关注我</em> </a> <em class="kt">但大多是些无意义的笑话和美食图片。</em></p><div class="kv kw kx ky fq ab cb"><figure class="na kz nb nc nd ne nf paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="na kz nb nc nd ne nf paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="na kz nb nc nd ne nf paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ng nh ni"><p id="f922" class="ir is kt it b iu iv iw ix iy iz ja jb nj jd je jf nk jh ji jj nl jl jm jn jo hn dt translated">黑客中午是黑客如何开始他们的下午。我们是这个家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is kt it b iu iv iw ix iy iz ja jb nj jd je jf nk jh ji jj nl jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="fe ff nm"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="kv kw kx ky fq kz"><div class="bz el l di"><div class="nn no l"/></div></figure></div></div>    
</body>
</html>