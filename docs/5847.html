<html>
<head>
<title>Inconsistency as a Feature</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不一致是一个特征</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/inconsistency-as-a-feature-f5f1a28356d4?source=collection_archive---------11-----------------------#2017-08-19">https://medium.com/hackernoon/inconsistency-as-a-feature-f5f1a28356d4?source=collection_archive---------11-----------------------#2017-08-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="9a08" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">下图描绘了几乎每个JS开发者都大量使用的两个最致命的包管理器的标志。</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/252bb6f2e7d3016bb9e3c834bce3f9c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z6AJmlvg7FAUxBv9RbO_Fw.jpeg"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Lethal weapons 2017</figcaption></figure><p id="d1e5" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">通过几个CLI命令，与它们的交互变得简单明了。他们所做的很简单，根据具体的版本为你下载软件包。左边的标志属于<strong class="kb hv"> <em class="kv">鲍尔</em> </strong>，右边的当然属于<strong class="kb hv"> <em class="kv"> npm </em> </strong>。</p><h1 id="7017" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated">体验Bower &amp; npm</h1><p id="4108" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">我使用<strong class="kb hv"> <em class="kv"> bower </em> </strong>已经有一段时间了(1年多了)，因为我从事前端工作，我的体验并不完全愉快。事实上，我认为我讨厌它。另一方面，我们有主要由node.js开发人员使用的包管理器(后端/前端)。这两种我都用过，我都不喜欢，但我认为NPM比鲍尔更糟糕。</p><p id="d4fe" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我与这些包管理器的交互或多或少是相同的，它们甚至有相同的命令，有时会产生不同的结果。例如，在bower中安装一个包(所有特性中最常用的特性)会安装在bower_components中(默认情况下)，但是在npm中它会安装在node_modules中。好吧，不同的名字，谁在乎。诀窍就在每个目录里。Bower将所有的依赖关系都记在一个平面结构中，相反，npm将所有的依赖关系都记在一个层次结构中。这意味着，如果你想要一个依赖项，在你的项目的node_module目录中，你将只有那个依赖项，但是在那个目录中，可能有另一个node_modules目录，它包含你的依赖项的依赖项，这样继续下去…这可能不是一个坏主意，因为你隔离了依赖项，它使你免于麻烦。<strong class="kb hv">在node 4.x.x之前，从版本5.x.x开始，他们也使用扁平结构。</strong></p><p id="fa72" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">小心Windows用户嵌套目录是痛苦的…</p><h2 id="6da5" class="lt kx hu bd ky lu lv lw lc lx ly lz lg ki ma mb li km mc md lk kq me mf lm mg dt translated">版本控制</h2><p id="d357" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">在我工作的一个项目中，我们应该使用语义版本控制，但不是标准形式，而是在开发时使用的形式，即0.Y.Z。然而，我们使用这个X . yβ-Z，其中Z在发布时自动递增。在SemVer中，它声明一个库应该有一个公共API，它是库的接口。那不应该经常改变，对吗？？</p><p id="d953" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">两个<strong class="kb hv">bower</strong>&amp;<strong class="kb hv">NPM</strong>都有相同的怪异的版本解析规则，这允许许多不同的方式来定义你的依赖关系。我真的不知道为什么有人想要一两种以上的方法来解决项目依赖的版本，但无论如何。</p><blockquote class="mh"><p id="e8c2" class="mi mj hu bd mk ml mm mn mo mp mq ku ek translated">最可笑的2个版本不等<strong class="ak"> <em class="mr"> ^ </em> </strong>和<strong class="ak"> <em class="mr"> ~ </em> </strong></p></blockquote><figure class="mt mu mv mw mx jo fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/12bae0a8d1b0ee1087862d8708748d12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*31HeU5SzVHzFowZshgRFLA.png"/></div></figure><p id="35da" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">你不觉得很复杂吗？等待下一次…</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff my"><img src="../Images/4fa2875c883501dc2a64a0bb2228115e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*3NDz_kcJz97-PDZb-VZhag.png"/></div></figure><p id="c5f7" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">简单的任务有太多的规则。我不明白为什么这两种语义对处理版本有用。它们只是让你的生活变得复杂，让你的开发环境不一致。</p><h1 id="bfe1" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated">问题是</h1><p id="1a28" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">如果你正在做一个小项目，使用上面的版本解析规则可能不会遇到任何问题，但是如果你正在做一个非常大的项目，并且多个团队之间有很多依赖关系，那么事情就变得复杂了。<strong class="kb hv">您总是想知道您正在运行的版本</strong>。是<em class="kv"> x.y.z </em>还是<em class="kv"> x.y1.z2 </em>？你需要在每个包内部搜索，以确保你使用的是正确的版本，而不是只看真相应该出现的地方，即<strong class="kb hv"> <em class="kv"> bower.json </em> </strong>或<strong class="kb hv"> <em class="kv"> package.json </em> </strong>。</p><blockquote class="mh"><p id="2df5" class="mi mj hu bd mk ml mm mn mo mp mq ku ek translated">从根本上说，你是在维护一个不一致的系统</p></blockquote><p id="4795" class="pw-post-body-paragraph jz ka hu kb b kc mz iv ke kf na iy kh ki nb kk kl km nc ko kp kq nd ks kt ku hn dt translated">我所说的不一致的系统是指依赖关系可能会在你不知道的情况下从一天到另一天发生变化。当您拥有自动CI构建时，这是非常可能发生的。所以，每次你的依赖项更新时，你都心甘情愿地生成一个不同的系统，而你并不知道。在某种程度上，你创造了一个自动进化的活系统。我不知道这到底是不是一件好事。</p><h2 id="2b1f" class="lt kx hu bd ky lu lv lw lc lx ly lz lg ki ma mb li km mc md lk kq me mf lm mg dt translated"><strong class="ak">示例</strong></h2><p id="dec0" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">您的系统包含:</p><ul class=""><li id="52e2" class="ne nf hu kb b kc kd kf kg ki ng km nh kq ni ku nj nk nl nm dt translated">lib-A.js</li><li id="7326" class="ne nf hu kb b kc nn kf no ki np km nq kq nr ku nj nk nl nm dt translated">图书馆-B.js</li><li id="511d" class="ne nf hu kb b kc nn kf no ki np km nq kq nr ku nj nk nl nm dt translated">ext-lib-C.js</li><li id="9f93" class="ne nf hu kb b kc nn kf no ki np km nq kq nr ku nj nk nl nm dt translated">ext-lib-D.js</li></ul><p id="c34d" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">你在你的所有团队内部维护<strong class="kb hv"> <em class="kv"> lib-A.js </em> </strong>和<strong class="kb hv"> <em class="kv"> lib-B.js </em> </strong>，它们会不断更新，也就是说，每周都会有几个小版本。<strong class="kb hv"> <em class="kv"> ext-lib-C </em> </strong>和<strong class="kb hv"> <em class="kv"> D </em> </strong>是外部的，更新不那么频繁。然后你在你的产品中使用<strong class="kb hv"> A </strong>和<strong class="kb hv"> B </strong>，使用<strong class="kb hv"> <em class="kv"> x.y.* </em> </strong>语义，这样你就安装了微小的改变(在这种情况下<strong class="kb hv"> <em class="kv">可能</em> </strong>包括新的特性)。</p><p id="a9f6" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">所以你有一个包括库的系统，不清楚它们包含什么，也不清楚它们是否正常工作。JavaScript是一种动态语言，除非运行代码，否则很难知道会发生什么。除此之外，缺乏集成测试、功能测试(甚至是E2E测试),你就有了不一致性和系统脆弱性的完美配方。</p><h1 id="c396" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated">优点</h1><ul class=""><li id="3576" class="ne nf hu kb b kc lo kf lp ki ns km nt kq nu ku nj nk nl nm dt translated">你不必关心更新，它们是“自动”完成的。</li></ul><p id="efd9" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我想象不出其他的优点…</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff nv"><img src="../Images/9d8ce7fdc4fd31923b6321d4252b6840.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/1*KvbUdYuOloWz6qFRdQoJPg.gif"/></div></figure><h1 id="c692" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated">问题</h1><ul class=""><li id="2784" class="ne nf hu kb b kc lo kf lp ki ns km nt kq nu ku nj nk nl nm dt translated">您不知道安装了什么，因此不清楚要验证什么。</li><li id="9693" class="ne nf hu kb b kc nn kf no ki np km nq kq nr ku nj nk nl nm dt translated">您可能会遇到难以发现的问题，因为您没有关于已安装内容的良好参考。</li></ul><h1 id="4c6e" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated">结论</h1><p id="30e2" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">可变的包版本控制使得维护和开发系统变得困难，因为它可以在你不知道的情况下随时中断。项目越大，就越难维护它，也越难确保没有什么东西被破坏。总的来说，保持简单，使用特定版本的包，一切都会变得容易得多。</p></div></div>    
</body>
</html>