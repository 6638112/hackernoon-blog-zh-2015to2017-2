<html>
<head>
<title>Share Code between React and React Native Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React和React原生应用之间共享代码</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/code-reuse-using-higher-order-hoc-and-stateless-functional-components-in-react-and-react-native-6eeb503c665?source=collection_archive---------0-----------------------#2017-01-30">https://medium.com/hackernoon/code-reuse-using-higher-order-hoc-and-stateless-functional-components-in-react-and-react-native-6eeb503c665?source=collection_archive---------0-----------------------#2017-01-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/dead590af9ad461a2a6ea3a5eb22e46d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*51Jb-exi2_3YoF2eCwZ3Yw.png"/></div></figure><p id="9887" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">开发人员正在采用高阶组件(HOC)无状态功能组件，这是有充分理由的:它们更容易实现代码重用，这是开发人员梦寐以求的愿望。</p><p id="c103" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">有许多关于特设和功能性无状态组件的文章。一些是介绍，另一些描述深层的技术方面；我将探索重构现有组件来创建可重用的元素。</p><p id="5b50" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">您可能认为代码重用被高估了。或者这太难了，尤其是在web和移动设备之间共享代码的时候。但是这里有一些好处需要考虑:</p><ul class=""><li id="7426" class="jw jx hu ja b jb jc jf jg jj jy jn jz jr ka jv kb kc kd ke dt translated">应用内和设备间的UX一致性</li><li id="5d4d" class="jw jx hu ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke dt translated">进行跨领域升级:改进一个组件并轻松更新其所有用途</li><li id="30c7" class="jw jx hu ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke dt translated">重用路由和授权规则</li><li id="2689" class="jw jx hu ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke dt translated">切换库(例如，下面的应用程序使用<a class="ae kk" href="https://mobx.js.org/" rel="noopener ugc nofollow" target="_blank"> MobX </a>进行状态管理，但是<a class="ae kk" href="http://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>可以交换进来)</li></ul><p id="c897" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我将重点介绍如何使用HOC和功能性无状态组件来实现重用。你应该已经熟悉了<a class="ae kk" href="https://facebook.github.io/react/" rel="noopener ugc nofollow" target="_blank"> React </a>和<a class="ae kk" href="https://facebook.github.io/react-native/" rel="noopener ugc nofollow" target="_blank"> React Native </a>的基础知识。Alexis Mangin 有一篇很好的<a class="ae kk" rel="noopener" href="/@alexmngn/from-reactjs-to-react-native-what-are-the-main-differences-between-both-d6e8e88ebf24#.rsas03guz">文章</a>解释了他们的不同之处。</p><blockquote class="kn ko kp"><p id="e0e0" class="iy iz kq ja b jb jc jd je jf jg jh ji kr jk jl jm ks jo jp jq kt js jt ju jv hn dt translated">帖子里有很多细节；我解释了重构组件的增量过程。但是如果你已经熟悉这些想法(比如HOC)，时间紧迫，或者只是不耐烦，你可以跳到<a class="ae kk" href="#5331" rel="noopener ugc nofollow"> <strong class="ja hv">收益:重用组件</strong> </a>。(<a class="ae kk" href="https://github.com/csepulv/search-box" rel="noopener ugc nofollow" target="_blank"> Final GitHub repo </a>)您可以看到结果，以及使用重用的组件创建额外的应用程序是多么容易。</p></blockquote><h1 id="c825" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">什么是高阶组件和无状态功能组件？</h1><p id="f903" class="pw-post-body-paragraph iy iz hu ja b jb ls jd je jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv hn dt translated">React 0.14引入了无状态功能组件。它们是渲染组件的函数。语法更简单；没有类定义，也没有构造函数。而且顾名思义，没有状态管理(没有使用<code class="eh lx ly lz ma b">setState</code>)。我将在后面对此进行更多的评论，并将示例推迟到本教程的后面。</p><p id="b550" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><a class="kl km gr" href="https://medium.com/u/e986f7cdb458?source=post_page-----6eeb503c665--------------------------------" rel="noopener" target="_blank">科里屋</a>有好介绍<a class="ae kk" href="https://hackernoon.com/react-stateless-functional-components-nine-wins-you-might-have-overlooked-997b0d933dbc#.fxlvlf378" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="5a96" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">高阶组件(HOC)是创建新组件的功能。它们包装另一个组件(或多个组件)，封装被包装的组件。例如，假设您有一个简单的文本框。您希望添加自动完成功能。您可以创建一个特设和使用结果作为一个新的组成部分。</p><pre class="mb mc md me fq mf ma mg mh aw mi dt"><span id="8e24" class="mj kv hu ma b fv mk ml l mm mn">const AutocompleteTextBox = makeAutocomplete(TextBox);<br/>export AutocompleteTextBox;</span><span id="2571" class="mj kv hu ma b fv mo ml l mm mn">//…later</span><span id="cc1a" class="mj kv hu ma b fv mo ml l mm mn">import {AutoCompleteTextBox} from ‘./somefile’;</span></pre><p id="1765" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">脸书文档在这里是<a class="ae kk" href="https://facebook.github.io/react/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank"/>。<a class="kl km gr" href="https://medium.com/u/bbc4c2a3a7ae?source=post_page-----6eeb503c665--------------------------------" rel="noopener" target="_blank"> franleplant </a>也有详细的<a class="ae kk" rel="noopener" href="/@franleplant/react-higher-order-components-in-depth-cf9032ee6c3e#.d1838xba3">帖子</a>。</p><p id="d15e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">一会儿我们将使用特设和无状态功能组件。</p><h1 id="5a88" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">示例应用程序</h1><p id="c947" class="pw-post-body-paragraph iy iz hu ja b jb ls jd je jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv hn dt translated">我们将从一个非常简单的应用程序开始:一个简单的搜索框。输入一个查询，得到一个结果列表。在这种情况下，我们将按名称搜索颜色。</p><p id="33a3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这将是一个屏幕应用程序。它不会使用路线或多个场景，因为重点是组件重用。</p><p id="acc6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们将添加第二对应用程序(React和React Native)，它们将重用我们提取的组件。</p><p id="d1ed" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">该<a class="ae kk" href="https://github.com/csepulv/search-box/tree/baseline-apps" rel="noopener ugc nofollow" target="_blank"> GitHub回购分支</a>有基线申请(最终结果在此为<a class="ae kk" href="https://github.com/csepulv/search-box/" rel="noopener ugc nofollow" target="_blank"/>)。).我在GitHub <a class="ae kk" href="https://github.com/csepulv/search-box/blob/baseline-apps/README.md" rel="noopener ugc nofollow" target="_blank"> README </a>中包含了构建React (web)和React Native (mobile)应用程序的全部细节，但这里有一个大纲:</p><ul class=""><li id="6119" class="jw jx hu ja b jb jc jf jg jj jy jn jz jr ka jv kb kc kd ke dt translated"><a class="ae kk" href="https://github.com/facebookincubator/create-react-app" rel="noopener ugc nofollow" target="_blank">创建-反应-应用</a>启动反应应用</li><li id="886b" class="jw jx hu ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke dt translated">我使用<a class="ae kk" href="http://www.material-ui.com/#/" rel="noopener ugc nofollow" target="_blank">材质UI </a>作为React/web应用中的UI元素</li><li id="4a9f" class="jw jx hu ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke dt translated"><code class="eh lx ly lz ma b"><a class="ae kk" href="https://facebook.github.io/react-native/docs/getting-started.html" rel="noopener ugc nofollow" target="_blank">react-native init</a></code>启动React本地应用程序</li><li id="235b" class="jw jx hu ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke dt translated">我使用<a class="ae kk" href="https://mobx.js.org/" rel="noopener ugc nofollow" target="_blank"> MobX </a>进行状态管理。(<a class="kl km gr" href="https://medium.com/u/de4496bfa1e2?source=post_page-----6eeb503c665--------------------------------" rel="noopener" target="_blank"> Michel Weststrate </a>，Mobx的创造者，有好的教程<a class="ae kk" rel="noopener" href="/@mweststrate/interactive-introduction-to-mobx-and-reactjs-1760e448103c#.vqfntf8r1">在这里</a>和<a class="ae kk" href="https://hackernoon.com/the-fundamental-principles-behind-mobx-7a725f71f3e8#.bg6q97rp9" rel="noopener ugc nofollow" target="_blank">在这里</a>。)</li></ul><p id="12df" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><a class="ae kk" href="https://colors-search-box.firebaseapp.com/" rel="noopener ugc nofollow" target="_blank">https://colors-search-box.firebaseapp.com/</a>是网页版的运行演示。两者的截图如下(网络，然后移动):</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/fa919ac458a37ebd8815f1d63834a156.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*_lHv4QLbnci7XVxXkCbYQw.png"/></div></figure><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff mq"><img src="../Images/4e6875007fc189044d845e3787aa56f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/1*Cj9-EDA6i12vmPWTLQicSw.gif"/></div></figure><h1 id="8812" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">重构以重用</h1><h2 id="30df" class="mj kv hu bd kw mr ms mt la mu mv mw le jj mx my li jn mz na lm jr nb nc lq nd dt translated">实现代码重用与视角有关</h2><p id="279e" class="pw-post-body-paragraph iy iz hu ja b jb ls jd je jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv hn dt translated">代码重用的基础很简单。您从一个代码库中提取方法(或类或组件)，用参数替换包含的值。然后在另一个代码库中使用结果。但是重用元素的价值通常很低，维护共享代码的成本会很高。</p><p id="6742" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我已经通过应用一些指导方针实现了持续的重用:<a class="ae kk" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank">关注点分离</a>，<a class="ae kk" href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="noopener ugc nofollow" target="_blank">单一责任原则</a>，以及<a class="ae kk" href="https://en.wikipedia.org/wiki/Duplicate_code" rel="noopener ugc nofollow" target="_blank">消除重复</a>。</p><p id="0bee" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">关注点分离(SoC)和单一责任原则(SRP)是同一枚硬币的两面；主要思想是给定的代码元素应该有一个主要目的。如果有一个目的，关注点的分离是一个自然的副产品；一个只有一个目的的元素可能不会混合两个责任领域。</p><p id="2e81" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">许多IDE和开发人员工具可以自动合并重复代码。但是消除相似设计中的重复更加困难。您必须“看到”重复，这可能需要重新排列代码块。</p><p id="6add" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">应用这些想法就像移动拼图块，找到它们相遇的地方和它们揭示的模式。</p><p id="65e2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们从寻找重复开始。</p><h2 id="ac93" class="mj kv hu bd kw mr ms mt la mu mv mw le jj mx my li jn mz na lm jr nb nc lq nd dt translated">看到重复</h2><p id="f064" class="pw-post-body-paragraph iy iz hu ja b jb ls jd je jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv hn dt translated">web和移动应用程序有两个主要部分。<br/>在网络应用中，<code class="eh lx ly lz ma b">App.js</code></p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="ne nf l"/></div></figure><p id="8e8b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在移动应用中，<code class="eh lx ly lz ma b">SearchView.js</code></p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="ne nf l"/></div></figure><p id="7a01" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">下面概述了它们的结构。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff ng"><img src="../Images/327237b37c1e4f40342c2c6d90c317be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*BP-vOCbp_qodlz6WxVpUhA.png"/></div><figcaption class="nh ni fg fe ff nj nk bd b be z ek">Almost the same, but the platform differences between React and React Native are in the way.</figcaption></figure><p id="6a2f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这两个组件具有相似的结构。理想情况下，它们将共享组件，如下所示:</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff nl"><img src="../Images/335fcdbefbc9d42eaba4cbd220d71fe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:348/format:webp/1*wWjnBWM-1XYVxqVqXtkNag.png"/></div><figcaption class="nh ni fg fe ff nj nk bd b be z ek">Our goal: a common, shared set of components</figcaption></figure><p id="003e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在伪代码中，</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="ne nf l"/></div></figure><p id="d78f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">然而不幸的是，在这两个应用程序中，几乎没有共同的实际代码。React中使用的组件(本例中为材质UI)与React Native中的组件不同。但是我们可以通过首先分离关注点，然后重构组件，使每个组件都有一个单独的职责，来消除概念上的重复。</p><h2 id="d767" class="mj kv hu bd kw mr ms mt la mu mv mw le jj mx my li jn mz na lm jr nb nc lq nd dt translated">关注点分离和单一责任</h2><p id="402d" class="pw-post-body-paragraph iy iz hu ja b jb ls jd je jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv hn dt translated"><code class="eh lx ly lz ma b">App.js</code>和<code class="eh lx ly lz ma b">SearchView.js</code>都将领域逻辑(我们的应用程序逻辑)与平台实现和库集成混合在一起。如果我们隔离，我们可以改进设计</p><ul class=""><li id="06a0" class="jw jx hu ja b jb jc jf jg jj jy jn jz jr ka jv kb kc kd ke dt translated">UI实现:例如将<code class="eh lx ly lz ma b">ListItem</code>和<code class="eh lx ly lz ma b">ListView</code>从搜索结果的概念中分离出来</li><li id="4c79" class="jw jx hu ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke dt translated">来自状态改变的UX:例如，将提交搜索与更新和显示结果分开</li><li id="6faa" class="jw jx hu ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke dt translated">组件:搜索输入、搜索结果(列表)和单个搜索结果(列表项)都应该是一个单独的组件</li></ul><p id="243f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">最后，重构应该通过自动化测试来完成，以确保在您进行更改时不会出现任何问题。我再补充一些简单的“冒烟”测试，可以在这个<a class="ae kk" href="https://github.com/csepulv/search-box/tree/smoke-tests" rel="noopener ugc nofollow" target="_blank"> GitHub repo/tag </a>中找到。</p><h1 id="fb72" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">提取无状态功能组件</h1><p id="d1b5" class="pw-post-body-paragraph iy iz hu ja b jb ls jd je jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv hn dt translated">让我们从重构时容易和明显的地方开始。React是关于组件的，所以让我们把组件分开。我们将使用无状态的功能组件，因为它们易于阅读。</p><p id="1349" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们可以创建<code class="eh lx ly lz ma b">SearchInput.js</code>如下:</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="ne nf l"/></div></figure><p id="7fc9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">React的本质是一个UI/视图框架，这就是我们现在在这个组件中拥有的。</p><p id="ef52" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">导入的元素只有两个:React(对JSX的要求)和Material UI的<code class="eh lx ly lz ma b">TextField</code>——没有MobX，没有<code class="eh lx ly lz ma b">MuiThemeProvider</code>，没有颜色等等。</p><p id="3c12" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">事件处理被委托给处理程序(作为参数给出)，除了监视<em class="kq"> Enter </em>键的按下。但是这是输入框的实现问题，应该封装在这个组件中。(例如，一个不同的UI小部件库可能包含输入时提交行为。)</p><p id="033d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">继续我们的重构，我们可以创建<code class="eh lx ly lz ma b">SearchResults.js</code>。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="ne nf l"/></div></figure><p id="4401" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">类似于<code class="eh lx ly lz ma b">SearchInput.js</code>，这个无状态的功能组件很简单，只有两个导入。在分离关注点(和SRP)之后，单独搜索结果的组成部分是一个参数<code class="eh lx ly lz ma b">ListItem</code>。</p><blockquote class="kn ko kp"><p id="8d58" class="iy iz kq ja b jb jc jd je jf jg jh ji kr jk jl jm ks jo jp jq kt js jt ju jv hn dt translated">我们可以创建一个更高阶的组件来包装<code class="eh lx ly lz ma b">ListItem</code>。但是由于我们目前使用的是无状态功能组件，我们将推迟使用HOC。(顺便说一下，我们稍后将把<code class="eh lx ly lz ma b">SearchResults.js</code>重构为一个特设。)</p></blockquote><p id="dd49" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">对于单个搜索结果，我们将创建<code class="eh lx ly lz ma b">ColorListItem.js</code></p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="ne nf l"/></div></figure><p id="9566" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，我们需要重构<code class="eh lx ly lz ma b">App.js</code>。</p><h1 id="77bb" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">提取高阶分量</h1><p id="17dc" class="pw-post-body-paragraph iy iz hu ja b jb ls jd je jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv hn dt translated">为了可读性，我们将把<code class="eh lx ly lz ma b">App.js</code>重命名为<code class="eh lx ly lz ma b">SearchBox.js</code>。对于它的重构，我们有几个选择。</p><ol class=""><li id="825f" class="jw jx hu ja b jb jc jf jg jj jy jn jz jr ka jv nm kc kd ke dt translated">让<code class="eh lx ly lz ma b">SearchBox</code>通过<code class="eh lx ly lz ma b">ColorListItem</code>到<code class="eh lx ly lz ma b">SearchResults</code>(作为道具)。</li><li id="3422" class="jw jx hu ja b jb kf jf kg jj kh jn ki jr kj jv nm kc kd ke dt translated">让<code class="eh lx ly lz ma b">index.js</code>将<code class="eh lx ly lz ma b">ColorListItem</code>传递给<code class="eh lx ly lz ma b">SearchBox</code>，后者将把它传递给<code class="eh lx ly lz ma b">SearchResults</code></li><li id="d8aa" class="jw jx hu ja b jb kf jf kg jj kh jn ki jr kj jv nm kc kd ke dt translated">转换到<code class="eh lx ly lz ma b">SearchBox</code>到更高阶组件(HOC)</li></ol><p id="1f41" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">(1)会是这样的:</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="ne nf l"/></div></figure><p id="b4e1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这没有错。这将是提取<code class="eh lx ly lz ma b">SearchInput.js</code>和<code class="eh lx ly lz ma b">SearchResults.js</code>的逻辑结果。但是它将<code class="eh lx ly lz ma b">SearchBox</code>绑定到<code class="eh lx ly lz ma b">ColorListItem</code>(上面的<strong class="ja hv">粗体文本</strong>)，因此违反了关注点分离。(也限制了<code class="eh lx ly lz ma b">SearchResults</code>的复用。)</p><p id="7b84" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">(2)解决了这些问题。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="ne nf l"/></div></figure><p id="cb49" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">(我把属性<code class="eh lx ly lz ma b">colors</code>重命名为<code class="eh lx ly lz ma b">searchStore</code>，让概念和复用性更清晰。)</p><p id="083d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">但如果看它的用法，还得把<code class="eh lx ly lz ma b">ColorListItem</code>当道具传。在<code class="eh lx ly lz ma b">index.js</code>中，我们会有，</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="ne nf l"/></div></figure><p id="9454" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">将其与以下内容进行比较:</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="ne nf l"/></div></figure><p id="d018" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这就是<code class="eh lx ly lz ma b">index.js</code> if (3)，一个特设被使用。区别很微妙，但很重要。<code class="eh lx ly lz ma b">ColorListItem</code>包括<code class="eh lx ly lz ma b">ColorSearchBox</code>，封装了它使用的特定搜索结果组件。</p><p id="e233" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">(这个<code class="eh lx ly lz ma b">searchStore</code>，<code class="eh lx ly lz ma b">Colors</code>，是个道具。应用程序中应该有一个实例，而一个给定的组件可以有多个实例，即<code class="eh lx ly lz ma b">ColorSearchBox</code>。)</p><p id="4226" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">因此，我们可以将<code class="eh lx ly lz ma b">SearchBox.js</code>特设如下。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="ne nf l"/></div></figure><p id="f7fc" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">请注意，<code class="eh lx ly lz ma b">SearchBox.js</code>看起来更像前面章节中的伪代码，<a class="ae kk" href="#ac93" rel="noopener ugc nofollow"> <strong class="ja hv">看到重复</strong> </a>。稍后我们将进一步完善它。</p><h1 id="a935" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">重构反应本机组件</h1><p id="b762" class="pw-post-body-paragraph iy iz hu ja b jb ls jd je jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv hn dt translated">我们可以按照前面的模式重构移动应用程序并提取组件。我就不一一赘述了，比如提取<code class="eh lx ly lz ma b">SearchInput</code>。但它们在<a class="ae kk" href="https://github.com/csepulv/search-box/blob/refactorings/README.md" rel="noopener ugc nofollow" target="_blank">自述</a>中为<a class="ae kk" href="https://github.com/csepulv/search-box/tree/refactorings" rel="noopener ugc nofollow" target="_blank"> GitHub回购分支</a>。</p><p id="1641" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">相反，我将把重点放在对通用<code class="eh lx ly lz ma b">SearchBox</code>的重构上，我们的web (React)和移动(React Native)应用程序都将使用它。</p><h1 id="35b1" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">提取用于Web和移动设备的共享组件</h1><p id="2a07" class="pw-post-body-paragraph iy iz hu ja b jb ls jd je jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv hn dt translated">为了清楚起见，我将<code class="eh lx ly lz ma b">SearchInput.js</code>、<code class="eh lx ly lz ma b">SearchResults.js</code>和<code class="eh lx ly lz ma b">SearchBox.js</code>分别重命名为<code class="eh lx ly lz ma b">WebSearchInput.js</code>、<code class="eh lx ly lz ma b">WebSearchResults.js</code>和<code class="eh lx ly lz ma b">WebSearchBox.js</code>。</p><p id="a43b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们来看看<code class="eh lx ly lz ma b">(Web)SearchBox.js</code></p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="ne nf l"/></div></figure><p id="6e8c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">第2–10、19、20、26、27行是特定于React的。</p><p id="e4e9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><code class="eh lx ly lz ma b">MuiThemeProvider</code>是物料UI组件的容器，是物料UI唯一的直接依赖。但是通过<code class="eh lx ly lz ma b">SearchInput</code>和<code class="eh lx ly lz ma b">SearchResult</code>有隐含的依赖关系。我们可以通过引入一个<code class="eh lx ly lz ma b">SearchFrame</code>组件来分离这些依赖关系。它将封装<code class="eh lx ly lz ma b">MuiThemeProvider</code>并将<code class="eh lx ly lz ma b">SearchInput</code>和<code class="eh lx ly lz ma b">SearchResults</code>呈现为子对象。然后我们可以创建一个新的<code class="eh lx ly lz ma b">SearchBox</code> HOC。它将使用<code class="eh lx ly lz ma b">SearchFrame</code>、<code class="eh lx ly lz ma b">SearchResults</code>和<code class="eh lx ly lz ma b">SearchInput</code>。</p><p id="79ce" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">创建新的<code class="eh lx ly lz ma b">SearchBox.js</code></p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="ne nf l"/></div></figure><p id="22a3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这看起来就像我们从<a class="ae kk" href="#ac93" rel="noopener ugc nofollow"> <strong class="ja hv">看到复制</strong> </a>的伪代码。</p><p id="db4c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，将<code class="eh lx ly lz ma b">WebSearchBox.js</code>的内容改为</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="ne nf l"/></div></figure><p id="a4cd" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><code class="eh lx ly lz ma b"><strong class="ja hv">WebSearchBox</strong></code>(第26行)是使用<code class="eh lx ly lz ma b">SearchBox</code> HOC的结果。</p><blockquote class="kn ko kp"><p id="2052" class="iy iz kq ja b jb jc jd je jf jg jh ji kr jk jl jm ks jo jp jq kt js jt ju jv hn dt translated"><code class="eh lx ly lz ma b">children</code>是一种特殊的反应道具。在我们的例子中，它允许<code class="eh lx ly lz ma b">WebSearchFrame</code>包含/渲染<code class="eh lx ly lz ma b">WebSearchInput</code>和<code class="eh lx ly lz ma b">WebSearchResults</code>，这是由<code class="eh lx ly lz ma b">SearchBox</code>提供的参数。更多关于儿童道具的信息可以在<a class="ae kk" href="https://facebook.github.io/react/docs/composition-vs-inheritance.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></blockquote><p id="b0aa" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们还将把<code class="eh lx ly lz ma b">WebSearchResults</code>改为特设。它应该封装<code class="eh lx ly lz ma b">ListItem</code>作为特设组合的一部分。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="ne nf l"/></div></figure><p id="7607" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们现在有了一套可重用的组件。(这里是<a class="ae kk" href="https://github.com/csepulv/search-box/tree/refactorings" rel="noopener ugc nofollow" target="_blank"> GitHub回购/分支</a>。注意，为了清楚起见，一些目录被重新命名。)</p><h1 id="5331" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">回报是:重用组件</h1><p id="b370" class="pw-post-body-paragraph iy iz hu ja b jb ls jd je jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv hn dt translated">我们将创建GitHub知识库搜索应用程序。(GitHub允许在没有API密钥的情况下使用API，这对于本教程来说很方便。)</p><p id="e224" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我将跳过引导的细节，但这里有一个总结</p><ul class=""><li id="498a" class="jw jx hu ja b jb jc jf jg jj jy jn jz jr ka jv kb kc kd ke dt translated">web应用程序的创建-反应-应用程序，移动应用程序的<code class="eh lx ly lz ma b">react-native init</code></li><li id="543f" class="jw jx hu ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke dt translated">添加这些模块:MobX、Material UI(仅web)、<a class="ae kk" href="https://www.npmjs.com/package/qs" rel="noopener ugc nofollow" target="_blank"> qs </a>(用于查询字符串编码)……在各自项目中的<code class="eh lx ly lz ma b">package.json</code>细节(<a class="ae kk" href="https://github.com/csepulv/search-box/blob/master/github-mobile/package.json" rel="noopener ugc nofollow" target="_blank"> web </a>和<a class="ae kk" href="https://github.com/csepulv/search-box/blob/master/github-mobile/package.json" rel="noopener ugc nofollow" target="_blank"> mobile </a>)</li></ul><p id="e73b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">大部分工作是编写一个新的搜索商店。它通过GitHub API搜索GitHub库，而不是颜色。我们可以创造<code class="eh lx ly lz ma b">github.js</code></p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="ne nf l"/></div></figure><p id="971e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">(它的单元测试是<a class="ae kk" href="https://github.com/csepulv/search-box/blob/master/github-web/src/github.test.js" rel="noopener ugc nofollow" target="_blank">这里的</a>。)</p><blockquote class="kn ko kp"><p id="d3cc" class="iy iz kq ja b jb jc jd je jf jg jh ji kr jk jl jm ks jo jp jq kt js jt ju jv hn dt translated">为了简单起见，我们将复制一些公共文件。GitHub repo使用<a class="ae kk" href="https://webpack.github.io/" rel="noopener ugc nofollow" target="_blank"> webpack </a>来复制文件，这是一个小小的便利改进。跨Javascript项目共享文件/模块通常由NPM或鲍尔完成。(你可以<a class="ae kk" href="https://www.npmjs.com/pricing" rel="noopener ugc nofollow" target="_blank">为<a class="ae kk" href="https://docs.npmjs.com/private-modules/intro" rel="noopener ugc nofollow" target="_blank">私有模块</a>注册支付</a>。)你也可以使用<a class="ae kk" href="https://git-scm.com/book/en/v2/Git-Tools-Submodules" rel="noopener ugc nofollow" target="_blank"> Git子模块</a>，尽管它们可能很笨重。因为我们的重点是组件重用而不是模块发布，所以我们将做一些简单的事情，复制文件。)</p></blockquote><p id="ec17" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">剩下的就简单了。删除<code class="eh lx ly lz ma b">App.js</code>(和<code class="eh lx ly lz ma b">App.test.js</code>)并将<code class="eh lx ly lz ma b">index.js</code>的内容替换为</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="ne nf l"/></div></figure><p id="3b68" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果你使用github-web应用程序，你应该会看到</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/b26664af675664e7efb87a66693ff405.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*0G_2A4nHLILkixI36C71Rg.gif"/></div></figure><p id="563d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">(也可以去<a class="ae kk" href="https://github-repo-search-box.firebaseapp.com" rel="noopener ugc nofollow" target="_blank">https://github-repo-search-box.firebaseapp.com</a>看现场版。)</p><h1 id="f26b" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">React Native: GitHub移动应用</h1><p id="6bf2" class="pw-post-body-paragraph iy iz hu ja b jb ls jd je jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv hn dt translated">复制<code class="eh lx ly lz ma b">github.js</code>和<code class="eh lx ly lz ma b">MobileSearch*.js</code>文件，然后创建<code class="eh lx ly lz ma b">GitHubMobileSearchBox.js</code></p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="ne nf l"/></div></figure><p id="a7e4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">并将<code class="eh lx ly lz ma b">index.ios.js</code>内容更改为</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="ne nf l"/></div></figure><p id="82fe" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">两个文件，新手机app。<code class="eh lx ly lz ma b">react-native run-ios</code></p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/f86710aad61be8ee42d1e588869176fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*Gmy46gNeM8AsOvXvbUdDYQ.gif"/></div></figure><p id="7dc7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们可能很努力地进行重构，但是重用组件来构建两个新的应用程序是很容易的。</p><h1 id="30f4" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">回顾和总结</h1><p id="c36c" class="pw-post-body-paragraph iy iz hu ja b jb ls jd je jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv hn dt translated">让我们看一下我们的组件图:</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="no np di nq bf nr"><div class="fe ff nn"><img src="../Images/ed9518e2ee81646c80c25da8d932ef6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OGj-8vjSpIkEFO6it0FX_A.png"/></div></div><figcaption class="nh ni fg fe ff nj nk bd b be z ek">box icon is from <a class="ae kk" href="https://thenounproject.com/" rel="noopener ugc nofollow" target="_blank">thenounproject.com</a>, courtesy of <a class="ae kk" href="https://thenounproject.com/trellva25/" rel="noopener ugc nofollow" target="_blank">Tinashe Mugayi</a></figcaption></figure><p id="d6b6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">很高兴看到重构有了回报。我们可以专注于新应用程序的特定领域逻辑。我们只需要定义GitHub API客户端以及如何呈现存储库结果。剩下的是“免费”的。</p><p id="79e7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">此外，我们的组件不必处理异步问题。例如，他们对<code class="eh lx ly lz ma b">github.js</code>中的异步获取调用一无所知。这是我们重构方法以及我们如何利用无状态功能组件的<strong class="ja hv">美妙的</strong>好处之一。承诺和异步编程只发生在它需要的地方，<code class="eh lx ly lz ma b">github.js</code>，也就是发出<code class="eh lx ly lz ma b">fetch</code>调用的地方。</p><p id="62e1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在您应用这些技术几次之后，提取组件并重用它们将变得更加容易。您甚至可以在一个新的视图元素的开头编写一个可重用的组件，因为模式已经成为编码中的一种规范。</p><p id="2551" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">此外，我鼓励研究像<a class="ae kk" href="https://github.com/acdlite/recompose" rel="noopener ugc nofollow" target="_blank"> recompose </a>这样的库，这使得编写hoc更容易。</p><p id="925b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">看看最后的<a class="ae kk" href="https://github.com/csepulv/search-box/" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>，让我知道它是如何重构可重用组件的。</p><p id="7a28" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">请♡这个帖子，并关注我的更新，在媒体上，或在<a class="ae kk" href="http://twitter.com/csepulv" rel="noopener ugc nofollow" target="_blank"> twitter </a> ( <a class="ae kk" href="http://twitter.com/csepulv" rel="noopener ugc nofollow" target="_blank"> csepulv </a>)上。</p><blockquote class="kn ko kp"><p id="f922" class="iy iz kq ja b jb jc jd je jf jg jh ji kr jk jl jm ks jo jp jq kt js jt ju jv hn dt translated"><a class="ae kk" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kk" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kk" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae kk" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="iy iz kq ja b jb jc jd je jf jg jh ji kr jk jl jm ks jo jp jq kt js jt ju jv hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kk" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kk" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="mb mc md me fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="no np di nq bf nr"><div class="fe ff ns"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>