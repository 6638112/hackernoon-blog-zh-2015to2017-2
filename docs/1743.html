<html>
<head>
<title>How I Used Proxy to Implement Lazy Infinite Lists in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何使用代理在JavaScript中实现惰性无限列表</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-i-used-proxy-to-implement-lazy-infinite-lists-in-javascript-5e86879b44d6?source=collection_archive---------2-----------------------#2016-12-04">https://medium.com/hackernoon/how-i-used-proxy-to-implement-lazy-infinite-lists-in-javascript-5e86879b44d6?source=collection_archive---------2-----------------------#2016-12-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="bb2b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本文中，我将展示一个延迟评估的<a class="ae jp" href="https://en.wikipedia.org/wiki/Linked_list" rel="noopener ugc nofollow" target="_blank">链表</a>数据结构的JavaScript ES6实现。递归定义的链表是许多函数式<a class="ae jp" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>语言中重要的集合类型。在启发了这个项目的<a class="ae jp" href="https://haskell-lang.org/" rel="noopener ugc nofollow" target="_blank"> Haskell语言</a>中，<a class="ae jp" href="https://en.wikibooks.org/wiki/Haskell/Lists_and_tuples" rel="noopener ugc nofollow" target="_blank">列表数据类型</a>填充了数组在<a class="ae jp" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>中所扮演的角色。因为这个列表类型是使用<a class="ae jp" href="https://en.wikipedia.org/wiki/Recursion_(computer_science)" rel="noopener ugc nofollow" target="_blank">递归</a>定义的，所以可以按需生成和评估列表元素，而不是在列表创建时(这是“懒惰”的部分)，从而使得无限列表不仅可行，而且相对简单。</p><p id="1c18" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我依靠来自<a class="ae jp" href="http://www.ecma-international.org/ecma-262/6.0/" rel="noopener ugc nofollow" target="_blank"> ES2015 </a>(又名ES6)的新<code class="eh jq jr js jt b"><a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" rel="noopener ugc nofollow" target="_blank">Proxy</a></code> API作为一种间接方式，在JavaScript中生成有限和无限范围列表。<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator" rel="noopener ugc nofollow" target="_blank">生成器</a>也在这里出现，所以这是一个很好的机会来探索和实际使用该语言的一些最新扩展，同时学习更多关于函数式编程的知识(我在之前的文章中更明确地讨论了这个主题)。这里展示的代码改编自我的<a class="ae jp" href="https://www.npmjs.com/package/lazy-linked-lists" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">懒惰链表</strong> </a> npm模块。完整的库可以在<a class="ae jp" href="https://github.com/sjsyrek/lazy-linked-lists" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上开源获得，而且，由于我们正在探索懒惰，我将本文中专门使用的示例代码放在一个单独的<a class="ae jp" href="https://gist.github.com/sjsyrek/3fb2fa03797ae0e89426b484ca8a6dcf" rel="noopener ugc nofollow" target="_blank"> GitHub Gist </a>中。</p><p id="299d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你还没有看<code class="eh jq jr js jt b">Proxy</code>，它将会颠覆你的世界。这是不是一件好事取决于你的观点。和它的对手<code class="eh jq jr js jt b"><a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect" rel="noopener ugc nofollow" target="_blank">Reflect</a></code>，<code class="eh jq jr js jt b">Proxy</code>一起，带来了全范围的<a class="ae jp" href="https://en.wikipedia.org/wiki/Metaprogramming" rel="noopener ugc nofollow" target="_blank">元编程</a>能力，承载着人类最多产的编程语言。顾名思义，<em class="ju">元编程</em>需要编写能够自我检查和修改的代码。换句话说，它是抽象层次中“上一层”的编程，或者说是编程本身的编程。</p><p id="1dc7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">函数式程序员可能会认为这种语义上的混乱是一种诅咒，这仅仅是语言设计失败的可能证据。如果函数式编程最大的优点是引用透明，那么<code class="eh jq jr js jt b">Proxy</code>就可以任意混淆。尽管以前版本的JavaScript允许您在一定程度上进行元编程，但ES2015规范通过使其成为一等公民而将这种能力置于前沿和中心。不管这是不是编程语言<em class="ju">应该</em>拥有的能力(例如<a class="ae jp" href="https://en.wikipedia.org/wiki/Brendan_Eich" rel="noopener ugc nofollow" target="_blank"> Brendan Eich </a>认为<a class="ae jp" href="https://www.youtube.com/watch?v=sClk6aB_CPk" rel="noopener ugc nofollow" target="_blank">代理很棒</a>)，讽刺的是，它给了我们这些来自函数世界的人一些额外的能力，可以更容易地将我们最喜欢的语言习惯用法嵌入JavaScript。</p><p id="56ba" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jq jr js jt b">Proxy</code> API提供了拦截正在运行的应用程序的普通进程的方法。这是通过将一个目标对象与<em class="ju">代表其</em>的另一个对象相关联来实现的，即作为<em class="ju">代理</em>。反过来，代理对象通过在指定的“处理程序”对象上定义的方法或“陷阱”来过滤目标对象上的传入操作。例如，您可以<em class="ju">捕捉</em>试图<code class="eh jq jr js jt b">get</code>一个对象的属性值:</p><pre class="jv jw jx jy fq jz jt ka kb aw kc dt"><span id="7595" class="kd ke hu jt b fv kf kg l kh ki"><strong class="jt hv">class</strong> Secret {<br/>  <strong class="jt hv">constructor</strong>(msg) { <strong class="jt hv">this</strong>.info = msg }<br/>}<br/><br/><strong class="jt hv">let</strong> handler = {<br/>  get: (target, prop) =&gt;<br/>    prop === "info" ? "Too many secrets" : target[prop]<br/>}<br/><br/><strong class="jt hv">let</strong> makeSecret = msg =&gt; <strong class="jt hv">new</strong> Proxy(<strong class="jt hv">new</strong> Secret(msg), handler)<br/><br/><strong class="jt hv">let</strong> s1 = <strong class="jt hv">new</strong> Secret("Confidential information")</span><span id="bce6" class="kd ke hu jt b fv kj kg l kh ki"><strong class="jt hv">let</strong> s2 = makeSecret("More confidential information")<br/><br/>s1.info <em class="ju">// "Confidential information"</em></span><span id="b818" class="kd ke hu jt b fv kj kg l kh ki">s2.info <em class="ju">// "Too many secrets"</em></span></pre><p id="856d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个简单的例子中，我们有一个名为<code class="eh jq jr js jt b">Secret</code>的小包装器类，作为我们可能用来隐藏敏感信息的对象的原型。我们可以提供一个定制的构造函数，而不是将类本身暴露给API的用户。这样做允许我们定制<code class="eh jq jr js jt b">Secret</code>在特定环境下的行为方式。这里，<code class="eh jq jr js jt b">makeSecret</code>函数并不返回新的<code class="eh jq jr js jt b">Secret</code>对象本身，而是返回一个代理对象来代表它。可以说，所有指向给定<code class="eh jq jr js jt b">Secret</code>的“消息”都将首先通过各自的代理。我们可以捕获所有、部分或不捕获这些消息。<code class="eh jq jr js jt b">Secret</code>代理仅捕获试图读取或<code class="eh jq jr js jt b">get</code>属性<code class="eh jq jr js jt b">info</code>的值。事实上，所有读取<code class="eh jq jr js jt b">Secret</code>属性的尝试都会被拦截，因为handler对象定义了一个<code class="eh jq jr js jt b">get</code>方法。但是该方法的逻辑只干涉获取<code class="eh jq jr js jt b">info</code>属性的请求。代理没有返回那个值，而是返回一个规定的缺省值(这个值是20世纪90年代间谍活动的狂热爱好者所钟爱的)。当然，你会注意到，这并不是一个完全可靠的数据隐藏机制，但是一个更有野心的程序，也许是一个实现了<a class="ae jp" href="http://soft.vub.ac.be/~tvcutsem/invokedynamic/js-membranes" rel="noopener ugc nofollow" target="_blank">膜</a>的程序，当然可以使用<code class="eh jq jr js jt b">Proxy</code>来实现这个目的。</p><p id="dffa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以应用同样的技术为任意长度的链表创建一个函数接口。既然我们在ES6领域，让我们从为列表类型定义一个简单的类开始:</p><pre class="jv jw jx jy fq jz jt ka kb aw kc dt"><span id="d62e" class="kd ke hu jt b fv kf kg l kh ki"><strong class="jt hv">class</strong> List {<br/>  <strong class="jt hv">constructor</strong> (x, xs) {<br/>    <strong class="jt hv">this</strong>.head = () =&gt; x<br/>    <strong class="jt hv">this</strong>.tail = () =&gt; xs<br/>  }<br/>}</span></pre><p id="763e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将是一个相当简单的函数数据结构。<code class="eh jq jr js jt b">List</code>的构造函数将一个值<code class="eh jq jr js jt b">x</code>作为一个新列表对象的第一个元素或头部，将另一个列表<code class="eh jq jr js jt b">xs</code>作为尾部，或<em class="ju">作为列表</em>的其余部分。如果您熟悉链表的底层实现，您可以将list对象视为一个由两个单元组成的节点:头部是节点的值(或标签)，尾部是指向下一个节点的指针。任何给定列表中的最后一个值总是空列表。<code class="eh jq jr js jt b">head</code>和<code class="eh jq jr js jt b">tail</code>属性被定义为返回函数而不是原始值，这与函数范式一致，也是对篡改的一种轻微保护。想象它们不是空函数，而是应用于它们的参数的等价恒等函数(如果你要参数化那个恒等函数，你会有一个<a class="ae jp" href="http://stackoverflow.com/questions/44965/what-is-a-monad" rel="noopener ugc nofollow" target="_blank">单子</a>，但是我保证我不会在本文中讨论单子)。</p><p id="940b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">事实上，整个<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/class" rel="noopener ugc nofollow" target="_blank">类声明</a>只是一种特殊的函数。尽管关于OOP概念的有用性还有争论，但是ES6类确实拥有一个我们可以利用的显著属性:你不能直接调用它们作为函数。定义为类的对象只能用<code class="eh jq jr js jt b">new</code>关键字构造；然后，类<code class="eh jq jr js jt b">constructor</code>函数确保<code class="eh jq jr js jt b">new</code>做正确的事情。尽管关于<code class="eh jq jr js jt b">new</code>本身的适当性还有争论，但是这个属性允许我们隐藏类声明(例如，通过不导出它)并提供我们自己的定制构造函数。在某种程度上，我们使用了JavaScript中最有争议的语法。下面是我们<em class="ju">想要导出的接口所需的代码:</em></p><pre class="jv jw jx jy fq jz jt ka kb aw kc dt"><span id="a255" class="kd ke hu jt b fv kf kg l kh ki"><strong class="jt hv">const</strong> emptyList = <strong class="jt hv">new</strong> List()<br/><br/><strong class="jt hv">const</strong> isEmpty = xs =&gt; xs === emptyList<br/><br/><strong class="jt hv">const</strong> cons = (x, xs) =&gt; <strong class="jt hv">new</strong> List(x, xs)<br/><br/><strong class="jt hv">const</strong> list = (...as) =&gt;<br/>  as.length === 0 ? emptyList : <strong class="jt hv">new</strong> List(as.shift(), list(...as))<br/><br/><strong class="jt hv">const</strong> head = xs =&gt; {<br/>  <strong class="jt hv">if</strong> (isEmpty(xs)) { <strong class="jt hv">throw</strong> Error('EmptyListError') }<br/>  <strong class="jt hv">return</strong> xs.head()<br/>}<br/><br/><strong class="jt hv">const</strong> tail = xs =&gt; {<br/>  <strong class="jt hv">if</strong> (isEmpty(xs)) { <strong class="jt hv">throw</strong> Error('EmptyListError') }<br/>  <strong class="jt hv">return</strong> xs.tail()<br/>}</span></pre><p id="f9f0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Haskell中，列表是一个需要两个构造函数的<a class="ae jp" href="https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/sum-types" rel="noopener ugc nofollow" target="_blank"> sum类型</a>:一个创建空列表，另一个递归地从一个值(头部)和“更多列表”(尾部)创建一个新列表。因为JavaScript没有sum类型，所以上面的实现有点草率。但这很有效。对象只是一个符号占位符。它不向<code class="eh jq jr js jt b">List</code>传递任何参数，所以空列表的头部和尾部都是<code class="eh jq jr js jt b">undefined</code>。既然我们无论如何都不希望直接调用<code class="eh jq jr js jt b">List</code>构造函数，这没问题:在我们的程序中，所有情况下只有一个空列表，它被构造一次且只有一次，它就是<code class="eh jq jr js jt b">emptyList</code>。我们还提供了一个检查列表是否为空的函数，这是递归和基本情况下经常需要的。</p><p id="8c69" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一个构造者是<code class="eh jq jr js jt b">cons</code>。<code class="eh jq jr js jt b">cons</code>和它包装的<code class="eh jq jr js jt b">List</code>类一样，<em class="ju"> cons </em>从一个值<code class="eh jq jr js jt b">x</code>和另一个列表<code class="eh jq jr js jt b">xs</code>构造一个新列表。<code class="eh jq jr js jt b">x</code>前置到<code class="eh jq jr js jt b">xs</code>上。如果<code class="eh jq jr js jt b">xs</code>是空列表，那么<code class="eh jq jr js jt b">cons</code>简单地创建一个新的单元素列表。显然，这里有滥用的机会，更全面的<code class="eh jq jr js jt b">cons</code>实现将验证甚至可能类型检查<code class="eh jq jr js jt b">x</code>。你也可以创建一个<a class="ae jp" href="https://github.com/sjsyrek/maryamyriameliamurphies.js/tree/master/source/list" rel="noopener ugc nofollow" target="_blank">咖喱版本</a>，并使其真正功能化，但出于解释的目的，我试图尽可能省略掉更多的噪音。</p><p id="5678" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里的<code class="eh jq jr js jt b">list</code>函数是为了方便，因为我们不能为声明多个元素的列表创建自己的语法糖。<code class="eh jq jr js jt b">list</code>获取零个或多个参数，并递归地使用它们，直到参数数组(由rest操作符干净地提供，另一个ES6特性)为空，此时它到达<code class="eh jq jr js jt b">emptyList</code>作为基本情况。函数调用<code class="eh jq jr js jt b">list(1,2,3)</code>相当于<code class="eh jq jr js jt b">cons(1, cons(2, cons(3, emptyList)))</code>。<code class="eh jq jr js jt b">head</code>和<code class="eh jq jr js jt b">tail</code>是那些各自属性的存取函数。正如在<a class="ae jp" href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html" rel="noopener ugc nofollow" target="_blank"> Haskell Prelude </a>中一样，它们是<a class="ae jp" href="https://wiki.haskell.org/Partial_functions" rel="noopener ugc nofollow" target="_blank">部分函数</a>，这并不理想，但同样，它们将足以用于演示目的。</p><p id="8436" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为JavaScript只是将我们的列表当作对象，所以我们想要一种很好地打印列表值的方法。所以让我们添加一个定制的<code class="eh jq jr js jt b">valueOf</code>方法:</p><pre class="jv jw jx jy fq jz jt ka kb aw kc dt"><span id="1468" class="kd ke hu jt b fv kf kg l kh ki"><strong class="jt hv">class</strong> List {<br/>  <strong class="jt hv">constructor</strong>(x, xs) {<br/>    <strong class="jt hv">this</strong>.head = null<br/>    <strong class="jt hv">this</strong>.tail = null<br/>    <strong class="jt hv">this</strong>.head = () =&gt; x<br/>    <strong class="jt hv">this</strong>.tail = () =&gt; xs<br/>  }<br/>  valueOf() {<br/>    <strong class="jt hv">let</strong> value = xs =&gt;<br/>      isEmpty(xs) ? `[]` : `${head(xs)}:${value(tail(xs))}`<br/>    <strong class="jt hv">return</strong> isEmpty(<strong class="jt hv">this</strong>) ? `[]` : `[${value(<strong class="jt hv">this</strong>)}]`<br/>  }<br/>}</span></pre><p id="c607" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，当我们显示列表值时，我们得到了一些相当清晰的东西:</p><pre class="jv jw jx jy fq jz jt ka kb aw kc dt"><span id="3ca3" class="kd ke hu jt b fv kf kg l kh ki"><strong class="jt hv">let</strong> lst1 = list(1,2,3,4,5)</span><span id="e1c4" class="kd ke hu jt b fv kj kg l kh ki">lst1.valueOf() <em class="ju">// [1:2:3:4:5:[]]</em><br/><br/><strong class="jt hv">let</strong> lst2 = cons(0, lst1)</span><span id="5597" class="kd ke hu jt b fv kj kg l kh ki">lst2.valueOf() <em class="ju">// [0:1:2:3:4:5:[]]<br/></em><br/><strong class="jt hv">let</strong> lst3 = cons(0, cons(1, cons(2, cons(3, cons(4, cons(5, emptyList))))))</span><span id="5e35" class="kd ke hu jt b fv kj kg l kh ki">lst3.valueOf() <em class="ju">// [0:1:2:3:4:5:[]]</em><br/><br/>head(lst1) <em class="ju">// 1</em></span><span id="1c2d" class="kd ke hu jt b fv kj kg l kh ki">tail(lst2).valueOf() <em class="ju">// [1:2:3:4:5:[]]</em></span><span id="5efa" class="kd ke hu jt b fv kj kg l kh ki">isEmpty(tail(tail(tail(tail(tail(lst1)))))) <em class="ju">// true</em></span></pre><p id="9ffd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我使用冒号而不是逗号来避免与数组混淆，并使它的结构更明显和更Haskell-y，但显然您可以按您想要的方式打印列表值(并查看:<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" rel="noopener ugc nofollow" target="_blank"> ES6模板文字</a>！).在这些例子中使用<code class="eh jq jr js jt b">valueOf</code>只有在你的REPL默认不打印对象属性时才有必要(当<a class="ae jp" href="https://nodejs.org/dist/latest-v7.x/docs/api/repl.html#repl_default_evaluation" rel="noopener ugc nofollow" target="_blank">节点</a>可以打印时，它会打印，但浏览器控制台不会)。</p><p id="dcd7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">ES6现在让我们实现的另一个很好的便利是使用生成器和所谓的"<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol" rel="noopener ugc nofollow" target="_blank">众所周知的符号</a>，"<code class="eh jq jr js jt b">Symbol.iterator</code>:</p><pre class="jv jw jx jy fq jz jt ka kb aw kc dt"><span id="c467" class="kd ke hu jt b fv kf kg l kh ki"><strong class="jt hv">class</strong> List {<br/>  <strong class="jt hv">constructor</strong>(x, xs) {<br/>    <strong class="jt hv">this</strong>.head = null<br/>    <strong class="jt hv">this</strong>.tail = null<br/>    <strong class="jt hv">this</strong>.head = () =&gt; x<br/>    <strong class="jt hv">this</strong>.tail = () =&gt; xs<br/>  }<br/>  [Symbol.iterator]() {<br/>    <strong class="jt hv">const</strong> listIterator = <strong class="jt hv">function*</strong> (xs) {<br/>      <strong class="jt hv">do</strong> {<br/>        <strong class="jt hv">yield</strong> head(xs)<br/>        xs = tail(xs)<br/>      } <strong class="jt hv">while</strong> (xs !== emptyList)<br/>    }<br/>    <strong class="jt hv">const</strong> gen = listIterator(<strong class="jt hv">this</strong>)<br/>    <strong class="jt hv">return</strong> {<br/>      next() { <strong class="jt hv">return</strong> gen.next() }<br/>    }<br/>  }<br/>  valueOf() {<br/>    <strong class="jt hv">let</strong> value = xs =&gt;<br/>      isEmpty(xs) ? `[]` : `${head(xs)}:${value(tail(xs))}`<br/>    <strong class="jt hv">return</strong> isEmpty(<strong class="jt hv">this</strong>) ? `[]` : `[${value(<strong class="jt hv">this</strong>)}]`<br/>  }<br/>}</span></pre><p id="eced" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们可以像使用数组一样使用列表——如果出于某种原因我们想使用<code class="eh jq jr js jt b">for</code>循环或者对可迭代对象有其他需求:</p><pre class="jv jw jx jy fq jz jt ka kb aw kc dt"><span id="3bf4" class="kd ke hu jt b fv kf kg l kh ki"><strong class="jt hv">let</strong> lst = list(1,2,3,4,5)</span><span id="6a4c" class="kd ke hu jt b fv kj kg l kh ki"><strong class="jt hv">for</strong> (<strong class="jt hv">let</strong> value <strong class="jt hv">of</strong> lst) { console.log(value); }<br/><em class="ju">// 1<br/>// 2<br/>// 3<br/>// 4<br/>// 5</em></span></pre><p id="fac3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下一步是通过范围列表表达式重新创建Haskell中提供的功能。例如，Haskell表达式<code class="eh jq jr js jt b">[1..10]</code>是构建列表<code class="eh jq jr js jt b">[1,2,3,4,5,6,7,8,9,10]</code>的快捷方式。同样，Haskell也可以推断出当您键入<code class="eh jq jr js jt b">[1,3..10]</code>时，您的意思是<code class="eh jq jr js jt b">[1,3,5,7,9]</code>。让我们看看在JavaScript中我们能做到什么程度。首先，我们将定义一个递归构造连续整数列表的函数:</p><pre class="jv jw jx jy fq jz jt ka kb aw kc dt"><span id="76df" class="kd ke hu jt b fv kf kg l kh ki"><strong class="jt hv">const</strong> listRange = (start, end) =&gt; {<br/>  <strong class="jt hv">if</strong> (start === end) { <strong class="jt hv">return</strong> list(start) }<br/>  <strong class="jt hv">if</strong> (start &gt; end) { <strong class="jt hv">return</strong> listRangeBy(start, end, x =&gt; x - 1) }<br/>  <strong class="jt hv">return</strong> listRangeBy(start, end, x =&gt; x + 1)<br/>}</span></pre><p id="f1af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们给这个函数两个值<code class="eh jq jr js jt b">start</code>和<code class="eh jq jr js jt b">end</code>，它返回一个它们之间的数字列表。注意，与Haskell不同，结果列表包含起始值，但不包含结束值(如在Python中)；这个函数只对数字起作用(然而，设计一个字符版本不会太难——参见<a class="ae jp" href="https://github.com/sjsyrek/lazy-linked-lists" rel="noopener ugc nofollow" target="_blank">我的库</a>)；并且如果<code class="eh jq jr js jt b">start</code>大于<code class="eh jq jr js jt b">end</code>，则结果列表<em class="ju">向下计数</em>而不是向上计数:</p><pre class="jv jw jx jy fq jz jt ka kb aw kc dt"><span id="8685" class="kd ke hu jt b fv kf kg l kh ki">listRange(1,10).valueOf() <em class="ju">// [1:2:3:4:5:6:7:8:9:[]]</em></span><span id="d385" class="kd ke hu jt b fv kj kg l kh ki">listRange(10,1).valueOf() <em class="ju">// [10:9:8:7:6:5:4:3:2:[]]</em></span></pre><p id="d894" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">眼尖的人会注意到，这个函数本身实际上并没有做多少事情。相反，它将列表构造本身的责任交给了另一个更通用的函数:<code class="eh jq jr js jt b">listRangeBy</code>。该函数也创建了一个范围列表，但是参数化了用于增加值的“step”函数，使其成为<code class="eh jq jr js jt b">listRange</code>的更一般的情况，并且使简单地根据另一个定义一个变得明智。最后，在<code class="eh jq jr js jt b">listRangeBy</code>中，我们见到了这件事的核心代理人:</p><pre class="jv jw jx jy fq jz jt ka kb aw kc dt"><span id="f89e" class="kd ke hu jt b fv kf kg l kh ki"><strong class="jt hv">const</strong> listRangeBy = (start, end, step) =&gt; {<br/>  <strong class="jt hv">if</strong> (start === end) { <strong class="jt hv">return</strong> list(start) }<br/>  <strong class="jt hv">let</strong> x = start<br/>  <strong class="jt hv">const</strong> xs = list(x)<br/>  <strong class="jt hv">const</strong> listGenerator = <strong class="jt hv">function*</strong>() {<br/>    x = step(x)<br/>    <strong class="jt hv">while</strong> (start &lt; end ? x &lt; end : x &gt; end) {<br/>      <strong class="jt hv">yield</strong> list(x)<br/>      x = step(x)<br/>    }<br/>  }<br/>  <strong class="jt hv">const</strong> gen = listGenerator()<br/>  <strong class="jt hv">const</strong> handler = {<br/>    get: <strong class="jt hv">function</strong>(target, prop) {<br/>      <strong class="jt hv">if</strong> (prop === `tail` &amp;&amp; isEmpty(tail(target))) {<br/>        <strong class="jt hv">const</strong> next = gen.next()<br/>        <strong class="jt hv">if</strong> (next.done === false) {<br/>          target[prop] = () =&gt; <strong class="jt hv">new</strong> Proxy(next.value, handler)<br/>        }<br/>      }<br/>      <strong class="jt hv">return</strong> target[prop]<br/>    }<br/>  }<br/>  <strong class="jt hv">const</strong> proxy = <strong class="jt hv">new</strong> Proxy(xs, handler)<br/>  <strong class="jt hv">return</strong> proxy<br/>}</span></pre><p id="2b55" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个函数有点奇怪，对于函数式程序员来说太强制性了，但是它完成了任务。首先，它接受<code class="eh jq jr js jt b">start</code>值，并用它创建一个单例列表。接下来，它声明一个内部生成器函数，为参数化的<code class="eh jq jr js jt b">step</code>函数定制，该函数将<code class="eh jq jr js jt b">yield</code>后续的单例列表，直到它命中<code class="eh jq jr js jt b">end</code>。这些新列表在生成时是由<code class="eh jq jr js jt b">listRangeBy</code>函数返回的“列表”(实际上是一个代理对象)的“惰性”尾部。头部是该特定节点的评估值，但是列表的其余部分被认为是“空的”，直到对更多列表的进一步调用触发后续评估。尾部的每个元素都是按需一次生成一个，这就是为什么我们可以说这些范围列表是延迟求值的。</p><p id="130d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来是<code class="eh jq jr js jt b">handler</code>对象。这个特殊的处理程序，如上面的<code class="eh jq jr js jt b">Secret</code>示例，捕获所有试图<code class="eh jq jr js jt b">get</code>目标<code class="eh jq jr js jt b">List</code>上定义的属性值的尝试。在这种情况下，我们只对<code class="eh jq jr js jt b">tail</code>地产感兴趣。当请求“目标”列表的<code class="eh jq jr js jt b">tail</code>的值时，处理程序的<code class="eh jq jr js jt b">get</code>方法调用生成器函数，而不是生成列表的整个剩余部分，该函数只生成下一个<code class="eh jq jr js jt b">head</code>值——打包在另一个单例列表中——并返回一个新的<code class="eh jq jr js jt b">Proxy</code>对象，该对象“定位”新生成的单例列表。这个新列表的<code class="eh jq jr js jt b">tail</code>仍然是<code class="eh jq jr js jt b">emptyList</code>，尽管只要生成器能够产生新值，它就不再是了。但是我们假装这是代理处理器逻辑的一部分。在我们的惰性列表世界中，处理程序计算的任何给定的尾部要么是单例列表，要么是已经部分或完全计算过的列表。在单例列表的情况下，处理程序开始创建一系列代理，这些代理继续捕获调用以评估这些嵌套的尾部，直到列表被完全评估或者不再请求更多的值。</p><p id="0d73" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是可行的，因为列表尾部是递归计算的。任何在列表中递归的函数最终都会在它的基本用例中遇到<code class="eh jq jr js jt b">emptyList</code>。对于那些我们定义为惰性的列表，如果列表的尾部为空，代理处理程序会检查生成器是否能产生另一个值。如果可以，它将返回一个新的代理，目标是一个以该值为头的新列表。如果不能，它正常返回<code class="eh jq jr js jt b">emptyList</code>,这意味着原始列表已经被完全评估，对其尾部的后续调用将不受干扰地通过代理。在列表已经被部分求值的情况下，处理程序代码被跳过，直到需要生成更多的值——直到，也就是说，目标列表的尾部等于<code class="eh jq jr js jt b">emptyList</code>。完全求值的列表的行为与任何其他<code class="eh jq jr js jt b">List</code>对象相同。</p><p id="5502" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，为了让整个事情顺利进行，<code class="eh jq jr js jt b">listRangeBy</code>创建了一个代理对象<code class="eh jq jr js jt b">proxy</code>，它指向最初的单例列表<code class="eh jq jr js jt b">xs</code>(我们的<code class="eh jq jr js jt b">start</code>值的包装器)并返回<code class="eh jq jr js jt b">proxy</code>，列表行头部的过滤器，代替了一个“普通的”<code class="eh jq jr js jt b">List</code>对象。我们现在已经抽象了懒惰评估。</p><p id="4f10" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它起作用了:</p><pre class="jv jw jx jy fq jz jt ka kb aw kc dt"><span id="ba0c" class="kd ke hu jt b fv kf kg l kh ki"><strong class="jt hv">let</strong> eagerList = list(1,2,3,4,5,6,7,8,9,10)</span><span id="c2fd" class="kd ke hu jt b fv kj kg l kh ki">eagerList.valueOf() <em class="ju">// [1:2:3:4:5:6:7:8:9:10:[]]</em><br/><br/><strong class="jt hv">let</strong> lazyList = listRangeBy(1,100000, x =&gt; x + 3)</span><span id="6d94" class="kd ke hu jt b fv kj kg l kh ki">lazyList <em class="ju">// List { head: [Function], tail: [Function] }</em></span><span id="25a3" class="kd ke hu jt b fv kj kg l kh ki">lazyList.valueOf() <em class="ju">// RangeError: Maximum call stack size exceeded</em></span></pre><p id="176d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不幸的是，在<a class="ae jp" href="https://github.com/tc39/proposal-ptc-syntax" rel="noopener ugc nofollow" target="_blank">适当的尾部调用</a>最终进入<a class="ae jp" href="http://kangax.github.io/compat-table/es6/" rel="noopener ugc nofollow" target="_blank"> JavaScript引擎</a>之前，当你试图执行某些操作时，极长的列表很可能会破坏你的堆栈框架。说到极长的列表…通过使用JavaScript的便利的<code class="eh jq jr js jt b">Infinity</code>全局变量，我们现在可以实现类似的函数来方便地构造<em class="ju">无限</em>长的惰性列表:</p><pre class="jv jw jx jy fq jz jt ka kb aw kc dt"><span id="2941" class="kd ke hu jt b fv kf kg l kh ki"><strong class="jt hv">const</strong> listInf = start =&gt; listInfBy(start, x =&gt; x + 1)<br/><br/><strong class="jt hv">const</strong> listInfBy = (start, step) =&gt; listRangeBy(start, Infinity, step)</span></pre><p id="3ab3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为无限列表是这个小项目的亮点，所以让我们定义几个更基本的列表函数来更好地说明它们是如何工作的:</p><pre class="jv jw jx jy fq jz jt ka kb aw kc dt"><span id="41ae" class="kd ke hu jt b fv kf kg l kh ki"><strong class="jt hv">const</strong> length = xs =&gt; {<br/>  <strong class="jt hv">const</strong> lenAcc = (xs, n) =&gt;<br/>    isEmpty(xs) ? n : lenAcc(tail(xs), n + 1)<br/>  <strong class="jt hv">return</strong> lenAcc(xs, 0)<br/>}<br/><br/><strong class="jt hv">const</strong> index = (as, n) =&gt; {<br/>  <strong class="jt hv">if</strong> (n &lt; 0 || isEmpty(as)) { <strong class="jt hv">throw</strong> Error('OutOfRangeError') }<br/>  <strong class="jt hv">const</strong> x = head(as)<br/>  <strong class="jt hv">const</strong> xs = tail(as)<br/>  <strong class="jt hv">if</strong> (n === 0) { <strong class="jt hv">return</strong> x }<br/>  <strong class="jt hv">return</strong> index(xs, n - 1)<br/>}<br/><br/><strong class="jt hv">const</strong> listAppend = (xs, ys) =&gt; {<br/>  <strong class="jt hv">if</strong> (isEmpty(xs)) { <strong class="jt hv">return</strong> ys }<br/>  <strong class="jt hv">if</strong> (isEmpty(ys)) { <strong class="jt hv">return</strong> xs }<br/>  <strong class="jt hv">return</strong> cons(head(xs), listAppend(tail(xs), ys))<br/>}<br/><br/><strong class="jt hv">const</strong> take = (n, as) =&gt; {<br/>  <strong class="jt hv">if</strong> (n &lt;= 0) { <strong class="jt hv">return</strong> emptyList }<br/>  <strong class="jt hv">if</strong> (isEmpty(as)) { <strong class="jt hv">return</strong> emptyList }<br/>  <strong class="jt hv">const</strong> x = head(as)<br/>  <strong class="jt hv">const</strong> xs = tail(as)<br/>  <strong class="jt hv">return</strong> cons(x, take(n - 1, xs))<br/>}<br/><br/><strong class="jt hv">const</strong> drop = (n, as) =&gt; {<br/>  <strong class="jt hv">if</strong> (n &lt;= 0) { <strong class="jt hv">return</strong> as }<br/>  <strong class="jt hv">if</strong> (isEmpty(as)) { <strong class="jt hv">return</strong> emptyList }<br/>  <strong class="jt hv">const</strong> xs = tail(as)<br/>  <strong class="jt hv">return</strong> drop(n - 1, xs)<br/>}<br/><br/><strong class="jt hv">const</strong> map = (f, as) =&gt; {<br/>  <strong class="jt hv">if</strong> (isEmpty(as)) { <strong class="jt hv">return</strong> emptyList }<br/>  <strong class="jt hv">const</strong> x = f(head(as))<br/>  <strong class="jt hv">const</strong> xs = tail(as)<br/>  <strong class="jt hv">return</strong> cons(x, map(f, xs))<br/>}</span></pre><p id="4582" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jq jr js jt b">length</code>和<code class="eh jq jr js jt b">index</code>类似于它们基于数组的对应物。<code class="eh jq jr js jt b">listAppend</code>类似于JavaScript中的<code class="eh jq jr js jt b">concat</code>(而Haskell中的<code class="eh jq jr js jt b">concat</code>采用多维列表并将其扁平化)。<code class="eh jq jr js jt b">take</code>从一个列表中抓取第一个<code class="eh jq jr js jt b">n</code>元素，并在一个新列表中返回它们。<code class="eh jq jr js jt b">drop</code>删除第一个<code class="eh jq jr js jt b">n</code>元素，返回剩下的。毫不奇怪，<code class="eh jq jr js jt b">map</code>将函数<code class="eh jq jr js jt b">f</code>应用于列表<code class="eh jq jr js jt b">as</code>中的每个元素。这些函数既适用于急切求值的列表，也适用于延迟求值的列表，包括无限列表，尽管有些函数显然不适用于后者(并且可能会在您的REPL中导致一些奇怪的行为):</p><pre class="jv jw jx jy fq jz jt ka kb aw kc dt"><span id="d755" class="kd ke hu jt b fv kf kg l kh ki"><strong class="jt hv">let</strong> eagerList = list(1,2,3,4,5,6,7)</span><span id="e647" class="kd ke hu jt b fv kj kg l kh ki"><strong class="jt hv">let</strong> lazyList = listRangeBy(1,1000, x =&gt; x * 2)</span><span id="7f14" class="kd ke hu jt b fv kj kg l kh ki"><strong class="jt hv">let</strong> infiniteList = listInf(1)<br/><br/>head(eagerList) <em class="ju">// 1</em></span><span id="2570" class="kd ke hu jt b fv kj kg l kh ki">head(lazyList) <em class="ju">// 1</em></span><span id="2fc1" class="kd ke hu jt b fv kj kg l kh ki">head(infiniteList) <em class="ju">// 1</em><br/><br/>tail(eagerList).valueOf() <em class="ju">// [2:3:4:5:6:7:8:9:10:[]]</em></span><span id="a4b5" class="kd ke hu jt b fv kj kg l kh ki">tail(lazyList).valueOf() <em class="ju">// [2:4:8:16:32:64:128:256:512:[]]</em></span><span id="938a" class="kd ke hu jt b fv kj kg l kh ki">tail(infiniteList).valueOf()<br/><em class="ju">// RangeError: Maximum call stack size exceeded<br/></em><br/>length(eagerList) <em class="ju">// 7</em></span><span id="97b9" class="kd ke hu jt b fv kj kg l kh ki">length(lazyList) <em class="ju">// 10</em></span><span id="2b3f" class="kd ke hu jt b fv kj kg l kh ki">length(infiniteList)<em class="ju"> // RangeError: Maximum call stack size exceeded</em><br/><br/>index(eagerList, 3) <em class="ju">// 4</em></span><span id="1798" class="kd ke hu jt b fv kj kg l kh ki">index(lazyList, 9) <em class="ju">// 512</em></span><span id="0346" class="kd ke hu jt b fv kj kg l kh ki">index(infiniteList, 10000) <em class="ju">// 10001</em><br/><br/>listAppend(eagerList, lazyList).valueOf()<br/><em class="ju">// [1:2:3:4:5:6:7:1:2:4:8:16:32:64:128:256:512:[]]</em></span><span id="11fe" class="kd ke hu jt b fv kj kg l kh ki">listAppend(lazyList, infiniteList).valueOf()<br/><em class="ju">// List { head: [Function], tail: [Function] }</em></span><span id="d437" class="kd ke hu jt b fv kj kg l kh ki">index(listAppend(lazyList, infiniteList), 100) <em class="ju">// 91</em></span><span id="f05b" class="kd ke hu jt b fv kj kg l kh ki">listAppend(infiniteList, eagerList).valueOf()<br/><em class="ju">// RangeError: Maximum call stack size exceeded<br/></em><br/>take(5, eagerList).valueOf() <em class="ju">// [1:2:3:4:5:[]]</em></span><span id="e6c4" class="kd ke hu jt b fv kj kg l kh ki">take(5, lazyList).valueOf() <em class="ju">// [1:2:4:8:16:[]]</em></span><span id="26a8" class="kd ke hu jt b fv kj kg l kh ki">take(5, infiniteList).valueOf() <em class="ju">// [1:2:3:4:5:[]]</em><br/><br/>drop(5, eagerList).valueOf() <em class="ju">// [6:7:[]]</em></span><span id="3239" class="kd ke hu jt b fv kj kg l kh ki">drop(5, lazyList).valueOf() <em class="ju">// [32:64:128:256:512:[]]</em></span><span id="d2ac" class="kd ke hu jt b fv kj kg l kh ki">drop(5, infiniteList).valueOf()<br/><em class="ju">// RangeError: Maximum call stack size exceeded</em><br/><br/><strong class="jt hv">let</strong> f = x =&gt; x * 10</span><span id="fdff" class="kd ke hu jt b fv kj kg l kh ki">map(f, eagerList).valueOf() <em class="ju">// [10:20:30:40:50:60:70:[]]</em></span><span id="5887" class="kd ke hu jt b fv kj kg l kh ki">map(f, lazyList).valueOf()<br/><em class="ju">// [10:20:40:80:160:320:640:1280:2560:5120:[]]</em></span><span id="3cb0" class="kd ke hu jt b fv kj kg l kh ki">map(f, infiniteList).valueOf()<br/><em class="ju">// RangeError: Maximum call stack size exceeded</em></span><span id="dde9" class="kd ke hu jt b fv kj kg l kh ki">map(f, take(10, infiniteList)).valueOf()<br/><em class="ju">// [10:20:30:40:50:60:70:80:90:100:[]]</em></span></pre><p id="5bfc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在最后一个例子中，我们不能执行惰性映射(虽然原则上是可能的)，但是我们<em class="ju">可以用另一个函数</em><a class="ae jp" href="https://wiki.haskell.org/Function_composition" rel="noopener ugc nofollow" target="_blank"/><code class="eh jq jr js jt b">map</code>组合<em class="ju"/>产生一个有限列表并映射到其上。</p><p id="5063" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们将Haskell函数翻译成JavaScript时，为什么不导入基本函数<a class="ae jp" href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-List.html#g:8" rel="noopener ugc nofollow" target="_blank">来生成其他类型的无限列表呢？当您需要处理价值流时，这些会很方便:</a></p><pre class="jv jw jx jy fq jz jt ka kb aw kc dt"><span id="6875" class="kd ke hu jt b fv kf kg l kh ki"><strong class="jt hv">const</strong> iterate = (f, x) =&gt; listInfBy(x, x =&gt; f(x))<br/><br/><strong class="jt hv">const</strong> repeat = a =&gt; cons(a, listInfBy(a, a =&gt; a))<br/><br/><strong class="jt hv">const</strong> replicate = (n, x) =&gt; take(n, repeat(x))</span></pre><p id="1573" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jq jr js jt b">iterate</code>将给定函数<code class="eh jq jr js jt b">f</code>反复应用于值<code class="eh jq jr js jt b">x</code>。<code class="eh jq jr js jt b">repeat</code>返回相同值的无限列表。<code class="eh jq jr js jt b">replicate</code>简单地返回一个值为<code class="eh jq jr js jt b">x</code>的<code class="eh jq jr js jt b">n</code>元素列表。还有一个函数<code class="eh jq jr js jt b">cycle</code>值得特别一提，因为它需要一个特殊的实现。<code class="eh jq jr js jt b">cycle</code>取一个列表，无限重复。然而，我们的常规<code class="eh jq jr js jt b">listRangeBy</code>函数不能处理这种情况，所以我们必须为<code class="eh jq jr js jt b">cycle</code>提供一个稍微改变的版本:</p><pre class="jv jw jx jy fq jz jt ka kb aw kc dt"><span id="5752" class="kd ke hu jt b fv kf kg l kh ki"><strong class="jt hv">const</strong> cycle = as =&gt; {<br/>  <strong class="jt hv">if</strong> (isEmpty(as)) { <strong class="jt hv">throw</strong> Error('EmptyListError') }<br/>  <strong class="jt hv">let</strong> x = head(as)<br/>  <strong class="jt hv">let</strong> xs = tail(as)<br/>  <strong class="jt hv">const</strong> c = list(x)<br/>  <strong class="jt hv">const</strong> listGenerator = <strong class="jt hv">function*</strong> () {<br/>    <strong class="jt hv">do</strong> {<br/>      x = isEmpty(xs) ? head(as) : head(xs)<br/>      xs = isEmpty(xs) ? tail(as) : tail(xs)<br/>      <strong class="jt hv">yield</strong> list(x)<br/>    } <strong class="jt hv">while</strong> (true)<br/>  }<br/>  <strong class="jt hv">const</strong> gen = listGenerator()<br/>  <strong class="jt hv">const</strong> handler = {<br/>    get: <strong class="jt hv">function</strong> (target, prop) {<br/>      <strong class="jt hv">if</strong> (prop === `tail` &amp;&amp; isEmpty(tail(target))) {<br/>        <strong class="jt hv">const</strong> next = gen.next()<br/>        target[prop] = () =&gt; <strong class="jt hv">new</strong> Proxy(next.value, handler)<br/>      }<br/>      <strong class="jt hv">return</strong> target[prop]<br/>    }<br/>  }<br/>  <strong class="jt hv">const</strong> proxy = <strong class="jt hv">new</strong> Proxy(c, handler)<br/>  <strong class="jt hv">return</strong> proxy<br/>}</span></pre><p id="bc69" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">JavaScript就像生活一样，有时候有点乱。让我们看看这些函数的作用:</p><pre class="jv jw jx jy fq jz jt ka kb aw kc dt"><span id="f9e3" class="kd ke hu jt b fv kf kg l kh ki"><strong class="jt hv">let</strong> lst1 = iterate(x =&gt; x + 2, 0)</span><span id="16c8" class="kd ke hu jt b fv kj kg l kh ki">take(10, lst1).valueOf() <em class="ju">// [0:2:4:6:8:10:12:14:16:18:[]]<br/></em><br/><strong class="jt hv">let</strong> lst2 = repeat(7)</span><span id="49ec" class="kd ke hu jt b fv kj kg l kh ki">take(20, lst2).valueOf()<br/><em class="ju">// [7:7:7:7:7:7:7:7:7:7:7:7:7:7:7:7:7:7:7:7:[]]</em><br/><br/><strong class="jt hv">let</strong> lst3 = replicate(5, 23) </span><span id="0e71" class="kd ke hu jt b fv kj kg l kh ki">lst3.valueOf() <em class="ju">// [23:23:23:23:23:[]]</em><br/><br/><strong class="jt hv">let</strong> lst4 = cycle(list(5,4,3,2,1))</span><span id="6d26" class="kd ke hu jt b fv kj kg l kh ki">index(ls4, 5) <em class="ju">// 5</em></span><span id="47e8" class="kd ke hu jt b fv kj kg l kh ki">index(lst4, 10) <em class="ju">// 5</em></span><span id="f65a" class="kd ke hu jt b fv kj kg l kh ki">index(lst4, 100) <em class="ju">// 5</em></span><span id="9571" class="kd ke hu jt b fv kj kg l kh ki">index(lst4, 104) <em class="ju">// 1</em></span></pre><p id="0dc7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们愿意，我们可以使用无限列表来创建更加专门化的流，或者作为众所周知的算法的实现的一部分:</p><pre class="jv jw jx jy fq jz jt ka kb aw kc dt"><span id="ca84" class="kd ke hu jt b fv kf kg l kh ki"><strong class="jt hv">const</strong> booleans = cycle(list(false, true))<br/><br/><strong class="jt hv">const</strong> fib = n =&gt; n &lt; 2 ? n : fib(n - 1) + fib(n - 2)<br/><strong class="jt hv">const</strong> fibs = n =&gt; map(fib, take(n, listInf(1)))<br/><br/><strong class="jt hv">const</strong> fact = n =&gt; n === 1 ? n : fact(n - 1) * n<br/><strong class="jt hv">const</strong> facts = n =&gt; map(fact, take(n, listInf(1)))<br/><br/><strong class="jt hv">const</strong> sqrt = (a0, eps, n) =&gt; {<br/>  <strong class="jt hv">const</strong> within = (eps, rest) =&gt; {<br/>    <strong class="jt hv">let</strong> a = index(rest, 0)<br/>    <strong class="jt hv">let</strong> b = index(rest, 1)<br/>    <strong class="jt hv">return</strong> Math.abs(a - b) &lt;= eps ? b : within(eps, drop(1, rest))<br/>  }<br/>  <strong class="jt hv">const</strong> next = (n, x) =&gt; (x + n / x) / 2<br/>  <strong class="jt hv">return</strong> within(eps, iterate(next.bind(null, n), a0))<br/>}<br/><br/>index(booleans, 20) <em class="ju">// false</em></span><span id="14dd" class="kd ke hu jt b fv kj kg l kh ki">index(booleans, 10001) <em class="ju">// true</em><br/><br/>index(fibs(10), 9) <em class="ju">// 55</em></span><span id="3982" class="kd ke hu jt b fv kj kg l kh ki">facts(5).valueOf() <em class="ju">// [1:2:6:24:120:[]]</em><br/><br/>sqrt(1,0,2) <em class="ju">// 1.414213562373095</em></span><span id="f313" class="kd ke hu jt b fv kj kg l kh ki">sqrt(1,0,144) <em class="ju">// 144</em></span></pre><p id="5ae6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">作为偶数或奇数的过滤器，或者如果您正在创建需要交替模式的其他东西(例如表格行的阴影)，交替布尔的无限列表可能会很方便。有了一个值流，您可以根据需要获取任意数量的值，而不必编写计算它们的逻辑代码。斐波那契和阶乘的例子，除了是有史以来最著名的递归例子外，还展示了如何使用无限列表从算法上产生自定义的值序列。这里显示的<code class="eh jq jr js jt b">sqrt</code>函数使用一个无限列表来计算一个数<code class="eh jq jr js jt b">n</code>的平方根，有一个容差<code class="eh jq jr js jt b">eps</code>，从一个初始估计值<code class="eh jq jr js jt b">a0</code>开始。这个计算平方根的<a class="ae jp" href="http://mathworld.wolfram.com/NewtonsMethod.html" rel="noopener ugc nofollow" target="_blank">牛顿-拉夫森方法</a>的例子改编自约翰·休斯的<a class="ae jp" href="http://www.cse.chalmers.se/~rjmh/Papers/whyfp.pdf" rel="noopener ugc nofollow" target="_blank">为什么函数式编程很重要</a>——确实是必读书。</p><p id="07e2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在你有了:JavaScript中懒惰的、函数式的、无限的列表，你可以对它们执行各种操作！再次，请查看GitHub 上的<a class="ae jp" href="https://github.com/sjsyrek/lazy-linked-lists" rel="noopener ugc nofollow" target="_blank">我的库，了解更多的<code class="eh jq jr js jt b">List</code>函数，包括有条件地获取和删除元素的函数、过滤列表、排序列表、压缩列表等等。完整的类定义还提供了列表相等性检查、所有标准比较方法以及常见代数接口的实现，如幺半群、可折叠、仿函数和单子(oops)。此外，完整的库更好地支持字符串，为了简单起见，我在本文中忽略了这一点。还提供了在列表和JavaScript数组以及字符串之间进行转换的函数。对于所有这些函数的类型检查和编译版本，请参见我翻译成JavaScript的更全面的Haskell函数库:</a><a class="ae jp" href="https://github.com/sjsyrek/maryamyriameliamurphies" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">【maryamriameliamurphies . js</strong></a>。</p><p id="95d9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">链表是函数式编程的理想数据结构:它很容易递归定义，并且非常适合函数的组合。函数链表实现起来非常简单，因为它是一个<a class="ae jp" href="https://en.wikipedia.org/wiki/Geometric_series" rel="noopener ugc nofollow" target="_blank">数学对象</a>，而不是必须通过程序操作的有限计算机内存块的抽象，或者像JavaScript那样，是一种特殊的记录类型。用一种更纯粹的函数式语言，我们可以将这种集合类型描述为一个简单的公式，而不必担心内存、指针或其他任何实际机器关心的东西，但我们作为程序员却不用担心。此外，<a class="ae jp" href="https://en.wikipedia.org/wiki/Algebraic_data_type" rel="noopener ugc nofollow" target="_blank">代数数据类型</a>，尽管听起来很可怕，却可以使我们的数据更容易组织，代码更容易阅读，正如俗话所说，推理。</p><p id="a2ef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，Haskell中列表的完整定义是<code class="eh jq jr js jt b">data [] a = [] | a : [a]</code>。这一小段代码完成了与我的整个类基本相同的事情——这都要归功于<a class="ae jp" rel="noopener" href="/@willkurt/why-sum-types-matter-in-haskell-ba2c1ab4e372#.tq1k0tdco">sum类型的强大功能和表达能力</a>。大多数语言都有产品类型。很少有求和类型。JavaScript <code class="eh jq jr js jt b">Object</code>是一个产品类型，因为每个对象都包含一个字段来表示每个可能的值。我们上面定义的<code class="eh jq jr js jt b">List</code>不是一个真正的sum类型，但是它确实再现了包含<em class="ju">一个值或一组值</em>或<em class="ju">另一个值或一组值</em>的类型的功能。其中产品类型代表<em class="ju">和</em>，总和类型代表<em class="ju">或</em>。在你的布尔逻辑中没有<em class="ju">或</em>你不会去做，那么为什么在你的类型系统中没有它们呢？如果不能将类型定义为<a class="ae jp" href="http://mathworld.wolfram.com/DisjointSets.html" rel="noopener ugc nofollow" target="_blank">不相交的</a>，您就会被困在一个人工层次和过度指定的抽象的世界中。当所有东西都是产品类型时，当你别无选择，只能将自定义类型(即类)定义为值的集合，而不是T21值中的选择时，你就会得到这个结果。如果你曾经遇到过将一堆对象拼接在一起以对不一致的数据建模的困难，那么你就会知道我所说的痛苦。现在你有补救方法了。使用sum类型，您可以更容易地使您的模型适应混乱的数据世界，而不是试图强迫数据符合您的模型。在函数式编程中，我们更喜欢<a class="ae jp" href="https://en.wikipedia.org/wiki/Proteus" rel="noopener ugc nofollow" target="_blank"> Proteus </a>而不是<a class="ae jp" href="https://en.wikipedia.org/wiki/Procrustes" rel="noopener ugc nofollow" target="_blank"> Procrustes </a>。我们更喜欢灵活的列表而不是死板的数组。JavaScript的内置<code class="eh jq jr js jt b">Array</code>类型已经朝着功能性更强的方向迈出了一大步，但它本质上仍然是一个黑客。幸运的是，JavaScript有更高阶的函数，所以我们也可以自己动手。</p><h2 id="a6d9" class="kd ke hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">后记—二叉树</h2><p id="bf28" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">我在本文中演示的实现链表的方法原则上也可以用于其他链接结构。如果一个给定的数据类型有一个明显的递归定义，对它应用同样的逻辑不会太麻烦。我们先简单看一下<a class="ae jp" href="https://en.wikipedia.org/wiki/Binary_tree" rel="noopener ugc nofollow" target="_blank">二叉树</a>。我们可以在Haskell中定义一棵二叉树如下:<code class="eh jq jr js jt b">data Tree a = Leaf | Node (Tree a) a (Tree a)</code>。就像我们上面的<code class="eh jq jr js jt b">List</code>类型一样，<code class="eh jq jr js jt b">Tree</code>是一个求和类型，这意味着任何给定的<code class="eh jq jr js jt b">Tree</code>都将是<em class="ju">或者是</em>a<code class="eh jq jr js jt b">Leaf</code>T12】或者是 a <code class="eh jq jr js jt b">Node</code>。<code class="eh jq jr js jt b">Leaf</code>就像<code class="eh jq jr js jt b">emptyList</code>一样:它是结构的自然基本情况或终点。然而，一个链表只在一个点终止，一棵树可以有多个分支，每个分支可以有更多的分支，所有的分支都在端点终止。下面是这个相同结构在JavaScript中的基本实现，包括用于插入到树中的函数和用于以通常的顺序显示树值的函数(为了方便起见，转换为数组):</p><pre class="jv jw jx jy fq jz jt ka kb aw kc dt"><span id="17a8" class="kd ke hu jt b fv kf kg l kh ki"><strong class="jt hv">class</strong> Tree {<br/>  <strong class="jt hv">constructor</strong>(left, label, right) {<br/>    <strong class="jt hv">this</strong>.left = () =&gt; left<br/>    <strong class="jt hv">this</strong>.label = () =&gt; label<br/>    <strong class="jt hv">this</strong>.right = () =&gt; right<br/>  }<br/>}<br/><br/><strong class="jt hv">const</strong> leaf = <strong class="jt hv">new</strong> Tree()<br/><br/><strong class="jt hv">const</strong> node = (left, label, right) =&gt; <strong class="jt hv">new</strong> Tree(left, label, right)<br/><br/><strong class="jt hv">const</strong> insert = (x, t) =&gt; {<br/>  <strong class="jt hv">if</strong> (t === leaf) { <strong class="jt hv">return</strong> node(leaf, x, leaf) }<br/>  <strong class="jt hv">if</strong> (x === t.label()) { <strong class="jt hv">return</strong> t }<br/>  <strong class="jt hv">if</strong> (x &lt; t.label()) {<br/>    <strong class="jt hv">return</strong> node(insert(x, t.left()), t.label(), t.right())<br/>  }<br/>  <strong class="jt hv">return</strong> node(t.left(), t.label(), insert(x, t.right()))<br/>}<br/><br/><strong class="jt hv">const</strong> preorder = t =&gt; t === leaf ? [] : <br/>  [t.label()]<br/>  .concat(preorder(t.left())<br/>  .concat(preorder(t.right())))<br/><br/><strong class="jt hv">const</strong> inorder = t =&gt; t === leaf ? [] :<br/>  inorder(t.left())<br/>  .concat([t.label()]<br/>  .concat(inorder(t.right())))<br/><br/><strong class="jt hv">const</strong> postorder = t =&gt; t === leaf ? [] :<br/>  postorder(t.left())<br/>  .concat(postorder(t.right())<br/>  .concat([t.label()]))</span></pre><p id="dff5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，让我们构建一个测试树，并尝试我们的小函数库:</p><pre class="jv jw jx jy fq jz jt ka kb aw kc dt"><span id="385b" class="kd ke hu jt b fv kf kg l kh ki"><strong class="jt hv">let</strong> tree = leaf</span><span id="0bb7" class="kd ke hu jt b fv kj kg l kh ki"><strong class="jt hv">let</strong> squares = listInfBy(1, x =&gt; x * 2)</span><span id="f88c" class="kd ke hu jt b fv kj kg l kh ki"><strong class="jt hv">let</strong> cubes = listInfBy(1, x =&gt; x * 3)</span><span id="7f93" class="kd ke hu jt b fv kj kg l kh ki"><strong class="jt hv">for</strong> (<strong class="jt hv">let</strong> value <strong class="jt hv">of</strong> take(10, squares)) { tree = insert(value, tree) }<br/><br/>preorder(tree) <em class="ju">// [1,2,4,8,16,32,64,128,256,512]</em></span><span id="0759" class="kd ke hu jt b fv kj kg l kh ki">inorder(tree) <em class="ju">// [1,2,4,8,16,32,64,128,256,512]</em></span><span id="dd9c" class="kd ke hu jt b fv kj kg l kh ki">postorder(tree) <em class="ju">// [512,256,128,64,32,16,8,4,2,1]<br/></em><br/><strong class="jt hv">for</strong> (<strong class="jt hv">let</strong> value <strong class="jt hv">of</strong> take(5, cubes)) { tree = insert(value, tree) }<br/><br/>preorder(tree) <em class="ju">// [1,2,4,3,8,16,9,32,27,64,128,81,256,512]</em></span><span id="baa4" class="kd ke hu jt b fv kj kg l kh ki">inorder(tree) <em class="ju">// [1,2,3,4,8,9,16,27,32,64,81,128,256,512]</em></span><span id="f423" class="kd ke hu jt b fv kj kg l kh ki">postorder(tree) <em class="ju">// [3,9,27,81,512,256,128,64,32,16,8,4,2,1]</em></span></pre><p id="43cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">学完函数链表，二叉树应该是小菜一碟。只是为了好玩，我使用了一个无限的正方形列表来生成上面的示例树，然后将它与立方体流混合在一起。为什么？再一次演示函数组合。函数式编程的强大来自于所有这些小概念的积累。不断学习它们，不断扩充你的工具箱。懒惰二叉树的实现我留给读者作为练习。</p><blockquote class="li lj lk"><p id="be9c" class="ir is ju it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是阿妹家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>的机会。</p><p id="dca4" class="ir is ju it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated">要了解更多信息，请阅读我们的“关于”页面、<a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">喜欢/在脸书上给我们发消息</a>，或者简单地发送<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is ju it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jv jw jx jy fq lo"><div class="bz el l di"><div class="lp lq l"/></div></figure></div></div>    
</body>
</html>