<html>
<head>
<title>Lessons Learned from Porting 300 C/C++ Projects to Buck Build</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将300个C/C++项目移植到Buck Build的经验教训</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/lessons-learned-from-porting-300-projects-to-buck-build-ff6463b65142?source=collection_archive---------3-----------------------#2017-05-16">https://medium.com/hackernoon/lessons-learned-from-porting-300-projects-to-buck-build-ff6463b65142?source=collection_archive---------3-----------------------#2017-05-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/23c2a6361a0d2d16da9abc6b1de841ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BJV_ZcD8Kn6XeWAIleacOA.jpeg"/></div></div></figure><div class=""/><p id="9ccd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过<a class="ae ka" href="https://www.buckaroo.pm/" rel="noopener ugc nofollow" target="_blank"> Buckaroo </a>，我们正在将C/C++项目的庞大生态系统转变为一系列易于组装的构建模块。我们无法独自完成这项工作，但为了启动社区，我们主动将300个项目移植到<a class="ae ka" href="https://buckbuild.com/" rel="noopener ugc nofollow" target="_blank"> Buck build系统</a>。</p><p id="145e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们选择这些库是基于它们在GitHub、StackOverflow上的受欢迎程度以及来自我们邮件列表的请求。它们的范围从<a class="ae ka" href="https://www.buckaroo.pm/project/philsquared/catch" rel="noopener ugc nofollow" target="_blank">极小的只有头文件的库</a>到<a class="ae ka" href="https://www.buckaroo.pm/project/boost/graph" rel="noopener ugc nofollow" target="_blank">整体的C++项目</a>到<a class="ae ka" href="https://www.buckaroo.pm/project/openssl/openssl" rel="noopener ugc nofollow" target="_blank">古老但关键的C库</a>。</p><p id="a3a0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于每一个库，我们都试图做一个完整的移植。有一些情况下，这并不奏效；有时项目结构非常复杂，以至于我们认为包装现有的构建系统更加实际。我们可以稍后再来看这些项目，但是大多数情况下，移植工作是成功的。</p><p id="e7f1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在研究了这么多项目之后，我们认为为构建干净的C/C++库编制一份清单是有好处的。</p><h1 id="40c5" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">不要:串联。cpp文件转换成一个翻译单元</h1><p id="b6dc" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在许多C/C++项目中发现的一种反模式是将多个C/C++文件组合成一个翻译单元进行编译。理论上来说，这样可以缩短编译时间，因为在整个编译过程中，只需要执行一次预处理器和解析步骤。这对于单个构建来说是正确的，但是它破坏了您进行增量构建的能力。使用单个翻译单元，每当任何项目文件改变时，编译器必须从头开始执行整个构建！</p><h1 id="c067" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">做:明确你的依赖关系</h1><p id="b155" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">使用现有的图书馆对每个人都有好处。库代码得到了更好的测试，这对社区来说很好，重复的工作更少了，这对您来说很好！然而，缺乏一个占主导地位的C/C++包管理器意味着对此使用了多种方法——有些是次优的。</p><p id="a589" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">编写库时，确保清楚地记录它的依赖关系。以下是一些合理的方法:</p><ul class=""><li id="b63d" class="le lf if je b jf jg jj jk jn lg jr lh jv li jz lj lk ll lm dt translated">Git子模块</li><li id="6d62" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">一列<code class="eh ls lt lu lv b">apt-get </code>或<code class="eh ls lt lu lv b">brew install</code>命令——尽管如果你的库的用户不得不修改他们的系统来使用它，他们可能会很恼火！</li><li id="8560" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">一个好的<a class="ae ka" href="https://buckaroo.pm/" rel="noopener ugc nofollow" target="_blank">包管理器</a></li></ul><h1 id="4a93" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">不要:除非万不得已，否则不要使用include_next</h1><p id="6dbb" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated"><code class="eh ls lt lu lv b">#include_next</code>是预处理程序的一个晦涩的特性，允许用户将一个文件包含在它自身中。其目的是允许对系统集管进行修补；<a class="ae ka" href="https://gcc.gnu.org/onlinedocs/cpp/Wrapper-Headers.html" rel="noopener ugc nofollow" target="_blank"> GCC文件</a>解释如下:</p><blockquote class="lw lx ly"><p id="d463" class="jc jd lz je b jf jg jh ji jj jk jl jm ma jo jp jq mb js jt ju mc jw jx jy jz hn dt translated">有时有必要调整系统提供的头文件的内容，而不直接编辑它。例如，GCC的fixincludes操作就是这样做的。一种方法是创建一个同名的新头文件，并将其插入到搜索路径中的原始头文件之前。只要你愿意完全替换旧的头，那就很好。但是如果你想从新的头中引用旧的头呢？</p></blockquote><p id="d86b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">实际上，这个特性会导致非常混乱的结果；许多程序员不熟悉它；它的行为很难追踪。除非万不得已，否则不要使用这个特性。</p><h1 id="49f5" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">DO:将私有头和导出头分开</h1><p id="3bfb" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">为您的库维护一个定义良好的API确实是一个好主意。它允许您在不破坏下游消费者的情况下进行调整，并且它为单元测试提供了一个清晰的表面。</p><p id="cc29" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">理想情况下，您应该将私有和导出的头分别放在各自的文件夹中。我很喜欢这个惯例:</p><ul class=""><li id="5151" class="le lf if je b jf jg jj jk jn lg jr lh jv li jz lj lk ll lm dt translated"><code class="eh ls lt lu lv b">include</code> —对库用户可用的标题</li><li id="0883" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated"><code class="eh ls lt lu lv b">private</code> —编译库所需的标头，但不应提供给库的使用者</li></ul><h1 id="4665" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">不要:包含。cpp文件</h1><p id="40ed" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">C/C++预处理器非常灵活，允许你做一些你可能不应该做的事情。一个例子是包含<code class="eh ls lt lu lv b">.cpp</code>文件。这是非常混乱的，因为文件扩展名不再匹配的意图。这个文件是一个标题吗？然后给它一个<code class="eh ls lt lu lv b">.h</code>或<code class="eh ls lt lu lv b">.hpp</code>的延期。这个文件需要编译吗？那就不要收录。</p><h1 id="63a5" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">DO:在你的例子中，按照预期的方式使用库</h1><p id="5349" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">很多时候，我发现一些例子被写成好像它们在库的源目录中:</p><pre class="md me mf mg fq mh lv mi mj aw mk dt"><span id="18be" class="ml kc if lv b fv mm mn l mo mp">#include “../../things.h”</span></pre><p id="0501" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例子应该是你的图书馆的预期用途的展示案例。这意味着要包括在下游使用的集管:</p><pre class="md me mf mg fq mh lv mi mj aw mk dt"><span id="7f45" class="ml kc if lv b fv mm mn l mo mp">#include &lt;my-library/things.h&gt;</span></pre><p id="c824" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当然，这要求您正确设置包含路径，但是一个好的构建系统<a class="ae ka" href="https://www.buckbuild.com" rel="noopener ugc nofollow" target="_blank">应该会让这变得简单。</a></p><h1 id="d6cc" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">不要:将依赖项复制到项目中</h1><p id="284d" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">如果您没有使用<a class="ae ka" href="https://buckaroo.pm/" rel="noopener ugc nofollow" target="_blank">包管理器</a>，那么将您所依赖的项目复制到源代码控制中会很有诱惑力。这样做的好处是每个人都在构建相同的代码，但是对于库的消费者来说，这可能是一场噩梦。</p><p id="8b2a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如，假设你是库<code class="eh ls lt lu lv b">A</code>的作者，这个库依赖于库<code class="eh ls lt lu lv b">Bv1</code>。但是，你的一个用户正在写库<code class="eh ls lt lu lv b">C</code>，依赖<code class="eh ls lt lu lv b">A</code>和<code class="eh ls lt lu lv b">Bv2</code>。现在，当他们试图构建您的项目时，他们会遇到符号冲突，必须降级到<code class="eh ls lt lu lv b">Bv1</code>或在<code class="eh ls lt lu lv b">A</code>提交PR！一个更好的方法是使用一个包管理器，它可以将<code class="eh ls lt lu lv b">B</code>解析为一个适用于项目中所有依赖项的版本。至少，使用Git子模块可以使这种升级更易于管理。</p><p id="c020" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个规则的一个例外是包含了用于开发任务的微小的只有头文件的库，比如<a class="ae ka" href="https://github.com/philsquared/Catch" rel="noopener ugc nofollow" target="_blank"> Catch测试框架</a>。</p><h1 id="156b" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">DO:命名您的头文件</h1><p id="69d7" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">你应该为你的库选择一个唯一的名字——如果你遇到困难，使用生成器——然后将你导出的所有文件头放入一个同名的文件夹中。这使得与其他库发生名称冲突的可能性大大降低。</p><h1 id="5a4f" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">不要:过度使用预处理器</h1><p id="a998" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">C/C++预处理器本身就是一种<a class="ae ka" href="http://www.ioccc.org/2001/herrmann1.hint" rel="noopener ugc nofollow" target="_blank">编程语言</a>，支持各种编译时魔法和代码生成。问题是预处理器很难调试，因为工具不如C/C++的工具好。</p><p id="47c3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那么为什么要使用预处理器呢？在过去，逻辑认为预处理器保证在编译时执行，因此为了获得最佳性能，应该尽可能在那里实现逻辑。从那时起，编译器已经有了很大的改进，现在<a class="ae ka" href="https://godbolt.org/g/90NjyJ" rel="noopener ugc nofollow" target="_blank">将为你做很多工作</a>。因此，使用现代工具，最好避免在预处理器中实现逻辑，因为它可以在C/C++中实现。相信你的编译器！</p><p id="fd54" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你必须使用预处理器，比如实现<a class="ae ka" href="https://github.com/jamboree/co2" rel="noopener ugc nofollow" target="_blank">无栈协同程序</a>，那么就尽量减少它的使用。希望将来这些案例会被整合到C++语言中，就像过去的模板一样。</p><h1 id="0d02" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">DO:使用文件抽象平台差异</h1><p id="e1a5" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在你的源代码中加入几个<code class="eh ls lt lu lv b">#ifdef __MACOS__ #endif</code>命令可能很诱人，但事实是这使得阅读代码变得非常困难。如果您将特定于平台的实现分成单独的文件，那么您的构建系统可以包含、编译和链接适当的文件。这使得新读者更容易维护和理解代码。</p><h1 id="2b2f" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">不要:依赖编译器特定的特性(除非你真的必须这样做)</h1><p id="8bdc" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">三大C++编译器(Clang、VC++、GCC)都有各自的怪癖，有可能编写的代码只能在其中一个编译器中编译，而不能在其他编译器中编译。这通常可以通过坚持语言标准(或者是VC++的子集)来避免。</p><p id="c4a7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我明白了——这些特定于供应商的特性中的一些可能很方便(<code class="eh ls lt lu lv b">#pragma once</code>)——但是不使你的库可移植，你就减少了你的工作的影响。你失去了对C++社区产生巨大影响的满足感，社区也失去了一个伟大的、可移植的库。</p><p id="7275" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你需要特定的特性，比如<code class="eh ls lt lu lv b">__builtin_popcount</code>，在内置版本和可移植版本上写一个抽象。然后，将实现分成单独的文件，并让您的构建系统知道您的意图。更好的是，重用已经编写好的抽象。</p><h1 id="ed48" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">DO:使用文件夹来划分文件类别</h1><p id="d7da" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">手动列出项目文件非常繁琐。常见的解决方案是使用<a class="ae ka" href="https://en.wikipedia.org/wiki/Glob_(programming)" rel="noopener ugc nofollow" target="_blank"> glob </a>命令。Glob是一个非常强大的工具，但是你可以通过以一种glob友好的方式布局你的文件来使事情变得容易得多。这意味着根据目的将文件划分到逻辑文件夹中。</p><h2 id="239f" class="ml kc if bd kd mq mr ms kh mt mu mv kl jn mw mx kp jr my mz kt jv na nb kx nc dt translated">安排不当的项目</h2><pre class="md me mf mg fq mh lv mi mj aw mk dt"><span id="d1d0" class="ml kc if lv b fv mm mn l mo mp">.<br/>├── common.cpp<br/>├── foo.cpp<br/>├── pthread.cpp<br/>└── win_thread.cpp</span></pre><h2 id="b898" class="ml kc if bd kd mq mr ms kh mt mu mv kl jn mw mx kp jr my mz kt jv na nb kx nc dt translated">安排有序的项目</h2><pre class="md me mf mg fq mh lv mi mj aw mk dt"><span id="a190" class="ml kc if lv b fv mm mn l mo mp">.<br/>├── common<br/>│   ├── common.cpp<br/>│   └── foo.cpp<br/>├── linux<br/>│   └── pthread.cpp<br/>└── windows<br/>    └── win_thread.cpp</span></pre><h1 id="07b0" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">就是这样！🙌</h1><p id="477b" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">Buckaroo软件包现在已经准备好使用了，我们正在努力工作，移植更多的软件。如果你需要一个特定的图书馆，<a class="ae ka" href="https://github.com/LoopPerfect/buckaroo-wishlist/issues/new" rel="noopener ugc nofollow" target="_blank">在愿望清单上创建一个问题</a>。或者(甚至更好)如果你愿意贡献自己的力量，<a class="ae ka" href="https://github.com/LoopPerfect/buckaroo-recipes" rel="noopener ugc nofollow" target="_blank"> PRs永远受欢迎</a>！</p><div class="md me mf mg fq ab cb"><figure class="nd hw ne nf ng nh ni paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nd hw ne nf ng nh ni paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nd hw ne nf ng nh ni paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="lw lx ly"><p id="f922" class="jc jd lz je b jf jg jh ji jj jk jl jm ma jo jp jq mb js jt ju mc jw jx jy jz hn dt translated"><a class="ae ka" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ka" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ka" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ka" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd lz je b jf jg jh ji jj jk jl jm ma jo jp jq mb js jt ju mc jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ka" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ka" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="md me mf mg fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nj"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>