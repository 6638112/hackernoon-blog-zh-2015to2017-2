<html>
<head>
<title>Writing a Blog Engine in Phoenix and Elixir: Part 5, Adding ExMachina</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Phoenix和Elixir编写博客引擎:第5部分，添加ExMachina</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/mixology-exmachina-92a08dc3e954?source=collection_archive---------0-----------------------#2015-11-05">https://medium.com/hackernoon/mixology-exmachina-92a08dc3e954?source=collection_archive---------0-----------------------#2015-11-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="7fda" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">最新更新:</strong>2016年7月21日</p><h2 id="f2dd" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">本系列的前一篇文章</h2><div class="kk kl fm fo km kn"><a rel="noopener follow" target="_blank" href="/@diamondgfx/writing-a-blog-engine-in-phoenix-and-elixir-part-4-adding-roles-to-our-controllers-9f4678b48468"><div class="ko ab ej"><div class="kp ab kq cl cj kr"><h2 class="bd hv fv z el ks eo ep kt er et ht dt translated">用Phoenix和Elixir编写博客引擎:第4部分，向控制器添加角色</h2><div class="ku l"><h3 class="bd b fv z el ks eo ep kt er et ek translated">最新更新:2016年1月26日</h3></div><div class="kv l"><p class="bd b gc z el ks eo ep kt er et ek translated">medium.com</p></div></div><div class="kw l"><div class="kx l ky kz la kw lb lc kn"/></div></div></a></div><h2 id="de73" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">介绍</h2><p id="f5ce" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">由于我们一直在为我们的博客引擎编写代码，您可能已经注意到我们在代码库中使用了很少的库。这是双重的:首先，我们希望我要开始的第一个是<a class="ae li" href="https://github.com/thoughtbot/ex_machina" rel="noopener ugc nofollow" target="_blank"> ExMachina </a>，一个与Ruby的工厂女孩一脉相承的工厂库。</p><h2 id="63e3" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">当前版本</h2><p id="5ffb" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">在撰写本文时，我们应用程序的当前版本是:</p><ul class=""><li id="fe99" class="lj lk hu it b iu iv iy iz jc ll jg lm jk ln jo lo lp lq lr dt translated"><strong class="it hv">仙丹</strong> : v1.3.1</li><li id="4a40" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">凤凰城:1.2.0版</li><li id="dcb3" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated"><strong class="it hv"> Ecto: </strong> v2.0.2</li><li id="6ebd" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated"><strong class="it hv"> ExMachina </strong> : v1.0.2</li></ul><p id="c07c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你正在读这篇文章，而这些不是最新的，请告诉我，我会相应地更新这篇教程。</p><h2 id="2b42" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">这是什么？</h2><p id="2b0a" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">如前所述，ExMachina被设计成类似于Ruby的<a class="ae li" href="https://github.com/thoughtbot/factory_girl" rel="noopener ugc nofollow" target="_blank">工厂女孩</a>的工厂风格实现(也来自Thoughtbot的优秀人员)。这里的前提是，对于您的测试来说，有一种方法可以为您的测试建立各种模型及其关联，而不必一遍又一遍地为它们重写创建逻辑，这很好。这可以通过编写提供简单创建函数的助手模块来完成，但最终您不得不为每个变体、每个额外关联等创建函数和助手，这可能会有点重复。</p><h2 id="cd64" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">入门指南</h2><p id="7921" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">我们将首先打开<strong class="it hv"> mix.exs </strong>并将<strong class="it hv"> ExMachina </strong>引入我们的依赖项和应用程序列表。</p><p id="b923" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">将ExMachina添加到我们的依赖列表非常简单，所以我们只需在comeonin之后添加一个ExMachina条目。</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="6f1f" class="jp jq hu mc b fv mg mh l mi mj">defp deps do<br/>  [{:phoenix, "~&gt; 1.2.0"},<br/>   {:phoenix_pubsub, "~&gt; 1.0"},<br/>   {:phoenix_ecto, "~&gt; 3.0"},<br/>   {:postgrex, "&gt;= 0.0.0"},<br/>   {:phoenix_html, "~&gt; 2.6"},<br/>   {:phoenix_live_reload, "~&gt; 1.0", only: :dev},<br/>   {:gettext, "~&gt; 0.11"},<br/>   {:cowboy, "~&gt; 1.0"},<br/>   {:comeonin, "~&gt; 2.5.2"},<br/>   {:ex_machina, "~&gt; 1.0"}]<br/>end</span></pre><p id="1da2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，我们将把<strong class="it hv"> :ex_machina </strong>添加到我们的应用程序正在使用的应用程序列表中:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="6338" class="jp jq hu mc b fv mg mh l mi mj">def application do<br/>  [mod: {Pxblog, []},<br/>   applications: [:phoenix, :phoenix_pubsub, :phoenix_html, :cowboy, :logger, :gettext,<br/>                  :phoenix_ecto, :postgrex, :comeonin, :ex_machina]]<br/>end</span></pre><p id="6d42" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">运行以下命令，确保一切准备就绪并正确设置:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="c471" class="jp jq hu mc b fv mg mh l mi mj">$ mix do deps.get, compile</span></pre><p id="5a82" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果一切顺利，您应该会看到一些关于获取ExMachina的输出，最后一切都编译成功了！你也应该运行<strong class="it hv">混合测试</strong>并且在你开始修改之前验证一切都是绿色的，只是为了在这里保持额外的安全。</p><h2 id="9e4a" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">添加我们的第一个工厂:角色</h2><p id="0457" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">我们需要做的是创建一个工厂模块，并使它可以被我们所有的测试访问。我最喜欢的不使每个测试膨胀太多的方法是将包含工厂的模块文件放入<strong class="it hv">测试/支持</strong>中，然后专门将其导入到我们需要的测试中。</p><p id="f690" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以，让我们从创建<strong class="it hv">test/support/factory . ex</strong>开始:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="4fa6" class="jp jq hu mc b fv mg mh l mi mj">defmodule Pxblog.Factory do<br/>  use ExMachina.Ecto, repo: Pxblog.Repo<br/><br/>  alias Pxblog.Role<br/>  alias Pxblog.User<br/>  alias Pxblog.Post<br/><br/>  def role_factory do<br/>    %Role{<br/>      name: sequence(:name, &amp;"Test Role #{&amp;1}"),<br/>      admin: false<br/>    }<br/>  end<br/>end</span></pre><p id="6d6b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们称之为<strong class="it hv">工厂</strong>,因为这是这个模块要做的事情。然后，我们编写工厂函数，在atom上匹配构建/创建工厂的类型。因为它和《工厂女孩》很接近，所以它带有一些命名约定，值得注意。第一个是<strong class="it hv">构建</strong>:构建意味着我们正在构建模型(不是变更集)，但是没有将它持久化到数据库中。<strong class="it hv"> insert </strong>，但是，确实将模型持久化到数据库中。</p><p id="8b09" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们需要<strong class="it hv">使用ExMachina。Ecto </strong> bit告诉ExMachina我们使用Ecto作为我们的Repo层，它应该相应地执行create/associations/etc。我们还需要为所有的模型添加别名，因为我们将为所有的模型编写工厂。</p><p id="7142" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> role_factory </strong>函数应该只返回一个<strong class="it hv"> Role </strong> struct，它定义了我们希望它拥有的默认属性。此函数仅支持arity为1。</p><p id="9336" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里的序列位非常有趣。我们希望为每个角色生成一个惟一的名称，因此为了能够做到这一点，我们定义了一个顺序生成的名称。我们使用<strong class="it hv"> sequence </strong>函数，我们向它传递两个参数:第一个是我们要为其生成序列的字段的名称，第二个是匿名函数，它返回一个字符串并向其中插入一个值。让我们来看看这个函数:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="ccba" class="jp jq hu mc b fv mg mh l mi mj">&amp;”Test Role #{&amp;1}”</span></pre><p id="3198" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您对Elixir感到满意，您可能会认为这是编写匿名函数的另一种方式。这大致可以解释为:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="279c" class="jp jq hu mc b fv mg mh l mi mj">fn x -&gt;<br/>  "Test Role #{x}"<br/>end</span></pre><p id="7ecd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，如果我们考虑这个序列函数在做什么，它实际上只是在做这个:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="4dcb" class="jp jq hu mc b fv mg mh l mi mj">sequence(:name, fn x -&gt;<br/>  "Test Role #{x}"<br/>end)</span></pre><p id="2493" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我们将admin标志设置为false，因为我们将使用这些作为默认情况，并且只显式创建admin角色。稍后，我们还将讨论ExMachina的一些更复杂的选项。现在，我们将花一些时间将我们的新角色工厂集成到我们的控制器测试中。</p><h2 id="0029" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">改变我们的控制器测试来使用我们的角色工厂</h2><p id="54c1" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">首先打开<strong class="it hv">test/controllers/user _ controller _ test . exs</strong>。在顶部，在我们的<strong class="it hv">设置</strong>块中，我们将使用我们的<strong class="it hv"> TestHelper.create_role </strong>函数来修改这些位。</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="f15d" class="jp jq hu mc b fv mg mh l mi mj"># ...</span><span id="e7ce" class="jp jq hu mc b fv mk mh l mi mj">import Pxblog.Factory<br/><br/>@valid_create_attrs %{email: "test@test.com", username: "test", password: "test", password_confirmation: "test"}<br/>@valid_attrs %{email: "test@test.com", username: "test"}<br/>@invalid_attrs %{}<br/><br/>setup do<br/>  user_role = insert(:role)<br/>  {:ok, nonadmin_user} = TestHelper.create_user(user_role, %{email: "nonadmin@test.com", username: "nonadmin", password: "test", password_confirmation: "test"})<br/><br/>  admin_role = insert(:role, admin: true)<br/>  {:ok, admin_user}    = TestHelper.create_user(admin_role, %{email: "admin@test.com", username: "admin", password: "test", password_confirmation: "test"})<br/><br/>  {:ok, conn: build_conn(), admin_role: admin_role, user_role: user_role, nonadmin_user: nonadmin_user, admin_user: admin_user}<br/>end</span><span id="9f14" class="jp jq hu mc b fv mk mh l mi mj"># ...</span></pre><p id="2772" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们必须从<strong class="it hv">导入</strong>我们创建的工厂模块开始。第10行只是我们使用一个简单的角色使用<strong class="it hv">:角色</strong>工厂。第13行是我们使用相同的<strong class="it hv"> :role </strong>工厂，但是我们特别将admin标志重写为true。</p><p id="1928" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">保存文件并重新运行我们的测试，我们仍然是绿色的！现在，让我们实现我们的用户工厂，并引入一个也能构建关联的工厂！</p><h2 id="e9c9" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">添加我们的下一个工厂:用户</h2><p id="7f1c" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">让我们来看看用户的工厂。</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="e46e" class="jp jq hu mc b fv mg mh l mi mj">def user_factory do<br/>  %User{<br/>    username: sequence(:username, &amp;"User #{&amp;1}"),<br/>    email: "test@test.com",<br/>    password: "test1234",<br/>    password_confirmation: "test1234",<br/>    password_digest: Comeonin.Bcrypt.hashpwsalt("test1234"),<br/>    role: build(:role)<br/>  }<br/>end</span></pre><p id="02c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在很大程度上，这个工厂与我们为角色创建的工厂相匹配。我们首先要处理几个问题。在上面的第7行，您可以看到我们必须将password_digest值设置为散列密码值(因为我们模拟用户登录，所以您会希望包括这个值)。我们只是调用Comeonin下的Bcrypt模块，并专门调用hashpwsalt函数，向它传递我们在password/password_confirmation值中使用的相同密码。在第8行，我们还必须指定<strong class="it hv">角色</strong>实际上是一个关联；我们使用<strong class="it hv">构建</strong>函数，并通过原子传递我们想要为此构建的关联的名称。</p><p id="df9e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">修改完我们的用户工厂后，让我们回到<strong class="it hv">测试/控制器/用户_控制器_测试.实例</strong></p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="d8d7" class="jp jq hu mc b fv mg mh l mi mj">setup do<br/>  user_role     = insert(:role)<br/>  nonadmin_user = insert(:user, role: user_role)<br/><br/>  admin_role = insert(:role, admin: true)<br/>  admin_user = insert(:user, role: admin_role)<br/><br/>  {:ok, conn: build_conn(), admin_role: admin_role, user_role: user_role, nonadmin_user: nonadmin_user, admin_user: admin_user}<br/>end</span></pre><p id="26c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们已经用对工厂的调用完全替换了对TestHelper的所有调用。我们使用用户角色，并将其传递给我们的用户工厂，以便它知道使用哪个角色。然后我们对管理员用户做同样的事情，但是除此之外，我们根本不需要修改我们的测试！运行我们的测试，确保一切仍然是绿色的，然后我们可以继续进行！</p><h2 id="29f5" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">添加我们的下一个工厂:帖子</h2><p id="b790" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">既然我们已经非常擅长添加新工厂，那么为posts添加最终工厂应该非常简单。</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="5719" class="jp jq hu mc b fv mg mh l mi mj">def post_factory do<br/>  %Post{<br/>    title: "Some Post",<br/>    body: "And the body of some post",<br/>    user: build(:user)<br/>  }<br/>end</span></pre><p id="8b6b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里没有什么新东西，所以我们将直接修改<strong class="it hv">test/controllers/post _ controller _ test . exs</strong>:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="2905" class="jp jq hu mc b fv mg mh l mi mj"># ...</span><span id="45da" class="jp jq hu mc b fv mk mh l mi mj">import Pxblog.Factory<br/><br/>@valid_attrs %{body: "some content", title: "some content"}<br/>@invalid_attrs %{}<br/><br/>setup do<br/>  role = insert(:role)<br/>  user = insert(:user, role: role)<br/>  post = insert(:post, user: user)<br/>  conn = build_conn() |&gt; login_user(user)<br/>  {:ok, conn: conn, user: user, role: role, post: post}<br/>end</span><span id="e95b" class="jp jq hu mc b fv mk mh l mi mj"># ...</span></pre><p id="363b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们再一次<strong class="it hv">导入</strong> <strong class="it hv"> Pxblog。工厂</strong>所以我们的模块知道工厂调用来自哪里。然后，我们用工厂调用代替setup块中的所有创建步骤。<strong class="it hv">角色</strong>由我们的<strong class="it hv"> insert </strong>语句填充，该语句创建我们的角色，然后用于从工厂构建我们的用户，最后该用户用于创建与该用户相关联的帖子…仅此而已！再次运行我们的测试，它又变回绿色了！</p><p id="29ee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">超过这一点，其他一切都只是繁重的工作；返回并用工厂调用替换对TestHelper的调用。这没有什么特别新的或令人兴奋的，所以我不会为每个细节而烦恼。</p><h2 id="6f1d" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">包含您的工厂的其他方式</h2><p id="70a2" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">我选择了将我的工厂显式导入到我的每个测试中的路线，但是如果您不想这样做，您可以改为执行以下操作之一:</p><p id="fa61" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">将我们的别名语句添加到<strong class="it hv">test/support/model _ case . ex:</strong>中的using块中</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="e1f4" class="jp jq hu mc b fv mg mh l mi mj">using do<br/>  quote do<br/>    alias Pxblog.Repo</span><span id="b975" class="jp jq hu mc b fv mk mh l mi mj">    import Ecto<br/>    import Ecto.Changeset<br/>    import Ecto.Query<br/>    import Pxblog.ModelCase<br/>    import Pxblog.Factory<br/>  end<br/>end</span></pre><p id="238e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">和<strong class="it hv">test/support/conn _ case . ex:</strong></p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="78f4" class="jp jq hu mc b fv mg mh l mi mj">using do<br/>  quote do<br/>    # Import conveniences for testing with connections<br/>    use Phoenix.ConnTest<br/><br/>    alias Pxblog.Repo<br/>    import Ecto<br/>    import Ecto.Changeset<br/>    import Ecto.Query<br/><br/>    import Pxblog.Router.Helpers<br/>    import Pxblog.Factory<br/><br/>    # The default endpoint for testing<br/>    @endpoint Pxblog.Endpoint<br/>  end<br/>end</span></pre><h2 id="4ac7" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">您可以使用Ex玛奇纳执行的其他功能</h2><p id="3cc1" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">出于我们正在编写的小博客引擎的目的，我们并不明确需要ExMachina提供的一些现成的其他特性。例如，为了方便起见，build和create都支持一些其他函数(我使用build作为例子，但是这些函数也支持create):</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="1a3f" class="jp jq hu mc b fv mg mh l mi mj">build_pair(:factory, attrs)    &lt;- Builds 2 models<br/>build_list(n, :factory, attrs) &lt;- Builds N models</span></pre><p id="460b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您还可以通过对模型调用create来持久化使用工厂构建方法的模型:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="d272" class="jp jq hu mc b fv mg mh l mi mj">build(:role) |&gt; insert</span></pre><h2 id="34e8" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">其他资源</h2><p id="2095" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">有关如何使用ExMachina的更多信息，请访问Github页面(<a class="ae li" href="https://github.com/thoughtbot/ex_machina" rel="noopener ugc nofollow" target="_blank">https://github.com/thoughtbot/ex_machina</a>)。你也可以访问thoughtbot的技术博客，那里的创造者写了一篇很棒的文章，宣布了ExMachina和其他一些使用它的方法！问题岗位在https://robots.thoughtbot.com/announcing-ex-machina<a class="ae li" href="https://robots.thoughtbot.com/announcing-ex-machina" rel="noopener ugc nofollow" target="_blank"/>。</p><h2 id="d245" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">包扎</h2><p id="8bb9" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">不可否认的是，起初我有点担心，因为我已经看到了一些过去在《工厂女孩》中实现的事情，我害怕马上回到同样的场景，但Elixir在保护我们免受自己伤害方面做得如此好，我认为它相当好地平衡了。语法清晰明了，我不得不编写的代码量大幅下降，而且它让我们的测试更加轻松，所以总体来说我非常满意。非常感谢Thoughtbot的优秀员工给我们提供了另一个非常方便的库。</p><p id="5386" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我也很想知道人们对这篇文章的看法。我一直在考虑发表一系列关于Elixir和Phoenix的不同库的文章，ExMachina似乎是一个很好的开始！你通常可以在Elixir Slack群或Elixir IRC聊天室找到我，当然你也可以在Twitter @ diamond gfx上找到我。</p><h2 id="33fc" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">本系列的下一篇文章</h2><div class="kk kl fm fo km kn"><a rel="noopener follow" target="_blank" href="/@diamondgfx/writing-a-blog-engine-in-phoenix-and-elixir-part-5-markdown-support-fde72badd8e1"><div class="ko ab ej"><div class="kp ab kq cl cj kr"><h2 class="bd hv fv z el ks eo ep kt er et ht dt translated">用Phoenix和Elixir编写博客引擎:第6部分，降价支持</h2><div class="ku l"><h3 class="bd b fv z el ks eo ep kt er et ek translated">最新更新:2016年1月26日</h3></div><div class="kv l"><p class="bd b gc z el ks eo ep kt er et ek translated">medium.com</p></div></div><div class="kw l"><div class="ml l ky kz la kw lb lc kn"/></div></div></a></div><h1 id="26e6" class="mm jq hu bd jr mn mo mp jv mq mr ms jz mt mu mv kc mw mx my kf mz na nb ki nc dt translated">看看我的新书！</h1><p id="8477" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">嘿大家好！如果你喜欢你在这里读到的东西，并且想和我一起学习更多，可以看看我的新书《长生不老药和凤凰网开发》:</p><div class="kk kl fm fo km kn"><a href="https://www.packtpub.com/web-development/phoenix-web-development" rel="noopener  ugc nofollow" target="_blank"><div class="ko ab ej"><div class="kp ab kq cl cj kr"><h2 class="bd hv fv z el ks eo ep kt er et ht dt translated">凤凰网开发| PACKT图书</h2><div class="ku l"><h3 class="bd b fv z el ks eo ep kt er et ek translated">学习使用Elixir和……从头开始构建投票web应用程序的高性能功能原型</h3></div><div class="kv l"><p class="bd b gc z el ks eo ep kt er et ek translated">www.packtpub.com</p></div></div><div class="kw l"><div class="nd l ky kz la kw lb lc kn"/></div></div></a></div><p id="1687" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我真的很兴奋终于可以把这个项目推向世界了！它的写作风格与我的其他教程一样，我们将从头到尾构建一个完整项目的框架，甚至涵盖一些更棘手的主题，如文件上传、Twitter/Google OAuth登录和API！</p><blockquote class="ne nf ng"><p id="5c3d" class="ir is nh it b iu iv iw ix iy iz ja jb ni jd je jf nj jh ji jj nk jl jm jn jo hn dt translated"><a class="ae li" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae li" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae li" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae li" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is nh it b iu iv iw ix iy iz ja jb ni jd je jf nj jh ji jj nk jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae li" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae li" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae li" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is nh it b iu iv iw ix iy iz ja jb ni jd je jf nj jh ji jj nk jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae li" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae li" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>