<html>
<head>
<title>Build Your Own React — A Step By Step Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建您自己的React —逐步指南</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/build-your-own-react-48edb8ed350d?source=collection_archive---------1-----------------------#2017-09-22">https://medium.com/hackernoon/build-your-own-react-48edb8ed350d?source=collection_archive---------1-----------------------#2017-09-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/f3889380f6fed24185329b0c0df07cf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HSisLuifMO6KbLfPOKtLow.jpeg"/></div></div></figure><p id="e1d2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">摘要- </strong>在这篇文章中，我将一步一步地创建一个完整的工作版本<a class="ae ka" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank"> react </a>。这不会是一个有效的版本，但它让你一瞥反应如何在引擎盖下工作。如果你熟悉react / web / dom等..您可以直接跳到步骤1。或者，如果你喜欢视频，你可以在youtube上查看我的演讲。</p><p id="4e37" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">简介</strong></p><p id="e839" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在编写react应用程序之前，和许多其他人一样，我用angular编写。关于angular的事情是，如果你想成为一名优秀的angular开发者，你需要知道angular是如何工作的。你知道的越多，你就会越好。但是使用react，情况似乎不是这样。您将了解类组件和无状态组件。你学习道具和状态，你永远不应该改变道具。然后你了解到，如果你想要一些动态的东西，你可以调用<code class="eh kb kc kd ke b">setState</code>就差不多了。除了生命周期方法和其他小特性，你不需要太多来编写好的react应用。毫无疑问，react vs angular的学习曲线要小得多。</p><p id="99c1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是，我成为了一名程序员，因为我喜欢了解事物是如何工作的。是什么让事情运转。不管是国际空间站、特斯拉汽车还是自动售货机。当我看到我感兴趣的东西时，在我开始质疑它的工作原理后不久。react也是如此。我看到一个关于引擎盖下反应的精彩演讲，我心想..这看起来并不复杂..我可以试试。</p></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><p id="7067" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">react到底是什么？</strong></p><p id="f5da" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们开始写react之前，我们应该知道我们想要构建什么。在我看来，react是一个构建动态树的库。在web用例中，react将构建一个DOM树。然而，它不一定是DOM。通过<a class="ae ka" href="https://facebook.github.io/react-native/" rel="noopener ugc nofollow" target="_blank"> react native </a>，react构建了ui控制器的原生应用层级。你甚至可以在react中编写<a class="ae ka" href="https://github.com/iamdustan/react-hardware" rel="noopener ugc nofollow" target="_blank"> arduino应用</a>。</p><p id="f33e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">什么是DOM树？</p><p id="8003" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">DOM代表文档对象模型。每个html文档都是由称为“dom元素”的元素构建的。<code class="eh kb kc kd ke b"><em class="km">&lt;html&gt;</em></code>是一个dom元素。还有<code class="eh kb kc kd ke b"><em class="km">&lt;div&gt;</em></code>和<code class="eh kb kc kd ke b"><em class="km">&lt;h1&gt;</em></code>等。树有一个根，通常是html标签。树中的每个节点都有自己的属性，并且可能有同样是dom元素的子节点。比如说。在下图中，您可以看到html文档的一部分及其作为对象树的表示形式。</p><figure class="ko kp kq kr fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kn"><img src="../Images/1c423f0f6ef22c651fd01fcc82338836.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*de8SJEwnxDCBfLw9Jq4ZdA.png"/></div></div></figure><p id="b1cb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">简单说说react和jsx </strong></p><p id="17d8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您已经熟悉react，您可能会使用jsx。因此，一个简单的组件可能是这样的:</p><pre class="ko kp kq kr fq ks ke kt ku aw kv dt"><span id="3f6d" class="kw kx hu ke b fv ky kz l la lb">const mySimpleComponent = () =&gt; {<br/> return &lt;h1&gt;Hello World&lt;/h1&gt;;<br/>}</span></pre><p id="7f60" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">运行babel或您喜欢的其他transpiler之后，这个组件将如下所示:</p><pre class="ko kp kq kr fq ks ke kt ku aw kv dt"><span id="ceee" class="kw kx hu ke b fv ky kz l la lb">const mySimpleComponent = () =&gt; {<br/> return React.createElement(‘h1’, null, `Hello World`);<br/>}</span></pre><p id="2e6f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个特殊的babel插件将把jsx调用传输到react提供的底层js api。在我们的例子中，<code class="eh kb kc kd ke b">&lt;h1&gt;</code>标记被转换成一个<code class="eh kb kc kd ke b">React.createElement</code>调用，其中第一个参数是标记名，第二个参数是属性，第三个参数是它的孩子。</p><p id="a866" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看一个稍微复杂一点的jsx例子:</p><pre class="ko kp kq kr fq ks ke kt ku aw kv dt"><span id="456c" class="kw kx hu ke b fv ky kz l la lb">&lt;div style={{color: yellow}}&gt;<br/>  &lt;Title text=`I'm a title`/&gt;<br/>  &lt;Person name=`moki`/&gt;<br/>&lt;/div&gt;</span></pre><p id="44a4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这将导致:</p><pre class="ko kp kq kr fq ks ke kt ku aw kv dt"><span id="7c1e" class="kw kx hu ke b fv ky kz l la lb">React.createElement(`div`, {style: {color: yellow}},<br/>  React.createElement(Title, {text: `I'm a title`}, null),<br/>  React.createElement(Person, {name: `moki`}, null)<br/>);</span></pre><p id="4c69" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们已经同步了，我们可以开始构建我们自己的react。</p></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><h1 id="358b" class="lc kx hu bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly dt translated"><strong class="ak">步骤1- DOM元素(Hello World) </strong></h1><p id="38d5" class="pw-post-body-paragraph jc jd hu je b jf lz jh ji jj ma jl jm jn mb jp jq jr mc jt ju jv md jx jy jz hn dt translated">首先，我将为我的应用程序创建一个主机html文档。它将加载我的<code class="eh kb kc kd ke b">react.js</code>版本，<code class="eh kb kc kd ke b">app.js</code>用于应用程序的逻辑，并且它将有一个id为<code class="eh kb kc kd ke b">root</code>的div来附加我的react应用程序。</p><figure class="ko kp kq kr fq iv"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="a00e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们构建react的方式将会是我喜欢称之为ADD的方式。它类似于TDD，但是它代表应用驱动开发，而不是测试驱动开发。在每一步中，我将显示我想要渲染的<code class="eh kb kc kd ke b">app.js</code>。然后我在<code class="eh kb kc kd ke b">react.js</code>文件中实现。</p><p id="be02" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我的第一个<code class="eh kb kc kd ke b">app.js</code>长这样:</p><figure class="ko kp kq kr fq iv"><div class="bz el l di"><div class="me mf l"/></div><figcaption class="mg mh fg fe ff mi mj bd b be z ek">step1-app.js</figcaption></figure><p id="4ad5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了让这段代码工作，我需要实现<code class="eh kb kc kd ke b">React.createElement</code>和<code class="eh kb kc kd ke b">ReactDOM.render</code></p><p id="2f26" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">ReactDOM是一个独立于react的模块，但是为了简单起见，我将它们放在一起编写。</p><p id="8489" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们开始吧。这是我的<code class="eh kb kc kd ke b">react.js</code>:</p><figure class="ko kp kq kr fq iv"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="361f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的hello world正在运行！你可以在这里看到结果<a class="ae ka" href="https://cdn.rawgit.com/ofirdagan/build-your-own-react/2e8bad05/v1-element/index.html" rel="noopener ugc nofollow" target="_blank"><em class="km"/></a>。</p></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><h1 id="e843" class="lc kx hu bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly dt translated"><strong class="ak">第二步——渲染非DOM元素，或者我们喜欢在react中称之为“组件”</strong></h1><p id="cf5f" class="pw-post-body-paragraph jc jd hu je b jf lz jh ji jj ma jl jm jn mb jp jq jr mc jt ju jv md jx jy jz hn dt translated">我们想增加对无状态组件的支持</p><p id="03ae" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kb kc kd ke b">app.js</code>:</p><figure class="ko kp kq kr fq iv"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="d5bc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里唯一改变的是现在<code class="eh kb kc kd ke b">element</code>可以是一个函数。如果是的话，我们会调用它。</p><p id="13d6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kb kc kd ke b">react.js</code>:</p><figure class="ko kp kq kr fq iv"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="5eb9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="km"> * </em> <a class="ae ka" href="https://cdn.rawgit.com/ofirdagan/build-your-own-react/2e8bad05/v2-non-dom-element/v2-step1/index.html" rel="noopener ugc nofollow" target="_blank"> <em class="km">结果</em> </a></p><p id="9029" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不是所有的孩子生来都一样。我们希望增加对非纯文本儿童的支持。让我们改进对待孩子的方式。</p><p id="2217" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kb kc kd ke b">app.js</code>:</p><figure class="ko kp kq kr fq iv"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="c42f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kb kc kd ke b">react.js</code>:</p><figure class="ko kp kq kr fq iv"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="2d15" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://cdn.rawgit.com/ofirdagan/build-your-own-react/2e8bad05/v2-non-dom-element/v2-step2-dom-children/index.html" rel="noopener ugc nofollow" target="_blank"><em class="km">*结果</em> </a></p><p id="61ed" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 2.3 </strong> -增加对类组件的支持</p><p id="c25d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kb kc kd ke b">app.js</code>:</p><figure class="ko kp kq kr fq iv"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="7cbc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就像我们处理无状态组件一样。我们将确定它是否是一个类，如果是，我们将创建一个新的类实例并调用它的渲染函数。</p><p id="cf71" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kb kc kd ke b">react.js:</code></p><figure class="ko kp kq kr fq iv"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="2418" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="km"> * </em> <a class="ae ka" href="https://cdn.rawgit.com/ofirdagan/build-your-own-react/2e8bad05/v2-non-dom-element/v2-step3-classes/index.html" rel="noopener ugc nofollow" target="_blank"> <em class="km">结果</em> </a></p><p id="cb1f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">是时候做一些旧的重构了。我们的<code class="eh kb kc kd ke b">anElement</code>函数太长了。下面我们摘录一些方法出来。同样，让我们为其他函数创建一个<code class="eh kb kc kd ke b">react-utils.js</code>，比如<code class="eh kb kc kd ke b">isClass</code>、<code class="eh kb kc kd ke b">isStatelessComponent</code>等..</p></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><h1 id="461e" class="lc kx hu bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly dt translated"><strong class="ak">步骤3-道具和状态</strong></h1><p id="09e9" class="pw-post-body-paragraph jc jd hu je b jf lz jh ji jj ma jl jm jn mb jp jq jr mc jt ju jv md jx jy jz hn dt translated">概括地说，到目前为止，我们呈现了dom元素、无状态组件和类组件。让我们添加道具和状态</p><p id="5671" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 3.1- </strong>无状态组件道具</p><p id="e4c7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kb kc kd ke b">app.js</code>:</p><figure class="ko kp kq kr fq iv"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="5808" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个很简单。我们只需要将道具传递给组件(函数)</p><p id="0adc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kb kc kd ke b">react.js</code>:</p><figure class="ko kp kq kr fq iv"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="bf2c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="km"> * </em> <a class="ae ka" href="https://cdn.rawgit.com/ofirdagan/build-your-own-react/2e8bad05/v3-props-and-state/v3-step1-stateless-comp-props/index.html" rel="noopener ugc nofollow" target="_blank"> <em class="km">结果</em> </a></p><p id="b735" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 3.2- </strong>类构件道具</p><p id="62e5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kb kc kd ke b">app.js</code>:</p><figure class="ko kp kq kr fq iv"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="c97e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你应该注意到<code class="eh kb kc kd ke b">Hello</code>类现在扩展了<code class="eh kb kc kd ke b">React.Component</code>。我这样做是为了让我的所有react类都有一个公共的父类，以便在类实例上分配道具。</p><p id="6b3c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kb kc kd ke b">Component</code>类别:</p><figure class="ko kp kq kr fq iv"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="774c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们有了组件类，我们将在构造函数中传递属性，这样就完成了。</p><figure class="ko kp kq kr fq iv"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="d3a1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 3.3- </strong>属性</p><p id="7478" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个简单的组件应该显示一个按钮点击警告。</p><p id="f6bc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kb kc kd ke b">app.js</code>:</p><figure class="ko kp kq kr fq iv"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="a959" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">与子节点一样，我们将遍历属性，并将事件侦听器设置为以on*开头的属性，并将其余属性设置为attribute。</p><p id="7a8f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kb kc kd ke b">react.js</code>:</p><figure class="ko kp kq kr fq iv"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="8073" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="km"> * </em> <a class="ae ka" href="https://cdn.rawgit.com/ofirdagan/build-your-own-react/2e8bad05/v3-props-and-state/v3-step3-attributes/index.html" rel="noopener ugc nofollow" target="_blank"> <em class="km">结果</em> </a></p><p id="6c6c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 3.4- </strong>重构。<code class="eh kb kc kd ke b">handleHtmlElement</code>变得太大。我们将提取出<code class="eh kb kc kd ke b">appendChild</code>和<code class="eh kb kc kd ke b">appendProp</code>函数。我们也可以使用lodash稍微清理一下代码。</p><p id="b11c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 3.5- </strong>状态</p><p id="9d33" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们已经准备好编写一个真正的react应用程序。我们来写一个计数器app。它将有两个按钮来增加和减少计数器，并将显示当前值</p><p id="98d6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kb kc kd ke b">app.js</code>:</p><figure class="ko kp kq kr fq iv"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="29ec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了完成这项工作，我们需要实现<code class="eh kb kc kd ke b">setState</code>函数。我的简单算法会在每次<code class="eh kb kc kd ke b">setState</code>调用时删除整个dom，并再次渲染它。为此，我需要保存对根react元素和根dom元素的引用。</p><p id="12ee" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kb kc kd ke b">react.js</code></p><figure class="ko kp kq kr fq iv"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="bcd3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我想保存我已经创建的类，这样当<code class="eh kb kc kd ke b">reRender </code>发生时，我就不会再创建它们并丢失我的状态。为了实现这一目标，我将采取以下措施:</p><ul class=""><li id="2a3c" class="mk ml hu je b jf jg jj jk jn mm jr mn jv mo jz mp mq mr ms dt translated">保存实例化类的缓存</li><li id="e5b9" class="mk ml hu je b jf mt jj mu jn mv jr mw jv mx jz mp mq mr ms dt translated">当处理一个类时。如果匹配，则返回缓存的实例</li><li id="5700" class="mk ml hu je b jf mt jj mu jn mv jr mw jv mx jz mp mq mr ms dt translated">不要直接调用render，而是返回一个带有特殊标志的对象，将它标记为react类。</li><li id="24c7" class="mk ml hu je b jf mt jj mu jn mv jr mw jv mx jz mp mq mr ms dt translated">追加子节点时。如果是react类，调用它的render</li></ul><p id="aa9d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kb kc kd ke b">handleClass</code>:</p><figure class="ko kp kq kr fq iv"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="4901" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kb kc kd ke b">handleChild</code>:</p><figure class="ko kp kq kr fq iv"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="6a87" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="km"> * </em> <a class="ae ka" href="https://cdn.rawgit.com/ofirdagan/build-your-own-react/2e8bad05/v3-props-and-state/v3-step5-state/index.html" rel="noopener ugc nofollow" target="_blank"> <em class="km">结果</em> </a></p><p id="0781" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就是这样。我们有自己的工作反应。不相信我？看看我从网上下载的这个待办事项应用程序。除了对real react和react-dom的引用，我没有做任何修改。</p><p id="e126" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">todo应用没给你留下太多印象？<a class="ae ka" href="https://cdn.rawgit.com/ofirdagan/build-your-own-react/2e8bad05/v5-examples/v5-step2-minesweeper/index.html" rel="noopener ugc nofollow" target="_blank">这款扫雷游戏</a>怎么样？</p><p id="a15b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">现在怎么办？</strong></p><p id="2316" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们稍微思考一下我给你们展示的内容。我写的react版本…好像不是超级高效。每次调用<code class="eh kb kc kd ke b">setState</code>时，我都清除整个dom并从头开始创建它。另外，当有人谈论react如何工作时，你首先听到的是神秘的虚拟dom。我没有在代码中写任何虚的东西，也没有提到它。</p><p id="a397" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">是时候面对现实了</strong></p><p id="228a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">是时候进行一些性能分析了。我用我的反应和真实的反应计算了扫雷游戏第一次渲染的时间。结果会让你大吃一惊。</p><p id="d103" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">看起来我的react比真实的react做得好2.5倍。但是让我们耐心等一会儿。如果我们继续玩，我们可以看到每一个<code class="eh kb kc kd ke b">setState</code>完成所花的时间。我的react需要2-8毫秒，而真正的react需要0.01毫秒。这种差异就是为什么我们喜欢react并经常使用它。除了超级直观，简单易学之外，它非常快，而且越来越快。</p><p id="1285" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">react算法</strong></p><p id="d107" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先是我的算法:每次重新渲染时</p><ul class=""><li id="577b" class="mk ml hu je b jf jg jj jk jn mm jr mn jv mo jz mp mq mr ms dt translated">清除dom</li><li id="2067" class="mk ml hu je b jf mt jj mu jn mv jr mw jv mx jz mp mq mr ms dt translated">从头开始呈现DOM</li></ul><p id="6386" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们看代码，我们会发现我们写的所有东西都是javascript。我们没有使用任何html或其他语言。如果我们不是直接创建dom元素，而是保留一个由javascript对象构成的dom树模型，那又会怎样呢？将我们的DOM表示为javascript对象非常容易，对吗？我们一开始就看到了。</p><p id="f37e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以更好的算法是:</p><ul class=""><li id="78d4" class="mk ml hu je b jf jg jj jk jn mm jr mn jv mo jz mp mq mr ms dt translated">在js树模型上调用render</li><li id="4512" class="mk ml hu je b jf mt jj mu jn mv jr mw jv mx jz mp mq mr ms dt translated">读取当前dom</li><li id="1e01" class="mk ml hu je b jf mt jj mu jn mv jr mw jv mx jz mp mq mr ms dt translated">找出变化</li><li id="71b3" class="mk ml hu je b jf mt jj mu jn mv jr mw jv mx jz mp mq mr ms dt translated">仅在dom上应用这些更改</li></ul><p id="53d9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这会让事情变得更快。但我们比那更聪明。我们希望尽可能减少对dom的读写。我们已经有了一个js树模型(让我们从现在开始称之为虚拟dom ),它反映了我们的dom应该是什么样子。</p><p id="3e95" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以我们可以有一个更好的算法。在重新渲染时，这里的想法是有两个虚拟dom，一个总是代表当前的dom，另一个将代表未来的DOM。在reRender上:</p><ul class=""><li id="07e0" class="mk ml hu je b jf jg jj jk jn mm jr mn jv mo jz mp mq mr ms dt translated">创建新的虚拟dom</li><li id="2e45" class="mk ml hu je b jf mt jj mu jn mv jr mw jv mx jz mp mq mr ms dt translated">找出它和当前虚拟dom之间的区别(两个js树之间的区别可以很快完成)</li><li id="eccb" class="mk ml hu je b jf mt jj mu jn mv jr mw jv mx jz mp mq mr ms dt translated">仅应用真实dom上的更改</li></ul><p id="b9e0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将差异合并到真正的dom树中的过程称为协调。这就是react真正的工作方式。</p><p id="86dd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">纤维</strong></p><p id="da68" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可能听说过<code class="eh kb kc kd ke b">fiber</code>。纤程是react的人正在研究的新的协调算法。应该很快就出来了。光纤背后的想法很简单。到目前为止，协调过程是线性的。一旦开始，你就无法停止。光纤旨在改变这种情况。它的动机是优先权。我们意识到有些变化比其他变化更重要。例如，如果您有一个需要更改的文本节点和一个需要绘制的动画。重要的是你要先画出动画，否则用户会注意到ui滞后。如果文本节点在几毫秒的延迟后改变，用户不会注意到。纤程有一个内置的中断机制。把它想象成一个暂停按钮。在和解期间的任何给定时刻。React可以告诉fiber暂停，进行动画等其他计算，然后继续。这将使我们的应用程序看起来更加流畅。</p><p id="9b6f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它的美妙之处在于它对开发者完全透明。协调算法是一个实现细节。我们从我自己糟糕的实现中看到了这一点。这些应用程序工作正常，但不是很好..react API的简单性和实现的复杂性使得它成为如此强大的工具。</p><p id="1e0e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你在这篇文章中看到的所有代码都可以在<a class="ae ka" href="https://github.com/ofirdagan/build-your-own-react" rel="noopener ugc nofollow" target="_blank">这里</a>找到。如果你有任何问题或只是想打声招呼，请在推特上联系我，电话:)</p><figure class="ko kp kq kr fq iv"><div class="bz el l di"><div class="my mf l"/></div></figure></div></div>    
</body>
</html>