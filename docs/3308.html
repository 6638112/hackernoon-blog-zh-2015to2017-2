<html>
<head>
<title>Middleware: THE core of node.js backend apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">中间件:node.js后端应用的核心</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/middleware-the-core-of-node-js-apps-ab01fee39200?source=collection_archive---------1-----------------------#2017-03-26">https://medium.com/hackernoon/middleware-the-core-of-node-js-apps-ab01fee39200?source=collection_archive---------1-----------------------#2017-03-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="9cc2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我做node/express应用已经有一段时间了。我交谈过的许多其他人也喜欢它的简单性，他们可能使用不同的框架，如哈比神，但在核心上，他们非常相似。核心概念之一是中间件。我很少看到初学者充分发挥它们的潜力，所以我想分享我的观点，为什么我认为它们是任何后端应用程序最重要的核心。</p><h1 id="975b" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">概念</h1><p id="730e" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated"><a class="ae jp" href="https://hackernoon.com/tagged/middleware" rel="noopener ugc nofollow" target="_blank">中间件</a>在您的路由处理器执行之前运行。你可能已经使用了一些中间件，例如<a class="ae jp" href="https://www.npmjs.com/package/body-parser" rel="noopener ugc nofollow" target="_blank"> bodyParser </a>。可以用各种方式插入，但概念是一样的。它用额外的信息增加了您的请求对象，并且它也已经可以响应客户端，但是您的路由处理程序可以(但不是必须)在之后被调用。</p><h2 id="fee1" class="kt jr hu bd js ku kv kw jw kx ky kz ka jc la lb ke jg lc ld ki jk le lf km lg dt translated">中间件定义</h2><p id="0603" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">一个功能很少的基本中间件如下所示:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="dbfd" class="kt jr hu lm b fv lq lr l ls lt">function emptyMiddleware (req, res, next) {<br/>  req.somedata = 42<br/>  next()<br/>}</span></pre><p id="d95e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">中间件基本上是一个接收请求和响应对象的功能，就像路由处理器一样。作为第三个参数，你有另一个函数，一旦你的中间件代码完成，你应该调用它。这意味着您可以等待异步数据库或网络操作完成，然后再继续下一步。这可能如下所示:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="9ddc" class="kt jr hu lm b fv lq lr l ls lt">function myMiddleware (req, res, next) {<br/>  getSomeData()<br/>  .then(function (data) {<br/>    req.somedata = data<br/>    next()<br/>  })<br/>}</span></pre><p id="732d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果有一个错误，并且您不想执行任何进一步的代码，就不要调用那个函数。请记住在这种情况下发送响应，否则客户端将一直等待响应，直到超时:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="73fc" class="kt jr hu lm b fv lq lr l ls lt">function myMiddleware (req, res, next) {<br/>  getSomeData()<br/>  .then(function (data) {<br/>    req.somedata = data<br/>    next()<br/>  })<br/>  .catch(function (error) {<br/>    res.status(500).send(error.message)<br/>  })<br/>}</span></pre><h2 id="e221" class="kt jr hu bd js ku kv kw jw kx ky kz ka jc la lb ke jg lc ld ki jk le lf km lg dt translated">中间件的使用</h2><p id="3d79" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">然后，您可以以各种方式使用中间件，最简单的方式是全局使用您的所有路线:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="404e" class="kt jr hu lm b fv lq lr l ls lt">var app = express()<br/>app.use(myMiddleware)<br/><br/>//your normal route Handlers<br/>app.get('/someroute', handler)<br/>...</span></pre><p id="4c03" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一种选择是仅针对特定路径包含它:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="c4c5" class="kt jr hu lm b fv lq lr l ls lt">app.use('/withmiddleware', myMiddleware)</span><span id="e0dd" class="kt jr hu lm b fv lu lr l ls lt">//route handlers without middleware<br/>app.get('/someroute', handler)<br/>//routes with middleware<br/>app.get('/withmiddleware/someroute', handler)</span></pre><p id="14f8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第三个选项通常被忽略，它直接位于路由处理程序中:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="f8ce" class="kt jr hu lm b fv lq lr l ls lt">//middlewares passed as array in second argument to a route definition<br/>app.get('/someroute', [myMiddleware], handler)</span></pre><p id="4e2a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">无论如何，路由处理程序现在接收到增加的请求对象:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="d797" class="kt jr hu lm b fv lq lr l ls lt">var handler = function (req, res) {<br/>  console.log(req.somedata) //prints out what was inserted by the middleware<br/>}</span></pre><p id="e51f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">中间件可以访问在执行时解析的所有请求参数。因此，全局中间件没有任何“req.params”选项，而具有特定路径的中间件或插入到路由定义中的中间件具有在该路径或路由中定义的所有参数。这在很多情况下非常方便，请看下一部分的例子。</p><h2 id="ff4f" class="kt jr hu bd js ku kv kw jw kx ky kz ka jc la lb ke jg lc ld ki jk le lf km lg dt translated">中间件链接</h2><p id="205f" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">您可以在上面最后一个示例中显示的中间件数组中或者通过使用多个app.use调用来链接中间件:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="06c2" class="kt jr hu lm b fv lq lr l ls lt">app.use(middlewareA)<br/>app.use(middlewareB)<br/>app.get('/', [middlewareC, middlewareD], handler)</span></pre><p id="81ce" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">中间件将按照它们的使用调用顺序或它们在数组中的顺序执行。此外，它们将从以前的中间件接收增强的请求对象，因此它们可以依赖彼此的功能，就像您的自定义中间件被插入到bodyParser之后，从而能够使用被解析的主体。</p><h1 id="92b0" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">中间件使用示例</h1><p id="76ca" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在这里，我想快速展示一些我认为中间件可以用来真正改善你的代码的方法。所有这些背后的基本思想是减少路由处理程序中的重复代码。</p><h2 id="f635" class="kt jr hu bd js ku kv kw jw kx ky kz ka jc la lb ke jg lc ld ki jk le lf km lg dt translated">从数据库中检索重要对象</h2><p id="9255" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">一个常见的体系结构是有许多以某种方式操作或输出同一数据库对象的数据的路由，因此可以使用中间件来检索该对象，如果找不到该对象或不允许访问，就会出错:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="1435" class="kt jr hu lm b fv lq lr l ls lt">function dbMiddleware (req, res, next) {<br/>  getFromDb(req.params.id) //see app.get below<br/>  .then(function(data) {<br/>    req.dbData = data<br/>    next()<br/>  })<br/>  .catch(function (error) {<br/>    res.status(500).end() //replace with proper error handling<br/>  })<br/>}</span><span id="bbeb" class="kt jr hu lm b fv lu lr l ls lt">app.get('/data/:id', [dbMiddleware], handler)</span></pre><p id="64b9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在前面的示例中，只有当数据成功添加到请求对象中时，才会调用处理程序，因此这里不需要进一步的错误处理或数据库代码。还要注意我是如何使用路由的id值的。</p><h2 id="c6de" class="kt jr hu bd js ku kv kw jw kx ky kz ka jc la lb ke jg lc ld ki jk le lf km lg dt translated">证明</h2><p id="ea07" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">最常见的例子是身份验证，因此您可以在所有路由中引用当前用户对象:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="e0d0" class="kt jr hu lm b fv lq lr l ls lt">function userMiddleware (req, res, next) {<br/>  getUserViaJWT(req.headers.authentication)<br/>  .then(function(user) {<br/>    req.user = user<br/>    next()<br/>  })<br/>  .catch(function (error) {<br/>    res.status(401).end() //replace with proper error handling<br/>  })<br/>}</span><span id="6e3e" class="kt jr hu lm b fv lu lr l ls lt">app.use(userMiddleware)</span><span id="ed7c" class="kt jr hu lm b fv lu lr l ls lt">app.get('/someroute', handler)</span></pre><p id="1ecc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该中间件只是解析一个身份验证头，并使用它来确定哪个用户当前登录，并将它添加到请求对象中。同样，如果有错误，它只会结束响应，而不会调用后续的中间件或路由处理程序。</p><h2 id="4e22" class="kt jr hu bd js ku kv kw jw kx ky kz ka jc la lb ke jg lc ld ki jk le lf km lg dt translated">记录</h2><p id="1c69" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">您还可以使用中间件进行日志记录，如下所示，以记录用户的最新活动，这可以与以前的中间件结合使用，以获取用户对象:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="b84e" class="kt jr hu lm b fv lq lr l ls lt">function logMiddleware (req, res, next) {<br/>  logLastActiveAt(req.user.id, new Date())<br/>  next()<br/>}</span><span id="43fe" class="kt jr hu lm b fv lu lr l ls lt">app.use(userMiddleware)<br/>app.use(logMiddleware)</span><span id="6098" class="kt jr hu lm b fv lu lr l ls lt">app.get('/someroute', handler)</span></pre><h1 id="9e6c" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">结论</h1><p id="39cc" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我希望这能让初学者更好地了解中间件，以及为什么它们真的能帮助清理你的代码。检查你的代码中重复出现的任务，并把它们放入它们自己的中间件中。有了包含中间件的各种方法，您可以以任何您想要的方式使用它们，并且不受特定URL结构的限制，可以在不同的地方使用特定的中间件。我绝不是这方面的专家，但是我发现很多项目使用了很多外部中间件，比如前面提到的bodyParser，或者一些JWT解析中间件，或者一些文件上传包等等，但是他们经常不使用任何定制的中间件，而是一遍又一遍地重复相同的东西和路由处理器。希望这篇文章有助于降低这种情况发生在你的应用程序中的风险。如果你有任何问题，请在评论中提问。我也欢迎任何建议、改进、纠正和批评，如果有什么我会更新帖子。</p><blockquote class="lv lw lx"><p id="33fe" class="ir is ly it b iu iv iw ix iy iz ja jb lz jd je jf ma jh ji jj mb jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is ly it b iu iv iw ix iy iz ja jb lz jd je jf ma jh ji jj mb jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is ly it b iu iv iw ix iy iz ja jb lz jd je jf ma jh ji jj mb jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lh li lj lk fq mc"><div class="bz el l di"><div class="md me l"/></div></figure></div></div>    
</body>
</html>