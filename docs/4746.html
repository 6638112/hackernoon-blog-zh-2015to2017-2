<html>
<head>
<title>How well does it work? Profiling in Haskell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">效果如何？Haskell中的剖析</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-well-does-it-work-profiling-in-haskell-4f495d0e7e38?source=collection_archive---------13-----------------------#2017-06-19">https://medium.com/hackernoon/how-well-does-it-work-profiling-in-haskell-4f495d0e7e38?source=collection_archive---------13-----------------------#2017-06-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="9f5e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我以前说过，但我要再说一遍。尽管我们愿意这么想，但我们的Haskell代码并不仅仅因为编译就能工作。这就是为什么我们有<a class="ae jp" href="https://mmhaskell.com/blog/2017/4/10/putting-your-haskell-to-the-test" rel="noopener ugc nofollow" target="_blank">测试套件</a>。但是，即使它通过了我们的测试套件，这也并不意味着它可以工作得很好。有时我们会意识到我们写的代码不够好，所以我们必须改进。</p><p id="35f5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是改进我们的代码有时感觉像是在瞎猜。你将花费大量的时间来调整某一部分。然后你会发现你实际上并没有减少应用程序的总运行时间。某些操作通常需要更长时间，比如数据库调用、网络操作和IO。因此，您通常可以对从哪里开始有一个不错的想法。但确保万无一失总是有帮助的。这就是基准测试和概要分析的用武之地。我们将处理一个特定的问题，并学习如何使用一些Haskell工具来锁定问题点。</p><p id="f9ec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意，我们将使用的工具要求你使用Stack或Cabal来组织你的代码。如果你以前从未使用过这两种游戏，你应该看看我们的<a class="ae jp" href="http://academy.mondaymorninghaskell.com/p/your-first-haskell-project" rel="noopener ugc nofollow" target="_blank"> Stack迷你课程</a>！它将教你用Stack创建一个项目的基础。您还将学习使用Stack的主要命令。这是全新的，最好的是免费的！看看吧！这是我们的第一门课程，所以我们希望得到反馈！</p><h1 id="e7e7" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">问题是</h1><p id="ebc9" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们在这篇文章中的首要问题是“最大矩形”问题。你实际上可以在名为“约翰和篱笆”的<a class="ae jp" href="https://www.hackerrank.com/" rel="noopener ugc nofollow" target="_blank"> Hackerrank </a>上尝试自己解决这个问题。想象一下，我们有一系列高度不同的竖条并排放置。我们想找出我们能在这些条上画出的最大矩形的面积，它不包括任何空白空间。这里有一个这样的问题和解决方案的可视化:</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div class="fe ff kt"><img src="../Images/3a400fd23cc2abffe75c44aa0a2eacdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*1TUfxOqomKaFW5l-MUjF6g.png"/></div></figure><p id="1ef0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个例子中，我们有高度为<code class="eh lb lc ld le b">[2,5,7,4,1,8]</code>的帖子。我们可以形成的最大矩形面积为12，正如我们看到的突出显示的正方形。</p><p id="9878" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">用Haskell解决这个问题非常简洁明了，因为它适合递归解决方案。首先让我们定义几个新类型来说明我们对这个问题的概念。我们将使用一个编译器扩展来派生索引类型上的<code class="eh lb lc ld le b">Num</code> typeclass，因为这在后面会很有用。</p><pre class="ku kv kw kx fq lf le lg lh aw li dt"><span id="ff58" class="lj jr hu le b fv lk ll l lm ln">{-# LANGUAGE GeneralizedNewtypeDeriving #-}<br/>...<br/>newtype FenceValues = FenceValues { unFenceValues :: [Int] }<br/>newtype FenceIndex = FenceIndex { unFenceIndex :: Int }<br/>  deriving (Eq, Num, Ord)<br/>-- Left Index is inclusive, right index is non-inclusive <br/>newtype FenceInterval = FenceInterval { unFenceInterval :: (FenceIndex, FenceIndex) }<br/>newtype FenceSolution = FenceSolution { unFenceSolution :: Int }<br/>  deriving (Eq, Show, Ord)</span></pre><p id="6a0a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，我们将定义我们的主要功能。它将接受我们的<code class="eh lb lc ld le b">FenceValues</code>，一个整数列表，并返回我们的解。</p><pre class="ku kv kw kx fq lf le lg lh aw li dt"><span id="c62b" class="lj jr hu le b fv lk ll l lm ln">largestRectangle :: FenceValues -&gt; FenceSolution<br/>largestRectangle values = ...</span></pre><p id="96e7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它将依次调用我们的递归助手函数。该函数将计算特定间隔内的最大矩形。我们可以用越来越小的区间递归求解。我们先在整个列表的区间上调用它。</p><pre class="ku kv kw kx fq lf le lg lh aw li dt"><span id="c2cb" class="lj jr hu le b fv lk ll l lm ln">largestRectangle :: FenceValues -&gt; FenceSolution<br/>largestRectangle values = largestRectangleAtIndices values<br/>  (FenceInterval (FenceIndex 0, FenceIndex (length (unFenceValues values))))</span><span id="38f5" class="lj jr hu le b fv lo ll l lm ln">largestRectangleAtIndices :: FenceValues -&gt; FenceInterval -&gt; FenceSolution<br/>largestRectangleAtIndices = ...</span></pre><p id="aaaa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，为了分解成递归的情况，我们首先需要更多的信息。我们需要的是这个区间内最小高度的指标<code class="eh lb lc ld le b">i</code>。一种选择是，我们可以用这个高度制作一个横跨整个区间的矩形。</p><p id="ab7b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">任何其他的“最大矩形”都不会使用这个特殊的索引。所以我们可以把我们的问题分成另外两种情况。首先，我们将在左边的区间上找到最大的矩形。在第二个例子中，我们向右看。</p><p id="aad7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如您可能意识到的，这两种情况仅仅涉及到递归调用！然后我们可以很容易地比较他们的结果。我们唯一需要添加的是一个基础案例。以下是用代码表示的所有这些情况:</p><pre class="ku kv kw kx fq lf le lg lh aw li dt"><span id="b8f0" class="lj jr hu le b fv lk ll l lm ln">largestRectangleAtIndices :: FenceValues -&gt; FenceInterval -&gt; FenceSolution<br/>largestRectangleAtIndices<br/>  values<br/>  interval@(FenceInterval (leftIndex, rightIndex)) = <br/>    -- Base Case: Checks if left + 1 &gt;= right<br/>    if isBaseInterval interval<br/>      then FenceSolution (valueAtIndex values leftIndex)<br/>      -- Compare three cases<br/>      else max (max middleCase leftCase) rightCase<br/>      where<br/>      -- Find the minimum height and its index<br/>      (minIndex, minValue) = minimumHeightIndexValue values interval<br/>      -- Case 1: Use the minimum index<br/>      middleCase = FenceSolution $ (intervalSize interval) * minValue<br/>      -- Recursive call #1<br/>      leftCase = largestRectangleAtIndices values (FenceInterval (leftIndex, minIndex))<br/>      -- Guard against case where there is no "right" interval<br/>      rightCase = if minIndex + 1 == rightIndex<br/>        then FenceSolution (maxBound :: Int) -- Supply a "fake" solution that we'll ignore<br/>        -- Recursive call #2<br/>        else largestRectangleAtIndices values (FenceInterval (minIndex + 1, rightIndex))</span></pre><p id="9f65" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就这样，我们差不多完成了。这里唯一的症结是几个助手函数。其中三个很简单:</p><pre class="ku kv kw kx fq lf le lg lh aw li dt"><span id="2335" class="lj jr hu le b fv lk ll l lm ln">valueAtIndex :: FenceValues -&gt; FenceIndex -&gt; Int<br/>valueAtIndex values index = (unFenceValues values) !! (unFenceIndex index)</span><span id="2c20" class="lj jr hu le b fv lo ll l lm ln">isBaseInterval :: FenceInterval -&gt; Bool<br/>isBaseInterval (FenceInterval (FenceIndex left, FenceIndex right)) = left + 1 &gt;= right</span><span id="19c4" class="lj jr hu le b fv lo ll l lm ln">intervalSize :: FenceInterval -&gt; Int<br/>intervalSize (FenceInterval (FenceIndex left, FenceIndex right)) = right - left</span></pre><p id="5d80" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们必须确定这个区间的最小值。让我们用最天真的方法来做这件事，用一个折叠扫描整个区间。</p><pre class="ku kv kw kx fq lf le lg lh aw li dt"><span id="c407" class="lj jr hu le b fv lk ll l lm ln">minimumHeightIndexValue :: FenceValues -&gt; FenceInterval -&gt; (FenceIndex, Int)<br/>minimumHeightIndexValue values (FenceInterval (FenceIndex left, FenceIndex right)) =<br/>  foldl minTuple (FenceIndex (-1), maxBound :: Int) valsInInterval<br/>  where<br/>    valsInInterval :: [(FenceIndex, Int)]<br/>    valsInInterval = drop left (take right (zip (FenceIndex &lt;$&gt; [0..]) (unFenceValues values)))<br/>    minTuple :: (FenceIndex, Int) -&gt; (FenceIndex, Int) -&gt; (FenceIndex, Int)<br/>    minTuple old@(_, heightOld) new@(_, heightNew) =<br/>      if heightNew &lt; heightOld then new else old</span></pre><p id="561a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们完成了！</p><h1 id="a439" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">对我们的代码进行基准测试</h1><p id="6647" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">这是一个简洁的算法解决方案，但是我们想知道我们的代码是否有效。我们需要知道它是否会扩展到更大的输入值。我们可以通过编写基准来找到这个问题的答案。基准是一个我们可以与Cabal和Stack一起使用的特性。它们的工作很像测试套件。但是他们不是证明我们代码的正确性，而是向我们展示我们的代码在各种环境下运行的速度。我们将使用<code class="eh lb lc ld le b">Criterion</code>库来完成这项工作。我们将首先在我们的。该基准的cabal文件:</p><pre class="ku kv kw kx fq lf le lg lh aw li dt"><span id="8508" class="lj jr hu le b fv lk ll l lm ln">benchmark fences-benchmarks<br/>  type:                exitcode-stdio-1.0<br/>  hs-source-dirs:      benchmark<br/>  main-is:             fences-benchmark.hs<br/>  build-depends:       base<br/>                     , FencesExample<br/>                     , criterion<br/>                     , random<br/>  default-language:    Haskell2010</span></pre><p id="0052" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们将制作我们的文件<code class="eh lb lc ld le b">fences-benchmark.hs</code>，使其成为一个<code class="eh lb lc ld le b">Main</code>模块并添加一个<code class="eh lb lc ld le b">main</code>函数。我们将生成6个列表，每次增加10倍。然后我们将创建一个基准组，并在每种情况下调用<code class="eh lb lc ld le b">bench</code>函数。</p><pre class="ku kv kw kx fq lf le lg lh aw li dt"><span id="781f" class="lj jr hu le b fv lk ll l lm ln">module Main where</span><span id="b250" class="lj jr hu le b fv lo ll l lm ln">import Criterion<br/>import Criterion.Main (defaultMain)<br/>import System.Random</span><span id="3b21" class="lj jr hu le b fv lo ll l lm ln">import Lib</span><span id="9600" class="lj jr hu le b fv lo ll l lm ln">main :: IO ()<br/>main = do<br/>  [l1, l2, l3, l4, l5, l6] &lt;- mapM <br/>    randomList [1, 10, 100, 1000, 10000, 100000]<br/>  defaultMain<br/>    [ bgroup "fences tests" <br/>      [ bench "Size 1 Test" $ whnf largestRectangle l1<br/>      , bench "Size 10 Test" $ whnf largestRectangle l2<br/>      , bench "Size 100 Test" $ whnf largestRectangle l3<br/>      , bench "Size 1000 Test" $ whnf largestRectangle l4<br/>      , bench "Size 10000 Test" $ whnf largestRectangle l5<br/>      , bench "Size 100000 Test" $ whnf largestRectangle l6<br/>      ]<br/>    ]</span><span id="b85c" class="lj jr hu le b fv lo ll l lm ln">-- Generate a list of a particular size<br/>randomList :: Int -&gt; IO FenceValues<br/>randomList n = FenceValues &lt;$&gt; (sequence $ replicate n (randomRIO (1, 10000 :: Int)))</span></pre><p id="ef38" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们通常用<code class="eh lb lc ld le b">stack bench</code>(或者<code class="eh lb lc ld le b">cabal bench</code>，如果你没有使用Stack)来运行这些基准测试。但是我们也可以用<code class="eh lb lc ld le b">--profile</code>标志编译我们的代码。这将自动创建一个关于我们代码的更多信息的分析报告。注意使用性能分析还需要重新编译所有依赖项才能使用性能分析。所以你不想来回切换太多。</p><pre class="ku kv kw kx fq lf le lg lh aw li dt"><span id="0db0" class="lj jr hu le b fv lk ll l lm ln">&gt;&gt; stack bench --profile<br/>Benchmark fences-benchmarks: RUNNING...<br/>benchmarking fences tests/Size 1 Test<br/>time                 47.79 ns   (47.48 ns .. 48.10 ns)<br/>                     1.000 R²   (0.999 R² .. 1.000 R²)<br/>mean                 47.78 ns   (47.48 ns .. 48.24 ns)<br/>std dev              1.163 ns   (817.2 ps .. 1.841 ns)<br/>variance introduced by outliers: 37% (moderately inflated)</span><span id="f9a2" class="lj jr hu le b fv lo ll l lm ln">benchmarking fences tests/Size 10 Test<br/>time                 3.324 μs   (3.297 μs .. 3.356 μs)<br/>                     0.999 R²   (0.999 R² .. 1.000 R²)<br/>mean                 3.340 μs   (3.312 μs .. 3.368 μs)<br/>std dev              98.52 ns   (79.65 ns .. 127.2 ns)<br/>variance introduced by outliers: 38% (moderately inflated)</span><span id="2d33" class="lj jr hu le b fv lo ll l lm ln">benchmarking fences tests/Size 100 Test<br/>time                 107.3 μs   (106.3 μs .. 108.2 μs)<br/>                     0.999 R²   (0.999 R² .. 0.999 R²)<br/>mean                 107.2 μs   (106.3 μs .. 108.4 μs)<br/>std dev              3.379 μs   (2.692 μs .. 4.667 μs)<br/>variance introduced by outliers: 30% (moderately inflated)</span><span id="4f4d" class="lj jr hu le b fv lo ll l lm ln">benchmarking fences tests/Size 1000 Test<br/>time                 8.724 ms   (8.596 ms .. 8.865 ms)<br/>                     0.998 R²   (0.997 R² .. 0.999 R²)<br/>mean                 8.638 ms   (8.560 ms .. 8.723 ms)<br/>std dev              228.8 μs   (193.6 μs .. 272.8 μs)</span><span id="d4d8" class="lj jr hu le b fv lo ll l lm ln">benchmarking fences tests/Size 10000 Test<br/>time                 909.2 ms   (899.3 ms .. 914.1 ms)<br/>                     1.000 R²   (1.000 R² .. 1.000 R²)<br/>mean                 915.1 ms   (914.6 ms .. 915.8 ms)<br/>std dev              620.1 μs   (136.0 as .. 664.8 μs)<br/>variance introduced by outliers: 19% (moderately inflated)</span><span id="1c78" class="lj jr hu le b fv lo ll l lm ln">benchmarking fences tests/Size 100000 Test<br/>time                 103.9 s    (91.11 s .. 117.3 s)<br/>                     0.997 R²   (0.997 R² .. 1.000 R²)<br/>mean                 107.3 s    (103.7 s .. 109.4 s)<br/>std dev              3.258 s    (0.0 s .. 3.702 s)<br/>variance introduced by outliers: 19% (moderately inflated)</span><span id="d24f" class="lj jr hu le b fv lo ll l lm ln">Benchmark fences-benchmarks: FINISH</span></pre><p id="511b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以当我们运行这个的时候，我们会发现一些…麻烦的事情。在100000规模上运行最终的基准测试需要很长时间。平均来说，这个案件需要超过100秒…超过一分半钟！我们可以进一步注意到平均运行时间是如何根据案例的大小而增加的。让我们稍微缩减一下数据:</p><pre class="ku kv kw kx fq lf le lg lh aw li dt"><span id="b70c" class="lj jr hu le b fv lk ll l lm ln">Size 1: 47.78 ns<br/>Size 10: 3.340 μs (increased ~70x)<br/>Size 100: 107.2 μs (increased ~32x)<br/>Size 1000: 8.638 ms (increased ~81x)<br/>Size 10000: 915.1 ms (increased ~106x)<br/>Size 100000: 107.3 s (increased ~117x)</span></pre><p id="f9b7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每当我们将问题的大小增加10倍，花费的时间就增加接近100倍！这表明我们的运行时间是<code class="eh lb lc ld le b">O(n^2)</code>(如果您不熟悉Big-O符号，请查看本指南<a class="ae jp" href="https://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/" rel="noopener ugc nofollow" target="_blank"/>)。我们想做得更好。</p><h1 id="75a1" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">确定问题</h1><p id="e186" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">所以我们想弄清楚为什么我们的代码执行得不是很好。幸运的是，我们已经分析了我们的基准！。这会输出一个我们可以查看的特定文件，称为<code class="eh lb lc ld le b">fences-benchmark.prof</code>。它有一些非常有趣的结果:</p><pre class="ku kv kw kx fq lf le lg lh aw li dt"><span id="51fb" class="lj jr hu le b fv lk ll l lm ln">COST CENTRE                            %time %alloc<br/>minimumHeightIndexValue.valsInInterva  69.8   99.7<br/>valueAtIndex                           29.3    0.0</span></pre><p id="56c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们看到我们有两个大的罪魁祸首花了很多时间。首先，我们的函数确定了特定区间的最小值。报告甚至更加具体，指出了函数中具体的违规部分。我们花了很多时间来获得特定区间的不同值。第二，我们有<code class="eh lb lc ld le b">valueAtIndex</code>。这意味着我们也花了很多时间从列表中获取值。</p><p id="cf33" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，让我们庆幸我们很好地分解了代码。如果我们把整个解决方案写在一个大函数中，我们就不会有任何线索了。这让我们分析问题容易多了。当检查代码时，我们看到为什么这两个函数会产生<code class="eh lb lc ld le b">O(n^2)</code>行为。</p><p id="2182" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于我们进行递归调用的次数，我们将调用每个函数<code class="eh lb lc ld le b">O(n)</code>次。然后当我们调用<code class="eh lb lc ld le b">valueAtIndex</code>时，我们在链表上使用<code class="eh lb lc ld le b">(!!)</code>操作符。这需要<code class="eh lb lc ld le b">O(n)</code>时间。扫描最小高度的整个区间具有相同的效果。在最坏的情况下，我们必须查看列表中的每个元素！我有点犹豫，但这是基本结果。当我们调用这些<code class="eh lb lc ld le b">O(n)</code>片段<code class="eh lb lc ld le b">O(n)</code>次时，我们得到<code class="eh lb lc ld le b">O(n^2)</code>总时间。</p><h1 id="e7f7" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">悬崖吊死结局</h1><p id="3210" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们实际上可以在<code class="eh lb lc ld le b">O(n log n)</code>时间内解决这个问题，比目前的<code class="eh lb lc ld le b">O(n^2)</code>时间有了巨大的进步。但是我们必须改进我们的数据结构来实现这一点。首先，我们将存储我们的值，以便我们可以在亚线性时间内从索引到元素。这很简单。其次，我们必须确定包含任意区间内最小元素的索引。这在亚线性时间里有点棘手。我们需要更先进的数据结构。</p><p id="0490" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要了解我们如何解决这些问题，您必须等待本系列的第2部分！下周周一早上回到<a class="ae jp" href="https://www.mmhaskell.com/" rel="noopener ugc nofollow" target="_blank">哈斯克尔的博客</a>！</p><p id="dd99" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">提醒一下，我们刚刚在Stack 上发布了一个免费的<a class="ae jp" href="http://academy.mondaymorninghaskell.com/p/your-first-haskell-project" rel="noopener ugc nofollow" target="_blank">迷你课程。它将教你布局一个项目和使用堆栈工具在它上面运行命令的基础。你应该在周一早上的哈斯克尔学院报名！这是我们的第一门课程，所以我们希望得到一些反馈！一旦你了解了Stack，自己尝试这个问题就容易多了！</a></p><p id="a4a7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了堆栈，递归在我们的解决方案中也很重要。如果你做过一定量的函数式编程，你会看到递归在起作用。但是如果你想巩固你的知识，你应该下载我们免费的<a class="ae jp" href="https://www.mmhaskell.com/workbook" rel="noopener ugc nofollow" target="_blank">递归练习册</a>！它有两章关于递归的内容，并且有10个练习题供你解决！</p><p id="1aee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">没用Haskell编程过？没问题！你可以下载我们的<a class="ae jp" href="https://www.mmhaskell.com/checklist" rel="noopener ugc nofollow" target="_blank">入门清单</a>，它将帮助你安装Haskell。它还会为你指出一些很好的学习资源的方向。看一看！</p><blockquote class="lp lq lr"><p id="6987" class="ir is ls it b iu iv iw ix iy iz ja jb lt jd je jf lu jh ji jj lv jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是AMI家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is ls it b iu iv iw ix iy iz ja jb lt jd je jf lu jh ji jj lv jl jm jn jo hn dt translated">要了解更多信息，<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">请阅读我们的“关于”页面</a> , <a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">喜欢/在脸书给我们发消息</a>，或者简单地，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank">发推文/DM @HackerNoon。</a></p><p id="708a" class="ir is ls it b iu iv iw ix iy iz ja jb lt jd je jf lu jh ji jj lv jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>