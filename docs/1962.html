<html>
<head>
<title>Deploy Docker Compose (v3) to Swarm (mode) Cluster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Docker Compose (v3)部署到Swarm (mode)集群</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/deploy-docker-compose-v3-to-swarm-mode-cluster-4159e9cca712?source=collection_archive---------1-----------------------#2016-12-25">https://medium.com/hackernoon/deploy-docker-compose-v3-to-swarm-mode-cluster-4159e9cca712?source=collection_archive---------1-----------------------#2016-12-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir is it"><p id="7d19" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><strong class="ix hv"> <em class="hu">免责声明:</em> </strong> <em class="hu">以下所有代码片段仅适用于</em><strong class="ix hv"><em class="hu">Docker 1.13+</em></strong></p></blockquote><h2 id="99ae" class="jt ju hu bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dt translated">TL；速度三角形定位法(dead reckoning)</h2><p id="6f85" class="pw-post-body-paragraph iu iv hu ix b iy kr ja jb jc ks je jf ke kt ji jj ki ku jm jn km kv jq jr js hn dt translated"><strong class="ix hv"> Docker 1.13 </strong>将组合应用的部署简化为一个<a class="ae kw" href="https://hackernoon.com/tagged/swarm" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hv"> swarm </strong> </a> (mode)集群。而且你可以不用创建一个新的<code class="eh kx ky kz la b">dab</code> ( <em class="iw">发行版应用捆绑包</em>)文件，只需使用熟悉和众所周知的<code class="eh kx ky kz la b">docker-compose.yml</code>语法(有一些补充)和<code class="eh kx ky kz la b">--compose-file</code>选项。</p><figure class="lc ld le lf fq lg fe ff paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="fe ff lb"><img src="../Images/f88856effa72e45d4d4039958dff38c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HKf_ZCMcge8srjcP.png"/></div></div></figure><h2 id="d2b8" class="jt ju hu bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dt translated">群体集群</h2><p id="9395" class="pw-post-body-paragraph iu iv hu ix b iy kr ja jb jc ks je jf ke kt ji jj ki ku jm jn km kv jq jr js hn dt translated">Docker 引擎1.12引入了一个新的<strong class="ix hv">群模式</strong>，用于本地管理一个名为<strong class="ix hv">群</strong>的Docker引擎集群。Docker <strong class="ix hv"> swarm mode </strong>实现<a class="ae kw" href="https://docs.docker.com/engine/swarm/raft/" rel="noopener ugc nofollow" target="_blank"> Raft Consensus算法</a>，不再需要使用外部键值存储，如<a class="ae kw" href="https://www.consul.io/" rel="noopener ugc nofollow" target="_blank">consult</a>或<a class="ae kw" href="https://github.com/coreos/etcd" rel="noopener ugc nofollow" target="_blank"> etcd </a>。</p><p id="cfcf" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ke jh ji jj ki jl jm jn km jp jq jr js hn dt translated">如果你想在开发者的机器上运行一个集群，有几种选择。</p><p id="7ec5" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ke jh ji jj ki jl jm jn km jp jq jr js hn dt translated">第一种选择，也是最广为人知的，是使用带有虚拟驱动程序的<code class="eh kx ky kz la b">docker-machine</code>工具(Virtualbox、Parallels或其他)。</p><p id="1817" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ke jh ji jj ki jl jm jn km jp jq jr js hn dt translated">但是，在这篇文章中，我将使用另一种方法:使用<a class="ae kw" href="https://hub.docker.com/_/docker/" rel="noopener ugc nofollow" target="_blank">Docker-in-Docker</a>Docker镜像和Docker for Mac，更多细节请参见我的<a class="ae kw" href="http://blog.terranillius.com/post/swarm_dind" rel="noopener ugc nofollow" target="_blank"> Docker Swarm cluster和docker-in-docker on MacOS </a>的文章。</p><h1 id="a0a1" class="ln ju hu bd jv lo lp lq jz lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc kp md dt translated">Docker注册表镜像</h1><p id="2bc9" class="pw-post-body-paragraph iu iv hu ix b iy kr ja jb jc ks je jf ke kt ji jj ki ku jm jn km kv jq jr js hn dt translated">当你在本地集群上部署一个新服务时，我建议设置本地Docker注册表镜像，并使用<code class="eh kx ky kz la b">--registry-mirror</code>选项运行所有集群节点，指向本地Docker注册表。通过运行本地Docker注册表镜像，您可以将大部分冗余图像获取流量保留在本地网络上，并加速服务部署。</p><h1 id="1d07" class="ln ju hu bd jv lo lp lq jz lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc kp md dt translated">Docker群集引导脚本</h1><p id="0a49" class="pw-post-body-paragraph iu iv hu ix b iy kr ja jb jc ks je jf ke kt ji jj ki ku jm jn km kv jq jr js hn dt translated">我准备了一个shell脚本，用Docker注册表镜像和非常好的<a class="ae kw" href="https://github.com/ManoMarks/docker-swarm-visualizer" rel="noopener ugc nofollow" target="_blank"> swarm visualizer </a>应用程序来引导4节点swarm集群。</p><p id="7254" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ke jh ji jj ki jl jm jn km jp jq jr js hn dt translated">该脚本将docker引擎初始化为一个<strong class="ix hv">群主机</strong>，然后启动3个新的docker-in-docker容器，并将它们作为工作节点加入到<strong class="ix hv">群</strong>集群中。所有工作节点都使用<code class="eh kx ky kz la b">--registry-mirror</code>选项运行。</p><pre class="lc ld le lf fq me la mf mg aw mh dt"><span id="8640" class="jt ju hu la b fv mi mj l mk ml">#!/bin/bash</span><span id="6920" class="jt ju hu la b fv mm mj l mk ml"># vars<br/>[ -z "$NUM_WORKERS" ] &amp;&amp; NUM_WORKERS=3</span><span id="b3d2" class="jt ju hu la b fv mm mj l mk ml"># init swarm (need for service command); if not created<br/>docker node ls 2&gt; /dev/null | grep "Leader"<br/>if [ $? -ne 0 ]; then<br/>  docker swarm init &gt; /dev/null 2&gt;&amp;1<br/>fi</span><span id="7280" class="jt ju hu la b fv mm mj l mk ml"># get join token<br/>SWARM_TOKEN=$(docker swarm join-token -q worker)</span><span id="492f" class="jt ju hu la b fv mm mj l mk ml"># get Swarm master IP (Docker for Mac xhyve VM IP)<br/>SWARM_MASTER=$(docker info --format "{{.Swarm.NodeAddr}}")<br/>echo "Swarm master IP: ${SWARM_MASTER}"<br/>sleep 10</span><span id="ff1b" class="jt ju hu la b fv mm mj l mk ml"># start Docker registry mirror<br/>docker run -d --restart=always -p 4000:5000 --name v2_mirror \<br/>  -v $PWD/rdata:/var/lib/registry \<br/>  -e REGISTRY_PROXY_REMOTEURL=<a class="ae kw" href="https://registry-1.docker.io" rel="noopener ugc nofollow" target="_blank">https://registry-1.docker.io</a> \<br/>  registry:2.5</span><span id="87a6" class="jt ju hu la b fv mm mj l mk ml"># run NUM_WORKERS workers with SWARM_TOKEN<br/>for i in $(seq "${NUM_WORKERS}"); do<br/>  # remove node from cluster if exists<br/>  docker node rm --force \<br/>    $(docker node ls --filter "name=worker-${i}" -q) \<br/>    &gt; /dev/null 2&gt;&amp;1<br/>  # remove worker container with same name if exists<br/>  docker rm --force \<br/>    $(docker ps -q --filter "name=worker-${i}") &gt; /dev/null 2&gt;&amp;1<br/>  # run new worker container<br/>  docker run -d --privileged --name worker-${i} \<br/>    --hostname=worker-${i} \<br/>    -p ${i}2375:2375 \<br/>    -p ${i}5000:5000 \<br/>    -p ${i}5001:5001 \<br/>    -p ${i}5601:5601 \<br/>    docker:1.13-rc-dind \<br/>      --registry-mirror <a class="ae kw" href="http://${SWARM_MASTER}:4000" rel="noopener ugc nofollow" target="_blank">http://${SWARM_MASTER}:4000</a><br/>  # add worker container to the cluster<br/>  docker --host=localhost:${i}2375 swarm join \<br/>    --token ${SWARM_TOKEN} ${SWARM_MASTER}:2377<br/>done</span><span id="b3bb" class="jt ju hu la b fv mm mj l mk ml"># show swarm cluster<br/>printf "\nLocal Swarm Cluster\n===================\n"</span><span id="597d" class="jt ju hu la b fv mm mj l mk ml">docker node ls</span><span id="b965" class="jt ju hu la b fv mm mj l mk ml"># echo swarm visualizer<br/>printf "\nLocal Swarm Visualizer\n===================\n"<br/>docker run -it -d --name swarm_visualizer \<br/>  -p 8000:8080 -e HOST=localhost \<br/>  -v /var/run/docker.sock:/var/run/docker.sock \<br/>  manomarks/visualizer:beta</span></pre><h1 id="a308" class="ln ju hu bd jv lo lp lq jz lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc kp md dt translated">部署多容器应用程序——“老”方法</h1><p id="0f72" class="pw-post-body-paragraph iu iv hu ix b iy kr ja jb jc ks je jf ke kt ji jj ki ku jm jn km kv jq jr js hn dt translated">Docker <code class="eh kx ky kz la b">compose</code>是一个用于定义和运行复合多容器Docker应用程序的工具(和部署规范格式)。在Docker 1.12之前，你可以使用<code class="eh kx ky kz la b">docker-compose</code>工具将这样的应用部署到<strong class="ix hv"> swarm </strong>集群。在1.12版本中，这不再可能:<code class="eh kx ky kz la b">docker-compose</code>只能在单个Docker主机上部署您的应用程序。</p><p id="40b5" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ke jh ji jj ki jl jm jn km jp jq jr js hn dt translated">为了将它部署到一个<strong class="ix hv"> swarm </strong>集群，你需要创建一个<code class="eh kx ky kz la b">dab</code>格式的特殊部署规范文件(也称为<em class="iw">分发应用包</em>)(更多<a class="ae kw" href="https://github.com/docker/docker/blob/master/experimental/docker-stacks-and-bundles.md" rel="noopener ugc nofollow" target="_blank">见这里</a>)。</p><p id="059f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ke jh ji jj ki jl jm jn km jp jq jr js hn dt translated">创建这个文件的方法是运行<code class="eh kx ky kz la b">docker-compose bundle</code>命令。该命令的输出是一个JSON文件，它描述了多容器组合的应用程序，其Docker图像由<code class="eh kx ky kz la b">@sha256</code>引用，而不是标记。目前<code class="eh kx ky kz la b">dab</code>文件格式不支持来自<code class="eh kx ky kz la b">docker-compose.yml</code>的多个设置，也不允许使用来自<code class="eh kx ky kz la b">docker service create</code>命令的支持选项。</p><p id="dbcb" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ke jh ji jj ki jl jm jn km jp jq jr js hn dt translated">这是一个令人遗憾的故事:<code class="eh kx ky kz la b">dab</code> bundle格式看起来很有前途，但是目前完全没有用(至少在Docker 1.12中)。</p><h1 id="507b" class="ln ju hu bd jv lo lp lq jz lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc kp md dt translated">部署多容器应用程序——“新”方式</h1><p id="f6df" class="pw-post-body-paragraph iu iv hu ix b iy kr ja jb jc ks je jf ke kt ji jj ki ku jm jn km kv jq jr js hn dt translated">在Docker 1.13中，部署多容器组合应用程序的“新”方法是再次使用<code class="eh kx ky kz la b">docker-compose.yml</code>(<em class="iw">万岁！</em>)。向码头工人队致敬！</p><p id="3d4a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ke jh ji jj ki jl jm jn km jp jq jr js hn dt translated">* <strong class="ix hv">注意</strong>:不需要<code class="eh kx ky kz la b">docker-compose</code>工具，只需要<strong class="ix hv"> docker-compose </strong>格式的<code class="eh kx ky kz la b">yaml</code>文件(<code class="eh kx ky kz la b">version: "3"</code>)</p><pre class="lc ld le lf fq me la mf mg aw mh dt"><span id="ee67" class="jt ju hu la b fv mi mj l mk ml">$ docker deploy --compose-file docker-compose.yml</span></pre><h1 id="3c9f" class="ln ju hu bd jv lo lp lq jz lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc kp md dt translated">Docker编写v3 ( <code class="eh kx ky kz la b">version: "3"</code>)</h1><p id="dbfd" class="pw-post-body-paragraph iu iv hu ix b iy kr ja jb jc ks je jf ke kt ji jj ki ku jm jn km kv jq jr js hn dt translated"><em class="iw">那么，docker compose版本3有什么新功能？</em></p><p id="cbbd" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ke jh ji jj ki jl jm jn km jp jq jr js hn dt translated">首先，我建议你深入了解一下<a class="ae kw" href="https://github.com/aanand/compose-file/blob/master/schema/data/config_schema_v3.0.json" rel="noopener ugc nofollow" target="_blank"> docker-compose schema </a>。它是众所周知的<code class="eh kx ky kz la b">docker-compose</code>格式的扩展。</p><p id="16ff" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ke jh ji jj ki jl jm jn km jp jq jr js hn dt translated"><strong class="ix hv">注意:</strong> <code class="eh kx ky kz la b">docker-compose</code>工具(<code class="eh kx ky kz la b">ver. 1.9.0</code>)还不支持<code class="eh kx ky kz la b">docker-compose.yaml version: "3"</code>。</p><p id="214f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ke jh ji jj ki jl jm jn km jp jq jr js hn dt translated">最明显的变化是围绕<strong class="ix hv">蜂群</strong>服务的部署。现在你可以指定<code class="eh kx ky kz la b">docker service create/update</code>命令支持的所有选项:</p><ul class=""><li id="ad44" class="mn mo hu ix b iy iz jc jd ke mp ki mq km mr js ms mt mu mv dt translated">服务副本(或全局服务)的数量</li><li id="802b" class="mn mo hu ix b iy mw jc mx ke my ki mz km na js ms mt mu mv dt translated">服务标签</li><li id="2d5b" class="mn mo hu ix b iy mw jc mx ke my ki mz km na js ms mt mu mv dt translated">服务(容器)CPU和内存的硬性和软性限制</li><li id="7ac3" class="mn mo hu ix b iy mw jc mx ke my ki mz km na js ms mt mu mv dt translated">服务重启策略</li><li id="6756" class="mn mo hu ix b iy mw jc mx ke my ki mz km na js ms mt mu mv dt translated">服务滚动更新策略</li><li id="76fc" class="mn mo hu ix b iy mw jc mx ke my ki mz km na js ms mt mu mv dt translated">部署位置约束<a class="ae kw" href="https://github.com/docker/docker/blob/master/docs/reference/commandline/service_create.md#specify-service-constraints---constraint" rel="noopener ugc nofollow" target="_blank">链接</a></li></ul><h1 id="261d" class="ln ju hu bd jv lo lp lq jz lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc kp md dt translated">Docker编写v3示例</h1><p id="5559" class="pw-post-body-paragraph iu iv hu ix b iy kr ja jb jc ks je jf ke kt ji jj ki ku jm jn km kv jq jr js hn dt translated">我已经为经典的<strong class="ix hv"> <em class="iw">“猫对狗”</em> </strong>例子创建了一个<strong class="ix hv">“新的”</strong>合成文件(v3)。该示例应用程序包含5个服务，部署配置如下:</p><ol class=""><li id="24ff" class="mn mo hu ix b iy iz jc jd ke mp ki mq km mr js nb mt mu mv dt translated"><code class="eh kx ky kz la b">voting-app</code> -一个Python webapp，让你在两个选项之间投票；需要<code class="eh kx ky kz la b">redis</code></li><li id="28b4" class="mn mo hu ix b iy mw jc mx ke my ki mz km na js nb mt mu mv dt translated"><code class="eh kx ky kz la b">redis</code> -收集新选票的Redis队列；部署在<code class="eh kx ky kz la b">swarm manager</code>节点上</li><li id="1cba" class="mn mo hu ix b iy mw jc mx ke my ki mz km na js nb mt mu mv dt translated"><code class="eh kx ky kz la b">db</code> -由Docker卷支持的Postgres数据库；部署在<code class="eh kx ky kz la b">swarm manager</code>节点上</li><li id="0a56" class="mn mo hu ix b iy mw jc mx ke my ki mz km na js nb mt mu mv dt translated"><code class="eh kx ky kz la b">result-app</code> - Node.js webapp，实时显示投票结果；2个副本，部署在<code class="eh kx ky kz la b">swarm worker</code>节点上</li><li id="8ae6" class="mn mo hu ix b iy mw jc mx ke my ki mz km na js nb mt mu mv dt translated"><code class="eh kx ky kz la b">worker</code>。消耗选票并将其存储在<code class="eh kx ky kz la b">db</code>中的网络工人；</li></ol><ul class=""><li id="7cdc" class="mn mo hu ix b iy iz jc jd ke mp ki mq km mr js ms mt mu mv dt translated"><strong class="ix hv">副本数量:</strong> 2个副本</li><li id="eca7" class="mn mo hu ix b iy mw jc mx ke my ki mz km na js ms mt mu mv dt translated"><strong class="ix hv">硬限制:</strong>最大25% CPU和512MB内存</li><li id="73d2" class="mn mo hu ix b iy mw jc mx ke my ki mz km na js ms mt mu mv dt translated"><strong class="ix hv">软限制:</strong>最大25% CPU和256MB内存</li><li id="4f61" class="mn mo hu ix b iy mw jc mx ke my ki mz km na js ms mt mu mv dt translated"><strong class="ix hv">位置:</strong>仅在<code class="eh kx ky kz la b">swarm worker</code>节点上</li><li id="3811" class="mn mo hu ix b iy mw jc mx ke my ki mz km na js ms mt mu mv dt translated"><strong class="ix hv">重启策略:</strong>失败时重启，延迟5秒，最多尝试3次</li><li id="b42e" class="mn mo hu ix b iy mw jc mx ke my ki mz km na js ms mt mu mv dt translated"><strong class="ix hv">更新策略:</strong>逐个更新，更新期间容许10秒延迟和0.3的故障率</li></ul><pre class="lc ld le lf fq me la mf mg aw mh dt"><span id="b459" class="jt ju hu la b fv mi mj l mk ml">version: "3"</span><span id="cb6a" class="jt ju hu la b fv mm mj l mk ml">services:</span><span id="b17a" class="jt ju hu la b fv mm mj l mk ml">redis:<br/>    image: redis:3.2-alpine<br/>    ports:<br/>      - "6379"<br/>    networks:<br/>      - voteapp<br/>    deploy:<br/>      placement:<br/>        constraints: [node.role == manager]</span><span id="85fb" class="jt ju hu la b fv mm mj l mk ml">db:<br/>    image: postgres:9.4<br/>    volumes:<br/>      - db-data:/var/lib/postgresql/data<br/>    networks:<br/>      - voteapp<br/>    deploy:<br/>      placement:<br/>        constraints: [node.role == manager]</span><span id="756e" class="jt ju hu la b fv mm mj l mk ml">voting-app:<br/>    image: gaiadocker/example-voting-app-vote:good<br/>    ports:<br/>      - 5000:80<br/>    networks:<br/>      - voteapp<br/>    depends_on:<br/>      - redis<br/>    deploy:<br/>      mode: replicated<br/>      replicas: 2<br/>      labels: [APP=VOTING]<br/>      placement:<br/>        constraints: [node.role == worker]</span><span id="f677" class="jt ju hu la b fv mm mj l mk ml">result-app:<br/>    image: gaiadocker/example-voting-app-result:latest<br/>    ports:<br/>      - 5001:80<br/>    networks:<br/>      - voteapp<br/>    depends_on:<br/>      - db</span><span id="8599" class="jt ju hu la b fv mm mj l mk ml">worker:<br/>    image: gaiadocker/example-voting-app-worker:latest<br/>    networks:<br/>      voteapp:<br/>        aliases:<br/>          - workers<br/>    depends_on:<br/>      - db<br/>      - redis<br/>    # service deployment<br/>    deploy:<br/>      mode: replicated<br/>      replicas: 2<br/>      labels: [APP=VOTING]<br/>      # service resource management<br/>      resources:<br/>        # Hard limit - Docker does not allow to allocate more<br/>        limits:<br/>          cpus: '0.25'<br/>          memory: 512M<br/>        # Soft limit - Docker makes best effort to return to it<br/>        reservations:<br/>          cpus: '0.25'<br/>          memory: 256M<br/>      # service restart policy<br/>      restart_policy:<br/>        condition: on-failure<br/>        delay: 5s<br/>        max_attempts: 3<br/>        window: 120s<br/>      # service update configuration<br/>      update_config:<br/>        parallelism: 1<br/>        delay: 10s<br/>        failure_action: continue<br/>        monitor: 60s<br/>        max_failure_ratio: 0.3<br/>      # placement constraint - in this case on 'worker' nodes only<br/>      placement:<br/>        constraints: [node.role == worker]</span><span id="e7da" class="jt ju hu la b fv mm mj l mk ml">networks:<br/>    voteapp:</span><span id="99b2" class="jt ju hu la b fv mm mj l mk ml">volumes:<br/>  db-data:</span></pre><p id="bd4a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ke jh ji jj ki jl jm jn km jp jq jr js hn dt translated">运行<code class="eh kx ky kz la b">docker deploy — compose-file docker-compose.yml VOTE</code>命令，在<strong class="ix hv"> swarm </strong>集群上部署我版本的<strong class="ix hv"> <em class="iw">【猫对狗】</em> </strong>应用程序。</p><figure class="lc ld le lf fq lg fe ff paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="fe ff nc"><img src="../Images/69a19efab2ba6b40b0d6a78071f3e22e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ho1ZuW2FFDasA5fGNnATaQ.png"/></div></div><figcaption class="nd ne fg fe ff nf ng bd b be z ek">Cats vs. Dogs on Swarm cluster</figcaption></figure><p id="cdd3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ke jh ji jj ki jl jm jn km jp jq jr js hn dt translated">希望这篇文章对你有用。我期待您的评论和任何问题。</p></div><div class="ab cl nh ni hc nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="hn ho hp hq hr"><p id="b8f9" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ke jh ji jj ki jl jm jn km jp jq jr js hn dt translated"><em class="iw">最初发表于</em> <a class="ae kw" href="https://codefresh.io/blog/deploy-docker-compose-v3-swarm-mode-cluster/" rel="noopener ugc nofollow" target="_blank"> <em class="iw"> Codefresh博客</em> </a> <em class="iw">。</em></p><div class="lc ld le lf fq ab cb"><figure class="no lg np nq nr ns nt paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="no lg np nq nr ns nt paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="no lg np nq nr ns nt paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ir is it"><p id="f922" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><a class="ae kw" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是阿妹家庭的一员。我们现在<a class="ae kw" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae kw" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kw" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kw" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lc ld le lf fq lg fe ff paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="fe ff nu"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="lc ld le lf fq lg"><div class="bz el l di"><div class="nv nw l"/></div></figure></div></div>    
</body>
</html>