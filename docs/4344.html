<html>
<head>
<title>Bi-Directional Cursor Pagination with React.js, Relay, and GraphQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React.js、Relay和GraphQL进行双向光标分页</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/bi-directional-cursor-pagination-with-react-js-relay-and-graphql-dc4ad6f9cbb0?source=collection_archive---------5-----------------------#2017-05-26">https://medium.com/hackernoon/bi-directional-cursor-pagination-with-react-js-relay-and-graphql-dc4ad6f9cbb0?source=collection_archive---------5-----------------------#2017-05-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="858c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">根据期望的用户体验和底层API的形式，分页有许多不同的风格。<a class="ae jp" href="https://hackernoon.com/tagged/graphql" rel="noopener ugc nofollow" target="_blank">graph QL</a>API，如<a class="ae jp" href="https://developer.github.com/early-access/graphql/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>实现了<a class="ae jp" href="https://facebook.github.io/relay/graphql/connections.htm" rel="noopener ugc nofollow" target="_blank">中继光标连接规范</a>来标准化大型结果集的分页和切片。这种方法非常适合无限滚动，但也可以用于带有下一页/上一页按钮的“窗口”分页。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff jq"><img src="../Images/1daa2e28c15c010643b81aa35ca0293c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*dr2MWNfjPVyjzKhvAXy-sw.png"/></div><figcaption class="jy jz fg fe ff ka kb bd b be z ek">An example of bi-directional windowed paging using the GitHub GraphQL API</figcaption></figure><p id="d71d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">游标连接通过传入下列查询参数对之一来工作:</p><h2 id="344c" class="kc kd hu bd ke kf kg kh ki kj kk kl km jc kn ko kp jg kq kr ks jk kt ku kv kw dt translated">前向窗口分页</h2><p id="221e" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated"><code class="eh lc ld le lf b">first</code>是一个非零正整数，描述从结果集的前端返回的最大结果数。在向后分页期间，该值必须为null。</p><p id="4df1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lc ld le lf b">after</code>是一个不透明的光标类型值，由连接的<code class="eh lc ld le lf b"><a class="ae jp" href="https://developer.github.com/early-access/graphql/object/pageinfo/" rel="noopener ugc nofollow" target="_blank">pageInfo</a></code>对象的<code class="eh lc ld le lf b">endCursor</code>字段提供。对于第一页，该值将为null。在向后分页期间，该值必须为null。</p><h2 id="523f" class="kc kd hu bd ke kf kg kh ki kj kk kl km jc kn ko kp jg kq kr ks jk kt ku kv kw dt translated">向后窗口分页</h2><p id="7234" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated"><code class="eh lc ld le lf b">last</code>是一个非零正整数，描述从结果集尾部返回的最大结果数。在向前分页期间，该值必须为null。</p><p id="52c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lc ld le lf b">before</code>是一个不透明的光标类型值，由连接的<code class="eh lc ld le lf b"><a class="ae jp" href="https://developer.github.com/early-access/graphql/object/pageinfo/" rel="noopener ugc nofollow" target="_blank">pageInfo</a></code>对象的<code class="eh lc ld le lf b">startCursor</code>字段提供。在向前分页期间，该值必须为null。</p><h2 id="a9b0" class="kc kd hu bd ke kf kg kh ki kj kk kl km jc kn ko kp jg kq kr ks jk kt ku kv kw dt translated">GraphQL查询片段示例</h2><pre class="jr js jt ju fq lg lf lh li aw lj dt"><span id="e22c" class="kc kd hu lf b fv lk ll l lm ln">Relay.QL`<br/>  fragment on Query {<br/>    search(query: $q, type: REPOSITORY,<br/>           first: $first, after: $after,<br/>           last: $last, before: $before) {<br/>      repositoryCount<br/>      pageInfo {<br/>        startCursor<br/>        endCursor<br/>      }<br/>      edges {<br/>        node {<br/>          ... on Repository {<br/>            id<br/>            name<br/>            url<br/>          }<br/>        }<br/>      }<br/>    }<br/>  }<br/>`</span></pre><p id="0f78" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lc ld le lf b">repositoryCount</code>字段用于计算结果页面的总数。<code class="eh lc ld le lf b"><a class="ae jp" href="https://developer.github.com/early-access/graphql/object/pageinfo/" rel="noopener ugc nofollow" target="_blank">pageInfo</a></code>用于填充<code class="eh lc ld le lf b">before</code> / <code class="eh lc ld le lf b">after</code>光标参数。<code class="eh lc ld le lf b"><a class="ae jp" href="https://developer.github.com/early-access/graphql/object/searchresultitemedge" rel="noopener ugc nofollow" target="_blank">edges</a></code>包含了<code class="eh lc ld le lf b"><a class="ae jp" href="https://developer.github.com/early-access/graphql/union/searchresultitem/" rel="noopener ugc nofollow" target="_blank">node</a></code>联合类型里面的搜索结果。我们使用<code class="eh lc ld le lf b">type</code>参数将结果限制为仅包含<code class="eh lc ld le lf b"><a class="ae jp" href="https://developer.github.com/early-access/graphql/object/repository/" rel="noopener ugc nofollow" target="_blank">repository</a></code>类型的节点。</p><p id="070c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用来自该查询的数据，应用程序可以计算页面总数，并跟踪我们当前所在的页面。页数是结果总数除以每页结果数的四舍五入结果。</p><p id="d149" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要查看下一页，使用当前页面的<code class="eh lc ld le lf b">endCursor</code>字段作为<code class="eh lc ld le lf b">after</code>参数，使用页面大小作为<code class="eh lc ld le lf b">first</code>参数来运行查询。要返回一个页面，使用当前页面的<code class="eh lc ld le lf b">startCursor</code>字段作为<code class="eh lc ld le lf b">before</code>参数，使用页面大小作为<code class="eh lc ld le lf b">last</code>参数来运行查询。</p><h2 id="d03c" class="kc kd hu bd ke kf kg kh ki kj kk kl km jc kn ko kp jg kq kr ks jk kt ku kv kw dt translated">将分页逻辑封装在React组件中</h2><pre class="jr js jt ju fq lg lf lh li aw lj dt"><span id="da6a" class="kc kd hu lf b fv lk ll l lm ln">class Search extends Component {</span></pre><p id="344a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了通过<a class="ae jp" href="https://facebook.github.io/relay/docs/guides-containers.html" rel="noopener ugc nofollow" target="_blank">中继容器</a>传播查询结果，我们需要创建一个<a class="ae jp" href="https://facebook.github.io/react/docs/react-component.html" rel="noopener ugc nofollow" target="_blank">反应组件</a>来处理、操作和显示数据。</p><pre class="jr js jt ju fq lg lf lh li aw lj dt"><span id="d7f8" class="kc kd hu lf b fv lk ll l lm ln">  constructor(props) {<br/>    super(props);</span><span id="f309" class="kc kd hu lf b fv lo ll l lm ln">    this.state = {<br/>      q: "",<br/>      pageSize: 25,<br/>      pageCursor: 1,<br/>      pageCount: 1<br/>    };</span><span id="09ba" class="kc kd hu lf b fv lo ll l lm ln">    this.handleQueryChange = this.handleQueryChange.bind(this);<br/>    this.handleSearch = this.handleSearch.bind(this);<br/>    this.handlePrevPage = this.handlePrevPage.bind(this);<br/>    this.handleNextPage = this.handleNextPage.bind(this);<br/>  }</span></pre><p id="ba55" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lc ld le lf b">constructor</code>主要是样板文件，带有一些初始状态和函数绑定，以确保组件在回调期间是函数上下文。</p><pre class="jr js jt ju fq lg lf lh li aw lj dt"><span id="e085" class="kc kd hu lf b fv lk ll l lm ln">  handleQueryChange(e) {<br/>    this.setState({<br/>      q: e.target.value<br/>    });<br/>  }</span></pre><p id="a5b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lc ld le lf b">handleQueryChange</code>由&lt;输入&gt; <code class="eh lc ld le lf b">onChange</code>回调调用，以基于用户输入更新搜索查询。在提交表单之前，实际的搜索不会发生。</p><pre class="jr js jt ju fq lg lf lh li aw lj dt"><span id="447d" class="kc kd hu lf b fv lk ll l lm ln">  handleSearch(e) {<br/>    this.props.relay.setVariables({<br/>      q: this.state.q,<br/>      first: this.state.pageSize,<br/>      after: null,<br/>      last: null,<br/>      before: null<br/>    });<br/>    this.isNewSearchQuery = true;<br/>    e &amp;&amp; e.preventDefault(); // Stop form action<br/>  }</span></pre><p id="93c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lc ld le lf b">handleSearch</code>由&lt;表单&gt; <code class="eh lc ld le lf b">onSubmit</code>回调调用，通过更新中继查询中的变量来执行搜索。当查询值改变时，<code class="eh lc ld le lf b">componentWillReceiveProps</code>使用<code class="eh lc ld le lf b">isNewSearchQuery</code>标志作为重置页码和页数的提示。</p><pre class="jr js jt ju fq lg lf lh li aw lj dt"><span id="b5f9" class="kc kd hu lf b fv lk ll l lm ln">  componentWillReceiveProps(nextProps) {<br/>    if (this.isNewSearchQuery) {<br/>      let repoCount = nextProps.query.search.repositoryCount;<br/>      let reposPerPage = this.state.pageSize<br/>      this.setState({<br/>        pageCursor: 1,<br/>        pageCount: Math.ceil(repoCount / reposPerPage)<br/>      });<br/>      this.isNewSearchQuery = false;<br/>    }<br/>  }</span></pre><p id="39b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lc ld le lf b"><a class="ae jp" href="https://facebook.github.io/react/docs/react-component.html#componentwillreceiveprops" rel="noopener ugc nofollow" target="_blank">componentWillReceiveProps</a></code>是一个React组件钩子，在查询结果返回时被调用。从这里，我们可以检查是否设置了<code class="eh lc ld le lf b">isNewSearchQuery</code>标志，并将页面光标重置到开头，并重新计算页数。当结果总数在分页过程中变化不大时，这种模式最有效。</p><pre class="jr js jt ju fq lg lf lh li aw lj dt"><span id="c8f4" class="kc kd hu lf b fv lk ll l lm ln">  handlePrevPage() {<br/>    if (this.state.pageCursor &gt; 1) {<br/>      let pageCursor = this.state.pageCursor - 1;<br/>      this.props.relay.setVariables({<br/>        last: this.state.pageSize,<br/>        before: this.props.query.search.pageInfo.startCursor,<br/>        first: null,<br/>        after: null<br/>      }, ({ ready, done }) =&gt; {<br/>        if (ready &amp;&amp; done) {<br/>          this.setState({ pageCursor });<br/>        }<br/>      });<br/>    }<br/>  }</span><span id="e812" class="kc kd hu lf b fv lo ll l lm ln">  handleNextPage() {<br/>    if (this.state.pageCursor &lt; this.state.pageCount) {<br/>      let pageCursor = this.state.pageCursor + 1;<br/>      this.props.relay.setVariables({<br/>        first: this.state.pageSize,<br/>        after: this.props.query.search.pageInfo.endCursor,<br/>        last: null,<br/>        before: null<br/>      }, ({ ready, done }) =&gt; {<br/>        if (ready &amp;&amp; done) {<br/>          this.setState({ pageCursor });<br/>        }<br/>      });<br/>    }<br/>  }</span></pre><p id="782b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lc ld le lf b">handlePrevPage</code>和<code class="eh lc ld le lf b">handleNextPage</code>基于分页状态执行边界检查，然后使用当前结果<code class="eh lc ld le lf b"><a class="ae jp" href="https://developer.github.com/early-access/graphql/object/pageinfo/" rel="noopener ugc nofollow" target="_blank">pageInfo</a></code>更新中继查询变量。直到新的查询通过利用可选的<code class="eh lc ld le lf b"><a class="ae jp" href="https://facebook.github.io/relay/docs/api-reference-relay-container.html#setvariables" rel="noopener ugc nofollow" target="_blank">setVariables</a></code>的<code class="eh lc ld le lf b">onReadyStateChange</code>参数完成，实际的页码才更新。</p><pre class="jr js jt ju fq lg lf lh li aw lj dt"><span id="e648" class="kc kd hu lf b fv lk ll l lm ln">  render() {<br/>    let { search } = this.props.query;<br/>    let { pageCursor, pageCount } = this.state;<br/>    let isPrevPageDisabled = (pageCursor === 1);<br/>    let isNextPageDisabled = (pageCursor === pageCount);<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;h2&gt;Search&lt;/h2&gt;</span><span id="d119" class="kc kd hu lf b fv lo ll l lm ln">        &lt;form onSubmit={this.handleSearch}&gt;<br/>          &lt;input placeholder="Repository name" type="text" value={this.state.q} onChange={this.handleQueryChange} /&gt;<br/>          &amp;nbsp;<br/>          &lt;button type="submit"&gt;Search&lt;/button&gt;<br/>        &lt;/form&gt;</span><span id="d8ed" class="kc kd hu lf b fv lo ll l lm ln">        &lt;h3&gt;{search.repositoryCount} results&lt;/h3&gt;</span><span id="df33" class="kc kd hu lf b fv lo ll l lm ln">        &lt;button onClick={this.handlePrevPage} disabled={isPrevPageDisabled}&gt;Previous Page&lt;/button&gt;<br/>        &amp;nbsp;<br/>        Page {pageCursor} of {pageCount}<br/>        &amp;nbsp;<br/>        &lt;button onClick={this.handleNextPage} disabled={isNextPageDisabled}&gt;Next Page&lt;/button&gt;</span><span id="316e" class="kc kd hu lf b fv lo ll l lm ln">        &lt;ul className="Search-results"&gt;<br/>          {search.edges.map(({ node }, index) =&gt; (<br/>            &lt;SearchResult key={node.id} repository={node} /&gt;<br/>          ))}<br/>        &lt;/ul&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="296e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lc ld le lf b">render</code>为搜索组件创建DOM，通过<code class="eh lc ld le lf b"><a class="ae jp" href="https://developer.github.com/early-access/graphql/object/searchresultitemedge" rel="noopener ugc nofollow" target="_blank">edges</a></code>映射连接所有回调并显示结果，并将搜索结果项封装在它们自己的组件中:</p><pre class="jr js jt ju fq lg lf lh li aw lj dt"><span id="a77e" class="kc kd hu lf b fv lk ll l lm ln">class SearchResult extends Component {<br/>  render() {<br/>    let repo = this.props.repository;<br/>    let stargazersUrl = repo.url + "/stargazers";<br/>    return (<br/>      &lt;li&gt;<br/>        &lt;h5 className="stargazers"&gt;&lt;a href={stargazersUrl}&gt;★ {repo.stargazers.totalCount}&lt;/a&gt;&lt;/h5&gt;<br/>        &lt;h4 className="headline"&gt;&lt;a href={repo.owner.url}&gt;{repo.owner.login}&lt;/a&gt;/&lt;a href={repo.url}&gt;{repo.name}&lt;/a&gt;&lt;/h4&gt;<br/>        &lt;span className="description"&gt;{repo.description}&lt;/span&gt;<br/>      &lt;/li&gt;<br/>    )<br/>  }<br/>}</span></pre><h2 id="f2b0" class="kc kd hu bd ke kf kg kh ki kj kk kl km jc kn ko kp jg kq kr ks jk kt ku kv kw dt translated">用一个中继容器把它包起来</h2><p id="52dd" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">最后，我们可以基于我们的查询片段和React组件创建一个中继容器:</p><pre class="jr js jt ju fq lg lf lh li aw lj dt"><span id="2e38" class="kc kd hu lf b fv lk ll l lm ln">Relay.createContainer(Search, {<br/>  initialVariables: {<br/>    q: "",<br/>    first: null,<br/>    last: null,<br/>    before: null,<br/>    after: null<br/>  },<br/>  fragments: {<br/>    query: () =&gt; Relay.QL`<br/>      fragment on Query {<br/>        search(query: $q, type: REPOSITORY,<br/>               first: $first, after: $after,<br/>               last: $last, before: $before) {<br/>          repositoryCount<br/>          pageInfo {<br/>            startCursor<br/>            endCursor<br/>          }<br/>          edges {<br/>            node {<br/>              ... on Repository {<br/>                id<br/>                name<br/>                url<br/>                description<br/>                stargazers {<br/>                  totalCount<br/>                }<br/>                owner {<br/>                  login<br/>                  url<br/>                }<br/>              }<br/>            }<br/>          }<br/>        }<br/>      }<br/>    `,<br/>  },<br/>});</span></pre><p id="288a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个容器可以被传递到一个<a class="ae jp" href="https://facebook.github.io/relay/docs/api-reference-relay-renderer.html" rel="noopener ugc nofollow" target="_blank">中继渲染器</a>中，或者使用<code class="eh lc ld le lf b"><a class="ae jp" href="https://facebook.github.io/relay/docs/api-reference-relay-container.html#getfragment" rel="noopener ugc nofollow" target="_blank">getFragment</a></code>静态方法作为父容器内部的子容器。</p><p id="7914" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我希望这对试图理解GraphQL分页模型并与React和Relay Classic集成的初学者有所帮助。我想分享这个，因为在解决这个问题时，我在GraphQL中找不到任何双向分页的例子。</p><p id="518b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">感谢阅读。如果你正在寻找一名有经验的JavaScript工程师，请在LinkedIn上给我发信息<a class="ae jp" href="https://www.linkedin.com/in/christopher-bonhage-629612136/" rel="noopener ugc nofollow" target="_blank">或者在christopherbonhage.com的【T4工作】上给我发邮件</a></p><div class="jr js jt ju fq ab cb"><figure class="lq jv lr ls lt lu lv paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="lq jv lr ls lt lu lv paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="lq jv lr ls lt lu lv paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="lw lx ly"><p id="f922" class="ir is lp it b iu iv iw ix iy iz ja jb lz jd je jf ma jh ji jj mb jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is lp it b iu iv iw ix iy iz ja jb lz jd je jf ma jh ji jj mb jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mc"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mh mi l"/></div></figure></div></div>    
</body>
</html>