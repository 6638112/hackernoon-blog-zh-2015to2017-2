<html>
<head>
<title>Creating a structured, hot-reloadable GraphQL API with Express.js, Apollo Server and Webpack: Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Express.js、Apollo Server和Webpack创建结构化的、可热加载的GraphQL API:第1部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/creating-a-structured-hot-reloadable-graphql-api-with-express-js-de62c859643?source=collection_archive---------0-----------------------#2017-07-29">https://medium.com/hackernoon/creating-a-structured-hot-reloadable-graphql-api-with-express-js-de62c859643?source=collection_archive---------0-----------------------#2017-07-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/fc5a3931192cbaa0c780ff7a22c9a7d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dPQO0s3hiwqOc_Yjyi-jdw.png"/></div></div></figure><p id="d1b3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">GraphQL是一种通过强类型查询语言构建API的新方法。脸书在2015年发布的GraphQL正迅速获得关注，并被Twitter和Github等其他大公司采用。在本文中，我们将介绍如何使用Express和Apollo Server设置API，以及如何构建GraphQL模式以保持其可管理性。<br/>作为奖励，我们也将在我们的API中添加热重装。</p><p id="a584" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">点击这里查看回购协议；<a class="ae kb" href="https://github.com/mhaagens/express_graphql_hmr_article_boilerplate" rel="noopener ugc nofollow" target="_blank">https://github . com/mhaagens/express _ graph QL _ hmr _ article _ boilerplate</a></p><h1 id="1036" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">服务器上GraphQL的高级概述</h1><p id="7c80" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">一旦熟悉了所有的活动部分，GraphQL实际上很容易上手。我会尽量缩短这一部分，但是如果你只想得到代码，你可以直接跳过。</p><p id="3ad6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">GraphQL服务器是通过一个模式定义的，其工作方式大致如下:</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lf"><img src="../Images/856d72cebe10d7f10f155ec644f8404e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E384h_zLRunyFwEdyEpF7A.png"/></div></div><figcaption class="lk ll fg fe ff lm ln bd b be z ek">GraphQL schema overview.</figcaption></figure><p id="dbcd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">类型是数据模型的强类型表示。<br/>这里有一个使用来自Apollo的<a class="ae kb" href="https://github.com/apollographql/graphql-tools" rel="noopener ugc nofollow" target="_blank"> graphql-tools </a>定义的post类型的例子，这是我们将在本教程中用来定义我们的模式的；</p><pre class="lg lh li lj fq lo lp lq lr aw ls dt"><span id="4d38" class="lt kd hu lp b fv lu lv l lw lx">import User from "./user_type";</span><span id="eeb1" class="lt kd hu lp b fv ly lv l lw lx">const Post = `<br/>  type Post {<br/>    id: Int!<br/>    title: String!<br/>    body: String!<br/>    author_id: Int!<br/>    author: User<br/>  }<br/>`;</span><span id="8f8d" class="lt kd hu lp b fv ly lv l lw lx">export default () =&gt; [Post, User];</span></pre><p id="07a9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">查询<br/> </strong>查询是您定义可以对模式运行什么查询的方式。下面是一个模式的根查询中的一些查询的例子；</p><pre class="lg lh li lj fq lo lp lq lr aw ls dt"><span id="6254" class="lt kd hu lp b fv lu lv l lw lx">const RootQuery = `<br/>  type RootQuery {<br/>    posts: [Post]<br/>    post(id:Int!): Post<br/>    users: [User]<br/>    user(id:Int!): User<br/>  }<br/>`;</span></pre><p id="04ce" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">突变<br/> </strong>突变类似于后请求(尽管它们实际上只是查询的同步版本)，它们允许你向服务器发送数据以执行插入、更新和其他工作。这里有一个为新的博客文章定义变异的例子，它接受postInput的输入类型，并将创建的文章作为Post类型返回。</p><pre class="lg lh li lj fq lo lp lq lr aw ls dt"><span id="4ed8" class="lt kd hu lp b fv lu lv l lw lx">const RootMutation = `<br/>  type RootMutation {<br/>    createPost(input: PostInput!): Post<br/>  }<br/>`;</span></pre><p id="4008" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">订阅<br/> </strong>订阅允许您通过GraphQL订阅服务器发布实时事件。</p><p id="7be3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是一个如何定义订阅的示例；</p><pre class="lg lh li lj fq lo lp lq lr aw ls dt"><span id="0ac7" class="lt kd hu lp b fv lu lv l lw lx">const RootSubscription = `<br/>  type RootSubscription {<br/>    postAdded(title: String): Post<br/>  }<br/>`;</span></pre><p id="5115" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，您可以通过在createPost变异解析器中运行此命令，向订阅者发布事件；</p><pre class="lg lh li lj fq lo lp lq lr aw ls dt"><span id="4c9d" class="lt kd hu lp b fv lu lv l lw lx">pubsub.publish(‘postAdded’, { postAdded: post });</span></pre><p id="e11d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">解析器</strong> <br/>解析器是您执行工作以响应查询、变异或订阅的地方。这是您进入数据库层进行CRUD操作并返回适当响应的地方。</p><p id="4ea3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是一些解析器函数的例子；</p><pre class="lg lh li lj fq lo lp lq lr aw ls dt"><span id="3412" class="lt kd hu lp b fv lu lv l lw lx">...<br/>resolvers: {<br/>  RootQuery: {<br/>    posts: () =&gt; posts,<br/>    post: async (_, { id }) =&gt; <br/>      await Post.query()<br/>  },<br/>  RootMutations: {<br/>    createPost: async (_, { input }) =&gt; <br/>      await Post.query.insert(input)<br/>  },<br/>  RootSubscriptions: {<br/>    postAdded: {<br/>    subscribe: () =&gt; <br/>      pubsub.asyncIterator('postAdded')<br/>  },<br/>  Post: {<br/>    author: async post =&gt; <br/>      await User.query().where("id", "=", post.author_id)<br/>  }<br/>}<br/>...</span></pre><p id="c18f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">模式是将所有运动的部分连接在一起的东西。让我们开始构建我们的API，这样我们就可以学习如何制作一个了！</p><h1 id="69c4" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">入门指南</h1><p id="2a4a" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">如果你想抢代码看看，这里有回购；<br/><a class="ae kb" href="https://github.com/mhaagens/express_graphql_hmr_article_boilerplate" rel="noopener ugc nofollow" target="_blank">https://github . com/mhaagens/express _ graph QL _ hmr _ article _ boilerplate</a></p><p id="7ff4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">安装依赖关系</strong></p><p id="5334" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">运行<code class="eh lz ma mb lp b">yarn init</code>然后<code class="eh lz ma mb lp b">yarn add express graphql-server-express graphql-tools graphql body-parser</code></p><p id="3ab6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，我们需要安装一些开发依赖项，我们不想每次做更改时都重启服务器，这就是Webpack可以帮助我们的地方。</p><p id="6fd9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">跑<code class="eh lz ma mb lp b">yarn add webpack webpack-node-externals start-server-webpack-plugin babel-loader babel-core babel-preset-env babel-preset-stage-0 babel-plugin-transform-runtime babel-plugin-transform-regenerator --dev</code></p><p id="24d6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">设置我们的webpack配置</strong></p><p id="1689" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在你的文件夹的根目录下，创建一个名为<code class="eh lz ma mb lp b">webpack.config.js</code>的文件，然后将它粘贴进去；</p><pre class="lg lh li lj fq lo lp lq lr aw ls dt"><span id="c6e7" class="lt kd hu lp b fv lu lv l lw lx">const webpack = require('webpack');<br/>const path = require('path');<br/>const nodeExternals = require('webpack-node-externals');<br/>const StartServerPlugin = require('start-server-webpack-plugin');</span><span id="42c6" class="lt kd hu lp b fv ly lv l lw lx">module.exports = {<br/>    entry: ['webpack/hot/poll?1000', './src/index'],<br/>    watch: true,<br/>    target: 'node',<br/>    node: {<br/>        __filename: true,<br/>        __dirname: true<br/>    },<br/>    externals: [nodeExternals({ whitelist: ['webpack/hot/poll?1000'] })],<br/>    module: {<br/>        rules: [<br/>            {<br/>                test: /\.js?$/,<br/>                use: [<br/>                    {<br/>                        loader: 'babel-loader',<br/>                        options: {<br/>                            babelrc: false,<br/>                            presets: [['env', { modules: false }], 'stage-0'],<br/>                            plugins: ['transform-regenerator', 'transform-runtime']<br/>                        }<br/>                    }<br/>                ],<br/>                exclude: /node_modules/<br/>            }<br/>        ]<br/>    },<br/>    plugins: [<br/>        new StartServerPlugin('server.js'),<br/>        new webpack.NamedModulesPlugin(),<br/>        new webpack.HotModuleReplacementPlugin(),<br/>        new webpack.NoEmitOnErrorsPlugin(),<br/>        new webpack.DefinePlugin({<br/>            'process.env': { BUILD_TARGET: JSON.stringify('server') }<br/>        })<br/>    ],<br/>    output: { path: path.join(__dirname, 'dist'), filename: 'server.js' }<br/>};</span></pre><p id="df70" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后将其添加到package.json脚本中；</p><pre class="lg lh li lj fq lo lp lq lr aw ls dt"><span id="04a8" class="lt kd hu lp b fv lu lv l lw lx">"scripts": {<br/>    "start": "webpack --config webpack.config.js"<br/>},</span></pre><p id="35f1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们创建一些启动和运行所需的文件</p><p id="70c2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">创建一个名为<code class="eh lz ma mb lp b">src</code>的文件夹，并在其中创建三个文件；<code class="eh lz ma mb lp b">index.js</code>、<code class="eh lz ma mb lp b">server.js</code>和<code class="eh lz ma mb lp b">schema.js</code></p><h1 id="5691" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">用graphql-tools设置我们的模式</h1><p id="45f7" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">内部<code class="eh lz ma mb lp b">schema.js</code>把这个贴进去；</p><pre class="lg lh li lj fq lo lp lq lr aw ls dt"><span id="e5e0" class="lt kd hu lp b fv lu lv l lw lx">import { makeExecutableSchema } from 'graphql-tools';</span><span id="b740" class="lt kd hu lp b fv ly lv l lw lx">const RootQuery = `<br/>  type RootQuery {<br/>    hello_world: String!<br/>   }<br/>`;</span><span id="3ae6" class="lt kd hu lp b fv ly lv l lw lx">const SchemaDefinition = `<br/>  schema {<br/>    query: RootQuery<br/>  }<br/>`;</span><span id="7a20" class="lt kd hu lp b fv ly lv l lw lx">export default makeExecutableSchema({<br/> typeDefs: [SchemaDefinition, RootQuery],<br/> resolvers: {<br/>   RootQuery: {<br/>     hello_world: () =&gt; "Hi from GraphQL!"<br/>   }<br/> }<br/>});</span></pre><p id="e976" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里我们定义了一个RootQuery，它将返回一个名为hello_world的查询。它返回一个必需的类型字符串(必需的由！在字符串类型定义之后)。String是GraphQL的内置类型，最终我们将创建自己的类型。</p><p id="f570" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在定义了我们的RootQuery之后，我们创建了一个模式定义，它将用于保存我们的查询、突变、订阅等等，然后我们将它导出为一个可执行的模式，供graphql-server-express使用。</p><h1 id="7183" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">创建我们的Webpack入口点</h1><p id="ea41" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">在<code class="eh lz ma mb lp b">index.js</code>中粘贴这个；</p><pre class="lg lh li lj fq lo lp lq lr aw ls dt"><span id="80c0" class="lt kd hu lp b fv lu lv l lw lx">import http from 'http';<br/>import { execute, subscribe } from 'graphql';<br/>import { createServer } from 'http';</span><span id="cf90" class="lt kd hu lp b fv ly lv l lw lx">import app from './server';<br/>import schema from './schema';</span><span id="2015" class="lt kd hu lp b fv ly lv l lw lx">const server = http.createServer(app);<br/>let currentApp = app;</span><span id="9d4d" class="lt kd hu lp b fv ly lv l lw lx">server.listen(3000, () =&gt; {<br/>  console.log(`GraphQL-server listening on port 3000.`)<br/>});</span><span id="2f17" class="lt kd hu lp b fv ly lv l lw lx">if (module.hot) {<br/>  module.hot.accept(['./server', './schema'], () =&gt; {<br/>    server.removeListener('request', currentApp);<br/>    server.on('request', app);<br/>    currentApp = app;<br/>  });<br/>}</span></pre><p id="7931" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个文件作为webpack导入我们的Express服务器的入口点，并在发生变化时重新热加载我们的服务器。</p><h1 id="d983" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">设置我们的Express GraphQL服务器</h1><p id="c477" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">最后，在<code class="eh lz ma mb lp b">server.js</code>中，我们将它粘贴进去；</p><pre class="lg lh li lj fq lo lp lq lr aw ls dt"><span id="64f3" class="lt kd hu lp b fv lu lv l lw lx">import express from 'express';<br/>import bodyParser from 'body-parser';<br/>import { graphqlExpress, graphiqlExpress } from 'graphql-server-express';</span><span id="dfcf" class="lt kd hu lp b fv ly lv l lw lx">import schema from './schema';</span><span id="5ce9" class="lt kd hu lp b fv ly lv l lw lx">const app = express();</span><span id="4f66" class="lt kd hu lp b fv ly lv l lw lx">app.use(<br/>  '/graphiql',<br/>  graphiqlExpress({<br/>    endpointURL: '/graphql'<br/>  })<br/>);<br/>app.use('/graphql', bodyParser.json(), graphqlExpress({ schema: schema }));</span><span id="e004" class="lt kd hu lp b fv ly lv l lw lx">export default app;</span></pre><p id="3328" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里我们将GraphQL附加到我们的/graphql端点，以及graph QL——一个用于运行/graph QL查询的GUI。</p><p id="7f98" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">运行<code class="eh lz ma mb lp b">npm start</code>并打开浏览器，转到<code class="eh lz ma mb lp b"><a class="ae kb" href="http://localhost:3000/graphiql" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/graphiql</a></code></p><p id="dc9a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Apollo Server(<a class="ae kb" href="https://github.com/apollographql/apollo-server" rel="noopener ugc nofollow" target="_blank">Apollo-Server</a>)附带了一个测试查询的GUI工具，叫做GraphiQL，这是一个很棒的工具，也是由脸书的好人们(GraphiQL的创造者)创造的。</p><p id="218a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在GraphiQL的左侧窗格中，粘贴以下内容并单击“运行”按钮(看起来像播放按钮的按钮)；</p><pre class="lg lh li lj fq lo lp lq lr aw ls dt"><span id="549b" class="lt kd hu lp b fv lu lv l lw lx">{<br/>  hello_world<br/>}</span></pre><p id="3b8d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您现在应该会在右边的窗格中看到一个输出，显示“来自GraphQL的Hi！”。</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mc"><img src="../Images/2c630a4ba1609c4733561c91febd3653.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EgK_bVMHkCl02hRO6MAdCA.png"/></div></div><figcaption class="lk ll fg fe ff lm ln bd b be z ek">Running our hello_world query.</figcaption></figure><p id="4a69" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">尝试更改hello_world解析器的值并重新运行查询，<br/>由于通过Webpack进行了热重新加载，它应该会立即返回您的新值！</p><p id="8e8c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为下一部分做准备</p><p id="89c7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">GraphQL可能很快变得难以使用，因此找出一个好的结构并模块化您的模式非常重要。<br/>让我们通过在<code class="eh lz ma mb lp b">src</code>中添加几个文件夹来为我们的结构打下基础；</p><p id="481a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh lz ma mb lp b">controllers/</code>、<code class="eh lz ma mb lp b">services/</code>、<code class="eh lz ma mb lp b">lib/</code>、<code class="eh lz ma mb lp b">models/</code>和<code class="eh lz ma mb lp b">types/</code></p><p id="a705" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第一部分到此为止。现在，您已经为带有Express和Apollo Server的可热加载GraphQL API做好了基础设置。</p><p id="8c5e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在下一部分中，我们将开始构建我们的项目，并添加解析器、突变、数据层、错误处理等等。</p><h2 id="51a3" class="lt kd hu bd ke md me mf ki mg mh mi km jn mj mk kq jr ml mm ku jv mn mo ky mp dt translated">敬请期待！</h2></div></div>    
</body>
</html>