<html>
<head>
<title>Getting started with React 16</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 16入门</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/getting-started-with-react-16-5ebd823d6990?source=collection_archive---------8-----------------------#2017-11-13">https://medium.com/hackernoon/getting-started-with-react-16-5ebd823d6990?source=collection_archive---------8-----------------------#2017-11-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/1f90955ece1f05c41ff63a3eb21c40b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GyhYeYlmTTWs0WRooh6bPg.png"/></div></div></figure><p id="7c12" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">距离<a class="ae ka" href="https://hackernoon.com/tagged/facebook" rel="noopener ugc nofollow" target="_blank">脸书</a>发布<a class="ae ka" href="https://reactjs.org/blog/2017/09/26/react-v16.0.html" rel="noopener ugc nofollow" target="_blank">反应16 </a>已经有一段时间了。<br/>新版本有很多新特性，有助于设计健壮的组件和增强功能，以加快渲染流水线。</p><p id="8b90" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank"> React </a> 16应该是完全向后兼容React 15的。正如React 16 <a class="ae ka" href="https://reactjs.org/blog/2017/09/26/react-v16.0.html#upgrading" rel="noopener ugc nofollow" target="_blank">官方博客文章</a>所述-</p><blockquote class="kb kc kd"><p id="ace6" class="jc jd ke je b jf jg jh ji jj jk jl jm kf jo jp jq kg js jt ju kh jw jx jy jz hn dt translated">如果你的应用在15.6中运行时没有任何警告，它应该在16中也能运行。</p></blockquote><p id="134d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">React 16还带有新的<a class="ae ka" href="https://opensource.org/licenses/MIT" rel="noopener ugc nofollow" target="_blank">麻省理工学院许可证</a>。如果你没有关注React团队为何改用新许可的新闻，请务必阅读<a class="ae ka" href="https://medium.freecodecamp.org/facebook-just-changed-the-license-on-react-heres-a-2-minute-explanation-why-5878478913b2" rel="noopener ugc nofollow" target="_blank">这篇文章</a>。</p><p id="7b5f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">谈到它的稳定性，React团队一直在为React 16的生产版本服务于<a class="ae ka" href="https://www.facebook.com/" rel="noopener ugc nofollow" target="_blank">脸书</a>和<a class="ae ka" href="https://www.messenger.com/" rel="noopener ugc nofollow" target="_blank">信使</a>。尽管增加了新功能，但与之前的版本相比，它的尺寸减小了32%。</p><p id="eba6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在不再浪费时间，我们来谈谈React 16的特性。</p></div><div class="ab cl ki kj hc kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hn ho hp hq hr"><h1 id="23d1" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">片段和字符串</h1><p id="4eb1" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">React 16让您能够从render方法返回一个<strong class="je hv">数组</strong>中的元素。</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="700b" class="mb kq hu lx b fv mc md l me mf">render() {<br/>    return [<br/>        &lt;h1 key="1"&gt;This is h1&lt;/h1&gt;,<br/>        &lt;h2 key="2"&gt;This is h2&lt;/h2&gt;,<br/>        &lt;h3 key="3"&gt;This is h3&lt;/h3&gt;<br/>    ];<br/>}</span></pre><p id="19df" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这意味着，在大多数情况下，你不需要在你的渲染方法中执行数组元素的映射。只需返回数组，它就会呈现得很好。</p><p id="c61b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里唯一的缺点是它仍然期望一个<strong class="je hv">键</strong>值被添加到每个数组元素中才能工作。</p><p id="dc0c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我觉得这不是一个大问题，而且React团队已经保证React的未来版本很可能会取消这一要求。</p><p id="7650" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">甚至<strong class="je hv">字符串</strong>和<strong class="je hv">数字</strong>现在都可以从render方法返回。</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="96ba" class="mb kq hu lx b fv mc md l me mf">render() {<br/>    return “Just a string”;<br/>}</span></pre><p id="b38d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以前版本的React会抛出这个错误-</p><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mg"><img src="../Images/40c9b0b3bd4468063797f4df601f7851.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4E_9raLoLh52nAMpVMLAkg.png"/></div></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek">Strings and numbers cannot be returned from the render method in React 15</figcaption></figure><p id="8543" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如您所见，render方法只允许返回有效的React元素。</p><p id="7b99" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用React 16，render方法可以返回- <br/> - React元素<br/> -字符串和数字<br/> -门户<br/> - Null <br/> -布尔表达式</p><p id="c485" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">字符串</strong>和<strong class="je hv">数字</strong>在DOM中呈现为常规的<strong class="je hv">文本节点</strong>，正如您所猜测的，<strong class="je hv"> null </strong>不呈现任何内容。</p><p id="056b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">更新:</strong> React 16.2于11月28日发布，改进了对从一个组件的render方法返回多个孩子(又名片段)的支持。关于这个的更多信息可以在官方<a class="ae ka" href="https://reactjs.org/blog/2017/11/28/react-v16.2.0-fragment-support.html" rel="noopener ugc nofollow" target="_blank">博客</a>上找到。</p></div><div class="ab cl ki kj hc kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hn ho hp hq hr"><h1 id="ef49" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">误差边界</h1><p id="5a3b" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">错误边界有助于您捕捉应用程序中的运行时错误，并允许您呈现回退用户界面。</p><p id="c5b3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当出现错误时，React的早期版本通常会使您的应用程序处于中断状态。为了解决这个问题，React 16提供了一个全新的生命周期钩子，叫做<strong class="je hv"> componentDidCatch，</strong>帮助你捕捉运行时错误。</p><p id="53a3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">错误边界在它们的子树中捕获错误<strong class="je hv">，这意味着如果错误发生在错误边界内的任何子组件中，那么特定错误边界的componentDidCatch生命周期方法将被触发。</strong></p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="7081" class="mb kq hu lx b fv mc md l me mf">componentDidCatch(error, info) {<br/>    // Render fallback UI<br/>    // Log error<br/>}</span></pre><p id="fb7b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">componentDidCatch返回两个参数——一个给出堆栈跟踪的<strong class="je hv"> error </strong>对象，和一个给出组件堆栈数据的<strong class="je hv"> info </strong>对象。</p><h2 id="9404" class="mb kq hu bd kr ml mm mn kv mo mp mq kz jn mr ms ld jr mt mu lh jv mv mw ll mx dt translated">误差边界是如何工作的</h2><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff my"><img src="../Images/882234a6e61bc280b94e9171ef52d914.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*TTeZv2v4SY4GfNIrmWpB3g.gif"/></div></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek">How Error Boundaries work</figcaption></figure><p id="5fac" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里需要注意几件事-</p><p id="1b10" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所有生命周期方法中的错误都可以被错误边界捕获，包括<strong class="je hv">构造器</strong>方法。</p><p id="405e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">错误边界无法捕捉自身内部的错误。</p><p id="5e57" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果错误边界由于某种原因失败，错误将传播到其上最近的错误边界。</p><p id="4e53" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里有一个关于如何创建和使用错误边界的例子-</p><figure class="ls lt lu lv fq iv"><div class="bz el l di"><div class="mz na l"/></div></figure><p id="3f0a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在上面的例子中，当在<strong class="je hv">子</strong>组件(第17行)中抛出错误时，<strong class="je hv">父</strong>组件的componentidcatch<strong class="je hv"/>生命周期方法触发(第33行)。在此基础上，我们改变状态，并在其位置上呈现一个回退UI(第38行)。</p><h2 id="b7c7" class="mb kq hu bd kr ml mm mn kv mo mp mq kz jn mr ms ld jr mt mu lh jv mv mw ll mx dt translated">出现错误时会发生什么？</h2><p id="d0d8" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">一旦出现错误，<strong class="je hv">错误堆栈跟踪</strong>和<strong class="je hv">组件堆栈数据</strong>被记录到控制台，组件树从根被卸载。这可以防止向用户显示损坏的数据。</p><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nb"><img src="../Images/f3cf91cf1723326247eaf02a34e46c82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HwJDlgl5ZujRZ2D7FEXxuQ.png"/></div></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek">Error stack trace returned by an Error Boundary</figcaption></figure><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nc"><img src="../Images/567b4dde76da43e52182e914e70de491.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1kCbv-ld7fzIfm6khvFrGQ.png"/></div></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek">Component stack data returned by an Error Boundary</figcaption></figure><p id="55db" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是真的有必要卸载整个React组件树吗？React团队已经讨论了这个决定，根据他们的经验，保留损坏的UI比完全移除它更糟糕。点击了解更多信息<a class="ae ka" href="https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html#new-behavior-for-uncaught-errors" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl ki kj hc kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hn ho hp hq hr"><h1 id="4dcf" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">门户网站</h1><p id="699c" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">门户允许您将子节点呈现或传送到不同的DOM节点层次结构中。</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="c38f" class="mb kq hu lx b fv mc md l me mf">render() {<br/>    return ReactDom.createPortal(child, node);<br/>}</span></pre><p id="26e3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">传递给门户的第一个参数是一个<strong class="je hv">子</strong>组件，它是任何可呈现的实体(render方法支持的实体)和一个<strong class="je hv"> DOM节点</strong>，子组件安装在该节点上。</p><p id="792b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">门户通常可用于呈现悬浮卡片或模态，其中的内容将以视觉上不同的非包含方式显示，脱离其父对象。</p><h2 id="c72b" class="mb kq hu bd kr ml mm mn kv mo mp mq kz jn mr ms ld jr mt mu lh jv mv mw ll mx dt translated">门户如何工作</h2><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff my"><img src="../Images/17f23bb0bb8bc64aae7f25c9ec5f11a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*EvpTR9_ecLQWmpl4t_V9FA.gif"/></div></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek">How Portals work</figcaption></figure><p id="ce97" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上图显示了创建门户的过程，目的是通过<strong class="je hv">模态</strong>节点将DOM层次1中的<strong class="je hv">文本</strong>组件呈现到DOM层次2中。</p><p id="0a72" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">模态</strong>组件创建一个门户，该门户将<strong class="je hv">文本</strong>组件安装到不同的DOM层次结构中。</p><p id="18b4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是上面例子的代码-</p><figure class="ls lt lu lv fq iv"><div class="bz el l di"><div class="mz na l"/></div></figure><h2 id="9f78" class="mb kq hu bd kr ml mm mn kv mo mp mq kz jn mr ms ld jr mt mu lh jv mv mw ll mx dt translated">门户中的事件冒泡</h2><p id="4e18" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">门户中的事件冒泡与普通React组件的工作方式相同，与它在DOM树中的位置无关。</p><p id="43eb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从门户内部触发的事件将传播到包含它的React树中的祖先，即使这些元素不是DOM树中的祖先。</p><figure class="ls lt lu lv fq iv"><div class="bz el l di"><div class="mz na l"/></div></figure><p id="3b60" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这种情况下，模式组件中的按钮没有<strong class="je hv"> onClick </strong>处理程序，因此一旦用户单击该按钮，事件就会传播到组件树中它的祖先，并且该组件的<strong class="je hv"> onClick </strong>处理程序就会触发。</p></div><div class="ab cl ki kj hc kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hn ho hp hq hr"><h1 id="786b" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">自定义DOM属性</h1><p id="f2ff" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">使用React 16，您可以向React组件传递自定义属性。</p><p id="c689" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">过去，React习惯于忽略未知的DOM属性。如果你用React不能识别的属性写JSX，React会跳过它。但是React 16允许将它们添加到组件中。</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="4b15" class="mb kq hu lx b fv mc md l me mf">render() {<br/>    return &lt;div data-attr="10" attr="20"&gt;App&lt;/div&gt;<br/>}</span></pre><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nd"><img src="../Images/a7ef794e7fa6ac4c1d65859faa95f235.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DCkKSgaC23bKmN4gl0sBFw.png"/></div></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek">Custom DOM attributes in React 16</figcaption></figure><p id="7441" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">注意，您仍然应该对已知属性使用规范的React命名- </strong></p><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ne"><img src="../Images/0502e82d7ea164c846e329d2c9e36c5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qcn4L8Y1ugphdR9qa7xB3Q.png"/></div></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek">Canonical naming convention in React</figcaption></figure><h2 id="d697" class="mb kq hu bd kr ml mm mn kv mo mp mq kz jn mr ms ld jr mt mu lh jv mv mw ll mx dt translated">属性白名单</h2><p id="8d8b" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">React以前的版本有一个属性白名单，其中包含React可以识别的属性列表，并允许将它们添加到组件中。</p><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nf"><img src="../Images/936b80aef5ce260c5ae9d727f3c450dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Noez5TJiywUTelS2PgehLg.png"/></div></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek">Attributes whitelist in React 15</figcaption></figure><p id="e9bc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">React 16消除了这一点，因此没有更多的属性与白名单匹配，导致文件更小。</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="8750" class="mb kq hu lx b fv mc md l me mf">render() {<br/>    return &lt;div custom-attr=“20"&gt;App&lt;/div&gt;<br/>}</span></pre><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ng"><img src="../Images/13d78681b46058db59199445c9e5f510.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V82R1HxGub7IANP8CuKK0A.png"/></div></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek">React 16 support for custom attributes</figcaption></figure><p id="6ef8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您需要使用非标准属性，或者如果您需要与依赖于此类属性的第三方库集成，自定义属性会很方便。就像以前一样，React 16也允许您对组件使用<strong class="je hv"> data- </strong>和<strong class="je hv"> aria- </strong>属性。</p></div><div class="ab cl ki kj hc kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hn ho hp hq hr"><h1 id="773a" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">新核心架构</h1><p id="752b" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">React 16有一个完全重写的架构，代号为<strong class="je hv"> Fiber。</strong></p><h2 id="2662" class="mb kq hu bd kr ml mm mn kv mo mp mq kz jn mr ms ld jr mt mu lh jv mv mw ll mx dt translated">异步渲染</h2><p id="b2f1" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">新的核心算法完全向后兼容，并基于<strong class="je hv">优先级调度</strong>系统。事件基于优先级进行流式处理，并计划由浏览器呈现，此方法不会阻塞主线程。</p><p id="f497" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">像<strong class="je hv">输入</strong>这样的事件被认为是高优先级事件，用户需要得到实时反馈，其他的如<strong class="je hv"> ajax </strong>被认为是低优先级事件。</p><p id="d138" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">调度系统大量使用了<strong class="je hv">请求回调</strong> API。</p><p id="f894" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此方法将在浏览器空闲期间调用的函数排队。这使开发人员能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。</p><p id="ebd8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在不支持该API的浏览器中，React提供了一个polyfill。</p><p id="c7fc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你想更多地了解纤维的工作原理，我强烈建议你去看看林·克拉克的这个<a class="ae ka" href="https://www.youtube.com/watch?v=ZCuYPiUIONs&amp;index=5&amp;list=PLb0IAmt7-GS3fZ46IGFirdqKTIxlws7e0" rel="noopener ugc nofollow" target="_blank">演讲</a>，或者阅读React团队的这篇<a class="ae ka" href="https://code.facebook.com/posts/1716776591680069/react-16-a-look-inside-an-api-compatible-rewrite-of-our-frontend-ui-library/" rel="noopener ugc nofollow" target="_blank">博客文章</a>中的详细内容。</p></div><div class="ab cl ki kj hc kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hn ho hp hq hr"><h1 id="c0f1" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">改进的服务器端渲染</h1><p id="f022" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">React 16中的服务器端渲染器也进行了重写。据说比<strong class="je hv">快3倍</strong>。</p><p id="f8cf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它提供了更快的组件流，通过网络传输到客户机。</p><p id="f4ac" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">新的打包策略(由<a class="ae ka" href="https://rollupjs.org/" rel="noopener ugc nofollow" target="_blank">汇总模块捆绑器</a>促成)摆脱了<strong class="je hv"> process.env </strong>检查，这确实很慢。</p><p id="4715" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">React 16通过新的<a class="ae ka" href="https://reactjs.org/docs/react-dom-server.html#rendertonodestream" rel="noopener ugc nofollow" target="_blank"><strong class="je hv">renderToNodeStream</strong></a><em class="ke"/>API支持组件流。请随意查看<strong class="je hv"> ReactDOMServer </strong> 的<a class="ae ka" href="https://reactjs.org/docs/react-dom-server.html" rel="noopener ugc nofollow" target="_blank">文档了解更多详情。</a></p><p id="6ac4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">React团队的核心成员之一Sasha Aickin写了一篇关于React 16的SSR改进的很棒的<a class="ae ka" href="https://hackernoon.com/whats-new-with-server-side-rendering-in-react-16-9b0d78585d67" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><p id="a468" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如博文中所说-</p><blockquote class="kb kc kd"><p id="d7ba" class="jc jd ke je b jf jg jh ji jj jk jl jm kf jo jp jq kg js jt ju kh jw jx jy jz hn dt translated">当与编译出process.env <strong class="je hv"> </strong>的React 15进行比较时，Node 4的性能提升了约2.4倍，Node 6的性能提升了约3倍，而在新的Node 8.4版本中，性能提升了整整3.8倍。而如果和没有编译的React 15对比，React 16在Node最新版本的SSR上有整整一个数量级的增益！</p></blockquote><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nh"><img src="../Images/8f6247612b9d7d6dc1d1daab540b30f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q4eha5UPkmN3Tjr5f2Qjtw.png"/></div></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek">SSR improvements in React 16</figcaption></figure></div><div class="ab cl ki kj hc kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hn ho hp hq hr"><h1 id="60a4" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">减小文件大小</h1><p id="8680" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">尽管增加了所有新功能，React 16实际上比15.6.1小了<strong class="je hv">！</strong></p><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ni"><img src="../Images/61c18d3def3fd06d4ed388422037cff6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5KNNQ1OPgiQMwx7TGXELHQ.png"/></div></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek">Reduced file size in React 16</figcaption></figure><p id="38f3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">尺寸差异部分归因于包装的变化。React现在使用<a class="ae ka" href="https://rollupjs.org/" rel="noopener ugc nofollow" target="_blank"> Rollup </a>为每种不同的目标格式创建平面包，从而在大小和运行时性能方面都取得了胜利。</p></div><div class="ab cl ki kj hc kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hn ho hp hq hr"><h1 id="be6d" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">装置</h1><p id="a498" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">您可以立即开始使用React 16，它在NPM和Yarn上可用。</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="8437" class="mb kq hu lx b fv mc md l me mf">npm install --save react@^16.0.0 react-dom@^16.0.0</span><span id="9d29" class="mb kq hu lx b fv nj md l me mf">yarn add react@^16.0.0 react-dom@^16.0.0</span></pre><p id="c215" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">详细的安装说明可以在<a class="ae ka" href="https://reactjs.org/docs/installation.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。关于弃用和突破性变化的细节可以在<a class="ae ka" href="https://reactjs.org/blog/2017/09/26/react-v16.0.html#upgrading" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div><div class="ab cl ki kj hc kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hn ho hp hq hr"><p id="bceb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不久前，我还在React 16上发表了一篇演讲，你可以在这里查看丹·阿布拉莫夫本人转发的这张卡片😄</p><p id="a324" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">暂时就这样吧！如果你喜欢这篇文章，别忘了给它一些👏<br/>另外，欢迎在<a class="ae ka" rel="noopener" href="/@arunmichaeldsouza"> Medium </a>、<a class="ae ka" href="https://twitter.com/amdsouza92" rel="noopener ugc nofollow" target="_blank"> Twitter </a>和<a class="ae ka" href="https://github.com/ArunMichaelDsouza" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上关注我。</p><p id="5a4c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">谢谢！</p><figure class="ls lt lu lv fq iv"><div class="bz el l di"><div class="nk na l"/></div></figure></div></div>    
</body>
</html>