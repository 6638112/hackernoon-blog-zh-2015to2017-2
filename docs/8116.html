<html>
<head>
<title>I have a confession to make… I commit to master.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我要向你坦白…我向师父承诺。</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/i-have-a-confession-to-make-i-commit-to-master-6a804f334beb?source=collection_archive---------0-----------------------#2017-11-20">https://medium.com/hackernoon/i-have-a-confession-to-make-i-commit-to-master-6a804f334beb?source=collection_archive---------0-----------------------#2017-11-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/5b2acd92ccd2d7085586a3fb189215ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yOmKInnYBSIeSQxCMxfCfA.png"/></div></div></figure><p id="ff7f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我曾经鼓吹Git Flow来保持我的代码可发布、可回滚，并保持一个干净的历史。但现在不是了——现在，糟糕的代码不会进入我的代码库。</p><p id="fb75" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是因为我有一个强大的持续部署管道。</p><p id="25cc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有了这个管道，我和我的团队成员可以直接向master提交。</p><p id="020a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我能听到干草叉已经被磨尖了。“千万不要委身于师父！”</p><p id="bfe6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我知道，我知道，我以前也说过同样的话。"你需要有分支来保持你的代码有条理，并且能够检查它！"但是，谁想这么做呢？自动化它！</p><p id="64ac" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">想象一下。您所做的每一次提交都会被忽略，小错误会被自动修复，您的代码会被彻底测试，并且您的覆盖率阈值会被强制执行。该过程在一个全新的容器中完成，确保不会忘记任何全局依赖项。然后，对完成的容器执行测试，以证明<em class="ka">将</em>与依赖项(如数据库、消息队列和其他任何服务)正确集成(集成测试)。如果一切顺利，代码被成功地推送到GitHub，在那里我的持续部署服务器获取代码并完成工作。</p><p id="a6af" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果它能投入使用，我肯定它能起作用。经过了很好的检验。</p><p id="ad92" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我敢肯定，此时你会想“听起来工作量很大”。</p><p id="d612" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">幸运的是，我花了几个月的时间反复试验，现在我想向你展示我每天用来自信地投入<code class="eh kb kc kd ke b">master</code>的过程和技巧。到这篇文章结束时，你将拥有构建你自己的生产优化的Dockerized持续集成过程所需的所有技能，并通过利用Docker Compose和Docker多阶段构建在每次提交时运行它。</p><p id="2b23" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kb kc kd ke b">master</code>部署起来总是安全的。</p><p id="60cb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意:如果你是Node.js工程师，你很幸运！示例适用于节点。对于其他人来说，概念和技术是相同的。您应该能够推断出该过程对于您选择的语言应该如何工作。</p><p id="ea14" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是首先，简单介绍一下持续部署的不同阶段。</p><h2 id="8bcc" class="kf kg hu bd kh ki kj kk kl km kn ko kp jn kq kr ks jr kt ku kv jv kw kx ky kz dt translated">持续集成、持续交付和持续部署</h2><p id="5abc" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">这些术语经常互换使用，但这是不正确的。在下面的图表中，我定义了哪些任务适合哪些领域。</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lf"><img src="../Images/b58d6f8fba115736df21a4113e36ccf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HA78GQq68y_d1teZjpBp8Q.png"/></div></div></figure><p id="8601" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一段时间以来，我一直提倡将docker-compose builder模式用于持续集成管道。然而，随着Docker多阶段构建的出现，现在更容易获得更小、更高效的容器。</p><p id="cf6c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Docker本质上是一个你的代码运行的隔离环境。就像配置服务器一样，您可以配置docker容器。大多数流行的框架和软件都有Docker Hub提供的版本。似乎我们如何使用节点，我们需要一个运行<code class="eh kb kc kd ke b">node</code>的环境。我们将以此开始我们的文档。</p><pre class="lg lh li lj fq lk ke ll lm aw ln dt"><span id="540c" class="kf kg hu ke b fv lo lp l lq lr"># Dockerfile</span><span id="402c" class="kf kg hu ke b fv ls lp l lq lr">FROM node:9-alpine AS build</span></pre><p id="2122" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意<code class="eh kb kc kd ke b">AS</code>指令。这表明这不是Dockerfile文件的最后阶段。稍后，我们可以将这个阶段中的工件放入我们的最终容器中。我们继续吧。</p><p id="cf3d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了简化起见，假设我们使用的库需要node-gyp来正确安装依赖项，因为它需要为您运行的操作系统编译本机<code class="eh kb kc kd ke b">c++</code>二进制文件。在大多数情况下你不需要这个，但是一些流行的库，比如<code class="eh kb kc kd ke b">redis</code>需要它。</p><pre class="lg lh li lj fq lk ke ll lm aw ln dt"><span id="8b16" class="kf kg hu ke b fv lo lp l lq lr"># Dockerfile continued</span><span id="5d9d" class="kf kg hu ke b fv ls lp l lq lr"># optionally install gyp tools<br/>RUN apk add --update --no-cache \<br/>    python \<br/>    make \<br/>    g++</span></pre><p id="d027" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这可能是T4环境中最复杂的了。</p><p id="37f1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不到一年前，我会告诉您构建这个映像并将其推送到Docker注册表中，作为其他<code class="eh kb kc kd ke b">node-gyp</code>相关构建的基础映像，事实上，我做到了。然而，随着Docker多阶段构建的出现，额外的步骤不再是必要的。事实上，我要说的是，由于保持多张图片更新的要求，它不再被推荐。相反，让我们继续我们的管道，并利用多阶段构建来生产我们的构建。首先，我们需要定义我们的管道在应用程序的上下文中是什么。</p><h2 id="b1fe" class="kf kg hu bd kh ki kj kk kl km kn ko kp jn kq kr ks jr kt ku kv jv kw kx ky kz dt translated">定义管道</h2><p id="b223" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">同样，为了有一个真实的例子，我假设我们使用babel作为预处理器，eslint作为linter，jest作为测试工具。然而，管道将只通过调用npm脚本来运行，所以替换您正在使用的工具应该很容易，比如TypeScript等。</p><p id="e8ec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是使用这些工具的package.json文件的示例<code class="eh kb kc kd ke b">scripts</code>部分:</p><pre class="lg lh li lj fq lk ke ll lm aw ln dt"><span id="9f37" class="kf kg hu ke b fv lo lp l lq lr">// package.json</span><span id="5b0b" class="kf kg hu ke b fv ls lp l lq lr">"scripts": {<br/>  "start": "nodemon src/index.js --watch src node_modules --exec babel-node",<br/>  "build": "babel src -d dist",<br/>  "serve": "node dist/index.js",<br/>  "lint": "eslint src __tests__",<br/>  "lint:fix": "eslint --fix src __tests__",<br/>  "test": "NODE_ENV=test jest --config jest.json --coverage",<br/>  "test:staging": "jest --config jest.staging.json --runInBand",<br/>  "test:watch": "NODE_ENV=test jest --config jest.json --watch --coverage",<br/>}</span></pre><p id="3221" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们的CI流程中，我们希望涵盖林挺、测试和构建我们的应用程序，以及构建容器，并使用我们的阶段测试来测试容器。通过继续我们的cover文件，我们可以涵盖除了staging测试之外的所有内容，staging测试需要构建的容器作为输入。</p><pre class="lg lh li lj fq lk ke ll lm aw ln dt"><span id="f893" class="kf kg hu ke b fv lo lp l lq lr"># Dockerfile continued </span><span id="afbc" class="kf kg hu ke b fv ls lp l lq lr">ADD . /src<br/>WORKDIR /src<br/>RUN npm install<br/>RUN npm run lint<br/>RUN npm run test<br/>RUN npm run build<br/>RUN npm prune --production</span></pre><p id="6e5c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，我们将我们的源代码<code class="eh kb kc kd ke b">ADD</code>到容器中，到一个名为<code class="eh kb kc kd ke b">/src</code>的文件夹，然后将我们的<code class="eh kb kc kd ke b">WORKDIR</code>改变到现在包含我们代码的那个<code class="eh kb kc kd ke b">/src</code>目录。接下来，我们简单地运行适当的<code class="eh kb kc kd ke b">npm</code>脚本到<code class="eh kb kc kd ke b">install</code>依赖项、<code class="eh kb kc kd ke b">lint</code>我们的代码、<code class="eh kb kc kd ke b">test</code>我们的代码，用<code class="eh kb kc kd ke b">build</code>编译我们的代码，然后用<code class="eh kb kc kd ke b">npm prune --production</code>删除devDependencies。</p><p id="cb08" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们继续之前，我想多谈一点测试步骤，因为我们使用了<code class="eh kb kc kd ke b">--coverage</code>标志，所以它也被建立来测量覆盖率。我们还传入了一个<code class="eh kb kc kd ke b">jest.json</code>文件作为配置文件。这是定义覆盖阈值的地方。</p><pre class="lg lh li lj fq lk ke ll lm aw ln dt"><span id="50de" class="kf kg hu ke b fv lo lp l lq lr">// jest.json</span><span id="0014" class="kf kg hu ke b fv ls lp l lq lr">{<br/>  "testEnvironment": "node",<br/>  "modulePaths": [<br/>    "src",<br/>    "/node_modules/"<br/>  ],<br/>  "coverageThreshold": {<br/>    "global": {<br/>      "branches": 100,<br/>      "functions": 100,<br/>      "lines": 100,<br/>      "statements": 100<br/>    }<br/>  },<br/>  "collectCoverageFrom" : [<br/>    "src/**/*.js"<br/>  ]<br/>}</span></pre><p id="42e6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您想保持90%的覆盖率，您可以将每个标记为<code class="eh kb kc kd ke b">100</code>的选项减少到<code class="eh kb kc kd ke b">90</code>。如果没有达到覆盖率阈值，测试将会失败。</p><p id="6590" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你想像我一样自动格式化你的代码，这里有<a class="ae lt" href="https://gist.github.com/patrickleet/052610cc90e58942a10175d3af324e7a" rel="noopener ugc nofollow" target="_blank">。eslintrc文件我将</a>与ESLint一起使用。而且，只是为了让你的生活更轻松，<a class="ae lt" href="https://gist.github.com/patrickleet/9492c7da1e3594f3eb8aff1b1efbd61a" rel="noopener ugc nofollow" target="_blank">。babelrc文件我用</a>，带Babel。</p><h2 id="db31" class="kf kg hu bd kh ki kj kk kl km kn ko kp jn kq kr ks jr kt ku kv jv kw kx ky kz dt translated">构建的第二阶段</h2><p id="c71c" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">到目前为止，我们的docker文件从一个新的Node环境开始，在Alpine linux上，有选择地安装node-gyp工具，然后添加、链接、测试和编译我们的代码，最后删除开发依赖。我们剩下的是生产构建所需的所有工件。不幸的是，到目前为止，我们所需要的工具变得更加臃肿。我们将使用多阶段构建，使用<code class="eh kb kc kd ke b">COPY --from=build</code>，仅将我们需要的工件复制到我们最终生产化的容器中。</p><pre class="lg lh li lj fq lk ke ll lm aw ln dt"><span id="b435" class="kf kg hu ke b fv lo lp l lq lr"># Dockerfile continued</span><span id="982a" class="kf kg hu ke b fv ls lp l lq lr">FROM node:9-alpine</span><span id="ec36" class="kf kg hu ke b fv ls lp l lq lr"># install curl for healthcheck<br/>RUN apk add --update --no-cache curl</span><span id="7837" class="kf kg hu ke b fv ls lp l lq lr">ENV PORT=3000<br/>EXPOSE $PORT</span><span id="472b" class="kf kg hu ke b fv ls lp l lq lr">ENV DIR=/usr/src/service<br/>WORKDIR $DIR</span><span id="7280" class="kf kg hu ke b fv ls lp l lq lr"># Copy files from build stage<br/>COPY --from=build /src/package.json package.json<br/>COPY --from=build /src/package-lock.json package-lock.json<br/>COPY --from=build /src/node_modules node_modules<br/>COPY --from=build /src/dist dist</span><span id="c4ff" class="kf kg hu ke b fv ls lp l lq lr">HEALTHCHECK --interval=5s \<br/>            --timeout=5s \<br/>            --retries=6 \<br/>            CMD curl -fs <a class="ae lt" href="http://localhost:$PORT/_health" rel="noopener ugc nofollow" target="_blank">http://localhost:$PORT/_health</a> || exit 1</span><span id="f25c" class="kf kg hu ke b fv ls lp l lq lr">CMD ["node", "dist/index.js"]</span></pre><p id="a207" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就完成了我们的文档。在我的例子中，最终的大小是一个28MB的容器，其中有我的产品<code class="eh kb kc kd ke b">node_modules</code>，和我的<code class="eh kb kc kd ke b">dist</code>文件夹，其中有babel编译的javascript源代码。要运行，只需使用vanilla <code class="eh kb kc kd ke b">node</code>。我还定义了一个健康检查，Docker Swarm这样的调度器可以使用它来确保容器是健康的。<code class="eh kb kc kd ke b">curl</code>这可能不是最有效的健康检查，但却是一个很好的起点。</p><p id="843d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里有一个完整的dock文件，可以满足您所有的复制和粘贴需求！</p><pre class="lg lh li lj fq lk ke ll lm aw ln dt"><span id="d899" class="kf kg hu ke b fv lo lp l lq lr">FROM node:9-alpine AS build</span><span id="c8b9" class="kf kg hu ke b fv ls lp l lq lr"># install gyp tools<br/>RUN apk add --update --no-cache \<br/>        python \<br/>        make \<br/>        g++</span><span id="fb4b" class="kf kg hu ke b fv ls lp l lq lr">ADD . /src<br/>WORKDIR /src<br/>RUN npm install<br/>RUN npm run lint<br/>RUN npm run test<br/>RUN npm run build<br/>RUN npm prune --production</span><span id="7585" class="kf kg hu ke b fv ls lp l lq lr">FROM node:9-alpine<br/>RUN apk add --update --no-cache curl</span><span id="6782" class="kf kg hu ke b fv ls lp l lq lr">ENV PORT=3000<br/>EXPOSE $PORT</span><span id="6f11" class="kf kg hu ke b fv ls lp l lq lr">ENV DIR=/usr/src/service<br/>WORKDIR $DIR</span><span id="0f94" class="kf kg hu ke b fv ls lp l lq lr">COPY --from=build /src/package.json package.json<br/>COPY --from=build /src/package-lock.json package-lock.json<br/>COPY --from=build /src/node_modules node_modules<br/>COPY --from=build /src/dist dist</span><span id="b708" class="kf kg hu ke b fv ls lp l lq lr">HEALTHCHECK --interval=5s \<br/>            --timeout=5s \<br/>            --retries=6 \<br/>            CMD curl -fs <a class="ae lt" href="http://localhost:$PORT/_health" rel="noopener ugc nofollow" target="_blank">http://localhost:$PORT/_health</a> || exit 1</span><span id="563a" class="kf kg hu ke b fv ls lp l lq lr">CMD ["node", "dist/index.js"]</span></pre><p id="c1d4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，简单地运行:</p><pre class="lg lh li lj fq lk ke ll lm aw ln dt"><span id="c297" class="kf kg hu ke b fv lo lp l lq lr">docker image build -t your-image-name .</span></pre><p id="5f8d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将负责我们80%的CI渠道。下一步是测试容器及其集成。</p><h2 id="2a4b" class="kf kg hu bd kh ki kj kk kl km kn ko kp jn kq kr ks jr kt ku kv jv kw kx ky kz dt translated">集成测试</h2><p id="8954" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">对于集成测试，我们需要运行其他软件，如数据库、消息队列或我们系统中的其他服务，并测试它们是否能一起工作——它们是否集成。因为这个任务需要同时运行多个图像，我们将使用适合这类任务的<code class="eh kb kc kd ke b">docker-compose</code>。</p><p id="19ab" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">同样，我试图坚持现实，而不是简化的例子，这里是我用来测试基于CQRS和事件源的架构中更复杂的微服务的docker-compose文件，它依赖于<code class="eh kb kc kd ke b">redis</code>、<code class="eh kb kc kd ke b">mongodb</code>和<code class="eh kb kc kd ke b">rabbitmq</code>。</p><pre class="lg lh li lj fq lk ke ll lm aw ln dt"><span id="7cd1" class="kf kg hu ke b fv lo lp l lq lr">version: '2'</span><span id="eace" class="kf kg hu ke b fv ls lp l lq lr">services:</span><span id="cac3" class="kf kg hu ke b fv ls lp l lq lr">  staging-deps:<br/>    image: your-image-name<br/>    environment:<br/>      - NODE_ENV=production<br/>      - PORT=3000<br/>      - RABBITMQ_URL=amqp://rabbitmq:5672<br/>      - REDIS_HOST=redis<br/>      - REDIS_PORT=6379<br/>      - MONGO_URL=mongodb://mongo:27017/inventory<br/>      - DEBUG=servicebus*<br/>    networks:<br/>      - default<br/>    depends_on:<br/>      - redis<br/>      - rabbitmq<br/>      - mongo</span><span id="c378" class="kf kg hu ke b fv ls lp l lq lr">  rabbitmq:<br/>    image: rabbitmq:3.6-management<br/>    ports:<br/>      - 15672:15672<br/>    hostname: rabbitmq<br/>    networks:<br/>      - default</span><span id="f189" class="kf kg hu ke b fv ls lp l lq lr">  redis:<br/>    image: redis<br/>    networks:<br/>      - default</span><span id="8e4e" class="kf kg hu ke b fv ls lp l lq lr">  mongo:<br/>    image: mongo<br/>    ports:<br/>      - 27017:27017<br/>    networks:<br/>      - default</span><span id="a488" class="kf kg hu ke b fv ls lp l lq lr">  staging:<br/>    image: node:8-alpine<br/>    volumes:<br/>      - .:/usr/src/service<br/>    working_dir: /usr/src/service<br/>    networks:<br/>      - default<br/>    environment:<br/>      - apiUrl=<a class="ae lt" href="http://staging-deps:3000" rel="noopener ugc nofollow" target="_blank">http://staging-deps:3000</a><br/>      - RABBITMQ_URL=amqp://rabbitmq:5672<br/>      - REDIS_HOST=redis<br/>      - REDIS_PORT=6379<br/>      - MONGO_URL=mongodb://mongo:27017/inventory<br/>      - DEBUG=$DEBUG<br/>    command: npm run test:staging</span><span id="78a1" class="kf kg hu ke b fv ls lp l lq lr">  clean:<br/>    extends:<br/>      service: staging<br/>    command: rm -rf node_modules</span><span id="544a" class="kf kg hu ke b fv ls lp l lq lr">  install:<br/>    extends: <br/>      service: staging<br/>    command: npm run install</span></pre><p id="b232" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">特别注意<code class="eh kb kc kd ke b">staging-deps</code>和<code class="eh kb kc kd ke b">staging</code>服务。</p><p id="9b5e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kb kc kd ke b">staging-deps</code>正在运行之前运行的<code class="eh kb kc kd ke b">docker image build</code>命令生成的图像。这是通过将<code class="eh kb kc kd ke b">image:</code>设置为我们在build命令中用<code class="eh kb kc kd ke b">-t</code>设置的标签来实现的。我们传递给它一堆环境变量，让我们的服务知道如何连接到我们网络中运行的不同容器，这就是<code class="eh kb kc kd ke b">default</code>网络。每个docker-compose文件都可以定义网络，并且默认有一个<code class="eh kb kc kd ke b">default</code>网络。Docker还通过其软件定义网络(sdn)处理服务发现，因此主机名将解析为网络上同名容器的IP地址。例如，<code class="eh kb kc kd ke b">MONGO_URL=mongodb://mongo:27017/inventory</code>中的<code class="eh kb kc kd ke b">mongo</code>将解析到SDN中的mongo容器。最后，<code class="eh kb kc kd ke b">depends_on</code>将告诉docker在调出集装箱时首先启动所依赖的集装箱。</p><p id="0fd9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kb kc kd ke b">staging</code>是一个基于<code class="eh kb kc kd ke b">node</code>的容器，使用<code class="eh kb kc kd ke b">volumes</code>指令将我们的源代码装入其中。集成测试将从此容器中运行。</p><p id="2c72" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此外，还有两个“服务”我们也将作为脚本运行:<code class="eh kb kc kd ke b">clean</code>和<code class="eh kb kc kd ke b">install</code>。<code class="eh kb kc kd ke b">clean</code>为了确保我们使用正确版本的<code class="eh kb kc kd ke b">node_modules</code>,我们似乎可以在我们的主机操作系统(如Mac)和Alpine Linux(我们的容器基于这两种操作系统)上进行切换。</p><p id="ca2b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，我们将提出依赖关系:</p><pre class="lg lh li lj fq lk ke ll lm aw ln dt"><span id="011a" class="kf kg hu ke b fv lo lp l lq lr">docker-compose -f docker-compose.staging.yml up -d staging-deps</span></pre><p id="61cd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">根据您的服务是否考虑重试连接，您可能希望首先简单地启动某些容器，并在它们准备就绪时休眠。或者，像<code class="eh kb kc kd ke b">wait-for-it.sh</code>这样的脚本可以通过shell脚本来完成。</p><p id="2f1b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦您的依赖项启动并运行，您将需要运行阶段测试。我们已经将代码装载到容器中，但是还没有在上面安装npm依赖项。运行以下命令来安装linux容器的依赖项，然后运行分段测试。</p><pre class="lg lh li lj fq lk ke ll lm aw ln dt"><span id="c118" class="kf kg hu ke b fv lo lp l lq lr">docker-compose -f docker-compose.staging.yml run --rm install<br/>docker-compose -f docker-compose.staging.yml run --rm staging</span></pre><p id="417e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您的集成/试运行测试通过，您将有信心继续进行交付和部署阶段！但是首先，让我们自动运行我们的管道，这样我们就可以在每次提交时运行它。</p><h2 id="6b81" class="kf kg hu bd kh ki kj kk kl km kn ko kp jn kq kr ks jr kt ku kv jv kw kx ky kz dt translated">自动化管道</h2><p id="a96a" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">首先，让我们创建一个<code class="eh kb kc kd ke b">Makefile</code>。我们的目标是能够运行<code class="eh kb kc kd ke b">make ci</code>来运行整个CI流程。</p><pre class="lg lh li lj fq lk ke ll lm aw ln dt"><span id="c4ec" class="kf kg hu ke b fv lo lp l lq lr">ci:<br/>  make docker-build \<br/>     clean \<br/>     install \<br/>     staging \<br/>     staging-down</span><span id="d17a" class="kf kg hu ke b fv ls lp l lq lr">docker-build:<br/>  docker build -t your-image-name .</span><span id="7573" class="kf kg hu ke b fv ls lp l lq lr">clean:<br/>  docker-compose -f docker-compose.staging.yml run --rm clean</span><span id="8f00" class="kf kg hu ke b fv ls lp l lq lr">install:<br/>  docker-compose -f docker-compose.staging.yml run --rm install</span><span id="5dcf" class="kf kg hu ke b fv ls lp l lq lr">staging:  <br/>  docker-compose -f docker-compose.staging.yml up -d staging-deps<br/>  docker-compose -f docker-compose.staging.yml run --rm staging</span><span id="354c" class="kf kg hu ke b fv ls lp l lq lr">staging-down:<br/>  docker-compose -f docker-compose.staging.yml down</span></pre><h2 id="c38d" class="kf kg hu bd kh ki kj kk kl km kn ko kp jn kq kr ks jr kt ku kv jv kw kx ky kz dt translated">每次提交时运行</h2><p id="9c11" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">我在本地运行每个提交，使用一个名为<code class="eh kb kc kd ke b">husky</code>的npm包，并再次在我的CI服务器上运行，它通常是Jenkins 2.0管道。</p><p id="dca9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要在本地运行，让我们通过运行以下命令将<code class="eh kb kc kd ke b">husky</code>安装到我们的devDependencies中</p><pre class="lg lh li lj fq lk ke ll lm aw ln dt"><span id="83b8" class="kf kg hu ke b fv lo lp l lq lr">npm i --save-dev husky</span></pre><p id="2355" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Husky让安装和运行git挂钩变得超级简单。只需打开您的<code class="eh kb kc kd ke b">package.json</code>，添加以下两个脚本:</p><pre class="lg lh li lj fq lk ke ll lm aw ln dt"><span id="807f" class="kf kg hu ke b fv lo lp l lq lr">"scripts": {<br/>  // ...<br/>  "precommit": "npm run lint:fix &amp;&amp; npm run test",<br/>  "prepush": "make ci"<br/>},</span></pre><p id="5f15" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，在每次提交时，在每个开发人员的机器上，husky将修复所有可以自动修复的林挺错误，并运行单元测试。我们的测试被配置为具有100%的覆盖率，因此如果有任何测试没有通过，或者没有达到覆盖率阈值，提交将被阻塞。此外，在每次尝试推送时，我们定义的整个CI流程都将运行。这对于捕获可能已经本地安装但没有保存到package.json的任何dep非常有用，并确保在生产中托管的操作系统中运行时一切都通过，以及测试使用阶段测试构建的容器。</p><h2 id="4ad2" class="kf kg hu bd kh ki kj kk kl km kn ko kp jn kq kr ks jr kt ku kv jv kw kx ky kz dt translated">结论</h2><p id="2f34" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">此时，您已经拥有了在每次提交时运行完整的Dockerized持续集成过程所需的一切，并且防止了坏代码进入您的代码库。但这远不是旅程的终点。关注我，获取更多类似主题的帖子！</p><p id="91aa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">至于接下来的步骤:</p><ul class=""><li id="a966" class="lu lv hu je b jf jg jj jk jn lw jr lx jv ly jz lz ma mb mc dt translated"><strong class="je hv">改进持续集成<br/> </strong>从这一点出发，根据您的需求进行定制。如果你正在开发一个应用程序，那么用Selenium或者它的一种风格来运行端到端测试可能是有意义的。如果这是一个高负荷的网站，增加压力测试的管道。像这样的任何类型的测试都属于集成阶段。</li><li id="c6be" class="lu lv hu je b jf md jj me jn mf jr mg jv mh jz lz ma mb mc dt translated"><strong class="je hv">连续交付</strong> <br/>一旦你正在构建生产化的docker容器，不把它们放在注册表中就太可惜了。有为此付费的解决方案，和自我托管的注册表的。什么最适合你取决于你的情况。我通常只是在Docker Hub上支付私人回购，然后就收工了。</li><li id="9ad8" class="lu lv hu je b jf md jj me jn mf jr mg jv mh jz lz ma mb mc dt translated"><strong class="je hv">持续部署<br/> </strong>这才是神奇真正开始发生的地方。当您在每次提交给master时都充分测试了部署自己的生产优化容器时，这才是真正的禅。尤其是考虑到现代微服务架构。通常，我们会添加新的服务来添加新的功能，而不是一个分支，从而使您更少地错过分支。对于持续部署服务器，我更喜欢蓝海的Jenkins 2.0管道。允许每个产品的工程师定义他们自己的CD管道，Docker堆栈文件允许开发者定义他们的服务如何在生产中运行。CD进程还可能涉及更新代理，如HAProxy或nginx。</li><li id="f272" class="lu lv hu je b jf md jj me jn mf jr mg jv mh jz lz ma mb mc dt translated"><strong class="je hv">试生产<br/> </strong>这就是<em class="ka">指挥者</em>的作用。这些工具包括Docker Swarm、Kubernetes和Mesos。它的工作方式与您现在使用的计算机上的调度程序非常相似，调度您的计算机上运行的进程并分配资源。相反，它们在一个机器集群中调度和保留资源，让您像控制一个机器一样控制它们。</li></ul><blockquote class="mi"><p id="71a0" class="mj mk hu bd ml mm mn mo mp mq mr jz ek translated">有兴趣听听我的DevOps之旅，没有无用的AWS认证？现在就在HackerNoon 上阅读。</p></blockquote><p id="a953" class="pw-post-body-paragraph jc jd hu je b jf ms jh ji jj mt jl jm jn mu jp jq jr mv jt ju jv mw jx jy jz hn dt translated">非常感谢你的阅读！如果你觉得这个帖子有帮助，请击碎那个按钮并分享！</p><p id="554d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请务必关注我，获取更多相关主题的帖子！:)</p><p id="f2c8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt">—</p><p id="febe" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> Changelog <br/> 11/21/2017，晚上9:11</strong><br/>“重构”了引言和结论，以解决评论和问题，并提高清晰度。</p></div></div>    
</body>
</html>