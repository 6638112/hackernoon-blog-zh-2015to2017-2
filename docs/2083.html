<html>
<head>
<title>Everyday Hacks for Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">码头工人的日常生活</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/everyday-hacks-for-docker-37e92188d9e8?source=collection_archive---------3-----------------------#2017-01-05">https://medium.com/hackernoon/everyday-hacks-for-docker-37e92188d9e8?source=collection_archive---------3-----------------------#2017-01-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir is it"><p id="9c5b" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">在这篇文章中，我决定与你分享一些我在使用令人敬畏的Docker技术时经常使用的有用命令和工具。每一个<em class="hu">“黑”都没有特定的顺序或<em class="hu">酷等级</em>。</em>我将简单介绍用例，以及具体的命令或工具如何帮助我的工作。</p></blockquote><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff jt"><img src="../Images/07481a08b3916f8d7e283e7487d78814.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DWNRIWDNB2eUf0rkpDuSWg.png"/></div></div></figure><h2 id="edc3" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">清理</h2><p id="424c" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf kq lf ji jj ku lg jm jn ky lh jq jr js hn dt translated">在与Docker 共事一段时间后，你开始积累开发垃圾:未使用的卷、网络、退出的容器和未使用的映像。</p><p id="bae0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated"><strong class="ix hv"> <em class="iw">一人指挥“统治一切”</em> </strong></p><pre class="ju jv jw jx fq lj lk ll lm aw ln dt"><span id="8ab2" class="kf kg hu lk b fv lo lp l lq lr">$ docker system prune</span></pre><p id="4062" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated"><code class="eh ls lt lu lk b">prune</code>是一个非常有用的命令(也适用于<code class="eh ls lt lu lk b">volume</code>和<code class="eh ls lt lu lk b">network</code>子命令)，但它只适用于<a class="ae li" href="https://blog.docker.com/2017/01/whats-new-in-docker-1-13/" rel="noopener ugc nofollow" target="_blank"> Docker 1.13 </a>。因此，如果您正在使用旧版本的Docker，以下命令可以帮助您替换<code class="eh ls lt lu lk b">prune</code>命令。</p><p id="5d46" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated"><strong class="ix hv"> <em class="iw">清除悬空卷</em> </strong></p><p id="e470" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated"><code class="eh ls lt lu lk b">dangling</code>卷是没有被任何容器使用的卷。要删除它们，组合两个命令:首先，列出<code class="eh ls lt lu lk b">dangling</code>卷的卷id，然后删除它们。</p><pre class="ju jv jw jx fq lj lk ll lm aw ln dt"><span id="f29e" class="kf kg hu lk b fv lo lp l lq lr">$ docker volume rm $(docker volume ls -q -f “dangling=true”)</span></pre><p id="ff5d" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated"><strong class="ix hv"> <em class="iw">移除退出的容器</em> </strong></p><p id="9290" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated">同样的原理在这里也适用。首先列出你要移除的容器(只有id)(用过滤器)然后移除(考虑<code class="eh ls lt lu lk b">rm -f</code>强制移除)。</p><pre class="ju jv jw jx fq lj lk ll lm aw ln dt"><span id="e120" class="kf kg hu lk b fv lo lp l lq lr">$ docker rm $(docker ps -q -f “status=exited”)</span></pre><p id="d8a6" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated"><strong class="ix hv"> <em class="iw">去除悬空图像</em> </strong></p><p id="95f1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated"><code class="eh ls lt lu lk b">dangling</code>图像是未标记的图像，是图像树的叶子(不是中间层)。</p><pre class="ju jv jw jx fq lj lk ll lm aw ln dt"><span id="ac56" class="kf kg hu lk b fv lo lp l lq lr">docker rmi $(docker images -q -f “dangling=true”)</span></pre><p id="be6e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated"><strong class="ix hv"> <em class="iw">自动移除交互式容器</em> </strong></p><p id="398c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated">当你运行一个新的交互容器，并希望在它退出后避免输入<code class="eh ls lt lu lk b">rm</code>命令时，使用<code class="eh ls lt lu lk b">--rm</code>选项。然后当你退出已创建的容器时，它将被自动销毁。</p><pre class="ju jv jw jx fq lj lk ll lm aw ln dt"><span id="56b9" class="kf kg hu lk b fv lo lp l lq lr">$ docker run -it --rm alpine sh</span></pre><h2 id="5bc2" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">检查码头资源</h2><p id="d0d4" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf kq lf ji jj ku lg jm jn ky lh jq jr js hn dt translated"><a class="ae li" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank"> jq </a> — <code class="eh ls lt lu lk b">jq</code>是一个轻量级且灵活的命令行<code class="eh ls lt lu lk b">JSON</code>处理器。对于JSON数据来说就像<code class="eh ls lt lu lk b">sed</code>。您可以使用它来切片和过滤，以及映射和转换结构化数据，就像<code class="eh ls lt lu lk b">sed</code>、<code class="eh ls lt lu lk b">awk</code>、<code class="eh ls lt lu lk b">grep</code>和朋友让您玩文本一样轻松。</p><p id="61c7" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated"><code class="eh ls lt lu lk b"><a class="ae li" href="https://docs.docker.com/engine/reference/commandline/info/" rel="noopener ugc nofollow" target="_blank">docker info</a></code>和<code class="eh ls lt lu lk b"><a class="ae li" href="https://docs.docker.com/engine/reference/commandline/inspect/" rel="noopener ugc nofollow" target="_blank">docker inspect</a></code>命令可以产生<code class="eh ls lt lu lk b">JSON</code>格式的输出。用<code class="eh ls lt lu lk b">jq</code>处理器组合这些命令。</p><p id="69b2" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated"><strong class="ix hv"> <em class="iw">漂亮的JSON和jq处理</em> </strong></p><pre class="ju jv jw jx fq lj lk ll lm aw ln dt"><span id="fd35" class="kf kg hu lk b fv lo lp l lq lr"># show whole Docker info <br/>$ docker info --format “{{json .}}” | jq . </span><span id="cbb5" class="kf kg hu lk b fv lv lp l lq lr"># show Plugins only <br/>$ docker info --format “{{json .Plugins}}” | jq . </span><span id="bdf8" class="kf kg hu lk b fv lv lp l lq lr"># list IP addresses for all containers connected to ‘bridge’ network $ docker network inspect bridge -f ‘{{json .Containers}}’ \<br/>    | jq ‘.[] \<br/>    | {cont: .Name, ip: .IPv4Address}’</span></pre><h2 id="7238" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">观察容器生命周期</h2><p id="019d" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf kq lf ji jj ku lg jm jn ky lh jq jr js hn dt translated">有时，当您运行某些docker命令或尝试不同的重启策略时，您希望看到容器被激活和退出。结合了<code class="eh ls lt lu lk b"><a class="ae li" href="https://docs.docker.com/engine/reference/commandline/ps/" rel="noopener ugc nofollow" target="_blank">docker ps</a></code>的<code class="eh ls lt lu lk b"><a class="ae li" href="http://man7.org/linux/man-pages/man1/watch.1.html" rel="noopener ugc nofollow" target="_blank">watch</a></code>命令在这里会非常有用。我发现<code class="eh ls lt lu lk b">docker stats</code>命令(即使有<code class="eh ls lt lu lk b">--format</code>选项)对此没有用，因为它不允许您看到与<code class="eh ls lt lu lk b">docker ps</code>命令相同的信息。</p><p id="7d54" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated"><strong class="ix hv"> <em class="iw">显示活动集装箱的“ID图像状态”表，每2秒刷新一次</em> </strong></p><pre class="ju jv jw jx fq lj lk ll lm aw ln dt"><span id="223b" class="kf kg hu lk b fv lo lp l lq lr">$ watch -n 2 ‘docker ps --format \<br/>    “table {{.ID}}\t {{.Image}}\t {{.Status}}”’</span></pre><h2 id="1d20" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">进入主机/容器名称空间</h2><p id="e7b8" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf kq lf ji jj ku lg jm jn ky lh jq jr js hn dt translated">有时候你想连接到Docker主机。<code class="eh ls lt lu lk b">ssh</code>命令是默认选项，但由于安全设置、防火墙规则或其他未记录的问题，该选项可能不可用(只需尝试谷歌“how to <code class="eh ls lt lu lk b">ssh</code> into Docker for Mac VM”以了解我的意思)。</p><p id="7d4e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated">jérme Petazzoni开发的<code class="eh ls lt lu lk b"><a class="ae li" href="https://github.com/jpetazzo/nsenter" rel="noopener ugc nofollow" target="_blank">nsenter</a></code>是一个小型且非常有用的<a class="ae li" href="https://hackernoon.com/tagged/tool" rel="noopener ugc nofollow" target="_blank">工具</a>用于这个用例。<code class="eh ls lt lu lk b">nsenter</code>命令允许你<code class="eh ls lt lu lk b">enter</code>进入<code class="eh ls lt lu lk b">n</code> ame <code class="eh ls lt lu lk b">s</code>步伐。我喜欢用极简(<code class="eh ls lt lu lk b">580 kB</code>)<a class="ae li" href="https://hub.docker.com/r/walkerlee/nsenter/" rel="noopener ugc nofollow" target="_blank">walker lee/n center</a>Docker形象。</p><p id="38aa" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated"><strong class="ix hv"> <em class="iw">进入Docker主机</em> </strong></p><p id="a170" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated">您可以使用<code class="eh ls lt lu lk b">--pid=host</code>进入Docker主机名称空间。</p><pre class="ju jv jw jx fq lj lk ll lm aw ln dt"><span id="3c74" class="kf kg hu lk b fv lo lp l lq lr"># get a shell into Docker host <br/>$ docker run --rm -it --privileged --pid=host \<br/>     walkerlee/nsenter -t 1 -m -u -i -n sh</span></pre><p id="bb71" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated"><strong class="ix hv"> <em class="iw">进入任意容器</em> </strong></p><p id="5b60" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated">也可以进入任何带有<code class="eh ls lt lu lk b">nsenter</code>和<code class="eh ls lt lu lk b">--pid=container:[id OR name]</code>的容器。但是在大多数情况下，最好使用标准的<code class="eh ls lt lu lk b"><a class="ae li" href="https://docs.docker.com/engine/reference/commandline/exec/" rel="noopener ugc nofollow" target="_blank">docker exec</a></code>命令。主要区别在于<code class="eh ls lt lu lk b">nsenter</code>不进入<em class="iw"> cgroups </em>，因此避开了资源限制(这对调试很有用)。</p><pre class="ju jv jw jx fq lj lk ll lm aw ln dt"><span id="5258" class="kf kg hu lk b fv lo lp l lq lr"># get a shell into ‘redis’ container namespace <br/>$ docker run --rm -it --privileged --pid=container:redis \<br/>     walkerlee/nsenter -t 1 -m -u -i -n sh</span></pre><h2 id="e527" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">Heredoc码头集装箱</h2><p id="cd63" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf kq lf ji jj ku lg jm jn ky lh jq jr js hn dt translated">有时你想得到一些工具作为Docker图像，但是你不想搜索一个合适的图像或者创建一个新的<code class="eh ls lt lu lk b">Dockerfile</code>(例如，不需要保留它以备将来使用)。有时候，在一个文件中存储Docker图像定义看起来有点矫枉过正——你需要决定如何编辑、存储和共享这个Docker文件。有时最好有一个单行命令，您可以复制、共享、嵌入到shell脚本中或创建特殊命令<code class="eh ls lt lu lk b">alias.</code> <br/>因此，当您想要用一个命令创建一个新的专用容器时，请尝试一种<a class="ae li" href="http://www.tldp.org/LDP/abs/html/here-docs.html" rel="noopener ugc nofollow" target="_blank"> Heredoc </a>方法。</p><p id="6929" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated"><strong class="ix hv"> <em class="iw">使用“htop”工具</em> </strong>创建基于Alpine的容器</p><pre class="ju jv jw jx fq lj lk ll lm aw ln dt"><span id="9902" class="kf kg hu lk b fv lo lp l lq lr">$ docker build -t htop — &lt;&lt; EOF <br/>FROM alpine <br/>RUN apk --no-cache add htop <br/>EOF</span></pre><h2 id="303b" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">Docker命令完成</h2><p id="a02c" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf kq lf ji jj ku lg jm jn ky lh jq jr js hn dt translated">Docker CLI语法非常丰富，并且在不断增加:添加新命令和新选项。很难记住每一个可能的命令和选项，所以为终端提供一个好的命令完成是<strong class="ix hv">必须具备的</strong>。</p><p id="da81" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated">命令完成是一种终端插件，让你通过点击<em class="iw">标签</em>键自动完成或自动建议下一步输入什么。Docker命令完成功能适用于命令和选项。Docker团队为<code class="eh ls lt lu lk b">docker</code>、<code class="eh ls lt lu lk b">docker-machine</code>和<code class="eh ls lt lu lk b">docker-compose</code>命令、为<code class="eh ls lt lu lk b">Bash</code>和<code class="eh ls lt lu lk b">Zsh</code>外壳准备了命令完成。</p><p id="072f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated">如果你正在使用Mac和<a class="ae li" href="http://brew.sh/" rel="noopener ugc nofollow" target="_blank">家酿</a>，那么安装Docker命令完成是非常简单的。</p><pre class="ju jv jw jx fq lj lk ll lm aw ln dt"><span id="0ec2" class="kf kg hu lk b fv lo lp l lq lr"># Tap homebrew/completion to gain access to these <br/>$ brew tap homebrew/completions </span><span id="2845" class="kf kg hu lk b fv lv lp l lq lr"># Install completions for docker suite <br/>$ brew install docker-completion <br/>$ brew install docker-compose-completion <br/>$ brew install docker-machine-completion</span></pre><p id="a9d1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated">如果您没有使用Mac，请阅读Docker官方文档以获得安装说明:<a class="ae li" href="https://github.com/docker/docker/tree/master/contrib/completion" rel="noopener ugc nofollow" target="_blank"> docker引擎</a>、<a class="ae li" href="https://docs.docker.com/compose/completion/" rel="noopener ugc nofollow" target="_blank"> docker-compose </a>和<a class="ae li" href="https://docs.docker.com/machine/completion/" rel="noopener ugc nofollow" target="_blank"> docker-machine </a>。</p><h2 id="2fca" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">自动启动容器</h2><p id="f60e" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf kq lf ji jj ku lg jm jn ky lh jq jr js hn dt translated">当在Docker容器中运行一个流程时，失败可能是由多种原因造成的。在某些情况下，您可以通过重新运行失败的容器来修复它。如果您使用的是Docker编排引擎，如Swarm或Kubernetes，失败的服务将自动重启。<br/>如果没有，那么你可能想要根据容器主进程的<em class="iw">退出代码</em>重启容器，或者总是重启(不管<em class="iw">退出代码</em>)。Docker 1.12引入了<code class="eh ls lt lu lk b">docker run</code>命令:<a class="ae li" href="https://docs.docker.com/engine/reference/run/#restart-policies-restart#restart-policies---restart" rel="noopener ugc nofollow" target="_blank">重启</a>用于这个用例。</p><p id="636b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated"><strong class="ix hv"> <em class="iw">重启总</em> </strong></p><p id="ee4a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated">使用重启策略<strong class="ix hv"> always </strong>重启<code class="eh ls lt lu lk b">redis</code>容器，这样如果容器退出，Docker将重启它。</p><pre class="ju jv jw jx fq lj lk ll lm aw ln dt"><span id="965f" class="kf kg hu lk b fv lo lp l lq lr">$ docker run --restart=always redis</span></pre><p id="6554" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated"><strong class="ix hv"> <em class="iw">故障时重启容器</em> </strong></p><p id="d16b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated">使用重启策略<strong class="ix hv"> on-failure </strong>和最大重启计数<code class="eh ls lt lu lk b">10</code>重启<code class="eh ls lt lu lk b">redis</code>容器。</p><pre class="ju jv jw jx fq lj lk ll lm aw ln dt"><span id="388a" class="kf kg hu lk b fv lo lp l lq lr">$ docker run --restart=on-failure:10 redis</span></pre><h2 id="60b1" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">网络诡计</h2><p id="6e1f" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf kq lf ji jj ku lg jm jn ky lh jq jr js hn dt translated">有时，您可能希望创建一个新的容器，并将其连接到现有的网络堆栈。这可能是Docker主机网络或另一个容器的网络。这在调试和审计网络问题时很有帮助。<br/><code class="eh ls lt lu lk b">docker run --network/net</code>选项允许你这样做。</p><p id="6227" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated"><strong class="ix hv"> <em class="iw">使用Docker主机网络栈</em> </strong></p><pre class="ju jv jw jx fq lj lk ll lm aw ln dt"><span id="3c75" class="kf kg hu lk b fv lo lp l lq lr">$ docker run --net=host …</span></pre><p id="d790" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated">新容器将连接到与Docker主机相同的网络接口。</p><p id="a53a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated"><strong class="ix hv"> <em class="iw">使用另一个容器的网络堆栈</em> </strong></p><pre class="ju jv jw jx fq lj lk ll lm aw ln dt"><span id="fd11" class="kf kg hu lk b fv lo lp l lq lr">$ docker run --net=container:&lt;name|id&gt; …</span></pre><p id="7dfb" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated">新容器将连接到与另一个容器相同的网络接口。目标容器可以通过<code class="eh ls lt lu lk b">id</code>或<code class="eh ls lt lu lk b">name</code>指定。</p><p id="1a97" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated"><strong class="ix hv"> <em class="iw">可附着叠加网络</em> </strong></p><p id="43e9" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated">使用在<strong class="ix hv">群模式</strong>下运行的Docker引擎，你可以在一个管理节点上创建一个多主机<code class="eh ls lt lu lk b">overlay</code>网络。当您创建一个新的<em class="iw">群服务</em>时，您可以将它附加到之前创建的<code class="eh ls lt lu lk b">overlay</code>网络。</p><p id="e543" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated">有时你需要附加一个新的Docker容器(装满不同的网络工具)，到现有的<code class="eh ls lt lu lk b">overlay</code>网络上，以便检查网络配置或调试网络问题。为此，您可以使用<code class="eh ls lt lu lk b">docker run</code>命令，这样就不需要创建一个全新的“调试服务”。</p><p id="42fa" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated">Docker 1.13为<code class="eh ls lt lu lk b">docker network create</code>命令带来了一个新选项:<code class="eh ls lt lu lk b">attachable</code>。<code class="eh ls lt lu lk b">attachable</code>选项允许手动连接容器。</p><pre class="ju jv jw jx fq lj lk ll lm aw ln dt"><span id="5255" class="kf kg hu lk b fv lo lp l lq lr"># create an attachable overlay network <br/>$ docker network create --driver overlay --attachable mynet </span><span id="a5ba" class="kf kg hu lk b fv lv lp l lq lr"># create net-tools container and attach it to mynet overlay network $ docker run -it --rm --net=mynet net-tools sh</span></pre></div><div class="ab cl lw lx hc ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hn ho hp hq hr"><p id="dba6" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated">我希望这篇文章对你有用。如果你自己有更多的小技巧，请在评论框里留下！</p></div><div class="ab cl lw lx hc ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hn ho hp hq hr"><p id="56a1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kq jh ji jj ku jl jm jn ky jp jq jr js hn dt translated"><em class="iw">原载于2017年1月5日</em><a class="ae li" href="https://codefresh.io/blog/everyday-hacks-docker/" rel="noopener ugc nofollow" target="_blank"><em class="iw">code fresh . io</em></a><em class="iw">。</em></p><div class="ju jv jw jx fq ab cb"><figure class="md jy me mf mg mh mi paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="md jy me mf mg mh mi paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="md jy me mf mg mh mi paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ir is it"><p id="f922" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><a class="ae li" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae li" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae li" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae li" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae li" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae li" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff mj"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="mk ml l"/></div></figure></div></div>    
</body>
</html>