<html>
<head>
<title>Applying the pub-sub and push-pull messaging patterns with AWS Lambda</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过AWS Lambda应用发布-订阅和推拉消息传递模式</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/applying-the-pub-sub-and-push-pull-messaging-patterns-with-aws-lambda-73d5ee346faa?source=collection_archive---------2-----------------------#2017-08-09">https://medium.com/hackernoon/applying-the-pub-sub-and-push-pull-messaging-patterns-with-aws-lambda-73d5ee346faa?source=collection_archive---------2-----------------------#2017-08-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="65d5" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">AWS为实现消息传递模式提供了丰富的选项，比如pub-sub和push-pull with Lambda，让我们比较一下这些选项。</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/06102d591f51c54b1f238583a40a11ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NnGOc6JXb5A1adnn-kHFTQ.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">This image is completely unrelated but I just thought it’s a cool pattern.</figcaption></figure><h1 id="f63a" class="jz ka hu bd kb kc kd ke kf kg kh ki kj ja kk jb kl jd km je kn jg ko jh kp kq dt translated">发布订阅</h1><p id="f3f7" class="pw-post-body-paragraph kr ks hu kt b ku kv iv kw kx ky iy kz la lb lc ld le lf lg lh li lj lk ll lm hn dt translated"><code class="eh ln lo lp lq b">Publish-Subscribe</code>(通常简称为pub-sub)是一种消息传递模式，发布者和订阅者通过中介代理(ZeroMQ、RabbitMQ、SNS等)分离。).</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff lr"><img src="../Images/162cb99fd99ccd26e5fd2d7bbd4c4279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jR_zFJKORmMdt68hESKcGA.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">From Wikipedia, <a class="ae ls" href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern</a></figcaption></figure><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff lt"><img src="../Images/781bc94d06789b95fe0b9f86590e77d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*40V5hr5x9G1T4eRxnIW-SA.png"/></div></div></figure><h2 id="e160" class="lu ka hu bd kb lv lw lx kf ly lz ma kj la mb mc kl le md me kn li mf mg kp mh dt translated">社交网络+拉姆达</h2><p id="2357" class="pw-post-body-paragraph kr ks hu kt b ku kv iv kw kx ky iy kz la lb lc ld le lf lg lh li lj lk ll lm hn dt translated">在AWS生态系统中，代理角色的明显候选人是SNS。</p><p id="0152" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">如果为函数指定了DLQ，SNS将在将消息发送到死信队列(DLQ)之前，尝试3次让函数处理消息。然而，根据OpsGenie的人员进行的<a class="ae ls" href="https://engineering.opsgenie.com/aws-lambda-performance-series-part-2-an-analysis-on-async-lambda-fail-retry-behaviour-and-dead-b84620af406" rel="noopener ugc nofollow" target="_blank">分析</a>，重试的次数可能多达6次。</p><div class="mn mo fm fo mp mq"><a href="https://engineering.opsgenie.com/aws-lambda-performance-series-part-2-an-analysis-on-async-lambda-fail-retry-behaviour-and-dead-b84620af406" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab ej"><div class="ms ab mt cl cj mu"><h2 class="bd hv fv z el mv eo ep mw er et ht dt translated">AWS Lambda性能系列—第2部分异步Lambda失败重试行为和死锁的分析…</h2><div class="mx l"><h3 class="bd b fv z el mv eo ep mw er et ek translated">在OpsGenie，我们渴望体验使用AWS Lambda技术的无服务器架构。因为概念和…</h3></div><div class="my l"><p class="bd b gc z el mv eo ep mw er et ek translated">engineering.opsgenie.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne jt mq"/></div></div></a></div><p id="df24" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">另一件要考虑的事情是这个设置提供的并行度。对于每条消息，SNS将创建一个新的函数调用。因此，如果你向社交网络发布100条消息，那么你可以同时执行100个订阅的Lambda函数。</p><p id="5042" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated"><strong class="kt hv">如果你在优化吞吐量的话，这很好</strong>。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nf"><img src="../Images/c0192010c1c5af3f9ab0632ce48c2640.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uv_URbM72EIPT8GedQ2omQ.png"/></div></div></figure><p id="0f14" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">然而，我们经常受到下游依赖项所能处理的最大吞吐量的限制，比如数据库、S3、内部/外部服务等等。</p><p id="424f" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">如果吞吐量的突发很短，那么重试很有可能是足够的(重试之间也有随机的指数后退)，并且您不会错过任何消息。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ng"><img src="../Images/6fd34c3af884783154aac4be248c024c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*64OQ0kOT3aXb49PYau-G4A.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Erred messages are retried 2 times with exponential back off. If the burst is short-lived then the retry is likely to succeed, resulting in no message loss.</figcaption></figure><p id="ca5b" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">如果吞吐量的激增持续了很长一段时间，那么您可以用尽最大重试次数。在这一点上，您将不得不依靠DLQ和可能的人工干预来恢复第一次无法处理的消息。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nh"><img src="../Images/01ebc90dbb08fbc2787821cde7c5de13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kj0DIPYdvfPWm2ae0Z_Hbw.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Erred messages are retried 2 times with exponential back off. But the burst in message rate overlaps with the retries, further exasperating the problem and eventually the max no. of retries are exhausted and erred messages have to be delivered to the DLQ instead (if one is specified).</figcaption></figure><p id="d54e" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">类似地，如果下游依赖关系经历了中断，那么在中断期间接收和重试的所有消息必定会失败。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ni"><img src="../Images/6a518924b20e8f393402f81a91ce20c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HmPnQJTwX6SJ8nwCpkXH4Q.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Any message received or retried during the downstream message will fail and be sent to the DLQ.</figcaption></figure><p id="a1e5" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">您还可以在一个区域中的并发执行数量上遇到<a class="ae ls" href="http://docs.aws.amazon.com/lambda/latest/dg/limits.html" rel="noopener ugc nofollow" target="_blank"> Lambda限制</a>。由于这是一个帐户范围的限制，它还会影响依赖AWS Lambda的其他系统——API、事件处理、cron作业等。</p><div class="mn mo fm fo mp mq"><a href="http://docs.aws.amazon.com/lambda/latest/dg/limits.html" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab ej"><div class="ms ab mt cl cj mu"><h2 class="bd hv fv z el mv eo ep mw er et ht dt translated">AWSλ限值-AWSλ</h2><div class="mx l"><h3 class="bd b fv z el mv eo ep mw er et ek translated">描述AWS Lambda安全节流和限制。</h3></div><div class="my l"><p class="bd b gc z el mv eo ep mw er et ek translated">docs.aws.amazon.com</p></div></div></div></a></div><h2 id="9714" class="lu ka hu bd kb lv lw lx kf ly lz ma kj la mb mc kl le md me kn li mf mg kp mh dt translated">Kinesis流+λ</h2><p id="1794" class="pw-post-body-paragraph kr ks hu kt b ku kv iv kw kx ky iy kz la lb lc ld le lf lg lh li lj lk ll lm hn dt translated">Kinesis流在许多方面不同于SNS:</p><ul class=""><li id="cdc4" class="nj nk hu kt b ku mi kx mj la nl le nm li nn lm no np nq nr dt translated">Lambda每秒钟向Kinesis查询记录多达5次，而SNS会向Lambda推送消息</li><li id="98d4" class="nj nk hu kt b ku ns kx nt la nu le nv li nw lm no np nq nr dt translated">批量接收记录(达到您指定的最大数量)，SNS通过一条消息调用您的函数</li><li id="7032" class="nj nk hu kt b ku ns kx nt la nu le nv li nw lm no np nq nr dt translated">如果您的函数返回一个错误或超时，那么您将继续接收同一批记录，直到您成功地处理它们或者数据在流中不再可用</li><li id="a35e" class="nj nk hu kt b ku ns kx nt la nu le nv li nw lm no np nq nr dt translated">并行度由流中碎片的数量决定，因为每个碎片有一个专用调用</li><li id="96d9" class="nj nk hu kt b ku ns kx nt la nu le nv li nw lm no np nq nr dt translated">Kinesis流根据推送到流的记录数量收费；碎片时间，以及是否启用延长保留期</li></ul><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nx"><img src="../Images/bd61dd706e44e4b13cc556a1896ae370.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7S1C3LCdbLwjK7XeFnAYJA.png"/></div></div></figure><p id="eba5" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">SNS容易遭受暂时性问题——流量突发、下游中断等。另一方面，Kinesis更好地处理了这些问题。</p><ul class=""><li id="6f4a" class="nj nk hu kt b ku mi kx mj la nl le nm li nn lm no np nq nr dt translated">并行度受到碎片数量的限制，碎片数量可用于缓冲消息速率中的突发</li></ul><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ny"><img src="../Images/1705246c4f916bf435a3d14ae041aaaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R83WixCf6irfoXZjnzvK1A.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Bursts in message rate is amortised, as the max throughput is determined by no. of shards * max batch size * 5 reads per second. Which gives you two levers to adjust the max throughput with.</figcaption></figure><ul class=""><li id="0f6d" class="nj nk hu kt b ku mi kx mj la nl le nm li nn lm no np nq nr dt translated">记录将被重试，直到成功，除非中断持续的时间超过您在流上的保留策略(默认为24小时)，否则您最终将能够处理记录</li></ul><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nz"><img src="../Images/9b48c8e30a4c3624718763bbe9d39a59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s63Maqw9tJC9vqM7JbBBSw.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">The impact of a downstream outage is absorbed by the retry-until-success invocation policy.</figcaption></figure><p id="25f7" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">但是Kinesis Streams也不是没有自己的问题。事实上，根据我在Lambda中使用Kinesis流的经验，我发现了许多我们需要理解的警告，以便有效地使用它们。</p><p id="4584" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">你可以在这里阅读这些警告。</p><div class="mn mo fm fo mp mq"><a href="https://read.acloud.guru/aws-lambda-3-pro-tips-for-working-with-kinesis-streams-8f6182a03113" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab ej"><div class="ms ab mt cl cj mu"><h2 class="bd hv fv z el mv eo ep mw er et ht dt translated">将AWS Lambda与Kinesis Streams结合使用的3个专业技巧</h2><div class="mx l"><h3 class="bd b fv z el mv eo ep mw er et ek translated">TL；DR:从我们的陷阱中吸取的教训包括考虑部分故障、使用死信队列和避免…</h3></div><div class="my l"><p class="bd b gc z el mv eo ep mw er et ek translated">read.acloud.guru</p></div></div><div class="mz l"><div class="oa l nb nc nd mz ne jt mq"/></div></div></a></div><p id="845a" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">还有几个操作注意事项需要考虑:</p><ul class=""><li id="8fe8" class="nj nk hu kt b ku mi kx mj la nl le nm li nn lm no np nq nr dt translated">因为Kinesis Streams(部分)是根据分片小时数收费的，所以一个休眠流的基线成本是每小时每分片0.015美元(每月每分片约11美元)</li><li id="b61e" class="nj nk hu kt b ku ns kx nt la nu le nv li nw lm no np nq nr dt translated">Kinesis流也没有内置的自动扩展功能，因此根据利用率对其进行扩展也会产生额外的管理开销</li></ul><p id="da99" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">你可以自己构建自动伸缩能力，我在之前的(失败的)启动中已经这么做了。虽然我不能分享代码，但你可以在这里<a class="ae ls" href="https://read.acloud.guru/auto-scaling-kinesis-streams-with-aws-lambda-299f9a0512da" rel="noopener ugc nofollow" target="_blank">阅读我的方法和设计思路</a>。</p><div class="mn mo fm fo mp mq"><a href="https://read.acloud.guru/auto-scaling-kinesis-streams-with-aws-lambda-299f9a0512da" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab ej"><div class="ms ab mt cl cj mu"><h2 class="bd hv fv z el mv eo ep mw er et ht dt translated">使用AWS Lambda自动缩放Kinesis流</h2><div class="mx l"><h3 class="bd b fv z el mv eo ep mw er et ek translated">使用Lambda函数创建自动缩放Kinesis流的经济高效的解决方案的方法</h3></div><div class="my l"><p class="bd b gc z el mv eo ep mw er et ek translated">read.acloud.guru</p></div></div><div class="mz l"><div class="ob l nb nc nd mz ne jt mq"/></div></div></a></div><p id="425e" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">有趣的是，Kinesis Streams并不是AWS上唯一可用的流选项，还有DynamoDB流。</p><h2 id="47ec" class="lu ka hu bd kb lv lw lx kf ly lz ma kj la mb mc kl le md me kn li mf mg kp mh dt translated">DynamoDB流+ Lambda</h2><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff oc"><img src="../Images/bf5ecffc61dd98cf12ddd68781eabffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Wp0NTekhku5B6HdwpN2UQ.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">DynamoDB Streams can be used as a like-for-like replacement for Kinesis Streams.</figcaption></figure><p id="6f2e" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">总的来说，DynamoDB Streams + Lambda的工作方式与Kinesis Streams + Lambda相同。在操作上，它确实有一些有趣的变化:</p><ul class=""><li id="50ca" class="nj nk hu kt b ku mi kx mj la nl le nm li nn lm no np nq nr dt translated">DynamoDB流自动缩放碎片的数量</li><li id="2576" class="nj nk hu kt b ku ns kx nt la nu le nv li nw lm no np nq nr dt translated">如果您使用AWS Lambda处理DynamoDB流，那么您不需要为DynamoDB流的读取付费(但是您仍然需要为DynamoDB表本身的读写容量单元付费)</li></ul><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff od"><img src="../Images/5fc075b8635ed61a0d87b9b8b41e0f92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DheWol53OQ9XDThSAlSIOw.png"/></div></div></figure><ul class=""><li id="d4a8" class="nj nk hu kt b ku mi kx mj la nl le nm li nn lm no np nq nr dt translated">Kinesis Streams提供了将数据保留期延长至7天的选项；DynamoDB Streams不提供这样的选项</li></ul><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff oe"><img src="../Images/386ccb2781192cd20386aa868bb88b59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IWU8I7_j6aYa_r56ftum9w.png"/></div></div></figure><p id="f784" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">DynamoDB流自动缩放碎片数量的事实可能是一把双刃剑。一方面，它消除了你管理和扩展流的需要(或者想出自制的<a class="ae ls" href="https://read.acloud.guru/auto-scaling-kinesis-streams-with-aws-lambda-299f9a0512da" rel="noopener ugc nofollow" target="_blank">自动扩展解决方案</a>)；另一方面，它还会削弱您传递给下游系统的负载峰值的缓冲能力。</p><p id="52a2" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">没有办法限制DynamoDB流可以扩展的碎片数量——这是您在实现自己的自动扩展解决方案时肯定会考虑的。</p><h2 id="c9d2" class="lu ka hu bd kb lv lw lx kf ly lz ma kj la mb mc kl le md me kn li mf mg kp mh dt translated">我应该使用Kinesis还是DynamoDB流？</h2><p id="dd54" class="pw-post-body-paragraph kr ks hu kt b ku kv iv kw kx ky iy kz la lb lc ld le lf lg lh li lj lk ll lm hn dt translated">我觉得最中肯的问题是<code class="eh ln lo lp lq b">“what is your source of truth?”</code></p><p id="6b1d" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">在DynamoDB中写入的一行是否符合您的系统状态？这在大多数围绕数据库构建的N层系统中都是如此，不管它是RDBMS还是NoSQL。</p><p id="8ba4" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">在以事件为源的系统中，状态被建模为一系列事件(而不是快照),事实的来源很可能是Kinesis流——一旦事件被写入该流，它就被认为是系统状态的标准。</p><p id="907d" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">此外，还有其他关于成本、自动扩展等方面的考虑。</p><p id="ff6a" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">从开发的角度来看，DynamoDB Streams也有一些限制和缺点:</p><ul class=""><li id="2458" class="nj nk hu kt b ku mi kx mj la nl le nm li nn lm no np nq nr dt translated">每个流仅限于一个表中的事件</li><li id="0e2f" class="nj nk hu kt b ku ns kx nt la nu le nv li nw lm no np nq nr dt translated">记录描述的是DynamoDB事件，而不是来自您的领域的事件，当我处理这些事件时，我总觉得这产生了一种不和谐的感觉</li></ul><h2 id="bf71" class="lu ka hu bd kb lv lw lx kf ly lz ma kj la mb mc kl le md me kn li mf mg kp mh dt translated">你的经纪人选择的成本影响</h2><p id="215d" class="pw-post-body-paragraph kr ks hu kt b ku kv iv kw kx ky iy kz la lb lc ld le lf lg lh li lj lk ll lm hn dt translated">排除用于处理消息的Lambda调用的成本，下面是使用SNS、Kinesis流和DynamoDB流作为代理的一些成本预测。我假设吞吐量是一致的，每条消息的大小是1KB。</p><p id="11cc" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated"><strong class="kt hv">1消息/秒的月费用</strong></p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff of"><img src="../Images/2555c56b535a8fba0f88652b9ec4b2a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-NWkSdl8i_lqbVyaq76RKA.png"/></div></div></figure><p id="42ff" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated"><strong class="kt hv">每月1000条消息/秒的费用</strong></p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff og"><img src="../Images/c0fad10a2f663763b0ca35dcc9105010.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9BYDcg7czGF6N_fPt2awsg.png"/></div></div></figure><p id="21df" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated"><strong class="kt hv">不应轻信这些预测。</strong>首先，关于完全一致的吞吐量和消息大小的假设是不现实的，即使没有达到限制，您也需要一些Kinesis &amp; DynamoDB流的扩展空间。</p><p id="b702" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">也就是说，这些预测告诉我的是:</p><ol class=""><li id="bb68" class="nj nk hu kt b ku mi kx mj la nl le nm li nn lm oh np nq nr dt translated">你可以从每个碎片中获得很多东西</li><li id="b273" class="nj nk hu kt b ku ns kx nt la nu le nv li nw lm oh np nq nr dt translated">虽然使用Kinesis流有一个基线成本，但与SNS和DynamoDB流相比，成本随着规模的增长要慢得多，因为每百万次请求的成本要低得多</li></ol><h2 id="42be" class="lu ka hu bd kb lv lw lx kf ly lz ma kj la mb mc kl le md me kn li mf mg kp mh dt translated">堆积起来</h2><p id="cd81" class="pw-post-body-paragraph kr ks hu kt b ku kv iv kw kx ky iy kz la lb lc ld le lf lg lh li lj lk ll lm hn dt translated">虽然SNS、Kinesis和DynamoDB流是代理的基本选择，但是Lambda函数本身也可以充当代理，并将事件传播到其他服务。</p><p id="f56c" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">这是awslabs的<a class="ae ls" href="https://github.com/awslabs/aws-lambda-fanout" rel="noopener ugc nofollow" target="_blank"> aws-lambda-fanout </a>项目使用的方法。它允许您将事件从Kinesis和DynamoDB流传播到其他服务，这些服务不能直接订阅3个基本的代理选择，因为帐户/区域限制，或者它们不被支持。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff oi"><img src="../Images/258ab2daf1acc49564b40f5407a846b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*8g-kpb0jXwcyW2YHwgqFeg.png"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">The aws-lambda-fanout project from awslabs propagates events from Kinesis and DynamoDB Streams to other services across multiple accounts and regions.</figcaption></figure><div class="mn mo fm fo mp mq"><a href="https://github.com/awslabs/aws-lambda-fanout" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab ej"><div class="ms ab mt cl cj mu"><h2 class="bd hv fv z el mv eo ep mw er et ht dt translated">aw slab/AWS-lambda-扇出</h2><div class="mx l"><h3 class="bd b fv z el mv eo ep mw er et ek translated">AWS-Lambda-fanout——一个样本AWS Lambda函数，它接受来自Amazon Kinesis流的消息，并传输…</h3></div><div class="my l"><p class="bd b gc z el mv eo ep mw er et ek translated">github.com</p></div></div><div class="mz l"><div class="oj l nb nc nd mz ne jt mq"/></div></div></a></div><p id="f265" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">虽然这是一个很好的想法，并且肯定满足了一些特定的需求，但是值得记住它引入的额外复杂性——处理部分故障、处理下游中断、错误配置等。</p><h1 id="f273" class="jz ka hu bd kb kc kd ke kf kg kh ki kj ja kk jb kl jd km je kn jg ko jh kp kq dt translated">推挽式，也称为扇出/扇入</h1><p id="c0b5" class="pw-post-body-paragraph kr ks hu kt b ku kv iv kw kx ky iy kz la lb lc ld le lf lg lh li lj lk ll lm hn dt translated"><code class="eh ln lo lp lq b">push-pull</code>消息传递模式通常被称为扇出/扇入。</p><p id="4c21" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">这实际上是两种不同的模式协同工作。<strong class="kt hv">扇出</strong>通常单独使用，消息以循环的方式传递给一群工人，每条消息只传递给一个工人。</p><p id="874b" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">这至少在两个不同方面是有用的:</p><ol class=""><li id="1a7d" class="nj nk hu kt b ku mi kx mj la nl le nm li nn lm oh np nq nr dt translated">让一群工作人员来执行实际工作可以实现并行处理，并提高吞吐量</li><li id="5044" class="nj nk hu kt b ku ns kx nt la nu le nv li nw lm oh np nq nr dt translated">如果每条消息代表一个昂贵的任务，而这个任务可以被分解成可以并行执行的更小的子任务</li></ol><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ok"><img src="../Images/b1a2071ac82ecde8234f8df2f3158340.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J4zldPc_Es3BGK31zu3y8A.png"/></div></div></figure><p id="bf12" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">在第二种情况下，原始任务(比如说一个批处理任务)被<strong class="kt hv">划分为许多子任务，您将需要<strong class="kt hv">扇入</strong>来收集单个工作人员的结果并将它们聚集在一起。</strong></p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff oc"><img src="../Images/767e0ffb80031069ecfbb60dd13ff31c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nfhsc-Zj1xJ-UEIlIYasgQ.png"/></div></div></figure><h2 id="4520" class="lu ka hu bd kb lv lw lx kf ly lz ma kj la mb mc kl le md me kn li mf mg kp mh dt translated">使用SNS的扇出</h2><p id="9779" class="pw-post-body-paragraph kr ks hu kt b ku kv iv kw kx ky iy kz la lb lc ld le lf lg lh li lj lk ll lm hn dt translated">如上所述，SNS的每条消息调用策略非常适合这里，因为我们在扇出阶段优化了吞吐量和并行性。</p><p id="1a5e" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">在这里，一个<code class="eh ln lo lp lq b">ventilator</code>函数会将昂贵的任务划分为子任务，并为每个子任务向SNS主题发布一条消息。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ol"><img src="../Images/e635ef44e0b28cf15b8d9b508a3dab38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8diTCV4S66QFUI8InMPQEw.png"/></div></div></figure><p id="e75e" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">这基本上是我们在Yubl(我工作的最后一家初创公司)实现时间线功能时采用的方法，它的工作方式与Twitter的时间线相同——当你发布一篇新帖子时，它会被分发到你的追随者的时间线；当你关注另一个用户时，他们的帖子会很快出现在你的时间轴上。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff om"><img src="../Images/d202514c25dbe4912356ec265bf9cf1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*rgaL7r9si3v0McLPt5jC6Q.png"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Yubl had a timeline feature which works the same way as Twitter’s timeline. When you publish a new post, the post will be distributed to the timeline of your followers.</figcaption></figure><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff on"><img src="../Images/37e2f4047fed8b1ef67fbdb30888d6d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mD0FklQtK3nlAM0RFfFTEg.png"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">A real-world example of fan-out whereby a user’s new post is distributed to his followers. Since the user can have tens of thousands of followers the task is broken down into many subtasks — each subtask involves distributing the new post to 1k followers and can be performed in parallel.</figcaption></figure><h2 id="7cdd" class="lu ka hu bd kb lv lw lx kf ly lz ma kj la mb mc kl le md me kn li mf mg kp mh dt translated">和SQS一起散开</h2><p id="e25b" class="pw-post-body-paragraph kr ks hu kt b ku kv iv kw kx ky iy kz la lb lc ld le lf lg lh li lj lk ll lm hn dt translated">在AWS Lambda出现之前，这种类型的工作负载通常由SQS执行。不幸的是，SQS不是Lambda支持的事件源之一，这使它在这里处于非常不利的地位。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff oo"><img src="../Images/9e0244ee510a19269cbe7aa338f10177.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OpjlY8qnEovzY8pcaPJcWA.png"/></div></div></figure><div class="mn mo fm fo mp mq"><a href="http://docs.aws.amazon.com/lambda/latest/dg/invoking-lambda-function.html" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab ej"><div class="ms ab mt cl cj mu"><h2 class="bd hv fv z el mv eo ep mw er et ht dt translated">支持的事件源- AWS Lambda</h2><div class="mx l"><h3 class="bd b fv z el mv eo ep mw er et ek translated">本主题列出了受支持的AWS服务，您可以将这些服务配置为AWS Lambda函数的事件源。你先请…</h3></div><div class="my l"><p class="bd b gc z el mv eo ep mw er et ek translated">docs.aws.amazon.com</p></div></div></div></a></div><p id="07e2" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">也就是说，SQS本身仍然是分配任务的一个很好的选择，如果你的子任务需要超过5分钟(Lambda的最大执行时间)才能完成，你可能仍然需要想办法让SQS + Lambda的设置工作起来。</p><p id="4a11" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">让我解释一下我的意思。</p><p id="71b0" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">首先，通过将Lambda函数写成递归函数，它有可能超过5分钟的执行时间限制。然而，最初的调用(由SNS触发)必须表明SNS消息是否被成功处理，但是该信息只有在递归结束时才可用！</p><p id="d14d" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">有了SQS，你就有了一个可以在递归过程中传递的消息句柄。递归调用然后可以使用句柄来:</p><ul class=""><li id="d3f6" class="nj nk hu kt b ku mi kx mj la nl le nm li nn lm no np nq nr dt translated">延长消息的可见性超时时间，以便在我们仍在处理消息时，另一个SQS轮询器不会收到它</li><li id="ea30" class="nj nk hu kt b ku ns kx nt la nu le nv li nw lm no np nq nr dt translated">如果我们能够成功处理该邮件，请将其删除</li></ul><p id="7d49" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">不久前，我构建了一个使用递归Lambda函数处理SQS消息的架构原型。该架构允许根据backlog的大小(或者您选择缩放的任何CloudWatch指标)弹性地增加或减少轮询器的数量。</p><p id="8e6d" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">你可以在这里阅读全部内容<a class="ae ls" rel="noopener" href="/theburningmonk-com/aws-lambda-use-recursive-function-to-process-sqs-messages-part-2-28b488993d8e">。</a></p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff op"><img src="../Images/25d8a2b107878da8c4a745f6b7895aa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h-sj4P7jvnCL9lS_UWlYmQ.png"/></div></div></figure><div class="mn mo fm fo mp mq"><a href="http://theburningmonk.com/2016/09/aws-lambda-use-recursive-function-to-process-sqs-messages-part-2/" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab ej"><div class="ms ab mt cl cj mu"><h2 class="bd hv fv z el mv eo ep mw er et ht dt translated">AWS Lambda——使用递归函数处理SQS消息(第2部分)</h2><div class="mx l"><h3 class="bd b fv z el mv eo ep mw er et ek translated">首先，很抱歉从第1部分开始花了几个月的时间来写这篇文章，自从加入Yubl以来，我一直非常忙…</h3></div><div class="my l"><p class="bd b gc z el mv eo ep mw er et ek translated">theburningmonk.com</p></div></div><div class="mz l"><div class="oq l nb nc nd mz ne jt mq"/></div></div></a></div><p id="c93e" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">我不相信它降低了常规使用的SQS + Lambda设置的门槛，更不用说为轮询SQS而24/7运行Lambda函数的额外成本了。然而，我确实知道一些公司(包括我的一个前雇主)正在生产中大规模使用这种架构，所以它可能工作得足够好。</p><p id="3a39" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">无论如何，把它放在你的后口袋里，以防万一你需要让AWS Lambda和SQS一起工作。</p><h2 id="f222" class="lu ka hu bd kb lv lw lx kf ly lz ma kj la mb mc kl le md me kn li mf mg kp mh dt translated">Kinesis或者DynamoDB流呢？</h2><p id="8657" class="pw-post-body-paragraph kr ks hu kt b ku kv iv kw kx ky iy kz la lb lc ld le lf lg lh li lj lk ll lm hn dt translated">就我个人而言，我不认为这些是很好的选择，因为并行度受到碎片数量的限制。虽然您可以增加碎片的数量，但这是获得额外并行性的一种非常昂贵的方式，特别是考虑到在Kinesis流中重新共享的工作方式——在分割现有碎片后，旧碎片仍然存在至少24小时(根据您的保留策略),您将继续为此付费。</p><p id="fe44" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">因此，动态地调整碎片的数量来扩大和缩小您所追求的并行度会导致很多不必要的成本。</p><p id="3695" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">对于DynamoDB流，您甚至不能选择对流进行重散列——这是一个托管流，它会根据需要进行重散列。</p><h2 id="15d8" class="lu ka hu bd kb lv lw lx kf ly lz ma kj la mb mc kl le md me kn li mf mg kp mh dt translated">扇入:从工人那里收集结果</h2><p id="ab95" class="pw-post-body-paragraph kr ks hu kt b ku kv iv kw kx ky iy kz la lb lc ld le lf lg lh li lj lk ll lm hn dt translated">当<code class="eh ln lo lp lq b">ventilator</code>函数将原始任务划分为许多子任务时，它还可以为每个子任务包含两个标识符——一个用于顶层任务，一个用于子任务。当子任务完成时，您可以使用标识符来记录它们的结果。</p><p id="5e95" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">例如，您可以使用DynamoDB表来存储这些结果。但是请记住，DynamoDB的最大条目大小为400KB，包括属性名。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff or"><img src="../Images/0b88da5eeeb13f828cbb5e97de7b5260.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WBmKMiod12DJOqOOx9i55w.png"/></div></div></figure><p id="3872" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">或者，您也可以考虑将结果存储在S3中，它的最大对象大小高达5TB！例如，您可以按如下方式存储结果:</p><pre class="jk jl jm jn fq os lq ot ou aw ov dt"><span id="3f80" class="lu ka hu lq b fv ow ox l oy oz">bucket/job_id/task_01.json<br/>bucket/job_id/task_02.json<br/>bucket/job_id/task_03.json<br/>...</span></pre><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff pa"><img src="../Images/7f63d5c36307a1daacccd1d3acaa7e4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LNgo11sQSFUrrB7_-0-6yw.png"/></div></div></figure><p id="eac1" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">注意，在这两种情况下，我们都容易遇到热分区——针对同一个DynamoDB散列键或S3前缀的大量写入。</p><p id="13fe" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">为了减轻这种负面影响，请确保对作业ID使用GUID。</p><p id="a6e7" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">根据您需要对S3执行的写操作量，您可能需要调整这种方法。例如:</p><ul class=""><li id="2e66" class="nj nk hu kt b ku mi kx mj la nl le nm li nn lm no np nq nr dt translated">使用顶级文件夹对存储桶进行分区，并根据作业ID的哈希值将结果放入正确的文件夹中</li></ul><pre class="jk jl jm jn fq os lq ot ou aw ov dt"><span id="a5c8" class="lu ka hu lq b fv ow ox l oy oz">bucket/01/job_id_001/task_01.json<br/>bucket/01/job_id_001/task_02.json<br/>bucket/01/job_id_001/task_03.json<br/>...</span></pre><ul class=""><li id="acae" class="nj nk hu kt b ku mi kx mj la nl le nm li nn lm no np nq nr dt translated">在S3以容易散列但非结构化的方式存储结果，但也在DynamoDB表中记录对它们的引用</li></ul><pre class="jk jl jm jn fq os lq ot ou aw ov dt"><span id="5347" class="lu ka hu lq b fv ow ox l oy oz">bucket/ffa7046a-105e-4a00-82e6-849cd36c303b.json<br/>bucket/8fb59303-d379-44b0-8df6-7a479d58e387.json<br/>bucket/ba6d48b6-bf63-46d1-8c15-10066a1ceaee.json<br/>...</span></pre><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff pb"><img src="../Images/3d82478d6b7754967155ab3f771f875b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r59cTFryFxokoXThLEw2Ig.png"/></div></div></figure><h2 id="d1cc" class="lu ka hu bd kb lv lw lx kf ly lz ma kj la mb mc kl le md me kn li mf mg kp mh dt translated">扇入:跟踪整体进度</h2><p id="c6b0" class="pw-post-body-paragraph kr ks hu kt b ku kv iv kw kx ky iy kz la lb lc ld le lf lg lh li lj lk ll lm hn dt translated">当<code class="eh ln lo lp lq b">ventilator</code>函数运行并将昂贵的任务分割成许多小的子任务时，它还应该记录子任务的总数。这样，它允许每次调用<code class="eh ln lo lp lq b">worker</code>函数自动递减计数，直到它达到0。</p><p id="a8ee" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">看到计数达到0的调用负责发出所有子任务都已完成的信号。它可以通过许多方式做到这一点，也许是通过向另一个SNS主题发布消息，这样<code class="eh ln lo lp lq b">worker</code>功能就与聚合单个结果所需的任何post步骤相分离。</p><p id="b4a6" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">(等等，我们又回到了发布订阅模式了吗？)也许；-)</p><p id="13fa" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">此时，将调用<code class="eh ln lo lp lq b">sink</code>函数(或者在map-reduce作业的上下文中称为reducer)。鉴于您可能有大量的结果要收集，将<code class="eh ln lo lp lq b">sink</code>函数也写成递归函数可能是个好主意。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff pc"><img src="../Images/b229e23185da217f2f47a056f775ee18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nNDVN1My7Lk1id9iWHuJTg.png"/></div></div></figure><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff oo"><img src="../Images/dfde5a464c8acf554268b3ecf8b4b49b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nWetZ-XFTkyQr76AqkEfGQ.png"/></div></div></figure><p id="66ea" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">无论如何，这些只是我能想到的用AWS Lambda实现<code class="eh ln lo lp lq b">pub-sub</code>和<code class="eh ln lo lp lq b">push-poll</code>模式的一些方法。如果我错过了任何明显的选择，请在评论中告诉我。</p></div><div class="ab cl pd pe hc pf" role="separator"><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi"/></div><div class="hn ho hp hq hr"><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="ab fr cl pk"><img src="../Images/8b4e4721bb1973db389b5b533d727ad1.png" data-original-src="https://miro.medium.com/v2/format:webp/0*b_1R345KzKSaI8sg.png"/></div></figure><p id="f870" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">嗨，我的名字是<strong class="kt hv">崔琰</strong>。我是一个<a class="ae ls" href="https://aws.amazon.com/developer/community/heroes/yan-cui/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt hv"> AWS无服务器英雄</strong> </a>和<a class="ae ls" href="https://bit.ly/production-ready-serverless" rel="noopener ugc nofollow" target="_blank"> <strong class="kt hv">量产无服务器</strong> </a>的作者。我已经在AWS中运行了近10年的大规模生产工作负载，我是一名架构师或首席工程师，涉足从银行、电子商务、体育流媒体到移动游戏等多个行业。我目前是一名专注于AWS和无服务器的独立顾问。</p><p id="c37e" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">你可以通过<a class="ae ls" href="mailto:theburningmonk.com" rel="noopener ugc nofollow" target="_blank">邮箱</a>、<a class="ae ls" href="https://twitter.com/theburningmonk" rel="noopener ugc nofollow" target="_blank"> Twitter </a>和<a class="ae ls" href="https://www.linkedin.com/in/theburningmonk/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我。</p></div><div class="ab cl pd pe hc pf" role="separator"><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi"/></div><div class="hn ho hp hq hr"><p id="404d" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">查看我的新课程，<a class="ae ls" href="https://theburningmonk.thinkific.com/courses/complete-guide-to-aws-step-functions" rel="noopener ugc nofollow" target="_blank"><strong class="kt hv">AWS步骤功能完整指南</strong> </a>。</p><p id="a329" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">在本课程中，我们将介绍有效使用AWS Step Functions服务所需了解的一切。包括基本概念、HTTP和事件触发器、活动、设计模式和最佳实践。</p><p id="cd40" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">在这里拿到你的副本。</p></div><div class="ab cl pd pe hc pf" role="separator"><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi"/></div><div class="hn ho hp hq hr"><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff pl"><img src="../Images/2faf40b47320300fed81b3e09483ffb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZYcHhOOzUf5VB-Ri.png"/></div></div></figure><p id="ee8c" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">来了解AWS Lambda: CI/CD的操作性<strong class="kt hv">最佳实践</strong>，本地测试&amp;调试功能、日志记录、监控、分布式跟踪、canary部署、配置管理、认证&amp;授权、VPC、安全性、错误处理等等。</p><p id="8bb5" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">还可以用代码<strong class="kt hv"> ytcui </strong>获得<strong class="kt hv">票面价格6折</strong>。</p><p id="f62a" class="pw-post-body-paragraph kr ks hu kt b ku mi iv kw kx mj iy kz la mk lc ld le ml lg lh li mm lk ll lm hn dt translated">点击获取您的副本<a class="ae ls" href="https://bit.ly/production-ready-serverless" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>