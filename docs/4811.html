<html>
<head>
<title>Do pure functions exist in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中存在纯函数吗？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/do-pure-functions-exist-in-javascript-b128ed5f0ed2?source=collection_archive---------5-----------------------#2017-06-23">https://medium.com/hackernoon/do-pure-functions-exist-in-javascript-b128ed5f0ed2?source=collection_archive---------5-----------------------#2017-06-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/550317e12373d46eff8c862acd1549ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ngrcIKRhCQUL9TbCW9IB2A.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">A shadow over our clean, elegant code? Photo by <a class="ae jg" href="http://unsplash.com/@bixphotos?utm_campaign=photographer-credit" rel="noopener ugc nofollow" target="_blank">Benjamin Bousquet</a></figcaption></figure><p id="a332" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最近，我参加了一个关于如何在JavaScript中确定一个函数是纯函数的讨论。纯粹的整个概念在这样一种动态的语言中似乎是模糊的。下面的例子表明，我们可能需要重新定义“纯函数”这个术语，或者——至少——在我们做出决定时要非常小心。</p><h1 id="eb07" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">什么是纯函数</h1><p id="6241" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">如果你是新学期的学生，我建议你先阅读一些介绍。<a class="ae jg" href="http://alvinalexander.com/scala/fp-book/definition-of-pure-function" rel="noopener ugc nofollow" target="_blank"/><a class="ae jg" href="https://twitter.com/alvinalexander" rel="noopener ugc nofollow" target="_blank">阿尔文·亚历山大</a>和<a class="ae jg" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976">大师JavaScript访谈:什么是纯函数？埃里克·埃利奥特</a>是很好的选择。</p><p id="185b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">综上所述，一个函数如果满足两个条件就叫纯函数:</p><blockquote class="lk"><p id="6257" class="ll lm hu bd ln lo lp lq lr ls lt ke ek translated">1)每次使用相同的参数集调用该函数时，它都会返回完全相同的结果。</p><p id="d9b7" class="ll lm hu bd ln lo lp lq lr ls lt ke ek translated">2)函数的求值除了返回值之外，不修改其范围之外的某些状态，也不与外界有可观察到的交互。(无副作用。)</p></blockquote><p id="d93a" class="pw-post-body-paragraph jh ji hu jj b jk lu jm jn jo lv jq jr js lw ju jv jw lx jy jz ka ly kc kd ke hn dt translated">有时，会添加第三个条件:“不依赖外部可变状态。”事实上，这是多余的，因为对可变变量的这种依赖将不可避免地导致违反第一个条件。</p><h1 id="d67f" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">这些中哪一个是纯的</h1><p id="6b9e" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">这里我写了四个示例函数。在继续之前，请回顾它们，自己决定哪些是纯净的，哪些是不纯净的。</p><figure class="lz ma mb mc fq iv"><div class="bz el l di"><div class="md me l"/></div></figure><p id="e267" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">完成了吗？太好了，我们来比较一下。</p><p id="1f48" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当我四处询问时，绝大多数人回答说函数<em class="mf"> doubleB </em>是唯一不纯的，函数<em class="mf"> doubleA </em>、<em class="mf"> doubleC </em>和<em class="mf"> doubleD </em>是纯的。</p><p id="5934" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们来看看条件。后一种是浑然不觉的；没有副作用。</p><p id="c236" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">第一个，更有趣。当使用相同的参数调用时，它们都返回相同的值(使用<a class="ae jg" href="https://facebook.github.io/jest/docs/expect.html#toequalvalue" rel="noopener ugc nofollow" target="_blank">等同于</a>来支持数组):</p><pre class="lz ma mb mc fq mg mh mi mj aw mk dt"><span id="ec26" class="ml kg hu mh b fv mm mn l mo mp">expect( doubleA(1) ).toEqual( doubleA(1) )<br/>expect( doubleB(1) ).toEqual( doubleB(1) )<br/>expect( doubleC(1) ).toEqual( doubleC(1) )<br/>expect( doubleD([1]) ).toEqual( doubleD([1]) )</span></pre><p id="e391" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对吗？对吗？</p><p id="28cb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Weeeell，这样写是的。但是，我的朋友<a class="li lj gr" href="https://medium.com/u/dff9a83c7a3c?source=post_page-----b128ed5f0ed2--------------------------------" rel="noopener" target="_blank">亚历山大</a>T22】回复的这段代码呢？</p><pre class="lz ma mb mc fq mg mh mi mj aw mk dt"><span id="35bb" class="ml kg hu mh b fv mm mn l mo mp">doubleB(1) // -&gt; 2</span><span id="fd5d" class="ml kg hu mh b fv mq mn l mo mp">two = 3</span><span id="bb39" class="ml kg hu mh b fv mq mn l mo mp">doubleB(1) // -&gt; 3</span></pre><p id="ed82" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是有效的。我用相同的参数运行了这个函数两次，得到了不同的值。这使得它不纯。不管中间发生了什么？</p><p id="260e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这让我思考。如果这就是证据，那其他人呢？如果我足够努力，他们会坚持吗？正如你所猜测的，不，他们没有。事实上，我现在说:</p><blockquote class="lk"><p id="f583" class="ll lm hu bd ln lo lp lq lr ls lt ke ek translated">四个函数没有一个是纯的。</p></blockquote><h2 id="a821" class="ml kg hu bd kh mr ms mt kl mu mv mw kp js mx my kt jw mz na kx ka nb nc lb nd dt translated">功能一流</h2><p id="51bc" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">在JavaScript中，函数是一级的，这意味着它们是一个变量的值，可以被传递、返回和重新分配。如果我可以改变变量<em class="mf">和两个</em>，我可以做如下操作:</p><pre class="lz ma mb mc fq mg mh mi mj aw mk dt"><span id="63c0" class="ml kg hu mh b fv mm mn l mo mp">doubleC(1) // -&gt; 2</span><span id="2870" class="ml kg hu mh b fv mq mn l mo mp">getTwo = function() { return 3 }</span><span id="b606" class="ml kg hu mh b fv mq mn l mo mp">doubleC(1) // -&gt; 3</span></pre><p id="8bed" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">需要强调的是，这与Alex在上面所做的并无不同。只是变量不是保存一个数字，而是保存一个函数。</p><h2 id="c3b6" class="ml kg hu bd kh mr ne mt kl mu nf mw kp js ng my kt jw nh na kx ka ni nc lb nd dt translated">阵列上的地图</h2><p id="eeef" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated"><a class="ae jg" href="https://www.youtube.com/watch?v=RUXUXup1Ji0" rel="noopener ugc nofollow" target="_blank">“贴图，过滤，缩小。重复。”</a>这是我在<a class="ae jg" href="https://www.twitch.tv/robinpokorny" rel="noopener ugc nofollow" target="_blank">的一次现场编码会议</a>的名字。这三者是函数式编程中数据转换的核心。所以在纯函数中使用它们应该是安全的。</p><p id="198e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">事实证明，在JavaScript中没有什么是一成不变的。或者应该说在<em class="mf">原型</em>里？</p><pre class="lz ma mb mc fq mg mh mi mj aw mk dt"><span id="40af" class="ml kg hu mh b fv mm mn l mo mp">doubleD([1]) // -&gt; [2]</span><span id="a356" class="ml kg hu mh b fv mq mn l mo mp">Array.prototype.map = function() {<br/>  return [3]<br/>}</span><span id="7eca" class="ml kg hu mh b fv mq mn l mo mp">doubleD([1]) // -&gt; [3]</span></pre><p id="fb09" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">等等。这肯定是不允许的。这是不对的。</p><p id="0ba9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这可能是错误的，也可能是愚蠢的。事实是，我只是用相同的参数调用了函数<em class="mf">double</em>两次，得到了不同的值。<em class="mf">无论在</em>之间发生了什么。</p><p id="af48" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们所做的就是在函数调用之间重新分配变量。就像我们以前做的一样。</p><p id="2897" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，<em class="mf">翻倍</em>不纯。</p><h2 id="22bc" class="ml kg hu bd kh mr ne mt kl mu nf mw kp js ng my kt jw nh na kx ka ni nc lb nd dt translated">乘法是纯粹的</h2><p id="e3ba" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">无论动态性如何，在JavaScript中人们不能像在某些语言中那样覆盖内置的操作符。</p><p id="e031" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">此外，<em class="mf"> n </em>是一个只存在于该函数范围内的局部变量。没有办法从外面改变它。</p><p id="4e93" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">或者是？</p><p id="a9f3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不，这真的不可能。如果你抱太大希望的话，你一定不看好JavaScript😄</p><p id="2c10" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是当我写下这四个函数没有一个是纯的时，我暴露了自己。我还有一个锦囊妙计。</p><p id="9ca2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">虽然我不能改变操作，也不能改变通过后的参数，但我有选择通过什么的自由。数字、字符串、布尔、对象…</p><p id="4d3d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对象？它们能有什么用？一个数乘以一个对象是，呃，是…像在` 2 * {} `中，是… <em class="mf">南。</em>(去控制台检查一下。)(正如我所做的。)</p><p id="cdbc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不过，这没什么用。要是有一种方法能让运行时在相乘时将对象转换成数字就好了。</p><h2 id="d336" class="ml kg hu bd kh mr ne mt kl mu nf mw kp js ng my kt jw nh na kx ka ni nc lb nd dt translated">数字字符串</h2><p id="db42" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">如果一个对象出现在一个字符串上下文中，比如与一个字符串连接，引擎将运行该对象的<em class="mf"> toString </em>函数并使用结果。如果没有实现，它将回退到已知的由<em class="mf">Object . prototype . tostring</em>方法产生的<em class="mf">'【对象对象】'</em>。</p><p id="c589" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">虽然很少使用，但是当JavaScript需要一个数字(或者一个布尔值，或者一个函数)时，它也会调用对象的<em class="mf"> valueOf </em>方法。剩下的就是让这个函数每次被调用时返回不同的值。</p><pre class="lz ma mb mc fq mg mh mi mj aw mk dt"><span id="753e" class="ml kg hu mh b fv mm mn l mo mp">var o = {<br/>  valueOf: Math.random<br/>}</span><span id="d923" class="ml kg hu mh b fv mq mn l mo mp">doubleA(o) // -&gt; 1.7709942335937932</span><span id="5d9c" class="ml kg hu mh b fv mq mn l mo mp">doubleA(o) // -&gt; 1.2600863386367704</span></pre><p id="89a5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><a class="ae jg" href="http://jsbin.com/lojupas/edit?js,console" rel="noopener ugc nofollow" target="_blank">在JS Bin中运行这个。</a></p><p id="a4c6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">乌夫，是的。使用完全相同的(通过任何比较手段)参数调用了该函数两次，第二次返回的值与第一次不同。它不纯。</p><p id="0aed" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="mf">注意:本文的前一版本使用了</em>@ @ top primitive<em class="mf">，或者更详细地说，</em>symbol . top primitive<em class="mf">。正如</em><a class="li lj gr" href="https://medium.com/u/1dd97108b7fa?source=post_page-----b128ed5f0ed2--------------------------------" rel="noopener" target="_blank"><em class="mf">Alexandre mor gaut</em></a><em class="mf">所指出的，从JavaScript的第一个版本开始，</em> valueOf <em class="mf">就已经足够并得到支持。如果你不知道</em> @@toPrimitive <em class="mf">，你可能还是想</em> <a class="ae jg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive" rel="noopener ugc nofollow" target="_blank"> <em class="mf">查一下</em> </a> <em class="mf">。</em></p><h1 id="2a10" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">什么是纯函数</h1><p id="d166" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">我知道，我是小心翼翼的，邪恶的，而且我用了一些卑鄙的手段。我们使用纯函数来增强对代码的信心。以确保代码做它应该做的事情。任何时候，任何情况下。</p><p id="3c9e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果我决定的话，我希望这四个函数都是纯的。是的，这包括像<em class="mf"> doubleB </em>这样的功能。如果那个变量(<em class="mf">两个</em>)不应该被改变，它是一个数学常数e，pi，或者<a class="ae jg" href="https://en.wikipedia.org/wiki/Golden_ratio" rel="noopener ugc nofollow" target="_blank"> phi </a>呢？那应该是纯的。</p><p id="bb46" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我希望能够信任内置函数。如果我假设<em class="mf">数组.原型</em>或<em class="mf">对象.原型</em>中的任何东西都可以改变，我能创建什么样的程序？极其基础的；没有人会想使用它们。</p><p id="c9f4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">由于这个小而有趣的练习，我相信<strong class="jj hv">我们需要一个新的定义来定义JavaScript中的纯函数</strong>。不幸的是，我认为这不可能仅限于技术术语。</p><p id="1896" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在某种程度上，它必须考虑代码的预期用途。一个函数在一个项目中可能被认为是纯的，而在另一个项目中可能被认为是不纯的。这是可以的。只要程序运行正常。只要开发商有信心。</p><p id="8a2d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你对这个定义有什么想法吗？你如何决定一个函数是纯的？我错过了什么吗？你学到什么了吗？</p></div><div class="ab cl nj nk hc nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="hn ho hp hq hr"><h1 id="55db" class="kf kg hu bd kh ki nq kk kl km nr ko kp kq ns ks kt ku nt kw kx ky nu la lb lc dt translated">评论</h1><p id="4e8a" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">有<em class="mf">的一些</em>方法来抵御<em class="mf">的一些</em>上面使用的诡计。</p><p id="825b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通过将整个块封装到一个函数中，可以避免覆盖像<em class="mf"> two </em>或<em class="mf"> getTwo </em>这样的自由变量。使用<a class="ae jg" href="https://en.wikipedia.org/wiki/Immediately-invoked_function_expression" rel="noopener ugc nofollow" target="_blank">寿命</a>或模块:</p><pre class="lz ma mb mc fq mg mh mi mj aw mk dt"><span id="9e1c" class="ml kg hu mh b fv mm mn l mo mp">var doubleB = (function () {<br/>  var two = 2</span><span id="e767" class="ml kg hu mh b fv mq mn l mo mp">  return function (n) {<br/>    return n * two<br/>  }<br/>})()</span></pre><p id="78e2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">更好的方法是使用ES2015中引入的<a class="ae jg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const" rel="noopener ugc nofollow" target="_blank">常量</a>:</p><pre class="lz ma mb mc fq mg mh mi mj aw mk dt"><span id="ccf7" class="ml kg hu mh b fv mm mn l mo mp">const two = 2<br/>const doubleB = (n) =&gt; n * two</span></pre><p id="51da" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">防止滥用或<em class="mf">的<em class="mf">值也是可能的，但是很麻烦。比如像这样:</em></em></p><pre class="lz ma mb mc fq mg mh mi mj aw mk dt"><span id="684b" class="ml kg hu mh b fv mm mn l mo mp">function doubleA(n) {<br/>  if (typeof n !== 'number') return NaN</span><span id="421f" class="ml kg hu mh b fv mq mn l mo mp">  return n * 2<br/>}</span></pre><p id="9d50" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">人们可以通过改变<em class="mf"> Array.prototype </em>来避开这个技巧，只需避免这样的函数，并退回到<em class="mf"> for (for … of) </em>循环。这是丑陋的，不切实际的，甚至是不可能的。抽象这些或者使用一个库本身就有缺点。</p><p id="a82b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不要忘记，要使一个函数真正纯净，需要将所有这些反技巧结合在一起。想象一下，现在优雅的doubleD看起来会是什么样子，会有多长，会如何损害可读性。</p><p id="852b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="mf">如果你喜欢这个帖子，请别忘了给个</em>👏<em class="mf">下面的</em>。每一个鼓掌通知对我来说都是一种激励。</p><p id="6aed" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你想了解更多，我最近在YouTube上开了一个关于JavaScript的频道。我每周都会发布新视频，所以可以考虑订阅。从一开始就在那里，帮助我变得更好。</p><div class="nv nw fm fo nx ny"><a href="https://www.youtube.com/c/robinpokorny?sub_confirmation=1" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab ej"><div class="oa ab ob cl cj oc"><h2 class="bd hv fv z el od eo ep oe er et ht dt translated">YouTube上的罗宾·波科尔尼</h2><div class="of l"><h3 class="bd b fv z el od eo ep oe er et ek translated">JavaScript是我的激情所在:我喜欢写JavaScript，我喜欢读JavaScript，我喜欢说JavaScript。</h3></div><div class="og l"><p class="bd b gc z el od eo ep oe er et ek translated">www.youtube.com/c/robinpokorny</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om ja ny"/></div></div></a></div><div class="lz ma mb mc fq ab cb"><figure class="on iv oo op oq or os paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="on iv oo op oq or os paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="on iv oo op oq or os paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ot ou ov"><p id="f922" class="jh ji mf jj b jk jl jm jn jo jp jq jr ow jt ju jv ox jx jy jz oy kb kc kd ke hn dt translated"><a class="ae jg" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jg" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jg" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jg" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jh ji mf jj b jk jl jm jn jo jp jq jr ow jt ju jv ox jx jy jz oy kb kc kd ke hn dt translated">如果您喜欢这个故事，我们建议您阅读我们的最新科技故事和<a class="ae jg" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实视为理所当然！</p></blockquote><figure class="lz ma mb mc fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff oz"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>