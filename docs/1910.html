<html>
<head>
<title>Beginner Bites: ES6 features you need to know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初学者入门:你需要知道的ES6特性</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/es6-features-you-need-to-know-now-b525e2b0755e?source=collection_archive---------6-----------------------#2016-12-19">https://medium.com/hackernoon/es6-features-you-need-to-know-now-b525e2b0755e?source=collection_archive---------6-----------------------#2016-12-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="53b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您熟悉原生JavaScript，并使用它创建了一些应用程序，但是当您进入更广阔的生态系统时，会发现JavaScript看起来很陌生。尤其是在你经常听说的那些库的文档中，像“React”、“Redux”、“TypeScript”、“Angular”、“Ember”、“T5”在这里插入很酷的框架/库 &gt;。我个人发现学习任何新的库都很困难，因为需要理解未来的JavaScript语言ES6。</p><p id="b70e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这篇文章中，我希望涵盖使用JSBin测试未来的JavaScript特性，并提供示例和练习。这篇文章的目标读者是希望接触ECMAScript6最重要部分的初学者(以便阅读和理解当今使用的现代库的文档)。</p><p id="2fd3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将涵盖:</p><ul class=""><li id="7da8" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">箭头功能</li><li id="fca0" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">休息参数</li><li id="3726" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">解构分配</li><li id="34b0" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">模板文字</li><li id="d916" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">班级</li><li id="a2c8" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">承诺</li><li id="170d" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">发电机</li></ul><p id="c38a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我推荐使用<a class="ae ke" href="https://jsbin.com/" rel="noopener ugc nofollow" target="_blank"> JSBin </a>来测试这些例子！(确保将JSBin语言改为<strong class="it hv"> ES6 / Babel </strong>)</p></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><h2 id="afbf" class="km kn hu bd ko kp kq kr ks kt ku kv kw jc kx ky kz jg la lb lc jk ld le lf lg dt translated">箭头功能</h2><p id="8a8e" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">箭头函数可以被认为是编写函数的一种简写方式。以下两个函数是等效的:</p><pre class="lm ln lo lp fq lq lr ls lt aw lu dt"><span id="21df" class="km kn hu lr b fv lv lw l lx ly">var fn1 = function (a) {<br/>    return 2 * a<br/>}</span></pre><p id="bcd4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lz ma mb lr b">var fn2 = a =&gt; 2 * a;</code></p><p id="5eff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae ke" href="https://jsbin.com/kiduqisagi/2/edit?js,console" rel="noopener ugc nofollow" target="_blank">现场玩一下上面的例子</a>。</p><p id="8242" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您会注意到上面的箭头函数有一些问题。</p><p id="41c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，arrow函数的参数缺少括号。这是因为只有一个参数<code class="eh lz ma mb lr b">a</code>。如果我们想传入多个参数，我们需要把那些括号放回去。</p><p id="5072" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lz ma mb lr b">var fn3 = (a, b) =&gt; a + b;</code></p><p id="655d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">其次，您还会注意到箭头右侧的<em class="jp">隐式返回</em>。箭头的右边是<code class="eh lz ma mb lr b">return a + b;</code>的简写。如果我们想在arrow函数中做更多的事情，而不仅仅是一个返回行呢？我们重新引入<code class="eh lz ma mb lr b">{}</code>括号。</p><pre class="lm ln lo lp fq lq lr ls lt aw lu dt"><span id="7f1a" class="km kn hu lr b fv lv lw l lx ly">var fn4 = (a, b) =&gt; {<br/>    var result = a + b;<br/>    return result<br/>}</span></pre><p id="2b7b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，如果你想<em class="jp">隐式返回</em>一个对象，你会遇到一个问题。对象文字符号周围的花括号会干扰声明函数体的花括号。在这种情况下，您需要用括号将对象括起来。</p><pre class="lm ln lo lp fq lq lr ls lt aw lu dt"><span id="12d8" class="km kn hu lr b fv lv lw l lx ly">// Incorrect return of object literal notation.<br/>var fn5 = () =&gt; { name: 'Bob' };</span><span id="6443" class="km kn hu lr b fv mc lw l lx ly">// Correct return of object literal notation.<br/>var fn6 = () =&gt; ({ name: 'Bob' });</span></pre><p id="d0d7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">值得研究的其他几点:</p><ul class=""><li id="bb03" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated"><a class="ae ke" href="http://www.2ality.com/2016/02/arrow-functions-vs-bind.html" rel="noopener ugc nofollow" target="_blank">箭头函数从它们被调用的词法范围绑定“this”。</a></li><li id="dc85" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated"><code class="eh lz ma mb lr b">arguments</code>没有在箭头函数中定义(解决方法见下面的<a class="ae ke" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/rest_parameters" rel="noopener ugc nofollow" target="_blank"> <em class="jp">剩余参数</em> </a>)。</li></ul><h2 id="83ca" class="km kn hu bd ko kp kq kr ks kt ku kv kw jc kx ky kz jg la lb lc jk ld le lf lg dt translated">休息参数</h2><p id="2f7f" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">Rest参数是一种在数组中捕获传递给函数的任意数量的参数的方法。这类似于<code class="eh lz ma mb lr b">arguments</code>,但是会给你一个实际的数组。</p><pre class="lm ln lo lp fq lq lr ls lt aw lu dt"><span id="e543" class="km kn hu lr b fv lv lw l lx ly">var fn7 = (a, b, ...theRest) =&gt; {<br/>    console.log(a);<br/>    console.log(b);<br/>    console.log(theRest);<br/>}</span><span id="caf2" class="km kn hu lr b fv mc lw l lx ly">fn7('A', 'B', 'C', 'D', 'E');</span></pre><p id="4914" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae ke" href="https://jsbin.com/nihasopibo/1/edit?js,console" rel="noopener ugc nofollow" target="_blank">使用休息参数。</a></p><p id="a3be" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">剩余参数</em>必须是参数列表中的最后一个参数。这种<code class="eh lz ma mb lr b">...</code>语法也可以用另外一种方式，<a class="ae ke" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank"> <em class="jp">析构</em> </a>一个数组。</p><h2 id="c70b" class="km kn hu bd ko kp kq kr ks kt ku kv kw jc kx ky kz jg la lb lc jk ld le lf lg dt translated">解构分配</h2><p id="37bc" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">这允许将数组或对象分散到不同的变量中。在上面的例子中，我们用<code class="eh lz ma mb lr b">’A’, ‘B’, ‘C’, ‘D’, ‘E’</code>来调用<code class="eh lz ma mb lr b">fn7</code>。我们可以将这些字母存储在一个数组中。但是如果我们将一个数组传递到函数中，我们最终会将数组分配给<code class="eh lz ma mb lr b">a</code>，而不是将数组分割到函数参数中。这里是<em class="jp">析构赋值语法的理想用例，</em>我们在数组前添加<code class="eh lz ma mb lr b">...</code>来析构它。</p><pre class="lm ln lo lp fq lq lr ls lt aw lu dt"><span id="73aa" class="km kn hu lr b fv lv lw l lx ly">var someArray = [<!-- -->’A’, ‘B’, ‘C’, ‘D’, ‘E’];</span><span id="2321" class="km kn hu lr b fv mc lw l lx ly">// Using fn7 defined above.</span><span id="a167" class="km kn hu lr b fv mc lw l lx ly">// Destructuring assignment. This will split 'someArray'.<br/>fn7(...someArray);</span><span id="7e67" class="km kn hu lr b fv mc lw l lx ly">/** WRONG **/ fn7(someArray);</span></pre><p id="4d56" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae ke" href="https://jsbin.com/sarohizera/2/edit?js,console" rel="noopener ugc nofollow" target="_blank">玩析构直播</a>。</p><p id="57f8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尝试使用析构语法的其他有趣的事情在<a class="ae ke" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank"> MDN文档</a>中显示。<code class="eh lz ma mb lr b">…</code>称为<a class="ae ke" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator" rel="noopener ugc nofollow" target="_blank">展开语法</a>。</p><h2 id="39f9" class="km kn hu bd ko kp kq kr ks kt ku kv kw jc kx ky kz jg la lb lc jk ld le lf lg dt translated">模板文字</h2><p id="a388" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">这是编写字符串文字的另一种方式，但允许您将表达式嵌入到字符串中。字符串包含在<code class="eh lz ma mb lr b">'</code>或<code class="eh lz ma mb lr b">"</code>中。模板文字包含在反勾号<code class="eh lz ma mb lr b">`</code>中。嵌入模板字符串的表达式位于<code class="eh lz ma mb lr b">${}</code>括号内。</p><pre class="lm ln lo lp fq lq lr ls lt aw lu dt"><span id="c483" class="km kn hu lr b fv lv lw l lx ly">var name = 'Mia';<br/>console.log(`Hi my name is ${name}.`);</span></pre><p id="c56d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">模板文字功能:</p><ul class=""><li id="2243" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">多线</li><li id="f046" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">有一个<em class="jp"> raw </em>属性允许你访问原始字符串</li><li id="3cc6" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">使用<em class="jp">标记的</em>模板文字进行输出修改</li></ul><p id="7d73" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae ke" href="https://jsbin.com/gutademeba/2/edit?js,console" rel="noopener ugc nofollow" target="_blank">模板文字的实例</a>。</p><h2 id="216c" class="km kn hu bd ko kp kq kr ks kt ku kv kw jc kx ky kz jg la lb lc jk ld le lf lg dt translated">班级</h2><p id="551a" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">一个简单的类可以这样定义:</p><pre class="lm ln lo lp fq lq lr ls lt aw lu dt"><span id="7279" class="km kn hu lr b fv lv lw l lx ly">class Monster {<br/>  <br/>  constructor(name){<br/>    this.name = name;<br/>  }<br/>  <br/>  greetings(){<br/>    console.log(`Hi my name is ${this.name}.`);<br/>  }<br/>}</span><span id="c98b" class="km kn hu lr b fv mc lw l lx ly">var goblin = new Monster('Jerry');<br/></span><span id="e7bc" class="km kn hu lr b fv mc lw l lx ly">goblin.greetings();</span></pre><p id="a861" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个类有一个构造函数，当你调用<code class="eh lz ma mb lr b">new Monster</code>时，这个构造函数就会被调用。在这个类中，构造函数需要一个参数<code class="eh lz ma mb lr b">name</code>。这个<code class="eh lz ma mb lr b">name</code>被分配给<code class="eh lz ma mb lr b">this.name</code>，T3是一个分配给创建的实例的变量。</p><p id="23bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae ke" href="https://jsbin.com/mugituquge/1/edit?js,console" rel="noopener ugc nofollow" target="_blank">一个基础类的实例</a>。</p><p id="86e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一篇关于类的精彩文章，我建议你深入研究。</p><h2 id="8150" class="km kn hu bd ko kp kq kr ks kt ku kv kw jc kx ky kz jg la lb lc jk ld le lf lg dt translated">承诺</h2><p id="74e6" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">在解释什么是承诺之前，我会试着解释承诺能解决什么问题。</p><p id="9700" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您正在编写一个天气应用程序，它允许用户获取给定位置的当前天气。有一个服务器，在你调用它之后，它会用温度来响应，但这可能需要一些时间。如果您的程序等待服务器提供温度，它将冻结，直到提供温度。另一种选择是<em class="jp">承诺</em>有一天这个价值会存在。然后对<em class="jp">解析</em>后的值做一些事情。如果出现错误，承诺可以<em class="jp">拒绝</em>，而您可以<em class="jp">捕捉</em>错误。</p><p id="bc49" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">花点时间看看这个例子并尝试这个练习。</p><p id="98b2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">承诺有完整的帖子专门讨论它们，所以我会链接一些帮助我理解它们的材料。</p><ul class=""><li id="4abc" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated"><a class="ae ke" href="https://scotch.io/tutorials/javascript-promises-for-dummies" rel="noopener ugc nofollow" target="_blank"> JavaScript给傻瓜的承诺</a></li><li id="53d5" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated"><a class="ae ke" href="https://www.promisejs.org/" rel="noopener ugc nofollow" target="_blank">https://www.promisejs.org/</a></li><li id="0c58" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated"><a class="ae ke" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank"> MDN承诺参考</a></li></ul><h2 id="de92" class="km kn hu bd ko kp kq kr ks kt ku kv kw jc kx ky kz jg la lb lc jk ld le lf lg dt translated">发电机</h2><p id="f9c4" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">生成器是一个可以暂停执行，然后从停止的地方继续执行的函数。当你需要分离逻辑和时间时，这是很棒的。</p><p id="b223" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我使用生成器的一个很好的例子是为<a class="ae ke" href="https://spyr1014.github.io/mazeSolver/" rel="noopener ugc nofollow" target="_blank">交互式迷宫解算器</a>创建动画。这让我可以制作一个简单的递归路径查找算法的动画，然后冻结/解冻它来绘制每个单独的帧。</p><p id="5727" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在函数声明中使用<code class="eh lz ma mb lr b">function*</code>声明一个生成器函数，如下所示:</p><p id="ca98" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lz ma mb lr b">function* generatorDefinition(){ /** stuff here **/ };</code></p><p id="4464" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">生成器函数使用<code class="eh lz ma mb lr b">yield</code> <em class="jp">而不是return </em>来暂停执行并产生一个值。为了让<em class="jp">产生</em>一个来自生成器的值，在从生成器返回的迭代器上调用<code class="eh lz ma mb lr b">.next()</code>。这将返回一个具有两个属性的对象(“done”和“value”)。当迭代器遇到一个<code class="eh lz ma mb lr b">return</code>语句时，它结束，返回<code class="eh lz ma mb lr b">done: true</code>和值。</p><p id="8dc1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用生成器中的<code class="eh lz ma mb lr b">yield*</code>调用另一个生成器函数。这就是你如何编写一个递归生成器。</p><p id="51ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">总结一下:</p><ul class=""><li id="5cd4" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">生成器返回一个迭代器。</li><li id="b297" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">打电话。迭代器上的next()返回一个具有两个属性的对象。“完成”和“价值”。</li><li id="b2ff" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">使用<code class="eh lz ma mb lr b">yield*</code>可以递归生成器。</li></ul><pre class="lm ln lo lp fq lq lr ls lt aw lu dt"><span id="c42e" class="km kn hu lr b fv lv lw l lx ly">function* trivialGenerator() {<br/>    var i = 0;<br/>    while (true) {<br/>        yield i++;<br/>    }<br/>}</span><span id="bf24" class="km kn hu lr b fv mc lw l lx ly">var myIterator = trivialGenerator();</span><span id="1190" class="km kn hu lr b fv mc lw l lx ly">console.log(myIterator.next());<br/>console.log(myIterator.next());</span></pre><p id="d5b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae ke" href="https://jsbin.com/wadusudeme/2/edit?js,console" rel="noopener ugc nofollow" target="_blank">在这里玩一个活生生的例子，尝试练习</a>。</p></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><p id="838e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你走到这一步，恭喜你！你绝对应该拍拍自己的背。你现在已经接触到了人们使用的语言的主要变化。作为奖励，有一个总结ES6 的<a class="ae ke" href="https://gist.github.com/vasco3/22b09ef0ca5e0f8c5996" rel="noopener ugc nofollow" target="_blank">备忘单。</a></p><p id="1689" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">黑客快乐！</p><p id="2ec9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp"> Edit 20/12/2016:改写了intro，纠正了一些被指出的错别字。</em></p><figure class="lm ln lo lp fq md"><div class="bz el l di"><div class="me mf l"/></div></figure><blockquote class="mg mh mi"><p id="8948" class="ir is jp it b iu iv iw ix iy iz ja jb mj jd je jf mk jh ji jj ml jl jm jn jo hn dt translated"><a class="ae ke" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是这个大家庭的一员。我们现在<a class="ae ke" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">正在接受投稿</a>，并乐意<a class="ae ke" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is jp it b iu iv iw ix iy iz ja jb mj jd je jf mk jh ji jj ml jl jm jn jo hn dt translated">要了解更多信息，请阅读我们的“关于”页面、<a class="ae ke" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">喜欢/在脸书上给我们发消息</a>，或者简单地发送<a class="ae ke" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is jp it b iu iv iw ix iy iz ja jb mj jd je jf mk jh ji jj ml jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ke" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ke" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>