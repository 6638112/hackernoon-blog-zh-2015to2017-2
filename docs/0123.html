<html>
<head>
<title>JavaScript — A Sneak Peak into the Essentials (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript——对本质的一次窥探(第3部分)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/javascript-a-sneak-peak-into-the-essentials-part-3-c97a9c2e933f?source=collection_archive---------0-----------------------#2015-12-21">https://medium.com/hackernoon/javascript-a-sneak-peak-into-the-essentials-part-3-c97a9c2e933f?source=collection_archive---------0-----------------------#2015-12-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir is it"><p id="bcc3" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">这篇博客文章是为那些已经知道如何编写软件并想学习Javascript的开发人员写的。我不是在教你如何写软件，因为我假设你可能用不同的语言编码。我还假设，即使是Javascript——忍者也喜欢在他们可能知道或可能不知道的话题的对话中有所下降。</p></blockquote><ol class=""><li id="980d" class="jt ju hu ix b iy iz jc jd jv jw jx jy jz ka js kb kc kd ke dt translated"><a class="ae kf" rel="noopener" href="/@michel.herszak/javascript-a-sneak-peak-into-the-essentials-part-1-5a2ef10e63d#.oebnf7aqu">句法糖</a></li><li id="f540" class="jt ju hu ix b iy kg jc kh jv ki jx kj jz kk js kb kc kd ke dt translated"><a class="ae kf" rel="noopener" href="/@michel.herszak/javascript-a-sneak-peak-into-the-essentials-part-2-9a4aa7dbd06#.avycxr84z"> Javascript模式/Javascript中的对象</a></li><li id="ea38" class="jt ju hu ix b iy kg jc kh jv ki jx kj jz kk js kb kc kd ke dt translated"><strong class="ix hv">JavaScript中的函数</strong></li><li id="7df7" class="jt ju hu ix b iy kg jc kh jv ki jx kj jz kk js kb kc kd ke dt translated"><a class="ae kf" rel="noopener" href="/@michel.herszak/javascript-a-sneak-peak-into-the-essentials-part-4-7abef2e984ae#.mo5i8c2nw">“这个”指的是这个</a></li><li id="a424" class="jt ju hu ix b iy kg jc kh jv ki jx kj jz kk js kb kc kd ke dt translated"><a class="ae kf" rel="noopener" href="/@michel.herszak/javascript-oop-essentials-88745eedb477#.38ktw1lsn"> OOP(面向对象编程)</a></li></ol><h1 id="55f5" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">Javascript中的函数</h1><p id="97e8" class="pw-post-body-paragraph iu iv hu ix b iy lj ja jb jc lk je jf jv ll ji jj jx lm jm jn jz ln jq jr js hn dt translated">函数对于Javascript的工作方式至关重要。这篇博客文章不可能涉及Javascript函数的每一个方面，但是我会提到使Javascript更有用的要素。你会在这篇文章的末尾找到一个链接，它会把你重定向到一个非常全面的函数资源。</p><p id="bb05" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jv jh ji jj jx jl jm jn jz jp jq jr js hn dt translated">它们提供了一组可重用的代码，可以在程序中的任何地方调用。函数可以适用于各种上下文，范围可以被封装和保留。它们的行为不同于你可能知道的其他语言，它们的命名有特定的顺序。Javascript函数既可以用作函数，也可以用作对象。Javascript函数可以是:</p><ul class=""><li id="2a5e" class="jt ju hu ix b iy iz jc jd jv jw jx jy jz ka js lo kc kd ke dt translated">正常函数构造</li><li id="1bd9" class="jt ju hu ix b iy kg jc kh jv ki jx kj jz kk js lo kc kd ke dt translated">匿名函数</li><li id="1278" class="jt ju hu ix b iy kg jc kh jv ki jx kj jz kk js lo kc kd ke dt translated">或带有指定变量的普通函数</li></ul><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="3592" class="ly km hu lu b fv lz ma l mb mc">// Normal function construct function<br/><strong class="lu hv">function </strong>myFunction(arguments){<br/>    // some code<br/>};</span><span id="2167" class="ly km hu lu b fv md ma l mb mc">// An anonymous function<br/>myFunction = <strong class="lu hv">function </strong>(arguments) {<br/>    // some code<br/>};</span><span id="bb9d" class="ly km hu lu b fv md ma l mb mc">// A normal function construct with an assigned variable<br/>myFunction = <strong class="lu hv">function </strong>myFunction(arguments) {<br/>    // some code<br/>};</span></pre><p id="0cb8" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jv jh ji jj jx jl jm jn jz jp jq jr js hn dt translated">我很确定你至少已经看过其中一部了？如果是这样，你应该了解他们的背景和行为。</p><h1 id="0e78" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">Javascript上下文</h1><p id="7f44" class="pw-post-body-paragraph iu iv hu ix b iy lj ja jb jc lk je jf jv ll ji jj jx lm jm jn jz ln jq jr js hn dt translated">有些应用程序希望您在语句中声明函数。这不是很常见，但当你这样做时，使用下面的例子作为样板。目前所有使用指定匿名函数的浏览器都支持这一点，这是达到预期效果的正确方法:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="ead3" class="ly km hu lu b fv lz ma l mb mc"><strong class="lu hv">var </strong>functionName; <br/><br/><strong class="lu hv">if</strong>( someCondition ) { <br/>    functionName = <strong class="lu hv">function </strong>() { ... }; <br/>}</span></pre><p id="bbb2" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jv jh ji jj jx jl jm jn jz jp jq jr js hn dt translated">这些函数可以在需要时被调用，其中包含的代码将会运行。调用函数通常有以下方法:</p><ul class=""><li id="4db4" class="jt ju hu ix b iy iz jc jd jv jw jx jy jz ka js lo kc kd ke dt translated">myFunction(变量列表)；</li><li id="bbe6" class="jt ju hu ix b iy kg jc kh jv ki jx kj jz kk js lo kc kd ke dt translated">window.myFunction(变量列表)；</li><li id="fca1" class="jt ju hu ix b iy kg jc kh jv ki jx kj jz kk js lo kc kd ke dt translated">object.onEventName = myFunction</li></ul><p id="0d4d" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jv jh ji jj jx jl jm jn jz jp jq jr js hn dt translated">我已经数不清我面试过的JavaScript开发人员中有多少人不能告诉我函数声明和函数表达式之间的区别，有多少人不知道什么是直接调用的函数表达式。我不是在咆哮，但我确实是:D</p><h1 id="0a97" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">自调用Javascript函数</h1><p id="eca2" class="pw-post-body-paragraph iu iv hu ix b iy lj ja jb jc lk je jf jv ll ji jj jx lm jm jn jz ln jq jr js hn dt translated">Javascript中使用的一种模式是所谓的自调用函数。自调用匿名函数在运行时创建时会立即运行。为了让您知道这是什么样子，下面是包装一些代码的自执行匿名函数的格式:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="d0b8" class="ly km hu lu b fv lz ma l mb mc">(<strong class="lu hv">function</strong>(){<br/>    // some code…<br/>})();</span></pre><p id="2138" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jv jh ji jj jx jl jm jn jz jp jq jr js hn dt translated">有趣的是，如果你查看jQuery 的<a class="ae kf" href="http://code.jquery.com/jquery-1.4.4.js" rel="noopener ugc nofollow" target="_blank">源代码，你会发现所有的东西都被包裹在中间，以便建立一个新的上下文:</a></p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="186b" class="ly km hu lu b fv lz ma l mb mc">(<strong class="lu hv">function</strong>( window, undefined ) {<br/>    // jQuery code<br/>})(window);</span></pre><p id="f90e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jv jh ji jj jx jl jm jn jz jp jq jr js hn dt translated">如果您想要重复运行一段代码，或者想要建立一个新的作用域。如果您使用的其他插件和Javascript供应商文件也可能使用您的变量，并干扰您的全局名称空间，那么新的作用域就很重要。假设我们在全局范围内有一个变量，只需调用它就可以访问它:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="7223" class="ly km hu lu b fv lz ma l mb mc">// app.js<br/><strong class="lu hv">var </strong>myVariable = ['this','is','my','message'];<br/><br/>// another.js<br/><strong class="lu hv">if</strong>(myVariable){ // true<br/>    console.log('your var is global');<br/>}</span></pre><p id="a743" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jv jh ji jj jx jl jm jn jz jp jq jr js hn dt translated">这实际上不被认为是最佳实践。myVariable将被添加到窗口范围，并在应用程序的所有其他文件中可见。你想为每个文件做的是，你想通过使用自envoking函数为你的var建立一个作用域。让我们尝试一下:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="c2a4" class="ly km hu lu b fv lz ma l mb mc">(<strong class="lu hv">function</strong>(){ <br/>    <strong class="lu hv">var </strong>myVariable = ['this','is','my','message']; <br/>})(); <br/><br/>// another.js <br/><strong class="lu hv">if</strong>(myVariable){ // false because it it undefined <br/>    console.log('your var is global'); <br/>}</span></pre><p id="9087" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jv jh ji jj jx jl jm jn jz jp jq jr js hn dt translated">要解决这个问题，您可以使用一个自执行匿名函数，并为此变量创建一个封装的上下文。所以让我们稍微重构一下这个函数，给大家展示一些有趣的东西。如果你知道Javascript在这种情况下做了什么，那才是有趣的。</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="b6c7" class="ly km hu lu b fv lz ma l mb mc">(<strong class="lu hv">function</strong>(){ <br/>    <strong class="lu hv">var </strong>myVariable = ['this','is','my','message'];<br/>    <strong class="lu hv">for</strong>(<strong class="lu hv">var </strong>i <strong class="lu hv">in </strong>myVariable) { <br/>        setTimeout(<strong class="lu hv">function </strong>() { <br/>            // will be exectured delayed by 10 milliseconds <br/>            console.log(myVariable[i]);<br/>            // output: message message message message <br/>        },10); <br/>    } <br/>})();</span></pre><p id="0358" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jv jh ji jj jx jl jm jn jz jp jq jr js hn dt translated">那么这里发生了什么？它实际上打印消息四次。所以人们可能会想，让我们把setTimeout时间降低到1，每次你打印它，它都会从数组中返回正确的句子，而不是。setTimeout延迟了执行，因此，当它被调用时，我已经是“message”了，或者是3，因为我们正在处理一个数组。</p><p id="6bac" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jv jh ji jj jx jl jm jn jz jp jq jr js hn dt translated">为了向你展示如何解决这个问题，我们必须以一种不太直观的方式重构这个函数。</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="0666" class="ly km hu lu b fv lz ma l mb mc">(<strong class="lu hv">function</strong>(){<br/>    <strong class="lu hv">var </strong>myVariable = ['this','is','my','message'];<br/>    <br/>    <strong class="lu hv">var </strong>say = <strong class="lu hv">function </strong>(i) { // the variable i will<br/>        setTimeout(<strong class="lu hv">function </strong>() {<br/>            console.log(myVariable[i]); <br/>            // output: message message message message<br/>        },10);<br/>    };<br/>    <br/>    // So by the time i is executed it is no longer referring <br/>    // to this i in the for loop it is referring to the <br/>    // scoped i inside the say function<br/>    <strong class="lu hv">for</strong>(<strong class="lu hv">var </strong>i <strong class="lu hv">in </strong>myVariable)<br/>    {<br/>        say(i); // output: this is my message<br/>    }<br/>})();</span></pre><p id="3be8" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jv jh ji jj jx jl jm jn jz jp jq jr js hn dt translated">此时，您实际上拥有的是一个作用域中的封装作用域。记住，当你调用这个函数的时候，我会把它交给这个函数，并创建一个新的函数作用域。所以当函数被调用时，I不再引用for循环中的I。它指的是索引。这在Javascript中是一个非常强大的概念，可以创建一个独立的上下文。如果你过去遇到过这个问题，请在评论区告诉我。</p><h1 id="4f88" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">闭合模式</h1><p id="24db" class="pw-post-body-paragraph iu iv hu ix b iy lj ja jb jc lk je jf jv ll ji jj jx lm jm jn jz ln jq jr js hn dt translated">我们有一个引用了函数外部变量的函数。让我们重构最后一个例子，使它成为一个闭包，并使它在这个上下文中工作。</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="ab71" class="ly km hu lu b fv lz ma l mb mc">(<strong class="lu hv">function</strong>(){<br/>    <strong class="lu hv">var </strong>myVariable = ['this','is','my','message'];</span><span id="017e" class="ly km hu lu b fv md ma l mb mc"><strong class="lu hv">    var </strong>say = <strong class="lu hv">function </strong>(i) { // the variable i will scoped<br/>        <strong class="lu hv">return function </strong>() {<br/>            console.log(myVariable[i]); <br/>            // Will be called later.<br/>        };<br/>    };</span><span id="f6c2" class="ly km hu lu b fv md ma l mb mc">    // So by the time i is executed it is no longer referring <br/>    // to this i in the for loop it is referring to the <br/>    // scoped i inside the say function<br/>    <strong class="lu hv">for</strong>(<strong class="lu hv">var </strong>i <strong class="lu hv">in </strong>myVariable)<br/>    {<br/>        setTimeout(say(i),1000); // output: this is my message<br/>    }<br/>})();</span></pre><p id="cb71" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jv jh ji jj jx jl jm jn jz jp jq jr js hn dt translated">这个概念是闭包函数的常见模式。闭包是一个包装函数，它捕获一个参数，而参数捕获函数内部的上下文。这个函数然后返回另一个函数，这个函数的唯一目的是在以后被调用。它利用在其作用域中初始化的参数。这是强大的，但你要学习它，直到你得到它的权利。这让我们想到了另一种常见的模式，称为模块模式。</p><h1 id="c626" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">模块模式</h1><p id="9f2b" class="pw-post-body-paragraph iu iv hu ix b iy lj ja jb jc lk je jf jv ll ji jj jx lm jm jn jz ln jq jr js hn dt translated">当您想要封装私有函数和变量来访问时，这种模式非常有用。此外，模块模式公开了一个公共api，您可以使用它来工作和构建您的应用程序。让我们看一个模块模式的好例子:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="f578" class="ly km hu lu b fv lz ma l mb mc"><strong class="lu hv">var </strong>MODULE = (<strong class="lu hv">function </strong>() {<br/>    <strong class="lu hv">var </strong>privateVariable = 1;<br/><br/>    <strong class="lu hv">function </strong>privateMethod() {<br/>        // do something in here<br/>    }<br/><br/>    <strong class="lu hv">return </strong>{<br/>        moduleProperty:1,<br/>        moduleMethod:<strong class="lu hv">function </strong>() {<br/>            <em class="iw">/**<br/>             * A function that can utilizes a private method<br/>             * or a private variable.<br/>             */<br/>        </em>}<br/>    };<br/>}());</span></pre><p id="62b3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jv jh ji jj jx jl jm jn jz jp jq jr js hn dt translated">注意，我们已经声明了一个名为module的全局模块，它有两个公共属性:一个名为MODULE.moduleMethod的方法和一个名为MODULE.moduleProperty的变量。此外，我们可以使用上面学到的模式轻松导入所需的全局变量。这种模式在构建插件时被大量使用，并且很容易转换成另一种叫做CommonJS的模式。</p><h1 id="9e72" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">CommonJS</h1><p id="54a2" class="pw-post-body-paragraph iu iv hu ix b iy lj ja jb jc lk je jf jv ll ji jj jx lm jm jn jz ln jq jr js hn dt translated">当我们说一个应用程序是<strong class="ix hv">模块化</strong>时，我们通常指的是它由一组存储在模块中的高度解耦的不同功能组成。你可能知道，<a class="ae kf" href="http://arguments.callee.info/2009/05/18/javascript-design-patterns--mediator/" rel="noopener ugc nofollow" target="_blank">松耦合</a>通过尽可能移除<em class="iw">依赖</em>来简化应用程序的可维护性。</p><p id="7c87" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jv jh ji jj jx jl jm jn jz jp jq jr js hn dt translated">CommonJS模块提案指定了一个简单的API，用于在服务器端声明模块，与AMD不同，它试图覆盖更广泛的关注点，如io、文件系统、承诺等等。</p><p id="834a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jv jh ji jj jx jl jm jn jz jp jq jr js hn dt translated">CommonJS Javascript在NodeJS中被大量使用。因此，如果您正在进行大量的NodeJS开发，您会经常看到这种情况。本质上，你所做的是将类接口分配给一个module.export。为了完成这项工作，你不需要一个自动执行的匿名函数。让我们去掉多余的圆括号:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="ee21" class="ly km hu lu b fv lz ma l mb mc"><em class="iw">/**<br/> * Define more behaviour we would like to expose.<br/> * And expose foobar to other modules as well.<br/> */<br/></em>exports.myFunction = <strong class="lu hv">function </strong>myFunction(){<br/>    <strong class="lu hv">this</strong>.one = <strong class="lu hv">function</strong>(){<br/>        console.log('Hello one');<br/>    }<br/><br/>    <strong class="lu hv">this</strong>.two = <strong class="lu hv">function</strong>(){<br/>        console.log('Hello two');<br/>    }<br/>}<br/><br/><em class="iw">/**<br/> * Access the module relative to the path where both usage<br/> * and module files exist in the same directory.<br/> * </em><strong class="lu hv"><em class="iw">@type </em></strong><em class="iw">{exports.</em>myFunction<em class="iw">|*}<br/> */<br/></em><strong class="lu hv">var </strong>myFunction = require('./myFunction').myFunction,<br/>    test   = <strong class="lu hv">new </strong>myFunction();</span><span id="4d55" class="ly km hu lu b fv md ma l mb mc"><em class="iw">/**<br/> * Make use of exported variables<br/> */<br/></em>test.two(); // output 'Hello two'</span></pre><p id="c6e6" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jv jh ji jj jx jl jm jn jz jp jq jr js hn dt translated">作为一个<strong class="ix hv">很好的练习建议</strong>，当你在处理函数的时候。不要使用匿名函数。原因是，假设你必须调试精简的代码，并且要处理大量的匿名函数。你很可能会认输，从头开始。太痛苦了！</p><p id="d5a5" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jv jh ji jj jx jl jm jn jz jp jq jr js hn dt translated">我相信关于函数这就足够了，因为在其他地方已经讨论了很多。所以看看下面的链接，我将继续第四部分，包括“这个”关键字和范围。</p><p id="2c6a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jv jh ji jj jx jl jm jn jz jp jq jr js hn dt translated">电子邮件—michel.herszak@gmail.com</p><p id="05e5" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jv jh ji jj jx jl jm jn jz jp jq jr js hn dt translated">推特—@ MHerszak(twitter.com/MHerszak)</p><p id="329f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jv jh ji jj jx jl jm jn jz jp jq jr js hn dt translated">想知道我的工作方式吗？很好，你可以从我如何着手一个项目的概述开始<a class="ae kf" href="http://base2industries.com/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="f582" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jv jh ji jj jx jl jm jn jz jp jq jr js hn dt translated">关于Javascript函数各个方面的综合博文将在<a class="ae kf" href="http://ryanmorr.com/understanding-scope-and-context-in-javascript/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。确实非常好！</p><p id="5e36" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jv jh ji jj jx jl jm jn jz jp jq jr js hn dt translated">CommonJS模式的服务器端用法:</p><ul class=""><li id="82bf" class="jt ju hu ix b iy iz jc jd jv jw jx jy jz ka js lo kc kd ke dt translated">http://nodejs.org<a class="ae kf" href="http://nodejs.org/" rel="noopener ugc nofollow" target="_blank">节点</a></li><li id="81fd" class="jt ju hu ix b iy kg jc kh jv ki jx kj jz kk js lo kc kd ke dt translated">独角鲸<a class="ae kf" href="https://github.com/tlrobinson/narwhal" rel="noopener ugc nofollow" target="_blank">https://github.com/tlrobinson/narwhal</a></li></ul></div><div class="ab cl me mf hc mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hn ho hp hq hr"><p id="f12c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jv jh ji jj jx jl jm jn jz jp jq jr js hn dt translated"><em class="iw">原载于2015年12月21日</em><a class="ae kf" href="http://www.browserstudios.com/2015/12/21/javascript%E2%80%8A-%E2%80%8Aa-sneak-peak-into-the-essentials-part-3/" rel="noopener ugc nofollow" target="_blank"><em class="iw">www.browserstudios.com</em></a><em class="iw">。</em></p></div></div>    
</body>
</html>