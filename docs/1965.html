<html>
<head>
<title>[Javascript] ES7 Async Await BIBLE</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[Javascript] ES7异步等待圣经</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/javascript-es7-async-await-bible-tutorial-example-32294f6133ab?source=collection_archive---------1-----------------------#2016-12-26">https://medium.com/hackernoon/javascript-es7-async-await-bible-tutorial-example-32294f6133ab?source=collection_archive---------1-----------------------#2016-12-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/0888f18994134699ca8d258dfd69cb00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*SQylaaGb9juNEj_0KG-CSA.jpeg"/></div></figure><h2 id="a504" class="iy iz hu bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">8个必须知道的例子:</h2><ol class=""><li id="dfbb" class="jw jx hu jy b jz ka kb kc jj kd jn ke jr kf kg kh ki kj kk dt translated">异步函数对象</li><li id="8675" class="jw jx hu jy b jz kl kb km jj kn jn ko jr kp kg kh ki kj kk dt translated">承诺函数</li><li id="4f90" class="jw jx hu jy b jz kl kb km jj kn jn ko jr kp kg kh ki kj kk dt translated">异步功能</li><li id="a3f2" class="jw jx hu jy b jz kl kb km jj kn jn ko jr kp kg kh ki kj kk dt translated">依次等待</li><li id="ef1b" class="jw jx hu jy b jz kl kb km jj kn jn ko jr kp kg kh ki kj kk dt translated">并行等待</li><li id="1559" class="jw jx hu jy b jz kl kb km jj kn jn ko jr kp kg kh ki kj kk dt translated">等待嵌套</li><li id="f7d8" class="jw jx hu jy b jz kl kb km jj kn jn ko jr kp kg kh ki kj kk dt translated">动态等待</li><li id="7ed4" class="jw jx hu jy b jz kl kb km jj kn jn ko jr kp kg kh ki kj kk dt translated">错误句柄</li></ol><h2 id="ee24" class="iy iz hu bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">注意</h2><p id="6c0c" class="pw-post-body-paragraph kq kr hu jy b jz ka ks kt kb kc ku kv jj kw kx ky jn kz la lb jr lc ld le kg hn dt translated"><em class="lf"> —要在Node.js上运行ES7，请阅读:</em> <a class="ae lg" href="https://hackernoon.com/nodejs-bbb-babel-burger-boilerplate-b74107eff049#.5x9fvu8ji" rel="noopener ugc nofollow" target="_blank"> BBB，Babel Burger Boilerplat </a> e</p><blockquote class="lh"><p id="2505" class="li lj hu bd lk ll lm ln lo lp lq kg ek translated">在ES5时代之前，JavaScripters们生活在回调地狱中。调试是一项疯狂的工作，被成千上万的回调函数窒息。在后来的时间里，承诺来拯救我们，它的魔力把地狱变成了一个扁平的结构，隧道尽头的一盏灯。今天，Async Await是这一承诺的化身。ES7。</p></blockquote><figure class="ls lt lu lv lw iv fe ff paragraph-image"><div class="fe ff lr"><img src="../Images/0a7feb941fb5687e033aef9e8203e04b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*ko3KtcVSlzpe3RnTRgJaHw.jpeg"/></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">Chronological Picture</figcaption></figure><h1 id="9485" class="mb iz hu bd ja mc md me je mf mg mh ji mi mj mk jm ml mm mn jq mo mp mq ju mr dt translated">1-异步的构造函数:<a class="ae lg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction" rel="noopener ugc nofollow" target="_blank"> asyncFunction </a></h1><p id="b303" class="pw-post-body-paragraph kq kr hu jy b jz ka ks kt kb kc ku kv jj kw kx ky jn kz la lb jr lc ld le kg hn dt translated">AsyncFunction构造函数创建一个新的异步函数对象。在JavaScript中，每个异步函数实际上都是一个Async function对象。来自Mozilla :</p><pre class="ms mt mu mv fq mw mx my mz aw na dt"><span id="52d9" class="iy iz hu mx b fv nb nc l nd ne">//Node.js<br/>console.log(async function () {});</span><span id="c7a9" class="iy iz hu mx b fv nf nc l nd ne">// Chrome or Firefox<br/>console.log(async function () {}.constructor);<br/>console.log(async function () {}.__proto__);</span></pre><p id="d6e2" class="pw-post-body-paragraph kq kr hu jy b jz ng ks kt kb nh ku kv jj ni kx ky jn nj la lb jr nk ld le kg hn dt translated">(感谢<a class="nl nm gr" href="https://medium.com/u/cad910df79a0?source=post_page-----32294f6133ab--------------------------------" rel="noopener" target="_blank">阿尔宾·拉尔森</a>的更正)</p><p id="dc18" class="pw-post-body-paragraph kq kr hu jy b jz ng ks kt kb nh ku kv jj ni kx ky jn nj la lb jr nk ld le kg hn dt translated">谁知道非功能性和承诺的兄弟姐妹？如果不是，则不允许跳过，因为这是ES6的承诺函数支持await的原因，也是Async await如何应用承诺特性的原因，例如<em class="lf">解析并行</em>和<em class="lf">错误处理</em>:</p><pre class="ms mt mu mv fq mw mx my mz aw na dt"><span id="467b" class="iy iz hu mx b fv nb nc l nd ne">function(){<br/>  ...<br/>  return new <strong class="mx hv"><em class="lf">Promise</em></strong>(function(resolve, reject) {<br/>    ...<br/>  })<br/>  ...<br/>}</span></pre><h1 id="f07c" class="mb iz hu bd ja mc md me je mf mg mh ji mi mj mk jm ml mm mn jq mo mp mq ju mr dt translated">2-构造承诺函数</h1><p id="2287" class="pw-post-body-paragraph kq kr hu jy b jz ka ks kt kb kc ku kv jj kw kx ky jn kz la lb jr lc ld le kg hn dt translated">为什么我们在这里讨论承诺函数？因为人们可能忽略了Async await的基础是承诺，所以我们创建的每一个Async函数和我们等待的每一件事都会自然而然地成为承诺。</p><p id="eb3e" class="pw-post-body-paragraph kq kr hu jy b jz ng ks kt kb nh ku kv jj ni kx ky jn nj la lb jr nk ld le kg hn dt translated"><strong class="jy hv"> <em class="lf">举例(感谢</em> </strong> <a class="nl nm gr" href="https://medium.com/u/423e5feec011?source=post_page-----32294f6133ab--------------------------------" rel="noopener" target="_blank"> <strong class="jy hv"> <em class="lf">乔特曼演唱</em> </strong> </a> <strong class="jy hv"> <em class="lf">的建议):</em> </strong></p><pre class="ms mt mu mv fq mw mx my mz aw na dt"><span id="c689" class="iy iz hu mx b fv nb nc l nd ne">(async function() {</span><span id="22c4" class="iy iz hu mx b fv nf nc l nd ne">var sleep = function(para) {<br/>    return new Promise(function(resolve, reject) {<br/>        setTimeout(function() {<br/>            resolve(para * para)<br/>        }, 1000)<br/>    })<br/>  }</span><span id="5e2f" class="iy iz hu mx b fv nf nc l nd ne">var result = await sleep(2)<br/>  // result is 4</span><span id="8522" class="iy iz hu mx b fv nf nc l nd ne">})();</span></pre><h1 id="79b8" class="mb iz hu bd ja mc md me je mf mg mh ji mi mj mk jm ml mm mn jq mo mp mq ju mr dt translated">3-构造异步函数</h1><p id="cfc9" class="pw-post-body-paragraph kq kr hu jy b jz ka ks kt kb kc ku kv jj kw kx ky jn kz la lb jr lc ld le kg hn dt translated"><code class="eh nn no np mx b"><strong class="jy hv">async function</strong></code>声明定义了一个<em class="lf">异步函数</em>，它返回一个<code class="eh nn no np mx b"><a class="ae lg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction" rel="noopener ugc nofollow" target="_blank">AsyncFunction</a></code>对象(也是一个承诺)。当异步函数返回值时，将使用返回值解析承诺。当async函数抛出异常或某个值时，promise将被抛出的值拒绝(<a class="ae lg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank"> Mozilla </a>)。</p><p id="8a80" class="pw-post-body-paragraph kq kr hu jy b jz ng ks kt kb nh ku kv jj ni kx ky jn nj la lb jr nk ld le kg hn dt translated"><strong class="jy hv"> <em class="lf">举例:</em> </strong></p><pre class="ms mt mu mv fq mw mx my mz aw na dt"><span id="44b6" class="iy iz hu mx b fv nb nc l nd ne">async function asyncSleep (para){<br/> return await sleep(para)<br/>}</span><span id="b5d8" class="iy iz hu mx b fv nf nc l nd ne">var result = await asyncSleep(2)<br/>//result is 4</span><span id="037f" class="iy iz hu mx b fv nf nc l nd ne">asyncSleep(3).then(function(result2){<br/>//result2 is 9<br/>})</span></pre><h1 id="2e68" class="mb iz hu bd ja mc md me je mf mg mh ji mi mj mk jm ml mm mn jq mo mp mq ju mr dt translated">4-顺序等待</h1><p id="bb9f" class="pw-post-body-paragraph kq kr hu jy b jz ka ks kt kb kc ku kv jj kw kx ky jn kz la lb jr lc ld le kg hn dt translated"><strong class="jy hv"> <em class="lf">例如:</em> </strong></p><pre class="ms mt mu mv fq mw mx my mz aw na dt"><span id="5e31" class="iy iz hu mx b fv nb nc l nd ne">var result1 = await sleep(2);<br/>var result2 = await sleep(result1);<br/>var result3 = await sleep(result2);</span><span id="9e8a" class="iy iz hu mx b fv nf nc l nd ne">//result1 is 4<br/>//result2 is 16<br/>//result3 is 256</span></pre><h1 id="c17b" class="mb iz hu bd ja mc md me je mf mg mh ji mi mj mk jm ml mm mn jq mo mp mq ju mr dt translated">5-并行等待</h1><p id="ea57" class="pw-post-body-paragraph kq kr hu jy b jz ka ks kt kb kc ku kv jj kw kx ky jn kz la lb jr lc ld le kg hn dt translated"><strong class="jy hv"> <em class="lf">举例:</em> </strong></p><pre class="ms mt mu mv fq mw mx my mz aw na dt"><span id="8f71" class="iy iz hu mx b fv nb nc l nd ne">var results = await Promise.all([sleep(1), sleep(2)]);<br/>//results is [1,4]</span></pre><h1 id="0ccc" class="mb iz hu bd ja mc md me je mf mg mh ji mi mj mk jm ml mm mn jq mo mp mq ju mr dt translated">六窝</h1><p id="69ff" class="pw-post-body-paragraph kq kr hu jy b jz ka ks kt kb kc ku kv jj kw kx ky jn kz la lb jr lc ld le kg hn dt translated"><strong class="jy hv"> <em class="lf">例如:</em> </strong></p><pre class="ms mt mu mv fq mw mx my mz aw na dt"><span id="3cff" class="iy iz hu mx b fv nb nc l nd ne">// iterator of objects<br/>//<!-- --> for (let thing of things) {</span><span id="e855" class="iy iz hu mx b fv nf nc l nd ne">for(var i =0 ; i&lt;3; i++){<br/>    var result = await sleep(i);</span><span id="bf63" class="iy iz hu mx b fv nf nc l nd ne">for(var j =0 ; j&lt;result; j++){<br/>        console.log('   i:'+i+', j:'+j+': ', await sleep(j));<br/>    }<br/>}</span><span id="060a" class="iy iz hu mx b fv nf nc l nd ne">// i:1, j:0:  0<br/>// i:2, j:0:  0<br/>// i:2, j:1:  1<br/>// i:2, j:2:  4<br/>// i:2, j:3:  9</span></pre><h1 id="935d" class="mb iz hu bd ja mc md me je mf mg mh ji mi mj mk jm ml mm mn jq mo mp mq ju mr dt translated">7-动态异步函数</h1><blockquote class="lh"><p id="366f" class="li lj hu bd lk ll lm ln lo lp lq kg ek translated">JavaScripters爱好者们，是时候承认了:我们在承诺方面有问题。</p></blockquote><p id="af58" class="pw-post-body-paragraph kq kr hu jy b jz nq ks kt kb nr ku kv jj ns kx ky jn nt la lb jr nu ld le kg hn dt translated">我很赞同<a class="ae lg" href="https://twitter.com/nolanlawson" rel="noopener ugc nofollow" target="_blank"> <em class="lf">诺兰·劳森</em> </a> <em class="lf">的</em>引用<em class="lf">的话。</em>动态<em class="lf"> </em>承诺数组是在处理未知进程、动态问题时需要用到的。对于这个问题，我的直觉是将所有的Promise函数放入一个数组中，然后依次等待它们。但是当我发现Promise函数在被声明的时候就执行了，这被证明是不正确的。我的结论是，用承诺解决问题，不要相信人的本能。</p><p id="3371" class="pw-post-body-paragraph kq kr hu jy b jz ng ks kt kb nh ku kv jj ni kx ky jn nj la lb jr nk ld le kg hn dt translated">这种方法是将参数和承诺分开存储(这里使用的是map对象)</p><p id="77ba" class="pw-post-body-paragraph kq kr hu jy b jz ng ks kt kb nh ku kv jj ni kx ky jn nj la lb jr nk ld le kg hn dt translated"><strong class="jy hv"> <em class="lf">举例:</em> </strong></p><pre class="ms mt mu mv fq mw mx my mz aw na dt"><span id="de7b" class="iy iz hu mx b fv nb nc l nd ne">var sleep = function(para1,para2) {<br/>    var _para1 = para1, _para2 = para2 || para1 ;<br/>    return new Promise(function(resolve, reject) {<br/>        setTimeout(function() {<br/>            resolve(_para1 * _para2)<br/>        }, 1000)<br/>    })<br/>}</span><span id="e024" class="iy iz hu mx b fv nf nc l nd ne">var proMap = new Map();<br/>proMap.set([1], sleep);<br/>proMap.set([2, 3], sleep);<br/>proMap.set([3], sleep);</span><span id="8a24" class="iy iz hu mx b fv nf nc l nd ne">for (var [para, fun] of proMap.entries()) {<br/>    var result = await fun.apply(this, para);<br/>    console.log(para, result)<br/>}</span><span id="c95f" class="iy iz hu mx b fv nf nc l nd ne">//[ 1 ] 1<br/>//[ 2, 3 ] 6<br/>//[ 3 ] 9</span></pre><h1 id="932c" class="mb iz hu bd ja mc md me je mf mg mh ji mi mj mk jm ml mm mn jq mo mp mq ju mr dt translated">8-错误句柄</h1><blockquote class="lh"><p id="69c2" class="li lj hu bd lk ll lm ln lo lp lq kg ek translated">在一个<code class="eh nn no np mx b">async</code>函数中，错误被“悄悄地”吞下——就像在正常的承诺中一样。</p></blockquote><p id="3ad1" class="pw-post-body-paragraph kq kr hu jy b jz nq ks kt kb nr ku kv jj ns kx ky jn nt la lb jr nu ld le kg hn dt translated"><strong class="jy hv">异步</strong>和<strong class="jy hv">承诺</strong>中的错误处理来自同一个母体，它们都需要try/catch，以便在异步函数中捕获并处理等待的承诺中的错误。</p><p id="1601" class="pw-post-body-paragraph kq kr hu jy b jz ng ks kt kb nh ku kv jj ni kx ky jn nj la lb jr nk ld le kg hn dt translated"><strong class="jy hv"> <em class="lf">例如:</em> </strong></p><pre class="ms mt mu mv fq mw mx my mz aw na dt"><span id="591b" class="iy iz hu mx b fv nb nc l nd ne">var errorSleep = function(para) {<br/>    return new Promise(function(resolve, reject) {<br/>        setTimeout(function() {<br/>            reject(' ErrorSleep')<br/>        }, 1000)<br/>    })<br/>}</span><span id="aeb8" class="iy iz hu mx b fv nf nc l nd ne"><strong class="mx hv"><em class="lf">try {<br/></em></strong>    var result1 = await sleep(1);<br/>    var result2 = await errorSleep(4);<br/>    var result3 = await sleep(1);</span><span id="7306" class="iy iz hu mx b fv nf nc l nd ne">console.log('result1: ', result1)<br/>    console.log('result2: ', result2)<br/>    console.log('result3: ', result3)<br/><strong class="mx hv"><em class="lf">} catch (err) {<br/></em></strong>    console.log('err: ', err)<br/>    console.log('result1: ', result1)<br/>    console.log('result2: ', result2)<br/>    console.log('result3: ', result3)<br/><strong class="mx hv"><em class="lf">}</em></strong></span><span id="930d" class="iy iz hu mx b fv nf nc l nd ne">//err:   ErrorSleep<br/>//result1:  1<br/>//result2:  undefined<br/>//result3:  undefined</span></pre><h1 id="f7ff" class="mb iz hu bd ja mc md me je mf mg mh ji mi mj mk jm ml mm mn jq mo mp mq ju mr dt translated">总结:</h1><p id="db50" class="pw-post-body-paragraph kq kr hu jy b jz ka ks kt kb kc ku kv jj kw kx ky jn kz la lb jr lc ld le kg hn dt nv translated">对于nodejs和浏览器程序员来说，ood，async/await都是一个很好的语法改进。与承诺相比，这是到达同一个目的地的捷径。它帮助开发人员用JavaScript实现函数式编程，增加代码可读性，使JavaScript更有趣。</p><p id="205c" class="pw-post-body-paragraph kq kr hu jy b jz ng ks kt kb nh ku kv jj ni kx ky jn nj la lb jr nk ld le kg hn dt nv translated"><span class="l nw nx ny bm nz oa ob oc od di"> B </span> ad，正如在第7和第8部分中提到的，Promise在动态生成实例和解析实例方面有问题，并且当发现意外异常时，await应该给Javascripter程序一个更大的声音。</p></div><div class="ab cl oe of hc og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="hn ho hp hq hr"><p id="c96f" class="pw-post-body-paragraph kq kr hu jy b jz ng ks kt kb nh ku kv jj ni kx ky jn nj la lb jr nk ld le kg hn dt translated">喜欢这个故事？对别人有帮助吗？它帮助我知道你是否想看到更多关于他的话题，并帮助人们看到这个故事，<strong class="jy hv"> <em class="lf">当点击下面的心</em> </strong>。</p><h1 id="6218" class="mb iz hu bd ja mc md me je mf mg mh ji mi mj mk jm ml mm mn jq mo mp mq ju mr dt translated">参考:</h1><p id="ed30" class="pw-post-body-paragraph kq kr hu jy b jz ka ks kt kb kc ku kv jj kw kx ky jn kz la lb jr lc ld le kg hn dt translated">Mozilla:<br/><a class="ae lg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/async function</a></p><p id="aaf1" class="pw-post-body-paragraph kq kr hu jy b jz ng ks kt kb nh ku kv jj ni kx ky jn nj la lb jr nk ld le kg hn dt translated">尼古拉斯·贝瓦夸<br/><a class="ae lg" href="https://ponyfoo.com/articles/understanding-javascript-async-await" rel="noopener ugc nofollow" target="_blank">https://pony foo . com/articles/understanding-JavaScript-async-await</a></p><p id="12ed" class="pw-post-body-paragraph kq kr hu jy b jz ng ks kt kb nh ku kv jj ni kx ky jn nj la lb jr nk ld le kg hn dt translated"><a class="ae lg" href="https://twitter.com/nolanlawson" rel="noopener ugc nofollow" target="_blank">诺兰·劳森</a><br/><a class="ae lg" href="https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html" rel="noopener ugc nofollow" target="_blank">https://pouchdb . com/2015/05/18/we-have-a-problem-with-promises . html</a></p></div></div>    
</body>
</html>