<html>
<head>
<title>Aspect Oriented Programming in Javascript (ES5+\Typescript)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript中面向方面的编程(ES5+\Typescript)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/aspect-oriented-programming-in-javascript-es5-typescript-d751dda576d0?source=collection_archive---------3-----------------------#2017-03-21">https://medium.com/hackernoon/aspect-oriented-programming-in-javascript-es5-typescript-d751dda576d0?source=collection_archive---------3-----------------------#2017-03-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="9845" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在过去的8年里，世界发展得非常快。但是我们陷入了一些问题，我将在本文中尝试解释这些问题并提供解决方案。</p><p id="3783" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">OOP试图通过将关注点分离到不同的实体中来面对开发过程。解构问题域是组织我们的代码所必须的。同样使用SRP ( <a class="ae jp" href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">单责任原则</strong> </a>)和IoC ( <a class="ae jp" href="https://en.wikipedia.org/wiki/Inversion_of_control" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">反转控制</strong> </a>)。</p><p id="54a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://en.wikipedia.org/wiki/Object-oriented_programming#Criticism" rel="noopener ugc nofollow" target="_blank">但是有时候OOP是不够的</a>。通常，我们习惯于复制和粘贴代码块来使事情工作。我希望你同意我说的，这是丑陋的，不容易阅读。</p><p id="1bce" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有多少次你试图弄清楚“这个方法到底是做什么的？?"因为基础设施代码分散在各处，隐藏了真正的目的，不是吗？：</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="jv jw l"/></div></figure><p id="fd97" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上面提到的。该方法(::doCheckout)的目的是将shippingDetails分配给实例属性，然后将其发送到服务器。为了实现这一点，现在我们习惯于编写基础设施代码，例如验证方法参数，然后发出AJAX请求(<em class="jx">从其他地方复制并粘贴代码，并更改一些变量……</em>)等等。</p><p id="133a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你每次面对这种情况都要重复这一点，那你就没有尽力。</p><blockquote class="jy jz ka"><p id="4b69" class="ir is jx it b iu iv iw ix iy iz ja jb kb jd je jf kc jh ji jj kd jl jm jn jo hn dt translated">较少的代码比干净的代码更好</p></blockquote><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="jv jw l"/></div></figure><p id="af54" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然，这只是一个例子，现实世界的问题并不简单。我们想实现这一点，不是吗？(<a class="ae jp" href="https://github.com/k1r0s/kaop-ts" rel="noopener ugc nofollow" target="_blank">跳到库</a>)</p></div><div class="ab cl ke kf hc kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hn ho hp hq hr"><h1 id="1f21" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">AOP简介</h1><p id="d88f" class="pw-post-body-paragraph ir is hu it b iu lj iw ix iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo hn dt translated"><a class="ae jp" href="https://en.wikipedia.org/wiki/Aspect-oriented_programming" rel="noopener ugc nofollow" target="_blank">面向方面编程</a>是关于粉碎CCC ( <a class="ae jp" href="https://en.wikipedia.org/wiki/Cross-cutting_concern" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">横切关注点</strong> </a>)。</p><p id="102e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不是所有的基础设施代码都是CCC的，但有些是。如果我们粘贴相同的代码，每次改变一些变量或参数来适应当前的上下文。该代码是AOP的主要候选代码。</p><p id="143e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该代码可以被抽象并准备好在某个方法之后或之前<strong class="it hv">被注入<strong class="it hv">，并且能够接收方法/实例上下文来执行操作，就像它(代码)在这里一样。</strong></strong></p><p id="5396" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这不是魔术，只是IoC。</p><blockquote class="jy jz ka"><p id="cc8d" class="ir is jx it b iu iv iw ix iy iz ja jb kb jd je jf kc jh ji jj kd jl jm jn jo hn dt translated">简而言之，AOP是一个反对重复的工具箱</p></blockquote><p id="b9a8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你还不能理解这篇文章<a class="ae jp" href="http://blog.mgechev.com/2015/07/29/aspect-oriented-programming-javascript-aop-js/" rel="noopener ugc nofollow" target="_blank">想想随处可见的console.log】，那就哭去吧。</a></p></div><div class="ab cl ke kf hc kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hn ho hp hq hr"><h1 id="a4e7" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">以KAOP/KAOP-TS为特色</h1><p id="084d" class="pw-post-body-paragraph ir is hu it b iu lj iw ix iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo hn dt translated">我通过尝试在ES5中实现OOP特性来构建这个库。</p><p id="b57d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，允许继承而不弄脏原型和覆盖父方法。在下面的代码中，我声明了<strong class="it hv">程序员</strong>类扩展<strong class="it hv">人</strong>类覆盖其构造函数:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="jv jw l"/></div></figure><p id="d822" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现代版本的Javascript就是这么做的。但是当我成功时，我意识到“override”只是一个在方法执行之前注入的<em class="jx">代码块，它利用带注释的方法的上下文来做一些事情……</em><strong class="it hv">这是一个有趣的技术，它提醒我</strong> <a class="ae jp" href="http://aopalliance.sourceforge.net/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> AOP联盟</strong> </a> <strong class="it hv">或者Java中的Spring</strong><em class="jx">。</em></p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="jv jw l"/></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">basically apply just executes super call with invoked arguments while implement actually injects super method</figcaption></figure><p id="04ba" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上面的例子是一个“override”建议的实现，它放在我们用来覆盖的方法之前。</p><p id="a0bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当你要实现一个<em class="jx">建议</em>(这是一个抽象代码块)<strong class="it hv">，</strong>时，你习惯于获取方法或实例上下文。<strong class="it hv"> meta </strong>关键字是作用域元数据，它包含几个允许<a class="ae jp" href="https://en.wikipedia.org/wiki/Reflection_(computer_programming)" rel="noopener ugc nofollow" target="_blank">反射</a>的属性:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="jv jw l"/></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">both kaop and its TypeScript version kaop-ts have the same API to access scope context</figcaption></figure><blockquote class="jy jz ka"><p id="d779" class="ir is jx it b iu iv iw ix iy iz ja jb kb jd je jf kc jh ji jj kd jl jm jn jo hn dt translated">AOP是关于定义和应用模式/行为</p></blockquote><p id="f8bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">与复制和粘贴代码块不同，使用KAOP，您可以提取代码块，使其更加抽象，然后将其注入到需要的地方。</p><p id="c413" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">KAOP提供了一种构建代码的方式，允许<a class="ae jp" href="https://en.wikipedia.org/wiki/Declarative_programming" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">声明式编程</strong> </a> <strong class="it hv"> </strong>，其目标是<strong class="it hv"> : </strong></p><blockquote class="jy jz ka"><p id="a2aa" class="ir is jx it b iu iv iw ix iy iz ja jb kb jd je jf kc jh ji jj kd jl jm jn jo hn dt translated">“根据<a class="ae jp" href="https://en.wikipedia.org/wiki/Problem_domain" rel="noopener ugc nofollow" target="_blank"><strong class="it hv"/></a>，通过描述<strong class="it hv"> <em class="hu">程序必须完成什么</em>来消除副作用，而不是描述<em class="hu"/>如何作为<a class="ae jp" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>语言<a class="ae jp" href="https://en.wikipedia.org/wiki/Language_primitive" rel="noopener ugc nofollow" target="_blank">原语</a>的序列来完成它”。</strong></p></blockquote><p id="c7eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">甚至你也有能力自己构建<strong class="it hv">依赖注入</strong>。因为AOP和DI都是<a class="ae jp" href="https://en.wikipedia.org/wiki/Reflection_(computer_programming)" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">反射技术</strong> </a> <strong class="it hv"> : </strong></p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="jv jw l"/></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">simplified from <a class="ae jp" href="https://github.com/k1r0s/ritley/blob/master/lib/abstract-resource.js" rel="noopener ugc nofollow" target="_blank">https://github.com/k1r0s/ritley/blob/master/lib/abstract-resource.js</a></figcaption></figure><p id="de8d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">前面的例子包含一个资源类，它采用一个nodeProvider，如果将它注入到构造函数<strong class="it hv">中，它将为每个资源子类提供一个单独的节点http服务器实例</strong>，所有这些实例都将侦听具有自己的<strong class="it hv">资源标识符</strong>的请求。所以简单地说，我们负责监听每个实例的请求，代码组织得很好，很容易在OOP模式中扩展。</p><p id="b7d4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你喜欢这篇文章，请查看<a class="ae jp" href="https://hackernoon.com/angular-tutorial-separation-of-concerns-using-es7-decorators-ed6c9756265" rel="noopener ugc nofollow" target="_blank">这个带有Angular 2+ app的例子</a></p><p id="6a42" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">今天到此为止，<strong class="it hv">如果你关心这个话题</strong>，我强烈推荐<a class="ae jp" href="https://k1r0s.github.io/aop-intro/" rel="noopener ugc nofollow" target="_blank">你查看这个</a>。</p><p id="8a2c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">欢迎任何投稿:</p><div class="ls lt fm fo lu lv"><a href="https://github.com/k1r0s/kaop" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab ej"><div class="lx ab ly cl cj lz"><h2 class="bd hv fv z el ma eo ep mb er et ht dt translated">k1r0s/kaop</h2><div class="mc l"><h3 class="bd b fv z el ma eo ep mb er et ek translated">kaop——高级OOP库，带有创建类、继承、提供者、注入器、建议，支持方便的反转…</h3></div><div class="md l"><p class="bd b gc z el ma eo ep mb er et ek translated">github.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj mk lv"/></div></div></a></div><div class="ls lt fm fo lu lv"><a href="https://github.com/k1r0s/kaop-ts" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab ej"><div class="lx ab ly cl cj lz"><h2 class="bd hv fv z el ma eo ep mb er et ht dt translated">k1r0s/kaop-ts</h2><div class="mc l"><h3 class="bd b fv z el ma eo ep mb er et ek translated">简单而强大的ES2016 Decorators库，带有像BeforeMethod这样的强类型方法拦截器…</h3></div><div class="md l"><p class="bd b gc z el ma eo ep mb er et ek translated">github.com</p></div></div><div class="me l"><div class="ml l mg mh mi me mj mk lv"/></div></div></a></div><blockquote class="jy jz ka"><p id="01dc" class="ir is jx it b iu iv iw ix iy iz ja jb kb jd je jf kc jh ji jj kd jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是T21家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is jx it b iu iv iw ix iy iz ja jb kb jd je jf kc jh ji jj kd jl jm jn jo hn dt translated">要了解更多信息，请阅读我们的“关于”页面、<a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">喜欢/在脸书上给我们发消息</a>，或者简单地发送<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is jx it b iu iv iw ix iy iz ja jb kb jd je jf kc jh ji jj kd jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mm jw l"/></div></figure></div></div>    
</body>
</html>