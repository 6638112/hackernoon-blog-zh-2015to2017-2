<html>
<head>
<title>Understanding Elixir Macros</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Elixir宏</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/understanding-elixir-macros-3464e141434c?source=collection_archive---------4-----------------------#2017-11-22">https://medium.com/hackernoon/understanding-elixir-macros-3464e141434c?source=collection_archive---------4-----------------------#2017-11-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/ecca2b45e40da37459e816daf57b962e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tHQF76ghMaYCWjshzAbtSA.jpeg"/></div></div></figure><div class=""/><p id="2cc7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">前一段时间，当我第一次研究<a class="ae ka" href="https://hackernoon.com/tagged/elixir" rel="noopener ugc nofollow" target="_blank">药剂</a>时，我在文档中增加了一章，它与一个叫做<strong class="je ig">宏的东西有关。</strong>当我研究这个问题时，一些复杂的术语开始出现，然后我就害怕了。比如:</p><ul class=""><li id="9275" class="kb kc if je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">元编程</li><li id="f4db" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">抽象语法三</li><li id="8ed8" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">酏剂AST</li><li id="3206" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">AST文字</li><li id="874b" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">引用和取消引用</li></ul><p id="272a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了理解<strong class="je ig">宏</strong>，我们应该对这些新的技术术语的含义有个概念，以及它们与灵药的关系。</p><h1 id="8fca" class="kp kq if bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated"><strong class="ak">元编程</strong></h1><p id="23ff" class="pw-post-body-paragraph jc jd if je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">几乎所有的博客、书籍或视频都会说类似写代码  <em class="ls">，</em>的<strong class="je ig"> <em class="ls">代码之类的东西但是我真的很喜欢<a class="ae ka" href="https://twitter.com/@iamvery" rel="noopener ugc nofollow" target="_blank">@ im avery</a>在他的一次演讲中给出的解释。</em></strong></p><blockquote class="lt lu lv"><p id="d33c" class="jc jd ls je b jf jg jh ji jj jk jl jm lw jo jp jq lx js jt ju ly jw jx jy jz hn dt translated">元编程只是<a class="ae ka" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a> …</p><p id="9f67" class="jc jd ls je b jf jg jh ji jj jk jl jm lw jo jp jq lx js jt ju ly jw jx jy jz hn dt translated">编程是在一些数据中执行一些工作…</p><p id="9ad3" class="jc jd ls je b jf jg jh ji jj jk jl jm lw jo jp jq lx js jt ju ly jw jx jy jz hn dt translated">数据是对其执行操作的数量。</p></blockquote><p id="a5b3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以元编程就像有规律的编程。然而，我们执行操作的数据可以是我们想要的任何数据，而不仅仅是语言提供给我们的数据结构。例如:</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="965c" class="mi kq if me b fv mj mk l ml mm">2 + 3</span></pre><p id="fca8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们知道'<strong class="je ig"> 2 <em class="ls"> ' </em> </strong>，'<strong class="je ig"> 3 <em class="ls"> ' </em> </strong>是数据，'<strong class="je ig"> <em class="ls"> +' </em> </strong>是运算。然而在元编程中'<strong class="je ig"> + </strong>'也被认为是数据。我们可以操纵它，访问它，做任何我们想做的事情。</p><h1 id="73b0" class="kp kq if bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">抽象语法三</h1><p id="92e7" class="pw-post-body-paragraph jc jd if je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">当我们编写程序时，负责将我们的代码转换成字节码的编译器需要知道我们程序的语法结构，这样指令才能按照我们定义的那样执行。抽象语法三是表示。让我们看一些非常简单的例子:</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="57c2" class="mi kq if me b fv mj mk l ml mm">2 + 3</span></pre><figure class="lz ma mb mc fq hw fe ff paragraph-image"><div class="fe ff mn"><img src="../Images/3af45ec972593f16aee4323db9596bc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:570/format:webp/1*OtrgCEM8Ju-puxCCvwKL0w.jpeg"/></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">AST (Abstract Syntax Tree)</figcaption></figure><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="e276" class="mi kq if me b fv mj mk l ml mm">2 + 3 == 5</span></pre><figure class="lz ma mb mc fq hw fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/a21e2e58247593d55abca6c60fefcc48.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*K5cAW7FetVGEMcvqvEANIg.jpeg"/></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">AST (Abstract Syntax Tree)</figcaption></figure><h1 id="0b64" class="kp kq if bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">酏剂AST</h1><p id="47a8" class="pw-post-body-paragraph jc jd if je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">Elixir有自己的方式来表示AST，这是通过将几乎所有内容转换为一个三元素元组，只是稍微重述一下，Elixir编译器在产生<strong class="je ig">之前有一些步骤。光束</strong>文件，这是一个真正简短的模式:</p><figure class="lz ma mb mc fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mt"><img src="../Images/a48f6d6b4f6678049d6d05e32a538b9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Eqr7KBvtwWOfF8Twt8tO8Q.png"/></div></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">Elixir compiler phases</figcaption></figure><p id="c957" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当使用宏时，我们正在编写脚本并生成Elixir AST，我们不会触及<strong class="je ig">扩展宏</strong>和<strong class="je ig"> Erlang AST </strong>。但是，很高兴知道这些步骤是存在的。</p><h1 id="2641" class="kp kq if bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">AST文字</h1><p id="e345" class="pw-post-body-paragraph jc jd if je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">像<strong class="je ig">原子、整数、浮点、字符串、列表</strong>和<strong class="je ig">二元元组</strong>这样的基本数据结构被认为是<em class="ls">文字。</em>这意味着当编译器处理那个时，它们在AST格式上是相同的。示例:</p><figure class="lz ma mb mc fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mu"><img src="../Images/b45d39a246b32e815027723dcab8a992.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GFeDLf1SmPlPwuteoG8MyQ.png"/></div></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">AST Literal</figcaption></figure><h1 id="b058" class="kp kq if bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated"><strong class="ak"> 3个元素元组</strong></h1><p id="1316" class="pw-post-body-paragraph jc jd if je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">另一方面，其他所有内容都被转换为三元元组，其基本结构如下:</p><p id="1b09" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">如果是变量:</strong></p><p id="0810" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第一个元素是变量<strong class="je ig">名</strong>，第二项是这个变量存在所需要的<strong class="je ig">元数据</strong>(<em class="ls">通常为空</em>)，最后一项是<strong class="je ig">上下文</strong>。</p><figure class="lz ma mb mc fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mv"><img src="../Images/8cc80e3b9e9e399eee6af90659816c19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fK-XJpgKy-au9XX1IP2BAw.png"/></div></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">Variable to Elixir AST</figcaption></figure><p id="5463" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">如果是通话</strong></p><p id="ed50" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第一个元素是函数<strong class="je ig">名</strong>，第二个只是<strong class="je ig">元数据</strong>(通常你不会关心这个)，最后一项是<strong class="je ig">参数</strong>。</p><figure class="lz ma mb mc fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mw"><img src="../Images/2a0990cf2966facb4cc04cd602dc8b60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xJ8lw63DKJvKOqv74NBLpA.png"/></div></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">Function call to Elixir AST</figcaption></figure><h1 id="9a36" class="kp kq if bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">引用</h1><p id="7ad4" class="pw-post-body-paragraph jc jd if je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">可能在这一点上你正在考虑退出这篇文章，AST是复杂的嵌套结构。然而，有一些有用的函数(实际上它们也是宏)可以帮助我们管理所有这些结构。</p><p id="e6d2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你看到<em class="ls">引用</em>的例子，你可能会明白它是什么以及如何使用它:</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="5a6d" class="mi kq if me b fv mj mk l ml mm">iex&gt; quote do: 2 + 3<br/>{:+, [context: Elixir, import: Kernel], [2, 3]}</span></pre><p id="1bb1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以像使用其他函数或宏一样使用它。</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="7e9b" class="mi kq if me b fv mj mk l ml mm">iex(1)&gt; quote do<br/>...(2)&gt;   if 2 + 3 == 5 do<br/>...(3)&gt;     "this is true"<br/>...(4)&gt;   else<br/>...(5)&gt;     "this is false"<br/>...(6)&gt;   end<br/>...(7)&gt; end</span><span id="e6a7" class="mi kq if me b fv mx mk l ml mm">{<strong class="me ig">:if</strong>, [context: Elixir, import: Kernel],<br/> [{<strong class="me ig">:==</strong>, [context: Elixir, import: Kernel],<br/>   [{<strong class="me ig">:+</strong>, [context: Elixir, import: Kernel], [<strong class="me ig">2</strong>, <strong class="me ig">3</strong>]}, <strong class="me ig">5</strong>]},<br/>  [do: <strong class="me ig">"this is true"</strong>, else: <strong class="me ig">"this is false"</strong>]]}</span></pre><h1 id="26a0" class="kp kq if bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">引文止</h1><p id="da9e" class="pw-post-body-paragraph jc jd if je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">我首先想到的是:</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="b73c" class="mi kq if me b fv mj mk l ml mm">iex(1)&gt; unquote do: {:+, [context: Elixir, import: Kernel], [2, 3]}<br/>"2 + 3"</span></pre><p id="8364" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是，让我们这么说吧，事情并不是这样的。</p><blockquote class="lt lu lv"><p id="50c4" class="jc jd ls je b jf jg jh ji jj jk jl jm lw jo jp jq lx js jt ju ly jw jx jy jz hn dt translated">引用和取消引用就像“插入的字符串”</p></blockquote><p id="0583" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">想象下一个代码:</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="45ae" class="mi kq if me b fv mj mk l ml mm">iex(1)&gt; name = "George"<br/><strong class="me ig">"George"</strong><br/>iex(2)&gt; "Hello name"<br/><strong class="me ig">"Hello name"</strong></span></pre><p id="46b6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们需要用字符串<strong class="je ig"> #{} </strong>评估<strong class="je ig">变量<strong class="je ig">名称</strong></strong></p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="1b17" class="mi kq if me b fv mj mk l ml mm">iex(1)&gt; name = "George"<br/><strong class="me ig">"George"</strong><br/>iex(2)&gt; "Hello #{name}"<br/><strong class="me ig">"Hello George"</strong></span></pre><p id="8737" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于<strong class="je ig">引用的表达式</strong>我们使用未引用的。</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="42b4" class="mi kq if me b fv mj mk l ml mm">iex(1)&gt; number = 3<br/>iex(2)&gt; quote do: 2 + unquote(number)<br/>{<strong class="me ig">:+</strong>, [context: Elixir, import: Kernel], [<strong class="me ig">2</strong>, <strong class="me ig">3</strong>]}</span></pre><h1 id="fbc0" class="kp kq if bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated"><strong class="ak">宏</strong></h1><p id="441d" class="pw-post-body-paragraph jc jd if je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">最后，本文的主要思想是向您展示什么是宏，但是正如我在开始时所说的，为了编写宏，我们需要理解一些其他的概念。</p><p id="8a52" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们定义我们的第一个宏:</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="8254" class="mi kq if me b fv mj mk l ml mm">defmodule MyMacros do</span><span id="4dfe" class="mi kq if me b fv mx mk l ml mm"><strong class="me ig">  defmacro</strong> nice_print({:+, _meta, [lhs, rhs]}) do<br/>    quote do<br/>      IO.puts """<br/>        #{unquote(lhs)}<br/>      + #{unquote(rhs)}<br/>        --<br/>        #{unquote(lhs+rhs)}<br/>      """<br/>    end<br/>  <strong class="me ig">end</strong></span><span id="e604" class="mi kq if me b fv mx mk l ml mm">end</span></pre><p id="13ab" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">看看我们如何立即使用quote，那是因为宏总是返回一个Elixir AST，如果你不这样做，你会得到一个错误。</p><p id="9faf" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们使用那个宏:</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="10a3" class="mi kq if me b fv mj mk l ml mm">iex(1)&gt; require MyMacros<br/>[MyMacros]<br/>iex(2)&gt; MyMacros.nice_print 2 + 3<br/>  2<br/>+ 3<br/>  --<br/>  5</span></pre><p id="376a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，我们的宏接收一个三元素元组，在本例中是<strong class="je ig"> 2 + 3 </strong>的Elixir AST，而不是表达式5的求值。为了管理宏，我们拥有的工具不仅仅是这些。</p><p id="bcdf" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">宏到字符串</strong></p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="8839" class="mi kq if me b fv mj mk l ml mm">iex(1)&gt; expression = quote do: 2 + 3<br/>{:+, [context: Elixir, import: Kernel], [2, 3]}<br/>iex(2)&gt; Macro.to_string(expression)<br/><strong class="me ig">“2 + 3”</strong></span></pre><p id="e5dd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig"> Code.eval_quoted </strong></p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="661d" class="mi kq if me b fv mj mk l ml mm">iex(1)&gt; expression = quote do: 2 + 3<br/>{:+, [context: Elixir, import: Kernel], [2, 3]}<br/>iex(2)&gt; Code.eval_quoted(expression)<br/>{<strong class="me ig">5</strong>, []}</span></pre><h1 id="1dc5" class="kp kq if bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">利弊</h1><p id="2685" class="pw-post-body-paragraph jc jd if je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">在Chris McCord的书“<strong class="je ig">元编程灵丹妙药</strong>”中，他有一节叫做宏规则，他的第一条规则是:</p><blockquote class="lt lu lv"><p id="b953" class="jc jd ls je b jf jg jh ji jj jk jl jm lw jo jp jq lx js jt ju ly jw jx jy jz hn dt translated">不要写宏</p></blockquote><p id="6fd4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是为什么呢？，它们很强大，很神奇，不是吗？…我想这是第一个原因，它们如此强大，以至于你会沉迷于过度使用它们，而过度使用它们，你的代码会看起来很难看，难以阅读。</p><p id="38aa" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在杰西·安德森的一次演讲中，他展示了一段非常有趣的话:</p><blockquote class="lt lu lv"><p id="83a8" class="jc jd ls je b jf jg jh ji jj jk jl jm lw jo jp jq lx js jt ju ly jw jx jy jz hn dt translated">代码被阅读的次数比它被编写的次数多得多，这意味着代码的最终成本在于它的阅读。</p></blockquote><p id="e14d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对我来说，这是真的，我们不必放弃编写漂亮易读的代码的想法。</p><p id="a913" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用宏的好处是元编程部分，我们可以做一些用普通函数做不到的事情，函数中的参数甚至在我们可以在函数体中使用它们之前就被计算了，而使用宏就不是这样了，因为我们只收到表达式的Elixir AST版本。</p><p id="0eab" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">宏对于隐藏样板文件也很有用，想象一下您必须编写这样的代码</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="ff6e" class="mi kq if me b fv mj mk l ml mm">case(true) do<br/>  x when x in [false, nil] -&gt;<br/>    false<br/>  _ -&gt;<br/>    true<br/>end</span></pre><p id="657c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">而不是这个</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="7e12" class="mi kq if me b fv mj mk l ml mm">if true do<br/>  true<br/>else<br/>  false<br/>end</span></pre><p id="3029" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，对于宏，我们有可能通过在宏内部生成代码来隐藏代码。</p><p id="7f50" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">希望你了解什么是宏以及如何使用它们，对我来说这个话题真的很棒，因为这是我第一次做元编程。灵丹妙药使其易于阅读和维护。如果你有任何问题，这里是我的推特<a class="ae ka" href="https://twitter.com/JorgeChavz" rel="noopener ugc nofollow" target="_blank"> @jorgechavz </a>。谢谢！</p><h1 id="0470" class="kp kq if bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated"><strong class="ak">资源</strong></h1><p id="a92a" class="pw-post-body-paragraph jc jd if je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">宏并没有就此停止，有太多的信息与这个主题相关，我会在这里留下一些链接来帮助我理解这个有趣的主题。</p><p id="17c1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">在Elixir <br/> </strong> <a class="ae ka" href="https://dockyard.com/blog/2016/08/16/the-minumum-knowledge-you-need-to-start-metaprogramming-in-elixir" rel="noopener ugc nofollow" target="_blank">中开始元编程所需的最少知识https://dock yard . com/blog/2016/08/16/The-minum-knowledge-you-need-start-meta programming-in-Elixir</a></p><p id="959e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不要写宏，但要了解它们是如何工作的——杰西·安德森https://www.youtube.com/watch?v=Bo48sQDb-hk</p><p id="8f0f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">少写，多做(并且玩得开心！)配仙丹宏<br/>视频:</strong><a class="ae ka" href="https://www.youtube.com/watch?v=mkoYqXdXl5Y" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=mkoYqXdXl5Y</a><br/><strong class="je ig">幻灯片:</strong>【http://slides.com/chrismccord/elixir-macros#/】T21</p><p id="0072" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">了解仙丹宏</strong><br/><a class="ae ka" href="http://theerlangelist.com/article/macros_1" rel="noopener ugc nofollow" target="_blank">http://theerlangelist.com/article/macros_1</a></p><figure class="lz ma mb mc fq hw"><div class="bz el l di"><div class="my mz l"/></div></figure></div></div>    
</body>
</html>