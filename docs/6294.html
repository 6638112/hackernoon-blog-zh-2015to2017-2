<html>
<head>
<title>Mastering Elixir Releases with Distillery — A (Pretty) Complete Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用蒸馏器控制酏剂释放——一本(相当)完整的指南</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/mastering-elixir-releases-with-distillery-a-pretty-complete-guide-497546f298bc?source=collection_archive---------2-----------------------#2017-09-12">https://medium.com/hackernoon/mastering-elixir-releases-with-distillery-a-pretty-complete-guide-497546f298bc?source=collection_archive---------2-----------------------#2017-09-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="59c5" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">如何创建酏剂版本？和伞应用程序的一些提示。</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/73a9acf5c5e2c33acd555de1a88edba8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gDw8nUbMrE6wM6t-SR6baQ.jpeg"/></div></div></figure><h1 id="2398" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">快速复习和一点历史</h1><p id="e20c" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">发行版在Erlang/OTP领域已经存在很长时间了。</p><p id="8aff" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">我以前写过关于<a class="ae lo" rel="noopener" href="/@pentacent/elixir-releases-docker-the-basics-explained-4c800a5b990b">什么是发布以及为什么它们更好的详细信息</a>。这里有一点提醒:版本是编译好的Elixir/Erlang <a class="ae lo" href="https://hackernoon.com/tagged/code" rel="noopener ugc nofollow" target="_blank">代码</a>的自包含包，可以很容易地部署在<a class="ae lo" href="https://hackernoon.com/tagged/remote" rel="noopener ugc nofollow" target="_blank"> remot </a> e机器上。</p><p id="8c55" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">自然，迄今为止，大多数创建发布的工具都来自Erlang世界。Erlang附带了<code class="eh lp lq lr ls b">systools</code>和<code class="eh lp lq lr ls b">reltool</code>，但是它们的用法相当复杂。所以社区构建了<code class="eh lp lq lr ls b"><a class="ae lo" href="https://github.com/erlware/relx" rel="noopener ugc nofollow" target="_blank">relx</a></code>作为一个更易于使用的替代方案，现在已经成为从Erlang项目创建版本的事实上的标准。因为这些工具都是为Erlang设计的，所以它们可以为Elixir项目工作，但是还有很多不足之处。</p><p id="74a8" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">2014年，Paul aka <a class="ae lo" href="http://bitwalker.org/" rel="noopener ugc nofollow" target="_blank"> bitwalker </a>开始让酏剂的发布变得更容易，并发布了<code class="eh lp lq lr ls b">exrm</code>——建立在<code class="eh lp lq lr ls b">relx</code>的基础上，具有一些酏剂特有的功能。由于<code class="eh lp lq lr ls b">relx</code>的限制，<code class="eh lp lq lr ls b">exrm</code>不够灵活，永远无法充分发挥模块化酏剂应用的潜力。所以保罗决定创建一个新的发布经理，从头开始用纯灵药编写——于是<a class="ae lo" href="https://github.com/bitwalker/distillery" rel="noopener ugc nofollow" target="_blank">酒厂</a>诞生了。</p><h1 id="177e" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">逐步指南</h1><p id="53cc" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">在本文的这一部分，您将学习如何将Distillery添加到项目中，并逐步构建您的第一个版本。我们走吧！</p><p id="4471" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">我已经创建了一个小应用程序，每秒钟打印出当前时间。我们可以用它来构建一个版本:</p><pre class="jk jl jm jn fq lu ls lv lw aw lx dt"><span id="bc4b" class="ly jw hu ls b fv lz ma l mb mc">git clone <a class="ae lo" href="https://github.com/wmnnd/distillery-demo.git" rel="noopener ugc nofollow" target="_blank">https://github.com/wmnnd/distillery-demo.git</a><br/>cd distillery-demo</span></pre><h2 id="b7cb" class="ly jw hu bd jx md me mf kb mg mh mi kf kw mj mk kh la ml mm kj le mn mo kl mp dt translated">安装Distillery &amp;创建第一个版本</h2><p id="cd3a" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">在创建您的第一个发行版之前，您需要安装Distillery。将<code class="eh lp lq lr ls b">{:distillery, "~&gt; 1.5"}</code>添加到项目<code class="eh lp lq lr ls b">mix.exs</code>的依赖项列表中，并运行<code class="eh lp lq lr ls b">mix deps.get</code>。</p><p id="fa6d" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">接下来，我们通过调用<code class="eh lp lq lr ls b">mix release.init</code>来初始化Distillery。该命令创建一个配置文件<code class="eh lp lq lr ls b">rel/config.exs</code>。您也可以手动创建文件，但这样更方便。</p><p id="949b" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">我们稍后将查看配置文件的内容。现在，这足以构建我们的第一个版本。为了做到这一点，运行<code class="eh lp lq lr ls b">mix release</code>。Distillery现在将创建如下所示的输出:</p><pre class="jk jl jm jn fq lu ls lv lw aw lx dt"><span id="3da0" class="ly jw hu ls b fv lz ma l mb mc">==&gt; Assembling release..<br/>==&gt; Building release clock:0.1.0 using environment dev<br/>==&gt; You have set dev_mode to true, skipping archival phase<br/>==&gt; Release successfully built!<br/>    You can run it in one of the following ways:<br/>      Interactive: _build/dev/rel/clock/bin/clock console<br/>      Foreground: _build/dev/rel/clock/bin/clock foreground<br/>      Daemon: _build/dev/rel/clock/bin/clock start</span></pre><p id="d661" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">祝贺您，您刚刚创建了您的第一个版本！用<code class="eh lp lq lr ls b">_build/dev/rel/clock/bin/clock foreground</code>运行。正如预期的那样，应用程序现在以一秒为间隔打印出当前时间。您可以点击<code class="eh lp lq lr ls b">Ctrl+C</code>终止应用程序。</p><blockquote class="mq mr ms"><p id="39ee" class="kn ko lt kp b kq lj iv ks kt lk iy kv mt ll ky kz mu lm lc ld mv ln lg lh li hn dt translated"><strong class="kp hv">注意:目前在Distillery中有一个bug，它可能会在启动发布时崩溃。在这种情况下，运行</strong> <code class="eh lp lq lr ls b"><strong class="kp hv">mix clean &amp;&amp; mix compile</strong></code> <strong class="kp hv">并再次尝试运行应用程序。</strong></p></blockquote><p id="675e" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">在启动应用程序的调用中，您在最后传递了<code class="eh lp lq lr ls b">foreground</code>命令。这是<em class="lt">引导命令</em>。还有其他启动应用程序的引导命令:<code class="eh lp lq lr ls b">console</code>启动与应用程序的交互式iex会话，<code class="eh lp lq lr ls b">start</code>在后台创建一个守护进程。</p><h2 id="4cbe" class="ly jw hu bd jx md me mf kb mg mh mi kf kw mj mk kh la ml mm kj le mn mo kl mp dt translated">发布概要文件和环境</h2><p id="5485" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">让我们后退一步。您可能已经熟悉了Elixir的构建工具组合。Mix支持多种<em class="lt">环境</em> : <code class="eh lp lq lr ls b">dev</code>，<code class="eh lp lq lr ls b">prod</code>和<code class="eh lp lq lr ls b">test</code>。例如，根据当前环境，Mix可以确定要包含哪些依赖项或配置文件。</p><p id="1385" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">您可能已经注意到，当我们创建发布时，Distillery打印出了这一行:<code class="eh lp lq lr ls b">Building release clock:0.1.0 <strong class="kp hv">using environment dev</strong></code>。酿酒厂也有<em class="lt">环境— </em>但它们不同于混合环境。<strong class="kp hv"> Distillery使用环境来允许发布构建过程的多种配置。</strong></p><p id="494f" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">便利地——或者令人困惑地——酿酒厂环境默认与混合环境相同。让我们看一下自动生成的配置文件<code class="eh lp lq lr ls b">rel/config.exs</code>，以便更好地理解概要文件的工作原理:</p><pre class="jk jl jm jn fq lu ls lv lw aw lx dt"><span id="d4e0" class="ly jw hu ls b fv lz ma l mb mc">use Mix.Releases.Config,<br/>  default_release: :default,<br/>  default_environment: Mix.env()</span></pre><p id="41be" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">我们可以看到<code class="eh lp lq lr ls b">default_environment</code>被设置为<code class="eh lp lq lr ls b">Mix.env()</code>。这意味着酿酒厂将与我们的混合环境相匹配。您可以用<code class="eh lp lq lr ls b">--env</code>开关覆盖默认环境。以下是这种工作方式的一些例子:</p><pre class="jk jl jm jn fq lu ls lv lw aw lx dt"><span id="6549" class="ly jw hu ls b fv lz ma l mb mc">mix release<br/>#Mix environment and Distillery environment are both <em class="lt">dev</em></span><span id="2600" class="ly jw hu ls b fv mw ma l mb mc">MIX_ENV=prod mix release<br/>#Mix environment and Distillery environment are both <em class="lt">prod</em></span><span id="6626" class="ly jw hu ls b fv mw ma l mb mc">MIX_ENV=prod mix release --env=dev<br/>#Mix environment is <em class="lt">prod</em>, Distillery environment is <em class="lt">dev</em></span></pre><p id="ef04" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">配置文件还指定<code class="eh lp lq lr ls b">default_release</code>为<code class="eh lp lq lr ls b">:default</code>。这是因为您实际上可以为您的项目定义不止一个版本。通过<code class="eh lp lq lr ls b">:default</code>设置，Distillery自动选择<code class="eh lp lq lr ls b">rel/config.exs</code>中定义的<em class="lt">第一个</em>版本。如果您想覆盖默认版本，您可以用<code class="eh lp lq lr ls b">--name</code>标志来指定。</p><p id="59eb" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">一个环境与一个特定发布名称的组合被称为一个<em class="lt">概要文件</em>。您可以选择带有<code class="eh lp lq lr ls b">--profile=name:env</code>标志的特定个人资料。</p><p id="3394" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">在下一节中，我们将看看如何使用多种环境来配置Distillery。</p><h2 id="51f3" class="ly jw hu bd jx md me mf kb mg mh mi kf kw mj mk kh la ml mm kj le mn mo kl mp dt translated">发布构建配置</h2><p id="4a22" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">我们的Distillery配置包括两个环境(<code class="eh lp lq lr ls b">dev</code>和<code class="eh lp lq lr ls b">prod</code>)，位于一个以我们的项目(<code class="eh lp lq lr ls b">clock</code>)命名的版本之上:</p><pre class="jk jl jm jn fq lu ls lv lw aw lx dt"><span id="adae" class="ly jw hu ls b fv lz ma l mb mc">environment :dev do<br/>  set dev_mode: true<br/>  set include_erts: false<br/>  set cookie: :"W?cN_`G&lt;&gt;ayUI&amp;ku{&lt;$3w7J&lt;^nUBRBu[F[…]"<br/>end</span><span id="75de" class="ly jw hu ls b fv mw ma l mb mc">environment :prod do<br/>  set include_erts: true<br/>  set include_src: false<br/>  set cookie: "^_`fz{dk|`w.n3Z%T,n=F&gt;ezazFk.1ci5}[…]"<br/>end</span><span id="ecf4" class="ly jw hu ls b fv mw ma l mb mc">release :clock do<br/>  set version: current_version(:clock)<br/>  set applications: [<br/>    :runtime_tools<br/>  ]<br/>end</span></pre><p id="3700" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">下面是配置文件中包含的选项的作用:</p><ul class=""><li id="863c" class="mx my hu kp b kq lj kt lk kw mz la na le nb li nc nd ne nf dt translated"><code class="eh lp lq lr ls b">dev_mode: true/false</code>:如果<code class="eh lp lq lr ls b">true</code>，字节码、资产等文件不复制到发布文件夹。相反，Distillery创建符号链接。这使得创建发布更快，并且非常适合测试目的。</li><li id="9a46" class="mx my hu kp b kq ng kt nh kw ni la nj le nk li nc nd ne nf dt translated"><code class="eh lp lq lr ls b">include_erts: true/false</code>:如果<code class="eh lp lq lr ls b">true</code>，Distillery包含Erlang运行时ERTS。这在您的开发机器上不是必需的，但建议您制作自包含版本。<br/>如果您想将您的版本部署到具有不同操作系统或处理器架构的机器上，您可以指定交叉编译的ERTS版本的路径，而不是<code class="eh lp lq lr ls b">true/false</code>。</li><li id="4812" class="mx my hu kp b kq ng kt nh kw ni la nj le nk li nc nd ne nf dt translated"><code class="eh lp lq lr ls b">cookie: $STRING</code>:酒厂可以设置<a class="ae lo" href="http://erlang.org/doc/reference_manual/distributed.html" rel="noopener ugc nofollow" target="_blank">二郎曲奇</a>。自动生成的配置包括随机Erlang cookies。如果你想把你的配置提交给一个Git库，不要包含硬编码的cookie！在这篇文章的后面，我们将研究一种更好的方法来配置这个神奇的cookie。</li><li id="b9fc" class="mx my hu kp b kq ng kt nh kw ni la nj le nk li nc nd ne nf dt translated"><code class="eh lp lq lr ls b">include_src: true/false</code>:该选项可用于<a class="ae lo" href="https://twitter.com/gotbones/status/906270692970295296" rel="noopener ugc nofollow" target="_blank">向后兼容</a>与Erlang发布工具<code class="eh lp lq lr ls b">relx</code>。如果<code class="eh lp lq lr ls b">true</code>，来自你的项目和依赖项的Erlang源代码包含在发布中。不包含长生不老药代码，所以大多数时候，你可以忽略这个选项。</li><li id="7601" class="mx my hu kp b kq ng kt nh kw ni la nj le nk li nc nd ne nf dt translated"><code class="eh lp lq lr ls b">version: $VERSION_STRING</code>:设置发布版本。您可以使用函数<code class="eh lp lq lr ls b">current_version/1</code>从项目的<code class="eh lp lq lr ls b">mix.exs</code>中提取版本。</li><li id="1566" class="mx my hu kp b kq ng kt nh kw ni la nj le nk li nc nd ne nf dt translated"><code class="eh lp lq lr ls b">applications: [:app_name]</code>:您可以在这里列出您想要包含的其他应用程序。默认情况下，Distillery包含了<code class="eh lp lq lr ls b">:runtime_tools</code>，它是Erlang标准库的一部分，支持某些调试特性。</li></ul><h2 id="0b81" class="ly jw hu bd jx md me mf kb mg mh mi kf kw mj mk kh la ml mm kj le mn mo kl mp dt translated">生命周期脚本又名钩子</h2><p id="0cb2" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">可以将shell脚本添加到您的版本中，以便在应用程序生命周期的某些点上运行。这些脚本也被称为<em class="lt">钩子</em>，可以在您的<code class="eh lp lq lr ls b">rel/config.exs</code>中配置。简单地将它们添加到<code class="eh lp lq lr ls b">env</code>或<code class="eh lp lq lr ls b">release</code>部分，如下所示:</p><pre class="jk jl jm jn fq lu ls lv lw aw lx dt"><span id="affe" class="ly jw hu ls b fv lz ma l mb mc">environment :prod do<br/>  set pre_start_hook: "rel/hooks/pre_start.sh"<br/>end</span></pre><p id="85ed" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">注意，这些路径是相对于您的项目目录的，而不是相对于<code class="eh lp lq lr ls b">rel</code>目录的。最有趣的钩子当然是<code class="eh lp lq lr ls b">pre_start</code>，但还有<code class="eh lp lq lr ls b">post_start</code>、<code class="eh lp lq lr ls b">pre/post_configure</code>、<code class="eh lp lq lr ls b">pre/post_stop</code>、<code class="eh lp lq lr ls b">pre/post_upgrade</code>。虽然Erlang理论上允许更多，但是目前每个Distillery钩子只能配置一个脚本。</p><h2 id="4eae" class="ly jw hu bd jx md me mf kb mg mh mi kf kw mj mk kh la ml mm kj le mn mo kl mp dt translated">伞形应用</h2><p id="b1a3" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">Distillery在处理伞状应用程序时也很棒！你只需要注意两件事:</p><ol class=""><li id="3a93" class="mx my hu kp b kq lj kt lk kw mz la na le nb li nl nd ne nf dt translated">在发布配置的<code class="eh lp lq lr ls b">applications</code>列表中包含您的子应用程序的名称。</li><li id="f762" class="mx my hu kp b kq ng kt nh kw ni la nj le nk li nl nd ne nf dt translated">您可以使用<code class="eh lp lq lr ls b">current_version(:my_child_app)</code>选择从任何子应用程序中获取发布版本号。</li></ol><p id="7e44" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">如前所述，也可以在您的<code class="eh lp lq lr ls b">rel/config.exs</code>中定义多个发布，从而指定多个发布概要文件。如果您希望发布的版本只包含保护伞项目中的某些子应用程序，这将非常有用。</p><h1 id="03cf" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">发行版的运行时配置</h1><p id="d90c" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">配置Elixir应用程序——尤其是在涉及第三方库时，可能是一件棘手的事情。Ecto核心开发者Micha最近表达了他对令人困惑的现状的担忧。</p><h2 id="2cc2" class="ly jw hu bd jx md me mf kb mg mh mi kf kw mj mk kh la ml mm kj le mn mo kl mp dt translated">混合配置的问题是</h2><p id="cf0a" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">您需要记住的第一件事是，混合配置文件中的配置是在编译时计算的。当您从源代码运行应用程序时，这不是问题。<strong class="kp hv">但是当Distillery构建一个版本时，所有的配置文件都会在构建时被评估。</strong></p><p id="d513" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">如果你的混音中有类似<code class="eh lp lq lr ls b">foo: System.get_env("BAR_VAR")</code>的东西。配置文件，你运气不好。<code class="eh lp lq lr ls b">foo</code>将从您的构建系统中获取<code class="eh lp lq lr ls b">BAR_VAR</code>环境变量的值。当您在另一台机器上启动应用程序时，该值不会更新。</p><p id="e7cb" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">幸运的是，有办法解决这个问题。最简单的是酿酒厂采用的一个小技巧:</p><h2 id="6382" class="ly jw hu bd jx md me mf kb mg mh mi kf kw mj mk kh la ml mm kj le mn mo kl mp dt translated">一个简单的解决方案:替换VARS操作系统</h2><p id="8674" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">Distillery有一种将环境变量注入Mix配置的特殊方式。只需在配置文件中使用类似<code class="eh lp lq lr ls b">"${BAR_VAR}"</code>的字符串，就可以了。当您的应用程序启动时，Distillery将用相应的环境变量值替换它。你所需要做的就是在发布时设置环境变量<code class="eh lp lq lr ls b">REPLACE_OS_VARS=true</code>。这使得编写如下配置变得非常容易:</p><pre class="jk jl jm jn fq lu ls lv lw aw lx dt"><span id="0567" class="ly jw hu ls b fv lz ma l mb mc">config :my_app,<br/>  foo: "${BAR_VAR}"</span></pre><p id="fcf9" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated"><strong class="kp hv">这个方法非常适合初始化Erlang cookie。</strong>使用<code class="eh lp lq lr ls b">rel/config.exs</code>中的<code class="eh lp lq lr ls b">set cookie: "${ERLANG_COOKIE}"</code>从环境变量中设置cookie。</p><p id="3ee5" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">不会没有问题的。最重要的是，这个方法只适用于字符串。如果您尝试类似于<code class="eh lp lq lr ls b">String.to_integer("${BAR}")</code>的东西，您会得到一个错误消息，因为编译器在Distillery有机会替换特殊字符串之前评估了表达式。</p><p id="6545" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">幸运的是，许多库现在支持更灵活的配置方法。</p><h2 id="93fe" class="ly jw hu bd jx md me mf kb mg mh mi kf kw mj mk kh la ml mm kj le mn mo kl mp dt translated">埃克托</h2><p id="74a1" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">Ecto引入了一种动态配置应用程序依赖关系的新方法。他们的解决方案是:回调！您可以使用<code class="eh lp lq lr ls b">Ecto.Repo.init/2</code>回调来动态配置Ecto。</p><p id="3053" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">这个回调将<code class="eh lp lq lr ls b">type</code>和<code class="eh lp lq lr ls b">config</code>作为参数。我们可以安全地忽略<code class="eh lp lq lr ls b">type</code>(根据调用的上下文，可以是<code class="eh lp lq lr ls b">:supervisor</code>或<code class="eh lp lq lr ls b">:dry_run</code>)。<code class="eh lp lq lr ls b">config</code>是您的Mix配置中的配置关键字列表。这很方便，因为它允许您在混合配置中设置默认值，然后用环境变量覆盖它们。</p><p id="954f" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">回调必须返回<code class="eh lp lq lr ls b">{:ok, config}</code>或<code class="eh lp lq lr ls b">:ignore</code>。下面是一个简单的类型转换示例:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nm nn l"/></div></figure><p id="dea5" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">不用编写自己的代码来解析环境变量，您可能会发现第三方应用程序，如<a class="ae lo" href="https://github.com/vinli/atmo_ex" rel="noopener ugc nofollow" target="_blank"> Atmo </a>或<a class="ae lo" href="https://github.com/Nebo15/confex" rel="noopener ugc nofollow" target="_blank"> Confex </a>很有用。我还没有尝试过，但他们似乎有一些很好的便利功能。</p><h2 id="f891" class="ly jw hu bd jx md me mf kb mg mh mi kf kw mj mk kh la ml mm kj le mn mo kl mp dt translated">凤凰</h2><p id="d607" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">从Phoenix应用程序中创建一个版本很容易。</p><p id="5316" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">在您创建生产版本之前，请确保您的资产已经构建并消化:</p><pre class="jk jl jm jn fq lu ls lv lw aw lx dt"><span id="20cb" class="ly jw hu ls b fv lz ma l mb mc">./node_modules/brunch/bin/brunch b -p<br/>MIX_ENV=prod mix phx.digest</span></pre><p id="07cc" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">在1.3版本中，Phoenix还采用了Ecto的回调式配置方法。这使得灵活配置<code class="eh lp lq lr ls b">Phoenix.Endpoint</code>变得非常容易:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nm nn l"/></div><figcaption class="no np fg fe ff nq nr bd b be z ek">The init/2 callback for Phoenix.Endpoint behaves exactly like in Ecto.</figcaption></figure><h1 id="741d" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">升级版本</h1><p id="8fe9" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">没有一个完整的关于Elixir版本的指南是完整的，如果没有提到他们最酷的特性之一:热更新。</p><p id="e129" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">您可能知道Erlang和Elixir被编译成字节码，然后由<em class="lt"> BEAM虚拟机</em>执行。多亏了BEAM，我们可以在不停止应用的情况下升级应用。</p><h2 id="e5a2" class="ly jw hu bd jx md me mf kb mg mh mi kf kw mj mk kh la ml mm kj le mn mo kl mp dt translated">创建升级版本</h2><p id="c1c4" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">内部版本升级使用<code class="eh lp lq lr ls b">.appup</code>文件来确定哪些模块应该升级以及如何升级。幸运的是，当我们给它传递参数<code class="eh lp lq lr ls b">--upgrade</code>时，Distillery会自动创建它们。<strong class="kp hv">在构建升级时，确保您的</strong> <code class="eh lp lq lr ls b"><strong class="kp hv">/_build</strong></code> <strong class="kp hv">文件夹中仍有以前的版本。否则，Distillery将无法确定哪些模块需要更新。</strong></p><h2 id="5de7" class="ly jw hu bd jx md me mf kb mg mh mi kf kw mj mk kh la ml mm kj le mn mo kl mp dt translated">创建生产版本</h2><p id="9d92" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">只有包含ERTS的版本才能使用热升级。因此，让我们从创建我们的<code class="eh lp lq lr ls b">clock</code>应用程序的生产版本开始:</p><pre class="jk jl jm jn fq lu ls lv lw aw lx dt"><span id="0efa" class="ly jw hu ls b fv lz ma l mb mc"><strong class="ls hv">#In Terminal 1</strong><br/>MIX_ENV=prod mix deps.get<br/>MIX_ENV=prod mix release</span></pre><p id="26d1" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">现在打开第二个终端窗口并启动发行版:</p><pre class="jk jl jm jn fq lu ls lv lw aw lx dt"><span id="2f71" class="ly jw hu ls b fv lz ma l mb mc"><strong class="ls hv">#In Terminal 2<br/></strong>cd distillery-clock-demo<br/>_build/prod/rel/clock/bin/clock foreground<!-- -->.</span></pre><p id="5bd4" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">同样，您应该看到每秒钟打印出来的当前时间。</p><h2 id="805a" class="ly jw hu bd jx md me mf kb mg mh mi kf kw mj mk kh la ml mm kj le mn mo kl mp dt translated">创建升级版本</h2><p id="4043" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">让我们创建一个新版本的<code class="eh lp lq lr ls b">clock</code>。因为它打印出当前版本号和当前时间，所以你需要做的就是改变<code class="eh lp lq lr ls b">mix.exs</code>中的<code class="eh lp lq lr ls b">version</code>来得到不同的输出。目前设置为<code class="eh lp lq lr ls b">0.1.0</code>。让我们把它改成<code class="eh lp lq lr ls b">0.2.0</code>。</p><p id="69d1" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">然后，通过将<code class="eh lp lq lr ls b">--upgrade</code>标志传递给<code class="eh lp lq lr ls b">mix.release</code>来创建一个升级版本。</p><pre class="jk jl jm jn fq lu ls lv lw aw lx dt"><span id="bfdf" class="ly jw hu ls b fv lz ma l mb mc"><strong class="ls hv">#In Terminal 1</strong><br/>MIX_ENV=prod mix release --upgrade</span></pre><h2 id="0125" class="ly jw hu bd jx md me mf kb mg mh mi kf kw mj mk kh la ml mm kj le mn mo kl mp dt translated">我们要现场直播！</h2><p id="66a9" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">创建发布升级后，第二个终端中的时钟应用程序没有改变。还没有。仍然在第一个终端中，运行以下命令:</p><pre class="jk jl jm jn fq lu ls lv lw aw lx dt"><span id="9b90" class="ly jw hu ls b fv lz ma l mb mc"><strong class="ls hv">#In Terminal 1</strong><br/>_build/prod/rel/clock/bin/clock upgrade 0.2.0</span></pre><p id="daa8" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">在第二个终端中，时钟输出现在将改变，并开始打印出当前日期。多整洁啊！</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ns"><img src="../Images/c07597aa11ed0bba4f1abad58b08ac48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*97Zic3IhrNIDRJ3o1eqiSw.png"/></div></div><figcaption class="no np fg fe ff nq nr bd b be z ek">Updating an application wile it’s running!</figcaption></figure><h1 id="a7f8" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">你是释放长生不老药的大师了吗？</h1><p id="5258" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">我希望在阅读本指南后，您现在对酏剂版本有了更好的理解。写完之后当然有！</p><p id="7d4c" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">如果你认为我错过了长生不老药版本的某个方面，这应该是这个(漂亮的)完整指南的一部分，请让我知道，我会努力添加它！</p></div><div class="ab cl nt nu hc nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="hn ho hp hq hr"><p id="e237" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated"><strong class="kp hv">本文是正在进行的关于将Elixir应用程序开发和部署到生产环境的系列文章的一部分。</strong>即将发布的文章将涵盖部署策略和构建Docker映像。</p><p id="6879" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">在这个系列中，我将分享我创建<a class="ae lo" href="https://www.dblsqd.com" rel="noopener ugc nofollow" target="_blank"><em class="lt">DBLSQD</em></a><em class="lt">的经验，这是一个用Elixir编写的发布和更新服务器。看看吧，有一个60天无附加条件的免费演示:</em></p><div class="oa ob fm fo oc od"><a href="https://www.dblsqd.com" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab ej"><div class="of ab og cl cj oh"><h2 class="bd hv fv z el oi eo ep oj er et ht dt translated">发布和分发软件— DBLSQD</h2><div class="ok l"><h3 class="bd b fv z el oi eo ep oj er et ek translated">DBLSQD是桌面和移动应用程序的发布+更新服务器。面向电子和Qt的强大SDK。兼容Sparkle、Squirrel和其他产品。</h3></div><div class="ol l"><p class="bd b gc z el oi eo ep oj er et ek translated">www.dblsqd.com</p></div></div><div class="om l"><div class="on l oo op oq om or jt od"/></div></div></a></div><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="os nn l"/></div></figure></div></div>    
</body>
</html>