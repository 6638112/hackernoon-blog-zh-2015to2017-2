<html>
<head>
<title>Dive Into GraphQL Part II: Anatomy of a GraphQL Query</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入GraphQL第二部分:GraphQL查询剖析</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/dive-into-graphql-part-ii-anatomy-of-a-graphql-query-cf0bfc5280d?source=collection_archive---------26-----------------------#2017-09-05">https://medium.com/hackernoon/dive-into-graphql-part-ii-anatomy-of-a-graphql-query-cf0bfc5280d?source=collection_archive---------26-----------------------#2017-09-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/b7fd73871f732cf85b2adc368c61f99e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ukp1py8_RQgPFcJOhtx2JA.jpeg"/></div></div></figure><p id="8044" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<a class="ae ka" href="https://marmelab.com/blog/2017/09/03/dive-into-graphql.html" rel="noopener ugc nofollow" target="_blank">深入GraphQL系列</a>的第一篇文章中，我解释了为什么REST不太适合今天的网络和移动应用。REST使得应用程序开发速度慢、难度大、成本高，而且功能过于有限。我们需要一个新的英雄，一个允许:</p><ol class=""><li id="dce3" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">查询资源的集合(例如，在一个往返行程中的tweets和profile)，甚至来自不同的域</li><li id="5265" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">查询明确的字段列表，而不是完整的资源</li><li id="ce7c" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">提供描述请求和响应语法的模式</li><li id="fa8f" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">成为一个标准，但不要太依赖于HTTP协议</li><li id="e4b0" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">支持现成的发布/订阅场景</li><li id="6963" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">将重点从服务器转移到客户端。</li></ol><p id="b025" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我确信<a class="ae ka" href="https://hackernoon.com/tagged/graphql" rel="noopener ugc nofollow" target="_blank">脸书</a>发明的查询语言GraphQL 是一个很好的候选语言。这种信念是基于几个月来对GraphQL的开发，并被Marmelab的许多开发人员所认同。我会在这篇文章中解释GraphQL是什么。</p><figure class="kq kr ks kt fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kp"><img src="../Images/7da5fdcd7ba0634079b73910c2dccbba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Usf1jFcgGArDLTGz.png"/></div></div></figure><p id="19da" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是首先，让我们打破一些关于GraphQL的误解。</p><h1 id="0d38" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">GraphQL不是什么</h1><p id="fac7" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">首先，GraphQL不是用于图形数据库的查询语言。那就是<a class="ae ka" href="http://tinkerpop.apache.org/" rel="noopener ugc nofollow" target="_blank">小妖精</a>。GraphQL中有<em class="lx">和</em>两个图的概念，但是学习者只有在阅读了一半文档后才能理解它(我会在下一篇文章中解释)。与此同时，许多好奇的开发人员放弃了，认为如果他们使用关系数据库或文档数据库，这与他们无关。</p><p id="3f0d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以在我看来，GraphQL最大的缺陷就是它的名字。其他名字会更好，比如，“焦糖”。这并不是说它不会发生在其他人身上:我将“<a class="ae ka" href="https://github.com/marmelab/admin-on-rest" rel="noopener ugc nofollow" target="_blank"> admin-on-rest </a>”命名为React库，它可以与任何REST <em class="lx">或GraphQL </em>后端一起工作。所以让我们弄清楚这一点:GraphQL适用于任何数据库——关系数据库、键/值存储库、文档数据库和图表数据库。您甚至可以在REST API前面使用它。</p><figure class="kq kr ks kt fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ly"><img src="../Images/d16d306cbaab929bfc193b912beea098.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dxuY0qnoRP4s2Wvn.jpg"/></div></div></figure><p id="c6cc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">GraphQL不是一个React库，它甚至不仅仅是一个JavaScript库。我知道，你会发现大多数关于GraphQL的教程都使用JavaScript，但这只是因为JS开发人员倾向于编写大量代码，所以他们希望分享它(双关语)。GraphQL是一个<em class="lx">规范</em>，有多种语言的实现。可以在JS、Objective-C或者Java中的客户端使用GraphQL。可以在JS、Go、Python、Ruby、PHP等在服务器端使用GraphQL。</p><p id="8c75" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">GraphQL不是传输协议。您可以将GraphQL用于任何传输方式——HTTP、WebSockets，如果您愿意，甚至可以通过Bittorrent将GraphQL查询作为文本文件发送。这使得它不同于REST，REST依赖于HTTP协议，建立在HTTP语法(<code class="eh lz ma mb mc b">GET</code>、<code class="eh lz ma mb mc b">POST</code>、<code class="eh lz ma mb mc b">PUT</code>等)之上。).</p><p id="9d58" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">根据这个想法，GraphQL不处理认证、授权、压缩、缓存、内容协商等。那是你的责任。</p><p id="ef21" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">GraphQL有意不包括内置的过滤、排序、计算或连接。您自己仔细设计所有这些来满足API消费者的需求，就像REST一样。</p><h1 id="67b0" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">您的第一个GraphQL查询</h1><p id="c029" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">现在，与其描述GraphQL <em class="lx">是什么</em>，不如让我们看看它<em class="lx">与REST相比做了什么</em>。例如，在REST中，从API请求一条tweet通常如下所示:</p><pre class="kq kr ks kt fq md mc me mf aw mg dt"><span id="40f5" class="mh kv hu mc b fv mi mj l mk ml">----------------------------------- request<br/>GET /tweets/123 HTTP 1.1<br/>Host: http://rest.acme.com/<br/>----------------------------------- response<br/>HTTP/1.1 200 OK<br/>Content-Type: application/json<br/>{<br/>    "id:" 123,<br/>    "body": "Lorem Ipsum dolor sit amet",<br/>    "user_id": 456,<br/>    "views": 45,<br/>    "date": "2017-07-14T12:44:17.449Z"<br/>    // etc.<br/>}</span></pre><p id="f644" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在HTTP上的GraphQL中，等效的代码是:</p><pre class="kq kr ks kt fq md mc me mf aw mg dt"><span id="0042" class="mh kv hu mc b fv mi mj l mk ml">----------------------------------- request<br/>POST / HTTP 1.1<br/>Host: http://graphql.acme.com/<br/>Content-Type: application/graphql<br/>{<br/>    Tweet(id: 123) {<br/>        id<br/>        body<br/>        date<br/>    }<br/>}<br/>----------------------------------- response<br/>HTTP/1.1 200 OK<br/>Content-Type: application/json<br/>{<br/>    "data": {<br/>        "Tweet": {<br/>            "id:" "123",<br/>            "body": "Lorem Ipsum dolor sit amet",<br/>            "date": "2017-07-14T12:44:17.449Z"<br/>        }<br/>    }<br/>}</span></pre><p id="222a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这个例子中有几件事需要注意:</p><ul class=""><li id="4837" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz mm kh ki kj dt translated">在REST中，API为每个资源公开一个端点(<code class="eh lz ma mb mc b">/tweets</code>就是这样一个端点)，而在GraphQL中，整个API只有一个端点(在示例中是<code class="eh lz ma mb mc b">/</code>)</li><li id="2094" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz mm kh ki kj dt translated">就像REST一样，GraphQL响应的主体是一个JSON对象。然而，响应的格式是标准化的，并且内容总是在<code class="eh lz ma mb mc b">data</code>键下可用。</li><li id="decf" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz mm kh ki kj dt translated">在GraphQL中，参数在括号之间(这里:<code class="eh lz ma mb mc b">(id: 123)</code>)和查询内部传递。</li><li id="1853" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz mm kh ki kj dt translated">在REST中，您需要一个完整的资源，而在GraphQL中，您必须显式地列出您想要的字段(本例中的<code class="eh lz ma mb mc b">id</code>、<code class="eh lz ma mb mc b">body</code>和<code class="eh lz ma mb mc b">date</code>)。</li><li id="0593" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz mm kh ki kj dt translated">GraphQL查询使用一种特殊的查询语言，称为… graphql。它看起来像JSON，但不是真的。我们很快就会看到。</li><li id="9fa2" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz mm kh ki kj dt translated">GraphQL请求使用一种特殊的内容类型<code class="eh lz ma mb mc b">application/graphql</code></li><li id="8b94" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz mm kh ki kj dt translated">与REST不同，GraphQL不依赖于HTTP语义。为了读取资源，GraphQL使用一个<code class="eh lz ma mb mc b">POST</code> HTTP请求。</li></ul><figure class="kq kr ks kt fq iv fe ff paragraph-image"><div class="fe ff mn"><img src="../Images/2842c0e078b79fbff35d34f6cf73fb91.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/0*07dtIKc_qOhwkiQI.gif"/></div></figure><p id="7350" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你是一个铁杆REST迷，这最后一点可能会让你畏缩。什么，用<code class="eh lz ma mb mc b">POST</code>到<em class="lx">读</em>一个资源？不是和溺死小猫一样犯罪吗？对您来说更糟糕的是:在GraphQL中，如果您想:</p><pre class="kq kr ks kt fq md mc me mf aw mg dt"><span id="31cb" class="mh kv hu mc b fv mi mj l mk ml">----------------------------------- request<br/>GET /?query=query%20%7B%20Tweet(id%3A%20123)%20%7Bid%20body%20date%20%7D%7D<br/>Host: http://graphql.acme.com/<br/>----------------------------------- response<br/>HTTP/1.1 200 OK<br/>Content-Type: application/json<br/>{<br/>    "data": {<br/>        "Tweet": {<br/>            "id:" "123",<br/>            "body": "Lorem Ipsum dolor sit amet",<br/>            "date": "2017-07-14T12:44:17.449Z"<br/>        }<br/>    }<br/>}</span></pre><p id="29e7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你感到震惊，请多包涵。几分钟后，你会发现这是一个多么伟大的想法。所以是的，GraphQL服务器通常不关心HTTP动词。更常见的是对所有事情(读写查询)使用<code class="eh lz ma mb mc b">POST</code>,因为它在教程中可读性更好。如前所述，您甚至不需要使用HTTP来与GraphQL服务器通信。</p><p id="54b2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">顺便提一下，您可以从<code class="eh lz ma mb mc b">GET</code>请求中看到，换行和制表在graphql查询中并不重要。</p><h1 id="4f6e" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">GraphQL是远程过程调用，不是基于资源的</h1><p id="0176" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">在之前的文章中，我介绍了移动Twitter主页的用例:</p><figure class="kq kr ks kt fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mo"><img src="../Images/3781e27544730ed4817bebef2ec0b9c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*K6NcJtMaqkbIXx6P.png"/></div></div></figure><p id="7137" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了呈现这个页面，应用程序需要读取10条最新的tweets，而不仅仅是一条。在休息时，你可以这样做:</p><pre class="kq kr ks kt fq md mc me mf aw mg dt"><span id="7f43" class="mh kv hu mc b fv mi mj l mk ml">----------------------------------- request<br/>GET /tweets/?limit=10&amp;sortField=date&amp;sortOrder=DESC HTTP 1.1<br/>Host: http://rest.acme.com/<br/>----------------------------------- response<br/>HTTP/1.1 200 OK<br/>Content-Type: application/json<br/>[<br/>    {<br/>        "id:" 752,<br/>        "body": "consectetur adipisicing elit",<br/>        "user_id": 249,<br/>        "views": 12,<br/>        "date": "2017-07-15T13:17:42.772Z",<br/>        // etc.<br/>    },<br/>    {<br/>        "id:" 123,<br/>        "body": "Lorem Ipsum dolor sit amet",<br/>        "user_id": 456,<br/>        "views": 45,<br/>        "date": "2017-07-14T12:44:17.449Z"<br/>        // etc.<br/>    },<br/>    // etc.<br/>]</span></pre><p id="f084" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在GraphQL中，就像您调用<code class="eh lz ma mb mc b">Tweet</code>查询来获得一条tweet一样，您通常调用<code class="eh lz ma mb mc b">Tweets</code>查询来获得几条tweet。但是，您需要列出希望出现在响应中的字段:</p><pre class="kq kr ks kt fq md mc me mf aw mg dt"><span id="8e55" class="mh kv hu mc b fv mi mj l mk ml">----------------------------------- request<br/>POST / HTTP 1.1<br/>Host: http://graphql.acme.com/<br/>Content-Type: application/graphql<br/>{<br/>    Tweets(limit: 10, sortField: "date", sortOrder: "DESC") {<br/>        id<br/>        body<br/>        date<br/>    }<br/>}<br/>----------------------------------- response<br/>HTTP/1.1 200 OK<br/>Content-Type: application/json<br/>{<br/>    "data": {<br/>        "Tweets": [<br/>            {<br/>                "id": "752",<br/>                "body": "consectetur adipisicing elit",<br/>                "date": "2017-07-15T13:17:42.772Z",<br/>            },<br/>            {<br/>                "id": "123",<br/>                "body": "Lorem Ipsum dolor sit amet",<br/>                "date": "2017-07-14T12:44:17.449Z"<br/>            },<br/>            // etc.<br/>        ]<br/>    }<br/>}</span></pre><p id="2b60" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh lz ma mb mc b">Tweet</code>和<code class="eh lz ma mb mc b">Tweets</code>是查询名称，由服务器定义。事实上，GraphQL的核心是一种远程过程调用(RPC)语言:它让客户机调用服务器上的过程(查询)。这意味着它绝对不局限于CRUD(创建、检索、更新、删除)场景。</p><p id="aa2a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是我应该警告你:对于<em class="lx">命名</em>查询没有约定。一些GraphQL服务器将使用<code class="eh lz ma mb mc b">Tweets</code>作为tweets列表，另一些可能使用<code class="eh lz ma mb mc b">allTweets</code>，还有一些使用<code class="eh lz ma mb mc b">getTweetPage</code>，等等。我知道<a class="ae ka" href="https://martinfowler.com/bliki/TwoHardThings.html" rel="noopener ugc nofollow" target="_blank">给事物命名是计算机科学</a>的两大难题之一，但我仍然很遗憾GraphQL规范没有更进一步。</p><h1 id="ded6" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">聚集</h1><p id="9e3a" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">您可能想知道为什么GraphQL响应在响应中包含一个<code class="eh lz ma mb mc b">Tweets</code>键，而不是将tweets列表直接放在<code class="eh lz ma mb mc b">"data"</code>下。这是因为您可以同时查询几个资源——在一次往返行程中:</p><pre class="kq kr ks kt fq md mc me mf aw mg dt"><span id="05b7" class="mh kv hu mc b fv mi mj l mk ml">----------------------------------- request<br/>POST / HTTP 1.1<br/>Host: http://graphql.acme.com/<br/>Content-Type: application/graphql<br/>{<br/>    Tweets(limit: 10, sortField: "date", sortOrder: "DESC") {<br/>        id<br/>        body<br/>        date<br/>    }<br/>    User {<br/>        full_name<br/>    }<br/>    NotificationsMeta {<br/>        count<br/>    }<br/>}<br/>----------------------------------- response<br/>HTTP/1.1 200 OK<br/>Content-Type: application/json<br/>{<br/>    "data": {<br/>        "Tweets": [<br/>            {<br/>                "id": "752",<br/>                "body": "consectetur adipisicing elit",<br/>                "date": "2017-07-15T13:17:42.772Z",<br/>            },<br/>            {<br/>                "id": "123",<br/>                "body": "Lorem Ipsum dolor sit amet",<br/>                "date": "2017-07-14T12:44:17.449Z"<br/>            },<br/>            // etc.<br/>        ],<br/>        "User": {<br/>            full_name: "John Doe"<br/>        },<br/>        "NotificationsMeta": {<br/>            count: 12<br/>        }<br/>    }<br/>}</span></pre><p id="afb0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">除了<code class="eh lz ma mb mc b">Tweets</code>之外，我还调用了<code class="eh lz ma mb mc b">User</code>查询来获取连接用户的详细信息，并调用了<code class="eh lz ma mb mc b">NotificationsMeta</code>查询来获取待处理通知的数量。GraphQL允许我将几个查询聚合成一个HTTP请求。</p><figure class="kq kr ks kt fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mp"><img src="../Images/f4e025e10b2034aca870c987bad7537c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dW3FhGaVsy1ZZlDz.jpg"/></div></div></figure><p id="3d7e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不过，还缺少一样东西:每条推文的作者姓名和头像。在REST中，您必须等待第一个查询的响应来获取每条tweet的<code class="eh lz ma mb mc b">user_id</code>，然后用这些id查询<code class="eh lz ma mb mc b">/users</code>端点。这将阻止页面的呈现，直到第二个响应返回。在GraphQL中，可以直接在推文中查询作者:</p><pre class="kq kr ks kt fq md mc me mf aw mg dt"><span id="e63b" class="mh kv hu mc b fv mi mj l mk ml">----------------------------------- request<br/>POST / HTTP 1.1<br/>Host: http://graphql.acme.com/<br/>Content-Type: application/graphql<br/>{<br/>    Tweets(limit: 10, sortField: "date", sortOrder: "DESC") {<br/>        id<br/>        body<br/>        date<br/>        Author {<br/>            username<br/>            full_name<br/>            avatar_url<br/>        }<br/>    }<br/>    User {<br/>        full_name<br/>    }<br/>    NotificationsMeta {<br/>        count<br/>    }<br/>}<br/>----------------------------------- response<br/>HTTP/1.1 200 OK<br/>Content-Type: application/json<br/>{<br/>    "data": {<br/>        "Tweets": [<br/>            {<br/>                "id": "752",<br/>                "body": "consectetur adipisicing elit",<br/>                "date": "2017-07-15T13:17:42.772Z",<br/>                "Author": {<br/>                    "username": "alang",<br/>                    "full_name": "Adrian Lang",<br/>                    "avatar_url": "http://avatar.acme.com/02ac660cdda7a52556faf332e80de6d8"<br/>                }<br/>            },<br/>            {<br/>                "id": "123",<br/>                "body": "Lorem Ipsum dolor sit amet",<br/>                "date": "2017-07-14T12:44:17.449Z",<br/>                "Author": {<br/>                    "username": "creilly17",<br/>                    "full_name": "Carole Reilly",<br/>                    "avatar_url": "http://avatar.acme.com/5be5ce9aba93c62ea7dcdc8abdd0b26b"<br/>                }<br/>            },<br/>            // etc.<br/>        ],<br/>        "User": {<br/>            full_name: "John Doe"<br/>        },<br/>        "NotificationsMeta": {<br/>            count: 12<br/>        }<br/>    }<br/>}</span></pre><p id="062e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此GraphQL允许您将许多查询组合成一个查询，包括对相关资源的查询。这样，您总是可以在一个请求中获得屏幕所需的所有数据。事实上，最后一个查询足以在一次往返中呈现整个Twitter主页。任务完成！</p><p id="ddab" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">提示</strong>:如果你想知道GraphQL服务器是如何工作的，<a class="ae ka" href="https://marmelab.com/blog/2017/09/06/dive-into-graphql-part-iii-building-a-graphql-server-with-nodejs.html" rel="noopener ugc nofollow" target="_blank">本系列的第三篇文章</a>将回答你的问题。这是一个为Twitter应用程序构建GraphQL服务器的教程。现在，请考虑服务器已经存在，并从这些服务器端的考虑中解放出来。</p><h1 id="0ec4" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">检查GraphQL服务器</h1><p id="c318" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">等等，我怎么知道可以在服务器上调用<code class="eh lz ma mb mc b">Tweets</code>、<code class="eh lz ma mb mc b">User</code>和<code class="eh lz ma mb mc b">NotificationsMeta</code>查询呢？我是说，除了我正在写这个教程？换句话说，作为一名前端开发人员，我如何知道可以在GraphQL后端调用哪些查询以及每个查询中的哪些字段？</p><figure class="kq kr ks kt fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mq"><img src="../Images/d61d682233e331d742344446c9ee42a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0IuZDJgqssXHV-uX.jpg"/></div></div></figure><p id="343e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">GraphQL通过公开查询映射来满足这一需求。每个GraphQL服务器都可以回答一个叫做<code class="eh lz ma mb mc b">__schema</code>的特殊查询——它叫做<em class="lx">自省</em>查询。它不是一个<a class="ae ka" href="https://gist.github.com/craigbeck/b90915d49fda19d5b2b17ead14dcd6da" rel="noopener ugc nofollow" target="_blank">特别可读的查询</a>，而且您无论如何也不会手工编写它(所有GraphQL客户端都可以在一个命令中进行自省)，所以让我们来看看这个查询的结果:它是服务器<em class="lx">模式</em>。对于我的示例Twitter API服务器，GraphQL模式如下所示:</p><pre class="kq kr ks kt fq md mc me mf aw mg dt"><span id="9076" class="mh kv hu mc b fv mi mj l mk ml"># entry points<br/>type Query {<br/>    Tweet(id: ID!): Tweet<br/>    Tweets(limit: Int, sortField: String, sortOrder: String): [Tweet]<br/>    TweetsMeta: Meta<br/>    User: User<br/>    Notifications(limit: Int): [Notification]<br/>    NotificationsMeta: Meta<br/>}<br/><br/>type Mutation {<br/>    createTweet (body: String): Tweet<br/>    deleteTweet(id: ID!): Tweet<br/>    markTweetRead(id: ID!): Boolean<br/>}<br/><br/>type Subscription {<br/>    tweetPublished(userId: ID!): Tweet<br/>}<br/><br/># custom types<br/>type Tweet {<br/>    id: ID!<br/>    # The tweet text. No more than 140 characters!<br/>    body: String<br/>    # When the tweet was published<br/>    date: Date<br/>    # Who published the tweet<br/>    Author: User<br/>    # Views, retweets, likes, etc<br/>    Stats: Stat<br/>}<br/><br/>type User {<br/>    id: ID!<br/>    username: String<br/>    first_name: String<br/>    last_name: String<br/>    full_name: String<br/>    name: String @deprecated<br/>    avatar_url: Url<br/>}<br/><br/>type Stat {<br/>    views: Int<br/>    likes: Int<br/>    retweets: Int<br/>    responses: Int<br/>}<br/><br/>type Notification {<br/>    id: ID<br/>    date: Date<br/>    type: String<br/>}<br/><br/>type Meta {<br/>    count: Int<br/>}<br/><br/># custom scalar types<br/>scalar Url<br/>scalar Date</span></pre><p id="d2bd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">哇，这个服务器暴露了很多东西！通过阅读模式，我一眼就能看出:</p><ul class=""><li id="dc82" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz mm kh ki kj dt translated">我可以<em class="lx">读取</em>关于推文、用户和通知的数据(<code class="eh lz ma mb mc b">type Query</code>列出了读取的入口点)</li><li id="e08c" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz mm kh ki kj dt translated">我可以<em class="lx">创建和删除</em>推文，并将其中一条标记为已读(<code class="eh lz ma mb mc b">type Mutation</code>列出了写入口点)</li><li id="bab1" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz mm kh ki kj dt translated">我可以<em class="lx">为给定用户订阅</em>新发布的推文(T1列出了发布/订阅入口点)</li></ul><p id="255e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每个入口点都有一个返回类型，模式列出了所有这些类型的可用字段。例如，<code class="eh lz ma mb mc b">Tweets</code>查询返回一个<code class="eh lz ma mb mc b">Tweet</code>类型的记录列表，它公开了<code class="eh lz ma mb mc b">id</code>、<code class="eh lz ma mb mc b">body</code>、<code class="eh lz ma mb mc b">date</code>、<code class="eh lz ma mb mc b">Author</code>和<code class="eh lz ma mb mc b">Stats</code>字段。这些字段也是类型化的，或者是标量类型(<code class="eh lz ma mb mc b">Int</code>、<code class="eh lz ma mb mc b">String</code>或<code class="eh lz ma mb mc b">ID</code>，类似于<code class="eh lz ma mb mc b">String</code>)，或者是自定义类型(<code class="eh lz ma mb mc b">User</code>和<code class="eh lz ma mb mc b">Stat</code>)，我也可以看到可用的字段。</p><p id="b962" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">GraphQL模式就像REST APIs的招摇过市。它包含了与服务器交互所需的所有信息。</p><p id="9bb6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">实际上，与本文不同，GraphQL的开发是模式优先的。前端和后端开发人员从商定一个模式开始。它们定义了前端和后端之间的契约。然后，每个团队开发自己的部分，没有任何惊喜。在本系列的下一篇文章中，您将会看到它是如何工作的。</p><p id="9991" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">注意</strong> : GraphQL建议主键使用<code class="eh lz ma mb mc b">ID</code>类型。这意味着GraphQL期望记录由一个<em class="lx">字符串</em>来标识。这也解释了为什么在上面的GraphQL结果中，<code class="eh lz ma mb mc b">Tweet.id</code>字段有字符串值，尽管这些值是数字。</p><p id="1141" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">注</strong>:你可能已经注意到了<code class="eh lz ma mb mc b">scalar Date</code>声明。它是大多数模式都包含的类型声明，因为GraphQL规范在默认情况下没有定义<code class="eh lz ma mb mc b">Date</code>类型！</p><h1 id="af8c" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">GraphQL是一种声明式查询语言</h1><p id="24cc" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">您可能注意到模式语法看起来很像查询语法。那是因为一样。这种类似JSON的、无逗号、无分号的语言被称为graphql语言。它用于描述类型、查询、突变、片段、订阅。有一个专门的网站<a class="ae ka" href="http://graphql.org/learn/schema/" rel="noopener ugc nofollow" target="_blank"/>，但是你已经学会了基本知识:</p><ul class=""><li id="1cf3" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz mm kh ki kj dt translated">GraphQL为<code class="eh lz ma mb mc b">String</code>、<code class="eh lz ma mb mc b">Int</code>、<code class="eh lz ma mb mc b">Float</code>、<code class="eh lz ma mb mc b">Boolean</code>和<code class="eh lz ma mb mc b">ID</code>提供了内置的标量类型。</li><li id="0fde" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz mm kh ki kj dt translated">您可以通过开始一个<code class="eh lz ma mb mc b">type</code>声明来定义一个对象类型。对象类型包含字段，每行一个。每个字段都有一个名称和一个类型，可以是对象类型，也可以是标量类型</li><li id="aba0" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz mm kh ki kj dt translated">对象字段可以有括号内的参数(如在<code class="eh lz ma mb mc b">Notifications</code>查询中)。这些参数也有类型。</li><li id="d52b" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz mm kh ki kj dt translated">必填字段的类型名称后面有一个感叹号(例如<code class="eh lz ma mb mc b">ID!</code>)</li><li id="a2b0" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz mm kh ki kj dt translated">您可以添加注释(以<code class="eh lz ma mb mc b">#</code>符号开始)</li><li id="ef64" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz mm kh ki kj dt translated">模式可以包含注释，称为<em class="lx">指令</em>(作为<code class="eh lz ma mb mc b">@deprecated</code>名称字段)</li><li id="47f4" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz mm kh ki kj dt translated">您可以通过开始一个<code class="eh lz ma mb mc b">scalar</code>声明来定义一个标量类型</li></ul><figure class="kq kr ks kt fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mr"><img src="../Images/3531ff55b006590023d2fb6701c40cf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3SWJPs18GIZ3CV85.jpg"/></div></div></figure><p id="d633" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该模式没有解释服务器如何获取结果，它描述了结果应该是什么样子。从这个意义上说，graphql语言就像SQL一样，是一种声明性语言。但是与SQL不同，GraphQL请求和响应非常相似——您总是知道会发生什么。</p><p id="f477" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">实际上，为了编写一个GraphQL查询，我首先考虑我期望的结果，例如:</p><pre class="kq kr ks kt fq md mc me mf aw mg dt"><span id="55f4" class="mh kv hu mc b fv mi mj l mk ml">{<br/>    Tweets: [<br/>        {<br/>            id: 752,<br/>            body: "consectetur adipisicing elit",<br/>            date: "2017-07-15T13:17:42.772Z",<br/>            Author: {<br/>                username: "alang",<br/>                full_name: "Adrian Lang",<br/>                avatar_url: "http://avatar.acme.com/02ac660cdda7a52556faf332e80de6d8"<br/>            },<br/>        {<br/>            id: 123,<br/>            body: "Lorem Ipsum dolor sit amet",<br/>            date: "2017-07-14T12:44:17.449Z",<br/>            Author: {<br/>                username: "creilly17",<br/>                full_name: "Carole Reilly",<br/>                avatar_url: "http://avatar.acme.com/5be5ce9aba93c62ea7dcdc8abdd0b26b"<br/>            },<br/>        },<br/>        // etc.<br/>    ],<br/>    User: {<br/>        full_name: "John Doe"<br/>    },<br/>    NotificationsMeta: {<br/>        count: 12<br/>    }<br/>}</span></pre><p id="988e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后我删除冒号、逗号和值。最后，我加入参数。结果是获得该结果的GraphQL查询:</p><pre class="kq kr ks kt fq md mc me mf aw mg dt"><span id="a657" class="mh kv hu mc b fv mi mj l mk ml">{<br/>    Tweets(limit: 10, sortField: "date", sortOrder: "DESC") {<br/>        id<br/>        body<br/>        date<br/>        Author {<br/>            username<br/>            full_name<br/>            avatar_url<br/>        }<br/>    }<br/>    User {<br/>        full_name<br/>    }<br/>    NotificationsMeta {<br/>        count<br/>    }<br/>}</span></pre><p id="d3b6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用GraphQL，我可以确定响应包含什么，而不管实现GraphQL服务器使用的是什么技术。在我的第一个GraphQL项目之后，当我明白我在第一个项目中学到的所有东西都可以直接应用到第二个项目时，我开始欣赏这个优势。</p><p id="c763" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">提示:</strong>如果你觉得在每个查询中重复你想要的字段列表很麻烦，看看GraphQL <a class="ae ka" href="http://facebook.github.io/graphql/#sec-Language.Fragments" rel="noopener ugc nofollow" target="_blank">片段</a>——它们有点像宏。</p><h1 id="fd63" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">突变和订阅</h1><p id="0a83" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">我已经解释了如何调用<code class="eh lz ma mb mc b">Query</code>:</p><pre class="kq kr ks kt fq md mc me mf aw mg dt"><span id="af13" class="mh kv hu mc b fv mi mj l mk ml">{<br/>    Tweet(id: 123) {<br/>        id<br/>        body<br/>        date<br/>    }<br/>}</span></pre><p id="9e9b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">实际上，GraphQL希望请求以定义请求所针对的入口点类型的关键字开始。在没有关键字的情况下，它退回到<code class="eh lz ma mb mc b">query</code>，但是我也可以使它显式:</p><pre class="kq kr ks kt fq md mc me mf aw mg dt"><span id="23c1" class="mh kv hu mc b fv mi mj l mk ml">query {<br/>    Tweet(id: 123) {<br/>        id<br/>        body<br/>        date<br/>    }<br/>}</span></pre><p id="7c4f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就这样，您已经学会了如何调用变异和订阅:只需在请求前加上适当的关键字:</p><pre class="kq kr ks kt fq md mc me mf aw mg dt"><span id="664b" class="mh kv hu mc b fv mi mj l mk ml">mutation {<br/>    createTweet(body: "Hello, world!") {<br/>        id<br/>        body<br/>        date<br/>    }<br/>}</span><span id="a248" class="mh kv hu mc b fv ms mj l mk ml">subscription {<br/>    tweetPublished(userId: 123) {<br/>        id<br/>        date<br/>        body<br/>        Author {<br/>            username<br/>            full_name<br/>            avatar_url<br/>        }<br/>    }<br/>}</span></pre><p id="a88d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个GraphQL查询只能包含三个关键字<code class="eh lz ma mb mc b">query</code>、<code class="eh lz ma mb mc b">mutation</code>和<code class="eh lz ma mb mc b">subscription</code>中的一个。这意味着您不能在单个查询中聚合读写操作。</p><p id="312c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">注意</strong> : GraphQL没有指定用于实时订阅的传输。通常是WebSockets，但是你可以使用iOS推送通知，长轮询，甚至电子邮件！</p><p id="7b7a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">提示:</strong>为你的请求命名<em class="lx">是一个好习惯。您可以在关键字和左括号之间添加名称，如下所示:</em></p><pre class="kq kr ks kt fq md mc me mf aw mg dt"><span id="1dc4" class="mh kv hu mc b fv mi mj l mk ml">query getTweetDetail {<br/>    Tweet(id: 123) {<br/>        id<br/>        body<br/>        date<br/>    }<br/>}</span></pre><p id="2a4e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这在客户端调试GraphQL时会很方便，因为调试工具会按名称列出客户端发出的查询。</p><h1 id="2420" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">变量和准备好的查询</h1><p id="e0ec" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">在第一个例子中，我已经请求了id为<code class="eh lz ma mb mc b">123</code>的<code class="eh lz ma mb mc b">Tweet</code>:</p><pre class="kq kr ks kt fq md mc me mf aw mg dt"><span id="4dbe" class="mh kv hu mc b fv mi mj l mk ml">----------------------------------- request<br/>POST / HTTP 1.1<br/>Host: http://graphql.acme.com/<br/>Content-Type: application/graphql<br/>{<br/>    Tweet(id: 123) {<br/>        id<br/>        body<br/>        date<br/>    }<br/>}</span></pre><p id="4e86" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了构建这样的查询，我必须将一个值(<code class="eh lz ma mb mc b">123</code>)连接或插入到一个字符串中。这为注入攻击打开了方便之门——不是SQL注入，而是GraphQL注入。</p><p id="0435" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了使这个查询安全，我可以将<code class="eh lz ma mb mc b">123</code>值转换成一个<code class="eh lz ma mb mc b">$id</code>变量，并告诉GraphQL将<code class="eh lz ma mb mc b">123</code>值绑定到这个变量。如果这听起来像SQL中的预准备语句，那是故意的。</p><p id="8939" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要在GraphQL查询中使用一个变量，我必须在查询的顶部，在左括号之前声明它，并指定它的类型。至于变量值，我可以在查询字符串中传递它，作为序列化的JSON对象:</p><pre class="kq kr ks kt fq md mc me mf aw mg dt"><span id="be88" class="mh kv hu mc b fv mi mj l mk ml">----------------------------------- request<br/>POST /?variables={"id":123} HTTP 1.1<br/>Host: http://graphql.acme.com/<br/>Content-Type: application/graphql<br/>($id: ID!) {<br/>    Tweet(id: $id) {<br/>        id<br/>        body<br/>        date<br/>    }<br/>}</span></pre><p id="f651" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，查询不会受到注入攻击。除了允许查询的可重用性，graphql变量还简化了繁琐的字符串插值和转义。</p><p id="24db" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">提示:</strong>如果你正在寻找记住GraphQL语法的方法，我推荐<a class="ae ka" href="https://raw.githubusercontent.com/sogko/graphql-shorthand-notation-cheat-sheet/master/graphql-shorthand-notation-cheat-sheet.png" rel="noopener ugc nofollow" target="_blank">Hafiz Ismail的GraphQL备忘单</a>。</p><h1 id="9f2b" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">GraphQL位于客户机和服务器之间</h1><p id="d260" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">在这一点上，开发人员经常会想:好吧，GraphQL是一种语言，但它如何转化为我的软件架构呢？</p><figure class="kq kr ks kt fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mt"><img src="../Images/60ce61b338af4491dae1543f9c312ab2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yXmioHf3g5EwWp1w.png"/></div></div></figure><p id="ed3e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">基本上，GraphQL服务器是一个API网关，是客户端和后端服务器之间的代理。后端服务器可以是任何东西(REST API、关系数据库、NoSQL数据库)。您甚至可以使用几个后端，并将它们隐藏在一个GraphQL(代理)服务器后面。</p><p id="d159" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">GraphQL服务器有多种语言，第一种是Node.js。但是如果JavaScript对您的团队没有意义，您就不必局限于它。你不需要在服务器上写太多代码——你甚至可以使用一个后端即服务工具，比如优秀的<a class="ae ka" href="https://www.graph.cool/" rel="noopener ugc nofollow" target="_blank"> GraphCool </a>来帮你处理GraphQL服务器端。</p><p id="04fe" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">客户端通常还有一个小的GraphQL SDK，帮助构建请求和解码响应。这完全是可选的，但这就是使用<em class="lx">标准</em>的优势:你不必为每个项目重写代码。</p><h1 id="b31b" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">简而言之GraphQL</h1><figure class="kq kr ks kt fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mu"><img src="../Images/9f1b587ddba418ca05ce156880748713.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0rij12ifLhz8d2Hx.png"/></div></div></figure><p id="c38c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以GraphQL是一种“查询语言”，就像HTTP动词和资源URL是REST的“查询语言”一样。但是这种语言比REST要发达和标准化得多。</p><ul class=""><li id="45e6" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz mm kh ki kj dt translated">GraphQL是一个API网关，或者说是位于数据后端前端的代理服务器。</li><li id="1935" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz mm kh ki kj dt translated">GraphQL是一种DSL，用来表达暴露给客户端的业务逻辑</li><li id="bf6a" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz mm kh ki kj dt translated">GraphQL是一种声明式查询语言。客户得到他们想要的。</li><li id="9055" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz mm kh ki kj dt translated">GraphQL是为远程过程调用而设计的，并不局限于CRUD。</li><li id="3cd9" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz mm kh ki kj dt translated">GraphQL是一种强大的静态类型语言。它使开发更快，更不容易出错。</li><li id="281e" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz mm kh ki kj dt translated">GraphQL支持读、写和订阅操作</li><li id="a07f" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz mm kh ki kj dt translated">GraphQL将重心移向客户端。客户端决定在响应中得到什么字段，而不是服务器。</li><li id="9e3d" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz mm kh ki kj dt translated">GraphQL在HTTP上工作…但不是唯一的。这是一个获取和更新数据的规范，可以在任何协议中实现</li><li id="f09b" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz mm kh ki kj dt translated">GraphQL支持在一个现成的请求中聚合和组合多个资源</li><li id="edde" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz mm kh ki kj dt translated">GraphQL服务器提供了内置的API文档</li><li id="0728" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz mm kh ki kj dt translated">GraphQL支持API进化，并允许不推荐警告</li><li id="c84b" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz mm kh ki kj dt translated">GraphQL不关心后端存储。您可以保留您的数据库，甚至可以保留您的REST API，如果它还在使用的话。</li></ul><p id="d710" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">总而言之，<em class="lx"> GraphQL不是下一个REST，它是下一个SOAP </em>，从零开始重新设计，吸取了REST最重要的经验:简单。我相信这是个好主意。</p><figure class="kq kr ks kt fq iv fe ff paragraph-image"><div class="fe ff mv"><img src="../Images/1bfa41fb7c64db24b4e28a108a919ac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/0*UGgS0HYYDq4XPDUu.gif"/></div></figure><p id="7c00" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">好了，关于GraphQL是什么，你已经看得够多了。是时候用GraphQL进行真正的开发了。在本系列的下一篇文章中，我将教你在Node.js中为一个类似Twitter的移动应用程序开发一个GraphQL服务器。</p></div><div class="ab cl mw mx hc my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="hn ho hp hq hr"><p id="0392" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="lx">原载于2017年9月5日</em><a class="ae ka" href="https://marmelab.com/blog/2017/09/05/dive-into-graphql-part-ii-anatomy-of-a-graphql-query.html" rel="noopener ugc nofollow" target="_blank"><em class="lx">marmelab.com</em></a><em class="lx">。</em></p><figure class="kq kr ks kt fq iv"><div class="bz el l di"><div class="nd ne l"/></div></figure></div></div>    
</body>
</html>