<html>
<head>
<title>Partial Application of Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数的部分应用</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/partial-application-of-functions-dbe7d9b80760?source=collection_archive---------5-----------------------#2017-03-15">https://medium.com/hackernoon/partial-application-of-functions-dbe7d9b80760?source=collection_archive---------5-----------------------#2017-03-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/a9004bb411f773193a072d07d5047d5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WAG-Kl8RlMalp0d7vNBbMQ.jpeg"/></div></div></figure><p id="dd26" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为函数提供比预期少的参数称为函数的部分应用。</p><p id="9d9a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然这个概念很简单，但它可以用来在我们日常的JavaScript中准备更强大的<em class="ka">函数构造</em>。</p><p id="0464" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">经常有人问我:“<em class="ka">你为什么要部分地应用一个函数呢？</em></p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff kb"><img src="../Images/35bef96e90d8dceef24a74e2901dc10d.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/1*OVjwnByTTBowAZVYssosmg.gif"/></div></figure><p id="8eae" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">“因为在那之后我得到的逻辑是一种美丽和功能纯洁的东西。”</em></p><blockquote class="kg"><p id="d17f" class="kh ki hu bd kj kk kl km kn ko kp jz ek translated">我们调用一个参数比预期少的函数，它返回一个接受剩余参数的函数。这叫做函数的局部应用。</p></blockquote><h1 id="53e9" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">使用function.bind()</h1><p id="0aee" class="pw-post-body-paragraph jc jd hu je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz hn dt translated">这种局部应用的风格在功能上并不酷，但我还是想让你知道这一点。</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="lt lu l"/></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">An example of Partial Application of functions using bind()</figcaption></figure><pre class="kc kd ke kf fq lz ma mb mc aw md dt"><span id="0988" class="me kr hu ma b fv mf mg l mh mi">We created a function ‘<em class="ka">add</em>’ which accepts two arguments.</span><span id="b6de" class="me kr hu ma b fv mj mg l mh mi">We preloaded it with a single argument and created a function ‘<em class="ka">increment</em>’ which takes only one argument.</span><span id="6b85" class="me kr hu ma b fv mj mg l mh mi">We created another function by the same process of Partial Application, this time by applying a different argument.</span><span id="8ce8" class="me kr hu ma b fv mj mg l mh mi">At last, we called our preloaded functions with the final argument.</span></pre><p id="e1c4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将一个函数绑定到更少的参数有助于我们生成其他函数，使我们的代码更少重复，更明确。但这也有一些问题，除了功能不够酷之外。</p><ul class=""><li id="dae4" class="mk ml hu je b jf jg jj jk jn mm jr mn jv mo jz mp mq mr ms dt translated"><strong class="je hv">太不可预测:</strong> Function.bind总是会返回另一个函数，即使我们已经向基本函数提供了所有的参数。所以我们不知道什么时候停下来。</li></ul><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff mt"><img src="../Images/68148a015ffc0ee7ddab0109f666483d.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*YQyb-Sopev0IYL9nRv1J-Q.gif"/></div></figure><ul class=""><li id="4695" class="mk ml hu je b jf jg jj jk jn mm jr mn jv mo jz mp mq mr ms dt translated">注意到代码中的'<em class="ka"> null </em>'，这是我们必须作为bind的第一个参数传递的部分应用函数的上下文。所以，每当我们部分地应用一个函数时，我们被迫附加上下文。<em class="ka">不酷！</em></li></ul><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/0d6017d6bf80fa50f8e4e459ac4c4477.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/1*UGNnM4Qapq0Rt10c3n1LOQ.gif"/></div></figure><h1 id="64f7" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb mv ld le lf mw lh li lj mx ll lm ln dt translated">Currying</h1><p id="1698" class="pw-post-body-paragraph jc jd hu je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz hn dt translated">这是一种很棒的函数式编程技术，可以用JavaScript实现，因为它能够创建更高阶的函数。Currying不是功能的部分应用，但它有助于以更具功能性的方式实现相同的目标。</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="lt lu l"/></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">Curried version of our <em class="my">add(</em>)</figcaption></figure><h2 id="dcd9" class="me kr hu bd ks mz na nb kw nc nd ne la jn nf ng le jr nh ni li jv nj nk lm nl dt translated">装订过度</h2><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff nm"><img src="../Images/5cc8eafa9ff1e4f64f9579f876c4d4d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*B2O9dTbutVK9t28AH5S4Mw.gif"/></div></figure><ul class=""><li id="8f31" class="mk ml hu je b jf jg jj jk jn mm jr mn jv mo jz mp mq mr ms dt translated"><strong class="je hv">可预测:</strong>一个定制函数总是返回另一个只有一个参数的<em class="ka">函数</em>。</li><li id="e541" class="mk ml hu je b jf nn jj no jn np jr nq jv nr jz mp mq mr ms dt translated"><strong class="je hv">棒极了:</strong>由于闭包的缘故，curried函数总是会记住所应用的参数。而且它们写成λ表达式的时候看起来那么好。😎</li><li id="4f9e" class="mk ml hu je b jf nn jj no jn np jr nq jv nr jz mp mq mr ms dt translated">纯函数:一个定制的函数总是纯函数，因为它为相同的输入生成相同的函数。</li></ul><h1 id="ed6f" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb mv ld le lf mw lh li lj mx ll lm ln dt translated">功能纯度</h1><blockquote class="kg"><p id="6b17" class="kh ki hu bd kj kk kl km kn ko kp jz ek translated">一个简化的函数总是纯的，因为它为相同的输入生成相同的函数。</p></blockquote><p id="1a00" class="pw-post-body-paragraph jc jd hu je b jf ns jh ji jj nt jl jm jn nu jp jq jr nv jt ju jv nw jx jy jz hn dt translated">对于一个函数式程序员来说，Currying是一个<em class="ka">蝙蝠侠的实用腰带</em>，我们将会看到它是如何的重要。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff nx"><img src="../Images/881038c60df0cc61eafe36137ef32b05.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/1*KQKlUCdcHx9t6jFN0Og6-g.gif"/></div></figure><p id="51e2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我想让你看看这段代码。</p><pre class="kc kd ke kf fq lz ma mb mc aw md dt"><span id="979c" class="me kr hu ma b fv mf mg l mh mi">‘Hello’.replace(/Hello/g, ‘Bye’).concat(‘!’); </span></pre><p id="9a7e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种结构被称为<em class="ka">方法链</em>，被认为是一种很好的面向对象设计。现在，如果你仔细观察，你可以看到它是如何工作的，它缺少什么。</p><p id="a129" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你好，数据正在通过兼容方法链传输，我们可以链接更多的方法，只要返回的对象与被链接的方法兼容。</p><p id="56e3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以，可以这样下去。</p><pre class="kc kd ke kf fq lz ma mb mc aw md dt"><span id="5c8d" class="me kr hu ma b fv mf mg l mh mi">‘Hello’<br/>  .replace(/Hello/g, ‘Bye’)<br/>  .concat(‘!’)<br/>  .repeat(2)  <br/>  .split('!')<br/>  .filter(x=&gt;x!='!')<br/>  .map(x=&gt;'Hello').toString();</span></pre><p id="a60a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于提供了“Hello”对象，上面的构造是可能的，如果没有提供给它们的对象，所有链接的方法都是没有价值的。<em class="ka">真可悲</em>。我可以说，这种面向对象设计的问题在于，一切都围绕着对象，一切都依赖于数据。</p><p id="9f5c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们把它功能化，</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="lt lu l"/></div></figure><pre class="kc kd ke kf fq lz ma mb mc aw md dt"><span id="3858" class="me kr hu ma b fv mf mg l mh mi">concat('!',replace(/Hello/g,'Bye','Hello'));</span></pre><p id="1c4c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">嗯，这看起来有点不太可读，<em class="ka">别担心这是函数式编程，</em>对于这种情况，我们有函数组合。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff ny"><img src="../Images/4603ee983e7f5eded0290f917a9b03ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/1*Kc1K1FOGCNA6X1ERec1BYg.gif"/></div></figure><blockquote class="kg"><p id="3fa2" class="kh ki hu bd kj kk nz oa ob oc od jz ek translated"><strong class="ak">功能组合</strong>是将两个或两个以上的功能组合产生一个新功能的过程。</p></blockquote><p id="01c4" class="pw-post-body-paragraph jc jd hu je b jf ns jh ji jj nt jl jm jn nu jp jq jr nv jt ju jv nw jx jy jz hn dt translated">好的，我们可以使用函数组合来组合我们的<em class="ka"> replace </em>和<em class="ka"> concat </em>函数，为此我们需要一个composer函数。</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="lt lu l"/></div></figure><p id="29c7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们来编写我们的函数，<strong class="je hv">但是等等，我们有一个问题</strong>，我们的编写器处理的函数只有<strong class="je hv">一个参数</strong>，但是我们的函数<em class="ka">替换了</em>并且<em class="ka"> concat </em>显然需要多个参数。</p><p id="cb17" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该是我们最喜欢的技巧了，currying</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="lt lu l"/></div></figure><p id="fb41" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">现在，我需要你仔细检查我是如何战略性地执行我的功能的，这样剩下的唯一要应用的参数就是要操作的“</em> <strong class="je hv"> <em class="ka">数据</em> </strong> <em class="ka">”。</em></p><p id="e9c3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，</p><pre class="kc kd ke kf fq lz ma mb mc aw md dt"><span id="4bcd" class="me kr hu ma b fv mf mg l mh mi">compose(replace(/Hello/g,’Bye’),concat(‘!’))(‘Hello’)</span></pre><p id="ccad" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这可以像这样继续下去，</p><pre class="kc kd ke kf fq lz ma mb mc aw md dt"><span id="4c44" class="me kr hu ma b fv mf mg l mh mi">compose(<br/> replace(/Hello/g,’Bye’),<br/> concat(‘!’),<br/> repeat(2),<br/> split('!'),<br/> filter(x=&gt;x!='!'),<br/> map(x=&gt;'Hello'),<br/> toString<br/>)(‘Hello’)</span><span id="dc7f" class="me kr hu ma b fv mj mg l mh mi">or</span><span id="2d9f" class="me kr hu ma b fv mj mg l mh mi">processHello(‘Hello’)</span></pre><p id="a081" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这在很多层面上都很酷。例如，由于我们的函数不再依赖于所提供的数据，我们可以这样做。</p><pre class="kc kd ke kf fq lz ma mb mc aw md dt"><span id="5ca1" class="me kr hu ma b fv mf mg l mh mi">[‘Hello’,’Hello world’,’Hi’].map(processHello)</span></pre><p id="6c59" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我很抱歉，我的意思是</p><pre class="kc kd ke kf fq lz ma mb mc aw md dt"><span id="4f3b" class="me kr hu ma b fv mf mg l mh mi">map(processHello)(‘Hello’,’Hello world’,’Hi’)</span></pre><p id="5135" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">嘿，恭喜你，我们刚刚写了一个无点风格的函数。你看到没有？。</p><p id="b9b6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">好吧，无点式函数是那些不提及数据的函数。这种编写函数的风格被称为无要点风格或心照不宣的编程。根据<a class="ae oe" href="https://en.wikipedia.org/wiki/Tacit_programming" rel="noopener ugc nofollow" target="_blank">维基百科</a></p><blockquote class="of og oh"><p id="dbf8" class="jc jd ka je b jf jg jh ji jj jk jl jm oi jo jp jq oj js jt ju ok jw jx jy jz hn dt translated">默认编程，也称为无点风格，是一种编程范式，其中函数定义不标识它们操作的参数(或“点”)。相反，这些定义只是组成了其他函数，其中包括操纵参数的组合子。</p></blockquote><p id="e722" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Currying和组成发挥得很好，创造了这种风格。</p><p id="b850" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Currying准备函数只接受数据作为它们的参数(其余的参数预先被部分应用),而Composition帮助组合那些部分应用的函数，以便数据可以通过它们传输。</p><p id="48d3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种风格，这种无要点的写作风格是功能纯度的试金石。因为它确认了我们的代码由更小的<em class="ka">纯函数</em>组成，否则我们将无法组合它们。</p><p id="5555" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">看，我告诉过你结果是纯的，这就是为什么你部分地应用函数。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff ol"><img src="../Images/8f435b2d7b6d23b734587c99050190ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*kzCuSk6RvoPSjU365D0ATg.gif"/></div></figure><p id="a1df" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">想象一下蝙蝠侠没有他的实用腰带，函数式Javascript没有curry是不可能的，这就是为什么像<a class="ae oe" href="https://github.com/lodash/lodash/wiki/FP-Guide" rel="noopener ugc nofollow" target="_blank"> <em class="ka"> lodash/fp </em> </a>或<a class="ae oe" href="http://ramdajs.com/" rel="noopener ugc nofollow" target="_blank"> <em class="ka"> Ramda </em> </a>这样的流行函数式编程库都带有自动定制的函数。</p><p id="2426" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">用...书写💖。</p><p id="0cce" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">感谢阅读。</p><div class="kc kd ke kf fq ab cb"><figure class="om iv on oo op oq or paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="om iv on oo op oq or paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="om iv on oo op oq or paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="of og oh"><p id="f922" class="jc jd ka je b jf jg jh ji jj jk jl jm oi jo jp jq oj js jt ju ok jw jx jy jz hn dt translated"><a class="ae oe" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是阿妹家庭的一员。我们现在<a class="ae oe" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae oe" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd ka je b jf jg jh ji jj jk jl jm oi jo jp jq oj js jt ju ok jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae oe" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae oe" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff os"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>