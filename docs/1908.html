<html>
<head>
<title>How to map a Map</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何绘制地图</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-map-a-map-12c6ef1c5b2e?source=collection_archive---------4-----------------------#2016-12-19">https://medium.com/hackernoon/how-to-map-a-map-12c6ef1c5b2e?source=collection_archive---------4-----------------------#2016-12-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="c360" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2016年接近尾声，ES6无处不在。但是ES6带来了一些新的语法和API。本文旨在回答一个非常具体的问题:如何将地图映射到数组中？</p><blockquote class="jp jq jr"><p id="4cd0" class="ir is js it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt translated"><em class="hu">TL；</em>博士:用Array.from(map，([key，value]) = &gt; value)</p></blockquote><p id="1e24" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你正在读这篇文章，说明你对更完整的答案感兴趣。为了清楚起见，我们在这里讨论的是JavaScript <a class="ae jw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="noopener ugc nofollow" target="_blank"> Map </a>类型。map的实例不提供Map方法。这篇文章是关于如何实现一个。</p><p id="191e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还感兴趣吗？如果是这样，我们将首先讨论这样做的必要性，主要是为什么你可能更喜欢使用地图而不是常规对象。</p><p id="7483" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，我们将讨论进行这种映射的不同方法。</p><h1 id="8872" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">贴图与对象</h1><blockquote class="kv"><p id="8ff5" class="kw kx hu bd ky kz la lb lc ld le jo ek translated">在进一步讨论之前，我们先试着回答一个简单的问题:为什么会有人在JavaScript中使用Map？</p></blockquote><p id="653f" class="pw-post-body-paragraph ir is hu it b iu lf iw ix iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo hn dt translated">从另一种语言来看，比如说<em class="js"> Java，</em>使用<a class="ae jw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="noopener ugc nofollow" target="_blank"> Map </a>似乎是显而易见的。但如果你来自ES6之前的世界呢？为什么要在物体上使用贴图？</p><p id="a1cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">需要说明的是，我并不提倡在任何地方都使用地图。一如既往，这是开发人员的选择，以决定什么最符合当前的情况。为了帮助你决定，我会在这里列出一些你可能更喜欢使用地图而不是普通物体的点。</p><h2 id="9ebd" class="lk jy hu bd jz ll lm ln kd lo lp lq kh jc lr ls kl jg lt lu kp jk lv lw kt lx dt translated">键入的键</h2><blockquote class="jp jq jr"><p id="a006" class="ir is js it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt translated">简而言之:你可以使用任何类型作为地图的键。不得使用Object或Array或其他对象的任何复杂类型属性。也许只使用字符串是个更好的主意。</p></blockquote><p id="514c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个普通的JavaScript对象，简单地用<code class="eh ly lz ma mb b">{}</code>创建，非常灵活。对于每个键，您可以为其分配任何其他JavaScript类型:</p><pre class="mc md me mf fq mg mb mh mi aw mj dt"><span id="1975" class="lk jy hu mb b fv mk ml l mm mn">const obj = {}; <br/>obj.first = ‘myvalue’;<br/>obj.arr = [];<br/>obj.number = 2;<br/>obj.deep = {};<br/>obj.map = new Map();</span></pre><p id="6fd4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，尽管您可以在某些地方读取内容，但您可以向对象添加一些动态键:</p><pre class="mc md me mf fq mg mb mh mi aw mj dt"><span id="338d" class="lk jy hu mb b fv mk ml l mm mn">const mykey = 'foo' + Math.random();<br/>const obj = {};<br/>obj[mykey] = 'bar';</span></pre><p id="3174" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">甚至，使用新的ES6计算属性语法:</p><pre class="mc md me mf fq mg mb mh mi aw mj dt"><span id="34b6" class="lk jy hu mb b fv mk ml l mm mn">const mykey = 'foo' + Math.random();</span><span id="6152" class="lk jy hu mb b fv mo ml l mm mn">const obj = {<br/>  [mykey]: 'bar'<br/>}</span></pre><p id="1e91" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后三个例子应该向你证明了普通的JS对象是非常灵活的。仍然有很大的不同:</p><blockquote class="kv"><p id="9626" class="kw kx hu bd ky kz la lb lc ld le jo ek translated">尽管Map可以有任何类型的键，但是来自JavaScript对象的键将被转换为字符串</p></blockquote><p id="e198" class="pw-post-body-paragraph ir is hu it b iu lf iw ix iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo hn dt translated">这种差异可能是副标题，但如果理解不正确，可能会导致有趣的错误</p><pre class="mc md me mf fq mg mb mh mi aw mj dt"><span id="d327" class="lk jy hu mb b fv mk ml l mm mn">const map = new Map();<br/>map.set(2, 'two');<br/>map.set('2', 'TWO');<br/>// Map {2 =&gt; "two", "2" =&gt; "TWO"}</span><span id="1538" class="lk jy hu mb b fv mo ml l mm mn">const obj = {};<br/>obj[2] = 'two';<br/>obj['2'] = 'TWO';<br/>obj;<br/>// Object {2: "TWO"}</span></pre><p id="7f50" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这种情况下，根据上下文，这两种行为都是有用的，但是现在，让我们试着猜测如果你试图分配一个对象会发生什么:</p><pre class="mc md me mf fq mg mb mh mi aw mj dt"><span id="560a" class="lk jy hu mb b fv mk ml l mm mn">const obj = {}<br/>const key1 = { id: 'foo' }<br/>const key2 = { id: 'bar' }</span><span id="4925" class="lk jy hu mb b fv mo ml l mm mn">obj[key1] = 'KEY1';<br/>obj[key2] = 'KEY2';</span><span id="582c" class="lk jy hu mb b fv mo ml l mm mn">obj[key1];<br/>// KEY2"</span></pre><p id="f374" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在前面的示例中，您为一个对象分配了由该对象提供的两个不同的属性值，但是当您尝试访问第一个属性值时，您将获得第二个属性值。这可能看起来很奇怪，但是如果你仔细阅读的话，这应该是符合逻辑的。如前所述，对象属性在开始使用前被转换成字符串。人们可以想象，这种转换是使用“JSON.stringify”或类似的东西来完成的，但事实要简单得多:我们只需执行“new String(prop)”。toString()` 0</p><pre class="mc md me mf fq mg mb mh mi aw mj dt"><span id="55ee" class="lk jy hu mb b fv mk ml l mm mn">String(key1).toString() <br/>// "[object Object]"</span><span id="3e4b" class="lk jy hu mb b fv mo ml l mm mn">String(key2).toString() <br/>// "[object Object]"</span><span id="aa46" class="lk jy hu mb b fv mo ml l mm mn">new String(key1).toString() === new String(key2).toString()</span></pre><p id="54f6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有了前面的例子，现在就很容易理解为什么使用复杂类型(如Object、Arrays或Map)作为属性名不是一个好主意了。如前所述，您可以在访问您的属性之前使用序列化层，但是如果您的key对象在赋值和访问之间被修改，那么这会给您带来与map不同的行为。</p><h1 id="f6b0" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">内置方法和属性</h1><p id="fe6b" class="pw-post-body-paragraph ir is hu it b iu mp iw ix iy mq ja jb jc mr je jf jg ms ji jj jk mt jm jn jo hn dt translated">我们之前已经看到，如果您需要使用复杂的键作为属性名，您最好使用Map。但是有更多的原因。其中之一是内置方法的可用性。</p><p id="728c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">地图对象最有用的内置属性可能是<code class="eh ly lz ma mb b">size</code>。它可能不需要进一步解释，只需返回地图中元素的当前数量。为什么有人更喜欢做<code class="eh ly lz ma mb b">map.size</code>而不是<code class="eh ly lz ma mb b">Object.keys(obj).length</code>，这可能很明显。</p><p id="a452" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">其他的实例方法，比如<code class="eh ly lz ma mb b">map.keys()</code>、<code class="eh ly lz ma mb b">map.values()</code>和<code class="eh ly lz ma mb b">map.entries()</code>，也非常类似于我们用相应的静态对象方法得到的，但是有一个主要的区别:它们返回迭代器而不是数组。我不会在这里深入讨论细节，但是我会在本文的第二部分回到这个问题。</p><p id="2d40" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，提供了另一个方法作为帮助函数，它是<code class="eh ly lz ma mb b">map.has(key)</code>，并且对应于<code class="eh ly lz ma mb b">obj.hasOwnProperty(key)</code>方法。</p><p id="d336" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ly lz ma mb b">Map</code>还有一些方法。下一节将提供其中大部分的详细信息。</p><h1 id="97bd" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">使用它有一个共享参考</h1><p id="f65e" class="pw-post-body-paragraph ir is hu it b iu mp iw ix iy mq ja jb jc mr je jf jg ms ji jj jk mt jm jn jo hn dt translated">除了将复杂对象作为关键特性之外，使用Map的原因之一是将它作为跨对象的共享引用，这是一种纯粹的POO风格。</p><p id="bf08" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个映射可以是单个的，或者简单地跨实例共享，但是可以被实例修改。这与JavaScript世界一成不变的趋势完全相反，但同样，一切都与上下文有关。</p><p id="d172" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">来到便便世界，<code class="eh ly lz ma mb b">map.get</code>和<code class="eh ly lz ma mb b">map.set</code>会觉得很自然。此外，在纯CRUD风格中，您可能希望能够从地图中删除一个元素。这里你可以使用<code class="eh ly lz ma mb b">map.delete</code>方法，你必须承认，这种方法比<code class="eh ly lz ma mb b">delete obj.key</code>感觉要简单得多</p><p id="ba32" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，您还有<code class="eh ly lz ma mb b">map.clear</code>方法，它允许您将地图重置为空状态。</p><h1 id="9336" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">循环</h1><p id="c217" class="pw-post-body-paragraph ir is hu it b iu mp iw ix iy mq ja jb jc mr je jf jg ms ji jj jk mt jm jn jo hn dt translated">Map对象最流行的特性之一是迭代特性。事实上，Map和他的新伙伴一起到来了，新的<code class="eh ly lz ma mb b">for...of</code>语法。</p><p id="489e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ly lz ma mb b">for...of</code>语法允许您编写代码，例如:</p><pre class="mc md me mf fq mg mb mh mi aw mj dt"><span id="95f3" class="lk jy hu mb b fv mk ml l mm mn">let iterable = new Map([["a", 1], ["b", 2], ["c", 3]]);<br/><br/>for (let entry of iterable) {<br/>  console.log(entry);<br/>}<br/>// [a, 1]<br/>// [b, 2]<br/>// [c, 3]<br/><br/>for (let [key, value] of iterable) {<br/>  console.log(value);<br/>}<br/>// 1<br/>// 2<br/>// 3</span></pre><blockquote class="jp jq jr"><p id="1098" class="ir is js it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt translated">摘自<a class="ae jw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of#Iterating_over_a_Map" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Statements/for...的# iteration _ over _ a _ Map</a></p></blockquote><p id="784c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就我个人而言，我不太喜欢C风格的迭代，更喜欢使用高阶函数。看来我不是唯一的一个，因为这也是著名的<a class="ae jw" href="https://github.com/airbnb/javascript#iterators--nope" rel="noopener ugc nofollow" target="_blank"> Airbnb风格指南</a>的一部分。</p><h1 id="fa8a" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">绘制地图的不同方法</h1><p id="72ab" class="pw-post-body-paragraph ir is hu it b iu mp iw ix iy mq ja jb jc mr je jf jg ms ji jj jk mt jm jn jo hn dt translated">不，我们有了基本的地图，我们现在将尝试解决最初的问题</p><h2 id="0eec" class="lk jy hu bd jz ll lm ln kd lo lp lq kh jc lr ls kl jg lt lu kp jk lv lw kt lx dt translated">为了…的</h2><p id="8bb7" class="pw-post-body-paragraph ir is hu it b iu mp iw ix iy mq ja jb jc mr je jf jg ms ji jj jk mt jm jn jo hn dt translated">如果您喜欢<code class="eh ly lz ma mb b">for...of</code>语法，您可能不喜欢函数式方法，也不喜欢不可变方法。如果是这样，那么您可能只是想使用下面的语法来映射一个映射。</p><pre class="mc md me mf fq mg mb mh mi aw mj dt"><span id="1f95" class="lk jy hu mb b fv mk ml l mm mn">const iterable = new Map([["a", 1], ["b", 2], ["c", 3]]);</span><span id="dc6f" class="lk jy hu mb b fv mo ml l mm mn">const squareValues = [];</span><span id="b18a" class="lk jy hu mb b fv mo ml l mm mn">for (let [key, value] of iterable) {<br/>  <!-- -->squareValues.push(value * value);<br/>}<br/>squareValues;<br/>// [1, 4, 9]</span></pre><blockquote class="jp jq jr"><p id="e9d2" class="ir is js it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt translated">如果你这样做，我会很难过，因为整篇文章的目标就是让你避免使用这种语法。</p></blockquote><p id="7327" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们以前没有描述过它，但是这种语法是可能的，因为Map是一个可迭代的对象——这就是<code class="eh ly lz ma mb b">map.keys()</code>和<code class="eh ly lz ma mb b">map.values()</code>的返回。</p><h2 id="89b2" class="lk jy hu bd jz ll lm ln kd lo lp lq kh jc lr ls kl jg lt lu kp jk lv lw kt lx dt translated">为每一个</h2><p id="df5a" class="pw-post-body-paragraph ir is hu it b iu mp iw ix iy mq ja jb jc mr je jf jg ms ji jj jk mt jm jn jo hn dt translated">在已经描述过的Map实例方法之上，还有一个尚未讨论的方法:<code class="eh ly lz ma mb b">map.forEach</code></p><p id="3757" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里提供的forEach方法与数组提供的forEach方法非常相似。使用与Array相同的语法，实现map方法相当容易。</p><pre class="mc md me mf fq mg mb mh mi aw mj dt"><span id="cfd5" class="lk jy hu mb b fv mk ml l mm mn"><strong class="mb hv">const</strong> mapMap <strong class="mb hv">=</strong> <strong class="mb hv">function</strong>(map, mapFunction){<br/><br/>  <strong class="mb hv">const</strong> toReturn <strong class="mb hv">=</strong> [];<br/>  map.forEach(<strong class="mb hv">function</strong>(value, key){ // be careful to the args order<br/>    toReturn.push(mapFunction(value, key));<br/>  })<br/><br/>  <strong class="mb hv">return</strong> toReturn;<br/>}</span></pre><p id="e9ff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用这种语法对我来说没问题，但是仍然显示了一个循环和<code class="eh ly lz ma mb b">toReturn</code>数组的变异。这在utils文件中是可以的，但是我们可能不希望到处都这样污染我们的代码。我的目标是一个纯粹的原生函数式语法。</p><h2 id="68ec" class="lk jy hu bd jz ll lm ln kd lo lp lq kh jc lr ls kl jg lt lu kp jk lv lw kt lx dt translated">数组. from</h2><p id="7445" class="pw-post-body-paragraph ir is hu it b iu mp iw ix iy mq ja jb jc mr je jf jg ms ji jj jk mt jm jn jo hn dt translated">我们最近讨论了这样一个事实，即我们所追求的<code class="eh ly lz ma mb b">map</code>方法在Array上是可用的。也许一个好的解决方案是将我们的map实现为一个数组，以便调用Map方法。此外，我们还描述了映射是可迭代的。</p><p id="75fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，自ES6规范以来，新的静态方法现在在Array上可用。其中之一就是<code class="eh ly lz ma mb b">Array.from</code>法。它允许复制一个数组，将一个类似数组的对象转换成一个数组，也可以将一个可迭代的对象转换成一个数组。</p><p id="f106" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">人们现在可以这样写:</p><pre class="mc md me mf fq mg mb mh mi aw mj dt"><span id="0ae8" class="lk jy hu mb b fv mk ml l mm mn">Array.from(p).map( ([key, value]) =&gt; value * value )</span></pre><p id="2f91" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我认为这开始感觉很好。我们将地图转换成数组，然后在上面应用地图。我们还能希望什么？这样做是不是只有一个操作？好消息，这是可能的。</p><p id="3844" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">实际上，可以用第二个可选参数调用Array.from方法，对应于一个映射方法。</p><p id="3310" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我们可以做:</p><pre class="mc md me mf fq mg mb mh mi aw mj dt"><span id="fc27" class="lk jy hu mb b fv mk ml l mm mn">Array.from(p, ([key, value]) =&gt; value * value)</span></pre><p id="f0ef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对我来说，这是回答最初问题的最佳方式:“如何在地图上绘制地图”</p><h1 id="2e2e" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">结论</h1><p id="549b" class="pw-post-body-paragraph ir is hu it b iu mp iw ix iy mq ja jb jc mr je jf jg ms ji jj jk mt jm jn jo hn dt translated">有时候用地图代替一个物体真的很有意义。当出现这种情况时，有时仍然需要应用map方法将一个Map变换成一个数组的变换对象。在这样做的时候，对我来说最好的方法是使用带有两个参数的Array.from方法，一个用于映射，另一个用于映射函数。</p><blockquote class="jp jq jr"><p id="1698" class="ir is js it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt translated"><a class="ae jw" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jw" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jw" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jw" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is js it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt translated">要了解更多信息，<a class="ae jw" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">请阅读我们的“关于”页面</a>，<a class="ae jw" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae jw" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is js it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jw" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jw" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>