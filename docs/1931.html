<html>
<head>
<title>Build your first Facebook Messenger bot in Ruby with Sinatra (Part 2/3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Ruby和Sinatra构建你的第一个Facebook Messenger机器人(第2/3部分)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/build-your-first-facebook-messenger-bot-in-ruby-with-sinatra-part-2-3-b3d929a4606d?source=collection_archive---------1-----------------------#2016-12-21">https://medium.com/hackernoon/build-your-first-facebook-messenger-bot-in-ruby-with-sinatra-part-2-3-b3d929a4606d?source=collection_archive---------1-----------------------#2016-12-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="93ba" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">跟上对话</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/9928d07b323abb4254a671690ef166e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t3zy_6PNhjCCzwGITa5HEA.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">A less obscure cultural reference</figcaption></figure><p id="4dc2" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在本教程的第一部分中，我们在<a class="ae kv" href="https://hackernoon.com/tagged/facebook" rel="noopener ugc nofollow" target="_blank">脸书</a>上建立了我们的页面，并通过<a class="ae kv" href="https://ngrok.com/" rel="noopener ugc nofollow" target="_blank"> ngrok </a>将其连接到运行在我们机器上的<a class="ae kv" href="http://www.sinatrarb.com/" rel="noopener ugc nofollow" target="_blank"> Sinatra </a>服务器。然后我们介绍了<a class="ae kv" href="https://github.com/hyperoslo/facebook-messenger" rel="noopener ugc nofollow" target="_blank"><strong class="kb hv">Facebook-messenger</strong></a>gem，由<a class="ae kv" href="http://www.hyper.no/" rel="noopener ugc nofollow" target="_blank">hyperslo</a>的家伙们开发。我们还教我们的机器人使用<a class="ae kv" href="https://developers.google.com/maps/documentation/geocoding/intro" rel="noopener ugc nofollow" target="_blank">谷歌地理编码API </a>来查找任何给定地址的GPS坐标。这就是我们的机器人在我们对其进行更多干预后的样子:</p><div class="jk jl jm jn fq ab cb"><figure class="kw jo kx ky kz la lb paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><img src="../Images/55879c50bed41cf2a53b5aa6b7d16209.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*y2Qkgfiin8gK2__ZCYPmZA.png"/></div></figure><figure class="kw jo kx ky kz la lb paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><img src="../Images/c048a97dca6b76ab8872c84cbd9410e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*5MZ5KG8DpwyXE-szbJDduA.png"/></div></figure><figure class="kw jo kx ky kz la lb paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><img src="../Images/a55abba466845d8204e7331ab10a9e15.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*WdWeo5rCgkvtzfVwYqz44Q.png"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek lc di ld le">Chatting with the bot on mobile</figcaption></figure></div><h1 id="fd72" class="lf lg hu bd lh li lj lk ll lm ln lo lp ja lq jb lr jd ls je lt jg lu jh lv lw dt translated"><strong class="ak">跟我说话</strong></h1><p id="bb4e" class="pw-post-body-paragraph jz ka hu kb b kc lx iv ke kf ly iy kh ki lz kk kl km ma ko kp kq mb ks kt ku hn dt translated">好了，让我们先把关于信使机器人的事情搞清楚。<strong class="kb hv">他们遵守</strong> <a class="ae kv" href="https://en.wikipedia.org/wiki/Victorian_era" rel="noopener ugc nofollow" target="_blank"> <strong class="kb hv">维多利亚时代</strong> </a> <strong class="kb hv">对小娃儿的礼仪</strong>:</p><blockquote class="mc"><p id="1a97" class="md me hu bd mf mg mh mi mj mk ml ku ek translated">“除非有人跟你说话，否则不要说话”</p></blockquote><p id="dd80" class="pw-post-body-paragraph jz ka hu kb b kc mm iv ke kf mn iy kh ki mo kk kl km mp ko kp kq mq ks kt ku hn dt translated">这是一个很好的规则，因为它有助于避免不请自来的消息，也就是垃圾邮件。但是我们如何提供请求的消息呢？在我们机器人的第一个极简版本中，我们只是假设用户会给我们一些东西，我们可以直接发送到谷歌地理编码API，等待响应并显示结果。这假设用户事先知道我们的机器人的意图，这是一个非常糟糕的UX方式。此外，我们没有为用户输入任何没有GPS坐标的内容提供任何支持(令人惊讶的是，“Hello”会产生一个结果，因为谷歌只会假设我们正在寻找<a class="ae kv" href="https://en.wikipedia.org/wiki/Hella,_Iceland" rel="noopener ugc nofollow" target="_blank"> Hella，冰岛</a>)——在这种情况下，我们的机器人将完全失去理智。我们需要某种<strong class="kb hv">对话循环</strong>。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="ab fr cl mr"><img src="../Images/b8a8326b115ba3c8fde1f511db0fc64c.png" data-original-src="https://miro.medium.com/v2/format:webp/1*gdtDrJnZukgGsXSRYdBjQA.jpeg"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><a class="ae kv" href="http://poorlydrawnlines.com/" rel="noopener ugc nofollow" target="_blank">Poorly Drawn Lines</a> by Reza Farazmand is licensed under a <a class="ae kv" href="https://creativecommons.org/licenses/by-nc/3.0/" rel="noopener ugc nofollow" target="_blank">CC BY-NC 3.0</a></figcaption></figure><p id="8c27" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我在尝试用<strong class="kb hv"> facebook-messenger </strong> gem实现它时学到的第一件事是:<code class="eh ms mt mu mv b">Bot.on :message { |…| block }</code>调用只能在每个作用域内<strong class="kb hv">调用一次，否则我们会面临各种各样的意外行为(如果我错了请<em class="mw">纠正我)。<strong class="kb hv">所以</strong> <strong class="kb hv">我们需要创建更多的作用域</strong>！好吧，让我们定义不同的方法来处理我们对话的不同方式，从最明显的开始。在<strong class="kb hv"> bot.rb </strong>中，删除你的Bot.on方法，该方法使用一个块并替换为:</em></strong></p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="cc7f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在我们需要添加一个在我们的<code class="eh ms mt mu mv b">wait_for_user_input</code>中引用的<code class="eh ms mt mu mv b">process_coordinates</code>方法。把这个放进你的<strong class="kb hv"> bot.rb </strong>:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="188f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在在<strong class="kb hv"> bot.rb的底部</strong>调用我们的等待方法。它将启动对话循环:</p><pre class="jk jl jm jn fq mz mv na nb aw nc dt"><span id="bd08" class="nd lg hu mv b fv ne nf l ng nh">wait_for_user_input</span></pre><p id="6036" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">从现在开始，如果用户在任何上下文中提到“坐标”(“coord”作为快捷方式)或“gps”，我们将只与他联系。然后，我们将要求用户提供一个查找的目的地，然后我们将调用谷歌和显示结果。如果没有找到结果，我们将通知用户并等待另一个命令。现阶段我们的<strong class="kb hv"> code.rb </strong>看起来就像<a class="ae kv" href="https://github.com/progapandist/coordinator-bot/blob/part-2-1/bot.rb" rel="noopener ugc nofollow" target="_blank">这个</a>。在<code class="eh ms mt mu mv b">rackup</code>运行的情况下点击标签中的<code class="eh ms mt mu mv b">Ctrl-C</code>，重启服务器在Messenger中进行测试。</p></div><div class="ab cl ni nj hc nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="hn ho hp hq hr"><h1 id="312d" class="lf lg hu bd lh li np lk ll lm nq lo lp ja nr jb lr jd ns je lt jg nt jh lv lw dt translated">好吧，这似乎行得通。让我们添加功能！</h1><p id="b3ca" class="pw-post-body-paragraph jz ka hu kb b kc lx iv ke kf ly iy kh ki lz kk kl km ma ko kp kq mb ks kt ku hn dt translated">如果我们深入研究从Google返回的JSON，我们会发现有一个名为T5的键，它将返回Google可以找到的任何目的地的完整邮政地址。让我们把它作为一个特性添加到我们的机器人中。</p><p id="93e4" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">首先，向我们的<code class="eh ms mt mu mv b">wait_for_user_input</code>方法添加另一个<code class="eh ms mt mu mv b">when</code>子句:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="a78d" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">请注意，我们认为用户拼错了“地址”:如果他/她键入“我需要一个完整的地址”(这是我会犯的一种错误)，我们的<a class="ae kv" href="https://en.wikipedia.org/wiki/Regular_expression" rel="noopener ugc nofollow" target="_blank"> regexp </a>仍然匹配，并且<code class="eh ms mt mu mv b">show_full_address </code>函数将被调用。也放在<strong class="kb hv"> bot.rb </strong>里面:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="1eb5" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">最后，添加这个助手方法:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="fc9b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">太好了。这是你在这个点的<a class="ae kv" href="https://github.com/progapandist/coordinator-bot/blob/part-2-2/bot.rb" rel="noopener ugc nofollow" target="_blank">代码。重启服务器并测试。</a></p></div><div class="ab cl ni nj hc nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="hn ho hp hq hr"><h1 id="b804" class="lf lg hu bd lh li np lk ll lm nq lo lp ja nr jb lr jd ns je lt jg nt jh lv lw dt translated"><strong class="ak">该重构了！</strong></h1><p id="5ceb" class="pw-post-body-paragraph jz ka hu kb b kc lx iv ke kf ly iy kh ki lz kk kl km ma ko kp kq mb ks kt ku hn dt translated">我们的机器人肯定可以工作，可以处理两种不同的命令，但是它的代码肯定可以使用一些重构:<code class="eh ms mt mu mv b">process_coordinates</code>和<code class="eh ms mt mu mv b">show_full_address</code>方法80%相同，这意味着<strong class="kb hv">我们可以做得更好</strong>。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="ab fr cl mr"><img src="../Images/2f2cd04536db94d2ea5cd7ac4c82910c.png" data-original-src="https://miro.medium.com/v2/format:webp/1*X_dQ1cIDUp5P2iu2r1TaZA.jpeg"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Refactoring can sure get messy</figcaption></figure><p id="7b8b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们知道<a class="ae kv" href="https://hackernoon.com/tagged/ruby" rel="noopener ugc nofollow" target="_blank"> Ruby </a>方法可以<a class="ae kv" href="http://rubylearning.com/satishtalim/ruby_blocks.html" rel="noopener ugc nofollow" target="_blank">接受块</a>。看起来我们可能会从这个语言特性中受益，让我们的代码<a class="ae kv" href="https://en.wikipedia.org/wiki/Don't_repeat_yourself" rel="noopener ugc nofollow" target="_blank">变得枯燥</a>-呃。让我们定义另一个方法，它将抽象出大多数API处理功能:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="1bfd" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">那么我们可以把<code class="eh ms mt mu mv b">both process_coordinates</code>和<code class="eh ms mt mu mv b">show_full_address</code>改成这样:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="4693" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">太好了。现在，我们的方法只做实际上特定于它们的目的的事情，其余的由我们处理API相关逻辑的通用方法来处理。</p><p id="df9b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我知道，带有参数的Ruby <code class="eh ms mt mu mv b">yield</code>的概念可能很难理解，尤其是如果你像我一样是一个初学者，但是我喜欢把它想象成连接两个方法的<strong class="kb hv">时空扭曲，你可以来回传递变量。</strong></p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="ab fr cl mr"><img src="../Images/91696b8ab4ac12f35e5f05211b917df3.png" data-original-src="https://miro.medium.com/v2/format:webp/1*YA_Y6-2g4QoOXr5cjOttWQ.jpeg"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">This is how I imagine Ruby <strong class="bd nu">yield</strong> that takes an argument inside a method (Almost)</figcaption></figure><p id="9de1" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">当我们这样做的时候，让我们也创建一个<code class="eh ms mt mu mv b">IDIOMS</code>常量，这样我们就可以把我们的机器人的所有短语放在一个地方。将它添加到您的<strong class="kb hv"> bot.rb </strong>的顶部:</p><pre class="jk jl jm jn fq mz mv na nb aw nc dt"><span id="3b56" class="nd lg hu mv b fv ne nf l ng nh">IDIOMS = {<br/>  not_found: 'There were no resutls. Ask me again, please',<br/>  ask_location: 'Enter destination'<br/>}</span></pre><p id="3d24" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在，将您的硬编码回复替换为对<code class="eh ms mt mu mv b">IDIOMS</code>的引用，如下所示:</p><pre class="jk jl jm jn fq mz mv na nb aw nc dt"><span id="bdcc" class="nd lg hu mv b fv ne nf l ng nh">message.reply(text: IDIOMS[:ask_location])</span></pre><p id="1c1b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这是你这个阶段的<a class="ae kv" href="https://github.com/progapandist/coordinator-bot/blob/part-2-3/bot.rb" rel="noopener ugc nofollow" target="_blank">代码</a>。重启你的服务器<strong class="kb hv">测试测试</strong>。</p></div><div class="ab cl ni nj hc nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="hn ho hp hq hr"><h1 id="207d" class="lf lg hu bd lh li np lk ll lm nq lo lp ja nr jb lr jd ns je lt jg nt jh lv lw dt translated"><strong class="ak">不只是说说而已</strong></h1><p id="d339" class="pw-post-body-paragraph jz ka hu kb b kc lx iv ke kf ly iy kh ki lz kk kl km ma ko kp kq mb ks kt ku hn dt translated">很好，我们的机器人仍然工作，我们使用了一些聪明的红宝石，但它仍然不是最好的用户体验。用户应该如何知道该做什么？我们能引导他吗？对话式人工智能的承诺还没有真正实现，现在我们还停留在混合界面上。<a class="ae kv" href="https://core.telegram.org/bots/2-0-intro" rel="noopener ugc nofollow" target="_blank">大家都在</a>做<a class="ae kv" href="http://venturebeat.com/2016/07/06/until-a-i-gets-better-buttons-are-a-bridge-for-chatbots/" rel="noopener ugc nofollow" target="_blank">做</a>做<a class="ae kv" href="https://techcrunch.com/2016/07/01/shatbots/" rel="noopener ugc nofollow" target="_blank">做</a>。Facebook Messenger目前有三种(据我所知)向用户显示“菜单”的方式:</p><ol class=""><li id="5338" class="nv nw hu kb b kc kd kf kg ki nx km ny kq nz ku oa ob oc od dt translated">可以从文本输入字段旁边的图标中调用的持久菜单。</li><li id="4f32" class="nv nw hu kb b kc oe kf of ki og km oh kq oi ku oa ob oc od dt translated">一个“按钮”模板，让您可以将动作按钮绑定到一个消息气泡上。</li><li id="191e" class="nv nw hu kb b kc oe kf of ki og km oh kq oi ku oa ob oc od dt translated">一套“快速回复”。</li></ol><div class="jk jl jm jn fq ab cb"><figure class="kw jo oj ky kz la lb paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><img src="../Images/b0ed1c39c91928ae5fbbb22ab861566f.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*ah75MOExRLHe3JdFtodLFA.png"/></div></figure><figure class="kw jo ok ky kz la lb paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><img src="../Images/5ab13139909963eff0596a86e70d4822.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*Wkpx8zf7Cs7KOvNSr3jUhw.png"/></div></figure><figure class="kw jo ol ky kz la lb paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><img src="../Images/b0d18054794adc19fa439c0bc29632d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*_8EbL96JwDuC8t1GiIVKQQ.png"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek om di on le">Three Facebook-approved ways of presenting button menus to user</figcaption></figure></div><p id="693e" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们将选择<a class="ae kv" href="https://developers.facebook.com/docs/messenger-platform/send-api-reference/quick-replies" rel="noopener ugc nofollow" target="_blank"> <strong class="kb hv">快速回复</strong> </a>，因为我觉得它们更人性化。它们也被API视为常规消息，而其他按钮实现对webhook的<a class="ae kv" href="https://developers.facebook.com/docs/messenger-platform/send-api-reference/postback-button" rel="noopener ugc nofollow" target="_blank">“回发”</a>调用，这是一个有点不同的概念，我们将在后面看到。</p><p id="287d" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">首先，创建constant以将您的快速回复保存在一个地方:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="c5a1" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">“Payload”听起来令人困惑，但这实际上只是您可以分配给用户交互的另一个标识符。把它想成一个常数，所以我们用<code class="eh ms mt mu mv b">CAPITAL_LETTERS</code>来表示我们的有效载荷。</p><p id="586d" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">好了，现在我们要写一个小方法，它将在将来帮助我们在编写机器人消息时采用更多的<a class="ae kv" href="https://en.wikipedia.org/wiki/Declarative_programming" rel="noopener ugc nofollow" target="_blank">声明性</a>方法。还记得我告诉过你机器人只会在别人跟他们说话的时候说话吗？嗯，在某种程度上这是真的。用户必须<a class="ae kv" href="https://developers.facebook.com/docs/messenger-platform/product-overview/entry-points#others" rel="noopener ugc nofollow" target="_blank">做一些</a>会<strong class="kb hv">暴露其ID </strong>的事情。比如，发送第一条消息或者使用一个链接到你的脸书的页面地址(你的机器人在那里生活和处理它的信使交互)。</p><p id="f235" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">因此，除了我们之前看到的<code class="eh ms mt mu mv b">Bot.on :message { |…| block }</code>之外，<strong class="kb hv"> facebook-messenger </strong> gem的创建者还给了我们<code class="eh ms mt mu mv b">Bot.deliver</code>方法，一旦我们有了用户的脸书ID，就可以给用户发送消息。我们将把它包装成我们自己的<code class="eh ms mt mu mv b">say</code>助手:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="ae20" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">它将接受一个用户的id，一个我们想要发送的消息的文本和一个快速回复数组的可选参数。如果提供了一个参数，消息将被发送并附有快速回复，如果没有，它将只是一个文本。</p><p id="356d" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">从<a class="ae kv" href="https://chatbotslife.com/" rel="noopener ugc nofollow" target="_blank">聊天机器人生活</a>中的这篇<a class="ae kv" href="https://chatbotslife.com/what-10-billion-messages-can-teach-us-about-making-chatbots-fb796781bb4a#.oy73pes67" rel="noopener ugc nofollow" target="_blank">精彩文章</a>中，我们知道大多数用户会以某种形式的“<em class="mw">嗨</em>”或“<em class="mw">你好</em>”与机器人交谈。我们希望我们的机器人尽可能快地呈现菜单上的内容，而没有任何不必要的meet &amp; greet，所以我们会稍微作弊:我们将引入<code class="eh ms mt mu mv b">wait_for_any_input</code>方法，该方法将呈现我们对用户发送给我们的任何内容的快速回复，无论是“<em class="mw"> hi </em>”、“<em class="mw"> bonjour </em>还是“<em class="mw"> привет </em>”。添加到<strong class="kb hv"> bot.rb </strong>:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="f77a" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><code class="eh ms mt mu mv b">message.sender[‘id’]</code>是我们如何在用户打开对话后获取他的ID。</p><p id="6326" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">此外，让我们将我们的旧<code class="eh ms mt mu mv b">wait_for_user_input</code>方法的名称改为<code class="eh ms mt mu mv b">wait_for_command</code>，以避免任何歧义。确保更改定义和所有可能的调用。</p><p id="773c" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">另外，确保在我们的<strong class="kb hv"> bot.rb </strong>的最后，你现在给<code class="eh ms mt mu mv b">wait_for_any_input</code>打电话:</p><pre class="jk jl jm jn fq mz mv na nb aw nc dt"><span id="5642" class="nd lg hu mv b fv ne nf l ng nh"># launch the loop<br/>wait_for_any_input</span></pre><p id="af15" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">让我们更新我们的<code class="eh ms mt mu mv b">IDIOMS</code>:</p><pre class="jk jl jm jn fq mz mv na nb aw nc dt"><span id="f6e6" class="nd lg hu mv b fv ne nf l ng nh">IDIOMS = {<br/>  not_found: 'There were no resutls. Ask me again, please',<br/>  ask_location: 'Enter destination',<br/>  unknown_command: 'Sorry, I did not recognize your command',<br/>  menu_greeting: 'What do you want to look up?'<br/>}</span></pre><p id="2873" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">然后让我们定义我们的<code class="eh ms mt mu mv b">show_replies_menu</code>方法:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="7e37" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">它使用我们的<code class="eh ms mt mu mv b">say</code>助手给用户发送菜单。然后它调用我们的<code class="eh ms mt mu mv b">wait_for_command</code>来处理用户接下来做的任何事情。注意，我们选择了快速回复的措辞来匹配<code class="eh ms mt mu mv b">wait_for_command</code>中所有可能的正则表达式。同时，用户没有义务选择任何快速回复。他可以对我们大喊，比如“给我坐标，你这个愚蠢的机器人！他的命令仍然会被处理，因为我们的正则表达式是不区分大小写的。现在让我们在switch语句中添加一个<code class="eh ms mt mu mv b">else </code>子句，以处理我们所知的命令都不匹配的情况。这是我们新改进的<code class="eh ms mt mu mv b">wait_for_command</code>:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="d834" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">到目前为止，当API请求失败时，用户不得不再次键入类似“<em class="mw">坐标</em>或“<em class="mw">完整地址</em>”的内容来重新开始整个过程。这不是很酷，所以如果API没有返回任何结果，让我们更新我们的<code class="eh ms mt mu mv b">handle_api_request</code>来重试最后一个命令。为此，我们将使用一些<a class="ae kv" href="https://en.wikipedia.org/wiki/Metaprogramming" rel="noopener ugc nofollow" target="_blank"> <strong class="kb hv">元编程</strong> </a> ( <em class="mw">这是我最喜欢Ruby的一点！</em>)。看:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mx my l"/></div></figure></div><div class="ab cl ni nj hc nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="hn ho hp hq hr"><h1 id="0b2a" class="lf lg hu bd lh li np lk ll lm nq lo lp ja nr jb lr jd ns je lt jg nt jh lv lw dt translated"><strong class="ak">通过螺纹</strong></h1><p id="1b0c" class="pw-post-body-paragraph jz ka hu kb b kc lx iv ke kf ly iy kh ki lz kk kl km ma ko kp kq mb ks kt ku hn dt translated">现在你的机器人应该是可测试的了。最后，我们将调整一些<strong class="kb hv">线程设置</strong>，这样我们的用户会得到适当的问候，并显示“开始”按钮，允许开始对话。我们还将添加一个持久的菜单，让用户不断访问这两个功能，即使他正在做别的事情。下面是它的样子:</p><div class="jk jl jm jn fq ab cb"><figure class="kw jo kx ky kz la lb paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><img src="../Images/5356094a8e95fe494504ae6b05b476b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*F4dqMOFpHpOCDGqq_BqgGg.png"/></div></figure><figure class="kw jo kx ky kz la lb paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><img src="../Images/7e5697396e95bd1f21fa4db648013c3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*8-6zpraYz9T8WbAYGCbkgA.png"/></div></figure><figure class="kw jo kx ky kz la lb paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><img src="../Images/dc3bf894ba4dd064a6eb9a5571373243.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*R19qWxa9sgOrJST6OEL_4A.png"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek lc di ld le">Making our bot nicer</figcaption></figure></div><p id="b025" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这将需要我们使用<strong class="kb hv"> facebook-messenger </strong>的<code class="eh ms mt mu mv b">Bot.on :postback { |..| block }</code>功能。首先，进入你的脸书开发者控制台，在<strong class="kb hv">“web hooks”</strong>下点击<strong class="kb hv">“编辑事件”</strong>并启用<strong class="kb hv"> messaging_postbacks </strong>。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="ab fr cl mr"><img src="../Images/0c74888bdf3b88673113a3d16a1ffe78.png" data-original-src="https://miro.medium.com/v2/format:webp/1*bTfJwk1dEM1JGqcpQNngfQ.png"/></div></figure><p id="5266" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">将此添加到您的<strong class="kb hv"> bot.rb </strong>:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="7015" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在添加一些逻辑来处理回发事件:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mx my l"/></div></figure></div><div class="ab cl ni nj hc nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="hn ho hp hq hr"><h1 id="5a40" class="lf lg hu bd lh li np lk ll lm nq lo lp ja nr jb lr jd ns je lt jg nt jh lv lw dt translated"><strong class="ak">第2部分到此结束！</strong></h1><p id="d9a0" class="pw-post-body-paragraph jz ka hu kb b kc lx iv ke kf ly iy kh ki lz kk kl km ma ko kp kq mb ks kt ku hn dt translated">我们用不到200行纯Ruby代码编写了一个功能齐全的机器人(尽管为了吸引数百万风投，它可能并不特别吸引人)。<a class="ae kv" href="https://hackernoon.com/build-your-first-facebook-messenger-bot-in-ruby-with-sinatra-part-3-3-c1b9f55ae121#.kd4zd0ywf" rel="noopener ugc nofollow" target="_blank"> <strong class="kb hv">跟随本教程的第三和最后</strong> </a>部分，看看我们如何添加一些最终的附加功能并部署到Heroku，这样我们的<strong class="kb hv">平滑协调器</strong>就可以最终上线了。</p><blockquote class="oo op oq"><p id="ed6e" class="jz ka mw kb b kc kd iv ke kf kg iy kh or kj kk kl os kn ko kp ot kr ks kt ku hn dt translated"><strong class="kb hv">在我的Github </strong>  <strong class="kb hv">上可以找到我们bot现阶段开发的所有代码</strong> <a class="ae kv" href="https://github.com/progapandist/coordinator-bot/tree/part-two" rel="noopener ugc nofollow" target="_blank"> <strong class="kb hv">。您可以在同一个回购协议中找到一个</strong> </a><a class="ae kv" href="https://github.com/progapandist/coordinator-bot" rel="noopener ugc nofollow" target="_blank"> <strong class="kb hv">完整项目</strong> </a> <strong class="kb hv">(撰写本文时仍在WIP中)的代码，但在主分支中。随便叉，随便克隆，随便玩。</strong></p></blockquote><h1 id="57a5" class="lf lg hu bd lh li lj lk ll lm ln lo lp ja lq jb lr jd ls je lt jg lu jh lv lw dt translated"><a class="ae kv" href="https://hackernoon.com/build-your-first-facebook-messenger-bot-in-ruby-with-sinatra-part-3-3-c1b9f55ae121#.nq73ya2oe" rel="noopener ugc nofollow" target="_blank">转到第3部分</a></h1><p id="9a1f" class="pw-post-body-paragraph jz ka hu kb b kc lx iv ke kf ly iy kh ki lz kk kl km ma ko kp kq mb ks kt ku hn dt translated"><strong class="kb hv">关于我</strong> : <em class="mw">我是一名初学网页开发的人，曾是资深国际电视记者，也是一名年轻的父亲，正在寻找第一份合适的程序员工作。除了痴迷于编码风格和试图让我的头脑充满技术文献之外，我最近以全班第一名的成绩从巴黎的一个优秀的</em> <a class="ae kv" href="https://www.lewagon.com/" rel="noopener ugc nofollow" target="_blank"> <em class="mw"> Le Wagon </em> </a> <em class="mw">编码训练营毕业，并在那里作为一个毕业项目与人合著了</em> <a class="ae kv" href="http://halfway.ninja" rel="noopener ugc nofollow" target="_blank"> <em class="mw">【半路忍者</em> </a> <em class="mw">。这是情侣机票的比较。去看看！你可以在</em><a class="ae kv" href="https://github.com/progapandist" rel="noopener ugc nofollow" target="_blank"><em class="mw">Github</em></a><em class="mw">，</em><a class="ae kv" href="https://twitter.com/progapandist" rel="noopener ugc nofollow" target="_blank"><em class="mw">Twitter</em></a><em class="mw">和</em><a class="ae kv" href="https://www.instagram.com/progapanda/" rel="noopener ugc nofollow" target="_blank"><em class="mw">insta gram</em></a><em class="mw">上找到我。我也拥有这个</em> <a class="ae kv" href="https://progapanda.org/" rel="noopener ugc nofollow" target="_blank"> <em class="mw">域</em> </a> <em class="mw">。我现在可以被雇佣，无论是鼓舞人心的实习，自由职业，甚至是全职工作。我会说英语、俄语、法语、Ruby、JavaScript、Python和Swift，目前在俄罗斯联邦莫斯科工作。有什么优惠可以直接写我</em><a class="ae kv" href="mailto:andybarnov@gmail.com" rel="noopener ugc nofollow" target="_blank"><em class="mw"/></a><em class="mw">。</em></p><div class="jk jl jm jn fq ab cb"><figure class="kw jo kx ky kz la lb paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="kw jo kx ky kz la lb paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="kw jo kx ky kz la lb paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="oo op oq"><p id="f922" class="jz ka mw kb b kc kd iv ke kf kg iy kh or kj kk kl os kn ko kp ot kr ks kt ku hn dt translated"><a class="ae kv" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kv" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kv" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae kv" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jz ka mw kb b kc kd iv ke kf kg iy kh or kj kk kl os kn ko kp ot kr ks kt ku hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kv" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kv" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ou"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ov my l"/></div></figure></div></div>    
</body>
</html>