<html>
<head>
<title>10 Things You Probably Didn’t Know about Sass</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于萨斯你可能不知道的10件事</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/10-things-you-probably-didnt-know-about-syntactically-awesome-style-sheets-d94bc5c137e6?source=collection_archive---------9-----------------------#2017-07-10">https://medium.com/hackernoon/10-things-you-probably-didnt-know-about-syntactically-awesome-style-sheets-d94bc5c137e6?source=collection_archive---------9-----------------------#2017-07-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><h2 id="0451" class="hs ht hu bd b gc hv hw hx hy hz ia ek ib translated" aria-label="kicker paragraph">高级Sass</h2><div class=""/><p id="a5e6" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">从我开始开发的那天起，我就使用Sass，无法想象没有它的前端编码。但事实是，我总是只知道它的顶部是什么，它允许做什么。</p><h1 id="f2bf" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">1.萨斯对SCSS</h1><p id="bf02" class="pw-post-body-paragraph ja jb hu jc b jd kw jf jg jh kx jj jk jl ky jn jo jp kz jr js jt la jv jw jx hn dt translated">第一个惊喜是最初的Sass语法没有使用分号和花括号:</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="8f70" class="lk jz hu lg b fv ll lm l ln lo">$font-stack: Helvetica<strong class="lg ie">,</strong> sans-serif<br/><br/></span><span id="ed2e" class="lk jz hu lg b fv lp lm l ln lo">body<br/>  <strong class="lg ie">font</strong>: 100% $font-stack;</span></pre><p id="b076" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">另一个是我们熟悉的，叫做SCSS的——需要花括号和分号，允许在一个文件中混合普通CSS和Sass。</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="6f7f" class="lk jz hu lg b fv ll lm l ln lo">$font-stack: Helvetica<strong class="lg ie">,</strong> sans-serif;<br/><br/>body {<br/>  <strong class="lg ie">font</strong>: 100% $font-stack;<br/>}</span></pre><p id="79d8" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">这让我们有机会通过简单地将旧的文件扩展名从<code class="eh lq lr ls lg b">.css</code>改为<code class="eh lq lr ls lg b">.scss</code>来开始编写Sass。</p><h1 id="cfc3" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">2.变量有作用域！</h1><p id="0ced" class="pw-post-body-paragraph ja jb hu jc b jd kw jf jg jh kx jj jk jl ky jn jo jp kz jr js jt la jv jw jx hn dt translated">另一个惊喜是变量有范围。如果我们在规则内部定义变量，它将只在规则内部可用，而不会扩大全局范围。</p><p id="ad0d" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">甚至更多——如果我们不确定变量已经在某个地方定义了，我们在声明中使用<code class="eh lq lr ls lg b">!default</code>关键字，意思是——如果值存在于外部作用域中，那么使用它，否则请使用这个新值。在下面的评论中检查要点。</p><p id="e0dd" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">(所有示例在第一帧中显示SCSS，在第二帧中显示生成的CSS。)</p><figure class="lb lc ld le fq lt"><div class="bz el l di"><div class="lu lv l"/></div></figure><h1 id="dd8e" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">3.首选Mixin以扩展</h1><p id="b057" class="pw-post-body-paragraph ja jb hu jc b jd kw jf jg jh kx jj jk jl ky jn jo jp kz jr js jt la jv jw jx hn dt translated">下一个功能是干原理支持。Sass提供了两种实现方式:<code class="eh lq lr ls lg b">extend</code>和<code class="eh lq lr ls lg b">mixin</code>。</p><p id="a6e7" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">我不确定这场圣战是否还在继续，但即使在Sass引入了一个使用extend with <code class="eh lq lr ls lg b">placeholder selector</code>的伟大选项之后，它也允许在不污染全局选择器名称空间的情况下创建规则(现在我们污染了占位符选择器名称空间):</p><figure class="lb lc ld le fq lt"><div class="bz el l di"><div class="lu lv l"/></div></figure><p id="91ae" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated"><code class="eh lq lr ls lg b">mixins</code>对我来说似乎仍然是赢家，因为当我们扩展深度选择器时，它们不会导致生成巨大的CSS，与使用<code class="eh lq lr ls lg b">extend</code>的样式相比，它们实际上会生成更小的gzip文件(证据:<a class="ae lw" href="https://tech.bellycard.com/blog/sass-mixins-vs-extends-the-data/" rel="noopener ugc nofollow" target="_blank">https://tech . belly card . com/blog/sass-mixins-vs-extends-the-data/</a>)。</p><p id="0c4d" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">因此，在接下来的章节中，我将重点介绍<code class="eh lq lr ls lg b">mixins</code>，因为它们包含了许多优秀的特性。</p><h1 id="ac21" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">4.Mixin — <code class="eh lq lr ls lg b">null</code>作为默认参数值</h1><p id="53a8" class="pw-post-body-paragraph ja jb hu jc b jd kw jf jg jh kx jj jk jl ky jn jo jp kz jr js jt la jv jw jx hn dt translated">好的，<code class="eh lq lr ls lg b">mixin</code>接受一些输入参数，并把定义在其中的声明放在你想放的地方。</p><figure class="lb lc ld le fq lt"><div class="bz el l di"><div class="lu lv l"/></div></figure><p id="0691" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">这使我们能够将<code class="eh lq lr ls lg b">include</code>放在我们想要的地方，而不是多次复制/粘贴相同的代码，关于<code class="eh lq lr ls lg b">mixin</code>参数有趣的事情是:</p><ul class=""><li id="4f2a" class="lx ly hu jc b jd je jh ji jl lz jp ma jt mb jx mc md me mf dt translated">它们既可以是命名的，也可以是未命名的——所以当<code class="eh lq lr ls lg b">include</code>调用<code class="eh lq lr ls lg b">mixin</code>时，我们可以省略其中的一些</li><li id="a6ee" class="lx ly hu jc b jd mg jh mh jl mi jp mj jt mk jx mc md me mf dt translated">每个参数都可以有一个默认值——所以如果参数的默认值是我们真正想要的，我们可以省略它</li><li id="1ee9" class="lx ly hu jc b jd mg jh mh jl mi jp mj jt mk jx mc md me mf dt translated">默认值可以是<code class="eh lq lr ls lg b">null</code>——这是一个非常有趣的例子。这意味着如果我们不指定参数并且它的默认值为null，那么使用这个参数作为值的整个声明将从生成的CSS中删除。这为我们节省了编写if/else子句或稍后重置意外声明的时间，并减小了最终文件的大小😌</li></ul><figure class="lb lc ld le fq lt"><div class="bz el l di"><div class="lu lv l"/></div></figure><h1 id="9ec3" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">5.可变参数</h1><p id="d909" class="pw-post-body-paragraph ja jb hu jc b jd kw jf jg jh kx jj jk jl ky jn jo jp kz jr js jt la jv jw jx hn dt translated">另一个<code class="eh lq lr ls lg b">mixin</code>的参数特征是<code class="eh lq lr ls lg b">variable declaration</code>，其行为与ES6扩展操作符相同。它允许我们传递一个<code class="eh lq lr ls lg b">list</code>或一个<code class="eh lq lr ls lg b">map</code>(其中map类似于JS对象)而不是将每个参数单独传递给<code class="eh lq lr ls lg b">mixin</code>，值将被自动分配。</p><p id="1f99" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">这就是我们如何利用这些知识，例如，定义黑暗和光明主题:</p><figure class="lb lc ld le fq lt"><div class="bz el l di"><div class="lu lv l"/></div></figure><p id="9b8e" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">很酷，对吧？是的。</p><p id="3a2d" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">另一个“酷，对”是我们可以传递参数，这样<code class="eh lq lr ls lg b">mixin</code>的输入就变成了其内部<code class="eh lq lr ls lg b">mixin</code>的输入。如果我们想要扩展一个供应商实用程序，比如说Foundation的“三角形”<code class="eh lq lr ls lg b">mixin</code>来使其绝对定位，这可能是有帮助的:</p><figure class="lb lc ld le fq lt"><div class="bz el l di"><div class="lu lv l"/></div></figure><h1 id="cbff" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">6.N <code class="eh lq lr ls lg b">ice Media Queries with Mixin @</code>内容</h1><p id="5635" class="pw-post-body-paragraph ja jb hu jc b jd kw jf jg jh kx jj jk jl ky jn jo jp kz jr js jt la jv jw jx hn dt translated">所以<code class="eh lq lr ls lg b">mixins</code>给了我们传递声明值(inline，block，#fffff等)甚至属性名(margin-right，color…)的好机会，但是如果我们想传递整个SCSS块，而不仅仅是它的一部分呢？我们可以使用<code class="eh lq lr ls lg b">content</code>关键字。</p><p id="bd24" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">让我们看看如何为媒体查询做这件事，这样当我们想用所需的媒体查询条件包装我们的代码时，就可以使用<code class="eh lq lr ls lg b">mixin</code>:</p><figure class="lb lc ld le fq lt"><div class="bz el l di"><div class="lu lv l"/></div></figure><p id="ea63" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">这里最酷的是，每当我想将媒体查询语法复制并粘贴到代码中时，它实际上允许我停止在IDE中搜索“媒体”字符串。我不再需要它了。</p><h1 id="1afe" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">7.再次范围</h1><p id="26d1" class="pw-post-body-paragraph ja jb hu jc b jd kw jf jg jh kx jj jk jl ky jn jo jp kz jr js jt la jv jw jx hn dt translated">关于<code class="eh lq lr ls lg b">content</code>需要记住的一件重要事情是，传递给<code class="eh lq lr ls lg b">mixin</code>的内容块是在定义块的范围内计算的，而不是在<code class="eh lq lr ls lg b">mixin</code>的范围内。</p><p id="c41d" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">所以我们作为参数传递给<code class="eh lq lr ls lg b">mixin</code>的变量不能在内容块中使用:</p><figure class="lb lc ld le fq lt"><div class="bz el l di"><div class="lu lv l"/></div></figure><h1 id="d48b" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">8.每个操作员</h1><p id="2066" class="pw-post-body-paragraph ja jb hu jc b jd kw jf jg jh kx jj jk jl ky jn jo jp kz jr js jt la jv jw jx hn dt translated">与<code class="eh lq lr ls lg b">if</code>、<code class="eh lq lr ls lg b">for</code>和<code class="eh lq lr ls lg b">while</code>一起，我们可以使用<code class="eh lq lr ls lg b">each</code>运算符，这在声明图标时非常有用:</p><figure class="lb lc ld le fq lt"><div class="bz el l di"><div class="lu lv l"/></div></figure><h1 id="21af" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">9.命名</h1><p id="69b4" class="pw-post-body-paragraph ja jb hu jc b jd kw jf jg jh kx jj jk jl ky jn jo jp kz jr js jt la jv jw jx hn dt translated">虽然不是非常有用，但是知道像<code class="eh lq lr ls lg b">mixin</code>或<code class="eh lq lr ls lg b">placeholder selector</code>名字这样的Sass标识符可以互换使用连字符和下划线还是有好处的。这意味着Sass中的<code class="eh lq lr ls lg b">dark-theme</code>和<code class="eh lq lr ls lg b">dark_theme</code>是相同的。还有这两个人:</p><p id="8692" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">༼ つ ◕_◕ ༽つ和༼ つ ◕-◕ ༽つ</p><p id="30ef" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">嗯:)很遗憾，我们无法验证最后两个，因为它们是无效的标识符，抱歉:)</p><h1 id="7c83" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">10.鼓励自己</h1><p id="4410" class="pw-post-body-paragraph ja jb hu jc b jd kw jf jg jh kx jj jk jl ky jn jo jp kz jr js jt la jv jw jx hn dt translated">最后我想分享的是，Sass官方文档很短。</p><p id="4e51" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">因为CSS不是一种编程语言，所以我低估了它所包含的工具的力量。后来我只花了几个小时浏览Sass文档，尽管如此，这给了我一大堆关于如何使代码更干净、更可读和更有性能的见解。</p><p id="e82a" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">祝你编码愉快；)</p></div></div>    
</body>
</html>