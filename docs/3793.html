<html>
<head>
<title>You Should Learn Functional Programming in 2017</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2017年要学函数式编程</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/you-should-learn-functional-programming-in-2017-91177148ec00?source=collection_archive---------2-----------------------#2017-04-24">https://medium.com/hackernoon/you-should-learn-functional-programming-in-2017-91177148ec00?source=collection_archive---------2-----------------------#2017-04-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="fc46" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">函数式编程已经存在很长一段时间了，从50年代开始，引入了<strong class="it hv"> Lisp </strong>编程语言；如果你在过去的两年里一直在关注的话，像<strong class="it hv"> Clojure </strong>、<strong class="it hv"> Scala </strong>、<strong class="it hv"> Erlang </strong>、<strong class="it hv"> Haskell </strong>和<strong class="it hv">elixin</strong>这样的语言已经引起了很大的反响，得到了大量的关注。</p><p id="1f00" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是什么是<strong class="it hv">函数式编程</strong>，为什么每个人都为之疯狂，为什么没有更多人使用它？在这篇文章中，我将尝试回答所有这些问题，并希望激起你对函数式编程的兴趣。</p><h2 id="3b1e" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">函数式编程简史</h2><p id="14a7" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">正如我们之前说过的，函数式编程始于50年代，当时创建了Lisp来运行在IBM700/7000系列科学计算机上。Lisp引入了许多我们现在与函数式编程联系在一起的范例和特性，虽然我们可以称<strong class="it hv"> Lisp </strong>为函数式编程的鼻祖，但我们甚至可以进一步追溯到所有函数式编程语言的共同根源<strong class="it hv"> Lambda Calculus </strong>。</p><figure class="kq kr ks kt fq ku fe ff paragraph-image"><div class="fe ff kp"><img src="../Images/e4d3498fdb70efd9495366f7734ac995.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*q14UN_-U9hP8f2Hw.jpg"/></div></figure><p id="940b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是函数式编程最有趣的方面；所有函数式编程语言都基于同一个简单的数学基础，<strong class="it hv">λ演算</strong>。</p><blockquote class="kx ky kz"><p id="9fa2" class="ir is la it b iu iv iw ix iy iz ja jb lb jd je jf lc jh ji jj ld jl jm jn jo hn dt translated">Lambda演算是图灵完备的，也就是说，它是一个通用的计算模型，可以用来模拟任何单带图灵机。[1]与其同名的希腊字母lambda (λ)用于lambda表达式和lambda术语中，表示在函数中绑定变量。— <a class="ae le" href="https://en.wikipedia.org/wiki/Lambda_calculus#Explanation_and_applications" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="f978" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Lambda演算是一个令人惊讶的简单而强大的概念。lambda演算的核心有两个概念:</p><ul class=""><li id="d7de" class="lf lg hu it b iu iv iy iz jc lh jg li jk lj jo lk ll lm ln dt translated"><strong class="it hv">函数抽象</strong>，用于通过名字(变量)的引入来泛化表达式。</li><li id="2866" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><strong class="it hv">函数应用</strong>，用于通过给特定值命名来评估通用表达式。</li></ul><p id="89fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们来看一个例子，一个单自变量函数<em class="la"> f </em>将自变量增加1:</p><pre class="kq kr ks kt fq lt lu lv lw aw lx dt"><span id="998b" class="jp jq hu lu b fv ly lz l ma mb">f = λ x. x+1</span></pre><p id="ce60" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设我们想将函数应用于数字5；那么该函数可以读作如下:</p><pre class="kq kr ks kt fq lt lu lv lw aw lx dt"><span id="0065" class="jp jq hu lu b fv ly lz l ma mb">f(5) =&gt; 5 + 1</span></pre><h2 id="e6f8" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">函数式编程基础</h2><p id="ac9f" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">数学已经讲得够多了，现在让我们来看看使函数式编程成为一个强大概念的特性:</p><h2 id="9884" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">一流的功能</h2><p id="dd94" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">在函数式语言中，函数是一等公民，这意味着<strong class="it hv">函数可以存储在变量</strong>中，例如在如下所示的elixir中:</p><pre class="kq kr ks kt fq lt lu lv lw aw lx dt"><span id="2777" class="jp jq hu lu b fv ly lz l ma mb">double = fn(x) -&gt; x * 2 end</span></pre><p id="8454" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，我们可以轻松地调用如下函数:</p><pre class="kq kr ks kt fq lt lu lv lw aw lx dt"><span id="a412" class="jp jq hu lu b fv ly lz l ma mb">double.(2)</span></pre><h2 id="1e27" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">高阶函数</h2><p id="0fe2" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">高阶函数被定义为以一个或多个函数作为自变量和/或返回新函数的函数。让我们再次使用我们的双重功能来举例说明这个概念:</p><pre class="kq kr ks kt fq lt lu lv lw aw lx dt"><span id="84e5" class="jp jq hu lu b fv ly lz l ma mb">double = fn(x) -&gt; x * 2 end <br/>Enum.map(1..10, double)</span></pre><p id="f7bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个例子中<strong class="it hv"> Enum.map </strong>将一个可枚举的列表作为第一个参数，将我们刚刚定义的函数作为第二个参数；并且<strong class="it hv">将函数</strong>应用于可枚举的每个元素，结果是:</p><pre class="kq kr ks kt fq lt lu lv lw aw lx dt"><span id="1038" class="jp jq hu lu b fv ly lz l ma mb">[2,4,6,8,10,12,14,16,18,20]</span></pre><h2 id="636c" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">不可变状态</h2><p id="20f7" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">在函数式编程语言中，状态是不可变的，这意味着一旦一个变量被绑定到<strong class="it hv">一个值，它们就不能被重新定义</strong>，这有一个很好的优势<strong class="it hv">防止副作用和竞争条件</strong>；使得并发编程变得更加容易。</p><p id="30eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">像以前一样让我们用长生不老药来说明这个概念:</p><pre class="kq kr ks kt fq lt lu lv lw aw lx dt"><span id="649e" class="jp jq hu lu b fv ly lz l ma mb">iex&gt; tuple = {:ok, "hello"}<br/>{:ok, "hello"}<br/>iex&gt; put_elem(tuple, 1, "world")<br/>{:ok, "world"}<br/>iex&gt; tuple<br/>{:ok, "hello"}</span></pre><p id="4ef8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个例子中，我们的元组永远不会改变值，在第三行中，put_elem返回一个全新的元组，而不修改原始元组的值。</p><p id="3b7b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我不会深入讨论细节，因为这篇文章不是对lambda微积分、计算理论甚至函数式编程的介绍；如果你想让我更深入地研究这两个话题，请在评论区给我留言。现在，我们从这一部分中得出以下结论:</p><ul class=""><li id="4a02" class="lf lg hu it b iu iv iy iz jc lh jg li jk lj jo lk ll lm ln dt translated">函数式编程已经存在很长时间了(50年代早期)</li><li id="d752" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">函数式编程基于数学概念，特别是Lambda演算</li><li id="cb4c" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">与命令式语言相比，函数式编程被认为太慢了</li><li id="b0c9" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">函数式编程正在卷土重来。</li></ul><h2 id="80ae" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">函数式编程应用</h2><p id="e6ea" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">作为软件开发人员，我们生活在一个激动人心的时代，云的承诺终于到来了，有了它，我们每个人都可以获得前所未有的计算机能力。不幸的是，随之而来的还有对可伸缩性、性能和并发性的需求。</p><p id="1efc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">面向对象编程</strong>已经不再适用了，特别是当涉及到<strong class="it hv">并发</strong>和<strong class="it hv">并行</strong>的时候；试图给这种语言添加并发性和并行性会增加很多复杂性，并且通常会导致过度工程化和低性能。</p><p id="f79b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一方面，函数式编程已经非常适合这些挑战，<strong class="it hv">不可变状态、闭包和高阶函数</strong>，这些概念非常适合编写高度并发和分布式的应用程序。</p><p id="f19e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但不要相信我的话，你可以通过查看WhatsApp和Discord等初创公司的技术反馈找到足够的证据:</p><ul class=""><li id="2aba" class="lf lg hu it b iu iv iy iz jc lh jg li jk lj jo lk ll lm ln dt translated"><a class="ae le" href="https://www.wired.com/2015/09/whatsapp-serves-900-million-users-50-engineers/" rel="noopener ugc nofollow" target="_blank"> WhatsApp </a>通过使用<strong class="it hv">二郎</strong>，在团队只有<strong class="it hv"> 50名工程师</strong>的情况下，能够支持9亿用户。</li><li id="3b9c" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><a class="ae le" href="https://blog.discordapp.com/how-discord-handles-push-request-bursts-of-over-a-million-per-minute-with-elixirs-genstage-8f899f0221b4" rel="noopener ugc nofollow" target="_blank"> Discord </a>以类似的方式使用<strong class="it hv">药剂</strong>每分钟处理超过<strong class="it hv">百万个请求</strong>。</li></ul><p id="a2e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于函数式编程的优势，这些公司和团队有能力处理这种大规模增长，并且随着函数式编程获得越来越多的牵引力；我坚信像WhatsApp和Discord这样的故事会越来越普遍。</p><p id="83c8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于这个原因，函数式编程需要成为每个开发人员的必备知识，你需要准备好构建下一代应用程序，为下一个十亿用户服务。如果这还不够的话，相信我，函数式编程真的很有趣，看看<strong class="it hv">灵丹妙药</strong>:</p><ul class=""><li id="e283" class="lf lg hu it b iu iv iy iz jc lh jg li jk lj jo lk ll lm ln dt translated"><a class="ae le" href="http://elixir-lang.org/getting-started/introduction.html" rel="noopener ugc nofollow" target="_blank">仙丹入门</a></li><li id="8270" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><a class="ae le" href="http://rob.conery.io/2016/01/04/learn-elixir-while-having-fun/" rel="noopener ugc nofollow" target="_blank">学习仙丹的有趣方式</a></li><li id="6006" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><a class="ae le" href="https://teamgaslight.com/blog/4-reasons-were-having-fun-programming-elixir" rel="noopener ugc nofollow" target="_blank">我们享受编写灵丹妙药的4个理由</a></li></ul><p id="4b24" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，如果你有任何意见，纠正或你想知道更多关于这个主题，不要犹豫，留下评论就在下面。</p><p id="d2ea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="la">本文原帖</em> <a class="ae le" href="http://coderoncode.com/functional-programming/2017/04/23/you-should-learn-functional-programming-in-2017.html" rel="noopener ugc nofollow" target="_blank"> <em class="la">在我自己的网站</em> </a> <em class="la">。</em></p><div class="kq kr ks kt fq ab cb"><figure class="mc ku md me mf mg mh paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mc ku md me mf mg mh paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mc ku md me mf mg mh paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="kx ky kz"><p id="f922" class="ir is la it b iu iv iw ix iy iz ja jb lb jd je jf lc jh ji jj ld jl jm jn jo hn dt translated"><a class="ae le" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae le" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae le" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae le" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is la it b iu iv iw ix iy iz ja jb lb jd je jf lc jh ji jj ld jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae le" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae le" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kq kr ks kt fq ku fe ff paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="fe ff mi"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>