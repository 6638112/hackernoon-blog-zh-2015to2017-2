<html>
<head>
<title>Java bits: 0xFF and 0xFFL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java位:0xFF和0xFFL</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/0xff-and-0xffl-8d2e480e9f03?source=collection_archive---------34-----------------------#2017-10-31">https://medium.com/hackernoon/0xff-and-0xffl-8d2e480e9f03?source=collection_archive---------34-----------------------#2017-10-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/fa820170eac6754751a8efee28a1d14d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MnY06YQgCowZkZseTegnmg.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Some Random Binaries</figcaption></figure><p id="f7d0" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我写了一个从InputStream中读取长输入数字的方法。代码如下:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="6f07" class="kn ko hu kj b fv kp kq l kr ks">public static long readLong(final ByteArrayInputStream inputStream) {<br/>    long n = 0L;<br/>    n |= ((inputStream.read() &amp; 0xFF) &lt;&lt; 0);<br/>    n |= ((inputStream.read() &amp; 0xFF) &lt;&lt; 8);<br/>    n |= ((inputStream.read() &amp; 0xFF) &lt;&lt; 16);<br/>    n |= ((inputStream.read() &amp; 0xFF) &lt;&lt; 24);<br/>    n |= ((inputStream.read() &amp; 0xFF) &lt;&lt; 32);<br/>    n |= ((inputStream.read() &amp; 0xFF) &lt;&lt; 40);<br/>    n |= ((inputStream.read() &amp; 0xFF) &lt;&lt; 48);<br/>    n |= ((inputStream.read() &amp; 0xFF) &lt;&lt; 56);<br/>    return n;<br/>}</span></pre><p id="1b87" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">它返回错误的结果，我一直在挠头到底哪里出错了。</p><p id="4644" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">深入研究后，我发现java.io.InputStream#read()方法返回一个int类型。当非常大的左移位(如&lt;&lt; 32)is performed on an int, the bits will go over bound and the high bits will be discarded.</p><p id="ca6f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">The solution is to use a long type 0xFFL when we are <a class="ae kt" href="https://hackernoon.com/tagged/performing" rel="noopener ugc nofollow" target="_blank">对int执行</a>&amp;运算，同时希望得到长类型作为这种运算的结果:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="49c4" class="kn ko hu kj b fv kp kq l kr ks">i &amp; 0xFFL</span></pre><p id="0a12" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><a class="ae kt" href="https://hackernoon.com/tagged/programme" rel="noopener ugc nofollow" target="_blank">程序</a>将对I执行<strong class="ji hv">符号扩展</strong>并保留所有位。</p><div class="ku kv fm fo kw kx"><a href="https://en.wikipedia.org/wiki/Sign_extension" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab ej"><div class="kz ab la cl cj lb"><h2 class="bd hv fv z el lc eo ep ld er et ht dt translated">标志扩展-维基百科</h2><div class="le l"><h3 class="bd b fv z el lc eo ep ld er et ek translated">在计算机算术中，符号扩展是指增加二进制数的位数，同时…</h3></div><div class="lf l"><p class="bd b gc z el lc eo ep ld er et ek translated">en.wikipedia.org</p></div></div></div></a></div><p id="2404" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">因此，正确的代码应该如下所示:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="f0f1" class="kn ko hu kj b fv kp kq l kr ks">public static long readLong(final ByteArrayInputStream inputStream) {<br/>    long n = 0L;<br/>    n |= ((inputStream.read() &amp; 0xFFL) &lt;&lt; 0);<br/>    n |= ((inputStream.read() &amp; 0xFFL) &lt;&lt; 8);<br/>    n |= ((inputStream.read() &amp; 0xFFL) &lt;&lt; 16);<br/>    n |= ((inputStream.read() &amp; 0xFFL) &lt;&lt; 24);<br/>    n |= ((inputStream.read() &amp; 0xFFL) &lt;&lt; 32);<br/>    n |= ((inputStream.read() &amp; 0xFFL) &lt;&lt; 40);<br/>    n |= ((inputStream.read() &amp; 0xFFL) &lt;&lt; 48);<br/>    n |= ((inputStream.read() &amp; 0xFFL) &lt;&lt; 56);<br/>    return n;<br/>}</span></pre><figure class="ke kf kg kh fq iv"><div class="bz el l di"><div class="lg lh l"/></div></figure></div></div>    
</body>
</html>