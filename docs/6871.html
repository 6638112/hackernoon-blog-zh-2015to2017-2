<html>
<head>
<title>The Law of Demeter in the era of microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务时代的德米特里定律</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-law-of-demeter-in-the-era-of-microservices-3186f4c399a1?source=collection_archive---------8-----------------------#2017-10-08">https://medium.com/hackernoon/the-law-of-demeter-in-the-era-of-microservices-3186f4c399a1?source=collection_archive---------8-----------------------#2017-10-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="3d20" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">问题是</h1><p id="fb16" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">假设我们有三个组件:<em class="kn"> A </em>、<em class="kn"> B </em>和<em class="kn"> C </em>。</p><figure class="ko kp kq kr fq ks"><div class="bz el l di"><div class="kt ku l"/></div></figure><p id="7f39" class="pw-post-body-paragraph jp jq hu jr b js kv ju jv jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km hn dt translated">另一个组件<em class="kn"> Main </em>依赖于<em class="kn"> A </em>，并且想要调用属于组件<em class="kn"> C </em>的方法foo:</p><pre class="ko kp kq kr fq la lb lc ld aw le dt"><span id="1822" class="lf is hu lb b fv lg lh l li lj">a.getB().getC().foo();</span></pre><p id="c4f5" class="pw-post-body-paragraph jp jq hu jr b js kv ju jv jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km hn dt translated">前面的代码片段相当于:</p><pre class="ko kp kq kr fq la lb lc ld aw le dt"><span id="ccb7" class="lf is hu lb b fv lg lh l li lj">B b = a.getB();<br/>C c = b.getC();<br/>c.foo();</span></pre><p id="1c9f" class="pw-post-body-paragraph jp jq hu jr b js kv ju jv jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km hn dt translated">这段代码的问题在于，为了调用foo，<em class="kn"> Main </em>需要一路通过组件<em class="kn"> A </em>和<em class="kn"> B </em>到达<em class="kn"> C </em>并最终调用那个方法。为了能够调用这个调用，Main 需要知道所有3个组件，以及它们的内部结构。</p><figure class="ko kp kq kr fq ks fe ff paragraph-image"><div class="fe ff lk"><img src="../Images/8fd4582fd1f9f4d21142a4508d5b4f76.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*lm-0m1IM6vsHemUU9ocdbg.png"/></div><figcaption class="ln lo fg fe ff lp lq bd b be z ek">The dotted lines represent the dependencies of the components and the arrows represent the calls</figcaption></figure><p id="e6d4" class="pw-post-body-paragraph jp jq hu jr b js kv ju jv jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km hn dt translated">尽管我们的例子过于简单，但我们可以说<em class="kn"> Main </em>需要知道调用哪个方法才能从<em class="kn"> A </em>获得<em class="kn"> B </em>，从<em class="kn"> B </em>获得<em class="kn"> C </em>并调用<em class="kn"> foo </em>。而且中间组件(<em class="kn"> B </em>和<em class="kn"> C </em>)需要提供一些API来支持这些链式调用。显然，这样的API改变了它们的性质。组件<em class="kn"> A </em>不应该作为组件<em class="kn"> B </em>的提供者，而是应该有一个证明其存在的API。问题是，我们在这里描述的是违反了德米特的<strong class="jr hv">定律。</strong></p><p id="a2fb" class="pw-post-body-paragraph jp jq hu jr b js kv ju jv jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km hn dt translated">Demeter法则是一个非常简单的指导方针，它帮助我们编写非紧密耦合的组件。维基页面用以下3个简单的句子总结了德米特里定律:</p><ul class=""><li id="ec47" class="ls lt hu jr b js kv jw kw ka lu ke lv ki lw km lx ly lz ma dt translated">每个单元应该只对其他单元有有限的了解:只有与当前单元“密切”相关的单元。</li><li id="f40b" class="ls lt hu jr b js mb jw mc ka md ke me ki mf km lx ly lz ma dt translated">每个单位应该只和自己的朋友说话；不要和陌生人说话。</li><li id="6aeb" class="ls lt hu jr b js mb jw mc ka md ke me ki mf km lx ly lz ma dt translated">只和你最亲近的朋友说话。</li></ul><p id="84fb" class="pw-post-body-paragraph jp jq hu jr b js kv ju jv jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km hn dt translated">在OOP中，我们知道对象通过传递消息来相互通信，所以方法调用实际上是从调用者发送到被调用者的消息。比如<em class="kn"> a.getB() </em>简单来说就是<em class="kn"> Main </em>向<em class="kn"> A“请求”</em>B发送消息。在第二个片段中，很明显<em class="kn"> Main </em>负责发送所有的消息，而中间组件除了给出它们的内部组件之外，没有任何实际的逻辑。</p><p id="ef61" class="pw-post-body-paragraph jp jq hu jr b js kv ju jv jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km hn dt translated">现在我们来想想<em class="kn"> Main </em>需要做什么。它需要调用foo，但是它只知道组件<em class="kn"> A </em>。它不需要<em class="kn">【搜索】</em>所有其他组件。它甚至不需要知道它们的存在。它所要做的就是<em class="kn">“告诉”</em>组件<em class="kn"> A </em>去寻找并调用方法<em class="kn"> foo </em>。<em class="kn"> A </em>可能会将此任务委托给<em class="kn"> B </em>并且<em class="kn"> B </em>会做与<em class="kn"> C </em>类似的事情。在这种情况下，组件A“告诉”B 该做什么。</p><h1 id="433a" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">优势</h1><p id="1061" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">德米特里定律有一些非常有益的含义。每个组件只与它的直接依赖项交互。没有已知的间接依赖关系，这使得独立地改变它们的实现更加容易。想象一下，如果我们改变组件<em class="kn"> A </em>的实现来调用某个组件<em class="kn"> X </em>而不是组件<em class="kn"> B </em>。通过链调用，这样的决定被传播到调用者。为了适应这种变化，Main必须做出改变。</p><p id="f63c" class="pw-post-body-paragraph jp jq hu jr b js kv ju jv jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km hn dt translated">测试也容易多了。在我们的例子中，我们必须模仿所有的中间组件，这显然是一种设计味道。实际上，当我们编写测试时，通过注意我们必须创建多少无用的模拟，很容易识别代码的味道。</p><p id="7db6" class="pw-post-body-paragraph jp jq hu jr b js kv ju jv jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km hn dt translated">这些是内部实现泄漏和不良封装的副作用，会导致组件紧密耦合。德米特里定律通过使组件更加自治/解耦来帮助系统的设计，在我看来，这是最重要的优势。</p></div><div class="ab cl mg mh hc mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="hn ho hp hq hr"><h1 id="b58d" class="ir is hu bd it iu mn iw ix iy mo ja jb jc mp je jf jg mq ji jj jk mr jm jn jo dt translated">微服务中的德米特里定律</h1><p id="3f63" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">在微服务领域，组件可以是位于网络不同位置的服务。最重要的区别是组件之间的所有调用现在都是远程调用，因此失败实际上是一种可能的情况。</p><p id="3376" class="pw-post-body-paragraph jp jq hu jr b js kv ju jv jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km hn dt translated">在我们的例子中，假设每个<em class="kn"> getComponent() </em>调用都是远程调用。当<em class="kn"> Main </em>对不同的组件/服务进行3次远程调用时，它会有多脆弱？当然，即使我们应用Demeter定律，为了得到<em class="kn"> foo() </em>的结果，3个消息必须沿着组件传递，但是现在<em class="kn"> Main </em>只与需要的1个组件通信。正如我们将在以下段落中看到的，通信协议的这一变化在可用性和性能方面有很大的提高。</p><p id="2d56" class="pw-post-body-paragraph jp jq hu jr b js kv ju jv jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km hn dt translated">通常，为了解决组件故障的问题并提高系统的性能和弹性，我们使用事件驱动的架构。在事件驱动的架构中，微服务之间的通信是通过向事件调度器发送事件来实现的，而不是直接向我们想要调用的组件发送消息。被调用方监听这些事件，并在它们可用时处理它们。这些事件被异步发送给调度程序。更多关于事件驱动架构的信息可以在<a class="ae lr" href="https://herbertograca.com/2017/10/05/event-driven-architecture/amp/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>中找到。</p><p id="5315" class="pw-post-body-paragraph jp jq hu jr b js kv ju jv jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km hn dt translated">调用<em class="kn"> a.bar() </em>在概念上与将带有该调用的事件发送给调度程序相同，其中组件<em class="kn"> A </em>已经订阅了这些事件。这一额外的间接层更好地解耦了组件，因为调用者不需要知道如何调用<em class="kn"> A </em>，但事实上通信是异步的，这意味着在某些情况下调用者不必等待<em class="kn"> A </em>完成其处理。在我们的例子中，如果<em class="kn"> foo() </em>实际上是一个发送通知或电子邮件的方法，调用者就不必等待这个任务完成。</p><p id="2bbc" class="pw-post-body-paragraph jp jq hu jr b js kv ju jv jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km hn dt translated">即使我们在示例中使用异步通信，当违反Demeter定律时，由于<em class="kn"> Main </em>发送的事件相互依赖，设计仍然存在一些问题。<em class="kn">主</em>向组件<em class="kn"> A </em>请求<em class="kn"> B </em>，以便能够向组件<em class="kn"> B </em>请求<em class="kn"> C </em>等。这种闲聊是构建最终事件所必需的。<em class="kn"> Main </em>不能在<em class="kn"> B </em>返回<em class="kn"> C </em>之前将调用foo的事件发送给<em class="kn"> C </em>(实际上<em class="kn"> B </em>会返回<em class="kn"> C </em>的位置)。此外，在中间组件/服务之一不可用的情况下，<em class="kn"> Main </em>将无法构建最终事件以发送给<em class="kn"> C </em>，因此<em class="kn"> Main </em>将无法完成其流程，并且根据业务规则，它可能无法完成其任务。在这种情况下，间接组件的不可用性会传播到<em class="kn">主</em>。</p><p id="72d2" class="pw-post-body-paragraph jp jq hu jr b js kv ju jv jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km hn dt translated">这种设计在性能方面也存在一些问题。<em class="kn"> Main </em>本可以立即编写调用foo的事件，继续做一些有用的事情，而不是发现其他组件。</p><p id="339b" class="pw-post-body-paragraph jp jq hu jr b js kv ju jv jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km hn dt translated">所有这些问题都是这样一个事实的暗示，即<em class="kn">主</em>而不是<em class="kn">“告诉”</em>它需要什么，它试图通过<em class="kn">“询问”</em>其他组件来收集信息，从而找到一种完成其大部分任务的方法。有人会说<em class="kn"> Main </em>的行为就像它不信任其他组件一样！</p><p id="a7b6" class="pw-post-body-paragraph jp jq hu jr b js kv ju jv jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km hn dt translated">显然，如果我们以不违反得墨忒耳定律的方式设计我们的系统，这些问题几乎可以免费解决。<em class="kn"> Main </em>将只发送1个事件，即使其他组件不可用，也将继续执行其任务。由于<em class="kn"> Main </em>仅发送1个事件，因此没有额外的步骤来创建该事件，因为之前已经优化了通信协议。显然，<em class="kn"> Main </em>的可用性不依赖于其他组件的可用性(除了事件调度程序)。<em class="kn"> Main </em>仅仅通过<em class="kn">“告诉”</em>需要做什么就已经完成了它的任务。当其他组件再次可用时，它们将<em class="kn">最终</em>从调度程序获取事件。</p><p id="be7f" class="pw-post-body-paragraph jp jq hu jr b js kv ju jv jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km hn dt translated">我们应该设计尽可能松散耦合的组件，德米特定律是一个很好的方法。</p><h1 id="6930" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">延伸阅读:</h1><p id="9036" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated"><a class="ae lr" href="https://martinfowler.com/bliki/TellDontAsk.html" rel="noopener ugc nofollow" target="_blank">https://martinfowler.com/bliki/TellDontAsk.html</a><br/>T25】https://pragprog.com/articles/tell-dont-ask</p></div></div>    
</body>
</html>