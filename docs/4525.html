<html>
<head>
<title>Syncing Watched Status Plex Servers with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python同步监视的状态Plex服务器</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/syncing-plex-servers-with-python-b9454fe81b00?source=collection_archive---------7-----------------------#2017-06-06">https://medium.com/hackernoon/syncing-plex-servers-with-python-b9454fe81b00?source=collection_archive---------7-----------------------#2017-06-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="ac8d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">大约8个月前，我安装了一台<a class="ae jp" href="https://www.plex.tv/" rel="noopener ugc nofollow" target="_blank"> Plex </a>服务器来满足我的电视瘾。我的一个朋友也这样做了，我们共享我们的服务器。我们在电视上有非常相似的品味，当我需要定位时，我不会太在意我连接到哪个服务器。</p><p id="fbae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这带来了一个问题，观看状态在服务器之间不同步，所以当我在服务器之间来回切换时，我必须记住我在节目中的位置。幸运的是，<a class="ae jp" href="https://hackernoon.com/tagged/plex" rel="noopener ugc nofollow" target="_blank"> Plex </a>有一个API，所以让我们编写一个脚本来自动同步它们。</p><p id="14dd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">更好的是，有人为API编写了一个<a class="ae jp" href="https://hackernoon.com/tagged/python" rel="noopener ugc nofollow" target="_blank"> python </a>包装器:<a class="ae jp" href="https://github.com/pkkid/python-plexapi" rel="noopener ugc nofollow" target="_blank">https://github.com/pkkid/python-plexapi</a></p><p id="fe94" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在开始之前，我做了一些假设:</p><ul class=""><li id="a338" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">被监视的状态胜过未被监视的状态。如果我在其中一个上看过一集，它应该会显示为在两个上看过</li><li id="f735" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">我们可能不会有彼此相同的情节。</li></ul><p id="3532" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个比较简单的问题。似乎应该只有几个步骤:</p><ol class=""><li id="ea3d" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo ke jw jx jy dt translated">连接到两台服务器</li><li id="95c7" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ke jw jx jy dt translated">找出两台服务器的所有共同点</li><li id="c766" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ke jw jx jy dt translated">遍历列表并获取每个节目的剧集</li><li id="74e4" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ke jw jx jy dt translated">对于每一集，如果它在任何一台服务器上看过，就标记它在另一台服务器上看过</li></ol><p id="af04" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">既然我们已经有了想做什么的想法，那就让我们在REPL尝试一下吧。GitHub自述文件中的文档向我们展示了如何做几乎所有我们想要做的事情，因此我们将遵循它。</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="751d" class="ko kp hu kk b fv kq kr l ks kt">$ mkvirtualenv -p /usr/bin/python3 plex_sync<br/>$ pip install plexapi<br/>$ python</span><span id="1701" class="ko kp hu kk b fv ku kr l ks kt">Python 3.5.2 (default, Nov 17 2016, 17:05:23) <br/>[GCC 5.4.0 20160609] on linux<br/>Type “help”, “copyright”, “credits” or “license” for more information.<br/>&gt;&gt;&gt; from plexapi.myplex import MyPlexAccount<br/>&gt;&gt;&gt; username = ‘username’<br/>&gt;&gt;&gt; password = ‘password’<br/>&gt;&gt;&gt; account = MyPlexAccount(username, password)<br/>Traceback (most recent call last):<br/> File “&lt;stdin&gt;”, line 1, in &lt;module&gt;<br/> File “/home/nolan/.virtualenvs/plex/lib/python3.5/site-packages/plexapi/myplex.py”, line 20, in __init__<br/> self.authenticationToken = data.attrib.get(‘authenticationToken’)<br/>AttributeError: ‘str’ object has no attribute ‘attrib’<br/>&gt;&gt;&gt;</span></pre><p id="fada" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">嗯。那可能不应该发生。看起来问题来自于<code class="eh kv kw kx kk b">plexapi.myplex</code>让我们深入了解一下这里发生了什么。</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="46ec" class="ko kp hu kk b fv kq kr l ks kt">git clone <a class="ae jp" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:pkkid/python-plexapi.git</span></pre><p id="6e04" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">根据异常，我们在myplex.py中查找第20行</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="969e" class="ko kp hu kk b fv kq kr l ks kt">$ find -name “myplex.py” | xargs cat — | head -25 | tail -10</span><span id="0ed6" class="ko kp hu kk b fv ku kr l ks kt">lass MyPlexAccount(PlexObject):<br/> “”” MyPlex account and profile information. The easiest way to build<br/> this object is by calling the staticmethod :func:`~plexapi.myplex.MyPlexAccount.signin`<br/> with your username and password. This object represents the data found Account on<br/> the myplex.tv servers at the url <a class="ae jp" href="https://plex.tv/users/account" rel="noopener ugc nofollow" target="_blank">https://plex.tv/users/account</a>.</span><span id="ae9b" class="ko kp hu kk b fv ku kr l ks kt">Parameters:<br/> username (str): Your MyPlex username.<br/> password (str): Your MyPlex password.<br/> session (requests.Session, optional): Use your own session object if you want to</span></pre><p id="4bac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是个问题。<code class="eh kv kw kx kk b">MyPlexAccount</code>的构造函数并不像异常中所说的那样在第20行。PyPi上的代码肯定不一样。它看起来像什么？</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="6030" class="ko kp hu kk b fv kq kr l ks kt">$ pip download plexapi<br/>$ tar -xvzf PlexAPI-2.0.2.tar.gz<br/>$ find -name “myplex.py” | xargs cat — | head -25 | tail -10<br/> BASEURL = ‘<a class="ae jp" href="https://plex.tv/users/account'" rel="noopener ugc nofollow" target="_blank">https://plex.tv/users/account'</a><br/> SIGNIN = ‘<a class="ae jp" href="https://my.plexapp.com/users/sign_in.xml'" rel="noopener ugc nofollow" target="_blank">https://my.plexapp.com/users/sign_in.xml'</a><br/> <br/> def __init__(self, data, initpath=None):<br/>     self.authenticationToken = data.attrib.get(‘authenticationToken’)<br/>     self.certificateVersion = data.attrib.get(‘certificateVersion’)<br/>     self.cloudSyncDevice = data.attrib.get(‘cloudSyncDevice’)<br/>     self.email = data.attrib.get(‘email’)<br/>     self.guest = utils.cast(bool, data.attrib.get(‘guest’))<br/>     self.home = utils.cast(bool, data.attrib.get(‘home’))</span></pre><p id="d84b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好吧，这样好一点了。构造函数在它应该在的地方，但是它不需要用户名和密码。这是怎么回事？</p><p id="3d1d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">花费的时间比我想承认的要长，但最终我意识到PyPi上的文档与GitHub上的不同。我需要使用<code class="eh kv kw kx kk b">MyPlexAccount.signin()</code>而不是<code class="eh kv kw kx kk b">MyPlexAccount</code>构造函数。第二次尝试:</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="ab6f" class="ko kp hu kk b fv kq kr l ks kt">$ python</span><span id="19e3" class="ko kp hu kk b fv ku kr l ks kt">Python 3.5.2 (default, Nov 17 2016, 17:05:23) <br/>[GCC 5.4.0 20160609] on linux<br/>Type “help”, “copyright”, “credits” or “license” for more information.<br/>&gt;&gt;&gt; from plexapi.myplex import MyPlexAccount<br/>&gt;&gt;&gt; username = ‘username’<br/>&gt;&gt;&gt; password = ‘password’<br/>&gt;&gt;&gt; account = MyPlexAccount.signin(username, password)<br/>&gt;&gt;&gt;</span></pre><p id="23d9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">进步！接下来，我们需要创建到两台服务器的连接。</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="6eea" class="ko kp hu kk b fv kq kr l ks kt">&gt;&gt;&gt; server_1_name = ‘server_1_name’<br/>&gt;&gt;&gt; server_2_name = ‘server_2_name’<br/>&gt;&gt;&gt; server_1 = account.resource(server_1_name)<br/>&gt;&gt;&gt; server_2 = account.resource(server_2_name)<br/>&gt;&gt;&gt; conn_1 = server_1.connect()<br/>&gt;&gt;&gt; conn_2 = server_2.connect()<br/>Traceback (most recent call last):<br/> File “&lt;stdin&gt;”, line 1, in &lt;module&gt;<br/> File “/home/nolan/.virtualenvs/plex/lib/python3.5/site-packages/plexapi/myplex.py”, line 157, in connect<br/> raise NotFound(‘Unable to connect to resource: %s’ % self.name)<br/>plexapi.exceptions.NotFound: Unable to connect to resource: server_2_name</span></pre><p id="386f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">啊哦。这是否意味着我不能通过API连接到不属于我的服务器？这说不通。我可以看到一堆在我朋友的服务器的网络界面上看不到的信息。</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="751c" class="ko kp hu kk b fv kq kr l ks kt">&gt;&gt;&gt; dir(server_2)<br/>[‘BASEURL’, ‘__class__’, ‘__delattr__’, ‘__dict__’, ‘__dir__’, ‘__doc__’, ‘__eq__’, ‘__format__’, ‘__ge__’, ‘__getattribute__’, ‘__gt__’, ‘__hash__’, ‘__init__’, ‘__le__’, ‘__lt__’, ‘__module__’, ‘__ne__’, ‘__new__’, ‘__reduce__’, ‘__reduce_ex__’, ‘__repr__’, ‘__setattr__’, ‘__sizeof__’, ‘__str__’, ‘__subclasshook__’, ‘__weakref__’, ‘_connect’, ‘accessToken’, ‘clientIdentifier’, ‘connect’, ‘connections’, ‘createdAt’, ‘device’, ‘home’, ‘lastSeenAt’, ‘name’, ‘owned’, ‘platform’, ‘platformVersion’, ‘presence’, ‘product’, ‘productVersion’, ‘provides’, ‘synced’]</span></pre><p id="901e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果不允许我连接到它，我可能不会得到像<code class="eh kv kw kx kk b">accessToken</code>或<code class="eh kv kw kx kk b">platform</code>这样的东西。为什么它会显示为我的帐户下的资源？让我们再次深入研究一下plexapi代码。</p><p id="60dc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我能够很好地创建一个<code class="eh kv kw kx kk b">MyPlexResource</code>对象(<code class="eh kv kw kx kk b">server_2</code>)，异常来自<code class="eh kv kw kx kk b">connect</code>函数，所以让我们从这里开始。<code class="eh kv kw kx kk b">connect</code>的代码如下所示:</p><figure class="kf kg kh ki fq ky"><div class="bz el l di"><div class="kz la l"/></div><figcaption class="lb lc fg fe ff ld le bd b be z ek">Copyright Michael Shepanski</figcaption></figure><p id="6d37" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">嗯，那件事看起来是个问题。从注释来看，API似乎只检查非本地连接中不属于我们的资源。但这似乎不是代码所做的。它过滤掉不属于本地的连接。那是行不通的。我想连接到我朋友的服务器，但它不是我自己的，也不是本地的。我敢打赌，如果我们把第6行和第7行中的<code class="eh kv kw kx kk b">if forcelocal(c)</code>去掉，我们就可以连接到<code class="eh kv kw kx kk b">server_2</code>。移除<code class="eh kv kw kx kk b">if forcelocal(c)</code>后:</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="e160" class="ko kp hu kk b fv kq kr l ks kt">$ python</span><span id="7f34" class="ko kp hu kk b fv ku kr l ks kt">Python 3.5.2 (default, Nov 17 2016, 17:05:23) <br/>[GCC 5.4.0 20160609] on linux<br/>Type “help”, “copyright”, “credits” or “license” for more information.<br/>&gt;&gt;&gt; from plexapi.myplex import MyPlexAccount<br/>&gt;&gt;&gt; username = ‘username’<br/>&gt;&gt;&gt; password = ‘password’<br/>&gt;&gt;&gt; account = MyPlexAccount.signin(username, password)<br/>&gt;&gt;&gt; server_1_name = ‘server_1_name’<br/>&gt;&gt;&gt; server_2_name = ‘server_2_name’<br/>&gt;&gt;&gt; server_1 = account.resource(server_1_name)<br/>&gt;&gt;&gt; server_2 = account.resource(server_2_name)<br/>&gt;&gt;&gt; conn_1 = server_1.connect()<br/>&gt;&gt;&gt; conn_2 = server_2.connect()<br/>&gt;&gt;&gt;</span></pre><p id="3dec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">啊哈！那似乎已经解决了问题。让我们通过找到他有但我没有的节目来确保它实际上正确地连接到我们想要的服务器。依靠(这次是正确的)文档:</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="df3f" class="ko kp hu kk b fv kq kr l ks kt">&gt;&gt;&gt; conn_2.library.section(‘TV Shows’).get(‘Police Squad!’).episodes()<br/>[&lt;Episode:13132:b’A.Substantial.Gift.(‘&gt;, &lt;Episode:13133:b’Ring.of.Fear.(A.Dang’&gt;, &lt;Episode:13134:b’The.Butler.Did.It.(A’&gt;, &lt;Episode:13135:b’Revenge.and.Remorse.’&gt;, &lt;Episode:13136:b’Rendezvous.at.Big.Gu’&gt;, &lt;Episode:13137:b’Testimony.of.Evil.(D’&gt;]</span></pre><p id="a25b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">看起来很有效。现在，我们必须执行步骤2到4。希望我们现在已经过了棘手的阶段。文档没有指定如何列出库中的所有节目，但我怀疑搜索什么都会返回所有内容。</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="af1f" class="ko kp hu kk b fv kq kr l ks kt">&gt;&gt;&gt; len(conn_2.library.section(‘TV Shows’).search())<br/>58</span></pre><p id="c20a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那起了作用。找到两个服务器之间所有共同节目的最简单方法是使用集合，并在每个服务器上找到节目集合的交集。</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="dd90" class="ko kp hu kk b fv kq kr l ks kt">&gt;&gt;&gt; server_1_shows = set(list(map((lambda x: x.title), conn_1.library.section(‘TV Shows’).search())))<br/>&gt;&gt;&gt; server_2_shows = set(list(map((lambda x: x.title), conn_2.library.section(‘TV Shows’).search())))<br/>&gt;&gt;&gt; common_shows = server_1_shows &amp; server_2_shows <br/>&gt;&gt;&gt; </span></pre><p id="deb0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好了，我们得到了两台服务器共有的所有节目的名字。接下来的两个步骤是遍历这个列表，并同步每个剧集的观看状态。这不是很简单，因为每一集都在一个列表中，我不知道顺序是否有保证。也有可能一集只存在于其中一个服务器上。这意味着我们只能用线性搜索来匹配剧集。</p><figure class="kf kg kh ki fq ky"><div class="bz el l di"><div class="kz la l"/></div></figure><p id="d56d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这很有效，所以让我们把它从REPL中取出来，放在一个python文件中，这样我们就可以做一些调整了。</p><p id="0dd3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们成功地做了我们计划要做的事情，但进展相当缓慢。怎么才能加快速度呢？对<code class="eh kv kw kx kk b">markWatched</code>的调用需要一个网络调用，我们调用它的次数比我们需要的要多。如果一集已经在两个服务器上被标记为已观看，我们仍然调用<code class="eh kv kw kx kk b">markWatched</code>。当我们将来运行这个工具时，将会有很多不必要的网络调用。让我们快速改变一下。</p><figure class="kf kg kh ki fq ky"><div class="bz el l di"><div class="kz la l"/></div></figure><p id="be8d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那应该差不多了。剩下要做的就是提交我对plexapi所做更改的pull请求。在那之前，我已经分叉了库，并在我的GitHub上应用了补丁。最终剧本:</p><figure class="kf kg kh ki fq ky"><div class="bz el l di"><div class="kz la l"/></div></figure><blockquote class="lf lg lh"><p id="05cd" class="ir is li it b iu iv iw ix iy iz ja jb lj jd je jf lk jh ji jj ll jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is li it b iu iv iw ix iy iz ja jb lj jd je jf lk jh ji jj ll jl jm jn jo hn dt translated">要了解更多信息，<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">请阅读我们的“关于”页面</a>，<a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is li it b iu iv iw ix iy iz ja jb lj jd je jf lk jh ji jj ll jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kf kg kh ki fq ky"><div class="bz el l di"><div class="lm la l"/></div></figure></div></div>    
</body>
</html>