<html>
<head>
<title>Make an automated iOS appstore out of Gitlab Pages without sacrifice virgins to Satan</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Gitlab页面制作一个自动化的iOS应用商店，而不要向撒旦牺牲处女</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/make-an-ios-appstore-out-of-gitlab-pages-99d4d16b0455?source=collection_archive---------7-----------------------#2017-04-22">https://medium.com/hackernoon/make-an-ios-appstore-out-of-gitlab-pages-99d4d16b0455?source=collection_archive---------7-----------------------#2017-04-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="f71b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://gitlab.com" rel="noopener ugc nofollow" target="_blank"> Gitlab </a>越来越成为许多任务的“一个解决方案”,它最初是一个安装在内部的github克隆服务，现在它专注于CI/CD。<br/>什么曾经可能是github/gitlab/？？？+ jenkins设置现在只需gitlab本身即可完成。<br/>在我的环境中，我们有一个苹果企业订阅和几个开发iOS应用的供应商，我们<a class="ae jp" href="https://developer.apple.com/library/content/documentation/IDEs/Conceptual/AppDistributionGuide/DistributingEnterpriseProgramApps/DistributingEnterpriseProgramApps.html" rel="noopener ugc nofollow" target="_blank">通过OTA </a>分发这些应用。<br/>用于签署应用程序的证书不会与供应商共享，因此对于每次应用程序更新，我们都必须在分发给最终用户之前亲自签署应用程序(在我们的案例中，通过<strong class="it hv"> MDM </strong>，应用程序仅供公司员工使用)。供应商、我们的团队和公司的一些关键用户需要一种快速的方法来安装正确签名的应用程序的测试版本。<br/>有很多解决方案可以达到向用户分发测试版的目的(<a class="ae jp" href="https://get.fabric.io" rel="noopener ugc nofollow" target="_blank"> Fabric </a>、<a class="ae jp" href="https://developer.apple.com/testflight/" rel="noopener ugc nofollow" target="_blank"> TestFlight </a>等)。)，但是在我们的环境中，我们需要一个<em class="jq">内部</em>解决方案，因为由MDM管理的设备会受到一些限制，这些限制不适合这些类型的服务。</p><p id="9ab4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">关于OTA分发的小题外话</strong> <br/> OTA分发相当简单，在过去是一场噩梦，但现在xcode处理得相当好。当您使用xcode为<em class="jq"> Enterprise </em>或<em class="jq"> AdHoc </em>发行版构建ipa时，您可以要求它生成一个清单文件。<br/><strong class="it hv">清单</strong>文件是一个plist(一个xml ),它包含了一些关于应用程序、版本、捆绑包id、图标和获取ipa文件的链接的信息。<br/>要创建用户可从iOS设备使用的安装链接，您必须使用一个指向清单plist的自定义apple方案:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="34e6" class="ka kb hu jw b fv kc kd l ke kf">itms-services://?action=download-manifest&amp;amp;url=https://yourdomainname.com/app.plist</span></pre><p id="ff76" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意:</p><ul class=""><li id="1542" class="kg kh hu it b iu iv iy iz jc ki jg kj jk kk jo kl km kn ko dt translated">清单文件<strong class="it hv">必须在<code class="eh kp kq kr jw b">https</code>连接下</strong>被提供</li><li id="d09f" class="kg kh hu it b iu ks iy kt jc ku jg kv jk kw jo kl km kn ko dt translated">网络服务器必须能够服务于这些MIME类型<code class="eh kp kq kr jw b">.ipa application/octet-steam</code>和<code class="eh kp kq kr jw b">.plist text/xml</code></li></ul><p id="495f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jq">我们的目标是简化自动化流程，使人们能够将代码推送到gitlab存储库，然后从iOS设备转到HTML页面，直接安装更新的应用程序。</em></p><h2 id="754c" class="ka kb hu bd kx ky kz la lb lc ld le lf jc lg lh li jg lj lk ll jk lm ln lo lp dt translated">首次设置</h2><p id="a7fc" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">第一个设置是用<strong class="it hv">git lab</strong>+<strong class="it hv">Jenkins</strong>+<strong class="it hv">一个静态HTML站点生成器</strong>完成的。<br/>对于自动化程度不同的应用程序，工作流程略有不同，大致如下:</p><ul class=""><li id="9afd" class="kg kh hu it b iu iv iy iz jc ki jg kj jk kk jo kl km kn ko dt translated">一家供应商向gitlab推出新变化</li><li id="3928" class="kg kh hu it b iu ks iy kt jc ku jg kv jk kw jo kl km kn ko dt translated">jenkins上的<strong class="it hv">构建</strong>作业被触发，该作业构建应用程序、签名并在共享位置移动生成的<em class="jq"> ipa </em>(可由其他作业访问)</li><li id="e912" class="kg kh hu it b iu ks iy kt jc ku jg kv jk kw jo kl km kn ko dt translated">jenkins上的<strong class="it hv">发布</strong>作业是手动触发的，或者是由之前的作业触发的，通过混合使用脚本和静态站点生成器(我们使用<a class="ae jp" href="http://laktek.github.io/punch/" rel="noopener ugc nofollow" target="_blank"> punch </a>只是因为它使用json文件作为内容输入)，生成最终的HTML <em class="jq"> ~AppStore </em>，其中包含所有应用程序页面和正确的manifest.plist，以便手动将它们安装到设备上。</li></ul><p id="4f90" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种方法很好，因为它做了它必须做的事情，但是涉及到几个完全分离的软件并在不同的机器上运行:gitlab托管源代码，jenkins在OSX的机器上构建和签名，另一台机器使用web服务器来服务最终的网站。<br/>此外，它还涉及许多关于配置、脚本和文件路径的<em class="jq">“惯例的魔力”</em>。</p><h2 id="bd5d" class="ka kb hu bd kx ky kz la lb lc ld le lf jc lg lh li jg lj lk ll jk lm ln lo lp dt translated">中间设置</h2><p id="69fd" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">当gitlab开始集成<a class="ae jp" href="https://about.gitlab.com/gitlab-ci" rel="noopener ugc nofollow" target="_blank"> CI/CD </a>时，我们改变了这一工作流程，将Jenkins从等式中移除，并利用gitlab的其他功能，如<a class="ae jp" href="https://docs.gitlab.com/ce/api/README.html" rel="noopener ugc nofollow" target="_blank"> API </a>及其<a class="ae jp" href="https://docs.gitlab.com/ce/integration/oauth_provider.html" rel="noopener ugc nofollow" target="_blank"> Oauth提供者</a>。软件栈减少到<strong class="it hv"> gitlab </strong>，一个简单的<a class="ae jp" href="https://docs.gitlab.com/ce/ci/runners/README.html" rel="noopener ugc nofollow" target="_blank"> gitlab runner </a>和一个用python制作的<strong class="it hv"> webapp </strong>和<a class="ae jp" href="http://flask.pocoo.org" rel="noopener ugc nofollow" target="_blank"> Flask </a>。<br/>新的工作流程是:</p><ul class=""><li id="f956" class="kg kh hu it b iu iv iy iz jc ki jg kj jk kk jo kl km kn ko dt translated">将新代码推送到gitlab</li><li id="3cfa" class="kg kh hu it b iu ks iy kt jc ku jg kv jk kw jo kl km kn ko dt translated">已配置的gitlab CI被触发，<em class="jq"> runner </em>构建并存储已签名的ipa作为gitlab上的<a class="ae jp" href="https://docs.gitlab.com/ce/user/project/pipelines/job_artifacts.html" rel="noopener ugc nofollow" target="_blank">工件</a>。</li></ul><p id="b625" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不需要发布步骤，因为所有其他事情都由flask webapp处理。</p><p id="bb7f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">webapp并不简单:</p><ul class=""><li id="f992" class="kg kh hu it b iu iv iy iz jc ki jg kj jk kk jo kl km kn ko dt translated">它使用gitlab的oauth特性对已经可以访问gitlab的人进行身份验证，并获得一个用于gitlab API的<code class="eh kp kq kr jw b">user token</code></li><li id="7926" class="kg kh hu it b iu ks iy kt jc ku jg kv jk kw jo kl km kn ko dt translated">用获得的令牌调用API检索用户可见的项目列表(更具体地说，过滤掉非iOS项目)</li><li id="f402" class="kg kh hu it b iu ks iy kt jc ku jg kv jk kw jo kl km kn ko dt translated">转到特定的项目页面，再次通过gitlab API，我们检索最新成功构建的工件</li><li id="3640" class="kg kh hu it b iu ks iy kt jc ku jg kv jk kw jo kl km kn ko dt translated">我们读取ipa内部，并为安装链接动态生成一个清单文件(我们可以使用xcode生成的清单，并将它作为工件保存在ipa中)</li></ul><p id="7244" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个解决方案更好，因为我们删除了一个软件，但我们仍然有3台机器来运行一切(一台用于gitlab，一台用于runner，另一台用于webapp)。<br/>我们移除了<em class="jq">【惯例魔法】</em>和所有的脚本，将整个逻辑嵌入到webapp中。<br/>但是我们不得不做一些技巧(又名<em class="jq">坏事</em>)来解决一些gitlab API <a class="ae jp" href="https://gitlab.com/gitlab-org/gitlab-ce/issues/22378" rel="noopener ugc nofollow" target="_blank">的怪癖</a>，这些怪癖使得flask应用程序很难维护并且整体上很难看。</p><h2 id="cbee" class="ka kb hu bd kx ky kz la lb lc ld le lf jc lg lh li jg lj lk ll jk lm ln lo lp dt translated">最终设置</h2><p id="6f45" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">当gitlab在社区版上发布<a class="ae jp" href="https://docs.gitlab.com/ce/user/project/pages/" rel="noopener ugc nofollow" target="_blank">页面</a>时，我们决定再次重构所有的东西。<br/>有了这个设置，我们可以完全杀死恼人的flask应用程序，并删除一台机器。<br/>我不会深入gitlab pages是如何工作的，但是<em class="jq">长话短说</em>您可以在CI配置上添加一个<em class="jq">作业</em>来将文件夹发布为静态站点，站点所在的主机名取决于您配置CI <em class="jq">作业</em>的存储库。查看<a class="ae jp" href="https://docs.gitlab.com/ce/user/project/pages/" rel="noopener ugc nofollow" target="_blank">文档</a>了解更多细节。</p><p id="4726" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">新流程现在是这样的:</p><ul class=""><li id="8ad6" class="kg kh hu it b iu iv iy iz jc ki jg kj jk kk jo kl km kn ko dt translated">将新代码推送到gitlab</li><li id="36f4" class="kg kh hu it b iu ks iy kt jc ku jg kv jk kw jo kl km kn ko dt translated">已配置的gitlab CI被触发，并且<em class="jq">运行程序</em>构建并存储已签名的ipa和清单文件，作为gitlab上的<a class="ae jp" href="https://docs.gitlab.com/ce/user/project/pipelines/job_artifacts.html" rel="noopener ugc nofollow" target="_blank">工件</a>。</li><li id="37e9" class="kg kh hu it b iu ks iy kt jc ku jg kv jk kw jo kl km kn ko dt translated">一个<strong class="it hv"> pages </strong> <em class="jq"> job </em>生成HTML静态文件，这些文件将与之前的job工件(ipa和manifest)一起发布在项目页面下。</li></ul><p id="3cdc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后一步可以用几种方法来完成，你可以使用一个成熟的静态站点生成器或者只是一个简单的脚本来生成一个html页面。</p><p id="b7fa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">基于你想要完成的，你可以有一个<code class="eh kp kq kr jw b">namespace site</code>来列出你想要公开的所有项目，然后有一个<code class="eh kp kq kr jw b">project site</code>来链接安装构建(如果你不知道我的意思，还是用<a class="ae jp" href="https://docs.gitlab.com/ce/user/project/pages/getting_started_part_one.html#gitlab-pages-domain" rel="noopener ugc nofollow" target="_blank"> RTFM </a>)。</p><p id="b955" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个设置的一个简单的<code class="eh kp kq kr jw b">.gitlab-ci.yml</code>可能是这样的:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="18ce" class="ka kb hu jw b fv kc kd l ke kf">stages:<br/>  - build<br/>  - publish<br/><br/>build_production:<br/>  stage: build<br/>  script:<br/>    - BASE_URL=https://namespace.yourdomain.com/projectname APPNAME=mightyapp fastlane gym<br/><br/>  artifacts:<br/>    paths:<br/>      - public/*.ipa<br/>      - public/*.plist<br/>    expire_in: 1 day // we don't need to save this since it is persisted by the pages job later<br/><br/>pages:<br/>  stage: publish<br/>  script:<br/>  - python publish.py "https://namespace.yourdomain.com/projectname"<br/>  artifacts:<br/>    paths:<br/>    - public</span></pre><p id="6980" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我建议你使用浪子<a class="ae jp" href="https://github.com/fastlane/fastlane/tree/master/gym" rel="noopener ugc nofollow" target="_blank">体育馆</a>而不是xcodebuild，以简化构建ipa和生成清单文件。</p><p id="49c9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是一个最小的<code class="eh kp kq kr jw b">Gymfile</code>:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="b346" class="ka kb hu jw b fv kc kd l ke kf">output_directory "./public"<br/>export_options(<br/>  method: "ad-hoc", <br/>  manifest: {<br/>    appURL: "#{ENV["BASE_URL"]}/#{ENV["APPNAME"]}.ipa",<br/>    displayImageURL: "https://placehold.it/600x600",<br/>    fullSizeImageURL: "https://placehold.it/600x600"<br/>  }<br/>)<br/>output_name ENV["APPNAME"]</span></pre><p id="7e0d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，这可能是一个超级快速和肮脏，但工作脚本生成一个html页面:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="bc4d" class="ka kb hu jw b fv kc kd l ke kf"># -*- coding: utf-8 -*-<br/>"""<br/>&lt;!doctype html&gt;<br/>&lt;html lang="en"&gt;<br/>&lt;head&gt;<br/>    &lt;meta charset="UTF-8"&gt;<br/>    &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt;<br/>    &lt;title&gt;Install {title}&lt;/title&gt;<br/><br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>    &lt;div class="main" style="margin:50px; text-align:center;"&gt;<br/>        &lt;h1&gt;{title}&lt;/h1&gt;<br/>        &lt;p&gt;{bundleid}&lt;/p&gt;<br/>        &lt;p&gt;{version}&lt;/p&gt;<br/>        &lt;a href="itms-services://?action=download-manifest&amp;url={baseurl}/manifest.plist"&gt;INSTALL&lt;/a&gt;<br/>    &lt;/div&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;<br/>"""<br/><br/>import sys<br/>from plistlib import readPlist<br/>from hashlib import md5<br/>from os import walk, environ<br/>from datetime import datetime<br/><br/><br/>def main():<br/>    baseurl = sys.argv[1]<br/>    plistfile = "public/manifest.plist"<br/>    index_html_path = "public/index.html"<br/>    plist = readPlist(plistfile)<br/>    metadata = plist['items'][0]['metadata']<br/>    info = dict()<br/>    info["title"] = metadata['title']<br/>    info["version"] = metadata['bundle-version']<br/>    info["bundleid"] = metadata['bundle-identifier']<br/>    info["baseurl"] = baseurl<br/>    with open(index_html_path, "w+") as f:<br/>        f.write(__doc__.format(**info))<br/><br/><br/>if __name__ == '__main__':<br/>    main()</span></pre><p id="cad7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该脚本非常简单明了，你可以通过使用模板引擎或任何你想要的<strong class="it hv">静态站点生成器</strong>来发挥创造力。</p><p id="1776" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">希望能给你一些新的想法，或者至少让你尝试一下gitlab，因为它是一个非常好的软件！</p><p id="d229" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">完全披露:不，他们不支付我很遗憾！</p><p id="65f5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">感谢<a class="lv lw gr" href="https://medium.com/u/fb8dedd8f96e?source=post_page-----99d4d16b0455--------------------------------" rel="noopener" target="_blank"> Sl3 </a>的校对:P</p><blockquote class="lx ly lz"><p id="9d92" class="ir is jq it b iu iv iw ix iy iz ja jb ma jd je jf mb jh ji jj mc jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is jq it b iu iv iw ix iy iz ja jb ma jd je jf mb jh ji jj mc jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上给我们点赞/发消息</a>，或者简单地说，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is jq it b iu iv iw ix iy iz ja jb ma jd je jf mb jh ji jj mc jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>