# Lattice 4.0:视图状态问题的解决方案

> 原文：<https://medium.com/hackernoon/lattice-4-0-a-solution-to-the-view-state-problem-9cc44a4bd9d7>

文本框是一个复杂而敏感的问题:如何以及在哪里存储文本，以及当发生变化时如何更新事件侦听器。

HTML 模型只是将文本框内容存储在 DOM 中，并在触发相关事件时调用更新监听器。这种模型经过了时间的考验，能够很好地处理 Javascript 如何将变量作用于匿名函数的问题。大多数编程语言(函数式之外的)不会将外部变量纳入闭包。[格子](https://github.com/andrew-lucker/Lattice)内置铁锈，多多少少都有这个问题。

视图状态的“问题”是，当一个事件被触发时，我们可能希望引用两个变量，一个是在创建文本框时创建的，另一个是在创建后绑定到视图组件的。对于 Javascript 来说，这听起来微不足道，但是相比之下，Rust 关于变量生命周期的安全特性阻止了我们在这里使用简单的解决方案。

HTML 在 DOM 中的状态存储是将信息存储到视图组件本身。让我们称这个策略为“绑定到左侧”。另一种方法是将信息存储到管理和调用侦听器的环境中。让我们把第二个策略称为“绑定到右侧”。从这个角度我们可以看到，在 HTML/JS 中，数据是左右两边共享的。这基本上是视图状态问题的理想解决方案，然而现在的问题是“我们如何在 Rust 中做同样的事情”？

第一种解决方案是复制 Javascript 的方法，虽然很丑，但非常合理。为了在 Rust 中共享一个变量，我们可以将该值放入一个引用单元格(Rc、RefCell、Box 等。)并从左侧和右侧检索和/或更新该值。这种方法的缺点是，客户端代码变得非常脏，难以阅读；更不用说，每个共享变量都必须使用所有权和生存期的迟钝规则进行显式绑定、解包和变异。也许这种方法在未来的 Rust 中会变得更容易，但是现在它对我来说是一个太大的负担。

第二种解决方案，在网格中使用，是使用受限的 FRP 样式。这意味着对象状态存储在“靠近”左侧，但不完全在视图组件上。由引擎管理，每个视图组件和听众可以订阅的*频道*都有一个关联值。当一个组件想要更新它的状态时，它会调用每个组件内置的状态设置函数。每个组件可能有多个不同类型的绑定值。然后，该引擎检查是否应该将更改通知给订阅者，如果是，则向侦听器发出一个事件。

以这种方式，可以通过使用引擎作为中介来引用左侧和右侧状态。状态的所有权交给中介，组件和侦听器总是接收借用的值。从用户的角度来看，这种方法非常简洁，并且在实践中非常类似于 Javascript 方法。

我仍然希望在未来，Rust 闭包会有更多的选项和更好的关于作用域变量的默认值，但是现在有很多变通方法。

![](img/30c51516b6205863fb9202959c603783.png)

This is what my git repositories usually look like