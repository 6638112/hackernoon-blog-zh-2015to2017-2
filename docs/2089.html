<html>
<head>
<title>How To Deal With Test And Production Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何处理测试和生产代码</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-deal-with-test-and-production-code-c64acd9a062?source=collection_archive---------9-----------------------#2017-01-05">https://medium.com/hackernoon/how-to-deal-with-test-and-production-code-c64acd9a062?source=collection_archive---------9-----------------------#2017-01-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="1c91" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">测试代码和生产代码是不同的，也许它们需要针对每种环境的单独的开发方法</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/b324090782147027fa0782eb415441ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JyZFqpzjLwtRtHfLIS--Qw.jpeg"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">The picture of a yellow lemon surrounded by a bunch of green limes. It definitely stands out as something different.</figcaption></figure><p id="710e" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在使用<strong class="kb hv">测试代码</strong>和<strong class="kb hv">生产代码</strong>时，我们可以识别一些模式。出于本文的目的，我们将包含项目逻辑并在生产中运行的系统部分称为“<strong class="kb hv">生产代码”</strong>。我们称之为"<strong class="kb hv">测试代码"</strong>项目的一部分，它包含验证应用程序(产品代码)是否如预期的那样工作的测试。这些模式的存在以及它们如何根据上下文而不同，可以使我们以不同的方式处理测试代码和生产代码。</p></div><div class="ab cl kv kw hc kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hn ho hp hq hr"><p id="9fa2" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们都知道<a class="ae lc" rel="noopener" href="/@fagnerbrack/why-test-driven-development-4fb92d56487c">测试驱动开发是有用的</a>，至少对于那些能够在适当的环境中正确应用它的人来说是如此。然而，TDD和测试优先对于编写软件来说都不是必需的。当然，它们提高了质量，但不是必需的。</p><p id="b59b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">测试一个内部可能执行多个互连“单元”的功能是可能的。一个“单元”可以是一个模块，一个函数，一个类…任何组成应用程序的东西。虽然产品代码代表了几个相互连接的单元的组合，其中每个单元都应该在某种程度上知道其他单元的存在，但是一个单独的测试不需要知道其他测试的存在。</p><blockquote class="ld"><p id="7073" class="le lf hu bd lg lh li lj lk ll lm ku ek translated">测试代码和生产代码之间存在差异</p></blockquote><p id="9366" class="pw-post-body-paragraph jz ka hu kb b kc ln iv ke kf lo iy kh ki lp kk kl km lq ko kp kq lr ks kt ku hn dt translated">通过覆盖系统重要部分的集成测试，最好是使用TDD的结果，可以安全地重构整个产品代码，并且非常确信系统仍将按预期工作。考虑到开发人员必须牢记的所有复杂性和熵，这并不意味着重构会很容易，而只是意味着信心很高。</p><p id="6df0" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">然而，我们不能只是重构所有的测试代码，然后抱最好的希望。我们需要一次重构一个测试，对于每一个测试，我们必须确保我们理解了测试的意图(这就是为什么有时候<a class="ae lc" rel="noopener" href="/@fagnerbrack/when-code-duplication-is-acceptable-51ce33ecd0f5">重复是可以接受的</a>)。之后，通过更改或注释与之相关的产品代码，有意地破坏测试。我们在重构测试代码时，并不像重构生产代码时那样有信心。在这种情况下，额外的护理是必须的。</p><blockquote class="ld"><p id="f117" class="le lf hu bd lg lh li lj lk ll lm ku ek translated">当重构测试代码时，我们不像重构生产代码那样有信心，因此我们需要小心翼翼地一个一个来做</p></blockquote><p id="3277" class="pw-post-body-paragraph jz ka hu kb b kc ln iv ke kf lo iy kh ki lp kk kl km lq ko kp kq lr ks kt ku hn dt translated">当我们有一个覆盖良好的系统时，就有可能在生产代码中用低几率的错误来搜索和替换。然而，我们应该极力避免在测试代码中使用<strong class="kb hv">搜索和替换</strong>，因为没有办法确保不会产生误报。</p><p id="4c06" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">有些测试运行得非常快，比如单元测试；有些测试运行得非常慢，比如集成测试。速度对于产品代码或测试代码来说都是一个重要的因素，但是它们不能用相同的公式来衡量。这一切都归结于成本，要么是开发者的成本，要么是用户参与的成本。</p><p id="9882" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">生产代码是最终产品。根据项目的规模及其影响的系统部分，100毫秒可以在用户参与度和收入方面产生巨大的差异。对于单个用户来说，这并不重要，但在大范围内，这种影响可能是相关的。</p><p id="360d" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">100毫秒的影响可能与测试代码无关。如果测试很慢，对开发人员的反馈周期会影响生产力。然而，如果有20名开发人员，测试代码执行中增加的100毫秒的成本可能与服务于数亿用户的应用程序中增加的100毫秒的成本不同。</p><blockquote class="ld"><p id="5a5b" class="le lf hu bd lg lh li lj lk ll lm ku ek translated">性能在生产代码中与在测试代码中一样重要，但是大多数时候它们并不<a class="ae lc" href="https://www.ted.com/talks/ruth_chang_how_to_make_hard_choices" rel="noopener ugc nofollow" target="_blank">彼此相提并论</a></p></blockquote><p id="4099" class="pw-post-body-paragraph jz ka hu kb b kc ln iv ke kf lo iy kh ki lp kk kl km lq ko kp kq lr ks kt ku hn dt translated">还是关于性能的话题，如果我们正在为web开发JavaScript应用程序，根据项目的规模，用户下载的产品代码中的每一个字节都很重要。然而，在测试代码中，代码大小是完全不相关的，因为大多数时候它将在开发人员机器或CI中本地运行。</p><p id="6592" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">有些人在JavaScript代码中做了一些折衷来节省字节，并用测试来补偿。有时，在生产代码中复制功能是有意义的，以考虑GZIP算法处理字符多次出现的方式，因为它可能会压缩到一个更小或更大的文件中，这取决于它是如何完成的。有时，应用降低代码可读性的技术是有意义的，但相反，这将有助于减少代码的大小。</p><blockquote class="ld"><p id="0aab" class="le lf hu bd lg lh li lj lk ll lm ku ek translated">在生产代码中，有些情况下优化代码大小可能有价值。然而，测试代码永远不会关心它，因此可以作为支持这些权衡的工具</p></blockquote><p id="a5e1" class="pw-post-body-paragraph jz ka hu kb b kc ln iv ke kf lo iy kh ki lp kk kl km lq ko kp kq lr ks kt ku hn dt translated">TDD最著名的倡导者之一Kent Beck曾经说过:</p><blockquote class="ls lt lu"><p id="6fd3" class="jz ka lv kb b kc kd iv ke kf kg iy kh lw kj kk kl lx kn ko kp ly kr ks kt ku hn dt translated">我为有效的代码而不是为测试获得报酬，所以我的哲学是尽可能少地测试以达到给定的置信度水平…</p><p id="20c2" class="jz ka lv kb b kc kd iv ke kf kg iy kh lw kj kk kl lx kn ko kp ly kr ks kt ku hn dt translated">—肯特·贝克开启<a class="ae lc" href="http://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests/153565#153565" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a></p></blockquote><p id="76af" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">为了编写能够工作的软件，我们需要进行测试，否则，将来可能无法工作。项目所有者总是假设默认情况下一切正常，所以我们需要自己假设稳定性是不可协商的。</p><p id="68a3" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">生产代码和测试代码是有区别的。它可以是复制、重构或表演的形式。然而，一个并不比另一个更重要。</p><p id="1121" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">测试代码是不同的，但仍然是必不可少的。</p></div><div class="ab cl kv kw hc kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hn ho hp hq hr"><p id="fb2c" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">感谢阅读。如果您有任何反馈，请通过<a class="ae lc" href="https://twitter.com/FagnerBrack" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae lc" href="https://www.facebook.com/fagner.brack" rel="noopener ugc nofollow" target="_blank">脸书</a>或<a class="ae lc" href="http://github.com/FagnerMartinsBrack" rel="noopener ugc nofollow" target="_blank"> Github </a>联系我。</p></div></div>    
</body>
</html>