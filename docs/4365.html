<html>
<head>
<title>Musing on Architectural Components and Realm and Room, and a look at Reactive Data Layer in Clean Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">思考建筑组件、领域和空间，并查看干净建筑中的反应数据层</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/musing-on-architectural-components-and-realm-and-room-and-a-look-at-reactive-clean-architecture-880c8df55abf?source=collection_archive---------2-----------------------#2017-05-28">https://medium.com/hackernoon/musing-on-architectural-components-and-realm-and-room-and-a-look-at-reactive-clean-architecture-880c8df55abf?source=collection_archive---------2-----------------------#2017-05-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/6d785e6d37e6b41c615944afa666516b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZNDNsZ0_eeZmLythGuKr0Q.png"/></div></div></figure><p id="ef61" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://hackernoon.com/tagged/google" rel="noopener ugc nofollow" target="_blank">谷歌</a> I/O 2017。Android的发展前景已经发生了变化。</p><p id="9a85" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">随着新推出的<strong class="je hv">“架构组件”</strong>，Android应用程序的设计方式将发生巨大变化。</p><p id="6147" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我一直使用装载机，我会感到困惑。“如何将<strong class="je hv"> <em class="kb"> ViewModels </em> </strong>和<strong class="je hv"><em class="kb">LiveData</em></strong><em class="kb"/>融入我的应用程序？”</p><p id="6f0c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是我很幸运。我有机会用<em class="kb">境界</em>代替。我可以通过<a class="ae ka" rel="noopener" href="/@Zhuinden/how-to-use-realm-for-android-like-a-champ-and-how-to-tell-if-youre-doing-it-wrong-ac4f66b7f149"><em class="kb">监听数据库</em>中的变化来简化我的大部分问题，而且一切都是最新的</a>。任何线程对Realm所做的任何更改都会反映在UI线程上，除了保持对一个<code class="eh kc kd ke kf b">RealmResults</code>的引用并向其添加一个<code class="eh kc kd ke kf b">RealmChangeListener</code>之外，没有其他工作。</p><p id="9ea2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">随着<strong class="je hv"> Room </strong>的引入，我认为Realm的许多优势现在对其他人都可用了——但是是在SQLite之上。</p><h1 id="c6ac" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">DAOs和观察数据库</h1><p id="c751" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">对于Room，典型的反应式数据访问层如下所示:</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="ln lo l"/></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek">Room DAO</figcaption></figure><p id="51aa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如您所看到的，所有的DAO方法都返回一个<code class="eh kc kd ke kf b">LiveData&lt;T&gt;</code>,您可以订阅它进行更改。</p><p id="29bf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">订阅变更根本不是一个新概念。Realm因为“遍布代码库”而受到了很多批评，但实际上，没有人会阻止任何人创建他们自己的基于Realm的Dao来在一个地方收集查询。</p><p id="5a8b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">事实上，它看起来像这样:</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="ln lo l"/></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek">Realm DAO</figcaption></figure><p id="d3ec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt">— — — — — — — — — — — — — — — — — — —</p><p id="7612" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦我们有了这些，我们可以观察到这样的变化:</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="ln lo l"/></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek">Observing LiveData (from <a class="ae ka" href="https://github.com/googlesamples/android-architecture-components/blob/178fe541643adb122d2a8925cf61a21950a4611c/BasicSample/app/src/main/java/com/example/android/persistence/ProductListFragment.java" rel="noopener ugc nofollow" target="_blank">here</a>)</figcaption></figure><p id="4cb0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然传统上，您可以让<code class="eh kc kd ke kf b">RealmResults</code>(甚至可能是<code class="eh kc kd ke kf b">Realm</code>实例)由活动/片段的生命周期回调直接管理，但这部分是<code class="eh kc kd ke kf b">ViewModel</code>负责的(另一半是活动和片段的<em class="kb">作用域</em>数据容器——例如，它可以存储订阅的Dagger组件)。</p><p id="d78c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们利用新的生命周期集成并将领域包装在视图模型中，我们甚至可以重用上面的代码，而只使用这个视图模型:</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="ln lo l"/></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek">Realm-based ViewModel, based on <a class="ae ka" href="https://github.com/googlesamples/android-architecture-components/blob/178fe541643adb122d2a8925cf61a21950a4611c/BasicSample/app/src/main/java/com/example/android/persistence/viewmodel/ProductListViewModel.java" rel="noopener ugc nofollow" target="_blank"><strong class="ak"><em class="lt">this sample</em></strong></a></figcaption></figure><p id="7719" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">基于这个例子，这里有一件有趣的事情需要注意。</p><blockquote class="lu lv lw"><p id="be07" class="jc jd kb je b jf jg jh ji jj jk jl jm lx jo jp jq ly js jt ju lz jw jx jy jz hn dt translated">概念上，<code class="eh kc kd ke kf b">MutableLiveData&lt;List&lt;T&gt;&gt;</code>和<code class="eh kc kd ke kf b">RealmResults&lt;T&gt;</code>是一回事。</p></blockquote><p id="350e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">事实上，即使以前有人问，我也告诉他们:如果他们使用干净的架构和Realm，并且他们的数据层返回一个<code class="eh kc kd ke kf b">List&lt;T&gt;</code>而不是类似于<code class="eh kc kd ke kf b">MutableLiveList&lt;T&gt;</code>的东西，这种东西会在适当的位置发生变化，并提供添加/删除更改监听器的方法，那么他们使用Realm是错误的，<em class="kb">和</em>使他们的生活变得更加复杂。</p><p id="d762" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">尽管如此，一个关键的区别是SQLite会急切地评估您的查询结果，而Realm提供的是延迟加载的结果。由于Realm的结果是延迟加载的，ViewModel提供的这种“范围缓存”甚至没有必要，但是很高兴看到一个代码<em class="kb">提供了反应性</em>并且可以从片段本身适当地抽象Realm<em class="kb"/>，不是吗？:)</p><h1 id="193c" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">将数据层变为反应层，而不仅仅是连接单个数据层</h1><p id="1493" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">现在，有一个非常普遍的建筑决策，我随处可见，但我从未真正理解。</p><p id="cdbb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">人们经常创建一个<code class="eh kc kd ke kf b">Repository</code>类，负责“从内存缓存、本地数据源或远程数据源中选择数据”——我认为这来自<a class="ae ka" href="https://fernandocejas.com/2015/07/18/architecting-android-the-evolution/" rel="noopener ugc nofollow" target="_blank"> <em class="kb">费尔南多·切哈斯的《架构Android:进化》</em> </a> <em class="kb">，</em>，但它甚至可能源自<a class="ae ka" href="http://blog.danlew.net/2015/06/22/loading-data-from-multiple-sources-with-rxjava/" rel="noopener ugc nofollow" target="_blank"> <em class="kb">丹·卢的《从多个来源加载数据》</em> </a> <em class="kb">。</em></p><p id="375a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通常，这会导致一个<code class="eh kc kd ke kf b">concat</code>操作，它有一种代数美:</p><pre class="lj lk ll lm fq ma kf mb mc aw md dt"><span id="0ddf" class="me kh hu kf b fv mf mg l mh mi">// from Dan Lew's article<br/>Single&lt;Data&gt; memory = ...;  <br/>Single&lt;Data&gt; disk = ...;  <br/>Single&lt;Data&gt; network = ...;<br/><br/>Single&lt;Data&gt; source = Single  <br/>  .concat(memory, disk, network)<br/>  .first();    // &lt;-- return only 1!</span></pre><p id="0fc4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在新的世界中，您可以观察数据库中的变化，您不仅仅需要<strong class="je hv"> 1 </strong>元素。你要求一个<em class="kb">可观察的</em>。可以是<strong class="je hv">1……*</strong>元素。</p><p id="99e7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">如果您只是从数据源中检索一个<em class="kb">单个</em>元素，否则<em class="kb">不会监听</em>对数据库所做的更改，那么<em class="kb">的反应性</em>在哪里？您基于Rx的解决方案的反应能力在哪里？</strong></p><p id="785c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，我不明白这个数据层的设计。我用油漆画了一个图来说明这一点(也可以在这里<a class="ae ka" href="https://stackoverflow.com/questions/43192015/realm-working-with-clean-architecture-and-rxjava2/43202425#43202425" rel="noopener ugc nofollow" target="_blank">找到</a>):</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mj"><img src="../Images/67fbecefc8c61301b78b6f62f061861b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OhM4YndCzYRt6NGLCXrscg.png"/></div></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek">Traditional “cold” repository implementation with multiple data sources</figcaption></figure><p id="7b98" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如您所见，演示者没有为的变更<em class="kb">订阅。任何改变数据集的后台操作将如何反映在演示者中？没办法听。</em></p><p id="5610" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">相反，一种可能的方法是启动一次性操作，必要时从远程<em class="kb">检索数据</em>，否则只监听本地数据源的变化。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mj"><img src="../Images/89894ba3b5d730bbb342e91c110e432b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mErt8cLMphX7l9IBAUQoPQ.png"/></div></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek">Repository listens to local datasource as “hot” event source</figcaption></figure><p id="bbb9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以前，您的缓存可以通过<a class="ae ka" href="https://github.com/JakeWharton/RxReplayingShare" rel="noopener ugc nofollow" target="_blank"> Jake Wharton的<strong class="je hv">rxpreplayingshare</strong></a>来完成，它会在订阅时返回最新的值(它已经取代了内存缓存作为数据源)。</p><p id="c106" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在这由<strong class="je hv"> ViewModel </strong>(数据范围)和<strong class="je hv"> LiveData </strong>(保存以前的值，并允许订阅——类似于<code class="eh kc kd ke kf b">BehaviorRelay</code>)处理，因此缓存不再是可观察链的责任:</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mj"><img src="../Images/f2d2a5a20f405e6aa6ab7512ca807f35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nAPG9NSw9Bf8SOkMo4rdwQ.png"/></div></div></figure><p id="9c19" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过这种方式，我们创建了限定范围的数据，并使用架构组件监听更改，同时我们在数据层中保持了反应性(而不是只请求一次数据，然后在数据发生更改时无法更新)。</p><h1 id="1500" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">结论</h1><p id="e107" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">我个人很欢迎使用<em class="kb"> ViewModel </em>和<em class="kb"> LiveData </em>给Android应用带来的新变化。在使用Realm一年多之后，reactivity带来的这种简单感觉就像家一样——无论是Realm<em class="kb">还是T21</em>房间。:)</p><p id="6dc3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">概念是相同的，谢天谢地，它比加载器或串联单个要好得多，容易得多，也稳定得多。</p><div class="lj lk ll lm fq ab cb"><figure class="mk iv ml mm mn mo mp paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mk iv ml mm mn mo mp paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mk iv ml mm mn mo mp paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="lu lv lw"><p id="f922" class="jc jd kb je b jf jg jh ji jj jk jl jm lx jo jp jq ly js jt ju lz jw jx jy jz hn dt translated"><a class="ae ka" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是这个大家庭的一员。我们现在<a class="ae ka" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ka" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd kb je b jf jg jh ji jj jk jl jm lx jo jp jq ly js jt ju lz jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ka" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ka" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="mq lo l"/></div></figure></div></div>    
</body>
</html>