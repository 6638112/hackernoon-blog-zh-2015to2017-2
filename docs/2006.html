<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://medium.com/hackernoon/questioning-microsoft-publicly-is-dangerous-9cac9b481c91?source=collection_archive---------2-----------------------#2017-01-01">https://medium.com/hackernoon/questioning-microsoft-publicly-is-dangerous-9cac9b481c91?source=collection_archive---------2-----------------------#2017-01-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><p id="8750" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">注意:这篇文章最初是作为关于docs/FAQ.md的<a class="ae ir" href="https://github.com/Microsoft/vcpkg/issues/478" rel="noopener ugc nofollow" target="_blank">github.com/Microsoft/vcpkg问题#478 </a>发布的，它相当粗心地歪曲了他们项目的社区替代方案。</p><p id="48f1" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">我的账户在20分钟内就被下线了，同时下线的还有我所有的Github库、评论(以及有问题的帖子)。我有一个活跃的账户(和存档的信用卡)已经将近8年了，但以前从未发生过这种情况。如果我去github.com/contact,，我会看到一段颇具讽刺意味的文字:</p><blockquote class="is it iu"><p id="62c8" class="hs ht iv hv b hw hx hy hz ia ib ic id iw if ig ih ix ij ik il iy in io ip iq hn dt translated">需要Microsoft/vcpkg项目的帮助吗？你可以和@微软联系。例如，您可以在存储库上打开一个问题，或者给维护者发送一封电子邮件。</p></blockquote><p id="3602" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated"><strong class="hv iz">更新:我的账号暂时恢复上线，</strong> <a class="ae ir" href="https://twitter.com/nothingstrivial/status/815389627854950400" rel="noopener ugc nofollow" target="_blank"> <strong class="hv iz">感谢@nothingstrivial </strong> </a> <strong class="hv iz">。我非常感谢他的帮助，特别是考虑到节日庆典！期待未来如何避免这种情况的细节。</strong></p><p id="d460" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated"><strong class="hv iz">目前，最好避免与微软的存储库交互，尤其是如果你依赖GitHub进行CI依赖或网站托管。我听说(非正式的)巨魔的高价值目标会得到特殊处理。我不知道用户有什么方法来评估这种风险。</strong></p><h1 id="1399" class="ja jb hu bd jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx dt translated">“为什么不是柯南？”常见问题部分混淆和歪曲</h1><p id="b975" class="pw-post-body-paragraph hs ht hu hv b hw jy hy hz ia jz ic id ie ka ig ih ii kb ik il im kc io ip iq hn dt translated"><a class="ae ir" href="https://github.com/Microsoft/vcpkg/blob/master/docs/FAQ.md#why-not-conan" rel="noopener ugc nofollow" target="_blank">的全部4个部分“为什么不是柯南？”FAQ </a>部分要么缺乏逻辑连贯性，要么与技术价值和工具适用性完全正交。</p><p id="d76e" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated"><strong class="hv iz">“公共联盟vs私人联盟”</strong>部分反对允许个人发布包，声明</p><blockquote class="is it iu"><p id="d849" class="hs ht iv hv b hw hx hy hz ia ib ic id iw if ig ih ix ij ik il iy in io ip iq hn dt translated">“我们认为，应该有一个单一的、协作维护的版本，适用于绝大多数情况，并允许用户自由侵入他们的私人版本。”</p></blockquote><p id="20a2" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">你不需要极端的(不幸的)技术限制来创造一个有围墙的花园。运行你自己的柯南服务器就行了，只授权从微软账号上传。您可以保留<a class="ae ir" href="https://github.com/Microsoft/vcpkg/tree/master/ports" rel="noopener ugc nofollow" target="_blank"> ports </a>目录——只需用con config file . py替换“CONTROL ”(有一个自动化工具)。只允许CI使用该帐户—瞧！您已经完美地镜像了vcpkg的现有访问权限和模型，并且没有损害用户自由。</p><p id="8d1d" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">当然，你可以主张监管，但是将监管融入到构建依赖关系的设计中不会有好结果。我喜欢自制软件，但我们很幸运地在2个月内得到了像libvips这样的非核心包。对策划清单的依赖不成比例。如果你做策展，严格限制在你可以承诺管理的范围内，并且0天内回复。鼓励和支持社区完成剩下的工作。</p><p id="9970" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">如果你想提高柯南中“官方”包的可发现性，提交一个包排序算法的PR。对用户名和包匹配的包进行优先排序的约定是一种很好的零维护方式，可以通过用户名保留来获得权威版本。或者每个包名只允许一个实例。我们正在讨论对包服务器的细微调整。<strong class="hv iz">你的第一个理由缺乏实质</strong>。</p><blockquote class="is it iu"><p id="b4f2" class="hs ht iv hv b hw hx hy hz ia ib ic id iw if ig ih ix ij ik il iy in io ip iq hn dt translated"><strong class="hv iz">每dll与每应用程序。</strong>当依赖项在库级别上<strong class="hv iz">独立版本化时，它鼓励<strong class="hv iz">每个</strong>构建环境完全成为<em class="hu">，唯一的</em>，<strong class="hv iz">无法</strong>利用，<strong class="hv iz">或促成</strong>一个<em class="hu">稳固的</em>，经过良好测试的生态系统【强调矿】。相比之下，通过将所有库作为一个平台(类似于系统包管理器)一起进行版本控制，我们希望将测试和工作集中在非常常见的库版本集上，以最大化生态系统的质量和稳定性。这也完全设计出了库要求与应用程序的选择相冲突的版本的能力(我想要openssl Z和boost X，但是X只适用于openssl Y)。</strong></p></blockquote><p id="1632" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">这与几十年的证据相矛盾。所有其他的开发包管理器(据我所知)都允许库指定依赖关系。这并不是全世界都错了。ABI脆弱性并不是C/C++独有的，只是被加重了。我们将在后面讨论系统包管理者(以及他们在C/C++软件开发中的角色)。</p><p id="6744" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated"><strong class="hv iz">柯南支持每应用版本化，依赖版本覆盖</strong>。您的应用程序只是使用另一个con config file . py来指定依赖版本。也就是说，我对柯南的生态系统一直很满意(并不介意)。</p><p id="fd52" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">库的维护者通常最清楚哪个版本的依赖项应该是默认的。你用了生态系统这个词。我认为那个词的意思和你想象的不一样。因为在前一段，你说:</p><blockquote class="is it iu"><p id="a812" class="hs ht iv hv b hw hx hy hz ia ib ic id iw if ig ih ix ij ik il iy in io ip iq hn dt translated">我们认为应该有一个单一的、协作维护的版本</p></blockquote><p id="696d" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">那是…不是一个生态系统。但是我们稍后会讨论生态系统。你继续</p><blockquote class="is it iu"><p id="4913" class="hs ht iv hv b hw hx hy hz ia ib ic id iw if ig ih ix ij ik il iy in io ip iq hn dt translated">我们希望将测试和努力集中在非常常见的库版本上，以最大化生态系统的质量和稳定性。</p></blockquote><p id="b52b" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated"><strong class="hv iz">所以..“版本”。好吧。我喜欢选择加入平台版本的概念。例如，“这里有一组库版本，它们都是兼容的”。这是一组新的版本。等等。</strong></p><p id="ae94" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">太好了。这也可能表现为:</p><ul class=""><li id="ad6f" class="kd ke hu hv b hw hx ia ib ie kf ii kg im kh iq ki kj kk kl dt translated">一个git存储库，包含一个conan版本号的纯文本文件。</li><li id="0fba" class="kd ke hu hv b hw km ia kn ie ko ii kp im kq iq ki kj kk kl dt translated">将所述特征添加到货物的简单的拉取请求。</li><li id="8735" class="kd ke hu hv b hw km ia kn ie ko ii kp im kq iq ki kj kk kl dt translated">一些没有声称要取代<em class="iv">包经理</em>的东西。我喜欢“港口树”这个名字。它并不意味着更多——各种精选包的构建脚本的集合。</li></ul><h2 id="9b19" class="kr jb hu bd jc ks kt ku jg kv kw kx jk ie ky kz jo ii la lb js im lc ld jw le dt translated">但是，vcpkg不是只支持1个(用户范围的)集合吗？</h2><p id="9ff0" class="pw-post-body-paragraph hs ht hu hv b hw jy hy hz ia jz ic id ie ka ig ih ii kb ik il im kc io ip iq hn dt translated">在linux/mac上，一个强制的系统范围的版本集正是我们几十年来一直试图逃避的痛苦。为了摆脱这种局面，我们投入了巨大的努力。<strong class="hv iz">它完全阻止了跨平台开发，因为没有两个操作系统会包含相同的版本集。</strong></p><p id="83cb" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">你不认为<em class="iv">为库设计指定依赖版本的能力</em>有点过头了吗？这是确保生态系统永远不会发展的一种方式，因为软件包只有在官方平台上才能有好的可用性。</p><p id="4f3b" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">您选择OpenSSL作为冲突的例子是一个很好的例子。在我的项目中，破坏OpenSSL API更改是痛苦的。但是柯南管理的图书馆却没有这种痛苦。我可以清楚地看到库支持什么版本，如果我需要更新什么，只需要几分钟。一个Windows系统范围的OpenSSL副本在vcpkg上比在homebrew或apt-get上更容易实现吗？<strong class="hv iz">请描述一下——这将是对常见问题的一个很好的补充。我将描述策划和非策划软件之间的平衡和界限，以及表面的大小如何影响这个工具的适用性。</strong></p><p id="0b2e" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated"><strong class="hv iz">理由二是双曲线双言。</strong></p><blockquote class="is it iu"><p id="7790" class="hs ht iv hv b hw hx hy hz ia ib ic id iw if ig ih ix ij ik il iy in io ip iq hn dt translated">跨平台vs单平台。虽然在许多平台上托管是一颗优秀的北极星，但我们认为apt-get、yum和homebrew提供的系统集成和稳定性水平非常值得在自动化脚本中用brew install boost交换apt-get install libboost-all-dev。</p></blockquote><p id="c2f3" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">我不使用自制软件或apt-get或巧克力来管理我的依赖关系。理论上，我可以在Docker容器中开发，并在其中使用apt-get或homebrew。但我不是被迫的，因为柯南是存在的。我有完整的包隔离，可以支持我想要的许多不同的版本集。今天，我同时在OS X 10.11、Windows 10和Ubuntu 14.04上运行柯南。我有几个不同的项目，有不同的需求，一切都很好。</p><p id="574e" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">这很好。就是我习惯用RVM+Bundler，Virtualenv+pip，Rustup+Cargo，npm，甚至NuGet(模几个bug)体验的。</p><p id="0d26" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">让我们澄清一些术语:</p><ul class=""><li id="225a" class="kd ke hu hv b hw hx ia ib ie kf ii kg im kh iq ki kj kk kl dt translated"><strong class="hv iz">系统包管理者</strong> : apt-get，homebrew，Chocolatey。系统上只能存在一个版本的包。可以有gcc和gcc5.3，但它们是分开命名的包。不能通过调用gcc来运行gcc5.3。apt-get、homebrew和Chocolatey的另一个限制是它们只能以root权限安装。</li><li id="1bdc" class="kd ke hu hv b hw km ia kn ie ko ii kp im kq iq ki kj kk kl dt translated"><strong class="hv iz">依赖包管理器</strong> : Bundler，npm，Cargo，pip，nuget。通常与某种语言或一组语言相关联，其中包管理器的设计经常考虑该语言的编译器/运行时的特定需求。这些语言通常依赖于系统编译器/运行时，因此与环境管理器相结合，以便开发人员可以一次处理一个以上的项目(假设不同的项目需要不同的版本)。如果使用版本管理器，通常会安装多个实例。许多提供了基本的运行时/编译器切换，或者有意对环境友好。</li><li id="29fb" class="kd ke hu hv b hw km ia kn ie ko ii kp im kq iq ki kj kk kl dt translated"><strong class="hv iz">环境管理者</strong> : rvm，rbenv，nvm，virutalenv，dnx。拉斯特普。这些允许您同时为给定的语言使用不同的编译器/运行时和不同的包管理器版本。他们可能会改变存储数据，这样包管理器(如果使用用户本地存储)就不会在多个运行时版本上重用相同的缓存。</li></ul><p id="b384" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">在开发C/C++的过程中，我们受到系统包管理器的约束，不知道我们可以同时安装哪些编译器。然而，我们有CXX和CC env变量，并且Conan提供了编译器切换功能。然而，在进程持续时间之外，In不会重新定义任何行为，因此在这方面，它更像rbenv而不是rvm。</p><h2 id="4644" class="kr jb hu bd jc ks kt ku jg kv kw kx jk ie ky kz jo ii la lb js im lc ld jw le dt translated">系统范围的构建依赖排除了合理的跨平台开发</h2><p id="fa9a" class="pw-post-body-paragraph hs ht hu hv b hw jy hy hz ia jz ic id ie ka ig ih ii kb ik il im kc io ip iq hn dt translated">当您没有添加任何定制代码时，系统范围的包管理可以顺利地工作，并且您对使用哪个版本的at工具一点也不挑剔。这种限制通常是不可接受的，所以现代工具通常用docker容器装运。新一代语言的出现正是为了通过普遍的静态链接来解决这个问题。(有维修问题)</p><p id="23ee" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">针对系统范围的依赖性开发软件是一场噩梦。我们对安全更新中的突破性变化没有追索权，没有编译两个的方法(完全独立！)需要不同libpng ABIs的工具。这是不必要的痛苦。</p><p id="c936" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">这是一个非常奇怪的时间点(鉴于微软的新战略)，开始(欺骗性地，或通过无知)推广将开发者与Windows捆绑在一起并确保未来痛苦的方法。</p><blockquote class="is it iu"><p id="4317" class="hs ht iv hv b hw hx hy hz ia ib ic id iw if ig ih ix ij ik il iy in io ip iq hn dt translated">我们选择让我们的系统尽可能容易地融入到这些非常成功的系统管理器的世界中——这是vcpkg install boost的又一条线——而不是试图在它们已经如此成功和受欢迎的地方替换它们。</p></blockquote><p id="0ecf" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">这个世界上有成功的系统经理，是的。我还想说，OneGet 可能配得上这个称号。<strong class="hv iz">你的设计并没有让vcpkg更容易集成。</strong>这一段试图将vcpkg框定为填补系统包经理的角色，措辞非常巧妙。</p><p id="0967" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated"><strong class="hv iz">但是vcpkg并没有很好地服务于改善开发者跨操作系统体验的目标。</strong> Linux包管理器首先出现，发行版在管理的存储库中提供了浮动但通常兼容的库和工具版本。人们可以通过改变存储库来切换“稳定/测试”频道。但是发行版之间的兼容性仍然很差，而且由于时间限制，我们经常不得不一次选择一个发行版来支持。倒退<em class="iv">可能</em>发生。因此，当我们开始将这些应用程序引入Mac时，我们需要模仿<em class="iv">那套</em>依赖关系。今天，自制程序经常使用预编译的二进制文件，并且经常获取特定的依赖版本。家酿还可以安装特定的配方版本。我们没有，而且<em class="iv">也不能</em>通过增加开发人员必须解决的排列数量来改善他们的体验。</p><p id="3856" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">它应该告诉我们<em class="iv">整个行业如何统一和专注于消除系统包管理</em>。依赖地狱在开发中代价高昂，但在生产中却是灾难性的。因此，我们得到了<strong class="hv iz"> Docker </strong>和<strong class="hv iz"> Ubuntu Snap Packages </strong>，以及一百个容器化包的迭代，以及<strong class="hv iz">十几个新的云操作系统</strong>，它们的目标都是<em class="iv">不</em>与任何人共享依赖关系，有时甚至完全消除系统包管理。</p><p id="751c" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">理由3无视现代发展和devops实践，并使用了一些我在外交电报之外见过的最棘手的措辞。</p><blockquote class="is it iu"><p id="0987" class="hs ht iv hv b hw hx hy hz ia ib ic id iw if ig ih ix ij ik il iy in io ip iq hn dt translated">C++/CMake vs python。虽然Python是一种受到许多人喜爱的优秀语言，但我们认为，在选择一种对于您的工作流来说像包管理器一样重要的工具时，透明度和熟悉度是最重要的因素。因此，我们选择使实现语言尽可能被普遍接受:C++应该在C++程序员的C++包管理器中使用。你不应该仅仅为了理解你的包管理器而学习另一种语言。</p></blockquote><p id="223b" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated"><strong class="hv iz">论据:1。透明度，熟悉与工具的交互。2.尽可能普遍接受的实现语言。3.你不需要学习另一种语言来理解你的包管理器。</strong></p><p id="938b" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">我将假设如果您已经成功编辑了一个. ini文件，那么您可以使用声明性的conanfile.txt语法。如果您在CMake中保留逻辑，它可能就足够了。柯南通过CMake你需要的所有变量。如果根据操作系统需要不同的依赖项，您可能会切换到conanfile.py(假设您在Windows上使用SChannel，但在linux上使用OpenSSL)。</p><p id="7124" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">为了便于讨论，让我们从针对conanfile.py列出的最复杂的示例之一开始:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="9e0f" class="kr jb hu lk b fv lo lp l lq lr">from conans import ConanFile, CMake<br/><br/>class PocoTimerConan(ConanFile):<br/>   settings = "os", "compiler", "build_type", "arch"<br/>   requires = "Poco/1.7.3@lasote/stable"<br/>   generators = "cmake", "gcc", "txt"<br/>   default_options = "Poco:shared=True", "OpenSSL:shared=True"<br/><br/>   def imports(self):<br/>      self.copy("*.dll", dst="bin", src="bin") # From bin to bin<br/>      self.copy("*.dylib*", dst="bin", src="lib") # From lib to bin<br/><br/>   def build(self):<br/>      cmake = CMake(self.settings)<br/>      self.run('cmake "%s" %s' % (self.conanfile_directory, cmake.command_line))<br/>      self.run('cmake --build . %s' % cmake.build_config)</span></pre><p id="2393" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">有能力编写C或C++的人会在理解这一点上有困难吗？</p><p id="6038" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">最神奇的一点是CMake(self.settings)有一个. command_line和。build_config方法，这种特定于生成器的逻辑使得CMake可以使用比您预期的更多的变量。</p><p id="b1d9" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">我不能把它和vcpkg相提并论，因为我甚至没有看到它提供依赖列表的地方。我假设使用了某种脚本来为每个包调用它？看起来你在学习另一种语言！</p><p id="dbb6" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated"><strong class="hv iz">论据二。尽可能普遍接受的实现语言。</strong></p><p id="5d21" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">被谁接受了？操作系统？据我所知，Python是世界上安装最广泛的脚本语言。它通常出现在最简单的docker图像上。你用Visual Studio发布它。它几乎与linux和os x的所有发行版捆绑在一起。</p><p id="46a0" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">如果你在谈论C++开发社区的理解，这是一个不寻常的论点。包管理器通常不被检查；我们只是希望它们能起作用。如果他们不这样做，我们就向了解该领域的专家投诉。这是一个很大的领域，有许多支点和复杂性。</p><p id="325f" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">让我们看一些例子。NuGet已经存在5年多了，但是<a class="ae ir" href="https://github.com/NuGet/NuGet.Client" rel="noopener ugc nofollow" target="_blank">只获得了30个重要贡献者</a>。我没发现任何不是MSFT员工的人。也许这个项目不是作为一个真正的开源项目来管理的，这是有影响的。让我们来看一个社区开发的项目——Chocolatey。<a class="ae ir" href="https://github.com/chocolatey/choco" rel="noopener ugc nofollow" target="_blank">哇。只有一个重要的贡献者</a>。</p><p id="b240" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">包管理、编解码器、图像处理库等领域需要大量的领域知识。作为维护者，我们希望选择我们认为最有可能鼓励贡献的技术。我们最好为这项任务选择最好的工具。如果已经有一个工具可以满足我们的需求，我们就使用它。</p><p id="255c" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">拒绝一个工具，因为它不是用你最喜欢的语言编写的，这似乎是微软的文化现象。在其他社区，我们积极地融合了用一系列语言编写的工具。以一个rails应用为例。通常有1-2个用ML风格语言编写的工具，几个C和C++组件，嵌入式lua运行时，某种形式的用于资产管理的npm(至少)，Perl(使用git？)，一点Crystal，Rust，各种Java包，还有各种你可能不知道的Python应用都是用Python搭建的，因为他们还没有喷出一个stacktrace。</p><p id="2024" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">我们希望到2019年，NuGet能达到Bundler 60%的功能对等。我被告知，在NuPack之前，在早期阶段，Bundler被使用。但它必须是C#，而不是所有东西中的Ruby。所以我们求助于…一个自称是软件包管理器的单平台、单工具的脚本集。这里有历史，似乎在重复。</p><p id="b1bf" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated"><strong class="hv iz">论据3。你不需要学习另一种语言来理解你的包管理器。</strong></p><p id="a2e9" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">我的回应:<strong class="hv iz">文档</strong>。</p><h2 id="e703" class="kr jb hu bd jc ks kt ku jg kv kw kx jk ie ky kz jo ii la lb js im lc ld jw le dt translated">vcpkg不应该把自己标榜成一个包管理者</h2><p id="8889" class="pw-post-body-paragraph hs ht hu hv b hw jy hy hz ia jz ic id ie ka ig ih ii kb ik il im kc io ip iq hn dt translated">已经有了针对C和C++的开源包管理器。它设计得很好，是许多真实世界迭代和部署的结果，并由在该领域具有丰富经验的开发人员提供支持。</p><ul class=""><li id="606c" class="kd ke hu hv b hw hx ia ib ie kf ii kg im kh iq ki kj kk kl dt translated">它在跨操作系统、C运行时和编译器兼容性方面处理得非常好。这个设计很棒。</li><li id="1bf9" class="kd ke hu hv b hw km ia kn ie ko ii kp im kq iq ki kj kk kl dt translated">它是构建系统不可知的——能够与任何东西集成——但是非常容易理解和使用。</li><li id="ef16" class="kd ke hu hv b hw km ia kn ie ko ii kp im kq iq ki kj kk kl dt translated">它可以通过CMake或nmake或任何您喜欢的工具直接与Visual Studio一起工作，并且具有最少的样板文件。</li><li id="0d93" class="kd ke hu hv b hw km ia kn ie ko ii kp im kq iq ki kj kk kl dt translated">您可以使用conanfile.txt或conanfile.py来声明您的包、依赖项、额外的配置/枢轴，并构建通过其发送枢轴的调用。前12个构建系统的提供者使得这是自动的——除非你想要更多的控制。在任何抽象层次上都没有痛苦。conaninfo.txt是Conan在目标构建目录中创建的文件，它提供了编译器设置和正在使用的包版本的可见性。</li><li id="414a" class="kd ke hu hv b hw km ia kn ie ko ii kp im kq iq ki kj kk kl dt translated">本质上不易碎，但能处理极其复杂的情况。</li></ul><p id="5ddd" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">使用Visual Studio和CMake是微不足道的。</p><h2 id="d4eb" class="kr jb hu bd jc ks kt ku jg kv kw kx jk ie ky kz jo ii la lb js im lc ld jw le dt translated">生态系统</h2><p id="1f3b" class="pw-post-body-paragraph hs ht hu hv b hw jy hy hz ia jz ic id ie ka ig ih ii kb ik il im kc io ip iq hn dt translated">我说过我会回到生态系统。vcpkg的FAQ将自己描述为软件包生态系统的冠军，在这方面比柯南更胜一筹。让我们往回看一点，看看包管理器的生态系统。</p><h2 id="8180" class="kr jb hu bd jc ks kt ku jg kv kw kx jk ie ky kz jo ii la lb js im lc ld jw le dt translated">采用包管理器</h2><p id="ad97" class="pw-post-body-paragraph hs ht hu hv b hw jy hy hz ia jz ic id ie ka ig ih ii kb ik il im kc io ip iq hn dt translated">C和C++是进行包管理的硬语言。开发人员有理由感到害怕——许多构建工具声称解决了包管理问题，但在关键细节上却失败了。存在一些特定于构建工具的管理器(cpm，hunter)。</p><p id="0483" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">考虑到明显的限制(或怀疑隐藏的限制)，很难鼓励开发人员投资新工具。在柯南之前，核心开发者创造了Biicode。作为一家公司，Biicode无法将C/++包管理货币化，最终破产。他们吸取了从商业C++包管理中学到的经验，设计了柯南，同时帮助Biicode用户尽可能地过渡，并通过周末咨询资助他们的工作。他们的社区成长了，他们现在是JFrog/Artifactory的一部分，但我以前从未见过对一个问题如此投入。</p><p id="ab9e" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">C/C++生态系统的共识似乎正在向作为跨平台构建工具的CMake靠拢。这让我的生活更轻松。但是采用包管理是一个较慢的任务，尽管需要更少的努力。系统包管理人员的痛苦催生了一种“在树内复制源代码”的宗教，这种宗教很难根除。</p><p id="f321" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">常用包的维护人员刚开始添加conanfile.py，设置Travis和AppVeyor进行跨平台包部署。如果我们希望低摩擦的跨平台开发变得无处不在，我们迫切需要这种趋势继续下去。</p><p id="ad64" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">微软有取代现有或新生开源项目的历史记录。通常替换物是在没有研究现有技术的情况下设计的，并且缺乏技术价值。</p><p id="1bdb" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">确保解决方案基于广告或品牌而非价值取得成功的最有效方法是</p><p id="09ce" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">(a)假装你从未听说过它们，在用户信任你相信现有技术的地方保持沉默，或者(b)使用虚假信息策略来确保竞争对手的角色和价值被误解。</p><p id="922d" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">考虑到软件开发社区的大部分人都指望微软品牌在工具和技术选择方面起到领导作用(福音传道者发挥了作用)，我认为大多数进入开源领域的Windows C#和C++开发人员都是这样做的(至少部分是因为)微软已经接受了开源。他们仍然青睐微软表示感兴趣的工具。</p><p id="6676" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">从众心理压倒了几乎所有其他因素，软件开发人员有意地参与到这个<em class="iv"/>中，也许是希望一个东西的使用会推迟它不可避免的、最终的放弃。微软可能不再是软件行业的领头羊，但它仍然是一个极其庞大的队伍的领头羊，这足以引发一群人。</p><p id="72eb" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">具有讽刺意味的是，下载量和Github发行数量可能与软件寿命无关——贡献者标签才是最重要的——但在采用方面，认知度是90%。</p><p id="bf2a" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">我倾向于认为，封闭源代码文化的后遗症需要很长时间才能消除，这种后遗症(而不是任何特定的意图)是过去十年中导致微软与开源社区关系紧张的更不小心的事件的原因。</p><p id="bfa9" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">在更大的开源社区中活跃了很长时间的微软员工似乎更仔细地考虑他们的出版物的影响，并且更有效地通过协作和协调达到他们的目标。箭少柴多。</p><p id="c535" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">许多人认为每种语言一个包管理器太多了，而且考虑到领域难度和贡献者池，这是不可持续的。他们是对的。不过没关系，因为软件开发人员需要包管理器来进行快速开发，他们需要特定于语言的特性。我们可以(并且已经)统一软件包管理的科学，这很有帮助，但是没有足够的人来完成这项工作。所以我们尽我们所能。我们甚至会牺牲<em class="iv">年</em>的构建可再现性来获得那个生产力(参见NuGet)。</p><p id="6f80" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">我没有看到任何证据表明在这个项目推广之前有合法的现有技术分析。文档中的许多其他基本原理令人困扰。</p><p id="1f41" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">FAQ中对柯南(以及更广泛的上下文)的曲解非常令人不安。我们努力让开源成为一个更友善、更真诚的地方。</p><p id="529c" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">在他们的自述文件顶部提到相近的现有技术，并在文件夹上方提供差异化(或链接)是一个很好的传统。这种区分应该坚持客观和仔细研究的事实，以及每个项目的范围和目标的官方声明。向读者提供所有事实，让他们考虑哪种解决方案最适合他们的情况，这是非常周到的。</p><p id="e932" class="pw-post-body-paragraph hs ht hu hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq hn dt translated">这为友好合作和真诚工作的精神奠定了基础，我们的共同目标是让软件开发人员更快乐(或者类似的东西，我希望)。</p><blockquote class="is it iu"><p id="53b7" class="hs ht iv hv b hw hx hy hz ia ib ic id iw if ig ih ix ij ik il iy in io ip iq hn dt translated"><a class="ae ir" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ir" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ir" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ir" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="hs ht iv hv b hw hx hy hz ia ib ic id iw if ig ih ix ij ik il iy in io ip iq hn dt translated">要了解更多信息，请<a class="ae ir" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae ir" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上给我们点赞/发消息</a>，或者简单地说，<a class="ae ir" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="hs ht iv hv b hw hx hy hz ia ib ic id iw if ig ih ix ij ik il iy in io ip iq hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ir" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ir" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>