<html>
<head>
<title>Managing Complex Data Structures in NodeJS.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在NodeJS中管理复杂的数据结构。</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/managing-complex-data-structures-in-nodejs-17b571c0ba04?source=collection_archive---------3-----------------------#2017-09-18">https://medium.com/hackernoon/managing-complex-data-structures-in-nodejs-17b571c0ba04?source=collection_archive---------3-----------------------#2017-09-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="f9f4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当开始一个新项目时，如何正确组织数据的问题通常是首先要解决的问题之一。假设需要存储用户的数据。使用Mongo并将数据存储为集合，我们有几个选择。例如，假设我们需要存储每个用户的以下数据:</p><h2 id="3402" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">用户信息:</h2><ol class=""><li id="cd4d" class="kk kl hu it b iu km iy kn jc ko jg kp jk kq jo kr ks kt ku dt translated">使用者辩证码</li><li id="a042" class="kk kl hu it b iu kv iy kw jc kx jg ky jk kz jo kr ks kt ku dt translated">西方人名的第一个字</li><li id="b0bd" class="kk kl hu it b iu kv iy kw jc kx jg ky jk kz jo kr ks kt ku dt translated">姓</li><li id="18a4" class="kk kl hu it b iu kv iy kw jc kx jg ky jk kz jo kr ks kt ku dt translated">现地址</li><li id="78e0" class="kk kl hu it b iu kv iy kw jc kx jg ky jk kz jo kr ks kt ku dt translated">电子邮件地址</li><li id="993a" class="kk kl hu it b iu kv iy kw jc kx jg ky jk kz jo kr ks kt ku dt translated">住宅电话</li><li id="4e1b" class="kk kl hu it b iu kv iy kw jc kx jg ky jk kz jo kr ks kt ku dt translated">工作电话</li><li id="eea3" class="kk kl hu it b iu kv iy kw jc kx jg ky jk kz jo kr ks kt ku dt translated">手机</li><li id="d807" class="kk kl hu it b iu kv iy kw jc kx jg ky jk kz jo kr ks kt ku dt translated">如果电话号码已经被验证</li></ol><p id="24c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">处理这些数据的一种方法是为列表中的每一项创建一个单独的模式。然后，我们可以做一个模式引用来引用其他模式中的数据。看起来大概是这样的:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="3e0d" class="jp jq hu lf b fv lj lk l ll lm">const mongoose = require('mongoose');</span><span id="bf56" class="jp jq hu lf b fv ln lk l ll lm">let Schema = mongoose.Schema;</span><span id="1dd6" class="jp jq hu lf b fv ln lk l ll lm">const userIDSchema = new Schema({</span><span id="91f2" class="jp jq hu lf b fv ln lk l ll lm">UserID: {<br/>    type: mongoose.Schema.Types.Mixed,<br/>  },<br/>  })</span><span id="d2f1" class="jp jq hu lf b fv ln lk l ll lm">const UserID = mongoose.model('UserID', userIDSchema);</span><span id="852b" class="jp jq hu lf b fv ln lk l ll lm">module.exports = UserID;</span></pre><p id="d8e5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，在我们的用户名字模式中，我们将这样做:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="17f8" class="jp jq hu lf b fv lj lk l ll lm">const mongoose = require('mongoose');</span><span id="7e38" class="jp jq hu lf b fv ln lk l ll lm">let Schema = mongoose.Schema;</span><span id="70d1" class="jp jq hu lf b fv ln lk l ll lm">const FirstNameSchema = new Schema({</span><span id="dad4" class="jp jq hu lf b fv ln lk l ll lm">UserID: {<br/>    type: mongoose.Schema.Types.Mixed,</span><span id="10d5" class="jp jq hu lf b fv ln lk l ll lm">    ref: 'UserId', <br/>},</span><span id="5cbf" class="jp jq hu lf b fv ln lk l ll lm">First_Name: {</span><span id="0e3f" class="jp jq hu lf b fv ln lk l ll lm">    type: String,</span><span id="4e18" class="jp jq hu lf b fv ln lk l ll lm">},<br/>  })</span><span id="cf6d" class="jp jq hu lf b fv ln lk l ll lm">const FirstName = mongoose.model('Firstname', FirstNameSchema);</span><span id="7bef" class="jp jq hu lf b fv ln lk l ll lm">module.exports = FirstName;</span></pre><p id="daf7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，对于列表中的每个后续项目，我们会做一些类似的事情。这样，每个模式都是独立的，但是可以访问其他数据。然而，当创建这么多不同的模型和路线时，这会变得很麻烦。当决定如何在后端组织数据时，这通常是主要的考虑因素之一。您预计数据将如何增长，当前的数据组织是否允许将来轻松扩展和操作数据？就我们的用户数据而言，我们当前的模型可能不是最好的。或者，我们可以将所需的数据嵌套在模型的对象和数组中，而不是在模式之间引用数据。让我们像这样重新组织我们的数据:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="9285" class="jp jq hu lf b fv lj lk l ll lm">const User = mongoose.model('Story', userSchema);</span><span id="22dd" class="jp jq hu lf b fv ln lk l ll lm">module.exports = User;</span><span id="51ae" class="jp jq hu lf b fv ln lk l ll lm">const mongoose = require('mongoose');</span><span id="029e" class="jp jq hu lf b fv ln lk l ll lm">let Schema = mongoose.Schema;</span><span id="9e2e" class="jp jq hu lf b fv ln lk l ll lm">const userSchema = new Schema({</span><span id="afe1" class="jp jq hu lf b fv ln lk l ll lm">UserID: {<br/>    type: mongoose.Schema.Types.Mixed,<br/>  },<br/>  User_Info: {<br/>    First_Name: {<br/>      type: String,<br/>    },<br/>    Last_Name: {<br/>      type: String,<br/>    },<br/>    Current_Address: {<br/>      type: String,<br/>    },<br/>    Email_Address: {<br/>      type: String,<br/>    },<br/>  },<br/>      Phone_Numbers: [{<br/>        Home_Phone: {<br/>          type: Number,<br/>        },<br/>        Work_Phone: {<br/>          type: Number,<br/>        },<br/>        Cell_Phone: {<br/>          type: Number,<br/>        },<br/>            Phone_verified: [{<br/>              Home: Boolean,</span><span id="c7b4" class="jp jq hu lf b fv ln lk l ll lm">              Work: Boolean,</span><span id="c1f6" class="jp jq hu lf b fv ln lk l ll lm">              Cell: Boolean,<br/>            }],<br/>      }],</span><span id="45f3" class="jp jq hu lf b fv ln lk l ll lm">})</span><span id="1f9a" class="jp jq hu lf b fv ln lk l ll lm">const User = mongoose.model('User', userSchema);</span><span id="e5ef" class="jp jq hu lf b fv ln lk l ll lm">module.exports = User;</span></pre><p id="44f0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里，我们将所有用户信息存储在一个对象中。然后，我们的三个电话号码作为对象存储在一个名为“Phone_Numbers”的数组中。在“Phone_Numbers”数组中，我们有一个名为“Phone-Verified”的子文档，它是一个对象数组，指示这些电话号码是否已经过验证。作为mongoose中的一个模型，很容易看出这些数据是如何组织和嵌套的。然而，正确发布数据可能会更加困难。如果我们将这些数据提交给一个API，我们的响应将是JSON格式的，我们的API调用可能如下所示:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="fd1a" class="jp jq hu lf b fv lj lk l ll lm">app.post('/api/user', function(req, res) {<br/>  User.create({<br/>    UserID: req.body.userid,<br/>    User_Info: req.body.userinfo,<br/>    First_Name: req.body.firstname,<br/>    Last_Name: req.body.lastname,<br/>    Current_Address: req.body.currentaddress,<br/>    Email_Address: req.body.emailaddress,<br/>    Phone_Numbers: req.body.phonenumbers,<br/>    Home_Phone: req.body.homephone,<br/>    Work_Phone: req.body.workphone,<br/>    Cell_Phone: req.body.cellphone,<br/>    Phone_Verified:<br/>    req.body.phoneverified,<br/>    Home: req.body.home,<br/>    Work: req.body.work,<br/>    Cell: req.body.cell,<br/>  }).then(user =&gt; {<br/>    res.json(user)<br/>  });<br/>});</span></pre><p id="6770" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可能已经注意到，在我们的app.post中，我们有“Phone_Numbers:”和“Phone_Verified”以及“User_Info”字段，尽管我们模型中的这些字段只是不包含实际数据的数组的名称。但是，有必要在我们的app.post中包含这一点。否则，帖子将不起作用。</p><p id="db2a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，如果我们要创建应用程序的前端，我们需要在app.js文件中包含这个依赖项:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="e730" class="jp jq hu lf b fv lj lk l ll lm">const bodyParser = require('body-parser');</span><span id="db27" class="jp jq hu lf b fv ln lk l ll lm">app.use(bodyParser.urlencoded({<br/>  extended: true<br/>}));</span></pre><p id="038f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们调用app.use时，确保我们将它设置为“extended: true ”,这将允许我们从前端表单向数据库中的嵌套数据发送数据。这就把我们带到了谜题的最后一部分，前端表单。让我们首先处理我们的UserID字段。这是最简单的，因为它不是嵌套的。无论您使用react、mustache还是其他什么，我们输入的命名都是一样的。它可能看起来像这样:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="c929" class="jp jq hu lf b fv lj lk l ll lm">&lt;input autocomplete="off" class="input" required type="text" name="userid"&gt;&lt;/input&gt;</span></pre><p id="f1f1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们需要做的就是确保“name”与我们在app.js文件中使用的“req.body.userid”相匹配。现在，我们如何发布到用户信息的嵌套对象？我们会做如下的事情:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="c7d8" class="jp jq hu lf b fv lj lk l ll lm">&lt;input autocomplete="off" class="input" required type="text" name="userinfo[firstname]"&gt;&lt;/input&gt;</span></pre><p id="8204" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为我们使用的是主体解析器，并且我们将它设置为urlencoded extended: true，所以主体解析器将把这个名称字段解释为嵌套对象。我们将对嵌套对象中的“姓氏”和其他字段做同样的事情，如下所示:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="c418" class="jp jq hu lf b fv lj lk l ll lm">&lt;input autocomplete="off" class="input" required type="text" name="userinfo[lastname]"&gt;&lt;/input&gt;</span></pre><p id="5f9e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在更复杂的是我们的嵌套数组。我们该怎么发布呢？嗯，我们会做一些非常类似的事情，这将再次被我们的身体解析器解释。假设只有一个用户。并且该用户只有一部住宅电话、一部手机和一部工作电话。在这种情况下，我们的表单输入将如下所示:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="3ff0" class="jp jq hu lf b fv lj lk l ll lm">&lt;input autocomplete="off" class="input" required type="text" name="phonenumbers[homephone]"&gt;&lt;/input&gt;</span><span id="846e" class="jp jq hu lf b fv ln lk l ll lm">&lt;input autocomplete="off" class="input" required type="text" name="phonenumbers[workphone]"&gt;&lt;/input&gt;</span></pre><p id="5528" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，如果在我们的数据结构中，每个文档中有多个子用户，或者多个家庭，或者需要为其添加电话的家庭成员，但是仍然将它们嵌套在用户中，那会怎么样呢？在这种情况下，您可以轻松地添加一组电话号码。在我们的前端，输入会有轻微的变化。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="f1fa" class="jp jq hu lf b fv lj lk l ll lm">&lt;input autocomplete="off" class="input" required type="text" name="phonenumbers[0][homephone]"&gt;&lt;/input&gt;</span></pre><p id="31cf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么我们的第二个输入应该是这样的:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="6fe0" class="jp jq hu lf b fv lj lk l ll lm">&lt;input autocomplete="off" class="input" required type="text" name="phonenumbers[1][homephone]"&gt;&lt;/input&gt;</span></pre><p id="4ef7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">主体解析器将其解释为数组的索引，并将它们作为电话号码添加到用户集合中的电话号码数组中。现在，如您所见，我们的验证电话号码字段嵌套在电话号码中。这看起来和我们在这里做的非常相似。它可能看起来像这样:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="c87a" class="jp jq hu lf b fv lj lk l ll lm">&lt;input autocomplete="off" class="input" required type="text" name="phonenumbers[1][phoneverified][0]"&gt;&lt;/input&gt;</span></pre><p id="f141" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如你所见，我们在这里发布深层嵌套数据，并可以继续这种格式，甚至更深层的嵌套数据。尽管有其他方法可以做到这一点，但是这个解决方案是优雅的、简单的，并且有望节省一些时间。顺便说一下，这种格式也适用于Postman，如果你以这种方式发布数据的话。</p><p id="326c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">希望这有所帮助，如果您有任何反馈或意见，请随时联系我们。谢谢！</p></div></div>    
</body>
</html>