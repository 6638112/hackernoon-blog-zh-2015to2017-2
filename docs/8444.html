<html>
<head>
<title>Quick &amp; Easy Elixir Refactorings — Part 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快速简单的灵丹妙药重构—第4部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/quick-easy-elixir-refactorings-part-4-4096a8022988?source=collection_archive---------8-----------------------#2017-12-02">https://medium.com/hackernoon/quick-easy-elixir-refactorings-part-4-4096a8022988?source=collection_archive---------8-----------------------#2017-12-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="d59d" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">嵌套条件句</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/05c2abf945219e3f34063fdf06591b64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Go_cRIV7eO_KC4djZ71bg.jpeg"/></div></div></figure><p id="98c7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在前一部分中，我们研究了如何通过传入一个函数来重构函数中间的条件。在此之前，我们看了在函数的开头和结尾重构T4条件句。</p><p id="edc7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果你还没有通读这个系列，我建议你从头开始</p><p id="3775" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><a class="ae kr" rel="noopener" href="/@efexen/quick-easy-elixir-refactorings-part-1-17376e9c455a">第1部分—以条件</a> <a class="ae kr" rel="noopener" href="/@efexen/quick-easy-elixir-refactorings-part-2-4cd66bad1b20"> <br/>开头的函数第2部分—以条件</a> <br/> <a class="ae kr" rel="noopener" href="/@efexen/quick-easy-elixir-refactorings-part-3-def1aae4b072">结尾的函数第3部分—中间的条件</a></p><p id="4a4c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在这篇文章中，我们将看看如何处理嵌套条件句。有人认为我不喜欢条件句，这是可以理解的😉</p></div><div class="ab cl ks kt hc ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hn ho hp hq hr"><h2 id="c64a" class="kz la hu bd lb lc ld le lf lg lh li lj ke lk ll lm ki ln lo lp km lq lr ls lt dt translated">嵌套条件句</h2><p id="3508" class="pw-post-body-paragraph jv jw hu jx b jy lu iv ka kb lv iy kd ke lw kg kh ki lx kk kl km ly ko kp kq hn dt translated">嵌套条件在其他语言中是一个大得多的问题，通常是因为函数太长，应该已经被拆分了，但有时会出现这种情况，最好有一种简洁的方法来处理它们。</p><p id="0c50" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">一个例子可能是这样的</p><pre class="jk jl jm jn fq lz ma mb mc aw md dt"><span id="ebf5" class="kz la hu ma b fv me mf l mg mh">defmodule Example do</span><span id="d7ac" class="kz la hu ma b fv mi mf l mg mh">  def authorised?(user) do<br/>    case UserAuthenticator.authorised?(user) do<br/>      {:ok, _user} -&gt;<br/>        true<br/>      {:error, _user} -&gt;<br/>        case LegacyUserAuthenticator.authorised?(user) do<br/>          {:ok, _user} -&gt;<br/>            true<br/>          {:error, _user} -&gt;<br/>            false<br/>        end<br/>    end<br/>  end</span><span id="8b70" class="kz la hu ma b fv mi mf l mg mh">end</span></pre><p id="14aa" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这段代码并不十分优雅，阅读起来也有点棘手。想象一下，如果我们不返回简单的布尔值，而是执行一些更长的逻辑😓</p><p id="9641" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们可以像这样拆分<code class="eh mj mk ml ma b">authorised?/1</code>函数来消除嵌套</p><pre class="jk jl jm jn fq lz ma mb mc aw md dt"><span id="7ed1" class="kz la hu ma b fv me mf l mg mh">def authorised?(user) do<br/>  case UserAuthenticator.authorised?(user) do<br/>    {:ok, _user} -&gt;<br/>      true<br/>    {:error, _} -&gt;<br/>      legacy_authorized?(user)<br/>  end<br/>end</span><span id="bb13" class="kz la hu ma b fv mi mf l mg mh">defp legacy_authorized?(user) do<br/>  case LegacyAuthenticator.authorised?(user) do<br/>    {:ok, _user} -&gt;<br/>      true<br/>    {:error, _} -&gt;<br/>      false<br/>  end<br/>end</span></pre><p id="8c23" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">万岁，不再筑巢🙌通过使用本系列前面的技术，我们可以完全消除条件句，得到类似这样的结果</p><pre class="jk jl jm jn fq lz ma mb mc aw md dt"><span id="cf4e" class="kz la hu ma b fv me mf l mg mh">def authorised?(user) do<br/>  user<br/>  |&gt; UserAuthenticator.authorised?()<br/>  |&gt; check_authorised()<br/>end</span><span id="396a" class="kz la hu ma b fv mi mf l mg mh">def check_authorised({:ok, _}), do: true<br/>def check_authorised({:error, user}) do<br/>  user<br/>  |&gt; LegacyAuthenticator.authorised?()<br/>  |&gt; check_legacy()<br/>end</span><span id="a01d" class="kz la hu ma b fv mi mf l mg mh">def check_legacy({:ok, _}), do: true<br/>def check_legacy(_), do: false</span></pre><p id="7b03" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">当你在初始条件的两个分支中都有嵌套的时候，这很好，因为它允许你把所有的分支都放在很多小函数上。</p><p id="82e6" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">幸运的是，在我们的例子中，我们只有一个分支中的嵌套条件，这允许我们使用<code class="eh mj mk ml ma b">with</code>语句来查看替代选项</p><pre class="jk jl jm jn fq lz ma mb mc aw md dt"><span id="e99a" class="kz la hu ma b fv me mf l mg mh">def authorised?(user) do<br/>  with {:error, _} &lt;- UserAuthenticator.authorised?(user),<br/>       {:error, _} &lt;- LegacyAuthenticator.authorised?(user) do<br/>         false<br/>       else<br/>         {:ok, _} -&gt; true<br/>       end<br/>  end</span></pre><p id="9c17" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt">😮 😍</p></div><div class="ab cl ks kt hc ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hn ho hp hq hr"><p id="5a1f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">从技术上来说，我们最终得到的仍然是一个条件，但是与我们上面的选择相比，我认为这是一个非常好的解决初始问题的方案。</p><p id="92f3" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果你不熟悉<code class="eh mj mk ml ma b">with</code>语句，我强烈建议你尝试一下，因为它可以让代码更容易推理，而且肯定比一堆嵌套的条件语句更清晰。</p><p id="c202" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">请点击掌声图标👏如果你喜欢这篇文章，请在这里或Twitter上关注我，<a class="ae kr" href="https://twitter.com/efexen" rel="noopener ugc nofollow" target="_blank"> @efexen </a>来寻找简短的可操作的文章，在那里我们会看到更多简单的技巧来提升你的<a class="ae kr" href="https://hackernoon.com/tagged/elixir" rel="noopener ugc nofollow" target="_blank">药剂</a>代码👍</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mm mn l"/></div></figure></div></div>    
</body>
</html>