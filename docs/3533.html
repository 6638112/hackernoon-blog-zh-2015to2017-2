<html>
<head>
<title>Making manual form input a tiny bit better</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让手工表单输入稍微好一点</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/making-manual-form-input-a-tiny-bit-better-ef40f04b5ea3?source=collection_archive---------13-----------------------#2017-04-06">https://medium.com/hackernoon/making-manual-form-input-a-tiny-bit-better-ef40f04b5ea3?source=collection_archive---------13-----------------------#2017-04-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="4f73" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">在UIProgressView和协议的帮助下</h2></div><p id="74aa" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">表单输入从来都不好玩。尤其是在<a class="ae kf" href="https://hackernoon.com/tagged/mobile" rel="noopener ugc nofollow" target="_blank">移动</a>设备上。在我们的<a class="ae kf" href="https://hackernoon.com/tagged/wevat" rel="noopener ugc nofollow" target="_blank"> WeVat </a>应用程序中，我们确实要求用户手动输入他们的一些细节，所以我们努力让用户尽可能不痛苦！</p><p id="fcdc" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们最近实现的一个功能是一个简单的进度视图，巧妙地向用户显示他们在流程中的进度。</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff kg"><img src="../Images/d6fe4a0240c6e6f4ceece1255873ee07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x1zvkUU0uojLajz4jNFxLw.png"/></div></div></figure><p id="f745" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我将向您展示如何以一种通用的方式编写这个进度视图，这样您就可以将它放入您的<code class="eh ks kt ku kv b">UINavigationController</code>中并完成它！所以让我们开始吧。</p><p id="86c7" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">TL；速度三角形定位法(dead reckoning)</p><ul class=""><li id="ec81" class="kw kx hu jl b jm jn jp jq js ky jw kz ka la ke lb lc ld le dt translated">创建将UIProgressView视图呈现为UINavigationController子视图的协议</li><li id="5971" class="kw kx hu jl b jm lf jp lg js lh jw li ka lj ke lb lc ld le dt translated">创建更新UIProgressView的协议</li><li id="c71e" class="kw kx hu jl b jm lf jp lg js lh jw li ka lj ke lb lc ld le dt translated">使您的UINavigationController符合演示者协议</li><li id="ce63" class="kw kx hu jl b jm lf jp lg js lh jw li ka lj ke lb lc ld le dt translated">使导航堆栈中的每个UIViewController符合更新程序协议</li></ul><p id="fd0a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">只想要密码？没有牛肉！在此下载示例项目<a class="ae kf" href="https://github.com/harryblam/FormEntryProgress" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="fc39" class="lk ll hu bd lm ln lo lp lq lr ls lt lu ja lv jb lw jd lx je ly jg lz jh ma mb dt translated">表单设置</h1><p id="2cc4" class="pw-post-body-paragraph jj jk hu jl b jm mc iv jo jp md iy jr js me ju jv jw mf jy jz ka mg kc kd ke hn dt translated">我在Xcode中建立了一个新项目，在一个<code class="eh ks kt ku kv b">UINavigationController</code>中有一个四个<code class="eh ks kt ku kv b">UIViewControllers</code>的堆栈。每个按钮都有自己的next按钮，可以将segue推到下一个视图控制器，还有一个finish按钮，可以将您带回到展开segue的开始。</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff mh"><img src="../Images/9af85434f599fa16271faf01d4c4909a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J6MeZAza-bvNWubNIpBm1Q.png"/></div></div><figcaption class="mi mj fg fe ff mk ml bd b be z ek">Our basic navigation flow</figcaption></figure><h1 id="060c" class="lk ll hu bd lm ln lo lp lq lr ls lt lu ja lv jb lw jd lx je ly jg lz jh ma mb dt translated">进度视图演示者</h1><p id="b736" class="pw-post-body-paragraph jj jk hu jl b jm mc iv jo jp md iy jr js me ju jv jw mf jy jz ka mg kc kd ke hn dt translated">正如我在<a class="ae kf" rel="noopener" href="/@harrybloom18">以前的文章</a>中所提到的，我们试图通过使用协议来尽可能多地将<em class="mm">功能化。所以让我们创建一个协议来处理<code class="eh ks kt ku kv b">UIProgressView</code>的显示。</em></p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="1184" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一旦我们有了这个，我们就可以使用协议扩展来提供一些默认的行为来配置这个视图。我们将需要确保视图被添加到它的superview和布局正确。确保将视图固定到<code class="eh ks kt ku kv b">UINavigationController</code>的<code class="eh ks kt ku kv b">navigationBar</code>属性</p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="c4c4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通过进一步扩展<code class="eh ks kt ku kv b">UINavigationController</code>，我们可以为协议提供视图，从而为实现这一点的所有导航控制器提供默认行为。伙计，我喜欢协议扩展。</p><p id="90de" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，我们可以创建我们的<code class="eh ks kt ku kv b">UINavigationController</code>子类，并在这里实现我们的协议，将这个功能添加到我们导航栈中的所有视图控制器中。<strong class="jl hv">不要忘记将它作为自定义类添加到故事板中。</strong></p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="mn mo l"/></div></figure><h1 id="38d0" class="lk ll hu bd lm ln lo lp lq lr ls lt lu ja lv jb lw jd lx je ly jg lz jh ma mb dt translated"><strong class="ak">进度视图更新器</strong></h1><p id="93b5" class="pw-post-body-paragraph jj jk hu jl b jm mc iv jo jp md iy jr js me ju jv jw mf jy jz ka mg kc kd ke hn dt translated">好了，现在我们的导航栏中有了<code class="eh ks kt ku kv b">UIProgressView</code>，但是我们如何更新你所询问的每个视图控制器的进度呢？</p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="e339" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以创建另一个协议来处理这个功能。我将向您详细介绍这些功能的功能。</p><ol class=""><li id="00ed" class="kw kx hu jl b jm jn jp jq js ky jw kz ka la ke mp lc ld le dt translated"><code class="eh ks kt ku kv b">updateProgress</code>简单的一个浮动和动画<code class="eh ks kt ku kv b">Bool</code>。稍后我们将把它传递给底层的<code class="eh ks kt ku kv b">UIProgressView.setProgress</code>。</li><li id="e957" class="kw kx hu jl b jm lf jp lg js lh jw li ka lj ke mp lc ld le dt translated"><code class="eh ks kt ku kv b">updateProgress</code>带有UIViewController类型的数组。这可能看起来有点奇怪，但是这可以给我们一种基于导航栈中的所有视图控制器来更新进度的方法。下面我会告诉你为什么这是有用的。</li><li id="bfd4" class="kw kx hu jl b jm lf jp lg js lh jw li ka lj ke mp lc ld le dt translated"><code class="eh ks kt ku kv b">completeProgress</code>将进度条填满。</li></ol><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="e0ab" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里我们可以扩展<code class="eh ks kt ku kv b">ProgressViewUpdater</code>来计算实际进度。我们通过遍历我们的视图控制器并根据我们当前在堆栈中的位置计算出进度来做到这一点。</p><p id="effe" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们快到了！还有一件事，在我们的流程中，我们有了一个全功能的进度视图。</p><h1 id="3c0f" class="lk ll hu bd lm ln lo lp lq lr ls lt lu ja lv jb lw jd lx je ly jg lz jh ma mb dt translated">更多默认实现</h1><p id="f6ea" class="pw-post-body-paragraph jj jk hu jl b jm mc iv jo jp md iy jr js me ju jv jw mf jy jz ka mg kc kd ke hn dt translated">对于我们的视图控制器，我们可以非常简单地向导航控制器传递我们需要的信息。猜猜接下来会发生什么，更多的协议！</p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="281d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以遵循我们的<code class="eh ks kt ku kv b">ProgressViewUpdater</code>协议，并为这个流中的视图控制器提供一个更干净的接口。</p><p id="4fb3" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后，这使我们能够在这个函数的实现中，按照它们出现的顺序，编程定义导航栈中的每个视图控制器。</p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="4ecc" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">确保我们的视图控制器符合<code class="eh ks kt ku kv b">MainFormProgressViewUpdater</code>，我们可以简单地调用<code class="eh ks kt ku kv b">updateProgress()</code>来根据我们在流程中的位置更新进度视图。</p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="e630" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果您想在您的应用程序中有另一个具有类似功能的流，您需要做的就是创建另一个类似于<code class="eh ks kt ku kv b">MainFormProgressUpdater</code>的协议，并将其放入您的视图控制器中。</p><p id="4deb" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="mm">注意:一定要从</em> <code class="eh ks kt ku kv b"><em class="mm">viewDidAppear</em></code> <em class="mm">调用它才能看到动画。</em></p><h1 id="6f8f" class="lk ll hu bd lm ln lo lp lq lr ls lt lu ja lv jb lw jd lx je ly jg lz jh ma mb dt translated">包裹</h1><p id="7d04" class="pw-post-body-paragraph jj jk hu jl b jm mc iv jo jp md iy jr js me ju jv jw mf jy jz ka mg kc kd ke hn dt translated">我做这个很开心！一定要让我知道你的想法，或者你是否会有不同的做法。</p><p id="d9ef" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">请务必查看我以前的文章中类似的内容。</p><div class="kh ki kj kk fq ab cb"><figure class="mq kl mr ms mt mu mv paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mq kl mr ms mt mu mv paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mq kl mr ms mt mu mv paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mw mx my"><p id="f922" class="jj jk mm jl b jm jn iv jo jp jq iy jr mz jt ju jv na jx jy jz nb kb kc kd ke hn dt translated"><a class="ae kf" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kf" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kf" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae kf" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jj jk mm jl b jm jn iv jo jp jq iy jr mz jt ju jv na jx jy jz nb kb kc kd ke hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kf" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kf" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff nc"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="nd mo l"/></div></figure></div></div>    
</body>
</html>