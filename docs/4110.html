<html>
<head>
<title>Smarter JavaScript Timeouts (v2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更智能的JavaScript超时(v2)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/smarter-javascript-timeouts-24308f3be5ab?source=collection_archive---------0-----------------------#2017-05-13">https://medium.com/hackernoon/smarter-javascript-timeouts-24308f3be5ab?source=collection_archive---------0-----------------------#2017-05-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="7fcd" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">具有清除、挂起、执行和暂停状态的计时器</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/97f11cb41ab49eff6bd588d0478bfaf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lPYo-KL6xgUcZSnXvuTvIQ.jpeg"/></div></div></figure><h1 id="4e70" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">基元</h1><p id="c907" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">如果你曾经花时间编写过JavaScript，你可能会非常熟悉这种语言内置的一些最古老的功能，即<code class="eh lj lk ll lm b">setTimeout()</code>和<code class="eh lj lk ll lm b">clearTimeout()</code>。</p><p id="192e" class="pw-post-body-paragraph kn ko hu kp b kq ln iv ks kt lo iy kv kw lp ky kz la lq lc ld le lr lg lh li hn dt translated">如果您不太熟悉JS计时器，<code class="eh lj lk ll lm b">setTimeout()</code>允许您安排一个毫秒级的延迟，过了这个时间它将触发回调函数(或其他任意代码块，尽管出于本文的目的，我们将重点关注回调)的执行。它返回一个唯一的定时器标识符，允许您在超时被触发之前通过将它传递给<code class="eh lj lk ll lm b">clearTimeout()</code>来取消超时。</p><pre class="jk jl jm jn fq ls lm lt lu aw lv dt"><span id="38e4" class="lw jw hu lm b fv lx ly l lz ma">function greetWorld() {<br/>  alert('Hello, world!');<br/>}</span><span id="29d1" class="lw jw hu lm b fv mb ly l lz ma">var timerId = setTimeout(greetWorld, 2000);</span></pre><p id="068b" class="pw-post-body-paragraph kn ko hu kp b kq ln iv ks kt lo iy kv kw lp ky kz la lq lc ld le lr lg lh li hn dt translated">这是一个尽可能简单的例子。在执行<code class="eh lj lk ll lm b">setTimeout()</code>语句两秒钟后，运行<code class="eh lj lk ll lm b">greetWorld()</code>回调。</p><p id="2df6" class="pw-post-body-paragraph kn ko hu kp b kq ln iv ks kt lo iy kv kw lp ky kz la lq lc ld le lr lg lh li hn dt translated">在这两秒钟过去之前，您可以通过拨打<code class="eh lj lk ll lm b">clearTimeout(timerId)</code>取消未决呼叫。除了设置和清除超时，没有提供其他有用的功能。</p><h1 id="ab7a" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">限制</h1><p id="2f32" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">当您为简单的需求编码时，内置的功能可能就足够了，但是它的局限性还有待改进。具体来说，有些无法回答的问题你可能需要回答:</p><ol class=""><li id="d361" class="md me hu kp b kq ln kt lo kw mf la mg le mh li mi mj mk ml dt translated">我的回拨超时了吗？</li><li id="8ba7" class="md me hu kp b kq mm kt mn kw mo la mp le mq li mi mj mk ml dt translated">我的超时回调的执行是否仍处于挂起状态？</li><li id="5482" class="md me hu kp b kq mm kt mn kw mo la mp le mq li mi mj mk ml dt translated">我的超时回调被执行了吗？</li></ol><p id="8af0" class="pw-post-body-paragraph kn ko hu kp b kq ln iv ks kt lo iy kv kw lp ky kz la lq lc ld le lr lg lh li hn dt translated">通常，如果开发人员需要在他们的项目中回答这些问题，他们可以编写一些特定于任务的实用逻辑来帮助实现这一目标。我的方法是创建一个通用的解决方案，提供这里列举的缺失功能，而不妨碍或复杂化内置原语提供的易用性和特性。</p><h1 id="0a74" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">Timeout.js</h1><div class="mr ms fm fo mt mu"><a href="https://github.com/rommelsantor/Timeout" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab ej"><div class="mw ab mx cl cj my"><h2 class="bd hv fv z el mz eo ep na er et ht dt translated">Rommel santor/超时</h2><div class="nb l"><h3 class="bd b fv z el mz eo ep na er et ek translated">超时-交互式、有状态JS (ES6)超时接口</h3></div><div class="nc l"><p class="bd b gc z el mz eo ep na er et ek translated">github.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni jt mu"/></div></div></a></div><p id="d565" class="pw-post-body-paragraph kn ko hu kp b kq ln iv ks kt lo iy kv kw lp ky kz la lq lc ld le lr lg lh li hn dt translated"><code class="eh lj lk ll lm b">npm install smart-timeout</code></p><p id="a7a4" class="pw-post-body-paragraph kn ko hu kp b kq ln iv ks kt lo iy kv kw lp ky kz la lq lc ld le lr lg lh li hn dt translated"><code class="eh lj lk ll lm b">Timeout</code>对象是一个交互式的、有状态的接口，旨在实现上述目标。使用显示模块模式，它公开了以下功能:</p><ul class=""><li id="8ce5" class="md me hu kp b kq ln kt lo kw mf la mg le mh li nj mj mk ml dt translated"><code class="eh lj lk ll lm b">Timeout.set(callback, delay = 0, param1, param2, ...)</code> <br/> <code class="eh lj lk ll lm b">Timeout.set(customId, callback, delay = 0, param1, param2, ...)</code></li><li id="d57a" class="md me hu kp b kq mm kt mn kw mo la mp le mq li nj mj mk ml dt translated"><code class="eh lj lk ll lm b">Timeout.clear(key, delete = true)</code></li><li id="ec8f" class="md me hu kp b kq mm kt mn kw mo la mp le mq li nj mj mk ml dt translated"><code class="eh lj lk ll lm b">Timeout.exists(key)</code></li><li id="6ac1" class="md me hu kp b kq mm kt mn kw mo la mp le mq li nj mj mk ml dt translated"><code class="eh lj lk ll lm b">Timeout.pending(key)</code></li><li id="6f6b" class="md me hu kp b kq mm kt mn kw mo la mp le mq li nj mj mk ml dt translated"><code class="eh lj lk ll lm b">Timeout.remaining(key)</code></li><li id="ef99" class="md me hu kp b kq mm kt mn kw mo la mp le mq li nj mj mk ml dt translated"><code class="eh lj lk ll lm b">Timeout.executed(key)</code></li><li id="b51b" class="md me hu kp b kq mm kt mn kw mo la mp le mq li nj mj mk ml dt translated"><code class="eh lj lk ll lm b">Timeout.pause(key)</code></li><li id="1e54" class="md me hu kp b kq mm kt mn kw mo la mp le mq li nj mj mk ml dt translated"><code class="eh lj lk ll lm b">Timeout.paused(key)</code></li><li id="46e4" class="md me hu kp b kq mm kt mn kw mo la mp le mq li nj mj mk ml dt translated"><code class="eh lj lk ll lm b">Timeout.resume(key)</code></li><li id="85b0" class="md me hu kp b kq mm kt mn kw mo la mp le mq li nj mj mk ml dt translated"><code class="eh lj lk ll lm b">Timeout.restart(key)</code></li></ul><p id="019b" class="pw-post-body-paragraph kn ko hu kp b kq ln iv ks kt lo iy kv kw lp ky kz la lq lc ld le lr lg lh li hn dt translated">设置新超时时，您可以选择定义一个自定义字符串标识符(<code class="eh lj lk ll lm b">customId</code>)来唯一标识它。如果省略这个参数，那么<code class="eh lj lk ll lm b">callback</code>本身将作为超时的唯一标识符。在每个被描述为接受<code class="eh lj lk ll lm b">key</code>作为其参数的函数中，<code class="eh lj lk ll lm b">key</code>代表<code class="eh lj lk ll lm b">customId</code>或<code class="eh lj lk ll lm b">callback</code>，无论哪个在对<code class="eh lj lk ll lm b">Timeout.set()</code>的相应调用中被使用。</p><p id="7869" class="pw-post-body-paragraph kn ko hu kp b kq ln iv ks kt lo iy kv kw lp ky kz la lq lc ld le lr lg lh li hn dt translated"><code class="eh lj lk ll lm b">Timeout.set()</code>返回一个函数，该函数在执行时返回一个布尔值，表明延迟时间是否已过以及回调是否已被触发。相当于调用<code class="eh lj lk ll lm b">Timeout.executed()</code>。如果相同的标识符在对<code class="eh lj lk ll lm b">Timeout.set()</code>的调用中重复出现，前者将在后者被添加之前被清除。(如果您有意为同一个回调设置多个并发超时，只需为每个设置一个不同的<code class="eh lj lk ll lm b">customId</code>。)</p><p id="80dc" class="pw-post-body-paragraph kn ko hu kp b kq ln iv ks kt lo iy kv kw lp ky kz la lq lc ld le lr lg lh li hn dt translated"><code class="eh lj lk ll lm b">Timeout.clear()</code>将简单地清除与指定的<code class="eh lj lk ll lm b">key</code>相关的超时(如果有这样的超时)并清除任何超时曾经存在的证据。它不返回值。</p><p id="1e26" class="pw-post-body-paragraph kn ko hu kp b kq ln iv ks kt lo iy kv kw lp ky kz la lq lc ld le lr lg lh li hn dt translated">无论其<code class="eh lj lk ll lm b">delay</code>是否已经过去，如果已经为指定的<code class="eh lj lk ll lm b">key</code>设置了超时并且没有清除，则<code class="eh lj lk ll lm b">Timeout.exists()</code>返回true。</p><p id="82c2" class="pw-post-body-paragraph kn ko hu kp b kq ln iv ks kt lo iy kv kw lp ky kz la lq lc ld le lr lg lh li hn dt translated">如果指定的<code class="eh lj lk ll lm b">key</code>超时，且其<code class="eh lj lk ll lm b">delay</code>尚未结束(即其<code class="eh lj lk ll lm b">callback</code>尚未被触发)，则<code class="eh lj lk ll lm b">Timeout.pending()</code>返回true。</p><p id="a3cc" class="pw-post-body-paragraph kn ko hu kp b kq ln iv ks kt lo iy kv kw lp ky kz la lq lc ld le lr lg lh li hn dt translated"><code class="eh lj lk ll lm b">Timeout.remaining()</code>【在v2中增加】返回执行前倒计时剩余的毫秒数。</p><p id="f0f9" class="pw-post-body-paragraph kn ko hu kp b kq ln iv ks kt lo iy kv kw lp ky kz la lq lc ld le lr lg lh li hn dt translated">如果指定的<code class="eh lj lk ll lm b">key</code>超时且其<code class="eh lj lk ll lm b">delay</code>已过(即其<code class="eh lj lk ll lm b">callback</code>已被触发)，则<code class="eh lj lk ll lm b">Timeout.executed()</code>返回true。</p><p id="b4a1" class="pw-post-body-paragraph kn ko hu kp b kq ln iv ks kt lo iy kv kw lp ky kz la lq lc ld le lr lg lh li hn dt translated"><code class="eh lj lk ll lm b">Timeout.pause()</code>【在v2中增加】允许您暂停尚未执行的计时器的倒计时。</p><p id="acb9" class="pw-post-body-paragraph kn ko hu kp b kq ln iv ks kt lo iy kv kw lp ky kz la lq lc ld le lr lg lh li hn dt translated"><code class="eh lj lk ll lm b">Timeout.paused()</code>[在v2中添加]如果挂起的超时当前暂停，则返回true。</p><p id="bda0" class="pw-post-body-paragraph kn ko hu kp b kq ln iv ks kt lo iy kv kw lp ky kz la lq lc ld le lr lg lh li hn dt translated"><code class="eh lj lk ll lm b">Timeout.resume()</code>【在v2中增加】允许您恢复暂停计时器的倒计时。</p><p id="5867" class="pw-post-body-paragraph kn ko hu kp b kq ln iv ks kt lo iy kv kw lp ky kz la lq lc ld le lr lg lh li hn dt translated"><code class="eh lj lk ll lm b">Timeout.restart()</code>【在v2中增加】允许您用原来的<code class="eh lj lk ll lm b">delay</code>时间重新开始等待或暂停的计时器的倒计时。</p><h2 id="6997" class="lw jw hu bd jx nk nl nm kb nn no np kf kw nq nr kh la ns nt kj le nu nv kl nw dt translated">基本功能</h2><p id="e2ae" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">考虑到前面提供的非常简单的回调示例，这里演示了最基本的功能。(注意，本文中剩余的代码示例将使用ES6。)</p><pre class="jk jl jm jn fq ls lm lt lu aw lv dt"><span id="baaa" class="lw jw hu lm b fv lx ly l lz ma">const didGreet = Timeout.set(greetWorld, 2000)</span><span id="40a6" class="lw jw hu lm b fv mb ly l lz ma">if (Timeout.exists(greetWorld)) {// true<br/>  console.log('greeting has been scheduled')<br/>}</span><span id="b632" class="lw jw hu lm b fv mb ly l lz ma">if (Timeout.pending(greetWorld)) {// true<br/>  console.log('greeting is waiting to be issued')<br/>}</span><span id="8416" class="lw jw hu lm b fv mb ly l lz ma">// ...wait for 2 seconds to elapse...</span><span id="29fa" class="lw jw hu lm b fv mb ly l lz ma">if (didGreet()) {// true<br/>  console.log('the greeting was issued')<br/>}</span><span id="e196" class="lw jw hu lm b fv mb ly l lz ma">// ^that is identical to calling this:<br/>if (Timeout.executed(greetWorld)) {// true<br/>  console.log('as I said, the greeting was issued')<br/>}</span><span id="127c" class="lw jw hu lm b fv mb ly l lz ma">Timeout.pending(greetWorld) // false - it ran</span><span id="dbf0" class="lw jw hu lm b fv mb ly l lz ma">Timeout.exists(greetWorld) // true - it still exists</span><span id="c152" class="lw jw hu lm b fv mb ly l lz ma">Timeout.clear(greetWorld)</span><span id="e7b1" class="lw jw hu lm b fv mb ly l lz ma">Timeout.exists(greetWorld) // false - it has been cleared</span></pre><p id="1f93" class="pw-post-body-paragraph kn ko hu kp b kq ln iv ks kt lo iy kv kw lp ky kz la lq lc ld le lr lg lh li hn dt translated">除了使用回调作为唯一键，您还可以指定一个自定义标识符:</p><pre class="jk jl jm jn fq ls lm lt lu aw lv dt"><span id="3496" class="lw jw hu lm b fv lx ly l lz ma">const didGreet = Timeout.set('myGreeting', greetWorld, 2000)</span><span id="af6a" class="lw jw hu lm b fv mb ly l lz ma">if (Timeout.exists('myGreeting')) {// true<br/>  console.log('greeting has been scheduled')<br/>}</span><span id="1f8b" class="lw jw hu lm b fv mb ly l lz ma">// etc.</span></pre><h2 id="d4b6" class="lw jw hu bd jx nk nl nm kb nn no np kf kw nq nr kh la ns nt kj le nu nv kl nw dt translated">看看它的实际效果</h2><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nx ny l"/></div></figure><h2 id="cb0c" class="lw jw hu bd jx nk nl nm kb nn no np kf kw nq nr kh la ns nt kj le nu nv kl nw dt translated">节流示例</h2><p id="a6b7" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">基本用法本身是有帮助的，但是让我们考虑一个更复杂的用例:抑制过多的窗口事件。在这种情况下，我们将不会使用延迟来触发超时回调，而只是作为时间跟踪器来测试指定的延迟是否已经过去。</p><p id="ae09" class="pw-post-body-paragraph kn ko hu kp b kq ln iv ks kt lo iy kv kw lp ky kz la lq lc ld le lr lg lh li hn dt translated">假设我们的需求规定，每当窗口从页面顶部向下滚动任意距离时，我们都要将类<code class="eh lj lk ll lm b">is-scrolled</code>添加到<code class="eh lj lk ll lm b">&lt;html&gt;</code>元素中。问题是当窗口滚动时，大量的<code class="eh lj lk ll lm b">scroll</code>事件被触发，我们不想因为对每个事件都做出反应而使页面陷入困境。这可以通过lodash等外部库的throttle函数来实现，但是对于这个例子，我们将使用<code class="eh lj lk ll lm b">Timeout</code>来限制<code class="eh lj lk ll lm b">onScroll</code>回调，这样它就可以定期执行。</p><pre class="jk jl jm jn fq ls lm lt lu aw lv dt"><span id="bec8" class="lw jw hu lm b fv lx ly l lz ma">const throttle =<br/>  (delay, callback) =&gt;<br/>    (...args) =&gt;<br/>      !Timeout.pending(callback) &amp;&amp;<br/>      Timeout.set(callback, () =&gt; {}, delay)<br/>        ? callback.apply(this, args)<br/>        : null</span><span id="838b" class="lw jw hu lm b fv mb ly l lz ma">const onScroll = () =&gt; {<br/>  const isScrolled = $(window).scrollTop() &gt; 0<br/>  $('html').toggleClass('is-scrolled', isScrolled)<br/>}</span><span id="1a8c" class="lw jw hu lm b fv mb ly l lz ma">const onScrollThrottled = throttle(100, onScroll)<br/>$(window).scroll(onScrollThrottled)</span></pre><p id="ce71" class="pw-post-body-paragraph kn ko hu kp b kq ln iv ks kt lo iy kv kw lp ky kz la lq lc ld le lr lg lh li hn dt translated"><code class="eh lj lk ll lm b">throttle()</code>函数接受以毫秒为单位的延迟和回调作为其两个参数，如果<em class="mc">自上次执行以来至少经过了</em>延迟，则执行回调。它返回一个适合用作事件回调的函数。</p><p id="d9e5" class="pw-post-body-paragraph kn ko hu kp b kq ln iv ks kt lo iy kv kw lp ky kz la lq lc ld le lr lg lh li hn dt translated">这显然是对<code class="eh lj lk ll lm b">Timeout</code>对象的一个非常具体(尽管有点复杂)的使用，但是它展示了它通过简洁、清晰的操作所提供的灵活性，这是单独使用<code class="eh lj lk ll lm b">setTimeout()</code>和<code class="eh lj lk ll lm b">clearTimeout()</code>所不可能的。</p><h1 id="5b31" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">结论</h1><p id="471b" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">可能还有其他库提供类似的功能，但是，如果是这样，它们一定隐藏得很好，因为我还没有找到它们，这就是我决定写这篇文章的原因。我希望它对你有用，就像我希望的那样！</p><div class="jk jl jm jn fq ab cb"><figure class="nz jo oa ob oc od oe paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nz jo oa ob oc od oe paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nz jo oa ob oc od oe paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="of og oh"><p id="f922" class="kn ko mc kp b kq ln iv ks kt lo iy kv oi lp ky kz oj lq lc ld ok lr lg lh li hn dt translated"><a class="ae ol" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ol" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ol" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae ol" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="kn ko mc kp b kq ln iv ks kt lo iy kv oi lp ky kz oj lq lc ld ok lr lg lh li hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ol" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ol" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff om"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>