<html>
<head>
<title>If not Redux then what?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如果不是Redux那是什么？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/if-not-redux-then-what-fc433234f5b4?source=collection_archive---------0-----------------------#2016-09-23">https://medium.com/hackernoon/if-not-redux-then-what-fc433234f5b4?source=collection_archive---------0-----------------------#2016-09-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="2112" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Redux的创始人丹·阿布拉莫夫(Dan abra mov)最近发表了一篇文章《<a class="ae jr" rel="noopener" href="/@dan_abramov/you-might-not-need-redux-be46360cf367#.zehy2d7a9"> <strong class="it hv">你可能不需要Redux </strong> </a>》，他在文章中指出，开发者在构建React应用程序时选择Redux作为事实，甚至没有考虑他们是否真的需要它。</p><p id="c48c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Redux不应该受到指责。像任何其他库一样，它提供了一些折衷，比如通过接触三个文件来完成简单的任务，将状态和动作描述为简单的对象和数组，以及通过纯函数来处理逻辑。这些约束使得调试更容易，测试性更好，保证用户界面的状态是可预测的，以及更多现成的东西。</p><blockquote class="js"><p id="4e8c" class="jt ju hu bd jv jw jx jy jz ka kb jo ek translated">但是，写这么多做这么少带来了一些烦恼，并减缓了整体发展。</p></blockquote><h1 id="e3b0" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">我们真的需要一个状态管理库吗？</h1><p id="e3ea" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">难道我们不能将普通的ES6类定义为模型，并将它们的实例存储在一个数组集合中，而不使用库吗？是的，我们可以！但是，问题不在于数据存储或检索。</p><p id="a534" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">真正的问题是我们如何检测数据突变并处理它的副作用。数据突变的副作用包括以下行为</p><ul class=""><li id="a065" class="lf lg hu it b iu iv iy iz jc lh jg li jk lj jo lk ll lm ln dt translated">将用户界面与数据变化同步</li><li id="e5cf" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">重新计算已计算的变量</li><li id="ee48" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">导航到不同的路线</li></ul><p id="3a1c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们使用赋值操作符(如user.name = "John Doe ")改变数据，我们就没有机制来检测这种变化(<a class="ae jr" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/observe" rel="noopener ugc nofollow" target="_blank"> Object.observe() </a>已被否决)。</p><p id="c696" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这正是我们需要状态管理库的地方。</p><blockquote class="js"><p id="45b1" class="jt ju hu bd jv jw jx jy jz ka kb jo ek translated">Redux通过称为reducers的纯函数强制数据突变来检测这种变化。</p></blockquote><h1 id="a7cc" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">其他框架如何解决？</h1><ul class=""><li id="9a0b" class="lf lg hu it b iu la iy lb jc lt jg lu jk lv jo lk ll lm ln dt translated"><strong class="it hv">脏检查:</strong> <a class="ae jr" href="https://angularjs.org/" rel="noopener ugc nofollow" target="_blank"> Angular 1.x </a>使用了<a class="ae jr" href="https://docs.angularjs.org/guide/scope" rel="noopener ugc nofollow" target="_blank">脏检查机制</a>，在连续的周期中对新旧数据树进行深度比较。一开始这很诱人，但是会在大规模中扼杀性能。</li><li id="3934" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><strong class="it hv">反应式编程:</strong> <a class="ae jr" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular 2 </a>和<a class="ae jr" href="https://www.meteor.com/" rel="noopener ugc nofollow" target="_blank"> Meteor </a>使用反应式编程的概念，使得数据传播和变化检测易于理解和扩展。</li><li id="9e91" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><strong class="it hv">观察者模式:</strong>与反应式编程概念类似，观察者模式在数据突变时触发事件。<a class="ae jr" href="http://knockoutjs.com/" rel="noopener ugc nofollow" target="_blank"> Knockout.js </a>和<a class="ae jr" href="https://mobxjs.github.io/mobx/" rel="noopener ugc nofollow" target="_blank"> MobX </a>使用观察者模式。</li><li id="fe0f" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><strong class="it hv"> Setter和Getter: </strong>古老的Setter和Getter方法解决了多年来被<a class="ae jr" href="http://emberjs.com/" rel="noopener ugc nofollow" target="_blank">成员</a>和<a class="ae jr" href="http://backbonejs.org/" rel="noopener ugc nofollow" target="_blank">骨干</a>使用的变更检测问题。</li></ul><h1 id="5745" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn lw kp kq kr lx kt ku kv ly kx ky kz dt translated">Redux的替代品有哪些？</h1><h2 id="b3fb" class="lz kd hu bd ke ma mb mc ki md me mf km jc mg mh kq jg mi mj ku jk mk ml ky mm dt translated">this.setState()</h2><p id="aa84" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">React自带组件级的变更检测方法。如果您是React新手，就坚持使用this.setState()方法。它适用于小型应用程序。例如:<a class="ae jr" href="https://gist.github.com/caike/736d45e44fa5c7595adb" rel="noopener ugc nofollow" target="_blank">简单的待办事项应用</a></p><h2 id="14ed" class="lz kd hu bd ke ma mb mc ki md me mf km jc mg mh kq jg mi mj ku jk mk ml ky mm dt translated">使用React的反应模式和观察者模式</h2><ul class=""><li id="f19d" class="lf lg hu it b iu la iy lb jc lt jg lu jk lv jo lk ll lm ln dt translated"><a class="ae jr" href="https://mobxjs.github.io/mobx/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> MobX </strong> </a> <strong class="it hv">(又名mobservable </strong> ) <strong class="it hv"> : </strong>它的占地面积非常小。如果你习惯使用面向对象的模式，这一个是给你的。使用ES6/7装饰器，你几乎感觉不到你在使用任何库。</li><li id="af72" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><a class="ae jr" href="https://github.com/Reactive-Extensions/RxJS" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">RxJS</strong></a><strong class="it hv">:</strong>“JavaScript的<strong class="it hv"> </strong>反应式扩展”。RxJS本身就是野兽。简单来说，RxJS =可观测量+算子+调度器。尽管它作为一个独立的库而闻名，但它为React 提供了一些简洁的<a class="ae jr" href="https://github.com/fdecampredon/rx-react" rel="noopener ugc nofollow" target="_blank">绑定。</a></li></ul><h2 id="a95a" class="lz kd hu bd ke ma mb mc ki md me mf km jc mg mh kq jg mi mj ku jk mk ml ky mm dt translated">其他Flux实现</h2><ul class=""><li id="dc0d" class="lf lg hu it b iu la iy lb jc lt jg lu jk lv jo lk ll lm ln dt translated"><a class="ae jr" href="http://alt.js.org/" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">Alt</strong></a><strong class="it hv">:</strong>同构的flux实现哪个干净易懂。您需要像其他flux实现一样将监听器连接到组件。</li><li id="42fb" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><a class="ae jr" href="https://github.com/reflux/refluxjs" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">回流</strong></a><strong class="it hv">:</strong>Flux架构的早期实现之一，有一定的局限性，大部分使用回流的开发者已经<a class="ae jr" href="https://www.quora.com/Is-it-wise-to-invest-into-RefluxJS-with-Facebooks-React" rel="noopener ugc nofollow" target="_blank">迁移到Redux或者其他库</a>。</li><li id="62fe" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><a class="ae jr" href="https://facebook.github.io/relay/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">中继</strong></a>T4:脸书搭建的官方框架，在后端使用React和GraphQL协议。<a class="ae jr" href="https://github.com/reactjs/redux/issues/464" rel="noopener ugc nofollow" target="_blank"> Relay的Container components与使用connect()方法创建的Redux </a>的Container components直接比较。</li></ul></div><div class="ab cl mn mo hc mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hn ho hp hq hr"><h1 id="8ba6" class="kc kd hu bd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv my kx ky kz dt translated">我的个人选择:<a class="ae jr" href="https://mobxjs.github.io/mobx/" rel="noopener ugc nofollow" target="_blank"> MobX </a></h1><p id="5aff" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated"><em class="mz">【2017年10月24日更新】我已经开始使用</em> <a class="ae jr" href="https://github.com/mobxjs/mobx-state-tree" rel="noopener ugc nofollow" target="_blank"> <em class="mz"> mobx状态树</em> </a> <em class="mz">，这是一个状态容器，使用mobx。</em></p><h2 id="bf8b" class="lz kd hu bd ke ma mb mc ki md me mf km jc mg mh kq jg mi mj ku jk mk ml ky mm dt translated">为什么是MobX？</h2><ul class=""><li id="7cd8" class="lf lg hu it b iu la iy lb jc lt jg lu jk lv jo lk ll lm ln dt translated">MobX最大的优点是<strong class="it hv">省去了为数据更改添加监听程序的麻烦</strong>，它透明地将反应式编程概念(TFRP)应用到数据模型中，并在需要时更新UI的一部分。</li><li id="16d3" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><strong class="it hv">面向对象概念为赢</strong>:你可以使用好的旧的面向对象概念，并应用到你的应用程序中的数据模型。</li><li id="9f8f" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><strong class="it hv">易于文档化和交流</strong>作为技术负责人，MobX让我的工作变得非常易于文档化所有类和存储，以及需要构建的属性和方法。</li><li id="b5f4" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><strong class="it hv">快速开发:</strong>相比其他库，你可以专注于应用程序的业务逻辑并以更快的速度交付产品。</li><li id="1574" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><strong class="it hv">有反应时增加生命周期挂钩:</strong>T28】mobx-reaction增加名为<strong class="it hv">component will reaction()的生命周期挂钩</strong>进行反应性更新。此挂钩可用于路由器和导航器。</li></ul><h2 id="a923" class="lz kd hu bd ke ma mb mc ki md me mf km jc mg mh kq jg mi mj ku jk mk ml ky mm dt translated">权衡？</h2><p id="478f" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">如果你选择一个库而不是另一个库，你会得到一些东西，也会失去一些东西。以下是MobX提供的一些权衡:</p><ul class=""><li id="a323" class="lf lg hu it b iu iv iy iz jc lh jg li jk lj jo lk ll lm ln dt translated">由于我们使用类和派生对象而不是普通的JavaScript对象，因此数据不能立即序列化。您需要为每个类编写自己的toJS()和fromJS()方法</li><li id="c37b" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">每次当数据离开执行环境时，都需要对数据进行序列化，例如在进行API调用、将其存储在LocalStorage中、从其他数据源填充后端中的存储等时。</li><li id="c39d" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">与Redux不同，撤销/重做和数据更改的时间旅行等功能需要手动构建。</li></ul><h1 id="0ccf" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn lw kp kq kr lx kt ku kv ly kx ky kz dt translated">底线</h1><p id="6b82" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">您必须使用React的特定状态管理库，这并不是一成不变的。这是你和你的团队对范式的个人选择。社区有时会误导人。所以，在你包含一个库之前，要再三考虑库提供的约束和权衡。</p></div><div class="ab cl mn mo hc mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hn ho hp hq hr"><p id="5828" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我错过什么了吗？如有任何更正、意见和讨论，请随时回复文章。</p><p id="4071" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你喜欢这篇文章，考虑推荐它。我是<a class="ae jr" href="http://geekyants.com/sanket" rel="noopener ugc nofollow" target="_blank"> Sanket </a>，我们正在<a class="ae jr" href="http://GeekyAnts.com" rel="noopener ugc nofollow" target="_blank"> GeekyAnts </a>建立<a class="ae jr" href="http://NativeBase.io" rel="noopener ugc nofollow" target="_blank"> NativeBase.io </a>。</p><blockquote class="na nb nc"><p id="4cd6" class="ir is mz it b iu iv iw ix iy iz ja jb nd jd je jf ne jh ji jj nf jl jm jn jo hn dt translated"><a class="ae jr" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jr" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jr" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jr" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is mz it b iu iv iw ix iy iz ja jb nd jd je jf ne jh ji jj nf jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae jr" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae jr" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上给我们点赞/发消息</a>，或者简单地说，<a class="ae jr" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is mz it b iu iv iw ix iy iz ja jb nd jd je jf ne jh ji jj nf jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jr" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jr" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>