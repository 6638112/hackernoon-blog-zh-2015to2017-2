<html>
<head>
<title>Performing custom validations in Rails — an example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Rails中执行定制验证——一个例子</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/performing-custom-validations-in-rails-an-example-9a373e807144?source=collection_archive---------1-----------------------#2017-01-27">https://medium.com/hackernoon/performing-custom-validations-in-rails-an-example-9a373e807144?source=collection_archive---------1-----------------------#2017-01-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="9674" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://hackernoon.com/tagged/rails" rel="noopener ugc nofollow" target="_blank"> Rails </a>提供了各种开箱即用的助手，用于快速<a class="ae jp" href="https://hackernoon.com/tagged/performing" rel="noopener ugc nofollow" target="_blank">执行</a>常用的验证——存在性、数值性、惟一性等。如果模型有超出标准助手的验证，我们必须实现一个定制的验证策略。我将展示进行验证的三种方法，并讨论其优缺点。</p><p id="c31c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，我们有一个Shipments表，其中每个记录代表一个带有属性<code class="eh jq jr js jt b">width</code>、<code class="eh jq jr js jt b">height</code>、<code class="eh jq jr js jt b">depth</code>和<code class="eh jq jr js jt b">weight</code>的包裹。</p><p id="9b5d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每次装运必须遵守以下规则:</p><ul class=""><li id="f273" class="ju jv hu it b iu iv iy iz jc jw jg jx jk jy jo jz ka kb kc dt translated">装运的体积必须在20到4000立方厘米之间(即体积验证)</li><li id="8b4a" class="ju jv hu it b iu kd iy ke jc kf jg kg jk kh jo jz ka kb kc dt translated">货物的密度不能超过每立方厘米200克(即密度验证)</li><li id="d043" class="ju jv hu it b iu kd iy ke jc kf jg kg jk kh jo jz ka kb kc dt translated">任何边的长度都不能小于最大边的10%(即比例验证)</li></ul><p id="3a59" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于每一种情况，我们将使用不同的验证实现。为了使验证更具可读性，我们在装运模型中实现了#volume和#density(查看<a class="ae jp" href="https://github.com/rfleury2/custom-validation-blog/tree/master/MyApp" rel="noopener ugc nofollow" target="_blank">源代码</a>)。</p><p id="37aa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，让我们通过在shipment类中创建一个自定义方法来验证装运量。我们可以使用<code class="eh jq jr js jt b">#validate</code>在验证过程中调用一个自定义方法。然后，在自定义方法中，向<code class="eh jq jr js jt b">#errors</code>对象添加新的错误(<a class="ae jp" rel="noopener" href="/@rfleury2/a-quick-guide-to-model-errors-in-rails-965e2be3ac93#.jycr0mkrl">应该有自己的简短帖子</a>)</p><pre class="ki kj kk kl fq km jt kn ko aw kp dt"><span id="278e" class="kq kr hu jt b fv ks kt l ku kv">class Shipment &lt; ActiveRecord::Base<br/>  …<br/>  validate :volume_limits<br/>  …</span><span id="6a76" class="kq kr hu jt b fv kw kt l ku kv">  private</span><span id="1618" class="kq kr hu jt b fv kw kt l ku kv">  def volume_limits<br/>    if volume &gt; 4000<br/>      errors.add(:volume, “cannot be above 400 cubic inches”)<br/>    elsif volume &lt; 20<br/>      errors.add(:volume, “cannot be below 20 cubic inches”)<br/>    end<br/>  end<br/>end</span></pre><p id="a70c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在模型中执行验证工作得很好，但是它也给模型增加了更多的逻辑。在可能的情况下，我更喜欢将该逻辑提取到它自己的助手类中。这是因为它很好地将每个验证的逻辑封装到自己的对象中，使得将来的调试和/或扩展更加容易。</p><p id="9e81" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们通过创建一个助手验证器类来验证密度。<code class="eh jq jr js jt b">#validates_with</code>方法将验证指向一个助手类:</p><pre class="ki kj kk kl fq km jt kn ko aw kp dt"><span id="b3de" class="kq kr hu jt b fv ks kt l ku kv">class Shipment &lt; ActiveRecord::Base<br/>  …<br/>  validates_with DensityValidator<br/>  …<br/>end</span></pre><p id="84e7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，在/models/concerns目录中，创建“density_validator.rb”。<code class="eh jq jr js jt b">DensityValidator</code>继承自<code class="eh jq jr js jt b">ActiveModel::Validator</code>，其约定有一个方法叫做<code class="eh jq jr js jt b">#validate</code>。该方法可以访问整个记录并实现验证逻辑，如果需要，还可以分配错误:</p><pre class="ki kj kk kl fq km jt kn ko aw kp dt"><span id="746d" class="kq kr hu jt b fv ks kt l ku kv">class DensityValidator &lt; ActiveModel::Validator<br/>  def validate(record)<br/>    if record.density &gt; 20<br/>      record.errors.add(:density, “is too high to safely ship”)<br/>    end<br/>  end<br/>end</span></pre><p id="b75c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后一个验证是确保包的形状不奇怪。如果一个包的任何一条边的长度短于最长边的10%,则称该包为奇形怪状。</p><p id="1055" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于上面的两个例子，我们都是在整体上验证货物的属性—任何包裹都只有一个体积和一个密度。对于包装的形状，每一面都必须单独验证。</p><p id="7eaf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用#validates，我们列出了所有需要验证的属性，后面跟着<code class="eh jq jr js jt b">package_proportion: true</code>:</p><pre class="ki kj kk kl fq km jt kn ko aw kp dt"><span id="d336" class="kq kr hu jt b fv ks kt l ku kv">class Shipment &lt; ActiveRecord::Base<br/>  ...<br/>  validates :height, :width, :depth, package_proportion: true<br/>  ...<br/>end</span></pre><p id="3811" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">package_proportion标志意味着我们期望有一个名为PackageProportionValidator的验证帮助器类。在/models/concerns目录下，创建“package _ proportion _ validator . Rb”。</p><pre class="ki kj kk kl fq km jt kn ko aw kp dt"><span id="945e" class="kq kr hu jt b fv ks kt l ku kv">class PackageProportionValidator &lt; ActiveModel::EachValidator<br/>  def validate_each(record, attribute, value)<br/>    if value &lt; [record.width, record.height, record.depth].max * 0.1<br/>      record.errors.add(attribute, "cannot be so short as to make                                                 <br/>      the package oddly sized :(")<br/>    end<br/>  end<br/>end</span></pre><p id="a696" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">属性验证助手类期望一个<code class="eh jq jr js jt b">#validates_each</code>方法来促进验证。它提供了对当前被验证的单个属性和作为单独变量的整个记录的访问，这很有帮助。</p><p id="cff4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们用一个形状奇怪、太大、太重的包来完成所有这些验证。</p><figure class="ki kj kk kl fq ky fe ff paragraph-image"><div class="fe ff kx"><img src="../Images/dd5ebd2f9e04ca8136a65bec66ef98e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/1*Uq2nJj_VNfYB9ZoLa5vvCA.gif"/></div></figure><p id="e0d4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是在Rails中实现验证的三种不同方式。哪一个是最好的取决于应用目标和验证用例。我通常尝试将逻辑封装到一个单独的类中，以使验证逻辑远离模型。当验证发生在属性级别时(比例示例)，我使用validates_each策略分别访问属性。当验证发生在对象级别时，我为整个对象使用一个定制的验证器(密度示例)。</p></div><div class="ab cl lb lc hc ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hn ho hp hq hr"><p id="d90c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">感谢您的阅读。我是写代码的新手，所以我会感谢任何有助于成为更好的作者和沟通者的反馈。也开放给未来的话题！</p><div class="ki kj kk kl fq ab cb"><figure class="li ky lj lk ll lm ln paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="li ky lj lk ll lm ln paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="li ky lj lk ll lm ln paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="lo lp lq"><p id="f922" class="ir is lr it b iu iv iw ix iy iz ja jb ls jd je jf lt jh ji jj lu jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is lr it b iu iv iw ix iy iz ja jb ls jd je jf lt jh ji jj lu jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ki kj kk kl fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="fe ff lv"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>