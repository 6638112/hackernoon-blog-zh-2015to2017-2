<html>
<head>
<title>Free Node.js Builds on Google Cloud Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">免费的Node.js建立在谷歌云功能之上</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/free-node-js-builds-on-google-cloud-functions-6e305623e249?source=collection_archive---------12-----------------------#2017-04-04">https://medium.com/hackernoon/free-node-js-builds-on-google-cloud-functions-6e305623e249?source=collection_archive---------12-----------------------#2017-04-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="c255" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">tldr: <a class="ae jp" href="https://github.com/jchorl/buildserverless" rel="noopener ugc nofollow" target="_blank">源代码和部署指令</a></p><h1 id="866f" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated"><strong class="ak">动机</strong></h1><p id="3672" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">如果你在软件公司工作过，你可能对构建服务器很熟悉。<a class="ae jp" href="http://stackoverflow.com/a/1099312" rel="noopener ugc nofollow" target="_blank">使用它们有很多理由。</a>当代码被构建并合并到产品中时，通常是在一个标准化的环境中，在称为构建服务器的专用服务器上完成的(想想像Jenkins、CircleCI等工具)。</p><p id="c4ce" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最近，<a class="ae jp" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>和<a class="ae jp" href="https://cloud.google.com/functions/" rel="noopener ugc nofollow" target="_blank"> Google Cloud Functions </a>越来越受欢迎，因为它们允许开发人员更多地考虑代码，更少地考虑服务器，同时严格支付他们消耗的内存和时间。谷歌最近宣布为他们的大多数云产品提供非常慷慨的免费服务，包括每月使用大量云功能。</p><p id="7c6c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于云函数在Node.js环境中执行代码，应该可以构建在Node.js环境中构建的应用程序(想想所有的<a class="ae jp" href="https://webpack.github.io/" rel="noopener ugc nofollow" target="_blank"> Webpack </a>前端，比如React和Angular应用程序等等)。所以我决定构建一个云函数，可以构建Node.js内置的前端。</p><h1 id="bb41" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">它是如何工作的</h1><p id="a62a" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">云功能是通过HTTP调用触发的(想想:<a class="ae jp" href="https://help.github.com/articles/about-webhooks/" rel="noopener ugc nofollow" target="_blank"> Github webhooks </a>)。概括地说，步骤非常简单:</p><ol class=""><li id="83f8" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated"><strong class="it hv">下载源代码</strong> —简单地克隆一个Github repo。</li><li id="f779" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated"><strong class="it hv">运行构建</strong> —执行您将在命令行上执行的构建命令，如<em class="lh"> npm运行构建。</em></li><li id="b0b5" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated"><strong class="it hv">打包构建结果</strong>——因为构建可能输出多个文件，所以最简单的方法是将所有这些结果打包成一个tarball并压缩，这样就可以将它推到其他地方了…</li><li id="273f" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated"><strong class="it hv">推送结果</strong> —云函数在临时环境中执行，因此构建结果必须被推送到某个持久的地方，以便以后使用。对它们进行打包和压缩使这变得更容易，并节省了网络出口。我选择将打包的build推送到<a class="ae jp" href="https://cloud.google.com/storage/" rel="noopener ugc nofollow" target="_blank"> GCS </a>，但是真的可以推送到任何地方。</li></ol><h1 id="cc63" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">数字</h1><p id="a054" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我测试构建了一个由<a class="ae jp" href="https://github.com/facebookincubator/create-react-app" rel="noopener ugc nofollow" target="_blank"> Create React App </a>创建的基础应用。我只能让它在2GB内存、2.4 GHz配置下运行。每次跑步不到2分钟。因此，根据<a class="ae jp" href="https://cloud.google.com/free/docs/always-free-usage-limits" rel="noopener ugc nofollow" target="_blank">Google Cloud Functions always free limits</a>，CPU资源早在RAM之前就用完了。</p><p id="8552" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">200000免费GHz-秒/(每次运行2.4 GHz * 120秒)= ~ <strong class="it hv"> 694 </strong></p><p id="7bed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这意味着每个月在谷歌云功能上免费运行~694个前端构建是很有可能的。鉴于云功能的定价模型，我不确定有多少构建值得运行专用的构建服务器。</p><h1 id="d733" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">云功能面临的挑战</h1><p id="71ec" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">这是我第一次在云功能上构建任何东西，一般来说是无服务器的。鉴于云功能还处于测试阶段，我相信它会继续以很好的方式发展。以下是我在构建这个项目时遇到的一些最大的挑战:</p><p id="aa59" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">没有文件系统</strong></p><p id="c2b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不幸的是，云函数并不能真正让你访问文件系统。他们确实给了你访问<a class="ae jp" href="https://cloud.google.com/functions/pricing#local_disk" rel="noopener ugc nofollow" target="_blank"> <em class="lh"> /tmp </em> </a>的权限，但是这似乎是针对你分配的RAM的，RAM最大容量为2GB。当从Github下载压缩的tarball、解压缩、解包、写入磁盘以及安装该项目的所有Node.js构建依赖项时，这是一个问题。我不确定这实际上需要多少内存，但天真地说，它可以达到代码库大小的4倍以上。</p><p id="2921" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">仿真器与生产</strong></p><p id="4f45" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/GoogleCloudPlatform/cloud-functions-emulator" rel="noopener ugc nofollow" target="_blank">云函数模拟器</a>和云函数生产环境之间存在一些差异，这使得开发变得困难。虽然模拟器是由谷歌开发的，但他们给出了一个免责声明，说明它不是谷歌的官方产品，所以这是公平的。</p><p id="28ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个例子是使用Node.js' <a class="ae jp" href="https://nodejs.org/api/child_process.html" rel="noopener ugc nofollow" target="_blank">子进程</a>执行命令。由于模拟器似乎并不运行在一个孤立的环境中，依赖于$PATH中的可执行文件可以在模拟器上工作，但不能在生产环境中工作。</p><p id="e08d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我最终使用<a class="ae jp" href="https://developer.github.com/v3/repos/contents/#get-archive-link" rel="noopener ugc nofollow" target="_blank"> Github Contents API </a>模仿了<em class="lh"> git clone </em>,因为我无法让最上面的几个Node.js git包在产品上工作，即使它们在模拟器上工作。常见的问题包括需要安装基本的加密库和git。</p><p id="3bd7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">部署缓慢</strong></p><p id="d808" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">部署总是需要几分钟，即使是部署简单的云功能。这使得调试仿真器与生产问题非常耗时，因为我必须为每一个小的变化重新部署(我有很多这样的变化)。</p><p id="8d4d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">没有Node.js可执行文件</strong></p><p id="0a1b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">能够构建Node.js应用程序需要访问节点<em class="lh">节点</em>和<em class="lh"> npm </em>可执行文件。鉴于云函数是在Node.js环境中执行的，我认为执行节点代码是微不足道的——我错了(有点)。虽然我可以在模拟器中<em class="lh">执行Sync </em> node命令，但是产品找不到<em class="lh"> node </em>或<em class="lh"> npm </em>可执行文件。我的第一个行动是查看我是否有任何可执行文件——是的，有效。echo＄PATH——似乎＄PATH中有几个目录——很好。<em class="lh">find/-name node-executable</em>—由于某种原因这没有返回任何东西(不确定为什么)，但是我有其他想法。我知道C允许你通过<em class="lh"> argv </em>看到调用命令，结果<a class="ae jp" href="http://stackoverflow.com/questions/4351521/how-do-i-pass-command-line-arguments" rel="noopener ugc nofollow" target="_blank">节点也能看到</a>。太棒了，我找到了<em class="lh">节点</em>可执行文件(/nodejs/bin/node)！我<a class="ae jp" href="http://stackoverflow.com/questions/2727167/how-do-you-get-a-list-of-the-names-of-all-files-present-in-a-directory-in-node-j" rel="noopener ugc nofollow" target="_blank">列出了包含目录</a>的内容，果然<em class="lh"> npm </em>也在里面。我将该目录添加到$PATH中，然后又回到了正轨。</p><h1 id="dea9" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">未来的想法</h1><ol class=""><li id="7638" class="kt ku hu it b iu ko iy kp jc li jg lj jk lk jo ky kz la lb dt translated">正在构建的项目的缓存node_modules。每个构建当前都运行<em class="lh"> npm安装</em>，这花费了大约60%的构建时间。缩短这个时间会大大降低每次构建的成本。</li><li id="7120" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">从<a class="ae jp" href="https://github.com/npm/node-tar" rel="noopener ugc nofollow" target="_blank">节点tar </a>切换到<a class="ae jp" href="https://github.com/mafintosh/tar-fs" rel="noopener ugc nofollow" target="_blank"> tar-fs </a>。tar-fs显然比node-tar快10倍，但不幸的是需要<em class="lh"> chmod </em>。默认情况下，云函数上的chmod 不在$PATH中，所以我假设它不可用。让tar-fs在未来工作是件好事。</li></ol><blockquote class="ll lm ln"><p id="89fd" class="ir is lh it b iu iv iw ix iy iz ja jb lo jd je jf lp jh ji jj lq jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是阿妹家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is lh it b iu iv iw ix iy iz ja jb lo jd je jf lp jh ji jj lq jl jm jn jo hn dt translated">要了解更多信息，请阅读我们的“关于”页面、<a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书</a>上给我们点赞/发消息，或者简单地发送<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is lh it b iu iv iw ix iy iz ja jb lo jd je jf lp jh ji jj lq jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>