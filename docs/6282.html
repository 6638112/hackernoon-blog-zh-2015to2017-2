<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://medium.com/hackernoon/contextual-logging-with-log4j2-how-we-nailed-it-in-project-x-1ffbd9e50eed?source=collection_archive---------13-----------------------#2017-09-11">https://medium.com/hackernoon/contextual-logging-with-log4j2-how-we-nailed-it-in-project-x-1ffbd9e50eed?source=collection_archive---------13-----------------------#2017-09-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><blockquote class="hs ht hu"><p id="cb7e" class="hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it hn dt translated"><em class="iu">认识一个对象就是通过这个世界提供的背景来引导它。</em></p><p id="0317" class="hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it hn dt translated">—威廉·詹姆斯(1842-1910)</p></blockquote><p id="cf8b" class="pw-post-body-paragraph hv hw iu hy b hz ia ib ic id ie if ig iv ii ij ik iw im in io ix iq ir is it hn dt translated"><a class="ae iy" href="https://hackernoon.com/tagged/logging" rel="noopener ugc nofollow" target="_blank">日志记录</a> — <a class="ae iy" href="https://hackernoon.com/tagged/maintaining" rel="noopener ugc nofollow" target="_blank">维护</a>操作的临时痕迹——对于任何任务关键型系统都至关重要，无论其规模有多大。我们的<a class="ae iy" href="https://developer.adroitlogic.com/project-x/docs/17.07/" rel="noopener ugc nofollow" target="_blank"> Project-X framework </a>也是如此，这就是为什么我们希望从一开始就把它做好。</p><p id="ad4d" class="pw-post-body-paragraph hv hw iu hy b hz ia ib ic id ie if ig iv ii ij ik iw im in io ix iq ir is it hn dt translated"><a class="ae iy" href="https://www.loggly.com/blog/logging-tips-for-power-users-contextual-logging/" rel="noopener ugc nofollow" target="_blank">上下文日志</a>——其中每个日志行自动记录其原始逻辑上下文，例如它是来自特定单元还是来自基础框架——是我们一直期待的，基于我们在传奇的<a class="ae iy" href="https://developer.adroitlogic.com/ultraesb-legacy/docs/2.6.1/" rel="noopener ugc nofollow" target="_blank"> UltraESB </a>上的日志记录经验。</p><p id="4745" class="pw-post-body-paragraph hv hw iu hy b hz ia ib ic id ie if ig iv ii ij ik iw im in io ix iq ir is it hn dt translated">我们已经知道<a class="ae iy" href="https://logging.apache.org/log4j/2.x/manual/thread-context.html" rel="noopener ugc nofollow" target="_blank"> log4j2通过它的</a> <code class="eh iz ja jb jc b"><a class="ae iy" href="https://logging.apache.org/log4j/2.x/manual/thread-context.html" rel="noopener ugc nofollow" target="_blank">CloseableThreadContext</a></code> <a class="ae iy" href="https://logging.apache.org/log4j/2.x/manual/thread-context.html" rel="noopener ugc nofollow" target="_blank">实现</a>提供了上下文日志，几乎包含了我们需要的一切；但是我们需要更多:</p><ol class=""><li id="9bd5" class="jd je iu hy b hz ia id ie iv jf iw jg ix jh it ji jj jk jl dt translated">我们需要一个合适的<a class="ae iy" href="https://www.owasp.org/index.php/Logging_Cheat_Sheet#Event_attributes" rel="noopener ugc nofollow" target="_blank">日志代码</a>治理机制，其中每个日志行包含一个唯一的日志代码，指示子系统、模块(包)甚至特定日志语句的精确“索引”,这样我们就不再需要<code class="eh iz ja jb jc b">grep</code>通过整个代码库来找出bugger来自哪里。</li><li id="a121" class="jd je iu hy b hz jm id jn iv jo iw jp ix jq it ji jj jk jl dt translated">我们需要注入带有特定前缀的环境变量和系统属性，以便自动注入到日志上下文中，这样特定的应用程序就可以将它们的运行时参数注入到日志中(例如在我们的<a class="ae iy" href="https://developer.adroitlogic.com/ips/docs/17.07/overview/" rel="noopener ugc nofollow" target="_blank">集成平台</a>中的<em class="hx">集群ID </em>)。</li></ol><p id="ae2f" class="pw-post-body-paragraph hv hw iu hy b hz ia ib ic id ie if ig iv ii ij ik iw im in io ix iq ir is it hn dt translated">我们还需要独立于log4j2的API，因为我们应该保留与log4j2分离的自由，并在需要时使用不同的日志框架(如<a class="ae iy" href="https://logback.qos.ch/manual/" rel="noopener ugc nofollow" target="_blank">日志返回</a>)。虽然我们可以利用第三方包装，如<a class="ae iy" href="https://www.slf4j.org/manual.html" rel="noopener ugc nofollow" target="_blank"> SLF4J </a>，但我们找不到一个可以满足我们所有需求的包装。</p><p id="5b2b" class="pw-post-body-paragraph hv hw iu hy b hz ia ib ic id ie if ig iv ii ij ik iw im in io ix iq ir is it hn dt translated">因此，与之前的UltraESB一样，我们用我们自己的日志实现<code class="eh iz ja jb jc b">x-logging</code>包装了log4j2。<code class="eh iz ja jb jc b">x-logging</code>由一个API和一组对真实日志框架的绑定(像log4j2和logback)组成，其中一个可以在服务器启动时用Java亲爱的老<a class="ae iy" href="https://docs.oracle.com/javase/7/docs/api/java/util/ServiceLoader.html" rel="noopener ugc nofollow" target="_blank"> ServiceLoader </a>机制动态插入。这有助于我们避免将特定于log4j2的内容泄漏到我们的实现中，因为基于log4j2的实现(以及log4j2本身)可以完全从编译时依赖集中删除。</p><p id="2820" class="pw-post-body-paragraph hv hw iu hy b hz ia ib ic id ie if ig iv ii ij ik iw im in io ix iq ir is it hn dt translated">我们团队的婉如<a class="ae iy" href="https://www.adroitlogic.com/team/ruwan-linton" rel="noopener ugc nofollow" target="_blank">也是Project-X的创始人，他用log4j2研究了一段时间，最终提出了一个很酷的设计来自动传播日志行的当前上下文，即它是来自平台(系统，又称</a><a class="ae iy" href="https://developer.adroitlogic.com/project-x/docs/17.07/architecture_and_design/runtime_architecture.html#integration-platform" rel="noopener ugc nofollow" target="_blank">引擎</a>)还是来自已部署的<a class="ae iy" href="https://developer.adroitlogic.com/project-x/docs/17.07/architecture_and_design/projects.html" rel="noopener ugc nofollow" target="_blank">项目</a>，如果是后者，则是项目的其他元数据(如版本)。最酷的部分是，一旦执行离开这个特定的上下文，这个上下文就会自动清理。</p><p id="8003" class="pw-post-body-paragraph hv hw iu hy b hz ia ib ic id ie if ig iv ii ij ik iw im in io ix iq ir is it hn dt translated">如果你熟悉<code class="eh iz ja jb jc b"><a class="ae iy" href="https://logging.apache.org/log4j/2.0/log4j-api/apidocs/org/apache/logging/log4j/CloseableThreadContext.html" rel="noopener ugc nofollow" target="_blank">CloseableThreadContext</a></code>，这听起来可能很简单。对于其他人来说，只需提及<code class="eh iz ja jb jc b">CloseableThreadContext</code>便于将键值对注入到日志记录上下文中，这样当上下文关闭时，只有当前上下文中注入的键值对被清理。注入的值会自动提供给调用线程的日志记录上下文(<code class="eh iz ja jb jc b">ThreadContext</code>);或者，用英语来说，由该线程打印的每一行日志都会在其线程上下文中看到该参数(或者用老式行话来说是<a class="ae iy" href="https://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/MDC.html" rel="noopener ugc nofollow" target="_blank"> MDC </a>)。</p><p id="40e4" class="pw-post-body-paragraph hv hw iu hy b hz ia ib ic id ie if ig iv ii ij ik iw im in io ix iq ir is it hn dt translated">好吧，我承认以上可能有点难以理解。也许一个示例代码片段可以做得更好:</p><pre class="jr js jt ju fq jv jc jw jx aw jy dt"><span id="ce9c" class="jz ka iu jc b fv kb kc l kd ke">// assume we are walking in, with nothing useful in the context</span><span id="1a12" class="jz ka iu jc b fv kf kc l kd ke">try (CloseableThreadContext.Instance level1 =<br/>    CloseableThreadContext.put("level", "1")) {</span><span id="911e" class="jz ka iu jc b fv kf kc l kd ke">    // now the context has "1" as "level"</span><span id="839b" class="jz ka iu jc b fv kf kc l kd ke">    // will see {level=1} as // the context<br/>    logger.debug("Commencing operation");</span><span id="baf3" class="jz ka iu jc b fv kf kc l kd ke">    // let's also put in a "clearance" value<br/>    level1.put("clearance", "nypd");</span><span id="2927" class="jz ka iu jc b fv kf kc l kd ke">    // now, any log lines would see {level=1,clearance=nypd}</span><span id="748b" class="jz ka iu jc b fv kf kc l kd ke">    logger.debug("Commencing operation");<br/>    // let's also put in a "clearance" value<br/>    level1.put("clearance", "nypd");<br/>    // now, any log lines would see {level=1,clearance=nypd}</span><span id="cbfe" class="jz ka iu jc b fv kf kc l kd ke">    // let's go deeper<br/>    try (CloseableThreadContext.Instance level2 =<br/>        CloseableThreadContext.put("level", "2")<br/>            .put("clearance", "fbi")) {</span><span id="fb39" class="jz ka iu jc b fv kf kc l kd ke">        /* now both of the above "level" and "clearance"<br/>           values are "masked" by the new ones<br/>           and yes, you can chain together context mutations */</span><span id="2098" class="jz ka iu jc b fv kf kc l kd ke">        // will see {level=2,clearance=fbi}<br/>        logger.debug("Commencing investigation");</span><span id="b620" class="jz ka iu jc b fv kf kc l kd ke">        // putting in some more<br/>        level2.put("access", "privileged");<br/>        // now context = {level=2,clearance=fbi,access=privileged}</span><span id="a9ad" class="jz ka iu jc b fv kf kc l kd ke">        // still deeper...<br/>        try (CloseableThreadContext.Instance level3 =<br/>            CloseableThreadContext.put("level", "3")<br/>                .put("clearance", "cia")) {</span><span id="5f09" class="jz ka iu jc b fv kf kc l kd ke">            /* "level" and "clearance" are overridden, but<br/>               "access" remains unchanged */</span><span id="d2b3" class="jz ka iu jc b fv kf kc l kd ke">            // {level=3,clearance=cia,access=privileged}<br/>            logger.debug("Commencing consipracy");</span><span id="4854" class="jz ka iu jc b fv kf kc l kd ke">        }</span><span id="b490" class="jz ka iu jc b fv kf kc l kd ke">        /* cool thing is, once you're out of the level3 block,<br/>           the context will be restored to that of level2<br/>           (thanks to the AutoCloseable nature of<br/>           CloseableThreadContext.Instance) */</span><span id="b47b" class="jz ka iu jc b fv kf kc l kd ke">        // {level=2,clearance=fbi,access=privileged}<br/>        logger.debug("Back to investigation");<br/>    }</span><span id="1178" class="jz ka iu jc b fv kf kc l kd ke">    // same for exiting level 2<!-- --> </span><span id="bce2" class="jz ka iu jc b fv kf kc l kd ke">    // {level=1,clearance=nypd}; access is gone!<br/>    logger.debug("Back to operation");</span><span id="b66e" class="jz ka iu jc b fv kf kc l kd ke">}</span><span id="2cfa" class="jz ka iu jc b fv kf kc l kd ke">logger.debug("Back to square one"); // {}; oh no, all gone!</span></pre><p id="f40e" class="pw-post-body-paragraph hv hw iu hy b hz ia ib ic id ie if ig iv ii ij ik iw im in io ix iq ir is it hn dt translated">这种机制非常适合我们的使用，因为我们需要包含线程的当前执行上下文以及该线程生成的每个日志行:</p><ol class=""><li id="c4da" class="jd je iu hy b hz ia id ie iv jf iw jg ix jh it ji jj jk jl dt translated">在<a class="ae iy" href="https://developer.adroitlogic.com/project-x/docs/17.07/architecture_and_design/runtime_architecture.html" rel="noopener ugc nofollow" target="_blank">Project-X</a>(UltraESB-X<a class="ae iy" href="https://developer.adroitlogic.com/ultraesb-x/docs/17.07/" rel="noopener ugc nofollow" target="_blank">的底层引擎)中，维护在基础框架级别的</a><a class="ae iy" href="https://docs.oracle.com/javase/tutorial/essential/concurrency/pools.html" rel="noopener ugc nofollow" target="_blank">工作线程池</a>负责代表属于特定项目的<a class="ae iy" href="https://developer.adroitlogic.com/project-x/docs/17.07/architecture_and_design/integration_flows_and_subflows.html" rel="noopener ugc nofollow" target="_blank">集成流</a>处理入站消息。</li><li id="372f" class="jd je iu hy b hz jm id jn iv jo iw jp ix jq it ji jj jk jl dt translated">只有在消息被注入到特定集成流的<a class="ae iy" href="https://developer.adroitlogic.com/project-x/docs/17.07/components_of_project_x/ingress_connectors.html" rel="noopener ugc nofollow" target="_blank">入口连接器</a>之后，我们才认为该线程处于项目的上下文中。在此之前，工作线程应该做很多工作，所有这些工作都被认为属于<code class="eh iz ja jb jc b">system</code>上下文。</li><li id="e903" class="jd je iu hy b hz jm id jn iv jo iw jp ix jq it ji jj jk jl dt translated">我们在整个过程中生成日志，所以它们应该自动用适当的上下文进行标记。</li><li id="f27a" class="jd je iu hy b hz jm id jn iv jo iw jp ix jq it ji jj jk jl dt translated">此外，由于每个日志行都有特定的错误代码，因此每次实际输出日志行时，都需要打开一个新的上下文，其中除了其他上下文参数之外，还将包含所需的日志代码。</li></ol><p id="3bb1" class="pw-post-body-paragraph hv hw iu hy b hz ia ib ic id ie if ig iv ii ij ik iw im in io ix iq ir is it hn dt translated">因此，线程在池中的生命将是一个无止境的循环，类似于:</p><pre class="jr js jt ju fq jv jc jw jx aw jy dt"><span id="11b7" class="jz ka iu jc b fv kb kc l kd ke">// wake up from thread pool</span><span id="1ca5" class="jz ka iu jc b fv kf kc l kd ke">// do system level stuff</span><span id="bc97" class="jz ka iu jc b fv kf kc l kd ke">loggerA.debug(143, "Now I'm doing this cool thing : {}", param);</span><span id="6537" class="jz ka iu jc b fv kf kc l kd ke">try (CloseableThreadContext.Instance projectCtx =<br/>     CloseableThreadContext.put("project", project.getName())<br/>         .put("version", project.getVersion())) {</span><span id="be57" class="jz ka iu jc b fv kf kc l kd ke">    // do project level stuff</span><span id="1e2a" class="jz ka iu jc b fv kf kc l kd ke">    loggerM.debug(78, "About to get busy : {}", param);</span><span id="8c60" class="jz ka iu jc b fv kf kc l kd ke">    // more stuff, tra la la la<br/>}</span><span id="4c23" class="jz ka iu jc b fv kf kc l kd ke">// back to system level, do still more stuff</span></pre><p id="e931" class="pw-post-body-paragraph hv hw iu hy b hz ia ib ic id ie if ig iv ii ij ik iw im in io ix iq ir is it hn dt translated">在内部，<code class="eh iz ja jb jc b">loggerA</code>、<code class="eh iz ja jb jc b">loggerM</code>和其他将最终调用一个<code class="eh iz ja jb jc b">logImpl(code, message, params)</code>方法:</p><pre class="jr js jt ju fq jv jc jw jx aw jy dt"><span id="e28a" class="jz ka iu jc b fv kb kc l kd ke">// context already has system/project info,<br/>// logger already has a pre-computed codePrefix</span><span id="6e7d" class="jz ka iu jc b fv kf kc l kd ke">try (CloseableThreadContext.Instance logCtx =<br/>     CloseableThreadContext.put("logcode", codePrefix + code)) {</span><span id="9b35" class="jz ka iu jc b fv kf kc l kd ke">    // publish the actual log line<br/>}</span><span id="9ef8" class="jz ka iu jc b fv kf kc l kd ke">// only "logcode" cleared from the context, others remain intact</span></pre><p id="c1b5" class="pw-post-body-paragraph hv hw iu hy b hz ia ib ic id ie if ig iv ii ij ik iw im in io ix iq ir is it hn dt translated">我们通过引入一个<code class="eh iz ja jb jc b">CloseableContext</code>接口来模拟这种行为，而没有绑定到log4j2:</p><pre class="jr js jt ju fq jv jc jw jx aw jy dt"><span id="54cd" class="jz ka iu jc b fv kb kc l kd ke">import java.io.Closeable;</span><span id="d691" class="jz ka iu jc b fv kf kc l kd ke">public interface CloseableContext extends Closeable {</span><span id="7150" class="jz ka iu jc b fv kf kc l kd ke">    CloseableContext append(final String key, final String value);</span><span id="0cfe" class="jz ka iu jc b fv kf kc l kd ke">    void close();<br/>}</span></pre><p id="8848" class="pw-post-body-paragraph hv hw iu hy b hz ia ib ic id ie if ig iv ii ij ik iw im in io ix iq ir is it hn dt translated">其log4j2变体(<code class="eh iz ja jb jc b">Log4j2CloseableContext</code>，显然)将以同样的方式操作<code class="eh iz ja jb jc b">CloseableThreadContext</code>实例:</p><pre class="jr js jt ju fq jv jc jw jx aw jy dt"><span id="fffc" class="jz ka iu jc b fv kb kc l kd ke">import org.adroitlogic.x.logging.CloseableContext;<br/>import org.apache.logging.log4j.CloseableThreadContext;</span><span id="295e" class="jz ka iu jc b fv kf kc l kd ke">public class Log4j2CloseableContext implements CloseableContext {</span><span id="b4ca" class="jz ka iu jc b fv kf kc l kd ke">    private final CloseableThreadContext.Instance ctx;</span><span id="d6c9" class="jz ka iu jc b fv kf kc l kd ke">    /**<br/>     * Creates an instance wrapping a new default MDC instance<br/>     */<br/>    Log4j2CloseableContext() {<br/>        this.ctx = CloseableThreadContext.put("impl",<br/>            "project-x");<br/>    }</span><span id="f012" class="jz ka iu jc b fv kf kc l kd ke">    /**<br/>     * Adds the provided key-value pair to the currently active<br/>     * log4j logging (thread) context<br/>     *<br/>     * @param key   the key to be inserted into the context<br/>     * @param value the value to be inserted, corresponding to<br/>     * {@code key}<br/>     * @return the current instance, wrapping the same logging <br/>     * context<br/>     */<br/>    @Override<br/>    public CloseableContext append(String key, String value) {<br/>        ctx.put(key, value);<br/>        return this;<br/>    }</span><span id="36f2" class="jz ka iu jc b fv kf kc l kd ke">    /**<br/>     * Closes the log4j logging context wrapped by the<br/>     * current instance<br/>     */<br/>    @Override<br/>    public void close() {<br/>        ctx.close();<br/>    }<br/>}</span></pre><p id="fbdf" class="pw-post-body-paragraph hv hw iu hy b hz ia ib ic id ie if ig iv ii ij ik iw im in io ix iq ir is it hn dt translated">现在，我们所要做的就是通过一个漂亮的管理界面打开一个合适的上下文，<code class="eh iz ja jb jc b">LogContextProvider</code>:</p><pre class="jr js jt ju fq jv jc jw jx aw jy dt"><span id="0bfb" class="jz ka iu jc b fv kb kc l kd ke">// system context is active by default</span><span id="ea93" class="jz ka iu jc b fv kf kc l kd ke">...</span><span id="f156" class="jz ka iu jc b fv kf kc l kd ke">try (CloseableContext projectCtx =<br/>     LogContextProvider.forProject(project.getName(),<br/>         project.getVersion())) {</span><span id="3d9a" class="jz ka iu jc b fv kf kc l kd ke">    // now in project context<br/>}</span><span id="0d68" class="jz ka iu jc b fv kf kc l kd ke">// back to system context</span></pre><p id="dfb1" class="pw-post-body-paragraph hv hw iu hy b hz ia ib ic id ie if ig iv ii ij ik iw im in io ix iq ir is it hn dt translated">而在<code class="eh iz ja jb jc b">logImpl</code>:</p><pre class="jr js jt ju fq jv jc jw jx aw jy dt"><span id="37e5" class="jz ka iu jc b fv kb kc l kd ke">try (CloseableContext logCtx = <br/>     LogContextProvider.overlayContext("logcode",<br/>         codePrefix + code)) {</span><span id="6ef6" class="jz ka iu jc b fv kf kc l kd ke">    // call the underlying logging framework<br/>}</span></pre><p id="557a" class="pw-post-body-paragraph hv hw iu hy b hz ia ib ic id ie if ig iv ii ij ik iw im in io ix iq ir is it hn dt translated">由于我们加载了<code class="eh iz ja jb jc b">CloseableContext</code>实现和日志绑定(通过<code class="eh iz ja jb jc b">ServiceLoader</code>，我们知道<code class="eh iz ja jb jc b">LogContextProvider</code>最终将调用正确的实现。</p><p id="e6f5" class="pw-post-body-paragraph hv hw iu hy b hz ia ib ic id ie if ig iv ii ij ik iw im in io ix iq ir is it hn dt translated">这就是我们<code class="eh iz ja jb jc b">x-logging</code>框架中上下文日志的故事。</p><p id="0985" class="pw-post-body-paragraph hv hw iu hy b hz ia ib ic id ie if ig iv ii ij ik iw im in io ix iq ir is it hn dt translated">也许我们还可以在以后的文章中解释我们的日志代码治理方法；在那之前，祝你伐木快乐！</p><figure class="jr js jt ju fq kg"><div class="bz el l di"><div class="kh ki l"/></div></figure></div></div>    
</body>
</html>