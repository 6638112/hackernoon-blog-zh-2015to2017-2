<html>
<head>
<title>Destructuring Clojure with Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Javascript析构Clojure</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/destructuring-clojure-with-javascript-bd1398bdacb6?source=collection_archive---------2-----------------------#2016-10-02">https://medium.com/hackernoon/destructuring-clojure-with-javascript-bd1398bdacb6?source=collection_archive---------2-----------------------#2016-10-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="c277" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Clojure是我在T2 Swym公司工作时学习的一种语言。当我去年加入时，我不知道它意味着什么，除非它是导致Javascript for loops出现问题的<a class="ae jp" href="http://stackoverflow.com/a/111111/1304559" rel="noopener ugc nofollow" target="_blank">。</a>事实证明它非常接近于<a class="ae jp" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> Javascript </a>。</p><figure class="jt ju jv jw fq jx fe ff paragraph-image"><div class="fe ff js"><img src="../Images/be290c1b77282727c1f0a5c585c59268.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/1*UW5b4MwwetvcIvgR7u2R5A.png"/></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">Source — <a class="ae jp" href="http://java.ociweb.com/mark/clojure/article.html" rel="noopener ugc nofollow" target="_blank">http://java.ociweb.com/mark/clojure/article.html</a></figcaption></figure><p id="a5b6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">来到Clojure。这是一种美丽的语言。一开始很奇怪，但你会慢慢喜欢的。函数式语言似乎更倾向于。在这篇文章中，我将谈论许多语言共有的一个特性，但在Clojure和Javascript中有具体的细节，有它们的快乐和痛苦。破坏。为什么是Clojure？—那是以后的事了。</p><p id="c9b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">析构使赋值变得更容易，这可能需要多行代码。</p><h1 id="1c84" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">简单的解构，</h1><p id="8dcd" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">简单来说，从向量和数组中快速加载变量，不多不少重复一个字。</p><pre class="jt ju jv jw fq lh li lj lk aw ll dt"><span id="e943" class="lm kf hu li b fv ln lo l lp lq">//JS</span><span id="194e" class="lm kf hu li b fv lr lo l lp lq">// Old way<br/>var list = [1,2,3];<br/>var x = list[0], y = list[1], z = list[2];<br/>console.log(x, y, z);</span><span id="7536" class="lm kf hu li b fv lr lo l lp lq">// Destructured way<br/>var list = [1,2,3];<br/>var [x, y, z, a] = list;<br/>console.log(x, y, z, a);<br/>// Note - Any extra parameter not accounted for becomes <em class="ls">undefined</em></span></pre><p id="c7e6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Clojure和JS的一个明显区别是数据结构的不变性。Like变量赋值可用，但不一定好用。这在理解Clojure时起了很大作用，我最初认为这是一个障碍。但是随着时间的推移，直觉显现出来了。</p><pre class="jt ju jv jw fq lh li lj lk aw ll dt"><span id="17ad" class="lm kf hu li b fv ln lo l lp lq">;; Clojure</span><span id="ddbf" class="lm kf hu li b fv lr lo l lp lq">;; Using let definition, same can be done with a <em class="ls">def </em>for the list<br/>(let [list [1 2 3]<br/>  [x y z] list]<br/>  (println x y z))</span><span id="4943" class="lm kf hu li b fv lr lo l lp lq">;; Better one, list ref created within the destructuring<br/>(let [[x y z a :as list] [1 2 3]]<br/> (println x y z a list))<br/>;; Note - Extra parameter unaccounted for becomes <em class="ls">nil</em></span></pre><p id="73db" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">更深入地研究向量，尤其是当你不想列出参数和析构的时候</p><pre class="jt ju jv jw fq lh li lj lk aw ll dt"><span id="0d21" class="lm kf hu li b fv ln lo l lp lq">// JS<br/>// Bunching rest of the values with a spread operator<br/>var list = [1, 2, 3, 5, 6, 7, 8];<br/>var [x, y, z, …a] = list;<br/>console.log(x, y, z, a);<br/>// Note - The last param will be the spread operator(...) Powerful for array merging, and data processing. <a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator" rel="noopener ugc nofollow" target="_blank">More on spread operators</a></span><span id="21de" class="lm kf hu li b fv lr lo l lp lq">// Ignoring parts<br/>var list = [1, 2, "ignore me", 3];<br/>var [x,y,,z] = list;<br/>console.log(x,y,z);</span></pre><p id="6c96" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Clojure与之匹配</p><pre class="jt ju jv jw fq lh li lj lk aw ll dt"><span id="eb5b" class="lm kf hu li b fv ln lo l lp lq">;; Clojure<br/>;; Spread operator<br/>(let [[x y z &amp; rest-of-it :as list] [1 2 3 5 6 7 8]]<br/> (println x y z rest-of-it))</span><span id="782c" class="lm kf hu li b fv lr lo l lp lq">;; Ignoring <br/>(let [[x y _ z :as list] [1 2 "ignore me" 3]]<br/>  (println x y z))</span></pre><p id="0c66" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">选择缺省值很简单，没有以前那些脆弱的if检查。</p><pre class="jt ju jv jw fq lh li lj lk aw ll dt"><span id="f042" class="lm kf hu li b fv ln lo l lp lq">// JS<br/>// Old way - Default values<br/>var list = [1,2];<br/>var x = list[0], y = list[1];<br/>var z = list[2] || 'default z'; // This check is flimsy, you need to check for <em class="ls">undefined</em> to avoid <em class="ls">falsy</em> errors. for eg: false will pass to second part</span><span id="0e0e" class="lm kf hu li b fv lr lo l lp lq"><br/>// Default values<br/>var list = [1, 2];<br/>var [x,y,z="default z"] = list;<br/>console.log(x,y,z);</span></pre><p id="f3c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Clojure中相同</p><pre class="jt ju jv jw fq lh li lj lk aw ll dt"><span id="7b65" class="lm kf hu li b fv ln lo l lp lq">;; Clojure<br/>;; Default values<br/>(let [[x,y,z :or [z 10]] [1 2]]<br/> (println x y z))</span></pre><h1 id="d280" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">对象和嵌套结构</h1><p id="8111" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">这就是真正的乐趣所在。通过简化赋值，对于接受配置和可选参数的函数非常强大。</p><pre class="jt ju jv jw fq lh li lj lk aw ll dt"><span id="4599" class="lm kf hu li b fv ln lo l lp lq">// JS<br/>// Object<br/>var o = {“x”: 1, “y”: 2, “z”: 3};<br/>var {x, y, z} = o;<br/>console.log(x, y, z);<br/>// Also works - var {x, y, z} = {x: 1, y: 2, z: 3};<br/>// Also works - var x,y,z; ({x, y, z} = o);</span><span id="10ae" class="lm kf hu li b fv lr lo l lp lq">// Renaming<br/>var o = {“x”: 1, “y”: 2, “z”: 3};<br/>var {x: a, y: b, z: c} = o;<br/>console.log(a, b, c);</span><span id="f4e3" class="lm kf hu li b fv lr lo l lp lq">// Default values with renaming<br/>var o = {“x”: 1, “y”: 2, “z”: 3};<br/>var {x, y, z: c, p: d=10, q=20} = o;<br/>console.log(a, b, c, d, q);</span><span id="7764" class="lm kf hu li b fv lr lo l lp lq">// Usage in functions<br/>function doSomethingAwesome({mandatoryParam, renameParam: changedParam, optionalParam=1, optionalRenameParam: changedOptionalParam=2}){<br/> console.log(mandatoryParam, changedParam, optionalParam, changedOptionalParam);<br/>}<br/>doSomethingAwesome({mandatoryParam: 10, renameParam: 20});</span><span id="4ec7" class="lm kf hu li b fv lr lo l lp lq">// Nested objects<br/>var o = {<br/> “a”: {<br/> “x”: 1,<br/> “y”: [2, 3]<br/> }<br/>};</span><span id="761c" class="lm kf hu li b fv lr lo l lp lq">// With renaming and default values<br/>var {a: {x, y: [aa, bb, cc=20], z=10}} = o;<br/>console.log(a, x, y, p, aa, bb, cc, z);</span></pre><p id="96ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">与Javascript相比，Clojure有一些枪，如<em class="ls"> :keys </em>和<em class="ls"> :strs </em>绑定形式，将析构捆绑在一起。警告——进入一个稍微复杂一点的领域</p><pre class="jt ju jv jw fq lh li lj lk aw ll dt"><span id="1b68" class="lm kf hu li b fv ln lo l lp lq">;; Clojure<br/>;; Object — not so efficient when there is no renaming<br/>(let [{x :x y :y} {:x 1 :y 2 :z 3}]<br/> (println x y))<br/> <br/>;; Object with renaming<br/>(let [{rx :x y :y} {:x 1 :y 2 :z 3}]<br/> (println rx y))</span><span id="682a" class="lm kf hu li b fv lr lo l lp lq">;; Object with keywords and strings, but no renaming<br/>(let [{:keys [x y z] :as list} {:x 1 :y 2 :z 3}<br/> {:strs [xx yy zz] :as list-str} {“xx” 11 “yy” 22 “zz” 33}]<br/> (println x y z xx yy zz))</span><span id="6d22" class="lm kf hu li b fv lr lo l lp lq">;; Object with defaults<br/>(let [{:keys [x y z xx yy zz] :or {xx 10 yy 20 zz 30} :as list} {:x 1 :y 2 :z 3}]<br/> (println x y z xx yy zz))<br/> <br/>;; Object defaults with renaming<br/>(let [{rx :x y :y rz :z :or {rz 30}} {:x 1 :y 2}]<br/> (println rx y rz))<br/> <br/>;; Usage in functions — not so efficient<br/>(defn do-something-awesome [{<br/> mandatoryParam :mandatoryParam<br/> changedParam :renameParam<br/> optionalParam :optionalParam<br/> changedOptionalParam :optionalRenameParam<br/> :or {optionalParam 1 changedOptionalParam 2} }]<br/> (println mandatoryParam changedParam optionalParam changedOptionalParam))</span><span id="ee26" class="lm kf hu li b fv lr lo l lp lq">(do-something-awesome {:mandatoryParam 10 :renameParam 20})</span><span id="f790" class="lm kf hu li b fv lr lo l lp lq">;; Usage in functions — better<br/>(defn do-something-awesome [{<br/> :keys [mandatoryParam optionalParam optionalRenameParam]<br/> changedParam :renameParam<br/> changedOptionalParam :optionalRenameParam<br/> :or {optionalParam 1 changedOptionalParam 2}<br/> }]<br/> (println mandatoryParam changedParam optionalParam changedOptionalParam))</span><span id="2f00" class="lm kf hu li b fv lr lo l lp lq">(do-something-awesome {:mandatoryParam 10 :renameParam 20})</span><span id="eddc" class="lm kf hu li b fv lr lo l lp lq">;; Nested objects<br/>(def o {<br/> :a {<br/> :x 1<br/> :y [2, 3]<br/> }<br/>})<br/>;; With default values<br/>(let [{ {:keys [x y]} :a} o<br/> [y1,y2] y] ;; forced to add a line to break y to params<br/> (println x y y1 y2))</span><span id="4d9d" class="lm kf hu li b fv lr lo l lp lq">;; y1, y2 don’t get assigned, what’s wrong? a TODO for me to figure out<br/>(let [{ {:keys [x [[y1,y2] :y]]} :a} o]<br/> (println x y y1 y2))</span></pre><p id="b75e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">keys绑定窗体和常规析构函数的用法是一种很好的用法，而不是只有一种。<em class="ls">支持重命名；作为更高层次的</em>绑定形式</p><p id="011a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在是时候大开杀戒了。让我们看看上面哪个组合打破了REPL。</p><p id="b231" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">JS Overkill</strong>——很难找到这种情况——使用内部析构进行重命名</p><pre class="jt ju jv jw fq lh li lj lk aw ll dt"><span id="dfaa" class="lm kf hu li b fv ln lo l lp lq">// Overkill?<br/>var o = {<br/> “a”: {<br/> “x”: 1,<br/> “y”: [2, 3]<br/> }<br/>};<br/>var {a: {x, y: p = [aa, bb, dd=20], z=10}} = o;<br/>console.log(a, x, y, p, aa, bb, dd, z);<br/>// Throws error, renaming with internal destructuring doesn’t work</span></pre><p id="295b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Clojure Overkill更容易被发现。试图在析构对象时析构对象内部的向量。</p><pre class="jt ju jv jw fq lh li lj lk aw ll dt"><span id="1c29" class="lm kf hu li b fv ln lo l lp lq">;; y1, y2 don't get assigned, what’s wrong? a TODO for me to figure out<br/>(let [{ {:keys [x [[y1,y2] :y]]} :a} o]<br/> (println x y y1 y2))</span></pre><p id="7419" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">析构使得代码更直观，更容易编写函数，阅读函数式编程。两者对比，让Javascript的函数起源更加清晰。一个新的问题是Javascript原型对象属于函数式编程范式吗？</p><p id="9a9b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不幸的是，对于Javascript用户来说，在所有基于浏览器的JIT上使用析构并不完全安全，但是如果你了解你的部署，就去做吧。</p><p id="78c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一定要让我知道你的想法和你将如何使用它们，并请改进我可能写错的任何东西。</p><p id="a47c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">参考文献</strong></p><p id="d1ad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">Javascript<br/></strong>T5】https://developer . Mozilla . org/en/docs/Web/Javascript/Reference/Operators/destructing _ assignment<br/><a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/Javascript/Reference/Operators/Spread _ operator</a></p><p id="40e1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> Clojure </strong> <br/> <a class="ae jp" href="http://blog.brunobonacci.com/2014/11/16/clojure-complete-guide-to-destructuring/" rel="noopener ugc nofollow" target="_blank">先看这个很有用——http://blog . brunobonacci . com/2014/11/16/clo jure-complete-guide-to-destructing/</a><br/><a class="ae jp" href="http://clojure.org/guides/destructuring" rel="noopener ugc nofollow" target="_blank">http://clojure.org/guides/destructuring</a><br/><a class="ae jp" href="https://gist.github.com/john2x/e1dca953548bfdfb9844" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/john2x/e1dca953548bfdfb9844</a></p><p id="ff10" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">页（page的缩写）S: PHP烂，Javascript美，Java一致，CSS再美，客观C诡异，Python敏感(读空白)，C#/。网是变种人等等。全是个人观点。</p><p id="a375" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">页（page的缩写）附言:我用来参考的要点</p><figure class="jt ju jv jw fq jx"><div class="bz el l di"><div class="lt lu l"/></div></figure><div class="jt ju jv jw fq ab cb"><figure class="lv jx lw lx ly lz ma paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="lv jx lw lx ly lz ma paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="lv jx lw lx ly lz ma paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mb mc md"><p id="f922" class="ir is ls it b iu iv iw ix iy iz ja jb me jd je jf mf jh ji jj mg jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是这个家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is ls it b iu iv iw ix iy iz ja jb me jd je jf mf jh ji jj mg jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jt ju jv jw fq jx fe ff paragraph-image"><a href="https://goo.gl/Ahtev1"><div class="fe ff mh"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></a></figure><figure class="jt ju jv jw fq jx"><div class="bz el l di"><div class="mi lu l"/></div></figure></div></div>    
</body>
</html>