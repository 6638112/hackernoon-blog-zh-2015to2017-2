<html>
<head>
<title>30-minute Python Web Scraper</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">30分钟Python Web Scraper</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/30-minute-python-web-scraper-39d6d038e5da?source=collection_archive---------4-----------------------#2017-10-28">https://medium.com/hackernoon/30-minute-python-web-scraper-39d6d038e5da?source=collection_archive---------4-----------------------#2017-10-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="3d93" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我一直想用Python和<a class="ae jp" href="http://www.seleniumhq.org/" rel="noopener ugc nofollow" target="_blank"> Selenium </a>创建一个web scraper，但是一直没有时间去做。几天前的晚上，我决定尝试一下。尽管看起来令人生畏，但编写代码从<a class="ae jp" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>抓取一些美丽的图像却极其容易。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/ce722aaf795db1ef6991e3c0093082af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9wHrewC1Dyf2Au_qEqwWcg.jpeg"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Image credit: <a class="ae jp" href="https://unsplash.com/@blakeconnally" rel="noopener ugc nofollow" target="_blank">Blake Connally</a> via <a class="ae jp" href="https://unsplash.com/photos/B3l0g6HLxr8" rel="noopener ugc nofollow" target="_blank">Unsplash.com</a></figcaption></figure><h2 id="2f67" class="kg kh hu bd ki kj kk kl km kn ko kp kq jc kr ks kt jg ku kv kw jk kx ky kz la dt translated">简单图像刮刀的成分</h2><ul class=""><li id="8164" class="lb lc hu it b iu ld iy le jc lf jg lg jk lh jo li lj lk ll dt translated"><a class="ae jp" href="https://www.python.org/downloads/" rel="noopener ugc nofollow" target="_blank"> Python </a> (3.6.3或更新版本)</li><li id="fca3" class="lb lc hu it b iu lm iy ln jc lo jg lp jk lq jo li lj lk ll dt translated"><a class="ae jp" href="https://www.jetbrains.com/pycharm/download/#section=windows" rel="noopener ugc nofollow" target="_blank"> Pycharm </a>(社区版就好)</li><li id="44d4" class="lb lc hu it b iu lm iy ln jc lo jg lp jk lq jo li lj lk ll dt translated"><code class="eh lr ls lt lu b">pip install <a class="ae jp" href="http://docs.python-requests.org/en/master/user/install/#install" rel="noopener ugc nofollow" target="_blank">requests</a> <a class="ae jp" href="https://pillow.readthedocs.io/en/latest/installation.html#basic-installation" rel="noopener ugc nofollow" target="_blank">Pillow</a> <a class="ae jp" href="http://selenium-python.readthedocs.io/installation.html#downloading-python-bindings-for-selenium" rel="noopener ugc nofollow" target="_blank">selenium</a></code></li><li id="8a48" class="lb lc hu it b iu lm iy ln jc lo jg lp jk lq jo li lj lk ll dt translated">壁虎驱动器(阅读下面的说明)</li><li id="03bb" class="lb lc hu it b iu lm iy ln jc lo jg lp jk lq jo li lj lk ll dt translated"><a class="ae jp" href="https://www.mozilla.org/en-US/firefox/new/" rel="noopener ugc nofollow" target="_blank">mozzla Firefox</a>(好像你没装)</li><li id="c369" class="lb lc hu it b iu lm iy ln jc lo jg lp jk lq jo li lj lk ll dt translated">工作互联网连接(显然)</li><li id="6c99" class="lb lc hu it b iu lm iy ln jc lo jg lp jk lq jo li lj lk ll dt translated">你30分钟的时间(可能更少)</li></ul><h2 id="bb39" class="kg kh hu bd ki kj kk kl km kn ko kp kq jc kr ks kt jg ku kv kw jk kx ky kz la dt translated">简单图像刮刀的配方</h2><p id="0e57" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lv je jf jg lw ji jj jk lx jm jn jo hn dt translated">一切都安装好了吗？很好！随着我们继续编写代码，我将解释这些组件的作用。</p><p id="f084" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将利用的第一件事是与<strong class="it hv"> geckodriver </strong>结合的<strong class="it hv"> Selenium webdriver </strong>来打开一个为我们工作的浏览器窗口。首先，在<strong class="it hv"> Pycharm </strong>中创建一个项目，为您的操作系统下载最新版本的geckodriver，打开压缩文件并将geckodriver文件拖放到您的项目文件夹中。Geckodriver基本上是让Selenium控制Firefox的工具，所以我们需要将它放在项目文件夹中，以便能够使用浏览器。</p><p id="a7bb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来我们要做的是将webdriver从Selenium导入到我们的代码中，并连接到我们想要的URL。让我们就这么做吧:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ly lz l"/></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Opening a new browser window to a specific URL</figcaption></figure><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff ma"><img src="../Images/74accd74c5fd2fdcc78a4f473439bfdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SXfVW1B1UiQakb200l9EmA.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">A remote-controlled Firefox window</figcaption></figure><p id="01f2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">很简单，是吧？如果你已经正确地做了所有的事情，那么你已经完成了最难的部分，你应该会看到一个类似于上图所示的浏览器窗口。</p><p id="4308" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，我们应该<strong class="it hv">向下滚动</strong>,以便在我们开始下载之前可以加载更多的图像。我们还希望<strong class="it hv">等待几秒钟</strong>，以防连接缓慢且图像未完全加载。由于Unsplash是用React构建的，等待大约5秒钟似乎是一个很长的时间，所以我们应该使用<code class="eh lr ls lt lu b">time</code>包来这样做。我们还想使用一些Javascript代码来滚动页面——我们将使用<code class="eh lr ls lt lu b"><a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollTo" rel="noopener ugc nofollow" target="_blank">window.scrollTo()</a></code>来完成这个任务。将所有这些放在一起，您最终应该会得到这样的结果:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ly lz l"/></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Scrolling the page and waiting 5 seconds</figcaption></figure><p id="c977" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">测试完上面的代码后，您应该会看到浏览器将页面向下滚动了一点。接下来我们需要做的是从网站上找到我们想要下载的图片。在深入研究了React生成的代码后，我发现我们可以使用一个<strong class="it hv"> CSS选择器</strong>来专门定位页面图库中的图像。页面的具体布局和代码将来可能会改变，但在编写本文时，我可以使用一个<code class="eh lr ls lt lu b">#gridMulti img</code>选择器来获取出现在我屏幕上的所有<code class="eh lr ls lt lu b">&lt;img&gt;</code>元素。</p><p id="44c5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以使用<code class="eh lr ls lt lu b"><a class="ae jp" href="http://selenium-python.readthedocs.io/api.html#selenium.webdriver.remote.webdriver.WebDriver.find_element_by_css_selector" rel="noopener ugc nofollow" target="_blank">find_elements_by_css_selector()</a></code>得到这些元素的列表，但是我们想要的是每个元素的<code class="eh lr ls lt lu b">src</code>属性。因此，我们可以遍历列表并获取这些内容:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ly lz l"/></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Selecting image elements and getting the images’ URLs</figcaption></figure><p id="ef5d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，为了得到我们发现的图像。为此，我们将使用<code class="eh lr ls lt lu b">requests</code>和<code class="eh lr ls lt lu b">PIL</code>包的一部分，即<code class="eh lr ls lt lu b">Image</code>。我们还想使用来自<code class="eh lr ls lt lu b">io</code>的<code class="eh lr ls lt lu b">BytesIO</code>将图像写入一个<code class="eh lr ls lt lu b">./images/</code>文件夹，我们将在我们的项目文件夹中创建这个文件夹。所以，为了把这些放在一起，我们需要发送一个<strong class="it hv"> HTTP GET请求</strong>到每张图片的URL，然后使用<code class="eh lr ls lt lu b">Image</code>和<code class="eh lr ls lt lu b">BytesIO</code>，我们将<strong class="it hv">存储我们在响应中得到的图片</strong>。有一种方法可以做到这一点:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ly lz l"/></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Downloading the images</figcaption></figure><p id="e4c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这几乎就是你下载一堆免费图片所需要的全部。显然，除非你想设计原型，你只是需要随机的图像，这个小刮刀没有多大用处。因此，我花了一些时间来改进它，增加了一些新功能:</p><ul class=""><li id="c610" class="lb lc hu it b iu iv iy iz jc mb jg mc jk md jo li lj lk ll dt translated">命令行参数允许用户指定一个<strong class="it hv">搜索查询</strong>，以及一个用于滚动的数值，这允许页面显示更多的图片供下载。</li><li id="ad94" class="lb lc hu it b iu lm iy ln jc lo jg lp jk lq jo li lj lk ll dt translated">可定制的CSS选择器。</li><li id="e01b" class="lb lc hu it b iu lm iy ln jc lo jg lp jk lq jo li lj lk ll dt translated">基于搜索查询定制的<strong class="it hv">结果文件夹</strong>。</li><li id="3d32" class="lb lc hu it b iu lm iy ln jc lo jg lp jk lq jo li lj lk ll dt translated">根据需要，通过裁剪缩略图的URL获得完整的<strong class="it hv">高清图像</strong>。</li><li id="e114" class="lb lc hu it b iu lm iy ln jc lo jg lp jk lq jo li lj lk ll dt translated">命名图像，基于它们的URL。</li><li id="aa42" class="lb lc hu it b iu lm iy ln jc lo jg lp jk lq jo li lj lk ll dt translated">在过程结束时关闭浏览器窗口。</li></ul><p id="5f55" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以(或许应该)尝试自己实现其中的一些特性。web scraper的全功能版本在<a class="ae jp" href="https://github.com/Chalarangelo/unscrape" rel="noopener ugc nofollow" target="_blank">这里</a>有售。记得单独下载<a class="ae jp" href="https://github.com/mozilla/geckodriver/releases/latest" rel="noopener ugc nofollow" target="_blank"> geckodriver </a>并将其连接到您的项目，如本文开头所述。</p></div><div class="ab cl me mf hc mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hn ho hp hq hr"><h2 id="ee51" class="kg kh hu bd ki kj kk kl km kn ko kp kq jc kr ks kt jg ku kv kw jk kx ky kz la dt translated">局限性、考虑因素和未来的改进</h2><p id="8c03" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lv je jf jg lw ji jj jk lx jm jn jo hn dt translated">这整个项目是一个非常简单的概念验证，看看网页抓取是如何完成的，这意味着有很多事情可以做，以改善这个小工具:</p><ul class=""><li id="7a95" class="lb lc hu it b iu iv iy iz jc mb jg mc jk md jo li lj lk ll dt translated">不承认图片的原始上传者是一个非常糟糕的主意。Selenium肯定能够解决这个问题，因此每张图片都带有作者的名字。</li><li id="002c" class="lb lc hu it b iu lm iy ln jc lo jg lp jk lq jo li lj lk ll dt translated">Geckodriver不应该放在项目文件夹中，而是全局安装，并且是系统变量<code class="eh lr ls lt lu b">PATH</code>的一部分。</li><li id="0eb6" class="lb lc hu it b iu lm iy ln jc lo jg lp jk lq jo li lj lk ll dt translated">搜索功能可以很容易地扩展到包括多个查询，这样就可以简化下载大量图像的过程。</li><li id="5eed" class="lb lc hu it b iu lm iy ln jc lo jg lp jk lq jo li lj lk ll dt translated">默认浏览器可以从Firefox改为Chrome，甚至是<a class="ae jp" href="http://phantomjs.org/" rel="noopener ugc nofollow" target="_blank"> PhantomJS </a>，这对这类项目来说会好得多。</li></ul></div></div>    
</body>
</html>