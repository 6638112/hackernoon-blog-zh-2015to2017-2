<html>
<head>
<title>Hosting Static React Websites on AWS S3 (&amp; CloudFront) with SSL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SSL在AWS S3 (&amp; CloudFront)上托管静态React网站</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/hosting-static-react-websites-on-aws-s3-cloudfront-with-ssl-924e5c134455?source=collection_archive---------2-----------------------#2017-10-28">https://medium.com/hackernoon/hosting-static-react-websites-on-aws-s3-cloudfront-with-ssl-924e5c134455?source=collection_archive---------2-----------------------#2017-10-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="2166" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">AWS S3 <code class="eh jp jq jr js b">Static Website Hosting</code>。它是廉价的、可扩展的和“高性能的”。尤其是当它用CloudFront标记团队时。</p><p id="f79c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个文档，以我的这个<a class="ae jt" href="https://www.bettercoverletter.com" rel="noopener ugc nofollow" target="_blank">宠物项目</a>为例，说明如何在AWS S3上使用SSL over CloudFront托管一个单页面应用程序(对于本例为React)。</p><figure class="jv jw jx jy fq jz fe ff paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="fe ff ju"><img src="../Images/62768b029141e6c125d0bdeaa0d244c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ruzgxradXfXiGOPiZO6mfQ.jpeg"/></div></div></figure><h1 id="8a6e" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">1)项目</h1><p id="64da" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">一个简单的静态网站，所以没有使用redux这个设置也适用于redux。因此，它将主要是反应和反应路由器。具体情况如下:</p><ul class=""><li id="ba17" class="lj lk hu it b iu iv iy iz jc ll jg lm jk ln jo lo lp lq lr dt translated">反应:^15.6.1</li><li id="6753" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">反应路由器:^4.1.2</li></ul><p id="c9ef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我用的捆扎机是<code class="eh jp jq jr js b">webpack: ^3.5.5</code>。</p><h1 id="c7d6" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">2) AWS S3</h1><p id="2e75" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">除了存储，S3还可以托管静态网站。</p><p id="751c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">请注意</strong>每个存储桶仅适用于1个网站，也就是说，您不能拥有一个名为<code class="eh jp jq jr js b">my-static-websites</code>的存储桶，并让每个目录托管1个网站。不。这将是每个网站每个桶。</p><p id="6aeb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为存储桶设置静态网站托管配置。记下<code class="eh jp jq jr js b">Endpoint</code>。</p><figure class="jv jw jx jy fq jz fe ff paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="fe ff lx"><img src="../Images/ef2bb1602227a49d7ace7b6da599e1db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KwSe3-Pb093XZKgpqcD5AQ.png"/></div></div></figure><p id="9cf6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个装置在说:</p><ul class=""><li id="e22f" class="lj lk hu it b iu iv iy iz jc ll jg lm jk ln jo lo lp lq lr dt translated">当用户访问我的网站的根路径时，向他们显示文件<code class="eh jp jq jr js b">index.html</code>。</li><li id="42c9" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">当用户访问一个不存在的页面时，在他们的浏览器上显示默认的S3错误信息。</li></ul><p id="518d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，当我们将react项目上传到bucket中时:</p><ul class=""><li id="954b" class="lj lk hu it b iu iv iy iz jc ll jg lm jk ln jo lo lp lq lr dt translated">在根路径上，用户可以看到网站正常运行！！！</li><li id="4d64" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">用户还可以导航到不同的路径！！！</li><li id="b151" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated"><strong class="it hv">但是</strong>当路径是<code class="eh jp jq jr js b">/something</code>而不是<code class="eh jp jq jr js b">/</code>时点击刷新会显示一个空白屏幕，或者<code class="eh jp jq jr js b">error.html</code>页面(如果已经设置好的话:((((</li></ul><p id="7ee9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">发生了什么事？嗯,<code class="eh jp jq jr js b">/something</code>路径正在S3桶中寻找文件<code class="eh jp jq jr js b">something.html</code>,但是没有找到。由于这是一个单页应用，所以只有1个html文件，1个神html文件。</p><p id="7de5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是挑战。</p><blockquote class="ly lz ma"><p id="670b" class="ir is mb it b iu iv iw ix iy iz ja jb mc jd je jf md jh ji jj me jl jm jn jo hn dt translated">我们需要将所有的路径映射到<code class="eh jp jq jr js b">index.html</code>文件。</p></blockquote><p id="c50b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于这是一个react项目，我们不需要像一个典型的网站那样将每个路径映射到一个特定的其他html页面；<code class="eh jp jq jr js b">index.html </code>将加载javascript包，react router将开始工作，根据路径向用户显示正确的页面。</p><p id="0941" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">卫生页</strong></p><p id="6d93" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不确定这是否是用于<code class="eh jp jq jr js b">sitemap.xml</code>和<code class="eh jp jq jr js b">robots.txt</code>文件的正确术语，但是是的，你将需要这些文件用于<a class="ae jt" href="https://yoast.com/ultimate-guide-robots-txt/" rel="noopener ugc nofollow" target="_blank"> SEO </a>。这些文件作为<code class="eh jp jq jr js b">index.html</code>文件的兄弟文件放在您的bucket的根目录中。最终，它们的url分别是<code class="eh jp jq jr js b">https://www.yourdomain.com/robots.txt</code>和<code class="eh jp jq jr js b">https://www.yourdomain.com/sitemap.xml</code>。</p><h1 id="3c7e" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">3a)自动气象站云锋—分布</h1><p id="9b8f" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">CloudFront是AWS的CDN，除了缓存站点之外，它还可以处理路由映射。</p><p id="97f4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先创建一个<strong class="it hv"> web </strong>发行版。我想提到的关键配置是:</p><ul class=""><li id="b83f" class="lj lk hu it b iu iv iy iz jc ll jg lm jk ln jo lo lp lq lr dt translated">Origin Domain Name —关注此字段后，将出现一个下拉列表，列出您的AWS S3中的所有存储桶。<strong class="it hv">不</strong>使用该列表中的任何选项。相反，输入前面提到的<em class="mb">静态网站托管使能的</em> S3桶的<code class="eh jp jq jr js b">Endpoint</code>的域。</li><li id="6dfb" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">查看器协议策略—选择<code class="eh jp jq jr js b">Redirect HTTP to HTTPS</code>以确保您的网站始终通过HTTPS被查看，并且没有公众可访问的HTTP协议下的重复实例。</li><li id="e6d7" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">基于所选请求头的缓存—选择<code class="eh jp jq jr js b">Whitelist</code>并添加到<code class="eh jp jq jr js b">Origin</code>头中。这是为了避免任何与CORS相关的错误。</li><li id="5f64" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">备用域名(CNAMEs) —在此输入非www和www域名，或您可能想要的任何其他子域，用换行符或逗号分隔。</li><li id="7202" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">ssl证书—选择<code class="eh jp jq jr js b">Custom SSL Certificate</code>并通过<code class="eh jp jq jr js b">Amazon Certificate Manager</code>上传您自己的SSL证书以及私钥和CA包。</li><li id="7455" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">自动压缩对象—选择<code class="eh jp jq jr js b">Yes</code>。CloudFront会自动压缩来自S3的未压缩文件，并根据谷歌标准提高页面速度。只需一个单选按钮就可以交换所有的深度apache/nginx/IIS设置——这就像<a class="ae jt" href="https://twitter.com/NoahElMas/status/899453545115734017/photo/1?ref_src=twsrc%5Etfw&amp;ref_url=http%3A%2F%2Fmashable.com%2F2017%2F08%2F20%2Fgame-of-thrones-season-7-viserion-dragon-drama%2F" rel="noopener ugc nofollow" target="_blank">用一个重量换一条龙</a>。</li></ul><p id="f42a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">创建CloudFront发行版，并等待它被部署。记下分布的<code class="eh jp jq jr js b">Domain Name</code> <strong class="it hv">。</strong></p><h1 id="cabf" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">3b) AWS CloudFront —错误页面</h1><p id="d683" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">创建CloudFront发行版后，当它的状态是<code class="eh jp jq jr js b">In Progress</code>时，进入<code class="eh jp jq jr js b">Error Pages</code>选项卡。用<code class="eh jp jq jr js b">Customize Error Response</code>处理响应代码404和403。</p><figure class="jv jw jx jy fq jz fe ff paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="fe ff mf"><img src="../Images/b87ccdd3e05aebf3d258339c4f55aea0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sGPZU9fRgndnsAo6mH0T8Q.png"/></div></div><figcaption class="mg mh fg fe ff mi mj bd b be z ek"><a class="ae jt" href="https://developers.google.com/speed/docs/insights/LeverageBrowserCaching" rel="noopener ugc nofollow" target="_blank">Google recommends</a> 1 week or 604800 seconds of caching.</figcaption></figure><p id="add9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们在这里所做的是设置CloudFront来处理缺失的html页面，这通常发生在用户输入无效路径时，尤其是当他们刷新根路径以外的路径时。</p><p id="ad6c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当这种情况发生时:</p><ol class=""><li id="2653" class="lj lk hu it b iu iv iy iz jc ll jg lm jk ln jo mk lp lq lr dt translated">CloudFront将寻找S3桶中不存在的文件；这个桶中只有一个html文件，这是像这个项目示例这样的单页面应用程序的<code class="eh jp jq jr js b">index.html</code></li><li id="3f6a" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo mk lp lq lr dt translated">将返回一个404响应，我们的自定义错误响应设置将劫持它。我们将返回200响应代码和<code class="eh jp jq jr js b">index.html</code>页面。</li><li id="496a" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo mk lp lq lr dt translated">React router将与index.html文件一起加载，它将查看url并呈现正确的页面，而不是根路径。在TTL期间，该页面将被缓存，以用于对所查询路径的所有请求。</li></ol><p id="e65d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为什么我们也需要处理403？这是因为亚马逊S3为不存在的资产返回了这个响应代码，而不是404。例如，<code class="eh jp jq jr js b">https://yourdomain.com/somewhere</code>的url将寻找一个不存在的名为<code class="eh jp jq jr js b">somewhere</code>(没有扩展名)的文件。</p><p id="63d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="mb"> PS。以前是回404，现在好像是回403；无论哪种方式，最好处理两个响应代码)。</em></p><h1 id="1004" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">4)域名系统</h1><p id="e1ea" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated"><a class="ae jt" href="http://www.yes-www.org/why-use-www/" rel="noopener ugc nofollow" target="_blank">我打算使用www版本的域名。</a></p><p id="2333" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">转到DNS区域文件并按此进行设置。</p><figure class="jv jw jx jy fq jz fe ff paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="fe ff ml"><img src="../Images/2dd94dc97c581be7bf481cbde12e690d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7oQ7M-MBkGbT_3pWjag4nA.png"/></div></div></figure><p id="9da6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该设置表明:</p><ol class=""><li id="6653" class="lj lk hu it b iu iv iy iz jc ll jg lm jk ln jo mk lp lq lr dt translated"><code class="eh jp jq jr js b">domain.com</code>将被重定向到<code class="eh jp jq jr js b">www.domain.com</code></li><li id="6c58" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo mk lp lq lr dt translated">如果有效，请求将被重写，从<code class="eh jp jq jr js b">http</code>到<code class="eh jp jq jr js b">https</code></li></ol><p id="1890" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我使用<a class="ae jt" href="https://www.namecheap.com" rel="noopener ugc nofollow" target="_blank">namecheap.com</a>作为我的DNS服务提供商，他们提供了在DNS级别将<code class="eh jp jq jr js b">https</code>或<code class="eh jp jq jr js b">http</code> <code class="eh jp jq jr js b">non-www</code>重定向到<code class="eh jp jq jr js b">https</code> <code class="eh jp jq jr js b">www</code>的选项。</p><p id="972f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">然而。</strong></p><p id="496e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您的DNS服务提供商不提供此功能，您可以使用AWS S3来执行重定向。用这些设置创建另一个桶。</p><figure class="jv jw jx jy fq jz fe ff paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="fe ff mm"><img src="../Images/739150387ac811a349046a5d5647b7ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m7BIJPQ_WU2JZQkTKmnSsw.png"/></div></div></figure><p id="3576" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">将根域的值DNS A记录设置为这个bucket的端点。</p><p id="9a81" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">将实现的是所有的<code class="eh jp jq jr js b">non-www</code>请求将被定向到这个桶。这个桶又将请求重定向到<code class="eh jp jq jr js b">www</code>域，该域指向文件所在的桶。是的，这将是一个<a class="ae jt" href="http://docs.aws.amazon.com/AmazonS3/latest/dev/how-to-page-redirect.html" rel="noopener ugc nofollow" target="_blank"> 301重定向</a>。如果你想知道，<a class="ae jt" href="https://moz.com/learn/seo/redirection" rel="noopener ugc nofollow" target="_blank">这就是301重定向的意义</a>。</p><p id="bae7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从<code class="eh jp jq jr js b">http</code>到<code class="eh jp jq jr js b">https</code>的转换将由之前设置的CloudFront配置(查看器协议策略)来处理。</p></div><div class="ab cl mn mo hc mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hn ho hp hq hr"><p id="f14e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此时，您应该能够像正常网站一样访问您的网站。在根路径以外的路径刷新也应该可以。</p><p id="f7b9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所有非https请求将在https协议下被重定向。</p><p id="87ea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所有非www请求也将在https协议下被重定向到www域。</p><p id="c111" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">机器人和爬虫应该可以像往常一样访问你的<code class="eh jp jq jr js b">robots.txt</code>和<code class="eh jp jq jr js b">sitemap.xml</code>文件。</p><h1 id="2104" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">5)结论</h1><p id="5a31" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated"><strong class="it hv">优点</strong></p><ul class=""><li id="c3b8" class="lj lk hu it b iu iv iy iz jc ll jg lm jk ln jo lo lp lq lr dt translated">财务友好。你基本上只为你使用的东西付费，所以你不会浪费一分钱在每月付费模式带来的未被充分利用的资源上。最重要的是，这种CloudFront和S3的结合也为你节省了一些钱，因为通过Cloudfront向互联网传输数据要比S3便宜得多。更不用说CDN更好的性能了。</li><li id="5545" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">可扩展性友好。如果你的网站变得非常受欢迎，也不会因为流量激增而出现可伸缩性问题，因为AWS CloudFront会帮你解决这个问题。没有必要与其他托管公司升级任何计划。</li><li id="b56b" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">性能友好。由于整个网站位于CDN之上，网站和资产的交付将会非常快。</li><li id="b4e2" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">DDoS不友好。由于该网站位于AWS CloudFront之后，针对DDoS 的<a class="ae jt" href="https://aws.amazon.com/answers/networking/aws-ddos-attack-mitigation/" rel="noopener ugc nofollow" target="_blank">攻击再次由CloudFront处理。亚马逊自己的技术可以防范DDoS攻击，相比其他托管公司，我更看好他们的网络安全技术和可靠性。</a></li><li id="fb26" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">安全友好——由于CloudFront现在正在处理SSL配置，您将看到您的域的SSL测试在<a class="ae jt" href="https://www.ssllabs.com/ssltest/" rel="noopener ugc nofollow" target="_blank"> SSLLabs </a>上是A级。</li></ul><p id="bfb1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">缺点</strong></p><ul class=""><li id="73cb" class="lj lk hu it b iu iv iy iz jc ll jg lm jk ln jo lo lp lq lr dt translated">这只适用于静态网站。即使大幅降低一个静态网站的速度，也需要巨大的流量。典型应用程序中的大多数瓶颈是当它与涉及逻辑计算和数据库查询的后端交互时。</li><li id="352a" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">由于网站缓存在CDN上，任何更改都不会立即看到，必须等到缓存过期。这是任何缓存机制都会有的。我们可以通过使缓存无效来减轻这一问题(这将产生费用)。如果您的javascript文件名是散列的，那么您可以忽略javascript文件，只需要使<code class="eh jp jq jr js b">index.html</code>文件无效。或者，您可以只给<em class="mb">和<code class="eh jp jq jr js b">index.html</code>文件</em>一个较短的缓存周期。</li><li id="d337" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">每一个页面应用程序的缺陷都是服务器端渲染的需求。除了<em class="mb"> Googlebot </em>之外，机器人和爬虫无法获取网站的元数据，因为它们不允许javascript执行。因此，如果你的网站只关注谷歌搜索引擎优化，这个设置是好的。但是如果你依赖于其他搜索引擎，或者你通过像脸书这样的社交媒体营销网站，这就不理想了。(TODO使用API网关和Lambda提供html页面)</li><li id="a055" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">由于所有404和403响应都被劫持为返回200，如果您在谷歌搜索控制台(GSC)上索引了您的网站，您可能不会收到任何404错误。这些由GSC提供的404报告可以告诉你哪些页面有错误，并通知你。没有它们，你就不知道哪些页面关闭了，或者是否有链接到网站其他部分的断开的链接。</li></ul></div><div class="ab cl mn mo hc mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hn ho hp hq hr"><h1 id="9fbc" class="kg kh hu bd ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld dt translated">支线任务</h1><p id="46aa" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">在本文的这一节中，我将介绍如何在这样的设置中仅从命令行自动完成这样一个站点的部署过程。</p><h1 id="3732" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">1) AWS IAM</h1><p id="9887" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">首先，您需要创建一个IAM用户，并授予其必要的S3权限。</p><figure class="jv jw jx jy fq jz fe ff paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="fe ff mz"><img src="../Images/c7a756400fc628cd931dc0791eeaf364.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gd2HEpFSLCNkpDJ0QU8MqQ.png"/></div></div></figure><p id="ceca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意<code class="eh jp jq jr js b">access key id</code>和<code class="eh jp jq jr js b">secret access key</code>，以及<code class="eh jp jq jr js b">User ARN</code>。</p><p id="8c2f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">IAM用户是您的AWS帐户中的访问控制配置，主要是回答谁可以在您的帐户下对哪些服务做什么的问题。</p><p id="652f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们姑且称这个用户为<code class="eh jp jq jr js b">iam_user</code>。</p><h1 id="e692" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated"><strong class="ak"> 2) AWS S3 </strong></h1><p id="0e6b" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">更改存储桶策略以允许此<code class="eh jp jq jr js b">iam_user</code>对存储桶进行更改。</p><pre class="jv jw jx jy fq na js nb nc aw nd dt"><span id="e981" class="ne kh hu js b fv nf ng l nh ni">{<br/>    "Version": "2012-10-17",<br/>    "Id": "someID",<br/>    "Statement": [<br/>        {<br/>            "Effect": "Allow",<br/>            "Principal": {<br/>                "AWS": "arn:aws:iam::123456789:user/iam_user"<br/>            },<br/>            "Action": "s3:*",<br/>            "Resource": "arn:aws:s3:::bucket-name"<br/>        }<br/>    ]<br/>}</span></pre><h1 id="256f" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">3)部署</h1><p id="f24a" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">由于这是一个简单的、大部分是静态的网站，因此没有为部署过程设置测试脚本或任何CI服务器。使用<a class="ae jt" href="http://docs.aws.amazon.com/cli/latest/userguide/cli-install-macos.html#awscli-install-osx-path" rel="noopener ugc nofollow" target="_blank"> AWS CLI </a>将新文件上传到S3的正确存储桶将是一项简单的任务。</p><p id="b7db" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">清理</strong></p><p id="ddbc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是在上传之前，请确保清理了为生产环境构建文件的分发文件夹。由于我使用<a class="ae jt" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> webpack </a>作为我的捆绑器，我利用<a class="ae jt" href="https://github.com/johnagan/clean-webpack-plugin" rel="noopener ugc nofollow" target="_blank"> clean-webpack-plugin </a>来帮助我在建立新文件之前处理旧文件。这是为了防止将相同的旧资产再次上传到存储桶。</p><pre class="jv jw jx jy fq na js nb nc aw nd dt"><span id="359c" class="ne kh hu js b fv nf ng l nh ni"># webpack.config</span><span id="4fd7" class="ne kh hu js b fv nj ng l nh ni">const CleanWebpackPlugin = require('clean-webpack-plugin')<br/>const HtmlWebpackPlugin = require('html-webpack-plugin')<br/>const pathsToClean = ["dist"]<br/>const cleanOptions = {}</span><span id="ec4c" class="ne kh hu js b fv nj ng l nh ni">...</span><span id="397e" class="ne kh hu js b fv nj ng l nh ni">output: {<br/>  path: path.resolve(__dirname, "dist", "assets"), // all files are bundled into the dist/assets sub-directory<br/>  publicPath: '/assets/',<br/>  filename: 'bundle.js'<br/>},</span><span id="1abf" class="ne kh hu js b fv nj ng l nh ni">...</span><span id="123b" class="ne kh hu js b fv nj ng l nh ni">plugins: [<br/>  ...,<br/>  new CleanWebpackPlugin(pathsToClean, cleanOptions), // cleanup the whole "dist" folder<br/>  new HtmlWebpackPlugin({<br/>    template: "./src/index.production.html",<br/>    filename: "../index.html" // all files are bundled into the dist/assets sub-directory, but index.html will be placed 1 directory up in the dist directory itself<br/>  }),</span><span id="8f97" class="ne kh hu js b fv nj ng l nh ni">  ...<br/>]</span></pre><p id="9d95" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">上传</strong></p><p id="3f0a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在把文件上传到S3。</p><p id="5ea8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了防止任何汤姆迪克和哈利能够这样做，认证是必需的。这就是我的所有工作发挥作用的地方。</p><p id="d298" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将使用一个脚本来完成上传，并使用自定义配置来验证请求。</p><p id="6cc1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在实际上传之前，您可以使用<code class="eh jp jq jr js b">--dryrun</code>标志来测试您的脚本。这是我剧本的最终版本。</p><pre class="jv jw jx jy fq na js nb nc aw nd dt"><span id="7814" class="ne kh hu js b fv nf ng l nh ni">aws s3 cp ./dist s3://better-cover-letter  --recursive --exclude "*.DS_Store" --acl public-read --cache-control public,max-age=604800 --dryrun --profile iam_user</span></pre><p id="a529" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jp jq jr js b">--exclude</code>标志是为了防止在macOS中上传恼人的、一直存在的<code class="eh jp jq jr js b">.DS_Store</code>文件。</p><p id="e1a8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jp jq jr js b">--acl</code>标志将设置文件的访问控制级别。让它对公众可读，这样人们就可以访问你的网站，否则他们会被一条<code class="eh jp jq jr js b">403 Forbidden</code>消息扇耳光。</p><p id="680a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当Cloudfront调用S3对象时,<code class="eh jp jq jr js b">--cache-control</code>标志将缓存控制头添加到这些对象中。这些缓存控制头将被传递给浏览器，以便<a class="ae jt" href="https://developers.google.com/speed/docs/insights/LeverageBrowserCaching" rel="noopener ugc nofollow" target="_blank">利用浏览器缓存</a>，从而提高页面速度。604800是以秒为单位的1周，所以这个<code class="eh jp jq jr js b">max-age</code>值将缓存这些资产一周。</p><blockquote class="ly lz ma"><p id="3444" class="ir is mb it b iu iv iw ix iy iz ja jb mc jd je jf md jh ji jj me jl jm jn jo hn dt translated">[Google]建议静态资产或不经常改变的资产的最小缓存时间为一周，最好是一年</p></blockquote><p id="2874" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jp jq jr js b">--profile</code>标志用于设置特定的IAM用户凭证来验证该操作。由于我在工作和个人项目中使用同一台macbook pro，我有多个AWS帐户要处理，因此需要此标志来区分不同的I am用户。查看<a class="ae jt" href="http://docs.aws.amazon.com/cli/latest/userguide/cli-multiple-profiles.html" rel="noopener ugc nofollow" target="_blank"> AWS CLI命名配置文件</a>了解更多信息。这些是我的配置和凭证文件，供您参考。</p><pre class="jv jw jx jy fq na js nb nc aw nd dt"><span id="f06b" class="ne kh hu js b fv nf ng l nh ni"># ~/.aws/config<br/>[default]<br/>region=us-west-2<br/>output=text</span><span id="cbee" class="ne kh hu js b fv nj ng l nh ni"># ~/.aws/credentials<br/>[iam_user]<br/>aws_access_key_id=something<br/>aws_secret_access_key=something</span><span id="7382" class="ne kh hu js b fv nj ng l nh ni">[company_user]<br/>aws_access_key_id=something_else<br/>aws_secret_access_key=something_else</span></pre><p id="f9cb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jp jq jr js b">aws_access_key_id</code>和<code class="eh jp jq jr js b">aws_secret_access_key</code>是特定于被创建的<code class="eh jp jq jr js b">iam_user</code>的。</p><p id="0551" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦您准备好了，您就可以移除<code class="eh jp jq jr js b">--dryrun</code>标志并进行测试运行，以确保您的文件确实上传到了正确的bucket。是的，一个<strong class="it hv">测试</strong>运行。这不是部署步骤的结束。我们可以更进一步，使整个过程完全自动化。</p><p id="31c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">注意</strong> : AWS S3不对桶内的数据传输收费，只对桶外的数据传输收费。所以请随意部署垃圾邮件。(事实上，S3不向Cloudfront收取数据传输费用。)</p><p id="d1a2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">合并步骤</strong></p><p id="c608" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们必须首先使用<code class="eh jp jq jr js b">webpack -p — config webpack.config.js</code>生成文件来构建我们的站点，然后使用<code class="eh jp jq jr js b">aws s3 cp</code>命令上传文件。</p><p id="ebf7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了让我们的生活更美好，我们可以创建一个新的脚本命令来一个接一个地运行这些命令，而不需要我们在那里等待第一个命令完成，然后手动执行另一个命令。</p><pre class="jv jw jx jy fq na js nb nc aw nd dt"><span id="903e" class="ne kh hu js b fv nf ng l nh ni"># package.json</span><span id="ddf0" class="ne kh hu js b fv nj ng l nh ni">...<br/>"scripts": {<br/>  ...<br/>  "deploy": "webpack -p --config webpack.config.prod.js &amp;&amp; aws s3 cp ./dist s3://better-cover-letter  --recursive --exclude "*.DS_Store" --cache-control public,max-age=604800 --dryrun --profile iam_user"<br/>  ...<br/>}</span></pre><p id="538b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以只要运行<code class="eh jp jq jr js b">npm run deploy</code>这些就会按时间顺序发生。</p><ul class=""><li id="9f8a" class="lj lk hu it b iu iv iy iz jc ll jg lm jk ln jo lo lp lq lr dt translated">旧的生产文件由clean-webpack-plugin清理</li><li id="969b" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">新的生产文件被编译到<code class="eh jp jq jr js b">dist</code>文件夹中(基于我的webpack配置文件)</li><li id="64d5" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">生产文件然后被上传到S3，一旦AWS Cloudfront CDN中的缓存过期，就可以随时访问。</li></ul><p id="7408" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是上传静态网站的全自动流程。</p><h1 id="0777" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">更多内务管理(可选)</h1><p id="5be2" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">如果你像我一样用一个散列捆绑你的javascript文件，你会发现你的S3桶与旧的js文件累积在一起，而不是被新的js文件取代，因为它们是不同的文件，因为它们的文件名中有散列，例如<code class="eh jp jq jr js b">bundle-0af19d01880334b789.js</code>。如果你只是上传<code class="eh jp jq jr js b">bundle.js</code>，它将替换桶中的任何<code class="eh jp jq jr js b">bundle.js</code>，就没有那么多了。</p><p id="4dd3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于在S3存储文件不是免费的，尽管也不是很贵，所以删除你永远不会再使用的文件仍然是明智的。</p><p id="ce13" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，我们可以在上传之前再次使用AWS CLI删除这些旧的js文件(注意:我保留bucket根目录中的文件不变，只是清理了<code class="eh jp jq jr js b">assets</code>文件夹)。</p><pre class="jv jw jx jy fq na js nb nc aw nd dt"><span id="3566" class="ne kh hu js b fv nf ng l nh ni">aws s3 rm s3://better-cover-letter/assets --recursive --profile iam_user --dryrun</span></pre><p id="849c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样，在部署脚本中组合它们。</p></div></div>    
</body>
</html>