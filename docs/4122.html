<html>
<head>
<title>Function Type Signatures in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript中的函数类型签名</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/function-type-signatures-in-javascript-5c698c1e9801?source=collection_archive---------2-----------------------#2017-05-14">https://medium.com/hackernoon/function-type-signatures-in-javascript-5c698c1e9801?source=collection_archive---------2-----------------------#2017-05-14</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/c5170818244bdfe73b196840dfc9b9ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wh9B3SwVwDm0bVSB3A4MFw.png"/></div></div></figure><p id="fdaf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当一个Javascript开发人员开始探索函数式编程的最深层秘密时，他经常会发现这些奇怪的<em class="ka">箭头符号，上面写着类型</em>，然后感觉<em class="ka">‘这到底是什么？’</em>。毕竟，他是动态类型化Javascript的大师，摆脱了类型的界限。</p><p id="3847" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些类型符号是一种叫做<strong class="je hv">类型签名</strong>的元语言，它讲述了很多关于纯函数的事情，并且在函数式编程中的重要性<em class="ka">远远超出了我们最初的预期</em>。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff kb"><img src="../Images/a283951efdc63183a246ae1c5ca502da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*8zKb9lvzV7n-DBIg8rBvzg.png"/></div><figcaption class="kg kh fg fe ff ki kj bd b be z ek">Screenshot from <a class="ae kk" href="http://ramdajs.com/docs/" rel="noopener ugc nofollow" target="_blank">http://ramdajs.com/docs/</a></figcaption></figure><p id="3532" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">让我们看看这些类型签名是什么，以及为什么我们应该在代码中使用它们。</em></p><blockquote class="kl km kn"><p id="21bc" class="jc jd ka je b jf jg jh ji jj jk jl jm ko jo jp jq kp js jt ju kq jw jx jy jz hn dt translated">类型签名定义函数的输入和输出，有时包括参数的数量、参数的类型以及函数包含的参数的顺序。</p></blockquote><p id="98d8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些类型签名是写在纯函数之上的高度表达的语句，用于推断它的工作。</p><p id="4bec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">类型签名基于作为标准类型系统的<a class="ae kk" href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system" rel="noopener ugc nofollow" target="_blank"> Hindley-Milner </a>类型系统，这也是受<a class="ae kk" href="https://en.wikipedia.org/wiki/ML_(programming_language)" rel="noopener ugc nofollow" target="_blank"> ML </a>影响的语言所遵循的，包括Haskell。</p><p id="82b3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些语句通过<strong class="je hv">形式化</strong>类型推断算法<em class="ka">(Haskell通常使用)</em>中的函数表达式达到了更大的目的，但是现在我们将使用它们来更好地记录我们的Javascript代码，并从中推导出<strong class="je hv">自由定理</strong>。</p><p id="9d67" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您发现任何用这些类型签名记录的纯函数，解码它们的能力将让您提前了解该函数的工作方式。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff kr"><img src="../Images/f452a7b5bf58972a98fbc8da95c2518d.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*owhYyEq_wSRyPN_OuyQXPQ.gif"/></div><figcaption class="kg kh fg fe ff ki kj bd b be z ek">Just like He-man</figcaption></figure><p id="b828" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将把类型签名定义为函数上方的注释。使用函数时还可以使用<a class="ae kk" href="https://flow.org/" rel="noopener ugc nofollow" target="_blank"> <em class="ka">流</em> </a>来推断类型。要开始心流，你可以跟随这个，</p><div class="ks kt fm fo ku kv"><a rel="noopener follow" target="_blank" href="/@lunasunkaiser/type-checking-with-flow-4db5ef9b3095"><div class="kw ab ej"><div class="kx ab ky cl cj kz"><h2 class="bd hv fv z el la eo ep lb er et ht dt translated">使用流程进行类型检查</h2><div class="lc l"><h3 class="bd b fv z el la eo ep lb er et ek translated">JavaScript可能是快速的、富于表现力的、轻量级的、功能性的、令人敬畏的编程语言，有一个巨大的社区…</h3></div><div class="ld l"><p class="bd b gc z el la eo ep lb er et ek translated">medium.com</p></div></div><div class="le l"><div class="lf l lg lh li le lj ja kv"/></div></div></a></div><h1 id="9564" class="lk ll hu bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh dt translated">简单功能</h1><pre class="kc kd ke kf fq mi mj mk ml aw mm dt"><span id="9d8c" class="mn ll hu mj b fv mo mp l mq mr">// length :: String → Number<br/>const length = s =&gt; s.length;</span></pre><p id="d99a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以上面的函数接受一个字符串并返回一个数字。如果我们仔细观察，我们可以看到</p><pre class="kc kd ke kf fq mi mj mk ml aw mm dt"><span id="0168" class="mn ll hu mj b fv mo mp l mq mr">1. The function name is written first followed by `::`.</span><span id="be23" class="mn ll hu mj b fv ms mp l mq mr">2. The input type of the function is written before the arrow.</span><span id="9793" class="mn ll hu mj b fv ms mp l mq mr">3. The return type of the function is written after the arrow or at last.</span></pre><p id="ac63" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">记住，只写输入和输出的类型，这样就可以读成<strong class="je hv"> <em class="ka">“一个从字符串到数字的函数长度”。</em> </strong></p><p id="118a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上述长度函数也可以写成</p><pre class="kc kd ke kf fq mi mj mk ml aw mm dt"><span id="3930" class="mn ll hu mj b fv mo mp l mq mr">// length :: [Number] → Number<br/>const length = arr =&gt; arr.length</span></pre><p id="08ee" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">只要实用，函数有多种类型签名是正常的，如果函数的参数类型过于灵活，那么我们应该使用<strong class="je hv"><em class="ka">HM-任意变量</em> </strong>，我们稍后将讨论它们。</p><h2 id="b5b7" class="mn ll hu bd lm mt mu mv lq mw mx my lu jn mz na ly jr nb nc mc jv nd ne mg nf dt translated">多参数</h2><p id="3300" class="pw-post-body-paragraph jc jd hu je b jf ng jh ji jj nh jl jm jn ni jp jq jr nj jt ju jv nk jx jy jz hn dt translated">在Javascript中，我们可以有带许多参数的函数，不像其他FP语言，让这些函数一次只带一个参数是一个好习惯。但是，如果我们仍然想在函数中使用多个参数，我们可以这样做。</p><pre class="kc kd ke kf fq mi mj mk ml aw mm dt"><span id="b10d" class="mn ll hu mj b fv mo mp l mq mr">// join :: (String, [String]) → String<br/>const join = (separator, arr) =&gt; arr.join(separator)</span></pre><h1 id="0460" class="lk ll hu bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh dt translated">高阶函数</h1><p id="4a21" class="pw-post-body-paragraph jc jd hu je b jf ng jh ji jj nh jl jm jn ni jp jq jr nj jt ju jv nk jx jy jz hn dt translated">如果我们没有函数来处理函数，那就不是函数式编程。</p><pre class="kc kd ke kf fq mi mj mk ml aw mm dt"><span id="f396" class="mn ll hu mj b fv mo mp l mq mr">// addOneToAll :: ((Number → Number),[Number]) → [Number]</span><span id="d695" class="mn ll hu mj b fv ms mp l mq mr">const addOneToAll = (addOne = x=&gt;x+1 , arr) =&gt; arr.map(addOne)</span></pre><p id="ecc1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当一个函数作为参数传递时，我们把它的签名放在一个括号中，以表示一个更有意义的整体类型签名。</p><p id="8899" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面的函数是一个'<em class="ka"> map </em>函数，不是每次这个函数都作用于定义的数据类型，基本上可以作用于任何类型的数组。所以为了描述这种函数，我们需要一些别的东西。</p><h1 id="5d25" class="lk ll hu bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh dt translated">辛德雷-米尔纳任意变量</h1><p id="fe45" class="pw-post-body-paragraph jc jd hu je b jf ng jh ji jj nh jl jm jn ni jp jq jr nj jt ju jv nk jx jy jz hn dt translated"><em class="ka">像identity、map、filter和reduce这样的函数接受的参数过于灵活，无法由特定类型定义，因此我们使用经典的Hindley-Milner变量</em> <code class="eh nl nm nn mj b"><em class="ka">a</em></code> <em class="ka">和</em> <code class="eh nl nm nn mj b"><em class="ka">b</em></code> <em class="ka">。</em></p><pre class="kc kd ke kf fq mi mj mk ml aw mm dt"><span id="2b3d" class="mn ll hu mj b fv mo mp l mq mr">// identity :: a → a<br/>const identity = a =&gt; a</span></pre><p id="630b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为对于相同的输入类型，identity总是给我们相同的输出类型。因此，我们用<code class="eh nl nm nn mj b">a → a</code>来代表它的签名。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff no"><img src="../Images/b9f225c4b565be0f5ffe082183a3e1fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/1*rtTpcLzjHB-TfCdnwZPtIA.gif"/></div><figcaption class="kg kh fg fe ff ki kj bd b be z ek">I know!</figcaption></figure><p id="89fc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的长度函数也可以写成</p><pre class="kc kd ke kf fq mi mj mk ml aw mm dt"><span id="4be4" class="mn ll hu mj b fv mo mp l mq mr">// length :: [a] → Number<br/>const length = arr =&gt; arr.length</span></pre><p id="455d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">同样的，</p><pre class="kc kd ke kf fq mi mj mk ml aw mm dt"><span id="7f6b" class="mn ll hu mj b fv mo mp l mq mr">// head :: [a] → a<br/>const head = arr =&gt; arr[0]</span></pre><h1 id="3683" class="lk ll hu bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh dt translated">Thunks或Curried函数</h1><p id="5988" class="pw-post-body-paragraph jc jd hu je b jf ng jh ji jj nh jl jm jn ni jp jq jr nj jt ju jv nk jx jy jz hn dt translated"><em class="ka">最纯粹的纯函数的类型签名</em> ✨</p><p id="b36d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于一个接受多个参数的函数来说，处理它们总是一个好的选择，这样它们就可以在我们代码的后面被组合。此外，在带有多个参数的函数中使用任意的HM变量也不是一个好的做法。</p><p id="8b76" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你对<a class="ae kk" href="https://hackernoon.com/partial-application-of-functions-dbe7d9b80760" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> <em class="ka">我们为什么要curry我们的函数</em> </strong> </a>感到好奇，请通过这个，</p><div class="ks kt fm fo ku kv"><a href="https://hackernoon.com/partial-application-of-functions-dbe7d9b80760" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab ej"><div class="kx ab ky cl cj kz"><h2 class="bd hv fv z el la eo ep lb er et ht dt translated">函数的部分应用</h2><div class="lc l"><h3 class="bd b fv z el la eo ep lb er et ek translated">为函数提供比预期更少的参数称为函数的部分应用。</h3></div><div class="ld l"><p class="bd b gc z el la eo ep lb er et ek translated">hackernoon.com</p></div></div><div class="le l"><div class="np l lg lh li le lj ja kv"/></div></div></a></div><pre class="kc kd ke kf fq mi mj mk ml aw mm dt"><span id="a42c" class="mn ll hu mj b fv mo mp l mq mr">// map :: (a → b) → [a] → [b]<br/>const map = fn =&gt; arr =&gt; arr.map(fn)</span></pre><p id="d663" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个标准的映射函数将具有上述类型的签名。但是，很多时候，映射也可以由这种类型的签名来定义</p><pre class="kc kd ke kf fq mi mj mk ml aw mm dt"><span id="0747" class="mn ll hu mj b fv mo mp l mq mr">map :: [a] → [b]</span></pre><p id="3511" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有时我们知道map返回的数组的类型，就像这样。</p><pre class="kc kd ke kf fq mi mj mk ml aw mm dt"><span id="0686" class="mn ll hu mj b fv mo mp l mq mr">// allToString :: [a] → [String]<br/>const allToString = arr =&gt; arr.map(toString)</span></pre><p id="0b52" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看看标准滤波器和reduce</p><pre class="kc kd ke kf fq mi mj mk ml aw mm dt"><span id="08b0" class="mn ll hu mj b fv mo mp l mq mr">// filter :: (a → bool) → [a] → [a]<br/>const filter = fn =&gt; arr =&gt; arr.filter(fn)</span><span id="1b12" class="mn ll hu mj b fv ms mp l mq mr">// reduce :: <!-- -->(b <!-- -->→ <!-- -->a <!-- -->→ <!-- -->b) <!-- -->→ <!-- -->b <!-- -->→ <!-- -->[a] <!-- -->→ <!-- -->b<br/>const reduce = fn =&gt; init =&gt; arr =&gt; arr.reduce(fn, init)</span></pre><p id="e6f7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">显然，reduce函数的类型签名有点复杂，如果我们能理解如何编写reduce函数的类型签名，我们就能为几乎任何函数编写类型签名。</p><p id="161d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">好的，所以reduce的第一个参数是一个<strong class="je hv"> <em class="ka"> reducing函数</em> </strong>，它使用<code class="eh nl nm nn mj b">b</code>和<code class="eh nl nm nn mj b">a</code>给出<code class="eh nl nm nn mj b">b</code>，这意味着这个函数将把所有东西都归约为类型<code class="eh nl nm nn mj b">b</code>，所以从<em class="ka"> reduce() </em>获得的最终值和提供的初始值将是<code class="eh nl nm nn mj b">b</code>类型。并且由于类型<code class="eh nl nm nn mj b">a</code>列表中的每个单个值都将被馈送到这个<strong class="je hv"><em class="ka"/></strong>归约函数，所以<strong class="je hv"> <em class="ka">归约函数</em> </strong>的第二个参数必须是<code class="eh nl nm nn mj b">a</code>类型，它就是这样。因此，<em class="ka"> reduce() </em>的类型签名是正当的。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff nq"><img src="../Images/52c0cb7ecbd329bd8d64863660c10278.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/1*5hga1wM83BuntHIvfwZyAw.gif"/></div></figure><h1 id="e086" class="lk ll hu bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh dt translated">自由定理</h1><p id="322c" class="pw-post-body-paragraph jc jd hu je b jf ng jh ji jj nh jl jm jn ni jp jq jr nj jt ju jv nk jx jy jz hn dt translated">这些签名的另一个用途是产生<em class="ka">自由定理。当我们处理纯函数的<strong class="je hv">组合时，这些定理非常有用，因为它们帮助我们优化和重构代码。</strong></em></p><pre class="kc kd ke kf fq mi mj mk ml aw mm dt"><span id="a734" class="mn ll hu mj b fv mo mp l mq mr">// Type signature of head says<br/>// head :: [a] → a</span><span id="b708" class="mn ll hu mj b fv ms mp l mq mr">compose(map(fn), head) == compose(head, fn)</span></pre><p id="74de" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是我们的第一个自由定理，仅来源于head和map函数的类型签名，其陈述</p><p id="8a6a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们对每个元素使用函数<code class="eh nl nm nn mj b">map</code>，然后对结果数组使用函数<code class="eh nl nm nn mj b">head</code>，那么这就相当于对数组的<code class="eh nl nm nn mj b">head</code>使用函数<code class="eh nl nm nn mj b">fn</code>。</p><p id="4d62" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们证明这个定理</p><pre class="kc kd ke kf fq mi mj mk ml aw mm dt"><span id="2702" class="mn ll hu mj b fv mo mp l mq mr">compose(map(fn), head) == compose(head, fn)</span><span id="e331" class="mn ll hu mj b fv ms mp l mq mr"><em class="ka">--Converting to Type Signatures--</em></span><span id="f76b" class="mn ll hu mj b fv ms mp l mq mr">[a] → [b] → b == [a] → a → b</span><span id="f636" class="mn ll hu mj b fv ms mp l mq mr"><em class="ka">-- Removing Intermediates --</em></span><span id="7edd" class="mn ll hu mj b fv ms mp l mq mr">[a] → b == [a] → b</span></pre><p id="b06f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于两个函数的总体类型签名是相同的，我们可以得出结论，对于相同的输入，两个组合将返回相同的结果。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff nr"><img src="../Images/0e43d03b3e40ca9a275464e7ed87bd57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*2yxW4P0pYnIlxew9FRrErg.gif"/></div></figure><p id="8ad5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面的推导被简化了，因为它需要Lambda Calculas来进行自由定理的实际推导，这不在本文的范围之内。</p><p id="108f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你想更深入地研究，你可以一直浏览瓦德勒关于自由定理的论文。</p><p id="c633" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，这里使用的Compose函数实际上与惯用的Compose相反。更多信息<a class="ae kk" href="https://github.com/rajatsharma305/compose-r#compose-r" rel="noopener ugc nofollow" target="_blank">点击这里</a>。</p></div><div class="ab cl ns nt hc nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="hn ho hp hq hr"><p id="9d62" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">解密和使用类型签名的能力不仅在Javascript中有用，在其他FP语言中也很有用，所以如果我们需要借用Javascript的任何纯函数，我们只需引用它的类型签名，我们就知道在代码中的什么地方放置该函数。</p><p id="ff65" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">感谢阅读</p><p id="3460" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">用...书写💖</p><div class="kc kd ke kf fq ab cb"><figure class="nz iv oa ob oc od oe paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nz iv oa ob oc od oe paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nz iv oa ob oc od oe paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="kl km kn"><p id="f922" class="jc jd ka je b jf jg jh ji jj jk jl jm ko jo jp jq kp js jt ju kq jw jx jy jz hn dt translated"><a class="ae kk" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kk" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kk" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae kk" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd ka je b jf jg jh ji jj jk jl jm ko jo jp jq kp js jt ju kq jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kk" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kk" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff of"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>