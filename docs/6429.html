<html>
<head>
<title>One-Shot Learning of C++ rvalue, &amp;&amp;, and Move</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一次性学习C++右值、&amp;&amp;和移动</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/one-shot-learning-of-c-r-value-and-move-27e5d6bcec3b?source=collection_archive---------8-----------------------#2017-09-18">https://medium.com/hackernoon/one-shot-learning-of-c-r-value-and-move-27e5d6bcec3b?source=collection_archive---------8-----------------------#2017-09-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/1888ccc73e32a8b92fbf044ce494d94f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TFH_2_NIlIPD6Gex0ijlew.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/vmvlzJz1lHg?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Sean McAuliffe</a> on <a class="ae jg" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="jh ji jj"><p id="30e8" class="jk jl jm jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">C++很难，新版本变得更难。本文将讨论C++中的一些难点，右值、右值引用(<code class="eh kj kk kl km b"><strong class="jn hv">&amp;&amp;</strong></code>)和移动语义。我将对这些复杂且相关的主题进行逆向工程(不是比喻)，这样你就可以一步到位地完全理解它们。</p></blockquote><p id="f445" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">首先，让我们检查</p><h1 id="c0c9" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">什么是右值？</h1><p id="ec80" class="pw-post-body-paragraph jk jl hu jn b jo lo jq jr js lp ju jv kn lq jy jz ko lr kc kd kp ls kg kh ki hn dt translated">一个<strong class="jn hv"> <em class="jm"> r </em> </strong>值应该在等号的右边。</p><p id="e91e" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated"><strong class="jn hv">举例:</strong></p><pre class="lt lu lv lw fq lx km ly lz aw ma dt"><span id="df5e" class="mb kr hu km b fv mc md l me mf">int <strong class="km hv">var</strong>; // too much JavaScript recently:)<br/><strong class="km hv">var</strong> = 8; <em class="jm">// OK! lvalue (yes, there is a lvalue) on the left</em><br/><br/>8 = <strong class="km hv">var</strong>; <em class="jm">// ERROR! rvalue on the left</em><br/>(<strong class="km hv">var</strong> + 1) = 8; <em class="jm">// ERROR! rvalue on the left</em></span></pre><p id="b21e" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">很简单。那么让我们来看一个更微妙的情况，函数返回的一个<strong class="jn hv"> <em class="jm"> r </em> </strong>值:</p><pre class="lt lu lv lw fq lx km ly lz aw ma dt"><span id="1f08" class="mb kr hu km b fv mc md l me mf">#include &lt;string&gt;<br/>#include &lt;stdio.h&gt;<br/><br/>int g_var = 8;<br/>int&amp; returnALvalue() {<br/>   <strong class="km hv">return</strong> g_var; <em class="jm">//here we return a lvalue</em><br/>}<br/><br/>int returnARvalue() {<br/>   <strong class="km hv">return</strong> g_var; <em class="jm">//here we return a rvalue</em><br/>}<br/><br/>int main() {<br/>   printf("%d", returnALvalue()++); <em class="jm">// g_var += 1;</em><br/>   printf("%d", returnARvalue());<br/>}</span></pre><p id="ed94" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated"><strong class="jn hv">结果:</strong></p><pre class="lt lu lv lw fq lx km ly lz aw ma dt"><span id="d8df" class="mb kr hu km b fv mc md l me mf">8<br/>9</span></pre><p id="ca5f" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">值得注意的是，返回一个<a class="ae jg" href="https://hackernoon.com/tagged/lavalue" rel="noopener ugc nofollow" target="_blank">左值</a>(在示例中)的方式被认为是一种不好的做法。所以不要在现实世界编程中这样做。</p><h1 id="cbbb" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">超出理论水平</h1><p id="a04b" class="pw-post-body-paragraph jk jl hu jn b jo lo jq jr js lp ju jv kn lq jy jz ko lr kc kd kp ls kg kh ki hn dt translated">一个变量是否是一个<strong class="jn hv"> r </strong>值甚至在<code class="eh kj kk kl km b"><strong class="jn hv">&amp;&amp;</strong></code>发明之前就能在实际编程中产生差异。</p><p id="14e5" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">例如，这一行</p><pre class="lt lu lv lw fq lx km ly lz aw ma dt"><span id="a0e1" class="mb kr hu km b fv mc md l me mf"><strong class="km hv">const</strong> int&amp; var = 8;</span></pre><p id="7459" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">可以很好地编译，而这:</p><pre class="lt lu lv lw fq lx km ly lz aw ma dt"><span id="6782" class="mb kr hu km b fv mc md l me mf">int&amp; var = 8; <em class="jm">// use a lvalue reference for a rvalue</em></span></pre><p id="b48d" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">生成以下错误:</p><pre class="lt lu lv lw fq lx km ly lz aw ma dt"><span id="bfdb" class="mb kr hu km b fv mc md l me mf">rvalue.cc:24:6: error: non-const lvalue reference to type 'int' cannot bind to a<br/>      temporary of type 'int'</span></pre><p id="7fdf" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">该错误消息意味着编译器对<strong class="jn hv"> r </strong>值强制使用<em class="jm">常量引用</em>。</p><p id="f40b" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">一个更有趣的<strong class="jn hv">例子:</strong></p><pre class="lt lu lv lw fq lx km ly lz aw ma dt"><span id="f115" class="mb kr hu km b fv mc md l me mf">#include &lt;stdio.h&gt;<br/>#include &lt;string&gt;<br/><br/><strong class="km hv">void</strong> print(<strong class="km hv">const</strong> std::string&amp; name) {<br/>    printf("rvalue detected:%s\n", name.c_str());<br/>}</span><span id="12ad" class="mb kr hu km b fv mg md l me mf"><strong class="km hv">void</strong> print(std::string&amp; name) {<br/>    printf("lvalue detected:%s\n", name.c_str());<br/>}</span><span id="a12f" class="mb kr hu km b fv mg md l me mf">int main() {<br/>    std::string name = "lvalue";<br/>    <!-- -->std::string rvalu = "rvalu";</span><span id="6066" class="mb kr hu km b fv mg md l me mf">    print(name); //compiler can detect the right function for lvalue<br/>    print(rvalu + "e"); // likewise for rvalue<br/>}</span></pre><p id="1710" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated"><strong class="jn hv">结果:</strong></p><pre class="lt lu lv lw fq lx km ly lz aw ma dt"><span id="115f" class="mb kr hu km b fv mc md l me mf">lvalue detected:lvalue<br/>rvalue detected:rvalue</span></pre><p id="8b92" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">这种差异实际上非常显著，编译器可以确定重载的函数。</p><h2 id="27ec" class="mb kr hu bd ks mh mi mj kw mk ml mm la kn mn mo le ko mp mq li kp mr ms lm mt dt translated">所以rvalue是常量值？</h2><p id="b680" class="pw-post-body-paragraph jk jl hu jn b jo lo jq jr js lp ju jv kn lq jy jz ko lr kc kd kp ls kg kh ki hn dt translated">不完全是。这就是<code class="eh kj kk kl km b"><strong class="jn hv">&amp;&amp;</strong></code> ( <strong class="jn hv"> r </strong>参考值)的用武之地。</p><p id="d093" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated"><strong class="jn hv">例如:</strong></p><pre class="lt lu lv lw fq lx km ly lz aw ma dt"><span id="e24e" class="mb kr hu km b fv mc md l me mf">#include &lt;stdio.h&gt;<br/>#include &lt;string&gt;</span><span id="fda3" class="mb kr hu km b fv mg md l me mf">void print(const std::string&amp; name) {<br/>  printf(“const value detected:%s\n”, name.c_str());<br/>}</span><span id="9942" class="mb kr hu km b fv mg md l me mf">void print(std::string&amp; name) {<br/>  printf(“lvalue detected%s\n”, name.c_str());<br/>}</span><span id="8010" class="mb kr hu km b fv mg md l me mf">void print(std::string&amp;&amp; name) {<br/>  printf(“rvalue detected:%s\n”, name.c_str());<br/>}</span><span id="f747" class="mb kr hu km b fv mg md l me mf">int main() {<br/>  std::string name = “lvalue”;<br/>  const std::string cname = “cvalue”;<br/>  <!-- -->std::string rvalu = "rvalu";</span><span id="3746" class="mb kr hu km b fv mg md l me mf">  print(name);<br/>  print(cname);<br/>  print(<!-- -->rvalu + "e"<!-- -->);<br/>}</span></pre><p id="43d8" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated"><strong class="jn hv">结果:</strong></p><pre class="lt lu lv lw fq lx km ly lz aw ma dt"><span id="8162" class="mb kr hu km b fv mc md l me mf">lvalue detected:lvalue<br/>const value detected:cvalue<br/>rvalue detected:rvalue</span></pre><p id="bc67" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">如果函数为<strong class="jn hv"> r </strong> value重载，则<strong class="jn hv"> r </strong> value变量选择更具体的版本，而不是采用两者兼容的常量引用参数的版本。因此，<code class="eh kj kk kl km b"><strong class="jn hv"> &amp;&amp;</strong></code> <strong class="jn hv">可以从常量值进一步多样化右值。</strong></p><p id="01b8" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">下面我总结了默认设置下重载函数版本对不同类型的兼容性。您可以通过有选择地注释掉上面示例中的行来验证结果。</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/a48f8b53b9b35d7f06e0e2265e43920a.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*X6u6FdvOCF38fhseoWxMbQ.png"/></div></figure><p id="ed71" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">进一步区分<strong class="jn hv"> r </strong>值和常量值听起来很酷，因为它们实际上并不完全相同。但是有什么实用价值呢？</p><h1 id="76da" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">&amp;&amp;到底解决了什么问题？</h1><p id="1ea1" class="pw-post-body-paragraph jk jl hu jn b jo lo jq jr js lp ju jv kn lq jy jz ko lr kc kd kp ls kg kh ki hn dt translated">当参数是一个<strong class="jn hv"> r </strong>值时，问题是不必要的深度复制。</p><p id="d00b" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">更具体地说。<code class="eh kj kk kl km b"><strong class="jn hv">&amp;&amp;</strong></code>符号用于指定<strong class="jn hv"> r </strong>值，当<strong class="jn hv"> r </strong>值，1)作为<em class="jm">构造函数</em>或<em class="jm">赋值运算符</em>的参数传递，以及2)其类包含一个(或多个)指向动态分配资源(内存)的指针时，可用于避免深度复制。</p><p id="c5b0" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">可以用<strong class="jn hv">例子更具体:</strong></p><pre class="lt lu lv lw fq lx km ly lz aw ma dt"><span id="1242" class="mb kr hu km b fv mc md l me mf">#include &lt;stdio.h&gt;<br/>#include &lt;string&gt;<br/>#include &lt;algorithm&gt;<br/><br/>using namespace std;<br/><br/><strong class="km hv">class</strong> ResourceOwner {<br/>public:<br/>  ResourceOwner(<strong class="km hv">const</strong> char res[]) {<br/>    theResource = <strong class="km hv">new</strong> string(res);<br/>  }<br/>  ResourceOwner(<strong class="km hv">const</strong> ResourceOwner&amp; other) {<br/>    printf("copy %s\n", other.theResource-&gt;c_str());<br/>    theResource = <strong class="km hv">new</strong> string(other.theResource-&gt;c_str());<br/>  }<br/>  ResourceOwner&amp; operator=(<strong class="km hv">const</strong> ResourceOwner&amp; other) {<br/>    ResourceOwner tmp(other);<br/>    swap(theResource, tmp.theResource);<br/>    printf("assign %s\n", other.theResource-&gt;c_str());<br/>  }<br/>  ~ResourceOwner() {<br/>    <strong class="km hv">if</strong> (theResource) {<br/>      printf("destructor %s\n", theResource-&gt;c_str());<br/>      <strong class="km hv">delete</strong> theResource;<br/>    }<br/>  }<br/><br/>private:<br/>  string* theResource;<br/>};</span><span id="2ee4" class="mb kr hu km b fv mg md l me mf">void testCopy() { // case 1<br/>  printf("=====start testCopy()=====\n");</span><span id="701f" class="mb kr hu km b fv mg md l me mf">  ResourceOwner res1("res1");<br/>  ResourceOwner res2 = res1;  <em class="jm">//copy res1</em></span><span id="26f0" class="mb kr hu km b fv mg md l me mf">  printf("=====destructors for stack vars, ignore=====\n");<br/>}</span><span id="4c47" class="mb kr hu km b fv mg md l me mf">void testAssign() { // case 2<br/>  printf("=====start testAssign()=====\n");</span><span id="75ac" class="mb kr hu km b fv mg md l me mf">  ResourceOwner res1("res1");<br/>  ResourceOwner res2("res2");<br/>  res2 = res1; <em class="jm">//copy res1, assign res1, destrctor res2</em></span><span id="5a5c" class="mb kr hu km b fv mg md l me mf">  printf("=====destructors for stack vars, ignore=====\n");<br/>}</span><span id="f4cb" class="mb kr hu km b fv mg md l me mf">void testRValue() {<!-- --> // case 3<br/>  <!-- -->printf("=====start <!-- -->testRValue<!-- -->()=====\n");<br/>  <br/>  ResourceOwner res2("res2");<br/>  res2 = ResourceOwner("res1"); //copy res1, assign res1, destructor res2, destructor res1</span><span id="d279" class="mb kr hu km b fv mg md l me mf">  printf("=====destructors for stack vars, ignore=====\n");<br/>}</span><span id="b1d3" class="mb kr hu km b fv mg md l me mf">int main() {<br/>  testCopy();<br/>  testAssign();<br/>  <!-- -->testRValue();<br/>}</span></pre><p id="fabb" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated"><strong class="jn hv">结果:</strong></p><pre class="lt lu lv lw fq lx km ly lz aw ma dt"><span id="a074" class="mb kr hu km b fv mc md l me mf">=====start testCopy()=====<br/>copy res1<br/>=====destructors for stack vars, ignore=====<br/>destructor res1<br/>destructor res1<br/>=====start testAssign()=====<br/>copy res1<br/>assign res1<br/>destructor res2<br/>=====destructors for stack vars, ignore=====<br/>destructor res1<br/>destructor res1<br/>=====start testRValue()=====<br/>copy res1<br/>assign res1<br/>destructor res2<br/>destructor res1<br/>=====destructors for stack vars, ignore=====<br/>destructor res1</span></pre><p id="e1df" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">对于前两个测试用例，即<code class="eh kj kk kl km b">testCopy()</code>和<code class="eh kj kk kl km b">testAssign()</code>，结果都是好的，其中<code class="eh kj kk kl km b">res1</code>中的的<em class="jm">资源被复制给了<code class="eh kj kk kl km b">res2</code>。复制资源是合理的，因为它们是两个实体，都需要它们的非共享资源(字符串)。</em></p><p id="72b1" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">然而，在第三种情况下，<code class="eh kj kk kl km b">res1</code>中资源的(深度)复制是多余的，因为匿名<strong class="jn hv"> r </strong>值(由<code class="eh kj kk kl km b">ResourceOwner(“res1”)</code>返回)将在赋值后立即被析构，因此它不再需要该资源:</p><pre class="lt lu lv lw fq lx km ly lz aw ma dt"><span id="251f" class="mb kr hu km b fv mc md l me mf">res2 = ResourceOwner("res1"); // Please note that the <!-- -->destructor res1<!-- --> is called right after this line before the point where stack variables are destructed.</span></pre><p id="2407" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">我认为这是重复问题陈述的好机会:</p><blockquote class="jh ji jj"><p id="f56b" class="jk jl jm jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated"><code class="eh kj kk kl km b"><strong class="jn hv">&amp;&amp;</strong></code>符号用于指定一个<strong class="jn hv"> r </strong>值，当<strong class="jn hv"> r </strong>值1)作为构造函数或赋值操作符的参数传递，2)其类包含一个(或多个)指向动态分配的资源(内存)的指针时，该符号可用于避免深度复制。</p></blockquote><p id="0f17" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">如果复制一个即将消失的资源不是最优的，那么什么是正确的操作呢？答案是</p><h1 id="1d26" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">移动</h1><p id="28ca" class="pw-post-body-paragraph jk jl hu jn b jo lo jq jr js lp ju jv kn lq jy jz ko lr kc kd kp ls kg kh ki hn dt translated">这个想法很简单，如果参数是一个r值，我们不需要复制。相反，我们可以简单地“移动”资源(即<strong class="jn hv"> r </strong>值指向的内存)。现在让我们使用新技术重载<em class="jm">赋值操作符</em>:</p><pre class="lt lu lv lw fq lx km ly lz aw ma dt"><span id="0908" class="mb kr hu km b fv mc md l me mf">ResourceOwner&amp; operator=(ResourceOwner&amp;&amp; other) {<br/>  theResource = other.theResource;<br/>  other.theResource = NULL;<br/>}</span></pre><p id="e366" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">这个新的<em class="jm">分配操作符</em>被称为<strong class="jn hv">移动</strong>分配操作符<em class="jm">。一个<strong class="jn hv">移动</strong>构造<em class="jm">构造</em>可以用类似的方式编程。</em></p><p id="52b8" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">理解这一点的一个好方法是:当你卖掉你的旧房子并把它搬到新房子时，你不必像我们在案例3中那样扔掉所有的家具，对吗？相反，你可以简单地把家具搬到新家。</p><p id="ea1e" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">一切都好。</p><h1 id="2b14" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">什么是std::move？</h1><p id="3aed" class="pw-post-body-paragraph jk jl hu jn b jo lo jq jr js lp ju jv kn lq jy jz ko lr kc kd kp ls kg kh ki hn dt translated">除了上面讨论的<strong class="jn hv">移动</strong> <em class="jm">赋值操作符</em>和<strong class="jn hv">移动</strong> <em class="jm">构造器</em>之外，这个拼图还缺少最后一块<code class="eh kj kk kl km b">std::move</code>。</p><p id="5a19" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">同样，我们先看问题:</p><p id="07ed" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">当1)我们知道一个变量实际上是一个<strong class="jn hv"> r </strong>值，而2)编译器不知道。无法调用重载函数的正确版本。</p><p id="03b5" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">一个常见的情况是当我们添加另一层资源所有者<code class="eh kj kk kl km b">ResourceHolder</code>时，三个实体的关系如下所示:</p><pre class="lt lu lv lw fq lx km ly lz aw ma dt"><span id="c45c" class="mb kr hu km b fv mc md l me mf">holder<br/> |<br/> |-----&gt;owner<br/>         |<br/>         |-----&gt;resource</span></pre><p id="a737" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">(注意，在下面的例子中，我也完成了<code class="eh kj kk kl km b">ResourceOwner</code>的<strong class="jn hv">move</strong><em class="jm">constructor</em>的实现)</p><p id="b386" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated"><strong class="jn hv">例如:</strong></p><pre class="lt lu lv lw fq lx km ly lz aw ma dt"><span id="1fde" class="mb kr hu km b fv mc md l me mf">#include &lt;string&gt;<br/>#include &lt;algorithm&gt;</span><span id="c68b" class="mb kr hu km b fv mg md l me mf">using namespace std;</span><span id="a5f0" class="mb kr hu km b fv mg md l me mf">class ResourceOwner {</span><span id="4193" class="mb kr hu km b fv mg md l me mf">public:<br/>  ResourceOwner(const char res[]) {<br/>    theResource = new string(res);<br/>  }</span><span id="83f1" class="mb kr hu km b fv mg md l me mf">  ResourceOwner(const ResourceOwner&amp; other) {<br/>    printf(“copy %s\n”, other.theResource-&gt;c_str());<br/>    theResource = new string(other.theResource-&gt;c_str());<br/>  }</span><span id="a1b1" class="mb kr hu km b fv mg md l me mf">++ResourceOwner(ResourceOwner&amp;&amp; other) {<br/>++ printf(“move cons %s\n”, other.theResource-&gt;c_str());<br/>++ theResource = other.theResource;<br/>++ other.theResource = NULL;<br/>++}</span><span id="765e" class="mb kr hu km b fv mg md l me mf">  ResourceOwner&amp; operator=(const ResourceOwner&amp; other) {<br/>    ResourceOwner tmp(other);<br/>    swap(theResource, tmp.theResource);<br/>    printf(“assign %s\n”, other.theResource-&gt;c_str());<br/>  }</span><span id="41b4" class="mb kr hu km b fv mg md l me mf">++ResourceOwner&amp; operator=(ResourceOwner&amp;&amp; other) {<br/>++ printf(“move assign %s\n”, other.theResource-&gt;c_str());<br/>++ theResource = other.theResource;<br/>++ other.theResource = NULL;<br/>++}</span><span id="48ee" class="mb kr hu km b fv mg md l me mf">  ~ResourceOwner() {<br/>    if (theResource) {<br/>      printf(“destructor %s\n”, theResource-&gt;c_str());<br/>      delete theResource;<br/>    }<br/>  }</span><span id="4256" class="mb kr hu km b fv mg md l me mf">private:<br/>  string* theResource;<br/>};</span><span id="bcf2" class="mb kr hu km b fv mg md l me mf">class ResourceHolder {</span><span id="4994" class="mb kr hu km b fv mg md l me mf">……</span><span id="3246" class="mb kr hu km b fv mg md l me mf">ResourceHolder&amp; operator=(ResourceHolder&amp;&amp; other) {<br/>  printf(“move assign %s\n”, other.theResource-&gt;c_str());<br/>  resOwner = other.resOwner;<br/>}</span><span id="4647" class="mb kr hu km b fv mg md l me mf">……</span><span id="e4ac" class="mb kr hu km b fv mg md l me mf">private:<br/>  ResourceOwner resOwner;<br/>}</span></pre><p id="9c28" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">在<code class="eh kj kk kl km b">ResourceHolder</code>的<strong class="jn hv">移动</strong> <em class="jm">赋值运算符</em>中，我们要调用<code class="eh kj kk kl km b">ResourceOwner</code>的<strong class="jn hv">移动</strong> <em class="jm">赋值运算符</em>，因为“一个<strong class="jn hv"> r </strong>值的无指针成员也应该是一个<strong class="jn hv"> r </strong>值”。然而，当我们简单地编写<code class="eh kj kk kl km b">resOwner = other.resOwner</code>时，被调用的实际上是<code class="eh kj kk kl km b">ResourceOwner</code>的普通<em class="jm">赋值操作符</em>，这又会导致额外的副本。</p><p id="926f" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">这是再次重复问题陈述的好机会:</p><blockquote class="jh ji jj"><p id="5b7a" class="jk jl jm jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">当1)我们知道一个变量实际上是一个<strong class="jn hv"> r </strong>值，而2)编译器不知道。无法调用重载函数的正确版本。</p></blockquote><p id="d2e1" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">作为解决方案，我们使用<code class="eh kj kk kl km b">std::move</code>将变量转换为<strong class="jn hv"> r </strong>值，这样就可以调用<code class="eh kj kk kl km b">ResourceOwner</code>的<em class="jm">赋值运算符</em>的正确版本。</p><pre class="lt lu lv lw fq lx km ly lz aw ma dt"><span id="15ee" class="mb kr hu km b fv mc md l me mf">ResourceHolder&amp; operator=(ResourceHolder&amp;&amp; other) {<br/>  printf(“move assign %s\n”, other.theResource-&gt;c_str());<br/>  resOwner = std::move(other.resOwner);<br/>}</span></pre><h1 id="ae6f" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">std::move到底是什么？</h1><p id="531b" class="pw-post-body-paragraph jk jl hu jn b jo lo jq jr js lp ju jv kn lq jy jz ko lr kc kd kp ls kg kh ki hn dt translated">我们知道<em class="jm">类型转换</em>不仅仅是告诉编译器“我知道我在做什么”的编译器安慰剂。它有效地生成指令<code class="eh kj kk kl km b">mov</code>的一个值给更大或更小的寄存器(例如<code class="eh kj kk kl km b">%eax</code> - &gt; <code class="eh kj kk kl km b">%cl</code>)来进行“强制转换”。</p><p id="dbe0" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">那么<code class="eh kj kk kl km b">std::move</code>到底在幕后做什么。当我写这一段时，我不知道我自己，所以让我们一起找出答案。</p><p id="c4f9" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">首先我们稍微修改一下主要部分(我试图保持风格一致)</p><p id="d70d" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated"><strong class="jn hv">举例:</strong></p><pre class="lt lu lv lw fq lx km ly lz aw ma dt"><span id="8ee6" class="mb kr hu km b fv mc md l me mf">int main() {<br/>  ResourceOwner res(“res1”);<br/>  asm(“nop”); // remeber me<br/>  ResourceOwner &amp;&amp; rvalue = std::move(res);<br/>  asm(“nop”); // remeber me<br/>}</span></pre><p id="2ea9" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">编译它，并使用</p><pre class="lt lu lv lw fq lx km ly lz aw ma dt"><span id="9d87" class="mb kr hu km b fv mc md l me mf">clang++ -g -c -std=c++11 -stdlib=libc++ -Weverything move.cc<br/>gobjdump -d -D move.o</span></pre><p id="6740" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated"><strong class="jn hv">结果:</strong></p><pre class="lt lu lv lw fq lx km ly lz aw ma dt"><span id="84d2" class="mb kr hu km b fv mc md l me mf">0000000000000000 &lt;_main&gt;:<br/> 0: 55 push %rbp<br/> 1: 48 89 e5 mov %rsp,%rbp<br/> 4: 48 83 ec 20 sub $0x20,%rsp<br/> 8: 48 8d 7d f0 lea -0x10(%rbp),%rdi<br/> c: 48 8d 35 41 03 00 00 lea 0x341(%rip),%rsi # 354 &lt;GCC_except_table5+0x18&gt;<br/> 13: e8 00 00 00 00 callq 18 &lt;_main+0x18&gt;<br/> 18: 90 nop // remember me<br/> 19: 48 8d 75 f0 lea -0x10(%rbp),%rsi<br/> 1d: 48 89 75 f8 mov %rsi,-0x8(%rbp)<br/> 21: 48 8b 75 f8 mov -0x8(%rbp),%rsi<br/> 25: 48 89 75 e8 mov %rsi,-0x18(%rbp)<br/> 29: 90 nop // remember me<br/> 2a: 48 8d 7d f0 lea -0x10(%rbp),%rdi<br/> 2e: e8 00 00 00 00 callq 33 &lt;_main+0x33&gt;<br/> 33: 31 c0 xor %eax,%eax<br/> 35: 48 83 c4 20 add $0x20,%rsp<br/> 39: 5d pop %rbp<br/> 3a: c3 retq<br/> 3b: 0f 1f 44 00 00 nopl 0x0(%rax,%rax,1)</span></pre><p id="d1c7" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">我简单解释一下两者之间发生了什么<code class="eh kj kk kl km b">nop</code>。</p><ol class=""><li id="3e81" class="mv mw hu jn b jo jp js jt kn mx ko my kp mz ki na nb nc nd dt translated">将一个堆栈变量(假定为<code class="eh kj kk kl km b">ResourceOwner res</code>)的地址分配给<code class="eh kj kk kl km b">%rsi</code></li><li id="5fad" class="mv mw hu jn b jo ne js nf kn ng ko nh kp ni ki na nb nc nd dt translated">将<code class="eh kj kk kl km b">%rsi</code>的值赋给另一个堆栈变量(这个变量是匿名的)</li><li id="8b30" class="mv mw hu jn b jo ne js nf kn ng ko nh kp ni ki na nb nc nd dt translated">将匿名堆栈变量的值赋回<code class="eh kj kk kl km b">%rsi</code>(什么？)</li><li id="6b50" class="mv mw hu jn b jo ne js nf kn ng ko nh kp ni ki na nb nc nd dt translated">将%rsi的值赋给另一个堆栈变量(大概是<code class="eh kj kk kl km b">ResourceOwner &amp;&amp; rvalue</code>)</li><li id="8227" class="mv mw hu jn b jo ne js nf kn ng ko nh kp ni ki na nb nc nd dt translated">所以整个操作可以总结为“将<code class="eh kj kk kl km b">ResourceOwner res</code>的地址分配给<code class="eh kj kk kl km b">ResourceOwner &amp;&amp; rvalue</code>”，这与正常的引用分配是一样的。</li></ol><p id="2e69" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">如果我们为编译器打开<code class="eh kj kk kl km b">O (-O1)</code>，所有那些伪指令都将消失。</p><pre class="lt lu lv lw fq lx km ly lz aw ma dt"><span id="2bbc" class="mb kr hu km b fv mc md l me mf">clang++ -g -c -O1 -std=c++11 -stdlib=libc++ -Weverything move.cc<br/>gobjdump -d -D move.o</span></pre><p id="021c" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">此外，如果将临界线更改为正常参考分配:</p><pre class="lt lu lv lw fq lx km ly lz aw ma dt"><span id="ad12" class="mb kr hu km b fv mc md l me mf">ResourceOwner &amp; rvalue = res;</span></pre><p id="7a07" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">除了变量偏移量上的一些微小差异，生成的汇编代码大部分是相同的，正如我们在上面第5点中假设的那样。</p><p id="99cc" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">测试表明<strong class="jn hv"> move </strong>语义是纯粹的语法糖果，机器根本不关心。</p><p id="f6bf" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">总结一下，</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div class="fe ff nj"><img src="../Images/4024798c546282f82be298ba76f1434d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*SqLM5563UiteDzMt1S7smQ.jpeg"/></div></figure></div><div class="ab cl nk nl hc nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="hn ho hp hq hr"><p id="ede2" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">如果你喜欢这篇文章，请为它鼓掌，或者点击按钮跟随我。感谢您的光临，希望下次再见。</p><p id="cfa3" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh ki hn dt translated">这个帖子也存档<a class="ae jg" href="http://holmeshe.me/cpp-rvalue-and-move/" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p><figure class="lt lu lv lw fq iv"><div class="bz el l di"><div class="nr ns l"/></div></figure></div></div>    
</body>
</html>