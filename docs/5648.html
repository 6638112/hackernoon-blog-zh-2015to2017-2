<html>
<head>
<title>Are Implicit Conversions Killing Your SQL Query Performance?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">隐式转换会降低SQL查询性能吗？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/are-implicit-conversions-killing-your-sql-query-performance-70961e547f11?source=collection_archive---------4-----------------------#2017-08-08">https://medium.com/hackernoon/are-implicit-conversions-killing-your-sql-query-performance-70961e547f11?source=collection_archive---------4-----------------------#2017-08-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/b8713a1c0ce3fd5b2bc4a4d681d9b3f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5wtmLbUow_4piutRlvrJVg.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/gts_Eh4g1lk?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">chuttersnap</a> on <a class="ae jg" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><figure class="jh ji jj jk fq iv"><div class="bz el l di"><div class="jl jm l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Watch this post on <a class="ae jg" href="https://www.youtube.com/watch?v=RqpApsRJpYc&amp;feature=youtu.be" rel="noopener ugc nofollow" target="_blank">YouTube</a></figcaption></figure><p id="2266" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">您是否遇到过运行缓慢的查询，即使您已经为它创建了索引？</p><p id="ee03" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">发生这种情况有几种不同的原因。我最常看到的一种情况发生在下面的场景中。</p><h2 id="f85d" class="kl km hu bd kn ko kp kq kr ks kt ku kv jy kw kx ky kc kz la lb kg lc ld le lf dt translated">我要一杯浓缩咖啡</h2><p id="2ece" class="pw-post-body-paragraph jn jo hu jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk hn dt translated">假设我有一个<a class="ae jg" href="https://gist.github.com/bertwagner/e1225294ae73f2d74575d834e93597e8" rel="noopener ugc nofollow" target="_blank">表dbo。咖啡库存</a>的咖啡豆和价格，我每周从<a class="ae jg" href="https://www.sweetmarias.com/" rel="noopener ugc nofollow" target="_blank">我最喜欢的生咖啡豆供应商</a>那里获取。它看起来像这样:</p><pre class="jh ji jj jk fq ll lm ln lo aw lp dt"><span id="09c1" class="kl km hu lm b fv lq lr l ls lt">-- Make sure Actual Execution Plan is on<br/>-- Let's see what our data looks like<br/>SELECT * FROM dbo.CoffeeInventory</span></pre><figure class="jh ji jj jk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lu"><img src="../Images/231387c1cb47528fc53cfd45426d1965.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V8zWwyeY57_6VT1AiCgJeg.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">If you want to follow along, you can get this data set from <a class="ae jg" href="https://gist.github.com/bertwagner/e1225294ae73f2d74575d834e93597e8" rel="noopener ugc nofollow" target="_blank">this GitHub Gist</a></figcaption></figure><p id="3a3b" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">我希望能够高效地查询这个表并根据价格进行过滤，所以接下来我创建了一个索引，如下所示:</p><pre class="jh ji jj jk fq ll lm ln lo aw lp dt"><span id="1f1b" class="kl km hu lm b fv lq lr l ls lt">CREATE CLUSTERED INDEX CL_Price ON dbo.CoffeeInventory (Price)</span></pre><p id="7e1c" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">现在，我可以编写我的查询来找出低于我愿意支付的咖啡价格:</p><pre class="jh ji jj jk fq ll lm ln lo aw lp dt"><span id="7e48" class="kl km hu lm b fv lq lr l ls lt">SELECT Name, Price FROM dbo.CoffeeInventory WHERE Price &lt; 6.75</span></pre><p id="28cb" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">您希望这个查询非常快，并使用聚集索引查找，对吗？</p><p id="8c46" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated"><strong class="jp hv">错了！</strong></p><figure class="jh ji jj jk fq iv fe ff paragraph-image"><div class="fe ff lv"><img src="../Images/f24ab6e0a6b2c1b726ef3a4fad966368.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*NALd5upi2gtb4ysGg0L3fw.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">What the heck?</figcaption></figure><p id="bd98" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">当我在谓词中过滤的列上添加聚集索引时，为什么SQL会扫描表？事情不应该是这样的！</p><p id="d6b0" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">亲爱的读者，如果我们更仔细地观察表扫描操作，我们会注意到一个叫做CONVERT_IMPLICIT的小东西:</p><figure class="jh ji jj jk fq iv fe ff paragraph-image"><div class="fe ff lw"><img src="../Images/fc8aad309b3737913d5721bae11d2d37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*gRlxQ59SWD1LIkHqP7YnQQ.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">CONVERT_IMPLICIT: ruiner of fast queries</figcaption></figure><p id="2d4e" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">CONVERT_IMPLICIT在做什么？顾名思义，它在执行查询时必须转换一些数据(与我在查询中指定了显式的CAST()或convert()函数相反)。</p><p id="fe55" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">它需要这样做的原因是因为我将Price列定义为VARCHAR(5):</p><figure class="jh ji jj jk fq iv fe ff paragraph-image"><div class="fe ff lx"><img src="../Images/4a6a733a9b5a27963c208dfec452675f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*O10mNGbV6hkwXhs2-QXZiw.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Who put numeric data into a string datatype? Someone who hasn’t had their coffee yet today.</figcaption></figure><p id="c8ce" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">然而，在我的查询中，我将与一个数字<code class="eh ly lz ma lm b">WHERE Price &lt; 6.75</code>进行比较。<a class="ae jg" href="https://hackernoon.com/tagged/sql-server" rel="noopener ugc nofollow" target="_blank"> SQL Server </a>说它不知道如何比较字符串和数字，所以它必须将VARCHAR字符串转换为数字(3，2)。</p><p id="3fcf" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">这是痛苦的。</p><p id="42c7" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">为什么？因为SQL正在为我的表中的每一行执行到数值数据类型的隐式转换。因此，它不能使用索引，因为它最终必须扫描整个表，首先将每条记录转换为数字。</p><p id="f5fb" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">这不仅仅发生在数字和字符串转换上。<a class="ae jg" href="https://docs.microsoft.com/en-us/sql/t-sql/data-types/data-type-conversion-database-engine" rel="noopener ugc nofollow" target="_blank">微软发布了一整张图表</a>详细说明了什么类型的数据类型比较会强制进行隐式转换:</p><figure class="jh ji jj jk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mc"><img src="../Images/aa174ab75ff889fa9185241c4da0fb9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lWpR_o3RZvbgqU79.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="https://docs.microsoft.com/en-us/sql/t-sql/data-types/data-type-conversion-database-engine" rel="noopener ugc nofollow" target="_blank">https://docs.microsoft.com/en-us/sql/t-sql/data-types/data-type-conversion-database-engine</a></figcaption></figure><p id="4415" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">那可是好多橙圈/隐式转换啊！</p><h2 id="6c58" class="kl km hu bd kn ko kp kq kr ks kt ku kv jy kw kx ky kc kz la lb kg lc ld le lf dt translated">如何更快的查询我的咖啡？</h2><p id="226c" class="pw-post-body-paragraph jn jo hu jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk hn dt translated">在这种情况下，我们有两个选择。</p><ol class=""><li id="6e7b" class="md me hu jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml dt translated">修复我们的表的数据类型，使之与实际存储在其中的数据保持一致(数据管理员喜欢这样)。</li><li id="cdfe" class="md me hu jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml dt translated">不会导致SQL Server转换列中的每一行。</li></ol><p id="c477" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">上面的第一条是不言自明的，如果你能做到的话，这是更好的选择。但是，如果您不能修改列类型，您最好这样编写您的查询:</p><pre class="jh ji jj jk fq ll lm ln lo aw lp dt"><span id="aee5" class="kl km hu lm b fv lq lr l ls lt">SELECT Name, Price FROM dbo.CoffeeInventory WHERE Price &lt; '6.75'</span></pre><figure class="jh ji jj jk fq iv fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/b64e5ad742171e7976b929a1b25b7a99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*UZGe0e3lIzkhTODYONsFmg.png"/></div></figure><p id="ec34" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">因为我们对等价的数据类型进行比较，所以SQL Server不需要进行任何转换，我们的索引就会被使用。呜-呼！</p><h2 id="d26d" class="kl km hu bd kn ko kp kq kr ks kt ku kv jy kw kx ky kc kz la lb kg lc ld le lf dt translated">我的服务器的其余部分呢？</h2><p id="80a6" class="pw-post-body-paragraph jn jo hu jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk hn dt translated">还记得上面的图表吗？有许多不同的数据比较可以强制SQL Server进行痛苦的列端隐式转换。</p><p id="f612" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">幸运的是，<a class="ae jg" href="https://www.sqlskills.com/blogs/jonathan/finding-implicit-column-conversions-in-the-plan-cache/" rel="noopener ugc nofollow" target="_blank"> Jonathan Kehayias </a>编写了一个很棒的查询，可以帮助您通过查询计划缓存找到列端隐式转换。运行他的查询是识别查询中发生的大多数隐式转换的一个很好的方法，这样您就可以返回并修复它们——然后为您改进的查询性能<a class="ae jg" href="https://hackernoon.com/tagged/performance" rel="noopener ugc nofollow" target="_blank">而高兴</a>！</p><p id="44bb" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated"><em class="mb">还在读书？你可能会喜欢在Twitte上关注我</em></p><figure class="jh ji jj jk fq iv"><div class="bz el l di"><div class="ms jm l"/></div></figure><p id="8ea4" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated"><em class="mb">喜欢这篇文章吗？请推荐给它一颗绿色的心</em>💚<em class="mb">下图。</em></p><figure class="jh ji jj jk fq iv"><div class="bz el l di"><div class="ms jm l"/></div></figure></div></div>    
</body>
</html>