<html>
<head>
<title>Doom3 is the proof that “keep it simple” works.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Doom3就是“保持简单”奏效的证明。</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/doom3-is-the-proof-that-keep-it-simple-works-3884d2484084?source=collection_archive---------10-----------------------#2017-07-12">https://medium.com/hackernoon/doom3-is-the-proof-that-keep-it-simple-works-3884d2484084?source=collection_archive---------10-----------------------#2017-07-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="45d0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你在网上搜索最好的C++源代码，Doom3源代码被提到很多次，还有像这样的评价。</p><blockquote class="jp jq jr"><p id="e00c" class="ir is js it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt translated">我花了一点时间浏览Doom3源代码。这可能是我见过的最干净、最漂亮的代码。</p></blockquote><p id="42c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">《毁灭战士3》是一款由<a class="ae jw" href="http://en.wikipedia.org/wiki/Id_Software" rel="noopener ugc nofollow" target="_blank"> id软件</a>开发，由<a class="ae jw" href="http://en.wikipedia.org/wiki/Activision" rel="noopener ugc nofollow" target="_blank">动视</a>发行的视频游戏。这款游戏是id软件的商业成功；售出了超过350万份游戏拷贝。</p><p id="14f8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2011年11月23日，id Software保持了传统，发布了他们之前引擎的<a class="ae jw" href="https://github.com/dhewm/dhewm3" rel="noopener ugc nofollow" target="_blank">源代码</a>。这份源代码被许多开发者审阅过，下面是fabien ( <a class="ae jw" href="http://fabiensanglard.net/doom3_bfg/" rel="noopener ugc nofollow" target="_blank">原始来源</a>)反馈的例子:</p><blockquote class="jp jq jr"><p id="ead0" class="ir is js it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt translated">《毁灭战士3·BFG》是用C++写的，这是一种如此庞大的语言，它可以用来生成伟大的代码，但也有令人厌恶的东西，会让你的眼睛流血。幸运的是，id软件满足于一个接近“有类的C”的C++子集，它几乎没有阻力地流向大脑:</p></blockquote><ul class=""><li id="0ebb" class="jx jy hu it b iu iv iy iz jc jz jg ka jk kb jo kc kd ke kf dt translated">没有例外。</li><li id="f855" class="jx jy hu it b iu kg iy kh jc ki jg kj jk kk jo kc kd ke kf dt translated">没有引用(使用指针)。</li><li id="c735" class="jx jy hu it b iu kg iy kh jc ki jg kj jk kk jo kc kd ke kf dt translated">最少使用模板。</li><li id="b554" class="jx jy hu it b iu kg iy kh jc ki jg kj jk kk jo kc kd ke kf dt translated">到处都是Const。</li><li id="0815" class="jx jy hu it b iu kg iy kh jc ki jg kj jk kk jo kc kd ke kf dt translated">班级。</li><li id="2686" class="jx jy hu it b iu kg iy kh jc ki jg kj jk kk jo kc kd ke kf dt translated">多态性。</li><li id="607c" class="jx jy hu it b iu kg iy kh jc ki jg kj jk kk jo kc kd ke kf dt translated">遗产。</li></ul><p id="59f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">许多C++专家不再推荐“带类的C”方法。然而，Doom3是在2000年到2004年之间开发的，这可以解释为什么没有使用现代C++机制。</p><p id="5060" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们使用<a class="ae jw" href="http://www.cppdepend.com/" rel="noopener ugc nofollow" target="_blank"> CppDepend </a>深入它的源代码，并发现它的特别之处。</p><p id="ed4a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Doom3使用几个项目进行模块化，下面是它的项目列表，以及关于它们类型的一些统计数据:</p><figure class="km kn ko kp fq kq fe ff paragraph-image"><div class="fe ff kl"><img src="../Images/a30e46bba0fa50af08f873fdfd3e066d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/0*rJQOwdMUtl8lMr9W.png"/></div></figure><p id="6dbe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是显示它们之间关系的依赖关系图:</p><figure class="km kn ko kp fq kq fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff kt"><img src="../Images/b6693a73315f8aa261bcc621a52a454e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8rGrpJL1u9efl5tB.png"/></div></div></figure><p id="12e3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Doom3定义了许多全局函数。但是，大部分处理都是在类中实现的。</p><p id="06ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">数据模型是使用结构定义的。为了有一个在源代码中使用结构的具体概念，上面的度量视图将它们显示为蓝色矩形。</p><p id="7d2c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Metric视图中，代码库通过树形图表示。Treemapping是一种通过使用嵌套矩形来显示树结构数据的方法。使用的树结构是通常的代码层次结构:</p><ul class=""><li id="264f" class="jx jy hu it b iu iv iy iz jc jz jg ka jk kb jo kc kd ke kf dt translated">项目包含命名空间。</li><li id="391e" class="jx jy hu it b iu kg iy kh jc ki jg kj jk kk jo kc kd ke kf dt translated">命名空间包含类型。</li><li id="e7da" class="jx jy hu it b iu kg iy kh jc ki jg kj jk kk jo kc kd ke kf dt translated">类型包含方法和字段。</li></ul><figure class="km kn ko kp fq kq fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff ky"><img src="../Images/552cd3f579baff50a2f64b19a7714d7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rfc4JMGBSOHAdkD1.png"/></div></div></figure><p id="1cf2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如我们所观察到的，许多结构都被定义了，例如超过40%的DoomDLL类型都是结构。它们被系统地用于定义数据模型。许多项目都采用这种做法，这种方法在多线程应用程序中有一个很大的缺点。事实上，具有公共字段的结构并不是不可变的。</p><p id="9c7a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">支持使用不可变对象的一个重要理由是:它极大地简化了并发编程。想一想，为什么编写合适的多线程编程是一项艰巨的任务？因为很难同步线程对资源(对象或其他OS资源)的访问。为什么很难同步这些访问？因为很难保证多线程对多个对象进行的多次写访问和读访问之间不会出现争用情况。如果没有更多的写访问呢？换句话说，如果线程访问的对象的状态不变，那会怎样？再也不需要同步了！</p><p id="67eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们搜索至少有一个基类的类:</p><figure class="km kn ko kp fq kq fe ff paragraph-image"><div class="fe ff kz"><img src="../Images/f98479f9ecd78031b7d679703a3feb78.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/0*QJtCfH6pk6DFc2Hw.png"/></div></figure><p id="2705" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">几乎40%的结构和类都有一个基类。一般来说，在OOP中，继承的一个好处是多态性，这里蓝色的是源代码中定义的虚拟方法:</p><figure class="km kn ko kp fq kq fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff la"><img src="../Images/c09d05fc99578391ca5e82ea546f51bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IFXKbNKZ2F2L9YG4.png"/></div></div></figure><p id="dd85" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">超过30%的方法是虚拟的。它们中很少是虚拟纯的，下面是定义的所有抽象类的列表:</p><figure class="km kn ko kp fq kq fe ff paragraph-image"><div class="fe ff lb"><img src="../Images/ce1919fdd7e9f9f5962f1593fa36cb87.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/0*bmOGI7mo1_dGaQ5y.png"/></div></figure><p id="26c1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">只有52个被定义为抽象类，其中35个被定义为纯接口，即它们所有的虚方法都是纯的。</p><figure class="km kn ko kp fq kq fe ff paragraph-image"><div class="fe ff lc"><img src="../Images/e8ae79659f00bceeb7007185926b0f36.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/0*H8q6gNXy0cUjhkbe.png"/></div></figure><p id="043a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们寻找使用RTTI的方法</p><figure class="km kn ko kp fq kq fe ff paragraph-image"><div class="fe ff ld"><img src="../Images/c4096940e0bcbf9cd42bbd0ac3976271.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/0*v0n3W4caGBSC6Vn5.png"/></div></figure><p id="0215" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">只有极少数方法使用RTTI。</p><p id="af89" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">简单来说，只使用OOP的基本概念，不使用高级设计模式，不过度使用接口和抽象类，有限使用RTTI，数据被定义为结构。</p><p id="0412" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">到目前为止，这段代码与许多其他使用“带类的C”的代码没有什么特别的区别，并受到许多C++开发人员的批评。</p><p id="1480" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里是他们的开发者的一些有趣的选择，帮助我们理解它的秘密:</p><p id="057e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">1-提供一个带有有用服务的公共基类。</p><p id="94a2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">许多类继承自idClass:</p><figure class="km kn ko kp fq kq fe ff paragraph-image"><div class="fe ff le"><img src="../Images/32b853f20b4e34d3d6264fad752716fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/0*mz6ZSdMgxIrzu2YU.png"/></div></figure><p id="1fbb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">idClass提供以下服务:</p><ol class=""><li id="900a" class="jx jy hu it b iu iv iy iz jc jz jg ka jk kb jo lf kd ke kf dt translated">实例创建。</li><li id="ba42" class="jx jy hu it b iu kg iy kh jc ki jg kj jk kk jo lf kd ke kf dt translated">类型信息管理。</li><li id="1842" class="jx jy hu it b iu kg iy kh jc ki jg kj jk kk jo lf kd ke kf dt translated">事件管理。</li></ol><figure class="km kn ko kp fq kq fe ff paragraph-image"><div class="fe ff lc"><img src="../Images/b2fff7493708373c85cc190ba5ea55e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/0*G5MJ1qf9YaEqr0eY.png"/></div></figure><p id="899f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 2-让琴弦操作变得简单</strong></p><p id="b0a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一般来说，字符串是项目中最常用的类型，许多处理都是使用它们完成的，我们需要函数来操作它们。</p><p id="e015" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Doom3定义了idstr类，它包含了几乎所有操作字符串的有用方法，不需要像其他框架提供的许多string类那样定义自己的方法。</p><p id="b637" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 3-源代码与GUI框架(MFC)高度解耦</strong></p><p id="1104" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在许多使用MFC的项目中，代码与它们的类型高度耦合，您可以在代码的任何地方找到来自MFC的类型。</p><p id="14d2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Doom3中，代码与MFC高度解耦，只有GUI类与它直接相关。如以下CQLinq查询所示:</p><figure class="km kn ko kp fq kq fe ff paragraph-image"><div class="fe ff lg"><img src="../Images/afe94b239d595a806d406d7d11761347.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/0*br3XDSoVOQA41OnF.png"/></div></figure><p id="6bb6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个选择对生产率有很大的影响。事实上，只有Gui开发人员必须关心MFC框架，对于其他开发人员来说，在MFC上浪费时间并不是强制性的。</p><p id="6c18" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">4-它提供了一个非常好的实用程序库(idlib) </p><p id="d0ca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在几乎所有项目中，最常用的类型是实用程序类，如以下查询的结果所示:</p><figure class="km kn ko kp fq kq fe ff paragraph-image"><div class="fe ff lh"><img src="../Images/9df8a96f42f62f4b8858c248da8fa6b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/0*kqfX9y4I9dcgYEtE.png"/></div></figure><p id="7097" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如我们所观察到的，使用最多的是公用设施。如果C++开发人员没有为实用程序使用一个好的框架，他们会把大部分开发时间花在与技术层斗争上。</p><p id="ca23" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">idlib提供了有用的类，包括处理字符串、容器和内存所需的所有方法。这方便了开发人员的工作，让他们更专注于游戏逻辑。</p><p id="7c2f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 5-实现非常容易理解</strong></p><p id="a29b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Doom3实现了一个硬编码的编译器，正如C++开发人员所知，开发解析器和编译器并不是一件容易的事情。然而，Doom3的实现非常容易理解，它的代码非常简洁。</p><p id="acc8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是编译器使用的类的依赖图:</p><figure class="km kn ko kp fq kq fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff li"><img src="../Images/e997cfbc83aa611fb66c90a024aea4c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SRN32IW0x2n2pHT8.png"/></div></div></figure><p id="872e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是编译器源代码中的一段代码:</p><figure class="km kn ko kp fq kq fe ff paragraph-image"><div class="fe ff lj"><img src="../Images/864adce688909afd1b26392625401e55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/0*UEHukIcXOffLYl5j.png"/></div></figure><p id="a76c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们已经研究了许多解析器和编译器的源代码。但这是我们第一次发现一个源代码非常容易理解的编译器，对整个Doom3源代码都一样。这是魔法。当我们探索Doom3源代码时，我们不能说:哇，真漂亮！</p><p id="f101" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">总结</strong></p><p id="517c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">即使Doom3的设计选择非常基本，但它的设计者做出许多决定，让开发者更多地关注游戏逻辑，并促进所有技术层的东西。这大大提高了生产率。</p><p id="2907" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，当使用“带类的C”时，你必须确切地知道你在做什么。你必须像Doom3开发者一样成为专家。不建议初学者冒险忽略现代C++的建议。</p></div></div>    
</body>
</html>