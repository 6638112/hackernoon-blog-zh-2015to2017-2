<html>
<head>
<title>Chrome Preconnect Breaks Singly Threaded Servers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Chrome Preconnect打破了单线程服务器</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/chrome-preconnect-breaks-singly-threaded-servers-95944be16400?source=collection_archive---------19-----------------------#2017-11-13">https://medium.com/hackernoon/chrome-preconnect-breaks-singly-threaded-servers-95944be16400?source=collection_archive---------19-----------------------#2017-11-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="5894" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我想分享我在使用<a class="ae jp" href="https://www.revenuecat.com" rel="noopener ugc nofollow" target="_blank"> RevenueCat </a>网络应用和<a class="ae jp" href="https://hackernoon.com/tagged/api" rel="noopener ugc nofollow" target="_blank"> API </a>时的一个小发现。</p><p id="6d22" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我注意到，我的AJAX请求经常被“卡住”,近一分钟都没有完成。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/4a3b9e8ef6c0655e21ee8aaef7c74967.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WtJd4PP-9715Dzu70KE43g.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">.Chrome inspector showed the following.</figcaption></figure><p id="e715" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请求的首字节时间(TTFB)太高。我运行的是一个简单的单线程Flask服务器，只处理来自web应用程序的一个GET请求，但是这种情况几乎每次都会发生。</p><p id="7e2c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<a class="ae jp" href="https://github.com/corydolphin/flask-cors/issues/147" rel="noopener ugc nofollow" target="_blank">发现</a> <a class="ae jp" href="https://github.com/pallets/flask/issues/2169" rel="noopener ugc nofollow" target="_blank">许多</a> <a class="ae jp" href="https://github.com/benoitc/gunicorn/issues/1284" rel="noopener ugc nofollow" target="_blank">其他</a>人有同样的问题后，我开始清除我的堆栈的某些部分，以找出导致挂起的原因。最终，我发现唯一能解决这个问题的方法，也是许多其他人发现的方法，是将Flask dev服务器切换到线程模式来解决这个问题。</p><p id="8d9f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我只发送了一个请求，服务器怎么会被锁定？</p><h1 id="238e" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">铬预连接</h1><p id="3a2b" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">原来写Chrome的人真的很聪明。它们所做的事情之一是先发制人地打开与服务器的TCP连接，您可能会向这些服务器发出后续的HTTP请求。这很有意义，当你的网站要求Chrome从你的服务器加载index.css时，你很有可能会在那之后加载另一个资源。为了加快速度，Chrome在加载第一个请求时会打开第二个与服务器的推测性TCP连接。</p><h2 id="dac9" class="lk kh hu bd ki ll lm ln km lo lp lq kq jc lr ls ku jg lt lu ky jk lv lw lc lx dt translated">僵局</h2><p id="851f" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">如果您使用单线程服务器进行开发，这可能是一个真正的问题。通常，服务器会处理你的真实请求，然后Chrome会关闭未使用的推测连接。然而，如果推测性连接是由你的服务器首先打开的，Chrome只是保持它打开，而服务器无法服务真正的请求。这导致大多数单线程服务器超时等待推测连接发出请求。最终超时，实际的请求很快完成。</p><h2 id="eeaa" class="lk kh hu bd ki ll lm ln km lo lp lq kq jc lr ls ku jg lt lu ky jk lv lw lc lx dt translated">工作区</h2><p id="944d" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">对于Flask，dev环境中最简单的解决方法是用<code class="eh ly lz ma mb b">threaded=True</code>运行dev服务器，这允许服务器在不阻塞的情况下服务两个连接。但是生产呢？这取决于您的应用程序是如何部署的。如果你的应用程序背后是一个像nginx这样的重型反向代理，你不需要担心，因为它会同时正确地服务两个请求，并将真正的请求代理到你的服务器。如果你只使用类似gunicorn的东西，你将需要确保你使用一个异步工作器模型，因为同步工作器仍然会被挂起。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mc md l"/></div></figure></div></div>    
</body>
</html>