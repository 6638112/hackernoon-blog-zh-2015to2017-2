<html>
<head>
<title>Building a Blockchain DApp using truffle, React, Next.js and MobX (part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用truffle、React、Next.js和MobX构建区块链DApp(第二部分)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/building-a-blockchain-dapp-using-truffle-react-next-js-and-mobx-part-2-847193b497e4?source=collection_archive---------6-----------------------#2017-10-13">https://medium.com/hackernoon/building-a-blockchain-dapp-using-truffle-react-next-js-and-mobx-part-2-847193b497e4?source=collection_archive---------6-----------------------#2017-10-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/37abe7d0245602e8b495886e02ed4216.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ncy6Q6DUc-HRFPcfxQV6BA.png"/></div></div></figure><p id="0479" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是第二篇带领你使用truffle、React、Next.js和MobX构建一个<a class="ae ka" href="https://hackernoon.com/tagged/blockchain" rel="noopener ugc nofollow" target="_blank">区块链</a> DApp的文章。</p><p id="ae3b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作为一个快速提醒，我们将使用区块链(<a class="ae ka" href="https://hackernoon.com/tagged/ethereum" rel="noopener ugc nofollow" target="_blank">以太坊</a>)作为一种有效的方式来处理用户和他们喜爱的电视节目的映射。</p><p id="05fb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该应用程序显示了来自非官方API的烂番茄列表。分为三类:新鲜，新，流行。</p><p id="68a2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">应用程序“书签”中的一个特殊部分显示了当前存储在区块链上的用户最喜爱的节目列表。</p><p id="2cc7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">用户可以在他们的书签部分添加或删除节目。每次用户添加或删除节目时，都会调用智能合约功能，并将更改存储在区块链上。</p><p id="9fe4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">前端应用程序是由<a class="ae ka" href="https://github.com/zeit/next.js/" rel="noopener ugc nofollow" target="_blank"> Next.js </a>支持的服务器端渲染React应用程序，对于状态管理，我们将使用M <a class="ae ka" href="https://mobx.js.org/" rel="noopener ugc nofollow" target="_blank"> ob </a> X，样式和布局将来自令人敬畏的<a class="ae ka" href="http://tachyons.io/" rel="noopener ugc nofollow" target="_blank"> tachyons </a>项目，为了与区块链交互，我们将在solidity中编写一个智能联系人，用JavaScript为其编写测试，并使用<a class="ae ka" href="http://truffleframework.com/" rel="noopener ugc nofollow" target="_blank"> truffle </a>在本地部署它。</p><p id="28d5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<a class="ae ka" href="https://hackernoon.com/building-a-blockchain-dapp-using-truffle-react-next-js-and-mobx-part-i-c46d218f4bdf" rel="noopener ugc nofollow" target="_blank">上一篇文章</a>中，我们回顾了充当我们的应用后端逻辑和存储的智能合约的实现。在本帖中，我们将重点讨论如何使用React构建UI，以及如何在浏览器中调用智能合约上的操作。</p><p id="f83e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这篇文章中，我将详细介绍:</p><ol class=""><li id="523c" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">设置开发环境</li><li id="bc93" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">编写我们的后端API</li><li id="9df5" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">编写我们的React组件</li><li id="8cac" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">编写我们的MobX存储来处理应用程序状态的变化。</li><li id="9301" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">编写将调用我们的智能契约公共API的区块链服务。</li></ol><h2 id="d2c0" class="kp kq hu bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated">设置开发环境</h2><p id="5732" class="pw-post-body-paragraph jc jd hu je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">在开始之前，请确保您已经安装了node、git和nvm。</p><p id="9273" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先我们需要安装TestRpc和Truffle:</p><ul class=""><li id="dccc" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz lp kh ki kj dt translated"><code class="eh lq lr ls lt b">npm install -g ethereumjs-testrpc</code></li><li id="df92" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz lp kh ki kj dt translated"><code class="eh lq lr ls lt b">npm install -g truffle</code></li></ul><p id="1ef8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在克隆应用程序并安装依赖项:</p><pre class="lu lv lw lx fq ly lt lz ma aw mb dt"><span id="828c" class="kp kq hu lt b fv mc md l me mf">//clone the repo<br/>git clone <a class="ae ka" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:liors/tvdapp.git</span><span id="332e" class="kp kq hu lt b fv mg md l me mf">// Navigate to within the directory<br/>cd tvdapp</span><span id="6c54" class="kp kq hu lt b fv mg md l me mf">//install dependencies<br/>yarn install</span><span id="591f" class="kp kq hu lt b fv mg md l me mf">//start the development server<br/>yarn dev</span></pre><p id="02c6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在新的终端窗口中启动本地区块链网络:</p><pre class="lu lv lw lx fq ly lt lz ma aw mb dt"><span id="0571" class="kp kq hu lt b fv mc md l me mf">testrpc</span></pre><p id="9f45" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们需要编译和迁移我们的智能契约运行:</p><pre class="lu lv lw lx fq ly lt lz ma aw mb dt"><span id="86e7" class="kp kq hu lt b fv mc md l me mf">yarn run blockchain</span></pre><p id="61cf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦你运行了以上所有的推荐，你就可以在<a class="ae ka" href="http://localhost:3020/tv/fresh" rel="noopener ugc nofollow" target="_blank">打开你的浏览器http://localhost:3020/TV/fresh</a>并查看应用的本地版本。</p><h2 id="9e12" class="kp kq hu bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated">我们的后端API</h2><p id="99c6" class="pw-post-body-paragraph jc jd hu je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">Next.js带有默认的express配置。在某些情况下，这很好，在我们的例子中，我想将路由添加到我们的API请求中，所以我使用了一个定制的express服务器。</p><p id="d613" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在/server下，您可以找到两个文件index.js和api.js</p><p id="9f05" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看一下index.js</p><figure class="lu lv lw lx fq iv"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="4585" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的API有3个端点:</p><ol class=""><li id="16d3" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">/api/shows/new</li><li id="e5e2" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">/API/显示/流行</li><li id="8698" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">/API/显示/新鲜</li></ol><p id="a53e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它们都使用我们从api.js导出的相同的api.get函数。此外，我们将一些get请求别名到我们的main /tv/fresh路由，因此当用户访问/ or /tv时，我们将他重定向到我们的/tv/fresh页面。所有其他请求，即' * '将由next.js默认路由处理。</p><p id="0bd7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们后端代码的最后一部分是从<a class="ae ka" href="https://www.rottentomatoes.com/" rel="noopener ugc nofollow" target="_blank">烂番茄</a>获取内容，并用来自<a class="ae ka" href="http://tvmaze.com" rel="noopener ugc nofollow" target="_blank"> tvmaze </a>的图像丰富返回数据。</p><p id="766b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看一下api.js</p><figure class="lu lv lw lx fq iv"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="4e46" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们导出一个接收类型的get函数。然后，我们发出请求，并将结果映射到标题和URL的数组中。</p><p id="7eb9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">IMO <a class="ae ka" href="http://tvmaze.com" rel="noopener ugc nofollow" target="_blank"> tvmaze </a>提供了质量更好的图像，所以让我们通过为每个节目获取一组图像来丰富我们的API。</p><p id="a482" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Async/await语法有助于我们避免嵌套回调，并有望创建一个可读性更好、更干净的代码。</p><p id="7986" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的get函数返回一个包含JSON对象数组的承诺，每个对象包含一个标题和一个img对象。</p><h2 id="ccad" class="kp kq hu bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated">我们的React组件</h2><p id="91b5" class="pw-post-body-paragraph jc jd hu je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">Next.js提供了一个非常简单的routes API。您只需要创建一个pages文件夹，该文件夹下的每个文件都将成为为该路径呈现的主要react组件。例如/pages/index.js将是您的应用程序主页，即默认路径/。</p><p id="f92c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们的例子中，主页面路径位于/pages/tv/fresh.js下</p><figure class="lu lv lw lx fq iv"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="f144" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Next.js还通过引入一个名为<a class="ae ka" href="https://zeit.co/blog/next" rel="noopener ugc nofollow" target="_blank"> getInitialProps </a>的新生命周期函数，提供了一种在服务器和客户机上获取数据的方法。当实现它时，我们必须返回一个解析为JavaScript对象的<code class="eh lq lr ls lt b">Promise</code>,然后这个对象填充组件的<code class="eh lq lr ls lt b">props.</code></p><p id="7493" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们首先调用我们的API — /api/tv/fresh，并用结果显示启动我们的存储。然后，该函数返回我们的组件props: shows，以及我们是否在服务器上渲染结果。</p><p id="51e4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的渲染函数非常简单——我们只需渲染一个页面组件，并传递给它两个属性:type和store。</p><p id="58fa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们所有的页面/路线看起来非常相似，不同的是页面类型和商店，其中包含给定类型的相关节目。</p><p id="68dd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看看我们的页面组件。</p><figure class="lu lv lw lx fq iv"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="95fc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该组件使用两个附加组件——我们的应用程序导航和节目网格。所选页面是当前的道具类型。我们的渲染功能是用MobX提供者包装的，因为这是我们应用程序的主要组件。</p><p id="4383" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个组件还有另一个职责。只有在客户端上运行时，即在React的<code class="eh lq lr ls lt b">componentDidMount</code>函数中，我们才设置我们的web3实例，一旦完成，我们就向我们的智能合约发出请求，以获取已经被书签标记的节目。一旦这个请求被解决，我们更新我们的商店，这导致我们的应用程序重新呈现，如果需要的话。</p><p id="4fe4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看看我们的主UI组件shows.js</p><figure class="lu lv lw lx fq iv"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="0d11" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的渲染功能使用了来自<a class="ae ka" href="http://tachyons.io/components/collections/square-title-subtitle/index.html" rel="noopener ugc nofollow" target="_blank"> tachyons.io </a>的“方形标题字幕”布局。为了让我们的应用程序识别这些css类(例如cf、w-100、pa2-ns等)，我们需要包含tachyons css文件。</p><p id="be12" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Next.js通过创建一个_document.js提供了一种定制由服务器生成的主html的方法，它允许您返回一个包含head标签的html块。</p><p id="746f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们的例子中，我们将设置视口并包含一些我们使用的外部资源——字体、css文件和web3库。</p><pre class="lu lv lw lx fq ly lt lz ma aw mb dt"><span id="b15a" class="kp kq hu lt b fv mc md l me mf">&lt;Head&gt;<br/>   &lt;meta charSet='utf-8' /&gt;<br/>   &lt;meta name='viewport' content='initial-scale=1.0, width=device-width' /&gt;<br/>   &lt;link href='//fonts.googleapis.com/css?family=Roboto' rel="stylesheet" /&gt;<br/>   &lt;link href='//cdnjs.cloudflare.com/ajax/libs/tachyons/4.8.1/tachyons.min.css' rel='stylesheet' /&gt;<br/>   &lt;link href='//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css' rel='stylesheet' /&gt;<br/>   &lt;script src='/static/js/web3.min.js'&gt;&lt;/script&gt;<br/>&lt;/Head&gt;</span></pre><p id="bf05" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">回到我们的节目组件——一旦我们呈现了我们的节目，我们需要为已经被书签标记的节目和没有被书签标记的节目显示不同的SVG。我们通过查看我们商店中的书签展示系列来做到这一点:</p><pre class="lu lv lw lx fq ly lt lz ma aw mb dt"><span id="ffa1" class="kp kq hu lt b fv mc md l me mf">isBookmarked = show =&gt; some(this.props.store.bookmarkedShows, show)</span></pre><p id="23d2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有些是一个<a class="ae ka" href="https://lodash.com/docs/4.17.4#some" rel="noopener ugc nofollow" target="_blank"> lodash </a>函数，它检查在这个例子中的【identity是否为<strong class="je hv">的任何</strong>元素(在我们的例子中是我们的节目列表)返回true。</p><p id="4c35" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们需要实现书签操作。我们通过用锚标记包装title/subtitle/bookmark SVG元素并在其上定义onClick函数来实现这一点:</p><pre class="lu lv lw lx fq ly lt lz ma aw mb dt"><span id="8adf" class="kp kq hu lt b fv mc md l me mf">handleBookmark = show =&gt; this.props.store.bookmark(show)</span></pre><p id="808f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的最后一个react组件是通知组件，它向用户提供一个指示，表明一个节目被添加/从区块链中删除，您可以在/components/notification.js下找到它</p><h2 id="eea4" class="kp kq hu bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated">我们的MobX商店处理应用程序状态变化</h2><p id="76b8" class="pw-post-body-paragraph jc jd hu je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">正如我们在组件实现中看到的，我们没有任何<code class="eh lq lr ls lt b">this.setState()</code>调用来重新呈现组件或获取请求以获取/更改数据。我们的MobX商店为我们处理这个问题，并为我们提供UI所需的核心API。</p><figure class="lu lv lw lx fq iv"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="72d8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们商店支持以下行动:</p><ol class=""><li id="8b6b" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">书签——这充当我们的UI的书签/移除动作的切换。</li><li id="c140" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">setBookmarkShows —设置来自区块链的初始书签显示。</li><li id="18ba" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">hideboorknotification——这有助于在需要时隐藏通知组件。</li></ol><p id="ae5e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们更详细地看看我们的书签功能。</p><p id="5748" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们首先检查所提供的节目是否已经被书签标记——如果没有，我们使用blockChainService的bookmarkContract函数。作为一个参数，该函数获得一个JSON，表示要添加书签的节目——该JSON将存储在区块链上。</p><p id="8dc9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦请求得到解决，我们就将节目添加到我们的observable shows数组中，打开通知标志并设置适当的动作类型——这将有助于通知组件显示适当的文本。</p><p id="cc5c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要删除/拒绝已经被书签标记的节目，我们调用rejectBookmarkContract并从我们的可观察节目数组中过滤掉该节目。</p><h2 id="22cf" class="kp kq hu bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated">我们的区块链服务调用我们的智能契约公共API</h2><p id="948a" class="pw-post-body-paragraph jc jd hu je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">我们到了应用程序的最后一部分，这个服务使用以太坊的web3来调用智能合约上的远程功能。让我们看看服务getBookmarks是如何实现的:</p><pre class="lu lv lw lx fq ly lt lz ma aw mb dt"><span id="11d5" class="kp kq hu lt b fv mc md l me mf">let getBookmarks = function () {<br/>   return new Promise((resolve, reject) =&gt; {<br/>      let instance<br/>      getBookmarkInstance()<br/>         .then(result =&gt; ({instance} = result))<br/>         .then(() =&gt; instance.getBookmarks.call())<br/>         .then(bookmarks =&gt; {<br/>            resolve(bookmarks &amp;&amp; JSON.parse(bookmarks.toString()))<br/>         })<br/>      })<br/>}</span></pre><p id="555a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了调用任何智能契约功能，我们需要获得可用的web3实例。我们通过从truffle-contract导入BookmarkArtifact和contract函数来实现这一点</p><pre class="lu lv lw lx fq ly lt lz ma aw mb dt"><span id="d1d0" class="kp kq hu lt b fv mc md l me mf">import BookmarkArtifact from '../build/contracts/Bookmark'<br/>import contract from 'truffle-contract'</span></pre><p id="1dd1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，我们为工件提供契约函数，并将其提供者设置为当前的web3实例当前提供者。</p><pre class="lu lv lw lx fq ly lt lz ma aw mb dt"><span id="8f7a" class="kp kq hu lt b fv mc md l me mf">const Bookmark = contract(BookmarkArtifact)<br/>Bookmark.setProvider(web3Instance.currentProvider)</span></pre><p id="a503" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦我们这样做了，我们就可以获得帐户并返回第一个帐户的已部署实例。</p><pre class="lu lv lw lx fq ly lt lz ma aw mb dt"><span id="5c00" class="kp kq hu lt b fv mc md l me mf">web3Instance.eth.getAccounts((error, accounts) =&gt; {<br/>   const account = accounts[0]<br/>   Bookmark.deployed().then((instance) =&gt; {<br/>      resolve({ instance, account })<br/>   })<br/>})</span></pre><p id="ce30" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">好了，回到getBookmarks函数。一旦有了实例，我们就可以调用我们的智能契约公共API。在这种情况下，我们需要获得我们的书签显示，即调用getBookmarks</p><pre class="lu lv lw lx fq ly lt lz ma aw mb dt"><span id="b357" class="kp kq hu lt b fv mc md l me mf">instance.getBookmarks.call()<br/>   .then(bookmarks =&gt; {<br/>      resolve(bookmarks &amp;&amp; JSON.parse(bookmarks.toString()))<br/>   })</span></pre><p id="93cb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">结果将是一个字符串，我们解析它并将其转换成一个JSON对象。</p><p id="e468" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">给一个节目做书签看起来非常相似。我们首先获取一个实例，然后调用我们的书签函数，在这种情况下，我们需要提供一些额外的信息——这个操作是从哪个帐户发生的。</p><pre class="lu lv lw lx fq ly lt lz ma aw mb dt"><span id="2ba1" class="kp kq hu lt b fv mc md l me mf">instance.bookmark(JSON.stringify(blockchainBookmarks), { from: account })<br/>    .then(showId =&gt; instance.getBookmarks.call())<br/>    .then(bookmarks =&gt; {<br/>        resolve({ data: JSON.parse(bookmarks.toString()) })<br/>    })</span></pre><p id="389e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就这样，我们的应用程序完成了。</p><p id="ceac" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">总而言之，我们一直在使用React、Next.js、MobX和truffle来构建一个服务器端渲染React DApp。我希望你可以利用这个简单的设置在区块链上开始自己的开发。</p><p id="ac1b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">github 上有完整的代码，如果你喜欢，请开始回购！</p><p id="f741" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该应用的一个实时版本部署在<a class="ae ka" href="https://tvdapp.herokuapp.com" rel="noopener ugc nofollow" target="_blank">这里</a>——请确保你的浏览器可以运行DApps，我一直在使用<a class="ae ka" href="https://metamask.io/" rel="noopener ugc nofollow" target="_blank"> MetaMask </a> chrome扩展。</p><p id="0c1c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">感谢阅读。希望这对你有帮助。</p><figure class="lu lv lw lx fq iv"><div class="bz el l di"><div class="mj mi l"/></div></figure></div></div>    
</body>
</html>