<html>
<head>
<title>Coping with (Code) Failures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应对(代码)失败</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/coping-with-code-failures-f15e60d07bb7?source=collection_archive---------20-----------------------#2017-07-31">https://medium.com/hackernoon/coping-with-code-failures-f15e60d07bb7?source=collection_archive---------20-----------------------#2017-07-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="48bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">异常处理很烦人。如果世界上的一切都按照它应该的方式运行，那就完全没有必要了。当然，这只是一种幻想。哈斯克尔不能改变现实。但是它的错误设施比大多数语言好得多。本周我们将看看一些常见的错误处理模式。我们将看到几个Haskell代码更简单、更清晰的例子。</p><h1 id="9912" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">什么都不用</h1><p id="e768" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">Haskell中最基本的例子是<code class="eh ks kt ku kv b">Maybe</code>类型。这允许我们封装任何有可能失败的计算。为什么这比其他语言的类似想法要好？让我们以Java为例。当你处理指针类型时，封装<code class="eh ks kt ku kv b">Maybe</code>很容易。你可以使用“空”指针作为你的失败案例。</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="0971" class="le jq hu kv b fv lf lg l lh li">public MyObject squareRoot(int x) {<br/>  if (x &lt; 0) {<br/>    return nil;<br/>  } else {<br/>    return MyObject(Math.sqrt(x));<br/>  }<br/>}</span></pre><p id="4d18" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是这有几个缺点。首先，空指针(一般来说)看起来和类型检查器的常规指针一样。这意味着编译时不能保证你处理的任何指针都不为空。想象一下，如果我们必须把每个Haskell值都放在一个Maybe中。我们需要不断地解开它们，否则就有触发“空指针异常”的风险。在Haskell中，一旦我们处理了<code class="eh ks kt ku kv b">Nothing</code>的情况，我们就可以传递一个纯值。这使得其他代码知道它不会抛出随机错误。考虑这个例子。我们检查我们的指针已经在<code class="eh ks kt ku kv b">function1</code>中非空一次。尽管如此，良好的编程实践要求我们在<code class="eh ks kt ku kv b">function2</code>中执行另一项检查。</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="782a" class="le jq hu kv b fv lf lg l lh li">public void function1(MyObject obj) {<br/>  if (obj == null) {<br/>    // Deal with error<br/>  } else {<br/>    function2(obj);<br/>  }<br/>}</span><span id="25b3" class="le jq hu kv b fv lj lg l lh li">public void function2(MyObject obj) {<br/>  if (obj == null) {<br/>    // ^^ We should be able to make this call redundant<br/>  } else {<br/>    // …<br/>  }<br/>}</span></pre><p id="baf5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们处理非指针的原始值时，第二个棘手的问题出现了。我们往往没有很好的办法来处理这些情况。假设您的函数返回一个<code class="eh ks kt ku kv b">int</code>，但是它可能会失败。你如何代表失败？通过使用“哨兵”值(如0或-1)来处理这种情况并不少见。</p><p id="2ace" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是如果你的函数范围跨越了所有的整数，你就有点困在那里了。如果使用枚举类型，代码可能看起来更干净，但这并不能避免问题。如果null在特定的上下文中是有效的，那么指针值也会出现同样的问题。</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="86c5" class="le jq hu kv b fv lf lg l lh li">public int integerSquareRoot(int x) {<br/>  if (x &lt; 0) {<br/>    return -1;<br/>  } else {<br/>    return Math.round(Math.sqrt(x));<br/>  }<br/>}</span><span id="f5e4" class="le jq hu kv b fv lj lg l lh li">public void (int a) {<br/>  int result = integerSquareRoot(a);<br/>  if (result == -1) {<br/>    // Deal with error<br/>  } else {<br/>    // Use correct value<br/>  }<br/>}</span></pre><p id="7f38" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，Haskell中带有<code class="eh ks kt ku kv b">Maybe</code>的一元复合更加自然。Java代码中有很多这种意大利面条的例子:</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="bb6a" class="le jq hu kv b fv lf lg l lh li">public Result computation1(MyObject value) {<br/>  …<br/>}</span><span id="af0c" class="le jq hu kv b fv lj lg l lh li">public Result computation2(Result res) {<br/>  …<br/>}</span><span id="0fb9" class="le jq hu kv b fv lj lg l lh li">public int intFromResult(Result res) {<br/>  …<br/>}</span><span id="4cf7" class="le jq hu kv b fv lj lg l lh li">public int spaghetti(MyObject value) {<br/>  if (value != null) {<br/>    result1 = computation1(value);<br/>    if (result1 != null) {<br/>      result2 = computation2(result1);<br/>      if (result2 != null) {<br/>        return intFromResult(result2);<br/>      }<br/>    }<br/>  }<br/>  return -1;<br/>}</span></pre><p id="1d61" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们太天真，我们可能会得到一个不那么漂亮的版本:</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="797f" class="le jq hu kv b fv lf lg l lh li">computation1 :: MyObject -&gt; Maybe Result<br/>computation2 :: Result -&gt; Maybe Result<br/>intFromResult :: Result -&gt; Int</span><span id="cec6" class="le jq hu kv b fv lj lg l lh li">spaghetti :: Maybe MyObject -&gt; Maybe Int<br/>spaghetti value = case value of<br/>  Nothing -&gt; Nothing<br/>  Just realValue -&gt; case computation1 realValue of<br/>    Nothing -&gt; Nothing<br/>    Just result1 -&gt; case computation2 result1 of<br/>      Nothing -&gt; Nothing<br/>      Just result2 -&gt; return $ intFromResult result2</span></pre><p id="5d54" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是正如我们在我们的第一篇<a class="ae lk" href="https://mmhaskell.com/blog/2017/2/13/finally-understanding-monads-part-1" rel="noopener ugc nofollow" target="_blank">单子文章</a>中讨论的，我们可以让它更干净。我们将在<code class="eh ks kt ku kv b">Maybe</code>单子中组合我们的动作:</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="60f7" class="le jq hu kv b fv lf lg l lh li">cleanerVersion :: Maybe MyObject -&gt; Maybe Int<br/>cleanerVersion value = do<br/>  realValue &lt;- value<br/>  result1 &lt;- computation1 realValue<br/>  result2 &lt;- computation2 result1<br/>  return $ intFromResult result2</span></pre><h1 id="575f" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">使用任何一种</h1><p id="4672" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">现在假设我们想让我们的错误包含更多的信息。在上面的例子中，如果失败，我们将输出<code class="eh ks kt ku kv b">Nothing</code>。但是调用该函数的代码将无法知道错误究竟是什么。这可能会妨碍我们的代码纠正错误的能力。我们也没有办法向用户报告具体的失败。正如我们已经探索过的，Haskell对此的回答是<code class="eh ks kt ku kv b">Either</code>单子。这允许我们附加任何类型的值作为可能的失败。在这种情况下，我们将改变每个函数的类型。然后，我们将更新函数，使用描述性的错误消息，而不是返回<code class="eh ks kt ku kv b">Nothing</code>。</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="d227" class="le jq hu kv b fv lf lg l lh li">computation1 :: MyObject -&gt; Either String Result<br/>computation2 :: Result -&gt; Either String Result<br/>intFromResult :: Result -&gt; Int</span><span id="03f4" class="le jq hu kv b fv lj lg l lh li">eitherVersion :: Either String MyObject -&gt; Either String Int<br/>eitherVersion value = do<br/>  realValue &lt;- value<br/>  result1 &lt;- computation1 realValue<br/>  result2 &lt;- computation2 result1<br/>  return $ intFromResult result2</span></pre><p id="f4fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在假设我们想在Java中实现这一点。我们如何做到这一点？我知道有几个选择。都不是特别有食欲。</p><ol class=""><li id="6ca1" class="ll lm hu it b iu iv iy iz jc ln jg lo jk lp jo lq lr ls lt dt translated">弹出故障条件时打印错误信息。</li><li id="76ca" class="ll lm hu it b iu lu iy lv jc lw jg lx jk ly jo lq lr ls lt dt translated">当失败条件出现时，更新一个全局变量。</li><li id="c111" class="ll lm hu it b iu lu iy lv jc lw jg lx jk ly jo lq lr ls lt dt translated">创建可能包含错误值或成功值的新数据类型。</li><li id="0f86" class="ll lm hu it b iu lu iy lv jc lw jg lx jk ly jo lq lr ls lt dt translated">向函数添加一个参数，如果出现故障，该参数的值将被填入一条错误消息。</li></ol><p id="32ad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第一对夫妇依赖于任意的副作用。作为Haskell程序员，我们不喜欢这些。第三种选择需要弄乱Java的模板类型。这些类型比Haskell的参数化类型更难处理。如果我们不采用这种方法，我们需要为每个不同的返回值创建一个新的类型。</p><p id="1dc8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后一个方法有点反模式，弥补了元组在Java中不是第一类构造的事实。检查你的一个<strong class="it hv">输入</strong>值作为一个<strong class="it hv">输出</strong>结果是非常反直觉的。有了这些选择，我随时都可以找到哈斯克尔。</p><h1 id="01e1" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">使用异常和处理程序</h1><p id="3f05" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">既然我们已经理解了代码中处理错误的更“纯粹”的方式，我们就可以处理异常了。异常出现在几乎每一种主要的编程语言中；哈斯克尔也不例外。Haskell的<code class="eh ks kt ku kv b">SomeException</code>类型封装了可能的失败条件。它可以包装任何属于<a class="ae lk" href="https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Exception.html" rel="noopener ugc nofollow" target="_blank">异常</a>类型类成员的类型。您通常会创建自己的异常类型。</p><p id="3203" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通常，当我们想要声明代码执行路径失败时，我们抛出异常。我们将允许完全不同的代码来处理错误，而不是向调用函数返回一些值。如果这听起来令人费解，那是因为它确实如此。一般来说，你希望保持控制流尽可能清晰。有时虽然我们无法避免。</p><p id="b8e4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设我们正在调用一个函数，我们知道这个函数可能会抛出一个异常。我们可以通过附加一个处理程序来“处理”这个异常。在Java中，您可以这样做:</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="2520" class="le jq hu kv b fv lf lg l lh li">public int integerSquareRoot(int value) throws NegativeSquareRootException {<br/>  ...<br/>}</span><span id="bb0b" class="le jq hu kv b fv lj lg l lh li">public int mathFunction(int x) {<br/>  try {<br/>    return 2 * squareRoot(x);<br/>  } catch (NegativeSquareRootException e) {<br/>    // Deal with invalid result<br/>  }<br/>}</span></pre><p id="28b8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要在Haskell中以这种方式处理异常，您必须能够访问IO monad。处理异常最常用的方法是使用<code class="eh ks kt ku kv b">catch</code>函数。当您调用可能抛出异常的操作时，您包含了一个“处理程序”函数。该函数将把异常作为一个参数，并处理该情况。如果我们想用Haskell编写上面的例子，我们应该首先定义我们的异常类型。我们只需要派生<code class="eh ks kt ku kv b">Show</code>来为<code class="eh ks kt ku kv b">Exception</code>类型类派生一个实例:</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="dcf6" class="le jq hu kv b fv lf lg l lh li">import Control.Exception (Exception)</span><span id="310d" class="le jq hu kv b fv lj lg l lh li">data MyException = NegativeSquareRootException<br/>  deriving (Show)</span><span id="486f" class="le jq hu kv b fv lj lg l lh li">instance Exception MyException</span></pre><p id="0adf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们可以编写一个纯粹的函数，在适当的情况下抛出这个异常。</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="ff8a" class="le jq hu kv b fv lf lg l lh li">import Control.Exception (Exception, throw)</span><span id="a51e" class="le jq hu kv b fv lj lg l lh li">integerSquareRoot :: Int -&gt; Int<br/>integerSquareRoot x<br/>  | x &lt; 0 = throw NegativeSquareRootException<br/>  | otherwise = undefined</span></pre><p id="cd93" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然我们可以从纯代码中抛出异常，但我们需要在<code class="eh ks kt ku kv b">IO</code> monad中捕捉它。我们将使用<code class="eh ks kt ku kv b">catch</code>函数来实现这一点。我们将使用一个处理函数，它将只捕捉我们预期的特定错误。它会将错误作为消息打印出来，然后返回一个空值。</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="3590" class="le jq hu kv b fv lf lg l lh li">import Control.Exception (Exception, throw, catch)</span><span id="5fe5" class="le jq hu kv b fv lj lg l lh li">…<br/>mathFunction :: Int -&gt; IO Int<br/>mathFunction input = do<br/>  catch (return $ integerSquareRoot input) handler<br/>  where<br/>    handler :: MyException -&gt; IO Int<br/>    handler NegativeSquareRootException = <br/>      print "Can't call square root on a negative number!" &gt;&gt; return (-1)</span></pre><h1 id="0f42" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">MonadThrow</h1><p id="b490" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">我们也可以把这个过程推广到不同的单子上。typeclass允许我们为不同的单子指定不同的异常行为。例如，<code class="eh ks kt ku kv b">Maybe</code>通过使用<code class="eh ks kt ku kv b">Nothing</code>抛出异常。<code class="eh ks kt ku kv b">Either</code>使用<code class="eh ks kt ku kv b">Left</code>，<code class="eh ks kt ku kv b">IO</code>将使用<code class="eh ks kt ku kv b">throwIO</code>。当我们在一个普通的<code class="eh ks kt ku kv b">MonadThrow</code>函数中时，我们用<code class="eh ks kt ku kv b">throwM</code>抛出异常。</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="4c84" class="le jq hu kv b fv lf lg l lh li">callWithMaybe :: Maybe Int<br/>callWithMaybe = integerSquareRoot (-5) -- Gives us `Nothing`</span><span id="c00f" class="le jq hu kv b fv lj lg l lh li">callWithEither :: Either SomeException Int<br/>callWithEither = integerSquareRoot (-5) -- Gives us `Left NegativeSquareRootException`</span><span id="6542" class="le jq hu kv b fv lj lg l lh li">callWithIO :: IO Int<br/>callWithIO = integerSquareRoot (-5) -- Throws an error as normal</span><span id="b7fb" class="le jq hu kv b fv lj lg l lh li">integerSquareRoot :: (MonadThrow m) =&gt; Int -&gt; m Int<br/>integerSquareRoot x<br/>  | x &lt; 0 = throwM NegativeSquareRootException<br/>  | otherwise = ...</span></pre><p id="77d1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">关于额外的抽象层是否有帮助还有一些争论。有一个强有力的例子说明，如果你要使用异常控制流，你无论如何都应该使用<code class="eh ks kt ku kv b">IO</code>。但是使用<code class="eh ks kt ku kv b">MonadThrow</code>可以让你的代码更具可扩展性。您的函数可能在代码库的更多区域可用。在这个话题上我不是太固执己见(至少现在还不是)。但是在Haskell社区中肯定有一些强烈的意见。</p><h1 id="985b" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">摘要</h1><p id="a5bd" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">错误处理是棘手的事情。许多常见的错误处理编程模式写起来很烦人。幸运的是，Haskell有几种不同的方法可以做到这一点。在Haskell中，您可以使用类似于<code class="eh ks kt ku kv b">Maybe</code>和<code class="eh ks kt ku kv b">Either</code>的简单机制来表达错误。它们的一元行为给了你高度的可组合性。您还可以像在其他语言中一样抛出和捕捉异常。但是Haskell有一些更通用的方法来做到这一点。这允许您不知道代码中的函数如何处理错误。</p><p id="5d49" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">初次接触Haskell？惊叹于它的牛逼，想试试？下载我们的<a class="ae lk" href="https://www.mmhaskell.com/checklist" rel="noopener ugc nofollow" target="_blank">入门清单</a>！它有一些很棒的工具和指导，可以让你在电脑上安装Haskell并开始使用。</p><p id="e982" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你试过Haskell但是想要更多的练习吗？查看我们的<a class="ae lk" href="https://www.mmhaskell.com/workbook" rel="noopener ugc nofollow" target="_blank">递归练习册</a>，获取一些精彩内容和10个练习题！</p><p id="71c9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请继续关注周一早上哈斯克尔的博客！</p></div></div>    
</body>
</html>