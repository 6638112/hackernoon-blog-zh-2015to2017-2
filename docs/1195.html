<html>
<head>
<title>Optimizing optimizing: some insights that led to a 400% speedup of PowerDNS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化优化:导致PowerDNS加速400%的一些见解</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/optimizing-optimizing-some-insights-that-led-to-a-400-speedup-of-powerdns-5e1a44b58f1c?source=collection_archive---------0-----------------------#2016-09-22">https://medium.com/hackernoon/optimizing-optimizing-some-insights-that-led-to-a-400-speedup-of-powerdns-5e1a44b58f1c?source=collection_archive---------0-----------------------#2016-09-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="ea05" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以不管你的代码有多漂亮，最终总会有人<a class="ae jp" href="https://hackernoon.com/tagged/benchmark" rel="noopener ugc nofollow" target="_blank">对它进行基准测试</a>并要求最高的性能。挤压微秒是一种非常容易上瘾，甚至是破坏性的活动。它破坏了你的夜晚，破坏了你与人交流的能力，通常会让你的代码变得一团糟。</p><p id="848e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，没有一个程序员可以逃避这个问题:这个世界需要速度，或者一个相当的现代标准，更长的电池寿命。</p><p id="9145" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">挤出更多的性能不仅仅是“写出更好的代码”的问题。这是一门艺术。在过去的30年里，我取得了一些成功，但许多性能改进都是在太长的时间之后才实现的。也有很多误导性的建议。</p><p id="e15e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这篇文章中，我将强调我多年来学到的一些东西。</p><blockquote class="jq jr js"><p id="f37b" class="ir is jt it b iu iv iw ix iy iz ja jb ju jd je jf jv jh ji jj jw jl jm jn jo hn dt translated">注意:这不是一个优化教程，但它可能有助于形成一种有用的心态。</p></blockquote><h2 id="a22e" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">宽刷优化</h2><p id="206a" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">所以这真的是神奇的调味汁(或者蛇油，如果你愿意的话)。“不要使用引用计数指针”。“使用无锁代码”。“离STL远点”。这通常是相当无用的，也是相当不科学的建议，因为它很难伪造。</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div class="fe ff kx"><img src="../Images/fd118ad20facc771b5881d93d5da6001.png" data-original-src="https://miro.medium.com/v2/resize:fit:408/format:webp/1*xkft9faQ0ja3P23AvNqCgQ.png"/></div><figcaption class="lf lg fg fe ff lh li bd b be z ek">Using tools sparingly</figcaption></figure><p id="751e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然，我们可以指出一个非常快的项目，它没有使用异常、RTTI和动态分配。但是1)这不是你的项目2)这种禁欲主义的代价是巨大的3)我们甚至不能确定把代码放在饮食上是否真的是导致它快速的原因。</p><p id="fac5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种建议仍然存在的一个原因是很难实施或反驳它。也许有用，也许没用，但通常需要修改整个项目才能找到答案。</p><p id="41c1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要点是，如果您的真实项目使用了动态内存和异常等新奇的东西，不要放弃优化，因为几乎没有证据表明没有它性能会突然提高。更别说你的项目会按时完成。</p><h2 id="0059" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">看简介:令人印象深刻的大改进</h2><p id="8ef2" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">因此，当开始优化代码库时，经常会有一些令人印象深刻的唾手可得的成果。你做了一个性能分析，你的项目花了50%的时间在一个超级慢的函数上。砰。工作五分钟，性能翻倍。</p><p id="5024" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我已经用我的<a class="ae jp" href="https://github.com/beaumontlab/antonie" rel="noopener ugc nofollow" target="_blank">阿端DNA工具</a>处理过这个问题，结果它花了大部分时间做<strong class="it hv">T5 e T6 T7的幂运算来得到一个不重要的统计数据。</strong></p><p id="be02" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">修复这样一个问题的冲动是如此强大，以至于我们为加速代码所做的其他努力都被它糟蹋了。我们希望其他大人物不假思索地跳出来给我们看！但是你可以继续寻找他们，他们不会来了:剩下的加速将是实际的艰苦工作。</p><h2 id="e952" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">思维模式:cpu /编译器/库/操作系统/语言是白痴</h2><p id="e866" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">我认为这可以追溯到20世纪80年代，当时所有这些都是真的。<strong class="it hv">异或ax，ax </strong>比设置<strong class="it hv"> ax </strong>为<strong class="it hv"> 0 </strong>快。系统random()调用缓慢传递交替的奇数和偶数，都位于<a class="ae jp" href="https://en.wikipedia.org/wiki/Linear_congruential_generator" rel="noopener ugc nofollow" target="_blank"> n维超平面</a>上。你可以通过用<strong class="it hv"> &gt; &gt; 3 </strong>替换<strong class="it hv"> /8 </strong>来帮助编译器。操作系统做的任何事情，你都可以绕过它做得更好。不要让我们开始学习这种语言，因为它有可怕的函数调用开销！</p><p id="0e1b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如今，事实证明，最明显的优化..已经由编译器或CPU为您完成了(这两者都比您更了解您的代码在做什么)。</p><p id="a594" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们中的许多人已经浪费了大量时间来实现用户空间多任务和异步I/O，因为这些系统线程肯定很糟糕，却发现内核对CPU和I/O的了解比我们多得多。我们的情况不够特殊。</p><p id="0763" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">类似地，许多项目已经放弃了虚方法(用C++的说法是RTTI ),只是在每个方法函数开始时将它们重新实现为switch语句。这是一个实实在在的倒退，因为编译器通常可以将调用非虚拟化，而switch语句(或函数指针结构)却不能。</p><p id="9949" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">很多时候，我们“帮助”CPU/编译器/操作系统的努力充其量只是重复已经发生的事情，但也使我们的代码去个体化，或者使其可读性大大降低。<strong class="it hv">没有任何加速</strong>。更多时候，事实证明我们实际上让事情变得更糟。</p><blockquote class="jq jr js"><p id="2ce8" class="ir is jt it b iu iv iw ix iy iz ja jb ju jd je jf jv jh ji jj jw jl jm jn jo hn dt translated">一个值得注意的例外是，如果你实际上是在一个已知缓慢的平台上，比如Python，避开它以获得性能是有意义的。但是无论如何，你可能在错误的地方得到快速软件！</p></blockquote><p id="e152" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，在你陷入假设你可以轻松地做得比你的基础设施更好的陷阱之前，要么选择更好的基础设施，要么衡量事情是否真的像你认为的那样糟糕。</p><h2 id="6eaa" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">平坦剖面:检查调用图</h2><p id="0575" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">在第一次大的优化完成后，你经常会看到一些不可避免的函数做了20%的工作，另外还有大量的函数各做了2-5%的工作。</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="fe ff lj"><img src="../Images/3a11cecd6df6fe64aa9dda26b0cff98a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hh7Xcbf1nvAubBTLTrAL7g.png"/></div></div></figure><p id="dba3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我已经花费了大量的工作来加速这些单独的函数，但是这非常令人沮丧——你意识到即使你设法加速了这样一个函数，所以它花费了<strong class="it hv"> _no_ </strong>更多的周期，你仍然只能提高3%的整体性能。</p><p id="5273" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">起初，这种平坦的轮廓只是难倒了我，让我放弃了进一步的优化。然而，随着更好的剖析器的出现，我明白了这样的平坦是骗人的。</p><p id="698a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可能会在10个函数中各花3%的时间，然后发现你花在那里的总时间的30%是因为有一个高阶函数调用所有这些小函数太频繁了。而这个更高的函数永远不会出现在你的平面轮廓里！</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div class="fe ff lo"><img src="../Images/f301d30304c72b9dbc9025f4953c815f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*442T39yJS8EnFs2sCfUWZw.png"/></div><figcaption class="lf lg fg fe ff lh li bd b be z ek">A PowerDNS Flame Graph made with <a class="ae jp" href="http://www.brendangregg.com/perf.html#FlameGraphs" rel="noopener ugc nofollow" target="_blank">http://www.brendangregg.com/perf.html#FlameGraphs</a>. Actual data <a class="ae jp" href="http://ds9a.nl/tmp/perf-kernel.svg" rel="noopener ugc nofollow" target="_blank">here</a>.</figcaption></figure><p id="200a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，要点是:获取基于调用图的性能分析。这通常有点麻烦，而且通常会慢很多，但是它们是值得的，因为它们会占用你3%的时间。</p><h2 id="17be" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">超级优化</h2><p id="d1f4" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">这是加速的奥运会。这些故事吸引了我们。亲自阅读它们，让我感到自己的渺小和不足。举例来说，如果我编写一个AES加密函数，它的速度会比那些超级密码英雄所实现的速度慢几个数量级。现代AES实现可以在11个时钟周期/字节内进行加密，而无需特殊的硬件辅助。在这5纳秒中，它执行了大量的异或和移位操作。而在11个时钟周期内，像我这样的普通程序员只能数到4。</p><p id="d716" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">如果你确实知道自己不熟悉现代CPU上的流水线和矢量化机器，这种英雄般的性能可能是放弃优化的一个理由</strong>。但是不要害怕。即使是这样英勇的程序员也只能为定义非常严格和简单的函数梳理出这种性能，即使这样，他们也要花费数周时间。</p><p id="fd23" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，尽管有<a class="ae jp" href="http://www.agner.org/optimize/" rel="noopener ugc nofollow" target="_blank">很多</a>让<a class="ae jp" href="https://cr.yp.to/qhasm.html" rel="noopener ugc nofollow" target="_blank">钦佩</a>的<a class="ae jp" href="https://www.imperialviolet.org/2010/12/21/eccspeed.html" rel="noopener ugc nofollow" target="_blank">人</a>能够<a class="ae jp" href="http://bellard.org/pi/pi2700e9/" rel="noopener ugc nofollow" target="_blank">让</a>所有的推测性执行引擎在一个CPU上旋转，意识到他们通过花费数周时间在数百字节的代码上实现如此出色的性能，这些代码很少超出加密、哈希和编解码器库的规模。不要太难过。感激地利用他们的工作，然后继续前进。</p><h2 id="b262" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">随着时间的推移，每个人都知道:少做事</h2><p id="2dfb" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">每个人都在重新发明这个。在对一个函数进行强力优化的过程中有一些“男子气概”(因为没有更好的词)。但通常它最多能让你提升20%的速度。当然，除非你是上一节的人之一！</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div class="fe ff lp"><img src="../Images/d226fc29a2becfec24cdc4f17621d223.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*ZlaoIxaUKfIYyT_mbsd_Ug.png"/></div><figcaption class="lf lg fg fe ff lh li bd b be z ek">Swoosh your code</figcaption></figure><p id="68a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">加速代码的最好方法是..而不是运行它。</strong>它需要一种非常不同的思维方式，而不是关注单独的代码行，甚至是功能。它包括真正理解你的程序在做什么。</p><p id="83a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在您花了足够的时间之后，您经常发现您的代码从数据库中检索12个字段，但是只查看一个。或者更有趣的是，它根本不看任何字段，而是将所有行存储在一个向量中，只返回它的大小。</p><p id="8312" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因《毁灭战士》和《雷神之锤》而出名的约翰·卡马克，第一次让我<a class="ae jp" href="https://m.reddit.com/r/programming/comments/13tvk9/speeding_up_go_and_c_with_custom_allocators/" rel="noopener ugc nofollow" target="_blank">明白了这个观点</a>:</p><blockquote class="lq"><p id="bbc8" class="lr ls hu bd lt lu lv lw lx ly lz jo ek translated">"与实现自定义分配器相比，花时间减少分配的总数几乎总是更好的."—约翰·卡马克</p></blockquote><p id="aa6a" class="pw-post-body-paragraph ir is hu it b iu ma iw ix iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo hn dt translated">在编写<a class="ae jp" href="https://github.com/PowerDNS/pdns/blob/master/pdns/malloctrace.hh" rel="noopener ugc nofollow" target="_blank">一些工具</a>来找出所有这些分配的确切来源之前，我已经在分配器改进上花费了比我愿意承认的更多的时间。减少malloc流量比试图优化实际的分配器本身有更大的效果。</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div class="fe ff mf"><img src="../Images/9ad6141dde62afa30037cc92243bf39a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*Cwilt1wT7Q5BfhOJ05GqiQ.png"/></div></figure><p id="8dec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">作为一个恰当的例子，<a class="ae jp" href="https://hackernoon.com/tagged/powerdns" rel="noopener ugc nofollow" target="_blank"> PowerDNS </a>最近发起了一场<a class="ae jp" href="https://mailman.powerdns.com/pipermail/pdns-users/2016-September/024457.html" rel="noopener ugc nofollow" target="_blank">为期一个月的优化狂欢</a>(这顺便引出了本文)，当我们发现我们正在对我们也可以以二进制(解析)形式存储的内容进行大量的字符串操作，将ascii/DNS往返转换为整数比较时，最终实现了“3倍”的加速。</p><p id="6d39" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，当寻找进一步优化的东西时，从代码的单个行后退很多步，以弄清楚你的代码到底试图实现什么，如果事实上与做事情太慢相比，它可能做了太多的事情。</p><h2 id="c240" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">marginal^H^H^H^H^H^H指数收益定律</h2><p id="d70f" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">这个真的打在我脸上了。PowerDNS权威服务器需要的不仅仅是20%的加速，我们需要对某个重要的工作负载进行全面的改进。所以当我开始的时候，我很快发现了两个算法优化，每个都提供了15%的性能提升。咩。所以我没有追求这个角度，因为15%的加速并不能让你达到200%的加速。或者他们有吗？</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div class="fe ff mg"><img src="../Images/f782b599182cd7bdfa450bf66f7ec695.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*lb0mGx6qcmj1aIEgGoTTig.png"/></div></figure><p id="8937" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我花了几天时间进行重大重构以实现50%的性能提升后，我思考了下一步该做什么。我把100微秒的操作缩短到了50微秒。<strong class="it hv">然后我就想到了</strong>。我丢弃的那些15%的加速值每15微秒。而且他们现在会从50微秒的预算中出来！所以我们30%的综合加速突然变成了..60%加速！<strong class="it hv">我们从50微秒/操作到20微秒/操作，快了两倍多</strong>。</p><p id="bfc1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，这仅适用于完全独立的优化，但这也是您经常会发现的情况——包含许多步骤的操作，而您的单个加速只达到其中的一些步骤。</p><p id="8c48" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">回想起来，这并不令人惊讶。sqlite项目在2014年通过微优化<a class="ae jp" href="https://news.ycombinator.com/item?id=8420274" rel="noopener ugc nofollow" target="_blank">实现了速度翻倍</a>。</p><p id="2173" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，要点是，每当您削减“15%”时，要意识到您实际上可能是在削减时钟周期而不是百分比，并且这些周期中的每一个在面对其他优化时都会变得越来越重要。在你放弃仅仅15%的进步之前，要意识到它可能会在一天结束前变成30%的进步！</p><h2 id="b234" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">包装它</h2><ul class=""><li id="91bb" class="mh mi hu it b iu ks iy kt jc mj jg mk jk ml jo mm mn mo mp dt translated">另一个项目是如此之快，没有使用任何功能？请注意，1)这是另一个项目2)他们的禁欲主义肯定会耗费他们的时间，但可能不是他们快速的原因</li><li id="53b1" class="mh mi hu it b iu mq iy mr jc ms jg mt jk mu jo mm mn mo mp dt translated">在重新实现基础设施功能之前，请三思而行。你真的比全职的编译器/cpu/OS设计师更聪明吗？</li><li id="6e22" class="mh mi hu it b iu mq iy mr jc ms jg mt jk mu jo mm mn mo mp dt translated">修复一个函数的巨大改进是:这只发生一次。进一步的改进将是非常困难的工作。准备好迎接一场苦战。</li><li id="430d" class="mh mi hu it b iu mq iy mr jc ms jg mt jk mu jo mm mn mo mp dt translated">扁平的CPU配置文件:投资于基于调用图的配置文件。获取火焰图。</li><li id="a4c2" class="mh mi hu it b iu mq iy mr jc ms jg mt jk mu jo mm mn mo mp dt translated">那些“0.4周期/字节”的速度记录是伟大的。用那个作品。但是对于大规模代码来说这是不可行的，所以对于电子表格来说做不到也不要难过。</li><li id="518c" class="mh mi hu it b iu mq iy mr jc ms jg mt jk mu jo mm mn mo mp dt translated">少做就好。</li><li id="7c54" class="mh mi hu it b iu mq iy mr jc ms jg mt jk mu jo mm mn mo mp dt translated">不要否定最初15%的改进。相对来说，一旦你实现了其他的加速，你的15%的加速可能会使性能翻倍。指数回报定律。</li></ul><p id="8ad8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">祝好运！如果你对代码加速有什么个人见解，请分享。或许这篇文章还有优化的空间！</strong></p><div class="ky kz la lb fq ab cb"><figure class="mv lc mw mx my mz na paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mv lc mw mx my mz na paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mv lc mw mx my mz na paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="jq jr js"><p id="f922" class="ir is jt it b iu iv iw ix iy iz ja jb ju jd je jf jv jh ji jj jw jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is jt it b iu iv iw ix iy iz ja jb ju jd je jf jv jh ji jj jw jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ky kz la lb fq lc fe ff paragraph-image"><a href="https://goo.gl/Ahtev1"><div class="fe ff nb"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></a></figure><figure class="ky kz la lb fq lc"><div class="bz el l di"><div class="nc nd l"/></div></figure></div></div>    
</body>
</html>