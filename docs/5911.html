<html>
<head>
<title>Combining Technologies: MongoDB &amp; NodeJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">组合技术:MongoDB和NodeJS</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/create-a-stat-tracker-app-1af88abc3165?source=collection_archive---------9-----------------------#2017-08-23">https://medium.com/hackernoon/create-a-stat-tracker-app-1af88abc3165?source=collection_archive---------9-----------------------#2017-08-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div class="fe ff hs"><img src="../Images/b85dab0ad96d19fdcba9e18868816559.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*4t7z7i4ifV1WRDRIzhehtQ.jpeg"/></div></figure><div class=""/><p id="872a" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在这篇姗姗来迟的博文中，我将介绍创建一个基本的统计跟踪应用程序的过程。在这篇文章中，我将介绍以下技术:</p><ol class=""><li id="c1c4" class="jw jx ib ja b jb jc jf jg jj jy jn jz jr ka jv kb kc kd ke dt translated">节点. js</li><li id="4923" class="jw jx ib ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke dt translated">Mustache.js</li><li id="6979" class="jw jx ib ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke dt translated">猫鼬</li><li id="d6d9" class="jw jx ib ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke dt translated">MongoDB</li></ol><p id="662d" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们想要做的是使用node来创建api端点，我们可以用它来读写我们的Mongo数据库。我们将使用Mustache在我们需要的特定页面上显示来自数据库的信息。</p><p id="c3aa" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">您可能会问自己，“我用这样的应用程序做什么？”作为一个完全假设的例子，假设你刚从为期12周的紧张的编程训练营毕业，需要一种有效的方法来跟踪你发出的简历和你参加的面试。</p><p id="73da" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在我们真正开始任何编码之前，用白板写出我们想要的样子是个好主意，这样我们就可以想象我们需要什么输入，以及我们的数据库结构应该是什么样子。我的设想在哪里，我将在这篇文章中尝试创造什么:</p><figure class="kl km kn ko fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="fe ff kk"><img src="../Images/f2ca4650ab55ebd39ceeb07de2b9fb6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7kbA3hEFflFA4t7Dx19qtA.png"/></div></div></figure><p id="215e" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我想基本上是三栏，一边是我们的类别输入。当我们输入一个新的类别时，我希望它动态地出现在输入的下方。我们将为此创建一个API端点，然后通过Mustache显示它。我们还希望一个活动与一个类别相关联。由于我们使用的是基于文档的数据库，这可能会比较棘手。因此，为了让我们的生活更简单，我们将强制用户在创建活动之前选择一个类别，或者输入一个新的类别。这样，一旦到达第二个端点，我们就可以从参数中获取类别。最后，我们将在最后一列中列出活动。我想在这里列出我们正在跟踪的所有活动。然后，当用户选择一个类别时，它会过滤这些结果，只显示为该类别列出的活动。我们需要在该端点创建一个find()查询来过滤我们的结果，然后还要改变mustache在我们的视图中显示的内容。</p><figure class="kl km kn ko fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="fe ff kk"><img src="../Images/74b64cfa8c7bd15f90d9cfb2e443b263.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZSWXx6GHCxxaAn3K8iwjXg.png"/></div></div></figure><p id="f1b7" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我的看法是，让所有内容同时可见，但每次只允许用户与一列进行交互。这样，用户永远不会觉得他们实际上是在导航到一个新的页面。我们将部分通过端点和小胡子来实现。在这里的第三个面板上，我想要一个基于文本的方法来显示每个活动的数据。类似于最右边的一栏。</p><figure class="kl km kn ko fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="fe ff kt"><img src="../Images/1a1706935440461b6115d67749744901.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kwc6DXFNRwBnsMKsERbYNA.png"/></div></div></figure><p id="87db" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">下面是我们简单的数据库结构应该是什么样子。最终，我们希望将新用户与类别相关联，然后将类别与用户相关联。这是一个非常简单的一对一关系。创建关系时，基于文档的数据库可能很难使用，因此在开始之前像这样计划您的项目是一个好主意。如果看起来您将需要大量的关系和关联，那么使用关系数据库可能是一个更好的主意。</p><p id="a4d0" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我还会包含一个到我的github的链接，以及一个我完成后的视频，这样你就可以看到我完成的项目是什么样子了。</p><p id="2909" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">好吧，那我们开始吧。一般来说，我喜欢先创建我的数据库。如果您还没有这样做，现在就开始安装MongoDB。可以在这里找到链接:<a class="ae ku" href="https://docs.mongodb.com/getting-started/shell/installation/" rel="noopener ugc nofollow" target="_blank">https://docs . MongoDB . com/getting-started/shell/installation/</a></p><h1 id="d750" class="kv kw ib bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">安装并启动Mongo</h1><p id="ba3f" class="pw-post-body-paragraph iy iz ib ja b jb lt jd je jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv hn dt translated">安装并启动MongoDB后，将mongo shell连接到正在运行的MongoDB实例。</p><p id="b559" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">然后，您可以使用以下命令行提示符运行Mongo Shell:</p><pre class="kl km kn ko fq ly lz ma mb aw mc dt"><span id="98e4" class="md kw ib lz b fv me mf l mg mh">mongo</span></pre><p id="53ae" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，如果您已经保存了任何数据库，您可以通过键入以下命令来查看它们:</p><pre class="kl km kn ko fq ly lz ma mb aw mc dt"><span id="c979" class="md kw ib lz b fv me mf l mg mh">show dbs</span></pre><p id="e82e" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">接下来，您可以创建一个新的数据库，或者使用一个现有的数据库。这两种情况下的命令都是一样的。我想为我的统计数据创建一个数据库，所以我将创建一个名为stats的数据库。</p><pre class="kl km kn ko fq ly lz ma mb aw mc dt"><span id="8dbe" class="md kw ib lz b fv me mf l mg mh">use stats</span></pre><p id="858c" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在mongo中，如果有一个数据库叫做stats，它就会切换到那个数据库。如果没有同名的现有数据库，它将创建一个。就这么简单。您应该会看到类似这样的内容:</p><pre class="kl km kn ko fq ly lz ma mb aw mc dt"><span id="18e7" class="md kw ib lz b fv me mf l mg mh">switched to db stats</span></pre><p id="9439" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，通过使用以下命令，我们可以看到数据库中的任何集合:</p><pre class="kl km kn ko fq ly lz ma mb aw mc dt"><span id="3d9d" class="md kw ib lz b fv me mf l mg mh">show collections</span></pre><p id="97c5" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们还没有为我们的统计追踪器收集任何东西，所以我们将制作一些新的。集合就像关系数据库中的表，尽管它们缺乏在集合之间轻松建立关联的能力，如果您更熟悉SQL数据库的话，您可能已经习惯了。对于我们的stat-tracker，我们知道至少需要3次收集:</p><ol class=""><li id="7794" class="jw jx ib ja b jb jc jf jg jj jy jn jz jr ka jv kb kc kd ke dt translated">用户，因此我们可以作为不同的用户登录和注销。</li><li id="56eb" class="jw jx ib ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke dt translated">类别，因为我们可能想要跟踪不同类别的统计数据。</li><li id="801a" class="jw jx ib ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke dt translated">活动。活动将是与每个类别相关联的特定活动。这似乎是一个额外的步骤，但我认为这将有助于我们保持事情的条理性。在我们的Activities集合中，我们将跟踪数据，例如活动名称、完成的活动数量、完成活动的日期等。</li></ol><p id="64c3" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">以下是我们创建这些系列的方式:</p><pre class="kl km kn ko fq ly lz ma mb aw mc dt"><span id="59d3" class="md kw ib lz b fv me mf l mg mh">db.createCollection("users")<br/>db.createCollection("categories")<br/>db.createCollection("activities")</span></pre><p id="0331" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们已经创建了它们，我们可以使用以下命令查看我们的集合:</p><pre class="kl km kn ko fq ly lz ma mb aw mc dt"><span id="5b33" class="md kw ib lz b fv me mf l mg mh">db.activities.find().pretty()</span></pre><p id="adf7" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">的。pretty()不是必需的，但是它使查看集合中的数据变得更加容易。如果您喜欢在终端中工作，那么您可以继续返回并在终端中键入该命令，这是一个很好的习惯，以确保您想要的数据被正确地添加到数据库中。然而，我是一个非常视觉化的人，希望能够以一种更具视觉吸引力的方式来查看数据。有一些数据库可视化的程序。Robo3T是一个不错的产品，但我也刚刚发现了一个由MongoDB制作的产品，名为MongoDB Compass。到目前为止，这是我最喜欢的数据库可视化技术，所以如果你对这方面感兴趣，我建议你去下载它。您可能还会发现他们有其他一些很棒的应用程序，如用于数据库部署的atlas。以下是您使用Compass可以看到的内容的截图:</p><figure class="kl km kn ko fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="fe ff mi"><img src="../Images/04c426ad5e196299e128d821ea7a649b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OIyg6hT3NYBpG0H55Fqsjw.png"/></div></div></figure><h1 id="cf71" class="kv kw ib bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">设置我们的应用程序。Js环境</h1><p id="0903" class="pw-post-body-paragraph iy iz ib ja b jb lt jd je jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv hn dt translated">现在我们已经完成了，我们可以在我们的文本编辑器中做剩下的工作。你可能已经注意到了，我喜欢逐步列表。所以让我们列一个我们需要做的事情的清单。</p><ol class=""><li id="9490" class="jw jx ib ja b jb jc jf jg jj jy jn jz jr ka jv kb kc kd ke dt translated">创建一个app.js文件，我们将在其中存储所有路线。</li><li id="5e72" class="jw jx ib ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke dt translated">为我们的每个系列制作模型。</li><li id="55cc" class="jw jx ib ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke dt translated">为我们的每个模型创建JS文件，并将它们导入我们的app.js文件</li><li id="4e3f" class="jw jx ib ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke dt translated">创建Mustache.js文件，我们将在其中查看所有的数据和信息。</li><li id="857e" class="jw jx ib ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke dt translated">创建一个CSS文件来设计我们的视图。</li></ol><p id="d414" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们首先从app.js文件开始。在这里，我们将列出我们的依赖项，然后开始我们的路线。以下是我认为我们需要的依赖项:</p><pre class="kl km kn ko fq ly lz ma mb aw mc dt"><span id="9291" class="md kw ib lz b fv me mf l mg mh">const express = require('express');<br/>const parseurl = require('parseurl');<br/>const bodyParser = require('body-parser');<br/>const path = require('path');<br/>const expressValidator = require('express-validator');<br/>const mustacheExpress = require('mustache-express');<br/>const uniqueValidator = require('mongoose-unique-validator');<br/>const mongoose = require('mongoose');<br/>const session = require('express-session');<br/>const app = express();</span></pre><p id="d8d1" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">接下来，我们还需要我们的模型。我们还没有创建它们，但是我们现在可以继续并要求它们，只要确保我们在创建和导出它们时使用相同的名称。</p><pre class="kl km kn ko fq ly lz ma mb aw mc dt"><span id="81fd" class="md kw ib lz b fv me mf l mg mh">const Activity = require('./models/activity');<br/>const Category = require('./models/category');<br/>const User = require('./models/user.js');</span></pre><p id="8606" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">接下来，我们将设置我们的视图引擎和app.use，用于我们的主体解析器和公共(CSS)文件:</p><pre class="kl km kn ko fq ly lz ma mb aw mc dt"><span id="dc41" class="md kw ib lz b fv me mf l mg mh">app.engine('mustache', mustacheExpress());<br/>app.set('view engine', 'mustache');<br/>app.set('views', './views');<br/>app.use(express.static('public'));<br/>app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({<br/>  extended: true<br/>}));<br/>app.use(expressValidator());</span></pre><h1 id="d3da" class="kv kw ib bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">连接到Mongo</h1><p id="24f1" class="pw-post-body-paragraph iy iz ib ja b jb lt jd je jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv hn dt translated">现在我们需要将app.js文件连接到mongoDB。</p><pre class="kl km kn ko fq ly lz ma mb aw mc dt"><span id="bd6c" class="md kw ib lz b fv me mf l mg mh">mongoose.connect('mongodb://localhost:27017/stats')</span></pre><p id="325b" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们将我们的数据库命名为“stats ”,所以要确保这里的名称也是相同的。</p><p id="04c7" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">接下来，我们将为根目录“/”创建一个app.get，并创建一个app.use来测试我们的连接。最好在这里写一条console.log消息，让您知道您已经连接上了。</p><pre class="kl km kn ko fq ly lz ma mb aw mc dt"><span id="3477" class="md kw ib lz b fv me mf l mg mh">app.get('/', function(req, res) {<br/>  res.redirect('/api/splash');<br/>});</span><span id="f043" class="md kw ib lz b fv mj mf l mg mh">app.use(function(req, res, next) {<br/>  console.log('Great Job!  You connected, you charming, handsome fellow!');<br/>  next();<br/>})</span></pre><p id="fdbb" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我通常也喜欢在这里加入鼓励的信息。你可能很快就会发现，事情往往不会成功，所以在这里有一点鼓励是很好的。</p><p id="197d" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在我们文件的底部，让我们继续创建一个应用程序。听着，在我们继续之前，我们可以确保一切都已连接。这将放在app.js的最底部，我们将在最底部为我们的应用程序包含一个导出。它应该是这样的:</p><pre class="kl km kn ko fq ly lz ma mb aw mc dt"><span id="02d2" class="md kw ib lz b fv me mf l mg mh">app.listen(3000);<br/>console.log('starting applicaiton.  Good job!');</span><span id="3cbb" class="md kw ib lz b fv mj mf l mg mh">module.exports = app;</span></pre><h1 id="7f19" class="kv kw ib bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">建造我们的猫鼬模型</h1><p id="54b2" class="pw-post-body-paragraph iy iz ib ja b jb lt jd je jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv hn dt translated">现在，让我们考虑一下我们需要的页面和功能，这样我们就可以开始创建端点了。</p><ol class=""><li id="2325" class="jw jx ib ja b jb jc jf jg jj jy jn jz jr ka jv kb kc kd ke dt translated">登录页面。在这里，用户要么登录，要么注册。登录后，我们将开始一个会话，以便保存信息。</li><li id="5d9b" class="jw jx ib ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke dt translated">注册页面。这里，我们将创建一个新用户，并将该用户添加到数据库中</li><li id="0559" class="jw jx ib ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke dt translated">登录页面。在这里，我们将启动一个会话，并将任何创建的活动与该用户相关联。</li><li id="4a9d" class="jw jx ib ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke dt translated">创建类别页面</li><li id="ac90" class="jw jx ib ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke dt translated">创建活动页面</li><li id="73f6" class="jw jx ib ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke dt translated">查看统计信息页面。在这里，我们希望能够查看每个活动的具体数据。</li></ol><p id="5fc5" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果我们愿意，我们可以添加其他功能或其他页面，但这应该让我们现在就开始。先说我们的品类和活动创建。为了做到这一点，我们可能应该首先构建我们的模型。先来看看活动。</p><pre class="kl km kn ko fq ly lz ma mb aw mc dt"><span id="907c" class="md kw ib lz b fv me mf l mg mh">const mongoose = require('mongoose');<br/>const uniqueValidator = require('mongoose-unique-validator');</span><span id="5e1f" class="md kw ib lz b fv mj mf l mg mh">let Schema = mongoose.Schema;</span><span id="7a16" class="md kw ib lz b fv mj mf l mg mh">const activitySchema = new mongoose.Schema({</span><span id="fe51" class="md kw ib lz b fv mj mf l mg mh">category: {<br/>  type: String,<br/>  ref: 'Category',<br/>},<br/>activity_name: {<br/>  type: String,<br/>},<br/>quantity: {<br/>  type: Number,<br/>},<br/>metric: {<br/>  type: String,<br/>},<br/>date: {<br/>  type: Date,<br/>  default: Date.now<br/>},<br/>});</span><span id="2fb3" class="md kw ib lz b fv mj mf l mg mh">const Activity = mongoose.model('Activity', activitySchema);<br/>activitySchema.plugin(uniqueValidator);<br/>module.exports = Activity</span></pre><p id="b03d" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所以这里有几点需要指出。首先，让我们看看模型的顶部和底部。我们从要求猫鼬开始。然后我们调用变量Schema，并将其设置为mongose . Schema，然后我们基于mongose . Schema创建我们的activitySchema。</p><p id="fd29" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在文件的最后，我们基本上让Activity成为我们正在导出的const，它是我们的模型中包含的所有数据。请记住，Activity是我们在app.js文件中需要的模型之一，所以请确保我们在这里使用了相同的名称。</p><p id="075f" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">介于两者之间的是我们希望包含在模型中的所有数据。我们的模型相当简单，因为我们拥有的每一项实际上只有一条信息，即数据类型。我们可以更简单地编写这一部分，如下所示:</p><pre class="kl km kn ko fq ly lz ma mb aw mc dt"><span id="42f0" class="md kw ib lz b fv me mf l mg mh">activity_name: type: String,</span><span id="d6dc" class="md kw ib lz b fv mj mf l mg mh">quantity: type: Number,<br/><br/>metric: type: String,<br/></span></pre><p id="c843" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">但是从每个项目创建一个对象允许我们扩展，如果我们需要的话，可以在以后向每个对象添加数据。你可能也注意到了，我们这里有一个category字段，尽管我们要做一个Category模型。</p><pre class="kl km kn ko fq ly lz ma mb aw mc dt"><span id="ff0c" class="md kw ib lz b fv me mf l mg mh">category: {<br/>  type: String,<br/>  ref: 'Category',<br/>},</span></pre><p id="3deb" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这包括一个类型和一个名为“ref:”的字段。这引用了我们的类别模型，并将数据，特别是类别名称，引入到我们的活动模型中。您可以将这些数据嵌入到活动模型中，但是有时将它们分开会更方便。好了，让我们创建我们的类别模型。</p><pre class="kl km kn ko fq ly lz ma mb aw mc dt"><span id="35d3" class="md kw ib lz b fv me mf l mg mh">const mongoose = require('mongoose');<br/>const uniqueValidator = require('mongoose-unique-validator');</span><span id="70d6" class="md kw ib lz b fv mj mf l mg mh">let Schema = mongoose.Schema;</span><span id="ad71" class="md kw ib lz b fv mj mf l mg mh">const categorySchema = new mongoose.Schema({</span><span id="2f98" class="md kw ib lz b fv mj mf l mg mh">activity_type: {<br/>  type: String,<br/>},</span><span id="9258" class="md kw ib lz b fv mj mf l mg mh">stats: [{<br/>  type: String,<br/>  ref: 'Activity',<br/>}],<br/>});</span><span id="d5f6" class="md kw ib lz b fv mj mf l mg mh">categorySchema.plugin(uniqueValidator);<br/>const Category = mongoose.model('Category', categorySchema);</span><span id="d086" class="md kw ib lz b fv mj mf l mg mh">module.exports = Category</span></pre><p id="8b72" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如您所见，我们的类别模型的设置与活动模型完全一样。同样，我们希望确保我们在app.js中使用的名称与我们在这里导出的名称“Category”相匹配。此外，我在这里包含了一个名为stats的字段，在这里我还引用了来自我们的活动模型的一组数据。我们可能还想在这里编辑我们的数据类型。我们可能宁愿用<code class="eh mk ml mm lz b">mongoose.Schema.Types.ObjectId</code>来代替字符串</p><p id="21da" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">而且，作为一个公平的警告，我们在这里尝试做的是在文档数据库中的集合之间建立关联。这不是一件容易的事，而且经常不会如你所愿。通常，只有在进行简单的一对一关联时，才需要这样做。当试图建立多个关联或多对多关联时，基于文档的数据库会变得难以使用。</p><p id="daff" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">既然我们的联想很简单，那大概还行吧。但是如果你的项目需要更多的东西，那么使用Postgres这样的SQL数据库可能就不会那么令人头疼了。</p><p id="1a75" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">好的，现在，让我们继续让我们的用户建模。它应该遵循相同的模式。</p><pre class="kl km kn ko fq ly lz ma mb aw mc dt"><span id="5a10" class="md kw ib lz b fv me mf l mg mh">const mongoose = require('mongoose');</span><span id="b2d2" class="md kw ib lz b fv mj mf l mg mh">let Schema = mongoose.Schema;</span><span id="21c1" class="md kw ib lz b fv mj mf l mg mh">const userSchema = new Schema({<br/>  username: {<br/>    type: String,<br/>  },<br/>  password: {<br/>    type: String,<br/>  },<br/>  category: [{<br/>    type: mongoose.Schema.Types.ObjectId,<br/>    ref: 'Category'<br/>  }],<br/>})<br/>const User = mongoose.model('User', userSchema);</span><span id="5e6b" class="md kw ib lz b fv mj mf l mg mh">module.exports = User;</span></pre><p id="3c38" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这里，我再次引用了类别模型，以便我们可以将类别与用户集合关联起来。现在我们已经有了模型，我们可以回到app.js文件，创建我们的api端点。</p><h1 id="f240" class="kv kw ib bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">构建我们的API端点</h1><ol class=""><li id="16ce" class="jw jx ib ja b jb lt jf lu jj mn jn mo jr mp jv kb kc kd ke dt translated">创建新类别</li></ol><pre class="kl km kn ko fq ly lz ma mb aw mc dt"><span id="9f27" class="md kw ib lz b fv me mf l mg mh">//====CREATE NEW CATEGORY===//</span><span id="507c" class="md kw ib lz b fv mj mf l mg mh">app.post('/api/home', function(req, res) {<br/>  Category.create({<br/>    activity_type: req.body.category,<br/>  }).then(activity =&gt; {<br/>    res.redirect('/api/home')<br/>  });<br/>});</span></pre><p id="2d96" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这是我们的第一个app.post，我们需要用它来创建一些东西。当我们在mustache视图上创建表单时，我们需要确保表单也有一个method="post "。</p><p id="0807" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这个端点将是/api/home，或者基本上是我们的根页面。如果有人去“/”，我们可以将他们重定向到主页。如您所见，创建类别后，我们使用res.redirect将用户送回主页，或/api/home。</p><p id="679b" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这里，我们使用了mongoose的“create”方法，它构建了一个模型，并将其保存在一个文件中。我们基本上是在说，“嘿Node，还记得我们的分类模型吗？是的，所以，我们有一个称为活动类型的字段。我们希望用数据填充该字段。我们使用的数据，你可以在我们文档的主体中找到，在一个名为“类别”的输入字段中"</p><p id="4b76" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，我们需要记住“类别”这个名称。当我们构建mustache视图时，我们需要使用这个名称作为输入字段的名称，以便它们可以正确地相互连接。</p><p id="a2b2" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">2.呈现类别主页。</p><pre class="kl km kn ko fq ly lz ma mb aw mc dt"><span id="97bf" class="md kw ib lz b fv me mf l mg mh">//====RENDER HOME PAGE===//</span><span id="13a6" class="md kw ib lz b fv mj mf l mg mh">app.get('/api/home', function(req, res) {<br/>  User.find({}).then(function(users) {<br/>    Category.find({}).then(function(categories) {<br/>      Activity.find({}).then(function(activities) {<br/>        console.log(activities);<br/>        res.render('home', {<br/>          users: users,<br/>          categories: categories,<br/>          activities: activities,<br/>        })<br/>      });<br/>    });<br/>  });<br/>});</span></pre><p id="51ac" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这是我们的app.get，我们需要使用它来呈现数据，而不是发布数据。我们在结尾也有一个res.render和“home”。当我们在mustache中创建视图时，我们需要确保将它命名为“home.mustache ”,以便它对应于这个res.render方法，并且可以呈现正确的页面。</p><p id="0ed6" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在这里，我们使用User.find、Category.find和Activity.find。但是在主页上，我想显示所有的类别和所有的活动，所以我没有在任何查找的({})之间放置任何查询，以确保我获得所有的数据并在该页面上显示所有的数据。</p><p id="df1d" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">3.创建一项活动</p><pre class="kl km kn ko fq ly lz ma mb aw mc dt"><span id="136a" class="md kw ib lz b fv me mf l mg mh">app.post('/api/:activity/:_id', function(req, res) {<br/>  Activity.create({<br/>    activity_name: req.body.activity,<br/>    quantity: req.body.quantity,<br/>    metric: req.body.metric,<br/>    category: req.params.activity,<br/>  }).then(activity =&gt; {<br/>    console.log("about to log categories");<br/>    res.redirect('/api/:activity/:_id')<br/>  });<br/>});</span></pre><p id="27c6" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们的第二个app.post有点复杂。对于activity和id，我们的端点有更多的参数，因为我们可能需要从这里的参数中提取数据，以便我们可以填充其中的一些字段。我们再次使用mongoose创建方法。我们也告诉mongoose基本上和我们在创建类别中做的一样。我们告诉它，“嗨，猫鼬，还记得我们活动模型中的活动字段吗？它们被标记为活动名称、数量和指标。无论如何，您可以在文档的主体中找到相应的活动、数量和度量的输入字段名称。类别，但您需要从params获取该信息。”</p><p id="4278" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，在创建之后，我们将把用户重定向回带有端点/api/:activity/:_id的活动页面。</p><p id="d565" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">一个旁注。您可能已经注意到，在我们的活动模型中，我们有一个日期字段，但是在这里，我们不要求输入日期。这是因为在日期对象中，我们包含了一个名为“默认”的字段。默认基本上是说，如果没有日期输入，使用今天的日期，或“date.now”。你也可以用“时间戳”来写看起来更像这样:</p><pre class="kl km kn ko fq ly lz ma mb aw mc dt"><span id="8c1c" class="md kw ib lz b fv me mf l mg mh">date: {<br/>timestamps: true,<br/>}</span></pre><p id="e1d7" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">date.now还会给你一个时间戳。然而，mongoose中的timestamps方法给你一个自动创建的日期和一个更新的日期。所以根据你的需要，你可以使用任何一种。</p><p id="66d2" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">4.呈现活动页面。</p><pre class="kl km kn ko fq ly lz ma mb aw mc dt"><span id="ee69" class="md kw ib lz b fv me mf l mg mh">//====RENDER ACTIVITY PAGE===//</span><span id="2fae" class="md kw ib lz b fv mj mf l mg mh">app.get('/api/:activity/:_id', function(req, res) {<br/>  User.find({}).then(function(users) {<br/>    Category.findOne({activity_type: req.params.activity}).then(function(categories) { Activity.find({category: req.params.activity}).then(function(activities) {<br/>        res.render('activity', {<br/>          users: users,<br/>          activities: activities,<br/>        })<br/>     });<br/>    });<br/>  });<br/>});</span></pre><p id="d1aa" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们在这里使用app.get，以及与我们的帖子相同的端点，因为我们还需要在这里为我们的查询拉参数。在category中，我们将使用findOne方法，因为在这里我们一次只需要一个Category。我们将一个活动输入到一个类别中。然后我们告诉它在哪里可以找到我们想要的活动，这是在req.params.activity中。然后我们也做一个activity.find，在这里我们找到所有的类别，与params中的活动相关联。这听起来可能有点混乱。但是这样想想。假设我们有一个分类叫做“找工作”。在这个类别中，我们希望显示它的活动，比如“发送的简历”和“面试”。我们可以在activities模式中包含它，而不是查询category模型。因为我们已经在活动模型中包含了对类别的引用，所以我们现在在活动中也有了这些信息。</p><p id="4050" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在这里，我们正在渲染“活动”。因此，让我们提醒自己，当我们创建mustache视图时，我们需要确保文件的名称与这里的呈现位置相匹配，以便呈现正确的页面。</p><p id="3bf4" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">5.呈现特定的活动</p><pre class="kl km kn ko fq ly lz ma mb aw mc dt"><span id="7445" class="md kw ib lz b fv me mf l mg mh">//====RENDER SPECIFIC ACTIVITY===//</span><span id="8134" class="md kw ib lz b fv mj mf l mg mh">app.get('/api/:activity', function(req, res) {<br/>  User.find({}).then(function(users) {<br/>    Category.findOne({activity_type: req.params.activity}).then(function(categories) { Activity.find({ activity_name: req.params.activity<br/>    }).then(function(activities) {<br/>          res.render('date', {<br/>            users: users,<br/>            categories: categories,<br/>            activities: activities<br/>          })<br/>      });<br/>    });<br/>  });<br/>});</span></pre><p id="1819" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这是另一个app.get，为这个页面添加了一个新的端点。在这里，我们希望显示关于活动的特定数据。我们再次使用Activity.find从活动模型中提取数据，然后根据我们传递给它的参数查询该数据。</p><h1 id="2641" class="kv kw ib bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">用小胡子创建视图。射流研究…</h1><p id="1624" class="pw-post-body-paragraph iy iz ib ja b jb lt jd je jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv hn dt translated">现在，在所有这些之后，我们可能想做不同的事情，比如删除或更新一个活动。但是考虑到这篇文章的长度，以及大多数读者(包括我自己)的关注范围，我不会在这里深入讨论。我想展示的最后一件事是这些api调用如何与我们的表单相匹配。当你创建你的小胡子文件时，你会再次想要用我们在res.render调用中使用的相同名称来命名它们。</p><p id="1847" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">然后，在我们的表单中，我们将使用method="post ",并为输入字段使用相同的名称，就像我们在Activity.create和Category.create中调用的那样。</p><pre class="kl km kn ko fq ly lz ma mb aw mc dt"><span id="2d3b" class="md kw ib lz b fv me mf l mg mh">&lt;div class="activity_input"&gt;<br/>      &lt;form action="{{#activities}}{{category}}{{/activities}}" method="post"&gt;<br/>        &lt;div class="title1container"&gt;<br/>          &lt;div class="title1"&gt;Step 3: Use the Input Fields to Add an Activity to the Category You Selected&lt;/div&gt;<br/>        &lt;/div&gt;<br/>        &lt;div class="formcontainer"&gt;</span><span id="5478" class="md kw ib lz b fv mj mf l mg mh">&lt;div class="formInput"&gt;</span><span id="3fc8" class="md kw ib lz b fv mj mf l mg mh">&lt;div class="labelAndCheckbox"&gt;<br/>              &lt;label class="title2"&gt;Category Name:&lt;/label&gt;</span><span id="d0ff" class="md kw ib lz b fv mj mf l mg mh">&lt;div class="act"&gt;<br/>                  {{#categories}}<br/>                   {{activity_type}}<br/>                   {{/categories}}<br/>                &lt;/div&gt;</span><span id="c73f" class="md kw ib lz b fv mj mf l mg mh">&lt;/div&gt;</span><span id="376f" class="md kw ib lz b fv mj mf l mg mh">&lt;div class="title2"&gt;New Activity&lt;/div&gt;<br/>            &lt;input autocomplete="off" class="input" required type="text" name="activity"&gt;</span><span id="ba49" class="md kw ib lz b fv mj mf l mg mh">&lt;div class="title2"&gt;Quantity&lt;/div&gt;<br/>            &lt;input autocomplete="off" class="input" required type="text" name="quantity"&gt;</span><span id="d8f9" class="md kw ib lz b fv mj mf l mg mh">&lt;div class="title2"&gt;Unit of Measurement&lt;/div&gt;<br/>            &lt;input autocomplete="off" class="input" required type="text" name="metric"&gt;</span><span id="5a05" class="md kw ib lz b fv mj mf l mg mh">&lt;input class="form__submit-button" type="submit"&gt;</span><span id="5ce3" class="md kw ib lz b fv mj mf l mg mh">&lt;/div&gt;<br/>        &lt;/div&gt;<br/>      &lt;/form&gt;</span></pre><p id="98ce" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，这里发生了很多事情。但是你可以在每个输入中看到，我们使用了api调用中使用的相同名称。“度量”、“数量”和“活动”。我们还在表单的顶部添加了这一点:</p><pre class="kl km kn ko fq ly lz ma mb aw mc dt"><span id="b0d8" class="md kw ib lz b fv me mf l mg mh">&lt;form action="{{#activities}}{{category}}{{/activities}}" method="post"&gt;</span></pre><p id="2f0f" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">它告诉mustache这是一篇文章，其中的动作是“类别”。我们所有的其他形式将遵循同样的方法。在我们的小胡子看来，这个难题的另一个棘手的部分是弄清楚如何处理从一个页面到另一个页面的链接。您将希望使用mustache来调用链接位置，以便这些链接是动态的。下面是一个从主页到活动输入页面的示例:</p><pre class="kl km kn ko fq ly lz ma mb aw mc dt"><span id="1122" class="md kw ib lz b fv me mf l mg mh">&lt;label class="title2"&gt;Category Name:&lt;/label&gt;</span><span id="1ac7" class="md kw ib lz b fv mj mf l mg mh">{{#categories}}<br/>          &lt;div class="act"&gt;&lt;a class="categoryList" href={{activity_type}}/{{_id}} value= {{_id}}{{#dates}}{{date}}{{/dates}}&gt;{{activity_type}}&lt;/a&gt;</span><span id="067e" class="md kw ib lz b fv mj mf l mg mh">&lt;/div&gt;<br/>        {{/categories}}</span></pre><p id="c4a5" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">href值实际上是{{#categories}}数据库的{{_id}}。这可能是一件很难弄清楚的事情，但是一旦你经历了几次，就没那么糟糕了。</p><p id="6058" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在我们的大多数页面上，我们只显示活动或类别名称。但是在我们的最后一个页面上，我们想要实际显示几乎所有关于活动的信息。这也可能会有点混乱，因为有太多的数据，用mustache以有组织的方式显示数据有时会有点混乱。以下是我的小胡子档案里我的样子:</p><pre class="kl km kn ko fq ly lz ma mb aw mc dt"><span id="19e5" class="md kw ib lz b fv me mf l mg mh">{{#activities}}</span><span id="508a" class="md kw ib lz b fv mj mf l mg mh">&lt;div class="categoryTitle"&gt;<br/>      <br/>      &lt;/div&gt;</span><span id="9078" class="md kw ib lz b fv mj mf l mg mh">&lt;div class="activityDateContainer"&gt;<br/>        &lt;span&gt;<br/>             While doing<br/>          &lt;/span&gt;<br/>        &lt;span class="bold"&gt;<br/>       {{category}}<br/>          &lt;/span&gt;<br/>          &lt;span&gt;<br/>               stuff,<br/>            &lt;/span&gt;<br/>        &lt;span class="bold"&gt;<br/>            {{#users}}{{username}}{{/users}}<br/>          &lt;/span&gt;<br/>        &lt;span&gt;<br/>             completed<br/>          &lt;/span&gt;<br/>        &lt;span class="bold"&gt;<br/>          {{quantity}}<br/>          &lt;/span&gt;<br/>        &lt;span class="bold"&gt;<br/>          {{metric}}<br/>          &lt;/span&gt;<br/>        &lt;span&gt;<br/>            of<br/>          &lt;/span&gt;<br/>        &lt;span class="bold"&gt;<br/>          {{activity_name}}<br/>          &lt;/span&gt;<br/>        &lt;span&gt;<br/>             on this date:<br/>          &lt;/span&gt;<br/>        &lt;span class="bold"&gt;<br/>          {{date}}<br/>          &lt;/span&gt;<br/>      &lt;/div&gt;</span><span id="f8f2" class="md kw ib lz b fv mj mf l mg mh">{{/activities}}</span></pre><p id="640f" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这可能没什么意义。如果你像我一样是一个视觉型的人，能够看到它实际上会是什么样子会有所帮助。为了有助于所有这一切，我已经包括了一个简短的视频，在那里你可以看到网站实际上是如何工作的。我希望这有所帮助。如果你有任何问题，或者我做错了什么，请随时联系我。谢谢！</p><figure class="kl km kn ko fq hw"><div class="bz el l di"><div class="mq mr l"/></div></figure><div class="ht hu fm fo hv ms"><a href="https://www.linkedin.com/in/ethan-jarrell-1226669/" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab ej"><div class="mu ab mv cl cj mw"><h2 class="bd ic fv z el mx eo ep my er et ia dt translated">伊桑·贾雷尔|职业简介| LinkedIn</h2><div class="mz l"><h3 class="bd b fv z el mx eo ep my er et ek translated">查看Ethan Jarrell在LinkedIn上的职业简介。LinkedIn是世界上最大的商业网络，帮助…</h3></div><div class="na l"><p class="bd b gc z el mx eo ep my er et ek translated">www.linkedin.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng hx ms"/></div></div></a></div><div class="ht hu fm fo hv ms"><a href="https://github.com/ethanjarrell/stattracker" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab ej"><div class="mu ab mv cl cj mw"><h2 class="bd ic fv z el mx eo ep my er et ia dt translated">ethanjarrell/stattracker</h2><div class="mz l"><h3 class="bd b fv z el mx eo ep my er et ek translated">在GitHub上创建一个帐户，为stattracker的开发做出贡献。</h3></div><div class="na l"><p class="bd b gc z el mx eo ep my er et ek translated">github.com</p></div></div><div class="nb l"><div class="nh l nd ne nf nb ng hx ms"/></div></div></a></div></div></div>    
</body>
</html>