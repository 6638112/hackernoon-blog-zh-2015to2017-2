<html>
<head>
<title>The Hydra Bug: Part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">九头蛇虫:第二部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-hydra-bug-d98214029358?source=collection_archive---------9-----------------------#2017-05-21">https://medium.com/hackernoon/the-hydra-bug-d98214029358?source=collection_archive---------9-----------------------#2017-05-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div class="fe ff hs"><img src="../Images/74c04a68ce56873317483760c75a8a5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/1*zN0_CPZDqawHmGg5z8Biew.gif"/></div><figcaption class="hz ia fg fe ff ib ic bd b be z ek">Image copyright <a class="ae id" href="https://www.flickr.com/photos/andrew_jian" rel="noopener ugc nofollow" target="_blank">Andrew Jian</a> <a class="ae id" href="https://creativecommons.org/licenses/by/2.0/" rel="noopener ugc nofollow" target="_blank">CC-BY</a></figcaption></figure><div class=""/><div class=""><h2 id="2c48" class="pw-subtitle-paragraph jd if ig bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ek translated">iPXE — 60%的情况下，它每次都有效</h2></div><p id="d1a7" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在解决了<a class="ae id" rel="noopener" href="/@vishvananda/the-hydra-bug-4a9ceb208436">简介</a>中的一个小错误后，<a class="ae id" rel="noopener" href="/@vishvananda/the-hydra-bug-e4d3af2d61c0">第一部分</a>阐述了我是如何花了一周时间为我的基于KVM/vf的虚拟机管理原型发现并解决hydra错误的。</p><p id="4187" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我的iPXE构建第一次就成功了。我在《T4》第一部中稍微夸大了事实。重启失败并不完全是意外。我在原型开发过程中遇到过几次这个错误，但是我会通过使用不同的vf或者重启主机来修复它。继续阅读冒险的第二部分。</p></div><div class="ab cl kr ks hc kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hn ho hp hq hr"><p id="e84d" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在虚拟机第二次启动时，iPXE无法通过iSCSI进行通信。打开intelxvf驱动程序的调试显示没有接收到数据包。一旦vf处于这种状态，它将保持断开状态，直到主机重新启动。很明显，虚函数中有一些持久的状态没有被清除。</p></div><div class="ab cl kr ks hc kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hn ho hp hq hr"><h2 id="74f5" class="ky kz ig bd la lb lc ld le lf lg lh li ke lj lk ll ki lm ln lo km lp lq lr ls dt translated">简介:英特尔网卡配置</h2><p id="0a15" class="pw-post-body-paragraph jv jw ig jx b jy lt jh ka kb lu jk kd ke lv kg kh ki lw kk kl km lx ko kp kq hn dt translated">英特尔82599网卡的配置是通过写入特定的DMA位置来执行的。各个位置控制不同的特性，在数据手册中称为“寄存器”。例如，有一个寄存器控制应该从哪里读取包数据。</p><p id="74b1" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">一些寄存器只能通过物理功能写入(例如，在管理程序主机上)，但是其他寄存器可以通过虚拟功能写入。这就是虚函数驱动程序建立发送和接收队列的方式。</p><p id="e0ba" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果一个错误持续存在于内核/驱动程序的多个实例中，那一定是因为某个寄存器值已经被改变了。iPXE中的驱动程序自己设置寄存器值，因此它可以通信，但是linux驱动程序稍后会在内核接管后重新配置寄存器。</p></div><div class="ab cl kr ks hc kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hn ho hp hq hr"><p id="0906" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我通读了英特尔<a class="ae id" href="http://www.intel.com/content/www/us/en/embedded/products/networking/82599-10-gbe-controller-datasheet.html" rel="noopener ugc nofollow" target="_blank">数据表</a>，试图理解可能会出错的地方。我找到了用于设置寄存器的<a class="ae id" href="https://github.com/ipxe/ipxe/blob/master/src/drivers/net/igbvf/igbvf_main.c" rel="noopener ugc nofollow" target="_blank"> iPXE代码</a>,看看它是否无法重置某些东西。奇怪的是，代码很清楚地向物理设备发送了一条请求重置的消息。为什么不会重置呢？</p><p id="c9c5" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我惊讶地发现，物理功能的<a class="ae id" href="http://lxr.free-electrons.com/source/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c?v=4.8#L650" rel="noopener ugc nofollow" target="_blank">驱动程序代码</a>(这是虚拟机管理程序端的物理设备的驱动程序)在接收到vf重置消息时并没有重置一切。虽然一些值(如mac地址)被重置，但另一些值没有重置(如发送和接收队列)。这给了我一个假设:linux中的vf驱动程序一定设置了一些寄存器，当iPXE第二次运行时，它使用了不正确的值。</p><p id="06e2" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我仔细阅读了代码，寻找一个主机端的解决方法来执行vf的完全重置。最终我在<a class="ae id" href="http://lxr.free-electrons.com/source/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c?v=4.8#L986" rel="noopener ugc nofollow" target="_blank">的ethtool </a>找到了一个。我现在可以通过使用ethtool更改父设备的环参数来重置队列。这对于测试来说太棒了，因为这意味着我不需要重启，但是不幸的是，它一次重置了所有的虚函数。这意味着在创建虚拟机时重置一个虚拟机的网卡将重置同一机器上的所有其他虚拟机。那可不太友好啊！所以我要修改iPXE端才能正确复位。</p><p id="1088" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">最初，我试图比较linux vf代码和iPXE vf代码来寻找不同之处，但是它们在风格上的差异足以使它变得困难。我想知道是否有某种方法可以让我查看vf寄存器的当前设置。幸运的是，英特尔为<a class="ae id" href="https://sourceforge.net/projects/e1000/files/Ethregs%20-%20Register%20Dump%20Tool/1.20.1/" rel="noopener ugc nofollow" target="_blank"> ethregs </a>提供了源代码，这是一个可以转储当前寄存器值的工具。</p><p id="6856" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我的目标是在iPXE将网卡的寄存器重置为linux之前和linux之后的相同状态后，获取网卡的寄存器。通过ethregs和diff，我发现第二个RX队列的配置有所不同。RX队列的寄存器包含一个DMA位置。这是网卡将数据包内容写入驱动程序的地方。在第一次启动时，第二个RX队列将寄存器设置为零——它被禁用。在第二次启动时，那里有一个值。</p><p id="8860" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">深入研究代码，我发现iPXE只配置了一个RX队列。一幅画面开始变得清晰。linux驱动程序正在配置多个RX队列，并告诉硬件它的接收环在内存中的位置。在重新启动时，iPXE将第一个队列设置为其接收环，但是第二个RX队列保留了一个不再使用的内存位置。NIC很高兴地将一些数据包发送到第二个队列，但是没有任何东西在读取它！</p><p id="aa92" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我更喜欢保持iPXE代码简单；它不需要多个读队列。因此，我添加了一点代码，以便在它执行现有配置之前重置所有的RX和TX队列。使用新代码的第一次引导仍然运行良好，但是第二次仍然失败。显然还有更多寄存器需要复位。</p><p id="79d2" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">通过细致的区分，我发现了更多的差异。主要的违规寄存器似乎是一个名为INTELXVF_PSRTYPE的寄存器，数据手册告诉我它配置数据包如何在报头和数据之间拆分。网卡可以做一些报头处理，linux利用了这一点。这种高级设置只会让iPXE感到困惑，因为它希望整个数据包都出现在它的队列中。</p><p id="beeb" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">SRRCTL寄存器中也有一些被linux改变的标志。这些似乎不太可能导致问题，但我还是重置了它们。有了我的新变化，每种情况下的寄存器都尽可能地接近:在分配的内存位置或计数器上有微小的差异，但稳定值是相同的。</p><p id="08cd" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">剩下的就是看第二次启动是否真的有效。我切换到我的虚拟控制台来检查iPXE的输出。有那么一会儿，我想它又停下来了，但是它成功了，我被食物迎接了。成功！</p><p id="9b24" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我跑了第三个和第四个靴子的好措施。一切顺利。看来我的原型已经完成了。我为一个上游<a class="ae id" href="http://lists.ipxe.org/pipermail/ipxe-devel/2016-December/005288.html" rel="noopener ugc nofollow" target="_blank">提案</a>编译了一个补丁。我开始做其他事情。我的原型变成了一个几乎可以投入生产的系统。在我们发布之前，修复我在<a class="ae id" rel="noopener" href="/@vishvananda/the-hydra-bug-e4d3af2d61c0">第一部分</a>中解决的内核错误可能会很好。那次冒险在<a class="ae id" rel="noopener" href="/@vishvananda/the-hydra-bug-1e71347d6759">第三部</a>中有详细描述。</p><div class="ly lz ma mb fq ab cb"><figure class="mc hw md me mf mg mh paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mc hw md me mf mg mh paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mc hw md me mf mg mh paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mi mj mk"><p id="f922" class="jv jw ml jx b jy jz jh ka kb kc jk kd mm kf kg kh mn kj kk kl mo kn ko kp kq hn dt translated"><a class="ae id" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae id" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae id" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae id" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jv jw ml jx b jy jz jh ka kb kc jk kd mm kf kg kh mn kj kk kl mo kn ko kp kq hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae id" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae id" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ly lz ma mb fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="fe ff mp"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>