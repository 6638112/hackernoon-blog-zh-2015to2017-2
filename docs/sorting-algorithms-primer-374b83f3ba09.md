# 排序算法入门

> 原文：<https://medium.com/hackernoon/sorting-algorithms-primer-374b83f3ba09>

排序算法是一种采用列表或数组并按一定顺序对其元素进行重新排序的算法。有几十种不同的排序算法，如果你学过计算机科学，你可能至少熟悉其中的几种。这也是一个很受欢迎的面试问题，所以在重要的面试前提醒你一下也无妨。

下面是最常见的排序算法和 Golang 实现示例的初级读本。

# 冒泡排序

[冒泡排序](https://en.wikipedia.org/wiki/Bubble_sort)是最基本的[原地排序](https://en.wikipedia.org/wiki/In-place_algorithm)算法，也是几乎所有人都熟悉的一种。它具有о(n)最坏情况和平均时间复杂度，这使得它在大型列表上效率很低。实现非常简单。

在循环中，从第一个元素开始迭代数组，直到第 n 个元素，其中 n = len(items)。比较相邻的值，如果顺序不对，就交换它们。你可以通过在每次迭代后将 n 减 1 来优化[算法](https://hackernoon.com/tagged/algorithm)。

时间复杂度:

*   最坏的情况:O(n)
*   一般情况:O(n)
*   最佳情况:O(n)

空间复杂性:

*   最坏情况:O(1)

# 选择排序

[选择排序](https://en.wikipedia.org/wiki/Selection_sort)是另一种简单的平均情况 [O](https://en.wikipedia.org/wiki/Big_O_notation) ( *n* )就地排序算法。该算法将列表分为两个子列表，一个用于排序的项目，从空开始，从列表的开始从左到右构建，第二个子列表用于剩余的[未排序的项目。](https://hackernoon.com/tagged/remaining)

这可以通过两个嵌套的 for 循环来实现。外部循环在列表上迭代 n 次，其中 n = len(items)。内部循环将总是从外部循环的当前迭代器值开始(因此在每次迭代中，它将从列表中更靠右的位置开始)，并找出子列表的最小值。用找到的最小值交换子列表的第一项。

时间复杂度:

*   最坏的情况:O(n)
*   一般情况:O(n)
*   最佳情况:O(n)

空间复杂性:

*   最坏情况:O(1)

# 插入排序

[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)是一个简单的就地二次 O(n)排序算法。同样，它在大型列表上效率较低，但也没有什么优势:

*   自适应:对于已经基本排序的列表，时间复杂度降低——如果每个元素距离其最终排序位置不超过 k 个位置，则为 O(nk)
*   稳定:具有相等值的索引的相对位置不变
*   就地:只需要恒定的 O(1)额外内存空间
*   实际上比冒泡或选择排序更有效

时间复杂度:

*   最坏的情况:O(n)
*   一般情况:O(n)
*   最佳情况:O(n)

空间复杂性:

*   最坏情况:O(1)

实现是非常自然的，因为它的工作方式类似于你在玩纸牌游戏时如何对手中的牌进行排序。

# 外壳分类

[Shellsort](https://en.wikipedia.org/wiki/Shellsort) 是插入排序的推广。这是一个有趣的排序算法，它通过将一个列表排列成一组交错排序的子列表来工作。

首先，选择一系列间隙。有许多不同的公式来生成间隙序列，并且算法的平均时间复杂度取决于该变量。例如，让我们选择(2^k)-1 前缀为 1，这将给我们[1，3，7，15，31，63，...]。颠倒顺序:[…，63，31，15，7，3，q]。

现在迭代反向间隙列表，并在每个子列表上使用插入排序。所以在第一次迭代中，取每 63 个元素并应用插入排序。在第二次迭代中，取每 31 个元素并应用插入排序。以此类推，一直到 1。最后一次迭代将在整个列表上运行插入排序。

时间复杂度:

*   最坏情况:O( *n(* log(n) *)* )
*   一般情况:取决于间隙序列
*   最佳情况:O( *n(* log(n) *)* )

空间复杂性:

*   最坏情况:O(1)

# 梳状排序

[梳状排序](https://en.wikipedia.org/wiki/Comb_sort)是对冒泡排序算法的改进。冒泡排序总是比较相邻的元素(gap=1)，而梳状排序从 gap=n/1.3 开始，其中 n=len(items)，并在每次迭代中缩小 1.3 倍。

这种改进背后的想法是消除所谓的海龟(列表末尾附近的小值)。最后一次迭代与 gap=1 时的简单冒泡排序相同。

时间复杂度:

*   最坏的情况:O(n)
*   平均情况:O(n /2^p) (p 是增量数)
*   最佳情况:O( *n(* log(n) *)* )

空间复杂性:

*   最坏情况:O(1)

# 合并排序

[归并排序](https://en.wikipedia.org/wiki/Merge_sort)是一个非常高效的通用排序算法。这是一个[分治算法](https://en.wikipedia.org/wiki/Divide_and_conquer_algorithm)，这意味着列表被递归地分解成更小的列表，这些列表被排序，然后被递归地组合以形成完整的列表。

> 从概念上讲，合并排序的工作方式如下:
> 
> 1.将未排序的列表分成 *n* 个子列表，每个子列表包含 1 个元素(包含 1 个元素的列表被视为已排序)。
> 
> 2.重复[合并](https://en.wikipedia.org/wiki/Merge_algorithm)子列表以产生新的排序子列表，直到只剩下 1 个子列表。这将是排序后的列表。
> 
> *——*[*百科*](https://en.wikipedia.org/wiki/Merge_sort)

时间复杂度:

*   最坏情况:O( *n(* log(n) *)* )
*   平均事例:O( *n(* log(n) *)* )
*   最佳情况:O( *n(* log(n) *)*

空间复杂性:

*   最坏的情况:O(n)

暂时就这样了。然而，我将在未来涵盖更多的排序算法，所以书签这一页:)

> [黑客中午](http://bit.ly/Hackernoon)是黑客如何开始他们的下午。我们是这个家庭的一员。我们现在[接受投稿](http://bit.ly/hackernoonsubmission)并乐意[讨论广告&赞助](mailto:partners@amipublications.com)机会。
> 
> 要了解更多信息，[请阅读我们的“关于”页面](https://goo.gl/4ofytp)、[在脸书上给我们点赞/发消息](http://bit.ly/HackernoonFB)，或者简单地说， [tweet/DM @HackerNoon。](https://goo.gl/k7XYbx)
> 
> 如果你喜欢这个故事，我们推荐你阅读我们的[最新科技故事](http://bit.ly/hackernoonlatestt)和[趋势科技故事](https://hackernoon.com/trending)。直到下一次，不要把世界的现实想当然！