<html>
<head>
<title>How to Scale WebSockets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何扩展WebSockets</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/scaling-websockets-9a31497af051?source=collection_archive---------0-----------------------#2017-07-17">https://medium.com/hackernoon/scaling-websockets-9a31497af051?source=collection_archive---------0-----------------------#2017-07-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/d24b3c6e3b46e43f72737b13f4cfdb29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aIe9-weNp6BxukmowahBdA.jpeg"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Scaling WebSockets</figcaption></figure><div class=""/><p id="359c" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在与还没有使用过WebSockets的开发人员交谈时，他们通常会有同样的担心:如何在多台服务器上横向扩展？</p><p id="c98e" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果所有订阅者都连接到一台服务器上，那么发布到该服务器上的一个频道是可以的。一旦您有了多台服务器，您就需要添加一些其他的东西。这就是这篇文章试图解决的问题。</p><h1 id="e570" class="kf kg ij bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">扩展HTTP与WebSockets</h1><p id="e7b3" class="pw-post-body-paragraph jg jh ij ji b jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz lh kb kc kd hn dt translated">为了理解为什么向外扩展WebSockets看起来令人生畏，让我们将其与HTTP进行对比，因为大多数人都很好地理解了它。</p><p id="bce5" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">使用HTTP，您有一个一次性的请求/回复模式，您不希望来自客户端的下一个请求返回到同一个服务器。至少您不应该这样做，因为这意味着您有一个棘手的会话问题，并且您不能轻松地向外扩展性能或冗余。</p><p id="6c33" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">使用HTTP，您可以在负载均衡器后面运行几乎无限量的web服务器实例。当请求到达时，负载平衡器将请求传递给一个健康的web服务器实例，一旦web服务器计算出响应，就将响应传递回客户机。HTTP连接通常是非常短暂的，它们只存在到给出响应为止。这是一种很好理解的、无处不在的方法，它的伸缩性很好。长时间轮询是个例外，但这并不常见，对这篇文章来说也不重要。</p><p id="1df5" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">另一方面，WebSockets不同于HTTP请求，因为它们是持久的。WebSocket客户端打开一个到服务器的连接并重用它。在这个长时间运行的连接中，服务器和客户端都可以发布和响应事件。这个概念被称为<a class="ae ke" href="http://searchnetworking.techtarget.com/definition/duplex" rel="noopener ugc nofollow" target="_blank">双工连接</a>。一个连接可以通过负载平衡器打开，但是一旦连接打开，它就一直在同一个服务器上，直到它被关闭或中断。</p><p id="4d92" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这反过来意味着交互是有状态的；对于每个打开的客户端连接，您最终将至少在WebSocket服务器的内存中存储一些数据。例如，您可能知道哪个用户在套接字的客户端，以及用户对哪种数据感兴趣。</p><p id="c408" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">WebSocket连接是<strong class="ji ik">持久的</strong>这一事实使得它对于<strong class="ji ik">实时应用</strong>如此强大，但也使得它更加<strong class="ji ik">难以扩展</strong>。</p><h1 id="1718" class="kf kg ij bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">一个示例WebSocket应用程序</h1><p id="5125" class="pw-post-body-paragraph jg jh ij ji b jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz lh kb kc kd hn dt translated">让我们讨论一个示例应用程序，这样我们可以在更具体的环境中讨论问题和方法。</p><p id="54bc" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">对于我们的例子，让我们选择一个协作白板应用程序。在这个应用程序中，有多个白板，这意味着人们可以在多个图纸上合作。当用户在特定的白板上绘图时，它通过WebSocket连接将坐标发布给所有其他打开相同白板的用户。换句话说，我们有一个通过WebSockets公开的发布/订阅模式。</p><p id="84d5" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在这个例子中，这意味着应用程序的每个用户的套接字连接的服务器端至少需要知道用户打开了什么白板。</p><p id="91af" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">像<a class="ae ke" href="https://socket.io/" rel="noopener ugc nofollow" target="_blank"> socket.io </a>这样的Web socket实现有通道的概念。可以把它想象成一个地址，客户端可以订阅该地址，服务或其他客户端可以向该地址发布内容。</p><p id="aa4c" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">人们可能会认为，构建我们的协作白板应用程序所需要做的就是利用通道(每个白板都有自己的通道)，然后坐下来放松一下，但正如你将在本文的其余部分看到的那样，你仍然会遇到横向扩展和容错的问题。</p><h1 id="696a" class="kf kg ij bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">你需要一个发布/订阅代理</h1><p id="d4da" class="pw-post-body-paragraph jg jh ij ji b jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz lh kb kc kd hn dt translated">首先，当我说“<strong class="ji ik"><em class="li"/></strong>”时，我指的是什么？有各种各样的技术在相当大的规模上支持<a class="ae ke" href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern" rel="noopener ugc nofollow" target="_blank">发布/订阅模式</a>。</p><p id="ff6d" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">当您需要在套接字上扩展发布/订阅架构时，您需要找到一种好的发布/订阅技术作为您的解决方案的核心。</p><p id="9575" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们不需要为这篇文章指定一个特定的选项，但这里有一些好的选项:<a class="ae ke" href="https://redis.io/topics/pubsub" rel="noopener ugc nofollow" target="_blank"> Redis </a>、<a class="ae ke" href="https://www.rabbitmq.com/tutorials/tutorial-three-python.html" rel="noopener ugc nofollow" target="_blank"> RabbitMQ </a>、<a class="ae ke" href="https://codurance.com/2016/05/16/publish-subscribe-model-in-kafka/" rel="noopener ugc nofollow" target="_blank"> Kafka </a>和<a class="ae ke" href="https://rethinkdb.com/docs/changefeeds/javascript/" rel="noopener ugc nofollow" target="_blank"> RethinkDB </a>。</p><p id="3629" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">为了理解为什么我们需要添加一个发布/订阅代理来帮助您扩展您的WebSockets，让我们首先在一个服务器的上下文中考虑我们的例子。</p><p id="f9ed" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">有了一台服务器，只使用WebSockets构建发布/订阅服务实际上相当容易。这是因为在一个服务器上，该服务器将知道所有客户端以及客户端对什么数据感兴趣。</p><p id="21fb" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">想想我们的示例应用程序。当客户端通过坐标发送绘图时，我们只需找到绘图的正确通道，并将对绘图的更新发布到该通道。所有的客户端都连接到一个服务器上，所以它们都会收到更改通知。<strong class="ji ik">有点像内存发布/订阅</strong>。</p><p id="ddda" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">但实际上，我们希望跨多个服务器进行扩展，我们希望这样做有两个原因:<strong class="ji ik"> 1) </strong> <strong class="ji ik">共享处理能力</strong>，以及<strong class="ji ik"> 2)冗余。</strong></p><p id="62e7" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">那么，我们能做些什么来确保我们的应用程序能够横向扩展呢？嗯，我们需要某种方式让其他连接了客户端的服务知道数据已经改变。</p><p id="1299" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">当构建这样的应用程序时，您可能已经有了一个数据库，甚至在您开始考虑扩展之前。你不会仅仅信任连接的客户端来存储所有绘图的所有数据，对吗？不，您将希望保存来自客户端的绘图数据，以便您可以在用户打开绘图时提供绘图数据。</p><p id="f1db" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">但问题来了。如果<strong class="ji ik">服务器A </strong>上的WebSocket向数据库中写入一些数据，那么<strong class="ji ik">服务器B </strong>上的WebSocket如何知道从数据库中获取最新的数据，以便通知其客户端新的数据呢？</p><p id="57b9" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们讨论一下在您的解决方案中使用Redis的过程。尽管您的集群中可能有数百个WebSocket服务器，但是让我们假设您只有<strong class="ji ik"> 3 </strong>个服务器来简化事情。我们将这些服务器称为<strong class="ji ik"> WS1 </strong>、<strong class="ji ik"> WS2 </strong>和<strong class="ji ik"> WS3 </strong>。有时候，我会惊讶于自己给东西起的惊人的创意名字！</p><p id="9863" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">好吧，让我们假设你有9个人打开了一幅狗骑着小马骑着恐龙的特定图画，保存在你的数据库中，id为<strong class="ji ik"> abc123 </strong>。假设您有<strong class="ji ik"> 3 </strong>个人连接到集群中的每台服务器(WS1、WS2、WS3)。</p><p id="795b" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">连接到<strong class="ji ik"> WS1 </strong>的用户之一在白板上画了些东西。在您的WebSocket服务器逻辑中，您写入数据库以确保更改已被持久化，然后根据与绘图相关联的唯一标识符(很可能是根据绘图的数据库id)发布到通道。假设这种情况下的通道名是<strong class="ji ik"> drawing_abc123 </strong>。</p><p id="fb89" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">此时，您已经将数据安全地写在数据库中，并且您已经向您的发布/订阅代理(Redis通道)发布了一个事件，通知其他相关方有新数据。</p><p id="0ef2" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">因为您有连接到其他WebSocket服务器(WS2、WS3)的用户，他们对同一个绘图感兴趣，他们将在<strong class="ji ik"> drawing_abc123 </strong>通道上开放Redis订阅。它们会收到事件通知，每个服务器都会向DB查询更新，并在WebSocket层上使用的WebSocket通道上发出更新。</p><p id="363d" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">因此，您可以看到，发布/订阅代理用于允许您通过横向扩展的WebSocket集群公开发布/订阅模型。</p><h1 id="6b7f" class="kf kg ij bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">处理故障转移</h1><p id="3494" class="pw-post-body-paragraph jg jh ij ji b jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz lh kb kc kd hn dt translated">使用发布/订阅代理协调WebSockets的另一个好处是，现在可以轻松处理故障转移。</p><p id="943a" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">当客户端连接到WebSocket服务器时，如果该服务器发生故障，客户端可以通过负载平衡器打开到另一个WebSocket服务器的连接。新的WebSocket服务器将确保订阅WebSocket客户端感兴趣的数据的发布/订阅代理，并在WebSocket上发生更改时通过管道传输这些更改。</p><h1 id="fc03" class="kf kg ij bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">使用增量</h1><p id="192b" class="pw-post-body-paragraph jg jh ij ji b jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz lh kb kc kd hn dt translated">当客户端重新连接时，要考虑的一件事是让客户端足够智能，它通过某种数据同步偏移(可能以时间戳的形式)发送，这样服务器就不会再次向它发送所有数据。</p><p id="5055" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果对所讨论的绘图的每次更新都有时间戳，则客户端可以轻松地存储他们收到的最新时间戳。当客户端失去与特定服务器的连接时，它可以通过传入它收到的最后一个时间戳来重新连接到您的websocket集群(通过您的负载平衡器),这样就可以建立对数据库的查询，以便它只返回在客户端最后一次成功接收更新之后发生的更新。</p><p id="4765" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在大量的应用程序中，担心副本被下载到客户端可能不是那么重要。但是即使这样，使用时间戳方法来节省资源和用户的带宽也是一个好主意。</p><h1 id="5095" class="kf kg ij bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">结论</h1><p id="f5ba" class="pw-post-body-paragraph jg jh ij ji b jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz lh kb kc kd hn dt translated">构建一个在一台服务器上运行的发布/订阅服务相对容易。挑战在于构建一个可以水平扩展的服务，以实现负载共享和容错。</p><p id="51e0" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">当您向外扩展时，您需要一种方法让web socket服务订阅更改的数据，因为对所述数据的更改也将来自其他服务器而不是它本身。支持实时查询的数据库非常适合这个目的，例如RethinkDB。这样你只有WebSockets和你的数据库。也就是说，你可能已经在你的环境中使用了支持发布/订阅的<a class="ae ke" href="https://hackernoon.com/tagged/technology" rel="noopener ugc nofollow" target="_blank">技术</a> (Redis，RabbitMQ，Kafka)，这将比引入一种新的数据库技术要容易得多。</p><h1 id="0ef6" class="kf kg ij bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">感谢阅读！:)如果你喜欢它，请点击下面的心形按钮表示支持。💚</h1><figure class="lj lk ll lm fq hw"><div class="bz el l di"><div class="ln lo l"/></div></figure></div></div>    
</body>
</html>