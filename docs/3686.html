<html>
<head>
<title>Introducing Trans 2.0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Trans 2.0简介</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/introducing-trans2-407610887068?source=collection_archive---------11-----------------------#2017-04-17">https://medium.com/hackernoon/introducing-trans2-407610887068?source=collection_archive---------11-----------------------#2017-04-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/e626215597e0e7e045f726296db0307a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JY_impSbrfGsBykD1uOCHw.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="64ba" class="pw-subtitle-paragraph jc ie if bd b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ek translated">更小、更安全、更易用、更灵活</h2></div><h1 id="4430" class="ju jv if bd jw jx jy jz ka kb kc kd ke jl kf jm kg jo kh jp ki jr kj js kk kl dt translated">什么是反式？</h1><p id="d103" class="pw-post-body-paragraph km kn if ko b kp kq jg kr ks kt jj ku kv kw kx ky kz la lb lc ld le lf lg lh hn dt translated"><a class="ae li" href="https://hex.pm/packages/trans" rel="noopener ugc nofollow" target="_blank"> <strong class="ko ig"> Trans </strong> </a> <strong class="ko ig">是一个管理嵌入数据结构</strong>的翻译的药剂库。虽然<a class="ae li" href="https://hackernoon.com/tagged/frans" rel="noopener ugc nofollow" target="_blank"> Trans </a>只能用于从映射或结构中获取翻译，但当与<a class="ae li" href="https://hex.pm/packages/ecto" rel="noopener ugc nofollow" target="_blank"> Ecto </a>结合使用时，它可以从数据库中获取和查询翻译。</p><p id="d0d5" class="pw-post-body-paragraph km kn if ko b kp lj jg kr ks lk jj ku kv ll kx ky kz lm lb lc ld ln lf lg lh hn dt translated">传统的翻译管理方法是使用专用于翻译存储的数据库表。例如，我们可能有一个<code class="eh lo lp lq lr b">posts</code>表和一个伴随的<code class="eh lo lp lq lr b">post_translations</code>表。这是Ruby gem <a class="ae li" href="https://rubygems.org/gems/globalize" rel="noopener ugc nofollow" target="_blank"> Globalize </a>使用的方法。</p><p id="e947" class="pw-post-body-paragraph km kn if ko b kp lj jg kr ks lk jj ku kv ll kx ky kz lm lb lc ld ln lf lg lh hn dt translated">虽然这种方法经过了实战检验，并且行之有效，但它也有一些可以改进的缺点:</p><ul class=""><li id="ac33" class="ls lt if ko b kp lj ks lk kv lu kz lv ld lw lh lx ly lz ma dt translated">这使得数据库模式变得复杂，需要为每个可翻译的模式创建一个新表。</li><li id="faa8" class="ls lt if ko b kp mb ks mc kv md kz me ld mf lh lx ly lz ma dt translated">这使得数据库迁移变得复杂，因为表结构的变化必须复制到转换表中。</li><li id="45bb" class="ls lt if ko b kp mb ks mc kv md kz me ld mf lh lx ly lz ma dt translated">它需要常量<em class="mg">连接</em>来过滤或获取记录及其翻译。当多个可翻译模式介入一个查询时，这对性能有明显的影响。</li></ul><p id="cf55" class="pw-post-body-paragraph km kn if ko b kp lj jg kr ks lk jj ku kv ll kx ky kz lm lb lc ld ln lf lg lh hn dt translated">现代的RDBMSs支持非结构化的数据类型，比如JSON。<strong class="ko ig">我们可以利用这种非结构化的数据类型支持，将翻译嵌入到模式本身的字段中</strong>，而不是为翻译使用单独的模式。这消除了同步维护重复数据库表的需要，并大大减少了查询中的JOIN子句的数量。</p><p id="f4fd" class="pw-post-body-paragraph km kn if ko b kp lj jg kr ks lk jj ku kv ll kx ky kz lm lb lc ld ln lf lg lh hn dt translated">虽然数据库本身提供了访问非结构化数据的机制，但Ecto 本身并没有提供一个高级接口来方便地访问这些数据。这是传送任务开始的地方。</p><p id="df8e" class="pw-post-body-paragraph km kn if ko b kp lj jg kr ks lk jj ku kv ll kx ky kz lm lb lc ld ln lf lg lh hn dt translated">Ecto允许您编写定制的SQL片段，可以用来访问数据库中的JSON字段。为每个需要翻译的查询编写这些SQL片段会很快变得令人厌倦并且容易出错。Trans为您生成SQL片段，并在编译时验证它们。</p><h1 id="7544" class="ju jv if bd jw jx jy jz ka kb kc kd ke jl kf jm kg jo kh jp ki jr kj js kk kl dt translated">Trans 1.0 sins</h1><h2 id="ab33" class="mh jv if bd jw mi mj mk ka ml mm mn ke kv mo mp kg kz mq mr ki ld ms mt kk mu dt translated">绕过查询的Ecto语法</h2><p id="00c1" class="pw-post-body-paragraph km kn if ko b kp kq jg kr ks kt jj ku kv kw kx ky kz la lb lc ld le lf lg lh hn dt translated"><a class="ae li" href="https://hexdocs.pm/ecto/Ecto.Query.html#content" rel="noopener ugc nofollow" target="_blank">爱克托。查询</a>为查询生成提供了一个很好的语法。可以使用一系列宏(或函数，取决于您喜欢的API)编写查询，这些宏允许参数插值、数据绑定、组合和前缀。</p><p id="b8ba" class="pw-post-body-paragraph km kn if ko b kp lj jg kr ks lk jj ku kv ll kx ky kz lm lb lc ld ln lf lg lh hn dt translated">Trans没有增强它，而是提供了它自己的、不同的、不与之交互的API。这造成了一系列的不便和限制。</p><p id="e317" class="pw-post-body-paragraph km kn if ko b kp lj jg kr ks lk jj ku kv ll kx ky kz lm lb lc ld ln lf lg lh hn dt translated">第一个也是最明显的不便出现在用可翻译数据的一些条件编写查询时。Trans 1.0不是在构建查询时指定条件，而是要求首先构建查询，然后将查询传递给添加所需条件的函数。</p><p id="b759" class="pw-post-body-paragraph km kn if ko b kp lj jg kr ks lk jj ku kv ll kx ky kz lm lb lc ld ln lf lg lh hn dt translated">第一个也是最明显的不便出现在用可翻译数据的一些条件编写查询时。对于普通的ect查询，您将在构建查询本身时指定条件。相反，<strong class="ko ig"> Trans 1.0要求首先构建查询，然后将其传递给一个函数，该函数将添加所需的条件。</strong></p><figure class="mv mw mx my fq hw"><div class="bz el l di"><div class="mz na l"/></div><figcaption class="nb nc fg fe ff nd ne bd b be z ek">The <strong class="ak">QueryBuilder</strong> component bypassed <strong class="ak">Ecto.Query</strong> functionality. Ugly to say the least…</figcaption></figure><p id="d163" class="pw-post-body-paragraph km kn if ko b kp lj jg kr ks lk jj ku kv ll kx ky kz lm lb lc ld ln lf lg lh hn dt translated">这种方法的另一个问题是，可翻译字段上的<strong class="ko ig">条件只能添加到查询</strong>的主模式上。联接模式和关联已经过时了…哎哟！</p><h2 id="1efc" class="mh jv if bd jw mi mj mk ka ml mm mn ke kv mo mp kg kz mq mr ki ld ms mt kk mu dt translated">混合模式模块中的职责</h2><p id="8d7a" class="pw-post-body-paragraph km kn if ko b kp kq jg kr ks kt jj ku kv kw kx ky kz la lb lc ld le lf lg lh hn dt translated">翻译容器是嵌入模式翻译的字段。Trans默认使用一个名为translations的字段，但允许对其进行定制。</p><p id="62ef" class="pw-post-body-paragraph km kn if ko b kp lj jg kr ks lk jj ku kv ll kx ky kz lm lb lc ld ln lf lg lh hn dt translated">在Trans 1.0中，有两种选择:直接调用QueryBuilder函数，或者在模式模块中使用Trans来设置一些方便的函数以避免重复。设置便利函数是最舒适的选择，但是它<strong class="ko ig">给不属于那里的模式模块</strong>增加了额外的责任和关注。</p><figure class="mv mw mx my fq hw"><div class="bz el l di"><div class="mz na l"/></div><figcaption class="nb nc fg fe ff nd ne bd b be z ek">Trans 1.0 polluted the modules interface and mixed concerns that should belong to other parts of the application.</figcaption></figure><h2 id="0963" class="mh jv if bd jw mi mj mk ka ml mm mn ke kv mo mp kg kz mq mr ki ld ms mt kk mu dt translated">对翻译错误不安全</h2><p id="2fbf" class="pw-post-body-paragraph km kn if ko b kp kq jg kr ks kt jj ku kv kw kx ky kz la lb lc ld le lf lg lh hn dt translated">Trans 1.0针对翻译错误执行了一些基本的检查。例如，试图在不可翻译的字段上添加查询条件会导致运行时<code class="eh lo lp lq lr b">ArgumentError</code>。</p><p id="9d6e" class="pw-post-body-paragraph km kn if ko b kp lj jg kr ks lk jj ku kv ll kx ky kz lm lb lc ld ln lf lg lh hn dt translated"><strong class="ko ig"> Trans 2.0改进了这些检查，并在编译阶段而不是运行时产生错误。</strong></p><figure class="mv mw mx my fq hw"><div class="bz el l di"><div class="mz na l"/></div><figcaption class="nb nc fg fe ff nd ne bd b be z ek">Trans would let you add conditions on non-existing fields which resulted in run-time errors.</figcaption></figure><h1 id="35fd" class="ju jv if bd jw jx jy jz ka kb kc kd ke jl kf jm kg jo kh jp ki jr kj js kk kl dt translated">Trans 2.0改进</h1><h2 id="2bba" class="mh jv if bd jw mi mj mk ka ml mm mn ke kv mo mp kg kz mq mr ki ld ms mt kk mu dt translated">包含用于查询的Ecto语法</h2><p id="5912" class="pw-post-body-paragraph km kn if ko b kp kq jg kr ks kt jj ku kv kw kx ky kz la lb lc ld le lf lg lh hn dt translated">在Trans 2.0中，QueryBuilder组件已经完全重写:<strong class="ko ig">它现在在编译时运行，它唯一的任务是生成所需的SQL片段</strong>。QueryBuilder模块中所有不同的功能都被统一到了<code class="eh lo lp lq lr b">translated/3</code>宏中。</p><p id="b68c" class="pw-post-body-paragraph km kn if ko b kp lj jg kr ks lk jj ku kv ll kx ky kz lm lb lc ld ln lf lg lh hn dt translated">作为一个宏，QueryBuilder可以在编译时生成SQL片段，并将其添加到正在编译的查询中。这样我们可以在创建Ecto查询时使用<code class="eh lo lp lq lr b">translated/3</code>宏，<strong class="ko ig">与</strong> <code class="eh lo lp lq lr b"><strong class="ko ig">Ecto.Query</strong></code> <strong class="ko ig">和</strong> <code class="eh lo lp lq lr b"><strong class="ko ig">Ecto.Query.Api</strong></code>提供的其余函数和宏进行交互。</p><figure class="mv mw mx my fq hw"><div class="bz el l di"><div class="mz na l"/></div><figcaption class="nb nc fg fe ff nd ne bd b be z ek">The <strong class="ak">translated/3</strong> macro is compatible with <strong class="ak">Ecto.Query</strong> and <strong class="ak">Ecto.Query.Api</strong></figcaption></figure><h2 id="e6c7" class="mh jv if bd jw mi mj mk ka ml mm mn ke kv mo mp kg kz mq mr ki ld ms mt kk mu dt translated">从模式模块中提取责任</h2><p id="d27b" class="pw-post-body-paragraph km kn if ko b kp kq jg kr ks kt jj ku kv kw kx ky kz la lb lc ld le lf lg lh hn dt translated">对于Trans 2.0，<strong class="ko ig">模块仅导出一个名为</strong> <code class="eh lo lp lq lr b"><strong class="ko ig">__trans__</strong></code>的下划线函数，该函数返回模块的Trans配置。</p><p id="bd7e" class="pw-post-body-paragraph km kn if ko b kp lj jg kr ks lk jj ku kv ll kx ky kz lm lb lc ld ln lf lg lh hn dt translated">这个<strong class="ko ig">保持了客户端模块的整洁，并保持了包含在QueryBuilder和Translator模块</strong>中的逻辑，而不是将它分散在客户端代码中。</p><h2 id="8b1a" class="mh jv if bd jw mi mj mk ka ml mm mn ke kv mo mp kg kz mq mr ki ld ms mt kk mu dt translated">尽快进行安全检查</h2><p id="6804" class="pw-post-body-paragraph km kn if ko b kp kq jg kr ks kt jj ku kv kw kx ky kz la lb lc ld le lf lg lh hn dt translated">如前所述，Trans 1.0在运行时做了一些基本的检查。由于每个模块的翻译配置是在编译期间设置的，Trans 2.0在运行前使用它来执行安全检查。</p><p id="6b56" class="pw-post-body-paragraph km kn if ko b kp lj jg kr ks lk jj ku kv ll kx ky kz lm lb lc ld ln lf lg lh hn dt translated">想翻译一个不存在的字段吗？您的应用程序无法编译。想要翻译不可翻译的字段？呜…你的应用程序无法编译。嗯……你明白了。这使得Trans 2.0比之前的版本更安全，更平易近人。</p><h1 id="e5c0" class="ju jv if bd jw jx jy jz ka kb kc kd ke jl kf jm kg jo kh jp ki jr kj js kk kl dt translated">未来计划</h1><p id="f491" class="pw-post-body-paragraph km kn if ko b kp kq jg kr ks kt jj ku kv kw kx ky kz la lb lc ld le lf lg lh hn dt translated">通过此次更新，Trans处于良好的维护和持续改进状态。我想在Trans的未来版本中包含的主要功能有:</p><ul class=""><li id="66dd" class="ls lt if ko b kp lj ks lk kv lu kz lv ld lw lh lx ly lz ma dt translated"><strong class="ko ig">支持MySQL </strong>。MySQL 5.7引入了一个原生JSON类型，Trans可以像使用PostgreSQL JSONB类型一样使用它。在<a class="ae li" href="https://github.com/xerions/mariaex" rel="noopener ugc nofollow" target="_blank"> MySQL数据库驱动</a>仓库中有一个<a class="ae li" href="https://github.com/xerions/mariaex/issues/119" rel="noopener ugc nofollow" target="_blank">未解决的问题</a>来增加对这种类型的支持。</li><li id="5a50" class="ls lt if ko b kp mb ks mc kv md kz me ld mf lh lx ly lz ma dt translated"><a class="ae li" href="https://github.com/belaustegui/trans/issues/14" rel="noopener ugc nofollow" target="_blank"> <strong class="ko ig">指定可用的区域设置</strong></a><strong class="ko ig"/><a class="ae li" href="https://github.com/belaustegui/trans/issues/12" rel="noopener ugc nofollow" target="_blank"><strong class="ko ig">自定义回退序列</strong> </a>。目前，当翻译不存在时，Trans会回到默认语言。可以对这种行为进行定制，以便在回到默认语言之前检查其他语言环境。</li><li id="5d48" class="ls lt if ko b kp mb ks mc kv md kz me ld mf lh lx ly lz ma dt translated"><strong class="ko ig">使翻译成为嵌入式模式，并创建一个定制的Ecto类型</strong>。这仍然是一个未完成的想法，但是这里的主要目标是将翻译表示为嵌入式模式。这样，翻译可以指定它们自己的变更集，并执行所需的验证或转换。</li></ul><h1 id="a16c" class="ju jv if bd jw jx jy jz ka kb kc kd ke jl kf jm kg jo kh jp ki jr kj js kk kl dt translated">包扎</h1><p id="f5d0" class="pw-post-body-paragraph km kn if ko b kp kq jg kr ks kt jj ku kv kw kx ky kz la lb lc ld le lf lg lh hn dt translated">Trans首次发布是在2016年6月4日，所以很快就到了一年的寿命。这是一段有趣的旅程，<strong class="ko ig">我们发布了6个版本，提交了159个，下载量达到了近250次</strong>。谢谢大家！</p><p id="110a" class="pw-post-body-paragraph km kn if ko b kp lj jg kr ks lk jj ku kv ll kx ky kz lm lb lc ld ln lf lg lh hn dt translated">随着这个新版本的发布，Trans已经达到了一个成熟的水平，使得它在未来的时间里更加可用、安全和可维护。所以期待未来更多的改进和特性。</p><p id="2184" class="pw-post-body-paragraph km kn if ko b kp lj jg kr ks lk jj ku kv ll kx ky kz lm lb lc ld ln lf lg lh hn dt translated">如果你发现了一个bug，或者有任何想法或评论，欢迎发表在这里，或者<a class="ae li" href="https://github.com/belaustegui/trans/issues/new" rel="noopener ugc nofollow" target="_blank">在GitHub </a>上发表一个问题。在Elixir论坛的<a class="ae li" href="https://elixirforum.com/t/trans-embedded-translations-for-elixir/840" rel="noopener ugc nofollow" target="_blank"> Trans线程中也有有趣的讨论。</a></p><p id="a79e" class="pw-post-body-paragraph km kn if ko b kp lj jg kr ks lk jj ku kv ll kx ky kz lm lb lc ld ln lf lg lh hn dt translated">在结束这篇文章之前，我想特别感谢我的朋友们<a class="nf ng gr" href="https://medium.com/u/ff2508be75f8?source=post_page-----407610887068--------------------------------" rel="noopener" target="_blank">óscar de arriba</a>，<a class="nf ng gr" href="https://medium.com/u/a15f8add882e?source=post_page-----407610887068--------------------------------" rel="noopener" target="_blank"> Victor Ortiz </a>，<a class="nf ng gr" href="https://medium.com/u/a70e615c440b?source=post_page-----407610887068--------------------------------" rel="noopener" target="_blank"> Enol Iglesias </a>，<a class="nf ng gr" href="https://medium.com/u/d0b19f8b8579?source=post_page-----407610887068--------------------------------" rel="noopener" target="_blank">Ruben Sierra</a>和<a class="nf ng gr" href="https://medium.com/u/909015f6e9c2?source=post_page-----407610887068--------------------------------" rel="noopener" target="_blank">dreaming choes</a>对❤️.的所有支持在<a class="ae li" href="http://www.elixirconf.eu/" rel="noopener ugc nofollow" target="_blank"> ElixirConf上见。欧盟</a>！</p><div class="mv mw mx my fq ab cb"><figure class="nh hw ni nj nk nl nm paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nh hw ni nj nk nl nm paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nh hw ni nj nk nl nm paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="nn no np"><p id="f922" class="km kn mg ko b kp lj jg kr ks lk jj ku nq ll kx ky nr lm lb lc ns ln lf lg lh hn dt translated">黑客中午是黑客如何开始他们的下午。我们是这个家庭的一员。我们现在<a class="ae li" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae li" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="km kn mg ko b kp lj jg kr ks lk jj ku nq ll kx ky nr lm lb lc ns ln lf lg lh hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae li" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae li" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="mv mw mx my fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nt"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="mv mw mx my fq hw"><div class="bz el l di"><div class="nu na l"/></div></figure></div></div>    
</body>
</html>