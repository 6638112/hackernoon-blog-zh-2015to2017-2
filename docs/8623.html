<html>
<head>
<title>I Finally Understand Static vs. Dynamic Typing and You Will Too!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我终于明白了静态和动态打字的区别，你也会明白的！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/i-finally-understand-static-vs-dynamic-typing-and-you-will-too-ad0c2bd0acc7?source=collection_archive---------1-----------------------#2017-12-08">https://medium.com/hackernoon/i-finally-understand-static-vs-dynamic-typing-and-you-will-too-ad0c2bd0acc7?source=collection_archive---------1-----------------------#2017-12-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="d5fc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我决定要理解某件事时，我会变得痴迷，直到最终理解为止。我的最新尝试？<strong class="it hv">静态与动态打字</strong>。</p><p id="2187" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://stackoverflow.com/questions/1517582/what-is-the-difference-between-statically-typed-and-dynamically-typed-languages" rel="noopener ugc nofollow" target="_blank">栈溢出</a>的回答令人困惑，冗长，甚至自相矛盾。原来这些术语经常被误解，所以我的搜索会被证明是困难的是有道理的。我继续阅读我能找到的任何东西，但没有什么能满足我对平易近人和简洁的渴望。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="jv jw l"/></div></figure><p id="4d54" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我将从一些基本术语开始，温和地引导你开悟…</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="fe ff jx"><img src="../Images/82da4502ef183da0287c534db61bbd83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Jf_7uXJNpyJQ6ifVgxPtw.jpeg"/></div></div><figcaption class="ke kf fg fe ff kg kh bd b be z ek">RIGHT: “man I should read that article about type systems too…”</figcaption></figure><h1 id="388a" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">编译与解释</h1><p id="8955" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">“当源代码被翻译时”</p><ul class=""><li id="1ca5" class="ll lm hu it b iu iv iy iz jc ln jg lo jk lp jo lq lr ls lt dt translated">源代码:原始代码(通常由人输入计算机)</li><li id="4eaa" class="ll lm hu it b iu lu iy lv jc lw jg lx jk ly jo lq lr ls lt dt translated"><strong class="it hv">翻译</strong>:将源代码转换成计算机可读的东西(即机器码)</li><li id="aef3" class="ll lm hu it b iu lu iy lv jc lw jg lx jk ly jo lq lr ls lt dt translated"><strong class="it hv">运行时间</strong>:程序执行命令的时间(编译后，如果已编译)</li><li id="8118" class="ll lm hu it b iu lu iy lv jc lw jg lx jk ly jo lq lr ls lt dt translated"><strong class="it hv">编译过的</strong>:运行前翻译的代码</li><li id="6534" class="ll lm hu it b iu lu iy lv jc lw jg lx jk ly jo lq lr ls lt dt translated"><strong class="it hv">解释的</strong>:代码在执行过程中被即时翻译</li></ul></div><div class="ab cl lz ma hc mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hn ho hp hq hr"><h1 id="1351" class="ki kj hu bd kk kl mg kn ko kp mh kr ks kt mi kv kw kx mj kz la lb mk ld le lf dt translated">打字</h1><p id="0743" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">"检查类型时"</p><p id="6653" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ml mm mn mo b">"3" + 5</code>将在<em class="mp">强类型</em>语言中引发类型错误，比如Python和Go，因为它们不允许“类型强制”:值在特定上下文中隐式改变类型的能力(例如使用<code class="eh ml mm mn mo b">+</code>合并两种类型)。<em class="mp">弱类型</em>语言，比如JavaScript，不会抛出类型错误(结果:<code class="eh ml mm mn mo b">'35'</code>)。</p><ul class=""><li id="b41d" class="ll lm hu it b iu iv iy iz jc ln jg lo jk lp jo lq lr ls lt dt translated"><strong class="it hv">静态</strong>:运行前检查的类型</li><li id="c69c" class="ll lm hu it b iu lu iy lv jc lw jg lx jk ly jo lq lr ls lt dt translated"><strong class="it hv">动态</strong>:在执行过程中动态检查类型</li></ul></div><div class="ab cl lz ma hc mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hn ho hp hq hr"><p id="9bb7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">“静态和编译”和“动态和解释”的定义非常相似…但是记住是“当类型被检查时”和“当源代码被翻译时”。</p><p id="7ea5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">类型检查与正在编译或解释的语言没有任何关系！你需要从概念上区分这些术语。</p></div><div class="ab cl lz ma hc mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hn ho hp hq hr"><h1 id="9158" class="ki kj hu bd kk kl mg kn ko kp mh kr ks kt mi kv kw kx mj kz la lb mk ld le lf dt translated">Python示例</h1><p id="8a26" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">动态的，解释的</p><pre class="jq jr js jt fq mq mo mr ms aw mt dt"><span id="693d" class="mu kj hu mo b fv mv mw l mx my">def foo(a):<br/>    if a &gt; 0:<br/>        print 'Hi'<br/>    else:<br/>        print "3" + 5</span><span id="a99e" class="mu kj hu mo b fv mz mw l mx my">foo(2)</span></pre><p id="6a6a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为Python是解释型和动态类型的，所以它只对正在执行的代码进行翻译和类型检查。<code class="eh ml mm mn mo b">else</code>块从不执行，所以<code class="eh ml mm mn mo b">"3" + 5</code>甚至从来没有被看过！</p><p id="85c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果它是静态类型的呢？</p><p id="3555" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">甚至在代码运行之前就会抛出类型错误。即使被解释，它仍然在运行前执行类型检查。</p><p id="1fe1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="mp">如果是编的呢？</em></p><p id="d8e5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ml mm mn mo b">else</code>块将在运行前被翻译/查看，但是因为它是动态类型的，所以它不会抛出错误！动态类型语言直到执行时才检查类型，而那一行从不执行。</p></div><div class="ab cl lz ma hc mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hn ho hp hq hr"><h1 id="1264" class="ki kj hu bd kk kl mg kn ko kp mh kr ks kt mi kv kw kx mj kz la lb mk ld le lf dt translated">Go示例</h1><p id="470e" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">静态的、编译的</p><pre class="jq jr js jt fq mq mo mr ms aw mt dt"><span id="bbdd" class="mu kj hu mo b fv mv mw l mx my">package main</span><span id="6b9a" class="mu kj hu mo b fv mz mw l mx my">import ("fmt"<br/>)</span><span id="c349" class="mu kj hu mo b fv mz mw l mx my">func foo(a int) {<br/>  if (a &gt; 0) {<br/>      fmt.Println("Hi")<br/>  } else {<br/>      fmt.Println("3" + 5)<br/>  }<br/>}</span><span id="9162" class="mu kj hu mo b fv mz mw l mx my">func main() {<br/>  foo(2)<br/>}</span></pre><p id="570a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在运行之前检查类型(静态的),并立即捕捉类型错误！如果类型被解释，在运行前仍然会被检查，结果是一样的。如果它是动态的，即使在编译期间会查看代码，它也不会抛出任何错误。</p></div><div class="ab cl lz ma hc mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hn ho hp hq hr"><h1 id="8dca" class="ki kj hu bd kk kl mg kn ko kp mh kr ks kt mi kv kw kx mj kz la lb mk ld le lf dt translated">表演</h1><p id="0368" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">如果编译的语言是静态类型的，那么它在运行时会有更好的性能，因为类型的知识允许机器代码优化。</p><p id="f9c5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">静态类型语言本质上在运行时具有更好的性能，因为在执行时不需要动态检查类型(它在运行前检查)。</p><p id="a137" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">类似地，编译语言在运行时更快，因为代码已经被翻译，而不需要动态地“解释”/翻译它。</p><p id="d278" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，编译语言和静态类型语言在分别运行翻译和类型检查之前都会有延迟。</p></div><div class="ab cl lz ma hc mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hn ho hp hq hr"><h1 id="d05b" class="ki kj hu bd kk kl mg kn ko kp mh kr ks kt mi kv kw kx mj kz la lb mk ld le lf dt translated">更多差异</h1><p id="cfd9" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">静态类型在早期捕获错误，而不是在执行过程中发现错误(对于长程序尤其有用)。它更“严格”，因为它不允许程序中的任何地方出现类型错误，并且经常阻止变量改变类型，这进一步防止了意外的错误。</p><pre class="jq jr js jt fq mq mo mr ms aw mt dt"><span id="9ba1" class="mu kj hu mo b fv mv mw l mx my">num = 2<br/>num = '3' // ERROR</span></pre><p id="436e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">动态类型更加灵活(有些人很欣赏这一点)，但是允许变量改变类型(有时会产生意外的错误)。</p></div><div class="ab cl lz ma hc mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hn ho hp hq hr"><p id="9464" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这让你明白了吗？请在评论中告诉我！</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="na jw l"/></div></figure></div></div>    
</body>
</html>