<html>
<head>
<title>I made a talking emoji using regular emojis and JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我用普通表情符号和JavaScript做了一个会说话的表情符号</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-i-made-a-talking-emoji-using-regular-emojis-and-javascript-fe20e62ba10?source=collection_archive---------4-----------------------#2017-12-18">https://medium.com/hackernoon/how-i-made-a-talking-emoji-using-regular-emojis-and-javascript-fe20e62ba10?source=collection_archive---------4-----------------------#2017-12-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/c4b2ef338b70cd538a2cfe672a66a0cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/0*7MYc3zjcC4QKsXi1."/></div></figure><p id="49a2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">今天，在我工作的时候，有人在一个聊天群里发了一个有趣的小脚本:<a class="ae jw" href="http://jsbin.com/nijohi/2/edit?js,output" rel="noopener ugc nofollow" target="_blank">http://jsbin.com/nijohi/edit?js,output</a>。最初的代码是由Martin Kleppe编写的——为他简短的实现向他致敬。</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="b6fa" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">代码很简单，但是效果很有趣。表情符号<a class="ae jw" href="https://hackernoon.com/tagged/emoji" rel="noopener ugc nofollow" target="_blank">看起来像是在说话。</a></p><p id="8e1e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们要看看代码做了什么。代码的第一部分<code class="eh kd ke kf kg b">[ ..."😮😀😁😐😑😬" ]</code>将表情符号串转换成一个数组。这样，我们可以从数组中选择单个元素。</p><p id="261a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">你可能想知道为什么我们把一个字符串转换成一个数组来从中选择一个字符。这是因为表情符号不是单个字符，通常是四个字节(实际上，表情符号看起来像这样:“\xF0\x9F\x98\x81”)。</p><p id="6e4d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">使用这种技术，可以让<a class="ae jw" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>引擎保留Unicode字符的结构，并以正确的方式拆分表情列表。</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="60e1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">正如你所看到的，我们有两种有效的方法来访问正确的表情符号，数组一要短得多，也更容易记住。</p><p id="083f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">数组方法的工作要感谢字符串对象的<a class="ae jw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/@@iterator" rel="noopener ugc nofollow" target="_blank">迭代器实现。不是像<code class="eh kd ke kf kg b">""[n]</code>一样遍历每个字节，而是在每个码位之间迭代(一个unicode字符就是一个码位)。</a></p><p id="46c5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">既然这个字符串是一组分离良好的表情符号，那么就有可能一个接一个地选择它们来获得一个有效的表情符号。使用<code class="eh kd ke kf kg b">[new Date%6]</code>依次选择表情符号。这段代码每毫秒返回一个不同的序列表情符号，<code class="eh kd ke kf kg b">%6</code>确保我们不会越界。</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="1531" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">最后，<code class="eh kd ke kf kg b">document.body.innerHTML = "&lt;h1&gt;" +</code>将表情符号设置为页面的唯一内容。</p><p id="0ac3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">但是，正如你所看到的，表情符号并没有变化得那么快，也不是每毫秒都在变化，但仍然是连续的。</p><p id="4a3a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这是因为</p><pre class="jx jy jz ka fq kh kg ki kj aw kk dt"><span id="9c1b" class="kl km hu kg b fv kn ko l kp kq">setInterval(_=&gt;{ },99)</span></pre><p id="49a9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">每99毫秒执行一次函数，通过每次99毫秒，我们使<code class="eh kd ke kf kg b">%6</code>每减少一个数字。</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="ea48" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">当我写这篇文章时，Martin写的代码仍然是最初的代码。<br/>在我发布之后，我注意到他修改了两次代码，以解决两个错误:</p><p id="099f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">第一个错误如<a class="ae jw" href="https://news.ycombinator.com/item?id=16009437" rel="noopener ugc nofollow" target="_blank"> didymospl </a>所指出的，<code class="eh kd ke kf kg b">99%6 === 3</code>。<br/>这意味着如果浏览器在正确的时间正确执行超时，只会显示2个表情符号，0和3。我将省去你的数学计算，如果<code class="eh kd ke kf kg b">x%y</code>是<code class="eh kd ke kf kg b">y</code>的任何除数(不包括1)的倍数，你将丢失一些数字。<br/>检查你选择的数字组合是否正确的一个快速方法是检查<code class="eh kd ke kf kg b">x</code>和<code class="eh kd ke kf kg b">y</code>的最大公约数是否为1 ( <code class="eh kd ke kf kg b">GCD(99,6) === 3, GCD(97,6) === 1</code>)。<br/>因此<a class="ae jw" href="http://jsbin.com/nijohi/3/edit?js,output" rel="noopener ugc nofollow" target="_blank"> Martin将超时时间更新为97 </a>这不是3或2的倍数。</p><p id="89f6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">即使进行了这种修正，代码在一些浏览器上仍然运行不正常，这是因为浏览器上的<em class="kr"> setTimeout </em>不可靠，如果浏览器忙于做任何事情，它将在另一个时刻执行setTimeout。为了使它在浏览器中更加一致，他选择使用<code class="eh kd ke kf kg b">~~(Math.random()*6)</code>而不是<code class="eh kd ke kf kg b">new Date()%6</code>来使它总是随机的。这是另一段有趣的代码，Math.random返回一个介于0和1之间的随机数(1除外)，所以如果你把它乘以6，它会返回一个介于0和6之间的数。唯一的问题是，这个数字是一个浮点数，我们不想访问位置1.2的表情符号，而是位置1的表情符号。为了使它成为整数，他使用了深奥的运算符<code class="eh kd ke kf kg b">~</code>，这个运算符是一个按位not，在数学术语中它返回<code class="eh kd ke kf kg b">(Math.floor(n) + 1) * -1</code>，通常这个运算符用于另一个技巧，<a class="ae jw" href="https://www.joezimjs.com/javascript/great-mystery-of-the-tilde/" rel="noopener ugc nofollow" target="_blank">检查一个数是否不是-1 </a>(对于indexOf非常有用)。但是在<a class="ae jw" href="https://en.wikipedia.org/wiki/Code_golf" rel="noopener ugc nofollow" target="_blank"> code golf </a>中它有另一个用途，将任何东西转换成整数，通过使用它两次，它只保留了<code class="eh kd ke kf kg b">Math.floor</code>的效果。</p><blockquote class="ks kt ku"><p id="6dec" class="iy iz kr ja b jb jc jd je jf jg jh ji kv jk jl jm kw jo jp jq kx js jt ju jv hn dt translated">如果你想在你的代码golf competition上节省11个字节，你可以用~</p></blockquote></div><div class="ab cl ky kz hc la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hn ho hp hq hr"><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="lf kc l"/></div></figure><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="567a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">先前的代码正在反转。我需要避免这种情况，所以我需要一个增加的数字。为了获得这个，我使用了<code class="eh kd ke kf kg b">Math.floor (new Date/delay)</code>。它不返回当前的毫秒数，而是返回当前的十分之一秒。</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="243c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">既然数字是递进的，我只需要把它限制在一个范围内。对于表情符号，我需要坚持表情符号的数量(6)，对于文本，我需要文本的长度+ 1(我使用+1来显示最新的字符，记住length%length == 0)。</p><p id="bbe2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">结果还不错:表情符号动了动嘴，下面出现了一条文字。但是嘴的运动是完全不相关的。我从出生开始就一直在看配音电影，那些配音很差的电影总是让我很恼火，所以我必须做点什么，让那个表情符号以更好的方式动画化。</p><p id="e6fb" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我搜索的第一个东西是一张图片，它展示了每个字母的各种嘴部动作。在谷歌搜索了五分钟后，我终于找到了正确的图片:</p><figure class="jx jy jz ka fq iv fe ff paragraph-image"><div class="fe ff lg"><img src="../Images/51a7942b4373b307552cc447ec2839f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/0*gwbWfYm-iQIPEXXP."/></div></figure><p id="bb49" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">是时候将不同的表情符号映射到每个字母上了。为此，我需要一个漂亮的页面，上面有我可能需要的所有表情符号:<a class="ae jw" href="https://emojipedia.org/apple/" rel="noopener ugc nofollow" target="_blank">https://emojipedia.org/apple/</a>。</p><p id="01f8" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在为图片中每个独特的嘴部动作选择一个之后，我开始创建地图:</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="bb65" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">非字母字符的默认表情符号( "，"！"、“、“… ) —现在我只需要修改代码来检索正确的表情符号。</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="lf kc l"/></div></figure><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="71e4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这部新法典分为两部分:</p><ol class=""><li id="80a9" class="lh li hu ja b jb jc jf jg jj lj jn lk jr ll jv lm ln lo lp dt translated">查找表情符号当前正在发音的字符:</li></ol><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="4db9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">代码很简单，因为我们使用了显示消息的相同代码逻辑，但是只选择了一个字符。主要的区别是<code class="eh kd ke kf kg b">message.toLowerCase()</code>，因为当我检查字符是否与我的表情地图中的字符匹配时，我需要它不区分大小写。</p><p id="eeeb" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">2.选择正确的表情符号:</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="bc1d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这段代码首先将表情地图转换成表情数组。这样，我就可以用表情符号作为键，一个一个地检查每个值。例如:</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="acec" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">find函数将逐个检查这些值，直到我为该值执行的函数返回true。在我们的例子中，我使用的函数是<code class="eh kd ke kf kg b">emoji =&gt; emojiMap[emoji].includes(character)</code>。这只是检查该表情符号的字符集是否包含我要搜索的字符。</p><p id="b627" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果find没有找到任何东西，它将返回<code class="eh kd ke kf kg b">undefined</code>，那是一个假值。通过使用<code class="eh kd ke kf kg b">|| defaultEmoji</code>，我可以让我的代码在find没有找到任何东西时返回<code class="eh kd ke kf kg b">defaultEmoji</code>。</p><p id="f32d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在功能正常，表情符号说话正确，但在手机上看起来很糟糕(在Android上)。我希望它甚至可以在移动设备上工作，所以我需要让代码返回一个在每个平台上都平等的表情符号。为此，我将使用<a class="ae jw" href="https://github.com/twitter/twemoji" rel="noopener ugc nofollow" target="_blank"> twemoji </a>。</p><p id="006a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Twemoji是Twitter的一个库，可以在任何地方使用他们的表情符号。这个库很容易使用，有一个名为parse的方法来解析一个文本字符串，并返回一个HTML字符串，其中每个表情符号都是一个图像。</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="lf kc l"/></div></figure><p id="4973" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这在目前来说是完美的，并且实现起来非常简单。我首先将脚本包含在页面中，并做了一点小小的改动，将我的表情符号转换成图像:</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="955a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">图像质量有点低。也许我们可以做点什么。查看文档时，我注意到我可以使用SVG。</p><p id="856d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们使用它们:</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="lf kc l"/></div></figure><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="59f0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">表情符号现在在手机上看起来很好，但文本太多了。为了解决这个问题，我把我要展示的文本分成几个单词，我只展示最后两个:</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="lf kc l"/></div></figure><p id="8d23" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">诀窍很简单。为了拆分单词，我使用了<code class="eh kd ke kf kg b">.split(' ')</code>，它将一个字符串分解成一个由空格分隔的字符串数组。</p><pre class="jx jy jz ka fq kh kg ki kj aw kk dt"><span id="1ed9" class="kl km hu kg b fv kn ko l kp kq">const words = message.substr(0, Math.floor(new Date / delay)%(message.length+1)).split(' ')</span></pre><p id="5ad7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">然后，我使用<code class="eh kd ke kf kg b">.pop()</code>获取表情符号正在说的当前单词</p><pre class="jx jy jz ka fq kh kg ki kj aw kk dt"><span id="1be4" class="kl km hu kg b fv kn ko l kp kq">const current = words.pop()</span></pre><p id="560b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我将所有内容添加到页面中，在最新的一个单词之前弹出这个单词。</p><pre class="jx jy jz ka fq kh kg ki kj aw kk dt"><span id="f35e" class="kl km hu kg b fv kn ko l kp kq">document.body.innerHTML = "&lt;h1&gt;" + ... + "&lt;/h1&gt;&lt;h3&gt;" + words.pop() + "&lt;/h3&gt;&lt;h2&gt;" + current</span></pre><p id="d02a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">最后，唯一剩下的小问题是，在带有嘴部位置的图像上，不仅有单个字符，还有组合字符，像<code class="eh kd ke kf kg b">sh</code>和<code class="eh kd ke kf kg b">th</code>。</p><p id="b8eb" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果剧本能抓住他们，那就太神奇了。</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="lf kc l"/></div></figure><p id="3d6d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了捕捉这两个字符组合，我不仅需要查看当前字符，还需要查看上一个和下一个字符。</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="1426" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我刚刚写的代码创建了三个变量:当前字符、当前字符和前一个字符、当前字符和下一个字符。</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="ec21" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们有了所有这三个变量，我们需要优先考虑几个字符。为此，我们首先在表情地图上搜索<code class="eh kd ke kf kg b">previousDouble</code>。如果我们什么也没找到，我们搜索<code class="eh kd ke kf kg b">nextDouble</code>，最后搜索当前的<code class="eh kd ke kf kg b">character</code>。</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="a920" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">最后，稍微修饰一下，会说话的表情符号就完成了！</p><p id="6bc6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">仍然有很大的改进空间，如果您想进一步扩展这个脚本，这里有几个想法:</p><ol class=""><li id="36a7" class="lh li hu ja b jb jc jf jg jj lj jn lk jr ll jv lm ln lo lp dt translated">使用<a class="ae jw" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Speech_API" rel="noopener ugc nofollow" target="_blank">网络语音API </a>让表情符号真正说话。这将有几个挑战，例如同步“嘴唇运动”与声音。</li><li id="d133" class="lh li hu ja b jb lq jf lr jj ls jn lt jr lu jv lm ln lo lp dt translated">使用<a class="ae jw" href="https://d3js.org/" rel="noopener ugc nofollow" target="_blank"> D3 </a>制作从一个表情符号到另一个表情符号的过渡动画，使其更加自然和真实。</li><li id="d12d" class="lh li hu ja b jb lq jf lr jj ls jn lt jr lu jv lm ln lo lp dt translated">停止使用表情符号，使用更有表现力的图片，也可以识别更多的双元音。这更容易，因为代码几乎不需要修改。</li></ol></div><div class="ab cl ky kz hc la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hn ho hp hq hr"><p id="8080" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这个故事最初发表在<a class="ae jw" href="https://www.codementor.io/mauriziocarboni/how-i-made-a-talking-emoji-using-regular-emojis-and-javascript-etmz7svtg" rel="noopener ugc nofollow" target="_blank">共同导师</a>上。</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="lv kc l"/></div></figure></div></div>    
</body>
</html>