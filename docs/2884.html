<html>
<head>
<title>The State of Go Dependency Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go依赖管理的状态</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-state-of-go-dependency-management-6cc5f82a4bfa?source=collection_archive---------2-----------------------#2017-02-26">https://medium.com/hackernoon/the-state-of-go-dependency-management-6cc5f82a4bfa?source=collection_archive---------2-----------------------#2017-02-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="b6b0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">自从Go在Google之外引起了极大的关注，依赖管理就成了一个热门话题。</p><p id="4619" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最初，除了<code class="eh jq jr js jt b">go get</code>之外没有依赖<a class="ae jp" href="https://hackernoon.com/tagged/management" rel="noopener ugc nofollow" target="_blank">管理</a>，它将源文件从<code class="eh jq jr js jt b">origin/master</code>加载到您的系统级<code class="eh jq jr js jt b"><a class="ae jp" href="https://github.com/golang/go/wiki/GOPATH" rel="noopener ugc nofollow" target="_blank">$GOPATH</a></code>。对于内部依赖，这通常是可行的，因为每个人都应该使用最新的版本。然而，对于依赖第三方的团队来说，这是不可接受的，因为存在不匹配、冲突、突破性的变更，因此出现了许多<em class="ju">特别的</em>方法，例如</p><ul class=""><li id="4c6f" class="jv jw hu it b iu iv iy iz jc jx jg jy jk jz jo ka kb kc kd dt translated">提交特定于项目的$GOPATH</li><li id="1ffe" class="jv jw hu it b iu ke iy kf jc kg jg kh jk ki jo ka kb kc kd dt translated">git <a class="ae jp" href="https://git-scm.com/book/en/v2/Git-Tools-Submodules" rel="noopener ugc nofollow" target="_blank">子模块</a> ( <a class="ae jp" href="https://github.com/ingydotnet/git-subrepo" rel="noopener ugc nofollow" target="_blank">和</a> <a class="ae jp" href="https://git-scm.com/book/en/v1/Git-Tools-Subtree-Merging" rel="noopener ugc nofollow" target="_blank">变体</a>)</li><li id="8f06" class="jv jw hu it b iu ke iy kf jc kg jg kh jk ki jo ka kb kc kd dt translated">在特定项目的<code class="eh jq jr js jt b">$GOPATH</code>之间自动切换的工具，如<code class="eh jq jr js jt b"><a class="ae jp" href="https://github.com/moovweb/gvm" rel="noopener ugc nofollow" target="_blank">gvm</a></code>和<code class="eh jq jr js jt b"><a class="ae jp" href="https://github.com/constabulary/gb" rel="noopener ugc nofollow" target="_blank">gb</a></code></li></ul><p id="e7d0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最终，人们意识到我们需要一些更好的东西…一些一致的、实际上跟踪代码提交的实际版本(提交sha、标签)的东西…一些简单的东西。为了“解决”这种需求，最流行的解决方案——<code class="eh jq jr js jt b"><a class="ae jp" href="https://github.com/tools/godep" rel="noopener ugc nofollow" target="_blank">godep</a></code>——上升到了流行。Godep允许你“轻松地”</p><ul class=""><li id="13e7" class="jv jw hu it b iu iv iy iz jc jx jg jy jk jz jo ka kb kc kd dt translated">将<code class="eh jq jr js jt b">$GOPATH</code>中的依赖项固定到项目中</li><li id="b703" class="jv jw hu it b iu ke iy kf jc kg jg kh jk ki jo ka kb kc kd dt translated">将依赖项从项目复制到您的$GOPATH</li><li id="0755" class="jv jw hu it b iu ke iy kf jc kg jg kh jk ki jo ka kb kc kd dt translated">浏览通过Godeps.json固定的依赖项</li></ul><p id="9a6f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尽管Godep是对现有方法的巨大改进，但它肯定不能解决所有问题。它有许多问题。</p><p id="26e7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，Godep有许多让用户感到沮丧的缺陷、怪癖和矛盾之处。许多人认为这扼杀了这个项目。我不同意。</p><p id="66aa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些“怪癖”大多是因为Godep还是围绕<code class="eh jq jr js jt b">$GOPATH</code>转。要更新项目的依赖关系，您必须通过<code class="eh jq jr js jt b">go get -u github.com/some/dep</code>在您的<code class="eh jq jr js jt b">$GOPATH</code>中更新它，然后，通过<code class="eh jq jr js jt b">godep save github.com/some/dep</code>将它从您的<code class="eh jq jr js jt b">$GOPATH</code>复制到您项目的<code class="eh jq jr js jt b">Godeps/</code>。由于大多数开发人员在<code class="eh jq jr js jt b">$GOPATH</code>之外工作，当你在<code class="eh jq jr js jt b">$GOPATH</code>中修改一个依赖项时，这是很烦人的。此外，由于大多数开发人员只有一个<code class="eh jq jr js jt b">$GOPATH</code>，同时使用不同版本的依赖项来更新多个项目的依赖项是压倒性的。</p><p id="9037" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">到Go 1.5(2015年年中)，已经有了很多不同的做法，但没有标准。所以Go团队意识到是时候通过起草“<a class="ae jp" href="https://docs.google.com/document/d/1Bz5-UB7g2uPBdOx-rw5t9MxJwkfpx90cqG9AFL0JAYo/edit" rel="noopener ugc nofollow" target="_blank">供应商实验</a>”来介入了。启用实验后，Go的<code class="eh jq jr js jt b">import</code>更喜欢<code class="eh jq jr js jt b">vendor</code>文件夹而不是<code class="eh jq jr js jt b">$GOPATH/src</code>。在Go 1.6中，默认情况下启用供应商实验。立刻，许多工具爆炸了，例如</p><ul class=""><li id="6347" class="jv jw hu it b iu iv iy iz jc jx jg jy jk jz jo ka kb kc kd dt translated">glide ，一个固执己见的、笨重的、现代的包管理系统…非常类似于ruby的gems</li><li id="7905" class="jv jw hu it b iu ke iy kf jc kg jg kh jk ki jo ka kb kc kd dt translated">govendor ，一个快乐的中间人……我个人的最爱，尽管它可能有奇怪的命名/语法约定</li><li id="b14b" class="jv jw hu it b iu ke iy kf jc kg jg kh jk ki jo ka kb kc kd dt translated">gvt ，一个简单的售货工具……卖主的神坛</li><li id="ebd7" class="jv jw hu it b iu ke iy kf jc kg jg kh jk ki jo ka kb kc kd dt translated">……还有<a class="ae jp" href="https://github.com/govend/govend" rel="noopener ugc nofollow" target="_blank">多</a>，<a class="ae jp" href="https://github.com/skelterjohn/wgo" rel="noopener ugc nofollow" target="_blank">多</a>多<a class="ae jp" href="https://github.com/dpw/vendetta" rel="noopener ugc nofollow" target="_blank">多</a></li></ul><p id="b2cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不要破坏将这样的东西集成到核心工具链中所需要的东西，但是除了4页的提议和宣传之外，“供应商”没有引入太多已经不存在的东西。<code class="eh jq jr js jt b">godep build</code>已经做了它提议的一切，甚至更多。</p><blockquote class="kj kk kl"><p id="bf2b" class="ir is ju it b iu iv iw ix iy iz ja jb km jd je jf kn jh ji jj ko jl jm jn jo hn dt translated">请注意，当“go get”获取一个新的依赖项时，它不会将它放在供应商目录中。一般来说，<strong class="it hv">将代码移入或移出供应商目录是供应商工具的工作，而不是go命令。</strong> <br/> <em class="hu"> —来自</em> <a class="ae jp" href="https://docs.google.com/document/d/1Bz5-UB7g2uPBdOx-rw5t9MxJwkfpx90cqG9AFL0JAYo/edit" rel="noopener ugc nofollow" target="_blank"> <em class="hu"> Go 1.5厂商实验</em> </a> <em class="hu">建议</em></p></blockquote><p id="1192" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">事实上，供应商甚至没有提供一个工具来管理依赖关系，或者将它们放在第一位。然而，它所做的是为社区提供一个标准，告诉他们应该如何以及在哪里管理依赖关系。而且，很明显，这通常足以让软件社区开始运转。</p><p id="07f3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">围棋中的复仇是<a class="ae jp" href="https://github.com/kardianos/govendor/issues" rel="noopener ugc nofollow" target="_blank">还是</a> <a class="ae jp" href="https://github.com/mattfarina/golang-broken-vendor" rel="noopener ugc nofollow" target="_blank">非常</a> <a class="ae jp" href="https://github.com/golang/go/issues?utf8=%E2%9C%93&amp;q=is%3Aissue%20is%3Aopen%20vendor" rel="noopener ugc nofollow" target="_blank">破</a>。幸运的是，Go团队正在开发一种新工具——<code class="eh jq jr js jt b"><a class="ae jp" href="https://github.com/golang/dep" rel="noopener ugc nofollow" target="_blank">dep</a></code>——这应该会大大改善这种情况。到目前为止，我遇到的所有关于Go依赖的问题都在他们的<a class="ae jp" href="https://docs.google.com/document/d/1JNP6DgSK-c6KqveIhQk-n_HAw3hsZkL-okoleM43NgA/edit#" rel="noopener ugc nofollow" target="_blank">特性</a>和<a class="ae jp" href="https://docs.google.com/document/d/1wT8e8wBHMrSRHY4UF_60GCgyWGqvYye4THvaDARPySs/edit#heading=h.50hvk96hc71m" rel="noopener ugc nofollow" target="_blank">用户故事</a>文档中解决了。当然，不能保证这些特性会在最初的版本中得到解决，但是很高兴知道团队认识到并有兴趣解决它们。从支持分叉到可传递依赖，到同一依赖的多个版本，再到支持私有代理，我真的为<code class="eh jq jr js jt b">dep</code>感到兴奋。</p><p id="7c0f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">围棋是为了简单。简单是为了生产力。不必对抗依赖性将是一个巨大的优势！🎉</p><blockquote class="kj kk kl"><p id="cb78" class="ir is ju it b iu iv iw ix iy iz ja jb km jd je jf kn jh ji jj ko jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is ju it b iu iv iw ix iy iz ja jb km jd je jf kn jh ji jj ko jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is ju it b iu iv iw ix iy iz ja jb km jd je jf kn jh ji jj ko jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kp kq kr ks fq kt"><div class="bz el l di"><div class="ku kv l"/></div></figure></div></div>    
</body>
</html>