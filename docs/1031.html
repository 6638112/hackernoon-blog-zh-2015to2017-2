<html>
<head>
<title>Generalized type constraints</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">广义类型约束</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/generalized-type-constraints-b256e79dd266?source=collection_archive---------0-----------------------#2016-08-20">https://medium.com/hackernoon/generalized-type-constraints-b256e79dd266?source=collection_archive---------0-----------------------#2016-08-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="efe4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这篇短文中，我将展示Scala中的通用类型约束——它们是什么，为什么我们需要它们，以及它们是如何使用的。</p><p id="0858" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，让我向您展示两个Scala难题。</p><h2 id="8cb8" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">第一个难题:</h2><pre class="kk kl km kn fq ko kp kq kr aw ks dt"><span id="9a4e" class="jp jq hu kp b fv kt ku l kv kw">def pair[S](s1: S, s2: S): (S, S) = (s1, s2)</span></pre><p id="7a85" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们向这个方法传递两个不同类型的值，你认为会发生什么？让我们看看:</p><pre class="kk kl km kn fq ko kp kq kr aw ks dt"><span id="8782" class="jp jq hu kp b fv kt ku l kv kw">scala&gt; pair(“foo”, 1)<br/>res0: (Any, Any) = (foo,1)</span></pre><p id="7e20" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">发生了什么，编译器说“好的，第一个值是一个字符串，第二个值是一个Int，但这实际上是行不通的，因为我需要这两个参数是相同的类型。我现在将尝试找到它们最近的公共超类型。给你——随便什么都行。酷，这些参数中的每一个也都是Any，所以我将它们视为Any类型，以满足类型约束。</p><p id="a4fa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">顺便说一下，如果我们有一个S型的界限，例如:</p><pre class="kk kl km kn fq ko kp kq kr aw ks dt"><span id="f4a3" class="jp jq hu kp b fv kt ku l kv kw">def pairVals[S &lt;: AnyVal](s1: S, s2: S) = (s1, s2)</span></pre><p id="342e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后用String和Int调用该方法会给我们一个编译错误，因为其中一个参数不是AnyVal的子类型(记住String是AnyRef的子类型，而不是AnyVal)。编译器说“你给我的参数的最接近的公共超类型是Any，但是这违反了给定的类型约束”:</p><pre class="kk kl km kn fq ko kp kq kr aw ks dt"><span id="3c3c" class="jp jq hu kp b fv kt ku l kv kw">scala&gt; pairVals(“foo”, 4)<br/>&lt;console&gt;:12: error: inferred type arguments [Any] do not conform to method pairVals’s type parameter bounds [S &lt;: AnyVal]</span></pre><p id="920a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">返回到pair()方法。这里有一个问题——如果我们想说“方法对()应该接受两个<strong class="it hv">相同类型</strong>的参数”呢？我们看到pair()很容易允许我们传入一个String和一个Int编译器将简单地推断出您传递了Any类型的值。如果我们希望只允许两个参数共享完全相同的类型(例如，两个Int或两个String，但不是一个Int和一个String)的调用，该怎么办？</p><p id="8c01" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我回答这个问题之前，还有一个难题:</p><h2 id="cc3f" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">第二个难题:</h2><pre class="kk kl km kn fq ko kp kq kr aw ks dt"><span id="3a45" class="jp jq hu kp b fv kt ku l kv kw">def advPair[S &lt;: T, T](s: S, t: T): (S, T) = (s, t)</span></pre><p id="aae9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是在稍微不同的情况下的相同原理。当我们用两个不同的参数调用这个方法时，你认为会发生什么？</p><pre class="kk kl km kn fq ko kp kq kr aw ks dt"><span id="2ca8" class="jp jq hu kp b fv kt ku l kv kw">scala&gt; advPair(“foo”, 1)<br/>res0: (String, Any) = (foo,1)</span></pre><p id="1757" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">乍一看，您可能会认为advPair()有两个参数，第一个是second的子类型，因此用String和Int调用它会失败(因为String不是Int的子类型)。同样，你也错了。就像在第一种情况下，编译器将试图解决混乱，看看它是否可以通过向上转换您的值来满足类型约束。<em class="kx">(顺便说一句，不要介意我使用“向上投射”这个术语——我知道这听起来有点丑陋，但你我都知道没有什么丑陋的事情发生。Int *是* an，就像Scala中的其他东西一样)。</em></p><p id="e4a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以是的，我们传入了一个字符串和一个Int，但是Int也是一个Any。当我们从这个角度看问题时，一切都解决了——我们传递了一个字符串和一个Any，并且满足了第一个参数是第二个参数的子类型的条件。</p><p id="f70e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么，我们怎样才能在“原始”类型上设置约束，而不使编译器试图变得慷慨并向上传递我们的参数，直到类型约束得到满足？</p><h2 id="2281" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">答案:</h2><p id="12ae" class="pw-post-body-paragraph ir is hu it b iu ky iw ix iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo hn dt translated">通过使用<em class="kx">广义类型约束</em>。</p><p id="6b88" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第一个谜题解决了:</p><pre class="kk kl km kn fq ko kp kq kr aw ks dt"><span id="6175" class="jp jq hu kp b fv kt ku l kv kw">def pair[S, T](s: S, t: T)<strong class="kp hv">(implicit ev: S =:= T)</strong>: (S, T) = (s, t)</span></pre><p id="f387" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第二个谜题解决了:</p><pre class="kk kl km kn fq ko kp kq kr aw ks dt"><span id="a212" class="jp jq hu kp b fv kt ku l kv kw">def advPair[S, T](s: S, t: T)<strong class="kp hv">(implicit ev: S &lt;:&lt; T)</strong>:(S, T) = (s, t)</span></pre><p id="53de" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">看到那些隐式参数了吗？他们是我们困境的解决方案。你可以把它们看作类型:语句S =:= T与Map[S，T]具有相同的性质。只是广义类型约束(“GTC”)是内嵌的，而不是前缀的。</p><p id="3718" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么当你有一个GTC时会发生什么呢？好吧，编译器会施展它的推理魔法，就好像GTC不存在一样。一旦一切都解决了，它将检查GTC是否满意。看看在pair()例子中我们如何不再有两个S类型的实参，而是不同类型的实参，返回类型也从(S，S)变成了(S，T)？这样，编译器不需要做任何向上转换的魔术——它只是将给定的参数配对成一个元组。但是，在处理方法体之前，它将检查GTC是否满意；也就是说，类型S和T实际上是否是同一类型。</p><pre class="kk kl km kn fq ko kp kq kr aw ks dt"><span id="89f7" class="jp jq hu kp b fv kt ku l kv kw">scala&gt; pair(“foo”, 1)<br/>&lt;console&gt;:12: error: Cannot prove that String =:= Int.<br/> pair(“w”, 1)<br/> ^</span><span id="0912" class="jp jq hu kp b fv ld ku l kv kw">scala&gt; pair(“foo”, “foo”)<br/>res0: (String, String) = (w,a)</span></pre><p id="f6aa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第二个方法也经历了类型约束方面的一些变化——我们删除了[S <: t="" part.="" why="" again="" to="" prevent="" the="" compiler="" from="" doing="" any="" upcasting="" magic.="" we="" saw="" how="" having="" caused="" upcast="" int="" into="" in="" order="" conform="" type="" constraint="" right="" well="" now="" will="" happily="" realize="" that="" there="" are="" no="" constraints="" which="" means="" s="" and="" can="" be="" string="" without="" problems="" so="" it="" proclaim="" its="" final="" decision:="" is="" int.="" but="" then="" gtc="" kicks="" tells="" you="" resolved="" concrete="" types="" here="" my="" demands="" if="" not="" a="" subtype="" of="" invocation="" fail.=""/></p><pre class="kk kl km kn fq ko kp kq kr aw ks dt"><span id="26e9" class="jp jq hu kp b fv kt ku l kv kw">scala&gt; advPair(“foo”, 1)<br/>&lt;console&gt;:12: error: Cannot prove that String &lt;:&lt; Int.<br/> advPair(“foo”, 1)<br/> ^</span><span id="f334" class="jp jq hu kp b fv ld ku l kv kw">scala&gt; val any: Any = "any"<br/>any: Any = any</span><span id="5d57" class="jp jq hu kp b fv ld ku l kv kw">scala&gt; advPair("foo", any)<br/>res0: (String, Any) = (foo,any)</span></pre><h2 id="7e4b" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">Conclusion</h2><p id="b92f" class="pw-post-body-paragraph ir is hu it b iu ky iw ix iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo hn dt translated">So here’s the summary:</p><p id="fb25" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Compiler will try to conform to type bounds by upcasting the types as needed, trying desperately to find a combination that works. If the process fails, compiler will cry. If it succeeds, compiler will assign each generic type parameter a concrete type (e.g. S and T will become String and Int).</p><p id="5d98" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Then, when the types are resolved, compiler will see that an implicit GTC is needed and it will provide it. Note that when you are writing a method that needs the GTC, you just need to declare it as an implicit parameter and that’s it. Compiler will provide the needed GTC at compile time and plug in the resolved types, issuing an error message in case GTC is not satisfied.</p><p id="318c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Fun with types never ends in Scala. :) As usual, contact me on sinisalouc@gmail.com with feedback or <a class="ae le" href="https://twitter.com/sinisalouc" rel="noopener ugc nofollow" target="_blank">在Twitter上找到我。</a></p><blockquote class="lf lg lh"><p id="8fd9" class="ir is kx it b iu iv iw ix iy iz ja jb li jd je jf lj jh ji jj lk jl jm jn jo hn dt translated"><a class="ae le" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae le" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae le" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae le" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is kx it b iu iv iw ix iy iz ja jb li jd je jf lj jh ji jj lk jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae le" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae le" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae le" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is kx it b iu iv iw ix iy iz ja jb li jd je jf lj jh ji jj lk jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae le" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae le" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>