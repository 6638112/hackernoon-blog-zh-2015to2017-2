<html>
<head>
<title>Higher-Order Components (HOCs) for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高阶元件(hoc ),适合初学者</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/higher-order-components-hocs-for-beginners-25cdcf1f1713?source=collection_archive---------4-----------------------#2017-07-17">https://medium.com/hackernoon/higher-order-components-hocs-for-beginners-25cdcf1f1713?source=collection_archive---------4-----------------------#2017-07-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/c7e6044ea8e07fd69562e529b2e262c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*BV2jDav85N4CDE-ZjgFzZw.jpeg"/></div></figure><h1 id="a913" class="iy iz hu bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">前言</h1><blockquote class="jw jx jy"><p id="71f6" class="jz ka kb kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">注:这是最初发布在我的<a class="ae ky" href="https://btnwtn.com/articles/higher-order-components-for-beginners" rel="noopener ugc nofollow" target="_blank">个人网站</a>上的。</p></blockquote><p id="1028" class="pw-post-body-paragraph jz ka hu kc b kd ke kf kg kh ki kj kk kz km kn ko la kq kr ks lb ku kv kw kx hn dt translated">我写这篇文章是因为其他每篇文章——包括关于高阶组件的React官方文档——都让我这个初学者感到困惑。我明白高阶组件是一个东西，但不明白它们如何有用。本文旨在澄清一些关于高阶元件的困惑。</p><p id="7d5e" class="pw-post-body-paragraph jz ka hu kc b kd ke kf kg kh ki kj kk kz km kn ko la kq kr ks lb ku kv kw kx hn dt translated">在我们理解HOCs之前，我们必须先了解一些关于Javascript中函数的事情。</p><h1 id="f21e" class="iy iz hu bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">ES6箭头功能简介</h1><p id="a855" class="pw-post-body-paragraph jz ka hu kc b kd lc kf kg kh ld kj kk kz le kn ko la lf kr ks lb lg kv kw kx hn dt translated">本文将提供仅使用ES6箭头函数的例子。如果你以前从未见过箭头函数，它们本质上等同于正则函数表达式。下面的代码展示了常规函数和箭头函数之间的区别。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="e31a" class="lq iz hu lm b fv lr ls l lt lu">function () {<br/>  return 42<br/>}</span><span id="a965" class="lq iz hu lm b fv lv ls l lt lu">// same as:<br/>() =&gt; 42</span><span id="38e3" class="lq iz hu lm b fv lv ls l lt lu">// same as:<br/>() =&gt; {<br/>  return 42<br/>}</span><span id="fe95" class="lq iz hu lm b fv lv ls l lt lu">function person(name) {<br/>  return { name: name }<br/>}</span><span id="9f67" class="lq iz hu lm b fv lv ls l lt lu">// same as:<br/>(name) =&gt; {<br/>  return { name: name }<br/>}</span></pre><p id="47ea" class="pw-post-body-paragraph jz ka hu kc b kd ke kf kg kh ki kj kk kz km kn ko la kq kr ks lb ku kv kw kx hn dt translated">阅读MDN 上的<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener ugc nofollow" target="_blank">箭头功能文档以获得更完整的理解。</a></p><h1 id="265a" class="iy iz hu bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">作为价值和部分应用的功能</h1><p id="e50e" class="pw-post-body-paragraph jz ka hu kc b kd lc kf kg kh ld kj kk kz le kn ko la lf kr ks lb lg kv kw kx hn dt translated">就像数字，字符串，布尔等。，<em class="kb">函数是值</em>。这意味着您可以像传递其他数据一样传递函数。您可以将函数作为参数传递给另一个函数:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="bb96" class="lq iz hu lm b fv lr ls l lt lu">const execute = (someFunction) =&gt; someFunction()</span><span id="283a" class="lq iz hu lm b fv lv ls l lt lu">execute(() =&gt; alert('Executed'))</span></pre><p id="96c5" class="pw-post-body-paragraph jz ka hu kc b kd ke kf kg kh ki kj kk kz km kn ko la kq kr ks lb ku kv kw kx hn dt translated">你可以从一个函数返回一个函数。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="a711" class="lq iz hu lm b fv lr ls l lt lu">const getOne = () =&gt; () =&gt; 1</span><span id="9257" class="lq iz hu lm b fv lv ls l lt lu">getOne()()</span></pre><p id="535a" class="pw-post-body-paragraph jz ka hu kc b kd ke kf kg kh ki kj kk kz km kn ko la kq kr ks lb ku kv kw kx hn dt translated">我们在<code class="eh lw lx ly lm b">getOne</code>后面有两个<code class="eh lw lx ly lm b">()</code>的原因是函数的第一个应用返回另一个。举例说明:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="9f1f" class="lq iz hu lm b fv lr ls l lt lu">const getOne = () =&gt; () =&gt; 1</span><span id="d7a1" class="lq iz hu lm b fv lv ls l lt lu">getOne<br/>//=&gt; () =&gt; () =&gt; 1</span><span id="87f6" class="lq iz hu lm b fv lv ls l lt lu">getOne()<br/>//=&gt; () =&gt; 1</span><span id="2dca" class="lq iz hu lm b fv lv ls l lt lu">getOne()()<br/>//=&gt; 1</span></pre><p id="6422" class="pw-post-body-paragraph jz ka hu kc b kd ke kf kg kh ki kj kk kz km kn ko la kq kr ks lb ku kv kw kx hn dt translated">从函数返回函数的好处是，我们可以编写跟踪初始输入的函数。例如，下面的函数接受一个数字作为参数，并返回一个将该参数乘以一个新参数的函数:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="0d33" class="lq iz hu lm b fv lr ls l lt lu">const multiply = (x) =&gt; (y) =&gt; x * y</span><span id="51e0" class="lq iz hu lm b fv lv ls l lt lu">multiply(5)(20)</span></pre><p id="f700" class="pw-post-body-paragraph jz ka hu kc b kd ke kf kg kh ki kj kk kz km kn ko la kq kr ks lb ku kv kw kx hn dt translated">这个例子和<code class="eh lw lx ly lm b">getOne</code>的工作原理一样，每个括号向函数应用一些输入。在这种情况下，我们将<code class="eh lw lx ly lm b">x</code>分配给<code class="eh lw lx ly lm b">5</code>，将<code class="eh lw lx ly lm b">y</code>分配给<code class="eh lw lx ly lm b">20</code>。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="7086" class="lq iz hu lm b fv lr ls l lt lu">const multiply = (x) =&gt; (y) =&gt; x * y</span><span id="cac4" class="lq iz hu lm b fv lv ls l lt lu">multiply<br/>//=&gt; (x) =&gt; (y) =&gt; x * y</span><span id="f153" class="lq iz hu lm b fv lv ls l lt lu">multiply(5)<br/>//=&gt; (y) =&gt; 5 * y</span><span id="800e" class="lq iz hu lm b fv lv ls l lt lu">multiply(5)(20)<br/>//=&gt; 5 * 20</span></pre><p id="5989" class="pw-post-body-paragraph jz ka hu kc b kd ke kf kg kh ki kj kk kz km kn ko la kq kr ks lb ku kv kw kx hn dt translated">当我们调用只有一个参数的函数<code class="eh lw lx ly lm b">multiply</code>时，我们部分地应用了这个函数。当我们调用<code class="eh lw lx ly lm b">multiply(5)</code>时，我们得到一个将它的输入乘以5的函数。如果我们调用<code class="eh lw lx ly lm b">multiply(7)</code>，我们会得到一个将输入乘以7的函数，依此类推。我们可以使用部分应用程序创建具有预定义输入的新功能:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="b923" class="lq iz hu lm b fv lr ls l lt lu">const multiply = (x) =&gt; (y) =&gt; x * y</span><span id="8aec" class="lq iz hu lm b fv lv ls l lt lu">const multiplyByFive = multiply(5)<br/>const multiplyBy100 = multiply(100)</span><span id="b78f" class="lq iz hu lm b fv lv ls l lt lu">multiplyByFive(20)<br/>//=&gt; 100<br/>multiply(5)(20)<br/>//=&gt; 100</span><span id="0450" class="lq iz hu lm b fv lv ls l lt lu">multiplyBy100(5)<br/>//=&gt; 500<br/>multiply(100)(5)<br/>//=&gt; 500</span></pre><p id="7db5" class="pw-post-body-paragraph jz ka hu kc b kd ke kf kg kh ki kj kk kz km kn ko la kq kr ks lb ku kv kw kx hn dt translated">这可能一开始看起来不是超级有用。但是，您可以使用分部应用程序来编写更易于阅读和推理的代码。例如，我们可以用更简洁的东西来代替<code class="eh lw lx ly lm b"><a class="ae ky" href="https://www.styled-components.com/docs/basics#adapting-based-on-props" rel="noopener ugc nofollow" target="_blank">styled-components</a></code>复杂的函数插值语法。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="d7a4" class="lq iz hu lm b fv lr ls l lt lu">// before<br/>const Button = styled.button`<br/>  background-color: ${({ theme }) =&gt; theme.bgColor}<br/>  color: ${({ theme }) =&gt; theme.textColor}<br/>`</span><span id="4483" class="lq iz hu lm b fv lv ls l lt lu">&lt;Button theme={themes.primary}&gt;Submit&lt;/Button&gt;</span><span id="b963" class="lq iz hu lm b fv lv ls l lt lu">// after<br/>const fromTheme = (prop) =&gt; ({ theme }) =&gt; theme[prop]</span><span id="b4e1" class="lq iz hu lm b fv lv ls l lt lu">const Button = styled.button`<br/>  background-color: ${fromTheme("bgColor")}<br/>  color: ${fromTheme("textColor")}<br/>`</span><span id="df1a" class="lq iz hu lm b fv lv ls l lt lu">&lt;Button theme={themes.primary}&gt;Submit&lt;/Button&gt;</span></pre><p id="5ba8" class="pw-post-body-paragraph jz ka hu kc b kd ke kf kg kh ki kj kk kz km kn ko la kq kr ks lb ku kv kw kx hn dt translated">我们创建一个接受字符串作为参数的函数:<code class="eh lw lx ly lm b">fromTheme("textColor")</code>，它返回一个接受带有<code class="eh lw lx ly lm b">theme</code>属性的对象的函数:<code class="eh lw lx ly lm b">({ theme }) =&gt; theme[prop]</code>，然后我们试图通过传入<code class="eh lw lx ly lm b">"textColor"</code>的初始字符串来查找该对象。我们可以更进一步，编写类似于<code class="eh lw lx ly lm b">backgroundColor</code>和<code class="eh lw lx ly lm b">textColor</code>的函数，它们部分应用了<code class="eh lw lx ly lm b">fromTheme</code>函数:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="c0e8" class="lq iz hu lm b fv lr ls l lt lu">const fromTheme = (prop) =&gt; ({ theme }) =&gt; theme[prop]<br/>const backgroundColor = fromTheme("bgColor")<br/>const textColor = fromTheme("textColor")</span><span id="9ec0" class="lq iz hu lm b fv lv ls l lt lu">const Button = styled.button`<br/>  background-color: ${backgroundColor}<br/>  color: ${textColor}<br/>`</span></pre><h1 id="9421" class="iy iz hu bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">高阶函数</h1><p id="32ac" class="pw-post-body-paragraph jz ka hu kc b kd lc kf kg kh ld kj kk kz le kn ko la lf kr ks lb lg kv kw kx hn dt translated">高阶函数被定义为接受一个函数作为自变量的函数。如果您曾经使用过像<code class="eh lw lx ly lm b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">map</a></code>这样的函数，您可能已经熟悉高阶函数。如果你不熟悉<code class="eh lw lx ly lm b">map</code>，它是一个循环函数，将函数应用于数组中的每个元素。例如，您可以对一组数字求平方，如下所示:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="d2d6" class="lq iz hu lm b fv lr ls l lt lu">const square = (x) =&gt; x * x</span><span id="4966" class="lq iz hu lm b fv lv ls l lt lu">[1, 2, 3].map(square)<br/>//=&gt; [ 1, 4, 9 ]</span></pre><p id="bfe8" class="pw-post-body-paragraph jz ka hu kc b kd ke kf kg kh ki kj kk kz km kn ko la kq kr ks lb ku kv kw kx hn dt translated">我们可以编写自己版本的<code class="eh lw lx ly lm b">map</code>来说明这个概念:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="42f0" class="lq iz hu lm b fv lr ls l lt lu">const map = (fn, array) =&gt; {<br/>  const mappedArray = []</span><span id="8013" class="lq iz hu lm b fv lv ls l lt lu">  for (let i = 0; i &lt; array.length; i++) {<br/>    mappedArray.push(<br/>      // apply fn with the current element of the array<br/>      fn(array[i])<br/>    )<br/>  }</span><span id="4783" class="lq iz hu lm b fv lv ls l lt lu">  return mappedArray<br/>}</span></pre><p id="3007" class="pw-post-body-paragraph jz ka hu kc b kd ke kf kg kh ki kj kk kz km kn ko la kq kr ks lb ku kv kw kx hn dt translated">然后，我们可以使用我们的<code class="eh lw lx ly lm b">map</code>来做一些事情，比如对一个数字数组求平方:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="93d7" class="lq iz hu lm b fv lr ls l lt lu">const square = (x) =&gt; x * x</span><span id="7198" class="lq iz hu lm b fv lv ls l lt lu">console.log(map(square, [1, 2, 3, 4, 5]))<br/>//=&gt; [ 1, 4, 9, 16, 25 ]</span></pre><p id="f1d1" class="pw-post-body-paragraph jz ka hu kc b kd ke kf kg kh ki kj kk kz km kn ko la kq kr ks lb ku kv kw kx hn dt translated">或者返回一个数组<code class="eh lw lx ly lm b">&lt;li&gt;</code> React元素:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="4286" class="lq iz hu lm b fv lr ls l lt lu">const HeroList = ({ heroes }) =&gt; (<br/>  &lt;ul&gt;<br/>    {map((hero) =&gt; (<br/>      &lt;li key={hero}&gt;{hero}&lt;/li&gt;<br/>    ), heroes)}<br/>  &lt;/ul&gt;<br/>)</span><span id="b0cc" class="lq iz hu lm b fv lv ls l lt lu">&lt;HeroList heroes=[<br/>  "Wonder Woman",<br/>  "Black Widow",<br/>  "Spider Man",<br/>  "Storm",<br/>  "Deadpool"<br/>]/&gt;<br/>/*=&gt; (<br/>  &lt;ul&gt;<br/>    &lt;li&gt;Wonder Woman&lt;/li&gt;<br/>    &lt;li&gt;Black Widow&lt;/li&gt;<br/>    &lt;li&gt;Spider Man&lt;/li&gt;<br/>    &lt;li&gt;Storm&lt;/li&gt;<br/>    &lt;li&gt;Deadpool&lt;/li&gt;<br/>  &lt;/ul&gt;<br/>)*/</span></pre><h1 id="dad9" class="iy iz hu bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">高阶组件</h1><p id="0036" class="pw-post-body-paragraph jz ka hu kc b kd lc kf kg kh ld kj kk kz le kn ko la lf kr ks lb lg kv kw kx hn dt translated">我们知道高阶函数是接受一个函数作为自变量的函数。在React中，任何返回<code class="eh lw lx ly lm b"><a class="ae ky" href="https://facebook.github.io/react/docs/jsx-in-depth.html" rel="noopener ugc nofollow" target="_blank">JSX</a></code>的函数都被称为无状态功能组件，或简称为功能组件。一个基本的功能组件如下所示:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="39ea" class="lq iz hu lm b fv lr ls l lt lu">const Title = (props) =&gt; &lt;h1&gt;{props.children}&lt;/h1&gt;</span><span id="b218" class="lq iz hu lm b fv lv ls l lt lu">&lt;Title&gt;Higher-Order Components(HOCs) for React Newbies&lt;/Title&gt;<br/>//=&gt; &lt;h1&gt;Higher-Order Components(HOCs) for React Newbies&lt;/h1&gt;</span></pre><p id="feac" class="pw-post-body-paragraph jz ka hu kc b kd ke kf kg kh ki kj kk kz km kn ko la kq kr ks lb ku kv kw kx hn dt translated">高阶组件是接受组件作为参数并返回组件的函数。如何使用传递的组件取决于您。你甚至可以完全忽略它:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="c745" class="lq iz hu lm b fv lr ls l lt lu">// Technically an HOC<br/>const ignore = (anything) =&gt; (props) =&gt; &lt;h1&gt;:)&lt;/h1&gt;</span><span id="6d7c" class="lq iz hu lm b fv lv ls l lt lu">const IgnoreHeroList = ignore(HeroList)<br/>&lt;IgnoreHeroList /&gt;<br/>//=&gt; &lt;h1&gt;:)&lt;/h1&gt;</span></pre><p id="3501" class="pw-post-body-paragraph jz ka hu kc b kd ke kf kg kh ki kj kk kz km kn ko la kq kr ks lb ku kv kw kx hn dt translated">您可以编写一个将其输入转换为大写的特设:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="2379" class="lq iz hu lm b fv lr ls l lt lu">const yell = (PassedComponent) =&gt;<br/>  ({ children, ...props }) =&gt;<br/>    &lt;PassedComponent {...props}&gt;<br/>      {children.toUpperCase()}!<br/>    &lt;/PassedComponent&gt;</span><span id="700c" class="lq iz hu lm b fv lv ls l lt lu">const Title = (props) =&gt; &lt;h1&gt;{props.children}&lt;/h1&gt;<br/>const AngryTitle = yell(Title)</span><span id="f75d" class="lq iz hu lm b fv lv ls l lt lu">&lt;AngryTitle&gt;Whatever&lt;/AngryTitle&gt;<br/>//=&gt; &lt;h1&gt;WHATEVER!&lt;/h1&gt;</span></pre><p id="223e" class="pw-post-body-paragraph jz ka hu kc b kd ke kf kg kh ki kj kk kz km kn ko la kq kr ks lb ku kv kw kx hn dt translated">还可以返回有状态的组件，因为Javascript中的类是函数的语法糖。这允许您挂钩到像<code class="eh lw lx ly lm b">componentDidMount</code>这样的React生命周期方法。这就是HOCs真正有用的地方。我们现在可以做一些事情，比如将HTTP请求的结果作为道具传递给功能组件。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="d000" class="lq iz hu lm b fv lr ls l lt lu">const withGists = (PassedComponent) =&gt;<br/>  class WithGists extends React.Component {<br/>    state = {<br/>      gists: []<br/>    }</span><span id="68a3" class="lq iz hu lm b fv lv ls l lt lu">    componentDidMount() {<br/>      fetch("https://api.github.com/gists/public")<br/>      .then((r) =&gt; r.json())<br/>      .then((gists) =&gt; this.setState({<br/>        gists: gists<br/>      }))<br/>    }</span><span id="bb3d" class="lq iz hu lm b fv lv ls l lt lu">    render() {<br/>      return (<br/>        &lt;PassedComponent<br/>          {...this.props}<br/>          gists={this.state.gists}<br/>        /&gt;<br/>      )<br/>    }<br/>  }<br/></span><span id="cd25" class="lq iz hu lm b fv lv ls l lt lu">const Gists = ({ gists }) =&gt; (<br/>  &lt;pre&gt;{JSON.stringify(gists, null, 2)}&lt;/pre&gt;<br/>)</span><span id="c6d7" class="lq iz hu lm b fv lv ls l lt lu">const GistsList = withGists(Gists)</span><span id="222f" class="lq iz hu lm b fv lv ls l lt lu">&lt;GistsList /&gt;<br/>//=&gt; Before api request finishes:<br/>// &lt;Gists gists={[]} /&gt;<br/>// <br/>//=&gt; After api request finishes:<br/>// &lt;Gists gists={[<br/>//  { /* … */ },<br/>//  { /* … */ },<br/>//  { /* … */ }<br/>// ]} /&gt;</span></pre><p id="230b" class="pw-post-body-paragraph jz ka hu kc b kd ke kf kg kh ki kj kk kz km kn ko la kq kr ks lb ku kv kw kx hn dt translated">您可以在任何组件上调用<code class="eh lw lx ly lm b">withGists</code>,它将传递gists api调用的结果。你可以在这里看到这个<a class="ae ky" href="https://codesandbox.io/embed/o2YpJnpDj" rel="noopener ugc nofollow" target="_blank">更具体的例子。</a></p><h1 id="6a78" class="iy iz hu bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">结论:hoc是🔥 🔥 🔥</h1><p id="610a" class="pw-post-body-paragraph jz ka hu kc b kd lc kf kg kh ld kj kk kz le kn ko la lf kr ks lb lg kv kw kx hn dt translated">Redux使用一个特设的<code class="eh lw lx ly lm b"><a class="ae ky" href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options" rel="noopener ugc nofollow" target="_blank">connect</a></code>将值从应用程序商店传递到“连接”的组件。它还进行一些错误检查和组件生命周期优化，如果手动进行，将会导致您编写大量样板代码。</p><p id="1c72" class="pw-post-body-paragraph jz ka hu kc b kd ke kf kg kh ki kj kk kz km kn ko la kq kr ks lb ku kv kw kx hn dt translated">如果您发现自己在不同的地方写了很多代码做同样的事情，那么您可以将这些代码重构为一个可重用的HOC。</p><p id="f3e3" class="pw-post-body-paragraph jz ka hu kc b kd ke kf kg kh ki kj kk kz km kn ko la kq kr ks lb ku kv kw kx hn dt translated">hoc真的很有表现力，你可以用它们做很多很酷的东西。然而，因为它们太富于表现力了，如果你想的话，你可以过度使用它们。</p><p id="8d12" class="pw-post-body-paragraph jz ka hu kc b kd ke kf kg kh ki kj kk kz km kn ko la kq kr ks lb ku kv kw kx hn dt translated">尽量让你的HOCs保持简单，并致力于编写不需要你读一篇长文章就能理解的代码。</p><h1 id="d922" class="iy iz hu bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">附加练习</h1><p id="0fdc" class="pw-post-body-paragraph jz ka hu kc b kd lc kf kg kh ld kj kk kz le kn ko la lf kr ks lb lg kv kw kx hn dt translated">以下是一些巩固你对HOCs理解的练习:</p><ul class=""><li id="0f4f" class="lz ma hu kc b kd ke kh ki kz mb la mc lb md kx me mf mg mh dt translated">编写一个撤销其输入的特设</li><li id="7b4f" class="lz ma hu kc b kd mi kh mj kz mk la ml lb mm kx me mf mg mh dt translated">编写一个从API向其传递的组件提供数据的特设</li><li id="2de6" class="lz ma hu kc b kd mi kh mj kz mk la ml lb mm kx me mf mg mh dt translated">写一个实现<code class="eh lw lx ly lm b"><a class="ae ky" href="https://facebook.github.io/react/docs/react-component.html#shouldcomponentupdate" rel="noopener ugc nofollow" target="_blank">shouldComponentUpdate</a></code> <a class="ae ky" href="https://facebook.github.io/react/docs/optimizing-performance.html#avoid-reconciliation" rel="noopener ugc nofollow" target="_blank">的特设来避免调和</a>。</li><li id="d833" class="lz ma hu kc b kd mi kh mj kz mk la ml lb mm kx me mf mg mh dt translated">编写一个使用<code class="eh lw lx ly lm b"><a class="ae ky" href="https://facebook.github.io/react/docs/react-api.html#react.children.toarray" rel="noopener ugc nofollow" target="_blank">React.Children.toArray</a></code>对传递给其传递组件的子组件进行排序的特设组件。</li></ul><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="mn mo l"/></div></figure></div></div>    
</body>
</html>