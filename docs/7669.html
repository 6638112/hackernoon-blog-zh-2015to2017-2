<html>
<head>
<title>Beginner Bites: A taste of Elixir, a beautiful, concise and productive language</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初学者咬:品尝灵丹妙药，一个美丽的，简洁的和富有成效的语言</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/beginner-bites-a-taste-of-elixir-a-beautiful-concise-and-productive-language-82e03f69b92e?source=collection_archive---------15-----------------------#2017-11-03">https://medium.com/hackernoon/beginner-bites-a-taste-of-elixir-a-beautiful-concise-and-productive-language-82e03f69b92e?source=collection_archive---------15-----------------------#2017-11-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="9dbf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可能最近听说过这种语言。随着一个名为<a class="ae jp" href="http://phoenixframework.org/" rel="noopener ugc nofollow" target="_blank">凤凰</a>的新框架做出令人兴奋的声明，Elixir已经获得了公众的关注。</p><p id="6bf3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Phoenix被标榜为一个“高效、可靠和快速”的web框架，并且是用Elixir构建的。在对Phoenix过于兴奋之前，我想深入研究一下仙丹，看看这种神秘的语言能提供什么。</p><p id="aefe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">重要的事情先来。这些公司已经使用了灵丹妙药:</p><ul class=""><li id="7943" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">WhatsApp</li><li id="8e3c" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">不调和</li><li id="f8f5" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">拼趣</li><li id="e3a8" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">暴动小游戏</li><li id="dfc6" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">杂草地图</li></ul><p id="0bee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这引起了我的兴趣！</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff ke"><img src="../Images/b32fa441687a0f57094191d4ff6cf118.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OYxmyf5nOg17brYP1QTseA.jpeg"/></div></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">What will I do with such a beautiful language</figcaption></figure><p id="d0b8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">今天，我想通过一个小小的黑客问题向你展示Elixir带来的一些乐趣。</p><p id="907a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将涵盖，基本功能，迭代集合，获取用户输入，管道，模式匹配和警卫。</p><p id="b76b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们开始解决这个问题之前，让我们先安装Elixir并创建一个项目！</p><h2 id="b30d" class="ku kv hu bd kw kx ky kz la lb lc ld le jc lf lg lh jg li lj lk jk ll lm ln lo dt translated">入门指南</h2><p id="ad8d" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">Elixir有很好的关于起床和跑步的说明<a class="ae jp" href="https://elixir-lang.org/install.html" rel="noopener ugc nofollow" target="_blank">这里</a>！</p><p id="ee23" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过在终端或命令提示符下键入<code class="eh lu lv lw lx b">elixir -v</code>,检查您是否正确安装了elixir:</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff ly"><img src="../Images/e6144404602b4cac75ed538775303876.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TIqwFd9u8e6qk4o74wKMIA.png"/></div></div></figure><p id="06c9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">长生不老药配有极好的工具。</p><ul class=""><li id="f1c4" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">混合:仙丹的构建工具。它设置你的项目，获取依赖项并测试你的代码。太牛逼了。</li><li id="655e" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">IEx:一个动态测试代码的交互式repl。我总是用它打字。在你的终端/命令提示符下用<code class="eh lu lv lw lx b">iex</code>打开它，但是我们稍后会讲到。</li><li id="1571" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">ExUnit:一个简单但强大的测试框架。在这篇文章中，我们不会涉及太多。</li></ul><p id="55cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们开始编码这个问题吧！</p><p id="46ad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你正在寻找一个IDE来编写你的灵丹妙药，我强烈推荐安装了 <a class="ae jp" href="https://marketplace.visualstudio.com/items?itemName=mjmcloug.vscode-elixir" rel="noopener ugc nofollow" target="_blank"> <em class="lz"> vscode-elixir插件</em> </a> <em class="lz">的</em><a class="ae jp" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"><em class="lz">vs code</em></a><em class="lz">。它是轻量级的，反应灵敏的，并且有语法高亮和自动完成等优点。提示:</em> <strong class="it hv"> <em class="lz">视图- &gt;集成终端</em> </strong> <em class="lz">将打开一个终端，您可以在其中使用Iex。</em></p><h2 id="f540" class="ku kv hu bd kw kx ky kz la lb lc ld le jc lf lg lh jg li lj lk jk ll lm ln lo dt translated">开始一个项目</h2><p id="d248" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">导航到您想要放置项目的目录(这是这个代码问题的解决方案)。一旦你在终端中导航到这个文件夹，用命令<code class="eh lu lv lw lx b">mix new hackerrank_sol</code>创建一个新项目。当然，你可以随意称呼这个项目。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff ly"><img src="../Images/95fa2c825124589d47090a78cb1de958.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*if2WNBYZOCmgoIjBpBGl5w.png"/></div></div></figure><p id="89a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将创建一个包含您的Elixir项目的新文件夹。让我们在我们最喜欢的代码编辑器中打开这个文件夹。我们的代码将存在于以下文件中:<code class="eh lu lv lw lx b">lib/hackerrank_sol.ex</code>。通过运行<code class="eh lu lv lw lx b">mix test</code>检查一切正常。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff ly"><img src="../Images/8a4f6292a42e3c2a6a0b472aa71d21ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hs2gzMzn-oNRfuC3w9IkqQ.png"/></div></div></figure><h2 id="40dc" class="ku kv hu bd kw kx ky kz la lb lc ld le jc lf lg lh jg li lj lk jk ll lm ln lo dt translated">我们来编码吧！</h2><p id="d9d1" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">您的<code class="eh lu lv lw lx b">lib/hackerrank_sol.ex</code>文件中已经有一些代码:</p><figure class="kf kg kh ki fq kj"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="884a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将保留它，并开始在一个名为<code class="eh lu lv lw lx b">Solution</code>的新模块中对其进行编码(一个文件中可以有多个模块)。</p><figure class="kf kg kh ki fq kj"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="767e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个问题需要我们获得用户输入。特别是一串数字。让我们打开终端中的Iex，看看我们需要什么。</p><p id="4600" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在你的终端中输入<code class="eh lu lv lw lx b">iex</code>，你将会受到友好的REPL的欢迎。经常使用<code class="eh lu lv lw lx b">h()</code>查找关于函数的信息，因为文档很棒。</p><p id="928a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为我们想从用户那里获得IO，所以我们将查看IO模块。此处模块列表:<a class="ae jp" href="https://hexdocs.pm/elixir/Kernel.html" rel="noopener ugc nofollow" target="_blank">https://hexdocs.pm/elixir/Kernel.html</a></p><p id="6779" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<code class="eh lu lv lw lx b">iex</code>中，我们可以看到IO输出了什么，也可以像这样请求帮助:</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff ly"><img src="../Images/9e6861b6f47a8c6b5bd7c5f4d5f645f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pdjU6kf__8jlzn3CWTHbQQ.png"/></div></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">Here I’m using `exports` to find out what IO exports</figcaption></figure><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff ly"><img src="../Images/029a4b8fc1721dd632693b80e415af7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aRNFwNspH37ZVb1C1mfv5w.png"/></div></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">Now I’m using `h(IO.gets)` to ask Elixir what the function gets does.</figcaption></figure><p id="9d7b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">神圣的moly，<strong class="it hv">我们得到一个例子</strong>和其他好的信息！关于名字<code class="eh lu lv lw lx b">IO.gets/2</code>的一个快速注释。<code class="eh lu lv lw lx b">/2</code>仅仅意味着函数接受两个参数。类似地，<code class="eh lu lv lw lx b">/1</code>表示一个参数，而<code class="eh lu lv lw lx b">/0</code>表示零个参数。这个函数的名字叫做<strong class="it hv"> arity </strong>。(现在你又有了一个很棒的派对事实)</p><p id="059a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们在<code class="eh lu lv lw lx b">iex</code>中使用这个函数，尝试一下它返回的内容。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff ly"><img src="../Images/fe3a4d3846366a150df5148c96739e54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SSrq4Zl2_WvTUwvr4jwnnA.png"/></div></div></figure><p id="946d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好吧！我们现在真的应该试着解决这个问题！</p><blockquote class="mc md me"><p id="6e85" class="ir is lz it b iu iv iw ix iy iz ja jb mf jd je jf mg jh ji jj mh jl jm jn jo hn dt translated">注意:您可以使用<code class="eh lu lv lw lx b">IO.puts/1</code>打印到控制台</p></blockquote><h1 id="0226" class="mi kv hu bd kw mj mk ml la mm mn mo le mp mq mr lh ms mt mu lk mv mw mx ln my dt translated">两组之间</h1><p id="583d" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">这个问题可以概括为:</p><ul class=""><li id="bdbd" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">给我们一条长度为两个数组的线，<strong class="it hv"> a </strong>和<strong class="it hv"> b. </strong></li><li id="d060" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">我们给了一个数组<strong class="it hv">一个</strong>。这是一个整数列表。</li><li id="4d5d" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">我们得到一个数组<strong class="it hv"> b </strong>。它也是一个整数列表。</li></ul><p id="c149" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个元素<strong class="it hv"> x </strong>被称为在<strong class="it hv"> a </strong>和<strong class="it hv"> b </strong>之间，如果:</p><ul class=""><li id="1b07" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">数组<strong class="it hv"> a </strong>中的所有元素都是<strong class="it hv"> x </strong>的因子。</li><li id="3bee" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated"><strong class="it hv"> x </strong>是<strong class="it hv"> b </strong>中所有元素的因子。</li></ul><p id="16a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我们想知道,<strong class="it hv"> x </strong>有多少个不同的值。</p><p id="9aa4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://www.hackerrank.com/challenges/between-two-sets/problem" rel="noopener ugc nofollow" target="_blank">查看hackerrank给出的具体示例，以明确需要什么</a>。</p><p id="ca03" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们把这个问题分成三块:</p><ul class=""><li id="8302" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">获取和处理输入。</li><li id="4e86" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">确保<strong class="it hv"> x </strong>是<strong class="it hv"> b. </strong>中所有元素的因子</li><li id="5863" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">确保数组<strong class="it hv"> a </strong>中的所有元素都是<strong class="it hv"> x </strong>的因子。</li></ul><h2 id="d74d" class="ku kv hu bd kw kx ky kz la lb lc ld le jc lf lg lh jg li lj lk jk ll lm ln lo dt translated">获取和处理输入</h2><p id="a60c" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">这真的是干净的仙丹。我们有从标准输入中获取一行输入的<code class="eh lu lv lw lx b">IO.gets/1</code>。在这个问题中，我们将得到3行输入，每一行都是一个整数列表。让我们创建一个通用的<code class="eh lu lv lw lx b">getLine/0</code>函数，它从stdin获取一行数据并返回一个数字列表。</p><p id="2eec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里有一个简单的实现，应该很容易理解。随意使用<strong class="it hv"> iex </strong>来浏览这些行，看看每一行在做什么。</p><figure class="kf kg kh ki fq kj"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="7bdc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您想测试这个功能，在您的终端中使用这个命令启动iex:<code class="eh lu lv lw lx b">iex -S mix</code>。这个命令允许您在iex中访问您的mix项目。如果你修改了代码，你也可以使用<code class="eh lu lv lw lx b">recompile()</code>来重新编译你的工作，这样你就可以使用最新的代码。</p><p id="4310" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了在<code class="eh lu lv lw lx b">iex</code>中测试这个函数，我们键入<code class="eh lu lv lw lx b">Solution.getLine()</code>。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff ly"><img src="../Images/77bfc94964512f619d5b2238388f8196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ElsoSLQIyaJs4dPV4V9cHA.png"/></div></div></figure><p id="f0a6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在使这段代码更加地道之前，我们先来看看elixir提供的一些很棒的东西。我们在函数上面有这个<code class="eh lu lv lw lx b">@doc</code>标签。这被称为模块属性，它告诉Elixir您已经向<code class="eh lu lv lw lx b">getLine/0</code>函数提供了文档。键入<code class="eh lu lv lw lx b">h(Solution.getLine/0)</code>并观察您自己的文档显示的所有荣耀！(注意文档支持降价！)</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff ly"><img src="../Images/647562c98afc1d9d1667cb63404723dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zWdKDuE4nDfv8MfnSCrv1A.png"/></div></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">This is beautiful professional documentation.</figcaption></figure><p id="5e25" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们现在不会详细讨论这个问题，但是您也可以在您的文档中编写可执行的文档测试。大多数时候，当你在文档中看到例子时，它们是可执行的，以确保它们是有效的。这允许单元测试和集成测试的分离。</p><p id="d069" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们快速浏览一下看起来很时髦的一行:</p><pre class="kf kg kh ki fq mz lx na nb aw nc dt"><span id="d8db" class="ku kv hu lx b fv nd ne l nf ng">converted_to_int = Enum.map(split_line, fn el -&gt; String.to_integer(el) end)</span></pre><p id="1ee7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们映射一个字符串列表，并将每个元素转换成一个整数。发生了以下情况:</p><p id="77a6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lu lv lw lx b">["1", "10", "3"] -- <em class="lz">Enum.map</em> --&gt; [1, 10, 3]</code></p><p id="13ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每个元素都作为<code class="eh lu lv lw lx b">el</code>传递给匿名函数，然后匿名函数将字符串转换成整数。</p><p id="17c8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">函数的最后一行被隐式返回。我发现这实际上鼓励了干净的编码，因为很难写出奇怪的嵌套条件，它们会奇怪地返回。</p><p id="dd2d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们来清理一下，这样每个人都会对使用另一个令人敬畏的仙丹操作员印象深刻…</p><p id="39c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="lz">我们将相信每个字符串都是有效的整数(但在现实世界中不应该这样)。</em></p><h2 id="f5a2" class="ku kv hu bd kw kx ky kz la lb lc ld le jc lf lg lh jg li lj lk jk ll lm ln lo dt translated">管道操作员</h2><p id="2596" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">我们的职能中出现了一种模式。每一行都将上面函数的输出作为第一个参数。Elixir为我们提供了这个很酷的操作符:<code class="eh lu lv lw lx b">|&gt;</code>,它将输出从左向右传输。</p><figure class="kf kg kh ki fq kj"><div class="bz el l di"><div class="ma mb l"/></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">Check out the code without all the intermediate variables!</figcaption></figure><p id="389e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意，我们删除了每个函数的第一个参数，因为它是由管道操作符处理的。</p><p id="836d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">输入完毕！现在让我们着手确保<strong class="it hv"> x </strong>是<strong class="it hv"> b </strong>中所有元素的一个因子。</p><h2 id="1f7b" class="ku kv hu bd kw kx ky kz la lb lc ld le jc lf lg lh jg li lj lk jk ll lm ln lo dt translated">确保<strong class="ak"> x </strong>是<strong class="ak"> b </strong>中所有元素的因子。</h2><p id="1150" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">我就直入主题了。我们需要找出列表<strong class="it hv"> b </strong>中元素的最大公约数。那么如果<strong class="it hv"> x </strong>除以最小公约数，它满足条件:它是<strong class="it hv"> b </strong>所有元素的因子。</p><p id="6f3c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有没有瞬间尖叫<em class="lz">欧几里德的算法</em>？稍后快速搜索<strong class="it hv">寻找最大公约数</strong>你会发现这个数学公式。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="fe ff nh"><img src="../Images/56f76f5d4657036feb70f648896a7cda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*U4EWAcSr_4td9jWbG5k_Zg.png"/></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">Straight from <a class="ae jp" href="https://en.wikipedia.org/wiki/Greatest_common_divisor#Using_Euclid.27s_algorithm" rel="noopener ugc nofollow" target="_blank">wikipedia</a></figcaption></figure><p id="05da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您还记得编码该算法的一种强制性方式(来自python的标准库):</p><pre class="kf kg kh ki fq mz lx na nb aw nc dt"><span id="5b0e" class="ku kv hu lx b fv nd ne l nf ng">def gcd(a, b):<br/>    """Calculate the Greatest Common Divisor of a and b.<br/>    Unless b==0, the result will have the same sign as b (so that      <br/>    when b is divided by it, the result comes out positive).<br/>    """<br/>    while b:<br/>        a, b = b, a%b<br/>    return a</span></pre><p id="460f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将做得更好，用Elixir编写我们自己的代码，它使用数学定义，提供很好的错误消息，并且仍然很快。</p><h2 id="57e9" class="ku kv hu bd kw kx ky kz la lb lc ld le jc lf lg lh jg li lj lk jk ll lm ln lo dt translated">防护和模式匹配</h2><p id="2665" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">Elixir支持模式匹配以及检查函数输入的条件。下面是一个简单的模式匹配示例:</p><figure class="kf kg kh ki fq kj"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="5705" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们在这里说的是，如果参数是<code class="eh lu lv lw lx b">0</code>，我们想要运行函数的顶层版本。如果参数不是<code class="eh lu lv lw lx b">0</code>，我们将在一个字符串中返回它。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff ni"><img src="../Images/da2fd4a46d3e13f7d8e834e0090a486a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tsVuCbis5ik2eCSZm-eD1w.png"/></div></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">Wait!!! We don’t want that third behaviour!</figcaption></figure><p id="98a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是可行的，但不幸的是参数<code class="eh lu lv lw lx b">x</code>可以是任何东西！幸运的是，我们有<a class="ae jp" href="https://hexdocs.pm/elixir/master/guards.html" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">守卫</strong> </a>，允许我们给参数添加约束。</p><p id="5770" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以通过添加<code class="eh lu lv lw lx b">is_integer</code>守卫来改进这个模式匹配示例，如下所示:</p><figure class="kf kg kh ki fq kj"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="a33c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">看看当我们试图传递无效的东西时会发生什么:</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff ni"><img src="../Images/8261ec9edad8ef5b50f4ff6bfa8abfff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*87ddN3Qyq6WPfjFliW46BQ.png"/></div></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">Taking our new guard for a test run.</figcaption></figure><p id="1253" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们得到了一个非常有用的信息，它特别指出了我们的论点失败的地方。我们可以看到一个<code class="eh lu lv lw lx b">[1,2,3]</code>的列表没能成为<code class="eh lu lv lw lx b">0</code>。它也不是整数。</p><p id="54a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们现在已经有足够的东西来编写我们的<code class="eh lu lv lw lx b">gcd</code>函数了。</p><figure class="kf kg kh ki fq kj"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="d33f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">守卫比代码多！(<em class="lz">嘶，仙丹中有一种方法可以创造你自己的组合守卫，但那不在今天的讨论范围之内</em>)</p><p id="0d80" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这也遵循了最大公约数的数学定义！当然有一种更快的方法来使用余数，我把它作为练习留给你们。(<a class="ae jp" href="https://gist.github.com/SpyR1014/dbd333de6f7dc9fb07bf4f9f8b6556f0" rel="noopener ugc nofollow" target="_blank">解</a>)</p><p id="145c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们需要找到一个列表的最大公约数。为了找到一系列数字的gcd，我们只需要根据当前的最大公约数减少这些数字，我们用每个元素更新这个最大公约数。我就用图吧！</p><p id="24eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们从这个列表开始:<code class="eh lu lv lw lx b">[8, 4, 16, 2]</code></p><p id="72d2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我们在前两个数字上使用<code class="eh lu lv lw lx b">gcd</code>:</p><pre class="kf kg kh ki fq mz lx na nb aw nc dt"><span id="5e78" class="ku kv hu lx b fv nd ne l nf ng">Reducing    --   List left to reduce<br/>------------------------------------<br/>gcd(8, 4)   --   [16, 2]<br/>= 4         --   [16, 2]<br/>gcd(4, 16)  --   [2]<br/>= 4         --   [2]<br/>gcd(4, 2)   --   []<br/>= 2</span></pre><p id="e1f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有一个功能可以做到这一点，叫做<code class="eh lu lv lw lx b">Enum.reduce/2</code>。这个列表缩减函数也可以称为<code class="eh lu lv lw lx b">gcd</code>，因为它在计算最大公约数。</p><figure class="kf kg kh ki fq kj"><div class="bz el l di"><div class="ma mb l"/></div></figure><h2 id="ed55" class="ku kv hu bd kw kx ky kz la lb lc ld le jc lf lg lh jg li lj lk jk ll lm ln lo dt translated">计算最低公倍数</h2><p id="b10c" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">现在我们有了一个<code class="eh lu lv lw lx b">gcd</code>函数，最小公倍数就简单多了。事实上是下面的公式:</p><blockquote class="nj"><p id="d395" class="nk nl hu bd nm nn no np nq nr ns jo ek translated">lcm( <em class="nt"> a </em>，<em class="nt">b</em>)=<em class="nt">a</em>×<em class="nt">b</em>/gcd(<em class="nt">a</em>，<em class="nt"> b </em>)</p></blockquote><p id="9b72" class="pw-post-body-paragraph ir is hu it b iu nu iw ix iy nv ja jb jc nw je jf jg nx ji jj jk ny jm jn jo hn dt translated">该死，这是一个伟大的公式。我们可以很容易地编写代码，包括演示的减少。</p><figure class="kf kg kh ki fq kj"><div class="bz el l di"><div class="ma mb l"/></div></figure><h2 id="9da4" class="ku kv hu bd kw kx ky kz la lb lc ld le jc lf lg lh jg li lj lk jk ll lm ln lo dt translated">大结局</h2><p id="30e1" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">既然我们有了获取输入的方法、找到最大公约数的方法和找到最小公倍数的方法，我们几乎就有了找到解决方案的方法。</p><p id="8280" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们要用有史以来最无聊的方法找到解决方案。我们将从最小公倍数到最大公约数“循环”每个整数，检查该数字是否满足问题的两个条件。然后我们将计算满足测试的结果<strong class="it hv"> x </strong>值。</p><p id="8480" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们将要编写的函数中，我们将接受最大值(<strong class="it hv">或list </strong> <strong class="it hv"> b </strong>的gcd)。我们还将接受最低值(<strong class="it hv">或列表a的LCM</strong>)。</p><figure class="kf kg kh ki fq kj"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="cba8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们首先检查列表<strong class="it hv"> b </strong>中的<strong class="it hv"> gcd </strong>值是否大于列表<strong class="it hv"> a </strong>中的<strong class="it hv"> lcm </strong>值(否则保护失败，我们返回0)。</p><p id="122b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lu lv lw lx b">lowest..highest</code>是一个范围。医生说。</p><blockquote class="nj"><p id="6f3e" class="nk nl hu bd nm nn no np nq nr ns jo ek translated">”定义一个范围”</p></blockquote><p id="4c73" class="pw-post-body-paragraph ir is hu it b iu nu iw ix iy nv ja jb jc nw je jf jg nx ji jj jk ny jm jn jo hn dt translated"><code class="eh lu lv lw lx b">1..3</code>基本上就是我们上面使用的<code class="eh lu lv lw lx b">[1,2,3]</code>。该代码基本上创建了一个介于最小和最大值之间的所有可能的<strong class="it hv"> x </strong>值的范围，然后根据这两个条件进行过滤。第一个过滤器检查<strong class="it hv"> x </strong>是列表<strong class="it hv"> a </strong>的lcm的倍数。第二个过滤器检查<strong class="it hv"> x </strong>是列表<strong class="it hv"> b </strong>的gcf的一个因子。然后我们统计结果:)</p><p id="d26c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们可以将各个部分放在一起以获得输入，并计算结果:</p><figure class="kf kg kh ki fq kj"><div class="bz el l di"><div class="ma mb l"/></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">This puts it all together to solve the hackerrank problem! :)</figcaption></figure><p id="6037" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">恭喜你读到这里！希望我已经向你展示了长生不老药是一种乐趣。模式匹配和保护的概念允许你对你的函数所采用的内容实施更好的前提条件。</p><p id="e7d9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">模式匹配比这里所展示的要深入得多，它确实有助于编写可读、可爱的代码。<a class="ae jp" href="https://gist.github.com/SpyR1014/d35dce82460d468055d28be00261c08b" rel="noopener ugc nofollow" target="_blank">黑客排名代码的完整解决方案在此</a>。</p><p id="9f60" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我还没有介绍这种语言的测试有多棒，或者Elixir 1.6附带了一个代码格式化程序。我甚至没有提到尾部递归或角色模型，也没有提到用这种语言进行并发编程是多么容易。</p></div><div class="ab cl nz oa hc ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="hn ho hp hq hr"><p id="25ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我希望你喜欢这个旋风式的旅行，如果你使用了仙丹或者对这个帖子感兴趣，请留下你的评论！我也喜欢掌声，如果你喜欢这篇文章，我会非常感激。</p></div></div>    
</body>
</html>