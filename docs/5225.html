<html>
<head>
<title>Programming with JS: Merge Sort</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JS编程:合并排序</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/programming-with-js-merge-sort-deb677b777c0?source=collection_archive---------3-----------------------#2017-07-17">https://medium.com/hackernoon/programming-with-js-merge-sort-deb677b777c0?source=collection_archive---------3-----------------------#2017-07-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/60a956da65b91b5ccf2d4d31b44f7f81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AGKCwMcNxpeolzxTzia5Ng.jpeg"/></div></div></figure><p id="14dd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">理解数据结构、算法和基本编程概念对于成为一名优秀的开发人员至关重要。现在，这些问题中的大部分都可以使用现代工具和库来解决，但是在该领域拥有更深入的知识肯定会拓宽您的软件开发视野。</p><p id="6e5e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就个人而言，对我来说很难理解其中的一些概念，因为我在日常工作中没有用到它们。我写这个系列是为了提高我自己对这些话题的理解，并帮助像我一样的其他人。</p><h1 id="2669" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">什么是合并排序？</h1><p id="ab44" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">归并排序是计算机科学中常用的排序算法之一。Firefox和Safari在实现Array.prototype.sort()时使用它(还记得JavaScript在不同浏览器中的不同行为吗？).它具有良好的性能，易于实现和理解。</p><p id="94d4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那么如何用归并排序对一个列表进行排序，这个算法是如何工作的？这一切都围绕着这样一个想法，即对两个有序的数组进行排序比对一个未排序的数组进行排序更容易。一旦我们有了两个排序后的数组，我们开始逐个比较它们的条目，并将较小的条目添加到结果列表中。假设你有两个列表A和B，你比较A[0]和B[0]。假设A[0]更小—我们将它添加到结果列表中并继续。然后我们比较A[1]和B[0]。这一次B[0]是较小的一个，所以我们添加它，并继续比较A[1]和B[1]等等…</p><p id="cefa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在排序的最后，任何左边的变量都连接在结果列表的末尾——因为A和B数组已经排序了，这不会导致重新排序。</p><h1 id="9644" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated"><strong class="ak">那么它是如何工作的呢？</strong></h1><p id="7567" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">这个概念很容易理解，但是我们如何达到有两个排序数组的状态呢？多项数组只有排序后才能比较！我们可以通过递归地将数组分成两半来实现这一点，直到我们到达比较多对单项数组的点。</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="e541" class="lm kb hu li b fv ln lo l lp lq">[1, 5, 3, 9, 6, 4, 8]</span><span id="4007" class="lm kb hu li b fv lr lo l lp lq">[1, 5, 3, 9] | [6, 4, 8]</span><span id="a549" class="lm kb hu li b fv lr lo l lp lq">[1, 5] | [3, 9] [6] | [4, 8]</span><span id="1717" class="lm kb hu li b fv lr lo l lp lq">[1] | [5] [3] | [9] [4] | [8]</span></pre><p id="0991" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这不是迄今为止最全面的模式，但是您可以看到数组是如何被递归地分割成越来越小的数组，直到我们达到只有包含单个项目的数组的状态。此时，我们开始逐个比较它们，并使用上面提到的连接方法——对数组进行排序。</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="a47c" class="lm kb hu li b fv ln lo l lp lq">[9, 3, 6, 4]</span><span id="e355" class="lm kb hu li b fv lr lo l lp lq">[9, 3] | [6, 4]</span><span id="b901" class="lm kb hu li b fv lr lo l lp lq">[9] | [3] [6] | [4]</span><span id="f412" class="lm kb hu li b fv lr lo l lp lq">[3, 9] | [4, 6]</span><span id="d262" class="lm kb hu li b fv lr lo l lp lq">[3, 4, 6, 9]</span></pre><p id="ba62" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">换句话说，我们将数组分割成最小的部分，然后按照正确的顺序重新组装。这里有一个JavaScript实现，它利用内置的<strong class="je hv"> slice </strong>函数来获取我们需要的数组部分。</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="e9a4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">算法通常不会在你第一次读到它们的时候点击。花一些时间在它们上面——一天、两天、一周或更长时间，直到你完全理解它们。只是通读代码并复制它不会帮助你的思维变得更好，所以花额外的时间并围绕这个概念思考。</p><p id="5316" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">谢谢你的阅读！您可以在我的个人资料中查看我的其他JS文章，或者在这里查看更多计算机科学主题:</p><blockquote class="lu lv lw"><p id="d06c" class="jc jd lx je b jf jg jh ji jj jk jl jm ly jo jp jq lz js jt ju ma jw jx jy jz hn dt translated"><strong class="je hv">用JS编程:</strong></p><p id="2fa1" class="jc jd lx je b jf jg jh ji jj jk jl jm ly jo jp jq lz js jt ju ma jw jx jy jz hn dt translated"><strong class="je hv">递归</strong>:<a class="ae mb" href="https://hackernoon.com/programming-with-js-recursion-31371e2bf808" rel="noopener ugc nofollow" target="_blank">https://hacker noon . com/programming-with-js-Recursion-31371 e2bf 808</a><br/><strong class="je hv">合并排序</strong>:<a class="ae mb" rel="noopener" href="/@KondovAlexander/programming-with-js-merge-sort-deb677b777c0">https://medium . com/@ KondovAlexander/programming-with-js-Merge-Sort-deb 677 b 777 c 0</a><strong class="je hv">二分搜索法</strong>:<a class="ae mb" rel="noopener" href="/@KondovAlexander/programming-with-js-binary-search-aaf86cef9cb3">https://medium . com/@ kondovalexan</a></p></blockquote><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="mc lt l"/></div></figure></div></div>    
</body>
</html>