<html>
<head>
<title>Javascript Promises for animation sequences</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript承诺动画序列</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/javascript-promises-for-animation-sequences-e31873493d49?source=collection_archive---------7-----------------------#2017-05-15">https://medium.com/hackernoon/javascript-promises-for-animation-sequences-e31873493d49?source=collection_archive---------7-----------------------#2017-05-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/16080254c885590cb261629d453cb13a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*pVdIcMwQ6165aPzUOdQTTQ.gif"/></div></div></figure><p id="4ebd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我最近有机会参加了令人惊叹的<a class="ae ka" href="http://creativecoding.club" rel="noopener ugc nofollow" target="_blank"> creativecoding.club </a>并拼凑了一个花朵落地的树的动画。这棵树首先使用随机算法建造(灵感来自survivol的这支<a class="ae ka" href="http://codepen.io/survivol/pen/pbGpog" rel="noopener ugc nofollow" target="_blank">生长</a>笔)，然后将花朵随机连接到新生长的树的树枝末端。</p><p id="6d87" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作为后端<a class="ae ka" href="https://hackernoon.com/tagged/engineer" rel="noopener ugc nofollow" target="_blank">工程师</a>的经验比设计或动画方面的经验多，我立即想到使用<a class="ae ka" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> Javascript </a>承诺帮助我排序一切，就像一堆数据库事务与API调用交错。它涉及到异步递归，这一开始看起来很棘手，所以我想我应该写一个解释，以防它可能会帮助其他想以同样的方式将它用于动画的人。😊</p><h1 id="6eda" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">种植树木</h1><figure class="kz la lb lc fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/ec84fdca3c3b44c0b567cd1d7153f55d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Ov6NxkNMmlPIEYA7miYpQw.gif"/></div></div><figcaption class="ld le fg fe ff lf lg bd b be z ek">From tiny acorns…</figcaption></figure><p id="f21a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第一步是弄清楚如何创建随机树。我们使用递归，这实际上是一种奇特的方式，说明我们是在已经做好的工作的基础上进行构建的。这是一个高层次的想法:</p><ol class=""><li id="2376" class="lh li hu je b jf jg jj jk jn lj jr lk jv ll jz lm ln lo lp dt translated">从树干开始——我们知道它的起点(地面)和终点(树干离地面的高度)。</li><li id="eed8" class="lh li hu je b jf lq jj lr jn ls jr lt jv lu jz lm ln lo lp dt translated">画树干。</li><li id="0991" class="lh li hu je b jf lq jj lr jn ls jr lt jv lu jz lm ln lo lp dt translated">接下来，从主干上创建一些分支——它们从主干结束的地方开始。我们在树干的左右两侧随机选取一些角度，一些比树干本身稍短的随机长度，并用它们来计算新树枝的末端。</li><li id="fa1f" class="lh li hu je b jf lq jj lr jn ls jr lt jv lu jz lm ln lo lp dt translated">画树枝。</li><li id="c448" class="lh li hu je b jf lq jj lr jn ls jr lt jv lu jz lm ln lo lp dt translated">对于两个新分支中的每一个，我们取它们的端点，并从它们上面再长出两个分支，就像步骤3中一样。</li><li id="1da9" class="lh li hu je b jf lq jj lr jn ls jr lt jv lu jz lm ln lo lp dt translated">重复，直到我们达到了我们想要的树的深度！</li></ol><p id="ef02" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以这个算法会给我们一棵树，但是如果我们边走边画的话，它的绘制速度会和计算机能够绘制和计算的速度一样快，可能太快了。如果我们想给树添加动画，让它看起来长得更慢，会怎么样？嗯，我们可以加一个延时！</p><p id="161e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在步骤3和4之间，计算然后绘制新的分支，我们可以等待(使用setTimeout())来绘制分支。由于重复发生在绘制之后，所以树会慢慢散开，计算、等待、绘制、计算、等待、绘制等。</p><p id="a65a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，我们最终得到的代码可能大致如下所示(假设未定义的函数做了它们目前所说的事情):</p><figure class="kz la lb lc fq iv"><div class="bz el l di"><div class="lv lw l"/></div></figure><h1 id="8c81" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">寻找最后一个分支的末端</h1><p id="b131" class="pw-post-body-paragraph jc jd hu je b jf lx jh ji jj ly jl jm jn lz jp jq jr ma jt ju jv mb jx jy jz hn dt translated">一旦我们种了树，我们就知道最后的树枝在哪里，我们想把它们都收集起来，这样我们就可以在下一阶段给它们加上花。具体来说，当我们意识到我们的newRemainingBranches ≤ 0时，我们知道我们不会再分支，因此我们知道我们计算的终点是一个结束分支。</p><p id="eeee" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们没有将所有这些延迟添加到代码中，我们本可以找到某种方法将分支的末端返回给growTree()的调用者。所以我们需要想出另一种方法来获得所有这些分支末端…</p><p id="66d9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以先尝试的一种方法是，创建一个数组，把分支末端放进去。我们可以将数组传递给growTree()/growBranch()，或者使用一个全局变量。不管怎样，我们都不确定<em class="mc">什么时候</em>所有的分支都在数组中。我们可以尝试计算我们期望的分支数量，但是我们仍然需要等待和投票来得到正确的数量。</p><p id="8b25" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们只是在所有分支创建时才得到通知，不是更好吗？</p><h1 id="eb35" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">输入承诺</h1><figure class="kz la lb lc fq iv"><div class="bz el l di"><div class="md lw l"/></div><figcaption class="ld le fg fe ff lf lg bd b be z ek">“I’m sorry, but I’m just thinking of the right words to say” for this section which is hard to explain</figcaption></figure><p id="2603" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://developers.google.com/web/fundamentals/getting-started/primers/promises" rel="noopener ugc nofollow" target="_blank">承诺</a>是做到这一点的好方法！假设我们的growTree()函数返回一个承诺，无论何时计算并绘制了所有的分支，它都会告诉我们并给我们分支。然后我们可以用这些树枝来做花的动画。</p><p id="a572" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于growTree()只是一个带有特殊参数的对growBranch()的调用，因此让growBranch()返回该承诺是有意义的。但是growBranch()递归地调用自己，尽管是以一种延迟的方式。因此，如果我们说growBranch()返回的是对一组端点的承诺，我们可以开始构建一个递归的承诺“树”(现在在计算机科学的意义上)。当我们得到所有这些承诺的结果时，我们可以将它们展平，得到一个分支结尾的数组。</p><figure class="kz la lb lc fq iv"><div class="bz el l di"><div class="lv lw l"/></div></figure><p id="7b03" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Promise库有几个不同的方面，所以让我们分别来看一下:</p><ul class=""><li id="87ef" class="lh li hu je b jf jg jj jk jn lj jr lk jv ll jz me ln lo lp dt translated"><strong class="je hv"> Promise.resolve() </strong>是一个效用函数，它说，“我保证我会给你这个值，但是，就像，现在。”这使得我们总是从函数中返回一个承诺变得一致，所以无论谁调用它，包括我们自己，都可以这样对待它。</li><li id="d92e" class="lh li hu je b jf lq jj lr jn ls jr lt jv lu jz me ln lo lp dt translated"><strong class="je hv"> Promise.all() </strong>是另一个实用程序，用于承诺您将返回您传递的所有承诺解析(您承诺返回的实际内容)的数组。换句话说，它一直等到几件事情都完成了，然后将它们作为一个包返回。</li><li id="9aed" class="lh li hu je b jf lq jj lr jn ls jr lt jv lu jz me ln lo lp dt translated">让我们以完全定制的方式创建一个新的承诺。它接受一个函数，并使用resolve()函数调用该函数。当您在该函数中调用resolve()时，它将解析为您为resolve()提供的参数。第一次看到它时，很难理解，但是在我们的例子中，我们只是试图将growBranch()递归调用的输出返回给父节点。如果这没有意义，<a class="ae ka" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank"> Mozilla有一个更清晰、更深入的解释</a>。</li><li id="ec9b" class="lh li hu je b jf lq jj lr jn ls jr lt jv lu jz me ln lo lp dt translated"><strong class="je hv"> Promise.prototype.then() </strong>让我们将计算链接到承诺的末尾。在这种情况下，我们希望将树中所有已解析的值展平到端点的平面数组中。</li></ul><h1 id="ad5f" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">最终产品</h1><p id="3ac2" class="pw-post-body-paragraph jc jd hu je b jf lx jh ji jj ly jl jm jn lz jp jq jr ma jt ju jv mb jx jy jz hn dt translated">所以我希望这一切都有意义，但有很多事情正在发生，所以它可能只是有助于分叉和玩这个代码笔只有树。</p><figure class="kz la lb lc fq iv"><div class="bz el l di"><div class="md lw l"/></div></figure><p id="a3ce" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">运行检查器，您应该能够看到输出到控制台的所有端点的数组。这支笔中的代码与上面gists中的代码略有不同，为了清楚起见，我<em class="mc">试图</em>简化这些代码。</p><p id="37a1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，一旦你对上面的树动画有所了解，你可以看看这支笔，它使用树枝端点来种花:</p><figure class="kz la lb lc fq iv"><div class="bz el l di"><div class="md lw l"/></div></figure><p id="06c9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你最终使用了这个技巧，请在Twitter <a class="ae ka" href="https://twitter.com/OngEmil" rel="noopener ugc nofollow" target="_blank"> @OngEmil </a>上与我分享或者作为下面的回应！🌸🌸🌸</p></div><div class="ab cl mf mg hc mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hn ho hp hq hr"><p id="a3f9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="mc">好吧，我不打算发布那个gif，问你是否喜欢这个帖子，所以作为回报…你愿意吗</em>💚<em class="mc">如果你喜欢这篇文章，请关注？:D </em></p><div class="kz la lb lc fq ab cb"><figure class="mm iv mn mo mp mq mr paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mm iv mn mo mp mq mr paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mm iv mn mo mp mq mr paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ms mt mu"><p id="f922" class="jc jd mc je b jf jg jh ji jj jk jl jm mv jo jp jq mw js jt ju mx jw jx jy jz hn dt translated"><a class="ae ka" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是阿妹家庭的一员。我们现在<a class="ae ka" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ka" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>的机会。</p><p id="708a" class="jc jd mc je b jf jg jh ji jj jk jl jm mv jo jp jq mw js jt ju mx jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ka" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ka" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kz la lb lc fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff my"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="kz la lb lc fq iv"><div class="bz el l di"><div class="mz lw l"/></div></figure></div></div>    
</body>
</html>