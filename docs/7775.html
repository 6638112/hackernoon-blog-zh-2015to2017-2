<html>
<head>
<title>How to Deploy Hyperledger Fabric on Kubernetes (1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Kubernetes上部署Hyperledger Fabric)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-deploy-hyperledger-fabric-on-kubernetes-1-a2ceb3ada078?source=collection_archive---------4-----------------------#2017-11-08">https://medium.com/hackernoon/how-to-deploy-hyperledger-fabric-on-kubernetes-1-a2ceb3ada078?source=collection_archive---------4-----------------------#2017-11-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="ac28" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">概观</h1><p id="fa6e" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">Fabric是Linux基金会主持的Hyperledger项目之一。它提供了一个开发区块链应用程序的框架。自从今年7月Fabric 1.0发布以来，人们渴望使用Fabric构建应用程序来解决他们的业务问题。然而，由于结构配置的复杂性，许多人在部署和管理结构系统时会遇到困难。</p><p id="3e00" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">为了简化Fabric的操作，我们需要一些工具来帮助我们更好地管理Fabric的分布式系统。Kubernetes似乎是这一目的的理想选择，原因有几个。(有趣的是，Kubernetes是CNCF的旗舰项目，也是Linux基金会的项目。)</p><p id="b2e5" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">首先，Fabric的位被构建到容器映像中。它的chaincode(智能契约)也利用容器在沙箱中运行。Fabric系统由运行在多个容器中的组件组成。另一方面，Kubernetes正在成为自动化容器化应用程序的部署、伸缩和其他管理的主导平台。这两者是天生的一对。</p><p id="c973" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">其次，Fabric组件可以通过部署在Kubernetes上实现高可用性。Kubernetes有一个名为replicator的功能，它可以监控正在运行的pod，并自动调出崩溃的pod。</p><p id="d2b2" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">第三，Kubernetes支持多租户。我们可以在同一个Kubernetes平台上运行多个独立的Fabric实例。这有助于区块链应用程序的开发和测试。</p><p id="828f" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">在接下来的小节中，我们将介绍一种在Kubernetes上部署Fabric的方法。我们假设读者对织物、Docker容器和Kubernetes有基本的了解。</p><h1 id="44f9" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated"><strong class="ak">网络拓扑</strong></h1><p id="a917" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我们的网络拓扑如图1所示。物理网络用蓝线表示。Kubernetes有一个或多个主节点和工作节点。除此之外，我们有一个CMD机器作为客户机来发布部署命令。NFS服务器用作配置文件和其他数据的共享文件系统。所有这些节点都通过物理网络(例如192.168.0.1/24)连接在一起。</p><p id="f5f5" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">Kubernetes的网络模型使所有的pod能够直接相互连接，而不管它们在哪个节点上。通过使用Kubernetes的CNI插件，如法兰绒，很容易为此目的创建一个叠加网络。如图1中的红线所示(省略了法兰绒组件的一些细节)，Kubernetes将所有的pod连接到法兰绒网络，允许这些pod的容器正确地相互通信。</p><p id="7f41" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">法兰绒网络的IP地址范围以及kube_dns的IP地址可以在附加配置文件中指定。我们需要确保kube_dns的IP地址必须在指定的地址范围内。例如，在图1中，法兰绒网络是10.0.0.1/16，kube_dns地址是10.0.0.10。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="fe ff ks"><img src="../Images/b606796b933ae88f5074081c9865630f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XWJnYYVtYsV71Jwc.png"/></div></div></figure><p id="db4e" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">图1</p><h1 id="a854" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated"><strong class="ak">将织物组件映射到Kubernetes pod</strong></h1><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="fe ff ks"><img src="../Images/f9e0fcdca81a4bab3fb506c029da5ecf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RsyzLqCkvXB25BJb.png"/></div></div></figure><p id="86f2" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">图2</p><p id="b37d" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">Fabric是一个包含多个节点的分布式系统。这些节点可以属于不同的实体。如图2所示，每个组织都有自己的节点集(为了简单起见，没有显示所有节点)。还有一种由订购者形成的公共共识服务。为了将Fabric部署到Kubernetes上，我们需要将所有组件转换成用于部署的pod，并使用名称空间来隔离组织。</p><p id="c3f5" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">在Kubernetes中，名称空间是一个重要的概念。它用于在多个用户之间划分集群资源。在Fabric的情况下，可以将组织映射到名称空间，以便它们拥有自己的专用资源。在这个映射之后，每个组织的对等体可以通过域名来区分。此外，我们可以通过设置网络策略来隔离不同的组织(不在本博客中讨论)。</p><p id="6377" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">如图2所示，假设在结构网络中有N个对等组织和M个订购者组织。我们在Kubernetes上是这样划分的:</p><p id="472a" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">如果是Fabric，我们将第N个对等组织命名为<em class="le"> orgN </em>。它在Kubernetes中对应的名称空间也叫做<em class="le"> orgN </em>。Fabric <em class="le"> orgN </em>的所有组件都将被放置到Kubernetes中的名称空间<em class="le"> orgN </em>中。每个组织的名称空间下有多个窗格。在Kubernetes中，pod是一个部署单元，它由一个或多个容器组成。我们可以将每个组织的织物容器捆绑到几个容器中。这些pod类型如下:</p><ul class=""><li id="379c" class="lf lg hu jr b js kn jw ko ka lh ke li ki lj km lk ll lm ln dt translated"><strong class="jr hv"> Peer Pod: </strong>包括Fabric peer，couchDB(可选)，代表组织的对等节点。每个组织可以有一个或多个对等pod。</li><li id="20f9" class="lf lg hu jr b js lo jw lp ka lq ke lr ki ls km lk ll lm ln dt translated"><strong class="jr hv"> CA Server Pod: </strong>组织的结构CA服务器节点。通常一个组织需要一个pod。</li><li id="f07b" class="lf lg hu jr b js lo jw lp ka lq ke lr ki ls km lk ll lm ln dt translated"><strong class="jr hv"> CLI Pod: </strong>(可选)为命令行工具提供操作组织节点的环境。Fabric的对等环境变量在此pod中配置。</li></ul><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="fe ff lt"><img src="../Images/c5c06f9f65eca7dba3fcbb5b4395b779.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HUUjVZ7oox7AKu0k.png"/></div></div></figure><p id="253c" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">图3</p><p id="2d04" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated"><strong class="jr hv"> B) </strong>结构中可能有一个或多个订购者。我们将第M个订购者组织的名称设置为<em class="le">orgorderm</em>。它在Kubernetes上对应的名称空间是<em class="le">orgorderm</em>。它有一个或多个窗格来运行订购者节点。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div class="fe ff lu"><img src="../Images/78ef6f1e95589501d2db69a7bb47f84f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/0*w7rSoan-9fFdGbnn.png"/></div></figure><p id="0dc7" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">图4</p><p id="e6a6" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated"><strong class="jr hv"> C) </strong>如果Kafka用于共识过程，我们可以把Kafka放入一个单独的命名空间。它仅用于运行和管理Zookeeper和Kafka容器。</p><p id="fbd2" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">总的来说，整个部署如下所示:</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="fe ff ks"><img src="../Images/66ee0a0926baafc3c0cfdd073249ee16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3gDQxe7Rpj2zZSJD.png"/></div></div></figure><p id="67d3" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">图5</p><h1 id="443e" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated"><strong class="ak">共享存储</strong></h1><p id="7cc0" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">在我们部署Fabric之前，我们需要准备它的组件的配置文件，比如对等体和订购者。这是一个非常复杂的过程，容易出错。幸运的是，我们创建了一个工具来自动生成这些配置文件。生成的文件存储在共享文件系统中，如NFS。</p><p id="327a" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">当我们稍后启动Fabric的pods时，我们将配置文件的不同子集挂载到pods中，以便它们具有特定于其所属组织的配置。</p><p id="41dc" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">在Kubernetes中，我们可以通过使用持久卷(PV)和持久卷声明(PVC)将文件或目录挂载到pod中。我们为结构中的每个组织创建PVs和PVC，以实现资源隔离。每个组织应该只能在NFS服务器中看到自己的目录。</p><p id="dd43" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">创建PV后，我们定义PVC，以便结构节点可以使用PV来访问相应的目录和文件。</p><p id="ae3d" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">以同级组织org1为例。首先，我们创建一个名称空间org1及其PV。PV被映射到NFS上的目录<em class="le">/opt/share/crypto-config/peer organizations/org 1</em>。其次，我们创建一个PVC来消耗PV。名称空间org1下的所有pod都使用相同的PVC。但是，我们只通过在pod配置文件中指定挂载路径来将必要的文件映射到每个pod中。</p><p id="8b5a" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">图6显示了pod和它们共享的NFS目录之间的关系。变量$PVC表示PVC挂载点，在本例中是<em class="le">/opt/share/crypto-config/peer organizations/org 1</em>。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="fe ff ks"><img src="../Images/a738724a91849f916a02f1f6e86de3e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UpuaCjyWOaeS7hcG.png"/></div></div></figure><p id="a66d" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">图6</p><h1 id="db04" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated"><strong class="ak">织物组件之间的通信</strong></h1><p id="4bf0" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">当所有Fabric的组件都放入Kubernetes的pod时，我们需要考虑这些pod之间的网络连接。Kubernetes中的每个pod都有一个内部IP地址，但是很难使用IP和端口在pod之间进行通信，因为IP地址对于pod来说是短暂的。当pod重新启动时，它的IP地址也会改变。因此，有必要在Kubernetes中为pods创建服务，以便它们可以通过服务名相互对话。服务的命名应该遵循以下原则，以显示它所绑定的pod信息:</p><p id="6fcc" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated"><strong class="jr hv"> 1) </strong>服务和pod的名称空间应该一致。<br/> <strong class="jr hv"> 2) </strong>服务的名称应该与pod内容器的id一致。</p><p id="4905" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">例如，组织org1的fabric peer0映射到命名空间org1下名为peer 0的pod。绑定到它的服务应该命名为peer0.org1，其中peer0是服务的名称，org1是服务的名称空间。其他pod可以通过服务名peer0.org1连接到org1的peer0，该服务名显示为peer0的主机名。</p><h1 id="acdc" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated"><strong class="ak">绕过链码沙箱</strong></h1><p id="0348" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">当Fabric中的一个对等体实例化一个链代码时，它创建一个Docker容器，链代码在其中运行。它调用来创建容器的Docker API端点是unix:///var/run/docker.sock。只要对等容器和链码容器由同一个Docker引擎管理，这种机制就能很好地工作。但是，在Kubernetes中，chaincode容器是由对等体创建的，没有通知Kubernetes。因此，链代码和对等容器不能相互连接，这导致实例化链代码时失败。</p><p id="dbb9" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">为了解决这个问题，我们需要在每个worker节点的Docker引擎中添加Kube_dns IP地址。这确保了chaincode容器可以通过使用Kube_dns服务正确解析对等体的主机名(服务名)。为此，在Docker引擎的配置文件中添加以下选项，在Ubuntu 14.04中通常是<em class="le"> /etc/default/docker </em>。如果该文件不存在，您可能需要创建它。请注意，在最新版本的docker和一些Linux发行版中，设置Docker守护进程选项的方式可能会有所不同。更多细节请参考Docker的文档。</p><p id="7110" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">在下面的示例中，10.0.0.10是kube_dns pod的IP地址。在您的环境中用正确的值替换它。</p><pre class="kt ku kv kw fq lv lw lx ly aw lz dt"><span id="a091" class="ma is hu lw b fv mb mc l md me">DOCKER_OPTS=<!-- -->"--dns=10.0.0.10 --dns=192.168.0.1 --dns-search \<br/>default.svc.cluster.local --dns-search \<br/>svc.cluster.local --dns-opt ndots:2 --dns-opt \<br/>timeout:2 --dns-opt attempts:2 "</span></pre><p id="5c52" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">到目前为止，我们已经说明了在Kubernetes上部署Fabric的关键点。在下一篇文章中，我们将描述部署的详细步骤。对于不能等待的人，请在Kubernetes  上下载我们的Fling“<a class="ae mf" href="https://labs.vmware.com/flings/blockchain-on-kubernetes" rel="noopener ugc nofollow" target="_blank"><strong class="jr hv">区块链”，感受一下它是如何工作的。它是一个自动化工具，允许您以最少的配置在Kubernetes上部署Fabric。Fling向您展示了如何在vSphere上部署Kubernetes。如果不使用vSphere，您可以为Kubernetes实例选择任何底层基础架构。只需跳过在vSphere上部署Kubernetes的步骤。请随时让我们知道您的想法。</strong></a></p><p id="a8c1" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated"><strong class="jr hv">继续第二部分:</strong></p><p id="e8cc" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated"><a class="ae mf" rel="noopener" href="/@zhanghenry/how-to-deploy-hyperledger-fabric-on-kubernetes-2-751abf44c807">https://medium . com/@ Zhang Henry/how-to-deploy-hyperledger-fabric-on-kubernetes-2-751 abf 44 c 807</a></p><p id="2c28" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated"><strong class="jr hv">相关帖子:</strong></p><p id="384b" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated"><a class="ae mf" href="http://www.think-foundry.com/hyperledger-fabric-deployment-using-helm-chart/" rel="noopener ugc nofollow" target="_blank"> <strong class="jr hv"> Hyperledger Fabric部署使用舵图</strong> </a></p><h1 id="8e3e" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated"><strong class="ak">关于作者:</strong></h1><p id="0c2d" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated"><strong class="jr hv">张卫彝:</strong>VMware中国首席架构师R &amp; D，<a class="ae mf" href="https://github.com/vmware/harbor" rel="noopener ugc nofollow" target="_blank">项目港</a>(<a class="ae mf" href="https://github.com/vmware/harbor" rel="noopener ugc nofollow" target="_blank"/>)——开源容器注册服务器创始人。亨利是《<strong class="jr hv">区块链技术指南</strong>》一书的合著者。他也是<a class="ae mf" href="https://github.com/hyperledger/cello" rel="noopener ugc nofollow" target="_blank"> Hyperledger大提琴项目</a>的贡献者。推特:@张海宁</p><p id="5d70" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated"><strong class="jr hv">陈璐珂:</strong>VMware中国研发中心工程师&amp;他拥有广州大学的硕士学位。他是Hyperledger Cello项目的维护者。</p></div></div>    
</body>
</html>