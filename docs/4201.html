<html>
<head>
<title>How to create library for Angular(2+) and publish to npm from scratch.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为Angular(2+)创建库并从头发布到npm。</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-create-library-in-angular-2-and-publish-to-npm-from-scratch-f2b1272d6266?source=collection_archive---------0-----------------------#2017-05-18">https://medium.com/hackernoon/how-to-create-library-in-angular-2-and-publish-to-npm-from-scratch-f2b1272d6266?source=collection_archive---------0-----------------------#2017-05-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/256e4ff818f1bf60705d26b6510d5a31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zRn7Rg-59WZHJNkI5VYTJA.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="http://streetwill.co/posts/240-on-the-table" rel="noopener ugc nofollow" target="_blank">http://streetwill.co/posts/240-on-the-table</a></figcaption></figure><p id="44ee" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我更新了make库以兼容AOT。您可以在“<em class="kf">让您的库兼容AOT”一节中查看更新</em> </p><p id="3ddc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这篇文章中，我为angular 2创建了一个库，但是你可以将这个方法应用到任何稍加修改的框架上。</p><p id="6fb0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你已经在前端领域工作了一段时间，你会发现有一天你必须做和以前一样的工作。我打赌你(过去)会复制你的旧代码并粘贴到新项目中(或者你会重新从头开始写，因为你的旧代码太乱了)。别担心，几乎每个人都这样做过，包括我。</p><p id="5dcb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有一天，我为一个项目创建了一个表格界面(带有分页功能)。但是在另一个项目中也有表格ui。我不得不复制并粘贴到新项目。问题是，当我在我的表中发现错误时，我必须修复每个项目中具有相同表的所有表组件。太可怕了，太无聊了。复制和粘贴有很多问题，我相信你已经知道了。</p><p id="d19c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以有一天我想，为什么我不做一张表发布到npm呢？这真的很棒，因为我只需要在一个地方改变我的代码，只需要在每个项目中更新我的表库(用<code class="eh kg kh ki kj b">npm update mylovelytable</code>)，我可以很容易地用<code class="eh kg kh ki kj b">npm install mylovelytable</code>安装它或改变表库代码，而不用担心它会破坏你的旧项目，因为它不会自动更新，除非你通过运行<code class="eh kg kh ki kj b">npm update mylovelytable</code>来更新它。</p><p id="99b8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">唯一的(也是最大的)问题是我不知道如何去做:/ </p><p id="eb3c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以这篇文章是我通过阅读许多文章，看其他库代码(例如@angular/material)试错，在angular中创建了库。</p><p id="e8a0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf">感谢</em> <a class="kk kl gr" href="https://medium.com/u/5ae4b2205cba?source=post_page-----f2b1272d6266--------------------------------" rel="noopener" target="_blank"> <em class="kf">奥利维尔</em></a><em class="kf"/><a class="ae jg" href="http://blog.mgechev.com/" rel="noopener ugc nofollow" target="_blank">明科</a>格切夫<em class="kf">的精彩帖子。我从他们那里学到了很多关于在Angular2中创建库知识。</em></p><p id="d229" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf">如果你已经理解了javascript中的模块系统，你可以跳到</em> <strong class="jj hv">让我们编写库代码</strong>部分。</p><p id="9730" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我会讲一些基本的话题。几乎每个库都是模块，所以我会先解释javascript中的模块系统，然后我会向你展示我如何在Angular2中创建库的例子。</p><p id="d3f4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我不是一个专业的糟糕的程序员，所以这篇文章可能有错误，所以如果你们发现了一些错误或改进。请在下面评论，我会给你买饼干的:D </p><p id="1ee1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里是这篇文章的完整源代码，<a class="ae jg" href="https://github.com/Elecweb/emptytext" rel="noopener ugc nofollow" target="_blank">https://github.com/Elecweb/emptytext</a></p><p id="7936" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">完蛋了。我们开始吧！</p><h1 id="db6b" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">javascript中的module是什么？</h1><figure class="ll lm ln lo fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lk"><img src="../Images/df5200d7b94385146be6790a04716f9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4IHvpQG7XQW2a0e4kWF-gw.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="https://unsplash.com/search/photos/lego?photo=jrW3-eLhWAw" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/search/photos/lego?photo=jrW3-eLhWAw</a></figcaption></figure><p id="b9b1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不管你要做什么库，模块是基础。如果您是前端开发人员，从过去编写jquery、css、html开始。当你试图包含一些库时，你下载它们的源代码或<code class="eh kg kh ki kj b">npm install</code>。</p><p id="838c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后您只需编写脚本标记来包含库文件。</p><pre class="ll lm ln lo fq lp kj lq lr aw ls dt"><span id="49d8" class="lt kn hu kj b fv lu lv l lw lx">&lt;script src=”path/to/jquery.js”&gt;&lt;/script&gt;</span></pre><p id="eb15" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">或者css</p><pre class="ll lm ln lo fq lp kj lq lr aw ls dt"><span id="59a4" class="lt kn hu kj b fv lu lv l lw lx">&lt;link rel=”stylesheet” type=”text/css” href=”path/to/theme.css”&gt;</span></pre><p id="4c02" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你包括一个或两个问题不大，但是10个或20个呢？(现在的图书馆很小，自成一体，做一件特定的工作就可以了)。如果我们可以在javascript文件中包含我们想要的库，并且只在一个地方写脚本标签，会不会更容易？你甚至可以在javascript文件中包含css！所以没有更多的标签脚本或链接。</p><p id="0ef1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">还有许多我上面提到的问题，例如:</p><ul class=""><li id="61d5" class="ly lz hu jj b jk jl jo jp js ma jw mb ka mc ke md me mf mg dt translated"><strong class="jj hv">顺序相关。你还记得错误告诉你没有来自其他库的jquery吗？甚至你已经包含了它，然后你意识到你需要在一些库之前包含它们。</strong></li><li id="3c91" class="ly lz hu jj b jk mh jo mi js mj jw mk ka ml ke md me mf mg dt translated"><strong class="jj hv">名字碰撞。在全局范围内声明每个变量不是一个好主意。你永远不知道你是否重写了声明的变量，这样你的应用程序就很容易崩溃。</strong></li><li id="c140" class="ly lz hu jj b jk mh jo mi js mj jw mk ka ml ke md me mf mg dt translated">可维护性和可重用性。很难维护和重用，因为没有模块，你可能需要在一个地方(或2 -3个地方)为许多工作编写代码。你永远不知道如果你删除或添加一些代码会破坏现有的功能。</li><li id="23f2" class="ly lz hu jj b jk mh jo mi js mj jw mk ka ml ke md me mf mg dt translated"><strong class="jj hv">便携。相信我，把你的node_module文件夹复制到另一个服务器上真的很伤你的感情。您可以使用package.json(具有与您的项目兼容的依赖版本)解决这个<code class="eh kg kh ki kj b">npm install</code>,或者复制模块捆绑器生成的4-5个文件。</strong></li><li id="7d97" class="ly lz hu jj b jk mh jo mi js mj jw mk ka ml ke md me mf mg dt translated">您需要指定路径。这可能没什么大不了的，但如果你不必这样做，会不会更好呢？</li></ul><p id="4918" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">模块可以帮助你解决这些问题。</p><h1 id="4c3b" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">javascript中的模块是什么样子的？</h1><p id="7a1f" class="pw-post-body-paragraph jh ji hu jj b jk mm jm jn jo mn jq jr js mo ju jv jw mp jy jz ka mq kc kd ke hn dt translated">模块在计算机科学中并不是什么新东西。在其他语言中有很长一段时间。不幸的是，Javascript没有包含它。</p><p id="5c03" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不管编程语言是什么？模块是独立的代码，完成一项特定的工作，而且做得很好。因为变量或函数不在全局范围内，您可以显式地导出或隐藏这些变量或函数，所以您可以更有把握地包含、删除或更改它们。</p><p id="d83f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可能习惯于在一个或多个文件中写所有的东西，但是变量或函数可以跨文件访问。这很糟糕，你可能在不知道的情况下弄乱了来自<code class="eh kg kh ki kj b">script1.js</code>的变量(比如改变值),你的项目会在没有任何编译错误的情况下中断。你能做的就是挠头，埋怨这个世界为什么这么残酷。</p><p id="b084" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当应用程序长大后，你代码会变得一团糟，因为它做了很多工作。当您的客户希望您更改旧代码或用户发现一些错误时，这对您来说是一场噩梦。这可以让你花一些(或很多)时间来弄清楚你的代码是做什么的。(如果你从来没有发现这个问题，相信我这真的真的是噩梦)。</p><p id="b3c8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们看看模块在javascript中是如何工作的。我先解释一下模块格式。</p><h1 id="1402" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">Javascript中的模块格式</h1><p id="338c" class="pw-post-body-paragraph jh ji hu jj b jk mm jm jn jo mn jq jr js mo ju jv jw mp jy jz ka mq kc kd ke hn dt translated">模块格式是我们可以用来定义模块的语法。</p><p id="02d2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在ES2015之前，JavaScript没有任何官方语法来定义模块，因此聪明的开发人员尝试为模块定义语法</p><p id="2175" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">javascript中有许多模块格式。例如:</p><ul class=""><li id="3cdb" class="ly lz hu jj b jk jl jo jp js ma jw mb ka mc ke md me mf mg dt translated">Commonjs</li><li id="72f3" class="ly lz hu jj b jk mh jo mi js mj jw mk ka ml ke md me mf mg dt translated">超微半导体公司</li><li id="4097" class="ly lz hu jj b jk mh jo mi js mj jw mk ka ml ke md me mf mg dt translated">UMD</li><li id="1465" class="ly lz hu jj b jk mh jo mi js mj jw mk ka ml ke md me mf mg dt translated">ES2015</li></ul><p id="0953" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">它们只是格式。它做同样的工作，使你的代码模块化。</p><p id="9cbb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我给你看<strong class="jj hv">常见的例子。</strong></p><pre class="ll lm ln lo fq lp kj lq lr aw ls dt"><span id="a082" class="lt kn hu kj b fv lu lv l lw lx">//idoaboutmathcalculate.js</span><span id="f4a4" class="lt kn hu kj b fv mr lv l lw lx">let indexjscannotseeme = "great!"; <br/>let plusTwoNumber= (a,b)=&gt;{ <br/>   return a+b;<br/>}  <br/>module.exports = plusTwoNumber;</span><span id="8c71" class="lt kn hu kj b fv mr lv l lw lx">//index.js<br/>const plus2num = require('./idoaboutmathcalculate');<br/>console.log(plus2num(2,5)); //7</span></pre><p id="76e8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在上面的例子中，有两个filles。<em class="kf">idoauthmathcalculate . js</em>和<em class="kf"> index.js. </em>如您所见，您可以包含来自其他js的js文件。</p><p id="de9f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您可以选择要隐藏或向外部公开的变量。<em class="kf"> index.js </em>只能看到<code class="eh kg kh ki kj b">plusTwoNumber</code>函数，因为<em class="kf">idoauthmathcalculate . js</em>只公开它。</p><p id="7dfb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可以把你的代码分成许多文件，并很容易地包含、删除和修改。</p><p id="186e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于ES2015，它使用<code class="eh kg kh ki kj b">import</code>和<code class="eh kg kh ki kj b">export</code>。例如:</p><pre class="ll lm ln lo fq lp kj lq lr aw ls dt"><span id="74ac" class="lt kn hu kj b fv lu lv l lw lx">//idoaboutmathcalculate.js</span><span id="de8f" class="lt kn hu kj b fv mr lv l lw lx">export default const plusTwoNumber= (a,b)=&gt;{ <br/>   return a+b;<br/>}</span><span id="f9ab" class="lt kn hu kj b fv mr lv l lw lx">//index.js<br/>import plus2num from './idoaboutmathcalculate';<br/>console.log(plus2num(2,5)); //7</span></pre><p id="2017" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我不会涵盖所有的模块格式。有很多关于他们的帖子对此做了很好的解释。</p><div class="ms mt fm fo mu mv"><a href="https://medium.freecodecamp.com/javascript-modules-a-beginner-s-guide-783f7d7a5fcc" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab ej"><div class="mx ab my cl cj mz"><h2 class="bd hv fv z el na eo ep nb er et ht dt translated">JavaScript模块:初学者指南</h2><div class="nc l"><h3 class="bd b fv z el na eo ep nb er et ek translated">如果你是JavaScript的新手，像“模块捆绑器与模块加载器”、“Webpack与Browserify”和“AMD…</h3></div><div class="nd l"><p class="bd b gc z el na eo ep nb er et ek translated">medium.freecodecamp.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj ja mv"/></div></div></a></div><div class="ms mt fm fo mu mv"><a href="http://www.jvandemo.com/a-10-minute-primer-to-javascript-modules-module-formats-module-loaders-and-module-bundlers/" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab ej"><div class="mx ab my cl cj mz"><h2 class="bd hv fv z el na eo ep nb er et ht dt translated">JavaScript模块、模块格式、模块加载器和模块打包器的10分钟初级读本</h2><div class="nc l"><h3 class="bd b fv z el na eo ep nb er et ek translated">现代JavaScript开发可能势不可挡。当你在做一个项目时，你可能想知道为什么所有的现代…</h3></div><div class="nd l"><p class="bd b gc z el na eo ep nb er et ek translated">www.jvandemo.com</p></div></div><div class="ne l"><div class="nk l ng nh ni ne nj ja mv"/></div></div></a></div><p id="5644" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我建议你坚持使用<strong class="jj hv"> ES2015 </strong>，因为它是模块标准(但目前还不支持)。</p><p id="448d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">无论模块格式是什么。它们的相同目的只是让模块在Javascript中发生。</p><p id="5242" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是仍然有更多的事情要做。</p><h1 id="358d" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">什么是模块加载器、模块捆绑器和模块解析？</h1><p id="c1e1" class="pw-post-body-paragraph jh ji hu jj b jk mm jm jn jo mn jq jr js mo ju jv jw mp jy jz ka mq kc kd ke hn dt translated">你有模块格式但是你仍然不能使用模块。为什么？不幸的是，现在的浏览器还不支持它<strong class="jj hv">，但它会的！</strong></p><p id="0a47" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们还需要两样东西来使它工作，模块捆绑器(或模块加载器)和模块解析。</p><p id="6285" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我将首先详细介绍模块装入器和模块捆绑器。</p><h1 id="8924" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated"><strong class="ak">模块加载器</strong></h1><p id="2033" class="pw-post-body-paragraph jh ji hu jj b jk mm jm jn jo mn jq jr js mo ju jv jw mp jy jz ka mq kc kd ke hn dt translated">它有什么作用？它加载您条目文件和对另一个文件的依赖。</p><p id="3cd2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我将展示一个使用SystemJS的例子，它是模块化加载器之一。</p><p id="381e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf"> app.js </em></p><pre class="ll lm ln lo fq lp kj lq lr aw ls dt"><span id="efc2" class="lt kn hu kj b fv lu lv l lw lx">SystemJS.import('./main.js').then((m)=&gt;{</span><span id="e048" class="lt kn hu kj b fv mr lv l lw lx">   console.log(m.test);</span><span id="2bb7" class="lt kn hu kj b fv mr lv l lw lx">});</span></pre><p id="f7fd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf"> main.js </em></p><pre class="ll lm ln lo fq lp kj lq lr aw ls dt"><span id="e5ad" class="lt kn hu kj b fv lu lv l lw lx">var a = require(‘./sub.js’);<br/>module.exports = {<br/>    test:a<br/>};</span></pre><p id="f406" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf">次js </em></p><pre class="ll lm ln lo fq lp kj lq lr aw ls dt"><span id="4ff9" class="lt kn hu kj b fv lu lv l lw lx">module.exports = "Hello world";</span></pre><p id="cd02" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">SystemJS会按照正确的顺序(app.js → main.js →sub.js)为你加载所有文件。它会在控制台上显示“你好，世界”。</p><h1 id="f047" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated"><strong class="ak">模块捆绑器</strong></h1><p id="e984" class="pw-post-body-paragraph jh ji hu jj b jk mm jm jn jo mn jq jr js mo ju jv jw mp jy jz ka mq kc kd ke hn dt translated">它将通过构建一个依赖关系图来捆绑您的条目文件和对另一个文件(模块)的依赖关系，并使用该图来生成一个优化的捆绑包，其中脚本将以正确的顺序加载。简而言之，当你把你的代码分成多个文件时，模块捆绑器会把你的多个文件捆绑成一个文件。</p><p id="ae91" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我将在<strong class="jj hv">让我们为捆绑器</strong>部分设置配置中展示使用模块捆绑器(带汇总)的示例。</p><p id="2f93" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">模块捆绑器和模块加载器的工作相似但不相同，它们将模块文件加载到浏览器中。</p><p id="ba8b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不同的是<strong class="jj hv">模块加载器</strong>在运行时工作，而<strong class="jj hv">模块打包器</strong>在编译时工作。<strong class="jj hv">模块加载器</strong>一次加载每个文件，而模块捆绑器会在编译时将所有模块文件捆绑成一个文件，浏览器只需加载捆绑的文件。</p><p id="0879" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">模块加载器的例子有:</strong></p><p id="ca62" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><a class="ae jg" href="http://requirejs.org/" rel="noopener ugc nofollow" target="_blank">require js</a>:AMD格式模块的加载器。</p><p id="7302" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><a class="ae jg" href="https://github.com/systemjs/systemjs" rel="noopener ugc nofollow" target="_blank">system js</a>:UMD common js AMD的模块加载器。</p><p id="0e53" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">模块捆绑器的例子有:</strong></p><p id="7ab2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><a class="ae jg" href="http://browserify.org/" rel="noopener ugc nofollow" target="_blank">浏览确认</a>:common js模块的缓冲器</p><p id="e73d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><a class="ae jg" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank">web pack</a>:AMD、CommonJS、ES6模块捆绑器</p><p id="6bb6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><a class="ae jg" href="https://rollupjs.org/" rel="noopener ugc nofollow" target="_blank">roll up . js</a>:AMD、UMD、CommonJS、ES6模块捆绑器</p><p id="675a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">那么我应该用什么呢？模块捆绑器还是模块加载器？嗯，这取决于你和情况。但是在这篇文章中，我将使用模块捆绑器，因为模块捆绑器将只发送一个文件，所以你的浏览器只需要请求一个文件。</p><p id="bb33" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">模块中的最后一个主题，<em class="kf">模块解析。</em></p><h1 id="4964" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">模块分辨率</h1><figure class="ll lm ln lo fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nl"><img src="../Images/71cd0a2d41111cbbd85d669a4292df2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZHvJkaC_ENjWeOlHa3sA0Q.jpeg"/></div></div></figure><p id="0d3e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">看看这个例子:</p><pre class="ll lm ln lo fq lp kj lq lr aw ls dt"><span id="69f2" class="lt kn hu kj b fv lu lv l lw lx">import { jquery } from ‘jquery’;</span></pre><p id="0529" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">模块解析告诉模块捆绑器在哪里看你导入的文件。这取决于您的设置和模块捆绑器。例如，如果您不提供路径，webpack将在<a class="ae jg" href="https://webpack.js.org/configuration/resolve/#resolve-modules" rel="noopener ugc nofollow" target="_blank"> resolve.modules </a>中指定的目录中查找文件。它的默认设置是<em class="kf"> node_modules </em>文件夹<em class="kf">。</em></p><p id="5a57" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您也可以使用相对路径和绝对路径。</p><pre class="ll lm ln lo fq lp kj lq lr aw ls dt"><span id="8bc0" class="lt kn hu kj b fv lu lv l lw lx">import plus2num from './idoaboutmathcalculate';<br/>//or<br/>import plus2num from 'absolute/path/idoaboutmathcalculate';</span></pre><p id="7e01" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可以注意到没有文件扩展名。默认为<code class="eh kg kh ki kj b">.js</code>，可以在模块捆绑器配置文件中设置默认文件扩展名。</p><h1 id="f492" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">让我们写一些真正的代码吧！</h1><p id="18f0" class="pw-post-body-paragraph jh ji hu jj b jk mm jm jn jo mn jq jr js mo ju jv jw mp jy jz ka mq kc kd ke hn dt translated"><em class="kf">好的，我已经理解了一些关于模块的基本概念，但是它与创建库有什么关系呢？</em></p><p id="8953" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">无论你做什么库，都是关于模块的——独立的功能，可重用，只做一件事，而且做得很好。如果你能创建你的模块，把你的代码推到npm或者别的什么上并不难。</p><p id="bcb4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你还在吗？很好。让我们最终创建我们可爱的图书馆。</p><p id="04d6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我要做的库叫做“空文本”。这个库包括<code class="eh kg kh ki kj b">emptytext</code>指令，用于在元素或组件中没有文本时显示“empty”，用于改变消息(默认为“empty”)。首先让我们设置项目和一些配置。</p><p id="a88c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是文件夹结构。</p><pre class="ll lm ln lo fq lp kj lq lr aw ls dt"><span id="4398" class="lt kn hu kj b fv lu lv l lw lx">/lib — your source code<br/>   empty-text.directive.ts<br/>   empty-text.module.ts<br/>   empty-text.service.ts<br/>   empty-text.ts</span><span id="8f32" class="lt kn hu kj b fv mr lv l lw lx">/tools — node files for utility work (I’ll explain later)<br/>   cleanup.js<br/>   copy-package.js<br/>   removecode.js</span><span id="11d6" class="lt kn hu kj b fv mr lv l lw lx">/dist — your module that user will get when ‘npm install’</span><span id="1620" class="lt kn hu kj b fv mr lv l lw lx">package.json<br/>rollup.config.esm.js<br/>rollup.config.umd.js<br/>tsconfig.json</span></pre><p id="3869" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">对于本帖中的代码，你可以在这里</strong> 找到 <a class="ae jg" href="https://github.com/Elecweb/emptytext/tree/master" rel="noopener ugc nofollow" target="_blank"> <strong class="jj hv"/></a></p><p id="4b09" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">首先，让我们创建一个package.json文件，并按照提示进行操作。</p><pre class="ll lm ln lo fq lp kj lq lr aw ls dt"><span id="634f" class="lt kn hu kj b fv lu lv l lw lx">npm init</span></pre><p id="2884" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这篇文章中，我将使用typescript编写代码(它不要求)。</p><pre class="ll lm ln lo fq lp kj lq lr aw ls dt"><span id="3b05" class="lt kn hu kj b fv lu lv l lw lx">npm install -g typescript</span></pre><p id="d8a0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">并为typescript编译器设置一些配置。我创建了名为<code class="eh kg kh ki kj b">tsconfig.json</code>的配置文件。</p><pre class="ll lm ln lo fq lp kj lq lr aw ls dt"><span id="95f3" class="lt kn hu kj b fv lu lv l lw lx">{<br/>   “compilerOptions”: {<br/>      “target”: “es5”,<br/>      “module”: “es2015”,<br/>      “sourceMap”:   true,<br/>      “moduleResolution”: “node”,<br/>      “emitDecoratorMetadata”: true,<br/>      “experimentalDecorators”: true,<br/>      “declaration”: true,<br/>      “outDir”: “./dist”,<br/>      “lib”: [“es2015”, “dom”]<br/>   },<br/>   “files”: [“./lib/empty-text.ts”]</span><span id="4026" class="lt kn hu kj b fv mr lv l lw lx">}</span></pre><ul class=""><li id="7818" class="ly lz hu jj b jk jl jo jp js ma jw mb ka mc ke md me mf mg dt translated"><code class="eh kg kh ki kj b">target</code>:编译代码的javascript(ECMAScript)版本。</li><li id="7a65" class="ly lz hu jj b jk mh jo mi js mj jw mk ka ml ke md me mf mg dt translated"><code class="eh kg kh ki kj b">module</code>:编译代码的模块格式。有几个选项，例如，UMD，ES2015，AMD。</li><li id="d440" class="ly lz hu jj b jk mh jo mi js mj jw mk ka ml ke md me mf mg dt translated"><code class="eh kg kh ki kj b">sourcemap</code>:告诉typescript编译器生成<a class="ae jg" href="https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/" rel="noopener ugc nofollow" target="_blank"> sourcemap </a>。</li><li id="9be9" class="ly lz hu jj b jk mh jo mi js mj jw mk ka ml ke md me mf mg dt translated"><code class="eh kg kh ki kj b">module resolution</code>:模块是如何被解析的(从<code class="eh kg kh ki kj b">import</code>的什么地方看你的依赖文件)，有两种方式，节点或者经典。<a class="ae jg" href="https://www.typescriptlang.org/docs/handbook/module-resolution.html" rel="noopener ugc nofollow" target="_blank">了解更多详情</a>。</li><li id="6c73" class="ly lz hu jj b jk mh jo mi js mj jw mk ka ml ke md me mf mg dt translated"><code class="eh kg kh ki kj b">emitDecoratorMetadata</code>和<code class="eh kg kh ki kj b">experimentalDecorators</code>:angular需要设置为true(他们用，比如@Component和@Directive。</li><li id="104b" class="ly lz hu jj b jk mh jo mi js mj jw mk ka ml ke md me mf mg dt translated"><code class="eh kg kh ki kj b">declaration</code>:生成对应的. d.ts文件(<a class="ae jg" href="https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html" rel="noopener ugc nofollow" target="_blank">定义文件</a>)。</li><li id="4df8" class="ly lz hu jj b jk mh jo mi js mj jw mk ka ml ke md me mf mg dt translated"><code class="eh kg kh ki kj b">lib</code>:内置API声明(定义文件)，可以选择包含在项目中。</li><li id="6e83" class="ly lz hu jj b jk mh jo mi js mj jw mk ka ml ke md me mf mg dt translated"><code class="eh kg kh ki kj b">files</code>:你想用<code class="eh kg kh ki kj b">tsc</code>编译你的类型脚本文件的地方</li></ul><p id="3287" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我可以用</p><pre class="ll lm ln lo fq lp kj lq lr aw ls dt"><span id="61d2" class="lt kn hu kj b fv lu lv l lw lx">tsc -p tsconfig.json // or just tsc</span></pre><p id="62f6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这个库中，我需要“角/芯”</p><pre class="ll lm ln lo fq lp kj lq lr aw ls dt"><span id="21bf" class="lt kn hu kj b fv lu lv l lw lx">npm install @angular/core --save</span></pre><p id="01f6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在不要太担心如何编译我们的代码，我稍后会解释。</p><h1 id="97dd" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">让我们编写库代码</h1><p id="3069" class="pw-post-body-paragraph jh ji hu jj b jk mm jm jn jo mn jq jr js mo ju jv jw mp jy jz ka mq kc kd ke hn dt translated">我不会解释太多代码，它很容易理解，不是这篇文章的重点。</p><p id="b7ae" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是指令。<code class="eh kg kh ki kj b">lib/empty-text.directive.ts</code></p><figure class="ll lm ln lo fq iv"><div class="bz el l di"><div class="nm nn l"/></div></figure><p id="a5ef" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里是设置消息的服务，<code class="eh kg kh ki kj b">lib/empty-text.service.ts</code></p><figure class="ll lm ln lo fq iv"><div class="bz el l di"><div class="nm nn l"/></div></figure><p id="8f12" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是用户要导入的模块。<code class="eh kg kh ki kj b">lib/empty-text.directive.ts</code></p><figure class="ll lm ln lo fq iv"><div class="bz el l di"><div class="nm nn l"/></div></figure><p id="ad5b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">创建条目文件以导出库中所有其他文件，<code class="eh kg kh ki kj b">empty-text.ts</code></p><pre class="ll lm ln lo fq lp kj lq lr aw ls dt"><span id="8ed5" class="lt kn hu kj b fv lu lv l lw lx">export * from "./empty-text.module";</span><span id="c8bc" class="lt kn hu kj b fv mr lv l lw lx">export * from "./empty-text.directive";</span><span id="b0ea" class="lt kn hu kj b fv mr lv l lw lx">export * from "./empty-text.service";</span></pre><p id="f69d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">就是这样。这个库很小，只有4个文件。</p><h1 id="7518" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">让我们为bundler设置配置</h1><p id="7731" class="pw-post-body-paragraph jh ji hu jj b jk mm jm jn jo mn jq jr js mo ju jv jw mp jy jz ka mq kc kd ke hn dt translated">您需要将文件中的代码捆绑到一个文件中，该文件的格式是UMD(UMD是<strong class="jj hv">通用模块定义，</strong>它可以用于任何模块格式)和ES2015。</p><p id="b539" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们提供ES2015的原因是，如果用户使用Rollup或Webpack，他们可以从<a class="ae jg" href="https://webpack.js.org/guides/tree-shaking/" rel="noopener ugc nofollow" target="_blank">树摇动</a>中获益。</p><p id="d830" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">没有关于你应该如何在Angular中为用户提供代码的文档(如果有人知道，请在下面评论)。</p><p id="77cc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以我看着 <code class="eh kg kh ki kj b"><em class="kf">@angular/material</em></code> <em class="kf">他们如何建立他们的文件，并在我的库中使用他们的格式。</em></p><p id="d02a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">首先，你需要模块捆绑器。可以是Webpack，Rollup什么的。在这篇文章中，我将使用Rollup。</p><pre class="ll lm ln lo fq lp kj lq lr aw ls dt"><span id="584c" class="lt kn hu kj b fv lu lv l lw lx">npm install --global rollup</span></pre><p id="e036" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你需要捆绑两种格式的代码，UMD和ES2015，所以有两个配置文件汇总。</p><p id="0c63" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不同的是<code class="eh kg kh ki kj b">format</code>属性分别为UMD和ES2015设置了<code class="eh kg kh ki kj b">umd</code>和<code class="eh kg kh ki kj b">es</code>。</p><p id="ed73" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">由于Rollup的配置文件是普通的javascript文件，您只能导入和更改<code class="eh kg kh ki kj b">format</code>属性，因此您不需要手动复制其他配置属性。</p><p id="49de" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我将首先为<code class="eh kg kh ki kj b">umd</code>设置配置文件。</p><p id="408b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是配置文件，<code class="eh kg kh ki kj b">rollup.config.umd.js</code></p><figure class="ll lm ln lo fq iv"><div class="bz el l di"><div class="nm nn l"/></div></figure><ul class=""><li id="bd79" class="ly lz hu jj b jk jl jo jp js ma jw mb ka mc ke md me mf mg dt translated"><code class="eh kg kh ki kj b">input</code>:您要捆绑的条目文件的位置。</li><li id="fd0d" class="ly lz hu jj b jk mh jo mi js mj jw mk ka ml ke md me mf mg dt translated"><code class="eh kg kh ki kj b">output</code>:捆绑文件配置，包含以下内容:</li><li id="9646" class="ly lz hu jj b jk mh jo mi js mj jw mk ka ml ke md me mf mg dt translated"><code class="eh kg kh ki kj b">output.format</code>:您捆绑文件的模块格式。</li><li id="c404" class="ly lz hu jj b jk mh jo mi js mj jw mk ka ml ke md me mf mg dt translated"><code class="eh kg kh ki kj b">output.name</code>:变量名，代表你的<code class="eh kg kh ki kj b">iife</code> / <code class="eh kg kh ki kj b">umd</code>包。</li><li id="e05d" class="ly lz hu jj b jk mh jo mi js mj jw mk ka ml ke md me mf mg dt translated"><code class="eh kg kh ki kj b">output.sourcemap</code>:设置为true，这样汇总将提供sourcemap。(在这种情况下没有必要，因为我不会为了简单而缩减代码。)</li><li id="1b30" class="ly lz hu jj b jk mh jo mi js mj jw mk ka ml ke md me mf mg dt translated"><code class="eh kg kh ki kj b">output.file</code>:要写入的文件。</li><li id="d14b" class="ly lz hu jj b jk mh jo mi js mj jw mk ka ml ke md me mf mg dt translated"><code class="eh kg kh ki kj b">external</code>:排除捆绑代码中的依赖代码，在这种情况下，我假设使用这个库的用户已经安装了<code class="eh kg kh ki kj b">@angular/core</code></li><li id="1e9a" class="ly lz hu jj b jk mh jo mi js mj jw mk ka ml ke md me mf mg dt translated"><code class="eh kg kh ki kj b">onwarn</code>:拦截警告信息的功能。我忽略了两个不必要的警告(<code class="eh kg kh ki kj b">THIS_IS_UNDEFINED</code>和<code class="eh kg kh ki kj b">MISSING_GLOBAL_NAME</code>)。</li><li id="5b6f" class="ly lz hu jj b jk mh jo mi js mj jw mk ka ml ke md me mf mg dt translated"><code class="eh kg kh ki kj b">plugins</code>:汇总中使用的插件。接下来我将解释我使用什么插件以及为什么</li></ul><p id="bfd4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们需要在Rollup中使用插件来制造魔法快乐。</p><ul class=""><li id="b50c" class="ly lz hu jj b jk jl jo jp js ma jw mb ka mc ke md me mf mg dt translated">汇总插件节点解析</li><li id="1fdb" class="ly lz hu jj b jk mh jo mi js mj jw mk ka ml ke md me mf mg dt translated">汇总-插件-常见</li><li id="d19d" class="ly lz hu jj b jk mh jo mi js mj jw mk ka ml ke md me mf mg dt translated">汇总-插件-角度</li><li id="606b" class="ly lz hu jj b jk mh jo mi js mj jw mk ka ml ke md me mf mg dt translated">汇总插件类型脚本</li><li id="3c85" class="ly lz hu jj b jk mh jo mi js mj jw mk ka ml ke md me mf mg dt translated">节点-sass</li></ul><p id="88e5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我将解释这些插件是做什么。但首先，让我们安装这些插件。</p><pre class="ll lm ln lo fq lp kj lq lr aw ls dt"><span id="b7e9" class="lt kn hu kj b fv lu lv l lw lx">npm install --save-dev rollup-plugin-node-resolve <!-- -->rollup-plugin-commonjs rollup-plugin-angular rollup-plugin-typescript node-sass</span></pre><p id="e6a8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们看看<code class="eh kg kh ki kj b">plugins</code>一节</p><p id="0c5e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf">摘自</em> <code class="eh kg kh ki kj b">rollup.config.umd.js</code></p><figure class="ll lm ln lo fq iv"><div class="bz el l di"><div class="nm nn l"/></div></figure><ul class=""><li id="0948" class="ly lz hu jj b jk jl jo jp js ma jw mb ka mc ke md me mf mg dt translated"><code class="eh kg kh ki kj b">angular</code>:如果你没有为组件内联模板和样式，你需要<code class="eh kg kh ki kj b">rollup-plugin-angular</code>来解析要包含在组件中的外部模板和样式。</li><li id="3767" class="ly lz hu jj b jk mh jo mi js mj jw mk ka ml ke md me mf mg dt translated"><code class="eh kg kh ki kj b">node-sass</code>:在组件中包含样式之前，将sass解析为css。我们在<code class="eh kg kh ki kj b">angular</code>插件中使用它</li></ul><pre class="ll lm ln lo fq lp kj lq lr aw ls dt"><span id="2c0b" class="lt kn hu kj b fv lu lv l lw lx">if(scss){</span><span id="f1da" class="lt kn hu kj b fv mr lv l lw lx">   css = sass.renderSync({ data: scss }).css.toString();</span><span id="0cee" class="lt kn hu kj b fv mr lv l lw lx">}else{</span><span id="f60b" class="lt kn hu kj b fv mr lv l lw lx">   css = '';</span><span id="4935" class="lt kn hu kj b fv mr lv l lw lx">}</span><span id="2956" class="lt kn hu kj b fv mr lv l lw lx">return css;</span></pre><p id="8a93" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf">示例中的库没有任何组件，但我想展示如何为提供组件的库进行配置。如果你的库不提供组件，你可以跳过</em> <code class="eh kg kh ki kj b">rollup-plugin-angular</code>和<code class="eh kg kh ki kj b">node-sass</code>配置部分。</p><ul class=""><li id="442c" class="ly lz hu jj b jk jl jo jp js ma jw mb ka mc ke md me mf mg dt translated"><code class="eh kg kh ki kj b">typescript</code>:将类型脚本移植到普通javascript。</li><li id="6b48" class="ly lz hu jj b jk mh jo mi js mj jw mk ka ml ke md me mf mg dt translated"><code class="eh kg kh ki kj b">resolve</code>:使用<a class="ae jg" href="https://nodejs.org/api/modules.html#modules_all_together" rel="noopener ugc nofollow" target="_blank">节点解析算法</a>定位模块。</li><li id="8fe4" class="ly lz hu jj b jk mh jo mi js mj jw mk ka ml ke md me mf mg dt translated"><code class="eh kg kh ki kj b">commonjs</code> : Rollup只能理解模块格式ES2015，但是你可能安装的一些库是commonjs，所以你需要这个插件以便Rollup能理解commonjs模块。</li></ul><p id="52d7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于ES2015模块配置文件，我们不必手动复制。只需从<code class="eh kg kh ki kj b">rollup.config.umd.js</code>导入配置并覆盖一些配置。</p><pre class="ll lm ln lo fq lp kj lq lr aw ls dt"><span id="bad4" class="lt kn hu kj b fv lu lv l lw lx">import config from './rollup.config.umd.js';</span><span id="de63" class="lt kn hu kj b fv mr lv l lw lx">import {nameLibrary,PATH_DIST} from './config-library.js'</span><span id="ba6f" class="lt kn hu kj b fv mr lv l lw lx">config.output.format = "es";<br/>config.output.file = PATH_DIST+nameLibrary+".esm.js"</span><span id="0e5b" class="lt kn hu kj b fv mr lv l lw lx">export default config;</span></pre><p id="71f5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我将<code class="eh kg kh ki kj b">output.format</code>替换为“es ”,将<code class="eh kg kh ki kj b">output.file</code>替换为捆绑文件的名称。</p><p id="088b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可能已经注意到了，我从<code class="eh kg kh ki kj b">config-library.js</code>导入了一些变量，这些变量是为捆绑文件的名称和目标路径定义的，这样我们就不必复制它了。</p><p id="0388" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf"> config-library.js </em></p><pre class="ll lm ln lo fq lp kj lq lr aw ls dt"><span id="f938" class="lt kn hu kj b fv lu lv l lw lx">export const nameLibrary = "empty-text";</span><span id="f01b" class="lt kn hu kj b fv mr lv l lw lx">export const PATH_SRC = "lib/";</span><span id="2cf3" class="lt kn hu kj b fv mr lv l lw lx">export const PATH_DIST = "dist/";</span></pre><p id="f682" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，您可以使用以下命令捆绑已定义的配置:</p><pre class="ll lm ln lo fq lp kj lq lr aw ls dt"><span id="c70c" class="lt kn hu kj b fv lu lv l lw lx">rollup -c rollup.config.umd.js //umd<br/>rollup -c rollup.config.esm.js //es2015</span></pre><h1 id="3897" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">为用户清除不必要的文件。</h1><p id="e6d3" class="pw-post-body-paragraph jh ji hu jj b jk mm jm jn jo mn jq jr js mo ju jv jw mp jy jz ka mq kc kd ke hn dt translated">当我们打包时，会有一些不必要的文件。ts文件(因为我们将为每种模块格式提供一个捆绑javascript文件)</p><p id="b0d5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我将使用node来处理删除不必要的文件，并将<code class="eh kg kh ki kj b">package.json</code>文件复制并粘贴到<code class="eh kg kh ki kj b">dist</code>文件夹中(我将很快解释原因)。</p><p id="5245" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在<code class="eh kg kh ki kj b">tools</code>文件夹中，我创建了<code class="eh kg kh ki kj b">copy-package.js</code>，用于将根文件夹中的<code class="eh kg kh ki kj b">package.json</code>复制到<code class="eh kg kh ki kj b">dist</code>文件夹中。</p><pre class="ll lm ln lo fq lp kj lq lr aw ls dt"><span id="3f65" class="lt kn hu kj b fv lu lv l lw lx">const fs = require('fs');</span><span id="109c" class="lt kn hu kj b fv mr lv l lw lx">let resizable = fs.readFileSync('package.json').toString();</span><span id="b96b" class="lt kn hu kj b fv mr lv l lw lx">fs.writeFileSync('dist/package.json', resizable);</span></pre><p id="e8e7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">和<code class="eh kg kh ki kj b">cleanup-package.js</code>，用于删除<code class="eh kg kh ki kj b">script</code>部分和<code class="eh kg kh ki kj b">devDependencies</code>。</p><pre class="ll lm ln lo fq lp kj lq lr aw ls dt"><span id="2242" class="lt kn hu kj b fv lu lv l lw lx">const fs = require('fs');</span><span id="8c48" class="lt kn hu kj b fv mr lv l lw lx">const packageJson = JSON.parse(fs.readFileSync('./dist/package.json').toString());</span><span id="85da" class="lt kn hu kj b fv mr lv l lw lx">delete packageJson.devDependencies;</span><span id="3ee4" class="lt kn hu kj b fv mr lv l lw lx">delete packageJson.scripts;</span><span id="e653" class="lt kn hu kj b fv mr lv l lw lx">fs.writeFileSync('./dist/package.json', JSON.stringify(packageJson, null, 2));</span></pre><p id="75ae" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最后一个文件是<code class="eh kg kh ki kj b">removecode.js</code>，用于删除从Typescript编译器发出的不必要的javscript文件。我们只是希望IDE的定义类型脚本(例如，自动完成)提供给用户。</p><pre class="ll lm ln lo fq lp kj lq lr aw ls dt"><span id="47d3" class="lt kn hu kj b fv lu lv l lw lx">const del = require('del');</span><span id="482e" class="lt kn hu kj b fv mr lv l lw lx">del(['dist/!(*.umd.js|*.esm.js|*.d.ts|*.umd.js.map|*.esm.js.map)']).then(paths =&gt; {</span><span id="2786" class="lt kn hu kj b fv mr lv l lw lx">    console.log('Files and folders that would be deleted:\n', paths.join('\n'));</span><span id="ae61" class="lt kn hu kj b fv mr lv l lw lx">});</span></pre><p id="92fe" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">它会删除除捆绑文件(*.umd.js，*.esm.js)、definition typscript ( *.d.ts)和sourcemap ( *.umd.js.map，*.esm.js.map)之外的所有文件。</p><p id="d533" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我使用<code class="eh kg kh ki kj b">del</code>库来删除文件。</p><p id="d7fc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">从npm安装<code class="eh kg kh ki kj b">del</code>。</p><pre class="ll lm ln lo fq lp kj lq lr aw ls dt"><span id="4be0" class="lt kn hu kj b fv lu lv l lw lx">npm install --save-dev del</span></pre><p id="48fb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，您可以使用<code class="eh kg kh ki kj b">node</code>命令运行我们在本节中定义的脚本。例如，如果您想将package.json复制并粘贴到<code class="eh kg kh ki kj b">dist</code>文件夹，只需在您喜欢的命令行中运行<code class="eh kg kh ki kj b">node tools/copy-package.js</code>即可。</p><p id="60b7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们需要运行许多命令。1)我们需要移除<code class="eh kg kh ki kj b">dist</code>文件夹来清除文件。2)用<code class="eh kg kh ki kj b">rollup</code> (2个命令用于umd和ES2015)捆绑文件。3)运行节点脚本(3个命令用于复制package.json，清除package.json中的脚本和devdependencies，删除不必要的代码)。</p><p id="423c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果我们只运行一个命令来为我们完成这些任务，那就更好了。</p><h1 id="3d7f" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">设置npm <code class="eh kg kh ki kj b">script </code>以便轻松构建</h1><p id="561c" class="pw-post-body-paragraph jh ji hu jj b jk mm jm jn jo mn jq jr js mo ju jv jw mp jy jz ka mq kc kd ke hn dt translated">最后你可以建图书馆了！最后一个任务设置在<code class="eh kg kh ki kj b">package.json</code>中<code class="eh kg kh ki kj b">script</code>，这样你就不必输入很多命令来构建我们的代码。</p><pre class="ll lm ln lo fq lp kj lq lr aw ls dt"><span id="0436" class="lt kn hu kj b fv lu lv l lw lx">...</span><span id="16e2" class="lt kn hu kj b fv mr lv l lw lx">"scripts": {</span><span id="0dda" class="lt kn hu kj b fv mr lv l lw lx">    "copy": "node tools/copy-package.js &amp;&amp; node tools/cleanup.js",</span><span id="8c6f" class="lt kn hu kj b fv mr lv l lw lx">    "bundle": "rimraf dist &amp;&amp; rollup -c rollup.config.umd.js &amp;&amp; rollup -c rollup.config.esm.js &amp;&amp; tsc",</span><span id="b083" class="lt kn hu kj b fv mr lv l lw lx">    "postbundle": "node tools/removecode.js",</span><span id="5503" class="lt kn hu kj b fv mr lv l lw lx">    "build": "npm run bundle &amp;&amp; npm run copy"</span><span id="d985" class="lt kn hu kj b fv mr lv l lw lx">},</span></pre><p id="95b8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在你只需要写一个命令</p><pre class="ll lm ln lo fq lp kj lq lr aw ls dt"><span id="a84b" class="lt kn hu kj b fv lu lv l lw lx">npm run build</span></pre><h1 id="4884" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">为模块解析设置一些配置</h1><p id="6926" class="pw-post-body-paragraph jh ji hu jj b jk mm jm jn jo mn jq jr js mo ju jv jw mp jy jz ka mq kc kd ke hn dt translated">当用户使用<code class="eh kg kh ki kj b">import</code>我们的库文件夹时，它会在<code class="eh kg kh ki kj b">package.json </code>的属性中寻找我们提供的文件。<a class="ae jg" href="http://blog.mgechev.com/2017/01/21/distributing-an-angular-library-aot-ngc-types/" rel="noopener ugc nofollow" target="_blank">更多细节</a>——在<em class="kf">分配组件</em>部分</p><blockquote class="no np nq"><p id="b489" class="jh ji kf jj b jk jl jm jn jo jp jq jr nr jt ju jv ns jx jy jz nt kb kc kd ke hn dt translated">将<code class="eh kg kh ki kj b"><em class="hu">package.json</em></code>的<code class="eh kg kh ki kj b"><em class="hu">main</em></code>属性的值设置为指向ES5 UMD包。</p><p id="5973" class="jh ji kf jj b jk jl jm jn jo jp jq jr nr jt ju jv ns jx jy jz nt kb kc kd ke hn dt translated">将<code class="eh kg kh ki kj b"><em class="hu">module</em></code>属性的值设置为指向库的<code class="eh kg kh ki kj b"><em class="hu">esm</em></code>版本的入口文件。<code class="eh kg kh ki kj b"><em class="hu">module</em></code>是<code class="eh kg kh ki kj b"><em class="hu">package.json</em></code>中的一个字段，rollup和webpack 2等捆绑器希望在其中找到对ES2015版本代码的引用。注意，一些旧版本的捆绑器使用<code class="eh kg kh ki kj b"><em class="hu">jsnext:main</em></code>而不是<code class="eh kg kh ki kj b"><em class="hu">module</em></code>，所以我们需要设置这两个属性。</p><p id="53a8" class="jh ji kf jj b jk jl jm jn jo jp jq jr nr jt ju jv ns jx jy jz nt kb kc kd ke hn dt">…</p></blockquote><p id="8633" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf"> package.json </em></p><pre class="ll lm ln lo fq lp kj lq lr aw ls dt"><span id="d549" class="lt kn hu kj b fv lu lv l lw lx">"main": "empty-text.umd.js",</span><span id="d44c" class="lt kn hu kj b fv mr lv l lw lx">"jsnext:main": "empty-text.esm.js",</span><span id="5545" class="lt kn hu kj b fv mr lv l lw lx">"module": "empty-text.esm.js",</span><span id="5955" class="lt kn hu kj b fv mr lv l lw lx">"types": "empty-text.d.ts",</span></pre><h1 id="b4dc" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">使您的库与AOT兼容[更新！(26/07/2017)]</h1><p id="0599" class="pw-post-body-paragraph jh ji hu jj b jk mm jm jn jo mn jq jr js mo ju jv jw mp jy jz ka mq kc kd ke hn dt translated">因为angular 2的库需要与AOT兼容。你需要运行<code class="eh kg kh ki kj b">ngc</code>来发射<code class="eh kg kh ki kj b">.metadata.json</code>到你的包旁边。</p><p id="4816" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">首次安装<code class="eh kg kh ki kj b">@angular/compiler-cli</code>:</p><pre class="ll lm ln lo fq lp kj lq lr aw ls dt"><span id="6c6f" class="lt kn hu kj b fv lu lv l lw lx">npm install --save-dev @angular/compiler-cli</span></pre><p id="13d7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后更新<code class="eh kg kh ki kj b">scripts</code>部分的<code class="eh kg kh ki kj b">package.json</code>:</p><pre class="ll lm ln lo fq lp kj lq lr aw ls dt"><span id="2962" class="lt kn hu kj b fv lu lv l lw lx">"scripts": {<br/>   ...,</span><span id="5386" class="lt kn hu kj b fv mr lv l lw lx">   "bundle": "rimraf dist &amp;&amp; rollup -c rollup.config.umd.js &amp;&amp; rollup -c rollup.config.esm.js &amp;&amp; tsc &amp;&amp; ngc", //&lt;--- add ngc<br/>   ...</span><span id="417b" class="lt kn hu kj b fv mr lv l lw lx">},</span></pre><p id="89b4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最后一件事是在<code class="eh kg kh ki kj b">tools/removecode.js</code>中更新，因为没有删除从<code class="eh kg kh ki kj b">ngc</code>命令发出的<code class="eh kg kh ki kj b">.metadata.json</code>文件</p><pre class="ll lm ln lo fq lp kj lq lr aw ls dt"><span id="18b6" class="lt kn hu kj b fv lu lv l lw lx">del(['dist/!(*.umd.js|*.esm.js|*.d.ts|*.umd.js.map|*.esm.js.map|*.metadata.json)']).then(paths =&gt; {</span><span id="dc56" class="lt kn hu kj b fv mr lv l lw lx">    console.log('Files and folders that would be deleted:\n', paths.join('\n'));</span><span id="4ecd" class="lt kn hu kj b fv mr lv l lw lx">});</span></pre><h1 id="2599" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">让我们建造并向世界发布~</h1><figure class="ll lm ln lo fq iv"><div class="bz el l di"><div class="nu nn l"/></div></figure><p id="d7d2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，您可以使用命令<code class="eh kg kh ki kj b">npm run build</code>构建文件，该命令将运行<code class="eh kg kh ki kj b">bundle</code>和<code class="eh kg kh ki kj b">copy</code>脚本。注意<code class="eh kg kh ki kj b">postbundle</code>，它将在<code class="eh kg kh ki kj b">bundle</code>完成后运行。</p><p id="a6c6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">运行<code class="eh kg kh ki kj b">build</code>脚本后，我们将得到<code class="eh kg kh ki kj b">dist</code>文件夹中的文件</p><pre class="ll lm ln lo fq lp kj lq lr aw ls dt"><span id="88c8" class="lt kn hu kj b fv lu lv l lw lx">empty-text.d.ts<br/>empty-text.directive.d.ts<br/>empty-text.esm.js<br/>empty-text.esm.js.map<br/>empty-text.module.d.ts<br/>empty-text.service.d.ts<br/>empty-text.umd.js<br/>empty-text.umd.js.map</span></pre><p id="639f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">剩下的唯一一项任务是将其发布到npm。</p><p id="fd98" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以通过命令<code class="eh kg kh ki kj b">npm run publish</code>向npm发布库代码。</p><p id="64c4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是等等！如果我现在发布我的库，用户会得到不必要的文件，比如我们的<code class="eh kg kh ki kj b">lib</code>和<code class="eh kg kh ki kj b">tools</code>文件夹。我们应该摆脱他们。</p><p id="6566" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有两种方法可以做到这一点。</p><ul class=""><li id="58bf" class="ly lz hu jj b jk jl jo jp js ma jw mb ka mc ke md me mf mg dt translated">创建<a class="ae jg" href="https://docs.npmjs.com/misc/developers#keeping-files-out-of-your-package" rel="noopener ugc nofollow" target="_blank">。忽略不必要的文件进行发布。</a></li><li id="7550" class="ly lz hu jj b jk mh jo mi js mj jw mk ka ml ke md me mf mg dt translated">用<code class="eh kg kh ki kj b">package.json</code>发布到<code class="eh kg kh ki kj b">dist</code>文件夹。</li></ul><p id="0550" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这篇文章中，我将使用第二种方法。这就是为什么我需要将<code class="eh kg kh ki kj b">package.json</code>复制到<code class="eh kg kh ki kj b">dist</code>文件夹。</p><p id="ad95" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们不需要手动复制和粘贴，因为<code class="eh kg kh ki kj b">copy-package.js</code>会为您完成这项工作。</p><p id="41be" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">从那里导航到<code class="eh kg kh ki kj b">dist</code>文件夹和<code class="eh kg kh ki kj b">npm publish</code>。所以安装我们库的用户只能从<code class="eh kg kh ki kj b">dist</code>文件夹中获得文件。</p><p id="5338" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf"> PS。浏览文件夹并运行命令很无聊，但是我找不到从根目录下的文件夹发布的方法。如果你有什么建议，请在评论中告诉我。</em></p><p id="3735" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">更新</strong></p><p id="7137" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Maxime Lafarie建议我在剧本部分加入<code class="eh kg kh ki kj b">“publish”: “cd ./dist &amp;&amp; npm publish”</code>。所以我们只需要运行<code class="eh kg kh ki kj b">npm run publish</code>。</p><p id="ed04" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">咳..这是一条漫长的路。你真是个好读者。现在你可以向全世界发布你的图书馆了！。</p><p id="3a9a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">用户只需像这样对他们的模块使用<code class="eh kg kh ki kj b">npm install emptytext</code>和<code class="eh kg kh ki kj b">import </code>。</p><p id="2a8e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kg kh ki kj b">import { EmptyTextModule } from ‘emptytext’;</code></p><p id="d9d1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">人们现在可以用甜蜜的指令(或者将来的你。相信我，你会感谢你自己的。</p><p id="0d5d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你有任何问题，或一些建议(真的适用！).请在下面评论。</p><p id="ffdf" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">真的是长帖。休息一下，喝杯咖啡。</p><div class="ll lm ln lo fq ab cb"><figure class="nv iv nw nx ny nz oa paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nv iv nw nx ny nz oa paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nv iv nw nx ny nz oa paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="no np nq"><p id="f922" class="jh ji kf jj b jk jl jm jn jo jp jq jr nr jt ju jv ns jx jy jz nt kb kc kd ke hn dt translated"><a class="ae jg" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是这个大家庭的一员。我们现在<a class="ae jg" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">正在接受投稿</a>，并乐意<a class="ae jg" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jh ji kf jj b jk jl jm jn jo jp jq jr nr jt ju jv ns jx jy jz nt kb kc kd ke hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jg" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jg" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ll lm ln lo fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ob"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>