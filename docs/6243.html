<html>
<head>
<title>How many 53-bit integers fit in your language’s map data structure?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您的语言的地图数据结构中有多少个53位整数？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-many-53-bit-integers-fit-in-your-languages-map-data-structure-41605402b7de?source=collection_archive---------6-----------------------#2017-09-09">https://medium.com/hackernoon/how-many-53-bit-integers-fit-in-your-languages-map-data-structure-41605402b7de?source=collection_archive---------6-----------------------#2017-09-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="e252" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在许多应用程序中，生成唯一的用户标识符是一项常见的任务，通常被认为是理所当然的。生成用户标识符的一种简单、有效的方法是生成一个大随机数，让小概率的属性几乎保证每个生成的数字将不同于任何先前生成的标识符(参见:<a class="ae jp" href="https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_.28random.29" rel="noopener ugc nofollow" target="_blank"> UUIDv4 </a>，或<a class="ae jp" href="https://en.wikipedia.org/wiki/Cryptographic_nonce" rel="noopener ugc nofollow" target="_blank">密码随机数</a>)。</p><p id="2985" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设随着用户基数的增加，你不想拿出铅笔、纸和大脑来计算碰撞概率。取而代之的是，你伸手去拿附近一个相对来说没有碎屑的键盘，并决定通过写一个模拟来娱乐自己。</p><p id="17f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">程序很简单。它执行以下操作:</p><ol class=""><li id="a7a2" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">创建一个map / dict / object数据结构作为关联数组。</li><li id="11d1" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">将全局冲突计数器设置为0。</li><li id="dcf4" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">生成一个随机的53位随机整数(为了允许与Javascript奇偶校验，Javascript只允许53位整数)。</li><li id="66e4" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">检查这个数字是否存在于关联数组中。如果没有，将其添加到数组中。如果是，则增加全局冲突计数器。</li><li id="252b" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">跳到第3步，直到程序由于达到2 GB内存限制而崩溃。</li></ol><p id="2b59" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这显然是一个简单的程序，可以用多种方式编写(例如，通过使用每种语言的设置数据结构)。然而，这个微基准的目的是粗略地回答许多语言的以下问题:</p><ol class=""><li id="67d5" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated"><strong class="it hv">在程序崩溃之前，我们可以在一个关联数组中填充多少个唯一的整数？</strong></li><li id="b7d1" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">每种语言到达崩溃点需要多长时间？</li></ol><p id="7c4a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然，还要看看实际上遇到了多少碰撞。</p><p id="4439" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">竞争者如下。在查看结果之前，试着对每种语言的上述问题的答案进行猜测。</p><ul class=""><li id="2567" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo ke jw jx jy dt translated"><strong class="it hv"> C++ </strong>编译支持gcc 5.4.0和C++11</li><li id="d74f" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ke jw jx jy dt translated">运行在CPython 2.7.12上的Python 2 </li><li id="0727" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ke jw jx jy dt translated">运行在PyPy 5.1.2上的Python 2 </li><li id="283e" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ke jw jx jy dt translated">运行在CPython 3.5.2上的Python 3 </li><li id="bfc1" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ke jw jx jy dt translated"><strong class="it hv"> node.js 6 </strong> .11.3 (LTS截至2017年9月)</li><li id="1ef4" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ke jw jx jy dt translated"><strong class="it hv"> node.js 8 </strong> .4.0(最新截至2017年9月)</li></ul><h1 id="12c7" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">结果</h1><p id="2de3" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">下图显示了在程序达到2 GB内存限制或由于其他原因崩溃之前，放入关联数组的唯一整数的数量。</p><p id="003f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">x轴是程序启动以来的时间，y轴是关联图中的整数个数，单位为百万。在这个图中，当程序崩溃时，线终止。较陡的线表示关联数组性能更快，因为在循环的每次迭代中都执行查找和插入。</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff li"><img src="../Images/d9e892cee05f1c79bec07f6ade5e153f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N_4Bp4yfLiIXQJKbwCJTlw.png"/></div></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">Size of the associative array over time for a number of languages. Each series ends when the program crashed. Lines that reach higher y-values represent more memory-efficient languages, and the slope of each line represents the performance of data structures in each language.</figcaption></figure><ul class=""><li id="6bbc" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo ke jw jx jy dt translated">自然，<strong class="it hv"> C++实现了最好的内存性能</strong>，在崩溃前在一个std::map中存储了超过<strong class="it hv">3250万长整数</strong>。然而，Python在速度方面超过了它的性能，这可以从所有三个实现的更陡峭的线条中看出。对于习惯于将C/C++作为性能黄金标准的人来说，这可能有些出乎意料，但这可以通过以下事实来解释:Python使用<a class="ae jp" href="http://www.laurentluce.com/posts/python-dictionary-implementation/" rel="noopener ugc nofollow" target="_blank">普通哈希映射</a>作为其dict数据结构的实现，而C++的映射使用<a class="ae jp" href="https://stackoverflow.com/questions/5288320/why-is-stdmap-implemented-as-a-red-black-tree" rel="noopener ugc nofollow" target="_blank">红黑树</a>。</li><li id="9c5c" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ke jw jx jy dt translated">在Python 2和3模式下运行CPython显示了非常相似的性能配置文件，在存储相同数量的项目时，Python 2比Python 3快一点——大约2230万个整数。</li><li id="df3a" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ke jw jx jy dt translated">Pypy的性能在Python 2和3版本中都超过了CPython，但是它的内存管理导致它在仅仅向map添加了<strong class="it hv">1000万个整数</strong>之后就崩溃了。</li><li id="754c" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ke jw jx jy dt translated">node.js显示了最差的内存性能特征。其中，node (v6)的当前LTS版本比最新版本(v8)稍好一些。然而，这两者不仅是最慢的，也是最差的内存性能。节点6在一个对象中只存储了<strong class="it hv">1110万个整数</strong>，节点8的情况最差，有<strong class="it hv">830万个整数</strong>。</li></ul><p id="4b14" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">至于这次考察的初衷，所有语言的所有运行中的冲突总数正好是<strong class="it hv"> 0。</strong></p><h1 id="1856" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">代码和原始结果</h1><p id="9217" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/mayanklahiri/53bit-ids" rel="noopener ugc nofollow" target="_blank"> Github </a></p><h1 id="6ded" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">笔记</h1><ul class=""><li id="24c0" class="jq jr hu it b iu ld iy le jc ly jg lz jk ma jo ke jw jx jy dt translated">g++ 与<strong class="it hv"> -O3 </strong>和C++11标准一起运行。</li><li id="32b4" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ke jw jx jy dt translated"><strong class="it hv">消耗约1.1 GB内存后，节点8.4.0挂起而不崩溃</strong>。尽管运行时使用了<strong class="it hv"> — max-old-space-size=2048 </strong>命令行标志，情况仍然如此。如果不使用ulimit限制进程内存，内存消耗似乎会无限制地增加，尽管不会产生新的输出。使用<strong class="it hv">关闭涡轮风扇发动机——没有影响。使用<strong class="it hv"> — noconcurrent_sweeping </strong>禁用垃圾收集也没有影响。</strong></li><li id="5b59" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ke jw jx jy dt translated"><strong class="it hv">节点6.11.3 </strong>的垃圾收集器将其崩溃栈跟踪打印到stdout而不是stderr，这是非标准行为。</li></ul></div></div>    
</body>
</html>