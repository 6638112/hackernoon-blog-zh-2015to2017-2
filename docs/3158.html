<html>
<head>
<title>State of the art in deploying Elixir / Phoenix applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">部署Elixir / Phoenix应用程序的最新技术</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/state-of-the-art-in-deploying-elixir-phoenix-applications-fe72a4563cd8?source=collection_archive---------0-----------------------#2017-03-16">https://medium.com/hackernoon/state-of-the-art-in-deploying-elixir-phoenix-applications-fe72a4563cd8?source=collection_archive---------0-----------------------#2017-03-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="25a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是基于在生产环境中运行3到4个Phoenix应用程序超过一年的固执己见的指南。我们最大的应用每天面对大约14K付费用户。</p><p id="6ce4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">我可能是错的</strong>，在<a class="ae jp" href="https://hackernoon.com/tagged/future" rel="noopener ugc nofollow" target="_blank">未来</a>，我们可能会在Kontomatik做不同的事情。然而，据我所知，截至2017年3月，这是部署基于Phoenix Framework的应用程序的最佳方式。</p><h1 id="2578" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">使用<strong class="ak"> asdf </strong>来管理您笔记本电脑上的Erlang和Elixir版本</h1><p id="dbf1" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">假设从一开始就从事多个Elixir项目。即使你现在只有一个生产应用程序，你也会想尝试不同版本的应用程序和其他开源项目。底线是，您不可避免地需要在笔记本电脑上轻松管理Erlang和Elixir版本。</p><p id="61bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用<a class="ae jp" href="https://github.com/asdf-vm/asdf" rel="noopener ugc nofollow" target="_blank"> asdf </a>版本管理器及其。工具版本文件，为您的每个项目固定特定的Erlang和Elixir版本。</p><p id="9123" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">显然，这些版本必须与您在生产环境中运行的版本相匹配。</p><p id="e2d7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">根据我的经验，asdf版本管理器工作得非常好。缺少其他工具(kiex等)(例如只支持酏剂)。</p><h1 id="0857" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">使用distillery来打包发布</h1><p id="b9b8" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">Erlang/OTP版本是打包项目的标准方式，使它们可以在Erlang VM上运行。</p><p id="ed23" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/bitwalker/distillery" rel="noopener ugc nofollow" target="_blank"> Distillery </a>是Elixir社区为构建版本提供的最佳工具。</p><p id="30a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">了解Distillery不涉及服务器或部署是很重要的。最终结果是包含该版本的本地目录(或gzipped文件)。</p><p id="1320" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在内部，发布构建是一个复杂的怪兽。大多数时候，Distillery会完全抽象掉这种复杂性。偶尔，你需要亲自动手，更详细地了解它的某些方面。</p><p id="c8e2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Elixir建立在31岁的Erlang/OTP生态系统之上，部署是遗留问题的一个方面。</p><p id="869a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不要试图以“Rails方式”在服务器上编译rsync Elixir源代码。在Erlang生态系统中，这是一个死胡同和错误的方法。</p><h1 id="6214" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">不要在服务器上安装Erlang将它嵌入到发行版中</h1><p id="ed93" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">配置Distillery以在发行版中嵌入Erlang:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="d79e" class="lc jr hu ky b fv ld le l lf lg"># rel/config.exs<br/>environment :prod do<br/>  set include_erts: true<br/>  # ...<br/>end</span></pre><p id="3b12" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不要在服务器上安装Erlang。</p><p id="eece" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不幸的是，Erlang VM并不完全向后兼容。为旧虚拟机编译的代码可能会在新虚拟机上崩溃。这真的很烦人，在JVM和CLR世界里闻所未闻。</p><p id="1cb4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">实际上，这意味着如果不停机，就无法升级服务器Erlang安装。基础设施工作必须与新应用程序版本(为新Erlang编译的)的部署同步。这种双向部署耦合感觉像石器时代，在现代技术环境中是不可接受的。</p><p id="dcb4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">将Erlang嵌入到版本中完全解决了这个问题，但是引入了一个新的问题:不同的程序员有不同的、不兼容的Erlang版本(Ubuntu LTS vs Arch滚动版本vs OS X等等)。</p><p id="9339" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">人们不能简单地将OS X Erlang二进制文件(及其依赖项)部署到生产Ubuntu LTS服务器上。</p><p id="e160" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将在下一章解决这个问题。</p><h1 id="dc4f" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">使用docker为生产环境进行本地构建</h1><p id="e262" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我不是说要建立码头工人的形象。Docker只需要具有生产兼容的构建环境，而不考虑您的底层开发机器。</p><p id="8a89" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您希望在运行的docker容器中使用Distillery构建您的Erlang/OTP版本。</p><p id="52fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让您的docker文件100%接近您在生产中使用的文件——与您的。工具版本等。请注意，Erlang本身的构建会有依赖项的硬编码特定版本(如Arch上的“libncursesw.so.6”和Ubuntu LTS上的“libncursesw.so.5 ”),这取决于构建它的平台。这就是为什么你需要docker，即使你团队中的每个人都使用Linux。</p><p id="20c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">顺便提一下，Docker也可以用来快速设置开发环境。虽然我不太喜欢这个。它有一些用途，但通常情况下，您不会希望直接在笔记本电脑上开发，而不需要复杂的层，从而获得直接的控制和简单性。此外，像在IntelliJ中运行的上下文测试这样的东西不能在容器中使用。更喜欢本地设置。</p><p id="d6c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">PS为什么不用edeliver？该工具假设在程序员和生产之间有一个部署服务器。这没有什么错，除了对大多数项目来说这是一种过度的杀戮。对于中小型项目，为了速度和简单性，我倾向于避免这种情况，减少移动部件，减少要管理的服务器。也就是说，真正的部署管道非常适合大型团队和项目。</p><h1 id="cd41" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">不要使用热代码升级</h1><p id="9dde" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">Erlang允许更新正在运行的应用程序，以获得极大的正常运行时间。</p><p id="7024" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">缺点是您需要在应用程序中迁移数据结构。部署不再是显而易见的事情(在持续部署的世界中也应该如此)。突然之间，必须仔细考虑部署——否则，您将面临难以调试的问题。</p><p id="fa33" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们不想那样。既费时又有风险。</p><p id="8733" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">简单重启。</strong></p><p id="5480" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了实现更长的正常运行时间，重点关注快速重启，如果有必要，尝试经典的蓝/绿部署或类似模式。</p><h1 id="39b6" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">使用ansible(或类似的)来自动化部署</h1><p id="54ef" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在Ruby世界中，Capistrano提供了几个经过验证的部署流程。您将希望使用您最喜欢的配置工具创建类似的东西。如果你一无所知，选择<a class="ae jp" href="https://www.ansible.com/" rel="noopener ugc nofollow" target="_blank"> ansible </a>。</p><p id="7699" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">设计部署流程的一些技巧:</p><ul class=""><li id="ef2e" class="lh li hu it b iu iv iy iz jc lj jg lk jk ll jo lm ln lo lp dt translated">生产服务器不应该访问您的源代码库</li><li id="d6e7" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo lm ln lo lp dt translated">作为第一步，将中央存储库克隆/拉至您笔记本电脑上的另一个目录(不是您的项目根目录)；构建将在此目录中单独发生</li><li id="e5c2" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo lm ln lo lp dt translated">一切都必须从<strong class="it hv">中央</strong>主(生产)分支——而不是本地程序员分支)构建和部署；这是为了保证没有私有提交被部署到生产中</li><li id="22b5" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo lm ln lo lp dt translated">不要压缩版本；相反，rsync发布目录；这将允许rsync只发送实际的更改(快得多)</li><li id="eef3" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo lm ln lo lp dt translated">在服务器上使用每个开发人员的发布缓存(更快，避免权限问题)</li><li id="3f4b" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo lm ln lo lp dt translated">通过在服务器上准备好一切，然后只将符号链接切换到新版本(并强制重启)，使部署接近原子；这在Rails世界中被称为“当前”符号链接</li><li id="82c2" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo lm ln lo lp dt translated">要运行数据库迁移，请参见:<a class="ae jp" href="https://github.com/bitwalker/distillery/blob/master/docs/Running%20Migrations.md" rel="noopener ugc nofollow" target="_blank">https://github . com/bit walker/distillery/blob/master/docs/Running % 20 migrations . MD</a></li></ul><h1 id="b29a" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">嘿，这太复杂了！</h1><p id="d237" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">可靠的生产部署从来都不容易，而Elixir在此基础上增加了一些意外的复杂性。这可能是去年我们在<a class="ae jp" href="http://kontomatik.com/" rel="noopener ugc nofollow" target="_blank"> Kontomatik </a>爱上的<strong class="it hv">美妙而多产的生态系统</strong>中最糟糕的一面。</p><p id="11c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好的一面是，仙丹/凤凰应用程序:</p><ul class=""><li id="fd30" class="lh li hu it b iu iv iy iz jc lj jg lk jk ll jo lm ln lo lp dt translated">在内存和CPU方面具有非常低的资源使用率；当您在可编程云中托管时，这一点尤为重要(那里的东西很快就会变贵)</li><li id="9bbb" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo lm ln lo lp dt translated">应用重启速度非常快，最大限度地减少了停机时间</li><li id="c59c" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo lm ln lo lp dt translated">生态系统正在迅速成熟，在未来的几个月和几年中，事情将部分简化</li></ul><p id="72f5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">遵循建议的最佳实践，以最大限度地减少部署痛苦，并<strong class="it hv">快速回到仙丹黑客乐趣！</strong>:)</p><blockquote class="lv lw lx"><p id="33d9" class="ir is ly it b iu iv iw ix iy iz ja jb lz jd je jf ma jh ji jj mb jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是AMI家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is ly it b iu iv iw ix iy iz ja jb lz jd je jf ma jh ji jj mb jl jm jn jo hn dt translated">要了解更多信息，<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">请阅读我们的“关于”页面</a> , <a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">喜欢/在脸书给我们发消息</a>，或者简单地，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank">发推文/DM @HackerNoon。</a></p><p id="708a" class="ir is ly it b iu iv iw ix iy iz ja jb lz jd je jf ma jh ji jj mb jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kt ku kv kw fq mc"><div class="bz el l di"><div class="md me l"/></div></figure></div></div>    
</body>
</html>