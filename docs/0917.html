<html>
<head>
<title>Functors and Applicatives</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函子和应用</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/functors-and-applicatives-b9af535b1440?source=collection_archive---------0-----------------------#2016-07-07">https://medium.com/hackernoon/functors-and-applicatives-b9af535b1440?source=collection_archive---------0-----------------------#2016-07-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="daf7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我早期的一篇文章中，我试图用一种平易近人的方式来解释单子。在这里，我们将尝试对同一个族中的其他成员——函子和应用函子进行同样的操作。尽管这里解释的概念和原理在函数式编程中是通用的，但是在Scala上(像往常一样)会有轻微的强调。</p><h2 id="d2ad" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">函子</h2><p id="0611" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">如果您阅读了前面提到的关于单子的文章，您可能还记得我是如何将它们描述为值的包装器的。包装在单子中的每个值都变成了一个配备了两种方法的对象，即<em class="kq">单位</em>和<em class="kq">平面图</em>(使用Scala命名约定)。</p><p id="bcc9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以，如果你把单子看作是提供这两种方法的包装器(我也喜欢“context”这个词)，那么你可以把<em class="kq">函子</em>看作是另一种包装器；一种提供一个稍微弱一点的单子的物质。</p><p id="d326" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您得到的只是:</p><ul class=""><li id="ef92" class="kr ks hu it b iu iv iy iz jc kt jg ku jk kv jo kw kx ky kz dt translated"><strong class="it hv">在哈斯克尔绘制</strong>(<em class="kq">fmap</em>；就像monad的flatMap，但是没有展平部分)</li></ul><p id="335d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">函数<em class="kq">映射</em>可能至少听起来很熟悉，尽管我很确定你们中的大多数人已经在实践中使用了它。初学者通常是用list/array/somethern collection的例子来介绍的，但问题是<em class="kq">所有的函子</em>都有这个功能。您可以映射列表或集合中的每个元素，但也可以将未来或选项中的值映射到另一个值(相同或不同类型)。</p><p id="2c77" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">继续前进，但首先我们必须解决一些问题。我没有声明未来、选项、列表等吗？成为单子文章中的<em class="kq">单子</em>？是的，我做了。所有的单子都是函子；你可以从面向对象的角度来看，单子是函子的一个子类(或子类型)。好吧，不要到处对每个人说这个，因为如果你偶然发现范畴理论的数学家，他们可能会开始谈论函子只是元素的映射和范畴之间的态射，而单子实际上是内函子范畴中的幺半群，自然变换被定义为函子合成和恒等式函子。我不是在开玩笑；他们实际上是这样说话的。但是，是的，从程序员的角度来看，完全有理由说单子实际上是一个函子，还有额外的东西。更具体地说，在functor的<em class="kq"> map </em>之上，monad有一个<em class="kq">flat</em>(也称<em class="kq"> join </em>)，这使得它能够定义map的升级版本——我们钟爱的<em class="kq"> flatMap </em>(也称<em class="kq"> bind </em> ) <em class="kq">。</em>记住，单子还有一个不太有趣，但同样重要的<em class="kq">单元</em>方法。</p><p id="3d36" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">记得单子定律吗？我们这里也有一些法律。假设<em class="kq"> m </em>是我们的仿函数实例(例如List或Future ),它保存一些值(例如Int ),函数<em class="kq"> f </em>和<em class="kq"> g </em>是转换该值的单参数函数(在我们的例子中，它们必须具有签名Int → Something ),那么我们可以定义两个仿函数定律如下:</p><ul class=""><li id="8c93" class="kr ks hu it b iu iv iy iz jc kt jg ku jk kv jo kw kx ky kz dt translated"><strong class="it hv">同一律</strong> : <br/> <em class="kq"> map id = id <br/> </em>或Scala-way:<em class="kq">m . map(identity)= = m</em></li><li id="c700" class="kr ks hu it b iu la iy lb jc lc jg ld jk le jo kw kx ky kz dt translated"><strong class="it hv">分配律</strong> : <br/> <em class="kq"> F图F图g = F图(g♀F)</em><br/>或Scala-way: <em class="kq"> m.map(f)。map(g)= = m . map(x =&gt;g(f(x))</em></li></ul><p id="fe47" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里<em class="kq"> identity </em>是Scala中predef包中定义的identity函数(给定一个值，它只是返回相同的值)，而<em class="kq">♀</em>是函数组合的标准数学符号(意思是“f之后是g”，或者“应用f然后是g”)。注意，如果你想在Scala中组合两个函数，你可以使用<em class="kq"> compose </em>或<em class="kq">then</em>；然而，这不是本文的重点，所以我选择了最简单的形式，简单地一个接一个地应用它们:<em class="kq"> g(f(x)) </em>。</p><h2 id="a492" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">重物提升</h2><p id="8579" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">我们现在将curry它，而不是map()接受两个参数。这意味着函数例如<em class="kq"> (Int，Int) → Int </em>现在将变成<em class="kq"> Int → Int → Int </em>。记住这是右联的，所以和<em class="kq"> Int → (Int → Int) </em>一样。如果你不熟悉currying，我们将很快回到它。</p><p id="3a8b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们以一个列表作为函子；我们的起点(也就是我们的起始仿函数实例)可以是，例如，List(1，2，3)。我们还可以使用一些函数来映射我们的列表，例如:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="09e2" class="jq jr hu lk b fv lo lp l lq lr">val f = (x: Int) =&gt; x.toString</span></pre><p id="fc47" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Scala中，我们将这个列表映射为简单的<em class="kq">列表(1，2，3)。</em>地图(f)。现在，如果我们像以前一样改变我们的视点，使map变成一个二元函数，我们可以调用它作为<em class="kq"> map(List(1，2，3)，f) </em>。第一个参数是仿函数实例，第二个参数是函数。<em class="kq">(注意，我这里是补句法；我只是在阐述一个概念。在所有标准的Scala构造中，map()总是一个类方法，在该类的一个实例上被调用，并且它只有一个参数——映射函数。这是惯例。)</em></p><p id="1f64" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们说过我们会更进一步，所以我们的map函数的调用现在变成了这样(注意，我交换了参数的位置，因为这样更容易说明我的观点；如果函数的参数在签名中的顺序被打乱，函数不需要改变它的实现):</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="1871" class="jq jr hu lk b fv lo lp l lq lr">map(f)(List(1, 2, 3))</span></pre><p id="3746" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Currying就是取一个<em class="kq"> n </em>参数的函数，把它变成<em class="kq"> n </em>单参数函数。任何<em class="kq"> n </em>参数函数都可以这样进行；实际上，在Haskell中，这是实现具有多个参数的函数的唯一方法。比如说。你不能有一个取两个数并相乘的函数，你只能有一个取一个数并返回一个数的函数。这样就像我们之前说的，<em class="kq"> (Int，Int) → Int </em>变成了<em class="kq"> Int → Int → Int </em>。或者如果你更喜欢显式地写优先级，它就变成了<em class="kq"> Int → (Int → Int </em>)。</p><p id="6359" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以我们的地图现在实际上是一个单参数函数，它返回另一个单参数函数。这允许我们像这样传递第一个参数:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="0113" class="jq jr hu lk b fv lo lp l lq lr">map(f) // returns a function List[Int] =&gt; List[String]</span></pre><p id="bdb7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们继续并将我们的列表(1，2，3)传递给map(f)的结果，我们将得到一个列表(“1”，“2”，“3”)。但是如果我们<em class="kq">在这里</em>停止，我们得到的是一个<em class="kq">函数，它接受一个整数列表并返回一个字符串列表</em>。Curried方法给出了一个高阶函数，它将<em class="kq"> typeA </em> → <em class="kq"> typeB </em>映射到<em class="kq">函子【typeA】</em>→<em class="kq">函子【typeB】。</em>这种高阶函数俗称<strong class="it hv"> lift </strong>。它接受一个函数并“提升”它，这样它的操作数就被放入某个上下文中(比如一个函子或一个单子)。</p><p id="e138" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这意味着我们可以这样编写map()的签名:</p><p id="35f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="kq"> (A → B) → F[A] → F[B] </em></p><p id="6387" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是在很多函数式编程书籍和编程语言中都能找到的<a class="ae jp" href="https://en.wikipedia.org/wiki/Map_(higher-order_function)#Generalization" rel="noopener ugc nofollow" target="_blank">经典地图签名</a>。由于它是两个curried函数的链，我们可以从两个方面来看待它:</p><ul class=""><li id="0aa2" class="kr ks hu it b iu iv iy iz jc kt jg ku jk kv jo kw kx ky kz dt translated">map采用一个函数<em class="kq"> A → B </em>和一个仿函数实例<em class="kq"> F[A] </em>，并产生另一个仿函数实例<em class="kq"> F[B] </em>(我们的经典非简化map)</li><li id="bf99" class="kr ks hu it b iu la iy lb jc lc jg ld jk le jo kw kx ky kz dt translated">map采用函数<em class="kq"> A → B </em>并返回函数<em class="kq"> F[A] → F[B] </em></li></ul><p id="6337" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正是谄媚的可怕本质让我们有了这两种不同的观点。</p><h2 id="9f31" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">函子的问题</h2><p id="27b3" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">我们看到了地图功能的三种不同表示:</p><ul class=""><li id="2a76" class="kr ks hu it b iu iv iy iz jc kt jg ku jk kv jo kw kx ky kz dt translated"><em class="kq">Scala方式:</em></li><li id="2978" class="kr ks hu it b iu la iy lb jc lc jg ld jk le jo kw kx ky kz dt translated">作为一个双参数函数:<em class="kq"> map(m，f) </em></li><li id="41ad" class="kr ks hu it b iu la iy lb jc lc jg ld jk le jo kw kx ky kz dt translated">作为约定函数:<em class="kq">映射(m)(f) </em>或<em class="kq">映射(f)(m) </em></li></ul><p id="6b95" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尽管第二种和第三种方法在函数式编程领域更为常见，但Scala，不仅是FP语言，也是OOP语言，决定选择第一种，因为它更接近于面向对象的范式。</p><p id="d343" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们知道map()只接受一个<strong class="it hv">函数的一个</strong>参数——这个参数与函子中的底层值属于同一类型。例如，整数列表上的map采用一个接受单个Int的函数(但它可以返回任何类型)。</p><p id="4f9e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，我们也知道使用奉承我们可以欺骗一点。如果我们有一个有<em class="kq"> n </em>个参数的函数，我们可以把它转换成一个只有一个参数的函数，返回一个有<em class="kq"> n-1 </em>个参数的函数。这将允许我们为map()提供函数<strong class="it hv">和任意数量的参数</strong>(当然，第一个参数必须是合适的类型，以匹配封装在函子中的参数，例如<em class="kq"> Future[Int] </em>可以用函数<em class="kq">Int→Whatever→Whatever→Whatever→</em>…)进行映射。</p><p id="cf7c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">想法不错，但是map()不太喜欢。</p><p id="914d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为什么？一个简单的例子可以说明这个问题。让我们用一个将两个整数相加的函数来处理它:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="1a09" class="jq jr hu lk b fv lo lp l lq lr">val f = (x: Int) =&gt; (y: Int) =&gt; x + y</span></pre><p id="04a7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们给这个函数提供一个值，我们将得到一个比原始函数少一个参数的函数，这样我们就只有一个参数(在我们的例子中称为“y”)。因此，如果我们给函数<em class="kq"> f </em>输入值42，我们将得到一个函数，它接受一个数字并给它加上42。</p><p id="fd39" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">酷毙了。因此，让我们将我们的curried函数提供给map():</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="4355" class="jq jr hu lk b fv lo lp l lq lr">val f = (x: Int) =&gt; (y: Int) =&gt; x + y</span><span id="9afe" class="jq jr hu lk b fv ls lp l lq lr">val result = Future(42).map(f)</span><span id="5473" class="jq jr hu lk b fv ls lp l lq lr">// result is Future(x =&gt; x + 42)</span></pre><p id="ff3d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们得到的是一个未来，其中我们的整数42被转换成一个函数，该函数接受某个整数<em class="kq"> x </em>并返回<em class="kq"> x </em> +42 <em class="kq">。</em>现在这有点麻烦了。正如我们之前说过的，通常当你找到一个有n个参数的函数，并给它提供第一个参数时，你会得到一个有n-1个参数的函数。如果我们的函数<em class="kq"> f </em>将两个数相加，我们将得到一个函数<em class="kq"> Int → Int </em>。但是当我们把那个函数提供给map()，<strong class="it hv">我们得到的不是<em class="kq"> Int → Int </em>，而是<em class="kq">Future【Int→Int】</em></strong>。我们不能再继续将东西应用到curried函数的其余部分，因为map()不知道如何处理包装在future中的函数。</p><p id="cdba" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我再重复一遍，这是关键部分。因此，如果我们想用某个函数来映射我们的未来，比如说，这次是四个参数，比如<em class="kq"> f(a: Int，b: Int，c: Int，d: Int) </em>，我们会将函数转换成<em class="kq"> Int→ Int→ Int→ Int </em>并将其提供给map()，但这就是全部。Map会消耗第一个参数，但不会留给我们<em class="kq"> Int→ Int→ Int </em>。如果是的话，我们可以以同样的方式继续下去。相反，它留给我们的是<em class="kq"> Future[Int → Int → Int] </em>。</p><p id="fa8d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们现在需要的是一个<em class="kq">适用函子</em>。</p><h2 id="3bf2" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">应用函子</h2><p id="0e65" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">适用函子(有时简称为<em class="kq">适用的</em>)是我们前面看到的通用函子的升级版本。虽然函子只使用单参数函数，但应用函子可以使用任意数量参数的函数。他们还引入了unit/return方法，该方法将给定的类型A提升到F[A]中。<em class="kq">(注:适用函子还附带了与普通函子稍有不同的</em> <a class="ae jp" href="https://en.wikibooks.org/wiki/Haskell/Applicative_functors#Applicative_functor_laws" rel="noopener ugc nofollow" target="_blank"> <em class="kq">套法则</em></a><em class="kq">；我不会在这里深入讨论它们，因为我的意图只是解释适用函子的概念，而将“机械的”部分(如定律)留给你个人研究，一旦你熟悉了这个概念)</em></p><p id="7fd2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们再来考虑一些四参数函数<em class="kq"> f </em>的简化形式。它的签名是<em class="kq"> Int → Int → Int → Int。</em>现在我们把它喂给某个<em class="kq">未来的map()【Int】</em>。结果是<em class="kq">未来[Int → Int → Int] </em>。一分钟前我们已经讨论过了。好的，但是现在很酷的事情发生了:我们的新朋友应用函子开始发挥作用，并且说:“嘿，你已经把你的函数包装到一点上下文中了，嗯？别担心，我知道如何应用这些包装函数。是的，你听得很清楚；我可以在仿函数上下文(如Future、Option或List)中应用函数。为了避免混淆，我们将把术语“映射”留给标准函子，而在应用函子中使用术语“应用”来表示这个新的酷函数。因此，如果映射被定义为(使用柯里化符号):</p><ul class=""><li id="2cd8" class="kr ks hu it b iu iv iy iz jc kt jg ku jk kv jo kw kx ky kz dt translated"><em class="kq">映射[A，B](f: F[A])(f: A → B): F[B] </em></li></ul><p id="fd1c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我们的新方法apply()被定义为:</p><ul class=""><li id="bc47" class="kr ks hu it b iu iv iy iz jc kt jg ku jk kv jo kw kx ky kz dt translated"><em class="kq">应用[A，B](F:F[A])(F:</em><strong class="it hv"><em class="kq">F【A→B】</em></strong><em class="kq">):F【B】</em></li></ul><p id="63dd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">定义适用函子还有两种方法:用同样强大的<em class="kq">映射2 </em>替换<em class="kq">应用</em>，或者用<em class="kq">乘积</em>和<em class="kq">映射</em>的组合替换。</p><p id="d52c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是所有三个定义:</p><ol class=""><li id="3094" class="kr ks hu it b iu iv iy iz jc kt jg ku jk kv jo lt kx ky kz dt translated"><em class="kq">单位[A](a: A): F[A] <br/>应用[A，B](f: F[A])(f: F[A → B]): F[B] </em></li><li id="c29e" class="kr ks hu it b iu la iy lb jc lc jg ld jk le jo lt kx ky kz dt translated"><em class="kq">单位[A](a: A): F[A] <br/> map2[A，B，C](fa: F[A]，fb: F[B])(f: (A，B) = &gt; C): F[C] </em></li><li id="bfe9" class="kr ks hu it b iu la iy lb jc lc jg ld jk le jo lt kx ky kz dt translated"><em class="kq">单位[A](a: A): F[A] <br/>映射[A](fa:F[A]])(F:A =&gt;B):F[B]<br/>乘积[A，B](fa: F[A]，fb: F[B]): F[(A，B)] </em></li></ol><p id="8f22" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我说方法<em class="kq">应用</em>和<em class="kq">映射2 </em>是“同等强大”的时候，我的意思是你可以通过使用另一个来表达一个。<em class="kq">产品</em>稍弱，需要配<em class="kq">图</em>。我不会在这里展示这些定义之间的翻译，但是你可以在网上找到它们(例如这里的<a class="ae jp" href="https://github.com/robertberry/Functional-Programming-in-Scala-Exercises/blob/master/src/main/scala/com/github/robertberry/fpis/Chapter12.scala" rel="noopener ugc nofollow" target="_blank"/>)或者试着自己解决它们。</p><p id="84fe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们现在将使用<em class="kq"> apply </em>版本，但是我将向您展示它与其他两个定义的关系。</p><h2 id="d3f2" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">解决函子问题</h2><p id="4e39" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">好吧。那么如果我们用函数<em class="kq"> Int → Int → Int → Int </em>来喂未来的map()会怎么样呢？我们得到一个<em class="kq">未来[Int → Int → Int]。</em>然后我们可以用<em class="kq"> Future[Int → Int → Int] </em>来填充它的apply()，得到一个F<em class="kq">Future[Int→Int]。</em>最后，我们应用<em class="kq"> Future[Int → Int] </em>，剩下<em class="kq"> Future[Int]。</em></p><p id="197a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们完成前面的“加42”的例子。请注意，我将编写更多的伪Scala，因为将来不会有以这种方式定义的apply()方法。现在，假设这样的方法存在，我们稍后将解释这种困境。</p><p id="d4a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，为了给函子提供一个双参数函数，我们要做:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="f1ec" class="jq jr hu lk b fv lo lp l lq lr">val f = (x: Int) =&gt; (y: Int) =&gt; x + y<br/>val r1: Future[Int =&gt; Int] = Future(42).map(f)<br/>Future(10).apply(r1) // results in Future(52)</span></pre><p id="51af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你看到这里发生了什么吗？我们采用了Future[Int]类型的两个值(Future(42)和Future(10))和一个函数<em class="kq"> f </em>，签名为<em class="kq"> Int → Int </em>，我们设法生成了另一个Future，其潜在值是将我们的两个起始Future的值应用于函数<em class="kq"> f </em>的结果。这真是太棒了。假设您从数据库中获取三角形的三个点，最后得到三个<em class="kq"> Future[Int] </em>值。如何用函数<em class="kq"> calculate(a: Int，b: Int，c: Int) </em>计算由那些点组成的三角形的周长？你不能只把点提供给函数，因为点不是Int类型的，而是Future[Int]类型的。</p><p id="e91c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用应用函子可以:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="f24c" class="jq jr hu lk b fv lo lp l lq lr">val f1 = Future(3)<br/>val f2 = Future(4)<br/>val f3 = Future(5)</span><span id="9469" class="jq jr hu lk b fv ls lp l lq lr">val calculate = (a: Int) =&gt; (b: Int) =&gt; (c: Int) =&gt; a + b + c</span><span id="a0eb" class="jq jr hu lk b fv ls lp l lq lr">// btw you can also do:<br/>// val calculate = ( (a:Int, b:Int, c:Int) =&gt; a + b + c ).curried</span><span id="90a5" class="jq jr hu lk b fv ls lp l lq lr">f1.apply(f2.apply(f3.apply(unit(calculate)))) // Future(12)</span></pre><p id="3567" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">很酷，对吧？注意，我们必须通过使用<em class="kq">单元</em>将函数包装到应用上下文中，以便<em class="kq">应用</em>能够使用它。</p><p id="b92e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">伪Scala的东西已经够多了。让我们写一些实际的代码。我们将使用scalaz库:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="2041" class="jq jr hu lk b fv lo lp l lq lr">import scalaz._, Scalaz._</span><span id="75cd" class="jq jr hu lk b fv ls lp l lq lr">val f1 = Future(3)<br/>val f2 = Future(4)<br/>val f3 = Future(5)</span><span id="74d2" class="jq jr hu lk b fv ls lp l lq lr">val calculate = (a: Int) =&gt; (b: Int) =&gt; (c: Int) =&gt; a + b + c<br/>val area = f1 &lt;*&gt; (f2 &lt;*&gt; (f3 &lt;*&gt; <em class="kq">Future</em>(calculate))) // Future(12)</span></pre><p id="dfc8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">操作器是对<em class="kq">施加</em>的操作。对于<em class="kq">单元</em>，我简单使用了未来构造函数。</p><p id="4374" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还记得我们讨论过应用程序的三种不同定义吗？让我们看看如何使用<em class="kq">产品+地图</em>:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="6314" class="jq jr hu lk b fv lo lp l lq lr">import scalaz._, Scalaz._</span><span id="d548" class="jq jr hu lk b fv ls lp l lq lr">val f1 = Future(3)<br/>val f2 = Future(4)<br/>val f3 = Future(5)</span><span id="3845" class="jq jr hu lk b fv ls lp l lq lr">val calculate = (a: Int) =&gt; (b: Int) =&gt; (c: Int) =&gt; a + b + c<br/>val area = (f1 |@| f2 |@| f3)(calculate)// Future(12)</span></pre><p id="969f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">运算符|@|是<em class="kq">的乘积</em>运算。我们在这里所做的是将三个应用程序放在一起，并将它们“合并”成一个(我们计算了它们的<em class="kq">乘积</em>，然后我们用我们的<em class="kq">计算</em>函数映射那个乘积。注意，我们没有显式调用map()，因为这是适用产品的scalaz语法的工作方式；通过使用|@|将您的应用程序组合到一个产品中，会产生一个ApplicativeBuilder，它接受一个在产品上执行的函数(因为产品+地图是一个非常常见的用例)。注意一个细节:<em class="kq">计算</em>不能在这里进行，因为应用产品采用一个无约束的多参数函数(在本例中为arity 3)。我</p><p id="e993" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果使用<em class="kq">产品</em>定义比使用<em class="kq">应用</em>定义更容易推断整个过程，那实际上是很正常的。我已经向你展示了两种方法，你可以自由选择你喜欢的。你能用<em class="kq">单位</em> + <em class="kq">应用</em>做的事情，你能用<em class="kq">单位</em> + <em class="kq">产品</em> + <em class="kq">地图</em>做，反之亦然。第三个定义也是一样，<em class="kq">单位+地图2 </em>(我会让你自己去研究那个定义；反正它已经从scalaz7中移除了，所以如果你决定跳过它也没关系)。</p><p id="1904" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">顺便说一下，敏锐的读者会注意到产品版本实际上在常规Scala中是可行的。是的，那是一个拉链。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="c906" class="jq jr hu lk b fv lo lp l lq lr">val area = (f1 zip f2 zip f3) map { <br/>  case ((a, b), c) =&gt; calculate(a, b, c) <br/>} // Future(12)</span></pre><p id="3d0d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有点笨拙，但可行。</p><h2 id="2e44" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">结论</h2><p id="2226" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">“常规”函子基本上是某种类型值的包装器。List[Int]、Future[String]和Option[Whatever]都是函子的例子。</p><p id="1b32" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">可应用的函子稍微复杂一些——它们知道如何应用包装在函子上下文中的函数。比如给定一个Future[Int]函子，我们可以对它应用一个函数<em class="kq"> Future[Int → Int] </em>，而正则函子中的正则map()只知道如何应用<em class="kq"> Int → Int。</em>或者，你可以这样看:在正则函子的<em class="kq">映射</em>功能之上，应用性函子增加了<em class="kq">单元</em>函数，它将一个普通的A提升到函子上下文F[A]中，<em class="kq">乘积</em>函数，它可以用来将多个函子合二为一。</p><p id="2379" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，有多种描述应用函子的方法，可以得到相同的基本原理。适用函子类似于函子，但是:</p><ul class=""><li id="e283" class="kr ks hu it b iu iv iy iz jc kt jg ku jk kv jo kw kx ky kz dt translated">应用函子可以应用多个参数的函数</li><li id="8b3b" class="kr ks hu it b iu la iy lb jc lc jg ld jk le jo kw kx ky kz dt translated">应用函子可以应用包装在函子上下文中的函数</li><li id="fed6" class="kr ks hu it b iu la iy lb jc lc jg ld jk le jo kw kx ky kz dt translated">应用函子可以将多个函子组合成一个乘积</li><li id="53b7" class="kr ks hu it b iu la iy lb jc lc jg ld jk le jo kw kx ky kz dt translated">等等。</li></ul><p id="6653" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们结束之前，还有一个有趣的问题:</p><p id="bb78" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可能已经知道了一些单子，也可能还不知道。嗯，单子更进一步，给你提供了一个更强大的操作。这是它们的比较，三个都是(我省略了<em class="kq">单元</em>，因为它不是说明这一点所必需的):</p><ul class=""><li id="4e9e" class="kr ks hu it b iu iv iy iz jc kt jg ku jk kv jo kw kx ky kz dt translated"><strong class="it hv">函子</strong>:<em class="kq">T5】映射(f: F[A])(f: A → B): F[B] </em></li><li id="14dd" class="kr ks hu it b iu la iy lb jc lc jg ld jk le jo kw kx ky kz dt translated"><strong class="it hv">适用函子</strong> : <em class="kq"> <br/>适用(f: F[A])(f: F[A → B]): F[B] </em></li><li id="e762" class="kr ks hu it b iu la iy lb jc lc jg ld jk le jo kw kx ky kz dt translated"><strong class="it hv">单子</strong> : <br/> <em class="kq">平面图(f: F[A])(f: A → F[B]): F[B] </em></li></ul><p id="d2e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如应用程序可以使用其他定义一样(例如，<em class="kq"> product + map </em>而不是<em class="kq"> apply </em>)，单子也是如此(例如，<em class="kq"> flatten + map </em>而不是<em class="kq"> flatMap </em>)。单子是最强大的；它们可以是“有条件的”，这意味着一个单子可以根据前一个单子操作的结果采取行动。或者，如果您愿意，它们可以串行工作，而应用程序可以并行工作。看到单子定义里那个<em class="kq"> f: A → F[B] </em>了吗？这是实现这种依赖性的部分；它说“从单子F[A]中取A，并基于它计算单子F[B]”。</p><p id="b5e7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，如果你有<em class="kq"> n </em>个异步请求(比如数据库查询)导致<em class="kq"> n </em>个未来，你应该根据你的需要选择一个合适的抽象:</p><ul class=""><li id="d0fa" class="kr ks hu it b iu iv iy iz jc kt jg ku jk kv jo kw kx ky kz dt translated">如果你的未来不互相依赖，使用一个应用程序(例如，你可以把它们放入一个产品中，并用一个处理成功/失败的函数映射每个结果)</li><li id="c38d" class="kr ks hu it b iu la iy lb jc lc jg ld jk le jo kw kx ky kz dt translated">如果你的未来确实相互依赖，例如，你想连续调用它们，并在第一次成功或第一次失败时停止，那么使用一个单子(它允许你用一个函数来平面映射一个未来，该函数检查它的值并基于它执行下一个单子操作)</li></ul><p id="f0f0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是为什么你只能通过使用单子为上下文相关的语法构建解析器，而对于上下文无关的语法，使用应用程序就足够了。</p><p id="e6a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好了，暂时就这些了。像往常一样，如果你觉得有什么不清楚、令人困惑、误导或不正确的地方，请在这里给我留言，或者给我发一封关于sinisalouc@gmail.com的电子邮件。也可以随时在<a class="ae jp" href="https://twitter.com/sinisalouc" rel="noopener ugc nofollow" target="_blank">推特</a>上找我。</p><p id="4e26" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">干杯！</p><blockquote class="lu lv lw"><p id="aaef" class="ir is kq it b iu iv iw ix iy iz ja jb lx jd je jf ly jh ji jj lz jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is kq it b iu iv iw ix iy iz ja jb lx jd je jf ly jh ji jj lz jl jm jn jo hn dt translated">要了解更多信息，<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">请阅读我们的“关于”页面</a> , <a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">喜欢/在脸书给我们发消息</a>，或者简单地，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank">发推文/DM @HackerNoon。</a></p><p id="708a" class="ir is kq it b iu iv iw ix iy iz ja jb lx jd je jf ly jh ji jj lz jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>