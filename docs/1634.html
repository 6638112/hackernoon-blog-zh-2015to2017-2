<html>
<head>
<title>Using Ecto.Multi for Complex Database Transactions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用埃克托。多用于复杂的数据库事务</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/using-ecto-multi-for-complex-database-transactions-70aac419e81c?source=collection_archive---------3-----------------------#2016-11-23">https://medium.com/hackernoon/using-ecto-multi-for-complex-database-transactions-70aac419e81c?source=collection_archive---------3-----------------------#2016-11-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="75de" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">维克拉姆·拉玛克里希南</p><p id="652b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最近，我们做了一个客户端项目，该项目要求在用户注册期间向服务器发送大量字段。其中一些字段(电子邮件、密码等。)是<code class="eh jp jq jr js b">user</code>模式的一部分，其他的是其他模式的一部分。由于这些其他模式依赖于<code class="eh jp jq jr js b">user</code>，我们将不得不在我们的<code class="eh jp jq jr js b">RegistrationController</code>中嵌套条件事务，这将提供多个故障点的可能性。我们不想嵌套这些条件事务，而是希望能够轻松地对事务进行排序，并匹配错误和失败。下面是我们如何使用<code class="eh jp jq jr js b">Ecto.Multi</code>来简化这一过程的解释。</p><p id="1edf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">考虑下面的例子。您有两个模式:<code class="eh jp jq jr js b">user</code>和<code class="eh jp jq jr js b">address</code>。一个<code class="eh jp jq jr js b">user</code> <code class="eh jp jq jr js b">has_many</code> <code class="eh jp jq jr js b">addresses</code>和一个<code class="eh jp jq jr js b">address</code> <code class="eh jp jq jr js b">belongs_to</code>一个<code class="eh jp jq jr js b">user</code>。在用户注册过程中，您希望用户提交他们的用户详细信息以及他们的邮寄地址详细信息。为了简单起见，让我们假设我们正在验证所有的字段，因此如果有任何字段没有发送到服务器，整个事务就会失败。下面是一个好的请求参数被发送到服务器的例子:</p><pre class="jt ju jv jw fq jx js jy jz aw ka dt"><span id="b78d" class="kb kc hu js b fv kd ke l kf kg">{<br/>  "user": {<br/>    "email": "vikram@quantlayer.com",<br/>    "password": "password1",<br/>    "phone_number": "6176176176"<br/>  },<br/>  "address": {<br/>    "city": "Cambridge",<br/>    "country": "US",<br/>    "postal_code": "02139",<br/>    "state_province": "MA",<br/>    "street_line1": "5 QuantLayer Ave."<br/>  }<br/>}</span></pre><p id="5334" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于邮寄地址属于一个用户，所以我们必须在创建地址之前创建一个用户来与该地址相关联。记住这一切，逻辑可能是这样的:</p><pre class="jt ju jv jw fq jx js jy jz aw ka dt"><span id="4d5e" class="kb kc hu js b fv kd ke l kf kg">1. Try creating a user<br/>2. If user creation fails, return an error<br/>3. If user creation succeeds, try creating an address<br/>4. If address creation fails, delete the user and return an error<br/>5. If address creation succeeds, return the user and jwt</span></pre><p id="d09c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是控制器中的一个示例:</p><pre class="jt ju jv jw fq jx js jy jz aw ka dt"><span id="7b1d" class="kb kc hu js b fv kd ke l kf kg">user_changeset = User.changeset(%User{}, user_params)</span><span id="4750" class="kb kc hu js b fv kh ke l kf kg">case Repo.insert(user_changeset) do {:ok, user} -&gt;<br/>  address_changeset = <br/>    %Address{user_id: user.id}<br/>    |&gt; Address.changeset(address_params)</span><span id="6520" class="kb kc hu js b fv kh ke l kf kg">  case Repo.insert(address_changeset) do<br/>    {:ok, _address} -&gt;<br/>      {:ok, jwt, _full_claims} = <br/>        Guardian.encode_and_sign(user, :token)</span><span id="952c" class="kb kc hu js b fv kh ke l kf kg">      conn<br/>      |&gt; put_status(:created)<br/>      |&gt; render(MyApp.SessionView, "create.json", jwt: jwt, user: user)</span><span id="eda9" class="kb kc hu js b fv kh ke l kf kg">    {:error, changeset} -&gt;<br/>      Repo.delete(user)</span><span id="34d6" class="kb kc hu js b fv kh ke l kf kg">      conn<br/>      |&gt; put_status(:unprocessable_entity)<br/>      |&gt; render(MyApp.RegView, "error.json", changeset: changeset)<br/>  end</span><span id="3e01" class="kb kc hu js b fv kh ke l kf kg">  {:error, changeset} -&gt;</span><span id="9f1d" class="kb kc hu js b fv kh ke l kf kg">  conn<br/>  |&gt; put_status(:unprocessable_entity)<br/>  |&gt; render(MyApp.RegView, "error.json", changeset: changeset)<br/>end</span></pre><p id="01de" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有几件事我不喜欢。首先，嵌套的<code class="eh jp jq jr js b">case</code>语句很难理解。其次，我们删除了地址失败时新创建的用户，这增加了数据库事务的数量。最后，对于<code class="eh jp jq jr js b">user</code>和<code class="eh jp jq jr js b">address</code>参数，我们不会处理基于错误输入的错误。这种方法实在站不住脚。想象一下再增加一个步骤，比如要求信用卡详细信息。嵌套更多的<code class="eh jp jq jr js b">case</code>语句以及跟踪多个错误点变得很麻烦。如果事务的任何部分失败，我宁愿能够回滚整个事务。</p><h2 id="e4ae" class="kb kc hu bd ki kj kk kl km kn ko kp kq jc kr ks kt jg ku kv kw jk kx ky kz la dt translated">输入<code class="eh jp jq jr js b">Ecto.Multi</code></h2><p id="f694" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated"><code class="eh jp jq jr js b">Ecto.Multi</code>让我们处理多个相互依赖的回购交易。</p><p id="c1d9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">文件(<a class="ae lg" href="https://hexdocs.pm/ecto/Ecto.Multi.html" rel="noopener ugc nofollow" target="_blank">https://hexdocs.pm/ecto/Ecto.Multi.html</a>)是这样描述的:</p><blockquote class="lh li lj"><p id="416c" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated">“埃克托。Multi使得将应该一起执行的操作打包(在单个数据库事务中)成为可能，并提供了一种无需实际执行就能自省排队操作的方法。每个操作都有一个独一无二的名称，这个名称将确定其结果，或者在发生故障时有助于确定故障的位置。”</p></blockquote><p id="9862" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以，让我们用<code class="eh jp jq jr js b">Ecto.Multi</code>重写上面的例子:</p><pre class="jt ju jv jw fq jx js jy jz aw ka dt"><span id="04d0" class="kb kc hu js b fv kd ke l kf kg">user_changeset = User.changeset(%User{}, user_params)</span><span id="3d42" class="kb kc hu js b fv kh ke l kf kg">multi =<br/>  Multi.new<br/>  |&gt; Multi.insert(:user, user_changeset)<br/>  |&gt; Multi.run(:address, fn %{user: user} -&gt;<br/>    address_changeset = <br/>      %Address{user_id: user.id}<br/>      |&gt; Address.changeset(address_params)<br/>    Repo.insert(address_changeset)<br/>  end)</span><span id="b7bc" class="kb kc hu js b fv kh ke l kf kg">case Repo.transaction(multi) do<br/>  {:ok, result} -&gt;<br/>    {:ok, jwt, _full_claims} = <br/>      Guardian.encode_and_sign(result.user, :token)</span><span id="3f67" class="kb kc hu js b fv kh ke l kf kg">    conn<br/>    |&gt; put_status(:created)<br/>    |&gt; render(MyApp.SessionView, "create.json", jwt: jwt, user: result.user)</span><span id="4ab4" class="kb kc hu js b fv kh ke l kf kg">  {:error, :user, changeset, %{}} -&gt;<br/>    conn<br/>    |&gt; put_status(:unprocessable_entity)<br/>    |&gt; render(MyApp.RegView, "error.json", changeset: changeset)</span><span id="3bc2" class="kb kc hu js b fv kh ke l kf kg">  {:error, :address, changeset, %{}} -&gt;<br/>    conn<br/>    |&gt; put_status(:unprocessable_entity)<br/>    |&gt; render(MyApp.RegView, "error.json", changeset: changeset)<br/>end</span></pre><p id="abc3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里，我们将一个<code class="eh jp jq jr js b">Ecto.Multi.new</code>事务分配给<code class="eh jp jq jr js b">multi</code>。<code class="eh jp jq jr js b">Multi</code>通过<code class="eh jp jq jr js b">insert</code>等函数接受变更集。注意，<code class="eh jp jq jr js b">:user</code>和<code class="eh jp jq jr js b">:address</code>是我们分配给<code class="eh jp jq jr js b">Multi.insert/2</code>和<code class="eh jp jq jr js b">Multi.run/2</code>中操作的唯一名称，这就是为什么我们可以将<code class="eh jp jq jr js b">user</code>传递给<code class="eh jp jq jr js b">Multi.run/2</code>。检查变更集，如果有错误，事务不会启动并返回错误。然后我们使用<code class="eh jp jq jr js b">Multi.run</code>来传递一个任意的函数，这个函数依赖于前面行中的用户。当我们用<code class="eh jp jq jr js b">Repo.transaction(multi)</code>执行事务时，我们可以对所有可能的结果进行模式匹配，这使得以后添加更多的需求变得更加容易。</p><p id="abda" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">更多关于图书馆用途的好观点包含在原文<code class="eh jp jq jr js b">Ecto.Multi</code>PR:<a class="ae lg" href="https://github.com/elixir-ecto/ecto/issues/1114" rel="noopener ugc nofollow" target="_blank">https://github.com/elixir-ecto/ecto/issues/1114</a>中</p><p id="0c7c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有兴趣更广泛地讨论定制软件需求吗？给我在vikram@quantlayer.com写封短信——我很想和你聊天。在https://twitter.com/@QuantLayer<a class="ae lg" href="https://twitter.com/@QuantLayer" rel="noopener ugc nofollow" target="_blank">的推特上关注我们</a></p><blockquote class="lh li lj"><p id="4b68" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated">黑客中午是黑客如何开始他们的下午。我们是这个家庭的一员。我们现在<a class="ae lg" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae lg" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated">要了解更多信息，<a class="ae lg" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">请阅读我们的“关于”页面</a> , <a class="ae lg" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">喜欢/在脸书给我们发消息</a>，或者简单地，<a class="ae lg" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank">发推文/DM @HackerNoon。</a></p><p id="708a" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lg" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lg" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>