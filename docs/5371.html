<html>
<head>
<title>Top Common Mistakes of Angular Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular开发人员的常见错误</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/top-common-mistakes-of-angular-developers-2a36524f2c21?source=collection_archive---------0-----------------------#2017-07-23">https://medium.com/hackernoon/top-common-mistakes-of-angular-developers-2a36524f2c21?source=collection_archive---------0-----------------------#2017-07-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="2baf" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">失败是成功的关键；每个错误都教会我们一些东西</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/5f625f8e290a6104f19b5802a419b5dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PcqMKjNMqJQWBEB0FCBXEQ.jpeg"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Image credit for theconversation.com</figcaption></figure><p id="e748" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><strong class="kb hv"> <em class="kv">这篇</em>文章</strong> <strong class="kb hv"> <em class="kv">原本出现在</em></strong><a class="ae kw" href="https://dormoshe.io/articles/top-common-mistakes-of-angular-developers-17" rel="noopener ugc nofollow" target="_blank"><strong class="kb hv"><em class="kv">dormoshe . io</em></strong></a></p><p id="f503" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">Angular是一个新的平台。我们学习如何使用它，如何优化应用程序以及如何改进我们的代码。作为团队成员的一部分，我们进行代码审查，并努力提高彼此的技能。作为代码评审和阅读web上代码示例的一部分，我注意到Angular开发人员的一些常见错误。<strong class="kb hv">可以是初级开发人员，也可以是专家开发人员，我们都会在代码中犯错误</strong>。</p><p id="3535" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在这篇文章中，我们将涵盖最常见的错误，我们将了解如何修复它们。每一个都可以成为整篇文章的灵感来源。我们将简要但详尽地讨论它们。</p></div><div class="ab cl kx ky hc kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hn ho hp hq hr"><h1 id="0a02" class="le lf hu bd lg lh li lj lk ll lm ln lo ja lp jb lq jd lr je ls jg lt jh lu lv dt translated">先说术语——角度对角度2对角度4对角度x+😅</h1><p id="3443" class="pw-post-body-paragraph jz ka hu kb b kc lw iv ke kf lx iy kh ki ly kk kl km lz ko kp kq ma ks kt ku hn dt translated">新Angular不仅仅是Angular的新版本。这是对框架的改写。所以现在我们有旧的Angular 1和Angular 2和Angular 4，在不久的将来还有Angular 5。但是角度2和角度4之间的变化不如角度1和角度2之间的变化。Angular 4不是重写。这是Angular 2的新版本，有错误修复和新功能。实际上，在语义版本化方法中，每六个月我们就会得到Angular的新版本。所以，在所有的新版本中，术语是混乱的。在Google里搜索学习资料，Stack Overflow里的问题或者只是和伙伴聊聊，都不太方便。为了解决这个令人沮丧的问题，Angular团队决定了名称术语。<strong class="kb hv">旧的Angular，Angular 1，叫AngularJS，新的Angular 2/2+/4/5叫Angular </strong>，就叫Angular。</p><p id="4726" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">另一个术语变化是第三方库名称。有时，一个库被称为前缀<code class="eh mb mc md me b">ng-</code>。当Angular版本2发布时，库开始使用前缀<code class="eh mb mc md me b">ng2-</code>。Angular版本4发布时，出现了新的术语趋势。术语是使用<code class="eh mb mc md me b">ngx-</code>前缀，因为Angular使用语义版本化，每六个月就会发布一个新版本。所以，比如说，<code class="eh mb mc md me b">ng2-bootstrap</code>的名字，改成了<code class="eh mb mc md me b">ngx-bootstrap</code>，以后也没有理由再改了。</p></div><div class="ab cl kx ky hc kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hn ho hp hq hr"><h1 id="1767" class="le lf hu bd lg lh li lj lk ll lm ln lo ja lp jb lq jd lr je ls jg lt jh lu lv dt translated">ngOnChanges vs ngDoCheck</h1><p id="a1ab" class="pw-post-body-paragraph jz ka hu kb b kc lw iv ke kf lx iy kh ki ly kk kl km lz ko kp kq ma ks kt ku hn dt translated">AngularJS具有<em class="kv">手表</em>功能，可在数值变化时发出通知。Angular放弃了监视和范围，现在我们有了作为属性的组件输入。此外，Angular给了我们<code class="eh mb mc md me b">ngOnChanges</code>生命周期钩子。为了提高更新的运行时间，当输入属性的深度字段改变时，<strong class="kb hv"/><code class="eh mb mc md me b"><strong class="kb hv">OnChanges</strong></code><strong class="kb hv">事件不会发出。</strong>在这种情况下，输入的值是对象的<strong class="kb hv">引用</strong>。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mf"><img src="../Images/692f89457fe2467b89fc13eeee999045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/0*HsFtDAR9WgM6Shlq.gif"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">The log entries appear as the string value of the <em class="mg">power</em> property changes. But the <code class="eh mb mc md me b">ngOnChanges</code> does not catch changes to <code class="eh mb mc md me b">hero.name</code></figcaption></figure><p id="3576" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">很多开发者不知道这一点，陷入了这个陷阱。要解决这个问题，有各种解决方案:</p><ul class=""><li id="d7ae" class="mh mi hu kb b kc kd kf kg ki mj km mk kq ml ku mm mn mo mp dt translated">使用<code class="eh mb mc md me b">ngDoCheck</code></li><li id="53ff" class="mh mi hu kb b kc mq kf mr ki ms km mt kq mu ku mm mn mo mp dt translated">使用不可变值作为输入</li><li id="56ae" class="mh mi hu kb b kc mq kf mr ki ms km mt kq mu ku mm mn mo mp dt translated">将输入值拆分为多个输入</li><li id="9ef1" class="mh mi hu kb b kc mq kf mr ki ms km mt kq mu ku mm mn mo mp dt translated">使用订阅</li></ul><p id="01f5" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><code class="eh mb mc md me b">ngDoCheck</code>生命周期挂钩是解决这个问题的常用方法。这个钩子在变化检测过程运行时被调用。您需要小心使用这个钩子，因为更改检测通常每分钟运行很多次。</p></div><div class="ab cl kx ky hc kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hn ho hp hq hr"><h1 id="6f84" class="le lf hu bd lg lh li lj lk ll lm ln lo ja lp jb lq jd lr je ls jg lt jh lu lv dt translated">僵尸订阅——缺乏退订</h1><p id="7405" class="pw-post-body-paragraph jz ka hu kb b kc lw iv ke kf lx iy kh ki ly kk kl km lz ko kp kq ma ks kt ku hn dt translated">当你在JavaScript中订阅一个可观察的or事件时，当你用完它时，需要<em class="kv"> </em>取消订阅来释放系统中的内存。否则，<strong class="kb hv">就会出现内存泄漏</strong>。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mv mw l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Example for unsubscribing in a component’s ngOnDestroy hook</figcaption></figure><p id="584b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">大多数情况下，当你订阅一个组件时，更好的退订位置是在<code class="eh mb mc md me b">OnDestroy</code>生命周期钩子中。当你订阅一项服务时，没有生命周期挂钩，所以你需要自己启动它。</p><p id="9961" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">缺少退订是因为开发人员不知道他们需要这样做，或者因为他们忘记退订。为了帮助我们解决这个问题，开发了<a class="ae kw" href="https://www.npmjs.com/package/ngx-auto-unsubscribe" rel="noopener ugc nofollow" target="_blank">库和</a>方法。</p></div><div class="ab cl kx ky hc kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hn ho hp hq hr"><h1 id="36a1" class="le lf hu bd lg lh li lj lk ll lm ln lo ja lp jb lq jd lr je ls jg lt jh lu lv dt translated">超额退订</h1><p id="23b2" class="pw-post-body-paragraph jz ka hu kb b kc lw iv ke kf lx iy kh ki ly kk kl km lz ko kp kq ma ks kt ku hn dt translated">除了僵尸订阅的错误，还有退订操作是Angular自动完成的情况。使用异步管道就是这种情况的一个例子。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mv mw l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Over unsubscription operation example</figcaption></figure><p id="073d" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">另一个例子可以是像<code class="eh mb mc md me b">Observable.timer(1000).subscribe(…)</code>和<code class="eh mb mc md me b">http.get(‘http://medium.com’).subscribe(…)</code>这样的有限订阅。</p><p id="87fd" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">有Rxjs的方法可以自行取消订阅。比如take(n)，takeWhile(谓词)，first()和first(谓词)就是其中的一些。所以，<strong class="kb hv">你需要小心退订的任务，知道这些方法是可行的，可以正确地完成这个任务。</strong></p></div><div class="ab cl kx ky hc kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hn ho hp hq hr"><h1 id="c7ea" class="le lf hu bd lg lh li lj lk ll lm ln lo ja lp jb lq jd lr je ls jg lt jh lu lv dt translated">@ component . providers vs @ ng module . providers</h1><p id="59e7" class="pw-post-body-paragraph jz ka hu kb b kc lw iv ke kf lx iy kh ki ly kk kl km lz ko kp kq ma ks kt ku hn dt translated">作为Angular新机制的一部分，分层依赖注入，我们可以多次实例化一个服务，这与AngularJS不同。在旧的AngularJS中，服务是单件的。</p><p id="dc70" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">假设我们有一个英雄服务来获取我们可爱的英雄:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mv mw l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Hero service</figcaption></figure><p id="afda" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">正如我们所看到的，服务在构造函数中获取数据。还有，有一个方法<code class="eh mb mc md me b">getHeroes</code>可以获得英雄。一切都很好。</p><p id="513d" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在是英雄成分:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mv mw l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Wrong use of provider</figcaption></figure><p id="1114" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><code class="eh mb mc md me b">HeroComponent</code>在<code class="eh mb mc md me b">@Component.providers</code>数组中声明<code class="eh mb mc md me b">HeroesService</code>提供者，并将其注入构造函数中。这段代码的问题在于<strong class="kb hv">的每个</strong> <code class="eh mb mc md me b"><strong class="kb hv">HeroComponent</strong></code> <strong class="kb hv">实例都会实例化</strong> <code class="eh mb mc md me b"><strong class="kb hv">HeroesService</strong></code>的一个新实例。因此，由于分层的DI，服务将通过HTTP请求多次获取数据。</p><p id="202f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这个问题的解决方案是在<code class="eh mb mc md me b">@NgModule.providers</code>中声明服务:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mv mw l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Correct use of provider</figcaption></figure><p id="3194" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在，对于所有的<code class="eh mb mc md me b">HeroComponent</code>实例，提供者将只被实例化一次。发生这种情况是因为，<strong class="kb hv">当一个提供者在</strong> <code class="eh mb mc md me b"><strong class="kb hv">NgModule</strong></code> <strong class="kb hv">中声明时，它将是单例的，所有其他模块都将能够使用它</strong>。不需要在<code class="eh mb mc md me b">@NgModule.exports</code>数组中导出一个提供者。它会自动完成。</p></div><div class="ab cl kx ky hc kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hn ho hp hq hr"><h1 id="20f6" class="le lf hu bd lg lh li lj lk ll lm ln lo ja lp jb lq jd lr je ls jg lt jh lu lv dt translated">直接变异dom</h1><p id="f033" class="pw-post-body-paragraph jz ka hu kb b kc lw iv ke kf lx iy kh ki ly kk kl km lz ko kp kq ma ks kt ku hn dt translated">Angular不再是网络的框架。<strong class="kb hv">有角是一个平台。</strong>它的优势之一是允许我们将应用程序代码从渲染器中分离出来，这反过来使得编写可以在浏览器、服务器上执行的应用程序成为可能，甚至可以作为原生应用程序来执行。</p><p id="38c6" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">解耦也给了我们更多的能力，比如使用AOT(提前编译)或web workers。提前编译意味着在服务器构建时编译应用程序模板。可以使用AOT来代替浏览器中运行的标准JIT编译。当我们使用AoT时，不需要在我们的包中包含大的<code class="eh mb mc md me b">@angular/compiler</code>包，所以包的大小和加载时间更短。所以这是至关重要的。</p><p id="f699" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如果我们现在或将来想要使用这种能力，我们需要保持一些约束。其中之一就是不要直接使用jQuery、document object或者<code class="eh mb mc md me b">ElementRef.nativeElement</code>对DOM进行变异。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mv mw l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Mutate the dom directly — the bad way</figcaption></figure><p id="a604" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如您所见，<code class="eh mb mc md me b">doBadThings</code>方法有三行代码，演示了直接改变DOM的三种方法。第一行是jQuery。第二个是由<code class="eh mb mc md me b">ElementRef.nativeElement</code>，第三个是由全局<code class="eh mb mc md me b">document</code>对象。</p><p id="3d3f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">改变DOM的角度方法是通过<code class="eh mb mc md me b"><a class="ae kw" href="https://angular.io/api/core/Renderer2" rel="noopener ugc nofollow" target="_blank">Renderer2</a></code>服务(在v4中是Renderer，在v2中是Renderer)。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mv mw l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Mutate the dom via Renderer — the recommended way</figcaption></figure><p id="10a0" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这样，我们用三个参数调用渲染器的<code class="eh mb mc md me b">setElementProperty</code>。这个函数的目标是改变/增加一个元素的属性。三个参数是<code class="eh mb mc md me b">elementRef</code>实例、属性名和属性值。<code class="eh mb mc md me b">Renderer</code>是视图突变层的包装器。当我们在浏览器中时，将使用默认的渲染器。当应用程序在另一个平台上运行时，如电话，<strong class="kb hv">呈现器将被另一个合适的呈现器替换</strong>。这个渲染器需要实现渲染器类接口，并被DI机制作为默认渲染器类加入。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mx"><img src="../Images/f2d2c477b493836afe8f62d4ed99ec53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XQoiF9YAzXasHKAizyYPgw.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">“Don’t ever never” touch the DOM directly</figcaption></figure></div><div class="ab cl kx ky hc kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hn ho hp hq hr"><h1 id="feed" class="le lf hu bd lg lh li lj lk ll lm ln lo ja lp jb lq jd lr je ls jg lt jh lu lv dt translated">多次声明一个组件</h1><p id="f8a4" class="pw-post-body-paragraph jz ka hu kb b kc lw iv ke kf lx iy kh ki ly kk kl km lz ko kp kq ma ks kt ku hn dt translated">组件是角度应用程序中的常见构建块。每个组件都需要在<code class="eh mb mc md me b">NgModule</code>中声明，以便对视图可用。要指定一个组件是一个<code class="eh mb mc md me b">NgModule</code>的成员，您应该在<code class="eh mb mc md me b">@NgModule.declarations</code>数组中列出它。</p><p id="dea8" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><strong class="kb hv">不可能在多个</strong> <code class="eh mb mc md me b"><strong class="kb hv">NgModule</strong></code>中声明一个组件。如果一个组件在多个<code class="eh mb mc md me b">NgModule</code>中声明，Angular编译器将<code class="eh mb mc md me b">throw an error</code>。例如:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mv mw l"/></div></figure><p id="eff2" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如你所见，该组件在<em class="kv">heroes模块</em>和<em class="kv">another模块</em>中声明。在<strong class="kb hv">多个模块中需要相同的组件是可以的</strong>。当这种情况发生时，我们应该思考<strong class="kb hv">模块</strong>之间有什么关系。如果一个模块是另一个模块的子模块，解决方案将是:</p><ul class=""><li id="ae26" class="mh mi hu kb b kc kd kf kg ki mj km mk kq ml ku mm mn mo mp dt translated">通过子模块的<code class="eh mb mc md me b">NgModule.declaration</code>声明子模块中的HeroComponent</li><li id="5f7c" class="mh mi hu kb b kc mq kf mr ki ms km mt kq mu ku mm mn mo mp dt translated">通过子级的<code class="eh mb mc md me b">NgModule.exports</code>数组导出HeroComponent</li><li id="4c8d" class="mh mi hu kb b kc mq kf mr ki ms km mt kq mu ku mm mn mo mp dt translated">通过父模块的<code class="eh mb mc md me b">NgModule.imports</code>数组导入子模块</li></ul><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mv mw l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Parent-child modules relation</figcaption></figure><p id="0203" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如果不是这样，我们需要声明另一个<code class="eh mb mc md me b">NgModule</code>，它将是共享材料的<strong class="kb hv">模块。解决方案将是:</strong></p><ul class=""><li id="2908" class="mh mi hu kb b kc kd kf kg ki mj km mk kq ml ku mm mn mo mp dt translated">在共享模块中声明并导出HeroComponent</li><li id="01ce" class="mh mi hu kb b kc mq kf mr ki ms km mt kq mu ku mm mn mo mp dt translated">在两个模块中导入共享模块</li></ul><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mv mw l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Shared module solution</figcaption></figure></div><div class="ab cl kx ky hc kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hn ho hp hq hr"><h1 id="5a90" class="le lf hu bd lg lh li lj lk ll lm ln lo ja lp jb lq jd lr je ls jg lt jh lu lv dt translated">结论</h1><p id="2995" class="pw-post-body-paragraph jz ka hu kb b kc lw iv ke kf lx iy kh ki ly kk kl km lz ko kp kq ma ks kt ku hn dt translated">犯错没关系。我们所有人都这样做。即使我们写了一堆代码，后来看了，有时候也不明白为什么代码是那样写的。</p><blockquote class="my"><p id="1cbc" class="mz na hu bd nb nc nd ne nf ng nh ku ek translated">视而不见是致命的错误——从错误中学习</p></blockquote><p id="6965" class="pw-post-body-paragraph jz ka hu kb b kc ni iv ke kf nj iy kh ki nk kk kl km nl ko kp kq nm ks kt ku hn dt translated"><strong class="kb hv">大错特错就是看到了错误而视而不见。</strong>作为开发人员，我们总是需要提高我们的技能。犯错是成为更强更好的开发者的最好方法之一。我们需要把错误作为旁注写下来，也许写在一个检查表中，我们应该确保在下一次中<strong class="kb hv">，代码将被正确地编写。</strong></p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff nn"><img src="../Images/522b2e4ace3cfcecd43bba30fcf0a317.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*cA1Y2VmIvRnUJUvjUPNZ2A.png"/></div></figure><p id="4bf7" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><strong class="kb hv"> <em class="kv">您可以关注我的</em></strong><a class="ae kw" href="https://www.dormoshe.io" rel="noopener ugc nofollow" target="_blank"><strong class="kb hv"><em class="kv">dormo she . io</em></strong></a><strong class="kb hv"><em class="kv">或</em></strong><a class="ae kw" href="https://twitter.com/DorMoshe" rel="noopener ugc nofollow" target="_blank"><strong class="kb hv"><em class="kv">Twitter</em></strong></a><strong class="kb hv"><em class="kv">阅读更多关于Angular、JavaScript和web开发的内容。</em> </strong></p></div></div>    
</body>
</html>