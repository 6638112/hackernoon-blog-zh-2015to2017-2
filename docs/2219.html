<html>
<head>
<title>The fundamental principles behind MobX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MobX背后的基本原则</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-fundamental-principles-behind-mobx-7a725f71f3e8?source=collection_archive---------0-----------------------#2017-01-13">https://medium.com/hackernoon/the-fundamental-principles-behind-mobx-7a725f71f3e8?source=collection_archive---------0-----------------------#2017-01-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="3162" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">几周前<a class="ae jp" href="https://twitter.com/solkimicreb1" rel="noopener ugc nofollow" target="_blank"> Bertalan Miklos </a>写了一篇非常有趣的<a class="ae jp" href="http://www.nx-framework.com/blog/public/mobx-vs-nx/" rel="noopener ugc nofollow" target="_blank">博客</a>，其中他将基于代理的NX-framework与<a class="ae jp" href="https://hackernoon.com/tagged/mobx" rel="noopener ugc nofollow" target="_blank"> MobX </a>进行了比较。这个博客很有趣，不仅因为它证明了代理的可行性，更因为它触及了MobX和透明反应(自动反应)的一些基本概念。到目前为止，我可能没有详细阐述这些概念。因此，让我来分享MobX的一些独特功能背后的心智模型。</p><h1 id="68db" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">为什么MobX同步运行所有派生</h1><p id="a199" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">这篇文章触及了MobX的一个非常显著的特性(imho ):在MobX中，所有的派生都是同步运行的。这很不寻常。大多数UI框架不这样做(如果有的话)。(像RxJS这样的反应式流库在默认情况下也是同步运行的，但是它们缺乏透明的跟踪，所以情况并不完全可比)。</p><p id="1e85" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在启动MobX之前，我对开发人员如何看待现有的库做了一些研究。像Meteor，Knockout，Angular，Ember和Vue这样的框架都暴露了类似于MobX的反应行为。它们已经存在很长时间了。那么我为什么要造MobX呢？当挖掘对这些库不满意的人的问题和评论时，我想到了一个反复出现的主题，它导致了反应承诺和实践中必须处理的令人讨厌的问题之间的鸿沟。</p><p id="04b6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个反复出现的主题是“可预测性”。如果一个框架运行你的代码两次，或者有延迟，调试它就变得很困难。或者去思考它。即使是“简单”的抽象，比如承诺，也因其异步性而难以调试。</p><p id="395c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我相信不可预测性理所当然是Flux模式流行的最重要的原因之一，尤其是Redux:它正好解决了扩展时的可预测性问题。工作中没有神奇的调度程序。</p><p id="b3cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而MobX采取了另一种方法；它没有抛弃自动跟踪和运行功能的整个概念，而是试图解决根本原因。这样我们仍然可以从这种模式中获益。透明反应性是声明性的、高层次的、简洁的。它通过添加两个约束来实现这一点:</p><ol class=""><li id="c4a9" class="ku kv hu it b iu iv iy iz jc kw jg kx jk ky jo kz la lb lc dt translated">确保对于任何给定的突变集，任何受影响的派生都将精确地运行<em class="kt">一次</em>。</li><li id="a19e" class="ku kv hu it b iu ld iy le jc lf jg lg jk lh jo kz la lb lc dt translated">衍生是永不过时的，它们的效果对任何观察者来说都是显而易见的。</li></ol><p id="9756" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">约束1。解决所谓的“双重运行”问题。它确保如果一个派生值依赖于另一个派生值，这些派生以正确的顺序运行。以便它们不会意外地读取过时的值。在早先的<a class="ae jp" rel="noopener" href="/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254">博客文章中详细描述了这一过程。</a></p><p id="da30" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第二个约束；派生永远不会过时；有趣多了。它不仅防止了所谓的“故障”(暂时的不一致)。它需要一种完全不同的方法来安排推导。</p><p id="0468" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="kt">到目前为止，UI库在调度派生时总是采取简单的方法:将派生标记为脏，并在所有状态更新后的下一个时钟周期重新运行它们。</em></p><p id="2f13" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是简单明了的。如果您唯一关心的是更新DOM，这是一个很好的方法。DOM通常有点“滞后”,我们很难通过编程从它那里读取数据。所以暂时的陈旧并不是一个真正的问题。然而暂时的陈旧扼杀了反应式库的普遍适用性。以下面的片段为例:</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="e3bc" class="lr jr hu ln b fv ls lt l lu lv">const user = observable({<br/>  firstName: “Michel”,<br/>  lastName: “Weststrate”,</span><span id="1b63" class="lr jr hu ln b fv lw lt l lu lv">  // MobX computed attribute<br/>  fullName: computed(function() {<br/>    return this.firstName + " " + this.lastName<br/>  })<br/>})</span><span id="e9f5" class="lr jr hu ln b fv lw lt l lu lv">user.lastName = “Vaillant”<br/>sendLetterToUser(user)</span></pre><p id="42a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在有趣的问题是:当<code class="eh lx ly lz ln b">sendLetterToUser(user)</code>运行时，它会看到用户的<code class="eh lx ly lz ln b">fullName</code>的一个<em class="kt">更新的</em>还是一个<em class="kt">陈旧的</em>版本？当使用MobX时，答案总是“更新”:因为MobX保证任何派生都是同步更新的。这不仅防止了许多令人讨厌的意外，还使调试更加简单，因为派生在其堆栈中总是有引起突变的原因。</p><p id="b71a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，如果您想知道为什么派生正在运行，只需在堆栈中向上走，就可以回到导致派生无效的操作。如果MobX使用异步调度/派生处理，这些优势就失去了。该库不会像已知的那样普遍适用。</p><p id="8063" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我开始使用MobX时，有很多人怀疑这样做是否足够有效:对派生树进行排序，并对每个变异运行派生。</p><p id="b557" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="kt">但在我们这里，开箱即用的系统通常比手动优化的代码更高效，例如这里报道的</em><a class="ae jp" rel="noopener" href="/@lavrton/how-to-optimise-rendering-of-a-set-of-elements-in-react-ad01f5b161ae#.6nhaj6npf"><em class="kt"/></a><em class="kt">和</em> <a class="ae jp" href="https://hackernoon.com/an-artificial-example-where-mobx-really-shines-and-redux-is-not-really-suited-for-it-1a58313c0c70#.42tpw3uw9" rel="noopener ugc nofollow" target="_blank"> <em class="kt">这里报道的</em> </a> <em class="kt">。</em></p><h1 id="c8cc" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">交易和活动</h1><p id="80a4" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">是的，有一个小的回报要付出；变异应该被分组到<em class="kt">事务</em>中，以原子方式处理多个变化。事务将派生的执行推迟到事务的末尾，但仍然同步运行它们。甚至更酷；如果您在事务结束之前使用了一个计算值，MobX将确保您获得该派生的一个更新值！</p><p id="ddb0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">实际上没有人明确地使用事务，它们甚至在MobX 3中被否决了。因为<a class="ae jp" rel="noopener" href="/@mweststrate/mobx-2-2-explicit-actions-controlled-mutations-and-improved-dx-45cdc73c7c8d?source=user_profile---------14----------"> <em class="kt">动作</em> </a>自动应用交易。动作在概念上更好；动作表示将<em class="kt">更新</em>状态的功能。它们是反应的逆过程，即<em class="kt">响应</em>状态更新。</p><figure class="li lj lk ll fq mb fe ff paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="fe ff ma"><img src="../Images/fe38a41ae2392f7d2dcfcddcd0727acb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WbbVajRYZqTxv-XClDgySw.png"/></div></div><figcaption class="mi mj fg fe ff mk ml bd b be z ek">The conceptual relation between actions, state, computed values and reactions</figcaption></figure><h1 id="894e" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">计算值和反应</h1><p id="ca26" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">MobX非常关注的另一件事是可以导出的值(<em class="kt">计算值</em>)和状态改变时应该自动触发的副作用(<em class="kt">反应</em>)之间的分离。这些概念的分离对于MobX来说是非常重要和基础的。</p><figure class="li lj lk ll fq mb fe ff paragraph-image"><div class="fe ff mm"><img src="../Images/e25e6e4e312db454441f13207d9cd259.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*ENADyv0To2mqpYnzHuSNJg.png"/></div><figcaption class="mi mj fg fe ff mk ml bd b be z ek">Example derivation graph. Observable state(blue), computed values (green) and reactions (red). Computed values will suspend (light green) if not observed (indirectly) by a reaction. MobX makes sure that each derivation runs only once and in the most optimal order after a mutation.</figcaption></figure><p id="ad00" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="kt">计算值应始终优先于反应值。</em></p><p id="11c6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">出于几个原因:</p><ol class=""><li id="4058" class="ku kv hu it b iu iv iy iz jc kw jg kx jk ky jo kz la lb lc dt translated">它们提供了很多概念上的清晰性。计算值应该总是纯粹用其他可观察值来表示。这导致了一个清晰的计算衍生图，而不是一个相互触发的不清楚的反应链。</li><li id="8a13" class="ku kv hu it b iu ld iy le jc lf jg lg jk lh jo kz la lb lc dt translated">换句话说，触发更多反应的反应，或者更新状态的反应:它们都被认为是MobX中的反模式。连锁反应会导致一连串难以追踪的事件，应该避免。</li><li id="0499" class="ku kv hu it b iu ld iy le jc lf jg lg jk lh jo kz la lb lc dt translated">对于计算出的值，MobX可以确定它们是否在某处被使用。这意味着计算出的值可以自动挂起并被垃圾回收。这节省了大量的样板文件，并对性能产生了显著的积极影响。</li><li id="8a41" class="ku kv hu it b iu ld iy le jc lf jg lg jk lh jo kz la lb lc dt translated">计算值被强制为无副作用。因为计算值不允许有副作用，所以MobX可以安全地对计算值的执行顺序进行重新排序，以保证最少的重新运行。如果未被观察到，它可以决定仅延迟运行计算。</li><li id="4446" class="ku kv hu it b iu ld iy le jc lf jg lg jk lh jo kz la lb lc dt translated">计算值会自动缓存。这意味着，只要所涉及的可观察值没有发生变化，读取计算值就不会重新运行计算。</li></ol><p id="b970" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最终，每个软件系统都需要副作用。原因很简单，我们总是需要从反应式代码过渡到命令式代码。例如发出网络请求或刷新DOM。然而，通常这些反应可以放在干净的抽象中，比如React <code class="eh lx ly lz ln b">observer</code>组件。</p><p id="d4ea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以MobX竭尽全力确保陈旧值永远不会被发现，并且派生不会比预期的运行得更频繁。事实上，如果没有人积极观察，计算甚至根本不会运行。实际上，这一点非常重要。最初对MobX经常有一些抵制，因为这些概念让人们想起了MVVM框架不可预测的行为。然而，我相信动作、计算值和反应的语义清晰，观察不到陈旧值的事实，所有派生都在与引起动作相同的堆栈上运行的事实，在这里产生了所有的差异。</p></div><div class="ab cl mn mo hc mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hn ho hp hq hr"><h1 id="7f44" class="jq jr hu bd js jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn dt translated">代理和MobX</h1><p id="8bdd" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">MobX在生产中被大量使用，因此已经承诺在每个ES5环境上运行。这使得用MobX瞄准任何浏览器成为可能，但同时也使依赖代理成为不可接受的。由于这个原因，MobX有一些缺点，比如不完全支持expando属性和使用伪数组。众所周知，我们的计划一直是最终转向基于代理的实现。MobX 3已经为代理的使用做了一些准备，并且第一个基于代理的可选特性很快就会出现。然而，在绝大多数设备和浏览器支持之前，核心将保持代理免费。</p><h1 id="904c" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">浅层数据结构的情况</h1><p id="f531" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">不管将来是否会迁移到代理，修饰符/浅层可观察概念将会以某种形式保留在MobX中。</p><p id="deef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="kt">修改器机制的原因不是性能；就是互通。</em></p><p id="4392" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">只要应用程序状态下的所有数据都在您的控制之下，自动观察就非常方便。MobX正是从这一点开始的。但是在某个时候，你发现这个世界并不像你希望的那样理想。在每个应用程序中都有许多库，每个库都扮演着自己的角色，并做出自己的假设。在MobX中引入了修饰符和浅层集合，以便能够明确MobX可以管理哪些数据。</p><p id="13e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，有时您需要存储对外部概念的引用。然而，对于已经由一些外部库管理的对象(例如JSX或DOM元素)，自动转换为可观测量通常是不可取的。它很容易干扰该库的内部假设。人们可以在MobX问题跟踪器中发现一些问题，在这些问题中，将对象无意中变成可观察对象会导致意外的行为。修饰符并不意味着发出“请尽快”的信号，而是发出“只观察对对象的引用，将对象本身视为一个黑盒，因为它不在我们的控制之下”的信号。</p><p id="102e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个概念也非常适合处理不可变的数据结构。例如，它使得创建一个可观察的消息图成为可能，其中消息本身被认为是不可变的数据结构。</p><p id="c938" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第二个问题是，可自动观察的集合总是创建“克隆”，这并不总是可接受的。代理总是产生一个新的对象，它们只在“一个方向”上工作。因此，如果一个被代理对象的原始版本被最初发布它的库修改了，代理不会检测到这个变化。举例说明:</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="c088" class="lr jr hu ln b fv ls lt l lu lv">const target = { x: 3 }<br/>const proxy = createObservableProxy(target)</span><span id="9a41" class="lr jr hu ln b fv lw lt l lu lv">observe(() =&gt; {<br/> console.log(proxy.x)<br/>})</span><span id="79e9" class="lr jr hu ln b fv lw lt l lu lv">target.x = 4<br/>// proxy.x is now 4, but no log statement will be written, as the proxy setter hook is not fired!</span></pre><p id="6377" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">修饰符为处理这些情况提供了必要的灵活性。目前，由于MobX使用属性描述符，它实际上可以增强现有的对象，因此如果真正需要的话，数据突变可以在两个方向上工作。</p><p id="c5f4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也就是说，NX在读取期间动态生成可观察代理的方式非常有趣。我还不确定它是如何处理引用透明性的，但是到目前为止，这似乎是一个非常聪明的做法。通过读/写<code class="eh lx ly lz ln b">$raw</code>来避免修饰语是一个非常有趣的方法。我不确定它读起来或写起来是否更干净，但它肯定省去了一些概念的引入，比如shallow，这很棒。</p><h1 id="c7cf" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">未跟踪是做什么的？</h1><p id="b81e" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">需要注意一下<code class="eh lx ly lz ln b">untracked</code>的语义，不像建议的那样，它与NX中的<code class="eh lx ly lz ln b">$raw</code>更新无关。在MobX中，没有办法在不通知观察者的情况下更新数据。故意允许这种情况会在应用程序中引入陈旧数据的可能性。这违背了MobX的原则。人们有时认为他们需要这样的机制，但我从未遇到过没有概念上更清晰的解决方案的真实生活用例。</p><p id="3d2b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lx ly lz ln b">untracked</code>的工作方式正好相反:它不是关于不可检测的<em class="kt">写。</em>相反，它只是导致<em class="kt">读取</em>不被跟踪。换句话说，这就是说我们对我们使用的数据的任何未来更新都不感兴趣。像<code class="eh lx ly lz ln b">transaction</code>一样，没有人在实践中使用这个API，但它是一个嵌入到<em class="kt">动作</em>中的机制，因为它在概念上很有意义:动作响应(用户)事件而运行，而不是响应状态变化，所以它们不应该跟踪它们使用了哪些数据。这就是<em class="kt">反应</em>的作用。</p><h1 id="5521" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">结论</h1><p id="8a6e" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated"><em class="kt"> MobX旨在成为一个普遍适用的反应性库。它不仅仅是一个在适当的时候重新呈现UI的工具。</em></p><p id="3aeb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">相反，它概括了有效处理数据(在性能和工作量方面)的概念，这些数据只是一些其他数据的项目。例如，在Mendix 中，MobX也用于后端流程。同步运行派生以及计算值和反应之间的分离是MobX的基础。它使应用程序的状态有了一个更加清晰的印象。</p><p id="8323" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，nx-observe证明了代理是透明反应式编程库的非常可行的基础。无论是概念上还是性能上。</p><div class="li lj lk ll fq ab cb"><figure class="mz mb na nb nc nd ne paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mz mb na nb nc nd ne paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mz mb na nb nc nd ne paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="nf ng nh"><p id="f922" class="ir is kt it b iu iv iw ix iy iz ja jb ni jd je jf nj jh ji jj nk jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is kt it b iu iv iw ix iy iz ja jb ni jd je jf nj jh ji jj nk jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="li lj lk ll fq mb fe ff paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="fe ff nl"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="li lj lk ll fq mb"><div class="bz el l di"><div class="nm nn l"/></div></figure></div></div>    
</body>
</html>