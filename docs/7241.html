<html>
<head>
<title>Common pitfall in initialising state based on props in React JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React JS中基于props的初始化状态的常见缺陷</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/common-pitfall-in-initialising-state-based-on-props-in-react-js-d56795a944aa?source=collection_archive---------4-----------------------#2017-10-21">https://medium.com/hackernoon/common-pitfall-in-initialising-state-based-on-props-in-react-js-d56795a944aa?source=collection_archive---------4-----------------------#2017-10-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/b2dd7a3eb37c52d6cd856eb5e03b7a34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EjHABzqbwHBPBP_xPRP_4A.png"/></div></div></figure><p id="b0fe" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最近我在做<a class="ae ka" href="https://hackernoon.com/tagged/react-js" rel="noopener ugc nofollow" target="_blank"> React JS </a>项目时遇到了这个问题，当时我正在通过props将父<a class="ae ka" href="https://hackernoon.com/tagged/component" rel="noopener ugc nofollow" target="_blank">组件</a>状态的一部分传递给子组件。然后我用这个道具来设置我的子组件的初始状态(在做了一些其他的计算之后)。因此，问题是当父组件在状态改变时重新呈现时，子组件没有用更新的状态值呈现。比如说—</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="f1e5" class="kk kl hu kg b fv km kn l ko kp">// our child component<br/>class ChildComponent extends Component {<br/>    constructor(){<br/>        super(props);<br/>        this.state = { count:this.props.value };<br/>    }<br/>    <br/>    render(){<br/>        return(<br/>            &lt;div&gt;<br/>                &lt;p&gt;I have {this.state.count} candies!&lt;/p&gt;<br/>            &lt;/div&gt;<br/>        );<br/>     }<br/>}</span><span id="0000" class="kk kl hu kg b fv kq kn l ko kp">// In parent component</span><span id="dbe9" class="kk kl hu kg b fv kq kn l ko kp">// Assuming this.state.value = 5<br/>//This will render correctly "I have 5 candies!"<br/>&lt;ChildComponent value = {this.state.value} /&gt;</span><span id="7132" class="kk kl hu kg b fv kq kn l ko kp">// Now parent state "value" changed to 10<br/>// This time child will again render "I have 5 candies!"<br/>&lt;ChildComponent value = {this.state.value} /&gt;  </span></pre><h2 id="3c5c" class="kk kl hu bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated">为什么会这样呢？</h2><p id="e0e5" class="pw-post-body-paragraph jc jd hu je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">组件的构造函数只执行一次，当组件被挂载的时候。当组件重新渲染时，它不会被执行。当父组件被重新渲染时，它不会破坏和重新创建子组件。React将<a class="ae ka" href="https://reactjs.org/docs/reconciliation.html" rel="noopener ugc nofollow" target="_blank">重用</a>之前渲染的子组件，并且不运行构造函数。</p><p id="a36c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为我们只在构造函数中设置子组件的状态，当子组件重新渲染时，不会调用这个构造函数。因此，即使在从父组件接收到新的属性时重新呈现子组件，状态也不会更新。这就是为什么子组件中的state“count”的值仍然是“5”。</p><h2 id="cd2b" class="kk kl hu bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated">救援时组件将收到道具</h2><p id="d4be" class="pw-post-body-paragraph jc jd hu je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">来自React官方文档</p><blockquote class="lp lq lr"><p id="ef67" class="jc jd ls je b jf jg jh ji jj jk jl jm lt jo jp jq lu js jt ju lv jw jx jy jz hn dt translated"><code class="eh lw lx ly kg b">componentWillReceiveProps()</code>在一个挂载的组件接收新的道具之前被调用。如果您需要更新状态以响应属性更改(例如，重置它)，您可以比较<code class="eh lw lx ly kg b">this.props</code>和<code class="eh lw lx ly kg b">nextProps</code>，并在此方法中使用<code class="eh lw lx ly kg b">this.setState()</code>执行状态转换</p></blockquote><p id="7a05" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> nextProps </strong>是从父组件接收的最新属性。</p><p id="6615" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将使用这种生命周期方法，并在子组件收到来自父组件的新道具时更新它的状态。我们将比较当前Props值和下一个props值，如果它们不同，我们将使用<strong class="je hv"> setState() </strong>方法更新子组件的状态。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="bffd" class="kk kl hu kg b fv km kn l ko kp"> class ChildComponent extends Component {</span><span id="56a3" class="kk kl hu kg b fv kq kn l ko kp">    constructor(){ ... }</span><span id="f998" class="kk kl hu kg b fv kq kn l ko kp">    componentWillReceiveProps(nextProps){<br/>        if(nextProps.value !== this.props.value){<br/>            this.setState({count:nextProps.value});<br/>        }<br/>    }</span><span id="5a56" class="kk kl hu kg b fv kq kn l ko kp">    render(){...}<br/>}</span></pre><p id="2792" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">尽管这种解决方案是可行的，但React推荐了一种不同的方法，您可能想看看。称为<a class="ae ka" href="https://reactjs.org/docs/lifting-state-up.html" rel="noopener ugc nofollow" target="_blank">提升状态上升</a>。</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="lz ma l"/></div></figure></div></div>    
</body>
</html>