<html>
<head>
<title>Writing Clean and Concise React Components by Making Full Use of ES6/7 Features and the Container-Component Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过充分利用ES6/7特性和容器-组件模式，编写简洁明了的React组件</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/writing-clean-and-concise-react-components-by-making-full-use-of-es6-7-features-and-the-container-4ba0473b7b01?source=collection_archive---------2-----------------------#2017-06-28">https://medium.com/hackernoon/writing-clean-and-concise-react-components-by-making-full-use-of-es6-7-features-and-the-container-4ba0473b7b01?source=collection_archive---------2-----------------------#2017-06-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="286b" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">故事到此为止</h1><p id="a884" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">如果像我一样，你曾经使用普通的旧HTML或模板、预处理CSS和JavaScript的“标准”工具创建过一个网站，那么当React出现并提供一种方法来轻松地将网站或应用分成可管理、可重用的块时，你可能也和我一样高兴。</p><p id="782f" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">这也发生在JavaScript极度成熟的时候，从一些人认为的“玩具语言”到今天最流行的语言之一。在<em class="kt">承诺</em>出现后，我们可以忘记写横向金字塔，让自己进入回调地狱。然后出现了<em class="kt"> async/await </em>，现在我们大多数人尽可能避免那些“混乱和令人困惑”的承诺链。我们被宠坏了，真的，因为选择。</p><p id="225d" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">然后出现了通量，在Redux之后。状态管理变得简单多了，尽管你可能并不总是需要它，Redux通常是很多开发人员的首选状态管理工具。这一点点额外的初始设置通常会走很长的路，并在以后为我们省去了很多麻烦。</p><p id="1b89" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">由于语言发展如此之快，很难跟踪所有的新特性，所以这篇文章是关于如何最好地利用它们来改进你的组件而不牺牲任何东西的个人观点。</p><p id="bdc7" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">我应该在这里指出，在我所有的例子中，我将使用React Native，但是React中的原理是完全相同的…所以让我们开始吧！</p><h1 id="cd6c" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">容器组件模式</h1><p id="b232" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">这是一个非常简单的模式，使您能够充分利用React的可组合性，这可以简单地解释为您的容器处理功能并呈现您的组件，而您的组件则负责显示容器获取的数据。</p><p id="13d7" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">这里有一个容器:</p><figure class="ku kv kw kx fq ky"><div class="bz el l di"><div class="kz la l"/></div></figure><p id="c4e1" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">现在我知道你在想什么，那只是一个反应组件？你说得对。这里的关键是，容器组件与无状态组件完全分离，只关心数据，将任何相关的内容传递给组件进行渲染。</p><p id="b25d" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">组件应该只是一个无状态的功能组件。如果你以前没有听说过这个术语——它就像它的发音一样:一个组件是一个函数，没有状态。这里有一个简单的例子:</p><figure class="ku kv kw kx fq ky"><div class="bz el l di"><div class="kz la l"/></div></figure><p id="894a" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">一个经常被忽视的好处是这种模式本质上实施的双重PropType检查。当原始道具被传送到你的容器中时，你操纵的道具会被你的标记，除非你喜欢弯弯曲曲的红线，你会把它们添加到你的道具类型检查中。对于其余的道具，您知道它们存在，但是您的容器没有业务处理，您应该将它们分散到您的组件中。您可以在上面的代码片段中看到这一点，其中button对象被扩展到Button组件中。</p><p id="e72f" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">这种模式提供的第二层安全来自于组件的PropType检查，你的第一层防御是容器的PropType检查，它只是检查传递的值是否是你所期望的。然后，您的组件可以检查容器中的道具是否被正确操作，如果没有这个模式，第二次检查将是不可能的。这是一个小的额外设置，随着应用程序的增长，问题会少很多。</p><p id="a27e" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">要更深入地了解这种模式，<a class="ae ks" rel="noopener" href="/@learnreact/container-components-c0e67432e005">请查阅本文</a>。</p><h1 id="0bc8" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">有用的ES6/7功能</h1><p id="65c2" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">在本文的这一部分，我将讨论如何利用ECMAScript标准的最新特性，这些特性可以让您的生活更轻松，让您的代码看起来更轻松。</p><h2 id="8836" class="lb is hu bd it lc ld le ix lf lg lh jb ka li lj jf ke lk ll jj ki lm ln jn lo dt translated">类别属性</h2><p id="5f91" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">ES最简单的一个新特性也是我最喜欢的一个。这个简单的特性允许你经常在你的类中去掉构造方法。那是什么呢？简而言之，类属性允许在类的任何方法之外定义类属性。</p><p id="79d8" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">为了向您展示这一简单特性的好处，这里有一个不使用类属性的组件:</p><figure class="ku kv kw kx fq ky"><div class="bz el l di"><div class="kz la l"/></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek">Yikes</figcaption></figure><p id="9fc3" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">这是完全相同的组件，但具有类属性:</p><figure class="ku kv kw kx fq ky"><div class="bz el l di"><div class="kz la l"/></div></figure><p id="be0d" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">通过将这一特性与其他更著名的ES新特性(如arrow函数，它不会打开新的上下文)相结合，我们成功地从容器文件中删除了三分之一的行。我们不再需要构造函数，也不需要将类方法的上下文绑定到类的上下文。</p><p id="74f6" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">我也将利用这个空间来解释我的一个讨厌之处:人们在道具上不必要地调用super。不需要调用' super(props)'，<em class="kt">，除非需要在构造函数</em>里面使用' this.props '。React组件总是将“props”绑定到“this ”,它只是在组件生命周期中的构造函数之后发生。</p><h2 id="3cb4" class="lb is hu bd it lc ld le ix lf lg lh jb ka li lj jf ke lk ll jj ki lm ln jn lo dt translated">静态方法和属性</h2><p id="4d3b" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">紧随类属性之后的是静态方法和属性。使用静态方法，你可以使用类的一部分，而不必实例化该类的一个全新的实例。它们是通过引用未实例化的类后跟属性名来调用的，但是如果你在一个方法上使用static，这当然会阻止你访问该方法中的“this ”,因为该类尚未实例化。</p><p id="aeaa" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">这种益处如何对组件产生反应？嗯，除了向任何阅读你的代码的人清楚地表明不会使用“this”之外，你还可以用它在类体中引入propTypes和defaultProps。这纯粹是个人偏好，但在我看来，这比在定义了类之后跟踪PropType检查要好很多。这里有一个例子:</p><figure class="ku kv kw kx fq ky"><div class="bz el l di"><div class="kz la l"/></div></figure><h2 id="0792" class="lb is hu bd it lc ld le ix lf lg lh jb ka li lj jf ke lk ll jj ki lm ln jn lo dt translated">装修工</h2><p id="09b3" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">装饰者使用其他语言已经有一段时间了。JavaScript中的概念很简单；decorators提供了一种语法性感的方式来包装你的类和函数，并添加额外的功能。</p><p id="6086" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">React装饰器最常见的用例是使用React-Redux的connect函数作为装饰器。这个概念很简单，所以这里有几个例子来说明它们可以使您的代码更加优雅。</p><p id="b1df" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">没有装饰者:</p><figure class="ku kv kw kx fq ky"><div class="bz el l di"><div class="kz la l"/></div></figure><p id="12e2" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">有装修工:</p><figure class="ku kv kw kx fq ky"><div class="bz el l di"><div class="kz la l"/></div></figure><p id="1f5c" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">因为这只是包装某些东西的语法糖，它们可以被链接任意多次。在我看来，这是装饰者真正让你的代码漂亮得多的地方。</p><p id="9e87" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">没有装饰者:</p><figure class="ku kv kw kx fq ky"><div class="bz el l di"><div class="kz la l"/></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek">Yo dawg… I heard you like to wrap functions</figcaption></figure><p id="0548" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">有装修工:</p><figure class="ku kv kw kx fq ky"><div class="bz el l di"><div class="kz la l"/></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek">That’s more like it</figcaption></figure><h2 id="5b5d" class="lb is hu bd it lc ld le ix lf lg lh jb ka li lj jf ke lk ll jj ki lm ln jn lo dt translated">物体扩散+生成道具</h2><p id="2954" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">对象扩展是ES中比较有名的新特性之一，所以我不会过多地谈论它，我只想向您展示我是如何使用它的。我应该提到的是，我将要向你们展示的“生成道具”方法是我的同事的想法，自从他第一次向我展示以来，我就无耻地采用了这个想法。</p><p id="8f7b" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">那么什么是对象传播呢？简单地说，它在顶层将一个对象的所有属性一个接一个地分配给另一个对象。想想Object.assign。这种语法现在已经变得无处不在，所以每当你在一个对象或数组中看到一个变量的前缀'…'时，你看到的是spread操作符。数组扩展、对象扩展、对象rest扩展和rest参数都使用相同的'…'语法。然而，对象静止扩散和静止参数有一点不同，所以我不会在这里深入讨论。</p><p id="94a3" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">那么什么是生成道具呢？这是一个将道具从容器传递到组件的小技巧。这不是什么开创性的东西，但是它确实提供了一种方法，可以清楚地看到你正在传递的道具，并在传递之前对它们进行一些小的操作。这个想法很简单，有一个函数返回你所有的道具，然后将这些道具分散到你的组件中，以避免在你的渲染方法中有一大堆杂乱的JSX。不幸的是，除非您使用容器组件模式，否则使用generate props将不起作用，您将在下面的示例中看到这一点。</p><p id="2a60" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">使用这种方法不一定会缩短代码，但是它确实比传统的传递属性的方法有一些优势。首先，你想作为道具传递的所有东西都被传播到生成道具中，生成道具的结果被传播到你的组件中，所以一旦它们都被链接起来，你就可以自由地沿着组件链传递道具，而不必打开中间组件。现在，值得一提的是，深入传递道具并不推荐，但有时这是不可避免的。第二，你有一个很好的对象表示你传递的道具，减少了JSX，给你传递的道具一个单一的参考点。你也可以在任何其他物体上自由传播，比如你所在的州。</p><p id="d668" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">值得注意的是，这可能会导致一些多余的道具被传递下去，但是随着函数式编程的出现，为了提高代码的重用性和可读性，除了其他好处之外，预计会有一些较小的(但不明显的)性能影响。</p><p id="75ee" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">再一次，让我们看一个有和没有的例子。</p><p id="cc61" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">不生成道具:</p><figure class="ku kv kw kx fq ky"><div class="bz el l di"><div class="kz la l"/></div></figure><p id="0b42" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">并使用生成道具:</p><figure class="ku kv kw kx fq ky"><div class="bz el l di"><div class="kz la l"/></div></figure><p id="7e77" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">与我在本文中提到的其他事情相比，这确实是个人偏好。</p><h1 id="529b" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">概括起来</h1><p id="9b23" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">JavaScript和围绕React的生态系统正在飞速发展。这只是一个例子，说明了我如何使用提供的一些新特性来使编码更有趣，并减少编写复杂应用程序时涉及的大量样板文件。</p></div><div class="ab cl lt lu hc lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hn ho hp hq hr"><h1 id="d450" class="ir is hu bd it iu ma iw ix iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo dt translated">推特:<a class="ae ks" href="https://twitter.com/josh_jahans" rel="noopener ugc nofollow" target="_blank"> @josh_jahans </a></h1></div></div>    
</body>
</html>