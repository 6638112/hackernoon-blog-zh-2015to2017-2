<html>
<head>
<title>Use TypeScript Generics to Build a Simple Yet Strongly Typed Cache Utility</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TypeScript泛型构建一个简单但强类型的缓存实用工具</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/use-typescript-generics-to-build-a-simple-yet-strong-typed-cache-utility-9f3c11d0399d?source=collection_archive---------16-----------------------#2017-01-30">https://medium.com/hackernoon/use-typescript-generics-to-build-a-simple-yet-strong-typed-cache-utility-9f3c11d0399d?source=collection_archive---------16-----------------------#2017-01-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="5a4f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们经常构建缓存来提高最终用户的实际和感知应用性能。本文描述了TS语言的一个特性——泛型——如何帮助我们构建缓存。</p><p id="8a79" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">构建缓存(以及任何类型的通用服务实用程序)时，您需要做的第一件事是定义它的公共接口。在其核心，一个典型的缓存有一些方法来存储和检索值。一个更全功能的缓存也可以让你检查缓存，从缓存中清除一个或多个项目，但是为了这篇文章，我们说我们只有两件事要做:<strong class="it hv"> Put </strong>和<strong class="it hv"> Get </strong>。</p><p id="50ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们来考虑一下看跌期权。当我们将一个项目放入缓存时，我们通常希望为该项目分配一个生存期。这是物品有效的时间窗口<strong class="it hv"> * </strong>。我们最终将从缓存中检索项目，为了做到这一点，我们需要某种方法来唯一地标识缓存的项目。我们称这个唯一的身份为物品的<strong class="it hv">键</strong>。把这些放在一起，我们就有了一个可行的Put函数签名:</p><blockquote class="jp jq jr"><p id="6dc5" class="ir is js it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt translated">public Put(key: string，data: any，lifetimeInMilliseconds:number):void</p></blockquote><p id="e69b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有了<strong class="it hv">得到</strong>，事情就有趣多了。正如您所看到的，当我们将数据放入缓存时，它是“任何”时间。这很好，因为缓存与其缓存的数据类型无关(至少在理论上如此)。如果我们不进一步，我们会得到这样的Get签名:</p><blockquote class="jp jq jr"><p id="4906" class="ir is js it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt translated">public Get(key: string): any</p></blockquote><p id="6108" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用泛型我们可以在TypeScript中做得更好。我们可以用一个泛型类型来修饰Get()，并告诉它我们期望检索的实际数据类型。看起来是这样的:</p><blockquote class="jp jq jr"><p id="33a5" class="ir is js it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt translated">public Get <t> (key:string) : T</t></p></blockquote><p id="8aae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是在告诉TypeScript编译器，我们将针对缓存发出一个<strong class="it hv"> Get </strong>。然而，我们也要告诉它，我们已经知道/期望响应的数据类型:“T”。</p><p id="4629" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">想象一下，如果我们缓存了两个对象，一个名为“UserProfile ”,另一个名为“FavoriteItem”。对于<a class="ae jw" href="https://hackernoon.com/tagged/typescript" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>泛型，我这样做:</p><blockquote class="jp jq jr"><p id="0b70" class="ir is js it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt translated">const cached profile = cache service。get<userprofile>(“some key”)；<br/>const cached aves = cacheService。get&lt;favorite item[]&gt;(“someOhterKey”)；</userprofile></p></blockquote><p id="57c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为我们现在告诉Get我们在第一种情况下期望一个UserProfile，在另一种情况下期望一个FavoriteItem数组，所以相应的const vars现在是强类型的。</p><p id="8cd2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个非常基本的例子，泛型可以走得更远。例如，一般来说，考虑JS对象实际上是复杂的东西。在我编写的真实缓存实用程序中，我的可缓存对象很简单——它们只保存数据。它们没有自己的函数或包含其他嵌套对象。因此，我可以使用JSON.stringify()和JSON.parse()安全地序列化和反序列化它们。这对于更复杂的对象来说还不够好。使用泛型，我们可以告诉TypeScript，我们只允许使用实现智能Serialize()和Deserialize()方法的<t>。代码应该是这样的:</t></p><blockquote class="jp jq jr"><p id="32da" class="ir is js it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt translated">公共Put <t extends="" serializable=""> (key: string，data: T，lifetime:number)；<br/> public Get &lt; T扩展Serializable&gt;(key:string):T；</t></p></blockquote><p id="3a73" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在运行时，TS编译器不让我们在对象上使用这种特殊的缓存服务，除非它们实现了一个名为“Serializable”的接口。</p><p id="dffd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你想了解更多这方面的内容，可以看看我之前写的这篇文章:<a class="ae jw" rel="noopener" href="/@pagalvin/implement-binary-search-in-typescript-using-generics-with-useful-refactorings-a4bcda932d7#.tv0of7jdo">https://medium . com/@ pagal vin/implement-binary-search-in-typescript-using-generics-with-used-refactorings-a 4 bcda 932d 7 # . TV 0 of 7 jdo</a>。</p><p id="67eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">泛型给了我们一个很好的工具<a class="ae jw" href="https://hackernoon.com/tagged/tool" rel="noopener ugc nofollow" target="_blank">来告诉TypeScript编译器我们期望数据在运行时是什么样子。这反过来又给了它所需要的信息，以便提供强大的智能感知和其他开发时的好处来帮助我们提高工作效率。</a></p><p id="c5fd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(*)利用时间活着只是众多选择之一。这句话很贴切:</p><blockquote class="jp jq jr"><p id="e212" class="ir is js it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt translated"><em class="hu">计算机科学只有两个硬东西:缓存失效和事物命名。</em></p><p id="c48b" class="ir is js it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt translated"><em class="hu"> —菲尔·卡尔顿</em></p></blockquote><p id="4013" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"/><blockquote class="jp jq jr"><p id="a897" class="ir is js it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt translated"><a class="ae jw" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是AMI家庭的一员。我们现在<a class="ae jw" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jw" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is js it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt translated">要了解更多信息，<a class="ae jw" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">请阅读我们的“关于”页面</a> , <a class="ae jw" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">喜欢/在脸书给我们发消息</a>，或者简单地说，<a class="ae jw" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is js it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jw" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jw" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jx jy jz ka fq kb"><div class="bz el l di"><div class="kc kd l"/></div></figure></div></div>    
</body>
</html>