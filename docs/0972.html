<html>
<head>
<title>Functional Computational Thinking — What is a monad?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">功能计算思维——什么是单子？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/functional-computational-thinking-what-is-a-monad-2adea91154e?source=collection_archive---------0-----------------------#2016-07-31">https://medium.com/hackernoon/functional-computational-thinking-what-is-a-monad-2adea91154e?source=collection_archive---------0-----------------------#2016-07-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="5eaf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你正在使用函数式<a class="ae jp" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>，无论是使用真正的函数式语言还是任何支持一级函数的语言，你可能在某个时候已经使用过单子了。大多数人只是不知道他们是单子。在这篇文章中，我将不用任何数学定理来解释什么是单子。此外，我将演示如何仅使用普通的<a class="ae jp" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>来派生monad。</p><p id="0267" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">警告:这是一个高级主题。可能不适合初学者。<br/>免责声明:本文不会提供单子的确切定义。所以有关于单子的考试就不要看了。</p><p id="f657" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我学习Haskell已经有半年了。我喜欢看youtube上的会议/聚会视频。有一天，我看了一个视频，叫《让我们成为主流吧！ELM的创建者Evan Czaplicki说“monad是回调”。我以为我明白了什么是单子，但我不明白为什么埃文说。这是那个视频的链接，如果你愿意，你可以在完成这篇文章后查看。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="jv jw l"/></div></figure><p id="f281" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">几个星期过去了，在阅读了大量的学习材料之后，尤其是在看了德里克·赖特的《单子为什么重要》之后。在这个视频中，他演示了几种不同单子，试图解决一个问题:函数组合。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="jv jw l"/></div></figure><p id="7fb0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面的解释基本上使用了相同的概念，但是我将使用JavaScript而不是Haskell。</p><p id="8bc4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，作为一名函数式程序员，我们都知道函数组合，这非常非常简单，就像这样:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="jx jw l"/></div></figure><p id="846b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">组合函数<em class="jy"> composeF </em>非常简单，它带有两个参数<em class="jy"> f </em>和<em class="jy"> g </em>，并返回一个新函数，该函数返回应用<em class="jy"> g </em>然后<em class="jy"> f </em>后的结果值。我们可以用这个函数将<em class="jy"> mul3 </em>和<em class="jy"> add1 </em>组合成新的函数<em class="jy"> addOneThenMul3 </em>。</p><p id="ad32" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，假设我们有一个场景:</p><p id="8403" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们所拥有的:</p><ol class=""><li id="0152" class="jz ka hu it b iu iv iy iz jc kb jg kc jk kd jo ke kf kg kh dt translated">两个文件，第一个文件(<em class="jy">文件1 </em>)包含指向第二个文件(<em class="jy">文件2 </em>)的路径，第二个文件包含我们想要的真实内容。</li><li id="6fbf" class="jz ka hu it b iu ki iy kj jc kk jg kl jk km jo ke kf kg kh dt translated">读取文件功能</li></ol><p id="4429" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，我们需要构造获取“真实内容”的函数。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="jx jw l"/></div></figure><p id="ae06" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">readFileSync是一个同步IO函数，它将路径字符串作为输入，并以字符串形式返回给定路径的内容。所以我们可以重用<em class="jy"> composeF </em>来组合我们想要的函数:<em class="jy"> readFileContentSync </em>。</p><p id="c052" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">到目前为止一切顺利！</p><p id="3c32" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是如果readFile函数是异步的呢？如果您熟悉Node.js，那么您可能已经使用回调来进行流控制，它有一个正式的名称:continuation-passing style或CPS。</p><div class="kn ko fm fo kp kq"><a href="https://en.wikipedia.org/wiki/Continuation-passing_style" rel="noopener  ugc nofollow" target="_blank"><div class="kr ab ej"><div class="ks ab kt cl cj ku"><h2 class="bd hv fv z el kv eo ep kw er et ht dt translated">连续传球风格</h2><div class="kx l"><h3 class="bd b fv z el kv eo ep kw er et ek translated">在函数式编程中，连续传递风格(CPS)是一种将控制传递给</h3></div><div class="ky l"><p class="bd b gc z el kv eo ep kw er et ek translated">en.wikipedia.org</p></div></div></div></a></div><p id="1fd6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么<em class="jy">读取文件</em>功能将如下所示:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="jx jw l"/></div></figure><p id="01fa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，有一个问题:我们不能用c<em class="jy">composif</em>来进行函数合成。因为这一次，函数没有返回任何内容。</p><p id="6233" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是等等，我们仍然可以做函数合成，只要:</p><ol class=""><li id="8acc" class="jz ka hu it b iu iv iy iz jc kb jg kc jk kd jo ke kf kg kh dt translated">派生的函数采用与第一个函数相同的输入</li><li id="9384" class="jz ka hu it b iu ki iy kj jc kk jg kl jk km jo ke kf kg kh dt translated">它按顺序完成这些功能。</li></ol><p id="9bf1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们需要的只是一个新的合成函数:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="jx jw l"/></div></figure><p id="d49f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意:我修改了参数的顺序:从<em class="jy"> (f，g) </em>到<em class="jy"> (g，f) </em>。</p><p id="2670" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以看到，c<em class="jy">composipse</em>将返回一个新的函数，该函数将调用<em class="jy"> g </em>，在<em class="jy"> g </em>的回调中，调用<em class="jy"> f </em>，并调用<em class="jy"> cb </em>，最终结果值为<em class="jy"> f </em>。</p><p id="b151" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">万岁。我们又可以做函数合成了！</p><p id="2f0a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好吧，让我们试试有趣的东西。</p><p id="c06a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先将<em class="jy"> readFileCPS </em>的功能签名调整为<em class="jy">read file of</em>:</p><pre class="jq jr js jt fq kz la lb lc aw ld dt"><span id="2d71" class="le lf hu la b fv lg lh l li lj">const readFileHOF = path =&gt; cb =&gt; {<br/>  readFileCPS(path, cb)<br/>}</span></pre><p id="75c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">HOF表示高阶函数。我们只需将一组参数分解为两组参数。使<em class="jy"> readFileHOF </em>取<em class="jy">路径</em>参数，返回一个以<em class="jy"> cb </em>为输入的函数，所有参数置位后，实函数体执行。</p><p id="0c94" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，我们需要一个新的合成函数。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="jx jw l"/></div></figure><p id="ec96" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这与<em class="jy">composits CPS</em>几乎相同，没有太大不同。</p><p id="582b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">其次，我们给以<em class="jy"> cb </em>为参数的函数命名，并把它放入一个对象中，如下所示:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="jx jw l"/></div></figure><p id="1f82" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样，因为我们再次更改了函数签名，所以我们需要调整组合函数:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="jx jw l"/></div></figure><p id="1fe3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这实际上也和<em class="jy"> composeHOF </em>没什么不同，对吧？</p><p id="89ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们讨厌重复你自己。让我们创建一个助手函数:</p><pre class="jq jr js jt fq kz la lb lc aw ld dt"><span id="af65" class="le lf hu la b fv lg lh l li lj">const createExecObj = exec =&gt; ({exec})</span></pre><p id="c4b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该函数返回一个带有<em class="jy"> exec </em>字段的对象，也是一个函数。让我们把“带有<em class="jy"> exec的对象</em>字段】<em class="jy"> ExecObj </em></p><p id="fee2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jy">createexecutobj</em>也使<em class="jy"> readFileEXEC </em>两行变短:</p><pre class="jq jr js jt fq kz la lb lc aw ld dt"><span id="921d" class="le lf hu la b fv lg lh l li lj">const readFileEXEC2 = path =&gt; {<br/>  return createExecObj(cb =&gt; {<br/>    readFileCPS(path, cb)<br/>  })<br/>}</span></pre><p id="63f6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">经过这种改变，您可以看到<em class="jy"> readFileEXE2 </em>采取了一种路径并返回了一个exec对象。除此之外，一切都一样。</p><p id="cdbc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">下一步，我们将有一个大的变化，所以要小心！</strong></p><p id="0518" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">到目前为止，复合函数的两个参数都是函数。让我们把第一个参数换成别的东西:exec对象！</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="jx jw l"/></div></figure><p id="c96a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将<em class="jy">合成</em>重命名为<em class="jy">绑定</em>。这个<em class="jy">绑定</em>函数将返回一个新的exec对象。如果有人调用这个对象的<em class="jy"> exec </em>，那么它将对<em class="jy"> execObj </em>做同样的事情，然后在回调中，它使用<em class="jy"> f </em>。注意，这个要点的第4行与<em class="jy"> composeEXEC </em>的第6行相同。</p><p id="6571" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后神奇开始了:</p><pre class="jq jr js jt fq kz la lb lc aw ld dt"><span id="b69e" class="le lf hu la b fv lg lh l li lj">const readFile2EXEC2 = bindExec(<br/>  readFileEXEC2('./file1'),<br/>  readFileEXEC2<br/>)<br/>readFile2EXEC2.exec(result =&gt; console.log(result))</span></pre><p id="4ff4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不够清楚？让我们去掉常数:</p><pre class="jq jr js jt fq kz la lb lc aw ld dt"><span id="15ee" class="le lf hu la b fv lg lh l li lj">bindExec(<br/>  readFileEXEC2('./file1'),<br/>  readFileEXEC2<br/>)<br/>.exec(result =&gt; console.log(result))</span></pre><p id="c125" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还不明白吗？嗯，我们快到了，耐心点:</p><p id="8644" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们尝试将<em class="jy"> bindExec </em>函数“内联”到Exec对象，如下所示:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="jx jw l"/></div></figure><p id="769c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请将此与<em class="jy"> bindExec </em>进行比较。返回对象是exec对象，所以我们简单地用<em class="jy">这个</em>替换<em class="jy"> execObj </em>。当然，由于同样的原因，我们不需要第一个论证(第3行)</p><p id="a084" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么怎么用呢？</p><pre class="jq jr js jt fq kz la lb lc aw ld dt"><span id="7257" class="le lf hu la b fv lg lh l li lj">readFileEXEC2('./file1')<br/>.bind(readFileEXEC2)<br/>.exec(result =&gt; console.log(result))</span></pre><p id="69fc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你看到了吗？很熟悉的东西？没有吗？</p><p id="9dab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好吧！让我们做一些重命名:</p><ul class=""><li id="7273" class="jz ka hu it b iu iv iy iz jc kb jg kc jk kd jo lk kf kg kh dt translated">readFileEXEC2 -&gt; readFileAsync</li><li id="4824" class="jz ka hu it b iu ki iy kj jc kk jg kl jk km jo lk kf kg kh dt translated">绑定-&gt;然后</li><li id="c4cb" class="jz ka hu it b iu ki iy kj jc kk jg kl jk km jo lk kf kg kh dt translated">执行-&gt;完成</li></ul><pre class="jq jr js jt fq kz la lb lc aw ld dt"><span id="3d4c" class="le lf hu la b fv lg lh l li lj">readFileAsync('./file1')<br/>.then(readFileAsync)<br/>.done(result =&gt; console.log(result))</span></pre><p id="73de" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的天啊。这是承诺！！！<br/>(不完全是。因为不管你叫<em class="jy"> done，承诺都会执行。</em>)</p><p id="4698" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者</p><ul class=""><li id="797d" class="jz ka hu it b iu iv iy iz jc kb jg kc jk kd jo lk kf kg kh dt translated">readFileEXEC2 -&gt; readFile$</li><li id="47da" class="jz ka hu it b iu ki iy kj jc kk jg kl jk km jo lk kf kg kh dt translated">绑定-&gt;平面图</li><li id="8d7b" class="jz ka hu it b iu ki iy kj jc kk jg kl jk km jo lk kf kg kh dt translated">执行-&gt;订阅</li></ul><p id="9da6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的天啊。这是Rx！！！<br/>(对！差不多！当然，我们仍然需要添加错误处理和其他东西)</p><h2 id="eb68" class="le lf hu bd ll lm ln lo lp lq lr ls lt jc lu lv lw jg lx ly lz jk ma mb mc md dt translated">那么monad在哪里呢？</h2><p id="51bf" class="pw-post-body-paragraph ir is hu it b iu me iw ix iy mf ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">答案是:从<em class="jy">到这里。都是单子！！！具体来说:</em></p><ul class=""><li id="167a" class="jz ka hu it b iu iv iy iz jc kb jg kc jk kd jo lk kf kg kh dt translated">由于<em class="jy"> composeCPS </em>，readFileCPS 成为一个单子。实际上，它在Haskell 中被称为<a class="ae jp" href="https://en.wikibooks.org/wiki/Haskell/Continuation_passing_style" rel="noopener ugc nofollow" target="_blank"> Cont monad</a></li><li id="aff6" class="jz ka hu it b iu ki iy kj jc kk jg kl jk km jo lk kf kg kh dt translated">“执行对象”因为<em class="jy">绑定</em>而变成单子。同样，它在Haskell中被称为IO monad，检查Haskell 中的<a class="ae jp" href="https://wiki.haskell.org/Tutorials/Programming_Haskell/String_IO#File_IO" rel="noopener ugc nofollow" target="_blank">文件IO</a></li></ul><h2 id="6b59" class="le lf hu bd ll lm ln lo lp lq lr ls lt jc lu lv lw jg lx ly lz jk ma mb mc md dt translated">那么如何鉴别一个事物是否是单子呢？</h2><p id="e10c" class="pw-post-body-paragraph ir is hu it b iu me iw ix iy mf ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">首先，也许你问了一个错误的问题。不要问“是不是单子”，应该问“能不能是单子”。</p><h2 id="ac9c" class="le lf hu bd ll lm ln lo lp lq lr ls lt jc lu lv lw jg lx ly lz jk ma mb mc md dt translated">单子有什么性质？</h2><ol class=""><li id="05e5" class="jz ka hu it b iu me iy mf jc mj jg mk jk ml jo ke kf kg kh dt translated">它有一个带值的上下文。</li><li id="54a1" class="jz ka hu it b iu ki iy kj jc kk jg kl jk km jo ke kf kg kh dt translated">该值不一定存在。</li><li id="cee2" class="jz ka hu it b iu ki iy kj jc kk jg kl jk km jo ke kf kg kh dt translated">它提供了一种获取值的方法(通常通过回调)</li><li id="7d04" class="jz ka hu it b iu ki iy kj jc kk jg kl jk km jo ke kf kg kh dt translated">一个<em class="jy">绑定</em>函数，该函数能够从单子(第一个参数)中取出值，并将该值作为参数放入另一个函数<em class="jy"> f </em>中。(<em class="jy"> f </em>应该是返回一个单子的函数)。并且<em class="jy">绑定</em>函数的返回值应该与第一个参数的类型相同。</li><li id="8def" class="jz ka hu it b iu ki iy kj jc kk jg kl jk km jo ke kf kg kh dt translated"><em class="jy">绑定</em>函数通常也称为<em class="jy">平面图</em></li></ol><h2 id="e41f" class="le lf hu bd ll lm ln lo lp lq lr ls lt jc lu lv lw jg lx ly lz jk ma mb mc md dt translated">所以monad是用于异步操作的？不要！！！</h2><p id="509b" class="pw-post-body-paragraph ir is hu it b iu me iw ix iy mf ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">例如:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="jx jw l"/></div></figure><p id="d530" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">检查这些属性:</p><ol class=""><li id="5a4c" class="jz ka hu it b iu iv iy iz jc kb jg kc jk kd jo ke kf kg kh dt translated">是啊！方括号[]是上下文。</li><li id="7676" class="jz ka hu it b iu ki iy kj jc kk jg kl jk km jo ke kf kg kh dt translated">存在就可以了。</li><li id="70b5" class="jz ka hu it b iu ki iy kj jc kk jg kl jk km jo ke kf kg kh dt translated">按<em class="jy"> forEach </em>。</li><li id="95ad" class="jz ka hu it b iu ki iy kj jc kk jg kl jk km jo ke kf kg kh dt translated">因为<em class="jy">映射</em>将返回嵌套数组(第14行)，所以映射不符合4。我们需要创建一个<em class="jy">平面图</em>函数。</li><li id="d882" class="jz ka hu it b iu ki iy kj jc kk jg kl jk km jo ke kf kg kh dt translated">As 4。</li></ol><p id="0e0c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以没错，数组可以是单子。</p><h2 id="970a" class="le lf hu bd ll lm ln lo lp lq lr ls lt jc lu lv lw jg lx ly lz jk ma mb mc md dt translated">有必要了解什么是单子才能工作吗？</h2><p id="b93d" class="pw-post-body-paragraph ir is hu it b iu me iw ix iy mf ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated"><strong class="it hv">不！</strong></p><p id="a14d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，许多开发人员使用array、promise和Rx，却不理解monad。没关系。我也是，用了很久Rx也没有真正理解monad。但是，如果你想创建一个像Rx这样的工具，这仍然是有帮助的。(嗯，我们刚刚做到了:p)</p><h2 id="6677" class="le lf hu bd ll lm ln lo lp lq lr ls lt jc lu lv lw jg lx ly lz jk ma mb mc md dt translated">结论</h2><p id="9c25" class="pw-post-body-paragraph ir is hu it b iu me iw ix iy mf ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">所以“单子回调”？</p><p id="6721" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">是啊！根据物业3。</p><p id="81b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后“回调是单子”？</p><p id="f30b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还没有！仅当定义了<em class="jy">绑定</em>函数时。</p></div><div class="ab cl mm mn hc mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hn ho hp hq hr"><p id="1c17" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">感谢<a class="mt mu gr" href="https://medium.com/u/8b8988f09be0?source=post_page-----2adea91154e--------------------------------" rel="noopener" target="_blank"> Tom Chen </a>、<a class="mt mu gr" href="https://medium.com/u/adb3ebc98ec6?source=post_page-----2adea91154e--------------------------------" rel="noopener" target="_blank">Guan-</a>、<a class="mt mu gr" href="https://medium.com/u/6bd546313098?source=post_page-----2adea91154e--------------------------------" rel="noopener" target="_blank"> Wu、Ching Ting </a>对本文的审阅。</p><p id="3697" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">更新:修复错误措辞:激情= &gt;病人，感谢<a class="mt mu gr" href="https://medium.com/u/10cb09327cf6?source=post_page-----2adea91154e--------------------------------" rel="noopener" target="_blank">伊恩霍夫曼-希克斯</a> <br/>更新:重命名readFileFluent，感谢<a class="mt mu gr" href="https://medium.com/u/f6bfec7294e?source=post_page-----2adea91154e--------------------------------" rel="noopener" target="_blank"> wkliang </a></p><div class="jq jr js jt fq ab cb"><figure class="mv ju mw mx my mz na paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mv ju mw mx my mz na paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mv ju mw mx my mz na paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="nd ne nf"><p id="f922" class="ir is jy it b iu iv iw ix iy iz ja jb ng jd je jf nh jh ji jj ni jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is jy it b iu iv iw ix iy iz ja jb ng jd je jf nh jh ji jj ni jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jq jr js jt fq ju fe ff paragraph-image"><a href="https://goo.gl/Ahtev1"><div class="fe ff nj"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></a></figure></div></div>    
</body>
</html>