# reduce() —速度提高 10%，没有起始值。

> 原文：<https://medium.com/hackernoon/reduce-faster-with-no-starting-value-3d697c9464f9>

![](img/408d9a2a447ec639b34e17a1ae547c42.png)

围绕这个方法，我注意到如果你不给它一个起始值，它就从数组的第二个索引开始迭代。

对于第一次迭代，`a`(累加器)被赋予`array` : `1`的第一个`index`；`b`(当前值)被赋予第二个`index` : `2`。因此，这个例子只有 3 次迭代。

这是有道理的，首先你加上`1+2`然后`3+3`最后`6+4`。

现在，如果你给 reducer `a`一个初始值，迭代将从第一个键开始，因此它将迭代 4 次:

这激起了我的好奇心:我想知道迭代次数少的实现是否真的更快。我没有本机代码性能测试的经验。但是我决定使用一个我看到正在使用的[工具](https://hackernoon.com/tagged/tool): JsPerf。

在 [JsPerf](https://jsperf.com/array-reduce-with-start-value) 上，没有起始值的测试运行速度大约快 10%(根据浏览器的不同有很大的差异)。这些结果是针对小型阵列的。

用更大的阵列(比如 10k 个项目)测试相同的代码并没有显示出显著的差异。有几个操作每秒钟的差异，不是很多。这很可能是由于两种实现的调度(开始)时间不同。这种差异在多次迭代后变得不明显。纯粹假设如果调度时间也是 2 纳秒，每次迭代 4 纳秒，那么 4 次迭代 2 纳秒就代表 2 / 4 * 4 + 2 ~11.11%。但是对于 100 次迭代，2 / 4 * 100 = 0.5 %

如您所见，这种巨大的差异只对小数组有效。对于一个`array.map(i => i.reduce())`来说，这可能很有趣，因为您知道每次缩减都将发生在一个小阵列上。

但是等等， [JsPerf](https://hackernoon.com/tagged/jsperf) 在浏览器上测试，node.js 呢？惊喜，惊喜…反过来了。我写了一个小脚本来测试:

我测试了 node.js 的不同版本，计算了没有开始值的实现和有开始值的实现之间的时间增长百分比。负数表示具有起始值的变量实际上更快。我给了你最快和最慢的测试。我已经做了很多介于这两个数字之间的测试。

我们可以看到，在较小的阵列上，具有起始值的节点实际上更快，但是在较大的阵列上，没有起始值的实现更快，在节点 8 上，具有起始值的实现比其他实现快很多倍。

我们这里说的是毫秒和毫微秒…例如，在节点 8 上表现最好的大阵列测试实际上要快大约`0.076ms`…

这些数字很小，我想这没有什么意义，除非你收到大量的请求。但这是一个有趣的实验。让我知道你的想法！