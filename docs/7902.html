<html>
<head>
<title>Interactive Charts with Go (GL)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带Go的交互式图表(GL)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/interactive-charts-with-go-gl-7a30a40162a0?source=collection_archive---------5-----------------------#2017-11-12">https://medium.com/hackernoon/interactive-charts-with-go-gl-7a30a40162a0?source=collection_archive---------5-----------------------#2017-11-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="a172" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">近年来，自从<a class="ae jp" href="https://d3js.org/" rel="noopener ugc nofollow" target="_blank"> D3.js </a>的出现，每当有涉及图表或图形可视化的任务时，我就倾向于JavaScript库。这主要是因为D3.js提供了一种简单的方法，通过数据驱动的方法，使用HTML、SVG和CSS实现数据。很容易为您自己的用例进行定制和集成，并且有大量漂亮的交互式图表示例。</p><p id="d317" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，有了创建C++ <a class="ae jp" href="https://www.qt.io/" rel="noopener ugc nofollow" target="_blank"> Qt </a>用户界面的经验，<em class="jq">有时候</em>我会怀念一种更本土的方法。有一些关于编译的小型二进制可执行文件，或者一些不必处理不同浏览器的东西。所以作为一个副业，我认为是时候去探索一些新的东西了，去进行一次<em class="jq">冒险</em>去寻找一个替代品。</p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div class="fe ff jr"><img src="../Images/4e5c3799af19980c93d4835b4296d978.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*8DPOF3sgUPj06R3zVcMV5A.png"/></div><figcaption class="jz ka fg fe ff kb kc bd b be z ek">Always be curious, have an adventure</figcaption></figure><p id="13bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我的工作环境(我所熟悉的东西)中寻找灵感，我决定这个项目的一个合适的主题是可视化<a class="ae jp" href="https://www.mongodb.com/what-is-mongodb" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>日志文件中的操作的工具。该工具将使用<a class="ae jp" href="https://en.wikipedia.org/wiki/Scatter_plot" rel="noopener ugc nofollow" target="_blank">散点图</a>根据操作的时间戳和持续时间绘制日志条目。</p><p id="25f6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">MongoDB日志条目示例(v3.4.9):</p><pre class="js jt ju jv fq kd ke kf kg aw kh dt"><span id="6a43" class="ki kj hu ke b fv kk kl l km kn"><strong class="ke hv">2017-11-13T10:22:19.039+1100</strong> I COMMAND  [conn3] command charts.golang appName: "MongoDB Shell" command: find { find: "golang", filter: { a: { $regex: /^d.*/ } } } planSummary: COLLSCAN keysExamined:0 docsExamined:1000 cursorExhausted:1 numYields:7 nreturned:42 reslen:2638 locks:{ Global: { acquireCount: { r: 16 } }, Database: { acquireCount: { r: 8 } }, Collection: { acquireCount: { r: 8 } } } protocol:op_command <strong class="ke hv">1ms</strong></span></pre><p id="c008" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">作为Golang编程语言的新手，这也是提高我语言流利度的绝佳机会。因为你知道他们说什么:如果你不使用它，你就会失去它。做出这些决定后，现在是时候寻找合适的Golang依赖项了。</p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="fe ff ko"><img src="../Images/7c47797abba2d599ca712e5c7ecd2859.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aGxAVhXsumPSTOIx."/></div></div><figcaption class="jz ka fg fe ff kb kc bd b be z ek">Keep Looking</figcaption></figure><p id="7ca9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">启动这个项目(可能)需要两个库:一个用于呈现散点图，一个用于解析MongoDB日志文件。</p><p id="e60c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一般来说，我所知道的Golang绘图库只是生成静态的，尽管很漂亮的图像；举几个例子:</p><ul class=""><li id="561d" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated"><a class="ae jp" href="https://github.com/gonum/plot" rel="noopener ugc nofollow" target="_blank">github.com/gonum/plot</a></li><li id="eaf0" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated"><a class="ae jp" href="https://github.com/wcharczuk/go-chart" rel="noopener ugc nofollow" target="_blank">github.com/wcharczuk/go-chart</a></li></ul><p id="a929" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这一点上，我决定走上编写自己的自定义交互式小部件的道路。快速搜索后，我找到了golang-ui/nuklear。这是一个为小型ANSI C GUI库提供Go绑定的包。参见相关的<a class="ae jp" href="https://github.com/vurtun/nuklear" rel="noopener ugc nofollow" target="_blank">github.com/vurtun/nuklear</a>。</p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="fe ff lh"><img src="../Images/070d0cbe70e80ea257dfc04103c95297.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E9e1nfTFpuoUW-hg."/></div></div><figcaption class="jz ka fg fe ff kb kc bd b be z ek">One of the examples of GUI from the Github repo.</figcaption></figure><p id="00ff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Nuklear有一些吸引我的特性:</p><ul class=""><li id="3bf2" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">小型代码库(约18k LOC)</li><li id="d0cd" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">没有依赖性(如果不需要，甚至没有标准库)</li><li id="d4a5" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">低内存占用，可根据需要控制总内存</li><li id="413c" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">可选字体烘焙器和顶点缓冲输出</li></ul><p id="cd56" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，我做了一个快速测试来创建入口图:</p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="fe ff li"><img src="../Images/eb01e516a5888fcc2620b6c160e418ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/0*c_oxGSjJju_YaNri."/></div></div></figure><pre class="js jt ju jv fq kd ke kf kg aw kh dt"><span id="85c5" class="ki kj hu ke b fv kk kl l km kn">c1 := nk.NkRect(float32(fx), float32(fy), 5.0, 5.0)   nk.NkFillCircle(canvas, c1, nk.NkRgb(171, 239, 29))   </span><span id="6f59" class="ki kj hu ke b fv lj kl l km kn">if nk.NkInputHasMouseClickDownInRect(input, nk.ButtonLeft, c1, 1) &gt; 0 {   <br/>     log.Println("Receive a click on coordinate: ", fx, fy)   <br/>}</span></pre><p id="0583" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上面这个简单例子的完整源代码可以在gist://<a class="ae jp" href="https://gist.github.com/sindbach/a21d93c5f11a24665d9d07c05340bad3" rel="noopener ugc nofollow" target="_blank"><em class="jq">test _ scatter . go</em></a>上找到</p><p id="ce1c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个二进制可执行文件的大小只有大约5MB。在没有任何代码优化的情况下，我可以在有一点延迟之前渲染大约75，000个点。</p><p id="bdf5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过另一个快速搜索，我找到了一个Golang库来解析MongoDB日志文件，<a class="ae jp" href="https://github.com/honeycombio/mongodbtools" rel="noopener ugc nofollow" target="_blank">github.com/honeycombio/mongodbtools</a>，由<a class="ae jp" href="https://honeycomb.io/" rel="noopener ugc nofollow" target="_blank"> honeycomb.io </a>编写。通过几行额外的Golang代码，我可以解析日志文件并将它们绘制到交互式小部件中:</p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="fe ff lk"><img src="../Images/81e83baa6bbc0aeeb2104772f62f7701.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KYekW2ei2_psDJWP."/></div></div></figure><p id="65ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个二进制可执行文件的大小约为10MB。</p><p id="3664" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此时，我可以修复丢失的X和Y轴信息，缩放输入时间戳和持续时间以适合应用程序窗口的大小，并计算标记点。</p><p id="04e5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我探索的另一条途径是使用许多Golang绘图库中的一个来生成SVG或PNG图像，并在GL小部件上将它渲染为纹理/位图，在新数据到达时刷新纹理生成。我很快尝试使用<a class="ae jp" href="https://github.com/wcharczuk/go-chart" rel="noopener ugc nofollow" target="_blank">github.com/wcharczuk/go-chart</a>生成静态图像来实现这条路径:</p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div class="fe ff ll"><img src="../Images/c2bf076a805457654c648774fb8aaca7.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*bsqx5spIufNNAzuF."/></div></figure><p id="fba4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里的挑战是映射小部件上接收到的鼠标点击，并将其关联回纹理/位图上的项目，以找出哪个入口点被点击。</p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="fe ff ko"><img src="../Images/a6ad7266577fb30cf3c32dfb33a34491.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R7MTBk5HdHezeuei."/></div></div><figcaption class="jz ka fg fe ff kb kc bd b be z ek">Always learning…</figcaption></figure><p id="75a9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好吧，那么我从这个小小的<em class="jq">冒险</em>中学到了什么:</p><ul class=""><li id="076d" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">有很多(有用的)Golang库。</li><li id="d3f5" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">仅使用GL编写Golang绘图仪应用程序是可行的，您只需编写X和Y轴缩放比例。</li><li id="166b" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">使用现有的Golang绘图库生成SVG输出，并将其映射为GL纹理也是可行的，您只需将GL上的单击映射回纹理即可。</li><li id="6877" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">仅使用GL的一个优点是可以渲染绘图入口点，而不必先读取所有数据。</li></ul><p id="11c6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也许创建一个Golang库来呈现交互式图形是有用的，也许已经有一个我不知道的Golang库了。让我知道你的想法。</p></div></div>    
</body>
</html>