<html>
<head>
<title>Using “Server-less” Architecture to Massively Parallelize DNA Sequence Alignment via StdLib and Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用“无服务器”架构通过StdLib和Node.js大规模并行化DNA序列比对</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/using-server-less-architecture-to-massively-parallelize-dna-sequence-alignment-via-stdlib-and-343dd2d5aebf?source=collection_archive---------6-----------------------#2017-01-18">https://medium.com/hackernoon/using-server-less-architecture-to-massively-parallelize-dna-sequence-alignment-via-stdlib-and-343dd2d5aebf?source=collection_archive---------6-----------------------#2017-01-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="fe3f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">软件开发中有一种新的风格，即所谓的“无服务器”或功能即服务(FaaS)架构，这是有充分理由的。它代表了不需要管理服务器就可以无限扩展的美好前景。您可以简单地编写代码，发布它，而不必担心代码执行的环境或它消耗的资源。</p><p id="1a38" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你是“无服务器”架构的新手，那么“无服务器”这个术语本身就有点用词不当——服务器没有去任何地方。我相信我们很快就会发现这个术语已经过时了(毕竟，我们驾驶的是汽车，而不是不用马拉的马车)，FaaS是一个更加贴切的描述符:可以在大型计算集群中复制的小功能。这并不是说服务器不存在，而是每次运行时，您的代码并不在同一个物理(或虚拟)机器上执行——如果一个计算节点关闭，一个副本会弹出来取代它。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/32da3c0124314112f5e7ade8c25efc46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3oSjzuMgGqDFJfzghjf5EQ.png"/></div></div></figure><p id="dc2f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们非常兴奋地向您展示一点FaaS的力量，我们正在使用这种新的、可扩展的分布式架构来构建<a class="ae kb" href="https://stdlib.com" rel="noopener ugc nofollow" target="_blank"> StdLib:作为服务软件库的功能</a>。我们的目标是向<em class="kc">的每一位</em>开发者开放FaaS架构的世界——我们真的相信这是基于云的软件开发的未来。我们今天要向您展示的更多是FaaS <em class="kc">真正</em>闪耀的地方——大规模并行化。我们借此机会将Node.js DNA序列比对工具应用于StdLib，并很高兴分享我们的结果。</p><h1 id="9f24" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">StdLib:通过FaaS实现并行化</h1><p id="222c" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">“功能即服务”架构简化了大规模并行化——您的代码将作为大型计算集群的一部分在任意虚拟环境中执行，而不是在单个服务器上执行。随着多个请求同时到来，会创建更多的虚拟上下文来处理额外的请求负载。我们可以利用这种行为来创建动态分配的并行计算集群。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff lg"><img src="../Images/fe2acff78ad4cbafa7455fee8998b2ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XQ9ftmbfYD6Pj1qElA17oA.jpeg"/></div></div><figcaption class="lh li fg fe ff lj lk bd b be z ek">We Can Use the Behavior of Function as a Service Architecture for Massive Parallelization</figcaption></figure><p id="cd9d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于任何使用大型数据集和MapReduce作业的人来说，创建动态分配的并行计算集群的想法都是梦想成真。我们有许多客户专门询问我们StdLib在MapReduce和并行化方面的表现如何，因此我们自己创建了一个内部案例研究，以推动我们平台的极限。为此，我们采用了一个基于Node.js的DNA序列比对工具<a class="ae kb" href="https://github.com/keithwhor/NtSeq" rel="noopener ugc nofollow" target="_blank"> NtSeq </a>，以展示StdLib处理并行工作流的能力。</p></div><div class="ab cl ll lm hc ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hn ho hp hq hr"><h1 id="a2b5" class="kd ke hu bd kf kg ls ki kj kk lt km kn ko lu kq kr ks lv ku kv kw lw ky kz la dt translated">序列比对:使NtSeq适应StdLib</h1><p id="8ab9" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">我们选择改编<a class="ae kb" href="https://github.com/keithwhor/NtSeq" rel="noopener ugc nofollow" target="_blank">NtSeq库</a>是因为我在这方面的深厚专业知识(作为原作者)。NtSeq附带了一个详尽的、无缺口的、退化的DNA序列比对工具，该工具在2015年初首次推出时就在黑客新闻上流传开来。它所打包的映射算法被称为<a class="ae kb" rel="noopener" href="/@keithwhor/nbeam-how-i-wrote-an-ultra-fast-dna-sequence-alignment-algorithm-in-javascript-c199e936da#.t5uuoy7hf"> NBEAM(核苷酸逐位穷举比对映射)</a>，它使用位操作来实现JavaScript中的“原始金属”性能——在2.4GHz下每个核苷酸比较大约2纳秒，这相当于大约5个处理器周期(<a class="ae kb" href="https://github.com/keithwhor/NtSeq#benchmarks-and-tests" rel="noopener ugc nofollow" target="_blank">基准</a>)。</p><p id="10e5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对算法的工作原理做一些说明；</p><ul class=""><li id="bd15" class="lx ly hu it b iu iv iy iz jc lz jg ma jk mb jo mc md me mf dt translated">穷举-比较每个核苷酸并对每个潜在的比对位置进行评分，因此比对作图步骤的时间复杂度为O(n)</li><li id="87d7" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">无缺口—仅比较原始序列数据(无“缺口”变异，即序列之间可能添加或删除了核苷酸)</li><li id="4b3d" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">简并—也匹配“通配符”核苷酸(不仅是A、T、G和C —例如，核苷酸W匹配{A、T} ),其完整列表可在维基百科的<a class="ae kb" href="https://en.wikipedia.org/wiki/Nucleic_acid_notation" rel="noopener ugc nofollow" target="_blank">核酸符号页面上找到</a></li></ul><p id="ed9b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">O(n)的映射时间复杂度是一个自然的瓶颈，也是并行化的良好候选</strong>，因为您正在搜索的查询序列和基因组序列都可以被分割成多个块，并独立地并行对齐，最后的缩减步骤可以聚合结果。</p><h1 id="43bb" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">StdLib服务设置:两个函数，搜索和映射</h1><p id="b4d0" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated"><em class="kc">如果您想继续阅读本文，请查看GitHub </em>  <em class="kc">上的</em><a class="ae kb" href="https://github.com/keithwhor/stdlib-sequence" rel="noopener ugc nofollow" target="_blank"><em class="kc">Keith whor/stdlib-sequence，在这里您可以克隆存储库并自己部署到StdLib。</em></a></p><p id="5cab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们有四个与序列比对和评分相关的基本步骤:</p><ol class=""><li id="a75e" class="lx ly hu it b iu iv iy iz jc lz jg ma jk mb jo ml md me mf dt translated"><strong class="it hv">准备</strong> —读取序列并为映射做准备(转换为二进制数组)</li><li id="8fd0" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo ml md me mf dt translated"><strong class="it hv">映射</strong> —执行对准(平行化)</li><li id="54c6" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo ml md me mf dt translated"><strong class="it hv">减少</strong>——将来自<strong class="it hv">映射</strong>的结果聚合成一个结果</li><li id="c00d" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo ml md me mf dt translated"><strong class="it hv">排序</strong> —对结果进行排序以给出最佳匹配</li></ol><p id="a4b9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以只使用<strong class="it hv">两个函数</strong>来构建整个StdLib服务。一个<strong class="it hv">搜索功能</strong>，它自己执行步骤(1)、(3)和(4)，并且还负责调用步骤(2)的委托/功能。需要一个专门的<strong class="it hv">映射函数</strong>来处理步骤(2)中实际的O(n)映射计算。设置看起来有点像这样(简化为三个并行函数调用):</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff mm"><img src="../Images/dd348d6f88d0fdbc3056df2bbe05d0be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*pk9hmpLz7_mXp9ggL7XXBw.jpeg"/></div></figure></div><div class="ab cl ll lm hc ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hn ho hp hq hr"><h1 id="f11a" class="kd ke hu bd kf kg ls ki kj kk lt km kn ko lu kq kr ks lv ku kv kw lw ky kz la dt translated">搜索(缩小)功能</h1><p id="0a6f" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">这是我们的搜索功能的样子。我概述了每个步骤:准备，映射，减少和排序。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mn mo l"/></div></figure><h1 id="feb5" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">地图功能</h1><p id="8a67" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">相比之下，我们的地图功能要简单得多，因为我们只是依靠<a class="ae kb" href="https://github.com/keithwhor/NtSeq" rel="noopener ugc nofollow" target="_blank"> NtSeq </a>来完成繁重的工作。<strong class="it hv">这是并行执行的功能。</strong>在<em class="kc"> map.initialize() </em>函数调用背后的后台正在进行繁重的计算。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mn mo l"/></div></figure></div><div class="ab cl ll lm hc ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hn ho hp hq hr"><h1 id="967b" class="kd ke hu bd kf kg ls ki kj kk lt km kn ko lu kq kr ks lv ku kv kw lw ky kz la dt translated">将所有这些放在一起:结果</h1><p id="ec6e" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">为了直观显示并行化的效果，以及我们是否能在实践中看到大型MapReduce作业的合理加速，我们已经使用<a class="ae kb" href="https://github.com/poly/stdlib" rel="noopener ugc nofollow" target="_blank"> StdLib命令行工具</a>测试了在本地运行我们的函数，它们将在同一线程上(串行)执行，也将在StdLib上(并行)执行，它们将在不同的上下文中执行。搜索查询是所有不同长度的“A”的序列，与大肠杆菌K12基因组的前100万个核苷酸相对应。</p><p id="6858" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以在<a class="ae kb" href="https://stdlib.com/services/keith/sequence," rel="noopener ugc nofollow" target="_blank">https://stdlib.com/services/keith/sequence</a>找到这项服务，或者使用<a class="ae kb" href="https://keith.stdlib.com/sequence?q=A&amp;repeat=10000&amp;count=0&amp;stats" rel="noopener ugc nofollow" target="_blank">https://keith.stdlib.com/sequence?q=A&amp;repeat = 10000&amp;count = 0&amp;stats</a>在HTTPS运行这项服务。GitHub 上也有<a class="ae kb" href="https://github.com/keithwhor/stdlib-sequence" rel="noopener ugc nofollow" target="_blank">的版本。</a></p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mp"><img src="../Images/89953d378c1ddd37d234dfdfe845e293.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QoaicSxKApHty-ih9q7FwA.png"/></div></div><figcaption class="lh li fg fe ff lj lk bd b be z ek">Local Execution vs StdLib Parallel (“Server-less”) Execution, Three (3) Trials Each</figcaption></figure><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mq"><img src="../Images/d9b653cf071d81114070b6e1e16b7c33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iO3quYGRQ7Iaw4mLd9KLkQ.png"/></div></div><figcaption class="lh li fg fe ff lj lk bd b be z ek">Local (Serial) vs StdLib (Parallel) execution for different search spaces. Local Execution has a clearly linear relationship with nt² input (O(n²)), whereas StdLib execution time remains relatively stable and can be approximated as O(1) due to massive parallelization.</figcaption></figure><p id="7d4b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们在本地对每组输入运行了三次搜索功能试验，并将其与StdLib上的三次执行试验进行了比较。本地机器是2.7 GHz Core i5处理器，内存为16GB。优化后，StdLib使用1.5GB内存执行。前两个测试(搜索空间≤ 1B nt)尚未并行化—请记住，根据上面的代码，只有当核苷酸搜索空间超过1，000，000，000 nt时，才会添加额外的工作线程。</p><p id="fb84" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们使用这些结果与使用的内核(工作线程)数量进行比较时，我们看到一种并行化模式似乎遵循<a class="ae kb" href="https://en.wikipedia.org/wiki/Amdahl%27s_law" rel="noopener ugc nofollow" target="_blank">阿姆达尔定律</a>，表明对于长度为1，000，000的基因组，无论并行工作线程的数量是多少，我们都可以推断出大约20–30倍的最大加速。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mr"><img src="../Images/99770ee24cb2c605caa1f0d014284bb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wQRq0cxo8NdfSFqP_bNoUw.png"/></div></div><figcaption class="lh li fg fe ff lj lk bd b be z ek">Speedup due to Parallelization via StdLib. Roughly follows Amdahl’s Law with test data provided, but should be noted that more cores also maps to an increase in search space.</figcaption></figure><h1 id="09c0" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">限制:网上请求时间</h1><p id="db00" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">并行化的最大瓶颈是在线请求时间。数据吞吐量导致的延迟增加意味着任何O(n)时间复杂度的任务都不适合这些工作流。</p><p id="ed65" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，虽然在理论上，可以无限地创建新的虚拟上下文，从而导致无限的并行化，但这并不是实践中的最终结果。导致客户端和服务器端请求排队的资源管理可能会导致暂停或性能延迟，从而导致大规模并行(&gt; 100名工作人员)作业的可变性达到1-3倍。这可以通过以下事实得到补偿:这些大型工作通常可以节省3倍以上的时间，就像这里的情况一样。我们一直在努力提高这一性能。</p><h1 id="9e49" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">结论:StdLib是一个强大的MapReduce工具</h1><p id="4651" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">基于过去几周我们对StdLib所做的工作和升级，我们有信心声明StdLib已经为MapReduce primetime做好了准备。单独使用AWS Lambda的好处是立竿见影的；</p><ul class=""><li id="2b44" class="lx ly hu it b iu iv iy iz jc lz jg ma jk mb jo mc md me mf dt translated">更简单的开发人员工作流程——部署就像“lib up”一样简单</li><li id="402d" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">我们支持高达128MB的请求和响应工作负载，缓解了围绕大型作业批处理的问题(与AWS Lambda的5MB相比)</li><li id="6d54" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">一个由数千名开发者组成的活跃社区(点击stdlib.com<a class="ae kb" href="https://stdlib.com" rel="noopener ugc nofollow" target="_blank">的标题加入我们的Slack频道)</a></li><li id="ee16" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">一个热情的开发团队随时准备回答任何问题</li><li id="1b89" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">我们的开发者层是免费使用的，随着我们推出更新，我们将向早期采用者提供平台积分</li></ul><p id="7e8e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您有大量的工作或工作量渴望并行化，并且想了解更多信息，请直接通过keith [at] stdlib [dot] com与我联系。</p><p id="59a8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">感谢阅读，我们希望你喜欢！在接下来的几个月里，我们将推出更多的平台更新。如果你想了解最新消息，你可以<a class="ae kb" href="https://twitter.com/stdlibhq" rel="noopener ugc nofollow" target="_blank">在Twitter @ StdLibHQ</a>上关注我们。</p></div><div class="ab cl ll lm hc ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hn ho hp hq hr"><p id="9d8c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">基思·霍伍德  <em class="kc">是一名业余爱好者兼程序员、生物化学家、系统工程师，以及介于两者之间的所有人。目前，他是</em> <a class="ae kb" href="https://stdlib.com" rel="noopener ugc nofollow" target="_blank"> <em class="kc"> StdLib </em> </a> <em class="kc">的创始人兼首席执行官，也是</em> <a class="ae kb" href="https://github.com/keithwhor/nodal" rel="noopener ugc nofollow" target="_blank"> <em class="kc"> Nodal API框架</em> </a> <em class="kc">的作者，他致力于让全球的开发者、团队和公司尽可能轻松地构建基于网络的软件和API。</em></p><p id="b709" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="kc">你可以在推特上关注他，</em><a class="ae kb" href="https://twitter.com/keithwhor" rel="noopener ugc nofollow" target="_blank"><em class="kc">@ keithwhor</em></a><em class="kc">。</em></p><div class="jq jr js jt fq ab cb"><figure class="ms ju mt mu mv mw mx paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="ms ju mt mu mv mw mx paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="ms ju mt mu mv mw mx paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="my mz na"><p id="f922" class="ir is kc it b iu iv iw ix iy iz ja jb nb jd je jf nc jh ji jj nd jl jm jn jo hn dt translated"><a class="ae kb" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是这个家庭的一员。我们现在<a class="ae kb" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae kb" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is kc it b iu iv iw ix iy iz ja jb nb jd je jf nc jh ji jj nd jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kb" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kb" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff ne"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>