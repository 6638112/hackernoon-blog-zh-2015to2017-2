<html>
<head>
<title>Using WeakHashMap to save references of callbacks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用WeakHashMap保存回调的引用</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/using-weahhashmap-to-save-references-to-callbacks-ed4f78ccb33?source=collection_archive---------4-----------------------#2016-09-26">https://medium.com/hackernoon/using-weahhashmap-to-save-references-to-callbacks-ed4f78ccb33?source=collection_archive---------4-----------------------#2016-09-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="857f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">根据'<a class="ae jp" href="https://hackernoon.com/tagged/effective-java" rel="noopener ugc nofollow" target="_blank"> Effective Java </a>，第二版'，“…确保回调被及时垃圾收集的最好方法是只存储对它们的<em class="jq">弱引用</em>，例如，通过只将它们作为键存储在WeakHashMap中。”</p><p id="13cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<a class="ae jp" href="https://hackernoon.com/tagged/jdk" rel="noopener ugc nofollow" target="_blank"> JDK </a>源代码中有一个例子，使用WeakHashMap保存回调以防止内存泄漏。</p><p id="81ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们看看这个班级</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="36f4" class="ka kb hu jw b fv kc kd l ke kf">BaseResourceFactory</span></pre><p id="fb73" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有一个字段:listenerMap</p><p id="2fa3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">，这是一个WeakHashMap，保存正在添加的侦听器。</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="a9cb" class="ka kb hu jw b fv kc kd l ke kf">// Use a WeakHashMap as it automatically removes dead objects when they're<br/>// collected<br/>private final WeakHashMap&lt;ResourceFactoryListener,Boolean&gt; listenerMap =<br/>        new WeakHashMap&lt;ResourceFactoryListener,Boolean&gt;();</span></pre><p id="8e90" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要添加一个监听器，客户端只需要将监听器保存为key，和Boolean。TRUE作为地图的值。</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="447f" class="ka kb hu jw b fv kc kd l ke kf">@Override public void addFactoryListener(ResourceFactoryListener l) {<br/>    listenerMap.put(l, Boolean.<em class="jq">TRUE</em>);<br/>}</span></pre><p id="7db3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为什么使用布尔型？真的吗？</p><p id="fdc2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为它是一个不变的物体:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="922a" class="ka kb hu jw b fv kc kd l ke kf">public static final Boolean <em class="jq">TRUE </em>= new Boolean(true);</span></pre><p id="308e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以我们把它作为一个占位符，不需要创建任何额外的对象或者使用任何额外的内存。</p><p id="af06" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了获取所有侦听器，getFactoryListeners方法返回WeahHashMap的keySet的防御性副本。</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="b4d0" class="ka kb hu jw b fv kc kd l ke kf">protected ResourceFactoryListener[] getFactoryListeners() {<br/>    return listenerMap.keySet().toArray(new ResourceFactoryListener[0]);<br/>}</span></pre><p id="244c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，还有移除方法。</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="5ebe" class="ka kb hu jw b fv kc kd l ke kf">@Override public void removeFactoryListener(ResourceFactoryListener l) {<br/>    // remove will return null if there is no mapping, so it's safe to call<br/>    // with unregistered listeners<br/>    listenerMap.remove(l);<br/>}</span></pre><figure class="jr js jt ju fq kg"><div class="bz el l di"><div class="kh ki l"/></div></figure></div></div>    
</body>
</html>