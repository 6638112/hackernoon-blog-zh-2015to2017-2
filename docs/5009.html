<html>
<head>
<title>Counting Bloom Filter in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++中的布隆过滤器计数</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/counting-bloom-filter-in-c-9672ec25b3ec?source=collection_archive---------5-----------------------#2017-07-05">https://medium.com/hackernoon/counting-bloom-filter-in-c-9672ec25b3ec?source=collection_archive---------5-----------------------#2017-07-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="d012" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我最近偶然看到了迈克尔·施马茨的bloom filter帖子，它启发我写了一个关于T2的bloom filter的巧妙变体，我发现它对我的工作很有用。快速复习:布隆过滤器是一种概率性的<a class="ae jp" href="https://hackernoon.com/tagged/data-structure" rel="noopener ugc nofollow" target="_blank">数据结构</a>，它测试一个元素是否<a class="ae jp" href="https://hackernoon.com/tagged/potentially" rel="noopener ugc nofollow" target="_blank">潜在地</a>在一个集合中。当测试一个元素是否在集合中时，假阳性是可能的，但是阴性意味着一个元素肯定不在集合中。明白了吗？酷毙了。</p><p id="362c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">计数过滤器本质上是一个bloom过滤器，它的一位布尔值被n位整数所取代。这使得过滤器比标准的bloom过滤器占用更多的空间，但作为回报，我们可以获得特定元素插入的上限计数，并可以从过滤器中删除元素。虽然删除元素可能非常简单，但是如果我们删除了一个从未插入到计数过滤器中的元素，我们就有可能出现假阴性。小心点——<a class="ae jp" href="https://pdfs.semanticscholar.org/b0cd/0a280b1c54fb218c1ca37b8f77b634fb6f45.pdf" rel="noopener ugc nofollow" target="_blank">郭对此比我说得更多。</a></p><h2 id="aa0a" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">履行</h2><p id="223f" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">我用下面的接口设计了我的计数过滤器类:</p><pre class="kq kr ks kt fq ku kv kw kx aw ky dt"><span id="1823" class="jq jr hu kv b fv kz la l lb lc">// Adds an element to the counting filter.<br/>void Add(const T *key, int size = sizeof(T));</span><span id="b8f7" class="jq jr hu kv b fv ld la l lb lc">// Removes an element from the counting filter.<br/>void Remove(const T *key, int size = sizeof(T));</span><span id="1bd0" class="jq jr hu kv b fv ld la l lb lc">// Test whether the element has been added. If false, the element <br/>// is definitely not in the set. If true, the element could be in<br/>// the set or it is a false positive as described above.<br/>bool MaybeContains(const T *key, int size = sizeof(T)) const;</span><span id="9405" class="jq jr hu kv b fv ld la l lb lc">// Get the upper bound on the number of times an element could<br/>// have been inserted into the counting filter.<br/>int CountUpperBound(const T *key, int size = sizeof(T)) const;</span></pre><p id="d3fd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">计数器存储在std::vector中，如下所示:</p><pre class="kq kr ks kt fq ku kv kw kx aw ky dt"><span id="e15d" class="jq jr hu kv b fv kz la l lb lc">std::vector&lt;uint8&gt; counters_;</span></pre><p id="c820" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我最初用存储在std::array对象中的计数器实现了这一点。使用这个数组，过滤器在我的机器上以大约1.35倍于std::unordered_set插入的运行时间进行了基准测试。对于vector，它的基准是大约2.05倍std::unordered_set插入。我选择了较慢的选项，因为代码看起来更干净，并且它允许我们在实例化期间指定bloom filter中散列的大小和数量，而不需要使用模板参数(std::arrays必须在编译时具有已知的大小)。</p><p id="ba19" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">构造函数非常简单。简单地通过调用resize()预先分配counters_ vector，也许只是用零填充向量，所以我应该从展示如何使用散列来获得索引对开始:</p><pre class="kq kr ks kt fq ku kv kw kx aw ky dt"><span id="e226" class="jq jr hu kv b fv kz la l lb lc">template &lt;typename T, int64_t kSize, int32_t kNumHashPairs&gt;<br/>void CountingFilter&lt;T, kSize, kNumHashPairs&gt;::IdxFromKey(<br/>  const T *key,<br/>  const int size,<br/>  const uint32_t seed,<br/>  int64_t *idx1,<br/>  int64_t *idx2) const {<br/><br/>  array&lt;uint64_t, 2&gt; results;<br/>  MurmurHash3_x64_128(key, size, seed, results.data());<br/>  *idx1 = results[0] % counters_.size();<br/>  *idx2 = results[1] % counters_.size();<br/>  assert(*idx1 &lt; counters_.size());<br/>  assert(*idx2 &lt; counters_.size());<br/>}</span></pre><p id="db9d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，这将实现限制为偶数个散列，但我喜欢我们得到64位散列的二对一交易这一事实。</p><p id="1b06" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Add()函数必须考虑计数超过最大计数器值的可能性。在这种情况下，除了避免增量并将过滤器数据标记为潜在错误之外，我们没有什么可做的。</p><pre class="kq kr ks kt fq ku kv kw kx aw ky dt"><span id="462f" class="jq jr hu kv b fv kz la l lb lc">template &lt;typename T, int64_t kSize, int32_t kNumHashPairs&gt;<br/>void CountingFilter&lt;T, kSize, kNumHashPairs&gt;::Add(<br/>  const T *key, const int size) {</span><span id="b412" class="jq jr hu kv b fv ld la l lb lc">for (int32_t xx = 0; xx &lt; kNumHashPairs; ++xx) {<br/>    int64_t idx1, idx2;<br/>    IdxFromKey(key, size, xx, &amp;idx1, &amp;idx2);<br/>    // It's possible that the count can exceed the maximum uint8<br/>    // value, so we'll just leave it be. After many removals,<br/>    // this could result in a false negative, but this is very<br/>    // unlikely. Let's just assert for this case.<br/>    assert(counters_[idx1] &lt;= numeric_limits&lt;uint8_t&gt;::max());<br/>    assert(counters_[idx2] &lt;= numeric_limits&lt;uint8_t&gt;::max());<br/>    counters_[idx1] += 1;<br/>    counters_[idx2] += 1;<br/>  }<br/>  ++num_insertions_;<br/>}</span></pre><p id="f44f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">移除要简单得多，因为我们只是递减计数器。在这种情况下，是否在递减计数器之前添加计数器非零的断言由您决定:</p><pre class="kq kr ks kt fq ku kv kw kx aw ky dt"><span id="3cc8" class="jq jr hu kv b fv kz la l lb lc">template &lt;typename T, int64_t kSize, int32_t kNumHashPairs&gt;<br/>void CountingFilter&lt;T, kSize, kNumHashPairs&gt;::Remove(<br/>  const T *key, const int size) {<br/><br/>  for (int32_t xx = 0; xx &lt; kNumHashPairs; ++xx) {<br/>    int64_t idx1, idx2;<br/>    IdxFromKey(key, size, xx, &amp;idx1, &amp;idx2);<br/>    assert(counters_[idx1] &gt; 0);<br/>    assert(counters_[idx2] &gt; 0);<br/>    counters_[idx1] -= 1;<br/>    counters_[idx2] -= 1;<br/>  }<br/>  --num_insertions_;<br/>}</span></pre><p id="58d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">检查元素是否存在于过滤器中只是检查所有计数器是否非零。获取元素在过滤器中的插入次数的上限需要我们找到最小的计数器。这是一个上限，因为碰撞可能会打乱我们的计算。</p><pre class="kq kr ks kt fq ku kv kw kx aw ky dt"><span id="4580" class="jq jr hu kv b fv kz la l lb lc">template &lt;typename T, int64_t kSize, int32_t kNumHashPairs&gt;<br/>int CountingFilter&lt;T, kSize, kNumHashPairs&gt;::CountUpperBound(<br/>  const T *key, const int size) const {<br/><br/>  int count_ub = numeric_limits&lt;uint8_t&gt;::max() + 1;<br/><br/>  for (int32_t xx = 0; xx &lt; kNumHashPairs; ++xx) {<br/>    int64_t idx1, idx2;<br/>    IdxFromKey(key, size, xx, &amp;idx1, &amp;idx2);<br/>    count_ub = min(static_cast&lt;int&gt;(counters_[idx1]), count_ub);<br/>    count_ub = min(static_cast&lt;int&gt;(counters_[idx2]), count_ub);<br/>  }<br/>  return count_ub;<br/>}</span></pre><h2 id="b15e" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">包扎</h2><p id="a143" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">这种数据结构是对普通bloom过滤器的有趣改进。我的实现目前的基准测试是一个预先保留的std::unordered_set的插入时间的2.05倍。当工作数据集非常大时，我主要使用它来对缓存插入进行挑选，但我很乐意为此找到更多的应用程序。</p><blockquote class="le lf lg"><p id="ce90" class="ir is lh it b iu iv iw ix iy iz ja jb li jd je jf lj jh ji jj lk jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is lh it b iu iv iw ix iy iz ja jb li jd je jf lj jh ji jj lk jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is lh it b iu iv iw ix iy iz ja jb li jd je jf lj jh ji jj lk jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kq kr ks kt fq ll"><div class="bz el l di"><div class="lm ln l"/></div></figure></div></div>    
</body>
</html>