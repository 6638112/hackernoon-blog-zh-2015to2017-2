<html>
<head>
<title>Improving first time load of a Production React App (Part 1 of 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">改善生产React应用程序的首次加载(第1部分，共2部分)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/improving-first-time-load-of-a-production-react-app-part-1-of-2-e7494a7c7ab0?source=collection_archive---------1-----------------------#2017-02-17">https://medium.com/hackernoon/improving-first-time-load-of-a-production-react-app-part-1-of-2-e7494a7c7ab0?source=collection_archive---------1-----------------------#2017-02-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="f100" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个关于UrbanClap网站的加载时间如何在一个月内从13+秒下降到不到5秒(3G新加坡移动服务器)的故事。为了证实这一点，让我先来看一些截图。</p><p id="f9b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是我们开始这个性能练习之前的情况:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/2d255d7577079e2ff96c4741119f520f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4E7P_hwLJOB3XS6pilGnSw.png"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Webpage Test(urbanclap.com/delhi-ncr-wedding-photographers), Singapore — EC2 — <strong class="bd kf">Chrome</strong> — <strong class="bd kf">Emulated Nexus 5–3GFast</strong> — Mobile (Dec 2016)</figcaption></figure><p id="74dd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是我们取得的进展。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff kg"><img src="../Images/11c7e22ca8e6e4b3b6d049cf67040af9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AyusL7ZTzZXEH2vtRQnwiQ.png"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Webpage Test(urbanclap.com/delhi-ncr-wedding-photographers), Singapore — EC2 — <strong class="bd kf">Chrome</strong> — <strong class="bd kf">Emulated Nexus 5–3GFast</strong> — Mobile (Jan 2017)</figcaption></figure><h1 id="88f9" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">背景</h1><p id="29e3" class="pw-post-body-paragraph ir is hu it b iu lf iw ix iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo hn dt translated">我们是一个(大部分)响应迅速的webapp，使用ReactJs和服务器端渲染，使用<a class="ae lk" href="https://webpack.github.io/" rel="noopener ugc nofollow" target="_blank"> webpack </a> (v1)作为我们的捆绑工具。我们也有一个<a class="ae lk" href="https://varnish-cache.org/" rel="noopener ugc nofollow" target="_blank">清漆缓存层</a>在上面，以减少我们的服务器负载，并进一步减少我们的<a class="ae lk" href="https://en.wikipedia.org/wiki/Time_To_First_Byte" rel="noopener ugc nofollow" target="_blank">时间到第一个字节(TTFB) </a>。关于我们的技术堆栈和选择的细节，你可以<a class="ae lk" rel="noopener" href="/urbanclap-engineering/building-web-at-urbanclap-the-react-way-aa81d69f0ad9#.rb7g23p2c">阅读这篇文章</a>。</p><p id="4e7f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2017年初，我们开展了一个为期一个月的项目来改善我们的网站性能，特别是我们的上市页面的首次加载(例如<a class="ae lk" href="http://www.urbanclap.com/delhi-ncr-wedding-photographers" rel="noopener ugc nofollow" target="_blank">www.urbanclap.com/delhi-ncr-wedding-photographers</a>)。<em class="ll">我们为什么选择这些页面？</em>这些是我们的谷歌搜索列表页面，这意味着我们网站的大部分流量都通过这里进入。<em class="ll">为什么专门第一次加载？</em>大部分用户都是独一无二的，通过谷歌搜索而来。所以当用户没有任何期望的访问时，特别注意第一次加载是非常关键的。第一印象确实可能是最后的印象。此外，有充分的证据表明，谷歌搜索引擎更喜欢性能更好、加载时间更短的网站。</p><p id="0922" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们研究了很多资源，尝试了很多想法，做了很多事情。艰巨的任务结束后，我列出了我们为社区其他人做的所有事情(包括有用的资源)。</p><blockquote class="lm ln lo"><p id="ce65" class="ir is ll it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated">需要注意的重要一点是<strong class="it hv">我们不能被网站表现</strong>所蒙蔽。我们仍然需要确保我们不会妨碍产品、用户体验、分析等。我怎么强调都不为过。在工程上走极端是很容易的，但是在一天结束的时候，你是在用最终用户和商业头脑解决一个商业问题。</p></blockquote><p id="0c19" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">考虑到这一点，我试图把我们在大致两个领域所做的事情进行分类:减少资产，改变事情的顺序。在这个由两部分组成的系列的第1部分中，我将讨论减少运费。</p><h1 id="f478" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">装运较少的资产</h1><p id="0bde" class="pw-post-body-paragraph ir is hu it b iu lf iw ix iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo hn dt translated">关于如何排序发送的资源，您可以想多聪明就有多聪明，但是在某些时候，瓶颈将是您发送的资源的数量。您编写的每一行js代码、包含的外部脚本、添加的css标签、呈现在页面上的图像不仅要下载，还要由浏览器处理。这在手机上变得尤其重要(<a class="ae lk" href="http://searchengineland.com/its-official-google-says-more-searches-now-on-mobile-than-on-desktop-220369" rel="noopener ugc nofollow" target="_blank">大约一半的流量来自手机</a>，所以不要这样做)——连接通常是劣质的(3g连接是一个很好的场景；还有2g和edge)，硬件可能很便宜，手机需要时间处理css和js——所有这些都不能忽视。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff ls"><img src="../Images/4796d33e5c464881c2ec233687168fca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*52LisqGHI7DgMx643FsLIQ.png"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Stats for urbanclap.com/delhi-ncr-wedding-photographers</figcaption></figure><p id="c7b1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我会试着列出我们所做的所有事情，以减少我们对浏览器的影响。这些步骤的总体结果在相邻的图像中得到了很好的总结。</p></div><div class="ab cl lt lu hc lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hn ho hp hq hr"><h1 id="d4c8" class="kh ki hu bd kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la me lc ld le dt translated">1.JS组块</h1><p id="2c16" class="pw-post-body-paragraph ir is hu it b iu lf iw ix iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo hn dt translated">如果你使用react-router，通过<a class="ae lk" href="https://webpack.github.io/docs/code-splitting.html" rel="noopener ugc nofollow" target="_blank"> webpack的代码分割</a>创建路由特定的块相对容易。这里有一个很好的<a class="ae lk" href="http://mxstbr.blog/2016/01/react-apps-with-pages/" rel="noopener ugc nofollow" target="_blank">教程</a>告诉你如何用require.ensure来达到这个目的。确保给你的程序块命名。当你有很多路线时，事情就简单多了。</p><pre class="jq jr js jt fq mf mg mh mi aw mj dt"><span id="2404" class="mk ki hu mg b fv ml mm l mn mo">// creates a code split, and then asynchronously gets the js file <br/>// for that route.<br/>&lt;Route name="details" path="/details" getComponent={(location, cb) =&gt; {<br/>    require.ensure([], (require) =&gt; {<br/>        cb(null, require('./containers/Details/DetailsPage'));<br/>    }, 'detailsChunk');<br/>}}/&gt;</span></pre><h1 id="b9ed" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">2.CSS分块</h1><p id="2aa3" class="pw-post-body-paragraph ir is hu it b iu lf iw ix iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo hn dt translated">虽然webpack自带js分块，但对于css分块(即每条路线使用不同的css)，您需要一些变通方法。对于小型应用程序，进行css分块可能不值得。但对于我们这种规模的应用来说，这几乎成了必需品。为了实现这一点，首先你必须在webpack配置中设置多个入口点,每个入口点对应一个你想拥有单独css的路由。每个入口点现在都会产生自己的js和css。</p><pre class="jq jr js jt fq mf mg mh mi aw mj dt"><span id="038c" class="mk ki hu mg b fv ml mm l mn mo">// produces detailsChunk.js and detailsChunk.css<br/>entry: {<br/> ...<br/> 'detailsChunk' : [<br/>      './src/containers/Details/DetailsPage.js'<br/>    ],<br/>    ...<br/>}</span></pre><p id="5aed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，在路由中包含css需要一点技巧。不仅要获得该路径的css文件名，还要将它作为样式表(确保其浏览器兼容)插入到文档中。</p><pre class="jq jr js jt fq mf mg mh mi aw mj dt"><span id="0d33" class="mk ki hu mg b fv ml mm l mn mo">// requireStyle - gets the name of the css file (detailsChunk.css)<br/>// and adds it as a stylesheet to the document as here:<br/>// <a class="ae lk" href="https://github.com/guybedford/require-css" rel="noopener ugc nofollow" target="_blank">https://github.com/guybedford/require-css</a></span><span id="e2dc" class="mk ki hu mg b fv mp mm l mn mo">&lt;Route name="details" path="/details" getComponent={(location, cb) =&gt; {<br/>    require.ensure([], (require) =&gt; {<br/>        requireStyle('detailsChunk', () =&gt; {<br/>            cb(null, require('./containers/Details/DetailsPage'));<br/>        })<br/>    }, 'detailsChunk');<br/>}}/&gt;</span></pre><p id="caab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意:一个显而易见的问题是，一些常见的应用程序和供应商库(如React)将包含在每个块中。解决方法是为它创建一个单独的块。CommonsChunkPlugin 是你的朋友。</p><h1 id="c99c" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">3.移动与桌面</h1><p id="edec" class="pw-post-body-paragraph ir is hu it b iu lf iw ix iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo hn dt translated">古老的问题:是去响应还是去适应。我们可以就此进行更长时间的辩论，但无论你选择哪种方式，你都需要一款专为手机设计的UX。因此，无论您是像在responsive中那样处理大量的媒体查询(这意味着为某种设备类型发布了更多不需要的代码)，还是将js和css分别用于移动和桌面(这意味着可能需要更多的开发资源)，都取决于您。但是由于我们的页面有明显不同的设计(甚至不同的封面图片用于移动和桌面，这意味着我们必须下载两个平台的图片)，我们决定最终完全分离我们的移动和桌面组件，并将它们分开捆绑。这帮助我们建立了一个基础设施，默认情况下我们的页面是响应性的，但是如果需要的话，我们可以改变任何路由来服务特定于设备的组件。</p><p id="a554" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，我们必须将代码本身分成桌面和移动两部分。一个简单的如下文件结构帮助实现了这一点，为桌面/移动组件之间的代码重构提供了空间。</p><pre class="jq jr js jt fq mf mg mh mi aw mj dt"><span id="0d69" class="mk ki hu mg b fv ml mm l mn mo">containers<br/>     --- Details<br/>             ---DetailsPageDesktop.js<br/>             ---DetailsPageDesktop.scss<br/>             ---DetailsPageMobile.js<br/>             ---DetailsPageMobile.scss<br/>             ---DetailsPageCommon.js</span><span id="8875" class="mk ki hu mg b fv mp mm l mn mo"><strong class="mg hv"><br/>DetailsPageDesktop.js</strong></span><span id="a01f" class="mk ki hu mg b fv mp mm l mn mo">import {} from 'DetailsPageCommon.js';<br/>var styles = require('DetailsPageDesktop.scss');</span><span id="0c0f" class="mk ki hu mg b fv mp mm l mn mo">class DetailsPageDesktop extends Component {<br/>    .<br/>    .<br/>    .<br/>}</span></pre><p id="4894" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，我们必须为路线的移动和桌面版本创建单独的块(js和css)。我们通过调整webpack配置中的入口点做到了这一点。</p><pre class="jq jr js jt fq mf mg mh mi aw mj dt"><span id="3594" class="mk ki hu mg b fv ml mm l mn mo">// this will create detailsChunkDesktop.js, detailsChunkDesktop.css,<br/>// detailsChunkMobile.js, detailsChunkMobile.css<br/>// detailsPageCommon will be automatically included in both the js <br/>// chunks.</span><span id="b29d" class="mk ki hu mg b fv mp mm l mn mo">entry: {<br/> ...<br/> 'detailsChunkDesktop' : [<br/>      './src/containers/Details/DetailsPageDesktop.js'<br/>    ],<br/>  'detailsChunkMobile' : [<br/>      './src/containers/Details/DetailsPageMobile.js'<br/>    ],<br/>    ...<br/>}</span></pre><p id="fd3a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我们必须调整我们的routes配置，以解析移动和桌面的不同组件。</p><pre class="jq jr js jt fq mf mg mh mi aw mj dt"><span id="d160" class="mk ki hu mg b fv ml mm l mn mo">// isMobile() -&gt; Make sure this function works on both client and<br/>// server side. Easiest way is a regex on user agent.</span><span id="62d5" class="mk ki hu mg b fv mp mm l mn mo">&lt;Route name="details" path="/details" getComponent={(location, cb) =&gt; {<br/>    if (isMobile()) {<br/>        require.ensure([], (require) =&gt; {<br/>            requireStyle('detailsChunkMobile', () =&gt; {<br/>                cb(null, require('DetailsPageMobile.js'));<br/>            })<br/>        }, 'detailsChunkMobile');<br/>    } else {<br/>        require.ensure([], (require) =&gt; {<br/>            requireStyle('detailsChunkDesktop, () =&gt; {<br/>                cb(null, require('DetailsPageDesktop.js'));<br/>            })<br/>        }, 'detailsChunkDesktop');<br/>    }<br/>}}/&gt;</span></pre><p id="6199" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们面临一个额外的问题:我们基于url在varnish上缓存我们的标记。由于桌面和移动设备会有不同的标记，我们必须让<a class="ae lk" href="https://www.singlemindconsulting.com/2011/02/08/configuring-varnish-to-cache-per-user-agent-in-pressflow/" rel="noopener ugc nofollow" target="_blank">清漆缓存设备知道</a>。</p><h1 id="f410" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">4.按需组块</h1><p id="d12a" class="pw-post-body-paragraph ir is hu it b iu lf iw ix iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo hn dt translated">有时，即使是同一条路线，我们也可能会有较重的部件，不需要按照当前路线运输。这些可以按需加载，既可以在访问页面后加载，也可以在事件处理程序(单击按钮)后加载。任何种类的对话框/模态(其中路线不会改变)或底层组件都是这种情况的主要候选对象。对于这样的组件，我们可以创建单独的块(有自己的js和css)，只在需要的时候下载。</p><p id="679f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，如前所述，我们在webpack配置的条目中为这样的组件创建单独的块。然后，我们在需要时触发这些块的异步检索。</p><pre class="jq jr js jt fq mf mg mh mi aw mj dt"><span id="1eb8" class="mk ki hu mg b fv ml mm l mn mo">// splits code for this component, and also asynchronously gets the <br/>// component. Returns a callback with the component.</span><span id="b889" class="mk ki hu mg b fv mp mm l mn mo">function loadHeavyDialog(cb) {<br/>  require.ensure(['./components/HeavyDialog/HeavyDialog'], (require) =&gt; {<br/>    requireStyle('heavyDialogChunk', () =&gt; {<br/>      const dial = require('./components/HeavyDialog/HeavyDialog');<br/>      if (cb) {<br/>        cb(dial);<br/>      }<br/>    });<br/>  }, 'heavyDialogChunk');<br/>}</span><span id="ab5e" class="mk ki hu mg b fv mp mm l mn mo"><strong class="mg hv"><br/>DetailsPage{Desktop}.js</strong></span><span id="f290" class="mk ki hu mg b fv mp mm l mn mo">// on a button click to load the dialog asynchronously and ensuring // this component doesn't get shipped with the parent route.<br/>function onLoadHeavyDialogButtonClick() {  <br/>   // show loader possibly<br/>   loadHeavyDialog((dialogComponent) =&gt; {<br/>       // do something with the component now.<br/>       // hide loader.<br/>   });<br/>}</span></pre><p id="0e33" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了进一步优化，您可以让这个组件在为路由加载文档后自动下载。这将确保您的用户体验不会受到负面影响；现在，用户不必等到真正需要的时候才下载程序块。</p><pre class="jq jr js jt fq mf mg mh mi aw mj dt"><span id="8a80" class="mk ki hu mg b fv ml mm l mn mo">&lt;Route name="details" path="/details" getComponent={(location, cb) =&gt; {<br/>    require.ensure([], (require) =&gt; {<br/>        requireStyle('detailsChunk', () =&gt; {<br/>            cb(null, require('./containers/Details/DetailsPage'));<br/>            // pre-emptively get a component which we know we might <br/>            // use later.<br/>            loadHeavyDialog(null); <br/>        })<br/>    }, 'detailsChunk');<br/>}}/&gt;</span></pre><p id="f6d1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样的策略也可以用于基于路线的块，这些块很有可能从当前路线被访问。</p><h1 id="1f9c" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">5.图像的大小/质量</h1><p id="5adb" class="pw-post-body-paragraph ir is hu it b iu lf iw ix iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo hn dt translated">对于媒体重的页面，减少你运送的图像的尺寸。除了通常的图像压缩，请确保您请求的图像大小是您所需要的。对移动设备要格外严格，你会惊讶地发现你可以用更小的图像处理这么多东西。我们能够在不影响任何产品指标的情况下，将手机上下载的媒体内容减少一半以上。</p><h1 id="19af" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">6.删除不需要的字体</h1><p id="e339" class="pw-post-body-paragraph ir is hu it b iu lf iw ix iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo hn dt translated">我们之前使用了3种自定义字体，2种用于渲染文本，1种用于图标。为了防止字体被浏览器视为渲染阻塞资源。在与设计团队合作后，我们削减到只有一个自定义文本字体和一个图标字体。我们对移动字体更加严格，不再需要自定义文本字体，只使用系统字体。手机的外形尺寸非常小，使用自定义字体的额外好处可以忽略不计。因此，我们能够在手机上更快地呈现内容。</p><h1 id="bd4d" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">7.对第三方/开源库要挑剔</h1><p id="bf08" class="pw-post-body-paragraph ir is hu it b iu lf iw ix iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo hn dt translated">第三方库很棒。但是它们通常具有比你需要的更多的功能。要挑剔。用它们来激励自己，然后要么实现你自己的，要么小心你需要它们做什么。需要了解其用法的一些常见第三方库示例如下:</p><ol class=""><li id="5ded" class="mq mr hu it b iu iv iy iz jc ms jg mt jk mu jo mv mw mx my dt translated"><strong class="it hv">洛达什:</strong>每当你看到<em class="ll">从洛达什</em>进口*时，这是一个不好的迹象。lodash库的大小是10kb (gzipped ),通常你只需要几个函数，而不是整个库。幸运的是，<a class="ae lk" href="https://lacke.mn/reduce-your-bundle-js-file-size/" rel="noopener ugc nofollow" target="_blank"> lodash提供了这方面的支持，并且在这里有很好的记录</a>。</li><li id="5fc0" class="mq mr hu it b iu mz iy na jc nb jg nc jk nd jo mv mw mx my dt translated"><strong class="it hv"> Material UI: </strong>毫无疑问Material UI是一个很好的起点，但是它很重。我们有几个组件使用了material ui，但是我们能够很容易地模仿它们，在这个过程中节省了相当多的空间。</li><li id="2f22" class="mq mr hu it b iu mz iy na jc nb jg nc jk nd jo mv mw mx my dt translated"><strong class="it hv"> babel-polyfill(或babel-runtime): </strong>需要babel-polyfill吗？简短回答:不会，如果你已经在用babel-runtime的话。消除对babel-polyfill的依赖可以显著减小包的大小。这里有一篇<a class="ae lk" rel="noopener" href="/@jcse/clearing-up-the-babel-6-ecosystem-c7678a314bf3#.d7y3dvh6v">精彩的文章，解释了两者的用法</a>。</li><li id="b79c" class="mq mr hu it b iu mz iy na jc nb jg nc jk nd jo mv mw mx my dt translated">再一次，这是一个非常受欢迎的库，但是考虑到你实际使用的代码量，这是一个沉重的库。这里有一个<a class="ae lk" href="https://github.com/moment/moment/issues/2373" rel="noopener ugc nofollow" target="_blank">很好的讨论</a>如何规范它的大小。</li></ol><h1 id="edf4" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">8.减少api内容/反应减少存储内容</h1><p id="ddf2" class="pw-post-body-paragraph ir is hu it b iu lf iw ix iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo hn dt translated">这仅适用于在服务器端渲染的情况。如果你是，你应该熟悉服务器在文档的底部粘贴它的redux(或者你正在使用的任何存储)的副本。如果你的页面依赖于一个强大的api(我们的曾经是)，那么初始文档的有效载荷将会大大增加。经过仔细检查，我们意识到我们的商店中有许多不需要的数据，并能够对其进行删减。</p><h1 id="f50d" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">9.继续分析你的组块</h1><p id="ed3f" class="pw-post-body-paragraph ir is hu it b iu lf iw ix iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo hn dt translated">虽然所有这些都是一次性的努力，但是经过一段时间，开发人员通常会变得粗心(尤其是在一个更大的团队中)，并且不会遵守纪律或者意识到包大小的含义。以下是一些有用的工具/技巧:</p><ol class=""><li id="47d1" class="mq mr hu it b iu iv iy iz jc ms jg mt jk mu jo mv mw mx my dt translated"><a class="ae lk" href="https://webpack.github.io/analyse/" rel="noopener ugc nofollow" target="_blank"> Webpack Analyzer </a>:查看捆绑包大小的最佳方式。</li><li id="1e96" class="mq mr hu it b iu mz iy na jc nb jg nc jk nd jo mv mw mx my dt translated">webpagetest.org<a class="ae lk" href="http://webpagetest.org" rel="noopener ugc nofollow" target="_blank">(或者Chrome开发工具):给出了你的网站需要的所有资产的概要，以及不同类型资产的大小。</a></li><li id="2d92" class="mq mr hu it b iu mz iy na jc nb jg nc jk nd jo mv mw mx my dt translated">定期监控:我们编写了一个<a class="ae lk" href="https://gist.github.com/kanavarora/cc767dd2918fbcef3d6ce2357674aced" rel="noopener ugc nofollow" target="_blank">快速实用程序来跟踪发行版中的包大小</a>。Housing也有一个关于持续集成的<a class="ae lk" rel="noopener" href="/engineering-housing/continuous-integration-using-webpagetest-and-webpack-1f4465d95405#.8vsf6zrd7">大帖子</a>。</li></ol></div><div class="ab cl lt lu hc lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hn ho hp hq hr"><p id="2e69" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">目前就这些。当然，很多这些东西只会增加很小的价值。但是绩效很少仅仅通过一件事来实现。这是许多小事的综合和持续的努力。如果你有其他这样的技巧来减少网站代码的大小，请在下面的评论中告诉我！</p><p id="368a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本系列的下一部分将讨论如何链接您的资产，以便尽可能快地下载/执行最重要的资产，进一步提高性能。</p><div class="jq jr js jt fq ab cb"><figure class="ne ju nf ng nh ni nj paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="ne ju nf ng nh ni nj paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="ne ju nf ng nh ni nj paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="lm ln lo"><p id="f922" class="ir is ll it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated"><a class="ae lk" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae lk" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae lk" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae lk" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is ll it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lk" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lk" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff nk"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>