<html>
<head>
<title>Promises Are Not Proxies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">承诺不是代理</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/promises-are-not-proxies-fd00751eb980?source=collection_archive---------0-----------------------#2016-03-15">https://medium.com/hackernoon/promises-are-not-proxies-fd00751eb980?source=collection_archive---------0-----------------------#2016-03-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="0bbd" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">试图澄清一些常见的误解</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/cca85079a944e065f1e2930682b6664c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VhZ88Mz1Ju-VieLpdpXh8Q.jpeg"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">A couple, hooking their fingers as if they are making a promise</figcaption></figure><p id="63bb" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">让我们用一句话概括一下Promises的主要目的:</p><blockquote class="kv kw kx"><p id="e7e6" class="jz ka ky kb b kc kd iv ke kf kg iy kh kz kj kk kl la kn ko kp lb kr ks kt ku hn dt translated">将同步属性添加到异步代码</p></blockquote><p id="16e4" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><a class="ae lc" href="https://blog.domenic.me/youre-missing-the-point-of-promises/" rel="noopener ugc nofollow" target="_blank">大家可能都知道</a>，之所以创建Promises，是为了让异步函数的行为类似于同步代码，比如能够<strong class="kb hv">返回值</strong>和<strong class="kb hv">抛出错误。</strong></p><p id="6411" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">让我们假设我们处在一个并行的世界中，IO永远不需要Promises，我们可以使用<a class="ae lc" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>中的同步代码从两个资源中检索数据，而不会出现现有API(如同步XHR、<code class="eh ld le lf lg b">localStorage</code>、<code class="eh ld le lf lg b">readFileSync</code>等)的任何性能缺陷。</p><p id="3c8c" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">一个资源包含足球比赛，而另一个资源包含足球结果。我们希望将数据结构转换为包含所有足球比赛和结果的单个数组。</p><p id="9fd7" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">请注意，对于本示例，我们希望使用命令性逐行代码依次加载一个请求<strong class="kb hv"/>，而不是并行加载<strong class="kb hv"/>。<code class="eh ld le lf lg b">Promise.all</code>已出桌。</p><p id="8a5d" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在理想情况下，代码如下所示:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lh li l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">A code example showing the fetching of soccer matches and soccer results using an imperative style</figcaption></figure><p id="6860" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">非常简单，它从资源中获取<code class="eh ld le lf lg b">soccerMatches</code> <em class="ky"> </em>，将数据与<code class="eh ld le lf lg b">soccerResults</code>相关联，然后在控制台中打印分数和匹配名称。</p><p id="997b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">但这不管用。</p><p id="2fd3" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">不幸的是，在撰写本文时<a class="ae lc" href="https://jakearchibald.com/2014/es7-async-functions/" rel="noopener ugc nofollow" target="_blank">，我们无法编写这样的代码。我们需要做些别的，不同的事。承诺的意义就在这里:</a></p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lh li l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">A code example showing the fetching of soccer matches and soccer results using the Promises style</figcaption></figure><p id="dd25" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">正如您在这里看到的，同步代码几乎是相同的。不同之处在于，我们返回的不是来自<code class="eh ld le lf lg b">fetchSoccerMatches*</code> <em class="ky"> </em>和<em class="ky"> </em> <code class="eh ld le lf lg b"><em class="ky">fetchSoccerResults*</em></code>的最终值，而是一个<a class="ae lc" href="https://hackernoon.com/tagged/promise" rel="noopener ugc nofollow" target="_blank">承诺</a>，它将在稍后用所需的值进行解析。注意，在代码被改为使用Promises之后，<strong class="kb hv">中的</strong> <code class="eh ld le lf lg b"><strong class="kb hv">soccerMatches</strong></code> <strong class="kb hv"> <em class="ky"> </em>变量被重命名为</strong> <code class="eh ld le lf lg b"><strong class="kb hv">fetchSoccerMatches</strong></code> <em class="ky">。</em>原因是变量不再保存数据，而是保存一个概念，即数据将在以后出现的“承诺”。</p><p id="9c17" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如何命名变量的区别非常重要。</p><p id="306a" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如果你在一个变量中保存了对一个承诺的引用，并一直把这个变量当作已解析的值，那么下一个将阅读代码的开发人员将很难区分<strong class="kb hv">期望值</strong>和<strong class="kb hv">期望得到那个值</strong>。这违反了最小惊奇原则，即“系统的一个组件的行为方式应该与该组件的用户可能期望它的行为方式相一致”。因此，在这种情况下，当处理承诺时，为了使意图清晰，命名非常重要。</p><blockquote class="lj"><p id="3597" class="lk ll hu bd lm ln lo lp lq lr ls ku ek translated">将承诺引用视为已解析的值，将很难区分预期值和获得该值的期望。</p></blockquote><p id="7178" class="pw-post-body-paragraph jz ka hu kb b kc lt iv ke kf lu iy kh ki lv kk kl km lw ko kp kq lx ks kt ku hn dt translated">使用变量名来对待值，就好像不管有没有承诺它们都是一样的，这是一个错误。虽然一个<a class="ae lc" href="https://sourcemaking.com/design_patterns/proxy" rel="noopener ugc nofollow" target="_blank">代理</a> <strong class="kb hv">不会改变一个已有组件的接口</strong>并且可以被视为你正在使用原始组件，但是<strong class="kb hv">一个承诺会改变</strong>。</p><p id="882d" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">换句话说，承诺不是代理。</p><p id="7849" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">当使用小代码库工作时，上面的问题并不清楚，只有当您开始使用更大的系统时，其中有已经从异步数据源检索的变量和应该稍后检索的其他变量的混合。根据上下文，你不能通过阅读代码来判断变量是承诺还是解析值。这可能是危险的，因为它可能会通过诱导审查者将<a class="ae lc" href="https://pt.wikipedia.org/wiki/Duck_typing" rel="noopener ugc nofollow" target="_blank"> duck typed </a>变量解释为正确的解析值而使代码审查中的错误不被注意到，而实际上它并不是。</p><p id="35cd" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">当你在阅读别人(甚至是你自己)写的代码时，你不需要理解代码中发生的事情的整个上下文。一小段代码应该能够清楚地表达一小部分业务逻辑，而不需要太多的努力。</p><p id="3dea" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">考虑到这一点，让我们以上面的例子为例，断章取义。您唯一需要知道的是，代码所在的模块会创建一个包含正确结果的匹配列表:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lh li l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">A subset of the first code example showing the fetching of soccer matches from a resource using the Promises style</figcaption></figure><p id="9b77" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><code class="eh ld le lf lg b">soccerResults</code>是承诺还是解决的价值？你应该从这个名字推断出是哪种类型？</p><p id="ca2d" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><a class="ae lc" href="http://martinfowler.com/bliki/TwoHardThings.html" rel="noopener ugc nofollow" target="_blank">给事物命名是困难的</a>，但是将Promise对象视为用<a class="ae lc" href="https://hackernoon.com/tagged/proxy" rel="noopener ugc nofollow" target="_blank">代理</a>模式创建的对象是误解的表现，这可能导致不容易被发现的错误。</p><p id="4aa1" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">不要认为承诺应该像最终数据结构一样对待，它们只是解决JavaScript中异步数据处理效率低下的实用工具。</p></div><div class="ab cl ly lz hc ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hn ho hp hq hr"><p id="54c2" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">感谢阅读。如果你有一些反馈，请通过<a class="ae lc" href="https://twitter.com/FagnerBrack" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae lc" href="https://www.facebook.com/fagner.brack" rel="noopener ugc nofollow" target="_blank">脸书</a>或<a class="ae lc" href="http://github.com/FagnerMartinsBrack" rel="noopener ugc nofollow" target="_blank"> Github </a>联系我。</p></div></div>    
</body>
</html>