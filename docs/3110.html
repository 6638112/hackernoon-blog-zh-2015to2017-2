<html>
<head>
<title>A Frontender’s Guide To The Galaxy: Pt I &amp; II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">银河前沿指南:第一卷和第二卷</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-frontenders-guide-to-the-galaxy-pt-i-ii-3ae2f85d4a01?source=collection_archive---------15-----------------------#2017-03-13">https://medium.com/hackernoon/a-frontenders-guide-to-the-galaxy-pt-i-ii-3ae2f85d4a01?source=collection_archive---------15-----------------------#2017-03-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="26fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">在过去的几个月里，我一直致力于为从过时的前端堆栈(ColdFusion)迁移到能再使用3到5年的产品奠定基础。在本文中，我将概述所做的选择以及它们如何解决(经典的)前端开发问题。它是技术性的，但它并不假定读者了解前端世界的最新发展。</em></p></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><h2 id="0adb" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">一.开店</h2><p id="949d" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated"><a class="ae kx" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">【NodeJS】</strong></a>:2017年，任何一个涉足前端开发的人都应该做的第一件事，可能就是安装NodeJS。NodeJS是一个<a class="ae kx" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>运行时，它最初被设计用来交付快速和可伸缩的<a class="ae kx" href="https://hackernoon.com/tagged/network" rel="noopener ugc nofollow" target="_blank">网络</a>应用程序，但从我们的角度来看更重要的是，它已经发展成为今天前端开发中使用的许多工具的基础。</p><p id="6faf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae kx" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> npm </strong> </a> : NodeJS自带一个包管理器，<em class="jp"> npm </em>(节点包管理器的简称)，开发者可以在一个中央注册表中共享JavaScript模块/包。这个注册中心现在拥有超过400，000个独立的包，从像<code class="eh ky kz la lb b">left-pad</code>这样的小型实用模块，到像<code class="eh ky kz la lb b">angular</code>这样的框架，到……成熟的包管理器<em class="jp">，</em>像<code class="eh ky kz la lb b">bower</code>。您可以通过导航到您的项目根目录并运行<code class="eh ky kz la lb b">npm install package</code>来简单地安装一个依赖项。</p><p id="cbd9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了聪明地使用他人的代码而不是通过<code class="eh ky kz la lb b">npm install</code>运行自己的代码之外，npm还允许我们通过使用JSON文件来管理依赖关系，该文件包含您的应用程序所需的(版本)包，从而消除了在存储库中签入外部依赖关系的需要。<em class="jp">(你也可以为npm注册使用新的Yarn客户端，它更快更可预测)。</em></p><p id="a7f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae kx" href="https://git-scm.com/downloads" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> Git Bash </strong>您需要一些更接近Bash所提供的东西。Windows 10拥有令人难以置信的(嗯，对于Windows来说)<em class="jp"> Bash on Ubuntu on Windows </em>，但要启动并运行它还需要更多的工作。Git Bash是一个轻量级的替代方案，它可以让您在98%的情况下达到目标。</a></p><p id="996d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae kx" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">【Visual Studio Code</strong></a>:微软最新的代码编辑器功能强大:语法高亮、代码补全、代码片段、主题化、扩展等常见功能，还有一个集成的终端、出色的调试支持，以及对那些不使用命令行的人的Git的一流(好吧，也许是二流)支持。额外的好处:扩展是用JavaScript编写的(并通过NodeJS执行)，所以创建/贡献这些是轻而易举的事(我认为微软有扩展开发的愉快体验，所以试试吧！).<em class="jp">(提示:使用</em> <a class="ae kx" href="https://gist.github.com/dgieselaar/ff74be3e02cf571f6b47a8c61157581f" rel="noopener ugc nofollow" target="_blank"> <em class="jp">这些快捷键</em> </a> <em class="jp">可以更快地切换标签)。</em></p><h2 id="f113" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">二。脚手架</h2><p id="474b" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">现在我们有了工具箱，我们需要有一个工作场所。我们需要建立一个构建系统，使我们能够:</p><ul class=""><li id="f4f6" class="lc ld hu it b iu iv iy iz jc le jg lf jk lg jo lh li lj lk dt translated">开发和构建单页应用程序</li><li id="78c5" class="lc ld hu it b iu ll iy lm jc ln jg lo jk lp jo lh li lj lk dt translated">开发和构建可嵌入单页应用程序和任何给定网站的独立组件</li><li id="6e0b" class="lc ld hu it b iu ll iy lm jc ln jg lo jk lp jo lh li lj lk dt translated">以最小的开销开发、构建和发布独立的包</li></ul><p id="100d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">文件夹结构</strong>:我们需要做的第一件事，是将软件包与我们将要部署的应用程序分开。<code class="eh ky kz la lb b">packages</code>是包所在的地方，<code class="eh ky kz la lb b">apps</code>是我们构建应用程序和组件的地方(为了简洁起见，我们称它们为应用程序)。</p><pre class="lq lr ls lt fq lu lb lv lw aw lx dt"><span id="42e0" class="jx jy hu lb b fv ly lz l ma mb">- apps<br/>- packages</span></pre><p id="38b0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在应用程序中，我们定义了一个<code class="eh ky kz la lb b">package.json</code>文件，它包含了应用程序的依赖关系。我们假设所有应用程序的依赖关系大致相同，因此我们将共享它们，而不是为每个应用程序定义依赖关系。然后我们将在<code class="eh ky kz la lb b">apps</code>中创建两个文件夹。</p><pre class="lq lr ls lt fq lu lb lv lw aw lx dt"><span id="e6af" class="jx jy hu lb b fv ly lz l ma mb">apps<em class="jp"><br/>- entries<br/></em>-- app<br/>-- componentA<br/>-- server<br/><em class="jp">- shared<br/></em>-- util<br/>package.json</span></pre><p id="1076" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ky kz la lb b">entries</code> <em class="jp"> </em>包含了我们单独应用的入口点，每个入口点一个文件夹。例如，我们可能有一个单页应用程序的入口点，或者componentA的入口点，或者服务器端呈现的应用程序shell的入口点。然后在<code class="eh ky kz la lb b">shared</code>中，我们有将在应用间共享的代码，例如认证服务。</p><p id="899e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae kx" href="https://lernajs.io/" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">Lerna</strong></a><strong class="it hv">:</strong>为了将分离的包链接在一起，并在我们的应用程序代码中使用，我们使用Lerna。这是一个很棒的工具，它基本上在你的<code class="eh ky kz la lb b">node_modules</code>文件夹(你的npm安装的依赖项所在的地方)中创建了一个到定义的包的符号链接。这使得我们可以非常快速地开发，因为我们不必构建和发布每个更改——我们可以在应用程序代码中直接使用更改后的包。</p><p id="ad57" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae kx" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> Webpack </strong> </a>:为了构建我们的应用程序，我们使用Webpack:一个功能强大得离谱的现代捆绑器。设置起来有点困难，但一旦一切就绪，这个不可思议的机器会为我们做些什么:</p><ul class=""><li id="afb7" class="lc ld hu it b iu iv iy iz jc le jg lf jk lg jo lh li lj lk dt translated">无缝导入和使用的不仅是JavaScript模块，还有JSON、CSS、图片、字体，基本上你能想到的都有。</li><li id="bfba" class="lc ld hu it b iu ll iy lm jc ln jg lo jk lp jo lh li lj lk dt translated">使用这些导入来构建依赖图，并且a)只服务于我们实际使用的代码，导致更小的包和更好的性能，b)容易地找到和删除死代码，以保持我们的代码库干净。</li><li id="caf0" class="lc ld hu it b iu ll iy lm jc ln jg lo jk lp jo lh li lj lk dt translated">启用一种开发模式，该模式侧重于快速重建，并在发生更改时自动刷新页面。这使得开发人员可以快速看到他们更改的结果(通常在1秒钟之内)，防止失去焦点，提高生产力。更神奇的是用React和React Hot Loader开发时的体验:你甚至不用刷新页面就能看到代码变化。更新的不仅仅是CSS甚至JavaScript函数也被替换为中的<em class="jp">。对任何开发者来说都是难以置信的体验。</em></li><li id="fb67" class="lc ld hu it b iu ll iy lm jc ln jg lo jk lp jo lh li lj lk dt translated">优化的生产版本具有更长的构建时间、更小的规模和更好的性能(例如，一些库删除了生产版本中的调试功能)。以生产为目标的包附带了源代码图，允许我们“美化”缩小的、不可读的代码来调试活的bug。</li><li id="4898" class="lc ld hu it b iu ll iy lm jc ln jg lo jk lp jo lh li lj lk dt translated">允许开发人员定义“分割点”，将应用程序的一部分代码分割成一个单独的包，只在需要时才加载(例如，单独的视图)。这再次帮助我们保持最初的JavaScript包较小，这样页面可以启动得更快。</li><li id="9457" class="lc ld hu it b iu ll iy lm jc ln jg lo jk lp jo lh li lj lk dt translated">当我们的包超过300KB时，请出错，<a class="ae kx" rel="noopener" href="/webpack/webpack-performance-budgets-13d4880fbf6d#.n5x0l2c96">这是JavaScript文件的推荐最大值</a>，确保我们继续关注性能。</li></ul><p id="5cb0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae kx" href="http://babeljs.io/" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">Babel</strong></a>:web开发的一个问题一直是跨浏览器兼容性:我们只能使用目标浏览器支持的(新)JavaScript特性。很难记住什么在什么浏览器中起作用，功能检测很难得到正确的结果，这使得大多数开发人员犯了谨慎的错误，并远离新的语言功能。这就是Babel的用武之地:一种将“现代”JavaScript代码转换成每个浏览器都支持的子集的工具。再加上令人惊叹的<code class="eh ky kz la lb b"><a class="ae kx" href="http://babeljs.io/docs/plugins/preset-env/" rel="noopener ugc nofollow" target="_blank">babel-preset-env</a></code>，我们可以简单地提供一个支持的浏览器列表，Babel将会传送足够的文件以确保它在任何地方都能工作。这样我们就可以安全地使用一些好东西，比如箭头函数、对象析构、扩展操作符、rest参数，以及更高级的东西，比如async/await和生成器。</p><p id="3595" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae kx" href="https://github.com/postcss/postcss" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">post CSS</strong></a><strong class="it hv">:</strong>对于CSS和JavaScript来说也是一样:当你处于CSS规范的前沿时，跨浏览器兼容性很快就会成为一个问题。这就是为什么我们使用PostCSS，一个针对CSS的编译器，它允许你定义一组用于转换源代码的插件。我们使用的一些插件是<code class="eh ky kz la lb b"><a class="ae kx" href="https://github.com/postcss/autoprefixer" rel="noopener ugc nofollow" target="_blank">autoprefixer</a></code>，它自动将厂商前缀添加到需要它的属性中，或者是<code class="eh ky kz la lb b"><a class="ae kx" href="https://github.com/postcss/postcss-custom-properties" rel="noopener ugc nofollow" target="_blank">postcss-custom-properties</a></code>，它允许我们使用CSS变量(目前，仅在编译时)，我们用它们来进行主题化。</p><p id="7ed9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae kx" href="https://flowtype.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">流</strong></a><strong class="it hv">:</strong>JavaScript的好处之一，它难以置信的动态性，在较大的代码库中会很快成为不利因素，越来越多地导致运行时错误。更严格的类型系统将允许我们在编译时而不是运行时捕捉错误。Flow是一个静态类型检查器，由脸书开发，它允许您为变量声明和函数参数定义类型。如果这个变量没有被正确使用，Flow可以警告您。例如，如果您将一个数字传递给一个需要字符串的函数，Flow将会出错。但是Flow的伟大之处在于它为您完成了大部分工作——它遍历您的代码(和外部依赖项)并确定变量的类型<em class="jp">而无需定义它</em>。可能Flow唯一需要一点帮助的地方是来自后端的数据。这就是为什么我们在前端代码中添加了反映我们平台的对象模型的类型，使我们能够放心地访问和转换来自后端API的数据，并且能够在对象模型改变和我们更新类型时看到我们的代码将在哪里中断。我为Visual Studio代码使用了一个流扩展，它提供了出色的自动完成功能，并在编辑器中显示错误。</p><p id="fa8b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae kx" href="http://eslint.org/" rel="noopener ugc nofollow" target="_blank"><strong class="it hv"/></a>:最后，我们使用ESLint来检查代码中我们(或其他人)认为不好的模式。ESLint是完全可配置的，允许您做任何事情，从强制单引号或双引号到函数括号中的一致间距。我还为Visual Studio代码使用了一个ESLint扩展，它可以内联显示错误，并在保存时修复“可修复的”规则(例如，<a class="ae kx" href="http://eslint.org/docs/rules/brace-style" rel="noopener ugc nofollow" target="_blank">将行后大括号转换为行内大括号</a>)。此外，我有一个预提交git挂钩，每当我尝试提交新的更改时，它都会在我的代码上运行ESLint。</p></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><p id="065b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请继续关注第三部分，在这一部分中，我将解释我们在应用程序中使用了哪些库，以及它们如何帮助我们更快、更可靠地发布。</p><p id="0e8f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同时，<a class="ae kx" href="https://twitter.com/GieselaarD" rel="noopener ugc nofollow" target="_blank">在Twitter上关注我</a>，或者阅读我以前的一些文章:</p><div class="mc md fm fo me mf"><a rel="noopener follow" target="_blank" href="/@d.gieselaar/a-sense-of-speed-2042c2804f80"><div class="mg ab ej"><div class="mh ab mi cl cj mj"><h2 class="bd hv fv z el mk eo ep ml er et ht dt translated">速度感</h2><div class="mm l"><h3 class="bd b fv z el mk eo ep ml er et ek translated">提高单页应用程序的性能</h3></div><div class="mn l"><p class="bd b gc z el mk eo ep ml er et ek translated">medium.com</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt mu mf"/></div></div></a></div><div class="mc md fm fo me mf"><a rel="noopener follow" target="_blank" href="/@d.gieselaar/the-offline-experience-or-saying-goodbye-to-imperative-data-fetching-9b2fa487eea7"><div class="mg ab ej"><div class="mh ab mi cl cj mj"><h2 class="bd hv fv z el mk eo ep ml er et ht dt translated">离线体验(或者说，告别强制性数据获取)</h2><div class="mm l"><h3 class="bd b fv z el mk eo ep ml er et ek translated">我们最近很高兴能够在我们的(Angular)网络应用Zaaksysteem.nl上从头开始</h3></div><div class="mn l"><p class="bd b gc z el mk eo ep ml er et ek translated">medium.com</p></div></div></div></a></div><div class="mc md fm fo me mf"><a rel="noopener follow" target="_blank" href="/@d.gieselaar/structuring-a-modern-web-app-take-two-432b1e1ad2b7"><div class="mg ab ej"><div class="mh ab mi cl cj mj"><h2 class="bd hv fv z el mk eo ep ml er et ht dt translated">构建一个现代的网络应用程序，需要两个</h2><div class="mm l"><h3 class="bd b fv z el mk eo ep ml er et ek translated">在用一个非常基本的连接和缩小设置工作了几年后，它变得非常不舒服，因为我们…</h3></div><div class="mn l"><p class="bd b gc z el mk eo ep ml er et ek translated">medium.com</p></div></div><div class="mo l"><div class="mv l mq mr ms mo mt mu mf"/></div></div></a></div><figure class="lq lr ls lt fq mw"><div class="bz el l di"><div class="mx my l"/></div></figure></div></div>    
</body>
</html>