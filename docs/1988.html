<html>
<head>
<title>Let’s use const! Here’s why.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">还是用const吧！原因如下。</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/lets-use-const-here-s-why-6549dcb80708?source=collection_archive---------2-----------------------#2016-12-29">https://medium.com/hackernoon/lets-use-const-here-s-why-6549dcb80708?source=collection_archive---------2-----------------------#2016-12-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="8e42" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">在开发</em> <a class="ae jq" href="https://hackernoon.com/tagged/software" rel="noopener ugc nofollow" target="_blank"> <em class="jp">软件</em> </a> <em class="jp">的时候，我们大部分时间都花在了阅读</em> <a class="ae jq" href="https://hackernoon.com/tagged/code" rel="noopener ugc nofollow" target="_blank"> <em class="jp">代码</em> </a> <em class="jp">上。ES6提供了</em> <code class="eh jr js jt ju b"><em class="jp">let</em></code> <em class="jp">和</em> <code class="eh jr js jt ju b"><em class="jp">const</em></code> <em class="jp">作为变量声明的新版本，这些语句的部分价值在于它们可以指示如何使用变量。当阅读一段代码时，其他人可以从这些信号中得到线索，以便更好地理解我们做了什么。像这样的线索对于减少人们花在解释一段代码上的时间是至关重要的，因此我们应该尽可能地利用它们。</em></p><figure class="jw jx jy jz fq ka fe ff paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="fe ff jv"><img src="../Images/e44ad75a599c9966a59e70a856aba960.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DiNHIQ0vKqJylMe_z6ZMBg.jpeg"/></div></div></figure><p id="4d20" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个<code class="eh jr js jt ju b"><em class="jp">let</em></code>声明表明，由于时间死区规则，变量不能在声明前使用。这不是惯例，而是事实:如果我们试图在到达变量的声明语句之前访问它，程序将会失败。这些语句是块范围的，而不是函数范围的；这意味着我们需要阅读更少的代码，以便完全掌握如何使用一个<code class="eh jr js jt ju b"><em class="jp">let</em></code>变量。</p><p id="6156" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jr js jt ju b">const</code>语句也是块范围的，它也遵循TDZ语义。好处是<code class="eh jr js jt ju b">const</code>绑定只能在声明期间被赋值。</p><p id="74f5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，这意味着变量绑定不能改变，但这并不意味着值本身在任何方面都是不可变的或恒定的。引用一个对象的<code class="eh jr js jt ju b">const</code>绑定不能在以后引用不同的值，但是底层对象确实可以变异。</p><p id="d5fd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了由<code class="eh jr js jt ju b">let</code>提供的信号之外，<code class="eh jr js jt ju b">const</code>关键字表明一个变量绑定不能被重新分配。这是一个强烈的信号。你知道价值会是多少？您知道，由于块范围的原因，绑定不能在其直接包含的块之外被访问；您知道，由于TDZ语义，绑定在声明之前不会被访问。</p><p id="64fe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你只需阅读 <code class="eh jr js jt ju b"><em class="jp">const</em></code> <em class="jp">声明语句就能知道所有这些，无需扫描该变量的其他引用。</em></p><p id="bb5e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由<code class="eh jr js jt ju b">let</code>和<code class="eh jr js jt ju b">const</code>提供的约束是一种使代码更容易理解的强大方法。试着在你写的代码中增加尽可能多的约束。限制一段代码含义的声明性约束越多，将来人们阅读、解析和理解一段代码就越容易、越快。</p><p id="f1ee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然，<code class="eh jr js jt ju b">const</code>声明比<code class="eh jr js jt ju b">var</code>声明有更多的规则:块范围、TDZ、声明时赋值、无重赋值。而<code class="eh jr js jt ju b">var</code>语句只表示函数作用域。然而，规则计数并没有提供太多的洞察力。最好根据复杂性来衡量这些规则:规则是增加了还是减少了复杂性？在<code class="eh jr js jt ju b">const</code>的例子中，块作用域意味着比函数作用域更窄的作用域，TDZ意味着我们不需要为了在声明前发现用法而从声明向后扫描作用域，赋值规则意味着绑定将总是保持相同的引用。</p><p id="9fab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">受约束的语句越多，代码就越简单。随着我们对语句的含义增加约束，代码变得更加不可预测。这是静态类型的程序通常比动态类型的程序更容易阅读的最大原因之一。静态类型对程序编写者来说是一个很大的限制，但是它也对程序如何被解释有很大的限制，使得它的代码更容易理解。</p><p id="001b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">考虑到这些论点，建议您尽可能使用<code class="eh jr js jt ju b">const</code>，因为它是给我们提供最少可能性的陈述。</p><pre class="jw jx jy jz fq kh ju ki kj aw kk dt"><span id="025e" class="kl km hu ju b fv kn ko l kp kq">if (condition) {<br/>  // can't access `isReady` before declaration is reached<br/>  const isReady = true<br/>  // `isReady` binding can't be reassigned<br/>}<br/>// can't access `isReady` outside of its containing block scope</span></pre><p id="f21f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当<code class="eh jr js jt ju b">const</code>不是一个选项时，因为变量需要稍后被重新分配，我们可以求助于<code class="eh jr js jt ju b">let</code>语句。使用<code class="eh jr js jt ju b">let</code>具有<code class="eh jr js jt ju b">const</code>的所有优点，除了变量可以被重新分配。为了递增计数器、翻转布尔标志或推迟初始化，这可能是必要的。</p><p id="73f1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">考虑下面的例子，我们取一些兆字节并返回一个字符串，比如<code class="eh jr js jt ju b">1.2 GB</code>。我们使用<code class="eh jr js jt ju b">let</code>，因为如果满足条件，值需要改变。</p><pre class="jw jx jy jz fq kh ju ki kj aw kk dt"><span id="246d" class="kl km hu ju b fv kn ko l kp kq">function prettySize (input) {<br/>  let value = input<br/>  let unit = `MB`<br/>  if (value &gt;= 1024) {<br/>    value /= 1024<br/>    unit = `GB`<br/>  }<br/>  if (value &gt;= 1024) {<br/>    value /= 1024<br/>    unit = `TB`<br/>  }<br/>  return `${ value.toFixed(1) } ${ unit }`<br/>}</span></pre><p id="d240" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">增加对Pb的支持需要在<code class="eh jr js jt ju b">return</code>语句前增加一个新的<code class="eh jr js jt ju b">if</code>分支。</p><pre class="jw jx jy jz fq kh ju ki kj aw kk dt"><span id="0fcb" class="kl km hu ju b fv kn ko l kp kq">if (value &gt;= 1024) {<br/>  value /= 1024<br/>  unit = `PB`<br/>}</span></pre><p id="8db1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们想让<code class="eh jr js jt ju b">prettySize</code>更容易扩展新单元，我们可以考虑实现一个<code class="eh jr js jt ju b">toLargestUnit</code>函数，为任何给定的<code class="eh jr js jt ju b">input</code>及其当前单元计算<code class="eh jr js jt ju b">unit</code>和<code class="eh jr js jt ju b">value</code>。然后我们可以使用<code class="eh jr js jt ju b">prettySize</code>中的<code class="eh jr js jt ju b">toLargestUnit</code>来返回格式化的字符串。</p><p id="c411" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面的代码片段实现了这样一个功能。它依赖于支持的<code class="eh jr js jt ju b">units</code>列表，而不是为每个单元使用一个新的分支。当输入<code class="eh jr js jt ju b">value</code>至少是<code class="eh jr js jt ju b">1024</code>并且有更大的单元时，我们将输入除以<code class="eh jr js jt ju b">1024</code>并移动到下一个单元。然后我们用更新的值调用<code class="eh jr js jt ju b">toLargestUnit</code>，这将继续递归地减少<code class="eh jr js jt ju b">value</code>，直到它足够小或者我们达到最大的单元。</p><pre class="jw jx jy jz fq kh ju ki kj aw kk dt"><span id="9cef" class="kl km hu ju b fv kn ko l kp kq">function toLargestUnit (value, unit = `MB`) {<br/>  const units = [`MB`, `GB`, `TB`]<br/>  const i = units.indexOf(unit)<br/>  const nextUnit = units[i + 1]<br/>  if (value &gt;= 1024 &amp;&amp; nextUnit) {<br/>    return toLargestUnit(value / 1024, nextUnit)<br/>  }<br/>  return { value, unit }<br/>}</span></pre><p id="877b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">引入petabyte支持过去涉及一个新的<code class="eh jr js jt ju b">if</code>分支和重复逻辑，但现在只需要在<code class="eh jr js jt ju b">units</code>数组的末尾添加<code class="eh jr js jt ju b">PB</code>字符串。</p><p id="bc3e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jr js jt ju b">prettySize</code>函数变得只关心如何显示字符串，因为它可以将其计算卸载给<code class="eh jr js jt ju b">toLargestUnit</code>函数。这种关注点的分离也有助于产生更可读的代码。</p><pre class="jw jx jy jz fq kh ju ki kj aw kk dt"><span id="0a71" class="kl km hu ju b fv kn ko l kp kq">function prettySize (input) {<br/>  const { value, unit } = toLargestUnit(input)<br/>  return `${ value.toFixed(1) } ${ unit }`<br/>}</span></pre><p id="c98c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每当一段代码有需要重新分配的变量时，我们应该花几分钟思考是否有更好的模式可以解决同样的问题而不需要重新分配。这并不总是可能的，但在大多数情况下可以完成。</p><p id="3f5c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦你找到了一个不同的解决方案，把它和你以前的方案进行比较。确保代码可读性确实得到了提高，并且实现仍然正确。单元测试在这方面很有帮助，因为它们可以确保你不会两次遇到同样的缺点。如果重构的代码在可读性或可扩展性方面看起来更差，请仔细考虑返回到以前的解决方案。</p><p id="a83d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">考虑下面的例子，我们使用数组连接来生成<code class="eh jr js jt ju b">result</code>数组。这里，我们也可以通过简单的调整从<code class="eh jr js jt ju b">let</code>变为<code class="eh jr js jt ju b">const</code>。</p><pre class="jw jx jy jz fq kh ju ki kj aw kk dt"><span id="45c7" class="kl km hu ju b fv kn ko l kp kq">function makeCollection (size) {<br/>  let result = []<br/>  if (size &gt; 0) {<br/>    result = result.concat([1, 2])<br/>  }<br/>  if (size &gt; 1) {<br/>    result = result.concat([3, 4])<br/>  }<br/>  if (size &gt; 2) {<br/>    result = result.concat([5, 6])<br/>  }<br/>  return result<br/>}<br/>makeCollection(0) // &lt;- []<br/>makeCollection(1) // &lt;- [1, 2]<br/>makeCollection(2) // &lt;- [1, 2, 3, 4]<br/>makeCollection(3) // &lt;- [1, 2, 3, 4, 5, 6]</span></pre><p id="4b7c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以用接受多个值的<code class="eh jr js jt ju b">Array#push</code>来代替重新分配操作。如果我们有一个动态列表，我们可以使用spread操作符来推送尽可能多的<code class="eh jr js jt ju b">...items</code>。</p><pre class="jw jx jy jz fq kh ju ki kj aw kk dt"><span id="98f0" class="kl km hu ju b fv kn ko l kp kq">function makeCollection (size) {<br/>  const result = []<br/>  if (size &gt; 0) {<br/>    result.push(1, 2)<br/>  }<br/>  if (size &gt; 1) {<br/>    result.push(3, 4)<br/>  }<br/>  if (size &gt; 2) {<br/>    result.push(5, 6)<br/>  }<br/>  return result<br/>}<br/>makeCollection(0) // &lt;- []<br/>makeCollection(1) // &lt;- [1, 2]<br/>makeCollection(2) // &lt;- [1, 2, 3, 4]<br/>makeCollection(3) // &lt;- [1, 2, 3, 4, 5, 6]</span></pre><p id="bb07" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当你确实需要使用<code class="eh jr js jt ju b">Array#concat</code>时，你应该使用<code class="eh jr js jt ju b">[...result, 1, 2]</code>来代替，这样会更简单。</p><p id="8cec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们要讨论的最后一个案例是重构。有时，我们编写类似下一个代码片段的代码，通常是在一个更大的函数的上下文中。</p><pre class="jw jx jy jz fq kh ju ki kj aw kk dt"><span id="8703" class="kl km hu ju b fv kn ko l kp kq">let completionText = `in progress`<br/>if (completionPercent &gt;= 85) {<br/>  completionText = `almost done`<br/>} else if (completionPercent &gt;= 70) {<br/>  completionText = `reticulating splines`<br/>}</span></pre><p id="ada1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这些情况下，将逻辑提取到一个纯函数中是有意义的。这样，我们避免了较大函数顶部附近的初始化复杂性，同时将所有关于计算完成文本的逻辑聚集在一个地方。</p><p id="55e2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面这段代码展示了我们如何将完成文本逻辑提取到它自己的函数中。然后我们可以去掉<code class="eh jr js jt ju b">getCompletionText</code>，使代码在可读性方面更加线性。</p><pre class="jw jx jy jz fq kh ju ki kj aw kk dt"><span id="7f0f" class="kl km hu ju b fv kn ko l kp kq">const completionText = getCompletionText(completionPercent)<br/>// ...<br/>function getCompletionText(progress) {<br/>  if (progress &gt;= 85) {<br/>    return `almost done`<br/>  }<br/>  if (progress &gt;= 70) {<br/>    return `reticulating splines`<br/>  }<br/>  return `in progress`<br/>}</span></pre><p id="bf1b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<code class="eh jr js jt ju b">const</code>vs<code class="eh jr js jt ju b">let</code>vs<code class="eh jr js jt ju b">var</code>中你的立场是什么？</p><blockquote class="kr ks kt"><p id="3f27" class="ir is jp it b iu iv iw ix iy iz ja jb ku jd je jf kv jh ji jj kw jl jm jn jo hn dt translated">这篇文章摘自我正在写的一本书<a class="ae jq" href="https://ponyfoo.com/books/practical-es6/chapters#toc" rel="noopener ugc nofollow" target="_blank">实用ES6 </a>。它在网上以HTML格式公开发布，在GitHub上以AsciiDoc格式发布。它最近<strong class="it hv">筹集了超过12，000美元<em class="hu"> </em> </strong> <em class="hu">💰</em>在Indiegogo 上资助<a class="ae jq" href="https://www.indiegogo.com/projects/modular-javascript-a-pragmatic-js-book-series#/" rel="noopener ugc nofollow" target="_blank">，并由发行商O'Reilly Media作为</a><a class="ae jq" href="http://shop.oreilly.com/product/0636920047124.do" rel="noopener ugc nofollow" target="_blank">提前发布</a>。</p></blockquote></div><div class="ab cl kx ky hc kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hn ho hp hq hr"><p id="236c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">最初发表于</em><a class="ae jq" href="https://ponyfoo.com/articles/var-let-const" rel="noopener ugc nofollow" target="_blank"><em class="jp">ponyfoo.com</em></a><em class="jp">。</em></p><div class="jw jx jy jz fq ab cb"><figure class="le ka lf lg lh li lj paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="le ka lf lg lh li lj paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="le ka lf lg lh li lj paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="kr ks kt"><p id="f922" class="ir is jp it b iu iv iw ix iy iz ja jb ku jd je jf kv jh ji jj kw jl jm jn jo hn dt translated"><a class="ae jq" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jq" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jq" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae jq" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is jp it b iu iv iw ix iy iz ja jb ku jd je jf kv jh ji jj kw jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jq" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jq" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jw jx jy jz fq ka fe ff paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="fe ff lk"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="jw jx jy jz fq ka"><div class="bz el l di"><div class="ll lm l"/></div></figure></div></div>    
</body>
</html>