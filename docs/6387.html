<html>
<head>
<title>How AI can be used to replicate a game engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">人工智能如何被用来复制游戏引擎</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-ai-can-be-used-to-replicate-a-game-engine-6160d000b1e3?source=collection_archive---------12-----------------------#2017-09-15">https://medium.com/hackernoon/how-ai-can-be-used-to-replicate-a-game-engine-6160d000b1e3?source=collection_archive---------12-----------------------#2017-09-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="414f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">这是研究论文</em> <a class="ae jq" href="https://www.google.co.in/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwjiv8Ks_KfWAhULKY8KHbBeAjoQFggnMAA&amp;url=https%3A%2F%2Fwww.cc.gatech.edu%2F~riedl%2Fpubs%2Fijcai17.pdf&amp;usg=AFQjCNF3lLPanlsi1MVVhKUt0ql-q4gftQ" rel="noopener ugc nofollow" target="_blank"> <em class="jp">游戏引擎学习视频</em> </a> <em class="jp">的衍生作品。这要归功于佐治亚理工学院的马修·古兹迪尔、李博阳、马克·o·里德尔。</em></p><p id="82f8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在下面的视频中，马里奥由一个人工智能代理扮演，它使用神经进化的过程来像大师级玩家一样玩游戏。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="jw jx l"/></div></figure><p id="14fc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这很棒，然而佐治亚理工学院的研究人员已经采取了下一步措施。他们没有学习如何玩游戏，而是学习了游戏引擎机制。他们的算法通过扫描游戏视频并反复即兴创作假设的引擎来实现这一点。</p><div class="jr js jt ju fq ab cb"><figure class="jy jv jz ka kb kc kd paragraph-image"><img src="../Images/d90d5dce19b47c2ba4c69d277d9736a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/1*lsI-VEhNFdp_AopHtwdHxA.gif"/></figure><figure class="jy jv jz ka kb kc kd paragraph-image"><img src="../Images/e315150f935da14104e6c34db7ed9e59.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/1*RIDYeOTo3eD-srqgScuR0g.gif"/><figcaption class="kg kh fg fe ff ki kj bd b be z ek kk di kl km">Original Mega Man game play video on the left. Cloned game engine on the right. Image from Georgia Tech</figcaption></figure></div><h1 id="bb24" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">概观</h1><p id="d9ba" class="pw-post-body-paragraph ir is hu it b iu ll iw ix iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo hn dt translated">该系统扫描每一帧，找出其中存在的对象列表，然后在相邻帧之间运行一种算法，以查看对象在帧之间如何变化。最后，当检测到的变化大于设定的阈值时，运行引擎搜索算法。</p><h1 id="8f28" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">解析帧</h1><p id="a9a3" class="pw-post-body-paragraph ir is hu it b iu ll iw ix iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo hn dt translated">该系统需要两个输入，一个精灵托盘(游戏中的一组角色和对象)和一个游戏视频。使用这些输入和OpenCV(计算机视觉库),我们可以理解精灵的数量和它们在各自帧中的空间位置。</p><p id="c191" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">给定精灵的帧序列和它们的位置。运行算法以在下一帧中将每个精灵与其最近的邻居匹配。如果精灵的数量不匹配，则创建一个空白精灵来匹配剩余的精灵。这发生在某些情况下，例如:当马里奥跳过一个敌人并摧毁它。</p><p id="980e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，当这些sprite表示被转换成事实列表时，解析就完成了。这些事实类型都需要一个预先编写的函数来从给定的输入帧中导出它。以下是事实类型的列表。</p><h2 id="5387" class="lq ko hu bd kp lr ls lt kt lu lv lw kx jc lx ly lb jg lz ma lf jk mb mc lj md dt translated">动画</h2><p id="3f98" class="pw-post-body-paragraph ir is hu it b iu ll iw ix iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo hn dt translated">这是所有精灵图像的集合，根据它们的原始文件名，宽度和高度。例如:如果在位置0，0找到高度大小为[26，26]的图像“mario1.png ”,动画事实将是{mario1，26，26}</p><h2 id="bda4" class="lq ko hu bd kp lr ls lt kt lu lv lw kx jc lx ly lb jg lz ma lf jk mb mc lj md dt translated"><strong class="ak"> <em class="me">空间</em> </strong></h2><p id="acd8" class="pw-post-body-paragraph ir is hu it b iu ll iw ix iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo hn dt translated">这是框架中带有x，y坐标的精灵的文件名。</p><h2 id="1b56" class="lq ko hu bd kp lr ls lt kt lu lv lw kx jc lx ly lb jg lz ma lf jk mb mc lj md dt translated"><strong class="ak"> <em class="me">关系X </em> </strong></h2><p id="935f" class="pw-post-body-paragraph ir is hu it b iu ll iw ix iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo hn dt translated">这是x维度中一对精灵之间的关系。例如:(mario1，mario1离管道1最近的边，3px，管道1，管道1离mario1最近的边)。这使得系统能够学习碰撞规则，例如当马里奥撞到管道时，其速度变为0)</p><h2 id="6d92" class="lq ko hu bd kp lr ls lt kt lu lv lw kx jc lx ly lb jg lz ma lf jk mb mc lj md dt translated"><strong class="ak"> <em class="me">关系关系</em> </strong></h2><p id="a176" class="pw-post-body-paragraph ir is hu it b iu ll iw ix iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo hn dt translated">上面提到的y维中的相同事实就像马里奥撞上砖块一样。</p><h2 id="98e4" class="lq ko hu bd kp lr ls lt kt lu lv lw kx jc lx ly lb jg lz ma lf jk mb mc lj md dt translated"><strong class="ak"><em class="me"/></strong></h2><p id="40ed" class="pw-post-body-paragraph ir is hu it b iu ll iw ix iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo hn dt translated">这记录了精灵在x维度的速度，它比较了前一帧和下一帧。例如:如果马里奥在第1帧的位置是[0，0],在第2帧的位置是[10，0],那么事实就是速度x:{马里奥，10}</p><h2 id="f9cc" class="lq ko hu bd kp lr ls lt kt lu lv lw kx jc lx ly lb jg lz ma lf jk mb mc lj md dt translated"><strong class="ak"> <em class="me">速度性</em> </strong></h2><p id="fa8d" class="pw-post-body-paragraph ir is hu it b iu ll iw ix iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo hn dt translated">上面提到的y维中的相同事实。</p><h2 id="2837" class="lq ko hu bd kp lr ls lt kt lu lv lw kx jc lx ly lb jg lz ma lf jk mb mc lj md dt translated"><strong class="ak"> <em class="me"> CameraX </em> </strong></h2><p id="7aa5" class="pw-post-body-paragraph ir is hu it b iu ll iw ix iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo hn dt translated">这存储了摄像机在一个关卡中能走多远。</p><h1 id="5e12" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">发动机学习</h1><p id="eab2" class="pw-post-body-paragraph ir is hu it b iu ll iw ix iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo hn dt translated">引擎学习方法试图制作一个游戏引擎，它可以预测在解析的帧中观察到的变化。游戏引擎是一组规则，每个规则都有IF和THEN。如果马里奥撞上了一根管子，那么把速度x改为0。该方法由帧扫描算法和引擎搜索算法组成。帧扫描算法扫描经过解析的帧，并开始搜索证明预测帧和实际帧之间的差异的规则。如果发现一个游戏引擎将差异减少到一定程度，则进行另一次扫描以确保新的引擎能够准确预测先前的帧。</p><h2 id="5b0d" class="lq ko hu bd kp lr ls lt kt lu lv lw kx jc lx ly lb jg lz ma lf jk mb mc lj md dt translated">帧扫描算法</h2><pre class="jr js jt ju fq mf mg mh mi aw mj dt"><span id="6c9f" class="lq ko hu mg b fv mk ml l mm mn">engine = new Engine()<br/>currentFrame = frames [0]</span><span id="d2c4" class="lq ko hu mg b fv mo ml l mm mn">while i=1 to frameSize do<br/>  <br/>   # Check if this engine predicts within the threshold<br/>  <br/>   frameDist = Distance(engine, currentFrame, i + 1)<br/>   if frameDist &lt; threshold then<br/>     currentFrame = Predict(engine, currentFrame, i + 1)<br/>     continue</span><span id="67e5" class="lq ko hu mg b fv mo ml l mm mn">   # Update engine and start parse over</span><span id="07c4" class="lq ko hu mg b fv mo ml l mm mn">   engine = EngineSearch(engine, currentFrame, i + 1)<br/>   i=1<br/>   currentFrame = frames[0]</span></pre><p id="88c6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">帧扫描算法将一组解析的帧和阈值作为输入，并输出游戏引擎。距离函数逐个像素地给出实际帧和预测帧之间的距离。如果距离小于设定的阈值，预测函数将返回与实际帧最接近的帧。</p><h2 id="8a3c" class="lq ko hu bd kp lr ls lt kt lu lv lw kx jc lx ly lb jg lz ma lf jk mb mc lj md dt translated">引擎扫描算法</h2><pre class="jr js jt ju fq mf mg mh mi aw mj dt"><span id="3956" class="lq ko hu mg b fv mk ml l mm mn">closed = []<br/>open = PriorityQueue()<br/>open.push(1,engine)</span><span id="6a38" class="lq ko hu mg b fv mo ml l mm mn">while open is not empty do<br/>   <br/>   node = open.pop()<br/>   <br/>   if node[0]&lt;threshold then<br/>      return node [1]<br/>   <br/>   engine = node<br/>   closed.add(engine)<br/>   <br/>   for Neighbor n of engine do<br/>       if n in closed then <br/>          continue<br/>   distance = Distance(engine, currentFrame, goalFrame)<br/>   open.push(distance + engine.rules.length, n)</span></pre><p id="a778" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">引擎扫描算法进行搜索以找到在实际帧的某个阈值内创建预测帧的一组规则。这是通过为给定引擎生成邻居来实现的。</p><p id="0171" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">邻居通过以下方式生成</em></p><h2 id="d122" class="lq ko hu bd kp lr ls lt kt lu lv lw kx jc lx ly lb jg lz ma lf jk mb mc lj md dt translated">添加规则</h2><p id="7e48" class="pw-post-body-paragraph ir is hu it b iu ll iw ix iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo hn dt translated">这需要选取一对同类事实，一个来自当前帧，另一个来自目标帧。例如:当前帧的velocityX事实为{mario1，5}，目标帧的事实为{mario1，0}。这些对事实代表规则处理的变化。这里马里奥的速度下降了。当前框架中的其他事实构成了该规则的初始条件。尽管这些将包含发生变化所不需要的条件。例如:马里奥的速度下降是因为他在管道之间的空间距离太近。这也可能包括他头顶上有云的情况。通过修改规则的条件事实，这些初始条件集被最小化。</p><h2 id="300a" class="lq ko hu bd kp lr ls lt kt lu lv lw kx jc lx ly lb jg lz ma lf jk mb mc lj md dt translated">修改规则的条件事实</h2><p id="c80e" class="pw-post-body-paragraph ir is hu it b iu ll iw ix iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo hn dt translated">通过采用现有规则的条件和当前条件集之间的公共条件，给定规则的条件集被最小化。如果这个邻居减少了预测的和目标帧的像素距离，那么这个比另一个添加新规则的邻居更可能被选择。这导致了对更小和通用发动机的偏好。</p><h2 id="47cd" class="lq ko hu bd kp lr ls lt kt lu lv lw kx jc lx ly lb jg lz ma lf jk mb mc lj md dt translated">修改规则以覆盖附加的子画面</h2><p id="166e" class="pw-post-body-paragraph ir is hu it b iu ll iw ix iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo hn dt translated">这就像上面的一个期望它可以做的变化可以扩展。例如:当马里奥跳到一个敌人身上时，它就消失了，或者从技术上来说，它从有价值的动画事实变成了没有价值的动画事实。所以一条规则可以处理多种情况。</p><h2 id="7e39" class="lq ko hu bd kp lr ls lt kt lu lv lw kx jc lx ly lb jg lz ma lf jk mb mc lj md dt translated">将规则修改为控制规则</h2><p id="d394" class="pw-post-body-paragraph ir is hu it b iu ll iw ix iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo hn dt translated">这将规则从正常处理更改为控制规则。这些是玩家做出决定的规则，例如控制角色的输入(左、右、跳)。</p><p id="d520" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个学习游戏引擎输出的例子。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mp jx l"/></div></figure><blockquote class="mq mr ms"><p id="315f" class="ir is jp it b iu iv iw ix iy iz ja jb mt jd je jf mu jh ji jj mv jl jm jn jo hn dt translated">关注Hackernoon和我(<a class="mw mx gr" href="https://medium.com/u/75a616711f4e?source=post_page-----6160d000b1e3--------------------------------" rel="noopener" target="_blank"> Febin John James </a>)了解更多故事。我还在写一本书，以提高对蓝鲸挑战的认识，蓝鲸挑战已经夺去了几个国家许多青少年的生命。它旨在帮助父母了解黑暗网络的威胁，并采取行动确保他们孩子的安全。《T2与蓝鲸战斗》这本书可以在亚马逊上预购。该书将于本月20日发行。</p></blockquote></div></div>    
</body>
</html>