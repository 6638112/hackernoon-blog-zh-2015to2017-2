<html>
<head>
<title>Drawing 2.7 billion Points in 10s</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">10秒钟内抽取27亿个点数</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/drawing-2-7-billion-points-in-10s-ecc8c85ca8fa?source=collection_archive---------14-----------------------#2017-10-31">https://medium.com/hackernoon/drawing-2-7-billion-points-in-10s-ecc8c85ca8fa?source=collection_archive---------14-----------------------#2017-10-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/c6ba4c012a2ad921cf3f5110481a8a1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JBNPVWffSEfzNe93aaLzMQ.png"/></div></div></figure><div class=""/><p id="7da8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我在阅读这篇关于在<a class="ae ka" href="https://hackernoon.com/tagged/macbook" rel="noopener ugc nofollow" target="_blank"> macbook </a>上一分钟可视化27亿个点的博文时，我很好奇这在<a class="ae ka" href="https://hackernoon.com/tagged/julia" rel="noopener ugc nofollow" target="_blank"> Julia </a>上会有多快。</p><p id="86ee" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不仅仅是为了好玩，也是为了把它集成到我的绘图库中(<a class="ae ka" href="https://github.com/SimonDanisch/MakiE.jl" rel="noopener ugc nofollow" target="_blank"> MakiE </a>)。因为我很高兴自己能够如此快速地创建一个非常快速的解决方案，所以我决定分享我的经验！</p><p id="4cd0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，你可以从http://planet.osm.org/gps/<a class="ae ka" href="http://planet.osm.org/gps/" rel="noopener ugc nofollow" target="_blank">下载数据</a></p><h2 id="a5c5" class="kb kc if bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">解析CSV</h2><p id="44a6" class="pw-post-body-paragraph jc jd if je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">我假设有人想要对数据进行大量操作，所以最明智的做法是将55gb的CSV文件转换为22gb的二进制blob文件，这样可以将<a class="ae ka" href="https://en.wikipedia.org/wiki/Memory-mapped_file" rel="noopener ugc nofollow" target="_blank">内存映射到</a>，并且不需要解析！</p><p id="690b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">没有任何现成的工具可以做到这一点，但是有了<a class="ae ka" href="https://github.com/JuliaComputing/TextParse.jl" rel="noopener ugc nofollow" target="_blank"> TextParser </a>的帮助。jl我能够快速完成一个定制解决方案——这也展示了如何很好地扩展现有的Julia库。</p><p id="87eb" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第一个问题是，TextParser需要一个字符串来解析CSV。因为我不能将整个55gb的数据集加载到RAM中，所以我们的第一个技巧是在Julia中创建一个内存映射字符串类型:</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="ce7e" class="kb kc if lg b fv lk ll l lm ln">struct MMapString{T} <br/>    # using Type parameter to not write out the result type of mmap<br/>    # but I also don't want to loose performance<br/>    x::T <br/>end</span><span id="b86e" class="kb kc if lg b fv lo ll l lm ln"># Constructor from a path<br/>MMapString(path::String) = MMapString(Mmap.mmap(open(path), Vector{UInt8}))<br/># we only need to overload the iteration protocol for TextParse to work!<br/>Base.getindex(x::MMapString, i) = Char(x.x[i])<br/>Base.next(x::MMapString, i) = Char(x.x[i]), i + 1<br/>Base.done(x::MMapString, i) = i &gt; length(x.x)<br/>Base.start(x::MMapString, i) = 1<br/>Base.length(x::MMapString) = length(x.x)</span></pre><p id="5167" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是满足大多数库的基本接口所需要的，期望一个字符串类型。现在，我们可以编写一个函数来读取55gb的数据集，逐行解析并将其写入二进制blob。</p><p id="94ac" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">出现的一个问题是，写入IO文件流的函数分配了相当多的空间。<em class="lp"> Base.write </em>为其参数创建一个可变容器(Ref)以安全地将其传递给c。即使是直接采用指针的<em class="lp"> Base.unsafe_write </em>仍然有一个分配128字节的检查。<br/>准备好<em class="lp"> unsafe_unsafe_write </em>，short <em class="lp"> uuwrite </em>。这为我们节省了40秒，并减少了3.5 gb的内存分配(最终速度提高了约1.2倍)！这实际上是一个很好的例子，说明朱莉娅目前是如何失败的，以及人们如何仍能挽回这种表现。<br/>我们直接调用C库，使用几乎被否决的语法(`&amp;`)从堆栈分配参数中获取指针。<br/>在Julia 0.7中，这可能不成问题，我们应该能够使用`<em class="lp"> write </em>`,因为编译器在堆栈分配和消除可变容器方面做得更好了。</p><p id="65ca" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">顺便说一下，我是用显示分配的<strong class="je ig"> @time write(io，1f0) </strong>来解决这个问题的，然后用<strong class="je ig"> @which write(io，1f0) </strong>(或者用<strong class="je ig"> @edit </strong>直接跳到编辑器)来解决函数在Julia中定义的位置以及分配的来源。</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="31e3" class="kb kc if lg b fv lk ll l lm ln">using TextParse<br/>using TextParse: Record, Field, Numeric, tryparsenext</span><span id="2d40" class="kb kc if lg b fv lo ll l lm ln">function uuwrite(io, ptr::T) where T<br/>    Int(ccall(<br/>       :ios_write, <br/>       Csize_t, (Ptr{Void}, Ptr{T}, Csize_t), <br/>       io.ios, &amp;ptr, sizeof(T))<br/>    )<br/>end</span><span id="c2a6" class="kb kc if lg b fv lo ll l lm ln">function save2bin(path, n = typemax(Int))<br/>    str = MMapString(path)<br/>    # Descriptor of 'num,num\n' which is the format in the csv<br/>    rec = Record((<br/>            Field(Numeric(Float32), delim = ','), <br/>            Field(Numeric(Float32), eoldelim = true)<br/>    ))<br/>    # skip the header! Nice is, that Julia's findfirst works with <br/>    # any iterator<br/>    pos = findfirst(str, '\n') + 1 <br/>    io = open(homedir()*"/gpspoints.bin", "w")<br/>    i = 0<br/>    while !done(str, pos) &amp;&amp; i &lt;= n<br/>        # tryparsenext takes roughly 35ns so it's fairly optimal  <br/>        p_or_null, pos = tryparsenext(<br/>            rec, str, pos, length(str)<br/>        )<br/>        isnull(p_or_null) &amp;&amp; continue # continue when parsing fails<br/>        p = get(p_or_null)<br/>        uuwrite(io, p)<br/>        i += 1<br/>    end<br/>    close(io)<br/>    i<br/>end<br/>tic()<br/><a class="ae ka" href="http://twitter.com/time" rel="noopener ugc nofollow" target="_blank">@time</a> save2bin(homedir() * "/Downloads/gps-points.csv");<br/>toc()</span></pre><p id="9044" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这将重写文件，并在190秒内将其保存为二进制文件，对于这样一个简单的实现和只需要做一次的操作来说，这已经不错了。</p><h2 id="e66b" class="kb kc if bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">绘制图像</h2><p id="6f98" class="pw-post-body-paragraph jc jd if je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">现在我们可以将该文件内存映射为一个保存原始gps坐标的<em class="lp">向量{NTuple{2，Float32}} </em>。然后，我们可以直接循环遍历这些点，并在2D数组中累加每个位置。</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="4688" class="kb kc if lg b fv lk ll l lm ln">"""<br/>Transforms from longitude/latitude to pixel on screen, with `dims` refering to <br/>the dimensions of the screen in pixel<br/>"""<br/><a class="ae ka" href="http://twitter.com/inline" rel="noopener ugc nofollow" target="_blank">@inline</a> function gps2pixel(point, dims)<br/>    lon, lat = point[1], point[2]<br/>    x = ((dims[1] / 180.0) * (90.0 + (lon / 10^7)))<br/>    y = ((dims[2] / 360.0) * (180.0 - (lat / 10^7)))<br/>    (x, y)<br/>end</span><span id="7f5a" class="kb kc if lg b fv lo ll l lm ln">function to_image_inner!(img, points, start, stop)<br/>    dims = size(img)<br/>    for i = start:stop<br/>        # don't check bounds when indexing into an array<br/>        <a class="ae ka" href="http://twitter.com/inbounds" rel="noopener ugc nofollow" target="_blank">@inbounds</a> begin <br/>            p0 = gps2pixel(points[i], dims)<br/>            idx = Int.(round.(p0))<br/>            xidx, yidx = dims[1] - idx[1], dims[2] - idx[2]<br/>            if checkbounds(Bool, img, xidx, yidx)<br/>                # we should give each point a radius and then add<br/>                # the coverage to each pixel for a smoother image<br/>                # But this does well enough for this short example:<br/>                img[xidx, yidx] += 0.001f0 # accumulate<br/>            end<br/>        end<br/>    end<br/>end<br/>function to_image!(img, points, range)<br/>    N = length(range)<br/>    # Number of threads Julia has available<br/>    # Use the environment variable JULIA_NUM_THREADS=8 to start<br/>    # Julia with 8 threads<br/>    NT = Threads.nthreads() <br/>    slices = floor(Int, N / NT)<br/>    offset = minimum(range)<br/>    Threads.<a class="ae ka" href="http://twitter.com/threads" rel="noopener ugc nofollow" target="_blank">@threads</a> for i = 1:NT<br/>        # <a class="ae ka" href="http://twitter.com/threads" rel="noopener ugc nofollow" target="_blank">@threads</a> creates a closure, which sometimes <br/>        # confuses type inference leading to slow code.<br/>        # this is why it's a good practice to move the loop body <br/>        # behind a function barrier<br/>        # (<a class="ae ka" href="https://docs.julialang.org/en/latest/manual/performance-tips/#kernal-functions-1" rel="noopener ugc nofollow" target="_blank">https://docs.julialang.org/en/latest/manual/performance-tips/#kernal-functions-1</a>)<br/>        to_image_inner!(<br/>            img, points, <br/>            offset + ((i-1) * slices + 1), offset + (i * slices)<br/>        )<br/>    end<br/>    return img<br/>end</span></pre><p id="51bb" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以用下面的方法使用上面的函数来得到一个简单的灰度图像:</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="0208" class="kb kc if lg b fv lk ll l lm ln">img = zeros(Float32, 600, 960)<br/>io = open(homedir() * "/gpspoints.bin")<br/>points = Mmap.mmap(io, Vector{NTuple{2, Float32}})<br/>tic()<br/>to_image!(img, points, 1:length(points))<br/>toc()<br/>using FileIO, Colors # save it with FileIO as a Gray image<br/>FileIO.save("gps.png", Gray.(clamp.(1f0 .- img, 0, 1)))</span></pre><figure class="lb lc ld le fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/c6ba4c012a2ad921cf3f5110481a8a1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JBNPVWffSEfzNe93aaLzMQ.png"/></div></div></figure><p id="e4ba" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">瞧啊。</p><p id="f8a4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在一台普通的台式电脑上画22gb的点需要10秒钟。</p><p id="8b2a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">需要指出的一点是您可以在示例中看到的伟大的点调用语法:</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="2d02" class="kb kc if lg b fv lk ll l lm ln">Gray.(clamp.(1f0 .- img, 0, 1)))</span></pre><p id="1bb5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这实际上是一个奇妙的机制<a class="ae ka" href="https://julialang.org/blog/2017/01/moredots" rel="noopener ugc nofollow" target="_blank">在融合所有操作的同时对数组中的每个元素应用一个函数</a>。所以上面会变成单for loop <br/> over <em class="lp"> img </em>，箝位，反转，转换成颜色一气呵成！</p><p id="0067" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们也可以使用我新的<a class="ae ka" href="https://github.com/SimonDanisch/MakiE.jl" rel="noopener ugc nofollow" target="_blank">交互绘图库</a>来创建一个很好的进度动画:</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="e555" class="kb kc if lg b fv lk ll l lm ln">using MakiE</span><span id="dcdb" class="kb kc if lg b fv lo ll l lm ln">resolution = (600, 960)<br/>scene = Scene(resolution = reverse(resolution))<br/>img = zeros(Float32, resolution)<br/>imviz = heatmap(img, colornorm = (0, 1))<br/>center!(scene)<br/># slice `points` into multiple batches which we will update<br/>slice = 10^7<br/>range = slice:slice:length(points)<br/>stop = 1<br/>vio = VideoStream(scene, homedir()*"/Desktop/", "gps")<br/>while true<br/>    start = stop<br/>    stop = min(stop + slice, length(points))<br/>    to_image!(img, points, start:stop)<br/>    imviz[:heatmap] = img # update heatmap plot<br/>    recordframe!(vio) # add frame to stream<br/>    stop == length(points) &amp;&amp; break<br/>end<br/>finish(vio, "gif") # finish streaming and export as gif!</span></pre><figure class="lb lc ld le fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/99c88408d3df054a7cc50995d22fd9cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*iO043Ni7KB6ve22Osrpq-Q.gif"/></div></div></figure><p id="5f78" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当然，我们可以应用各种各样的改进，但我很高兴这是第一个结果。也不清楚这个解决方案与最初提到的博客帖子有多大的可比性，因为我还没有在我的电脑上运行过。如果你想在你的机器上试试这个，看看完整的<a class="ae ka" href="https://gist.github.com/SimonDanisch/923de18c470162155416b3019ef9295d" rel="noopener ugc nofollow" target="_blank">代码</a>！</p><figure class="lb lc ld le fq hw"><div class="bz el l di"><div class="lq lr l"/></div></figure></div></div>    
</body>
</html>