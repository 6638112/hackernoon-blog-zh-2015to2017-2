<html>
<head>
<title>Naive Infinite scroll in Reactive Programming using RxJS Observables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用RxJS可观测量的反应式编程中的简单无限滚动</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/naive-infinite-scroll-in-reactive-programming-using-rxjs-observables-4a605d3146e8?source=collection_archive---------1-----------------------#2017-02-15">https://medium.com/hackernoon/naive-infinite-scroll-in-reactive-programming-using-rxjs-observables-4a605d3146e8?source=collection_archive---------1-----------------------#2017-02-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/ac860fc363e86c80fbbbbe5dd73e6cac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C8HismzBKoGWJcRH3E_5Og.png"/></div></div></figure><div class=""/><p id="bf89" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">用RxJS实现无限滚动的简单实验</p><p id="5c97" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">关于Angular实现的博文:<a class="ae ka" rel="noopener" href="/@Sureshkumar_Ash/angular-2-simple-infinite-scroller-directive-with-rxjs-observables-a989b12d4fb1">带有RxJS可观察值的简单无限滚动条指令</a></p><p id="0d4e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">什么是反应式编程？<br/> </strong>简单来说就是用异步数据流编程。Andre Staltz 发表了一篇很棒的文章，介绍了你一直错过的反应式编程，并附有一个egghead.io视频。</p><p id="dbec" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754" rel="noopener ugc nofollow" target="_blank">你错过的反应式编程入门</a></p><p id="6514" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://egghead.io/courses/introduction-to-reactive-programming" rel="noopener ugc nofollow" target="_blank">https://egghead . io/courses/introduction-to-reactive-programming</a></p><p id="366e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">RxJS是什么？</strong></p><p id="7178" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">RxJS或Reactive Extensions是微软开放技术公司用Javascript开发的库，用于<em class="kb">转换、组合</em>和<em class="kb">查询</em>数据流。<a class="ae ka" href="https://github.com/Reactive-Extensions/RxJS" rel="noopener ugc nofollow" target="_blank">https://github.com/Reactive-Extensions/RxJS</a></p><p id="7399" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">本·莱什有一个关于这个<a class="ae ka" href="https://www.youtube.com/watch?v=1vR9lQLfqjo&amp;t=959s" rel="noopener ugc nofollow" target="_blank">与RxJS 5 </a>反应式思维的精彩演讲</p><p id="142e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是Netanel Basal 对可观测量和一些运算符的一些不错的介绍</p><ol class=""><li id="7a2e" class="kc kd if je b jf jg jj jk jn ke jr kf jv kg jz kh ki kj kk dt translated"><a class="ae ka" href="https://netbasal.com/javascript-observables-under-the-hood-2423f760584#.ptzobjg31" rel="noopener ugc nofollow" target="_blank">发动机罩下的可见物</a>。</li><li id="62fc" class="kc kd if je b jf kl jj km jn kn jr ko jv kp jz kh ki kj kk dt translated"><a class="ae ka" href="https://netbasal.com/rxjs-six-operators-that-you-must-know-5ed3b6e238a0#.oqgxqivb2" rel="noopener ugc nofollow" target="_blank">RxJS——你必须知道的六个操作者</a></li></ol><p id="e8e2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将会建造什么？</p><p id="150d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将使用observables构建一个简单的无限滚动器。每当用户将给定的容器滚动到70%时，我们将触发api调用从服务器获取更多数据。对于这个实现，我们将使用<a class="ae ka" href="https://github.com/cheeaun/node-hnapi" rel="noopener ugc nofollow" target="_blank"> HackerNews非官方api </a>来获取最新消息。</p><p id="a3a2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是我们将在RxJS中使用的运算符</p><ol class=""><li id="504f" class="kc kd if je b jf jg jj jk jn ke jr kf jv kg jz kh ki kj kk dt translated"><code class="eh kq kr ks kt b"><a class="ae ka" href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-map" rel="noopener ugc nofollow" target="_blank">map</a></code>:类似于数组中的映射，映射到传入的数据流上。</li><li id="e1ad" class="kc kd if je b jf kl jj km jn kn jr ko jv kp jz kh ki kj kk dt translated"><code class="eh kq kr ks kt b"><a class="ae ka" href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-filter" rel="noopener ugc nofollow" target="_blank">filter</a></code>:类似于数组中的filter，过滤传入的数据流。</li><li id="e194" class="kc kd if je b jf kl jj km jn kn jr ko jv kp jz kh ki kj kk dt translated"><code class="eh kq kr ks kt b"><a class="ae ka" href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-pairwise" rel="noopener ugc nofollow" target="_blank">pairwise</a></code>:返回当前发出数据的数组，也返回以前发出的数据。</li><li id="972e" class="kc kd if je b jf kl jj km jn kn jr ko jv kp jz kh ki kj kk dt translated"><code class="eh kq kr ks kt b"><a class="ae ka" href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-startWith" rel="noopener ugc nofollow" target="_blank">startWith</a></code>:在从源可观察对象发出值之前，返回一个可观察对象发出提供的值</li><li id="5ab9" class="kc kd if je b jf kl jj km jn kn jr ko jv kp jz kh ki kj kk dt translated"><code class="eh kq kr ks kt b"><a class="ae ka" href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-exhaustMap" rel="noopener ugc nofollow" target="_blank">exhaustMap</a></code>:等待发出值，直到传入的内部可观察对象完成</li></ol><p id="9567" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">链接到jsbin.com的输出:<a class="ae ka" href="https://output.jsbin.com/punibux" rel="noopener ugc nofollow" target="_blank">https://output.jsbin.com/punibux</a></p><p id="d748" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig"> #Phase1 </strong> —设置基本的html和样式</p><p id="7251" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">导入RxJS库，我们将使用<code class="eh kq kr ks kt b">infinite-scroller</code>作为滚动容器，并向其中添加新闻。</p><figure class="ku kv kw kx fq hw"><div class="bz el l di"><div class="ky kz l"/></div></figure><figure class="ku kv kw kx fq hw"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="d890" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig"> #Phase2 </strong> —为数据处理、渲染和计算设置助手功能</p><figure class="ku kv kw kx fq hw"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="1eb6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">前三个功能很简单，</p><ol class=""><li id="2d21" class="kc kd if je b jf jg jj jk jn ke jr kf jv kg jz kh ki kj kk dt translated"><code class="eh kq kr ks kt b">getQuotesAPI</code> —返回带有当前页码的api url作为查询参数</li><li id="968c" class="kc kd if je b jf kl jj km jn kn jr ko jv kp jz kh ki kj kk dt translated"><code class="eh kq kr ks kt b">processData</code> —处理从使用<a class="ae ka" href="https://developer.mozilla.org/en/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank">获取api </a>执行的API返回的数据，并增加当前页面。</li><li id="d97c" class="kc kd if je b jf kl jj km jn kn jr ko jv kp jz kh ki kj kk dt translated"><code class="eh kq kr ks kt b">renderNews</code> —获取每个新闻条目并呈现给视图。</li></ol><p id="d2fb" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来的两个函数用于滚动计算</p><p id="a7be" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">4.<code class="eh kq kr ks kt b">isUserScrollingDown</code> —确定用户是否向下滚动。</p><p id="43cc" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">5.<code class="eh kq kr ks kt b">isScrollExpectedPercent</code> —确定用户是否已滚动到传入百分比以获取更多数据。</p><p id="6bb9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig"> #Phase3 </strong> —设置可观察流</p><figure class="ku kv kw kx fq hw"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="c509" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了捕获容器中的滚动事件，我们需要从滚动事件中创建一个可观察对象。这可以通过使用<code class="eh kq kr ks kt b">Rx.Observable.fromEvent</code> - <a class="ae ka" href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-fromEvent" rel="noopener ugc nofollow" target="_blank">单据</a>来实现。当引用一个可观察的流时，将<code class="eh kq kr ks kt b">$</code>附加到变量是一个惯例。</p><p id="a0f4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig"> #Phase4 </strong> —处理滚动事件和调用api的流逻辑</p><figure class="ku kv kw kx fq hw"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="2c2e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将接受由<code class="eh kq kr ks kt b">scrollEvent$</code>和<code class="eh kq kr ks kt b">map</code>发出的滚动事件，只接受我们的无限滚动逻辑所需的值。我们只需要来自滚动元素的三个属性— <code class="eh kq kr ks kt b"><a class="ae ka" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight" rel="noopener ugc nofollow" target="_blank">scrollHeight</a></code>、<code class="eh kq kr ks kt b"><a class="ae ka" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTop" rel="noopener ugc nofollow" target="_blank">scrollTop</a></code>和<code class="eh kq kr ks kt b"><a class="ae ka" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/clientHeight" rel="noopener ugc nofollow" target="_blank">clientHeight</a></code>。</p><p id="95da" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将映射的数据传递给<code class="eh kq kr ks kt b">pairwise</code>操作符，它将当前和以前的值放在一个数组中，如下所示。</p><figure class="ku kv kw kx fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff la"><img src="../Images/a0b8e85edacb9f8c35f40db587f05d0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9xRY_Pk6XLDF8_j7lDbsVA.png"/></div></div></figure><p id="ba4d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们可以将这一对位置传递给<code class="eh kq kr ks kt b">filter</code>它们根据我们的条件进行过滤</p><ol class=""><li id="7208" class="kc kd if je b jf jg jj jk jn ke jr kf jv kg jz kh ki kj kk dt translated">用户是否向下滚动</li><li id="434a" class="kc kd if je b jf kl jj km jn kn jr ko jv kp jz kh ki kj kk dt translated">用户滚动是否达到了容器的70%</li></ol><p id="ed13" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kq kr ks kt b">requestOnScroll$</code> —当<code class="eh kq kr ks kt b">userScrollDown$</code>通过过滤条件时调用。我们从一个空数组的初始值开始。</p><figure class="ku kv kw kx fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lb"><img src="../Images/318ebf17122e4abdc939e917be158da6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FDisiNv9_jBL-vCdqlEkag.png"/></div></div></figure><p id="942a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将使用<code class="eh kq kr ks kt b"><a class="ae ka" href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-fromPromise" rel="noopener ugc nofollow" target="_blank">Rx.Observable.fromPromise</a></code>从承诺中创建一个可观察值。<code class="eh kq kr ks kt b">fetch</code>进行http调用并返回一个承诺。<code class="eh kq kr ks kt b">exhaustMap</code>将等待获取完成，等待内部可观察对象从API发出数据。</p><p id="8cd2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">可观察的东西是懒惰的——意味着它们不做任何事情，直到你订阅它们。我们将订阅<code class="eh kq kr ks kt b">requestOnScroll$</code>并将<code class="eh kq kr ks kt b">processData</code>传递给subscribe方法。当<code class="eh kq kr ks kt b">exhaustMap</code>从api发出数据时，它将被传递给<code class="eh kq kr ks kt b">processData</code>，T3将调用<code class="eh kq kr ks kt b">renderNews</code>呈现到视图上。</p><p id="0104" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是无限卷轴的gif图片，请看右边的滚动条。</p><figure class="ku kv kw kx fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lc"><img src="../Images/c8574949c1f340a36b895f6576ade169.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*C76zWaLe9sfs282S5N0CcQ.gif"/></div></div></figure><blockquote class="ld"><p id="fd77" class="le lf if bd lg lh li lj lk ll lm jz ek translated">在我的下一篇文章中，我将尝试通过创建一个无限滚动指令在Angular 2中实现它。</p></blockquote><p id="4873" class="pw-post-body-paragraph jc jd if je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">更新:这里是我关于简单无限滚动条指令的链接</p></div></div>    
</body>
</html>