<html>
<head>
<title>Enhanced Futures for Groovy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Groovy的增强未来</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/enhanced-futures-for-groovy-b8b8956543fa?source=collection_archive---------4-----------------------#2017-08-12">https://medium.com/hackernoon/enhanced-futures-for-groovy-b8b8956543fa?source=collection_archive---------4-----------------------#2017-08-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/b944880d9ee33a4bf27eed90fa957ae2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hHDSw4MIgMqU-7sSg077LA.jpeg"/></div></div></figure><p id="68b9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Scala中工作一段时间后，从函数式编程的角度来看，一些常见的问题看起来更容易了，尤其是在并行系统中工作时。</p><p id="87c3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我今天不得不用Groovy写了一些多线程代码。我不是一个很棒的专家，但远非如此。然而，不管是哪种语言，编写并发代码都不应该那么难，对吗？</p><p id="7feb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正在讨论的问题如下。我需要运行一些代码，A，当A完成时，我需要运行一些其他代码B和c。这些链可以像我需要的那样复杂。</p><p id="0c36" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我查看了Groovy并发工具集。我可以创造未来。不错！这应该很容易。</p><p id="1fcd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">思考我想在Scala中做的事情。</p><figure class="ka kb kc kd fq iv"><div class="bz el l di"><div class="ke kf l"/></div></figure><p id="0185" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是链接异步计算的一个非常好的方法。</p><p id="a6cc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，如果我有另一个计算链，比如说<code class="eh kg kh ki kj b">anotherFuture</code></p><figure class="ka kb kc kd fq iv"><div class="bz el l di"><div class="ke kf l"/></div></figure><p id="60c0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以使用Scala <strong class="je hv"> <em class="kk">对</em> </strong>进行同步。</p><figure class="ka kb kc kd fq iv"><div class="bz el l di"><div class="ke kf l"/></div></figure><p id="d67e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这里我们可以用<strong class="je hv"> <em class="kk">代替</em> </strong>，因为未来是一个单子，或者说是一种单子，至少它在大多数时候表现得像一个单子。</p><p id="5411" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">回到我的Groovy代码，我发现那里的未来和Scala的几乎没有共同之处。</p><p id="dbf8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Groovy中，要运行异步操作，我们需要这样的东西。</p><figure class="ka kb kc kd fq iv"><div class="bz el l di"><div class="ke kf l"/></div></figure><p id="d9dc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了从<code class="eh kg kh ki kj b">future</code>中得到结果，我们必须在这里做<code class="eh kg kh ki kj b">future.get()</code><code class="eh kg kh ki kj b">.get()</code>将以Scala相同的方式阻塞。问题是我找不到一种方法来定义如何处理<code class="eh kg kh ki kj b">future</code>的结果而不被阻塞。</p><p id="9440" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当然，我可以通过do向池提交多个任务。</p><figure class="ka kb kc kd fq iv"><div class="bz el l di"><div class="ke kf l"/></div></figure><p id="d876" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但这不是我需要的。我必须能够链接操作，并将一个任务的结果传递给下一个异步任务。</p><p id="ade8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">好吧，我自己完成了。</p><p id="408d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将把我的新未来叫做<code class="eh kg kh ki kj b">Continuation</code>，这只是我取的一个名字，没什么特别的。它将从Future继承，所以我们也可以将它发送到一个执行池，我们最后将添加一个单子映射函数或方法，这是它们在Groovy中的调用方式。</p><figure class="ka kb kc kd fq iv"><div class="bz el l di"><div class="ke kf l"/></div></figure><p id="9091" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了创造一个延续，我们需要传递它将使用的未来。</p><p id="7379" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Continuation实现了future的相同功能，但使用的是潜在的Future。</p><p id="0e4b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最重要的部分是延续增加了一个新功能，<code class="eh kg kh ki kj b">map</code>。函数<code class="eh kg kh ki kj b">map</code>接收一个<code class="eh kg kh ki kj b">Closure&lt;B&gt;</code>和<code class="eh kg kh ki kj b">ExecutorService</code>作为执行池，并通过创建一个新的Future返回一个新的<code class="eh kg kh ki kj b">Continuation&lt;B&gt;</code>，该Future从async获取值并传递给<code class="eh kg kh ki kj b">Closure</code>。<em class="kk">注意，这是一个非阻塞操作。</em></p></div><div class="ab cl kl km hc kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hn ho hp hq hr"><p id="83ef" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">回到最初的问题。</p><figure class="ka kb kc kd fq iv"><div class="bz el l di"><div class="ke kf l"/></div></figure><p id="a237" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们现在可以用Groovy来做。</p><figure class="ka kb kc kd fq iv"><div class="bz el l di"><div class="ke kf l"/></div></figure><p id="88e8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这里，<code class="eh kg kh ki kj b">y</code>是传递给下一个<code class="eh kg kh ki kj b">.map</code>的<code class="eh kg kh ki kj b">someLogicB(x)</code>的结果。</p><p id="8632" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，我们将<code class="eh kg kh ki kj b">pool</code>传递给每个map，但是记住Scala Futures需要一个隐式传递的ExecutionContext。</p></div><div class="ab cl kl km hc kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hn ho hp hq hr"><h2 id="99de" class="ks kt hu bd ku kv kw kx ky kz la lb lc jn ld le lf jr lg lh li jv lj lk ll lm dt translated">结论</h2><p id="b29c" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">Scala并发性很棒，这不是秘密。然而，我们不能被自己选择的语言拒之门外(<em class="kk"> Scala是我的</em>)。有时候我们需要用手头的工具来解决问题。如果您没有或没有找到所需的工具，那么就自己去构建它。</p><p id="6f8b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不要害怕<code class="eh kg kh ki kj b">Monad</code>。单子是一种数学结构，在编程中有着广泛的用途，尤其是在函数式编程中。单子是链接操作的一种非常有趣的方式，正如我们在<code class="eh kg kh ki kj b">map</code>中看到的。我们的<code class="eh kg kh ki kj b">Continuation </code>不是一个<strong class="je hv"> <em class="kk">完整的</em> </strong>单子，而是<code class="eh kg kh ki kj b">map</code>背后的想法是从<em class="kk">那里来的</em>。</p><p id="58ca" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">记得先写你的测试。</p><figure class="ka kb kc kd fq iv"><div class="bz el l di"><div class="ke kf l"/></div></figure></div></div>    
</body>
</html>