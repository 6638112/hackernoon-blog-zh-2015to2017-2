<html>
<head>
<title>You Don’t Need an ORM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你不需要ORM</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/you-dont-need-an-orm-7ef83bd1b37d?source=collection_archive---------10-----------------------#2017-09-10">https://medium.com/hackernoon/you-dont-need-an-orm-7ef83bd1b37d?source=collection_archive---------10-----------------------#2017-09-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="a0dd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">关于ORM为什么是反模式已经说了很多。核心原因在这里描述<a class="ae jp" href="http://www.yegor256.com/2014/12/01/orm-offensive-anti-pattern.html" rel="noopener ugc nofollow" target="_blank">。要点是数据存储和检索的方式是任何对象的固有属性。但ORM似乎是“一等公民”:我们在需要取一些数据的时候显式调用它的方法，ORM把它框成一个对象；当我们需要持久化一个对象时，我们调用ORM的功能。在这两种情况下，ORM对我们的对象进行操作，将它们视为数据包。真的很冒犯。所以我宁愿反过来:我希望我的对象调用ORM，而不是相反。</a></p><h2 id="d48a" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">那么，什么是对象呢？</h2><p id="c35f" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">毕竟，什么是对象？它代表了现实生活中的一些事物，来自我们无处不在的语言。它的数据存储方式只是一个实现细节。我希望它被封装在我的对象边界内。谁说所有对象的数据都必须存储为对象属性？谁说那个对象包含任何数据？是即时计算的吗？它存储在内存中吗？它存储在磁盘上吗？是否存储在云端？没关系。对象不是数据包。就像<a class="ae jp" rel="noopener" href="/@wrong.about/what-characteristics-my-services-should-possess-ca22294bbea6">我的微服务</a>一样，它暴露的是行为而不是数据。这个原理被称为<a class="ae jp" href="https://martinfowler.com/bliki/UniformAccessPrinciple.html" rel="noopener ugc nofollow" target="_blank">统一访问原理</a>，它是封装——基本OOP概念的一种体现。</p><h2 id="4b9d" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">持久对象状态</h2><p id="352f" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">所以我的持久化对象封装了两件事:第一件由对象用来访问存储，第二件由对象用来查找或保存数据。这里举的例子<a class="ae jp" href="https://github.com/aintshy/hub/blob/master/src/main/java/com/aintshy/pgsql/PgHuman.java" rel="noopener ugc nofollow" target="_blank">是</a>:</p><pre class="kq kr ks kt fq ku kv kw kx aw ky dt"><span id="8148" class="jq jr hu kv b fv kz la l lb lc"><strong class="kv hv">final class </strong>PgHuman <strong class="kv hv">implements </strong>Human<br/>{<br/>    <em class="ld">/**<br/>     * Data source.<br/>     */<br/>    </em><strong class="kv hv">private final </strong>transient PgSource src;<br/><br/>    <em class="ld">/**<br/>     * Number of it.<br/>     */<br/>    </em><strong class="kv hv">private final </strong>transient long number;<br/><br/>    PgHuman(<strong class="kv hv">final </strong>PgSource source, <strong class="kv hv">final </strong>long num)<br/>    {<br/>        this.src = source;<br/>        this.number = num;<br/>    }<br/>}</span></pre><p id="44bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是在实施这个概念的过程中，有一件事让我担心。再次考虑<a class="ae jp" href="https://github.com/aintshy/hub/blob/master/src/main/java/com/aintshy/pgsql/PgHuman.java" rel="noopener ugc nofollow" target="_blank"> PgHuman </a>类。里面肯定既有数据库查询逻辑，也有业务逻辑。看下一个()方法。它检索带有未读消息的对话，如果没有，则开始与没有任何消息的随机问题相关的新的对话，并且该对话不是由当前用户询问的。我觉得把这些责任分开会很棒。我完全理解数据库切换很少发生，但尽管如此，它对本地集成测试还是很有帮助的，因为数据只存储在内存中。</p><h2 id="e1f5" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">更好的实施</h2><p id="6e3b" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">那么，将数据库逻辑分解出来并隐藏在接口后面的明显步骤是什么呢？考虑一个基于<a class="ae jp" href="http://gorodinski.com/blog/2012/04/14/services-in-domain-driven-design-ddd/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>的例子。<br/>下面是一个实现:</p><pre class="kq kr ks kt fq ku kv kw kx aw ky dt"><span id="e5e0" class="jq jr hu kv b fv kz la l lb lc"><strong class="kv hv">class </strong>PurchaseOrder <strong class="kv hv">implements </strong>IPurchaseOrder<br/>{<br/>    <em class="ld">/**<br/>     * </em><strong class="kv hv"><em class="ld">@var </em></strong><em class="ld">OrderStorage<br/>     */<br/>    </em><strong class="kv hv">private $storage</strong>;<br/><br/>    <em class="ld">/**<br/>     * </em><strong class="kv hv"><em class="ld">@var </em></strong><em class="ld">OrderId<br/>     */<br/>    </em><strong class="kv hv">private $id</strong>;<br/><br/>    <strong class="kv hv">public function </strong>__construct(OrderStorage $storage, OrderId $id)<br/>    {<br/>        $this-&gt;<strong class="kv hv">storage </strong>= $storage;<br/>        $this-&gt;<strong class="kv hv">id </strong>= $id;<br/>    }<br/><br/>    <strong class="kv hv">public function </strong>newInvoice(<br/>        IInvoiceNumber $invoiceNumber,<br/>        IVendorInvoiceNumber $vendorInvoiceNumber,<br/>        DateTime $dateTime,<br/>        InvoiceAmount $amount<br/>    )<br/>    {<br/>        $this-&gt;<strong class="kv hv">storage</strong>-&gt;save($invoiceNumber, $vendorInvoiceNumber, $dateTime, $amount);<br/><br/>        <strong class="kv hv">return new </strong>Invoice($this-&gt;<strong class="kv hv">storage</strong>, $invoiceNumber);<br/>    }<br/>}</span></pre><p id="63ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，所有数据库逻辑都放在存储的“save()”方法中。可能是事务处理、相关表中的一些插入、显式锁等。好的一面是域类PurchaseOrder根本没有耦合到特定于数据库的代码。<br/>如果我们使用任何带有虚拟数据库抽象库的关系数据库，我们的存储代码可能如下所示:</p><pre class="kq kr ks kt fq ku kv kw kx aw ky dt"><span id="4a23" class="jq jr hu kv b fv kz la l lb lc"><strong class="kv hv">class </strong>SQLOrderStorage <strong class="kv hv">implements </strong>OrderStorage<br/>{<br/>    <strong class="kv hv">private $connection</strong>;<br/><br/>    <strong class="kv hv">public function </strong>__construct(SQLConnection $connection)<br/>    {<br/>        $this-&gt;<strong class="kv hv">connection </strong>= $connection;<br/>    }<br/><br/>    <strong class="kv hv">public function </strong>save(<br/>        IInvoiceNumber $invoiceNumber,<br/>        IVendorInvoiceNumber $vendorInvoiceNumber,<br/>        DateTime $dateTime,<br/>        InvoiceAmount $amount<br/>    )<br/>    {<br/>        <strong class="kv hv">new </strong>InsertQuery($this-&gt;<strong class="kv hv">connection</strong>)<br/>            -&gt;into(<strong class="kv hv">'invoice'</strong>)<br/>            -&gt;set(<strong class="kv hv">'invoice_number'</strong>, $invoiceNumber-&gt;value())<br/>            -&gt;set(<strong class="kv hv">'vendor_invoice_number'</strong>, $vendorInvoiceNumber)<br/>            -&gt;set(<strong class="kv hv">'datetime'</strong>, $dateTime)<br/>            -&gt;set(<strong class="kv hv">'amount'</strong>, $amount-&gt;amount())<br/>            -&gt;set(<strong class="kv hv">'currency'</strong>, $amount-&gt;currency())<br/>        ;<br/>    }<br/>}</span></pre><p id="76c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">需要Memcached缓存吗？没问题，让我们用一个装饰者:</p><pre class="kq kr ks kt fq ku kv kw kx aw ky dt"><span id="e30e" class="jq jr hu kv b fv kz la l lb lc"><strong class="kv hv">class </strong>MemcachedOrderStorage <strong class="kv hv">implements </strong>OrderStorage<br/>{<br/>    <strong class="kv hv">private $storage</strong>;<br/>    <strong class="kv hv">private $memcachedClient</strong>;<br/><br/>    <strong class="kv hv">public function </strong>__construct(OrderStorage $storage, MemcachedClient $memcachedClient)<br/>    {<br/>        $this-&gt;<strong class="kv hv">storage </strong>= $storage;<br/>        $this-&gt;<strong class="kv hv">memcachedClient </strong>= $memcachedClient;<br/>    }<br/><br/>    <strong class="kv hv">public function </strong>save(<br/>        IInvoiceNumber $invoiceNumber,<br/>        IVendorInvoiceNumber $vendorInvoiceNumber,<br/>        DateTime $dateTime,<br/>        InvoiceAmount $amount<br/>    )<br/>    {<br/>        $this-&gt;<strong class="kv hv">storage</strong>-&gt;save($invoiceNumber, $vendorInvoiceNumber, $dateTime, $amount);<br/><br/>        $this-&gt;<strong class="kv hv">memcachedClient</strong>-&gt;set(<br/>            $invoiceNumber-&gt;value(),<br/>            <em class="ld">base64_encode</em>(<br/>                json_encode(<br/>                    [<br/>                        <strong class="kv hv">'invoice_number' </strong>=&gt; $invoiceNumber-&gt;value(),<br/>                        <strong class="kv hv">'vendor_invoice_number' </strong>=&gt; $vendorInvoiceNumber-&gt;value(),<br/>                        <strong class="kv hv">'datetime' </strong>=&gt; $dateTime-&gt;format(<strong class="kv hv">'c'</strong>),<br/>                        <strong class="kv hv">'amount' </strong>=&gt; $amount-&gt;amount(),<br/>                        <strong class="kv hv">'currency' </strong>=&gt; $amount-&gt;currency(),<br/>                    ]<br/>                )<br/>            )<br/>        );<br/>        ;<br/>    }<br/>}</span></pre><p id="7573" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">需要内存缓存？让我们再次使用一个装饰器:</p><pre class="kq kr ks kt fq ku kv kw kx aw ky dt"><span id="f7ec" class="jq jr hu kv b fv kz la l lb lc"><strong class="kv hv">class </strong>LocalOrderStorage <strong class="kv hv">implements </strong>OrderStorage<br/>{<br/>    <strong class="kv hv">private $storage</strong>;<br/>    <strong class="kv hv">private $localStorage</strong>;<br/><br/>    <strong class="kv hv">public function </strong>__construct(OrderStorage $storage)<br/>    {<br/>        $this-&gt;<strong class="kv hv">storage </strong>= $storage;<br/>        $this-&gt;<strong class="kv hv">localStorage </strong>= [];<br/>    }<br/><br/>    <strong class="kv hv">public function </strong>save(<br/>        IInvoiceNumber $invoiceNumber,<br/>        IVendorInvoiceNumber $vendorInvoiceNumber,<br/>        DateTime $dateTime,<br/>        InvoiceAmount $amount<br/>    )<br/>    {<br/>        $this-&gt;<strong class="kv hv">storage</strong>-&gt;save($invoiceNumber, $vendorInvoiceNumber, $dateTime, $amount);<br/><br/>        $this-&gt;<strong class="kv hv">localStorage</strong>[$invoiceNumber-&gt;value()] =<br/>            [<br/>                <strong class="kv hv">'invoice_number' </strong>=&gt; $invoiceNumber-&gt;value(),<br/>                <strong class="kv hv">'vendor_invoice_number' </strong>=&gt; $vendorInvoiceNumber-&gt;value(),<br/>                <strong class="kv hv">'datetime' </strong>=&gt; $dateTime-&gt;format(<strong class="kv hv">'c'</strong>),<br/>                <strong class="kv hv">'amount' </strong>=&gt; $amount-&gt;amount(),<br/>                <strong class="kv hv">'currency' </strong>=&gt; $amount-&gt;currency(),<br/>            ]<br/>        ;<br/>    }<br/>}</span></pre><h2 id="f600" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">事务管理</h2><p id="e11b" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">您也不应该担心事务管理。如果你对<a class="ae jp" href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215" rel="noopener ugc nofollow" target="_blank"/>感兴趣，你会意识到<a class="ae jp" href="https://martinfowler.com/bliki/DDD_Aggregate.html" rel="noopener ugc nofollow" target="_blank">聚合根</a>的概念。简而言之，它是您的领域模型中一致性边界的量子。在任何时候都必须保持不变的东西。您可能知道在改变聚合时的经验法则:每个事务一个聚合，下一个聚合通常由当前事件发布的事件触发。<a class="ae jp" rel="noopener" href="/@wrong.about/example-of-service-boundaries-identification-e9077c513560">这里是这种方法的一个例子</a>。所以没有跨越几个聚合根的事务。在我的示例中，“PurchaseOrder”类是一个聚合根，所有事务逻辑都可以驻留在“SQLOrderStorage”中。</p><h2 id="6f87" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">多语种物体</h2><p id="771a" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">这个概念不仅包括使用SQL语言的对象、使用NoSQL语言的对象或任何其他使用特定存储语言的对象，还包括其数据不仅保存在内存中的任何对象。这包括一些远程json/xml/etc资源，或者一个本地文件。例如，如果我可以通过调用某个API找到我的财务事务，事务类可能如下所示:</p><pre class="kq kr ks kt fq ku kv kw kx aw ky dt"><span id="4a0a" class="jq jr hu kv b fv kz la l lb lc"><strong class="kv hv">class </strong>FinancialTransaction<br/>{<br/>    <strong class="kv hv">private $dataSource</strong>;<br/>    <strong class="kv hv">private $id</strong>;<br/><br/>    <strong class="kv hv">public function </strong>__construct(TransactionDataSource $dataSource, TransactionId $id)<br/>    {<br/>        $this-&gt;<strong class="kv hv">dataSource </strong>= $dataSource;<br/>        $this-&gt;<strong class="kv hv">id </strong>= $id;<br/>    }<br/><br/>    <strong class="kv hv">public function </strong>isSuccessful()<br/>    {<br/>        <strong class="kv hv">return </strong>$this-&gt;<strong class="kv hv">dataSource</strong>-&gt;isSuccessful();<br/>    }<br/>}</span></pre><p id="9aac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">和数据源实现可以如下所示:</p><pre class="kq kr ks kt fq ku kv kw kx aw ky dt"><span id="2661" class="jq jr hu kv b fv kz la l lb lc"><strong class="kv hv">interface </strong>TransactionDataSource<br/>{<br/>    <strong class="kv hv">public function </strong>isSuccessful(TransactionId $transactionId);<br/>}<br/><br/><strong class="kv hv">class </strong>HttpTransactionDataSource <strong class="kv hv">implements </strong>TransactionDataSource<br/>{<br/>    <strong class="kv hv">private $connection</strong>;<br/><br/>    <strong class="kv hv">public function </strong>__construct(Connection $connection)<br/>    {<br/>        $this-&gt;<strong class="kv hv">connection </strong>= $connection;<br/>    }<br/><br/>    <strong class="kv hv">public function </strong>isSuccessful(TransactionId $transactionId)<br/>    {<br/>        (<strong class="kv hv">new </strong>Response(<br/>            <strong class="kv hv">new </strong>PostHttpRequest(<br/>                $this-&gt;<strong class="kv hv">connection</strong>-&gt;uri(),<br/>                <strong class="kv hv">new </strong>HttpVersion(<strong class="kv hv">'HTTP/1.1'</strong>),<br/>                [<br/>                    $this-&gt;<strong class="kv hv">connection</strong>-&gt;credentials(),<br/>                    <strong class="kv hv">new </strong>Header(<strong class="kv hv">'Content-Type: application/xml'</strong>),<br/>                    <strong class="kv hv">new </strong>Header(<strong class="kv hv">'SOAPAction: ""'</strong>),<br/>                ],<br/>                <strong class="kv hv">new </strong>RequestBody(<br/>                    (<strong class="kv hv">new </strong>SimpleXMLElement(<strong class="kv hv">"&lt;data&gt;&lt;/data&gt;"</strong>))<br/>                        -&gt;addChild(<strong class="kv hv">'transaction_id'</strong>, $transactionId-&gt;value())<br/>                ),<br/>                $this-&gt;<strong class="kv hv">connection</strong>-&gt;transport()<br/>            )<br/>        ))<br/>            -&gt;value()<br/>        ;<br/>    }<br/>}</span></pre><h2 id="60b2" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">包装它</h2><p id="f4e5" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">嗯，这种方式无非就是倒过来的ORM/HTTP call/等。但是概念上的差异是巨大的。<br/>主要的一点是，这种方法中的动力来自于“对象”的概念。它是一个声明性的概念，代表现实生活中的实体。知道做什么和如何做的对象。不需要任何指令的对象。不需要以任何方式编排或控制的对象。最后，拥有所有资源或<a class="ae jp" rel="noopener" href="/@wrong.about/you-dont-need-a-domain-service-class-in-ddd-9ecd3140782">服务</a>的对象需要完成它的工作。</p><p id="e36e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">用人类的比喻来说，对象是成年人，而不是孩子。</p></div></div>    
</body>
</html>