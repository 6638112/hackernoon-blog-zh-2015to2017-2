<html>
<head>
<title>Javascript inheritance behind the scene __proto__, [[prototype]] and prototype</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">幕后Javascript继承__proto__，[[prototype]]和prototype</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/understand-nodejs-javascript-object-inheritance-proto-prototype-class-9bd951700b29?source=collection_archive---------0-----------------------#2017-01-14">https://medium.com/hackernoon/understand-nodejs-javascript-object-inheritance-proto-prototype-class-9bd951700b29?source=collection_archive---------0-----------------------#2017-01-14</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/654b83819c4ce4bb32e94cc1508c6ae2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nDBFaMpflmSsIKfMLxWIvQ.jpeg"/></div></div></figure><blockquote class="jc"><p id="46b4" class="jd je hu bd jf jg jh ji jj jk jl jm ek translated">原型是构造函数上的一个属性，它设置将成为构造对象上的__proto__属性的内容。</p></blockquote><p id="5399" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj jm hn dt translated">理解Javascript中的继承的关键是理解父母鸡如何进行Javascript下蛋过程；Javascript继承发生在原型继承中，但是传统的类在技术上和概念上是不存在的。</p><p id="6854" class="pw-post-body-paragraph jn jo hu jp b jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ko ki kj jm hn dt translated">这是一篇关于澄清Javascript中<strong class="jp hv"> <em class="kp">原型</em> </strong>、<strong class="jp hv"> <em class="kp"> __proto__ </em> </strong>和<strong class="jp hv"> <em class="kp">继承</em> </strong>混乱的注释。这里的大部分内容都是从<a class="ae kq" href="http://dmitrysoshnikov.com/" rel="noopener ugc nofollow" target="_blank">德米特里·索什尼科夫</a>和<a class="ae kq" href="https://www.blogger.com/profile/01255331129588005020" rel="noopener ugc nofollow" target="_blank">肯尼斯·金·卢姆</a>:<a class="ae kq" href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core/" rel="noopener ugc nofollow" target="_blank">http://dmitrysoshnikov.com/ecmascript/javascript-the-core/</a><br/><a class="ae kq" href="https://kenneth-kin-lum.blogspot.tw/2012/10/javascripts-pseudo-classical.html?showComment=1484288337339#c1393503225616140233" rel="noopener ugc nofollow" target="_blank">https://肯尼斯·金·卢姆. blogspot . tw/2012/10/JavaScript s-pseudo-classic . html？show comment = 1484288337339 # c 1393503225616140233</a></p></div><div class="ab cl kr ks hc kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hn ho hp hq hr"><h1 id="5f61" class="ky kz hu bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv dt translated">例0:<strong class="ak"><em class="lw">[[原型]] </em> </strong> vs __proto__ vs原型</h1><p id="5264" class="pw-post-body-paragraph jn jo hu jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj jm hn dt translated"><a class="ae kq" href="http://speakingjs.com/" rel="noopener ugc nofollow" target="_blank">speakingjs.com</a>和<a class="ae kq" href="http://www.javascripttutorial.net/javascript-prototype/" rel="noopener ugc nofollow" target="_blank">javascripttutorial.com</a>是解释[[prototype]]、__proto__和prototype从基础到应用的关系的最佳资源，而且非常重要的是他们将这种关系形象化。</p><blockquote class="mc md me"><p id="ad89" class="jn jo kp jp b jq kk js jt ju kl jw jx mf km ka kb mg kn ke kf mh ko ki kj jm hn dt translated">每个对象都可以有另一个对象作为其原型。那么前一个对象将继承其原型的所有属性。一个对象通过内部属性<code class="eh mi mj mk ml b"><em class="hu">[[Prototype]]</em></code>指定它的原型。由<code class="eh mi mj mk ml b"><em class="hu">[[Prototype]]</em></code>属性连接的对象链被称为<em class="hu">原型链:</em></p></blockquote><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div class="fe ff mm"><img src="../Images/f514afd0c07a770ce1c7ee99ed415854.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/0*JoyuFSITeSY9iiqa.png"/></div><figcaption class="mr ms fg fe ff mt mu bd b be z ek"><a class="ae kq" href="http://speakingjs.com/es5/ch17.html" rel="noopener ugc nofollow" target="_blank">http://speakingjs.com/es5/ch17.html</a></figcaption></figure><blockquote class="mc md me"><p id="8979" class="jn jo kp jp b jq kk js jt ju kl jw jx mf km ka kb mg kn ke kf mh ko ki kj jm hn dt translated">为了了解基于原型(或<em class="hu">原型</em>)的继承是如何工作的，让我们看一个例子(用发明的语法来指定<code class="eh mi mj mk ml b">[[Prototype]]</code>属性):</p></blockquote><pre class="mn mo mp mq fq mv ml mw mx aw my dt"><span id="8982" class="mz kz hu ml b fv na nb l nc nd"><strong class="ml hv">var</strong> <!-- -->proto<!-- --> <!-- -->=<!-- --> <!-- -->{<br/>    <!-- -->describe:<!-- --> <strong class="ml hv">function</strong> <!-- -->()<!-- --> <!-- -->{<br/>        <strong class="ml hv">return</strong> <!-- -->'name: '+<strong class="ml hv">this</strong>.name;<br/>    <!-- -->}<br/>};<br/><strong class="ml hv">var</strong> <!-- -->obj<!-- --> <!-- -->=<!-- --> <!-- -->{<br/>    <!-- -->[[Prototype]]:<!-- --> <!-- -->proto,<br/>    <!-- -->name:<!-- --> <!-- -->'obj'<br/>};</span><span id="8989" class="mz kz hu ml b fv ne nb l nc nd">&gt; obj.describe<br/>[Function]</span><span id="cc53" class="mz kz hu ml b fv ne nb l nc nd">&gt; obj.describe()<br/>'name: obj'</span></pre><blockquote class="mc md me"><p id="64e7" class="jn jo kp jp b jq kk js jt ju kl jw jx mf km ka kb mg kn ke kf mh ko ki kj jm hn dt translated"><code class="eh mi mj mk ml b">__proto__</code>是<code class="eh mi mj mk ml b">Object.prototype</code>对象的<a class="ae kq" href="http://www.javascripttutorial.net/javascript-objects/#accessor_property" rel="noopener ugc nofollow" target="_blank">访问器属性</a>。它公开了一个对象的内部原型链接(<code class="eh mi mj mk ml b">[[Prototype]])</code>，通过该链接可以访问它(<a class="ae kq" href="http://www.javascripttutorial.net/javascript-prototype/" rel="noopener ugc nofollow" target="_blank">，由javascripttutorial </a>)。</p></blockquote><pre class="mn mo mp mq fq mv ml mw mx aw my dt"><span id="0704" class="mz kz hu ml b fv na nb l nc nd">function Foo(name) {<br/>  this.name = name;<br/>}</span><span id="31ef" class="mz kz hu ml b fv ne nb l nc nd">var b = new Foo('b');<br/>var a = new Foo('a');<br/>b.say = function() {<br/>  console.log('Hi from ' + this.whoAmI());<br/>}</span><span id="d9e3" class="mz kz hu ml b fv ne nb l nc nd">console.log(a.__proto__ === Foo.prototype); <em class="kp">// true<br/></em>console.log(a.__proto__ === b.__proto__); <em class="kp">// true</em></span></pre><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nf"><img src="../Images/4821763def77f175609a7f65d9a11850.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*edtYKYPk_PW3-OK1.png"/></div></div><figcaption class="mr ms fg fe ff mt mu bd b be z ek"><a class="ae kq" href="http://www.javascripttutorial.net/javascript-prototype/" rel="noopener ugc nofollow" target="_blank">http://www.javascripttutorial.net/javascript-prototype/</a></figcaption></figure><blockquote class="mc md me"><p id="1b2e" class="jn jo kp jp b jq kk js jt ju kl jw jx mf km ka kb mg kn ke kf mh ko ki kj jm hn dt translated">JavaScript引擎将<code class="eh mi mj mk ml b">say()</code>方法添加到<code class="eh mi mj mk ml b">b</code>对象，而不是<code class="eh mi mj mk ml b">Foo.prototype</code>对象。</p><p id="edfb" class="jn jo kp jp b jq kk js jt ju kl jw jx mf km ka kb mg kn ke kf mh ko ki kj jm hn dt translated">如图所示，<code class="eh mi mj mk ml b">a.__proto__</code>暴露了指向<code class="eh mi mj mk ml b">Foo.prototype</code>对象的<code class="eh mi mj mk ml b">[[Prototype]]</code>。同样，<code class="eh mi mj mk ml b">b.__proto__</code>也指向与<code class="eh mi mj mk ml b">a.__proto__:</code>相同的对象</p></blockquote></div><div class="ab cl kr ks hc kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hn ho hp hq hr"><h1 id="f47f" class="ky kz hu bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv dt translated">示例1:通过构造函数创建对象</h1><p id="ea94" class="pw-post-body-paragraph jn jo hu jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj jm hn dt translated">这是一个来自<a class="ae kq" href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core/" rel="noopener ugc nofollow" target="_blank"> Dmitr </a> y的例子，关于通过构造函数创建对象，它将展示一个<strong class="jp hv">原型</strong>和<strong class="jp hv"> __proto__ </strong>如何在继承机制中工作。</p><blockquote class="mc md me"><p id="e920" class="jn jo kp jp b jq kk js jt ju kl jw jx mf km ka kb mg kn ke kf mh ko ki kj jm hn dt translated">除了按照指定的模式创建对象之外，<em class="hu">构造函数</em>还做了另一件有用的事情——它<em class="hu">自动为新创建的对象设置一个原型对象</em>。这个原型对象存储在<code class="eh mi mj mk ml b"><em class="hu">ConstructorFunction.prototype</em></code>属性中。</p><p id="3ff1" class="jn jo kp jp b jq kk js jt ju kl jw jx mf km ka kb mg kn ke kf mh ko ki kj jm hn dt translated">例如，我们可以使用构造函数用<code class="eh mi mj mk ml b"><em class="hu">b</em></code>对象重写前面的例子。因此，对象<code class="eh mi mj mk ml b"><em class="hu">a</em></code>(原型)<code class="eh mi mj mk ml b"><em class="hu">Foo.prototype</em></code>的作用是:</p></blockquote><p id="1632" class="pw-post-body-paragraph jn jo hu jp b jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ko ki kj jm hn dt translated">用原型<strong class="jp hv"> <em class="kp"> x </em> </strong>和<strong class="jp hv"> <em class="kp"> calculate() </em> </strong>创建Foo对象</p><pre class="mn mo mp mq fq mv ml mw mx aw my dt"><span id="48e9" class="mz kz hu ml b fv na nb l nc nd"><strong class="ml hv">function</strong> <!-- -->Foo(y) {<br/>  <strong class="ml hv">this</strong>.y = y;<br/>}</span><span id="8868" class="mz kz hu ml b fv ne nb l nc nd">Foo.prototype.x = 10;<br/>Foo.prototype.calculate = <strong class="ml hv">function</strong> <!-- -->(z) {<br/><strong class="ml hv">  return</strong> <strong class="ml hv">this</strong>.x + <strong class="ml hv">this</strong>.y + z;<br/>};</span></pre><p id="09b9" class="pw-post-body-paragraph jn jo hu jp b jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ko ki kj jm hn dt translated">使用对象Foo创建实例b:</p><pre class="mn mo mp mq fq mv ml mw mx aw my dt"><span id="e7bf" class="mz kz hu ml b fv na nb l nc nd"><strong class="ml hv">var</strong> <!-- -->b = <strong class="ml hv">new</strong> <!-- -->Foo(20);</span><span id="8f4e" class="mz kz hu ml b fv ne nb l nc nd">b.calculate(30); // 60</span><span id="ef31" class="mz kz hu ml b fv ne nb l nc nd">console.log(<br/>  b.__proto__ === Foo.prototype, // true<br/>  b.__proto__.calculate === Foo.prototype.calculate // true<br/>  b.__proto__.calculate === b.calculate, // true<br/>  Foo === b.constructor, // true<br/>  Foo === Foo.prototype.constructor, // true<br/>);</span></pre><blockquote class="mc md me"><p id="f54a" class="jn jo kp jp b jq kk js jt ju kl jw jx mf km ka kb mg kn ke kf mh ko ki kj jm hn dt translated">如上所示，b继承了Foo()的方法。“Foo.prototype”自动创建一个特殊属性“constructor”，它是对构造函数本身的引用。<br/>实例“b”可以通过委托找到它，并用来检查它们的构造函数。</p></blockquote><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div class="fe ff ng"><img src="../Images/911e27ad575bcb5e77705d87a5b9cee2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*I836SKwS0prHmfqgFGP9RQ.png"/></div><figcaption class="mr ms fg fe ff mt mu bd b be z ek">from: <a class="ae kq" href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core/" rel="noopener ugc nofollow" target="_blank">http://dmitrysoshnikov.com/ecmascript/javascript-the-core/</a></figcaption></figure></div><div class="ab cl kr ks hc kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hn ho hp hq hr"><h1 id="d15c" class="ky kz hu bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv dt translated">示例2 : JavaScript经典继承图</h1><p id="36b0" class="pw-post-body-paragraph jn jo hu jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj jm hn dt translated">这是Kenneth 的一个例子，也是关于通过构造函数创建对象的，但是我们关注的是在这些对象和实例系列中的原型链问题。原型对象也只是简单的对象，可能有自己的原型。如果一个原型对它的原型有一个非空的引用，依此类推，这被称为原型链(由<a class="ae kq" href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core/" rel="noopener ugc nofollow" target="_blank"> Dmitr </a> y)。</p><p id="6ebb" class="pw-post-body-paragraph jn jo hu jp b jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ko ki kj jm hn dt translated">下面是JavaScript伪经典继承的图表。构造函数Foo只是一个假想类的类名。foo对象是Foo的一个实例。</p><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div class="fe ff nh"><img src="../Images/602ffe6c0f4054223a59851c1e20ec7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*thxIm0Q78LpAtVEGjnGSdg.png"/></div><figcaption class="mr ms fg fe ff mt mu bd b be z ek"><a class="ae kq" href="https://kenneth-kin-lum.blogspot.tw/2012/10/javascripts-pseudo-classical.html?showComment=1484288337339#c1393503225616140233" rel="noopener ugc nofollow" target="_blank">https://kenneth-kin-lum.blogspot.tw/2012/10/javascripts-pseudo-classical.html?showComment=1484288337339#c1393503225616140233</a></figcaption></figure><p id="149a" class="pw-post-body-paragraph jn jo hu jp b jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ko ki kj jm hn dt translated">现在我们可以从图中看出，为什么当我们从<strong class="jp hv">动物</strong>继承<strong class="jp hv">狗</strong>时，我们会这样做:</p><pre class="mn mo mp mq fq mv ml mw mx aw my dt"><span id="d98c" class="mz kz hu ml b fv na nb l nc nd"><strong class="ml hv">function Dog() {} // the usual constructor function</strong><br/><strong class="ml hv"> Dog.prototype = new Animal();</strong><br/><strong class="ml hv"> Dog.prototype.constructor = Dog;</strong></span></pre><h2 id="fbc6" class="mz kz hu bd la ni nj nk le nl nm nn li jy no np lm kc nq nr lq kg ns nt lu nu dt translated">new()实例时会发生什么:</h2><blockquote class="mc md me"><p id="56ff" class="jn jo kp jp b jq kk js jt ju kl jw jx mf km ka kb mg kn ke kf mh ko ki kj jm hn dt translated">注意<strong class="jp hv"> Foo.prototype </strong>中的<strong class="jp hv">原型</strong>不是形成原型链。<strong class="jp hv"> Foo.prototype </strong> <em class="hu">指向</em>某个原型链中的某个位置，但是Foo的这个<strong class="jp hv">原型</strong>属性并不是形成原型链。构成原型链的是指向链上方的<strong class="jp hv"> __proto__ </strong>和<strong class="jp hv"> __proto__ </strong>指向的对象，比如从<strong class="jp hv"> foo。__proto__ </strong>，上至<strong class="jp hv"> foo。__proto__。__proto__ </strong>等等，直到到达空值为止。</p></blockquote><h2 id="2aa6" class="mz kz hu bd la ni nj nk le nl nm nn li jy no np lm kc nq nr lq kg ns nt lu nu dt translated">__proto__与原型的关系</h2><blockquote class="mc md me"><p id="9661" class="jn jo kp jp b jq kk js jt ju kl jw jx mf km ka kb mg kn ke kf mh ko ki kj jm hn dt translated">JavaScript的伪经典继承是这样工作的:我是一个构造函数，我只是一个函数，我持有一个原型引用，每当调用<strong class="jp hv"> foo = new Foo() </strong>时，我会让<strong class="jp hv"> foo。__proto__ </strong>指向我的原型对象。所以<strong class="jp hv"> Foo.prototype </strong>和<strong class="jp hv"> obj。__proto__ </strong>是两个不同的概念。<strong class="jp hv"> Foo.prototype </strong>表示当<strong class="jp hv"> Foo </strong>的对象被创建时，这是新对象的原型链应该指向的点——即<strong class="jp hv"> foo。__proto__ </strong>应该指向<strong class="jp hv"> Foo.prototype </strong>指向的地方。</p></blockquote><h2 id="421a" class="mz kz hu bd la ni nj nk le nl nm nn li jy no np lm kc nq nr lq kg ns nt lu nu dt translated">如果需要添加一个函数呢</h2><blockquote class="mc md me"><p id="8158" class="jn jo kp jp b jq kk js jt ju kl jw jx mf km ka kb mg kn ke kf mh ko ki kj jm hn dt translated">如果<strong class="jp hv"> woofie </strong>对象没有<strong class="jp hv"> move </strong>方法，它将沿着原型链向上，就像任何原型继承场景一样，首先到达由<strong class="jp hv"> woofie指向的对象。__proto__ </strong>，与<strong class="jp hv"> Dog.prototype </strong>所指的对象相同。如果方法<strong class="jp hv"> move </strong>不是该对象的属性(意味着<strong class="jp hv"> Dog </strong>类没有方法<strong class="jp hv"> move </strong>，则在原型链中上升一级，即<strong class="jp hv"> woofie。__proto__。__proto__ </strong>，或者同<strong class="jp hv"> Animal.prototype </strong>。</p></blockquote><pre class="mn mo mp mq fq mv ml mw mx aw my dt"><span id="18d6" class="mz kz hu ml b fv na nb l nc nd"><strong class="ml hv">Animal.prototype.move = function() { ... };</strong></span></pre><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div class="fe ff nh"><img src="../Images/c45402eee7fe26e935b5917cd82ae86f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*tU88bH9_JKuRmIloA1eWUw.png"/></div><figcaption class="mr ms fg fe ff mt mu bd b be z ek"><a class="ae kq" href="https://kenneth-kin-lum.blogspot.tw/2012/10/javascripts-pseudo-classical.html?showComment=1484288337339#c1393503225616140233" rel="noopener ugc nofollow" target="_blank">https://kenneth-kin-lum.blogspot.tw/2012/10/javascripts-pseudo-classical.html?showComment=1484288337339#c1393503225616140233</a></figcaption></figure><blockquote class="mc md me"><p id="dfc7" class="jn jo kp jp b jq kk js jt ju kl jw jx mf km ka kb mg kn ke kf mh ko ki kj jm hn dt translated">即使<strong class="jp hv"> foo.constructor === Foo </strong>，但是<strong class="jp hv">构造函数</strong>的属性并不是<strong class="jp hv"> foo </strong>自己的属性。它实际上是通过沿着原型链向上到达<strong class="jp hv"> foo的位置而获得的。__proto__ </strong>正在指向。同样适用于<strong class="jp hv"> Function.constructor </strong>。当我们看到<strong class="jp hv"> Constructor.prototype </strong>，<strong class="jp hv"> foo时，这个图可能会很复杂，有时会令人困惑。__proto__ </strong>，<strong class="jp hv">foo . prototype . constructor</strong>。</p><p id="7585" class="jn jo kp jp b jq kk js jt ju kl jw jx mf km ka kb mg kn ke kf mh ko ki kj jm hn dt translated">为了验证这个图，请注意，即使<strong class="jp hv"> foo.constructor </strong>将显示一个值，属性<strong class="jp hv"> constructor </strong>并不是<strong class="jp hv"> foo </strong>自己的属性，而是通过跟踪原型链获得的，正如<strong class="jp hv">foo . hasownproperty(" constructor ")</strong>可以看出的那样。</p></blockquote></div><div class="ab cl kr ks hc kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hn ho hp hq hr"><h1 id="093b" class="ky kz hu bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv dt translated">注意事项:</h1><p id="7406" class="pw-post-body-paragraph jn jo hu jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj jm hn dt translated">一个对象通过内部属性指定它的原型</p><p id="58bd" class="pw-post-body-paragraph jn jo hu jp b jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ko ki kj jm hn dt translated"><code class="eh mi mj mk ml b"><strong class="jp hv">__proto__</strong></code>给语言带来了对<code class="eh mi mj mk ml b">[[Prototype]]</code>的直接访问(由<a class="ae kq" href="http://speakingjs.com/es5/ch17.html" rel="noopener ugc nofollow" target="_blank">speakingjs.com</a>)。</p><p id="7c87" class="pw-post-body-paragraph jn jo hu jp b jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ko ki kj jm hn dt translated"><code class="eh mi mj mk ml b"><strong class="jp hv">prototype</strong></code>是<strong class="jp hv"> <em class="kp">对象</em> </strong>，当你用<code class="eh mi mj mk ml b">new.</code>创建一个对象时，用来构建<code class="eh mi mj mk ml b">__proto__</code></p><p id="496c" class="pw-post-body-paragraph jn jo hu jp b jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ko ki kj jm hn dt translated"><code class="eh mi mj mk ml b"><strong class="jp hv">prototype</strong></code>在实例本身(或其他对象)上不可用，只在构造函数上可用。</p><p id="4058" class="pw-post-body-paragraph jn jo hu jp b jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ko ki kj jm hn dt translated"><code class="eh mi mj mk ml b"><strong class="jp hv">prototype</strong></code>仅在函数上可用，因为它们是从<code class="eh mi mj mk ml b">Function</code>和<code class="eh mi mj mk ml b">Object,</code>复制的，但在其他任何情况下都不可用。然而<code class="eh mi mj mk ml b"><strong class="jp hv">__proto__</strong></code>却随处可见。</p><pre class="mn mo mp mq fq mv ml mw mx aw my dt"><span id="c564" class="mz kz hu ml b fv na nb l nc nd">( new Foo ).__proto__ === Foo.prototype  //true<br/>( new Foo ).prototype === undefined      //true</span></pre><p id="3fe1" class="pw-post-body-paragraph jn jo hu jp b jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ko ki kj jm hn dt translated"><strong class="jp hv"> <em class="kp">委托原型</em> </strong>和<strong class="jp hv"> <em class="kp">串联继承</em> </strong></p><pre class="mn mo mp mq fq mv ml mw mx aw my dt"><span id="0d37" class="mz kz hu ml b fv na nb l nc nd"><strong class="ml hv"><em class="kp">Cat.prototype = new Animal();</em></strong><br/>//it will properly follow the prototype chain through the inheritance hierarchy.</span><span id="ddfb" class="mz kz hu ml b fv ne nb l nc nd"><strong class="ml hv"><em class="kp">Cat.prototype = Animal.prototype<br/></em></strong>//<!-- -->any runtime changes to the Cat prototype would also affect the Animal</span></pre><p id="4b5b" class="pw-post-body-paragraph jn jo hu jp b jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ko ki kj jm hn dt translated"><strong class="jp hv">静态属性/功能</strong>在原型上不存在。只有在创建了一个<code class="eh mi mj mk ml b">new</code>实例时，才会用到<code class="eh mi mj mk ml b">prototype</code>。</p></div><div class="ab cl kr ks hc kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hn ho hp hq hr"><p id="11de" class="pw-post-body-paragraph jn jo hu jp b jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ko ki kj jm hn dt translated">喜欢这个故事？对别人有帮助吗？这有助于我知道你是否想看到更多关于他的主题，并帮助人们在点击下面的 时看到这个故事。</p></div><div class="ab cl kr ks hc kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hn ho hp hq hr"><h1 id="db9e" class="ky kz hu bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv dt translated">参考:</h1><p id="92ff" class="pw-post-body-paragraph jn jo hu jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj jm hn dt translated"><a class="ae kq" href="http://speakingjs.com/es5/index.html" rel="noopener ugc nofollow" target="_blank">http://speakingjs.com/es5/index.html</a></p><p id="9841" class="pw-post-body-paragraph jn jo hu jp b jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ko ki kj jm hn dt translated"><a class="ae kq" href="http://www.javascripttutorial.net/javascript-prototype/" rel="noopener ugc nofollow" target="_blank">http://www.javascripttutorial.net/javascript-prototype/</a></p><p id="2bd8" class="pw-post-body-paragraph jn jo hu jp b jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ko ki kj jm hn dt translated"><a class="ae kq" href="http://stackoverflow.com/questions/9959727/proto-vs-prototype-in-javascript" rel="noopener ugc nofollow" target="_blank">http://stack overflow . com/questions/9959727/proto-vs-prototype-in-JavaScript</a></p><p id="95a0" class="pw-post-body-paragraph jn jo hu jp b jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ko ki kj jm hn dt translated"><a class="ae kq" href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core/" rel="noopener ugc nofollow" target="_blank">http://dmitrysoshnikov.com/ecmascript/javascript-the-core/</a></p><p id="fef0" class="pw-post-body-paragraph jn jo hu jp b jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ko ki kj jm hn dt translated"><a class="ae kq" href="https://www.quora.com/What-is-the-difference-between-__proto__-and-prototype" rel="noopener ugc nofollow" target="_blank">https://www . quora . com/What-is-the-difference-_ _ proto _ _-and-prototype</a></p><p id="64d7" class="pw-post-body-paragraph jn jo hu jp b jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ko ki kj jm hn dt translated"><a class="ae kq" href="http://www.jisaacks.com/prototype-vs-proto/" rel="noopener ugc nofollow" target="_blank">http://www.jisaacks.com/prototype-vs-proto/</a></p><p id="9f26" class="pw-post-body-paragraph jn jo hu jp b jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ko ki kj jm hn dt translated"><a class="ae kq" href="http://kenneth-kin-lum.blogspot.tw/2012/10/javascripts-pseudo-classical.html" rel="noopener ugc nofollow" target="_blank">http://Kenneth-kin-lum . blogspot . tw/2012/10/JavaScript s-pseudo-classic . html</a></p><div class="mn mo mp mq fq ab cb"><figure class="nv iv nw nx ny nz oa paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nv iv nw nx ny nz oa paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nv iv nw nx ny nz oa paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mc md me"><p id="f922" class="jn jo kp jp b jq kk js jt ju kl jw jx mf km ka kb mg kn ke kf mh ko ki kj jm hn dt translated"><a class="ae kq" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kq" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kq" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae kq" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jn jo kp jp b jq kk js jt ju kl jw jx mf km ka kb mg kn ke kf mh ko ki kj jm hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kq" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kq" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ob"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>