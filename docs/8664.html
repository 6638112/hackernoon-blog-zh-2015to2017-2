<html>
<head>
<title>A Simple, Serverless API using Azure Tables &amp; Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个简单的、无服务器的API，使用Azure表和函数</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-simple-serverless-api-using-azure-tables-functions-bd7669b4b8cf?source=collection_archive---------2-----------------------#2017-12-10">https://medium.com/hackernoon/a-simple-serverless-api-using-azure-tables-functions-bd7669b4b8cf?source=collection_archive---------2-----------------------#2017-12-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/38732bbc3c12a9bc5cec020632a937c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dHYJosowL4M62WuXjrZppg.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Who would’ve thought developing in a Portal would be so bearable.</figcaption></figure><p id="1329" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">虽然无服务器绝不是一项新的技术，但直到最近在准备T2 532微软考试时，我才真正享受到AWS Lambda和Azure Functions等产品的强大功能。无论是可伸缩性、成本还是易于实现；在您的基于云的解决方案中采用无服务器方法是有好处的。这篇文章不一定是如何使用微软Azure功能的充实教程，而是一篇探索性的文章，讲述了在Azure门户内部创建各种各样的数据库后端<em class="kf">“API”</em>是多么容易！</p><p id="a9db" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv">注意，我不一定主张这就是你应该开发Azure函数的方式。</strong> <a class="ae ke" href="https://docs.microsoft.com/en-us/azure/app-service/app-service-deploy-local-git" rel="noopener ugc nofollow" target="_blank"> <strong class="ji hv">微软支持使用Git </strong> </a> <strong class="ji hv">等版本控制系统与Azure函数协同工作，并提供一个</strong><a class="ae ke" href="https://github.com/Azure/azure-functions-cli" rel="noopener ugc nofollow" target="_blank"><strong class="ji hv">Azure Functions CLI</strong></a><strong class="ji hv">用于在本地运行函数。</strong></p><h2 id="44cd" class="kg kh hu bd ki kj kk kl km kn ko kp kq jr kr ks kt jv ku kv kw jz kx ky kz la dt translated">安装</h2><figure class="lc ld le lf fq iv fe ff paragraph-image"><div class="fe ff lb"><img src="../Images/065189d7bf8eb28636777750d96e802a.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*Pu3-09-fBv3mj0HBhZRstQ.png"/></div></figure><p id="45d9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">假设你有Azure订阅(<a class="ae ke" href="https://azure.microsoft.com/en-us/free/" rel="noopener ugc nofollow" target="_blank">如果没有在这里注册，它是免费的</a>)，在市场中找到<em class="kf">“无服务器功能应用”</em>资源。虽然我通常建议您分别创建资源组和存储帐户，但为了简化过程，我们将使用函数创建这两个帐户。</p><p id="6846" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">对于那些不确定Azure行话的人来说，<em class="kf">资源组</em>本质上就是它的名字所暗示的，是Azure资源的集合，这些资源是你在Azure上使用的服务。<em class="kf">存储帐户</em>是一种资源，它在一个资源下提供多种类型的存储解决方案，包括文件、blob、表、队列等等。在本教程中，我们将重点关注使用<em class="kf">表格</em>，Azure将其描述为:</p><blockquote class="lg lh li"><p id="601d" class="jg jh kf ji b jj jk jl jm jn jo jp jq lj js jt ju lk jw jx jy ll ka kb kc kd hn dt translated">用于非结构化和半结构化数据的NoSQL存储，是web应用程序、地址簿和其他用户数据的理想选择。</p></blockquote><figure class="lc ld le lf fq iv fe ff paragraph-image"><div class="fe ff lm"><img src="../Images/5ef3975fb4bdaedaf9bd34f92c13f15f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*7YQagOYbSrkV_yEQcfiLHw.png"/></div></figure><p id="407b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">当创建你的函数应用时，Azure将在你键入时预填充资源组和存储帐户的名称。对于托管计划，我选择了消费，因为这是一种按使用量而不是正常运行时间计费的方式。位置很大程度上取决于你的位置，所以它对功能本身并没有什么影响。单击“创建”将验证Azure函数配置并将其添加到您的函数应用中。</p><h2 id="8038" class="kg kh hu bd ki kj kk kl km kn ko kp kq jr kr ks kt jv ku kv kw jz kx ky kz la dt translated">让我们写一些函数！</h2><p id="ffa3" class="pw-post-body-paragraph jg jh hu ji b jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd hn dt translated">一旦功能应用被部署，你可以在Azure门户网站的<em class="kf">“功能应用”</em>部分找到它。在我们开始创建函数之前，我想修改我的CORS原点，以允许所有的(*)，就本文的目的而言，定义我使用的具体原点是不必要的。</p><figure class="lc ld le lf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ls"><img src="../Images/46a94b28501245e33961f02d697c63d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qcZOu2HXS840ojvH-GhcNA.png"/></div></div></figure><p id="1784" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">点击您的功能应用程序，进入平台功能-&gt; CORS，然后删除所有允许的原点，添加一个原点*。</p><figure class="lc ld le lf fq iv fe ff paragraph-image"><div class="fe ff lt"><img src="../Images/60cd7a84064a4301874d89114ceada3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*yGx74lIXr2mskABxrg-qQg.png"/></div></figure><p id="4c17" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">保存这些更改后，转到函数应用程序的函数部分，然后单击新建函数按钮。这将显示Azure提供的所有模板。在本教程中，我们将使用HTTP GET和HTTP POST模板，因为该模板包含了连接到表存储所需的所有内容。</p><figure class="lc ld le lf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lu"><img src="../Images/c3256c739a83e7531bfafc539b022233.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XNwOmKcraSeTnS1cSofEhA.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">So many options :O</figcaption></figure><p id="02f5" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们将从HTTP GET开始，对于本教程，我将使用C#,但我承认我在很大程度上依赖于生成的代码，你可以使用任何你想使用的语言。</p><figure class="lc ld le lf fq iv fe ff paragraph-image"><div class="fe ff lv"><img src="../Images/c96355077d421bf8202edf80cc2861ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*LAUAMEaBqdAlr_Euh4_HMg.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Let’s go with a food theme for a change.</figcaption></figure><p id="006f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在本教程中，我们将从食品数据库中添加和检索项目。在很大程度上，函数的命名取决于您，需要更改的是表名和存储帐户连接。表格名称可以是任何名称，因为如果表格不存在，Azure将创建一个表格，并且要检索您之前创建的存储帐户，请单击<em class="kf">“新建”</em>按钮并从选项列表中选择它。对HTTP POST重复这个过程。</p><p id="1752" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">首先，我们将编辑GET函数，使它更像我们自己的函数。在Azure门户中打开该功能将打开一个<a class="ae ke" href="https://github.com/Microsoft/monaco-editor" rel="noopener ugc nofollow" target="_blank"> monaco编辑器</a>，其中包含我们的功能。如果你的函数使用C#这样的强类型语言，Azure会为你的函数生成一个<code class="eh lw lx ly lz b">TableEntity</code>(默认为person)。让我们稍微编辑一下，让它更独特一些…</p><figure class="lc ld le lf fq iv"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="784f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如你所见，除了<code class="eh lw lx ly lz b">RowKey </code>和<code class="eh lw lx ly lz b">PartitionKey</code>，TableEntity是一个非常普通的C#对象。虽然这不是Azure Functions的概念，更像是Azure Tables的一条信息，但总而言之,<code class="eh lw lx ly lz b">RowKey</code>可以被认为是表中的主键。我们可以使用它来惟一地标识和轻松地检索表中的条目。<code class="eh lw lx ly lz b">PartitionKey </code>稍微复杂一点，它定义了Azure将如何在你的存储中分发条目。可以假设具有相同分区键的元素保存在存储的同一个分区中，因此可以很容易地一起查询和批处理。</p><p id="fbfe" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">正如你可能猜到的，在这个例子中，我将使用<code class="eh lw lx ly lz b">FoodItem </code>的名字作为<code class="eh lw lx ly lz b">RowKey</code>，所有的条目都被相同的分区。</p><p id="4a04" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我还需要重构<code class="eh lw lx ly lz b">HttpResponseMessage</code>的函数，以便它能够处理正确的数据类型。</p><figure class="lc ld le lf fq iv"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="1185" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">有了这些改变，我们的GET端点就完成了！所有的实现都是在Azure门户编辑器中实现的。为了测试这个函数，我们可以从右上角的<em class="kf"> Get Function URL </em>按钮复制URL，并用Postman查询，得到的响应是一个预期的空数组。</p><figure class="lc ld le lf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mc"><img src="../Images/81cbe869325940b82d793888de19145d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DmEKX5Sp0C4d6ag-3RgVVw.png"/></div></div></figure><p id="f84a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">导航到POST函数，对于我的函数，我写了下面的代码；</p><figure class="lc ld le lf fq iv"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="be7f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">虽然模型保持不变，但函数本身还是有一些需要注意的地方。</p><ul class=""><li id="1e4e" class="md me hu ji b jj jk jn jo jr mf jv mg jz mh kd mi mj mk ml dt translated">强调可空数据类型，尤其是<code class="eh lw lx ly lz b">int?</code>这样的例子。</li><li id="2c84" class="md me hu ji b jj mm jn mn jr mo jv mp jz mq kd mi mj mk ml dt translated">我的验证基本上是确保<code class="eh lw lx ly lz b">name</code>和<code class="eh lw lx ly lz b">rating</code>存在。</li><li id="a95e" class="md me hu ji b jj mm jn mn jr mo jv mp jz mq kd mi mj mk ml dt translated">不需要像在最初生成的代码中那样显式地设置一个<code class="eh lw lx ly lz b">PartitionKey</code>和一个<code class="eh lw lx ly lz b">RowKey</code>，因为我们在构造函数和<code class="eh lw lx ly lz b">Name</code>设置器中会处理这些。</li></ul><p id="022e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">一旦实现，保存您的post函数并确保您的日志中没有错误。如果一切顺利，祝贺你！您刚刚利用Azure表存储支持的Azure函数实现了GET和POST端点。为了测试它，让我们打开postman并向POST端点发送一些数据；</p><figure class="lc ld le lf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mr"><img src="../Images/10ecc1361c7dea21f300a873c23173c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xWQNkzfwD7QviW5gimiDZA.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Nothing was more satisfying than the 201 I received for this</figcaption></figure><figure class="lc ld le lf fq iv fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/8a4efd75e29d909e3fa46349d957c48d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*UmbmPmB95_NXqzQ6LyptGA.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">GET Endpoint works as expected.</figcaption></figure><p id="62dd" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">虽然Azure 函数还有很多值得探索的地方，但我希望这是一个很好的入门书，让你知道开始使用它们有多容易。</p><p id="4d46" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果你喜欢这篇文章，请给我们一个掌声，因为它膨胀了我的自我，激发了我写更多作品的需要。</p><p id="fb7d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> PS:只想推荐Scott Duffy的Udemy课程</strong><a class="ae ke" href="https://www.udemy.com/70532-azure/learn/v4/overview" rel="noopener ugc nofollow" target="_blank"><strong class="ji hv">《70-532开发微软Azure解决方案认证》</strong> </a> <strong class="ji hv">作为我想写这篇文章的理由。绝对值得一试，因为它非常深入，是最新的，并且是围绕微软的同名考试设计的。</strong></p><figure class="lc ld le lf fq iv"><div class="bz el l di"><div class="mt mb l"/></div></figure></div></div>    
</body>
</html>