<html>
<head>
<title>Implementation Inheritance Is Evil</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实现继承是邪恶的</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/inheritance-based-on-internal-structure-is-evil-7474cc8e64dc?source=collection_archive---------10-----------------------#2017-09-27">https://medium.com/hackernoon/inheritance-based-on-internal-structure-is-evil-7474cc8e64dc?source=collection_archive---------10-----------------------#2017-09-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="e683" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">关于为什么遗传不好已经说了很多。我将分享我对这一主题的看法，并说明大多数时候并不真正需要继承。</p><h2 id="f928" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">结构遗传</h2><p id="1408" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated"><em class="kq">它打破了封装<br/> </em>为了属性重用而继承并不是OOP中的继承方式，因为早期的<a class="ae jp" href="https://en.wikipedia.org/wiki/Simula" rel="noopener ugc nofollow" target="_blank"> Simula </a>和<a class="ae jp" href="https://en.wikipedia.org/wiki/Smalltalk" rel="noopener ugc nofollow" target="_blank"> Smalltalk </a>。这种继承方式打破了人类的隐喻。没有人应该接触到我的内部:胃，大脑，或者肺。它打破了对象的封装，这是它的基本特征。它打破了OOP。</p><p id="6937" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="kq">是</em> <a class="ae jp" href="https://en.wikipedia.org/wiki/Fragile_base_class" rel="noopener ugc nofollow" target="_blank"> <em class="kq">脆弱</em> </a> <em class="kq"> <br/> </em>行为和内部结构是正交的概念。它们独立变化。如果某个对象今天扩展了另一个对象的内部结构，并不意味着明天事情会保持不变。</p><p id="011b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="kq">正是</em> <a class="ae jp" href="http://www.yegor256.com/2016/09/13/inheritance-is-procedural.html" rel="noopener ugc nofollow" target="_blank"> <em class="kq">对程序性</em> </a> <br/>内在结构的继承必然促进了程序观的产生。好的对象就是没有机会在这么恶劣的环境下生存。它们只不过是一种数据结构。我个人在巨大的层级结构中的经历正好反映了这一点。我参与的一个项目有大量的类，代表应用程序可以处理的每个请求。可怕的是这些课程充满了商业逻辑。由于没有反映域的真实对象，这些请求类中的业务逻辑更像是对一些数据进行操作的过程。因为这种继承仅仅是由请求字段重用驱动的，所以它是非常不自然和不可维护的。</p><p id="11c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从这个过程的意义上来说，应用继承产生的实体看起来总是不自然的。它们很少反映无处不在的语言，如果有的话。原因是任何领域都有<a class="ae jp" rel="noopener" href="/@wrong.about/how-to-decompose-a-system-into-modules-796bd941f036">自然接缝</a>，划分不同的责任、行为——这正是一个对象与另一个对象不同的地方。对象内部数据本质上不能用来区分对象——仅仅因为它是内部的。</p><h2 id="ccc1" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">行为遗传</h2><p id="7034" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">为了行为扩展而继承才是应该走的路。这就像生物物种分类学。它的建立依赖于所有物种共有的一些共同特征。例如，所有的哺乳动物都是脊椎动物，吸热并产生乳汁喂养婴儿。灵长类动物是哺乳动物的一种，但是有发达的手和脚，有手指和脚趾。人类是<em class="kq">灵长类的一种</em>，但是我们有自我反省的能力。</p><p id="e28b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个在<a class="ae jp" href="https://www.amazon.com/Object-Thinking-Developer-Reference-David/dp/0735619654" rel="noopener ugc nofollow" target="_blank">对象思维</a>中使用的隐喻，它有一个有趣的结果。这意味着<strong class="it hv">具体的类不能被继承</strong>。记住生物分类学的比喻，没有具体的哺乳动物实例。没有具体的灵长类动物。有猫，狗，人类。真正的实体是层次结构的叶子。其余的都是抽象类或接口。因此，我更倾向于<a class="ae jp" href="https://en.wikipedia.org/wiki/Subtyping" rel="noopener ugc nofollow" target="_blank">子类型</a>的概念，而不是继承。</p><h2 id="cd06" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">遗传是罕见的</h2><p id="0197" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">假设我们有一个商业实体。可以审批，也可以过期。典型的方法是创建一个“状态”属性。但是很快我们意识到行为有很大不同。被批准的商家可以做我们系统允许的任何事情，不像过期的商家。因此，我们提出了两个独立的类——一个用于批准的商户，另一个用于过期的商户。第一个推动力是用他们共享的所有内部数据——姓名、地址等——创建一个基本的merchant类。但是，首先，正如我在开始写的，这是错误的动机，其次，没有任何对象内部数据必须被建模为对象的属性(<a class="ae jp" rel="noopener" href="/@wrong.about/you-dont-need-an-orm-7ef83bd1b37d">并且通常不是</a>)。所以这种继承在两方面都是错的。</p><p id="147b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">遵循行为对象分解方法，结果表明继承在大多数情况下是不必要的。我们过去认为关系非常密切的东西——批准的商户和过期的商户，都是商户——实际上没有任何共同的行为，因此没有共同的父代。</p><h2 id="dd12" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">继承层次很小</h2><p id="2475" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">所以按照这种分解方法，除非我们设计生物分类学，否则不会有巨大的遗传级联。装修工的数量反而大。</p><p id="51b5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这都是关于分解你的领域。当<a class="ae jp" rel="noopener" href="/@wrong.about/on-good-domain-decomposition-385ee8ce5a3">做对了</a>，自然就出来了。然而这并不容易。</p></div><div class="ab cl kr ks hc kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hn ho hp hq hr"><p id="4836" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以不要扩展具体的类——只扩展抽象的。首先分解你的问题空间，这导致了小而罕见的继承层次，有大量的装饰者。</p></div></div>    
</body>
</html>