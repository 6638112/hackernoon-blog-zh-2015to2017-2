<html>
<head>
<title>Writing modern C++ servers using Wangle.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用王乐编写现代C++服务器。</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/writing-high-performance-servers-in-modern-c-7cd00926828?source=collection_archive---------0-----------------------#2016-01-10">https://medium.com/hackernoon/writing-high-performance-servers-in-modern-c-7cd00926828?source=collection_archive---------0-----------------------#2016-01-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="e670" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，感谢所有来自我的第一篇帖子的反馈——用C++ 创业。</p><blockquote class="jq jr js"><p id="b984" class="ir is jt it b iu iv iw ix iy iz ja jb ju jd je jf jv jh ji jj jw jl jm jn jo hn dt translated"><strong class="it hv">TL；我展示了如何构建一个现代的C++高性能异步echo服务器，它只用48行代码就可以编写完成。</strong></p></blockquote><p id="0ca5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我在之前的帖子中提到，我能够在一天之内使用脸书的<a class="ae jp" href="https://github.com/facebook/wangle" rel="noopener ugc nofollow" target="_blank">王乐</a>构建一个原型数据库引擎，所以这篇帖子解释了我是如何做到这一点的。在这篇文章结束时，你将能够使用王乐编写一个高性能的C++服务器。这篇文章也作为一个教程，将被合并到王乐的<em class="jt"> README.md. </em></p><p id="b05c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我将展示如何用现代C++编写echo服务器——这是分布式系统的“hello world”的等价物。服务器将通过直接发回相同的消息来响应每条消息。我们还将编写一个客户机，向我们的echo服务器发送消息。你可以在这里找到例子<a class="ae jp" href="https://github.com/facebook/wangle/tree/master/wangle/example/echo" rel="noopener ugc nofollow" target="_blank">的源代码。</a></p><p id="731c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">王乐是一个客户端/服务器应用程序框架，用于构建异步、事件驱动的现代C++服务。它对王乐的基本抽象是管道。一旦你完全理解了这种抽象，你将能够编写各种复杂的现代C++服务。另一个重要的抽象是<em class="jt">服务，</em>它是管道的高级版本，但超出了本文的范围。</p><h2 id="6bc6" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">管道</h2><p id="47f9" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">管道是王乐最重要和最强大的抽象。它提供了极大的灵活性来定制服务处理请求和响应的方式。</p><p id="e727" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">管道是一系列请求/响应处理程序。我在想一个类似管道的真实世界，我唯一能想到的是工厂里的生产线。生产线是按顺序工作的，每个工人收到一件物品，只用它完成一项功能，然后把它传递给下一个工人，直到产品完全制造出来。这不是一个很好的类比，因为它只能上游而不能下游，因为管道也可以以相反的方式处理下游，从制成品到原材料。</p><p id="21be" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">王乐处理程序处理下游(处理响应)和上游(处理请求)事件。一旦您将处理程序链接在一起，它就提供了一种灵活的方法来将原始数据流转换为所需的消息类型(类),以及将相反的消息类型转换为原始数据流。</p><p id="ea2c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，在echo服务的管道中，我们将创建一个管道，大约<em class="jt">到</em>有以下处理程序。</p><ol class=""><li id="bc78" class="kx ky hu it b iu iv iy iz jc kz jg la jk lb jo lc ld le lf dt translated"><strong class="it hv">处理器1 </strong></li></ol><p id="dbcf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jt">上游</em>:从一个套接字接收一个原始二进制流，并将其读入一个零拷贝字节缓冲区，然后将其发送到处理程序2。</p><p id="d01b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jt">下游</em>:接收一个零拷贝字节缓冲区，并将其内容写入套接字。</p><p id="3ba4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2.<strong class="it hv">处理器2 </strong></p><p id="eb14" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jt">上游:</em>从处理程序1接收一个零拷贝字节缓冲区，将字节缓冲区解码成一个字符串，并将该字符串向上发送到处理程序3。</p><p id="8e57" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jt">下游:</em>从处理程序3接收一个字符串，将std::string编码到一个零拷贝字节缓冲区中，并将其发送到处理程序1。</p><p id="7eef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">3.<strong class="it hv">处理器3 </strong></p><p id="1d03" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jt">上游:</em>从处理程序2接收一个字符串，然后将它发送回管道写回客户端。它将字符串发送回处理程序2。</p><p id="2a65" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jt">下游:</em>从上游接收一个std::string，并将其向下传递给处理程序2。</p><p id="9e9d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">非常重要的一点是，一个处理程序应该只做一件事，而且只做一件事。如果有一个处理程序执行不止一个功能——比如直接从原始字节流中解码一个字符串——那么就需要把它分成几个处理程序。这对于最大化可维护性和灵活性非常重要。</p><p id="b679" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">哦，对了，处理程序不是线程安全的，所以不要添加任何没有互斥、原子锁等保护的共享状态。如果你想使用一个线程安全的容器，那么我真的推荐Folly的无锁数据结构，你可以很容易地导入它，因为它们是王乐的一个依赖项，速度非常快。</p><p id="e4e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果这还没有太多意义，不要担心——当您看到实际的代码时，应该会更清楚。</p><h2 id="29f9" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">回声服务器</h2><p id="c3ee" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">我将开始展示用王乐构建您的第一个C++ echo服务器的代码。我想你已经安装了王乐。我必须警告，不幸的是，它还没有建立在马克斯OS X上，所以我建议虚拟化Ubuntu 14.04来安装它。</p><p id="5c20" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里是echo处理程序:它接收一个字符串，将其打印到stdout，然后在管道中将其发送回下游。添加行分隔符非常重要，因为我们的管道将使用行解码器——将一个字节缓冲区拆分为行分隔的字节缓冲区。</p><figure class="lg lh li lj fq lk"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="1359" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这需要是管道中的最后一个处理程序。现在我们需要创建一个<em class="jt"> PipelineFactory </em>，在这里我们定义管道来处理请求和响应。</p><figure class="lg lh li lj fq lk"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="822e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">非常重要的一点是，你必须严格控制插入的顺序，因为它们是按插入顺序排列的。这个管道有4个处理程序:</p><ol class=""><li id="f2f1" class="kx ky hu it b iu iv iy iz jc kz jg la jk lb jo lc ld le lf dt translated"><strong class="it hv"> AsyncSocketHandler: </strong></li></ol><p id="58c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jt">上游:</em>从套接字读取原始数据流，并将其转换成零拷贝字节缓冲区。</p><p id="5622" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jt">下游:</em>将零拷贝字节缓冲区的内容写入底层套接字。</p><p id="d4fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2.<strong class="it hv"> LineBasedFrameDecoder: </strong></p><p id="7d9f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jt">上游:</em>接收一个零拷贝字节缓冲区，并在行尾拆分</p><p id="3190" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jt">下游:</em>只是将字节缓冲传递给<em class="jt"> AsyncSocketHandler </em></p><p id="0e59" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">3.<strong class="it hv">字符串编码:</strong></p><p id="f3f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jt">上游:</em> <strong class="it hv"> </strong>接收一个字节缓冲区，将其解码成std::string，并向上传递给EchoHandler。</p><p id="03ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jt">下游:</em> <strong class="it hv"> </strong>接收一个std::string，将其编码到一个字节缓冲区，并向下传递到LineBasedFrameDecoder。</p><p id="3e39" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">4.<strong class="it hv"> EchoHandler: </strong></p><p id="8acc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上游:接收一个std::string并将其写入管道，管道会将消息发送到下游。</p><p id="618e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下游:接收一个std::string并将其转发给StringCodec。</p><p id="baf4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在需要做的就是将管道工厂插入到一个<em class="jt"> ServerBootstrap </em>中，这就差不多了。绑定一个端口并等待它停止。</p><figure class="lg lh li lj fq lk"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="f8bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们已经在48 LOC下编写了一个高性能的异步C++服务器。</p><h2 id="18ce" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">回显客户端</h2><p id="022f" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">echo客户机的代码与Echo服务器非常相似。</p><figure class="lg lh li lj fq lk"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="c7f6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意，我们覆盖了其他方法— <em class="jt"> readException </em>和<em class="jt">read of。很少有其他方法可以克服。如果需要处理特定的事件，只需重写相应的虚方法。</em></p><p id="3047" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是客户的管道工厂。除了<em class="jt"> EventBaseHandler </em>之外，它与服务器的管道工厂完全相同，后者处理从事件循环线程写入的数据。</p><figure class="lg lh li lj fq lk"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="a718" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是当它完全为客户端放置时的样子。</p><figure class="lg lh li lj fq lk"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="8025" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它在一个循环中从stdin读取输入，并将其写入管道，然后阻塞，直到处理完响应。它通过调用来阻止。从返回的未来中获取()。</p><h2 id="150a" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">摘要</h2><p id="585b" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">我已经展示了如何使用王乐用现代C++快速编写一个基本的高性能服务器。你现在应该知道了王乐的基础知识，它应该给你用C++编写自己的服务的信心。我强烈建议理解<em class="jt">服务抽象</em>，因为你可以用它来构建真正复杂的服务器。</p><blockquote class="jq jr js"><p id="c63a" class="ir is jt it b iu iv iw ix iy iz ja jb ju jd je jf jv jh ji jj jw jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is jt it b iu iv iw ix iy iz ja jb ju jd je jf jv jh ji jj jw jl jm jn jo hn dt translated">要了解更多信息，<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">请阅读我们的“关于”页面</a> , <a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">喜欢/在脸书给我们发消息</a>，或者简单地，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank">发推文/DM @HackerNoon。</a></p><p id="708a" class="ir is jt it b iu iv iw ix iy iz ja jb ju jd je jf jv jh ji jj jw jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>