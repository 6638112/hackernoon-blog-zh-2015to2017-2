<html>
<head>
<title>Usage of Reselect in a React-Redux Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React-Redux应用程序中使用重选</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/usage-of-reselect-in-a-react-redux-application-fcdca05cc00d?source=collection_archive---------1-----------------------#2017-09-12">https://medium.com/hackernoon/usage-of-reselect-in-a-react-redux-application-fcdca05cc00d?source=collection_archive---------1-----------------------#2017-09-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/2e8c937315bfbe928ed3fbe220a21680.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nM8pjTPURkHr9hS864wgLg.jpeg"/></div></div></figure><h1 id="b8fd" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated"><strong class="ak">为什么重选这么好</strong></h1><p id="a5d7" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">Reselect是一个流行的库，它提供了一种从React-Redux应用程序的存储中获取值的便捷方式。它的优点是它的记忆能力。您可以在文档中阅读所有这些内容。换句话说，当您使用<em class="ky"> createSelector() </em>函数时，它会记忆每个输入选择器的输出，并且仅当任何输入选择器改变其输出时才重新计算结果值。这里需要注意的重要一点是，reselect使用引用等式(===)来确定值的变化。</p><p id="44ad" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">作为使用记忆化的动机，文档建议提高性能，因为每次调用的重新计算可能非常昂贵。但是我们将在本文中看到，在React-Redux应用程序中，使用内存化的选择器有时是唯一的方法，即使计算非常便宜并且不影响性能。</p><h1 id="220c" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated"><strong class="ak">React-Redux连通分量如何工作</strong></h1><p id="7473" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">首先，我们来看看一个React-Redux应用程序是如何工作的。Redux所做的本质上是为我们的应用程序状态提供一个商店，并提供与商店通信的方法。其中一种方法是<em class="ky"> connect() </em>函数。在定制组件上调用<em class="ky"> connect() </em>之后，您会得到一个包装器，它将状态作为道具从存储传递到您的组件。这通过每次状态改变时调用的<em class="ky"> mapStateToProps() </em>函数来实现。</p><p id="b5af" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">在<em class="ky"> mapStateToProps() </em>产生重新计算的属性后，新属性比旧属性浅，如果它们不同，组件将被重新渲染。再次使用引用等式(===)来比较道具。</p><h1 id="5a4f" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">一个没有记忆的选择器会毁了你的一天</h1><p id="6251" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">这里我们可以利用一个例子。让我们创建一个名为商品列表的应用程序。app将基于<a class="ae le" href="https://github.com/react-boilerplate/react-boilerplate" rel="noopener ugc nofollow" target="_blank"><strong class="kc hv">react-boilerplate</strong></a>具有不可变状态(参见<a class="ae le" href="https://facebook.github.io/immutable-js/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc hv"> Immutable.js </strong> </a>)。</p><p id="63c3" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我们为我们的应用程序定义了一个状态:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="b1f1" class="lo jd hu lk b fv lp lq l lr ls">import {SET_GOODS, SET_SORTED, COUNT} from 'constants/index';<br/>import {fromJS} from 'immutable';</span><span id="b5bc" class="lo jd hu lk b fv lt lq l lr ls">const initialState = fromJS({<br/>goods: [<br/> {<br/>  name: 'tomatoes',<br/>  price: 3,<br/> },<br/> {<br/>  name: 'potatoes',<br/>  price: 2,<br/> },<br/> {<br/>  name: 'cucumbers',<br/>  price: 5,<br/> },<br/> {<br/>  name: 'salad',<br/>  price: 1,<br/> }<br/>],<br/>sorted: false,<br/>});</span><span id="80fe" class="lo jd hu lk b fv lt lq l lr ls">export default (<em class="ky">state </em>= initialState, <em class="ky">action</em>) =&gt; {<br/>switch (<em class="ky">action</em>.type) {<br/> case SET_SORTED: {<br/>  return <em class="ky">state</em>.set('sorted', <em class="ky">action</em>.sorted);<br/> }<br/> default: {<br/>  return initialState;<br/> }<br/>}<br/>}</span></pre><p id="3dd4" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">和几个组件:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="fa2f" class="lo jd hu lk b fv lp lq l lr ls">class GoodsList extends React.Component {<br/>render () {<br/> return (<br/>  &lt;<strong class="lk hv">div</strong>&gt;<br/>   &lt;<strong class="lk hv">ul</strong>&gt;<br/>   {this.props.goods.map((<em class="ky">g</em>, <em class="ky">i</em>) =&gt;<br/>   &lt;<strong class="lk hv">li </strong>key={<em class="ky">i</em>}&gt;{`${<em class="ky">g</em>.get('name')} - ${<em class="ky">g</em>.get('price')}$`}&lt;/<strong class="lk hv">li</strong>&gt;)}<br/>   &lt;/<strong class="lk hv">ul</strong>&gt;<br/>  &lt;/<strong class="lk hv">div</strong>&gt;<br/> )<br/>}<br/>}</span><span id="1e40" class="lo jd hu lk b fv lt lq l lr ls">const mapStateToProps = (<em class="ky">state</em>) =&gt; {<br/>return {<br/> goods: getGoods(<em class="ky">state</em>),<br/>};<br/>}</span><span id="c454" class="lo jd hu lk b fv lt lq l lr ls">const mapDispatchToProps = (<em class="ky">dispatch</em>) =&gt; bindActionCreators({<br/>count,<br/>}, <em class="ky">dispatch </em>;</span><span id="017e" class="lo jd hu lk b fv lt lq l lr ls">export default connect(mapStateToProps, mapDispatchToProps)(GoodsList);</span></pre></div><div class="ab cl lu lv hc lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hn ho hp hq hr"><pre class="lj lk ll lm aw ln dt"><span id="d9f4" class="lo jd hu lk b fv mb mc md me mf lq l lr ls">class Buttons extends React.Component {<br/>render () {<br/> return (<br/>  &lt;<strong class="lk hv">div </strong>style={{display: 'flex'}}&gt;<br/>   &lt;<strong class="lk hv">button<br/>   </strong>style={buttonStyle}<br/>   onClick={() =&gt; this.props.setSorted(true)}&gt;<br/>     <strong class="lk hv">Show Sorted<br/>   </strong>&lt;/<strong class="lk hv">button</strong>&gt;<br/>    &lt;<strong class="lk hv">button<br/>    </strong>style={buttonStyle}<br/>    onClick={() =&gt; this.props.setSorted(false)}&gt;<br/>      <strong class="lk hv">Show Unsorted<br/>   </strong>&lt;/<strong class="lk hv">button</strong>&gt;<br/>  &lt;/<strong class="lk hv">div</strong>&gt;<br/> )<br/>}<br/>}</span><span id="cf1f" class="lo jd hu lk b fv lt lq l lr ls">const mapStateToProps = (<em class="ky">state</em>) =&gt; {<br/>return {}<br/>}</span><span id="b2f7" class="lo jd hu lk b fv lt lq l lr ls">const mapDispatchToProps = (<em class="ky">dispatch</em>) =&gt; bindActionCreators({<br/>setSorted,<br/>}, <em class="ky">dispatch</em>);</span><span id="4d41" class="lo jd hu lk b fv lt lq l lr ls">export default connect(mapStateToProps, mapDispatchToProps)(Buttons);</span></pre><p id="9702" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我们还有一个包含我们组件的页面:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="0fe5" class="lo jd hu lk b fv lp lq l lr ls"> export default class HomePage extends React.PureComponent {<br/> render() {<br/>  return (<br/>   &lt;<strong class="lk hv">div</strong>&gt;<br/>    &lt;<strong class="lk hv">GoodsList</strong>/&gt;<br/>    &lt;<strong class="lk hv">Buttons</strong>/&gt;<br/>   &lt;/<strong class="lk hv">div</strong>&gt;<br/>  );<br/>}<br/>}</span></pre><p id="0192" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">该应用程序只呈现商品列表，要么按价格排序(当用户单击“显示排序”按钮时)，要么未排序(默认情况下，当用户单击“显示未排序”按钮时)。在状态中，我们有<em class="ky">商品</em>和<em class="ky">排序</em>商品，前者是我们想要显示的商品列表，后者告诉我们该列表是应该排序还是不排序。</p><p id="ea35" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我们现在唯一需要做的就是定义一个选择器。让我们首先尝试一个未记忆的选择器。基本上，这只是一个函数，就像这样:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="5d11" class="lo jd hu lk b fv lp lq l lr ls"> export const getGoods = (<em class="ky">state</em>) =&gt; {<br/> const list = <em class="ky">state</em>.getIn(['main', 'goods']);<br/> const sorted = <em class="ky">state</em>.getIn(['main', 'sorted']);</span><span id="c5a4" class="lo jd hu lk b fv lt lq l lr ls"> return sorted ? list.sort((<em class="ky">a</em>, <em class="ky">b</em>) =&gt; {<br/>   const aPrice = <em class="ky">a</em>.get('price');<br/>   const bPrice = <em class="ky">b</em>.get('price');<br/>   if (aPrice &lt; bPrice) { return -1; }<br/>   if (aPrice &gt; bPrice) { return 1; }<br/>   if (aPrice === bPrice) { return 0; }<br/>}) : list;<br/>}</span></pre><p id="4f8f" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">根据排序后的的<em class="ky">的值，该选择器要么只返回该州的商品列表，要么在返回之前按价格排序。让我们仔细看看这里发生了什么。不可变的. js文档说:“sort()总是返回一个新的实例，即使原始实例已经被排序了”。这意味着，我们排序后的商品列表将永远不会与之前排序的商品列表相同。GoodsList组件的<em class="ky">商品</em>属性的引用等式将永远不成立，这意味着该组件将在每次状态更改时重新呈现，即使这种更改不会以任何方式影响商品列表。</em></p><p id="55dc" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">虽然这显然是一种错误的创建选择器的方式，但是到目前为止看起来并没有什么大不了的。对于我们只有四个条目的列表，选择器中的计算非常便宜，不会有任何明显的性能下降。但是如果我们需要改变组件生命周期中的状态呢？正如<a class="ae le" href="https://facebook.github.io/react/docs/react-component.html#componentwillreceiveprops" rel="noopener ugc nofollow" target="_blank"> <strong class="kc hv"> React文档</strong> </a>所建议的，我们将在componentWillReceiveProps方法中完成。比方说，出于某种原因，我们需要计算GoodsList收到道具的次数。因此，我们将componentWillReceiveProps添加到GoodsList组件:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="f13c" class="lo jd hu lk b fv lp lq l lr ls">componentWillReceiveProps = (<em class="ky">nextProps</em>) =&gt; {<br/>this.<em class="ky">props</em>.count();<br/>}</span></pre><p id="325c" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这里的<em class="ky"> count </em>是一个发送到store的动作。</p><p id="0c80" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">减速器看起来像这样:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="80d7" class="lo jd hu lk b fv lp lq l lr ls">import {SET_GOODS, SET_SORTED, COUNT} from 'constants/index';<br/>import {fromJS} from 'immutable';</span><span id="2e89" class="lo jd hu lk b fv lt lq l lr ls">const initialState = fromJS({<br/>goods: [...],<br/>sorted: false,<br/>count: 0,<br/>});</span><span id="20ea" class="lo jd hu lk b fv lt lq l lr ls">export default (<em class="ky">state </em>= initialState, <em class="ky">action</em>) =&gt; {<br/>switch (<em class="ky">action</em>.type) {<br/> case SET_SORTED: {<br/>   return <em class="ky">state</em>.set('sorted', <em class="ky">action</em>.sorted);<br/> }<br/> case COUNT: {<br/>   return <em class="ky">state</em>.set('count', <em class="ky">state</em>.get('count') + 1);<br/> }<br/> default: {<br/>   return initialState;<br/> }<br/>}<br/>}</span></pre><p id="6cf9" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">当用户单击“显示已排序”时，将触发以下操作序列:</p><ol class=""><li id="1da8" class="mg mh hu kc b kd kz kh la kl mi kp mj kt mk kx ml mm mn mo dt translated"><em class="ky">值为<em class="ky">真</em>的SET_SORTED </em>动作被分派到存储。</li><li id="97bd" class="mg mh hu kc b kd mp kh mq kl mr kp ms kt mt kx ml mm mn mo dt translated">排序后的<em class="ky">的值</em>在状态下改变。</li><li id="c287" class="mg mh hu kc b kd mp kh mq kl mr kp ms kt mt kx ml mm mn mo dt translated"><em class="ky"> GoodsList </em>连接组件调用<em class="ky"> mapStateToProps </em>。</li><li id="370b" class="mg mh hu kc b kd mp kh mq kl mr kp ms kt mt kx ml mm mn mo dt translated">选择器<em class="ky"> getGoods </em>从<em class="ky"> mapStateToProps </em>中调用。</li><li id="7029" class="mg mh hu kc b kd mp kh mq kl mr kp ms kt mt kx ml mm mn mo dt translated">选择器返回排序后的列表，该列表不等于已经传递给<em class="ky"> GoodsList </em>的列表。</li><li id="9d77" class="mg mh hu kc b kd mp kh mq kl mr kp ms kt mt kx ml mm mn mo dt translated">当<em class="ky"> mapStateToProps </em>返回的属性不浅等于组件先前的属性时，React开始<em class="ky"> GoodsList </em>重新渲染。</li><li id="653b" class="mg mh hu kc b kd mp kh mq kl mr kp ms kt mt kx ml mm mn mo dt translated"><em class="ky"> GoodsList </em>生命周期方法<em class="ky">componentWillReceiveProps</em>被调用。</li><li id="9cb3" class="mg mh hu kc b kd mp kh mq kl mr kp ms kt mt kx ml mm mn mo dt translated">动作<em class="ky">计数</em>被分派到商店。</li><li id="2af0" class="mg mh hu kc b kd mp kh mq kl mr kp ms kt mt kx ml mm mn mo dt translated">计数<em class="ky">的值</em>在状态下改变。</li><li id="9351" class="mg mh hu kc b kd mp kh mq kl mr kp ms kt mt kx ml mm mn mo dt translated">再次重复第3-9点。</li><li id="7935" class="mg mh hu kc b kd mp kh mq kl mr kp ms kt mt kx ml mm mn mo dt translated">然后再来一次。</li><li id="7eef" class="mg mh hu kc b kd mp kh mq kl mr kp ms kt mt kx ml mm mn mo dt translated">然后…嗯，永远不会停止。我们有一个无尽的循环。</li></ol><p id="0b3d" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这种对收到的道具进行计数的情况可能看起来有点虚假，但这可能发生在现实生活中。例如，当你为一个<a class="ae le" href="http://redux-form.com/" rel="noopener ugc nofollow" target="_blank"><strong class="kc hv"/></a>设置初始值时，一个动作被分派到store。或者，如果您需要在状态中存储路由参数，您可以将它们设置为一个对象，这将导致状态发生变化，您可能会在componentWillReceiveProps()中这样做，因为路由可能会在不卸载组件的情况下发生变化。这两种情况都有效地表现为好像您在componentWillReceiveProps()中计算收到的属性。</p><h1 id="2fac" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated"><strong class="ak">重选可能对你有帮助也可能没有</strong></h1><p id="51d9" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">我们可以很容易地通过重新选择来解决这个问题。这个选择器在我们的例子中工作得很好:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="f9c1" class="lo jd hu lk b fv lp lq l lr ls">import {createSelector} from 'reselect';</span><span id="979d" class="lo jd hu lk b fv lt lq l lr ls">const getList = (<em class="ky">state</em>) =&gt; <em class="ky">state</em>.getIn(['main', 'goods']);<br/>const getSorted = (<em class="ky">state</em>) =&gt; <em class="ky">state</em>.getIn(['main', 'sorted']);</span><span id="b244" class="lo jd hu lk b fv lt lq l lr ls">export const getGoods = createSelector(<br/>getList,<br/>getSorted,<br/>(<em class="ky">list</em>, <em class="ky">sorted</em>) =&gt; {<br/> return <em class="ky">sorted </em>? <em class="ky">list</em>.sort((<em class="ky">a</em>, <em class="ky">b</em>) =&gt; {<br/>    const aPrice = <em class="ky">a</em>.get('price');<br/>    const bPrice = <em class="ky">b</em>.get('price');<br/>    if (aPrice &lt; bPrice) { return -1; }<br/>    if (aPrice &gt; bPrice) { return 1; }<br/>    if (aPrice === bPrice) { return 0; }<br/>  }) : <em class="ky">list</em>;<br/>}<br/>)</span></pre><p id="ceb7" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这里，在<em class="ky"> getList </em>或<em class="ky"> getSorted </em>改变它们在<em class="ky"> COUNT </em>动作中没有的值之前，不会调用转换函数。相反，<em class="ky"> getGoods </em>选择器只返回先前计算的值，该值显然等于已经传递给<em class="ky"> GoodsList </em>组件的列表。React不会尝试第二次重新呈现组件，循环会中断。</p><p id="b26f" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">然而，有一个危险:很容易意外地使重选选择器失去记忆。</p><p id="a16d" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">例如，出于某种原因，您可能希望在组件中使用JavaScript数组，而不是不可变列表。但是该选择器将再次导致在“显示已排序的”点击时开始无休止的循环:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="799f" class="lo jd hu lk b fv lp lq l lr ls">import {createSelector} from 'reselect';</span><span id="c383" class="lo jd hu lk b fv lt lq l lr ls">const getList = (<em class="ky">state</em>) =&gt; <em class="ky">state</em>.getIn(['main', 'goods']).toJS();<br/>const getSorted = (<em class="ky">state</em>) =&gt; <em class="ky">state</em>.getIn(['main', 'sorted']);</span><span id="6b6b" class="lo jd hu lk b fv lt lq l lr ls">export const getGoods = createSelector(<br/>getList,<br/>getSorted,<br/>(<em class="ky">list</em>, <em class="ky">sorted</em>) =&gt; {<br/> return <em class="ky">sorted </em>? <em class="ky">list</em>.sort((<em class="ky">a</em>, <em class="ky">b</em>) =&gt; <em class="ky">a</em>.price - <em class="ky">b</em>.price) : <em class="ky">list</em>;<br/>}<br/>)</span></pre><p id="9d90" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">虽然<em class="ky"> getGoods </em>在这里是一个记忆化的选择器，但它每次都从getList获得不同的输入。一般来说，从状态中获取值的选择器不应该做任何其他事情，因为它们没有被记忆。</p><p id="94f4" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">另一个可能的错误是咖喱选择器。有时您希望创建这样的选择器，以防将来需要将参数传递给选择器:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="4675" class="lo jd hu lk b fv lp lq l lr ls">export const getGoods = () =&gt; createSelector(...)</span></pre><p id="0b69" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这样写<em class="ky"> mapStateToProps </em>很有诱惑力:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="7f8c" class="lo jd hu lk b fv lp lq l lr ls">const mapStateToProps = (<em class="ky">state</em>) =&gt; {<br/>return {<br/>  goods: getGoods()(<em class="ky">state</em>),<br/>};<br/>}</span></pre><p id="9c5e" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">但是这里我们在每次调用<em class="ky"> mapStateToProps </em>时创建一个新的选择器实例。基本上，我们只是放弃了选择器的记忆能力，因为每个新实例都会重新计算它的值，而这个值不等于另一个实例计算的值。</p><p id="2483" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这种类型的bug非常烦人，因为当你创建了一个bug，并在以后的多次提交中偶然发现它时，你通常不会注意到。谢天谢地，<em class="ky"> git平分</em>可以帮你找到哪里出了问题。</p><h1 id="91b6" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated"><strong class="ak">让你的生活更美好的小贴士</strong></h1><p id="3f67" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">总而言之，我将指定我在使用Reselect库时为自己获得的一些技巧。</p><ol class=""><li id="fabf" class="mg mh hu kc b kd kz kh la kl mi kp mj kt mk kx ml mm mn mo dt translated">如果它以任何方式从状态转换值，总是使用Reselect中的<em class="ky"> createSelector() </em>来创建选择器。</li><li id="1d5a" class="mg mh hu kc b kd mp kh mq kl mr kp ms kt mt kx ml mm mn mo dt translated">避免咖喱选择器。一般来说，你不需要它们。您可以使用选择器的第二个参数传递您需要的所有参数。事实上，我能想到的唯一需要curried选择器的情况是在<a class="ae le" href="https://github.com/reactjs/reselect#sharing-selectors-with-props-across-multiple-components" rel="noopener ugc nofollow" target="_blank"> <strong class="kc hv">文档</strong> </a> <strong class="kc hv">中描述的。</strong></li><li id="ed77" class="mg mh hu kc b kd mp kh mq kl mr kp ms kt mt kx ml mm mn mo dt translated">从生命周期功能向商店分派动作时要小心。一般来说，避免这样做。但如果你不得不，也许在派遣一个动作之前手动比较道具是个好主意。</li></ol><p id="c06b" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">不要使用<code class="eh mu mv mw lk b">state =&gt; state</code>或<code class="eh mu mv mw lk b">state =&gt; state.get(‘main’)</code>这样的选择器作为输入选择器。如果您访问状态的大部分，这些部分很可能会随着每个动作而改变。如果你真的需要，你可能不得不自己记忆转换函数。这可以通过使用来自<a class="ae le" href="https://lodash.com/docs/4.17.4#memoize" rel="noopener ugc nofollow" target="_blank"> <strong class="kc hv"> Lodash </strong> </a>或<a class="ae le" href="http://ramdajs.com/docs/#memoize" rel="noopener ugc nofollow" target="_blank"> <strong class="kc hv"> Ramda </strong> </a>或其他东西的<em class="ky"> memoize() </em>来完成。</p><p id="94bb" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">此外，如果你想使用选择器并模拟一些其他情况，你可以在GitHub  上找到我在这里使用的例子。</p></div><div class="ab cl lu lv hc lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hn ho hp hq hr"><div class="lf lg lh li fq mx"><a href="https://hackernoon.com/missing-part-of-redux-saga-experience-1d2d169ba765" rel="noopener  ugc nofollow" target="_blank"><div class="my ab ej"><div class="mz ab na cl cj nb"><h2 class="bd hv fv z el nc eo ep nd er et ht dt translated">Redux Saga体验中缺失的部分</h2><div class="ne l"><h3 class="bd b fv z el nc eo ep nd er et ek translated">Redux saga是应用程序和redux store之间的中间件，由redux actions处理。这意味着，它可以…</h3></div><div class="nf l"><p class="bd b gc z el nc eo ep nd er et ek translated">hackernoon.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl ja mx"/></div></div></a></div><div class="nm nn fm fo no mx"><a href="https://hackernoon.com/using-normalizr-to-organize-data-in-stores-practical-guide-82fa061b60fb" rel="noopener  ugc nofollow" target="_blank"><div class="my ab ej"><div class="mz ab na cl cj nb"><h2 class="bd hv fv z el nc eo ep nd er et ht dt translated">使用Normalizr组织商店中的数据——实用指南</h2><div class="ne l"><h3 class="bd b fv z el nc eo ep nd er et ek translated">在对Normalizr的工作结果应用一些简单的操作之后，我们得到了可以存储的数据</h3></div><div class="nf l"><p class="bd b gc z el nc eo ep nd er et ek translated">hackernoon.com</p></div></div><div class="ng l"><div class="np l ni nj nk ng nl ja mx"/></div></div></a></div><div class="nm nn fm fo no mx"><a href="https://hackernoon.com/using-normalizr-to-organize-data-in-store-part-2-d9646133b7df" rel="noopener  ugc nofollow" target="_blank"><div class="my ab ej"><div class="mz ab na cl cj nb"><h2 class="bd hv fv z el nc eo ep nd er et ht dt translated">使用Normalizr组织存储中的数据。第二部分</h2><div class="ne l"><h3 class="bd b fv z el nc eo ep nd er et ek translated">文章的第二部分讲述了如何使用Normalizr来组织商店中的数据。</h3></div><div class="nf l"><p class="bd b gc z el nc eo ep nd er et ek translated">hackernoon.com</p></div></div><div class="ng l"><div class="nq l ni nj nk ng nl ja mx"/></div></div></a></div><div class="nm nn fm fo no mx"><a href="https://hackernoon.com/how-to-stop-using-callbacks-and-start-living-1e5ed92e68e8" rel="noopener  ugc nofollow" target="_blank"><div class="my ab ej"><div class="mz ab na cl cj nb"><h2 class="bd hv fv z el nc eo ep nd er et ht dt translated">如何停止使用回调，开始生活</h2><div class="ne l"><h3 class="bd b fv z el nc eo ep nd er et ek translated">Javascript有两种处理异步任务的主要方式——回调和承诺。一般来说，承诺是…</h3></div><div class="nf l"><p class="bd b gc z el nc eo ep nd er et ek translated">hackernoon.com</p></div></div><div class="ng l"><div class="nr l ni nj nk ng nl ja mx"/></div></div></a></div><p id="d7e8" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">作者:<a class="ae le" href="https://github.com/iPhaeton" rel="noopener ugc nofollow" target="_blank"> Ilya Bohaslauchyk </a></p></div></div>    
</body>
</html>