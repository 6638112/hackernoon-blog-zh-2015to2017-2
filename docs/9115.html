<html>
<head>
<title>A Modern Home Karaoke System built with YouTube API, WebSocket, Redis, QR codes, and a Chrome extension/WebAudio</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用YouTube API、WebSocket、Redis、QR码和Chrome扩展/WebAudio构建的现代家庭卡拉ok系统</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-modern-home-karaoke-system-built-with-youtube-api-websocket-redis-qr-codes-and-a-chrome-dc8c23a52985?source=collection_archive---------6-----------------------#2017-12-27">https://medium.com/hackernoon/a-modern-home-karaoke-system-built-with-youtube-api-websocket-redis-qr-codes-and-a-chrome-dc8c23a52985?source=collection_archive---------6-----------------------#2017-12-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/53b87e40c67b46b9f649df57e99901bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_k6f5Ew5TOGNVzN-mSoL1g.jpeg"/></div></div></figure><div class=""/><p id="6c98" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig"><em class="ka">2020年11月更新</em> </strong> <em class="ka"> : Youtube在今年夏天关闭了对卡拉Karaoke.house和Singk.net的API访问，在审查后认为这不符合他们的服务条款。因此，这些网站将在今年年底永久下线。这是一个很好的运行，有一小部分狂热的用户，而它持续！</em></p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><p id="6b54" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我既是一名软件工程师，也是一名歌手。像大多数歌手一样，我以各种方式从事唱歌，像在乐队演奏，去卡拉ok。</p><figure class="kj kk kl km fq hw fe ff paragraph-image"><div class="fe ff ki"><img src="../Images/c7918cc40475ab74b147be722f6a67ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*WRD-nOoP0dZk-nJuS357PA.png"/></div><figcaption class="kn ko fg fe ff kp kq bd b be z ek">YouTube search results for “KTV”</figcaption></figure><p id="9267" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">早在2012年，我就注意到很多YouTube用户上传中国卡拉ok音乐视频(也称为KTV视频)到YouTube上，不管有没有许可证。这让我开始思考和尝试——我可以在家里用YouTube上的内容唱卡拉ok，但是YouTube的界面不是为卡拉ok设计的，所以有很多不便。事实证明，有效地选择歌曲、移动队列中的歌曲、跳过曲目，甚至调整乐器或原声的音频都很困难。(大部分中文KTV视频利用左右声道，一个是原声，一个是器乐专用。您必须调整Windows或Mac的音量控制设置，只输出左声道或右声道，以获得想要的音频。)</p><p id="4717" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt">This was when I first had the idea to create a home karaoke system using modern web technologies — using the YouTube API to create a custom video player, and a layer built around it with functionality to work like the software you’d find at karaoke studios. Around late 2013, I finally began working on a prototype. This is the beginning of what would become <a class="ae kr" href="http://singk.net" rel="noopener ugc nofollow" target="_blank"><strong class="je ig">SingK.net</strong></a> (唱K網; Chinese version) and <a class="ae kr" href="http://karaoke.house" rel="noopener ugc nofollow" target="_blank"><strong class="je ig">Karaoke.house</strong></a> (English version).</p><p id="352c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个爱好项目可能是我做过的技术上更加多样化的项目之一；经历了两个版本和一些实验原型。在这篇文章中，我想介绍一下技术，讨论一些架构设计和样本代码。</p><h2 id="6917" class="ks kt if bd ku kv kw kx ky kz la lb lc jn ld le lf jr lg lh li jv lj lk ll lm dt translated">产品理念</h2><figure class="kj kk kl km fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ln"><img src="../Images/6088ab59e581ed103919ea324c6e1265.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eiJSoOQ1ClZ3Jj3nxVGZiA.jpeg"/></div></div></figure><p id="40af" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">基本想法是让它像你在亚洲卡拉ok厅找到的软件一样工作。电视屏幕播放音乐视频(底部有歌词作为字幕)，独立的电脑(带遥控器)用于搜索歌曲、跳过曲目、暂停、重启等。</p><p id="69a5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个想法是在家里复制这种体验:使用电脑屏幕(理想情况下连接到客厅的电视，就像在媒体PC设置中一样)播放视频，使用智能手机(或平板电脑)作为“遥控器”，结合界面来搜索歌曲。</p><p id="2ed4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">具体的特征要求是:1)移动控制需要实时影响计算机上的视频播放器(即，单独的设备)，并且这包括从遥控器排队歌曲以在计算机上播放它们，以及像暂停/播放这样的视频回放控制功能；2)能够调整视频上的左/右音频通道。</p><h1 id="c155" class="lo kt if bd ku lp lq lr ky ls lt lu lc lv lw lx lf ly lz ma li mb mc md ll me dt translated">V1: YouTube Flash API，Redis(2013–2014)</h1><p id="c440" class="pw-post-body-paragraph jc jd if je b jf mf jh ji jj mg jl jm jn mh jp jq jr mi jt ju jv mj jx jy jz hn dt translated">回到2013年，Flash还没有完全死亡。由于当时在脸书游戏公司工作，我碰巧也有一些动作脚本编码的背景。我相信内置这个是正确的技术选择，原因如下:</p><ol class=""><li id="3db1" class="mk ml if je b jf jg jj jk jn mm jr mn jv mo jz mp mq mr ms dt translated">更好的声音转换功能集。我需要能够只输出左声道或右声道。当时浏览器并不广泛支持Javascript的WebAudio。Flash毫不妥协地提供了这一点。此外，将WebAudio与YouTube的Javascript player API一起使用将会是一个问题，我们将在稍后的V2会议上讨论这个问题。</li><li id="62cf" class="mk ml if je b jf mt jj mu jn mv jr mw jv mx jz mp mq mr ms dt translated">WebSocket在2013年仍是一项相对较新的技术，得到的支持较少。为了实现两个设备之间的实时通信，包括让web浏览器客户端<em class="ka">同步接收</em>数据，我需要它来保持与服务器的开放套接字连接。如果没有WebSocket，那么很大程度上就是在Flash中使用套接字连接。</li><li id="307a" class="mk ml if je b jf mt jj mu jn mv jr mw jv mx jz mp mq mr ms dt translated">YouTube当时仍然为视频播放器提供Flash API，使得整个项目成为可能。</li></ol><p id="d4d3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了完成上面的#2，我将直接从Flash客户端打开一个到Redis服务器的套接字连接(打开服务器防火墙上的Redis端口)，并利用<a class="ae kr" href="https://redis.io/topics/pubsub" rel="noopener ugc nofollow" target="_blank">Redis’<strong class="je ig">pub sub</strong></a>功能，该功能让客户端<strong class="je ig"> sub </strong>编写并监听服务器执行的命令<strong class="je ig"> pub </strong>。</p><figure class="kj kk kl km fq hw fe ff paragraph-image"><div class="fe ff my"><img src="../Images/9bb526a3bf5dc4d5a6b0d2dccd09db2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*m1EA3Y3tpNV7LPUYpocmVg.png"/></div></figure><p id="a6c6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，从安全的角度来看，向公众开放Redis服务器听起来很疯狂，但是Redis实际上有一些特性可以帮助做到这一点。使用<code class="eh mz na nb nc b">rename-command</code>配置(如此处的<a class="ae kr" href="https://redis.io/topics/security" rel="noopener ugc nofollow" target="_blank">所示</a>，您可以禁用那个面向公众的Redis实例上的每个命令，除了<code class="eh mz na nb nc b">PUBLISH</code>、<code class="eh mz na nb nc b">SUBSCRIBE</code>和<code class="eh mz na nb nc b">QUIT</code>。这也有助于运行这个Redis实例，而不是关闭默认端口6379，这将大大减少扫描程序/机器人找到你的开放Redis实例。</p><p id="abb1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦这些都设置好了，运行在计算机网页上的用户Flash客户端就可以实时监听来自服务器的命令。(当用户在页面上时，连接始终保持打开状态)</p><p id="d764" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">之后，所需要的就是移动客户端(移动web即普通网页)向网络服务器发出发布命令的请求。要发出播放/暂停、改变音频频道、排列歌曲等命令，它只需像其他网页一样用Javascript向服务器发出AJAX请求。完整的架构图如下所示:</p><figure class="kj kk kl km fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nd"><img src="../Images/bf7ddc46c009cdfb2acb70d9ee55a5ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3G6E_1sUsZmk8wr3pukWNg.png"/></div></div></figure><h2 id="c3d6" class="ks kt if bd ku kv kw kx ky kz la lb lc jn ld le lf jr lg lh li jv lj lk ll lm dt translated">问题:闪光的终结</h2><p id="6672" class="pw-post-body-paragraph jc jd if je b jf mf jh ji jj mg jl jm jn mh jp jq jr mi jt ju jv mj jx jy jz hn dt translated">众所周知，苹果决定不支持iPhone上的Flash。现在，这实际上不会影响我们，因为我们在桌面上运行我们的视频播放器。然而，闪死的趋势是非常真实的。在我使用上面的架构完成这个项目的V1后不久，YouTube也决定结束对其Flash API的支持。所有使用YouTube的Flash API的开发者都应该迁移到新的Javascript API播放器。</p><p id="16f7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这给我带来了一些问题，因为我选择Flash不仅仅是因为YouTube播放器，还有其他几个原因，如上所述。YouTube在2015年左右否决了Flash API，并在2016年的某个时候完全停止了它的工作。这时候app已经坏了。</p><p id="eb2f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我现在需要将这个应用程序的视频播放器部分迁移到YouTube JS API。为此，我需要重写两个主要特性:</p><ol class=""><li id="8726" class="mk ml if je b jf jg jj jk jn mm jr mn jv mo jz mp mq mr ms dt translated">与Redis保持开放的套接字连接。</li><li id="cb5b" class="mk ml if je b jf mt jj mu jn mv jr mw jv mx jz mp mq mr ms dt translated">Flash中声音转换(左/右音频通道隔离/选择)必须用不同的技术重做。</li></ol><p id="eaa2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">幸运的是，当我从事这项工作时，已经是2017年了，WebSocket被所有现代浏览器广泛采用。</p><h1 id="2563" class="lo kt if bd ku lp lq lr ky ls lt lu lc lv lw lx lf ly lz ma li mb mc md ll me dt translated">V2: YouTube JS API、WebSocket、Redis、二维码和WebAudio/Chrome扩展(2017)</h1><p id="c145" class="pw-post-body-paragraph jc jd if je b jf mf jh ji jj mg jl jm jn mh jp jq jr mi jt ju jv mj jx jy jz hn dt translated">因为需要改变，V2不仅仅是视频播放器客户端从Actionscript到Javascript的重写，也是对其架构的重新设计。</p><p id="a8c4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要从Flash  Redis  Web服务器架构转移到WebSocket架构，有两种架构设计方案可以实现实时通信:</p><figure class="kj kk kl km fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ne"><img src="../Images/855c00769aadc1cf4085576965704e73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zNGYxerL1DMcvlJxDTJueA.png"/></div></div></figure><p id="f0da" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">乍一看，选项1在架构上看起来更简单；但是它实际上在实施中提出了更多的挑战:</p><ol class=""><li id="c2dd" class="mk ml if je b jf jg jj jk jn mm jr mn jv mo jz mp mq mr ms dt translated">WebSocket服务器需要更多的逻辑:它需要能够区分哪个是移动客户端，哪个是桌面客户端；以便监听来自移动设备的命令，并将它们发送给桌面客户端。</li><li id="e2dc" class="mk ml if je b jf mt jj mu jn mv jr mw jv mx jz mp mq mr ms dt translated">它还要求移动客户端打开一个WebSocket连接。在这个应用中，移动客户端是一个移动web应用。在演唱期间，用户的手机可以进入和退出待机/屏幕关闭模式，甚至可以进入和退出网络浏览器本身。这使得维护WebSocket连接变得古怪和迟缓；在最坏的情况下，当按下按钮什么也做不了时，它会产生一个可怜的UX。</li></ol><p id="f386" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">选项2，虽然在架构图中看起来更复杂，但实际上与我们最初的设计有更多的相似之处，使得重写V1的实现更容易，范围更小。</p><ol class=""><li id="d1eb" class="mk ml if je b jf jg jj jk jn mm jr mn jv mo jz mp mq mr ms dt translated">移动客户端的工作方式完全相同:它不需要了解WebSocket服务器，只需通过常规的AJAX请求向web服务器发送命令。web服务器也以完全相同的方式工作，它通过publish(pubsub的pub部分)向Redis发送命令。</li><li id="2f63" class="mk ml if je b jf mt jj mu jn mv jr mw jv mx jz mp mq mr ms dt translated">与Flash客户端相比，新的Javascript桌面web客户端的主要变化是，它现在不是直接连接到Redis，而是连接到WebSocket服务器。</li><li id="d0f0" class="mk ml if je b jf mt jj mu jn mv jr mw jv mx jz mp mq mr ms dt translated">这使得我们的WebSocket服务器非常简单:只有一种类型的客户端可以连接到它；它只能对客户端做一种事情(向它发送命令)。它确实需要打开与Redis服务器的连接，但这相对来说并不重要。</li><li id="237c" class="mk ml if je b jf mt jj mu jn mv jr mw jv mx jz mp mq mr ms dt translated">尽管我们仍然使用Redis，但我们现在可以从公众中关闭我们的Redis服务器(关闭防火墙中的那个端口)。这是因为现在只有WebSocket服务器需要与它对话，而不是像以前一样需要所有的Flash客户端。</li></ol><p id="c579" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">出于以上原因，我选择了架构选项2。</p><h2 id="094a" class="ks kt if bd ku kv kw kx ky kz la lb lc jn ld le lf jr lg lh li jv lj lk ll lm dt translated">nodejs:web socket服务器的完美技术</h2><p id="9b75" class="pw-post-body-paragraph jc jd if je b jf mf jh ji jj mg jl jm jn mh jp jq jr mi jt ju jv mj jx jy jz hn dt translated">该项目的web服务器后端一直是PHP。在这个项目之前，我已经使用它10多年了，在我开始这个项目的2013年，PHP仍然相对流行，而nodejs作为web服务器后端还不太普及。</p><p id="8fe4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，当需要编写WebSocket服务器时，我自然会尝试坚持使用PHP，为同一个项目保持相同/较小的技术堆栈，而不必在我的服务器上安装新软件。</p><p id="c28e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我很快发现，由于PHP的非异步特性，PHP中的WebSocket库在您所能做的事情方面受到了相当大的限制——web socket服务器的异步方面通常在一个事件循环中处理，这使得在同一个服务器程序代码中很难有一个完全独立的异步方面(例如，一个用于连接Redis并使用<code class="eh mz na nb nc b">SUBSCRIBE</code>监听命令，当命令到来时触发回调)。这是当我决定PHP不是正确的<a class="ae kr" href="https://hackernoon.com/tagged/tool" rel="noopener ugc nofollow" target="_blank">工具</a>的时候。</p><p id="569c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这已经是2017年了，nodejs作为一个开发平台已经非常成熟了。不仅有大量的npm包可用于任何事情，nodejs的异步特性也使它成为这个用例的完美工具。</p><p id="4a9f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用<a class="ae kr" href="https://www.npmjs.com/package/ws" rel="noopener ugc nofollow" target="_blank"> ws </a>和<a class="ae kr" href="https://www.npmjs.com/package/redis" rel="noopener ugc nofollow" target="_blank"> redis </a> npm包，WebSocket服务器的nodejs代码可以归结为:</p><pre class="kj kk kl km fq nf nc ng nh aw ni dt"><span id="d12f" class="ks kt if nc b fv nj nk l nl nm">const WebSocket = require('ws'),<br/>  Redis = require('redis');</span><span id="a665" class="ks kt if nc b fv nn nk l nl nm">const redis = Redis.createClient({host: 'localhost', port: 6379});</span><span id="d13f" class="ks kt if nc b fv nn nk l nl nm">/**<br/> * Listens for Redis messages<br/> */<br/>redis.on("message", function(channel, message) {<br/>  // parse message from web server that came through redis pubsub<br/>  // then issue a send() command to a websocket connection<br/>});</span><span id="ac3c" class="ks kt if nc b fv nn nk l nl nm">const websocketServer = new WebSocket.Server({ port: 8080 });</span><span id="8d2b" class="ks kt if nc b fv nn nk l nl nm">websocketServer.on('connection', function connection(client) {<br/>  // store the connected client for making send() to later<br/>});</span></pre><p id="72d3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当然，还有一些事情，比如日志记录、错误处理和清理连接。此外，使用<code class="eh mz na nb nc b">ws</code>包，您将希望手动保持心跳以保持连接。但是最终，整个WebSocket服务器归结为一个文件中大约100行nodejs代码。</p><h2 id="cdc8" class="ks kt if bd ku kv kw kx ky kz la lb lc jn ld le lf jr lg lh li jv lj lk ll lm dt translated">登录:二维码</h2><p id="e92c" class="pw-post-body-paragraph jc jd if je b jf mf jh ji jj mg jl jm jn mh jp jq jr mi jt ju jv mj jx jy jz hn dt translated">正如您现在已经猜到的，让整个架构工作的前提是让Javascript桌面web客户端和移动客户端登录到同一个帐户。</p><p id="b002" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">完成这项工作很简单:因为您使用用户名和密码登录，所以您只需在桌面端和移动端输入相同的用户名/密码。之后，从手机发出的每一个命令都会转到正确的桌面客户端(同一个账号)。这是自V1以来的运作方式。</p><p id="5e5b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，众所周知，在移动设备上输入密码并不是一件愉快的UX。</p><p id="1df5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">经过一番思考，我想到这可能是二维码的一个完美用例。要使用<a class="ae kr" href="http://karaoke.house" rel="noopener ugc nofollow" target="_blank">卡拉ok屋</a>，你<em class="ka">总是</em>必须同时登陆桌面和移动。你几乎总是先登录桌面，然后用同一个账户登录手机。为什么不在桌面登录后生成一个二维码图像，让移动设备扫描后登录，而不需要输入任何东西？(对于那些熟悉Whatsapp的人来说，Whatsapp Web的工作方式与此类似，但却是相反的——你首先登录手机，然后用手机扫描web.whatsapp.com上的二维码，让桌面Web客户端登录到与手机相同的账户。)</p><figure class="kj kk kl km fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff no"><img src="../Images/e9134e23b58ec87f706c16ae2ac95f58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rng8icczbVAxPC16Ohz-sw.png"/></div></div><figcaption class="kn ko fg fe ff kp kq bd b be z ek">The first screen you see as you log in on desktop</figcaption></figure><p id="4dd6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在大多数语言中，生成QR码相对容易，因为已经有为此编写的开源库。在我的例子中，通过一个PHP web服务器后端，我使用了<a class="ae kr" href="http://phpqrcode.sourceforge.net/" rel="noopener ugc nofollow" target="_blank"> PHP二维码</a>来做这件事。</p><p id="688c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">二维码实际上只是一个文本字符串，它被编码成一个方块，方块内有一些更小的方块。实现QR码登录系统的方法是简单地生成一个足够长的随机字符串，然后将其存储到您的数据库(或Redis)中，将它与已经在桌面上登录的用户的帐户相关联。然后，您只需将二维码输出为您选择的图库的图像。</p><pre class="kj kk kl km fq nf nc ng nh aw ni dt"><span id="ec7d" class="ks kt if nc b fv nj nk l nl nm">// A not very up to current cryptographically-secure standard way<br/>// of generating a random string: just one example way to do it<br/>// in PHP. Generates a 60-character hex string randomly.<br/>$qrString = bin2hex(openssl_random_pseudo_bytes(30));</span><span id="5dd1" class="ks kt if nc b fv nn nk l nl nm">// Store the string into database, associate it with the user ID<br/>// of the currently logged in account.</span><span id="a4c8" class="ks kt if nc b fv nn nk l nl nm">// Using the PHP QR Code library, this generates/outputs a QR code<br/>QRcode::png($qrString);</span></pre><p id="0a81" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在移动客户端，我使用的是<a class="ae kr" href="https://github.com/schmich/instascan" rel="noopener ugc nofollow" target="_blank"> Instascan </a> JS库，创建一个可用的QR扫描仪的代码非常简单:</p><pre class="kj kk kl km fq nf nc ng nh aw ni dt"><span id="b031" class="ks kt if nc b fv nj nk l nl nm">var scanner = new Instascan.Scanner({ video: document.getElementById('preview'), mirror: false });</span><span id="a86a" class="ks kt if nc b fv nn nk l nl nm">scanner.addListener('scan', function (content) {<br/>  // When scanner detected a QR code successfully.<br/>  // The "content" variable will contain that random string<br/>  // you generated from the server side above.<br/>  // Submit login form here with that data to log in as that user.<br/>});</span><span id="b8e1" class="ks kt if nc b fv nn nk l nl nm">Instascan.Camera.getCameras().then(function (cameras) {<br/>  if (cameras.length &gt; 0) {<br/>    scanner.start(cameras[cameras.length-1]);<br/>  }<br/>});</span></pre><p id="9ee5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">除了一些额外的错误处理，没有太多的代码需要有一个工作的二维码登录。当然，在服务器端，登录端点将需要读取QR字符串，并从数据库中查找它以匹配要登录的用户帐户。</p><h2 id="9f5c" class="ks kt if bd ku kv kw kx ky kz la lb lc jn ld le lf jr lg lh li jv lj lk ll lm dt translated">最后一个问题:Javascript WebAudio中的左/右声道</h2><p id="d4fc" class="pw-post-body-paragraph jc jd if je b jf mf jh ji jj mg jl jm jn mh jp jq jr mi jt ju jv mj jx jy jz hn dt translated">在这一点上，我们几乎重新创建了V1 Flash版本的所有功能，甚至改进了许多东西(例如QR登录，没有Flash插件要求，不再有面向公众的Redis服务器)。</p><p id="3a60" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">V2的最后一块拼图是声音。诚然，这对于英文版的<a class="ae kr" href="http://karaoke.house" rel="noopener ugc nofollow" target="_blank">卡拉ok屋</a>来说问题要小得多，因为英文卡拉ok视频不倾向于分别使用左右声道。但是，这几乎是中国KTV视频的要求。</p><p id="5767" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的答案在于Javascript中的WebAudio API，它允许你在网页上用声音做各种各样的事情。然而，事情会变得棘手。</p><p id="e94f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">WebAudio JS代码将网页上的声音修改为仅使用单声道左声道或单声道右声道，如下所示:</p><pre class="kj kk kl km fq nf nc ng nh aw ni dt"><span id="5f99" class="ks kt if nc b fv nj nk l nl nm">audioCtx = new (window.AudioContext)();</span><span id="427e" class="ks kt if nc b fv nn nk l nl nm">source = audioCtx.createMediaElementSource(node);<br/>// "node" is the DOM node that contains the element with sound,<br/>// can be a &lt;video&gt; or &lt;audio&gt; element.</span><span id="958e" class="ks kt if nc b fv nn nk l nl nm">splitter = audioCtx.createChannelSplitter(2);<br/>source.connect(splitter, 0, 0);<br/>gainLeft = audioCtx.createGain();<br/>gainRight = audioCtx.createGain();<br/>splitter.connect(gainLeft, 0);<br/>splitter.connect(gainRight, 1);<br/>gainLeft.connect(audioCtx.destination, 0);<br/>gainRight.connect(audioCtx.destination, 0);</span><span id="1c69" class="ks kt if nc b fv nn nk l nl nm">// from here on, if you want to switch to left-only, do:<br/>gainLeft.gain.value = 1;<br/>gainRight.gain.value = 0;</span><span id="fa43" class="ks kt if nc b fv nn nk l nl nm">// and vice versa for right-only.</span></pre><p id="fa3e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果它与YouTube的JS API一起工作，这将是相对容易的，我们将在这里完成。但是，事实并非如此。</p><p id="1b0d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">YouTube JS API播放器的实现方式是，视频播放器本身(即<code class="eh mz na nb nc b">&lt;video&gt;</code>标签本身)存在于一个iframe中。这样做是出于各种各样的原因，这对YouTube来说是有意义的(主要是安全原因)，但这也使我们不可能做上面的WebAudio声音更改。在另一个域的iframe中访问一个<code class="eh mz na nb nc b">&lt;video&gt;</code> DOM节点将是跨源资源共享(CORS)，这是YouTube的服务器配置所不允许的(当然)。</p><figure class="kj kk kl km fq hw fe ff paragraph-image"><div class="fe ff np"><img src="../Images/b335240e5fb5bb67362b1da5a382424e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*IiRRPNMUdmMVGL_cBlSeIA.jpeg"/></div></figure><p id="d36d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这样做的唯一真正方法就是Chrome扩展。这就是为什么我创建了<a class="ae kr" href="https://chrome.google.com/webstore/detail/left-right-sound-select/gjaliinpmkmkehebabkfkhpbfaekgljn?hl=en-US" rel="noopener ugc nofollow" target="_blank">左右声音选择扩展</a>(<a class="ae kr" href="https://github.com/bigicoin/left-right-sound-select" rel="noopener ugc nofollow" target="_blank">source code/GitHub repo here</a>)，它基本上包含了上面的代码，但是适用于在一个页面上找到的所有视频或音频DOM节点(只要你启用了扩展，并且从扩展弹出菜单中选择了左声道或右声道，如上所示)。</p><p id="3466" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该应用程序的中文版<a class="ae kr" href="http://singk.net" rel="noopener ugc nofollow" target="_blank">SingK.net</a>，提示用户安装扩展，如果他们希望有音频通道选择功能。不理想，但考虑到限制因素，这是我能做的最好的了。幸运的是，至少英语卡拉ok视频没有这些分离的音频通道，所以没有必要为<a class="ae kr" href="http://karaoke.house" rel="noopener ugc nofollow" target="_blank">卡拉ok屋</a>提示这一点。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><p id="4e99" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最终，这不是一个我希望接触到数百万用户并成长为一家公司的项目；这是一个有点太小众的用例和受众。喜欢卡拉ok的人想在家里做，并且有一台媒体电脑(有相当好的立体声系统和麦克风！)设置在他们的客厅里。然而，这是我做过的技术上更有趣的副业之一，引导我探索Flash Actionscript声音转换、WebSocket、QR码、Javascript WebAudio API，甚至Chrome扩展。希望这里的知识能帮助到一些人，甚至启发一些人去做一个项目！</p><p id="9819" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">比如唱歌？给<a class="ae kr" href="http://karaoke.house" rel="noopener ugc nofollow" target="_blank"> <strong class="je ig">歌厅</strong> </a>一个尝试，如果只是为了检查它是如何工作的！</p></div></div>    
</body>
</html>