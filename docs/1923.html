<html>
<head>
<title>End to End Testing in One Short Second with Dart</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Dart在短短一秒钟内完成端到端测试</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/end-to-end-testing-in-one-short-second-with-dart-e699c8146fd6?source=collection_archive---------6-----------------------#2016-12-20">https://medium.com/hackernoon/end-to-end-testing-in-one-short-second-with-dart-e699c8146fd6?source=collection_archive---------6-----------------------#2016-12-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="8171" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">构建良好的端到端测试很难。拥有良好的端到端测试是非常好的。你如何从前者进入后者？</p><p id="b1af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上周我介绍了一个用<a class="ae jp" href="https://hackernoon.com/tagged/dart" rel="noopener ugc nofollow" target="_blank"> Dart </a>编写的简单的<a class="ae jp" rel="noopener" href="/@davidmorgan_14314/building-a-chat-app-in-dart-815fcd0e5a31#.5p6514fje">聊天服务器和客户端</a>。在编写代码的中途，我决定停下来添加端到端测试——这样它们可以帮助我取得更快的进展。这很有效，总体上节省了时间。</p><p id="e39c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">测试可能会耗费大量时间；但是我确信它会工作，因为我以前在类似的代码中使用过相同的模式。现在我在这里与你分享这种模式。</p><p id="6323" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于那些在家跟进的人来说，下面是如何获取和运行测试的方法。你需要<a class="ae jp" href="https://git-scm.com/downloads" rel="noopener ugc nofollow" target="_blank"> git </a>和<a class="ae jp" href="https://www.dartlang.org/install" rel="noopener ugc nofollow" target="_blank"> dart </a>，然后:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="c3da" class="jz ka hu jv b fv kb kc l kd ke">git clone <a class="ae jp" href="https://github.com/google/built_value.dart.git" rel="noopener ugc nofollow" target="_blank">https://github.com/google/built_value.dart.git</a><br/>cd built_value.dart<br/>git checkout tags/v0.4.3-article<br/>cd chat_example<br/>pub get<br/>pub run test</span></pre><p id="d12f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你运行它，你会发现它快得离谱<em class="kf">。在我的机器上，运行所有13个端到端测试总共需要大约一秒钟。此外，如果你检查其中一个测试，你会发现它们非常容易编写。这里有一个<a class="ae jp" href="https://hackernoon.com/tagged/test" rel="noopener ugc nofollow" target="_blank">测试</a>私有消息是私有的:</em></p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="f3cb" class="jz ka hu jv b fv kb kc l kd ke">group('tell', () {<br/>  test('goes to a single user', () async {<br/>    var alice = environment.newUser()..type('/login Alice letmein');<br/>    var bob = environment.newUser()..type('/login Bob letmein');<br/>    var eve = environment.newUser();</span><span id="81ed" class="jz ka hu jv b fv kg kc l kd ke">    alice.type('/tell Bob Hi there.');<br/>    bob.expectMatch(r'Alice \(private\): Hi there.');<br/>    eve.expectNoMatch('Hi there.');<br/>  });<br/>});</span></pre><p id="6acf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它同时测试客户端代码(在浏览器中运行的代码)和服务器。我们创建了三个用户:Alice、Bob和Eve。爱丽丝和鲍勃登录，然后爱丽丝发送一个“告诉”，一个直接的消息，给鲍勃。如果Bob能看到消息而Eve看不到，则测试通过。</p><h1 id="da3d" class="kh ka hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">到处飞镖</h1><p id="2018" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">如何测试聊天示例的关键是客户机代码和服务器代码都是用Dart编写的。这意味着完全有可能在服务器上运行客户机代码，或者在客户机上运行服务器代码——只有像“dart:io”这样的VM专用库和像“dart:html”这样的浏览器专用库除外。</p><p id="f36a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以我做的是<em class="kf">伪造出</em>客户端专用代码。这意味着“dart:html”支持的类被分成一个接口和单独的实现。例如，以下是HTML显示:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="1fbe" class="jz ka hu jv b fv kb kc l kd ke">/// Chat window main text display.<br/>abstract class Display {<br/>  /// Adds [text] to the display, coloured to indicate a local   <br/>  /// command.<br/>  void addLocal(String text); </span><span id="90bd" class="jz ka hu jv b fv kg kc l kd ke">  /// Adds [text] to the display.<br/>  void add(String text);<br/>}</span></pre><p id="1c33" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，为了在VM中加载客户机代码，我提供了一个假的实现:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="87e9" class="jz ka hu jv b fv kb kc l kd ke">/// Fake [Display] that stores added text.<br/>class FakeDisplay implements Display {<br/> List&lt;String&gt; text = &lt;String&gt;[];</span><span id="b83b" class="jz ka hu jv b fv kg kc l kd ke"> @override<br/> void add(String text) {<br/>   this.text.add(text);<br/> }</span><span id="b08c" class="jz ka hu jv b fv kg kc l kd ke"> @override<br/> void addLocal(String text) {}<br/>}</span></pre><p id="1aec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我可以在同一个虚拟机中运行服务器和客户端代码。到目前为止一切顺利。但是他们需要能够互相交流。</p><p id="68ba" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用相同的方法；连接类被分成接口:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="e94f" class="jz ka hu jv b fv kb kc l kd ke">/// Two-way connection between client and server; the client.<br/>abstract class ClientConnection {<br/>  Stream&lt;String&gt; get dataFromServer;</span><span id="0d8c" class="jz ka hu jv b fv kg kc l kd ke">  void sendToServer(String string);<br/>}</span></pre><p id="f46f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后为了测试，使用假的实现，把所有的东西连在一起。一个<a class="ae jp" href="https://github.com/google/built_value.dart/blob/v0.4.3-article/chat_example/lib/testing/fake_environment.dart" rel="noopener ugc nofollow" target="_blank">测试环境</a>维护服务器代码的一个实例，并创建连接到它的<a class="ae jp" href="https://github.com/google/built_value.dart/blob/v0.4.3-article/chat_example/lib/testing/test_user.dart" rel="noopener ugc nofollow" target="_blank">测试用户</a>。</p><p id="f5b7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">仅此而已。现在，你可能会说这不是真正的端到端测试。为此，我们需要使用类似于<a class="ae jp" href="https://github.com/google/webdriver.dart" rel="noopener ugc nofollow" target="_blank">网络驱动</a>的东西。这样的测试有它们的位置，特别是在与复杂系统集成时。它们是运输坚如磐石的软件所必需的。但是它们不是提高开发速度的最佳方式。</p><p id="06b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为此，你需要快速、简单地编写测试，就像这些，只测试你正在处理的代码。对于某些代码，单元测试是理想的；但是要真正理解高层次的东西，你需要作为用户与整个应用程序交互的测试。它们是“端到端”的，但只针对您最关心的部分。</p><h1 id="0b85" class="kh ka hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">更多的测试</h1><p id="f106" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">在撰写本文时，我注意到聊天代码中的一个bug:并非所有命令都能在本地得到正确响应。也就是说，有些命令在输入后就“消失”了。这并不奇怪:我对此没有任何测试！所以我决定补充一些。</p><p id="e8bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，“FakeDisplay”也需要记录本地回显的文本:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="45a2" class="jz ka hu jv b fv kb kc l kd ke">class FakeDisplay implements Display {<br/>  List&lt;String&gt; text = &lt;String&gt;[];<br/>  List&lt;String&gt; localText = &lt;String&gt;[];</span><span id="2f00" class="jz ka hu jv b fv kg kc l kd ke">  @override<br/>  void add(String text) {<br/>    this.text.add(text);<br/>  }</span><span id="5e43" class="jz ka hu jv b fv kg kc l kd ke">  @override<br/>  void addLocal(String text) {<br/>    this.localText.add(text);<br/>  }<br/>}</span></pre><p id="3c60" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我们需要能够断言它，所以“TestUser”得到了一个新方法:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="258b" class="jz ka hu jv b fv kb kc l kd ke">/// Checks local text for this user.<br/>void expectLocalMatch(Pattern pattern) {<br/>  expect(_display.localText, anyElement(matches(pattern)));<br/>}</span></pre><p id="2b59" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就这样，我准备添加这样的测试:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="3141" class="jz ka hu jv b fv kb kc l kd ke">test('away echoes locally', () async {<br/>  environment.newUser()<br/>      ..type('/away Not here.')<br/>      ..expectLocalMatch(r'/away Not here\.');<br/>});</span></pre><p id="19ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">捕获并修复了错误。这是完整的<a class="ae jp" href="https://github.com/google/built_value.dart/pull/90/commits/68b8593d9a7e554e10aa7382d6de0c401ab0c61f" rel="noopener ugc nofollow" target="_blank">拉取请求</a>。我添加了七个新的端到端测试，使总数达到20个，并修复了两个bug。</p><p id="72b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在所有的测试都在1.1秒内完成。我认为这是可以接受的。</p><h1 id="93a9" class="kh ka hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">节日快乐</h1><p id="da4d" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">我现在已经深入地写了我在Dart峰会上的<a class="ae jp" href="https://www.youtube.com/watch?v=TMeJxWltoVo" rel="noopener ugc nofollow" target="_blank">演讲(视频)</a>中的所有内容。幸运的是，现在是休息的好时机。你可以期待我在2017年发表更多文章——只要我有新的东西可以写。同时，如果你有什么特别想让我报道的，请告诉我。</p><blockquote class="lj lk ll"><p id="bda0" class="ir is kf it b iu iv iw ix iy iz ja jb lm jd je jf ln jh ji jj lo jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is kf it b iu iv iw ix iy iz ja jb lm jd je jf ln jh ji jj lo jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is kf it b iu iv iw ix iy iz ja jb lm jd je jf ln jh ji jj lo jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jq jr js jt fq lp"><div class="bz el l di"><div class="lq lr l"/></div></figure></div></div>    
</body>
</html>