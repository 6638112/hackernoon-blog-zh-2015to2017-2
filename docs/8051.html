<html>
<head>
<title>Mixing Python with Elixir II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Python与Elixir II混合</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/mixing-python-with-elixir-ii-async-e8586f9b2d53?source=collection_archive---------5-----------------------#2017-11-17">https://medium.com/hackernoon/mixing-python-with-elixir-ii-async-e8586f9b2d53?source=collection_archive---------5-----------------------#2017-11-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/e7c86717602a2a167384fba83bc596f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YWS_RPoF43IZWv7gMRnMag.png"/></div></div></figure><h2 id="f771" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">异步通信</h2><p id="fe35" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated"><strong class="kc hv">重要的</strong>:在继续之前，请阅读这篇文章的<a class="ae kv" rel="noopener" href="/@badu_bizzle/mixing-python-with-elixir-7a2b7ac6696">第一部分</a>。</p></div><div class="ab cl kw kx hc ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hn ho hp hq hr"><p id="c4af" class="pw-post-body-paragraph ka kb hu kc b kd ld kf kg kh le kj kk jn lf km kn jr lg kp kq jv lh ks kt ku hn dt translated">在第一部分<a class="ae kv" rel="noopener" href="/@badu_bizzle/mixing-python-with-elixir-7a2b7ac6696">，</a>中，我们看了如何使用Erlport从Elixir调用Python函数！</p><p id="a8a6" class="pw-post-body-paragraph ka kb hu kc b kd ld kf kg kh le kj kk jn lf km kn jr lg kp kq jv lh ks kt ku hn dt translated">ErlPort是一个Elixir库，它使得使用Erlang端口协议将Erlang连接到许多其他编程语言变得更加容易。</p><p id="6fd3" class="pw-post-body-paragraph ka kb hu kc b kd ld kf kg kh le kj kk jn lf km kn jr lg kp kq jv lh ks kt ku hn dt translated">然而，您可能已经注意到，调用过程必须等待Python完成处理并返回结果。这适用于即时且不需要太多时间的操作。否则，在运行密集型Python函数时就没什么意思了。因为你的长生不老药程序会挂起，等待Python代码完成。</p><p id="9f90" class="pw-post-body-paragraph ka kb hu kc b kd ld kf kg kh le kj kk jn lf km kn jr lg kp kq jv lh ks kt ku hn dt translated">对于需要一段时间才能完成的操作，我们需要一种方法来调用Python函数，并在函数完成时在我们的elixir代码中得到通知——类似于我们如何编写带有异步相互通信的进程的elixir程序。这很有用，尤其是当您想要一个Elixir进程来控制/监督几个Python操作时。我们可以同时运行Python函数，这让生活变得更美好。</p><p id="7776" class="pw-post-body-paragraph ka kb hu kc b kd ld kf kg kh le kj kk jn lf km kn jr lg kp kq jv lh ks kt ku hn dt translated">在本帖中，我们将探索如何实现这一点Python和Elixir之间的异步通信！</p><p id="e110" class="pw-post-body-paragraph ka kb hu kc b kd ld kf kg kh le kj kk jn lf km kn jr lg kp kq jv lh ks kt ku hn dt translated">我们可以像在Elixir进程之间通信一样思考这个挑战——通过使用<code class="eh li lj lk ll b">cast</code>——它允许我们在进程之间异步通信。</p><p id="7148" class="pw-post-body-paragraph ka kb hu kc b kd ld kf kg kh le kj kk jn lf km kn jr lg kp kq jv lh ks kt ku hn dt translated">以前我们从Python调用函数时，大多使用<a class="ae kv" href="https://github.com/hdima/erlport" rel="noopener ugc nofollow" target="_blank"> erlport的</a> <code class="eh li lj lk ll b"><a class="ae kv" href="http://erlport.org/docs/python.html#python-call-4" rel="noopener ugc nofollow" target="_blank">:python.call/4</a></code>。这是同步的，elixir程序必须等待python函数完成并发送响应。</p><p id="3907" class="pw-post-body-paragraph ka kb hu kc b kd ld kf kg kh le kj kk jn lf km kn jr lg kp kq jv lh ks kt ku hn dt translated">在这篇文章中，我们将使用<code class="eh li lj lk ll b"><a class="ae kv" href="http://erlport.org/docs/python.html#python-cast-2" rel="noopener ugc nofollow" target="_blank">:python.cast/2</a></code></p><h1 id="1374" class="lm jd hu bd je ln lo lp ji lq lr ls jm lt lu lv jq lw lx ly ju lz ma mb jy mc dt translated"><strong class="ak">了解:python.cast/2 </strong></h1><p id="49f8" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated"><code class="eh li lj lk ll b">:python.cast/2</code>的工作原理与<code class="eh li lj lk ll b"><a class="ae kv" href="https://hexdocs.pm/elixir/GenServer.html#cast/2" rel="noopener ugc nofollow" target="_blank">GenServer.cast/2</a></code>相同。您给它进程id(或注册的进程名)和发送给该进程的消息。与<code class="eh li lj lk ll b">:python.call</code>不同，<code class="eh li lj lk ll b">:python.cast</code>用于发送消息，而不是调用Python函数。就像你的长生不老药传递信息一样。Erlport为我们提供了一种机制来接收发送给python实例的消息。</p><h2 id="306b" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">Erlport Python模块</h2><p id="f340" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">Erlport提供了一个<a class="ae kv" href="https://pypi.python.org/pypi/erlport" rel="noopener ugc nofollow" target="_blank"> python库</a>，它有助于使用elixir数据类型和过程。您可以使用<a class="ae kv" href="https://pypi.python.org/pypi/pip" rel="noopener ugc nofollow" target="_blank"> pip </a>安装erlport。</p><pre class="md me mf mg fq mh ll mi mj aw mk dt"><span id="945c" class="jc jd hu ll b fv ml mm l mn mo">pip install erlport #don't run this yet!</span></pre><p id="a8a9" class="pw-post-body-paragraph ka kb hu kc b kd ld kf kg kh le kj kk jn lf km kn jr lg kp kq jv lh ks kt ku hn dt translated">然而，Erlport Elixir repo已经附带了Python库，它会在运行时自动加载。因此，如果您通过Elixir使用Erlport，就不必安装Erlport Python库。</p><p id="fe70" class="pw-post-body-paragraph ka kb hu kc b kd ld kf kg kh le kj kk jn lf km kn jr lg kp kq jv lh ks kt ku hn dt translated">下面是Erlang/Elixir和Python之间的数据映射</p><figure class="md me mf mg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mq"><img src="../Images/945fb6970b71e05a0a239d1731cc9c37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FZhI3nMnqSOAnDvBfhuzrg.png"/></div></div><figcaption class="mr ms fg fe ff mt mu bd b be z ek">Erlang/Elixir data types mapped to Python data types (<a class="ae kv" href="http://erlport.org/docs/python.html" rel="noopener ugc nofollow" target="_blank">http://erlport.org/docs/python.html</a>)</figcaption></figure><figure class="md me mf mg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mv"><img src="../Images/c3cb18fdbbdd56d6122bd60be2f68a2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bt4MrPgtead6UHpMssXa5Q.png"/></div></div><figcaption class="mr ms fg fe ff mt mu bd b be z ek">Python data types mapped to Erlang/Elixir data types (<a class="ae kv" href="http://erlport.org/docs/python.html" rel="noopener ugc nofollow" target="_blank">http://erlport.org/docs/python.html</a>)</figcaption></figure><h1 id="e586" class="lm jd hu bd je ln lo lp ji lq lr ls jm lt lu lv jq lw lx ly ju lz ma mb jy mc dt translated"><strong class="ak">处理从Elixir发送到Python的消息</strong></h1><p id="f77b" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">对于Elixir流程，您有一个接收块，在其中处理所有消息。或者使用GenServer时的<code class="eh li lj lk ll b">handle_call</code>、<code class="eh li lj lk ll b">handle_cast</code>和<code class="eh li lj lk ll b">handle_info</code>功能。Erlport为处理发送给Python进程的消息提供了类似的机制。<code class="eh li lj lk ll b"><em class="mp">set_message_handler</em></code>是函数。它在<code class="eh li lj lk ll b">erlport.erlang</code>模块中。它采用一个带有一个参数消息的Python函数，即传入的消息。无论何时收到消息，Erlport都会调用传递给<code class="eh li lj lk ll b">set_message_handler</code>的函数。这就像一个回调函数。</p><h1 id="3b7e" class="lm jd hu bd je ln lo lp ji lq lr ls jm lt lu lv jq lw lx ly ju lz ma mb jy mc dt translated">从Python向Elixir发送消息</h1><p id="8ebc" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">由于Elixir进程不知道谁发送了一条<em class="mp"> cast </em>消息，所以我们必须找到一种方法，一旦python函数完成，就知道将结果发送给哪个进程。一种方法是注册您希望结果发送到的Elixir流程的流程id。</p><p id="b187" class="pw-post-body-paragraph ka kb hu kc b kd ld kf kg kh le kj kk jn lf km kn jr lg kp kq jv lh ks kt ku hn dt translated">Erlport python模块提供了<code class="eh li lj lk ll b"><a class="ae kv" href="http://erlport.org/docs/python.html#erlport-erlang-cast" rel="noopener ugc nofollow" target="_blank">cast</a></code>函数，用于向Elixir process发送消息。这样，当函数完成时，我们可以将消息异步发送回elixir进程！</p><h1 id="e422" class="lm jd hu bd je ln lo lp ji lq lr ls jm lt lu lv jq lw lx ly ju lz ma mb jy mc dt translated">把所有的放在一起</h1><p id="d556" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">打开终端并使用mix创建一个新的Elixir项目</p><pre class="md me mf mg fq mh ll mi mj aw mk dt"><span id="7e34" class="jc jd hu ll b fv ml mm l mn mo">$ mix new elixir_python</span></pre><p id="4a37" class="pw-post-body-paragraph ka kb hu kc b kd ld kf kg kh le kj kk jn lf km kn jr lg kp kq jv lh ks kt ku hn dt translated"><em class="mp">添加依赖关系</em></p><p id="3553" class="pw-post-body-paragraph ka kb hu kc b kd ld kf kg kh le kj kk jn lf km kn jr lg kp kq jv lh ks kt ku hn dt translated">将<code class="eh li lj lk ll b">erlport</code>添加到您的依赖关系<code class="eh li lj lk ll b">mix.exs</code></p><pre class="md me mf mg fq mh ll mi mj aw mk dt"><span id="db20" class="jc jd hu ll b fv ml mm l mn mo">defp deps do<br/>    [     <br/>      <strong class="ll hv">{:erlport, "~&gt; 0.9"}</strong>,<br/>    ]<br/>  end</span></pre><p id="1e13" class="pw-post-body-paragraph ka kb hu kc b kd ld kf kg kh le kj kk jn lf km kn jr lg kp kq jv lh ks kt ku hn dt translated">然后安装项目依赖项。</p><pre class="md me mf mg fq mh ll mi mj aw mk dt"><span id="f28a" class="jc jd hu ll b fv ml mm l mn mo">$ cd elixir_python<br/>$ mix deps.get</span></pre><p id="5837" class="pw-post-body-paragraph ka kb hu kc b kd ld kf kg kh le kj kk jn lf km kn jr lg kp kq jv lh ks kt ku hn dt translated">创建<code class="eh li lj lk ll b">priv/python</code>目录，你将在那里保存我们的python模块</p><pre class="md me mf mg fq mh ll mi mj aw mk dt"><span id="70e2" class="jc jd hu ll b fv ml mm l mn mo">$ mkdir -p priv/python</span></pre><p id="2414" class="pw-post-body-paragraph ka kb hu kc b kd ld kf kg kh le kj kk jn lf km kn jr lg kp kq jv lh ks kt ku hn dt translated">为Erlport相关函数创建一个elixir模块包装。</p><pre class="md me mf mg fq mh ll mi mj aw mk dt"><span id="3b5a" class="jc jd hu ll b fv ml mm l mn mo">#lib/python.ex<br/><strong class="ll hv">defmodule</strong> ElixirPython.Python <strong class="ll hv">do</strong></span><span id="0948" class="jc jd hu ll b fv mw mm l mn mo">    @doc """<br/>      Start python instance with custom modules dir priv/python <br/>     """<br/>    <strong class="ll hv">def</strong> start() <strong class="ll hv">do</strong> <br/>        path = [<br/>             :code.priv_dir(:elixir_python), <br/>             "python"<br/>        ]|&gt; Path.join()<br/>        <br/>        {:ok, pid} = :python.start([<br/>           {:python_path, to_charlist(path)}<br/>        ])<br/>        pid</span><span id="97a9" class="jc jd hu ll b fv mw mm l mn mo">    <strong class="ll hv">end</strong></span><span id="0ee2" class="jc jd hu ll b fv mw mm l mn mo">    <strong class="ll hv">def</strong> call(pid, m, f, a \\ []) <strong class="ll hv">do</strong> <br/>       :python.call(pid, m, f, a)<br/>    <strong class="ll hv">end</strong><br/>    <br/>    <strong class="ll hv">def</strong> cast(pid, message) <strong class="ll hv">do</strong> <br/>       :python.cast(pid, message)<br/>    <strong class="ll hv">end</strong><br/>   <br/>    <strong class="ll hv">def</strong> stop(pid) <strong class="ll hv">do</strong> <br/>       :python.stop(pid)<br/>    <strong class="ll hv">end</strong></span><span id="5c4f" class="jc jd hu ll b fv mw mm l mn mo"><strong class="ll hv">end</strong></span></pre><p id="805f" class="pw-post-body-paragraph ka kb hu kc b kd ld kf kg kh le kj kk jn lf km kn jr lg kp kq jv lh ks kt ku hn dt translated">为了让Elixir流程异步接收消息，我们将创建一个简单的<code class="eh li lj lk ll b">GenServer</code>模块</p><pre class="md me mf mg fq mh ll mi mj aw mk dt"><span id="b370" class="jc jd hu ll b fv ml mm l mn mo">#lib/python_server.ex<br/><strong class="ll hv">defmodule</strong> ElixirPython.PythonServer <strong class="ll hv">do <br/>   use</strong> GenServer<br/>   alias ElixirPython.Python</span><span id="3348" class="jc jd hu ll b fv mw mm l mn mo">   <strong class="ll hv">def</strong> start_link() <strong class="ll hv">do <br/>      </strong>GenServer.start_link(__MODULE__, [])<br/>   <strong class="ll hv">end</strong></span><span id="bbfc" class="jc jd hu ll b fv mw mm l mn mo"><strong class="ll hv">   def</strong> init(args) <strong class="ll hv">do<br/>      </strong>#start the python session and keep pid in state<br/>      python_session = Python.start()<br/>      #register this process as the message handler<br/>      Python.call(python_session, :test, :register_handler, [self()])<br/>      {:ok, python_session}<br/>   <strong class="ll hv">end</strong></span><span id="4473" class="jc jd hu ll b fv mw mm l mn mo"><strong class="ll hv">   def</strong> cast_count(count) <strong class="ll hv">do <br/>      </strong>{:ok, pid} = start_link()<br/>      GenServer.cast(pid, {:count, count})<br/>   <strong class="ll hv">end<br/><br/>   def</strong> call_count(count) <strong class="ll hv">do<br/>      </strong>{:ok, pid} = start_link()<br/>      # :infinity timeout only for demo purposes<br/>      GenServer.call(pid, {:count, count}, :infinity)<br/>   <strong class="ll hv">end<br/><br/>   def</strong> handle_call({:count, count}, from, session) <strong class="ll hv">do <br/>      </strong>result = Python.call(session, :test, :long_counter, [count])<br/>      {:reply, result, session}<br/>   <strong class="ll hv">end</strong></span><span id="98be" class="jc jd hu ll b fv mw mm l mn mo"><strong class="ll hv">   def</strong> handle_cast({:count, count}, session) <strong class="ll hv">do <br/>     </strong>Python.cast(session, count)<br/>     {:noreply, session}<br/>   <strong class="ll hv">end</strong></span><span id="6a75" class="jc jd hu ll b fv mw mm l mn mo"><strong class="ll hv">   def</strong> handle_info({:python, message}, session) <strong class="ll hv">do         <br/>      </strong>IO.puts("Received message from python: #{inspect message}")<br/><br/>      #stop elixir process<br/>      {:stop, :normal,  session}<br/>   <strong class="ll hv">end</strong></span><span id="3478" class="jc jd hu ll b fv mw mm l mn mo"><strong class="ll hv">   def</strong> terminate(_reason, session) <strong class="ll hv">do <br/>     </strong>Python.stop(session)<br/>     :ok<br/>   <strong class="ll hv">end</strong></span><span id="d49b" class="jc jd hu ll b fv mw mm l mn mo"><strong class="ll hv">end</strong></span></pre><p id="c4fb" class="pw-post-body-paragraph ka kb hu kc b kd ld kf kg kh le kj kk jn lf km kn jr lg kp kq jv lh ks kt ku hn dt translated">现在让我们创建python模块<code class="eh li lj lk ll b">priv/python/test.py</code></p><pre class="md me mf mg fq mh ll mi mj aw mk dt"><span id="b218" class="jc jd hu ll b fv ml mm l mn mo">#priv/python/test.py<br/><strong class="ll hv">import</strong> time<br/><strong class="ll hv">import</strong> sys<br/>#import erlport modules and functions<br/><strong class="ll hv">from</strong> erlport.erlang <strong class="ll hv">import</strong> set_message_handler, cast<br/><strong class="ll hv">from</strong> erlport.erlterms <strong class="ll hv">import</strong> Atom<br/><br/>message_handler = <strong class="ll hv">None</strong> #reference to the elixir process to send result to<br/><br/><strong class="ll hv">def</strong> cast_message(pid, message):<br/>    cast(pid, message)<br/><br/><strong class="ll hv">def</strong> register_handler(pid):<br/>    #save message handler pid<br/>    <strong class="ll hv">global</strong> message_handler<br/>    message_handler = pid<br/><br/><strong class="ll hv">def</strong> handle_message(count):<br/>    <strong class="ll hv">try</strong>:<br/>        print "Received message from Elixir"<br/>        print count<br/>        result = long_counter(count)<br/>        if message_handler:<br/>           #build a tuple to atom {:python, result}<br/>           cast_message(message_handler, (Atom('python'), result))<br/>    <strong class="ll hv">except</strong> Exception, e:<br/>      # you can send error to elixir process here too<br/>      # print e<br/>      <strong class="ll hv">pass</strong><br/><strong class="ll hv">def</strong> long_counter(count=100):<br/>    #simluate a time consuming python function<br/>    i = 0<br/>    data = []<br/>    <strong class="ll hv">while</strong> i &lt; count:<br/>        time.sleep(1) #sleep for 1 sec<br/>        data.append(i+1)<br/>        i = i + 1<br/>    <strong class="ll hv">return</strong> data<br/><br/>set_message_handler(handle_message) #set handle_message to receive all messages sent to this python instance</span></pre><p id="87b4" class="pw-post-body-paragraph ka kb hu kc b kd ld kf kg kh le kj kk jn lf km kn jr lg kp kq jv lh ks kt ku hn dt translated">编译！</p><pre class="md me mf mg fq mh ll mi mj aw mk dt"><span id="0e79" class="jc jd hu ll b fv ml mm l mn mo">$ mix compile</span></pre><p id="e410" class="pw-post-body-paragraph ka kb hu kc b kd ld kf kg kh le kj kk jn lf km kn jr lg kp kq jv lh ks kt ku hn dt translated">快跑！</p><pre class="md me mf mg fq mh ll mi mj aw mk dt"><span id="1535" class="jc jd hu ll b fv ml mm l mn mo">$ iex -S mix<br/>iex(1)&gt; ElixirPython.PythonServer.call_count(4)<br/>[1, 2, 3, 4] #printed after waiting 4sec<br/>iex(2)&gt; ElixirPython.PythonServer.call_count(10)<br/>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] #printed after waiting 10sec!</span></pre><p id="c207" class="pw-post-body-paragraph ka kb hu kc b kd ld kf kg kh le kj kk jn lf km kn jr lg kp kq jv lh ks kt ku hn dt translated">还要注意的是，<code class="eh li lj lk ll b">call_count</code>导致<code class="eh li lj lk ll b">iex</code>挂起，直到我们从python获得返回结果</p><p id="1eab" class="pw-post-body-paragraph ka kb hu kc b kd ld kf kg kh le kj kk jn lf km kn jr lg kp kq jv lh ks kt ku hn dt translated">现在让我们异步调用同一个python函数！</p><pre class="md me mf mg fq mh ll mi mj aw mk dt"><span id="b114" class="jc jd hu ll b fv ml mm l mn mo">iex(3)&gt; ElixirPython.PythonServer.cast_count(4)<br/>:ok<br/>Received message from Elixir<br/>4<br/>Received message from python: [1, 2, 3, 4] # printed after 4sec, no wait<br/>iex(4)&gt; ElixirPython.PythonServer.cast_count(10)<br/>:ok<br/>Received message from Elixir<br/>10<br/>iex(5)&gt;<br/>nil<br/>Received message from python: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] #printed after 10sec without blocking</span></pre><p id="e23c" class="pw-post-body-paragraph ka kb hu kc b kd ld kf kg kh le kj kk jn lf km kn jr lg kp kq jv lh ks kt ku hn dt translated">请注意，一旦python函数完成，我们将如何继续在iex中工作并获得结果。试着用不同的号码——大号码和小号码——拨打<code class="eh li lj lk ll b">cast_count</code>。</p><p id="6ef8" class="pw-post-body-paragraph ka kb hu kc b kd ld kf kg kh le kj kk jn lf km kn jr lg kp kq jv lh ks kt ku hn dt translated">就是这样！现在您可以在Elixir和Python之间异步通信了。</p><p id="c6e8" class="pw-post-body-paragraph ka kb hu kc b kd ld kf kg kh le kj kk jn lf km kn jr lg kp kq jv lh ks kt ku hn dt translated">编码快乐！</p></div></div>    
</body>
</html>