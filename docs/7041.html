<html>
<head>
<title>Introduction to Numpy -2 : An absolute beginners guide to Machine Learning and Data science.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Numpy -2介绍:机器学习和数据科学的绝对初学者指南。</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/introduction-to-numpy-2-an-absolute-beginners-guide-to-machine-learning-and-data-science-967b21e3542a?source=collection_archive---------3-----------------------#2017-10-15">https://medium.com/hackernoon/introduction-to-numpy-2-an-absolute-beginners-guide-to-machine-learning-and-data-science-967b21e3542a?source=collection_archive---------3-----------------------#2017-10-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/9dd74f950915b4ec3ea33aeb13af00f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OUo68kyIoTraupNHse7myw.png"/></div></div></figure><p id="9935" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是numpy教程系列的第二部分。如果你没有读过我之前关于numpy的教程，我建议你在这里阅读。在本教程中，我将涵盖数据科学和机器学习所需的一些重要内容，也就是说，我不会涵盖numpy的所有可能。</p><p id="68b8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">好了那么，我们在之前的教程中已经看到了np.array()，np.arange()，np.eye()，np.dot()，np.shape，NP . shape()，np.sum()。让我们首先指出我们导入numpy的方式，您已经看到如下:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="e2d5" class="kk kl hu kg b fv km kn l ko kp">import numpy as np</span></pre><p id="e617" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们告诉python“NP”是对numpy的正式引用。</p><h1 id="597d" class="kq kl hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">np.random.rand():</h1><p id="a9e7" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">现在，我们来谈谈使用numpy的随机值生成。假设你想得到矩阵形式的随机值。就像下面的语句一样简单:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="37fb" class="kk kl hu kg b fv km kn l ko kp"># generate random values in a 2 x 3 matrix form<br/>np.random.rand(2,3)<br/>====================================================================<br/>array([[ 0.2248368 ,  0.49652272,  0.76189091],<br/>       [ 0.73520939,  0.48107188,  0.3883801 ]])</span></pre><p id="0766" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">好的，那么这个可以扩展到多个dim吗？当然是的！这就是numpy被建造的原因。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="fd1b" class="kk kl hu kg b fv km kn l ko kp"># generate random values in a 12 x 13 matrix form<br/>np.random.rand(12,13)<br/>====================================================================<br/>array([[ 0.43385691,  0.15503296,  0.19860119,  0.65346609,  0.16774261,0.56058978,  0.84974275,  0.05887681,  0.27276929,  0.88750259,0.25141674,  0.05663906,  0.54186252],<br/>       [ 0.2635477 ,  0.88291404,  0.42043263,  0.83565607,  0.92982761,0.79879409,  0.91323242,  0.37954769,  0.60198588,  0.44773903,0.70699903,  0.3892703 ,  0.94314732],<br/>       [ 0.12593268,  0.97838364,  0.81297353,  0.3368167 ,  0.33501746,0.99619471,  0.22476839,  0.93321408,  0.41301684,  0.01808732,0.61321647,  0.22462791,  0.468457  ],<br/>       [ 0.63765001,  0.13884884,  0.67648642,  0.65589694,  0.80931411,0.46202022,  0.40819602,  0.03863341,  0.16494124,  0.69603883,0.96849077,  0.19150476,  0.8968954 ],<br/>       [ 0.25646945,  0.21928867,  0.70952192,  0.80569537,  0.84562245,0.54595757,  0.00684613,  0.19142737,  0.94387805,  0.80871064,0.73648968,  0.80105002,  0.16716087],<br/>       [ 0.3894393 ,  0.61933361,  0.41088568,  0.88781578,  0.40932049,0.90947387,  0.71984125,  0.81259019,  0.69020009,  0.56480145,0.43041522,  0.02650665,  0.7738148 ],<br/>       [ 0.21326808,  0.2036178 ,  0.30368209,  0.51081501,  0.64345557,0.99061654,  0.96805793,  0.19446453,  0.25974565,  0.74033622,0.37379014,  0.67444828,  0.82899251],<br/>       [ 0.47571066,  0.82012796,  0.50881338,  0.3900192 ,  0.34356749,0.36440024,  0.58048805,  0.74650051,  0.24974157,  0.70129048,0.99920892,  0.29142188,  0.09263266],<br/>       [ 0.4140815 ,  0.25578684,  0.5485647 ,  0.07581615,  0.28539059,0.93805043,  0.56897052,  0.23606972,  0.78568646,  0.609795,0.70741831,  0.51003452,  0.53791667],<br/>       [ 0.53967367,  0.78513565,  0.94739241,  0.03891731,  0.15962705,0.45470422,  0.56172944,  0.49735169,  0.35216862,  0.87391629,0.43953245,  0.18160601,  0.78307107],<br/>       [ 0.1725005 ,  0.89132449,  0.05287284,  0.2113003 ,  0.69802999,0.12609322,  0.83490382,  0.34199806,  0.90740966,  0.33934554,0.02015816,  0.13498658,  0.06695927],<br/>       [ 0.14066135,  0.34828447,  0.0780561 ,  0.00126867,  0.57958087,0.93641585,  0.70294758,  0.21712057,  0.24902555,  0.53284372,0.19795993,  0.69817631,  0.71156616]])</span></pre><p id="4b2f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里有12行，每行包含13列。很酷，对吧？np真的是一个很棒的图书馆。我们都知道。</p><h1 id="c0f1" class="kq kl hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">如果我想在数组中手动添加元素呢？np.append()在这里回答你的祈祷！</h1><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="369f" class="kk kl hu kg b fv km kn l ko kp"># generate an array using np.arange()<br/>A = np.arange(5,15,2)<br/>A<br/>====================================================================<br/>array([ 5,  7,  9, 11, 13])</span></pre><p id="b00b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设我想把19加到a上，我该怎么做？</p><h2 id="7d22" class="kk kl hu bd kr ls lt lu kv lv lw lx kz jn ly lz ld jr ma mb lh jv mc md ll me dt translated">这正是我们使用np.append()的原因。</h2><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="6201" class="kk kl hu kg b fv km kn l ko kp">A = np.append(A,19)<br/>A<br/>====================================================================<br/>array([ 5,  7,  9, 11, 13, 19])</span></pre><p id="83ec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">np.append()将元素添加到指定数组中。</p><h2 id="79ea" class="kk kl hu bd kr ls lt lu kv lv lw lx kz jn ly lz ld jr ma mb lh jv mc md ll me dt translated">另一个(我不是DJ khaled！):</h2><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="4d8f" class="kk kl hu kg b fv km kn l ko kp">A = np.append(A,[3,55,34,553])<br/>A<br/>====================================================================<br/>array([  5,   7,   9,  11,  13,  19,   3,  55,  34, 553])</span></pre><p id="b746" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这一次是需要添加到中的元素列表。因此，我们可以预计，无论是一个元素还是一个元素列表，都将作为参数传递给np.append(这里是原始数组，这里是元素)。</p><p id="e31a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">捕捉返回值很重要，否则这些元素实际上不会被更新到旧列表中。它的意思是:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="8164" class="kk kl hu kg b fv km kn l ko kp"># A not updated because returned not captured.<br/>np.append(A,[3,55,34,553])</span><span id="8e78" class="kk kl hu kg b fv mf kn l ko kp"># A updated because returned value captured.<br/>A = np.append(A,[3,55,34,553])</span></pre><p id="9caa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我为什么要告诉你这些？很明显很简单！事情是这样的:我花了很长时间试图弄清楚发生了什么，最终归结为我没有抓住这个小错误。</p><h1 id="61cf" class="kq kl hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">太好了！我如何找到相邻元素之间的区别？</h1><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="d579" class="kk kl hu kg b fv km kn l ko kp">A<br/>====================================================================<br/>array([  5,   7,   9,  11,  13,  19,   3,  55,  34, 553])</span></pre><p id="803d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我的问题是，在数组A中，我如何找到(7–5)，(9–7)，(11–9)？或者换句话说，我如何连续找到A[n+1]-A[n]？</p><p id="3885" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">np有一个内置的方法，叫做np.diff()来解决这个问题。它看起来像这样:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="a572" class="kk kl hu kg b fv km kn l ko kp">B = np.diff(A,n=1)<br/>B<br/>====================================================================<br/>array([  2,   2,   2,   2,   6, -16,  52, -21, 519])</span></pre><p id="4a5a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你做一些减法，你会注意到这个数组正好是A[n+1]-A[n]。不过，这里的情况是:这个数组的长度比实际数组A的长度小1。</p><p id="79b1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我继续在B上做同样的np.diff()，我会得到如下结果:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="3daa" class="kk kl hu kg b fv km kn l ko kp">B = np.diff(B,n=1)<br/>B<br/>===================================================================<br/>array([  0,   0,   0,   4, -22,  68, -73, 540])</span></pre><p id="2639" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我可以告诉np.diff()为我做两次，而不是显式地做两次，最后仍然得到相同的结果。我的意思是:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="52a6" class="kk kl hu kg b fv km kn l ko kp"># parameter n indicates that this diff() must be run twice. <br/>np.diff(A,n=2)<br/>===================================================================<br/>array([  0,   0,   0,   4, -22,  68, -73, 540])</span></pre><p id="5dfe" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以，简单来说那就是np.diff()。n是定义迭代计数的参数。</p><h1 id="7b75" class="kq kl hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">现在如果我想堆叠元素，形成一个矩阵/向量呢？np.vstack()，np.column_stack()</h1><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="ac5c" class="kk kl hu kg b fv km kn l ko kp"># lets define 3 lists.<br/>a = [1,2,3]<br/>b = [4,5,6]<br/>c = [7,8,9]</span></pre><p id="7929" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我们考虑堆叠元素时，有两种变体可以考虑。</p><h2 id="5924" class="kk kl hu bd kr ls lt lu kv lv lw lx kz jn ly lz ld jr ma mb lh jv mc md ll me dt translated">如何通过堆叠3个列表直接生成一个矩阵？</h2><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="c960" class="kk kl hu kg b fv km kn l ko kp"># directly stack with lists passed in the same order.<br/>np.vstack((a,b,c))<br/>===================================================================<br/>array([[1, 2, 3],<br/>       [4, 5, 6],<br/>       [7, 8, 9]])</span><span id="527f" class="kk kl hu kg b fv mf kn l ko kp">np.vstack((b,a,c))<br/>===================================================================<br/>array([[4, 5, 6],<br/>       [1, 2, 3],<br/>       [7, 8, 9]])</span></pre><h2 id="e4ab" class="kk kl hu bd kr ls lt lu kv lv lw lx kz jn ly lz ld jr ma mb lh jv mc md ll me dt translated">如何通过堆叠3个列为行的列表来生成矩阵？</h2><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="87ae" class="kk kl hu kg b fv km kn l ko kp"># stack with lists passed taking their columns as rows. <br/>np.vstack((a,b,c))<br/>===================================================================<br/>array([[1, 4, 7],<br/>       [2, 5, 8],<br/>       [3, 6, 9]])</span></pre><p id="80f9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们再看一遍那些名单。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="4cc7" class="kk kl hu kg b fv km kn l ko kp">a = [1,2,3]<br/>b = [4,5,6]<br/>c = [7,8,9]</span></pre><p id="1498" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里，沿着列是元素[1，4，7]，[2，5，8]，[3，6，9]。我的问题是，如何让这些元素按行堆叠？</p><h2 id="ff79" class="kk kl hu bd kr ls lt lu kv lv lw lx kz jn ly lz ld jr ma mb lh jv mc md ll me dt translated">我们有np.column_stack()</h2><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="d012" class="kk kl hu kg b fv km kn l ko kp">np.column_stack((a,b,c))<br/>===================================================================<br/>array([[1, 4, 7],<br/>       [2, 5, 8],<br/>       [3, 6, 9]])</span><span id="538a" class="kk kl hu kg b fv mf kn l ko kp">np.column_stack((b,a,c))<br/>===================================================================<br/>array([[4, 1, 7],<br/>       [5, 2, 8],<br/>       [6, 3, 9]])</span></pre><h1 id="2cbf" class="kq kl hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">完美！这些都是先进的。我的基本问题是如何从数组中选择一些元素？切片。</h1><p id="cc42" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">假设我正在处理数组a，我只想选择元素9，11和13。我该怎么做？</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="2a8f" class="kk kl hu kg b fv km kn l ko kp">A<br/>===================================================================<br/>array([  5,   7,   9,  11,  13,  19,   3,  55,  34, 553])</span></pre><p id="2e9e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这又回到了数组切片，如果你还没见过它是什么，切片是这样工作的:你选择起始索引并在结束索引处停止。问题是结尾的索引不包括在内。</p><p id="29ef" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看看:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="28e6" class="kk kl hu kg b fv km kn l ko kp">A[2:5]  <br/>===================================================================<br/>array([ 9, 11, 13])</span></pre><p id="7720" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">9出现在索引2处，而13出现在索引4处。当进行数组切片时，要获得索引为4的元素，必须选择结束索引为5。换句话说，开始是原样，结束总是比要求大一号。</p><p id="e9b4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从现在开始，我将开始索引称为下界，结束索引称为上界。因此，一般来说，切片可以被公式化为:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="ce78" class="kk kl hu kg b fv km kn l ko kp">A[lowerbound(inclusive): upperbound(exclusive)]</span></pre><p id="d05d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一个例子:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="2734" class="kk kl hu kg b fv km kn l ko kp">A[0:3]<br/>===================================================================<br/>array([5, 7, 9])</span></pre><h1 id="2d3c" class="kq kl hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">再说广播。</h1><p id="905f" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">广播是numpy最好的特性之一。numpy能够将操作扩展到所有元素。</p><p id="6685" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那是什么意思？</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="c92e" class="kk kl hu kg b fv km kn l ko kp">A<br/>===================================================================<br/>array([  5,   7,   9,  11,  13,  19,   3,  55,  34, 553])</span></pre><p id="e2d1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我想给A的所有元素加1呢？我们的自然倾向是做以下事情:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="cbc3" class="kk kl hu kg b fv km kn l ko kp"># create an empty array to hold the new values<br/>K = np.array([])</span><span id="1d51" class="kk kl hu kg b fv mf kn l ko kp"># go through all the elements in A and add 1 to each<br/># and append the new value to the array.<br/>for e in A:<br/>    K = np.append(K,e+1)</span><span id="00ea" class="kk kl hu kg b fv mf kn l ko kp"># print the k array.<br/>K<br/>====================================================================<br/>array([  6,   8,  10,  12,  14,  20,   4,  56,  35, 554])</span></pre><p id="e23d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这看起来很自然，很可能每个人都会同意这种方法。问题是，所有numpy爱好者和极客可能会报告这篇文章“费时低效”,因为它提供了这种低效的解决方案。</p><h2 id="b3c5" class="kk kl hu bd kr ls lt lu kv lv lw lx kz jn ly lz ld jr ma mb lh jv mc md ll me dt translated">真的！？为什么这样效率低？</h2><p id="b702" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">这就是广播开始发挥作用的时候。我可以只用一行代码而不用任何for循环来做同样的事情，如下所示:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="48ec" class="kk kl hu kg b fv km kn l ko kp">K = A+1<br/>K<br/>====================================================================<br/>array([  6,   8,  10,  12,  14,  20,   4,  56,  35, 554])<br/></span></pre><h2 id="d945" class="kk kl hu bd kr ls lt lu kv lv lw lx kz jn ly lz ld jr ma mb lh jv mc md ll me dt translated">但是这是如何工作的呢？</h2><p id="41b4" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">numpy根据需要在内部匹配元素。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="b2e8" class="kk kl hu kg b fv km kn l ko kp"># This is how numpy matches internally aka broadcasting<br/>A+[1,1,1,1,1,1,1,1,1,1]</span></pre><p id="4995" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一个例子:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="c67d" class="kk kl hu kg b fv km kn l ko kp">A*-1<br/>====================================================================<br/>array([  -5,   -7,   -9,  -11,  -13,  -19,   -3,  -55,  -34, -553])</span></pre><p id="82ae" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，整个数组现在带有一个减号(-)。它正在广播。</p><p id="aae6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在你知道了，如果你想处理一个numpy数组中的所有元素，你可能不需要for循环，你也知道广播很酷。</p><p id="25d0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里有一个视频教程，解释了我所做的一切，如果你有兴趣通过视频消费。</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="mg mh l"/></div></figure><h1 id="7a01" class="kq kl hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">如果你喜欢这篇文章，请鼓掌/推荐。它帮助我写更多这样的文章。</h1></div></div>    
</body>
</html>