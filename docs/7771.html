<html>
<head>
<title>Why native app developers should take a serious look at Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么原生应用开发者应该认真看待Flutter</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/why-native-app-developers-should-take-a-serious-look-at-flutter-e97361a1c073?source=collection_archive---------0-----------------------#2017-11-08">https://medium.com/hackernoon/why-native-app-developers-should-take-a-serious-look-at-flutter-e97361a1c073?source=collection_archive---------0-----------------------#2017-11-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="3d39" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我开始之前，如果你还没有听说过，<a class="ae jp" href="https://flutter.io/" rel="noopener ugc nofollow" target="_blank"> Flutter </a>是一个应用SDK(由谷歌支持)，用于构建“<em class="jq">现代移动应用</em>”。它仍然处于alpha阶段，但是有很好的文档和工具，一些生产应用已经发布。</p><p id="6763" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我是一个业余爱好的开发者，最近我自己也用Flutter推出了一个app。这是一次如此愉快的经历，以至于我<em class="jq">有</em>来分享我为什么如此喜欢它。</p><h2 id="87e7" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">一点背景故事…</h2><p id="808b" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">我做的这个app(名为<a class="ae jp" href="http://chipsoffury.com" rel="noopener ugc nofollow" target="_blank"> Chips of Fury </a>)是一个虚拟扑克筹码app(现在在<a class="ae jp" href="https://play.google.com/store/apps/details?id=com.kanily.chipsoffury" rel="noopener ugc nofollow" target="_blank"> Play store </a>和<a class="ae jp" href="https://itunes.apple.com/WebObjects/MZStore.woa/wa/viewSoftware?id=1292493748&amp;mt=8" rel="noopener ugc nofollow" target="_blank"> App store </a>上线)。这是当你想和朋友玩扑克(或任何其他纸牌游戏)，但没有可用的扑克筹码的时候。因此，这是一个不平凡的多玩家应用程序，它需要在玩家玩回合时在所有设备之间实时同步，并具有大量自定义UI元素。</p><p id="dbfd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我花了大约1.5个月的时间来编写端到端的“愤怒的芯片”，包括我学习Flutter的时间。在我之前尝试推出这款应用时，我尝试过用Android/Java和iOS/Swift编写原生应用，但都以不同的完成程度离开了它们。我就是无法让他们达到“足以上市”的阶段。原因主要是无聊，做一个人完成一个项目需要做的单调工作。因此，Flutter不仅帮助我快速构建，更重要的是，它帮助我实际完成。太有趣了！不用说，我现在是旋舞迷了。</p><h2 id="d488" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">那么是不是像React Native？</h2><p id="b741" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">我在5-6个月前偶然发现了Flutter，当时我已经将它加入了书签，准备在未来的一个周末进行黑客活动。当时我没有深究太多细节，只是在心里把它归为与<a class="ae jp" href="https://facebook.github.io/react-native/" rel="noopener ugc nofollow" target="_blank"> React Native </a>相同的类别。</p><p id="7318" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">粗略地看一下，React本机比较非常明显。但是在思想层面上，与RN的相似之处始于并止于反应式编程模型。依我看，Flutter在它所实现的理念方面实现了跨越式的发展。澄清一下，我只尝试过几次使用React，主要是为了学习。所以我不打算比较颤振和反应。事实上，我有一种感觉，大多数开发者并没有足够认真地看待Flutter，因为这种想法与RN背道而驰。</p></div><div class="ab cl kr ks hc kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hn ho hp hq hr"><p id="1962" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的目标是试图说服本地应用程序开发人员(iOS/Swift/ObjC或Android/Java/Kotlin)认真看待旋舞。同样的代码可以在安卓和iOS上运行，这可以说是“T0”而不是“T1”的最大原因，这也是为什么颤振会给你留下最深刻的印象。无需赘述，以下是我认为扑动是应用程序开发的未来的原因。听好了哟！</p><h1 id="fd6f" class="ky js hu bd jt kz la lb jx lc ld le kb lf lg lh ke li lj lk kh ll lm ln kk lo dt translated">1.都是达特干的</h1><p id="a662" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated"><a class="ae jp" href="https://www.dartlang.org/" rel="noopener ugc nofollow" target="_blank">镖</a>什么？😕。当我向其他开发人员谈论颤振时，这是一个常见的反应。老实说，与斯威夫特或柯特林相比,<a class="ae jp" href="https://www.dartlang.org/" rel="noopener ugc nofollow" target="_blank">飞镖(T5)在句法上没有太大优势。</a></p><p id="2ccd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，我只是想强调这一点，因为我认为谷歌低估了有多少开发人员，当他们认为他们必须学习一种新的语言时，并没有尝试一种新的工具。如此之多，以至于即使它在技术上更优越也没关系。</p><p id="9fda" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以在Dart的辩护中<strong class="it hv"/>，这是一种简单的学习语言，不太可能对尝试flippet out起到威慑作用。看看Dart中的这个示例类。</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="77b1" class="jr js hu lu b fv ly lz l ma mb"><strong class="lu hv">class </strong>Vehicle {<br/>  <strong class="lu hv">final </strong>int numberOfWheels;<br/>  <strong class="lu hv">final </strong>double mileage;<br/>  <strong class="lu hv">final </strong>double horsePower;<br/><br/>  int speed = 0;<br/><br/>  Vehicle(<strong class="lu hv">this</strong>.numberOfWheels, <strong class="lu hv">this</strong>.mileage, <strong class="lu hv">this</strong>.horsePower);<br/><br/>  <strong class="lu hv">void </strong>accelerate() {<br/>    speed = speed + 1;<br/>  }<br/><br/>  <strong class="lu hv">void </strong>decelerate() {<br/>    speed = speed - 1;<br/>  }<br/><br/>  <strong class="lu hv">void </strong>brake() {<br/>    speed = 0;<br/>  }<br/>}</span></pre><p id="d438" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如您所看到的，使用类似于大多数流行的面向对象语言的语法阅读是非常简单的。当然，有一些特定语言的语法糖，一旦你学会了语言，你就可以开始编写更简洁的代码，但我的观点是，学习曲线相当小。</p><p id="34d8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">事实上，如果你没有尝试过斯威夫特/科特林，那么飞镖可能是一个很好的选择。</p><p id="86d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">为旋舞辩护</strong>:谷歌/旋舞有<a class="ae jp" href="https://flutter.io/faq/#why-did-flutter-choose-to-use-dart" rel="noopener ugc nofollow" target="_blank">充分的理由选择飞镖</a>。颤振的工作方式是，它需要非常快速地创建和破坏大量的短命物体。Dart的“垃圾收集”非常适合这种用例。这也表现在可以使用颤振构建的应用程序的性能上。</p><p id="0414" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以，假设你不会因为Dart而取消旋舞，让我继续。</p><h1 id="70c1" class="ky js hu bd jt kz la lb jx lc ld le kb lf lg lh ke li lj lk kh ll lm ln kk lo dt translated">2.这一切都是灾难援助计划——第二部分</h1><p id="c3b8" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">如果您为安卓或iOS开发应用程序，以下集成开发环境工作流是常见的-</p><figure class="lp lq lr ls fq md fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff mc"><img src="../Images/14f50ce1d27a150b3fe51d364ed8423d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tWwGVIW98CLUd_mUz1eYjA.png"/></div></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">Android Studio / XCode development flow when building screen layouts</figcaption></figure><p id="f9c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可能也熟悉标记，比如下面这些-</p><figure class="lp lq lr ls fq md fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff mc"><img src="../Images/41f7fdf23f1acd386cb794cafba82950.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hfp1eKdNl5lmallgeTiztg.png"/></div></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">Layout XML’s / JSX (React native)</figcaption></figure><p id="eb55" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在颤振中，布局仅使用Dart代码定义。没有XML /模板语言。也没有视觉设计师/故事板工具。</p><p id="fb23" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的直觉是，一听到这个，你们中的一些人甚至会有点畏缩。从表面上看，这也是我的反应。使用可视化工具进行布局不是更容易吗？在代码中编写各种约束逻辑不会使事情变得过于复杂吗？</p><p id="96cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的答案是<strong class="it hv">不</strong>。孩子！真是令人大开眼界。让我试着证明一下。</p><p id="1ab6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先..遇见先生<strong class="it hv">热重装</strong>。</p><p id="3159" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个并列的应用程序代码和模拟器的例子。这是一个完全自定义的布局，有一个顶部和底部的酒吧和一个内容的中间容器。你看到的代码就是运行app所需的_whole_ code。</p><figure class="lp lq lr ls fq md fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff mo"><img src="../Images/3980ad6803eda150ad58a8eef979da9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*3Lry5LY0xTllLE7-p3fF-g.gif"/></div></div></figure><p id="9ed5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">没有单独的布局xml，没有xib文件等。你对代码所做的修改可以被<strong class="it hv">立即热重装</strong>。热重新加载甚至可以保留您的应用程序状态，因此您甚至不必点击并到达您所在的屏幕就可以继续。我怎么强调都不为过，这比Android的Instant Run或任何类似的解决方案领先了好几光年。它只是工作，甚至在大型非平凡的应用程序。而且是疯狂的快。这就是Dart给你的力量。</p><p id="8c85" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">实际上，这使得可视化编辑器界面变得多余。我一点也没有错过XCode相当不错的自动布局<em class="jq"/>。</p><p id="6e2a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，我用Flutter (Dart)编写布局的效率比Android/XCode都高。一旦你掌握了它(对我来说，这意味着几个星期)，因为很少发生上下文切换，所以有一个实质性的开销减少。人们不必切换到设计模式，选择鼠标并开始四处点击。然后想知道某件事是否必须通过编程来完成，如何实现等等。一切都是程序化的。API设计得非常好。它很快变得直观，并且比auto layout / layout XMLs提供的构造强大得多。</p><h1 id="fc3d" class="ky js hu bd jt kz la lb jx lc ld le kb lf lg lh ke li lj lk kh ll lm ln kk lo dt translated">3.颤动是反应性的</h1><p id="9477" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">如果你从未使用过反应式框架，那么这可能是一个学习曲线。API防止以命令式的风格编码。对我来说，这需要一点时间来适应，但这是一种祝福(变相的？).</p><p id="cf5b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于那些知道反应范式的人来说，你可以跳过这一点的其余部分。至于其他，我想用一个小例子来说明反应式风格。看看这个简单的应用程序。它显示“Hello <name>”以及用户输入的名称，并让用户选择消息的颜色。</name></p><figure class="lp lq lr ls fq md fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/7aec4e3c76e0b432d8243ffd4afde858.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/1*ZV5tGO0o7iUW-Y2HDZx9yw.gif"/></div></figure><p id="ea78" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们想象一下，你将如何在原生Android(或iOS)中构建这样一个应用程序。因为这是一个简单的单页应用程序，所以我们将在一个活动(或ViewController)中编写所有代码。在命令式风格中，结构看起来像这样…</p><figure class="lp lq lr ls fq md fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff mq"><img src="../Images/34849f4340a3aaa52f259768103a3242.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gkgMvXelRxjTJf03qLWVVw.jpeg"/></div></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">Imperative style of code</figcaption></figure><p id="4e25" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">工作原理:</strong>将有一个监听器来跟踪文本字段和下拉列表值的变化。在更改时，我们将获得文本标签的一个实例，并调用相关的方法来更新它的值。(很可能我们会将这些值保存在一些私有实例变量中，以维护状态)</p><p id="49d1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这意味着，在Android或iOS中一个视图的典型公共API中，您会发现许多不同属性的getters和setters。例如，看看Android中TextView类的公共API。由于篇幅太长，我无法在此全文转载。它有数百个方法——准确地说是259个，外加4个构造函数。</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="b2d1" class="jr js hu lu b fv ly lz l ma mb">Some methods in the Android TextView.java class</span><span id="330e" class="jr js hu lu b fv mr lz l ma mb">getText<br/>setText<br/>setTextSize<br/>length<br/>getLineHeight<br/>getLayout<br/>setCompoundDrawables<br/>setCompoundDrawablesWithIntrinsicBounds<br/>setPadding<br/>getTextSize<br/>setTextSize<br/>getLetterSpacing<br/>setLetterSpacing<br/>setFontFeatureSettings<br/>setTextColor<br/>getTextColors<br/>getCurrentTextColor<br/>.<br/>.<br/>.<br/>.<br/>200+ more</span></pre><p id="cd51" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以每个视图都有一些通过这些方法公开的特定属性。任何给定的小部件类型都有数十种或数百种方法，这种方法让您可以根据自己的需要定制其外观和行为。酷吧？😱</p><p id="6698" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，让我们看看在反应式代码风格中，该结构可能是什么样子…</p><figure class="lp lq lr ls fq md fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff ms"><img src="../Images/5a3cf24b7d67f3742b8b131c08ba4707.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*__pI7kJQYUO2MpDl9p9W7g.jpeg"/></div></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">Reactive style of code</figcaption></figure><p id="71c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">工作原理:</strong>将有一个监听器来跟踪文本字段和下拉列表值的变化。在改变时，我们将在“全局状态”中更新这些值，并告诉Flutter重新绘制。</p><p id="634a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Flutter会自动计算出文本标签应该是什么样子。</p><p id="f666" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种编码方式有很多优点。例如，假设这个应用程序的下一个版本添加了另一个问候文本小部件，上面写着“再见”。</p><blockquote class="mt"><p id="b6dd" class="mu mv hu bd mw mx my mz na nb nc jo ek translated">你好<name>。<br/>拜拜&lt;姓名&gt;。</name></p></blockquote><p id="88f4" class="pw-post-body-paragraph ir is hu it b iu nd iw ix iy ne ja jb jc nf je jf jg ng ji jj jk nh jm jn jo hn dt translated">现在，在命令式风格中，还需要更新侦听器来调用新的“Bye”文本小部件(或视图)上的相关setter方法。</p><p id="a78a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，在反应式应用程序中，监听器保持不变。它们将继续更新全局状态(如前所述)。新的小部件将简单地根据状态重新绘制自己。</p><p id="05c6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在复杂的应用程序中，这种风格的编码开始大放异彩。维护和推理要简单得多。</p><p id="3941" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一个优势是公共API被极大地简化了。虽然这也是因为Flutter的Widget架构(下一点会解释)。举例来说，看看Flutter中文本小部件的代码。</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="55ca" class="jr js hu lu b fv ly lz l ma mb">class Text extends StatelessWidget {</span><span id="eee8" class="jr js hu lu b fv mr lz l ma mb">const Text(this.data, {<br/>    Key key,<br/>    this.style,<br/>    this.textAlign,<br/>    this.textDirection,<br/>    this.softWrap,<br/>    this.overflow,<br/>    this.textScaleFactor,<br/>    this.maxLines,<br/>  }) : assert(data != null),<br/>       super(key: key);</span><span id="4929" class="jr js hu lu b fv mr lz l ma mb">/// The text to display.<br/>  final String data;</span><span id="ad91" class="jr js hu lu b fv mr lz l ma mb">  final TextStyle style;<br/>  final TextAlign textAlign;<br/>  final TextDirection textDirection;<br/>  final bool softWrap;<br/>  final TextOverflow overflow;<br/>  final double textScaleFactor;<br/>  final int maxLines;</span><span id="b53c" class="jr js hu lu b fv mr lz l ma mb"><a class="ae jp" href="http://twitter.com/override" rel="noopener ugc nofollow" target="_blank">@override</a><br/>  Widget build(BuildContext context) {...}</span><span id="4916" class="jr js hu lu b fv mr lz l ma mb"><a class="ae jp" href="http://twitter.com/override" rel="noopener ugc nofollow" target="_blank">@override</a><br/>  void debugFillProperties(DiagnosticPropertiesBuilder description {...}<br/>}</span></pre><p id="c682" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它只有一个构造函数。仅此而已。其他两个方法将由框架调用。这是<em class="jq">的全部代码</em>，移除了注释，并从被覆盖的方法中移除了几行。是不是很优雅？部分原因是因为没有setters和getters。小部件更喜欢使用它们的构造函数参数来重新构建自己，而不是使用setters来改变自己。</p><p id="4cc3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">反应式vs命令式，心态转变:</strong></p><p id="6b3b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我觉得如果你一直用命令式的风格编码，那么一旦你真正尝试了这种风格，它就会受到赏识💡。开始时，我花了很多时间试图弄清楚如何在一个子部件上调用一个方法来更新它的内部状态(就像我们例子中的问候标签)。我陷入了做事必不可少的心态。</p><p id="de70" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我记得在挣扎了几天之后，是什么在我的脑海里点燃了一个灯泡。这是我在<a class="ae jp" href="https://gitter.im/flutter/flutter" rel="noopener ugc nofollow" target="_blank"> Flutter gitter频道</a>与一位友好成员的对话。这是他的建议(重点是我的)。</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="3567" class="jr js hu lu b fv ly lz l ma mb">@rrousselGit<br/><strong class="lu hv">A widget shouldn't visit it's children</strong>. It becomes messy. But you can access the state of your parents.</span><span id="df11" class="jr js hu lu b fv mr lz l ma mb">@animeshjain<br/>hmm ok. perhaps i'm still stuck with an imperative style of programming.</span><span id="9a8f" class="jr js hu lu b fv mr lz l ma mb">@rrousselGit<br/><strong class="lu hv">Think in immutable</strong>. Don't update the child. Update the parent, and create a new batch of child. Once you get used to it, you realize it has a lot of advantages.</span></pre><p id="e3bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Reactive中的架构更倾向于弄清楚如何管理状态。这值得在单独的系列文章中进行适当的讨论，因为有多种方法可以做到这一点。但是不用说，一旦我掌握了这种风格的编码，那就太棒了。仅仅从我现在已经开发了一个全功能应用的经验来说，我意识到我几乎没有花时间在副作用引起的错误上！</p><h1 id="1cd1" class="ky js hu bd jt kz la lb jx lc ld le kb lf lg lh ke li lj lk kh ll lm ln kk lo dt translated">4.一切都是小部件</h1><p id="68c4" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">在前一点中，我简单地提到了Flutter小部件API是多么优雅和简洁。这一点会进一步说明。</p><p id="1b6c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">什么是widget？</strong></p><p id="9286" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于大多数开发人员来说，小部件通常会调用呈现在屏幕上的元素的脑海画面，并封装一些行为。Android和iOS对应的是各种视图类。</p><p id="19ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Flutter对这一概念采取了不同/更广泛的观点，并在此过程中将其扩展到不仅仅是结构元素。小部件架构更倾向于组合而不是继承，从而使小部件更加强大和可组合(咄！).引用自<a class="ae jp" href="https://flutter.io/technical-overview/" rel="noopener ugc nofollow" target="_blank"> Flutter的文档</a> -</p><blockquote class="ni nj nk"><p id="4430" class="ir is jq it b iu iv iw ix iy iz ja jb nl jd je jf nm jh ji jj nn jl jm jn jo hn dt translated">小部件可以定义<br/> -结构元素(如按钮或菜单)<br/> -风格元素(如字体或配色方案)<br/> -布局的一个方面(如填充)<br/>等等…</p></blockquote><p id="6274" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">甚至一个行为也是一个小部件(像<a class="ae jp" href="https://docs.flutter.io/flutter/widgets/GestureDetector-class.html" rel="noopener ugc nofollow" target="_blank">手势检测器</a>)。有一种小部件有助于状态管理(<a class="ae jp" href="https://docs.flutter.io/flutter/widgets/InheritedWidget-class.html" rel="noopener ugc nofollow" target="_blank"> InheritedWidget </a>)，还有一种有助于构建动画(<a class="ae jp" href="https://docs.flutter.io/flutter/widgets/AnimatedWidget-class.html" rel="noopener ugc nofollow" target="_blank"> AnimatedWidget </a>)。再次引用文献-</p><blockquote class="ni nj nk"><p id="446a" class="ir is jq it b iu iv iw ix iy iz ja jb nl jd je jf nm jh ji jj nn jl jm jn jo hn dt translated">您还可以通过将小部件与其他小部件组合来控制小部件的<em class="hu">布局</em>。例如，要使一个小部件居中，您可以将其包装在一个居中的小部件中。有用于填充、对齐、行、列和网格的小部件。这些布局小部件没有自己的可视化表示。相反，它们的唯一目的是控制另一个小部件布局的某些方面。为了理解为什么小部件以某种方式呈现，检查相邻的小部件通常是有帮助的。</p></blockquote><p id="41f4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过遵循“组合&gt;继承”，小部件从原始的开始，到一些真正复杂的。例如，Flutter提供的<a class="ae jp" href="https://docs.flutter.io/flutter/widgets/Container-class.html" rel="noopener ugc nofollow" target="_blank">容器部件</a>由许多原语组成</p><figure class="lp lq lr ls fq md fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff no"><img src="../Images/46f4b18eb5fdbf513ad83bbd59b19b29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YPnhpNun4kA_qxsNowY4Lg.png"/></div></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">Container is made of upto 7 nested widgets!</figcaption></figure><p id="339e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦你开始建造，这种设计的独创性就会显现出来。该框架使得定制任何库存部件的外观和感觉变得非常容易，并且如果需要的话可以构建自己的外观和感觉。这使得API占用空间非常小。例如，每个文本小部件不需要一个叫做填充的属性。您只需用填充小部件包装文本小部件。</p><p id="6fb5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">重复一遍，要记住的关键是……组成重于继承。它在Flutter的API中得到了有力的应用，并使它变得非常优雅和简单。</p><h1 id="dbdd" class="ky js hu bd jt kz la lb jx lc ld le kb lf lg lh ke li lj lk kh ll lm ln kk lo dt translated">5.告别活动生命周期管理</h1><p id="60e2" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">我不确定我是否遇到过喜欢管理活动(或者片段或者视图控制器)生命周期的人。作为一个没有每天开发应用程序的人，我发现至少可以说它们很烦人，而且总的来说花费了大量的时间。</p><p id="0641" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让一个片段在一个活动中工作，带有异步数据加载和本地状态管理，对我来说可能是一种魔法。所以我做了一个普通工程师会做的事..我复制粘贴的代码，辛苦地浏览文档，看猫的视频，试图让所有的工作和生活都变得不连贯。</p><p id="368b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">颤动带走了所有的乐趣。</p><figure class="lp lq lr ls fq md fe ff paragraph-image"><div class="fe ff np"><img src="../Images/811cd165e480b82c7ed0d3f35a7b2398.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*qzQSQNsLHg37uw_iUaYxgw.gif"/></div></figure><h1 id="0eb0" class="ky js hu bd jt kz la lb jx lc ld le kb lf lg lh ke li lj lk kh ll lm ln kk lo dt translated">6.一致的60 FPS(每秒帧数)性能</h1><p id="753c" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">Flutter应用程序编译成本机代码，因此性能非常好。事实上，我发现它比使用Java/Swift更适合构建类似app的游戏。由于它的反应性质，编写UI代码要干净得多。这与性能特征相结合，可能也使它成为构建游戏的有力竞争者。</p><p id="9bc0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这篇由<a class="ae jp" href="http://twitter.com/wmleler1" rel="noopener ugc nofollow" target="_blank"> @wmleler1 </a>(开发者倡导者@ Google)撰写的文章很好地解释了为什么Flutter的渲染速度如此之快——<a class="ae jp" href="https://hackernoon.com/whats-revolutionary-about-flutter-946915b09514" rel="noopener ugc nofollow" target="_blank">https://hacker noon . com/whats-revolution-about-Flutter-946915 b 09514</a>。我将借用这篇文章，并张贴一些图表和引文，展示它的TLDR版本，比较三种架构——本机与反应本机与颤振。</p><p id="8ec3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">本地应用(Java/Swift) </strong></p><figure class="lp lq lr ls fq md fe ff paragraph-image"><div class="fe ff nq"><img src="../Images/cdea460c354ba0dfa0b448d09d340a63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*c4-dPk9FGweW7XawcLxYPQ.png"/></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">How native Android/iOS code interacts with the platform</figcaption></figure><blockquote class="ni nj nk"><p id="4cad" class="ir is jq it b iu iv iw ix iy iz ja jb nl jd je jf nm jh ji jj nn jl jm jn jo hn dt translated">你的应用程序与平台对话来创建小部件，或者访问像相机这样的服务。小部件呈现在屏幕画布上，事件传递回小部件。这是一个简单的架构，但是你几乎必须为每个平台创建单独的应用程序，因为小部件是不同的，更不用说本地语言了。</p></blockquote><p id="8ab5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> React原生应用(Javascript) </strong></p><figure class="lp lq lr ls fq md fe ff paragraph-image"><div class="fe ff nr"><img src="../Images/281c8293c9e3f9436fcb801fefe38578.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*kIH_djrXMlSsoYra92_S0g.png"/></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">How React Native interacts with the platform</figcaption></figure><blockquote class="ni nj nk"><p id="0881" class="ir is jq it b iu iv iw ix iy iz ja jb nl jd je jf nm jh ji jj nn jl jm jn jo hn dt translated">React Native非常受欢迎(也理应如此)，但是因为JavaScript领域访问本机领域中的OEM小部件，所以它也必须<a class="ae jp" rel="noopener" href="/@talkol/performance-limitations-of-react-native-and-how-to-overcome-them-947630d7f440">通过桥</a>来访问这些小部件。小部件通常被频繁访问(在动画、过渡或用户用手指在屏幕上“滑动”时，每秒钟多达60次)，因此这可能会导致性能问题。正如<a class="ae jp" rel="noopener" href="/@talkol/performance-limitations-of-react-native-and-how-to-overcome-them-947630d7f440">一篇关于React Native </a>的文章所说:</p><p id="b76d" class="ir is jq it b iu iv iw ix iy iz ja jb nl jd je jf nm jh ji jj nn jl jm jn jo hn dt translated">这是理解React本机性能的关键之一。每个领域本身都快得惊人。当我们从一个领域转移到另一个领域时，经常会出现性能瓶颈。为了构建高性能的React本机应用程序，我们必须尽量减少过桥次数。</p></blockquote><p id="3883" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">颤振应用程序(飞镖)</strong></p><figure class="lp lq lr ls fq md fe ff paragraph-image"><div class="fe ff ns"><img src="../Images/f5eaa39a5d0046b25ca3e0a9cb906c27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*1DiOFy8WN0dgoV16iK02BQ.png"/></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">How Flutter interacts with the platform</figcaption></figure><blockquote class="ni nj nk"><p id="c72f" class="ir is jq it b iu iv iw ix iy iz ja jb nl jd je jf nm jh ji jj nn jl jm jn jo hn dt translated">Flutter采用了一种不同的方法，通过使用编译的编程语言，即<a class="ae jp" href="https://www.dartlang.org/" rel="noopener ugc nofollow" target="_blank"> Dart </a>，来避免由于需要JavaScript桥而导致的性能问题。Dart被“提前”(AOT)编译成多平台的本机代码。这允许Flutter与平台进行通信，而不需要通过JavaScript桥进行上下文切换。</p><p id="c8e1" class="ir is jq it b iu iv iw ix iy iz ja jb nl jd je jf nm jh ji jj nn jl jm jn jo hn dt translated">Flutter有一个新的架构，包括外观和感觉都很好、速度很快、可定制和可扩展的小部件。没错，<strong class="it hv"> Flutter不使用OEM widgets </strong>(或者DOM WebViews)，<strong class="it hv">它提供自己的widgets </strong>。</p><p id="9ca5" class="ir is jq it b iu iv iw ix iy iz ja jb nl jd je jf nm jh ji jj nn jl jm jn jo hn dt translated">Flutter将窗口小部件和渲染器从平台移动到应用程序中，这使得它们可以定制和扩展。Flutter对平台的所有要求是一个画布，在其中呈现小部件，以便它们可以出现在设备屏幕上，并访问事件(触摸、计时器等)。)和服务(位置、相机等。).</p></blockquote><p id="b8f2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您想更好地理解Flutter的性能，请通读这篇文章。</p><p id="e1c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你在安卓系统上，你可以试试Flutter gallery应用程序，它展示了一些非常酷的动画-<a class="ae jp" href="https://play.google.com/store/apps/details?id=io.flutter.gallery" rel="noopener ugc nofollow" target="_blank">https://play.google.com/store/apps/details?id=io.flutter.gallery </a>。这是那个应用程序的gif图</p><figure class="lp lq lr ls fq md fe ff paragraph-image"><div class="fe ff nt"><img src="../Images/276c1ca48ae9b897e3bee2c487103cd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/1*350ujaVYToF28-RAusHnbQ.gif"/></div></figure><p id="3dfb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(iOS应用商店没有列出演示应用，所以在iOS上你必须自己构建-<a class="ae jp" href="https://github.com/flutter/flutter/tree/master/examples/flutter_gallery" rel="noopener ugc nofollow" target="_blank">https://github . com/flutter/flutter/tree/master/examples/flutter _ gallery</a>)</p><p id="bebc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将我们带到倒数第二，但颤振最大的胜利之一…</p><h1 id="cdd4" class="ky js hu bd jt kz la lb jx lc ld le kb lf lg lh ke li lj lk kh ll lm ln kk lo dt translated">7.像老板一样在android和iOS上发布。</h1><p id="83ee" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">说够了！</p><figure class="lp lq lr ls fq md fe ff paragraph-image"><div class="fe ff nu"><img src="../Images/658e7ce9ce29440f9648425d3e650616.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/1*CK0PaBUo-uFpmpufwPOemQ.gif"/></div></figure><p id="8ea3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后但同样重要的是…</p><h1 id="4e47" class="ky js hu bd jt kz la lb jx lc ld le kb lf lg lh ke li lj lk kh ll lm ln kk lo dt translated">8.颤振社区</h1><p id="6fef" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">这是非常重要的一点，因为颤振是新的(和阿尔法)。从这个角度来看，社区支持非常好。<a class="ae jp" href="https://gitter.im/flutter/flutter" rel="noopener ugc nofollow" target="_blank">颤振gitter频道</a>有持续的聊天，新手和有经验的开发人员很好地混合在一起。我的大多数问题在那里几个小时内就得到了回答。对于更长的问题，<a class="ae jp" href="https://stackoverflow.com/questions/tagged/flutter" rel="noopener ugc nofollow" target="_blank"> stackoverflow </a>也能很快得到回答。</p><p id="27ef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">挂在聊天上的Flutter dev团队非常有帮助。他们非常欢迎新朋友，并回答我们容易陷入的简单问题。总的来说，我发现谈话的语气是谦逊和真实的。我认为这对框架的未来是个好兆头。</p></div><div class="ab cl kr ks hc kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hn ho hp hq hr"><p id="5e33" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是所有的乡亲。我希望我已经说服你和Flutter一起玩了。这篇文章主要谈论的是Flutter的积极方面，因为在我的开发经历中，这是我最大的经历。这并不意味着没有缺点。</p><p id="28fd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">需要注意的是，Flutter是新出现的，所以有<em class="jq">已知的问题/限制，当然还有未知的问题/限制。解决这些限制不在本文的讨论范围之内。此外，许多限制是一个移动的目标，而Flutter dev团队正在快速关闭东西。</em></p><p id="ba2b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里列出了一些限制，这些限制似乎是社区中常见的</p><ul class=""><li id="174d" class="nv nw hu it b iu iv iy iz jc nx jg ny jk nz jo oa ob oc od dt translated">还不支持内嵌地图-<a class="ae jp" href="https://github.com/flutter/flutter/issues/73" rel="noopener ugc nofollow" target="_blank">https://github.com/flutter/flutter/issues/73</a></li><li id="230d" class="nv nw hu it b iu oe iy of jc og jg oh jk oi jo oa ob oc od dt translated">缺乏对内嵌视频的支持。但是看起来有一个补丁在里面，应该很快就会到达主分支🎉 🍻——<a class="ae jp" href="https://github.com/flutter/flutter/pull/12525" rel="noopener ugc nofollow" target="_blank">https://github.com/flutter/flutter/pull/12525</a></li><li id="b99d" class="nv nw hu it b iu oe iy of jc og jg oh jk oi jo oa ob oc od dt translated">实例状态(Android)未保存。因此，如果应用程序在后台被终止，您将失去状态。还没有简单的方法来处理这个问题——https://github.com/flutter/flutter/issues/6827</li></ul></div><div class="ab cl kr ks hc kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hn ho hp hq hr"><p id="8d58" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">鸣谢:感谢校对和建议- Brian Egan，Ajeet Kushwaha，Sajat Jain，Gaurav Karwa，Arpit</p></div><div class="ab cl kr ks hc kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hn ho hp hq hr"><p id="a6e2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jq">如果您喜欢这篇文章，请在您的网络中分享。如果你玩扑克，试着给</em> <a class="ae jp" href="http://chipsoffury.com" rel="noopener ugc nofollow" target="_blank"> <em class="jq">狂暴筹码</em> </a> <em class="jq">(我用Flutter做的应用)一个旋转。</em></p><p id="f468" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">谢谢！</p></div></div>    
</body>
</html>