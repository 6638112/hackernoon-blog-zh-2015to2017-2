<html>
<head>
<title>The Hydra Bug: Part III</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">九头蛇虫:第三部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-hydra-bug-1e71347d6759?source=collection_archive---------14-----------------------#2017-05-22">https://medium.com/hackernoon/the-hydra-bug-1e71347d6759?source=collection_archive---------14-----------------------#2017-05-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div class="fe ff hs"><img src="../Images/74c04a68ce56873317483760c75a8a5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/1*zN0_CPZDqawHmGg5z8Biew.gif"/></div><figcaption class="hz ia fg fe ff ib ic bd b be z ek">Image copyright <a class="ae id" href="https://www.flickr.com/photos/andrew_jian" rel="noopener ugc nofollow" target="_blank">Andrew Jian</a> <a class="ae id" href="https://creativecommons.org/licenses/by/2.0/" rel="noopener ugc nofollow" target="_blank">CC-BY</a></figcaption></figure><div class=""/><div class=""><h2 id="d2ca" class="pw-subtitle-paragraph jd if ig bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ek translated">能(不能)的小内核</h2></div><p id="c0c7" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在解决了<a class="ae id" rel="noopener" href="/@vishvananda/the-hydra-bug-4a9ceb208436">简介</a>中的一个小错误后，<a class="ae id" rel="noopener" href="/@vishvananda/the-hydra-bug-e4d3af2d61c0">第一部分</a>阐述了我是如何花了一周时间为我的基于KVM/vf的虚拟机管理原型发现并解决hydra错误的。<a class="ae id" rel="noopener" href="/@vishvananda/the-hydra-bug-d98214029358">第二部分</a>解释了我是如何花了一周时间让iPXE intelxvf驱动程序变得更加健壮的。</p><p id="ddf9" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">一切都在工作，但我很恼火，我没有真正修复九头蛇的错误，而是解决了它。我可能无法控制启动哪个内核。因此，在iPXE端防止挂起是有意义的，但我不知道它为什么会修复这个问题，这让我很困扰。我作弊了，感觉很肮脏。不解决这个问题，我无法休息。请继续阅读，寻找真正的解决方案。</p></div><div class="ab cl kr ks hc kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hn ho hp hq hr"><p id="871a" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">自从我上一次做这个已经过去了几个月，所以我的第一步是重现最初的问题。我恢复了我的解决方法，并尝试启动内核3.8。同样的问题。我确保下载UEK3的最新版本，以防bug被修复。运气不好。</p><p id="4572" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我需要知道内核挂在哪里。我的第一个尝试是尝试通过内核命令行启用sysrq键,这样我可以强制它进行堆栈跟踪。不幸的是，无论我如何混合print-screen，挂起的内核都没有响应。也许我在启动过程中太早了？</p><p id="9e11" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">看起来我不得不开始使用gdb来获得堆栈跟踪。我为来宾内核下载了debuginfo包，并使用调试监听器(<code class="eh ky kz la lb b">-s</code>和<code class="eh ky kz la lb b">-S</code>选项)启动qemu stopped。我远程连接gdb，加载调试就绪的内核映像，并键入<code class="eh ky kz la lb b">c</code>继续。</p><p id="426d" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">所有的在线帮助都谈到通过qemu直接引导内核来调试内核。qemu启动时，我的内核没有加载。在最终到达内核代码之前，它会跳过BIOS、iPXE和grub。因此，我假设我必须找出内核在内存中的加载位置，并告诉gdb。</p><p id="1a71" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">一旦我确定客户挂起了，我就按Ctrl-C，让我吃惊的是我看到了源代码。经过进一步的思考，这是有意义的，因为早期的内核引导会将其例程加载到内存中的同一个位置。也可能是广发只是魔术。查看回溯，它似乎卡在kvm_steal_clock中的一个<a class="ae id" href="http://lxr.free-electrons.com/source/arch/x86/kernel/kvm.c?v=4.8#L400" rel="noopener ugc nofollow" target="_blank"> while循环</a>中。是时候研究kvm时钟是如何工作的了。</p><p id="18a3" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">kvm时钟似乎是通过分配一些共享内存来与主机通信的，主机端向这些共享内存写入数据，而客户机从这些共享内存中读取数据。在快速检查该函数中是否有任何代码在UEK被修改后，我注意到它被包装在一个<code class="eh ky kz la lb b">#ifndef CONFIG_DTRACE</code>中，但是该函数肯定被调用了，所以这是在转移视线。</p><p id="2f0e" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">只是为了验证问题出在这个位置，我试着完全禁用<a class="ae id" href="https://rwmj.wordpress.com/tag/kvmclock/" rel="noopener ugc nofollow" target="_blank"> kvmclock </a>。在qemu命令行上传递<code class="eh ky kz la lb b">cpu=host,-kvmclock</code>稍微改变了挂起位置，但似乎没有解决问题。我认为kvmclock使用的内存在某种程度上与iPXE冲突，也许删除它只是破坏了其他东西。</p><p id="63ee" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在内核源代码中读取早期的内存块分配，看起来它正在分配一个包含部分保留区域的大块(这是早在<a class="ae id" rel="noopener" href="/@vishvananda/the-hydra-bug-e4d3af2d61c0">第一部分</a>中打印出来的<code class="eh ky kz la lb b">NODE_DATA</code>的值)。尽管如此，kvmclock代码打印出它正在使用的内存位置，并且，虽然它们靠近iPXE保留区域，但它们似乎并不直接冲突。</p><p id="666a" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我决定逐步完成kvm时钟初始化，看看它是否能提供更多信息。我重启调试会话，键入<code class="eh ky kz la lb b">b kvmclock_init</code>，后跟<code class="eh ky kz la lb b">c</code>，等待断点命中。我到达了挂起，但没有碰到断点。搞什么？kvmclock_init是否被跳过？不，控制台从函数中间显示调试语句，所以它肯定运行了。</p><p id="517f" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我在网上搜索qemu断点，偶然发现一个<a class="ae id" href="http://wiki.qemu.org/Documentation/Debugging" rel="noopener ugc nofollow" target="_blank">页面</a>提到硬件断点可能比软件断点工作得更好。我记得很久以前我用qemu开发引导装载程序时遇到了软件断点的问题。关于处于16位模式的一些事情让调试器感到困惑。我尝试使用硬件断点。这次它停下来了，但是给了我一个神秘的信息<code class="eh ky kz la lb b">Remote ‘g’ packet reply is too long</code>。</p></div><div class="ab cl kr ks hc kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hn ho hp hq hr"><h2 id="9acf" class="lc ld ig bd le lf lg lh li lj lk ll lm ke ln lo lp ki lq lr ls km lt lu lv lw dt translated">简介:GDB和内核调试</h2><p id="9fb0" class="pw-post-body-paragraph jv jw ig jx b jy lx jh ka kb ly jk kd ke lz kg kh ki ma kk kl km mb ko kp kq hn dt translated">为了兼容，所有x86处理器都以16位实模式启动。当英特尔推出32位处理器时，32位指令隐藏在<a class="ae id" href="https://en.wikipedia.org/wiki/Protected_mode" rel="noopener ugc nofollow" target="_blank">保护模式</a>中。即使是现代的64位处理器也是以实模式启动，并调用专门的指令，最终进入64位指令可用的模式。当您在vm执行之前连接到qemu(使用<code class="eh ky kz la lb b">qemu -s -S</code>)时，gdb检测到处理器处于实模式，并适当地配置自己。</p><p id="38e3" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">不幸的是，在远程调试会话期间，gdb没有<a class="ae id" href="https://bugs.launchpad.net/ubuntu/+source/qemu-kvm/+bug/901944" rel="noopener ugc nofollow" target="_blank">很好地处理</a><a class="ae id" href="https://sourceware.org/bugzilla/show_bug.cgi?id=13984" rel="noopener ugc nofollow" target="_blank"/>模式切换。软件断点丢失，它不能正确解码来自远程端的数据包。更高版本的gdb和/或gdbserver可能会解决这个问题，但是有几个变通方法足以让我们重新开始:</p><ol class=""><li id="fca7" class="mc md ig jx b jy jz kb kc ke me ki mf km mg kq mh mi mj mk dt translated">使用硬件断点而不是软件断点。</li><li id="f6fe" class="mc md ig jx b jy ml kb mm ke mn ki mo km mp kq mh mi mj mk dt translated">在包回复错误之后，将一个新的gdb实例连接到服务器</li></ol></div><div class="ab cl kr ks hc kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hn ho hp hq hr"><p id="091f" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">数据包回复问题通过重新连接解决了，我可以通过gdb和几个qemu <a class="ae id" href="https://en.wikibooks.org/wiki/QEMU/Monitor#x" rel="noopener ugc nofollow" target="_blank">控制台命令</a>转储内存。kvmclock用来与主机通信的位置似乎肯定有一个值，但是不清楚那里有什么数据以及为什么它可能会被破坏。</p><p id="8beb" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我用一个新的内核又运行了一次，看看是否能发现任何不同之处。我注意到损坏的内核指的是实例化“引导时钟”，而工作的内核指的是“主时钟”。嗯，实例化主时钟的代码似乎在不同的位置。也许它实际上是在新内核中初始化失败，但由于某种原因没有挂起？</p><p id="22c6" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我花了太多时间试图找出主时钟的差异。在gdb中沮丧了几个小时后，我终于发现我看到的是一个旧版本的代码。在实际工作的内核代码中，主时钟的重复初始化已被删除，时钟的名称从“引导时钟”更改为“主时钟”。所以新内核实际上运行的是相同的代码。那是多么转移注意力的事啊！</p><p id="0b61" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">接下来，我试图去理解早期的内存分配过程。memblock分配器似乎通过查看内核报告的可用内存的末尾，然后切掉一个块，来找到最高的可用地址。据我所知，通过阅读代码，任何保留的部分只有在以后构造页表时才会被考虑。我开始认为在早期引导过程中有一个错误，在页表初始化之前的分配可能与BIOS保留的内存冲突。</p><p id="9619" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我的理论有几个问题:</p><ol class=""><li id="8a96" class="mc md ig jx b jy jz kb kc ke me ki mf km mg kq mh mi mj mk dt translated">像这样的大规模错误似乎不太可能通过<br/> 10多个主要版本的内核而不被发现。</li><li id="04ad" class="mc md ig jx b jy ml kb mm ke mn ki mo km mp kq mh mi mj mk dt translated">工作中的内核报告将kvmclock分配在与损坏的内核相同的位置，并且特定的地址看起来没问题。</li></ol><p id="a115" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果bug肯定在kvmclock代码中，也许memblock分配终究是没问题的。</p><p id="ebbb" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我再次尝试验证这个bug确实在kvmclock中。我注意到了几个命令行参数，它们似乎从客户机端控制时钟的初始化。尝试了这些参数的各种组合后，我发现如果我指定了<code class="eh ky kz la lb b">no-kvmclock</code>和<code class="eh ky kz la lb b">no-kvmclock-vsyscall</code>，那么客户机实际上会启动。这看起来像是问题出在kvmclock的铁证。</p><p id="fb94" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">最后我很幸运。在网上搜索kvmclock_init中的各种函数调用时，我偶然发现了一个非常有希望的<a class="ae id" href="https://bugzilla.kernel.org/show_bug.cgi?id=59521" rel="noopener ugc nofollow" target="_blank">错误报告</a>。详细信息指的是挂起，因为当有多个处理器时，kvmclock正在读取未初始化的内存。作为测试，我将处理器的数量减少到1。内核启动！这个bug报告绝对是关于我们的bug。</p><p id="b762" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这个bug的<a class="ae id" href="https://github.com/torvalds/linux/commit/07868fc6aaf57847b0f3a3d53086b7556eb83f4a" rel="noopener ugc nofollow" target="_blank">修复</a>是相当琐碎的。这是3.8中引入的一个简短的回归，在3.10中得到修复。其他发行版已经反向移植了它。我检查了UEK的来源，它没有被反向端口。最后一步是验证修复是否真正解决了我们的挂起问题。</p><p id="ae49" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我不喜欢做完整的内核构建，所以我启动gdb并在有问题的内存分配处设置一个断点。断点之后，我手动调用memset来清除内存，并继续引导。找到了。我有一个启用了kvmclock的3.8内核。我向UEK团队发送了一份错误报告，确信3.8内核的下一个版本将摆脱这个顽固的小错误。</p><p id="e49e" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">因此，事实证明，内核memblock分配很好。恰好它为kvmclock共享区分配了一些以前使用过的内存。由于实现中的一个微小变化，二级处理器的kvmclock的内存没有初始化，因此它试图读取一个垃圾值并永远循环下去。</p><p id="de41" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">第一部分中的解决方法是将kvmclock移动到内存中，而内存碰巧被初始化为零，这是一个副作用。知道这一点很好，因为如果引导过程中的某些东西(BIOS、iPXE或grub)碰巧在新位置写入数据，该解决方法将会失败。换句话说，我的解决方法大多是偶然的。</p><p id="003a" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">那么这个故事的寓意是什么呢？早点搜索现有的bug报告！我曾梦想在内核内存分配中找到一个有趣的问题，但如果我只是更直接地谷歌一下实际挂起周围的一些代码行，我会更快地发现关键错误报告。</p><p id="65d3" class="pw-post-body-paragraph jv jw ig jx b jy jz jh ka kb kc jk kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">对于三周的调试来说，一个错过的反向端口是一个合适的结论吗？也许不是。但至少知道了为什么我可怜的小内核不能启动，我会睡得更安稳。没有留下任何bug！</p><div class="mq mr ms mt fq ab cb"><figure class="mu hw mv mw mx my mz paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mu hw mv mw mx my mz paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mu hw mv mw mx my mz paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="na nb nc"><p id="f922" class="jv jw nd jx b jy jz jh ka kb kc jk kd ne kf kg kh nf kj kk kl ng kn ko kp kq hn dt translated"><a class="ae id" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae id" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae id" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae id" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jv jw nd jx b jy jz jh ka kb kc jk kd ne kf kg kh nf kj kk kl ng kn ko kp kq hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae id" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae id" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="mq mr ms mt fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="fe ff nh"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>