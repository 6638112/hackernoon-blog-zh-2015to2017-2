<html>
<head>
<title>Coding interview: recursion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编码面试:递归</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/coding-interview-recursion-f0d60c9dbb60?source=collection_archive---------7-----------------------#2017-10-11">https://medium.com/hackernoon/coding-interview-recursion-f0d60c9dbb60?source=collection_archive---------7-----------------------#2017-10-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/d803a4666d5ed271a06d5c16d40de2ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Oh0zhSpIwpAt1gaUjTXSw.jpeg"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek"><a class="ae ih" href="https://www.pexels.com/photo/books-school-stacked-closed-48126/" rel="noopener ugc nofollow" target="_blank">Image from here</a></figcaption></figure><div class=""/><div class=""><h2 id="e247" class="pw-subtitle-paragraph jh ij ik bd b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy ek translated">如何通过递归来接近和思考</h2></div><p id="f4dd" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我最近开始寻找我的下一个机会(如果你喜欢你的工作场所，请联系我！)，并注意到很多面试问题都围绕递归展开。事实上，我最近面试的12家公司中有4家在面试过程中问了一个递归问题。</p><p id="b2c2" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">你可能遇到过一个面试问题，这个问题应该在你职业生涯中的某个时候递归解决。</p><p id="b509" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">虽然我现在对递归理解得更好了，但是当我三年前第一次学习它的时候，我还是很纠结。以下是我在准备找工作时，通过解决几十个递归问题收集到的一些技巧。</p><p id="dec8" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><em class="kv">在我们开始之前，本文假设对什么是递归有一个基本的理解。注意:任何可以递归求解的问题也可以迭代求解。然而，对于某些类型的问题，递归解决方案更清晰，可读性更好，也更容易实现。我在这里谈论我是如何用一种对我有意义的方式来思考递归的，希望你们中的一些人也会发现我的方法是有帮助的。</em></p><h2 id="4608" class="kw kx ik bd ky kz la lb lc ld le lf lg ki lh li lj km lk ll lm kq ln lo lp lq dt translated">I .如何识别递归解决方案有意义的问题</h2><p id="ee62" class="pw-post-body-paragraph jz ka ik kb b kc lr jl ke kf ls jo kh ki lt kk kl km lu ko kp kq lv ks kt ku hn dt translated">简而言之，递归是一种通过将输入分解成越来越小的部分直到它不能再被分解而得到解决方案的方法。最终输出是通过将这些调用的输出与“较小的”输入放在一起计算的。</p><p id="d077" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如果一个问题的输入由不相等的嵌套值组成，而输出需要遍历输入，这是需要递归的好迹象。</p><p id="663a" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我见过的面试问题示例包括遍历嵌套散列，例如:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="ef57" class="kw kx ik mb b fv mf mg l mh mi">entertainment_materials = {<br/>  romance: {<br/>    comedy: {<br/>      movies: ['50 first dates', 'eternal sunshine'],<br/>      books: ["he's just not that into you :("],<br/>      articles: ['How I automated dating with a Tinder Bot']<br/>    }<br/>  },<br/>  action: {<br/>    movies: ['LOTR', 'Transformers 1'],<br/>    superhero: {<br/>      movies: ['Wonder Woman'],<br/>      books: ['Ironman comic', 'Batman comic'],<br/>      batman: {<br/>        movies: ['Lego Batman']<br/>      },<br/>      spiderman: {<br/>        movies: ['Homecoming']<br/>      }<br/>    }<br/>  }<br/>  ...<br/>}</span></pre><p id="2a23" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">或者嵌套数组，例如:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="fa75" class="kw kx ik mb b fv mf mg l mh mi">[7,[[1]], [1,[2,[3]]], 3, [4, 5], 9]</span></pre><p id="9d82" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">当然，这类问题绝非面面俱到。像二分搜索法、合并排序和树遍历这样的常见算法是用递归实现的。</p><p id="bde5" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">为了确定递归是否是正确的方法，我问自己:</p><p id="68c8" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><em class="kv">“通过一遍又一遍地调用一个方法，对我的原始输入进行某种‘截断’，从而得到一个输出，这有意义吗？”</em></p><p id="77e2" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">和</p><p id="93aa" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><em class="kv">“这个原始输入能以一种合理的方式被‘截断’以达到一个输出吗？”</em></p><p id="2784" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在本文中，我将讨论一个使用嵌套散列作为输入的问题。假设我应该<code class="eh mj mk ml mb b">find how many movies, books, and articles there are in the ‘entertainment_materials' directory</code>。同样，假设我们的解决方案应该是:<code class="eh mj mk ml mb b">{books: 0, movies: 0, articles: 0}</code>的格式。</p></div><div class="ab cl mm mn hc mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hn ho hp hq hr"><h2 id="4f32" class="kw kx ik bd ky kz la lb lc ld le lf lg ki lh li lj km lk ll lm kq ln lo lp lq dt translated">二。我如何写下我的解决方案</h2><p id="4162" class="pw-post-body-paragraph jz ka ik kb b kc lr jl ke kf ls jo kh ki lt kk kl km lu ko kp kq lv ks kt ku hn dt translated">当我遇到递归时，我问自己:</p><ol class=""><li id="22d7" class="mt mu ik kb b kc kd kf kg ki mv km mw kq mx ku my mz na nb dt translated">基本情况是什么？</li><li id="2121" class="mt mu ik kb b kc nc kf nd ki ne km nf kq ng ku my mz na nb dt translated">我如何到达基本情况？</li><li id="16d4" class="mt mu ik kb b kc nc kf nd ki ne km nf kq ng ku my mz na nb dt translated">如何通过调用堆栈聚合数据？</li></ol><h2 id="09ff" class="kw kx ik bd ky kz la lb lc ld le lf lg ki lh li lj km lk ll lm kq ln lo lp lq dt translated"><strong class="ak"> 1。基本情况是什么？</strong></h2><p id="f7d4" class="pw-post-body-paragraph jz ka ik kb b kc lr jl ke kf ls jo kh ki lt kk kl km lu ko kp kq lv ks kt ku hn dt translated">我认为基本情况是这样的:</p><p id="19af" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><em class="kv">“基本情况是当我们得到一个输入时，我们知道输出是什么。”</em></p><p id="99d1" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">因此，基本情况是终止递归的条件。</p><p id="d5a2" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在这里的例子中，基本情况是输入中没有任何东西可供我们循环。这可能是因为输入为零(或空散列)。当这种情况发生时，我们知道输出是<code class="eh mj mk ml mb b">{books: 0, movies: 0, articles: 0}</code>。</p><p id="b73c" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在我见过的所有涉及数组的递归问题中，基本情况是当<code class="eh mj mk ml mb b">input_array.length &lt;= 1</code>时。</p><p id="6e7f" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">因此，这个问题的解决方案可能会从以下内容开始:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="babe" class="kw kx ik mb b fv mf mg l mh mi">def count_materials_by_type(directory)<br/>  return { books: 0, movies: 0, articles: 0 } if directory.nil?</span><span id="28c9" class="kw kx ik mb b fv nh mg l mh mi">end</span></pre><h2 id="122e" class="kw kx ik bd ky kz la lb lc ld le lf lg ki lh li lj km lk ll lm kq ln lo lp lq dt translated">2.我如何到达基本情况？</h2><p id="c945" class="pw-post-body-paragraph jz ka ik kb b kc lr jl ke kf ls jo kh ki lt kk kl km lu ko kp kq lv ks kt ku hn dt translated">了解基本情况很重要。否则，我们会有无限递归。</p><p id="d74c" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在许多数组问题中，达到基本情况的方法要么是删除第一个元素，最后一个元素，要么是将数组分成两半。</p><p id="5cd5" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在这个嵌套散列问题中，遍历每个键/值对是有意义的。如果值是另一个散列，我们需要用那个“更小”的散列进行递归调用。</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="455d" class="kw kx ik mb b fv mf mg l mh mi">def count_materials_by_type(directory)<br/>  return { books: 0, movies: 0, articles: 0 } if directory.nil?</span><span id="286b" class="kw kx ik mb b fv nh mg l mh mi"> directory.each do |key, value|<br/>    if value.is_a?(Hash)<br/>      count_materials_by_type(value) # ensures that input into the recursive call keeps "shrinking" until it gets to the base case<br/>    end<br/>  end<br/>end</span></pre><p id="60c7" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">当然，除了返回目录本身，我们的方法不做任何事情。</p><p id="78f8" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在我们的例子中，每当我们在目录中遇到这些关键字时，我们需要增加书籍、电影和文章的数量。让我们调整方法，定义一个变量来跟踪这些信息</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="51d6" class="kw kx ik mb b fv mf mg l mh mi">def count_materials_by_type(directory)<br/>  result = { books: 0, movies: 0, articles: 0 }</span><span id="3057" class="kw kx ik mb b fv nh mg l mh mi">  return result if directory.nil? || directory.empty?</span><span id="0b15" class="kw kx ik mb b fv nh mg l mh mi">  directory.each do |key, value|<br/>    if key == :books || key == :movies || key == :articles<br/>      result[key] += value.length<br/>    end</span><span id="12eb" class="kw kx ik mb b fv nh mg l mh mi">    if value.is_a?(Hash)<br/>      count_materials_by_type(value)<br/>    end<br/>  end</span><span id="f2af" class="kw kx ik mb b fv nh mg l mh mi">  result<br/>end</span></pre><p id="4f75" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这仍然不起作用，如果我运行它，我得到</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="b922" class="kw kx ik mb b fv mf mg l mh mi">{ books: 0, movies: 0, articles: 0 }</span></pre><p id="eae5" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">原因是因为我在每个调用堆栈中将结果重置为<code class="eh mj mk ml mb b">{books: 0, movies: 0, articles: 0}</code>。因此，我实际上并没有<strong class="kb il"> </strong>跟踪或处理调用栈中的数据。</p><p id="1853" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在，我们开始讨论问题的实质。</p><h2 id="a530" class="kw kx ik bd ky kz la lb lc ld le lf lg ki lh li lj km lk ll lm kq ln lo lp lq dt translated">3.如何跨调用栈<strong class="ak"> <em class="ni">聚合数据？</em>T9】</strong></h2><p id="5931" class="pw-post-body-paragraph jz ka ik kb b kc lr jl ke kf ls jo kh ki lt kk kl km lu ko kp kq lv ks kt ku hn dt translated">不幸的是，这个是通过练习得来的。然而，好消息是，你对这种类型的问题练习得越多，你就会建立越多的直觉，直到你知道为止。</p><p id="2d92" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">从调用堆栈聚合输出的方式取决于问题。阅读<a class="ae ih" href="https://medium.freecodecamp.org/learn-recursion-in-10-minutes-e3262ac08a1" rel="noopener ugc nofollow" target="_blank">这篇文章</a>中的一些好例子。</p><p id="8ab9" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在这个特殊的例子中，方法是将<code class="eh mj mk ml mb b">result</code>散列传回到方法中。</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="d1fe" class="kw kx ik mb b fv mf mg l mh mi">def count_materials_by_type(directory, result = { movies: 0, books: 0, articles: 0})<br/>  return result if directory.nil?</span><span id="5bc7" class="kw kx ik mb b fv nh mg l mh mi">  directory.each do |key, value|<br/>    if key == :books || key == :movies || key == :articles<br/>      result[key] += value.length<br/>    end</span><span id="1eca" class="kw kx ik mb b fv nh mg l mh mi">    if value.is_a?(Hash)<br/>      count_materials_by_type(value, result)<br/>    end<br/>  end</span><span id="de08" class="kw kx ik mb b fv nh mg l mh mi">  result<br/>end</span></pre><p id="1c1d" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">返回值是包含电影、书籍和文章的结果散列。每当我们在循环中遇到另一个hash值时，我们再次将那个较小的hash值传递给方法。在输入没有嵌套散列之前，我们不会命中返回值。每个调用堆栈返回的结果包含电影、书籍和文章的更新计数。</p><p id="301e" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这是我对递归的思考过程:</p><ol class=""><li id="3467" class="mt mu ik kb b kc kd kf kg ki mv km mw kq mx ku my mz na nb dt translated">基本情况是什么？</li><li id="dc56" class="mt mu ik kb b kc nc kf nd ki ne km nf kq ng ku my mz na nb dt translated">我如何到达基本情况？</li><li id="62db" class="mt mu ik kb b kc nc kf nd ki ne km nf kq ng ku my mz na nb dt translated">如何在调用堆栈中聚合数据？</li></ol><p id="cf21" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">同样，就像其他技能一样，熟能生巧。所以继续编码，去搞定那个面试吧！:)</p><h1 id="fb4c" class="nj kx ik bd ky nk nl nm lc nn no np lg jq nq jr lj jt nr ju lm jw ns jx lp nt dt translated">如果你喜欢这个故事，给我一些掌声！</h1></div></div>    
</body>
</html>