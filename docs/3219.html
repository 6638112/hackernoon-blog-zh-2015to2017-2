<html>
<head>
<title>Why functional programming matters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么函数式编程很重要</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/why-functional-programming-matters-c647f56a7691?source=collection_archive---------0-----------------------#2017-03-21">https://medium.com/hackernoon/why-functional-programming-matters-c647f56a7691?source=collection_archive---------0-----------------------#2017-03-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="fd13" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我已经做了十六年的软件工程师，这些年来我参加了无数的工作面试，但我仍然对公司是如何做到这一点的感到惊讶。大多数工程职位的面试都侧重于算法和数据结构。考生必须回答这样的问题:如何找到一个给定和的数组中最长的子数组，他们的解有多复杂，如何改进等等。，通常是在白板上。白板会议旨在展示计算机科学的熟练程度，对大O符号等主题的理解，以及解决一般问题的技能。它们也是为了让面试官感受到如何与应聘者合作共事。</p><p id="ec03" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所有这些工作主要是日复一日地实现API端点，这些端点除了执行简单的数据库查询、对结果进行排序并以JSON格式返回这些结果之外什么也不做，每秒钟可能要执行数千次。计算上最复杂的步骤可能是排序部分，即便如此，通常看起来也像这样</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="f0ca" class="jy jz hu ju b fv ka kb l kc kd">collection.sort()</span></pre><p id="9bdd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是可以理解的。这些公司中的绝大多数都在构建某种平台，将以前由两个人通过电话交换数据或由人类代表从客户那里获取数据来完成的简单任务自动化。自动将数据从一个地方移动到另一个地方并存储在那里的平台。这是迄今为止自动化的日常现实。当然，最近有越来越多的数据科学和机器学习相关的职位，但一个普通的软件开发人员仍然有更大的机会被雇佣来实现另一个API，最多可能解决跨集群分发API调用的挑战。大多数开发人员并不真的编写太多实际计算的代码，而只是将各种组件连接在一起，在它们之间移动数据。</p><p id="3311" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">雇佣一名软件开发人员可能会非常昂贵。那么，计算机科学能力测试真的是这笔钱的最佳用途吗？而建立一个高效的开发团队来做以上事情的最好方法是什么？知道如何平衡二叉查找树真的是一项普通商业成功所依赖的关键工程技能吗？如果不是，那是什么？</p><figure class="jp jq jr js fq kg fe ff paragraph-image"><a href="https://forrestbrazeal.com/2016/07/27/cloudpleasers-real-world-coding-interview/"><div class="fe ff kf"><img src="../Images/d3cd0834cd54a0188cd5beca3a49fc4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hh62emcQF6UzfNzikrkMrg.png"/></div></a></figure><h2 id="a77f" class="jy jz hu bd kj kk kl km kn ko kp kq kr jc ks kt ku jg kv kw kx jk ky kz la lb dt translated">变化</h2><p id="9028" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">如果一家公司雇佣软件工程师，他们业务的关键部分很有可能以计算机代码的形式存在。因此，业务的增长与代码的可维护性紧密相关。企业不断适应和成长，它们永远在变化。每天都有新功能和新产品提供给客户。现有功能被重新审视，战略被修订，整个商业模式被改变。</p><p id="302e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了管理所有这些变化，公司倾向于关注过程、实践、项目管理技术和开发方法、组织考虑和团队结构，以及系统设计和架构模式。虽然把所有这些都做好是平稳增长的基础，但这些都没有考虑到这样一个事实，即随着业务被编码为计算机代码，代码库本身也处于不断变化的状态。与公司的其他部分一样，代码库也必须能够处理和适应不断的变化，而不会对业务造成任何干扰。</p><p id="ba89" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，有实际的方法学建立在这种永久增量改进的思想之上。敏捷和精益方法要求代码库能够从第一天开始，从第一行代码就管理和处理变更。那是写<em class="lh">换</em>的。</p><p id="ad1e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一家公司最昂贵的员工不会把大部分时间花在实现聪明的算法来解决棘手的问题上，而是——除了用这个一行程序对集合进行排序之外——挠头思考如何保持代码库对变化的低阻力。因此，擅长这一点，并拥有能够编写可维护代码的技能——代码，一个不断增长和波动的团队可以一起工作，不断增长和改变它，实现新功能和修改现有功能，而不会中断——似乎比很好地理解Floyd-Warshall算法或具有拜占庭容错的分布式系统更重要。</p><p id="cafa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是这些技能到底是什么呢？可维护的代码到底意味着什么，软件开发候选人需要在这方面有专长？如何保持代码库对变化的低阻力，以便每隔几年就可以不间断地添加越来越多的功能，雇佣越来越多的开发人员更快地添加新功能，并且需要越来越少的完全重写？</p><h2 id="f4f9" class="jy jz hu bd kj kk kl km kn ko kp kq kr jc ks kt ku jg kv kw kx jk ky kz la lb dt translated">变革的遏制</h2><p id="57a9" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">我们都知道九个女人一个月生不出一个孩子的说法，但到底是什么阻止了通过团队规模翻倍来实现交付速度翻倍呢？如果团队与代码库一起成长，那么每个开发人员的代码量保持不变，每个开发人员需要拥有、理解和维护相同数量的代码。但是代码的绝对数量并不是决定它对改变的阻力。正如一个成长中的团队带来了项目管理挑战，增加了任务的相互依赖性，或者产品开发挑战，增加了特性的相互依赖性，一个成长中的代码库增加了代码部分的相互依赖性。相互依赖意味着代码的某些特定部分不能在不影响其他部分的情况下被修改。随着团队和代码库的增长，这需要越来越多的协调。</p><p id="5e85" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一种看待这个问题的方式是，变化沿着这些相互依赖的关系传播和繁殖，所以为了控制变化，边界是需要的。类似于划分也是遏制失败的一种方式。但是对于编写代码来说，划分意味着与运行程序稍有不同。边界不只是在任何随机的地方将较大的东西分成较小的部分，而是将抽象层分开。代码的划分是通过模块化和组合性实现的:以这样一种方式组织代码库，整体由更小的、可重用的构建块组成(这些构建块进一步由更小的构建块组成，等等)，这种组合不是特别的，而是遵循定义良好的规则。因此，要理解和推理整体，一个人必须只理解构成的积木和规则。</p><p id="3b95" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种方法将代码库从专门化代码部分之间任意相互依赖的网络转变成可重用的构建块集，这些构建块集可以系统地组合成更大的块。我们所说的系统化是指遵循规则或法律。一组具有合成法则的构建块是一种领域语言。包含变更并因此减少代码库对变更的阻力的关键是编写问题领域的<em class="lh">理论</em>的代码，而不是特定问题的解决方案。问题领域的理论基本上是最通用的领域语言，也就是声音，并且仍然只允许构建块的正确组合。这样，随着业务的增长和发展，新的问题和新的解决方案可以用同一种语言来描述和表达，从而很容易合并到代码库中。</p><p id="5413" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是著名计算机科学家<a class="ae ke" href="http://www.pmg.csail.mit.edu/~liskov/turing-09-5.pdf" rel="noopener ugc nofollow" target="_blank">芭芭拉·利斯科夫</a>对此的看法:</p><blockquote class="li lj lk"><p id="b9f3" class="ir is lh it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated">基于抽象的模块化是完成事情的方式</p></blockquote><p id="e0f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者什么<a class="ae ke" href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-10.html" rel="noopener ugc nofollow" target="_blank">计算机程序的结构和解释</a>，哈罗德·艾贝尔森和杰拉德·让伊·萨斯曼的一本书中说:</p><blockquote class="li lj lk"><p id="bc4a" class="ir is lh it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated">这种分解策略的重要性不仅仅在于将程序分成几个部分。[……]相反，至关重要的是，每个程序完成一个可识别的任务，该任务可用作定义其他程序的模块。[……]不完全是程序，而是程序的抽象，所谓的程序抽象。[……]程序的用户可能不是自己编写的，而是从另一个程序员那里作为黑盒获得的。用户不需要知道该过程是如何实现的就可以使用它。</p></blockquote><p id="d037" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者是罗纳·比雅纳松在他的<a class="ae ke" href="https://www.youtube.com/watch?v=hzf3hTUKk8U&amp;feature=youtu.be&amp;t=1234" rel="noopener ugc nofollow" target="_blank">函数式编程是可怕的</a>东北Scala研讨会上的讲话:</p><blockquote class="li lj lk"><p id="0ce0" class="ir is lh it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated">可组合性是一种属性，通过理解软件的各个部分以及控制组合的规则，可以将软件理解为一个整体。</p><p id="6e3e" class="ir is lh it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated">模块化是这样一种属性，你的软件可以被分成它的组成部分，这些部分可以独立于整体被重用，以一种你在创建这些部分时没有预料到的新方式。</p></blockquote><p id="b05f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是软件开发人员候选人需要擅长的:编写模块化的、组合的代码，理解各种抽象方法，从而能够合作创建领域理论。除了算法和数据结构之外，这些是公司应该测试的技能，因为这些是应对挑战所需的技能，这些挑战决定了一个普通开发人员的工作日。在大多数情况下，选择这些技能可以保证最高效的团队，为企业提供最佳价值。</p><p id="5993" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是如何测试与编写模块化、组合式代码相关的技能呢？到底为什么函数式编程很重要？</p><h2 id="af4a" class="jy jz hu bd kj kk kl km kn ko kp kq kr jc ks kt ku jg kv kw kx jk ky kz la lb dt translated">函数式编程</h2><p id="921d" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">命令式编程就像构建装配线，它将一些初始全局状态作为原材料，在这些材料被推过生产线时对其应用各种特定的转换和突变，并在最后产生最终产品，即最终的全局状态，它代表了计算的结果。每一步都需要以特定的方式精确地改变、旋转、按摩工件，以便为下游的后续步骤做好准备。下游每一步都依赖于前面的每一步，因此它们的顺序是固定不变的。由于这些依赖性，一个单独的计算步骤本身并没有太多的用途和意义，而只是在所有其他步骤的上下文中才有意义，为了理解它，必须理解整条线是如何工作的。全局可变状态在代码的所有部分之间创建了相互依赖关系，而编程语言没有提供显式表达这些关系的方法。装配线只生产一种产品，如果要生产一种新产品，就需要一条新的装配线。它们代表了特定问题的特定解决方案。</p><p id="df59" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">面向对象编程是流水线模块化的一个拙劣的尝试。不仅仅是因为，这样做引入了某种随意的组合方式，比如成员和继承。但主要是因为封装实现的只是将全局可变状态分解成更小的部分，然后隐藏在称为类的模块中。但它并没有真正改变装配线的基本模式，也没有解决相互依赖的根本问题。它覆盖(封装)了装配线的较大部分，但这些部分很少能以意想不到的方式重新安排。即使如此，也没有系统的和经过验证的方法来做到这一点(除非我们认为GoF设计模式也是如此)。</p><p id="126f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">真正模块化的关键不是放弃全局状态，而是放弃可变状态。通过放弃有效的程序，并把它们换成纯粹的功能，作为计算的基本构件。这种看似限制性的折衷使编程中的函数更接近数学中的函数概念，而远离过程。如果我们使用纯函数作为抽象的基本单位，并且这些函数组成为数学函数:<em class="lh"> f ∘ g </em>，并且这种组成遵循以下定律:<em class="lh"> f ∘ (g ∘ h) = (f ∘ g) ∘ h </em>和<em class="lh"> f ∘ id = f = id ∘ f </em>，那么我们就获得了一种系统的和经过验证的方法来组成更小部分的更大部分，这种方法在每一个层次、每一个尺度上都有效。更小的函数可以无限组合成更大的函数，这种组合感觉比继承和类成员更自然严谨。这打开了一个随时可用的数学抽象库。</p><p id="9a74" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">纯函数不是受限制的过程，而是更高层次的抽象，转化为不纯的过程。程序员必须只关心后者，就像电影摄影师关心摄影机如何工作一样。函数式编程在流水线上进行抽象，它把计算机程序变成大型数学公式，我们已经知道如何推理。它将描述、推理和解决问题提升到抽象科学的高度:数学。这是理论的理论。</p><p id="b6a2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是函数式编程如此重要的原因，因为它只是创建问题领域理论的一种优越方法。命令式编程和函数式编程方法之间的差异反映了对更改具有高阻力和低阻力的代码之间的差异:一个由特定的相互依赖的代码部分组成的错综复杂的网络与一个由构建块分层组成的系统，在每一层上都遵循简单的组合规则。因此，测试候选人编写模块化和组合代码相关技能的最简单方法是测试他们的函数式编程技能。理解<a class="ae ke" href="http://lambdaconf.us/downloads/documents/lambdaconf_slfp.pdf" rel="noopener ugc nofollow" target="_blank">关键的函数式编程概念</a>，如纯函数、函数组合、currying和局部应用、递归数据结构、代数数据类型、一元组合、类型类、透镜、一元转换器等。，是一个很好的指标，表明候选人可以编写代码，并在不阻碍业务增长和发展的代码上进行合作。</p><div class="jp jq jr js fq ab cb"><figure class="lo kg lp lq lr ls lt paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="lo kg lp lq lr ls lt paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="lo kg lp lq lr ls lt paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="li lj lk"><p id="f922" class="ir is lh it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><a class="ae ke" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ke" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ke" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ke" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is lh it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ke" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ke" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jp jq jr js fq kg fe ff paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="fe ff lu"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="jp jq jr js fq kg"><div class="bz el l di"><div class="lz ma l"/></div></figure></div></div>    
</body>
</html>