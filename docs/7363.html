<html>
<head>
<title>Redux TDD: a deep dive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redux TDD:深度潜水</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/redux-tdd-a-deep-dive-344cd7682a54?source=collection_archive---------11-----------------------#2017-10-25">https://medium.com/hackernoon/redux-tdd-a-deep-dive-344cd7682a54?source=collection_archive---------11-----------------------#2017-10-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="2541" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">这是对</em><a class="ae jq" href="https://github.com/lmatteis/redux-tdd" rel="noopener ugc nofollow" target="_blank"><em class="jp">redux-TDD</em></a><em class="jp">项目及其API如何工作的描述。如果你正在寻找关于redux测试驱动开发的更高层次的解释，请查看</em> <a class="ae jq" href="https://medium.freecodecamp.org/test-driven-development-with-react-and-redux-using-redux-tdd-3fd3be299918" rel="noopener ugc nofollow" target="_blank"> <em class="jp">我的freeCodeCamp文章</em> </a> <em class="jp">。</em></p><p id="6c5e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jq" href="https://github.com/lmatteis/redux-tdd" rel="noopener ugc nofollow" target="_blank"> Redux TDD </a>是一个简单的库，让你以测试驱动的<a class="ae jq" href="https://hackernoon.com/tagged/development" rel="noopener ugc nofollow" target="_blank">开发</a> (TDD)方式测试<a class="ae jq" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank"> React </a>组件以及Redux数据流。</p><p id="e3b7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在API的几次迭代之后，我想到了一个简单的抽象，它不太关注组件或状态的实现细节，而是更多地关注分派的动作和组件应该接收的道具:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="0a52" class="ka kb hu jw b fv kc kd l ke kf">import <strong class="jw hv">reduxTdd</strong> from 'redux-tdd';<br/><br/><strong class="jw hv">reduxTdd</strong>({ counter: counterReducer }, state =&gt; [<br/>  &lt;Counter<br/>    onClick={incrementAction}<br/>    counter={state.counter.count} /&gt;<br/>])<br/>.<strong class="jw hv">action</strong>(props =&gt; props.onClick())<br/>.<strong class="jw hv">toMatchProps</strong>({ counter: 1 })<br/>.<strong class="jw hv">contains</strong>(&lt;span&gt;1&lt;/span&gt;)</span></pre><p id="e8a7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在上面这段代码中，我们<a class="ae jq" href="http://airbnb.io/enzyme/docs/api/shallow.html" rel="noopener ugc nofollow" target="_blank">浅渲染</a>(来自enzyme)了<strong class="it hv">计数器</strong>组件，并向其传递映射到状态特定部分的道具。</p><p id="1678" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">计数器</strong>属性映射到状态值<strong class="it hv"> state.counter.count </strong>。事实上，<code class="eh kg kh ki jw b">state =&gt; []</code>函数不仅充当我们的渲染函数，还充当我们的<strong class="it hv"> mapStateToProps </strong>函数。</p><p id="6cb1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">作为第一个参数reduxTdd采用我们的reducers，因此我们的状态的形状。</p><p id="d911" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来我们称之为<code class="eh kg kh ki jw b">.action(props =&gt; props.onClick())</code>,这是奇迹发生的地方。传递给<strong class="it hv"> action </strong>操作符的回调所返回的任何内容都将被调度(尽管我们没有使用redux的调度——稍后会详细介绍)。</p><p id="1af1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，动作操作符将更新内部状态，并根据这种新状态更新组件的属性。</p><p id="be6e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> toMatchProps </strong>和<strong class="it hv"> contains </strong>此时只需检查我们的组件在动作被调度后是否收到了正确的值。</p></div><div class="ab cl kj kk hc kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hn ho hp hq hr"><h1 id="8210" class="kq kb hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">TodoList示例</h1><p id="ed0d" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">在下一个例子中，我们将尝试以TDD的方式实现一个简单的TodoList还有什么😄？</p><p id="d8a7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们首先简单地将尚不存在的TodoList组件传递给reduxTdd:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="7e23" class="ka kb hu jw b fv kc kd l ke kf">reduxTdd({}, state =&gt; [ &lt;TodoList /&gt; ])</span></pre><p id="36ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的列表项可能存在于state中，所以接下来让我们引入一个<code class="eh kg kh ki jw b">list</code>缩减器，并将其作为一个名为“list items”的道具传递给我们的组件。</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="0d57" class="ka kb hu jw b fv kc kd l ke kf">reduxTdd({ list }, state =&gt; [ &lt;TodoList listItems={state.list} /&gt; ])</span></pre><p id="8ee0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">运行这个当然会失败，因为还没有实现任何东西，但是让我们在实现我们的逻辑之前写更多的测试。</p><p id="7c33" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">todo-list意味着有一个输入框，您可以在其中添加todo，所以让我们也添加一个AddTodo组件(记住我们返回一个数组，以便我们可以测试多个组件):</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="82a9" class="ka kb hu jw b fv kc kd l ke kf">reduxTdd({ list }, state =&gt; [ <br/>  &lt;TodoList listItems={state.list} /&gt;,<br/>  &lt;AddTodo onAdd={addTodo} /&gt;<br/>])</span></pre><p id="0a4a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">很好，现在让我们继续上面例子中的点链接，并通过调用<code class="eh kg kh ki jw b">onAdd</code>动作创建器来实际模拟添加一个todo:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="9607" class="ka kb hu jw b fv kc kd l ke kf">.it('should add todo items')<br/>.switch(AddTodo) // the next dot-chained calls will work on AddTodo<br/>.action(props =&gt; props.onAdd('clean house')) // add 'clean house'</span></pre><p id="b1d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以接下来我们应该会在TodoList看到“清洁之家”todo，对吗？让我们测试一下:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="77f8" class="ka kb hu jw b fv kc kd l ke kf">.switch(TodoList) // back to TodoList<br/>.toMatchProps({ listItems: ["clean house"] })</span></pre><p id="1e00" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们甚至可以添加另一个todo:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="652f" class="ka kb hu jw b fv kc kd l ke kf">.switch(AddTodo).action(props =&gt; props.onAdd('water plants'))<br/>.switch(TodoList).toMatchProps({ listItems: [<br/>  "clean house",<br/>  "water plants"<br/>]})</span></pre><p id="8156" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">很好，这就足够了，让我们运行这段代码，开始实现我们的组件、减少器和动作:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="5bf3" class="ka kb hu jw b fv kc kd l ke kf">const TodoList = ({ listItems }) =&gt; <br/>  &lt;div&gt;{listItems.map(item =&gt; &lt;div&gt;{item}&lt;/div&gt;)}&lt;/div&gt;</span><span id="a1b0" class="ka kb hu jw b fv ls kd l ke kf">const AddTodo = ({ onAdd }) =&gt;<br/>  &lt;button onClick={onAdd}&gt;add todo&lt;/button&gt;</span></pre><p id="b0ea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(提示:AddTodo中有意省略了文本输入逻辑)</p><p id="73f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的addTodo操作:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="c01a" class="ka kb hu jw b fv kc kd l ke kf">function addTodo(todoText) {<br/>  return { type: 'ADD_TODO', payload: todoText }<br/>}</span></pre><p id="c74f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后是我们的减速器:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="1dab" class="ka kb hu jw b fv kc kd l ke kf">function list(state = {}, action) {<br/>  switch (action.type) {<br/>    case 'ADD_TODO':<br/>      return { ...state, [action.payload]: {} }<br/>    default:<br/>      return state<br/>  }<br/>}</span></pre><p id="7110" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们再次运行我们的代码，有些事情会失败:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="131f" class="ka kb hu jw b fv kc kd l ke kf">TypeError: listItems.map is not a function</span></pre><p id="d95d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是因为我们的state.list是一个对象，但listItems属性需要一个数组。让我们使用一个选择器来解决这个问题(如果你愿意，你甚至可以使用<a class="ae jq" href="https://github.com/reactjs/reselect" rel="noopener ugc nofollow" target="_blank">重新选择</a>)❤️</p><p id="157b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们最初的reduxTdd定义中，让我们改变状态映射到TodoList组件的props的方式:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="1a39" class="ka kb hu jw b fv kc kd l ke kf">reduxTdd({ list }, state =&gt; [ <br/>  &lt;TodoList listItems={getVisibleItems(state)} /&gt;,</span></pre><p id="1a6c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">选择器:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="76ee" class="ka kb hu jw b fv kc kd l ke kf">function getVisibleItems(state) {<br/>  return Object.keys(state.list).length<br/>    ? Object.keys(state.list).map(key =&gt; key)<br/>    : []<br/>}</span></pre><p id="cf9c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，如果我们再次运行测试，我们会得到:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="6dfa" class="ka kb hu jw b fv kc kd l ke kf">TodoList<br/>    ✓ should add todo items (1ms)</span></pre><h1 id="f147" class="kq kb hu bd kr ks lt ku kv kw lu ky kz la lv lc ld le lw lg lh li lx lk ll lm dt">🎉</h1><p id="c415" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">让我们也TDD一下“将待办事项设置为完整”的想法。</p><p id="8182" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为此，我认为应该有一个TodoItem组件，是可点击的吧？让我们将它添加到我们的初始列表中:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="9fcd" class="ka kb hu jw b fv kc kd l ke kf">reduxTdd({ list }, state =&gt; [<br/>  &lt;TodoList listItems={getVisibleItems(state)} /&gt;,<br/>  &lt;AddTodo onAdd={addTodo} /&gt;,<br/>  &lt;TodoItem onClick={completeTodo} /&gt;<br/>])</span></pre><p id="9821" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是有个问题！TodoItem必须知道它必须完成哪一项。它必须对单个项目起作用，但是在我们的状态中，我们保留一个对象！要解决这个问题，我们可以简单地从state.list对象中传递一个条目:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="b150" class="ka kb hu jw b fv kc kd l ke kf">reduxTdd({ list }, state =&gt; [<br/>  &lt;TodoList listItems={getVisibleItems(state)} /&gt;,<br/>  &lt;AddTodo onAdd={addTodo} /&gt;,<br/>  &lt;TodoItem onClick={completeTodo} <strong class="jw hv">item</strong>={state.list['water plants']}    <br/>/&gt;<br/>])</span></pre><p id="2abf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，我们将其标记为完成:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="7e00" class="ka kb hu jw b fv kc kd l ke kf">.switch(TodoItem)<br/>.action(props =&gt; props.onClick('water plants'))</span></pre><p id="8882" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此时，我们意识到我们的TodoList组件无法显示该项是否完整(应该有一条删除线)。因此，我们传递一个新的“completedItems”属性，它是一个完整项目的数组:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="475c" class="ka kb hu jw b fv kc kd l ke kf">.switch(TodoList)<br/>.toMatchProps({ <br/>  listItems: ["clean house", "water plants"] <br/>  <strong class="jw hv">completedItems</strong>: ["water plants"]<br/>})</span></pre><p id="5736" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们再次改变我们的定义来为这样的行为工作:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="7857" class="ka kb hu jw b fv kc kd l ke kf">reduxTdd({ list }, state =&gt; [<br/>  &lt;TodoList <br/>    listItems={getVisibleItems(state)} <br/>    completedItems={getCompletedItems(state)} /&gt;,<br/>...</span></pre><p id="9d7f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们运行测试，他们会告诉我们一些需要实现的东西，比如我们的completeTodo操作创建器:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="f806" class="ka kb hu jw b fv kc kd l ke kf">function completeTodo(todoText) {<br/>  return { type: 'COMPLETE_TODO', payload: todoText }<br/>}</span></pre><p id="32ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们相应地更新了我们的减速器:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="b171" class="ka kb hu jw b fv kc kd l ke kf">function list(state = {}, action) {<br/>  switch (action.type) {<br/>    case 'ADD_TODO':<br/>      return { ...state, [action.payload]: {} }<br/>    case 'COMPLETE_TODO':<br/>      return { ...state, [action.payload]: { status: 'complete' } }<br/>    default:<br/>      return state<br/>  }<br/>}</span></pre><p id="e26c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">再次运行我们的测试将告诉我们getCompletedItems丢失了:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="7bd2" class="ka kb hu jw b fv kc kd l ke kf">function getCompletedItems(state) {<br/>  return Object.keys(state.list)<br/>    .map(item =&gt; state.list[item])<br/>    .filter(item =&gt; item.status === 'complete')<br/>}</span></pre><p id="58f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们完事了。</p><p id="45b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以更进一步，使用其他操作符，如<strong class="it hv"> contains </strong>和<strong class="it hv"> view </strong>来测试UI中更细粒度的部分。但是我们应用程序的主要部分是以TDD的方式一步一步实现的。</p><p id="67e1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">更重要的是，我们不必事先就我们的状态或道具做出复杂的工程决策。我们在前进的过程中，在看到需要的时候，实施了这些措施。</p><p id="bb9f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我希望这些例子能帮助您理解Redux TDD背后的思想，以及如何在您自己的项目中使用它。要查看更复杂的示例，请查看repo中的<a class="ae jq" href="https://github.com/lmatteis/redux-tdd/tree/master/test" rel="noopener ugc nofollow" target="_blank"> tests/ </a>文件夹。你会发现另一个重要的操作符叫做<strong class="it hv"> epic </strong>，它可以用来测试异步行为！</p><p id="5265" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">谢谢，TDD快乐🤗</p><figure class="jr js jt ju fq ly"><div class="bz el l di"><div class="lz ma l"/></div></figure></div></div>    
</body>
</html>