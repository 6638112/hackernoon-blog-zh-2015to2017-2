<html>
<head>
<title>Faster Clojure Reduce</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更快的Clojure减少</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/faster-clojure-reduce-57a104448ea4?source=collection_archive---------8-----------------------#2017-12-03">https://medium.com/hackernoon/faster-clojure-reduce-57a104448ea4?source=collection_archive---------8-----------------------#2017-12-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="0f7e" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">摘要</h1><p id="76e5" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">并不总是转换或迭代集合的最快方式。尤其是如果:1。涉及到原始数学。需要多个累加器或3。涉及多个序列。</p><h2 id="b8f8" class="kr is hu bd it ks kt ku ix kv kw kx jb ka ky kz jf ke la lb jj ki lc ld jn le dt translated">介绍</h2><p id="6e89" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">Clojure中的许多函数都可以对序列进行迭代。还有<code class="eh kn ko kp kq b">map</code>、<code class="eh kn ko kp kq b">filter</code>、<code class="eh kn ko kp kq b">keep</code>、<code class="eh kn ko kp kq b">mapcat</code>等等。通常，如果没有一个标准的序列转换函数适合，开发人员倾向于回到<code class="eh kn ko kp kq b">reduce</code>，更少的是手动<code class="eh kn ko kp kq b">loop</code>。后两者非常灵活，因为你可以做任何你想做的转换</p><ol class=""><li id="0f06" class="lf lg hu jr b js lh jw li ka lj ke lk ki ll km lm ln lo lp dt translated">简化为单一值</li><li id="c66b" class="lf lg hu jr b js lq jw lr ka ls ke lt ki lu km lm ln lo lp dt translated">忽略(过滤)一些值</li><li id="a4b7" class="lf lg hu jr b js lq jw lr ka ls ke lt ki lu km lm ln lo lp dt translated">映射一些值</li><li id="35c0" class="lf lg hu jr b js lq jw lr ka ls ke lt ki lu km lm ln lo lp dt translated">添加更多值</li></ol><p id="1ee5" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">同时进行。<code class="eh kn ko kp kq b">reduce</code>也有非常快的名声，因为每个集合本身都会运行它自己的优化缩减代码。</p><h2 id="2588" class="kr is hu bd it ks kt ku ix kv kw kx jb ka ky kz jf ke la lb jj ki lc ld jn le dt translated">问题</h2><p id="56bb" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">在这篇文章中，我将讨论两个问题:</p><ol class=""><li id="de60" class="lf lg hu jr b js lh jw li ka lj ke lk ki ll km lm ln lo lp dt translated">化简为多个值<br/>如:<br/> - <em class="ly">统计所有正数，统计所有奇数</em>-<br/>-<em class="ly">计算集合中所有数的和与积(迭代一次)</em></li><li id="7f4c" class="lf lg hu jr b js lq jw lr ka ls ke lt ki lu km lm ln lo lp dt translated">同时迭代多个序列。<br/>如:<br/> - <em class="ly">计算向量的转置<br/> -从一个向量中选择所有值给定另一个向量</em></li></ol><p id="25e1" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">在示例中，我将使用vectors，因为当您关心性能时，这是最常用的数据类型。</p></div><div class="ab cl lz ma hc mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hn ho hp hq hr"><p id="c930" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">让我们从问题#1开始:为了保持代码简单，我们将计算1000万个数字的奇数值和偶数值:</p><figure class="mh mi mj mk fq ml fe ff paragraph-image"><div class="fe ff mg"><img src="../Images/8b35e747eadf8b26f916bd1bb366552f.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*VVAYKdiz31ZENnjQSHuuzw.png"/></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">229ms</figcaption></figure><p id="1164" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">使用Criterium和一个正确配置的JVM，这个过程大约需要229毫秒。作为对比:一个简单的<code class="eh kn ko kp kq b">(reduce (fn [s _] (inc s)) 0 xs)</code>大约运行82毫秒。因为我们有两个累加器，而不是一个，所以几乎慢了3倍。</p><p id="0740" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">我们能做得更好吗？让我们来试试一个简单的手动<code class="eh kn ko kp kq b">loop</code>:</p><figure class="mh mi mj mk fq ml fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/16a307fd5abcef13a6b6031e16c287ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*lh6VB_EO6laU9ip0bsk8ww.png"/></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">148ms</figcaption></figure><p id="2fd1" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">这大约需要148毫秒。为什么会快这么多？多重原因:</p><ol class=""><li id="4d43" class="lf lg hu jr b js lh jw li ka lj ke lk ki ll km lm ln lo lp dt translated">我们并不是在每次迭代中都要析构一个新的向量。</li><li id="f67f" class="lf lg hu jr b js lq jw lr ka ls ke lt ki lu km lm ln lo lp dt translated">我们在循环内部做简单的数学运算。</li></ol><p id="a7f3" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">然而，对于这样一个简单的<code class="eh kn ko kp kq b">even? — odd?</code>比较，它仍然比82毫秒的基线慢得多。</p><p id="cd1f" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">在内部，向量由长度为32的Java数组块组成。对<code class="eh kn ko kp kq b">next</code>的调用返回向量部分的顺序视图(a <code class="eh kn ko kp kq b">ChunkedSeq</code>)。所以这个<code class="eh kn ko kp kq b">loop</code>在每次迭代中生成一个新的对象，只是为了在循环的下一次迭代中丢弃它。这意味着我们产生了JVM需要收集的垃圾。</p><p id="636b" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">显然，迭代这个向量数组是最快的。这正是<code class="eh kn ko kp kq b">reduce</code>在内部所做的。我们能以某种方式访问这个原始数组并编写我们自己的循环吗？许多函数和宏都知道分块序列，这也是<code class="eh kn ko kp kq b">map</code>在向量上相当快的原因。</p><p id="cf8a" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">另一个候选是<code class="eh kn ko kp kq b">doseq</code>，它遍历分块缓冲区(运行<code class="eh kn ko kp kq b">(macroexpand '(doseq [x xs] “abc”))</code>来看看如何)。让我们使用一些技巧来加快速度:</p><figure class="mh mi mj mk fq ml fe ff paragraph-image"><div class="fe ff mt"><img src="../Images/36d6698839927d92efbfbed96d44320c.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*ru4il35DvGsBIg3im0GjzA.png"/></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">109ms</figcaption></figure><p id="e3ac" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">这大约需要109毫秒。更好！但是现在我们离开了我们美好的不可变领域，代码变得相当丑陋。此外，这种方法仅适用于有限的累加器集。如果我们想累积成另一个向量或持久地图呢？它是不灵活的。另一个更糟糕的版本是使用数组并对其进行变异:</p><figure class="mh mi mj mk fq ml fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/ad358076e4d5971f25c0399cbc8cc887.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*5q_g5PfL9vsk3GFDg8fs1w.png"/></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">73ms</figcaption></figure><p id="66a4" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">这大约需要73毫秒。非常快，但是如果我们想累加除了数字以外的值，这种方法非常难看，容易出错，而且不灵活。</p></div><div class="ab cl lz ma hc mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hn ho hp hq hr"><h2 id="8939" class="kr is hu bd it ks kt ku ix kv kw kx jb ka ky kz jf ke la lb jj ki lc ld jn le dt translated">被遗忘的方法</h2><p id="d659" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">最后，让我们介绍一下这篇文章所涉及的结构:使用<code class="eh kn ko kp kq b">Iterator</code>。大多数语言都有某种迭代器，Java非常简单，它们的接口上只有两个方法:<code class="eh kn ko kp kq b">it.hasNext()</code>和<code class="eh kn ko kp kq b">it.next()</code>。让我们使用它:</p><figure class="mh mi mj mk fq ml fe ff paragraph-image"><div class="fe ff mv"><img src="../Images/7f46b9711d0bcf638d212b90cc4e95c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/1*BVPbF_wt2p7YLmlPZLZliA.png"/></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">70ms</figcaption></figure><p id="c5fe" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">这大约需要70毫秒。它只比使用可变数组方法快一点点，但是我们更加灵活:我们可以累积任何我们想要的值！迭代器非常快，因为它在每次迭代中产生很少的垃圾，并且对大多数数据结构都有快速的实现。<code class="eh kn ko kp kq b">it.hasNext()</code>检查只进行索引比较，而<code class="eh kn ko kp kq b">it.next()</code>只调用<code class="eh kn ko kp kq b">PersistenVector</code>的索引查找。</p><p id="98ff" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">附注:我写了一个宏，它手动迭代分块缓冲区，类似于<code class="eh kn ko kp kq b">doseq</code>，但也在循环中累加奇数/偶数。它的运行速度只快了7%(低至约65毫秒)。我不会在这里展示它，因为它不太灵活，只适用于vector，并且对分块序列的内部进行假设。</p><h2 id="f7a3" class="kr is hu bd it ks kt ku ix kv kw kx jb ka ky kz jf ke la lb jj ki lc ld jn le dt translated">一个宏诞生了</h2><p id="996e" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">让我们写一个宏使生活变得更容易:</p><figure class="mh mi mj mk fq ml fe ff paragraph-image"><div class="fe ff mw"><img src="../Images/c7d099557a2990af3ba887a2f5e24068.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*SnNAz7D_3ucouHXf9-n-RQ.png"/></div></figure><p id="ac22" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">我们现在可以很好地重写上面的代码:</p><figure class="mh mi mj mk fq ml fe ff paragraph-image"><div class="fe ff mx"><img src="../Images/c0cf3e1833ac9f68791c3d2691a70d10.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*Wdy4LAOW_vYbDiSWTYKTKA.png"/></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">Same as above but using the new macro.</figcaption></figure><p id="dc4c" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">注意:告诉<a class="ae my" href="https://cursive-ide.com/" rel="noopener ugc nofollow" target="_blank">草书</a>到<a class="ae my" href="https://cursive-ide.com/userguide/macros.html" rel="noopener ugc nofollow" target="_blank">像对待</a> <code class="eh kn ko kp kq b"><a class="ae my" href="https://cursive-ide.com/userguide/macros.html" rel="noopener ugc nofollow" target="_blank">for</a></code>一样对待 <code class="eh kn ko kp kq b"><a class="ae my" href="https://cursive-ide.com/userguide/macros.html" rel="noopener ugc nofollow" target="_blank">loop-it</a></code> <a class="ae my" href="https://cursive-ide.com/userguide/macros.html" rel="noopener ugc nofollow" target="_blank">给了我们很好的语法高亮。</a></p></div><div class="ab cl lz ma hc mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hn ho hp hq hr"><p id="cf61" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">现在让我们来看第二个问题:迭代多个序列。为此，我们将考虑转置两个向量的问题。即:给定<code class="eh kn ko kp kq b">[a b c]</code>和<code class="eh kn ko kp kq b">[0 1 2]</code>，我们创建<code class="eh kn ko kp kq b">[[a 0] [b 1] [c 2]]</code>作为输出。<code class="eh kn ko kp kq b">clojure.core</code>中没有太多函数可以处理多个输入序列:据我所知只有<code class="eh kn ko kp kq b">map</code>、<code class="eh kn ko kp kq b">mapv</code>、<code class="eh kn ko kp kq b">pmap</code>、<code class="eh kn ko kp kq b">sequence</code>、<code class="eh kn ko kp kq b">interleave</code>、<code class="eh kn ko kp kq b">lazy-cat</code>和<code class="eh kn ko kp kq b">mapcat</code>可以。因此，如果你需要迭代多个集合，你需要使用这些有限的函数。</p><p id="23eb" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">相反，使用迭代器我们可以很容易地做到这一点:</p><figure class="mh mi mj mk fq ml fe ff paragraph-image"><div class="fe ff mz"><img src="../Images/43aea3d5dfe3b9e2a3038cb73740eaa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*wSrTWhAatF1iwIF1bJjK4w.png"/></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">20ms</figcaption></figure><p id="2d05" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">对于具有一百万个元素的两个向量，这在大约20毫秒内运行。使用<code class="eh kn ko kp kq b">(mapv vector xs xs)</code>运行约85毫秒。所以使用迭代器时速度提高了4倍多。当然，这有点不公平，因为我们没有提供函数<code class="eh kn ko kp kq b">f</code>在这里调用。然而，这样做只会降低功能1-2%的速度。</p><p id="fd33" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">附注:如果你真的需要这么快，你也可以使用数组来达到10ms:</p><figure class="mh mi mj mk fq ml fe ff paragraph-image"><div class="fe ff na"><img src="../Images/7feb78a1933d55b4fc7f9bc17913bd75.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*sheQhTQWtU824YPnrXOcPw.png"/></div></figure><p id="6942" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated"><code class="eh kn ko kp kq b">loop-it</code>有很多应用。我们还可以用它来创建一个更快的<code class="eh kn ko kp kq b">interleave</code>函数(显然不是懒惰):</p><figure class="mh mi mj mk fq ml fe ff paragraph-image"><div class="fe ff nb"><img src="../Images/5ea0b66803b7ae287abac30037f87b65.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*kZtQcK26DxG64sn1AWU3QQ.png"/></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">26ms</figcaption></figure><p id="2437" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">这大约需要26毫秒，而<code class="eh kn ko kp kq b">(doall (interleave xs xs))</code>大约需要64毫秒。一次漂亮的加速。</p><p id="d408" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">我当然听到你说:<code class="eh kn ko kp kq b">map</code>要灵活得多；它可以带一个<strong class="jr hv">变量</strong>号序列；</p><figure class="mh mi mj mk fq ml fe ff paragraph-image"><div class="fe ff nc"><img src="../Images/d5099a2a5e86c5893bb19258842cf33b.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*56fzWs7u1WyFlB3Yj8Hp4Q.png"/></div></figure><p id="d57b" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">见鬼，它甚至能恰当地处理无限序列:</p><figure class="mh mi mj mk fq ml fe ff paragraph-image"><div class="fe ff nd"><img src="../Images/1ac3e5bd5f1811d1a14328041a27f234.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*5KRtKB1k1sOehT68rLb8Yw.png"/></div></figure><p id="3d4b" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">我们能用<code class="eh kn ko kp kq b">loop-it</code>达到同样的效果吗？不是在它的当前状态:它需要你——在编译时——给它你想要迭代的序列。对于可变数量的序列，我们可以使用一个技巧(复制自<code class="eh kn ko kp kq b">clojure.core</code>):将可变数量的迭代器转换成一个迭代器。新的迭代器为每个对<code class="eh kn ko kp kq b">it.next()</code>的调用返回一个集合。我们称之为<strong class="jr hv">多重迭代器</strong>。由于<code class="eh kn ko kp kq b">clojure.core</code>中的类是私有的，我们必须重写它:</p><figure class="mh mi mj mk fq ml fe ff paragraph-image"><div class="fe ff ne"><img src="../Images/6049b5fee53ab9d3b9d6a2852769be42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*RtVWn6aQjRG98Sjmjpi2pw.png"/></div></figure><p id="5cc2" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">就像<code class="eh kn ko kp kq b">clojure.lang.MultiIterator</code>一样，它使用本地数组来提高速度。然而，一个问题仍然存在:它不能处理无限数量的序列，因为它是热切的。所以让我们创建另一个懒人:</p><figure class="mh mi mj mk fq ml fe ff paragraph-image"><div class="fe ff nf"><img src="../Images/6fb88e4ce642e6b75dfb8f94c0c549f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*y2yVL3RTUtixMJRkKtDwYA.png"/></div></figure><p id="94e3" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">现在<code class="eh kn ko kp kq b">colls</code>可以是一个无限序列。</p><p id="f092" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">让我们实际看看如何使用它:</p><figure class="mh mi mj mk fq ml fe ff paragraph-image"><div class="fe ff ng"><img src="../Images/727412ad8ee9838d8f95e1bb796b2b91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*XpLkLaXnEFSfPxtSij4oIA.png"/></div></figure><p id="ac2d" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">这是一个开始。但是在进行基准测试之前，让我们结合并展开一些内容，以得出一个真正快速的<code class="eh kn ko kp kq b">mapv</code>:</p><figure class="mh mi mj mk fq ml fe ff paragraph-image"><div class="fe ff nh"><img src="../Images/0f5c3426e7aec50c02c57435055b113f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*pClkd5tvGJWNoaDNburgbg.png"/></div></figure><p id="b6d2" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">注意:我也把<code class="eh kn ko kp kq b">loop-it</code>宏改为调用<code class="eh kn ko kp kq b">ensure-iter</code>而不是<code class="eh kn ko kp kq b">clojure.lang.RT/iter</code>。</p><p id="18d1" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">让我们进行基准测试:</p><pre class="mh mi mj mk fq ni kq nj nk aw nl dt"><span id="7137" class="kr is hu kq b fv nm nn l no np">(<strong class="kq hv">mapv </strong>vector xs xs xs xs)</span></pre><p id="a085" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">对于100万个元素，这大约需要1.28秒。我们新的基于迭代的实现仅需147毫秒。几乎9倍的加速，实现是非常可读的。</p><h2 id="2961" class="kr is hu bd it ks kt ku ix kv kw kx jb ka ky kz jf ke la lb jj ki lc ld jn le dt translated">其他应用</h2><ol class=""><li id="cced" class="lf lg hu jr b js jt jw jx ka nq ke nr ki ns km lm ln lo lp dt translated">让我们写一个<strong class="jr hv">真快</strong> <code class="eh kn ko kp kq b">take-nth</code>:</li></ol><figure class="mh mi mj mk fq ml fe ff paragraph-image"><div class="fe ff nt"><img src="../Images/9a99841610f524b7cef1e20dd4771002.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*TikEkTwciJsA2U9cAQhQsw.png"/></div></figure><p id="71c8" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">对于有1000万个元素的<code class="eh kn ko kp kq b">(take-nth-vec 5 xs-large)</code>来说，这需要52毫秒。<code class="eh kn ko kp kq b">(into [] (take-nth 5) xs-large)</code>运行时间为273毫秒<code class="eh kn ko kp kq b">(doall (take-nth 5 xs-large))</code>运行时间为290毫秒。</p><p id="c1a5" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">2.将你的序列分成两组:<code class="eh kn ko kp kq b">all-truthy-values</code>，<code class="eh kn ko kp kq b">all-falsy-values</code>:</p><figure class="mh mi mj mk fq ml fe ff paragraph-image"><div class="fe ff nu"><img src="../Images/ac7cac967533862b3634fc1336edef7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*r5hRtO8A4zS9Nlqj8ICJHA.png"/></div></figure><p id="8230" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">对于基于<code class="eh kn ko kp kq b">loop-it</code>的实施，运行时间约为176毫秒，而对于基于<code class="eh kn ko kp kq b">reduce</code>的实施，运行时间约为291毫秒。在我看来，这个循环可读性更强。</p><p id="e615" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated"><em class="ly">边注</em>:这是其他多少编程语言定义的<code class="eh kn ko kp kq b">partition</code>。</p><p id="6074" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">3.计算集合的总和。</p><figure class="mh mi mj mk fq ml fe ff paragraph-image"><div class="fe ff nv"><img src="../Images/9dcd446c0822c72ec3d46645f19505c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*Xx0HZBQNlk5EBlK1VwZfXA.png"/></div></figure><p id="bafc" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">从上到下:177毫秒，130毫秒，59毫秒</p><h2 id="385c" class="kr is hu bd it ks kt ku ix kv kw kx jb ka ky kz jf ke la lb jj ki lc ld jn le dt translated">Clojurescript</h2><p id="df64" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">这一切在Clojurescript中也是可能的。创建一个iter是用<code class="eh kn ko kp kq b">iter</code>完成的，只有对<code class="eh kn ko kp kq b">ensure-iter</code>的改变稍微有点棘手。</p><h2 id="f04d" class="kr is hu bd it ks kt ku ix kv kw kx jb ka ky kz jf ke la lb jj ki lc ld jn le dt translated">梦想</h2><p id="a004" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">一个<code class="eh kn ko kp kq b">Iterator</code>很简单:<code class="eh kn ko kp kq b">it.hasNext()</code>和<code class="eh kn ko kp kq b">it.next()</code>。一个非常好的特性是一个改进的迭代器，它也允许我们说“现在给我剩下的序列”。类似<code class="eh kn ko kp kq b">it.restSeq()</code>。这可以让我们加速像<code class="eh kn ko kp kq b">nthrest</code>这样的事情，这在迭代器中是不可能的。一个值得注意的想法是加快<code class="eh kn ko kp kq b">apply</code>速度，但并不那么快。它当前多次迭代给定的序列。想法见我的<a class="ae my" href="https://dev.clojure.org/jira/browse/CLJS-2099" rel="noopener ugc nofollow" target="_blank">clojuscript票</a>。如果迭代器有<code class="eh kn ko kp kq b">it.restSeq()</code>的话，它就可以在那里使用。</p><h2 id="44eb" class="kr is hu bd it ks kt ku ix kv kw kx jb ka ky kz jf ke la lb jj ki lc ld jn le dt translated">结论</h2><p id="a037" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">不要忘记clojure的<code class="eh kn ko kp kq b">Iterators</code>。他们通常是值得的。如果您需要，请使用它们:</p><ul class=""><li id="b1f2" class="lf lg hu jr b js lh jw li ka lj ke lk ki ll km nw ln lo lp dt translated">累积多个值</li><li id="6508" class="lf lg hu jr b js lq jw lr ka ls ke lt ki lu km nw ln lo lp dt translated">想做原始的数学</li><li id="3f27" class="lf lg hu jr b js lq jw lr ka ls ke lt ki lu km nw ln lo lp dt translated">想要同时迭代多个序列</li></ul><p id="e10d" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">一如既往:如果性能很重要:基准。有时使用迭代器不是很快。例如，热切的<code class="eh kn ko kp kq b">mapcatv</code>实现比嵌套的<code class="eh kn ko kp kq b">loop-it</code>实现慢(但是使用<code class="eh kn ko kp kq b">reduce</code>作为内部循环更快)。</p><p id="8169" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">所有代码位于:<a class="ae my" href="https://github.com/rauhs/clj-bench" rel="noopener ugc nofollow" target="_blank">https://github.com/rauhs/clj-bench</a></p><p id="cc3e" class="pw-post-body-paragraph jp jq hu jr b js lh ju jv jw li jy jz ka lv kc kd ke lw kg kh ki lx kk kl km hn dt translated">注意:由于<code class="eh kn ko kp kq b">loop-it</code>很小，所以你应该复制它。没有clojars库。</p></div></div>    
</body>
</html>