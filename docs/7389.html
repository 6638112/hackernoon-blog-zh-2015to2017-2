<html>
<head>
<title>Impress Your Friends With Code Splitting in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的代码分割让您的朋友印象深刻</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/impress-your-friends-with-code-splitting-in-react-9f9a3ca2ae6e?source=collection_archive---------3-----------------------#2017-10-26">https://medium.com/hackernoon/impress-your-friends-with-code-splitting-in-react-9f9a3ca2ae6e?source=collection_archive---------3-----------------------#2017-10-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="5294" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">几周前，在准备<a class="ae jp" href="http://devupconf.org/" rel="noopener ugc nofollow" target="_blank"> DevUp </a>主题演讲时，我花了一些时间学习在React中演示<a class="ae jp" href="https://hackernoon.com/tagged/code" rel="noopener ugc nofollow" target="_blank">代码</a>分裂的最小可能量。现在你的第一反应大概是…</p><blockquote class="jq"><p id="ae00" class="jr js hu bd jt ju jv jw jx jy jz jo ek translated">伯克。你为什么要做主题演讲？主题演讲不再有任何意义了吗？</p></blockquote><p id="dd40" class="pw-post-body-paragraph ir is hu it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn jo hn dt translated">让我通过说两件事来回答这个问题…</p><ol class=""><li id="e7cc" class="kf kg hu it b iu iv iy iz jc kh jg ki jk kj jo kk kl km kn dt translated">哎哟</li><li id="8265" class="kf kg hu it b iu ko iy kp jc kq jg kr jk ks jo kk kl km kn dt translated">有人被邀请做主题发言。他们只是让我帮忙。</li></ol><p id="d7b6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">作为主题演讲的一部分，我正在研究如何优化React构建。这是我们在开始吐槽代码拆分之前应该回答的问题。</p><h1 id="ae57" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">优化React构建</h1><p id="3c18" class="pw-post-body-paragraph ir is hu it b iu lr iw ix iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo hn dt translated">当我说“优化”一个构建时，我指的是任何使代码<strong class="it hv">更小</strong>和<strong class="it hv">更快</strong>的东西。有一些技术被用于整个JavaScript领域来实现这一点…</p><ul class=""><li id="cf69" class="kf kg hu it b iu iv iy iz jc kh jg ki jk kj jo lw kl km kn dt translated">集束</li><li id="e56d" class="kf kg hu it b iu ko iy kp jc kq jg kr jk ks jo lw kl km kn dt translated">缩小</li><li id="d356" class="kf kg hu it b iu ko iy kp jc kq jg kr jk ks jo lw kl km kn dt translated">提前编译</li><li id="8b93" class="kf kg hu it b iu ko iy kp jc kq jg kr jk ks jo lw kl km kn dt translated">树晃动(当你的孩子的无人机再次卡在树上时——呃——我的意思是移除死代码)</li><li id="37d9" class="kf kg hu it b iu ko iy kp jc kq jg kr jk ks jo lw kl km kn dt translated">代码分割(按需加载代码块)</li></ul><p id="38bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">create-react-app默认会发生上述三种情况:由于Webpack，create-react-app免费提供捆绑、缩小和树抖动。</p><p id="3d7c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">React不做AoT，因为AoT主要用于将字符串模板编译成可执行的JavaScript，所以浏览器不需要做这部分工作。React已经在JSX这样做了。这也是React人们喜欢说“这只是JavaScript”的原因之一。声明一下，字符串也是有效的JavaScript。随便说说。这不像Angular和Vue的人使用一些只有专有编译器才能理解的预处理器语言——你知道，像JSX。</p><figure class="ly lz ma mb fq mc fe ff paragraph-image"><div class="fe ff lx"><img src="../Images/36029b8c18fffbfc6efb214c21e57dc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*-4N19FszBtTpIOg-wvinEA.png"/></div></figure><p id="fb74" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">但无论如何</strong></p><p id="366b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就给我们留下了代码分割。这只是一个简单的想法，你想把你的代码分成可以延迟加载的块，这样你就不会加载可能永远不会用到的JavaScript，这取决于用户在你的应用程序中的位置。</p><p id="b67c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<em class="mf">为什么</em>你会想在React中进行代码拆分的背后有很好的和深刻的技术原因。这些具体原因包括…</p><ul class=""><li id="d9a3" class="kf kg hu it b iu iv iy iz jc kh jg ki jk kj jo lw kl km kn dt translated">你是个潮人</li><li id="88db" class="kf kg hu it b iu ko iy kp jc kq jg kr jk ks jo lw kl km kn dt translated">所有酷小孩都这么做</li><li id="768b" class="kf kg hu it b iu ko iy kp jc kq jg kr jk ks jo lw kl km kn dt translated">“代码分割”是一个性感的词</li><li id="96a8" class="kf kg hu it b iu ko iy kp jc kq jg kr jk ks jo lw kl km kn dt translated">你不能强迫用户加载他们不会使用的代码</li></ul><p id="7c6e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们通过检查一个您在现实生活中永远不会使用的演示应用程序来看看这在现实生活中是如何工作的。</p><h1 id="e879" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">代码分割IRL</h1><p id="a4a6" class="pw-post-body-paragraph ir is hu it b iu lr iw ix iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo hn dt translated">在下面的GIF中，你会看到一个追踪英雄列表的应用程序。这只是一个简单的CRUD应用程序。这个应用程序的一个有趣的部分是有一个编辑表单，它只在添加一个新项目或选择一个现有项目时显示。这意味着，如果用户来到这个应用程序，并且从来没有添加或修改过一个英雄，他们已经加载了一大块他们永远不会使用的JavaScript。</p><figure class="ly lz ma mb fq mc fe ff paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="fe ff mg"><img src="../Images/6f53903c26d4df746f61e4d387cda2fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*x2Hr75XuPpj45KOwUH9Opw.gif"/></div></div></figure><p id="0f82" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以延迟加载这个小表单，这样它只在有人点击编辑一个项目或者点击“添加新英雄”时才显示。这两个动作都显示了编辑表单。</p><p id="6671" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，我将在我的状态中为这个“EditForm”组件添加一个点。</p><pre class="ly lz ma mb fq ml mm mn mo aw mp dt"><span id="907c" class="mq ku hu mm b fv mr ms l mt mu">class Heroes extends Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = { <br/>      ...,      <br/>      lazyEditHero: null <br/>    }<br/>  }</span><span id="9919" class="mq ku hu mm b fv mv ms l mt mu">  ...,</span><span id="76a0" class="mq ku hu mm b fv mv ms l mt mu">  render() { <br/>    return ( <br/>      ...<br/>    )<br/>  }<br/>}</span></pre><p id="bb41" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我把我的放在一个叫做<code class="eh mw mx my mm b">lazyEditHero, </code>的房产里，但是你可以随便叫它什么。给事物命名是很难的，无论你做什么，你都有100%的可能会后悔。</p><p id="1945" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，每当有人选择“添加新英雄”或选择一个现有的英雄来编辑它时，我们需要实际加载这个组件。然后，我们将在州中设置组件引用，以便稍后在JSX中使用它。我把它放在一个名为<strong class="it hv"> LoadEditForm </strong>的函数中</p><pre class="ly lz ma mb fq ml mm mn mo aw mp dt"><span id="f282" class="mq ku hu mm b fv mr ms l mt mu">class Heroes extends Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = { <br/>      ...<br/>      lazyEditHero: null <br/>    }<br/>  }</span><span id="aa13" class="mq ku hu mm b fv mv ms l mt mu">  async LoadEditForm() {<br/>    const { default : EditHero } = await import('./EditHero');<br/>    this.setState({ lazyEditHero: EditHero })<br/>  }</span><span id="038f" class="mq ku hu mm b fv mv ms l mt mu">  render() { <br/>    return ( <br/>      ...<br/>    )<br/>  }<br/>}</span></pre><p id="340e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们只需要从触发编辑器组件显示的两个函数中调用这个<strong class="it hv"> LoadEditForm </strong>。</p><pre class="ly lz ma mb fq ml mm mn mo aw mp dt"><span id="04cc" class="mq ku hu mm b fv mr ms l mt mu">class Heroes extends Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = { <br/>      ...<br/>      lazyEditHero: null <br/>    }<br/>  }</span><span id="f4ce" class="mq ku hu mm b fv mv ms l mt mu">  async LoadEditForm() {<br/>    const { default : EditHero } = await import('./EditHero');<br/>    this.setState({ lazyEditHero: EditHero })<br/>  }</span><span id="0be7" class="mq ku hu mm b fv mv ms l mt mu">  handleSelect = async hero =&gt; {<br/>    await this.LoadEditForm();<br/>    this.setState({ selectedHero: hero });<br/>  }<br/>  <br/>  handleEnableAddMode = async () =&gt; {<br/>    await this.LoadEditForm();</span><span id="55c4" class="mq ku hu mm b fv mv ms l mt mu">    this.setState({<br/>      addingHero: true,<br/>      selectedHero: { id: '', name: '', saying: '' }<br/>    });<br/>  }</span><span id="4519" class="mq ku hu mm b fv mv ms l mt mu">  ...</span><span id="2dd4" class="mq ku hu mm b fv mv ms l mt mu">  render() { <br/>    return ( <br/>      ...<br/>    )<br/>  }<br/>}</span></pre><p id="ebab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一些需要注意的事项…</p><ul class=""><li id="d61f" class="kf kg hu it b iu iv iy iz jc kh jg ki jk kj jo lw kl km kn dt translated">我们的函数都标记为async，因为我使用了async/await语法。简而言之，async/await允许我们在不显式使用promise语法的情况下同步进行某些操作——比如通过HTTP调用加载文件。它超级棒，你应该<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank">看看</a>。</li><li id="6f06" class="kf kg hu it b iu ko iy kp jc kq jg kr jk ks jo lw kl km kn dt translated"><code class="eh mw mx my mm b">./EditHero</code>文件被加载并分配(通过析构)给一个名为“EditHero”的变量。指定“default”的原因是，这是组件在加载文件的异步调用返回的响应中的实际位置。</li></ul><p id="cec9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我们需要将组件添加到我们的JSX中，但前提是它不为空。如果为空，我们将只显示一个空字符串。这也允许我们在组件延迟加载时向组件传递任何道具。</p><pre class="ly lz ma mb fq ml mm mn mo aw mp dt"><span id="603c" class="mq ku hu mm b fv mr ms l mt mu">class Heroes extends Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = { <br/>      ...<br/>      lazyEditHero: null <br/>    }<br/>  }</span><span id="7d6d" class="mq ku hu mm b fv mv ms l mt mu">  async LoadEditForm() {<br/>    const { default : EditHero } = await import('./EditHero');<br/>    this.setState({ lazyEditHero: EditHero })<br/>  }</span><span id="84e6" class="mq ku hu mm b fv mv ms l mt mu">  handleSelect = async hero =&gt; {<br/>    await this.LoadEditForm();<br/>    this.setState({ selectedHero: hero });<br/>  }<br/>  <br/>  handleEnableAddMode = async () =&gt; {<br/>    await this.LoadEditForm();</span><span id="ceeb" class="mq ku hu mm b fv mv ms l mt mu">  this.setState({<br/>      addingHero: true,<br/>      selectedHero: { id: '', name: '', saying: '' }<br/>    });<br/>  }</span><span id="227a" class="mq ku hu mm b fv mv ms l mt mu">  ...</span><span id="4895" class="mq ku hu mm b fv mv ms l mt mu">  render() { <br/>    const EditHero = this.state.lazyEditHero;<br/>    return (<br/>      &lt;div&gt;<br/>        ...<br/>        &lt;div className="editarea"&gt;<br/>          &lt;button onClick={this.handleEnableAddMode}&gt;Add&lt;/button&gt;<br/>          {EditHero ? (<br/>            &lt;EditHero<br/>              addingHero={this.state.addingHero}<br/>              onChange={this.handleOnChange}<br/>              selectedHero={this.state.selectedHero}<br/>              onSave={this.handleSave}<br/>              onCancel={this.handleCancel}<br/>            /&gt;<br/>          ) : (<br/>            &lt;div&gt;&lt;/div&gt;<br/>          )}<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="f234" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在你知道了！现在，当我们运行这个应用程序时，它只会加载英雄列表，直到我们点击一个或尝试添加一个新的。一旦我们这样做了，您就可以打开开发人员工具，观察浏览器对浏览器加载和执行的新JavaScript块发出HTTP请求。</p><figure class="ly lz ma mb fq mc fe ff paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="fe ff mg"><img src="../Images/c803f2630a99325681bc230d531c1089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ujxJRWRF92SHAaBUDU-snA.gif"/></div></div></figure><p id="21ff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好俏皮！还要注意，即使我们在添加或选择一个项目时一遍又一遍地调用那个<code class="eh mw mx my mm b">LoadEditForm</code>，Webpack也足够聪明，不会尝试重新加载组件，因此不会进行后续调用。</p><h1 id="ff43" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">我应该在哪里进行代码拆分</h1><p id="8c3b" class="pw-post-body-paragraph ir is hu it b iu lr iw ix iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo hn dt translated">嘿，这是你的世界。我不是来告诉你该做什么的。</p><p id="f4d7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是如果我是，我会推荐在你有特别重的组件的地方(字节方面)和你有组件的地方使用代码分割，你的用户有很大的不使用的统计可能性。</p><p id="da21" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">React Router是另一个使用代码分割的好地方，因为你可以在URL改变时加载内容。按需加载SPA的页面是有意义的，而不是一次全部加载。事实上，<a class="ae jp" href="https://serverless-stack.com/chapters/code-splitting-in-create-react-app.html" rel="noopener ugc nofollow" target="_blank">大部分代码拆分的例子</a>都会涉及到React路由器。</p><h1 id="9fd1" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">临别时的告诫</h1><p id="d655" class="pw-post-body-paragraph ir is hu it b iu lr iw ix iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo hn dt translated">代码拆分很酷，但是不要忘乎所以。如果你的整个应用程序是一堆懒惰的组件，你就<strong class="it hv"> a) </strong>违背了捆绑器的目的，<strong class="it hv"> b) </strong>过早地优化和<strong class="it hv"> c) </strong>使你的代码更加难以阅读和调试。</p><p id="4f9c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以小心使用代码分割，然后告诉你所有的朋友你知道怎么做。你听起来会非常酷，每个人都会喜欢你。这已经足够了。</p><figure class="ly lz ma mb fq mc"><div class="bz el l di"><div class="mz na l"/></div></figure></div></div>    
</body>
</html>