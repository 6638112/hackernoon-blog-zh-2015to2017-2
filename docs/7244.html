<html>
<head>
<title>React — Reusable component state</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React —可重用组件状态</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/react-reusable-component-state-805163dc355?source=collection_archive---------7-----------------------#2017-10-21">https://medium.com/hackernoon/react-reusable-component-state-805163dc355?source=collection_archive---------7-----------------------#2017-10-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="0645" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">如何在组件之间共享状态和方法。</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/8933e4fa3854e49902a096a7f2866351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y6C4nSvy2Woe0m7bWEn4BA.png"/></div></div></figure><p id="32d4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">到现在大家都学会了，用构图而不是继承。然而，对于某些事情，尤其是对于不熟悉函数式<a class="ae kr" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>的开发人员来说，可能不清楚如何正确地使用组合。</p><p id="8660" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">一个常见的问题是如何<strong class="jx hv">重用</strong>组件之间的状态和共享方法。</p><p id="595e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我用一个列表来举例。列表定义如下，有状态中的<code class="eh ks kt ku kv b">nextItem()</code>、<code class="eh ks kt ku kv b"> prevItem()</code>、<code class="eh ks kt ku kv b">onChange(selectedItem)</code>方法、<code class="eh ks kt ku kv b">selectedItem</code>等基本内容。它期待<code class="eh ks kt ku kv b">props</code>中的<code class="eh ks kt ku kv b">items</code>，当然最后会呈现一个列表。</p><pre class="jk jl jm jn fq kw kv kx ky aw kz dt"><span id="f270" class="la lb hu kv b fv lc ld l le lf"><strong class="kv hv">class </strong>List <strong class="kv hv">extends </strong>Component {<br/>  constructor(props) {<br/>    <strong class="kv hv">super</strong>(props);<br/>    <strong class="kv hv">this</strong>.<strong class="kv hv">state </strong>= {<br/>      <strong class="kv hv">selectedItem</strong>: 0,<br/>    }<br/>  }<br/><br/>  componentWillUpdate({onChange, items}, nextState) {<br/>    <strong class="kv hv">if </strong>(onChange &amp;&amp; nextState.<strong class="kv hv">selectedItem </strong>!== <strong class="kv hv">this</strong>.<strong class="kv hv">state</strong>.<strong class="kv hv">selectedItem</strong>) {<br/>      onChange(items[nextState.<strong class="kv hv">selectedItem</strong>]);<br/>    }<br/>  }<br/><br/>  nextItem() {<br/>    <strong class="kv hv">const </strong>{<strong class="kv hv">selectedItem</strong>} = <strong class="kv hv">this</strong>.<strong class="kv hv">state</strong>;<br/>    <strong class="kv hv">const </strong>{items} = <strong class="kv hv">this</strong>.<strong class="kv hv">props</strong>;<br/><br/>    <strong class="kv hv">if </strong>(items.length === <strong class="kv hv">selectedItem </strong>+ 1) {<br/>      <strong class="kv hv">return</strong>;<br/>    }<br/><br/>    <strong class="kv hv">this</strong>.setState({<strong class="kv hv">selectedItem</strong>: <strong class="kv hv">selectedItem </strong>+ 1});<br/>  }<br/><br/>  prevItem() {<br/>    <strong class="kv hv">const </strong>{<strong class="kv hv">selectedItem</strong>} = <strong class="kv hv">this</strong>.<strong class="kv hv">state</strong>;<br/><br/>    <strong class="kv hv">if </strong>(<strong class="kv hv">selectedItem </strong>=== 0) {<br/>      <strong class="kv hv">return</strong>;<br/>    }<br/><br/>    <strong class="kv hv">this</strong>.setState({<strong class="kv hv">selectedItem</strong>: <strong class="kv hv">selectedItem </strong>- 1});<br/>  }<br/><br/>  render() {<br/>    <strong class="kv hv">const </strong>{items} = <strong class="kv hv">this</strong>.<strong class="kv hv">props</strong>;<br/>    <strong class="kv hv">const </strong>{<strong class="kv hv">selectedItem</strong>} = <strong class="kv hv">this</strong>.<strong class="kv hv">state</strong>;<br/><br/>    <strong class="kv hv">return </strong>(<br/>      &lt;<strong class="kv hv">ul</strong>&gt;<br/>        {<br/>          items.map((item, index) =&gt; (<br/>            &lt;<strong class="kv hv">li className=</strong>{<strong class="kv hv">`</strong>${<strong class="kv hv">selectedItem </strong>=== index ? <strong class="kv hv">'selected' </strong>: <strong class="kv hv">''</strong>}<strong class="kv hv">`</strong>}&gt;<br/>              {item}<br/>            &lt;/<strong class="kv hv">li</strong>&gt;<br/>          ))<br/>        }<br/>      &lt;/<strong class="kv hv">ul</strong>&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="a70f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在，当我们有了一个清晰的列表，这里有一个问题。</p><p id="ea32" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">问:如何创建ListVertical和ListHorizontal？</strong></p><p id="4f82" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">带<a class="ae kr" href="https://hackernoon.com/tagged/hoc" rel="noopener ugc nofollow" target="_blank"> HOC </a>(高阶组件)<code class="eh ks kt ku kv b">withList</code> HOC。所以基本上，我们要做的是分离并传递我们需要的东西给包装的组件。看好了。</p><pre class="jk jl jm jn fq kw kv kx ky aw kz dt"><span id="7b12" class="la lb hu kv b fv lc ld l le lf"><strong class="kv hv">function </strong><em class="lg">withList</em>(WrappedComponent) {<br/>  <strong class="kv hv">return class extends </strong>Component {<br/>    constructor(props) {<br/>      <strong class="kv hv">super</strong>(props);<br/>      <strong class="kv hv">this</strong>.<strong class="kv hv">state </strong>= {<br/>        <strong class="kv hv">selectedIndex</strong>: 0,<br/>      }<br/>    }<br/><br/>    componentWillUpdate({onChange, items}, nextState) {<br/>      <strong class="kv hv">if </strong>(onChange &amp;&amp; nextState.<strong class="kv hv">selectedIndex </strong>!== <strong class="kv hv">this</strong>.<strong class="kv hv">state</strong>.<strong class="kv hv">selectedIndex</strong>) {<br/>        onChange(items[nextState.<strong class="kv hv">selectedIndex</strong>]);<br/>      }<br/>    }<br/><br/>    <em class="lg">nextItem </em>= () =&gt; {<br/>      <strong class="kv hv">const </strong>{selectedIndex} = <strong class="kv hv">this</strong>.<strong class="kv hv">state</strong>;<br/>      <strong class="kv hv">const </strong>{items} = <strong class="kv hv">this</strong>.<strong class="kv hv">props</strong>;<br/><br/>      <strong class="kv hv">if </strong>(items.<strong class="kv hv">length </strong>=== selectedIndex + 1) {<br/>        <strong class="kv hv">return</strong>;<br/>      }<br/><br/>      <strong class="kv hv">this</strong>.setState({<strong class="kv hv">selectedIndex</strong>: selectedIndex + 1});<br/>    };<br/><br/>    <em class="lg">prevItem </em>= () =&gt; {<br/>      <strong class="kv hv">const </strong>{selectedIndex} = <strong class="kv hv">this</strong>.<strong class="kv hv">state</strong>;<br/><br/>      <strong class="kv hv">if </strong>(selectedIndex === 0) {<br/>        <strong class="kv hv">return</strong>;<br/>      }<br/><br/>      <strong class="kv hv">this</strong>.setState({<strong class="kv hv">selectedIndex</strong>: selectedIndex - 1});<br/>    };<br/><br/>    <em class="lg">selectItem </em>= (selectedIndex) =&gt; {<br/>      <strong class="kv hv">this</strong>.setState({selectedIndex});<br/>    };<br/><br/>    render() {<br/>      <strong class="kv hv">const </strong>{selectedIndex} = <strong class="kv hv">this</strong>.<strong class="kv hv">state</strong>;<br/><br/>      <strong class="kv hv">return </strong>(<br/>        &lt;<strong class="kv hv">WrappedComponent<br/>          </strong>{...<strong class="kv hv">this</strong>.<strong class="kv hv">props</strong>}<br/>          <strong class="kv hv">prevItem=</strong>{<strong class="kv hv">this</strong>.<em class="lg">prevItem</em>}<br/>          <strong class="kv hv">nextItem=</strong>{<strong class="kv hv">this</strong>.<em class="lg">nextItem</em>}<br/>          <strong class="kv hv">selectItem=</strong>{<strong class="kv hv">this</strong>.<em class="lg">selectItem</em>}<br/>          <strong class="kv hv">selectedIndex=</strong>{selectedIndex}<br/>        /&gt;<br/>      );<br/>    }<br/>  }<br/>}</span></pre><p id="dc08" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如您所见，被包装的组件将拥有所有可用的方法和<code class="eh ks kt ku kv b">selectedIndex</code>。不是从<code class="eh ks kt ku kv b">this</code>中使用，而是从<code class="eh ks kt ku kv b">props</code>中使用。好多了！</p><p id="5c7e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">对于包装的组件来说，能够改变所使用的父状态是很重要的。这样，您就可以保持生命周期，并可以创建新的方法来更新状态。这意味着完全重用状态。</p><blockquote class="lh li lj"><p id="9cac" class="jv jw lg jx b jy jz iv ka kb kc iy kd lk kf kg kh ll kj kk kl lm kn ko kp kq hn dt translated"><strong class="jx hv">注意</strong> <code class="eh ks kt ku kv b"><em class="hu">selectItem</em></code>是额外实现的，这样被包装的组件可以改变<code class="eh ks kt ku kv b"><em class="hu">selectedIndex</em></code>，就像它是其状态的一部分一样。那是！重要。</p></blockquote><p id="0c10" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">让我们检查一下水平列表的外观。</p><pre class="jk jl jm jn fq kw kv kx ky aw kz dt"><span id="e9a5" class="la lb hu kv b fv lc ld l le lf"><strong class="kv hv">class </strong>ListHorizontal <strong class="kv hv">extends </strong>Component {<br/>  <em class="lg">customNextItem </em>= () =&gt; {<br/>    <em class="lg">// Not really custom -_-<br/>    </em><strong class="kv hv">const </strong>{selectedIndex, selectItem} = <strong class="kv hv">this</strong>.<strong class="kv hv">props</strong>;<br/>    selectItem(selectedIndex + 1);<br/>  }</span><span id="6a36" class="la lb hu kv b fv ln ld l le lf">  render() {<br/>    <strong class="kv hv">const </strong>{selectedIndex, prevItem, selectItem} = <strong class="kv hv">this</strong>.<strong class="kv hv">props</strong>;<br/>    <strong class="kv hv">return </strong>(<br/>      &lt;<strong class="kv hv">div</strong>&gt;<br/>        &lt;<strong class="kv hv">img src="https://imgflip.com/s/meme/Troll-Face.jpg" alt="Horizontal list" </strong>/&gt;<br/>        &lt;<strong class="kv hv">div</strong>&gt;Selected item index: {selectedIndex}&lt;/<strong class="kv hv">div</strong>&gt;<br/>        &lt;<strong class="kv hv">span onClick=</strong>{prevItem}&gt;Prev item&lt;/<strong class="kv hv">span</strong>&gt;<br/>        &lt;<strong class="kv hv">span onClick=</strong>{<strong class="kv hv">this</strong>.<em class="lg">customNextItem</em>}&gt;Next item&lt;/<strong class="kv hv">span</strong>&gt;<br/>      &lt;/<strong class="kv hv">div</strong>&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="3524" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">就是这样！简单干净。一切都在<code class="eh ks kt ku kv b">withList</code> HOC中实现，现在可以很容易地应用于任何组件。HOC最美好的一点就是，想包多少包多少！</p><p id="80b4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">家庭作业:现在列表看起来怎么样？</p><p id="b1d3" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">观察和预先评论:</p><ul class=""><li id="5a39" class="lo lp hu jx b jy jz kb kc ke lq ki lr km ls kq lt lu lv lw dt translated">我发现使用HOC比使用容器更灵活👎</li><li id="c8ae" class="lo lp hu jx b jy lx kb ly ke lz ki ma km mb kq lt lu lv lw dt translated">我知道CSS可以实现横向和纵向列表😒</li><li id="d4af" class="lo lp hu jx b jy lx kb ly ke lz ki ma km mb kq lt lu lv lw dt translated">上面的代码还没有运行😱</li><li id="f7a7" class="lo lp hu jx b jy lx kb ly ke lz ki ma km mb kq lt lu lv lw dt translated">不要让我写一个扩展列表的例子😝</li><li id="3d0d" class="lo lp hu jx b jy lx kb ly ke lz ki ma km mb kq lt lu lv lw dt translated">缺点是使用<code class="eh ks kt ku kv b">ref</code>😭</li></ul><p id="e979" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">都读过。呜哇！</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mc md l"/></div></figure></div></div>    
</body>
</html>