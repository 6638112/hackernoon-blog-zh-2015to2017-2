<html>
<head>
<title>Software Complexity: The Art of Naming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">软件复杂性:命名的艺术</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/software-complexity-naming-6e02e7e6c8cb?source=collection_archive---------2-----------------------#2017-04-05">https://medium.com/hackernoon/software-complexity-naming-6e02e7e6c8cb?source=collection_archive---------2-----------------------#2017-04-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/9c4f3f6bb663e378dffb46f84851cb91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g_Frs8C5mdr6fUP8sqZenQ.png"/></div></div></figure><blockquote class="jc jd je"><p id="693b" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">计算机科学只有两个硬东西:缓存失效和事物命名。</p><p id="1b11" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">菲尔·卡尔顿</p></blockquote><p id="8b62" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt kh translated">美食写作很难。但是为什么呢？因为好的写作是关于好的阅读。我们倾向于关注前者，而忘记后者。我们忘记了代码只写一次，却要读很多次。</p><p id="6caa" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">好的写作是为了阅读的方便而优化，而不是为了写作本身的方便，这个过程的核心涉及到很多同理心。这是关于退后一步，试着从一篇文章中观察另一个角度。一个人必须理解一个人的问题，然后用其他人能理解的方式表达出来。对我来说，这显然把<a class="ae kq" href="https://hackernoon.com/tagged/software" rel="noopener ugc nofollow" target="_blank">软件</a>放到了社会科学的桶里。如果不是为人类，我们为谁写代码？</p><p id="7650" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">因此，我们如何向我们的人类同伴和我们自己传达想法和过程，是<a class="ae kq" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>的核心。</p><h1 id="bf99" class="kr ks hu bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">命名组件</h1><p id="e37a" class="pw-post-body-paragraph jf jg hu ji b jj lp jl jm jn lq jp jq ke lr jt ju kf ls jx jy kg lt kb kc kd hn dt translated">为了说明我们的第一个概念，我们来玩一个游戏。叫<em class="jh">“我们在哪个房间？”</em>。我给你一张照片，你必须说出这是什么房间。</p><p id="652c" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated"><strong class="ji hv">3个问题中的第1个</strong></p><figure class="lu lv lw lx fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/b694147340f37def5e25bf0ecfc5cfc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VpEIo0Zn2NuC1-oneSSAUQ.png"/></div></div><figcaption class="ly lz fg fe ff ma mb bd b be z ek">A couch, what room does it belong to?</figcaption></figure><p id="63a8" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">从这件家具来看，这肯定是<em class="jh">客厅</em>。根据一个组件，我们知道我们所在房间的名字。那很容易。下一个。</p><p id="8add" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated"><strong class="ji hv">第2个问题，共3个问题</strong></p><figure class="lu lv lw lx fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/6340ad86fc4963d0710158406f28282b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_nZcEI2Ch_h3eyA38-t6yw.png"/></div></div><figcaption class="ly lz fg fe ff ma mb bd b be z ek">A toilet, what room does it belong to?</figcaption></figure><p id="422b" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">根据这个物体，我们可以相当肯定地说这是<em class="jh">洗手间</em>。</p><p id="f4b8" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">看到这里的模式了吗？房间的名字是一个<strong class="ji hv">标签</strong>，它定义了里面是什么。有了这个标签，我们不需要查看容器内部就可以知道里面有什么元素。这使我们能够建立我们的第一个推论:</p><p id="5c29" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated"><strong class="ji hv">推论1:容器名是其元素的函数。</strong></p><p id="05c2" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">注意这基本上是鸭子打字。它有床吗？然后是卧室。</p><p id="8788" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">现在，反过来也是正确的:根据容器名，我们可以推断出它的组成部分。如果我们在谈论一间卧室，它很可能有一张床。这使我们能够定义我们的第二个推论:</p><p id="92f3" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">推论2:我们可以根据容器名来推断组件。</p><p id="1ced" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">很明显，但是现在我们有了一些规则，让我们试着把它们应用到下一个房间。</p><p id="ffd1" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated"><strong class="ji hv">第3个问题，共3个问题</strong></p><figure class="lu lv lw lx fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/567d35deb1a7e7d3db0fd1773c51c4a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SvvNee3CsoNV99WxvQWcmA.png"/></div></div><figcaption class="ly lz fg fe ff ma mb bd b be z ek">What room has a toilet and a bed?</figcaption></figure><p id="12d2" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">好了，<em class="jh">同一个房间</em>的一张床和一个马桶？这使得它的定义非常模糊不清，如果我不得不使用推论1和2来命名这个房间，我会叫它<strong class="ji hv">怪物房间</strong>。</p><p id="1617" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">这里的问题不在于同一个房间里物品的数量，而是完全不相关的东西被当作具有相同的功能。在家里，我们把具有相同关注点、目的和意图的东西放在一起，这使组织变得更容易，而通过弄乱这些责任，我们不能确定建筑师想要什么或这些物体应该如何使用。通过混乱，我们阻断了流动。</p><p id="7af4" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated"><strong class="ji hv">推论3:容器定义的清晰程度与其组件的紧密程度成正比。</strong></p><p id="379e" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">这很难读懂，所以我们用一张图:</p><figure class="lu lv lw lx fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/4d5f97e6832cd9b3499972a3e5181952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u_97CQdVgmkRHjHO383K-A.png"/></div></div><figcaption class="ly lz fg fe ff ma mb bd b be z ek">Clarity vs relation</figcaption></figure><p id="c7f7" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">当组件相关时，更容易找到一个好的名称。当事情不相关时，就变得越来越困难。这里的“关系”一词可以是它们的功能、目的、策略、类型等等。在我们谈到标准之前，关系本身并没有多大意义。请耐心听我说，我们很快就会谈到这一点。</p><p id="ee90" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">在软件中，这同样适用。我们有组件、类、功能、服务、应用、小怪物。<em class="jh">“我们的理解与我们的感知相关”</em>，罗伯特·德劳内曾经说过，在这种技术背景下，我们的代码能让读者以最简单的方式感知业务需求吗？</p><p id="6dd5" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated"><strong class="ji hv">例1: HTTP域和汽车</strong></p><p id="cd66" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">HTTP是一个域，它有请求和响应。如果我们将一个名为<code class="eh mc md me mf b">Car</code>的组件放入其中，我们就不能再称它为HTTP了。在这种情况下，它就变成了令人困惑的东西。</p><pre class="lu lv lw lx fq mg mf mh mi aw mj dt"><span id="e8a8" class="mk ks hu mf b fv ml mm l mn mo">public interface WhatIsAGoodNameForThis {<br/>  /* methods for a car */<br/>  public void gas();<br/>  public void brake();</span><span id="37c3" class="mk ks hu mf b fv mp mm l mn mo">  /* methods for an HTTP client */<br/>  public Response makeGetRequest(String param); <br/>}</span></pre><figure class="lu lv lw lx fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/1b69c1c5dbbded4a217d40458119262c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UCxAFRoO6iRAuAnqhPkgJg.png"/></div></div></figure><p id="3882" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated"><strong class="ji hv">示例2:通过单词耦合</strong></p><p id="d6fb" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">一种常见的模式是在类名中附加Builder和其他以<code class="eh mc md me mf b">Er</code>结尾的单词。一些建设者。UserBuilder、AccountBuilder、AccountCreator、UserHelper、JobPerformer。</p><figure class="lu lv lw lx fq iv fe ff paragraph-image"><div class="fe ff mq"><img src="../Images/a2b3340a7f032f99812c8da7d8b7e76a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*3Sc2IiXJz3w7D1j39gqkYA.png"/></div></figure><p id="2b07" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">从名字判断，我们可以解读三件事。首先，类名中的动词Build意味着它是一个穿着类衣服的函数，过程化的。其次，它内部有两个隐藏的实体，一个用户和一个构建者，这意味着可能违反了封装。第三，这意味着Builder可以访问用户的内部工作方式，因为毕竟它们是相互纠缠在一起的。</p><p id="5c00" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">这类似于工厂模式，有它的位置。当我们的例子在整个代码库中被滥用时，它就成了一个问题。另外，提醒一下，在工厂模式中，你不需要为它创建一个类。<code class="eh mc md me mf b">Application</code>的<code class="eh mc md me mf b">createUser()</code>完全可以胜任工厂的工作。</p><p id="9cce" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated"><strong class="ji hv">例3:底座</strong></p><p id="3d22" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">我们来看几个现实生活中的例子。第一个是<a class="ae kq" href="https://github.com/svenfuchs/i18n/blob/master/lib/i18n.rb" rel="noopener ugc nofollow" target="_blank"> I18n </a> Ruby gem(为了简洁起见，只提供了类名和方法名):</p><pre class="lu lv lw lx fq mg mf mh mi aw mj dt"><span id="e759" class="mk ks hu mf b fv ml mm l mn mo">class Base<br/> def config<br/> def translate<br/> def locale_available?(locale)<br/> def transliterate<br/>end</span></pre><p id="b24f" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">在这里，<em class="jh">基</em>不表示意思。它可以配置和翻译，以及判断一个地区是否可用。它在做一些不同的，不相关的事情。</p><p id="2804" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated"><strong class="ji hv">例4:名称引导设计</strong></p><p id="5202" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">当我们谈到名字如何指导我们的设计时，Discourse有几个例子，其中一个让我们感兴趣。</p><pre class="lu lv lw lx fq mg mf mh mi aw mj dt"><span id="84f9" class="mk ks hu mf b fv ml mm l mn mo">class PostAlerter<br/> def notify_post_users<br/> def notify_group_summary<br/> def notify_non_pm_users<br/> def create_notification<br/> def unread_posts<br/> def unread_count<br/> def group_stats<br/>end</span></pre><p id="f38e" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated"><em class="jh">帖子提醒者</em>这个名字暗示了<em class="jh">提醒</em>某人某个帖子的功能。然而，<em class="jh"> unread_posts </em>、<em class="jh"> unread_count </em>和<em class="jh"> group_stats </em>显然处理的是别的东西，使得这个类名对于它所做的事情来说并不理想。将这三种方法转移到一个名为<em class="jh">poststatistics</em>的类中会让事情变得更清晰，对新来者来说也更容易预测。</p><pre class="lu lv lw lx fq mg mf mh mi aw mj dt"><span id="a725" class="mk ks hu mf b fv ml mm l mn mo">class PostAlerter<br/> def notify_post_users<br/> def notify_group_summary<br/> def notify_non_pm_users<br/> def create_notification<br/>end</span><span id="0962" class="mk ks hu mf b fv mp mm l mn mo">class PostsStatistics<br/> def unread_posts<br/> def unread_count<br/> def group_stats<br/>end</span></pre><p id="52d5" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated"><strong class="ji hv">例5:怪物名字</strong></p><p id="aa0a" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">Spring框架有几个例子来说明做了太多事情的组件，因此，需要类似于我们的怪物房间的名称。这里有<a class="ae kq" href="http://docs.spring.io/spring/docs/2.5.x/javadoc-api/org/springframework/aop/config/SimpleBeanFactoryAwareAspectInstanceFactory.html" rel="noopener ugc nofollow" target="_blank">一个</a>(因为<a class="ae kq" href="http://www.javafind.net/gate.jsp?q=%2Flibrary%2F36%2Fjava6_full_apidocs%2Fcom%2Fsun%2Fjava%2Fswing%2Fplaf%2Fnimbus%2FInternalFrameInternalFrameTitlePaneInternalFrameTitlePaneMaximizeButtonWindowNotFocusedState.html" rel="noopener ugc nofollow" target="_blank">这个</a>有点太多了):</p><pre class="lu lv lw lx fq mg mf mh mi aw mj dt"><span id="aa53" class="mk ks hu mf b fv ml mm l mn mo">class SimpleBeanFactoryAwareAspectInstanceFactory {<br/> public ClassLoader getAspectClassLoader()<br/> public Object getAspectInstance()<br/> public int getOrder() <br/> public void setAspectBeanName(String aspectBeanName) <br/> public void setBeanFactory(BeanFactory beanFactory)<br/>} </span></pre><p id="bedc" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated"><strong class="ji hv">例6:好的命名，有所改变</strong></p><p id="b20d" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">糟糕的命名已经够多了。好的命名可以在D3的<a class="ae kq" href="https://github.com/d3/d3-shape/blob/master/src/arc.js" rel="noopener ugc nofollow" target="_blank">弧</a>中找到，比如:</p><pre class="lu lv lw lx fq mg mf mh mi aw mj dt"><span id="8e13" class="mk ks hu mf b fv ml mm l mn mo">export default function() {<br/>  /* ... */<br/>  arc.centroid     = function() { /* ... */ }<br/>  arc.innerRadius  = function() { /* ... */ }<br/>  arc.outerRadius  = function() { /* ... */ }<br/>  arc.cornerRadius = function() { /* ... */ }<br/>  arc.padRadius    = function() { /* ... */ }<br/>  arc.startAngle   = function() { /* ... */ }<br/>  arc.endAngle     = function() { /* ... */ }<br/>  arc.padAngle     = function() { /* ... */ }<br/>  return arc;<br/>}</span></pre><p id="2755" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">这些方法中的每一个都很有意义:它们都是以弧的名称命名的。我喜欢下图的原因是它非常简单。</p><figure class="lu lv lw lx fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/80d5be785045a8cca513ffe3f83d1ad8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UC3TnoNBEHG5mvEFqT3FVA.png"/></div></div></figure><h2 id="05e3" class="mk ks hu bd kt mr ms mt kx mu mv mw lb ke mx my lf kf mz na lj kg nb nc ln nd dt translated">方法1:分开</h2><figure class="lu lv lw lx fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/38388f8e70783b13c5b2bbc7553aab3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fPoNhjVs-z1r8rxpVgF5oA.png"/></div></div><figcaption class="ly lz fg fe ff ma mb bd b be z ek">Divide and… name</figcaption></figure><p id="e780" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated"><strong class="ji hv">何时使用:</strong>您无法为一个类或组件找到一个好的名称，但是您已经有了孤立的概念，并且想要为它们的分组找到一个好的名称。</p><p id="acbf" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">它包括两个步骤:</p><p id="9f78" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">1.确定我们拥有的概念。把他们分开</p><p id="6754" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">在厕所+床的场景中，我们把床推到左边，厕所推到右边，把我们能识别的不同东西分开。好了，现在我们有两个独立的东西，我们终于可以用自然的方式推理了。</p><p id="4371" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">当你找不到一个好名字的时候，你面前可能有不止一个东西。正如你现在所知道的，命名多个事物是很困难的。当遇到麻烦时，试着识别你所拥有的是由哪些片段和动作组成的。</p><p id="cde5" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated"><strong class="ji hv">示例</strong></p><p id="d55a" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">我们有一个未命名的类，包含一个<em class="jh">请求</em>、<em class="jh">响应</em>、<em class="jh">标题</em>、<em class="jh">URL</em>、<em class="jh">正文</em>、<em class="jh">缓存</em>和<em class="jh">超时</em>。除了这个主类，我们只剩下组件<code class="eh mc md me mf b">Request</code>、<code class="eh mc md me mf b">Response</code>、<code class="eh mc md me mf b">Headers</code>、<code class="eh mc md me mf b">URLs</code>、<code class="eh mc md me mf b">ResponseBody</code>、<code class="eh mc md me mf b">Cache</code>、<code class="eh mc md me mf b">Timeout</code>等等。如果我们只有这些类的名称，我们可以相当肯定地假设我们正在处理一个web请求。web请求组件的一个很好的候选是<code class="eh mc md me mf b">HTTPClient</code>。</p><p id="9196" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">代码硬的时候，不要先考虑整体。不要。想想零件。</p><h2 id="50aa" class="mk ks hu bd kt mr ms mt kx mu mv mw lb ke mx my lf kf mz na lj kg nb nc ln nd dt translated">方法2:发现新概念</h2><figure class="lu lv lw lx fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/1dba10889370850251060735818e5f9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XY3AwS4aWraWnmSXHdyMAQ.png"/></div></div><figcaption class="ly lz fg fe ff ma mb bd b be z ek">Compound concept</figcaption></figure><p id="89d7" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated"><strong class="ji hv">何时适用:</strong>当一个类不简单或不连贯时。</p><p id="d335" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">发现新概念需要业务领域的知识。当软件应用与业务相同的术语时，一种无处不在的语言就建立起来了(Evans，2003)，这种语言允许不同专业领域的专业人员使用相同的术语。</p><p id="fc52" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated"><strong class="ji hv">示例1:将组件封装成一个新概念</strong></p><p id="fa08" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">几年前，一家公司即将失去一份大合同。为什么？因为团队发布新功能和修复错误的速度很慢。</p><p id="21bf" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">这个电子商务市场通过多个支付网关向不同国家的学生收取不同规则的费用。需求相当复杂。当我看到收费代码<code class="eh mc md me mf b">PaymentGateway</code>的时候，我震惊于它是多么的复杂，有好几个依赖关系，包括:<code class="eh mc md me mf b">User</code>、<code class="eh mc md me mf b">UserAddress</code>、<code class="eh mc md me mf b">CreditCard</code>、<code class="eh mc md me mf b">BillingAddress</code>、<code class="eh mc md me mf b">SellerAddress</code>、<code class="eh mc md me mf b">LineItems</code>、<code class="eh mc md me mf b">Discounts</code>等等。它的构造函数是巨大的，这种复杂性使得添加新规则变得困难，因为触及一个东西会破坏其他东西，并且要求我们改变所有的网关适配器。</p><p id="5fcc" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">这个问题超出了付款的范围。通过让信息课程再次汇总所有这些数据，向学生发送电子邮件。技术支持有自己的屏幕，第三次聚集了这些数据，只是这个特定的地方使用了一个名为<code class="eh mc md me mf b">Aggregator</code>的类(这个词没有上下文就没有任何意义)。我们必须做些什么来修复这个架构障碍。</p><p id="885f" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">为了解决这个问题，我从一个思维练习开始。以下是事情进展的大致情况:</p><blockquote class="jc jd je"><p id="c974" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我来了，带着这些我需要你帮我收费的细节。如果这是一张桌子，我会把这些文件整理好，我可能会把它们叫做发票。那么，如果我创建一个名为<code class="eh mc md me mf b">Invoice</code>的类，它只不过是所有其他细节的集合，这样网关就不需要知道那些规则是如何执行的，因为<code class="eh mc md me mf b">Invoice</code>会知道。我没有注射一百万个物体，只是把一个交给你？</p></blockquote><p id="eb68" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">发票<em class="jh">术语没有在任何地方使用。我们花了一个月的时间进行重构，一旦完成，我们就能更快地改变软件。</em></p><p id="9d1f" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">发票是一个很好的概念例子，它只是来自许多来源的数据的集合，大多数人都知道它是什么。最终的解决方案添加了<code class="eh mc md me mf b">Invoice</code>类，它被单独注入到网关中，充当门面模式并隐藏其他类。</p><p id="48f7" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">好的命名不仅仅是写出漂亮的文字，还要准确写出以前没有的需要表达的内容。</p><p id="3946" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated"><strong class="ji hv">示例2:基于业务领域的旋转名称</strong></p><p id="7f06" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">在一个全新的拼车项目中，我们从头开始设计这个系统，在研究其他交通解决方案的过程中，描述某人在某一天从出发地到目的地的旅程的合适词是<code class="eh mc md me mf b">trip</code>，这群人被称为<code class="eh mc md me mf b">ride</code>。我们发布了一个词汇表，这样公司的其他人就可以讨论和分享这种无处不在的语言。</p><p id="d054" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">发布后，我们的客户总是将trips称为<code class="eh mc md me mf b">rides</code>。很快，我们在将支持请求转化为必须要做的事情时遇到了问题，在经历了一些痛苦之后，我们决定是时候重构<code class="eh mc md me mf b">trips</code>到<code class="eh mc md me mf b">rides</code>和<code class="eh mc md me mf b">rides</code>到<code class="eh mc md me mf b">carpools</code>了。这解决了一家公司说两种不同语言的问题。</p><p id="d801" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated"><strong class="ji hv">示例3:抽象层次</strong></p><figure class="lu lv lw lx fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ne"><img src="../Images/c3658762553f9407bc047ef13d8b0988.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z62Cd6HIxH696eiJa3Gjiw.png"/></div></div></figure><p id="aa89" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">一个人说，<em class="jh">移动右腿然后左腿然后右腿</em>，另一个人说<em class="jh">走</em>。两者意思相同，但据说后者更抽象。</p><p id="39a8" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">理想情况下，随着代码越来越接近它的公共API，它就越试图匹配业务术语。当它接近数据库和金属时，它使用与其上下文相关的机器术语。在这两者之间，是一个从更抽象到不那么抽象的渐变。</p><p id="16a5" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">在一家公司，一个商务人士会说<em class="jh"> post Tweet </em>，所以像<code class="eh mc md me mf b">postTweet()</code>这样的名字在公共API中比<code class="eh mc md me mf b">makeHttpRequest()</code>更有意义。在一家技术服务更强的公司，后者可能更合适。</p><p id="edb5" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">第二，考虑特异性。<code class="eh mc md me mf b">postTweet()</code>非常具体，而<code class="eh mc md me mf b">makeHttpRequest()</code>非常通用，可以用于脸书或基本上任何涉及HTTP的东西。通用名称可以很容易地重用，但代价是模糊不清。这解释了为什么框架代码与商业软件代码如此不同。</p><p id="004d" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated"><strong class="ji hv">例4:一般化</strong></p><p id="1899" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">很久以前，一个CMS有数据库表<em class="jh">新闻</em>，<em class="jh">历史</em>，<em class="jh">视频</em>，<em class="jh">文章</em>，<em class="jh">页面</em>等。其中大部分都有相同的栏目，<em class="jh">标题</em>，<em class="jh">摘要</em>，<em class="jh">正文</em>。<em class="jh"> videos </em>表有额外的属性，如<em class="jh"> url </em>(用于嵌入YouTube)和<em class="jh"> history </em>有一个<em class="jh"> date </em>属性，因此页面会按年份显示历史事件列表。所有这些表看起来都像副本，有些地方有一些不同，添加新功能需要重新编写大量样板文件。</p><p id="5a2e" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">我将所有这些表折叠成一个名为<code class="eh mc md me mf b">contents</code>的表，其中一个外键指向一个名为<code class="eh mc md me mf b">sections</code>的表，该表包含新闻、历史、视频等栏目列表。现在，<code class="eh mc md me mf b">contents</code>的一个代码就足够了。几年后，一个朋友不得不写一个小的CMS，我建议采用同样的方法。一旦完成了管理内容的表单，实现任何内容所需的时间只有正常情况下的1/N，因为对于每一个相同类型的新部分，都已经完成了。</p><p id="8082" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">通过给它取另一个名字来一般化可以提高生产率。新闻是一种内容。文章是一个内容。历史是一个内容。所有这些可以共享相同的属性吗？是的。调查？不，<em class="jh">不是</em>的一个内容。</p><h2 id="929f" class="mk ks hu bd kt mr ms mt kx mu mv mw lb ke mx my lf kf mz na lj kg nb nc ln nd dt translated">方法3:分组标准</h2><p id="308c" class="pw-post-body-paragraph jf jg hu ji b jj lp jl jm jn lq jp jq ke lr jt ju kf ls jx jy kg lt kb kc kd hn dt translated"><strong class="ji hv">什么时候用:</strong>名字都不错但是不太搭的时候。</p><p id="005f" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">组件可以根据各种标准进行分组，包括物理性质、经济、情感、社会以及软件中最常用的功能。相框是根据情感因素分类的，而产品是根据经济动机分类的。沙发和电视放在同一个房间里，根据功能标准组合在一起，因为它们都有相同的功能或目的，提供休闲。</p><p id="9d36" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">在软件中，我们倾向于按功能对组件进行分组。列出您的项目文件，您可能会看到类似<code class="eh mc md me mf b">controllers/</code>、<code class="eh mc md me mf b">models/</code>、<code class="eh mc md me mf b">adapters/</code>、<code class="eh mc md me mf b">templates/</code>等内容。然而，有时这些小组会觉得不舒服，这将是重新评估模块结构的最佳时间。</p><p id="d2a0" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated"><strong class="ji hv">例:按策略分组</strong></p><p id="90d8" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">一个自动化文档操作的库基于代码生成一个规范文件(即API蓝图),将该文件(保证格式正确)上传到云中(即S3)。</p><p id="661c" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">根据文档格式，将自动做出各种后续决定。选择API蓝图将会选择一个不同的线程，一个不同的测试器和一个不同的API元素转换器。这里基于一个输入对所有这些不同的功能进行分组的关键词是<em class="jh">策略</em>。随后，该库包括一个名为Strategy的模块(或命名空间),用于将文件格式、摘要、文档测试人员和存储提供者分组在一起。这使得该库能够将普通的操作文件(如上传器、解析器和命令行)与业务核心策略分开。</p><h1 id="ae2b" class="kr ks hu bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">利用上下文</h1><p id="0a02" class="pw-post-body-paragraph jf jg hu ji b jj lp jl jm jn lq jp jq ke lr jt ju kf ls jx jy kg lt kb kc kd hn dt translated">每个应用程序都有不同的上下文，其中的每个模块，其中的每个类，下至每个函数。仅单词<em class="jh">用户</em>就可以表示系统的用户，但也可能是数据库表或第三方服务凭证。<code class="eh mc md me mf b">lib/billing/user</code>与<code class="eh mc md me mf b">lib/booking/user</code>不同，但仍然是<code class="eh mc md me mf b">user</code>。</p><figure class="lu lv lw lx fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nf"><img src="../Images/f7f5d4290e96d2f93e337007f04e1536.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qvg14GBJRMyc7c5pIBvbEA.png"/></div></div></figure><p id="0a4a" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">想象一下，每个容器，比如一个模块，都是一个桶。在它们内部，组件与外部世界绝缘。你可以随意命名这些课程。它让大脑不必为普通事物寻找深奥的名称。</p><p id="5a96" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">微服务(许多独立的桶)优于单一体系结构(一个大桶里面有小桶)的一个强有力的论点是，它在每个服务中强制执行约束责任，因为现在您不能轻易地将完全不相关的东西相互纠缠在一起。记账生活在BillingApp内部，预订生活在BookingApp内部，等等。在整体架构中，这些各自的服务名称可能是简单的模块名称，但不是每个人都有保持事物整洁的纪律。</p><p id="8fc1" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated"><strong class="ji hv">示例:名称空间</strong></p><p id="ba49" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">马克正在构建一个<em class="jh">广告</em>平台，该平台需要生成数十万个广告，然后发送给广告词、和必应，所有这些都是通过图形用户界面进行管理的。</p><p id="06aa" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">Mark从一个名为<code class="eh mc md me mf b">Ad</code>的实体开始，这个实体很快变得臃肿。AdWords的广告有<code class="eh mc md me mf b">headline_part1</code>和<code class="eh mc md me mf b">headline_part2</code>，脸书的没有，而必应只有<code class="eh mc md me mf b">headline</code>。他需要想办法分裂他的实体。他思考不同的上下文，以及如何利用语言的名称空间特性来表达。他提出了以下结构:</p><ul class=""><li id="3ef4" class="ng nh hu ji b jj jk jn jo ke ni kf nj kg nk kd nl nm nn no dt translated"><code class="eh mc md me mf b">Adwords::Ad</code>:表示Adwords中的广告对象。它具有Adwords特有的属性，逻辑可以包含在这个类中。</li><li id="4c0e" class="ng nh hu ji b jj np jn nq ke nr kf ns kg nt kd nl nm nn no dt translated"><code class="eh mc md me mf b">Facebook::Ad</code>:和上一个一样，只是有脸书的具体要求和逻辑。</li><li id="a40a" class="ng nh hu ji b jj np jn nq ke nr kf ns kg nt kd nl nm nn no dt translated"><code class="eh mc md me mf b">Bing::Ad</code>:同上。</li><li id="88de" class="ng nh hu ji b jj np jn nq ke nr kf ns kg nt kd nl nm nn no dt translated"><code class="eh mc md me mf b">RemoteAdService::Ad</code>:作为<code class="eh mc md me mf b">Adwords::Ad</code>、<code class="eh mc md me mf b">Facebook::Ad</code>、<code class="eh mc md me mf b">Bing::Ad</code>与系统其余部分之间的接口。这意味着这三个类将拥有相同的公共API，允许系统利用多态性。</li><li id="8f47" class="ng nh hu ji b jj np jn nq ke nr kf ns kg nt kd nl nm nn no dt translated"><code class="eh mc md me mf b">Database::Ad</code>:这是<code class="eh mc md me mf b">ads</code>表的ORM。它使用ActiveRecord、DataMapper或任何自定义解决方案。</li><li id="6c52" class="ng nh hu ji b jj np jn nq ke nr kf ns kg nt kd nl nm nn no dt translated"><code class="eh mc md me mf b">GUI::Ad</code>:表示在UI中显示广告所需的属性。它可能具有表示和国际化功能。</li><li id="9e19" class="ng nh hu ji b jj np jn nq ke nr kf ns kg nt kd nl nm nn no dt translated"><code class="eh mc md me mf b">API::Ad</code>:广告的HTTP端点将有自己的自定义属性，因此序列化逻辑存在于此是有意义的。</li></ul><p id="a6de" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">根据上下文，单词可以有不同的含义，当我们利用上下文时，我们可以为组件选择更简单的单词。在这个例子中，我们不需要做任何杂技动作来找到那些组件名，因为它们都是一个东西，ad。</p><h1 id="4cce" class="kr ks hu bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">无意义和新词</h1><p id="62bd" class="pw-post-body-paragraph jf jg hu ji b jj lp jl jm jn lq jp jq ke lr jt ju kf ls jx jy kg lt kb kc kd hn dt translated">随着时间的推移，名字演变并获得新的含义。其他人进来填补漏洞。</p><p id="5dfb" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated"><strong class="ji hv">助手:</strong>助手是支持应用程序主要目标的功能。但是，定义应用程序主要目标的标准是什么？应用程序中的一切都支持应用程序的主要目标。</p><p id="8c1a" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">在实践中，它们被不自然地组合在一起，为一些杂七杂八的常用操作提供可重用性。他们倾向于遭受<a class="ae kq" href="https://sourcemaking.com/refactoring/smells/feature-envy" rel="noopener ugc nofollow" target="_blank">特性嫉妒</a>，在那里他们需要访问另一个组件的内部数据来工作。它们是人们找不到合适名称的事物的借口。</p><p id="ab40" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated"><strong class="ji hv"> Base: </strong>命名为<em class="jh"> Base </em>的类是很久以前C#中的一个约定，用于在缺少更好的名称时指定继承。例如，<code class="eh mc md me mf b">Automobile</code>和<code class="eh mc md me mf b">Bicycle</code>的父类将是<code class="eh mc md me mf b">Base</code>而不是<code class="eh mc md me mf b">Vehicle</code>。尽管微软建议避免使用这个名字(Cwalina，2009)，它还是感染了Ruby世界，最显著的是通过<code class="eh mc md me mf b">ActiveRecord</code>。直到今天，我们仍然把<em class="jh"> Base </em>看作是开发人员找不到名字的东西的类名。</p><p id="f847" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated"><em class="jh">底座</em>的变体包括<em class="jh">普通</em>和<em class="jh">实用</em>。例如，<a class="ae kq" href="https://github.com/flori/json/blob/65297fbae1e92e26fdde886fe156bac322977db2/lib/json/common.rb" rel="noopener ugc nofollow" target="_blank"> JSON </a> Ruby gem <code class="eh mc md me mf b">Common</code>类有方法<code class="eh mc md me mf b">parse</code>、<code class="eh mc md me mf b">generate</code>、<code class="eh mc md me mf b">load</code>和<code class="eh mc md me mf b">jj</code>，但是common在这里真正的意思是什么呢？</p><p id="8156" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated"><strong class="ji hv">任务:</strong>Javascript社区有一波调用异步函数，<em class="jh">任务</em>。它始于task.js，这个术语甚至在最初的库不存在的时候也开始使用。</p><p id="76be" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">团队里的人都懂吗？那就没事了！但是当新成员加入团队时，自60年代以来就存在的命名法会被扔进垃圾堆吗？</p><p id="2b26" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">我在一个项目中工作，其中一个类的名字是，猜猜看，亚特兰大。是的，亚特兰大。该死的亚特兰大。没有人知道或能告诉我为什么这么叫。</p><h1 id="5a51" class="kr ks hu bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">交流</h1><blockquote class="jc jd je"><p id="6cc6" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">"现实存在于人的头脑中，而不存在于其他地方."乔治·奥威尔</p></blockquote><p id="5f82" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">我相信擅长交流是一种利他主义的行为，我们为提高技能所付出的努力与我们关心他人的程度相关。我们希望人们容易理解，我们希望消除摩擦和障碍。</p><p id="a06b" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">其次，我们希望别人理解我们。通过接受接收者接收信息是发送者的责任，我们建立了一个共情的环境。这是双赢的局面。没有理由不刻意练习我们的沟通技巧——除非你生活在丛林中。</p><p id="16d0" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">通过写作，我们为阅读做了优化，而移情练习可能会让人精疲力尽。但是，就像生活中的一切一样，熟练只属于那些练习的人。</p><p id="435d" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated"><strong class="ji hv">参考书目</strong></p><p id="22c6" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">克日什托夫Cwalina。2009.框架设计指南:可重用的惯例、习惯用法和模式。NET库，第二版。波士顿:皮尔逊教育公司206。</p><p id="f02b" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">埃文斯埃里克。2003.领域驱动设计:解决软件核心的复杂性。波士顿:艾迪生-卫斯理专业。</p><div class="lu lv lw lx fq ab cb"><figure class="nu iv nv nw nx ny nz paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nu iv nv nw nx ny nz paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nu iv nv nw nx ny nz paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="jc jd je"><p id="f922" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><a class="ae kq" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kq" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kq" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae kq" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kq" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kq" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lu lv lw lx fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff oa"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="lu lv lw lx fq iv"><div class="bz el l di"><div class="ob oc l"/></div></figure></div></div>    
</body>
</html>