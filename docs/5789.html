<html>
<head>
<title>How fast is yes in Node?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node里的yes有多快？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-fast-is-yes-in-node-e6004c4486bf?source=collection_archive---------12-----------------------#2017-08-16">https://medium.com/hackernoon/how-fast-is-yes-in-node-e6004c4486bf?source=collection_archive---------12-----------------------#2017-08-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/623a80bf39d3cb50fa3f8a4bf6a541a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pu3-rFEZY7pPqCwbPJhUtA.jpeg"/></div></div></figure><div class=""/><p id="31d7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当开发人员厌倦了在终端中对用户协议、安装或确认之类的事情说Y(是)时，他们会编写诸如<a class="ae ka" href="https://en.wikipedia.org/wiki/Yes_(Unix)" rel="noopener ugc nofollow" target="_blank"> <strong class="je ig"> yes </strong> </a>之类的程序。这是一个在Node中实现“y\n”的高吞吐量的故事。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><h2 id="7216" class="ki kj if bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated">灵感和方法</h2><p id="8941" class="pw-post-body-paragraph jc jd if je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">这个故事的灵感来自于<a class="ae ka" href="https://hackernoon.com/how-fast-is-yes-in-go-1acc57b98815" rel="noopener ugc nofollow" target="_blank">“yes in Go有多快”</a>的一篇文章，这篇文章本身就受到了<a class="ae ka" href="https://www.reddit.com/r/unix/comments/6gxduc/how_is_gnu_yes_so_fast/?st=j3v3iw3c&amp;sh=5651ea3c" rel="noopener ugc nofollow" target="_blank">这次讨论</a>的启发。在我们的例子中，我们还将依靠<a class="ae ka" href="https://linux.die.net/man/1/pv" rel="noopener ugc nofollow" target="_blank"> <strong class="je ig"> pv </strong> </a>来测量吞吐量并记录峰值结果，通过输出字符“y”后跟适当的行尾字符来复制默认行为<strong class="je ig"> yes </strong>。我们将使用来自<strong class="je ig"> </strong> <code class="eh li lj lk ll b">yes | pv &gt; /dev/null</code>的<strong class="je ig"> 8.01 GiB/s </strong>作为基线进行测量。<em class="lm">硬件设置如下。</em></p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><h1 id="e74d" class="ln kj if bd kk lo lp lq ko lr ls lt ks lu lv lw kv lx ly lz ky ma mb mc lb md dt translated">使用console.log和process.stdout.write</h1><p id="c50d" class="pw-post-body-paragraph jc jd if je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">也许首先想到的是使用我们的老朋友<code class="eh li lj lk ll b">console.log</code>，它几乎没有让我们失望，并且使用一个无限的while循环来保持应用程序运行...此外，由于<code class="eh li lj lk ll b">console.log</code>会在每个日志后自动添加一个EOL，因此可以节省一个步骤:</p><figure class="me mf mg mh fq hw"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="4980" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如您所见，性能非常糟糕，几乎比我们的基线慢了10，000倍。如果我们抛开<code class="eh li lj lk ll b">console</code>抽象，直接写<code class="eh li lj lk ll b">stdout</code>会怎么样？我们现在只需要添加从操作系统导入的EOL，并测量:</p><figure class="me mf mg mh fq hw"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="85f4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这相对不错，但我们可以做得更好。让我们尝试根据上一篇文章来缓冲我们的输出，我们将利用最小的页面对象大小<code class="eh li lj lk ll b">4096</code>，以便在从内存写入底层文件描述符(fd)时获得一些效率:</p><figure class="me mf mg mh fq hw"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="906e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在短时间内，我们获得了一些吞吐量，然后什么也没有。是一个隐藏的流，每当它可以推送数据时，它就写入文件描述符，否则它会将数据缓冲回内存，直到可以再次推送数据。不幸的是，我们在这里用我们的同步循环淹没了异步流<a class="ae ka" href="https://nodejs.org/api/process.html#process_a_note_on_process_i_o" rel="noopener ugc nofollow" target="_blank">(有些例外)</a>，特别是有那么多数据被缓冲回到流中，我们可以通过编写一个半异步循环来解决这个问题:</p><figure class="me mf mg mh fq hw"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="7cde" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那就好多了！这使我们处于GiB领域，但我认为我们可以进一步推动Node。</p><p id="13ac" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="lm">注意</em> <code class="eh li lj lk ll b"><em class="lm">Buffer.alloc</em></code> <em class="lm">中的第二个参数用给定的字符串填充整个缓冲区。</em></p><h1 id="bf88" class="ln kj if bd kk lo mk lq ko lr ml lt ks lu mm lw kv lx mn lz ky ma mo mc lb md dt translated">使用流和其他优化</h1><p id="04fe" class="pw-post-body-paragraph jc jd if je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">我之前提到过<code class="eh li lj lk ll b">process.stdout</code>是<a class="ae ka" href="https://nodejs.org/api/process.html#process_a_note_on_process_i_o" rel="noopener ugc nofollow" target="_blank">一种奇特的河流</a>，那么为什么不通过管道把一条河流输送到那里呢？本质上，流的工作方式是根据可用的吞吐量读写数据，并缓冲其余的数据以备后用。我们可以聪明地使用我们的<strong class="je ig"> yes.js </strong>程序，只发送需要的内容。</p><p id="3cf3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将从创建一个<a class="ae ka" href="https://nodejs.org/api/stream.html#stream_readable_streams" rel="noopener ugc nofollow" target="_blank">可读流</a>开始，该流将推送一个大小相等的缓冲区，因为总是适合整个字符集并且不丢失一个换行符是很重要的:</p><figure class="me mf mg mh fq hw"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="90f4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的流中的<code class="eh li lj lk ll b">_read</code>方法将被调用，其大小取决于要读取或在我们的例子中产生的数据量。然后，我们可以创建这个流的一个新实例，并将其通过管道传输到<code class="eh li lj lk ll b">process.stdout</code>，这将产生<strong class="je ig"> 3.25GiB/s </strong>的吞吐量，这一点都不差！但是我们正在分配一个全新的缓冲区，并在每次调用<code class="eh li lj lk ll b">_read</code>方法时填充它。让我们缓存我们的缓冲区并创建一个最终版本:</p><figure class="me mf mg mh fq hw"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="8048" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最终峰值吞吐量<strong class="je ig">为4.67 GiB/s </strong>，比我们开始时快了5万倍，比我们基线的一半还要好。在同一台机器上，Golang能够使用Mat Evans的source实现<strong class="je ig"> 7.75 GiB/s </strong>。</p><p id="ab6f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作为旁注，<code class="eh li lj lk ll b">console.log</code>不是一个<a class="ae ka" href="https://www.npmjs.com/package/lorg" rel="noopener ugc nofollow" target="_blank">高性能日志解决方案</a>,如果你完全依赖它，但是它有一大堆简单日志记录器所没有的内置特性。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><h2 id="33d1" class="ki kj if bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated">运行测量的设置是什么？</h2><p id="5e90" class="pw-post-body-paragraph jc jd if je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">为了测量峰值吞吐量，所有测试都在同一台远程机器上单独运行，该机器装有运行Ubuntu 17.0的英特尔至强E3 1240 v3(3.4 GHz)和32GB DDR 3内存。<em class="lm">在应用端Node.js版本8.3.0和7.10.0和Golang 1.7.4被使用。</em></p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><h2 id="d006" class="ki kj if bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated">最后的想法</h2><p id="cd83" class="pw-post-body-paragraph jc jd if je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">你可以从npm 安装并运行<a class="ae ka" href="https://www.npmjs.com/package/fast-yes" rel="noopener ugc nofollow" target="_blank">最终代码。有许多展示语言/框架能力的好方法，但是<strong class="je ig">是的</strong>开始成为我个人最喜欢的方法之一，它展示了原始的单线程吞吐量，而没有牺牲简单性。</a></p></div></div>    
</body>
</html>