<html>
<head>
<title>tmux in practice: copy text from remote session using SSH remote tunnel and systemd service</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">tmux实践:使用SSH远程隧道和systemd服务从远程会话复制文本</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/tmux-in-practice-copy-text-from-remote-session-using-ssh-remote-tunnel-and-systemd-service-dd3c51bca1fa?source=collection_archive---------4-----------------------#2017-11-27">https://medium.com/hackernoon/tmux-in-practice-copy-text-from-remote-session-using-ssh-remote-tunnel-and-systemd-service-dd3c51bca1fa?source=collection_archive---------4-----------------------#2017-11-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="8487" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">将文本从远程会话复制到本地剪贴板的另一种方法</h2></div><p id="6668" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在“tmux实践”系列的前一篇文章<a class="ae kf" rel="noopener" href="/@alexeysamoshkin/tmux-in-practice-integration-with-system-clipboard-bcd72c62ff7b">中，我们已经讨论了从</a><a class="ae kf" href="https://hackernoon.com/tagged/tmux" rel="noopener ugc nofollow" target="_blank"> tmux </a>会话向系统剪贴板共享复制文本的各种解决方案。虽然这对于本地会话来说很容易设置(只需将选定的文本通过管道发送到<code class="eh kg kh ki kj b">pbcopy</code>或<code class="eh kg kh ki kj b">xclip</code>或<code class="eh kg kh ki kj b">xsel</code>)，但是当您使用远程tmux会话时，事情就变得复杂了。您需要一些机制来将数据从远程机器传输到本地系统的剪贴板。如果您的终端仿真器处理<a class="ae kf" href="https://sunaku.github.io/tmux-yank-osc52.html" rel="noopener ugc nofollow" target="_blank"> OSC 52 ANSI转义序列</a>，那么您是幸运的。然而，只有少数终端模拟器支持这个特性:它可以在iTerm的OSX上开箱即用，并且很可能在<a class="ae kf" href="https://hackernoon.com/tagged/linux" rel="noopener ugc nofollow" target="_blank"> Linux </a>上失败(除非您使用的是基本的xterm)。</p><p id="99bc" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">今天，让我们探索替代解决方案。它由以下部分组成:</p><ol class=""><li id="e2f4" class="kk kl hu jl b jm jn jp jq js km jw kn ka ko ke kp kq kr ks dt translated">在本地机器上，我们将设置systemd服务，监听网络套接字，将接收到的任何输入通过管道传输到<code class="eh kg kh ki kj b">xclip</code>，从而将其存储在系统剪贴板中。</li><li id="e9d4" class="kk kl hu jl b jm kt jp ku js kv jw kw ka kx ke kp kq kr ks dt translated">设置SSH远程隧道，连接远程机器上的端口和本地机器上的端口，我们的服务在本地机器上监听。</li><li id="4ab2" class="kk kl hu jl b jm kt jp ku js kv jw kw ka kx ke kp kq kr ks dt translated">更改远程tmux配置，将选定的文本通过管道传输到远程机器上的网络端口，以便通过SSH远程隧道传输到本地机器。</li></ol><h1 id="a7bc" class="ky kz hu bd la lb lc ld le lf lg lh li ja lj jb lk jd ll je lm jg ln jh lo lp dt translated">套接字激活的xclip系统服务</h1><p id="472a" class="pw-post-body-paragraph jj jk hu jl b jm lq iv jo jp lr iy jr js ls ju jv jw lt jy jz ka lu kc kd ke hn dt translated">所以我们需要在某个端口上设置网络监听器。当建立连接时，任何输入都应该通过管道传输到<code class="eh kg kh ki kj b">xclip</code>以存储在系统剪贴板上。这个服务将永久运行，所以我们的选择是创建一个systemd套接字激活的服务。如果你在OSX，使用launchd而不是systemd(见下面关于OSX的段落)。</p><p id="a955" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最简单的方法是创建两个单元文件:服务单元和套接字单元。把你的单位文件放在<code class="eh kg kh ki kj b">/etc/systemd/system</code>目录下。让我们从<code class="eh kg kh ki kj b">/etc/systemd/system/xclip.socket</code>文件开始:</p><pre class="lv lw lx ly fq lz kj ma mb aw mc dt"><span id="8646" class="md kz hu kj b fv me mf l mg mh">[Unit]<br/>Description=Network copy backend for tmux based on xclip</span><span id="504d" class="md kz hu kj b fv mi mf l mg mh">[Socket]<br/>ListenStream=19988<br/>Accept=yes</span><span id="dd74" class="md kz hu kj b fv mi mf l mg mh">[Install]<br/>WantedBy=sockets.target</span></pre><p id="b5e4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">单元文件只是说这是一个监听端口19988的网络套接字。服务设计因<code class="eh kg kh ki kj b">Accept</code>设置的不同而有很大差异:</p><ul class=""><li id="9329" class="kk kl hu jl b jm jn jp jq js km jw kn ka ko ke mj kq kr ks dt translated"><code class="eh kg kh ki kj b">yes</code>，systemd将接受传入的连接，并将连接套接字传递给目标服务。然后，套接字可以连接到服务进程的标准输入和标准输出文件描述符。服务在第一次连接时被延迟启动。将为每个传入的连接生成新的服务实例(模板化的单元在幕后使用)</li><li id="21a8" class="kk kl hu jl b jm kt jp ku js kv jw kw ka kx ke mj kq kr ks dt translated"><code class="eh kg kh ki kj b">no</code>，systemd将不接受连接，监听套接字将传递给服务。程序必须定制，以便它可以处理这些插座(使用<code class="eh kg kh ki kj b">sd_listen_fds</code>功能)。无论连接数多少，都只会产生一个服务实例(单一服务)。服务被延迟激活，并在第一次传入连接时启动。</li></ul><p id="78b0" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们坚持使用<code class="eh kg kh ki kj b">Accept=yes</code>设计，因为它非常简单，只需使用<code class="eh kg kh ki kj b">xclip</code>命令，无需任何修改，只需将套接字连接到xclip的标准输入和标准输出描述符。</p><p id="6eca" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，让我们创建<code class="eh kg kh ki kj b">/etc/systemd/system/xclip@.service</code>。注意，<code class="eh kg kh ki kj b">Accept=yes</code>一提出这个要求，就应该是模板单元文件。</p><pre class="lv lw lx ly fq lz kj ma mb aw mc dt"><span id="7f6a" class="md kz hu kj b fv me mf l mg mh">[Unit]<br/>Description=Copy backend service piping input to xclip</span><span id="4d84" class="md kz hu kj b fv mi mf l mg mh">[Service]<br/>Type=simple<br/>ExecStart=/usr/bin/xclip -i -f -selection primary | /usr/bin/xclip -i -selection clipboard<br/>StandardInput=socket<br/>StandardOutput=socket</span></pre><p id="9f11" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们使用熟悉的xclip命令将数据存储在主选择和剪贴板选择中。</p><p id="0832" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，让我们启用并启动我们的套接字单元。<code class="eh kg kh ki kj b">enable</code> -表示它将在下次系统启动时自动启动，<code class="eh kg kh ki kj b">start </code> -表示我们现在手动启动它。</p><pre class="lv lw lx ly fq lz kj ma mb aw mc dt"><span id="5060" class="md kz hu kj b fv me mf l mg mh">$ sudo systemctl enable xclip.socket<br/>Created symlink from /etc/systemd/system/sockets.target.wants/xclip.socket to /etc/systemd/system/xclip.socket.</span><span id="3e24" class="md kz hu kj b fv mi mf l mg mh">$ sudo systemctl start xclip.socket</span><span id="f736" class="md kz hu kj b fv mi mf l mg mh">$ sudo systemctl status xclip.socket</span><span id="e84d" class="md kz hu kj b fv mi mf l mg mh">● xclip.socket - XClip socket<br/>   Loaded: loaded (/etc/systemd/system/xclip.socket; enabled; vendor preset: disabled)<br/>   Active: active (listening) since Mon 2017-11-27 15:07:12 EET; 3s ago<br/>   Listen: [::]:19988 (Stream)<br/> Accepted: 0; Connected: 0</span><span id="a207" class="md kz hu kj b fv mi mf l mg mh">Nov 27 15:07:12 centos7 systemd[1]: Listening on XClip socket.<br/>Nov 27 15:07:12 centos7 systemd[1]: Starting XClip socket.</span></pre><p id="bf17" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们看到我们的插座单元启动了。<code class="eh kg kh ki kj b">Accepted</code>表示自服务启动以来建立的连接总数，<code class="eh kg kh ki kj b">Connected</code>表示当前活动连接的数量。让我们确保端口19988正在侦听:</p><pre class="lv lw lx ly fq lz kj ma mb aw mc dt"><span id="9bbc" class="md kz hu kj b fv me mf l mg mh">$ ss -tnl '( sport = 19988 )'</span><span id="079b" class="md kz hu kj b fv mi mf l mg mh">State      Recv-Q Send-Q Local Address:Port  Peer Address:Port<br/>LISTEN     0      128    :::19988            :::*</span></pre><p id="481f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以使用<code class="eh kg kh ki kj b">netcat</code>来测试我们的服务。你发送给它的任何数据都应该在系统剪贴板中。在我们深入之前测试一下。</p><pre class="lv lw lx ly fq lz kj ma mb aw mc dt"><span id="ba9b" class="md kz hu kj b fv me mf l mg mh">echo "text to copy" | nc localhost 19988</span></pre><p id="4caf" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">注意，如果您对服务实例单元状态感兴趣，您将不会通过<code class="eh kg kh ki kj b">systemctl list-units</code>找到任何正在运行的实例。这是因为一旦xclip进程退出，它就会产生并立即退出。</p><h1 id="5ff0" class="ky kz hu bd la lb lc ld le lf lg lh li ja lj jb lk jd ll je lm jg ln jh lo lp dt translated">SSH远程隧道</h1><p id="46e0" class="pw-post-body-paragraph jj jk hu jl b jm lq iv jo jp lr iy jr js ls ju jv jw lt jy jz ka lu kc kd ke hn dt translated">当您连接到远程机器时，使用以下命令设置SSH远程隧道:</p><pre class="lv lw lx ly fq lz kj ma mb aw mc dt"><span id="f702" class="md kz hu kj b fv me mf l mg mh">ssh -R 19988:localhost:19988 alexeys@192.168.33.101</span></pre><p id="d4a5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">或者您可以在您的<code class="eh kg kh ki kj b">~/.ssh/config</code>文件中设置一次:</p><pre class="lv lw lx ly fq lz kj ma mb aw mc dt"><span id="aae0" class="md kz hu kj b fv me mf l mg mh">Host vb_ubuntu14<br/>  Hostname 192.168.33.100<br/>  User alexeys<br/>  IdentityFile ~/.ssh/alexeys_at_vb_ubuntu14<br/>  RemoteForward 19988 localhost:19988</span></pre><p id="d9e8" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后就:</p><pre class="lv lw lx ly fq lz kj ma mb aw mc dt"><span id="29c8" class="md kz hu kj b fv me mf l mg mh">ssh vb_ubuntu14</span></pre><p id="8ff8" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">SSH远程隧道允许远程网络上的应用程序通过特定端口(在我们的例子中，localhost:19988)与本地网络上的服务对话。为了避免混乱，我们在本地和远程机器上使用相同的端口号。</p><h1 id="4202" class="ky kz hu bd la lb lc ld le lf lg lh li ja lj jb lk jd ll je lm jg ln jh lo lp dt translated">tmux配置</h1><p id="a042" class="pw-post-body-paragraph jj jk hu jl b jm lq iv jo jp lr iy jr js ls ju jv jw lt jy jz ka lu kc kd ke hn dt translated">现在，当我们准备好所有的部分时，我们可以将它们连接到我们在“tmux实践”的前一部分中制作的<code class="eh kg kh ki kj b">~/.tmux.conf.</code>let extend<code class="eh kg kh ki kj b">yank.sh</code>文件:</p><pre class="lv lw lx ly fq lz kj ma mb aw mc dt"><span id="5c5b" class="md kz hu kj b fv me mf l mg mh"><em class="mk"># Resolve copy backend: pbcopy (OSX), reattach-to-user-namespace (OSX), xclip/xsel (Linux), or network service</em></span><span id="3927" class="md kz hu kj b fv mi mf l mg mh"><em class="mk"># get data either form stdin or from file<br/></em>buf=$(cat "$@")</span><span id="01d2" class="md kz hu kj b fv mi mf l mg mh">copy_backend=""<br/>if is_app_installed pbcopy; then<br/>  copy_backend="pbcopy"<br/>elif is_app_installed reattach-to-user-namespace; then<br/>  copy_backend="reattach-to-user-namespace pbcopy"<br/>elif [ -n "${DISPLAY-}" ] &amp;&amp; is_app_installed xsel; then<br/>  copy_backend="xsel -i --clipboard"<br/>elif [ -n "${DISPLAY-}" ] &amp;&amp; is_app_installed xclip; then<br/>  copy_backend="xclip -i -f -selection primary | xclip -i -selection clipboard"<br/>elif [ "$(ss -n -4 state listening "( sport = 19988 )" | tail -n +2 | wc -l)" -eq 1 ]; then<br/>  copy_backend="nc localhost 19988"<br/>fi</span><span id="bb0d" class="md kz hu kj b fv mi mf l mg mh"><em class="mk"># if copy backend is resolved, copy and exit<br/></em>if [ -n "$copy_backend" ]; then<br/>  printf "$buf" | eval "$copy_backend"<br/>  exit;<br/>fi</span></pre><p id="9132" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里我们有分支逻辑来选择剪贴板后端，我们应该在那里传输一个选定的文本。后者<code class="eh kg kh ki kj b">elif</code>检查是否有人监听端口<code class="eh kg kh ki kj b">19988</code>，并将数据netcats到该端口。</p><p id="22d6" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kg kh ki kj b">~/.tmux.conf</code>中的按键:</p><pre class="lv lw lx ly fq lz kj ma mb aw mc dt"><span id="8099" class="md kz hu kj b fv me mf l mg mh">yank="~/.tmux/yank.sh"</span><span id="4c17" class="md kz hu kj b fv mi mf l mg mh">bind -T copy-mode-vi Enter send-keys -X copy-pipe-and-cancel “$yank”<br/>bind -T copy-mode-vi Y send-keys -X copy-pipe-and-cancel “$yank; tmux paste-buffer”<br/>bind-key -T copy-mode-vi D send-keys -X copy-end-of-line \<em class="mk">; </em>run "tmux save-buffer - | $yank"<br/>bind-key -T copy-mode-vi A send-keys -X append-selection-and-cancel \<em class="mk">; </em>run "tmux save-buffer - | $yank"</span></pre><h1 id="a7d0" class="ky kz hu bd la lb lc ld le lf lg lh li ja lj jb lk jd ll je lm jg ln jh lo lp dt translated">限制</h1><p id="00fd" class="pw-post-body-paragraph jj jk hu jl b jm lq iv jo jp lr iy jr js ls ju jv jw lt jy jz ka lu kc kd ke hn dt translated">老实说，解决方案并不像微风一样轻巧。此外，它也有局限性。</p><p id="a8e9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果您使用相同的端口转发配置启动多个SSH会话(从相同的本地机器或不同的机器)到相同的远程机器，则只有第一个连接将正常运行文本复制。在这种情况下，您需要将不同的远程端口隧道连接到同一个本地端口，并更改<code class="eh kg kh ki kj b">tmux.conf</code>来探测几个端口。</p><h1 id="59b6" class="ky kz hu bd la lb lc ld le lf lg lh li ja lj jb lk jd ll je lm jg ln jh lo lp dt translated">OSX怎么了？</h1><p id="67ea" class="pw-post-body-paragraph jj jk hu jl b jm lq iv jo jp lr iy jr js ls ju jv jw lt jy jz ka lu kc kd ke hn dt translated">上面所说的一切对OSX来说都是正确的，除了你将使用launchd而不是systemd，并且使用<code class="eh kg kh ki kj b">pbcopy </code>而不是<code class="eh kg kh ki kj b">xclip.</code></p><p id="4120" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">以下是等效启动服务的示例:</p><pre class="lv lw lx ly fq lz kj ma mb aw mc dt"><span id="12ce" class="md kz hu kj b fv me mf l mg mh">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "<a class="ae kf" href="http://www.apple.com/DTDs/PropertyList-1.0.dtd" rel="noopener ugc nofollow" target="_blank">http://www.apple.com/DTDs/PropertyList-1.0.dtd</a>"&gt;<br/>&lt;plist version="1.0"&gt;<br/>&lt;dict&gt;<br/>    &lt;key&gt;Label&lt;/key&gt;<br/>    &lt;string&gt;local.pbcopy&lt;/string&gt;<br/>    &lt;key&gt;UserName&lt;/key&gt;<br/>    &lt;string&gt;asamoshkin&lt;/string&gt;<br/>    &lt;key&gt;Program&lt;/key&gt;<br/>    &lt;string&gt;/usr/bin/pbcopy&lt;/string&gt;<br/>    &lt;key&gt;Sockets&lt;/key&gt;<br/>    &lt;dict&gt;<br/>        &lt;key&gt;Listeners&lt;/key&gt;<br/>        &lt;dict&gt;<br/>            &lt;key&gt;SockNodeName&lt;/key&gt;<br/>            &lt;string&gt;localhost&lt;/string&gt;<br/>            &lt;key&gt;SockServiceName&lt;/key&gt;<br/>            &lt;string&gt;19988&lt;/string&gt;<br/>        &lt;/dict&gt;<br/>    &lt;/dict&gt;<br/>    &lt;key&gt;inetdCompatibility&lt;/key&gt;<br/>    &lt;dict&gt;<br/>        &lt;key&gt;Wait&lt;/key&gt;<br/>        &lt;false/&gt;<br/>    &lt;/dict&gt;<br/>&lt;/dict&gt;<br/>&lt;/plist&gt;</span></pre><p id="6589" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">要安装并启动它:</p><pre class="lv lw lx ly fq lz kj ma mb aw mc dt"><span id="e97d" class="md kz hu kj b fv me mf l mg mh">$ launchctl load local.pbcopy.plist<br/>$ launchctl start local.pbcopy</span></pre><p id="e9d7" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通过查看我的<a class="ae kf" href="https://github.com/samoshkin/tmux-config" rel="noopener ugc nofollow" target="_blank"> tmux-config </a> repo，你可以看到所有这些东西在起作用。</p><h1 id="ea51" class="ky kz hu bd la lb lc ld le lf lg lh li ja lj jb lk jd ll je lm jg ln jh lo lp dt translated">资源和链接</h1><p id="287d" class="pw-post-body-paragraph jj jk hu jl b jm lq iv jo jp lr iy jr js ls ju jv jw lt jy jz ka lu kc kd ke hn dt translated">MAC OS——如何使用iTerm2从远程shell复制到OSX剪贴板？—提问不同—<a class="ae kf" href="https://apple.stackexchange.com/questions/257609/how-do-i-copy-to-the-osx-clipboard-from-a-remote-shell-using-iterm2" rel="noopener ugc nofollow" target="_blank">https://apple . stack exchange . com/questions/257609/how-do-I-copy-to-the-OS x-clipboard-from-a-remote-shell-using-ITER m2</a></p><p id="b71d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">macos —在远程tmux会话和本地macos粘贴板之间同步粘贴板—超级用户—<a class="ae kf" href="https://superuser.com/questions/407888/synchronize-pasteboard-between-remote-tmux-session-and-local-mac-os-pasteboard/408374#408374" rel="noopener ugc nofollow" target="_blank">https://Super User . com/questions/407888/Synchronize-pasteboard-between-remote-tmux-session-and-local-Mac-OS-pasteboard/408374 # 408374</a></p><p id="a427" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">linux —从远程SSH会话获取本地剪贴板上的项目—堆栈溢出—<a class="ae kf" href="https://stackoverflow.com/questions/1152362/getting-items-on-the-local-clipboard-from-a-remote-ssh-session" rel="noopener ugc nofollow" target="_blank">https://Stack Overflow . com/questions/1152362/Getting-Items-on-the-Local-Clipboard-from-a-Remote-SSH-Session</a></p><p id="076d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">面向管理员的systemd，部分XI，inetd服务—<a class="ae kf" href="http://0pointer.de/blog/projects/inetd.html" rel="noopener ugc nofollow" target="_blank">http://0pointer.de/blog/projects/inetd.html</a></p><p id="606f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一个类似inetd的套接字激活服务的例子。# systemd # inetd # systemd . socket—<a class="ae kf" href="https://gist.github.com/drmalex07/28de61c95b8ba7e5017c" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/drmalex07/28de61c95b8ba7e5017c</a></p><p id="ff2c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Systemd socket文件stdin重定向/系统管理/ Arch Linux论坛—【https://bbs.archlinux.org/viewtopic.php?id=207834 T2】</p><p id="fdbd" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">samoshkin/tmux-config: tmux配置，为您的Tmux增压，打造舒适凉爽的终端环境—【https://github.com/samoshkin/tmux-config T4】</p><figure class="lv lw lx ly fq ml"><div class="bz el l di"><div class="mm mn l"/></div></figure></div></div>    
</body>
</html>