<html>
<head>
<title>Scaling Redux for real-life applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现实生活应用的缩放冗余</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/scaling-redux-for-real-life-applications-be18c731a54d?source=collection_archive---------5-----------------------#2017-05-30">https://medium.com/hackernoon/scaling-redux-for-real-life-applications-be18c731a54d?source=collection_archive---------5-----------------------#2017-05-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/fe5aa20a3c2c45dfae0a580b2b2c6231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZBdwUYlyJo1HD8TqE9X41A.jpeg"/></div></div></figure><p id="8b20" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">React  + <a class="ae ka" href="https://hackernoon.com/tagged/redux" rel="noopener ugc nofollow" target="_blank"> Redux </a> stack已经成为构建现代web应用程序的一个非常流行的选择。关于它们有足够多的<a class="ae ka" href="https://teropa.info/blog/2015/09/10/full-stack-redux-tutorial.html" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">好教程</strong> </a>，但我还没找到一个解释ToDo-app完成后该做什么的。</p><p id="b0f9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这篇文章中，我将解释我是如何在水平方向(相邻的特性)和垂直方向(复杂的特性)上扩展我的项目的。</p><h1 id="051b" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">关于命名</h1><p id="ddc8" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在我们深入研究代码示例之前，让我们就一些命名约定达成一致。对我来说，给事物命名总是很难，而且感觉固执己见，所以请对此有所保留。</p><p id="b02e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我们谈论React时，<a class="le lf gr" href="https://medium.com/u/a3a8af6addc1?source=post_page-----be18c731a54d--------------------------------" rel="noopener" target="_blank"> Dan Abramov </a>已经写了一篇很好的文章解释了<a class="ae ka" rel="noopener" href="/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.sxxr1fdf7"> <strong class="je hv">表示和容器组件</strong> </a>之间的区别。</p><p id="4fc1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用Redux，我尝试用几种不同的方式组织我的动作创建器和还原器，现在我最终使用了<a class="le lf gr" href="https://medium.com/u/a9d3e1c4ef5f?source=post_page-----be18c731a54d--------------------------------" rel="noopener" target="_blank"> Erik Rasmussen </a>的提议，将Redux应用程序拆分成<a class="ae ka" href="https://github.com/erikras/ducks-modular-redux" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">还原器包(又名ducks) </strong> </a>。我喜欢这个想法，但不喜欢这个名字，所以我将谈论<strong class="je hv">概念</strong>而不是鸭子(就此而言，还不如说是<strong class="je hv">服务</strong>)。他们的目的是创建尽可能内聚和可重用的代码模块来构建我们的应用程序。</p><h1 id="e233" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">基础知识</h1><p id="c8eb" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">举例来说，假设我们正在实现一个显示某种用户列表的应用程序。让我们从一个简单的概念开始，它从API获取用户，并将它们存储到Redux store中。</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="6046" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，容器组件使用这个概念来呈现获取的数据。</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="352d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这有点工作，但我不喜欢我的商店的内部结构泄漏到容器中的想法(我在看着你，<code class="eh lm ln lo lp b">mapToState</code> function)。例如，如果我想重命名商店中的<code class="eh lm ln lo lp b">loading</code>为<code class="eh lm ln lo lp b">isLoading</code>，我必须使用这个概念对每个容器进行修改。因为我们正在讨论为更复杂的应用程序进行扩展，所以这是不可能的。</p><h1 id="5665" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">简介:选择器</h1><p id="9cf9" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">解决上述问题的一个简单方法是使用<strong class="je hv">选择器</strong>实现一个API来访问concept的存储。就此而言，它们可以被称为getters，但是我喜欢使用<a class="ae ka" href="https://github.com/reactjs/reselect" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> Reselect </strong> </a>库，因为它提供了记忆化的结果和选择器组合，所以命名有点儿固定。</p><p id="ee87" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以，让我们在概念中加入一些选择器。</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="e38f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">并且还更新容器:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="a33b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我们的容器不需要知道存储的内部表示，我们也有了更多可测试和可重用的API来访问应用程序状态的一部分。</p><p id="1698" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">根据我的经验，当大多数连接的容器只依赖于单个概念时，像这样构造代码对于更简单的CRUD类型的应用程序来说效果很好。</p><p id="d5c2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我们开始添加更复杂的功能时，这种方法的局限性就开始显现出来，这些功能通常意味着数据聚合和/或将多个操作编排到应用程序逻辑中。</p><h1 id="15a2" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">发育期痛</h1><p id="32c8" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们的最终用户对我们的应用程序很满意，但现在他们想要更多。他们要求在用户列表中查看每个用户的提醒数量和某种用户活动分数。</p><p id="9d09" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们使用的API不提供现成的信息，所以我们必须发出多个请求来获得我们需要的所有信息。</p><p id="390c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以重构<code class="eh lm ln lo lp b">fetchUsers()</code>来发出其他请求，但是这将加载用户、警报和活动评分紧密耦合在一起。如果我们只想获取用户信息(或者将它与其他信息聚合在一起)，我们必须向action creator和reducer添加更多的参数和/或条件。</p><p id="7c67" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们不断给我们的概念添加越来越多的逻辑，我们最终会得到一大团意大利面条。而且既然我们要<a class="ae ka" href="https://en.wikipedia.org/wiki/Don't_repeat_yourself" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">干</strong> </a>和<a class="ae ka" href="https://en.wikipedia.org/wiki/KISS_principle" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">亲</strong> </a>，这太不行了。</p><p id="2143" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个症状可能是React组件中<code class="eh lm ln lo lp b">componentWillReceiveProps()</code>函数数量的增加，你试图从当前和下一个道具中推断实际发生了什么。</p><p id="0733" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们也可以在容器组件中实现这个逻辑。一种方法是将连接容器实现为<a class="ae ka" rel="noopener" href="/@franleplant/react-higher-order-components-in-depth-cf9032ee6c3e">高阶组件</a>，它只包装表示组件，而不自己呈现任何东西。这已经很好了，但我要说它仍然有一些缺点；我们可以让单元测试变得简单一点，但是我们仍然需要一个好的地方来存储特定于视图的数据(例如，搜索词等等)。</p><h1 id="8bd6" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">简介:容器概念</h1><p id="bdb5" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">最近我开始将我的概念组织成两个不同的类别:<strong class="je hv">基本概念</strong>和<strong class="je hv">容器概念</strong>。</p><p id="d219" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">前者很像我们已经写过的那个。它们是我们应用程序的基本构件，这意味着它们…</p><ul class=""><li id="c6ff" class="lq lr hu je b jf jg jj jk jn ls jr lt jv lu jz lv lw lx ly dt translated"><strong class="je hv">包含大部分应用状态，</strong></li><li id="379c" class="lq lr hu je b jf lz jj ma jn mb jr mc jv md jz lv lw lx ly dt translated"><strong class="je hv">提供一个内聚的通用API，用于访问和更新他们的状态部分，</strong></li><li id="fcc6" class="lq lr hu je b jf lz jj ma jn mb jr mc jv md jz lv lw lx ly dt translated"><strong class="je hv">包含最少量的应用程序逻辑，不依赖于其他概念</strong></li><li id="958d" class="lq lr hu je b jf lz jj ma jn mb jr mc jv md jz lv lw lx ly dt translated"><strong class="je hv">理想情况下不被任何容器使用</strong></li></ul><p id="ed41" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们的例子中，我们可能有单独的<code class="eh lm ln lo lp b">users</code>、<code class="eh lm ln lo lp b">alerts</code>和<code class="eh lm ln lo lp b">activityScores</code>概念。这听起来可能有点过度工程化，在这一点上确实如此，但请记住，我们将在未来为这些概念添加越来越多的新功能。</p><p id="dd20" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一方面，容器概念几乎是相反的。他们…</p><ul class=""><li id="782d" class="lq lr hu je b jf jg jj jk jn ls jr lt jv lu jz lv lw lx ly dt translated"><strong class="je hv">状态中包含最少数据或没有数据，</strong></li><li id="4856" class="lq lr hu je b jf lz jj ma jn mb jr mc jv md jz lv lw lx ly dt translated"><strong class="je hv">提供一个为单个容器定制的非常具体的API，</strong></li><li id="802d" class="lq lr hu je b jf lz jj ma jn mb jr mc jv md jz lv lw lx ly dt translated"><strong class="je hv">通过组合基本概念的功能来实现大部分应用逻辑</strong></li><li id="cc3d" class="lq lr hu je b jf lz jj ma jn mb jr mc jv md jz lv lw lx ly dt translated"><strong class="je hv">理想情况下仅由一个容器使用</strong></li></ul><p id="2fd4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，让我们看看这些容器的概念是什么样的，并创建一个容器来处理获取和聚合用户、警报和活动分数数据。</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="527d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为我们的用户列表特定概念没有任何自己的状态，所以我们不需要它的缩减器。如果我们想要添加支持，比方说，通过搜索项过滤，搜索项可以被添加到这个概念的存储中，因为它可以被视为一个视图/容器特定的关注点。</p><p id="1900" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不过，动作创建器和选择器是更有趣的部分。</p><p id="8940" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh lm ln lo lp b">fetchUsers()</code>动作创建器现在通过利用其他概念提供的动作创建器来封装向不同端点发出多个请求的逻辑。它不需要知道如何或在哪里准确地检索数据的细节。它唯一关心的是确保需要的信息在需要的时候被获取。</p><p id="9497" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有时候，我只是从其他概念中重新导出动作创建者，而不添加任何包装。比起依赖容器中的多个概念，我更喜欢这种方法。</p><p id="924f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh lm ln lo lp b">getUsers()</code>使用Reselect中的<code class="eh lm ln lo lp b">createSelector()</code>函数组合并重新格式化数据，使其更适合容器。例如，我们正在计算过去7天用户活动得分的最小值、最大值和平均值。注意，我们还将键值数据转换为按用户名排序的列表，这样更容易按组件呈现。</p><p id="da06" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为Reselect为我们提供了结果的记忆，所以我们也不必太担心性能影响。</p><p id="9e56" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">到目前为止，我们已经设法使基本概念保持简单、独立和易于测试。应用程序逻辑没有泄漏到React组件中，这意味着单元测试也很容易。另外，它与容器的一对一关系意味着，如果我们修改容器概念，我们不必担心在其他地方破坏某些东西。同样值得注意的是，容器使用的API仍然和我们开始时一样。</p><h1 id="930a" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">结论</h1><p id="b00f" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">对于像我这样一直使用MVVM模式的人来说，这应该不是什么新鲜事。<strong class="je hv">基本概念是模型，容器概念是视图——模型和容器是视图。</strong></p><p id="6cb9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在现实生活中，这种方法也有一些限制。在某些情况下，我们已经注意到这种两层的概念方法是不够的，但是我们已经通过添加依赖于它们下面的概念的更精炼的基本概念解决了这个问题。只要确保在你的概念依赖树中有一个清晰的层次结构。</p><p id="3c62" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通用API和特定于容器的API之间也没有明确的界限。我们将我们的概念保存在同一个目录中，但是通过将它们保存在不同的目录中来明确区分它们也是有意义的，这有助于您的思考过程。我建议选择最适合你的解决方案。</p><p id="a260" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我目前的工作项目是类似仪表板的应用程序(超过60kLOC ),具有大量的数据聚合和数据提炼，以及复杂的应用程序逻辑。以这种方式构建我们的代码使我们能够轻松地进行纵向和横向伸缩。对我们来说，这意味着更少的回归，意味着更快乐的客户，最终意味着更快乐的编码员。</p><p id="28d1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我很想听听你对以这种方式构建代码的想法？你在你的项目中使用了什么样的解决方案，它们对你有什么作用？</p><div class="lg lh li lj fq ab cb"><figure class="me iv mf mg mh mi mj paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="me iv mf mg mh mi mj paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="me iv mf mg mh mi mj paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mk ml mm"><p id="f922" class="jc jd mn je b jf jg jh ji jj jk jl jm mo jo jp jq mp js jt ju mq jw jx jy jz hn dt translated"><a class="ae ka" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ka" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ka" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae ka" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd mn je b jf jg jh ji jj jk jl jm mo jo jp jq mp js jt ju mq jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ka" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ka" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lg lh li lj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mr"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="ms ll l"/></div></figure></div></div>    
</body>
</html>