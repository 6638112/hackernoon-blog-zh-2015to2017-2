<html>
<head>
<title>The Secret behind the Single Responsibility Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单一责任原则背后的秘密</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-secret-behind-the-single-responsibility-principle-e2f3692bae25?source=collection_archive---------5-----------------------#2017-11-30">https://medium.com/hackernoon/the-secret-behind-the-single-responsibility-principle-e2f3692bae25?source=collection_archive---------5-----------------------#2017-11-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="8f6c" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">对编程历史的简短回顾，有助于理解它的基本概念</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/09abe68c4f340e73d73b52128c0b21e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fu4xjD86nSZ0yJ0fWHxsog.jpeg"/></div></div></figure><p id="da76" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这是第一篇关于<a class="ae kr" href="https://hackernoon.com/solid-principles-530b2cc2badf" rel="noopener ugc nofollow" target="_blank">坚实的</a>原则以及它们共有的价值观和原则的文章。</p><h2 id="4708" class="ks kt hu bd ku kv kw kx ky kz la lb lc ke ld le lf ki lg lh li km lj lk ll lm dt translated">1972年，大卫·帕纳斯</h2><p id="189e" class="pw-post-body-paragraph jv jw hu jx b jy ln iv ka kb lo iy kd ke lp kg kh ki lq kk kl km lr ko kp kq hn dt translated">早在1972年，<a class="ae kr" href="https://en.wikipedia.org/wiki/David_Parnas" rel="noopener ugc nofollow" target="_blank"> David Parnas </a>，一个封装和<a class="ae kr" rel="noopener" href="/@wrong.about/how-to-decompose-a-system-into-modules-796bd941f036">模块化编程</a>概念背后的人，写了他著名的论文<a class="ae kr" href="http://www.cs.umd.edu/class/spring2003/cmsc838p/Design/criteria.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="ls">“关于将系统分解成模块的标准”</em> </a>。在那里，他详细阐述了在决定哪些代码应该放在一起，哪些应该分开时使用的标准。</p><p id="7199" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv"> <em class="ls">帕纳斯的论文到底有什么革命性？它基本上是关于什么的？嗯，是关于两件相关的事情。</em></strong></p><p id="375f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">首先，它是关于选择正确的概念来操作。在领域层面上，这些是你的<a class="ae kr" rel="noopener" href="/@wrong.about/on-good-domain-decomposition-385ee8ce5a3">问题空间</a>的概念。这些概念在很大程度上相互独立。当你谈论购买一件物品时，你不会考虑它是如何储存的。这些概念的实现也应该相互独立。<br/>在基础设施层面，这些是您做出的主要技术决策。所有使用数据库的代码不应该分散在整个项目中。绝对是单模块。</p><p id="c8a7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">第二，是封装。当适当分解的领域概念被建模时，它们不应该沉迷于将它们的实现细节散布在整个代码库中。更像是前一点的后果。</p><p id="9617" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这个原则适用于所有层次，而不仅仅是模块层次。它也是关于类和服务的。</p><p id="81b4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv"> <em class="ls">利润</em> </strong> <br/>首先，如果你需要做一些改变，用这种方法更有可能将它限制在一个明确定义和可理解的范围内。你不需要修复一半的项目类。如果你改变了一个商品的购买方式，你就不必修改负责存储它的代码。如果您更改了数据库，就不必修复每个使用数据库功能的地方。</p><p id="8581" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">第二，可理解性。每段代码都有明确的目的。</p><h2 id="6984" class="ks kt hu bd ku kv kw kx ky kz la lb lc ke ld le lf ki lg lh li km lj lk ll lm dt translated">1979年，约登和康斯坦丁</h2><p id="5d40" class="pw-post-body-paragraph jv jw hu jx b jy ln iv ka kb lo iy kd ke lp kg kh ki lq kk kl km lr ko kp kq hn dt translated">后来在1979年，Yordon和Constantine在他们的书<a class="ae kr" href="https://www.amazon.com/Structured-Design-Fundamentals-Discipline-Computer/dp/0138544719" rel="noopener ugc nofollow" target="_blank"> <em class="ls">“结构化设计:计算机程序和系统设计的基础”</em> </a>中创造了<a class="ae kr" href="https://en.wikipedia.org/wiki/Cohesion_(computer_science)" rel="noopener ugc nofollow" target="_blank">内聚</a>这个术语。它就像</p><blockquote class="lt lu lv"><p id="94a7" class="jv jw ls jx b jy jz iv ka kb kc iy kd lw kf kg kh lx kj kk kl ly kn ko kp kq hn dt translated">一个<a class="ae kr" href="https://en.wikipedia.org/wiki/Module_(programming)" rel="noopener ugc nofollow" target="_blank">模块</a>内的元素属于一起的程度</p></blockquote><p id="10c8" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">维基百科对此有所阐述:</p><blockquote class="lt lu lv"><p id="61d4" class="jv jw ls jx b jy jz iv ka kb kc iy kd lw kf kg kh lx kj kk kl ly kn ko kp kq hn dt translated">在某种意义上，它是一个类的方法和数据与该类所服务的某种统一目的或概念之间的关系强度的度量。在另一种意义上，它是类的方法和数据本身之间关系强度的度量。</p></blockquote><p id="f9b9" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这就引出了第一点:这样的目的应该只有一个。第二点更微妙。这是关于类名与其职责的一致性:这两者的抽象层次应该匹配。下面是我在<a class="ae kr" href="https://softwareengineering.stackexchange.com/questions/359741/counterpart-to-single-responsibility-principle-minimizing-number-of-places-to-t/360262#360262" rel="noopener ugc nofollow" target="_blank">软件工程q &amp; a站点</a>上给出的一个相关问题的例子，说明了第二点的违反:</p><pre class="jk jl jm jn fq lz ma mb mc aw md dt"><span id="2d48" class="ks kt hu ma b fv me mf l mg mh">class Car<br/>{<br/>    public function __construct()<br/>    {<br/>    }<br/><br/>    public function drive()<br/>    {<br/>        //<br/>    }<br/><br/>    public function giveFuelToEngine()<br/>    {<br/><br/>    }<br/>}</span></pre><p id="48df" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><code class="eh mi mj mk ma b">Car</code>的责任，它的主要目的——驱动——与方法<code class="eh mi mj mk ma b">giveFuelToEngine.</code>的抽象层次不相关，因此有不同的改变原因。</p><h2 id="0b1d" class="ks kt hu bd ku kv kw kx ky kz la lb lc ke ld le lf ki lg lh li km lj lk ll lm dt translated">2003年，罗伯特马丁</h2><p id="ed24" class="pw-post-body-paragraph jv jw hu jx b jy ln iv ka kb lo iy kd ke lp kg kh ki lq kk kl km lr ko kp kq hn dt translated">2003年，Robert Martin在他的书<a class="ae kr" href="https://www.amazon.com/Software-Development-Principles-Patterns-Practices/dp/0135974445" rel="noopener ugc nofollow" target="_blank"><em class="ls">【敏捷软件开发、原则、模式和实践】</em></a>中陈述了<a class="ae kr" href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="noopener ugc nofollow" target="_blank">单一责任原则</a>:</p><blockquote class="lt lu lv"><p id="3e1f" class="jv jw ls jx b jy jz iv ka kb kc iy kd lw kf kg kh lx kj kk kl ly kn ko kp kq hn dt translated">一个类应该只有一个改变的理由。</p></blockquote><p id="22f1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">维基百科上说，马丁把这个原则建立在内聚性的基础上，灵感来自于<a class="ae kr" href="https://www.amazon.com/Structured-Analysis-System-Specification-DeMarco/dp/0138543801" rel="noopener ugc nofollow" target="_blank"> <em class="ls">结构化分析和</em> </a>系统规范一书。我对此表示怀疑。汤姆·狄马克采取了以数据为中心的方法，其中数据流是主要关注点。所以这里的内聚性只是一种实现<a class="ae kr" href="https://en.wikipedia.org/wiki/Structured_analysis#Single_abstraction_mechanism" rel="noopener ugc nofollow" target="_blank">功能分解</a>的手段，尽管如此，这还是很好的。</p><h2 id="789e" class="ks kt hu bd ku kv kw kx ky kz la lb lc ke ld le lf ki lg lh li km lj lk ll lm dt translated">2004年，埃里克·埃文斯</h2><p id="2572" class="pw-post-body-paragraph jv jw hu jx b jy ln iv ka kb lo iy kd ke lp kg kh ki lq kk kl km lr ko kp kq hn dt translated">Eric Evans在他的书<a class="ae kr" href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215" rel="noopener ugc nofollow" target="_blank"> " <em class="ls">领域驱动设计:解决软件核心的复杂性</em> " </a>中，介绍了一个<a class="ae kr" href="https://martinfowler.com/bliki/DDD_Aggregate.html" rel="noopener ugc nofollow" target="_blank">集合</a>的概念。它是一组可以被视为一个单元的对象。它有一个突出的特点:聚合只能通过一个<a class="ae kr" href="http://www.informit.com/articles/article.aspx?p=2020371&amp;seqNum=4" rel="noopener ugc nofollow" target="_blank">标识符</a>来相互引用。请记住，我们不能将任何存储库传递给它，很容易得出结论，一个聚合无法对其边界内的其他聚合进行操作。他们的交流只能通过事件。</p><p id="e8ba" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这种方法促进了真正内聚的领域概念的创建，除此之外还有明确的边界。这就是内聚性和封装性相遇的地方。</p><h2 id="60a7" class="ks kt hu bd ku kv kw kx ky kz la lb lc ke ld le lf ki lg lh li km lj lk ll lm dt translated">包装它</h2><p id="293c" class="pw-post-body-paragraph jv jw hu jx b jy ln iv ka kb lo iy kd ke lp kg kh ki lq kk kl km lr ko kp kq hn dt translated">因此，如果一个类是内聚的，如果有一个单一的更高层次的目的，如果它的职责符合它的名字，SRP就会自然地出现。SRP只是一个实际的结果，它本身并不是目标。<a class="ae kr" rel="noopener" href="/@wrong.about/on-good-domain-decomposition-385ee8ce5a3">标识</a>并赋予其<a class="ae kr" rel="noopener" href="/@wrong.about/how-to-avoid-anemic-domain-model-5e1c3e6fe4d0">正确职责</a>的内聚对象是。此外，整个<a class="ae kr" href="https://hackernoon.com/solid-principles-530b2cc2badf" rel="noopener ugc nofollow" target="_blank">实体</a>只是基本面向对象原则的简化实现结果。只是形式，不是本质。</p></div></div>    
</body>
</html>