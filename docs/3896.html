<html>
<head>
<title>All You Need to Know About @Decorators— a Case Study</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于@Decorators你需要知道的一切——一个案例研究</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/all-you-need-to-know-about-decorators-a-case-study-4a7e776b22a6?source=collection_archive---------2-----------------------#2017-04-30">https://medium.com/hackernoon/all-you-need-to-know-about-decorators-a-case-study-4a7e776b22a6?source=collection_archive---------2-----------------------#2017-04-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/7567f8716ee42f049ea227394723b094.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aWbkEgTvcQUt3I9D95aMow.jpeg"/></div></div></figure><p id="a0d3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="ka">本</em>条</strong> <strong class="je hv"> <em class="ka">原本出现在</em></strong><a class="ae kb" href="https://dormoshe.io/articles/all-you-need-to-know-about-decorators-a-case-study-6" rel="noopener ugc nofollow" target="_blank"><strong class="je hv"><em class="ka">dormoshe . io</em></strong></a></p><p id="80c3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">装饰器是ECMAScript中我最喜欢的特性之一。易用性和易于构建使它们如此受欢迎。它们是干净的。它们很简单。他们很酷。他们会留在这里。现在你可以使用它们，你不想忽视它们。大部分开发人员使用装饰者，但他们不知道装饰者是什么，也不知道如何构建装饰者。</p><p id="d270" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我第一次真正见到装修工是在<a class="ae kb" href="https://hackernoon.com/top-8-resources-to-explore-angular-4-ff2c1b42020a" rel="noopener ugc nofollow" target="_blank"> Angular 2落地</a>的时候，2016年9月——你还记得吗？😍。他们看着我，我看着他们，这是一见钟情。</p><p id="69aa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在本文中，我们将了解它们是什么，如何构建它们，以及为什么我们不需要害怕它们。我们将从我以前的文章中看到如何构建<a class="ae kb" href="https://hackernoon.com/rich-typescript-logger-decorator-for-easy-coding-fc2ff73684c6" rel="noopener ugc nofollow" target="_blank">rich logger decorator。</a></p></div><div class="ab cl kc kd hc ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hn ho hp hq hr"><h1 id="3f4b" class="kj kk hu bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">等等，什么是室内设计师？</h1><p id="461a" class="pw-post-body-paragraph jc jd hu je b jf lh jh ji jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz hn dt translated">装饰器只是一个函数。</p><blockquote class="lm"><p id="2c84" class="ln lo hu bd lp lq lr ls lt lu lv jz ek translated">装饰器使得在设计时注释和修改类和属性成为可能。</p></blockquote><p id="4aca" class="pw-post-body-paragraph jc jd hu je b jf lw jh ji jj lx jl jm jn ly jp jq jr lz jt ju jv ma jx jy jz hn dt translated">装饰器是一种特殊的声明，可以附加到类声明、方法、属性或参数上。Decorators使用@expression形式，其中expression必须计算出一个函数，该函数将在运行时使用被修饰声明的信息进行调用。</p></div><div class="ab cl kc kd hc ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hn ho hp hq hr"><h1 id="6ceb" class="kj kk hu bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">个案研究</h1><p id="79b5" class="pw-post-body-paragraph jc jd hu je b jf lh jh ji jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz hn dt translated">在这一节中，我们将看到如何构建rich-logger-decorator项目的某些部分。</p><h2 id="ed0b" class="mb kk hu bd kl mc md me kp mf mg mh kt jn mi mj kx jr mk ml lb jv mm mn lf mo dt translated">伐木装饰工</h2><p id="76cf" class="pw-post-body-paragraph jc jd hu je b jf lh jh ji jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz hn dt translated">@ <strong class="je hv">记录器</strong>装饰器是一个方法装饰器。在功能开始之前和功能结束之后，将打印日志消息。这个装饰器可以获得定义流行为的选项。</p><figure class="mp mq mr ms fq iv"><div class="bz el l di"><div class="mt mu l"/></div><figcaption class="mv mw fg fe ff mx my bd b be z ek">Full logger decorator code</figcaption></figure><p id="f100" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于options参数，这个装饰器需要返回一个函数(所以这是一个装饰器工厂)。一个<strong class="je hv">方法</strong>装饰器有一个类似于<code class="eh mz na nb nc b">function(target, methodName, descriptor)</code>的签名。</p><p id="978c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它需要三个参数:</p><ul class=""><li id="8384" class="nd ne hu je b jf jg jj jk jn nf jr ng jv nh jz ni nj nk nl dt translated"><strong class="je hv">目标</strong> —被修饰的原方法。</li><li id="0203" class="nd ne hu je b jf nm jj nn jn no jr np jv nq jz ni nj nk nl dt translated"><strong class="je hv">方法名</strong> —被修饰的方法的名称。</li><li id="796a" class="nd ne hu je b jf nm jj nn jn no jr np jv nq jz ni nj nk nl dt translated"><strong class="je hv">描述符</strong> —给定属性的属性描述符，如果它存在于对象上，否则未定义。属性描述符通过调用<em class="ka">object . getownpropertydescriptor()</em>函数获得。</li></ul><p id="96c5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">函数的第一部分试图获取描述符，对于一些边缘情况(对于<strong class="je hv">类记录器</strong>装饰器):</p><figure class="mp mq mr ms fq iv"><div class="bz el l di"><div class="mt mu l"/></div><figcaption class="mv mw fg fe ff mx my bd b be z ek">Logger decorator code — part I</figcaption></figure><p id="648d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第二部分是通过访问描述符的值来获取原始方法:</p><figure class="mp mq mr ms fq iv"><div class="bz el l di"><div class="mt mu l"/></div><figcaption class="mv mw fg fe ff mx my bd b be z ek">Logger decorator code — part II</figcaption></figure><p id="9a11" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第三部分是猴子补丁的原始方法:</p><figure class="mp mq mr ms fq iv"><div class="bz el l di"><div class="mt mu l"/></div><figcaption class="mv mw fg fe ff mx my bd b be z ek">Logger decorator code — part III</figcaption></figure><p id="7340" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如您所见，该机制在原始方法调用之前记录了一条消息，在调用之后记录了一条消息。用源参数调用的函数和新方法返回的结果。</p><p id="53f6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在最后一部分，我们将该方法标记为monkey patched method(稍后将在<strong class="je hv"> ClassLogger </strong> decorator中使用),并返回描述符以支持为此方法使用更多的decorator。</p><figure class="mp mq mr ms fq iv"><div class="bz el l di"><div class="mt mu l"/></div><figcaption class="mv mw fg fe ff mx my bd b be z ek">Logger decorator code — part IV</figcaption></figure><h1 id="a2be" class="kj kk hu bd kl km nr ko kp kq ns ks kt ku nt kw kx ky nu la lb lc nv le lf lg dt translated">@ClassLogger</h1><p id="54ed" class="pw-post-body-paragraph jc jd hu je b jf lh jh ji jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz hn dt translated"><strong class="je hv"> @ClassLogger </strong>装饰器是一个方法装饰器。当您将decorator放在类定义的顶部时，类中的所有方法都会被自动记录(由<strong class="je hv"> @DisableLogger </strong>修饰的方法除外)。</p><figure class="mp mq mr ms fq iv"><div class="bz el l di"><div class="mt mu l"/></div><figcaption class="mv mw fg fe ff mx my bd b be z ek">Full class logger decorator code</figcaption></figure><p id="6553" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作为Logger decorator，这也是一个decorator工厂。一个<strong class="je hv">类</strong>装饰器有一个类似于<code class="eh mz na nb nc b">function(target)</code>的签名。目标是对类构造函数的引用。</p><p id="466f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">装饰器需要装饰所请求的方法——所有被装饰的类方法，除非将设置数组选项<em class="ka">logged method names</em>。设置后，只有数组中的方法会被修饰。</p><figure class="mp mq mr ms fq iv"><div class="bz el l di"><div class="mt mu l"/></div><figcaption class="mv mw fg fe ff mx my bd b be z ek">Full class logger decorator code — part I</figcaption></figure><p id="8b71" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这段代码获取类的属性(包括类方法)。然后使用<em class="ka">logged method names</em>数组选项对它们进行过滤。</p><figure class="mp mq mr ms fq iv"><div class="bz el l di"><div class="mt mu l"/></div><figcaption class="mv mw fg fe ff mx my bd b be z ek">Full class logger decorator code — part II</figcaption></figure><p id="5b53" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，循环过滤的项目。如果该项不是一个函数或者它已经被日志记录机制修饰过(根据<em class="ka">_ _ loggermonkey patch completed</em>)，则该项被省略。</p><figure class="mp mq mr ms fq iv"><div class="bz el l di"><div class="mt mu l"/></div><figcaption class="mv mw fg fe ff mx my bd b be z ek">Full class logger decorator code — part III</figcaption></figure><p id="5eac" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们像在方法记录器装饰器中一样“猴子修补”这些方法。就是这样。</p><h1 id="5ef1" class="kj kk hu bd kl km nr ko kp kq ns ks kt ku nt kw kx ky nu la lb lc nv le lf lg dt translated">@DisableLogger</h1><p id="d463" class="pw-post-body-paragraph jc jd hu je b jf lh jh ji jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz hn dt translated"><strong class="je hv"> @DisableLogger </strong>装饰器也是一个方法装饰器。<strong class="je hv"> ClassLogger </strong> decorator将跳过这个方法不被记录。</p><figure class="mp mq mr ms fq iv"><div class="bz el l di"><div class="mt mu l"/></div><figcaption class="mv mw fg fe ff mx my bd b be z ek">Disable logger decorator code</figcaption></figure><p id="e8f2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了这个目的，我们只需要改变布尔值就可以了。这是一个不改变原始方法的简单装饰器的例子。</p><h1 id="7f9d" class="kj kk hu bd kl km nr ko kp kq ns ks kt ku nt kw kx ky nu la lb lc nv le lf lg dt translated">参考</h1><ul class=""><li id="c69f" class="nd ne hu je b jf lh jj li jn nw jr nx jv ny jz ni nj nk nl dt translated"><a class="ae kb" href="https://hackernoon.com/rich-typescript-logger-decorator-for-easy-coding-fc2ff73684c6" rel="noopener ugc nofollow" target="_blank">丰富的打字记录器装饰器，方便编码</a>文章</li><li id="931a" class="nd ne hu je b jf nm jj nn jn no jr np jv nq jz ni nj nk nl dt translated">rich-logger-decoratorGitHub存储库</li><li id="2285" class="nd ne hu je b jf nm jj nn jn no jr np jv nq jz ni nj nk nl dt translated">国家预防机制中的富人伐木工装饰工</li></ul></div><div class="ab cl kc kd hc ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hn ho hp hq hr"><h1 id="f994" class="kj kk hu bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">结论</h1><p id="aaac" class="pw-post-body-paragraph jc jd hu je b jf lh jh ji jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz hn dt translated">装修工很厉害。它们提高了可读性和可重用性。你可以用Typescript，Traceur或者Bable把它们编译成ES5。现在你知道如何构建它们了，所以去编写你的自定义装饰器吧，别忘了分享…</p><figure class="mp mq mr ms fq iv fe ff paragraph-image"><div class="fe ff nz"><img src="../Images/522b2e4ace3cfcecd43bba30fcf0a317.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*cA1Y2VmIvRnUJUvjUPNZ2A.png"/></div></figure><p id="c3e1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="ka">您可以关注我的</em></strong><a class="ae kb" href="https://www.dormoshe.io" rel="noopener ugc nofollow" target="_blank"><strong class="je hv"><em class="ka">dormo she . io</em></strong></a><strong class="je hv"><em class="ka">或</em></strong><a class="ae kb" href="https://twitter.com/DorMoshe" rel="noopener ugc nofollow" target="_blank"><strong class="je hv"><em class="ka">Twitter</em></strong></a><strong class="je hv"><em class="ka">了解更多关于Angular、JavaScript和web开发的内容。</em> </strong></p></div></div>    
</body>
</html>