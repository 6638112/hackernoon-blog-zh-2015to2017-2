<html>
<head>
<title>Sudoku Solver with OpenCV 3.2 and Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用OpenCV 3.2和Go的数独解算器</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/sudoku-solver-w-golang-opencv-3-2-3972ed3baae2?source=collection_archive---------7-----------------------#2017-07-18">https://medium.com/hackernoon/sudoku-solver-w-golang-opencv-3-2-3972ed3baae2?source=collection_archive---------7-----------------------#2017-07-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="654f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">几周前，我渴望开始学习<a class="ae jp" href="https://hackernoon.com/tagged/learning" rel="noopener ugc nofollow" target="_blank">Go…和OpenCV。我决定通过开发一个由OpenCV和</a><a class="ae jp" href="https://hackernoon.com/tagged/go" rel="noopener ugc nofollow" target="_blank"> Go </a>支持的数独解谜网络应用程序来解决这个问题，并启动一点机器学习。这个想法很简单:</p><ul class=""><li id="b23c" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">上传一张图片，用OpenCV“解析”谜题，例如找到网格和数字</li><li id="60ce" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">使用来自样本谜题的数字测试集来训练机器学习模型以识别数字</li><li id="9672" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">使用我在参与<a class="ae jp" href="https://www.udacity.com/ai" rel="noopener ugc nofollow" target="_blank"> Udacity AI nanodegree </a>项目时学到的一些约束传播算法来解决这个难题</li></ul><p id="a5ec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一路上，钻研OpenCV让我开始接触C++，花了相当多的时间理解CGO(Go和C/C++之间的桥梁)和一些Docker知识的新知识。这里有一个快速演示它是如何结束的:</p><figure class="ke kf kg kh fq ki"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="6043" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请继续阅读，了解它是如何形成的…</p><h1 id="9561" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">用OpenCV“解析”数独图片</h1><p id="91b3" class="pw-post-body-paragraph ir is hu it b iu lj iw ix iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo hn dt translated">OpenCV当前的3.x版本公开了一个C++ API，所以我为Visual Studio代码安装了<a class="ae jp" href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools" rel="noopener ugc nofollow" target="_blank"> C/C++工具插件</a>，并开始阅读OpenCV示例代码。我希望能够检测到“数字拼图”图片，如左边的图片，以及可能有一些倾斜和光线不足的拼图图片，如右边的例子。</p><figure class="ke kf kg kh fq ki fe ff paragraph-image"><div class="fe ff lo"><img src="../Images/c102da76ffbb17c84bc631611dd000fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*91lW1vQUaTuQldIk-yd8dg.png"/></div><figcaption class="lr ls fg fe ff lt lu bd b be z ek">Original Sudoku Puzzle Images</figcaption></figure><p id="2a34" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我完成了以下图像处理步骤:</p><p id="5646" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">转换为灰度并调整大小</strong> —后续步骤不依赖于颜色，假设大小一致使得一些后续处理更加简单</p><p id="0266" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">提取并“解开”网格</strong>—下一个任务是检测图像中的数独网格。仅支持“数字拼图”图像会容易得多，但报纸图像需要更多的工作。它从一些<a class="ae jp" href="http://docs.opencv.org/3.2.0/d1/d79/group__photo__denoise.html#ga4c6b0031f56ea3f98f768881279ffe93" rel="noopener ugc nofollow" target="_blank">去噪</a>和<a class="ae jp" href="http://docs.opencv.org/3.2.0/d7/d1b/group__imgproc__misc.html#ga72b913f352e4a1b1b397736707afcde3" rel="noopener ugc nofollow" target="_blank">自适应阈值</a>开始。</p><figure class="ke kf kg kh fq ki fe ff paragraph-image"><div class="fe ff lo"><img src="../Images/921a0ec9b262fd442e9fad1da6c3b349.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*BWsvjNEG2YCkgKSJ_TA66Q.png"/></div><figcaption class="lr ls fg fe ff lt lu bd b be z ek">Thresholding and Denoising Applied</figcaption></figure><p id="0bd2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些步骤为<a class="ae jp" href="https://en.wikipedia.org/wiki/Canny_edge_detector" rel="noopener ugc nofollow" target="_blank"> Canny边缘检测算法</a> ( <a class="ae jp" href="http://docs.opencv.org/3.2.0/dd/d1a/group__imgproc__feature.html#ga04723e007ed888ddf11d9ba04e2232de" rel="noopener ugc nofollow" target="_blank"> OpenCV docs </a>)做准备，该算法进一步将图像中的信息减少到仅仅是物体边缘，就像我们正在寻找的网格。</p><figure class="ke kf kg kh fq ki fe ff paragraph-image"><div class="fe ff lo"><img src="../Images/e277e95c307078d1fb84f089c7319407.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*XCKDQq996fQeTREhkT9kDg.png"/></div><figcaption class="lr ls fg fe ff lt lu bd b be z ek">Canny Edge Detection Algorithm</figcaption></figure><p id="8d6c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们可以使用OpenCV的<code class="eh lv lw lx ly b"><a class="ae jp" href="http://docs.opencv.org/3.2.0/d3/dc0/group__imgproc__shape.html#ga17ed9f5d79ae97bd4c7cf18403e1689a" rel="noopener ugc nofollow" target="_blank">findContours</a></code>算法来检测图像中的形状；<code class="eh lv lw lx ly b"><a class="ae jp" href="http://docs.opencv.org/3.2.0/d3/dc0/group__imgproc__shape.html#ga819779b9857cc2f8601e6526a3a5bc71" rel="noopener ugc nofollow" target="_blank">RETR_EXTERNAL</a></code>模式用于将搜索限制在极端的<strong class="it hv">外部</strong>轮廓，跳过任何位于<em class="lz">内部的</em>其他轮廓。</p><figure class="ke kf kg kh fq ki fe ff paragraph-image"><div class="fe ff lo"><img src="../Images/03fff1350b954f80fae7ad15981ab4a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*YWNI_pkHx2IXdmQ7JNV1sw.png"/></div><figcaption class="lr ls fg fe ff lt lu bd b be z ek">Contour Detection (there is a single contour in the image on the left if you look close)</figcaption></figure><p id="fb16" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有了一系列轮廓，这些轮廓只是“跟踪”形状的X/Y坐标列表，下一个任务是在<code class="eh lv lw lx ly b"><a class="ae jp" href="http://docs.opencv.org/3.2.0/d3/dc0/group__imgproc__shape.html#ga2c759ed9f497d4a618048a2f56dc97f1" rel="noopener ugc nofollow" target="_blank">contourArea</a></code>的帮助下找到最大的轮廓，然后通过在轮廓覆盖的区域的每个象限内找到轮廓的最外点来识别哪个X/Y坐标是网格的角。</p><figure class="ke kf kg kh fq ki fe ff paragraph-image"><div class="fe ff lo"><img src="../Images/e3a07e6027fa25edc4e4451753263443.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*yfxMlT1G7fGlTid4mySAvA.png"/></div><figcaption class="lr ls fg fe ff lt lu bd b be z ek">Detecting Perspective Transform Points for the Largest Contour</figcaption></figure><p id="874b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后用OpenCV的<code class="eh lv lw lx ly b"><a class="ae jp" href="http://docs.opencv.org/3.2.0/da/d54/group__imgproc__transform.html#ga8c1ae0e3589a9d77fffc962c49b22043" rel="noopener ugc nofollow" target="_blank">getPerspectiveTransform</a></code>和<code class="eh lv lw lx ly b"><a class="ae jp" href="http://docs.opencv.org/3.2.0/da/d54/group__imgproc__transform.html#gaf73673a7e8e18ec6963e3774e6a94b87" rel="noopener ugc nofollow" target="_blank">warpPerspective</a></code>使用这些角来“解扭曲”图像的网格部分。虽然“数字拼图”没有太大的变化，但现在我们的报纸照片和“数字拼图”图像在后续处理中处于更加平等的地位。</p><figure class="ke kf kg kh fq ki fe ff paragraph-image"><div class="fe ff lo"><img src="../Images/aa3387f35895dd7df279d5105a1b2e92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*0b8WwSjo9OGJ1DFl0X5lQg.png"/></div><figcaption class="lr ls fg fe ff lt lu bd b be z ek">Perspective Transform Applied to Detected Grid</figcaption></figure><p id="a67b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">消除网格线</strong> —在我们寻找图像的数字区域之前，去掉网格线是很有用的。一个<a class="ae jp" href="http://docs.opencv.org/3.2.0/d4/d86/group__imgproc__filter.html#gac342a1bb6eabf6f55c803b09268e36dc" rel="noopener ugc nofollow" target="_blank">结构化元素</a>(我使用了1px水平和垂直内核)被传递给<code class="eh lv lw lx ly b"><a class="ae jp" href="http://docs.opencv.org/3.2.0/d4/d86/group__imgproc__filter.html#gaeb1e0c1033e3f6b891a25d0511362aeb" rel="noopener ugc nofollow" target="_blank">erode</a></code>和<code class="eh lv lw lx ly b"><a class="ae jp" href="http://docs.opencv.org/3.2.0/d4/d86/group__imgproc__filter.html#ga4ff0f3318642c4f469d0e11f242f3b6c" rel="noopener ugc nofollow" target="_blank">dilate</a></code>，以便清理网格线。<code class="eh lv lw lx ly b"><a class="ae jp" href="http://docs.opencv.org/3.2.0/d3/dc0/group__imgproc__shape.html#ga17ed9f5d79ae97bd4c7cf18403e1689a" rel="noopener ugc nofollow" target="_blank">findContours</a></code>再次被使用，但是这次轮廓通过纵横比被过滤成接近水平线和垂直线的轮廓。</p><figure class="ke kf kg kh fq ki fe ff paragraph-image"><div class="fe ff lo"><img src="../Images/60cc645dbd98616352716cee6bbbba45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*0eMv7xjuhLmgzDwddUysSA.png"/></div><figcaption class="lr ls fg fe ff lt lu bd b be z ek">Grid lines detected in each image (pink is just the image border)</figcaption></figure><p id="d04b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有时报纸的线条仍然太“弯曲”或模糊，不能像这里的例子那样作为网格线(在这个实现中)传递。这些区域然后被稍微扩展，并且从图像中减去<strong class="it hv">得到下面的结果。</strong></p><figure class="ke kf kg kh fq ki fe ff paragraph-image"><div class="fe ff lo"><img src="../Images/0d348c704a6e849acd3c3c89b193209f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*EHcdTpbLCTfmM-WQN6b3aw.png"/></div><figcaption class="lr ls fg fe ff lt lu bd b be z ek">Removing Grid Lines and Denoising to Prepare for Digit Detection</figcaption></figure><p id="810b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">寻找数字</strong> —终于到了检测图像的数字区域的时候了。再次使用<code class="eh lv lw lx ly b"><a class="ae jp" href="http://docs.opencv.org/3.2.0/d3/dc0/group__imgproc__shape.html#ga17ed9f5d79ae97bd4c7cf18403e1689a" rel="noopener ugc nofollow" target="_blank">findContours</a></code>，之后是另一个长宽比过滤器，灵感来自我的朋友<a class="ae jp" href="https://hackernoon.com/building-a-gas-pump-scanner-with-opencv-python-ios-116fe6c9ae8b" rel="noopener ugc nofollow" target="_blank">凯文·卡兹米耶扎克的文章</a>。这个过滤器允许我们跳过右边报纸图像中一些水平伪影的轮廓。</p><figure class="ke kf kg kh fq ki fe ff paragraph-image"><div class="fe ff lo"><img src="../Images/699e500acdb48b95c39d0f14a1a7d0f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*axCOOFjflK5ZJhT_SOygWw.png"/></div><figcaption class="lr ls fg fe ff lt lu bd b be z ek">Detecting Digit Regions of the Image</figcaption></figure></div><div class="ab cl ma mb hc mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hn ho hp hq hr"><h1 id="27ae" class="kl km hu bd kn ko mh kq kr ks mi ku kv kw mj ky kz la mk lc ld le ml lg lh li dt translated">使用OpenCV进行机器学习</h1><p id="2bf5" class="pw-post-body-paragraph ir is hu it b iu lj iw ix iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo hn dt translated">找到图像中的数字区域后，下一步是识别每个数字图像中出现的数字。我仔细观察了几个样本图像，并将样本数独图像和它们包含的数字放在一起，形成了一个简单的csv数据文件，如下所示:</p><figure class="ke kf kg kh fq ki"><div class="bz el l di"><div class="mm kk l"/></div></figure><p id="d3f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，每个样本图像都经过前面描述的“解析”逻辑，以找到手指区域。每个数字区域的中心与图像上的9x9网格的最近中心点相匹配，然后根据。csv文件。然后将每个数字的大小调整到一致的大小，并组合成一个整体的“训练”图像，其中顶行包含所有的“1”图像，第二行包含所有的“2”图像，依此类推。这成为我们训练机器学习模型的原始数据。</p><figure class="ke kf kg kh fq ki fe ff paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="fe ff mn"><img src="../Images/31ff5bd640e9fbf3a9088d3760abc024.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_uh0SLbs8BECcI-hx4C-0Q.png"/></div></div><figcaption class="lr ls fg fe ff lt lu bd b be z ek">Digit regions extracted from several sample Sudoku puzzle images and combined together</figcaption></figure><p id="a426" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有大量的数字识别教程，但我发现萨提亚·马利克的《T2》有着特殊的价值，因为它的解释清晰而详细。我为这个项目采用了他的方法。为了快速总结，为每个数字图像计算梯度描述符的<a class="ae jp" href="http://docs.opencv.org/3.2.0/d5/d33/structcv_1_1HOGDescriptor.html#a723b95b709cfd3f95cf9e616de988fc8" rel="noopener ugc nofollow" target="_blank">直方图(参见</a><a class="ae jp" href="http://www.learnopencv.com/histogram-of-oriented-gradients/" rel="noopener ugc nofollow" target="_blank"> Satya对HOG描述符的精彩解释</a>)。这些描述符的80%连同数字标签(从我们的训练图像中的行推断出)然后作为我们的“观察”被馈送到<a class="ae jp" href="http://docs.opencv.org/3.2.0/d1/d2d/classcv_1_1ml_1_1SVM.html" rel="noopener ugc nofollow" target="_blank"> OpenCV的</a> <code class="eh lv lw lx ly b"><a class="ae jp" href="http://docs.opencv.org/3.2.0/d1/d2d/classcv_1_1ml_1_1SVM.html" rel="noopener ugc nofollow" target="_blank">SVM</a></code> <a class="ae jp" href="http://docs.opencv.org/3.2.0/d1/d2d/classcv_1_1ml_1_1SVM.html" rel="noopener ugc nofollow" target="_blank">类</a>中以训练模型。然后，使用经过训练的SVM模型来为剩余的20%的数字预测合适的数字。</p><p id="a427" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我构建了一个<a class="ae jp" href="https://github.com/jamesandersen/go-sudoku/blob/master/sudokuparser/cli/sudoku_parser_cli.cpp" rel="noopener ugc nofollow" target="_blank">小型C++ CLI工具</a>来调用训练过程，最终在我收集的<em class="lz">尽管有限的</em>样本谜题集上获得了97.73%的准确率。经过训练的SVM模型被保存并在以后再次加载，以用于解决新奇的谜题。</p></div><div class="ab cl ma mb hc mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hn ho hp hq hr"><h1 id="447c" class="kl km hu bd kn ko mh kq kr ks mi ku kv kw mj ky kz la mk lc ld le ml lg lh li dt translated">OpenCV 3.x C++通过CGO与Go集成</h1><p id="16a7" class="pw-post-body-paragraph ir is hu it b iu lj iw ix iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo hn dt translated">到目前为止，所有的工作都是用C++完成的(如果你看一下代码<a class="ae jp" href="https://github.com/jamesandersen/go-sudoku/tree/master/sudokuparser" rel="noopener ugc nofollow" target="_blank"><em class="lz"/></a><em class="lz">【温柔点，我在写这篇文章的时候还是个C++新手</em>)。从Go中调用这个结果比我预期的要复杂，<em class="lz">对于我在Go中的第一个作品来说不是一个容易的场景。</em></p><p id="6117" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使Go能够使用一个特殊的注释调用C代码，该注释被称为“C”包的特定导入(该导入应该单独在一行上)的前导，如下所示。请注意，序言支持特定于平台的值，以支持在不同平台上交叉编译安全代码库，例如darwin(我的本地设置)和linux(为运行此应用程序而创建的docker容器)。</p><figure class="ke kf kg kh fq ki"><div class="bz el l di"><div class="mm kk l"/></div></figure><p id="a0ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">引用<a class="ae jp" href="https://golang.org/cmd/cgo/" rel="noopener ugc nofollow" target="_blank">文档</a>(重点是我的):</p><blockquote class="ms mt mu"><p id="d9c4" class="ir is lz it b iu iv iw ix iy iz ja jb mv jd je jf mw jh ji jj mx jl jm jn jo hn dt translated">当Go工具发现一个或多个Go文件使用了特殊的导入“C”时，它会在目录中寻找其他非Go文件<strong class="it hv">，并将它们编译成Go包的一部分。任何。c，。s，或者。s文件将用C编译器编译。任何。抄送，<strong class="it hv">。cpp </strong>，或。cxx文件<strong class="it hv">将用C++编译器</strong>编译。</strong></p></blockquote><p id="6718" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这看起来很简单，但是由于我上面强调的几点，我浪费了时间:</p><ul class=""><li id="7d1f" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated"><strong class="it hv"> CGO让我们称之为C代码(不是C++代码)</strong>——那么提到用C++编译器编译的<code class="eh lv lw lx ly b">.cpp</code>文件是怎么回事？嗯，作为一个C/C++的新手，我花了一段时间才明白，<code class="eh lv lw lx ly b">cgo</code>将从正在导入的C代码中编译被<a class="ae jp" href="https://isocpp.org/wiki/faq/mixing-c-and-cpp#call-cpp" rel="noopener ugc nofollow" target="_blank">引用</a> <em class="lz">的C++。然而，您不能直接导入C++代码，这意味着像<code class="eh lv lw lx ly b"><a class="ae jp" href="http://www.cplusplus.com/reference/string/string/" rel="noopener ugc nofollow" target="_blank">string</a></code>和<code class="eh lv lw lx ly b"><a class="ae jp" href="http://www.cplusplus.com/reference/vector/vector/?kw=vector" rel="noopener ugc nofollow" target="_blank">vector</a></code>这样的C++类型必须转换成它们的C等价类型。</em></li><li id="5cdc" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated"><strong class="it hv"> CGO只编译同一目录中的文件</strong>——我最初的C++数独谜题解析代码被组织到src/和include/目录中，我的<code class="eh lv lw lx ly b">cgo</code>序言试图包含子目录中的C头文件。这不起作用。</li></ul><p id="b060" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我以下面的目录结构结束，让<code class="eh lv lw lx ly b">cgo</code>正确地编译并链接我的C++ OpenCV代码到导入的“C”包中</p><figure class="ke kf kg kh fq ki fe ff paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="fe ff my"><img src="../Images/85d5593043c44c642dbc9cbc8b8ad3ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Cu6duRW5z0ApUIqXPbL-g.png"/></div></div></figure><p id="ff93" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还有一些更值得注意的问题:</p><ul class=""><li id="6cf6" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated"><strong class="it hv">用CGO </strong> — <a class="ae jp" href="https://github.com/derekparker/delve" rel="noopener ugc nofollow" target="_blank"> Delve </a>调试，围棋调试器牛逼。然而，一旦我开始使用<code class="eh lv lw lx ly b">cgo</code>，我就不能让它工作了。我不知道它是否真的被支持，或者我只是有问题。我发现单独启动和调试C++代码更容易</li><li id="3d7d" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated"><a class="ae jp" href="https://golang.org/cmd/cgo/#hdr-Passing_pointers" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">注意你的指针！</strong> </a> —早些时候，我从C++传回一个字符串，它代表“解析”的数独谜题，并断断续续地得到奇怪的垃圾结果。最后，我提前分配了C内存，并将指针传递给C代码，允许它从分配的内存中读取/写入。Go的<code class="eh lv lw lx ly b">defer</code>和<code class="eh lv lw lx ly b">C.free()</code>确保我们完成后释放它。下面是一个例子。</li></ul><figure class="ke kf kg kh fq ki"><div class="bz el l di"><div class="mm kk l"/></div></figure><p id="508a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个调用的结果只是一个81个字符的字符串，标识从图像中检测到的数字:</p><figure class="ke kf kg kh fq ki"><div class="bz el l di"><div class="mm kk l"/></div></figure></div><div class="ab cl ma mb hc mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hn ho hp hq hr"><h1 id="3d21" class="kl km hu bd kn ko mh kq kr ks mi ku kv kw mj ky kz la mk lc ld le ml lg lh li dt translated">解决数独难题</h1><p id="3c93" class="pw-post-body-paragraph ir is hu it b iu lj iw ix iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo hn dt translated">本文的主要重点是研究如何解决给定数字的数独难题。如果这就是你想要的，看看彼得·诺维格的方法和解释。然而，我要指出的是，主要的技术是约束传播，其中我们本质上使用问题域上的约束来限制要搜索的选项的数量。如果我们<strong class="it hv"> <em class="lz">天真地</em> </strong>将数独棋盘想象成一个9x9的网格，其中每个单元格可以取1-9之间的值，那么我们就有了9⁸可能的棋盘状态(超过30亿)。当然，我们知道有许多约束限制了搜索空间:</p><ul class=""><li id="60c6" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">已知的起始数字</li><li id="8b09" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">每行必须包含所有数字1-9</li><li id="927e" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">每列必须包含所有数字1-9</li><li id="4d27" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">等等。</li></ul><p id="2718" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过应用这些约束，我们可以大大减少可能的搜索空间。一旦应用了一个约束来缩小搜索空间，我们可以重新评估其他约束，以迭代地缩小拼图中每个单元格的有效值。当约束不能消除所有可能性时，结合搜索算法，大多数谜题可以在几秒钟或更短的时间内解决。查看<code class="eh lv lw lx ly b"><a class="ae jp" href="https://github.com/jamesandersen/go-sudoku/blob/master/sudokuboard.go" rel="noopener ugc nofollow" target="_blank">sudokuboard.go</a></code>了解本项目中使用的Go实现。</p><p id="0f46" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了Sudoku求解代码之外，项目的Go部分还包含一些不起眼的代码，用于为项目UI所在的web内容的静态目录提供服务，并接受一个多部分文件上传，Sudoku谜题图像将被发送到该文件中。它还使用<a class="ae jp" href="https://github.com/nytimes/gziphandler" rel="noopener ugc nofollow" target="_blank"> NY Times Gzip处理器</a>来压缩响应。</p></div><div class="ab cl ma mb hc mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hn ho hp hq hr"><h1 id="3d93" class="kl km hu bd kn ko mh kq kr ks mi ku kv kw mj ky kz la mk lc ld le ml lg lh li dt translated">Docker部署</h1><p id="a98e" class="pw-post-body-paragraph ir is hu it b iu lj iw ix iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo hn dt translated">好了，我们已经有了OpenCV代码来“解析”一张拼图图片(作为字节数组传递)，我们已经将其与一个简单的Go web应用程序集成，该应用程序接收一张拼图图片，将其交给OpenCV进行解析，然后解决缺失的数字。太好了！但是在哪里部署呢？</p><p id="034b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对OpenCV的依赖意味着我们没有一个独立的二进制文件，并且排除了类似谷歌云平台上的<a class="ae jp" href="https://cloud.google.com/appengine/docs/go/" rel="noopener ugc nofollow" target="_blank"> Go标准环境</a>的东西。集装箱化的解决方案是下一个合乎逻辑的选择</p><p id="1dcb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://hub.docker.com/_/golang/" rel="noopener ugc nofollow" target="_blank">围棋图像</a>？✔</p><p id="9cbe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">OpenCV图片？很多人！</p><p id="dd31" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Go <strong class="it hv">和</strong> OpenCV 3.x？☹</p><p id="e310" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">…所以我拼凑了我对DockerHub 的第一个贡献，这是一个基于Alpine Linux的映像，带有Go 1.8.3和OpenCV 3库，幸运的是这些库在Alpine Linux<em class="lz">Edge<a class="ae jp" href="https://pkgs.alpinelinux.org/packages?name=opencv&amp;branch=&amp;repo=&amp;arch=&amp;maintainer=" rel="noopener ugc nofollow" target="_blank">中</a>可用。</em>这里有一些困难，例如让<a class="ae jp" href="https://github.com/jamesandersen/alpine-golang-opencv3/blob/master/Dockerfile#L11-L17" rel="noopener ugc nofollow" target="_blank">符号链接设置</a>到版本特定的opencv库，但最终这个容器，加上之前看到的平台特定的<code class="eh lv lw lx ly b">cgo</code>序言，让我成功地在docker容器内构建了应用。</p><p id="1ba2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在阅读了Kelsey Hightower关于Go应用程序的微型Docker容器的文章后，我意识到，虽然我可以从这个图像运行我的应用程序，但它会被夸大，因为所有的Go工具仍然存在。对我来说幸运的是，自从凯尔西写了他的文章，Docker团队在Docker 17.05中添加了<a class="ae jp" href="https://docs.docker.com/engine/userguide/eng-image/multistage-build/" rel="noopener ugc nofollow" target="_blank">多阶段构建</a>，现在，在<strong class="it hv">单个</strong>Docker文件中，我可以构建应用程序，<strong class="it hv">用SDK工具丢弃构建映像，等等。将前一阶段的Go二进制文件复制到一个干净的轻量级映像中！伟大的工作码头团队！</strong></p><figure class="ke kf kg kh fq ki"><div class="bz el l di"><div class="mm kk l"/></div></figure><p id="6994" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">感谢<a class="ae jp" href="https://hyper.sh" rel="noopener ugc nofollow" target="_blank"> Hyper.sh </a>的人们为docker容器的简单托管提供了一个免费层。</p><h1 id="f5c3" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">结论</h1><p id="e603" class="pw-post-body-paragraph ir is hu it b iu lj iw ix iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo hn dt translated">如果你坚持了这么久…谢谢！我希望有对你有价值的东西。求解器绝不是万无一失的；它对一些图像仍然有问题，要么无法解析它们，要么解析不正确，导致无法解决它们(因为它可能解析为无效的谜题)。目标当然是增加一些新技术，从这个角度来看，这个项目是有价值的。</p><p id="b801" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">解算器在<a class="ae jp" href="http://gosudoku.jander.me/" rel="noopener ugc nofollow" target="_blank">http://gosudoku.jander.me/</a>上线(截至本文撰写之时),如果你感兴趣的话<a class="ae jp" href="https://github.com/jamesandersen/go-sudoku" rel="noopener ugc nofollow" target="_blank">源代码在GitHub </a>上。如果你觉得有用或有任何后续问题，请给我留言。谢谢！</p><figure class="ke kf kg kh fq ki"><div class="bz el l di"><div class="mz kk l"/></div></figure></div></div>    
</body>
</html>