<html>
<head>
<title>Why We Replaced Our Kafka Connector with a Kafka Consumer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我们用Kafka消费者替换了Kafka连接器</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/why-we-replaced-our-kafka-connector-with-a-kafka-consumer-972e56bebb23?source=collection_archive---------1-----------------------#2017-12-16">https://medium.com/hackernoon/why-we-replaced-our-kafka-connector-with-a-kafka-consumer-972e56bebb23?source=collection_archive---------1-----------------------#2017-12-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div class="fe ff hs"><img src="../Images/b1cd86fb905672f09c13fd58870003d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*rCSZxf-gglx1u0-vni07rQ.jpeg"/></div><figcaption class="hz ia fg fe ff ib ic bd b be z ek">Confused?</figcaption></figure><div class=""/><p id="bba8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">几个月前，我写了一篇关于<a class="ae ka" href="https://hackernoon.com/writing-your-own-sink-connector-for-your-kafka-stack-fa7a7bc201ea" rel="noopener ugc nofollow" target="_blank">在我们开始使用自己的水槽连接器</a>后，创建自己的水槽连接器的文章。令人惊讶的是，上周我们用<a class="ae ka" href="https://kafka.apache.org/documentation/#consumerapi" rel="noopener ugc nofollow" target="_blank">卡夫卡消费者</a>代替了它。我将回顾我们的经验，并尝试在这篇短文中写出这两种技术的优缺点。</p><h2 id="d728" class="kb kc if bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">但是为什么呢？</h2><p id="d5ad" class="pw-post-body-paragraph jc jd if je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">说实话，我们对我们定制的弹性水槽连接器非常满意；它已经处理了我们的流量(每秒高达7000条产品数据(<em class="lb">每条约1000行)</em>，在4个docker容器上)，并且没有发生任何性能故障。然而，<strong class="je ig">对于定制的Kafka连接器来说，调试和测试是非常困难的！</strong></p><figure class="ld le lf lg fq hw fe ff paragraph-image"><div class="fe ff lc"><img src="../Images/a635e1e7376948073e5302d50fe1cf99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*M-niOn2-KTD9EBTH_KmEOA.jpeg"/></div><figcaption class="hz ia fg fe ff ib ic bd b be z ek">Yes, unfortunately.</figcaption></figure><p id="da91" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你不能轻易地编写你的集成测试，因为它是你的Kafka堆栈中的某种插件。你需要模仿内部的Kafka类，创建<a class="ae ka" href="https://docs.microsoft.com/en-us/azure/architecture/patterns/anti-corruption-layer" rel="noopener ugc nofollow" target="_blank">反腐败层，</a>在单元测试上花费大量时间，而且……你仍然不满意，因为没有端到端或集成测试。</p><p id="562c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设您在产品中有一个bug，但是由于上述原因，您的测试没有完成，所以您无法解决它。好，您想在本地调试连接器。不幸的是，对于卡夫卡连接器来说，这是一个相当奢侈的词。如果需要在某个地方放一个断点，需要做很多“<em class="lb"> wtf…真的吗？”</em>这里所说的<a class="ae ka" href="https://stackoverflow.com/a/45719652" rel="noopener ugc nofollow" target="_blank">人员</a>。创造你的环境？你可以把你的连接器连接到Landoop的fast-data-dev栈，但是同样，这不是调试，你只是克隆了问题，并试图在一个更可控的基础设施中解决它。</p><p id="6138" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">出于这个原因，我们用一个普通的Kafka消费者替换了我们的定制水槽连接器，现在维护它就像是小菜一碟。(至少目前如此……)</p><p id="a350" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们对性能感到疑惑，但测试结果给我们留下了深刻的印象。对于我们的性能问题，它们几乎是相同的。也许它可以显示一个相当大的流量的变化，但这个时候你可以正确的缩放，这是卡夫卡最好的优势。</p><h2 id="aad5" class="kb kc if bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">向卡夫卡消费者转移</h2><p id="6f58" class="pw-post-body-paragraph jc jd if je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">调试和测试Kafka消费者相当容易，就像一个常规的API一样。如果你决定转向消费者，你可以用许多编程语言来写。我们最初考虑用Python或者C#来写，但最终选择了Java。因为我们可以在短时间内复制Kafka Connect项目中的类。(您必须为您的定制Kafka连接器使用Java)</p><p id="aa7b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我想在这里强调主要的一点:提交补偿。</p><p id="c70b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在自定义Kafka连接器中，如果put方法中没有异常，框架会自动提交消息:</p><figure class="ld le lf lg fq hw"><div class="bz el l di"><div class="lh li l"/></div><figcaption class="hz ia fg fe ff ib ic bd b be z ek">It is in your …SinkTask class.</figcaption></figure><p id="f3de" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Kafka Consumers中，您可以再次使用自动提交，但是这一次您应该考虑到框架是在您收到主题消息之后提交的。我想说的是，如果你的代码在传输数据前抛出异常，你就丢失了消息。</p><p id="a9f7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">相反，您可以手动提交，这很容易模仿Connect的行为，只需在完成工作后提交即可:)</p><figure class="ld le lf lg fq hw"><div class="bz el l di"><div class="lh li l"/></div><figcaption class="hz ia fg fe ff ib ic bd b be z ek">Committing manually at the end of the process</figcaption></figure><h2 id="2573" class="kb kc if bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">那么，你的意思是不推荐卡夫卡连接器吗？</h2><p id="71c1" class="pw-post-body-paragraph jc jd if je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">不要！如果您需要简单地将您的主题数据传输到另一个系统，或者相反，并且有一个社区/汇合支持的Kafka连接器，请使用它！-稍微配置一下，嘣，就好了。但是，如果您因为某些原因必须编写自己的Kafka连接器，请考虑测试和调试是很难的。</p><p id="652c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">感谢阅读，</p><p id="30db" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有时候我会发一条有用的信息:<a class="ae ka" href="https://twitter.com/_skynyrd" rel="noopener ugc nofollow" target="_blank"> @_skynyrd </a></p></div></div>    
</body>
</html>