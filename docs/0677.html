<html>
<head>
<title>Spring Boot: Persisting data with REST + JPA</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot:用REST + JPA保持数据</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/spring-boot-persisting-data-with-rest-jpa-33a063e8b147?source=collection_archive---------1-----------------------#2016-03-10">https://medium.com/hackernoon/spring-boot-persisting-data-with-rest-jpa-33a063e8b147?source=collection_archive---------1-----------------------#2016-03-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/ec20ab8cd0e47fb7a5f9f025abe149e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*62oYyAhPA8wTdsDQYl1moA.png"/></div></div></figure><div class=""/><blockquote class="jc jd je"><p id="42df" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">本文是《Spring Boot:从零开始的REST+TDD》的续篇，所以，如果你还没有这样做，请首先回顾一下。</p></blockquote><p id="e797" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">在本文中，我们将添加<a class="ae ke" href="http://projects.spring.io/spring-data-jpa/" rel="noopener ugc nofollow" target="_blank"> Spring Data JPA </a>来帮助我们实现基于JPA的存储库。我们的主要目标将是通过RESTful端点持久化/检索我们的用户<a class="ae ke" href="https://hackernoon.com/tagged/data" rel="noopener ugc nofollow" target="_blank">数据</a>，并且，就像在前一篇文章中一样，我们将尝试跟上<a class="ae ke" href="https://hackernoon.com/tagged/tdd" rel="noopener ugc nofollow" target="_blank"> TDD </a>实践。</p><p id="e5ea" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">因此，让我们从创建一个简单的测试开始:</p><figure class="ki kj kk kl fq hw"><div class="bz el l di"><div class="km kn l"/></div><figcaption class="ko kp fg fe ff kq kr bd b be z ek">Add this file to $SOURCE_HOME/src/test/java/br/com/brunokrebs/</figcaption></figure><p id="e89e" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">这个类包含一个单独的测试，它使用<a class="ae ke" href="https://github.com/jayway/rest-assured" rel="noopener ugc nofollow" target="_blank">REST freeze API</a>将序列化为JSON的用户发布到我们将要创建的端点。这个代码，就像现在一样，甚至不会编译，因为我们还没有User类。现在让我们创建它，以便能够运行我们的测试。</p><figure class="ki kj kk kl fq hw"><div class="bz el l di"><div class="km kn l"/></div><figcaption class="ko kp fg fe ff kq kr bd b be z ek">Add this file to $SOURCE_HOME/src/main/java/br/com/brunokrebs/model/</figcaption></figure><p id="5cdb" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">目前，一个简单的<a class="ae ke" href="https://en.wikipedia.org/wiki/Plain_Old_Java_Object" rel="noopener ugc nofollow" target="_blank"> POJO </a>就足够了，因为我们将只使用它来序列化/反序列化到/到我们将要创建的端点。有了这个新类，我们现在就可以执行测试了。发出“mvn清除验证”将为我们执行此任务。</p><p id="e291" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">Ooops，我们的测试中有一个危险信号。看来我们的终结点没有响应，状态代码等于HttpStatus。好的，正如我们测试的<a class="ae ke" href="https://gist.github.com/brunokrebs/93b1e492ff585d064591#file-userrestit-java-L23" rel="noopener ugc nofollow" target="_blank">23号线所料。嗯，有道理，因为我们还没有创建自己的端点。让我们现在就开始:</a></p><figure class="ki kj kk kl fq hw"><div class="bz el l di"><div class="km kn l"/></div><figcaption class="ko kp fg fe ff kq kr bd b be z ek">Add this file to $SOURCE_HOME/src/main/java/br/com/brunokrebs/rest/</figcaption></figure><p id="5079" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">有了这个小类，我们现在将能够再次运行我们的测试，并(希望)看到它通过。让我们再次发出“mvn清除验证”。很好，它现在通过了我们的第一次测试。</p><p id="c889" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">但等等，我们的REST服务只是返回我们传递给它的用户。让我们改进测试，看看我们的端点是否以某种方式神奇地持久化了我们的用户。</p><figure class="ki kj kk kl fq hw"><div class="bz el l di"><div class="km kn l"/></div><figcaption class="ko kp fg fe ff kq kr bd b be z ek">Take a look at @FixMethodOrder annotation. The NAME_ASCENDING configuration makes JUnit run our tests in alphabetical order.</figcaption></figure><p id="ccde" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">发出“mvn clean verify”现在不能证明我们的用户是否被持久化，它只能证明我们没有一个端点来应答“/user/”路径上的GET请求。因此，为了获得一些速度并使事情更简单，让我们先将Spring Data JPA添加到我们的项目中，然后创建一个方法来响应GET请求。</p><blockquote class="jc jd je"><p id="9c8c" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">TDD通常希望我们先创建一个小的测试，用最简单的实现来完成这个测试，改进测试来添加新的条件，重构我们的实现，然后一直这样下去。尽管一些TDD实践非常好，但是这个微周期并不是非常有效率，这就是为什么我们在本文中跳过了一些周期。</p></blockquote><h2 id="1ae8" class="ks kt if bd ku kv kw kx ky kz la lb lc kf ld le lf kg lg lh li kh lj lk ll lm dt translated">添加Spring数据JPA和H2数据库</h2><p id="33ac" class="pw-post-body-paragraph jf jg if ji b jj ln jl jm jn lo jp jq kf lp jt ju kg lq jx jy kh lr kb kc kd hn dt translated">添加<a class="ae ke" href="http://projects.spring.io/spring-data-jpa/" rel="noopener ugc nofollow" target="_blank"> Spring数据JPA </a>作为依赖项，并通过我们的RESTful端点持久化数据，只需要四个简单的步骤。首先，我们需要向pom.xml添加两个依赖项:</p><figure class="ki kj kk kl fq hw"><div class="bz el l di"><div class="km kn l"/></div></figure><p id="4c0f" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">第一个将JPA 2和Hibernate添加到我们的项目中。然后，我们必须注释我们的用户类，以获得持久化，并向其实例添加一个id。</p><figure class="ki kj kk kl fq hw"><div class="bz el l di"><div class="km kn l"/></div><figcaption class="ko kp fg fe ff kq kr bd b be z ek">User class now annotated to be persisted and with an id field that is auto generated.</figcaption></figure><p id="da1c" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">在那之后，我们的第三步，也是证明Spring如何令人难以置信地使事情变得简单的一步，是创建一个存储库接口，Spring数据将使用它来自动创建存储库实现。这个实现将拥有我们现在需要的一切(比如保存、按id查找和查找所有方法)。</p><figure class="ki kj kk kl fq hw"><div class="bz el l di"><div class="km kn l"/></div><figcaption class="ko kp fg fe ff kq kr bd b be z ek">Create this interface at $SOURCE_FOLDER/src/main/java/br/com/brunokrebs/repository</figcaption></figure><p id="1ce1" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">作为第四步…等等，等等？用户存储库是否正确？只是一个扩展另一个的接口？是啊！！所以面对现实吧，让我们继续前进。在我们的下一篇文章中，我们将看到更多关于它的精彩内容。正如我所说的，第四步也是最后一步是重构我们的UserRest类，使用之前创建的UserRepository来保存和列出用户。</p><figure class="ki kj kk kl fq hw"><div class="bz el l di"><div class="km kn l"/></div><figcaption class="ko kp fg fe ff kq kr bd b be z ek">$SOURCE_HOME/src/main/java/br/com/brunokrebs/rest/UserRest.java</figcaption></figure><p id="9991" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">现在，所有这四个步骤完成后，让我们发出' mvn干净验证'。太好了！两个测试都通过了，我们的用户得到了持久化。这太神奇了。嗯，没什么好惊讶的，H2是一个嵌入式数据库，有了这种配置，每次执行时所有的表都会被重新创建。所以没有什么是真正持久的。当我们的应用程序启动并运行时，我们的用户会一直保留在数据库中。当它关闭时，我们的数据就会丢失。</p><p id="c158" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">我们将在下一篇文章中讨论这个问题。实际上，我们将用PostgreSQL替换H2数据库，这里使用它只是为了展示在我们的Spring Boot面向REST的应用程序中使用JPA/Hibernate是多么容易。</p><p id="6ffe" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">哦，只是一个附录，如果你想让我们的系统能够手动发出请求，只需发出以下命令' mvn spring-boot:run '。该系统还没有图形界面，但我们也将在这方面努力。这个接口也将基于我们的RESTful端点。</p><p id="ed39" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">那么，你觉得Spring Boot和我们正在建造的这个建筑怎么样？在我看来，这是基于web技术的企业应用程序所能拥有的最佳架构之一。我们在一个坚实的基础上构建我们的应用程序，Spring带有自动化测试，并且采用一种无状态的方法，就像HTTP被设计为工作一样。留下评论:)</p><blockquote class="jc jd je"><p id="b24a" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我叫布鲁诺·克雷布斯，你可以通过我的<a class="ae ke" href="https://twitter.com/brunoskrebs/" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、我的<a class="ae ke" href="https://www.linkedin.com/in/brunokrebs" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和我的<a class="ae ke" href="https://github.com/brunokrebs" rel="noopener ugc nofollow" target="_blank"> Github </a>账户找到我。此外，请随意在这里或我的任何文章中添加任何评论。</p></blockquote><div class="ki kj kk kl fq ab cb"><figure class="ls hw lt lu lv lw lx paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="ls hw lt lu lv lw lx paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="ls hw lt lu lv lw lx paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="jc jd je"><p id="f922" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><a class="ae ke" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ke" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ke" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ke" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ke" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ke" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ki kj kk kl fq hw fe ff paragraph-image"><a href="https://goo.gl/Ahtev1"><div class="fe ff ly"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></a></figure><figure class="ki kj kk kl fq hw"><div class="bz el l di"><div class="lz kn l"/></div></figure></div></div>    
</body>
</html>