<html>
<head>
<title>aSaying “No” to Fragments (and Activities): Creating View-driven applications with Flow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对片段(和活动)说“不”:用流创建视图驱动的应用程序</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/saying-no-to-fragments-and-activities-creating-view-driven-applications-with-flow-8f7d02315442?source=collection_archive---------2-----------------------#2016-11-03">https://medium.com/hackernoon/saying-no-to-fragments-and-activities-creating-view-driven-applications-with-flow-8f7d02315442?source=collection_archive---------2-----------------------#2016-11-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/7ea7bf9c25c3afe575280749ee5bf905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rm7bwbakSD2cJ4PjJSwjnw.png"/></div></div></figure><p id="d481" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">注:我已经弃用了Flowless(并且已经放弃使用Flow ),支持我从头开始写的东西:</strong> <a class="ae ka" href="https://github.com/Zhuinden/simple-stack" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> <em class="kb">简单堆栈</em> </strong> </a> <strong class="je hv">。</strong></p><p id="ee04" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">所以你应该记住，我不再使用它了，因为简单堆栈解决了我不喜欢的Flow设计的怪癖。</strong></p><p id="3156" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">事实上，这篇文章可能已经不值得一读了。</p><p id="d4c2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">改为看这个:<a class="ae ka" rel="noopener" href="/@Zhuinden/simplified-fragment-navigation-using-a-custom-backstack-552e06961257">https://medium . com/@ zhuin den/simplified-fragment-navigation-using-a-custom-back stack-552 e 06961257</a></p><p id="bc21" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt">— — — — — — — — — — — — — — — — — — — — — — — — —</p><p id="4680" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">事实上，我以前写过一篇关于流动的文章，但是相当平淡。是时候写一篇新的更好的文章了，更直截了当一点。我也写过关于使用Flow 0.12和Mortar 的<a class="ae ka" href="https://github.com/Zhuinden/MortarFlowSetup/wiki/Abandoning-the-Activity-Stack-using-Flow-0.12-and-Mortar" rel="noopener ugc nofollow" target="_blank">，但是那应该被认为是过时的——Flow 1.0-alpha的架构要好得多，也更可取(因为它管理状态持久性，而以前的版本没有)。</a></p><h1 id="11ce" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">基础知识</h1><p id="74f4" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">对于那些不知道有多少片段已经被讨厌了很长时间的人来说<a class="ae ka" rel="noopener" href="/square-corner-blog/advocating-against-android-fragments-81fd0b462c97#.lldcwxoyq">——嗯，没有人喜欢生命周期，没有人喜欢它们如何奇怪地与CoordinatorLayout一起工作，也没有人喜欢FragmentManager事务如何混乱，阅读</a><a class="ae ka" href="https://android.googlesource.com/platform/frameworks/support/+/refs/heads/master/v4/java/android/support/v4/app/FragmentManager.java#416" rel="noopener ugc nofollow" target="_blank">源代码并不能真正帮助</a>。</p><p id="fb15" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">考虑到这一点，<a class="ae ka" href="https://github.com/square/flow" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> Flow </strong> </a> <strong class="je hv"> </strong>被创建来接管FragmentManager想要做的事情——成为<strong class="je hv"> backstack </strong>(就像<code class="eh lf lg lh li b">addToBackStack(null)</code>给你的一样)，确保视图在配置改变和进程死亡时得到正确的恢复；但是<em class="kb">没有</em>就没有人真正理解<a class="ae ka" href="https://www.google.hu/webhp?sourceid=chrome-instant&amp;ion=1&amp;espv=2&amp;ie=UTF-8#q=fragment+not+attached+to+activity" rel="noopener ugc nofollow" target="_blank">的古怪bug</a>。</p><p id="3ffa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可能会问，为什么没有这种奇怪的虫子？因为从“<em class="kb">状态A </em>到“<em class="kb">状态B </em>的所有过渡都是由<strong class="je hv">你</strong>——流量的使用者——来处理的。</p><h1 id="6fd0" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">一些历史和新的东西</h1><p id="855d" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">Flow实际上非常古老，尽管由于缺乏文档和可怕的示例代码，它从未真正得到改编。甚至有关于它的文章<a class="ae ka" rel="noopener" href="/square-corner-blog/simpler-android-apps-with-flow-and-mortar-5beafcd83761#.s21vs642b">(嗯，方有点离开，挂在流量0.8) </a>。</p><p id="ca62" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了理解<em class="kb">流</em>是如何随时间变化的，让我们看一下那篇文章中关于<em class="kb">流0.8 </em>的例子，以及我们如何对最新的流做同样的事情。</p><h2 id="4efb" class="lj kd hu bd ke lk ll lm ki ln lo lp km jn lq lr kq jr ls lt ku jv lu lv ky lw dt translated">国家代表权</h2><p id="91b5" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">回到流程0.8，显示的每个视图都由一个<code class="eh lf lg lh li b">Object</code>描述，其中这个对象用<code class="eh lf lg lh li b">@Screen</code>注释。此屏幕包含当此对象设置为backstack时应显示的布局。</p><pre class="lx ly lz ma fq mb li mc md aw me dt"><span id="d957" class="lj kd hu li b fv mf mg l mh mi">@Screen<strong class="li hv">(</strong>layout <strong class="li hv">=</strong> R<strong class="li hv">.</strong>layout<strong class="li hv">.</strong>album_view<strong class="li hv">)</strong><br/><strong class="li hv">public class</strong> <strong class="li hv">AlbumScreen</strong> <strong class="li hv">{</strong><br/>  <strong class="li hv">private</strong> <strong class="li hv">final</strong> <strong class="li hv">int</strong> albumId<strong class="li hv">;</strong></span><span id="19f9" class="lj kd hu li b fv mj mg l mh mi">  <strong class="li hv">public</strong> <strong class="li hv">AlbumScreen(int</strong> albumId<strong class="li hv">)</strong> <strong class="li hv">{</strong> <strong class="li hv">this.</strong>albumId <strong class="li hv">=</strong> albumId<strong class="li hv">;</strong> <strong class="li hv">}<br/> <br/>  public int getAlbumId() {<br/>     return albumId;<br/>  }<br/>}</strong></span><span id="3672" class="lj kd hu li b fv mj mg l mh mi">@Screen<strong class="li hv">(</strong>layout <strong class="li hv">=</strong> R<strong class="li hv">.</strong>layout<strong class="li hv">.</strong>track_view<strong class="li hv">)</strong><br/><strong class="li hv">public class</strong> TrackScreen <strong class="li hv">implements</strong> HasParent<strong class="li hv">&lt;</strong>AlbumScreen<strong class="li hv">&gt;</strong> <strong class="li hv">{</strong><br/>  <strong class="li hv">private final</strong> <strong class="li hv">AlbumScreen</strong> albumScreen<strong class="li hv">;</strong><br/>  <strong class="li hv">private</strong> <strong class="li hv">final</strong> <strong class="li hv">int</strong> trackId<strong class="li hv">;</strong></span><span id="bf77" class="lj kd hu li b fv mj mg l mh mi"><strong class="li hv">  public</strong> <strong class="li hv">TrackScreen(AlbumScreen </strong>albumScreen<strong class="li hv">, int</strong> trackId<strong class="li hv">)</strong> <strong class="li hv">{</strong><br/>    <strong class="li hv">this.</strong>albumScreen<strong class="li hv"> =</strong> albumScreen<strong class="li hv">;</strong><br/>    <strong class="li hv">this.</strong>trackId <strong class="li hv">=</strong> trackId<strong class="li hv">;</strong><br/>  <strong class="li hv">}</strong></span><span id="3ec6" class="lj kd hu li b fv mj mg l mh mi">  @Override <strong class="li hv">public</strong> AlbumScreen getParent<strong class="li hv">()</strong> <strong class="li hv">{</strong><br/>    <strong class="li hv">return</strong> albumScreen<strong class="li hv">;</strong><br/>  <strong class="li hv">}</strong></span><span id="38ef" class="lj kd hu li b fv mj mg l mh mi">  <strong class="li hv">public </strong>AlbumScreen getAlbumScreen() {<br/>    <strong class="li hv">return </strong>albumScreen;<br/>  }</span><span id="92b2" class="lj kd hu li b fv mj mg l mh mi">  <strong class="li hv">public </strong>int getTrackId() {<br/>    <strong class="li hv">return </strong>trackId;<br/>  }<strong class="li hv"><br/>}</strong></span></pre><p id="d07a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个其实没什么变化，除了<code class="eh lf lg lh li b">@Screen</code>(和<code class="eh lf lg lh li b">HasParent</code>)不再被图书馆提供给你。你只是被告知使用任何物体，任何你想要的物体；只要它有<code class="eh lf lg lh li b">equals()</code>和<code class="eh lf lg lh li b">hashCode()</code>方法。</p><p id="ca94" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当然，最有意义的是键仍然告诉您想要构建什么样的布局。如果你把你的钥匙做成可打包的(或者提供一个<code class="eh lf lg lh li b">KeyParceler</code>可以把它们变成可打包的，但是这需要更多的努力)，这也是最简单的。</p><p id="2e61" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">事不宜迟，现在在Flow 1.0中，您可以这样做:</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="1d0d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果愿意，您还可以选择使用注释来提供视图的布局标识符，您只需要提供从中提取值的逻辑。</p><p id="9c18" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="kb">(注意:对于当前的Flow 1.0-alpha，如果我们想让Flow处理“托管服务”和引用计数，扩展</em> <code class="eh lf lg lh li b"><em class="kb">TreeKey</em></code> <em class="kb">而不是进行</em> <code class="eh lf lg lh li b"><em class="kb">HasParent</em></code> <em class="kb">注释可能也是一个好主意——尽管我个人不使用它，因为我对它有疑问。)</em></p><h2 id="f38e" class="lj kd hu bd ke lk ll lm ki ln lo lp km jn lq lr kq jr ls lt ku jv lu lv ky lw dt translated">导航处理</h2><p id="7668" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">回到Flow 0.8，你必须实现<code class="eh lf lg lh li b">Flow.Listener</code>接口，它给你新的对象的<code class="eh lf lg lh li b">Backstack</code>(用<code class="eh lf lg lh li b">@Screen</code>标注)，以及关于你是否后退、前进或替换的<code class="eh lf lg lh li b">Direction</code>。</p><pre class="lx ly lz ma fq mb li mc md aw me dt"><span id="3cf5" class="lj kd hu li b fv mf mg l mh mi">@Override <strong class="li hv">public</strong> <strong class="li hv">void</strong> <strong class="li hv">go(</strong>Backstack backstack<strong class="li hv">,</strong> Direction direction<strong class="li hv">)</strong> <strong class="li hv">{</strong><br/>  Object screen <strong class="li hv">=</strong> backstack<strong class="li hv">.</strong>current<strong class="li hv">().</strong>getScreen<strong class="li hv">();</strong><br/>  setContentView<strong class="li hv">(</strong>Screens<strong class="li hv">.</strong>createView<strong class="li hv">(this,</strong> screen<strong class="li hv">));</strong><br/><strong class="li hv">}</strong></span></pre><p id="b5c7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这有一点改变，因为<code class="eh lf lg lh li b">Screens</code>和<code class="eh lf lg lh li b">@Screen</code>不再存在，更重要的是，流不再是同步的——它是基于回调的。这是为了允许处理动画，并且只有当动画实际完成时，状态改变才会被“提交”。更重要的是，您还会收到<em class="kb">以前的</em>和<em class="kb">新的</em>堆栈对象。</p><p id="74ed" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Flow 1.0-alpha中，您需要用下面的签名实现<code class="eh lf lg lh li b">Dispatcher</code>接口(以前是<code class="eh lf lg lh li b">Flow.Dispatcher</code>):</p><pre class="lx ly lz ma fq mb li mc md aw me dt"><span id="4796" class="lj kd hu li b fv mf mg l mh mi">public interface Dispatcher {  <br/>  /** <br/>   * Called when the history is about to change.  <br/>   * Note that Flow does not consider the Traversal to be finished, <br/>   * and will not actually update the history, <br/>   * until the callback is triggered. <br/>   * Traversals cannot be canceled.</span><span id="8a97" class="lj kd hu li b fv mj mg l mh mi">   * @param callback - Must be called to indicate completion of the traversal.   <br/>   */  </span><span id="4022" class="lj kd hu li b fv mj mg l mh mi">    void dispatch(@NonNull Traversal traversal, <br/>                  @NonNull TraversalCallback callback);<br/>}</span></pre><p id="1013" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们想保持文章的简单，应该是这样的:</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="f84c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">至于中间的上下文魔术，<a class="ae ka" href="https://github.com/square/flow/blob/762864967765f0f3f7f9827609f5b97fdd963a76/flow/src/main/java/com/squareup/flow/Screens.java" rel="noopener ugc nofollow" target="_blank">那正是</a> <code class="eh lf lg lh li b"><a class="ae ka" href="https://github.com/square/flow/blob/762864967765f0f3f7f9827609f5b97fdd963a76/flow/src/main/java/com/squareup/flow/Screens.java" rel="noopener ugc nofollow" target="_blank">Screens</a></code> <a class="ae ka" href="https://github.com/square/flow/blob/762864967765f0f3f7f9827609f5b97fdd963a76/flow/src/main/java/com/squareup/flow/Screens.java" rel="noopener ugc nofollow" target="_blank">用来做</a>的。</p><p id="a8dd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt">— — — — — — — — — — — — — — — — — — — — — — — — — — — —</p><p id="196e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，值得注意的是，过去，<code class="eh lf lg lh li b">Flow</code>没有处理视图状态持久性。在这方面，你完全靠自己。现在，Flow提供了一个<code class="eh lf lg lh li b">State</code>类，您可以将视图的状态保存到这个类中，然后将视图的状态存储到Flow自己的<code class="eh lf lg lh li b">History</code>堆栈中。</p><p id="a80c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">考虑到这一点，我们应该创建一个视图组，包含我们当前显示的视图(我称之为<code class="eh lf lg lh li b">root</code>)，这样我们就可以轻松地直接访问视图，并获得/恢复它的状态。</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="f179" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">记住这一点，现在我们不仅有一个backstack，而且还有视图的状态持久性。旋转和导航离开我们的视图不会再移除我们的视图状态，Flow在内部处理大部分工作。整洁！:)</p><p id="fb32" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这也是处理两个视图之间动画的地方——例如，如果<code class="eh lf lg lh li b">previousView</code>存在，我们可以使用<code class="eh lf lg lh li b">TransitionManager.beginDelayedTransition()</code>。</p><h2 id="33c2" class="lj kd hu bd ke lk ll lm ki ln lo lp km jn lq lr kq jr ls lt ku jv lu lv ky lw dt translated">在应用程序状态之间切换</h2><p id="59f0" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">还记得这个吗？</p><pre class="lx ly lz ma fq mb li mc md aw me dt"><span id="ccfd" class="lj kd hu li b fv mf mg l mh mi">FragmentManager fragmentManager = getFragmentManager();<br/>FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();<br/>fragmentTransaction.replace(R.id.fragment_container, FeedFragment.newInstance());<br/>fragmentTransaction.addToBackStack(null);<br/>fragmentTransaction.commit();</span></pre><p id="d5bd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">回到流程0.8，它曾经是这样的:</p><pre class="lx ly lz ma fq mb li mc md aw me dt"><span id="fce5" class="lj kd hu li b fv mf mg l mh mi">flow<strong class="li hv">.</strong>goTo<strong class="li hv">(new</strong> <strong class="li hv">Track(</strong>albumScreen<strong class="li hv">,</strong> trackId<strong class="li hv">));</strong></span></pre><p id="e12a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在在流程1.0-alpha中，是这样的:</p><pre class="lx ly lz ma fq mb li mc md aw me dt"><span id="35c7" class="lj kd hu li b fv mf mg l mh mi">Flow.get(this).set(<strong class="li hv">new</strong> <strong class="li hv">Track(</strong>albumScreen<strong class="li hv">,</strong> trackId<strong class="li hv">));</strong></span></pre><p id="69b3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用<code class="eh lf lg lh li b">set</code>检查给定的键是否已经存在(使用<code class="eh lf lg lh li b">equals</code>，如果存在，那么它将状态设置回该视图——并且所有视图的历史记录都将被清除。如果它不存在，那么它是一个新的状态，并将其附加到历史堆栈的末尾。它本质上是<em class="kb"> CLEAR_TOP </em>，除了它实际工作。这决定了您在遍历中看到的<code class="eh lf lg lh li b">destination</code>历史堆栈。</p><p id="3889" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您想要更细粒度的历史修改，Flow也可以满足您:</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="mk ml l"/></div></figure><h1 id="b7a3" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">旧版本中可怕的东西:迫击炮/匕首</h1><h2 id="7fa7" class="lj kd hu bd ke lk ll lm ki ln lo lp km jn lq lr kq jr ls lt ku jv lu lv ky lw dt translated">旧广场“大图”</h2><p id="3cd5" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">流0.8的例子看起来很吓人，主要是因为迫击炮和匕首1。如果你问我，Mortar通过ViewPresenter的状态持久性在概念上是有缺陷的，Dagger1被Dagger2取代。尽管如此，了解我们试图解决什么问题可能是值得的，即使它已经过时了，或者由Dispatcher实现在外部处理。</p><pre class="lx ly lz ma fq mb li mc md aw me dt"><span id="0fd7" class="lj kd hu li b fv mf mg l mh mi">@Screen<strong class="li hv">(</strong>layout <strong class="li hv">=</strong> R<strong class="li hv">.</strong>layout<strong class="li hv">.</strong>album_view<strong class="li hv">)</strong><br/>public class AlbumScreen <strong class="li hv">implements</strong> <strong class="li hv">Blueprint {</strong><br/>  final int albumId;</span><span id="d0bc" class="lj kd hu li b fv mj mg l mh mi">  public AlbumScreen(int albumId) { this.albumId = albumId; }</span><span id="5c69" class="lj kd hu li b fv mj mg l mh mi"> <strong class="li hv"> @Override String getMortarScopeName() {<br/>    return "AlbumScreen";<br/>  }</strong></span><span id="e8c0" class="lj kd hu li b fv mj mg l mh mi"><strong class="li hv">  @Override Object getDaggerModule() {<br/>    return new Module();<br/>  }</strong></span><span id="330f" class="lj kd hu li b fv mj mg l mh mi">  <strong class="li hv">@dagger.Module(addsTo = AppModule.class)<br/>  static class Module {<br/>    @Provides Album provideAlbum(JukeBox jukebox) {<br/>      return jukebox.getAlbum(albumId);<br/>    }<br/>  }</strong><br/>}</span></pre><p id="b478" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，定义一个表示器，它接收从Dagger的ObjectGraph注入的依赖项，由Mortar的作用域保留:</p><pre class="lx ly lz ma fq mb li mc md aw me dt"><span id="41a0" class="lj kd hu li b fv mf mg l mh mi">@Singleton <br/>public static class Presenter <strong class="li hv">extends</strong> ViewPresenter<strong class="li hv">&lt;</strong>AlbumView<strong class="li hv">&gt;</strong> <strong class="li hv">{</strong><br/>  <strong class="li hv">private</strong> <strong class="li hv">final</strong> Album album<strong class="li hv">;</strong></span><span id="11ba" class="lj kd hu li b fv mj mg l mh mi">  @Inject Presenter<strong class="li hv">(</strong>Album album<strong class="li hv">)</strong> <strong class="li hv">{</strong> <strong class="li hv">this.</strong>album <strong class="li hv">=</strong> album<strong class="li hv">;</strong> <strong class="li hv">}<br/></strong></span></pre><p id="bd6d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">和观点:</p><pre class="lx ly lz ma fq mb li mc md aw me dt"><span id="c9fb" class="lj kd hu li b fv mf mg l mh mi"><strong class="li hv">public</strong> <strong class="li hv">class</strong> <strong class="li hv">AlbumView</strong> <strong class="li hv">extends</strong> FrameLayout <strong class="li hv">{</strong><br/>  @Inject AlbumScreen<strong class="li hv">.</strong>Presenter presenter<strong class="li hv">;</strong></span><span id="1987" class="lj kd hu li b fv mj mg l mh mi"><strong class="li hv">  private</strong> <strong class="li hv">final</strong> TextView newNameView<strong class="li hv">;</strong></span><span id="4195" class="lj kd hu li b fv mj mg l mh mi"><strong class="li hv">  public</strong> <strong class="li hv">AlbumView(</strong>Context context<strong class="li hv">,</strong> AttributeSet attrs<strong class="li hv">)</strong> <strong class="li hv">{</strong><br/>    <strong class="li hv">super(</strong>context<strong class="li hv">,</strong> attrs<strong class="li hv">);</strong><br/>    Mortar<strong class="li hv">.</strong>inject<strong class="li hv">(</strong>context<strong class="li hv">,</strong> <strong class="li hv">this);</strong></span></pre><p id="c778" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="kb">当然，这个</em> <code class="eh lf lg lh li b"><a class="ae ka" href="https://github.com/square/mortar/pull/2/files#diff-8c45305219e23e9aa32a516d557a98e4" rel="noopener ugc nofollow" target="_blank"><em class="kb">Blueprint</em></a></code> <em class="kb">也可以是类似</em> <code class="eh lf lg lh li b"><em class="kb">@Blueprint(scope = "AlbumScreen", module = AlbumScreen.Module.class)</em></code> <em class="kb">的注释。后来，它作为一个图书馆被从迫击炮中移除。</em></p><h2 id="17a2" class="lj kd hu bd ke lk ll lm ki ln lo lp km jn lq lr kq jr ls lt ku jv lu lv ky lw dt translated">砂浆是什么？</h2><p id="0034" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">BluePrint回到了<a class="ae ka" href="https://github.com/square/mortar/blob/master/CHANGELOG.md#version-017-2015-04-27" rel="noopener ugc nofollow" target="_blank"> Mortar 0.17 API quake </a>之前，当时Mortar与Dagger1捆绑在一起——它本质上是一个服务定位器，其中用于<code class="eh lf lg lh li b">LinkedHashMap</code>的<em class="kb">范围</em>由一个字符串键标识，这个<em class="kb">范围</em>在配置更改后仍然存在，而<a class="ae ka" rel="noopener" href="/@theMikhail/system-services-are-not-just-for-the-system-ce33aab4594a#.8ym79d4y0">通过覆盖</a> <code class="eh lf lg lh li b"><a class="ae ka" rel="noopener" href="/@theMikhail/system-services-are-not-just-for-the-system-ce33aab4594a#.8ym79d4y0">getSystemService()</a></code>，它用于提供依赖关系的分层范围(想想具有Dagger2的<code class="eh lf lg lh li b">@Singleton</code>和<code class="eh lf lg lh li b">@ActivityScope</code>，并在整个视图层次中看到它们，同时还在轮换之间保留它们。</p><p id="862f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Mortar还将自己视为视图的“呈现者”(<code class="eh lf lg lh li b">ViewPresenter&lt;V&gt;</code>)，并处理来自活动的<code class="eh lf lg lh li b">onSaveInstanceState()</code>的委托，以便将呈现者的状态持久化到活动的包中。</p><h2 id="6a77" class="lj kd hu bd ke lk ll lm ki ln lo lp km jn lq lr kq jr ls lt ku jv lu lv ky lw dt translated">砂浆的问题</h2><p id="007d" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">Mortar根本没有融入心流——你在心流中向前导航，又向后导航；而Mortar无法持久化视图的状态，因为它从未收到来自<code class="eh lf lg lh li b">activity.onSaveInstanceState(Bundle)</code>的回调。在导航更改之间，所有视图状态都丢失了。</p><p id="33dd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">结果，Mortar的ViewPresenter由于多种原因而存在缺陷——这正是为什么<strong class="je hv">流</strong>本身开始处理状态持久性。</p><h2 id="5536" class="lj kd hu bd ke lk ll lm ki ln lo lp km jn lq lr kq jr ls lt ku jv lu lv ky lw dt translated">流和状态持久性(超越视图状态)</h2><p id="bebf" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">但是Flow只提供了一种保存视图状态的直接方法——尽管它在历史中有一个槽，允许将一个包与视图状态一起保存。而Flow并没有提供一种方式(还没有？)要访问这个包，可以将它与一些包内部的逻辑一起使用，这样您就可以<a class="ae ka" href="https://github.com/square/flow/issues/181" rel="noopener ugc nofollow" target="_blank">手动</a>将presenter状态通过视图保存到一个包中。</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="358d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后你可以打电话</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="e622" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，您的视图也能够在旋转时将其状态保存到一个包中。</p><h2 id="e99e" class="lj kd hu bd ke lk ll lm ki ln lo lp km jn lq lr kq jr ls lt ku jv lu lv ky lw dt translated">作为服务定位器的Mortar和“托管服务”</h2><p id="0d0b" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">Mortar还提供了一种从绑定到上下文的范围中检索Dagger对象图的方法，该范围可以手动创建和销毁，与活动生命周期本身无关。</p><p id="b317" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个换成了Square的Flow 1.0-alpha作为<code class="eh lf lg lh li b">ManagedServices</code>和<code class="eh lf lg lh li b">ServiceFactory</code>，我个人根本不用这些。它们将解决创建和销毁服务的问题，如果键属于同一个“流”，则在视图状态之间共享它们，从而在视图之间共享资源。</p><p id="a33a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果这行得通，那就太好了，但是我遇到了“节点引用计数”和<code class="eh lf lg lh li b">TreeKey</code>的神秘错误——所以我跳过了它。</p><p id="baa2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是没错，<a class="ae ka" href="https://github.com/square/flow/blob/master/flow-sample-tree/src/main/java/flow/sample/tree/FlowServices.java" rel="noopener ugc nofollow" target="_blank">的</a> <code class="eh lf lg lh li b"><a class="ae ka" href="https://github.com/square/flow/blob/master/flow-sample-tree/src/main/java/flow/sample/tree/FlowServices.java" rel="noopener ugc nofollow" target="_blank">ServiceFactory</a></code> <a class="ae ka" href="https://github.com/square/flow/blob/master/flow-sample-tree/src/main/java/flow/sample/tree/FlowServices.java" rel="noopener ugc nofollow" target="_blank">就是会取代迫击炮的东西。</a></p><h1 id="f6f7" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">使用心流的新蓝图</h1><p id="2fb0" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">既然我们有了状态持久化的backstack，我们就能够创建表示活动窗口的视图，而不必依赖活动来完成。</p><p id="e5a2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们还对这个<a class="ae ka" href="https://hackernoon.com/tagged/backstack" rel="noopener ugc nofollow" target="_blank"> backstack </a>进行了细粒度的操作，而不是试图让<a class="ae ka" href="https://hackernoon.com/tagged/android" rel="noopener ugc nofollow" target="_blank"> Android </a>用魔法意图标志做我们想要它做的事情。</p><p id="42d1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的意图被键参数代替，片段事务也被键本身代替。所有状态更改都由调度程序管理，这提供了可预测的行为，而不是“未附加的陈旧片段”。我们的活动和片段被定制的视图组所取代，消除了复杂性并提供了更好的性能。</p><p id="d0ca" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过最少的配置，我们现在可以创建视图驱动的应用程序，就像这样。</p><ul class=""><li id="b720" class="mm mn hu je b jf jg jj jk jn mo jr mp jv mq jz mr ms mt mu dt translated">活动</li></ul><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="mk ml l"/></div></figure><ul class=""><li id="8a0d" class="mm mn hu je b jf jg jj jk jn mo jr mp jv mq jz mr ms mt mu dt translated">钥匙</li></ul><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="mk ml l"/></div></figure><ul class=""><li id="3f89" class="mm mn hu je b jf jg jj jk jn mo jr mp jv mq jz mr ms mt mu dt translated">视角</li></ul><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="mk ml l"/></div></figure><ul class=""><li id="c50a" class="mm mn hu je b jf jg jj jk jn mo jr mp jv mq jz mr ms mt mu dt translated">提出者</li></ul><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="a42f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">视图和表示之间的分离相当简单——比活动或片段更清晰。</p><p id="8822" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我们真正需要的是一个在配置改变后仍然存在的独立的状态表示时，为什么我们还在与碎片作战呢？</p><p id="dfa1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然你可以使用导体，但我还没有用过。我更喜欢Flow提供的细粒度控制——并直接了解底层发生了什么。</p><p id="8d0c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">(<em class="kb"> Reddit讨论</em>:<a class="ae ka" href="https://www.reddit.com/r/androiddev/comments/5awo5r/saying_no_to_fragments_and_activities_creating/" rel="noopener ugc nofollow" target="_blank">https://www . Reddit . com/r/Android dev/comments/5a wo5 r/saying _ no _ to _ fragments _ and _ activities _ creating/</a>)</p><div class="lx ly lz ma fq ab cb"><figure class="mv iv mw mx my mz na paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mv iv mw mx my mz na paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mv iv mw mx my mz na paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="nb nc nd"><p id="f922" class="jc jd kb je b jf jg jh ji jj jk jl jm ne jo jp jq nf js jt ju ng jw jx jy jz hn dt translated"><a class="ae ka" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ka" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ka" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae ka" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd kb je b jf jg jh ji jj jk jl jm ne jo jp jq nf js jt ju ng jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ka" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ka" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lx ly lz ma fq iv fe ff paragraph-image"><a href="https://goo.gl/Ahtev1"><div class="fe ff nh"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></a></figure><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="ni ml l"/></div></figure></div></div>    
</body>
</html>