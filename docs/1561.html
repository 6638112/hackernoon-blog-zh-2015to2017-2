<html>
<head>
<title>Functional Reactive Programming in Swift 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift 3中的函数式反应式编程</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/functional-reactive-programming-in-swift-f67a0939266b?source=collection_archive---------0-----------------------#2016-11-15">https://medium.com/hackernoon/functional-reactive-programming-in-swift-f67a0939266b?source=collection_archive---------0-----------------------#2016-11-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="e6c1" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">使用RxSwift进行数据绑定</h2></div><p id="f269" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这篇文章是一个教程，将教你如何使用RxSwift将数据绑定到视图，rx swift是函数反应式<a class="ae kf" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a> (FRP) <a class="ae kf" href="https://hackernoon.com/tagged/design" rel="noopener ugc nofollow" target="_blank">设计</a>模式的一部分——视图对数据的变化做出反应。<strong class="jl hv"> FRP是<em class="kg">不是</em> MVC。</strong>这些设计模式各不相同。除非你有充分的理由在一个项目中同时使用这两种模式，否则我建议你在架构模式上保持一致——只坚持一种！</p><p id="2d80" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">提醒一下，模型视图控制器(MVC)包括让一个<strong class="jl hv">视图控制器</strong>成为一个<strong class="jl hv">数据模型</strong>和屏幕上的<strong class="jl hv">视图</strong>之间的“中间人”。</p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="fe ff kh"><img src="../Images/9cd406109711991706c390d55c00ed52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cFoDnOh9xYQsLhNBZikSWg.jpeg"/></div></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">The Model and View never directly communicate, but use the Controller to pass information.</figcaption></figure><p id="553d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">注意，当使用MVC设计模式时，模型和视图<em class="kg">从不</em>直接通信。</p><p id="c91b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">MVC的一个<em class="kg">替代方案</em>是一种被称为功能反应式编程(FRP)的设计模式。FRP与MVC完全相反——考虑到模型和视图有一个<strong class="jl hv">直接连接的事实。</strong></p><p id="0b34" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在本教程中，我们将只关注使用RxSwift将数据绑定到视图—每当数据更新时，您的视图将自动更新。</p><p id="e32f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">本教程要求您使用一个名为<a class="ae kf" href="https://github.com/ReactiveX/RxSwift" rel="noopener ugc nofollow" target="_blank"> RxSwift </a>的Cocoapod。<strong class="jl hv">我提供的链接是Swift 3的。</strong>如果您使用的是Swift 2.3，请使用RxSwift 的这个分支<a class="ae kf" href="https://github.com/ReactiveX/RxSwift/tree/rxswift-2.0" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="b0f5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们要做的是在数据和视图之间建立一个直接的连接。你可以在这里分叉克隆我的首发回购<a class="ae kf" href="https://github.com/juliascript/FRPTutorial/tree/b97fe32f05a4f97a95478c99a62502ed7261a0fe" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="32a7" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们以一个<code class="eh kx ky kz la b">UILabel</code>为例，它根据来自<code class="eh kx ky kz la b">UIAlertController</code>的文本输入进行更新。</p><p id="ed64" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通常，您可能有一个如下所示的变量来表示名称值:</p><pre class="ki kj kk kl fq lb la lc ld aw le dt"><span id="5379" class="lf lg hu la b fv lh li l lj lk">let name: String = "Julia"</span></pre><p id="e1e7" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">要将这个变量转换成与RxSwift兼容的变量，我们必须改变变量的类型。</p><pre class="ki kj kk kl fq lb la lc ld aw le dt"><span id="56fd" class="lf lg hu la b fv lh li l lj lk">let name: Variable&lt;String&gt; = Variable("Julia")</span></pre><p id="1fb7" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">注意，我们的变量现在属于<code class="eh kx ky kz la b">Variable</code>类，它是RxSwift库的一部分。</p><p id="3e17" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您可能已经注意到，<code class="eh kx ky kz la b">Variable</code>类充当存储在变量中的数据的<em class="kg">包装器</em>。所以，你仍然可以通过调用<code class="eh kx ky kz la b">name.value</code>来访问字符串“Julia”。</p><p id="4224" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">接下来，我们对变量<code class="eh kx ky kz la b">name</code>调用<code class="eh kx ky kz la b">asObservable</code>函数。然后我们对结果调用<code class="eh kx ky kz la b">bindTo</code>函数，传入我们绑定到的视图元素。</p><pre class="ki kj kk kl fq lb la lc ld aw le dt"><span id="32c3" class="lf lg hu la b fv lh li l lj lk">name.asObservable()<br/>    .bindTo(nameLabel.rx.text)</span></pre><p id="1683" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这个特例中，我们绑定到名为<code class="eh kx ky kz la b">nameLabel</code>的<code class="eh kx ky kz la b">UILabel </code>的<code class="eh kx ky kz la b">text</code>属性。然而，<code class="eh kx ky kz la b">bindTo</code>函数也允许我们绑定到视图的其他属性，比如<code class="eh kx ky kz la b">backgroundColor</code>。</p><p id="5935" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最后，我们必须初始化并使用一个处置包。<strong class="jl hv">我们在数据和视图之间创建的绑定即使在视图控制器被释放后也将持续。</strong>当视图控制器被释放时，dispose包将确保绑定也被释放。</p><pre class="ki kj kk kl fq lb la lc ld aw le dt"><span id="b394" class="lf lg hu la b fv lh li l lj lk">let disposeBag = DisposeBag()</span></pre><p id="4b59" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了将绑定添加到dispose包中，我们必须调用绑定的最后一个函数。最终的绑定应该是这样的:</p><pre class="ki kj kk kl fq lb la lc ld aw le dt"><span id="86b4" class="lf lg hu la b fv lh li l lj lk">name.asObservable()<br/>    .bindTo(nameLabel.rx.text)<br/>    .addDisposableTo(disposeBag)</span></pre><p id="0d32" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最后，为了改变你的观点，你需要改变数据！本教程中的变量基于来自<code class="eh kx ky kz la b">UIAlertController</code>的文本输入而改变，我们将实现改变视图的代码。</p><p id="dfa9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通常，您的操作结束可能如下所示:</p><pre class="ki kj kk kl fq lb la lc ld aw le dt"><span id="8579" class="lf lg hu la b fv lh li l lj lk">let okAction = UIAlertAction(title: "OK", style: .default) { action in<br/>            if let textInput = alert.textFields?.first?.text {<br/>                self.name = textInput<br/>                self.nameLabel.text = self.name<br/>           }<br/>}</span></pre><p id="449a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">请注意，您必须更新视图和数据。当我们将视图绑定到数据时，我们不需要更新视图。绑定意味着它会自动更新！我们要做的就是改变数据本身。</p><pre class="ki kj kk kl fq lb la lc ld aw le dt"><span id="fd34" class="lf lg hu la b fv lh li l lj lk">let okAction = UIAlertAction(title: "OK", style: .default) { action in<br/>            if let textInput = alert.textFields?.first?.text {<br/>                self.name.value = textInput<br/>            }<br/>}</span></pre><p id="5b36" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">记住<code class="eh kx ky kz la b">name</code>的类型是<code class="eh kx ky kz la b">Variable</code>——这意味着数据被封装在一个包装器中。我们不得不更新数据，而不是更新名称变量本身，数据恰好在它的<code class="eh kx ky kz la b">value</code>属性中。</p><p id="e65b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里有一个<a class="ae kf" href="https://github.com/juliascript/FRPTutorial" rel="noopener ugc nofollow" target="_blank"> Github repo </a>的链接，里面有本教程的工作代码。如果您有任何问题，请随时联系我们！</p></div><div class="ab cl ll lm hc ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hn ho hp hq hr"><p id="c6bc" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你通过阅读这篇文章获得了价值吗？<a class="ae kf" href="http://ctt.ec/l1ica" rel="noopener ugc nofollow" target="_blank">点击这里</a>在Twitter上分享！如果你想更经常地看到这样的内容，请在Medium上关注我，并订阅我每月一次的简讯。你也可以请我喝杯咖啡。</p><figure class="ki kj kk kl fq km"><div class="bz el l di"><div class="ls lt l"/></div></figure><div class="ki kj kk kl fq ab cb"><figure class="lu km lv lw lx ly lz paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="lu km lv lw lx ly lz paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="lu km lv lw lx ly lz paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ma mb mc"><p id="f922" class="jj jk kg jl b jm jn iv jo jp jq iy jr md jt ju jv me jx jy jz mf kb kc kd ke hn dt translated"><a class="ae kf" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kf" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kf" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae kf" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jj jk kg jl b jm jn iv jo jp jq iy jr md jt ju jv me jx jy jz mf kb kc kd ke hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kf" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kf" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ki kj kk kl fq km fe ff paragraph-image"><a href="https://goo.gl/Ahtev1"><div class="fe ff mg"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></a></figure><figure class="ki kj kk kl fq km"><div class="bz el l di"><div class="ls lt l"/></div></figure></div></div>    
</body>
</html>