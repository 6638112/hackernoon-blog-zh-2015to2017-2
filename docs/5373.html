<html>
<head>
<title>Web Assembly Proof of Concept With Emscripten &amp; VS Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Emscripten和VS代码的Web程序集概念验证</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/web-assembly-proof-of-concept-with-emscripten-vs-code-530e69eb4de0?source=collection_archive---------2-----------------------#2017-07-23">https://medium.com/hackernoon/web-assembly-proof-of-concept-with-emscripten-vs-code-530e69eb4de0?source=collection_archive---------2-----------------------#2017-07-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="6214" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">TL；DR:我对Web Assembly感兴趣有一段时间了，最后坐下来做了一点概念验证，看看我能走多远。我对这个结果感到高兴和鼓舞。</p><p id="5c9b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可能会发现这对您自己的研究很有用。</p></div><div class="ab cl jp jq hc jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hn ho hp hq hr"><h1 id="7801" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">上蜡历史</h1><p id="871b" class="pw-post-body-paragraph ir is hu it b iu ku iw ix iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo hn dt translated">如果你只是想得到技术位，跳过这一节。</p><p id="e676" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我对用除了JavaScript之外的语言编写web应用的潜力越来越感兴趣。当然，这已经发生了。我没有用普通的JS写过任何重要的东西，因为…我不确定。我清楚地记得在2013年用普通JS写了一个应用程序(！)就这样。</p><p id="0950" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从那以后，我开始从事<a class="ae kz" href="https://hackernoon.com/tagged/typescript" rel="noopener ugc nofollow" target="_blank">打字稿</a>的工作。我很喜欢TS(我最近<a class="ae kz" href="https://goo.gl/fk12K2" rel="noopener ugc nofollow" target="_blank">出版了一本关于它的免费书籍</a>，但是说到底，它基本上只是JavaScript，不足以<a class="ae kz" href="https://hackernoon.com/the-wonderful-consequences-of-javascript-as-the-virtual-machine-language-of-the-web-3a65cbf887fa" rel="noopener ugc nofollow" target="_blank">改善我对SmallTalk的嫉妒</a>:)。我玩了一下<a class="ae kz" href="https://clojurescript.org/guides/quick-start" rel="noopener ugc nofollow" target="_blank">闭包</a>，但是我被这篇关于系统程序员的<a class="ae kz" href="https://www.usenix.org/system/files/1311_05-08_mickens.pdf" rel="noopener ugc nofollow" target="_blank">*有趣的文章转移了话题。你真的应该现在就看。</a></p><p id="7354" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">说真的。就<a class="ae kz" href="https://www.usenix.org/system/files/1311_05-08_mickens.pdf" rel="noopener ugc nofollow" target="_blank">去读吧</a>。</p><p id="34c8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我是一个自学成才的C程序员，从Kernighan和Ritchie的开创性著作(第一版，不算少)的第一版中学习。大约20年前，我买了Borland的C++编译器并开始使用。这些天我离那些根很远:(。不要误解我——我喜欢我所做的事情，但是如此直接地与记忆一起工作并且如此接近硬件真的很有趣和令人兴奋。</p><p id="f0c5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，这篇有趣的文章让我想起了那些有趣的日子，我决定看看编写C/C++代码并将其作为web应用程序的一部分进行部署是否可行。</p></div><div class="ab cl jp jq hc jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hn ho hp hq hr"><h1 id="cc27" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">概念验证</h1><p id="5e65" class="pw-post-body-paragraph ir is hu it b iu ku iw ix iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo hn dt translated">我是从查《web组装教程》开始的，偶然看到这篇文章:<a class="ae kz" href="https://tutorialzine.com/2017/06/getting-started-with-web-assembly" rel="noopener ugc nofollow" target="_blank">https://tutorial zine . com/2017/06/getting-started-with-web-assembly</a></p><p id="b5cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这篇文章在很大程度上起了作用，但我认为一些底层基础设施已经发生了变化。我必须在JavaScript方面做一些改动，才能让这篇文章的代码正常工作。然后我把它延长了一点。</p><p id="52f8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我在windows 10笔记本电脑上完成了所有这些工作。</p><p id="1b6d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是在高层次上发生的事情:</p><ul class=""><li id="31ac" class="la lb hu it b iu iv iy iz jc lc jg ld jk le jo lf lg lh li dt translated">你生成一些Wasm代码。Wasm是一些浏览器可以理解的二进制格式。在我写这篇文章的时候，Chrome可以加载和使用WASM。其他人也可以，但我只用过Chrome。</li><li id="24da" class="la lb hu it b iu lj iy lk jc ll jg lm jk ln jo lf lg lh li dt translated">您可以通过各种方式生成Wasm二进制文件。我选择了使用<a class="ae kz" href="http://kripken.github.io/emscripten-site/index.html" rel="noopener ugc nofollow" target="_blank"> Emscripten </a>。我认为还有其他选择。</li><li id="06e2" class="la lb hu it b iu lj iy lk jc ll jg lm jk ln jo lf lg lh li dt translated">Emscripten将获取您的C或C++代码，编译它并为您生成Wasm二进制文件。我确信这不仅仅需要<em class="lo">任何</em> C/C++代码。我不知道这些界限是什么。</li><li id="a4f7" class="la lb hu it b iu lj iy lk jc ll jg lm jk ln jo lf lg lh li dt translated">Emscripten还生成了大量的JavaScript。TutorialZine文章的作者将其称为“胶水代码”。此外，这个生成的JS知道如何加载和启动Wasm二进制文件。它还为您提供了许多生命周期挂钩。加载和初始化过程异步运行。我使用其中一个钩子宣布(通过一个普通的JS事件)我的C代码已经可以投入使用了。</li><li id="4906" class="la lb hu it b iu lj iy lk jc ll jg lm jk ln jo lf lg lh li dt translated">一旦它被加载，你就像调用普通的JS函数一样调用你的C/C++例程。您的C代码可以调用您的JavaScript函数，您甚至可以让您的C代码调用一个JS函数来调用另一个C函数。为什么这么做？当然是为了纯粹的快乐！</li></ul></div><div class="ab cl jp jq hc jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hn ho hp hq hr"><h1 id="7949" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">步骤1:安装Emscripten</h1><p id="d619" class="pw-post-body-paragraph ir is hu it b iu ku iw ix iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo hn dt translated">我发现这很容易，也不需要很长时间。到这里:<a class="ae kz" href="https://kripken.github.io/emscripten-site/docs/getting_started/downloads.html" rel="noopener ugc nofollow" target="_blank">https://kri pken . github . io/EMS cripten-site/docs/getting _ started/downloads . html</a>。</p><p id="e98b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用web安装程序。</p><p id="271b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">等一会儿就好了。</p><h1 id="5d0c" class="jw jx hu bd jy jz lp kb kc kd lq kf kg kh lr kj kk kl ls kn ko kp lt kr ks kt dt translated">第二步:写一些C代码</h1><p id="83df" class="pw-post-body-paragraph ir is hu it b iu ku iw ix iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo hn dt translated">我使用TutorialZine代码作为测试的基础，并添加了一点:</p><figure class="lu lv lw lx fq ly"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="016c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如您所见，第8行有一个常规的C main()函数。</p><p id="924e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还有三个附加功能:</p><ul class=""><li id="fbd3" class="la lb hu it b iu iv iy iz jc lc jg ld jk le jo lf lg lh li dt translated">roll_dice:这是来自TutorialZine的文章。它产生一个从1到6的随机数。当用户点击CSS渲染的骰子并根据结果重新绘制自己时，JS UI调用这个。</li><li id="ddd6" class="la lb hu it b iu lj iy lk jc ll jg lm jk ln jo lf lg lh li dt translated">请注意这里有一个标记，EMSCRIPTEN_KEEPALIVE。我不完全确定这是如何工作的，但是…它基本上保持了后加载的功能。如果你没有用这个标记来修饰你的函数，你就不能从JavaScript调用它。</li><li id="25db" class="la lb hu it b iu lj iy lk jc ll jg lm jk ln jo lf lg lh li dt translated">我有一个函数，sayHi()。这个做了几件事:</li></ul><ol class=""><li id="ec36" class="la lb hu it b iu iv iy iz jc lc jg ld jk le jo mb lg lh li dt translated">第19行:emscripten _ run _ script(" console . log(' hi3！)");emscript_run_script执行相关的JavaScript。</li><li id="c685" class="la lb hu it b iu lj iy lk jc ll jg lm jk ln jo mb lg lh li dt translated">在第20行，它调用函数_sayXyzzy()。_sayXyzzy实际上是C程序中的另一个函数，它只是注销到控制台，“Xyzzy”(同样，通过emscripten_run_script —参见代码中的第24行)。</li></ol><p id="0587" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它做得不多，但对于这个循序渐进的概念验证来说已经足够好了。</p><h1 id="667f" class="jw jx hu bd jy jz lp kb kc kd lq kf kg kh lr kj kk kl ls kn ko kp lt kr ks kt dt translated">编译C代码</h1><p id="02b0" class="pw-post-body-paragraph ir is hu it b iu ku iw ix iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo hn dt translated">我是通过Emscripten命令行(web安装程序的一部分)开始这样做的，非常简单:</p><figure class="lu lv lw lx fq ly fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mc"><img src="../Images/444d0b2eb79f334942968f623edcdb0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xshY-piqkEfQ-8pZHN8oJQ.png"/></div></div><figcaption class="mj mk fg fe ff ml mm bd b be z ek">You can always tell those developers who come from the ee cummings branch of CompSci.</figcaption></figure><p id="a09a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我第一次运行该命令时，它进行了大量的初始化，并出现了一些可怕的警告。然而，一切都解决了。我觉得其实就是编译一堆标准C库，可能先下载。后续运行看起来像上面的截图。</p><p id="f72e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您应该阅读完整的Emscripten文档，了解有关选项的详细信息。这个命令编译一个C文件，dice-roll.c。它生成一个WASM文件(WASM=1)。它只做很少的优化(-O1 —注意，O代表优化，0代表零)。它还生成了那个glue JS文件，并将其命名为“index.js”。</p><p id="e285" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此后不久，我就转而使用VS代码。VS Code告诉我有一个插件可以查看C/C++文件，我安装了这个插件。然后，我为上述内容创建了一个任务。我最终用实际命令创建了一个. bat文件。My tasks.json看起来是这样的:</p><figure class="lu lv lw lx fq ly fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mn"><img src="../Images/d238b2a9d33dc4a1945b71104c0a0031.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9BWytwSyjfmJMQeZr_LanA.png"/></div></div></figure><h1 id="b248" class="jw jx hu bd jy jz lp kb kc kd lq kf kg kh lr kj kk kl ls kn ko kp lt kr ks kt dt translated">让它在浏览器中工作</h1><p id="2869" class="pw-post-body-paragraph ir is hu it b iu ku iw ix iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo hn dt translated">让它在Chrome中工作非常简单。只是创建一个准系统。html文件(如index.html ),并包含emcc命令在前面步骤中生成的index.js文件。</p><p id="0e73" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那个index.js文件是……什么的:)。在我的env里，有6111行长:)。这不是很好的记录，但足以帮助我找出。这是一个很好的起点:<a class="ae kz" href="https://kripken.github.io/emscripten-site/docs/api_reference/module.html#module" rel="noopener ugc nofollow" target="_blank">https://kri pken . github . io/emscripten-site/docs/API _ reference/module . html # module</a>。</p><p id="8c16" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在大约1000个其他东西中，它加载Wasm文件并创建一个全局可用的对象Module。事实上，如果您已经创建了模块，它是模块的补充。我认为你总是想这样做，这样你就可以影响初始化的生命周期。</p><p id="78c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个index.js plus模块对象允许我做几件重要的事情:</p><ul class=""><li id="67cd" class="la lb hu it b iu iv iy iz jc lc jg ld jk le jo lf lg lh li dt translated">首先加载Wasm</li><li id="a1a2" class="la lb hu it b iu lj iy lk jc ll jg lm jk ln jo lf lg lh li dt translated">将函数添加到模块的“postRun”数组中。一旦Wasm被加载和初始化，index.js初始化代码就运行这些postRun函数。</li><li id="8588" class="la lb hu it b iu lj iy lk jc ll jg lm jk ln jo lf lg lh li dt translated">提供了一个有用的包装器，让我调用C代码函数。</li></ul><p id="b709" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是我的HTML:</p><figure class="lu lv lw lx fq ly"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="3236" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">很多都是直接来自TutorialZine的文章。我通过添加对“prerun.js”的引用进行了修改。</p><p id="e67f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Emscripten创建了index.js文件(第18行),这就是6100行的胶水怪物。</p><p id="ccc9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">剩下的来自TutorialZine。它引用了一些在显示骰子方面做得很好的CSS。它在click上添加了一个事件监听器，调度一个匿名函数调用第31行的C代码:</p><blockquote class="mo mp mq"><p id="c9e3" class="ir is lo it b iu iv iw ix iy iz ja jb mr jd je jf ms jh ji jj mt jl jm jn jo hn dt translated"><em class="hu"> var </em>结果=模块。_ roll _ dice()；</p></blockquote><p id="d7ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您还记得，实际的C函数的名称是roll_dice(没有前导下划线)。Emscripten index.js文件用所有C函数填充Module对象(记住它们必须用那个EMSCRIPTEN_KEEPALIVE标记来修饰)。本质上，这些是代理JavaScript函数。Emscripten在C函数的名称前插入一个下划线。如果你的C代码中有函数“somawesomefunction”，那么JS模块对象将有一个函数，_ someAwesomeFunction()供你在需要时调用。</p><p id="f56a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第21行实际上抛出了一个运行时错误。That _sayHi() JS函数，它是C中sayHi()函数的代理，现在还不存在。index.js文件异步工作。它最终是可用的，当我开始点击骰子时，它确实可用了。第33行从不失败，但第21行总是失败。</p><p id="63be" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">很明显想知道C代码什么时候能用。这就是“prerun.js”发挥作用的地方。</p><p id="1302" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是从第17行加载的prerun.js:</p><figure class="lu lv lw lx fq ly"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="0ecc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第一行，我定义了一个空的模块对象。</p><p id="2d67" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我定义了几个函数(sayAbc()、sayXyz()、sayInit())。</p><p id="322e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当index.js粘合代码执行时，它将补充已经存在的模块对象，或者创建一个新的模块对象。在这种情况下，我已经创建了它，所以它补充它。</p><p id="e32e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">事实上，它不仅仅是补充。我可以通过提供一些在特定时间执行的函数来影响模块的生命周期，比如preRun[]、onInit[]、postRun[]，甚至更多。在线文档为我指明了方向，postRun[]是我能够可靠地开始运行我的C代码的地方。</p><p id="1496" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以看到我在第18行有一个函数notifyReady()。它只是创建一个事件并将其发布到窗口对象上。</p><p id="b979" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在第25行，我有一个事件监听器。当它获得事件时，它记录一条快乐的消息，然后调用模块。_sayHi()。</p><p id="4f96" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我在第23行的postRun[]数组中添加了两个函数。</p><h1 id="2ac4" class="jw jx hu bd jy jz lp kb kc kd lq kf kg kh lr kj kk kl ls kn ko kp lt kr ks kt dt translated">总结</h1><p id="a755" class="pw-post-body-paragraph ir is hu it b iu ku iw ix iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo hn dt translated">当你像这样详细地把它拼写出来时，可能会觉得有点难以理解，但实际上并没有那么复杂。</p><ol class=""><li id="8433" class="la lb hu it b iu iv iy iz jc lc jg ld jk le jo mb lg lh li dt translated">安装Emscripten。</li><li id="55d1" class="la lb hu it b iu lj iy lk jc ll jg lm jk ln jo mb lg lh li dt translated">写点C代码。</li><li id="1eea" class="la lb hu it b iu lj iy lk jc ll jg lm jk ln jo mb lg lh li dt translated">用某种构建过程来emcc你的C代码。当然，有一百万种方法可以做到这一点。</li><li id="d633" class="la lb hu it b iu lj iy lk jc ll jg lm jk ln jo mb lg lh li dt translated">使用生成的JS“glue”代码来加载和处理Wasm。</li><li id="7c5b" class="la lb hu it b iu lj iy lk jc ll jg lm jk ln jo mb lg lh li dt translated">利用生命周期数组钩子来安全地执行C函数。</li></ol><p id="c1dc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦我得到了基本的工具，这是小菜一碟。编辑我的C文件，按control-shift-B。等待，然后在浏览器上按F5。</p><p id="86d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(关于浏览器的快速说明—您需要使用一个真正的web服务器，因为Wasm文件是通过fetch()d/XHR处理的。Chrome不会让你无法通过file://协议从文件系统中获取文件，所以你需要一个真正的web服务器来做这件事。我用<a class="ae kz" href="http://fenixwebserver.com/" rel="noopener ugc nofollow" target="_blank">菲尼克斯</a>来处理这类事情——它简单得可笑。).</p><p id="ef94" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就是这样！在这一点上，这似乎是一个非常可行的尝试。我不完全确定下一步去哪里。我想我可能会尝试实现一个奇特的排序算法，并与普通的JS进行一些比较/对比。</p><p id="a661" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><end/></p><p id="0baf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><postscript/></p><p id="6cb0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我最近出版了一本关于TypeScript的书！这是免费的，你可以在这里获得:<a class="ae kz" href="https://www.gitbook.com/book/pagalvin/yet-another-typescript-book/details" rel="noopener ugc nofollow" target="_blank">https://www . git book . com/book/pagal vin/yet-another-typescript-book/details</a></p><p id="b2ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"/><figure class="lu lv lw lx fq ly"><div class="bz el l di"><div class="mu ma l"/></div></figure></div></div>    
</body>
</html>