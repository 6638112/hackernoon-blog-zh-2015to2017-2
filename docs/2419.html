<html>
<head>
<title>How to use Hash ID’s in your URL in Ruby on Rails 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Ruby on Rails 5的URL中使用散列ID</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-use-hash-ids-in-your-url-in-ruby-on-rails-5-e8b7cdd31733?source=collection_archive---------3-----------------------#2017-01-26">https://medium.com/hackernoon/how-to-use-hash-ids-in-your-url-in-ruby-on-rails-5-e8b7cdd31733?source=collection_archive---------3-----------------------#2017-01-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/e892b2882ac2436ed62febd86a00f6da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JIjo1zGoDa2yyEm6q58ZeQ.png"/></div></div></figure><p id="3d43" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我构建一个Rails应用程序时，我希望以某种形式面向公众，我不想在我的URL中显示自动递增的、基于整数的id。在我看来，它不仅在视觉上看起来更好。这是一种安全性增强，通过URL消除了记录发现的可预测性。尽管自动递增的整数主键在ActiveRecord中已经根深蒂固，但我不想让事情变得太糟。有些人建议使用UUIDs，但是我觉得它们对于我喜欢的URL来说太长了。所以，我开始讲述如何在我的URL中使用散列作为id，并希望与你分享。</p><p id="4c6d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">本教程将假设您已经有了现有的模型，但是，您只需要向您的新模型添加一个“hash_id:string”列。此外，您还需要安装<a class="ae ka" href="https://github.com/norman/friendly_id" rel="noopener ugc nofollow" target="_blank"> friendly_id gem </a>。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="9602" class="kk kl hu kg b fv km kn l ko kp"># Gemfile<br/>gem 'friendly_id', '~&gt; 5.1.0'</span></pre><p id="45ee" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">…当然还有</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="ec2f" class="kk kl hu kg b fv km kn l ko kp">bundle install</span></pre><p id="2311" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">太好了，我们有了在模型上进行散列ID查找所需的宝石。接下来，我们需要将功能包含到我们的模型中。我选择创建一个模型关注点，它将能够包含在任何我们想要散列ID功能的模型中…</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="f5d9" class="kk kl hu kg b fv km kn l ko kp"># app/models/concerns/friendlyable.rb</span><span id="d602" class="kk kl hu kg b fv kq kn l ko kp">module Friendlyable<br/>  extend ActiveSupport::Concern</span><span id="715c" class="kk kl hu kg b fv kq kn l ko kp">  included do <br/>    extend ::FriendlyId<br/>    before_create :set_hash_id<br/>    friendly_id :hash_id<br/>  end</span><span id="2c59" class="kk kl hu kg b fv kq kn l ko kp">  def set_hash_id<br/>    hash_id = nil<br/>    loop do<br/>      hash_id = SecureRandom.urlsafe_base64(9).gsub(/-|_/,('a'..'z').to_a[rand(26)])<br/>      break unless self.class.name.constantize.where(:hash_id =&gt; hash_id).exists?<br/>    end<br/>    self.hash_id = hash_id<br/>  end</span><span id="276b" class="kk kl hu kg b fv kq kn l ko kp">end</span></pre><p id="bc3b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们检查一下那个文件。前两行是标准的模型关注样板。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="b4a6" class="kk kl hu kg b fv km kn l ko kp">included do <br/>    extend ::FriendlyId<br/>    before_create :set_hash_id<br/>    friendly_id :hash_id<br/>  end</span></pre><p id="b26b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">include块基本上允许您将行插入到模型文件中，就像您手动将它们放在那里一样。因此，我们添加了FriendlyId功能，添加了before_create回调，最后告诉FriendlyId我们使用的hash_id列具有FriendlyId查找列。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="1857" class="kk kl hu kg b fv km kn l ko kp">def set_hash_id<br/>    hash_id = nil<br/>    loop do<br/>      hash_id = SecureRandom.urlsafe_base64(9).gsub(/-|_/,('a'..'z').to_a[rand(26)])<br/>      break unless self.class.name.constantize.where(:hash_id =&gt; hash_id).exists?<br/>    end<br/>    self.hash_id = hash_id<br/>  end</span></pre><p id="8501" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在文件的后半部分，我们定义了从before_create钩子调用的方法。本质上，我们正在创建一个循环来创建一个URL安全散列，如果hash_id不与任何现有记录冲突，就设置hash_id属性。如果成功，我们就中断循环，并设置ActiveRecord的属性来保存。</p><p id="5046" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">既然我们已经准备好了模型关注点，那么将它包含到模型中就非常容易了:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="321b" class="kk kl hu kg b fv km kn l ko kp">class User &lt; ApplicationRecord<br/>  include Friendlyable</span><span id="3574" class="kk kl hu kg b fv kq kn l ko kp">   ...</span><span id="11f9" class="kk kl hu kg b fv kq kn l ko kp">end</span></pre><p id="1d68" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">…就是这样！让我们添加迁移来完成这个任务。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="ba8f" class="kk kl hu kg b fv km kn l ko kp">class AddHashIdToUsers &lt; ActiveRecord::Migration[5.0]<br/> def up<br/>   add_column :users, :hash_id, :string,<!-- --> index: true<br/>   User.all.each{|m| m.set_hash_id; m.save}<br/>  end</span><span id="fab6" class="kk kl hu kg b fv kq kn l ko kp">  def down<br/>   remove_column :users, :hash_id, :string<br/>  end</span><span id="362f" class="kk kl hu kg b fv kq kn l ko kp">end</span></pre><p id="0122" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">迁移将添加该列，对其进行索引，然后更新任何现有记录，使其具有hash_id。</p><p id="77a7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里的最后一部分将通过FriendlyId查找记录，这是对应用程序中任何发现的简单更新:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="1704" class="kk kl hu kg b fv km kn l ko kp">User.friendly.find(params[:id])</span></pre><p id="07eb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">…它将使用主“id”键或您的“hash_id”来查找记录。你有它！从现在开始，您可以在您的Rails应用程序中使用像<a class="ae ka" href="http://localhost:3000/users/90upoijsz" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/users/90 upoijsz</a>这样的URL。</p></div><div class="ab cl kr ks hc kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hn ho hp hq hr"><p id="925d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">PS——这个概念和其他许多概念在我的新书《在Rails 5(【https://BuildASaaSAppinRails.com】)上构建SaaS Ruby》中得到了应用，现在已经开始预售了。</p><div class="kb kc kd ke fq ab cb"><figure class="ky iv kz la lb lc ld paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="ky iv kz la lb lc ld paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="ky iv kz la lb lc ld paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="le lf lg"><p id="f922" class="jc jd lh je b jf jg jh ji jj jk jl jm li jo jp jq lj js jt ju lk jw jx jy jz hn dt translated"><a class="ae ka" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ka" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ka" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae ka" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd lh je b jf jg jh ji jj jk jl jm li jo jp jq lj js jt ju lk jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ka" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ka" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ll"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>