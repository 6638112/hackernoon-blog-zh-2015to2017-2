<html>
<head>
<title>Server-side React Rendering From non-Node Environments</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">非节点环境中的服务器端React渲染</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/server-side-react-rendering-from-non-node-environments-216021ad537d?source=collection_archive---------4-----------------------#2017-03-22">https://medium.com/hackernoon/server-side-react-rendering-from-non-node-environments-216021ad537d?source=collection_archive---------4-----------------------#2017-03-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="f607" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你的大部分前端是使用<a class="ae jp" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank"> React </a>组件构建的，那么使用相同的代码从后端呈现你的视图是有意义的。这个<strong class="it hv">预渲染</strong>，也就是说，在组件被渲染之前，不要等待你的<a class="ae jp" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> Javascript </a>加载到网络浏览器中，这对于SEO来说尤其重要。幸运的是，React提供了将组件呈现为HTML字符串的功能，然后可以从web服务器返回该字符串。然而，React是一个Javascript库，因此需要一个Javascript运行时环境。如果您使用NodeJS作为后端，那就可以了。但是如果使用Ruby on Rails、Go、Django或者其他任何非Javascript环境，就无法直接使用React的服务器端渲染功能。</p><p id="a08e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">输入<a class="ae jp" href="https://github.com/musawirali/preact-rpc" rel="noopener ugc nofollow" target="_blank"> preact-rpc </a>。</p><p id="8f4d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Preact-rpc集三种功能于一身:</p><ol class=""><li id="9c3b" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">一个RPC服务器，由连接到它的客户端完成React组件呈现请求。</li><li id="a9b1" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">一个在Javascript包中注册React组件的库，以便RPC服务器可以找到它们。</li><li id="fc51" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">用于连接RPC服务器并向其发送呈现请求的特定于语言的库的集合。</li></ol><blockquote class="ke kf kg"><p id="a08f" class="ir is kh it b iu iv iw ix iy iz ja jb ki jd je jf kj jh ji jj kk jl jm jn jo hn dt translated">基本思路是这样的。运行NodeJS套接字服务器，它可以代表客户端呈现React组件并返回HTML字符串。这种方法非常有效，因为服务器在开始时加载包含组件的Javascript包，并将其保存在内存中。</p></blockquote><p id="10dd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">整个系统非常简单，但是让我们通过一个例子来使事情变得非常清楚。</p><p id="e156" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设我们的后端是一个Go应用程序，我们希望从那里呈现React组件。假设我们有这样一个简单的组件:</p><figure class="kl km kn ko fq kp"><div class="bz el l di"><div class="kq kr l"/></div></figure><p id="58c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个简单的组件，它使用一个道具<strong class="it hv"> <em class="kh">来调用</em> </strong>并打印出一条Hello消息。</p><p id="2954" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们安装模块:<strong class="it hv"> npm安装preact-rpc </strong></p><p id="5151" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，我们需要<strong class="it hv">注册</strong>我们的组件，以便我们的RPC服务器知道如何在给定某种ID/名称的情况下识别特定的React组件。为此，我们将Javascript修改如下:</p><figure class="kl km kn ko fq kp"><div class="bz el l di"><div class="kq kr l"/></div></figure><p id="09cb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们已经用名称“hello”注册了组件Hello。当我们以后想要发送渲染请求时，我们将使用这个名称。</p><p id="348a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尽管我在上面的例子中只使用了一个组件，但是您可以根据需要注册任意多个组件。实际上，您需要创建一个包含所有必需组件的Webpack包。</p><p id="7e75" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您的Javascript现在已经准备好了。我们现在可以用这个Javascript文件启动RPC服务器:</p><figure class="kl km kn ko fq kp"><div class="bz el l di"><div class="kq kr l"/></div></figure><p id="7b76" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将启动一个带有UNIX套接字的服务器。您可以通过为端口命令行参数提供一个数字来使用TCP套接字。</p><p id="d0bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">服务器启动后，它准备好满足组件呈现请求。协议非常简单。该请求采用JSON的形式:</p><figure class="kl km kn ko fq kp"><div class="bz el l di"><div class="kq kr l"/></div></figure><p id="2e2b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">服务器期望请求以特殊的字节序列结束。默认情况下，这定义为:<strong class="it hv"> <em class="kh"> \r\n. </em> </strong></p><p id="451a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们现在可以用我们选择的语言编写一个客户端来连接到服务器。如果愿意，您可以自己编写这段代码，或者可以使用preact-rpc中包含的一个助手库。对于Go，包含了github.com/musawirali/preact-rpc/goclient<strong class="it hv">套餐</strong>。下面是我们的Go后端，它使用这个包连接到前面启动的RPC服务器:</p><figure class="kl km kn ko fq kp"><div class="bz el l di"><div class="kq kr l"/></div></figure><p id="34f8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">运行应用程序，查看我们简单的Hello组件呈现。</p></div><div class="ab cl ks kt hc ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hn ho hp hq hr"><p id="215f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在当前状态下，preact-rpc包是可用的，但仍然非常小。许多事情正在酝酿中，以充实该系统:</p><ul class=""><li id="fb61" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo kz jw jx jy dt translated">加载前端Javascript时，React组件生命周期从后端到前端的无缝连续性。</li><li id="b379" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo kz jw jx jy dt translated">支持Redux商店。</li><li id="f939" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo kz jw jx jy dt translated">为更多的语言/环境构建助手库。</li></ul><p id="1a63" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">希望这个项目对社区有帮助。欢迎投稿！</p><blockquote class="ke kf kg"><p id="ec7a" class="ir is kh it b iu iv iw ix iy iz ja jb ki jd je jf kj jh ji jj kk jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is kh it b iu iv iw ix iy iz ja jb ki jd je jf kj jh ji jj kk jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上给我们点赞/发消息</a>，或者简单地说，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is kh it b iu iv iw ix iy iz ja jb ki jd je jf kj jh ji jj kk jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kl km kn ko fq kp"><div class="bz el l di"><div class="la kr l"/></div></figure></div></div>    
</body>
</html>