<html>
<head>
<title>React + Webpack inside VSTS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">VSTS境内的React + Webpack</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/react-webpack-inside-vsts-d6b1853f1a82?source=collection_archive---------12-----------------------#2017-10-24">https://medium.com/hackernoon/react-webpack-inside-vsts-d6b1853f1a82?source=collection_archive---------12-----------------------#2017-10-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/dff030b2ea6e12ab860ad547a0de5929.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ra4MeZQnSitSDmcAQhT33A.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Continuous everything</figcaption></figure><p id="eeae" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">今天，几乎所有你参与的web项目都在使用node.js、npm和git，至少在构建过程中是这样。这是一个像带有npm脚本的webpack这样的工具比gulp或grunt更有优势的时刻。在VSTS，你仍然找不到使用webpack构建网络应用的模板。因此，这是一个方向上的帮助，我们将看到在VSTS用webpack进行建设是非常简单的。</p><p id="10fc" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们还将解决使用react-router时历史模块的一个常见问题:<em class="ke">无法解析模块' react-router/node _ modules/history/lib/createBrowserHistory '导入/no-unresolved的路径。</em></p><h2 id="4a21" class="kf kg hu bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz dt translated">在VSTS上设置构件</h2><p id="cf03" class="pw-post-body-paragraph jg jh hu ji b jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd hn dt translated">我们将假设你已经有一个React应用程序，并且你正在通过g it将它推送到VSTS。你用webpack构建它，它可以在你的计算机上成功运行。现在是时候在VSTS内部创建一个构建定义了，这也将帮助你在Azure应用服务上部署你的应用。</p><h2 id="50f6" class="kf kg hu bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz dt translated">第一步</h2><p id="cabb" class="pw-post-body-paragraph jg jh hu ji b jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd hn dt translated">我们将使用Gulp模板，因为它已经配置了几个步骤，所以我们获得了一些点击。</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lf"><img src="../Images/17ea8f682e33c726ec74dcea52a04ed6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7_tPqcFRzryKNwX89dsBCg.png"/></div></div></figure><h2 id="7f89" class="kf kg hu bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz dt translated">第二步</h2><p id="b4ef" class="pw-post-body-paragraph jg jh hu ji b jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd hn dt translated">之后，我们将删除吞咽步骤，并添加npm运行构建步骤。我们可以通过添加新任务&gt;包选项卡&gt;并选择npm简单任务来完成此操作。新步骤应该如下配置，只需运行自定义命令“运行构建”:</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ls"><img src="../Images/71e95cdd0debf496541f7d87bdd3c4a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iFw_0gqInTeok7vw9bGotA.png"/></div></div></figure><h2 id="f5e0" class="kf kg hu bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz dt translated">第三步</h2><figure class="lg lh li lj fq iv fe ff paragraph-image"><div class="fe ff lt"><img src="../Images/0c09215467a7536240b1be900a5b177b.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*WR4C0UGY7CF_U818DZi2XQ.png"/></div></figure><p id="6eb5" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">当我们运行“npm运行构建”时，webpack将创建一个名为“<em class="ke"> dist </em>的文件夹，这就是我们的生产文件所在的位置。</p><p id="1afb" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">最后一步是修改归档文件步骤，以便归档文件夹<em class="ke"> dist，</em>，如图所示。</p><h1 id="2356" class="lu kg hu bd kh lv lw lx kl ly lz ma kp mb mc md ks me mf mg kv mh mi mj ky mk dt translated">修复反应路由器错误</h1><p id="66ea" class="pw-post-body-paragraph jg jh hu ji b jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd hn dt translated">现在我们已经准备好对我们的第一个构建进行排队了。这在大多数情况下应该是成功的。</p><p id="5ee0" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">但是在我的应用程序中，因为我使用了react-router包，所以我得到了下面的错误:<em class="ke">无法解析模块' react-router/node _ modules/history/lib/createBrowserHistory ' import/no-resolved的路径。</em></p><p id="428d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在调查错误后，我发现这个历史包确实有一些特殊的请求，react-router依赖于历史版本3.x来工作，当你安装了新版本时，它会失败。错误本身并没有说明这一点，它实际上给出了一个指示，即应该作为react-router的一个模块安装的历史包丢失了。包react-router的文件夹中没有node_modules。在我们的本地版本中，它创建时没有任何问题，但是在VSTS版本中，由于某些原因，它无法安装。</p><h2 id="f48b" class="kf kg hu bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz dt translated">步骤4(可选)</h2><p id="8c69" class="pw-post-body-paragraph jg jh hu ji b jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd hn dt translated">唯一修复构建的方法是在npm安装之后添加一个额外的步骤，为react-router包单独调用<em class="ke"> npm install </em>。所以这看起来像下面这样</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ml"><img src="../Images/dbc28f402e0f660f685f13caf1771127.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-FPuVkLy74anCW4Fq3O2Vw.png"/></div></div></figure><p id="e33f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">就这样，享受你的VSTS CI建设。</p></div></div>    
</body>
</html>