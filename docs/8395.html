<html>
<head>
<title>The Wormhole Route to Android Coding Using Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kotlin实现Android编码的虫洞路线</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-wormhole-route-to-android-coding-using-kotlin-33eea6626ea?source=collection_archive---------15-----------------------#2017-11-30">https://medium.com/hackernoon/the-wormhole-route-to-android-coding-using-kotlin-33eea6626ea?source=collection_archive---------15-----------------------#2017-11-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="032f" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">将您的Android开发置于Nitro模式</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/080b7349aa95294c0ad2e810496e56c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZdALV8Xst_B2mvGicYgZkw.jpeg"/></div></div></figure><p id="76d1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">当<a class="ae kr" href="http://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx hv"> Kotlin </strong> </a>在<a class="ae kr" href="https://www.youtube.com/watch?v=X1RVYt2QKQE" rel="noopener ugc nofollow" target="_blank">今年的Google I/O </a>上被宣布为Android的一级语言时，我把深入研究这种语言作为我的首要任务。虽然我很久以前就从我的一个朋友那里听说过Kotlin，他也是一个Android爱好者，但直到现在，我才真正为我的项目学习和使用这种语言。</p><p id="7dfb" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">科特林语作为一种语言是美丽的。它简洁、强大，学习曲线非常平坦。一旦你开始习惯这种语言，就没有回头路了。没有不尊重Java的意思，但是我想我不会再为Android使用Java了。</p><p id="a102" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">然而，一个工具的强大取决于你如何使用它。如果你不打算利用语言中隐藏的宝石，那么你最好不要使用它。由于我一直在探索这种语言，Kotlin如何加快Android应用程序开发的一些方面引起了我的注意，我将与你分享它们，以便你可以在6 之前从办公室乘坐虫洞<em class="ks">回家。</em></p><h1 id="7001" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">1.应用Android扩展插件</h1><p id="999e" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">你能做的第一件事是去掉所有那些难看的<strong class="jx hv"> findViewById() </strong>调用，或者任何你用来把你的视图注入到你的活动或者片段或者其他视图的框架。</p><p id="71a0" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">JetBrains在<a class="ae kr" href="https://kotlinlang.org/docs/tutorials/android-plugin.html" rel="noopener ugc nofollow" target="_blank">中捆绑了一个Android扩展插件</a>和它的Kotlin插件，可以让你访问你的<strong class="jx hv">活动</strong>、<strong class="jx hv">片段</strong>或<strong class="jx hv">视图</strong>中的视图，就好像它只是一个预定义的属性一样。迷茫？等着看例子吧。</p><p id="ab0f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">首先，您需要将这一行添加到应用程序的build.gradle中。</p><pre class="jk jl jm jn fq lq lr ls lt aw lu dt"><span id="5e81" class="lv ku hu lr b fv lw lx l ly lz">apply plugin: 'kotlin-android-extensions'</span></pre><p id="b428" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在你的项目应该可以利用Kotlin的Android扩展插件了。</p><h2 id="9d6b" class="lv ku hu bd kv ma mb mc kz md me mf ld ke mg mh lf ki mi mj lh km mk ml lj mm dt translated">怎么用？</h2><p id="d7ea" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">非常简单。没有什么需要设置的。不需要初始化。只需使用在XML布局中声明的id来引用活动或片段或视图中的视图。</p><p id="ee77" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">所以，假设你已经用XML声明了你的视图，</p><pre class="jk jl jm jn fq lq lr ls lt aw lu dt"><span id="c3cc" class="lv ku hu lr b fv lw lx l ly lz">&lt;android.support.v7.widget.RecyclerView<br/>    android:<strong class="lr hv">id</strong>="@+id/recyclerView"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="wrap_content"/&gt;</span></pre><p id="9df4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">然后，您可以在您的活动或片段或视图中访问您的RecyclerView，以这种方式，</p><pre class="jk jl jm jn fq lq lr ls lt aw lu dt"><span id="57e4" class="lv ku hu lr b fv lw lx l ly lz">recyclerView.adapter = adapter</span></pre><p id="946a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">就是这样。您不需要从XML中显式解析视图，也不需要做任何其他的事情。没有findViewById()。没有黄油刀。您的视图已经可以在您的Kotlin代码中引用和使用了。</p><p id="d2d7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">但是，如果您的Kotlin类不是活动、片段或视图，这将无法工作，因为该类没有任何附加的布局来遍历和定位您的视图。但这并不妨碍它施展魅力。如果您有一个展开的视图，那么您可以使用这种方法访问它的子视图，</p><pre class="jk jl jm jn fq lq lr ls lt aw lu dt"><span id="4f56" class="lv ku hu lr b fv lw lx l ly lz">view.textView.text = "Hello"<br/>view.buttonSubmit.setOnClickListener {<br/>    println("Button Clicked!")<br/>}</span></pre><p id="7f8a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这种方法在像访问RecyclerView的视图容器中的视图这样的情况下很有用，在这种情况下，您需要像这样访问您的视图，</p><pre class="jk jl jm jn fq lq lr ls lt aw lu dt"><span id="39ec" class="lv ku hu lr b fv lw lx l ly lz"><strong class="lr hv">class</strong> <strong class="lr hv">ViewHolder</strong>(itemView: View) : RecyclerView.ViewHolder(itemView) {<br/>    <strong class="lr hv">fun</strong> bindData(newsModel: <strong class="lr hv">NewsModel</strong>) {<br/>        with(newsModel) {<br/>            itemView.heading_news.text = heading<br/>        }<br/>    }<br/>}</span></pre><p id="03e4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">注意，在上面的代码片段中，我们通过使用父元素itemView的引用来引用每个row元素中的视图。有了它，您可以绑定项目中的几乎所有视图，甚至不需要编写额外的代码来完成所有的仪式。findViewById()去年就是如此。</p><h2 id="7148" class="lv ku hu bd kv ma mb mc kz md me mf ld ke mg mh lf ki mi mj lh km mk ml lj mm dt translated">你需要知道的是</h2><p id="7516" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">Android Studio无缝地完成了导入类的所有繁重工作，因此您永远不用担心自己编写导入语句。然而，<strong class="jx hv">如果IDE不能</strong>做到这一点，您需要在任何使用扩展直接访问视图的地方添加这个import语句，</p><pre class="jk jl jm jn fq lq lr ls lt aw lu dt"><span id="f6ad" class="lv ku hu lr b fv lw lx l ly lz"><strong class="lr hv">import</strong> <strong class="lr hv">kotlinx</strong>.android.synthetic.main.your-layout.*</span></pre><p id="9b6f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">对于后一种情况，即访问既不是活动也不是片段或视图的类中的视图，您需要添加一点点更多的信息，</p><pre class="jk jl jm jn fq lq lr ls lt aw lu dt"><span id="9e36" class="lv ku hu lr b fv lw lx l ly lz"><strong class="lr hv">import</strong> <strong class="lr hv">kotlinx</strong>.android.synthetic.main.your-layout.view.*</span></pre><p id="0988" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这应该足够完成这项工作了。</p><h1 id="8337" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">2.从安科那里获得帮助</h1><p id="697c" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">JetBrains，Kotlin背后的家伙发布了<a class="ae kr" href="https://github.com/Kotlin/anko" rel="noopener ugc nofollow" target="_blank">一个名为<strong class="jx hv">Anko</strong>T5】的库，这是另一个获得开发完成捷径的工具。它包括许多功能和方法，通过为我们在Android应用程序中做的一些非常常见的事情编写紧凑而美丽的代码，帮助您减少开发时间，同时获得快乐。</a></p><p id="16da" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">首先，您需要向build.gradle中添加一个依赖项，</p><pre class="jk jl jm jn fq lq lr ls lt aw lu dt"><span id="06de" class="lv ku hu lr b fv lw lx l ly lz">dependencies {<br/>    compile "org.jetbrains.anko:anko:0.10.1"<br/>}</span></pre><p id="3ac1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在您执行了Gradle Sync之后，您应该准备好在您的项目中利用Anko的强大功能。</p><p id="bfea" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Anko由几个部分组成，涵盖了项目中的各种用例，</p><ul class=""><li id="26a4" class="mn mo hu jx b jy jz kb kc ke mp ki mq km mr kq ms mt mu mv dt translated"><strong class="jx hv"> Anko Commons </strong> —用于启动<em class="ks">意图</em>，显示<em class="ks">对话框</em>等</li><li id="7ca8" class="mn mo hu jx b jy mw kb mx ke my ki mz km na kq ms mt mu mv dt translated"><strong class="jx hv"> Anko布局</strong> ( <a class="ae kr" href="https://github.com/Kotlin/anko/wiki/Anko-Layouts" rel="noopener ugc nofollow" target="_blank"> wiki </a> ) —编写没有任何XML的动态布局</li><li id="84ea" class="mn mo hu jx b jy mw kb mx ke my ki mz km na kq ms mt mu mv dt translated"><strong class="jx hv">Anko SQLite</strong>(<a class="ae kr" href="https://github.com/Kotlin/anko/wiki/Anko-SQLite" rel="noopener ugc nofollow" target="_blank">wiki</a>)—<em class="ks">Android的SQLite </em>的简化用法</li><li id="b734" class="mn mo hu jx b jy mw kb mx ke my ki mz km na kq ms mt mu mv dt translated"><strong class="jx hv"> Anko协同程序</strong> ( <a class="ae kr" href="https://github.com/Kotlin/anko/wiki/Anko-Coroutines" rel="noopener ugc nofollow" target="_blank"> wiki </a> ) —科特林<em class="ks">协同程序</em>的助手</li></ul><p id="8593" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">为了简洁起见，在本文中我将只讨论Anko Commons的用法。让我们深入研究一下。</p><p id="cf53" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Anko Commons提供了更简单紧凑的代码来执行任何Android应用程序中最常见的功能。一些使用案例是，</p><h2 id="b481" class="lv ku hu bd kv ma mb mc kz md me mf ld ke mg mh lf ki mi mj lh km mk ml lj mm dt translated">发起一个意图</h2><p id="25b7" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">启动一个意图可能是Android应用程序中从一个屏幕导航到另一个屏幕最常见的方面。然而，这需要执行许多仪式，尤其是在将数据从一个活动传递到另一个活动时。</p><p id="efe1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">例如，如果我们想从<strong class="jx hv"> MainActivity </strong>中启动一个<strong class="jx hv"> UserDetailsActivity </strong>，并传递一些用户数据，使该活动成为一个<a class="ae kr" href="https://inthecheesefactory.com/blog/understand-android-activity-launchmode/en" rel="noopener ugc nofollow" target="_blank"><strong class="jx hv">singleTop</strong>activity</a>，那么就有很多东西要写，</p><pre class="jk jl jm jn fq lq lr ls lt aw lu dt"><span id="8824" class="lv ku hu lr b fv lw lx l ly lz"><strong class="lr hv">val</strong> userActivity = Intent(<strong class="lr hv">this</strong>, UserDetailsActivity::<strong class="lr hv">class</strong>.<strong class="lr hv">java</strong>)<br/>userActivity.putExtra("id", 1)<br/>userActivity.putExtra("name", "Rahul")<br/>userActivity.flags = Intent.FLAG_ACTIVITY_SINGLE_TOP<br/>startActivity(userActivity)</span></pre><p id="e6d6" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这是一个简单任务的5行代码。有了Anko，您可以将其归结为一行代码，就像这样，</p><pre class="jk jl jm jn fq lq lr ls lt aw lu dt"><span id="565c" class="lv ku hu lr b fv lw lx l ly lz">startActivity(intentFor&lt;UserDetailsActivity&gt;("id" to 1, "name" to "Rahul").singleTop())</span></pre><p id="2c1f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">很简单。有意义。不会再伤害你的手指了。</p><h2 id="162f" class="lv ku hu bd kv ma mb mc kz md me mf ld ke mg mh lf ki mi mj lh km mk ml lj mm dt translated">显示信息</h2><p id="571c" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">向应用程序的用户显示消息的两种最常见的方式是显示一个祝酒词或一个对话框。安科给他们俩注射了一些有益血清。</p><p id="71aa" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">展示一个<strong class="jx hv">祝酒词</strong>就像，</p><pre class="jk jl jm jn fq lq lr ls lt aw lu dt"><span id="09ea" class="lv ku hu lr b fv lw lx l ly lz"><em class="ks">//Normal toast using a hardcoded string</em><br/>toast("Hi there!")<br/><em class="ks">//Normal toast using a string resource</em><br/>toast(R.string.welcome)<br/><em class="ks">//Long toast</em><br/>longToast("Wow, such a duration")</span></pre><p id="8319" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">写完祝酒辞后，不要忘记调用show()函数。</p><p id="fa9a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">对话框也很简单，</p><pre class="jk jl jm jn fq lq lr ls lt aw lu dt"><span id="4f5f" class="lv ku hu lr b fv lw lx l ly lz">alert(Appcompat, "Hi, I'm Rahul", "Do we know each other?") {<br/>    yesButton { toast("Oh…") }<br/>    noButton {}<br/>}.show()</span></pre><p id="1cb8" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">嗯，这不难写。注意，这里指定Appcompat是为了告诉Anko呈现对话框的AppCompat版本。如果您不希望这样，可以跳过该参数。</p><p id="8946" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">你可以在这里获得对Anko Commons wiki的全面概述。</p><h2 id="3505" class="lv ku hu bd kv ma mb mc kz md me mf ld ke mg mh lf ki mi mj lh km mk ml lj mm dt translated">需要知道的事情</h2><p id="ad9e" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">由于Anko是由Commons、Layouts、SQLite和Coroutines等几个部分组成的总包，所以我们添加的普通包会显著增加应用程序的大小和功能数量。这是一个很好的做法，只包括必要的模块，省略其余的，以保持你的APK苗条。</p><p id="c7d2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">您可以用这种方式添加独立的依赖项，无论您的项目需要哪个模块，</p><pre class="jk jl jm jn fq lq lr ls lt aw lu dt"><span id="2eab" class="lv ku hu lr b fv lw lx l ly lz">dependencies {<br/>    <em class="ks">// Anko Commons</em><br/>    compile "org.jetbrains.anko:anko-commons:0.10.1"</span><span id="6d06" class="lv ku hu lr b fv nb lx l ly lz">    <em class="ks">// Anko Layouts</em><br/>    compile "org.jetbrains.anko:anko-sdk25:0.10.1"<br/>    compile "org.jetbrains.anko:anko-appcompat-v7:0.10.1"</span><span id="f746" class="lv ku hu lr b fv nb lx l ly lz">    <em class="ks">// Coroutine listeners for Anko Layouts</em><br/>    compile "org.jetbrains.anko:anko-sdk25-coroutines:0.10.1"<br/>    compile "org.jetbrains.anko:anko-appcompat-v7-couroutines:0.10.1"</span><span id="da6c" class="lv ku hu lr b fv nb lx l ly lz">    <em class="ks">// Anko SQLite</em><br/>    compile "org.jetbrains.anko:anko-sqlite:0.10.1"<br/>}</span></pre><h1 id="e44b" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">3.写扩展函数</h1><p id="b1d3" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">Kotlin最大的优点之一是能够编写扩展函数和属性。考虑到一些Android API是多么糟糕，这对所有Android应用程序开发者来说都是一个福音。如果我的话对您没有任何意义，请不要惊慌，您马上就会明白，但是在深入研究如何用Kotlin编写扩展函数之前，让我们先简单介绍一下它们是什么。</p><h2 id="3add" class="lv ku hu bd kv ma mb mc kz md me mf ld ke mg mh lf ki mi mj lh km mk ml lj mm dt translated">什么是扩展函数？</h2><p id="60d8" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">Kotlin为开发人员提供了向项目或平台(<em class="ks">即SDK </em>)类添加功能的能力，而无需以任何常规方式实际扩展或修改该类。</p><p id="dd51" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">让我们用一个例子来说明，假设我们有一个这样的Kotlin类，</p><pre class="jk jl jm jn fq lq lr ls lt aw lu dt"><span id="6b4b" class="lv ku hu lr b fv lw lx l ly lz"><strong class="lr hv">class</strong> <strong class="lr hv">StandardClass</strong> {<br/>    <strong class="lr hv">fun</strong> doSomething() {<br/>        <em class="ks">//Do something here</em><br/>        println("Maybe print something")<br/>    }<br/>}</span></pre><p id="3c34" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们现在可以给这个类注入一个函数，它的行为就像类中的一个常规函数，并且可以访问类中所有的<strong class="jx hv">属性</strong>和<strong class="jx hv">函数</strong>，甚至不用扩展它。怎么会？这是怎么回事。</p><pre class="jk jl jm jn fq lq lr ls lt aw lu dt"><span id="dd40" class="lv ku hu lr b fv lw lx l ly lz"><strong class="lr hv">fun</strong> StandardClass.doSomethingMore() {<br/>    <em class="ks">//Do something more here</em><br/>    println("Maybe print something new and extra")<br/>}</span></pre><p id="202f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">仅此而已，请注意，这个函数可以在任何地方定义，甚至可以作为<strong class="jx hv">正则函数中的顶级函数。kt文件</strong>。定义这种扩展函数的语法或结构如下，</p><pre class="jk jl jm jn fq lq lr ls lt aw lu dt"><span id="26ff" class="lv ku hu lr b fv lw lx l ly lz"><strong class="lr hv">fun</strong> receiver-<strong class="lr hv">class</strong>-name.function-name() {<br/>    <em class="ks">//Body of the function goes here</em><br/>}</span></pre><h2 id="6fbe" class="lv ku hu bd kv ma mb mc kz md me mf ld ke mg mh lf ki mi mj lh km mk ml lj mm dt translated">这有什么帮助？</h2><p id="7b67" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">嗯，所有这些看起来都很花哨，但是当涉及到Android应用程序开发时，这些时髦的功能实际上在哪里派上用场呢？答案很简单。它是一个标准的实用程序类，提供了一个全新的维度，能够为平台API添加缺失的实用程序。</p><p id="e041" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">以这种情况为例。膨胀一个视图并将其添加到一个<strong class="jx hv">视图组</strong>是一项繁琐的任务。首先，你需要一个像这样的<strong class="jx hv">充气机</strong>，</p><pre class="jk jl jm jn fq lq lr ls lt aw lu dt"><span id="e6ff" class="lv ku hu lr b fv lw lx l ly lz">val inflater = LayoutInflater.from(context)</span></pre><p id="34fb" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">然后，您必须展开布局并将其添加到父视图组，如下所示，</p><pre class="jk jl jm jn fq lq lr ls lt aw lu dt"><span id="2d01" class="lv ku hu lr b fv lw lx l ly lz"><strong class="lr hv">inflater</strong>.inflate(<strong class="lr hv">R</strong>.layout.view_layout, <strong class="lr hv">parent</strong>, <strong class="lr hv">true</strong>)</span></pre><p id="f1c8" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">每次你需要展开一个布局时，你都必须这样做，这在Android项目中经常发生。那么我们如何让它变得更好呢？我们为它创建了一个扩展函数。</p><pre class="jk jl jm jn fq lq lr ls lt aw lu dt"><span id="f047" class="lv ku hu lr b fv lw lx l ly lz"><strong class="lr hv">fun</strong> ViewGroup.inflate(layoutId: <strong class="lr hv">Int</strong>, attachToRoot: <strong class="lr hv">Boolean</strong> = false): View {<br/>    <strong class="lr hv">return</strong> LayoutInflater.from(context).inflate(layoutId, <strong class="lr hv">this</strong>, attachToRoot)<br/>}</span></pre><p id="bf46" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在，您可以通过对整个项目中的任何ViewGroup对象调用inflate()函数来扩展任何布局，如下所示:</p><pre class="jk jl jm jn fq lq lr ls lt aw lu dt"><span id="e79a" class="lv ku hu lr b fv lw lx l ly lz"><strong class="lr hv">view</strong>.inflate(<strong class="lr hv">R</strong>.layout.view_layout)</span></pre><p id="0fa4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在上面的函数定义中需要注意的一点是，我们没有将上下文作为参数，但是仍然能够解析和使用它。这是因为我们向类ViewGroup添加了一个扩展函数，现在我们可以访问函数块中的所有属性和函数。Context是类中定义的属性之一，我们可以使用它，而不需要任何额外的努力来检索它。</p><p id="a70f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">还不信服？这是另一个改变你想法的例子，</p><pre class="jk jl jm jn fq lq lr ls lt aw lu dt"><span id="1d1a" class="lv ku hu lr b fv lw lx l ly lz"><strong class="lr hv">fun</strong> SharedPreferences.save(function: <strong class="lr hv">SharedPreferences</strong>.<strong class="lr hv">Editor</strong>.() -&gt; Unit) {<br/>    <strong class="lr hv">val</strong> editor = edit()<br/>    editor.function()<br/>    editor.apply()<br/>}</span></pre><p id="6a7a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这个函数的作用是扩展Android中的<strong class="jx hv"> SharedPreferences </strong>类，以便轻松地将数据保存在首选项中，而无需执行所有的仪式，例如获取<strong class="jx hv"> SharedPreferences。编辑preferences对象中的</strong>对象，并记住在输入所有数据后调用<strong class="jx hv"> apply() </strong>或<strong class="jx hv"> commit() </strong>。</p><p id="4544" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">使用这个函数非常简单，</p><pre class="jk jl jm jn fq lq lr ls lt aw lu dt"><span id="8e31" class="lv ku hu lr b fv lw lx l ly lz"><strong class="lr hv">val</strong> sharedPref = PreferenceManager.getDefaultSharedPreferences(applicationContext)<br/>sharedPref.save {<br/>    putString("name", "Rahul")<br/>    putBoolean("isLoggedIn", true)<br/>}</span></pre><p id="6471" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这只是将一些数据保存到应用程序的共享首选项中。</p><p id="07ea" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">尽管最初可能需要一些时间来设置所有的扩展函数，但是一旦你完成了，你的生产力将会有一个飞跃，你将能够更快地编写代码。最好的事？您可以跨项目共享您的扩展功能，并根据需要重用它们。</p><p id="8c05" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">有了扩展功能，你可以延长你做生活中其他事情的时间。</p><h1 id="689c" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">4.让数据类为您服务</h1><p id="3566" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">科特林引入了<a class="ae kr" href="https://kotlinlang.org/docs/reference/data-classes.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jx hv">数据类</strong> </a>来简化模型类的创建和维护。仅仅为了创建一个模型类就需要编写大量样板代码的日子已经一去不复返了。</p><p id="a9c9" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">谷歌试图用<a class="ae kr" href="https://github.com/google/auto/tree/master/value" rel="noopener ugc nofollow" target="_blank"> <strong class="jx hv"> AutoValue </strong> </a>来解决这个问题。其他人试图通过为IDE创建插件来为您生成所有代码来解决这个问题，但是将这个特性内置在语言中是一种享受。没有要包含的内容。没有要安装的第三方插件。</p><h2 id="0f44" class="lv ku hu bd kv ma mb mc kz md me mf ld ke mg mh lf ki mi mj lh km mk ml lj mm dt translated">有什么特别的？</h2><p id="39f6" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">Kotlin数据类自动为您生成以下内容，让您的代码保持整洁，让您的手指放松</p><ul class=""><li id="81b6" class="mn mo hu jx b jy jz kb kc ke mp ki mq km mr kq ms mt mu mv dt translated"><strong class="jx hv"> equals() </strong>和<strong class="jx hv"> hashCode() </strong>函数用于模型比较</li><li id="8ef3" class="mn mo hu jx b jy mw kb mx ke my ki mz km na kq ms mt mu mv dt translated">格式化的<strong class="jx hv"> toString() </strong>函数，以可读的方式输出内容</li><li id="ac97" class="mn mo hu jx b jy mw kb mx ke my ki mz km na kq ms mt mu mv dt translated"><strong class="jx hv"> componentN() </strong>用于访问类中属性的函数</li><li id="a8d7" class="mn mo hu jx b jy mw kb mx ke my ki mz km na kq ms mt mu mv dt translated"><a class="ae kr" href="https://kotlinlang.org/docs/reference/data-classes.html#copying" rel="noopener ugc nofollow" target="_blank"> <strong class="jx hv"> copy() </strong> </a>函数可以轻松地将属性从一个对象复制到另一个对象</li></ul><p id="1179" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">所有这些都是在隐藏模式下生成的，这意味着在Kotlin代码中看不到这些函数，从而保持了数据类的简洁明了。</p><h2 id="ce40" class="lv ku hu bd kv ma mb mc kz md me mf ld ke mg mh lf ki mi mj lh km mk ml lj mm dt translated">如何将类声明为数据类？</h2><p id="6c1c" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">只需在你的类定义前添加关键字<strong class="jx hv">数据</strong>。这里没什么可做的了。例如，您可以像这样定义一个<strong class="jx hv">用户模型</strong>类，</p><pre class="jk jl jm jn fq lq lr ls lt aw lu dt"><span id="79d1" class="lv ku hu lr b fv lw lx l ly lz"><strong class="lr hv">data</strong> <strong class="lr hv">class</strong> <strong class="lr hv">UserModel</strong>(<strong class="lr hv">val</strong> name: String, <strong class="lr hv">val</strong> age: Int, <strong class="lr hv">var</strong> isOnline: Boolean)</span></pre><p id="32cb" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">是的，你可以在一行中定义一个完整的模型类。这再简单不过了。</p><p id="c890" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">最好的部分是，如果我们想向用户模型引入一个新的属性，只需更改几个字符。让我们添加一个属性来保存用户的出生日期。</p><pre class="jk jl jm jn fq lq lr ls lt aw lu dt"><span id="679e" class="lv ku hu lr b fv lw lx l ly lz"><strong class="lr hv">data</strong> <strong class="lr hv">class</strong> <strong class="lr hv">UserModel</strong>(<strong class="lr hv">val</strong> name: String, <strong class="lr hv">val</strong> age: Int, <strong class="lr hv">var</strong> isOnline: Boolean, <strong class="lr hv">val</strong> dateOfBirth: Date)</span></pre><p id="fb72" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">就是这样。我刚刚在主构造函数定义中添加了一个新属性。科特林会处理剩下的。不再添加新的getter和setter或更新toString()方法。</p><h2 id="f2e4" class="lv ku hu bd kv ma mb mc kz md me mf ld ke mg mh lf ki mi mj lh km mk ml lj mm dt translated">在常规Android应用中的使用</h2><p id="d841" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">几乎每个Android应用程序都在一个模型中保存数据。无论是用户数据还是其他数据。考虑一个应用程序，它使用<a class="ae kr" href="http://square.github.io/retrofit/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx hv">改进</strong> </a>连接到后端API，并将响应存储在这样定义的模型类中，</p><pre class="jk jl jm jn fq lq lr ls lt aw lu dt"><span id="f427" class="lv ku hu lr b fv lw lx l ly lz"><strong class="lr hv">data</strong> <strong class="lr hv">class</strong> <strong class="lr hv">UserApiResponse</strong>(<strong class="lr hv">@SerializedName("user_name")</strong> <strong class="lr hv">var</strong>   userName: String,<br/>                           <strong class="lr hv">@SerializedName("age")</strong> <strong class="lr hv">var</strong> age: Int)</span></pre><p id="737c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">认为模型一旦定义就不会改变是天真的。它可以而且将会改变(这里<em class="ks">不是试图通过应用墨菲定律看起来很酷</em>)。</p><p id="20b4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">无论您的应用程序是本地的还是连接到后端API来获取数据，您的本地数据库模式或API响应格式都非常容易发生变化。</p><p id="f4b2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">当它确实改变时会发生什么？您沿着项目结构走一趟，找到模型类并进行必要的更改。</p><p id="5366" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果这是更新模型类的老派方法，您将不得不花费一两分钟或无聊的任务来添加字段，创建getters和setters，并更新toString()函数。</p><p id="0dc9" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">谢天谢地，我们不再做那种体力劳动了，记得吗？科特林会帮我们处理好一切。<em class="ks">节省的时间</em>。</p></div><div class="ab cl nc nd hc ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="hn ho hp hq hr"><p id="1256" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Android应用程序开发是一项耗时的工作。科特林的使命是让它成为一次愉快的经历，并在前进的道路上加速这一过程。确保你使用尽可能多的技巧来充分利用这种新语言。</p><p id="3574" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">下次再见，在另一个教程或常识讲座中。分享这篇文章，如果你喜欢它。</p><h2 id="9997" class="lv ku hu bd kv ma mb mc kz md me mf ld ke mg mh lf ki mi mj lh km mk ml lj mm dt translated">鼓掌。鼓掌。鼓掌。帮助我有动力为你写更多的东西。</h2></div></div>    
</body>
</html>