<html>
<head>
<title>What caused the accidental killing of the Parity multisig wallet &amp; how to detect similar bugs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">是什么导致了奇偶校验multisig钱包的意外死亡&amp;如何检测类似的错误</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/what-caused-the-latest-100-million-ethereum-bug-and-a-detection-tool-for-similar-bugs-7b80f8ab7279?source=collection_archive---------9-----------------------#2017-11-08">https://medium.com/hackernoon/what-caused-the-latest-100-million-ethereum-bug-and-a-detection-tool-for-similar-bugs-7b80f8ab7279?source=collection_archive---------9-----------------------#2017-11-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="f8cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp"/><a class="ae jq" href="https://mythx.io" rel="noopener ugc nofollow" target="_blank"><em class="jp">MythX</em></a><em class="jp">的创造者伯恩哈德·穆勒(Bernhard Mueller)展示了如何检测以太坊智能合约中的漏洞。</em></p><p id="35cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">11月6日，一名玩奇偶校验multisig钱包库合同的用户<a class="ae jq" href="https://github.com/paritytech/parity/issues/6995" rel="noopener ugc nofollow" target="_blank">“意外”触发了其kill()函数</a>，有效冻结了所有与库的代码相关联的奇偶校验multisig钱包上的资金。根据早期的估计，这可能会使价值超过1亿美元的以太网无法使用(更新:同时，这个数字已经上升到2.8亿美元)。</p><p id="04e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">碰巧的是，就在几周前，我写了关于使用符号分析检测无保护自杀指令的文章。最新的奇偶校验事故是由该漏洞的一个实例引起的。在这篇博客文章中，我将检查在最近的攻击中发生了什么，并介绍一个新的<a class="ae jq" href="https://github.com/ConsenSys/mythril-classic" rel="noopener ugc nofollow" target="_blank"> Mythril </a>分析模块，它可以用来检测Solidity代码和链上契约中的类似问题。</p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="fe ff jr"><img src="../Images/e35318e4e5d11407c6ab26ce14a16042.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AqNklmVHdflXU4aDbIAzAQ.png"/></div></div><figcaption class="kd ke fg fe ff kf kg bd b be z ek">Ethereum rendition by Shed Designs for <a class="kh ki gr" href="https://medium.com/u/6c0e21b7d1c2?source=post_page-----7b80f8ab7279--------------------------------" rel="noopener" target="_blank">EventChain.io</a></figcaption></figure><p id="9d5e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，让我们简单看看发生了什么。用户<a class="ae jq" href="https://github.com/devops199" rel="noopener ugc nofollow" target="_blank"> devops199 </a>(为了简单起见，我就称他为“攻击者”)只发送了两个事务就造成了大破坏。<a class="ae jq" href="https://etherscan.io/tx/0x05f71e1b2cb4f03e547739db15d080fd30c989eda04d37ce6264c5686e0722c9" rel="noopener ugc nofollow" target="_blank">第一个事务</a>调用<code class="eh kj kk kl km b">initWallet</code>函数将<code class="eh kj kk kl km b">owner</code>状态变量设置为devops199的地址。</p><pre class="js jt ju jv fq kn km ko kp aw kq dt"><span id="a49a" class="kr ks hu km b fv kt ku l kv kw">Function: initWallet(address[] _owners, uint256 _required, uint256 _daylimit)<br/>MethodID: 0xe46dcfeb<br/>[0]:0000000000000000000000000000000000000000000000000000000000000060<br/>[1]:0000000000000000000000000000000000000000000000000000000000000000<br/>[2]:0000000000000000000000000000000000000000000000000000000000000000<br/>[3]:0000000000000000000000000000000000000000000000000000000000000001<br/>[4]:000000000000000000000000ae7168deb525862f4fee37d987a971b385b96952</span></pre><p id="d4d1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可能想知道为什么这很容易。没有适当的检查来防止随机发送者给<code class="eh kj kk kl km b">initWallet</code>打电话吗？正如您在<a class="ae jq" href="https://etherscan.io/address/0x863df6bfa4469f3ead0be8f9f2aae51c91a907b4#code" rel="noopener ugc nofollow" target="_blank">源代码</a>中看到的，使用<code class="eh kj kk kl km b">only_uninitialized</code>修饰符来限制对该函数的访问:</p><pre class="js jt ju jv fq kn km ko kp aw kq dt"><span id="2d35" class="kr ks hu km b fv kt ku l kv kw">/ throw unless the contract is not yet initialized.<br/> modifier only_uninitialized { if (m_numOwners &gt; 0) throw; _; }<br/>// constructor — just pass on the owner array to the multiowned and<br/> // the limit to daylimit</span><span id="a599" class="kr ks hu km b fv kx ku l kv kw"> function initWallet(address[] _owners, uint _required, uint _daylimit) only_uninitialized</span></pre><p id="6274" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个修饰符允许钱包初始化一次。通常，当一个新的钱包被建立时，这个库函数在创建过程中被立即调用。</p><p id="0ba0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，<code class="eh kj kk kl km b">WalletLibrary</code>本身从来就不应该被用作<em class="jp">钱包</em>。它唯一的目的是通过<code class="eh kj kk kl km b">DELEGATECALL</code>为调用它的其他契约提供代码。因此，非常不幸的是，库契约实例本身<em class="jp"> </em>从未被初始化。这是开发人员的疏忽，部分原因是以太坊混乱的库/调用语义。这个主题在某种程度上应该有自己的博文，但是现在让我们把注意力集中在特定的攻击上。</p><p id="5292" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">作为合同所有者，攻击者现在调用第二个事务中的<code class="eh kj kk kl km b">kill</code>函数:</p><pre class="js jt ju jv fq kn km ko kp aw kq dt"><span id="9b55" class="kr ks hu km b fv kt ku l kv kw">Function: kill(address _to)<br/>MethodID: 0xcbf0b0c0<br/>[0]:000000000000000000000000ae7168deb525862f4fee37d987a971b385b96952</span></pre><p id="ba9b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这终止了图书馆合同，导致所有依赖于图书馆代码的钱包不可用。</p><h2 id="d9b7" class="kr ks hu bd ky kz la lb lc ld le lf lg jc lh li lj jg lk ll lm jk ln lo lp lq dt translated">检测Bug</h2><p id="c82e" class="pw-post-body-paragraph ir is hu it b iu lr iw ix iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo hn dt translated"><a class="ae jq" href="https://github.com/ConsenSys/mythril-classic" rel="noopener ugc nofollow" target="_blank"> Mythril的</a>“未检查的自杀”模块试图检测类似<code class="eh kj kk kl km b">WalletLibrary</code>中的暴露的kill函数。使用<code class="eh kj kk kl km b">-x</code>选项运行mythril时，该模块会自动执行。</p><p id="e1a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要进行测试，您可以对<a class="ae jq" href="https://github.com/b-mueller/mythril/blob/master/examples/walletlibrary.sol" rel="noopener ugc nofollow" target="_blank">平价钱包</a>进行分析。遗憾的是，Mythril的链上扫描特性不能在dead contract实例上使用，<code class="eh kj kk kl km b">WalletLibrary</code>代码只能用solc 4.10编译。让它工作的最好方法是首先在<a class="ae jq" href="https://remix.ethereum.org/#version=soljson-v0.4.10+commit.f0d539ae.js" rel="noopener ugc nofollow" target="_blank"> remix </a>中编译代码，然后用<code class="eh kj kk kl km b">-c</code>选项将运行时字节码传递给Mythril。您应该得到以下输出:</p><pre class="js jt ju jv fq kn km ko kp aw kq dt"><span id="bc4d" class="kr ks hu km b fv kt ku l kv kw">./myth -x -c "60606040(…)0029"<br/>=== Unchecked SUICIDE ===</span><span id="8725" class="kr ks hu km b fv kx ku l kv kw">Type: Warning</span><span id="71df" class="kr ks hu km b fv kx ku l kv kw">The function kill(address) executes the SUICIDE instruction.</span><span id="c9e8" class="kr ks hu km b fv kx ku l kv kw">The remaining Ether is sent to an address provided as a function argument.</span><span id="e0d1" class="kr ks hu km b fv kx ku l kv kw">There is a check on storage index keccac_1461501637330902918203684832716283019655932542975_&amp;_caller. This storage index can be written to by calling the function 'initMultiowned(address[],uint256)'.</span><span id="9bd4" class="kr ks hu km b fv kx ku l kv kw">There is a check on storage index 0. This storage index can be written to by calling the function 'initMultiowned(address[],uint256)'.</span><span id="c5a5" class="kr ks hu km b fv kx ku l kv kw">There is a check on storage index 1. This storage index can be written to by calling the function 'initMultiowned(address[],uint256)'.</span></pre><p id="e9e4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该算法的工作原理如下:</p><ul class=""><li id="61af" class="lw lx hu it b iu iv iy iz jc ly jg lz jk ma jo mb mc md me dt translated"><a class="ae jq" href="https://github.com/b-mueller/mythril/blob/master/mythril/analysis/symbolic.py" rel="noopener ugc nofollow" target="_blank">列出不受msg.sender约束的所有<code class="eh kj kk kl km b">SSTORE</code>指令的清单</a>(即任何人都可以调用)；</li><li id="60bb" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mb mc md me dt translated">寻找<code class="eh kj kk kl km b">SUICIDE</code>说明并检查每个说明的约束条件。</li><li id="51d3" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mb mc md me dt translated">如果找到的每个相关存储索引都有一个“污点”<code class="eh kj kk kl km b">SSTORE</code>，则尝试解决包含<code class="eh kj kk kl km b">SUICIDE</code>块的基本块上的约束，以确保它是可达的。</li></ul><p id="dc22" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个非常简单的检查，但足以检测像奇偶校验这样的小缺陷(尽管它不是防假阳性的)。</p><h1 id="987b" class="mk ks hu bd ky ml mm mn lc mo mp mq lg mr ms mt lj mu mv mw lm mx my mz lp na dt translated">关于Mythril和MythX</h1><p id="621b" class="pw-post-body-paragraph ir is hu it b iu lr iw ix iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo hn dt translated">Mythril是一款免费的开源智能合同安全分析器。它使用符号执行来检测各种安全漏洞。</p><p id="8a09" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jq" href="https://mythx.io" rel="noopener ugc nofollow" target="_blank"> MythX </a>是一个基于云的智能合约安全服务，它无缝集成到智能合约开发环境中并构建管道。它将多个领先的安全分析流程捆绑到一个易于使用的API中，允许任何人创建专门构建的智能合同安全工具。MythX兼容以太坊、Tron、Vechain、Quorum、Roostock和其他基于EVM的平台。</p></div></div>    
</body>
</html>