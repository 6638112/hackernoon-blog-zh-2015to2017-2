# 理解 JavaScript:闭包

> 原文：<https://medium.com/hackernoon/understanding-javascript-closures-4188edf5ea1b>

![](img/3ebe313ad4ed0458fbaaf97aa37aab47.png)

# 为什么要深入学习 JavaScript？

JavaScript 是当今最流行的编程语言之一。它运行在浏览器上，运行在服务器上，运行在移动设备上，桌面应用程序上，可能还有冰箱。即使我们把更奇特的例子拿掉，如果你正在处理任何类型的 web 开发，你将在某一点上编写或处理 JavaScript。

许多 web 开发人员声称他们了解 JavaScript，因为他们可以编写运行的代码。关于 JS 的事情是，你可以在一个月内开始编码，然后在你的余生中掌握这门语言。如果没有错误，也没有人抱怨，你为什么需要学习更多呢？

嗯，我是自称精通这门语言的人之一。几年前，我用 AngularJS 和 Node 编写了一个应用程序，我对自己的技能非常有信心。我相信我已经征服了 JS 语言。

因此，当一位面试官要求我解释什么是结束时，我发现自己惊呆了。我是说我知道那是什么。我知道这与回调有关，我那时一直在使用回调(我那时不知道承诺)，但不知何故，我找不到词语来解释它是什么以及它是如何工作的。

一次失败的 JavaScript 面试是我开发生涯中最谦卑、最有教育意义的经历。从那以后，我花了一年半多的时间在 JS 中达到更高的*Dan*，并决定是时候与世界分享它了。从一个最常见的 JavaScript 面试问题开始:

# **什么是结束？**

毫无疑问，您使用闭包已经有一段时间了，因为它们有各种各样的应用。每次为事件处理程序添加回调时，都使用了闭包的神奇属性。

我遇到过不同的一句话解释，但最让我感动的是凯尔·辛普森给出的解释:

> 闭包是当一个函数能够记住并访问它的词法范围时，即使这个函数在它的词法范围之外执行。

这个解释一开始可能有点让人不知所措，所以我们将一点一点地分解它，看看闭包到底是不是黑魔法。

在本文中，我们不会详细讨论作用域(关于这个主题会有一个单独的部分)，但是为了理解闭包是如何工作的，了解它是很重要的。作用域实际上是代码中包含某些变量和函数的部分。在 JavaScript 中，每个函数都创建一个新的作用域，它的变量和传递的参数只能在函数内部使用。

如果你在函数内部声明了一个变量，那么它在函数外部是不可用的。但是我们也可以在其他函数内部定义函数，这些函数内部有自己的作用域。这些嵌套函数的特别之处在于，它们可以访问父函数的变量。

老实说，这并不特别，因为在全局作用域中定义的每个函数都可以访问其中的变量，但是我在这里有所涉及。我们提到的那些嵌套函数可以访问它们的父函数的作用域，但是它们本身不能从父函数之外被调用。除非我们以某种方式揭露他们。

我们可以公开这个内部函数，这样它就可以在全局范围内使用。太好了！现在我们可以随心所欲地调用和使用它。但是让我们想象一下，这个公开的内部函数实际上引用了它的父作用域中的一个变量。那会有问题吗？不，当然不会，因为这是个了结！

# 闭包是暴露的嵌套函数

我不确定这是不是闭包的最佳定义，但是它很好地抓住了这个术语的本质。闭包是暴露的函数，即使我们从外部调用它们，它们也可以访问它们的父对象的范围。你明白我们之前提到的词法范围的解释了吗？

这里我们定义了一个接受单个参数`name`的`person`函数。它返回一个对象，该对象的属性之一是`greet`函数。正如我们现在所知，这个公开的`greet`函数仍然可以访问其父函数的参数，即使我们这样调用它。所以即使`name`变量没有在它的作用域中明确定义，它也会从它的父变量中获取，因为它是一个闭包。

不难理解，你可能已经无数次利用了这种行为。在我开始阅读闭包之前，我从来没有想到所有幕后的黑魔法，所以我可以实现封装和使用模块。

哇，哇…模块？封装？那些是突然出现的。

# 模块和用闭包封装

当我开始深入 JavaScript maelstrom 时，我学到的第一件事是，有许多复杂的发音单词有真正实用的解释。模块和封装是这些术语的完美例子。我们将使用相同的策略，从封装开始，分解每一个策略以彻底理解它。

封装是编程的基本原则之一。那些学习过 OOP 的人对这个概念很熟悉，但是对于那些不熟悉的人来说——这本质上是一种隐藏机制，它允许我们保留一些私有数据。通常我们不希望将函数的所有内容都暴露给全局范围，我们希望它的大部分保持私有且不可触及。

这就是闭包真正方便的地方。我们可以利用它们的能力来访问父作用域，即使它们在它之外被调用来实现正确的封装。我们可以在父函数中包含许多函数和变量，通过使用闭包，我们可以只向外界展示我们想要的功能。

> 使用闭包，我们可以为我们的函数定义一个公共 API，而将其他所有东西保持私有。

既然我们已经讨论了封装，我们只需要将它付诸实践。这个概念在 JavaScript 中的实现是使用模块模式完成的。

# 模块

在 ES6 中，我们有更好的基于文件的模块，我们可以使用导入和导出关键字，但重要的是要注意，它们只是我们将要看到的语法糖。

这是一个相当简单的例子，展示了我们如何保持一些函数数据的私有性。我们可以有其他嵌套函数，甚至可以在导出的函数中使用它们，但不公开它们。

在这个稍微现实一点的例子中，我们有一个返回 order 对象的函数。唯一暴露的函数是`calculateTotal`。它在 Order 函数上有一个闭包，这允许它使用自己的变量和传递的参数。它还隐藏了当您计算订单总数时实际发生的情况，允许您在将来添加运费或其他费用。

# 奇怪的部分

现在，JavaScript 有它奇怪的部分。事实上，它们中的一些是如此的怪异，以至于它们会导致严重的头痛和调试的不眠之夜。当我们没有正确使用闭包时，它们也没有什么不同。

下面的代码经常在 JavaScript 任务面试时给出，以猜测它的输出。

我们在这里所做的就是从 1 到 5 循环，并设置一个超时，在一定时间后打印当前的数字。常识上说这段代码会输出 1，2，3，4，5 对吧？

令我们惊讶的是，上面的代码在控制台中连续五次记录了数字`6`。如果在没有`setTimeout`的情况下执行这个循环，就不会有任何问题，因为日志会被立即执行。但是很明显，及时排队这个操作是导致这个缺陷的原因。

我们期望每一个`setTimeout`调用都会收到它自己的`i`变量的副本，但是发生的情况是它从它的父范围访问它。因为它们被排队，所以第一个日志将在排队 1 秒后出现。当这 1000 毫秒过去时，循环早已结束，`i`变量的值为 6。

我们理解这个问题，但是我们如何解决它呢？`setTimeout`会在全局范围内寻找`i`变量，导致它*不会*打印出我们想要的数字。我们可以通过将`setTimeout`包装在一个函数中并传递我们想要记录的变量来操纵它。这样,`setTimeout`函数将从它的父作用域而不是全局作用域访问它。

我们使用一个 IIFE(立即调用的函数表达式),并将数字传递到日志中。生命是一个函数，我们在定义它之后立即调用它，并且经常在这样的情况下使用——当我们想要创建一个作用域的时候。通过这种方式，每个函数都将使用它自己的变量副本来调用，这意味着当`setTimeout`运行时，它将访问正确的数字。因此，使用上面的例子，我们将得到我们正在寻找的结果 1，2，3，4 和 5。

# 结束语

这篇文章抓住了闭包的本质，但是还有更多东西要学习，还有更多边缘案例要思考。如果你想深入了解闭包黑魔法，我强烈推荐凯尔·辛普森关于范围闭包的书。

我希望这篇文章提高了您对 JavaScript 的理解，并帮助您更好地理解这个主题。你可以帮我按住拍手键，把文章分享给朋友！

如果你对更多的 JS 相关内容感兴趣，你可以从 [***这里***](https://buttondown.email/kondov) 订阅我的时事通讯，或者你可以看看同一系列的其他文章:

[](https://hackernoon.com/understanding-javascript-scope-1d4a74adcdf5) [## 理解 JavaScript:范围

### 由于数量惊人的库、工具和各种各样的东西使你的开发更容易，很多…

hackernoon.com](https://hackernoon.com/understanding-javascript-scope-1d4a74adcdf5) [](https://hackernoon.com/understanding-javascript-prototype-and-inheritance-d55a9a23bde2) [## 理解 JavaScript:原型和继承

### 由于数量惊人的库、工具和各种各样的东西使你的开发更容易，很多…

hackernoon.com](https://hackernoon.com/understanding-javascript-prototype-and-inheritance-d55a9a23bde2) [](https://hackernoon.com/understanding-javascript-the-this-keyword-4de325d77f68) [## 理解 JavaScript:这个关键字

### 由于数量惊人的库、工具和各种各样的东西使你的开发更容易，很多…

hackernoon.com](https://hackernoon.com/understanding-javascript-the-this-keyword-4de325d77f68) [](https://hackernoon.com/understanding-javascript-new-keyword-ec67c8caaa74) [## 理解 JavaScript:新关键字

### 由于数量惊人的库、工具和各种各样的东西使你的开发更容易，很多…

hackernoon.com](https://hackernoon.com/understanding-javascript-new-keyword-ec67c8caaa74) [](https://hackernoon.com/understanding-js-coercion-ff5684475bfc) [## 理解 JS:强制

### 由于数量惊人的库、工具和各种各样的东西使你的开发更容易，很多…

hackernoon.com](https://hackernoon.com/understanding-js-coercion-ff5684475bfc) [](https://hackernoon.com/understanding-js-the-event-loop-959beae3ac40) [## 理解 JS:事件循环

### 由于数量惊人的库、工具和各种各样的东西使你的开发更容易，很多…

hackernoon.com](https://hackernoon.com/understanding-js-the-event-loop-959beae3ac40)