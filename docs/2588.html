<html>
<head>
<title>Javascript Promises Best Practices &amp; Anti Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript承诺最佳实践和反模式</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/javascript-promises-best-practices-anti-patterns-b32309f65551?source=collection_archive---------2-----------------------#2017-02-06">https://medium.com/hackernoon/javascript-promises-best-practices-anti-patterns-b32309f65551?source=collection_archive---------2-----------------------#2017-02-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="39e4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下可能看起来像是自以为是的<a class="ae jp" href="https://hackernoon.com/tagged/article" rel="noopener ugc nofollow" target="_blank">文章</a>，也请给出你的意见。事实上，我发表这篇文章是为了验证我的想法。如果你同意，请推荐。<br/> //发表完这篇文章后，我发现了另一篇由<a class="ae jp" rel="noopener" href="/@nolan_lawson">诺兰·劳森</a>写的很棒的博文。<br/> //此处查看<a class="ae jp" href="https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html" rel="noopener ugc nofollow" target="_blank">。<br/> //您可以检查并返回到这里查看全局错误记录。</a></p><h1 id="7779" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">改进一段糟糕的代码</h1><p id="7416" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">所以让我们从坏的<a class="ae jp" href="https://hackernoon.com/tagged/code" rel="noopener ugc nofollow" target="_blank">代码</a>开始。这是一个没有逃脱回调地狱的人的例子。</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="ae1e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里所有的底层函数都调用return Promises，所以不需要创建<em class="la">新的Promise </em>而是直接使用return:</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="35f4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，因为我们可以将一个函数的输出传递给另一个函数，所以我们可以像这样链接它们:</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="e060" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为我们的函数很简单，我们甚至可以把它简化成这样:</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="22a2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">简单易懂不是吗？</p><h1 id="75f1" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">多重变量</h1><p id="034b" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">现在让我们举一个需要两个变量的例子。比方说，你有一种香肠，你需要一种特别的面包。在这个例子中，我们需要两个承诺的响应，其中一个依赖于另一个。</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="795d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以将内部函数提取到另一个函数中，但是你将在那里创建闭包，所以这是一回事。</p><p id="cfd0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还有一个使用Promise.all的选项，但我觉得这会使代码难以维护。但这是个人的选择。</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><h1 id="7a83" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">错误处理</h1><p id="739f" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">现在我们知道了如何链接承诺，让我们看看一些错误处理。你能区分这两者吗？</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="6af0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上面两个例子之间有一个非常重要的区别，那些最近才从jQuery迁移到React/Redux Stack并开始使用Axios、Fetch或其他类似库的人会觉得React开始吞噬他们的错误，而不是向前传播它们。</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="lb kz l"/></div></figure><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="lb kz l"/></div></figure><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="lb kz l"/></div></figure><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="lb kz l"/></div></figure><p id="22f4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但这不是吃你的错误。</p><p id="a9aa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">比方说，你在上面的<code class="eh lc ld le lf b">doSomething</code>函数中有一个运行时错误，在<code class="eh lc ld le lf b">requestA</code>流程中，你的错误会被捕获，然后<code class="eh lc ld le lf b">fallbackForRequestFail</code>会被调用，而实际上<code class="eh lc ld le lf b">fallbackForRuntimeError</code>应该被记录，这样你会得到通知，而不是神秘地消失。</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="6741" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以本质上在<code class="eh lc ld le lf b">requestB</code>代码流中，只有函数会在两者之间被调用。任何其他错误(如运行时错误)都将提前传播，您可以单独处理这些错误，也可以将这些错误记录到您的错误记录服务中，并根据具体情况进行修复。</p><h1 id="5f71" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">记录未处理的拒绝承诺</h1><h2 id="8f69" class="lg jr hu bd js lh li lj jw lk ll lm ka jc ln lo ke jg lp lq ki jk lr ls km lt dt translated">在浏览器中</h2><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><h2 id="1da6" class="lg jr hu bd js lh li lj jw lk ll lm ka jc ln lo ke jg lp lq ki jk lr ls km lt dt translated">In Node.js</h2><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="62c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以在这里阅读更多关于处理拒绝承诺的信息<a class="ae jp" href="http://www.2ality.com/2016/04/unhandled-rejections.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="0ddc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你觉得我犯了一个错误，请评论。如果你觉得应该有更多的人知道这件事，请推荐。另外，点击查看<a class="ae jp" rel="noopener" href="/@nolan_lawson">诺兰·劳森</a>的深度文章<a class="ae jp" href="https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html" rel="noopener ugc nofollow" target="_blank">。</a></p><blockquote class="lu lv lw"><p id="8802" class="ir is la it b iu iv iw ix iy iz ja jb lx jd je jf ly jh ji jj lz jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is la it b iu iv iw ix iy iz ja jb lx jd je jf ly jh ji jj lz jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上给我们点赞/发消息</a>，或者简单地说，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is la it b iu iv iw ix iy iz ja jb lx jd je jf ly jh ji jj lz jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ma kz l"/></div></figure></div></div>    
</body>
</html>