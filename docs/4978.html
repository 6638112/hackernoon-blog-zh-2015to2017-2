<html>
<head>
<title>How to Build a Tiny Httpd Container</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建微型Httpd容器</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-build-a-tiny-httpd-container-ae622c37db39?source=collection_archive---------5-----------------------#2017-07-03">https://medium.com/hackernoon/how-to-build-a-tiny-httpd-container-ae622c37db39?source=collection_archive---------5-----------------------#2017-07-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div class="fe ff hs"><img src="../Images/8c21dd687d098819e30baee3d3371c57.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*0Ces-C_U37k8HZdFOiG-xg.png"/></div></figure><div class=""/><p id="09b3" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja ic">TL；DR: </strong> <a class="ae jw" href="https://github.com/oracle/smith" rel="noopener ugc nofollow" target="_blank"> Smith </a>可以将一个69MB <a class="ae jw" href="https://httpd.apache.org/" rel="noopener ugc nofollow" target="_blank">的apache httpd </a>容器缩小到2MB以下，从而节省97%的空间，同时使其更加安全和易于操作。然而，构建<a class="ae jw" href="https://blogs.oracle.com/developers/the-microcontainer-manifesto" rel="noopener ugc nofollow" target="_blank">微容器</a>可能需要一些复杂的修改，所以使用该工具进行一些练习是有用的。</p></div><div class="ab cl jx jy hc jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hn ho hp hq hr"><p id="f5e9" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Smith 是一个<a class="ae jw" href="https://blogs.oracle.com/developers/the-microcontainer-manifesto" rel="noopener ugc nofollow" target="_blank">微容器</a>构建器，过去几个月我一直在为它工作。<a class="ae jw" href="https://github.com/oracle/smith/blob/master/README.md" rel="noopener ugc nofollow" target="_blank">自述文件</a>展示了如何构建一个超简单的微容器，但是有些软件可能更难“微型化”。Apache httpd是棘手应用程序的一个很好的例子，因为它包括配置文件，有一些复杂的权限要求，并加载动态库。所有这些都需要一些基本步骤之外的额外步骤。下面我将详细介绍构建一个工作的httpd微容器的过程。</p><h1 id="0aef" class="ke kf ib bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">第一步</h1><p id="a1c8" class="pw-post-body-paragraph iy iz ib ja b jb lc jd je jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv hn dt translated">Smith可以使用mock直接从yum存储库和rpm构建，但是它也可以“微型化”现有的docker容器。出于这个过程的目的，我们将使用Docker Hub 上的官方<a class="ae jw" href="https://hub.docker.com/_/httpd/" rel="noopener ugc nofollow" target="_blank"> httpd容器作为我们的基础。最新的标签是由debian jessie构建的，压缩后重69MB。还有一个阿尔卑斯山的图像，在一个更瘦的28MB。我将使用基于debian的最新图像，但是也可以使用alpine图像执行类似的过程。</a></p><p id="398a" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">第一步是下载并安装smith:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="aa98" class="lq kf ib lm b fv lr ls l lt lu"># before starting ensure you have golang 1.6 or later installed<br/>git clone github.com/oracle/smith<br/>cd smith<br/>make<br/>sudo make install</span></pre><p id="1f2e" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们为我们的构建创建一个新目录:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="31f9" class="lq kf ib lm b fv lr ls l lt lu">mkdir smith-httpd<br/>cd smith-httpd</span></pre><p id="6f3e" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">接下来，我们下载httpd映像，这样我们就可以用它作为基础。(请注意，您还可以在smith.yaml中将包指定为完整的下载路径，但是图像不会被缓存，因此每次我们进行构建时都会重新下载。因为我们要构建很多次，所以最好手动下载图像。)</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="1249" class="lq kf ib lm b fv lr ls l lt lu">smith download -r <a class="ae jw" href="https://registry-1.docker.io/library/httpd" rel="noopener ugc nofollow" target="_blank">https://registry-1.docker.io/library/httpd</a> \<br/>-i httpd.tar.gz</span></pre><p id="7cf8" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">下一步是创建一个基本yaml文件。我不知道httpd二进制文件安装在映像中的什么位置，所以我们只能猜测它的位置。<code class="eh lv lw lx lm b">-DFOREGROUND</code>的arg告诉httpd不要后台化，以便docker可以以通常的方式获取日志:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="d1e4" class="lq kf ib lm b fv lr ls l lt lu">cat &lt;&lt; EOF &gt; smith.yaml<br/>type: oci<br/>package: httpd.tar.gz<br/>paths:<br/>- /usr/bin/httpd<br/>cmd:<br/>- /usr/bin/httpd<br/>- -DFOREGROUND<br/>EOF</span></pre><p id="bfcb" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们可以尝试构建:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="08b6" class="lq kf ib lm b fv lr ls l lt lu">smith -i smith-httpd.tar.gz<br/># …<br/># WARN[0002] chmod failed: chmod: cannot access ‘/usr/bin/httpd’: No such file or directory<br/># WARN[0002] Could not make paths readable: Process chmod -R go+rX /usr/bin/httpd exited with status 1<br/># …</span></pre><p id="5911" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">看起来/usr/bin/httpd不是正确的位置。幸运的是，smith将源图像中的图层解压缩到一个目录中，这样我们就可以四处查看了。目录是<code class="eh lv lw lx lm b">/tmp/smith-unpack-$(id -u)</code>。让我们找到正确的二进制:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="69b3" class="lq kf ib lm b fv lr ls l lt lu">find /tmp/smith-unpack-$(id -u) -name httpd<br/># /tmp/smith-unpack-1000/usr/local/apache2/bin/httpd</span></pre><p id="18d2" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">看起来二进制文件已经安装到了<code class="eh lv lw lx lm b">/usr/local/apache2/bin/httpd</code>中。事实上，如果我们在解压缩后的图像中稍微看一下，看起来所有的东西都已经安装在<code class="eh lv lw lx lm b">/usr/local/apache2</code>下了。让我们走一点捷径，只获取整个目录:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="6de7" class="lq kf ib lm b fv lr ls l lt lu">cat &lt;&lt; EOF &gt; smith.yaml<br/>type: oci<br/>package: httpd.tar.gz<br/>paths:<br/>- /usr/local/apache2/<br/>cmd:<br/>- /usr/local/apache2/bin/httpd<br/>- -DFOREGROUND<br/>EOF</span></pre><p id="a5b1" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们可以重建了。因为我们没有改变我们的源映像，所以当我们构建:</p><p id="f8ff" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><code class="eh lv lw lx lm b">smith -f -i smith-httpd.tar.gz</code></p><h1 id="bfc2" class="ke kf ib bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">测试我们的形象</h1><p id="2c8b" class="pw-post-body-paragraph iy iz ib ja b jb lc jd je jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv hn dt translated">Docker <a class="ae jw" href="https://github.com/moby/moby/pull/33355" rel="noopener ugc nofollow" target="_blank">还不支持</a>通过docker load直接导入oci映像，所以我们必须将映像推送到存储库来使用它。Docker Hub工作正常。创建帐户并创建新存储库后，您可以按如下方式推送您的映像:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="dbb9" class="lq kf ib lm b fv lr ls l lt lu">smith upload -r \<br/>https://&lt;user&gt;:&lt;pass&gt;<a class="ae jw" href="http://twitter.com/registry" rel="noopener ugc nofollow" target="_blank">@registry</a>-1.docker.io/&lt;user&gt;/&lt;repo&gt; \<br/>-i smith-httpd.tar.gz</span></pre><p id="1c58" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果您想将图像标记为除了<code class="eh lv lw lx lm b">latest</code>之外的东西，您可以选择将<code class="eh lv lw lx lm b">:&lt;tag&gt;</code>附加到存储库中。上传完成后，您可以通过<code class="eh lv lw lx lm b">docker run -it --rm &lt;user&gt;/&lt;repo&gt;</code>运行图像，或者使用我构建并上传的图像继续操作:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="7b24" class="lq kf ib lm b fv lr ls l lt lu">docker run -it --rm vishvananda/smith-httpd:first<br/># …<br/># /usr/local/apache2/bin/httpd: error while loading shared libraries: libuuid.so.1: cannot open shared object file: No such file or directory</span></pre><p id="7de7" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">嗯，看起来不太管用。</p><h1 id="c81d" class="ke kf ib bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">修复我们的形象</h1><p id="1395" class="pw-post-body-paragraph iy iz ib ja b jb lc jd je jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv hn dt translated">Smith足够聪明，可以下载为映像选择的二进制文件所需的任何库，只要它们在运行时没有通过dlopen打开。不幸的是，apache确实dlopen了一些库，包括上面错误消息中看到的<code class="eh lv lw lx lm b">libuuid.so.1</code>。有时，您可以通过在二进制文件上运行<code class="eh lv lw lx lm b">strings</code>找到可能打开的库，但是我发现的最好的方法是尝试运行二进制文件，看看什么会失败。通常错误信息会告诉你到底需要什么文件。</p><p id="adc0" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在这种情况下，我们需要添加<code class="eh lv lw lx lm b">/lib/x86_64-linux-gnu/libuuid.so.1</code>到我们的图像中。这很容易做到，只需将文件名附加到yaml文件的路径中。重建并重新推送映像后，记得使用新标签或使用<code class="eh lv lw lx lm b">docker pull &lt;user&gt;/&lt;repo&gt;</code>强制其在<code class="eh lv lw lx lm b">docker run</code>之前获得更新版本。如果您运行新的映像，您将会看到一个类似的抱怨<code class="eh lv lw lx lm b">librt.so.1</code>的错误消息。为了节省您的时间，这里有一个新的yaml，其中包含您需要的动态加载库的完整列表:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="671b" class="lq kf ib lm b fv lr ls l lt lu">cat &lt;&lt; EOF &gt; smith.yaml<br/>type: oci<br/>package: httpd.tar.gz<br/>paths:<br/>- /usr/local/apache2/<br/>- /lib/x86_64-linux-gnu/libuuid.so.1<br/>- /lib/x86_64-linux-gnu/librt.so.1<br/>- /lib/x86_64-linux-gnu/libdl.so.2<br/>- /lib/x86_64-linux-gnu/libexpat.so.1<br/>- /lib/x86_64-linux-gnu/libgcc_s.so.1<br/>- /lib/x86_64-linux-gnu/libcrypt.so.1<br/>cmd:<br/>- /usr/local/apache2/bin/httpd<br/>- -DFOREGROUND<br/>EOF</span></pre><p id="1def" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在另一次构建/上传/拉取之后，我们可以再次运行它:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="c2ae" class="lq kf ib lm b fv lr ls l lt lu">docker run -it --rm vishvananda/smith-httpd:second<br/># …<br/># AH00543: httpd: bad user name daemon</span></pre><p id="54fc" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了理解这里出了什么问题，我们需要稍微跑题一下。在大多数安装中，apache httpd将以root用户身份运行。它通常需要以root用户身份运行，以便能够绑定1024以下的端口。当然，让您的web服务器以root用户身份运行会有安全风险，因此它会放弃配置文件中指定的用户/组的权限。</p><p id="3ce1" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在理想情况下，我们应该从httpd配置文件中删除User和Group命令，并以非特权用户的身份运行二进制文件。这是可以做到的，但它要求我们以下列方式之一解决缺少绑定低端口的问题:</p><ol class=""><li id="6ff9" class="ly lz ib ja b jb jc jf jg jj ma jn mb jr mc jv md me mf mg dt translated">更改配置，使httpd侦听非特权端口</li><li id="8402" class="ly lz ib ja b jb mh jf mi jj mj jn mk jr ml jv md me mf mg dt translated">将<code class="eh lv lw lx lm b">--sysctl net.ipv4.ip_unprivileged_port_start=0</code>传递给<code class="eh lv lw lx lm b">docker run</code>(需要内核&gt; = 4.11)</li><li id="3f17" class="ly lz ib ja b jb mh jf mi jj mj jn mk jr ml jv md me mf mg dt translated">将<code class="eh lv lw lx lm b">--cap-add NET_BIND_SERVICE</code>传递给<code class="eh lv lw lx lm b">docker run</code>，并在httpd二进制文件上设置适当的能力位(docker中有对环境能力的短暂支持，这将消除设置能力位的需要，但它被还原，尚未返回到docker中)。</li></ol><p id="fdc0" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这些选项并不适合所有人，所以httpd映像的创建者使用了可靠的方法，即以root用户身份开始，然后转到另一个用户。一般来说，我们不希望微容器以root用户身份运行，但是smith支持这种情况。为了启用这个特性，我们需要在yaml中设置两个布尔值:<code class="eh lv lw lx lm b">root</code>和<code class="eh lv lw lx lm b">nss</code>。<code class="eh lv lw lx lm b">root</code>设置镜像以root用户身份运行，而<code class="eh lv lw lx lm b">nss</code>安装所需的linux位以使用户名和组查找在容器中工作。让我们用这些设置创建一个新的yaml:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="533e" class="lq kf ib lm b fv lr ls l lt lu">cat &lt;&lt; EOF &gt; smith.yaml<br/>type: oci<br/>package: httpd.tar.gz<br/>nss: true<br/>root: true<br/>paths:<br/>- /usr/local/apache2/<br/>- /lib/x86_64-linux-gnu/libuuid.so.1<br/>- /lib/x86_64-linux-gnu/librt.so.1<br/>- /lib/x86_64-linux-gnu/libdl.so.2<br/>- /lib/x86_64-linux-gnu/libexpat.so.1<br/>- /lib/x86_64-linux-gnu/libgcc_s.so.1<br/>- /lib/x86_64-linux-gnu/libcrypt.so.1<br/>cmd:<br/>- /usr/local/apache2/bin/httpd<br/>- -DFOREGROUND<br/>EOF</span></pre><p id="846b" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了避免任何权限问题，我们还希望apache将映像中的文件归属于拥有这些文件的用户。用smith构建的微容器中所有文件的默认<code class="eh lv lw lx lm b">user:group</code>是<code class="eh lv lw lx lm b">smith:smith</code>。我们必须修改httpd配置来使用这些名称。此外，按照惯例，我们将微容器进程的配置文件放在<code class="eh lv lw lx lm b">/read</code>中，所以让我们创建一个覆盖图来完成这项工作:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="fcb2" class="lq kf ib lm b fv lr ls l lt lu"># make an overlay read directory<br/>mkdir -p rootfs/read<br/># copy the config file out of the image<br/>cp /tmp/smith-unpack-$(id -u)/usr/local/apache2/conf/httpd.conf \<br/>rootfs/read/<br/># replace the file in our image with symlink to our file<br/>mkdir -p rootfs/usr/local/apache2/conf/<br/>ln -s /read/httpd.conf rootfs/usr/local/apache2/conf/httpd.conf</span></pre><p id="b56e" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，我们可以用所需的设置替换用户和组:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="8cd8" class="lq kf ib lm b fv lr ls l lt lu">sed -i -e ‘s/User daemon/User smith/’ \<br/>-e ‘s/Group daemon/Group smith/’ rootfs/read/httpd.conf</span></pre><p id="5a85" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在构建/上传/拉取之后，我们可以运行容器并在主机上公开一个端口:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="5f9b" class="lq kf ib lm b fv lr ls l lt lu">docker run -it -p 80:80/tcp --rm vishvananda/smith-httpd:third</span></pre><p id="2403" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">来自另一个shell的快速curl验证httpd正在工作:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="05f7" class="lq kf ib lm b fv lr ls l lt lu">curl localhost<br/># &lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</span></pre><h1 id="6cac" class="ke kf ib bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">变得真正“微”</h1><p id="c7e0" class="pw-post-body-paragraph iy iz ib ja b jb lc jd je jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv hn dt translated">现在容器可以工作了，我们可以进一步最小化它。apache2目录中实际上有相当多的无关内容。我们使用的唯一bin文件是httpd本身。我们确实需要这些模块，但是我们可以只挑选出那些在<code class="eh lv lw lx lm b">httpd.conf</code>中启用的模块。这是我们的最终构建，所以我们也可以切换到直接从Docker Hub获取图像:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="dd3f" class="lq kf ib lm b fv lr ls l lt lu">cat &lt;&lt; EOF &gt; smith.yaml<br/>package: <a class="ae jw" href="https://registry-1.docker.io/library/httpd" rel="noopener ugc nofollow" target="_blank">https://registry-1.docker.io/library/httpd</a><br/>nss: true<br/>root: true<br/>paths:<br/>- /usr/local/apache2/bin/httpd<br/># dynamic dependencies<br/>- /lib/x86_64-linux-gnu/libuuid.so.1<br/>- /lib/x86_64-linux-gnu/librt.so.1<br/>- /lib/x86_64-linux-gnu/libdl.so.2<br/>- /lib/x86_64-linux-gnu/libexpat.so.1<br/>- /lib/x86_64-linux-gnu/libgcc_s.so.1<br/>- /lib/x86_64-linux-gnu/libcrypt.so.1<br/># modules<br/>- /usr/local/apache2/modules/mod_authn_file.so<br/>- /usr/local/apache2/modules/mod_authn_core.so<br/>- /usr/local/apache2/modules/mod_authz_host.so<br/>- /usr/local/apache2/modules/mod_authz_groupfile.so<br/>- /usr/local/apache2/modules/mod_authz_user.so<br/>- /usr/local/apache2/modules/mod_authz_core.so<br/>- /usr/local/apache2/modules/mod_access_compat.so<br/>- /usr/local/apache2/modules/mod_auth_basic.so<br/>- /usr/local/apache2/modules/mod_reqtimeout.so<br/>- /usr/local/apache2/modules/mod_filter.so<br/>- /usr/local/apache2/modules/mod_mime.so<br/>- /usr/local/apache2/modules/mod_log_config.so<br/>- /usr/local/apache2/modules/mod_env.so<br/>- /usr/local/apache2/modules/mod_headers.so<br/>- /usr/local/apache2/modules/mod_setenvif.so<br/>- /usr/local/apache2/modules/mod_version.so<br/>- /usr/local/apache2/modules/mod_unixd.so<br/>- /usr/local/apache2/modules/mod_status.so<br/>- /usr/local/apache2/modules/mod_autoindex.so<br/>- /usr/local/apache2/modules/mod_dir.so<br/>- /usr/local/apache2/modules/mod_alias.so<br/>cmd:<br/>- /usr/local/apache2/bin/httpd<br/>- -DFOREGROUND<br/>EOF</span></pre><p id="64de" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了遵循微容器约定，我们还想对conf和rootfs做一些调整:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="d377" class="lq kf ib lm b fv lr ls l lt lu"># move the mime.types config file into the read directory<br/>cp /tmp/smith-unpack-$(id -u)/usr/local/apache2/conf/mime.types \<br/>rootfs/read/<br/>ln -s /read/mime.types rootfs/usr/local/apache2/conf/mime.types<br/># create a directory for serving files<br/>mkdir -p rootfs/read/www<br/># copy the index file into our new directory<br/>cp /tmp/smith-unpack-$(id -u)/usr/local/apache2/htdocs/index.html \ rootfs/read/www/<br/># change the serve directory in the config<br/># (note we could also have accomplished this with a symlink)<br/>sed -i ‘s;/usr/local/apache2/htdocs;/read/www;’ \ rootfs/read/httpd.conf<br/># store the pidfile in /run<br/>sed -i ‘/Group smith/a PidFile /run/httpd.pid’ rootfs/read/httpd.conf</span></pre><p id="3894" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在构建/上传/拉取之后，我们尽可能安全地运行我们的微容器:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="021f" class="lq kf ib lm b fv lr ls l lt lu">docker run -it -p 80:80/tcp --read-only --tmpfs /run \<br/>-v httpd-read:/read:ro --rm vishvananda/smith-httpd</span></pre><p id="1b6f" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们可以访问主机上的服务目录，因此我们可以进行更改:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="c889" class="lq kf ib lm b fv lr ls l lt lu">sudo sed -i ‘s/It works/Hello world/’ \<br/>/var/lib/docker/volumes/httpd-read/_data/www/index.html<br/>curl localhost<br/># &lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello world!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</span></pre><h1 id="87f8" class="ke kf ib bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">从Yum存储库构建</h1><p id="0eea" class="pw-post-body-paragraph iy iz ib ja b jb lc jd je jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv hn dt translated">使用mock的基于yum的构建惊人地相似。在<a class="ae jw" href="https://fedoraproject.org/wiki/Using_Mock_to_test_package_builds#How_do_I_set_up_Mock.3F" rel="noopener ugc nofollow" target="_blank">设置好模拟</a>后，你可以简单的用<code class="eh lv lw lx lm b">package: httpd</code>替换yaml中的包行。当然，这些文件将位于与docker映像不同的位置，在这种情况下，没有要研究的解压缩映像。</p><p id="44c1" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">要找到您想要取出的文件，在第一次构建后使用<code class="eh lv lw lx lm b">/usr/bin/mock --shell</code>在模拟chroot中查看。您还可以使用<code class="eh lv lw lx lm b">/usr/bin/mock --copyout</code>将文件从chroot复制到您的本地目录。构建/上传/运行过程是相同的，我鼓励您尝试在没有明确说明的情况下生成微容器。</p><h1 id="fb7a" class="ke kf ib bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">结论</h1><p id="5b46" class="pw-post-body-paragraph iy iz ib ja b jb lc jd je jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv hn dt translated">我们的微容器的第一个工作版本只有6MB，最终版本不到2MB。这还不到原容器大小的3%!此外，我们已经删除了所有无关的二进制文件，并将容器的文件系统设置为只读，从而改善了容器本身的操作特性和安全性。我希望这能启发你和smith一起开发一些其他的微容器。</p><div class="lh li lj lk fq ab cb"><figure class="mm hw mn mo mp mq mr paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mm hw mn mo mp mq mr paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mm hw mn mo mp mq mr paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ms mt mu"><p id="f922" class="iy iz mv ja b jb jc jd je jf jg jh ji mw jk jl jm mx jo jp jq my js jt ju jv hn dt translated"><a class="ae jw" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jw" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jw" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jw" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="iy iz mv ja b jb jc jd je jf jg jh ji mw jk jl jm mx jo jp jq my js jt ju jv hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jw" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jw" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lh li lj lk fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="fe ff mz"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>