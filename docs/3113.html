<html>
<head>
<title>React + .NET Core + SignalR = Amazing!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React +。网芯+ SignalR =惊艳！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/react-net-core-signalr-amazing-ea0a83e4357e?source=collection_archive---------0-----------------------#2017-03-14">https://medium.com/hackernoon/react-net-core-signalr-amazing-ea0a83e4357e?source=collection_archive---------0-----------------------#2017-03-14</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="0274" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">构建实时React + C#的简单、轻量级但功能强大的方法。NET核心web应用程序。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff jq"><img src="../Images/ac9f9677d38b70d3f7c0cad4387b3f06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*WDDBlFf_KxzZddnYH-HLNg.jpeg"/></div></figure><blockquote class="jy jz ka"><p id="d2c1" class="ir is jp it b iu iv iw ix iy iz ja jb kb jd je jf kc jh ji jj kd jl jm jn jo hn dt translated"><strong class="it hv">更新:</strong> <a class="ae ke" href="https://hackernoon.com/https-hackernoon-com-dotnetify-react-released-efc7de44a47e" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> DotNetify-React发布:用React + SignalR构建反应式MVVM app。网芯2.1！</strong> </a></p></blockquote><p id="bd43" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我很兴奋地宣布我一直在做的<a class="ae ke" href="https://hackernoon.com/tagged/open-source" rel="noopener ugc nofollow" target="_blank">开源项目</a>的测试版，以集成<a class="ae ke" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank"> React </a>于其中。网芯。它被称为<strong class="it hv"> dotNetify-React </strong>，它让你的React应用与. NET核心后端连接起来变得超级简单，你都知道，它可以在任何地方运行:Windows、Linux和Mac。</p><p id="c8a9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不仅如此，你的应用将免费获得实时WebSockets功能！</p><p id="a4ff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个项目使用SignalR将React组件连接到后端视图模型。它不使用MVC模式，不需要编写web API，也不需要从React端发出AJAX请求。在其最基本的形式下，您只需要在React组件的构造函数中声明一个单独的<strong class="it hv"> connect </strong> API，它就会自动地在connect上合并初始状态。</p><h1 id="67bb" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">实时MVVM</h1><p id="72b5" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">当一个实时应用程序需要一个有状态的模型时，这就是dotNetify显示其关键优势的地方。那些后端视图模型，它们不仅仅是贫血的对象，还可以用来托管应用程序逻辑，否则您将在客户端用Javascipt编写这些逻辑。从某种意义上来说，它是一个真正的MVVM，视图模型代表了一个视图的抽象，包含了数据和行为来完成一个用例。</p><p id="de9d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">后端有一个瘦控制器，其唯一的工作是在浏览器上显示相关视图时维护视图模型实例，您可以使用您最喜欢的IoC容器(或者使用ASP.NET依赖注入)来实例化它们。结合实时将数据推送到客户端的能力，您可以真正选择<em class="jp">让您的应用程序非常后端驱动，并保持您的前端瘦而笨</em>。</p><p id="b5b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你认为这是向IBM哑终端时代的倒退，不可能是可扩展的，嘿，<a class="ae ke" href="https://realm.io/news/mbltdev-hector-zarate-consistent-thin-dumb-spotify/" rel="noopener ugc nofollow" target="_blank">这已经在现代完成了，不亚于Spotify </a>的公司！</p><h1 id="31a7" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">几分钟内开始运行</h1><p id="e494" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">我在<a class="ae ke" href="http://dotnetify.net" rel="noopener ugc nofollow" target="_blank">项目的网站</a>上放了一些非常简单的步骤，介绍如何从头开始制作一个实时的“Hello World”应用程序，使用了三种不同的选项:。NET Core CLI，Visual Studio 2017 + WebPack，或者脸书自己的<a class="ae ke" href="https://facebook.github.io/react/blog/2016/07/22/create-apps-with-no-configuration.html" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>用Node.js和。网芯。</p><p id="0ea0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">后者最让我兴奋，因为<em class="jp"> create-react-app </em>是创建新react应用的官方标准，号称零配置<br/>，因为它只是以一种非常自以为是(但专家)的方式为你打包所有内容。我喜欢每当脚本文件更新时页面自动重新加载，并且有一种方法可以添加WebPack的热模块替换功能，这样更新将只重新呈现组件，而不是完全重新加载。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="fe ff li"><img src="../Images/141133e36620774d0b58fdcd3e9f5576.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/1*8Jug4R0bUi49okOee1Df8A.gif"/></div></div></figure><p id="bf48" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但更让我高兴的是，我们可以做类似的事情。NET Core:任何服务器端的文件更新都会导致它重新构建，只需添加<a class="ae ke" href="https://docs.microsoft.com/en-us/aspnet/core/tutorials/dotnet-watch" rel="noopener ugc nofollow" target="_blank"> dotnet watch </a>特性。想象一下我们在这里可以获得的生产力提升:每当你做一些代码更改时，我们可以跳过停止、重新编译、重新运行和重新加载页面的循环。</p><p id="bb5e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要了解更多信息并观看充实的现场演示，请访问<a class="ae ke" href="http://dotnetify.net" rel="noopener ugc nofollow" target="_blank">项目的网站</a>及其<a class="ae ke" href="https://github.com/dsuryd/dotNetify" rel="noopener ugc nofollow" target="_blank"> Github站点</a>。</p><p id="df54" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我对这个项目的期望是达到一个可以支持全栈微服务的状态。NET平台:拥有一个由独立的<em class="jp">前端+后端</em>模块组成的复杂web应用程序的能力，这些模块可以由完全自主的团队在最短的停机时间内进行工作和部署。听起来像是一个高要求？希望不会，因为那真的是我未来想要的工作方式！</p><div class="jr js jt ju fq ab cb"><figure class="ln jv lo lp lq lr ls paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="ln jv lo lp lq lr ls paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="ln jv lo lp lq lr ls paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="jy jz ka"><p id="f922" class="ir is jp it b iu iv iw ix iy iz ja jb kb jd je jf kc jh ji jj kd jl jm jn jo hn dt translated"><a class="ae ke" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是阿妹家庭的一员。我们现在<a class="ae ke" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ke" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is jp it b iu iv iw ix iy iz ja jb kb jd je jf kc jh ji jj kd jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ke" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ke" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="fe ff lt"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lu lv l"/></div></figure></div></div>    
</body>
</html>