<html>
<head>
<title>The First Video Game on the BBC Micro:bit [probably]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BBC微上第一个视频游戏:bit[大概]</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-first-video-game-on-the-bbc-micro-bit-probably-4175fab44da8?source=collection_archive---------5-----------------------#2017-02-27">https://medium.com/hackernoon/the-first-video-game-on-the-bbc-micro-bit-probably-4175fab44da8?source=collection_archive---------5-----------------------#2017-02-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/2123c71066b47fa246e477babc50affa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bU1eV419oXLWJFwwKN3AXQ.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">The title screen</figcaption></figure><p id="4609" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">不久前，我很幸运地得到了一个BBC micro:bit，这是Nicholas Tollervey提供的，我想看看我能把python推向什么程度(我去年5月开始写这篇文章！).这是我用2美元的外部显示器在micro:bit上构建游戏的故事。</p><h1 id="4cc0" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">硬件</h1><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff le"><img src="../Images/0dc01572168e52d4906078a499fafb57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OJcjw2DMDmhl2IbudMyJwg.jpeg"/></div></div></figure><p id="bf4f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><a class="ae lj" href="https://www.microbit.co.uk/" rel="noopener ugc nofollow" target="_blank"> bbc micro:bit </a>是一台微型电脑，<a class="ae lj" href="http://www.bbc.co.uk/mediacentre/latestnews/2016/bbc-micro-bit-schools-launch" rel="noopener ugc nofollow" target="_blank">其中</a>有一百万台被英国人(和威尔士人！)学童和学校。它有灯，按钮，USB，蓝牙，运行Python！</p><p id="4c30" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">硬件相当有限。它围绕nRF51822芯片构建，时钟频率为16 MHz，内存为16 KB。闪存空间稍微大一些，有256 KB的可用空间。这使得做更复杂的事情相当有挑战性和乐趣。</p><p id="cf70" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">该板有两个按钮，和一个由25个发光二极管组成的迷你屏幕，这对人们开始使用非常好，但在绘制小行星和宇宙飞船时非常有限！为了让事情更令人兴奋，我添加了这个小显示屏:</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lk"><img src="../Images/01005d5eaba66afac241586d52f106cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tkE2oAp7viRrvRFDdGQ6wg.jpeg"/></div></div></figure><p id="e9b0" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">你可以在网上花2美元买到。在之前我已经讲过<a class="ae lj" rel="noopener" href="/@stestagg/playing-star-wars-on-the-esp8266-with-micropython-5f175fe7b755">这个显示器了。</a></p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div class="fe ff ll"><img src="../Images/e4dbae7bfe75940d99fb43e9ea75ab18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*fJg5sbktYhXRiv62OZ7MoA.png"/></div></figure><p id="5bfe" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">为了连接两者，我从K <a class="ae lj" href="https://www.kitronik.co.uk/" rel="noopener ugc nofollow" target="_blank"> itronik </a>买了一个edge连接器，它可以将micro:bit上的智能edge连接器变成电子原型的普通引脚。</p><p id="be9b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">考虑到这一点，以及来自micro:bit site 的<a class="ae lj" href="https://www.microbit.co.uk/device/pins" rel="noopener ugc nofollow" target="_blank">引脚，它显示了I C引脚(显示器使用的有线协议)，以及哪些引脚可用于为显示器供电，我可以将它们连接起来。不幸的是，micro:bit和显示器的引脚并不完全匹配，我不得不将一个跨越两条电线的适配器拼凑在一起，以允许显示器直接插入分线板。然后，我用</a><a class="ae lj" href="https://sugru.com/" rel="noopener ugc nofollow" target="_blank"> sugru </a>包裹连接器，让它看起来更漂亮:</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div class="fe ff ln"><img src="../Images/74c55d93d65baa7421507a2d4e489aea.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*9BnOszlPYSFLtvcDHJzFTQ.png"/></div></figure><h1 id="55c1" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">软件</h1><p id="bdd4" class="pw-post-body-paragraph jg jh hu ji b jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd hn dt translated">Micropython有点令人敬畏。Python3语言的一个独立实现，由Damien George开发，运行在低功耗/内存芯片上，为嵌入式应用而设计。</p><p id="78ff" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">最终，它仍然是Python，尽管它有很多好处，但它并没有被设计成超快或内存高效，而这两者在传统上对游戏来说是至关重要的。这使得一些事情变得相当棘手，我将在下面探讨它们。</p><h1 id="ef1a" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">Bitflyer</h1><p id="c5c7" class="pw-post-body-paragraph jg jh hu ji b jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd hn dt translated">这是一个游戏的视频:</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lt lu l"/></div></figure><p id="62f1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我的想法是在小行星和太空入侵者之间创建一个更简单的交叉，巨石从屏幕顶部落下，玩家必须驾驶飞船来躲避它们。</p><p id="7664" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">源代码在github上:<a class="ae lj" href="https://github.com/stestagg/bitflyer" rel="noopener ugc nofollow" target="_blank">https://github.com/stestagg/bitflyer</a></p><p id="fd8c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在制作过程中，我遇到了该平台的一些限制，我将在下面讨论这些限制:</p><h2 id="c7f6" class="lv kh hu bd ki lw lx ly km lz ma mb kq jr mc md ku jv me mf ky jz mg mh lc mi dt translated">速度</h2><p id="d9f0" class="pw-post-body-paragraph jg jh hu ji b jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd hn dt translated">速度实际上并不是一个大问题。该芯片的时钟频率为16 Mhz，micropython很好地利用了这些周期。</p><p id="e54c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在某些情况下，我将一些代码转移到C模块中(见下文),这有助于解决一些瓶颈问题。</p><p id="5289" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">主要的速度问题是更新显示。I C并不是为超高速通信而设计的。nRF51822/ssd1306可以以1 Mhz的时钟速度进行通信，但对于I C线和握手协议，这实际上相当于25–40 KBps(字节)。</p><p id="7147" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">更新整个显示需要1 KB的数据，因此每秒多次这样做(cpu在通信发生的整个时间都很忙)不会给做其他事情留下太多空间。</p><h2 id="5fea" class="lv kh hu bd ki lw lx ly km lz ma mb kq jr mc md ku jv me mf ky jz mg mh lc mi dt translated">记忆</h2><p id="5aff" class="pw-post-body-paragraph jg jh hu ji b jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd hn dt translated">记忆是个大问题。micro:bit有16 KB ram，这并不多，尤其是在使用严重依赖动态分配的python时。</p><p id="bd7e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">下图显示了如何为micropython划分内存(禁用了许多较大的内置模块):</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mj"><img src="../Images/09069860367b0ed4f02770bcb30307d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2S_rPnRo0MLPa80QJ1legQ.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Map of the RAM usage of the bitflyer code. Labels indicate which system uses that section of memory. Each square represents 32 bytes of RAM</figcaption></figure><p id="1462" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">重要的部分是“micropython堆”部分。所有普通的python对象都在这个范围内，</p><p id="ec3d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">所有普通的python对象都存在于上图中绿色的“micropython堆”中，这个堆只能使用大约一半的ram。</p><p id="1350" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">传统上，对于嵌入式系统，所有代码都被编译，并添加到闪存中，在micro:bit上是256 KB(加载空间！).使用python，虽然源代码可以存在于flash中，但micropython必须在运行时将它编译成RAM中的对象。在这种情况下，添加大量复杂代码来避免内存使用通常不是一种选择，因为复杂代码也会使用与您试图压缩的对象相同的内存池。</p><p id="d819" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我没有深入研究micropython解析器/编译器的内部，但是像去掉注释和使用<a class="ae lj" href="https://github.com/liftoff/pyminifier" rel="noopener ugc nofollow" target="_blank"> pyminifier </a>这样简单的事情对将代码放入内存有很大的帮助。</p><p id="255f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">最后，为了找到一个可靠运行的模型，进行了大量的试错，改变了使用的变量和顺序。我还必须调整python堆和栈的大小(使它们变小)来容纳所有内容。</p><h2 id="67e1" class="lv kh hu bd ki lw lx ly km lz ma mb kq jr mc md ku jv me mf ky jz mg mh lc mi dt translated">显示缓冲器</h2><p id="5731" class="pw-post-body-paragraph jg jh hu ji b jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd hn dt translated">我很早就决定使用显示缓冲区。我使用的显示芯片(ssd1306)有一个内部帧缓冲器，但没有简单/明显的方法从中读取当前值，只能更新它们。</p><p id="d8ef" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我本可以实现一种方法，基于跟踪自上一帧以来移动了什么对象，并计算增量，来清除/ <a class="ae lj" href="https://hackernoon.com/tagged/repainting" rel="noopener ugc nofollow" target="_blank">重画</a>屏幕的部分，但是这种方法有一些缺点:跟踪每次更改的代码/内存成本相当高，与显示器的通信相当慢，所以许多小的更新命令会引入明显的滞后/延迟。</p><p id="6a6a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">相反，我决定在内存中保存一个屏幕“视图”，每次都用它来进行有效的更新。这是一个很大的成本，屏幕有128x64像素，每个像素要么开要么关，所以屏幕缓冲区是1 KB，或机器总内存的1/16。这种方法的优点是更新屏幕要简单得多，因为您只需跟踪屏幕的哪个矩形包含更改，并进行一次数据批量传输来更新显示。</p><p id="8860" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">最初，我使用python数组来存储屏幕缓冲区，并立即遇到了严重的内存问题。问题原来是分裂。micropython堆只有9 KB，在中间某个随机的地方有一大块1 KB的不可移动数据，这给试图在它周围放置小对象的分配器造成了很大的压力。</p><p id="9bef" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我在有效地将位图数据复制到数组中时也遇到了一些困难，在循环中使用“|”操作符有点慢。</p><p id="e48e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">为了解决这两个问题，我给micropython添加了一个c模块，它提供了一个静态分配的1 KB缓冲区的显示缓冲区接口，以及一些用c编写的<a class="ae lj" href="https://en.wikipedia.org/wiki/Bit_blit" rel="noopener ugc nofollow" target="_blank"> blit </a>函数</p><h2 id="f711" class="lv kh hu bd ki lw lx ly km lz ma mb kq jr mc md ku jv me mf ky jz mg mh lc mi dt translated">形象</h2><p id="a4ed" class="pw-post-body-paragraph jg jh hu ji b jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd hn dt translated">显示器有一个奇怪的内存布局。垂直方向有64个像素，但这些像素被分成8个像素的行。每行将1个字节中的位映射到垂直像素，如下所示:</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div class="fe ff mk"><img src="../Images/bf22b761bbf87d2ee4483a2d7773ddc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*o921vO1RIG-zEIoW_4poSQ.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">The ssd1306 internal memory layout</figcaption></figure><p id="2c3d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这种非标准格式意味着我不能真正使用micropython内置的图像模块，而是编写一个脚本来将图像转换为以上述格式打包的c数组，并将它们作为静态变量包含在内。</p><h2 id="ee4e" class="lv kh hu bd ki lw lx ly km lz ma mb kq jr mc md ku jv me mf ky jz mg mh lc mi dt translated">Rant —层</h2><blockquote class="ml mm mn"><p id="c3ee" class="jg jh lm ji b jj jk jl jm jn jo jp jq mo js jt ju mp jw jx jy mq ka kb kc kd hn dt translated">抽象/专门化权衡的争论是复杂的，并且会变得激烈。我个人非常反对在任何堆栈中超过1或2个抽象点，下面的咆哮就是基于这个观点。我对一个可行的实现提出质疑，但没有证明另一种方法更好(或者发送一个拉请求)，所以这真的不公平。然而，我确实认为围绕这个问题进行友好的辩论可能是有益的。请注意，以下观点可能不会得到普遍认同。</p></blockquote><p id="a925" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">Damien在如此短的时间内将micropython移植到micro:bit上所取得的成就是惊人的，我不知道确切的时间，但我知道这是一个令人印象深刻的快速转变。</p><p id="031c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">一种方法是利用现有框架来实现这一目标，其中许多框架由mbed生态系统推广/管理。使用<a class="ae lj" href="https://www.mbed.com/en/" rel="noopener ugc nofollow" target="_blank"> mbed </a>工具的成本是图层，mbed工具都构建在构建于底层工具之上的工具之上。这些层中有几层增加的价值很小，但都是有成本的。</p><p id="50cd" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">例如，构建bitflyer/micropython二进制文件基本上就是在源代码上调用gcc arm交叉编译器，使用预定义的参数，并用nRF51822 ld脚本将它链接在一起，以给出正确的内存布局。</p><p id="9cdd" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">mbed方法是使用一个叫做<a class="ae lj" href="https://yotta.mbed.com/" rel="noopener ugc nofollow" target="_blank"> yotta </a>的工具。Yotta是“IOT”平台的软件包管理器，要使用它，你需要一个ARM帐户，并让ARM访问你的github帐户。(我感觉ARM试图在这里建立一个锁定平台)。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mr"><img src="../Images/a93a7ae39b46fcaf2538396c98ef58a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oHAd0WOInBSx3kUZfxQWQQ.png"/></div></div></figure><p id="ee5e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">Micropython有一些额外的构建阶段，所以在yotta周围有一个Makefile包装器，然后调用“yt build”</p><p id="8516" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">YT build最终为项目创建一个CMake配置(&gt; 1.7 k行)，并运行它来生成一个<a class="ae lj" href="https://ninja-build.org/" rel="noopener ugc nofollow" target="_blank"> ninja </a>构建配置(&gt; 2.8 k行)。</p><p id="358c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">Ninja随后运行，依次为每个文件调用gcc/g++，然后将它们链接在一起。</p><p id="3361" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果一切正常，就会产生一个二进制文件。但是，如果你想知道所有RAM的去向，你需要查看<em class="lm"> ld </em>的输出，为了做到这一点，我必须发现并跟踪堆栈的每一层，以找到相关信息输出的位置。幸运的是，我不需要实际更改<em class="lm"> ld </em>命令行参数，因为那样会困难得多。</p><p id="d2ce" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，我知道，ARM正试图建立一个神奇的平台，容纳1000个现成的组件，这些组件可以与许多平台交叉编译，并向所有IOT开发人员提供ARM交付的一键式价值，但在这种情况下，魔力很快就消失了。</p><h2 id="428a" class="lv kh hu bd ki lw lx ly km lz ma mb kq jr mc md ku jv me mf ky jz mg mh lc mi dt translated">哈尔/达尔/平台</h2><p id="27d3" class="pw-post-body-paragraph jg jh hu ji b jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd hn dt translated">这个问题出现的另一个例子是在代码中。Micropython只是一个执行环境，所以为了和不同的硬件集成，它有一层叫做mphal (micropython硬件抽象层)。这将公共模块功能转化为特定于设备的调用。</p><p id="e453" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">micropython的micro:bit端口使用了一个名为<a class="ae lj" href="https://github.com/lancaster-university/microbit-dal" rel="noopener ugc nofollow" target="_blank"> microbit-dal </a>(设备抽象层)的项目，在很长一段时间内，需要兰卡斯特大学的某人亲自批准才能访问代码(自述文件中仍有提及)</p><p id="e6d4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">microbit-dal是在mbed平台上构建的，因此调用mbed-classic代码来完成大部分繁重的工作。</p><p id="afe6" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">mbed-classic是一个基于一组IOT相关功能的硬件抽象库，最终调用nrf的yotta_target来满足实际的平台特定需求。</p><p id="900c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">所有这些层的副作用之一可以在上面的内存图中看到。microbit上有两个独立的堆，micropython堆和mbed-classic堆。对于16 KB内存来说，这是一个很大的堆！</p><p id="be77" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这个堆栈中涉及的代码行很快开始增加，并且跟踪所有层中的代码路径很快就过时了:</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="ms lu l"/></div></figure><h2 id="355a" class="lv kh hu bd ki lw lx ly km lz ma mb kq jr mc md ku jv me mf ky jz mg mh lc mi dt translated">摘要</h2><p id="319d" class="pw-post-body-paragraph jg jh hu ji b jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd hn dt translated">编写bitflyer真的是一个有趣且有益的挑战！</p><p id="ef14" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这种体验对于更高年级的/ <a class="ae lj" href="https://hackernoon.com/tagged/technical" rel="noopener ugc nofollow" target="_blank">技术</a>学生来说并不遥远。如果可以释放更多的内存，并对辅助模块进行一些整理，举行一次学校活动来焊接显示连接器，并编写一个简单的游戏应该是容易做到的。</p><p id="fb68" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">编写c模块等的大部分艰苦工作，通过一些整理应该是可重用的，允许在没有太多技术知识的基础上构建酷的项目。</p><p id="a6a4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我对游戏的下一步将是添加声音，使用一个简单的压电扬声器和micropython音乐模块。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mt"><img src="../Images/990acf2e2f224c21f7bea14262469532.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O5t2oWnjYJvNAjmGG_AByw.jpeg"/></div></div></figure><div class="lf lg lh li fq ab cb"><figure class="mu iv mv mw mx my mz paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mu iv mv mw mx my mz paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mu iv mv mw mx my mz paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ml mm mn"><p id="f922" class="jg jh lm ji b jj jk jl jm jn jo jp jq mo js jt ju mp jw jx jy mq ka kb kc kd hn dt translated"><a class="ae lj" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae lj" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae lj" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae lj" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jg jh lm ji b jj jk jl jm jn jo jp jq mo js jt ju mp jw jx jy mq ka kb kc kd hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lj" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lj" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff na"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="nb lu l"/></div></figure></div></div>    
</body>
</html>