<html>
<head>
<title>Your Node.js authentication tutorial is (probably) wrong</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你的Node.js认证教程(可能)是错误的</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/your-node-js-authentication-tutorial-is-wrong-f1a3bf831a46?source=collection_archive---------0-----------------------#2017-08-03">https://medium.com/hackernoon/your-node-js-authentication-tutorial-is-wrong-f1a3bf831a46?source=collection_archive---------0-----------------------#2017-08-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="e487" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">TL；dr: </strong>我继续搜索Node.js/Express.js认证教程。它们都不完整，或者在某种程度上犯了安全错误，可能会伤害新用户。这篇文章探讨了一些常见的认证陷阱，如何避免它们，以及当教程不再对您有所帮助时，您该如何自救。我仍在寻找一个健壮的、一体化的解决方案，用于Node/Express中的认证，与Rails的<a class="ae jp" href="https://github.com/plataformatec/devise" rel="noopener ugc nofollow" target="_blank">设计</a>相媲美。</p><blockquote class="jq jr js"><p id="4af9" class="ir is jt it b iu iv iw ix iy iz ja jb ju jd je jf jv jh ji jj jw jl jm jn jo hn dt translated"><strong class="it hv">更新(8月7日)</strong> : RisingStack已经伸出援手，<a class="ae jp" href="https://github.com/RisingStack/nodehero-authentication/commit/9d69ea70b68c4971466c64382e5f038e3eda8d8a" rel="noopener ugc nofollow" target="_blank">不再在他们的教程中明文存储密码</a>，选择在他们的示例代码和教程中转移到bcrypt。<br/> <strong class="it hv">更新(8月8日):</strong>编辑标题为<em class="hu">你的Node.js认证教程(很可能)是错的</em>，因为这篇帖子已经改进了其中的一些教程。<br/> <strong class="it hv">更新(8月10日):</strong><a class="ae jp" href="https://twitter.com/dmcghan" rel="noopener ugc nofollow" target="_blank"><em class="hu">Dan mcg Han</em></a><em class="hu">发现其中一个教程解决了我在本文档中不知何故漏掉的一个问题。我现在省略了格拉芙，因为Medium不允许删除。毕竟，我也会犯错。😊本文末尾有一个附录。<br/> </em> <strong class="it hv">更新(2018年5月27日):<em class="hu">这个帖子仍然有很多浏览量，但这个帖子现在已经有几个月了，可能包含过时的信息。从那以后，我不再试图强化节点生态系统；它正在往野火上泼水。生态系统的增长优先于安全性，您必须决定这些风险是否是您的组织可以接受的。</em> </strong></p></blockquote><p id="7345" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt jx translated">在我的业余时间，我一直在钻研各种Node.js教程，因为似乎每个拥有博客的Node.js开发者都发布了他们自己的教程，告诉他们如何以正确的方式做事，或者更准确地说，以他们自己的方式做事。成千上万被扔进服务器端JS大漩涡的前端开发人员正试图从这些教程中拼凑出可操作的知识，要么是通过cargo-cult-copypasta，要么是免费使用<em class="jt"> npm install </em>，因为他们疯狂地争夺外包经理或广告代理创意总监为他们设定的最后期限。</p><p id="2b07" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Node.js开发中一个比较有问题的事情是，认证在很大程度上被留给了个体开发人员<em class="jt">。</em>express . js世界中<em class="jt">事实上的</em>认证解决方案是<a class="ae jp" href="http://passportjs.org/" rel="noopener ugc nofollow" target="_blank"> Passport </a>，它提供了一系列<em class="jt">策略</em>用于认证。如果你想要一个类似于<a class="ae jp" href="https://github.com/plataformatec/devise" rel="noopener ugc nofollow" target="_blank"> Plataformatec为Ruby on Rails设计的</a>的健壮解决方案，你很可能会被指向<a class="ae jp" href="https://auth0.com/" rel="noopener ugc nofollow" target="_blank"> Auth0 </a>，一个已经将认证作为服务的初创公司。</p><p id="2674" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">与Devise相比，Passport只是一个身份验证中间件，并不为您处理身份验证的任何其他部分:这意味着Node.js开发人员可能会使用他们自己的API令牌机制、密码重置令牌机制、用户身份验证路由和端点，以及当今流行的任何模板语言的视图。因此，有很多专门为Express.js应用程序设置Passport的教程，但几乎所有的教程都存在这样或那样的错误，而且没有一个教程正确地实现了工作web应用程序所需的完整堆栈。</p><blockquote class="jq jr js"><p id="b723" class="ir is jt it b iu iv iw ix iy iz ja jb ju jd je jf jv jh ji jj jw jl jm jn jo hn dt translated"><strong class="it hv">注意</strong>:我并不是想骚扰这些教程的开发者，而是想利用他们的认证错误来说明在开发你自己的认证系统时所固有的安全问题。如果你是一个教程作者，一旦你更新了你的教程，请随时联系我。让我们让Node/Express成为新开发者更安全的生态系统。</p></blockquote><h1 id="2afb" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">错误一:凭证存储</h1><p id="1cb4" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">让我们从凭据存储开始。存储和调用凭证是身份管理的标准工作，传统的做法是在您自己的数据库或应用程序中完成。Passport是一个中间件，只是简单地说“这个用户很酷”或“这个用户不酷”，它需要<a class="ae jp" href="https://github.com/jaredhanson/passport-local" rel="noopener ugc nofollow" target="_blank"> passport-local </a>模块来处理您自己数据库中的密码存储，该模块由与Passport.js本身相同的开发人员编写。</p><p id="0582" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们进入这个教程兔子洞之前，让我们提醒自己OWASP的一个<a class="ae jp" href="https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet" rel="noopener ugc nofollow" target="_blank">密码存储</a>的伟大备忘单，它归结为“用独特的盐和单向自适应成本函数存储高熵密码”。或者，真的，科达·黑尔的<a class="ae jp" href="https://codahale.com/how-to-safely-store-a-password/" rel="noopener ugc nofollow" target="_blank"> bcrypt meme </a>，尽管<a class="ae jp" href="https://security.stackexchange.com/a/6415" rel="noopener ugc nofollow" target="_blank">有一些争议</a>。</p><blockquote class="jq jr js"><p id="90d1" class="ir is jt it b iu iv iw ix iy iz ja jb ju jd je jf jv jh ji jj jw jl jm jn jo hn dt translated"><strong class="it hv">有经验的开发人员注意:</strong>如果您<em class="hu">真的</em>想使用最先进的凭证存储，<a class="ae jp" href="https://github.com/P-H-C/phc-winner-argon2" rel="noopener ugc nofollow" target="_blank"><em class="hu">argon 2</em></a><em class="hu"/>是密码哈希竞赛的获胜者，现在在Node.js 中有了<a class="ae jp" href="https://github.com/emilbayes/secure-password" rel="noopener ugc nofollow" target="_blank">一些简单的支持。不幸的是，为Node.js生态系统中的新手用户实现Argon2的文档仍然缺乏，并且考虑到这是针对阅读教程的人，在接下来的几个月里坚持使用bcrypt似乎是一个不错的权衡。</a></p></blockquote><p id="41a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">作为一个新的Express.js和Passport用户，我首先要看的是<em class="jt"> passport-local </em>本身的示例代码，感谢<a class="ae jp" href="https://github.com/passport/express-4.x-local-example" rel="noopener ugc nofollow" target="_blank">给了我一个可以克隆和扩展的示例Express.js 4.0应用程序</a>。然而，如果我只是复制pasta这个，我不会留下太多，因为在这个例子中没有数据库支持，它假设我只是使用一些设置帐户。</p><p id="a4a8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不过，没关系，对吧？<em class="jt">这只是一个内部网应用</em>，开发人员说，<em class="jt">我还有其他四个项目分配给我，下周到期</em>。当然，本例中的密码没有经过任何散列处理，<a class="ae jp" href="https://github.com/passport/express-4.x-local-example/blob/master/db/users.js" rel="noopener ugc nofollow" target="_blank">并以明文形式存储在本例中的验证逻辑旁边</a>。这一次甚至没有考虑凭证存储。</p><p id="7a86" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们使用<em class="jt"> passport-local </em>搜索另一个教程。我在“节点英雄”系列中找到了<a class="ae jp" href="https://blog.risingstack.com/node-hero-node-js-authentication-passport-js/" rel="noopener ugc nofollow" target="_blank">这个来自RisingStack的快速教程，但它对我也没有帮助。他们，</a><a class="ae jp" href="https://github.com/RisingStack/nodehero-authentication" rel="noopener ugc nofollow" target="_blank">也在GitHub </a>上给了我一个示例应用程序，但是它有<a class="ae jp" href="https://github.com/RisingStack/nodehero-authentication/blob/7f808f5c8ea756155099b7b4a88390c356cf31be/app/authentication/init.js#L8" rel="noopener ugc nofollow" target="_blank">和官方的</a>一样的问题。<strong class="it hv"> ( <em class="jt"> Ed。8/7/17: </em> RisingStack是<em class="jt"> </em> </strong> <a class="ae jp" href="https://github.com/RisingStack/nodehero-authentication/commit/9d69ea70b68c4971466c64382e5f038e3eda8d8a" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">现在在他们的教程应用中使用bcrypt </strong> </a> <strong class="it hv">。)</strong></p><p id="87c8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以指责我挑选指南，如果挑选指南意味着从谷歌搜索结果的第一页中选择，那你就是对的。让我们从TutsPlus 中选择<a class="ae jp" href="https://code.tutsplus.com/tutorials/authenticating-nodejs-applications-with-passport--cms-21619" rel="noopener ugc nofollow" target="_blank">排名更高的结果<em class="jt">护照-本地</em>教程。这个更好，因为</a><a class="ae jp" href="https://github.com/tutsplus/passport-mongo/blob/master/passport/login.js" rel="noopener ugc nofollow" target="_blank">使用代价因子为10的brypt进行密码散列</a>。谷歌上最热门的搜索结果，scotch.io的教程也使用了成本系数为8的bcrypt。这两个都很小，但是8真的很小。如今大多数bcrypt库使用12。<a class="ae jp" href="https://www.usenix.org/legacy/publications/library/proceedings/usenix99/provos/provos_html/node6.html" rel="noopener ugc nofollow" target="_blank">成本因子8是针对十八年前<em class="jt"/></a><em class="jt"/>原始bcrypt论文发布时的管理员账户。</p><p id="df3b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了密码存储之外，这两个教程都没有实现密码重置功能，这是留给开发人员的一个练习，并且有其自身的缺陷。</p><h1 id="17ff" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">错误二:密码重置</h1><p id="88ac" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">密码存储的一个姐妹安全问题是密码重置，没有一个顶级的基础教程解释如何使用Passport进行重置。你得跟着另一个。</p><p id="b01d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有一千种方法可以把事情搞砸。我见过的最常见的密码重置错误的情况是:</p><ol class=""><li id="d12b" class="lj lk hu it b iu iv iy iz jc ll jg lm jk ln jo lo lp lq lr dt translated"><strong class="it hv">可预测的令牌。</strong>基于当前时间的令牌就是一个很好的例子。由不良伪随机数生成器生成的令牌不太明显。</li><li id="2f40" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated"><strong class="it hv">不好储藏。</strong>在您的数据库中存储未加密的密码重置令牌意味着如果数据库遭到破坏，这些令牌实际上就是明文密码。用密码安全的随机数生成器生成长令牌可以阻止对重置令牌的远程暴力攻击，但不能阻止本地攻击。重置令牌是凭据，应如此对待。</li><li id="f6a1" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated"><strong class="it hv">无令牌过期。</strong>不使您的令牌过期给了攻击者更多的时间来利用重置窗口。</li><li id="655b" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated"><strong class="it hv">没有二次数据验证。</strong>安全问题是对复位的<em class="jt">事实上的</em>数据验证。当然，接下来开发者还得选择<em class="jt">好的安全问题</em>。<a class="ae jp" href="https://www.kaspersky.com/blog/security-questions-are-insecure/13004/" rel="noopener ugc nofollow" target="_blank">安全问题自有问题</a>。虽然这看起来像是安全过度，但是电子邮件地址是您拥有的，而不是您知道的，并且合并了身份验证因素。您的电子邮件地址成为每个帐户的关键，只是发送一个重置令牌到电子邮件。</li></ol><p id="fa78" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你是新手，试试OWASP的<a class="ae jp" href="https://www.owasp.org/index.php/Forgot_Password_Cheat_Sheet" rel="noopener ugc nofollow" target="_blank">密码重置备忘单</a>。让我们回到节点世界在这方面为我们提供了什么。</p><p id="338c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将转移到<em class="jt"> npm </em>一会儿，然后<a class="ae jp" href="https://www.npmjs.com/search?q=password%20reset&amp;page=1&amp;ranking=popularity" rel="noopener ugc nofollow" target="_blank">寻找密码重置</a>，看看是否有人做过这个。有一个五年前的包来自(通常很棒的)子栈。在Node.js时间轴上这个模块是侏罗纪的，如果我想吹毛求疵的话，<a class="ae jp" href="https://security.stackexchange.com/questions/84906/predicting-math-random-numbers" rel="noopener ugc nofollow" target="_blank"> Math.random()在V8 </a>中是可预测的，所以<a class="ae jp" href="https://github.com/substack/node-password-reset/blob/master/index.js#L73" rel="noopener ugc nofollow" target="_blank">它不应该用于令牌生成</a>。还有，它不用护照，我们继续。</p><p id="c14d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">堆栈溢出并没有太大的帮助，因为Stormpath公司的开发人员关系部喜欢在每一个可以想到的关于这一点的帖子上宣传他们的IaaS初创公司。他们的文档也随处可见，他们还有<a class="ae jp" href="https://stormpath.com/blog/the-pain-of-password-reset" rel="noopener ugc nofollow" target="_blank">一个关于密码重置的博客</a>。然而，所有这一切都是徒劳的，因为Stormpath已经解散，<a class="ae jp" href="https://stormpath.com/" rel="noopener ugc nofollow" target="_blank">，它将在2017年8月17日</a>完全关闭。</p><p id="6732" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好吧，回到谷歌，这似乎是唯一存在的教程。我们将使用谷歌搜索<em class="jt"> express passport密码重置的第一个结果<a class="ae jp" href="http://sahatyalkabov.com/how-to-implement-password-reset-in-nodejs/" rel="noopener ugc nofollow" target="_blank">。这里是我们的老朋友<em class="jt"> bcrypt </em>再次，在文本中使用了一个更小的成本因子5，对于现代使用来说，这个成本因子<em class="jt">太小了。</em></a></em></p><p id="115d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，与其他教程相比，本教程相当可靠，因为它使用<em class="jt"> crypto.randomBytes </em>来生成真正随机的令牌，如果它们没有被使用，就会过期。然而，上述实践的#2和#4并没有被这个全面的教程所重视，因此密码令牌本身很容易受到第一个身份验证错误，凭证存储的影响。</p><p id="b639" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">幸运的是，由于重置过期，这是有限的使用。然而，如果攻击者通过BSON注入对数据库中的用户对象拥有读取权限，或者由于配置错误而可以自由访问Mongo，那么这些令牌就特别有趣。攻击者可以为每个用户发布密码重置，从数据库中读取未加密的令牌，并为用户帐户设置自己的密码，而不必通过GPU平台对bcrypt哈希进行代价高昂的字典攻击。</p><h1 id="0560" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">错误三:API令牌</h1><p id="0574" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">API令牌是凭证。它们与密码或重置令牌一样敏感。几乎每个开发人员都知道这一点，并试图守住他们的AWS密钥、Twitter秘密等。接近他们的胸部，但是这似乎没有转移到正在创作的代码中。</p><p id="0b98" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们使用<a class="ae jp" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> JSON Web令牌</a>作为API凭证。拥有一个无状态的、可列入黑名单的、可声明的令牌比使用了近十年的旧API key/secret模式要好。也许我们的junior Node.js dev以前在某个地方听说过jwt，或者看到了<em class="jt"> passport-jwt </em>并决定实施JWT战略。无论如何，在Node.js的势力范围内，每个人似乎都在向JWT移动。(德高望重的<a class="ae jp" href="https://news.ycombinator.com/item?id=13866883" rel="noopener ugc nofollow" target="_blank">托马斯·普塔切克会认为JWT是坏的</a>，但恐怕那艘船已经驶到这里了。)</p><p id="880e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们会在Google上搜索<em class="jt"> express js jwt </em>，然后在Node.js   <em class="jt"> </em>中找到<a class="lx ly gr" href="https://medium.com/u/8d4c0a555bc3?source=post_page-----f1a3bf831a46--------------------------------" rel="noopener" target="_blank"> Soni Pandey </a>的教程<a class="ae jp" rel="noopener" href="/@pandeysoni/user-authentication-using-jwt-json-web-token-in-node-js-using-express-framework-543151a38ea1"> <em class="jt">使用JWT (JSON Web Token)进行用户认证，这是第一个教程结果。不幸的是，这实际上对我们没有任何帮助，因为它不使用Passport，但是当我们在这里时，我们将很快注意到凭证存储中的错误:</em></a></p><ol class=""><li id="692f" class="lj lk hu it b iu iv iy iz jc ll jg lm jk ln jo lo lp lq lr dt translated">我们将把<a class="ae jp" href="https://github.com/pandeysoni/User-Authentication-using-JWT-JSON-Web-Token-in-Node.js-Express/blob/master/server/config/config.js#L13" rel="noopener ugc nofollow" target="_blank"> JWT密钥明文存储在存储库</a>中。</li><li id="bebb" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">我们将<a class="ae jp" href="https://github.com/pandeysoni/User-Authentication-using-JWT-JSON-Web-Token-in-Node.js-Express/blob/master/server/config/common.js#L54" rel="noopener ugc nofollow" target="_blank">使用对称密码来存储密码</a>。这意味着我可以获得加密密钥，并在发生违规时解密所有密码。加密密钥与JWT秘密共享。</li><li id="c59e" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">我们将使用AES-256-CTR来存储密码。我们不应该使用AES来启动，这种操作模式没有帮助。我不确定为什么特别选择了这种模式，但是这个选择本身就让密文具有延展性。</li></ol><p id="d8c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Welp。让我们回到谷歌，我们找到下一个教程。Scotch在他们的passport-local教程中对密码存储做得很好，<a class="ae jp" href="https://github.com/scotch-io/node-token-authentication/blob/master/app/models/user.js#L7" rel="noopener ugc nofollow" target="_blank">只是忽略了他们之前告诉你的内容，并在本例中以明文形式存储密码</a>。</p><p id="ee84" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">呃，为了简洁起见，我们暂且不考虑这个问题，但它对copypasta团队没有帮助。这是因为更有趣的是，本教程<a class="ae jp" href="https://github.com/scotch-io/node-token-authentication/blob/master/server.js#L81" rel="noopener ugc nofollow" target="_blank">还将mongoose用户对象序列化为JWT </a>。</p><p id="2491" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们克隆Scotch教程存储库，遵循说明并运行它。在Mongoose发出一个<em class="jt">弃用警告</em>或三个警告之后，我们可以点击<a class="ae jp" href="http://localhost:8080/setup" rel="noopener ugc nofollow" target="_blank"><em class="jt">http://localhost:8080/setup</em></a><em class="jt"/>来创建用户，然后通过使用默认凭证“Nick Cerminara”和“password”提交到/api/authenticate来获得一个令牌。如邮递员显示的那样，令牌被返回。</p><figure class="ma mb mc md fq me fe ff paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="fe ff lz"><img src="../Images/eff1ca27a733c2992e80328fcbfa275e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wvb2F4-Rx4I1ji2EJIyXZg.png"/></div></div><figcaption class="ml mm fg fe ff mn mo bd b be z ek">A JWT token returned from the Scotch tutorial.</figcaption></figure><p id="038d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，JSON Web令牌是签名的，但不是加密的。这意味着两个句点之间的大斑点是Base64编码的对象。快速解码，我们得到一些有趣的东西。</p><figure class="ma mb mc md fq me fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/a7861ae0107e57ded5519c64f2085d22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*5KcDyNtIfWXVe9uVUD0A_g.png"/></div><figcaption class="ml mm fg fe ff mn mo bd b be z ek">I love my passwords in plaintext in tokens.</figcaption></figure><p id="4275" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，任何拥有<em class="jt">甚至过期令牌</em>的人都拥有您的密码，以及存储在Mongoose模型中的任何其他内容。鉴于这个是通过HTTP传输的，我本可以从网络上嗅出它。</p><p id="e560" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下一个教程呢？接下来的教程，<a class="ae jp" href="https://jonathanmh.com/express-passport-json-web-token-jwt-authentication-beginners/" rel="noopener ugc nofollow" target="_blank"> <em class="jt"> Express，Passport和JSON Web Token (jwt)认证面向初学者</em> </a> <em class="jt">，</em>包含相同的信息泄露漏洞<em class="jt">。来自一家名为<a class="ae jp" href="http://blog.slatepeak.com/creating-a-simple-node-express-api-authentication-system-with-passport-and-jwt/" rel="noopener ugc nofollow" target="_blank"> SlatePeak的初创公司的下一篇教程做了同样的连载</a>。此时，我放弃了寻找。</em></p><h1 id="d577" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">错误四:限速</h1><p id="ee23" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">正如我在上面提到的，我在这些认证教程中没有发现提到速率限制或帐户锁定。</p><p id="2017" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在没有速率限制的情况下，对手可以进行在线字典攻击，运行像<a class="ae jp" href="https://portswigger.net/burp/help/intruder_using.html" rel="noopener ugc nofollow" target="_blank">Burp intrusor</a>这样的工具，希望获得使用弱密码访问帐户的权限。帐户锁定也有助于解决这个问题，它要求用户在下次登录时提供更多的登录信息。</p><p id="f8e4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">记住，速率限制也有助于可用性。<em class="jt"> bcrypt </em>是一个CPU密集型函数，在没有速率限制函数的情况下，使用bcrypt会成为应用级拒绝服务的媒介，尤其是在高工作因子的情况下。用户注册或登录密码检查的多个请求是一种简单的方法，可以将轻量级HTTP请求转化为服务器的高成本时间。</p><p id="8de9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然我没有可以指向这些的教程，但是Express有大量的限速中间件，例如<a class="ae jp" href="https://github.com/nfriedly/express-rate-limit" rel="noopener ugc nofollow" target="_blank"> express-rate-limit </a>、<a class="ae jp" href="https://www.npmjs.com/package/express-limiter" rel="noopener ugc nofollow" target="_blank"> express-limiter </a>和<a class="ae jp" href="https://github.com/AdamPflug/express-brute" rel="noopener ugc nofollow" target="_blank"> express-brute </a>。我不能谈论这些模块的安全性，甚至没有看过它们；一般来说，我建议在生产环境中运行一个反向代理，并允许nginx或其他负载均衡器对请求进行速率限制。</p><h1 id="f0ef" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">认证很难。</h1><p id="d86a" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">我相信教程开发者会为自己辩护说“这只是为了解释基础知识！肯定没有人会在生产中这样做！”然而，我怎么强调都不为过<em class="jt">这是多么的错误。当代码出现在你的教程中时，这一点<em class="jt">尤其是</em>正确。人们会相信你的话——毕竟，你比他们更有经验。</em></p><p id="177b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你是初学者，不要相信你的教程。教程<em class="jt">中的copy pasta</em>可能会让你、你的公司和你的客户在Node.js世界中陷入认证麻烦。如果你真的需要强大的、生产就绪的、一体化的身份验证库，那就回到更容易上手、更稳定、更成熟的东西上来，比如Rails/device。</p><p id="7055" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然Node.js生态系统是可访问的，但对于需要快速编写生产web应用程序的基于JavaScript的开发人员来说，它仍然有很多优势。如果你有前端背景，不了解其他编程语言，我个人认为拿起Ruby站在巨人的肩膀上比从头开始写这些类型的东西时快速学会如何不搬起石头砸自己的脚更容易。</p><p id="2398" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你是教程作者，<em class="jt">请</em>更新你的教程，<em class="jt">尤其是</em>样板代码。这些代码将会被复制到其他人的生产web应用程序中。</p><p id="8f2e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您是Node.js的铁杆开发者，希望您已经了解了一些在您使用Passport的身份验证系统中不要做的事情。你可能会出错。在这一篇文章中，我还没有涵盖所有可能出错的地方。你的工作不应该是为你的Express应用程序创建你自己的auth。应该有更好的。</p><p id="634f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你对更好地保护节点生态系统感兴趣，请在Twitter上给我发消息。</p><blockquote class="jq jr js"><p id="9540" class="ir is jt it b iu iv iw ix iy iz ja jb ju jd je jf jv jh ji jj jw jl jm jn jo hn dt translated">这篇文章是由espresso带给你的，因为我没有清酒了。</p></blockquote><h2 id="18c2" class="mq kh hu bd ki mr ms mt km mu mv mw kq jc mx my ku jg mz na ky jk nb nc lc nd dt translated">附录(最后更新于2017年8月10日)</h2><p id="1bbf" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">这篇文章是出于对我所看到的问题的失望而写的，不知何故，它有了自己的生命。它收到了更多的回应，更多的反馈，引起了比我预期的更多的争议。很明显，这是其他开发者的一个挫败点。</p><p id="aabc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你在这篇文章中发现错误，请给我发消息，我们会努力改正。我们不需要的是另一个被误导的帖子。那与我们所需要的正好相反。</p><p id="da6c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，我恳求你:让我们不要只在这个帖子上工作。让我们在未来让生态系统变得更好。如果你发现错误或有其他实践，你在生产中学到的东西，或简单的改进，请随时DM我。<strong class="it hv">我们的下一个最佳步骤似乎是编写一个活文档</strong>，其中包含围绕Node/Express身份验证的“备忘单”式最佳实践，直到有成熟、可靠的解决方案为止。</p><p id="1022" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为此，我已经在GitLab 上建立了<a class="ae jp" href="https://gitlab.com/micaksica/nodeauth-best-practices" rel="noopener ugc nofollow" target="_blank">知识库。请随意提出问题、您的建议或提出一些拉动式请求，让我们开始行动。这个周末一有机会，我就会去做。</a></p></div></div>    
</body>
</html>