<html>
<head>
<title>3x faster Flask apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">速度快3倍的烧瓶应用</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/3x-faster-than-flask-8e89bfbe8e4f?source=collection_archive---------1-----------------------#2017-11-27">https://medium.com/hackernoon/3x-faster-than-flask-8e89bfbe8e4f?source=collection_archive---------1-----------------------#2017-11-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="df6a" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">夸脱作为烧瓶的升级</h2></div><p id="98aa" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">自从大约8年前第一次发布<a class="ae kf" href="https://github.com/pallets/flask" rel="noopener ugc nofollow" target="_blank"> Flask </a>以来，Python一直在发展，特别是随着asyncio的引入。Asyncio允许开发诸如<a class="ae kf" href="https://github.com/MagicStack/uvloop" rel="noopener ugc nofollow" target="_blank"> uvloop </a>和<a class="ae kf" href="https://github.com/magicstack/asyncpg" rel="noopener ugc nofollow" target="_blank"> asyncpg </a>之类的库，据报道(<a class="ae kf" href="https://magic.io/blog/uvloop-blazing-fast-python-networking/" rel="noopener ugc nofollow" target="_blank">这里是</a>，这里是<a class="ae kf" href="https://magic.io/blog/asyncpg-1m-rows-from-postgres-to-python/" rel="noopener ugc nofollow" target="_blank">这里是</a>)，以提高性能，远远超过以前可能的性能。遗憾的是，Flask不容易与asyncio或这些库结合。然而，Flask-API可以通过<a class="ae kf" href="https://gitlab.com/pgjones/quart" rel="noopener ugc nofollow" target="_blank"> Quart </a>框架与asyncio一起使用。</p><p id="8a24" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Quart为Flask应用程序使用asyncio提供了最简单的过渡，因为它共享Flask-API。这意味着现有的Flask应用程序可以毫不费力地发展成Quart应用程序，然后使用这些新的库来利用Flask无法实现的性能改进。</p><p id="55ce" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">本文档详细介绍了典型生产<a class="ae kf" href="https://en.wikipedia.org/wiki/Create%2C_read%2C_update_and_delete" rel="noopener ugc nofollow" target="_blank"> CRUD </a>应用从烧瓶到夸脱的转换，并展示了典型生产部署的性能改进。</p><h2 id="b8aa" class="kg kh hu bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la dt translated">TL；博士；医生</h2><p id="7d4b" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated">将这款 Flask-pyscopg2应用升级到Quart-asyncpg应用，性能提升了3倍，而无需对代码进行重大重写或调整。总结结果，</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="15ea" class="kg kh hu ll b fv lp lq l lr ls">Route           | Flask | Quart | Ratio <br/>                | Req/s | Req/s | (Quart/Flask)<br/>-----------------------------------------------<br/>GET /films/995/ |   330 |  1160 |          3.5<br/>GET /films/     |    99 |   195 |          2.0<br/>POST /reviews/  |   325 |  1114 |          3.4</span></pre><h1 id="c550" class="lt kh hu bd ki lu lv lw km lx ly lz kq ja ma jb kt jd mb je kw jg mc jh kz md dt translated">该应用程序</h1><p id="42d3" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated">为了进行比较，我将考虑一个简单的应用程序，它简单地提供了一个RESTful数据库接口。这是微服务架构中的一个常见用例，提供了一个非常简单的代码库进行比较。</p><p id="b310" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">该应用程序有两个<a class="ae kf" href="http://flask.pocoo.org/docs/0.12/blueprints/" rel="noopener ugc nofollow" target="_blank">蓝图</a>，总共包括三条路线。这些路线旨在代表典型的CRUD使用，即<code class="eh me mf mg ll b">GET /films/&lt;int:id&gt;/</code>单个资源、<code class="eh me mf mg ll b">GET /films/</code>所有资源、<code class="eh me mf mg ll b">POST /reviews/</code>新资源。</p><p id="cfca" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">源代码可以在https://github.com/pgjones/faster_than_flask_article<a class="ae kf" href="https://github.com/pgjones/faster_than_flask_article" rel="noopener ugc nofollow" target="_blank">获得</a>注意有两个提交，一个Flask版本和一个Quart版本。</p><h2 id="1dc0" class="kg kh hu bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la dt translated">从烧瓶到夸脱的演变</h2><p id="2ea0" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated">从flask到quart的演变意味着很容易并且需要最小的改变，特别是从Flask的导入被改变为从Quart，函数变成异步的。全<a class="ae kf" href="https://github.com/pgjones/faster_than_flask_article/commit/0a70f2bddae90da13da5bce2b77ea56355ecc5d1" rel="noopener ugc nofollow" target="_blank">差</a>的一个例子是，</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="d87e" class="kg kh hu ll b fv lp lq l lr ls">def add_review():<br/>    data = request.get_json()<br/>    ...</span></pre><p id="cb83" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这就变成了，</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="8b5c" class="kg kh hu ll b fv lp lq l lr ls">async def add_review():<br/>    data = await request.get_json()<br/>    ...</span></pre><h2 id="0008" class="kg kh hu bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la dt translated">从psycopg2到asyncpg的演变</h2><p id="d556" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated">发展psycopg2代码以使用asyncpg要稍微复杂一些，因为两者有不同的用法。为了简化差异，Flask应用程序中使用了一个<code class="eh me mf mg ll b">PoolWrapper</code>来提供一个上下文管理的psycopg2连接，该连接使用与asyncpg相同的API，即<code class="eh me mf mg ll b">with pool.acquire() as connection:</code>。这允许通过将<code class="eh me mf mg ll b">with</code>更改为<code class="eh me mf mg ll b">async with</code>来使用asyncpg。</p><p id="cfa1" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">除了连接之外，Asyncpg和psycopg2在游标使用、事务、执行参数和查询格式上也有所不同。这些大多是不同的约定，细节最好在<a class="ae kf" href="https://github.com/pgjones/faster_than_flask_article/commit/0a70f2bddae90da13da5bce2b77ea56355ecc5d1" rel="noopener ugc nofollow" target="_blank"> diff </a>中考虑。</p><h2 id="d7aa" class="kg kh hu bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la dt translated">部署</h2><p id="2c48" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated">将Flask应用程序直接暴露给生产流量不太可能扩展，也不能真正代表典型的生产环境。这是因为Flask本身一次只能处理一个请求。相反，WSGI服务器通常与某种异步工作器结合使用，例如<a class="ae kf" href="https://github.com/benoitc/gunicorn" rel="noopener ugc nofollow" target="_blank"> Gunicorn </a>和<a class="ae kf" href="https://github.com/eventlet/eventlet" rel="noopener ugc nofollow" target="_blank"> eventlet </a>。</p><p id="b285" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Quart最好与Gunicorn一起部署，它允许使用相同的命令来运行Flask和Quart应用程序，</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="c4ae" class="kg kh hu ll b fv lp lq l lr ls">$ gunicorn --config gunicorn.py 'run:create_app()'</span></pre><p id="67b5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">配置文件<a class="ae kf" href="https://github.com/pgjones/faster_than_flask_article/commit/0a70f2bddae90da13da5bce2b77ea56355ecc5d1#diff-e61b1f0efe946725406491d0bb56c68b" rel="noopener ugc nofollow" target="_blank">与</a>的区别仅在于使用了哪个worker(event let用于Flask，Quart-UVLoop用于Quart)。</p><p id="7f36" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">性能测量是在Gunicorn后面运行Flask和Quart应用程序的情况下进行的。</p><h2 id="54da" class="kg kh hu bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la dt translated">数据库ˌ资料库</h2><p id="177a" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated">Postgresql <a class="ae kf" href="http://www.postgresqltutorial.com/postgresql-sample-database/" rel="noopener ugc nofollow" target="_blank">示例数据库</a>用于以一种粗鲁的方式给应用程序一些东西来对抗。除了添加一个简单的回顾表之外，</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="ed6c" class="kg kh hu ll b fv lp lq l lr ls">CREATE TABLE review (<br/>    film_id INTEGER REFERENCES film(film_id), <br/>    rating INTEGER<br/>);</span></pre><h1 id="23d9" class="lt kh hu bd ki lu lv lw km lx ly lz kq ja ma jb kt jd mb je kw jg mc jh kz md dt translated">性能测定</h1><p id="f7ef" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated">使用wrk 来测量应用程序<a class="ae kf" href="https://github.com/wg/wrk" rel="noopener ugc nofollow" target="_blank">的性能。它被配置为使用20个连接来匹配数据库连接池的大小(这应该确保最高的吞吐量，20是我使用的典型值)。为了测量GET请求，命令是:</a></p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="b7f6" class="kg kh hu ll b fv lp lq l lr ls">$ wrk --connections 20 --duration 5m http://localhost:5000/${PATH}/</span></pre><p id="d205" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">而对于POST请求，命令是，</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="54c8" class="kg kh hu ll b fv lp lq l lr ls">$ wrk --connections 20 --duration 5m --script post.lua http://localhost:5000/${PATH}/</span></pre><p id="6139" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">用post.lua文件定义<a class="ae kf" href="https://github.com/pgjones/faster_than_flask_article/blob/master/post.lua" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h2 id="e986" class="kg kh hu bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la dt translated">测试系统</h2><p id="202a" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated">数据库Postgres (9.5.10)、wrk (4.0.0)和apps Python (3.6.3)与需求asyncpg (0.13.0)、Flask (0.12.2)、Gunicorn (19.7.1)、psycopg2 (2.7.3.2)、Quart (0.3.1)都运行在一台AWS c4.large机器上。</p><h1 id="3eca" class="lt kh hu bd ki lu lv lw km lx ly lz kq ja ma jb kt jd mb je kw jg mc jh kz md dt translated">结果</h1><p id="1543" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated">全部结果如下表所示，</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="b2a6" class="kg kh hu ll b fv lp lq l lr ls">Route           | Requests per second | Average Latency [ms]  |<br/>                |   Flask  |   Quart  |   Flask   |   Quart   |<br/>---------------------------------------------------------------<br/>GET /films/995/ |   330.22 |  1160.27 |     60.55 |     17.23 |<br/>GET /films/     |    99.39 |   194.58 |    201.14 |    102.76 |<br/>POST /reviews/  |   324.49 |  1113.81 |     61.60 |     18.22 |</span></pre><p id="f775" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">请注意，四分之一服务器的每秒请求数增加了2到3.5倍，平均延迟相应减少了2到3.5倍。</p><h1 id="9bf0" class="lt kh hu bd ki lu lv lw km lx ly lz kq ja ma jb kt jd mb je kw jg mc jh kz md dt translated">结论</h1><p id="83ee" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated">从Flask应用程序到Quart应用程序的演变相当容易，因为共享API主要意味着在正确的位置编写<code class="eh me mf mg ll b">async</code> &amp; <code class="eh me mf mg ll b">await</code>的工作。然而，如果使用SQLAlchemy(或其他ORM ),从psycopg2到asyncpg的演变会更加复杂，可能会更麻烦。</p><p id="8b88" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">应用程序的性能明显提高。这一改进主要归功于Quart启用的asyncpg和uvloop的使用。据估计，仅Quart一项就能提供1.5倍的速度提升。</p><p id="644f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">总之，从Flask-psycopg2应用程序到Quart-asyncpg应用程序的过渡是相当容易的，并且给出了非常合理的性能改进。这可能会扩展到任何其他基于asyncio的库，这意味着Quart可以让Flask应用程序轻松过渡到asyncio生态系统。</p></div></div>    
</body>
</html>