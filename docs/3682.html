<html>
<head>
<title>Working Of Yarn and npm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">纱线和非织造布的加工</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/working-of-yarn-and-npm-974b79f10341?source=collection_archive---------7-----------------------#2017-04-17">https://medium.com/hackernoon/working-of-yarn-and-npm-974b79f10341?source=collection_archive---------7-----------------------#2017-04-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="9e6f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">作为一个Ember开发者，发现脸书的纱线包管理器是我能遇到的最好的事情。</p><p id="bc0a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每当我的开发伙伴遇到“花椰菜插件失败……”时，我会说“rm -rf node_modules”，这是我的前辈告诉我的，我延续了这个传统。</p><p id="2dc0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是非常令人沮丧的，作为一个初学者，我过去常常把这一切归咎于Ember，因为我不明白发生了什么。随着时间的推移，我意识到npm是罪魁祸首。但是几个月前，我发现了这个纱线包经理。当我找到它时，我读到它承诺解决最常见的“npm安装”错误。它声称它更好，因为它是:</p><p id="62cb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">确定性不同于npm。</p><p id="bcd5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">并行安装的网络性能。</p><p id="8864" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">与npm相同的软件包安装(它使用相同的注册表)。</p><p id="c53e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Yarn使用校验和来验证包的完整性。</p><p id="db2e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为它缓存了所有的软件包，所以即使在脱机状态下也可以运行。</p><p id="7eb3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Its最近获得了很多关注，所以它的功能可以在互联网上找到。你在互联网上不容易找到的是它如何实现这些伟大的功能。我最初并没有太注意npm装置是如何工作的，但随着我对纱线的了解，我变得很好奇，所以我决定深入研究，找出它们是如何工作的。希望有助于初学者更好的理解事物。</p><p id="a19d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">作为一个npm世界的初学者，我不知道下面的几个术语，所以我决定在这里添加它们，这样新来的人就不必谷歌每个单词，然后来回跳转。</p><h2 id="233e" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">1.包装</h2><p id="2368" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">它们是一种软件，可以从网上下载来完成某项任务。它们可能依赖于其他包。</p><h2 id="72a0" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">2.属国</h2><p id="0479" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">它们指定了应用程序使用的包。它们在像package.json这样的清单文件中指定。以下依赖关系可能表示如下:</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div class="fe ff kq"><img src="../Images/67b4943b17bae9b944634757469fc413.png" data-original-src="https://miro.medium.com/v2/resize:fit:414/format:webp/1*jMRNnIVnvCB63C_r-fy_uw.png"/></div></figure><p id="2f34" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">“依赖项”:{<br/>“a”:“1 . 0 . 0”，<br/>“b”:“1 . 0 . 0”<br/>}</p><p id="0ff4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">他们使用语义版本控制，即</p><p id="96c5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">I .给定版本号MAJOR.MINOR.PATCH</p><p id="dbaf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">二。主要版本当您进行不兼容的API更改时，</p><p id="05c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">三。当您以向后兼容的方式添加功能时，次要版本。</p><p id="ec6c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">四。补丁版本当你做向后兼容的bug修复。</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div class="fe ff ky"><img src="../Images/41fdbc622d8b6b47ebc68d42369566d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*OD6K3nFw2ga5jv3KxIaJZA.png"/></div></figure><p id="6bb6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它们遵循平面命名空间，这意味着所有不同的包被赋予相同的层次结构，除非它们有多个版本，那么在这种情况下，它们将在命名空间中被分配较低的级别，就像上面例子中的's^2.0.0'。</p><p id="b238" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以让我们从一个npm安装的例子开始，然后是yarn安装。我将保持这个例子简单但非常详细。</p><h2 id="d54f" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">假设</h2><p id="a946" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">这将是我们第一次安装package.json</p><p id="095a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">二。目前没有node_modules文件夹。</p><p id="e9be" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">三。没有预先缓存的包。</p><h2 id="29e8" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">软件包安装有三个阶段</h2><p id="0dcc" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated"><strong class="it hv">一、依赖关系解析</strong></p><p id="018c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">向注册表发出请求，递归地查找依赖项，并确定依赖项文件夹中软件包安装的位置。</p><p id="4c96" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">二。获取包</strong></p><p id="82dc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">获取压缩格式的包，并将它们放在全局缓存中。</p><p id="dd2c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">三世。链接包</strong></p><p id="9c17" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">将文件从全局缓存复制到本地node_modules文件夹。</p><p id="5e5e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也就是说，让我们看看当我们进行“npm安装”时，上述事情实际上是如何发生的。</p><p id="05a5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在考虑一个清单文件(package.json ),它包含以下简单的假设包。</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div class="fe ff kz"><img src="../Images/dd7ca43f41b4241b226099584c772663.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*_9Lp0epu0pqceH9LBS9Lnw.png"/></div></figure><p id="606c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">"依赖项":{ <br/> "a" : "1.0.0 "，<br/> "b" : "1.0.0" <br/> }</p><p id="a773" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将通过删除次要版本和补丁版本，只保留主要版本来使它变得更简单。留给我们的是:</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div class="fe ff la"><img src="../Images/9dde4780af3ac3c8ba60a7a434f25774.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*YHY60ltNItJTfT5mL-JldQ.png"/></div></figure><p id="d9be" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们对上述package.json文件进行“npm安装”时，npm会执行以下操作:</p><h2 id="3bcd" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">1.加载包:</h2><p id="d5d3" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">a.如果node_modules文件夹已经存在(即，您之前使用了“npm install”来创建npm_modules文件夹)，则使用它通过从光盘加载来创建理想树。</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div class="fe ff lb"><img src="../Images/fe3f7de4e9aef297525dde1805f8b79e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*dViRdLjYPGau6Af232YBUQ.png"/></div></figure><p id="f5c6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">b.克隆现有的树，以建立理想的树，这作为我们的应用程序的最终树。</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div class="fe ff lb"><img src="../Images/d54d04eab280a2064c224cb5cc61b632.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*usv429qUs8mBteMWdRAY1w.png"/></div></figure><p id="ed68" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">c.使用克隆树构建理想树，它将用于在node_modules文件夹中构建包文件夹。这可以在下面的快照中看到。</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div class="fe ff lb"><img src="../Images/5b3c0b12cacbeedf3492855ac1d95719.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*21uuLHHuo1-CYDxDBmAQdg.png"/></div></figure><p id="ccb0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，我们遇到“a1”包，它有另一个对“s1”的依赖，因为这是我们第一次看到它，所以我们遵循扁平结构，并将其作为“a1”和“b1”的公共依赖。这种结构允许我们将这个包重新用于可能依赖于“s1”的另一个包。</p><p id="880c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，当我们遇到“s2”时，它是同一个包的版本2，那么我们就不能遵循平面结构，因为同一个包不能驻留在同一个目录中。因此，我们认为它是“b1”的子文件夹，并且在“b1”中创建了“s2”的文件夹。<br/> <br/>这也告诉我们，当我们需要重用一个包的时候，我们需要把它放在另一个同名但版本不同的包的最上面，这个包可能不会被其他包重用。</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div class="fe ff lb"><img src="../Images/9a847237de60c1ca602b3b763db822ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*X81JVofUZRbRw9TXN3sMdg.png"/></div></figure><h2 id="2ece" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">2.依赖关系解析:</h2><p id="e9ff" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">a.基于理想树，npm检测哪些包需要安装，哪些已经安装。对于我们的情况，因为没有理想的，因为我们从零开始安装。</p><p id="7d1c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">b.它还解析子包和平面目录路径中使用的版本。</p><p id="c0bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">c.在这一步，npm知道哪些包需要安装在哪些文件夹中。</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div class="fe ff lb"><img src="../Images/615a679db0fee2a62c94969e41e9ba74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*LM_CG_RWNWvniutA_nP9zw.png"/></div></figure><h2 id="b59e" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">3.包获取和链接</h2><p id="a9e5" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">a.在这里，npm实际上是从npm registry获取包，并将它们安装在包的相应文件夹中。</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div class="fe ff lb"><img src="../Images/55a3fa76d95d82745cbc546a03e0eb4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*8sQmDT5MudPUqTp2wJ9H_A.png"/></div></figure><p id="d852" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是npm一直以来的做法，现在让我们来看看我们的新人Yarn要做些什么来让事情变得更好。</p><h2 id="82a2" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">1.依赖关系解析:</h2><p id="4c11" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">a.Yarn为清单文件创建了一个包请求列表。它首先检查包，然后将所需的版本添加到列表中。依赖性解析是一个包一个包地完成的。对于这个例子，它考虑“a1”。</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="fe ff lb"><img src="../Images/ebad1b5b57f99cab8a24ce1d9f18b677.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*W0QBtA8rtD-VdM-3Q1r5Dg.png"/></div></div></figure><p id="e7ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">b.现在我们已经有了包名和它的版本号，Yarn继续到npm存储库(Registry ),寻找与清单文件中提到的相同或更高版本的包。我们可以在package.json或manifest文件中提到需要获取的包。以下是用于指示需要获取哪个版本的符号。</p><p id="3bdf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">i. '~ ':它修复了主版本号和次版本号，同时匹配任何补丁号。《出埃及记》~2.1.0意味着获取高于2.1.0但低于2.2.0的任何内容。</p><p id="cfda" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">二。'^':它锁定主要版本，并寻找次要版本和补丁版本的最新版本。Ex ^2.1.0表示获取高于2.1.0且低于3.0.0的任何数据</p><p id="c265" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">三。*:它根据使用位置锁定大调或小调。例2。*表示低于版本3.0.0和2.0的任何版本。*表示小于2.1.0的任何值</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div class="fe ff lb"><img src="../Images/ebeec6f51e26f9772822ed662e89e90b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*m20z-HJ3NoxGuYp6TALepA.png"/></div></figure><p id="9ee1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">c.现在，Yarn在向注册表发出实际请求之前检查本地缓存。如果需要安装的包已经被其他包使用了，那么就没有必要再请求它了，因为它已经被yarn缓存起来以备后用。</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div class="fe ff lb"><img src="../Images/e5cb2f7778e9c4fbb20056c6270accda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*UWUFyWOd39PhIIx3hlu2ow.png"/></div></figure><p id="403e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">d.对每个包执行上述过程，然后具有需要提取的包的列表，因为它知道哪些包先前被提取并且被缓存。</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div class="fe ff lb"><img src="../Images/3b57fe900ae0abb024ea3accc87d351e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*20UTFun7qgATyE18yypu_g.png"/></div></figure><h2 id="cbf0" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">2.获取和链接</h2><p id="ce9e" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">a.现在，对包的请求已经发出，并从注册表中获取。以同样的方式，纱线获取其他包装。</p><p id="61b6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦获取了所有需要的包，Yarn就会像“npm”一样链接这些包。但是这里的链接有点复杂，因为Yarn需要链接缓存的和新获取的包。它需要将缓存的包复制到新的链接路径中。</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div class="fe ff lb"><img src="../Images/12548f9c610343bce8259ba6ade232d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*XWLASPVC48ldlri5Srhcfw.png"/></div></figure><h2 id="2f83" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">3.保存锁定文件</h2><p id="54e9" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">a.它用于准确地存储每个依赖项安装了哪个版本。它类似于npm的npm-shrinkwrap.json，但是它没有损耗，并且创建了可重复的结果。在Rails中，您有bundler来做类似的事情。它由Yarn管理，并在您每次添加/删除/更新现有包时进行更新。</p><p id="200d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">b.这个文件总是需要提交，因为它是Yarn能够跨系统维护包的完整性和一致性的唯一原因。所以是谁提交了这个文件，以及用这个文件提交了什么，这是很难做到的。破包提交可能导致在每个团队成员的机器上安装相同的破包。</p><p id="00b8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">c.它还起诉每个包的校验和，这有助于确保您的数据完整性得到维护。</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div class="fe ff lb"><img src="../Images/d29dcca3f82aad3385dcf4ed33dcb6f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*h9kPbSQKYCG0JA2VMvv8fQ.png"/></div></figure><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div class="fe ff lb"><img src="../Images/5c27d02f77211c4595e767dff7f4d705.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*MBTRsIubeBOjTcj3zjfmUg.png"/></div></figure><p id="bd17" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们知道了yarn是如何工作的，我想展示一下npm的一个主要缺点，并告诉你Yarn是如何解决它的。</p><p id="35fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我想展示在不同的机器上安装相同的包如何在npm中产生不同的node_modules文件夹，以及yarn如何通过维护一个锁文件来解决这个问题。</p><p id="d493" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在假设，Yehuda使用npm如下安装软件包</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div class="fe ff lb"><img src="../Images/41febeff99ed4926d135c06ff7833062.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*hXh6Xs-UQNzm6wNSHpamxw.png"/></div></figure><p id="cc17" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">考虑他决定将包“a”升级到“a2”。运行“npm安装”时，它会产生以下结构。</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div class="fe ff lb"><img src="../Images/4913ac3bb197a9b88d183a47ecc6e2fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*TCl9aj_0_83UlB94qw1bfw.png"/></div></figure><p id="a6dc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在假设耶胡达想与世界分享他的代码，人们开始使用上述软件包的“npm安装”。</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div class="fe ff lb"><img src="../Images/48c567153c1b7559b30443037d3a6bd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*94oBhZ1LsRQ8XjW_PXg7QA.png"/></div></figure><p id="ca18" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，正如我们所看到的，npm并没有跨系统维护一致的结构，但是Yarn就是为了解决这个唯一的问题而构建的。其余的功能只是一个插件。</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div class="fe ff lb"><img src="../Images/2419d5bebb57038514017124661792ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*6Lh7WI1C0oLq9JG7owChjQ.png"/></div></figure><p id="f084" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这可以通过清除“node_modules”文件夹来解决，但这不是最好的方法。事实上，重新安装软件包需要很长时间。</p><p id="6c74" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">包覆救援…..但是我在哪里能找到它？？？</p><p id="a1e0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它已经有npm，但默认情况下是禁用的，是有损耗的。所以即使是npm的人也不信任你。</p><p id="fe14" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在耶胡达发现了纱线，所以他决定试一试。</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div class="fe ff lb"><img src="../Images/d113c0fbaa78a8f36082e67d6b8b2b48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*MxuMuRTHRgZKw0VmJZRohg.png"/></div></figure><p id="19d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还有一个锁文件，即使在你运行“yarn install”时，它也能保持这种依赖关系。结果在每台机器上都是一致的。</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div class="fe ff lb"><img src="../Images/dc32b99e8702e84cc88e0bb80982c86d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*lE3ifnNqGWGcg5hUBzdVuw.png"/></div></figure><p id="d77a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，无论是谁进行“yarn install ”,他都会得到相同的依赖项，并且顺序完全相同，因为锁文件会被传送给每个人。</p><p id="af80" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">专业提示:永远不要忘记提交你的锁文件，因为它是所有用户的唯一真实来源。</p><p id="fd9b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们知道Yahuda非常聪明，所以他决定让Ember和Yarn之间的整合更加紧密。</p><p id="4a82" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">烬2.13现在是纱线意识，这意味着它生成锁文件，并鼓励你使用纱线。</p><div class="kr ks kt ku fq ab cb"><figure class="lg kv lh li lj lk ll paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="lg kv lh li lj lk ll paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="lg kv lh li lj lk ll paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="lm ln lo"><p id="f922" class="ir is lp it b iu iv iw ix iy iz ja jb lq jd je jf lr jh ji jj ls jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is lp it b iu iv iw ix iy iz ja jb lq jd je jf lr jh ji jj ls jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="fe ff lt"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>