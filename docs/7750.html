<html>
<head>
<title>Writing functional javascript without a 3rd party library.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在没有第三方库的情况下编写函数式javascript。</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/writing-functional-javascript-without-a-3rd-party-library-b2fd7862d93c?source=collection_archive---------8-----------------------#2017-11-07">https://medium.com/hackernoon/writing-functional-javascript-without-a-3rd-party-library-b2fd7862d93c?source=collection_archive---------8-----------------------#2017-11-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="322f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">大约一年前，我和一些同事合作创建我们自己的函数，而不是使用库来减小包的大小。虽然有一个选择是使用<a class="ae jp" href="https://webpack.js.org/guides/tree-shaking/" rel="noopener ugc nofollow" target="_blank">树摇动</a>，但是我们认为我们可以通过去掉一些随之而来的脚手架和样板文件来进一步减少树摇动，并且我有一个非常想尝试的想法。这是一个关于我如何试验原生Javascript并把它翻转成一个更具功能性的范例的故事，我有一个大约500字节的功能性迷你库。</p><p id="bdd6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">故事从一个场景开始，在我开车回家的路上，我想出了很多主意。当我在州际公路上行驶时，我想到了一个想法，<em class="jq">“如果我们创建一个对象，它只是在本质上使用已经存在的数组方法，但是它有currying，并且可以使用pipe和compose！”</em></p><p id="49b1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的意思是，所有的通用函数都是广泛可用的——像<em class="jq">贴图</em>、<em class="jq">减少</em>、<em class="jq">过滤</em>等等。我真正想做的唯一一件事是以某种方式“借用”他们已经优化的功能，而不是重写它们。</p><p id="1776" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我还发现，我们没有的、我真正想要并使其全部工作的唯一函数是<code class="eh jr js jt ju b">pipe</code>和<code class="eh jr js jt ju b">compose</code>——这将是我们的工具箱中真正唯一的“非本机”函数。</p><h2 id="8003" class="jv jw hu bd jx jy jz ka kb kc kd ke kf jc kg kh ki jg kj kk kl jk km kn ko kp dt translated">创建“白名单”</h2><p id="9aac" class="pw-post-body-paragraph ir is hu it b iu kq iw ix iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo hn dt translated">因为Javascript的<code class="eh jr js jt ju b">Array</code>对象有我需要的所有函数，我想我可以把它们取出来。为此，我从数组对象中创建了一个函数“白名单”:</p><pre class="kv kw kx ky fq kz ju la lb aw lc dt"><span id="4296" class="jv jw hu ju b fv ld le l lf lg"><em class="jq">const </em><strong class="ju hv">whitelist </strong>= ['concat', 'every', 'filter ', 'find ', 'includes', 'keys', 'map', 'reduce ', 'reduceRight', 'slice', 'some']</span></pre><p id="8978" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好吧！所以在仔细阅读了MDN文档，并且完全不介意浏览器兼容性<em class="jq">(至少现在还不介意！)</em>我试图“反转”(这里可能用错了术语)这些函数，这样它们就可以被<em class="jq">取悦</em>，这样你就可以用像<code class="eh jr js jt ju b">compose</code>或<code class="eh jr js jt ju b">pipe</code>这样的函数来处理它们</p><p id="6418" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">诀窍是创建一个新对象，并将数组的原型方法直接放在它上面。我想到的第一个名字是<code class="eh jr js jt ju b">Box</code>,灵感来自于布尔博士的关于理论家的系列文章</p><p id="8c13" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它还将使用来自<code class="eh jr js jt ju b">Array.prototype</code>的<code class="eh jr js jt ju b">getOwnPropertyNames</code>，查看在<strong class="it hv">原型</strong>上是否有任何匹配白名单的方法，如果有，将它们作为<code class="eh jr js jt ju b">Box</code>对象的一部分。</p><p id="0886" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将允许<em class="jq">不受支持的</em>方法保持原样:<code class="eh jr js jt ju b">undefined</code>——所以如果有人想要使用这个对象，他们并没有得到任何真正新的东西，只是以不同的方式使用他们已经拥有的相同功能。如果你需要一些额外的浏览器支持，你可以添加<strong class="it hv"> polyfill </strong>和<em class="jq">，然后</em>添加<code class="eh jr js jt ju b">Box</code>——我认为这是一个很好的主意！</p><pre class="kv kw kx ky fq kz ju la lb aw lc dt"><span id="77bf" class="jv jw hu ju b fv ld le l lf lg">const Box = {}<br/>Object<br/> .getOwnPropertyNames(Array.prototype)<br/> .filter(s =&gt; whitelist.includes(s))<br/> .forEach(method =&gt; {<br/> Box[method] = fn =&gt; a =&gt; a[method](fn)<br/> })</span></pre><p id="ba0b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以现在唯一剩下的事情就是添加管道和作曲:</p><p id="943e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(特别感谢<a class="lh li gr" href="https://medium.com/u/fd90c0774931?source=post_page-----b2fd7862d93c--------------------------------" rel="noopener" target="_blank">江武平·罗斯</a>写了这些有用的东西)</p><pre class="kv kw kx ky fq kz ju la lb aw lc dt"><span id="b57d" class="jv jw hu ju b fv ld le l lf lg">Box.compose = (...fns) =&gt; data =&gt; fns.reduce((value, fn) =&gt; fn(value), data)[0]<br/>Box.pipe = (...fns) =&gt; data =&gt; fns.reverse().reduce((value, fn) =&gt; fn(value), data)</span><span id="affd" class="jv jw hu ju b fv lj le l lf lg">module.exports = Box</span></pre><p id="fef0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好的，那么把这个功能强大的包放在一起，在一个大约500字节的很小的空间里，你有:</p><pre class="kv kw kx ky fq kz ju la lb aw lc dt"><span id="197f" class="jv jw hu ju b fv ld le l lf lg">// Let's pluck these methods off of Array.prototype<br/>const whitelist = ['concat', 'every', 'filter ', 'find ', 'includes', 'keys', 'map', 'reduce ', 'reduceRight', 'slice', 'some']</span><span id="268c" class="jv jw hu ju b fv lj le l lf lg"><br/>// We'll put them on a container Object<br/>const Box = {}</span><span id="950a" class="jv jw hu ju b fv lj le l lf lg"><br/>// So if any of the methods exist, we add them, if not, we just move on.<br/>Object<br/>  .getOwnPropertyNames(Array.prototype)<br/>  .filter(s =&gt; whitelist.includes(s))<br/>  .forEach(method =&gt; {<br/>    Box[method] = fn =&gt; a =&gt; a[method](fn)<br/>  })</span><span id="0836" class="jv jw hu ju b fv lj le l lf lg"><br/>// We'll create two functions that are our own for making things compositional<br/>Box.compose = (...fns) =&gt; data =&gt; fns.reduce((value, fn) =&gt; fn(value), data)[0]<br/>Box.pipe = (...fns) =&gt; data =&gt; fns.reverse().reduce((value, fn) =&gt; fn(value), data)</span><span id="ea9d" class="jv jw hu ju b fv lj le l lf lg">module.exports = Box</span></pre><figure class="kv kw kx ky fq ll fe ff paragraph-image"><div class="fe ff lk"><img src="../Images/e5f7c67fa8f984f2b04cbe1ddab4090e.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*mhw6HU8ZT5tiWWNa.png"/></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">Woah! That lambda right there means we are in functional territory!</figcaption></figure><p id="fd52" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">相当酷！那么，如何使用组合和管道函数呢？</p><p id="1bc7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是一个使用compose的示例</p><pre class="kv kw kx ky fq kz ju la lb aw lc dt"><span id="7878" class="jv jw hu ju b fv ld le l lf lg">compose(<br/>  // 42<br/>  reduce((acc, val) =&gt; val + acc),<br/>  // [12, 14, 16]<br/>  map(x =&gt; x * 2),<br/>  // [6, 7, 8]<br/>  filter(x =&gt; x &gt; 5),<br/>  // [0, 1, 2, 3, 4, 5, 6, 7, 8],<br/>  concat([6, 7, 8])<br/>  // [0, 1, 2, 3, 4, 5]<br/>)([1, 2, 3, 4, 5])</span></pre><p id="9443" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个人为的例子创建了一个函数，我们将一个数组[1，2，3，4，5]传递给它。然后，该函数从右向左传递参数(就像compose工作时一样)，结果是42:)</p><p id="36ea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们想从左向右读，我们可以使用管道:</p><pre class="kv kw kx ky fq kz ju la lb aw lc dt"><span id="8e9c" class="jv jw hu ju b fv ld le l lf lg">pipe(<br/>  map(x =&gt; x + 1),<br/>  // [1]<br/>  map(x =&gt; x + 1),<br/>  // [2]<br/>  map(x =&gt; x + 1),<br/>  // [3]<br/>)([0])</span></pre><p id="41cf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">像compose方法一样，这个pipe方法创建一个函数，它接受参数<code class="eh jr js jt ju b">[0]</code>，然后从左到右通过管道传递，传递过程中递增1。</p><p id="655b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以用这个做一些更好的事情，你不一定需要使用管道和合成，你可以做一个叫做<code class="eh jr js jt ju b">addTwo</code>的函数，它基本上是一个curried函数，增加两个参数，同样使用我们的函数化数组方法:</p><pre class="kv kw kx ky fq kz ju la lb aw lc dt"><span id="d6f6" class="jv jw hu ju b fv ld le l lf lg">const arrayOne = [1, 2, 3];<br/>const addTwo = concat([4, 5])<br/>const result = (addTwo(arrayOne))</span><span id="b444" class="jv jw hu ju b fv lj le l lf lg">console.log(result)<br/>// [1, 2, 3, 4, 5]</span></pre><p id="7582" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我希望有人会觉得这很有用，因为你真的可以不用库用javascript进行函数式编程！</p><p id="5790" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也就是说，库给了你额外的功能和向后兼容的支持。你甚至可以使用树抖动来减少bundlesize，所以我不能说够了，如果你想使用一个库，请这样做。但是，你可能会觉得这很有趣！</p><p id="e6b1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/trainyard/pico-lambda" rel="noopener ugc nofollow" target="_blank">我们最终把这个实验变成了一个库，</a>并且反复了很多次，修复了错误等等。我们还增加了字符串支持。我们最终得到的库叫做pico-lambda，看看吧(尤其是它的源代码，它很小！)，它也有大量的单元测试，并且它们也在主流浏览器的browserstack中运行。</p><p id="b730" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该说的都说了，该做的都做了，我们解决了边缘情况，修复了错误，添加了字符串，我们最终得到了一个稍微大一点的“盒子”</p><pre class="kv kw kx ky fq kz ju la lb aw lc dt"><span id="bccb" class="jv jw hu ju b fv ld le l lf lg">Object<br/>  .getOwnPropertyNames(Array.prototype)<br/>  .reduce((lambda, method) =&gt; {<br/>    lambda[method] = (~['concat', 'every', 'filter', 'find', 'findIndex', 'includes', 'join', 'map', 'reduce', 'reduceRight', 'slice', 'some'].indexOf(method))<br/>        ? (fn, ...params) =&gt; arr =&gt; arr[method](fn, ...params)<br/>        : (~['sort', 'copyWithin', 'fill'].indexOf(method))<br/>            ? (...params) =&gt; arr =&gt; [...arr][method](...params)<br/>            : (~['toLocaleString', 'indexOf', 'lastIndexOf'].indexOf(method))<br/>              ? (...params) =&gt; arr =&gt; arr[method](...params)<br/>              : (~['push', 'splice'].indexOf(method))<br/>                ? (...params) =&gt; arr =&gt; { var t = [...arr]; t[method](...params); return t; }<br/>                : (~['toString', 'entries', 'keys'].indexOf(method))<br/>                  ? arr =&gt; arr[method]()<br/>                  : lambda[method];<br/><a class="ae jp" href="https://github.com/trainyard/pico-lambda/blob/master/src/index.js" rel="noopener ugc nofollow" target="_blank">...full source here</a></span></pre><p id="cdf6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jq">感谢阅读，如果你喜欢，请鼓掌并跟我来。如果你想分享你的想法或有任何问题，也请留下你的评论！</em></p><p id="297d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt">❤</p></div></div>    
</body>
</html>