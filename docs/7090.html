<html>
<head>
<title>Object-oriented programming in vanilla JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">普通JavaScript中的面向对象编程</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/object-oriented-programming-in-vanilla-javascript-f3945b15f08a?source=collection_archive---------4-----------------------#2017-10-17">https://medium.com/hackernoon/object-oriented-programming-in-vanilla-javascript-f3945b15f08a?source=collection_archive---------4-----------------------#2017-10-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/00c6dadf2a6255b87ac98ebfbbd3a571.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LdilJoQXl8aLfkXbxtiYZw.png"/></div></div></figure><p id="6423" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>是一种强大的面向对象<a class="ae ka" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a> (OOP)语言，然而，与许多传统编程语言不同，它使用基于原型的OOP模型，这使得它的语法对大多数开发人员来说是陌生的。此外，JavaScript还将函数视为一级对象，这可能会让不熟悉这些概念的开发人员更加困惑。</p><p id="8fcf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">可以通过采用另一种编程语言来回避这些概念，例如TypeScript，它具有熟悉的语法并提供额外的功能，但是，这种语言无论如何都可以编译成普通的JavaScript，因此用这些知识武装自己不仅可以帮助您理解它们是如何工作的，还可以帮助您理解何时适合使用它们。</p><p id="381f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以下是我们将要涉及的主题列表:</p><p id="2d71" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">命名空间<br/>对象<br/>对象文字<br/>构造函数<br/>继承</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><h1 id="9c0a" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">命名空间</h1><p id="4081" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">随着web上第三方库、框架和依赖性的不断增加，命名空间对于JavaScript开发来说是必不可少的，因为我们试图避免全局命名空间中的对象和变量之间的冲突。</p><p id="658a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不幸的是，JavaScript没有内置的命名空间支持，但是我们可以使用对象来达到同样的效果。在JavaScript中实现名称空间有许多不同的模式，但是我们将讨论嵌套的名称空间，这当然是最常见的一种。</p><p id="0ab3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">嵌套命名空间模式使用一个对象文字将功能捆绑在一个惟一的、特定于应用程序的名称下。我们可以从创建一个全局对象开始，并像这样将它赋给一个变量:</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="7aa1" class="lu kj hu lq b fv lv lw l lx ly">var MyApp = MyApp || {};</span></pre><p id="3cc6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们也可以使用相同的技术来创建子名称空间:</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="a366" class="lu kj hu lq b fv lv lw l lx ly">MyApp.users = MyApp.user || {};</span></pre><p id="b799" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦我们有了一个容器，我们就可以用它来定义方法和属性，并在我们的全局命名空间中使用它们，而不会有与现有定义冲突的风险。</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="f091" class="lu kj hu lq b fv lv lw l lx ly">MyApp.users = {</span><span id="ca80" class="lu kj hu lq b fv lz lw l lx ly">    // properties</span><span id="e288" class="lu kj hu lq b fv lz lw l lx ly">    existingUsers: [...],</span><span id="3587" class="lu kj hu lq b fv lz lw l lx ly">    // methods</span><span id="0c68" class="lu kj hu lq b fv lz lw l lx ly">    renderUsersHTML: function() {<br/>      ...<br/>    }</span><span id="196c" class="lu kj hu lq b fv lz lw l lx ly">};</span></pre><p id="c013" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这里可以找到对JavaScript中命名空间模式的深入概述:<a class="ae ka" href="https://addyosmani.com/blog/essential-js-namespacing/#beginners" rel="noopener ugc nofollow" target="_blank">基本JavaScript命名空间模式</a>。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><h1 id="64bb" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">目标</h1><p id="b574" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">如果您曾经用JavaScript编写过代码，那么您已经在某种程度上使用了对象。JavaScript有三种不同类型的对象:</p><h2 id="c42e" class="lu kj hu bd kk ma mb mc ko md me mf ks jn mg mh kw jr mi mj la jv mk ml le mm dt translated">本地对象</h2><p id="4021" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">本机对象是语言规范的一部分。无论我们的JavaScript代码在哪个客户端上运行，它们都是可用的。本地对象的例子有:<code class="eh mn mo mp lq b">Array</code>、<code class="eh mn mo mp lq b">Date</code>和<code class="eh mn mo mp lq b">Math</code>。完整列表请参考<a class="ae ka" href="https://mzl.la/2bTppcQ" rel="noopener ugc nofollow" target="_blank"> JavaScript内置对象参考</a></p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="d373" class="lu kj hu lq b fv lv lw l lx ly">var users = Array(); // Array is a native object</span></pre><h2 id="1664" class="lu kj hu bd kk ma mb mc ko md me mf ks jn mg mh kw jr mi mj la jv mk ml le mm dt translated">宿主对象</h2><p id="4469" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">与本地对象不同，主机对象是由运行JavaScript代码的客户端提供的。不同的客户端有不同的主机对象，在大多数情况下，这些对象允许我们与它进行交互。例如，如果我们为一个浏览器编写代码，它为我们提供了宿主对象，比如:<code class="eh mn mo mp lq b">window</code>、<code class="eh mn mo mp lq b">document</code>、<code class="eh mn mo mp lq b">location</code>和<code class="eh mn mo mp lq b">history</code>。</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="e2e2" class="lu kj hu lq b fv lv lw l lx ly">document.body.innerHTML = 'Hello'; // document is a host object</span></pre><h2 id="e297" class="lu kj hu bd kk ma mb mc ko md me mf ks jn mg mh kw jr mi mj la jv mk ml le mm dt translated">用户对象</h2><p id="b7d2" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">用户对象——有时也称为贡献对象——是我们在运行时定义的自定义对象。在JavaScript中有两种方法来声明我们自己的对象，接下来我们将介绍它们。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><h1 id="560e" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">对象文字</h1><p id="40f9" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">在讨论命名空间时，我们已经讨论了对象文字，但是现在是时候给出一个清晰的定义了:对象文字是用大括号括起来的逗号分隔的名称-值对列表。它们可以捆绑属性和方法，像JavaScript中的任何其他对象一样，它们可以传递给函数，也可以从函数返回。下面是另一个对象文字的例子:</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="588e" class="lu kj hu lq b fv lv lw l lx ly">var dog = {</span><span id="fa44" class="lu kj hu lq b fv lz lw l lx ly">  // properties</span><span id="ffe1" class="lu kj hu lq b fv lz lw l lx ly">  breed: ‘Bulldog’,</span><span id="9d28" class="lu kj hu lq b fv lz lw l lx ly">  // methods</span><span id="6a57" class="lu kj hu lq b fv lz lw l lx ly">  bark: function() {</span><span id="ba47" class="lu kj hu lq b fv lz lw l lx ly">    console.log(“Woof!”);</span><span id="cb06" class="lu kj hu lq b fv lz lw l lx ly">  },</span><span id="7cc1" class="lu kj hu lq b fv lz lw l lx ly">};</span><span id="1207" class="lu kj hu lq b fv lz lw l lx ly">// accessing methods and properties</span><span id="028b" class="lu kj hu lq b fv lz lw l lx ly">dog.bark();</span></pre><p id="89e2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对象文字是单值的。它们最常见的用途是封装代码并将其封装在一个整洁的包中，以避免与全局范围(命名空间)内的变量和对象发生冲突，并将配置传递给插件和对象。</p><p id="fd97" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对象文字是有用的，但它们不能被实例化或继承。如果我们想利用这些特性，我们需要探索用JavaScript创建对象的另一种方法。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><h1 id="a2fe" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">构造函数</h1><p id="de99" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">JavaScript中的函数被视为一等公民，这意味着它们支持其他实体可用的相同操作。用JavaScript术语来说，这意味着函数可以在运行时构造，作为参数传递，从其他函数返回，以及赋给变量。此外，它们可以有自己的属性和方法。这允许我们使用函数作为对象，使<em class="mq">可以被</em>实例化和继承。</p><p id="26ba" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是一个使用构造函数定义对象的示例:</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="7471" class="lu kj hu lq b fv lv lw l lx ly">function User( name, email ) {</span><span id="1109" class="lu kj hu lq b fv lz lw l lx ly">  // properties</span><span id="e23d" class="lu kj hu lq b fv lz lw l lx ly">  this.name = name;<br/>  this.email = email;</span><span id="6995" class="lu kj hu lq b fv lz lw l lx ly">  // methods</span><span id="cb03" class="lu kj hu lq b fv lz lw l lx ly">  this.sayHey = function() {</span><span id="a08c" class="lu kj hu lq b fv lz lw l lx ly">   console.log( “Hey, I’m “ + this.name );</span><span id="4b89" class="lu kj hu lq b fv lz lw l lx ly">  };</span><span id="eb28" class="lu kj hu lq b fv lz lw l lx ly">}</span><span id="8c15" class="lu kj hu lq b fv lz lw l lx ly">// instantiating the object</span><span id="ddf1" class="lu kj hu lq b fv lz lw l lx ly">var steve = new User( “Steve”, “steve@hotmail.com” );</span><span id="6b92" class="lu kj hu lq b fv lz lw l lx ly">// accessing methods and properties</span><span id="03a7" class="lu kj hu lq b fv lz lw l lx ly">steve.sayHey();</span></pre><p id="c984" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">创建构造函数类似于创建常规函数，只有一点不同:我们使用<code class="eh mn mo mp lq b">this</code>关键字来声明属性和方法。</p><p id="5475" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用<code class="eh mn mo mp lq b">new</code>关键字实例化构造函数类似于在传统的基于类的编程语言中实例化对象，然而，有一个问题可能一开始并不明显。</p><p id="9bc7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我们在JavaScript中使用<code class="eh mn mo mp lq b">new</code>关键字创建新对象时，我们一次又一次地运行函数块，这导致我们的脚本每次都为每个方法声明匿名函数。这将导致我们的程序消耗更多的内存，这可能会严重影响性能，这取决于程序的规模。</p><p id="2e2d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">幸运的是，有一种更好的方法可以将方法附加到构造函数上，而不会污染全局范围。</p><h2 id="65b7" class="lu kj hu bd kk ma mb mc ko md me mf ks jn mg mh kw jr mi mj la jv mk ml le mm dt translated">方法和原型</h2><p id="5c49" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">JavaScript是一种原型编程语言，这意味着我们可以使用原型作为对象的模板。这将帮助我们在扩展应用程序时避免匿名函数陷阱。<code class="eh mn mo mp lq b">prototype</code>是JavaScript中的一个特殊属性，允许我们向对象添加新方法。</p><p id="64d5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是我们之前使用原型的例子的改写:</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="ab4e" class="lu kj hu lq b fv lv lw l lx ly">function User( name, email ) {</span><span id="d7ad" class="lu kj hu lq b fv lz lw l lx ly">  // properties</span><span id="a44f" class="lu kj hu lq b fv lz lw l lx ly">  this.name = name;<br/>  this.email = email;</span><span id="bd9b" class="lu kj hu lq b fv lz lw l lx ly">}</span><span id="bdab" class="lu kj hu lq b fv lz lw l lx ly">// methods</span><span id="0c00" class="lu kj hu lq b fv lz lw l lx ly">User.prototype.sayHey = function() {</span><span id="0375" class="lu kj hu lq b fv lz lw l lx ly">  console.log( “Hey, I’m “ + this.name );</span><span id="94bf" class="lu kj hu lq b fv lz lw l lx ly">}</span><span id="1667" class="lu kj hu lq b fv lz lw l lx ly">// instantiating the object</span><span id="74ab" class="lu kj hu lq b fv lz lw l lx ly">var steve = new User( “Steve”, “steve@hotmail.com” );</span><span id="d599" class="lu kj hu lq b fv lz lw l lx ly">// accessing methods and properties</span><span id="c85c" class="lu kj hu lq b fv lz lw l lx ly">steve.sayHey();</span></pre><p id="32b4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这个例子中，<code class="eh mn mo mp lq b">sayHey()</code>将被<code class="eh mn mo mp lq b">User</code>对象的所有实例共享。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><h1 id="6827" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">遗产</h1><p id="d37a" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">原型也通过原型链用于继承。在JavaScript中，每个对象都有一个原型，因为原型只是另一个对象，所以它也有一个原型，以此类推……直到我们得到一个值为<code class="eh mn mo mp lq b">null</code>的原型——原型链中的最后一环。</p><p id="a18f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我们访问一个方法或属性时，JavaScript检查它是否在对象定义中定义，如果不是，它将检查原型并查看它是否在那里定义。如果它也不能在那里找到它，它将继续沿着原型链向下，直到找到它，或者直到它到达链的末端。</p><p id="1025" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它是这样工作的:</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="35a9" class="lu kj hu lq b fv lv lw l lx ly">// the user object</span><span id="32e6" class="lu kj hu lq b fv lz lw l lx ly">function User( name, email, role ) {</span><span id="ebb1" class="lu kj hu lq b fv lz lw l lx ly">  this.name = name;<br/>  this.email = email;<br/>  this.role = role;</span><span id="4aac" class="lu kj hu lq b fv lz lw l lx ly">}</span><span id="336e" class="lu kj hu lq b fv lz lw l lx ly">User.prototype.sayHey = function() {</span><span id="79fc" class="lu kj hu lq b fv lz lw l lx ly">  console.log( “Hey, I’m an “ + role);</span><span id="5924" class="lu kj hu lq b fv lz lw l lx ly">}</span><span id="71f3" class="lu kj hu lq b fv lz lw l lx ly">// the editor object inherits from user</span><span id="f59a" class="lu kj hu lq b fv lz lw l lx ly">function Editor( name, email ) {</span><span id="3342" class="lu kj hu lq b fv lz lw l lx ly">   // The Call function is calling the Constructor of User<br/>   // and decorates Editor with the same properties</span><span id="d2e4" class="lu kj hu lq b fv lz lw l lx ly">   User.call(this, name, email, "admin"); </span><span id="3081" class="lu kj hu lq b fv lz lw l lx ly">}</span><span id="3cb7" class="lu kj hu lq b fv lz lw l lx ly">// To set up the prototype chain, we create a new object using<br/>// the User prototype and assign it to the Editor prototype</span><span id="2f7b" class="lu kj hu lq b fv lz lw l lx ly">Editor.prototype = Object.create( User.prototype );</span><span id="f042" class="lu kj hu lq b fv lz lw l lx ly">// Now we can access all the properties and methods<br/>// of User from the Editor object</span><span id="5753" class="lu kj hu lq b fv lz lw l lx ly">var david = new Editor( "David", "matthew@medium.com" );</span><span id="89d2" class="lu kj hu lq b fv lz lw l lx ly">david.sayHey();</span></pre><p id="1598" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">原型继承可能需要一些时间来适应，但是为了掌握普通JavaScript中的OOP，这是一个重要的概念。虽然它经常被认为是JavaScript的弱点之一，但原型继承模型实际上比经典模型更强大。例如，在原型模型之上构建一个经典的继承模型是相当简单的。</p><p id="63da" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="mq"> ECMAScript 6引入了一组新的关键字实现</em> <a class="ae ka" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" rel="noopener ugc nofollow" target="_blank"> <em class="mq">类</em> </a> <em class="mq">。虽然这些构造看起来像基于类的语言，但它们并不相同。JavaScript仍然是基于原型的。</em></p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><p id="3daa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">JavaScript已经发展了很长一段时间，在此期间，许多开发人员已经采用了当今标准应该避免的不同实践。随着ES2015的推出，这种情况开始慢慢改变，但是，许多开发人员仍然坚持他们的老方法，这损害了他们代码的相关性。理解并应用JavaScript中的OOP编程对于编写可持续的代码是必不可少的，我希望这篇简短的介绍能帮助你实现这一点。</p><figure class="ll lm ln lo fq iv"><div class="bz el l di"><div class="mr ms l"/></div></figure></div></div>    
</body>
</html>