<html>
<head>
<title>Reconciling Backend Templates with Frontend Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">协调后端模板和前端组件</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/reconciling-djangos-mvc-templates-with-react-components-3aa986cf510a?source=collection_archive---------1-----------------------#2017-02-03">https://medium.com/hackernoon/reconciling-djangos-mvc-templates-with-react-components-3aa986cf510a?source=collection_archive---------1-----------------------#2017-02-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="c3e1" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">如何在不制作单页应用程序的情况下构建前端</h2></div><p id="177f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在$startupNameHere，我们决定用Django编写后端，用React编写前端。这种组合如今并不罕见，但如果你曾经尝试过，你可能会发现后端模板系统的页面组合和React的组件模型之间存在一些摩擦。</p><p id="de7d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最根本的问题是Django希望您使用模板片段构建页面，而React希望将您带入以JS组件为主要构建块的世界。Rails、Flask和任何其他使用模板的后端框架也会出现这种冲突。</p><figure class="kg kh ki kj fq kk fe ff paragraph-image"><div class="fe ff kf"><img src="../Images/b5fa23517c2f3276e08a23bc8add20b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*B-kFzr8f4OF9rr6Ueg-UFg.png"/></div></figure><p id="9a24" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我在这里告诉你这些不一定要冲突，有可能两者都用而不激怒小人国。</p></div><div class="ab cl kn ko hc kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hn ho hp hq hr"><h1 id="e7e7" class="ku kv hu bd kw kx ky kz la lb lc ld le ja lf jb lg jd lh je li jg lj jh lk ll dt translated">放弃SPA，拥抱页面组件</h1><p id="c58a" class="pw-post-body-paragraph jj jk hu jl b jm lm iv jo jp ln iy jr js lo ju jv jw lp jy jz ka lq kc kd ke hn dt translated">我们的解决方案是放弃单页面应用模型，而是让Django单独为每个页面提供服务，为每个页面提供一个根React组件。Django模板提供了不会在页面之间改变的基本站点组件(如导航条、页脚),而特定于每个页面的内容(如扑克界面、排行榜)是在React中编写的。</p><blockquote class="lr ls lt"><p id="f483" class="jj jk lu jl b jm jn iv jo jp jq iy jr lv jt ju jv lw jx jy jz lx kb kc kd ke hn dt translated">抛弃SPA，为什么会说出这么恐怖的话？！</p></blockquote><ul class=""><li id="158e" class="ly lz hu jl b jm jn jp jq js ma jw mb ka mc ke md me mf mg dt translated"><strong class="jl hv">单页面应用并不总是解决方案</strong>，通过让Django处理页面样板和路由，我们已经获得了稳定性(错误仅限于一个页面)、更容易的调试、更容易的搜索引擎索引和更容易的静态页面管理</li><li id="944a" class="ly lz hu jl b jm mh jp mi js mj jw mk ka ml ke md me mf mg dt translated">当您在Django模板中有了所有的页面样板时，为静态内容(例如关于页面、登录页面)创建非React页面就容易多了</li><li id="40b2" class="ly lz hu jl b jm mh jp mi js mj jw mk ka ml ke md me mf mg dt translated">不需要处理React路由器，历史API，或者在幕后异步获取页面内容(更多关于我们如何在不刷新页面的情况下进行页面热加载的内容将在后面的文章中介绍)</li></ul><blockquote class="lr ls lt"><p id="8dcd" class="jj jk lu jl b jm jn iv jo jp jq iy jr lv jt ju jv lw jx jy jz lx kb kc kd ke hn dt translated">那么这在实践中是什么样的呢？</p></blockquote><h1 id="1934" class="ku kv hu bd kw kx mm kz la lb mn ld le ja mo jb lg jd mp je li jg mq jh lk ll dt translated">Django模板</h1><p id="0e75" class="pw-post-body-paragraph jj jk hu jl b jm lm iv jo jp ln iy jr js lo ju jv jw lp jy jz ka lq kc kd ke hn dt translated">这里我们有一个用于React页面的基本模板，注意它是如何扩展ui/base.html的(它包含了我们的标题、导航条和所有放在基本模板中的常用内容)。</p><figure class="kg kh ki kj fq kk fe ff paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="fe ff mr"><img src="../Images/28ded1e9bb80dc3428f1dd8fdb67a1ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WVYdIiAszvP_zEqoLKEiDg.png"/></div></div></figure><p id="5656" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个基本模板可以接受JS组件文件和props的任意组合。如果你想你甚至不必传递一个React组件，你可以传递一个Vue.js或Angular脚本，让它渲染到<code class="eh mw mx my mz b">window.react_mount</code>并读取<code class="eh mw mx my mz b">window.props</code>。</p><figure class="kg kh ki kj fq kk"><div class="bz el l di"><div class="na nb l"/></div></figure><blockquote class="lr ls lt"><p id="3913" class="jj jk lu jl b jm jn iv jo jp jq iy jr lv jt ju jv lw jx jy jz lx kb kc kd ke hn dt translated">但是这个页面是空的，我如何渲染我的React组件？</p></blockquote><p id="1c56" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh mw mx my mz b">{{component}}</code>是一个脚本的路径，例如<code class="eh mw mx my mz b">leaderboard.js</code>，它包含一个标准的React组件，使用ReactDOM呈现。该脚本应该已经编译好，并且可以通过浏览器从staticfiles文件夹中访问。它可以被你的后端和nginx主动缓存，因为内容从不改变，所有动态内容都通过<code class="eh mw mx my mz b">window.props</code>传递。</p><p id="c033" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">到目前为止，这给了我们一个带有导航条和加载消息的基本页面。一旦我们有一个组件要挂载，加载消息就会被组件替换(这个过程发生得如此之快，以至于您的用户永远不会看到加载组件…消息)。</p><h1 id="e144" class="ku kv hu bd kw kx mm kz la lb mn ld le ja mo jb lg jd mp je li jg mq jh lk ll dt translated">反应组分</h1><p id="a479" class="pw-post-body-paragraph jj jk hu jl b jm lm iv jo jp ln iy jr js lo ju jv jw lp jy jz ka lq kc kd ke hn dt translated">现在我们定义一个布局页面的基本React组件。我们可以从其他JS文件中导入可重用的组件，或者只是将它们全部写在一个文件中。为了简单起见，我将在这里这样做。一个更复杂的页面可能会挂载一个redux Provider，导入几十个组件，或者在这里设置websocket连接。可以把它看作是您的'<code class="eh mw mx my mz b">base.js</code>'入口点，类似于SPA <code class="eh mw mx my mz b">base.js</code>，只不过它只定义了一个页面的内容。</p><p id="203d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里我实现了一个简单的排行榜，它显示了用户列表。</p><figure class="kg kh ki kj fq kk"><div class="bz el l di"><div class="na nb l"/></div></figure><h2 id="f32a" class="nc kv hu bd kw nd ne nf la ng nh ni le js nj nk lg jw nl nm li ka nn no lk np dt translated">构建Javascript组件</h2><p id="1f7f" class="pw-post-body-paragraph jj jk hu jl b jm lm iv jo jp ln iy jr js lo ju jv jw lp jy jz ka lq kc kd ke hn dt translated">我们使用<a class="ae nq" href="http://browserify.org/" rel="noopener ugc nofollow" target="_blank"> browserify </a>将这个源文件从ES6编译成古JS，并把它放在我们的staticfiles文件夹中，这样就可以很容易地提供(和缓存)它。为了简单起见，我选择了browserify，但是您可以在您的项目中使用webpack并获得相同的结果。</p><p id="03f0" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh mw mx my mz b">browserify src/pages/leaderboard.js &gt; static/src/pages/leaderboard.js</code></p><p id="9efb" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">太好了，现在屏幕上有东西了！</p><figure class="kg kh ki kj fq kk fe ff paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="fe ff nr"><img src="../Images/ec61a0d7fa0e904e745b9917d788c6a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wRKrVOiG61f1IfD_eIhBuA.png"/></div></div></figure><blockquote class="lr ls lt"><p id="f0ad" class="jj jk lu jl b jm jn iv jo jp jq iy jr lv jt ju jv lw jx jy jz lx kb kc kd ke hn dt translated">但是Alice &amp; Bob是从哪里来的，我们是怎么把数据传递给模板的？</p></blockquote><h1 id="5eff" class="ku kv hu bd kw kx mm kz la lb mn ld le ja mo jb lg jd mp je li jg mq jh lk ll dt translated">景色</h1><p id="d75a" class="pw-post-body-paragraph jj jk hu jl b jm lm iv jo jp ln iy jr js lo ju jv jw lp jy jz ka lq kc kd ke hn dt translated">Django视图只需要向react_base.html模板提供以下上下文，就可以正确地呈现这个页面:</p><ol class=""><li id="3418" class="ly lz hu jl b jm jn jp jq js ma jw mb ka mc ke ns me mf mg dt translated"><code class="eh mw mx my mz b">component</code> = <code class="eh mw mx my mz b">leaderboard.js</code>(上面我们的React文件)</li><li id="8710" class="ly lz hu jl b jm mh jp mi js mj jw mk ka ml ke ns me mf mg dt translated"><code class="eh mw mx my mz b">props</code> = <code class="eh mw mx my mz b">{users: [{username: ‘alice’}, {username: ‘bob’}]}</code>(作为道具传递给React组件的数据)</li><li id="850b" class="ly lz hu jl b jm mh jp mi js mj jw mk ka ml ke ns me mf mg dt translated"><code class="eh mw mx my mz b">title</code> = <code class="eh mw mx my mz b">‘Leaderboard’</code>(用于浏览器标签标题)</li></ol><figure class="kg kh ki kj fq kk"><div class="bz el l di"><div class="na nb l"/></div></figure><h1 id="c6c7" class="ku kv hu bd kw kx mm kz la lb mn ld le ja mo jb lg jd mp je li jg mq jh lk ll dt translated">为什么使用这种模式，有其他选择吗？</h1><p id="d602" class="pw-post-body-paragraph jj jk hu jl b jm lm iv jo jp ln iy jr js lo ju jv jw lp jy jz ka lq kc kd ke hn dt translated">这种在基本模板中安装组件的简单模式非常强大，它传递要反应的东西。它允许您自由地混合和匹配模板组合与React组件，这取决于您对给定页面的需求。</p><blockquote class="lr ls lt"><p id="4d14" class="jj jk lu jl b jm jn iv jo jp jq iy jr lv jt ju jv lw jx jy jz lx kb kc kd ke hn dt translated">但是我们已经在一个复杂的REST API上构建了我们的整个前端，从用户信息到页面内容都有端点，为什么这样更好呢？</p></blockquote><p id="a7ce" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你已经有了一个基于REST API的SPA，不要去重写你的整个前端。使用REST API + SPA可以获得一些使用page-as-a-component无法获得的优势，比如减少了包的大小，因为webpack可以跨页面优化共享代码。如果将后端功能拆分成单独的微服务，也可能更容易扩展。如果您对稍微大一点的包没问题，那么页面作为组件的方法是很好的，这样可以获得灵活性以及与Django模板和路由的良好交互。</p><blockquote class="lr ls lt"><p id="4a31" class="jj jk lu jl b jm jn iv jo jp jq iy jr lv jt ju jv lw jx jy jz lx kb kc kd ke hn dt translated">如果我现在从头开始开发一个应用程序，我有什么选择？</p></blockquote><ul class=""><li id="ba57" class="ly lz hu jl b jm jn jp jq js ma jw mb ka mc ke md me mf mg dt translated"><strong class="jl hv"> SPA +粒度API: </strong>使用Django作为REST API后端，并通过API端点提供所有页面数据，这些数据由一个单片SPA React应用程序查询(这是我在网上看到教得最多的方法)。这种方法对于微服务风格的后端来说非常好，因为前端并不关心后端是如何构建的，或者它到达了什么端点，只要它获得了所需的数据。<br/> - <em class="lu"> Webpack针对这种方法进行了优化。<br/> -前端可以建立在许多独立的微服务端点之上<br/> -前端处理路由&amp;切换到新页面<br/> -很难确定服务器端渲染(可能对搜索索引不利)<br/> -在不良连接上加载缓慢，因为数据需要多次往返</em></li><li id="a92f" class="ly lz hu jl b jm mh jp mi js mj jw mk ka ml ke md me mf mg dt translated"><strong class="jl hv"> SPA + 1个每页请求API: </strong>将每个页面的数据作为一个请求提供，前端仍然处理路由，但后端是用每页一个视图构建的，而不是许多更小的REST API端点。这样开始通常比为每个查询公开单独的端点更容易，但是它相当紧密地耦合了后端&amp;前端逻辑。<br/> - <em class="lu">前端处理路由&amp;切换到新页面</em> <br/> - <em class="lu">前端几乎依赖于来自一个端点的所有数据<br/> -加载时间更快，比拥有单独端点更容易缓存<br/> -更容易进行服务器端渲染，因为视图与前端数据匹配<br/> -在不良连接上表现不错，但仍需要2次往返</em></li><li id="0a88" class="ly lz hu jl b jm mh jp mi js mj jw mk ka ml ke md me mf mg dt translated"><strong class="jl hv">模板化的JS片段:</strong>使用模板系统编写React组件，通过包含JS代码片段来构建呈现所需页面的html模板(而不是挂载一个包含JS中定义的整个页面的组件文件)。根据我的经验，这种方法需要最大的haxxing，因为您完全忽略了JS导入的好处，并且破坏了您的lint页面、缩小JS以及将页面编译为所需的最小JS量的能力。这是像<a class="ae nq" href="https://github.com/Frojd/django-react-templatetags" rel="noopener ugc nofollow" target="_blank">django-react-template tags</a>这样的库使用的方法，它允许服务器端渲染，但是它引入了很多复杂性(包括一个节点服务器！)到你的后端。<br/> - <em class="lu">不需要AJAX请求，所有数据由页面提供</em>-<br/>-<em class="lu">后端处理所有路由，前端链接是正常的href<br/>-服务器端呈现非常容易，数据全部由一个视图提供，片段可以独立呈现并缓存<br/> -容易在逐段的基础上用react组件替换non-react组件<br/> -加载速度非常快，呈现的片段可以缓存并与其数据一起提供(非常适合搜索索引)【T33</em></li><li id="927d" class="ly lz hu jl b jm mh jp mi js mj jw mk ka ml ke md me mf mg dt translated"><strong class="jl hv">页面组件</strong>(我们的方法):用JS编写页面，将每个页面作为可缓存的<code class="eh mw mx my mz b">&lt;script&gt;</code>包含在模板中，通过props传递数据。这种方法结合了两者的优点，您可以在React中进行页面合成，同时还可以轻松地在服务器端呈现和缓存整个页面。当您没有单独的react片段时，管理数据流也更容易，因为所有组件都是从一个挂载点向下分层布局的。<br/> <em class="lu"> -稍微更难将&amp;匹配模板片段与React组件<br/></em>-<em class="lu">-比</em>模板化JS片段更可定制-<em class="lu">构建过程<br/> - <em class="lu">灵活，同样适用于Vue.js或Angular <br/>等非React页面-更易于管理数据流bc。单个JS入口点(esp。with redux) <br/> -如果脚本包被缓存，则加载1个往返页面</em></em></li><li id="e023" class="ly lz hu jl b jm mh jp mi js mj jw mk ka ml ke md me mf mg dt translated">有你的团队使用但我没有提到的模式吗？<em class="lu">我一直在寻找新的，联系我@theSquashSH，我会在这里收录。</em></li></ul><h1 id="21bf" class="ku kv hu bd kw kx mm kz la lb mn ld le ja mo jb lg jd mp je li jg mq jh lk ll dt translated">扩展页面作为组件模式</h1><blockquote class="lr ls lt"><p id="acf5" class="jj jk lu jl b jm jn iv jo jp jq iy jr lv jt ju jv lw jx jy jz lx kb kc kd ke hn dt translated">好吧，小人国的人对这个设计很满意，但是他们想要更多的功能！</p></blockquote><p id="89de" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">上面的代码示例过于简化。2017年的真正应用程序可能会安装Redux提供程序，创建WebSocket连接，通过网络获取内容，并导入几十个组件来组装一个完整的页面。</p><p id="19ba" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">既然我已经介绍了一个基本模式，是时候考虑用下一层功能来扩展它了。根据您的应用，您可以决定添加:</p><ul class=""><li id="81b9" class="ly lz hu jl b jm jn jp jq js ma jw mb ka mc ke md me mf mg dt translated">Django端更高级、可扩展的页面视图</li><li id="5bbc" class="ly lz hu jl b jm mh jp mi js mj jw mk ka ml ke md me mf mg dt translated">添加一些所有页面共享的属性(如当前用户信息、查看语言、时区、<code class="eh mw mx my mz b">get_base_props(request)</code>)</li><li id="1845" class="ly lz hu jl b jm mh jp mi js mj jw mk ka ml ke md me mf mg dt translated">用于<a class="ae nq" href="https://hackernoon.com/shape-your-redux-store-like-your-database-98faa4754fd5" rel="noopener ugc nofollow" target="_blank">管理前端状态</a>的冗余存储</li><li id="8da8" class="ly lz hu jl b jm mh jp mi js mj jw mk ka ml ke md me mf mg dt translated"><strong class="jl hv"> WebSocket使用django-channels </strong>连接到Django，其中处理程序代码位于页面视图的旁边(查看我们的<a class="ae nq" href="https://github.com/Monadical-SAS/django-channels-router" rel="noopener ugc nofollow" target="_blank"> django-channels-router </a>库)</li><li id="444d" class="ly lz hu jl b jm mh jp mi js mj jw mk ka ml ke md me mf mg dt translated">实时更新的<a class="ae nq" href="https://github.com/Monadical-SAS/redux-time" rel="noopener ugc nofollow" target="_blank">反应动画</a>与后端时间同步</li><li id="f2d5" class="ly lz hu jl b jm mh jp mi js mj jw mk ka ml ke md me mf mg dt translated">点击链接而不刷新时，热加载新页面。这是用<code class="eh mw mx my mz b">react-router</code>做SPA的一个优点，但是我们不需要做完全的SPA就可以非常接近。通过向&lt;主体&gt; <br/> 2追加一个新的脚本标签来加载下一个页面的JS组件文件。以JSON响应的形式查询一个服务于该页面道具的端点，并将它们保存到<code class="eh mw mx my mz b">window.props</code> <br/> 3。使用:<br/> <code class="eh mw mx my mz b">ReactDOM.render(&lt;NewPage {...window.props}/&gt;, window.react_mount)</code> <br/>呈现新页面热加载可能很难正确完成，当加载JS脚本和查询API端点时，很难干净地从错误中恢复并返回到正常导航，这可能会以多种方式独立失败。您可能还需要修改历史API，以便在导航时更改URL和浏览器标题。</li></ul><p id="60d2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你有任何问题，可以在twitter @theSquashSH上联系我，或者在<a class="ae nq" href="https://oddslingers.com" rel="noopener ugc nofollow" target="_blank">https://oddslingers.com</a>查看我们的网站！</p><p id="3429" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在我们的应用程序(一个扑克网站)中，我们使用<code class="eh mw mx my mz b">django-channels</code>通过WebSockets向<code class="eh mw mx my mz b">react-redux</code>前端发送数据。前端实时显示一些游戏状态，同时与所有其他站点的观众保持时间同步，保持在25毫秒以内。我们没有找到任何以我们喜欢的方式实现web动画的库，所以我们最终实现了自己的库:<code class="eh mw mx my mz b"><a class="ae nq" href="https://github.com/Monadical-SAS/redux-time" rel="noopener ugc nofollow" target="_blank">redux-time</a></code>。如果你正试图用<code class="eh mw mx my mz b">redux</code>风格的状态管理以一种功能性的、声明性的方式来做实时动画，这是值得一试的。我们还开发了<code class="eh mw mx my mz b"><a class="ae nq" href="https://github.com/Monadical-SAS/django-channels-router" rel="noopener ugc nofollow" target="_blank">django-channels-router</a></code>,它是后端路由，用于处理去往/来自前端的套接字消息。如果你觉得这两个库有用，或者你以前做过类似的工作，请告诉我！</p><h1 id="611d" class="ku kv hu bd kw kx mm kz la lb mn ld le ja mo jb lg jd mp je li jg mq jh lk ll dt translated">链接和资源:</h1><ul class=""><li id="9aa4" class="ly lz hu jl b jm lm jp ln js nt jw nu ka nv ke md me mf mg dt translated">如果你是Django和结构化应用程序的新手，从这里开始一个温和的介绍:<a class="ae nq" href="https://scotch.io/tutorials/build-your-first-python-and-django-application" rel="noopener ugc nofollow" target="_blank">构建你的第一个Python &amp; Django应用程序</a></li><li id="19a6" class="ly lz hu jl b jm mh jp mi js mj jw mk ka ml ke md me mf mg dt translated">django-react-templatetags 一个用于模板化react片段的库</li><li id="7042" class="ly lz hu jl b jm mh jp mi js mj jw mk ka ml ke md me mf mg dt translated">小人国的人到底是谁？！</li><li id="9a4c" class="ly lz hu jl b jm mh jp mi js mj jw mk ka ml ke md me mf mg dt translated"><a class="ae nq" href="http://www.code-experience.com/why-you-might-not-need-mvc-with-reactjs/" rel="noopener ugc nofollow" target="_blank">为什么React.js不需要MVC</a></li><li id="ceb4" class="ly lz hu jl b jm mh jp mi js mj jw mk ka ml ke md me mf mg dt translated">涵盖更多细节的教程，有一些不同的设计决策:<a class="ae nq" href="http://gregblogs.com/how-django-reactjs-and-browserify/" rel="noopener ugc nofollow" target="_blank">我他妈的怎么设置Django，Django REST Framework，ReactJS和Browserify？</a></li><li id="b748" class="ly lz hu jl b jm mh jp mi js mj jw mk ka ml ke md me mf mg dt translated"><a class="ae nq" href="https://learnnextjs.com" rel="noopener ugc nofollow" target="_blank">next . js</a>:React&amp;节点的构建环境/库，使用了与<em class="lu">页面组件</em>非常相似的系统</li></ul></div><div class="ab cl kn ko hc kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hn ho hp hq hr"><blockquote class="lr ls lt"><p id="9ab9" class="jj jk lu jl b jm jn iv jo jp jq iy jr lv jt ju jv lw jx jy jz lx kb kc kd ke hn dt translated">TL；dr让Django管理你的路由，为每个页面制作单独的JS文件，通过模板将props数据传递给你的组件</p></blockquote><h1 id="3467" class="ku kv hu bd kw kx mm kz la lb mn ld le ja mo jb lg jd mp je li jg mq jh lk ll dt">—</h1><p id="9b0c" class="pw-post-body-paragraph jj jk hu jl b jm lm iv jo jp ln iy jr js lo ju jv jw lp jy jz ka lq kc kd ke hn dt translated">希望你觉得这有用！如果有，给这篇文章一个💚，或者在twitter上ping我<a class="ae nq" href="https://twitter.com/theSquashSH" rel="noopener ugc nofollow" target="_blank"> @theSquashSH </a>。</p><p id="1f61" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你对涉及以太坊的很酷的Django + React/Redux项目感兴趣，<a class="ae nq" href="https://monadical.com" rel="noopener ugc nofollow" target="_blank"> Monadical正在招聘</a>远程&amp;本地开发人员(第一个月我们会带你去阳光明媚的麦德林)！</p><figure class="kg kh ki kj fq kk fe ff paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="fe ff nw"><img src="../Images/1a04cde1bda1dd1c8ac4655c33c1ac15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uRMpX-1G6q12KDu23mGcvQ.png"/></div></div></figure></div></div>    
</body>
</html>