<html>
<head>
<title>The beauty in Partial Application, Currying, and Function Composition.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">局部应用美、曲线美和功能组合美。</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-beauty-in-partial-application-currying-and-function-composition-d885bdf0d574?source=collection_archive---------4-----------------------#2017-07-18">https://medium.com/hackernoon/the-beauty-in-partial-application-currying-and-function-composition-d885bdf0d574?source=collection_archive---------4-----------------------#2017-07-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/5e4925fa0fa7450c73d207f148a8a287.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0bqXgqnug9cALrmhQi5ylQ.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="https://pixabay.com/en/amazing-animal-beautiful-beautifull-736885/" rel="noopener ugc nofollow" target="_blank">photo by Bessi</a></figcaption></figure><h1 id="4b39" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">故事时间</h1><p id="13c9" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">今天，我有一个奇怪的函数需要写出来。它包含了太多的输入和数学运算(对于一个函数来说),比我希望的要多得多。即使数学本身实际上只是基本的三角学。写了几行代码后，很明显这个函数是不可维护的。</p><p id="66f5" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">我想起了最近听到并爱上的一件事:</p><blockquote class="li"><p id="57a5" class="lj lk hu bd ll lm ln lo lp lq lr lc ek translated">编程语言不是给计算机用的，而是给人用的。</p></blockquote><p id="5d4e" class="pw-post-body-paragraph kf kg hu kh b ki ls kk kl km lt ko kp kq lu ks kt ku lv kw kx ky lw la lb lc hn dt translated">另一个也是这样:</p><blockquote class="li"><p id="01cd" class="lj lk hu bd ll lm ln lo lp lq lr lc ek translated"><a class="ae jg" href="https://stackoverflow.com/a/522831/504836" rel="noopener ugc nofollow" target="_blank">电脑不运行就坏了。人看不懂就坏了。很快。</a></p></blockquote><p id="cff1" class="pw-post-body-paragraph kf kg hu kh b ki ls kk kl km lt ko kp kq lu ks kt ku lv kw kx ky lw la lb lc hn dt">❤</p><p id="bc36" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">总之，回到函数。</p><p id="1132" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">我已经下定决心要重构这个东西。这是一个典型的重构，分解一些职责，加入一些局部的应用程序，添加一些修饰，然后用函数组合完成。</p><p id="c94e" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">留给我的是一些非常优雅且易于维护的代码。我反思了以这种方式编写代码是多么罕见，这就是我今天分享的原因。</p><p id="7093" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated"><strong class="kh hv">免责声明:</strong>单篇文章远不足以涵盖所有的函数式编程技术。我们不会深究其中任何一个。我希望这个<em class="lx">高层次的概述</em>能激起你对FP的好奇心，让你开始自己的旅程。</p><h1 id="d28b" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">要求</h1><p id="c076" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">那我到底在做什么？</p><p id="ee40" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">我在试图计算一个事件发生的概率。我知道随着这个事件的<code class="eh ly lz ma mb b">velocity</code>增加，事件发生的<code class="eh ly lz ma mb b">probability</code>也增加。</p><p id="1ad2" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">如果<code class="eh ly lz ma mb b">velocity</code>低于1000，那么发生的<code class="eh ly lz ma mb b">probability</code>总是50%。如果<code class="eh ly lz ma mb b">velocity</code>高于9000，则<code class="eh ly lz ma mb b">probability</code>跳到85%的最大值。用图表更容易形象化，所以这里有一个图表。</p><figure class="md me mf mg fq iv fe ff paragraph-image"><div class="fe ff mc"><img src="../Images/42ccc27ec0f13cde82ed1e0259cf3b80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*KdzedW5Y3KtQs0K_jz3kUw.png"/></div></figure><p id="f950" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">我想把这些都封装到一个函数里。</p><p id="52be" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">这可以用一行三角学来解决，但它看起来像一个正则表达式或机器语言，今天，<em class="lx">我们正在为人们编写代码</em>。</p><h1 id="2f51" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">开始</h1><p id="ae51" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">首先，我创建了一个校准对象来将<code class="eh ly lz ma mb b">X</code>转换为<code class="eh ly lz ma mb b">Y</code>。</p><pre class="md me mf mg fq mh mb mi mj aw mk dt"><span id="a9b4" class="ml ji hu mb b fv mm mn l mo mp">const calibration = {<br/>  x: { min: 1000, max: 9000 },<br/>  y: { min: 50, max: 85 },<br/>}</span></pre><p id="e9b5" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">然后我<em class="lx">几乎</em>写了这段代码，如果值低于阈值就返回最小值<code class="eh ly lz ma mb b">Y</code>，如果值高于阈值就返回最大值<code class="eh ly lz ma mb b">Y</code>。</p><figure class="md me mf mg fq iv"><div class="bz el l di"><div class="mq mr l"/></div></figure><p id="2fdb" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">但是我真的不喜欢<code class="eh ly lz ma mb b">if</code>的说法。如果你发现自己对为什么感到好奇，那么看看关于它的文章…</p><div class="ms mt fm fo mu mv"><a href="https://hackernoon.com/rethinking-javascript-the-if-statement-b158a61cd6cb" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab ej"><div class="mx ab my cl cj mz"><h2 class="bd hv fv z el na eo ep nb er et ht dt translated">重新思考JavaScript:if语句</h2><div class="nc l"><h3 class="bd b fv z el na eo ep nb er et ek translated">功能性思维打开了我对编程的思维。它让我对代码有了更深的理解…</h3></div><div class="nd l"><p class="bd b gc z el na eo ep nb er et ek translated">hackernoon.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj ja mv"/></div></div></a></div><p id="65b3" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">并且<em class="lx">使用<code class="eh ly lz ma mb b">Math.min</code>和<code class="eh ly lz ma mb b">Math.max</code>有一个更好的方法来做这件事</em>。因为我需要同时使用这两种方法，所以我打算只使用拉姆达的<code class="eh ly lz ma mb b">clamp</code>方法，它确实做到了这一点。</p><h1 id="46cd" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">特征缩放</h1><p id="edc5" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">特征缩放(Feature scaling)，也称为<strong class="kh hv">规格化</strong>，是一种机器学习技术，我认为在这里会应用得很好。</p><p id="4241" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">特征缩放的要点是将输入(<code class="eh ly lz ma mb b">X</code>)缩放到<code class="eh ly lz ma mb b">[0, 1]</code>之间的值。然后我将做相反的操作，将数字缩小到<code class="eh ly lz ma mb b">Y</code>刻度。</p><p id="4a98" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated"><strong class="kh hv">你应该忽略</strong>下面的大部分代码，只需注意<code class="eh ly lz ma mb b">normalize</code>，特别是它如何调用两个函数<code class="eh ly lz ma mb b">scale</code>和<code class="eh ly lz ma mb b">R.clamp</code>。<code class="eh ly lz ma mb b">denormalize</code>做同样的事，只是反过来。</p><figure class="md me mf mg fq iv"><div class="bz el l di"><div class="mq mr l"/></div></figure><h1 id="b5e2" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">功能组成</h1><p id="3502" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">函数合成是我最喜欢的FP工具之一。这是一种利用现有函数创建新函数的技术。</p><p id="de7f" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated"><code class="eh ly lz ma mb b">normalize</code>和<code class="eh ly lz ma mb b">denormalize</code>是函数组合的绝佳候选，我们可以使用Ramda的<code class="eh ly lz ma mb b">pipe</code>方法将它们转换成:</p><figure class="md me mf mg fq iv"><div class="bz el l di"><div class="mq mr l"/></div></figure><p id="d47f" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">没有很大的不同，但我们只走了一半。我们将在Currying &amp; Partial Application部分进一步减少这个问题。</p><p id="b7bf" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">要继续学习更多关于函数合成的知识，请查阅我以前关于函数合成的文章。</p><div class="ms mt fm fo mu mv"><a href="https://hackernoon.com/javascript-functional-composition-for-every-day-use-22421ef65a10" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab ej"><div class="mx ab my cl cj mz"><h2 class="bd hv fv z el na eo ep nb er et ht dt translated">函数JavaScript:日常使用的函数组合。</h2><div class="nc l"><h3 class="bd b fv z el na eo ep nb er et ek translated">函数组合是函数式编程中我最喜欢的部分。我希望给你提供一个好的真实的…</h3></div><div class="nd l"><p class="bd b gc z el na eo ep nb er et ek translated">hackernoon.com</p></div></div><div class="ne l"><div class="nk l ng nh ni ne nj ja mv"/></div></div></a></div><h1 id="0ac0" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">固化和部分应用</h1><p id="19ad" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">Currying <strong class="kh hv"> </strong>是一种将带有多个参数的函数的求值转化为一系列函数的求值的技术，每个函数只有一个参数。— <a class="ae jg" href="https://en.wikipedia.org/wiki/Currying" rel="noopener ugc nofollow" target="_blank">维基百科</a></p><p id="1842" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">Currying允许我们轻松地将参数部分应用于<code class="eh ly lz ma mb b">scale</code>和<code class="eh ly lz ma mb b">R.clamp</code>。</p><figure class="md me mf mg fq iv"><div class="bz el l di"><div class="mq mr l"/></div></figure><p id="d79c" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated"><strong class="kh hv">注意:虽然我在这里没有遵循1参数规则</strong>，但是min和max也应该被分开。但是，它没有添加任何实用程序，因为min和max将同时提供，这会使示例变得复杂。有时，最好遵循法律的精神，而不是法律的字面意思:)</p><h1 id="cca7" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">该功能</h1><p id="50db" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">构建函数现在变得非常简单。这是因为我们已经写好了所有的逻辑。剩下的就是像这样组合<code class="eh ly lz ma mb b">normalize</code>和<code class="eh ly lz ma mb b">denormalize</code>:</p><figure class="md me mf mg fq iv"><div class="bz el l di"><div class="mq mr l"/></div></figure><p id="8e67" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">就是这样！超级简单。</p><h1 id="3922" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">最后</h1><p id="c9fd" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">总的来说，它看起来像这样:</p><figure class="md me mf mg fq iv"><div class="bz el l di"><div class="mq mr l"/></div></figure><p id="bdcc" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated"><strong class="kh hv">观察:</strong></p><p id="f3b0" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">每个函数都是一个<strong class="kh hv">表达式</strong>而不是一个<em class="lx">块</em>。函数<em class="lx">立即</em>返回它们的值。</p><p id="6c0b" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">每个函数都是<strong class="kh hv">等幂的</strong>，这意味着给定相同的输入，它将<em class="lx">总是</em>产生相同的输出。</p><p id="fd6d" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">每个函数都是一个纯函数。它只从<em class="lx">输入中计算输出</em>。</p><p id="3620" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">我们的大多数函数<strong class="kh hv">不包含任何新代码</strong>，它们只是由现有函数组成的<strong class="kh hv">。</strong></p><h1 id="f78e" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">额外学分</h1><p id="7f33" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">简单不仅仅是装饰。我正在处理的变换是线性的，但实际上它可能更接近下图中的easeOutSine或easeOutCubic。</p><figure class="md me mf mg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nl"><img src="../Images/dd9f5a6e664e4f1a4415f8a17942ab72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UMNpm1P-9TBCTXjlOfLlzA.png"/></div></div></figure><p id="3543" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">因为我们已经将代码分解成了小块，所以增强这个功能会非常简单。我们只需将我们的过渡添加到<code class="eh ly lz ma mb b">R.pipe</code>管道中。这里有几种方法可以做到这一点:</p><figure class="md me mf mg fq iv"><div class="bz el l di"><div class="mq mr l"/></div></figure><h1 id="32d7" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">放弃</h1><p id="daf2" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">我确实理解“更容易”是主观的，许多不熟悉函数式编程风格的人现在可能已经神魂颠倒了。</p><p id="67b1" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">你必须先知道如何进行函数式编程，然后你也会有这种感觉。尽管一旦你这样做了，这种风格就成了显而易见的正确选择。这里的关键是<em class="lx">一旦你知道</em>。</p><p id="4d73" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">这也不意味着是一个教程。这只是函数式javascript世界的一小部分。</p><h1 id="c0a0" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">摘要</h1><p id="9d51" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">嘿，你一路走到了最后！谢谢你听我的咆哮。我是真心的。</p><p id="974b" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">今天，我已经演示了如何将被分解成单一职责的功能轻松地组合成新的功能。</p><p id="3217" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">我知道我没有涵盖足够多的内容，但是我确实有很多其他的<strong class="kh hv">函数式编程</strong>文章，这些文章有更详细的内容。</p><div class="ms mt fm fo mu mv"><a href="https://medium.com/@joelthoms/latest" rel="noopener follow" target="_blank"><div class="mw ab ej"><div class="mx ab my cl cj mz"><h2 class="bd hv fv z el na eo ep nb er et ht dt translated">乔尔·托马斯写的最新故事</h2><div class="nc l"><h3 class="bd b fv z el na eo ep nb er et ek translated">阅读乔尔·托马斯在Medium上写的最新故事。计算机科学家和技术布道者，拥有21年的…</h3></div><div class="nd l"><p class="bd b gc z el na eo ep nb er et ek translated">medium.com</p></div></div><div class="ne l"><div class="nm l ng nh ni ne nj ja mv"/></div></div></a></div><p id="103e" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">我知道这是一件小事，但当我在媒体和Twitter上收到这些后续通知时，我感到非常高兴。或者你觉得我满嘴屁话，在下面的评论里告诉我。</p><p id="56ae" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">干杯！</p></div></div>    
</body>
</html>