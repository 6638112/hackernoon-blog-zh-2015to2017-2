<html>
<head>
<title>TabBar Items with Swift Enums</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Swift枚举的TabBar项目</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/tabbar-items-with-swift-enums-c0e37be8ae21?source=collection_archive---------10-----------------------#2017-11-25">https://medium.com/hackernoon/tabbar-items-with-swift-enums-c0e37be8ae21?source=collection_archive---------10-----------------------#2017-11-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="9a91" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">管理子视图控制器的快速技巧</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/f08c707dc27454b752baa0d2e0378192.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IdqxCGYC4aLP81mPr3qOlg.jpeg"/></div></div></figure><p id="d867" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在iOS中，标签式导航非常方便有趣。由于本机UITabBarController，UIViewController的一个子类，除了它的子ViewControllers之外，它实际上不需要太多设置。</p><p id="81e0" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">但是，不可否认的是，在那之后，我们仍然发现自己在管理子视图控制器方面处于两难境地，特别是当我们需要从TabBarController访问它们的时候。有几种不同的方法来完成它，这取决于几个更多的因素，如任务的重量或意图，其中一些是:</p><ol class=""><li id="4503" class="kr ks hu jx b jy jz kb kc ke kt ki ku km kv kq kw kx ky kz dt translated">儿童视图控制器的位置应该很容易改变/切换，没有太多问题，但主观设计。</li><li id="1210" class="kr ks hu jx b jy la kb lb ke lc ki ld km le kq kw kx ky kz dt translated">除了需要沟通的情况外，父TabBarControllers不需要了解子ViewControllers太多信息。</li><li id="11ec" class="kr ks hu jx b jy la kb lb ke lc ki ld km le kq kw kx ky kz dt translated">父TabBarControllers应该能够容易地访问并准确地区分子ViewControllers。</li></ol><p id="1b27" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">跟踪子ViewControllers的一个简单方法是通过它们的<strong class="jx hv">字符串</strong> <code class="eh lf lg lh li b">tabBarItem.title</code>属性。如果名字比较是你所需要的，也许这就够了？</p><p id="117e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">但还是要小心。字符串很容易实现和修改，但是如果你不严格注意的话，也是非常松散的。使用<strong class="jx hv">字符串</strong>作为比较点很容易在你不知道的情况下导致许多错误的标志，所以我现在会远离它。</p><p id="228e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">另一种方式可以通过<strong class="jx hv">数据类型</strong>来实现。类似于标题比较，您可能会以大量的<code class="eh lf lg lh li b">if else</code>结束，正因为如此，它只适用于没有两个子视图控制器共享相同类型的情况。</p><p id="a291" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">与字符串比较不同，这可以避免您意外地误解错误的值。但是如果您走这条路，测试父UITabBarController将会非常棘手，因为依赖严格的数据类型来识别对象将会限制您的模拟能力。</p><h2 id="f25e" class="lj lk hu bd ll lm ln lo lp lq lr ls lt ke lu lv lw ki lx ly lz km ma mb mc md dt translated">通过协议和枚举描述我们的选项卡项目</h2><p id="2d34" class="pw-post-body-paragraph jv jw hu jx b jy me iv ka kb mf iy kd ke mg kg kh ki mh kk kl km mi ko kp kq hn dt translated">我想与大家分享的另一种管理子视图控制器的方法是通过Swift Enum和协议实现的混合。通过为您的子ViewControllers创建一组有限的TabBar标识值，您还可以为它们提供一个模拟或测试类的良好基础，从而提高它们的可测试性。</p><p id="5d61" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">首先，我们将通过一组表示我们期望的TabBar项目的枚举值来实现我们的有限的名为<code class="eh lf lg lh li b">TabBarType</code>的标识集。</p><pre class="jk jl jm jn fq mj li mk ml aw mm dt"><span id="7981" class="lj lk hu li b fv mn mo l mp mq">enum TabBarType: String {</span><span id="183f" class="lj lk hu li b fv mr mo l mp mq">    case featured = "Featured"</span><span id="0c5d" class="lj lk hu li b fv mr mo l mp mq">    case accounts = "Accounts"</span><span id="3dde" class="lj lk hu li b fv mr mo l mp mq">    case cart = "Cart"</span><span id="4e32" class="lj lk hu li b fv mr mo l mp mq">    case search = "Search"</span><span id="239a" class="lj lk hu li b fv mr mo l mp mq">    case none = "None"</span><span id="cc4c" class="lj lk hu li b fv mr mo l mp mq">}</span></pre><p id="8837" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这样我们可以锁定我们可能的值，以确保我们可以在编译时尽早捕捉到任何流氓。</p><p id="8541" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">其次，我们将创建一个名为<code class="eh lf lg lh li b">TabBarChild</code>的简短协议来描述一个包含代表它们的<code class="eh lf lg lh li b">TabBarType</code>值的对象。</p><pre class="jk jl jm jn fq mj li mk ml aw mm dt"><span id="1f50" class="lj lk hu li b fv mn mo l mp mq">protocol TabBarChild {</span><span id="53b4" class="lj lk hu li b fv mr mo l mp mq">    var tabBarType: TabBarType? { get set }</span><span id="8035" class="lj lk hu li b fv mr mo l mp mq">}</span></pre><p id="ed23" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">第三，我们将使我们指定的子ViewController类符合新的协议，这样他们的父母就知道如何作为TabBar的孩子与他们交流。这可以通过许多不同的方式来实现，取决于你的团队偏好的<a class="ae ms" href="https://hackernoon.com/tagged/design" rel="noopener ugc nofollow" target="_blank">设计</a>，但是在本文中我可以向你展示几个。</p><h2 id="2d99" class="lj lk hu bd ll lm ln lo lp lq lr ls lt ke lu lv lw ki lx ly lz km ma mb mc md dt translated">解决方案1:扩展UIViewController</h2><p id="e3e9" class="pw-post-body-paragraph jv jw hu jx b jy me iv ka kb mf iy kd ke mg kg kh ki mh kk kl km mi ko kp kq hn dt translated">更简单的方法是通过扩展UIViewController类来符合<code class="eh lf lg lh li b">TabBarChild</code>协议。你基本上只是假设每个UIViewController都有<code class="eh lf lg lh li b">TabBarChild</code>能力，缺点是必须设计ViewController来存储/计算<code class="eh lf lg lh li b">TabBarType</code>的值，不太符合常规。</p><pre class="jk jl jm jn fq mj li mk ml aw mm dt"><span id="224a" class="lj lk hu li b fv mn mo l mp mq">extension UIViewController: TabBarChild {</span><span id="d71a" class="lj lk hu li b fv mr mo l mp mq">    var tabBarType: TabBarType {</span><span id="9877" class="lj lk hu li b fv mr mo l mp mq">        get { return TabBarType(rawValue: tabBarItem.title ?? "" ) ?? .none }</span><span id="1821" class="lj lk hu li b fv mr mo l mp mq">        set { tabBarItem.title = newValue.rawValue }</span><span id="8b55" class="lj lk hu li b fv mr mo l mp mq">    }</span><span id="cd68" class="lj lk hu li b fv mr mo l mp mq">}</span></pre><p id="65c4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在本例中，我选择将其值存储到ViewController的<code class="eh lf lg lh li b">tabBarItem.title</code>中。这样，您可以通过简单地更改<code class="eh lf lg lh li b">TabBarType</code>的值来轻松地修改ViewController的显示方式。这是一种方便的方法，因为它还允许您分配/删除<code class="eh lf lg lh li b">TabBarType</code>属性。下面是实施过程中的一个示例:</p><pre class="jk jl jm jn fq mj li mk ml aw mm dt"><span id="3373" class="lj lk hu li b fv mn mo l mp mq">//somewhere in you code<br/>let viewController = SearchViewController()<br/>viewController.tabBarType = .search<br/>tabBarController.viewControllers.append(viewController)</span><span id="5bda" class="lj lk hu li b fv mr mo l mp mq">func tabBarController(_ tabBarController: UITabBarController, shouldSelect viewController: UIViewController) -&gt; Bool {</span><span id="69e5" class="lj lk hu li b fv mr mo l mp mq">    if viewController.tabBarType == .search {<br/>        //do something with the search tab here?</span><span id="70b1" class="lj lk hu li b fv mr mo l mp mq">    }</span><span id="682a" class="lj lk hu li b fv mr mo l mp mq">    return true</span><span id="0efc" class="lj lk hu li b fv mr mo l mp mq">}</span></pre><h2 id="cbf8" class="lj lk hu bd ll lm ln lo lp lq lr ls lt ke lu lv lw ki lx ly lz km ma mb mc md dt translated">解决方案2:自定义UIViewController扩展</h2><p id="43ba" class="pw-post-body-paragraph jv jw hu jx b jy me iv ka kb mf iy kd ke mg kg kh ki mh kk kl km mi ko kp kq hn dt translated">不喜欢上面的解决方案？另一种方法是更进一步，删除<code class="eh lf lg lh li b">TabBarChild</code>的<code class="eh lf lg lh li b">set</code>访问，<a class="ae ms" href="https://hackernoon.com/tagged/leaving" rel="noopener ugc nofollow" target="_blank">给</a>留下一个不可变的<code class="eh lf lg lh li b">TabBarType</code>属性，这样它们的实现看起来就像这样:</p><pre class="jk jl jm jn fq mj li mk ml aw mm dt"><span id="2225" class="lj lk hu li b fv mn mo l mp mq">protocol TabBarChild {</span><span id="6ac1" class="lj lk hu li b fv mr mo l mp mq">    var tabBarType: TabBarType { get }</span><span id="47cd" class="lj lk hu li b fv mr mo l mp mq">}</span><span id="ba4f" class="lj lk hu li b fv mr mo l mp mq">extension AccountsViewController: TabBarChild {</span><span id="292a" class="lj lk hu li b fv mr mo l mp mq">    var tabBarType: TabBarType {</span><span id="dddd" class="lj lk hu li b fv mr mo l mp mq">        return .accounts</span><span id="014b" class="lj lk hu li b fv mr mo l mp mq">    }</span><span id="cff0" class="lj lk hu li b fv mr mo l mp mq">}</span></pre><p id="ad19" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这让您可以更安全地将<code class="eh lf lg lh li b">TabBarType</code>属性分配给子ViewControllers。在您的TabBar管理层上，访问它们可能如下所示:</p><pre class="jk jl jm jn fq mj li mk ml aw mm dt"><span id="c5ac" class="lj lk hu li b fv mn mo l mp mq">//sample UITabBarDelegate calls<br/>extension HomeFlowController: UITabBarControllerDelegate {</span><span id="ac6f" class="lj lk hu li b fv mr mo l mp mq">    func tabBarController(_ tabBarController: UITabBarController,     shouldSelect viewController: UIViewController) -&gt; Bool {</span><span id="5544" class="lj lk hu li b fv mr mo l mp mq">        if let tabBarChild = viewController as? TabBarChild,</span><span id="0743" class="lj lk hu li b fv mr mo l mp mq">            tabBarChild.tabBarType == .accounts {</span><span id="5489" class="lj lk hu li b fv mr mo l mp mq">            //do something with accounts tab here?</span><span id="3543" class="lj lk hu li b fv mr mo l mp mq">        }</span><span id="5da8" class="lj lk hu li b fv mr mo l mp mq">        return true</span><span id="b514" class="lj lk hu li b fv mr mo l mp mq">    }</span><span id="9a9f" class="lj lk hu li b fv mr mo l mp mq">}</span></pre><p id="5b32" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">由于它不知道您的子ViewController类型，您可以轻松地防止ViewController实现中的更改直接影响您的选项卡管理逻辑。</p><h2 id="f8f5" class="lj lk hu bd ll lm ln lo lp lq lr ls lt ke lu lv lw ki lx ly lz km ma mb mc md dt translated">下一步是什么？</h2><p id="9de6" class="pw-post-body-paragraph jv jw hu jx b jy me iv ka kb mf iy kd ke mg kg kh ki mh kk kl km mi ko kp kq hn dt translated">我在这里提出的解决方案肯定可以进一步扩展，所以尝试并解决其他可能性。看看哪一个最适合你和你的团队。给<code class="eh lf lg lh li b">TabBarChild</code>协议增加更多的属性/功能会对你有更好的帮助吗？或者一个更简单的版本能做得更好吗？</p><p id="bace" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果你有自己的解决方案，请在这里分享，我非常有兴趣听听他们的意见！</p></div><div class="ab cl mt mu hc mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="hn ho hp hq hr"><h1 id="0f2b" class="na lk hu bd ll nb nc nd lp ne nf ng lt ja nh jb lw jd ni je lz jg nj jh mc nk dt translated">你大老远跑来了！</h1><blockquote class="nl"><p id="804e" class="nm nn hu bd no np nq nr ns nt nu kq ek translated">我希望当你打开这篇文章的时候，你已经得到了你想要的东西。如果是这样，如果你能把这个推荐给你的朋友^^，我将非常感激</p></blockquote><p id="26c6" class="pw-post-body-paragraph jv jw hu jx b jy nv iv ka kb nw iy kd ke nx kg kh ki ny kk kl km nz ko kp kq hn dt translated">如果您还有任何问题/反馈，请随时留言！</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="oa ob l"/></div></figure></div></div>    
</body>
</html>