<html>
<head>
<title>Make React Fast Again [Part 2]: why-did-you-update</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">再次快速反应[第2部分]:你为什么更新</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/make-react-fast-again-part-2-why-did-you-update-43a89dc96b10?source=collection_archive---------10-----------------------#2017-06-09">https://medium.com/hackernoon/make-react-fast-again-part-2-why-did-you-update-43a89dc96b10?source=collection_archive---------10-----------------------#2017-06-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/d034abfdeb3fceb015650a521a41c8a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mJFYp7LKVzZM3PPjFb0QXQ.png"/></div></div></figure><p id="2c53" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">React通常非常快，但是很容易犯小错误，导致性能问题。缓慢的组件安装、深度的组件树和不必要的渲染周期很快会让应用程序感觉很慢。</p><p id="f41e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">幸运的是，有很多工具可以帮助诊断性能问题，有些工具甚至是内置的。在本系列中，我们将重点介绍让React应用程序快速运行的工具和技术。每个帖子还会有一个互动的，有趣的演示！</p></div><div class="ab cl ka kb hc kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hn ho hp hq hr"><h1 id="6d74" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">问题:不必要的渲染周期</h1><p id="ba08" class="pw-post-body-paragraph jc jd hu je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">影响React性能的最常见问题之一是不必要的渲染周期。默认情况下，无论父组件何时渲染，React组件都会重新渲染，即使它们的道具没有改变。</p><p id="d087" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如，如果我有这样一个简单的组件:</p><pre class="lk ll lm ln fq lo lp lq lr aw ls dt"><span id="6eb6" class="lt ki hu lp b fv lu lv l lw lx">class DumbComponent extends Component {<br/>  render() {<br/>    return &lt;div&gt; {this.props.value} &lt;/div&gt;;<br/>  }<br/>}</span></pre><p id="ae50" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有这样一个父组件:</p><pre class="lk ll lm ln fq lo lp lq lr aw ls dt"><span id="df41" class="lt ki hu lp b fv lu lv l lw lx">class Parent extends Component {<br/>  render() {<br/>    return &lt;div&gt;<br/>      &lt;DumbComponent value={3} /&gt;<br/>    &lt;/div&gt;;<br/>  }<br/>}</span></pre><p id="ccdb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每当父组件渲染时，<code class="eh ly lz ma lp b">DumbComponent</code>将重新渲染，尽管其属性没有改变。</p><p id="ff4f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一般来说，如果<code class="eh ly lz ma lp b">render</code>运行，虚拟DOM没有变化，这是一个浪费渲染周期，因为<code class="eh ly lz ma lp b">render</code>方法应该是纯的，没有任何副作用。在大规模的React应用程序中，检测发生这种情况的位置可能很棘手，但幸运的是，有一个工具可以提供帮助！</p><h1 id="900c" class="kh ki hu bd kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le dt translated">为什么更新？</h1><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mg"><img src="../Images/bf648d6f04427486a1c19151a4953914.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lb4nr_WLwnLt63jUoszrnQ.png"/></div></div></figure><p id="69f8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ly lz ma lp b">why-did-you-update</code>是一个挂钩React并检测潜在不必要的组件渲染的库。它检测组件的<code class="eh ly lz ma lp b">render</code>方法何时被调用，尽管它的属性没有改变。</p><h2 id="7616" class="lt ki hu bd kj mh mi mj kn mk ml mm kr jn mn mo kv jr mp mq kz jv mr ms ld mt dt translated">设置</h2><ol class=""><li id="ee8f" class="mu mv hu je b jf lf jj lg jn mw jr mx jv my jz mz na nb nc dt translated">使用npm安装:<code class="eh ly lz ma lp b">npm i --save-dev why-did-you-update</code></li><li id="7918" class="mu mv hu je b jf nd jj ne jn nf jr ng jv nh jz mz na nb nc dt translated">将此片段添加到您的应用中的任意位置:</li></ol><pre class="lk ll lm ln fq lo lp lq lr aw ls dt"><span id="d80c" class="lt ki hu lp b fv lu lv l lw lx">import React from 'react'</span><span id="c66e" class="lt ki hu lp b fv ni lv l lw lx">if (process.env.NODE_ENV !== 'production') {<br/>  const {whyDidYouUpdate} = require('why-did-you-update')<br/>  whyDidYouUpdate(React)<br/>}</span></pre><p id="2bf0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">注意</strong>这个工具在本地开发中很棒，但是要确保在生产中禁用它，因为它会降低你的应用程序的速度。</p><h2 id="3f0c" class="lt ki hu bd kj mh mi mj kn mk ml mm kr jn mn mo kv jr mp mq kz jv mr ms ld mt dt translated">了解输出</h2><p id="a5b1" class="pw-post-body-paragraph jc jd hu je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated"><code class="eh ly lz ma lp b">why-did-you-update</code>在应用运行时监控应用，并记录可能发生不必要更改的组件。它可以让你在一个渲染周期之前和之后看到它认为可能是不必要的道具。</p><h1 id="1f67" class="kh ki hu bd kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le dt translated">修复不必要的渲染</h1><p id="b202" class="pw-post-body-paragraph jc jd hu je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">一旦你发现应用程序中有不必要的重复渲染的组件，有一些简单的修复方法。</p><h2 id="6f38" class="lt ki hu bd kj mh mi mj kn mk ml mm kr jn mn mo kv jr mp mq kz jv mr ms ld mt dt translated">使用纯组件</h2><p id="020e" class="pw-post-body-paragraph jc jd hu je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">在上面的例子中，<code class="eh ly lz ma lp b">DumbComponent</code>是其道具的纯函数。即组件只需要在其道具发生变化时重新渲染即可。React内置了一种特殊类型的组件，称为<code class="eh ly lz ma lp b">PureComponent</code>，正是针对这种用例。</p><p id="cb92" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">而不是从React继承。组件，使用React。像这样的纯组件:</p><pre class="lk ll lm ln fq lo lp lq lr aw ls dt"><span id="7e44" class="lt ki hu lp b fv lu lv l lw lx">class DumbComponent extends PureComponent {<br/>  render() {<br/>    return &lt;div&gt; {this.props.value} &lt;/div&gt;;<br/>  }<br/>}</span></pre><p id="eaed" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，组件只会在它的道具实际改变时重新渲染。就是这样！</p><p id="3418" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意<code class="eh ly lz ma lp b">PureComponent</code>做了一个肤浅的道具比较，所以如果你使用复杂的数据结构，它可能会错过一些道具变化，不会更新你的组件。</p><h2 id="5c5f" class="lt ki hu bd kj mh mi mj kn mk ml mm kr jn mn mo kv jr mp mq kz jv mr ms ld mt dt translated">实现shouldComponentUpdate</h2><p id="d69b" class="pw-post-body-paragraph jc jd hu je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated"><code class="eh ly lz ma lp b">shouldComponentUpdate</code>是当<code class="eh ly lz ma lp b">props</code>或<code class="eh ly lz ma lp b">state</code>发生变化时，在<code class="eh ly lz ma lp b">render</code>之前调用的组件方法。如果<code class="eh ly lz ma lp b">shouldComponentUpdate</code>返回true，将调用<code class="eh ly lz ma lp b">render</code>，如果返回false，则不执行任何操作。</p><p id="5355" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过实现这个方法，您可以指示React避免重新渲染一个给定的组件，如果它的属性没有改变的话。</p><p id="9bfb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如，我们可以在上面的哑组件中实现<code class="eh ly lz ma lp b">shouldComponentUpdate</code>,如下所示:</p><pre class="lk ll lm ln fq lo lp lq lr aw ls dt"><span id="59f7" class="lt ki hu lp b fv lu lv l lw lx">class DumbComponent extends Component {<br/>  shouldComponentUpdate(nextProps) {<br/>    if (this.props.value !== nextProps.value) {<br/>      return true;<br/>    } else {<br/>      return false;<br/>    }<br/>  }</span><span id="1466" class="lt ki hu lp b fv ni lv l lw lx">render() {<br/>    return &lt;div&gt;foo&lt;/div&gt;;<br/>  }<br/>}</span></pre><h1 id="4267" class="kh ki hu bd kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le dt translated">演示！</h1><p id="4064" class="pw-post-body-paragraph jc jd hu je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">为了演示<code class="eh ly lz ma lp b">why-did-you-update</code>，我在Code Sandbox上的TodoMVC应用程序中安装了这个库，Code Sandbox是一个在线React游乐场。打开浏览器控制台，添加一些TODOs来查看输出。</p><p id="41b8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae nj" href="https://codesandbox.io/s/xGJP4QExn" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/xGJP4QExn</a></p><p id="dda7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，应用程序中的一些组件进行了不必要的渲染。尝试实现上述技术，以防止不必要的渲染。如果操作正确，控制台中应该没有来自<code class="eh ly lz ma lp b">why-did-you-update</code>的输出。</p><h1 id="9392" class="kh ki hu bd kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le dt translated">调试生产中的性能问题</h1><p id="cf23" class="pw-post-body-paragraph jc jd hu je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated"><code class="eh ly lz ma lp b">why-did-you-update</code>只在本地开发有效。如果您有兴趣了解生产应用程序中的性能问题，请尝试<a class="ae nj" href="https://logrocket.com" rel="noopener ugc nofollow" target="_blank"> LogRocket </a>。</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nk"><img src="../Images/b47f54e433b8f39f62f5fffc5232dd8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s_rMyo6NbrAsP-XtvBaXFg.png"/></div></div></figure><p id="adbd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">LogRocket 是一个前端日志工具，可以让你回放问题，就像它们发生在你自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。</p><p id="00f2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">LogRocket让你的应用程序记录性能计时、Redux动作/状态、日志、错误、带有头+主体的网络请求/响应以及浏览器元数据。它还记录页面上的HTML和CSS，甚至可以重建最复杂的单页面应用程序的像素级完美视频。</p><div class="nl nm fm fo nn no"><a href="https://logrocket.com/" rel="noopener  ugc nofollow" target="_blank"><div class="np ab ej"><div class="nq ab nr cl cj ns"><h2 class="bd hv fv z el nt eo ep nu er et ht dt translated">JavaScript应用程序的日志记录和会话重放</h2><div class="nv l"><h3 class="bd b fv z el nt eo ep nu er et ek translated">LogRocket帮助您了解影响用户的问题，以便您可以重新开始构建优秀的软件。</h3></div><div class="nw l"><p class="bd b gc z el nt eo ep nu er et ek translated">logrocket.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc ja no"/></div></div></a></div><h1 id="c2cd" class="kh ki hu bd kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le dt translated">结论</h1><p id="cfb5" class="pw-post-body-paragraph jc jd hu je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated"><code class="eh ly lz ma lp b">why-did-you-update</code>是一个方便的工具，用于检测潜在的不必要的组件重渲染，帮助你使你的应用程序性能更好。</p><p id="73e7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为<code class="eh ly lz ma lp b">why-did-you-update</code>只在开发中工作，所以请查看<a class="ae nj" href="https://logrocket.com" rel="noopener ugc nofollow" target="_blank">日志火箭</a>，以诊断生产中的错误和性能问题。</p><p id="df5e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要了解更多React性能技巧，请查看本系列的第1部分和第3部分:</p><div class="nl nm fm fo nn no"><a href="https://blog.logrocket.com/make-react-fast-again-part-1-performance-timeline-f7f39f676f58" rel="noopener  ugc nofollow" target="_blank"><div class="np ab ej"><div class="nq ab nr cl cj ns"><h2 class="bd hv fv z el nt eo ep nu er et ht dt translated">再次快速反应[第1部分]:性能时间表</h2><div class="nv l"><h3 class="bd b fv z el nt eo ep nu er et ek translated">React通常非常快，但是很容易犯小错误，导致性能问题。慢速分量…</h3></div><div class="nw l"><p class="bd b gc z el nt eo ep nu er et ek translated">blog.logrocket.com</p></div></div><div class="nx l"><div class="od l nz oa ob nx oc ja no"/></div></div></a></div><div class="nl nm fm fo nn no"><a href="https://blog.logrocket.com/make-react-fast-again-part-3-highlighting-component-updates-6119e45e6833" rel="noopener  ugc nofollow" target="_blank"><div class="np ab ej"><div class="nq ab nr cl cj ns"><h2 class="bd hv fv z el nt eo ep nu er et ht dt translated">再次快速反应[第3部分]:突出组件更新</h2><div class="nv l"><h3 class="bd b fv z el nt eo ep nu er et ek translated">React通常非常快，但是很容易犯小错误，导致性能问题。慢速分量…</h3></div><div class="nw l"><p class="bd b gc z el nt eo ep nu er et ek translated">blog.logrocket.com</p></div></div><div class="nx l"><div class="oe l nz oa ob nx oc ja no"/></div></div></a></div></div><div class="ab cl ka kb hc kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hn ho hp hq hr"><p id="c5b4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="of">很难保持前端开发的最新状态。加入我们的每周邮件列表，了解新的工具、库和最佳实践，帮助你构建更好的应用:</em></p><figure class="lk ll lm ln fq iv"><div class="bz el l di"><div class="og oh l"/></div></figure><div class="lk ll lm ln fq ab cb"><figure class="oi iv oj ok ol om on paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="oi iv oj ok ol om on paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="oi iv oj ok ol om on paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="oo op oq"><p id="f922" class="jc jd of je b jf jg jh ji jj jk jl jm or jo jp jq os js jt ju ot jw jx jy jz hn dt translated"><a class="ae nj" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客们下午的开始。我们是<a class="ae nj" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae nj" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae nj" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd of je b jf jg jh ji jj jk jl jm or jo jp jq os js jt ju ot jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae nj" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae nj" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ou"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>