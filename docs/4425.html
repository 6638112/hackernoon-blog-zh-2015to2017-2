<html>
<head>
<title>Are Mutable References Fast?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可变引用速度快吗？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/are-mutable-references-in-haskell-fast-f095f4144977?source=collection_archive---------2-----------------------#2017-06-01">https://medium.com/hackernoon/are-mutable-references-in-haskell-fast-f095f4144977?source=collection_archive---------2-----------------------#2017-06-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="69da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我在剖析一个简单的循环(几年前)。它类似于:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="9141" class="jy jz hu ju b fv ka kb l kc kd">countForever ref = forever $ modifyIORef' ref (+1)</span></pre><p id="5dfb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我数了四个汇编指令。</p><blockquote class="ke kf kg"><p id="f00e" class="ir is kh it b iu iv iw ix iy iz ja jb ki jd je jf kj jh ji jj kk jl jm jn jo hn dt translated">加法需要大约300皮秒，但是有内存访问，所以让我们说两纳秒</p></blockquote><p id="1305" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了描述，我写道:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="6f39" class="jy jz hu ju b fv ka kb l kc kd">iorefLoop = do<br/>  ref &lt;- newIORef (0 :: Int)<br/>  replicateM_ 100000000 $ modifyIORef' ref (+1)</span></pre><p id="e0e4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我预计这需要大约0.2秒，但是…</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="5e5b" class="jy jz hu ju b fv ka kb l kc kd">$ bench ./bin/ioref-loop</span><span id="637e" class="jy jz hu ju b fv kl kb l kc kd">benchmarking ./bin/ioref-loop<br/>time                 332.3 ms   (330.4 ms .. 333.8 ms)<br/>                     1.000 R²   (1.000 R² .. 1.000 R²)<br/>mean                 334.4 ms   (333.2 ms .. 335.9 ms)<br/>std dev              2.822 ms   (2.182 ms .. 3.942 ms)</span></pre><p id="48dc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是个好时机吗？我是不是对哈斯克尔有不切实际的期待？作为健全性检查，我用C写了一个类似的<a class="ae km" href="https://hackernoon.com/tagged/program" rel="noopener ugc nofollow" target="_blank">程序</a>:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="eae9" class="jy jz hu ju b fv ka kb l kc kd">int main (int argc, const char** argv)<br/>{<br/>    int ref = 0;<br/>    while (ref &lt; 100000000)<br/>    {<br/>        ref++;<br/>    }<br/>}</span></pre><p id="4aed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我编译并运行了它，如下所示:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="8a49" class="jy jz hu ju b fv ka kb l kc kd">$ gcc -O2 ./src/CLoop.c -o ./bin/CLoop &amp;&amp; bench ./bin/CLoop</span><span id="28b1" class="jy jz hu ju b fv kl kb l kc kd">benchmarking ./bin/CLoop<br/>time                 3.999 ms   (3.794 ms .. 4.235 ms)<br/>                     0.980 R²   (0.972 R² .. 0.992 R²)<br/>mean                 3.940 ms   (3.838 ms .. 4.093 ms)<br/>std dev              593.3 μs   (422.8 μs .. 816.0 μs)<br/>variance introduced by outliers: 90% (severely inflated)</span></pre><p id="82b9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这比我预料的要快得多。</p><blockquote class="ke kf kg"><p id="9b92" class="ir is kh it b iu iv iw ix iy iz ja jb ki jd je jf kj jh ji jj kk jl jm jn jo hn dt translated">也许<code class="eh kn ko kp ju b">bench</code>在程序快时不准确？</p></blockquote><p id="6d58" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我上了IRC(不同的时间，因为GHC现在做代码更快):</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="8204" class="jy jz hu ju b fv ka kb l kc kd">jfischoff ~ Is there anyway to make modifyIORef' faster? <br/>jfischoff ~ I am surprised that in a second I was only able to <br/>          ↪ update this ref 100 million times: <br/>          ↪ timeout 1000000 $ forever $ modifyIORef' x (1+)<br/>jfischoff ~ where as c++ was able to do the same in 4 milliseconds<br/>glguy     ~ c++ was able to do 1 update every 0.04 nanoseconds?<br/>glguy     ~ an update rate of 25 gigahertz?<br/>dv-       ~ gcc probably just replaced it with a constant<br/>jfischoff ~ dv-: perhaps<br/>glguy     ~ That or C++ unlocks the fast mode of an Intel processor</span></pre><p id="f937" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">燃烧。</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="4b2c" class="jy jz hu ju b fv ka kb l kc kd">$ gcc -O2 CLoop.c -S</span></pre><p id="2034" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">组装如下:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="e605" class="jy jz hu ju b fv ka kb l kc kd">; CLoop.s<br/>; Notice, there are no jumps.<br/>; There is no looping.<br/>_main:                                  ## <a class="ae km" href="http://twitter.com/main" rel="noopener ugc nofollow" target="_blank">@main</a><br/> .cfi_startproc<br/>## BB#0:<br/> pushq %rbp<br/>Ltmp0:<br/> .cfi_def_cfa_offset 16<br/>Ltmp1:<br/> .cfi_offset %rbp, -16<br/> movq %rsp, %rbp<br/>Ltmp2:<br/> .cfi_def_cfa_register %rbp<br/> xorl %eax, %eax<br/> popq %rbp<br/> retq<br/> .cfi_endproc</span></pre><p id="220d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kn ko kp ju b">dv-</code>说得对。我猜编译器已经去掉了这个循环，因为我没有使用结果。我添加了一个<code class="eh kn ko kp ju b">volatile</code>关键字来防止<a class="ae km" href="https://hackernoon.com/tagged/optimizations" rel="noopener ugc nofollow" target="_blank">优化</a>:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="2e97" class="jy jz hu ju b fv ka kb l kc kd">//CountForver.c<br/>int main (int argc, const char** argv)<br/>{<br/>    volatile int ref = 0;<br/>    while (ref &lt; 100000000)<br/>    {<br/>        ref++;<br/>    }<br/>}</span></pre><p id="73b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">编译:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="db1c" class="jy jz hu ju b fv ka kb l kc kd">$ gcc -O2 ./src/CLoopVolatile.c -o ./bin/CLoopVolatile <br/>$ bench ./bin/CLoopVolatile</span><span id="9688" class="jy jz hu ju b fv kl kb l kc kd">benchmarking ./bin/CLoopVolatile</span><span id="6ab2" class="jy jz hu ju b fv kl kb l kc kd">time                 158.2 ms   (156.7 ms .. 159.5 ms)<br/>                     1.000 R²   (0.999 R² .. 1.000 R²)<br/>mean                 159.1 ms   (158.4 ms .. 160.2 ms)<br/>std dev              2.423 ms   (1.755 ms .. 3.772 ms)</span></pre><p id="49d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">回路的组装是:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="fa1e" class="jy jz hu ju b fv ka kb l kc kd">loop:                  <br/> incl -4(%rbp)         # Increment the value at the address stored        <br/>                       # in rbp displaced by 4.<br/> movl -4(%rbp), %eax   # move the value at the address stored in rbp <br/>                       # displaced by 4 to eax.<br/> cmpl $100000000, %eax # Compare to 100000000 to eax.<br/> jl loop               # Jump to the start of the loop if the eax <br/>                       # was less than when compared above.</span></pre><p id="2481" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以，递增C的可变refs比<code class="eh kn ko kp ju b">IORef</code>快两倍多？不过，也许手写汇编会更快？也许<code class="eh kn ko kp ju b">volatile</code>这个关键词把优化抛得太远了？</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="c9da" class="jy jz hu ju b fv ka kb l kc kd">; AsmLoop.asm<br/>EXTERN _exit<br/>GLOBAL start<br/><br/>SECTION .data<br/>  align 8<br/>  iterationCount DD 100000000<br/>  result DD 0<br/><br/>SECTION .text<br/>start:<br/>   ; Copy the iteration count to the ecx register<br/>   ; which is used by the loopnz instruction<br/>   mov ecx, [iterationCount]<br/><br/>loopBlock:  <br/>   inc dword [result] ; Increment the value at the address of result<br/>   loopnz loopBlock   ; Decrement the ecx counter and loop until ecx <br/>                      ; is zero<br/><br/>exitBlock:<br/>   push dword 0 ; Set the exit code to zero<br/>   mov  eax, 1  ; Place the system call number (exit) in the eax reg<br/>   sub  esp, 4  ; I have to add some dummy space to the stack for <br/>                ; some reason<br/>   int  0x80    ; Exit</span></pre><p id="d51e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">编译:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="80bc" class="jy jz hu ju b fv ka kb l kc kd">$ nasm -fmacho src/AsmLoop.asm <br/>$ ld -o ./bin/AsmLoop -macosx_version_min 10.7.0 ./src/AsmLoop.o <br/>$ bench ./bin/AsmLoop<br/><br/>benchmarking ./bin/AsmLoop<br/>time                 185.2 ms   (183.7 ms .. 186.9 ms)<br/>                     1.000 R²   (0.999 R² .. 1.000 R²)<br/>mean                 187.0 ms   (185.9 ms .. 188.5 ms)<br/>std dev              3.132 ms   (2.229 ms .. 4.269 ms)</span></pre><p id="d39c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">哇，我的l33t skillz增加了大约15%的时间(三年前这个版本更快…只是说)。</p><p id="6b29" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以<code class="eh kn ko kp ju b">IORef</code>比C和汇编语言中的简单方法慢两倍。怎么回事？到核心！</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="bd1a" class="jy jz hu ju b fv ka kb l kc kd">$ stack exec ghc-core -- --no-syntax -- -O2 \ <br/>      -dsuppress-all src/IORefLoop.hs</span></pre><p id="43d4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">透过核心我看到:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="4a8e" class="jy jz hu ju b fv ka kb l kc kd">...<br/>case readMutVar# ipv1_aVW w2_a35m<br/>of _ { (# ipv2_aWt, ipv3_aWu #) -&gt;<br/>case ipv3_aWu of _ { I# x_aUW -&gt;<br/>case writeMutVar# ipv1_aVW (I# (+# x_aUW 1#)) ipv2_aWt<br/>...</span></pre><p id="0dc2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我发现GHC核心几乎不可读。</p><p id="5f31" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个技巧是尽量忽略大部分case语句。第一个和第三个case语句不是为了检查备选方案，而是为了确保IO操作的正确排序。此外，重命名生成的变量也很有帮助。</p><p id="a807" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是上述内容的清理版本:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="2aec" class="jy jz hu ju b fv ka kb l kc kd">...<br/>case readMutVar# ioRef token of<br/>  { (# token', x #) -&gt; <br/>case x of<br/>  { I# unbox -&gt; case writeMutVar# ioRef (I# (+# unbox 1#)) token'<br/>...</span></pre><p id="773e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第二个case语句将一个<code class="eh kn ko kp ju b">Int</code>取消装箱为一个原始的取消装箱的<code class="eh kn ko kp ju b">Int#</code>，</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="ad16" class="jy jz hu ju b fv ka kb l kc kd">case x of<br/>  { I# unbox </span></pre><p id="1a08" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后设置时装箱。</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="2faa" class="jy jz hu ju b fv ka kb l kc kd">case writeMutVar# ioRef (I# (+# unbox 1#)) token'</span></pre><p id="6e45" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kn ko kp ju b">I#</code>是<code class="eh kn ko kp ju b">Int</code>构造函数(<code class="eh kn ko kp ju b">#</code>意味着它是一个编译器原语)。它包装或装箱一个未打包的、未装箱的“机器”int。大多数时候，GHC可以自动取消原语的装箱，但在这种情况下它不能。装箱/拆箱可能是经济放缓的根源。</p><p id="f800" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们需要一个未装箱的可变引用。我能想到两个选项:<a class="ae km" href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Foreign-Ptr.html" rel="noopener ugc nofollow" target="_blank"> Ptr Int </a>和<a class="ae km" href="http://hackage.haskell.org/package/primitive-0.5.3.0/docs/Data-Primitive-ByteArray.html#t:MutableByteArray" rel="noopener ugc nofollow" target="_blank"> MutableByteArray </a>。</p><p id="d161" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第<code class="eh kn ko kp ju b">Ptr</code>版:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="c004" class="jy jz hu ju b fv ka kb l kc kd">main = alloca $ \ptr -&gt; do<br/>   poke ptr (0 :: Int)<br/>   replicateM_ 100000000 $ do<br/>     i &lt;- peek ptr<br/>     let !i' = i + 1<br/>     poke ptr i'</span></pre><p id="e08d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">跑步时，我得到:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="63e9" class="jy jz hu ju b fv ka kb l kc kd">bench ./bin/ptr-loop</span><span id="23b9" class="jy jz hu ju b fv kl kb l kc kd">benchmarking ./bin/ptr-loop<br/>time                 175.2 ms   (174.1 ms .. 176.2 ms)<br/>                     1.000 R²   (0.999 R² .. 1.000 R²)<br/>mean                 174.7 ms   (174.1 ms .. 175.2 ms)<br/>std dev              1.626 ms   (1.372 ms .. 2.089 ms)</span></pre><p id="7705" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这很好！几乎快了一倍<code class="eh kn ko kp ju b">IORef</code>。</p><figure class="jp jq jr js fq kq"><div class="bz el l di"><div class="kr ks l"/></div></figure><p id="b3fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在的<code class="eh kn ko kp ju b">MutableByteBuffer</code>版本:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="a694" class="jy jz hu ju b fv ka kb l kc kd">main = do<br/>  mba &lt;- newAlignedPinnedByteArray 4 8<br/>  replicateM_ 100000000 $ do<br/>      i &lt;- readByteArray mba 0 :: IO Int<br/>      let !i' = i + 1<br/>      writeByteArray mba 0 i'</span></pre><p id="deaa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">跑步:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="6ce2" class="jy jz hu ju b fv ka kb l kc kd">bench ./bin/mutable-byte-buffer-loop</span><span id="9f95" class="jy jz hu ju b fv kl kb l kc kd">benchmarking ./bin/mutable-byte-buffer-loop<br/>time                 175.2 ms   (173.5 ms .. 177.3 ms)<br/>                     0.999 R²   (0.999 R² .. 1.000 R²)<br/>mean                 177.4 ms   (176.5 ms .. 178.4 ms)<br/>std dev              2.423 ms   (1.987 ms .. 2.919 ms)</span></pre><p id="ac7c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">基本一致。</p><p id="30cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我有进步，但是我不想用<code class="eh kn ko kp ju b">Ptr</code>或者<code class="eh kn ko kp ju b">MutableByteBuffer</code>。它们不是很安全(<code class="eh kn ko kp ju b">Ptr</code>可以说是足够安全了，但如果可以的话，我宁愿不要直接手动分配内存)。</p><p id="a40b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果其中一个类型有一个安全的包装就好了。有！<code class="eh kn ko kp ju b">Vector</code>是围绕<code class="eh kn ko kp ju b">MutableByteBuffer</code>的安全包装。下面是<code class="eh kn ko kp ju b">Vector</code>版本:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="5503" class="jy jz hu ju b fv ka kb l kc kd">main = do<br/>  mba &lt;- M.new 1<br/>  replicateM_ 100000000 $ do<br/>      i &lt;- M.read mba 0 :: IO Int<br/>      let !i' = i + 1<br/>      M.write mba 0 i'</span></pre><p id="052b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">跑步:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="f034" class="jy jz hu ju b fv ka kb l kc kd">bench ./bin/vector-loop</span><span id="cd89" class="jy jz hu ju b fv kl kb l kc kd">benchmarking ./bin/vector-loop<br/>time                 178.6 ms   (177.3 ms .. 179.9 ms)<br/>                     1.000 R²   (0.999 R² .. 1.000 R²)<br/>mean                 178.2 ms   (177.1 ms .. 179.3 ms)<br/>std dev              3.021 ms   (2.082 ms .. 4.288 ms)</span></pre><p id="afd2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不错！只需增加很少的时间，我们就可以获得一个快速的、未装箱的可变引用的安全接口。对单个元素使用集合类型有点奇怪，但也不可怕。</p><h1 id="5816" class="kt jz hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">桌子上有什么</h1><p id="ad34" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated"><code class="eh kn ko kp ju b">CLoopVolatile</code>和<code class="eh kn ko kp ju b">AsmLoop.asm</code>不是编写递增一个数的循环的最快方法。这将涉及到在循环期间将引用放在寄存器中，以及像循环展开这样的其他技巧。这里有一个简单的汇编例子，可以让你感受一下速度有多快。</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="62e8" class="jy jz hu ju b fv ka kb l kc kd">; FastAsmLoop.asm<br/>EXTERN _exit<br/>GLOBAL start</span><span id="11d9" class="jy jz hu ju b fv kl kb l kc kd">SECTION .text<br/>start:<br/>   mov rcx, 0<br/>   mov rax, 100000000</span><span id="d580" class="jy jz hu ju b fv kl kb l kc kd">loopBlock:<br/>   inc qword rcx     ; <br/>   cmp rcx, rax      ; <br/>   jl loopBlock      ; </span><span id="d8e0" class="jy jz hu ju b fv kl kb l kc kd">exitBlock:<br/>  mov     rax, 0x2000001 ; exit<br/>  mov     rdi, 0<br/>  syscall</span></pre><p id="d71c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">收集</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="efb2" class="jy jz hu ju b fv ka kb l kc kd">$ nasm -fmacho64 src/FastAsmLoop.asm <br/>$ ld -o ./bin/FastAsmLoop -macosx_version_min 10.7.0 \ <br/>      ./src/FastAsmLoop.o <br/>$ bench ./bin/FastAsmLoop;</span><span id="361c" class="jy jz hu ju b fv kl kb l kc kd">benchmarking ./bin/FastAsmLoop<br/>time                 38.38 ms   (37.96 ms .. 39.15 ms)<br/>                     0.999 R²   (0.995 R² .. 1.000 R²)<br/>mean                 38.22 ms   (37.98 ms .. 38.87 ms)<br/>std dev              715.8 μs   (282.6 μs .. 1.261 ms)</span></pre><p id="c2f3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我几乎不相信这些数字，但我认为这表明GHC仍然有一些表现。</p><p id="b585" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另外值得注意的是，在Haskell中，这并不是一个紧密循环的写法。人们不需要可变的引用。在以后的文章中，我想对Haskell和assembly做更直接的比较。C代码实际上只是一个基线，引导我去研究GHC在做什么。</p><p id="b00b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="kh">更新:Michael Snoyman提醒我他的一个包提供了一个未装箱的可变引用，以及其他一些好东西:</em><a class="ae km" href="https://www.stackage.org/haddock/lts-8.16/mutable-containers-0.3.3/Data-Mutable.html#t:URef" rel="noopener ugc nofollow" target="_blank"><em class="kh">https://www . stack age . org/haddock/lts-8.16/mutable-containers-0 . 3 . 3/Data-mutable . html # t:URef</em></a></p><p id="9117" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">包含该代码的项目也可以产生这些计时，可以在这里找到:<a class="ae km" href="https://github.com/jfischoff/are-mutable-references-in-haskell-fast" rel="noopener ugc nofollow" target="_blank">https://github . com/jfischoff/are-mutable-references-in-haskell-fast</a></p><blockquote class="ke kf kg"><p id="3b0b" class="ir is kh it b iu iv iw ix iy iz ja jb ki jd je jf kj jh ji jj kk jl jm jn jo hn dt translated"><a class="ae km" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae km" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae km" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae km" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is kh it b iu iv iw ix iy iz ja jb ki jd je jf kj jh ji jj kk jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae km" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae km" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae km" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is kh it b iu iv iw ix iy iz ja jb ki jd je jf kj jh ji jj kk jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae km" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae km" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jp jq jr js fq kq"><div class="bz el l di"><div class="lv ks l"/></div></figure></div></div>    
</body>
</html>