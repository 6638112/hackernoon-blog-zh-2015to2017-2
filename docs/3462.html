<html>
<head>
<title>How to make the fastest Promise library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何最快做出承诺库</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-make-the-fastest-promise-library-f632fd69f3cb?source=collection_archive---------9-----------------------#2017-04-03">https://medium.com/hackernoon/how-to-make-the-fastest-promise-library-f632fd69f3cb?source=collection_archive---------9-----------------------#2017-04-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="d4e1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我开发了<code class="eh jp jq jr js b"><a class="ae jt" href="https://github.com/suguru03/aigle" rel="noopener ugc nofollow" target="_blank">Aigle</a></code>，这是一个快速承诺库。灵感来源于<code class="eh jp jq jr js b"><a class="ae jt" href="https://github.com/petkaantonov/bluebird" rel="noopener ugc nofollow" target="_blank">Bluebir</a>d</code>。该库不仅是一个基准测试，还是一个实现Promise A+标准的产品化库，而且比T2更快。</p><h1 id="0b0b" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated"><strong class="ak">什么是承诺？</strong></h1><p id="a5ed" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">在解释之前，我想提供一些关于承诺的基本信息。一个承诺可以有三种状态:<code class="eh jp jq jr js b">pending</code>、<code class="eh jp jq jr js b">fulfilled</code>和<code class="eh jp jq jr js b">rejected</code>。一旦状态从<code class="eh jp jq jr js b">pending</code>变为另一个状态，该状态就不能再改变。</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="fe ff kx"><img src="../Images/8a44d97bd7f1f5d5c7e5dd4206ec98ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g1EZpcctuSoa6Jcwp68SUQ.png"/></div></div><figcaption class="lj lk fg fe ff ll lm bd b be z ek">Promise states (quote: <a class="ae jt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">MDN</a>)</figcaption></figure><p id="b16d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，承诺必须总是异步解决，这是最重要的事情之一。</p><pre class="ky kz la lb fq ln js lo lp aw lq dt"><span id="6e1c" class="lr jv hu js b fv ls lt l lu lv"><strong class="js hv">new</strong> Promise(resolve =&gt; resolve(1)) // synchronously<br/>  .then(num =&gt; {<br/>    // called asynchronously<br/>  });</span></pre><h1 id="1f03" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">高性能库的最佳实践</h1><p id="2558" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">当我开发库时，我总是遵循这三个原则。</p><ul class=""><li id="7c03" class="lw lx hu it b iu iv iy iz jc ly jg lz jk ma jo mb mc md me dt translated">避免创建不必要的变量、函数和实例</li><li id="2065" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mb mc md me dt translated">避免执行不必要的功能</li><li id="e499" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mb mc md me dt translated">巧妙处理异步函数</li></ul><h2 id="3aa2" class="lr jv hu bd jw mk ml mm ka mn mo mp ke jc mq mr ki jg ms mt km jk mu mv kq mw dt translated">避免创建不必要的变量、函数和实例</h2><p id="9cf9" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">遵循这一原则有助于避免不必要的内存分配。举个例子，</p><pre class="ky kz la lb fq ln js lo lp aw lq dt"><span id="6a63" class="lr jv hu js b fv ls lt l lu lv"><strong class="js hv">function</strong> sum(array) {<br/>  <strong class="js hv">return</strong> array.reduce(<strong class="js hv">function</strong> iterator(result, num) {<br/>    <strong class="js hv">return</strong> result <strong class="js hv">+</strong> num;<br/>  });<br/>}<br/><br/>sum([1, 2, 3]); <em class="mx">// 6</em></span></pre><p id="54c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当调用<code class="eh jp jq jr js b">sum</code>时，总是会创建<code class="eh jp jq jr js b">iterator</code>函数。这是一种不必要的内存分配。代码被重写以遵循下一个例子。</p><pre class="ky kz la lb fq ln js lo lp aw lq dt"><span id="5680" class="lr jv hu js b fv ls lt l lu lv"><strong class="js hv">function</strong> iterator(result, num) {<br/>  <strong class="js hv">return</strong> result <strong class="js hv">+</strong> num;<br/>}<br/><br/><strong class="js hv">function</strong> sum(array) {<br/>  <strong class="js hv">return</strong> array.reduce(iterator);<br/>}<br/><br/>sum([1, 2, 3]); <em class="mx">// 6</em></span></pre><p id="1d68" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">代码避免了不必要的函数。</p><p id="0017" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来是另一个额外的内存分配的例子。</p><pre class="ky kz la lb fq ln js lo lp aw lq dt"><span id="bad0" class="lr jv hu js b fv ls lt l lu lv"><strong class="js hv">function</strong> get(type) {<br/>  <strong class="js hv">const</strong> array <strong class="js hv">=</strong> [];<br/>  <strong class="js hv">const</strong> object <strong class="js hv">=</strong> {};<br/>  <strong class="js hv">const</strong> number <strong class="js hv">=</strong> 0;<br/>  <strong class="js hv">const</strong> string <strong class="js hv">=</strong> '';<br/>  <strong class="js hv">switch</strong> (type) {<br/>  <strong class="js hv">case</strong> 'array'<strong class="js hv">:</strong><br/>    <strong class="js hv">return</strong> array;<br/>  <strong class="js hv">case</strong> 'object'<strong class="js hv">:</strong><br/>    <strong class="js hv">return</strong> object;<br/>  <strong class="js hv">case</strong> 'number'<strong class="js hv">:</strong><br/>    <strong class="js hv">return</strong> number;<br/>  <strong class="js hv">case</strong> 'string'<strong class="js hv">:</strong><br/>    <strong class="js hv">return</strong> string;<br/>  }<br/>}<br/>get('string');</span></pre><p id="3deb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这种情况下，<code class="eh jp jq jr js b">string</code>是唯一必需的变量。<code class="eh jp jq jr js b">array</code>、<code class="eh jp jq jr js b">object</code>和<code class="eh jp jq jr js b">number</code>不需要。代码重写如下:</p><pre class="ky kz la lb fq ln js lo lp aw lq dt"><span id="bac1" class="lr jv hu js b fv ls lt l lu lv"><strong class="js hv">function</strong> get(type) {<br/>  <strong class="js hv">switch</strong> (type) {<br/>  <strong class="js hv">case</strong> 'array'<strong class="js hv">:</strong><br/>    <strong class="js hv">return</strong> [];<br/>  <strong class="js hv">case</strong> 'object'<strong class="js hv">:</strong><br/>    <strong class="js hv">return</strong> {};<br/>  <strong class="js hv">case</strong> 'number'<strong class="js hv">:</strong><br/>    <strong class="js hv">return</strong> 0;<br/>  <strong class="js hv">case</strong> 'string'<strong class="js hv">:</strong><br/>    <strong class="js hv">return</strong> '';<br/>  }<br/>}<br/>get('string');</span></pre><p id="46ad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这两个例子之间没有太大的区别，但是如果在函数中创建实例或函数，就会有很大的区别。</p><h2 id="b924" class="lr jv hu bd jw mk ml mm ka mn mo mp ke jc mq mr ki jg ms mt km jk mu mv kq mw dt translated">避免执行不必要的功能</h2><p id="b506" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">例如，在创建API时，有必要检查请求参数。</p><pre class="ky kz la lb fq ln js lo lp aw lq dt"><span id="20ed" class="lr jv hu js b fv ls lt l lu lv"><strong class="js hv">function</strong> api(req, res) {<br/>  <strong class="js hv">const</strong> { id } <strong class="js hv">=</strong> req.body;<br/>  <strong class="js hv">if</strong> (<strong class="js hv">!</strong>isNumber(id)) {<br/>     <strong class="js hv">return</strong> res.sendStatus(400);<br/>  }<br/>  innerFunc(id)<br/>    .then(...)<br/>    .<strong class="js hv">catch</strong>(...)<br/>}<br/><br/><strong class="js hv">function</strong> isNumber(id) {<br/>  <strong class="js hv">return</strong> <strong class="js hv">typeof</strong> id <strong class="js hv">===</strong> 'number';<br/>}<br/><br/><strong class="js hv">function</strong> innerFunc(id) {<br/>  <strong class="js hv">if</strong> (<strong class="js hv">!</strong>isNumber(id)) {<br/>    <strong class="js hv">return</strong> Promise.reject(<strong class="js hv">new</strong> Error('error'));<br/>  }<br/>  ...<br/>}</span></pre><p id="22a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当实现API时，最好检查内部函数中的参数，因为该函数可能会被其他函数调用。然而，当实现库时，函数不需要检查参数。在执行内部函数之前，参数已经被检查过了，所以没有必要在内部函数中再次检查它们。</p><h2 id="a550" class="lr jv hu bd jw mk ml mm ka mn mo mp ke jc mq mr ki jg ms mt km jk mu mv kq mw dt translated">巧妙处理异步函数</h2><p id="d088" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">我想用<code class="eh jp jq jr js b">Bluebird</code>的例子来解释这个概念。</p><h1 id="05df" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">什么使<code class="eh jp jq jr js b">Bluebird fast?</code></h1><p id="4767" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">如果你打开<code class="eh jp jq jr js b">Bluebird</code>库代码，你会看到<code class="eh jp jq jr js b">bitField</code>参数。但是<code class="eh jp jq jr js b">bitField</code>并不那么重要。<br/> <code class="eh jp jq jr js b">Bluebird</code>大致有两种状态:<code class="eh jp jq jr js b">pending</code>与否。处理的最大区别在于两种状态。</p><h2 id="2904" class="lr jv hu bd jw mk ml mm ka mn mo mp ke jc mq mr ki jg ms mt km jk mu mv kq mw dt translated">如果状态为待定:</h2><pre class="ky kz la lb fq ln js lo lp aw lq dt"><span id="3927" class="lr jv hu js b fv ls lt l lu lv"><strong class="js hv">new</strong> Bluebird(<strong class="js hv">function</strong> executor(resolve) { <br/>  // called synchronously<br/>  setTimeout(<strong class="js hv">function</strong> timer() {<br/>    resolve(1); <em class="mx">// called asynchronously</em><br/>  }, 10);<br/>})<br/>.then(<strong class="js hv">function</strong> onFulfilled(value) {<br/>  <em class="mx">//  called asynchronously</em><br/>});</span></pre><p id="e336" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个执行顺序是，</p><ol class=""><li id="caad" class="lw lx hu it b iu iv iy iz jc ly jg lz jk ma jo my mc md me dt translated">当新的<code class="eh jp jq jr js b">Bluebird</code>被调用时，创建<code class="eh jp jq jr js b">Bluebird</code>的父实例</li><li id="2901" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo my mc md me dt translated">执行<code class="eh jp jq jr js b">executor</code></li><li id="6476" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo my mc md me dt translated">执行<code class="eh jp jq jr js b">then</code>。<code class="eh jp jq jr js b">then</code>创建<code class="eh jp jq jr js b">Bluebird</code>的子实例</li><li id="2e82" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo my mc md me dt translated">执行<code class="eh jp jq jr js b">resolve</code></li><li id="775e" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo my mc md me dt translated">执行<code class="eh jp jq jr js b">onFulfilled</code></li></ol><p id="3f50" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当调用<code class="eh jp jq jr js b">then</code>时，<a class="ae jt" href="https://github.com/petkaantonov/bluebird/blob/v3.4.7/src/promise.js#L228" rel="noopener ugc nofollow" target="_blank">一个子实例被创建</a>。那时，<code class="eh jp jq jr js b">resolve</code>还没有被调用，所以父状态是<code class="eh jp jq jr js b">pending</code>。当状态为<code class="eh jp jq jr js b">pending</code>、<a class="ae jt" href="https://github.com/petkaantonov/bluebird/blob/v3.4.7/src/promise.js#L416" rel="noopener ugc nofollow" target="_blank">时，子实例作为子实例</a>链接到父实例。之后<code class="eh jp jq jr js b"><a class="ae jt" href="https://github.com/petkaantonov/bluebird/blob/v3.4.7/src/promise.js#L513" rel="noopener ugc nofollow" target="_blank">resolve</a></code> <a class="ae jt" href="https://github.com/petkaantonov/bluebird/blob/v3.4.7/src/promise.js#L513" rel="noopener ugc nofollow" target="_blank">被<code class="eh jp jq jr js b">setTimeout</code>异步调用</a>。然后，<code class="eh jp jq jr js b"><a class="ae jt" href="https://github.com/petkaantonov/bluebird/blob/v3.4.7/src/promise.js#L703-L710" rel="noopener ugc nofollow" target="_blank">onFulfilled</a></code>T34被调用，结果为。<br/>当状态为<code class="eh jp jq jr js b">pending</code>时，子实例链接到父实例。调用<code class="eh jp jq jr js b">resolve</code>后，调用<code class="eh jp jq jr js b">onFulfilled</code>。这很简单。</p><h2 id="5101" class="lr jv hu bd jw mk ml mm ka mn mo mp ke jc mq mr ki jg ms mt km jk mu mv kq mw dt translated">如果状态不是待定:</h2><pre class="ky kz la lb fq ln js lo lp aw lq dt"><span id="8b5a" class="lr jv hu js b fv ls lt l lu lv"><strong class="js hv">new</strong> Bluebird(<strong class="js hv">function</strong> executor(resolve) {<br/>  resolve(); <em class="mx">// called synchronously</em><br/>})<br/>.then(<strong class="js hv">function</strong> onFulfilled(value) {<br/>  <em class="mx">// ensured asynchronously</em><br/>});</span></pre><p id="257b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">执行顺序是</p><ol class=""><li id="3d03" class="lw lx hu it b iu iv iy iz jc ly jg lz jk ma jo my mc md me dt translated">当新的<code class="eh jp jq jr js b">Bluebird</code>被调用时，创建<code class="eh jp jq jr js b">Bluebird</code>的父实例</li><li id="3792" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo my mc md me dt translated">执行<code class="eh jp jq jr js b">executor</code></li><li id="0424" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo my mc md me dt translated">执行<code class="eh jp jq jr js b">resolve</code></li><li id="b6b3" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo my mc md me dt translated">执行<code class="eh jp jq jr js b">then</code>。<code class="eh jp jq jr js b">then</code>创建<code class="eh jp jq jr js b">Bluebird</code>的子实例</li><li id="92be" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo my mc md me dt translated">执行<code class="eh jp jq jr js b">onFulfilled</code></li></ol><p id="2169" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">调用<code class="eh jp jq jr js b">then</code>时，父状态已经不是<code class="eh jp jq jr js b">pending</code>。在这种情况下，如果在没有任何东西的情况下调用<code class="eh jp jq jr js b">onFulfilled</code>，则函数同步执行。出于这个原因，库需要<a class="ae jt" href="https://github.com/petkaantonov/bluebird/blob/v3.4.7/src/promise.js#L263-L270" rel="noopener ugc nofollow" target="_blank">调用一个异步函数</a>。在调用该函数之前，<code class="eh jp jq jr js b">onFulfilled</code>被<a class="ae jt" href="https://github.com/petkaantonov/bluebird/blob/v3.4.7/src/async.js#L88" rel="noopener ugc nofollow" target="_blank">设置为</a> a <code class="eh jp jq jr js b"><a class="ae jt" href="https://github.com/petkaantonov/bluebird/blob/v3.4.7/src/async.js#L88" rel="noopener ugc nofollow" target="_blank">queue</a></code>，这个<code class="eh jp jq jr js b"><a class="ae jt" href="https://github.com/petkaantonov/bluebird/blob/v3.4.7/src/async.js#L159" rel="noopener ugc nofollow" target="_blank">schedule</a></code> <a class="ae jt" href="https://github.com/petkaantonov/bluebird/blob/v3.4.7/src/async.js#L159" rel="noopener ugc nofollow" target="_blank">函数被称为</a>。Node.js上的<code class="eh jp jq jr js b">schedule</code>是<code class="eh jp jq jr js b">setImmediate</code>，然后<code class="eh jp jq jr js b"><a class="ae jt" href="https://github.com/petkaantonov/bluebird/blob/v3.4.7/src/async.js#L144" rel="noopener ugc nofollow" target="_blank">setImmediate</a></code> <a class="ae jt" href="https://github.com/petkaantonov/bluebird/blob/v3.4.7/src/async.js#L144" rel="noopener ugc nofollow" target="_blank">异步调用所有排队的函数</a>。<br/>当状态不是<code class="eh jp jq jr js b">pending</code>时，将<code class="eh jp jq jr js b">onFulfilled</code>置为<code class="eh jp jq jr js b">queue</code>，然后由异步函数执行排队函数。</p><p id="5756" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可能想知道为什么<code class="eh jp jq jr js b">onFulfilled</code>被设置为<code class="eh jp jq jr js b">queue</code>。这是<code class="eh jp jq jr js b">Bluebird</code>中最聪明的想法。</p><h2 id="f7b0" class="lr jv hu bd jw mk ml mm ka mn mo mp ke jc mq mr ki jg ms mt km jk mu mv kq mw dt translated">如何灵活处理异步函数</h2><p id="4787" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">我想用这个例子来解释一下。</p><pre class="ky kz la lb fq ln js lo lp aw lq dt"><span id="0b4e" class="lr jv hu js b fv ls lt l lu lv">Bluebird.resolve(1) <em class="mx">// synchronously</em><br/>  .then(num <strong class="js hv">=&gt;</strong> console.log(num)); <em class="mx">// asynchronously</em><br/>Bluebird.resolve(2) <em class="mx">// synchronously</em><br/>  .then(num <strong class="js hv">=&gt;</strong> console.log(num)); <em class="mx">// asynchronously</em><br/>Bluebird.resolve(3) <em class="mx">// synchronously</em><br/>  .then(num <strong class="js hv">=&gt;</strong> console.log(num)); <em class="mx">// asynchronously</em></span></pre><p id="59b7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果没有使用<code class="eh jp jq jr js b">queue</code>，异步函数将被调用三次。但是如果使用了一个<code class="eh jp jq jr js b">queue</code>,这个函数会立刻执行所有排队的函数。我不确定<code class="eh jp jq jr js b">bitField</code>是否会带来很大的好处。但是我觉得<code class="eh jp jq jr js b">Bluebird</code>为什么快是因为简单。</p><h1 id="cc39" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">是什么让Aigle快速？</h1><p id="ac77" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">我刚刚遵循了这些重要的原则，</p><ul class=""><li id="1785" class="lw lx hu it b iu iv iy iz jc ly jg lz jk ma jo mb mc md me dt translated">避免创建不必要的变量、函数和实例</li><li id="00bf" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mb mc md me dt translated">避免执行不必要的功能</li><li id="6d08" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mb mc md me dt translated">巧妙处理异步函数</li></ul><p id="93fc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你遵循它们，你将能够创建好的图书馆。我做了一个<a class="ae jt" href="https://github.com/suguru03/aigle/tree/master/benchmark#benchmark" rel="noopener ugc nofollow" target="_blank">基准</a>来检查<code class="eh jp jq jr js b">Aigle</code>和<code class="eh jp jq jr js b">Bluebird</code>之间的性能。基准测试结果在这里。</p><ul class=""><li id="dcbb" class="lw lx hu it b iu iv iy iz jc ly jg lz jk ma jo mb mc md me dt translated">节点6.9.1</li><li id="6c41" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mb mc md me dt translated">Aigle v0.5.0</li><li id="209b" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mb mc md me dt translated">蓝鸟3.5.0版</li></ul><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="fe ff mz"><img src="../Images/f40777805951894ec83a871954307fe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RTUPNZWTZKBl-WU2zbKM7A.png"/></div></div><figcaption class="lj lk fg fe ff ll lm bd b be z ek">Aigle vs Bluebird</figcaption></figure><p id="0611" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jp jq jr js b">Aigle</code>实现非常简单，因此比<code class="eh jp jq jr js b">Bluebird</code>快。如果你对<code class="eh jp jq jr js b">Aigle</code>感兴趣，我希望你能为它做出贡献。</p><h2 id="4916" class="lr jv hu bd jw mk ml mm ka mn mo mp ke jc mq mr ki jg ms mt km jk mu mv kq mw dt translated">适用于生产环境</h2><p id="f3f2" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">最重要的部分是<code class="eh jp jq jr js b">aigle-core</code>依赖。<br/>在<code class="eh jp jq jr js b">Bluebird</code>中，每个promise实例都必须是<code class="eh jp jq jr js b">Bluebird</code>的实例。选中实例时，调用<code class="eh jp jq jr js b">instanceof</code>函数。但是<code class="eh jp jq jr js b">Bluebird</code>只检查实例是否是由当前<strong class="it hv">的</strong>类<code class="eh jp jq jr js b"><strong class="it hv">Bluebird</strong></code>生成的。所以如果用了很多版本，<code class="eh jp jq jr js b">Bluebird</code>会变慢。避免性能损失的关键是拥有相同的依赖性。<code class="eh jp jq jr js b">Aigle</code>有<code class="eh jp jq jr js b">aigle-core</code>依赖，因此每个<code class="eh jp jq jr js b">Aigle</code>实例都由同一个<code class="eh jp jq jr js b">AigleCore</code>类扩展。<code class="eh jp jq jr js b">Aigle</code>会保持高性能。</p><p id="e679" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我想向<a class="ae jt" href="https://github.com/suguru03/aigle-benchmark" rel="noopener ugc nofollow" target="_blank">展示一下基准示例</a>。</p><pre class="ky kz la lb fq ln js lo lp aw lq dt"><span id="ab21" class="lr jv hu js b fv ls lt l lu lv">$ npm list<br/>aigle-benchmark@0.0.0 <br/>├─┬ aigle@0.5.0 &lt;- aigle@0.5.0 has aigle-core@0.2.0<br/>│ └── aigle-core@0.2.0<br/>├─┬ benchmark@2.1.3<br/>│ └── platform@1.3.3<br/>├── bluebird@3.5.0<br/>├── lodash@4.17.4<br/>├── minimist@1.2.0<br/>└─┬ promise-libraries@0.3.0<br/>  ├── aigle@0.4.0 &lt;- aigle@0.4.0 has aigle-core@0.2.0 too<br/>  └── bluebird@3.4.6</span></pre><p id="0862" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如您所见，不同的<code class="eh jp jq jr js b">aigle</code>依赖项有相同的<code class="eh jp jq jr js b">aigle-core</code>子依赖项。使用<code class="eh jp jq jr js b">aigle@0.4.0</code>时，共享<code class="eh jp jq jr js b">aigle-core</code>。</p><ul class=""><li id="79b7" class="lw lx hu it b iu iv iy iz jc ly jg lz jk ma jo mb mc md me dt translated">节点6.9.1</li><li id="64a1" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mb mc md me dt translated"><code class="eh jp jq jr js b">Aigle</code> v0.4.0，v0.5.0</li><li id="f7c5" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mb mc md me dt translated"><code class="eh jp jq jr js b">Bluebird</code>版本3.4.6，版本3.5.0</li></ul><pre class="ky kz la lb fq ln js lo lp aw lq dt"><span id="6146" class="lr jv hu js b fv ls lt l lu lv">$ node --expose_gc . -t then<br/>======================================<br/>[Aigle] v0.5.0<br/>[Bluebird] v3.5.0<br/>======================================<br/>[promise:then:same] Preparing...<br/>--------------------------------------<br/>[promise:then:same] Executing...<br/>[1] "aigle" 180μs[1.00][1.00]<br/>[2] "bluebird" 341μs[0.526][1.90]<br/>======================================<br/>[promise:then:diff] Preparing...<br/>--------------------------------------<br/>[promise:then:diff] Executing...<br/>[1] "aigle" 178μs[1.00][1.00]<br/>[2] "bluebird" 506μs[0.352][2.84]</span></pre><p id="553b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jp jq jr js b">promise:then:same</code>使用相同的版本，而<code class="eh jp jq jr js b">promise:then:diff</code>使用不同版本的子实例。<code class="eh jp jq jr js b">Aigle</code>即使版本混杂也不会慢下来。</p><h1 id="5632" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">结论</h1><p id="7ba6" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">如果你遵循这三个重要的原则，你会建立一个快速的图书馆。<br/>还有<code class="eh jp jq jr js b">Aigle</code>受<code class="eh jp jq jr js b"><a class="ae jt" href="https://github.com/caolan/async" rel="noopener ugc nofollow" target="_blank">Async</a></code>和<code class="eh jp jq jr js b"><a class="ae jt" href="https://github.com/suguru03/neo-async" rel="noopener ugc nofollow" target="_blank">Neo-Async</a></code>启发有很多功能。如果你还在使用回调风格，我想鼓励你使用<code class="eh jp jq jr js b">Aigle</code>。<br/>如果我能为<code class="eh jp jq jr js b">Node.js</code>和<code class="eh jp jq jr js b">JavaScript</code>社区做出贡献，我会很高兴成为一名贡献者。</p><h1 id="c5cf" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">参考</h1><ul class=""><li id="3282" class="lw lx hu it b iu ks iy kt jc na jg nb jk nc jo mb mc md me dt translated"><code class="eh jp jq jr js b"><a class="ae jt" href="https://github.com/suguru03/aigle" rel="noopener ugc nofollow" target="_blank">Aigle</a></code></li><li id="2b80" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mb mc md me dt translated"><code class="eh jp jq jr js b"><a class="ae jt" href="https://github.com/petkaantonov/bluebird" rel="noopener ugc nofollow" target="_blank">Bluebird</a></code></li><li id="4448" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mb mc md me dt translated"><a class="ae jt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank"> MDN </a></li></ul><div class="ky kz la lb fq ab cb"><figure class="nd lc ne nf ng nh ni paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nd lc ne nf ng nh ni paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nd lc ne nf ng nh ni paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="nj nk nl"><p id="f922" class="ir is mx it b iu iv iw ix iy iz ja jb nm jd je jf nn jh ji jj no jl jm jn jo hn dt translated"><a class="ae jt" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是阿妹家庭的一员。我们现在<a class="ae jt" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jt" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is mx it b iu iv iw ix iy iz ja jb nm jd je jf nn jh ji jj no jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jt" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jt" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="fe ff np"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>