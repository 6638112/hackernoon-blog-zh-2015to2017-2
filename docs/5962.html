<html>
<head>
<title>Data Immutability with vanilla JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">普通JavaScript的数据不变性</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/data-immutability-with-vanilla-javascript-63834a65a6c9?source=collection_archive---------5-----------------------#2017-08-26">https://medium.com/hackernoon/data-immutability-with-vanilla-javascript-63834a65a6c9?source=collection_archive---------5-----------------------#2017-08-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="aa12" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">与JavaScript世界中的大多数<em class="jj">趋势</em>不同，数据不变性必定会伴随我们一段时间，这是有充分理由的:首先，因为它不是<em class="jj">一种趋势:</em>它是一种编码方式(和用代码思考),促进了清晰性、易用性和对数据流的理解，并使代码更不容易出错。</h2></div><p id="b231" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">尽管新版本的JS语言给了我们一个比以前更健壮的工具集，而没有使用像<a class="ae kg" href="https://facebook.github.io/immutable-js/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm hv"> Immutable.js </strong> </a>这样的库，但是当你把它们放在一起时，事情看起来还是有点可怕。熟悉阅读和编写最常见的用例非常有帮助。</p><p id="e23a" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">在这篇简短的帖子中，我们将看看纯JS的方式(使用ES2015++，是的，我可能刚刚发明了这种符号)来添加、删除和更新对象、数组中深度嵌套的属性，并找到通用模式来重现这些操作。</p><p id="d793" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated"><em class="kh">游乐场:</em> <a class="ae kg" href="http://jsbin.com/kikajon/edit?js,console" rel="noopener ugc nofollow" target="_blank"> <em class="kh">直接链接到JS Bin </em> </a></p><h1 id="0b65" class="ki kj hu bd kk kl km kn ko kp kq kr ks ja kt jb ku jd kv je kw jg kx jh ky kz dt translated">目标</h1><p id="21ee" class="pw-post-body-paragraph jk jl hu jm b jn la iv jp jq lb iy js jt lc jv jw jx ld jz ka kb le kd ke kf hn dt translated">让我们以一个初始对象<code class="eh lf lg lh li b">person</code>为例，我们可以把它看作是一段应用程序状态，我们希望对它进行变异。àlàredux思考，我们应该总是返回这个状态的新副本，<strong class="jm hv">永远不要直接改变它</strong>。</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="3b15" class="lr kj hu li b fv ls lt l lu lv">const person = { <br/>  name: 'Ricardo', <br/>  location: 'Berlin', <br/>  interests: { coffee: 9, climbing: 9, wasps: 0 } <br/>};</span></pre><h1 id="678b" class="ki kj hu bd kk kl km kn ko kp kq kr ks ja kt jb ku jd kv je kw jg kx jh ky kz dt translated">更改简单对象属性</h1><p id="3031" class="pw-post-body-paragraph jk jl hu jm b jn la iv jp jq lb iy js jt lc jv jw jx ld jz ka kb le kd ke kf hn dt translated">使用<code class="eh lf lg lh li b">Object.assign</code>修改顶级属性非常简单。我们将探索它的更多用例(和替代品),但现在让我们简单地创建一个修改过的对象副本，将<code class="eh lf lg lh li b">name</code>设置为“道格拉斯”。</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="db07" class="lr kj hu li b fv ls lt l lu lv">const updatedPerson = Object.assign({}, person, { <br/>  name: 'Douglas' <br/>});</span></pre><p id="c6e4" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated"><em class="kh">简单的</em>。我们告诉Object.assign给<em class="kh">取这个空{}，在上面应用person，并修改name属性</em>。我们物体的其余部分看起来是一样的。</p><h1 id="dfc7" class="ki kj hu bd kk kl km kn ko kp kq kr ks ja kt jb ku jd kv je kw jg kx jh ky kz dt translated">更改深度嵌套的属性</h1><p id="626c" class="pw-post-body-paragraph jk jl hu jm b jn la iv jp jq lb iy js jt lc jv jw jx ld jz ka kb le kd ke kf hn dt translated">这里有一个使用<code class="eh lf lg lh li b">Object.assign</code>复制对象时常见的错误:忘记复制我们试图变异的<strong class="jm hv">内部对象</strong>。假设我们要将<em class="kh">咖啡</em>兴趣改为<em class="kh"> 10 </em>和<code class="eh lf lg lh li b">location</code>从“柏林”到“月球”(柏林的一条普通火车路线)。如果我们尝试以下应用程序会怎么样:</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="d5c1" class="lr kj hu li b fv ls lt l lu lv">const updated = Object.assign({}, person, { <br/>  location: 'Moon', <br/>  interests: { <br/>    coffee: 10 // <strong class="li hv">Crap! Only this one is copied </strong><br/>  } <br/>});</span></pre><p id="fa37" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">从表面上看，这似乎行得通，但这并没有复制<code class="eh lf lg lh li b">interests</code>对象的其余部分。它会给我们留下更新的<code class="eh lf lg lh li b">{coffee: 10}</code>和<code class="eh lf lg lh li b">location: 'Moon'</code>，但不会复制<code class="eh lf lg lh li b">climbing</code>或<code class="eh lf lg lh li b">wasps</code>。反正没人需要黄蜂。但是我们如何解决这个问题呢？</p><p id="fcea" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">相反，我们还需要深入复制<code class="eh lf lg lh li b">interests</code>对象，就像这样:</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="7c8a" class="lr kj hu li b fv ls lt l lu lv">const updated = Object.assign({}, person, { <br/>  location: 'Moon', <br/>  interests: <strong class="li hv">Object.assign({},</strong> person.interests, { <br/>    coffee: 10 // All other interests are copied <br/>  }) <br/>});</span></pre><p id="c19c" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">注意双<code class="eh lf lg lh li b">Object.assign</code>。实际上有点冗长，因为为了不丢失属性，所有对象都需要被赋值。</p><h1 id="90d9" class="ki kj hu bd kk kl km kn ko kp kq kr ks ja kt jb ku jd kv je kw jg kx jh ky kz dt translated">扩展运算符</h1><p id="4962" class="pw-post-body-paragraph jk jl hu jm b jn la iv jp jq lb iy js jt lc jv jw jx ld jz ka kb le kd ke kf hn dt translated">我们可以通过使用<code class="eh lf lg lh li b">spread</code>操作符让这个看起来更整洁，它采用<code class="eh lf lg lh li b">...</code>的形式——事实上，前面的例子可以改写为:</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="0c0e" class="lr kj hu li b fv ls lt l lu lv">const updated = { <br/>  ...person, <br/>  interests: { <br/>    <strong class="li hv">...person.interests,</strong> <br/>    coffee: 10, <br/>  } <br/>}</span></pre><p id="6f23" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">好看多了！Spread操作符是如此的不可思议，你绝对应该在MDN 上阅读更多关于它们的内容。</p><h1 id="3c30" class="ki kj hu bd kk kl km kn ko kp kq kr ks ja kt jb ku jd kv je kw jg kx jh ky kz dt translated">删除属性</h1><p id="72a0" class="pw-post-body-paragraph jk jl hu jm b jn la iv jp jq lb iy js jt lc jv jw jx ld jz ka kb le kd ke kf hn dt translated">现在，从对象中删除属性。关键字<code class="eh lf lg lh li b">delete</code>是一个变异动作，所以当我们考虑不可变数据时不能使用它。</p><p id="5549" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">有几种不同的方法可以解决这个问题，有些方法比其他方法更有效。一种(缓慢的)方法是重新创建我们的整个对象，但是忽略我们想要移除的属性。让我们创建一个函数，它接受我们的对象，以及我们希望删除的属性的名称:</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="6260" class="lr kj hu li b fv ls lt l lu lv">const removeProperty = (obj, property) =&gt; { <br/>  return Object.keys(obj).reduce((acc, key) =&gt; { <br/>    if (<strong class="li hv">key !== property</strong>) { <br/>      return {<strong class="li hv">...acc, [key]: obj[key]}</strong> } <br/>    return acc; <br/>  }, {}) <br/>}</span></pre><p id="6772" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated"><em class="kh">注意:为了便于阅读，本文采用了长格式。您可以省略一些return语句。</em></p><p id="cc04" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">这看起来有点复杂，但是发生的事情非常简单:对于每个不是我们传递的键，我们不断将它们添加到累加器中，由函数返回。所以现在，如果我们想要从我们的<code class="eh lf lg lh li b">person</code>对象中移除<code class="eh lf lg lh li b">interests</code>属性，我们可以这样使用:</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="83a3" class="lr kj hu li b fv ls lt l lu lv">const updated = removeProperty(person, 'interests');</span></pre><p id="4ff1" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">这将为我们提供对象的全新副本，除了一个被忽略的属性:</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="dc55" class="lr kj hu li b fv ls lt l lu lv">{ name: 'Ricardo', location: 'Berlin', }</span></pre><h1 id="4fdb" class="ki kj hu bd kk kl km kn ko kp kq kr ks ja kt jb ku jd kv je kw jg kx jh ky kz dt translated">旁白:使用lodash</h1><p id="3154" class="pw-post-body-paragraph jk jl hu jm b jn la iv jp jq lb iy js jt lc jv jw jx ld jz ka kb le kd ke kf hn dt translated">如果你在你的项目中使用了<strong class="jm hv"> lodash </strong>，那么你可以利用它的一些方法来帮助你改变对象。<strong class="jm hv">然而，你应该注意到，缺省情况下，lodash的一些方法改变了原始对象</strong>，这通常会弄乱你的不可变数据。然而，一个例外是<a class="ae kg" href="https://lodash.com/docs/4.17.4#omit" rel="noopener ugc nofollow" target="_blank"/><code class="eh lf lg lh li b"><a class="ae kg" href="https://lodash.com/docs/4.17.4#omit" rel="noopener ugc nofollow" target="_blank">_.omit</a></code><a class="ae kg" href="https://lodash.com/docs/4.17.4#omit" rel="noopener ugc nofollow" target="_blank">方法</a>，它可以用来从对象中删除属性。</p><p id="b23d" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">再一次，让我们像以前一样尝试删除<code class="eh lf lg lh li b">interests</code>属性，但是使用lodash。这一次，我们将把它写成一个reducer风格的函数，只是作为一个例子:</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="22a6" class="lr kj hu li b fv ls lt l lu lv">import { omit } from lodash; </span><span id="2540" class="lr kj hu li b fv lw lt l lu lv">const reducer = (state, action) =&gt; { <br/>  switch (action.type) { <br/>    case 'DELETE_KEY': <br/>    return omit(state, action.key); <br/>    default: <br/>    return state; <br/>  } <br/>}</span></pre><p id="40f0" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">这将工作，即使没有lodash的<em class="kh"> /fp </em>子集。所以如果你已经在用lodash，你会免费得到这个。我们可以这样使用它:</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="d6f3" class="lr kj hu li b fv ls lt l lu lv">const newState = reducer(person, { <br/>  type: 'DELETE_KEY', <br/>  key: 'interests' <br/>});</span></pre><p id="b93a" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">那会给我们同样的结果。再次，在重新分配数据时厌倦使用一些lodash方法，因为 <strong class="jm hv"> <em class="kh">他们的大多数方法都是对原对象</em> </strong> <em class="kh">的变异。考虑使用</em><a class="ae kg" href="https://github.com/lodash/lodash/wiki/FP-Guide" rel="noopener ugc nofollow" target="_blank"><em class="kh">/FP</em></a><em class="kh">子集变异。</em></p><h1 id="c58d" class="ki kj hu bd kk kl km kn ko kp kq kr ks ja kt jb ku jd kv je kw jg kx jh ky kz dt translated">更复杂的更新</h1><p id="ac64" class="pw-post-body-paragraph jk jl hu jm b jn la iv jp jq lb iy js jt lc jv jw jx ld jz ka kb le kd ke kf hn dt translated">很难理解如何混合和匹配对象的这些操作。重组属性，同时更新它们，是Redux reducers非常常用的模式。为了练习，让我们看一个更复杂的操作的例子。</p><p id="4d01" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">考虑我们的原始数据，一组有名字和ID的用户:</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="1dc8" class="lr kj hu li b fv ls lt l lu lv">const users = [ <br/>  {name: 'john', id: 176}, <br/>  {name: 'gary', id: 288}, <br/>  {name: 'louise', id: 213} <br/>];</span></pre><p id="4d9b" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">在<strong class="jm hv"> Redux </strong>中，通常的做法是<a class="ae kg" href="http://redux.js.org/docs/recipes/reducers/NormalizingStateShape.html" rel="noopener ugc nofollow" target="_blank">规范化你的应用程序状态</a>，通过将数据按ID分组以便于查找。假设这就是我们想要做的:我们想要一个新的<strong class="jm hv">数组</strong>，它包含按ID 分组的用户<strong class="jm hv">。为了好玩，让我们也把他们名字的第一个字母大写。</strong></p><p id="0518" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">简而言之，我们想从第一张表转到第二张表:</p><figure class="lj lk ll lm fq ly fe ff paragraph-image"><div class="fe ff lx"><img src="../Images/b523328cb85b19aa03585792de320091.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*_to6hfoGEtWDRra4.png"/></div></figure><p id="c6ff" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">但是，我们如何将<code class="eh lf lg lh li b">object.id</code>作为一个键返回呢？这是您将看到<code class="eh lf lg lh li b">[item.id]: something</code>符号的地方。它允许您动态地获取值，并将其用作键。所以记住这一点，让我们写我们的<code class="eh lf lg lh li b">byId</code>函数，它也大写第一个字母:</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="a079" class="lr kj hu li b fv ls lt l lu lv">const byId = (state) =&gt; state.reduce((acc, item) =&gt; ({ <br/>  ...acc, <br/>  <strong class="li hv">[item.id]</strong>: Object.assign({}, item, { <br/>    name: <em class="kh">item.name.charAt(0).toUpperCase() + item.name.slice(1) </em><br/>   }) <br/>}), {})</span></pre><p id="68bc" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">如果这个方法会说话，它会说:</p><p id="a213" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated"><em class="kh">嘿，你:对于我的状态，应用</em> <code class="eh lf lg lh li b"><em class="kh">reduce</em></code> <em class="kh">方法，这将给你一个以空{}开始的累加器，以及我的所有项目。对于每一个，扩展累积的属性，但是添加一个具有每个[item.id]的值的新键。在每一个里面，复制一个</em> <code class="eh lf lg lh li b"><em class="kh">item</em></code> <em class="kh">，同时修改它的</em> <code class="eh lf lg lh li b"><em class="kh">name</em></code> <em class="kh">属性。</em></p><p id="ba4f" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">这将<strong class="jm hv">返回一个新的对象，将每个用户的ID作为键</strong>，将他们的所有值分散到每个对象中，并将他们的<code class="eh lf lg lh li b">name</code>属性修改为第一个字符大写。</p><p id="ca32" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">如果我们想更新更多的属性，而不仅仅是用户名，该怎么办？在这里，您将考虑组合<strong class="jm hv">纯函数</strong>，以便根据需要操作数据，但总是返回一个新的副本。让我们稍微重构一下，创建一个<code class="eh lf lg lh li b">updateUser</code>函数:</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="9415" class="lr kj hu li b fv ls lt l lu lv">const <strong class="li hv">updateUser</strong> = (user) =&gt; Object.assign({}, user, { <br/>  name: user.name.charAt(0).toUpperCase() + user.name.slice(1) <br/>}); </span><span id="067c" class="lr kj hu li b fv lw lt l lu lv">const byId = (state) =&gt; state.reduce((acc, item) =&gt; ({ <br/>  ...acc, <br/>  [item.id]: <strong class="li hv">updateUser</strong>(item), <br/>}), {})</span></pre><p id="aa9c" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">我们现在需要获得一个新的状态，将用户按ID分组，只需:</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="cf20" class="lr kj hu li b fv ls lt l lu lv">const usersById = byId(users);</span></pre><h1 id="ae75" class="ki kj hu bd kk kl km kn ko kp kq kr ks ja kt jb ku jd kv je kw jg kx jh ky kz dt translated">数组</h1><p id="8884" class="pw-post-body-paragraph jk jl hu jm b jn la iv jp jq lb iy js jt lc jv jw jx ld jz ka kb le kd ke kf hn dt translated">酷，那么数组中的不变性呢？让我们考虑一个原始的不可变数据:</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="65a9" class="lr kj hu li b fv ls lt l lu lv">const original = ['a', 'c', 'd', 'e'];</span></pre><p id="b757" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">有了数组，您通常会希望执行以下操作之一:</p><ul class=""><li id="a0db" class="mb mc hu jm b jn jo jq jr jt md jx me kb mf kf mg mh mi mj dt translated">按索引插入项目</li><li id="7fc9" class="mb mc hu jm b jn mk jq ml jt mm jx mn kb mo kf mg mh mi mj dt translated">按索引删除项目</li><li id="bef0" class="mb mc hu jm b jn mk jq ml jt mm jx mn kb mo kf mg mh mi mj dt translated">按项目删除</li><li id="a26e" class="mb mc hu jm b jn mk jq ml jt mm jx mn kb mo kf mg mh mi mj dt translated">在末尾插入一个项目</li></ul><h1 id="ef42" class="ki kj hu bd kk kl km kn ko kp kq kr ks ja kt jb ku jd kv je kw jg kx jh ky kz dt translated">按索引插入</h1><p id="f3e2" class="pw-post-body-paragraph jk jl hu jm b jn la iv jp jq lb iy js jt lc jv jw jx ld jz ka kb le kd ke kf hn dt translated">我们很方便地忘记了在索引中的<code class="eh lf lg lh li b">a</code>值旁边添加<code class="eh lf lg lh li b">b</code>。哦，不，这对我们的alphabet应用程序是一个巨大的灾难！我们如何以不可变的方式在给定的索引处插入一个条目？一种思考方式是:</p><ol class=""><li id="dcf2" class="mb mc hu jm b jn jo jq jr jt md jx me kb mf kf mp mh mi mj dt translated"><em class="kh">复制数组</em> <strong class="jm hv"> <em class="kh">直到</em> </strong> <em class="kh">指定的索引</em></li><li id="e31c" class="mb mc hu jm b jn mk jq ml jt mm jx mn kb mo kf mp mh mi mj dt translated">插入我们的项目</li><li id="55cb" class="mb mc hu jm b jn mk jq ml jt mm jx mn kb mo kf mp mh mi mj dt translated"><em class="kh">将数组</em> <strong class="jm hv"> <em class="kh">的剩余部分从</em> </strong> <em class="kh">复制到指定的索引</em></li></ol><p id="75ac" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">所以我们可以用下面的签名写一个助手函数:</p><p id="d395" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated"><code class="eh lf lg lh li b">insertByIndex = (state, newItem, insertAt)</code></p><blockquote class="mq mr ms"><p id="5589" class="jk jl kh jm b jn jo iv jp jq jr iy js mt ju jv jw mu jy jz ka mv kc kd ke kf hn dt translated"><em class="hu">其中</em> <code class="eh lf lg lh li b"><em class="hu">state</em></code> <em class="hu">是原始数组，</em> <code class="eh lf lg lh li b"><em class="hu">newItem</em></code> <em class="hu">是我们要添加的项的值，</em> <code class="eh lf lg lh li b"><em class="hu">insertAt</em></code> <em class="hu">是我们要插入</em> <code class="eh lf lg lh li b"><em class="hu">newItem</em></code> <em class="hu">的位置的数字(索引)。</em></p></blockquote><p id="51f2" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">编写这样一个助手函数的简单方法如下:</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="63b0" class="lr kj hu li b fv ls lt l lu lv">const insertByIndex = (state, <strong class="li hv">newItem</strong>, insertAt) =&gt; [  <br/>  ...state.slice(0, insertAt), <br/>  <strong class="li hv">newItem</strong>, <br/>  ...state.slice(insertAt) <br/>]</span></pre><p id="c272" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">等等，什么？</p><p id="d1cb" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">好吧，我们来分析一下。我们已经看到了<code class="eh lf lg lh li b">spread</code>操作符(...)复制值，这正是我们在这里所做的。首先，我们返回一个新的数组；从头开始复制它，直到我们的索引，插入我们的新值(<code class="eh lf lg lh li b">b</code>)，然后从那里复制数组的其余部分。</p><p id="f886" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">因此，它的用法示例如下:</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="ebd3" class="lr kj hu li b fv ls lt l lu lv">insertByIndex(original, 'b', 1) <br/>// ["a", "b", "c", "d", "e"]</span></pre><h1 id="e3ea" class="ki kj hu bd kk kl km kn ko kp kq kr ks ja kt jb ku jd kv je kw jg kx jh ky kz dt translated">按索引删除</h1><p id="d554" class="pw-post-body-paragraph jk jl hu jm b jn la iv jp jq lb iy js jt lc jv jw jx ld jz ka kb le kd ke kf hn dt translated">幸运的是，通过索引移除数组要简单得多，只要我们能够使用<code class="eh lf lg lh li b">Array.filter</code>。让我们想想:<code class="eh lf lg lh li b">filter</code>方法给了我们索引值作为第二个参数，这意味着我们想要返回<em class="kh">所有没有N </em>索引的值。</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="95d4" class="lr kj hu li b fv ls lt l lu lv">const removeByIndex = (arr, at) =&gt; arr.filter((item, idx) =&gt; <strong class="li hv">idx !== at</strong>);</span></pre><h1 id="eea6" class="ki kj hu bd kk kl km kn ko kp kq kr ks ja kt jb ku jd kv je kw jg kx jh ky kz dt translated">按项目移除</h1><p id="1fc6" class="pw-post-body-paragraph jk jl hu jm b jn la iv jp jq lb iy js jt lc jv jw jx ld jz ka kb le kd ke kf hn dt translated">如果您想直接删除一个项目(比如说，<code class="eh lf lg lh li b">b</code>，而不是它的索引)，我们仍然可以像以前一样使用<code class="eh lf lg lh li b">filter</code>，但是我们将过滤掉项目本身，并忽略索引:</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="1b94" class="lr kj hu li b fv ls lt l lu lv">const removeByItem = (arr, value) =&gt; arr.filter((item) =&gt; <strong class="li hv">item !== value</strong>);</span></pre><h1 id="e1d8" class="ki kj hu bd kk kl km kn ko kp kq kr ks ja kt jb ku jd kv je kw jg kx jh ky kz dt translated">添加项目</h1><p id="6abc" class="pw-post-body-paragraph jk jl hu jm b jn la iv jp jq lb iy js jt lc jv jw jx ld jz ka kb le kd ke kf hn dt translated">在数组末尾加一个项也挺简单的，但是<strong class="jm hv">你敢想push！</strong>其实，老好人<code class="eh lf lg lh li b">concat()</code>才是你不变的朋友。使用<code class="eh lf lg lh li b">.push</code>会改变原始数组，这将不可避免地导致不可预测的行为。</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="8ead" class="lr kj hu li b fv ls lt l lu lv">const addItem = (arr, value) =&gt; arr.<strong class="li hv">concat</strong>(value);</span></pre><p id="4ebd" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">因此，如果我们想将<code class="eh lf lg lh li b">banana</code>添加到我们的字母数组中(为什么不呢？)，我们可以做:</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="dbee" class="lr kj hu li b fv ls lt l lu lv">addItem(original, 'banana') // ["a", "c", "d", "e", "banana"]</span></pre><h1 id="b442" class="ki kj hu bd kk kl km kn ko kp kq kr ks ja kt jb ku jd kv je kw jg kx jh ky kz dt translated">引人深思的事</h1><p id="48e8" class="pw-post-body-paragraph jk jl hu jm b jn la iv jp jq lb iy js jt lc jv jw jx ld jz ka kb le kd ke kf hn dt translated">即使您使用的是不可变库，如Immutable.js或lodash 的<a class="ae kg" href="https://github.com/lodash/lodash/wiki/FP-Guide" rel="noopener ugc nofollow" target="_blank"> fp风格，很好地掌握不变性如何与简单的</a><a class="ae kg" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>一起工作仍然是一个很好的主意。不可变的. js作为一个依赖项有很大的权重，还有其他的选择，比如同样流行的<a class="ae kg" href="https://github.com/debitoor/dot-prop-immutable" rel="noopener ugc nofollow" target="_blank">点-prop-不可变的</a>。</p><p id="0229" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">什么时候应该使用库实现不变性，或者使用JavaScript？这实际上取决于您的数据变更的复杂性，您可以为您的代码库和您的团队带来的开销(这是<em class="kh">需要学习的另一件事</em>)。我认为了解大多数模式的准系统实现是有益的，尤其是在使用Redux或任何其他类似的在代码不变性方面很流行的模式时。</p><p id="7603" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated"><strong class="jm hv">非常有用的资源:</strong></p><ul class=""><li id="7559" class="mb mc hu jm b jn jo jq jr jt md jx me kb mf kf mg mh mi mj dt translated"><a class="ae kg" href="https://www.sitepoint.com/immutability-javascript/" rel="noopener ugc nofollow" target="_blank">immutable . js简介</a></li><li id="c68d" class="mb mc hu jm b jn mk jq ml jt mm jx mn kb mo kf mg mh mi mj dt translated"><a class="ae kg" href="http://redux.js.org/docs/recipes/reducers/ImmutableUpdatePatterns.html" rel="noopener ugc nofollow" target="_blank">还原不可变模式</a></li><li id="35f7" class="mb mc hu jm b jn mk jq ml jt mm jx mn kb mo kf mg mh mi mj dt translated"><a class="ae kg" href="https://wecodetheweb.com/2016/02/12/immutable-javascript-using-es6-and-beyond/" rel="noopener ugc nofollow" target="_blank">更多ES2015示例</a></li><li id="05b7" class="mb mc hu jm b jn mk jq ml jt mm jx mn kb mo kf mg mh mi mj dt translated"><a class="ae kg" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator" rel="noopener ugc nofollow" target="_blank">传播语法:MDN </a></li></ul><p id="d794" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">有什么我可能忽略或弄错的吗？不要害怕在推特上联系我。</p></div><div class="ab cl mw mx hc my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="hn ho hp hq hr"><p id="8f81" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated"><em class="kh">原载于我的个人博客</em><a class="ae kg" href="http://blog.ricardofilipe.com/post/immutable-changes-in-js" rel="noopener ugc nofollow" target="_blank"><em class="kh">blog.ricardofilipe.com</em></a></p><figure class="lj lk ll lm fq ly"><div class="bz el l di"><div class="nd ne l"/></div></figure></div></div>    
</body>
</html>