<html>
<head>
<title>Troubleshooting and avoiding deadlocks — MySQL/Rails</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">故障排除和避免死锁— MySQL/Rails</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/troubleshooting-and-avoiding-deadlocks-mysql-rails-766913f3cfbc?source=collection_archive---------4-----------------------#2017-06-10">https://medium.com/hackernoon/troubleshooting-and-avoiding-deadlocks-mysql-rails-766913f3cfbc?source=collection_archive---------4-----------------------#2017-06-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="970f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最近我有一个有趣的问题要解决。刚从大学毕业，在现实世界中第一次看到学到的东西，有点令人兴奋。</p><p id="f06a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">问题是，在我们的电子商务Rails应用程序中，偶尔会有订单和一些API请求失败。从异常处理中我们发现这是由<a class="ae jp" href="https://hackernoon.com/tagged/mysql" rel="noopener ugc nofollow" target="_blank"> MySQL </a>错误引起的。</p><blockquote class="jq jr js"><p id="718d" class="ir is jt it b iu iv iw ix iy iz ja jb ju jd je jf jv jh ji jj jw jl jm jn jo hn dt translated">"试图获取锁时发现死锁；尝试重新启动交易"</p><p id="cba7" class="ir is jt it b iu iv iw ix iy iz ja jb ju jd je jf jv jh ji jj jw jl jm jn jo hn dt translated">“超过锁定等待超时；尝试重新启动交易"</p></blockquote><p id="27d1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这很糟糕，因为作为企业不可或缺的一部分，某些东西不应该失败。所以我的首要任务是找出原因。从日志中，我能够回溯到失败的代码行，并且还发现上面的两个错误都是针对同一行代码的。</p><h2 id="6ebc" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">那么到底什么是死锁呢？</h2><p id="31e1" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">假设有两个事务需要获得一些锁，以便提交事务。</p><blockquote class="jq jr js"><p id="9f34" class="ir is jt it b iu iv iw ix iy iz ja jb ju jd je jf jv jh ji jj jw jl jm jn jo hn dt translated">事务A:锁定行X，并等待锁定行y。</p><p id="00d7" class="ir is jt it b iu iv iw ix iy iz ja jb ju jd je jf jv jh ji jj jw jl jm jn jo hn dt translated">事务B:锁定行Y，并等待锁定行x。</p></blockquote><p id="a2b6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是这两个事务持有另一个事务需要起作用的行的锁，因此造成了两个事务都停止起作用的情况。</p><p id="cca7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这种情况下，MySQL会使一个或两个事务超时，并释放锁。</p></div><div class="ab cl kx ky hc kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hn ho hp hq hr"><p id="c9f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是Rails的问题是你有ORM，事务封装的回调，我经常忘记它必须维护的SQL，底层数据库协议和ACID属性。这都是Rails的魔力。</p><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="lj lk l"/></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">To the muggle world now!</figcaption></figure><p id="77c6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在可以推断出三件事:</p><ol class=""><li id="40a2" class="lp lq hu it b iu iv iy iz jc lr jg ls jk lt jo lu lv lw lx dt translated">失败代码行所需的锁与其他事务所需的锁顺序相反，因此会导致死锁。</li><li id="a658" class="lp lq hu it b iu ly iy lz jc ma jg mb jk mc jo lu lv lw lx dt translated">有一些繁重的事务可能会锁定表而不是行，这样订单就会由于超时而失败。</li><li id="0453" class="lp lq hu it b iu ly iy lz jc ma jg mb jk mc jo lu lv lw lx dt translated">因为它是失败的同一行代码，所以当死锁没有发生时会发生超时错误。</li></ol><p id="1401" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以下一步是找出另一个导致超时和死锁的锁定行的事务。</p><h1 id="5e72" class="md jy hu bd jz me mf mg kd mh mi mj kh mk ml mm kk mn mo mp kn mq mr ms kq mt dt translated">死锁故障排除:</h1><p id="1cca" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">在MySQL控制台中执行查询:</p><pre class="le lf lg lh fq mu mv mw mx aw my dt"><span id="b079" class="jx jy hu mv b fv mz na l nb nc">SHOW ENGINE INNODB STATUS;</span></pre><p id="09fc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这为您提供了InnoDB存储引擎的状态。它有不同的信息部分，您可以在其中找到有关最新检测到的死锁的信息。你可以在这里阅读更多关于这个<a class="ae jp" href="https://dev.mysql.com/doc/refman/5.5/en/innodb-standard-monitor.html" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><p id="81a6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是死锁部分的示例:</p><pre class="le lf lg lh fq mu mv mw mx aw my dt"><span id="7d9d" class="jx jy hu mv b fv mz na l nb nc">------------------------<br/>LATEST DETECTED DEADLOCK<br/>------------------------<br/>141016 15:39:58<br/>*** (1) TRANSACTION:<br/>TRANSACTION 3D009, ACTIVE 19 sec starting index read<br/>mysql tables in use 1, locked 1<br/>LOCK WAIT 2 lock struct(s), heap size 376, 1 row lock(s)<br/>MySQL thread id 2, OS thread handle 0x7f0ee43cd700, query id 78 localhost root<br/>updating<br/>DELETE FROM t WHERE i = 1<br/>*** (1) WAITING FOR THIS LOCK TO BE GRANTED:<br/>RECORD LOCKS space id 0 page no 2428 n bits 72 index `GEN_CLUST_INDEX` of table<br/>`mysql`.`t` trx id 3D009 lock_mode X waiting<br/>Record lock, heap no 2 PHYSICAL RECORD: n_fields 4; compact format; info bits 0<br/> 0: len 6; hex 000000000700; asc       ;;<br/> 1: len 6; hex 00000003d007; asc       ;;<br/> 2: len 7; hex 87000009560110; asc     V  ;;<br/> 3: len 4; hex 80000001; asc     ;;</span><span id="fed8" class="jx jy hu mv b fv nd na l nb nc">*** (2) TRANSACTION:<br/>TRANSACTION 3D008, ACTIVE 69 sec starting index read<br/>mysql tables in use 1, locked 1<br/>4 lock struct(s), heap size 1248, 3 row lock(s)<br/>MySQL thread id 1, OS thread handle 0x7f0ee440e700, query id 79 localhost root<br/>updating<br/>DELETE FROM t WHERE i = 1<br/>*** (2) HOLDS THE LOCK(S):<br/>RECORD LOCKS space id 0 page no 2428 n bits 72 index `GEN_CLUST_INDEX` of table<br/>`mysql`.`t` trx id 3D008 lock mode S<br/>Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0<br/> 0: len 8; hex 73757072656d756d; asc supremum;;</span><span id="998b" class="jx jy hu mv b fv nd na l nb nc">Record lock, heap no 2 PHYSICAL RECORD: n_fields 4; compact format; info bits 0<br/> 0: len 6; hex 000000000700; asc       ;;<br/> 1: len 6; hex 00000003d007; asc       ;;<br/> 2: len 7; hex 87000009560110; asc     V  ;;<br/> 3: len 4; hex 80000001; asc     ;;</span><span id="f0d0" class="jx jy hu mv b fv nd na l nb nc">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:<br/>RECORD LOCKS space id 0 page no 2428 n bits 72 index `GEN_CLUST_INDEX` of table<br/>`mysql`.`t` trx id 3D008 lock_mode X waiting<br/>Record lock, heap no 2 PHYSICAL RECORD: n_fields 4; compact format; info bits 0<br/> 0: len 6; hex 000000000700; asc       ;;<br/> 1: len 6; hex 00000003d007; asc       ;;<br/> 2: len 7; hex 87000009560110; asc     V  ;;<br/> 3: len 4; hex 80000001; asc     ;;</span><span id="1cf6" class="jx jy hu mv b fv nd na l nb nc">*** WE ROLL BACK TRANSACTION (1)</span></pre><p id="a72d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我承认，看到这一大堆信息，我有些不知所措。但是，如果你眯着眼睛看，一切都变得有意义了。在这个部分中，您可以了解哪些事务导致了死锁，持有和等待的锁的类型。</p><p id="9bd8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以从这些信息中推断出:</p><ol class=""><li id="cc2d" class="lp lq hu it b iu iv iy iz jc lr jg ls jk lt jo lu lv lw lx dt translated"><strong class="it hv">涉及的交易</strong>:从交易段可以看出<code class="eh ne nf ng mv b"><a class="ae jp" href="https://dev.mysql.com/doc/refman/5.5/en/innodb-locking.html#innodb-record-locks" rel="noopener ugc nofollow" target="_blank"><em class="jt">RECORD LOCKS</em></a> SPACE id 0</code><em class="jt"/><em class="jt"/>的锁定索引，更重要的是<code class="eh ne nf ng mv b">WAITING FOR THIS LOCK TO BE GRANTED</code><em class="jt"/><em class="jt"/><code class="eh ne nf ng mv b"><em class="jt">HOLDS THE LOCKS(S)</em></code><em class="jt">的交易查询。</em></li><li id="7d22" class="lp lq hu it b iu ly iy lz jc ma jg mb jk mc jo lu lv lw lx dt translated"><strong class="it hv">所涉及的锁模式</strong>:在<em class="jt">上方可以看到<code class="eh ne nf ng mv b">lock mode S</code>和<code class="eh ne nf ng mv b">lock mode X </code>。</em>你有必要了解锁是如何工作的，这样你就知道为什么会发生死锁。</li></ol><ul class=""><li id="9395" class="lp lq hu it b iu iv iy iz jc lr jg ls jk lt jo nh lv lw lx dt translated"><a class="ae jp" href="https://dev.mysql.com/doc/refman/5.5/en/glossary.html#glos_exclusive_lock" rel="noopener ugc nofollow" target="_blank">排他锁(X) </a>:一种<strong class="it hv"> <em class="jt">锁</em> </strong>，防止任何其他<strong class="it hv"> <em class="jt">事务</em> </strong>锁定同一行。</li><li id="cbac" class="lp lq hu it b iu ly iy lz jc ma jg mb jk mc jo nh lv lw lx dt translated"><a class="ae jp" href="https://dev.mysql.com/doc/refman/5.5/en/glossary.html#glos_shared_lock" rel="noopener ugc nofollow" target="_blank">共享锁</a>:一种<strong class="it hv"> <em class="jt">锁</em> </strong>，允许其他<strong class="it hv"> <em class="jt">事务</em> </strong>读取锁定的对象，也可以获取其上的其他共享锁，但不能写入。</li></ul><p id="8f52" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">瞧啊。现在您知道是哪些事务导致了问题。</p><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="ni lk l"/></div></figure><h2 id="d15d" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">避免死锁:</h2><p id="e2d7" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">web应用程序是一个相当复杂的硬件、软件和网络系统。可以有多个用户同时请求web应用程序。您的应用程序必须以一种能够处理并发数据访问的方式进行编码。如果操作不当，可能会导致超时和死锁。</p><p id="3c70" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，App server可以有多个进程，这样您的主机就可以同时为多个请求运行Ruby代码。因此，处理并发的两个主要工具是事务和锁。</p><p id="481f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请记住以下几点以避免死锁</p><ol class=""><li id="9301" class="lp lq hu it b iu iv iy iz jc lr jg ls jk lt jo lu lv lw lx dt translated">事务必须很短—尽可能在最短的时间内锁定更少的行。</li></ol><p id="5b00" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2 .关心您使用的ActiveRecord回调。</p><p id="87cf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于长时间运行的代码，使用<code class="eh ne nf ng mv b">after_commit</code>。例如:</p><pre class="le lf lg lh fq mu mv mw mx aw my dt"><span id="3fa6" class="jx jy hu mv b fv mz na l nb nc">class SailBoat<br/>  has_many :passengers<br/>  after_create :get_passenger_list<br/>  def get_passenger_list<br/>    # associating all passengers<br/>  end<br/>end</span></pre><p id="756d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在回调在很长一段时间内打开一个事务块并进行关联。这很糟糕，因为这会锁定行并导致死锁。</p><p id="3aa0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">3.确保公共工作流总是以相同的顺序获得锁定。</p><p id="67e0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">4.使用队列来防止并发数据访问。</p><p id="462c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">5.检查您的应用用例是否需要何种模式的<a class="ae jp" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html" rel="noopener ugc nofollow" target="_blank">隔离级别</a>。默认情况下，INNODB使用<code class="eh ne nf ng mv b">REPEATABLE READ</code>。</p><h2 id="1b3a" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">解决问题</h2><p id="b41c" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">持有锁的事务来自应用程序的外部服务。多亏了Unicorn，这些请求同时发生，增加了超时/死锁的可能性。为什么？因为这些是繁重的事务性请求，有时会远远超出默认的50秒锁等待时间，或者会获取锁来制造死锁。</p><p id="b967" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从<code class="eh ne nf ng mv b">INNODB STATUS</code>中，我能够找出<code class="eh ne nf ng mv b">HOLDS THE LOCK(S)</code>的查询，它来自API请求调用的存储过程。订单流和存储过程中的锁获取是相反的。把它们做成同样的顺序是很大的改变。但是在存储过程中引入了一个新的<code class="eh ne nf ng mv b">TEMPORARY TABLE</code>,这样，通过一个索引临时表来连接它，而不是直接连接两个索引表，解决了问题的再次出现。</p><p id="c39a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于已经失败的死锁/超时API请求，我简单地实现了一个带有重试块的队列，并将它们推给它。</p></div><div class="ab cl kx ky hc kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hn ho hp hq hr"><p id="c162" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">咻，我想我已经做完了！这是一条相当长的学习曲线，理解数据库如何在每个查询保持真实属性的情况下忙碌是非常酷的。如果有任何错误，请随时纠正我，或者在评论中分享你的想法。</p><p id="a8e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">祝你愉快。长码繁荣！</p><div class="le lf lg lh fq ab cb"><figure class="nj li nk nl nm nn no paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nj li nk nl nm nn no paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nj li nk nl nm nn no paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="jq jr js"><p id="f922" class="ir is jt it b iu iv iw ix iy iz ja jb ju jd je jf jv jh ji jj jw jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is jt it b iu iv iw ix iy iz ja jb ju jd je jf jv jh ji jj jw jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="le lf lg lh fq li fe ff paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="fe ff nr"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="nw lk l"/></div></figure></div></div>    
</body>
</html>