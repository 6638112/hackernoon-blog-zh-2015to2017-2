<html>
<head>
<title>Making Ruby’s Array.include? faster for symbols</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">制作Ruby的Array.include？符号速度更快</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/making-rubys-array-include-faster-for-symbols-827a988ec26b?source=collection_archive---------18-----------------------#2017-03-21">https://medium.com/hackernoon/making-rubys-array-include-faster-for-symbols-827a988ec26b?source=collection_archive---------18-----------------------#2017-03-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="2c34" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这一切都开始做一些重构——我在玩<code class="eh jp jq jr js b">Array</code>和<code class="eh jp jq jr js b">Set</code>,一些东西诱使我去做一个简单的基准测试，结果显示出奇怪的结果。这是我描述如何修复它的第二部分。这是关于构建Ruby的代码，用<code class="eh jp jq jr js b">lldb</code>调试它，让它更快！</p><p id="c8ba" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这一切都始于<a class="ae jt" href="https://github.com/pawelniewie/benchmark-set-array-contains/blob/master/ruby/array_include.rb" rel="noopener ugc nofollow" target="_blank">标杆</a> <code class="eh jp jq jr js b"><a class="ae jt" href="https://github.com/pawelniewie/benchmark-set-array-contains/blob/master/ruby/array_include.rb" rel="noopener ugc nofollow" target="_blank">Array.include?()</a></code></p><pre class="ju jv jw jx fq jy js jz ka aw kb dt"><span id="3583" class="kc kd hu js b fv ke kf l kg kh">Comparison:<br/>               array:  1332567.6 i/s<br/>       array symbols:  1154135.9 i/s - 1.15x  slower</span></pre><p id="ad4a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">符号数组比字符串数组慢，这难道不奇怪吗？符号应该是很快的！</p><p id="6679" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我下载了<a class="ae jt" href="https://github.com/ruby/ruby" rel="noopener ugc nofollow" target="_blank"> Ruby的源代码</a>开始看。</p><p id="7a7f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我最初认为问题出在Symbol的<code class="eh jp jq jr js b">==</code>上，所以我去寻找它。我在<code class="eh jp jq jr js b">string.c</code>很容易地找到了一个字符串</p><pre class="ju jv jw jx fq jy js jz ka aw kb dt"><span id="0d15" class="kc kd hu js b fv ke kf l kg kh">rb_define_method(rb_cString, "==", rb_str_equal, 1);</span></pre><p id="530b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是<code class="eh jp jq jr js b">symbol.c</code>没有遵循模式，因为它也在<code class="eh jp jq jr js b">string.c</code> :-)</p><pre class="ju jv jw jx fq jy js jz ka aw kb dt"><span id="8e32" class="kc kd hu js b fv ke kf l kg kh">rb_define_method(rb_cSymbol, "==", sym_equal, 1);</span></pre><p id="44db" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">确定数组在哪里也很简单，这很容易:</p><pre class="ju jv jw jx fq jy js jz ka aw kb dt"><span id="f0f5" class="kc kd hu js b fv ke kf l kg kh">rb_define_method(rb_cArray, "include?", rb_ary_includes, 1);</span></pre></div><div class="ab cl ki kj hc kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hn ho hp hq hr"><pre class="jy js jz ka aw kb dt"><span id="81ed" class="kc kd hu js b fv kp kq kr ks kt kf l kg kh">VALUE<br/>rb_ary_includes(VALUE ary, VALUE item)<br/>{<br/>    long i;<br/>    VALUE e;<br/><br/>    for (i=0; i&lt;RARRAY_LEN(ary); i++) {<br/>    e = RARRAY_AREF(ary, i);<br/>    switch (rb_equal_opt(e, item)) {<br/>      case Qundef:<br/>        if (rb_equal(e, item)) return Qtrue;<br/>        break;<br/>      case Qtrue:<br/>        return Qtrue;<br/>    }<br/>    }<br/>    return Qfalse;<br/>}</span></pre><p id="d770" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这让我想到了<code class="eh jp jq jr js b">vm_insnhelper.c</code> <code class="eh jp jq jr js b">rb_equal_opt</code>然后又想到了<code class="eh jp jq jr js b">opt_eq_func</code>，感觉有些不对劲:</p><pre class="ju jv jw jx fq jy js jz ka aw kb dt"><span id="540f" class="kc kd hu js b fv ke kf l kg kh">static<br/>#ifndef NO_BIG_INLINE<br/>inline<br/>#endif<br/>VALUE<br/>opt_eq_func(VALUE recv, VALUE obj, CALL_INFO ci, CALL_CACHE cc)<br/>{<br/>#define BUILTIN_CLASS_P(x, k) (!SPECIAL_CONST_P(x) &amp;&amp; RBASIC_CLASS(x) == k)<br/>#define EQ_UNREDEFINED_P(t) BASIC_OP_UNREDEFINED_P(BOP_EQ, t##_REDEFINED_OP_FLAG)<br/>    if (FIXNUM_2_P(recv, obj)) {<br/>    if (EQ_UNREDEFINED_P(INTEGER)) {<br/>        return (recv == obj) ? Qtrue : Qfalse;<br/>    }<br/>    }<br/>    else if (FLONUM_2_P(recv, obj)) {<br/>    if (EQ_UNREDEFINED_P(FLOAT)) {<br/>        return (recv == obj) ? Qtrue : Qfalse;<br/>    }<br/>    }<br/>    else if (BUILTIN_CLASS_P(recv, rb_cFloat)) {<br/>    if (EQ_UNREDEFINED_P(FLOAT)) {<br/>        return rb_float_equal(recv, obj);<br/>    }<br/>    }<br/>    else if (BUILTIN_CLASS_P(recv, rb_cString)) {<br/>    if (EQ_UNREDEFINED_P(STRING)) {<br/>        return rb_str_equal(recv, obj);<br/>    }<br/>    }<br/>#undef EQ_UNREDEFINED_P<br/>#undef BUILTIN_CLASS_P<br/><br/>    {<br/>    vm_search_method(ci, cc, recv);<br/><br/>    if (check_cfunc(cc-&gt;me, rb_obj_equal)) {<br/>        return recv == obj ? Qtrue : Qfalse;<br/>    }<br/>    }<br/><br/>    return Qundef;<br/>}</span></pre><p id="e592" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我本想说我讨厌那样的格式，但结果是因为他们在文件中混合了空格和制表符。咄！</p><p id="17d0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">看看代码，很明显——符号没有特例。我想我有点期待Ruby已经优化了用c编写的方法。现在是时候弄清楚如何编写缺失的方法了。</p><p id="49f1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，一些设置。运行一次以准备制作文件(Mac OS X):</p><pre class="ju jv jw jx fq jy js jz ka aw kb dt"><span id="97c4" class="kc kd hu js b fv ke kf l kg kh">autoconf <br/>CFLAGS="-O0 -ggdb" ./configure --prefix=/usr/local/opt/rbenv/versions/2.5.0 --with-openssl-dir="$(brew --prefix openssl)" --disable-install-doc</span></pre><p id="09f8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后进行编译:</p><pre class="ju jv jw jx fq jy js jz ka aw kb dt"><span id="e769" class="kc kd hu js b fv ke kf l kg kh">make &amp;&amp; make check &amp;&amp; make install</span></pre><p id="81d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Ruby C API指南是理解代码中发生的事情的一个很好的起点。最重要的教训——你不能<code class="eh jp jq jr js b">printf</code> a <code class="eh jp jq jr js b">VALUE</code>，有<code class="eh jp jq jr js b">rb_p</code>为那。</p><p id="83fe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你也可以用<code class="eh jp jq jr js b">lldb</code>调试东西，这很简单(虽然不是<code class="eh jp jq jr js b">gdb</code>，所以<a class="ae jt" href="https://lldb.llvm.org/tutorial.html" rel="noopener ugc nofollow" target="_blank">命令与</a>不同):</p><p id="33f0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jp jq jr js b">lldb /usr/local/opt/rbenv/versions/2.5.0/bin/ruby -- -e "if [:test, :another].include?(:test); puts 'A'; end"</code></p><pre class="ju jv jw jx fq jy js jz ka aw kb dt"><span id="83a4" class="kc kd hu js b fv ke kf l kg kh">breakpoint set --file vm_insnhelper.c --line 1279 <br/>process launch <br/>process continue</span></pre><p id="57e0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然，我是如此渴望，以至于在最终搜索到Ruby C API指南之前，我尝试了许多东西:-D我认为它很容易理解，并且我可以处理C代码，因为它回到了过去。</p><p id="7a98" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我阅读指南时，很明显我必须使用<code class="eh jp jq jr js b">SYMBOL_P</code>:</p><pre class="ju jv jw jx fq jy js jz ka aw kb dt"><span id="e938" class="kc kd hu js b fv ke kf l kg kh">diff --git a/vm_insnhelper.c b/vm_insnhelper.c<br/>index a991e59..476b5e2 100644<br/>--- a/vm_insnhelper.c<br/>+++ b/vm_insnhelper.c<br/>@@ -1296,6 +1296,11 @@ opt_eq_func(VALUE recv, VALUE obj, CALL_INFO ci, CALL_CACHE cc)<br/>        return rb_str_equal(recv, obj);<br/>    }<br/>     }<br/>+    else if (SYMBOL_P(recv) &amp;&amp; SYMBOL_P(obj)) {<br/>+        if (EQ_UNREDEFINED_P(SYMBOL)) {<br/>+       return rb_obj_equal(recv, obj);<br/>+   }<br/>+    }<br/> #undef EQ_UNREDEFINED_P<br/> #undef BUILTIN_CLASS_P</span></pre><p id="4683" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在再次运行基准测试:</p><pre class="ju jv jw jx fq jy js jz ka aw kb dt"><span id="b30a" class="kc kd hu js b fv ke kf l kg kh">Comparison:<br/>       array symbols:  1630417.3 i/s<br/>               array:  1372269.7 i/s - 1.19x  slower</span></pre><p id="8721" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">符号现在更快了！从一开始就应该这样。</p><p id="e772" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如你所见，浏览C代码很容易。此外，如果您在基准测试中发现一些问题，这可能只是代码中的一个简单错误。你需要记住Ruby有两层——Ruby代码和C代码。如果你的Ruby代码看起来不错，那可能是有问题的C代码。</p><p id="9e61" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">创建了<a class="ae jt" href="https://github.com/ruby/ruby/pull/1540" rel="noopener ugc nofollow" target="_blank">公关并修复了</a>。</p><blockquote class="kv"><p id="d006" class="kw kx hu bd ky kz la lb lc ld le jo ek translated">像这样？请点击下面的♥，以便其他人可以找到它！</p></blockquote></div><div class="ab cl ki kj hc kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hn ho hp hq hr"><p id="f507" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="ku">原载于2017年3月21日</em><a class="ae jt" href="https://pawelniewiadomski.com/2017/03/21/making-ruby-array-include-faster/" rel="noopener ugc nofollow" target="_blank"><em class="ku">pawelniewiadomski.com</em></a><em class="ku">。</em></p></div></div>    
</body>
</html>