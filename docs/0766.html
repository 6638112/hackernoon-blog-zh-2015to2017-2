<html>
<head>
<title>The Node.js System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js系统</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-node-js-system-51090c35dddc?source=collection_archive---------0-----------------------#2016-04-22">https://medium.com/hackernoon/the-node-js-system-51090c35dddc?source=collection_archive---------0-----------------------#2016-04-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/f01732c7c456dd1d675587d410e28598.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aeWo6e6FC8InJwBl3TmpDw.jpeg"/></div></div></figure><p id="e8f8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">刚开始学<a class="ae ka" href="http://www.nodejs.org" rel="noopener ugc nofollow" target="_blank"> Node.js </a>的时候，我一直在想，它是怎么工作的？在Node.js里面怎么样？<em class="kb">事件循环和事件队列</em>术语被消化。但是到底是怎么回事呢？那些术语<em class="kb">事件循环和事件队列</em>从何而来。为了满足我的好奇心，也为了知道我之前的问题的答案，我尽可能地深入研究，发现了一些事情，我想与你分享。简而言之，本文是关于<strong class="je hv"> Node.js系统</strong>——Node内部工作的一瞥。</p><p id="8633" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您熟悉Node.js，那么Node.js是单线程的是一个众所周知的事实。如果你有编程/计算机科学背景，你会知道线程意味着什么。考虑这个场景:传统上，一个I/O请求到达一个web服务器，并被分配给一个可用的线程，对于每个并发连接，都有一个可用的线程。该请求在特定线程上处理，直到完成并发送响应。</p><p id="5f63" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个场景是<strong class="je hv">阻塞I/O </strong>的一个很好的例子，因为当一个特定的线程处理一个特定的请求时，当操作正在进行时<em class="kb">会有一些空闲时间(比如检索一个文件，打开它，读取它，等等。).</em>单线程消耗内存。在Node.js的<a class="ae ka" rel="noopener" href="/@amanhimself/the-node-way-philosophy-of-a-platform-f9738ed5f9d2#.w77h292q9">世界中，为每个连接运行一个更长的线程，然后闲置一段时间被认为不是一种有效的方式</a></p><h2 id="6fc4" class="kc kd hu bd ke kf kg kh ki kj kk kl km jn kn ko kp jr kq kr ks jv kt ku kv kw dt translated">输入反应器模式Node.js的中心</h2><p id="c3c5" class="pw-post-body-paragraph jc jd hu je b jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv lb jx jy jz hn dt translated"><strong class="je hv">反应器模式</strong>是Node.js中非阻塞I/O操作的一种思想，该模式提供了一个处理程序<em class="kb">(对于Node.js，是一个</em> <strong class="je hv"> <em class="kb">回调函数</em> </strong> <em class="kb"> ) </em>，与每个I/O操作相关联。当产生一个I/O请求时，它被提交给一个<em class="kb">解复用器</em>。</p><p id="ad8c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个<em class="kb">解复用器</em>是一个通知接口，用于在<em class="kb">非阻塞I/O </em>模式<em class="kb"> </em>下处理并发，并以事件的形式收集每个请求，并将每个事件排列在一个队列中。于是，解复用器提供了我们经常听到的<strong class="je hv">事件队列</strong>。当解复用器收集到一个请求时，它会将控制返回给系统，并且不会阻塞I/O。同时，还有一个<strong class="je hv">事件循环</strong>，它会遍历事件队列中的项目。每个事件都有一个与之关联的回调函数，当事件循环迭代时，该回调函数被调用。</p><p id="a36c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">回调函数通常还包含其他回调函数，用于表示一些异步操作。这些操作由解复用器插入到事件队列中，一旦事件循环遍历它们，就可以处理这些操作。这就是为什么对其他操作的调用必须是异步的。</p><p id="56fa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当处理完事件队列中的所有项目，并且没有未完成的操作时，Node.js会自动终止应用程序。</p><h1 id="d954" class="lc kd hu bd ke ld le lf ki lg lh li km lj lk ll kp lm ln lo ks lp lq lr kv ls dt translated">Node.js的构建块</h1><ul class=""><li id="43a8" class="lt lu hu je b jf kx jj ky jn lv jr lw jv lx jz ly lz ma mb dt translated">反应器模式</li><li id="c6ec" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">libuv</li><li id="7728" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">一套装订</li><li id="d0a5" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">Chrome的V8</li><li id="47aa" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">核心JS库</li></ul><h2 id="db4b" class="kc kd hu bd ke kf kg kh ki kj kk kl km jn kn ko kp jr kq kr ks jv kt ku kv kw dt translated"><a class="ae ka" href="http://docs.libuv.org/en/v1.x/" rel="noopener ugc nofollow" target="_blank"> <em class="mh"> libuv </em> </a></h2><p id="6732" class="pw-post-body-paragraph jc jd hu je b jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv lb jx jy jz hn dt translated">发音为“lib u v”，是用C语言编写的库，使Node.js与每个操作系统兼容，并提供非阻塞I/O行为。<a class="ae ka" href="http://docs.libuv.org/en/v1.x/" rel="noopener ugc nofollow" target="_blank"> <em class="kb"> libuv </em> </a> <em class="kb"> </em>是实现<em class="kb">反应器模式</em>的低级引擎，从而提供用于创建事件循环、管理事件队列和运行异步I/O操作的API。它是专为在不同操作系统上提供统一体验而构建的。</p><h2 id="f066" class="kc kd hu bd ke kf kg kh ki kj kk kl km jn kn ko kp jr kq kr ks jv kt ku kv kw dt translated">需要libuv？</h2><p id="41f4" class="pw-post-body-paragraph jc jd hu je b jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv lb jx jy jz hn dt translated">每个操作系统都有自己的解复用器接口。比如Mac OS X的<a class="ae ka" href="https://en.wikipedia.org/wiki/Kqueue" rel="noopener ugc nofollow" target="_blank"> Kqueue </a>，Windows的<a class="ae ka" href="https://en.wikipedia.org/wiki/Input/output_completion_port" rel="noopener ugc nofollow" target="_blank"> IOCP </a>，Linux的<a class="ae ka" href="https://en.wikipedia.org/wiki/Epoll" rel="noopener ugc nofollow" target="_blank"> Epoll </a>。不同的多路复用器在处理I/O请求时会有不同的表现。然后，在同一个操作系统中，每个I/O操作的行为会有所不同。这就产生了不一致性，为了克服这种不一致性<em class="kb"> libuv </em>是解决方案。</p><p id="7e53" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我不打算在这里谈论libuv的内部工作方式，我自己也不是这方面的专家。要了解更多关于libuv  <a class="ae ka" href="http://docs.libuv.org/" rel="noopener ugc nofollow" target="_blank"> <em class="kb">的信息，请查看他们的文档</em> </a> <em class="kb">或</em> <a class="ae ka" href="http://www.slideshare.net/saghul/libuv-nodejs-and-everything-in-between" rel="noopener ugc nofollow" target="_blank"> <em class="kb">这张幻灯片</em> </a> <em class="kb">由</em><strong class="je hv"><em class="kb">Saul Ibarra corretgé</em></strong><em class="kb">(</em><a class="ae ka" href="https://twitter.com/saghul" rel="noopener ugc nofollow" target="_blank"><em class="kb">@ sag hul</em></a><em class="kb">)是一个好的开始。</em></p><p id="9a5d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://github.com/libuv/libuv" rel="noopener ugc nofollow" target="_blank"> <em class="kb">还有，libuv是由牛逼开发者独立维护的。</em>T49】</a></p><h2 id="f24b" class="kc kd hu bd ke kf kg kh ki kj kk kl km jn kn ko kp jr kq kr ks jv kt ku kv kw dt translated">绑定集</h2><p id="7d7a" class="pw-post-body-paragraph jc jd hu je b jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv lb jx jy jz hn dt translated">这些绑定集负责包装并向JavaScript公开<em class="kb"> libuv </em>和其他底层功能。</p><h2 id="8e79" class="kc kd hu bd ke kf kg kh ki kj kk kl km jn kn ko kp jr kq kr ks jv kt ku kv kw dt translated">V8</h2><p id="1df6" class="pw-post-body-paragraph jc jd hu je b jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv lb jx jy jz hn dt translated">这是谷歌为Chrome浏览器开发的一个运行时引擎<a class="ae ka" href="https://developers.google.com/v8/" rel="noopener ugc nofollow" target="_blank">。这就是Node.js快速高效的原因。</a></p><h2 id="656f" class="kc kd hu bd ke kf kg kh ki kj kk kl km jn kn ko kp jr kq kr ks jv kt ku kv kw dt translated">核心库</h2><p id="8471" class="pw-post-body-paragraph jc jd hu je b jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv lb jx jy jz hn dt translated">这是一个JavaScript库，实现了高级Node.js API ( <em class="kb">又名node-core </em>)。</p><figure class="mj mk ml mm fq iv fe ff paragraph-image"><div class="fe ff mi"><img src="../Images/5da9d3a9c0836c5913023be4e5185462.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*dTYKv5fII4doUAqJSA51Qg.png"/></div><figcaption class="mn mo fg fe ff mp mq bd b be z ek">More accurate image of Event Loop inside Node.js</figcaption></figure></div><div class="ab cl mr ms hc mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="hn ho hp hq hr"><p id="944a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面借用的图片阐明并表示了一个完整的Node.js系统。我希望这篇文章让事情变得更清楚，就像它对我一样。</p><p id="69ea" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">想要收到更多像这样的文章吗？订阅我 <a class="ae ka" href="https://patreon.us17.list-manage.com/subscribe?u=ad4c168a6d5bb975f2f282d54&amp;id=39e959cecd" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">这里</strong> </a> <strong class="je hv">。有时，我会向我的订户发送“从未见过”的内容。</strong></p></div></div>    
</body>
</html>