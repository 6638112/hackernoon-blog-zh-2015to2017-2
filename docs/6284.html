<html>
<head>
<title>Deep Learning and Deep Types: Tensor Flow and Dependent Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深度学习和深度类型:张量流和依赖类型</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/deep-learning-and-deep-types-tensor-flow-and-dependent-types-7b3ddf10c5a3?source=collection_archive---------15-----------------------#2017-09-11">https://medium.com/hackernoon/deep-learning-and-deep-types-tensor-flow-and-dependent-types-7b3ddf10c5a3?source=collection_archive---------15-----------------------#2017-09-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="aa25" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本系列的<a class="ae jp" href="https://mmhaskell.com/blog/2017/8/7/the-future-is-functional-haskell-and-the-ai-native-world" rel="noopener ugc nofollow" target="_blank">介绍中，我提出的一个要点是Haskell是一种安全的语言。我们将在编译时而不是运行时捕捉许多错误。运行时错误通常对系统来说是灾难性的，因此能够减少这些错误是至关重要的。在对自动驾驶汽车或无人机进行编程时尤其如此。这些物体将出现在现实世界中，如果它们发生故障，可能会伤害到人。</a></p><p id="3ce2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，让我们回顾一下我们在过去3或4周内编写的一些代码。它真的更安全吗？我们会发现答案是，嗯，没那么多。很难验证代码的某些属性。但是Haskell中确实存在使代码更安全的工具！在接下来的两篇文章中，我们将对依赖类型进行一些严肃的分析。我们将能够在编译时证明人工智能程序的一些困难的特性！</p><p id="7a33" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来的三篇文章将关注依赖类型编程。这是一个很难的主题，所以如果您不能完全理解所有的代码示例，也不用担心。让我们的机器学习代码更安全的主要想法才是重要的！所以，事不宜迟，让我们从头开始，看看运行时问题会出现在哪里。</p><p id="370a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你想自己玩这个代码，查看我的Github库上的<a class="ae jp" href="https://github.com/jhb563/HTensor/tree/dependent-shapes" rel="noopener ugc nofollow" target="_blank">依赖形状分支</a>！本文所有代码在<a class="ae jp" href="https://github.com/jhb563/HTensor/blob/dependent-shapes/src/DepShape.hs" rel="noopener ugc nofollow" target="_blank"> DepShape.hs </a>中。虽然如果你想让代码运行，你可能还需要让Haskell张量流工作。下载我们的<a class="ae jp" href="https://www.mmhaskell.com/tensorflow" rel="noopener ugc nofollow" target="_blank"> Haskell张量流指南</a>获取相关说明！</p><h1 id="19e6" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">Python的问题</h1><p id="e9b8" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">Python作为一种解释型语言，肯定会有运行时错误。当我第一次学习张量流的时候，我碰到了很多这种很常见的东西。对我来说最突出的两个是占位符故障和尺寸不匹配。例如，让我们回想一下第一个例子。我们的代码将有几个占位符，我们在运行会话时会提交这些占位符的值:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="14df" class="lc jr hu ky b fv ld le l lf lg">node1 = tf.placeholder(tf.float32)<br/>node2 = tf.placeholder(tf.float32)<br/>adderNode = tf.add(node1, node2)<br/>sess = tf.Session()<br/>result1 = sess.run(adderNode, {node1: 3, node2: 4.5 })</span></pre><p id="532a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是没有什么可以阻止我们在不提交值的情况下运行会话。这将导致运行时崩溃:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="844c" class="lc jr hu ky b fv ld le l lf lg">...<br/>sess = tf.Session()<br/>result1 = sess.run(adderNode)<br/>print(result1)<br/>…</span><span id="0fd7" class="lc jr hu ky b fv lh le l lf lg">Terminal Output:</span><span id="ba79" class="lc jr hu ky b fv lh le l lf lg">InvalidArgumentError (see above for traceback): You must feed a value for placeholder tensor 'Placeholder' with dtype float<br/>   [[Node: Placeholder = Placeholder[dtype=DT_FLOAT, shape=[], _device="/job:localhost/replica:0/task:0/cpu:0"]()]]</span></pre><p id="9cb7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一个不时出现的问题是尺寸不匹配。某些运算需要张量维数之间的某种关系。例如，不能将两个不同长度的向量相加:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="d8db" class="lc jr hu ky b fv ld le l lf lg">node1 = tf.constant([3.0, 4.0, 5.0], dtype=tf.float32)<br/>node2 = tf.constant([4.0, 16.0], dtype=tf.float32)<br/>additionNode = tf.add(node1, node2)</span><span id="4b75" class="lc jr hu ky b fv lh le l lf lg">sess = tf.Session()<br/>result = sess.run(additionNode)<br/>print(result)</span><span id="58d1" class="lc jr hu ky b fv lh le l lf lg">…</span><span id="0326" class="lc jr hu ky b fv lh le l lf lg">Terminal Output:</span><span id="54d3" class="lc jr hu ky b fv lh le l lf lg">ValueError: Dimensions must be equal, but are 3 and 2 for 'Add' (op: 'Add') with input shapes: [3], [2].</span></pre><p id="4238" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样，我们会遇到运行时崩溃。这些似乎是我们可以在编译时解决的问题。</p><h1 id="6b14" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">Haskell解决了这些问题吗？</h1><p id="2ad9" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">但是任何一个仔细阅读我到目前为止所写的Haskell代码的人都会发现它并没有解决这些问题！下面回顾一下我们的基本占位符示例:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="8b3b" class="lc jr hu ky b fv ld le l lf lg">runPlaceholder :: Vector Float -&gt; Vector Float -&gt; IO (Vector Float)<br/>runPlaceholder input1 input2 = runSession $ do<br/>  (node1 :: Tensor Value Float) &lt;- placeholder [1]<br/>  (node2 :: Tensor Value Float) &lt;- placeholder [1]<br/>  let adderNode = node1 `add` node2<br/>  let runStep = \node1Feed node2Feed -&gt; runWithFeeds <br/>        [ feed node1 node1Feed<br/>        , feed node2 node2Feed<br/>        ] <br/>        adderNode<br/>  runStep (encodeTensorData [1] input1) (encodeTensorData [1] input2)</span></pre><p id="8a3e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意<code class="eh li lj lk ky b">runWithFeeds</code>函数是如何获取一系列<code class="eh li lj lk ky b">Feed</code>对象的。如果我们提供空列表，代码仍然可以很好地编译。那么它将面临和我们的Python代码一样的命运:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="cdb5" class="lc jr hu ky b fv ld le l lf lg">…<br/>let runStep = \node1Feed node2Feed -&gt; runWithFeeds [] adderNode<br/>…</span><span id="f415" class="lc jr hu ky b fv lh le l lf lg">Terminal Output:</span><span id="b4bc" class="lc jr hu ky b fv lh le l lf lg">TensorFlowException TF_INVALID_ARGUMENT "You must feed a value for placeholder tensor 'Placeholder_1' with dtype float and shape [1]\n\t [[Node: Placeholder_1 = Placeholder[dtype=DT_FLOAT, shape=[1], _device=\"/job:localhost/replica:0/task:0/cpu:0\"]()]]"</span></pre><p id="37f6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于维数的第二个例子，我们也可以在Haskell中犯这个错误。以下代码编译后将在运行时崩溃:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="f854" class="lc jr hu ky b fv ld le l lf lg">runSimple :: IO (Vector Float)<br/>runSimple = runSession $ do<br/>  let node1 = constant [3] [3 :: Float, 4, 5]<br/>  let node2 = constant [2] [4 :: Float, 5]<br/>  let additionNode = node1 `add` node2<br/>  run additionNode<br/>…</span><span id="4b46" class="lc jr hu ky b fv lh le l lf lg">Terminal Output:<br/>TensorFlowException TF_INVALID_ARGUMENT "Incompatible shapes: [3] vs. [2]\n\t [[Node: Add_2 = Add[T=DT_FLOAT, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](Const_0, Const_1)]]"</span></pre><p id="718e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在更基本的层面上，我们甚至不需要说出矢量形状的真相！我们可以给一个假的shape值，它仍然可以编译！</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="6aa3" class="lc jr hu ky b fv ld le l lf lg">let node1 = constant [3, 2, 3] [3 :: Float, 4, 5]<br/>…</span><span id="5692" class="lc jr hu ky b fv lh le l lf lg">Terminal Output:<br/>invalid tensor length: expected 18 got 3<br/>CallStack (from HasCallStack):<br/>  error, called at src/TensorFlow/Ops.hs:299:23 in tensorflow-ops-0.1.0.0-EWsy8DQdciaL8o6yb2fUKR:TensorFlow.Ops</span></pre><h1 id="86da" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">我们能做得更好吗？</h1><p id="ac72" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">现在，我们做了一些正确的事情。让我们回想一下我们制造神经网络时的<code class="eh li lj lk ky b">Model</code>类型。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="c70d" class="lc jr hu ky b fv ld le l lf lg">data Model = Model<br/>  { train :: TensorData Float<br/>          -&gt; TensorData Int64<br/>          -&gt; Session ()<br/>  , errorRate :: TensorData Float<br/>              -&gt; TensorData Int64<br/>              -&gt; SummaryTensor<br/>              -&gt; Session (Float, ByteString)<br/>  }</span></pre><p id="13e4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将我们的训练步骤公开为一个函数。这个函数强迫用户为占位符提供两个张量。这很好，但是不能保护我们免受尺寸问题的影响。</p><p id="c2a5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当试图解决这些问题时，我们可以围绕每个操作编写包装器。像<code class="eh li lj lk ky b">add</code>和<code class="eh li lj lk ky b">matMul</code>这样的函数可以返回<code class="eh li lj lk ky b">Maybe</code>值。但这将是笨重的。我们可以在Python中采取同样的步骤。当然，单子允许Haskell版本更好地组合。但是如果我们能提前一次检查我们的错误，那就更好了。</p><p id="c0f1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们愿意深入挖掘，我们可以解决这些问题！在这篇文章的剩余部分，我们将探索使用依赖类型来确保维度总是正确的。然而，获得正确的占位符要稍微复杂一些！所以我们将把它留到下周的文章中。</p><h1 id="f024" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">检查尺寸</h1><p id="7fb7" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">目前，我们处理的张量类型在维度上没有类型安全。张量流在与C库交互时不提供这些信息。所以不可能在低层次强制执行。但是这并不妨碍我们编写包装器来解决这个问题。</p><p id="600f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要编写这些包装器，我们需要深入研究依赖类型。我将对正在发生的事情进行高度概括。但是对于一些基础的细节，你应该看看这个教程。我也要对<a class="ae jp" href="https://github.com/k0001" rel="noopener ugc nofollow" target="_blank">伦佐·卡博纳拉</a>、<a class="ae jp" href="https://hackage.haskell.org/package/exinst" rel="noopener ugc nofollow" target="_blank">exist库</a>和其他伟大的Haskell作品的作者表示感谢。他帮助我跨越了实现依赖类型的两大知识鸿沟。</p><h1 id="d89e" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">从属类型介绍:大小向量</h1><p id="00cf" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">引入依赖类型的最简单的例子是大小向量的概念。如果你读了上面的教程，你会看到它们是如何从头开始实现的。一个正常的向量有一个单一的类型参数，指的是向量包含什么类型的项目。有大小的向量有一个额外的类型参数，这个类型指的是向量的大小。例如，以下是有效的大小向量类型:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="878b" class="lc jr hu ky b fv ld le l lf lg">import Data.Vector.Sized (Vector, fromList)</span><span id="083b" class="lc jr hu ky b fv lh le l lf lg">vectorWith2 :: Vector 2 Int64<br/>...<br/>vectorWith6 :: Vector 6 Float<br/>...</span></pre><p id="1aa9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在第一类签名中，<code class="eh li lj lk ky b">2</code>不指术语2。指的是<em class="ll">型</em> 2。也就是说，我们已经取得了这个术语，并且<em class="ll">将它提升</em>为只有一个值的类型。这种工作机制令人困惑，但结果是这样的。我们可以尝试将法向量转换成大小向量。但是如果我们的尺寸不匹配，手术就会失败。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="8da6" class="lc jr hu ky b fv ld le l lf lg">import Data.Vector.Sized (Vector, fromList)<br/>import GHC.TypeLits (KnownNat)</span><span id="82af" class="lc jr hu ky b fv lh le l lf lg">-- fromList :: (KnownNat n) =&gt; [a] -&gt; Maybe (Vector n a)</span><span id="25f2" class="lc jr hu ky b fv lh le l lf lg">-- This results in a “Just” value!<br/>success :: Maybe (Vector 2 Int64)<br/>success = fromList [5,6]</span><span id="2627" class="lc jr hu ky b fv lh le l lf lg">-- The sizes don’t match, so we’ll get “Nothing”!<br/>failure :: Maybe (Vector 2 Int64)<br/>failure = fromList [3,1,5]</span></pre><p id="f72c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh li lj lk ky b">KnownNat</code>约束允许我们指定类型<code class="eh li lj lk ky b">n</code>引用一个自然数。所以现在我们可以分配一个封装列表大小的类型签名。</p><h1 id="ddec" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">“安全”形状类型</h1><p id="64b7" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">现在我们对依赖类型有了一个非常基本的了解，让我们为张量流想出一个游戏计划。第一步是创建一个新的类型，将形状放入类型签名中。我们将制作一个<code class="eh li lj lk ky b">SafeShape</code>类型，模拟大小向量类型。它将存储维度的完整列表，而不是存储单个数字作为类型。我们想创建一个类似这样的API:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="f2d0" class="lc jr hu ky b fv ld le l lf lg">-- fromShape :: Shape -&gt; Maybe (SafeShape s)</span><span id="8305" class="lc jr hu ky b fv lh le l lf lg">-- Results in a “Just” value<br/>goodShape :: Maybe (SafeShape ‘[2, 2])<br/>goodShape = fromShape (Shape [2,2])</span><span id="a9fc" class="lc jr hu ky b fv lh le l lf lg">-- Results in Nothing<br/>badShape :: Maybe (SafeShape ‘[2,2])<br/>badShape = fromShape (Shape [3,3,2])</span></pre><p id="1655" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为此，我们首先定义<code class="eh li lj lk ky b">SafeShape</code>类型。这遵循了大小向量的例子。参见下面的<strong class="it hv">附录</strong>了解本文中使用的编译器扩展和导入。特别是，您需要GADTs和数据类型。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="7047" class="lc jr hu ky b fv ld le l lf lg">data SafeShape (s :: [Nat]) where<br/>  NilShape :: SafeShape '[]<br/>  (:--) :: KnownNat m =&gt; Proxy m -&gt; SafeShape s -&gt; SafeShape (m ': s)</span><span id="45f5" class="lc jr hu ky b fv lh le l lf lg">infixr 5 :--</span></pre><p id="d2b5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们可以定义<code class="eh li lj lk ky b">toShape</code>函数了。这将使用代理把我们的<code class="eh li lj lk ky b">SafeShape</code>变成一个普通的<code class="eh li lj lk ky b">Shape</code>。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="2a09" class="lc jr hu ky b fv ld le l lf lg">toShape :: SafeShape s -&gt; Shape<br/>toShape NilShape = Shape []<br/>toShape ((pm :: Proxy m) :-- s) = Shape (fromInteger (natVal pm) : s')<br/>  where<br/>    (Shape s') = toShape s</span></pre><p id="6bcf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在对于反方向，我们首先要做一个类<code class="eh li lj lk ky b">MkSafeShape</code>。这个类封装了我们可以转换成<code class="eh li lj lk ky b">SafeShape</code>类型的所有类型。我们将为所有自然列表定义这个类的实例。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="ccd8" class="lc jr hu ky b fv ld le l lf lg">class MkSafeShape (s :: [Nat]) where<br/>  mkSafeShape :: SafeShape s<br/>instance MkSafeShape '[] where<br/>  mkSafeShape = NilShape<br/>instance (MkSafeShape s, KnownNat m) =&gt; MkSafeShape (m ': s) where<br/>  mkSafeShape = Proxy :-- mkSafeShape</span></pre><p id="bdef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们可以使用<code class="eh li lj lk ky b">MkSafeShape</code>类定义我们的<code class="eh li lj lk ky b">fromShape</code>函数。为了检查它是否有效，我们将比较结果形状和输入形状，确保它们相等。注意，这需要我们定义一个简单的<code class="eh li lj lk ky b">Eq Shape</code>实例。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="1a65" class="lc jr hu ky b fv ld le l lf lg">instance Eq Shape where<br/>  (==) (Shape s) (Shape r) = s == r</span><span id="fb53" class="lc jr hu ky b fv lh le l lf lg">fromShape :: forall s. MkSafeShape s =&gt; Shape -&gt; Maybe (SafeShape s)<br/>fromShape shape = if toShape myShape == shape<br/>  then Just myShape<br/>  else Nothing<br/>  where<br/>    myShape = mkSafeShape :: SafeShape s</span></pre><p id="8052" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">既然我们已经为shape做了这些，我们可以为<code class="eh li lj lk ky b">Tensor</code>创建一个类似的类型，将Shape存储为类型参数。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="2cc1" class="lc jr hu ky b fv ld le l lf lg">data SafeTensor v a (s :: [Nat]) where<br/>  SafeTensor :: (TensorType a) =&gt; Tensor v a -&gt; SafeTensor v a s</span></pre><h1 id="55ad" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">使用我们的安全类型</h1><p id="4751" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">那么这一切给我们带来了什么？我们的下一个目标是创建一个<code class="eh li lj lk ky b">safeConstant</code>函数。这将让我们创建一个<code class="eh li lj lk ky b">SafeTensor</code>包装一个常数张量并存储形状。请记住，<code class="eh li lj lk ky b">constant</code>接受一个形状和一个向量，但不确保它们之间的相关性。我们想要这样的东西:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="fcfc" class="lc jr hu ky b fv ld le l lf lg">safeConstant :: (TensorType a) =&gt; Vector n a -&gt; SafeShape s -&gt; SafeTensor Build a s<br/>safeConstant elems shp = SafeTensor $ constant (toShape shp) (toList elems)</span></pre><p id="8a0e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将给定的形状附加到张量上。但是少了一件。我们还想在输入元素的数量和形状之间建立联系。所以形状为<code class="eh li lj lk ky b">[3,3,2]</code>的东西应该强迫你输入一个长度为18的向量。现在，<code class="eh li lj lk ky b">n</code>和<code class="eh li lj lk ky b">s</code>之间没有约束。</p><p id="bd1d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将添加一个名为<code class="eh li lj lk ky b">ShapeProduct</code>的类型族。这些实例将说明给定自然列表的正确自然类型是它们的乘积。我们用递归定义第二个实例，所以我们需要<code class="eh li lj lk ky b">UndecidableInstances</code>。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="a6b1" class="lc jr hu ky b fv ld le l lf lg">type family ShapeProduct (s :: [Nat]) :: Nat<br/>type instance ShapeProduct '[] = 1<br/>type instance ShapeProduct (m ': s) = m * ShapeProduct s</span></pre><p id="f058" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们几乎完成了这一部分！我们可以通过在<code class="eh li lj lk ky b">s</code>和<code class="eh li lj lk ky b">n</code>之间的<code class="eh li lj lk ky b">ShapeProduct</code>上添加一个约束来修复我们的<code class="eh li lj lk ky b">safeConstant</code>函数。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="7aba" class="lc jr hu ky b fv ld le l lf lg">safeConstant :: (TensorType a, ShapeProduct s ~ n) =&gt; Vector n a -&gt; SafeShape s -&gt; SafeTensor Build a s<br/>safeConstant elems shp = SafeTensor $ constant (toShape shp) (toList elems)</span></pre><p id="d9b6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们可以写出<code class="eh li lj lk ky b">safeConstant</code>函数的简单用法，如下所示:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="bc55" class="lc jr hu ky b fv ld le l lf lg">main :: IO (VN.Vector Int64)<br/>main = runSession $ do<br/>  let (shape1 :: SafeShape '[2,2]) = fromJust $ fromShape (Shape [2,2])<br/>  let (elems1 :: Vector 4 Int64) = fromJust $ fromList [1,2,3,4]<br/>  let (constant1 :: SafeTensor Build Int64 '[2,2]) = safeConstant elems1 shape1<br/>  let (SafeTensor t) = constant1<br/>  run t</span></pre><p id="3dff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们在这里使用<code class="eh li lj lk ky b">fromJust</code>作为快捷方式。但是在一个真实的程序中，你会读入你的初始张量，并把它们作为<code class="eh li lj lk ky b">Maybe</code>值进行检查。运行时失败的可能性仍然存在。但是这个系统有几个优点。第一，不会死机。我们将有机会优雅地处理它。第二，我们预先做所有的错误检查。一旦我们为每件事情分配了类型，所有的失败案例都应该被包含了。</p><p id="7df3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">回到上一个例子，我们来改变一些东西。例如，我们可以让向量的长度为3，而不是4。我们现在会得到一个编译错误！</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="40ea" class="lc jr hu ky b fv ld le l lf lg">main :: IO (VN.Vector Int64)<br/>main = runSession $ do<br/>  let (shape1 :: SafeShape '[2,2]) = fromJust $ fromShape (Shape [2,2])<br/>  let (elems1 :: Vector 3 Int64) = fromJust $ fromList [1,2,3]<br/>  let (constant1 :: SafeTensor Build Int64 '[2,2]) = safeConstant elems1 shape1<br/>  let (SafeTensor t) = constant1<br/>  run t</span><span id="357c" class="lc jr hu ky b fv lh le l lf lg">…</span><span id="a853" class="lc jr hu ky b fv lh le l lf lg">    • Couldn't match type ‘4’ with ‘3’<br/>        arising from a use of ‘safeConstant’<br/>    • In the expression: safeConstant elems1 shape1<br/>      In a pattern binding:<br/>        (constant1 :: SafeTensor Build Int64 '[2, 2])<br/>          = safeConstant elems1 shape1</span></pre><h1 id="8db4" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">添加类型安全操作</h1><p id="16a1" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">现在我们已经将形状信息附加到张量上，我们可以定义更安全的数学运算了。很容易编写一个安全的加法函数，确保张量具有相同的形状:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="51ed" class="lc jr hu ky b fv ld le l lf lg">safeAdd :: (TensorType a, a /= Bool) =&gt; SafeTensor Build a s -&gt; SafeTensor Build a s -&gt; SafeTensor Build a s<br/>safeAdd (SafeTensor t1) (SafeTensor t2) = SafeTensor (t1 `add` t2)</span></pre><p id="dea6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里有一个类似的矩阵乘法函数。它确保我们有二维的形状和尺寸。注意这两个张量共享<code class="eh li lj lk ky b">n</code>维度。必须是第一个张量的列维度和第二个张量的行维度:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="788e" class="lc jr hu ky b fv ld le l lf lg">safeMatMul :: (TensorType a, a /= Bool, a /= Int8, a /= Int16, a /= Int64, a /= Word8, a /= ByteString)<br/>   =&gt; SafeTensor Build a '[i,n] -&gt; SafeTensor Build a '[n,o] -&gt; SafeTensor Build a '[i,o]<br/>safeMatMul (SafeTensor t1) (SafeTensor t2) = SafeTensor (t1 `matMul` t2)</span></pre><p id="3074" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是这些功能的实际应用:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="27fe" class="lc jr hu ky b fv ld le l lf lg">main2 :: IO (VN.Vector Float)<br/>main2 = runSession $ do<br/>  let (shape1 :: SafeShape '[4,3]) = fromJust $ fromShape (Shape [4,3])<br/>  let (shape2 :: SafeShape '[3,2]) = fromJust $ fromShape (Shape [3,2])<br/>  let (shape3 :: SafeShape '[4,2]) = fromJust $ fromShape (Shape [4,2])<br/>  let (elems1 :: Vector 12 Float) = fromJust $ fromList [1,2,3,4,1,2,3,4,1,2,3,4]<br/>  let (elems2 :: Vector 6 Float) = fromJust $ fromList [5,6,7,8,9,10]<br/>  let (elems3 :: Vector 8 Float) = fromJust $ fromList [11,12,13,14,15,16,17,18]<br/>  let (constant1 :: SafeTensor Build Float '[4,3]) = safeConstant elems1 shape1<br/>  let (constant2 :: SafeTensor Build Float '[3,2]) = safeConstant elems2 shape2<br/>  let (constant3 :: SafeTensor Build Float '[4,2]) = safeConstant elems3 shape3<br/>  let (multTensor :: SafeTensor Build Float '[4,2]) = constant1 `safeMatMul` constant2<br/>  let (addTensor :: SafeTensor Build Float '[4,2]) = multTensor `safeAdd` constant3<br/>  let (SafeTensor finalTensor) = addTensor<br/>  run finalTensor</span></pre><p id="840f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然，如果我们在任何地方使用了不正确的维度，我们都会得到编译错误。假设我们将<code class="eh li lj lk ky b">multTensor</code>改为使用<code class="eh li lj lk ky b">[4,3]</code>作为它的类型:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="9c9e" class="lc jr hu ky b fv ld le l lf lg">• Couldn't match type ‘2’ with ‘3’<br/>      Expected type: SafeTensor Build Float '[4, 3]<br/>        Actual type: SafeTensor Build Float '[4, 2]<br/>    • In the expression: constant1 `safeMatMul` constant2<br/>…<br/> • Couldn't match type ‘3’ with ‘2’<br/>      Expected type: SafeTensor Build Float '[4, 2]<br/>        Actual type: SafeTensor Build Float '[4, 3]<br/>    • In the expression: multTensor `safeAdd` constant3<br/>…<br/>• Couldn't match type ‘2’ with ‘3’<br/>      Expected type: SafeTensor Build Float '[4, 3]<br/>        Actual type: SafeTensor Build Float '[4, 2]<br/>    • In the second argument of ‘safeAdd’, namely ‘constant3’</span></pre><h1 id="1913" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">结论</h1><p id="ec0e" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在这个练习中，我们深入了解了Haskell中最难学习的主题之一。依赖型一开始会让你晕头转向。但是我们看到了一个具体的例子，说明它们如何允许我们在编译时检测有问题的代码。它们是一种文档形式，也使我们能够验证我们的代码在某些方面是正确的。</p><p id="8f69" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">类型不能代替测试(尤其是行为测试)。但是在这个例子中，至少有一些不同的测试用例，我们不需要太担心。下周，我们将看到如何应用这些原则来验证占位符。</p><p id="99f3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你想了解更多关于使用Haskell张量流的细节，你应该看看我们的<a class="ae jp" href="https://www.mmhaskell.com/tensorflow" rel="noopener ugc nofollow" target="_blank">张量流指南</a>。它将引导你完成向一个简单的堆栈项目添加张量流的基础知识。</p><p id="912c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也许你以前从未使用过Haskell，但我已经让你相信依赖类型是未来。如果你想尝试一下，下载我们的<a class="ae jp" href="https://www.mmhaskell.com/checklist" rel="noopener ugc nofollow" target="_blank">入门清单</a>。您还可以学习如何使用Stack创建和组织Haskell项目！查看我们的<a class="ae jp" href="http://academy.mondaymorninghaskell.com/p/your-first-haskell-project" rel="noopener ugc nofollow" target="_blank"> Stack迷你课程</a>！</p><h1 id="7618" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">附录:扩展和导入</h1><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="1559" class="lc jr hu ky b fv ld le l lf lg">{-# LANGUAGE GADTs                #-}<br/>{-# LANGUAGE DataKinds            #-}<br/>{-# LANGUAGE KindSignatures       #-}<br/>{-# LANGUAGE TypeOperators        #-}<br/>{-# LANGUAGE ScopedTypeVariables  #-}<br/>{-# LANGUAGE TypeFamilies         #-}<br/>{-# LANGUAGE UndecidableInstances #-}</span><span id="0f76" class="lc jr hu ky b fv lh le l lf lg">import           Data.ByteString (ByteString)<br/>import           Data.Constraint (Constraint)<br/>import           Data.Int (Int64, Int8, Int16)<br/>import           Data.Maybe (fromJust)<br/>import           Data.Proxy (Proxy(..))<br/>import qualified Data.Vector as VN<br/>import           Data.Vector.Sized (Vector(..), toList, fromList)<br/>import           Data.Word (Word8)<br/>import           GHC.TypeLits (Nat, KnownNat, natVal)<br/>import           GHC.TypeLits</span><span id="0ce4" class="lc jr hu ky b fv lh le l lf lg">import           TensorFlow.Core<br/>import           TensorFlow.Core (Shape(..), TensorType, Tensor, Build)<br/>import           TensorFlow.Ops (constant, add, matMul)<br/>import           TensorFlow.Session (runSession, run)</span></pre></div></div>    
</body>
</html>