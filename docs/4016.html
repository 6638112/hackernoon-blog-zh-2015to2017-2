<html>
<head>
<title>Compile JavaScript? Really?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编译JavaScript？真的吗？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/javascript-compilation-epoch-ebfb7b5bb664?source=collection_archive---------1-----------------------#2017-05-07">https://medium.com/hackernoon/javascript-compilation-epoch-ebfb7b5bb664?source=collection_archive---------1-----------------------#2017-05-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="9742" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">用于<a class="ae jp" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> Javascript </a>编译的WebAssembly、Emscripten和<a class="ae jp" href="https://hackernoon.com/tagged/tools" rel="noopener ugc nofollow" target="_blank">工具</a>。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/c761c1ec30178e83fc3bf04b87f820ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O8rX3BH7QpjDjbK7TWjylQ.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Slide from the “The Birth &amp; Death of JavaScript” by <a class="ae jp" href="https://www.destroyallsoftware.com/screencasts" rel="noopener ugc nofollow" target="_blank">Gary Bernhardt</a></figcaption></figure><h2 id="8c87" class="kg kh hu bd ki kj kk kl km kn ko kp kq jc kr ks kt jg ku kv kw jk kx ky kz la dt translated">我有两个消息告诉你:好消息和坏消息。</h2><p id="96ec" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated"><strong class="it hv">好消息—</strong><em class="lg">JavaScript编译的时代已经开始。</em> <strong class="it hv"> <br/>坏消息— </strong> <em class="lg">我们还没有为这个时代做好准备。</em></p></div><div class="ab cl lh li hc lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hn ho hp hq hr"><h1 id="05e1" class="lo kh hu bd ki lp lq lr km ls lt lu kq lv lw lx kt ly lz ma kw mb mc md kz me dt translated">真的吗？</h1><p id="0922" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">也许你已经看过<a class="ae jp" href="https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">这次大会的演讲</strong></a>(<a class="ae jp" href="https://www.destroyallsoftware.com/screencasts" rel="noopener ugc nofollow" target="_blank">加里·伯恩哈特</a>的《JavaScript的诞生&amp;死亡》)。</p><blockquote class="mf mg mh"><p id="75cf" class="ir is lg it b iu iv iw ix iy iz ja jb mi jd je jf mj jh ji jj mk jl jm jn jo hn dt translated">简而言之，这个演讲的中心思想是——浏览器将成为新的操作系统，JS将成为新的C语言，软件将移植到浏览器中。</p></blockquote><p id="f768" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">是的，这个时代已经在Chrome OS、<a class="ae jp" href="https://electron.atom.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">电子</strong> </a>、Emscripten、WebAssembly之后开始了。<em class="lg">为什么自电子？</em>因为电子app相当于作为桌面app工作的浏览器。在web将迁移到web之前，这是一个很好的第一步:<em class="lg">在所有桌面应用程序都可以在浏览器中工作之前，我们可以尝试在浏览器上运行单个桌面应用程序。</em></p><h2 id="6132" class="kg kh hu bd ki kj kk kl km kn ko kp kq jc kr ks kt jg ku kv kw jk kx ky kz la dt translated"><em class="ml">电子有什么问题？</em></h2><p id="297c" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">关于电子的主要问题很简单:<a class="ae jp" href="https://josephg.com/blog/electron-is-flash-for-the-desktop/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">电子是用于桌面的Flash(</strong>关于电子的伟大文章<strong class="it hv">)。</strong> </a></p><blockquote class="mf mg mh"><p id="c733" class="ir is lg it b iu iv iw ix iy iz ja jb mi jd je jf mj jh ji jj mk jl jm jn jo hn dt translated">例如，我在Mac上安装了Slack、Atom和其他3个用Electron开发的应用程序。相当于5个Chromium浏览器。</p></blockquote></div><div class="ab cl lh li hc lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hn ho hp hq hr"><h1 id="ad7d" class="lo kh hu bd ki lp lq lr km ls lt lu kq lv lw lx kt ly lz ma kw mb mc md kz me dt translated"><strong class="ak"> WebAssembly、Emscripten和LLVM </strong></h1><div class="mm mn fm fo mo mp"><a href="https://github.com/WebAssembly/design" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab ej"><div class="mr ab ms cl cj mt"><h2 class="bd hv fv z el mu eo ep mv er et ht dt translated">web组装/设计</h2><div class="mw l"><h3 class="bd b fv z el mu eo ep mv er et ek translated">设计- WebAssembly设计文档</h3></div><div class="mx l"><p class="bd b gc z el mu eo ep mv er et ek translated">github.com</p></div></div><div class="my l"><div class="mz l na nb nc my nd ka mp"/></div></div></a></div><p id="141e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我相信你已经听说过<a class="ae jp" href="http://webassembly.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> WebAssembly </strong> </a>。</p><p id="2c05" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是如果你想使用<strong class="it hv"> WebAssembly </strong>，你<strong class="it hv">需要了解C或C++ </strong>。<br/>有多少<strong class="it hv">前端</strong>开发人员<strong class="it hv">熟悉</strong>C/c++？<br/> <em class="lg">我个人在现实生活中并不认识这样的开发者。</em></p><p id="f05c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们可以通过两种方式将C/C++代码编译成Wasm:</p><ul class=""><li id="429e" class="ne nf hu it b iu iv iy iz jc ng jg nh jk ni jo nj nk nl nm dt translated">用Emscripten编译。</li><li id="2d25" class="ne nf hu it b iu nn iy no jc np jg nq jk nr jo nj nk nl nm dt translated">用LLVM编译。<a class="ae jp" href="https://gist.github.com/yurydelendik/4eeff8248aeb14ce763e" rel="noopener ugc nofollow" target="_blank">安装指南在此。</a></li></ul></div><div class="ab cl lh li hc lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hn ho hp hq hr"><h2 id="b397" class="kg kh hu bd ki kj kk kl km kn ko kp kq jc kr ks kt jg ku kv kw jk kx ky kz la dt translated">Emscripten</h2><div class="mm mn fm fo mo mp"><a href="https://github.com/kripken/emscripten" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab ej"><div class="mr ab ms cl cj mt"><h2 class="bd hv fv z el mu eo ep mv er et ht dt translated">克里普肯/埃姆斯普滕</h2><div class="mw l"><h3 class="bd b fv z el mu eo ep mv er et ek translated">一个LLVM到JavaScript的编译器</h3></div><div class="mx l"><p class="bd b gc z el mu eo ep mv er et ek translated">github.com</p></div></div><div class="my l"><div class="ns l na nb nc my nd ka mp"/></div></div></a></div><blockquote class="mf mg mh"><p id="7a92" class="ir is lg it b iu iv iw ix iy iz ja jb mi jd je jf mj jh ji jj mk jl jm jn jo hn dt translated">Emscripten使本机代码在Web上立即可用。</p></blockquote><p id="bfc6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://kripken.github.io/emscripten-site/" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">Emscripten</strong></a><strong class="it hv"/>的目的之一就是将<strong class="it hv">已有的庞大C/C++代码库移植到Web </strong>。但是目前，JavaScript是最流行的语言之一。它在我们的<strong class="it hv">浏览器</strong>中运行，在<strong class="it hv">移动平台</strong>上运行，在<strong class="it hv">服务器</strong> ( <em class="lg">节点</em>)上运行。JS <strong class="it hv"> codebase </strong> <strong class="it hv">是</strong> <strong class="it hv">巨大的</strong>也是。</p></div><div class="ab cl lh li hc lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hn ho hp hq hr"><h1 id="2251" class="lo kh hu bd ki lp lq lr km ls lt lu kq lv lw lx kt ly lz ma kw mb mc md kz me dt translated">JS -&gt; WebAssembly</h1><p id="b0ad" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">就我个人而言，我在寻找任何可以将JS翻译成l语言的工具，这些语言可以被翻译成C/C++或asm.js。还有……我没有找到任何这样的工具。</p><p id="378c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不过可以找个工具把<code class="eh nt nu nv nw b">&lt;your-favorite-language/&gt;</code>翻译成JS。这个工具几乎总是存在的。这证明JS代码库可能是<strong class="it hv">有史以来</strong>最大的代码库。JS代码可以用<a class="ae jp" href="http://www.jsweet.org/" rel="noopener ugc nofollow" target="_blank"> Java </a>、<a class="ae jp" href="http://www.infoworld.com/article/3033047/javascript/4-tools-to-convert-python-to-javascript-and-back-again.html" rel="noopener ugc nofollow" target="_blank"> Python </a>等语言生成。</p><blockquote class="mf mg mh"><p id="91a6" class="ir is lg it b iu iv iw ix iy iz ja jb mi jd je jf mj jh ji jj mk jl jm jn jo hn dt translated"><strong class="it hv">有趣的想法</strong>:<a class="ae jp" href="https://facebook.github.io/reason/" rel="noopener ugc nofollow" target="_blank">原因</a>语言是基于OCaml的后端开发的，用于生成JS。OCaml字节码可以翻译成C代码。意味着Reason(可能)允许你同时写WebAssembly和JS。</p></blockquote><p id="d6c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一种方法是将JS编译成<strong class="it hv"> LLVM字节码</strong>。理论上，那可以提供JS编译成<strong class="it hv">的原生代码和WebAssembly。这是个疯狂的想法，但会很棒。</strong></p></div><div class="ab cl lh li hc lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hn ho hp hq hr"><h1 id="58fd" class="lo kh hu bd ki lp lq lr km ls lt lu kq lv lw lx kt ly lz ma kw mb mc md kz me dt translated">小纸条:</h1><blockquote class="mf mg mh"><p id="2781" class="ir is lg it b iu iv iw ix iy iz ja jb mi jd je jf mj jh ji jj mk jl jm jn jo hn dt translated">几乎每种语言都可以生成JS，但是您只能用可以编译成LLVM字节码的语言生成WebAssembly(它将在浏览器中与JS交互)。</p><p id="745c" class="ir is lg it b iu iv iw ix iy iz ja jb mi jd je jf mj jh ji jj mk jl jm jn jo hn dt translated">但是与其写C代码，不如将JS翻译成WebAssembly。</p></blockquote></div><div class="ab cl lh li hc lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hn ho hp hq hr"><h1 id="6cb3" class="lo kh hu bd ki lp lq lr km ls lt lu kq lv lw lx kt ly lz ma kw mb mc md kz me dt translated">“编译”您的JS的工具:</h1><h1 id="48c6" class="lo kh hu bd ki lp nx lr km ls ny lu kq lv nz lx kt ly oa ma kw mb ob md kz me dt translated">围住</h1><blockquote class="oc"><p id="f866" class="od oe hu bd of og oh oi oj ok ol jo ek translated">将Node.js项目编译成可执行文件</p></blockquote><div class="om on oo op oq mp"><a href="https://github.com/igorklopov/enclose" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab ej"><div class="mr ab ms cl cj mt"><h2 class="bd hv fv z el mu eo ep mv er et ht dt translated">igorklopov/附上</h2><div class="mw l"><h3 class="bd b fv z el mu eo ep mv er et ek translated">将Node.js项目编译成可执行文件</h3></div><div class="mx l"><p class="bd b gc z el mu eo ep mv er et ek translated">github.com</p></div></div><div class="my l"><div class="or l na nb nc my nd ka mp"/></div></div></a></div><p id="0a32" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="http://enclosejs.com/" rel="noopener ugc nofollow" target="_blank">这是第一次尝试“编译”JS。<br/></a>Enclose有两个版本:免费和专有。免费版本只能捆绑五个文件。<br/>另外，看起来<strong class="it hv"> Enclose已经过时了。<br/> </strong>现在<em class="lg">项目业主在<strong class="it hv"> Pkg </strong>上</em>工作。</p></div><div class="ab cl lh li hc lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hn ho hp hq hr"><h1 id="7e95" class="lo kh hu bd ki lp lq lr km ls lt lu kq lv lw lx kt ly lz ma kw mb mc md kz me dt translated">包装</h1><blockquote class="oc"><p id="3715" class="od oe hu bd of og oh oi oj ok ol jo ek translated">将Node.js项目打包成可执行文件</p></blockquote><div class="om on oo op oq mp"><a href="https://github.com/zeit/pkg" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab ej"><div class="mr ab ms cl cj mt"><h2 class="bd hv fv z el mu eo ep mv er et ht dt translated">zeit/pkg</h2><div class="mw l"><h3 class="bd b fv z el mu eo ep mv er et ek translated">pkg——将Node.js项目打包成可执行文件</h3></div><div class="mx l"><p class="bd b gc z el mu eo ep mv er et ek translated">github.com</p></div></div><div class="my l"><div class="os l na nb nc my nd ka mp"/></div></div></a></div><p id="7c5a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最近尝试“编译”JS。<br/>它是如何工作的？<strong class="it hv"> Pkg </strong>只是把30MB的节点二进制放到可执行文件中。所以即使像<code class="eh nt nu nv nw b">const a = 5</code>这样的代码也会生成一个大文件。</p><p id="76dc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="lg">来自</em> <a class="ae jp" href="https://github.com/pmq20/node-compiler" rel="noopener ugc nofollow" target="_blank"> <em class="lg">节点-编译器</em> </a> <em class="lg">文档(对照表):</em></p><blockquote class="mf mg mh"><p id="3e16" class="ir is lg it b iu iv iw ix iy iz ja jb mi jd je jf mj jh ji jj mk jl jm jn jo hn dt translated"><strong class="it hv"> Pkg </strong>动态入侵<code class="eh nt nu nv nw b">fs.*</code> API以访问包内文件。<br/> <strong class="it hv"> Pkg </strong>使用JSON存储包内文件。</p></blockquote><p id="d813" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">用例:</strong></p><ul class=""><li id="a7f7" class="ne nf hu it b iu iv iy iz jc ng jg nh jk ni jo nj nk nl nm dt translated">制作应用程序的演示版本。</li><li id="71d7" class="ne nf hu it b iu nn iy no jc np jg nq jk nr jo nj nk nl nm dt translated">制作交叉编译的可执行文件。</li></ul><blockquote class="mf mg mh"><p id="2dfc" class="ir is lg it b iu iv iw ix iy iz ja jb mi jd je jf mj jh ji jj mk jl jm jn jo hn dt translated"><em class="hu">个人比较确定Pkg更合适的名字是</em> <strong class="it hv"> <em class="hu">附2 :) </em> </strong></p><p id="7e72" class="ir is lg it b iu iv iw ix iy iz ja jb mi jd je jf mj jh ji jj mk jl jm jn jo hn dt translated">Pkg的主要开发者是伊戈尔·克洛波夫:<a class="ae jp" href="https://github.com/zeit/pkg/pulse/monthly" rel="noopener ugc nofollow" target="_blank">这里是repo的脉冲。</a></p><p id="4fa3" class="ir is lg it b iu iv iw ix iy iz ja jb mi jd je jf mj jh ji jj mk jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/zeit/pkg/commits/master" rel="noopener ugc nofollow" target="_blank">您可以检查提交历史</a>。</p><p id="efd9" class="ir is lg it b iu iv iw ix iy iz ja jb mi jd je jf mj jh ji jj mk jl jm jn jo hn dt translated"><strong class="it hv"> Pkg </strong>使用devdependency <code class="eh nt nu nv nw b">eslint-config-klopov</code>。</p></blockquote></div><div class="ab cl lh li hc lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hn ho hp hq hr"><h1 id="a3f5" class="lo kh hu bd ki lp lq lr km ls lt lu kq lv lw lx kt ly lz ma kw mb mc md kz me dt translated">Nexe</h1><blockquote class="oc"><p id="e5fc" class="od oe hu bd of og oh oi oj ok ol jo ek translated">🎉从node.js应用程序中创建一个可执行文件</p></blockquote><div class="om on oo op oq mp"><a href="https://github.com/nexe/nexe" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab ej"><div class="mr ab ms cl cj mt"><h2 class="bd hv fv z el mu eo ep mv er et ht dt translated">nexe/nexe</h2><div class="mw l"><h3 class="bd b fv z el mu eo ep mv er et ek translated">nexe -🎉从node.js应用程序中创建一个可执行文件</h3></div><div class="mx l"><p class="bd b gc z el mu eo ep mv er et ek translated">github.com</p></div></div><div class="my l"><div class="ot l na nb nc my nd ka mp"/></div></div></a></div><p id="2473" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">又一次尝试编译JS。</p><p id="37ec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它到底是如何工作的没有官方信息，但是<em class="lg">经过一个小的研究，我弄明白了</em>中的<a class="ae jp" href="https://github.com/nexe/nexe/blob/master/lib/exe.js#L304-L308" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> Nexe下载节点二进制文件</strong> </a>(就像<strong class="it hv"> Pkg </strong>和<strong class="it hv">包围</strong>)。</p><p id="7e40" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">问题:</p><ul class=""><li id="5494" class="ne nf hu it b iu iv iy iz jc ng jg nh jk ni jo nj nk nl nm dt translated">Nexe不支持节点本机模块。</li><li id="1ce6" class="ne nf hu it b iu nn iy no jc np jg nq jk nr jo nj nk nl nm dt translated">Nexe不支持动态require语句。</li><li id="7d99" class="ne nf hu it b iu nn iy no jc np jg nq jk nr jo nj nk nl nm dt translated">Nexe使用browserify(不好吗？我想这并不现代。)。<br/> <a class="ae jp" href="https://github.com/nexe/nexe/tree/next" rel="noopener ugc nofollow" target="_blank"> <em class="lg">但只限于高手分支。您可以在这里找到dev branch。</em> </a></li></ul></div><div class="ab cl lh li hc lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hn ho hp hq hr"><h1 id="f561" class="lo kh hu bd ki lp lq lr km ls lt lu kq lv lw lx kt ly lz ma kw mb mc md kz me dt translated"><strong class="ak">节点编译器</strong></h1><blockquote class="oc"><p id="80e3" class="od oe hu bd of og oh oi oj ok ol jo ek translated">使用dynamic require和所有fs将Node.js应用程序编译成一个可执行文件。* API支持。</p></blockquote><div class="om on oo op oq mp"><a href="https://github.com/pmq20/node-compiler" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab ej"><div class="mr ab ms cl cj mt"><h2 class="bd hv fv z el mu eo ep mv er et ht dt translated">pmq 20/节点编译器</h2><div class="mw l"><h3 class="bd b fv z el mu eo ep mv er et ek translated">node-compiler——使用dynamic require和所有fs将Node.js应用程序编译成一个可执行文件。* API…</h3></div><div class="mx l"><p class="bd b gc z el mu eo ep mv er et ek translated">github.com</p></div></div><div class="my l"><div class="ou l na nb nc my nd ka mp"/></div></div></a></div><p id="2933" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">节点编译器</strong>推荐自己是Pkg和Nexe的更好替代品。正如你所看到的<a class="ae jp" href="https://github.com/pmq20/node-compiler/blob/master/lib/compiler/npm_package.rb#L25-L57" rel="noopener ugc nofollow" target="_blank">这个工具将你的应用与节点二进制文件</a> <em class="lg">(我不确定，没有关于它如何工作的信息)</em>。</p><p id="dabd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="lg">还有，</em> <a class="ae jp" href="https://github.com/pmq20/node-compiler/tree/master/node" rel="noopener ugc nofollow" target="_blank"> <em class="lg">在项目回购里找到Node.js回购很奇怪吧？</em>T15】</a></p><h1 id="41ae" class="lo kh hu bd ki lp nx lr km ls ny lu kq lv nz lx kt ly oa ma kw mb ob md kz me dt translated">小总结:</h1><ul class=""><li id="ac91" class="ne nf hu it b iu lb iy lc jc ov jg ow jk ox jo nj nk nl nm dt translated"><strong class="it hv">附上</strong>好像没保养。</li><li id="a999" class="ne nf hu it b iu nn iy no jc np jg nq jk nr jo nj nk nl nm dt translated"><code class="eh nt nu nv nw b">&lt;sarcasm&gt;<br/><strong class="it hv">//</strong></code> <strong class="it hv"> Pkg </strong> === ( <strong class="it hv"> <em class="lg">附2.0: </em> </strong> <em class="lg">伊戈尔·克洛波夫的归来)<br/> </em> <code class="eh nt nu nv nw b">&lt;/sarcasm&gt;</code></li><li id="8276" class="ne nf hu it b iu nn iy no jc np jg nq jk nr jo nj nk nl nm dt translated"><code class="eh nt nu nv nw b">&lt;sarcasm&gt;</code> <strong class="it hv">节点编译器</strong>在repo中存储Node.js repo。<code class="eh nt nu nv nw b">&lt;/sarcasm&gt;</code></li><li id="683b" class="ne nf hu it b iu nn iy no jc np jg nq jk nr jo nj nk nl nm dt translated"><a class="ae jp" href="https://github.com/nexe/nexe/commits/next" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> Nexe </strong>在发展，但不那么积极。</a></li><li id="ba9c" class="ne nf hu it b iu nn iy no jc np jg nq jk nr jo nj nk nl nm dt translated"><strong class="it hv">这些项目都不编译JS，只是用节点二进制打包你的代码。</strong></li><li id="c97d" class="ne nf hu it b iu nn iy no jc np jg nq jk nr jo nj nk nl nm dt translated">但是<strong class="it hv">它们对于某些用途来说仍然很棒</strong>，因为你可以将你的代码打包成可执行文件。</li></ul></div><div class="ab cl lh li hc lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hn ho hp hq hr"><h1 id="e621" class="lo kh hu bd ki lp lq lr km ls lt lu kq lv lw lx kt ly lz ma kw mb mc md kz me dt translated">用JS引擎编译</h1><h2 id="4f13" class="kg kh hu bd ki kj kk kl km kn ko kp kq jc kr ks kt jg ku kv kw jk kx ky kz la dt translated"><strong class="ak"> <em class="ml">可以用V8/查克拉/蜘蛛猴编译JS吗？</em> </strong></h2><p id="5ea2" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">是的，我们可以。 <strong class="it hv">理论上的</strong>。例如，我们可以从引擎中取出未优化的编译(非“JIT-ed”)代码。</p><p id="cc00" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不，我们不能。未优化的本机代码比JIT优化的代码效率低。</p><p id="f435" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">也许。每个JS引擎都是一个非常复杂、令人困惑的系统，有自己的架构和特性。</strong></p><blockquote class="mf mg mh"><p id="7ade" class="ir is lg it b iu iv iw ix iy iz ja jb mi jd je jf mj jh ji jj mk jl jm jn jo hn dt translated">如果你问某人浏览器是如何工作的，你会发现这个开发者只知道浏览器的一些常识。而且是… <strong class="it hv">吓人</strong>。因为不是所有的程序员都知道<strong class="it hv">系统(执行他们的代码)是如何工作的</strong>。</p></blockquote></div><div class="ab cl lh li hc lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hn ho hp hq hr"><h1 id="9287" class="lo kh hu bd ki lp lq lr km ls lt lu kq lv lw lx kt ly lz ma kw mb mc md kz me dt translated">结论。</h1><ul class=""><li id="c389" class="ne nf hu it b iu lb iy lc jc ov jg ow jk ox jo nj nk nl nm dt translated"><strong class="it hv">电子</strong>必须<strong class="it hv">修正</strong>。</li><li id="46a8" class="ne nf hu it b iu nn iy no jc np jg nq jk nr jo nj nk nl nm dt translated">很多前端开发者<strong class="it hv">不会用WebAssembly </strong>，因为<strong class="it hv">没有C/C++背景。</strong></li><li id="6f93" class="ne nf hu it b iu nn iy no jc np jg nq jk nr jo nj nk nl nm dt translated">没有任何工具可以将JS翻译成另一种语言。</li><li id="7cd1" class="ne nf hu it b iu nn iy no jc np jg nq jk nr jo nj nk nl nm dt translated">JS代码可以从几乎任何编程语言生成。</li><li id="3a4e" class="ne nf hu it b iu nn iy no jc np jg nq jk nr jo nj nk nl nm dt translated">可以让可执行文件存在的工具，但是他们把节点二进制文件放到你的文件中。</li><li id="f54a" class="ne nf hu it b iu nn iy no jc np jg nq jk nr jo nj nk nl nm dt translated"><strong class="it hv">浏览器</strong>非常<strong class="it hv">复杂</strong>并且可能<strong class="it hv">更好地向开发者解释。</strong></li><li id="f6e8" class="ne nf hu it b iu nn iy no jc np jg nq jk nr jo nj nk nl nm dt translated">WebAssembly可能会成为JavaScript的编译形式。</li></ul></div><div class="ab cl lh li hc lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hn ho hp hq hr"><p id="91f1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="lg">也许，JS是新的C语言？现代世界的现代C。</em>T13】</strong></p></div><div class="ab cl lh li hc lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hn ho hp hq hr"><p id="e742" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">github:<a class="ae jp" href="https://github.com/Metnew" rel="noopener ugc nofollow" target="_blank">https://github.com/Metnew</a><br/>推特:<a class="ae jp" href="https://twitter.com/coldlinecall" rel="noopener ugc nofollow" target="_blank">https://twitter.com/coldlinecall</a><br/>邮件:<em class="lg">vladimirmetnew@gmail.com</em></p><div class="jr js jt ju fq ab cb"><figure class="oy jv oz pa pb pc pd paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="oy jv oz pa pb pc pd paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="oy jv oz pa pb pc pd paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mf mg mh"><p id="f922" class="ir is lg it b iu iv iw ix iy iz ja jb mi jd je jf mj jh ji jj mk jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是这个家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is lg it b iu iv iw ix iy iz ja jb mi jd je jf mj jh ji jj mk jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff pe"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="pf pg l"/></div></figure></div></div>    
</body>
</html>