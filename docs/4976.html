<html>
<head>
<title>Drag &amp; Drop for Lightning Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Lightning组件的拖放</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/drag-drop-for-lightning-components-27230745a2eb?source=collection_archive---------3-----------------------#2017-07-03">https://medium.com/hackernoon/drag-drop-for-lightning-components-27230745a2eb?source=collection_archive---------3-----------------------#2017-07-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="9427" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">很久以前…</h1><p id="11fd" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">一位同事和我谈论基于组件的应用程序；我和他分享了一些我和AngularJS(是的，“1”版本)和Vue的可爱经历。那是11月，天气越来越暖和，夏天就在眼前，这本身就让我很开心。然而，我的朋友感到寒冷和沮丧；在过去的几个月里，他一直在从事基于Lightning组件框架的sales force Lightning应用程序的工作，并且他一直在努力处理那些在任何其他框架中都很自然的东西。他在为Lightning组件进行拖放工作时遇到了问题，并且陷入了死胡同……那东西拒绝工作，他要怪Lightning。</p><p id="7b55" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">那时，在听到他的誓言后，我只是走开，继续我的路，只给他留下一句简单的“对不起”(又名。“我认为这是你的问题，我绝不可能插手”)。</p><p id="4b90" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">但和往常一样，这个世界转啊转，有时会让你正好面对你曾经选择忽视和逃避的问题。对于一般的生活来说是如此，对于编程来说也是如此。几个月后，我被同样的问题困扰:<strong class="jr hv">拖&amp;下降为闪电组件</strong>。</p><h1 id="4cf2" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">设定我们的目标！</h1><p id="fe5b" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我认为设立一个小项目作为概念验证是有意义的，也是隔离D&amp;D问题的一种手段。</p><p id="7cac" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">这个想法是将Trello和其他看板风格的应用程序的典型的基于列的布局拿出来，创建一些“卡片”或项目，并能够在列之间移动它们。</p><p id="2775" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">这是我们需要的:</p><ol class=""><li id="b379" class="kt ku hu jr b js ko jw kp ka kv ke kw ki kx km ky kz la lb dt translated">一个lightning应用程序和一个用于我们演示的容器lightning组件。</li><li id="205b" class="kt ku hu jr b js lc jw ld ka le ke lf ki lg km ky kz la lb dt translated">每个列或管道都将被表示为一个组件，并且都将是我们可拖动项目的有效拖放目标</li><li id="01be" class="kt ku hu jr b js lc jw ld ka le ke lf ki lg km ky kz la lb dt translated">每列中可拖动的项目看起来像卡片，我们可以用鼠标随意移动它们。</li></ol><p id="1193" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">很简单，不是吗？</p><h1 id="62cb" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">准备好了…</h1><p id="2104" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">首先，我定义了一个非常简单的应用程序和主要组件。其结构如下:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="b817" class="lq is hu lm b fv lr ls l lt lu">&lt;!-- DragDropContainer.cmp --&gt;<br/>&lt;aura:component&gt;<br/>  &lt;!-- resources --&gt;<br/>  &lt;ltng:require styles="{!$Resource.bulma + '/bulma-0.4.2/css/bulma.css'}" /&gt;</span><span id="0c6d" class="lq is hu lm b fv lv ls l lt lu">&lt;!-- attributes --&gt;<br/>  &lt;aura:attribute name="allItems" type="list"&gt;&lt;/aura:attribute&gt;</span><span id="4587" class="lq is hu lm b fv lv ls l lt lu">&lt;!-- event handlers --&gt;<br/>  &lt;aura:handler name="init" action="{!c.doInit}" value="{!this}"&gt;&lt;/aura:handler&gt;<br/>  &lt;aura:handler name="pipelineChange" event="c:pipelineChange" action="{!c.onPipelineChanged}"&gt;&lt;/aura:handler&gt;</span><span id="283a" class="lq is hu lm b fv lv ls l lt lu">&lt;div class="columns"&gt;<br/>    &lt;c:pipeline title="New" items="{!v.allItems}"&gt;&lt;/c:pipeline&gt;<br/>    &lt;c:pipeline title="Closed" items="{!v.allItems}"&gt;&lt;/c:pipeline&gt;<br/>    &lt;c:pipeline title="Deleted" items="{!v.allItems}"&gt;&lt;/c:pipeline&gt;<br/>  &lt;/div&gt;<br/>&lt;/aura:component&gt;</span></pre><p id="7689" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">尽可能简单地，我们有3个“管道”来保存我们的可拖动项，它们是在组件的“onInit”方法中生成的，还有一个名为“pipelineChange”的自定义事件的处理程序。该事件有以下定义:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="0555" class="lq is hu lm b fv lr ls l lt lu">&lt;!-- pipelineChange.evt --&gt;<br/>&lt;aura:event type="COMPONENT" description="Event fired whenever an item is dropped on a pipeline"&gt;<br/>    &lt;aura:attribute type="String" name="title"&gt;&lt;/aura:attribute&gt; <br/>    &lt;aura:attribute type="Object" name="item"&gt;&lt;/aura:attribute&gt;&lt;/aura:event&gt;</span></pre><p id="6683" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated"><strong class="jr hv">这是我们的控制器，展示了我们如何创建项目和处理自定义事件</strong></p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="483e" class="lq is hu lm b fv lr ls l lt lu">&lt;!-- DragDropContainerController.js --&gt;<br/>({<br/>  doInit: function(component, event, helper) {<br/>    var newItems = [<br/>      {<br/>        title: "One item",<br/>        id: "23243342",<br/>        status: "New"<br/>      }<br/>    ];<br/>    component.set("v.allItems", newItems);<br/>  },</span><span id="fac3" class="lq is hu lm b fv lv ls l lt lu">onPipelineChanged: function(component, event, helper) {<br/>    var title = event.getParam("title");<br/>    var item = event.getParam("item");<br/>    var allLists = component.get("v.allItems");<br/>    var actualItem = allLists.find(function(el) {<br/>      return el.id == item.id;<br/>    });<br/>    if (actualItem) {<br/>      actualItem.status = title;<br/>      component.set("v.allItems", allLists);<br/>    } else {<br/>      console.log("could not find item ", item, " in list ", allLists);<br/>    }<br/>  }<br/>});</span></pre><p id="f041" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">因此，基本上我们创建了一个条目列表，每个条目都有一个与组件中的每个管道(列)相匹配的“状态”。为了处理<strong class="jr hv"> pipelineChanged </strong>事件，我们定义了一个处理程序，它将项目的状态设置为它所放入的列的名称，并刷新我们的集合。我知道这不是最理想的，但现在已经足够了。</p><h1 id="1f2b" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">设置…</h1><p id="2e02" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">每个项目将由一个“卡”组件表示，如下所示:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="6212" class="lq is hu lm b fv lr ls l lt lu">&lt;!-- Card.cmp --&gt;<br/>&lt;aura:component &gt;<br/>    &lt;aura:attribute name="item" type="Object" required="true"&gt;&lt;/aura:attribute&gt;<br/>    &lt;div class="card draggable" draggable="true" ondragstart="{!c.onDragStart}"&gt;<br/>        &lt;div class="card-content"&gt;{!v.item.title}&lt;/div&gt;<br/>    &lt;/div&gt;<br/>&lt;/aura:component&gt;</span></pre><p id="b8bd" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">我们将组件的主标签声明为“draggable ”,以便浏览器知道我们希望用户能够拖动它，并且我们有一个用于<strong class="jr hv"> dragStart </strong>事件的处理程序。正如您可能已经猜到的，我们将把我们的项目(组件的属性)放入D &amp; D的dataTransfer事件集属性:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="7780" class="lq is hu lm b fv lr ls l lt lu">&lt;!-- CardController.js --&gt;<br/>({<br/>     onDragStart : function(component, event, helper) {<br/>         event.dataTransfer.dropEffect = "move";<br/>         var item = component.get('v.item');<br/>         event.dataTransfer.setData('text', JSON.stringify(item));<br/>     }<br/>})</span></pre><p id="65bf" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">太好了！我们能够将序列化为JSON字符串的整个项目放入D&amp;D事件集的dataTransfer属性中(有关这方面的更多信息，请参见<a class="ae kn" href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API" rel="noopener ugc nofollow" target="_blank"> HTML拖放API </a>)。现在，我们只需要确保我们的“管道”组件能够在用户放下对象时进行处理，我们就完成了。</p><h1 id="fffd" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">还有…什么？</h1><p id="02f3" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">通常，为了让drop事件在给定的HTML元素上工作，我们只需要为接收事件并调用“event.preventDefault()”的<strong class="jr hv"> ondrop </strong>事件实现一个简单的处理函数。因此，我为我们的管道创建了以下组件</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="84b4" class="lq is hu lm b fv lr ls l lt lu">&lt;!-- pipeline.cmp --&gt;<br/>&lt;aura:component &gt;<br/>    &lt;!-- Attributes --&gt;<br/>    &lt;aura:attribute name="title" type="String" required="true"&gt;&lt;/aura:attribute&gt;<br/>    &lt;aura:attribute name="items" type="Object[]" required="true"&gt;&lt;/aura:attribute&gt;<br/>    <br/>    &lt;!-- Custom Events --&gt;<br/>    &lt;aura:registerEvent name="pipelineChange" type="c:pipelineChange"/&gt;<br/>    <br/>    &lt;div class="column" ondrop="{!c.onDrop}"&gt;<br/>        &lt;div class="panel"&gt;<br/>            &lt;div class="panel-heading"&gt;<br/>                {! v.title }<br/>            &lt;/div&gt;<br/>            &lt;div class="panel-block column"&gt;<br/>                &lt;aura:iteration items="{!v.items}" var="item"&gt;<br/>                    &lt;aura:if isTrue="{!item.status == v.title}"&gt;<br/>                     &lt;c:Card item="{!item}"&gt;&lt;/c:Card&gt;<br/>                    &lt;/aura:if&gt;    <br/>                &lt;/aura:iteration&gt;<br/>            &lt;/div&gt;<br/>        &lt;/div&gt;<br/>    &lt;/div&gt;<br/>&lt;/aura:component&gt;</span></pre><p id="bd38" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">注意，我注册了前面提到的“pipelineChange”事件，所以我可以从这个组件中触发它(毕竟，我们希望我们的主组件在用户将卡放入其中一个管道时能够注意到。这是我们的控制器:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="55e2" class="lq is hu lm b fv lr ls l lt lu">&lt;!-- pipelineController.js --&gt;<br/>({  <br/>    onDrop: function(component, event, helper) {<br/>        event.preventDefault();<br/>        var pipelineChangeEvent = component.getEvent('pipelineChange');<br/>        pipelineChangeEvent.setParams({<br/>            'title': component.get('v.title'),<br/>            'item': JSON.parse(event.dataTransfer.getData('text'))<br/>        });<br/>        pipelineChangeEvent.fire();<br/>    }<br/>})</span></pre><p id="89fe" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">迄今为止，太阳底下没有什么新鲜事。我用一个最终触发<strong class="jr hv"> pipelineChange </strong>事件的函数处理了<strong class="jr hv"> ondrop </strong>事件，这样我们的主组件就可以施展魔法并刷新我们的列表(同样，所有这些往返都是因为我想更加简单，而不是使实现过于复杂。应该管用吧？</p><p id="0dda" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated"><strong class="jr hv"> <em class="lw">嗯，情况就是这样行不通。</em>T13】</strong></p><h1 id="b93b" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">又是糟糕的设计，闪电？</h1><p id="4247" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">这并不新鲜，Lightning组件框架的某些部分并没有得到很好的考虑，而且它们的执行更差。兔子洞有多远是我们在开发lightning应用程序和组件时每天都会发现的事情，所以Salesforce搞乱本机<a class="ae kn" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> javascript </a>事件令人惊讶。</p><p id="95c7" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated"><strong class="jr hv">众所周知</strong> lightning覆盖了“触摸”事件，在基于触摸的平台上用“点击”来代替它们，这并没有那么糟糕，如果你仔细想想，这甚至是有道理的。然而，D事件的处理却是另一回事。</p><p id="2be4" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">显然，有些事件就是不行，比如“<strong class="jr hv">拖拉</strong>”和“<strong class="jr hv">拖拉</strong>”。这是为什么，我不知道。更糟糕的是，一些事件被渲染成无法尊重他们各自的契约。O 一个这样的例子是“<strong class="jr hv"> drop </strong>”，如果没有以非常具体的方式处理，它将丢失其key <strong class="jr hv"> dataTransfer </strong>属性的值。</p><p id="681d" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">如果你没有注意到<strong class="jr hv">数据传输</strong>属性是整个拖放机制工作的关键。如果我们不能获得我们在链的前面步骤中存储的任何数据，我们就不可能成功地处理一个drop事件…这意味着我们破产了。</p><h1 id="e0c8" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">追逐龙</h1><p id="9f1c" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">然后，我在谷歌上搜索了一大堆误导性的东西，有限的用例，甚至是我拒绝为处理拖放用例这样简单和基本的事情添加的库覆盖的东西。</p><p id="b98f" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">可能就像流行故事中的Jekyll博士一样，我开始混合药水和我知道会有效的拖放实现的配方，甚至在VueJS上创建了这个概念的<a class="ae kn" href="https://codepen.io/srodriki/pen/KqKEmO" rel="noopener ugc nofollow" target="_blank">证明。</a>什么都没用，我正要放弃的时候…</p><p id="bfa0" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">我决定<strong class="jr hv">阻止所有我没有使用的拖拽事件的默认设置</strong>,因为你猜怎么着？这东西起作用了！</p><p id="91b0" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">我将为您省去一些往返行程，并告诉您我实际上需要用<strong class="jr hv"> preventDefault </strong>处理的另一个事件是<strong class="jr hv"> dragover </strong>事件。这是为什么呢？我仍然不知道。</p><p id="96da" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">最后，我们的管道组件将如下所示:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="1b10" class="lq is hu lm b fv lr ls l lt lu">&lt;!-- pipeline.cmp --&gt;<br/>&lt;aura:component &gt;<br/>    &lt;!-- Attributes --&gt;<br/>    &lt;aura:attribute name="title" type="String" required="true"&gt;&lt;/aura:attribute&gt;<br/>    &lt;aura:attribute name="items" type="Object[]" required="true"&gt;&lt;/aura:attribute&gt;<br/>    <br/>    &lt;!-- Custom Events --&gt;<br/>    &lt;aura:registerEvent name="pipelineChange" type="c:pipelineChange"/&gt;<br/>    <br/>    &lt;div class="column" ondrop="{!c.onDrop}" ondragover="{!c.allowDrop}"&gt;<br/>        &lt;div class="panel"&gt;<br/>            &lt;div class="panel-heading"&gt;<br/>                {! v.title }<br/>            &lt;/div&gt;<br/>            &lt;div class="panel-block column"&gt;<br/>                &lt;aura:iteration items="{!v.items}" var="item"&gt;<br/>                    &lt;aura:if isTrue="{!item.status == v.title}"&gt;<br/>                     &lt;c:Card item="{!item}"&gt;&lt;/c:Card&gt;<br/>                    &lt;/aura:if&gt;    <br/>                &lt;/aura:iteration&gt;<br/>            &lt;/div&gt;<br/>        &lt;/div&gt;<br/>    &lt;/div&gt;<br/>&lt;/aura:component&gt;</span></pre><p id="9656" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">这是我们的控制器，现在可以让我们的组件按预期工作。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="8dae" class="lq is hu lm b fv lr ls l lt lu">&lt;!-- pipelineController.js --&gt;<br/>({<br/> allowDrop: function(component, event, helper) {<br/>        event.preventDefault();<br/>    },<br/>    <br/>    onDrop: function(component, event, helper) {<br/>        event.preventDefault();<br/>        var pipelineChangeEvent = component.getEvent('pipelineChange');<br/>        pipelineChangeEvent.setParams({<br/>            'title': component.get('v.title'),<br/>            'item': JSON.parse(event.dataTransfer.getData('text'))<br/>        });<br/>        pipelineChangeEvent.fire();<br/>        <br/>    },<br/>})</span></pre><h1 id="f754" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">旅程还在继续</h1><p id="858d" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我希望这篇相当长的文章能帮助一些人理解如何成功地处理Lightning组件的拖放功能，但我也希望它能描述这样一种挣扎，即Lightning组件框架常常使事情复杂化，而不是作为一种在Force.com平台上构建丰富的web应用程序的手段。</p><blockquote class="lx ly lz"><p id="7844" class="jp jq lw jr b js ko ju jv jw kp jy jz ma kq kc kd mb kr kg kh mc ks kk kl km hn dt translated">你可以在<a class="ae kn" href="https://github.com/srodriki/sfdc-lightning-drag-drop/" rel="noopener ugc nofollow" target="_blank"> Github </a>中找到这个项目的完整回购</p></blockquote><p id="531e" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">许多其他例子向我们展示了Lightning中糟糕的设计决策，大多数时候这让我想到，如果有一个框架能够简单地提供非常有用的库<strong class="jr hv"><em class="lw"/></strong>和调用由Apex控制器从任何Javascript<em class="lw"/>公开的<strong class="jr hv"> <em class="lw"> AuraEnabled方法，将任何前端工作留给Vue、Angular、React、Inferno、Ember等经验证的库，我们会更高兴。</em></strong></p><p id="be0b" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">不管怎样，虽然上述情况不会发生，但我会(希望)尽快为Lightning组件框架的常见问题提供有用的解决方案。</p><p id="43a9" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated"><strong class="jr hv">干杯，快乐编码！</strong></p><blockquote class="lx ly lz"><p id="d4a4" class="jp jq lw jr b js ko ju jv jw kp jy jz ma kq kc kd mb kr kg kh mc ks kk kl km hn dt translated"><a class="ae kn" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kn" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kn" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae kn" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="jp jq lw jr b js ko ju jv jw kp jy jz ma kq kc kd mb kr kg kh mc ks kk kl km hn dt translated">要了解更多信息，请<a class="ae kn" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae kn" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae kn" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="jp jq lw jr b js ko ju jv jw kp jy jz ma kq kc kd mb kr kg kh mc ks kk kl km hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kn" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kn" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lh li lj lk fq md"><div class="bz el l di"><div class="me mf l"/></div></figure></div></div>    
</body>
</html>