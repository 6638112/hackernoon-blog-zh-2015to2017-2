<html>
<head>
<title>Graceful shutdown in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes的优雅关闭</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/graceful-shutdown-in-kubernetes-435b98794461?source=collection_archive---------3-----------------------#2017-05-08">https://medium.com/hackernoon/graceful-shutdown-in-kubernetes-435b98794461?source=collection_archive---------3-----------------------#2017-05-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="48c9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我一直在研究如何在<a class="ae jp" href="https://hackernoon.com/tagged/kubernetes" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>中优雅地关闭HTTP服务。令人惊讶的是，我在这个话题上发现了相互矛盾的观点，所以我决定自己做测试。如果你对结果感兴趣，请继续阅读。</p><h1 id="f76a" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">研究</h1><p id="24b2" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在研究不同的关闭方法之前，让我们看看Kubernetes官方文档对这个主题是怎么说的[2]。以下是该文档的摘录(我跳过了我认为不相关的部分):</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="ec4e" class="lc jr hu ky b fv ld le l lf lg">1. User sends command to delete Pod, with default grace period (30s)<br/>3. Pod shows up as “Terminating” when listed in client commands<br/>6. The processes in the Pod are sent the TERM signal.<br/>7. (simultaneous with 3), Pod is removed from endpoints list for service, and are no longer considered part of the set of running pods for replication controllers. Pods that shutdown slowly can continue to serve traffic as load balancers (like the service proxy) remove them from their rotations.</span></pre><p id="5fa2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">读到这里，看起来有可能在收到一个<code class="eh lh li lj ky b">SIGTERM</code>之后有新的请求进来(在6和7之间)。这意味着如果进程只是监听<code class="eh lh li lj ky b">SIGTERM</code>并在接收时退出，一些请求将不会被服务。</p><p id="0ab7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这还不够清楚，所以我开始研究。我偶然发现的第一个帖子[1]提出了以下流程:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="5bac" class="lc jr hu ky b fv ld le l lf lg">1. Process receives SIGTERM.<br/>2. Process returns 5XX response for (failureThreshold * periodSeconds) to its readiness probe, so it will be unregistered from the list of valid endpoints.<br/>3. Process closes its listener, waits for all ongoing requests to finish and exists.</span></pre><p id="3af7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种方法表明，进程应该通过就绪探测失败来通知它正在退出。期望一个进程知道它正在运行的底层基础设施似乎很奇怪。更有甚者，看了评论更添困惑。有一个注释指出，通知您的进程正在退出不需要<strong class="it hv">而需要</strong>，但是确实有一些请求会在<code class="eh lh li lj ky b">SIGTERM</code>被发送后被路由到容器。确实很奇怪。我们继续挖吧。</p><p id="19b5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我发现了一个关于正常关机的Stackoverflow问题[3]，答案如下。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="5f95" class="lc jr hu ky b fv ld le l lf lg">I ran some experiments to find out exactly what happens.</span><span id="be90" class="lc jr hu ky b fv lk le l lf lg">The pod will briefly (&lt;1s) continue receiving requests after shutdown is initiated, so you need to either catch SIGTERM or install a preStop hook so you can wait for them (and finish serving current requests).</span><span id="3bbb" class="lc jr hu ky b fv lk le l lf lg">However, once the shutdown has been initiated, the readiness probe no longer matters, you don't need to change its state to stop receiving requests. (But before that a failing readiness probe will lead to your pod receiving no more traffic.)</span></pre><p id="f245" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">更多的研究只是产生了更多的结果，表明这两种方法，使事情更加不清楚。在这一点上，我决定我必须自己做一些实验。</p><h1 id="a665" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">实验</h1><p id="8e9f" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我想检查的第一件事是请求在<code class="eh lh li lj ky b">SIGTERM</code>之后是否被路由到容器。最后，我使用minikube[6]构建了一个本地集群，并部署了test Go程序(名为<code class="eh lh li lj ky b">kuber</code>)，该程序在获得<code class="eh lh li lj ky b">SIGTERM</code>后对所有收到的请求进行计数。它是通过服务和入口公开的。</p><p id="8ee8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我用<code class="eh lh li lj ky b">ab</code>(Apache HTTP server基准测试<a class="ae jp" href="https://hackernoon.com/tagged/tool" rel="noopener ugc nofollow" target="_blank">工具</a>运行了一个测试，当测试运行时，我删除了服务请求的pod。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="3b44" class="lc jr hu ky b fv ld le l lf lg">ab -n 10000 -c 10 <a class="ae jp" href="https://192.168.99.100/api/info" rel="noopener ugc nofollow" target="_blank">https://192.168.99.100/api/info</a> &amp; sleep 3 &amp;&amp; kubectl delete pods/kuber-2370255394-v93lk</span></pre><p id="5dde" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是测试程序的输出:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="dc4e" class="lc jr hu ky b fv ld le l lf lg">$ kubectl logs -f kuber-2263169569-r527k<br/>2017/05/07 18:26:47 Serving...<br/>2017/05/07 18:27:24 Shutting down due to terminated<br/>2017/05/07 18:27:39 Requests served after shutdown signal: 2216<br/>2017/05/07 18:27:39 Exiting</span></pre><p id="7667" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">事实证明，在收到关机信号后，确实有可能得到请求。在停止HTTP服务器之前的15秒钟等待期间，服务了2000多个请求。</p><p id="c2fe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，我没有发现程序在实际退出之前等待的时间与请求数量之间有任何关联。我测试的下一步是使用就绪探针。我增强了测试程序，所以一旦收到终止信号，它就开始返回<code class="eh lh li lj ky b">503 Service Unavailable</code>。这也没有改变行为。</p><h1 id="045b" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">未来的工作</h1><p id="c503" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">上面的测试符合在单节点Kubernetes设置中使用<code class="eh lh li lj ky b">kubectl</code>删除单个pod的情况。当一个节点被终止时，测试在多节点Kubernetes设置中会发生什么是一个好主意。关于停止将请求路由到关闭pod所需的时间，这可能会产生不同的结果。</p><h1 id="56ee" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">外卖食品</h1><p id="01d8" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">以下是我的实验中一些明显和不太明显的收获</p><ul class=""><li id="b1a9" class="ll lm hu it b iu iv iy iz jc ln jg lo jk lp jo lq lr ls lt dt translated">确保您的进程确实收到了终止信号。如果您使用一个shell命令来启动它，例如<code class="eh lh li lj ky b">/bin/sh -c myapp</code>，请确保您使用的shell(本例中为<code class="eh lh li lj ky b">sh</code>)正在向您的程序发送<code class="eh lh li lj ky b">TERM</code>信号。比如在Alpine上，<code class="eh lh li lj ky b">/bin/sh</code>不转发信号。</li><li id="1cbd" class="ll lm hu it b iu lu iy lv jc lw jg lx jk ly jo lq lr ls lt dt translated">在关闭HTTP服务器之前添加一些宽限期，以避免失败的请求。</li><li id="7fd3" class="ll lm hu it b iu lu iy lv jc lw jg lx jk ly jo lq lr ls lt dt translated">如果应用程序在<code class="eh lh li lj ky b">SIGTERM</code>后未能通过准备就绪检测，这不会有任何影响，但拥有这种机制不会有什么坏处，实际上可能是正确的做法。这可能取决于您正在使用的负载平衡层的实现。</li><li id="2df3" class="ll lm hu it b iu lu iy lv jc lw jg lx jk ly jo lq lr ls lt dt translated">如果你正在使用Go，你应该订阅<code class="eh lh li lj ky b">syscall.SIGTERM</code>而不是<code class="eh lh li lj ky b">os.Interrupt</code>。</li></ul><p id="ccf6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你对这个话题有任何经验，请在下面的评论区分享，这样这种困惑就一劳永逸地被赶走了。</p><h2 id="4051" class="lc jr hu bd js lz ma mb jw mc md me ka jc mf mg ke jg mh mi ki jk mj mk km ml dt translated">来源</h2><p id="f679" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">[1]<a class="ae jp" href="https://blog.risingstack.com/graceful-shutdown-node-js-kubernetes/" rel="noopener ugc nofollow" target="_blank">https://blog . rising stack . com/graceful-shut down-node-js-kubernetes/</a></p><p id="fc64" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">[2]<a class="ae jp" href="https://kubernetes.io/docs/concepts/workloads/pods/pod/#termination-of-pods" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/concepts/workloads/pods/pod/# termination-of-pods</a></p><p id="709a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">[3]<a class="ae jp" href="http://stackoverflow.com/questions/40545581/do-kubernetes-pods-still-receive-requests-after-receiving-sigterm" rel="noopener ugc nofollow" target="_blank">http://stack overflow . com/questions/40545581/do-kubernetes-pods-still-receive-requests-after-receiving-sigterm</a></p><p id="d667" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">[4]<a class="ae jp" href="http://stackoverflow.com/questions/31574038/how-can-i-ensure-graceful-scaling-in-kubernetes" rel="noopener ugc nofollow" target="_blank">http://stack overflow . com/questions/31574038/how-can-I-ensure-scaling-in-kubernetes</a></p><p id="06fe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">[5]<a class="ae jp" href="http://www.bite-code.com/2015/07/27/implementing-graceful-shutdown-for-docker-containers-in-go-part-2/" rel="noopener ugc nofollow" target="_blank">http://www . bite-code . com/2015/07/27/implementing-graceful-shut down-for-docker-containers-in-go-part-2/</a></p><p id="d9f8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">[6]https://github.com/kubernetes/minikube<a class="ae jp" href="https://github.com/kubernetes/minikube" rel="noopener ugc nofollow" target="_blank"/></p><blockquote class="mm mn mo"><p id="079c" class="ir is mp it b iu iv iw ix iy iz ja jb mq jd je jf mr jh ji jj ms jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is mp it b iu iv iw ix iy iz ja jb mq jd je jf mr jh ji jj ms jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is mp it b iu iv iw ix iy iz ja jb mq jd je jf mr jh ji jj ms jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kt ku kv kw fq mt"><div class="bz el l di"><div class="mu mv l"/></div></figure></div></div>    
</body>
</html>