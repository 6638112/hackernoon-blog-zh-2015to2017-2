<html>
<head>
<title>afl-unicorn: Part 2 — Fuzzing the ‘Unfuzzable’</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">afl-unicorn:第2部分——模糊化“不可模糊”的事物</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/afl-unicorn-part-2-fuzzing-the-unfuzzable-bea8de3540a5?source=collection_archive---------2-----------------------#2017-11-15">https://medium.com/hackernoon/afl-unicorn-part-2-fuzzing-the-unfuzzable-bea8de3540a5?source=collection_archive---------2-----------------------#2017-11-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="50af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我在<a class="ae jp" rel="noopener" href="/@njvoss299/afl-unicorn-fuzzing-arbitrary-binary-code-563ca28936bf">上一篇文章</a>中演示的独角兽模式表面上看并没有太大用处。它有很多限制，这使得它在大多数现实情况下使用起来笨拙而缓慢。例如，如果您想要模拟的二进制文件调用了一个导入的库函数，该库函数很可能会调用到内核中，比如<em class="jq"> malloc() </em>或<em class="jq"> printf() </em>，该怎么办？如果您想要模糊的代码是高度有状态的，并且需要大量内存区域(堆分配、堆栈指针、全局变量等),该怎么办？)直到运行时才知道？事实上，我发现它唯一直接的用法就是使用调试器从固件中恢复的嵌入式运行时系统内存快照。</p><p id="6580" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本文介绍了我和我的同事Parker Wiksell为了将afl-unicorn应用于Windows、Linux、Android和iOS应用程序而开发的一些新工具和技术。</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff jt"><img src="../Images/e97651fcf4fa7cdf8603d07fb4c7af1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HO32vRAAO_xOhTHYQ9aYWQ.png"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">While nothing is more thorough and applicable than manual static and dynamic analysis, afl-unicorn lets you do a little reverse engineering to get all of AFL’s benefits in places it normally can’t be used.</figcaption></figure><p id="804e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Afl-unicorn弥补了完全手动研究(即阅读反汇编/源代码)的彻底性和Afl无与伦比的易用性之间的差距。通过一点逆向工程和设置时间，afl-unicorn允许您利用afl的力量快速发现您认为可疑的代码部分中的漏洞，并对它们的作用有一个基本的了解。</p><p id="8276" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也许你会问自己，“如果我需要做一些逆向工程，为什么我要花时间让afl-unicorn启动并运行”？对我来说，这是一个简单的决定:我认为自己是一个相当不错的逆向工程师，但我不相信自己有能力发现我正在逆向处理的代码中的所有漏洞。我发现自己错过了越界内存访问、整数溢出等。在过去，所以我宁愿依靠AFL的变异引擎来为我寻找bug。此外，如果你走上手工分析的道路，你无论如何都要重新跑腿，所以花一两天时间启动afl-unicorn，然后让它在后台运行，同时你继续筛选代码，这提供了额外的低成本覆盖。</p><h1 id="c2d2" class="kj kk hu bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">一般工作流程</h1><p id="d03b" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">虽然最初的博客文章描述了afl-unicorn如何工作背后的基本机制，并提供了一个玩具示例，但本文旨在提供一种更真实的方式来使用它对抗运行在操作系统(如Windows、Linux、Android或iOS)上的应用程序。在现实中，你真的想了解afl-unicorn做什么，并使它适应你的具体问题，以确保你不会得到(或知道如何识别)假阳性和假阴性。</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div class="fe ff lm"><img src="../Images/0de0713bb679d51b6d9d055705934b7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*fLfHJM1yFGlFRr46I9jxlQ.png"/></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">*There are some special nuances to creating a Unicorn script that works with afl-unicorn. These are described in more detail below.</figcaption></figure><p id="d996" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第一个任务是逆向工程一些关于你想模糊的代码的基础知识。这包括确定一个好的起点和终点，以及代码如何接收您将要变异的输入。</p><p id="4387" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设您为网络数据包确定了一个顶级解析函数。该函数是否将数据包作为参数从网络中取出？这是如何传递到函数中的？最有可能的是，这将通过全局分配的缓冲区、堆栈上的指针或寄存器中的指针来实现。</p><p id="2b2b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您还需要(尽可能)弄清楚输入有什么约束。比如最大尺寸是多少？有没有无效字符？请确保在所选起始地址的上下文中考虑这一点，因为随着代码过滤掉无效输入并在整个输入处理过程中分配各种大小的缓冲区，这些约束可能会随着时间而改变。</p><p id="ea78" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦所有的研究都完成了，您将希望在处理有效输入的同时，在起始地址捕获流程的快照。我们通过创建一系列“Unicorn Context Dumper”脚本来实现这一点，这些脚本在位于开始地址的调试器断点处运行时，会将整个进程内存、寄存器值和架构信息保存到磁盘上的“上下文目录”中。</p><p id="f846" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在您需要编写一个Unicorn脚本，它加载您转储的流程上下文，加载要用从磁盘上的文件中读取的数据进行模糊处理的输入，并从起始地址到结束地址进行模拟。如果在仿真过程中检测到任何错误或崩溃，该脚本必须强制自身崩溃，以便AFL能够检测到它。我们已经创建了一套帮助工具，我们称之为“独角兽加载器”模块，使这些任务变得简单。“Unicorn Loader”还包括一个完整的独立堆管理器，它有助于防止模拟典型操作系统应用程序时发生的模拟错误…稍后将详细介绍。</p><p id="4bd5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦你的Unicorn test harness脚本可以成功地模拟从开始到结束的地址(并完成上面提到的所有其他事情)，是时候创建一些有效的、非崩溃的样本输入并在afl-unicorn下运行它了，如第一篇博文中所述。运气好的话，你会看到路径被发现，并希望有一些崩溃！</p><h1 id="842d" class="kj kk hu bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">一个具体的例子:CGC的FSK_Messaging_Service</h1><h2 id="7391" class="ln kk hu bd kl lo lp lq kp lr ls lt kt jc lu lv kx jg lw lx lb jk ly lz lf ma dt translated">示例目标应用程序的描述</h2><p id="dcc4" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">Trail最近发布了<a class="ae jp" href="https://github.com/trailofbits/cb-multios" rel="noopener ugc nofollow" target="_blank"> cb-multios </a>，它包含了来自DARPA的<a class="ae jp" href="https://www.darpa.mil/program/cyber-grand-challenge" rel="noopener ugc nofollow" target="_blank">网络大挑战</a>的挑战，以及额外的支持库，使它们易于在Linux上编译和运行。在这个例子中，我将演示如何使用afl-unicorn来模糊其中一个挑战的解析功能，该功能被特别设计为难以模糊，<a class="ae jp" href="https://github.com/trailofbits/cb-multios/tree/master/challenges/FSK_Messaging_Service" rel="noopener ugc nofollow" target="_blank"> FSK_Messaging_Service </a>:</p><blockquote class="mb mc md"><p id="e275" class="ir is jq it b iu iv iw ix iy iz ja jb me jd je jf mf jh ji jj mg jl jm jn jo hn dt translated">[…]一种实现分组无线电接收机的服务，包括FSK解调前端、分组解码、处理，并最终将其解析为简单的消息服务。</p></blockquote><p id="650b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">FSK_Messaging_Service challenge是专门为挑战fuzz而设计的。虽然潜在的漏洞相当简单，但在对模拟模拟RF输入进行大量解析和解调后，这些漏洞仍然存在。此外，数据本身附加了一个简单的16位校验和，在执行完整解析之前必须对其进行验证。根据对挑战的描述:</p><blockquote class="mb mc md"><p id="3be6" class="ir is jq it b iu iv iw ix iy iz ja jb me jd je jf mf jh ji jj mg jl jm jn jo hn dt translated">这个[挑战二进制]向计算机推理系统提出了许多挑战。难点在于在RF前端之后将输入集转换成处理过的数据。由于其本身的性质<strong class="it hv">模糊化将是无效的</strong>，因为射频接收器自然会受到噪声的影响，并且特别适合在存在噪声的情况下识别信号[……]因此，这种[挑战]被主观地认为是困难的，并且被设计为测试超出最先进的输入推理能力和解算器的状态。</p></blockquote><p id="554f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下图显示了FSK_Messaging_Service应用程序的整体逻辑和数据流:</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff mh"><img src="../Images/b1f01902a32be4791bd1b835a49fec61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nA2pNj6DLPhwwLSU-OYrSQ.png"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">Traditional fuzzers (AFL included) would never make it past the demodulation logic. Afl-unicorn lets you directly target the code you think is most likely to be vulnerable.</figcaption></figure><h2 id="72f8" class="ln kk hu bd kl lo lp lq kp lr ls lt kt jc lu lv kx jg lw lx lb jk ly lz lf ma dt translated">找到我们需要模拟和模糊目标代码的内容</h2><p id="81cb" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">好的。所以我们不能模糊前门接口，但是通过对代码的一点点分析(或者反汇编，如果我们没有源代码的话)很容易找到直觉告诉我们最有可能有bug的函数:<em class="jq"> cgc_receive_packet() </em>在<a class="ae jp" href="https://github.com/trailofbits/cb-multios/blob/master/challenges/FSK_Messaging_Service/src/packet.c" rel="noopener ugc nofollow" target="_blank"> packet.c </a>中找到。这个函数相当简单，它执行以下操作:</p><ul class=""><li id="7ae2" class="mi mj hu it b iu iv iy iz jc mk jg ml jk mm jo mn mo mp mq dt translated">验证数据包缓冲区不为空，并且其长度大于0</li><li id="2761" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mn mo mp mq dt translated">通过计算和比较16位CRC来验证数据包内容</li><li id="eaf2" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mn mo mp mq dt translated">循环查看数据包类型，如果匹配，调用<em class="jq"> cgc_add_new_packet() </em></li><li id="2113" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mn mo mp mq dt translated">如果找到有效的包类型，<em class="jq"> cgc_add_new_packet() </em>实例化一个<em class="jq"> tSinglePacketData </em>结构，并从包中复制信息</li></ul><p id="f567" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是一组稍微修改过的源代码片段，显示了相关部分:</p><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="mw mx l"/></div></figure><p id="a3eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然，实际上你很可能没有源代码。相反，您必须使用传统的逆向工程方法(静态和动态分析)来了解关于目标应用程序的所有必要信息。</p><p id="dc40" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们有了模糊目标，也知道了输入是如何给出的:</p><ul class=""><li id="06cf" class="mi mj hu it b iu iv iy iz jc mk jg ml jk mm jo mn mo mp mq dt translated">我们希望模糊来自<em class="jq"> cgc_receive_packet() </em>函数</li><li id="5924" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mn mo mp mq dt translated">输入以3个参数的形式传递给函数:指向包数据的指针(<em class="jq"> uint8_t *pData </em>)、相应的长度(<em class="jq"> uint8_t dataLen </em>)和数据的校验和(<em class="jq"> uint16_t packetCRC </em>)</li></ul><p id="0c1f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还知道对输入的一个简单约束:</p><ul class=""><li id="ea95" class="mi mj hu it b iu iv iy iz jc mk jg ml jk mm jo mn mo mp mq dt translated">最大数据长度为256字节，因为<em class="jq"> dataLen </em>是一个8位值</li></ul><h2 id="8e0e" class="ln kk hu bd kl lo lp lq kp lr ls lt kt jc lu lv kx jg lw lx lb jk ly lz lf ma dt translated">转储有效的运行进程上下文</h2><p id="4782" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">现在我们想要得到整个进程内存的快照，因为这个函数被调用以使模拟尽可能简单。与更简单的方法(如由<a class="ae jp" href="https://github.com/pbiernat/ripr" rel="noopener ugc nofollow" target="_blank"> ripr </a>或<a class="ae jp" href="https://github.com/alexhude/uEmu" rel="noopener ugc nofollow" target="_blank"> uEmu </a>提供的就地仿真)相比，这似乎是一种高压手段，它解决了大量问题。例如，全局列表<em class="jq"> cgc_g_packetHandlers </em>是在运行时填充的，因此除非我们有其内存位置的运行时状态，否则迭代<em class="jq"> cgc_packet_receive() </em>中处理程序的For循环将在仿真期间失败。</p><p id="bbf2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用“Unicorn Context Dumper”脚本来转储整个进程的内存状态和寄存器上下文。我们已经创建了几个不同的版本来支持不同的调试器，包括IDA Pro(目前在版本7之前)、LLDB和GDB与GEF。目前只有<a class="ae jp" href="https://github.com/njv299/afl-unicorn/blob/master/unicorn_mode/helper_scripts/unicorn_dumper_ida.py" rel="noopener ugc nofollow" target="_blank"> IDA版本可用</a>，但是其他版本(以及为其他调试器创建的其他版本)一旦准备好就会被推送到GitHub。只需将IDA Pro的调试器附加到一个正在运行的FSK_Message_Service进程上，在fuzzing起始地址打一个断点，通过IDA(<em class="jq">File-&gt;Script File…</em>)运行脚本。注意，我只在IDA的内置远程调试服务器上测试过。附加到其他调试器可能会以不同的方式呈现内存段，这可能会导致错误。</p><p id="0dc6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我选择在调用<em class="jq"> cgc_packet_receive() </em>之前设置我的起始地址，在这个位置，参数方便地全部在寄存器中，而不是在堆栈中。这使得在我的Unicorn仿真脚本中修改它们变得更加容易。</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div class="fe ff my"><img src="../Images/19c3e5c1d59bcfe0580324b2c35bd294.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*_nILRn-9zKrJ4SdOuwFUAw.png"/></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">Context is dumped just before the call to <em class="mz">cgc_receive_packet(). The input parameters (*pData and dataLen) are sitting in registers that are easy to change here instead of on the stack.</em></figcaption></figure><p id="ef39" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦脚本完成，它将在IDA数据库所在的文件夹中生成一个“Unicorn Context”目录。idb)。这个目录包含两个内容:</p><ul class=""><li id="05e8" class="mi mj hu it b iu iv iy iz jc mk jg ml jk mm jo mn mo mp mq dt translated"><em class="jq">_ index . JSON</em>:JSON格式的文件，包含关于进程中所有内存段的元数据、寄存器状态和架构信息</li><li id="bc8f" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mn mo mp mq dt translated">大量gzip压缩的二进制文件，包含进程中每个内存段的内容</li></ul><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff na"><img src="../Images/b2e20984b36243106bf22903808ef0ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tUYpCVZhTSPQFa3LHZ2gQg.png"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">Contents of a typical ‘Unicorn Context’ directory created by one of the Unicorn Context Dumper tools</figcaption></figure><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div class="fe ff nb"><img src="../Images/141edfdda67931c8d9f8d4ffaf74d7e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*go21Y2JJeL24dmmD_60H9A.png"/></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">The _index.json file contains metadata for all memory segments, register context, and architecture information</figcaption></figure><h2 id="7528" class="ln kk hu bd kl lo lp lq kp lr ls lt kt jc lu lv kx jg lw lx lb jk ly lz lf ma dt translated">创建一个模糊的Unicorn测试工具</h2><p id="9281" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">现在我们有了一个开始仿真的起始上下文，我们编写一个Unicorn脚本来加载上下文(映射所有内存区域，将内容加载到其中，并设置寄存器内容)，挂接任何会中断仿真或会妨碍模糊化的内容(<em class="jq">【malloc()</em>，<em class="jq">【free()</em>)，校验和验证，等等。)，将一个新的包嵌入到适当的位置，并从头到尾模拟代码。我已经创建了一个<a class="ae jp" href="https://github.com/njv299/afl-unicorn/blob/master/unicorn_mode/helper_scripts/template_test_harness.py" rel="noopener ugc nofollow" target="_blank">裸机模板</a>作为测试工具的例子。</p><p id="3339" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">快进一点，下面显示的是完整的Unicorn脚本，它可以模拟FSK_Message_Service应用程序的应用层数据包解析，从Unicorn上下文转储器生成的上下文目录加载的初始状态开始。这个脚本非常依赖于从afl-unicorn提供的<a class="ae jp" href="https://github.com/njv299/afl-unicorn/blob/master/unicorn_mode/helper_scripts/unicorn_loader.py" rel="noopener ugc nofollow" target="_blank"><em class="jq">unicorn _ loader . py</em></a>模块导入的功能。我们将在下面讨论一些更有趣的内容，但大部分内容都遵循了我在之前的博文中讨论的基本步骤。</p><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="mw mx l"/></div></figure><p id="5ec0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个脚本有一些独特的部分，使得仿真和模糊成为可能。下面详细描述了每种方法:</p><p id="78f2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="jq">从转储上下文中实例化Unicorn引擎实例:</em></strong><a class="ae jp" href="https://github.com/njv299/afl-unicorn/blob/master/unicorn_mode/helper_scripts/unicorn_loader.py" rel="noopener ugc nofollow" target="_blank"><em class="jq">Unicorn _ loader . py</em></a>模块提供了一个新的<em class="jq">afunicornegine</em>类，该类派生自普通的<em class="jq">unicornegine</em>。构造函数有3个参数:上下文目录的路径、在STDOUT上启用跟踪输出的标志和在将上下文加载到STDOUT时启用调试输出的标志。</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div class="fe ff nc"><img src="../Images/4e2e4ead224340182b0c03613091e947.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*RnRekLlTcpLFYq1AhwWfVQ.png"/></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">Once instantiated from a context directory, the AflUnicornEngine has all process memory mapped, register values initialized, and is ready to emulate from the instruction pointer</figcaption></figure><p id="a8d7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">AflUnicornEngine类还提供了一些额外的API，这些API在模糊测试工具中很有用:</p><ul class=""><li id="a0d0" class="mi mj hu it b iu iv iy iz jc mk jg ml jk mm jo mn mo mp mq dt translated"><em class="jq"> dump_regs() </em>:将当前寄存器内容转储到标准输出</li><li id="77c2" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mn mo mp mq dt translated"><em class="jq"> force_crash(e) </em>:通过发出信号(SIGILL，SIGSEGV，SIGABRT等)强制测试线束崩溃。).这让我们AFL检测到崩溃的发生并适当地记录日志。如果发生崩溃情况(比如<em class="jq"> emu_start() </em>抛出异常)，你必须调用这个函数！</li></ul><p id="eae5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为这个类是从基类<em class="jq"> UnicornEngine </em>派生的，所以您仍然可以使用所有普通的调用，比如<em class="jq"> emu_start() </em>、<em class="jq"> reg_read() </em>和<em class="jq"> mem_write() </em>。要查看在<em class="jq">afunicornegine</em>类上可用的所有API，请通读unicorn_loader模块的<a class="ae jp" href="https://github.com/njv299/afl-unicorn/blob/master/unicorn_mode/helper_scripts/unicorn_loader.py" rel="noopener ugc nofollow" target="_blank">源代码</a>。</p><p id="a08f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="jq">挂钩所有堆分配(</em> malloc() <em class="jq"> ): </em> </strong>在仿真过程中调用<em class="jq"> malloc() </em>会导致各种各样的问题。有可能分配器需要向内核请求更多的内存，但是在仿真期间，我们没有内核这样的东西…所以那会导致崩溃。为了防止这种情况，Unicorn脚本将任何对<em class="jq"> malloc() </em>的调用挂钩，转而调用一个基于Unicorn的实现，该实现由<em class="jq"> unicorn_loader.py </em>模块中的afl-unicorn提供。下面的代码片段显示了用于FSK_Messaging_Service二进制文件的代码，这是一个32位的Linux二进制文件。</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff nd"><img src="../Images/41c1d6e92ab09edf43f8b8574563dc5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YjxSZUfxmWYF50e-2iTCNQ.png"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">Calls to malloc() are redirected to our own internal, page-guarded, Unicorn-based implementation</figcaption></figure><p id="03d1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在第45行，从堆栈中检索字节数。第46行调用内部的基于Unicorn的实现。第47行将返回值(分配的缓冲区地址)放入EAX，第48和49行通过将EIP设置为返回地址，然后从堆栈中弹出返回地址，手动执行“返回”。所有这些都符合典型的<a class="ae jp" href="https://en.wikipedia.org/wiki/X86_calling_conventions" rel="noopener ugc nofollow" target="_blank"> x86调用约定</a>。当将这种方法应用于您自己的二进制文件时，请确保您遵循了您给定的操作系统和架构的调用约定！</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff ne"><img src="../Images/d9d205d64a662535139051aa57f83b43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GnlMziIIxEZ7Zo0zH-JNuQ.png"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">All buffers allocated by the Unicorn-based heap implementation are automatically surrounded by guard pages that will force crashes on any under/overflow</figcaption></figure><p id="38ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">自己处理内存分配的另一个主要好处是，我们可以实现自己的基本<a class="ae jp" href="https://www.us-cert.gov/bsi/articles/knowledge/coding-practices/guard-pages" rel="noopener ugc nofollow" target="_blank">保护页</a>。基本上，所有分配的缓冲区都被没有读或写权限的“保护页”所包围。任何超出返回缓冲区边界的访问(也称为堆溢出或下溢)都会立即崩溃，并出现内存访问冲突。</p><p id="78fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意，<em class="jq">UnicornSimpleHeap . py</em>模块中的<em class="jq"> UnicornSimpleHeap </em>类也提供了<em class="jq"> free()、calloc()、</em>和<em class="jq"> realloc() </em>功能，但是为了简单起见，我在本例中只选择了挂钩<em class="jq"> malloc() </em>。为了模拟更大、运行时间更长、更复杂的代码，您可能希望或需要挂接所有与堆相关的函数。</p><p id="57b9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="jq">跳过不必要的、难以仿真的函数:</em> </strong>还有很多其他的事情显然会引起问题。<em class="jq">例如，Printf() </em>肯定会调用内核，以便将要打印的文本发送到图形设备进行渲染。您将希望分析您试图模拟的代码，并努力识别您认为可能会破坏模拟的任何内容。在这个例子中，我已经确定<em class="jq"> free() </em>、<em class="jq"> printf() </em>和<em class="jq"> cgc_transmit() </em>会因为各种原因导致仿真失败，而且我也可以跳过它们，不会对模糊结果产生任何重大影响。通过强制立即返回来跳过所有这些函数。这与上面描述的<em class="jq"> malloc() </em>钩子的最后一部分是相同的:手动将EIP设置为堆栈中存储的返回地址，然后通过将ESP加4将返回地址弹出堆栈。请记住，这个确切的过程是特定于x86的，因此根据您的目标体系结构进行必要的调整。</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff fg"><img src="../Images/4826b0880934e71ae2262b5befe9e217.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k_2GiicdU0snO4fnBopK2Q.png"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">Problematic functions are immediately returned from when called. Make sure there aren’t unintended consequences to doing this!</figcaption></figure><p id="c750" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="jq">绕过校验和验证:</em> </strong>每个接收到的数据包都带有一个16位的CRC，在验证数据包之前必须对其进行验证(请参考本文前面源代码片段中的第27–31行)。仅这一点就对传统的模糊化提出了重大挑战，因为任何盲目修改数据包的尝试都将导致CRC校验失败，并且几乎没有代码覆盖。这种类型的问题是众所周知的，但传统上它需要修补目标二进制文件或开发来为每个输入正确地生成有效的校验和。</p><p id="c663" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Afl-unicorn使得绕过这一点变得相当简单。对于本例，校验和验证在IDA中非常容易识别:</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff nf"><img src="../Images/b9d976db0fe6e2bfbcc9fe6ae3b23d01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1eoottp7pWUVYYSB25qVjA.png"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">We want to make sure that when emulation fuzzing we always go down the path to the left</figcaption></figure><p id="c76e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们简单地将调用挂接到<em class="jq">cgc _ simple _ checksum 16()</em>，每当执行到达那里时，EIP被手动设置为“CRC校验通过”路径:</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div class="fe ff ng"><img src="../Images/d1b3d88db1659505a4f69efa8fd2f185.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*acJk8yDBgsQmrJz4N7xVSA.png"/></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">Bypassing the CRC check is really simple with Unicorn</figcaption></figure><p id="90ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这并不妨碍我们为了开发一个完整的工作漏洞而不得不在以后找出如何计算CRC，但是它让我们将这项工作向前推进，而不是首先专注于发现漏洞。</p><p id="770f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="jq">在加载变异的输入之前仿真一条指令:</em> </strong>这是最奇怪的部分，它实际上只是我如何将AFL植入Unicorn的一个工件，因为我<a class="ae jp" href="https://github.com/njv299/afl-unicorn/issues/3" rel="noopener ugc nofollow" target="_blank">还没有想出真正内部问题的解决方案</a>:为了确保AFL的forkserver在正确的时间启动，在从磁盘加载变异的输入之前，你必须仿真至少一条指令。如果不这样做，那么AFL创建的每一个fork都将使用相同的输入来执行。在示例脚本中，这在第82行和第87行之间完成:</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div class="fe ff nh"><img src="../Images/33492306c4485824d31d4eebda9eb81f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*QThrKsTRvST5j0GAsYt7ew.png"/></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">Yep, this is a hack…just accept it for now, and hopefully it will be fixed in the near future</figcaption></figure><p id="4821" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以基本上，在加载变异输入之前，您只需要在测试工具中的某个地方放上这段代码。不过，有一个细微差别:你需要问问自己，重新执行第一条指令是否会有任何负面后果。在这个例子中，执行的第一条指令是无害的“mov [esp]，ecx”，所以重新执行它不会有任何负面影响。如果您不想或负担不起重新执行第一条指令，只需在第二次启动仿真时适当调整起始地址(<em class="jq"> uc.emu_start() </em>)。</p><h2 id="4690" class="ln kk hu bd kl lo lp lq kp lr ls lt kt jc lu lv kx jg lw lx lb jk ly lz lf ma dt translated">用afl-unicorn对仿真二进制进行模糊处理</h2><p id="c875" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">随着独角兽线束完成，唯一要做的事情就是在afl-unicorn下运行它，并希望它能找到一些崩溃。关于如何运行afl-unicorn的详细说明，请务必阅读我之前的博客文章，但是对于这个特定的实例，我们只运行典型的afl-unicorn命令行:</p><pre class="ju jv jw jx fq ni nj nk nl aw nm dt"><span id="dde0" class="ln kk hu nj b fv nn no l np nq">afl-fuzz -U -m none -i /path/to/inputs/ -o /path/to/results/ -- python fsk_message_service_test_harness.py /path/to/context_dir/ @@</span></pre><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff nr"><img src="../Images/5b024327c2fa858c55263a0a07f18c9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HgY8NW9M0Lg0QWq9dPXhRg.png"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">A crash is found in just a few seconds!</figcaption></figure><p id="d7eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">果然，它在挑战的<a class="ae jp" href="https://github.com/trailofbits/cb-multios/blob/master/challenges/FSK_Messaging_Service/README.md" rel="noopener ugc nofollow" target="_blank">自述</a>中描述的<em class="jq"> cgc_packet_receive() </em>函数中发现了漏洞:</p><blockquote class="mb mc md"><p id="f4c3" class="ir is jq it b iu iv iw ix iy iz ja jb me jd je jf mf jh ji jj mg jl jm jn jo hn dt translated">在接收到超过64字节最大分组大小的分组时，对新分配的分组结构的memcpy进行不正确的长度检查。这允许在堆上发生内存覆盖。该数据结构具有指向分组处理器的函数指针，该指针可以被重写，并且一旦服务执行该函数指针，就有机会通过重写该函数指针来执行控制流。</p></blockquote><p id="f167" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从转储崩溃的输入文件可以明显看出，对于在<em class="jq"> tSinglePacketData </em>结构中分配的<em class="jq"> packetData </em>缓冲区来说，数据包太大(&gt; 48字节):</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff ns"><img src="../Images/ed783e8f594aab61daa310e20cd81746.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j6cCxYJQYpkOJsj6AEsLYw.png"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">The crashing packet is larger than 48 bytes (the size of the buffer that the packet data is copied into during parsing)</figcaption></figure><p id="5a08" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，我们可以通过运行带有崩溃输入的Unicorn脚本来验证这一点:</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff nt"><img src="../Images/792ad2f0197a39d6417f9036b2cd4128.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*glbsW2gFT7QDNrenVaDkaw.png"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">Run the crashing input through the Unicorn script to verify it and debug it more thoroughly</figcaption></figure><p id="2993" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下一步是弄清楚如何将这个崩溃输入发送到实际的(非仿真的)应用程序中，并证明这是一个真实的、有效的崩溃，并且不是由仿真错误引起的。</p><h2 id="1da3" class="ln kk hu bd kl lo lp lq kp lr ls lt kt jc lu lv kx jg lw lx lb jk ly lz lf ma dt translated">调试基于仿真的模糊问题</h2><p id="a7d9" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">我遇到的一些常见问题包括:</p><ul class=""><li id="7147" class="mi mj hu it b iu iv iy iz jc mk jg ml jk mm jo mn mo mp mq dt translated"><em class="jq">没有发现路径</em>:确保在加载变异输入之前至少仿真了一条指令。如果不这样做，每个分支都会得到相同的不变输入。在afl-unicorn外部运行您的测试工具，并确保它从开始到结束地址没有任何问题。如果这不能解决问题，请确保变异的输入被正确地写入仿真内存和寄存器上下文。</li><li id="379b" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mn mo mp mq dt translated"><em class="jq">太多的崩溃被发现</em>:要么你发现了一些真正有问题的代码(头奖！)，或者有仿真问题。遵循仿真调试跟踪输出，并寻找中断仿真的东西，例如基于段寄存器的解引用、内核中的系统调用或动态模块加载。</li></ul><p id="6300" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果情况看起来不错(新的路径被发现得相当有规律)，那么其他一切都遵循典型的AFL使用模式。确保您的样本输入很好地覆盖了目标代码，并模糊了您的核心内容。</p><h1 id="c16f" class="kj kk hu bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">我们在哪里，我们要去哪里</h1><p id="efc5" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">在这篇文章中，我展示了一个例子，说明我们如何使用afl-unicorn来模糊现实世界应用程序中难以触及的接口。我们发现这种方法在Windows、Linux、Android和iOS应用程序上非常有效，我认为它可以很容易地移植到嵌入式系统上。</p><p id="2880" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">未完成的任务主要是继续使用使这种方法可用的脚本，并将它们扩展到其他操作系统和体系结构。例如，模拟Windows应用程序会引入一长串问题，因为对PEB和TIB的引用会因为对GS段寄存器的引用而导致错误的崩溃。可以创建特定于操作系统的实用程序(以类似于已经在<em class="jq">UnicornSimpleHeap模块中的UnicornSimpleHeap类的方式)来用最少的工具处理这些已知的情况。这将非常类似于<a class="ae jp" href="https://github.com/lunixbochs/usercorn" rel="noopener ugc nofollow" target="_blank"> usercorn </a>项目所采取的路线。此外,<a class="ae jp" href="https://github.com/pbiernat/ripr" rel="noopener ugc nofollow" target="_blank"> ripr </a>项目非常有趣，我相信他们的代码生成方法很有可能被修改或扩展，以生成一个非常容易模糊化的模板测试工具。</em></p><p id="2bd8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在以后的博客文章中，我计划针对从嵌入式系统中检索的平面运行时内存映像演示使用afl-unicorn。该用例是创建afl-unicorn的原始灵感，我仍然相信它是理想的环境，因为它避免了在更复杂的多线程操作系统中模拟用户应用程序时引入的大多数问题。</p><h1 id="b5cb" class="kj kk hu bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">信用</h1><p id="a038" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">我与俄亥俄州哥伦布市<a class="ae jp" href="https://www.battelle.org/cyber" rel="noopener ugc nofollow" target="_blank">巴特尔</a>的<a class="jr js gr" href="https://medium.com/u/e5fb3c97cd06?source=post_page-----bea8de3540a5--------------------------------" rel="noopener" target="_blank">帕克·维克塞尔</a>合作开发了afl-unicorn和<a class="ae jp" href="https://hackernoon.com/tagged/methodology" rel="noopener ugc nofollow" target="_blank">方法论</a>，此处描述为内部研究项目。巴特尔是一个令人敬畏的工作场所，afl-unicorn只是那里正在进行的新颖网络安全研究的众多例子之一。对于更多巴特尔赞助的项目，请查看<a class="ae jp" href="https://github.com/xoreaxeaxeax" rel="noopener ugc nofollow" target="_blank">克里斯·多马斯</a>和<a class="ae jp" href="https://github.com/cetfor" rel="noopener ugc nofollow" target="_blank">约翰·托特希</a>(又名<a class="jr js gr" href="https://medium.com/u/d9f348e2859b?source=post_page-----bea8de3540a5--------------------------------" rel="noopener" target="_blank"> cetfor </a>)之前的工作。有关巴特尔职业的信息，请查看他们的<a class="ae jp" href="https://www.battelle.org/cyber-careers" rel="noopener ugc nofollow" target="_blank">职业页面</a>。</p><p id="31f2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然，如果没有AFL的<a class="ae jp" href="http://lcamtuf.coredump.cx/afl/" rel="noopener ugc nofollow" target="_blank">和独角兽引擎的</a>和<a class="ae jp" href="http://www.unicorn-engine.org/" rel="noopener ugc nofollow" target="_blank">这一切都是不可能的。许多额外的灵感来自亚历克斯·胡德为IDA开发的令人敬畏的uEmu </a>插件，许多通用概念借鉴自NCC集团的AFLTriforce 项目。许多额外的灵感来自于usercorn项目，因为它证明了Unicorn可以成功地运行用户空间应用程序。</p><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="nu mx l"/></div></figure></div></div>    
</body>
</html>