<html>
<head>
<title>Detox: Gray Box End to End Testing Framework for Mobile Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">排毒:灰盒端到端移动应用测试框架</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/detox-gray-box-end-to-end-testing-framework-for-mobile-apps-196ccd9564ce?source=collection_archive---------1-----------------------#2017-09-10">https://medium.com/hackernoon/detox-gray-box-end-to-end-testing-framework-for-mobile-apps-196ccd9564ce?source=collection_archive---------1-----------------------#2017-09-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/5d85cecac3fae11581e5708a770de1b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jp0C86r59ZCqonG2VRYLiQ.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Detox from sleep(); Photo by <a class="ae jg" href="https://unsplash.com/photos/JYFmYif4n70?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Dominik Martin</a> on <a class="ae jg" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="jh"><p id="e676" class="ji jj hu bd jk jl jm jn jo jp jq jr ek translated">端到端测试位于测试金字塔的顶端，他们应该给<strong class="ak">被测系统工作的最大信心，但是在大多数端到端测试框架中，我们发现自己在与“不可靠”的测试作斗争，并最终不信任测试套件。我们希望通过排毒来改变这种情况。</strong></p></blockquote><h1 id="9cbc" class="js jt hu bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dt translated">开始</h1><p id="f057" class="pw-post-body-paragraph kq kr hu ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm jr hn dt translated">我们的故事从<a class="ae jg" href="https://itunes.apple.com/us/app/wix-com/id1099748482?mt=8" rel="noopener ugc nofollow" target="_blank"> Wix应用</a>开始——我们官方的原生iOS/Android应用</p><ul class=""><li id="c708" class="ln lo hu ks b kt lp kx lq lb lr lf ls lj lt jr lu lv lw lx dt translated">它是用React Native从头开始写的</li><li id="6d42" class="ln lo hu ks b kt ly kx lz lb ma lf mb lj mc jr lu lv lw lx dt translated">大约18个月前(2016年3月)开始着手这项工作</li></ul><p id="7622" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated">就工程工作而言:</p><ul class=""><li id="45c5" class="ln lo hu ks b kt lp kx lq lb lr lf ls lj lt jr lu lv lw lx dt translated">该应用程序是一个跨公司的努力，它目前合并了来自6个不同产品组的代码。</li><li id="80d7" class="ln lo hu ks b kt ly kx lz lb ma lf mb lj mc jr lu lv lw lx dt translated">目前有40名开发人员在这个项目上工作，或者用infra工具提供支持。</li><li id="e58a" class="ln lo hu ks b kt ly kx lz lb ma lf mb lj mc jr lu lv lw lx dt translated">大部分代码是用JavaScript编写的</li></ul><p id="3db0" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated">有了Google Play和Apple App Store作为我们的分发手段，我们的发布本质上就不是持续部署。所以我们有发布列车(每周2个站台)。但是发行机制并不是我们不做真CD的真正原因。</p><h2 id="6f34" class="mg jt hu bd ju mh mi mj jy mk ml mm kc lb mn mo kg lf mp mq kk lj mr ms ko mt dt translated">我们依赖手工测试，很多！</h2><ol class=""><li id="fb42" class="ln lo hu ks b kt ku kx ky lb mu lf mv lj mw jr mx lv lw lx dt translated">目前，完整的回归QA测试套件包含300个测试，需要14个人-天来运行，由于它太大，我们无法在下一个版本中按时完成测试，所以我们只测试其中的~70个，这也需要很长时间，一个设备需要3个人-天。</li><li id="7141" class="ln lo hu ks b kt ly kx lz lb ma lf mb lj mc jr mx lv lw lx dt translated">事实上，如果我们在两个平台上运行整个套件，并且每个平台上只有两个操作系统版本，那么我们最终将需要56 (2个平台x 2个操作系统版本x 14)个人-天来完成全面回归。但是情况变得更糟了。</li></ol><figure class="mz na nb nc fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff my"><img src="../Images/345177cadaadc2ef1cc146a449003d1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ijxJ150JX1ObAIcmeFec6w.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">This ice cream cone is a software testing anti-pattern.</figcaption></figure><h2 id="b7ef" class="mg jt hu bd ju mh mi mj jy mk ml mm kc lb mn mo kg lf mp mq kk lj mr ms ko mt dt translated">QA不可扩展</h2><ol class=""><li id="c81b" class="ln lo hu ks b kt ku kx ky lb mu lf mv lj mw jr mx lv lw lx dt translated">QA测试套件总是会增长，这意味着即使开发以同样的速度继续，QA也会在每个版本上有额外的工作，所以我们要么需要雇佣更多的QA，要么放弃一些测试。</li><li id="ee44" class="ln lo hu ks b kt ly kx lz lb ma lf mb lj mc jr mx lv lw lx dt translated">Wix的移动开发每季度增长约25%,而且速度还在不断加快。</li></ol><p id="a137" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated">让我们举一个简单的例子，如果开发以每周2个特性或bug修复的速度进行，那么QA每周将有<strong class="ks hv">两个额外的测试</strong>，这意味着在第1周他们将有2个测试，在第7周套件将会大7倍。</p><p id="5884" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated">向组合中添加一个不断增长的产品，这需要雇用更多的开发人员并提高开发过程的速度，QA测试套件就像爆炸一样…更高的特性速度意味着QA回归套件增长得更快。</p><figure class="mz na nb nc fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nd"><img src="../Images/62e35778ea9aaded9ab9879508bf4b6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CPJgOY6bHfSTQ3wgEhITfw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">The graph on the bottom shows the number of new developed features every week, the graph on the top shows the number tests in a QA test suite.</figcaption></figure><h1 id="1131" class="js jt hu bd ju jv jw jx jy jz ka kb kc kd ne kf kg kh nf kj kk kl ng kn ko kp dt translated">自动化测试是未来的趋势！</h1><p id="f11d" class="pw-post-body-paragraph kq kr hu ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm jr hn dt translated">不过这并不新鲜…</p><p id="9d6f" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated">我们不想雇佣一大群人来做人工QA，我们想要自动化测试，在CI上运行现代化的连续工作流，有非常短的开发反馈循环，如果所有测试都是绿色的，我们就有信心发布新版本。</p><p id="77d3" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated">这是测试金字塔，因为你已经知道了为什么测试如此重要，并且理解了不同类型的测试，我们将关注如何测试每一种类型，而不是解释它们是什么。<br/>让我们把E2E分成两部分，纯UI自动化(意思是，不测试外部服务)，和完全E2E，用真实的服务器数据模拟一个用户。这些必须在设备或模拟器上运行。</p><figure class="mz na nb nc fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nh"><img src="../Images/b89aff521ad3fc9f9d441ca0ce4bb067.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n0TzzBmWXap9Qp7JyVBFSw.png"/></div></div></figure><p id="210c" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated">让我们把重点放在移动开发上，具体反应原生。</p><p id="32c3" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated">我们知道怎么做？</p><ul class=""><li id="8f93" class="ln lo hu ks b kt lp kx lq lb lr lf ls lj lt jr lu lv lw lx dt translated"><strong class="ks hv">单元测试</strong> <br/>业务逻辑大多在JS中，用Jest很容易在节点上测试。<br/> React Native和React一样，使用Flux架构来控制app数据流。最流行的Flux实现之一是Redux，我们在应用程序中广泛使用它。尽管redux广受欢迎，但我们从来没有对Redux应用程序进行过单元测试，所以我们开发了测试Redux应用程序的方法和测试工具包，查看<a class="ae jg" href="https://github.com/wix/redux-testkit" rel="noopener ugc nofollow" target="_blank"> redux-testkit </a>了解更多信息。<br/>另一个流行的flux实现是<a class="ae jg" href="https://mobx.js.org/" rel="noopener ugc nofollow" target="_blank"> Mobx </a>，它比Redux更加独立，并且具有强大的测试能力。我们创造了一种自以为是的风格，让我们的工程师更容易理解。R <a class="ae jg" href="https://github.com/wix/remx" rel="noopener ugc nofollow" target="_blank"> emx </a>可以很容易地测试，单元测试可以是普通的JavaScript，完全不知道底层的实现，我们将在不久的将来添加更多关于Remx的信息。</li><li id="abfb" class="ln lo hu ks b kt ly kx lz lb ma lf mb lj mc jr lu lv lw lx dt translated"><strong class="ks hv">组件测试<br/> </strong>也在node上运行，我们依靠Airbnb的<a class="ae jg" href="https://github.com/airbnb/enzyme" rel="noopener ugc nofollow" target="_blank"> Enzyme </a>，使用<a class="ae jg" href="https://github.com/wix/enzyme-drivers" rel="noopener ugc nofollow" target="_blank"> Enzyme Drivers </a>帮助嘲讽。</li><li id="9620" class="ln lo hu ks b kt ly kx lz lb ma lf mb lj mc jr lu lv lw lx dt translated">UI自动化/端到端<br/> 但是端到端测试怎么办呢？这些测试给人最大的信心，因为它们相当于一个在设备上运行你的应用程序的机器人。维护一个端到端的测试套件很难，而且不如其他的测试套件可靠。但是为什么呢？</li></ul><h2 id="ee54" class="mg jt hu bd ju mh mi mj jy mk ml mm kc lb mn mo kg lf mp mq kk lj mr ms ko mt dt translated">片状</h2><p id="62f3" class="pw-post-body-paragraph kq kr hu ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm jr hn dt translated">E2E测试通常被认为是不可靠的，在所有平台上，web，iOS，Android。</p><ul class=""><li id="9670" class="ln lo hu ks b kt lp kx lq lb lr lf ls lj lt jr lu lv lw lx dt translated">测试可能没有明显的原因就失败了，即使没有代码更改。</li><li id="3620" class="ln lo hu ks b kt ly kx lz lb ma lf mb lj mc jr lu lv lw lx dt translated">测试是不确定的，应用程序中有许多移动的部分，它们可能在不同的运行中以不同的顺序完成执行。</li><li id="808f" class="ln lo hu ks b kt ly kx lz lb ma lf mb lj mc jr lu lv lw lx dt translated">我们不能真正确定应用程序何时空闲，因为不清楚应用程序何时完成处理用户交互。</li><li id="51eb" class="ln lo hu ks b kt ly kx lz lb ma lf mb lj mc jr lu lv lw lx dt translated">E2E框架的用户经常不得不手动处理同步，<strong class="ks hv">所以他们发现自己在关键位置添加了多个sleeps，只是为了让测试通过</strong>。</li></ul><h2 id="f2ab" class="mg jt hu bd ju mh mi mj jy mk ml mm kc lb mn mo kg lf mp mq kk lj mr ms ko mt dt translated"><strong class="ak">手动同步</strong></h2><p id="f415" class="pw-post-body-paragraph kq kr hu ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm jr hn dt translated">手动同步被如此普遍地使用，以至于我们将它合并到我们的测试框架基础设施中，API调用充满了包含<code class="eh ni nj nk nl b">sleep()</code>函数的循环。<br/>这是我从<a class="nm nn gr" href="https://medium.com/u/e45d45638b1d?source=post_page-----196ccd9564ce--------------------------------" rel="noopener" target="_blank"> Aaron Greenwald </a>在React Amsterdam 的<a class="ae jg" href="https://www.youtube.com/watch?v=cUSUJXAvt6k" rel="noopener ugc nofollow" target="_blank">演讲中截取的一个例子，这是我们在之前的测试框架中用来测试React原生应用的一段实际代码。</a></p><figure class="mz na nb nc fq iv"><div class="bz el l di"><div class="no np l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">sleep(a_lot);</figcaption></figure><h2 id="a8c1" class="mg jt hu bd ju mh mi mj jy mk ml mm kc lb mn mo kg lf mp mq kk lj mr ms ko mt dt translated">片状测试套件有多不可靠？</h2><p id="6c75" class="pw-post-body-paragraph kq kr hu ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm jr hn dt translated">为了理解问题有多严重，让我们来计算一个测试套件失败的概率。</p><figure class="mz na nb nc fq iv fe ff paragraph-image"><div class="fe ff nq"><img src="../Images/bb4c14988e627375a829edcb56ebb367.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/0*TS-Cqtu1Tqe8Vr9L."/></div></figure><p id="93eb" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated"><strong class="ks hv">问:</strong>测试失败的概率<br/> <strong class="ks hv"> n: </strong>测试次数</p><p id="49ab" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated"><strong class="ks hv"><em class="nr">1-q</em></strong><em class="nr"/>是成功的概率。<br/> <strong class="ks hv"> <em class="nr"> (1-q)^n </em> </strong>是整个套件成功的概率。<br/><strong class="ks hv"><em class="nr">1-(1-q)^n</em></strong><em class="nr"/>是至少一个测试失败的概率。</p><p id="52de" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated">如果测试有0.5%的几率不稳定:</p><figure class="mz na nb nc fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ns"><img src="../Images/5912f89b372032db4c6428f2e4cba5d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WojoUKKSbyzt6nF6."/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">And we have 20 tests</figcaption></figure><figure class="mz na nb nc fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ns"><img src="../Images/036a8531a8629ba8e4e8df50072f3a77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ku6cYtdDEo7CKcMb."/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">50 tests</figcaption></figure><figure class="mz na nb nc fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ns"><img src="../Images/4c0e1c2cf02a54b4dcd65690cbfe5cb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AycKtka6fHnCMWq3."/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">100 tests</figcaption></figure><p id="b047" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated">你说到点子上了，很不靠谱…</p><h1 id="539e" class="js jt hu bd ju jv jw jx jy jz ka kb kc kd ne kf kg kh nf kj kk kl ng kn ko kp dt translated">过去的经验</h1><p id="1743" class="pw-post-body-paragraph kq kr hu ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm jr hn dt translated">所以，这是一个复杂的问题…而且我们在过去已经有了一些框架的经验。</p><p id="5276" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated"><a class="ae jg" href="https://github.com/appium/appium" rel="noopener ugc nofollow" target="_blank"> <strong class="ks hv"> Appium </strong> </a> <br/>最流行的解决方案是业界事实上的标准。我们还检查了其他拥有移动产品的公司在端到端测试方面的做法，发现许多公司甚至没有自动化，而那些有自动化的公司则使用Appium。Appium的内部驱动程序是使用Instruments (iOS)和UIAutomator (Android)实现的，它们本质上是与设备交互的外部方式，就像用户一样。</p><p id="7070" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated">我们一般使用Appium年，使用React Native 8个月，发现我们花在编写测试和抚摸系统上的时间比实际编写特性的时间还多。</p><p id="6b74" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated">我们发现端到端测试非常困难:</p><p id="03d6" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated">测试是易变的，我们在不同的机器上得到不同的结果，CI经常失败，唯一的解决方法是增加睡眠，这减慢了测试速度。</p><p id="265c" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated">测试已经很慢了，因为苹果UIAutomation工具被限制为每秒执行一个动作，有一个黑客可以毫不延迟地删除这个cap <strong class="ks hv">工具(已经没有维护)，</strong>所以每次发布新Xcode后，我们都必须等待补丁才能升级。</p><p id="aecc" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated"><a class="ae jg" href="https://github.com/MagnetoTesting/magneto" rel="noopener ugc nofollow" target="_blank"> <strong class="ks hv">万磁王</strong> </a> <strong class="ks hv"> <br/> </strong>还有一点值得注意的是<strong class="ks hv">万磁王</strong>，一个只针对Android的E2E测试框架，<br/>一个由Everything.me提供的解决方案，我之前工作的地方，以UIAutomator为主驱动构建。</p><ol class=""><li id="f871" class="ln lo hu ks b kt lp kx lq lb lr lf ls lj lt jr mx lv lw lx dt translated">它稳定多了，但我们仍然不能根除片状剥落。</li><li id="b623" class="ln lo hu ks b kt ly kx lz lb ma lf mb lj mc jr mx lv lw lx dt translated">我们有12个移动开发人员，一个开发人员致力于开发框架和CI系统。</li><li id="036c" class="ln lo hu ks b kt ly kx lz lb ma lf mb lj mc jr mx lv lw lx dt translated">大约5-10%的假阴性。</li></ol><p id="6e06" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated">其他的框架，像<a class="ae jg" href="https://github.com/RobotiumTech/robotium" rel="noopener ugc nofollow" target="_blank"> Robotium </a>和<a class="ae jg" href="https://developer.xamarin.com/guides/testcloud/calabash/introduction-to-calabash/" rel="noopener ugc nofollow" target="_blank">葫芦</a>已经不在开发中了。</p><p id="b3a5" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated">这些框架之间的主要相似之处在于它们都是黑盒测试框架。</p><h2 id="3815" class="mg jt hu bd ju mh mi mj jy mk ml mm kc lb mn mo kg lf mp mq kk lj mr ms ko mt dt translated">黑箱测试</h2><figure class="mz na nb nc fq iv fe ff paragraph-image"><div class="fe ff nt"><img src="../Images/ec71e2919882cb9f402e36911e76c254.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/format:webp/1*zNnM0UeZCNzffq2mQEJfdg.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">A box</figcaption></figure><p id="78e3" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated">什么是<a class="ae jg" href="https://en.wikipedia.org/wiki/Black-box_testing" rel="noopener ugc nofollow" target="_blank">黑盒测试</a>？这是一种从外部测试东西的方法，而不知道内部发生了什么。<br/>在mobile中，黑盒E2E框架本质上检查视图层次结构，寻找元素(如果没有找到，休眠，继续以这种方式循环，直到某个超时)，然后与视图交互。同样的原则也适用于网络黑盒E2E。</p><p id="f92a" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated">现在，想一想要求用户提供这个超时是多么不公平，他们不知道操作系统内部发生了什么，甚至不知道应用程序内部发生了什么，这是剥落的主要原因。</p><h1 id="d9e9" class="js jt hu bd ju jv jw jx jy jz ka kb kc kd ne kf kg kh nf kj kk kl ng kn ko kp dt translated"><strong class="ak">黑盒测试+ React Native </strong></h1><p id="3196" class="pw-post-body-paragraph kq kr hu ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm jr hn dt translated">当在react-native应用上使用时，E2E变得更加古怪…</p><h2 id="c858" class="mg jt hu bd ju mh mi mj jy mk ml mm kc lb mn mo kg lf mp mq kk lj mr ms ko mt dt translated">翻译</h2><p id="14ae" class="pw-post-body-paragraph kq kr hu ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm jr hn dt translated">在本地应用程序中，只有一个线程负责呈现UI(主线程)。<br/>使用React Native有点棘手，React Native的独特架构增加了系统的复杂性，其UI渲染从协调器开始，协调器计算UI的哪些部分发生了变化，这是在JavaScript线程上完成的，然后通过异步桥传递，并转换为主线程的本机指令，以渲染真实的布局。由于使用了这种异步渲染机制，现在有两个线程控制渲染，所以黑盒测试框架在控制React原生应用时会遇到更大的麻烦。</p><h2 id="862d" class="mg jt hu bd ju mh mi mj jy mk ml mm kc lb mn mo kg lf mp mq kk lj mr ms ko mt dt translated">加载和解析包</h2><p id="83b0" class="pw-post-body-paragraph kq kr hu ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm jr hn dt translated">当React本机应用程序启动时，它会从本地打包服务器或设备上的资产加载一个包，在任何情况下，这都是一个异步过程，需要不确定的时间。黑盒测试框架在这个过程中也需要休眠，但是要休眠多久呢？没有真正的答案。</p><p id="63dd" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated">黑盒是一个死胡同，我们需要一种不同的方法…</p></div><div class="ab cl nu nv hc nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="hn ho hp hq hr"><h1 id="edda" class="js jt hu bd ju jv ob jx jy jz oc kb kc kd od kf kg kh oe kj kk kl of kn ko kp dt translated">戒瘾诊所</h1><h2 id="54b0" class="mg jt hu bd ju mh mi mj jy mk ml mm kc lb mn mo kg lf mp mq kk lj mr ms ko mt dt translated">灰色盒子，不是黑色盒子</h2><p id="d450" class="pw-post-body-paragraph kq kr hu ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm jr hn dt translated">Detox使用灰盒，而不是黑盒，以允许测试框架从内部监控应用程序并与之同步。</p><p id="3b03" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated">灰盒子本质上使用了一段植入应用程序的代码，它可以帮助我们看到里面发生了什么。</p><p id="f266" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated">与黑盒不同，灰盒运行在同一个进程中，可以访问内存，可以监控执行进程。能够读取内部内存使它能够检测进程内部发生的事情:如果有网络请求正在进行，当主线程空闲时，其他线程空闲时，动画结束时，react本机桥空闲时。它可以在主线程上执行，以确保当它执行动作时，UI层次结构中没有任何变化。</p><p id="5689" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated">但也有不利的一面——通常当使用灰盒测试框架进行测试时，应用程序会经历不同的编译/运行过程，因为它需要从过程内部执行额外的代码。对我们来说，牺牲这一点并获得巨大的回报是值得的。</p><h2 id="216b" class="mg jt hu bd ju mh mi mj jy mk ml mm kc lb mn mo kg lf mp mq kk lj mr ms ko mt dt translated">使用EarlGrey和Espresso</h2><p id="d979" class="pw-post-body-paragraph kq kr hu ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm jr hn dt translated">领先的原生灰盒驱动程序由谷歌开发iOS版的<a class="ae jg" href="https://github.com/google/EarlGrey" rel="noopener ugc nofollow" target="_blank"> EarlGrey </a>和Android版的<a class="ae jg" href="https://developer.android.com/training/testing/ui-testing/espresso-testing.html" rel="noopener ugc nofollow" target="_blank"> Espresso </a>。这些框架可以与应用程序同步，确保只在应用程序空闲时与之交互。</p><p id="933d" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated">这些灰盒框架中使用的底层同步机制以如下方式工作。</p><p id="0370" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated">它们将每隔几毫秒查询一次内部资源，或者监听来自内部资源的回调，告知它们现在已经切换到空闲模式，而不是在UI上重试动作/期望。测试将不会继续，直到他们都返回是，只有到那时，当应用程序空闲时，它将与用户界面进行交互。</p><figure class="mz na nb nc fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff og"><img src="../Images/db6c60ee240b911d51521b24b0d92bc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f0mvvetAKW-41DzQWypN4w.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Idling Resources</figcaption></figure><h2 id="403f" class="mg jt hu bd ju mh mi mj jy mk ml mm kc lb mn mo kg lf mp mq kk lj mr ms ko mt dt translated">不依赖于WebDriver</h2><p id="4819" class="pw-post-body-paragraph kq kr hu ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm jr hn dt translated">排毒不依赖于网络驱动，因为这不是网络。Detox使用基于JSON的反射机制与其本机驱动程序(扩展了EarlGrey和Espresso)进行通信，这允许一个通用的JavaScript实现直接在设备上调用本机方法。</p><h2 id="ac75" class="mg jt hu bd ju mh mi mj jy mk ml mm kc lb mn mo kg lf mp mq kk lj mr ms ko mt dt translated">简单API</h2><ol class=""><li id="94d9" class="ln lo hu ks b kt ku kx ky lb mu lf mv lj mw jr mx lv lw lx dt translated">类似API的量角器，用JavaScript写的。</li><li id="6d38" class="ln lo hu ks b kt ly kx lz lb ma lf mb lj mc jr mx lv lw lx dt translated">最少的样板文件和非常小的配置过程。</li><li id="a802" class="ln lo hu ks b kt ly kx lz lb ma lf mb lj mc jr mx lv lw lx dt translated"><strong class="ks hv">跨平台:</strong>测试代码不知道它测试的平台，它可以在平台之间共享。</li><li id="0dda" class="ln lo hu ks b kt ly kx lz lb ma lf mb lj mc jr mx lv lw lx dt translated"><strong class="ks hv">同步:</strong>无需手动同步测试与应用程序，排毒固有的同步，它会执行其命令，只有当应用程序是空闲的，没有更多的睡眠！</li><li id="2422" class="ln lo hu ks b kt ly kx lz lb ma lf mb lj mc jr mx lv lw lx dt translated"><strong class="ks hv">可调试:</strong>使用诸如modern <code class="eh ni nj nk nl b">async-await</code>之类的原生构造，而不是将所有东西都放在承诺队列中，这意味着断点将按预期工作。</li></ol><figure class="mz na nb nc fq iv"><div class="bz el l di"><div class="no np l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">A simple login flow test written with Detox</figcaption></figure><h2 id="75c4" class="mg jt hu bd ju mh mi mj jy mk ml mm kc lb mn mo kg lf mp mq kk lj mr ms ko mt dt translated">反应本地支持</h2><p id="3523" class="pw-post-body-paragraph kq kr hu ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm jr hn dt translated">Detox完全是为原生移动而构建的，并对React原生应用程序提供一流的支持。</p><p id="a6af" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated">我们发现React Native几乎重新实现了iOS和Android，因此除了EarlGrey和Espresso对原生应用程序的基本同步支持之外，我们还必须为React Native创建特殊的同步机制。</p><h2 id="afe0" class="mg jt hu bd ju mh mi mj jy mk ml mm kc lb mn mo kg lf mp mq kk lj mr ms ko mt dt translated">评估对设备的期望</h2><p id="e93d" class="pw-post-body-paragraph kq kr hu ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm jr hn dt translated">传统上，测试框架评估在计算机上运行的测试脚本中的期望。排毒直接在模拟器上运行的测试应用程序中评估预期。这使得以前由于不同的范围或性能原因而不可能实现的操作成为可能。</p><h1 id="5efe" class="js jt hu bd ju jv jw jx jy jz ka kb kc kd ne kf kg kh nf kj kk kl ng kn ko kp dt translated">排毒是如何工作的</h1><p id="3317" class="pw-post-body-paragraph kq kr hu ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm jr hn dt translated">让我们来看看高层次的图表，希望它能帮助我们了解如何排毒工程。</p><figure class="mz na nb nc fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff oh"><img src="../Images/b89427915f991e3d3565811e40da622a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wjwAcotWegqE-Oje8cFwog.png"/></div></div></figure><ol class=""><li id="1482" class="ln lo hu ks b kt lp kx lq lb lr lf ls lj lt jr mx lv lw lx dt translated">试运行:行动或期望的执行(等待承诺)</li><li id="6298" class="ln lo hu ks b kt ly kx lz lb ma lf mb lj mc jr mx lv lw lx dt translated">测试人员:期望被序列化为嵌套调用JSON</li><li id="02cc" class="ln lo hu ks b kt ly kx lz lb ma lf mb lj mc jr mx lv lw lx dt translated">服务器:转发消息</li><li id="cddb" class="ln lo hu ks b kt ly kx lz lb ma lf mb lj mc jr mx lv lw lx dt translated">被测试者:通过方法反射调用EarlGrey</li><li id="7247" class="ln lo hu ks b kt ly kx lz lb ma lf mb lj mc jr mx lv lw lx dt translated">调用将仅在应用程序空闲时执行</li><li id="0047" class="ln lo hu ks b kt ly kx lz lb ma lf mb lj mc jr mx lv lw lx dt translated">被测试者:调用结果通过websocket返回</li><li id="a3a7" class="ln lo hu ks b kt ly kx lz lb ma lf mb lj mc jr mx lv lw lx dt translated">测试人员:解决/拒绝期望承诺</li></ol><p id="f8a9" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated">关于排毒如何工作的更多深入信息，请访问文档。</p><h1 id="4528" class="js jt hu bd ju jv jw jx jy jz ka kb kc kd ne kf kg kh nf kj kk kl ng kn ko kp dt translated">具有排毒功能的UI自动化</h1><p id="3d0d" class="pw-post-body-paragraph kq kr hu ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm jr hn dt translated">让我们回到我们的测试金字塔。</p><p id="c10b" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated">所以我们现在有了一个稳定的端到端测试框架。但是由于网络和服务器的问题，它可能仍然不稳定。</p><p id="be56" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated">为了做到这一点，我们需要消除网络中测试的依赖性，以一致且及时的方式预期请求和响应，我们将创建纯UI自动化(UI密封测试)。</p><h2 id="726e" class="mg jt hu bd ju mh mi mj jy mk ml mm kc lb mn mo kg lf mp mq kk lj mr ms ko mt dt translated"><a class="ae jg" href="https://github.com/wix/react-native-repackager" rel="noopener ugc nofollow" target="_blank">react-native-re packer</a></h2><p id="9259" class="pw-post-body-paragraph kq kr hu ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm jr hn dt translated"><a class="ae jg" href="https://github.com/wix/react-native-repackager" rel="noopener ugc nofollow" target="_blank"> react-native-repackager </a>是一个针对react-native JS代码的模仿机制。本质上，它扩展了打包程序用任何其他文件覆盖捆绑文件的能力，本质上创建了一种在react-native中模拟环境的简单方法。</p><p id="7b3f" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated">因此，您可以创建自己的预打包响应，或者将您的端点设置到您的本地模拟服务器，这对于分离您的测试关注点非常有帮助。</p><p id="dc3e" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated">React-native-repackager也将Detox变成了一个UI自动化框架。金字塔全绿，没有借口:)可以开始测试了！</p><h1 id="e870" class="js jt hu bd ju jv jw jx jy jz ka kb kc kd ne kf kg kh nf kj kk kl ng kn ko kp dt translated">排毒在行动</h1><p id="b45e" class="pw-post-body-paragraph kq kr hu ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm jr hn dt translated">令人惊讶的是，灰色盒子不仅比黑色盒子更稳定，而且速度更快。没有更多的睡眠或等待，直到代码执行毫秒应用程序变得空闲。因此，它比黑盒解决方案快5-10倍。<br/>事实上，它的速度非常快，可以在4分钟内运行完整的排毒测试项目套件(79项测试)。</p><figure class="mz na nb nc fq iv"><div class="bz el l di"><div class="oi np l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Detox’s own test suite running on an iOS Simulator</figcaption></figure><ul class=""><li id="4242" class="ln lo hu ks b kt lp kx lq lb lr lf ls lj lt jr lu lv lw lx dt translated">这是排毒自己的E2E测试，当然是用排毒写的</li><li id="b581" class="ln lo hu ks b kt ly kx lz lb ma lf mb lj mc jr lu lv lw lx dt translated">运行应用程序的模拟器在右边</li><li id="c249" class="ln lo hu ks b kt ly kx lz lb ma lf mb lj mc jr lu lv lw lx dt translated">运行我们测试的控制台在左边</li><li id="8d2a" class="ln lo hu ks b kt ly kx lz lb ma lf mb lj mc jr lu lv lw lx dt translated">我们使用<a class="ae jg" href="https://github.com/mochajs/mocha" rel="noopener ugc nofollow" target="_blank">摩卡</a>作为我们的测试跑步者，但是你可以使用任何你喜欢的，人们已经用Jest成功地设置了排毒。</li><li id="835b" class="ln lo hu ks b kt ly kx lz lb ma lf mb lj mc jr lu lv lw lx dt translated">您在控制台中看到的每一行都是一个新的隔离测试场景，因此它从头开始重新启动所有的测试，并且可以在将来进行分片。</li><li id="ac2e" class="ln lo hu ks b kt ly kx lz lb ma lf mb lj mc jr lu lv lw lx dt translated">如你所见，它非常快</li></ul><h2 id="ebf1" class="mg jt hu bd ju mh mi mj jy mk ml mm kc lb mn mo kg lf mp mq kk lj mr ms ko mt dt translated">跨平台对吗？安卓在哪里？</h2><p id="7c7e" class="pw-post-body-paragraph kq kr hu ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm jr hn dt translated">许多人一直在询问Android的排毒支持。这也是Wix内部热切期待的一个特性。<br/>现在，开源是一个很棒的东西，它可以形成合作，使项目更上一层楼。<br/>几个月前，来自KPN(荷兰一家大型电信公司)的<a class="nm nn gr" href="https://medium.com/u/6a258af9e7ed?source=post_page-----196ccd9564ce--------------------------------" rel="noopener" target="_blank">西蒙·拉茨</a>联系了我们，他表示愿意帮助Android排毒。从那时起，他几乎成了Detox的团队成员，在我们即将推出的Android支持中实现关键功能。</p><p id="db3c" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated">让我们看看它看起来怎么样</p><figure class="mz na nb nc fq iv"><div class="bz el l di"><div class="oi np l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Detox’s own test suite running on an Android Emulator</figcaption></figure><p id="d3ac" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated">这是我们用来测试iOS实现的同一个测试套件。它实际上是未受影响的，这样我们可以确保我们的API真正是跨平台的。Android的Detox几乎准备好了，事实上，缺少的东西很少，有关我们Android发布的更多细节，请关注github上我们的<a class="ae jg" href="https://github.com/wix/detox/releases" rel="noopener ugc nofollow" target="_blank">发布页面</a>。</p><h2 id="d12f" class="mg jt hu bd ju mh mi mj jy mk ml mm kc lb mn mo kg lf mp mq kk lj mr ms ko mt dt translated">排毒是一个TDD项目</h2><ol class=""><li id="5277" class="ln lo hu ks b kt ku kx ky lb mu lf mv lj mw jr mx lv lw lx dt translated">它有100%的代码覆盖率，如果低于这个数字，构建就会失败。</li><li id="9f01" class="ln lo hu ks b kt ly kx lz lb ma lf mb lj mc jr mx lv lw lx dt translated"><strong class="ks hv"> Detox的E2E API经过了Detox的测试:</strong>我们在每次构建时都在一个特殊的测试应用上运行整个Detox API。</li><li id="a13b" class="ln lo hu ks b kt ly kx lz lb ma lf mb lj mc jr mx lv lw lx dt translated"><strong class="ks hv">它旨在接受贡献:</strong>构建在TravisCI上运行，只有符合标准的贡献才会被接受，我们试图保持非常开放并与社区保持联系，非常乐意接受任何形式的帮助。</li></ol><div class="oj ok fm fo ol om"><a href="https://github.com/wix/detox/" rel="noopener  ugc nofollow" target="_blank"><div class="on ab ej"><div class="oo ab op cl cj oq"><h2 class="bd hv fv z el or eo ep os er et ht dt translated">wix/detox</h2><div class="ot l"><h3 class="bd b fv z el or eo ep os er et ek translated">排毒-灰盒E2E测试和移动应用程序自动化库</h3></div><div class="ou l"><p class="bd b gc z el or eo ep os er et ek translated">github.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa ja om"/></div></div></a></div><p id="2bb9" class="pw-post-body-paragraph kq kr hu ks b kt lp kv kw kx lq kz la lb md ld le lf me lh li lj mf ll lm jr hn dt translated">我要感谢排毒背后的团队成员:<a class="nm nn gr" href="https://medium.com/u/b717150cccfc?source=post_page-----196ccd9564ce--------------------------------" rel="noopener" target="_blank">利奥·纳坦</a>、<a class="nm nn gr" href="https://medium.com/u/83a4f96844d0?source=post_page-----196ccd9564ce--------------------------------" rel="noopener" target="_blank">塔尔·科尔</a>、<a class="nm nn gr" href="https://medium.com/u/4c6f11f87e4b?source=post_page-----196ccd9564ce--------------------------------" rel="noopener" target="_blank">谢尔盖·伊里耶夫斯基</a>、<a class="nm nn gr" href="https://medium.com/u/6a258af9e7ed?source=post_page-----196ccd9564ce--------------------------------" rel="noopener" target="_blank">西蒙·拉茨</a>、<a class="nm nn gr" href="https://medium.com/u/ed368caf53a6?source=post_page-----196ccd9564ce--------------------------------" rel="noopener" target="_blank">埃拉德·博戈莫尔尼</a>、<a class="nm nn gr" href="https://medium.com/u/d14afae26ab6?source=post_page-----196ccd9564ce--------------------------------" rel="noopener" target="_blank">丹尼尔·施密特</a>，以及我们所有其他内部和外部的贡献者，谢谢你们，你们太棒了！</p><h2 id="bb36" class="mg jt hu bd ju mh mi mj jy mk ml mm kc lb mn mo kg lf mp mq kk lj mr ms ko mt dt translated">摘要</h2><p id="5f80" class="pw-post-body-paragraph kq kr hu ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm jr hn dt translated">我们最初的任务是创建一个我们可以信任的框架，这样当构建是绿色的时，我们就可以发布我们的新版本，并以此建立一个真正的持续部署工作流。为了实现这一点，我们需要改变我们的思维状态，没有所谓的片状测试，要么是应用程序中存在错误，要么是测试框架缺乏，我们的首要任务是防止片状化，但这不是一个非常容易的任务。<br/>我们对排毒感到非常兴奋，我们希望它对我们有用，对其他人也有用。</p></div></div>    
</body>
</html>