<html>
<head>
<title>Reshaping Data in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中重塑数据</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/reshaping-data-in-python-fa27dda2ff77?source=collection_archive---------0-----------------------#2017-01-20">https://medium.com/hackernoon/reshaping-data-in-python-fa27dda2ff77?source=collection_archive---------0-----------------------#2017-01-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="23fe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我非常喜欢Jean-Nicholas Hould关于Python中整洁数据的文章，这篇文章是基于Hadley Wickham关于整洁数据的文章。从某种意义上说，当你思考这些结论时，它们是直观而明显的。但是数据分析可以是抽象的。为你正在做的事情找到合适的词汇并不容易。</p><p id="5535" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这篇文章中，我想专门讨论重塑数据的过程，即把数据从一种格式转换成另一种格式。Hould的文章中会有一些重复，但目标是概述我们经常遇到的各种数据格式，命名它们并命名我们用来转换数据的操作。</p><h1 id="bf5f" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated"><strong class="ak">长格式</strong></h1><p id="d2e2" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">让我们从一个数据整洁的表格开始。我们将称之为<em class="kt">长</em>格式数据(尽管存在其他命名约定，见下文)。借用Wickham的定义，在这种格式中a)每个变量形成一列，b)每个观测值形成一行，c)每种类型的观测单元形成一个表格。</p><p id="7d09" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">长格式数据的一个例子是这个由三个人在特定日期的现金余额组成的表。</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="50b0" class="ld jr hu kz b fv le lf l lg lh">In  : df<br/>Out :<br/>  <strong class="kz hv">   date        person   dollars</strong><br/><strong class="kz hv">0</strong>    2000-01-03  Michael  200<br/><strong class="kz hv">1</strong>    2000-01-03  George   500<br/><strong class="kz hv">2</strong>    2000-01-03  Lisa     450<br/><strong class="kz hv">3</strong>    2000-01-04  Michael  180.5<br/><strong class="kz hv">4</strong>    2000-01-04  George   450<br/><strong class="kz hv">5</strong>    2000-01-04  Lisa     448<br/><strong class="kz hv">6</strong>    2000-01-05  Michael  177<br/><strong class="kz hv">7</strong>    2000-01-05  George   420<br/><strong class="kz hv">8</strong>    2000-01-05  Lisa     447<br/><strong class="kz hv">9</strong>    2000-01-06  Michael  150<br/><strong class="kz hv">10</strong>   2000-01-06  George   300<br/><strong class="kz hv">11</strong>   2000-01-06  Lisa     344.6</span></pre><p id="749e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该表的格式可以称为:</p><ul class=""><li id="c4b7" class="li lj hu it b iu iv iy iz jc lk jg ll jk lm jo ln lo lp lq dt translated"><em class="kt">堆叠格式</em>，因为单个观察值相互堆叠。</li><li id="e4a9" class="li lj hu it b iu lr iy ls jc lt jg lu jk lv jo ln lo lp lq dt translated"><em class="kt">记录格式</em>，因为每一行都是单个记录，即单次观测。</li><li id="f484" class="li lj hu it b iu lr iy ls jc lt jg lu jk lv jo ln lo lp lq dt translated"><em class="kt">长格式</em>，因为这种格式在垂直方向是长的，而在水平方向是宽的。</li></ul><h1 id="6951" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">透视数据</h1><p id="f14c" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">如果这张桌子已经很整洁了，我们为什么还要把它重新塑造成另一种格式呢？嗯，我们可能会对按日期直观地比较个人的平衡感兴趣。或者，我们可能对将数据绘制成时间序列感兴趣，其中每条水平线代表一个人。</p><p id="e8ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在pandas中，我们可以通过使用dataframe的<em class="kt"> pivot </em>方法来实现这一点。这就产生了一个“数据透视表”，这是Excel用户所熟悉的。</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="5590" class="ld jr hu kz b fv le lf l lg lh">In  : df.pivot(index='date', columns='name', values='dollars')<br/>Out :<br/><strong class="kz hv">name        George  Lisa   Michael</strong><br/><strong class="kz hv">date</strong><br/><strong class="kz hv">2000-01-03</strong>  500.0   450.0  200.0<br/><strong class="kz hv">2000-01-04</strong>  450.0   448.0  180.5<br/><strong class="kz hv">2000-01-05</strong>  420.0   447.0  177.0<br/><strong class="kz hv">2000-01-06</strong>  300.0   344.6  150.0</span></pre><p id="992e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您指定为<em class="kt">列</em>参数的任何列都将用于创建新列(每个唯一的条目将形成一个新列)。您指定为<em class="kt">值</em>参数的列将构成这些列的值，索引将由……您猜对了，您指定为<em class="kt">索引</em>参数的列组成。</p><p id="aa35" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该表的格式可以称为:</p><ul class=""><li id="88cc" class="li lj hu it b iu iv iy iz jc lk jg ll jk lm jo ln lo lp lq dt translated"><em class="kt">宽格式</em>，因为表格现在变宽了而不是变长了。</li><li id="18cb" class="li lj hu it b iu lr iy ls jc lt jg lu jk lv jo ln lo lp lq dt translated"><em class="kt">未堆叠格式</em>，因为个人观察(一个人/一个日期)不再彼此堆叠。</li></ul><p id="bb9f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有点令人困惑的是，pandas dataframes还附带了一个<em class="kt"> pivot_table </em>方法，这是对<em class="kt"> pivot </em>方法的一个概括。每当一个索引/列对有重复值时，就需要使用<em class="kt"> pivot_table </em>。让我们看一个例子。</p><p id="9f19" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设我们有乔治、丽莎和迈克尔售出的饼干数量的数据。表中的每一行都代表一个销售机会，这意味着在给定的日期可能有同一销售者的多行。</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="1115" class="ld jr hu kz b fv le lf l lg lh">In  : df_cookies<br/>Out :<br/>   <strong class="kz hv">cookies_sold  date        name</strong><br/><strong class="kz hv">0</strong>  1             2000–01–01  George<br/><strong class="kz hv">1</strong>  3             2000–01–01  Michael<br/><strong class="kz hv">2</strong>  3             2000–01–01  Lisa<br/><strong class="kz hv">3</strong>  2             2000–01–01  George<br/><strong class="kz hv">4</strong>  4             2000–01–01  Lisa</span></pre><p id="f01c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们试图<em class="kt">旋转</em>这个数据帧，我们会得到一个ValueError。</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="156c" class="ld jr hu kz b fv le lf l lg lh">In  : df_cookies.pivot(index='date',<br/>                       columns='name',<br/>                       values='cookies_sold')<br/>Out :<br/>...<br/>ValueError: Index contains duplicate entries, cannot reshape</span></pre><p id="cc66" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">与我们之前的balance数据框架不同，cookies数据框架中的值必须聚合才能进行透视，因为George和Lisa在一天内多次出售cookies。换句话说，当我们让pandas透视我们的数据时，它找不到一个值来返回重复的日期/名称对。然而，Pandas可以为我们提供每个日期/姓名对的总和、平均值或任何其他聚合值。</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="bbc9" class="ld jr hu kz b fv le lf l lg lh">In  : df_cookies.pivot_table(index='date',<br/>                             columns='name',<br/>                             values='cookies_sold')<br/>Out :<br/><strong class="kz hv">name        George  Lisa  Michael</strong><br/><strong class="kz hv">date</strong><br/><strong class="kz hv">2000-01-01</strong>  1.5     3.5   3.0</span></pre><p id="8abd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">pandas使用的默认聚合函数是平均值，但是我们可以使用<em class="kt"> aggfunc </em>参数轻松地更改它。</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="3931" class="ld jr hu kz b fv le lf l lg lh">In  : df_cookies.pivot_table(index='date',<br/>                             columns='name',<br/>                             values='cookies_sold'<br/>                             aggfunc='sum')<br/>Out :<br/><strong class="kz hv">name        George  Lisa  Michael</strong><br/><strong class="kz hv">date</strong><br/><strong class="kz hv">2000-01-01</strong>  3       7     3</span></pre><h1 id="b64f" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">堆叠和拆分数据</h1><p id="40ea" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">除了旋转方法之外，pandas还有堆叠和拆分数据这两个相关的概念。这些主要是为操作多索引数据帧而设计的。</p><p id="6ba8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们创建一个原始余额数据框架的多索引数据框架。</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="e441" class="ld jr hu kz b fv le lf l lg lh">In  : df_multi = df.set_index(['date', 'name'])<br/>In  : df_multi<br/>Out :<br/>                     <strong class="kz hv">dollars</strong><br/><strong class="kz hv">date        name</strong><br/><strong class="kz hv">2000–01–03  Michael</strong>  200.0<br/>          <strong class="kz hv">  George</strong>   500.0<br/>          <strong class="kz hv">  Lisa</strong>     450.0<br/><strong class="kz hv">2000–01–04  Michael</strong>  180.5<br/>          <strong class="kz hv">  George</strong>   450.0<br/>          <strong class="kz hv">  Lisa</strong>     448.0<br/><strong class="kz hv">2000–01–05  Michael</strong>  177.0<br/>          <strong class="kz hv">  George</strong>   420.0<br/>           <strong class="kz hv"> Lisa</strong>     447.0<br/><strong class="kz hv">2000–01–06  Michael</strong>  150.0<br/>           <strong class="kz hv"> George</strong>   300.0<br/>           <strong class="kz hv"> Lisa</strong>     344.6</span></pre><p id="a4ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">记住，这是堆叠的数据。每行对应一行。使用<em class="kt"> DataFrame.stack </em>和<em class="kt"> DataFrame.unstack </em>，我们可以在层次索引和层次列之间切换。在这种情况下，我们有一个层次索引，所以让我们看看<em class="kt"> unstack </em>是做什么的。</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="5c5b" class="ld jr hu kz b fv le lf l lg lh">In  : df_multi.unstack()<br/>Out :<br/>            <strong class="kz hv">dollars</strong><br/><strong class="kz hv">name</strong>        <strong class="kz hv">George  Lisa   Michael</strong><br/><strong class="kz hv">date</strong>   <br/><strong class="kz hv">2000-01-03</strong>  500.0   450.0  200.0<br/><strong class="kz hv">2000-01-04</strong>  450.0   448.0  180.5<br/><strong class="kz hv">2000-01-05</strong>  420.0   447.0  177.0<br/><strong class="kz hv">2000-01-06</strong>  300.0   344.6  150.0</span></pre><p id="34c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如您所见，该操作将我们的分层索引移动了一级，从而在数据帧中形成了一个新的列级。要回到堆栈格式，我们只需使用<em class="kt">堆栈</em>。</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="d35b" class="ld jr hu kz b fv le lf l lg lh">In  : df_multi.unstack().stack()<br/>Out :<br/>                     <strong class="kz hv">dollars</strong><br/><strong class="kz hv">date        name</strong><br/><strong class="kz hv">2000–01–03  Michael</strong>  200.0<br/>          <strong class="kz hv">  George</strong>   500.0<br/>          <strong class="kz hv">  Lisa</strong>     450.0<br/><strong class="kz hv">2000–01–04  Michael</strong>  180.5<br/>          <strong class="kz hv">  George</strong>   450.0<br/>           <strong class="kz hv"> Lisa</strong>     448.0<br/><strong class="kz hv">2000–01–05  Michael</strong>  177.0<br/>           <strong class="kz hv"> George</strong>   420.0<br/>           <strong class="kz hv"> Lisa</strong>     447.0<br/><strong class="kz hv">2000–01–06  Michael</strong>  150.0<br/>           <strong class="kz hv"> George</strong>   300.0<br/>           <strong class="kz hv"> Lisa</strong>     344.6</span></pre><h1 id="79ee" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">转置数据</h1><p id="a52b" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">Pandas有一种旋转数据帧的简单方法，即切换列和索引的位置。只需使用<em class="kt"> T </em>属性来旋转数据。</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="7e78" class="ld jr hu kz b fv le lf l lg lh">In  : df = pd.DataFrame({'a': [1, 2], <br/>                         'b': [3, 4]}, index=[‘one’, ‘two’])<br/>In  : df<br/>Out :<br/>    <strong class="kz hv">a</strong> <strong class="kz hv">b</strong><br/><strong class="kz hv">one</strong> 1 3<br/><strong class="kz hv">two</strong> 2 4</span><span id="d3f7" class="ld jr hu kz b fv lw lf l lg lh">In  : df.T<br/>Out :<br/>  <strong class="kz hv">one two</strong><br/><strong class="kz hv">a</strong> 1   2<br/><strong class="kz hv">b</strong> 3   4</span></pre><h1 id="6d79" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">使用melt取消数据透视</h1><p id="2a68" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">对我来说，发现熊猫的“融化T21”功能改变了游戏规则。它基本上允许您按照自己的意愿取消数据透视。换句话说，我们使用<em class="kt"> melt </em>将宽数据转换为长数据。</p><p id="41b7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设我们有一个像这样的宽格式数据帧。</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="ffa0" class="ld jr hu kz b fv le lf l lg lh"><strong class="kz hv">  country 2010  2011  2012</strong><br/><strong class="kz hv">0</strong> Canada  55    55    86<br/><strong class="kz hv">1</strong> Iraq    56    32    22<br/><strong class="kz hv">2</strong> Italy   3     56    11</span></pre><p id="fa95" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了将这些数据转换成长格式，其中每一行代表一个国家/年份对，我们使用了<em class="kt"> melt </em>(这不是dataframe方法，而是从pandas的顶级导入)。</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="c246" class="ld jr hu kz b fv le lf l lg lh">In  : pd.melt(df, id_vars='country', value_vars=[2010, 2011, 2012])<br/>Out :<br/><strong class="kz hv">   country  year  value</strong><br/><strong class="kz hv">0</strong>  Canada   2010  55<br/><strong class="kz hv">1</strong>  Iraq     2010  56<br/><strong class="kz hv">2</strong>  Italy    2010  3<br/><strong class="kz hv">3</strong>  Canada   2011  55<br/><strong class="kz hv">4</strong>  Iraq     2011  32<br/><strong class="kz hv">5</strong>  Italy    2011  56<br/><strong class="kz hv">6</strong>  Canada   2012  86<br/><strong class="kz hv">7</strong>  Iraq     2012  22<br/><strong class="kz hv">8</strong>  Italy    2012  11</span></pre><p id="3d03" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">希望这个概述能让pandas重塑数据的工具更加清晰。快乐的数据争论！</p><blockquote class="lx ly lz"><p id="1f81" class="ir is kt it b iu iv iw ix iy iz ja jb ma jd je jf mb jh ji jj mc jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is kt it b iu iv iw ix iy iz ja jb ma jd je jf mb jh ji jj mc jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is kt it b iu iv iw ix iy iz ja jb ma jd je jf mb jh ji jj mc jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>