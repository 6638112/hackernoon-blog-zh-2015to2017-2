<html>
<head>
<title>Deploying Flogo apps to Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Flogo应用部署到Kubernetes</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/deploying-flogo-apps-to-kubernetes-43a74742e323?source=collection_archive---------16-----------------------#2017-11-15">https://medium.com/hackernoon/deploying-flogo-apps-to-kubernetes-43a74742e323?source=collection_archive---------16-----------------------#2017-11-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/f87bb8f0ec1d92bdd9806443ac6527a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yeRqlz-lmNaL3ZwI0TK1kA.png"/></div></div></figure><p id="ddbe" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">借助<a class="ae ka" href="https://flogo.io" rel="noopener ugc nofollow" target="_blank"> Project Flogo </a>，您可以可视化地创建超轻边缘微服务，并在任何地方运行它们。但是，如果您想使用最强大的容器管理平台之一<a class="ae ka" href="https://hackernoon.com/tagged/kubernetes" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>来运行那些极其轻量级的微服务，该怎么办呢？</p><h1 id="25da" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated"><strong class="ak">先决条件</strong></h1><p id="e9e9" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">如Kubernetes网站所述</p><blockquote class="le lf lg"><p id="c173" class="jc jd lh je b jf jg jh ji jj jk jl jm li jo jp jq lj js jt ju lk jw jx jy jz hn dt translated">Kubernetes是一个用于自动化部署、扩展和管理容器化应用程序的开源系统。它将组成应用程序的容器分组到逻辑单元中，以便于管理和发现。</p></blockquote><p id="03c3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你还没有建立自己的Kubernetes集群，我绝对推荐你看看<a class="ae ka" href="https://github.com/kubernetes/minikube" rel="noopener ugc nofollow" target="_blank"> minikube </a>。该团队做出了惊人的努力，以最小的安装工作量，使在本地运行您自己的集群变得非常容易。</p><p id="ce2c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于Kubernetes是针对容器化应用的，这意味着我们必须从我们的<a class="ae ka" href="https://hackernoon.com/tagged/flogo" rel="noopener ugc nofollow" target="_blank"> Flogo </a>应用创建一个Docker映像，并将其推送到Kubernetes集群可访问的注册表中。在下面的例子中，我将使用Docker Cloud，但是根据您的喜好，您可以选择任何容器注册表。</p><h1 id="449b" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated"><strong class="ak">Flogo应用</strong></h1><p id="bc7d" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">由于这篇文章更多的是关于在Kubernetes上运行应用程序，而不是如何创建应用程序，我只是使用了<a class="ae ka" href="https://tibcosoftware.github.io/flogo/getting-started/quickstart/" rel="noopener ugc nofollow" target="_blank"> Flogo文档</a>中的教程。这个应用程序有一个简单的HTTP接收器监听端口<em class="lh"> 8080 </em>并发回一个默认字符串。如果你想使用不同的应用程序，当然也是可以的！</p><h1 id="2048" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated"><strong class="ak">创建一个Docker图像</strong></h1><p id="40ee" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">Flogo将自己描述为一个<em class="lh"> _Ultralight Edge微服务框架_ </em>，因此将使用它构建的应用程序容器化应该不会增加太多开销。幸运的是，今天你有一大堆小型基础容器可用，从<a class="ae ka" href="https://hub.docker.com/_/alpine/" rel="noopener ugc nofollow" target="_blank"> alpine </a>到debian(还有<a class="ae ka" href="https://hub.docker.com/r/library/debian/tags/jessie-slim/" rel="noopener ugc nofollow" target="_blank"> jessie-slim </a>)。我最喜欢的三个是:</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="ea29" class="lu kc hu lq b fv lv lw l lx ly">$ docker images</span><span id="6dc1" class="lu kc hu lq b fv lz lw l lx ly">debian jessie-slim a870c469749c 10 days ago 79.1MB</span><span id="2e10" class="lu kc hu lq b fv lz lw l lx ly">alpine latest 053cde6e8953 11 days ago 3.97MB</span><span id="9359" class="lu kc hu lq b fv lz lw l lx ly">bitnami/minideb latest c5693017e0d4 3 weeks ago 53.6MB</span></pre><p id="60d1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我有一个在Linux上运行的应用程序，大约7.4MB，因为我想尽可能降低开销，所以我将使用<em class="lh"> alpine </em>来运行这个程序。将alpine与我的Flogo应用程序结合起来，应该会产生大约12MB的图像，我认为这已经很不错了。为了构建图像，我们需要一个Dockerfile文件:</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="5f0b" class="lu kc hu lq b fv lv lw l lx ly"># Dockerfile for flogoapp</span><span id="e5f9" class="lu kc hu lq b fv lz lw l lx ly"># VERSION 0.0.1</span><span id="afc2" class="lu kc hu lq b fv lz lw l lx ly"># The FROM instruction initializes a new build stage and sets the Base Image for subsequent instructions.</span><span id="d7d2" class="lu kc hu lq b fv lz lw l lx ly"># We’re using alpine because of the small size</span><span id="9947" class="lu kc hu lq b fv lz lw l lx ly">FROM alpine</span><span id="8ea4" class="lu kc hu lq b fv lz lw l lx ly"># The ADD instruction copies new files, directories or remote file URLs from &lt;src&gt; and adds them to the filesystem of the image at the path &lt;dest&gt;.</span><span id="ae6f" class="lu kc hu lq b fv lz lw l lx ly"># We’ll add the flogoapp, built using the Web UI, to the working directory</span><span id="5d7e" class="lu kc hu lq b fv lz lw l lx ly">ADD flogoapp.dms .</span><span id="ae94" class="lu kc hu lq b fv lz lw l lx ly"># The EXPOSE instruction informs Docker that the container listens on the specified network ports at runtime.</span><span id="09cb" class="lu kc hu lq b fv lz lw l lx ly"># The app we’re using listens on port 8080 by default</span><span id="e5e5" class="lu kc hu lq b fv lz lw l lx ly">EXPOSE 8080</span><span id="472f" class="lu kc hu lq b fv lz lw l lx ly"># The main purpose of a CMD is to provide defaults for an executing container.</span><span id="481f" class="lu kc hu lq b fv lz lw l lx ly"># In our case we simply want to run the app</span><span id="ff54" class="lu kc hu lq b fv lz lw l lx ly">CMD ./flogoapp.dms</span></pre><p id="a23f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要在此基础上构建应用程序，您只需运行以下命令:</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="1eb8" class="lu kc hu lq b fv lv lw l lx ly">docker build . -t &lt;your username&gt;/flogoalpine</span></pre><p id="16fb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我的例子中，它以一个非常小的图像结束，大概是我期望的大小！</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="4d1b" class="lu kc hu lq b fv lv lw l lx ly">REPOSITORY TAG IMAGE ID CREATED SIZE</span><span id="2312" class="lu kc hu lq b fv lz lw l lx ly">retgits/flogoalpine latest e7bc672e009e About an hour ago 11.7MB</span></pre><p id="2817" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如前所述，我将利用<a class="ae ka" href="https://cloud.docker.com" rel="noopener ugc nofollow" target="_blank"> Docker Cloud </a>来推送我的图像，以便Kubernetes集群可以访问它们。一个简单的命令就可以让图像可用:-)</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="c1b9" class="lu kc hu lq b fv lv lw l lx ly">docker push &lt;your username&gt;/flogoalpine</span></pre><p id="12c9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是码头工人的部分，让我们去Kubernetes！</p><h1 id="e855" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated"><strong class="ak">创建“部署”</strong></h1><p id="7a4c" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">Kubernetes中的<em class="lh">部署</em>是一个控制器，它为pod和副本集提供声明性更新。从本质上说，它让您能够公开更新您的应用程序，这意味着零停机时间！</p><p id="5220" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">示例“deployment.yaml”文件可能如下所示。这将在Kubernetes上创建一个部署，其中有一个副本(因此我们的应用程序的一个实例正在运行),其中容器的名称为“flogoapp ”,它将提取“T8”作为要运行的容器。请特别注意“containerPort ”,因为这将确保可以从外部访问该端口(尽管仍在群集内)</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="60e9" class="lu kc hu lq b fv lv lw l lx ly">apiVersion: extensions/v1beta1</span><span id="e217" class="lu kc hu lq b fv lz lw l lx ly">kind: Deployment</span><span id="b5a1" class="lu kc hu lq b fv lz lw l lx ly">metadata:</span><span id="3dfb" class="lu kc hu lq b fv lz lw l lx ly">  name: flogoapp-deployment</span><span id="f43e" class="lu kc hu lq b fv lz lw l lx ly">spec:</span><span id="65fa" class="lu kc hu lq b fv lz lw l lx ly">  replicas: 1</span><span id="729d" class="lu kc hu lq b fv lz lw l lx ly">  template:</span><span id="2031" class="lu kc hu lq b fv lz lw l lx ly">    metadata:</span><span id="547c" class="lu kc hu lq b fv lz lw l lx ly">      labels:</span><span id="1984" class="lu kc hu lq b fv lz lw l lx ly">        app: flogoapp</span><span id="0dec" class="lu kc hu lq b fv lz lw l lx ly">    spec:</span><span id="9ad5" class="lu kc hu lq b fv lz lw l lx ly">      containers:</span><span id="2ea1" class="lu kc hu lq b fv lz lw l lx ly">      - name: flogoapp</span><span id="3bfa" class="lu kc hu lq b fv lz lw l lx ly">        image: &lt;image name&gt;</span><span id="4f75" class="lu kc hu lq b fv lz lw l lx ly">        imagePullPolicy: Always</span><span id="10d5" class="lu kc hu lq b fv lz lw l lx ly">        ports:</span><span id="50ae" class="lu kc hu lq b fv lz lw l lx ly">        - containerPort: 8080</span></pre><p id="00ce" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在创建一个部署，您可以运行</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="b0fb" class="lu kc hu lq b fv lv lw l lx ly">kubectl create -f deployment.yaml</span></pre><p id="5169" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在kubectl cli工具中，或者使用仪表板，您可以看到您的部署状态:</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="35ad" class="lu kc hu lq b fv lv lw l lx ly">$ kubectl get deployments</span><span id="e72b" class="lu kc hu lq b fv lz lw l lx ly">NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE</span><span id="f922" class="lu kc hu lq b fv lz lw l lx ly">flogoapp-deployment 1 1 1 1 50m</span></pre><p id="0e63" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的应用正在运行！现在，我们需要确保我们也可以从外部访问它…</p><h1 id="6877" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated"><strong class="ak">创建一个“服务”</strong></h1><p id="7a15" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">Kubernetes文档对为什么需要<em class="lh">服务</em>有很好的解释，所以我让<a class="ae ka" href="https://kubernetes.io/docs/concepts/services-networking/service" rel="noopener ugc nofollow" target="_blank">他们</a>来讲述这个故事</p><blockquote class="le lf lg"><p id="c2b1" class="jc jd lh je b jf jg jh ji jj jk jl jm li jo jp jq lj js jt ju lk jw jx jy jz hn dt translated">库伯内特豆荚是会死的。他们出生，当他们死去，他们不会复活。复制控制器特别是动态地创建和销毁pod(例如，当放大或缩小或者当进行滚动更新时)。虽然每个Pod都有自己的IP地址，但即使是这些IP地址也不能长期保持稳定。这就产生了一个问题:如果Kubernetes集群中的一组Pods(让我们称之为后端)向其他Pods(让我们称之为前端)提供功能，那么这些前端如何发现并跟踪该组中的后端呢？</p></blockquote><p id="4145" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，这些服务在逻辑上将pod分组在一起，并确保即使当pod消失时，您也不必更改IP地址。一个服务可以有许多不同的功能和更多的配置选项，所以让我们创建一个相当简单的服务。</p><p id="ccb6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面的“service.yaml”文件简单地定义了服务“flogoapp ”,该服务将我们已经部署的应用程序的端口8080直接绑定到端口30061，我们可以从集群外部访问该端口。</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="16c0" class="lu kc hu lq b fv lv lw l lx ly">apiVersion: v1</span><span id="7222" class="lu kc hu lq b fv lz lw l lx ly">kind: Service</span><span id="ddd9" class="lu kc hu lq b fv lz lw l lx ly">metadata:</span><span id="923f" class="lu kc hu lq b fv lz lw l lx ly">  name: flogoapp</span><span id="2671" class="lu kc hu lq b fv lz lw l lx ly">  labels:</span><span id="07bb" class="lu kc hu lq b fv lz lw l lx ly">    app: flogoapp</span><span id="fcd6" class="lu kc hu lq b fv lz lw l lx ly">spec:</span><span id="7cab" class="lu kc hu lq b fv lz lw l lx ly">  selector:</span><span id="2f6c" class="lu kc hu lq b fv lz lw l lx ly">    app: flogoapp</span><span id="f891" class="lu kc hu lq b fv lz lw l lx ly">  ports:</span><span id="9418" class="lu kc hu lq b fv lz lw l lx ly">  - port: 8080</span><span id="f34e" class="lu kc hu lq b fv lz lw l lx ly">    protocol: TCP</span><span id="1a7d" class="lu kc hu lq b fv lz lw l lx ly">    nodePort: 30061</span><span id="4c22" class="lu kc hu lq b fv lz lw l lx ly">  type: LoadBalancer</span></pre><p id="a2c0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要在Kubernetes中创建服务，只需运行:</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="44d9" class="lu kc hu lq b fv lv lw l lx ly">kubectl create -f service.yaml</span></pre><p id="a497" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在kubectl cli工具中，或者使用仪表板，您可以看到服务的状态，就像您的部署一样:</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="bf83" class="lu kc hu lq b fv lv lw l lx ly">$ kubectl get services</span><span id="da5c" class="lu kc hu lq b fv lz lw l lx ly">NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE</span><span id="d943" class="lu kc hu lq b fv lz lw l lx ly">flogoapp LoadBalancer 10.0.0.110 &lt;pending&gt; 8989:30061/TCP 1h</span><span id="4192" class="lu kc hu lq b fv lz lw l lx ly">kubernetes ClusterIP 10.0.0.1 &lt;none&gt; 443/TCP 1d</span></pre><p id="1c7f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这也负责将应用程序暴露在集群之外。所以我们还有最后一项任务！</p><h1 id="e2bd" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated"><strong class="ak">访问您的应用程序！</strong></h1><p id="8390" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">现在访问应用程序非常简单。首先，我们需要Kubernetes集群的外部IP地址。如果你正在运行minikube，你可以通过运行“minikube ip”来获得。使用cURL，您现在可以从应用程序调用API，并查看应用程序的内部Flogo ID。</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="771b" class="lu kc hu lq b fv lv lw l lx ly">$ curl <a class="ae ka" href="http://192.168.99.100:30061/helloworld" rel="noopener ugc nofollow" target="_blank">http://192.168.99.100:30061/helloworld</a></span><span id="9545" class="lu kc hu lq b fv lz lw l lx ly">{“id”:”006257ffaf5fb1e9621914dcd0203af8"}</span></pre><h1 id="440d" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated"><strong class="ak">结论</strong></h1><p id="c238" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们采用了一个简单的Flogo应用程序，将该应用程序添加到Docker容器中，并将其部署到Kubernetes。Flogo本身非常强大和轻便。结合Kubernetes的强大功能和灵活性，您可以在一个非常酷且强大的平台上运行超轻微服务。如果你想尝试Flogo项目，请访问我们的<a class="ae ka" href="http://www.flogo.io" rel="noopener ugc nofollow" target="_blank">网页</a>或GitHub <a class="ae ka" href="https://github.com/tibcosoftware/flogo" rel="noopener ugc nofollow" target="_blank">项目</a>。</p><figure class="ll lm ln lo fq iv"><div class="bz el l di"><div class="ma mb l"/></div></figure></div></div>    
</body>
</html>