<html>
<head>
<title>Kotlin Functors, Applicatives, And Monads in Pictures. Part 2/3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图中的科特林函子、应用和单子。第2/3部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/kotlin-functors-applicatives-and-monads-in-pictures-part-2-3-f99a09efd1ec?source=collection_archive---------2-----------------------#2017-04-04">https://medium.com/hackernoon/kotlin-functors-applicatives-and-monads-in-pictures-part-2-3-f99a09efd1ec?source=collection_archive---------2-----------------------#2017-04-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="0c4d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，如果你没有阅读前一篇文章，去读吧，否则你可能会错过一些重要的概念！</p><div class="jp jq fm fo jr js"><a rel="noopener follow" target="_blank" href="/@aballano/kotlin-functors-applicatives-and-monads-in-pictures-part-1-3-c47a1b1ce251"><div class="jt ab ej"><div class="ju ab jv cl cj jw"><h2 class="bd hv fv z el jx eo ep jy er et ht dt translated">图中的科特林函子、应用和单子。第1/3部分(草案)</h2><div class="jz l"><h3 class="bd b fv z el jx eo ep jy er et ek translated">很简单。让我们扩展一下，任何值都可以在上下文中。现在，您可以将上下文视为一个…</h3></div><div class="ka l"><p class="bd b gc z el jx eo ep jy er et ek translated">medium.com</p></div></div><div class="kb l"><div class="kc l kd ke kf kb kg kh js"/></div></div></a></div><h1 id="ab88" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">应用程序</h1><p id="f7a1" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">应用程序把它带到了下一个层次。对于应用程序，我们的值被包装在上下文中，就像<a class="ae ll" href="https://hackernoon.com/tagged/functors" rel="noopener ugc nofollow" target="_blank">函子</a>:</p><figure class="ln lo lp lq fq lr fe ff paragraph-image"><div class="fe ff lm"><img src="../Images/be3042e1d038e30123ca086bcd795a94.png" data-original-src="https://miro.medium.com/v2/resize:fit:320/format:webp/0*tLlU2WEqCu7jYUSj.png"/></div></figure><p id="9928" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是我们的函数也包含在上下文中！</p><figure class="ln lo lp lq fq lr fe ff paragraph-image"><div class="fe ff lt"><img src="../Images/dcbde23c23e52d7785a41d0c1fb6730a.png" data-original-src="https://miro.medium.com/v2/resize:fit:270/format:webp/0*-3EM_WBCQu5KlCUX.png"/></div></figure><p id="1187" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">是啊。让它深入人心。申请人不会开玩笑。与Haskell不同，<a class="ae ll" href="https://hackernoon.com/tagged/kotlin" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>还没有<em class="lu">和</em>一种处理应用程序的内置方式。但是加一个是非常容易的！我们可以为每个支持Applicative的类型定义一个<code class="eh lv lw lx ly b">apply</code>函数，它知道如何将包装在类型上下文中的函数应用到包装在相同上下文中的值:</p><pre class="ln lo lp lq fq lz ly ma mb aw mc dt"><span id="2506" class="md kj hu ly b fv me mf l mg mh">infix fun &lt;A, B&gt; Option&lt;(A) -&gt; B&gt;.apply(f: Option&lt;A&gt;): Option&lt;B&gt; =<br/>        when (this) {<br/>            is Option.None -&gt; Option.None<br/>            is Option.Some -&gt; f.map(this.value)<br/>        }</span><span id="526b" class="md kj hu ly b fv mi mf l mg mh">infix inline fun &lt;A, reified B&gt; Array&lt;(A) -&gt; B&gt;.apply(a: Array&lt;A&gt;) =<br/>        Array(this.size * a.size) {<br/>            this[it / a.size](a[it % a.size])<br/>        }</span></pre><p id="c154" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果<code class="eh lv lw lx ly b">this</code>和函数都是<code class="eh lv lw lx ly b">Some</code>，那么函数被应用到展开的选项，否则返回<code class="eh lv lw lx ly b">None</code>。</p><p id="6ef0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于<code class="eh lv lw lx ly b">Array</code>,我使用它的构造函数参数来生成数组，尽管注意这对于更大的数组来说不是最好的选择。</p><blockquote class="mj mk ml"><p id="cbe4" class="ir is lu it b iu iv iw ix iy iz ja jb mm jd je jf mn jh ji jj mo jl jm jn jo hn dt translated"><strong class="it hv">注意:</strong>这将是Haskell中的<code class="eh lv lw lx ly b">&lt;*&gt;</code>，所以如果需要的话，我们可以使用一个<code class="eh lv lw lx ly b">*</code>操作符。</p></blockquote><figure class="ln lo lp lq fq lr fe ff paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="fe ff mp"><img src="../Images/313be1e5f22b85c0d971c31b761caf21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YZDbwqs5Vxy-ldbA.png"/></div></div></figure><p id="fcf8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">即:</p><pre class="ln lo lp lq fq lz ly ma mb aw mc dt"><span id="7c55" class="md kj hu ly b fv me mf l mg mh">Some({ a: Int -&gt; a + 3 }) apply Some(2)<br/>// =&gt; Some(5)</span></pre></div><div class="ab cl mu mv hc mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="hn ho hp hq hr"><p id="385b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你仔细观察，你会发现我们的操作符只按照这个特定的顺序工作:<code class="eh lv lw lx ly b">Option(function) apply Option(value)</code>为什么？因为我们的扩展函数就是按这个顺序定义的。那么，难道我不能创建另一个扩展函数来反过来工作吗，比如:</p><pre class="ln lo lp lq fq lz ly ma mb aw mc dt"><span id="31f2" class="md kj hu ly b fv me mf l mg mh">fun &lt;A, B&gt; Option&lt;A&gt;.<!-- -->apply<!-- -->(o: Option&lt;(A) -&gt; B&gt;) = {...}<br/>fun &lt;A, B&gt; Option&lt;(A) -&gt; B&gt;.<!-- -->apply<!-- -->(o: Option&lt;A&gt;) = {...}</span></pre><p id="ee0f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">严格来说不是。因为Kotlin产生的代码和Java一样，它必须处理我们的朋友<a class="ae ll" href="https://docs.oracle.com/javase/tutorial/java/generics/erasure.html" rel="noopener ugc nofollow" target="_blank">类型的删除</a>。所以基本上这两个函数会在编译时释放泛型类型(变成仅仅是<code class="eh lv lw lx ly b">Option</code>)，使它们相等，因此无效。但是这里有一个技巧，我们可以使用一个所谓的<code class="eh lv lw lx ly b">dummyImplicit</code>(你可以在这里阅读为什么<a class="ae ll" href="http://stackoverflow.com/questions/34745066/dummyimplicits-is-this-used-and-how/34746255?stw=2#34746255" rel="noopener ugc nofollow" target="_blank"/>)看起来像这样:</p><pre class="ln lo lp lq fq lz ly ma mb aw mc dt"><span id="165b" class="md kj hu ly b fv me mf l mg mh">fun &lt;A, B&gt; Option&lt;A&gt;.apply(f: Option&lt;(A) -&gt; B&gt;, <br/>                           dummyImplicit: Any? = null): Option&lt;B&gt; = <br/>when (this) {<br/>    is Option.None -&gt; Option.None<br/>    is Option.Some -&gt; f.map { it(value) }<strong class="ly hv"><br/></strong>}</span></pre><p id="c714" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这使我们能够:</p><pre class="ln lo lp lq fq lz ly ma mb aw mc dt"><span id="72ef" class="md kj hu ly b fv me mf l mg mh">Some(2).<em class="lu">apply</em>(Some(<strong class="ly hv">{ </strong>a: Int <strong class="ly hv">-&gt; </strong>a + 3 <strong class="ly hv">}</strong>))<br/>// =&gt; Some(5)</span></pre><p id="35ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但不幸的是，这使得中缀不可能，因为中缀函数只有一个参数:(</p></div><div class="ab cl mu mv hc mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="hn ho hp hq hr"><p id="accb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以，按照我们之前的解释，使用<em class="lu">应用</em>会导致一些有趣的情况。例如:</p><pre class="ln lo lp lq fq lz ly ma mb aw mc dt"><span id="e39a" class="md kj hu ly b fv me mf l mg mh">arrayOf&lt;(Int) -&gt; Int&gt;({ it + 3 }, { it * 2 }) <em class="lu">apply </em>arrayOf(1, 2, 3)<br/>// =&gt; [ 4, 5, 6, 2, 4, 6 ]</span></pre><figure class="ln lo lp lq fq lr fe ff paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="fe ff nb"><img src="../Images/6988fadf9c0f31c3a199eb6938c35225.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dTv-_gpKc-DbXIx7.png"/></div></div></figure><blockquote class="mj mk ml"><p id="c5ac" class="ir is lu it b iu iv iw ix iy iz ja jb mm jd je jf mn jh ji jj mo jl jm jn jo hn dt translated"><strong class="it hv"> <em class="hu">注:</em> </strong> <em class="hu">原来的文章现在展示了应用程序如何比函子更强大，因为它们允许函数应用多个参数。同样，这在vanilla Kotlin中是不可行的，但是我们可以通过在一个</em> <a class="ae ll" href="https://en.wikipedia.org/wiki/Currying" rel="noopener ugc nofollow" target="_blank"> <em class="hu"> curried方式</em> </a> <em class="hu">中定义我们想要处理的函数来解决这个问题。</em></p></blockquote><p id="5678" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里有一些你可以用应用程序做，但不能用函子做的事情。如何应用一个将两个参数传递给两个包装值的函数？</p><pre class="ln lo lp lq fq lz ly ma mb aw mc dt"><span id="a2dc" class="md kj hu ly b fv me mf l mg mh">fun curriedAddition(a: Int) = { b: Int -&gt;<br/>    a + b<br/>}</span><span id="435d" class="md kj hu ly b fv mi mf l mg mh">Some(3) map ::curriedAddition map Some(2)<br/>// =&gt; COMPILER ERROR</span></pre><p id="b2fd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">适用范围:</p><pre class="ln lo lp lq fq lz ly ma mb aw mc dt"><span id="0b59" class="md kj hu ly b fv me mf l mg mh">Some(3) map ::curriedAddition apply Some(2)<br/>// =&gt; Some(5)</span></pre><p id="b144" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">等等，什么？？让我一步一步地分解它:</p><pre class="ln lo lp lq fq lz ly ma mb aw mc dt"><span id="c664" class="md kj hu ly b fv me mf l mg mh">Some(3) map ::curriedAddition<br/>// =&gt; Some({ 3 + b })</span><span id="1380" class="md kj hu ly b fv mi mf l mg mh">Some({ 3 + b }) apply Some(2)<br/>// =&gt; Some(5)</span></pre><p id="ccbb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lv lw lx ly b">Applicative</code>将<code class="eh lv lw lx ly b">Functor</code>推到一边。“大男孩可以使用带有任意数量参数的函数，”它说。“有了map和apply，我就可以使用任何期望任意数量的展开值的函数。然后我传递给它所有包装好的值，我得到一个包装好的值！啊哈哈哈哈！”</p><pre class="ln lo lp lq fq lz ly ma mb aw mc dt"><span id="c27b" class="md kj hu ly b fv me mf l mg mh">fun curriedTimes(a: Int) = <strong class="ly hv">{ </strong>b: Int <strong class="ly hv">-&gt;<br/>    </strong>a * b<br/><strong class="ly hv">}</strong></span><span id="a4a6" class="md kj hu ly b fv mi mf l mg mh">Some(3) map ::curriedTimes apply Some(5)<br/>// =&gt; Some(15)</span></pre><p id="e52d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是等等，如果我们想更深入呢？</p><figure class="ln lo lp lq fq lr fe ff paragraph-image"><div class="fe ff nc"><img src="../Images/261827cfa2ecf113a369a00c5f3177c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*cmUv1wycDkmX3CQWYBRm2g.png"/></div></figure><p id="ac5a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设我们有一个三重乘积函数:</p><pre class="ln lo lp lq fq lz ly ma mb aw mc dt"><span id="1c97" class="md kj hu ly b fv me mf l mg mh">fun tripleProduct(a: Int, b: Int, c: Int) = a * b * c</span></pre><p id="6974" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们想做和以前一样的事情，但是我们不想手动搜索它，所以我们有一个搜索函数，在这个例子中有3个参数:</p><pre class="ln lo lp lq fq lz ly ma mb aw mc dt"><span id="3615" class="md kj hu ly b fv me mf l mg mh">fun &lt;A, B, C, D&gt; curry(f: (A, B, C) -&gt; D): (A) -&gt; (B) -&gt; (C) -&gt; D = <strong class="ly hv">{ </strong>a <strong class="ly hv">-&gt; { </strong>b <strong class="ly hv">-&gt; { </strong>c <strong class="ly hv">-&gt; </strong>f(a, b, c) <strong class="ly hv">} } }</strong></span></pre><blockquote class="mj mk ml"><p id="9cd2" class="ir is lu it b iu iv iw ix iy iz ja jb mm jd je jf mn jh ji jj mo jl jm jn jo hn dt translated">感谢<a class="nd ne gr" href="https://medium.com/u/e856388adc0e?source=post_page-----f99a09efd1ec--------------------------------" rel="noopener" target="_blank">ľuboš·穆德拉克</a>的建议！</p></blockquote><p id="1207" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">嗯，那很简单:</p><pre class="ln lo lp lq fq lz ly ma mb aw mc dt"><span id="ed12" class="md kj hu ly b fv me mf l mg mh">Some(3) map <em class="lu">curry</em>(::tripleProduct) apply Some(5) apply Some(4)<br/>// =&gt; Some(60)</span></pre><h2 id="fa7e" class="md kj hu bd kk nf ng nh ko ni nj nk ks jc nl nm kw jg nn no la jk np nq le nr dt translated">就是这样！希望你和我一样喜欢这第二部分，记住你可以在我创建的<a class="ae ll" href="https://github.com/aballano/FAM-Playground" rel="noopener ugc nofollow" target="_blank">游乐场回购</a>中找到所有代码，希望在下一个也是最后一个系列中见到你！</h2><p id="e6ed" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">第三也是最后一部分已经有了”</p><div class="jp jq fm fo jr js"><a rel="noopener follow" target="_blank" href="/@aballano/kotlin-functors-applicatives-and-monads-in-pictures-part-3-3-832d58d92445"><div class="jt ab ej"><div class="ju ab jv cl cj jw"><h2 class="bd hv fv z el jx eo ep jy er et ht dt translated">图中的科特林函子、应用和单子。第三部分</h2><div class="jz l"><h3 class="bd b fv z el jx eo ep jy er et ek translated">这是从Haskell到Kotlin的图片中的函子、应用程序和单子的翻译。</h3></div><div class="ka l"><p class="bd b gc z el jx eo ep jy er et ek translated">medium.com</p></div></div><div class="kb l"><div class="ns l kd ke kf kb kg kh js"/></div></div></a></div><div class="ln lo lp lq fq ab cb"><figure class="nt lr nu nv nw nx ny paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nt lr nu nv nw nx ny paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nt lr nu nv nw nx ny paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mj mk ml"><p id="f922" class="ir is lu it b iu iv iw ix iy iz ja jb mm jd je jf mn jh ji jj mo jl jm jn jo hn dt translated">黑客中午是黑客如何开始他们的下午。我们是这个家庭的一员。我们现在<a class="ae ll" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ll" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is lu it b iu iv iw ix iy iz ja jb mm jd je jf mn jh ji jj mo jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ll" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ll" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ln lo lp lq fq lr fe ff paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="fe ff nz"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="ln lo lp lq fq lr"><div class="bz el l di"><div class="oa ob l"/></div></figure></div></div>    
</body>
</html>