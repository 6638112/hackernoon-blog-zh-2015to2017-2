<html>
<head>
<title>Runtime Introspection of Flow Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">流类型的运行时自省</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/runtime-introspection-of-flow-types-ddb7e5b042a5?source=collection_archive---------1-----------------------#2016-10-02">https://medium.com/hackernoon/runtime-introspection-of-flow-types-ddb7e5b042a5?source=collection_archive---------1-----------------------#2016-10-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="ed3c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">感谢飓风马修席卷哥伦比亚，我不得不利用我的时间做一些有意义的事情。所以很自然地，我一直在考虑类型系统，特别是<a class="ae jp" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>的<strong class="it hv"> Flowtype </strong>。</p><p id="79a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的团队在Red Badger使用流类型已经有一段时间了，我们已经看到了一些真正的好处。也就是说，更健壮的代码更容易、更安全地重构，并且由于使用了优秀的核素ide工具，生产率显著提高(感谢脸书！).</p><p id="267e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不参与静态和动态打字的争论，我相信<strong class="it hv">渐进打字</strong>提供了自信和灵活性的极好平衡。我看到它在一个大的(重要的)JavaScript代码库上有效地工作。</p><h1 id="59f7" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">灵感</h1><p id="0b04" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">昨天我在clojure.spec 上看了一场精彩的《奇兵》脱口秀:</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">Stuart Halloway’s Talk on clojure.spec</figcaption></figure><p id="e481" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于那些不熟悉的人来说，它是动态类型语言Clojure的规范语言。它允许开发人员指定函数期望的一些数据的形状，并指定在执行之前或之后应该满足的一些不变量。它似乎受到了契约式设计的启发，并且与T10型系统提供的保证有一定的重叠。</p><p id="98c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，clojure.spec背后的强大思想是这些规范的执行完全由开发人员决定。尽管有一些内置的实用功能的帮助。为此，规范必须在运行时可用<strong class="it hv">。</strong></p><p id="6c8d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">静态类型语言通常只在编译时使用类型信息。然而，像C#和Java这样的语言也有在运行时访问类型信息的机制，作为“<strong class="it hv">反射API”、</strong>的一部分已经有很长时间了<strong class="it hv">。</strong></p><p id="de38" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了将来自<strong class="it hv"> core.spec </strong>的一些想法引入JS，我着手为流类型化JavaScript构建一个类似的特性。</p><h1 id="8d43" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">在运行时公开流类型</h1><p id="dd4b" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">Flow是用OCaml而不是JavaScript编写的，类型检查发生在开发过程中的Flow流程中。这意味着JavaScript无法访问类型信息。</p><p id="36b1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，Flow的用户通常通过Babel运行他们的JS代码，其中<strong class="it hv"> flow-strip-types </strong>删除任何注释并输出可执行代码。为了保留类型信息，我们可以用<strong class="it hv"> flow-runtime-types、</strong>我为此编写的一个小转换库<strong class="it hv">来代替这个插件。</strong></p><p id="443a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> flow-runtime-types </strong>将我们的流注释的AST暴露给运行时代码，然后我们可以解释这个AST来构建一些有趣的特性。</p><p id="3ccc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">AST看起来像这样:</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="le kz l"/></div></figure><p id="008b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">理解起来非常简单，并且足够低，可以构建一些利用它的工具。</p><h1 id="8d2d" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">用例</h1><h2 id="f6fa" class="lf jr hu bd js lg lh li jw lj lk ll ka jc lm ln ke jg lo lp ki jk lq lr km ls dt translated">类型一致性验证</h2><p id="f3b0" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在任何系统的边缘，无论是否进行了类型检查，都有必要实现验证逻辑来确保数据处于正确的形式。当使用Flow时，将这些规则编码成类型系统的一部分，然后再编码成可执行代码的一部分，可能会觉得多余。</p><p id="7b31" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">相反，我们可以利用流注释AST来产生数据的自动运行时验证。</p><p id="df96" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我选择将流类型转换成Joi模式对象(<a class="ae jp" href="https://github.com/hapijs/joi" rel="noopener ugc nofollow" target="_blank">https://github.com/hapijs/joi</a>)，这样验证就可以由一个久经考验的库来处理。例如，使用上面的类型定义:</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="le kz l"/></div></figure><p id="a245" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这并不意味着我们可以删除所有其他的验证逻辑，因为没有办法在Flow中编码任意的约束(例如，字符串的最大长度)。然而，它的确将我们从结构验证的单调中解救出来，因此我们可以转而关注于验证数据的<strong class="it hv">语义</strong>。</p><p id="4bd6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我已经实现了这一点，作为Flow中基本类型和一般类型的概念证明，它似乎工作得很有效。我们当然也可以使用这种方法来完全取代React组件中的运行时<strong class="it hv"> propType验证</strong>。</p><h2 id="a36e" class="lf jr hu bd js lg lh li jw lj lk ll ka jc lm ln ke jg lo lp ki jk lq lr km ls dt translated">为基于属性的/单元测试生成测试用例</h2><p id="f424" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们还可以使用流AST来生成有效的fixtures，以便在基于单元或属性的测试中使用。用法如下:</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="le kz l"/></div></figure><p id="b0dc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以多次执行这个函数，为我们的系统产生随机但有效的输出。当应用于UI <a class="ae jp" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>时，我们可以在<strong class="it hv">基于属性的测试</strong>或<strong class="it hv">模糊测试</strong>(如在<a class="ae jp" href="https://github.com/carteb/carte-blanche" rel="noopener ugc nofollow" target="_blank">https://github.com/carteb/carte-blanche</a>等工具中所见)中直接使用它。</p><h1 id="f622" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">局限性和改进</h1><p id="d9b1" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">这种方法的一个限制是运行时自省只适用于<strong class="it hv">显式类型声明。</strong>流的主要好处之一是类型推断。解决这一限制可以采用以下方法之一:</p><ul class=""><li id="7b0d" class="lt lu hu it b iu iv iy iz jc lv jg lw jk lx jo ly lz ma mb dt translated">通过带有`— json '标志的CLI从流中请求类型化的AST信息。核素和其他工具使用这种类型的集成。完成这项工作所需的具体电话还不存在，但正在https://github.com/facebook/flow/issues/248进行讨论。</li><li id="0ea1" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo ly lz ma mb dt translated">将Flow (OCaml)编译成JS。使用像https://github.com/ocsigen/js_of_ocaml这样的工具，这在理论上是可能的，并且会打开许多其他的集成机会，但是看起来像是T2的大量工作。如果可能的话，这也意味着我们可以直接使用Flow的类型系统模型，而不是在JavaScript中重新实现我们自己的较弱的形式。</li></ul><h1 id="17fe" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">相关项目</h1><ul class=""><li id="3758" class="lt lu hu it b iu ko iy kp jc mh jg mi jk mj jo ly lz ma mb dt translated">【https://github.com/codemix/babel-plugin-typecheck T4】</li><li id="89e9" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo ly lz ma mb dt translated"><a class="ae jp" href="https://github.com/gcanti/babel-plugin-tcomb" rel="noopener ugc nofollow" target="_blank">https://github.com/gcanti/babel-plugin-tcomb</a></li></ul><h1 id="fd11" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">有意思？</h1><p id="3749" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">您能想到运行时类型自省的其他用例吗？或者更简单的实现方式？</p><p id="ad64" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">GitHub上提供了概念验证，但尚未分发给NPM:</p><div class="mk ml fm fo mm mn"><a href="https://github.com/JoeStanton/babel-transform-flow-introspection" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab ej"><div class="mp ab mq cl cj mr"><h2 class="bd hv fv z el ms eo ep mt er et ht dt translated">乔斯坦顿/巴别塔-转换-流动-内省</h2><div class="mu l"><h3 class="bd b fv z el ms eo ep mt er et ek translated">babel-transform-flow-introspection-Rough PoC用于向运行时代码公开流类型注释</h3></div><div class="mv l"><p class="bd b gc z el ms eo ep mt er et ek translated">github.com</p></div></div><div class="mw l"><div class="mx l my mz na mw nb nc mn"/></div></div></a></div><blockquote class="nd ne nf"><p id="ced9" class="ir is ng it b iu iv iw ix iy iz ja jb nh jd je jf ni jh ji jj nj jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is ng it b iu iv iw ix iy iz ja jb nh jd je jf ni jh ji jj nj jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上给我们点赞/发消息</a>，或者简单地说，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is ng it b iu iv iw ix iy iz ja jb nh jd je jf ni jh ji jj nj jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="nk kz l"/></div></figure></div></div>    
</body>
</html>