<html>
<head>
<title>The Problem with MongoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MongoDB的问题</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-problem-with-mongodb-d255e897b4b?source=collection_archive---------1-----------------------#2017-02-13">https://medium.com/hackernoon/the-problem-with-mongodb-d255e897b4b?source=collection_archive---------1-----------------------#2017-02-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/96d1b321a6f9122c384575614e98394e.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*KHIQHTqhFobGU_q0cL6orw.png"/></div></figure><p id="593a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">当构建一个需要存储数据的web应用程序(或任何应用程序)时，要做的最大决定之一是使用什么数据库。在初创企业的世界里，MVP和敏捷开发占据了主导地位，NoSQL数据库在<a class="ae jw" href="http://www.techrepublic.com/article/nosql-databases-eat-into-the-relational-database-market/" rel="noopener ugc nofollow" target="_blank">中增长，越来越受欢迎</a>主要是因为它们的<a class="ae jw" href="http://www.ibmbigdatahub.com/blog/rise-nosql-databases" rel="noopener ugc nofollow" target="_blank">灵活的</a>特性和易用性。其中，MongoDB是迄今为止最受欢迎的<a class="ae jw" href="http://db-engines.com/en/ranking" rel="noopener ugc nofollow" target="_blank"/>。<a class="ae jw" href="http://mongoosejs.com/" rel="noopener ugc nofollow" target="_blank">mongose</a>是Nodejs中MongoDB的一款神奇的ODM，它也越来越受欢迎，从2015年到2016年，npm下载数量几乎翻了一番<a class="ae jw" href="https://npm-stat.com/charts.html?package=mongoose&amp;from=2012-01-01&amp;to=2016-12-31" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="8b70" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">对于使用Nodejs/javascript的web应用程序，MongoDB特别好，因为数据是使用JSON对象存储的，使得读写数据变得流畅自然。然而，尽管有这些巨大的优势，MongoDB仍然缺少关系数据库中最有用的特性之一，即…关系。</p><figure class="jy jz ka kb fq iv fe ff paragraph-image"><div class="fe ff jx"><img src="../Images/744b6c0da81bbc887a922b1d2fef66c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*yX49yeWyB5nTg7eLTiroSA.jpeg"/></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Not how it works…</figcaption></figure><p id="a609" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">对于几乎任何存储数据的应用程序来说，不同的数据实体之间自然会有关系。用户有角色，购物车有商品，书籍有类别……你明白了。这些关系通常采取三种不同的形式之一:一对一、一对多和多对多。虽然MongoDB不是关系数据库，但实际上有两种推荐的方法来表示实体之间的关系。让我们看看每一个，看看它们是如何产生的。</p><p id="1016" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><em class="kg">注意:如果您觉得自己已经熟悉这个话题，或者只是想要一个解决方案，请随意向下滚动至脾气暴躁的猫……(或者只需查看</em><a class="ae jw" href="https://github.com/JKHeadley/rest-hapi" rel="noopener ugc nofollow" target="_blank"><em class="kg">rest-hapi</em></a><em class="kg">)</em></p></div><div class="ab cl kh ki hc kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hn ho hp hq hr"><h2 id="dd02" class="ko kp hu bd kq kr ks kt ku kv kw kx ky jj kz la lb jn lc ld le jr lf lg lh li dt translated">方法1: <a class="ae jw" href="https://docs.mongodb.com/v3.0/tutorial/model-embedded-one-to-many-relationships-between-documents/" rel="noopener ugc nofollow" target="_blank">嵌入文件</a></h2><p id="aae6" class="pw-post-body-paragraph iy iz hu ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hn dt translated">在MongoDB中关联数据(表示为<a class="ae jw" href="https://docs.mongodb.com/v3.0/reference/glossary/#term-document" rel="noopener ugc nofollow" target="_blank">文档</a>)最自然的方法是将它们嵌入到另一个中。这种方法的优点是只需一次查询就可以检索所有相关数据。这是非常高效的，一开始看起来不错。有时这可能是一种合适的方法，但是依赖嵌入式关系可能会付出很高的代价。考虑一个用户和角色的例子，其中用户可以属于一个角色，而角色可以有多个用户。在这种情况下，我们可以选择将用户文档嵌入到角色文档中，反之亦然。如果我们决定用户是最重要的实体，角色应该嵌入其中，那么我们最终会得到如下所示的数据:</p><pre class="jy jz ka kb fq lo lp lq lr aw ls dt"><span id="aba4" class="ko kp hu lp b fv lt lu l lv lw">Users:<br/>[<br/>   {<br/>      _id: 1234,<br/>      email: 'bob@admin.com',<br/>      role: {<br/>         name: 'Admin',<br/>         description: 'A user with awesome powers.'<br/>      }<br/>   },<br/>   {<br/>      _id: 4321,<br/>      email: 'bill@admin.com',<br/>      role: {<br/>         name: 'Admin',<br/>         description: 'A user with awesome powers.'<br/>      }<br/>   }<br/>]</span></pre><p id="88f6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">当我们想改变一个角色的细节时，他的方法就出现了问题。如果我们更新第一个用户的角色描述，第二个用户的角色描述保持不变。这是一个问题，如果我们想保持一致，我们几乎总是这样做。对于只有两个用户的情况来说，这似乎不是一个大问题，但是如果有数百个用户呢？查找和更新每个嵌入的角色听起来并不有趣。</p><p id="f4fe" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">意识到这一点，我们可以选择将用户嵌入角色中。这可能会产生如下数据:</p><pre class="jy jz ka kb fq lo lp lq lr aw ls dt"><span id="a201" class="ko kp hu lp b fv lt lu l lv lw">Roles:<br/>[<br/>   {<br/>      _id: 5678,<br/>      name: 'Admin',<br/>      description: 'A user with awesome powers.',<br/>      users: [<br/>         {<br/>            email: 'bob@admin.com'<br/>         },<br/>         {<br/>            email: 'bill@admin.com'<br/>         }<br/>      ]<br/>   }<br/>]</span></pre><p id="a675" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">问题解决了，对吧？当然，如果我们的数据库中没有其他实体与用户有关系…这是不太可能的。如果我们有另一个实体“团队”，它可以与多个用户相关联，那么我们又回到了起点。更新用户的电子邮件必须反映在用户所在的任何角色或团队中。随着实体和关系数量的增长，一致性问题会变得更快。这通常会导致代码混乱不堪。我们开始时的效率也消失了。所以也许有更好的方法？让我们看看下一种方法。</p><h2 id="ada3" class="ko kp hu bd kq kr ks kt ku kv kw kx ky jj kz la lb jn lc ld le jr lf lg lh li dt translated">方法二:<a class="ae jw" href="https://docs.mongodb.com/v3.0/tutorial/model-referenced-one-to-many-relationships-between-documents/" rel="noopener ugc nofollow" target="_blank">文件参考</a></h2><p id="50b7" class="pw-post-body-paragraph iy iz hu ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hn dt translated">我们可以给每个文档一个id并存储相关的文档id，而不是整个文档，而不是将文档嵌入到另一个文档中。让我们来看看上一个例子中的数据，它是这样表示的:</p><pre class="jy jz ka kb fq lo lp lq lr aw ls dt"><span id="ed65" class="ko kp hu lp b fv lt lu l lv lw">Users:<br/>[<br/>   {<br/>      _id: 1234,<br/>      email: 'bob@admin.com',<br/>      role: 5678<br/>   },<br/>   {<br/>      _id: 4321,<br/>      email: 'bill@admin.com',<br/>      role: 5678<br/>   }<br/>]</span><span id="64a0" class="ko kp hu lp b fv lx lu l lv lw">Roles:<br/>[<br/>   {<br/>      _id: 5678,<br/>      name: 'Admin',<br/>      description: 'A user with awesome powers.',<br/>      users: [<br/>         1234,<br/>         4321<br/>      ]<br/>   }<br/>]</span></pre><p id="34f0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，无论何时更新文档，都不需要其他操作，因为引用id不会改变。一致性问题解决！然而，有一个权衡。在方法1中，只需要一个查询就可以获取与用户(或角色)相关的所有数据。现在，为了获得角色及其相关用户的数据，我们必须首先执行一个角色查询，然后执行另一个查询，根据id查找用户。这可能看起来没那么糟糕，但也可能很快失控。让我们引入团队实体，再次查看我们的数据:</p><pre class="jy jz ka kb fq lo lp lq lr aw ls dt"><span id="a392" class="ko kp hu lp b fv lt lu l lv lw">Users:<br/>[<br/>   {<br/>      _id: 1234,<br/>      email: 'bob@admin.com',<br/>      role: 5678<br/>   },<br/>   {<br/>      _id: 4321,<br/>      email: 'bill@admin.com',<br/>      role: 5678<br/>   }<br/>]</span><span id="82ef" class="ko kp hu lp b fv lx lu l lv lw">Roles:<br/>[<br/>   {<br/>      _id: 5678,<br/>      name: 'Admin',<br/>      description: 'A user with awesome powers.',<br/>      users: [<br/>         1234,<br/>         4321<br/>      ]<br/>   }<br/>]</span><span id="767f" class="ko kp hu lp b fv lx lu l lv lw">Teams:<br/>[<br/>   {<br/>      _id: 1357,<br/>      name: 'Managers',<br/>      description: 'They manage things.',<br/>      users: [<br/>         1234<br/>      ]<br/>   },<br/>   {<br/>      _id: 9753,<br/>      name: 'Editors',<br/>      description: 'They edit things.',<br/>      users: [<br/>         4321<br/>      ]<br/>   }<br/>]</span></pre><p id="0a5c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，如果我们想要检索一个角色中包含的所有数据，我们必须执行与前面相同的两个查询，以及第三个更复杂的查询来填充每个用户的团队数据。作为开发人员，您现在不得不为每种需要检索相关数据的情况编写复杂的查询处理程序。</p><p id="8b1d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果您试图通过web api检索这些数据，这将变得更加困难。api必须接受某种“嵌入”查询参数，每个端点都需要支持逻辑来填充嵌套数据。除此之外，还需要更多的逻辑来支持基于引用对象的过滤查询。这个问题通常会导致许多过于特定的端点，这些端点带有针对不同实体结构的不同“类型”查询的定制逻辑。这种方法也可能很快导致难以扩展、难以维护的代码。</p><figure class="jy jz ka kb fq iv fe ff paragraph-image"><div class="fe ff ly"><img src="../Images/7c3193fb519a398574ca5695cd0b5727.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*f1Tsk-T8fVuXzPr0g1kTtg.jpeg"/></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">In this case…yes</figcaption></figure><h2 id="0d57" class="ko kp hu bd kq kr ks kt ku kv kw kx ky jj kz la lb jn lc ld le jr lf lg lh li dt translated">那现在怎么办？</h2><p id="486f" class="pw-post-body-paragraph iy iz hu ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hn dt translated">那么我们应该采取哪种方法呢？理想情况下，您会希望混合使用针对您的整体模型结构优化的嵌入和引用关系。问题是这不可能从一开始就做到，因为模型结构在开发过程中必然会改变(即敏捷开发)，通常从一开始就试图“优化”事情可能是一种<a class="ae jw" href="http://seanhess.github.io/2011/12/15/optimization_is_like_firing_clay.html" rel="noopener ugc nofollow" target="_blank">被误导的方法</a>。</p><p id="f92d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">作为解决这些问题的尝试，我构建了一个名为<a class="ae jw" href="https://github.com/JKHeadley/rest-hapi" rel="noopener ugc nofollow" target="_blank"> rest-hapi </a>的工具。在我之前的<a class="ae jw" href="https://hackernoon.com/the-problem-with-apis-331f08f7a39c#.f1uch63vr" rel="noopener ugc nofollow" target="_blank">帖子</a>中，我讨论了rest-hapi如何通过将端点逻辑封装到<a class="ae jw" href="https://resthapi.com/docs/creating-endpoints.html" rel="noopener ugc nofollow" target="_blank">模型配置</a>中来简化api的开发。从那时起，rest-hapi已经升级为一个<a class="ae jw" href="https://www.npmjs.com/package/rest-hapi" rel="noopener ugc nofollow" target="_blank"> npm模块</a> / <a class="ae jw" href="https://hapijs.com/plugins" rel="noopener ugc nofollow" target="_blank"> hapi插件</a>，也可以用作mongoose ODM的<a class="ae jw" href="https://resthapi.com/docs/mongoose-wrapper-methods.html" rel="noopener ugc nofollow" target="_blank">包装器</a>。</p><p id="0d92" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">使用rest-hapi，<a class="ae jw" href="https://resthapi.com/docs/associations.html" rel="noopener ugc nofollow" target="_blank">实体关系</a>被定义为模型配置的一部分，并且提供了支持添加、移除、填充和查询关系数据的包装器方法。它甚至支持一个等价形式的<a class="ae jw" href="https://resthapi.com/docs/associations.html#linking-models" rel="noopener ugc nofollow" target="_blank">连接表</a>，用于需要特定关系实例数据的多对多关系。虽然这可能不是一个优化的解决方案，但我相信它确实支持一个优化的开发环境。rest-hapi允许开发人员专注于以敏捷的方式开发应用程序，并快速启动和运行。它结合了MongoDB著名的灵活性和关系结构的强大功能。</p><figure class="jy jz ka kb fq iv fe ff paragraph-image"><div class="fe ff lz"><img src="../Images/a0392afab08e46ee3ba75a678f683676.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*kUWyDV-zOa36gotDryDV_A.jpeg"/></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Fast and Flexible</figcaption></figure><p id="fd98" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我最近的努力是开发一个样板用户系统(名为<a class="ae jw" href="https://github.com/JKHeadley/appy" rel="noopener ugc nofollow" target="_blank"> appy </a>),它提供通用的用户服务，同时利用rest-hapi的能力提供一个全功能的应用引导程序。我刚刚完成了第一个版本，到目前为止，我觉得它体现了rest-hapi的有用性。appy中实现的<a class="ae jw" href="https://github.com/JKHeadley/appy-backend/wiki/Authorization" rel="noopener ugc nofollow" target="_blank">权限系统</a>甚至利用连接表支持来允许启用/禁用特定的权限关系。</p><p id="b21b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我希望你能花些时间看看<a class="ae jw" href="https://github.com/JKHeadley/rest-hapi" rel="noopener ugc nofollow" target="_blank"> rest-hapi </a>和<a class="ae jw" href="https://github.com/JKHeadley/appy" rel="noopener ugc nofollow" target="_blank"> appy </a>。我觉得他们可以为开发者社区做出重大贡献。如果您有任何反馈，请随时在下面留下评论或在<a class="ae jw" href="https://github.com/JKHeadley/rest-hapi/issues" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中提出问题。如果你想联系我，你可以通过推特<a class="ae jw" href="https://twitter.com/JKHeadley" rel="noopener ugc nofollow" target="_blank">、脸书</a><a class="ae jw" href="https://www.facebook.com/justinkheadley" rel="noopener ugc nofollow" target="_blank">、领英</a>或电子邮件<a class="ae jw" href="mailto:headley.justin@gmail.com" rel="noopener ugc nofollow" target="_blank">headley.justin@gmail.com</a>联系我。我希望你喜欢这篇文章，感谢阅读！</p><div class="jy jz ka kb fq ab cb"><figure class="ma iv mb mc md me mf paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="ma iv mb mc md me mf paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="ma iv mb mc md me mf paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mg mh mi"><p id="f922" class="iy iz kg ja b jb jc jd je jf jg jh ji mj jk jl jm mk jo jp jq ml js jt ju jv hn dt translated"><a class="ae jw" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jw" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jw" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae jw" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="iy iz kg ja b jb jc jd je jf jg jh ji mj jk jl jm mk jo jp jq ml js jt ju jv hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jw" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jw" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jy jz ka kb fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="fe ff mm"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>