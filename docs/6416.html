<html>
<head>
<title>Writing Your Own Sink Connector for Your Kafka Stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为你的Kafka栈编写你自己的接收器连接器</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/writing-your-own-sink-connector-for-your-kafka-stack-fa7a7bc201ea?source=collection_archive---------3-----------------------#2017-09-17">https://medium.com/hackernoon/writing-your-own-sink-connector-for-your-kafka-stack-fa7a7bc201ea?source=collection_archive---------3-----------------------#2017-09-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/44c2cfeca47dcd47228d2e9f5c2bb0b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eC3fKob7FdMJqITZX5ZX6w.png"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">The image from <a class="ae ih" href="https://www.confluent.io/blog/announcing-kafka-connect-building-large-scale-low-latency-data-pipelines/" rel="noopener ugc nofollow" target="_blank">here.</a></figcaption></figure><div class=""/><p id="b0e2" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您的系统可能没有Kafka接口，或者现有的接口可能不符合您的要求。在这两种情况下，您都必须编写自己的Kafka连接器，并且没有太多关于它的在线资源。我会试着写下我的冒险经历来帮助其他遭受同样痛苦的人。</p><p id="0d35" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">下面是我的例子:我想从Kafka主题中读取数据，如果数据的状态字段中有“insert”标志，则将它们写入弹性索引，如果状态为“delete ”,则将它们删除。我知道我不能使用官方或任何其他开源弹性接收器连接器，因为它们有一个通用的行为选项，不依赖于数据，而是连接器配置。</p><p id="4406" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于本地开发和测试，我使用了<a class="ae ih" href="https://github.com/Landoop/fast-data-dev" rel="noopener ugc nofollow" target="_blank"> Landoop的快速数据开发项目</a>，因为它在一个docker容器中包含了Zookeeper、Kafka、Connect和足够的UI工具。</p><h2 id="ea2a" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">做好准备</h2><p id="dad5" class="pw-post-body-paragraph jh ji ik jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">如果您想编写自己的源或接收器连接器，您必须使用Java，因为我们的主要想法是从我们的项目中创建一些jar，这些jar将成为我们本地Kafka Connect集群的插件，或独立服务器。所以，确保你有JDK在你的本地。我使用IntelliJ IDEA是因为我是JetBrains的粉丝。</p><h2 id="e2d6" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">使用自定义Connect Maven原型创建您的项目</h2><p id="7f51" class="pw-post-body-paragraph jh ji ik jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">你的项目有一个<a class="ae ih" href="https://maven.apache.org/guides/introduction/introduction-to-archetypes.html" rel="noopener ugc nofollow" target="_blank"> maven原型</a>，包括一堆框架类。为了通过IntelliJ使用它，您可以在创建新项目时添加它。这里是它的<a class="ae ih" href="https://github.com/jcustenborder/kafka-connect-archtype" rel="noopener ugc nofollow" target="_blank"> Github库。</a></p><figure class="lg lh li lj fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lf"><img src="../Images/a92899fb3c781cafdd690aca83e62261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mTLegDS-lTwK2btwDTkYnQ.png"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Not forget to use the latest version. <a class="ae ih" href="https://github.com/jcustenborder/kafka-connect-archtype" rel="noopener ugc nofollow" target="_blank">Check it out from its repo.</a></figcaption></figure><h2 id="d972" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">我们要建造什么？</h2><p id="5bdd" class="pw-post-body-paragraph jh ji ik jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">正如我所说的，我们将创建一个定制的弹性接收器连接器，它将根据主题数据进行操作。我将解释这个项目最重要的部分，请<a class="ae ih" href="https://github.com/skynyrd/kafka-connect-elastic-sink" rel="noopener ugc nofollow" target="_blank">克隆我的库</a>来捕捉下面的片段。</p><h2 id="3c3e" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">ElasticSinkConnectorConfig.java</h2><p id="76c0" class="pw-post-body-paragraph jh ji ik jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">您将使用这个类来获取配置属性，它是一个非常简单的类。首先，您应该定义您的配置元素，例如:</p><figure class="lg lh li lj fq hw fe ff paragraph-image"><div class="fe ff lk"><img src="../Images/f9ead940d3dee2d080f7ea4ad99e798a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eU0RvdA98BaR4TnMTnuDoA.png"/></div><figcaption class="id ie fg fe ff if ig bd b be z ek"><a class="ae ih" href="https://github.com/skynyrd/kafka-connect-elastic-sink/blob/master/src/main/java/com/skynyrd/kafka/ElasticSinkConnectorConfig.java" rel="noopener ugc nofollow" target="_blank">Link to source</a></figcaption></figure><p id="113e" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">是将用于我们的弹性传输客户端的配置属性，或者您可以说是弹性驱动程序。<code class="eh ll lm ln lo b">ELASTIC_PORT_DOC</code>是被<code class="eh ll lm ln lo b">ConfigDef</code>静态方法使用的解释属性。</p><p id="4cf8" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh ll lm ln lo b">ConfigDef</code>是kafka公共包中的一个方法，我们在这里绑定了我们所有的属性:</p><figure class="lg lh li lj fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lp"><img src="../Images/56b80c6bc689be0a8998e5c95a40603d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N4rq7nmX2wGZB1QkszKRIA.png"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek"><a class="ae ih" href="https://github.com/skynyrd/kafka-connect-elastic-sink/blob/master/src/main/java/com/skynyrd/kafka/ElasticSinkConnectorConfig.java" rel="noopener ugc nofollow" target="_blank">Link to source</a></figcaption></figure><p id="5517" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">文件的其余部分包括属性的getters和setters，这里并不复杂。</p><h2 id="4381" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">ElasticSinkConnector.java</h2><p id="3002" class="pw-post-body-paragraph jh ji ik jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">如果您在从一个主题开始消费或停止连接器时有事情要做，这是您应该实现的类。</p><p id="e7ad" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">只是检查一下方法:</p><ul class=""><li id="6e26" class="lq lr ik jj b jk jl jo jp js ls jw lt ka lu ke lv lw lx ly dt translated"><code class="eh ll lm ln lo b">version()</code>返回连接器的版本，</li><li id="c0f3" class="lq lr ik jj b jk lz jo ma js mb jw mc ka md ke lv lw lx ly dt translated"><code class="eh ll lm ln lo b">start()</code>从<code class="eh ll lm ln lo b">connector.properties</code>获取配置，并将它们传递给我们上面讨论过的<code class="eh ll lm ln lo b">ElasticSinkConnectorConfig</code>类，</li><li id="8602" class="lq lr ik jj b jk lz jo ma js mb jw mc ka md ke lv lw lx ly dt translated"><code class="eh ll lm ln lo b">taskClass()</code>返回执行实际工作的类——从主题和流程中获取数据。(我们马上就要谈到这一点)，</li><li id="26cd" class="lq lr ik jj b jk lz jo ma js mb jw mc ka md ke lv lw lx ly dt translated"><code class="eh ll lm ln lo b">stop()</code>是你的连接器的一种拆卸功能，</li><li id="54b6" class="lq lr ik jj b jk lz jo ma js mb jw mc ka md ke lv lw lx ly dt translated"><code class="eh ll lm ln lo b">config()</code>为我们返回配置类— <code class="eh ll lm ln lo b">ElasticSinkConnectorConfig</code>，</li></ul><p id="3e93" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">而<code class="eh ll lm ln lo b">taskConfigs()</code>是给你的任务。我们已经将配置分配给这里的所有任务:(顺便说一下，你应该从worker配置中给<em class="me"> tasks.max </em>属性，这里的<a class="ae ih" href="https://stackoverflow.com/a/42030617" rel="noopener ugc nofollow" target="_blank">是它应该有的值)</a></p><figure class="lg lh li lj fq hw fe ff paragraph-image"><div class="fe ff mf"><img src="../Images/a6e21e41ac5b0cc66e8731852ddd2abf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*3Nz5wvSgK6DTDFXaqHeN1A.png"/></div><figcaption class="id ie fg fe ff if ig bd b be z ek">By the way, I still could not realized how many task should be set for an optimal configuration.. <a class="ae ih" href="https://github.com/skynyrd/kafka-connect-elastic-sink/blob/master/src/main/java/com/skynyrd/kafka/ElasticSinkConnector.java" rel="noopener ugc nofollow" target="_blank">Link to source</a></figcaption></figure><h2 id="d6e6" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">ElasticSinkTask.java</h2><p id="be42" class="pw-post-body-paragraph jh ji ik jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">这是你从已配置的主题中获取数据的类，在<code class="eh ll lm ln lo b">start()</code>方法中，我创建了一个<code class="eh ll lm ln lo b">ElasticServiceImpl</code>的实例，我没有使用任何依赖注入策略，因为测试插件覆盖方法非常困难，并且需要某种<a class="ae ih" href="https://softwareengineering.stackexchange.com/questions/184464/what-is-an-anti-corruption-layer-and-how-is-it-used" rel="noopener ugc nofollow" target="_blank">反腐败层</a>。出于这个原因，当我在<code class="eh ll lm ln lo b">put()</code>方法中获得数据时，我在稍加修改后直接将其发送给<code class="eh ll lm ln lo b">ElasticServiceImpl</code>并测试我的服务，而不是<code class="eh ll lm ln lo b">ElasticSinkTask</code>类。在弹性服务的构造函数中，我将<code class="eh ll lm ln lo b">null</code>作为<code class="eh ll lm ln lo b">ElasticClient</code>传递，因为我将在测试类中传递它。于是，我的主处理类就变成了<code class="eh ll lm ln lo b">ElasticServiceImpl</code>了。</p><p id="9c61" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">具有讽刺意味的是，我还没有编写任何测试类，我将实现它们。</p><p id="c821" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个类最重要的事情是你应该小心使用<code class="eh ll lm ln lo b">put()</code>方法，因为Kafka Connect在这个方法中提交数据偏移。因此，这里应该进行适当的错误处理。</p><h2 id="f2b4" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">ElasticServiceImpl.java</h2><p id="bd36" class="pw-post-body-paragraph jh ji ik jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">在构造函数中，我们在创建<code class="eh ll lm ln lo b">ElasticClient</code>的实例之前设置了<code class="eh ll lm ln lo b">JsonConverter</code>和<code class="eh ll lm ln lo b">Gson</code>序列化器。</p><p id="40b1" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在<code class="eh ll lm ln lo b">process()</code>方法中，我将记录字符串转换为<code class="eh ll lm ln lo b">Record</code>数据类型，因为它更具可读性和可处理性。</p><figure class="lg lh li lj fq hw fe ff paragraph-image"><div class="fe ff mg"><img src="../Images/a9587c2ee42207748460431c100fd437.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*nhNlg34ArG5K6s6yV9kZGg.png"/></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Topic message representation. <a class="ae ih" href="https://github.com/skynyrd/kafka-connect-elastic-sink/blob/master/src/main/java/com/skynyrd/kafka/Record.java" rel="noopener ugc nofollow" target="_blank">Link to source</a></figcaption></figure><p id="ab5f" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">玩了一些<code class="eh ll lm ln lo b">Gson</code>的方法把<code class="eh ll lm ln lo b">string</code> s转换成<code class="eh ll lm ln lo b">Record</code> s后，就准备送弹性了。</p><h2 id="c523" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">ElasticClientImpl.java</h2><p id="75f3" class="pw-post-body-paragraph jh ji ik jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">作为一个弹性客户端，我首先尝试使用<a class="ae ih" href="https://www.elastic.co/guide/en/elasticsearch/client/java-api/5.4/transport-client.html" rel="noopener ugc nofollow" target="_blank">传输客户端</a>，因为它像另一个节点一样连接到您的弹性集群，并且<a class="ae ih" href="https://www.elastic.co/blog/benchmarking-rest-client-transport-client" rel="noopener ugc nofollow" target="_blank">批量索引</a>比<code class="eh ll lm ln lo b">http</code>协议稍微快一点。然而，我遇到了一个错误，却找不到任何解决方法，<a class="ae ih" href="https://stackoverflow.com/questions/46179241/nosuchmethoderror-when-constructing-prebuilttransportclient-for-elastic" rel="noopener ugc nofollow" target="_blank">甚至我问了StackOverflow </a>。我认为这可能与<code class="eh ll lm ln lo b">fast-data-dev </code>容器，或者<code class="eh ll lm ln lo b">docker</code>网络配置等有关。然后我切换到<a class="ae ih" href="https://github.com/searchbox-io/Jest" rel="noopener ugc nofollow" target="_blank"> Jest客户端</a>，因为<code class="eh ll lm ln lo b">http</code>协议性能也与我上面提到的同一篇文章密切相关。</p><p id="e701" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在<code class="eh ll lm ln lo b">bulkSend()</code>方法中，我们简单地将<code class="eh ll lm ln lo b">dataList</code>中的每个数据添加到<code class="eh ll lm ln lo b">Bulk</code>中，如果<code class="eh ll lm ln lo b">Record</code>的<code class="eh ll lm ln lo b">behavior</code>为<code class="eh ll lm ln lo b">insert</code>，则添加索引请求，否则将删除请求附加到<code class="eh ll lm ln lo b">Bulk</code>。</p><p id="fc8b" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果出现任何错误，我们会将其发送给Elastic并记录下来:</p><figure class="lg lh li lj fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mh"><img src="../Images/fc30a69371e068b20b8a828ba00c0c72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jdi2cIvF8j-ccxIuxJtPOg.png"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek"><a class="ae ih" href="https://github.com/skynyrd/kafka-connect-elastic-sink/blob/master/src/main/java/com/skynyrd/kafka/client/ElasticClientImpl.java" rel="noopener ugc nofollow" target="_blank">Link to source</a></figcaption></figure><h2 id="c8ac" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">结论</h2><p id="80d8" class="pw-post-body-paragraph jh ji ik jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">总之，如果我们的系统没有社区实现，我们必须编写自己的接收器或源连接器。也可以有现成的连接器，但你可能需要改变其行为。</p><p id="dcc4" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个过程中最具挑战性的部分是测试您的连接器。你实现的是你的连接集群的某种插件，它不是一个独立的应用程序。编写单元测试很棘手，因为你覆盖了Kafka Connect包的方法，并且需要某种反腐败层。调试也相当困难。</p><p id="9082" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您可以使用我编写的<code class="eh ll lm ln lo b">docker-compose</code>文件并按照<a class="ae ih" href="https://github.com/skynyrd/kafka-connect-elastic-sink" rel="noopener ugc nofollow" target="_blank">我的库</a>中的步骤来测试连接器。</p><p id="3bf3" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">谢谢，</p><p id="021e" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有时候我会发一些有用的信息:<a class="ae ih" href="https://twitter.com/_skynyrd" rel="noopener ugc nofollow" target="_blank"> @_skynyrd </a></p><p id="8280" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我用过的有用资源:</p><ul class=""><li id="ca83" class="lq lr ik jj b jk jl jo jp js ls jw lt ka lu ke lv lw lx ly dt translated">https://docs.confluent.io/current/connect/devguide.html<a class="ae ih" href="https://docs.confluent.io/current/connect/devguide.html" rel="noopener ugc nofollow" target="_blank"/></li><li id="dcd9" class="lq lr ik jj b jk lz jo ma js mb jw mc ka md ke lv lw lx ly dt translated"><a class="ae ih" href="https://www.udemy.com/kafka-streams/" rel="noopener ugc nofollow" target="_blank">夏羽·马瑞克的Udemy课程</a>。</li></ul></div></div>    
</body>
</html>