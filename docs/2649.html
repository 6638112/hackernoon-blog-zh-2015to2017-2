<html>
<head>
<title>Changing mindset with functional concepts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用功能概念改变思维模式</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/changing-mindset-with-functional-concepts-af3b2492c116?source=collection_archive---------15-----------------------#2017-02-08">https://medium.com/hackernoon/changing-mindset-with-functional-concepts-af3b2492c116?source=collection_archive---------15-----------------------#2017-02-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/220a12f49cdb7a0b370f318c66ace5a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yJ-SxLviEE2f4i4xM88JCw.png"/></div></div></figure><div class=""/><p id="c04b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我第一次听说函数式编程(FP)时，我认为它是另一个没有人需要的被过度宣传的东西。我生活在我快乐的面向对象世界中，不认为有什么是我应该改变的。直到我看了<a class="ae ka" href="https://www.youtube.com/watch?v=7Zlp9rKHGD4" rel="noopener ugc nofollow" target="_blank">非常有说服力的视频</a>，在那里鲍勃叔叔描述了为什么FP如此重要。</p><p id="15bc" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我决定试一试。我开始使用小的，不是很流行的，但是非常功能化(正如人们描述的)的JavaScript库。叫做React.js。</p><p id="75d8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我很快意识到函数概念是多么强大。我们无时无刻不在使用它们，甚至不知道。</p><h1 id="bfd1" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">纯洁</h1><p id="bf55" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">React是一个库，用于创建带有一些所需逻辑的HTML视图。主要构件是一个“组件”。</p><p id="6e2e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">组件接受数据并返回HTML。</p><p id="8519" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个例子:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="f09d" class="ln kc if lj b fv lo lp l lq lr">const SomeComponent = ({data}) =&gt; { <br/>  return ( <br/>    &lt;div&gt; &lt;h1&gt;{data.title}&lt;/h1&gt; &lt;p&gt;{data.text}&lt;/h1&gt; &lt;/div&gt; <br/>  ) <br/>}</span></pre><blockquote class="ls lt lu"><p id="064b" class="jc jd lv je b jf jg jh ji jj jk jl jm lw jo jp jq lx js jt ju ly jw jx jy jz hn dt translated">注意:上面的代码是有效的JavaScript。它使用<a class="ae ka" href="https://facebook.github.io/react/docs/jsx-in-depth.html" rel="noopener ugc nofollow" target="_blank"> JSX语法扩展</a>。</p></blockquote><p id="a007" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如您所见，遵循代码非常容易。诀窍是<strong class="je ig">给定相同的输入，该组件将总是给出相同的输出。</strong></p><p id="fcee" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有可能是因为<code class="eh lz ma mb lj b">SomeComponent</code>不访问任何外部状态，也不调用任何外部API。它是纯的，没有任何副作用。你不需要担心在这个函数调用过程中会发生一些意想不到的魔法。</p><p id="85e4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在FP中，这些函数被称为<em class="lv">纯函数</em>。它们只处理它们接受的参数，不访问外部状态。</p><p id="1089" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是你可能会问，这些副作用到底是什么？举几个例子:</p><ul class=""><li id="0136" class="mc md if je b jf jg jj jk jn me jr mf jv mg jz mh mi mj mk dt translated">访问数据库</li><li id="c934" class="mc md if je b jf ml jj mm jn mn jr mo jv mp jz mh mi mj mk dt translated">写入磁盘</li><li id="c626" class="mc md if je b jf ml jj mm jn mn jr mo jv mp jz mh mi mj mk dt translated">网络通信</li><li id="3e67" class="mc md if je b jf ml jj mm jn mn jr mo jv mp jz mh mi mj mk dt translated">显示数据</li><li id="cc61" class="mc md if je b jf ml jj mm jn mn jr mo jv mp jz mh mi mj mk dt translated">触发事件</li></ul><p id="637c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">避免副作用</strong>是另一个直接来自函数式编程的核心概念。</p><p id="043c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不可能写出完全没有副作用的应用程序。关键是把它们放在一个地方。最好是在应用程序的“边缘”。</p><p id="4d8a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过这样做，您可以获得两个重要的好处——可组合性和更简单的测试。可以想象，测试第一个例子中的函数是非常容易的。您只需要提供一些参数并测试输出。不需要复杂的模仿库。</p><p id="f43a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你得到的好处是:结构良好的代码，更少的重构问题，更容易的调试和可扩展性。</p><p id="ce8b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用酶文库进行测试的例子:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="1537" class="ln kc if lj b fv lo lp l lq lr">it('renders SomeComponent', () =&gt; { <br/>  const wrapper = shallowRender( <br/>    &lt;SomeComponent data={{title: 'hello', text: 'world'}} /&gt; <br/>  ); <br/>  expect(wrapper.find('h1')).to.have.length(1);<br/>  expect(wrapper.find('p')).to.have.length(1); <br/>});</span></pre><p id="8644" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">纯函数也支持合成。假设您有更多的数据要呈现，并且视图稍微复杂一些:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="43e6" class="ln kc if lj b fv lo lp l lq lr">const data = { <br/>  menu: [ <br/>    {link: 'http://netflix.com', title: 'Netflix'}, <br/>    {link: 'https://www.primevideo.com/', title: 'Amazon Prime'} <br/>    // ... <br/>  ], <br/>  title: 'Some Heading', text: 'Lorem ipsum...' <br/>} </span><span id="26b8" class="ln kc if lj b fv mq lp l lq lr">const MenuComponent = ({menu}) =&gt; { <br/>  const menuHtml = menu.map(menuElement =&gt; ( <br/>    &lt;a href={menuElement.link}&gt;{menuElement.title}&lt;/a&gt; <br/>  )) </span><span id="62b0" class="ln kc if lj b fv mq lp l lq lr">  return ( <br/>    &lt;div&gt;{menuHtml}&lt;/div&gt; <br/>  ) <br/>} </span><span id="0eb9" class="ln kc if lj b fv mq lp l lq lr">const SomeComponent = ({data}) =&gt; { <br/>  return ( <br/>    &lt;div&gt; <br/>      &lt;h1&gt;{data.title}&lt;/h1&gt; <br/>      &lt;MenuComponent menu={data.menu} /&gt; // passing menu array here<br/>      &lt;p&gt;{data.text}&lt;/p&gt; <br/>    &lt;/div&gt; <br/>  ) <br/>} </span><span id="e453" class="ln kc if lj b fv mq lp l lq lr">render(<br/>  &lt;SomeComponent data={data} /&gt;, <br/>  document.getElementById('main') <br/>)</span></pre><blockquote class="ls lt lu"><p id="3a72" class="jc jd lv je b jf jg jh ji jj jk jl jm lw jo jp jq lx js jt ju ly jw jx jy jz hn dt translated">注意:请将本文中的所有代码示例视为伪代码。</p></blockquote><p id="00a2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">拥有两个纯函数— <code class="eh lz ma mb lj b">MenuComponent</code>和<code class="eh lz ma mb lj b">SomeComponent</code>，允许你以任何你想要的方式将它们混合在一起。尽管如此，你不需要担心副作用，因为这些功能没有它们。</p><h1 id="3df0" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">不变</h1><p id="0028" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">上面的例子中缺少的是数据操作。在传统编程中，数据操作通常是通过改变值来完成的。</p><p id="b03c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个简单的例子:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="df42" class="ln kc if lj b fv lo lp l lq lr">const doSomethingToTheArray = arr =&gt; { <br/>  array.push(4) // mutating the original array <br/>} </span><span id="9c69" class="ln kc if lj b fv mq lp l lq lr">const anArray = [1, 2, 3] <br/>doSomethingToTheArray(anArray) // [1, 2, 3, 4]</span></pre><p id="09a9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种模式可能非常危险。</p><p id="0361" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设您需要将同一个数组传递给其他函数。这些功能也可以改变这种状态。</p><p id="539c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">确定状态在哪里被改变的唯一方法是遵循代码。有时几层下来。</p><p id="9349" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最终<em class="lv">引入了共享的可变状态</em>。有人认为它是万恶之源(我同意)。</p><p id="cd2e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">浏览器事件、API调用等。会在不可预知的时间发生。鉴于此，跟踪应用程序中共享状态的所有变化很快就变得很麻烦。</p><p id="8c4d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有什么选择？</p><p id="59ef" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">FP引入了不变性的概念——你不能改变一个曾经被创建的值。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="0afd" class="ln kc if lj b fv lo lp l lq lr">const doSomethingToTheArray = arr =&gt; { <br/>  return array.concat(4) // no mutation, returning new array <br/>} </span><span id="3cd2" class="ln kc if lj b fv mq lp l lq lr">const anArray = [1, 2, 3] <br/>const newArray = doSomethingToTheArray(anArray) // no mutation</span></pre><p id="a202" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果不变异任何状态，就不用处理并发问题。</p><p id="1a0d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，在我看来，还有更重要的建筑效益。<strong class="je ig">状态在一个地方管理，因此更容易跟踪变化。</strong></p><p id="9c41" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们专注于此。</p><p id="6149" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在React中，如果您沿着组件树向下传递状态，它将永远不会被重新分配。</p><p id="75d6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那么如何改变这种状态呢？</p><p id="8a5b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">定义状态的组件负责处理所有的更改。假设您想要通过单击子组件中的某个按钮来修改状态。要做到这一点，您不仅需要传递数据，还需要能够更改数据的处理程序。</p><p id="d15f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个代码示例胜过千言万语，所以让我们看看它是如何工作的。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="c683" class="ln kc if lj b fv lo lp l lq lr">// a way to define a stateful compnent<br/>const StatefulComponent = React.createClass({<br/>  getInitialState () { // defining initial state<br/>    return {<br/>      data: [1, 2, 3]<br/>    }<br/>  },<br/><br/>  // a handler changing state<br/>  changeSomeState (newValue) {<br/>    // built-in function to change the state<br/>    this.setState(({data}) =&gt; {<br/>      return {<br/>        data: data.concat(newValue)<br/>      }<br/>    })<br/>  },<br/><br/>  return (<br/>    &lt;div&gt;<br/>      &lt;ChildComponent<br/>        changeSomeState={this.changeSomeState}<br/>        data={this.state.data}<br/>      /&gt;<br/><br/>      &lt;SomeOtherComponentDiplayingData data={this.state.data} /&gt;<br/><br/>      &lt;SomeOtherComponentChangingData<br/>        changeSomeState={this.changeSomeState}<br/>        data={this.state.data}<br/>      /&gt;<br/>    &lt;/div&gt;<br/>  )<br/>})<br/><br/>const ChildComponent = ({data, changeSomeState}) =&gt; {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;button onClick={() =&gt; {changeSomeState(4)}}&gt;Click&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="7579" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh lz ma mb lj b">StatefulComponent</code>遵循我之前提到的原则——它拥有国家，并且是唯一可以改变国家的地方。<code class="eh lz ma mb lj b">ChildComponent</code>只是一个傀儡，它在点击按钮时调用<code class="eh lz ma mb lj b">changeSomeState</code>处理程序。它调用传递的函数来更改状态，但不能直接修改状态。</p><p id="ed86" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">看看跟踪状态有多容易。您会立即知道它在哪里使用，以及哪个子组件使用该处理程序来修改它。</p><p id="1275" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们知道还有一个显示状态的组件(<code class="eh lz ma mb lj b">SomeOtherComponentDiplayingData</code>)，还有一个改变状态的组件(<code class="eh lz ma mb lj b">SomeOtherComponentChangingData</code>)。</p><p id="cb97" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">几乎没有关于状态管理的认知负荷。你只需要看一下<code class="eh lz ma mb lj b">StatefulComponent</code>就可以知道你可以执行什么样的状态修改。</p><p id="10f6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我曾经遇到过这样一种情况，我们在项目中与国家管理层发生冲突。它看起来像这样:</p><figure class="le lf lg lh fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mr"><img src="../Images/24425e189a3591992520ad02c46560ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jgxu-NMSMr-ED9gCh24qeg.png"/></div></div></figure><p id="b47c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们遵循上面描述的原则，它可能看起来像这样:</p><figure class="le lf lg lh fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mr"><img src="../Images/987c562938c4d9b68372fd4cc6bf64e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jS6BAQBcbPvg71gZJ9KXyw.png"/></div></div></figure><p id="ac76" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你喜欢哪一个？</p><h1 id="b480" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">Redux</h1><p id="9a1c" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">当使用前端代码时，您可以通过在组件之外抽象状态管理来帮助自己。</p><p id="f958" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最受欢迎的库是Redux。</p><p id="bbb3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是脸书人描述的<a class="ae ka" href="http://facebook.github.io/flux/" rel="noopener ugc nofollow" target="_blank">通量架构</a>的一个实现，大约在同一时间React出现了。</p><p id="83d1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">前提是要有一个全局状态容器。状态不是保存在有状态的组件中，而是保存在全局存储中。</p><p id="0153" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您想要执行状态更改，您需要发出一个操作。然后，动作被分派到商店。存储处理所有更改，然后通知所有订阅者新的状态，以便他们可以获取它并重新呈现视图。</p><figure class="le lf lg lh fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mr"><img src="../Images/9ca759168533d0c6f10e8fdd8c3e5699.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2m0nWA2086hsGI_k9OdzIQ.png"/></div></div><figcaption class="ms mt fg fe ff mu mv bd b be z ek">source: <a class="ae ka" href="https://facebook.github.io/flux" rel="noopener ugc nofollow" target="_blank">https://facebook.github.io/flux</a></figcaption></figure><blockquote class="ls lt lu"><p id="f517" class="jc jd lv je b jf jg jh ji jj jk jl jm lw jo jp jq lx js jt ju ly jw jx jy jz hn dt translated">注意:<a class="ae ka" href="http://redux.js.org/docs/introduction/PriorArt.html" rel="noopener ugc nofollow" target="_blank">“Redux没有调度员的概念”</a></p></blockquote><p id="7f22" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Redux本身功能就很强大。负责状态修改的“存储”部分被称为“还原器”，它们是接受某种状态和动作的纯函数。它们返回修改的状态。</p><p id="6faf" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">来自<a class="ae ka" href="http://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux docs </a>的一个例子:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="835f" class="ln kc if lj b fv lo lp l lq lr">// todos reducer<br/>function todos(state = [], action) {<br/>  // Somehow calculate it...<br/>  switch (action.type) {<br/>    case 'ADD':<br/>      return state.concat(action.payload)<br/>    default:<br/>      return state<br/>  }<br/>  return nextState<br/>}<br/><br/>const addTodoAction = {type: 'ADD', payload: 'write a blog post'}</span></pre><p id="48c8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Redux将通过向<code class="eh lz ma mb lj b">todos</code>减速器和<code class="eh lz ma mb lj b">addTodoAction</code>一起提供先前的状态来处理动作。运行减速器后，将返回新状态。</p><p id="4ce6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">同样，抽象状态管理使得测试变得容易。您需要提供一些状态和动作。这样你可以毫无困难地测试任何你能想到的案例。</p><p id="3d04" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">来自<a class="ae ka" href="http://redux.js.org/docs/recipes/WritingTests.html" rel="noopener ugc nofollow" target="_blank"> Redux docs </a>的测试示例:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="b2c6" class="ln kc if lj b fv lo lp l lq lr">it('should handle ADD_TODO', () =&gt; {<br/>  const initialState = []<br/>  expect(<br/>    reducer(initialState, {<br/>      type: types.ADD_TODO,<br/>      text: 'Run the tests'<br/>    })<br/>  ).toEqual(<br/>    [<br/>      {<br/>        text: 'Run the tests',<br/>        completed: false,<br/>        id: 0<br/>      }<br/>    ]<br/>  )<br/>)}</span></pre><p id="a7cb" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您的状态管理变得复杂，并且希望引入更多的可预测性，您可能希望尝试Redux。</p><h1 id="aaff" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">高阶函数</h1><p id="0947" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">有时组件需要用一些公共逻辑来修饰。例如，获取用户权限以启用/禁用某些字段。</p><p id="eba9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">React允许您为处理这些情况的组件定义包装器。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="de97" class="ln kc if lj b fv lo lp l lq lr">// component that requires user rights<br/>const WrappedComponent = ({user}) =&gt; {<br/>  if (user.isAdmin) {<br/>    return &lt;AdminStuff /&gt;<br/>  }<br/><br/>  return &lt;RegularStuff /&gt;<br/>}<br/><br/>// wrapper function<br/>const withUserRights = Component =&gt; React.createClass({<br/>  getInitialState () {<br/>    return {<br/>      user: null<br/>    }<br/>  }<br/><br/>  componentDidMount () {<br/>    this.setState({user: getUserData()})<br/>  },<br/><br/>  render () {<br/>    return &lt;Component user={this.state.user} /&gt;<br/>  }<br/>})<br/><br/>// usage<br/>const WrappedComponentWithUserRights = withUserRights(WrappedComponent)</span></pre><p id="2131" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh lz ma mb lj b">withUserRights</code>函数返回一个组件，它是一个<strong class="je ig">高阶组件</strong> (HOC)。在React文档的高级技术部分可以找到对这种技术的描述。但说实话，它很快就变得有用了。</p><p id="9eae" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如文档中所描述的，HOC是一个接受一个组件并返回一个新组件的函数。<br/>这个概念是从FP那里借来的，在FP那里它被称为高阶函数。</p><p id="f7d9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">高阶函数是将函数作为参数、返回函数或两者都做的函数。</p><p id="2074" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最基本的例子是“map()”。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="ea4e" class="ln kc if lj b fv lo lp l lq lr">const mapped = [1, 2, 3].map(n =&gt; n + 1) <br/>// [2, 3, 4]</span></pre><p id="5461" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这完全是抽象的。例如，<code class="eh lz ma mb lj b">map()</code>是一个抽象的<code class="eh lz ma mb lj b">for</code>循环，它正在组装新的数组。当你使用内置的抽象，比如<code class="eh lz ma mb lj b">map()</code>、<code class="eh lz ma mb lj b">filter()</code>或<code class="eh lz ma mb lj b">forEach()</code>时，引入错误的机会更小。你可以忘记像计数器递增这样的低级概念。</p><p id="ef7d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">想象更复杂(有点夸张)的函数链:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="8a88" class="ln kc if lj b fv lo lp l lq lr">const Wrapped = withSuperFeatureNumber3Enabled( <br/>  withFancyHeader( <br/>    withUserRights(WrappedComponent) <br/>  ) <br/>)</span></pre><p id="eaba" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">本例中的每一层抽象都封装了一些公共逻辑。代码变得更加清晰<strong class="je ig">你可以看到其他程序员的想法</strong>。代码易于理解，使用组合可以更好地重用代码。</p><h1 id="7f58" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">摘要</h1><p id="c9e6" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">有许多源自FP的技巧你可以每天使用。这些是函数式编程最基本的构件，但我发现它们是最有用的。</p><p id="0287" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">没有副作用的纯函数给你更好的抽象和组合。再加上不变性和可预测的状态管理，您最终会得到更少的易错代码和更少的认知负荷。<br/>高阶函数给你一个更好的普通逻辑的抽象，并且在纯函数中表现出色。</p><p id="3ead" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我真的鼓励你深入挖掘，因为FP在未来会变得更加有用。</p><p id="e847" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你正在寻找知识的来源，我推荐阅读:</p><p id="2c47" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我经常重复<strong class="je ig">函数式编程是一种思维模式</strong>。心态的坏处是不容易改变。在FP的情况下，我觉得是值得的。<a class="ae ka" href="https://signalvnoise.com/posts/3124-give-it-five-minutes" rel="noopener ugc nofollow" target="_blank">再等五分钟</a>。</p></div><div class="ab cl mw mx hc my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="hn ho hp hq hr"><p id="356d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="lv">最初发布于</em><a class="ae ka" href="https://www.future-processing.pl/blog/changing-mindset-with-functional-concepts/" rel="noopener ugc nofollow" target="_blank"><em class="lv">www . future-processing . pl</em></a><em class="lv">。</em></p><div class="le lf lg lh fq ab cb"><figure class="nd hw ne nf ng nh ni paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nd hw ne nf ng nh ni paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nd hw ne nf ng nh ni paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ls lt lu"><p id="f922" class="jc jd lv je b jf jg jh ji jj jk jl jm lw jo jp jq lx js jt ju ly jw jx jy jz hn dt translated">黑客中午是黑客如何开始他们的下午。我们是这个家庭的一员。我们现在<a class="ae ka" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ka" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd lv je b jf jg jh ji jj jk jl jm lw jo jp jq lx js jt ju ly jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ka" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ka" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="le lf lg lh fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nj"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>