<html>
<head>
<title>Motion Detection in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript中的运动检测</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/motion-detection-in-javascript-2614adea9325?source=collection_archive---------11-----------------------#2017-08-14">https://medium.com/hackernoon/motion-detection-in-javascript-2614adea9325?source=collection_archive---------11-----------------------#2017-08-14</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/15bd4fa25a57755a0c6745a483719741.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*x_NlArecwPLdhEu-SIBiow.gif"/></div></div></figure><div class=""/><p id="80c6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">制造计算机参见</em></p><p id="4a7f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">学习纯javascript创造性编码系列的一部分。更多</em> <a class="ae kb" rel="noopener" href="/@radarboy3000">见此处<em class="ka"/></a><em class="ka">。并在这里得到文件</em><a class="ae kb" href="https://github.com/GeorgeGally/creative_coding" rel="noopener ugc nofollow" target="_blank"><em class="ka"/></a><em class="ka">。</em></p><p id="556b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有很多技术和库可以用来检测和处理相机的运动数据。但是大多数情况下，一个简单的解决方案比你需要的要多。我发现滚动我自己的运动检测代码给了我更好的性能、灵活性和理解。95%的情况下，你只需要这个简单的方法。所以让我们开始吧…</p><p id="a299" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们要使用的技术很简单。我们将前一帧的颜色与当前帧的颜色进行比较。如果它们高于某个阈值，我们可以假设有运动。</p><p id="2e29" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当然没必要每个像素都比较。这对我们的计算机来说太费力了，而且经常会给系统带来不必要的噪音。因此，我们将使用与上一个教程<a class="ae kb" href="https://hackernoon.com/creating-a-pixelation-filter-for-creative-coding-fc6dc1d728b2" rel="noopener ugc nofollow" target="_blank">相似的技术来创建一个像素化滤镜</a>。</p><p id="5b45" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，我们需要让您的网络摄像头在浏览器中工作。我不打算深入讨论这个问题。到处都有很多教程。老实说，这没什么意思(还有点罗嗦)。我已经创建了一个可重复使用的<a class="ae kb" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> Javascript </a>文件，所以我再也不需要重写代码，甚至不需要费心启动你的网络摄像头……<a class="ae kb" href="https://github.com/GeorgeGally/creative_coding/blob/master/js/video.js" rel="noopener ugc nofollow" target="_blank">下面是代码</a>。只需将它包含在html中，就像处理任何javascript文件一样，它会自动创建一个默认大小为320x240px的<em class="ka"> video </em>元素，该元素通过css隐藏。</p><p id="b754" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">(实际上，我们可以以较小的尺寸绘制它，然后扩大我们的计算，并获得进一步的性能提升，稍后我会向您展示这一点。但是现在让我们保持事情简单。</p><p id="4100" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要将视频绘制到屏幕上，我们只需引用视频并使用canvas <em class="ka"> drawImage() </em>函数:</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="0ade" class="kl km if kh b fv kn ko l kp kq">ctx.drawImage(video, 0, 0, w, h);</span></pre><p id="ed20" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们想遍历像素并得到它们的颜色值…</p><figure class="kc kd ke kf fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff kr"><img src="../Images/86bc014860bb0445cca26ce543bcb2b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ZNIHrna1C3gOHNTsNNO8Qw.gif"/></div></div></figure><p id="aec3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">代码与使用<em class="ka"> getImageData() </em>创建<a class="ae kb" href="https://hackernoon.com/creating-a-pixelation-filter-for-creative-coding-fc6dc1d728b2" rel="noopener ugc nofollow" target="_blank">像素化效果</a>完全相同，除了我们使用的是实时视频:</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="7bb1" class="kl km if kh b fv kn ko l kp kq"><em class="ka">// setup canvas</em><br/>var ctx = createCanvas("canvas1");</span><span id="b858" class="kl km if kh b fv ks ko l kp kq">// sample the colour of every 50 pixels<br/>var sample_size = 50;</span><span id="08e3" class="kl km if kh b fv ks ko l kp kq">function draw(){</span><span id="38a6" class="kl km if kh b fv ks ko l kp kq"><em class="ka">  // draw video onto screen</em><br/>  ctx.drawImage(video, 0, 0, w, h);</span><span id="cc9c" class="kl km if kh b fv ks ko l kp kq"><em class="ka">  // get the screen's pixels data</em><br/>  var data = ctx.getImageData(0, 0, w, h).data;</span><span id="1ef3" class="kl km if kh b fv ks ko l kp kq"><em class="ka">  // loop through rows and columns<br/>  </em><strong class="kh ig">for (var y = 0; y &lt; h; y+= sample_size) {</strong></span><span id="3d7b" class="kl km if kh b fv ks ko l kp kq"><strong class="kh ig">    for (var x = 0; x &lt; w; x+= sample_size) {</strong></span><span id="14f1" class="kl km if kh b fv ks ko l kp kq"><em class="ka">      // the data array is a continuous array of red, blue, green <br/>      // and alpha values, so each pixel takes up four values <br/>      // in the array</em><br/>      <strong class="kh ig">var pos = (x + y * w) * 4;</strong><br/>      <br/>      <em class="ka">// get red, blue and green pixel value<br/>      </em><strong class="kh ig">var r = data[pos];<br/>      var g = data[pos+1];<br/>      var b = data[pos+2];</strong></span><span id="a145" class="kl km if kh b fv ks ko l kp kq">      <em class="ka">// draw the pixels as blocks of colours</em><br/>      <strong class="kh ig">ctx.fillStyle = rgb(r, g, b);<br/>      ctx.fillRect(x, y, sample_size, sample_size);</strong></span><span id="3a64" class="kl km if kh b fv ks ko l kp kq">    <strong class="kh ig">}<br/>  }</strong></span><span id="84ca" class="kl km if kh b fv ks ko l kp kq">}</span></pre><p id="c3bb" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">运动测试:</strong></p><p id="0fc4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了测试视频中是否有运动，我们现在需要做的就是将我们前一帧的像素值存储在一个数组中，并将这些值与当前值进行比较…如果差值高于某个阈值，那么就有运动。</p><figure class="kc kd ke kf fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff kt"><img src="../Images/6f6037fddd1cc19a14c72b874b9cbc3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*V1oIHvQM27-dlRR-pft4Gw.gif"/></div></div></figure><p id="6b11" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以做一个公式来计算RGB值的总和，或者看看亮度，但在大多数情况下，我们只需要比较红色值…</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="bfd7" class="kl km if kh b fv kn ko l kp kq"><em class="ka">// make an array to hold our old pixel values</em><strong class="kh ig"><br/>var previous_frame = [];<br/></strong>// choose a brightness threshold, if the old pixel values differs enough then we know there's movement<br/><strong class="kh ig">var threshold = 50; <br/></strong>// sample the colour every 50 pixels<br/>var sample_size = 50;</span><span id="da1f" class="kl km if kh b fv ks ko l kp kq">function draw(){</span><span id="91a0" class="kl km if kh b fv ks ko l kp kq">  ctx.drawImage(video, 0, 0, w, h);<br/>  var data = ctx.getImageData(0, 0, w, h).data;<br/>  ctx.background(0);<br/>  <br/>  for (var y = 0; y &lt; h; y+= sample_size) {<br/>    <br/>     for (var x = 0; x &lt; w; x+= sample_size) {</span><span id="b639" class="kl km if kh b fv ks ko l kp kq">      var pos = (x + y * w) * 4;<br/>      var r = data[pos];<br/>      var g = data[pos+1];<br/>      var b = data[pos+2];</span><span id="d46c" class="kl km if kh b fv ks ko l kp kq">      // first check if it's not the first frame, but <br/>       // seeing of when the <em class="ka">previous_frame</em> array <br/>      // is not we empty, and then only draw something if there's <br/>      // a significant colour difference <br/>      <strong class="kh ig">if(previous_frame[pos] <br/>      &amp;&amp; Math.abs(previous_frame[pos] - r) &gt; threshold) {</strong><br/>        ctx.fillStyle = rgb(r, g, b);<br/>        ctx.fillRect(x, y, sample_size, sample_size);<br/>     <strong class="kh ig"> }</strong></span><span id="5c91" class="kl km if kh b fv ks ko l kp kq"><em class="ka">      // store these colour values to compare to the next frame<br/>      </em><strong class="kh ig">previous_frame[pos] = r;</strong></span><span id="4631" class="kl km if kh b fv ks ko l kp kq">    }<br/>  <br/>  }</span><span id="b449" class="kl km if kh b fv ks ko l kp kq">}</span></pre><p id="4d27" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在你知道了。这就是运动检测的基本原理。非常简洁明了。</p><p id="f792" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了使我们的代码更容易阅读和处理，让我们快速地将运动检测代码放入一个函数中。除了添加一个运动数组来存储所有的运动点及其颜色值，然后返回这些值之外，我们不需要做太多的修改:</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="cd09" class="kl km if kh b fv kn ko l kp kq">function motionDetection(){</span><span id="87fc" class="kl km if kh b fv ks ko l kp kq">  <br/>  <em class="ka">// create an array to store our motion data</em><br/>  <strong class="kh ig">var motion = [];</strong></span><span id="912c" class="kl km if kh b fv ks ko l kp kq">  ctx.drawImage(video, 0, 0, w, h);<br/>  var data = ctx.getImageData(0, 0, w, h).data;<br/>  ctx.background(0);<br/>  <br/>  for (var y = 0; y &lt; h; y+= sample_size) {<br/>    <br/>     for (var x = 0; x &lt; w; x+= sample_size) {</span><span id="fe06" class="kl km if kh b fv ks ko l kp kq">      var pos = (x + y * w) * 4;<br/>      var r = data[pos];<br/>      var g = data[pos+1];<br/>      var b = data[pos+2];</span><span id="b5e5" class="kl km if kh b fv ks ko l kp kq">      // first check if it's not the first frame, but <br/>      // seeing of when the <em class="ka">previous_frame</em> array <br/>      // is not we empty, and then only draw something if there's <br/>      // a significant colour difference <br/>      ctx.drawImage(video, 0, 0, w, h);<br/>      var data = ctx.getImageData(0, 0, w, h).data;<br/>      ctx.background(0);<br/>  <br/>      for (var y = 0; y &lt; h; y+= sample_size) {<br/>    <br/>        for (var x = 0; x &lt; w; x+= sample_size) {</span><span id="a50e" class="kl km if kh b fv ks ko l kp kq">           var pos = (x + y * w) * 4;<br/>           var r = data[pos];<br/>           var g = data[pos+1];<br/>           var b = data[pos+2];</span><span id="f61e" class="kl km if kh b fv ks ko l kp kq">           // first check if it's not the first frame, but <br/>           // seeing of when the <em class="ka">previous_frame</em> array <br/>           // is not we empty, and then only draw something if <br/>           // a significant colour difference there's<br/>           if(previous_frame[pos] <br/>           &amp;&amp; Math.abs(previous_frame[pos] - r) &gt; threshold) {<br/>        <br/>          // push the x, y and rgb values into the motion array<br/>          <strong class="kh ig">motion.push({x: x, y: y, r: r, g: g, b: b});</strong><br/>     <strong class="kh ig"> <br/>        </strong>}</span><span id="a445" class="kl km if kh b fv ks ko l kp kq"><em class="ka">        // store these colour values to compare to the next frame<br/>        </em>previous_frame[pos] = r;</span><span id="3545" class="kl km if kh b fv ks ko l kp kq">     }<br/>  <br/>  }</span><span id="7d2f" class="kl km if kh b fv ks ko l kp kq"><strong class="kh ig">return motion;</strong></span><span id="c8e1" class="kl km if kh b fv ks ko l kp kq">}</span></pre><p id="1612" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后在我们的绘制循环中，我们可以遍历运动数组，并对结果值做一些事情:</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="309b" class="kl km if kh b fv kn ko l kp kq">function draw(){</span><span id="4d04" class="kl km if kh b fv ks ko l kp kq">   ctx.background(250);<br/>   <strong class="kh ig">var motion = motionDetection();<br/>   for (i = 0; i &lt; motion.length; i++) {<br/>    <br/>      var m = motion[i];<br/>      ctx.fillStyle = rgb(m.r, m.g, m.b);<br/>      ctx.fillEllipse(m.x, m.y, sample_size, sample_size);</strong></span><span id="589f" class="kl km if kh b fv ks ko l kp kq"><strong class="kh ig">    }</strong></span><span id="3671" class="kl km if kh b fv ks ko l kp kq">}</span></pre><p id="60c1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在让我们开始表演吧。照目前的情况来看，它相当快。但是我们可以让它更快。仔细想想，将视频绘制到整个屏幕上，然后每隔10或20个像素读取一次，这有点傻，因为我们可以只输入一个较小的视频，然后读取这些像素…所以我们就这么做吧…</p><p id="55bb" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，让我们把视频变得更小…我们将使用setup()函数来确保视频在我们操作它之前被加载…然后我们只需将视频设置为屏幕大小的比例…</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="87c6" class="kl km if kh b fv kn ko l kp kq"><strong class="kh ig">var scalefactor = 40;</strong></span><span id="c946" class="kl km if kh b fv ks ko l kp kq"><strong class="kh ig">function setup(){<br/>   video.width = w/scalefactor;<br/>   video.height = h/scalefactor;<br/>}</strong></span></pre><p id="1dc0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，我们只需要循环输出视频，而不是整个屏幕，看到我们的视频很小，我们的性能会有很大提高。因为我们现在查看视频的每个像素，噪音也有微小的减少。我们还需要将x和y位置乘以比例因子…</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="7538" class="kl km if kh b fv kn ko l kp kq">function motionDetection(){</span><span id="dbea" class="kl km if kh b fv ks ko l kp kq">  var motion = [];</span><span id="a4e9" class="kl km if kh b fv ks ko l kp kq">  <em class="ka">// draw the video and get its pixels</em><br/>  ctx.drawImage(video, 0, 0, <strong class="kh ig">video.width, video.height</strong>);<br/>  var data = ctx.getImageData(0, 0, <strong class="kh ig">video.width</strong>, <strong class="kh ig">video.height</strong>).data;</span><span id="5092" class="kl km if kh b fv ks ko l kp kq"><strong class="kh ig">  // we can now loop over all the pixels of the video</strong><br/>  for (var y = 0; y &lt; <strong class="kh ig">video.height</strong>; y++) {<br/>    for (var x = 0; x &lt; <strong class="kh ig">video.width</strong>; x++) {</span><span id="c50a" class="kl km if kh b fv ks ko l kp kq">      var pos = (x + y * <strong class="kh ig">video.width</strong>) * 4;<br/>      var r = data[pos];<br/>      var g = data[pos+1];<br/>      var b = data[pos+2];</span><span id="fe45" class="kl km if kh b fv ks ko l kp kq">      if(old[pos] &amp;&amp; Math.abs(old[pos].red - r) &gt; threshold) {<br/>        ctx.fillStyle = rgb(r, g, b);<br/>        ctx.fillRect(x * scalefactor, y * scalefactor, scalefactor, scalefactor);<br/>        <em class="ka">// push the x, y and rgb values into the motion array<br/>        // but multiply the x and y values bck up by scalefactor <br/>        // to get their actual screen position</em><br/>        motion.push({<strong class="kh ig">x: x * scalefactor, y: y * scalefactor</strong>, r: r, g: g, b: b});</span><span id="8486" class="kl km if kh b fv ks ko l kp kq">      }</span><span id="18fd" class="kl km if kh b fv ks ko l kp kq">      old[pos] = { red: r, green: g, blue: b};</span><span id="dc01" class="kl km if kh b fv ks ko l kp kq">}<br/>  }<br/>  <br/>return motion;</span><span id="ecd0" class="kl km if kh b fv ks ko l kp kq">}</span></pre><p id="3629" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在你知道了。一个简单的可重用运动反应代码块。一旦你有了你的运动阵列，尝试附加粒子。</p><p id="ad7b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意环境光，它会增加噪音，并相应地上下调整你的阈值。</p><p id="0039" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让调整更容易的简单方法是添加一些滑块来调整我们的<em class="ka">阈值</em> …</p><p id="b1c9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我喜欢用<a class="ae kb" href="http://www.bit-101.com/blog/" rel="noopener ugc nofollow" target="_blank"> bit101 </a>的快速设置:<a class="ae kb" href="https://github.com/bit101/quicksettings" rel="noopener ugc nofollow" target="_blank">https://github.com/bit101/quicksettings</a><em class="ka">(也可以看看他的</em> <a class="ae kb" href="https://bit101.github.io/lab/" rel="noopener ugc nofollow" target="_blank"> <em class="ka"> lab </em> </a> <em class="ka">和</em> <a class="ae kb" href="https://www.youtube.com/user/codingmath?&amp;ab_channel=CodingMath" rel="noopener ugc nofollow" target="_blank"> <em class="ka">编码数学</em> </a> <em class="ka">视频系列中一些很棒的创意</em> <a class="ae kb" href="https://hackernoon.com/tagged/coding" rel="noopener ugc nofollow" target="_blank"> <em class="ka">编码</em> </a> <em class="ka">的例子和技巧)。</em></p><p id="5f1b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦包含了这个库，就要像这样实例化它:</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="1ccb" class="kl km if kh b fv kn ko l kp kq">var settings = QuickSettings.create();</span></pre><p id="17c3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后添加<em class="ka">阈值</em>和<em class="ka">样本大小</em>的范围滑块:</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="9214" class="kl km if kh b fv kn ko l kp kq"><em class="ka">// addRange(label, min, max, start, increment, callback)</em><br/><strong class="kh ig">settings.addRange("threshold", 5, 100, 50, 1, function(value) {<br/>  threshold = value;<br/>});</strong></span></pre><p id="ba54" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一个经常使用的技术，特别是对于装置，是<em class="ka">背景减除</em>。代码完全一样。但是，你不是比较前一帧的像素，而是对你的空房间拍一张快照，然后将该图像与你当前的像素进行比较。试着让它运行起来，如果你有困难，我很乐意帮助你，请在评论中或twitter上联系我。</p><p id="1488" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是运动检测所需的全部内容。快乐编码。</p><p id="c5d8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">像往常一样，我的github上有完整的代码:<a class="ae kb" href="https://github.com/GeorgeGally/creative_coding" rel="noopener ugc nofollow" target="_blank">https://github.com/GeorgeGally/creative_coding</a></p><p id="0992" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可以在这里看到我之前所有的创意编码教程<a class="ae kb" rel="noopener" href="/@radarboy3000">。</a></p></div><div class="ab cl ku kv hc kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hn ho hp hq hr"><p id="6ec9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">如果你愿意，请跟我来:</strong></p><p id="93d2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae kb" href="https://www.instagram.com/radarboy3000/" rel="noopener ugc nofollow" target="_blank"><strong class="je ig">https://www.instagram.com/radarboy3000/</strong></a></p><p id="ebaa" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae kb" href="https://twitter.com/radarboy_japan" rel="noopener ugc nofollow" target="_blank"><strong class="je ig">https://twitter.com/radarboy_japan</strong></a></p><div class="ht hu fm fo hv lb"><a href="https://www.facebook.com/radarboy3000" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab ej"><div class="ld ab le cl cj lf"><h2 class="bd ig fv z el lg eo ep lh er et ie dt translated">雷达男孩</h2><div class="li l"><h3 class="bd b fv z el lg eo ep lh er et ek translated">雷达男孩。145个赞。艺术、设计可视化、黑客</h3></div><div class="lj l"><p class="bd b gc z el lg eo ep lh er et ek translated">www.facebook.com</p></div></div><div class="lk l"><div class="ll l lm ln lo lk lp ib lb"/></div></div></a></div><figure class="kc kd ke kf fq hw"><div class="bz el l di"><div class="lq lr l"/></div></figure></div></div>    
</body>
</html>