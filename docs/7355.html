<html>
<head>
<title>Fundamentals of System Design — Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">系统设计基础——第三部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/fundamentals-of-system-design-part-3-8da61773a631?source=collection_archive---------3-----------------------#2017-10-25">https://medium.com/hackernoon/fundamentals-of-system-design-part-3-8da61773a631?source=collection_archive---------3-----------------------#2017-10-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="9b94" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以在这里阅读本系列<a class="ae jp" href="https://hackernoon.com/fundamentals-of-system-design-part-2-abbe437ce2dd" rel="noopener ugc nofollow" target="_blank">的上一篇帖子。在这篇文章中，我将介绍数据库索引。</a></p><p id="882d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所有数据库都实现索引。索引是在数据库中实现的附加抽象，用于支持高读取吞吐量。那么为什么不索引数据库中的所有内容呢？因为索引是额外的抽象，会降低写入速度。因此，应用程序<a class="ae jp" href="https://hackernoon.com/tagged/developer" rel="noopener ugc nofollow" target="_blank">开发人员</a>的任务是根据应用程序的读/写工作负载定义哪些列/键需要索引。</p><p id="31a8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最流行的索引方式是使用<a class="ae jp" href="https://hackernoon.com/tagged/b-trees" rel="noopener ugc nofollow" target="_blank"> B树</a>。b树将数据库分成几千字节的页面或块。每个页面都可以通过其在磁盘上的唯一地址来定位。这样页面就可以相互引用。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/462caf26c01209dd641fe9dcb73dd258.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cJn3ZhC091dIn94dLtR65Q.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Source: Wikipedia, <a class="ae jp" href="https://en.wikipedia.org/wiki/B-tree" rel="noopener ugc nofollow" target="_blank">B-tree</a></figcaption></figure><p id="8d96" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，在上图中，如果您正在寻找例如键10，从查看根节点开始。10位于7和16之间，因此跟随7和16之间的指针，您将到达第二行的中间节点。10位于9和12之间，因此跟随指针到9和12之间的磁盘指针所引用的下一页。继续搜索，直到到达包含键及其相应值的叶节点。该值通常是记录实际存储位置的字节偏移量。</p><p id="3526" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一种索引技术被用于较新的数据库，如Elastic Search、Hbase、Cassandra、Riak，它基于Google的BigTable论文。下面是它如何在引擎盖下工作的简短总结:</p><ol class=""><li id="a5cb" class="kg kh hu it b iu iv iy iz jc ki jg kj jk kk jo kl km kn ko dt translated">新写入被添加到内存中排序的平衡树(如红黑树或AVL树)。这种内存树被称为memtable。</li><li id="b484" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated">当memtable变大时，它会作为一个SSTable文件刷新到磁盘。可以把SSTable看作内存树的磁盘上的一个排序的键值存储，即已经排序的memtable。当STable被写入磁盘时，新的写操作可以在memtable中继续。</li><li id="38af" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated">读取首先指向memtable。如果在memtable中没有找到这些键，就在最近的STable中搜索，然后是下一个最近的STable，依此类推。表是经过排序的，所以很容易对它们进行范围查询。</li><li id="d55a" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated">在后台，从SSTable中删除重复的键，并保留最新的键值。这一过程被称为压实。</li><li id="6f96" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated">压缩的表被合并到新的表中。因为表是排序的，所以使用类似合并排序的算法来合并它们非常快。</li></ol><p id="7c02" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种索引方案被称为LSM树或日志结构合并树。</p><p id="5ba2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">根据经验，LSM树可以处理更高的写工作负载，B树适合高读工作负载。这是因为SSTables中的写入始终是顺序的，不像B树那样是随机写入(B树页面不需要在磁盘上按顺序排列)</p><p id="8b5b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了提高耐用性，在B树中写入之前还会写入一个称为预写日志(WAL)的附加文件。wal只是附加文件，在崩溃时帮助B树恢复到一致状态。这意味着写入B树意味着首先写入WAL，这又意味着额外的工作和更慢的写入。</p><p id="57ec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通常，LSM树中的合并和压缩过程非常快，但有时会落后于写入。当数据库遇到非常高的写入工作负载时，可能会发生这种情况。缓慢的压缩和合并会对读取产生负面影响，因为现在需要读取更多的表。这是LSM树的一个很大的缺点，在非常高的写吞吐量的情况下，它的性能会变得不稳定，不像B树那样表现出稳定的性能。</p><p id="1483" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，如果事务语义是最重要的，那么B树是更可取的。在LSM树中，同一个键可以出现在多个表中。在B树中，一个键只出现在一个地方，它的值就地更新。因此，事务隔离很容易在Btrees中实现(我打算在以后的文章中讨论事务隔离)。</p><p id="7290" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">点击此处链接阅读<a class="ae jp" rel="noopener" href="/@v_aparimit/fundamentals-of-system-design-part-4-d6a62f3fa779">系统设计基础——第4部分</a>。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ku kv l"/></div></figure></div></div>    
</body>
</html>