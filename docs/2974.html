<html>
<head>
<title>Lighting by hand #4: into the shadows</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">手工照明#4:进入阴影</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/lighting-by-hand-4-into-the-shadows-a92bc8bc6d97?source=collection_archive---------6-----------------------#2017-03-03">https://medium.com/hackernoon/lighting-by-hand-4-into-the-shadows-a92bc8bc6d97?source=collection_archive---------6-----------------------#2017-03-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><h2 id="29f0" class="hs ht hu bd b gc hv hw hx hy hz ia ek ib translated" aria-label="kicker paragraph">皮科-8</h2><div class=""/><p id="79b0" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">本文是描述我为<a class="ae jy" href="http://www.lexaloffle.com/pico-8.php" rel="noopener ugc nofollow" target="_blank"> PICO-8 </a>设计的实时灯光引擎的系列文章的最后一部分，PICO-8是一款马力有限的可爱幻想控制台。它可以作为一篇独立的文章，但是如果你还没有阅读之前的条目，你可能仍然想要<a class="ae jy" href="https://hackernoon.com/pico-8-lighting-part-1-thin-dark-line-8ea15d21fed7#.q578i21cc" rel="noopener ugc nofollow" target="_blank">从头开始</a>。</p><figure class="ka kb kc kd fq ke fe ff paragraph-image"><div class="fe ff jz"><img src="../Images/f971b4fa09413ac32a6c4607c41dc020.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/1*XQow47dlG58uyyXLBFcYeA.gif"/></div><figcaption class="kh ki fg fe ff kj kk bd b be z ek">The engine in question.</figcaption></figure><p id="14af" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">上次我们分手时，我们有一个可爱的闪烁的<a class="ae jy" href="https://hackernoon.com/tagged/light" rel="noopener ugc nofollow" target="_blank">灯</a>，大部分功能已经就绪，但一个重要的组成部分仍然缺失:实时阴影。为了增加缺失的部分，我们需要弄清楚一些事情:如何表示阴影，如何计算它们在哪里，以及如何有效地绘制它们。</p><p id="3ae4" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">我们很幸运，因为这就是这篇文章的全部内容。</p><h2 id="f0a2" class="kl km hu bd kn ko kp kq kr ks kt ku kv jl kw kx ky jp kz la lb jt lc ld le ia dt translated"><strong class="ak">说话量</strong></h2><p id="4a59" class="pw-post-body-paragraph ja jb hu jc b jd lf jf jg jh lg jj jk jl lh jn jo jp li jr js jt lj jv jw jx hn dt translated">每一个被照亮的物体都在背后投下一个<a class="ae jy" href="https://hackernoon.com/tagged/shadow" rel="noopener ugc nofollow" target="_blank">阴影</a>。在现实世界中，这是由光源发出的光线被物体阻挡造成的。</p><p id="f191" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">一些渲染技术，如<a class="ae jy" href="https://en.wikipedia.org/wiki/Ray_tracing_(graphics)" rel="noopener ugc nofollow" target="_blank">光线追踪</a>，创建虚拟光线并模拟它们的行为。这些模拟光线就像真实光线一样被阻挡，所以漂亮的阴影是免费的。没有发生的是任何一种合理的性能——尽管自发明以来所有的技术进步，光线跟踪仍然非常慢，并且大多不足以进行实时渲染。</p><p id="7860" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">GPU实际上的工作方式是专注于对象本身。现代渲染管道中没有光线。相反，我们从物体表面的一个像素开始，根据它相对于光源的位置对它进行光照。这样做的缺点是反弹光线产生的效果(如阴影和反射)变得更加难以实现，因为我们不再有实际的光线来工作。</p><p id="fed4" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">两种常见的解决方法是<a class="ae jy" href="https://en.wikipedia.org/wiki/Shadow_volume" rel="noopener ugc nofollow" target="_blank"> <em class="lk">阴影体积</em> </a>和<a class="ae jy" href="https://en.wikipedia.org/wiki/Shadow_mapping" rel="noopener ugc nofollow" target="_blank"> <em class="lk">阴影贴图</em> </a>。后一种方法是目前人们通常使用的方法，但两者都有自己的优势，阴影体有一个重要的优势——它们很容易适应2D，并且不需要屏幕外缓冲区，这在PICO-8上很难做到。</p><figure class="ka kb kc kd fq ke fe ff paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="fe ff ll"><img src="../Images/93a49a6bc8eb563146232defaf2914c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5liZqHhzzHKFRYMJ1vgQXA.png"/></div></div><figcaption class="kh ki fg fe ff kj kk bd b be z ek">Each yellow shape is a shadow volume for one of the spheres (image from <a class="ae jy" href="https://en.wikipedia.org/wiki/Shadow_volume#/media/File:Shadow_volume_illustration.png" rel="noopener ugc nofollow" target="_blank">English Wikipedia</a>)</figcaption></figure><p id="6b2d" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">阴影体积背后的想法都在名称中。对于每一个物体，我们可以把它的影子想象成一个空间体，在这个空间体中，一切都是黑暗的。这些体积本身是三维对象，使用它们的基本方法如下:</p><pre class="ka kb kc kd fq lq lr ls lt aw lu dt"><span id="b920" class="kl km hu lr b fv lv lw l lx ly"><strong class="lr ie">for each lit object</strong>: <br/>  generate a <strong class="lr ie">shadow volume</strong><br/>  draw this <strong class="lr ie">shadow volume </strong>to a special <strong class="lr ie">buffer<br/>when we draw actual objects later:<br/>  </strong>check each pixel against the <strong class="lr ie">buffer</strong> to see if it's in shadow<br/>  <strong class="lr ie">light it </strong>only if it's not</span></pre><p id="e859" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">详细解释这一点将会是一篇关于它自己的的<a class="ae jy" href="https://www.gamedev.net/resources/_/technical/graphics-programming-and-theory/the-theory-of-stencil-shadow-volumes-r1873" rel="noopener ugc nofollow" target="_blank">文章，但是我们可以从中得出的核心思想是:一个物体的阴影可以用一个形状来表示。</a></p><h2 id="01d9" class="kl km hu bd kn ko kp kq kr ks kt ku kv jl kw kx ky jp kz la lb jt lc ld le ia dt translated"><strong class="ak">平压</strong></h2><p id="1a05" class="pw-post-body-paragraph ja jb hu jc b jd lf jf jg jh lg jj jk jl lh jn jo jp li jr js jt lj jv jw jx hn dt translated">阴影体积的二维等价物实际上是一个<strong class="jc ie">阴影区域</strong>——一个平面形状，代表给定对象阴影中的所有像素。</p><figure class="ka kb kc kd fq ke fe ff paragraph-image"><div class="fe ff lz"><img src="../Images/5f300d338ac4bbf9ac84fe7707aca07c.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*nYGZDH1U7PdenisHyacHqg.png"/></div><figcaption class="kh ki fg fe ff kj kk bd b be z ek">A 2D object and the shadow “volume” behind it</figcaption></figure><p id="0070" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">计算一个复杂物体的面积可能会很麻烦，所以我们将使用我们最喜欢的借口:我们将把它分解成更简单的组件。在3D世界中，这通常是通过将表面分成三角形来实现的。计算三角形的阴影体积要比计算茶壶的阴影体积容易得多。</p><p id="5922" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">三角形的2D等价物是线段。就像我们可以将一个三维物体的表面分解成三角形一样，我们也可以将任何二维形状分解成它的组成边缘。</p><figure class="ka kb kc kd fq ke fe ff paragraph-image"><div class="fe ff lz"><img src="../Images/27efaf4856f67866dfac8de2fcb67823.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*Yu5btIDfFH-FO5CPtaw6ew.png"/></div><figcaption class="kh ki fg fe ff kj kk bd b be z ek">How the shadow volumes of the three segments add up</figcaption></figure><p id="5ba0" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">每个片段的阴影体积可以单独计算。相邻线段的体积会相互连接，加起来就是整体的影子。</p><h2 id="58ed" class="kl km hu bd kn ko kp kq kr ks kt ku kv jl kw kx ky jp kz la lb jt lc ld le ia dt translated">筑起城墙</h2><p id="d1b8" class="pw-post-body-paragraph ja jb hu jc b jd lf jf jg jh lg jj jk jl lh jn jo jp li jr js jt lj jv jw jx hn dt translated">一旦我们知道所有阴影投射者将由线段来表示，我们必须告诉我们的引擎这些线在哪里。</p><p id="f17d" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">基本思想是这样的:游戏中的每个物体(墙、柱子、敌人)都允许有一个<code class="eh ma mb mc lr b">walls</code>列表——投射阴影的线条。这些线由线段本身的端点<code class="eh ma mb mc lr b">s</code>和<code class="eh ma mb mc lr b">e</code>表示，还有一个单位向量<code class="eh ma mb mc lr b">d</code>，它指向远离墙壁的方向，让我们知道墙壁的哪一侧是外面(如果你精通向量:墙壁的法线<a class="ae jy" href="https://twitter.com/JoachimHolmer/status/832918393967742976/photo/1" rel="noopener ugc nofollow" target="_blank"/>)。</p><figure class="ka kb kc kd fq ke fe ff paragraph-image"><div class="fe ff jz"><img src="../Images/70c18ec4e1e5ec67e8865dabbdf1e44c.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/1*AqbJGE9N0jcyc8ua92s6Cw.gif"/></div><figcaption class="kh ki fg fe ff kj kk bd b be z ek">Walls and their d-vectors in a sample corridor.</figcaption></figure><p id="e4ba" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">一旦我们有了投射阴影的结构，是时候利用它了。</p><p id="bbb9" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">最初的3D算法使用一种特殊的屏幕外缓冲区，能够快速判断像素是否在阴影体积内。这在PICO-8上并不是一个真正的选项，而且对每个潜在发光像素进行多边形中点碰撞检查的替代方案听起来也不太有前景。</p><p id="f146" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">幸运的是，我们可以以一种更简单的方式使用阴影体:我们可以在渲染场景的顶部用黑色绘制它们。对于一个单一的光源和漆黑的阴影，最终结果将是相同的，但渲染一个多边形将比检查我们画的每个像素更有效。</p><p id="7e44" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">在这个简化之后，添加阴影到引擎的整个过程可以归结为渲染循环最底层的一个循环。</p><pre class="ka kb kc kd fq lq lr ls lt aw lu dt"><span id="3edb" class="kl km hu lr b fv lv lw l lx ly"><strong class="lr ie">for each wall:<br/>  </strong>figure out if its shadow is <strong class="lr ie">visible </strong>at all<br/>  if it is, calculate the <strong class="lr ie">shadow volume</strong><br/>  <strong class="lr ie">draw the shadow volume</strong> in solid black</span></pre><p id="08ea" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">第一步是至关重要的，因为它大大减少了我们需要绘制的阴影的数量。上图显示了这一点，我们实际需要处理的墙壁用黄色突出显示。只有两条规则:</p><ul class=""><li id="dc74" class="md me hu jc b jd je jh ji jl mf jp mg jt mh jx mi mj mk ml dt translated">如果光源在墙的后面，就不需要画阴影</li><li id="5a00" class="md me hu jc b jd mm jh mn jl mo jp mp jt mq jx mi mj mk ml dt translated">如果墙的两端都在灯光的最大范围之外，我们也可以忽略那面墙——反正阴影是看不见的</li></ul><h2 id="93b4" class="kl km hu bd kn ko kp kq kr ks kt ku kv jl kw kx ky jp kz la lb jt lc ld le ia dt translated">阴影里有什么</h2><p id="8912" class="pw-post-body-paragraph ja jb hu jc b jd lf jf jg jh lg jj jk jl lh jn jo jp li jr js jt lj jv jw jx hn dt translated">现在我们知道哪些墙可以安全地忽略，我们的新任务是计算出那些我们必须处理的阴影体积。警告:此部分可能包含微量的矢量数学。</p><figure class="ka kb kc kd fq ke fe ff paragraph-image"><div class="fe ff lz"><img src="../Images/b712d94382920ae2d5b5b8dd61eeac78.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*rXvUqIhQ-iAGUzr7EQ4oOQ.png"/></div><figcaption class="kh ki fg fe ff kj kk bd b be z ek">A shadow volume and the light rays bounding it (shown in red)</figcaption></figure><p id="5398" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">从上面的插图来看，很明显一面墙的阴影区域是某种多边形。投射阴影的墙成为多边形的一条边，因为它是阴影周长的一部分。通过将光源与墙壁的每个端点连接起来并向前投射，可以获得另外两个边缘——我们实际上可以将这些视为限制我们阴影的光线。理论上，这些射线会到达无穷远，但是画出无限多边形就像数到无穷远一样有效。</p><p id="6818" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">幸运的是，光线已经有了一个有限的范围，由包含所有潜在发光像素的方便的裁剪矩形表示。我们可以使用这个矩形，利用光线与矩形的交点，将我们庞大的无限多边形截断成一个更小的、独立的等价物，没有宏伟的错觉。</p><pre class="ka kb kc kd fq lq lr ls lt aw lu dt"><span id="9014" class="kl km hu lr b fv lv lw l lx ly"><em class="lk">-- light position and range</em><br/><strong class="lr ie">local</strong> p,rng = lgt.pos,lgt.rng<br/><em class="lk">-- wall endpoints</em><br/><strong class="lr ie">local</strong> s,e = wall.s, wall.e<br/><em class="lk">-- calculate light rays towards s and e</em><br/><strong class="lr ie">local</strong> ds,de = s-p,e-p<br/><em class="lk">-- extend the rays until they intersect with the<br/>-- nearest boundary defined by light range<br/>-- (white points)</em><br/><strong class="lr ie">local</strong> cs, ce=<br/>  rng/max(abs(ds.x),abs(ds.y)),<br/>  rng/max(abs(de.x),abs(de.y))<br/><strong class="lr ie">local</strong> proj_s, proj_e=<br/>  p+ds*cs, p+de*ce</span></pre><p id="25b4" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">这给了我们四个顶点，我们现在可以连接成一个多边形，并在这个简单的例子中得到一个合理的阴影。到目前为止，我们已经了解到简单的情况并不是唯一的。</p><div class="ka kb kc kd fq ab cb"><figure class="mr ke ms mt mu mv mw paragraph-image"><img src="../Images/7b7165db5350029ff340fa51de9e475e.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*aGEJyI3qaNMCcuXqQMnzNA.png"/></figure><figure class="mr ke ms mt mu mv mw paragraph-image"><img src="../Images/c09a98f5f94ff298c3c9a3e63d6e0831.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*kf_6bwi5LJNM3knXoatJ1w.png"/><figcaption class="kh ki fg fe ff kj kk bd b be z ek mx di my mz">Two situations in which four points aren’t enough — the regions in red would miss out on all the fun</figcaption></figure></div><p id="5343" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">当光线与矩形的不同边缘相交时，仅使用四个点是不会切割它的。为了击中矩形内的所有阴影像素，我们需要添加更多的顶点，也就是说，我们沿着周长从一个交叉点到另一个交叉点会遇到的拐角。我们通过检查每个交点属于哪个象限并顺时针迭代，直到我们得到所有丢失的角点。</p><pre class="ka kb kc kd fq lq lr ls lt aw lu dt"><span id="e89d" class="kl km hu lr b fv lv lw l lx ly"><em class="lk">-- find the quadrants</em><br/><strong class="lr ie">local </strong>qs,qe = quadrant(ps), quadrant(pe)<br/><em class="lk">-- make sure qe-&gt;qs is increasing</em><br/><strong class="lr ie">if</strong> (qs&lt;qe) qs += 4<br/><em class="lk">-- assemble vertices in clockwise order</em><br/><strong class="lr ie">local</strong> vertices = {s, e, proj_e}<br/><strong class="lr ie">for</strong> q = qe,qs-1 <strong class="lr ie">do</strong><br/>  <em class="lk">-- corners are pre-stored in a table as [</em>±<em class="lk">1,</em>±<em class="lk">1] vectors<br/>  -- we just have to translate/scale them to our rectangle</em><br/>  <strong class="lr ie">add</strong>(vertices, p+corners[q]*rng)<br/><strong class="lr ie">end</strong><br/><strong class="lr ie">add</strong>(pts, proj_s)</span></pre><h2 id="4062" class="kl km hu bd kn ko kp kq kr ks kt ku kv jl kw kx ky jp kz la lb jt lc ld le ia dt translated">绘制和排序</h2><p id="5c54" class="pw-post-body-paragraph ja jb hu jc b jd lf jf jg jh lg jj jk jl lh jn jo jp li jr js jt lj jv jw jx hn dt translated">我们有我们的阴影体积，但实际绘制它是另一回事。大多数光栅化算法只处理三角形，但我们可以是从四边形到六边形的任何东西。</p><p id="3914" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">对于面更丰富的多边形，最常用的解决方案是首先将它们分解成三角形。这在GPU世界中非常有效，因为“渲染三角形”在那里被加速到基本免费的程度。在PICO-8上，绘制三角形的开销非常大，这对我们和我们的六边形来说是个坏消息，六边形总共由四个烦人的三角形组成。</p><p id="28db" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">幸运的是，有一个简单的算法来渲染多边形，不管它们有多少个面，只要它们是<a class="ae jy" href="https://en.wikipedia.org/wiki/Convex_set" rel="noopener ugc nofollow" target="_blank">凸的</a>——我们的阴影体就是这样。</p><p id="01bd" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">第一步将是我们在处理渲染一个形状时通常要做的事情:我们将把多边形分割成单独的线条。这将渲染多边形的问题转化为简单地逐行计算其范围。</p><pre class="ka kb kc kd fq lq lr ls lt aw lu dt"><span id="6a02" class="kl km hu lr b fv lv lw l lx ly">ymin, ymax = <strong class="lr ie">Y coordinates of the top/bottom of the polygon<br/>for each y between </strong>ymin, ymax:<br/>  xls[y] = find the leftmost x still inside the polygon at line y<br/>  xrs[y] = find the rightmost x still inside the polygon at line y<br/><strong class="lr ie">for each y between </strong>ymin, ymax:<br/>  fill(xls[y], xrs[y], y)</span></pre><p id="2654" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">多边形的工作方式是，两个极端都必须位于其中一条边上。这意味着我们可以获取所有的边，遍历每条边上的所有像素(就好像我们想把它画成一条线)，并相应地更新<code class="eh ma mb mc lr b">xls</code>或<code class="eh ma mb mc lr b">xrs</code>表。唯一的问题是我们不知道要更新哪个表:我们不知道任何给定的边是在多边形的左侧还是右侧。</p><figure class="ka kb kc kd fq ke fe ff paragraph-image"><div class="fe ff lz"><img src="../Images/44b44ff6132e134739df899ffa167af2.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*b6u3R-xFPbzLyvEIoXMqRA.png"/></div><figcaption class="kh ki fg fe ff kj kk bd b be z ek">What is stuffily known as the clockwise winding order.</figcaption></figure><p id="73de" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">解决这个难题最简单的方法是对顶点做一个假设，即它们总是以一个确定的顺序出现:顺时针或逆时针。一旦我们这样做了，我们可以很容易地通过观察它的走向来判断它属于哪一边。我们的阴影体积代码给了我们顺时针排序的点，所以任何上升的边(结束<code class="eh ma mb mc lr b">y</code>小于开始<code class="eh ma mb mc lr b">y</code>)一定在多边形的左边。另一方面，如果一个边是向下的，它一定在右边。</p><pre class="ka kb kc kd fq lq lr ls lt aw lu dt"><span id="8e72" class="kl km hu lr b fv lv lw l lx ly"><strong class="lr ie">function</strong> ngon(pts, ln)<br/>  <strong class="lr ie">local</strong> xls, xrs, npts = {}, {}, #pts<br/>  -- update xls and xrs using each edge in turn<br/>  <strong class="lr ie">for</strong> i=1, npts <strong class="lr ie">do</strong><br/>   ngon_edge(<br/>    pts[i],pts[i%npts+1],<br/>    xls, xrs<br/>   )<br/>  <strong class="lr ie">end</strong><br/>  -- use the tables to draw each horizontal line<br/>  <strong class="lr ie">for</strong> y, xl <strong class="lr ie">in pairs</strong>(xls) <strong class="lr ie">do</strong><br/>    <strong class="lr ie">local</strong> xr = xrs[y]<br/>    ln(xl, xr, y)<br/>  <strong class="lr ie">end</strong><br/><strong class="lr ie">end</strong></span></pre><p id="042f" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">在这个代码片段中，伪代码中的“计算出y的最小值/最大值”部分不见了。这是因为我们免费得到了这个部分:<code class="eh ma mb mc lr b">xls</code> / <code class="eh ma mb mc lr b">xrs</code>表将只包含我们的多边形实际到达的y坐标的条目。我们可以直接迭代这些表中的一个，而不是按顺序遍历所有的<code class="eh ma mb mc lr b">y</code>。</p><h2 id="7d30" class="kl km hu bd kn ko kp kq kr ks kt ku kv jl kw kx ky jp kz la lb jt lc ld le ia dt translated"><strong class="ak">反转导流</strong></h2><p id="f548" class="pw-post-body-paragraph ja jb hu jc b jd lf jf jg jh lg jj jk jl lh jn jo jp li jr js jt lj jv jw jx hn dt translated">经历了这么多麻烦，我们终于准备好把所有东西都插上了。我们设置墙壁，插入阴影渲染循环，然后…</p><figure class="ka kb kc kd fq ke fe ff paragraph-image"><div class="fe ff jz"><img src="../Images/9449010f9831ee721e68aa70dafbebfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/1*kX8M2PetkmG5s2AjsY14-w.gif"/></div></figure><p id="671c" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">嗯，我们确实看到了一些阴影，所以这是个优点。问题是每面墙的影子完全遮住了墙本身。这可能对某些游戏有用，但是我们并没有大费周章地绘制一个很酷的古代寺庙磁砖，只是为了将我们的渲染限制在地板上。我们想阻止墙壁自己投射阴影。</p><p id="330a" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">有几种方法可以做到这一点，我们将要使用的是一个肮脏的伎俩。我们将通过反转<code class="eh ma mb mc lr b">d</code>向量来翻转我们的墙壁，使所有的阴影投射部分面向<em class="lk">内侧</em>。因为我们检查的是墙的哪一边，这将使只有背面能够投射阴影。引擎会表现得好像只有当<em class="lk">离开</em>一个固体物体时，光线才会被阻挡，而不是当<em class="lk"> </em>试图进入时。</p><figure class="ka kb kc kd fq ke fe ff paragraph-image"><div class="fe ff jz"><img src="../Images/f3f8dd339b4880735ae433d1a78d1f8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/1*P0edxrrbNrO272nnB99T8Q.gif"/></div><figcaption class="kh ki fg fe ff kj kk bd b be z ek">Back-face shadows, in garish Technicolor</figcaption></figure><p id="fc9b" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">这让我们得到了我们想要的。后墙的阴影形成了正确的形状，但是墙的内部没有被改变。</p><h2 id="25cf" class="kl km hu bd kn ko kp kq kr ks kt ku kv jl kw kx ky jp kz la lb jt lc ld le ia dt translated"><strong class="ak">洞内整体</strong></h2><p id="5de5" class="pw-post-body-paragraph ja jb hu jc b jd lf jf jg jh lg jj jk jl lh jn jo jp li jr js jt lj jv jw jx hn dt translated">既然它对坚固的墙壁如此有效，让我们把它应用到更古老的东西上——坦普尔。比如说一个蚀刻的柱子。</p><figure class="ka kb kc kd fq ke fe ff paragraph-image"><div class="fe ff na"><img src="../Images/e9ac5fd6198655f3605812283aca0807.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/1*tWXSK9Wr3mSSnIuyMePdig.gif"/></div><figcaption class="kh ki fg fe ff kj kk bd b be z ek">The base behind the spire casts a shadow<em class="nb"> on</em> the spire. MC Escher approves.</figcaption></figure><p id="be00" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">好吧，那仍然不是它。底座投下的阴影遮住了它上面应该很高的部分，完全破坏了深度的错觉。</p><p id="01b8" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">这是第二次垂直表面给我们带来痛苦，也是第二次我们将通过使用一个简单的技巧来解决这个问题。具有垂直组件的对象将在它们的<code class="eh ma mb mc lr b">walls</code>表中定义一个特殊的<code class="eh ma mb mc lr b">hole</code>掩码，它只是一个标记为“请勿触摸”的矩形。我们可以用这个矩形来覆盖垂直的塔尖，确保它不会被阴影覆盖。</p><p id="a123" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">我们扩展了polygon例程来接受这样的遮罩，并在绘制时考虑它们。对于每一条线，我们将把正在绘制的线段分成“洞前”和“洞后”部分，并绘制这些部分——保持矩形的内部完整。</p><figure class="ka kb kc kd fq ke fe ff paragraph-image"><div class="fe ff na"><img src="../Images/15c625d65835deb1bcaa28f6df4da2a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/1*cj-vVZDHLWj0cRbfOk-ZLg.gif"/></div><figcaption class="kh ki fg fe ff kj kk bd b be z ek">MC Escher no longer approves.</figcaption></figure><h2 id="d3fa" class="kl km hu bd kn ko kp kq kr ks kt ku kv jl kw kx ky jp kz la lb jt lc ld le ia dt translated">结果好一切都好</h2><p id="51bb" class="pw-post-body-paragraph ja jb hu jc b jd lf jf jg jh lg jj jk jl lh jn jo jp li jr js jt lj jv jw jx hn dt translated">此时，我对阴影的样子很满意。引擎有时仍然会画出一些无意义的东西，比如一个物体遮挡了它不应该遮挡的东西，但是当你关注整个游戏的时候，这种情况很少发生，很难注意到。我非常肯定，最终解决这些遗留问题的唯一方法是用3D技术来实现——我必须为以后的文章留下一些有趣的东西，不是吗？</p><figure class="ka kb kc kd fq ke fe ff paragraph-image"><div class="fe ff jz"><img src="../Images/522693c4d1857cf72419460ba8ab5014.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/1*xgIPZgLgcJGBnRhFeJIJLQ.gif"/></div></figure><p id="e1cb" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">这就结束了我们在PICO-8上从黑屏到可用照明引擎的四部分旅程。我希望你和我一样喜欢它。为了在下个世纪到来之前完成这篇文章，我不得不省略了很多细节，所以如果你有任何问题或反馈，我很乐意在推特上发表。</p><p id="7036" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">写这些既有趣又累，所以我可能会暂时停止写作。不过，请继续关注我的下一篇文章——我们将讨论严格的限制(比如PICO-8)如何影响游戏设计向更好的方向发展。</p><p id="d3c9" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">在那之前，愿你一直有始有终。</p><p id="c5fd" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated"><a class="ae jy" href="https://hackernoon.com/pico-8-lighting-part-1-thin-dark-line-8ea15d21fed7#.pojyj8rkh" rel="noopener ugc nofollow" target="_blank"> <em class="lk">第一部分</em> </a> <em class="lk"> | </em> <a class="ae jy" href="https://hackernoon.com/lighting-by-hand-2-stitching-lines-together-24edc9f819bf#.glbk87bk6" rel="noopener ugc nofollow" target="_blank"> <em class="lk">第二部分</em> </a> <em class="lk"> | </em> <a class="ae jy" href="https://hackernoon.com/lighting-by-hand-3-breath-of-life-7a775617697e#.xw8c30as1" rel="noopener ugc nofollow" target="_blank"> <em class="lk">第三部分</em> </a> <em class="lk"> | </em> <strong class="jc ie"> <em class="lk">第四部分</em> </strong> <em class="lk"> | </em> <a class="ae jy" href="https://krajzeg.itch.io/dank-tomb" rel="noopener ugc nofollow" target="_blank"> <em class="lk">玩游戏</em> </a></p><div class="ka kb kc kd fq ab cb"><figure class="mr ke nc mt mu mv mw paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mr ke nc mt mu mv mw paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mr ke nc mt mu mv mw paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="nd ne nf"><p id="f922" class="ja jb lk jc b jd je jf jg jh ji jj jk ng jm jn jo nh jq jr js ni ju jv jw jx hn dt translated"><a class="ae jy" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jy" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jy" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jy" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ja jb lk jc b jd je jf jg jh ji jj jk ng jm jn jo nh jq jr js ni ju jv jw jx hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jy" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jy" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ka kb kc kd fq ke fe ff paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="fe ff nj"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="ka kb kc kd fq ke"><div class="bz el l di"><div class="nk nl l"/></div></figure></div></div>    
</body>
</html>