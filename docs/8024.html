<html>
<head>
<title>Clone Minesweeper in 15 minutes with TypeScript, React, and Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用TypeScript，React和Redux在15分钟内克隆扫雷</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/clone-minesweeper-in-15-minutes-with-typescript-react-and-redux-64be1a7a0264?source=collection_archive---------14-----------------------#2017-11-16">https://medium.com/hackernoon/clone-minesweeper-in-15-minutes-with-typescript-react-and-redux-64be1a7a0264?source=collection_archive---------14-----------------------#2017-11-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/5ec13c7fa8a4141b71758c7da9f719da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hpZC-T7qQqbhgK_SZog4HA.png"/></div></div></figure><p id="6643" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当<a class="ae ka" href="https://en.wikipedia.org/wiki/Minesweeper_(video_game)" rel="noopener ugc nofollow" target="_blank">扫雷</a>搭载Windows 3.1时，它不仅仅是为了娱乐。令人上瘾的小游戏掩盖了一个不可告人的目的:<a class="ae ka" href="http://mentalfloss.com/uk/technology/32106/the-true-purpose-of-solitaire-minesweeper-hearts-and-freecell" rel="noopener ugc nofollow" target="_blank">向用户介绍鼠标右键</a>。两键鼠标现在已经是旧闻了，但是扫雷对于不同的介绍来说仍然是合适的尺寸。</p><p id="d7fb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在接下来的十五分钟里，我们将构建一个扫雷克隆(<a class="ae ka" href="https://github.com/rjz/ts-minesweeper" rel="noopener ugc nofollow" target="_blank"> github </a>)，它使用<a class="ae ka" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>、<a class="ae ka" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>和<a class="ae ka" href="http://redux.js.org" rel="noopener ugc nofollow" target="_blank"> Redux </a>来构建一个健壮的浏览器应用程序。这是一个简单的同步项目，但是引入使用<a class="ae ka" href="http://rjzaworski.com/c/typescript" rel="noopener ugc nofollow" target="_blank"> Redux和TypeScript </a>的模式来帮助驯服大得多的应用程序的复杂性就足够了。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff kb"><img src="../Images/c999bce4f973207c190c700e99c45a3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*fDKj9q-S9FrtqLfLHx6HuA.png"/></div></figure><h1 id="515b" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">入门指南</h1><p id="f03f" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">没有时间进行配置，时间紧迫！我们可以使用<a class="ae ka" href="https://github.com/wmonk/create-react-app-typescript" rel="noopener ugc nofollow" target="_blank">create-react-app-typescript</a>来建立一个具有合理默认值的项目。微调可以以后再来。</p><pre class="kc kd ke kf fq lj lk ll lm aw ln dt"><span id="9b24" class="lo kh hu lk b fv lp lq l lr ls">$ create-react-app minesweeper — scripts-version=react-scripts-ts<br/>$ cd minesweeper<br/>$ yarn install</span></pre><p id="115f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们还需要为后者添加<code class="eh lt lu lv lk b">redux</code>、<code class="eh lt lu lv lk b">redux-react</code>和<a class="ae ka" href="https://github.com/DefinitelyTyped/DefinitelyTyped" rel="noopener ugc nofollow" target="_blank">类型定义</a>(<code class="eh lt lu lv lk b">redux</code>为<a class="ae ka" href="https://github.com/reactjs/redux/blob/master/index.d.ts" rel="noopener ugc nofollow" target="_blank">带来了自己的</a>)。</p><pre class="kc kd ke kf fq lj lk ll lm aw ln dt"><span id="347f" class="lo kh hu lk b fv lp lq l lr ls">$ yarn add redux react-redux<br/>$ yarn add <a class="ae ka" href="http://twitter.com/types/react-redux" rel="noopener ugc nofollow" target="_blank">@types/react-redux</a></span></pre><h1 id="a10b" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">游戏逻辑</h1><p id="f0a8" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">接下来，我们要作弊(但只是一点点)。虽然我们将对前端UI使用React，对持久性使用Redux，但我们可以通过借用游戏本身现有的<a class="ae ka" href="http://wiki.c2.com/?FourLayerArchitecture" rel="noopener ugc nofollow" target="_blank">模型</a>来节省时间。</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="lw lx l"/></div></figure><p id="a4e6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个特殊的<a class="ae ka" href="https://github.com/rjz/ts-minesweeper/blob/master/src/minesweeper.ts" rel="noopener ugc nofollow" target="_blank">实现</a>碰巧是友好的、本地的和同步的，但是很容易想象将<code class="eh lt lu lv lk b">MinesweeperAPI</code>移到HTTP请求的远端。它的行为在两种情况下都是一样的:给定<code class="eh lt lu lv lk b">Game</code>的当前状态和显示或标记单个单元格的请求，<code class="eh lt lu lv lk b">MinesweeperAPI</code>将返回一个更新的新状态来反映请求的结果。</p><p id="9d07" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我们需要告诉TypeScript关于<code class="eh lt lu lv lk b">Game</code>的“形状”。这包括<code class="eh lt lu lv lk b">Options</code>——棋盘的大小和有多少地雷藏在上面——一个<code class="eh lt lu lv lk b">moveCount</code>，以及组成棋盘状态的几个指数。完成的类型声明很好地证明了这一点:</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="lw lx l"/></div></figure><h1 id="082c" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">这次是Redux</h1><p id="e482" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">我们有一个游戏——我们只是需要一个地方来放它。我们将准备Redux来存储和更新<code class="eh lt lu lv lk b">Game</code>的状态，方法是在我们自己的类型化操作中镜像公共<code class="eh lt lu lv lk b">MinesweeperAPI</code>:</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="lw lx l"/></div></figure><p id="a3af" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">除了<a class="ae ka" href="https://rjzaworski.com/2016/09/typescript-redux-async-actions#actions" rel="noopener ugc nofollow" target="_blank">类型定义</a>之外，这些看起来就像我们用普通JavaScript编写的动作创建器。但是通过预先声明我们的假设，TypeScript编译器可以在应用程序的其他地方强制执行这些操作。如果我们试图创建一个没有在<code class="eh lt lu lv lk b">Action</code> <a class="ae ka" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#union-types" rel="noopener ugc nofollow" target="_blank">联合</a>中声明的动作，程序将无法编译。</p><h2 id="b7cc" class="lo kh hu bd ki ly lz ma km mb mc md kq jn me mf ku jr mg mh ky jv mi mj lc mk dt translated">玩游戏</h2><p id="b38a" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">我们将从商店内部的静态类型中获得更多的好处。伸缩Redux 的挑战之一是日益“深入”的reducers、accessors和state的复杂性。通过先发制人地声明它们的形状，TypeScript编译器可以警告我们输入错误、缺少参数和引用错误。</p><p id="7889" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了简单起见，我们将根据领域模型围绕现有的<code class="eh lt lu lv lk b">Game</code>类型构建商店。即使有了这种相对扁平的数据结构，在TypeScript保证应用程序的其余部分遵守规则的情况下，我们晚上也会睡得更安稳。</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="lw lx l"/></div></figure><p id="a238" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">打破它！尝试访问<code class="eh lt lu lv lk b">'REVEAL_LOCATION'</code>分支中的<code class="eh lt lu lv lk b">action.options</code>，并检查产生的编译器错误。</p><h1 id="d6b2" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">构建前端</h1><p id="ac23" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">说到“退房”，钟！时间很紧，但我们还有时间美化一下城市。</p><p id="49f6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了让事情进展顺利，让我们通过在根元素周围包装一个<code class="eh lt lu lv lk b"><a class="ae ka" href="https://github.com/reactjs/react-redux/blob/4c2670dc11cc067ef106f6c527e6e8b9d47f8af8/docs/api.md#provider-store" rel="noopener ugc nofollow" target="_blank">Provider</a></code>来将Redux存储到组件树中。这与JavaScript中的工作方式完全一样:</p><pre class="kc kd ke kf fq lj lk ll lm aw ln dt"><span id="fa01" class="lo kh hu lk b fv lp lq l lr ls">ReactDOM.render(<br/>  &lt;Provider store={store}&gt;<br/>    &lt;App /&gt;<br/>  &lt;/Provider&gt;,<br/>  document.getElementById('root') as HTMLElement<br/>);</span></pre><p id="6762" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我们将搭建一个根应用程序组件并将它<code class="eh lt lu lv lk b"><a class="ae ka" href="https://github.com/reactjs/react-redux/blob/4c2670dc11cc067ef106f6c527e6e8b9d47f8af8/docs/api.md#connect" rel="noopener ugc nofollow" target="_blank">connect</a></code>到所提供的<code class="eh lt lu lv lk b">store</code>。</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="lw lx l"/></div></figure><p id="20de" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">TypeScript在这里添加了几个新的方面。传递给<code class="eh lt lu lv lk b">connect</code>的<code class="eh lt lu lv lk b">mapStateToProps</code>和<code class="eh lt lu lv lk b">mapDispatchToProps</code>函数都有自己的类型声明，它们的交集代表组件自己的<code class="eh lt lu lv lk b">Props</code>。当尘埃落定时，<code class="eh lt lu lv lk b">&lt;App /&gt; </code>将接收整个Redux <code class="eh lt lu lv lk b">Game</code>加上三个可用的动作和一个<code class="eh lt lu lv lk b">grid</code>数组来简化渲染。作为附加仪式的回报，我们得到了完全的类型安全:未知的动作、畸形的道具和未定义的引用现在都将在编译时触发错误。</p><h2 id="7970" class="lo kh hu bd ki ly lz ma km mb mc md kq jn me mf ku jr mg mh ky jv mi mj lc mk dt translated">呈现单元格</h2><p id="9ebb" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated"><code class="eh lt lu lv lk b">&lt;App /&gt;</code>已接入商店，但还没什么好看的。为了解决这个问题，让我们创建一个表示网格上单个单元格的组件:</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="lw lx l"/></div></figure><p id="ebc1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将CSS和渲染优化留到将来<a class="ae ka" href="https://hackernoon.com/tagged/future" rel="noopener ugc nofollow" target="_blank">的</a>练习中(我们有时间表，这里！)这看起来很像JavaScript中的样子。<a class="ae ka" href="https://www.typescriptlang.org/docs/handbook/type-inference.html" rel="noopener ugc nofollow" target="_blank"> <em class="ml">推断</em> </a>是游戏的名字:一旦TypeScript理解了应用程序的边界，它就可以为里面的大部分细节推断出正确的类型。这对我们的小速跑来说没什么大不了的，但是随着项目规模的扩大，它会省去很多仪式。</p><p id="022c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">编译器不能很好地推断出的一件事是跨越应用程序边界的新数据。例如，当一个单元格被点击时，我们需要告诉<a class="ae ka" href="https://hackernoon.com/tagged/typescript" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>一个独立的事件处理程序准备接收什么类型的事件:</p><pre class="kc kd ke kf fq lj lk ll lm aw ln dt"><span id="99fb" class="lo kh hu lk b fv lp lq l lr ls">e: React.MouseEvent&lt;HTMLButtonElement&gt;</span></pre><p id="3826" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">编译器现在可以验证我们正在正确地处理事件。如果我们传递一个<code class="eh lt lu lv lk b">KeyboardEvent</code>或者将处理程序附加到一个<code class="eh lt lu lv lk b">&lt;button /&gt;</code>之外的东西上，我们会在编译时遇到一个错误。</p><h2 id="4ef6" class="lo kh hu bd ki ly lz ma km mb mc md kq jn me mf ku jr mg mh ky jv mi mj lc mk dt translated">完成棋盘</h2><p id="814c" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">我们快到了！我们还需要两样东西来让游戏在<code class="eh lt lu lv lk b">&lt;App /&gt;</code>中运行:一个<code class="eh lt lu lv lk b"><a class="ae ka" href="https://reactjs.org/docs/react-component.html#componentdidmount" rel="noopener ugc nofollow" target="_blank">componentDidMount</a></code>钩子来创建初始游戏状态，一个<code class="eh lt lu lv lk b">render</code>方法来将<code class="eh lt lu lv lk b">CellComponent</code>网格放到屏幕上。</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="lw lx l"/></div></figure><p id="da8b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这只是JavaScript——所有的类型都在上游声明，TypeScript将在下游推断细节。</p><h1 id="f0bf" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">包扎</h1><p id="506e" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">放下铅笔。14:59.加上一个漂亮的设计，这就是:静态验证的扫雷舰，只需不到15分钟。我们已经为其他<a class="ae ka" href="http://rjzaworski.com/c/typescript" rel="noopener ugc nofollow" target="_blank"> TypeScript教程</a>留下了大量的细节，但是这里介绍的模式可以适用于所有规模和形状的项目。</p><p id="2ff4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">完成的游戏并不是最漂亮的东西。没有测试，次优的渲染，设计团队有很多机会，但我们终于到了TypeScript最闪亮的地方。随着项目的发展，我们的类型声明中包含的所有假设都将被保留以供参考——并且在任何违反规则的时候都会有友好的警告作为支持。</p><p id="425b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Github 上查看<a class="ae ka" href="https://github.com/rjz/ts-minesweeper" rel="noopener ugc nofollow" target="_blank">完成的项目！</a></p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="mm lx l"/></div></figure></div></div>    
</body>
</html>