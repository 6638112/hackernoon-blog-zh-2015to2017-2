<html>
<head>
<title>GraphQL: Tips after a year in production</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL:生产一年后的提示</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/graphql-tips-after-a-year-in-production-419341db52e3?source=collection_archive---------1-----------------------#2016-12-18">https://medium.com/hackernoon/graphql-tips-after-a-year-in-production-419341db52e3?source=collection_archive---------1-----------------------#2016-12-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="e131" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我一年多以前写<a class="ae jp" href="https://github.com/mattkrick/meatier" rel="noopener ugc nofollow" target="_blank"> Meatier </a>的时候，我很早就采用了<a class="ae jp" href="https://hackernoon.com/tagged/graphql" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>来替换我的REST端点、ORM和我的必要的客户端数据请求。不久之后，当我受雇从头开始开发一个<a class="ae jp" href="https://github.com/ParabolInc/action/" rel="noopener ugc nofollow" target="_blank">开源实时应用</a>时，我抓住了在服务器上使用GraphQL的机会，并将其作为我自己的客户端缓存的基础。一年后，我了解到为生产构建一个GraphQL应用程序与你在GitHub上看到的那些演示应用程序有很大不同。去想想。在我犯了所有的错误之后，这里是我得到的教训。</p><p id="e72b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">GraphQL是灵活的。刚开始时，你经常怀疑自己的做法是否“正确”。GraphQL应该和mongoose这样的ORM对话，还是直接进入数据库？您是为密码、段落和标题创建自定义标量库，还是使用外部验证？你喜欢更多更小的变异(例如<strong class="it hv"> updateName，updateTitle </strong>)还是更大更强大的变异(例如<strong class="it hv"> updateUserDoc </strong>)？你应该用它来认证吗？(是)作为外部API的中介怎么样？(是的！)它能做订阅了吗？(有点)。让我们开始吃吧。</p><h1 id="e93f" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">1.文件夹结构</h1><p id="d9a4" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">哈欠节。但是说真的，保持GraphQL模式的模块化至关重要。我为每个DB实体保留了一个独立的文件夹(<strong class="it hv"> Post </strong>、<strong class="it hv"> Comment </strong>等)。)内部是每个操作的离散文件(<strong class="it hv"> PostQuery，PostMutation，PostSchema </strong>)。用文字解释文件夹结构很烂。<a class="ae jp" href="https://github.com/ParabolInc/action/tree/master/src/server/graphql" rel="noopener ugc nofollow" target="_blank">点击这里查看</a>。现在开始有趣的事情…</p><h1 id="ea90" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">2.使用Node.js连接到数据库</h1><p id="93e6" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在生产中，您使用驱动程序连接到数据库。所有的演示都在文件的顶部导入它们的DB驱动程序。这是废话，主要原因是:它不懒！当您启动服务器时，您的GraphQL端点将解析您的GraphQL模式文件，这反过来将解析您的db驱动程序并启动该连接。通过急切地实例化DB连接，您增加了启动服务器所需的时间。更重要的是，您的连接现在是有状态的，因此任何使用您的模式的webpack魔术(考虑为服务器端呈现创建一个webpack包)都需要管理该连接，并在必要时终止它。想象一下，构建一个通用的应用程序，同时构建客户端和服务器包&amp;，然后可能启动服务器。就像叫最后一个出去的人关门，却看不到也听不到任何人。意大利面代码变得不可避免。为了避免头痛，我只在必要时建立连接:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="7f9f" class="ld jr hu kz b fv le lf l lg lh">// getDBDriver.js<br/>let driver;<br/>export default function getDBDriver() {<br/>  if (!driver) driver = startDriver();<br/>  return driver;<br/>};</span></pre><p id="daf6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我不导入驱动程序，而是导入我的包装器&amp;在<strong class="it hv"> resolve </strong>方法中调用它:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="9097" class="ld jr hu kz b fv le lf l lg lh">// in userSchema.js<br/>resolve(source, {id}) {<br/>  const db = getDBDriver();<br/>  return db.get(id);<br/>}</span></pre><p id="c982" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我的进口没有副作用。耶关闭！</p><h1 id="5a83" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">3.结构化解析函数</h1><p id="828f" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在每个GraphQL演示中，<strong class="it hv"> <em class="kt"> resolve </em> </strong>函数除了解析什么也不做。一定很棒。在生产中，攻击者调用您的GraphQL端点，试图查询不属于他们的文档。即使有人拥有该文档，他们也可能试图传入不应该允许的值(例如<strong class="it hv"> userCredits = $1000000 </strong>)。那么，如何在保持代码可读性的同时保护自己呢？我的答案是我称之为验证/确认/解决模式的东西。为了描述它，让我们假设我们有一个应用程序，它的表单允许一个人更改他们的团队名称:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="8bb3" class="ld jr hu kz b fv le lf l lg lh">async resolve(<em class="kt">source</em>, {<em class="kt">updatedTeam</em>}, {<em class="kt">authToken</em>}) {<br/>  const db = getDBDriver();<br/><br/>  // AUTH<br/>  requireUserOnTeam(<em class="kt">authToken</em>, <em class="kt">updatedTeam</em>.id);<br/><br/>  // VALIDATION<br/>  const validate = makeTeamSchema();<br/>  const {errors, data: {id, name}} = validate(<em class="kt">updatedTeam</em>);<br/>  handleSchemaErrors(errors);<br/><br/>  // RESOLUTION<br/>  return await db.table('Team').get(id).update({name});<br/>}</span></pre><p id="c622" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在5行代码中，我建立了身份验证和授权。我已经验证并规范化了参数，并返回了结果。我们来分解一下。</p><h2 id="4715" class="ld jr hu bd js li lj lk jw ll lm ln ka jc lo lp ke jg lq lr ki jk ls lt km lu dt translated">作家（author的简写）</h2><p id="e48c" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在一个完整的企业SaaS中，我发现每一个突变只需要大约5个唯一身份验证检查中的1个。(他们签到了吗？他们在编辑属于他们或他们团队的东西吗？他们有活动的websocket连接吗？).这些是廉价的检查，以确保用户可以做他们想做的事情。理想情况下，它们是同步的。为了使它们同步，我有时会作弊&amp;在主键中加入额外的信息。比如一个用户有一个待办事项，而那个待办事项不能改变用户，我就把id <strong class="it hv">设为user123::xYz8yUo </strong>。当用户试图更新它时，我们可以将待办事项的<strong class="it hv"> id </strong>与他们的authToken/cookie中的id进行比较。当你有一个实时应用程序，并且以亚秒的间隔编辑同一个文档时，这种事情就变得至关重要。我不在乎你是否能黑掉选举，你仍然不能改变数据库中的主键。</p><h2 id="6500" class="ld jr hu bd js li lj lk jw ll lm ln ka jc lo lp ke jg lq lr ki jk ls lt km lu dt translated">确认</h2><p id="7f52" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">现在我们知道了<em class="kt">用户</em>是好的，我们需要看看<em class="kt">数据</em>是否是好的。当然，您可能已经在客户端验证了这一点，但是安全web应用程序的第一条规则是永远不要信任客户端。为此，我使用了一个函数来验证和规范化(例如<strong class="it hv"> String.trim() </strong>)数据。有很多流行的库，比如臃肿的<a class="ae jp" href="https://github.com/hapijs/joi" rel="noopener ugc nofollow" target="_blank"> Joi </a>和async <a class="ae jp" href="https://github.com/jquense/yup" rel="noopener ugc nofollow" target="_blank"> Yup </a>，但是我推出了自己的<a class="ae jp" href="https://github.com/ParabolInc/action/blob/ef26d6151addd6c9a34f263f115bb30cc82fc4e1/src/universal/validation/legitify.js" rel="noopener ugc nofollow" target="_blank"> 100 LOC解决方案</a>，它直接插入到<a class="ae jp" href="http://redux-form.com/6.2.1/" rel="noopener ugc nofollow" target="_blank"> redux-form </a>中，因此客户端和服务器可以使用相同的验证模式。</p><p id="8d67" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为什么没有GraphQL自定义标量？我以为那是应该走的路，但我错了。不幸的是，他们只是调情有用。他们冗长而缺乏力量。例如，如果我想验证一个新用户的电子邮件地址，我需要一个正则表达式，但是我还需要确保它不存在于我的数据库中。如果我需要在<strong class="it hv"> resolve </strong>函数中验证这一点，我也可以在那里使用正则表达式(并返回一个客户端错误消息，比GraphQL给我的糟糕结果要漂亮得多)。</p><h1 id="4279" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">4.编写您的模式</h1><p id="3733" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">有些人喜欢使用GraphQL简写来编写大文本blob模式。我不这样做的原因和我不把我所有的JavaScript写在文本文件中一样。这很难写，我喜欢IDE给我的彩色错误曲线。当然，在未来，编辑可能会发现GraphQL位的代码&amp;在运行中丢弃它们，但那一天不是今天。</p><p id="11cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">至于描述，有2件重要的事情需要包括:</p><ul class=""><li id="f5bc" class="lv lw hu it b iu iv iy iz jc lx jg ly jk lz jo ma mb mc md dt translated">星号表示数据库中有索引的字段(这样那些不能直接访问数据库的人仍然可以编写高效的查询)</li><li id="a8e9" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo ma mb mc md dt translated">描述如何生成任何id的描述符。这可能是:<strong class="it hv">短ID，UUID，团队Id::用户id，</strong>等。只是一些让你知道期待什么和你可能从中提取的任何非随机信息(对多对多关系特别有用)</li></ul><h1 id="1b2d" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">5.写你的突变</h1><p id="4676" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">古老的问题:你愿意和一只马大小的鸭子战斗，还是和100只鸭子大小的马战斗？</p><figure class="ku kv kw kx fq mk fe ff paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="fe ff mj"><img src="../Images/2ec82e7315f1137c4bc7807c06c75c47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hqz5VFnEzIThCtKhTr4UjA.jpeg"/></div></div><figcaption class="mr ms fg fe ff mt mu bd b be z ek">Honestly, I’d take the horses. I’m from the country. I’ve had to run from angry ducks.</figcaption></figure><p id="ec88" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它也适用于GraphQL。您应该编写1个变体来处理100种不同形式的数据，还是为文档的每种不同编辑方式编写100个不同的变体？虽然正确的答案总是“视情况而定”，但我喜欢默认更大、更强大的突变，因为它让你迭代得更快。如果你的表单得到了一个新的字段，你把它添加到前端，你把它添加到你的GraphQL模式，你的验证模式，你就可以开始了。当您开始在<strong class="it hv"> resolve </strong>函数中看到多个巨大的条件块和越来越多的参数时，您就知道是时候把它拆开了。</p><h1 id="7146" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">结束语</h1><p id="27f5" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">就是这样！您的GraphQL中级课程已经完成。如果你想深入了解GraphQL中的auth和错误处理，你可以随时查看我的<a class="ae jp" rel="noopener" href="/front-end-developers/graphql-field-guide-to-auth-ead84f657ab#.5nubbma4n"> GraphQL域Auth指南</a>。我是不是满口胡言？请在评论中告诉我。</p><div class="ku kv kw kx fq ab cb"><figure class="mv mk mw mx my mz na paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mv mk mw mx my mz na paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mv mk mw mx my mz na paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="nb nc nd"><p id="f922" class="ir is kt it b iu iv iw ix iy iz ja jb ne jd je jf nf jh ji jj ng jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is kt it b iu iv iw ix iy iz ja jb ne jd je jf nf jh ji jj ng jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ku kv kw kx fq mk"><div class="bz el l di"><div class="nh ni l"/></div></figure><figure class="ku kv kw kx fq mk fe ff paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="fe ff nj"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>