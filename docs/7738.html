<html>
<head>
<title>Organizing our Effects Effectively</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有效地组织我们的效果</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/organizing-our-effects-effectively-38bd95029339?source=collection_archive---------23-----------------------#2017-11-06">https://medium.com/hackernoon/organizing-our-effects-effectively-38bd95029339?source=collection_archive---------23-----------------------#2017-11-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="64d0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在过去的5周左右，我们已经建立了一个web应用程序，公开了一个小的API。该应用程序非常狭窄，仅包含少量功能。但它仍然很深入，涵盖了几种不同的库和技术。</p><p id="bddc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在接下来的几周里，我们将讨论一些架构上的考虑。我们将观察这个系统的一些弱点，以及如何改进它们。本周我们将关注一种使用类型类和单子变形器的方法。几周后，我们将考虑免费单子，以及如何使用它们。</p><p id="56e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以跟随Github repo的<a class="ae jp" href="https://github.com/jhb563/ProdHaskellSeries/tree/effects-1" rel="noopener ugc nofollow" target="_blank"> effects-1 </a>分支上的代码。</p><h1 id="2adf" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">弱点</h1><p id="157e" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在我们当前的系统中，有很多类似这样的不同功能:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="77e3" class="lc jr hu ky b fv ld le l lf lg">fetchUserPG :: PGInfo -&gt; Int64 -&gt; IO (Maybe User)<br/>createUserPG :: PGInfo -&gt; User -&gt; IO Int64<br/>cacheUser :: RedisInfo -&gt; Int64 -&gt; User -&gt; IO ()</span></pre><p id="5597" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，参数告诉我们每个函数应该访问什么。但是函数还是常规的<code class="eh lh li lj ky b">IO</code>函数。这意味着一个程序员新手可能会认为使用任意效果是没问题的。例如，为什么不从Redis函数中获取Postgres信息呢？毕竟，<code class="eh lh li lj ky b">fetchPGInfo</code>也是一个<code class="eh lh li lj ky b">IO</code>函数:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="0f7c" class="lc jr hu ky b fv ld le l lf lg">fetchPostgresConnection :: IO PGInfo<br/>...</span><span id="0a48" class="lc jr hu ky b fv lk le l lf lg">cacheUser :: RedisInfo -&gt; Int64 -&gt; User -&gt; IO ()<br/>cacheUser = do<br/>  pgInfo &lt;- fetchPostgresConnection<br/>  -- Connect to Postgres instead of Redis :(</span></pre><p id="5925" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的API在处理函数中也有一些不舒服的提升。我们必须调用<code class="eh lh li lj ky b">liftIO</code>，因为我们所有的数据库函数都是<code class="eh lh li lj ky b">IO</code>函数。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="efb8" class="lc jr hu ky b fv ld le l lf lg">fetchUsersHandler :: PGInfo -&gt; RedisInfo -&gt; Int64 -&gt; Handler User<br/>fetchUsersHandler pgInfo redisInfo uid = do<br/>  -- liftIO #1<br/>  maybeCachedUser &lt;- liftIO $ fetchUserRedis redisInfo uid<br/>  case maybeCachedUser of<br/>    Just user -&gt; return user<br/>    Nothing -&gt; do<br/>      -- liftIO #2<br/>      maybeUser &lt;- liftIO $ fetchUserPG pgInfo uid<br/>      case maybeUser of<br/>        -- liftIO #3<br/>        Just user -&gt; liftIO (cacheUser redisInfo uid user) &gt;&gt; return user<br/>        Nothing -&gt; Handler $ (throwE $ err401 { errBody = "Could not find user with that ID" })</span></pre><p id="6a95" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">至少，我们的连接参数在这里是显式的。如果我们把它们藏在阅读器里，这将会带来更多的提升。</p><p id="3845" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这篇文章将集中在使用类型类来限制我们如何使用效果。如果运气好的话，我们还会稍微清理一下代码，让测试变得更容易。但是下周我们会更加关注更多的测试。</p><p id="4103" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，根据项目的规模和范围，这些弱点可能不是问题。但这绝对是一个有用的练习，可以看到组织代码的其他方法。</p><h1 id="1392" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">定义我们的类型类</h1><p id="0dbb" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">限制效果的第一步是创建两个类型类。我们将有一个用于主数据库，一个用于缓存。我们将努力使这些函数与底层数据库表示无关。因此，我们将改变我们的API来移除<code class="eh lh li lj ky b">Entity</code>的概念。我们将用<code class="eh lh li lj ky b">KeyVal</code>的概念来代替它，它是一个元组的包装器。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="0554" class="lc jr hu ky b fv ld le l lf lg">newtype KeyVal a = KeyVal (Int64, a)</span></pre><p id="0621" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">至此，我们有了8个访问数据库的功能:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="5710" class="lc jr hu ky b fv ld le l lf lg">class (Monad m) =&gt; MonadDatabase m where<br/>  fetchUserDB :: Int64 -&gt; m (Maybe User) <br/>  createUserDB :: User -&gt; m Int64 <br/>  deleteUserDB :: Int64 -&gt; m ()<br/>  fetchArticleDB :: Int64 -&gt; m (Maybe Article)<br/>  createArticleDB :: Article -&gt; m Int64<br/>  deleteArticleDB :: Int64 -&gt; m ()<br/>  fetchArticlesByAuthor :: Int64 -&gt; m [KeyVal Article]<br/>  fetchRecentArticles :: m [(KeyVal User, KeyVal Article)]</span></pre><p id="f110" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，我们有三个函数用于与缓存交互:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="99db" class="lc jr hu ky b fv ld le l lf lg">class (Monad m) =&gt; MonadCache m where<br/>  cacheUser :: Int64 -&gt; User -&gt; m ()<br/>  fetchCachedUser :: Int64 -&gt; m (Maybe User)<br/>  deleteCachedUser :: Int64 -&gt; m ()</span></pre><p id="3688" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们现在可以为我们想要使用的任何不同的monad创建这些类型类的实例。让我们从描述现有库的实现开始。</p><h1 id="6cf6" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">编写实例</h1><p id="f9bf" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们从<code class="eh lh li lj ky b">SqlPersistT</code>开始。我们想为它制作一个<code class="eh lh li lj ky b">MonadDatabase</code>的实例。我们将收集前几篇文章中所有不同的功能。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="ba67" class="lc jr hu ky b fv ld le l lf lg">instance (MonadIO m, MonadLogger m) =&gt; MonadDatabase (SqlPersistT m) where<br/>  fetchUserDB uid = get (toSqlKey uid)</span><span id="9e45" class="lc jr hu ky b fv lk le l lf lg">  createUserDB user = fromSqlKey &lt;$&gt; insert user</span><span id="f5ae" class="lc jr hu ky b fv lk le l lf lg">  deleteUserDB uid = delete (toSqlKey uid :: Key User)</span><span id="a98b" class="lc jr hu ky b fv lk le l lf lg">  fetchArticleDB aid = ((fmap entityVal) . listToMaybe) &lt;$&gt; (select . from $ \articles -&gt; do<br/>    where_ (articles ^. ArticleId ==. val (toSqlKey aid))<br/>    return articles)</span><span id="5f55" class="lc jr hu ky b fv lk le l lf lg">  createArticleDB article = fromSqlKey &lt;$&gt; insert article</span><span id="6541" class="lc jr hu ky b fv lk le l lf lg">  deleteArticleDB aid = delete (toSqlKey aid :: Key Article)</span><span id="e3a6" class="lc jr hu ky b fv lk le l lf lg">  fetchArticlesByAuthor uid = do<br/>    entities &lt;- select . from $ \articles -&gt; do<br/>      where_ (articles ^. ArticleAuthorId ==. val (toSqlKey uid))<br/>      return articles<br/>    return $ unEntity &lt;$&gt; entities</span><span id="cf05" class="lc jr hu ky b fv lk le l lf lg">  fetchRecentArticles = do<br/>    tuples &lt;- select . from $ \(users `InnerJoin` articles) -&gt; do<br/>      on (users ^. UserId ==. articles ^. ArticleAuthorId)<br/>      orderBy [desc (articles ^. ArticlePublishedTime)]<br/>      limit 10<br/>      return (users, articles)<br/>    return $ (\(userEntity, articleEntity) -&gt; (unEntity userEntity, unEntity articleEntity)) &lt;$&gt; tuples</span></pre><p id="1f00" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为我们从API中移除了<code class="eh lh li lj ky b">Entity</code>，所以我们使用了这个<code class="eh lh li lj ky b">unEntity</code>函数。它会把钥匙和价值还给我们作为<code class="eh lh li lj ky b">KeyVal</code>:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="be72" class="lc jr hu ky b fv ld le l lf lg">unEntity :: (ToBackendKey SqlBackend a) =&gt; Entity a -&gt; KeyVal a<br/>unEntity (Entity id_ val_) = KeyVal (fromSqlKey id_, val_)</span></pre><p id="6cc6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们将对缓存函数做同样的事情。我们将为<code class="eh lh li lj ky b">Redis</code>单子制作一个<code class="eh lh li lj ky b">MonadCache</code>的实例:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="45fd" class="lc jr hu ky b fv ld le l lf lg">instance MonadCache Redis where<br/>  cacheUser uid user = void $ setex (pack . show $ uid) 3600 (pack . show $ user)<br/>  fetchCachedUser uid = do<br/>    result &lt;- get (pack . show $ uid)<br/>    case result of<br/>      Right (Just userString) -&gt; return $ Just (read . unpack $ userString)<br/>      _ -&gt; return Nothing<br/>  deleteCachedUser uid = void $ del [pack . show $ uid]</span></pre><p id="4804" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是全部了！让我们看看如何在我们的API中将这些结合起来以便于使用。</p><h1 id="5d94" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">制作我们的应用程序Monad</h1><p id="3009" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们想要描述一个“应用单子”，它将允许我们轻松地访问这两个功能。我们将制作一个monad转换器的包装器，包含一个Redis信息和<code class="eh lh li lj ky b">SqlPersistT</code> monad的阅读器。我们使用<code class="eh lh li lj ky b">GeneralizedNewtypeDeriving</code>推导出此类型的<code class="eh lh li lj ky b">Monad</code>:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="012e" class="lc jr hu ky b fv ld le l lf lg">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span><span id="7d6f" class="lc jr hu ky b fv lk le l lf lg">newtype AppMonad a = AppMonad (ReaderT RedisInfo (SqlPersistT (LoggingT IO)) a)<br/>  deriving (Functor, Applicative, Monad)</span></pre><p id="199a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们想创建<code class="eh lh li lj ky b">MonadDatabase</code>和<code class="eh lh li lj ky b">MonadCache</code>的实例。尽管实例很简单；我们将使用底层单子的实例。首先，让我们定义一个从<code class="eh lh li lj ky b">SqlPersistT</code>动作到<code class="eh lh li lj ky b">AppMonad</code>动作的转换。我们需要为此构建<code class="eh lh li lj ky b">ReaderT RedisInfo</code>。我们将使用<code class="eh lh li lj ky b">ReaderT</code>构造函数并忽略带有<code class="eh lh li lj ky b">const</code>的信息。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="5b15" class="lc jr hu ky b fv ld le l lf lg">liftSqlPersistT :: SqlPersistT (LoggingT IO) a -&gt; AppMonad a<br/>liftSqlPersistT action = AppMonad $ ReaderT (const action)</span></pre><p id="fe19" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还可以定义Redis操作的转换:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="8b2b" class="lc jr hu ky b fv ld le l lf lg">liftRedis :: Redis a -&gt; AppMonad a<br/>liftRedis action = do<br/>  info &lt;- AppMonad ask<br/>  connection &lt;- liftIO $ connect info<br/>  liftIO $ runRedis connection action</span></pre><p id="c6f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将像这样应用我们的底层实例:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="dfb2" class="lc jr hu ky b fv ld le l lf lg">instance MonadDatabase AppMonad where<br/>  fetchUserDB = liftSqlPersistT . fetchUserDB<br/>  createUserDB = liftSqlPersistT . createUserDB<br/>  deleteUserDB = liftSqlPersistT . deleteUserDB<br/>  fetchArticleDB = liftSqlPersistT . fetchArticleDB<br/>  createArticleDB = liftSqlPersistT . createArticleDB<br/>  deleteArticleDB = liftSqlPersistT . deleteArticleDB<br/>  fetchArticlesByAuthor = liftSqlPersistT . fetchArticlesByAuthor<br/>  fetchRecentArticles = liftSqlPersistT fetchRecentArticles</span><span id="98d7" class="lc jr hu ky b fv lk le l lf lg">instance MonadCache AppMonad where<br/>  cacheUser uid user = liftRedis (cacheUser uid user)<br/>  fetchCachedUser = liftRedis . fetchCachedUser <br/>  deleteCachedUser = liftRedis . deleteCachedUser</span></pre><p id="0cab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就是这样！我们有自己的例子。现在，我们想继续前进，并弄清楚如何将这个新的单子合并到我们的API中。</p><h1 id="5747" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">写一个自然的转变</h1><p id="11b0" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们想让我们的处理函数可以使用<code class="eh lh li lj ky b">AppMonad</code>而不是<code class="eh lh li lj ky b">Handler</code>单子。但是Servant被硬编码为使用<code class="eh lh li lj ky b">Handler</code>，那么我们该怎么办呢？答案是我们定义的“自然转化”。</p><p id="8d2a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我发现这个术语有点像“类别”。这似乎无关痛痒，但实际上是指一些深刻的数学问题。但是用起来不需要了解太多。类型运算符<code class="eh lh li lj ky b">(:~&gt;)</code>定义了一个自然转换。我们需要做的只是一个函数，它在我们的monad中获取一个动作，并将其转换为处理程序monad中的一个动作。我们将需要传递我们的连接信息，以使这一工作。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="534d" class="lc jr hu ky b fv ld le l lf lg">transformAppToHandler :: PGInfo -&gt; RedisInfo -&gt; AppMonad :~&gt; Handler</span></pre><p id="92d9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将从定义一个“处理程序”开始，它将捕捉我们抛出的任何错误，并将它们重新转换为服务错误。一般来说，您希望列出将要捕获的特定类型的异常。像这样捕捉每个异常并不是一个好主意。但是对于这个例子，我们将保持简单:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="cd9c" class="lc jr hu ky b fv ld le l lf lg">handler :: SomeException -&gt; IO (Either ServantErr a)<br/>handler e = return $ Left $ err500 { errBody = pack (show e)}</span></pre><p id="ead1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意这返回了一个<code class="eh lh li lj ky b">Either</code>，它总是一个<code class="eh lh li lj ky b">Left</code>。现在让我们定义如何将一个动作从我们的“AppMonad”转换成一个<code class="eh lh li lj ky b">Either</code>。我们将得到结果，并将其作为一个<code class="eh lh li lj ky b">Right</code>值传递。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="9c1b" class="lc jr hu ky b fv ld le l lf lg">runAppAction :: Exception e =&gt; AppMonad a -&gt; IO (Either e a)<br/>runAppAction (AppMonad action) = do<br/>  result &lt;- runPGAction pgInfo $ runReaderT action redisInfo<br/>  return $ Right result</span></pre><p id="47d1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">综合起来，这就是我们的转变。我们捕捉错误，然后将结果包装在<code class="eh lh li lj ky b">Handler</code>中。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="19db" class="lc jr hu ky b fv ld le l lf lg">transformAppToHandler :: PGInfo -&gt; RedisInfo -&gt; AppMonad :~&gt; Handler<br/>transformAppToHandler pgInfo redisInfo = NT $ \action -&gt; do<br/>  result &lt;- liftIO (handleAny handler (runAppAction action))<br/>  Handler $ either throwError return result<br/>  ...</span></pre><h1 id="af8c" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">整合应用Monad</h1><p id="7f01" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们现在要做的就是将新的单子合并到我们的处理程序中。首先，让我们更改API以删除实体:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="237f" class="lc jr hu ky b fv ld le l lf lg">type FullAPI =<br/>       "users" :&gt; Capture "userid" Int64 :&gt; Get '[JSON] User<br/>  :&lt;|&gt; "users" :&gt; ReqBody '[JSON] User :&gt; Post '[JSON] Int64<br/>  :&lt;|&gt; "articles" :&gt; Capture "articleid" Int64 :&gt; Get '[JSON] Article<br/>  :&lt;|&gt; "articles" :&gt; ReqBody '[JSON] Article :&gt; Post '[JSON] Int64<br/>  :&lt;|&gt; "articles" :&gt; "author" :&gt; Capture "authorid" Int64 :&gt; Get '[JSON] [KeyVal Article]<br/>  :&lt;|&gt; "articles" :&gt; "recent" :&gt; Get '[JSON] [(KeyVal User, KeyVal Article)]</span></pre><p id="06ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们想更新每个函数的类型。<code class="eh lh li lj ky b">AppMonad</code>包含所有配置信息。所以我们不需要显式传递连接信息。相反，我们可以在我们的monad类型类上使用约束来暴露这些效果。下面是我们的类型签名的样子:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="e130" class="lc jr hu ky b fv ld le l lf lg">fetchUsersHandler :: (MonadDatabase m, MonadCache m) =&gt; Int64 -&gt; m User<br/>createUserHandler :: (MonadDatabase m) =&gt; User -&gt; m Int64<br/>fetchArticleHandler :: (MonadDatabase m) =&gt; Int64 -&gt; m Article<br/>createArticleHandler :: (MonadDatabase m)=&gt; Article -&gt; m Int64<br/>fetchArticlesByAuthorHandler :: (MonadDatabase m) =&gt; Int64 -&gt; m [KeyVal Article]<br/>fetchRecentArticlesHandler :: (MonadDatabase m) =&gt; m [(KeyVal User, KeyVal Article)]</span></pre><p id="eaac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们的很多函数都是简单的一元调用。我们甚至不需要使用“电梯”！</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="84d7" class="lc jr hu ky b fv ld le l lf lg">createUserHandler :: (MonadDatabase m) =&gt; User -&gt; m Int64<br/>createUserHandler = createUserDB</span><span id="0101" class="lc jr hu ky b fv lk le l lf lg">createArticleHandler :: (MonadDatabase m)=&gt; Article -&gt; m Int64<br/>createArticleHandler = createArticleDB</span><span id="1428" class="lc jr hu ky b fv lk le l lf lg">fetchArticlesByAuthorHandler :: (MonadDatabase m) =&gt; Int64 -&gt; m [KeyVal Article]<br/>fetchArticlesByAuthorHandler = fetchArticlesByAuthor</span><span id="19de" class="lc jr hu ky b fv lk le l lf lg">fetchRecentArticlesHandler :: (MonadDatabase m) =&gt; m [(KeyVal User, KeyVal Article)]<br/>fetchRecentArticlesHandler = fetchRecentArticles</span></pre><p id="6c12" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">“获取”函数有点复杂，因为我们想先检查缓存。但是，我们所有的函数都是简单的一元调用，没有使用任何提升。下面是我们的获取处理程序的样子:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="8fe2" class="lc jr hu ky b fv ld le l lf lg">fetchUsersHandler :: (MonadDatabase m, MonadCache m) =&gt; Int64 -&gt; m User<br/>fetchUsersHandler uid = do<br/>  maybeCachedUser &lt;- fetchCachedUser uid<br/>  case maybeCachedUser of<br/>    Just user -&gt; return user<br/>    Nothing -&gt; do<br/>      maybeUser &lt;- fetchUserDB uid<br/>      case maybeUser of<br/>        Just user -&gt; cacheUser uid user &gt;&gt; return user<br/>        Nothing -&gt; error "Could not find user with that ID"</span><span id="be07" class="lc jr hu ky b fv lk le l lf lg">fetchArticleHandler :: (MonadDatabase m) =&gt; Int64 -&gt; m Article<br/>fetchArticleHandler aid = do<br/>  maybeArticle &lt;- fetchArticleDB aid<br/>  case maybeArticle of<br/>    Just article -&gt; return article<br/>    Nothing -&gt; error "Could not find article with that ID"</span></pre><p id="d33f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们将改变我们的<code class="eh lh li lj ky b">Server</code>函数。我们将更新它，使它把我们的自然转换作为一个参数。然后我们将使用与转换相结合的<code class="eh lh li lj ky b">enter</code>函数。这就是仆人如何知道我们想要什么单子给我们的处理程序:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="586b" class="lc jr hu ky b fv ld le l lf lg">fullAPIServer :: (AppMoand :~&gt; Handler) -&gt; Server FullAPI<br/>fullAPIServer naturalTransformation =<br/>  enter naturalTransformation $<br/>    fetchUsersHandler :&lt;|&gt;<br/>    createUserHandler :&lt;|&gt;<br/>    fetchArticleHandler :&lt;|&gt;<br/>    createArticleHandler :&lt;|&gt;<br/>    fetchArticlesByAuthorHandler :&lt;|&gt;<br/>    fetchRecentArticlesHandler</span><span id="961a" class="lc jr hu ky b fv lk le l lf lg">runServer :: IO ()<br/>runServer = do<br/>  pgInfo &lt;- fetchPostgresConnection<br/>  redisInfo &lt;- fetchRedisConnection<br/>  -- Pass the natural transformation as an argument!<br/>  run 8000 (serve usersAPI (fullAPIServer (transformAppToHandler pgInfo redisInfo)))</span></pre><p id="9154" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们完成了！</p><h1 id="bca0" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">这种方法的缺点</h1><p id="435b" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">当然，这个系统也不是没有弱点。特别是，有相当多的样板文件。如果我们不想固定单子堆栈的顺序，这一点尤其正确。例如，如果我们应用程序的另一部分将<code class="eh lh li lj ky b">SqlPersistT</code>放在<code class="eh lh li lj ky b">Redis</code>的上面会怎么样？如果我们想把其他的单子变形金刚混进去呢？为此，我们需要<code class="eh lh li lj ky b">MonadDatabase</code>和<code class="eh lh li lj ky b">MonadCache</code>的新实例。我们最终会写出更多简单的定义。当我们看自由单子时，我们将在几周内检查这个弱点的解决方案。</p><p id="9417" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每当我们想要更新它们的功能时，我们还需要向我们的类型类添加新的函数。然后，我们将不得不更新该类型类的每个实例，这可能是相当痛苦的。我们拥有的实例越多，添加新功能就越困难。</p><h1 id="6010" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">结论</h1><p id="6eab" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">因此，通过一些有用的技巧，我们可以得到更简洁的代码。我们使用类型类来限制应用程序中的效果。通过为不同的单子编写这些类的实例，我们可以改变应用程序的行为。下周，我们将看到如何使用这个行为来编写更简单的测试！</p><p id="1881" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当管理一个依赖如此之多的应用程序时，您需要合适的工具。我用<a class="ae jp" href="https://docs.haskellstack.org/en/stable/README/" rel="noopener ugc nofollow" target="_blank"> Stack </a>来组织我所有的Haskell项目。查看我们免费的<a class="ae jp" href="http://academy.mondaymorninghaskell.com/p/your-first-haskell-project" rel="noopener ugc nofollow" target="_blank">堆栈迷你课程</a>了解更多信息！</p><p id="3239" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是如果你从来没有尝试过Haskell，那就试试吧！看看我们的<a class="ae jp" href="https://www.mmhaskell.com/checklist" rel="noopener ugc nofollow" target="_blank">入门清单</a>。</p></div></div>    
</body>
</html>