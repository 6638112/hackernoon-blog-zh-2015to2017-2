<html>
<head>
<title>Optimising the front end for the browser</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化浏览器的前端</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/optimising-the-front-end-for-the-browser-f2f51a29c572?source=collection_archive---------0-----------------------#2017-02-09">https://medium.com/hackernoon/optimising-the-front-end-for-the-browser-f2f51a29c572?source=collection_archive---------0-----------------------#2017-02-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/a538e66b2a74d4f6a7fe6b89f2f40e8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xS9MOKc_DBGGQBUhLd0dEg.png"/></div></div></figure><div class=""/><p id="05d5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你在字典中查找优化(或为我们美国读者的优化)，它会说一些类似于<em class="ka">充分利用我们所拥有的</em>的东西。</p><p id="29ad" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接受有价值的努力和挑战。</p><h1 id="83cc" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">背景</h1><p id="de89" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在2016年，我的整个团队有机会花一些时间对我们的代码库进行升级，这让我开始思考我们应该如何构建我们的前端。我很快意识到浏览器将是我们方法中的一个重要因素，也是我们知识中的一个同样大的瓶颈。</p><p id="b895" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从那以后，我的团队有幸将大量的理论付诸实践，让我们学到了很多东西。</p><p id="9d9a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我也在网上和很多其他开发者交流过，也在关于优化的讲座上交流过，所以我想把我的知识传授给你们。</p><h1 id="ad60" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">为什么要优化？</h1><ul class=""><li id="9959" class="le lf if je b jf kz jj la jn lg jr lh jv li jz lj lk ll lm dt translated">用户更高兴了，因为网页加载速度更快，并且可以提供更好的UX。</li><li id="75da" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">开发人员更高兴了，因为您的代码库和架构遵循了最佳实践。</li><li id="38cf" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">由于潜在的更低的跳出率和更高的转换率，业务变得更加愉快。</li><li id="b7d0" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">当速度和优化对SEO排名影响更大时，你可以在将来证明你的代码。</li><li id="f08b" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">你可以帮助网络成为一个更好的地方。</li></ul><h1 id="1bdf" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">方法</h1><h2 id="edc5" class="ls kc if bd kd lt lu lv kh lw lx ly kl jn lz ma kp jr mb mc kt jv md me kx mf dt translated">第一</h2><p id="fc77" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们无法控制浏览器或改变它的行为方式，但我们可以理解它是如何工作的，这样我们就可以优化我们提供的有效载荷。</p><p id="39d2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">幸运的是，浏览器行为的基本面相当稳定，<a class="ae mg" href="https://developers.google.com/web/fundamentals/" rel="noopener ugc nofollow" target="_blank">有据可查</a>，而且在很长一段时间内不太可能发生重大变化。</p><p id="6ba4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以这至少给了我们一个努力的目标。</p><h2 id="1c54" class="ls kc if bd kd lt lu lv kh lw lx ly kl jn lz ma kp jr mb mc kt jv md me kx mf dt translated">第二</h2><p id="15e1" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">另一方面，代码、堆栈、架构和模式是我们可以控制的。它们更加灵活，变化速度更快，为我们提供了更多的选择。</p><h2 id="445a" class="ls kc if bd kd lt lu lv kh lw lx ly kl jn lz ma kp jr mb mc kt jv md me kx mf dt translated">因此</h2><p id="ef35" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我决定从外向内工作，弄清楚我们代码的最终结果应该是什么，然后形成关于编写代码的意见。在第一篇博客中，我们将集中讨论所有我们需要知道的关于浏览器的事情。</p><h1 id="f986" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">浏览器的功能</h1><p id="9c3d" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">让我们积累一些知识。这里有一些我们希望浏览器运行的普通HTML。</p><figure class="mh mi mj mk fq hw"><div class="bz el l di"><div class="ml mm l"/></div></figure><h2 id="d3a0" class="ls kc if bd kd lt lu lv kh lw lx ly kl jn lz ma kp jr mb mc kt jv md me kx mf dt translated">浏览器呈现页面的方式</h2><p id="590f" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">当浏览器收到我们的HTML时，它会解析它，将其分解成它能理解的词汇，这在所有浏览器中都保持一致，这要归功于<a class="ae mg" href="https://www.w3.org/TR/html5/dom.html" rel="noopener ugc nofollow" target="_blank"> HTML5 DOM规范</a>。然后，它通过一系列步骤来构建和呈现页面。这是非常高层次的概述。</p><ol class=""><li id="0254" class="le lf if je b jf jg jj jk jn mn jr mo jv mp jz mq lk ll lm dt translated">使用HTML创建文档对象模型(<strong class="je ig"> DOM </strong>)。</li><li id="761d" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz mq lk ll lm dt translated">使用CSS创建CSS对象模型(<strong class="je ig"> CSSOM </strong>)。</li><li id="8cb4" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz mq lk ll lm dt translated">在DOM和CSSOM上执行<strong class="je ig">脚本</strong>。</li><li id="7730" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz mq lk ll lm dt translated">结合DOM和CSSOM形成<strong class="je ig">渲染树</strong>。</li><li id="9584" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz mq lk ll lm dt translated">使用渲染树来<strong class="je ig">布局</strong>所有元素的大小和位置。</li><li id="8e74" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz mq lk ll lm dt translated"><strong class="je ig">在所有像素中绘制</strong>。</li></ol><figure class="mh mi mj mk fq hw fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/372ae376a7aecce1704a99fdaba9d3c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iGvSHKFsbjKHIrhBos7p1w.png"/></div></figure><h1 id="56fe" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">第一步— HTML</h1><p id="4e43" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">浏览器开始从上到下读取标记，并通过将其分解为节点来创建DOM。</p><figure class="mh mi mj mk fq hw fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/65488393ea9cb0ff1b4b0878ac9becdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d6a_A4DAp1zZDyzSrTsQqg.png"/></div></figure><h2 id="06a4" class="ls kc if bd kd lt lu lv kh lw lx ly kl jn lz ma kp jr mb mc kt jv md me kx mf dt translated">HTML交付优化策略</h2><ul class=""><li id="4404" class="le lf if je b jf kz jj la jn lg jr lh jv li jz lj lk ll lm dt translated">顶部是样式，底部是脚本</li></ul><p id="a5c5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然这条规则也有例外和细微差别，但总的想法是尽可能早地加载样式，尽可能晚地加载脚本。这样做的原因是脚本需要HTML和CSS在执行之前完成解析，因此我们将样式放在高处，这样在我们在底部编译和执行脚本之前，它们有足够的时间进行计算。</p><p id="9689" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我们将研究如何在优化的同时进行调整。</p><ul class=""><li id="a3e4" class="le lf if je b jf jg jj jk jn mn jr mo jv mp jz lj lk ll lm dt translated">缩小和压缩</li></ul><p id="a4b9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这适用于我们交付的所有内容，包括HTML、CSS、<a class="ae mg" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>、图像和其他资产。</p><p id="4b68" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">缩小删除任何多余的字符，包括空白、注释、多余的分号等。</p><p id="8025" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">压缩，例如GZip，通过为代码或资产分配一个指向原始实例的指针来替换代码或资产中重复的数据。大规模压缩下载文件的大小，转而依靠客户端来解压文件。</p><p id="8cc4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过这两种方法，你可以将有效载荷减少80%或90%。例如<a class="ae mg" href="https://css-tricks.com/the-difference-between-minification-and-gzipping/#article-header-id-2" rel="noopener ugc nofollow" target="_blank">仅在bootstrap上就节省了87%</a>。</p><ul class=""><li id="a90f" class="le lf if je b jf jg jj jk jn mn jr mo jv mp jz lj lk ll lm dt translated">预加载、预取、预呈现、预连接</li></ul><p id="7588" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这四个html属性允许我们先发制人地加载资源或建立用户将来可能需要的网络连接。</p><p id="8634" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">属性允许我们预加载在当前页面导航中需要的资源。</p><p id="6751" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">属性允许我们为将来的导航预取资源和网络请求。</p><p id="41bd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ms mt mu mv b">prerender</code>属性在后台完全呈现页面。</p><p id="7058" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ms mt mu mv b">preconnect</code>属性预测未来的网络请求，并执行DNS查找、TLS协商和TCP握手。</p><p id="c4b1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在KeyCDN 和CSS-tricks 上有大量关于这些非常强大的属性<a class="ae mg" href="https://www.keycdn.com/blog/resource-hints/" rel="noopener ugc nofollow" target="_blank">的有用信息。</a></p><ul class=""><li id="3ea8" class="le lf if je b jf jg jj jk jn mn jr mo jv mp jz lj lk ll lm dt translated">易接近</li></ul><p id="c466" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然这不会让你的页面下载更快，但它会大大提高受损用户的满意度。一定要给大家提供！在元素上使用<code class="eh ms mt mu mv b">aria</code>标签，在图像上提供<code class="eh ms mt mu mv b">alt</code>文本以及所有那些<a class="ae mg" href="http://www.clarissapeterson.com/2012/11/html5-accessibility/" rel="noopener ugc nofollow" target="_blank">其他好东西</a>。</p><p id="19bf" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用像<a class="ae mg" href="http://wave.webaim.org/" rel="noopener ugc nofollow" target="_blank"> WAVE </a>这样的工具来找出你可以提高可访问性的地方。</p><h1 id="0648" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">第二步— CSS</h1><p id="a094" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">当它找到任何样式相关的节点时，即外部、内部或内联样式，它停止<strong class="je ig">呈现</strong>DOM，并使用这些节点创建CSSOM。这就是为什么他们把CSS叫做<strong class="je ig">渲染分块</strong>。以下是不同类型风格的优缺点。</p><figure class="mh mi mj mk fq hw"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="95ff" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">CSSOM节点的创建就像DOM节点一样，稍后它们会被合并，但现在它们看起来是这样的。</p><figure class="mh mi mj mk fq hw fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/3b72b6659caff6f5881dd74286081a13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qvhLFgHUP0A2SaYKfwrHUQ.png"/></div></figure><p id="cfa3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">CSSOM的构造阻碍了页面的呈现，所以我们希望在树中尽可能早地加载样式，使它们尽可能轻量级，并在有效的情况下延迟加载它们。</p><h2 id="7ee8" class="ls kc if bd kd lt lu lv kh lw lx ly kl jn lz ma kp jr mb mc kt jv md me kx mf dt translated">CSS交付优化策略</h2><ul class=""><li id="3503" class="le lf if je b jf kz jj la jn lg jr lh jv li jz lj lk ll lm dt translated">使用<a class="ae mg" href="https://developer.mozilla.org/en-US/docs/Web/CSS/@media" rel="noopener ugc nofollow" target="_blank">媒体属性</a>。</li></ul><p id="f4ab" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">媒体属性指定了加载样式必须满足的条件，例如，是否有最大或最小分辨率？是为了屏幕阅读器吗？</p><p id="8b69" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">台式机非常强大，但移动设备却不是，所以我们希望尽可能减轻它们的负载。我们可以先假设只提供移动样式，然后把桌面样式作为媒体的条件，虽然这不会阻止它下载，但会阻止它加载我们的页面并耗尽宝贵的资源。</p><figure class="mh mi mj mk fq hw"><div class="bz el l di"><div class="ml mm l"/></div></figure><ul class=""><li id="1e8c" class="le lf if je b jf jg jj jk jn mn jr mo jv mp jz lj lk ll lm dt translated">推迟CSS的加载</li></ul><p id="2c24" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你有样式，可以等到第一次有意义的绘制之后再加载和计算，例如，出现在折叠下面的内容，或者在页面有响应之前不重要的内容。在附加样式之前，您可以使用脚本等待页面加载。</p><figure class="mh mi mj mk fq hw"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="bebe" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里有一个如何实现这一点的<a class="ae mg" href="https://jakearchibald.com/2016/link-in-body/" rel="noopener ugc nofollow" target="_blank">示例</a>，还有一个<a class="ae mg" href="https://www.giftofspeed.com/defer-loading-css/" rel="noopener ugc nofollow" target="_blank">示例</a>。我的团队已经非常成功地使用了filamentgroup 的<a class="ae mg" href="https://github.com/filamentgroup/loadCSS" rel="noopener ugc nofollow" target="_blank"> LoadCSS包，我绝对推荐它。</a></p><ul class=""><li id="4772" class="le lf if je b jf jg jj jk jn mn jr mo jv mp jz lj lk ll lm dt translated">特异性较低</li></ul><p id="951a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个明显的缺点是，随着更多的元素链接在一起，物理上有更多的数据要传输，从而扩大了CSS文件，但在计算具有更高特异性的样式时，也有客户端计算消耗。</p><figure class="mh mi mj mk fq hw"><div class="bz el l di"><div class="ml mm l"/></div></figure><ul class=""><li id="ab18" class="le lf if je b jf jg jj jk jn mn jr mo jv mp jz lj lk ll lm dt translated">仅交付您需要的东西</li></ul><p id="08de" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这听起来可能很傻或者很傲慢，但是如果你在前端工作过一段时间，你就会知道CSS的一个大问题是删除内容的不可预测性。从设计上来说，它被诅咒了要不停地生长。</p><p id="8f56" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了尽可能地精简CSS，可以使用像<a class="ae mg" href="https://github.com/giakki/uncss" rel="noopener ugc nofollow" target="_blank"> uncss </a>包这样的工具，或者如果你想要一个网络替代品，那么就四处看看，有很多选择。</p><h1 id="aa2a" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">第三步— JavaScript</h1><p id="ceaa" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">然后，浏览器继续构建DOM/CSSOM节点，直到找到任何JavaScript节点，即外部或内联脚本。</p><figure class="mh mi mj mk fq hw"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="ae9b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为我们的脚本可能需要访问或操作先前的HTML或样式，所以我们必须等待它们全部构建完成。</p><p id="a56c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，浏览器必须停止<strong class="je ig">解析</strong>节点，完成构建CSSOM，执行脚本，然后继续。这就是为什么他们称JavaScript为“<strong class="je ig">解析器阻塞</strong>”。</p><p id="44fd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">浏览器有一种叫做“预加载扫描器”的东西，它会扫描DOM中的脚本并开始预加载它们，但是脚本只有在前面的CSS节点被构造之后才会按顺序执行。</p><p id="f581" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果这是我们的剧本:</p><figure class="mh mi mj mk fq hw"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="e48e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那么这将是对我们的DOM和CSSOM的影响:</p><figure class="mh mi mj mk fq hw fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/b3a9bcfd3a2ff48f14ee154408050527.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FnWl0pkQjfJ8G46AINMuyQ.png"/></div></figure><h2 id="f66f" class="ls kc if bd kd lt lu lv kh lw lx ly kl jn lz ma kp jr mb mc kt jv md me kx mf dt translated">JavaScript交付优化策略</h2><p id="4722" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">优化我们的脚本是我们能做的最重要的事情之一，也是大多数网站做得最差的事情之一。</p><ul class=""><li id="c22b" class="le lf if je b jf jg jj jk jn mn jr mo jv mp jz lj lk ll lm dt translated">异步加载脚本</li></ul><p id="7654" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过在我们的脚本中使用一个<code class="eh ms mt mu mv b">async</code>属性，我们可以告诉浏览器继续用另一个低优先级的线程下载它，但是不要阻塞其余的页面加载。一旦下载完成，它就会执行。</p><figure class="mh mi mj mk fq hw"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="6a1e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这意味着它可以在任何时候执行，这导致了两个明显的问题。首先，它可能会在页面加载后很久才执行，所以如果我们依赖它为UX做一些事情，那么我们可能会给用户一个次优的体验。第二，如果它碰巧在页面完成加载之前执行，我们不能预测它将访问正确的DOM/CSSOM元素，并且可能会中断。</p><figure class="mh mi mj mk fq hw fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/c0d6a4d9dac017c060102ea5d56acac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gUx2xj314KR0X22IeqEjsA.png"/></div></figure><p id="ddb1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ms mt mu mv b">async</code>对于不影响我们的DOM或CSSOM的脚本来说是非常好的，对于不需要了解我们的代码并且对于UX来说不是必要的外部脚本来说肯定是非常好的，比如分析或跟踪。但是如果你发现它的任何好的用例，那么就使用它。</p><ul class=""><li id="9116" class="le lf if je b jf jg jj jk jn mn jr mo jv mp jz lj lk ll lm dt translated">延迟加载脚本</li></ul><p id="d7c5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ms mt mu mv b">defer</code>与<code class="eh ms mt mu mv b">async</code>非常相似，它不会阻止页面的加载，但是，它会等到我们的HTML被解析后再执行，并按外观顺序执行。</p><figure class="mh mi mj mk fq hw fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/1d93f8164748482d8b921d36f58e34a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WCaJghZuI4iVlVDF8cg0uA.png"/></div></figure><p id="fccd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这对于脚本来说是一个非常好的选择，这些脚本将作用于我们的渲染树，但对于加载页面的折叠内容来说并不重要，或者需要之前已经运行的脚本。</p><figure class="mh mi mj mk fq hw"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="a8c9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里有<a class="ae mg" href="https://varvy.com/pagespeed/defer-loading-javascript.html" rel="noopener ugc nofollow" target="_blank">另一个使用延迟策略的很好的选择</a>，或者你可以使用类似<code class="eh ms mt mu mv b">addEventListener</code>的东西。如果你想知道更多，那么这里是开始阅读的好地方。</p><figure class="mh mi mj mk fq hw"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="7eab" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不幸的是，<code class="eh ms mt mu mv b">async</code>和<code class="eh ms mt mu mv b">defer</code>不能处理内联脚本，因为默认情况下，浏览器一有它们就会编译并执行它们。当它们在HTML中内联时，它们会立即运行，通过在外部资源上使用上述两个属性，我们只是抽象掉或延迟了我们的脚本到我们的DOM/CSSOM的发布。</p><ul class=""><li id="df09" class="le lf if je b jf jg jj jk jn mn jr mo jv mp jz lj lk ll lm dt translated">操作前克隆节点</li></ul><p id="f7bb" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当且仅当您在对DOM执行多次更改时看到不必要的行为时，请尝试这样做。</p><p id="2d22" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先克隆整个DOM节点，对克隆节点进行修改，然后用它替换原来的节点，这样可以避免多次重绘，降低CPU和内存负载，这样可能会更有效。它还可以防止页面的“抖动”变化和无样式内容的闪烁。</p><figure class="mh mi mj mk fq hw"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="ff96" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">克隆时要小心，因为它不会克隆事件侦听器。有时候这可能正是你想要的。过去，当事件监听器不调用命名函数时，我们使用这种方法来重置事件监听器，并且我们没有JQuery的<code class="eh ms mt mu mv b">.on()</code>和<code class="eh ms mt mu mv b">.off()</code>方法可用。</p><h1 id="1e84" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">第四步——渲染树</h1><p id="4005" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">一旦读取了所有节点，并且准备好组合DOM和CSSOM，浏览器就构建呈现树。如果我们把节点看作单词，把对象模型看作句子，那么渲染树就是一整页。现在，浏览器拥有了呈现页面所需的一切。</p><figure class="mh mi mj mk fq hw fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/ff4187e0db6ffa5f32228a0eabd07e85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_uqUTyUlC-8A4JIkm2_r3Q.png"/></div></figure><h1 id="4140" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">第五步—布局</h1><p id="ebd0" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">然后我们进入布局阶段，确定页面上所有元素的大小和位置。</p><figure class="mh mi mj mk fq hw fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/1e0eb9360bf8f51fc7e511ba4abe42eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xx60n7T-n_yWnP0qcVeshQ.png"/></div></figure><h1 id="2100" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">第六步——绘画</h1><p id="4546" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">最后，我们进入绘画阶段，我们实际上将屏幕上的像素光栅化，为用户“绘画”页面。</p><figure class="mh mi mj mk fq hw fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/8a898812d53caba861a631f2892ac30e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4kId2si_o9DOXWG612Z-Ug.png"/></div></figure><p id="662d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">而这一切通常发生在几秒或几十分之一秒内。我们的工作是加快速度。</p><p id="ab64" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果JavaScript事件改变了页面的任何部分，就会导致渲染树的重绘，并迫使我们重新进行布局和绘制。现代浏览器足够智能，只进行部分重绘，但我们不能指望这是有效的或高性能的。</p><p id="f58b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">话虽如此，显然JavaScript在很大程度上是基于客户端事件的，我们希望它操纵我们的DOM，所以它将会这样做。我们只需要限制它的不良影响。</p><p id="4088" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">到现在为止，你已经知道了足够多的东西来欣赏程昕婷·加西尔的演讲。这是2012年的数据，但信息仍然正确。她关于这个主题的综合论文可以在这里阅读。</p><figure class="mh mi mj mk fq hw"><div class="bz el l di"><div class="mw mm l"/></div></figure><p id="2adf" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你喜欢到目前为止所读的内容，但仍然渴望了解更多的低级技术内容，那么你所有知识的神谕就是<a class="ae mg" href="https://www.w3.org/TR/html5/" rel="noopener ugc nofollow" target="_blank"> HTML5规范</a>。</p><p id="9ea0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们就快到了，再陪我一会儿吧！现在我们发现了为什么我们需要知道以上所有的事情。</p><h1 id="9fca" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">浏览器如何进行网络调用</h1><p id="bf2f" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在本节中，我们将了解如何最有效地向浏览器传输呈现页面所需的数据。</p><p id="d300" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当浏览器请求一个URL时，我们的服务器用一些HTML来响应。我们将从非常小的开始，慢慢增加复杂性。</p><p id="091c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设这是我们页面的HTML。</p><figure class="mh mi mj mk fq hw"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="ce23" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们需要学习一个新术语，关键渲染路径(CRP)。它只是意味着浏览器呈现页面需要的步骤数量。这是我们的CRP图表现在的样子。</p><figure class="mh mi mj mk fq hw fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/377b331cca4db4a8e5da8520f27e0156.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wy_HC3gRPD_qNFReb1eBWg.png"/></div></figure><p id="5c06" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">浏览器发出一个GET请求，它一直闲置，直到我们用页面所需的1kb HTML(还没有CSS或JavaScript)作出响应，然后它能够构建DOM并呈现页面。</p><h2 id="e4c4" class="ls kc if bd kd lt lu lv kh lw lx ly kl jn lz ma kp jr mb mc kt jv md me kx mf dt translated">关键路径长度</h2><p id="7698" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">三个CRP指标中的第一个是路径长度。我们希望它尽可能的低。</p><p id="1956" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">浏览器与服务器进行一次往返，以检索呈现页面所需的HTML，这就是它所需要的全部。因此我们的关键路径长度是1，完美。</p><p id="94e8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在让我们把它提升一个档次，加入一些内部风格和JavaScript。</p><figure class="mh mi mj mk fq hw"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="dca5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们检查我们的CRP图表，我们应该看到一些变化。</p><figure class="mh mi mj mk fq hw fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/b078399c6d77ddf7b59047dd6e9eaec5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zeq8ep9eapZYElEPZsjLhQ.png"/></div></figure><p id="7145" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们有两个额外的步骤，<strong class="je ig">构建CSSOM </strong>和<strong class="je ig">执行脚本</strong>。这是因为我们的HTML有需要计算的内部样式和脚本。然而，因为不需要发出外部请求，所以它们不会增加我们的关键路径长度，耶！</p><p id="6317" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是等等，不要这么快。还要注意，我们的HTML大小增加到了2kb，所以我们不得不在某个地方做些改动。</p><h2 id="d6f8" class="ls kc if bd kd lt lu lv kh lw lx ly kl jn lz ma kp jr mb mc kt jv md me kx mf dt translated">关键字节</h2><p id="d6a9" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">这就是我们三个指标中的第二个指标的用武之地，关键字节。这度量了呈现页面需要传输多少字节。并不是所有的字节都将下载到页面上，而是真正呈现我们的页面并使其响应用户所需的字节。</p><p id="8860" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不用说，我们也想尽量减少这种情况。</p><p id="e08e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你认为这很好，谁还需要外部资源，那你就错了。虽然这看起来很诱人，但在大规模上并不可行。实际上，如果我的团队必须交付一个包含内部或内联所需的所有内容的页面，这将是一个巨大的工程。并且浏览器不是为处理这样的负载而构建的。</p><p id="d8a4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">看看这篇<a class="ae mg" href="https://www.ctheu.com/2015/08/17/react-inline-styles-vs-css-stupid-benchmark/" rel="noopener ugc nofollow" target="_blank">有趣的文章</a>关于像React推荐的那样内联所有样式时页面加载的影响。DOM的大小增加了四倍，装载时间增加了一倍，响应时间增加了50%。相当不能接受。</p><p id="5b62" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还要考虑这样一个事实，即外部资源可以被缓存，因此当再次访问我们的页面，或者访问使用相同资源的其他页面(例如<code class="eh ms mt mu mv b">my-global.css</code>)时，浏览器将不会进行网络调用，而是使用其缓存版本，从而对我们来说是一个更大的胜利。</p><p id="45af" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，让我们成长起来，并使用外部资源为我们的风格和脚本。注意，我们有1个外部CSS文件、1个外部JavaScript文件和1个外部<code class="eh ms mt mu mv b">async</code> JavaScript文件。</p><figure class="mh mi mj mk fq hw"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="c9e4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是我们的CRP图表现在的样子。</p><figure class="mh mi mj mk fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mx"><img src="../Images/f709d5af2b6615e71bd5fe759fe429c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fInHIT4sWSm5QJrCkFH_yQ.png"/></div></div></figure><p id="2d04" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">浏览器得到我们的页面，构建DOM，一旦它发现任何外部资源，预加载扫描器就会启动。这将继续下去，并开始下载它可以在HTML中找到的所有外部资源。CSS和JavaScript优先级较高，其他资源优先级较低。</p><p id="00a3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它捡起了我们的<code class="eh ms mt mu mv b">styles.css</code>和<code class="eh ms mt mu mv b">app.js</code>，并开辟了另一条关键路径去拿它们。它没有选择我们的<code class="eh ms mt mu mv b">analytics.js</code>，因为我们给了它<code class="eh ms mt mu mv b">async</code>属性。浏览器仍然会用另一个低优先级的线程下载它，但是因为它不会阻止我们页面的渲染，所以它不会影响到关键路径。这正是谷歌自己的优化算法对网站进行排名的方式。</p><h2 id="e164" class="ls kc if bd kd lt lu lv kh lw lx ly kl jn lz ma kp jr mb mc kt jv md me kx mf dt translated">关键文件</h2><p id="5467" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">最后，我们的最后一个CRP指标，关键文件。浏览器为呈现页面而必须下载的文件总数。在我们的案例3中，HTML文件本身、CSS和JavaScript。<code class="eh ms mt mu mv b">async</code>剧本不算。当然，越小越好。</p><h2 id="6801" class="ls kc if bd kd lt lu lv kh lw lx ly kl jn lz ma kp jr mb mc kt jv md me kx mf dt translated">回到关键路径长度</h2><p id="46ab" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">现在你可能会想，这肯定是有史以来最长的关键路径了吧？我的意思是，我们只需要下载HTML、CSS和JavaScript来呈现我们的页面，我们已经在两次往返中完成了。</p><h2 id="d958" class="ls kc if bd kd lt lu lv kh lw lx ly kl jn lz ma kp jr mb mc kt jv md me kx mf dt translated">HTTP1文件限制</h2><p id="24f9" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">再说一次，生活没那么简单。由于HTTP1协议，我们的浏览器一次只能从一个域同时下载设定的最大数量的文件。它的范围从非常老的浏览器的2到Edge的10，Chrome处理6。</p><p id="0061" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以在此查看您的用户浏览器可以从您的域<a class="ae mg" href="http://sgdev-blog.blogspot.co.uk/2014/01/maximum-concurrent-connection-to-same.html" rel="noopener ugc nofollow" target="_blank">请求的最大并发文件数。</a></p><p id="93f5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可以也应该通过提供一些影子域之外的资源来最大化你的优化潜力。</p><p id="f03c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">警告</strong>:不要从你的根域之外的任何地方提供关键的CSS，DNS查找和延迟本身会抵消任何可能情况下的任何好处。</p><h2 id="8bed" class="ls kc if bd kd lt lu lv kh lw lx ly kl jn lz ma kp jr mb mc kt jv md me kx mf dt translated">HTTP2</h2><p id="5298" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">如果你的网站是HTTP2并且你的用户的浏览器是兼容的，那么你可以完全取消这个限制。但是这些美好的事情还不太常见。</p><p id="7362" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可以在这里测试你网站的HTTP2'ness。</p><h2 id="266b" class="ls kc if bd kd lt lu lv kh lw lx ly kl jn lz ma kp jr mb mc kt jv md me kx mf dt translated">TCP往返行程限制</h2><p id="0d15" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">另一个敌人靠近了！</p><p id="4120" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在任何一次往返中可以传输的最大数据量是14kb(它可以变化到16kb)，这适用于所有web请求，包括HTML、CSS和脚本。这来自一个防止网络拥塞和数据包丢失的<a class="ae mg" href="https://hpbn.co/building-blocks-of-tcp/#slow-start" rel="noopener ugc nofollow" target="_blank"> TCP规范</a>。</p><p id="f2c6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们的HTML或请求中的任何资源累积大于14kb，那么我们需要进行额外的往返来获取它们。所以，是的，这些巨大的资源确实为我们的CRP增加了许多途径。</p><h2 id="d6ab" class="ls kc if bd kd lt lu lv kh lw lx ly kl jn lz ma kp jr mb mc kt jv md me kx mf dt translated">大卡哈纳</h2><p id="20a3" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">现在让我们全力以赴制作我们庞大的网页。</p><figure class="mh mi mj mk fq hw"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="cca6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我知道一个按钮需要很多CSS和JavaScript，但它是一个非常重要的按钮，对我们来说意义重大。所以我们不要妄加评论，好吗？</p><p id="f009" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的整个HTML被很好地缩小和压缩，大小为2kb，远低于14kb的限制，所以它在CRP的一次往返中返回给我们，浏览器尽职尽责地开始用1个关键文件，即我们的HTML，构建我们的DOM。</p><figure class="mh mi mj mk fq hw fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/07cef67317766e310069b0567dbbab88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0q_zJ7oHmBNXZ0fNT7tGGQ.png"/></div></figure><p id="cd03" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ms mt mu mv b">CRP Metrics: Length 1, Files 1, Bytes 2kb</code></p><p id="6048" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它获取一个CSS文件，并通过预加载扫描器识别所有外部资源(CSS和JavaScript ),并请求开始下载它们。但是等一下，第一个CSS文件是14kb，最大化了一次往返的有效载荷，所以它本身就是一个CRP。</p><figure class="mh mi mj mk fq hw fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/10a6139c854a67442fc2a1744783bded.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jsZI7bWq9GTL2Uk0uDdvBA.png"/></div></figure><p id="9986" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ms mt mu mv b">CRP Metrics: Length 2, Files 2, Bytes 16kb</code></p><p id="e9b1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后它继续下载资源。其余的重量在14kb以下，所以可以在一次往返中完成，但有7个，因为我们的网站还没有在HTTP2上，我们使用的是Chrome，所以在这次往返中我们只能下载6个文件。</p><figure class="mh mi mj mk fq hw fe ff paragraph-image"><div class="fe ff my"><img src="../Images/cbb005d867ac8716f428932b7a95ec0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*dSFGbrVG1GKRNzpoxVvGIg.png"/></div></figure><p id="7e9b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ms mt mu mv b">CRP Metrics: Length 3, Files 8, Bytes 28kb</code></p><p id="b3d0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们终于可以下载最终文件并呈现DOM了。</p><figure class="mh mi mj mk fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mz"><img src="../Images/39cc1b21c27e06833172f30a08c0062a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MIxhs8CxxMBmRmy7OtQliw.png"/></div></div></figure><p id="f598" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ms mt mu mv b">CRP Metrics: Length 4, Files 9, Bytes 30kb</code></p><p id="69a8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使我们的CRP达到9个关键文件和4个关键路径中总共30kb的关键资源。有了这些信息和一些关于连接延迟的知识，您实际上可以开始对给定用户的页面性能做出真正准确的估计。</p><h2 id="3888" class="ls kc if bd kd lt lu lv kh lw lx ly kl jn lz ma kp jr mb mc kt jv md me kx mf dt translated">浏览器网络优化策略</h2><ul class=""><li id="1020" class="le lf if je b jf kz jj la jn lg jr lh jv li jz lj lk ll lm dt translated">Pagespeed洞察</li></ul><p id="b4b8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用<a class="ae mg" href="https://developers.google.com/speed/pagespeed/insights/" rel="noopener ugc nofollow" target="_blank">洞察力</a>识别绩效问题。Chrome DevTools中还有一个<code class="eh ms mt mu mv b">audit</code>标签。</p><ul class=""><li id="ea0b" class="le lf if je b jf jg jj jk jn mn jr mo jv mp jz lj lk ll lm dt translated">精通Chrome开发者工具</li></ul><p id="52b2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">开发工具太神奇了。我可以单独写一整本书，但是已经有很多资源可以帮助你了。<a class="ae mg" href="https://developers.google.com/web/tools/chrome-devtools/network-performance/understanding-resource-timing" rel="noopener ugc nofollow" target="_blank">这里有一篇真正有用的文章，可以用来开始解读网络资源。</a></p><ul class=""><li id="f26a" class="le lf if je b jf jg jj jk jn mn jr mo jv mp jz lj lk ll lm dt translated">在良好的环境中构建，在恶劣的环境中测试</li></ul><p id="0437" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当然，你希望在Macbook Pro上安装1tb SSD和32gb RAM，但对于性能测试，你应该前往Chrome中的<code class="eh ms mt mu mv b">network</code>选项卡，如果你使用的是Chrome，并模拟低带宽、节流CPU连接，以真正获得一些有用的信息。</p><ul class=""><li id="ed67" class="le lf if je b jf jg jj jk jn mn jr mo jv mp jz lj lk ll lm dt translated">将资源/文件连接在一起</li></ul><p id="7162" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以在上面的CRP图表中，我省略了一些你当时不需要知道的东西。但基本上，在收到每个外部CSS和JavaScript文件后，浏览器会构建CSSOM并在其上执行脚本。因此，即使您可能在一次往返行程中提交几个文件，它们每个都会使浏览器浪费宝贵的时间和资源，所以最好在可行的情况下将文件组合在一起，并消除不必要的负载。</p><ul class=""><li id="d2a6" class="le lf if je b jf jg jj jk jn mn jr mo jv mp jz lj lk ll lm dt translated">页眉中折叠内容上方的内部样式</li></ul><p id="d77f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于是否内化或内联CSS和JavaScript以停止获取外部资源，并没有真正的黑白之分，相反，将资源外化以便可以缓存它们以保持DOM轻量级。</p><p id="5ba7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是有一个很好的理由来支持在折叠内容之上使用内部样式，这意味着你可以避免获取资源来进行第一次有意义的绘制。</p><ul class=""><li id="7abc" class="le lf if je b jf jg jj jk jn mn jr mo jv mp jz lj lk ll lm dt translated">缩小/缩小图像</li></ul><p id="bbf7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">非常简单的概念，有多种实现方式，选择你最喜欢的。</p><ul class=""><li id="0400" class="le lf if je b jf jg jj jk jn mn jr mo jv mp jz lj lk ll lm dt translated">将图像加载延迟到页面加载之后</li></ul><p id="b9ac" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用一些简单的普通JavaScript，您可以推迟加载出现在文件夹下的图像或者对于第一个用户响应状态不重要的图像。这里有一个非常好的策略来做这件事<a class="ae mg" href="https://varvy.com/pagespeed/defer-images.html" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="7a31" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你应该知道的关于图像优化策略的一切都可以在Addy Osmani 的这本优秀的免费<a class="ae mg" href="https://images.guide/" rel="noopener ugc nofollow" target="_blank">电子书中找到。</a></p><ul class=""><li id="b9c9" class="le lf if je b jf jg jj jk jn mn jr mo jv mp jz lj lk ll lm dt translated">异步加载字体</li></ul><p id="03eb" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">加载字体是非常昂贵的，如果可以的话，你应该使用带有后备的网络字体，然后逐步渲染你的字体和图标。这可能看起来不太好，但是另一个选择是，如果字体没有加载，你的页面加载时没有任何文本，这被称为不可见文本的闪现。</p><p id="3dbd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有一个极好的来自易贝的<a class="ae mg" href="http://www.ebaytechblog.com/2017/09/21/ebays-font-loading-strategy/" rel="noopener ugc nofollow" target="_blank">开发者博客，关于一个好的定制字体交付策略。</a></p><ul class=""><li id="e0ee" class="le lf if je b jf jg jj jk jn mn jr mo jv mp jz lj lk ll lm dt translated">你真的需要那些JavaScript/CSS吗？</li></ul><p id="f994" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你知道吗？回答我！有没有一个本地的HTML元素可以产生你使用脚本的行为？有没有可以内联而不是内部/外部创建的样式或图标？例如<a class="ae mg" href="https://css-tricks.com/using-svg/#article-header-id-7" rel="noopener ugc nofollow" target="_blank">内联一个SVG </a>。</p><ul class=""><li id="29e8" class="le lf if je b jf jg jj jk jn mn jr mo jv mp jz lj lk ll lm dt translated">CDNs</li></ul><p id="a781" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">内容交付网络(cdn)可用于从物理距离更近、延迟更低的位置向用户提供资产服务，从而降低加载时间。</p><ul class=""><li id="4183" class="le lf if je b jf jg jj jk jn mn jr mo jv mp jz lj lk ll lm dt translated">服务器端优化</li></ul><p id="a44b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于您的服务器必须获取并使用您的代码响应的每个请求，这会导致网络请求的延迟和等待时间。这里有很多不同的优化方法，这可能是一整本书的价值，所以我不能详细说明太多。但是，您可能希望了解静态html的服务器端缓存、代码缓存和内存化等内容。</p></div><div class="ab cl na nb hc nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="hn ho hp hq hr"><p id="6b69" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在你高兴极了，知道了足够多的东西，可以去那里自己发现更多关于这个主题的东西。我会推荐做这个<a class="ae mg" href="https://classroom.udacity.com/courses/ud884/lessons/1464158641/concepts/14734291220923" rel="noopener ugc nofollow" target="_blank">免费的Udacity课程</a>并阅读谷歌自己的关于优化的<a class="ae mg" href="https://developers.google.com/web/fundamentals/performance/" rel="noopener ugc nofollow" target="_blank">文档。</a></p><p id="a10a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你渴望更低级的知识，那么伊利亚·格里戈利克关于<a class="ae mg" href="https://hpbn.co/" rel="noopener ugc nofollow" target="_blank">高性能浏览器网络</a>的免费电子书是一个很好的起点。</p><h1 id="dc10" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">包扎</h1><p id="589f" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">关键的渲染路径是非常重要的，它给了我们一些非常可靠和合理的规则来优化我们的网站。重要的3个指标是:</p><p id="9aa3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">1 —关键字节数。</p><p id="5b47" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">2 —关键文件的数量。</p><p id="a2a0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">3 —关键路径的数量。</p><p id="8ad4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我在这里写的东西应该足以让你掌握基本原理，并帮助你解释谷歌对你的表现的看法。</p><p id="c3c3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最佳实践的应用将与良好的DOM结构、网络优化和我们可用于最小化CRP指标的各种策略相结合。让用户更开心，让谷歌的搜索引擎更开心。</p><p id="70bf" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在任何企业规模的网站，这将是一个巨大的任务，但你迟早要做，所以停止招致更多的技术债务，开始投资于坚实的性能优化策略。</p><p id="8c3f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">非常感谢您的阅读。现在你已经有了一个坚实的概述，你可以走出去，成为像我一样痴迷于性能优化，祝你好运，玩得开心！</p><div class="mh mi mj mk fq ab cb"><figure class="nh hw ni nj nk nl nm paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nh hw ni nj nk nl nm paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nh hw ni nj nk nl nm paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="nn no np"><p id="f922" class="jc jd ka je b jf jg jh ji jj jk jl jm nq jo jp jq nr js jt ju ns jw jx jy jz hn dt translated"><a class="ae mg" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae mg" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae mg" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae mg" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd ka je b jf jg jh ji jj jk jl jm nq jo jp jq nr js jt ju ns jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae mg" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae mg" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="mh mi mj mk fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nt"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="mh mi mj mk fq hw"><div class="bz el l di"><div class="nu mm l"/></div></figure></div></div>    
</body>
</html>