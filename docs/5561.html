<html>
<head>
<title>Partial Application for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初学者的部分应用</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/partial-application-for-beginners-1cd355f8f5bc?source=collection_archive---------12-----------------------#2017-08-02">https://medium.com/hackernoon/partial-application-for-beginners-1cd355f8f5bc?source=collection_archive---------12-----------------------#2017-08-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/341b0df57e52d6f70efb1d2a83036dae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Y7oRApa-UpuhbjuZpoN_iQ.jpeg"/></div></figure><p id="b78a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><em class="jw">注:此为本人</em> <a class="ae jx" href="https://btnwtn.com/articles/partial-application-for-beginners" rel="noopener ugc nofollow" target="_blank"> <em class="jw">个人网站</em> </a> <em class="jw">原帖。</em></p><h1 id="f7bd" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">为什么使用部分应用程序？</h1><p id="3a25" class="pw-post-body-paragraph iy iz hu ja b jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv hn dt translated"><a class="ae jx" href="https://hackernoon.com/tagged/partial-application" rel="noopener ugc nofollow" target="_blank">局部应用</a>是写干巴巴(不要重复自己)又有表现力的代码的一个核心概念。您可以使用部分应用程序来编写和创建新的函数，并编写如下代码:</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="fd1a" class="lk jz hu lg b fv ll lm l ln lo">function sortFilesByName() {<br/>  /* … */<br/>}</span><span id="e47e" class="lk jz hu lg b fv lp lm l ln lo">function sortFilesByType() {<br/>  /* … */<br/>}</span><span id="6835" class="lk jz hu lg b fv lp lm l ln lo">function sortFilesByFilesize() {<br/>  /* … */<br/>}</span><span id="f933" class="lk jz hu lg b fv lp lm l ln lo">function sortFilesByDate() {<br/>  /* … */<br/>}</span><span id="02ff" class="lk jz hu lg b fv lp lm l ln lo">&lt;button onClick={() =&gt; sortFilesByName()}&gt;Name&lt;/button&gt;<br/>&lt;button onClick={() =&gt; sortFilesByType()}&gt;Type&lt;/button&gt;<br/>&lt;button onClick={() =&gt; sortFilesByFilesize()}&gt;Filesize&lt;/button&gt;<br/>&lt;button onClick={() =&gt; sortFilesByDate()}&gt;Date&lt;/button&gt;</span></pre><p id="23d6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">变成这样:</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="780b" class="lk jz hu lg b fv ll lm l ln lo">function sortFilesBy(prop) {<br/>  /* … */<br/>}</span><span id="4d05" class="lk jz hu lg b fv lp lm l ln lo">&lt;button onClick={sortFilesBy('name')}&gt;Name&lt;/button&gt;<br/>&lt;button onClick={sortFilesBy('type')}&gt;Type&lt;/button&gt;<br/>&lt;button onClick={sortFilesBy('filesize')}&gt;Filesize&lt;/button&gt;<br/>&lt;button onClick={sortFilesBy('date')}&gt;Date&lt;/button&gt;</span></pre><h1 id="b53f" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">了解局部应用</h1><p id="8179" class="pw-post-body-paragraph iy iz hu ja b jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv hn dt translated">部分应用是一个计算机科学术语，描述将一些参数固定到一个函数，然后返回一个较小arity的函数的过程。那么这到底意味着什么呢？</p><h1 id="8576" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">公式</h1><p id="443e" class="pw-post-body-paragraph iy iz hu ja b jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv hn dt translated">在Javascript中，我们可以用几种方式定义函数。我们可以声明它们:</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="1804" class="lk jz hu lg b fv ll lm l ln lo">function add(x, y) {<br/>  return x + y<br/>}</span><span id="13f0" class="lk jz hu lg b fv lp lm l ln lo">console.log(add)<br/>//=&gt; ƒ add(x, y) { return x + y }</span></pre><p id="90e4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们可以通过将它们定义为表达式(函数表达式)来使用它们作为值:</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="c760" class="lk jz hu lg b fv ll lm l ln lo">const add = function (x, y) {<br/>  return x + y<br/>}</span><span id="a207" class="lk jz hu lg b fv lp lm l ln lo">console.log(add)<br/>//=&gt; ƒ (x, y) { return x + y }</span></pre><p id="4277" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">函数表达式使我们能够像传递其他值一样传递函数。这意味着您可以将一个函数作为参数传递给另一个函数(例如<code class="eh lq lr ls lg b">map(function () {})</code>)，并从一个函数返回一个函数:</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="6484" class="lk jz hu lg b fv ll lm l ln lo">const fn = function () {<br/>  return function (x) {<br/>    return x<br/>  }<br/>}</span><span id="dcd3" class="lk jz hu lg b fv lp lm l ln lo">fn()<br/>//=&gt; ƒ (x) { return x }</span><span id="d31f" class="lk jz hu lg b fv lp lm l ln lo">fn()(1)<br/>//=&gt; 1</span></pre><p id="4239" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这是Javascript的一个核心特性，它使我们能够编写出非常干净灵活的代码。</p><h1 id="bac0" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">Arity</h1><p id="e030" class="pw-post-body-paragraph iy iz hu ja b jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv hn dt translated">Arity是一个描述函数接受的参数数量的术语。接受零参数的函数是零实参的函数。接受一个参数的函数是一个arity的函数，两个参数的arity是二，以此类推。</p><p id="8fe5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们可以通过使用<code class="eh lq lr ls lg b"><a class="ae jx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/length" rel="noopener ugc nofollow" target="_blank">Function.length</a></code>来确定函数的arity。</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="af97" class="lk jz hu lg b fv ll lm l ln lo">add.length<br/>//=&gt; 2</span><span id="e95d" class="lk jz hu lg b fv lp lm l ln lo">(function (x, y) { return x + y }).length<br/>//=&gt; 2</span><span id="dab7" class="lk jz hu lg b fv lp lm l ln lo">(function (x) { return x }).length<br/>//=&gt; 1</span><span id="28e1" class="lk jz hu lg b fv lp lm l ln lo">(function () {}).length<br/>//=&gt; 0</span></pre><h1 id="dcc7" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">关闭</h1><p id="e938" class="pw-post-body-paragraph iy iz hu ja b jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv hn dt translated">我们知道可以用函数表达式从函数中返回一个函数。我们可以利用这种行为，从返回它们的函数中返回“记住”值的函数。听起来令人困惑，但实际上有点简单:</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="7422" class="lk jz hu lg b fv ll lm l ln lo">const add = function add() {<br/>  const x = 1</span><span id="a3bb" class="lk jz hu lg b fv lp lm l ln lo">  return function innerFunction() {<br/>    return x<br/>  }<br/>}</span><span id="2749" class="lk jz hu lg b fv lp lm l ln lo">add()<br/>//=&gt; ƒ innerFunction() { return x }</span><span id="8c08" class="lk jz hu lg b fv lp lm l ln lo">add()()<br/>//=&gt; 1</span></pre><p id="3761" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">内部函数(<code class="eh lq lr ls lg b">innerFunction</code>)从外部函数传递<code class="eh lq lr ls lg b">x</code>，并记住该值。这个内部函数被称为闭包，因为它从外部<code class="eh lq lr ls lg b">add</code>函数的环境中访问数据。我们可以重写<code class="eh lq lr ls lg b">add</code>来返回一个接受另一个变量的闭包:</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="7d42" class="lk jz hu lg b fv ll lm l ln lo">const add = function add() {<br/>  const x = 1</span><span id="954c" class="lk jz hu lg b fv lp lm l ln lo">  return function innerFunction(y) {<br/>    return x + y<br/>  }<br/>}</span><span id="70c3" class="lk jz hu lg b fv lp lm l ln lo">add()<br/>//=&gt; ƒ innerFunction(y) { return x + y }</span><span id="4fbe" class="lk jz hu lg b fv lp lm l ln lo">add()(4)<br/>//=&gt; 5</span><span id="9652" class="lk jz hu lg b fv lp lm l ln lo">add()(1)<br/>//=&gt; 2</span><span id="e0ed" class="lk jz hu lg b fv lp lm l ln lo">add()(0)<br/>//=&gt; 1</span></pre><p id="63a2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果我们把<code class="eh lq lr ls lg b">x</code>作为一个参数，去掉<code class="eh lq lr ls lg b">innerFunction</code>的名字，我们得到:</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="8344" class="lk jz hu lg b fv ll lm l ln lo">const add = function add(x) {<br/>  return function (y) {<br/>    return x + y<br/>  }<br/>}</span><span id="25a3" class="lk jz hu lg b fv lp lm l ln lo">add(1)(1)<br/>//=&gt; 1</span><span id="e90c" class="lk jz hu lg b fv lp lm l ln lo">add(0)(0)<br/>//=&gt; 0</span></pre><h1 id="3e12" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">把它放在一起</h1><blockquote class="lt lu lv"><p id="1a90" class="iy iz jw ja b jb jc jd je jf jg jh ji lw jk jl jm lx jo jp jq ly js jt ju jv hn dt translated"><em class="hu">部分应用是将一些参数固定到一个函数上，然后返回一个更小arity的函数的过程。</em></p></blockquote><p id="0dfd" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">因为上面的<code class="eh lq lr ls lg b">add</code>函数返回一个函数，所以我们可以用一个参数将一个变量赋给调用<code class="eh lq lr ls lg b">add</code>的结果:</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="5dce" class="lk jz hu lg b fv ll lm l ln lo">const add5 = add(5)<br/>//=&gt; ƒ (y) { return x + y }</span><span id="c528" class="lk jz hu lg b fv lp lm l ln lo">add5(10)<br/>//=&gt; 15</span></pre><p id="939b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">函数<code class="eh lq lr ls lg b">add5</code>调用<code class="eh lq lr ls lg b">add</code>，将值<code class="eh lq lr ls lg b">5</code>固定(绑定)到<code class="eh lq lr ls lg b">x</code>。<code class="eh lq lr ls lg b">add </code>返回内部函数，用固定值<code class="eh lq lr ls lg b">ƒ (y) { return 5 + y }</code>替换<code class="eh lq lr ls lg b">x</code>。</p><p id="4655" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">当我们这样做的时候，我们已经用<em class="jw">部分应用了</em>函数<code class="eh lq lr ls lg b">add</code>。它产生了一个函数(<code class="eh lq lr ls lg b">add5</code>)，我们可以用不同的方式使用它。</p><p id="463f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们有了一个接受一个参数的函数，我们可以将这个函数传递给高阶函数(将函数作为参数的函数)，比如<code class="eh lq lr ls lg b">map</code>:</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="5163" class="lk jz hu lg b fv ll lm l ln lo">[1, 2, 3].map(add5)<br/>//=&gt; [6, 7, 8]</span><span id="8fc1" class="lk jz hu lg b fv lp lm l ln lo">// same as:<br/>[1, 2, 3].map(function (y) { return 5 + y })</span></pre><p id="e3df" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">虽然<code class="eh lq lr ls lg b">add</code>和<code class="eh lq lr ls lg b">add5</code>示例很好地解释了部分应用的“内容”和“方式”,但它们未能说明“为什么”。让我们继续看一些真实世界的例子。</p><h1 id="eb5e" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">真实世界的例子</h1><p id="84d0" class="pw-post-body-paragraph iy iz hu ja b jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv hn dt translated">让我们来看看本文开头的例子:</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="92b7" class="lk jz hu lg b fv ll lm l ln lo">function sortFilesByName() {<br/>  /* … */<br/>}</span><span id="2d69" class="lk jz hu lg b fv lp lm l ln lo">function sortFilesByType() {<br/>  /* … */<br/>}</span><span id="bcc1" class="lk jz hu lg b fv lp lm l ln lo">function sortFilesByFilesize() {<br/>  /* … */<br/>}</span><span id="a227" class="lk jz hu lg b fv lp lm l ln lo">function sortFilesByDate() {<br/>  /* … */<br/>}</span><span id="dae5" class="lk jz hu lg b fv lp lm l ln lo">&lt;button onClick={() =&gt; sortFilesByName()}&gt;Name&lt;/button&gt;<br/>&lt;button onClick={() =&gt; sortFilesByType()}&gt;Type&lt;/button&gt;<br/>&lt;button onClick={() =&gt; sortFilesByFilesize()}&gt;Filesize&lt;/button&gt;<br/>&lt;button onClick={() =&gt; sortFilesByDate()}&gt;Date&lt;/button&gt;</span></pre><p id="cdd2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">假设我们有一个请求，要求通过一个新字段添加排序:“Last Modified”。我们可以将此作为重构和简化代码的机会，而不是添加一个新函数<code class="eh lq lr ls lg b">sortFilesByLastModified</code>。</p><p id="ba6c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">首先，让我们将这些函数分组到一个普通对象中，该对象的键将表示我们要排序的属性，值将是接受要过滤的文件列表的函数:</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="dd3f" class="lk jz hu lg b fv ll lm l ln lo">const SortBy = {<br/>  name: function (files) {<br/>    // sort files<br/>    return sortedFiles<br/>  },</span><span id="4ba9" class="lk jz hu lg b fv lp lm l ln lo">  size: function (files) {<br/>    // sort files<br/>    return sortedFiles<br/>  },</span><span id="7982" class="lk jz hu lg b fv lp lm l ln lo">  /* etc. */<br/>}</span></pre><p id="6b94" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我知道我想创建一个单一的通用函数，而不是许多<code class="eh lq lr ls lg b">onClick</code>处理程序。这个函数应该接受一个属性来过滤并返回一个<a class="ae jx" href="https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Event_handlers" rel="noopener ugc nofollow" target="_blank">事件处理程序</a>:</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="cb91" class="lk jz hu lg b fv ll lm l ln lo">function sortFilesBy(property) {<br/>  return function (event) {<br/>    // ???<br/>  }<br/>}</span></pre><p id="7ac1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们可以像这样使用这个函数:</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="3387" class="lk jz hu lg b fv ll lm l ln lo">&lt;button onClick={sortFilesBy('name')}&gt;Name&lt;/button&gt;<br/>&lt;button onClick={sortFilesBy('type')}&gt;Type&lt;/button&gt;<br/>&lt;button onClick={sortFilesBy('filesize')}&gt;Filesize&lt;/button&gt;<br/>&lt;button onClick={sortFilesBy('date')}&gt;Date&lt;/button&gt;</span></pre><p id="61f1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">当使用这个函数时，我们将<code class="eh lq lr ls lg b">property</code>绑定为作为参数传入的任何内容，并返回一个<code class="eh lq lr ls lg b">onClick</code>可以触发的事件处理程序。现在我们需要对文件进行分类:</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="5c07" class="lk jz hu lg b fv ll lm l ln lo">function sortFilesBy(property) {<br/>  return function (event) {<br/>    const sort = SortBy[property]<br/>    //=&gt; ƒ (files) { return sortedFiles }</span><span id="45f8" class="lk jz hu lg b fv lp lm l ln lo">    this.setState(function (state) {<br/>      return {<br/>        files: sort(state.files)<br/>      }<br/>    })<br/>  }<br/>}</span></pre><p id="a6e8" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">因为<code class="eh lq lr ls lg b">property</code>被固定为我们提供给<code class="eh lq lr ls lg b">sortFilesBy </code>函数的任何值，我们可以用它从<code class="eh lq lr ls lg b">SortBy</code>对象中查找我们的排序函数。这个例子部分应用了<code class="eh lq lr ls lg b">sortFilesBy</code>函数来产生一个事件处理程序，它根据传递给<code class="eh lq lr ls lg b">property</code>的内容对文件进行排序。</p><p id="516c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这里的好处是，我们可以向<code class="eh lq lr ls lg b">SortBy</code>对象添加和移除函数，而不是向我们的React组件(或其他组件)添加新函数。这减少了组件的代码行数。更好的是，它将过滤和管理状态的逻辑从组件中分离出来。<code class="eh lq lr ls lg b">SortBy</code>现在可以在整个代码库中重用，而以前它是紧密集成到特定组件中的。</p><h1 id="e95c" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">结论</h1><p id="f9c9" class="pw-post-body-paragraph iy iz hu ja b jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv hn dt translated">这只是部分应用函数的众多好处之一。部分应用使编写<a class="ae jx" href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-compose-and-pipeline" rel="noopener ugc nofollow" target="_blank">可组合函数</a>变得容易，代码简洁，并且有其他用途。我鼓励你在自己的项目中找到可以受益于这种技术的代码！</p><figure class="lb lc ld le fq iv"><div class="bz el l di"><div class="lz ma l"/></div></figure></div></div>    
</body>
</html>