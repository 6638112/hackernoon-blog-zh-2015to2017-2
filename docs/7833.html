<html>
<head>
<title>Exploring Property-Based Testing with ScalaCheck (simple examples)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用ScalaCheck探索基于属性的测试(简单示例)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/exploring-property-based-testing-with-scalacheck-simple-examples-bcdc34600810?source=collection_archive---------17-----------------------#2017-11-09">https://medium.com/hackernoon/exploring-property-based-testing-with-scalacheck-simple-examples-bcdc34600810?source=collection_archive---------17-----------------------#2017-11-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/d03c01214cacb83270e014f23a625e12.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*2CzoQ5sfOKSsp9pWq5KexA.png"/></div></figure><blockquote class="iy iz ja"><p id="afa9" class="jb jc jd je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是更多的例子而不是谈话。</p></blockquote><p id="279f" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">将ScalaCheck添加到您的<em class="jd"> build.sbt </em>文件中</p><figure class="kd ke kf kg fq iv"><div class="bz el l di"><div class="kh ki l"/></div></figure><p id="6b4e" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">第一个问题，FizzBuzz</p><p id="c7a8" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">让我们看一些测试FizzBuzz问题。</p><figure class="kd ke kf kg fq iv"><div class="bz el l di"><div class="kh ki l"/></div></figure><p id="061b" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">每个测试都试图证明FizzBuzz的某些属性，例如，属性“only div by 3”试图证明Fizz仅在传递的值被3整除而不是被5整除时返回。看看值生成器(<em class="jd"> divBy3 </em>)会让我们意识到我们正在过滤掉那些能被5整除的值。</p><p id="18af" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">按照同样的思路，我们可以证明其他属性，例如只有那些能被5整除而不能被3整除的属性才应该被翻译成“Buzz”，或者如果值不能被3整除和5整除，则应该使用id函数和toString来翻译，这样它们就变成了字符串格式。</p><p id="6e71" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">这里的神奇之处在于，基于我们的生成器属性，每个测试将使用随机值空间(不稳定)运行至少100次。在我看来，这比使用问题域的有限值，比如5，10，15，2，24，2，来测试更强。</p><p id="28e3" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">另一方面，这种测试技术不应该取代TDD，而应该将其扩展为更完整的测试套件。</p><p id="79d9" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">我们对FizzBuzz的实现如下所示。</p><figure class="kd ke kf kg fq iv"><div class="bz el l di"><div class="kh ki l"/></div></figure><h1 id="7fa9" class="kj kk hu bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">第二个问题，堆栈</h1><p id="35eb" class="pw-post-body-paragraph jb jc hu je b jf lh jh ji jj li jl jm ka lj jp jq kb lk jt ju kc ll jx jy jz hn dt translated">现在，让我们看看如何使用相同的技术来测试一个定制的、功能性的堆栈实现。</p><h2 id="44f0" class="lm kk hu bd kl ln lo lp kp lq lr ls kt ka lt lu kx kb lv lw lb kc lx ly lf lz dt translated">大小</h2><p id="cfd7" class="pw-post-body-paragraph jb jc hu je b jf lh jh ji jj li jl jm ka lj jp jq kb lk jt ju kc ll jx jy jz hn dt translated">让我们从测试开始，因为它们是我们在这篇文章中关注的领域。</p><figure class="kd ke kf kg fq iv"><div class="bz el l di"><div class="kh ki l"/></div></figure><p id="d9e0" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">首先，我们定义一个值生成器，专门用于正int值。</p><p id="1adb" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">然后我们定义我们的第一个测试，即<em class="jd">将多个值(按顺序)压入堆栈，并验证堆栈的大小与压入的值的数量相对应。</em></p><p id="8a91" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">记住，相同的测试将运行100次，并推送不同数量的值。第一次运行时，可能会推送2个值并验证大小为2，然后可能会再次运行，推送97个值并再次验证堆栈的大小为97。</p><h2 id="6f04" class="lm kk hu bd kl ln lo lp kp lq lr ls kt ka lt lu kx kb lv lw lb kc lx ly lf lz dt translated">挑选</h2><p id="c1af" class="pw-post-body-paragraph jb jc hu je b jf lh jh ji jj li jl jm ka lj jp jq kb lk jt ju kc ll jx jy jz hn dt translated">我们的第二个测试验证了从堆栈中选择不会修改它。</p><figure class="kd ke kf kg fq iv"><div class="bz el l di"><div class="kh ki l"/></div></figure><p id="ccf7" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">使用相同的原理，测试运行很多次，每次将不同数量的项目推入堆栈，然后调用<code class="eh ma mb mc md b">.head</code> ( <em class="jd"> pick </em>)，然后验证大小是否等于被推入的值的数量，这意味着<code class="eh ma mb mc md b">.head</code>不修改堆栈。</p><h2 id="2b95" class="lm kk hu bd kl ln lo lp kp lq lr ls kt ka lt lu kx kb lv lw lb kc lx ly lf lz dt translated">toList</h2><p id="849b" class="pw-post-body-paragraph jb jc hu je b jf lh jh ji jj li jl jm ka lj jp jq kb lk jt ju kc ll jx jy jz hn dt translated">现在，我们可以测试获得堆栈的列表表示(不修改堆栈)。</p><figure class="kd ke kf kg fq iv"><div class="bz el l di"><div class="kh ki l"/></div></figure><p id="eee4" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">再一次，使用相同的原理，每次测试运行时，它检查<code class="eh ma mb mc md b">.toList</code>是否返回我们以相反顺序推送的相同值。</p><h2 id="f57a" class="lm kk hu bd kl ln lo lp kp lq lr ls kt ka lt lu kx kb lv lw lb kc lx ly lf lz dt translated">推拉式</h2><figure class="kd ke kf kg fq iv"><div class="bz el l di"><div class="kh ki l"/></div></figure><p id="edaf" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">我们的“推拉”测试验证了我们放入堆栈的任何东西都可以以正确的顺序取出。同样，这个测试将使用不同的堆栈大小运行100次。</p><h2 id="a73a" class="lm kk hu bd kl ln lo lp kp lq lr ls kt ka lt lu kx kb lv lw lb kc lx ly lf lz dt translated">堆</h2><p id="a5c2" class="pw-post-body-paragraph jb jc hu je b jf lh jh ji jj li jl jm ka lj jp jq kb lk jt ju kc ll jx jy jz hn dt translated">我们的栈是一个不可变的数据结构。对堆栈的操作不会修改它，而是创建新的堆栈。</p><figure class="kd ke kf kg fq iv"><div class="bz el l di"><div class="kh ki l"/></div></figure><h1 id="deb7" class="kj kk hu bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">结论</h1><p id="5c3a" class="pw-post-body-paragraph jb jc hu je b jf lh jh ji jj li jl jm ka lj jp jq kb lk jt ju kc ll jx jy jz hn dt translated">基于属性的测试是一个强大的工具。我发现它在编写复杂的数据结构时非常有用，比如我们已经添加到<a class="ae me" href="https://github.com/stew/dogs" rel="noopener ugc nofollow" target="_blank"><strong class="je hv"><em class="jd"/></strong></a>中的数据结构。然而，它不应该取代其他技术，如TDD(测试驱动开发),而是对它们的补充。</p></div></div>    
</body>
</html>