<html>
<head>
<title>NodeNinja Fundamentals 1.0 — The Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">忍者基础1.0-基础</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/nodeninja-fundamentals-1-0-the-basics-6204edc475db?source=collection_archive---------15-----------------------#2017-06-30">https://medium.com/hackernoon/nodeninja-fundamentals-1-0-the-basics-6204edc475db?source=collection_archive---------15-----------------------#2017-06-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/dc3a209acbfc25f1b6efa5b3bc831ae0.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/format:webp/1*Hs60Y-qlWZLtk9L9NYMbow.jpeg"/></div></figure><p id="c97b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">全世界都迷恋NodeJs。当我们谈论节点时，我们会听到很多术语，如异步、回调和承诺。从C++的世界来看，流程是线性的，函数调用和返回方式非常简单，这似乎有点奇怪。你会听到很多变形的词，比如回调和承诺。</p><p id="6cf6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所以让我们一次一个地从这些术语开始。</p><p id="5d64" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">异步和同步:</p><p id="b149" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们将通过两个场景来更好地理解这个概念。</p><p id="1acc" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">场景1。</p><p id="0e37" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">假设你去酒吧。现在是星期五晚上。你去吧台的服务生那里，要一杯饮料，让我们。叫服务员克雷。但事实证明，Clay是一个非常忙碌的人，高中毕业后，他在这方面有点迟钝。所以你看到他慢慢地给你斟酒。你真的在打哈欠。与此同时，一位美丽的女士从你身边走过，坐在酒吧的另一端。你现在很困惑。她似乎是个完美的约会对象。你想和她谈谈。但是这个服务员太慢了。所以你所做的。</p><p id="4026" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">你很聪明。你告诉侍者当你的饮料准备好的时候叫你，然后你直奔那位女士。你在和这位女士聊天，讨论生活。你听到了克莱的呼唤。所以，你回到克莱身边，感谢他并重新加入你美丽的公司，为快乐的时刻干杯..</p><p id="ac2b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">场景2。：</p><p id="ac0c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">假设，粘土慢。他也有点粗鲁。当你恳求他斟满你的酒杯时，他指示你留下。否则别人会吞了你的60块。你没有选择。你看到蟒蛇先生走过去坐在那位女士旁边。你完蛋了。你的时间是世界上最重要的东西。你猜怎么着，克莱阻止了你，毁了你的周五。</p><figure class="jx jy jz ka fq iv fe ff paragraph-image"><div class="fe ff jw"><img src="../Images/2db9395ce5ac03b44d68597ee5ac58e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*qVcFMbBiFgkQyz-O4urhPA.jpeg"/></div></figure><p id="feec" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，客观地看，假设Clay是一个昂贵的DB调用、一个io操作或一个文件读取。你永远不知道它们完成的确切时间。这些事情需要不同的时间。你就是执行这些指令的进程。这位女士是服务器上的另一个请求。</p><p id="70fc" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在场景1中，你所做的是不浪费时间。同时，您在等待耗时的调用完成，您为它的执行添加了一个提醒，并继续处理第二个请求。在这种情况下，您从DB获得一个操作已经完成的响应，因此您将第二个请求放入堆栈，并执行挂起的第一个请求。(事件机制)</p><p id="1675" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这就是异步性。这就是node看起来很快的原因。只有一个执行线程。<strong class="ja hv">其实Javascript并不是异步的，NodeJS只是提供了异步API。它需要这样的操作是非阻塞的。</strong></p><p id="2a1b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">开始同步。</p><p id="b6b1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在场景2中，克莱挡住了你。在第二次请求到来的时候，你什么也做不了。Python先生抢尽了风头。你拿起你的饮料，喝了它，然后回家。所以把Python先生当做另一个线程。</p><p id="7da4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">你正在处理第一个请求，它阻塞了，所以…与此同时，第二个请求来了。那么服务器进程做了什么，它产生了一个新的线程，并开始处理第二个请求。这就是PHP的工作方式。</p><p id="57e9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这是一个概括。一个线程在任何时候都有自己的堆栈，它在自己的地址空间中执行函数。因此Node看起来有点像轻量级冠军，它只有一个执行线程——称为事件循环。它连续运行，执行一个事件循环的时间称为tick。但是Node很好地处理了这种上下文切换，这就是它如此受欢迎的原因。</p><p id="a243" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们考虑一下这在NodeJS中的含义。</p><p id="5060" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所以NodeJs有两套东西。阻塞和非阻塞。(同步和a-Sync)。你有文件读取函数，比如fileReadSync和fileRead。考虑一个服务器进程，其中有10个API，其中一个用来读取一个文件的内容。</p><p id="0c72" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Alice和Bob是新手，正在申请API。</p><p id="08c7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">使用fileRead —异步方法</p><p id="8f56" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">案例一。</p><p id="c4f9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Alice和Bob向服务器请求GET/my _ favorite _ seasons。作为节点进程的服务器开始执行调用，</p><p id="96b9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">a的请求首先到达服务器，事件循环获得调用，开始执行它。它进入文件读取功能。但是文件读取是异步的，所以NodeJs添加了一个注释，在读取完成时附加一种事件作为某种通知，并再次开始监听。b的请求来了，它开始服务它。快进几毫秒，A和B很高兴从服务器上收到他们最喜欢的季节列表。</p><p id="499d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">案例二。</p><p id="2915" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们假设在这个场景中读取的文件是阻塞的。所以节点进程着手执行A的调用。它到达了文件读取函数，但是在这里被阻塞了。现在不是免费的。b的请求来了，但是你猜怎么着，这个呼叫没有人服务。NodeJs是一个人的军队，这个人正忙于将文件的内容转储到内存中。所以B会被卡住——它的请求会被延迟。因为事件循环很忙。或者只是服务器不接受连接。</p><p id="607c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">当您在API中使用太多阻塞调用时，就会发生这种情况。如果您忽略了这些考虑因素，您的服务器可能会崩溃。</p><p id="643b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">尝试在您的进程中添加一个无限循环，看看服务器如何运行。</p><p id="1c91" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">你应该做的是用第一种方式做事。如果文件非常大，您应该在响应中流式传输文件。</p><p id="1d2f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所以说到溪流和缓冲区。</p><p id="14e9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">流和缓冲区:</p><p id="71ab" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们经常听到这些术语。我的youtube视频正在缓冲，来自spotify的流..还有什么不可以。你每天都会听到这些。</p><p id="13f5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">它们到底是什么？</p><p id="9857" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">缓冲区:你正在从磁盘上读取一个文件。通常所做的是将文件的全部内容从磁盘复制到RAM。文件存储在缓冲区中。当涉及到大文件时，使用缓冲区是绝对不行的(原因很明显，:D)。你应该做什么是我们下一个讨论的话题。所以继续吧。</p><p id="d608" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">流:流是流动的数据。是的，就像瀑布一样。数据流。您的流程调用了一个管道工。它修复了一个管道，直接从文件库到您的ram，您的节点进程也位于ram中，当轮到执行时，CPU从ram中获取它。</p><p id="579b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">简单地说，获取解码执行。所以你打开水龙头。一点一滴的数据进入你的水桶。当它填满时，会生成一个数据事件，节点进程会读取数据。文件的全部内容都是分块读取的。在RAM中只分配了桶的大小，一切都按计划进行。这些是溪流。简而言之，这就是流媒体的工作方式。</p><p id="5390" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">对于一些非常好的参考资料，您可以参考:</p><div class="kb kc fm fo kd ke"><a href="https://stackoverflow.com/questions/17607280/why-is-node-js-asynchronous" rel="noopener  ugc nofollow" target="_blank"><div class="kf ab ej"><div class="kg ab kh cl cj ki"><h2 class="bd hv fv z el kj eo ep kk er et ht dt translated">node.js为什么是异步的？</h2><div class="kl l"><h3 class="bd b fv z el kj eo ep kk er et ek translated">实际上没有人问过这个问题(从我得到的所有‘建议’中，也从我在这里提问之前的搜索中)。所以…</h3></div><div class="km l"><p class="bd b gc z el kj eo ep kk er et ek translated">stackoverflow.com</p></div></div><div class="kn l"><div class="ko l kp kq kr kn ks iw ke"/></div></div></a></div><div class="kb kc fm fo kd ke"><a href="https://stackoverflow.com/questions/24222883/is-an-infinite-loop-impossible-in-nodejs" rel="noopener  ugc nofollow" target="_blank"><div class="kf ab ej"><div class="kg ab kh cl cj ki"><h2 class="bd hv fv z el kj eo ep kk er et ht dt translated">nodejs中无限循环是不可能的吗？</h2><div class="kl l"><h3 class="bd b fv z el kj eo ep kk er et ek translated">加入Stack Overflow社区Stack Overflow是一个由730万程序员组成的社区，就像你一样，帮助每一个…</h3></div><div class="km l"><p class="bd b gc z el kj eo ep kk er et ek translated">stackoverflow.com</p></div></div><div class="kn l"><div class="kt l kp kq kr kn ks iw ke"/></div></div></a></div><p id="02ed" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">附加演示:</p><p id="34b2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">使用无限循环的含义</p><p id="3026" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">对于创建服务器和测试，只需使用express:</p><blockquote class="ku"><p id="4c22" class="kv kw hu bd kx ky kz la lb lc ld jv ek translated">npm快速安装-g</p><p id="8b24" class="kv kw hu bd kx ky kz la lb lc ld jv ek translated">npm安装快速发电机g</p></blockquote><pre class="le lf lg lh li lj lk ll lm aw ln dt"><span id="ab93" class="lo lp hu lk b fv lq lr l ls lt">#make sure you have node installed in your system<br/>npm install express -g<br/>npm install express-generator -g<br/>express your-process-name</span></pre><p id="45f3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">然后转到routes/index.js，用下面的文件替换这个文件</p><pre class="jx jy jz ka fq lj lk ll lm aw ln dt"><span id="ca35" class="lo lp hu lk b fv lq lr l ls lt">var express = require('express');<br/>var router = express.Router();</span><span id="eb22" class="lo lp hu lk b fv lu lr l ls lt">/* GET home page. */<br/>router.get('/', function(req, res, next) {<br/>  console.log('hello');</span><span id="0f80" class="lo lp hu lk b fv lu lr l ls lt">while(1){</span><span id="e8ec" class="lo lp hu lk b fv lu lr l ls lt">}<br/>  // we will never reach here<br/>  res.send();<br/>});</span><span id="3b55" class="lo lp hu lk b fv lu lr l ls lt">router.get('/async', function(req, res, next) {<br/>  setTimeout(function(){<br/>   console.log('it should get printed after 10 seconds');<br/>   res.send();<br/>  },10000);<br/>  <br/>});</span><span id="7e3d" class="lo lp hu lk b fv lu lr l ls lt">module.exports = router;</span></pre><blockquote class="lv lw lx"><p id="b768" class="iy iz ly ja b jb jc jd je jf jg jh ji lz jk jl jm ma jo jp jq mb js jt ju jv hn dt translated">做一个“npm开始”。它将设置服务器监听端口3000。</p></blockquote><p id="a952" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所以，现在尝试首先调用异步方法，它将在10秒后打印“它应该在10秒后得到打印”并发送响应(空)。</p><pre class="jx jy jz ka fq lj lk ll lm aw ln dt"><span id="11e9" class="lo lp hu lk b fv lq lr l ls lt">curl -X GET <a class="ae mc" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a>/async</span></pre><figure class="jx jy jz ka fq iv fe ff paragraph-image"><div class="fe ff md"><img src="../Images/3039a96dfa139d71037162a05a44abaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*aMSgMY1jsaFax5nq5_szKw.png"/></div></figure><p id="4bb5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所以现在调用/async端点，然后尝试下面提到的curl请求。你将永远得不到服务器的响应。</p><pre class="jx jy jz ka fq lj lk ll lm aw ln dt"><span id="3fca" class="lo lp hu lk b fv lq lr l ls lt">curl -X GET <a class="ae mc" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a></span></pre><p id="82d5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">真正发生的是回调被无限期推迟，因为事件循环在“/”API中被阻塞。所以当你使用无限循环时就会发生这种情况。</p><p id="7685" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这对一个高流量的服务器有很多影响。</p><p id="9bc7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所以伙计们，这就是基本面1.0的终结。如果你有任何疑问或觉得有什么不对的地方，请在评论中纠正我。</p><p id="0c7a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">和平！！</p></div></div>    
</body>
</html>