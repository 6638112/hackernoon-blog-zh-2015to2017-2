<html>
<head>
<title>Making sense out of flamegraphs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解火焰图</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/making-sense-out-of-flamegraphs-f25e1a0eb760?source=collection_archive---------4-----------------------#2017-02-25">https://medium.com/hackernoon/making-sense-out-of-flamegraphs-f25e1a0eb760?source=collection_archive---------4-----------------------#2017-02-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/1febf38074ad884cba4ab5d16eee0568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cv0d6P_EmeNSRLcbniPl7A.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Flamegraph generated for a Rails application’s request</figcaption></figure><p id="3aea" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">火焰图是一个有价值的工具，可以帮助您调试应用程序的性能问题。但是，当您第一次使用它时，它们可能会让人不知所措，尤其是当您处理复杂的Rails应用程序，其中有许多事情正在进行的时候。</p><p id="112f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">但是我们所需要的只是一点点关于如何构建flamegraph以及它代表什么的直觉，我们就可以开始我们的性能优化之旅了。这篇文章旨在帮助你获得有价值的直觉。</p><h2 id="74cd" class="ke kf hu bd kg kh ki kj kk kl km kn ko jr kp kq kr jv ks kt ku jz kv kw kx ky dt translated">什么是火焰图？</h2><p id="33ad" class="pw-post-body-paragraph jg jh hu ji b jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz ld kb kc kd hn dt translated">火焰图只是<em class="le">采样分析器输出的可视化。</em></p><p id="733b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">采样分析器？好吧，让我们把事情分解一下。首先，<em class="le">分析器</em>是一个工具，它让你检查运行程序的<em class="le">并收集统计数据，告诉你有多少资源(比如内存、磁盘等等。)程序正在使用，方法调用花费多长时间，执行代码的每个部分花费多长时间，等等。这些统计数据有助于你优化你的程序。有许多不同种类的分析器，深入研究它们已经超出了本文的范围。</em></p><p id="2d52" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">为了更好地理解火焰图，让我们仔细看看采样分析器。</p><h2 id="255a" class="ke kf hu bd kg kh ki kj kk kl km kn ko jr kp kq kr jv ks kt ku jz kv kw kx ky dt translated"><strong class="ak">采样剖析器</strong></h2><p id="2ebe" class="pw-post-body-paragraph jg jh hu ji b jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz ld kb kc kd hn dt translated"><em class="le">采样分析器</em> <strong class="ji hv"> <em class="le"> </em> </strong>是一种分析器，它通过定期拍摄运行程序的<a class="ae lf" href="https://en.wikipedia.org/wiki/Call_stack" rel="noopener ugc nofollow" target="_blank">方法调用堆栈</a>的快照来工作，并报告在哪里(在哪些函数或方法中)花费了最多的执行时间，从而允许我们识别程序中较慢的部分(瓶颈)。</p><p id="1a7d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">理解采样分析器的工作原理对于获得阅读火焰图的直觉是至关重要的。因此，让我用一些源代码来展示采样分析器是如何工作的。</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="78cb" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh lm ln lo lp b">runner.rb</code>中的代码简单地调用了两个类中的方法——<code class="eh lm ln lo lp b">HeavyWorker</code>和<code class="eh lm ln lo lp b">LightWorker</code>——它们都做了一些需要不同时间完成的工作。</p><p id="bf4c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">像我之前描述的那样，采样分析器以我们的采样频率定义的速率拍摄程序调用堆栈的快照(换句话说，就是样本)。</p><p id="4a58" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">假设我们的程序需要大约<code class="eh lm ln lo lp b">6 seconds</code>来运行(这实际上不是真的),并且我们用<code class="eh lm ln lo lp b">1 second</code>的采样频率来分析程序，这些将是我们得到的样本——</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lq"><img src="../Images/9d51a55e0a40e56c898aacdbc5c2058e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wUhdf0n9gGUIlBTZXc_69A.jpeg"/></div></div></figure><p id="a2e3" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">每行代表调用堆栈中的一个框架。利用我们对<a class="ae lf" href="https://www.youtube.com/watch?v=Q2sFmqvpBe0" rel="noopener ugc nofollow" target="_blank">调用栈代表什么</a>的直觉，我们现在可以从我们获得的样本中推断出以下事实—</p><ol class=""><li id="a8f7" class="lr ls hu ji b jj jk jn jo jr lt jv lu jz lv kd lw lx ly lz dt translated"><code class="eh lm ln lo lp b">HeavyWorker#work</code>大约占总执行时间的2/3(~ 66%)。</li><li id="3f75" class="lr ls hu ji b jj ma jn mb jr mc jv md jz me kd lw lx ly lz dt translated"><code class="eh lm ln lo lp b">HeavyWorker#work</code>中的执行时间在<code class="eh lm ln lo lp b">HeavyWorker#work</code> (~33%)和<code class="eh lm ln lo lp b">HeavyWorker#more_work</code> (~33%)之间平均分配。</li><li id="2972" class="lr ls hu ji b jj ma jn mb jr mc jv md jz me kd lw lx ly lz dt translated">总执行时间的1/3(~ 33%)花费在<code class="eh lm ln lo lp b">LightWorker#work.</code></li></ol><p id="2191" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这是一些有用的信息。想象一下，如果您可以从Rails请求执行中获得这样的快照，您可以做些什么。我们可以知道在模型中花费了多少百分比的响应时间，或者渲染你的模板花费了多长时间，或者是否有任何有问题的库花费了太多时间来执行。</p><p id="1421" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在我们的程序中使用真正的采样分析器，比如<a class="ae lf" href="https://github.com/tmm1/stackprof" rel="noopener ugc nofollow" target="_blank">stack prof</a>(Ruby2.1+的一个流行选项)将会为我们提供这样的报告</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div class="fe ff mf"><img src="../Images/548941ae6dbb1e5221953603b9aad0d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*qOiATeuTBTRCsLmMZxpwzQ.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Text report generated by running stackprof</figcaption></figure><p id="f88f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">该报告告诉您每个方法(帧)在调用堆栈快照顶部出现的次数(这意味着在该时间点，该方法正在执行)。</p><p id="ba68" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">根据我们上面的推断，这个报告告诉我们<code class="eh lm ln lo lp b">HeavyWorker</code>花费了大约66%的执行时间，而<code class="eh lm ln lo lp b">LightWorker</code>花费了大约33%。需要注意的重要一点是，我们需要小心不要将这与<em class="le">实际执行时间相关联。</em>这是不准确的，采样分析器并不意味着跟踪每个方法的实际执行时间。</p><p id="0dde" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">stackprof非常复杂，您也可以使用它生成其他报告。请务必阅读他们的<a class="ae lf" href="https://github.com/tmm1/stackprof" rel="noopener ugc nofollow" target="_blank">文档</a>以了解更多信息。</p><h2 id="38d8" class="ke kf hu bd kg kh ki kj kk kl km kn ko jr kp kq kr jv ks kt ku jz kv kw kx ky dt translated">回到火焰图</h2><p id="74bd" class="pw-post-body-paragraph jg jh hu ji b jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz ld kb kc kd hn dt translated">既然我们已经清楚了如何使用采样分析器从正在运行的程序中提取样本，那么我们可以看看如何使用这些样本来生成火焰图。</p><p id="1c28" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们需要做的是，将上面得到的快照组合成一条水平线(代表时间进程)。我们可以得到这样的东西—</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mg"><img src="../Images/12a15da0c7ef393b6d98f7610e02d200.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Ss1LE25Y3cYUCK-HgwPpQ.jpeg"/></div></div></figure><p id="0594" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我已经根据它们属于哪一类对它们进行了颜色编码。现在只需<em class="le">看一眼</em>就可以知道每个类和方法花费了多少执行时间。很漂亮吧？我希望你现在对如何阅读火焰图有了更好的直觉。</p><p id="aefa" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们继续使用<a class="mh mi gr" href="https://medium.com/u/af8fe46fdb8f?source=post_page-----f25e1a0eb760--------------------------------" rel="noopener" target="_blank">山姆·萨弗伦</a>的<a class="ae lf" href="https://github.com/SamSaffron/flamegraph" rel="noopener ugc nofollow" target="_blank">火焰图</a>宝石为我们的程序生成一个真正的火焰图。这是你使用它的方法——</p><p id="b40f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh lm ln lo lp b">Flamegraph.generate('flamegraph.html') { # your code }</code></p><p id="f556" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这是我们得到的结果—</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div class="fe ff mj"><img src="../Images/36c4f3f7b2ffa39d3756b1e1add381e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*Y9PWPXtXBozayt92I6aFHg.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Flamegraph for our example code. Has been tweak little to cut out noise (frames from the Flamegraph and stackprof libraries) and frames have been given clearer names.</figcaption></figure><p id="8d68" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">堆叠在彼此顶部的重复帧代表我们在程序中使用的块<a class="ae lf" href="https://gist.github.com/steverob/1c7679518d0b1a40b5707ee4f0da398d#file-heavy_worker-rb-L3" rel="noopener ugc nofollow" target="_blank">这里是</a>。每个Ruby块在调用堆栈上都有一个单独的框架。</p><p id="3a59" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">既然你已经学会了如何阅读火焰图，你应该能够挖掘和跟踪你的代码库的那些减慢你的应用程序的部分，并且为了乐趣和利益执行一些优化！</p><h2 id="92d6" class="ke kf hu bd kg kh ki kj kk kl km kn ko jr kp kq kr jv ks kt ku jz kv kw kx ky dt translated"><strong class="ak">与导轨一起使用</strong></h2><p id="40fd" class="pw-post-body-paragraph jg jh hu ji b jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz ld kb kc kd hn dt translated">有许多方法可以为Rails应用程序生成火焰图。我建议你使用<a class="ae lf" href="https://github.com/MiniProfiler/rack-mini-profiler" rel="noopener ugc nofollow" target="_blank"> rack-mini-profiler </a> gem。这个gem将各种<a class="ae lf" href="https://hackernoon.com/tagged/tools" rel="noopener ugc nofollow" target="_blank">工具</a>捆绑在一起，让您执行数据库、调用堆栈和内存分析。</p><p id="2491" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">一旦您将rack-mini-profiler与Rails应用程序连接起来，您就可以开始分析您的请求，并以火焰图的形式轻松地显示结果。</p><p id="89f0" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv">接下来是什么？— </strong>由于Rails框架的巨大复杂性，为Rails请求生成的火焰图可能会非常复杂和嘈杂。我强烈推荐你阅读<a class="mh mi gr" href="https://medium.com/u/450384e6a749?source=post_page-----f25e1a0eb760--------------------------------" rel="noopener" target="_blank"> Justin Weiss </a>关于主题的<a class="ae lf" href="http://www.justinweiss.com/articles/a-new-way-to-understand-your-rails-apps-performance/" rel="noopener ugc nofollow" target="_blank">博客，以帮助你在使用flamegraphs调试Rails应用程序时提高效率。</a></p></div><div class="ab cl mk ml hc mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hn ho hp hq hr"><p id="7af4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这篇文章对你有用吗？如果是这样，请在下面的评论中分享你的反馈。你可以在推特上关注我，地址是<a class="ae lf" href="https://twitter.com/stev4niTy" rel="noopener ugc nofollow" target="_blank"> @stev4nity </a>。</p><p id="1621" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="le">我在</em><strong class="ji hv"><em class="le">sprite，</em> </strong> <em class="le">工作，这是一家专门开发和维护Rails应用程序的开发公司。如果您需要一些专家帮助来调整您的应用程序并获得更多回报，请联系我们！</em></p><div class="lg lh li lj fq ab cb"><figure class="mr iv ms mt mu mv mw paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mr iv ms mt mu mv mw paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mr iv ms mt mu mv mw paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mx my mz"><p id="f922" class="jg jh le ji b jj jk jl jm jn jo jp jq na js jt ju nb jw jx jy nc ka kb kc kd hn dt translated"><a class="ae lf" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是阿妹家庭的一员。我们现在<a class="ae lf" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae lf" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>的机会。</p><p id="708a" class="jg jh le ji b jj jk jl jm jn jo jp jq na js jt ju nb jw jx jy nc ka kb kc kd hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lf" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lf" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lg lh li lj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nd"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="ne ll l"/></div></figure></div></div>    
</body>
</html>