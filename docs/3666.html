<html>
<head>
<title>Understanding homoiconicity through Clojure macros</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Clojure宏理解同象似性</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/understanding-homoiconicity-through-clojure-macros-eeb8c1f25369?source=collection_archive---------3-----------------------#2017-04-16">https://medium.com/hackernoon/understanding-homoiconicity-through-clojure-macros-eeb8c1f25369?source=collection_archive---------3-----------------------#2017-04-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="9035" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">代码就是数据，数据就是代码</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/dcf1dd1b71a5992843610c2e0ae35164.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lfd-W9SElnMNda-v."/></div></div></figure><p id="19ae" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">主要参与了。到目前为止，在我的职业生涯中，同象似性对我来说是一个新的概念，当我第一次在Clojure遇到它的时候(也是后来在酏剂中)。</p><p id="ba96" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果你在维基百科上查一下，你会发现通常的冗长定义有点道理。</p><blockquote class="ks"><p id="9177" class="kt ku hu bd kv kw kx ky kz la lb kq ek translated"><em class="lc">“……同象似性是某些编程语言的一个特性，在这些语言中，程序结构与其语法相似，因此程序的内部表示可以通过阅读文本的布局来推断……”</em></p></blockquote><p id="91cd" class="pw-post-body-paragraph jv jw hu jx b jy ld iv ka kb le iy kd ke lf kg kh ki lg kk kl km lh ko kp kq hn dt translated">所以，简言之:<strong class="jx hv">代码就是数据，数据就是代码</strong>。</p><h1 id="c4f1" class="li lj hu bd lk ll lm ln lo lp lq lr ls ja lt jb lu jd lv je lw jg lx jh ly lz dt translated">报价和评估</h1><p id="fa98" class="pw-post-body-paragraph jv jw hu jx b jy ma iv ka kb mb iy kd ke mc kg kh ki md kk kl km me ko kp kq hn dt translated">举一个简单的例子:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mf"><img src="../Images/16001513cfe3cbe5d28e2f04183d33c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/0*AI589YLl3MzcyB0G."/></div></figure><p id="8c6c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这一行代码执行临时绑定(将x绑定到值1 ),然后增加x，得到返回值2。</p><p id="c1a5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">所以它是可以被执行并产生一些数据的代码。</p><p id="8160" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">但是同样，它也可以被认为是一个包含三个元素的列表:</p><ul class=""><li id="863a" class="mg mh hu jx b jy jz kb kc ke mi ki mj km mk kq ml mm mn mo dt translated">一个<a class="ae kr" href="http://clojure.org/data_structures#Data Structures-Symbols" rel="noopener ugc nofollow" target="_blank">符号</a>命名字母；</li><li id="ff36" class="mg mh hu jx b jy mp kb mq ke mr ki ms km mt kq ml mm mn mo dt translated">包含两个元素的向量——一个名为x的符号和一个整数；</li><li id="ff6b" class="mg mh hu jx b jy mp kb mq ke mr ki ms km mt kq ml mm mn mo dt translated">包含两个元素的列表——一个名为inc的符号，一个名为x的符号。</li></ul><h1 id="314c" class="li lj hu bd lk ll lm ln lo lp lq lr ls ja lt jb lu jd lv je lw jg lx jh ly lz dt translated">引用</h1><p id="d5d2" class="pw-post-body-paragraph jv jw hu jx b jy ma iv ka kb mb iy kd ke mc kg kh ki md kk kl km me ko kp kq hn dt translated">您可以使用<a class="ae kr" href="https://clojuredocs.org/clojure.core/quote" rel="noopener ugc nofollow" target="_blank"> <strong class="jx hv">引用</strong> </a>函数获取一些Clojure代码，并将其作为数据返回，而不是对其进行评估。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/48513810b6f1a3d09cea1144771a860d.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/0*Dt7zq6kDxOGV2N_Z."/></div></figure><p id="a0c1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">侧栏:</strong> <em class="mv">任何F#开发人员阅读本文都会注意到与F#中的</em> <a class="ae kr" href="https://msdn.microsoft.com/en-us/library/dd233212.aspx" rel="noopener ugc nofollow" target="_blank"> <em class="mv">代码引用</em> </a> <em class="mv">的相似之处，尽管您得到的表示并不那么容易操作，也没有内置的方法来评估它。也就是说，您确实有一些选择，包括:</em></p><ul class=""><li id="ef91" class="mg mh hu jx b jy jz kb kc ke mi ki mj km mk kq ml mm mn mo dt translated"><a class="ae kr" href="http://fsprojects.github.io/FSharp.Quotations.Evaluator/" rel="noopener ugc nofollow" target="_blank"> <em class="mv"> F#报价评估员</em> </a> <em class="mv">和</em></li><li id="1628" class="mg mh hu jx b jy mp kb mq ke mr ki ms km mt kq ml mm mn mo dt translated"><a class="ae kr" href="http://nessos.github.io/Vagabond/" rel="noopener ugc nofollow" target="_blank"> <em class="mv">流浪</em> </a> <em class="mv">，这就是</em> <a class="ae kr" href="http://www.m-brace.net/" rel="noopener ugc nofollow" target="_blank"> <em class="mv">在云中执行代码的方式</em> </a> <em class="mv"/></li></ul><h1 id="a052" class="li lj hu bd lk ll lm ln lo lp lq lr ls ja lt jb lu jd lv je lw jg lx jh ly lz dt translated">evaluate 评价</h1><p id="9aeb" class="pw-post-body-paragraph jv jw hu jx b jy ma iv ka kb mb iy kd ke mc kg kh ki md kk kl km me ko kp kq hn dt translated">另一方面，您具有<a class="ae kr" href="https://clojuredocs.org/clojure.core/eval" rel="noopener ugc nofollow" target="_blank"> <strong class="jx hv"> eval </strong> </a>功能。它接受数据并作为代码执行。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mf"><img src="../Images/413398ec43543cf634d898f72541d70c.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/0*IjQO7t7M8ymCAnkh."/></div></figure><p id="c50b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在您将一些可执行代码捕获为数据之后，您还可以在执行转换后的代码之前对其进行操作。这就是宏的用武之地。</p><h1 id="61d9" class="li lj hu bd lk ll lm ln lo lp lq lr ls ja lt jb lu jd lv je lw jg lx jh ly lz dt translated">宏指令</h1><p id="a59c" class="pw-post-body-paragraph jv jw hu jx b jy ma iv ka kb mb iy kd ke mc kg kh ki md kk kl km me ko kp kq hn dt translated"><a class="ae kr" href="http://clojure.github.io/clojure/clojure.test-api.html" rel="noopener ugc nofollow" target="_blank">比如clojure.test </a>就是一个用宏编写的单元测试框架。您可以使用“is”宏做一个简单的断言:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mf"><img src="../Images/603d24e98e1fc8fc4e629baa0c75a0cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/0*BHG9uelyGfaX0ued."/></div></figure><p id="9911" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">并与我们从NUnit得到的错误信息进行对比。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mw"><img src="../Images/41dde82bbabf08aead485ae013b978c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/0*d2tKeAmlaWktdkiP."/></div></figure><p id="0396" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">失败的表达式被打印出来，这样你就可以直接看到哪里出错了，这不是很好吗？这比我们从NUnit得到的一般消息信息量大得多，NUnit迫使我们四处挖掘并找出哪一行测试失败了。</p><p id="db5c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv"><em class="mv">2015年05月23日更新:</em> </strong></p><p id="b2bd" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><em class="mv">正如Vasily在评论中指出的，有一个F#的断言库叫做</em><a class="ae kr" href="https://code.google.com/p/unquote/" rel="noopener ugc nofollow" target="_blank"><em class="mv">un quote</em></a><em class="mv">，它使用F#代码引号(上面提到过)，并产生类似于</em><a class="ae kr" href="http://clojure.github.io/clojure/clojure.test-api.html" rel="noopener ugc nofollow" target="_blank"><em class="mv">clo jure . test</em></a><em class="mv">的用户友好的错误消息。这表明，即使没有宏，仅仅能够轻松地将代码捕获为您的语言中的数据结构就可以实现许多用例——菲尔·特雷福德的</em><a class="ae kr" href="https://foq.codeplex.com/" rel="noopener ugc nofollow" target="_blank"><em class="mv">Foq</em></a><em class="mv">mocking库是另一个很好的例子。</em></p><h1 id="2d66" class="li lj hu bd lk ll lm ln lo lp lq lr ls ja lt jb lu jd lv je lw jg lx jh ly lz dt translated">构建断言等于宏</h1><p id="6b03" class="pw-post-body-paragraph jv jw hu jx b jy ma iv ka kb mb iy kd ke mc kg kh ki md kk kl km me ko kp kq hn dt translated">作为一个发现的过程，让我们看看如何通过宏来完成。</p><h2 id="936c" class="mx lj hu bd lk my mz na lo nb nc nd ls ke ne nf lu ki ng nh lw km ni nj ly nk dt translated">版本1</h2><p id="5156" class="pw-post-body-paragraph jv jw hu jx b jy ma iv ka kb mb iy kd ke mc kg kh ki md kk kl km me ko kp kq hn dt translated">首先，我们将定义<em class="mv">可能</em>工作的最简单的宏:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff nl"><img src="../Images/4926e7d59865d4e920bcc8ea5d23f5da.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/0*0-hTPXf9ybT-0Nih."/></div></figure><p id="087b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">哎呀，所以最后一个案例没有成功。</p><p id="2f76" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这是因为传递给宏的实际值和期望值是代码，而不是整数值2。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff nm"><img src="../Images/6dd7878a00b4b1fda205c26b4f0c8be2.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/0*oe68JFh367srqgcq."/></div></figure><h2 id="b7b2" class="mx lj hu bd lk my mz na lo nb nc nd ls ke ne nf lu ki ng nh lw km ni nj ly nk dt translated">版本2</h2><p id="0175" class="pw-post-body-paragraph jv jw hu jx b jy ma iv ka kb mb iy kd ke mc kg kh ki md kk kl km me ko kp kq hn dt translated">如果我们在里面做个评估呢？</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff nn"><img src="../Images/359e6cda57eac6de639aa8c53aed35c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/0*P8dFKaO1elf-dKJG."/></div></figure><p id="ef7e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这行得通，对吧？对吗？</p><p id="cb9f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">不完全是。</p><p id="ffd4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们没有操纵代表代码的数据，而是在编译时对它们进行评估(宏在编译时运行)。</p><p id="6eca" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">您可以通过使用<a class="ae kr" href="https://clojuredocs.org/clojure.core/macroexpand" rel="noopener ugc nofollow" target="_blank">宏展开</a>来验证这一点:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff no"><img src="../Images/7b7277d2dc7ef4d5c49bf14dc9afcad3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/0*yUn3pYIlT64q-y5k."/></div></figure><p id="4834" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">所以你可以看到我们的宏已经把输入的代码转换成布尔值<em class="mv"> true </em>并作为代码返回。</p><h2 id="9e79" class="mx lj hu bd lk my mz na lo nb nc nd ls ke ne nf lu ki ng nh lw km ni nj ly nk dt translated">版本3</h2><p id="2b2d" class="pw-post-body-paragraph jv jw hu jx b jy ma iv ka kb mb iy kd ke mc kg kh ki md kk kl km me ko kp kq hn dt translated">我们应该做的是返回我们想要作为数据执行的代码，我们已经知道如何做了——使用<em class="mv">引用</em>函数。在返回的代码中，我们还需要在断言失败时出错。</p><p id="6d59" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">从我们要执行的代码开始，假设:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mf"><img src="../Images/5da76bc1d7be95831f65fb1a78e57650.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/0*u2rboDP_7KigGmCo."/></div></figure><p id="4665" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">嗯，我们想:</p><ul class=""><li id="a481" class="mg mh hu jx b jy jz kb kc ke mi ki mj km mk kq ml mm mn mo dt translated">比较实际和预期的评估值，如果不相等则抛出<em class="mv"> AssertionError </em></li><li id="0ec3" class="mg mh hu jx b jy mp kb mq ke mr ki ms km mt kq ml mm mn mo dt translated">在错误信息中显示实际表达式<em class="mv"> (inc 1) </em>和预期表达式<em class="mv"> (+ 0 1) </em></li><li id="a420" class="mg mh hu jx b jy mp kb mq ke mr ki ms km mt kq ml mm mn mo dt translated">显示实际值的评估值— 2</li></ul><p id="3eee" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">那么，也许是这样的？</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mf"><img src="../Images/f39b904f2a6254ce5c6829b1fab55c4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/0*k8Eh6YHZD1Fb7_Iu."/></div></figure><p id="0711" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在我们知道了我们的最终目标，我们可以向后工作来定义我们的宏:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff np"><img src="../Images/aea4e2264b7315667e558f4f3cc63ff1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/0*Ox0BvnDlaMBL0-EK."/></div></figure><p id="31e7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">看到相似之处了吗？这里需要注意的重要一点是，我们引用了整个<em class="mv"> let </em> block(通过‘速记’)。但是为了引用<em class="mv">实际的</em>和<em class="mv">预期的</em>表达式并按原样返回它们，即<em class="mv"> (inc 1)，(+ 0 1) </em>，我们不得不使用<strong class="jx hv"> ~ </strong>操作符有选择地取消<strong class="jx hv">某些内容的引用。</strong></p><p id="4b38" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">您可以展开宏，看到它与我们想要输出的代码在语义上是相同的:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff nq"><img src="../Images/f1be51502c3e65b0f44d227d5edd8dd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*JmxWevMFYhAKeCJN."/></div></figure><p id="2a71" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在我们继续之前，您可能会对这里正在进行的一些引用操作感到疑惑，所以让我们花一些时间来详细了解它们。</p><p id="1b0f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">输出待评估的<em class="mv">实际</em>表达式</strong></p><p id="c8b3" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">记住，我们的<em class="mv"> defmacro </em>块中的<em class="mv">实际</em>和<em class="mv">预期</em>参数是<em class="mv"> (inc 1) </em>和<em class="mv"> (+ 0 1) </em>的引用版本。</p><p id="ee8a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">为了提高效率，我们希望只评估<em class="mv">实际</em>一次，以防产生副作用。这就是为什么我们需要评估它，并将结果绑定到一个符号。</p><p id="5fd0" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">为了生成将在运行时评估<em class="mv"> (inc 1) </em>的输出代码<em class="mv">(let[actual-value(Inc 1)]……)</em>，我们需要引用引用形式的<em class="mv"> actual </em>表达式，因此<em class="mv"> ~actual </em>。</p><p id="5db1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果我们不取消<em class="mv">实际</em>的引用，请注意扩展代码中的差异。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff nl"><img src="../Images/10375fb7085d8568cbba1727f7c87bb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/0*yoppf0-3MYOlJsCh."/></div></figure><p id="6d53" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果没有~，生成的代码会寻找一个名为<em class="mv"> actual </em>的局部变量，这个变量会因为不存在而失败。</p><p id="4683" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">输出<em class="mv">实际值</em>符号</strong></p><p id="5172" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">为了在<em class="mv"> let </em>绑定中输出<em class="mv">实际值</em>符号，我们必须编写<em class="mv">~‘实际值</em>，即<em class="mv">(未引用(引用实际值))</em>。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff nr"><img src="../Images/183c6721c663a48d10a62aa0be8c0596.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/0*-Bco4umaTnv-izuC."/></div></figure><p id="2800" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我知道，对！？我也花了一段时间才想明白。</p><p id="f8eb" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">问:我们能不能只写<em class="mv">'(让[actual-value ~actual] …) </em>？</p><p id="ce3d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">A.不，因为它将转换为<em class="mv">(let[user/actual-value(Inc 1)]……)</em>，这不是一个有效的let绑定。</p><p id="c7c0" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">好的，那么<em class="mv">~实际值</em>呢？</p><p id="f16a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">A.不，因为宏不会被编译，因为我们将在<em class="mv"> defmacro </em>的范围内寻找一个不存在的局部变量<em class="mv">实际值</em>。</p><p id="4bbf" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">问:好的..还是<em class="mv">‘实际值</em>？</p><p id="8f74" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">A.不，因为它将转换为<em class="mv"> (let [(引用实际值)</em><em class="mv">(Inc 1)]……)</em>，这在运行时会失败，因为这不是有效的绑定语法。</p><p id="c458" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">问:那么<em class="mv">~‘实际值</em>到底是如何工作的呢？</p><p id="02f2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">A.以下内容:</p><ol class=""><li id="1374" class="mg mh hu jx b jy jz kb kc ke mi ki mj km mk kq ns mm mn mo dt translated"><em class="mv">(引用实际值)</em>捕捉符号<em class="mv">实际值</em></li><li id="be98" class="mg mh hu jx b jy mp kb mq ke mr ki ms km mt kq ns mm mn mo dt translated">取消对符号的引用，使其显示为输出代码中的样子</li></ol><p id="5cb7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">输出<em class="mv">实际</em>和<em class="mv">预期</em>表达式</strong></p><p id="7fd9" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">最后，在公式化错误信息时，我们还看到了<em class="mv">' ~实际</em>和<em class="mv">' ~预期</em>。</p><p id="eaf5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">下面是带引号和不带引号的扩展代码。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff nt"><img src="../Images/05a6a25cdeff31d54a7feb539c8cad0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/0*KKAm7YkJbAn6Tx7J."/></div></figure><p id="54e5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">看出区别了吗？</p><p id="698e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果没有引用，生成的代码将会评估<em class="mv"> (inc 1) </em>并打印<em class="mv"> FAIL in 2 </em>。</p><p id="7cff" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果引用的话，它会打印<em class="mv"> FAIL in (inc 1) </em>，这正是我们想要的。</p><p id="fcde" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">经验法则</strong></p><ul class=""><li id="40e0" class="mg mh hu jx b jy jz kb kc ke mi ki mj km mk kq ml mm mn mo dt translated">要捕获一个符号，使用<em class="mv"> ~ '符号名称</em></li><li id="975f" class="mg mh hu jx b jy mp kb mq ke mr ki ms km mt kq ml mm mn mo dt translated">要引用宏的参数并生成将在运行时评估的代码，请使用<em class="mv"> ~arg-name </em></li><li id="d15d" class="mg mh hu jx b jy mp kb mq ke mr ki ms km mt kq ml mm mn mo dt translated">要引用宏的参数并生成在运行时引用它的代码，请使用<em class="mv"> '~arg-name </em></li></ul><p id="4795" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">最后，让我们测试一下我们的新宏。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff nl"><img src="../Images/140534c2d0598f47c38f9983eb87ec89.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/0*AQjQPIZ576Xb5epR."/></div></figure><p id="c460" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">太棒了。就这样吗？</p><p id="0056" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">差不多了。</p><p id="f911" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这里我们的宏有一个小问题——在<em class="mv">实际值</em>上的名字冲突是不安全的。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mf"><img src="../Images/3efc803c46e79ec090f6e241139118dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/0*H-cQKg0TQhuRfF2I."/></div></figure><h2 id="47de" class="mx lj hu bd lk my mz na lo nb nc nd ls ke ne nf lu ki ng nh lw km ni nj ly nk dt translated">版本4</h2><p id="b178" class="pw-post-body-paragraph jv jw hu jx b jy ma iv ka kb mb iy kd ke mc kg kh ki md kk kl km me ko kp kq hn dt translated">如果你在一个符号的末尾看到<strong class="jx hv"> # </strong>，那么这将用于自动生成一个带有随机名称的新符号。这在宏中很有用，因为它可以防止宏中声明的符号泄漏。</p><p id="6442" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">因此，我们可以不使用<em class="mv"> let </em>绑定中的<em class="mv">~‘实际值</em>，而是执行以下操作:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff nu"><img src="../Images/4eaab5ed9deeab428baad3433e8efee7.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/0*i3H9etCDtgWJGN1S."/></div></figure><p id="2f2c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">展开后，可以看到<em class="mv"> let </em>绑定使用了一个随机生成的符号<em class="mv">actual-value _ _ 16087 _ _ auto _ _</em>:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff nv"><img src="../Images/3e93b0939d961e0cb32a3d5a67d7c981.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/0*oB3LI9JHZ2094Zl7."/></div></figure><p id="f8dd" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这个版本不仅更安全，而且没有令人费解的<em class="mv">(引用实际值))</em>业务，可读性更好！</p><p id="a36f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">因此，这里有一个对同象性和宏Clojure的简单介绍。宏是一个人工具箱中的强大工具，它允许你像clojure.test一样以一种非常自然的方式扩展语言。我希望你会觉得这个想法很有趣，而且我已经很好地解释了这个话题。</p><p id="a85b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果有任何不清楚的地方，请随时在评论中告诉我。</p><h1 id="57ce" class="li lj hu bd lk ll lm ln lo lp lq lr ls ja lt jb lu jd lv je lw jg lx jh ly lz dt translated">链接</h1><ul class=""><li id="c208" class="mg mh hu jx b jy ma kb mb ke nw ki nx km ny kq ml mm mn mo dt translated"><a class="ae kr" href="https://hackernoon.com/learn-to-learn-286558241fd6" rel="noopener ugc nofollow" target="_blank">学会学习</a></li><li id="b8d2" class="mg mh hu jx b jy mp kb mq ke mr ki ms km mt kq ml mm mn mo dt translated"><a class="ae kr" href="https://hackernoon.com/dont-learn-a-syntax-learn-to-change-the-way-you-think-18436807012d" rel="noopener ugc nofollow" target="_blank">不要学一种语法，要学会改变你的思维方式</a></li><li id="297f" class="mg mh hu jx b jy mp kb mq ke mr ki ms km mt kq ml mm mn mo dt translated"><a class="ae kr" href="http://amzn.to/1F2waSN" rel="noopener ugc nofollow" target="_blank">clo jure第二版的喜悦</a></li><li id="0bdd" class="mg mh hu jx b jy mp kb mq ke mr ki ms km mt kq ml mm mn mo dt translated"><a class="ae kr" href="http://learnxinyminutes.com/docs/clojure/" rel="noopener ugc nofollow" target="_blank">Y分钟学会clo jure</a></li><li id="d0c7" class="mg mh hu jx b jy mp kb mq ke mr ki ms km mt kq ml mm mn mo dt translated"><a class="ae kr" href="http://learnxinyminutes.com/docs/clojure-macros/" rel="noopener ugc nofollow" target="_blank">在Y分钟内学会Clojure宏</a></li><li id="0fac" class="mg mh hu jx b jy mp kb mq ke mr ki ms km mt kq ml mm mn mo dt translated"><a class="ae kr" href="https://yobriefca.se/blog/2014/05/19/the-weird-and-wonderful-characters-of-clojure/" rel="noopener ugc nofollow" target="_blank">clo jure</a>的怪异和神奇人物</li></ul><div class="jk jl jm jn fq ab cb"><figure class="nz jo oa ob oc od oe paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nz jo oa ob oc od oe paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nz jo oa ob oc od oe paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="of og oh"><p id="f922" class="jv jw mv jx b jy jz iv ka kb kc iy kd oi kf kg kh oj kj kk kl ok kn ko kp kq hn dt translated"><a class="ae kr" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kr" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kr" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae kr" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jv jw mv jx b jy jz iv ka kb kc iy kd oi kf kg kh oj kj kk kl ok kn ko kp kq hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kr" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kr" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ol"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>