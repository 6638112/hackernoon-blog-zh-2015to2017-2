<html>
<head>
<title>Building a Chatbot Using Rasa Stack: Intro and Tips</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Rasa堆栈构建聊天机器人:介绍和提示</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/building-a-chatbot-using-rasa-stack-intro-and-tips-c6d1057d8536?source=collection_archive---------2-----------------------#2017-12-03">https://medium.com/hackernoon/building-a-chatbot-using-rasa-stack-intro-and-tips-c6d1057d8536?source=collection_archive---------2-----------------------#2017-12-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="bc6b" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">为什么是拉莎？</h1><p id="db52" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">大公司开发了大量易于使用的bot构建框架。有机会近距离观察了一下<a class="ae kn" href="https://dialogflow.com/" rel="noopener ugc nofollow" target="_blank"> Dialogflow </a>(原名API。AI；Google开发)和<a class="ae kn" href="https://dev.botframework.com/" rel="noopener ugc nofollow" target="_blank"> Bot框架</a>(微软开发)。Dialogflow和Bot框架都有预先构建的自定义语言理解模式。这些框架似乎是让你快速入门的好工具，尤其是如果你没有可以用作训练数据的聊天记录的话。</p><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff ko"><img src="../Images/5b04a8251084197f1c92cf23e5515b93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0XrFcDk4g7lpXAL3K3ZyPA.png"/></div></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">.</figcaption></figure><p id="7332" class="pw-post-body-paragraph jp jq hu jr b js le ju jv jw lf jy jz ka lg kc kd ke lh kg kh ki li kk kl km hn dt translated">但是，在某些情况下，您可能希望避免使用在Google或Microsoft拥有的服务器上处理用户输入的闭源框架。例如，你想为一家企业开发一个<a class="ae kn" href="https://hackernoon.com/tagged/chatbot" rel="noopener ugc nofollow" target="_blank">聊天机器人</a>，这个聊天机器人将从用户那里接收潜在的敏感或机密信息。在这种情况下，你可能更愿意把聊天机器人的所有组件都放在家里。</p><p id="fba2" class="pw-post-body-paragraph jp jq hu jr b js le ju jv jw lf jy jz ka lg kc kd ke lh kg kh ki li kk kl km hn dt translated">这就是Rasa平台非常方便的地方。它是一个开源的bot构建框架。它在服务器上没有任何可以使用API调用的预建模型，这意味着要让它运行起来需要更多的工作。然而，我认为完全控制你的聊天机器人的所有组件是完全值得的。</p><p id="467a" class="pw-post-body-paragraph jp jq hu jr b js le ju jv jw lf jy jz ka lg kc kd ke lh kg kh ki li kk kl km hn dt translated"><a class="ae kn" href="https://hackernoon.com/tagged/rasa" rel="noopener ugc nofollow" target="_blank"> Rasa </a>栈由两大部分组成:<a class="ae kn" href="https://nlu.rasa.ai/" rel="noopener ugc nofollow" target="_blank"> Rasa NLU </a>和<a class="ae kn" href="https://core.rasa.ai/" rel="noopener ugc nofollow" target="_blank"> Rasa核心</a>。拉莎·NLU负责聊天机器人的自然语言理解。其主要目的是，给定一个输入句子，预测该句子的<em class="lj">意图</em>，并从中提取有用的<em class="lj">实体</em>。意图决定了聊天机器人应该如何响应用户的输入。实体用于使响应更加个性化(例如，记住用户的姓名/年龄)。关于意图、实体的更多信息可以在Rasa NLU文件网站上的<a class="ae kn" href="https://nlu.rasa.ai/tutorial.html" rel="noopener ugc nofollow" target="_blank">教程</a>中找到。</p><p id="dd3a" class="pw-post-body-paragraph jp jq hu jr b js le ju jv jw lf jy jz ka lg kc kd ke lh kg kh ki li kk kl km hn dt translated">第二个组件，Rasa核心，是Rasa堆栈管道中的下一个组件。它以意图和实体的形式接受结构化输入(Rasa NLU或任何其他意图分类工具的输出)，并使用概率模型选择机器人应该采取的行动(更具体地说，它使用在Keras中实现的<a class="ae kn" href="https://core.rasa.ai/policies.html#generalising-to-new-dialogues" rel="noopener ugc nofollow" target="_blank"> LSTM神经网络</a>)。</p><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff lk"><img src="../Images/dca371fb42e261b23b53744bf43c3649.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1jKyxaFAZf3p-Jo6N0NV8Q.png"/></div></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">Typical output of Rasa NLU</figcaption></figure><p id="a611" class="pw-post-body-paragraph jp jq hu jr b js le ju jv jw lf jy jz ka lg kc kd ke lh kg kh ki li kk kl km hn dt translated">Rasa很酷的一点是，堆栈的每个部分都是完全可定制的，并且很容易互换。可以单独使用Rasa核心或Rasa NLU(我最初只使用NLU组件开始使用Rasa)。当使用Rasa NLU，你可以选择几个后端NLP库。Rasa Core用于动作预测的LSTM神经网络可以很容易地与任何其他网络交换，如果你对递归神经网络以及如何在Keras中实现它们有一点了解的话。到目前为止，默认的LSTM神经网络非常适合我的应用程序，并且可以相对快速地训练，所以我没有尝试改变它。</p><p id="05f3" class="pw-post-body-paragraph jp jq hu jr b js le ju jv jw lf jy jz ka lg kc kd ke lh kg kh ki li kk kl km hn dt translated">深入研究Rasa堆栈的更多细节没有什么意义。了解它的能力的最好方法是通过<a class="ae kn" href="https://core.rasa.ai/tutorial_basics.html" rel="noopener ugc nofollow" target="_blank"> Rasa核心</a>和<a class="ae kn" href="https://nlu.rasa.ai/tutorial.html" rel="noopener ugc nofollow" target="_blank"> Rasa NLU </a>文档网站上的教程。我发现教程和文档很全面，容易理解。</p><h1 id="1271" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">发展提示</h1><p id="b3e2" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">在过去的几周里，我一直在做一个简单的帮助台聊天机器人。在这里，我想分享一些技巧，如果你刚刚开始使用Rasa stack开发你的第一个聊天机器人，这些技巧可能会有用。如果您熟悉Rasa chatbot的一般结构，这些提示会有意义(也就是说，最好先完成教程)。</p><p id="6ba8" class="pw-post-body-paragraph jp jq hu jr b js le ju jv jw lf jy jz ka lg kc kd ke lh kg kh ki li kk kl km hn dt translated">如果你已经仔细阅读了Rasa NLU和Rasa核心的全部文档，你不会在这里学到任何新东西。</p><h2 id="e1bb" class="ll is hu bd it lm ln lo ix lp lq lr jb ka ls lt jf ke lu lv jj ki lw lx jn ly dt translated">为您的域仔细选择插槽类型</h2><p id="9946" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">在Rasa核心文件的<em class="lj">深度剖析</em>部分，有一段加粗的文字写道:</p><blockquote class="lz ma mb"><p id="11bd" class="jp jq lj jr b js le ju jv jw lf jy jz mc lg kc kd md lh kg kh me li kk kl km hn dt translated"><strong class="jr hv">应小心选择插槽类型。</strong></p></blockquote><p id="79dd" class="pw-post-body-paragraph jp jq hu jr b js le ju jv jw lf jy jz ka lg kc kd ke lh kg kh ki li kk kl km hn dt translated">当我第一次阅读文档时，我错过了这一部分，这导致了一个令人讨厌的错误。聊天机器人顽固地对用于训练它的一些输入做出不正确的反应。</p><p id="2f9f" class="pw-post-body-paragraph jp jq hu jr b js le ju jv jw lf jy jz ka lg kc kd ke lh kg kh ki li kk kl km hn dt translated">假设你的聊天机器人识别的意图之一是一个<code class="eh mf mg mh mi b">login problem</code>。当用户告诉机器人一个登录问题而没有提供任何细节时，您希望您的机器人提供一些通用的响应(或要求澄清)。除此之外，您还针对用户在使用电脑、手机或平板电脑时出现登录问题的情况准备了三种具体的应对措施。</p><p id="5e6c" class="pw-post-body-paragraph jp jq hu jr b js le ju jv jw lf jy jz ka lg kc kd ke lh kg kh ki li kk kl km hn dt translated">在这种情况下，您应该将这些关键字定义为<code class="eh mf mg mh mi b">domain.yml</code>中的槽，如下所示:</p><pre class="kp kq kr ks fq mj mi mk ml aw mm dt"><span id="7948" class="ll is hu mi b fv mn mo l mp mq">entities:<br/> - login_problem_type</span><span id="018e" class="ll is hu mi b fv mr mo l mp mq">slots:<br/> login_problem_type:<br/> type: categorical<br/> values:<br/> — computer<br/> — phone<br/> — tablet</span></pre><p id="f3e0" class="pw-post-body-paragraph jp jq hu jr b js le ju jv jw lf jy jz ka lg kc kd ke lh kg kh ki li kk kl km hn dt translated">很容易将这个插槽的类型定义为<code class="eh mf mg mh mi b">text</code>，因为docs网站上的大多数教程都使用这个类型。<code class="eh mf mg mh mi b">text</code>描述一个槽式说:</p><blockquote class="lz ma mb"><p id="70dc" class="jp jq lj jr b js le ju jv jw lf jy jz mc lg kc kd md lh kg kh me li kk kl km hn dt translated">如果设置了任何值，则导致槽的特征被设置为<code class="eh mf mg mh mi b">1</code>。否则，该特性将被设置为<code class="eh mf mg mh mi b">0</code>(未设置任何值)。</p></blockquote><p id="294b" class="pw-post-body-paragraph jp jq hu jr b js le ju jv jw lf jy jz ka lg kc kd ke lh kg kh ki li kk kl km hn dt translated">这意味着该插槽将不会捕获用户是否对您列出的特定<em class="lj">设备有问题。它只会捕捉用户是否对您列出的</em>设备中的<em class="lj">有问题，而不会指明是哪一个。最有可能的情况是，聊天机器人会选择并给出您为它接收的任何设备类型准备的答案之一。</em></p><p id="459c" class="pw-post-body-paragraph jp jq hu jr b js le ju jv jw lf jy jz ka lg kc kd ke lh kg kh ki li kk kl km hn dt translated">现在，这里是对<code class="eh mf mg mh mi b">categorical</code>类型的描述:</p><blockquote class="lz ma mb"><p id="4883" class="jp jq lj jr b js le ju jv jw lf jy jz mc lg kc kd md lh kg kh me li kk kl km hn dt translated">创建一个描述哪个<code class="eh mf mg mh mi b">values</code>匹配的独热编码。</p></blockquote><p id="c11f" class="pw-post-body-paragraph jp jq hu jr b js le ju jv jw lf jy jz ka lg kc kd ke lh kg kh ki li kk kl km hn dt translated">这意味着聊天机器人将能够区分涉及不同设备类型的登录问题。</p><h2 id="1fe9" class="ll is hu bd it lm ln lo ix lp lq lr jb ka ls lt jf ke lu lv jj ki lw lx jn ly dt translated">不要忘记为插槽的值定义同义词</h2><p id="1a86" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我在这里继续使用上一个例子中的插槽。预计有些人会把他们的电脑称为“台式机”或“笔记本电脑”。因此，我们需要将这些单词定义为<code class="eh mf mg mh mi b">computer</code>槽值的同义词。有两种方法可以做到:</p><ul class=""><li id="9480" class="ms mt hu jr b js le jw lf ka mu ke mv ki mw km mx my mz na dt translated">在包含Rasa核心解释器培训数据的<code class="eh mf mg mh mi b">data/nlu.md</code>文件中，指定每个示例中出现的同义词，如下所示:</li></ul><pre class="kp kq kr ks fq mj mi mk ml aw mm dt"><span id="01eb" class="ll is hu mi b fv mn mo l mp mq">- I changed my [laptop](login_problem_type:computer) recently and cant login<br/>- cant login from my new [macbook](login_problem_type:computer). Is there any additional software that i need to install?</span></pre><ul class=""><li id="39cc" class="ms mt hu jr b js le jw lf ka mu ke mv ki mw km mx my mz na dt translated">在<code class="eh mf mg mh mi b">models/nlu/current/entity_synonyms.json</code>中，将同义词添加到字典中，使用同义词作为键，使用slot <code class="eh mf mg mh mi b">value</code>作为值(全部使用小写就足够了)。示例:</li></ul><pre class="kp kq kr ks fq mj mi mk ml aw mm dt"><span id="de79" class="ll is hu mi b fv mn mo l mp mq">{<br/> “laptop”: “computer”,<br/> “desktop”: “computer”,<br/> “machine”: “computer”,<br/> “pc”: “computer”,<br/> “macbook”: “computer”,<br/> “iphone”: “phone”,<br/> “ipad”: “tablet”<br/>}</span></pre><p id="0174" class="pw-post-body-paragraph jp jq hu jr b js le ju jv jw lf jy jz ka lg kc kd ke lh kg kh ki li kk kl km hn dt translated">当您训练Rasa核心模型时，使用第一种方法指定的同义词将被添加到<code class="eh mf mg mh mi b">entity_synonyms.json</code>中的字典中，因此添加同义词的两种方法最终是等效的。</p><h2 id="915f" class="ll is hu bd it lm ln lo ix lp lq lr jb ka ls lt jf ke lu lv jj ki lw lx jn ly dt translated">写故事时使用检查点</h2><p id="4311" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">当你发布你的聊天机器人时，你会很快开始聚集大量有价值的训练数据。这意味着需要频繁更新<code class="eh mf mg mh mi b">data/nlu.md</code>和<code class="eh mf mg mh mi b">data/stories.md</code>文件。随着您收集更多的训练数据并向bot添加更多的复杂性，这两个文件的大小(就行数而言)会增长得非常快。我不是说文本文件的磁盘大小是一个问题，但是由于这些文件是手动处理的，所以保持它们有组织是很重要的。</p><p id="8ecb" class="pw-post-body-paragraph jp jq hu jr b js le ju jv jw lf jy jz ka lg kc kd ke lh kg kh ki li kk kl km hn dt translated">有了<code class="eh mf mg mh mi b">data/nlu.md</code>文件就简单多了。我认为它是一个只附加的文件。因为它是用来训练解释器的，而且额外的训练数据不会影响性能，所以我只是将新的用户输入添加到该文件中相应的意图中。</p><p id="6029" class="pw-post-body-paragraph jp jq hu jr b js le ju jv jw lf jy jz ka lg kc kd ke lh kg kh ki li kk kl km hn dt translated">跟<code class="eh mf mg mh mi b">data/stories.md</code>完全是两码事。当你给你的机器人增加新的功能或者遇到一个引导一个有效但非常不可预测的对话的用户时，你可能需要对现有的故事做一些改变。<code class="eh mf mg mh mi b">data/stories.md</code>通过使用检查点使其更加模块化，管理起来就容易多了。</p><p id="1820" class="pw-post-body-paragraph jp jq hu jr b js le ju jv jw lf jy jz ka lg kc kd ke lh kg kh ki li kk kl km hn dt translated">假设您正在编写一个对话故事，其中用户讲述了一个登录问题，但没有提供任何细节，聊天机器人需要澄清这个问题:</p><pre class="kp kq kr ks fq mj mi mk ml aw mm dt"><span id="eed2" class="ll is hu mi b fv mn mo l mp mq">## help with login (general)<br/>* login_general<br/> — utter_login_specify<br/>&gt; clarify login problem</span></pre><p id="256f" class="pw-post-body-paragraph jp jq hu jr b js le ju jv jw lf jy jz ka lg kc kd ke lh kg kh ki li kk kl km hn dt translated"><code class="eh mf mg mh mi b">&gt;clarify login problem</code>在“故事模块”的末尾添加了检查点，因为上述交流是不同类型的更具体登录问题的常见开端。</p><p id="422f" class="pw-post-body-paragraph jp jq hu jr b js le ju jv jw lf jy jz ka lg kc kd ke lh kg kh ki li kk kl km hn dt translated">然后我们可以为各种更具体的登录问题指定“故事分支”。</p><pre class="kp kq kr ks fq mj mi mk ml aw mm dt"><span id="c283" class="ll is hu mi b fv mn mo l mp mq">## help with login (computer)<br/>&gt; clarify login problem<br/>* login_clarification{"login_problem_type":"computer"}<br/> — utter_login_computer_help</span><span id="d261" class="ll is hu mi b fv mr mo l mp mq">## help with login (phone)<br/>&gt; clarify login problem<br/>* login_clarification{"login_problem_type":"phone"}<br/> — utter_login_phone_help</span><span id="08bd" class="ll is hu mi b fv mr mo l mp mq">## help with login (tablet)<br/>&gt; clarify login problem<br/>* login_clarification{"login_problem_type":"tablet"}<br/> — utter_login_tablet_help</span></pre><p id="5424" class="pw-post-body-paragraph jp jq hu jr b js le ju jv jw lf jy jz ka lg kc kd ke lh kg kh ki li kk kl km hn dt translated">显然，使用检查点可以使故事文件更有条理，并帮助您在编写新故事时节省一些时间。<a class="ae kn" href="https://core.rasa.ai/stories.html" rel="noopener ugc nofollow" target="_blank">检查点使用的另一个例子</a>是在文档中。</p><h2 id="381e" class="ll is hu bd it lm ln lo ix lp lq lr jb ka ls lt jf ke lu lv jj ki lw lx jn ly dt translated">在将用户消息传递给机器人时，不要忘记指定<code class="eh mf mg mh mi b">sender_id</code></h2><p id="ed0e" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">Rasa Core的大部分功能都可以通过<a class="ae kn" href="https://github.com/RasaHQ/rasa_core/blob/master/rasa_core/agent.py" rel="noopener ugc nofollow" target="_blank">代理类</a>的方法来访问。<code class="eh mf mg mh mi b">handle_message(text_message)</code>是该类的方法之一。它接受用户输入作为参数，然后通过我在引言中描述的管道运行该输入，并返回机器人想要响应的消息。</p><p id="d81d" class="pw-post-body-paragraph jp jq hu jr b js le ju jv jw lf jy jz ka lg kc kd ke lh kg kh ki li kk kl km hn dt translated"><code class="eh mf mg mh mi b">handle_message(text_message)</code>方法的可选参数之一是<code class="eh mf mg mh mi b">sender_id</code>。如果您有一个服务于多个客户端的代理实例，那么为每个客户端分配一个惟一的<code class="eh mf mg mh mi b">sender_id</code>并将其与来自该客户端的每个输入一起传递给<code class="eh mf mg mh mi b">handle_message(text_message, sender_id=some_unique_id)</code>是非常重要的。</p><p id="5055" class="pw-post-body-paragraph jp jq hu jr b js le ju jv jw lf jy jz ka lg kc kd ke lh kg kh ki li kk kl km hn dt translated">文档中没有提到任何关于<code class="eh mf mg mh mi b">sender_id</code>的内容，起初我也不清楚它的用途。最初，我认为代理实例跟踪单个对话。为了让聊天机器人同时服务于两个客户端，我认为我需要两个代理实例。然后为连接到服务器的每个新客户端创建一个新的，并在客户端离开时删除或重置旧客户端的状态。</p><p id="1b06" class="pw-post-body-paragraph jp jq hu jr b js le ju jv jw lf jy jz ka lg kc kd ke lh kg kh ki li kk kl km hn dt translated">如果指定了<code class="eh mf mg mh mi b">sender_id</code>，就没有必要这么麻烦了。对于每个唯一的用户，代理实例的处理器创建一个跟踪器实例，该实例维护与该特定用户的对话状态。每个tracker实例都保存在Tracker存储区中，并根据会话的当前状态进行更新。使用单个代理实例时，无需担心聊天机器人会混淆与不同用户的对话！</p><p id="ba83" class="pw-post-body-paragraph jp jq hu jr b js le ju jv jw lf jy jz ka lg kc kd ke lh kg kh ki li kk kl km hn dt translated">你可以在这里了解Rasa核心组件是如何组装在一起的<a class="ae kn" href="https://core.rasa.ai/plumbing.html" rel="noopener ugc nofollow" target="_blank">。你可以在源文件</a><a class="ae kn" href="https://github.com/RasaHQ/rasa_core/blob/master/rasa_core/processor.py" rel="noopener ugc nofollow" target="_blank"> processor.py </a>和<a class="ae kn" href="https://github.com/RasaHQ/rasa_core/blob/master/rasa_core/tracker_store.py" rel="noopener ugc nofollow" target="_blank"> tracker_store.py </a>中找到更多关于如何处理<code class="eh mf mg mh mi b">sender_id</code>的细节。</p></div><div class="ab cl nb nc hc nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="hn ho hp hq hr"><p id="90ce" class="pw-post-body-paragraph jp jq hu jr b js le ju jv jw lf jy jz ka lg kc kd ke lh kg kh ki li kk kl km hn dt translated">对我来说，开始使用Rasa非常容易。虽然我没有训练数据，但我能够用编造的数据成功地训练出第一个原型。我的聊天机器人现在可以非常准确地识别15种不同的意图，其中一些具有非常接近的含义和预期的句子结构。我用大约300个例子训练了解释器(<code class="eh mf mg mh mi b">nlu.md</code>)，每个意图大约10-20个例子。我的<code class="eh mf mg mh mi b">stories.md</code>文件大约有150行长，总共只有25个故事。在用相对少量的数据进行训练后，它对以前看不见的输入进行分类的准确性给我留下了非常深刻的印象。</p><p id="db92" class="pw-post-body-paragraph jp jq hu jr b js le ju jv jw lf jy jz ka lg kc kd ke lh kg kh ki li kk kl km hn dt translated">Rasa堆栈非常容易使用。无需编写一行代码，就可以创建一个可以在终端中与之交互的聊天机器人。从我上面的例子中你可能已经注意到，所有包含训练数据和领域规范的Rasa文件都是用Markdown编写的。当然，当你想让它为客户做好准备时，在为它设计后端和前端时会有大量的编程工作。</p><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff ni"><img src="../Images/b8247a287ea24c2a64cf0b7d9d31547a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0aj2s4ROm-cgE3uYrYk3wg.png"/></div></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">Testing the chatbot from the terminal</figcaption></figure><p id="15d3" class="pw-post-body-paragraph jp jq hu jr b js le ju jv jw lf jy jz ka lg kc kd ke lh kg kh ki li kk kl km hn dt translated">对我个人来说，开发聊天机器人最困难的部分是创建一个用户友好的前端，因为我在这方面几乎没有经验。如果你在开发一个好的前端方面有问题，我建议你看看GitHub上的simple React或Angular聊天室项目，然后选择你喜欢的(并且理解！)最多。你不需要改变很多东西，因为聊天机器人的前端几乎和普通聊天室的前端一样。虽然我没有探索这条道路，但我知道将Rasa聊天机器人与脸书信使联系起来是可能的；这样你就不用担心前端了。</p></div><div class="ab cl nb nc hc nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="hn ho hp hq hr"><p id="d41a" class="pw-post-body-paragraph jp jq hu jr b js le ju jv jw lf jy jz ka lg kc kd ke lh kg kh ki li kk kl km hn dt translated">我希望这些技巧能够帮助刚开始使用Rasa的开发人员更快地构建一个原型，并避免过程中的一些常见错误。</p><p id="7deb" class="pw-post-body-paragraph jp jq hu jr b js le ju jv jw lf jy jz ka lg kc kd ke lh kg kh ki li kk kl km hn dt translated">关于Rasa堆栈的最佳信息来源是文档。整篇文章中有很多相关的链接。Rasa在Medium上也有他们的博客，你可以在这里找到<a class="ae kn" href="https://medium.com/rasa-blog" rel="noopener"/>。</p><h2 id="10e8" class="ll is hu bd it lm ln lo ix lp lq lr jb ka ls lt jf ke lu lv jj ki lw lx jn ly dt translated">编辑#1:</h2><p id="7187" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">将故事中的意图格式更改为当前格式(在Core的0.10.1版本中引入)。</p><figure class="kp kq kr ks fq kt"><div class="bz el l di"><div class="nj nk l"/></div></figure></div></div>    
</body>
</html>