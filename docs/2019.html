<html>
<head>
<title>Rahawan: How We Achieved 95% Better Response Time By Mostly-Unidirectional Data Access Layer Design</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rahawan:我们如何通过单向数据访问层设计将响应时间提高了95%</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/rahawan-how-we-achieved-95-better-response-time-by-mostly-unidirectional-data-access-layer-design-1af1f87755f5?source=collection_archive---------5-----------------------#2017-01-02">https://medium.com/hackernoon/rahawan-how-we-achieved-95-better-response-time-by-mostly-unidirectional-data-access-layer-design-1af1f87755f5?source=collection_archive---------5-----------------------#2017-01-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="b901" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">介绍</h1><p id="27a4" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">构建网站/应用程序来服务每天数百万的访问是一个真正的挑战，尤其是在尽可能降低响应时间的时候。新闻网站是高负载网站/应用程序的完美例子。构建少数几个并保持良好状态，需要我们从头开始重新设计/重写我们的数据访问层。</p><p id="948d" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">“Rahawan”是一个针对数据访问层的全新设计，帮助我们将网站响应时间从250毫秒缩短到10毫秒。同时将数据库负载从每秒800个补丁请求减少到每秒150个补丁请求。</p><h1 id="507a" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">长话短说</h1><p id="decc" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">最简单的形式，“Rahawan”只不过是一个由数据缓存引擎驱动的数据访问层。它的主要目的是<strong class="jr hv">即时</strong>提供一个完全加载的<a class="ae ks" href="https://hackernoon.com/tagged/data-model" rel="noopener ugc nofollow" target="_blank">数据模型</a>来响应web请求(比如浏览某个网页)。</p><p id="0831" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">大多数情况下，提供“数据模型”的过程是作为直接的键值检索操作来完成的。数据库记录的任何变化都会触发Rahawan内部的<strong class="jr hv">后台任务</strong>来重建与修改后的数据库记录相关的“数据模型”。</p><p id="763a" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated"><strong class="jr hv">注意:在谈论Rahawan本身之前，我将做一个闪回来展示这个解决方案是如何发展的。如果你愿意，你可以跳过迭代一&amp;二。</strong></p><h1 id="ab07" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">迭代一:凌乱缓慢的代码:)</h1><p id="3de5" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">像许多开发人员一样，我确实参与了一些项目，在这些项目中，所有的灯都是“绿色”的，任何团队成员都可以在任何地方编写任何代码。只要它导致一个工作网站。</p><p id="15ff" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">客户急于推出他们的网站。通常这会给开发团队带来很大的压力，在这个迭代中，除了构建一个可工作的网站，做任何事情都是次要的。不要谈论代码质量或团队成员之间更好的协调。这导致fat控制器直接与数据库通信。这是一个简化的示例:</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="8b71" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">如图所示，这只是“意大利面条式代码”的完美开端。控制器正在直接与数据库通信。数据通过两种不同的方式(视图模型和视图包)从控制器传输到视图。要在视图内部进行部分渲染，请使用“Html。RenderAction”已经使用过一次，而“Html。“Partial”已在另一个中使用。</p><p id="9af0" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">这样的代码很难经受住许多团队成员所做的持续的变更请求和错误修复。当一些开发人员在这里修复了一个bug，新的bug就会在那里产生。如果团队设法击落所有的bug，没有人可以结束糟糕的性能问题。所有这些都消耗了大量的时间和精力来达到近乎稳定的网站。</p><p id="809d" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">在这个迭代的末尾，所有的团队都同意他们需要为激动人心的事情休息一下，并思考更好的解决这些问题的方法。这将促使我们:</p><h1 id="c29c" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">迭代二:清理代码</h1><p id="d09b" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">在前一次迭代中面临很多问题后，团队得到了它。不是所有的绿灯都是好的，一些红旗必须放在导致问题的道路上，并遵循一些统一的设计准则。</p><p id="2d50" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">以下两点是我们团队一致认同的危险信号的真实例子:</p><ul class=""><li id="86fc" class="la lb hu jr b js kn jw ko ka lc ke ld ki le km lf lg lh li dt translated">除非非常必要，否则不要使用ViewBag或ViewData</li><li id="2839" class="la lb hu jr b js lj jw lk ka ll ke lm ki ln km lf lg lh li dt translated">不要使用Html。RenderAction，除非真的有必要</li></ul><p id="8d5d" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">这是我们通过第二次迭代后的简化示例</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="7b67" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">代码已由以下人员清理:</p><ul class=""><li id="7fa5" class="la lb hu jr b js kn jw ko ka lc ke ld ki le km lf lg lh li dt translated">使用<a class="ae ks" href="http://martinfowler.com/eaaCatalog/unitOfWork.html" rel="noopener ugc nofollow" target="_blank">工作模式单元</a>封装数据检索逻辑，这将释放优化数据检索方式的能力，而无需接触控制器。</li><li id="1f97" class="la lb hu jr b js lj jw lk ka ll ke lm ki ln km lf lg lh li dt translated">使用<a class="ae ks" href="http://structuremap.github.io/" rel="noopener ugc nofollow" target="_blank">依赖注入</a>提供控制器所需的工作单元。</li><li id="15c6" class="la lb hu jr b js lj jw lk ka ll ke lm ki ln km lf lg lh li dt translated">使用“ViewModel”作为将数据从控制器传输到视图的唯一方式，视图具有严格的模型类型有助于开发人员更加自信地进行更改，减少意外行为。</li><li id="5161" class="la lb hu jr b js lj jw lk ka ll ke lm ki ln km lf lg lh li dt translated">消除对“RenderAction”不必要的调用，因为它会创建新的控制器实例，并且<a class="ae ks" href="http://stackoverflow.com/questions/719027/renderaction-renderpartial" rel="noopener ugc nofollow" target="_blank">比“RenderPartial”花费更长的时间&amp;更慢的路径</a>。除非真的需要这样做，否则“RenderPartial”是我们的首选。</li><li id="377b" class="la lb hu jr b js lj jw lk ka ll ke lm ki ln km lf lg lh li dt translated">使用输出缓存，这将指导ASP.NET进程不调用“索引操作”，除非从最后一次调用到同一操作过去了60秒，并在60秒过去之前从ASP.NET缓存为web请求提供服务。</li></ul><h1 id="c90f" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">迭代三:拉哈万</h1><p id="f3d7" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">为了更好的理解，我们来采访一下。</p><p id="d67e" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">我:你好<br/>T9】拉哈万:你好</p><p id="f985" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">我:你能介绍一下你自己吗？<br/> <strong class="jr hv"> Rahawan: </strong>我是一个增强的数据访问层。</p><p id="42a2" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated"><strong class="jr hv"> Me: </strong>你为什么声称自己是“增强的”，是什么让你与其他数据访问层有所不同？<br/> <strong class="jr hv">拉哈万:</strong>我被设计成<a class="ae ks" href="https://facebook.github.io/flux/" rel="noopener ugc nofollow" target="_blank">尽可能利用单向数据流</a>。</p><p id="6454" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">我:你说的利用单向数据流是什么意思？在回答之前，让我先解释一下我要解决的问题:</p><ul class=""><li id="cc57" class="la lb hu jr b js kn jw ko ka lc ke ld ki le km lf lg lh li dt translated">通常当某个网页被请求，<strong class="jr hv">并且没有缓存版本提供服务，</strong>服务器端页面控制器将使用传统的数据访问层从数据库中获取所需的数据，然后为页面做准备。所有这些逻辑都是独立于任何其他页面逻辑完成的。这导致从数据库中获得相同数据的重复，尽管它暂时没有改变。</li><li id="817f" class="la lb hu jr b js lj jw lk ka ll ke lm ki ln km lf lg lh li dt translated">例如，同一作者写的三个新闻网页同时被请求。每个页面将查询数据库以获得自己的作者数据副本，本例中有3x3个问题:)<br/> * 3个数据库在同一时间查询相同的确切数据。<br/>* web服务器内存中相同作者数据的3个副本。<br/> * 3个比所需速度慢的网页。</li></ul><p id="5142" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated"><strong class="jr hv">我:</strong>关于这个问题，你的解决方案呢？<br/> <strong class="jr hv"> Rahawan: </strong>我的解决方案是总是将对数据库项所做的修改移动到web服务器的内存缓存引擎，即使表示层还没有请求这些数据项。这将确保从数据库到内存再到表示层的大部分单向数据流。</p><p id="2200" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">我:这将如何实现？<br/> <strong class="jr hv">拉哈万:</strong>通过这个设计:</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="fe ff lo"><img src="../Images/6edba93f563a6fd6d55324d52bd725c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WU8KBDLmmVb6nTnlw-TGsA.png"/></div></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">Rahawan design diagram</figcaption></figure><p id="9019" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated"><strong class="jr hv">我:</strong>能解释一下吗？<br/> <strong class="jr hv">拉哈万:</strong>当然，它展示了用来完成我的任务的4个组件:</p><ul class=""><li id="69b2" class="la lb hu jr b js kn jw ko ka lc ke ld ki le km lf lg lh li dt translated"><strong class="jr hv">变更检测器:</strong>它的职责是检测数据库中发生的任何变更，并用。</li><li id="ac29" class="la lb hu jr b js lj jw lk ka ll ke lm ki ln km lf lg lh li dt translated"><strong class="jr hv">缓存存储库:</strong>它的职责是通过在缓存引擎和存储库之间进行协调来服务数据请求。作为拉哈万的单一联系点。</li><li id="e54d" class="la lb hu jr b js lj jw lk ka ll ke lm ki ln km lf lg lh li dt translated"><strong class="jr hv">缓存引擎:</strong>它的职责是在内存中保存数据。</li><li id="383e" class="la lb hu jr b js lj jw lk ka ll ke lm ki ln km lf lg lh li dt translated"><strong class="jr hv"> Repository: </strong>它的职责是与数据库通信，以获取数据。</li></ul><p id="ad7e" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated"><strong class="jr hv">我:</strong>但是任何ORM比如实体框架都可以做到，为什么还要这样？<br/> <strong class="jr hv"> Rahawan: </strong>有很大的区别，比如实体框架，没有被设计成线程安全的，这意味着多个web请求不能使用同一个实体框架上下文安全地处理。而Rahawan被设计成线程安全的。</p><p id="fde7" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">我:线程安全问题可以用某种方式处理，继续使用ORM而不是这种复杂性。<br/> <strong class="jr hv">拉哈万:</strong>这样你只解决了一半的谜题，那另一半呢？</p><p id="daf0" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated"><strong class="jr hv">我:</strong>什么另一半？<br/> <strong class="jr hv">拉哈万:</strong>缓慢的数据库查询。你只需要五分钟的时间来监控实时数据库查询——<a class="ae ks" href="http://sqlblog.com/blogs/adam_machanic/archive/2012/03/22/released-who-is-active-v11-11.aspx" rel="noopener ugc nofollow" target="_blank">使用活跃的sp</a>——然后你就可以清楚地知道ORMs通常和Entity Framework不能有效地翻译复杂的查询。这会导致许多超时错误，尤其是在高负载网站/应用程序上。</p><p id="b611" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">我:你是如何处理数据库查询缓慢的问题的？<br/> <strong class="jr hv"> Rahawan: </strong>通过将数据缓存逻辑从数据检索逻辑中分离出来，我们可以更好地控制如何检索数据(使用ORM或第三方库，如<a class="ae ks" href="https://github.com/StackExchange/dapper-dot-net" rel="noopener ugc nofollow" target="_blank"> Dapper </a>)。这释放了手动重写特定查询的能力，从而在不影响缓存方式的情况下提高它们的效率。</p><p id="9545" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated"><strong class="jr hv">我:</strong>你之前说的4个组件如何协同工作？拉哈万:举个真实的例子</p><ul class=""><li id="6775" class="la lb hu jr b js kn jw ko ka lc ke ld ki le km lf lg lh li dt translated">一些作者发表新闻条目。</li><li id="ed3b" class="la lb hu jr b js lj jw lk ka ll ke lm ki ln km lf lg lh li dt translated">新闻条目保存在数据库中。</li><li id="9a73" class="la lb hu jr b js lj jw lk ka ll ke lm ki ln km lf lg lh li dt translated">Change Detector检测到某个新闻项已经发布，并在从表示层请求之前调用缓存的存储库来获取该新闻项。</li><li id="ea0f" class="la lb hu jr b js lj jw lk ka ll ke lm ki ln km lf lg lh li dt translated">缓存存储库从数据库中检索新闻项目，并将其传递给缓存引擎。</li><li id="6e34" class="la lb hu jr b js lj jw lk ka ll ke lm ki ln km lf lg lh li dt translated">一个网页控制器从缓存存储库请求新闻项目，该存储库直接从缓存引擎提供新闻项目。</li></ul><p id="5367" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">管理员从数据库中免费获得这样的新闻条目，这反映了网站用户更好的响应。</p><p id="f7b9" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">我:这意味着你将在缓存引擎中复制整个数据库？<br/> <strong class="jr hv">拉哈万:</strong>当然不是，有某种方法可以决定哪些数据会保留在缓存引擎中，哪些数据不会。</p><p id="6664" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">我:关于这种方式的细节？<br/> <strong class="jr hv">拉哈万:</strong>虽然这是根据情况定制的。但是，例如，上个月发布的任何新闻都很可能会有很高的需求。然后是访问率高的新闻条目的优先级。这些可以保存在缓存引擎中，而其他可以根据需要从数据库中检索。</p><p id="b428" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">这意味着数据流并不总是单向的。<br/> <strong class="jr hv">拉哈万:</strong>这就是为什么提到了“大多-单向”。因为大部分数据请求(基于真实世界的情况)将是单向的，并且在被服务之前从数据库中检索的百分比将会减少。</p><p id="0842" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated"><strong class="jr hv"> Me: </strong>如果从数据库中按需检索了某个项目，缓存失效策略是为了什么？<br/> <strong class="jr hv">拉哈万:</strong>缓存的项目——作为单独的项目——没有失效策略。相反，缓存引擎容量受到监控。一旦达到最大容量，最少请求的项目将被删除。</p><p id="6f4f" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated"><strong class="jr hv">我:</strong>我明白你的想法了，那么实施呢？<br/> <strong class="jr hv"> Rahawan: </strong>虽然当前的4个组件实现可以随着时间的推移而改变，但这些是当前的细节:</p><ul class=""><li id="d2e6" class="la lb hu jr b js kn jw ko ka lc ke ld ki le km lf lg lh li dt translated"><strong class="jr hv">变更检测器:</strong>当前的实现对数据库执行定期的SQL查询，以找出哪些记录已经被修改。SQL查询使用修改日期来获取这些记录，<a class="ae ks" href="http://hangfire.io/" rel="noopener ugc nofollow" target="_blank"> Hangfire </a>用于调度&amp;在同一网站/应用程序的后台线程中运行这些定期查询。</li><li id="8178" class="la lb hu jr b js lj jw lk ka ll ke lm ki ln km lf lg lh li dt translated"><strong class="jr hv">缓存存储库:</strong>非常薄的层没有特殊的实现，只是有引用存储库&amp;缓存引擎来协调之间的关系。并在需要时处理数据。</li><li id="9e39" class="la lb hu jr b js lj jw lk ka ll ke lm ki ln km lf lg lh li dt translated"><strong class="jr hv">存储库:</strong>两个<a class="ae ks" href="https://github.com/StackExchange/dapper-dot-net" rel="noopener ugc nofollow" target="_blank"> Dapper </a> &amp;实体框架都是用来和数据库通信的，这里有一点很重要的说明:<br/>* raha wan的目标之一就是尽可能的减少SQL连接。例如，新闻SQL select查询将只获取作者id。然后，将从“作者缓存存储库”请求作者数据。作者数据很可能已经存在于缓存引擎中。因此，我们赢得了两次胜利，第一次是通过减少SQL连接，第二次是通过避免重复查询使数据库过载。</li><li id="77bb" class="la lb hu jr b js lj jw lk ka ll ke lm ki ln km lf lg lh li dt translated"><strong class="jr hv">缓存引擎:</strong>使用static ConcurrentDictionary构建，因为它的简单性和它对存储在其中的数据提供的控制量。</li></ul><p id="2a84" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated"><strong class="jr hv">我:</strong>结果呢？<br/> <strong class="jr hv"> Rahawan: </strong>在服务器端级别，<a class="ae ks" href="https://github.com/MiniProfiler/dotnet" rel="noopener ugc nofollow" target="_blank"> Mini Profiler </a>用于测量响应时间，这是一个区别示例:</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div class="fe ff lz"><img src="../Images/436dfd5e18c9b695a402666f9b37c2c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*PPIm_3TpCE6UsNW6Dasm0g.png"/></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">Website response time before &amp; after using Rahawan</figcaption></figure><p id="a023" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated"><strong class="jr hv">拉哈万:</strong>在数据库级别:</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div class="fe ff ma"><img src="../Images/e3b81416e81fcc93cbd069516f0e41c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*7NT5cGp5LbP-gNhuJdoPvg.png"/></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">Database usage before &amp; after using Rahawan</figcaption></figure><h1 id="99cb" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">拉哈万2.0</h1><p id="06b9" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">目前，有一个基于发布/订阅模式重建变更检测器的计划，而不是定期的SQL查询。以及Redis支持缓存引擎的其他计划，等等。</p><h1 id="fe49" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">最后:</h1><p id="c581" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">Rahawan不是消除任何网站/应用程序性能问题的银弹，它诞生于基于新闻的网站挑战，并且可以用于面临类似挑战的其他网站/应用程序。面临不同挑战的网站/应用将需要更合适的解决方案。可能是Rahawan或者是修改版的，甚至是别的什么。</p><p id="add6" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">这篇文章谈到了Rahawan的设计，并没有深入探讨我们的实现。因为这需要很多文章来分享我们的实现细节，以及在<a class="ae ks" href="https://hackernoon.com/tagged/development" rel="noopener ugc nofollow" target="_blank">开发</a>期间遇到的问题。例如内存泄漏和进程突然终止，但在深入诊断之后才发现这是未处理的堆栈溢出异常。如果需要的话，我会试着在其他文章中讨论这些细节。</p><h1 id="b453" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">等待您的反馈和评论</h1><p id="9c7d" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">谢谢，祝你有美好的一天:)<br/> <a class="ae ks" href="https://www.linkedin.com/in/ahmedmozaly" rel="noopener ugc nofollow" target="_blank">艾哈迈德·莫扎里</a></p><div class="kt ku kv kw fq ab cb"><figure class="mb kx mc md me mf mg paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mb kx mc md me mf mg paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mb kx mc md me mf mg paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mh mi mj"><p id="f922" class="jp jq mk jr b js kn ju jv jw ko jy jz ml kp kc kd mm kq kg kh mn kr kk kl km hn dt translated"><a class="ae ks" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客们下午的开始。我们是<a class="ae ks" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ks" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ks" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jp jq mk jr b js kn ju jv jw ko jy jz ml kp kc kd mm kq kg kh mn kr kk kl km hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ks" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ks" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="fe ff mo"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="mp kz l"/></div></figure></div></div>    
</body>
</html>