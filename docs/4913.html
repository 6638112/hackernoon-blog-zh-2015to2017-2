<html>
<head>
<title>Sorting Algorithms Primer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">排序算法入门</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/sorting-algorithms-primer-374b83f3ba09?source=collection_archive---------10-----------------------#2017-06-29">https://medium.com/hackernoon/sorting-algorithms-primer-374b83f3ba09?source=collection_archive---------10-----------------------#2017-06-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="6797" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">排序算法是一种采用列表或数组并按一定顺序对其元素进行重新排序的算法。有几十种不同的排序算法，如果你学过计算机科学，你可能至少熟悉其中的几种。这也是一个很受欢迎的面试问题，所以在重要的面试前提醒你一下也无妨。</p><p id="547a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是最常见的排序算法和Golang实现示例的初级读本。</p><h1 id="e757" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">冒泡排序</h1><p id="e429" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated"><a class="ae ks" href="https://en.wikipedia.org/wiki/Bubble_sort" rel="noopener ugc nofollow" target="_blank">冒泡排序</a>是最基本的<a class="ae ks" href="https://en.wikipedia.org/wiki/In-place_algorithm" rel="noopener ugc nofollow" target="_blank">原地排序</a>算法，也是几乎所有人都熟悉的一种。它具有о(n)最坏情况和平均时间复杂度，这使得它在大型列表上效率很低。实现非常简单。</p><p id="9bcc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在循环中，从第一个元素开始迭代数组，直到第n个元素，其中n = len(items)。比较相邻的值，如果顺序不对，就交换它们。你可以通过在每次迭代后将n减1来优化<a class="ae ks" href="https://hackernoon.com/tagged/algorithm" rel="noopener ugc nofollow" target="_blank">算法</a>。</p><p id="b44a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">时间复杂度:</p><ul class=""><li id="18b2" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">最坏的情况:O(n)</li><li id="42b5" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">一般情况:O(n)</li><li id="88ad" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">最佳情况:O(n)</li></ul><p id="e574" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">空间复杂性:</p><ul class=""><li id="dec3" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">最坏情况:O(1)</li></ul><figure class="lh li lj lk fq ll"><div class="bz el l di"><div class="lm ln l"/></div></figure><h1 id="c606" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">选择排序</h1><p id="47f5" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated"><a class="ae ks" href="https://en.wikipedia.org/wiki/Selection_sort" rel="noopener ugc nofollow" target="_blank">选择排序</a>是另一种简单的平均情况<a class="ae ks" href="https://en.wikipedia.org/wiki/Big_O_notation" rel="noopener ugc nofollow" target="_blank"> O </a> ( <em class="lo"> n </em>)就地排序算法。该算法将列表分为两个子列表，一个用于排序的项目，从空开始，从列表的开始从左到右构建，第二个子列表用于剩余的<a class="ae ks" href="https://hackernoon.com/tagged/remaining" rel="noopener ugc nofollow" target="_blank">未排序的项目。</a></p><p id="0ac5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这可以通过两个嵌套的for循环来实现。外部循环在列表上迭代n次，其中n = len(items)。内部循环将总是从外部循环的当前迭代器值开始(因此在每次迭代中，它将从列表中更靠右的位置开始)，并找出子列表的最小值。用找到的最小值交换子列表的第一项。</p><p id="3aca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">时间复杂度:</p><ul class=""><li id="4e0d" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">最坏的情况:O(n)</li><li id="514c" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">一般情况:O(n)</li><li id="724a" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">最佳情况:O(n)</li></ul><p id="46e4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">空间复杂性:</p><ul class=""><li id="a40b" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">最坏情况:O(1)</li></ul><figure class="lh li lj lk fq ll"><div class="bz el l di"><div class="lm ln l"/></div></figure><h1 id="92ed" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">插入排序</h1><p id="ebac" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated"><a class="ae ks" href="https://en.wikipedia.org/wiki/Insertion_sort" rel="noopener ugc nofollow" target="_blank">插入排序</a>是一个简单的就地二次O(n)排序算法。同样，它在大型列表上效率较低，但也没有什么优势:</p><ul class=""><li id="23ec" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">自适应:对于已经基本排序的列表，时间复杂度降低——如果每个元素距离其最终排序位置不超过k个位置，则为O(nk)</li><li id="0ea5" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">稳定:具有相等值的索引的相对位置不变</li><li id="f995" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">就地:只需要恒定的O(1)额外内存空间</li><li id="091e" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">实际上比冒泡或选择排序更有效</li></ul><p id="b7d1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">时间复杂度:</p><ul class=""><li id="9238" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">最坏的情况:O(n)</li><li id="6370" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">一般情况:O(n)</li><li id="50a2" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">最佳情况:O(n)</li></ul><p id="5e95" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">空间复杂性:</p><ul class=""><li id="4075" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">最坏情况:O(1)</li></ul><p id="6f5b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">实现是非常自然的，因为它的工作方式类似于你在玩纸牌游戏时如何对手中的牌进行排序。</p><figure class="lh li lj lk fq ll"><div class="bz el l di"><div class="lm ln l"/></div></figure><h1 id="580b" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">外壳分类</h1><p id="6c1e" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated"><a class="ae ks" href="https://en.wikipedia.org/wiki/Shellsort" rel="noopener ugc nofollow" target="_blank"> Shellsort </a>是插入排序的推广。这是一个有趣的排序算法，它通过将一个列表排列成一组交错排序的子列表来工作。</p><p id="b10a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，选择一系列间隙。有许多不同的公式来生成间隙序列，并且算法的平均时间复杂度取决于该变量。例如，让我们选择(2^k)-1前缀为1，这将给我们[1，3，7，15，31，63，...]。颠倒顺序:[…，63，31，15，7，3，q]。</p><p id="86c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在迭代反向间隙列表，并在每个子列表上使用插入排序。所以在第一次迭代中，取每63个元素并应用插入排序。在第二次迭代中，取每31个元素并应用插入排序。以此类推，一直到1。最后一次迭代将在整个列表上运行插入排序。</p><p id="b4ad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">时间复杂度:</p><ul class=""><li id="b1dc" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">最坏情况:O( <em class="lo"> n( </em> log(n) <em class="lo"> ) </em>)</li><li id="ba76" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">一般情况:取决于间隙序列</li><li id="272c" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">最佳情况:O( <em class="lo"> n( </em> log(n) <em class="lo"> ) </em>)</li></ul><p id="1cd7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">空间复杂性:</p><ul class=""><li id="b6aa" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">最坏情况:O(1)</li></ul><figure class="lh li lj lk fq ll"><div class="bz el l di"><div class="lm ln l"/></div></figure><h1 id="3f47" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">梳状排序</h1><p id="a407" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated"><a class="ae ks" href="https://en.wikipedia.org/wiki/Comb_sort" rel="noopener ugc nofollow" target="_blank">梳状排序</a>是对冒泡排序算法的改进。冒泡排序总是比较相邻的元素(gap=1)，而梳状排序从gap=n/1.3开始，其中n=len(items)，并在每次迭代中缩小1.3倍。</p><p id="7740" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种改进背后的想法是消除所谓的海龟(列表末尾附近的小值)。最后一次迭代与gap=1时的简单冒泡排序相同。</p><p id="f0b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">时间复杂度:</p><ul class=""><li id="07b0" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">最坏的情况:O(n)</li><li id="1358" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">平均情况:O(n /2^p) (p是增量数)</li><li id="2502" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">最佳情况:O( <em class="lo"> n( </em> log(n) <em class="lo"> ) </em>)</li></ul><p id="e3bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">空间复杂性:</p><ul class=""><li id="091d" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">最坏情况:O(1)</li></ul><figure class="lh li lj lk fq ll"><div class="bz el l di"><div class="lm ln l"/></div></figure><h1 id="9d15" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">合并排序</h1><p id="6312" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated"><a class="ae ks" href="https://en.wikipedia.org/wiki/Merge_sort" rel="noopener ugc nofollow" target="_blank">归并排序</a>是一个非常高效的通用排序算法。这是一个<a class="ae ks" href="https://en.wikipedia.org/wiki/Divide_and_conquer_algorithm" rel="noopener ugc nofollow" target="_blank">分治算法</a>，这意味着列表被递归地分解成更小的列表，这些列表被排序，然后被递归地组合以形成完整的列表。</p><blockquote class="lp lq lr"><p id="fcb0" class="ir is lo it b iu iv iw ix iy iz ja jb ls jd je jf lt jh ji jj lu jl jm jn jo hn dt translated">从概念上讲，合并排序的工作方式如下:</p><p id="f09f" class="ir is lo it b iu iv iw ix iy iz ja jb ls jd je jf lt jh ji jj lu jl jm jn jo hn dt translated">1.将未排序的列表分成<em class="hu"> n </em>个子列表，每个子列表包含1个元素(包含1个元素的列表被视为已排序)。</p><p id="43a9" class="ir is lo it b iu iv iw ix iy iz ja jb ls jd je jf lt jh ji jj lu jl jm jn jo hn dt translated">2.重复<a class="ae ks" href="https://en.wikipedia.org/wiki/Merge_algorithm" rel="noopener ugc nofollow" target="_blank">合并</a>子列表以产生新的排序子列表，直到只剩下1个子列表。这将是排序后的列表。</p><p id="5673" class="ir is lo it b iu iv iw ix iy iz ja jb ls jd je jf lt jh ji jj lu jl jm jn jo hn dt translated"><em class="hu">——</em><a class="ae ks" href="https://en.wikipedia.org/wiki/Merge_sort" rel="noopener ugc nofollow" target="_blank"><em class="hu">百科</em> </a></p></blockquote><p id="fe65" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">时间复杂度:</p><ul class=""><li id="0bdb" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">最坏情况:O( <em class="lo"> n( </em> log(n) <em class="lo"> ) </em>)</li><li id="e28c" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">平均事例:O( <em class="lo"> n( </em> log(n) <em class="lo"> ) </em>)</li><li id="e595" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">最佳情况:O( <em class="lo"> n( </em> log(n) <em class="lo"> ) </em></li></ul><p id="20ff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">空间复杂性:</p><ul class=""><li id="62a4" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">最坏的情况:O(n)</li></ul><figure class="lh li lj lk fq ll"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="313b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">暂时就这样了。然而，我将在未来涵盖更多的排序算法，所以书签这一页:)</p><blockquote class="lp lq lr"><p id="78c6" class="ir is lo it b iu iv iw ix iy iz ja jb ls jd je jf lt jh ji jj lu jl jm jn jo hn dt translated"><a class="ae ks" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是这个家庭的一员。我们现在<a class="ae ks" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ks" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is lo it b iu iv iw ix iy iz ja jb ls jd je jf lt jh ji jj lu jl jm jn jo hn dt translated">要了解更多信息，<a class="ae ks" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">请阅读我们的“关于”页面</a>、<a class="ae ks" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上给我们点赞/发消息</a>，或者简单地说，<a class="ae ks" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is lo it b iu iv iw ix iy iz ja jb ls jd je jf lt jh ji jj lu jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ks" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ks" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>