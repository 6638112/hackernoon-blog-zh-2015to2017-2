<html>
<head>
<title>Users Table Mutations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用户表变化</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/users-table-mutations-209fa19412d6?source=collection_archive---------4-----------------------#2017-02-17">https://medium.com/hackernoon/users-table-mutations-209fa19412d6?source=collection_archive---------4-----------------------#2017-02-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="16ee" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">构建和修改用户表的三种方法</h2></div><h1 id="173a" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated">摘要</h1><p id="183e" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">约翰·多伊刚刚开始了一份新工作，在一家类似优步的初创公司担任首席技术官。他将不得不扩大规模、颠覆和创新。但是现在，他需要一个用户表。</p><ul class=""><li id="eed1" class="kx ky hu kd b ke kz kh la kk lb ko lc ks ld kw le lf lg lh dt translated"><strong class="kd hv">第1天</strong>:用户是具有ID、电子邮件、密码、姓名和角色(客户、司机或管理员)的简单实体。</li><li id="b7e2" class="kx ky hu kd b ke li kh lj kk lk ko ll ks lm kw le lf lg lh dt translated">第2天 : John给所有用户添加了一个电话号码。</li><li id="b496" class="kx ky hu kd b ke li kh lj kk lk ko ll ks lm kw le lf lg lh dt translated"><strong class="kd hv">第3天</strong>:新的用例，业务在增长。用户需要国家、性别和可选公司。</li><li id="0e09" class="kx ky hu kd b ke li kh lj kk lk ko ll ks lm kw le lf lg lh dt translated">第四天:让我们只给驱动用户添加一个简介。</li><li id="aab0" class="kx ky hu kd b ke li kh lj kk lk ko ll ks lm kw le lf lg lh dt translated"><strong class="kd hv">第5天</strong>:一些客户希望将自定义属性添加到他们的客户账户中。</li></ul><p id="2e50" class="pw-post-body-paragraph kb kc hu kd b ke kz iv kg kh la iy kj kk ln km kn ko lo kq kr ks lp ku kv kw hn dt translated">约翰可以用无数种方式满足日常需求。让我们检查其中的3个场景(John选择PostgreSQL)。</p><h1 id="00de" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated">第一个场景—大嘴水牛的路径</h1><figure class="lr ls lt lu fq lv fe ff paragraph-image"><div class="fe ff lq"><img src="../Images/a21a1108fe3cf19d61419f8bba94e4e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*Tv9RjmK_9oANsmdqSj8pVQ.png"/></div></figure><h2 id="c654" class="ly jk hu bd jl lz ma mb jp mc md me jt kk mf mg jv ko mh mi jx ks mj mk jz ml dt translated">第一天</h2><p id="ba31" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">John创建了一个包含6列的<code class="eh mm mn mo mp b">users</code>表:<strong class="kd hv">id</strong><em class="mq">(</em><a class="ae mr" href="https://www.clever-cloud.com/blog/engineering/2015/05/20/why-auto-increment-is-a-terrible-idea/" rel="noopener ugc nofollow" target="_blank"><em class="mq">uuid</em></a><em class="mq">，主键)</em> <strong class="kd hv">电子邮件</strong> <em class="mq"> (varchar) </em>，<strong class="kd hv">密码</strong> <em class="mq"> (varchar) </em>，<strong class="kd hv">角色</strong> <em class="mq">(枚举:客户、司机、管理员)</em> <strong class="kd hv"> created_at</strong></p><h2 id="603a" class="ly jk hu bd jl lz ma mb jp mc md me jt kk mf mg jv ko mh mi jx ks mj mk jz ml dt translated">第二天</h2><p id="37cd" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">John修改了<code class="eh mm mn mo mp b">users</code>表并添加了一个<strong class="kd hv"> phone </strong>列<em class="mq">(</em><a class="ae mr" href="http://stackoverflow.com/questions/1846254/mysql-datatype-for-telephone-number-and-address" rel="noopener ugc nofollow" target="_blank"><em class="mq">varchar</em></a><em class="mq">，可空)。</em> <strong class="kd hv"> Phone </strong>可空:第一天创建的用户没有电话号码，John可能永远也不会知道他们的电话号码。</p><h2 id="22bb" class="ly jk hu bd jl lz ma mb jp mc md me jt kk mf mg jv ko mh mi jx ks mj mk jz ml dt translated">第三天</h2><p id="f0c1" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">约翰再次修改了<code class="eh mm mn mo mp b">users</code>表，增加了<strong class="kd hv">国家</strong> <em class="mq"> (varchar，nullable) </em>，<strong class="kd hv">性别</strong> <em class="mq"> (enum，nullable) </em>，<strong class="kd hv">公司</strong> <em class="mq"> (varchar，</em><a class="ae mr" href="http://stackoverflow.com/a/1583691/978690" rel="noopener ugc nofollow" target="_blank"><em class="mq">nullable</em></a><em class="mq">)。</em></p><h2 id="4eeb" class="ly jk hu bd jl lz ma mb jp mc md me jt kk mf mg jv ko mh mi jx ks mj mk jz ml dt translated">第四天</h2><p id="f6b3" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">传记只针对司机。至少有两种可能性:</p><ol class=""><li id="5591" class="kx ky hu kd b ke kz kh la kk lb ko lc ks ld kw ms lf lg lh dt translated">创建一个<em class="mq">可空的</em> <strong class="kd hv"> bio </strong> <em class="mq"> text </em>列(对于非驱动程序为空)</li><li id="e289" class="kx ky hu kd b ke li kh lj kk lk ko ll ks lm kw ms lf lg lh dt translated">因为它仅用于驱动程序，所以创建一个<code class="eh mm mn mo mp b">drivers_biographies</code>表，在<code class="eh mm mn mo mp b">users</code>上有FK，在<strong class="kd hv">列有个人简介</strong> <em class="mq">和文本</em>列。</li></ol><p id="d0f4" class="pw-post-body-paragraph kb kc hu kd b ke kz iv kg kh la iy kj kk ln km kn ko lo kq kr ks lp ku kv kw hn dt translated">每种可能性都有其利弊，John选择添加一个新表，因为他不喜欢有太多的空值，并且他确信他永远不会向其他帐户类型添加传记。也许他错了。</p><h2 id="6d45" class="ly jk hu bd jl lz ma mb jp mc md me jt kk mf mg jv ko mh mi jx ks mj mk jz ml dt translated">第五天</h2><p id="3a6b" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">客户现在可以要求他们的用户自定义字段。所以是某种<em class="mq">动态变量属性。</em> John <em class="mq">可以</em>根据需要在其users表上添加可空的新列(客户端请求用户的宠物名，John添加了一个pet_name列)。但是对他来说这听起来不可扩展，也许他错了。</p><p id="96d7" class="pw-post-body-paragraph kb kc hu kd b ke kz iv kg kh la iy kj kk ln km kn ko lo kq kr ks lp ku kv kw hn dt translated">所以，他决定创建两个新表:<code class="eh mm mn mo mp b">properties</code>和<code class="eh mm mn mo mp b">users_properties</code>。<code class="eh mm mn mo mp b">properties</code>表有两列:</p><ul class=""><li id="53a6" class="kx ky hu kd b ke kz kh la kk lb ko lc ks ld kw le lf lg lh dt translated"><strong class="kd hv">id</strong>T26】(uuid)</li><li id="661f" class="kx ky hu kd b ke li kh lj kk lk ko ll ks lm kw le lf lg lh dt translated"><strong class="kd hv">标签</strong> <em class="mq"> (varchar) </em>例如:“宠物名”</li></ul><p id="e9c6" class="pw-post-body-paragraph kb kc hu kd b ke kz iv kg kh la iy kj kk ln km kn ko lo kq kr ks lp ku kv kw hn dt translated"><code class="eh mm mn mo mp b">users_properties</code>有3列:</p><ul class=""><li id="102c" class="kx ky hu kd b ke kz kh la kk lb ko lc ks ld kw le lf lg lh dt translated"><strong class="kd hv"> user_id </strong> <em class="mq">(外键在</em> <code class="eh mm mn mo mp b"><em class="mq">users</em></code> <em class="mq">表上)</em></li><li id="29d4" class="kx ky hu kd b ke li kh lj kk lk ko ll ks lm kw le lf lg lh dt translated"><strong class="kd hv">property _ id</strong>(<em class="mq"/><code class="eh mm mn mo mp b"><em class="mq">users_properties</em></code><em class="mq">表</em>上的【外键】 )例:昵称的id</li><li id="d456" class="kx ky hu kd b ke li kh lj kk lk ko ll ks lm kw le lf lg lh dt translated"><strong class="kd hv">值</strong> <em class="mq">(呃……什么？看情况。我猜是短信吧？！)</em></li></ul><p id="33d7" class="pw-post-body-paragraph kb kc hu kd b ke kz iv kg kh la iy kj kk ln km kn ko lo kq kr ks lp ku kv kw hn dt translated">现在，每次客户请求其用户的新属性时，John的应用程序都会在<code class="eh mm mn mo mp b">properties</code>表中添加一个新条目。然后，对于每个具有自定义属性的新用户，在users_properties表中为其自己的属性添加一些行(<a class="ae mr" href="https://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model" rel="noopener ugc nofollow" target="_blank">类似EAV的</a>模式)。</p><h2 id="52da" class="ly jk hu bd jl lz ma mb jp mc md me jt kk mf mg jv ko mh mi jx ks mj mk jz ml dt translated">验尸Mary Foobar分析</h2><p id="79e2" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">这种方法似乎存在一些问题:</p><ul class=""><li id="d5aa" class="kx ky hu kd b ke kz kh la kk lb ko lc ks ld kw le lf lg lh dt translated"><strong class="kd hv">公司</strong>是可选列，大部分时间为空。现在只有一个，但是第12天呢？</li><li id="5183" class="kx ky hu kd b ke li kh lj kk lk ko ll ks lm kw le lf lg lh dt translated"><code class="eh mm mn mo mp b">drivers_biographies</code>是一对一表，这就大材小用了。</li><li id="1cb6" class="kx ky hu kd b ke li kh lj kk lk ko ll ks lm kw le lf lg lh dt translated">将用户的数据混合在两个表中是一团乱麻。为什么有些字段(<strong class="kd hv">公司</strong>，<strong class="kd hv">性别</strong>)在<code class="eh mm mn mo mp b">users</code>表中，而有些字段(<strong class="kd hv">手机</strong>，<strong class="kd hv">宠物名</strong>)在<code class="eh mm mn mo mp b">users_properties</code>表中(模式不同)？John的数据库架构可能被认为是不一致的。</li><li id="0d9a" class="kx ky hu kd b ke li kh lj kk lk ko ll ks lm kw le lf lg lh dt translated">向用户查询其属性将比平常更困难。</li><li id="0ba5" class="kx ky hu kd b ke li kh lj kk lk ko ll ks lm kw le lf lg lh dt translated">映射到对象(假设John使用这种东西)也会很复杂。</li><li id="a66b" class="kx ky hu kd b ke li kh lj kk lk ko ll ks lm kw le lf lg lh dt translated">第5天有4个表，仅用于描述用户。</li><li id="187d" class="kx ky hu kd b ke li kh lj kk lk ko ll ks lm kw le lf lg lh dt translated">在<code class="eh mm mn mo mp b">users</code>表中的每一个新列都必须是可空的:这些列是在第一次插入用户之后<strong class="kd hv">添加的，这些用户没有值。</strong></li></ul><figure class="lr ls lt lu fq lv fe ff paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="fe ff mt"><img src="../Images/1b6cdb79003816774fc927186156af49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z29Rk6YWy-jqvBO2f0WxJA.png"/></div></div><figcaption class="my mz fg fe ff na nb bd b be z ek">Quick and dirty implementation of the Bigmouth Buffalo’s Path.</figcaption></figure><p id="63fa" class="pw-post-body-paragraph kb kc hu kd b ke kz iv kg kh la iy kj kk ln km kn ko lo kq kr ks lp ku kv kw hn dt translated">也许约翰可以建造一个更好的建筑。</p><h1 id="33b4" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated">第二个场景——蓝鱼的路径</h1><figure class="lr ls lt lu fq lv fe ff paragraph-image"><div class="fe ff lq"><img src="../Images/5223a2b659769afdb3817a8e15ecfc97.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*F15O9JSsAxyDWC5Si-tjlA.png"/></div></figure><h2 id="8586" class="ly jk hu bd jl lz ma mb jp mc md me jt kk mf mg jv ko mh mi jx ks mj mk jz ml dt translated">第一天</h2><p id="080f" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">约翰很有远见。在水牛嘴的路径上，他<strong class="kd hv"> </strong>创建了一个<code class="eh mm mn mo mp b">users</code>表，表中有<strong class="kd hv"> id </strong> <em class="mq">、</em> <strong class="kd hv">电子邮件</strong>、<strong class="kd hv">密码</strong>和<strong class="kd hv">角色</strong> <em class="mq">。但是他也立即创建了一个<code class="eh mm mn mo mp b">users_properties</code>表(<a class="ae mr" href="https://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model" rel="noopener ugc nofollow" target="_blank">实体-属性-值</a>模型)，类似于<a class="ae mr" href="http://web-profile.net/wp-content/uploads/wordpress_db_schema.png" rel="noopener ugc nofollow" target="_blank"> Wordpress </a>方法。<code class="eh mm mn mo mp b">users_properties</code>是一个包含<strong class="kd hv"> user_id </strong>(用户表</em>上的<em class="mq">外键)、<strong class="kd hv"> key </strong> ( <em class="mq"> varchar)的表，例如:姓名、公司、电话等。</em>)，以及<strong class="kd hv">值</strong> ( <em class="mq">正文</em>)。</em></p><h2 id="aedc" class="ly jk hu bd jl lz ma mb jp mc md me jt kk mf mg jv ko mh mi jx ks mj mk jz ml dt translated">第二、三、四、五天</h2><p id="2e2d" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">John很放松，他不需要改变它的表模式。它的程序只是在数据库中添加新用户和他们的新属性。他创建了一个管理面板来快速添加新的属性。</p><h2 id="421c" class="ly jk hu bd jl lz ma mb jp mc md me jt kk mf mg jv ko mh mi jx ks mj mk jz ml dt translated">验尸-玛丽·福巴分析</h2><p id="4718" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">与以前的设计相比，有一个好处。解释和理解起来很简单，每个属性都位于一个唯一的表中。EAV是一个众所周知的模式，即使约翰没有听说过，他也会自己发明它。描述用户元数据的表只有两个，不会再多了。但是也有一些警告:</p><ul class=""><li id="21c0" class="kx ky hu kd b ke kz kh la kk lb ko lc ks ld kw le lf lg lh dt translated">简单的查询变得<a class="ae mr" href="http://www.antradar.com/blog-wordpress-and-the-curse-of-eav" rel="noopener ugc nofollow" target="_blank">复杂和不可读</a>，而传统的表只有一个属性列。<code class="eh mm mn mo mp b">SELECT name FROM users WHERE age=50 AND gender='f'</code>变成了:</li></ul><pre class="lr ls lt lu fq nc mp nd ne aw nf dt"><span id="c683" class="ly jk hu mp b fv ng nh l ni nj">SELECT <br/>  name.meta_value AS name, <br/>FROM <br/>  users_properties age, <br/>  users_properties name, <br/>  users_properties gender<br/>WHERE age.key = ’age’ <br/>AND age.value = ’50'<br/>AND age.user_id = name.user_id<br/>AND gender.user_id = age.user_id<br/>AND gender.key = ’gender’ and gender.value = ’f’</span></pre><ul class=""><li id="ae03" class="kx ky hu kd b ke kz kh la kk lb ko lc ks ld kw le lf lg lh dt translated">这张表用肉眼看不清楚。SQL是关于行和列的，这个模型被EAV破坏了。</li></ul><figure class="lr ls lt lu fq lv fe ff paragraph-image"><div class="fe ff nk"><img src="../Images/9e350dff85958c7d4b7d2ba32eed34b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*5bPG0UeP72LF8omxNJzoYQ.jpeg"/></div><figcaption class="my mz fg fe ff na nb bd b be z ek">Unreadable random table found on Google Images</figcaption></figure><ul class=""><li id="52cf" class="kx ky hu kd b ke kz kh la kk lb ko lc ks ld kw le lf lg lh dt translated">重复数据更难检测，没有数据类型，没有数据层次，没有一致性，<a class="ae mr" href="http://dba.stackexchange.com/a/20763/68831" rel="noopener ugc nofollow" target="_blank">等等。</a></li></ul><h1 id="d0e9" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated">第三种情况—虹鳟鱼的路径</h1><figure class="lr ls lt lu fq lv fe ff paragraph-image"><div class="fe ff lq"><img src="../Images/3ea35f12a88955cc887ea6df625243eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*AMdCyQ4L6kXiiuQYJjkQ4Q.png"/></div></figure><h2 id="afe3" class="ly jk hu bd jl lz ma mb jp mc md me jt kk mf mg jv ko mh mi jx ks mj mk jz ml dt translated">第一天</h2><p id="9378" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">和许多人一样，约翰几年前就对《NoSQL》产生了兴趣。他尝试并抛弃了MongoDB，回到了它的初恋PostgreSQL。他记得感觉无模式数据在某些情况下会有好处，特别是在可变的元数据中。所以这一次，John用<strong class="kd hv"> id </strong> <em class="mq">，</em> <strong class="kd hv">电子邮件</strong>，<strong class="kd hv">密码</strong>，<strong class="kd hv">角色</strong>，<strong class="kd hv">元数据</strong>(<em class="mq">JSONB</em>)<strong class="kd hv">created _ at</strong>和<strong class="kd hv"> updated_at </strong>创建了一个<code class="eh mm mn mo mp b">users</code>表。它的元数据列是无模式的，他可以存储这样的对象:</p><pre class="lr ls lt lu fq nc mp nd ne aw nf dt"><span id="b4aa" class="ly jk hu mp b fv ng nh l ni nj">{"phone": "+33612345678", "company": "My company", "gender": "f"}</span></pre><h2 id="e1cd" class="ly jk hu bd jl lz ma mb jp mc md me jt kk mf mg jv ko mh mi jx ks mj mk jz ml dt translated">第二、三、四、五天</h2><p id="4228" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">表模式不变。</p><h2 id="d623" class="ly jk hu bd jl lz ma mb jp mc md me jt kk mf mg jv ko mh mi jx ks mj mk jz ml dt translated">验尸-玛丽·福巴分析</h2><p id="65e7" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">与以前的路径相比，这种设计有一些好处:</p><ul class=""><li id="d662" class="kx ky hu kd b ke kz kh la kk lb ko lc ks ld kw le lf lg lh dt translated">仅用一个表来描述一个实体:用户。</li><li id="781a" class="kx ky hu kd b ke li kh lj kk lk ko ll ks lm kw le lf lg lh dt translated">查询很容易写:<code class="eh mm mn mo mp b">select * from users where metadata-&gt;'age'=50</code></li><li id="86a9" class="kx ky hu kd b ke li kh lj kk lk ko ll ks lm kw le lf lg lh dt translated">每个用户在一行中读取数据很容易(平心而论，JSON部分如果增长就有点难读了)。</li><li id="c08b" class="kx ky hu kd b ke li kh lj kk lk ko ll ks lm kw le lf lg lh dt translated">对于用户定义的字段，避免使用EAV。</li></ul><p id="aaa0" class="pw-post-body-paragraph kb kc hu kd b ke kz iv kg kh la iy kj kk ln km kn ko lo kq kr ks lp ku kv kw hn dt translated">也有一些警告:</p><ul class=""><li id="d160" class="kx ky hu kd b ke kz kh la kk lb ko lc ks ld kw le lf lg lh dt translated">John应该记得在元数据上添加一个<a class="ae mr" href="https://www.postgresql.org/docs/current/static/gin.html" rel="noopener ugc nofollow" target="_blank"> GIN索引</a>。</li><li id="d3a4" class="kx ky hu kd b ke li kh lj kk lk ko ll ks lm kw le lf lg lh dt translated">John不应该在元数据中添加关系。对于JSONB列，很容易在该列中添加所有内容。如果John添加一个新实体，他必须创建一个新表，而不是添加一个子属性，如:</li></ul><pre class="lr ls lt lu fq nc mp nd ne aw nf dt"><span id="fedc" class="ly jk hu mp b fv ng nh l ni nj">{ "bookings": [<br/>  { "id": "aaa-bb-cc", "date": "2017–01–12", "duration": "10 days"},<br/>  { "id": "xxx-yy-zz", "date": "2017–02–10", "duration": "1 day"},<br/>]}</span></pre></div><div class="ab cl nl nm hc nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="hn ho hp hq hr"><h1 id="0f8c" class="jj jk hu bd jl jm ns jo jp jq nt js jt ja nu jb jv jd nv je jx jg nw jh jz ka dt translated">最后的想法</h1><p id="a2c3" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">在我的修补职业生涯中，我按照这三条路径(不完全是，但很相似)和其他一些路径创建了<code class="eh mm mn mo mp b">users</code>表:我们可以考虑动态添加列和表，为另一个DBMS改变，等等。在过去的几个月里，我一直遵循第三条道路。我确信没有正确的方法，这条路也有许多隐藏的警告(我应该多读一些),但是对于我的日常工作来说，我可以接受。我通过删除元数据表，将一个包含60多个无用表的遗留系统迁移到了大约10个表。不确定反正是不是更好，我也不是说表越少越好，但是在这个特定的情况下，我觉得代码和数据库更容易读取、创建、更新和删除。我知道几个月后我会发现一条新的道路，并为我所做的感到羞愧。</p><ul class=""><li id="eea3" class="kx ky hu kd b ke kz kh la kk lb ko lc ks ld kw le lf lg lh dt translated">虹鳟鱼的路径对用户表来说是可以的，我不认为每次都在每个表上到处添加JSONB是个好主意。仅存储元数据可能会有所帮助。<strong class="kd hv">没有关系。</strong></li><li id="033a" class="kx ky hu kd b ke li kh lj kk lk ko ll ks lm kw le lf lg lh dt translated">我没有谈到索引，这不是问题，但请到处使用索引。</li><li id="34a2" class="kx ky hu kd b ke li kh lj kk lk ko ll ks lm kw le lf lg lh dt translated">我只谈了PostgreSQL，也许SQL不是建立用户数据库的东西。</li><li id="f0ef" class="kx ky hu kd b ke li kh lj kk lk ko ll ks lm kw le lf lg lh dt translated">我仍然很惊讶，这么多年过去了，我竟然没有找到一个明显的建立用户表的最佳方法。我错过了什么吗？</li></ul><p id="f8c7" class="pw-post-body-paragraph kb kc hu kd b ke kz iv kg kh la iy kj kk ln km kn ko lo kq kr ks lp ku kv kw hn dt translated">请随意提出建议、反馈和批评。我很乐意了解更多。</p><figure class="lr ls lt lu fq lv fe ff paragraph-image"><div class="fe ff nx"><img src="../Images/d791a2efa66b15c7110e9c66b50e00aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:248/format:webp/1*3_K1gTuaesOS_QOHHsSEPA.jpeg"/></div><figcaption class="my mz fg fe ff na nb bd b be z ek">Sorry for long post, here is a potato</figcaption></figure><div class="lr ls lt lu fq ab cb"><figure class="ny lv nz oa ob oc od paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="ny lv nz oa ob oc od paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="ny lv nz oa ob oc od paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="oe of og"><p id="f922" class="kb kc mq kd b ke kz iv kg kh la iy kj oh ln km kn oi lo kq kr oj lp ku kv kw hn dt translated"><a class="ae mr" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae mr" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae mr" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae mr" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="kb kc mq kd b ke kz iv kg kh la iy kj oh ln km kn oi lo kq kr oj lp ku kv kw hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae mr" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae mr" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lr ls lt lu fq lv fe ff paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="fe ff ok"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>