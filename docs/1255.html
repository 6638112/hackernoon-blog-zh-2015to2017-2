<html>
<head>
<title>Smart contracts: Turing completeness &amp; reality</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">智能契约:图灵完备性和现实性</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/smart-contracts-turing-completeness-reality-3eb897996621?source=collection_archive---------3-----------------------#2016-10-03">https://medium.com/hackernoon/smart-contracts-turing-completeness-reality-3eb897996621?source=collection_archive---------3-----------------------#2016-10-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="dbae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">“道”的崩溃以及最近对以太坊的DDOS攻击引发了一场关于智能契约语言中“图灵完整性”是否明智的辩论。Tezos ，一个加密账本和智能合约平台，以正式指定的语言向图灵提供完整的智能合约(具有强类型和静态类型检查)。我们试图澄清一些关于智能契约背景下“图灵完备性”相关性的误解。</p><h1 id="3808" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">该理论</h1><figure class="kp kq kr ks fq kt fe ff paragraph-image"><a href="https://en.wikipedia.org/wiki/Alan_Turing"><div class="fe ff ko"><img src="../Images/2be6b20c2670ed430720ffe1e6cb1eb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*O9zEkNTsiE-Ts8St2Qn6CQ.png"/></div></a><figcaption class="kw kx fg fe ff ky kz bd b be z ek">Alan Turing</figcaption></figure><p id="d304" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">图灵完全性是一种表明某些(通常是大多数)编程语言完全通用的属性。根据<a class="ae jp" href="https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis" rel="noopener ugc nofollow" target="_blank">丘奇-图灵命题</a>(一个有大量经验证据的物理原理)，每一个可以物理实现的计算，甚至原则上，都可以用图灵完全语言来表达和实现。</p><p id="2445" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">哪种语言并不重要。任何图灵完全语言都足够通用，可以模拟所有其他语言(尽管可能会变慢)，使它们在可以执行的计算方面等价。图灵完全语言如此普遍，以至于它们甚至出现在看似简单的系统中，如<a class="ae jp" href="https://en.wikipedia.org/wiki/Cellular_automaton" rel="noopener ugc nofollow" target="_blank">细胞自动机</a>或<a class="ae jp" href="https://en.wikipedia.org/wiki/Wang_tile" rel="noopener ugc nofollow" target="_blank">平铺系统</a>。</p><figure class="kp kq kr ks fq kt fe ff paragraph-image"><a href="https://en.wikipedia.org/wiki/Alonzo_Church"><div class="fe ff ko"><img src="../Images/efe5c96348ffde36221dcfadb09c7f37.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*fL191g4ExSZLckGuqr413Q.png"/></div></a><figcaption class="kw kx fg fe ff ky kz bd b be z ek">Alonzo Church</figcaption></figure><p id="0f50" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不幸的是，权力带来了复杂性。<a class="ae jp" href="https://en.wikipedia.org/wiki/Rice%27s_theorem" rel="noopener ugc nofollow" target="_blank">莱斯定理</a>告诉我们，原则上没有任何一个<em class="la">通用</em>程序(人或机械)可以为所有程序决定<em class="la">是否终止。事实上，它甚至不能预测他们行为的任何重要性质。</em></p><p id="28af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有人可能会得出这样的结论:既然我们无法预测这些程序会做什么，我们就应该远离这些语言。事实上，这不正是刀的情况吗？合同参与者无法预测合同的行为，灾难随之而来。</p><p id="5ad6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种误解出奇的普遍。显然，至少有一个人，即攻击者，能够预测和理解契约——事实上比它的创建者更好。</p><p id="3ed0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">赖斯定理断言，没有一个通用的程序来决定一个程序的行为属性是否成立。这些可能是诸如“这个程序是否停止”、“它是否达到一个错误条件”、“是否能够产生某个输出”之类的属性。</p><p id="b859" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个定理暗示了程序的存在，这些程序由<em class="la">做</em>终止，并且<em class="la">做</em>按预期运行，但是不能证明如此。我们无法真正知道它们是什么，但我们通过巧妙的数学论证知道它们的存在(承蒙图灵、丘奇和哥德尔的支持)。重要的是，可能有通用程序可以计算大多数程序的<em class="la">行为，而不是所有<em class="la">程序的</em>行为。</em></p><figure class="kp kq kr ks fq kt fe ff paragraph-image"><a href="https://en.wikipedia.org/wiki/Kurt_G%C3%B6del"><div class="fe ff ko"><img src="../Images/b385de224b7f1233b78365b60e6d1f87.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/0*vUjlz0XxgPmna25y.jpg"/></div></a><figcaption class="kw kx fg fe ff ky kz bd b be z ek">Kurt Gödel</figcaption></figure><p id="198c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一些语言放弃了图灵完备性，它们的程序<em class="la">可以</em>显示总是暂停。例如，比特币脚本就是这种情况。一个民间的信念似乎是赖斯定理的逆命题是正确的。也就是说，误解是:</p><p id="6db0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">“既然图灵完全语言中的停顿问题意味着我们不能预测程序的一般行为，那么，只要我们用保证终止的语言编写程序，我们就能够预测我们想要的所有有趣的特性。”</p><p id="bb40" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这不是真的，理论上不是，实践上也不是。有些语言保证程序对于所有的输入都会暂停，但是您可能无法确定任何给定的输入是否会导致程序到达错误状态。<em class="la">(对于理论上倾向于:以由单个程序f组成的语言为例，该程序检查其输入x是否是ZFC不一致性的证明。f总是停止，但是它是否返回“真”在ZFC是不可判定的)</em></p></div><div class="ab cl lb lc hc ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hn ho hp hq hr"><h1 id="678b" class="jq jr hu bd js jt li jv jw jx lj jz ka kb lk kd ke kf ll kh ki kj lm kl km kn dt translated">实践</h1><p id="d0ad" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">实际上，图灵完备性是一种理想化。具体来说，计算机的内存是有限的，在关机前只能运行有限的时间。</p><p id="9312" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Tezos(或以太坊)智能合约在时间上受到每个区块和每个交易的限制。在某种程度上，它们并不完全是图灵完备的。更好的是，由于契约执行的步骤数量是有限的，因此理论上可以预测给定程序对任何可能输入的行为。</p><p id="55bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于解析输入所花费的时间至少与输入的长度相当，所以执行中步骤数量的上限限制了契约可以读取的任何输入的最大大小。因此，下面的算法可以决定任何契约的行为:</p><pre class="kp kq kr ks fq ls lt lu lv aw lw dt"><span id="dbba" class="lx jr hu lt b fv ly lz l ma mb">for(all inputs &lt; max size) {<br/>   run program for max time;<br/>   check property;<br/>}</span></pre><p id="d0b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然，这种算法在天文学上是不切实际的。如果输入大小被限制在微不足道的千字节，宇宙中可能仍然没有足够的自由能量来进行计算。</p><p id="e1a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我在这里的观点并不是要表明我们总能证明时间受限智能合约的所有真实属性。恰恰相反，我的观点是，一般算法的存在和<em class="la">实用</em>算法的存在是截然不同的两回事。</p><p id="92c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">比特币脚本是否存在如此高效的算法？答案也是否定的！</p><p id="3d88" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">考虑下面的比特币脚本</p><pre class="kp kq kr ks fq ls lt lu lv aw lw dt"><span id="a1c9" class="lx jr hu lt b fv ly lz l ma mb">scriptPubKey: OP_HASH256 0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef OP_EQUAL</span></pre><p id="7e55" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个哈希难题，正如在<a class="ae jp" href="https://en.bitcoin.it/wiki/Script#Transaction_puzzle" rel="noopener ugc nofollow" target="_blank">比特币维基</a>上所描述的。请注意，我选择的散列显然是虚构的。该脚本明显地停止了所有的输入，但是我们可能有兴趣知道这个输出是否是可消费的。这完全取决于是否存在我创建的哈希的原像，这是绝对不清楚的。我们将不得不暴力破解哈希函数数十亿年才能找到答案。</p><p id="28bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">比特币的脚本缺乏图灵完备性并不是什么灵丹妙药。这对决定这个非常简单的脚本的基本属性没有帮助。</p></div><div class="ab cl lb lc hc ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hn ho hp hq hr"><h1 id="258a" class="jq jr hu bd js jt li jv jw jx lj jz ka kb lk kd ke kf ll kh ki kj lm kl km kn dt translated">真正重要的是</h1><p id="c9ed" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">正如我们之前说过的，莱斯定理本质上告诉我们，存在这样的程序，<em class="la">做</em>终止，<em class="la">做</em>按预期运行，但无法证明如此。</p><p id="d8eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，几乎所有感兴趣的<em class="la">正确的</em>程序本质上都是<em class="la">可证明正确的</em>。此外，他们的正确性的证明将是相对简单的。在基于加密分类帐的智能契约的上下文中尤其如此，这些分类帐通常实现简单明了的业务逻辑(当然，如果您处理的是计算代数，就不那么真实了)。</p><p id="2c8f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正确性证明可能依赖于承认某些难以证明的猜想。例如，我们可以从启发性的论证中接受哈希函数确实很难反转，并在我们的证明中将其作为引理，就像密码学论文中通常所做的那样。</p><p id="81c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但总的来说，每当程序员编写程序时，他们通常会在头脑中保留一个模糊的正确性证明大纲。有时这种证明是不完整或错误的——人是会犯错的——但它总是指导写作。程序员不断地对他们程序的行为进行推理，以确保它做了预期的事情。</p><p id="4a0b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当且仅当<a class="ae jp" href="https://en.wikipedia.org/wiki/Collatz_conjecture" rel="noopener ugc nofollow" target="_blank">柯拉茨猜想</a>为真，或者<a class="ae jp" href="https://en.wikipedia.org/wiki/Zermelo%E2%80%93Fraenkel_set_theory" rel="noopener ugc nofollow" target="_blank"> ZFC </a>不一致时，程序员不会坐在他们的办公桌前，善意地写一份互换合同，销毁其所有抵押担保品。</p><p id="83c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">是否存在一个完全通用的程序来判断用给定语言编写的任意程序是否正确并不重要。相反，重要的是如何简单明了地构造容易推理的程序。</p><p id="a69a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这方面，推断比特币脚本的行为一般来说是简单明了的。他们没有带来太多的惊喜。有没有前像t0 0x123…？也许是，也许不是，但是任何人都不可能发现，所以对于所有的意图和目的来说，这笔交易是不可消费的。</p></div><div class="ab cl lb lc hc ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hn ho hp hq hr"><h1 id="8543" class="jq jr hu bd js jt li jv jw jx lj jz ka kb lk kd ke kf ll kh ki kj lm kl km kn dt translated">权衡</h1><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div class="fe ff mc"><img src="../Images/a8223d78c65062ab5db7c2c5a20d009c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*cZcwmauW1iRdg-L9uM7ndw.png"/></div><figcaption class="kw kx fg fe ff ky kz bd b be z ek">The efficient frontier, and the new frontier created by automated theorem proving and formal verification</figcaption></figure><p id="3ce3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">编程语言存在于表达能力/推理的边界之下。</p><p id="9e4c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="la">富于表现力的</em>语言使得描述某些想要的行为变得容易。虽然原则上所有的图灵语言都可以表达相同类型的计算，但在实践中，如果语言不够完善，就很难表达某些计算。一个幽默的例子是T4语。虽然Malbolge是图灵全集，但用这种语言编写程序来做它们应该做的事情是极其困难的。</p><p id="891a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">和表现力一样，<em class="la">ease to reasoning about</em>不是二元变量。图灵完备性对于语言推理的一般可能性有着重要的理论和实践意义，但是正如我们前面看到的，它并没有说明全部情况。</p><p id="b648" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">非常有表现力的语言往往更难推理，而一些受限语言(如有限状态机)却很容易推理，但代价是缺乏表现力。幸运的是，有一种方法可以拓展这个领域:正式验证。</p><p id="ce50" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">形式验证是一门新兴的计算机科学学科，它产生可证明正确的程序。你可能会认为这是创建一个机器可检查的证明程序是正确的，虽然，通常，证明本身<em class="la">就是</em>一个程序。智能合约只有几行代码，但风险很大，这使它们成为这种技术的完美候选。</p><p id="278d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">特别是，辅助的，甚至是自动化的定理证明让程序员指定他们想要证明的属性，并让计算机完成大部分提出正确性的正式证明的繁琐工作。这对所有语言的影响并不相同。</p><p id="95dc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然一个可证明正确的程序在被编译成某个汇编时仍然是可证明正确的，但是从编译后的版本中得到证明要困难得多。这对人类来说是真的，对自动定理证明器来说也是真的。编译步骤丢弃了关于程序结构的重要信息。</p></div><div class="ab cl lb lc hc ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hn ho hp hq hr"><h1 id="715c" class="jq jr hu bd js jt li jv jw jx lj jz ka kb lk kd ke kf ll kh ki kj lm kl km kn dt translated">我们正在做什么</h1><p id="5569" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">自Tezos于2014年夏天开始以来，该项目的核心原则一直是智能合约语言是形式验证的完美目标。我们想要一种能很好地使用定理证明的语言，但也能很容易地对其本身进行推理。这导致了以下选择:</p><ol class=""><li id="31aa" class="md me hu it b iu iv iy iz jc mf jg mg jk mh jo mi mj mk ml dt translated">我们从语言的正式规范开始，精确地确定程序“T2”的意思。</li><li id="574c" class="md me hu it b iu mm iy mn jc mo jg mp jk mq jo mi mj mk ml dt translated">我们用代数数据类型和静态类型检查使语言具有强类型。类型是推理程序行为的一种强有力的方式。例如，他们可以确保我们不会错误地添加苹果和橘子，但他们可以进一步强制执行合同的某些属性。</li><li id="0326" class="md me hu it b iu mm iy mn jc mo jg mp jk mq jo mi mj mk ml dt translated">我们把语言变得高级了。参与者签订的合同不是一些混乱的程序集，而是编写合同的语言。这允许我们引入有用的高级原语，如功能图和功能集。我们的目标不是构建一些任意的代码执行引擎，而是一个适合智能合同作者需求的引擎。</li></ol><p id="d9f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所有这些属性都有助于使用自动定理证明程序来证明关于合同的事实，例如<a class="ae jp" href="https://coq.inria.fr/" rel="noopener ugc nofollow" target="_blank"> Coq证明助手</a>，但是它们也使得手动检查程序的正确性更加容易。</p></div><div class="ab cl lb lc hc ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hn ho hp hq hr"><h1 id="eef5" class="jq jr hu bd js jt li jv jw jx lj jz ka kb lk kd ke kf ll kh ki kj lm kl km kn dt translated">结论</h1><p id="9d4f" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">图灵完备性被诬陷！有些程序的性质很容易理解和证明，而有些程序的性质很难理解和证明。有一些编程语言有助于这种证明，也有一些模糊了这种证明。这是关于权衡，而不是关于停顿问题的一些亮点。</p><div class="kp kq kr ks fq ab cb"><figure class="mr kt ms mt mu mv mw paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mr kt ms mt mu mv mw paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mr kt ms mt mu mv mw paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mx my mz"><p id="f922" class="ir is la it b iu iv iw ix iy iz ja jb na jd je jf nb jh ji jj nc jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is la it b iu iv iw ix iy iz ja jb na jd je jf nb jh ji jj nc jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kp kq kr ks fq kt fe ff paragraph-image"><a href="https://goo.gl/Ahtev1"><div class="fe ff nd"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></a></figure></div></div>    
</body>
</html>