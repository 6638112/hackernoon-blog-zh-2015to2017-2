<html>
<head>
<title>Things you can’t do in Rust: copy closures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust中不能做的事情:复制闭包</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/things-you-cant-do-in-rust-copy-closures-79d2c0586da?source=collection_archive---------29-----------------------#2017-12-04">https://medium.com/hackernoon/things-you-cant-do-in-rust-copy-closures-79d2c0586da?source=collection_archive---------29-----------------------#2017-12-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="868f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我爱Rust，希望它更好。开发团队知道提出的所有问题。我只是想引发讨论和热情，让一门好的语言变得更好。</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="5ec6" class="jy jz hu ju b fv ka kb l kc kd">fn main() {<br/>   // Many closures can now be passed by-value to multiple functions:<br/>   fn call&lt;F: FnOnce()&gt;(f: F) { f() }<br/>   let hello = || println!("Hello, world!");<br/>   call(hello);<br/>   call(hello);</span><span id="7bfc" class="jy jz hu ju b fv ke kb l kc kd">   // Many `Iterator` combinators are now `Copy`/`Clone`:<br/>   let x = (1..100).map(|x| x * 5);<br/>   let y = x.map(|x| x - 3); // moves `x` by `Copy`ing<br/>   let _ = x.chain(y); // moves `x` again<br/>   let _ = x.cycle(); // `.cycle()` is only possible when `Self: Clone`</span><span id="7f46" class="jy jz hu ju b fv ke kb l kc kd">   // Closures which reference data mutably are not `Copy`/`Clone`:<br/>   let mut x = 0;<br/>   let incr_x = || x += 1;<br/>   call(incr_x);<br/>   call(incr_x); // ERROR: `incr_x` moved in the call above.</span><span id="bcc0" class="jy jz hu ju b fv ke kb l kc kd">   // `move` closures implement `Clone`/`Copy` if the values they capture<br/>   // implement `Clone`/`Copy`:<br/>   let mut x = 0;<br/>   let print_incr = move || { println!("{}", x); x += 1; };</span><span id="874c" class="jy jz hu ju b fv ke kb l kc kd">   fn call_three_times&lt;F: FnMut()&gt;(mut f: F) {<br/>      for i in 0..3 {<br/>         f();<br/>      }<br/>   }<br/>   call_three_times(print_incr); // prints "0", "1", "2"<br/>   call_three_times(print_incr); // prints "0", "1", "2"<br/>}</span></pre><p id="21ad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">结果(编译时错误):</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="bda0" class="jy jz hu ju b fv ka kb l kc kd"><strong class="ju hv">error[E0277]: the trait bound `[closure@a.ru:9:24: 9:33]: std::clone::Clone` is not satisfied<br/>   |<br/>12</strong> <strong class="ju hv">| </strong>  let _ = x.cycle(); // `.cycle()` is only possible when `Self: Clone`<br/>   <strong class="ju hv">| </strong>            <strong class="ju hv">^^^^^</strong> <strong class="ju hv">the trait `std::clone::Clone` is not implemented for `[closure@a.ru:9:24: 9:33]`<br/>   |<br/>   = note</strong>: required because of the requirements on the impl of `std::clone::Clone` for `std::iter::Map&lt;std::ops::Range&lt;{integer}&gt;, [closure@a.ru:9:24: 9:33]&gt;`</span><span id="ab90" class="jy jz hu ju b fv ke kb l kc kd"><strong class="ju hv">error: aborting due to previous error(s)</strong></span></pre><p id="fbb9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">公平地说，这个特性已经部分实现了。要实现Copy，编译器需要注意生存期和可变性，所以这不是一个简单的添加特性。到目前为止，已经介绍了许多常见的情况，但是正如RFC (2132)示例所示，还有很长的路要走。目前，这是闭包的又一个缺陷。</p></div></div>    
</body>
</html>