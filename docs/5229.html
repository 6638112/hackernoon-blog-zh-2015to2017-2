<html>
<head>
<title>Strace in 60 lines of Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">60行围棋中的Strace</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/strace-in-60-lines-of-go-b4b76e3ecd64?source=collection_archive---------7-----------------------#2017-07-17">https://medium.com/hackernoon/strace-in-60-lines-of-go-b4b76e3ecd64?source=collection_archive---------7-----------------------#2017-07-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="051b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">这篇文章是我在</em> <a class="ae jq" href="https://gophercon.com/speakers/27" rel="noopener ugc nofollow" target="_blank"> <em class="jp"> GopherCon talk期间写的一篇简单的</em> <a class="ae jq" href="http://github.com/lizrice/strace-from-scratch" rel="noopener ugc nofollow" target="_blank"> <em class="jp"> strace实现</em> </a> <em class="jp">的演练，一篇关于Syscalls </em> </a> <em class="jp">的Go程序员指南。你会在这里找到</em><a class="ae jq" href="http://github.com/lizrice/strace-from-scratch" rel="noopener ugc nofollow" target="_blank"><em class="jp"/></a><em class="jp">的代号。</em></p><p id="c70a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了探索Linux ptrace syscall的一些特性，我认为编写自己的基本strace的实现会很有趣——这个工具显示一个可执行文件使用了哪个syscall。这篇文章简要分析了这个程序是如何工作的。如果您有时间的话，我们将在讲座中介绍更多细节和精彩内容:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="jw jx l"/></div></figure><h1 id="0d4a" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">对子进程设置断点</h1><p id="7af9" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">我们的程序将捕获我们传入的任意命令发出的所有系统调用。它使用<code class="eh lb lc ld le b">exec.Command()</code>来设置子进程将要运行的任何命令，并且我们通过在命令的<code class="eh lb lc ld le b">SysProcAttr</code>结构中设置<code class="eh lb lc ld le b">Ptrace</code>为真来指定我们想要在这个子进程上使用ptrace。下面是来自<code class="eh lb lc ld le b">main()</code>函数的这段代码:</p><pre class="jr js jt ju fq lf le lg lh aw li dt"><span id="e886" class="lj jz hu le b fv lk ll l lm ln">fmt.Printf("Run %v\n", os.Args[1:])</span><span id="4347" class="lj jz hu le b fv lo ll l lm ln">cmd := exec.Command(os.Args[1], os.Args[2:]...)<br/>cmd.Stderr = os.Stderr<br/>cmd.Stdin = os.Stdin<br/>cmd.Stdout = os.Stdout<br/>cmd.SysProcAttr = &amp;syscall.SysProcAttr{<br/>    Ptrace: true,<br/>}</span><span id="b06b" class="lj jz hu le b fv lo ll l lm ln">cmd.Start()<br/>err := cmd.Wait()<br/>if err != nil {<br/>    fmt.Printf("Wait returned: %v\n", err)<br/>}</span></pre><p id="0b7a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这使得子进程在创建后立即进入断点状态。如果我们在<code class="eh lb lc ld le b">main()</code>中运行这段代码，我们可以看到<code class="eh lb lc ld le b">cmd.Wait()</code>返回一个非零错误:</p><pre class="jr js jt ju fq lf le lg lh aw li dt"><span id="0d92" class="lj jz hu le b fv lk ll l lm ln">root@vm-ubuntu:myStrace# ./myStrace echo hello<br/>Run [echo hello]<br/>Wait returned: stop signal: trace/breakpoint trap<br/>root@vm-ubuntu:myStrace# hello</span></pre><p id="7fe7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还可以看到<em class="jp"> hello </em>文本输出也被打印出来，这乍一看似乎很奇怪，因为我们刚刚将子进程(它执行打印)置于断点状态。如果您在<code class="eh lb lc ld le b">cmd.Wait()</code>之后插入一个小的延迟，您将会看到这不会发生，直到父进程完成。这里发生的事情是，父进程将子进程保持在断点状态，但是当父进程退出时，就没有什么可以再阻止子进程了——所以子进程继续它将要做的事情，并显示<em class="jp"> hello </em>。</p><h1 id="11d4" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">从子进程的寄存器中获取当前的系统调用</h1><p id="e47d" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">下一步是找到子进程寄存器的当前值(其进程ID可以在<code class="eh lb lc ld le b">cmd.Process.Pid</code>中找到)。这是通过PTRACE的PTRACE_GETREGS子命令完成的。Go <a class="ae jq" href="https://golang.org/pkg/syscall/" rel="noopener ugc nofollow" target="_blank"> syscall包</a>为我们提供了几个函数，使得调用各种Ptrace子命令变得容易，包括这个。</p><pre class="jr js jt ju fq lf le lg lh aw li dt"><span id="bc0b" class="lj jz hu le b fv lk ll l lm ln">pid = cmd.Process.Pid<br/>err = syscall.PtraceGetRegs(pid, &amp;regs)</span></pre><p id="a3d7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将返回一个结构，显示子进程所有寄存器的当前值。在x86 CPU(我的MacBook Pro有)上，syscall标识符在<code class="eh lb lc ld le b">Orig_rax</code>字段中找到。(<code class="eh lb lc ld le b">sec</code>是我给<code class="eh lb lc ld le b">seccomp/libseccomp-golang</code>包的导入别名。)</p><pre class="jr js jt ju fq lf le lg lh aw li dt"><span id="54c0" class="lj jz hu le b fv lk ll l lm ln">name, _ := sec.ScmpSyscall(regs.Orig_rax).GetName()<br/>fmt.Printf("%s\n", name)</span></pre><h1 id="30b2" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">运行到下一个系统调用</h1><p id="0e44" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">我们现在希望允许子进程继续运行，直到它遇到下一个系统调用。PTRACE_SYSCALL子命令就是这样做的，Go syscall包给了我们一个<a class="ae jq" href="https://golang.org/pkg/syscall/#PtraceSyscall" rel="noopener ugc nofollow" target="_blank">函数</a>来用这个子命令调用SYS_PTRACE。</p><pre class="jr js jt ju fq lf le lg lh aw li dt"><span id="50f3" class="lj jz hu le b fv lk ll l lm ln">err = syscall.PtraceSyscall(pid, 0)</span></pre><p id="af89" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当这种情况发生时，我们会得到一个信号陷阱，我们需要等待。</p><pre class="jr js jt ju fq lf le lg lh aw li dt"><span id="440a" class="lj jz hu le b fv lk ll l lm ln">_, err = syscall.Wait4(pid, nil, 0, nil)</span></pre><h1 id="16d1" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">并重复</h1><p id="ad10" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">在这一阶段，我们希望再次读取寄存器以获取syscall标识符，之后我们希望子进程运行到下一个syscall，依此类推——因此我们可以简单地在整个进程周围添加一个for循环。</p><p id="6810" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当子进程完成时，我们需要停止这个循环。在我的简单实现中，当PtraceGetRegs失败时，我简单地退出for循环。(我们看到的错误是，它试图读取不存在的进程的寄存器——这在子进程已经完成时是有意义的。)</p><h1 id="717a" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">然而</h1><p id="3d0a" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">运行这段代码将生成一个系统调用列表，但是只有一个问题:每个系统调用都输出两次。这是因为PTRACE_SYSCALL实际上在SYSCALL运行之前和完成之后都会停止子进程。下面是手册页中的相关描述:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="fe ff lp"><img src="../Images/e3a8c17ae83dc5a21bc3569019368c82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S_ziYnlCu8GXW0aCp30fhA.png"/></div></div></figure><p id="33ce" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我添加了一个名为<code class="eh lb lc ld le b">exit</code>的布尔值来跟踪它是退出还是进入，并在每次for循环中简单地翻转它的状态。我只计算退出时的系统调用。这里是循环，包括跟踪出口。</p><pre class="jr js jt ju fq lf le lg lh aw li dt"><span id="bcfb" class="lj jz hu le b fv lk ll l lm ln">for {<br/>    if exit {<br/>        err = syscall.PtraceGetRegs(pid, &amp;regs)<br/>        if err != nil {<br/>            break<br/>        }</span><span id="aa35" class="lj jz hu le b fv lo ll l lm ln">        name, _ := sec.ScmpSyscall(regs.Orig_rax).GetName()<br/>        fmt.Printf("%s\n", name)<br/>    }</span><span id="4ead" class="lj jz hu le b fv lo ll l lm ln">    err = syscall.PtraceSyscall(pid, 0)<br/>    if err != nil {<br/>        panic(err)<br/>    }</span><span id="0082" class="lj jz hu le b fv lo ll l lm ln">    _, err = syscall.Wait4(pid, nil, 0, nil)<br/>    if err != nil {<br/>        panic(err)<br/>    }</span><span id="5440" class="lj jz hu le b fv lo ll l lm ln">    exit = !exit<br/>}</span></pre><h1 id="ac64" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">汇总系统调用</h1><p id="45ce" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">我编写了一些<a class="ae jq" href="https://github.com/lizrice/strace-from-scratch/blob/master/syscallcounter.go" rel="noopener ugc nofollow" target="_blank">实用程序代码</a>来记录每个syscall代码被使用的次数，并打印出摘要。</p><h1 id="50a4" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">好了</h1><p id="bf80" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">如果你试一试，你会发现它给出的东西与<code class="eh lb lc ld le b">strace</code>给我们的东西是一致的。这里有一个很短的演示，展示了我们在<code class="eh lb lc ld le b">echo hello</code>上使用这段代码时的输出，以及<code class="eh lb lc ld le b">strace -c</code>的输出。您将会看到它们为每个系统调用显示了相同的计数。</p><div class="lw lx fm fo ly lz"><a href="https://asciinema.org/a/TcEvXJvxXS6YyzCtowWpOfq6z" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab ej"><div class="mb ab mc cl cj md"><h2 class="bd hv fv z el me eo ep mf er et ht dt translated">从头开始演示</h2><div class="mg l"><h3 class="bd b fv z el me eo ep mf er et ek translated">https://github.com/lizrice/strace-from-scratch</h3></div><div class="mh l"><p class="bd b gc z el me eo ep mf er et ek translated">asciinema.org</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn lu lz"/></div></div></a></div><p id="b258" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">完整的实现还显示了每个系统调用的参数。如果你想构建我们的简单版本来做这件事，我们可以<a class="ae jq" href="http://syscalls.kernelgrok.com/" rel="noopener ugc nofollow" target="_blank">从其他寄存器</a>映射它们。</p></div><div class="ab cl mo mp hc mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hn ho hp hq hr"><p id="55f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在演讲中，我继续演示了如何使用<a class="ae jq" href="http://blog.aquasec.com/new-docker-security-features-and-what-they-mean-seccomp-profiles" rel="noopener ugc nofollow" target="_blank"> seccomp安全模块来阻止特定的系统调用</a>。您可以通过取消对<code class="eh lb lc ld le b">disallow()</code>调用的注释来亲自尝试一下。这实际上只是让您了解一下使用seccomp过滤器时会发生什么——我不建议每个人都开始在生产应用程序中手工编写代码来确定他们可以调用哪些系统调用！如果你喜欢自我沙箱化应用的想法，你应该<a class="ae jq" href="https://www.google.co.uk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwitiNyuipDVAhXrAMAKHYl5BqMQtwIIKzAA&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DBuFTHOgsgAY&amp;usg=AFQjCNEvLzasIbNnh-u61pkQJtH6rssj7Q" rel="noopener ugc nofollow" target="_blank">看看Jessie Frazelle </a>的演讲。</p></div><div class="ab cl mo mp hc mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hn ho hp hq hr"><p id="21d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">大量感谢</em><a class="mv mw gr" href="https://medium.com/u/92606ca29d25?source=post_page-----b4b76e3ecd64--------------------------------" rel="noopener" target="_blank"><em class="jp">@ nelhage</em></a><em class="jp"/><a class="ae jq" href="https://blog.nelhage.com/2010/08/write-yourself-an-strace-in-70-lines-of-code/" rel="noopener ugc nofollow" target="_blank"><em class="jp">C中strace的实现</em> </a> <em class="jp">和</em><a class="mv mw gr" href="https://medium.com/u/5b90d60d16b7?source=post_page-----b4b76e3ecd64--------------------------------" rel="noopener" target="_blank"><em class="jp">micha zowicki</em></a><em class="jp"/><a class="ae jq" rel="noopener" href="/golangspec/making-debugger-for-golang-part-i-53124284b7c8"><em class="jp">深</em> </a> <em class="jp"> </em> <a class="ae jq" rel="noopener" href="/golangspec/making-debugger-in-golang-part-ii-d2b8eb2f19e0"> <em class="jp">潜</em></a></p><figure class="jr js jt ju fq jv fe ff paragraph-image"><a href="http://aquasec.com"><div class="fe ff mx"><img src="../Images/e0bb5d33fb79cccb8e33e4f791aff982.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*dwt1cP8cW1b3_SKkmbWNkw.png"/></div></a></figure></div></div>    
</body>
</html>