<html>
<head>
<title>Negative Zero</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">负零</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/negative-zero-bbd5fd790af3?source=collection_archive---------6-----------------------#2017-11-17">https://medium.com/hackernoon/negative-zero-bbd5fd790af3?source=collection_archive---------6-----------------------#2017-11-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="10ee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每当我妻子想证明我迂腐时，她都会提起下面这个故事:当我的一个女儿上二年级时，她的数学老师告诉全班，任何数除以零都是一。我给老师发了一封充满激情的电子邮件，坚持说结果必须是不确定的。据说这是我有时难以相处的证据。</p><p id="5a01" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">原来玩笑可能开在我身上——虽然还是很难支持二年级老师的回答。我最近学到了一堆我不知道的浮点数学知识:</p><ul class=""><li id="4674" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx dt translated">负零有一个值，与常规(正？)零。这两个零被定义为彼此相等，但它们是不同的值。</li><li id="86bd" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">x ÷ 0.0，对于x ≠ 0.0，不算误差。相反，按照通常的符号约定，结果要么是正无穷大，要么是负无穷大。</li><li id="2722" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">0.0 ÷ 0.0的情况是错误的(具体来说就是“不是数字”或者NaN)。</li><li id="18f2" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">–0.0+–0.0 =–0.0，–0.0+0.0 = 0.0，以及–0.0×0.0 =–0.0</li></ul><p id="cc6a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些规则源于IEEE 754“浮点运算标准”，它标准化了跨平台的浮点表示。该标准的最新版本是在2008年完成的，但原始版本是在1985年发布的，因此这种行为并不新鲜。上述规则在我的Mac上的C (gcc)和Swift中都适用，在iPhone上的Swift中也适用。Mac上的Python支持浮点数的负零，但是当你试图用任何符号的零除时会抛出一个异常。</p><p id="1961" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些规则有几个令人惊讶的推论:</p><ul class=""><li id="1742" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx dt translated">因为0.0和-0.0的比较结果必须相等，所以测试(x &lt; 0.0)不会对每个负数都返回true它对负零失败。因此，要确定零值的符号，您需要使用平台的内置符号函数，例如Swift中的Double.sign。或者我想你可以对double的原始表示进行位操作，这是一个非常适合C程序员的答案。</li><li id="f2db" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">如果a = b ÷ c，并不一定得出b = a × c，因为这也不适用于c的符号为零的情况。</li></ul><p id="f813" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我不是数字理论家，但我发现上面的概念令人惊讶。</p><p id="4be6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个迫在眉睫的问题是:无穷大不是一个数字，像零或3.25或π。相反，无限是一个概念。的确，有理数是可数无穷的——但是无穷不是有理数集合中的一员。</p><p id="9df4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，从数论的角度来看，被零除是没有意义的。如果你能准确理解除法的意思，你就能理解为什么了。从技术上讲，“除法”是“乘以一个数的倒数”，其中倒数满足:a × a^-1 = 1。零是实数集合中唯一没有乘法倒数的数。因为这个逆不存在，我们不能到处乘以它。</p><p id="e3c6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是设计浮点数的人肯定都知道这些。所以，我想知道<em class="ke">为什么</em>所描述的行为会被写入IEEE标准。</p><p id="2f61" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，让我们考虑浮点数学试图解决的问题。实数是不可计数的无穷大，然而我们希望在有限的计算机内存范围内表示整个集合。对于64位double，存在2^64可能符号，IEEE标准的设计者试图将这些符号映射到实数集上，这种方式既有利于现实世界的应用，又在80年代早期硅的限制下经济可行。给定基本要求，显然要使用近似值。</p><p id="ec43" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">负零的推理似乎可以追溯到威廉·卡汉1987年的一篇论文[1]，他是伯克利的教授，被认为是“浮点之父”，后来因起草IEEE 754而获得图灵奖。事实证明，负零的存在与除以零的能力密切相关。</p><p id="b0fe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们从讨论不允许被零除的通常原因开始。除以零的一个简单方法是观察到:</p><figure class="kg kh ki kj fq kk fe ff paragraph-image"><div class="fe ff kf"><img src="../Images/c18bb17d1881450e9284afc585e17a48.png" data-original-src="https://miro.medium.com/v2/resize:fit:314/format:webp/0*CS27oLDK6kCdKLhQ.png"/></div></figure><p id="f952" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">换句话说，随着x变小，1/x的结果变大。但这只在x从正方向接近0时才成立(这就是为什么上面有一个小加号)。从负面进行同样的思考实验:</p><figure class="kg kh ki kj fq kk fe ff paragraph-image"><div class="fe ff kn"><img src="../Images/e31c333d92d23c91bc81d599c20dc29c.png" data-original-src="https://miro.medium.com/v2/resize:fit:318/format:webp/0*G2IL-J4uMaGQ51hl.png"/></div></figure><p id="d062" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">结果，当x接近0时，1/x的一般极限是未定义的，因为在函数1/x中有一个不连续点(卡汉称之为<em class="ke">狭缝</em>)</p><p id="acfd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，通过引入一个带符号的零，Kahan和IEEE委员会可以解决这个难题。直观上，零的符号被用来表示接近极限的方向。正如卡汉在他1987年的论文中所说:</p><blockquote class="ko kp kq"><p id="2282" class="ir is ke it b iu iv iw ix iy iz ja jb kr jd je jf ks jh ji jj kt jl jm jn jo hn dt translated">不要把+0和-0看作截然不同的数值，而要把它们的符号位看作是一个辅助变量，它传达了关于任何取0为值的数值变量的一位信息(或错误信息)。通常这些信息是不相关的；对于x := +0和x := -0，3+x的值没有什么不同。然而，一些特殊的算术运算<em class="hu">受到零符号的影响；例如1/ (+0) = +∞，但1/(–0)=–∞。</em></p></blockquote><p id="2785" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我已经接受了我的合作伙伴迈克·帕金斯提出的合理化建议:2^64可用符号显然不足以代表一组实数的整体。因此，IEEE的设计者们将这些符号中的一部分保留下来，以表示特殊的含义。从这个意义上说，∞并不真正意味着“无穷大”，相反，它意味着“一个比我们在浮点符号集中所能表示的要大的实数。”因此+0实际上并不意味着“零”，而是“一个大于真0但小于我们所能表示的任何正数的实数。”</p><p id="8a5c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">顺便提一下，在研究这个问题时，我发现即使是卡汉也不喜欢负零的想法:</p><blockquote class="ko kp kq"><p id="a78e" class="ir is ke it b iu iv iw ix iy iz ja jb kr jd je jf ks jh ji jj kt jl jm jn jo hn dt translated">有符号的零——好吧，有符号的零是一个棘手的问题，如果我们使用投影模式，就可以消除它。如果只有一个无穷大和一个零，你可以做得很好；那么你不关心零的符号，也不关心无穷大的符号。但是另一方面，如果你坚持我认为是两个无穷大中较小的一个，那么你将会得到两个有符号的零。真的没有办法绕过这一点，你被它卡住了。”(摘自<a class="ae kd" href="http://history.siam.org/pdfs2/Kahan_final.pdf" rel="noopener ugc nofollow" target="_blank">2005年对卡汉的一次采访</a>。)</p></blockquote><p id="b598" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我不确定十年后写博客是否能弥补对一个可怜的二年级老师的指责。对我女儿来说，当我在晚餐上开始谈论被零除的时候，她只是翻了翻白眼。所以也许“难以相处”是遗传的。</p><p id="8083" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">[1] Kahan，w .，“复杂初等函数的分支切割，或无事生非的符号位”，<em class="ke">《数值分析的最新发展水平</em>，(Eds .Iserles and Powell)，牛津克拉伦登出版社，1987年，这里有<a class="ae kd" href="https://people.freebsd.org/~das/kahan86branch.pdf" rel="noopener ugc nofollow" target="_blank">的</a>。</p></div></div>    
</body>
</html>