<html>
<head>
<title>Introducing Mythril: A framework for bug hunting on the Ethereum blockchain</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">介绍Mythril:以太坊区块链上的bug搜索框架</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/introducing-mythril-a-framework-for-bug-hunting-on-the-ethereum-blockchain-9dc5588f82f6?source=collection_archive---------3-----------------------#2017-10-09">https://medium.com/hackernoon/introducing-mythril-a-framework-for-bug-hunting-on-the-ethereum-blockchain-9dc5588f82f6?source=collection_archive---------3-----------------------#2017-10-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="cc1d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">注:这是古代的一篇文章。有关Mythril的最新介绍，请改为阅读</em> <a class="ae jq" href="https://hackernoon.com/practical-smart-contract-security-analysis-and-exploitation-part-1-6c2f2320b0c" rel="noopener ugc nofollow" target="_blank"> <em class="jp">这篇文章</em> </a> <em class="jp">。</em></p><p id="5a05" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除非你在过去三年一直生活在岩石下，否则你肯定会注意到一个让“机器学习”大受欢迎的行业流行语:<em class="jp">区块链</em>。</p><p id="7a8e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以太坊是这个概念最成功的实现之一。与提供有限脚本功能的比特币相反，以太坊提供了一个图灵完全虚拟机。网络中的状态转换(例如特定令牌的帐户余额的变化)由虚拟机中运行的代码来管理，也称为“智能合约”。</p><p id="3054" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一句古老的安全谚语说:“灵活性越大，潜在的漏洞也越多”。更糟糕的是，以太坊最流行的高级编程语言Solidity的语义往往是反直觉的，这为开发人员创造了许多搞砸的可能性。这方面的一个很好的例子是<a class="ae jq" href="http://hackingdistributed.com/2017/07/22/deep-dive-parity-bug/" rel="noopener ugc nofollow" target="_blank">奇偶多签名钱包漏洞</a>，它允许一个未知的攻击者<a class="ae jq" rel="noopener" href="/@rtaylor30/how-i-snatched-your-153-037-eth-after-a-bad-tinder-date-d1d84422a50b">在他们的tinder日期被证明是一个真正的蠕变之后提取153，037乙醚(价值超过3000万美元)</a>。</p><p id="3390" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">奇偶校验失败表明，实现错误可以在数月内不被发现，即使当契约被部署在mainnet上并且其源代码可以公开获得。人们只能猜测链上部署的数千个合同中可能隐藏着什么样的漏洞，其中许多是黑盒(从源代码没有在<a class="ae jq" rel="noopener" href="/@rtaylor30/how-i-snatched-your-153-037-eth-after-a-bad-tinder-date-d1d84422a50b"> Etherscan </a>上发布的意义上来说)。</p><p id="ce0e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不足为奇的是，如此丰富的潜在漏洞来源和金钱回报并没有逃过“白帽”和“黑帽”安全人员的注意。这是<em class="jp">为了乐趣和利益</em>而砸栈*的又一次——只是这次有真正的利益(*注意，EVM不仅有栈，它也没有寄存器，所以几乎每个指令都使用栈)。</p><p id="8854" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我几周前开始研究以太坊时，我在mainnet上发现了不少分析合同的有用工具。<a class="ae jq" href="http://therscan and remix allow researchers to conveniently disassemble and debug contracts in the web browser." rel="noopener ugc nofollow" target="_blank"> Etherscan </a>和<a class="ae jq" href="https://remix.ethereum.org/" rel="noopener ugc nofollow" target="_blank"> remix </a>允许研究人员在网络浏览器中方便地浏览、分解和调试合同。<a class="ae jq" href="https://github.com/comaeio/porosity" rel="noopener ugc nofollow" target="_blank">孔隙度反编译器</a>可以(在一定程度上)从给定的字节码中恢复源代码。<a class="ae jq" href="https://github.com/trufflesuite/truffle" rel="noopener ugc nofollow" target="_blank"> Truffle </a>和<a class="ae jq" href="https://github.com/ethereumjs/testrpc" rel="noopener ugc nofollow" target="_blank"> testrpc </a>让Solidity代码的编译和调试变得简单。</p><p id="9d01" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，我也发现有很多事情我不能高效地完成:最明显的是，在区块链中搜索有趣的合同，用Python编写静态/动态分析脚本(我还没有完全赶上用JavaScript做所有事情的火车)。因此，我开始编写一些Python模块和命令行工具。最重要的是，我把这个东西打磨到了其他人可以使用的程度。结果是<a class="ae jq" href="https://github.com/ConsenSys/mythril" rel="noopener ugc nofollow" target="_blank"> Mythril </a>，一个以太坊反汇编器/区块链探索&amp;分析工具。下面是一个简短的教程。</p><h1 id="30e9" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated">设置</h1><p id="daef" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">最初，我希望运行<a class="ae jq" href="https://github.com/ethereum/pyethapp" rel="noopener ugc nofollow" target="_blank"> PyEthApp </a>并直接访问其LevelDB中的状态。不幸的是，PyEthApp似乎在相当长的一段时间内缺乏维护和开发，并且与以太坊主网不同步。因此，Mythril需要RPC访问一个完全连接的<a class="ae jq" href="https://github.com/ethereum/go-ethereum" rel="noopener ugc nofollow" target="_blank"> go-ethereum </a>节点。<a class="ae jq" href="https://geth.ethereum.org/install/" rel="noopener ugc nofollow" target="_blank">安装go-ethereum </a>并按如下方式启动节点:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="b0da" class="ld js hu kz b fv le lf l lg lh">$ geth --rpc --rpcapi eth,debug --syncmode fast console 2&gt;/dev/null</span></pre><p id="c95f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，Mythril使用了<a class="ae jq" href="https://github.com/ethereum/go-ethereum/wiki/Management-APIs" rel="noopener ugc nofollow" target="_blank">非标准的go-ethereum调试API</a>，因此，虽然它应该可以与其他ethereum客户端一起工作，但有些功能将不可用。</p><p id="4ee6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Mythril本身可以通过Pypi安装:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="6d61" class="ld js hu kz b fv le lf l lg lh">$ pip install mythril</span></pre><p id="1bb2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将安装Python模块和<code class="eh li lj lk kz b">myth</code>命令行工具。</p><h2 id="9ca9" class="ld js hu bd jt ll lm ln jx lo lp lq kb jc lr ls kf jg lt lu kj jk lv lw kn lx dt translated">数据库初始化</h2><p id="d3ed" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">Mythril可以在几分钟内而不是几天内实现搜索操作，就像传奇的“Mitch Brenner”博客文章中描述的那样。为此，它创建了部署在mainnet上的契约的快照。运行以下命令初始化数据库:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="8d32" class="ld js hu kz b fv le lf l lg lh">$ myth --init-db</span></pre><p id="676f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">整个过程需要一些时间(老实说效率不是很高，我希望在某个时候提供一个更好的实现)。如果您不想立即同步整个链，您可以在任何时候点击<code class="eh li lj lk kz b"> ctrl+c</code>，并且同步将在您下次使用<code class="eh li lj lk kz b">--init-db</code>标志运行mythril时自动恢复。</p><h1 id="928a" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated">命令行用法</h1><p id="9461" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">一旦数据库中有了一些契约，就可以运行搜索命令来查找函数签名和操作码序列。表达式语法如下:</p><ul class=""><li id="8a59" class="ly lz hu it b iu iv iy iz jc ma jg mb jk mc jo md me mf mg dt translated">func #[函数签名]#</li><li id="26c6" class="ly lz hu it b iu mh iy mi jc mj jg mk jk ml jo md me mf mg dt translated">代码#[操作码]#</li></ul><p id="31b1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，下面的命令将输出具有名为<code class="eh li lj lk kz b">changeMultisig(address)</code>的函数的所有合同:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="6e56" class="ld js hu kz b fv le lf l lg lh">$ myth --search “func#changeMultisig(address)#”<br/>Matched contract with code hash 2bfa6e34330ac57501bd0f6c84d50fcd<br/>Address: 0x3665f2bf19ee5e207645f3e635bf0f4961d661c0, balance: 4999600000000000000<br/>Matched contract with code hash 98623854d849f0d97c55b98e0238eb7b<br/>Address: 0x2d36cb89a977209703c1d6304f23198c22b7a498, balance: 63686800960937000000</span></pre><p id="6292" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">搜索功能支持简单的布尔表达式。上面的命令打印所有包含名为<code class="eh li lj lk kz b">changeMultisig(address)</code>的函数和操作码序列<code class="eh li lj lk kz b">PUSH1 0x50, POP</code>的契约:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="1639" class="ld js hu kz b fv le lf l lg lh">$ myth --search “func#changeMultisig(address)# and code#PUSH1 0x50,POP#”</span></pre><h2 id="753d" class="ld js hu bd jt ll lm ln jx lo lp lq kb jc lr ls kf jg lt lu kj jk lv lw kn lx dt translated">反汇编程序</h2><p id="2624" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">用<code class="eh li lj lk kz b">-d</code>标志调用反汇编程序。它要么通过<code class="eh li lj lk kz b">-c</code>参数接受一个字节码字符串，要么通过<code class="eh li lj lk kz b">-a ADDRESS</code>接受一个契约地址(这将从您的以太坊节点下载契约代码)。</p><p id="dc97" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Mythril试图使用一个内置的签名文件来解析函数名，该文件最初是从<a class="ae jq" href="https://www.4byte.directory" rel="noopener ugc nofollow" target="_blank">以太坊签名数据库</a>中获得的。如果您最终使用Mythril，非常欢迎您使用<a class="ae jq" href="https://github.com/b-mueller/mythril/edit/master/mythril/disassembler/signatures.json" rel="noopener ugc nofollow" target="_blank">提交对文件</a>的更新。</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="103b" class="ld js hu kz b fv le lf l lg lh">$ myth -d -a 0x2d36cb89a977209703c1d6304f23198c22b7a498<br/>0 PUSH1 0x60<br/>2 PUSH1 0x40<br/>4 MSTORE<br/>(…)<br/>212 — FUNCTION changeMultisig(address) -<br/>213 CALLVALUE<br/>214 ISZERO</span></pre><h2 id="ee0f" class="ld js hu bd jt ll lm ln jx lo lp lq kb jc lr ls kf jg lt lu kj jk lv lw kn lx dt translated">调用图</h2><p id="5422" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">Mythril的“杀手级特性”之一是调用图生成器。添加参数<code class="eh li lj lk kz b">-g OUTPUT_FILE</code>将导致Mythril以HTML格式保存图表:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="5319" class="ld js hu kz b fv le lf l lg lh">myth -g ~/Desktop/graph.html -a 0x2d36cb89a977209703c1d6304f23198c22b7a498</span></pre><p id="b08f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在web浏览器中打开结果文件以查看图表。通常，您可以很好地了解可用的执行路径(幸运的是，智能契约并不那么复杂)。</p><figure class="ku kv kw kx fq mn fe ff paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="fe ff mm"><img src="../Images/c814298fbc5032c95f119ef70989215d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ts19feztwnUtNIvDr3EEow.jpeg"/></div></div></figure><p id="cac2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用调用图和执行跟踪来逐步对合同进行逆向工程，对我来说效果很好，尽管最好有一个基于GUI的SVG编辑器来注释(如果你知道的话，请在评论中告诉我)。</p><h2 id="e7c5" class="ld js hu bd jt ll lm ln jx lo lp lq kb jc lr ls kf jg lt lu kj jk lv lw kn lx dt translated">查找交叉引用</h2><p id="37a8" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">标识特定合同引用的其他合同通常很有用。让我们假设您想要搜索在回退函数中使用<code class="eh li lj lk kz b">DELEGATECALL</code>指令的契约，就像奇偶错误中的情况一样。您可以使用动态分析来做到这一点:简单地运行PyEthereum VM中的每个契约，不需要任何输入，并检查是否执行了<code class="eh li lj lk kz b">DELEGATECALL</code>指令。Mythril repo包含一个<a class="ae jq" href="https://github.com/b-mueller/mythril/blob/master/examples/find-fallback-dcl.py" rel="noopener ugc nofollow" target="_blank">示例脚本</a>来展示如何做到这一点。它应该输出如下所示的内容:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="48d4" class="ld js hu kz b fv le lf l lg lh">$ python examples/find-fallback-dcl.py<br/>DELEGATECALL in fallback function: Contract 0x07459966443977122e639cbf7804c446<br/>DELEGATECALL in fallback function: Contract 0x17c9e5b7f2bfd8307d628f2d9fcc9352<br/>DELEGATECALL in fallback function: Contract 0x17f9db8b6ffa854335b319d01f09ba39</span><span id="ce03" class="ld js hu kz b fv mu lf l lg lh">(…)</span></pre><p id="73bb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">顾名思义，<code class="eh li lj lk kz b">DELEGATECALL</code>指令将执行委托给一个不同的契约，所以您自然会对调用哪个契约感兴趣。您可以通过<code class="eh li lj lk kz b">--xrefs</code>选项打印被引用合同的地址:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="8092" class="ld js hu kz b fv le lf l lg lh">$ myth --xrefs 0x07459966443977122e639cbf7804c446<br/>0x5b9e8728e316bbeb692d22daaab74f6cbf2c4691</span></pre><p id="8c76" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了使用命令行工具，您还可以以编程方式跟踪交叉引用，并对引用的合同运行进一步的分析(<code class="eh li lj lk kz b">find-fallback-dcl.py</code>也包含了一个这样的例子)。</p><h1 id="55eb" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated">高级用法</h1><p id="3d52" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">虽然命令行工具很简洁，但是只有使用定制代码才能释放Mythril的全部力量。除了契约数据库、反汇编器和EVM跟踪模块，Mythril还包括修改版的<a class="ae jq" href="https://github.com/ConsenSys/ethjsonrpc" rel="noopener ugc nofollow" target="_blank"> ethjsonrpc </a>，允许您在<a class="ae jq" href="https://github.com/ethereumjs/testrpc" rel="noopener ugc nofollow" target="_blank"> testrpc </a>节点上部署和跟踪代码。通过结合所有这些，您可以拼凑出一些不错的静态和动态分析。</p><h2 id="95bb" class="ld js hu bd jt ll lm ln jx lo lp lq kb jc lr ls kf jg lt lu kj jk lv lw kn lx dt translated">搜索</h2><p id="7828" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">使用<code class="eh li lj lk kz b">get_persistent_storage</code>功能从Python程序打开合同数据库。这将返回一个<code class="eh li lj lk kz b">ContractStorage</code>对象(默认情况下，数据库位于<code class="eh li lj lk kz b">[your-home]/.mythril</code>中，但是您可以在构造函数中覆盖它)。调用方法<code class="eh li lj lk kz b">search(expression, callback)</code>开始搜索:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="bac3" class="ld js hu kz b fv le lf l lg lh">from mythril.ether.contractstorage import get_persistent_storage</span><span id="f607" class="ld js hu kz b fv mu lf l lg lh">contract_storage = get_persistent_storage()</span><span id="22af" class="ld js hu kz b fv mu lf l lg lh">contract_storage.search("FUNC#getOwner()#", myCallback)</span></pre><p id="189f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每个搜索结果都将调用第二个参数中传递的回调函数。它接收以下参数:</p><ul class=""><li id="0f3e" class="ly lz hu it b iu iv iy iz jc ma jg mb jk mc jo md me mf mg dt translated">标识Mythril数据库中合同的散列密钥</li><li id="39b0" class="ly lz hu it b iu mh iy mi jc mj jg mk jk ml jo md me mf mg dt translated">包含当前合同的<a class="ae jq" href="https://github.com/b-mueller/mythril/blob/master/mythril/ether/ethcontract.py" rel="noopener ugc nofollow" target="_blank"> ETHContract </a>对象</li><li id="5669" class="ly lz hu it b iu mh iy mi jc mj jg mk jk ml jo md me mf mg dt translated">合同在区块链的地址列表</li><li id="e893" class="ly lz hu it b iu mh iy mi jc mj jg mk jk ml jo md me mf mg dt translated">每个已部署合同的列表余额</li></ul><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="63cb" class="ld js hu kz b fv le lf l lg lh">def myCallBack(contract_hash, contract, addresses, balances):<br/>  # Do something…</span></pre><p id="d2b1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个有用的模式是搜索某种特定类型的合同，然后对每个结果执行一组分析任务。让我们来看看第二个例子<a class="ae jq" href="https://github.com/b-mueller/mythril" rel="noopener ugc nofollow" target="_blank">就是这样做的</a>。</p><h2 id="9302" class="ld js hu bd jt ll lm ln jx lo lp lq kb jc lr ls kf jg lt lu kj jk lv lw kn lx dt translated">跟踪执行</h2><p id="80f7" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">让我们假设您想要扫描契约数据库，寻找类似于奇偶校验错误的条件，但是是以一种通用的方式。一个想法是寻找<em class="jp">任何</em>函数，当没有传递参数、地址或地址列表时，最终用<code class="eh li lj lk kz b">SSTORE</code>指令将你的地址写入存储器。当然，这并不一定意味着您正在覆盖一个重要的状态变量，比如<code class="eh li lj lk kz b">owner</code>或<code class="eh li lj lk kz b">owners</code>，但是这绝对是您想要进一步研究的那种行为。</p><p id="fffd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在前面的<a class="ae jq" href="https://github.com/b-mueller/mythril/blob/master/examples/find-fallback-dcl.py" rel="noopener ugc nofollow" target="_blank">示例</a>中，我们看到了如何在PyEthereum虚拟机中跟踪代码。对于更高级的分析，还包括状态(如可用帐户、契约存储、调用构造函数等。)最好将契约部署在<a class="ae jq" href="https://github.com/ethereumjs/testrpc" rel="noopener ugc nofollow" target="_blank"> testrpc </a>上。在我的测试环境中，我在端口8545上运行geth，在端口8546上运行testrpc实例，这允许我立即将契约从真实网络转移到testrpc。要运行<a class="ae jq" href="https://github.com/b-mueller/mythril/blob/master/examples/discover_writes.py" rel="noopener ugc nofollow" target="_blank">示例代码</a>，按如下方式启动testrpc:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="f150" class="ld js hu kz b fv le lf l lg lh">$ testrpc --port 8546 --gasLimit 0xFFFFFFF --account \<br/>0x0b6f3fd29ca0e570faf9d0bb8945858b9c337cd2a2ff89d65013eec412a4a811,500000000000000000000 --account \<br/>0x2194ac1cd3b9ca6cccc1a90aa2c6f944994b80bb50c82b973adce7f288734d5c,500000000000000000000</span></pre><p id="ca3a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们希望查看数据库中的所有合同，因此我们可以使用匹配每个合同的搜索词，或者简单地迭代这些合同:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="dab1" class="ld js hu kz b fv le lf l lg lh">for k in contract_keys:</span><span id="724b" class="ld js hu kz b fv mu lf l lg lh">  contract = contract_storage.contracts[k]</span></pre><p id="a589" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将返回<a class="ae jq" href="https://github.com/b-mueller/mythril/blob/master/mythril/ether/ethcontract.py" rel="noopener ugc nofollow" target="_blank"> ETHContract </a>对象，这些对象存储了合同代码(<code class="eh li lj lk kz b">contact.code</code>)和创建合同的交易代码(<code class="eh li lj lk kz b">contract.creation_code</code>)。</p><p id="7482" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要在您自己的私有链或testrpc上重新创建契约，使用Mythril的<a class="ae jq" href="https://github.com/b-mueller/mythril/blob/master/mythril/rpc/client.py" rel="noopener ugc nofollow" target="_blank"> JSON RPC客户端</a>重放契约创建事务:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="60b9" class="ld js hu kz b fv le lf l lg lh">from mythril.rpc.client import EthJsonRpc</span><span id="26e3" class="ld js hu kz b fv mu lf l lg lh">testrpc = EthJsonRpc(“localhost”, 8546)</span><span id="8f81" class="ld js hu kz b fv mu lf l lg lh"># Deploy on testrpc</span><span id="fd72" class="ld js hu kz b fv mu lf l lg lh">creator_addr = "0xadc2f8617191ff60a36c3c136170cc69c03e64cd"</span><span id="9c52" class="ld js hu kz b fv mu lf l lg lh">ret = testrpc.eth_sendTransaction(from_address=creator_addr, gas=5000000, value=0, data=contract.creation_code)<br/>receipt = testrpc.eth_getTransactionReceipt(ret)<br/>contract_addr = receipt[‘contractAddress’]</span></pre><p id="5305" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将返回包含合同地址的交易收据。注意，每当testrpc接收到一个事务时，它就会“挖掘”一个新的块，因此您的契约会被即时部署。</p><p id="f9cb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh li lj lk kz b">Disassembly</code>类允许您访问指令列表、格式化的easm代码、交叉引用和合同函数。它采用一个构造函数参数，即契约字节码:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="abdc" class="ld js hu kz b fv le lf l lg lh">disas = Disassembly(contract.code)</span></pre><p id="22d5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">反汇编对象有两个列表<code class="eh li lj lk kz b">func_to_addr</code>和<code class="eh li lj lk kz b">addr_to_func</code>，其中包含函数名和地址之间的映射。您可以迭代<code class="eh li lj lk kz b">func_to_addr</code>来获得每个函数的签名(注意未识别的函数被标记为“UNK_地址”)。</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="7402" class="ld js hu kz b fv le lf l lg lh">for function_selector in disas.func_to_addr:</span><span id="28d1" class="ld js hu kz b fv mu lf l lg lh">  # do something with the function signature. E.g.:<br/>  # "changeOwner(address)"<br/>  # "deposit()"<br/>  # "UNK_0x5b980628"</span></pre><p id="9c79" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<a class="ae jq" href="https://github.com/b-mueller/mythril/blob/master/examples/discover_writes.py" rel="noopener ugc nofollow" target="_blank">示例脚本</a>中，每个可用的函数都用不同的参数调用多次(例如，没有参数、一个地址、一个地址列表)。我不会在这里详细解释所有这些——请查看代码，了解如何对调用数据进行编码并发送事务。</p><p id="e621" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，要跟踪函数调用的执行，使用<code class="eh li lj lk kz b">traceTransaction</code> RPC方法:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="724c" class="ld js hu kz b fv le lf l lg lh">tx = testrpc.eth_sendTransaction(to_address=contract_addr, from_address=addr_schnupper, gas=5000000, value=0, data=data)</span><span id="58d9" class="ld js hu kz b fv mu lf l lg lh">trace = testrpc.traceTransaction(tx)</span></pre><p id="779e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将返回一个包含每个执行指令的字典，以及每个执行点的堆栈。我们只对目标地址位于堆栈倒数第二位的<code class="eh li lj lk kz b">SSTORE</code>指令感兴趣(即“攻击者”的地址被写入存储器)。我们可以按如下方式搜索说明列表:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="e6ed" class="ld js hu kz b fv le lf l lg lh">for t in trace[‘structLogs’]:<br/>  if t['op'] == 'SSTORE':<br/>    if addr_schnupper[2:] in t['stack'][-2]:<br/>      return True</span></pre><p id="e899" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">可能的后续步骤可能包括运行进一步的静态和动态分析，以确定被覆盖地址的影响，或者转储调用图进行手动分析。</p><p id="f389" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里详细描述的使用场景只是冰山一角:你可以在Mythril的API之上构建几乎任意复杂的区块链扫描仪。然而，请注意，Mythril的许多组件，如合同存储、搜索表达式和其他组件，仍然有很大的改进空间。欢迎您在<a class="ae jq" href="https://github.com/ConsenSys/mythril" rel="noopener ugc nofollow" target="_blank"> GitHub存储库</a>上贡献更好的实现和额外的分析脚本。</p><h1 id="1c01" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated">关于神话和神话</h1><p id="621b" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated"><a class="ae jq" href="https://github.com/ConsenSys/mythril" rel="noopener ugc nofollow" target="_blank"> Mythril </a>是一款免费的开源智能合同安全分析器。它使用符号执行来检测各种安全漏洞。</p><p id="0a97" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jq" href="https://mythx.io" rel="noopener ugc nofollow" target="_blank"> MythX </a>是一种基于云的智能合约安全服务，可以无缝集成到智能合约开发环境中并构建管道。它将多个领先的安全分析流程捆绑到一个易于使用的API中，允许任何人创建专门构建的智能合同安全工具。MythX兼容以太坊、Tron、Vechain、Quorum、Roostock和其他基于EVM的平台。</p></div></div>    
</body>
</html>