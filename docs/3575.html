<html>
<head>
<title>Compilers and Interpreters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编译器和解释器</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/compilers-and-interpreters-3e354a2e41cf?source=collection_archive---------0-----------------------#2017-04-10">https://medium.com/hackernoon/compilers-and-interpreters-3e354a2e41cf?source=collection_archive---------0-----------------------#2017-04-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/2836053a731030b1aa390136222d5124.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FbgALTOVNBWUFJeFoJGYFw.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Sliding doors, <a class="ae jg" href="https://en.wikipedia.org/wiki/Kan%C5%8D_Sanraku" rel="noopener ugc nofollow" target="_blank">Kanō Sanraku</a></figcaption></figure><p id="455c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">欢迎来到<a class="ae jg" href="https://hackernoon.com/lets-build-a-programming-language-2612349105c6" rel="noopener ugc nofollow" target="_blank"> <em class="kf">让我们构建一种编程语言(LBPL) </em>系列</a>的第二篇文章。如果你不熟悉这个系列，<a class="ae jg" href="https://hackernoon.com/lets-build-a-programming-language-2612349105c6" rel="noopener ugc nofollow" target="_blank"> LBPL </a>的目的是带你从0到1实现一种编程语言。</p><p id="04b7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这篇文章对编译器和解释器的结构进行了高度概括。</p><h1 id="ae54" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">什么是编译器？</h1><p id="4606" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">编译器最简单的定义是一个程序，它将以高级编程语言(如JavaScript或Java)编写的代码翻译成可由计算机或另一个程序(如虚拟机)直接执行的低级代码(如汇编)。</p><p id="a6b0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">例如，Java编译器将<a class="ae jg" href="https://en.wikipedia.org/wiki/Java" rel="noopener ugc nofollow" target="_blank"> Java </a>代码转换为<a class="ae jg" href="https://en.wikipedia.org/wiki/Java_virtual_machine" rel="noopener ugc nofollow" target="_blank"> JVM </a> (Java虚拟机)可执行的<a class="ae jg" href="https://en.wikipedia.org/wiki/Java_bytecode" rel="noopener ugc nofollow" target="_blank"> Java字节码</a>。其他例子有<a class="ae jg" href="https://en.wikipedia.org/wiki/V8_(JavaScript_engine)" rel="noopener ugc nofollow" target="_blank"> V8 </a>，谷歌的JavaScript引擎，它将JavaScript代码转换成机器码，或者<a class="ae jg" href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection" rel="noopener ugc nofollow" target="_blank"> GCC </a>，它可以将用C、C++、Objective-C、Go等编程语言编写的代码转换成本机机器码。</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div class="fe ff lj"><img src="../Images/00df4d0931b25829c01070d369f3d170.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*jtuu7CroVW2UTygRXHSXPQ.png"/></div></figure><h1 id="65fa" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">黑盒子里有什么？</h1><p id="37d8" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">到目前为止，我们把编译器看作是一个神奇的黑盒子，它包含了一些把高级代码转换成低级代码的咒语。让我们打开那个盒子，看看里面是什么。</p><p id="937c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">编译器可以分为两部分。</p><ul class=""><li id="4767" class="lo lp hu jj b jk jl jo jp js lq jw lr ka ls ke lt lu lv lw dt translated">第一个通常被称为<strong class="jj hv">前端</strong>扫描提交的源代码中的语法错误，检查(并在必要时推断)每个声明变量的类型，并确保每个变量在使用前都已声明。如果有任何错误，它会向用户提供信息性的错误消息。它还维护一个名为<strong class="jj hv">符号表</strong>的数据结构，该表包含源代码中所有<em class="kf">符号</em>的信息。最后，如果没有检测到错误，另一个数据结构，代码的<em class="kf">中间表示</em>，从源代码建立，并作为输入传递给第二部分。</li><li id="a8cb" class="lo lp hu jj b jk lx jo ly js lz jw ma ka mb ke lt lu lv lw dt translated">第二部分，<strong class="jj hv">后端</strong>利用<em class="kf">前端</em>构建的<em class="kf">中间表示</em>和<em class="kf">符号表</em>生成底层代码。</li></ul><p id="ace4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">前端和后端都在一系列阶段中执行操作。每个阶段从它之前的阶段发出的另一个数据结构生成一个特定的数据结构。</p><p id="745b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">前端的阶段一般包括<strong class="jj hv">词法分析</strong>、<strong class="jj hv">语法分析</strong>、<strong class="jj hv">语义分析</strong>和<em class="kf"> </em> <strong class="jj hv">中间代码生成</strong>而<strong class="jj hv"> </strong>后端包括<strong class="jj hv">优化</strong>和<strong class="jj hv">代码生成</strong>。</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div class="fe ff mc"><img src="../Images/6eab1f9a48c77ceff10c1d0860770a8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*KVKVPU8XD2sNxbi2u0Awwg.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Structure of a compiler</figcaption></figure><h2 id="59a6" class="md kh hu bd ki me mf mg km mh mi mj kq js mk ml ku jw mm mn ky ka mo mp lc mq dt translated">词汇分析</h2><p id="1528" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">编译器的第一阶段是<em class="kf">词法分析</em>。在这个阶段，编译器将提交的源代码分解成称为<strong class="jj hv">词位</strong>的有意义的元素，并从词位生成一系列<strong class="jj hv">标记</strong>。</p><p id="7d26" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一个<em class="kf">词位</em>可以被认为是源编程语言中唯一可识别的字符串，例如<em class="kf">关键字</em>如<code class="eh mr ms mt mu b">if</code>、<code class="eh mr ms mt mu b">while</code>或<code class="eh mr ms mt mu b">func</code>、<em class="kf">标识符</em>、<em class="kf">字符串</em>、<em class="kf">数字</em>、<em class="kf">运算符</em>或<em class="kf">单字符</em>如<code class="eh mr ms mt mu b">(</code>、<code class="eh mr ms mt mu b">)</code>、<code class="eh mr ms mt mu b">.</code>或<code class="eh mr ms mt mu b">:</code>。</p><p id="90ae" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf">标记</em>是描述<em class="kf">词位</em>的对象。除了<em class="kf">词位</em>(词位的实际字符串)的值之外，它还包含诸如其类型(<em class="kf">它是关键字吗？</em> <em class="kf">一个标识符？</em> <em class="kf">一个操作员？</em> …)及其在源代码中出现的位置(行号和/或列号)。</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mv"><img src="../Images/e7213bb33a32919b0a415458944c31cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RILS4frRfsqfyuvPINojOw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Sequence of lexemes generated during lexical analysis</figcaption></figure><p id="278e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果编译器遇到一串它不能为其创建一个<em class="kf">标记</em>的字符，它将通过抛出一个错误来停止执行；例如，如果遇到格式错误的字符串或数字或无效字符(如Java中的非ASCII字符)。</p><h2 id="a1c0" class="md kh hu bd ki me mf mg km mh mi mj kq js mk ml ku jw mm mn ky ka mo mp lc mq dt translated">语法分析</h2><p id="a488" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">在语法分析过程中，编译器使用词法分析过程中生成的<em class="kf">标记</em>序列生成一个树状数据结构，称为<strong class="jj hv">抽象语法树</strong>，简称<strong class="jj hv"> AST </strong>。AST反映了程序的语法和逻辑结构。</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mv"><img src="../Images/b237f55adaf98a2eb3fb61e74e560383.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YZTMtnZGU9CQptGKEFQtFw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Abstract Syntax Tree generated after syntax analysis</figcaption></figure><p id="f898" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">语法分析也是检测最终语法错误并以信息性消息的形式报告给用户的阶段。例如，在上面的例子中，如果我们在定义了<code class="eh mr ms mt mu b">sum</code>函数后忘记了右括号<code class="eh mr ms mt mu b">}</code>，编译器应该返回一个错误，指出缺少<code class="eh mr ms mt mu b">}</code>，并且该错误应该指向缺少<code class="eh mr ms mt mu b">}</code>的行和列。</p><p id="d18e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果在这一阶段没有发现错误，编译器转到<em class="kf">语义分析</em>阶段。</p><h2 id="97c9" class="md kh hu bd ki me mf mg km mh mi mj kq js mk ml ku jw mm mn ky ka mo mp lc mq dt translated">语义分析</h2><p id="354e" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">在语义分析时，编译器使用语法分析时生成的<em class="kf"> AST </em>来检查程序是否符合源编程语言的所有规则。语义分析包括</p><ul class=""><li id="ab31" class="lo lp hu jj b jk jl jo jp js lq jw lr ka ls ke lt lu lv lw dt translated"><strong class="jj hv">类型推断</strong>。如果编程语言支持类型推断，编译器将尝试推断程序中所有非类型化表达式的类型。如果类型被成功推断，编译器将使用推断的类型信息在<em class="kf"> AST </em>中注释<strong class="jj hv">相应的节点。</strong></li><li id="3389" class="lo lp hu jj b jk lx jo ly js lz jw ma ka mb ke lt lu lv lw dt translated"><strong class="jj hv">型式检查</strong>。在这里，编译器检查赋给变量的所有值和操作中涉及的所有参数的类型是否正确。例如，编译器确保没有类型为<code class="eh mr ms mt mu b">String</code>的变量被赋予<code class="eh mr ms mt mu b">Double</code>值，或者类型为<code class="eh mr ms mt mu b">Bool</code>的值没有被传递给接受类型为<code class="eh mr ms mt mu b">Double</code>的参数的函数，或者我们没有试图用<code class="eh mr ms mt mu b">Int</code>、<code class="eh mr ms mt mu b">"Hello" / 2</code>来除<code class="eh mr ms mt mu b">String</code>(除非语言定义允许)。</li><li id="f601" class="lo lp hu jj b jk lx jo ly js lz jw ma ka mb ke lt lu lv lw dt translated"><strong class="jj hv">符号管理</strong>。除了执行类型推断和类型检查，编译器还维护一个名为<strong class="jj hv">符号表</strong>的数据结构，其中包含了程序中遇到的所有符号(或名称)的信息。编译器使用<em class="kf">符号表</em>来回答诸如<em class="kf">这个变量在使用前声明了吗？</em>、<em class="kf">同一个作用域内是否有2个同名的变量？</em> <em class="kf">这个变量的类型是什么？</em> <em class="kf">这个变量在当前作用域内可用吗？</em>还有很多。</li></ul><p id="30e1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">语义分析阶段的输出是一个<strong class="jj hv">注释AST </strong>和<strong class="jj hv">符号表</strong>。</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mw"><img src="../Images/3b91c8048ac2fc0e4e3df026aa2a67d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*55yoB_-AO9suiP2QNTzAgw.png"/></div></div></figure><h2 id="855e" class="md kh hu bd ki me mf mg km mh mi mj kq js mk ml ku jw mm mn ky ka mo mp lc mq dt translated">中间代码生成</h2><p id="76c1" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">在语义分析阶段之后，编译器使用<em class="kf">注释的AST </em>生成一个中间的和机器无关的底层代码。一种这样的中间表示是<a class="ae jg" href="https://en.wikipedia.org/wiki/Three-address_code" rel="noopener ugc nofollow" target="_blank"> <strong class="jj hv">三地址码</strong> </a>。</p><p id="5c79" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf">三地址码</em> ( <em class="kf"> 3AC </em>)最简单的形式是一种语言，其中一条指令是一个赋值，最多有3个操作数。</p><p id="cdff" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf"> 3AC </em>中的大多数指令都是<code class="eh mr ms mt mu b">a <strong class="jj hv">:=</strong> b <strong class="jj hv">&lt;operator&gt;</strong> c</code>或<code class="eh mr ms mt mu b">a <strong class="jj hv">:=</strong> b</code>的形式。</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mx"><img src="../Images/6e306a69667b7e8bfad3ee153f9f9f1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DH1GvuL7-Qr3EIx5DpFqfQ.png"/></div></div></figure><p id="90b6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">上图描述了一个<em class="kf"> 3AC </em>代码，该代码由在函数编译期间创建的<em class="kf">注释AST </em>生成</p><pre class="lk ll lm ln fq my mu mz na aw nb dt"><span id="1dc2" class="md kh hu mu b fv nc nd l ne nf"><strong class="mu hv">func</strong> sum(n: <strong class="mu hv">Int</strong>): <strong class="mu hv">Int</strong> = {<br/>    n * (n + 1) / 2<br/>}</span></pre><p id="c53b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">中间代码生成结束了编译器的<em class="kf">前端</em>阶段。</p><h2 id="e70f" class="md kh hu bd ki me mf mg km mh mi mj kq js mk ml ku jw mm mn ky ka mo mp lc mq dt translated">最佳化</h2><p id="3d39" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">在优化阶段，即<em class="kf">后端</em>的第一阶段，编译器使用不同的优化技术来改进生成的中间代码，例如通过使代码更快或更短。</p><p id="dcd8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">例如，对前一个例子中的<em class="kf"> 3AC </em>代码的一个非常简单的优化就是去掉临时赋值<code class="eh mr ms mt mu b">t3 := t2 / 2</code>，直接给<code class="eh mr ms mt mu b">id1</code>赋值<code class="eh mr ms mt mu b">t2 / 2</code>。</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div class="fe ff ng"><img src="../Images/b7c947bbe5bd3777588de39a4e062df3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*G3knNvYZWHvZnDsY-S9jtQ.png"/></div></figure><h2 id="d5ca" class="md kh hu bd ki me mf mg km mh mi mj kq js mk ml ku jw mm mn ky ka mo mp lc mq dt translated">代码生成</h2><p id="3bec" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">在这个最后阶段，编译器将优化的中间代码翻译成机器相关代码、<em class="kf">汇编</em>或任何其他目标低级语言。</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div class="fe ff nh"><img src="../Images/8093273c32dd5bf66e12a5ddc9dc7570.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*W4MUFcWTCU83dbtgSWQu6g.png"/></div></figure><h1 id="efc2" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">编译器与解释器</h1><p id="c6bb" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">让我们以编译器和解释器之间的区别来结束这篇文章。</p><p id="2542" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">解释器和编译器在结构上非常相似。主要区别在于解释器直接执行源编程语言中的指令，而编译器将这些指令翻译成高效的机器代码。</p><p id="e286" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">解释器通常会生成一个有效的中间表示，并立即对其进行评估。根据解释器的不同，中间表示可以是一个<em class="kf"> AST </em>、一个<em class="kf">带注释的AST </em>或一个独立于机器的低级表示，如<em class="kf">三地址码</em>。</p><h1 id="eb5a" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">下一步是什么？</h1><p id="772d" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">请阅读下一篇文章，在这篇文章中，我们将深入探讨词法分析，并回顾为Blink构建词法分析器所需的所有概念。你也会因为完成第一个挑战而弄脏你的手。</p><p id="9865" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你已经到达终点了。🎉</p><blockquote class="ni nj nk"><p id="f922" class="jh ji kf jj b jk jl jm jn jo jp jq jr nl jt ju jv nm jx jy jz nn kb kc kd ke hn dt translated"><a class="ae jg" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jg" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jg" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae jg" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jh ji kf jj b jk jl jm jn jo jp jq jr nl jt ju jv nm jx jy jz nn kb kc kd ke hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jg" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jg" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>