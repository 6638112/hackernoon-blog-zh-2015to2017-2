<html>
<head>
<title>On Type Class Instance Selection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于类型类实例选择</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/typeclass-instance-selection-fea1068920e6?source=collection_archive---------3-----------------------#2017-05-14">https://medium.com/hackernoon/typeclass-instance-selection-fea1068920e6?source=collection_archive---------3-----------------------#2017-05-14</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="87c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我能够创建类型类来定期解决问题之前，我的Haskell职业生涯已经进行了很长时间。</p><p id="a824" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">回想起来，我并没有很好地理解实例选择是如何工作的。我不知道什么时候我会走上一条会导致重叠实例的道路，或者什么时候我是安全的。</p><h1 id="8217" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">简单重叠</h1><p id="f708" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">我会经常看到Haskellers像我以前一样写代码:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="8356" class="lb jq hu kx b fv lc ld l le lf">class Combine a where<br/> combine :: a -&gt; a -&gt; a</span><span id="6505" class="lb jq hu kx b fv lg ld l le lf">instance Combine String where<br/> combine = (++)</span><span id="552c" class="lb jq hu kx b fv lg ld l le lf">instance Num a =&gt; Combine a where<br/> combine = (+)</span></pre><p id="5d65" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">并且在编译失败时感到困惑。</p><p id="6aa1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么为什么下面的代码会重叠呢？</p><p id="92cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lh li lj kx b">String</code>不是<code class="eh lh li lj kx b">Num</code>的实例，所以看起来编译器可以将这些实例视为非重叠的。</p><p id="a399" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">原来类型检查被分成几个步骤。首先进行实例选择，然后类型检查器确保满足像<code class="eh lh li lj kx b">Num a</code>这样的约束。</p><p id="a6f2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了判断两个实例是否重叠，必须忽略实例声明的上下文部分。</p><p id="b6db" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们把这两个实例排列起来，看看它们是否重叠。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="13f1" class="lb jq hu kx b fv lc ld l le lf">Combine String <br/>Combine a</span></pre><p id="779c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">他们也是吗？我还没有真正定义实例重叠的含义。</p><p id="7e60" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">实例选择就像一种模式匹配。每个实例都类似于执行匹配的不同等式，匹配使用类型构造函数和类型变量，而不是匹配数据构造函数。</p><h1 id="46c6" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">模式匹配审查</h1><p id="ff9f" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">这是一个带有一些正常模式匹配的函数。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="1a13" class="lb jq hu kx b fv lc ld l le lf">asInt True = 1<br/>asInt a    = 0</span></pre><p id="bdad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">匹配有重叠吗？是的。第二种模式是通配符，匹配所有内容。这里没有什么不明确的地方，因为模式匹配能够使用匹配的顺序来确定如何处理重叠。</p><p id="b8ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你改变顺序，编译器会抱怨，因为更具体的匹配永远不会被命中。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="e083" class="lb jq hu kx b fv lc ld l le lf">asInt a    = 0<br/>asInt True = 1</span></pre><p id="c0d2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">实例选择的工作方式类似于模式匹配，只是在类型级别上不同。但是，没有办法指定顺序，因此重叠会无条件地导致编译器错误。</p><p id="47c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这导致了使用类型类的启发。如果你曾经写了一个像<code class="eh lh li lj kx b">instance Combine a</code>这样的实例，你是在说类型类只能有一个实例。这回避了为什么要使用类型类的问题。答案很可能是“不要使用类型类。”</p><h1 id="24f8" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">一切正常，但你还是失败了</h1><p id="d5f5" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">让我们继续使用我们错误的实例来看看实例选择是如何成功的，但是编译会失败。</p><p id="1519" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们写出实例签名并删除重叠的实例。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="7f5c" class="lb jq hu kx b fv lc ld l le lf">class Combine a where<br/> combine :: a -&gt; a -&gt; a</span><span id="7933" class="lb jq hu kx b fv lg ld l le lf">instance Num a =&gt; Combine a where<br/> combine :: Num a =&gt; a -&gt; a -&gt; a<br/> combine = (+)</span></pre><p id="5f5d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们现在可以使用<code class="eh lh li lj kx b">combine</code></p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="6699" class="lb jq hu kx b fv lc ld l le lf">main = putStrLn $ combine “hello “ “world”</span></pre><p id="0ef5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在幕后，编译器基于我们的实例声明<a class="ae lk" href="https://hackernoon.com/tagged/declaration" rel="noopener ugc nofollow" target="_blank">和</a>制作了一个<code class="eh lh li lj kx b">combine</code>版本，我们称之为<code class="eh lh li lj kx b">combine_num</code>(关于编译器做什么的更详细的解释，请看这篇<a class="ae lk" href="https://www.schoolofhaskell.com/user/jfischoff/instances-and-dictionaries" rel="noopener ugc nofollow" target="_blank">帖子</a>)。</p><p id="30d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">编译器在<code class="eh lh li lj kx b">main</code>中发现了<code class="eh lh li lj kx b">combine</code>的用法，并且必须满足约束<code class="eh lh li lj kx b">Combine a</code>。它推断在这种情况下<code class="eh lh li lj kx b">a</code>是类型<code class="eh lh li lj kx b">String</code>。它现在必须满足专门的约束<code class="eh lh li lj kx b">Combine String</code>。编译器查看它的实例，试图找到匹配的东西。</p><p id="c952" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">编译器没有<code class="eh lh li lj kx b">Combine String</code>，但是它有<code class="eh lh li lj kx b">Combine a</code>。<code class="eh lh li lj kx b">a</code>将匹配<code class="eh lh li lj kx b">String</code>，因为它是匹配所有内容的通配符。</p><p id="b47d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">编译器在<code class="eh lh li lj kx b">combine_num</code>中进行替换。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="51ed" class="lb jq hu kx b fv lc ld l le lf">main = putStrLn $ combine_num “hello “ “world”</span></pre><p id="b6ca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lh li lj kx b">combine_num</code>带来了约束<code class="eh lh li lj kx b">Num a</code>，这里专门针对<code class="eh lh li lj kx b">Num String</code>。这个约束导致再次搜索<code class="eh lh li lj kx b">Num String</code>的实例，但是这次没有匹配，编译失败。</p><p id="46ee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用类型类方法会添加编译器必须解决的类约束。解决约束要求找到合适的实例，这可能导致编译器不得不解决更多的约束。为了编译成功，必须满足所有的约束，但是它们不能同时被解决。</p><h1 id="ceeb" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">更棘手的重叠</h1><p id="14f5" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">假设你想写一个类型类来计算一个函数有多少个参数:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="1827" class="lb jq hu kx b fv lc ld l le lf">class ArgCount a where<br/> argCount :: a -&gt; Int<br/> <br/>instance ArgCount (a -&gt; b) where<br/> argCount _ = 1<br/> <br/>instance ArgCount (x -&gt; y -&gt; z) where<br/> argCount _ = 2</span></pre><p id="d315" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们像以前一样排列我们的声明:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="ea2c" class="lb jq hu kx b fv lc ld l le lf">ArgCount (a -&gt; b)<br/>ArgCount (x -&gt; y -&gt; z)</span></pre><p id="7e8f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它们重叠吗？确实如此(否则我不会问这个问题:p)。加括号会让原因更清楚。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="2110" class="lb jq hu kx b fv lc ld l le lf">ArgCount (a -&gt; b)<br/>ArgCount (x -&gt; (y -&gt; z))</span></pre><p id="3a1c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第一个实例中的<code class="eh lh li lj kx b">b </code>可以是任何东西，甚至是<code class="eh lh li lj kx b">y -&gt; z</code>,所以它将匹配第二个实例，我们确实有重叠。</p><p id="c012" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您仍然对这个例子感到困惑，这可能是因为中缀符号。与构造函数的模式匹配通常采用前缀表示法(但这不是必须的)。以下是以前缀形式写出的相同示例:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="5913" class="lb jq hu kx b fv lc ld l le lf">ArgCount (-&gt; a b       )<br/>ArgCount (-&gt; x (y -&gt; z))</span></pre><p id="d750" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们试着用递归来解决这个问题。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="f0ea" class="lb jq hu kx b fv lc ld l le lf">-- I upgraded to using proxies so I would not have to use undefined<br/>class ArgCount a where<br/> argCount :: p a -&gt; Int<br/> <br/>instance ArgCount b =&gt; ArgCount (a -&gt; b) where<br/> argCount _ = 1 + argCount (Proxy :: Proxy b)<br/> <br/>instance ArgCount (m a) where<br/> argCount _ = 0</span></pre><p id="16b6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个想法是，我将能够计算最终结果类似于<code class="eh lh li lj kx b">State Int</code>或<code class="eh lh li lj kx b">IO a</code>的一元函数。不幸的是，这也会重叠。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="814c" class="lb jq hu kx b fv lc ld l le lf">ArgCount (m a)<br/>ArgCount (a -&gt; b)</span></pre><p id="e506" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样，当以前缀形式书写时，这一点更清楚。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="9475" class="lb jq hu kx b fv lc ld l le lf">ArgCount (m a)<br/>ArgCount ((-&gt; a) b)</span></pre><p id="c306" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以看到<code class="eh lh li lj kx b">m</code>可能是<code class="eh lh li lj kx b">-&gt; a</code>，所以我们有重叠。</p><p id="c531" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面的代码将计算<code class="eh lh li lj kx b">IO</code>函数的参数个数。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="6b63" class="lb jq hu kx b fv lc ld l le lf">class ArgCount a where<br/> argCount :: p a -&gt; Int<br/> <br/>instance ArgCount b =&gt; ArgCount (a -&gt; b) where<br/> argCount _ = 1 + argCount (Proxy :: Proxy b)<br/> <br/>instance ArgCount (IO a) where<br/> argCount _ = 0</span></pre><p id="76b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lh li lj kx b"><a class="ae lk" href="http://hackage.haskell.org/package/base-4.9.1.0/docs/Text-Printf.html#t:PrintfType" rel="noopener ugc nofollow" target="_blank">Printf</a></code>也采用了类似的模式。</p><p id="b765" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以有几件事要注意。</p><p id="49d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个实例的多态越少，重叠的可能性就越小。有时您可能认为您的实例是相对特定的(<code class="eh lh li lj kx b">a -&gt; b</code>仅用于一个参数的函数)，但是由于可能的替换，它实际上是更通用的(<code class="eh lh li lj kx b">a -&gt; b</code>实际上是所有函数的实例)。</p><h1 id="a7b2" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">当更多的多态性意味着更好的推断时</h1><p id="43ba" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">让我们完成最后一个实例选择示例:获得更好的类型推断的技巧。该代码取自<code class="eh lh li lj kx b">mono-traversable</code> <code class="eh lh li lj kx b"><a class="ae lk" href="https://hackage.haskell.org/package/mono-traversable-1.0.2/docs/src/Data-Sequences.html#line-1488" rel="noopener ugc nofollow" target="_blank">Data.Sequences</a></code>但也存在于<code class="eh lh li lj kx b"><a class="ae lk" href="http://hackage.haskell.org/package/base-4.9.1.0/docs/Text-Printf.html#t:PrintfType" rel="noopener ugc nofollow" target="_blank">Printf</a></code>中</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="11e3" class="lb jq hu kx b fv lc ld l le lf">instance (c ~ Char) =&gt; Textual [c] where<br/> words = List.words</span></pre><p id="44f2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们忽略上下文，我们会看到这是所有列表类型的<code class="eh lh li lj kx b">Textual</code>的一个实例，与元素类型无关。然而，实际上只有当列表的类型是<code class="eh lh li lj kx b">[Char]</code>或<code class="eh lh li lj kx b">String</code>时，代码才会被编译。</p><p id="0619" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在有些情况下，类型检查器可能能够推断出它需要一个<code class="eh lh li lj kx b">[c]</code>的实例，并且在替换了<code class="eh lh li lj kx b">words</code>之后，在稍后的某个阶段确定该列表确实是一个<code class="eh lh li lj kx b">String</code>。如果我们只为<code class="eh lh li lj kx b">String, </code>编写实例，那么在没有类型注释的情况下，实例选择可能会失败。</p><p id="f5f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然这不是典型的情况，但是如果你只需要一个多态类型的专用实例，这是一个比使用<code class="eh lh li lj kx b">FlexibleInstance</code> …更好的方法，至少从类型推理的角度来看是这样的。</p><h1 id="df55" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">打字课太棒了</h1><p id="d4c2" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">许多Haskellers对成功使用类型类的失败尝试有着不好的记忆。我希望通过揭示类型类实例选择是如何工作的，我们可以避免不必要的痛苦。</p><p id="f9a9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我只讲述了简单的普通类型类，没有任何特定的类型类扩展。人们很容易认为重叠问题可以通过启用<code class="eh lh li lj kx b">OverlappingInstances</code>(以及更现代的<code class="eh lh li lj kx b">Overlapping</code>和<code class="eh lh li lj kx b">Overlaps</code>杂注)来解决，但这绝不是灵丹妙药。介绍有用的类型类扩展能完成什么至少是一篇独立的博客文章。</p><p id="d71e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我的下一篇博文中，我将讨论一些简单的编写类型类的模式，你可以从中获得乐趣和收益。</p><p id="46ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">PS。感谢Sukant Hajra、Alan Zimmerman和Sudhir Kumar的早期审查和初步<a class="ae lk" href="https://hackernoon.com/tagged/feedback" rel="noopener ugc nofollow" target="_blank">反馈</a>。</p><blockquote class="ll lm ln"><p id="0cd2" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated"><a class="ae lk" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客们下午的开始。我们是<a class="ae lk" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae lk" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae lk" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae lk" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae lk" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上给我们点赞/发消息</a>，或者简单地说，<a class="ae lk" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lk" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lk" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ks kt ku kv fq ls"><div class="bz el l di"><div class="lt lu l"/></div></figure></div></div>    
</body>
</html>