<html>
<head>
<title>Creating a parallel, offline, extensible, browser based bundler for CodeSandbox</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为CodeSandbox创建并行、离线、可扩展、基于浏览器的捆绑器</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-i-created-a-parallel-offline-extensible-browser-based-bundler-886db508cc31?source=collection_archive---------3-----------------------#2017-08-27">https://medium.com/hackernoon/how-i-created-a-parallel-offline-extensible-browser-based-bundler-886db508cc31?source=collection_archive---------3-----------------------#2017-08-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/885937bc2b90a8b26a988a70da9ad9c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zzptpqU8vLkq4nnnjZO0jw.png"/></div></div></figure><p id="7f4c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我第一次开始CodeSandbox时，我完全专注于React开发。起初我们甚至将其命名为ReactSandbox，但我在最后一刻将其更改为CodeSandbox，以便我们可以扩展到其他库。我很自豪地说，我们现在在这方面取得了成功！</p><p id="677d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">过去一周，我们慢慢推出了对其他库的支持。我们现在支持React、Vue和Preact模板，并计划支持Angular、ReasonML和Svelte(如果您有其他建议，请告诉我)。为了做到这一点，我不得不从头开始重写bundler。在这篇博文中，我将主要解释新的bundler是如何建造的，以及我做出了哪些决定。</p><figure class="ka kb kc kd fq iv"><div class="bz el l di"><div class="ke kf l"/></div><figcaption class="kg kh fg fe ff ki kj bd b be z ek">Vue</figcaption></figure><figure class="ka kb kc kd fq iv"><div class="bz el l di"><div class="ke kf l"/></div><figcaption class="kg kh fg fe ff ki kj bd b be z ek">Preact</figcaption></figure><h1 id="2c35" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">过去</h1><p id="0332" class="pw-post-body-paragraph jc jd hu je b jf li jh ji jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz hn dt translated">我们使用的第一个捆绑器非常简单:对于每个请求的文件，我们首先传输它，评估它，然后缓存结果。当一个文件发生变化时，我们只需丢弃依赖于该文件的所有文件的缓存，然后重新开始。这适用于Babel，但不适用于其他需要异步传输的加载程序，如Sass。在旧系统中，为Vue等创建transpilers变得更加困难。很明显，如果我们想支持像Vue这样的库，我必须重新考虑捆绑过程，而且这也给了我改进捆绑器的机会。</p><h2 id="f859" class="lo kl hu bd km lp lq lr kq ls lt lu ku jn lv lw ky jr lx ly lc jv lz ma lg mb dt translated">浏览器中的Webpack</h2><p id="8692" class="pw-post-body-paragraph jc jd hu je b jf li jh ji jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz hn dt translated">我的第一个想法是让Webpack在浏览器中工作。几乎所有现有的CLI都已经使用了Webpack，如果它已经与Webpack一起工作，那么添加新的加载程序就不需要任何工作。为下载功能导出到一个<code class="eh mc md me mf b">webpack.config.js</code>也很容易，用户可以提供他们自己的配置。听起来很完美，对吧？对我来说也是！这听起来好得不像是真的，结果却是真的。</p><p id="18eb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我让Webpack在浏览器中运行，但是包的大小是3.5MB。由于动态需求，我不得不提供许多polyfills，编译抛出了十几个警告。此外，只有一半的装载机工作。Webpack假设了一个节点环境，事实证明模拟该环境的成本(在我看来)对于从中获得的优势来说太大了。我的第二个原因是CodeSandbox是一个非常特定的平台，如果我们自己构建bundler，我们可以完全针对该平台进行优化。</p><h2 id="44f0" class="lo kl hu bd km lp lq lr kq ls lt lu ku jn lv lw ky jr lx ly lc jv lz ma lg mb dt translated">浏览器中的Webpack加载器API</h2><p id="2e25" class="pw-post-body-paragraph jc jd hu je b jf li jh ji jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz hn dt translated">我的第二个想法是写我自己的bundler，但是用一个非常接近Webpack的loader API。这样做的好处是bundler“感觉”像Webpack，但针对浏览器环境进行了优化。编写加载器将非常容易；我们可以只使用现有的Webpack加载器，去掉所有SSR、节点和生产逻辑，它*应该*在CodeSandbox中工作。另一个<strong class="je hv">大</strong>优势是我们假设了一个浏览器环境，所以我们可以滥用浏览器API，比如Web Workers、Service Workers和代码分割！</p><h1 id="b9d5" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">履行</h1><p id="ae5f" class="pw-post-body-paragraph jc jd hu je b jf li jh ji jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz hn dt translated">对于实际的实现，我试图做到两全其美:用Webpack关闭加载器API surface，并对CodeSandbox进行全面优化。它应该比第一捆绑，离线工作速度更快，它应该是可扩展的。最终捆绑器区分三个阶段:配置、传输和评估。</p><h2 id="0af7" class="lo kl hu bd km lp lq lr kq ls lt lu ku jn lv lw ky jr lx ly lc jv lz ma lg mb dt translated">配置</h2><p id="2994" class="pw-post-body-paragraph jc jd hu je b jf li jh ji jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz hn dt translated">新的捆扎机是按照模板制造的。对于我们拥有的每个模板(目前为React、Vue和Preact ),我们都定义了一个新的预设。这些预设包含的配置也可以在Webpack配置中找到:别名、默认加载器和默认扩展。<code class="eh mc md me mf b">Preset</code>的功能是返回一个文件类型使用了什么加载器，以及文件是如何被解析的。Preact的<code class="eh mc md me mf b">Preset</code>如下所示:</p><figure class="ka kb kc kd fq iv"><div class="bz el l di"><div class="mg kf l"/></div></figure><h2 id="3c85" class="lo kl hu bd km lp lq lr kq ls lt lu ku jn lv lw ky jr lx ly lc jv lz ma lg mb dt translated">蒸腾作用</h2><p id="9a84" class="pw-post-body-paragraph jc jd hu je b jf li jh ji jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz hn dt translated">蒸腾作用是最重要的阶段。顾名思义:它做编译，但也负责构建依赖图。对于每个传输的文件，我们遍历AST，搜索所有require语句，并将它们添加到树中。这种情况不仅发生在<code class="eh mc md me mf b">js</code>档，也发生在<code class="eh mc md me mf b">typescript</code>、<code class="eh mc md me mf b">sass</code>、<code class="eh mc md me mf b">less</code>和<code class="eh mc md me mf b">stylus</code>档。在编译期间构建树的优点是我们只需要构建一次AST。</p><p id="d6cb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">传输输出保存在<code class="eh mc md me mf b"><a class="ae mh" href="https://github.com/CompuIves/codesandbox-client/blob/master/src/sandbox/eval/transpiled-module.js" rel="noopener ugc nofollow" target="_blank">TranspiledModule</a></code>中。一个文件可以与多个<code class="eh mc md me mf b">TranspiledModule</code>相关联，因为文件可能以不同的方式被需要。例如，<code class="eh mc md me mf b">require(‘raw-loader!./Hello.js’)</code>和<code class="eh mc md me mf b">require(‘./Hello.js’)</code>不一样。</p><figure class="ka kb kc kd fq iv"><div class="bz el l di"><div class="ke kf l"/></div><figcaption class="kg kh fg fe ff ki kj bd b be z ek">Different require syntax is supported!</figcaption></figure><p id="7e3d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> Web Workers </strong> <br/>一个非常重要的改进是，几乎所有的传输都是基于您的内核数量使用web worker池管理器并行进行的。这意味着我们使用单独的线程进行传输，所以默认情况下传输是并行发生的。这消除了UI线程的负载(减少了停顿),并且极大地改善了传输时间:对我来说，传输时间(以及加载时间)缩短了2到4倍！蒸腾作用是三个阶段中唯一不同步的阶段。</p><figure class="ka kb kc kd fq iv"><div class="bz el l di"><div class="mi kf l"/></div><figcaption class="kg kh fg fe ff ki kj bd b be z ek">What happens if you move Babel into a web worker?</figcaption></figure><p id="44eb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">代码拆分</strong> <br/>每个加载器都是根据它们的用途动态加载的。如果你的沙箱只包含javascript文件，我们只会下载巴别塔加载器。这节省了大量的时间和带宽，因为传输器往往很大。</p><p id="6d0e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">离线支持<br/> </strong>捆扎机的要求之一是离线工作，这就是为什么所有未使用的加载程序仍然由服务人员在后台下载。在沙盒上工作时没有外部依赖性，所以下载transpilers后，它可以随时随地离线捆绑。</p><h2 id="776e" class="lo kl hu bd km lp lq lr kq ls lt lu ku jn lv lw ky jr lx ly lc jv lz ma lg mb dt translated">估价</h2><p id="4122" class="pw-post-body-paragraph jc jd hu je b jf li jh ji jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz hn dt translated">尽管我将这个捆绑器称为“捆绑器”，但实际上并没有发生捆绑！我们已经可以访问所有代码，所以剩下的唯一任务就是评估正确的文件。使用一个简单的<code class="eh mc md me mf b">eval</code>来评估入口点，我们提供了一个存根require来解析正确的<code class="eh mc md me mf b">TranspiledModule</code>并评估它或者返回缓存(如果存在的话)。</p><h2 id="61b3" class="lo kl hu bd km lp lq lr kq ls lt lu ku jn lv lw ky jr lx ly lc jv lz ma lg mb dt translated"><strong class="ak">‘热模块重装’</strong></h2><p id="9459" class="pw-post-body-paragraph jc jd hu je b jf li jh ji jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz hn dt translated">传输和评估的输出被缓存。当一个文件改变时，我们丢弃了那个特定文件的编译和那个文件以及所有父文件的编译(所有文件<code class="eh mc md me mf b">require</code>使用那个文件)。从那一点，我们再次从入口点传输和评估。我将HMR放在引号中，因为这与真正的HMR解决方案不是同一个实现。我们没有<code class="eh mc md me mf b">​module.hot</code>，因为要让HMR在沙盒中工作需要一个设置，而我想让它开箱即用。<em class="ln">(编辑:我们现在从CodeSandbox 2.5开始就支持</em> <code class="eh mc md me mf b"><em class="ln">module.hot</em></code> <em class="ln">！)</em></p><h1 id="4705" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">结论</h1><p id="7b3d" class="pw-post-body-paragraph jc jd hu je b jf li jh ji jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz hn dt translated">我为这个bundler感到自豪，因为它允许我们做更多的事情，并且比以前的版本快得多。有了新的实现，我们拥有了两个世界的精华；我们有一个与Webpack相近的API surface，它针对CodeSandbox和浏览器进行了优化。它当然没有Webpack等其他解决方案先进，但对于CodeSandbox来说非常完美。现在添加一个新模板不超过一个小时，加载器很容易从Webpack中移植过来。这使得我们在未来非常灵活。</p><h2 id="79d7" class="lo kl hu bd km lp lq lr kq ls lt lu ku jn lv lw ky jr lx ly lc jv lz ma lg mb dt translated">表演</h2><p id="acec" class="pw-post-body-paragraph jc jd hu je b jf li jh ji jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz hn dt translated">新捆扎机的性能也有所提高。初始加载时间可能很长，因为需要下载transpilers。所有的transpilers都是使用服务工作者或浏览器缓存来缓存的，所以第二次尝试应该会快得多。在我的Macbook 13" 2015上，初始编译需要1到2秒，所有重新编译需要35到40毫秒(！).这些测试在Redux的TodoMVC实现上运行。它的速度更快，因为跨编译现在在不同的线程上并行发生，并且跨编译已经在获取依赖项时开始。</p><h2 id="d105" class="lo kl hu bd km lp lq lr kq ls lt lu ku jn lv lw ky jr lx ly lc jv lz ma lg mb dt translated">来源</h2><p id="5195" class="pw-post-body-paragraph jc jd hu je b jf li jh ji jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz hn dt translated">如果你想看真货；可以在这里找到源码:<a class="ae mh" href="https://github.com/CompuIves/codesandbox-client/blob/master/src/sandbox/eval/manager.js" rel="noopener ugc nofollow" target="_blank">https://github . com/compu Ives/code sandbox-client/blob/master/src/sandbox/eval/manager . js</a>。这是<code class="eh mc md me mf b">Manager</code>类，它负责连接<code class="eh mc md me mf b">Sandbox</code>、<code class="eh mc md me mf b">Preset</code>和所有的<code class="eh mc md me mf b">TranspiledModule</code></p><h1 id="d8e9" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">将来的</h1><p id="4a50" class="pw-post-body-paragraph jc jd hu je b jf li jh ji jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz hn dt translated">新的捆扎机提供了许多令人兴奋的可能性。最大的两个是自定义模板支持和完全离线支持。</p><h2 id="b85a" class="lo kl hu bd km lp lq lr kq ls lt lu ku jn lv lw ky jr lx ly lc jv lz ma lg mb dt translated">自定义模板支持</h2><p id="e9c3" class="pw-post-body-paragraph jc jd hu je b jf li jh ji jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz hn dt translated">我们现在有了所有这些加载器，如sass和typescript，如果我们也能为React沙箱解锁这些就好了。应该有一个按钮<code class="eh mc md me mf b">eject</code>一个沙箱，这使你能够指定加载器和自定义巴别塔配置之类的东西。这方面的主要工作已经完成，我们只需要API来支持它。</p><h2 id="7853" class="lo kl hu bd km lp lq lr kq ls lt lu ku jn lv lw ky jr lx ly lc jv lz ma lg mb dt translated">完全离线支持</h2><p id="664a" class="pw-post-body-paragraph jc jd hu je b jf li jh ji jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz hn dt translated">一切都已经脱机工作，但为了完全脱机支持，我们需要允许您脱机保存沙箱。这让你可以永远离线工作，并随时上传到CodeSandbox。唯一需要互联网连接的功能是npm依赖项，但我们已经缓存了所有npm结果。当您计划旅行或飞行时，我们将为您提供预先缓存组合的选项。</p></div><div class="ab cl mj mk hc ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hn ho hp hq hr"><p id="401c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你想了解CodeSandbox的最新消息，你可以关注我的推特(<a class="ae mh" href="https://twitter.com/CompuIves" rel="noopener ugc nofollow" target="_blank">https://twitter.com/CompuIves</a>)或者CodeSandbox的推特(<a class="ae mh" href="https://twitter.com/codesandboxapp" rel="noopener ugc nofollow" target="_blank">https://twitter.com/codesandboxapp</a>)。</p></div></div>    
</body>
</html>