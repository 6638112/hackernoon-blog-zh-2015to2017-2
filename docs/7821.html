<html>
<head>
<title>How to Build Your Own Reactivity System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何建立自己的反应系统</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-build-your-own-reactivity-system-fc48863a1b7c?source=collection_archive---------5-----------------------#2017-11-09">https://medium.com/hackernoon/how-to-build-your-own-reactivity-system-fc48863a1b7c?source=collection_archive---------5-----------------------#2017-11-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/54439eb546da599490b3b9286158b789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Wl6_qqrbI_FafXAMkLEnw.jpeg"/></div></div></figure><p id="e145" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">想了解Vuex？检查我的</em> <a class="ae kb" href="https://bit.ly/31v8NPq" rel="noopener ugc nofollow" target="_blank"> <em class="ka">手动课程</em> </a> <em class="ka">！。给我发消息成为早期评论者，免费获得。</em></p><p id="ec51" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">几个月前，我在<a class="kc kd gr" href="https://medium.com/u/1b199ed2dfd?source=post_page-----fc48863a1b7c--------------------------------" rel="noopener" target="_blank"> Frontend Masters </a>参加了一个名为<em class="ka">vue . js Advanced Features from the Ground Up</em>的见面会。这真的很棒，因为我们从它的创造者<a class="kc kd gr" href="https://medium.com/u/4f198f5f1f12?source=post_page-----fc48863a1b7c--------------------------------" rel="noopener" target="_blank">尤雨溪</a>那里了解到了<a class="kc kd gr" href="https://medium.com/u/9b930cf6db26?source=post_page-----fc48863a1b7c--------------------------------" rel="noopener" target="_blank"> Vue.js </a>。他不仅教我们如何使用Vue，还向我们展示了如何实际实现它的一部分。反应性是我最感兴趣的部分，所以，课后，我钻研了Vue的源代码，以了解更多关于它的反应系统是如何工作的。在本指南中，我将解释Vue的反应系统是如何实现的，并展示如何制作自己的反应系统。</p><h1 id="c087" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">反应性的问题</h1><p id="e475" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">什么是反应性？我真的很喜欢Evan在他的演讲中解释的方式，所以我会用他的例子。说你有一个变量<code class="eh lh li lj lk b">a</code> <strong class="je hv">。</strong></p><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="9dba" class="lt kf hu lk b fv lu lv l lw lx">let a = 3</span></pre><p id="2794" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，假设你有另一个变量<code class="eh lh li lj lk b">b</code>，比如<code class="eh lh li lj lk b">b = a * 3</code>。</p><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="337e" class="lt kf hu lk b fv lu lv l lw lx">let b = a * 3<br/>console.log(b) // 9</span></pre><p id="1c6c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这工作得很好。但是如果需要换<code class="eh lh li lj lk b">a</code>会怎么样呢？</p><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="cd61" class="lt kf hu lk b fv lu lv l lw lx">a = 5<br/>console.log(b) // 9</span></pre><p id="80b6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">即使<code class="eh lh li lj lk b">a</code>变了，<code class="eh lh li lj lk b">b</code> <strong class="je hv"> </strong>依然如故。为什么？因为你从未改变过<code class="eh lh li lj lk b">b</code>。如果你想确保<code class="eh lh li lj lk b">b</code> <strong class="je hv"> </strong>仍然是<code class="eh lh li lj lk b">a * 3</code>，你必须这样做:</p><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="d9ec" class="lt kf hu lk b fv lu lv l lw lx">a = 5<br/>b = a * 3<br/>console.log(b) // 15</span></pre><p id="a10f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，这是可行的，但是如果每次<code class="eh lh li lj lk b">a</code>改变时都必须输入<code class="eh lh li lj lk b">b = a * 3 </code>会很烦人。我们可以通过将对<code class="eh lh li lj lk b">b</code>的更新封装在一个函数中来解决这个问题</p><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="ae23" class="lt kf hu lk b fv lu lv l lw lx">let b;<br/>function onUpdate() {<br/>  b = a * 3<br/>}</span><span id="e4de" class="lt kf hu lk b fv ly lv l lw lx">let a = 3<br/>onUpdate()<br/>console.log(b) // 9</span><span id="506f" class="lt kf hu lk b fv ly lv l lw lx">a = 5<br/>onUpdate()<br/>console.log(b) // 15</span></pre><p id="f33d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是，这仍然不是一个很好的做事方式。虽然在这个例子中问题不大，但想象一下，如果我们有10个不同的变量，它们都与另一个或多个变量有潜在的复杂关系。我们需要为每个变量使用单独的<code class="eh lh li lj lk b">onUpdate()</code> <em class="ka"> </em>方法。与其使用这种笨拙的命令式API，不如使用一种更简单、更具声明性的API，只做我们想让它做的事情。Evan将其比作电子表格，在电子表格中，我们可以更新一个单元格，并且知道依赖于我们更新的单元格的任何单元格都将自动更新自己。</p><figure class="ll lm ln lo fq iv fe ff paragraph-image"><div class="fe ff lz"><img src="../Images/4aa073b49b2a55ef16dee403512e1825.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/1*AYyu-J7PrkYJ69_N5IyNsg.gif"/></div></figure><h1 id="40c2" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">解决方法</h1><p id="f618" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">好消息是，人们已经想出了许多解决反应性问题的方法。事实上，三个主要的web开发框架都提供了反应性的解决方案:</p><ol class=""><li id="4b8c" class="ma mb hu je b jf jg jj jk jn mc jr md jv me jz mf mg mh mi dt translated"><strong class="je hv"> React的状态管理</strong>:创建一个函数<code class="eh lh li lj lk b">setState()</code>，当我们需要更新<code class="eh lh li lj lk b">a</code>时就使用它。然后，在<code class="eh lh li lj lk b">setState()</code>中，调用一个渲染函数来更新视图，以显示<code class="eh lh li lj lk b">b</code>的正确值。</li><li id="5c8b" class="ma mb hu je b jf mj jj mk jn ml jr mm jv mn jz mf mg mh mi dt translated"><strong class="je hv"> Angular的脏检查</strong>:创建一个函数<code class="eh lh li lj lk b">detectChanges()</code>，运行它所跟踪的每一个属性，检查自上次检查以来它是否发生了变化。如果它找到一个更新的属性(例如<code class="eh lh li lj lk b">a</code>，那么它更新使用该更新属性的每个属性(例如<code class="eh lh li lj lk b">b</code>)。然后，每隔几毫秒，只要符合逻辑，就运行<code class="eh lh li lj lk b">detectChanges()</code> <em class="ka"> </em>函数。</li><li id="775b" class="ma mb hu je b jf mj jj mk jn ml jr mm jv mn jz mf mg mh mi dt translated"><strong class="je hv"> Vue的反应系统</strong>:给每个被跟踪的属性添加ES5的getters和setters。每当访问被跟踪的属性时，将访问该属性的函数标记为“订户”。每当属性发生更改时，将更改通知每个订阅服务器。</li></ol><p id="20cb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们打算用纯JavaScript实现Vue的反应系统。在我们进入代码之前，让我们更详细地了解一下我们到底在构建什么。</p><h1 id="86bc" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">我们正在建造的东西</h1><figure class="ll lm ln lo fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mo"><img src="../Images/98210c160ee4f6ffa127c8c5d35b06ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L97hrVHJuZDKGGdpy8ktxA.png"/></div></div><figcaption class="mp mq fg fe ff mr ms bd b be z ek">Diagram of how Vue’s reactivity system works. Source: <a class="ae kb" href="https://vuejs.org/v2/guide/reactivity.html" rel="noopener ugc nofollow" target="_blank">https://vuejs.org/v2/guide/reactivity.htm</a></figcaption></figure><p id="b79d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将创建一个名为<strong class="je hv"> <em class="ka"> Watcher </em> </strong>的类，它接受两个属性:一个<strong class="je hv">值getter </strong>和一个<strong class="je hv">回调</strong>。值getter可以是任何有返回值的函数。示例:</p><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="afa0" class="lt kf hu lk b fv lu lv l lw lx">let a = 3<br/>const getter = () =&gt; a * 3</span></pre><p id="c334" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">getter可能会有<strong class="je hv">依赖关系</strong>，或者它所依赖的变量来获取它的值。在上面的例子中，<code class="eh lh li lj lk b">a</code>是getter函数的唯一依赖项。不过，Getter函数可以有多个依赖项。例如，<code class="eh lh li lj lk b">() =&gt; x * y</code>既有<code class="eh lh li lj lk b">x</code> <strong class="je hv"> </strong>又有<code class="eh lh li lj lk b">y</code> <strong class="je hv"> </strong>作为依赖。</p><p id="70fb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每当getter函数的依赖关系改变时，我们将自动运行回调函数，传入当前值和前一个值。这个回调可以做任何事情，从记录值到在div中显示值。</p><p id="cb72" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，我们将创建一个<code class="eh lh li lj lk b">defineReactive()</code> <em class="ka"> </em>函数，它将变化检测添加到一个对象的属性中。我们还将创建一个<code class="eh lh li lj lk b">walk()</code>函数，为对象的所有属性添加变化检测。这将允许对象的属性用作依赖项。我们将以与Vue相同的方式实现这种变化检测:通过定义ES5<a class="ae kb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get" rel="noopener ugc nofollow" target="_blank">getter和setter</a>。虽然这种方法确实有一些限制(在<a class="ae kb" href="https://vuejs.org/v2/guide/reactivity.html" rel="noopener ugc nofollow" target="_blank">文档</a>中有描述)，但是这是一种非常有效和简单的获得反应的方法，因为JavaScript引擎最终提供了变化检测。</p><blockquote class="mt mu mv"><p id="9e94" class="jc jd ka je b jf jg jh ji jj jk jl jm mw jo jp jq mx js jt ju my jw jx jy jz hn dt translated"><strong class="je hv">脚注:</strong>未发布的<a class="ae kb" href="https://blog.cloudboost.io/reactivity-in-vue-js-2-vs-vue-js-3-dcdd0728dcdf" rel="noopener ugc nofollow" target="_blank"> Vue 3将使用ES6代理</a>而不是getters和setters，但我相信Vue的其余反应系统不会改变太多。</p></blockquote><p id="01bc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我们完成时，我们将有一个通用的反应API。下面是它的用法示例:</p><figure class="ll lm ln lo fq iv"><div class="bz el l di"><div class="mz na l"/></div></figure><h1 id="784f" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">Deps</h1><p id="6329" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">第一步是实现<strong class="je hv"> <em class="ka"> Dep </em> </strong>类。<strong class="je hv"> <em class="ka"> Dep，</em></strong>dependency的简称，是一个值的包装器。我们的实现将直接基于<a class="ae kb" href="https://github.com/vuejs/vue/blob/dev/src/core/observer/dep.js" rel="noopener ugc nofollow" target="_blank"> Vue的<strong class="je hv"> <em class="ka"> Dep </em> </strong>类</a>。每个<strong class="je hv"> <em class="ka"> Dep </em> </strong>实例都维护一个订户列表，即<code class="eh lh li lj lk b">subs</code>，每当Dep的值发生变化时，所有人都想知道这个列表。这些订阅者是<strong class="je hv"> <em class="ka">观察器</em> </strong>类的实例，我们将在下一节中实现它。每当Dep的值改变时，每个<strong class="je hv"> <em class="ka"> Dep </em> </strong>实例负责调用每个订户的<code class="eh lh li lj lk b">update()</code> <em class="ka"> </em>方法。</p><p id="6126" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">尽管<strong class="je hv"> <em class="ka"> Dep </em> </strong>实例负责提醒订阅者某个值的变化，但每个<strong class="je hv"> <em class="ka"> Dep </em> </strong>实例实际上并不知道它在观察什么值。所以，它的每个<strong class="je hv"> <em class="ka"> Dep </em> </strong>实例都有一个<code class="eh lh li lj lk b">notify()</code> <em class="ka"> </em>方法，这让它知道它的值何时改变。稍后我们将更多地讨论谁调用了<code class="eh lh li lj lk b">notify()</code>，但是现在只要假设它在被监视的值改变时被调用。下面是一个工作<strong class="je hv"> <em class="ka">副</em> </strong>的实现:</p><figure class="ll lm ln lo fq iv"><div class="bz el l di"><div class="mz na l"/></div></figure><p id="9169" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">什么是<code class="eh lh li lj lk b">Dep.target</code>，它什么时候获得一个值？<code class="eh lh li lj lk b">Dep.target</code> <strong class="je hv"> </strong>是一个<strong class="je hv"> <em class="ka">观察器</em> </strong>实例，它让<strong class="je hv"> <em class="ka"> Dep </em> </strong>实例知道<strong class="je hv"> </strong>谁在使用它的值<em class="ka">。</em>这是必要的，因为<strong class="je hv"> <em class="ka"> Dep </em> </strong>实例需要将自己注册为目标观察器的依赖项。有两个函数<code class="eh lh li lj lk b">pushTarget()</code> <em class="ka"> </em>和<code class="eh lh li lj lk b">popTarget()</code>管理当前<em class="ka"> </em> <strong class="je hv"> Dep目标</strong>。这些看起来是这样的:</p><figure class="ll lm ln lo fq iv"><div class="bz el l di"><div class="mz na l"/></div></figure><p id="77b6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将在下一节详细讨论这些方法。</p><h1 id="b384" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">观察者</h1><p id="90cb" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">根据<a class="ae kb" href="https://github.com/vuejs/vue/blob/be9ac624c81bb698ed75628fe0cbeaba4a2fc991/src/core/observer/watcher.js" rel="noopener ugc nofollow" target="_blank">源代码</a>:</p><blockquote class="mt mu mv"><p id="ddac" class="jc jd ka je b jf jg jh ji jj jk jl jm mw jo jp jq mx js jt ju my jw jx jy jz hn dt translated">观察器解析表达式，收集依赖项，并在表达式值改变时触发回调。这用于$watch() api和指令。</p></blockquote><p id="ee1e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="ka"> Watcher </em> </strong>类接受一个<strong class="je hv"> getter </strong> <strong class="je hv">函数</strong>和一个<strong class="je hv">回调函数</strong>，并存储由getter函数计算的值的依赖关系数组。它跟踪依赖项的值，并在这些依赖项发生变化时运行回调函数。这里有一个例子:</p><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="d005" class="lt kf hu lk b fv lu lv l lw lx">let a = 5, b = 4</span><span id="ff5a" class="lt kf hu lk b fv ly lv l lw lx">const getter = () =&gt; a + b<br/>const callback = (val) =&gt; console.log(val)</span><span id="02d6" class="lt kf hu lk b fv ly lv l lw lx">const watcher = new Watcher(getter, callback)</span><span id="26f0" class="lt kf hu lk b fv ly lv l lw lx">a = 6 // 10 is logged to the console</span></pre><p id="5800" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Vue的代码中，<strong class="je hv"> <em class="ka"> Watcher </em> </strong>类有几个方法，但是，出于我们的目的，我们只需要实现其中的三个:</p><ol class=""><li id="1c5d" class="ma mb hu je b jf jg jj jk jn mc jr md jv me jz mf mg mh mi dt translated"><code class="eh lh li lj lk b">get()</code> <em class="ka">。</em>这个方法调用构造函数中提供的getter函数来计算初始值。在调用getter之前，它使用<strong class="je hv"><em class="ka"/></strong><code class="eh lh li lj lk b">pushTarget()</code><strong class="je hv"/>方法将自己设置为当前的<strong class="je hv"> <em class="ka"> Dep </em> </strong>目标观察者。这使得getter函数中使用的所有值都将添加<strong class="je hv"> <em class="ka">观察器</em> </strong>实例作为订阅者。这很重要，因为<strong class="je hv"> <em class="ka">观察器</em> </strong>实例需要以某种方式链接到它的依赖项，这样当它的一个依赖项的值改变时，它就可以得到通知。</li><li id="c248" class="ma mb hu je b jf mj jj mk jn ml jr mm jv mn jz mf mg mh mi dt translated"><code class="eh lh li lj lk b">addDep(dep)</code>T40。该方法将自身作为订阅者添加到给定的依赖项中。这个方法由<em class="ka"> Dep#depend() </em>方法调用，我们将在下一节更详细地讨论这个方法。</li><li id="9319" class="ma mb hu je b jf mj jj mk jn ml jr mm jv mn jz mf mg mh mi dt translated"><code class="eh lh li lj lk b">update()</code> <em class="ka">。</em>该方法使用旧值和新值作为参数调用构造函数中提供的回调函数。当<em class="ka"> Dep#notify() </em>方法在它的值改变后对它的每个订阅者调用<code class="eh lh li lj lk b">update</code>时，就会用到它。</li></ol><p id="5ac3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是我们的<strong class="je hv"> <em class="ka">观察者</em> </strong>类的代码:</p><figure class="ll lm ln lo fq iv"><div class="bz el l di"><div class="mz na l"/></div></figure><h1 id="42df" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated"><code class="eh lh li lj lk b">defineReactive()</code></h1><p id="5ee7" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">根据<a class="ae kb" href="https://github.com/vuejs/vue/blob/61187596b9af48f1cb7b1848ad3eccc02ac2509d/src/core/observer/index.js" rel="noopener ugc nofollow" target="_blank">源代码</a>、<code class="eh lh li lj lk b">defineReactive()</code>、<em class="ka">、</em>“定义一个对象上的反应属性”。这是通过向给定对象的给定属性添加getters和setters来实现的。每个属性都有一个<strong class="je hv"> <em class="ka"> Dep </em> </strong>实例与之相关联。每当访问一个反应对象的属性时，getter调用<em class="ka"> Dep#depend()，</em>将当前目标<strong class="je hv"> <em class="ka"> Watcher </em> </strong>作为订阅者添加到属性的<strong class="je hv"> <em class="ka"> Dep </em> </strong>实例中。每当属性被更改时，setter调用<em class="ka"> Dep#notify() </em>，后者调用属性的<strong class="je hv"> <em class="ka"> Dep </em> </strong> <em class="ka">的每个订阅者的<em class="ka"> update() </em>方法。</em>下面是<em class="ka"> defineReactive() </em>，基于源代码:</p><figure class="ll lm ln lo fq iv"><div class="bz el l di"><div class="mz na l"/></div></figure><h1 id="20ca" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">这一切是如何协同工作的</h1><p id="0889" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">现在我们已经写了反应系统的每一部分，但是它是如何工作的呢？系统的每个部分都与所有其他部分紧密相连，因此很难理解。让我们一步一步地看看在我们的<strong class="je hv"> <em class="ka">观察器</em> </strong>类的示例用法中发生了什么。</p><p id="e028" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将从设置好一切开始:</p><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="57cd" class="lt kf hu lk b fv lu lv l lw lx">const foods = { apple: 5 }</span><span id="0d39" class="lt kf hu lk b fv ly lv l lw lx">// make foods reactive, register deps for each property<br/>walk(foods)</span><span id="0407" class="lt kf hu lk b fv ly lv l lw lx">// Instantiate the watcher, which takes a getter and a callback<br/>const foodsWatcher = new Watcher(() =&gt; foods.apple,<br/>                                 () =&gt; console.log('change')<br/>                                 )</span></pre><p id="9df5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，<strong class="je hv"> <em class="ka">观察器</em> </strong>类的构造函数运行如下:</p><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="5634" class="lt kf hu lk b fv lu lv l lw lx">this.value = this.get()</span></pre><p id="fa65" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是<em class="ka">观察者#get() </em>:</p><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="dd6b" class="lt kf hu lk b fv lu lv l lw lx">pushTarget(this) // Imported from dep.js<br/>const value = this.getter()<br/>popTarget() // Imported from dep.js</span><span id="2f97" class="lt kf hu lk b fv ly lv l lw lx">return value</span></pre><p id="06d0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，它调用<code class="eh lh li lj lk b">pushTarget()</code> <em class="ka"> </em>函数，将<code class="eh lh li lj lk b">this</code><strong class="je hv"/><strong class="je hv"/><code class="eh lh li lj lk b">foodsWatcher</code>)赋值给<code class="eh lh li lj lk b">Dep.target</code>。<strong class="je hv"> </strong>然后，它调用<code class="eh lh li lj lk b">this.getter()</code> <em class="ka">，</em>第一个函数传递给<strong class="je hv"> <em class="ka">观察器</em> </strong>构造器。<code class="eh lh li lj lk b">foodsWatcher</code> <strong class="je hv"> <em class="ka"> </em> </strong>的getter只是返回<code class="eh lh li lj lk b">foods.apple</code>的值。由于<code class="eh lh li lj lk b">foods.apple</code>是由<code class="eh lh li lj lk b">defineReactive()</code> <em class="ka">，</em>激活的，它也将运行激活的getter:</p><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="00cf" class="lt kf hu lk b fv lu lv l lw lx">// adds Dep.target as a subscriber to the property's dep instance<br/>dep.depend()</span><span id="fea8" class="lt kf hu lk b fv ly lv l lw lx">return value</span></pre><p id="84bc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这将<code class="eh lh li lj lk b">foodsWatcher</code>注册为与<code class="eh lh li lj lk b">foods.apple</code>关联的<strong class="je hv"> <em class="ka"> Dep </em> </strong>实例的订阅者。所以现在在<code class="eh lh li lj lk b">foodsWatcher</code>和<code class="eh lh li lj lk b">foods.apple</code>之间有一个连接。</p><p id="0678" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这有什么帮助？假设我们改变<code class="eh lh li lj lk b">foods.apple</code>。</p><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="887e" class="lt kf hu lk b fv lu lv l lw lx">foods.apple = 6</span></pre><p id="45e8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这样做将调用<code class="eh lh li lj lk b">foods.apple</code>上的setter。setter运行<code class="eh lh li lj lk b">dep.notify()</code>，而<em class="ka"> </em>在dep的每个订户上调用<code class="eh lh li lj lk b">update()</code> <em class="ka"> </em>。由于<code class="eh lh li lj lk b">foodsWatcher</code>是<strong class="je hv"> <em class="ka"> Dep </em> </strong>实例的订阅者，因此<code class="eh lh li lj lk b">dep.notify()</code> <em class="ka"> </em>调用将触发<code class="eh lh li lj lk b">foodsWatcher</code>上的更新方法。<em class="ka"> Watcher#update() </em>是做什么的？</p><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="5e26" class="lt kf hu lk b fv lu lv l lw lx">update() {<br/>  const value = this.get()<br/>  const oldValue = this.value<br/>  this.value = value</span><span id="81fd" class="lt kf hu lk b fv ly lv l lw lx">  this.cb(value, oldValue)<br/>}</span></pre><p id="287e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它更新其对当前值的了解，然后调用构造函数中提供的回调。记得我们指定的回调是</p><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="ba50" class="lt kf hu lk b fv lu lv l lw lx">() =&gt; console.log('change')</span></pre><p id="16e4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以，当我们改变<code class="eh lh li lj lk b"><strong class="je hv">foods.apple</strong></code>时，我们的反应系统会让我们知道！最酷的是，这种情况的发生并没有每毫秒进行一次脏检查。它的发生不需要我们显式地设置状态。它就是<em class="ka">起作用了</em>，根本不用我们去想它，就像一个电子表格。这就是Vue的反应系统如此不可思议的原因。</p><p id="a694" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你想在一个地方看到我们反应系统的所有代码，我做了一个非常酷的演示。感谢阅读！</p><h1 id="348f" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">资源</h1><ul class=""><li id="48b6" class="ma mb hu je b jf lc jj ld jn nb jr nc jv nd jz ne mg mh mi dt translated">我去的<a class="ae kb" href="https://frontendmasters.com/live-event/vue-js-advanced-features-ground/" rel="noopener ugc nofollow" target="_blank">前端硕士课程</a>(如果你有前端硕士订阅的话)</li><li id="3f97" class="ma mb hu je b jf mj jj mk jn ml jr mm jv mn jz ne mg mh mi dt translated">Vue的<a class="ae kb" href="https://vuejs.org/v2/guide/reactivity.html" rel="noopener ugc nofollow" target="_blank">关于反应性的文件</a></li><li id="c866" class="ma mb hu je b jf mj jj mk jn ml jr mm jv mn jz ne mg mh mi dt translated">埃文在2016年做的关于反应性的演讲</li><li id="b8c8" class="ma mb hu je b jf mj jj mk jn ml jr mm jv mn jz ne mg mh mi dt translated">Vue的<a class="ae kb" href="https://github.com/vuejs/vue/tree/dev/src/core/observer" rel="noopener ugc nofollow" target="_blank">源代码</a>(终极参考)</li></ul></div></div>    
</body>
</html>