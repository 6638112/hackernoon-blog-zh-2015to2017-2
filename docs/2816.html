<html>
<head>
<title>Hacking Android phone. How deep the rabbit hole goes.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">黑安卓手机。兔子洞有多深。</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/hacking-android-phone-how-deep-the-rabbit-hole-goes-18b62ad65727?source=collection_archive---------2-----------------------#2017-02-21">https://medium.com/hackernoon/hacking-android-phone-how-deep-the-rabbit-hole-goes-18b62ad65727?source=collection_archive---------2-----------------------#2017-02-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/fff3a95e5f6450128495e964cf0a6981.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Z257Z4inYArHt-j0.jpg"/></div></div></figure><p id="c694" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我的第一部Android手机Galaxy Note N7000是在2011年10月发布会后买的。多亏了一个叫bauner的德国人，我有机会使用最新版本的CyanogenMod(现在是<a class="ae ka" href="https://forum.xda-developers.com/galaxy-note/development/rom-nightowl-preview-t3455847" rel="noopener ugc nofollow" target="_blank"> LineageOS </a>)。不幸的是，我的手机在大约一年半前使用廉价的中国汽车充电器后死亡。</p><p id="f629" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我花了很长时间寻找替代品，停在了<a class="ae ka" href="https://ru.wikipedia.org/wiki/Kyocera" rel="noopener ugc nofollow" target="_blank">京瓷</a>(是的，他们生产手机)KC-S701。看起来挺野蛮的，没有触摸按键。我甚至没有想过要以root用户身份访问电话。我确信现在每部手机都有可能获得root。总会有人能把CyanogenMod移植到它上面。我弄错了。</p><p id="677b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在一年半的时间里，只发布了一个内核更新— <a class="ae ka" href="https://github.com/torvalds/linux/commit/a134f083e79fb4c3d0a925691e732c56911b4326" rel="noopener ugc nofollow" target="_blank">修复</a>解决了一个特制ping数据包上的内核故障。此外，一年前，Android KitKat已经被认为是相当老了。不幸的是，既没有信息，也不可能获得根访问。同样的硬件也用于名为京瓷准将E6782的美国版手机。默认情况下，它具有快速启动模式，无法启动未签名的内核(只能启动，不能闪存，只能使用旧的易受攻击的引导加载程序，<a class="ae ka" href="https://www.codeaurora.org/projects/security-advisories/fastboot-boot-command-bypasses-signature-verification-cve-2014-4325" rel="noopener ugc nofollow" target="_blank">CVE-2014–4325</a>)，此外，它还提供了一个通过按下手机按钮启动到快速启动和恢复模式的机会。通过威瑞森(或者京瓷)的努力？)安卓版的准将已经更新到棒棒糖了。</p><p id="6407" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">于是，我决定自己处理在Android上获取root的过程。</p><p id="6468" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">两个月前，我对Android内部一无所知(实际上，现在<a class="ae ka" href="https://en.wikipedia.org/wiki/I_know_that_I_know_nothing" rel="noopener ugc nofollow" target="_blank">我甚至不知道更多</a>)。大多数知识是通过阅读源代码和实验获得的，因为互联网上缺乏关于Android黑客的信息。以下信息适用于Android 4.4 KitKat，但我认为也有可能应用于新版本。</p><p id="a45b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我想提请你注意的是，这篇文章中描述的信息只是我个人在特定手机型号上的Android黑客经验，所以如果你不想破坏手机，请小心使用它。如果你想用这篇文章来修复你的手机，我建议你忘记你在日常生活中使用你的手机，做一个备份，然后进行硬重置。这将在出现致命错误时保护您的数据。</p><p id="9686" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这篇文章不仅描述了导致成功的行动，也描述了错误。我希望我为达到期望的结果所做的尝试，以及无数次的失败，会让你感兴趣。</p><p id="4103" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这项研究是在Linux环境下进行的。</p><h1 id="5c6d" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">dirty cow(CVE-2016–5195)</h1><p id="5913" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">简而言之，dirty cow(<a class="ae ka" href="https://github.com/timwr/CVE-2016-5195" rel="noopener ugc nofollow" target="_blank">Android的工作漏洞</a>)允许你替换任何进程的内存(如果你熟悉汇编就很有用)，或者任何可供读取的文件，即使它在只读文件系统中。建议哄骗大小大于或等于替换大小的文件。dirtycow for Android的主要攻击是<code class="eh le lf lg lh b">/system/bin/run-as</code>欺骗。它是Android中的某种<code class="eh le lf lg lh b">sudo</code>，允许调试应用程序。由于<strong class="je hv"> android-19 </strong> API(参见<a class="ae ka" href="https://source.android.com/source/build-numbers.html" rel="noopener ugc nofollow" target="_blank">匹配API和android版本的表格</a>)<code class="eh le lf lg lh b">/system/bin/run-as</code>具有<strong class="je hv"> CAP_SETUID </strong>和<strong class="je hv"> CAP_SETGID </strong>功能标志(在旧版本中使用suid位- <code class="eh le lf lg lh b">6755</code>):</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="5e20" class="lq kc hu lh b fv lr ls l lt lu">$ getcap bin/run-as<br/>bin/run-as = cap_setgid,cap_setuid+ep</span></pre><p id="84ab" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果文件系统是以读写模式装载的，dirtycow欺骗的所有内容都将被写入文件系统。因此，您必须备份原始文件，并在获得root访问权限后恢复它，或者不要以读写模式重新挂载文件系统。一般Android中的<strong class="je hv"> /system </strong>分区默认以只读方式挂载。</p><p id="dade" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是为什么dirtycow被认为是Linux中发现的最严重的漏洞之一。使用适当的知识，您可以绕过内核的所有安全级别，包括SELinux。</p><h1 id="c963" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">SELinux</h1><p id="7e35" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">初学者应该知道SELinux上下文是如何工作的。Gentoo wiki里有一篇很好的文章:<a class="ae ka" href="https://wiki.gentoo.org/wiki/SELinux/Tutorials/How_does_a_process_get_into_a_certain_context" rel="noopener ugc nofollow" target="_blank">https://wiki . Gentoo . org/wiki/SELinux/Tutorials/How _ does _ a _ process _ get _ into _ a _ certain _ context</a></p><p id="ac82" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">简而言之，你应该知道以下几点:</p><ul class=""><li id="3ae7" class="lv lw hu je b jf jg jj jk jn lx jr ly jv lz jz ma mb mc md dt translated">如果在sepolicy规则(上下文转换)中描述了这样的操作，则可以更改SELinux进程上下文。Android 4.4 (KitKat)提供了通过改变SELinux上下文来提升权限的可能性。从Android 5.x开始，这已经不可能了。</li><li id="6bc8" class="lv lw hu je b jf me jj mf jn mg jr mh jv mi jz ma mb mc md dt translated">有文件上下文。</li><li id="60ea" class="lv lw hu je b jf me jj mf jn mg jr mh jv mi jz ma mb mc md dt translated">除了进程和文件上下文，Android还实现了自己的<strong class="je hv"> property_contexts </strong>。</li><li id="9e3d" class="lv lw hu je b jf me jj mf jn mg jr mh jv mi jz ma mb mc md dt translated">规则如下:源上下文(应用程序)被允许访问目标上下文(文件系统)。在SELinux强制模式下，应用程序只允许执行明确授权的操作。其余的是禁止的。</li></ul><h1 id="5466" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">Adbd和控制台</h1><p id="8773" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在生产Android设备中获得部分特权外壳的唯一可能方式是开发者模式。开发者模式启动adbd守护进程，它可以充当某种ssh / telnet服务器。在Android KitKat <code class="eh le lf lg lh b">/sbin/adbd</code>中，二进制文件位于<a class="ae ka" href="https://en.wikipedia.org/wiki/Initramfs" rel="noopener ugc nofollow" target="_blank"> initramfs </a>中，对于非root用户来说是不可读的。最初，adbd作为根用户执行，它运行在<strong class="je hv"> u:r:init:s0 </strong> SELinux上下文中(由init使用，通常比其他上下文有更多的特权)。如果<code class="eh le lf lg lh b">/init.rc</code>有明确指定的进程上下文，如<strong class="je hv"> seclabel u:r:adbd:s0 </strong>，进程将在该上下文中立即开始。在初始化的情况下，根据编译选项(<a class="ae ka" href="https://source.android.com/source/building.html#choose-a-target" rel="noopener ugc nofollow" target="_blank"> user、userdebug或eng </a>和Android设置(<a class="ae ka" href="http://rxwen.blogspot.com/2010/01/android-property-system.html%5D" rel="noopener ugc nofollow" target="_blank"> properties </a>)，adbd降低特权:它将当前用户更改为shell，将SELinux上下文设置为<strong class="je hv"> u:r:shell:s0 </strong>，并修剪除<strong class="je hv"> CAP_SETUID </strong>和<strong class="je hv"> CAP_SETGID </strong>之外的所有系统功能(这是通过<code class="eh le lf lg lh b">run-as</code>调试应用程序所必需的)。<strong class="je hv">功能限制集</strong>不允许应用程序升级功能，只能删除它们。这些特权允许你做更多的事情。您可以使用下面的命令<code class="eh le lf lg lh b">cat /proc/self/status | grep CapBnd</code>查看当前进程的能力。例如，用<code class="eh le lf lg lh b">capsh</code>命令(Android上没有)解密它们。：</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="1578" class="lq kc hu lh b fv lr ls l lt lu">$ capsh --decode=0000001fffffffff<br/>0x0000001fffffffff=cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend</span></pre><p id="c434" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以使用<code class="eh le lf lg lh b">id</code>或<code class="eh le lf lg lh b">cat /proc/self/attr/current</code>命令查看当前的SELinux上下文。可以通过<code class="eh le lf lg lh b">cat /proc/self/attr/prev</code>查看以前的上下文。</p><p id="731e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">查看文件的上下文:<code class="eh le lf lg lh b">ls -Z</code></p><p id="4493" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">查看正在运行的进程的上下文:<code class="eh le lf lg lh b">ps -Z</code></p><h1 id="e17a" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">获得root访问权限</h1><p id="7b41" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我做的第一件事是使用dirtycow来实现它的预期目的——欺骗<code class="eh le lf lg lh b">/system/bin/run-as</code>,它允许我将UID / GID设置为0(和<code class="eh le lf lg lh b">su</code>做的一样)。然而，我无法挂载文件系统(以及tmpfs)，无法加载内核模块和查看<code class="eh le lf lg lh b">dmesg</code>。我甚至无法浏览拥有0700权限并属于其他系统用户的目录。我只能读写块设备。只有当适当的UID / GID被设置为指定的用户时，查看文件或目录才是可能的(我发明了自己的<a class="ae ka" href="https://github.com/kayrus/CVE-2016-5195/blob/3d8262a5399bd91d187533095361995c98974040/run.c" rel="noopener ugc nofollow" target="_blank">轮</a> - <code class="eh le lf lg lh b">su</code>选择，它设置SELinux上下文和用户/组)。这有助于我理解内部)。</p><p id="8cd0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后我转储了整个固件，引导和恢复:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="5487" class="lq kc hu lh b fv lr ls l lt lu">$ dd if=/dev/block/mmcblk0 of=/storage/sdcard1/mmcblk0.img<br/>$ dd if=/dev/block/platform/msm_sdcc.1/by-name/boot of=/storage/sdcard1/boot.img<br/>$ dd if=/dev/block/platform/msm_sdcc.1/by-name/recovery of=/storage/sdcard1/recovery.img</span></pre><p id="25a4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以使用<code class="eh le lf lg lh b">kpartx</code>和<code class="eh le lf lg lh b"><a class="ae ka" href="https://github.com/osm0sis/mkbootimg" rel="noopener ugc nofollow" target="_blank">unpackbootimg</a></code>等实用程序来检查完整的转储。<code class="eh le lf lg lh b">kpartx -a mmbblk0.img</code>命令创建一个可通过<code class="eh le lf lg lh b">/dev/mapper/loop0</code>路径使用的虚拟块设备。您可以像使用常规块设备一样使用转储。引导和恢复分区的转储可以使用<code class="eh le lf lg lh b">unpackbootimg</code>来解包。</p><p id="a47f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后我试图<strong class="je hv">零</strong>恢复，只是为了检查写操作是否工作，然后立即从转储中恢复恢复。</p><p id="9814" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我可以写入块设备，那么我也可以编写自定义恢复。我找到了准将的TWRP，闪入恢复分区，重启手机:<code class="eh le lf lg lh b">adb reboot recovery</code>。我没有看到任何与TWRP有关的东西，只有带感叹号的安卓图标。这看起来像一个标准的Android恢复，不像TWRP。</p><p id="bbe7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我重启手机进入正常模式，运行漏洞并检查恢复分区的哈希——哈希与原始分区匹配。我试图再次写入数据—哈希已更改！然后我想起了Linux页面缓存，并刷新它(<code class="eh le lf lg lh b">echo 3 &gt; /proc/sys/vm/drop_caches</code>)——哈希值再次与原始值匹配。因此，我写入块设备的所有内容都被“重定向”到<code class="eh le lf lg lh b">/dev/null</code>中，没有任何错误，有时还会存放在Linux缓存中。但是固件更新是如何工作的呢？以及用户数据是如何存储到内存中的？我不得不进一步挖掘。</p><h1 id="08bb" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">试图禁用SELinux</h1><p id="ba79" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">当时我认为所有的限制都是由于缺少SELinux特权造成的(我完全忘记了功能的减少)。我无法查看dmesg，logcat没有显示任何相关内容。我开始思考如何禁用SELinux。</p><p id="325e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我能找到的第一条线索是:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="63a8" class="lq kc hu lh b fv lr ls l lt lu">$ grep -A2 reload_policy boot_initramfs/init.rc<br/>on property: selinux.reload_policy = 1<br/>     restart ueventd<br/>     restart installd</span></pre><p id="b329" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://android.googlesource.com/platform/system/core/+/android-4.4.2_r2/init/property_service.c#350" rel="noopener ugc nofollow" target="_blank">源代码</a>说当你改变这个选项时，init从<code class="eh le lf lg lh b">/sepolicy</code>文件中重新读取和加载SELinux策略。</p><p id="b075" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为我使用的是dirtycow，所以我可以覆盖<code class="eh le lf lg lh b">/sepolicy</code>并执行<code class="eh le lf lg lh b">setprop selinux.reload_policy 1</code>命令来重新加载更新后的策略。</p><p id="44a0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先你必须弄清楚<code class="eh le lf lg lh b">/sepolicy</code>文件里面是什么。您可以使用<code class="eh le lf lg lh b">sesearch</code>命令(Debian中的<code class="eh le lf lg lh b">setools</code>包)来读取它的规则。</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="a81d" class="lq kc hu lh b fv lr ls l lt lu">$ sesearch --allow sepolicy<br/>$ sesearch --neverallow sepolicy<br/>$ sesearch --auditallow sepolicy<br/>$ sesearch --dontaudit sepolicy</span></pre><p id="94b7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我的例子中,<code class="eh le lf lg lh b">/sepolicy</code>文件只包含<strong class="je hv">允许</strong>规则，这意味着——当SELinux处于强制模式时，应用程序只被允许做策略中授权的事情。因此允许init进程重新加载策略，但不允许它改变实施模式:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="3b7d" class="lq kc hu lh b fv lr ls l lt lu">$ sesearch --allow sepolicy | grep 'load_policy'<br/>  allow init kernel: security load_policy;</span></pre><p id="dd37" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我的目标是允许init上下文将强制模式设置为permissive (setenforce 0)。</p><p id="8a2c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我做的第一步:从库存的Android KitKat构建一个标准策略，替换原来的<code class="eh le lf lg lh b">/sepolicy</code>，加载(作为root: <code class="eh le lf lg lh b">setprop selinux.reload_policy 1</code>)并在状态栏中收到一条消息，表明手机处于无保护模式(稍后会有关于此通知的更多细节)。在那之后，手机拒绝运行应用程序，变得非常周到，除此之外，我仍然无法设置许可模式，因此手机最终重启。否定结果也是结果，<code class="eh le lf lg lh b">/sepolicy</code>替换有效。</p><p id="9adc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我的第一个想法是:股票政策不适合这款手机，由于缺乏权限，它开始出现故障。</p><p id="2a0b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，我决定重新构建原来的策略，并向shell上下文添加尽可能多的特权。</p><p id="9675" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我找到了一篇<a class="ae ka" href="https://ge0n0sis.github.io/posts/2015/12/exploring-androids-selinux-kernel-policy/" rel="noopener ugc nofollow" target="_blank">文章</a>，它解释了如何“逆向工程”该政策。我能够解决所有的依赖关系并运行<code class="eh le lf lg lh b"><a class="ae ka" href="https://github.com/kayrus/sedump/" rel="noopener ugc nofollow" target="_blank">sedump</a></code>实用程序。结果，我收到了一个文本文件，我能够把它编译成二进制格式(KitKat的<code class="eh le lf lg lh b">checkpolicy -M -c 26 -o sepolicy.new policy.conf</code>)，甚至得到了一个和原来的<code class="eh le lf lg lh b">sepolicy</code>大小完全一样，但是十六进制内容不同的文件。加载新的策略文件导致了与之前完全相同的结果——几分钟后手机重启。</p><p id="8667" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我决定从以下文件中编译两个策略:原始反编译的<code class="eh le lf lg lh b">policy.conf</code>和拥有<code class="eh le lf lg lh b">allow init kernel: security</code>内所有权限的<code class="eh le lf lg lh b">policy.conf</code>，包括<strong class="je hv"> setenforce </strong>。这些文件的比较可以告诉我哪些字节我必须替换原始的<code class="eh le lf lg lh b">sepolicy</code>二进制文件。</p><p id="a4f3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">原来只改了两个字节。我试图在原始的<strong class="je hv">策略</strong>中找到匹配，但是我找不到。然后我写了一个强力脚本，将两个字节替换为“0xFF，0xFF”，启动<code class="eh le lf lg lh b">sesearch --allow | grep "desired result"</code>，如果不符合结果，就尝试替换下一个递增偏移量上的字节，依此类推。几分钟后，脚本在原始策略中找到了必要的偏移量。我替换了字节，在电话里伪造了原来的政策。此时它工作正常，没有重新启动。但是我仍然无法禁用SELinux强制模式。</p><p id="8861" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">过了一会儿，我发现了一个可以修改二进制文件的<a class="ae ka" href="https://bitbucket.org/joshua_brindle/sepolicy-inject/" rel="noopener ugc nofollow" target="_blank"> sepolicy-inject </a>实用程序。它可以添加新的许可SELinux上下文，或者将功能添加到现有规则中。虽然添加许可上下文会增加<code class="eh le lf lg lh b">sepolicy</code>文件，但修改现有规则不会增加文件大小。不幸的是，该工具每次运行只添加一个权限。我不得不编写另一个脚本来授予每个规则所有的功能。新策略文件的大小与原始文件的大小相匹配。但是，政策再一次没有帮助。</p><p id="9360" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后我注意到Android有<code class="eh le lf lg lh b">load_policy</code>命令可以从任何路径重新加载策略:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="1152" class="lq kc hu lh b fv lr ls l lt lu"># it has to be executed under system user<br/># since /sys/fs/selinux/policy is owned by system user in my phone<br/>adb shell run-as /data/local/tmp/run -u system -c u:r:init:s0 load_policy /data/local/tmp/sepolicy.new</span></pre><p id="4a32" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">或者这样:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="0570" class="lq kc hu lh b fv lr ls l lt lu">$ run-as /data/local/tmp/run -u system -c u:r:init:s0 sh -c "cat my_policy &gt; /sys/fs/selinux/load"</span></pre><p id="2613" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以添加任何许可域，加载新策略并在该域的上下文中工作(顺便说一下，chainfire <a class="ae ka" href="https://su.chainfire.eu/#selinux-contexts-basics" rel="noopener ugc nofollow" target="_blank">的supersu对于新的Android版本以相同的方式工作</a>)。但即使这样也没有给我禁用SELinux的可能性。我决定从另一个方向挖掘。</p><h1 id="9842" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">调查恢复</h1><figure class="li lj lk ll fq iv fe ff paragraph-image"><div class="fe ff mj"><img src="../Images/8d9ff3a6aa460e90dd4fa56ea094e0f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/format:webp/0*SgsxgI_J9cB6qf8U.png"/></div></figure><p id="f82f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我从检查引导分区和恢复分区之间的差异开始。除了initramfs之外，它们是相同的。恢复分区的initramfs有<code class="eh le lf lg lh b">init.rc</code>，它只有一个执行<code class="eh le lf lg lh b">/sbin/recovery</code>的服务。调查<code class="eh le lf lg lh b">strings sbin/recovery | less</code>输出和读取<a class="ae ka" href="https://android.googlesource.com/platform/bootable/recovery/+/android-4.4.4_r2/recovery.cpp" rel="noopener ugc nofollow" target="_blank">原始恢复源代码</a>得出以下结果:</p><ul class=""><li id="f3e6" class="lv lw hu je b jf jg jj jk jn lx jr ly jv lz jz ma mb mc md dt translated">默认恢复只是显示Android徽标，然后在超时后重新启动</li><li id="ee91" class="lv lw hu je b jf me jj mf jn mg jr mh jv mi jz ma mb mc md dt translated">如果你想“进入”恢复，你必须创建一个<code class="eh le lf lg lh b">/cache/recovery/command</code>文件，里面有相应的命令，即<code class="eh le lf lg lh b">--show_text</code>，它将显示恢复菜单。</li></ul><p id="e55f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我编写了文件并执行了<code class="eh le lf lg lh b">adb reboot recovery</code>命令。手机重新启动，我能够看到标准的恢复菜单。至少有些结果。我试图通过<code class="eh le lf lg lh b">adb sideload</code>刷新supersu ZIP文件。操作因出错而终止。我并没有真正注意这个错误，而是开始研究负责ZIP数字签名验证的恢复代码。</p><p id="7a30" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">原来，恢复initramfs包含一个<a class="ae ka" href="https://github.com/IanHarvey/minicrypt" rel="noopener ugc nofollow" target="_blank"> minicrypt </a>格式的<code class="eh le lf lg lh b">res/keys</code>公钥，用于检查ZIP文件的数字签名。公钥似乎是一个标准的Android测试密钥，所以我可以用这个密钥签署任何ZIP文件。您可以使用下面的命令检查该密钥:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="b2e5" class="lq kc hu lh b fv lr ls l lt lu">$ java -jar dumpkey.jar android/bootable/recovery/testdata/testkey.x509.pem &gt; mykey<br/>$ diff -u mykey res/keys</span></pre><p id="08ac" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我试图直接从sdcard安装ZIP，但是在安装sdcard时恢复导致了一个错误。对<code class="eh le lf lg lh b">etc/recovery.fstab</code>文件的调查显示了实际问题:恢复模式下的SD卡被安装为vfat:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="5d1b" class="lq kc hu lh b fv lr ls l lt lu">$ grep mmcblk1 recovery/ramfs/etc/recovery.fstab<br/>/dev/block/mmcblk1p1/sdcard vfat nosuid, nodev, barrier = 1, data = ordered, nodelalloc wait</span></pre><p id="55fe" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我的64Gb卡是用exFAT格式化的。我找到了一个旧的2Gb卡，将其重新格式化为vfat，编写了ZIP并将其插入手机。这一次恢复能够安装卷，我可以在手机上查看它的内容。但是，ZIP安装再次导致错误:<strong class="je hv"> E:无法设置安装所需的挂载；中止</strong>。</p><p id="dcd9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh le lf lg lh b">strings recovery | less</code>命令显示这次恢复有自定义的Kyocera字符串，至少有与<code class="eh le lf lg lh b">/data</code>分区擦除命令相关的字符串。在阅读原始源代码后，我发现这个错误是由<code class="eh le lf lg lh b"><a class="ae ka" href="https://android.googlesource.com/platform/bootable/recovery/+/android-4.4.2_r2%20/roots.cpp#206" rel="noopener ugc nofollow" target="_blank">roots.cpp</a></code>文件的<code class="eh le lf lg lh b">setup_install_mounts</code>函数引起的。由于某种原因，恢复未能卸载<code class="eh le lf lg lh b">recovery/ramfs/etc/recovery.fstab</code>中列出的所有分区。</p><h1 id="2af6" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">调查内核源代码</h1><p id="6e4c" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">与AOSP的Apache许可证不同，GPLv2许可证要求智能手机制造商发布Linux内核源代码。感谢莱纳斯和斯托曼给我这个机会。有时制造商发布假的源代码，有时是正确的，但没有<code class="eh le lf lg lh b">defconfig</code>文件，有时有<code class="eh le lf lg lh b">defconfig</code>，很少带有如何构建源代码的说明(例如LG)。</p><p id="0b49" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我的例子中，源代码是和正确的<code class="eh le lf lg lh b">defconfig</code>一起发布的，但是没有说明。因此，我花了一些时间来构建内核。</p><p id="e90f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">经过长时间的源代码研究，我停在了两个文件上:</p><ul class=""><li id="516d" class="lv lw hu je b jf jg jj jk jn lx jr ly jv lz jz ma mb mc md dt translated"><a class="ae ka" href="https://github.com/kayrus/kc-s701-torque-kernel/blob/master/security/selinux/hooks.c" rel="noopener ugc nofollow" target="_blank">https://github . com/Kay RUS/KC-s701-torque-kernel/blob/master/security/selinux/hooks . c</a></li><li id="f982" class="lv lw hu je b jf me jj mf jn mg jr mh jv mi jz ma mb mc md dt translated"><a class="ae ka" href="https://github.com/kayrus/kc-s701-torque-kernel/blob/master/arch/arm/mach-msm/restart.c" rel="noopener ugc nofollow" target="_blank">https://github . com/Kay RUS/KC-s701-torque-kernel/blob/master/arch/arm/mach-MSM/restart . c</a></li></ul><h1 id="d7ee" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">钩住</h1><p id="9c05" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">为了增加手机的安全性，京瓷刚刚在潜在的危险操作上实现了自定义的SELinux挂钩:<code class="eh le lf lg lh b">mount</code>、<code class="eh le lf lg lh b">umount</code>、<code class="eh le lf lg lh b">insmod</code>(唯一允许加载的模块是<code class="eh le lf lg lh b">wlan</code>，并且只有当它由init进程或非root用户加载时)和其他一些。这是恢复失败的实际原因。它无法卸载<code class="eh le lf lg lh b">/system</code>分区！只允许init进程进行<code class="eh le lf lg lh b">/system</code>分区的安装/卸载操作。特别是，我不能禁用SELinux，因为这个特性在内核编译时被禁用了。只有当内核加载了某些引导参数时，这些钩子才会被绕过(<strong class="je hv"> kcdroidboot.mode=f-ksg </strong>或<strong class="je hv">androidboot . mode = KC factory</strong>)。</p><h1 id="46d0" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">重新开始</h1><p id="167e" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">该文件描述了电话可能的重新启动选项:</p><ul class=""><li id="0cd5" class="lv lw hu je b jf jg jj jk jn lx jr ly jv lz jz ma mb mc md dt translated"><strong class="je hv"> adb reboot bootloader </strong> —快速启动模式，在我的手机中不可用(<code class="eh le lf lg lh b">0x77665500</code> - <code class="eh le lf lg lh b">00556677</code>分区中的十六进制标记)</li><li id="dc1e" class="lv lw hu je b jf me jj mf jn mg jr mh jv mi jz ma mb mc md dt translated"><strong class="je hv"> adb重启恢复</strong> —默认Android恢复模式(<code class="eh le lf lg lh b">sbl1</code>分区中的<code class="eh le lf lg lh b">0x77665502</code> - <code class="eh le lf lg lh b">02556677</code>十六进制标记)</li><li id="b15a" class="lv lw hu je b jf me jj mf jn mg jr mh jv mi jz ma mb mc md dt translated"><strong class="je hv"> adb重启RTC</strong>——所谓<code class="eh le lf lg lh b">ALARM_BOOT</code>。我不明白这是干什么用的，在<code class="eh le lf lg lh b">sbl1</code>中没有十六进制符号。大概和<a class="ae ka" href="https://developer.android.com/reference/android/app/AlarmManager.html" rel="noopener ugc nofollow" target="_blank">https://developer . Android . com/reference/Android/app/alarm manager . html</a>有关</li><li id="6d24" class="lv lw hu je b jf me jj mf jn mg jr mh jv mi jz ma mb mc md dt translated"><strong class="je hv"> adb重启oem-X </strong>(在我的例子中是oem-1，<code class="eh le lf lg lh b">0x6f656d01</code> - <code class="eh le lf lg lh b">016d656f</code>十六进制标记在<code class="eh le lf lg lh b">sbl1</code>分区中)。制造商定义了在这种模式下会发生什么。据消息人士称，如果位于<code class="eh le lf lg lh b">modem</code>分区的固件文件验证失败，手机将重启进入该模式。</li><li id="8e6f" class="lv lw hu je b jf me jj mf jn mg jr mh jv mi jz ma mb mc md dt translated"><strong class="je hv"> adb重启edl </strong> —紧急下载，重启进入默认的高通下载模式。手机标识为<strong class="je hv"> QHSUSB__BULK </strong> COM口，可以用来引导一个自定义的bootloader(但要用手机型号对应的私钥签名)，用你的手机进行底层操作，包括闪烁、解锁等。通常与QPST应用程序一起使用。对于一些手机来说，这些引导程序已经泄露到互联网上。</li><li id="aded" class="lv lw hu je b jf me jj mf jn mg jr mh jv mi jz ma mb mc md dt translated">某个<strong class="je hv">下载模式</strong>，可以由内核引导参数触发。看起来挺有意思的。</li></ul><p id="cc12" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一些关于高通手机如何启动的信息:</p><p id="13c5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">内置ROM高通引导程序(pbl —主引导程序)验证并引导<code class="eh le lf lg lh b">sbl1</code>分区(辅助引导程序)。<code class="eh le lf lg lh b">sbl1</code>验证并引导<code class="eh le lf lg lh b">tz</code>(信任区)，然后<code class="eh le lf lg lh b">aboot</code>(安卓引导，小内核，lk)。然后aboot可以引导到内置的快速启动维护模式，进行正常引导或引导到恢复或fota。</p><p id="b642" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">启动时涉及的分区描述:</p><ul class=""><li id="c60d" class="lv lw hu je b jf jg jj jk jn lx jr ly jv lz jz ma mb mc md dt translated">tz——高通信任区。它执行低级操作，包括使用QFuses (rpmb安全mmc分区)。</li><li id="e605" class="lv lw hu je b jf me jj mf jn mg jr mh jv mi jz ma mb mc md dt translated">rpm —资源和电源管理器固件。专用SoC的固件，负责资源和电源。</li><li id="65c2" class="lv lw hu je b jf me jj mf jn mg jr mh jv mi jz ma mb mc md dt translated">sdi —信任区域存储分区。信任区域使用的数据。</li></ul><p id="5804" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所有这些分区都由证书链签名。</p><h1 id="4bad" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">厚实棉布</h1><p id="a3dc" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在某些情况下，忽略固件更新是有用的。</p><p id="c7bf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">FOTA——固件空中下载。与引导或恢复不同，fota是一种非官方的Android引导模式。Fota的任务是更新固件。京瓷使用<a class="ae ka" href="https://en.wikipedia.org/wiki/Red_Bend_Software" rel="noopener ugc nofollow" target="_blank"> Red Bend </a>专利解决方案，适合35Mb的全部更新。包括<code class="eh le lf lg lh b">boot</code>、<code class="eh le lf lg lh b">tz</code>、<code class="eh le lf lg lh b">recovery</code>、<code class="eh le lf lg lh b">fota</code>甚至<code class="eh le lf lg lh b">system</code>分区的更新。这就是为什么<code class="eh le lf lg lh b">/system</code>分区在只读模式下可用。如果你修改这个分区，基于差异的fota更新可以砖手机。</p><p id="8e45" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我的手机从2015年9月开始更新。我没有更新我的手机，因为我害怕失去一个扎根我手机的机会。现在我可以轻松地执行更新过程，因为我可以完全访问<code class="eh le lf lg lh b">/cache</code>分区，并随时中止更新过程。</p><p id="3679" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在检查了负责的<a class="ae ka" href="http://www.javadecompilers.com/apktool" rel="noopener ugc nofollow" target="_blank">基于Java的</a>更新工具的源代码后，我很清楚它是如何工作的:</p><ul class=""><li id="766c" class="lv lw hu je b jf jg jj jk jn lx jr ly jv lz jz ma mb mc md dt translated">Java app将一个特殊的delta文件下载到<code class="eh le lf lg lh b">/cache/delta/boot_delta.bin</code>中，创建一个<code class="eh le lf lg lh b">/cache/delta/Alt-OTA_dlcomplete</code>文件，验证delta文件是否下载成功。</li><li id="b3b1" class="lv lw hu je b jf me jj mf jn mg jr mh jv mi jz ma mb mc md dt translated">当您确认更新过程时，它会再次验证文件。</li><li id="fba1" class="lv lw hu je b jf me jj mf jn mg jr mh jv mi jz ma mb mc md dt translated">如果先前的验证成功，那么使用<code class="eh le lf lg lh b">libjnialtota.so</code>动态库修改<code class="eh le lf lg lh b">fotamng</code>分区。</li><li id="5a1b" class="lv lw hu je b jf me jj mf jn mg jr mh jv mi jz ma mb mc md dt translated">手机重启。</li></ul><p id="9605" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">重启不会立即发生，所以我可以在重启前删除一个文件，看看<code class="eh le lf lg lh b">fotamng</code>分区会发生什么。</p><p id="4733" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我写了脚本，不断使<code class="eh le lf lg lh b">fotamng</code>分区转储并重命名<code class="eh le lf lg lh b">/cache/delta/boot_delta.bin</code>文件。我在更新确认后立即运行了它。手机重新启动到FOTA模式，显示一个错误，并重新启动到正常启动模式。</p><p id="82eb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我开始调查转储的数据。分区还包含一个额外的东西:fota和dmseg日志！看来fota启动可以通过在<code class="eh le lf lg lh b">fotamng</code>分区中设置几个字节为“1”来初始化:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="7c7e" class="lq kc hu lh b fv lr ls l lt lu">$ dd if=/data/local/tmp/one_bit.bin of=/dev/block/platform/msm_sdcc.1/by-name/fotamng seek=16 bs=1 count=1<br/>$ dd if=/data/local/tmp/one_bit.bin of=/dev/block/platform/msm_sdcc.1/by-name/fotamng seek=24 bs=1 count=1<br/>$ dd if=/data/local/tmp/one_bit.bin of=/dev/block/platform/msm_sdcc.1/by-name/fotamng seek=131088 bs=1 count=1<br/>$ dd if=/data/local/tmp/one_bit.bin of=/dev/block/platform/msm_sdcc.1/by-name/fotamng seek=131096 bs=1 count=1</span></pre><p id="a4b2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些字节在重启后被清除。我还注意到fota dmesg日志中的<strong class="je hv"> kcdroidboot.mode=f-ksg </strong>内核参数。在这里！因此，bootloader删除了fota引导的手机保护，理论上，如果我写一个常规的引导分区，而不是fota，并重新启动手机进入这种模式，我会得到禁用京瓷保护的内核。但是我仍然没有系统相关分区的写权限。</p><h1 id="67c4" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">调查小内核(lk)源代码</h1><p id="d0b4" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">小内核或Android bootloader位于aboot分区内。普通源代码可从<a class="ae ka" href="https://source.codeaurora.org/quic/la/kernel/lk/" rel="noopener ugc nofollow" target="_blank">https://source.codeaurora.org/quic/la/kernel/lk/</a>获得</p><p id="3815" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在那里你可以找到关于如何引导进入某些模式的信息。例如，如果将<strong class="je hv">引导恢复</strong>写入<code class="eh le lf lg lh b">misc</code>分区，那么下一次引导将是<a class="ae ka" href="https://source.codeaurora.org/quic/la/kernel/lk/tree/app/aboot/recovery.c?h=LA.BR.1.3.3_rb2.29#n65" rel="noopener ugc nofollow" target="_blank">恢复模式</a>，不需要执行<strong class="je hv"> adb重启恢复</strong>。当您使用这种方法引导进入恢复模式时，<strong class="je hv">引导恢复</strong>标签<a class="ae ka" href="https://android.googlesource.com/platform/bootable/recovery/+/android-4.4.4_r2/recovery.cpp#335" rel="noopener ugc nofollow" target="_blank">将被重置</a>。如果恢复不能启动，手机将得到启动循环，你会失去它。所以要小心，最好避免这个选项重新启动。</p><p id="3ddf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您还可以找到启用系统相关emmc区的只读保护<a class="ae ka" href="https://source.codeaurora.org/quic/la/kernel/lk/tree/platform/msm_shared/mmc.c?h=LA%20.BR.1.3.3_rb2.29#n2572" rel="noopener ugc nofollow" target="_blank">的代码。这是对为什么不可能重写恢复分区这个问题的回答。这种保护可以在Linux内核中禁用。另外一个对京瓷手机感兴趣的人已经</a><a class="ae ka" href="https://github.com/hiikezoe/android_mmc_protect" rel="noopener ugc nofollow" target="_blank">编写了这样一个模块。这个模块不时工作，有时挂在mmc的索赔功能。理想情况下，这需要详细的调查。</a></p><p id="1875" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是aboot如何验证引导分区:<a class="ae ka" href="https://source.codeaurora.org/quic/la/kernel/lk/tree/platform/msm_shared/image_verify.c?h=LA.BR.1.3.3_rb2.29" rel="noopener ugc nofollow" target="_blank">https://source . code aurora . org/quic/la/kernel/lk/tree/platform/MSM _ shared/image _ verify . c？h=LA。BR.1.3.3_rb2.29 </a></p><h1 id="4cab" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">最初的成功</h1><p id="cc9d" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">Google帮我回答了为什么读不到内核日志的问题:<code class="eh le lf lg lh b"><a class="ae ka" href="https://www.kernel.org/doc/Documentation/sysctl/kernel.txt" rel="noopener ugc nofollow" target="_blank">/proc/sys/kernel/dmesg_restrict</a></code>。当电话启动时，该参数的值被设置为1。如果用户没有<strong class="je hv"> CAP_SYS_ADMIN </strong>能力，则日志对其不可用。</p><h1 id="80e8" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">uevent_helper</h1><p id="f008" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">就我而言，令人惊讶的是，我有可能被写进<code class="eh le lf lg lh b">/sys/kernel/uevent_helper</code>。如果你写一些可执行文件的路径，它将在root用户下执行，初始化SELinux上下文，最重要的是拥有完整的功能(shell脚本也可以)</p><p id="7753" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我写了以下脚本:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="09ae" class="lq kc hu lh b fv lr ls l lt lu">#!/system/bin/sh<br/>echo 0 &gt; /proc/sys/kernel/dmesg_restrict</span></pre><p id="a530" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">把它上传到手机上，把它的路径写到<code class="eh le lf lg lh b">/sys/kernel/uevent_helper</code>里，我就可以读取dmesg日志了！</p><h1 id="c2d5" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">修补的adbd</h1><figure class="li lj lk ll fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mk"><img src="../Images/abcc3c67c7ed2ac94d0a8f8a53e90481.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ij-8lFt-OAde-oPz.png"/></div></div></figure><p id="c2cb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于功能限制，我不能轻易研究手机的内部结构，所以我决定用21点和妓女建立自己的adbd。为此，我必须下载70 Gb的Android源代码(我不想单独弄乱每个依赖项)。我去掉了删除功能的检查，编译了adbd，替换了<code class="eh le lf lg lh b">/sbin/adbd</code>，得到了一个完整的根控制台。现在，我可以挂载文件系统，读取dmesg日志而不会弄乱<strong class="je hv"> dmesg_restrict </strong>，轻松查看或编辑不属于root的文件，等等。但是我仍然不能挂载<code class="eh le lf lg lh b">/system</code>分区并将模块加载到内核中。</p><p id="e94d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">顺便说一下，可以通过编译<a class="ae ka" href="https://github.com/baselsayeh/custombackdoorlshserver" rel="noopener ugc nofollow" target="_blank"> lsh </a>并将其路径写入<code class="eh le lf lg lh b">/sys/kernel/uevent_helper</code>来避免这个过程。我建议将lsh封装在设置<code class="eh le lf lg lh b">PATH</code>环境的脚本中启动，否则您必须指定每个命令的完整路径。</p><h1 id="5346" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">无线局域网（wireless fidelity的缩写）</h1><p id="cc46" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我手机里的WiFi是通过内核模块工作的。当WiFi打开时，模块被加载。当WiFi关闭时—模块被卸载。如果您用自己的模块文件替换模块文件并打开WiFi，则必须加载假冒的模块。幸运的是，我的手机不会检查模块的数字签名。我尝试的第一件事是编译并加载通过替换内核内存来禁用SELinux的模块。该模块最初是为亚马逊Fire Phone编写的:<a class="ae ka" href="https://github.com/chaosmaster/ford_selinux_permissive" rel="noopener ugc nofollow" target="_blank">https://github.com/chaosmaster/ford_selinux_permissive</a></p><p id="2026" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了编译这个模块，你需要一个或多或少合适的内核源码和<code class="eh le lf lg lh b">Module.symvers</code>文件。如果源代码明确对应手机中使用的内核，那么可以使用内核编译过程中自动生成的<code class="eh le lf lg lh b">Module.symvers</code>。</p><p id="dbac" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果内核模块在<strong class="je hv">上抱怨不同意符号模块布局</strong>的版本，你将需要从<code class="eh le lf lg lh b">boot</code>分区中提取<code class="eh le lf lg lh b">Module.symvers</code>。这可以使用<a class="ae ka" href="https://github.com/glandium/extract-symvers" rel="noopener ugc nofollow" target="_blank">https://github.com/glandium/extract-symvers</a>脚本来完成:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="2a30" class="lq kc hu lh b fv lr ls l lt lu">$ unpackbootimg -i boot.img -o boot<br/>$ extract-symvers.py -e le -B 0xc0008000 boot/boot.img-zImage &gt; %PATH_TO_KERNEL%/Module.symvers</span></pre><figure class="li lj lk ll fq iv fe ff paragraph-image"><div class="fe ff ml"><img src="../Images/31e014d5e5b8243f4ba4c2e55abf7459.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/0*ZaQ_ZQZQWaQOOx9F.jpg"/></div></figure><p id="d9e1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你还记得这个<a class="ae ka" href="https://github.com/kayrus/kc-s701-torque-kernel/blob/e3f29f4412f645ac06a580c5327298f7a2e087b9/security/selinux/hooks.c#L5228" rel="noopener ugc nofollow" target="_blank">列表</a>吗？这个模块应该叫做<code class="eh le lf lg lh b">wlan</code>。我是这样解决这个问题的:</p><ul class=""><li id="7f96" class="lv lw hu je b jf jg jj jk jn lx jr ly jv lz jz ma mb mc md dt translated">创建了一个<code class="eh le lf lg lh b">wlan.c</code>符号链接</li><li id="6cce" class="lv lw hu je b jf me jj mf jn mg jr mh jv mi jz ma mb mc md dt translated">修改的Makefile</li></ul><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="fc28" class="lq kc hu lh b fv lr ls l lt lu">...<br/>MODULE_NAME = wlan<br/>...</span></pre><p id="004b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在应用了这些技巧并执行了<code class="eh le lf lg lh b">svc wifi disable &amp;&amp; svc wifi enable</code>之后，模块已经成功加载(<code class="eh le lf lg lh b">wlan</code>模块使用的内存减少了，可以使用<code class="eh le lf lg lh b">lsmod</code>命令来检查),但是SELinux并没有被禁用。</p><p id="b09e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">dmesg日志不包含任何与新模块相关的信息。这是由另一个内核选项引起的:<code class="eh le lf lg lh b">/proc/sys/kernel/printk</code>，它过滤包括模块日志在内的信息日志。我降低了所有日志的阈值:<code class="eh le lf lg lh b">echo '8 8 8 8' &gt; /proc/sys/kernel/printk</code>，重新加载了模块，看起来模块就是找不到所需的字节模式。我决定写自己的内核模块。</p><h1 id="eb9d" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">编写模块</h1><h1 id="7033" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">禁用安全保护</h1><p id="7d29" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我未能禁用SELinux，但通过类比https://github.com/chaosmaster/ford_selinux_permissive模块，我可以尝试禁用京瓷挂钩。我只需要使用Linux内核模块设置一个<strong class="je hv"> kc_bootmode </strong>或<strong class="je hv"> kc_kbfm </strong>变量。</p><p id="3e4f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Linux内核有可能获得所有函数和变量的指针地址:<code class="eh le lf lg lh b">cat /proc/kallsyms</code>。默认情况下，这些地址显示为0。这是另一种内核保护，可以通过下面的命令禁用:<code class="eh le lf lg lh b">echo 0 &gt; /proc/sys/kernel/kptr_restrict</code>。</p><p id="b0bd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦获得了所需函数的地址，就可以用适当的参数调用它，函数会将相应的变量设置为1。我注意到不是所有的Linux内核都显示变量的地址(<strong class="je hv"> d </strong>或<strong class="je hv"> D </strong>类型，case表示变量是否是公共的)这就是为什么我使用函数指针，而不是实际的变量指针。也许是由内核编译时的<code class="eh le lf lg lh b">CONFIG_KALLSYMS_ALL</code>选项决定的。</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="3af5" class="lq kc hu lh b fv lr ls l lt lu">$ adb shell "grep kc_bootmode_setup /proc/kallsyms"<br/>c0d19d84 t kc_bootmode_setup</span></pre><p id="faed" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，我必须声明我想在模块中调用的内核函数:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="b660" class="lq kc hu lh b fv lr ls l lt lu">int (* _kc_bootmode_setup) (char * buf) = (int (*) ()) 0xc0d19d84;</span></pre><p id="4597" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后称之为:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="8468" class="lq kc hu lh b fv lr ls l lt lu">_kc_bootmode_setup("f-ksg")</span></pre><p id="1698" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您也可以动态确定地址:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="9f4d" class="lq kc hu lh b fv lr ls l lt lu">_kc_bootmode_setup = (int (*) (char * buf)) kallsyms_lookup_name("kc_bootmode_setup");</span></pre><p id="a8b7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我加载了<a class="ae ka" href="https://github.com/kayrus/kc_s701_break_free" rel="noopener ugc nofollow" target="_blank">模块</a>，它禁用了保护！现在我可以挂载<code class="eh le lf lg lh b">/system</code>并加载任何内核模块，不管它的名字是什么。</p><p id="cad2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">受保护的eMMC区域仍处于只读模式，它不允许您定期修改<code class="eh le lf lg lh b">/system</code>分区。这些文件可以被编辑，但是当你清理内核缓存的时候，一切都回到了原来的状态。</p><h1 id="28e3" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">最后禁用SELinux</h1><p id="3cd8" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">它已经不是必需的了，但只是为了好玩，我决定最终禁用SELinux。我不能修改已定义的<code class="eh le lf lg lh b">selinux_enabled</code>常量，但是我可以用钩子指针取消对<code class="eh le lf lg lh b">security_ops</code>结构的引用。</p><p id="873e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这可以通过调用<code class="eh le lf lg lh b">reset_security_ops</code>函数来完成:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="682a" class="lq kc hu lh b fv lr ls l lt lu">void (* _reset_security_ops) (void) = NULL;<br/>... ... ...<br/>_reset_security_ops = (void (*) (void)) kallsyms_lookup_name("reset_security_ops");<br/>if (_reset_security_ops! = NULL) {<br/>  _reset_security_ops ();<br/>}</span></pre><p id="6976" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它禁用所有SELinux挂钩和函数，但系统仍然认为SELinux被启用，因为<code class="eh le lf lg lh b">selinux_enabled</code>包含1个整数值。因此，可能存在一些与SELinux函数相关的问题，即不正确的<code class="eh le lf lg lh b">ls -Z</code>输出。</p><h1 id="d4cc" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">重启进入下载模式</h1><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="4bcf" class="lq kc hu lh b fv lr ls l lt lu">int (* _enable_dload_mode) (char * str) = (int (*) ()) 0xc0d0cc18;<br/>... ... ...<br/>_enable_dload_mode("dload_mode");</span></pre><p id="d2f9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">同样的操作适用于我上面写的<code class="eh le lf lg lh b">download_mode</code>。模块加载后，手机重启将启动它在一个特殊的模式，作为USB大容量存储设备。这样我就可以完全访问手机的所有分区了！我试图覆盖恢复分区，它甚至在清除内核缓存后也能工作。</p><p id="4dce" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">实际上常规的<code class="eh le lf lg lh b">dd</code>不工作，手机的USB大容量存储设备断开连接，写入停止。这可能是大容量存储加载程序的内部缓存溢出的结果。我不得不写一个解决方法。重<code class="eh le lf lg lh b">system</code>分区的高级脚本在这里有:<a class="ae ka" href="https://github.com/kayrus/kc_s701_break_free/blob/master/inject_supersu/write_rooted_system.sh" rel="noopener ugc nofollow" target="_blank">https://github . com/Kay RUS/KC _ s701 _ break _ free/blob/master/inject _ supersu/write _ root _ system . sh</a>。主要的技巧是读取你想要覆盖的数据。读比写快得多，所以我比较源和目的地的散列，如果它们不同，我就写新的数据。这节省了大量时间，1.2Gb的修改分区可以在2-3分钟内刷新，而不是35分钟。</p><p id="d174" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用这种方法，我将supersu二进制文件安装到下载的分区中，并刷新到手机中。手机开机了，但我在通知栏里得到了如下消息:<code class="eh le lf lg lh b">Low security level. Inappropriate application may have been installed. Please uninstall it and reboot the phone.</code>。我在加载不安全的SELinux策略时已经看到过这条消息。这个通知还会导致永久的红色LED闪烁，并且手机在超时时不会关闭屏幕(我猜是为了引起用户的注意，手机被黑客攻击)。我花了一些时间，发现这个通知是由<code class="eh le lf lg lh b">/system/vendor/bin/akscd</code>后台程序触发的。它是一个小的守护程序，监视在<code class="eh le lf lg lh b">PATH</code>中可以找到的<code class="eh le lf lg lh b">su</code> / <code class="eh le lf lg lh b">sudo</code>二进制文件，监视SELinux状态以及<code class="eh le lf lg lh b">/system</code>分区是否以读写模式挂载。它将安全状态写入<code class="eh le lf lg lh b">/data/system/akscd/out_%s.dat</code>并触发上述通知。我刚刚禁用了这项服务，但应该有一个更好的修复方法，只禁用<code class="eh le lf lg lh b">su</code> / <code class="eh le lf lg lh b">sudo</code>检测，并允许监控<code class="eh le lf lg lh b">/system</code>状态，因为我仍然想控制我的手机的安全。</p><p id="b576" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">初始任务完成:获得了永久根访问和写入外部SD卡的可能性。此外，我编写了一个<a class="ae ka" href="https://github.com/kayrus/kc_s701_break_free/blob/master/disable_security.c" rel="noopener ugc nofollow" target="_blank">实用程序</a>，它将<code class="eh le lf lg lh b">system</code> UID设置为<code class="eh le lf lg lh b">CAP_SYS_MODULE</code>功能，然后加载原始的<code class="eh le lf lg lh b">wlan</code>模块，然后加载我的假<code class="eh le lf lg lh b">wlan</code>模块，该模块禁用安全性，最后再次加载原始的<code class="eh le lf lg lh b">wlan</code>模块。</p><p id="e1e6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我的下一个目标是引导定制内核。我希望没有数字签名验证，我决定启动我的自定义启动分区。由于刷新常规引导分区是危险的，我决定将其刷新到恢复分区，并使用<strong class="je hv"> adb reboot recovery </strong>命令重新引导到恢复分区。<strong class="je hv">记住</strong> <code class="eh le lf lg lh b"><strong class="je hv">misc</strong></code> <strong class="je hv">分区，不建议通过该分区中的</strong> <code class="eh le lf lg lh b"><strong class="je hv">boot-recovery</strong></code> <strong class="je hv">条目引导进入恢复，会造成引导循环</strong>。不幸的是，手机无法启动到恢复，它只是振动，然后重新启动到正常模式。</p><p id="9f91" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">看来我得解锁手机的引导程序了。没有太多关于如何做到这一点的信息，但我发现了几个适用于旧手机的方法:</p><ul class=""><li id="9945" class="lv lw hu je b jf jg jj jk jn lx jr ly jv lz jz ma mb mc md dt translated"><a class="ae ka" href="https://github.com/beaups/SamsungCID" rel="noopener ugc nofollow" target="_blank">https://github.com/beaups/SamsungCID</a>。</li><li id="0ac3" class="lv lw hu je b jf me jj mf jn mg jr mh jv mi jz ma mb mc md dt translated"><a class="ae ka" href="https://github.com/djrbliss/loki" rel="noopener ugc nofollow" target="_blank">https://github.com/djrbliss/loki</a></li><li id="a996" class="lv lw hu je b jf me jj mf jn mg jr mh jv mi jz ma mb mc md dt translated"><a class="ae ka" href="https://bits-please.blogspot.com/2016/02/unlocking-motorola-bootloader.html" rel="noopener ugc nofollow" target="_blank">https://bits-please . blogspot . com/2016/02/unlocking-Motorola-boot loader . html</a></li></ul><h1 id="5a85" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">aboot和引导分区的数字签名</h1><p id="c64d" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我很好奇aboot到底是如何验证引导分区的。所以我从一个boot分区(<code class="eh le lf lg lh b">binwalk -e aboot</code>)打开所有的证书，提取图像签名，循环所有的公钥试图解密签名。原来所有的启动映像都是用同一个密钥签名的。</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="43f2" class="lq kc hu lh b fv lr ls l lt lu">#!/bin/bash</span><span id="ba10" class="lq kc hu lh b fv mm ls l lt lu"># mkdir boot<br/># unpackbootimg -i 09-boot.img -o boot<br/># cd boot<br/># mkbootimg --kernel 09-boot.img-zImage --ramdisk 09-boot.img-ramdisk.gz --cmdline "`cat 09-boot.img-cmdline`" --base `cat 09-boot.img-base` --pagesize `cat 09-boot.img-pagesize` --dt 09-boot.img-dtb --kernel_offset `cat 09-boot.img-kerneloff` --ramdisk_offset `cat 09-boot.img-ramdiskoff` --tags_offset `cat 09-boot.img-tagsoff` --output mynew.img<br/># dd if=../09-boot.img of=signature.bin bs=1 count=256 skip=$(ls -la mynew.img | awk '{print $5}')<br/># cd ..<br/># binwalk -e 05-aboot.img<br/># openssl rsautl -raw -inkey &lt;(openssl x509 -pubkey -noout -inform der -in _05-aboot.img.extracted/4D8D8.crt 2&gt;/dev/null) -pubin -in signature.bin 2&gt;/dev/null | hd<br/># print cert in text mode: openssl x509 -inform der -in 1768B.crt -text -noout</span><span id="2c63" class="lq kc hu lh b fv mm ls l lt lu">NAME=$1<br/>IMG=${NAME}/mynew.img<br/>SIG=${NAME}/signature.bin</span><span id="4bef" class="lq kc hu lh b fv mm ls l lt lu">CALC_SHA256=$(sha256sum ${IMG} | awk '{print $1}')</span><span id="fa09" class="lq kc hu lh b fv mm ls l lt lu">for i in `find . -name *.crt`; do<br/>  ORIG_SHA256=$(openssl rsautl -inkey &lt;(openssl x509 -pubkey -noout -inform der -in ${i} 2&gt;/dev/null) -pubin -in ${SIG} 2&gt;/dev/null | hexdump -ve '/1 "%02x"')<br/>  if [ "${ORIG_SHA256}" != "" ]; then<br/>    echo "sha256 was decrypted using ${i} key - ${ORIG_SHA256}"<br/>  fi<br/>  if [ "${ORIG_SHA256}" = "${CALC_SHA256}" ]; then<br/>    echo "sha256 matched the calculated sha256 ${ORIG_SHA256}"<br/>    echo "$i"<br/>  fi<br/>done</span></pre><p id="4c51" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该脚本打印以下输出:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="0c6f" class="lq kc hu lh b fv lr ls l lt lu">$ ./verify.sh boot<br/> sha256 was decrypted using ./_05-aboot.img.extracted/31464.crt key - 91642909810cde935881d1656f6290ebf32e19975d99d739bd03162f79e000d7 sha256 matched the calculated sha256 91642909810cde935881d1656f6290ebf32e19975d99d739bd03162f79e000d7 ./_05-aboot.img.extracted/31464.crt</span></pre><p id="2760" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">aboot分区的验证似乎更复杂。我提取并解密了图像的sha256签名。但是我自己无法计算这个散列。幸运的是，<a class="ae ka" href="http://nelenkov.blogspot.de/2014/04/android-security-internals.html" rel="noopener ugc nofollow" target="_blank">Android security internals</a>的作者Nikolay Elenkov帮助并转发给我高通白皮书:<a class="ae ka" href="https://www.qualcomm.com/media/documents/files/secure-boot-and-image-authentication-technical-overview.pdf" rel="noopener ugc nofollow" target="_blank">https://www . Qualcomm . com/media/documents/files/secure-boot-and-image-authentic ation-technical-overview . pdf</a>。它解释了如何计算目标sha256。哈希依赖于证书主题中定义的<code class="eh le lf lg lh b">HW_ID</code>和<code class="eh le lf lg lh b">SW_ID</code>，即</p><blockquote class="mn mo mp"><p id="b979" class="jc jd mq je b jf jg jh ji jj jk jl jm mr jo jp jq ms js jt ju mt jw jx jy jz hn dt translated"><em class="hu"> Subject: C=US，ST=CA，L=San Diego，OU=07 0001 SHA256，OU=06 001E MODEL_ID，OU=05 00002000 SW_SIZE，OU=04 0039 OEM_ID，OU = 03 0000000000000002 DEBUG，OU=02 009180E10039001E HW_ID，OU = 01 0000000000002</em></p></blockquote><p id="c11b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">工作脚本可以在Nikolay的<a class="ae ka" href="https://github.com/nelenkov/aboot-parser" rel="noopener ugc nofollow" target="_blank"> github库</a>中找到。</p><h1 id="5e5e" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">试验fota分区</h1><p id="c9ec" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">因为我知道引导/恢复和fota分区是用相同的密钥签名的，而且fota分区是在禁用内核安全性的情况下引导的，所以值得尝试检查一下将引导分区刷新到fota分区是否可行。</p><p id="9013" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是相当危险的，我可以得到类似于恢复引导的引导。boot-in-fota标志被写入<code class="eh le lf lg lh b">fotamng</code>分区，如果aboot没有引导fota，它会尝试在无限循环中引导它。</p><p id="f66d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不幸的是，用fota编写的引导分区无法加载，但幸运的是LK在引导时重置了fota字节，我没有面对引导循环。不清楚为什么它不工作，可能是因为不同的ramdisk和标签偏移量(很可能它们被硬编码在LK中):</p><p id="9369" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">启动/恢复:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="88ac" class="lq kc hu lh b fv lr ls l lt lu">ramdisk: 0x01000000<br/>   tags: 0x00000100</span></pre><p id="b0e3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">fota:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="8467" class="lq kc hu lh b fv lr ls l lt lu">ramdisk: 0x02000000<br/>   tags: 0x01e00000</span></pre><h1 id="996c" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">试用准将引导程序</h1><p id="e117" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">为了做实验，我订购了一台破碎屏幕的京瓷准将。</p><p id="7a9b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我检查了KC-S701和准将aboot分区的数字签名，看起来它们是由相同主题的证书签署的，所以aboot分区应该是可互换的。我决定做一个实验:将一个boot从KC-S701闪存到准将。引导加载程序成功启动。令人惊讶的是，eMMC写保护没有被激活，我可以很容易地恢复原来的引导加载程序(我想只读标志可以由QFuses设置)。</p><p id="7531" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后我试着将准将的aboot闪存到KC-S701中。我可以有机会使用快速启动并启动任何未签名的内核。此时手机没有开机。</p><p id="79f1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此时，故事可能会以“手机无法启动”和黑屏结束。但是，幸运的是，这个黑屏是“下载模式”。我能够刷新原来的aboot分区，手机复活了。我仍然想知道它为什么不启动。两个证书链都是有效的，理论上应该可以互换。我面临这个问题最有可能是因为准将基于msm8928，而KC-S701基于msm8226 SoC。它们都来自同一个SoC系列，但有一些微小的差异(msm8928支持USB OTG)。</p><h1 id="d538" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">还有什么需要澄清的</h1><p id="f9e0" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">为什么策略重新编译不起作用？不完美的策略反编译器？</p><h1 id="d3d9" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">aboot分区隐藏了什么？</h1><p id="8213" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated"><code class="eh le lf lg lh b">oem-1</code>重启模式背后隐藏着什么？Aboot分区包含<code class="eh le lf lg lh b">fastboot</code>代码，至少有:<code class="eh le lf lg lh b">flash</code>、<code class="eh le lf lg lh b">erase</code>、<code class="eh le lf lg lh b">oem device-info</code>、<code class="eh le lf lg lh b">preflash</code>、<code class="eh le lf lg lh b">oem enable-charger-screen</code>和<code class="eh le lf lg lh b">oem disable-charger-screen</code>命令。如何进入快速启动模式？</p><h1 id="50f5" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">如何禁用相机快门声？</h1><p id="611b" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我已经找到了至少3个控制相机快门声音的选项，但是没有一个有效。禁用它的唯一方法是替换<code class="eh le lf lg lh b">/system/media/audio/ui/camera_click.ogg</code>文件。但是我不喜欢这个解决方案，并且仍然希望找到一种更优雅的方式来禁用这个选项。最有可能的是，它是由专有京瓷属性控制的。</p><h1 id="418c" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">京瓷特性说明</h1><p id="69f5" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">京瓷和安卓系统属性一起使用自己的内部属性。我很肯定会有一些棘手的选择，可以影响引导加载程序保护或相机快门声音不能被禁用的删除(哦，伙计，我刚刚意识到在KC-S701有多少限制)。手机有一个<strong class="je hv"> libkcjprop_jni.so </strong>动态库和<strong class="je hv"> kcjprop_daemon </strong>守护进程。我可以写一个应用程序，将使用这个库，但与其他待办事项相比，这项任务的优先级较低。</p><p id="1458" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">选项被写入文件系统，看起来像二进制数据:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="8eda" class="lq kc hu lh b fv lr ls l lt lu">$ ls -la /sysprop/kcjprop/rw/8d9d788ddd5fecfdbc6c5f7c5cecfc<br/> -rw-rw ---- root root 16 1970-01-22 21:01 8d9d788ddd5fecfdbc6c5f7c5cecfc</span></pre><h1 id="852f" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">Kexec</h1><p id="6370" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">Kexec允许Linux内核加载另一个内核。默认情况下，生产内核版本不支持Kexec，但是可以使用内核模块来启用它。然后，使用用户端实用程序，您可以加载任何自定义内核来替换当前内核。这看起来像一个黑客，但是如果你想加载你的自定义内核并绕过数字签名验证，这是一个选择。</p><h1 id="a92b" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">QSEE漏洞</h1><p id="a3c9" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">QSEE-高通信任区保护，该保护可能存在在信任区上下文中执行自定义代码的漏洞:<a class="ae ka" href="https://bits-please.blogspot.com/2016/05/qsee-privilege-escalation-vulnerability.html" rel="noopener ugc nofollow" target="_blank">https://bits-please . blogspot . com/2016/05/QSEE-privilege-escalation-vulnerability . html</a>。看起来我必须构建一个特殊格式的SCM命令来烧录相应的QFuse并解锁bootloader。还有待完成。</p><h1 id="5efc" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">结论</h1><figure class="li lj lk ll fq iv fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/6fe398a1399b762a732cb4bb5213d465.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/0*LhVKM9-v1uWBu--v.jpg"/></div></figure><p id="a322" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我解决的每个问题都会引发大量新问题，很难预测兔子洞有多深。</p><p id="bfbd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我的github repo:<a class="ae ka" href="https://github.com/kayrus/kc_s701_break_free" rel="noopener ugc nofollow" target="_blank">https://github.com/kayrus/kc_s701_break_free</a>中可以找到模块的源代码、aboot加载器和处理京瓷属性的库。</p><p id="695e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我想对京瓷开发商的优秀设备和高安全性表示感谢。否则这篇文章就写不出来了。另一方面，没有定期更新让我真的很苦恼。如果京瓷有能解锁bootloader的新手机型号，我肯定会买。</p><p id="79f9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我还是没有放弃解锁bootloader。最赚钱的时候是在圣诞节，但现在我很难找到一些空闲时间，专注于这个问题。</p><p id="dd04" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">附注:非常感谢<a class="ae ka" href="http://nelenkov.blogspot.de/" rel="noopener ugc nofollow" target="_blank">尼古拉·埃伦科夫</a>。他向我解释了Android boot chain的工作原理，并帮助我进行aboot数字签名验证。</p><div class="li lj lk ll fq ab cb"><figure class="mv iv mw mx my mz na paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mv iv mw mx my mz na paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mv iv mw mx my mz na paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mn mo mp"><p id="f922" class="jc jd mq je b jf jg jh ji jj jk jl jm mr jo jp jq ms js jt ju mt jw jx jy jz hn dt translated"><a class="ae ka" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ka" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ka" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ka" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd mq je b jf jg jh ji jj jk jl jm mr jo jp jq ms js jt ju mt jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ka" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ka" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="li lj lk ll fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nb"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>