<html>
<head>
<title>Full stack react app from scratch — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从头开始的全栈react应用程序—第1部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/full-stack-react-app-from-scratch-part-1-9086cacc59ac?source=collection_archive---------3-----------------------#2017-09-29">https://medium.com/hackernoon/full-stack-react-app-from-scratch-part-1-9086cacc59ac?source=collection_archive---------3-----------------------#2017-09-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/cbb6ed4bdf0f372f260facf1a76788ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*xG3lUGh3ehPFLtVH1tUG6w.png"/></div></figure><p id="9cf8" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">一些开发人员不喜欢<a class="ae jw" href="https://facebook.github.io/react/" rel="noopener ugc nofollow" target="_blank"> react </a>，因为它太难了，功能性的，新思想。在本教程中，我将向您展示如何简单快速地使用<a class="ae jw" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> node.js </a>、react、<a class="ae jw" href="http://redux.js.org/docs/introduction/" rel="noopener ugc nofollow" target="_blank"> redux </a> with <a class="ae jw" href="http://reactivex.io/rxjs/" rel="noopener ugc nofollow" target="_blank"> rxjs </a>和<a class="ae jw" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> docker </a>从零开始创建生产就绪全栈应用程序，并覆盖全部代码。</p><p id="09e4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们将在后端使用node.js创建全栈应用程序，并在前端使用redux和rxjs。而<a class="ae jw" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> redis </a>将是我们的数据存储。要在dev PC上运行redis，我将展示使用docker是多么容易。</p></div><div class="ab cl jx jy hc jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hn ho hp hq hr"><p id="4082" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们从<a class="ae jw" href="https://docs.docker.com/engine/installation/" rel="noopener ugc nofollow" target="_blank"> docker安装</a>开始创建我们的应用程序。之后，我们应该创建目录并启动节点项目。现在谁想看我创建的代码<a class="ae jw" href="https://github.com/evheniy/react-awesome-app" rel="noopener ugc nofollow" target="_blank"> github库</a>。</p><p id="1e78" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">每个新的JavaScript项目都应该从使用<strong class="ja hv"> npm init </strong>命令创建的<strong class="ja hv"> package.json </strong>开始。</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="71eb" class="kn ko hu kj b fv kp kq l kr ks">mkdir react-awesome-app<br/>cd react-awesome-app<br/>npm init -f</span></pre><figure class="ke kf kg kh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff kt"><img src="../Images/75676718ac97c31515407fe518723ff5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UG2ZQ1SPV77dD20di5q3QA.png"/></div></div></figure><p id="8333" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Node.js现在是<a class="ae jw" href="https://medium.freecodecamp.org/trending-developer-skills-based-on-my-analysis-of-ask-hn-whos-hiring-26c02a3ca1fd" rel="noopener ugc nofollow" target="_blank">最受欢迎的平台</a>，不仅仅是作为后端或前端捆绑的工具。正如<a class="ae jw" rel="noopener" href="/@evheniybystrov/backend-development-what-next-f9a5f9b386d2">我在</a>之前写的，许多大公司支持它用于自己的服务(谷歌、AWS)或者<a class="ae jw" href="https://nodesource.com/blog/how-massive-companies-use-node-js-at-scale" rel="noopener ugc nofollow" target="_blank">把它作为系统的一部分</a>(优步贝宝)。对于真正的生产项目，最好使用云服务，如<a class="ae jw" href="https://cloud.google.com/functions/docs/" rel="noopener ugc nofollow" target="_blank"> Google function </a>或<a class="ae jw" href="http://docs.aws.amazon.com/lambda/latest/dg/nodejs-prog-model-handler.html" rel="noopener ugc nofollow" target="_blank"> AWS lambda </a>。但是对于开发或小型项目，我们可以使用node作为http/https服务器，使用类似于<a class="ae jw" href="http://expressjs.com/ru/" rel="noopener ugc nofollow" target="_blank"> express </a>或<a class="ae jw" href="http://koajs.com/" rel="noopener ugc nofollow" target="_blank"> koa </a>的框架。在教程中，我将向您展示其他框架— <a class="ae jw" href="https://yeps.info/" rel="noopener ugc nofollow" target="_blank"> YEPS </a>，<a class="ae jw" rel="noopener" href="/@evheniybystrov/yet-another-event-promised-server-ee1b06506add">我创建了它</a>用于处理承诺、异步/等待、并行执行…</p><p id="9f0b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">正如我之前所说，要存储我们的应用程序数据，我们可以使用redis。感谢docker，我们可以在本地运行它，没有依赖性和内存问题。要在docker中运行它，我们需要执行命令</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="1aa3" class="kn ko hu kj b fv kp kq l kr ks">docker run -d --name redis -p 6379:6379 redis:alpine</span></pre><p id="2c8f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这里我们使用小的<strong class="ja hv"> alpine </strong>镜像作为守护进程(<strong class="ja hv"> -d </strong>)，打开默认端口<strong class="ja hv"> 6379 </strong>。要停止它，我们需要运行:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="7b69" class="kn ko hu kj b fv kp kq l kr ks">docker rm -f redis</span></pre><p id="65f3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">当我们使用<strong class="ja hv"> package.json </strong>时，我们可以将这些命令添加到<strong class="ja hv">脚本</strong>部分:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="5a91" class="kn ko hu kj b fv kp kq l kr ks">"scripts": {<br/>  "db:start": "docker run -d --name redis -p 6379:6379 redis:alpine",<br/>  "db:stop": "docker rm -f redis"<br/>},</span></pre><p id="ad4e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">不要忘记<strong class="ja hv"> package.json </strong>是json文件，所以不要破坏它。现在我们只需要运行<strong class="ja hv"> npm run db:start </strong>来启动redis服务，运行<strong class="ja hv"> npm run db:stop </strong>来停止它。</p><p id="2476" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">不要忘记安装node.js版本7.6.0和更高版本，因为我们将本机使用<strong class="ja hv"> async / await </strong>。要检查当前版本，只需运行<strong class="ja hv"> node -v </strong>(由于<a class="ae jw" href="https://github.com/creationix/nvm" rel="noopener ugc nofollow" target="_blank"> nvm </a>，我使用了最新版本):</p><figure class="ke kf kg kh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff ky"><img src="../Images/d43a462109bbdbb3b7af027b79881300.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YVqm8Hpdx_7kUw_f09Hf9w.png"/></div></div></figure><p id="2082" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我将只安装一个全局依赖项— <a class="ae jw" href="https://www.npmjs.com/package/ntl" rel="noopener ugc nofollow" target="_blank"> <strong class="ja hv"> ntl </strong> </a>，它有助于查看我们所有的命令:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="dbe6" class="kn ko hu kj b fv kp kq l kr ks">npm i -g ntl</span></pre><p id="48e7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在目录中运行<strong class="ja hv"> ntl </strong>命令并选择脚本后:</p><figure class="ke kf kg kh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff kz"><img src="../Images/9524da2a6bc6b95fe17d793f2e3c6c64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GSE2KbKbbDw1wU-MBN7Hnw.png"/></div></div></figure><h1 id="979e" class="la ko hu bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw dt translated">下一步是我们的后端。</h1><p id="f317" class="pw-post-body-paragraph iy iz hu ja b jb lx jd je jf ly jh ji jj lz jl jm jn ma jp jq jr mb jt ju jv hn dt translated">了解<strong class="ja hv"/><a class="ae jw" href="https://nodejs.org/en/docs/guides/anatomy-of-an-http-transaction/" rel="noopener ugc nofollow" target="_blank"><strong class="ja hv">node . js http/https server</strong></a><strong class="ja hv"/>如何工作非常重要。它是单个进程，实际上它是带有<strong class="ja hv">请求</strong>事件的EventEmitter。每个用户的请求运行事件处理程序，而每个node.js框架(如express.js或koa.js)只是处理用户请求的处理程序。因此，这个过程中的任何副作用(如变量)都可能导致内存泄漏。小心点。</p><p id="a656" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">对于我们的项目，我们将使用<a class="ae jw" rel="noopener" href="/@evheniybystrov/yet-another-event-promised-server-ee1b06506add"> YEPS框架</a>。我使用Promise.all为一个具有异步/等待和并行作业的高负载项目创建了它。多亏了promise模型和并行执行，而不是一个接一个循环运行模块的中间件模型，我的速度提高了10倍。</p><p id="52d5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">要使用YEPS，我们需要安装所有依赖项(运行带有<strong class="ja hv"> -S </strong>标志的命令，将依赖项存储在<strong class="ja hv"> package.json </strong>和<strong class="ja hv"> -D </strong>中，将其存储为<strong class="ja hv"> devDependencies </strong>):</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="d17a" class="kn ko hu kj b fv kp kq l kr ks">npm i -S yeps yeps-bodyparser yeps-cors yeps-error yeps-helmet yeps-logger yeps-redis yeps-router yeps-server yeps-static</span></pre><p id="7149" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">并且我们可以看到<strong class="ja hv"> package.json </strong>的变化:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="265d" class="kn ko hu kj b fv kp kq l kr ks">"dependencies": {<br/>  "yeps": "^1.0.0",<br/>  "yeps-bodyparser": "^1.1.0",<br/>  "yeps-cors": "^1.0.0",<br/>  "yeps-error": "^1.2.0",<br/>  "yeps-helmet": "^1.0.0",<br/>  "yeps-logger": "^1.0.0",<br/>  "yeps-redis": "^1.0.0",<br/>  "yeps-router": "^1.0.0",<br/>  "yeps-server": "^1.0.0",<br/>  "yeps-static": "^1.2.0"<br/>}</span></pre><p id="6659" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了组装我们的服务器部分，我将创建新的目录<strong class="ja hv"> server </strong>和<strong class="ja hv"> index.js </strong>作为入口点。</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="1455" class="kn ko hu kj b fv kp kq l kr ks">mkdir server<br/>cd server<br/>touch index.js</span></pre><p id="011a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">并把这段代码:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="32cb" class="kn ko hu kj b fv kp kq l kr ks"><strong class="kj hv">const </strong>App = require('yeps');<br/><strong class="kj hv">const </strong>Router = require('yeps-router');<br/><strong class="kj hv">const </strong>error = require('yeps-error');<br/><strong class="kj hv">const </strong>logger = require('yeps-logger');<br/><strong class="kj hv">const </strong>redis = require('yeps-redis');<br/><strong class="kj hv">const </strong>bodyParser = require('yeps-bodyparser');<br/><strong class="kj hv">const </strong>helmet = require('yeps-helmet');<br/><strong class="kj hv">const </strong>cors = require('yeps-cors');<br/><strong class="kj hv">const </strong>serve = require('yeps-static');<br/><br/><strong class="kj hv">const </strong>app = module.exports = <strong class="kj hv">new </strong>App();<br/><strong class="kj hv">const </strong>router = <strong class="kj hv">new </strong>Router();<br/><br/>router.get('/data').then(<strong class="kj hv">async </strong>(ctx) =&gt; {<br/>  <strong class="kj hv">const </strong>rows = <strong class="kj hv">await </strong>ctx.redis.get('data');<br/>  ctx.res.end(JSON.stringify(rows));<br/>}).post('/data').then(<strong class="kj hv">async </strong>(ctx) =&gt; {<br/>  <strong class="kj hv">await </strong>ctx.redis.set('data', JSON.stringify(ctx.request.body));<br/>  ctx.res.end(JSON.stringify({<br/>    message: 'ok',<br/>  }));<br/>});<br/><br/>app.all([<br/>  error({ isJSON: <strong class="kj hv">true </strong>}),<br/>  logger(),<br/>]).then(<br/>  serve(),<br/>).all([<br/>  redis(),<br/>  bodyParser(),<br/>  helmet(),<br/>  cors(),<br/>]).then(<br/>  router.resolve(),<br/>);</span></pre><p id="1089" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在这里，在需要所有依赖项之后，我创建了<strong class="ja hv">应用程序</strong>和<strong class="ja hv">路由器</strong>。在路由器中，我创建了两个入口点<strong class="ja hv">获取</strong>和<strong class="ja hv">设置数据</strong>。不是restfull app。</p><p id="c34f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">之后我们能看到的最有趣的东西。使用YEPS，我们可以并行运行所有作业，但是使用promise接口(在YEPS接口后面，我们使用promise)我们可以使用优先级。首先我们应该设置我们的<strong class="ja hv">记录器</strong>和<strong class="ja hv">错误处理器</strong>(带有json响应头)。在检查请求并理解它不是获取静态文件如JavaScript文件或index.html的请求后(没有参数该模块查看<strong class="ja hv">公共</strong>目录),我们可以启用所有其他模块并且<strong class="ja hv">并行运行它</strong>。连接到redis后，设置所有安全头，我们可以开始解析请求并运行路由器处理程序。</p><p id="4122" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我在<a class="ae jw" href="https://github.com/evheniy/yeps-router" rel="noopener ugc nofollow" target="_blank"> YEPS路由器</a>中使用了相同的并行作业思想。例如，在express.js中，我们需要考虑哪些路线是最重要、最受欢迎的，并将其放在第一位。在YEPS路由器中，所有检查都是并行进行的。第一个匹配路由器将停止此过程。如果您需要设置优先级，您可以创建多个路由器:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="7f16" class="kn ko hu kj b fv kp kq l kr ks"><strong class="kj hv">const </strong>routerFirst = <strong class="kj hv">new </strong>Router();<br/><strong class="kj hv">const </strong>routerSecond = <strong class="kj hv">new </strong>Router();</span><span id="aa0f" class="kn ko hu kj b fv mc kq l kr ks">app<br/>.then(routerFirst.resolve())<br/>.then(routerSecond.resolve());</span></pre><p id="d167" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">不要忘记为我们的redis创建<strong class="ja hv">配置</strong>。你可以在<a class="ae jw" href="https://github.com/evheniy/yeps-redis" rel="noopener ugc nofollow" target="_blank"> yeps-redis </a>文档中找到例子。为此，我们需要创建<strong class="ja hv"> config </strong>目录，并放入<strong class="ja hv"> default.json </strong>文件:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="786c" class="kn ko hu kj b fv kp kq l kr ks">{<br/>  "redis": {<br/>    "host": "127.0.0.1",<br/>    "port": 6379<br/>  }<br/>}</span></pre><p id="0c23" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">要运行我们的服务器，我们需要在<strong class="ja hv"> package.json </strong>中创建<strong class="ja hv">入口点</strong>和<strong class="ja hv">脚本</strong>，就像我们为docker创建的一样:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="6371" class="kn ko hu kj b fv kp kq l kr ks">"start: server": "node ./bin/www",</span></pre><p id="1638" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">和<strong class="ja hv"> bin/www </strong>:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="0d7b" class="kn ko hu kj b fv kp kq l kr ks">#!/usr/bin/env node<br/><br/>const app = require('../server');<br/>const server = require('yeps-server');<br/><br/>server.createHttpServer(app);</span></pre><p id="9706" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">以及运行的命令:<strong class="ja hv"> npm run start:server </strong>(或者使用<strong class="ja hv"> ntl </strong>)。</p><p id="45ec" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">打开浏览器<a class="ae jw" href="http://localhost:3000/data" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/data</a>后检查响应。</p><h1 id="e0e4" class="la ko hu bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw dt translated">为了做好生产准备，我们需要创建我们的第一个测试。</h1><p id="2259" class="pw-post-body-paragraph iy iz hu ja b jb lx jd je jf ly jh ji jj lz jl jm jn ma jp jq jr mb jt ju jv hn dt translated">现在我们需要安装我们的第一个开发依赖项。为了进行测试，我们将使用<a class="ae jw" href="https://www.npmjs.com/package/mocha" rel="noopener ugc nofollow" target="_blank">摩卡</a>、<a class="ae jw" href="http://chaijs.com/api/bdd/" rel="noopener ugc nofollow" target="_blank">柴期望</a>、<a class="ae jw" href="http://sinonjs.org/" rel="noopener ugc nofollow" target="_blank">西农</a>和<a class="ae jw" href="https://github.com/chaijs/chai-http" rel="noopener ugc nofollow" target="_blank">柴-http </a>:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="e014" class="kn ko hu kj b fv kp kq l kr ks">npm i -D mocha chai chai-http sinon</span></pre><p id="7681" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">而我们的<strong class="ja hv"> package.json </strong>之后有<strong class="ja hv"> devDependencies </strong>:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="58e8" class="kn ko hu kj b fv kp kq l kr ks">"devDependencies": {<br/>  "chai": "^4.1.2",<br/>  "chai-http": "^3.0.0",<br/>  "mocha": "^3.5.3",<br/>  "sinon": "^3.3.0"<br/>}</span></pre><p id="82c9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了运行测试，我们需要将<strong class="ja hv">脚本</strong>添加到<strong class="ja hv"> package.json </strong>中:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="5c73" class="kn ko hu kj b fv kp kq l kr ks">"test:server": "mocha tests --recursive"</span></pre><p id="1b3a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">之后，创建测试目录，其中包含<strong class="ja hv">服务器</strong>目录和<strong class="ja hv"> index.js </strong>文件:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="cc06" class="kn ko hu kj b fv kp kq l kr ks">mkdir tests<br/>cd tests<br/>mkdir server<br/>cd server<br/>touch index.js</span></pre><p id="8eab" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">和我们后端测试的代码:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="0384" class="kn ko hu kj b fv kp kq l kr ks"><strong class="kj hv">const </strong>chai = require('chai');<br/><strong class="kj hv">const </strong>chaiHttp = require('chai-http');<br/><strong class="kj hv">const </strong>sinon = require('sinon');<br/><strong class="kj hv">const </strong>yeps = require('yeps-server');<br/><strong class="kj hv">const </strong>redis = require('yeps-redis/redis');<br/><strong class="kj hv">const </strong>logger = require('yeps-logger/logger');<br/><br/><strong class="kj hv">const </strong>app = require('../../server');<br/><br/><strong class="kj hv">const </strong>expect = chai.expect;<br/>chai.use(chaiHttp);<br/><strong class="kj hv">let </strong>server;<br/><br/>describe('Server testing', () =&gt; {<br/>    logger.info = text =&gt; text;<br/>    logger.error = text =&gt; text;<br/><br/>    beforeEach(() =&gt; {<br/>        server = yeps.createHttpServer(app);<br/>    });<br/><br/>    afterEach(() =&gt; {<br/>        server.close();<br/>    });<br/><br/>    it('should test 404 error', <strong class="kj hv">async </strong>() =&gt; {<br/>        <strong class="kj hv">const </strong>spy = sinon.spy();<br/>        <strong class="kj hv">await </strong>chai.request(server)<br/>            .get('/404')<br/>            .send()<br/>            .catch((error) =&gt; {<br/>                expect(error).to.have.status(404);<br/>                spy();<br/>            });<br/>        expect(spy.calledOnce).to.be.true;<br/>    });<br/><br/>    it('should test static server', <strong class="kj hv">async </strong>() =&gt; {<br/>        <strong class="kj hv">const </strong>spy = sinon.spy();<br/>        <strong class="kj hv">await </strong>chai.request(server)<br/>            .get('/index.html')<br/>            .send()<br/>            .then((res) =&gt; {<br/>                expect(res).to.have.status(200);<br/>                spy();<br/>            });<br/>        expect(spy.calledOnce).to.be.true;<br/>    });<br/><br/>    it('should test get data', <strong class="kj hv">async </strong>() =&gt; {<br/>        <strong class="kj hv">const </strong>spy = sinon.spy();<br/>        <strong class="kj hv">await </strong>redis.set('data', 'test');<br/>        <strong class="kj hv">await </strong>chai.request(server)<br/>            .get('/data')<br/>            .send()<br/>            .then((res) =&gt; {<br/>                expect(res).to.have.status(200);<br/>                expect(res.body).to.be.equal('test');<br/>                spy();<br/>            });<br/>        expect(spy.calledOnce).to.be.true;<br/>    });<br/><br/>    it('should test set data', <strong class="kj hv">async </strong>() =&gt; {<br/>        <strong class="kj hv">const </strong>spy = sinon.spy();<br/>        <strong class="kj hv">const </strong>data = 'test';<br/>        <strong class="kj hv">await </strong>chai.request(server)<br/>            .post('/data')<br/>            .send({ data })<br/>            .then((res) =&gt; {<br/>                expect(res).to.have.status(200);<br/>                spy();<br/>            });<br/>        <strong class="kj hv">const </strong>storedData = JSON.parse(<strong class="kj hv">await </strong>redis.get('data'));<br/>        expect(storedData.data).to.be.equal(data);<br/>        expect(spy.calledOnce).to.be.true;<br/>    });<br/>});</span></pre><p id="ab5e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在运行<strong class="ja hv"> npm run test:server </strong>之后，我们看到:</p><figure class="ke kf kg kh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff md"><img src="../Images/b0535f1f7bbf965cba56e928c79de438.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nR70bnL5E2EvEFP6MJ-RhA.png"/></div></div></figure><p id="7edb" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我禁用了记录器以查看清晰的结果(我们可以看到关于404错误测试的信息—未找到页面):</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="d811" class="kn ko hu kj b fv kp kq l kr ks">logger.info = text =&gt; text;<br/>logger.error = text =&gt; text;</span></pre><p id="2a1d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这就是我们的后端。我们创建了两个端点来获取和设置我们的数据，我们的服务器可以是一个静态服务器。现在我们准备在下一章开始我们的前端部分<strong class="ja hv">。</strong></p><p id="c549" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">和一些小的更新，如果你在团队工作。首先是<a class="ae jw" href="http://editorconfig.org/" rel="noopener ugc nofollow" target="_blank"> editorconfig </a>。对所有团队成员使用相同的代码标准很有帮助。我们需要创造<strong class="ja hv">。编辑器配置</strong>:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="de52" class="kn ko hu kj b fv kp kq l kr ks">root = true<br/><br/>[*]<br/>end_of_line = lf<br/>insert_final_newline = true<br/><br/>charset = utf-8<br/><br/>indent_style = space<br/>indent_size = 2</span></pre><p id="54f9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">下一步是安装<a class="ae jw" href="https://www.npmjs.com/package/nsp" rel="noopener ugc nofollow" target="_blank"> nsp </a> —节点安全平台。它帮助您保持节点应用程序的安全。我们只在开发时需要它，所以用<strong class="ja hv"> -D </strong>标志安装它:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="728b" class="kn ko hu kj b fv kp kq l kr ks">npm i -D nsp</span></pre><p id="131a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">并将脚本添加到<strong class="ja hv"> package.json </strong>来运行它:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="1289" class="kn ko hu kj b fv kp kq l kr ks">"test:security": "nsp check"</span></pre><p id="cd9d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">下一步是安装<a class="ae jw" href="https://www.npmjs.com/package/eslint" rel="noopener ugc nofollow" target="_blank"> eslint </a>和<a class="ae jw" href="https://www.npmjs.com/package/istanbul" rel="noopener ugc nofollow" target="_blank">伊斯坦布尔</a>。Eslint helsp配合ES6代码标准，我们会配合<a class="ae jw" href="https://www.npmjs.com/package/eslint-config-airbnb" rel="noopener ugc nofollow" target="_blank"> airbnb react插件</a>使用。由于我们将使用ES6和更高版本，我们需要安装新版本的伊斯坦布尔-伊斯坦布尔@next。</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="78dd" class="kn ko hu kj b fv kp kq l kr ks">npm i -D eslint eslint-config-airbnb eslint-plugin-jsx-a11y eslint-plugin-react eslint-plugin-import istanbul@next</span></pre><p id="153a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">要使用eslint，我们需要创建配置文件— <strong class="ja hv">。eslintrc </strong>:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="3a00" class="kn ko hu kj b fv kp kq l kr ks">{<br/>  "extends": "airbnb",<br/>  "env": {<br/>    "node": <strong class="kj hv">true</strong>,<br/>    "mocha": <strong class="kj hv">true<br/>  </strong>},<br/>  "rules": {<br/>    "jsx-a11y/href-no-hash": 0,<br/>    "no-unused-expressions": 0,<br/>    "no-multi-assign": 0<br/>  }<br/>}</span></pre><p id="8974" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">和脚本:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="cbe2" class="kn ko hu kj b fv kp kq l kr ks">"lint:js": "eslint server tests",</span></pre><p id="ba12" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">要运行:<strong class="ja hv"> npm运行lint:js </strong></p><p id="8b7a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">伊斯坦布尔也一样— <strong class="ja hv">.伊斯坦布尔. yml </strong>:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="f30d" class="kn ko hu kj b fv kp kq l kr ks"><strong class="kj hv">instrumentation:<br/>  default-excludes: </strong>true<br/>  <strong class="kj hv">excludes: </strong>[]<br/>  <strong class="kj hv">include-all-sources: </strong>true</span></pre><p id="6efd" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">和脚本:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="396b" class="kn ko hu kj b fv kp kq l kr ks">"test:coverage": "istanbul cover _mocha -- tests --recursive"</span></pre><p id="755f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在运行<strong class="ja hv"> npm运行测试之后:覆盖率</strong>我们看到</p><figure class="ke kf kg kh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff me"><img src="../Images/112f7af6cc83f03758cec42fb295d44d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2gSZjOyT7U0SO8_RAiqgTQ.png"/></div></div></figure><p id="6ab4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">要在一次点击中运行我们所有命令，我们需要<a class="ae jw" href="https://www.npmjs.com/package/npm-run-all" rel="noopener ugc nofollow" target="_blank"> npm-run-all </a>包:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="dea0" class="kn ko hu kj b fv kp kq l kr ks">npm i -S npm-run-all</span></pre><p id="d192" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">并且命令<strong class="ja hv"> npm run test </strong>(简而言之就是<strong class="ja hv"> npm test </strong>甚至<strong class="ja hv"> npm t </strong>)会运行我们所有的测试:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="0414" class="kn ko hu kj b fv kp kq l kr ks">"test": "npm-run-all test:**",</span></pre><p id="a952" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">最后一点——每个github库都应该有一个Readme.md文件，里面有如何安装和使用你的项目的说明。让我们检查一下<a class="ae jw" href="https://github.com/evheniy/react-awesome-app" rel="noopener ugc nofollow" target="_blank"> github库</a>。在下一章，我将向你展示如何轻松地创建真正的反应式应用程序。</p></div></div>    
</body>
</html>