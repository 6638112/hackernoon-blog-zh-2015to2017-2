<html>
<head>
<title>Compile Driven Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编译驱动学习</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/compile-driven-learning-3264034ca266?source=collection_archive---------19-----------------------#2017-04-03">https://medium.com/hackernoon/compile-driven-learning-3264034ca266?source=collection_archive---------19-----------------------#2017-04-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="0613" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">想象一下。你在你的宠物项目上取得了惊人的进展。您需要再添加一个组件来整合所有内容。你引入了一个外部库来帮助这个组件，而你…却被卡住了。你想知道你应该如何开始。你看一下图书馆的文档。不是特别有帮助。</p><p id="1abd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然Haskell库的文档并不总是很棒，但也有可取之处。正如我们之前所探讨的，Haskell是严格类型化的。一般来说，当它编译时，它按照我们期望的方式工作。至少这在Haskell中比其他语言更常见。对于学习新的库来说，这可能是一把双刃剑。</p><p id="09ec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一方面，如果你能为函数拼凑出正确的类型，你就成功了。但是，如果对库中的类型不太了解，就很难知道从何下手。如果你不知道如何构造正确类型的东西，你会怎么做？你可以试着写很多代码，但是你会得到大量的错误信息。因为你不熟悉这些类型，所以它们很难理解。</p><p id="b643" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这篇文章中，我将分享我解决这个学习问题的方法。我称之为“编译驱动学习”。要学习一个新的库或系统，应该从编写尽可能少的代码开始，这样代码才能继续编译。它与测试驱动开发的思想有着错综复杂的联系。我们将在下周的文章中更详细地讨论这个想法，但这里是10000英尺。概述。</p><h1 id="9aab" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">测试驱动开发</h1><p id="fb4d" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">测试驱动开发是一种软件开发的范例，在这种情况下，你在编写源代码之前先编写测试。您考虑您希望代码具有的效果，以及公开的函数应该是什么。然后编写测试，建立对公开功能的期望。一旦你对测试的范围感到满意，你就只需要为一个特性编写源代码。</p><p id="ea00" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦你这样做了，测试结果<strong class="it hv">驱动开发</strong>。您不必花费太多时间来确定您应该实现哪段代码。你找到第一个失败的测试用例，让它通过，清洗并重复。您希望编写尽可能少的代码来通过测试。显然，你不应该只是硬编码函数定义来适应测试。你的测试用例应该足够健壮，这是不可能的。</p><p id="3700" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，如果你试图写尽可能少的代码来通过测试，你可能会得到<strong class="it hv">杂乱无章的代码</strong>。这可不好。TDD中解决这个问题的主要思想是红绿重构循环。首先你写测试，失败(红色)。然后你让测试通过(绿色)。然后你重构你的代码，使它符合你正在使用的任何风格标准(重构)。当你完成了这个，你就可以进入下一个功能了。</p><h1 id="826a" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">编译驱动学习</h1><p id="a501" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">TDD很棒，但是我们不一定能把它应用到学习一个新的库上。如果你不知道类型，<strong class="it hv">你就不能写出好的测试</strong>。所以你可以用这个过程来代替。在某种程度上，我们使用类型系统和编译器来测试我们对代码的理解。我们可以使用这些知识来尽可能地保持代码编译，以实现两个目标:</p><ol class=""><li id="38ef" class="ks kt hu it b iu iv iy iz jc ku jg kv jk kw jo kx ky kz la dt translated">推动我们的发展，并准确了解我们下一步打算实施什么。</li><li id="e37f" class="ks kt hu it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la dt translated">避免令人沮丧的“错误之山”效应。</li></ol><p id="2e71" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该方法如下所示:</p><ol class=""><li id="6222" class="ks kt hu it b iu iv iy iz jc ku jg kv jk kw jo kx ky kz la dt translated">定义您正在实现的函数，然后将其删除为<code class="eh lg lh li lj b">undefined</code>。(您的代码应该仍然可以编译。)</li><li id="81c4" class="ks kt hu it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la dt translated">在定义函数时尽可能取得最小的进展，这样代码仍然可以编译。</li><li id="b983" class="ks kt hu it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la dt translated">确定下一段要写的代码，是需要填充的<code class="eh lg lh li lj b">undefined</code>值，还是对象的构造函数的存根部分。</li><li id="81d6" class="ks kt hu it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la dt translated">重复2–3。</li></ol><p id="a84b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意，在这个过程的每一步结束时，我们仍然应该有编译代码。这里的<code class="eh lg lh li lj b">undefined</code>值是一个很好的工具。它是Haskell中的一个值，可以采用任何类型，所以你可以用它来清除任何函数或值。关键是能够看到实现的下一层。</p><h1 id="5adf" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">实践中的CDL</h1><p id="a1c8" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">这是我的副业之一“一周应用”中的一个例子。首先我定义了一个我想写的函数:</p><pre class="lk ll lm ln fq lo lj lp lq aw lr dt"><span id="1f7e" class="ls jq hu lj b fv lt lu l lv lw">swiftFileFromView :: OWAAppInfo -&gt; OWAView -&gt; SwiftFile<br/>swiftFileFromView = undefined</span></pre><p id="3639" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该函数表示，我们希望能够获取一个关于Swift应用程序的“应用程序信息”对象以及一个视图对象，并为视图生成一个Swift文件。现在我们必须确定下一步。我们希望我们的代码在编译的同时仍然朝着解决问题的方向前进。<code class="eh lg lh li lj b">SwiftFile</code>类型是围绕<code class="eh lg lh li lj b">FileSection</code>项目列表的包装器。所以我们能够做到这一点:</p><pre class="lk ll lm ln fq lo lj lp lq aw lr dt"><span id="d746" class="ls jq hu lj b fv lt lu l lv lw">swiftFileFromView :: OWAAppInfo -&gt; OWAView -&gt; SwiftFile<br/>swiftFileFromView _ _ = SwiftFile []</span></pre><p id="6db6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这还编译！诚然，相当不完整！但是我们在<strong class="it hv">正确的方向</strong>上迈出了<strong class="it hv">微小的一步</strong>。</p><p id="2df4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下一步，我们必须确定哪些<code class="eh lg lh li lj b">FileSection</code>对象进入列表。在这种情况下，我们需要三个不同的部分。首先，我们在顶部有评论部分。其次，我们有一个“进口”部分。然后我们有主要的实现部分。因此，我们可以将这些表达式放在列表中，然后在下面将其删除:</p><pre class="lk ll lm ln fq lo lj lp lq aw lr dt"><span id="0aea" class="ls jq hu lj b fv lt lu l lv lw">swiftFileFromView :: OWAAppInfo -&gt; OWAView -&gt; SwiftFile<br/>swiftFileFromView _ _ = SwiftFile [commentSection, importsSection, classSection]<br/>  where<br/>    commentSection = undefined<br/>    importsSection = undefined<br/>    classSection = undefined</span></pre><p id="775b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这段代码仍然可以编译。现在我们可以一个接一个地填写<strong class="it hv">部分，而不是一次写完所有的代码。每一个都有自己的组成部分，我们将进一步分解。</strong></p><p id="7e21" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">利用我们对<code class="eh lg lh li lj b">FileSection</code>类型的了解，我们可以使用<code class="eh lg lh li lj b">BlockCommentSection</code>构造函数。这只需要一个字符串列表。同样，我们将为导入部分使用<code class="eh lg lh li lj b">ImportsSection</code>构造函数。它也需要一个列表。所以我们可以这样进步:</p><pre class="lk ll lm ln fq lo lj lp lq aw lr dt"><span id="55e9" class="ls jq hu lj b fv lt lu l lv lw">swiftFileFromView :: OWAAppInfo -&gt; OWAView -&gt; SwiftFile<br/>swiftFileFromView _ _ = SwiftFile [commentSection, importsSection, classSection]<br/>  where<br/>    commentSection = BlockCommentSection []<br/>    importsSection = ImportsSection []<br/>    classSection = undefined</span></pre><p id="a962" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以再一次，我们的代码<strong class="it hv">仍然编译</strong>，我们取得了小的进步。现在，我们将确定注释部分需要哪些字符串，并添加它们。然后我们可以为导入部分添加<code class="eh lg lh li lj b">Import</code>对象。如果我们搞砸了，我们将会看到一条错误消息，并且我们将会确切地知道问题在哪里。这有助于更快的开发过程。</p><h1 id="63a5" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">摘要</h1><p id="c9fc" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">我们讨论了这种学习新库的方法，但它对正常开发也很有帮助！避免一头扎进去写几百行代码的诱惑！处理<strong class="it hv">几十条错误信息</strong>你会后悔的！稳扎稳打才能赢得这场比赛。如果您将工作一部分一部分地分解，并使用编译器来检查您的工作，您将会更快地完成工作。</p><p id="0d3c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你想尝试实现编译驱动学习，你应该看看我们免费的<a class="ae lx" href="https://www.mmhaskell.com/workbook" rel="noopener ugc nofollow" target="_blank">回收工作簿</a>！它有10个练习题，以<code class="eh lg lh li lj b">undefined</code>开头。你可以试着一步一步地实现它们，看看你是否能通过测试！</p><p id="cc15" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您以前从未编写过任何Haskell，并且想要尝试一下，您应该阅读我们的<a class="ae lx" href="https://www.mmhaskell.com/checklist" rel="noopener ugc nofollow" target="_blank">入门清单</a>。它会告诉你关于写Haskell的第一行你需要知道的一切！</p><p id="13e4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，下周我们将更深入地讨论测试驱动开发，敬请关注。我们将通过使用测试用例，而不仅仅是看我们的代码是否编译，来看看我们如何能达到类似于CDL的效果。</p><blockquote class="ly lz ma"><p id="ff04" class="ir is mb it b iu iv iw ix iy iz ja jb mc jd je jf md jh ji jj me jl jm jn jo hn dt translated"><a class="ae lx" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是AMI家庭的一员。我们现在<a class="ae lx" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae lx" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is mb it b iu iv iw ix iy iz ja jb mc jd je jf md jh ji jj me jl jm jn jo hn dt translated">要了解更多信息，<a class="ae lx" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">请阅读我们的“关于”页面</a> , <a class="ae lx" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">喜欢/在脸书给我们发消息</a>，或者简单地，<a class="ae lx" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank">发推文/DM @HackerNoon。</a></p><p id="708a" class="ir is mb it b iu iv iw ix iy iz ja jb mc jd je jf md jh ji jj me jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lx" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lx" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>