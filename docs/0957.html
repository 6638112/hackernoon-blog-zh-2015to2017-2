<html>
<head>
<title>Some thoughts on Elm Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于榆树发展的几点思考</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/some-thoughts-on-elm-development-39a0f8a9002a?source=collection_archive---------0-----------------------#2016-07-25">https://medium.com/hackernoon/some-thoughts-on-elm-development-39a0f8a9002a?source=collection_archive---------0-----------------------#2016-07-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="9658" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">背景</h2></div><p id="78c5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我玩Elm已经有几个月了，现在我已经开始觉得我已经了解了这门语言以及如何把事情做好。这是一种非常好的感觉。然而，有一件事一直困扰着我，那就是一个组件和整个应用程序应该如何调整和设置。虽然这可能看起来是一个微不足道的细节，并且很容易被忽略，但是我发现这个小细节可以对一个或几个人长期维护的项目或者由一个更大的团队在短期内构建和维护的项目的结果产生深远的影响。</p><p id="fc85" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在查看Elm代码示例时，似乎没有明显的示例，所以我查看了个人示例，并与其他人的观点进行了比较。</p><h2 id="803f" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">第一步:看看你已经做了什么…</h2><p id="944a" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">从现在感觉像是无穷无尽的角度应用开始，我将从这里开始。根据Angular社区中无处不在的John Papa的指导，最佳实践似乎已经达到将控制器、服务和工厂划分为尽可能小的块。在UI方面，指令是一条可行的道路，但是我观察到它们的大小没有工厂和控制器那么严格。</p><blockquote class="lf"><p id="b765" class="lg lh hu bd li lj lk ll lm ln lo ke ek translated">…老实说，现在是2016年。我们有大量的用于后端的高效工具、快捷方式、技巧和抽象，为什么还有人在前端编写HTML呢？</p></blockquote><p id="94bd" class="pw-post-body-paragraph jj jk hu jl b jm lp iv jo jp lq iy jr js lr ju jv jw ls jy jz ka lt kc kd ke hn dt translated">实际上，我见过并经历过这样的项目，它们采用微小的服务、工厂和控制器，在指令之间共享它们，并且随着代码库的发展，产生非常微妙的错误和难以追踪的边缘情况。此外，随着时间的推移，指令有膨胀的趋势。然而，最让我沮丧的是:非常诚实地说，现在是2016年。我们有大量的用于后端的高效工具、快捷方式、技巧和抽象，为什么还有人在前端编写HTML呢？事实上，任何人不仅想继续使用HTML，而且实际上认为将Javascript随机插入HTML标签中会是一个更好的主意，这对我来说就像在开放的伤口上撒盐。</p><blockquote class="lf"><p id="1ffa" class="lg lh hu bd li lj lk ll lm ln lo ke ek translated">对我来说，Typescript和Angular 2感觉就像是向web Java的回归；这让我很难过。</p></blockquote><p id="0fa1" class="pw-post-body-paragraph jj jk hu jl b jm lp iv jo jp lq iy jr js lr ju jv jw ls jy jz ka lt kc kd ke hn dt translated">这就是我对Angular 1的体验。现在我需要决定是升级到2级还是跳槽。随着Angular的人积极推动Typescript、OOP，以及创建新项目的日益沉重的开销，感觉Angular 1中唯一有趣的东西已经被吸走了。对我来说，Typescript和Angular 2感觉就像是向web Java的回归；这让我很难过。</p><h2 id="f457" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">第二步:考虑替代方案…</h2><p id="a69a" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">所以Angular的两个答案，据我所知是React和Elm。我查看了React，实际上对这篇关于React无状态函数和Ramda的功能组件的<a class="ae lu" rel="noopener" href="/@mirkomariani/functional-components-with-react-stateless-functions-and-ramda-e83e54fcd86b#.u69g3uryt">帖子</a>感到非常兴奋。我通读了一遍，很喜欢我所看到的，并认为这将是模型。将所有东西分割成微小的DOM块，让数据流经它们各自的组件，这似乎正是我考虑应用程序的方式。我被迷住了。</p><p id="35a3" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不幸的是，对于所有来自React社区的好想法，有很多，有两件事让我担心:</p><ol class=""><li id="5965" class="lv lw hu jl b jm jn jp jq js lx jw ly ka lz ke ma mb mc md dt translated">工具、库、最佳实践、API甚至架构已经连续两年每个季度都在搅动。虽然太多的创新是一个典型的问题，但是JS疲劳是真实的，并且在跨分布式团队工作时会成倍恶化。</li><li id="37f4" class="lv lw hu jl b jm me jp mf js mg jw mh ka mi ke ma mb mc md dt translated">React和框架/设计/架构一样都是一门学科。如果团队中有人不守纪律，事情就会变得一团糟。</li></ol><h2 id="b55e" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">因此把我带到了榆树…</h2><p id="8beb" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">榆树很棒。它通过尽可能减少状态问题来处理它。它处理“严肃的HTML…这是2016年的问题，通过代表我的函数生成它。它将我的应用程序简化为可测试的功能。它通过一个令人愉快且有用的编译器降低了重构导致的错误的风险。它消除了所有说服力的类型不变量。它甚至在每次保存后为我格式化文件。它解决了我这么多的JS疼痛，我很高兴能做一个后空翻。然而，尽管如此，有些事情感觉不太对劲。</p><h2 id="57c3" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">布兰南街的精神指引…</h2><p id="62e5" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">所以我寻求专业帮助。最近在旧金山的一次榆树聚会上，我和永远令人愉快的理查德·费尔德曼聊了聊。我和他分享了编写无状态组件的梦想，这些组件可以像“拼图块”一样被用来构建越来越大的块，并创建一个网站。他友好地倾听并提供反馈，这完全改变了我对应用程序应该如何架构的思路。</p><blockquote class="lf"><p id="8a46" class="lg lh hu bd li lj lk ll lm ln lo ke ek translated">“你需要多大就做多大的记录。当它让你不舒服的时候，可能就是重构的时候了。”</p></blockquote><p id="a08c" class="pw-post-body-paragraph jj jk hu jl b jm lp iv jo jp lq iy jr js lr ju jv jw ls jy jz ka lt kc kd ke hn dt translated">这与我迄今为止所读到的关于埃尔姆的一切都截然相反。当我阅读可组合的无状态组件时，我想到了无数的三行函数慢慢构建成一个网站。事实证明Elm也可以做到这一点(您很快就会看到这一点)。但这并不是最难的部分。真正重要的是缩减器和状态管理部分。在Elm应用程序中传递状态和消息现在是一个活跃的讨论领域，但是普遍的看法是没有必要将应用程序分割成比所需更小的部分。在一个elm文件中包含一个完整的页面或Elm应用程序的主要组件是很自然的事情；模型、更新、视图等。尽管如果你愿意，你当然可以把这三个部分分开。</p><p id="e2d7" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以这个周末，我带着这个建议在一个可爱的免费榆树球场工作时接受了这个建议。这很有趣，也很自然，让我重新体会到了函数式编程的一个主要好处:函数式编程为你提供了为自己和他人构建漂亮API的工具和框架。不信你看看这个更新功能(一个elm app的真实动作在哪里):</p><pre class="mj mk ml mm fq mn mo mp mq aw mr dt"><span id="59f6" class="kf kg hu mo b fv ms mt l mu mv">update : Msg -&gt; Model -&gt; Model<br/>update msg model =<br/>    case msg of<br/>        -- On new input, update the text in input box<br/>        Input name -&gt;<br/>            { model | name = name }</span><span id="cc9f" class="kf kg hu mo b fv mw mt l mu mv">        --On clicking the save button<br/>        Save -&gt;<br/>            case (model.playerId) of<br/>                -- If the user is being edited, IE already has a <br/>                -- playerId<br/>                Just playerId -&gt;<br/>                    model<br/>                        |&gt; updatePlayerNames playerId<br/>                        |&gt; updateNameInPlays playerId<br/>                        |&gt; clearInputBox<br/>                        |&gt; clearPlayerIndex<br/>                        |&gt; deactivateEditMode</span><span id="eac7" class="kf kg hu mo b fv mw mt l mu mv">                -- If the user is new, IE doesn't yet have <br/>                -- a playerId<br/>                Nothing -&gt;<br/>                    model<br/>                        |&gt; addNewPlayer<br/>                        |&gt; clearInputBox<br/>                        |&gt; clearPlayerIndex<br/>                        |&gt; deactivateEditMode</span><span id="7dc6" class="kf kg hu mo b fv mw mt l mu mv">        -- On clicking the cancel button<br/>        Cancel -&gt;<br/>            model<br/>                |&gt; clearInputBox<br/>                |&gt; clearPlayerIndex<br/>                |&gt; deactivateEditMode</span><span id="e21e" class="kf kg hu mo b fv mw mt l mu mv">        -- When the edit mode is activated by "pencil button" click<br/>        Edit player -&gt;<br/>            model<br/>                |&gt; putNameInInputBox player.name<br/>                |&gt; setPlayerIndex player.playerId<br/>                |&gt; activateEditMode player.playerId</span><span id="0e1a" class="kf kg hu mo b fv mw mt l mu mv">        -- When the two or three point buttons are clicked, <br/>        -- update scores<br/>        Score playerId points -&gt;<br/>            model<br/>                |&gt; updatePlayerScore playerId points<br/>                |&gt; appendPlays playerId points</span><span id="78dc" class="kf kg hu mo b fv mw mt l mu mv">        DeletePlay play -&gt;<br/>            model<br/>                |&gt; removePlay play<br/>                |&gt; updatePlayerScore<br/>                    play.playerId<br/>                    (negate play.points)</span></pre><p id="1988" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果那不是禅，我不知道那是什么。那是适合人类消费的代码。您可以向非技术经理展示的代码…或者你妈妈，他们会完全理解的。<em class="mx">“哦，对了，当你编辑一个球员时，把他们的名字放进输入框，设置球员索引，然后激活编辑模式……”。</em>完美。</p><h2 id="38d1" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">我是如何学会停止担忧，重新开始创作的…</h2><p id="3d99" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">所以我从中得到的教训是……放松。当您的应用程序从概念验证阶段进入生产阶段时，Elm会处理那些让您和您的团队感到沮丧的事情，其间还会有许多新特性。<strong class="jl hv">将你的应用程序分割成微小的部分是治标不治本。</strong>您可以将每一个DOM呈现部分缩减成更小、更可重用的组件，比如:</p><pre class="mj mk ml mm fq mn mo mp mq aw mr dt"><span id="644a" class="kf kg hu mo b fv ms mt l mu mv">playerSection : Model -&gt; Html Msg<br/>playerSection model =<br/>    div<br/>        []<br/>        [ playerListHeader<br/>        , playerListModel model<br/>        , pointTotal model<br/>        ]</span><span id="a775" class="kf kg hu mo b fv mw mt l mu mv">pointTotal : Model -&gt; Html Msg<br/>pointTotal model =<br/>    let<br/>        total =<br/>            List.map .points model.players<br/>                |&gt; List.sum<br/>    in<br/>        footer []<br/>            [ div [] [ text "Total: " ]<br/>            , div [] [ text &lt;| toString total ]<br/>            ]</span><span id="b672" class="kf kg hu mo b fv mw mt l mu mv">playerListHeader : Html Msg<br/>playerListHeader =<br/>    header<br/>        []<br/>        [ div [] [ text "Name" ]<br/>        , div [] [ text "Points" ]<br/>        ]</span><span id="4f96" class="kf kg hu mo b fv mw mt l mu mv">playerListModel : Model -&gt; Html Msg<br/>playerListModel model =<br/>    model.players<br/>        |&gt; List.sortBy .name<br/>        |&gt; List.map (domPlayerMaker model)<br/>        |&gt; ul []</span><span id="648c" class="kf kg hu mo b fv mw mt l mu mv">domPlayerMaker : Model -&gt; Player -&gt; Html Msg<br/>domPlayerMaker model player =<br/>    let<br/>        editChecker =<br/>            if<br/>                model.editMode<br/>                    == True<br/>                    &amp;&amp; model.editPlayerId<br/>                    == player.playerId<br/>            then<br/>                class "edit"<br/>            else<br/>                class ""<br/>    in<br/>        li []<br/>            [ i<br/>                [ class "edit"<br/>                , onClick (Edit player)<br/>                ]<br/>                []<br/>            , div [ editChecker ]<br/>                [ text player.name ]<br/>            , pointButtonMaker 2 player<br/>            , pointButtonMaker 3 player<br/>            , div []<br/>                [ text &lt;| toString player.points ]<br/>            ]</span><span id="e9b2" class="kf kg hu mo b fv mw mt l mu mv">pointButtonMaker : Int -&gt; Player -&gt; Html Msg<br/>pointButtonMaker i player =<br/>    button<br/>        [ type' "button"<br/>        , onClick &lt;| Score player.playerId i<br/>        ]<br/>        [ text &lt;| toString (i) ++ "pt" ]</span></pre><p id="2aaf" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">…这非常酷，也是React文章一开始就如此简洁的原因。然而，微观的DOM函数实际上并不是一个需要答案的问题。</p><p id="96d1" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我血压下降的是状态被最小化，并且在一个地方，每个组件开始完成，并且只负责代码的更新功能。构建你的声明式API的所有助手函数都能够留在文件中或者移动到一个助手函数文件中；这是你的电话。然而，函数式编程为您提供了快速构建API所需的所有工具，并且希望其他人会发现该API非常有用，并且能够在他们的项目中加以利用。最重要的是，因为所有这些函数都是纯函数，所以当你们都在使用它的时候，你不再需要担心有人会改变对象、原型或者代码中的任何东西。给定一个x，这个函数将总是产生一个y，而不管这个函数是在何时、何地、在什么上下文中被调用的。</p><p id="6c8d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我意识到这是React在无状态功能组件中的一个主要推动，但是我需要强调，这是一个建议，而不是一个要求。即使是最训练有素的团队也会偷工减料，POC也有一个非常糟糕的习惯，那就是超过了它们的有用性，并且可怕地超出了它们的预期用途。我在软件开发方面的经验不断提醒我两个谚语:</p><ol class=""><li id="aab7" class="lv lw hu jl b jm jn jp jq js lx jw ly ka lz ke ma mb mc md dt translated">任何可以被削减的角落，在某个时候都会被削减。</li><li id="b408" class="lv lw hu jl b jm me jp mf js mg jw mh ka mi ke ma mb mc md dt translated">没有比暂时更长久的了。</li></ol><p id="fef0" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Elm消除了我所见过的JS框架的所有主要障碍，几乎没有什么需要放弃的。但由于一切都还很新鲜，最佳实践似乎更多的是口头传统，而不是任何致力于写作的东西。因此，我想与他人分享我的想法、经验和对话，以便这种语言和Elm社区能够繁荣发展。理查德的反馈是我前进所需的指导，让我对自己正在做的事情充满信心，并让我期待构建更大、更有趣的东西。我真诚地希望我已经或将要在这里写的东西对其他人同样有用，我将继续写我在Elm的经历和学习。</p><p id="cd03" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">感谢詹姆斯·马龙将免费的Elm教程放在网上，感谢理查德·费尔德曼倾听我的意见，给我信心，让我继续做一些很酷的东西。</p><p id="d423" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">代码可供您查阅:<a class="ae lu" href="https://github.com/NewMountain/Scorekeeper" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><blockquote class="my mz na"><p id="b13f" class="jj jk mx jl b jm jn iv jo jp jq iy jr nb jt ju jv nc jx jy jz nd kb kc kd ke hn dt translated"><a class="ae lu" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae lu" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae lu" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae lu" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="jj jk mx jl b jm jn iv jo jp jq iy jr nb jt ju jv nc jx jy jz nd kb kc kd ke hn dt translated">要了解更多信息，请<a class="ae lu" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae lu" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae lu" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="jj jk mx jl b jm jn iv jo jp jq iy jr nb jt ju jv nc jx jy jz nd kb kc kd ke hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lu" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lu" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>