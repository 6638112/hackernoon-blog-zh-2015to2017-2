<html>
<head>
<title>Webpack: Creating dynamically named outputs for wildcarded entry files</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Webpack:为通配符条目文件创建动态命名的输出</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/webpack-creating-dynamically-named-outputs-for-wildcarded-entry-files-9241f596b065?source=collection_archive---------4-----------------------#2017-11-12">https://medium.com/hackernoon/webpack-creating-dynamically-named-outputs-for-wildcarded-entry-files-9241f596b065?source=collection_archive---------4-----------------------#2017-11-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="36ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果这不是一个性感的头衔，我不知道什么是。</p><p id="b54c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最近，当我试图让它输出以条目文件动态命名的包时，遇到了一个Webpack大小的砖墙。棘手的部分是，我希望它对我将来可能要编写的某一类型的所有文件进行前瞻性的处理。</p><p id="b784" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我在网上找不到任何答案或可以招募的节点包，所以我决定自己写。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/74a941f47b4c2202c7b770efa54bb077.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*rCU-bT07JQjDu9VDwvKLbw.png"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek"><a class="ae kf" href="https://www.npmjs.com/package/webpack-entry-plus" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/webpack-entry-plus</a></figcaption></figure></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><p id="9c1b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">问题如下:我有一个文件夹存放我所有的核心JavaScript代码:</p><pre class="jq jr js jt fq kn ko kp kq aw kr dt"><span id="43ab" class="ks kt hu ko b fv ku kv l kw kx">|-- core<br/>    |-- file1.js<br/>    |-- file2.js</span></pre><p id="486c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我知道这些文件的名称，我也知道我希望将它们捆绑在一起，以及将输出文件放在哪里:</p><pre class="jq jr js jt fq kn ko kp kq aw kr dt"><span id="77fd" class="ks kt hu ko b fv ku kv l kw kx">|-- build<br/>    |-- main.js    &lt;&lt; Bundle all core files here<br/>|-- core<br/>    |-- file1.js<br/>    |-- file2.js</span></pre><p id="f761" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">容易做到:</p><pre class="jq jr js jt fq kn ko kp kq aw kr dt"><span id="8bc6" class="ks kt hu ko b fv ku kv l kw kx">// webpack.config.js</span><span id="84a7" class="ks kt hu ko b fv ky kv l kw kx">module.exports = {<br/>  entry: ['./core/file1.js', './core/file2.js'],<br/>  output: {<br/>    filename: './build/[name].js',    &lt;&lt; [name] defaults to 'main'<br/>  },                                  &lt;&lt; more on that later<br/>}</span></pre><p id="c4c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，我在某个地方有一堆其他文件夹，它们只与某些内容相关，我希望它们的包相对于源条目文件的位置输出:</p><pre class="jq jr js jt fq kn ko kp kq aw kr dt"><span id="b458" class="ks kt hu ko b fv ku kv l kw kx">|-- build<br/>    |-- main.js<br/>|-- core<br/>    |-- file1.js<br/>    |-- file2.js<br/>|-- content<br/>    |-- one<br/>        |-- index.js       &lt;&lt; This index<br/>        |-- main.js        &lt;&lt; Gets bundled here<br/>    |-- two<br/>        |-- sub<br/>            |-- index.js   &lt;&lt; This index<br/>            |-- main.js    &lt;&lt; Gets bundled here</span></pre><p id="7099" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">作为开发人员，我们编写了<code class="eh kz la lb ko b">index.js</code>,但是我们希望<a class="ae kf" href="https://hackernoon.com/tagged/webpack" rel="noopener ugc nofollow" target="_blank"> Webpack </a>获取它并处理同一个文件夹中紧挨着它的输出<code class="eh kz la lb ko b">main.js</code>。我们已经能够通过将一个对象传递给Webpack的<code class="eh kz la lb ko b">entry</code>值，覆盖默认的<code class="eh kz la lb ko b">[name]</code>，并处理多个包来做到这一点。只要我们了解我们正在处理的文件，这种方法就有效:</p><pre class="jq jr js jt fq kn ko kp kq aw kr dt"><span id="652b" class="ks kt hu ko b fv ku kv l kw kx">// webpack.config.js</span><span id="df97" class="ks kt hu ko b fv ky kv l kw kx">module.exports = {<br/>  entry: {<br/>    build:           ['./core/file1.js', './core/file2.js'],<br/>    content/one:     ['./content/one/index.js'],<br/>    content/two/sub: ['./content/two/sub/index.js'],<br/>  },<br/>  output: {<br/>    filename:        './[name]/main.js',<br/>  },<br/>}</span></pre><p id="372c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Webpack将用每个<code class="eh kz la lb ko b">entry</code>对象的条目构建一个包。键<code class="eh kz la lb ko b">(build, content/one, content/two/sub)</code>将作为<code class="eh kz la lb ko b">[name]</code>值传递给<code class="eh kz la lb ko b">output</code>，要捆绑的文件将是每个键的数组值。</p><p id="964e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这项技术非常强大，如果您愿意，可以用来生成带扩展名的绝对文件名，例如:</p><pre class="jq jr js jt fq kn ko kp kq aw kr dt"><span id="54ee" class="ks kt hu ko b fv ku kv l kw kx">...</span><span id="f513" class="ks kt hu ko b fv ky kv l kw kx">entry: {<br/>  build/main.js: ['./core/file1.js', './core/file2.js'],<br/>},<br/>output: '[name]',</span><span id="8de8" class="ks kt hu ko b fv ky kv l kw kx">...</span></pre><p id="5906" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们难题中的最后一个挑战是，我们并不知道我们想要构建的所有<code class="eh kz la lb ko b">content</code>包，即使我们知道，我们也不一定想要为所有的包硬编码条目。所以我们使用<code class="eh kz la lb ko b">glob</code>节点包来匹配一个通配符，并返回一个包含所有与之匹配的文件的数组:</p><pre class="jq jr js jt fq kn ko kp kq aw kr dt"><span id="5e33" class="ks kt hu ko b fv ku kv l kw kx">// webpack.config.js</span><span id="e854" class="ks kt hu ko b fv ky kv l kw kx">const glob = require('glob');</span><span id="77be" class="ks kt hu ko b fv ky kv l kw kx">entry: glob.sync('content/**/index.js'),  &lt;&lt; Returns Array of files</span></pre><p id="895c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，这就是问题所在。没有办法为每个通配符文件创建一个包，然后输出到与条目相同的文件夹中。</p><p id="d0af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是知道了我们对<code class="eh kz la lb ko b">entry</code>值对象的了解，并且能够操纵<code class="eh kz la lb ko b">[name]</code>为我们所用，用一个下午的时间编写代码就能得出一个解决方案。操作filepath值，为我们的构建返回一个合适的<code class="eh kz la lb ko b">[name]</code>:</p><pre class="jq jr js jt fq kn ko kp kq aw kr dt"><span id="d8b2" class="ks kt hu ko b fv ku kv l kw kx">// webpack.config.js</span><span id="19cf" class="ks kt hu ko b fv ky kv l kw kx">const glob = require('glob');</span><span id="501c" class="ks kt hu ko b fv ky kv l kw kx">const entryArray = glob.sync('content/**/index.js');</span><span id="b288" class="ks kt hu ko b fv ky kv l kw kx">const entryObject = entryArray.reduce((acc, item) =&gt; {<br/>  const name = item.replace('/index.js', '');<br/>  acc[name] = item;<br/>  return acc;<br/>}, {});</span><span id="bc4e" class="ks kt hu ko b fv ky kv l kw kx">module.exports = {<br/>  entry:  entryObject,<br/>  output: '[name]/main.js',<br/>}</span></pre><p id="f5c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上面的<code class="eh kz la lb ko b">entryObject</code>将返回这个，一个适合Webpack的<code class="eh kz la lb ko b">entry</code>值的值:</p><pre class="jq jr js jt fq kn ko kp kq aw kr dt"><span id="c290" class="ks kt hu ko b fv ku kv l kw kx">{<br/>  content/one:     ['./content/one/index.js'],<br/>  content/two/sub: ['./content/two/sub/index.js'],<br/>}</span></pre><p id="a73e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果有必要，我们可以使用<code class="eh kz la lb ko b">Object.assign()</code>来组合指定或通配符条目文件的多个对象，以使用这种技术创建适当的输出包，或者使用<code class="eh kz la lb ko b">.reduce()</code>或<code class="eh kz la lb ko b">.map()</code>或我们喜欢的任何东西。而这正是我所做的:)</p><p id="2940" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，因为我认为这是一个没有现有解决方案的常见问题，所以我创建了一个简单的包，它可以为我们处理所有这些问题，并为大多数其他用例提供一个合理的API。</p><p id="767c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">无论您是想要推出自己的定制实施，还是想要一个开箱即用的解决方案，我都建议您查看一下:</p><div class="lc ld fm fo le lf"><a href="https://www.npmjs.com/package/webpack-entry-plus" rel="noopener  ugc nofollow" target="_blank"><div class="lg ab ej"><div class="lh ab li cl cj lj"><h2 class="bd hv fv z el lk eo ep ll er et ht dt translated">网络包-入口-plus</h2><div class="lm l"><h3 class="bd b fv z el lk eo ep ll er et ek translated">从已知或未知的条目文件生成动态webpack捆绑包输出名称</h3></div><div class="ln l"><p class="bd b gc z el lk eo ep ll er et ek translated">www.npmjs.com</p></div></div><div class="lo l"><div class="lp l lq lr ls lo lt jz lf"/></div></div></a></div><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="lu lv l"/></div></figure></div></div>    
</body>
</html>