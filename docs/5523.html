<html>
<head>
<title>Routing without URLs in ChocolateChip-UI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ChocolateChip-UI中不带URL的路由</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/routing-without-urls-in-chocolatechip-ui-7079a12fab7e?source=collection_archive---------16-----------------------#2017-07-31">https://medium.com/hackernoon/routing-without-urls-in-chocolatechip-ui-7079a12fab7e?source=collection_archive---------16-----------------------#2017-07-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/eed0b0e5abe2f46b61e33d6b7c3ea093.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tVH1AgQnLj2xNd6wVEGx7A.png"/></div></div></figure><p id="0f17" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当读者读到这个标题时，我能听到他们的抱怨和挠头。为什么你想要没有url的路由？目的是什么？这到底是怎么回事？我们在这里讨论的是在使用<a class="ae ka" href="https://chocolatechip-ui.github.io" rel="noopener ugc nofollow" target="_blank"> ChocolateChip-UI </a>构建的应用中使用导航时路由是如何工作的。这是一个为Android和iOS创建混合移动应用的框架。因此，用户永远不会接触到Webview的chrome。他们只与应用程序的结构和内容进行交互。用户看不到浏览器及其url栏。</p><h1 id="d8e8" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">基础知识</h1><p id="46af" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">要理解为什么我们提出了没有URL的路由，你首先要理解ChocolateChip-UI移动应用程序是如何构造的。一个ChocolateChip-UI应用程序基于屏幕的概念。当你看任何设备时，你会发现应用程序位于屏幕的较大区域，从状态栏下方到屏幕的左、右和底部。ChocolateChip-UI使用一个特殊的标签来表示这个查看区域:<code class="eh le lf lg lh b">ui-screen</code>。<code class="eh le lf lg lh b">ui-screen</code>由于反应灵敏，可自动扩展以填满所有可用空间。在下面的Codepen示例中，我们有一个蓝色背景的<code class="eh le lf lg lh b">ui-screen</code>,所以你可以看到它是如何扩展以填充所有可用空间的:</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="808f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh le lf lg lh b">ui-screen</code>只是其他结构的容器。最常见的两种是<code class="eh le lf lg lh b">nav</code>和<code class="eh le lf lg lh b">section</code>。你也可以在屏幕底部添加一个<code class="eh le lf lg lh b">footer</code>作为工具栏。<code class="eh le lf lg lh b">nav</code>是使用<code class="eh le lf lg lh b">h1</code>放置屏幕标题的地方。您还可以放置某种类型的按钮来实现用户交互。标签是那个屏幕的内容所在。下面是一个带有<code class="eh le lf lg lh b">nav</code>和<code class="eh le lf lg lh b">section</code>的Codepen示例:</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><h1 id="160d" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">处理屏幕状态</h1><p id="dead" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">因为一个<code class="eh le lf lg lh b">ui-screen</code>填满了整个屏幕，所以其他屏幕需要放在屏幕之外。ChocolateChip-UI通过使用一组三个类来处理这个问题:</p><ol class=""><li id="c079" class="lo lp hu je b jf jg jj jk jn lq jr lr jv ls jz lt lu lv lw dt translated"><code class="eh le lf lg lh b">previous</code></li><li id="b656" class="lo lp hu je b jf lx jj ly jn lz jr ma jv mb jz lt lu lv lw dt translated"><code class="eh le lf lg lh b">current</code></li><li id="6f0d" class="lo lp hu je b jf lx jj ly jn lz jr ma jv mb jz lt lu lv lw dt translated"><code class="eh le lf lg lh b">next</code></li></ol><p id="4981" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当一个<code class="eh le lf lg lh b">ui-screen</code>有一个<code class="eh le lf lg lh b">previous</code>类时，它将被转换为-100%的transition-x值，这将使它离开屏幕向左移动。具有类<code class="eh le lf lg lh b">current</code>的<code class="eh le lf lg lh b">ui-screen</code>将以0的过渡值进行变换，这将其定位到视图中。类别为<code class="eh le lf lg lh b">next</code>的<code class="eh le lf lg lh b">ui-screen</code>将以100%的过渡值进行变换，这将使其位于屏幕右侧。如果你需要支持从右到左的语言，比如阿拉伯语、波斯语、乌尔都语或希伯来语，你可以将<code class="eh le lf lg lh b">dir='rtl'</code>放在<code class="eh le lf lg lh b">html</code>标签上。这样做会导致定位翻转到相反的方向。这使得导航动画对那些语言来说感觉很合适。</p><p id="2392" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在下面的Codepen示例中，我们创建了两个<code class="eh le lf lg lh b">ui-screens</code>，一个包含一个类<code class="eh le lf lg lh b">current</code>，另一个包含一个类<code class="eh le lf lg lh b">next</code>。通过点击按钮，我们改变类来触发导航体验。注意<code class="eh le lf lg lh b">ui-screens</code>是如何自动滑入和滑出的。</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="4717" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用这种类的切换给了我们从一个屏幕导航到另一个屏幕的体验。我们不需要知道链接或网址。我们只需切换这些类，就可以获得物理导航到某个目的地的效果。虽然很酷，但这很乏味。你真的不希望每次需要导航的时候都要编写代码来切换类。为了避免这种情况，ChocolateChip-UI提供了一个导航系统。</p><h1 id="15cd" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">航行</h1><p id="c34e" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">移动操作系统可以通过多种方式让用户导航到应用程序的不同屏幕。最常见的方式是导航列表。正如我们已经看到的，ChocolateChip-UI希望你的应用程序由在视图内外活动的<code class="eh le lf lg lh b">ui-screens</code>组成。为了更容易实现这一点，ChocolateChip-UI有一个简单的机制来显示您想要转换到哪个<code class="eh le lf lg lh b">ui-screen</code>。首先，您需要创建一个列表。然后使用一个特殊的属性:<code class="eh le lf lg lh b">data-goto</code>来指示每个列表项指向哪个<code class="eh le lf lg lh b">ui-screen</code>。它的值将是您想去的<code class="eh le lf lg lh b">ui-screen</code>的id。为了表示列表项是可导航的，在<code class="eh le lf lg lh b">aside</code>标签中添加一个显示指示器:</p><pre class="li lj lk ll fq mc lh md me aw mf dt"><span id="bbca" class="mg kc hu lh b fv mh mi l mj mk">&lt;li data-goto='detail-page'&gt;<br/>  &lt;h3&gt;Item&lt;/h3&gt;<br/>  &lt;aside&gt;<br/>    &lt;disclosure&gt;&lt;/disclosure&gt;<br/>  &lt;/aside&gt;<br/>&lt;/li&gt;</span></pre><p id="def0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这会给你一个这样的列表</p><figure class="li lj lk ll fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ml"><img src="../Images/ee3b6bd08e7fc9380d82ffa9c6b90e74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lh_3cnKfKuU-9PD1Y4XwrQ.png"/></div></div></figure><h1 id="0556" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">将用户界面导航导入您的应用</h1><p id="f493" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">为了让这个导航列表工作，您需要将导航小部件添加到您的项目中。您可以通过将它导入到项目的<code class="eh le lf lg lh b">app.js</code>文件中来实现。顺便说一下，如果你不知道如何开始一个新的ChocolateChip-UI项目，请阅读<a class="ae ka" href="https://chocolatechip-ui.github.io/v5/install.html" rel="noopener ugc nofollow" target="_blank">文档</a>了解如何安装和创建项目。</p><p id="918e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要导入<code class="eh le lf lg lh b">ui-navigation</code>，请将以下内容添加到您的<code class="eh le lf lg lh b">app.js</code>文件的顶部:</p><pre class="li lj lk ll fq mc lh md me aw mf dt"><span id="b717" class="mg kc hu lh b fv mh mi l mj mk">import {UINavigation} from './src/widgets/ui-navigation</span></pre><p id="1d54" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">导入后，当您在浏览器中构建和加载应用程序时，您会发现点击带有属性<code class="eh le lf lg lh b">data-goto='detail-page'</code>的列表项会将您转换到id为<code class="eh le lf lg lh b">detail-page</code>的<code class="eh le lf lg lh b">ui-screen</code>。当然，你需要确保你的应用程序有这样一个<code class="eh le lf lg lh b">ui-screen</code>，否则你会过渡到一个空白屏幕。</p><h1 id="243b" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">怎么回去</h1><p id="a53a" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">如果您导航到某个屏幕，您可能希望返回到上一个屏幕。点击浏览器的后退按钮不起作用，因为这是通过由类触发的动画来完成的。ChocolateChip-UI提供了一种简单的方式来启用后退导航。在目的地屏幕的<code class="eh le lf lg lh b">nav</code>标签中，放置一个带有类别<code class="eh le lf lg lh b">back</code>的按钮。当用户导航到该屏幕时，点击后退按钮将自动将用户导航回前一屏幕。后退按钮只是一个带有<code class="eh le lf lg lh b">back</code>类的按钮。它应该是<code class="eh le lf lg lh b">nav</code>标签中的第一项，在<code class="eh le lf lg lh b">h1</code>之前:</p><pre class="li lj lk ll fq mc lh md me aw mf dt"><span id="c18e" class="mg kc hu lh b fv mh mi l mj mk">&lt;nav&gt;<br/>  &lt;button class='back'&gt;Back&lt;/button&gt;<br/>  &lt;h1&gt;Some Details&lt;/h1&gt;<br/>&lt;/nav&gt;</span></pre><p id="8b6c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面的Codepen示例展示了所有这些工作:</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="32eb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您仔细观察这支笔，您会注意到没有JavaScript来实现导航。启用导航的标记约定意味着您不必编写任何JavaScript就能实现这一点。相反，在加载时，ChocolateChip-UI监听器监听属性为<code class="eh le lf lg lh b">data-goto</code>的列表项和类别为<code class="eh le lf lg lh b">back</code>的<code class="eh le lf lg lh b">ui-screen</code> <code class="eh le lf lg lh b">nav</code>标签中的按钮。这使得向前和向后导航能够正常工作。</p><h1 id="c43a" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">跟踪导航</h1><p id="50af" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">从上面的例子可以清楚地看出，向前导航非常容易管理。用户点击列表项目。ChocolateChip-UI抓取<code class="eh le lf lg lh b">data-goto</code>值，知道去哪个屏幕。它通过更改其类将当前屏幕导航到视图之外，并通过更改其类将目标导航到视图中。但是当用户点击后退按钮时，它如何知道回到哪里呢？ChocolateChip-UI使用了一个特殊的数组:<code class="eh le lf lg lh b">$.ChuiRoutes</code>。当应用程序第一次加载时，ChocolateChip-UI将当前<code class="eh le lf lg lh b">ui-screen</code>的id推送到这个数组中。然后，当用户点击带有<code class="eh le lf lg lh b">data-goto</code>属性的列表项时，ChocolateChip-UI会将该id推送给<code class="eh le lf lg lh b">$.ChuiRoutes</code>。您可以通过打开浏览器的控制台并检查<code class="eh le lf lg lh b">$.ChuiRoutes</code>的值来随时检查您的路线。那么，后退键呢？当你点击它时，ChocolateChip-UI弹出<code class="eh le lf lg lh b">$.ChuiRoutes</code>数组并获得最后一个数组项。然后切换弹出项的类和数组中最后一项的类。这为您提供了向后导航。后退按钮不需要知道<code class="eh le lf lg lh b">$.ChuiRoutes</code>当前值以外的任何信息。</p><p id="7f4c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以下Codepen示例阐释了这种向前和向后导航:</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="9108" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用导航目标中列表项和后退按钮上的<code class="eh le lf lg lh b">data-goto</code>属性这一简单技术，您可以创建向下钻取几个级别的导航。以下Codepen示例说明了这一点:</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><h1 id="58d5" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">多目的地导航</h1><p id="6124" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">通常，当您点击导航列表的列表项目时，您会想要查看该项目的更多详细信息。使用简单的声明性技术最终需要大量的<code class="eh le lf lg lh b">ui-screens</code>。下面的Codepen示例说明了这个问题。你拥有的物品越多，你需要的<code class="eh le lf lg lh b">ui-screens</code>就越多:</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="d996" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这样效率不高。最好是所有列表项只有一个目的地，并动态呈现内容。要启用这种方法，您需要使用路由参数进行路由。</p><h1 id="398b" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">遇见路由器</h1><p id="f757" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">ChocolateChip-UI有路由器。要使用它，您需要将其导入到您的<code class="eh le lf lg lh b">app.js</code>文件中:</p><pre class="li lj lk ll fq mc lh md me aw mf dt"><span id="7462" class="mg kc hu lh b fv mh mi l mj mk">import {UINavigation} from './src/widgets/ui-navigation'<br/>import {Router} form './src/widgets/ui-router'</span></pre><p id="f664" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Router是一个类，所以要使用它，需要创建一个实例。初始化需要两个值:一个路由和一个在路由发生时执行的回调。但是没有用于导航的URL，那么这是如何工作的呢？当用户点击带有<code class="eh le lf lg lh b">data-goto</code>的列表项时，它会发布这个<code class="eh le lf lg lh b">ui-screen</code> id。使用路由器，您可以创建监听该路由的路由。当用户点击发布路由时，将执行回调。以下是您设置路由的方式:</p><pre class="li lj lk ll fq mc lh md me aw mf dt"><span id="29cd" class="mg kc hu lh b fv mh mi l mj mk">import {UINavigation} from './src/widgets/ui-navigation'<br/>import {Router} form './src/widgets/ui-router'</span><span id="f647" class="mg kc hu lh b fv mm mi l mj mk">app(() =&gt; {<br/>  const router = new Router() <br/>  router.addRoute({<br/>    route: 'detail',<br/>    callback: (param) =&gt; {<br/>      // Handle the route <br/>    }<br/>  })<br/>})</span></pre><p id="0c71" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面的路线假设用户将点击一个列表项，其<code class="eh le lf lg lh b">data-goto</code>值为<code class="eh le lf lg lh b">detail</code>，这将是一个<code class="eh le lf lg lh b">ui-screen</code>的id。路由回调期望接收一个参数(param ),我们可以用它来知道哪个项目被点击了。那么，我们如何获得路线的参数呢？这需要将一条额外的信息传递给列表项<code class="eh le lf lg lh b">data-goto</code>属性。通常情况下，<code class="eh le lf lg lh b">data-goto</code>属性的值就是要转到的<code class="eh le lf lg lh b">ui-screen</code>的id。但是我们可以告诉ChocolateChip-UI用这个id传递更多的信息。为此，我们向id添加一个<code class="eh le lf lg lh b">:</code>，后面跟着我们要传递的值。</p><p id="24ad" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这需要我们暂时转移话题。假设我们有一个人员列表:</p><pre class="li lj lk ll fq mc lh md me aw mf dt"><span id="bdf8" class="mg kc hu lh b fv mh mi l mj mk">const people = [<br/>  {<br/>    firstName:'Joe',<br/>    lastName:'Bodoni'<br/>  }, <br/>  {<br/>    firstName:'Ellen',<br/>    lastName:'Vanderbilt'<br/>  },<br/>  {<br/>    firstName:'Sam',<br/>    lastName:'Anderson'<br/>  }<br/>]</span></pre><p id="bc76" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们想把这些数据打印成一个列表，没问题。然而，如果我们希望能够识别每个人，他们需要一些独特的标识符。这可能是id、uuid、guid或密钥。选择一个并给每个对象一个:</p><pre class="li lj lk ll fq mc lh md me aw mf dt"><span id="c2ea" class="mg kc hu lh b fv mh mi l mj mk">const people = [<br/>  {<br/>    id: 101,<br/>    firstName:'Joe',<br/>    lastName:'Bodoni'<br/>  }, <br/>  {<br/>    id: 102,<br/>    firstName:'Ellen',<br/>    lastName:'Vanderbilt'<br/>  },<br/>  {<br/>    id: 103,<br/>    firstName:'Sam',<br/>    lastName:'Anderson'<br/>  }<br/>]</span></pre><p id="f2ff" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用上面的数据，我们可以这样定义我们的列表组件，每个列表项的<code class="eh le lf lg lh b">data-goto</code>属性获得每个对象的惟一id:</p><pre class="li lj lk ll fq mc lh md me aw mf dt"><span id="17d3" class="mg kc hu lh b fv mh mi l mj mk">const list = new Component({<br/>  element: '#peopleList', <br/>  // Add route parameter using object id:<br/>  render: (person) =&gt; html`<br/>    &lt;li data-goto='detail:${person.id}'&gt;<br/>      &lt;h3&gt;${person.firstName} ${person.lastName}&lt;/h3&gt;<br/>      &lt;aside&gt;<br/>        &lt;disclosure&gt;&lt;/disclosure&gt;<br/>      &lt;/aside&gt;<br/>    &lt;/li&gt;`<br/>})</span></pre><p id="6bff" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上述组件将创建具有以下导航属性的列表项:</p><ol class=""><li id="e2fc" class="lo lp hu je b jf jg jj jk jn lq jr lr jv ls jz lt lu lv lw dt translated"><code class="eh le lf lg lh b">data-goto='detail:101'</code></li><li id="0c8f" class="lo lp hu je b jf lx jj ly jn lz jr ma jv mb jz lt lu lv lw dt translated"><code class="eh le lf lg lh b">data-goto='detail:102'</code></li><li id="befe" class="lo lp hu je b jf lx jj ly jn lz jr ma jv mb jz lt lu lv lw dt translated"><code class="eh le lf lg lh b">data-goto='detail:103'</code></li></ol><p id="9d8e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当用户点击其中一个列表项时，<code class="eh le lf lg lh b">:</code>后的值将作为路线参数发送。通过检查route参数，我们可以确定用户点击了哪个列表项，并过滤数据以显示适当的内容。下面是一个假设的用例:</p><pre class="li lj lk ll fq mc lh md me aw mf dt"><span id="19d9" class="mg kc hu lh b fv mh mi l mj mk">import {UINavigation} from './src/widgets/ui-navigation'<br/>import {Router} form './src/widgets/ui-router'</span><span id="395d" class="mg kc hu lh b fv mm mi l mj mk">app(() =&gt; {<br/>  const router = new Router() <br/>  router.addRoute({<br/>    route: 'detail',<br/>    callback: (param) =&gt; {<br/>      // Handle the route <br/>      const person = people.filter(person =&gt; person.id == id)<br/>      // Render the destination screen list with this data:<br/>      chosenPersonList.render(person)   <br/>    }<br/>  })<br/>})</span></pre><p id="fbc1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是一个Codepen示例，说明了动态列表创建和路由是如何工作的:</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="0468" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要了解更多关于导航和路线的信息，请查阅<a class="ae ka" href="https://chocolatechip-ui.github.io/v5/docs/widgets/navigation.html" rel="noopener ugc nofollow" target="_blank">文档</a>和<a class="ae ka" href="https://chocolatechip-ui.github.io/v5/docs/tutorials/tutorials-routing.html" rel="noopener ugc nofollow" target="_blank">教程</a>。</p><h1 id="a8ba" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">看，妈，没有网址！</h1><p id="1b22" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">通过使用<code class="eh le lf lg lh b">data-goto</code>属性来处理导航，这将激活ChocolateChip-UI的内部pubsub系统来发布哪个<code class="eh le lf lg lh b">ui-screen</code>是目的地，并传递一个路线参数。这意味着没有必要弄乱浏览器的网址。现在你可能会反对说，没有办法捕捉一个url发送给某人。但我想不出有哪一次我在使用原生应用程序时，能够在其中找到一个网址。嗯，除非是直接暴露地址栏。只有少数原生应用程序在显示诸如迷因或实际网页等内容时会实际暴露浏览器url。但是，为什么要费心为此构建一个本地应用程序呢？更有意义的是为那些类型的用例构建一个PWA(渐进式web应用)。</p></div></div>    
</body>
</html>