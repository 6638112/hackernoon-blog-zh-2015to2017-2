# 使用 RxJS 处理 HTTP 请求

> 原文：<https://medium.com/hackernoon/using-rxjs-to-handle-http-requests-what-ive-learned-4640aaf4646c>

当我第一次开始学习 RxJS 时，我可以本能地看到，可观察流为解决我在前端 web 应用程序开发中每天遇到的许多问题提供了各种可能性。我已经使用 flux 架构有一段时间了，它给我的 web 应用带来的组织结构的清晰性和关注点的分离令我惊叹不已。我读到过 RxJS 也能做到这一点，并且很想知道是如何做到的。对 HTTP 请求的优雅处理似乎是这个学习旅程的明显起点。

然而，我很快就感到沮丧，因为我在一个地方所能找到的关于这个主题(特别是错误处理)的良好实践的信息是如此之少，并且不得不通过四处阅读、大量浏览 Stackoverflow 和 Github 问题线程以及个人实验来找出大多数东西。这篇文章是我迄今为止所学内容的目录。

我将解释一些简便的方法来完成以下任务:

*   从 HTTP 请求创建可观察的流
*   处理 HTTP 错误响应
*   无序 HTTP 请求完成的优雅处理
*   限制用户输入
*   一些额外的额外提示和技巧

我将假设一些创建和订阅 observables 的绝对基础知识，因为这很容易在网上找到[，并且是我开始试验 RxJS 和 HTTP 请求的地方。](https://www.sitepoint.com/functional-reactive-programming-rxjs/)

# 示例应用程序

为了演示所有这些技术，我们将创建一个使用 g [ithub 用户 api](https://api.github.com/users/jamesflight) 的迷你应用程序示例。它将使用户能够在一个框中键入 github 用户名，如果有效，将在下面显示他们的头像。我将使用该应用程序的许多变体来演示使用 RxJS 的不同方式。为了保持简单，该应用程序只使用 RxJS，bootstrap 和一点点 jQuery 来粘合页面。

注意:github 用户 api，在未经授权的情况下，每小时有 60 个请求的可怜的速率限制。因此，如果你对这些例子过于乐观，它们可能会停止工作一段时间。

## 设置

首先，让我们创建一个文本输入，并从它的“keyup”事件创建一个可观察对象。

Example 1: Input Box

在框中键入并点击搜索按钮，以查看包含文本输入值的警告。注意在可观察到的`fromEvent`之后链接的额外的`map`。这使我们能够将搜索输入框的当前输入值映射到我们的`userClicksSearchButton`可观察对象，替换通常会发出的默认事件对象。

# 处理 HTTP 请求

好了，我们现在有了一个可观察对象，当用户点击搜索按钮时，它将发出用户输入。为了启动我们的 HTTP 请求，我们将创建一个可观察的流，我们可以使用我们的`userClicksSearchButton`作为源进行订阅:

Example 2: Button Search

试着在框中输入你的 github 用户名，点击搜索，你应该会看到你的头像出现在下面。要知道，目前，如果你搜索一个无效的用户名，它将打破应用程序。现在不要担心这个；我们一会儿会解决这个问题。

我们在第一个可观察对象之后链接了`flatMap`,订阅了结果可观察对象，并将一些接收到的数据写入 DOM。

我们已经使用标准的 jQuery get 执行了请求，我们已经将它封装在 RxJS 的有用的`fromPromise`中，以将其转化为可观察的。

## **平面地图**

看看例子中“平面图”的用法。我必须承认，当我第一次看到这类事情的一些例子时，我感到非常困惑。乍一看，我们应该能够像对点击事件那样调用`map`，毕竟，我们已经通过调用`fromPromise`将承诺转化为可观察的结果，对吗？

实际上，`fromPromise`返回的是一个可观察到的承诺流*，而不是承诺解析时发出的对象流。`flatMap`允许我们将所有这些承诺的解析整合到一个可观察的流中，当我们订阅它时，我们得到的只是 jQuery 最初在`then()`发出的响应对象。*

# *处理错误*

*之前我提到过，如果你搜索一个无效的用户名，这个应用程序就会崩溃(试着搜索一些胡言乱语，然后是完全有效的东西)。这显然很糟糕，最初，根本不清楚为什么会发生这种情况。为了理解为什么，让我们来看看承诺解决时事件发生的顺序:*

1.  *HTTP 请求完成，jQuery 拒绝了这个承诺(因为它是 404)*
2.  *由`fromPromise`创建的可观察对象抛出一个错误，因为这是它对被拒绝的承诺的反应*
3.  *该错误未被捕获，因此在父`flatMap` observable 中再次抛出。*
4.  *`flatMap` observable 将不再发出，因为在一个 observable 流抛出一个错误后，它被终止。*

*这有一个意想不到的副作用，那就是每当我们得到一个错误响应时，我们的搜索按钮就变得毫无用处。这不太好，那么我们该如何处理这个问题呢？*

*这又是一个应用程序，但这次是错误处理:*

*Example 3: Button Search With Error Handling*

*现在，我们在错误向上游传播之前捕捉并处理它，并用一个空的完整的错误替换可观察的错误，该错误将在其位置变平。为此我们使用了方便的`Rx.Observable.empty()`。*

# *处理无序请求*

*让我们稍微改变一下这个例子。假设我们希望用户能够在输入框中输入内容，而不是点击按钮进行搜索，并在输入的同时进行搜索。为此，我们需要将`userClicksSearchButton`可观测值替换为`userTypesInSearchBox`可观测值，如下所示:*

*Example 4: Text Search*

*我们现在发现，因为我们的每个请求都被快速连续地触发，所以我们不能再保证它们会按照发起的顺序完成。这可能会导致我们的搜索结果不匹配的头像显示在下面。这并不好，所以为了解决这个问题，我们将使用`concatMap`。*

## *串联图*

*`concatMap`和`flatMap`很像，除了它会保持源发射的顺序，即使被它拉平的可观测物以不同的顺序发射。例如，如果我搜索“Elle”，然后立即搜索“Ellen”，而“Ellen”请求恰好首先完成，`concatMap`将等待“Elle”请求完成，然后以“Elle”“Ellen”的顺序连续发出两个结果。*

*下面是代码，修改后使用了“concatMap”。*

*Example 5: Text Search Preserving Request Order*

*编辑:我刚刚得知我们也可以用`switchMap`来做这件事。这提供了额外的好处，即在必要时取消底层的冗余 http 请求。*

# *限制用户输入*

*目前，我们的应用程序会在用户每次向文本框中输入一个字母时发出一个请求。考虑到用户直到在输入框中输入至少几个字母后才真正有兴趣看到结果，这看起来有点过了。当服务器对用户体验没有任何帮助时，为什么还要敲打它呢？使用 RxJS，我们可以通过一个简单的额外函数调用“去反跳”来缓解这个问题。*

*Example 6: Text Search Throttled*

*在本例中，值得一提的是，在控制台窗口的 network 选项卡中，当您在框中键入内容时，会发现发送的请求比前一个示例少得多。*

## *去抖*

*“去抖”接受一个数字参数，该参数代表可观测对象在上次发射后再次发射前应等待的毫秒数。在这段时间过去后，可观测物体将只发出这段时间内的最后一次辐射，而忽略其他任何辐射。我发现这对基于实时文本的搜索功能非常有帮助。*

*注意:如果您需要它发射相反的信号，即该时间段内的第一次发射，您可以使用`throttle`方法。*

# ***额外提示和技巧***

*上述技术将处理大多数 HTTP 请求用例，但是您可以做一些其他很酷的事情来减轻异步请求处理带来的一些痛苦:*

## *拿*

*有时候，你只对前 1、2 或 n 个用户交互感兴趣。对于这些情况，RxJS 提供了“take”方法。在我们的搜索按钮示例中，假设我们只想显示第一个有效的结果:*

*Example 7: Text Search With Take*

*现在，执行的第一个搜索将会起作用，但是随后在框中键入的任何内容都将被忽略。*

## *过滤器*

*有时，我们希望根据条件过滤掉某些可观察到的辐射。为了演示，让我们使用`filter`让我们的文本搜索示例忽略搜索，直到它们至少有 5 个字符长:*

*Example 8: Text Search Filtered*

## *合并*

*有时，将多个可观测值合并成一个可观测值是很有用的。为了演示，让我们使用`merge`为我们的搜索应用程序提供两个输入，您可以通过键入任意一个进行搜索:*

*Example 9: Text Search With Merge*

## *为以后保留数据*

*以上所有示例的一个潜在问题是，当我们处于可观察流的后期阶段时，在请求完成之后，我们已经丢失了对原始有效负载的引用(在本例中，是我们的搜索词文本)。我们可以将原始有效负载与响应有效负载捆绑在一起，同时仍然可以通过词法范围访问它。例如，假设我们想将搜索词作为`render`函数的一部分再次写入页面:*

*Example 10: Text Search With Retained Data*

## *合并最新*

*RxJS 最好的特性之一是将多个流合并成一个流是多么容易。为了演示，让我们修改我们的示例来执行两个搜索，并允许用户比较彼此相邻的结果头像，但仅在两个搜索都有结果之后:*

*Example 11: Text Search With Combine Latest*

# *接下来呢？*

*有许多方法可以最大限度地利用 RxJS 处理 HTTP 请求的能力，我们已经提到了其中的一些方法。然而，RxJS API 是一个复杂的庞然大物，我们仅仅触及了 RxJS 方法可以用 HTTP 流做的许多不同方式的表面。一旦你了解了一些，就很有必要查看一下[文档](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/libraries/main/rx.complete.md),尝试更多可能有助于更具体用例的文档。*

*[![](img/50ef4044ecd4e250b5d50f368b775d38.png)](http://bit.ly/HackernoonFB)**[![](img/979d9a46439d5aebbdcdca574e21dc81.png)](https://goo.gl/k7XYbx)**[![](img/2930ba6bd2c12218fdbbf7e02c8746ff.png)](https://goo.gl/4ofytp)*

> *[黑客中午](http://bit.ly/Hackernoon)是黑客如何开始他们的下午。我们是 [@AMI](http://bit.ly/atAMIatAMI) 家庭的一员。我们现在[接受投稿](http://bit.ly/hackernoonsubmission)，并乐意[讨论广告&赞助](mailto:partners@amipublications.com)机会。*
> 
> *如果你喜欢这个故事，我们推荐你阅读我们的[最新科技故事](http://bit.ly/hackernoonlatestt)和[趋势科技故事](https://hackernoon.com/trending)。直到下一次，不要把世界的现实想当然！*

*![](img/be0ca55ba73a573dce11effb2ee80d56.png)*