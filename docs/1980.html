<html>
<head>
<title>Akka Streams, a Story of Scalability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Akka Streams，可扩展性的故事</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/akka-streams-a-story-of-scalability-5d9e7c2d3ac3?source=collection_archive---------1-----------------------#2016-12-28">https://medium.com/hackernoon/akka-streams-a-story-of-scalability-5d9e7c2d3ac3?source=collection_archive---------1-----------------------#2016-12-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/fdeb8d50776a2ad7d16cc011ab1057e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c-nyGE_kfwf3IuT-8gNYQQ.png"/></div></div></figure><p id="bd33" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">构建数据管道是当今几乎每个公司的共同任务。然而，它们的建造方式各不相同。</p><p id="f768" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作为一家公司，我们和其他公司没有什么不同，所以我们也在构建这些数据路径，但是工具总是因地而异。</p><p id="32a5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我将要描述的内容可以使用任何可用的大数据工具来实现，比如Apache Spark，我也是它的忠实粉丝。然而，团队对Akka进行了大量投资，我们用它建立了几个内部系统，这在某种程度上意味着我们要探索如何完成手头的任务。</p><p id="1986" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了简化问题，我们会说我们的任务在于计算一个代表特定文件的唯一行的值。例如，给定一个文件<strong class="je hv">一个</strong>，其内容如下:</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="f602" class="kj kk hu kf b fv kl km l kn ko">This is just a <br/>Test file<br/>For this example</span></pre><p id="74d4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用函数<strong class="je hv"> f(s: String) = &gt; int </strong>处理这个文件的结果是:</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="f6fe" class="kj kk hu kf b fv kl km l kn ko">2342342<br/>12341234151245<br/>234</span></pre><p id="ad75" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="kp">请不要太在意函数f，让我们专注于过程的整体视图。</em></p><p id="4d9a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用Akka流，我们可以创建一个简单的管道来处理这些文件。让我们看看怎么做。</p><figure class="ka kb kc kd fq iv"><div class="bz el l di"><div class="kq kr l"/></div></figure><p id="6083" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，我们定义我们的流的构建块。然后，必须把它们放在一起。</p><figure class="ka kb kc kd fq iv"><div class="bz el l di"><div class="kq kr l"/></div></figure><p id="0d75" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们基本上完成了。我们已经构建了一个流，它将逐行处理每个文件，计算每个文件的权重，最后写下值。</p><h2 id="077c" class="kj kk hu bd ks kt ku kv kw kx ky kz la jn lb lc ld jr le lf lg jv lh li lj lk dt translated">真正的问题是</h2><p id="29d7" class="pw-post-body-paragraph jc jd hu je b jf ll jh ji jj lm jl jm jn ln jp jq jr lo jt ju jv lp jx jy jz hn dt translated">当所描述的流执行其工作时，需要花费很长时间来处理，因为文件可能非常大。</p><h2 id="a3e5" class="kj kk hu bd ks kt ku kv kw kx ky kz la jn lb lc ld jr le lf lg jv lh li lj lk dt translated">第一次尝试。增加流并行度</h2><p id="90b2" class="pw-post-body-paragraph jc jd hu je b jf ll jh ji jj lm jl jm jn ln jp jq jr lo jt ju jv lp jx jy jz hn dt translated">我们的第一个尝试是增加流中并发映射器的数量。我们可以重新定义管道的部件，以便在给定的时刻做更多的工作。</p><figure class="ka kb kc kd fq iv"><div class="bz el l di"><div class="kq kr l"/></div></figure><p id="9641" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为我们有大型机器，我们可以增加并行性。此外，我们不太关心顺序，因为计算出的值每行都是唯一的，所以我们可以根据行的权重轻松确定确切的值(文件，行)。</p><p id="6d3c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如您所料，现在性能有所提高，但是考虑到等待处理的数据量，还不够好。即使我们在任何给定的时间做更多的处理，我们也不能超越一台计算机的能力，Akka流现在还不支持它。</p><h2 id="6e2f" class="kj kk hu bd ks kt ku kv kw kx ky kz la jn lb lc ld jr le lf lg jv lh li lj lk dt translated">第二次尝试。回到基础</h2><p id="405c" class="pw-post-body-paragraph jc jd hu je b jf ll jh ji jj lm jl jm jn ln jp jq jr lo jt ju jv lp jx jy jz hn dt translated">使用流很容易，很好，也很干净，但是有时我们需要回到基本的抽象上来。</p><p id="29cd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将使用<em class="kp"> Akka集群</em>和<em class="kp">分布式发布/订阅</em>通过管道移动我们的数据。</p><figure class="ka kb kc kd fq iv"><div class="bz el l di"><div class="kq kr l"/></div></figure><p id="3f88" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这里，我们创建了两个actors，它们的功能与我们之前创建的streams相同。尽管如此，我们还是错过了读取数据集的那个。</p><figure class="ka kb kc kd fq iv"><div class="bz el l di"><div class="kq kr l"/></div></figure><p id="900c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个actor将获取一个流，并将它的元素(文件、行)发布到集群，这样<code class="eh lq lr ls kf b">WeightCalculator</code>就可以做相应的工作。</p><p id="7a44" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们创建一个运行这个管道的应用程序，看看所有的东西是如何组合在一起的。</p><figure class="ka kb kc kd fq iv"><div class="bz el l di"><div class="kq kr l"/></div></figure><p id="21f8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这一点上，我们有一个可运行的应用程序，它做的和我们使用流时一样。然而，这种方法可以通过在同一个或不同的JVM中部署更多的某种类型的角色(<code class="eh lq lr ls kf b">WeightCalculator or Writer</code>)来更容易地扩展。我们甚至可以在网络上的不同机器上远程部署它们。所有这些部署策略都由Akka集群提供支持。</p><p id="d35c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们对每一步的处理器数量没有限制，但是这种方法有一个有趣的问题。</p><p id="1317" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在stream的世界中，我们有内置的反压力，所以我们不必担心过多的消息淹没演员。然而，使用我们的新方法，我们将大量消息推入集群，根据我们的经验，这会导致大量JVM崩溃。</p><h2 id="9d5f" class="kj kk hu bd ks kt ku kv kw kx ky kz la jn lb lc ld jr le lf lg jv lh li lj lk dt translated">第三次尝试。拉与推</h2><p id="18dd" class="pw-post-body-paragraph jc jd hu je b jf ll jh ji jj lm jl jm jn ln jp jq jr lo jt ju jv lp jx jy jz hn dt translated">如果我们能够使用Akka集群部署，同时能够控制消息从<em class="kp">源</em>传播的速度，那就太好了。我们可以通过改变演员来实现这一目标。</p><p id="bd5d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们需要首先改变我们的来源，所以我们退出。</p><figure class="ka kb kc kd fq iv"><div class="bz el l di"><div class="kq kr l"/></div></figure><p id="8d47" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这里，<code class="eh lq lr ls kf b">Streamer</code>默认不推送任何东西。它等待某个消费者在集群上发布的<strong class="je hv"> <em class="kp"> SendNext(to) </em> </strong>消息，其中<strong class="je hv"> <em class="kp">到</em> </strong> <em class="kp"> </em>的值是消费者的地址。然后<code class="eh lq lr ls kf b">Streamer</code>会将流的下一个元素直接发送给它。这种机制保证了元素只被发送给请求它们的参与者。</p><p id="7b6b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一方面，任何参与者都可以通过在集群上发布请求来请求元素。我们需要改变<code class="eh lq lr ls kf b">WeightCalculator</code>，以便它在需要时请求元素。</p><figure class="ka kb kc kd fq iv"><div class="bz el l di"><div class="kq kr l"/></div></figure><p id="0e52" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如您所看到的，<code class="eh lq lr ls kf b">WeightCalculator</code>只有在处理完一个给定的元素后才会请求新元素。通过这种方式，我们避免了过多的消息淹没它，使它无法一次处理。</p><p id="d811" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<code class="eh lq lr ls kf b">WeightCalculator</code>处理完一条消息后，它将使用主题<code class="eh lq lr ls kf b">out</code>在集群中发布结果，这样它就可以被<code class="eh lq lr ls kf b">Writer</code>记录下来。</p><p id="e6de" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以使用相同的<code class="eh lq lr ls kf b">app</code>来运行我们的管道，但是请记住，由于集群的能力，我们可以在任何地方部署我们的参与者，我们不会受到单台计算机的限制。</p></div><div class="ab cl lt lu hc lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hn ho hp hq hr"><p id="633c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用Akka集群，我们可以无限制地扩大规模，但即使有大量的计算机，我们最终还是会淹没大量的参与者，导致崩溃和失败。在我们的特殊情况下，消息传播的方式很重要，改变为<em class="kp">拉动</em>的方式似乎是解决方案。通过从源头拉取，我们可以让不同的组件一起工作，每个组件以自己的速度进行处理；<em class="kp">速度慢的比速度快的处理得少，但是不会崩溃。</em></p><p id="4db2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们相信，我们遇到的问题是一个非常普遍的问题，这篇文章旨在让您了解可能会出现的问题以及该解决方案如何为我们服务。</p><p id="7f45" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们希望我们简单的例子能够清楚地说明问题，同时帮助您找到解决问题的方法。</p><p id="c728" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">希望我们将看到Akka流在集群上运行，因为它们的抽象很容易使用，也很容易放在一起；目前，我们需要寻找替代方案。</p><div class="ka kb kc kd fq ab cb"><figure class="ma iv mb mc md me mf paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="ma iv mb mc md me mf paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="ma iv mb mc md me mf paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mg mh mi"><p id="f922" class="jc jd kp je b jf jg jh ji jj jk jl jm mj jo jp jq mk js jt ju ml jw jx jy jz hn dt translated"><a class="ae mm" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae mm" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae mm" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae mm" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd kp je b jf jg jh ji jj jk jl jm mj jo jp jq mk js jt ju ml jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae mm" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae mm" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ka kb kc kd fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mn"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>