<html>
<head>
<title>React Native ListView Performance Revisited — Recycling Without the Bridge</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重新审视React本机ListView性能—无需桥接即可回收</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/react-native-listview-performance-revisited-recycling-without-the-bridge-c4f62d18c7dd?source=collection_archive---------1-----------------------#2017-03-16">https://medium.com/hackernoon/react-native-listview-performance-revisited-recycling-without-the-bridge-c4f62d18c7dd?source=collection_archive---------1-----------------------#2017-03-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/4a129ae5f1060119814c86795b65fdd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zmYlpNFQTAF1rEzPJsXDuA.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">airplanes take off against the wind</figcaption></figure><p id="f240" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="ke"> ListView表现在</em><a class="ae kf" href="https://hackernoon.com/tagged/react-native" rel="noopener ugc nofollow" target="_blank"><em class="ke">React Native</em></a><em class="ke">是我最喜欢的开放议题之一。正在取得重大进展，但这个问题似乎没有一个单一的一站式解决方案，可以处理每一个用例。阻碍我们前进的一个因素是React本地桥的异步性。有没有可能把它从等式中剔除？</em></p></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><h2 id="a7bf" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">这么多伟大的思想聚集在一个房间里</h2><p id="7c0f" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">我在从2017年<a class="ae kf" href="http://conf.reactjs.org/" rel="noopener ugc nofollow" target="_blank"> ReactConf </a>回来的飞机上。与我们行业的许多巨头一起度过整整3天是我经历过的最鼓舞人心的经历之一。我终于可以在我在Twitter上关注的所有个人资料上放上真实的面孔了！</p><p id="79ff" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我一直对React Native中列表视图的挑战很感兴趣。你知道什么..我和这个领域最有影响力的三个人在一起:<a class="ae kf" href="https://twitter.com/notbrent" rel="noopener ugc nofollow" target="_blank"><em class="ke">Brent Vatne</em></a>——Expo的领导者之一，React本地社区背后的驱动力。<a class="ae kf" href="https://twitter.com/sahrens2012" rel="noopener ugc nofollow" target="_blank"> <em class="ke">斯潘塞阿伦斯</em></a>——来自<a class="ae kf" href="https://hackernoon.com/tagged/facebook" rel="noopener ugc nofollow" target="_blank">脸书</a> React原生核心团队，他们最近发布了<a class="ae kf" href="https://facebook.github.io/react-native/blog/2017/03/13/better-list-views.html" rel="noopener ugc nofollow" target="_blank"> FlatList </a>。以及<a class="ae kf" href="https://twitter.com/brian_d_vaughn" rel="noopener ugc nofollow" target="_blank"><em class="ke">Brian Vaughn</em></a>—<a class="ae kf" href="https://github.com/bvaughn/react-virtualized" rel="noopener ugc nofollow" target="_blank">背后的人React Virtualized </a>，这是我见过的针对网络这个问题的最佳实现。</p><h2 id="73dd" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">那么，还需要做些什么呢？</h2><p id="a99e" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">列表视图有许多用例，不同的用例需要不同的优化。React Native中的当前实现可以很好地处理具有各种各样单元格的复杂列表，这些单元格可以滚动而不会跳来跳去。将脸书的信息与你手机的联系人列表进行对比。</p><p id="2268" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">当一个用户有几百或几千个联系人，并且正在浏览试图找到一个特定的联系人时，他们使用列表的方式完全不同。滚动模式会更加不稳定，跳跃更大，滑动更快。如果我们从另一个世界借用，你可以说用户正试图进行<em class="ke">随机访问</em>而不是<em class="ke">顺序访问</em>:)</p><p id="714d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这也是React Native最难的地方。滚动发生在<em class="ke">本地领域</em>中，但是行的呈现异步发生在<em class="ke"> JavaScript领域</em>中。它们之间的数据在网桥上排队。如果你滚动得足够快，渲染请求最终会排队等待，导致滚动中出现空白。</p><h2 id="005a" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">我们能帮上什么忙？</h2><p id="9da7" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">许多人认为Fiber是有前途的——它能够控制渲染优先级并取消不再需要的未决渲染。这肯定很有趣，但我们将尝试完全不同的东西。</p><p id="7096" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们将试着把桥从等式中完全去掉。我们以前在处理其他性能问题时也采用过这种方法。使用<a class="ae kf" href="https://facebook.github.io/react-native/docs/animated.html" rel="noopener ugc nofollow" target="_blank"> Animated </a>的本地驱动程序，动画最终可以以60 FPS的速度运行，从而最大限度地减少桥接流量……我刚刚在ReactConf中展示了一种很酷的方法，用<a class="ae kf" rel="noopener" href="/@talkol/moving-beyond-animations-to-user-interactions-at-60-fps-in-react-native-b6b1fa0ba525">声明式物理库</a>以60 FPS的速度进行用户交互……我们知道声明式API可以是一种强大的武器。</p><p id="c25e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果没有桥，当我们滚动的时候也不会有JavaScript的渲染。这意味着我们将不得不完全依赖回收旧行。这是iOS <a class="ae kf" href="https://developer.apple.com/reference/uikit/uitableview?language=objc" rel="noopener ugc nofollow" target="_blank"> UITableView </a>等原生ListViews中的标准方法。幸运的是，联系人列表场景也非常适合回收——行几乎完全相同。我们可以利用这一点。</p><p id="74f7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">你们中的忠实追随者可能还记得，我已经在大约9个月前使用过这种方法(参见<a class="ae kf" rel="noopener" href="/@talkol/recycling-rows-for-high-performance-react-native-list-views-628fd0363861#.5c52s0n42">为高性能React本地列表视图回收行</a>)。之前尝试的问题是，我们仍然依赖React和JavaScript来协调行内容更新。</p><h2 id="4ef8" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">如何在不使用React的情况下更新行？</h2><p id="5131" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">简单。我们只更新行，不做反应。</p><p id="d547" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果你仔细查看React原生文档，你会发现这种能力不久前被记录在“<a class="ae kf" href="https://facebook.github.io/react-native/docs/direct-manipulation.html" rel="noopener ugc nofollow" target="_blank">直接操作</a>”下。这个API从来没有找到自己的位置，几乎已经从世界上消失了。但是通过挖掘旧的<a class="ae kf" href="https://github.com/facebook/react/blob/e452e3374135c116ef687a8bb3a5d277e3cde8fb/src/renderers/native/NativeMethodsMixin.js" rel="noopener ugc nofollow" target="_blank"> NativeMethodsMixin </a>代码可以让我们知道如何做到这一点。</p><h2 id="0327" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">这个计划</h2><p id="5c5e" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">首先，在我们的库中，我们将使用React来呈现一个行池，这个行池仅够覆盖一个屏幕折叠。这只会在初始化期间发生，因此不会影响滚动性能。此时使用React将为开发人员提供使用JSX定义行模板布局的灵活性。</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="lr ls l"/></div></figure><p id="76a0" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">接下来，我们将要求开发人员在JSX中定义行模板，并明确声明数据源中的数据将如何绑定到它。这就是声明性API发挥作用的地方:</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="lr ls l"/></div></figure><p id="d3f6" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果你仔细观察上面的例子，你会注意到我们使用<a class="ae kf" href="https://facebook.github.io/react-native/docs/textinput.html" rel="noopener ugc nofollow" target="_blank"> TextInput </a>组件来显示字符串，而不是使用<a class="ae kf" href="https://facebook.github.io/react-native/docs/text.html" rel="noopener ugc nofollow" target="_blank">文本</a>。这背后有一个原因，我们稍后会深入探讨(这将得到解决，不用担心)。</p><p id="6623" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们的声明式API使用<a class="ae kf" href="https://facebook.github.io/react/docs/refs-and-the-dom.html" rel="noopener ugc nofollow" target="_blank"> ref </a>来定义模板中的各种字段id如何绑定到特定组件的道具中。在这种情况下，我们将字符串模板字段绑定到TextInput的“text”属性。</p><p id="0316" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们要做的下一件事是将整个数据源传递给<em class="ke">本地领域</em>。这可能听起来很吓人，但实际上对性能的影响很小。即使有5000个联系人，数据源中的数据总量也很小。每个联系人都有一些附加条件。网桥具有非常高的吞吐量，因此在初始化期间一次发送它不会产生很大的影响:</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="lr ls l"/></div></figure><p id="33b0" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">接下来，我们将要求用户提供另一个声明。这一次展示了数据源中的字段如何映射到模板中的字段id。我们将把它作为另一个属性添加给BindingListView:</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="lr ls l"/></div></figure><p id="5177" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">正如您所记得的，当我们在上面定义数据源时，数据源中的每一行都有两个字段:“姓名首字母”和“姓名”。</p></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><p id="591a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">是时候转换到本地了。我们将在iOS上工作，并使用Objective-C。由于我们需要一个可回收的原生ListView，我们将简单地直接依赖<a class="ae kf" href="https://developer.apple.com/reference/uikit/uitableview?language=objc" rel="noopener ugc nofollow" target="_blank"> UITableView </a>。它是原生iOS SDK的一部分，提供开箱即用的原生视图回收。</p><p id="4633" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这是用于实现回收的API:</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="lr ls l"/></div></figure><p id="fad8" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">每当UITableView无法回收时(这只会发生在第一次屏幕折叠时)，我们需要为它提供一个新的视图。我们从预先创建的池中获取此视图。</p><p id="7194" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们如何填充池？这其实是很酷的一招。我们在初始化期间定义的JSX行池作为React子对象提供给我们的ListView。这将在native中为我们提供一个方便的挂钩点，我们可以将视图“偷”到池中，而不是实际将它们作为子视图添加:</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="lr ls l"/></div></figure><p id="3736" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">记得以前，当我们不能回收一个视图而必须分配一个视图时，我们已经获取了一个在池中等待的未使用的单元。</p><p id="85ce" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如今，现在..主要表演时间到了。我们如何将数据源数据从本机绑定到本机视图？</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="lr ls l"/></div></figure><p id="4bbf" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">秘诀是<em class="ke">synchronouslyUpdateViewOnUIThread</em>——一个用于直接操作的本地API，它是React Native <a class="ae kf" href="https://github.com/facebook/react-native/blob/264d60b97925aa72e51d4f4e0074503235eca12e/React/Modules/RCTUIManager.m" rel="noopener ugc nofollow" target="_blank"> UIManager </a>的一部分。</p><h2 id="c6ec" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">为什么之前我们用TextInput而不是Text？</h2><p id="1dea" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated"><em class="ke">的问题在于它只适用于道具。使用<a class="ae kf" href="https://facebook.github.io/react-native/docs/textinput.html" rel="noopener ugc nofollow" target="_blank"> TextInput </a>，组件中的文本作为道具而不是子组件提供。这使得它更容易使用。</em></p><p id="f2ad" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">对于<a class="ae kf" href="https://facebook.github.io/react-native/docs/text.html" rel="noopener ugc nofollow" target="_blank">文本</a>组件，原始文本是一个子节点，这使得一切都变得非常复杂。这种情况下的模板声明仍然很简单，与之前非常相似:</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="lr ls l"/></div></figure><p id="9cd5" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">请注意，我们在这里使用的专有名称现在是“儿童”。</p><p id="eb39" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在最大的问题是，我们如何支持从本地绑定到原始文本子节点？事实上，我花了很长时间试图解决这个问题。这是我迄今为止找到的最好的解决方案(<em class="ke"> dispatch_async </em>):</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="lr ls l"/></div></figure><p id="2033" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这并不完美，因为我们在进程中依赖于不同的本机线程(UIManager影子队列)。这仍然比过桥效率高得多，但是，如果我们最终只从主线程做所有的事情，我会很高兴。如果你想出了一个从主线程来做这件事的方法，请告诉我！</p><h2 id="2b57" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">包装东西</h2><p id="52e4" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">我的航班就要结束了..这是一个很好的消费方式:)</p><p id="ae63" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">GitHub上照常提供了一个完整的连接上述所有代码片段的工作示例:</p><div class="lt lu fm fo lv lw"><a href="https://github.com/wix/BindingListView" rel="noopener  ugc nofollow" target="_blank"><div class="lx ab ej"><div class="ly ab lz cl cj ma"><h2 class="bd hv fv z el mb eo ep mc er et ht dt translated">wix/BindingListView</h2><div class="md l"><h3 class="bd b fv z el mb eo ep mc er et ek translated">支持直接视图绑定的本地ListView实验实现</h3></div><div class="me l"><p class="bd b gc z el mb eo ep mc er et ek translated">github.com</p></div></div><div class="mf l"><div class="mg l mh mi mj mf mk ja lw"/></div></div></a></div><p id="081c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">repo包含一个包含5000个项目的示例联系人列表，您可以在手机上运行该列表。提示:在真实的设备上运行，而不是在模拟器上。我相信你会同意滚动性能是你见过的最好的，同时保持内存消耗恒定和最小。我相信这个例子是我们用React Native得到的最接近纯本机滚动性能的例子。</p><p id="ca11" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">就用户体验而言，它绝对够好了，甚至当你快速滚动或者按下状态栏上的键滚动到顶部时，它也没有任何空白。</p><p id="605d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">以下是回购中主要文件的分类:</p><ul class=""><li id="ff45" class="ml mm hu ji b jj jk jn jo jr mn jv mo jz mp kd mq mr ms mt dt translated">由使用我们的BindingListView库的开发人员编写</li><li id="97e8" class="ml mm hu ji b jj mu jn mv jr mw jv mx jz my kd mq mr ms mt dt translated"><a class="ae kf" href="https://github.com/wix/BindingListView/blob/90c787be46ceaf35c255d1a444a4548af94fcb06/src/BindingListView.js" rel="noopener ugc nofollow" target="_blank"> BindingListView.js </a> —库的JavaScript实现</li><li id="1df9" class="ml mm hu ji b jj mu jn mv jr mw jv mx jz my kd mq mr ms mt dt translated"><a class="ae kf" href="https://github.com/wix/BindingListView/blob/90c787be46ceaf35c255d1a444a4548af94fcb06/ios/BindingListView/RCTBindingListView.m" rel="noopener ugc nofollow" target="_blank">rctbindinglistview . m</a>—lib的原生iOS实现</li></ul></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><p id="5203" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我希望这种方法能推动更多这方面的研究。</p><p id="f99a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果你对ListView的性能感兴趣，并且正在寻找一个挑战——试着想想如何增加对可变高度单元格的支持。也许我们可以自己直接驱动yoga(原生布局引擎)在绑定过程中更新布局。</p><div class="ln lo lp lq fq ab cb"><figure class="mz iv na nb nc nd ne paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mz iv na nb nc nd ne paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mz iv na nb nc nd ne paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="nf ng nh"><p id="f922" class="jg jh ke ji b jj jk jl jm jn jo jp jq ni js jt ju nj jw jx jy nk ka kb kc kd hn dt translated"><a class="ae kf" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kf" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kf" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae kf" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jg jh ke ji b jj jk jl jm jn jo jp jq ni js jt ju nj jw jx jy nk ka kb kc kd hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kf" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kf" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ln lo lp lq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nl"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="nm ls l"/></div></figure></div></div>    
</body>
</html>