<html>
<head>
<title>Under the sink: Removing remote git tags</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在接收器下:移除远程git标签</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/under-the-sink-removing-remote-git-tags-3d5644d67ea0?source=collection_archive---------8-----------------------#2017-10-07">https://medium.com/hackernoon/under-the-sink-removing-remote-git-tags-3d5644d67ea0?source=collection_archive---------8-----------------------#2017-10-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="6595" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">TLDR；<code class="eh jp jq jr js b">git push [remote-name] :refs/tags/[tag-name]</code></p><p id="f17c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">干得好——继续前进。但是等等，如果你和我一样，你可能会想:“等等，这到底是怎么回事？”所以继续想象水管工屁股裂开的样子吧，因为我们要在饭桶下偷看一眼。</p></div><div class="ab cl jt ju hc jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hn ho hp hq hr"><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff ka"><img src="../Images/f4e5cfe83b4c0c2e6ef50cbec83166b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*0o9GZUzXiNnI4poEvxvy8g.png"/></div><figcaption class="ki kj fg fe ff kk kl bd b be z ek"><a class="ae km" href="https://xkcd.com/1597/" rel="noopener ugc nofollow" target="_blank"><em class="kn">xkcd</em></a></figcaption></figure><p id="9429" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也许不是流行的观点，但是我最喜欢git的一部分是它的命令。我认为它们非常棒，这是我使用终端的主要原因之一。然而，我并没有偏离常见的git命令太远，对我来说，这些命令如下:</p><p id="54c8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jp jq jr js b">git [push]|[pull]|[checkout]|[rebase]|[diff]|[log]</code></p><p id="f3d8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">都(相对)容易理解和使用。这些被称为<a class="ae km" href="https://git-scm.com/book/en/v2/Git-Internals-Plumbing-and-Porcelain" rel="noopener ugc nofollow" target="_blank">瓷器指令</a>——它们隐藏了管道。管道是隐藏起来的所有部件，它们使git工作并在幕后做我们认为理所当然的事情——有点像你家里的管道。</p><p id="70d0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以，当我需要移除一个已经放在遥控器上的标签时，这个任务我过去已经做过好几次了，我想说我只是记得怎么做或者自己想出来了。我没有。我谷歌了一下，事实上，我甚至记得之前谷歌过几次。只是我没有理解那个命令，可能是因为我从来没有花时间去弄清楚<em class="ko">为什么</em>它会工作。所以，让我们开始吧。</p><blockquote class="kp"><p id="0a8f" class="kq kr hu bd ks kt ku kv kw kx ky jo ek translated"><code class="eh jp jq jr js b">git push [remote-name] :refs/tags/[tag-name]</code></p></blockquote><p id="3198" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">看起来很复杂；让我们分解一下(LC；lbtd)。</p><ul class=""><li id="34f1" class="le lf hu it b iu iv iy iz jc lg jg lh jk li jo lj lk ll lm dt translated">饭桶</li><li id="1d0a" class="le lf hu it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm dt translated">推</li><li id="71f2" class="le lf hu it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm dt translated">[远程名称]例如<em class="ko">来源</em></li></ul><p id="dcfe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">行..到目前为止一切顺利…</p><ul class=""><li id="a4ff" class="le lf hu it b iu iv iy iz jc lg jg lh jk li jo lj lk ll lm dt translated">:refs/tags/[tag-name]例如:refs/tags/1.10.1</li></ul><p id="06a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">什么—<em class="ko"/>—f % * # K？好的，我想我已经确定了我需要关注的地方。</p><blockquote class="kp"><p id="6ed0" class="kq kr hu bd ks kt ku kv kw kx ky jo ek translated"><code class="eh jp jq jr js b">:refs/tags/[tag-name]</code></p></blockquote><p id="6c68" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">让我们进一步分析一下。</p><ul class=""><li id="693e" class="le lf hu it b iu iv iy iz jc lg jg lh jk li jo lj lk ll lm dt">:</li><li id="b1ba" class="le lf hu it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm dt translated">参考/标签/[标签名称]</li></ul><p id="6400" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">稍微熟悉一下<code class="eh jp jq jr js b">.git</code>文件夹的内部文件结构，每个回购中都有这个文件夹，我可以看出第二部分看起来像是<code class="eh jp jq jr js b">.git/refs</code>文件夹的路径。我还知道<code class="eh jp jq jr js b">refs</code>文件夹是存储所有<em class="ko"> git引用</em>的地方。在查看了<code class="eh jp jq jr js b">push</code> ( <code class="eh jp jq jr js b">git help push</code>)的手册页之后，重点关注了<code class="eh jp jq jr js b">push</code>接受的选项，我发现冒号是<em class="ko"> refspec </em>格式的一部分。意味着整个零件<code class="eh jp jq jr js b">:refs/tag/[tag-name]</code>是一个<em class="ko"> refspec </em>。在我们讨论<em class="ko"> refspecs </em>之前，让我们回顾一下什么是<em class="ko"> git引用</em>。</p><h2 id="8787" class="ls lt hu bd lu lv lw lx ly lz ma mb mc jc md me mf jg mg mh mi jk mj mk ml mm dt translated">Git引用</h2><p id="3111" class="pw-post-body-paragraph ir is hu it b iu mn iw ix iy mo ja jb jc mp je jf jg mq ji jj jk mr jm jn jo hn dt translated">如前所述，git引用存储在<code class="eh jp jq jr js b">/.git/refs</code>文件夹中。这里您会发现几个子文件夹，git用它们来对引用进行分组。但是它们是什么呢？</p><pre class="kb kc kd ke fq ms js mt mu aw mv dt"><span id="6aa8" class="ls lt hu js b fv mw mx l my mz">$_: ls ./.git/refs/<br/>heads  remotes  tags</span></pre><p id="3541" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">git中的引用，或文档中通常提到的“refs ”,指的是原始的SHA-1值。分支名称、<strong class="it hv">标签</strong>，它们都是完整的40字符SHA-1校验和(+头)散列的友好别名。我不会详细介绍什么是内容可寻址文件系统或者它是如何工作的，但是要知道，git就是其中之一，这些散列就是git如何能够在其中引用我们的数据。可以把它想象成一个键值存储，ref就是键。</p><p id="467c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Git在我们使用它的时候会一直为我们创建和更新这些别名。想象一下，当您想要签出或提取一个分支时，必须键入整个40个字符的散列？如果你<code class="eh jp jq jr js b">cat</code>去掉一个ref，你会看到这个:</p><pre class="kb kc kd ke fq ms js mt mu aw mv dt"><span id="4ae0" class="ls lt hu js b fv mw mx l my mz">$_: cat ./.git/refs/heads/master <br/>8d519a1066b4d05e010e0a6435401f0ea6fdca71</span></pre><p id="e03f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些文件夹也存在于远程服务器上。事实上，如果你想备份你的git repo，比如真正的lo-fi，复制<code class="eh jp jq jr js b">.git</code>文件夹。</p><h2 id="ac30" class="ls lt hu bd lu lv lw lx ly lz ma mb mc jc md me mf jg mg mh mi jk mj mk ml mm dt translated">Refspec</h2><p id="ec88" class="pw-post-body-paragraph ir is hu it b iu mn iw ix iy mo ja jb jc mp je jf jg mq ji jj jk mr jm jn jo hn dt translated">一个<em class="ko"> refspec </em>是指定源和目的地的格式，等等，<em class="ko">引用！</em> Git自动为您添加的每个遥控器设置refspec。如果你想知道你的refspecs设置为什么，看看你的repo中的这个文件<code class="eh jp jq jr js b">./.git/config</code>。</p><pre class="kb kc kd ke fq ms js mt mu aw mv dt"><span id="b443" class="ls lt hu js b fv mw mx l my mz">$_: cat ./.git/config<br/>[core]<br/>        repositoryformatversion = 0<br/>        filemode = true<br/>        bare = false<br/>        logallrefupdates = true<br/>[remote "origin"]<br/>        url = <a class="ae km" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:vprasanth/dotfiles.git<br/>        fetch = +refs/heads/*:refs/remotes/origin/*<br/>[branch "master"]<br/>        remote = origin<br/>        merge = refs/heads/master</span></pre><blockquote class="kp"><p id="b001" class="kq kr hu bd ks kt na nb nc nd ne jo ek translated">格式:+ <code class="eh jp jq jr js b">&lt;src&gt;:&lt;dst&gt;</code></p></blockquote><p id="c948" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">重要的是要明白，根据您是推还是拉，源和目的地会在本地和远程之间切换。推的时候，src是<em class="ko">本地</em>，目的地是<em class="ko">远程</em>，拉的时候反之。</p><p id="e49a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一个需要知道的重要事情是，git将引用扩展到它的完全限定名，它通过使用在配置中为远程设置的目的地来做到这一点(参见上面代码片段中branch remote如何设置为“origin”)。事实上git总是进行这种扩展。有没有尝试过推送遥控器上不存在的本地分支？:)</p><pre class="kb kc kd ke fq ms js mt mu aw mv dt"><span id="a9a5" class="ls lt hu js b fv mw mx l my mz">$_: git log -n 1 --oneline origin/master <br/>8d519a1 Remove vundle configs and set tab to 2<br/>$_: git log -n 1 --oneline remotes/origin/master<br/>8d519a1 Remove vundle configs and set tab to 2<br/>$_: git log -n 1 --oneline refs/remotes/origin/master<br/>8d519a1 Remove vundle configs and set tab to 2</span></pre><p id="3c52" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">是啊。</p><p id="9cea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">哦，关于refspecs还有一件事，按下空的<code class="eh jp jq jr js b">&lt;src&gt;</code>告诉<code class="eh jp jq jr js b">git</code>将遥控器上的<code class="eh jp jq jr js b">&lt;dst&gt;</code>设置为空，这样<strong class="it hv"> <em class="ko">会删除</em> </strong>它。</p><h2 id="61c0" class="ls lt hu bd lu lv lw lx ly lz ma mb mc jc md me mf jg mg mh mi jk mj mk ml mm dt translated">所以……<code class="eh jp jq jr js b">git push origin :refs/tags/1.10.1</code></h2><p id="0181" class="pw-post-body-paragraph ir is hu it b iu mn iw ix iy mo ja jb jc mp je jf jg mq ji jj jk mr jm jn jo hn dt translated">所有的魔力都在那个<code class="eh jp jq jr js b">refspec</code>里。因为推送通常会为您扩展refspec，它会尝试匹配任何适合您当前<code class="eh jp jq jr js b">HEAD</code>设置的内容，这里我们手动将其设置为:<strong class="it hv"> <em class="ko">请不要将任何内容推送至原点的标签引用1.10.1。</em> </strong>我们现在知道删除遥控器上的标签。</p><p id="751e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">是的，我肯定是想当然的不去看<em class="ko"> refspecs </em>。我很高兴我做到了。有趣的是，理解这里发生的事情也解释了一些其他的错误，以前当我试图推或拉东西时，这些错误是没有意义的。下次我点击这些，也许我会写点什么。希望这也能帮到你。</p><h2 id="6c7a" class="ls lt hu bd lu lv lw lx ly lz ma mb mc jc md me mf jg mg mh mi jk mj mk ml mm dt translated">进一步阅读</h2><ul class=""><li id="3387" class="le lf hu it b iu mn iy mo jc nf jg ng jk nh jo lj lk ll lm dt translated"><a class="ae km" href="https://git-scm.com/book/en/v2/Git-Internals-Plumbing-and-Porcelain" rel="noopener ugc nofollow" target="_blank">Git-SCM上的Git内部章节</a>。涵盖我提到的一切，然后一些！总体资源丰富。</li></ul><h2 id="36f2" class="ls lt hu bd lu lv lw lx ly lz ma mb mc jc md me mf jg mg mh mi jk mj mk ml mm dt translated">注意</h2><p id="d5a6" class="pw-post-body-paragraph ir is hu it b iu mn iw ix iy mo ja jb jc mp je jf jg mq ji jj jk mr jm jn jo hn dt translated">我没有介绍<em class="ko"> refspec </em>格式中的<code class="eh jp jq jr js b">+</code>是什么意思。它首先是可选的，并告诉git更新引用，即使它不是一个<em class="ko">快进</em>。我不想深究这意味着什么，也许改天再发一篇文章。</p></div></div>    
</body>
</html>