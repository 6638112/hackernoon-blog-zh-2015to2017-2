<html>
<head>
<title>More than you want to know about headless Chrome</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比你想知道的更多关于无头浏览器</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/more-than-you-want-to-know-about-headless-chrome-31f6b3b06d82?source=collection_archive---------6-----------------------#2017-09-25">https://medium.com/hackernoon/more-than-you-want-to-know-about-headless-chrome-31f6b3b06d82?source=collection_archive---------6-----------------------#2017-09-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/8569ce57849d6c74b35096aa0d5d5b75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CfdxLFqER3D-buDMmBh5sw.jpeg"/></div></div></figure><blockquote class="jc"><p id="d2f6" class="jd je hu bd jf jg jh ji jj jk jl jm ek translated">你们的科学家太专注于他们能不能做到，他们没有停下来想一想他们是否应该。</p></blockquote><p id="d544" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj jm hn dt translated">无头的Chrome是大张旗鼓地宣布的。它的泄露导致了<a class="ae kk" href="https://groups.google.com/forum/#!topic/phantomjs/9aI5d-LDuNE" rel="noopener ugc nofollow" target="_blank">维护者设置关闭</a>、<a class="ae kk" href="https://github.com/graphcool/chromeless" rel="noopener ugc nofollow" target="_blank">新包出来</a>，甚至<a class="ae kk" href="https://browserless.io" rel="noopener ugc nofollow" target="_blank">新创公司推出</a>(完全披露:最后一个环节是我自己主动的)。如果你经常访问黑客新闻，那么这些都不会让你感到震惊。</p><p id="30f8" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated">虽然并不是所有的事情都像这些重大变化一样完美。PhantomJS是一款无头浏览器，由于上述原因最近被弃用，它确实有自己的问题。它的API背后也有很多的成熟和历史，而且它包括了自己的库，可以开箱即用，这使得它很容易上手。相比之下，目前有两个主要的无头Chrome库，标志着一个已经破裂的生态系统(<a class="ae kk" href="https://github.com/graphcool/chromeless/issues/235" rel="noopener ugc nofollow" target="_blank">尽管希望不会持续太久</a>)。只有一款捆绑了Chrome的一个版本，保证能与它一起工作，尽管代价是灵活性。尽管如此，所有主要的开源无头库都要求迁移到无头Chrome(见<a class="ae kk" href="https://github.com/segmentio/nightmare/issues/1092" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae kk" href="https://github.com/ariya/phantomjs/issues/14954" rel="noopener ugc nofollow" target="_blank">这里</a>)。</p><p id="1e89" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated">通常我倾向于从远处观看这样的事件，但命运让我被GitHub和Google的广告吞没了。</p><h1 id="d780" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">我的旅程</h1><p id="8170" class="pw-post-body-paragraph jn jo hu jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj jm hn dt translated">在这一点上，你可能想知道我到底是谁。我不为谷歌工作，也不为graph.cool工作，也不为任何与无头浏览器游戏有重大利害关系的人工作。我确实有一些其他人，包括那些列出来的人可能没有的东西:在用户方面感受到的过多的经验和挫折。我个人已经与PhantomJS缺少的<a class="ae kk" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a> API，必须通过它执行的古怪测试，以及调试我的方法进行了多次斗争。我已经在战壕里待了将近五年，而且还在继续。</p><p id="8798" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated">那么，我是如何在这一片喧嚣中结束的呢？嗯，大约4个月前，我在写一个兼职项目，非常需要某种网络驱动程序。和其他人一样，我也在做一个网页抓取器，上面有价格、标题和产品描述，用户可以通过URL输入提交。手持<a class="ae kk" href="https://github.com/cheeriojs/cheerio" rel="noopener ugc nofollow" target="_blank"> cheerio </a>包；我要“扰乱”礼品登记处的业务。在我遇到Target.com之前，一切都进行得很顺利。你可能不知道，Target运行的是众所周知的单页面应用程序，这意味着他们的HTML中几乎没有任何内容，而是依靠JavaScript来执行所有的网站操作。这意味着没有任何一个啦啦队长能把我从即将到来的灾难中拯救出来。</p><figure class="lv lw lx ly fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lu"><img src="../Images/23ed2b0e1fad09e116f160604f46e2bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r3ZNxoo-z6UlSV2CYgLjSQ.png"/></div></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Target with JavaScript disabled :(</figcaption></figure><p id="fe06" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated">好的。太好了。如果我想在我的站点中处理Target，我也这样做了，那么我必须执行一个JavaScript运行时来完全“加载”他们的页面。被PhantomJS和它的迟钝烧了无数次，我选择用Chrome代替。在这个时间点上，headless Chrome是最近才发布的，当然也没有像puppeteer或chromeless这样出色的库。那么工程师应该做什么呢？当然，这是为了改变你的应用程序，解决问题！最终产生了一个叫做<a class="ae kk" href="https://github.com/joelgriffith/navalia" rel="noopener ugc nofollow" target="_blank">纳瓦拉</a>的包。我在这方面取得了一些成功，甚至有几天在Github的TypeScript趋势排行榜上名列第三。</p><p id="9ddb" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated"><strong class="jp hv">我成名的15分钟</strong></p><figure class="lv lw lx ly fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff md"><img src="../Images/b5950502c6ba259356c83c6d9124c0d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QsRlpnQL_PRjLR7nJlKD5g.png"/></div></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Look ma! #3!</figcaption></figure><p id="1dc1" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated">这引起了graph.cool的优秀员工的注意，他们问我是否愿意帮助他们做一个名为chromeless的项目，因为我获得了一些关注。在经历了一些内在的道德困境后，我决定加入graph.cool的chromeless项目，开始贬低Navalia的过程(没关系，它在JavaScript年代活得很久)。我强烈地感觉到我们应该团结起来做一个了不起的项目，而不是三四个平庸的项目。当然，正如JavaScript所希望的那样，Google随后推出了他们的木偶项目。有了与chromeless和navalia几乎相同的API，我们现在在无头库军备竞赛中有了一个新的竞争者。</p><p id="ca04" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated">这就把我们带到了现在的位置:两个库和一些在云基础设施中执行它们的方法。让我们仔细看看这两个库和它们的区别因素。</p><h1 id="6496" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">无铬的</h1><p id="5f56" class="pw-post-body-paragraph jn jo hu jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj jm hn dt translated">有些人可能不太熟悉Chromeless，它不仅是一个用于驱动无头Chrome的丰富API，还提供了一个如何在生产/CI环境中执行无头工作的处方。他们的观点很吸引人:不用在你自己的基础设施中运行和管理二进制文件，只要在AWS lambda中就可以了。</p><figure class="lv lw lx ly fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff me"><img src="../Images/df3611cc16209ff3ca97efa33ad76910.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zzLoOfo_dKLxdH0n4cQJDQ.png"/></div></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Diagram for how to execute chromeless locally and in AWS</figcaption></figure><p id="a4b6" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated">到目前为止，对于如何在托管环境中设置无头浏览器，还没有很好的解决方案。Chromeless能够做到这一切，部分是因为这个<a class="ae kk" href="https://github.com/adieuadieu/serverless-chrome" rel="noopener ugc nofollow" target="_blank">包</a>的努力(后面会有更多)。</p><p id="3f2e" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated">为了方便与Chrome通话，chromeless使用了<a class="ae kk" href="https://github.com/cyrus-and/chrome-remote-interface" rel="noopener ugc nofollow" target="_blank"> chrome远程接口</a>。这个项目抽象出了制作自己的web套接字客户端、建立连接和实现所有必要协议的痛苦，以便成功地试验chrome。需要强调的是，web socket是进入Chrome的唯一接口，在某种程度上，你的堆栈<em class="lt">将</em>必须打开一个web socket连接。</p><p id="f3ab" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated">使用chrome-remote-interface的一个大缺点是，it和chrome仍然会频繁地发布突破性的改变，因此你的Chrome二进制文件必须与你正在使用的协议完全一致。这是因为远程协议不支持混合版本，正如在他们的常见问题解答<a class="ae kk" href="https://chromedevtools.github.io/devtools-protocol/" rel="noopener ugc nofollow" target="_blank">这里</a>中读到的。</p><p id="22ed" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated">在我看来，chromeless确实有一个非常优雅的API。</p><h1 id="defe" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">我💖那些锁链</h1><pre class="lv lw lx ly fq mf mg mh mi aw mj dt"><span id="b92a" class="mk kr hu mg b fv ml mm l mn mo">const screenshot = await chromeless<br/>    .goto('https://www.google.com')<br/>    .type('chromeless', 'input[name="q"]')<br/>    .press(13)<br/>    .wait('#resultStats')<br/>    .screenshot()</span></pre><p id="6bff" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated">这些花哨的链接操作是通过Promise chaining带给你的，<em class="lt">的awa等待</em>直到调用一个<code class="eh mp mq mr mg b">then</code> -able(这是<code class="eh mp mq mr mg b">async/await</code>为你做的)，然后执行操作集合。这个API使它与lambdas很好地结合在一起，因为这个操作集合实际上被发送到lambda调用并立即执行，而不是单独执行每个操作(这使得工作流更加冗长)。如何实现这种批处理操作的主题相当吸引人，可以在这里找到源代码<a class="ae kk" href="https://github.com/graphcool/chromeless/blob/master/src/queue.ts" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="5c80" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated">总结为所有你撇油的要点:</p><p id="b324" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated"><strong class="jp hv">优点</strong></p><ul class=""><li id="e0fb" class="ms mt hu jp b jq kl ju km jy mu kc mv kg mw jm mx my mz na dt translated">使用链式操作的优秀API。</li><li id="7bd0" class="ms mt hu jp b jq nb ju nc jy nd kc ne kg nf jm mx my mz na dt translated">将您的测试/应用过渡到云平台的规定方式。</li><li id="2c2e" class="ms mt hu jp b jq nb ju nc jy nd kc ne kg nf jm mx my mz na dt translated">由于依赖关系，在Chrome版本上有些灵活。</li></ul><p id="7ba5" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated"><strong class="jp hv">缺点</strong></p><ul class=""><li id="0950" class="ms mt hu jp b jq kl ju km jy mu kc mv kg mw jm mx my mz na dt translated">由于chrome远程接口的使用，API可能无法与Chrome的最新版本保持一致。</li><li id="3aac" class="ms mt hu jp b jq nb ju nc jy nd kc ne kg nf jm mx my mz na dt translated">没有谷歌的支持。</li></ul><h1 id="70d6" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">操纵木偶的人</h1><p id="fd1c" class="pw-post-body-paragraph jn jo hu jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj jm hn dt translated">正如我之前提到的，谷歌在chromeless之后不久发布了他们的库<a class="ae kk" href="https://github.com/GoogleChrome/puppeteer" rel="noopener ugc nofollow" target="_blank">木偶师</a>。虽然这些API非常相似，但实际上在实现上有很大的不同，这可以根据您的需求改变您选择的库。</p><p id="8622" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated"><strong class="jp hv">木偶师的API </strong></p><pre class="lv lw lx ly fq mf mg mh mi aw mj dt"><span id="3451" class="mk kr hu mg b fv ml mm l mn mo">const puppeteer = require('puppeteer');<br/><br/>(async () =&gt; {<br/>  const browser = await puppeteer.launch();<br/>  const page = await browser.newPage();<br/>  await page.goto('https://example.com');<br/>  await page.screenshot({path: 'example.png'});<br/><br/>  await browser.close();<br/>})();</span></pre><p id="2a94" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated">由于缺少链式操作，这使得puppeteer更难在无服务器类型的环境中运行。当然，他们自己的<a class="ae kk" href="https://try-puppeteer.appspot.com/" rel="noopener ugc nofollow" target="_blank">游戏平台</a>通过将脚本直接发送到服务器执行来绕过这个问题。</p><p id="195b" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated"><strong class="jp hv">木偶人的游乐场</strong></p><figure class="lv lw lx ly fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ng"><img src="../Images/6cd90f7e48a71ffc24681f054e5a79e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d04jdK9T3YgVEiF63dsaBQ.png"/></div></div></figure><p id="c5a5" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated">由于这种API设计，它不太适合AWS的lambda方法，因为浏览器实例在被收集之前需要“逗留”一段时间。你可以从谷歌的做法中获得灵感，上传你的脚本让AWS执行，但是你仍然需要克服<a class="ae kk" href="https://github.com/graphcool/chromeless/issues/114" rel="noopener ugc nofollow" target="_blank">个消息限制。</a></p><p id="4d4c" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated">木偶戏采用了不同于chromeless的方法，因为它不使用chrome远程接口包。相反，它实现了协议本身:启动web socket客户端并封送消息及其响应。这看起来像是重新发明轮子，因为chrome远程界面会处理所有这些事情。然而，与chromeless相反，puppeteer自带Chrome二进制文件，保证能与你安装的库一起工作。如果您需要一个保证API工作的锁定包，这是一个可靠的选择。不过，这里的成本可能不小，因为您依赖于包的维护者保持他们的协议和API是最新的。由于这是由谷歌支持的，这种情况很有可能会一直存在，尽管谷歌因任何原因放弃项目而闻名。</p><p id="63fb" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated">对于我们的撇油朋友，这是木偶师的概要:</p><p id="3a3b" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated"><strong class="jp hv">优点</strong></p><ul class=""><li id="d7bd" class="ms mt hu jp b jq kl ju km jy mu kc mv kg mw jm mx my mz na dt translated">锁定的API和Chrome二进制。</li><li id="cdeb" class="ms mt hu jp b jq nb ju nc jy nd kc ne kg nf jm mx my mz na dt translated">由Chrome的发行商谷歌提供支持。</li><li id="78d4" class="ms mt hu jp b jq nb ju nc jy nd kc ne kg nf jm mx my mz na dt translated"><a class="ae kk" href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#" rel="noopener ugc nofollow" target="_blank">全功能API </a>覆盖大部分用例。</li></ul><p id="1c56" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated"><strong class="jp hv">缺点</strong></p><ul class=""><li id="2bc4" class="ms mt hu jp b jq kl ju km jy mu kc mv kg mw jm mx my mz na dt translated">潜在的协议滞后，因为他们手动维护它，而不是依赖它。</li><li id="4a67" class="ms mt hu jp b jq nb ju nc jy nd kc ne kg nf jm mx my mz na dt translated">更“闲聊”的方法，因为它们的API不是可链接的。</li><li id="02e5" class="ms mt hu jp b jq nb ju nc jy nd kc ne kg nf jm mx my mz na dt translated">在生产环境中设置it需要克服一些障碍。</li></ul><p id="afbc" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated">我希望这已经给了你一些关于库决策的指导，因为当把我们的代码发布到生产或持续集成环境中时，事情会变得更加复杂😢</p><h1 id="cef4" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">AWS lambda上的铬</h1><p id="8c8e" class="pw-post-body-paragraph jn jo hu jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj jm hn dt translated">在我们开始谈论在AWS lambda上获得无头Chrome之前，让我们先来回顾一下它们的限制，这里是<a class="ae kk" href="http://docs.aws.amazon.com/lambda/latest/dg/limits.html" rel="noopener ugc nofollow" target="_blank"/>(我已经将它们过滤为适用于Chrome的约束):</p><ul class=""><li id="f244" class="ms mt hu jp b jq kl ju km jy mu kc mv kg mw jm mx my mz na dt translated">内存分配范围从128mb到1536mb。</li><li id="4a9e" class="ms mt hu jp b jq nb ju nc jy nd kc ne kg nf jm mx my mz na dt translated">512 MB的临时磁盘容量(“/tmp”空间)。</li><li id="0d4c" class="ms mt hu jp b jq nb ju nc jy nd kc ne kg nf jm mx my mz na dt translated">每个请求的最长执行时间为5分钟。</li><li id="c684" class="ms mt hu jp b jq nb ju nc jy nd kc ne kg nf jm mx my mz na dt translated"><a class="ae kk" href="http://docs.aws.amazon.com/lambda/latest/dg/API_Invoke.html" rel="noopener ugc nofollow" target="_blank">调用</a>请求体有效负载大小(请求响应/同步调用)为6mb</li><li id="e53a" class="ms mt hu jp b jq nb ju nc jy nd kc ne kg nf jm mx my mz na dt translated"><a class="ae kk" href="http://docs.aws.amazon.com/lambda/latest/dg/API_Invoke.html" rel="noopener ugc nofollow" target="_blank">调用</a>请求体有效负载大小(事件/异步调用)为128kb。</li><li id="58c4" class="ms mt hu jp b jq nb ju nc jy nd kc ne kg nf jm mx my mz na dt translated">并发执行(参见<a class="ae kk" href="http://docs.aws.amazon.com/lambda/latest/dg/concurrent-executions.html" rel="noopener ugc nofollow" target="_blank">λ函数并发执行</a>):1000</li><li id="4f35" class="ms mt hu jp b jq nb ju nc jy nd kc ne kg nf jm mx my mz na dt translated">Lambda函数部署包大小(压缩。zip/。jar文件):50mb</li><li id="36e0" class="ms mt hu jp b jq nb ju nc jy nd kc ne kg nf jm mx my mz na dt translated">可以压缩到部署包中的代码/依赖项的大小(未压缩。zip/。jar大小):250mb</li></ul><p id="ca0f" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated">要让Chrome在这些类型的约束下运行，你首先要做以下事情，或者依靠其他人来做:</p><ul class=""><li id="5e25" class="ms mt hu jp b jq kl ju km jy mu kc mv kg mw jm mx my mz na dt translated">编译<a class="ae kk" href="https://cs.chromium.org/chromium/src/headless/app/" rel="noopener ugc nofollow" target="_blank"> headless Chromium shell </a>的非调试版本，当gzipped压缩时，它产生的二进制文件不到44 MB。</li><li id="60c0" class="ms mt hu jp b jq nb ju nc jy nd kc ne kg nf jm mx my mz na dt translated">在Chrome代码库中从<code class="eh mp mq mr mg b">/dev/shm </code>到<code class="eh mp mq mr mg b">/tmp</code>重写<a class="ae kk" href="https://en.wikipedia.org/wiki/Tmpfs" rel="noopener ugc nofollow" target="_blank"> tmpfs </a>😨</li></ul><p id="5ac7" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated">还有几个步骤我不会浪费时间在这里详述，特别是因为它们在以下地方有很好的记录:</p><ul class=""><li id="f5e0" class="ms mt hu jp b jq kl ju km jy mu kc mv kg mw jm mx my mz na dt translated"><a class="ae kk" href="https://github.com/graphcool/chromeless/tree/master/serverless" rel="noopener ugc nofollow" target="_blank">为AWS设置无铬合金</a></li><li id="c741" class="ms mt hu jp b jq nb ju nc jy nd kc ne kg nf jm mx my mz na dt translated"><a class="ae kk" rel="noopener" href="/@marco.luethy/running-headless-chrome-on-aws-lambda-fa82ad33a9eb">为AWS做Chrome设置的人为chromeless做了设置</a>。</li></ul><h2 id="d243" class="mk kr hu bd ks nh ni nj kw nk nl nm la jy nn no le kc np nq li kg nr ns lm nt dt translated">AWS lambda优势</h2><p id="1d64" class="pw-post-body-paragraph jn jo hu jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj jm hn dt translated">现在，这可能看起来令人难以置信的复杂和痛苦，在某种程度上确实如此。然而，<a class="ae kk" href="https://aws.amazon.com/lambda/pricing/" rel="noopener ugc nofollow" target="_blank">lambda在自由层</a>中非常便宜，并且可以很好地水平扩展。以这样的成本和规模，你可以在几秒钟内执行数量惊人的功能测试。</p><blockquote class="nu nv nw"><p id="d1da" class="jn jo lt jp b jq kl js jt ju km jw jx nx kn ka kb ny ko ke kf nz kp ki kj jm hn dt translated">在<!-- --> <a class="ae kk" href="https://www.graph.cool/" rel="noopener ugc nofollow" target="_blank"> Graphcool </a>的案例中，这将测试持续时间从大约20分钟减少到了几秒钟。</p></blockquote><p id="24ff" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated">如果规模和规划是你不确定的事情，那么AWS方法是一个很好的方法。您可以轻松地运行1次调用，最多1000次，而不会有太多麻烦或变化。</p><h2 id="1c96" class="mk kr hu bd ks nh ni nj kw nk nl nm la jy nn no le kc np nq li kg nr ns lm nt dt translated">缺点</h2><p id="5a1c" class="pw-post-body-paragraph jn jo hu jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj jm hn dt translated">当然，对于不透明的技术，事情总是有两面性。第一个主要的痛点是需要自己维护Chrome二进制文件，因为你必须把它拼凑起来才能在lambdas中运行。如果越来越多的人开始使用lambdas做非标准的事情，比如无头的Chrome，这种情况可能会改变。由于lambdas的存储和时间也非常有限，所以像字体和长时间运行的工作流这样的问题是不可避免的。即使考虑到这些缺点，lambdas仍然可能相当古怪，正如这里的<a class="ae kk" href="https://github.com/graphcool/chromeless/issues/180" rel="noopener ugc nofollow" target="_blank"/>、这里的<a class="ae kk" href="https://github.com/adieuadieu/serverless-chrome/issues/41" rel="noopener ugc nofollow" target="_blank"/>和这里的<a class="ae kk" href="https://github.com/graphcool/chromeless/issues/278" rel="noopener ugc nofollow" target="_blank"/>所示。</p><p id="6e94" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated">别忘了我们的撇油器，这是你们渴望的子弹:</p><p id="c601" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated"><strong class="jp hv">优点</strong>:</p><ul class=""><li id="dd49" class="ms mt hu jp b jq kl ju km jy mu kc mv kg mw jm mx my mz na dt translated">代码的大规模扩展和并行化。</li><li id="beb8" class="ms mt hu jp b jq nb ju nc jy nd kc ne kg nf jm mx my mz na dt translated">在AWS和对应的免费层上运行的成本较低。</li><li id="91d5" class="ms mt hu jp b jq nb ju nc jy nd kc ne kg nf jm mx my mz na dt translated">存在专门关注这一点的包。</li></ul><p id="f33f" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated"><strong class="jp hv">缺点:</strong></p><ul class=""><li id="1145" class="ms mt hu jp b jq kl ju km jy mu kc mv kg mw jm mx my mz na dt translated"><a class="ae kk" href="https://github.com/adieuadieu/serverless-chrome/issues/68" rel="noopener ugc nofollow" target="_blank">复杂而脆弱的设置</a>。<a class="ae kk" href="https://chromium.googlesource.com/chromium/src/+/master/docs/linux_build_instructions.md" rel="noopener ugc nofollow" target="_blank">可能要编译Chrome </a>。</li><li id="59a3" class="ms mt hu jp b jq nb ju nc jy nd kc ne kg nf jm mx my mz na dt translated"><a class="ae kk" href="https://github.com/graphcool/chromeless/issues/43" rel="noopener ugc nofollow" target="_blank">缺少字体</a>、<a class="ae kk" href="https://github.com/graphcool/chromeless/issues/280" rel="noopener ugc nofollow" target="_blank">表情符号</a>和低<a class="ae kk" href="https://github.com/graphcool/chromeless/issues/180" rel="noopener ugc nofollow" target="_blank">调试性</a>。</li><li id="1649" class="ms mt hu jp b jq nb ju nc jy nd kc ne kg nf jm mx my mz na dt translated"><a class="ae kk" href="https://github.com/adieuadieu/serverless-chrome/issues/68" rel="noopener ugc nofollow" target="_blank">长时间运行或复杂设置的下限</a>。</li><li id="a0a5" class="ms mt hu jp b jq nb ju nc jy nd kc ne kg nf jm mx my mz na dt translated">轻松挂出<a class="ae kk" href="https://github.com/graphcool/chromeless/issues/227" rel="noopener ugc nofollow" target="_blank">高额账单</a>。</li><li id="46a5" class="ms mt hu jp b jq nb ju nc jy nd kc ne kg nf jm mx my mz na dt translated"><a class="ae kk" href="https://github.com/adieuadieu/serverless-chrome/issues/41#issuecomment-317989508" rel="noopener ugc nofollow" target="_blank"> 1到2秒的启动开销</a>。</li></ul><h1 id="2592" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">Docker上的铬合金</h1><p id="129b" class="pw-post-body-paragraph jn jo hu jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj jm hn dt translated">如果AWS由于其缺点而不能满足你的需求，那么在docker容器上运行Chrome可能正合你的胃口。这相对简单，因为有大量的docker文件可供使用。甚至<a class="ae kk" href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/troubleshooting.md#running-puppeteer-in-docker" rel="noopener ugc nofollow" target="_blank">木偶师</a>也有文件让你去做。这通常会让你摆脱lambda的所有限制，因为你可以随意运行脚本，想用多少就用多少。</p><p id="5455" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated"><strong class="jp hv">Chrome的dockerfile安装示例</strong></p><div class="oa ob fm fo oc od"><a href="https://github.com/ebidel/try-puppeteer/blob/master/backend/Dockerfile" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab ej"><div class="of ab og cl cj oh"><h2 class="bd hv fv z el oi eo ep oj er et ht dt translated">ebidel/尝试木偶师</h2><div class="ok l"><h3 class="bd b fv z el oi eo ep oj er et ek translated">在云中运行木偶代码</h3></div><div class="ol l"><p class="bd b gc z el oi eo ep oj er et ek translated">github.com</p></div></div><div class="om l"><div class="on l oo op oq om or ja od"/></div></div></a></div><p id="7f98" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated">运行你自己的docker容器的好处是，你可以自由地使用任何托管提供商(只要他们允许或使用docker ),并且可以根据你的需要扩展负载。当然，你失去了lambdas提供的所有其他好处，即自动伸缩特性，这在标准云提供商中是一件棘手的事情，因为你不仅要平衡http请求，还要平衡web套接字连接。docker方法也是危险的，因为你仍然会遇到丢失字体和其他缺点。</p><p id="b649" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated">我想要表情符号🔥</p><figure class="lv lw lx ly fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff os"><img src="../Images/680849552a81fc3d5611b29911e61c30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jj7F62FUlu0dqjsNme2OHg.png"/></div></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Never realized there were so many square box emojis…</figcaption></figure><p id="79d8" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated">docker方法的另一个主要注意事项是确保脚本在干净的隔离环境中运行。尽管Chrome有一种创建匿名档案的方法，但是很少有库支持它。这大致意味着，你必须在这个容器中围绕Chrome编写一些处理程序，以确保新目标获得一个干净的上下文(阅读:中间人所有web socket消息)。呀！</p><p id="7390" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated"><strong class="jp hv">优点:</strong></p><ul class=""><li id="c95b" class="ms mt hu jp b jq kl ju km jy mu kc mv kg mw jm mx my mz na dt translated">完全控制它如何运作。</li><li id="b06a" class="ms mt hu jp b jq nb ju nc jy nd kc ne kg nf jm mx my mz na dt translated">在您自己的基础架构或其他云上运行，没有任何限制。</li><li id="8ba0" class="ms mt hu jp b jq nb ju nc jy nd kc ne kg nf jm mx my mz na dt translated">有很多很多的Dockerfile可以给你灵感。</li></ul><p id="84fa" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated"><strong class="jp hv">缺点</strong>:</p><ul class=""><li id="30da" class="ms mt hu jp b jq kl ju km jy mu kc mv kg mw jm mx my mz na dt translated">不得不用新版Chrome手动维护docker容器。</li><li id="ba07" class="ms mt hu jp b jq nb ju nc jy nd kc ne kg nf jm mx my mz na dt translated">缺少字体和其他缺点。</li><li id="46be" class="ms mt hu jp b jq nb ju nc jy nd kc ne kg nf jm mx my mz na dt translated">除非库支持，否则脚本不会独立运行。</li></ul><h1 id="cb1c" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">无浏览器的Chrome</h1><p id="34ca" class="pw-post-body-paragraph jn jo hu jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj jm hn dt translated">现在，在我过多地进入<a class="ae kk" href="https://browserless.io/" rel="noopener ugc nofollow" target="_blank">无浏览器</a>之前，我想完全公开我是它的创造者。正如你可能已经注意到的，我喜欢发现没有人考虑过的问题，并看到无头Chrome在服务提供商方面的问题。结束披露。</p><p id="9274" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated">回顾我的小礼物注册应用程序，无论是Docker还是AWS lambdas都不能满足我的要求，因为我需要他们没有的功能。表情符号是必须的，干净的隔离是必须的，因为任何人都可以使用它，我不想把所有的时间都花在维护云服务提供商的Chrome上。这就是无浏览器诞生到这个世界上的原因。</p><p id="f770" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated">无浏览器真的位于docker的顶端，但是也提供了一些其他的特性。它可以观察Chrome，当它变得迟钝时会重启它，对各种语言和表情符号都有很好的支持，并且几乎可以与任何一个库兼容:</p><p id="f203" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated"><strong class="jp hv">🎉表情符号！</strong></p><figure class="lv lw lx ly fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ot"><img src="../Images/c700eb8ad55fa0f2c0944cfc96d882f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uw30fDmdXIl8p92zz8PoCg.png"/></div></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Remember that puppeteer picture? This is what it should have looked like.</figcaption></figure><p id="6b7e" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated">这并不是说它没有缺点。首先，这可能比你自己运行一个docker容器花费更多。如果你处于“我不知道我需要多少规模”的困境中，那么它可能也不适合你。在远程位置调试浏览器工作仍然存在挑战，但这些通常在所有提供商之间共享。</p><p id="7705" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated"><strong class="jp hv">优点:</strong></p><ul class=""><li id="37ed" class="ms mt hu jp b jq kl ju km jy mu kc mv kg mw jm mx my mz na dt translated">无需维护或托管。</li><li id="9fee" class="ms mt hu jp b jq nb ju nc jy nd kc ne kg nf jm mx my mz na dt translated">字体和表情符号只是工作。</li><li id="39dd" class="ms mt hu jp b jq nb ju nc jy nd kc ne kg nf jm mx my mz na dt translated">Chrome保持高性能，脚本在它们自己的浏览器环境中运行。</li><li id="69d0" class="ms mt hu jp b jq nb ju nc jy nd kc ne kg nf jm mx my mz na dt translated">为无头Chrome定制。</li></ul><p id="f356" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated"><strong class="jp hv">缺点:</strong></p><ul class=""><li id="ba4d" class="ms mt hu jp b jq kl ju km jy mu kc mv kg mw jm mx my mz na dt translated">可能比替代品更贵。</li><li id="718c" class="ms mt hu jp b jq nb ju nc jy nd kc ne kg nf jm mx my mz na dt translated">不能像AWS那样自动缩放。</li><li id="20fe" class="ms mt hu jp b jq nb ju nc jy nd kc ne kg nf jm mx my mz na dt translated">不如其他docker图像便携。</li></ul><h1 id="bb3b" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">前方是什么</h1><p id="293c" class="pw-post-body-paragraph jn jo hu jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj jm hn dt translated">尽管我在web开发的这一部分有些磕磕绊绊，但我对迄今为止的劳动成果感到非常兴奋，并对未来的道路充满期待。我认为，为了保持最佳实践与时俱进，我们还需要传播大量的知识。为此，我很高兴地宣布，我将建立一个网站，收集这些新图书馆的最佳实践、酷想法和食谱，以及headless arena中的所有更新。请密切关注它的揭示。</p><p id="135a" class="pw-post-body-paragraph jn jo hu jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj jm hn dt translated">最后，我欢迎您对以上任何内容的想法、反馈和评论。如果我犯了严重的错误，或者你对无头浏览器有什么担心，请告诉我。在那之前，我们网上见！</p><figure class="lv lw lx ly fq iv"><div class="bz el l di"><div class="ou ov l"/></div></figure></div></div>    
</body>
</html>