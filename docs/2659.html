<html>
<head>
<title>Practical scaling techniques for web sites</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">网站的实用缩放技术</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/practical-scaling-techniques-for-web-sites-554a38dbd492?source=collection_archive---------2-----------------------#2017-02-09">https://medium.com/hackernoon/practical-scaling-techniques-for-web-sites-554a38dbd492?source=collection_archive---------2-----------------------#2017-02-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="5a1f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在从事高容量网站工作8年后，我看到了许多有趣的缩放技术。虽然非常具体的策略确实可以获得巨大的效率收益，但复杂化也不是没有代价的。根据我的经验，中等规模的站点会遇到的扩展问题可以通过以下方法解决:</p><ul class=""><li id="f6ba" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx dt translated">异步工作队列</li><li id="9cc7" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">正确使用数据库</li><li id="d9c4" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">适当的缓存</li></ul><p id="bc3d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面的例子是在Ruby on Rails的上下文中编写的，但是应该可以很好地翻译成其他语言和框架。</p><h2 id="0e05" class="kd ke hu bd kf kg kh ki kj kk kl km kn jc ko kp kq jg kr ks kt jk ku kv kw kx dt translated">异步工作队列</h2><p id="684b" class="pw-post-body-paragraph ir is hu it b iu ky iw ix iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo hn dt translated">随着网站的增长，控制人员很容易变得臃肿，并因他们可能必须执行的所有额外任务而变慢，例如:</p><ul class=""><li id="9620" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx dt translated">分析跟踪</li><li id="2780" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">发送电子邮件</li><li id="f05e" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">创建附加数据库记录</li><li id="904b" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">意外的N+1查询副作用</li></ul><p id="8c0c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，假设一个用户想要删除他的个人资料和与之相关的数千条记录—这可能需要一段时间。而且它真的没有立即发生<em class="ld"/>；相反，它可以确认请求已收到，并在完成后向他们发送电子邮件。然后，您可以在一个<strong class="it hv">异步工作队列</strong>中执行实际的删除。异步工作队列包括:</p><ol class=""><li id="ef97" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo le jv jw jx dt translated">可执行作业和作业参数的队列(通常在Redis、MongoDB、MySQL等中)。</li><li id="8003" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo le jv jw jx dt translated">从队列中提取作业并执行它们的工作池。</li></ol><p id="1aa3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">基本上，<em class="ld"> </em>可以从控制器推迟的任何事情应该是:</p><ul class=""><li id="59c6" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx dt translated"><strong class="it hv">对第三方服务的API请求。</strong>这些是必须推迟的，因为它们的响应时间可能是可变的/缓慢的，并且web请求不应该阻塞响应的呈现。更糟糕的是，如果您没有正确地检测和中止缓慢的响应，失败的API提供者可能会使您的站点瘫痪。避开这个问题，在异步工作器中执行尽可能多的API调用。</li><li id="96f8" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated"><strong class="it hv">电子邮件。基本上是一个API请求。</strong></li><li id="fb61" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated"><strong class="it hv">数据库记录创建。</strong>虽然通常比API请求快几个数量级，但由于数据库负载、索引数量和外键约束等因素，插入仍然需要10-100毫秒。</li></ul><p id="91ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不推迟的唯一理由是如果结果对回应很重要；例如，支付请求可能被阻止，从而客户立即被通知支付失败。</p><p id="60f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在web请求周期之外，异步工作队列对于并行化大型工作负载非常有用。例如，设想一个每天预定的脚本，向10k电子邮件分发列表发布新产品。如果这个脚本按顺序发送所有的电子邮件，这可能需要一个多小时。对于十几个异步工人，这可能需要将近5分钟。如果您需要处理工作/流量高峰，也可以简单地临时增加工作人员数量。</p><p id="12e6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">异步工作器对于各种问题非常有效，并且实现成本低，这使它们成为各种情况下的实用解决方案。</p><h2 id="c66a" class="kd ke hu bd kf kg kh ki kj kk kl km kn jc ko kp kq jg kr ks kt jk ku kv kw kx dt translated">正确使用数据库</h2><p id="746b" class="pw-post-body-paragraph ir is hu it b iu ky iw ix iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo hn dt translated">你的网站编写的编程语言可能是非常通用的——它以效率为代价为灵活性进行了优化。数据库是关系代数的高度优化的计算引擎。几乎有数百(如果不是数千)本书是关于数据库的，所以我将只提到我遇到的一些常见场景。</p><p id="0f9e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> N+1个查询问题</strong></p><p id="ad0b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我听到的关于对象关系映射器(ORM)的最大抱怨之一——尤其是Rails中的ActiveRecord是它们使得在不知道的情况下编写糟糕的查询/查询集变得非常容易。例如，考虑:</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="3190" class="kd ke hu ll b fv lp lq l lr ls">User.each { |u| puts u.address }</span></pre><p id="233b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">似乎无关痛痒。但是不明显的是，Rails正在执行一个查询来加载<code class="eh lt lu lv ll b">User</code>关系，然后在循环的每次迭代中查询<code class="eh lt lu lv ll b">Address</code>表:</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="13a8" class="kd ke hu ll b fv lp lq l lr ls">SELECT * FROM users;</span><span id="d4c2" class="kd ke hu ll b fv lw lq l lr ls">SELECT * FROM addresses WHERE user_id = 1;</span><span id="bf77" class="kd ke hu ll b fv lw lq l lr ls">SELECT * FROM addresses WHERE user_id = 2;</span><span id="aa83" class="kd ke hu ll b fv lw lq l lr ls">...</span></pre><p id="b9ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这类性能问题称为N+1查询问题，通过简单分析SQL日志就可以很容易地识别出来。修复方法也很简单:收集用户的id并在一条语句中查询所有用户，而不是循环查询:</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="5f94" class="kd ke hu ll b fv lp lq l lr ls">SELECT * FROM addresses WHERE user_id in (SELECT id FROM users);</span><span id="4521" class="kd ke hu ll b fv lw lq l lr ls">SELECT * FROM users INNER JOIN addresses ON (users.id = addresses.user_id);</span></pre><p id="92db" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Ruby on Rails提供了一些“急切加载”机制，可以轻松避免N+1查询模式:</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="fc07" class="kd ke hu ll b fv lp lq l lr ls">User.includes(:address).each {|u| puts u.address}</span></pre><p id="5f12" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在幕后，它指示Rails使用<code class="eh lt lu lv ll b">SELECT..FROM..WHERE id IN (?)</code>模式来选择来自用户的带有user _ ids的地址。</p><p id="99ad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">缺少索引</strong></p><p id="019f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当按任何列查询表时，数据库引擎有两种选择:查看表中的每条记录或使用索引，索引是一种高度优化的数据结构，可用于在查看表之前选择或消除记录。</p><p id="2ce3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在小于10k记录的表上，很容易意识不到您丢失了一个索引，因为它足够快了。然而，超过10k，查询将变得明显缓慢。外键关系(<code class="eh lt lu lv ll b">other_table_id</code>)是放置索引的明显位置。覆盖索引(需要返回的所有信息都在索引中)可以通过消除访问表本身的需要来加快查询速度。如果不确定是否使用了索引，可以使用数据库引擎的<code class="eh lt lu lv ll b">EXPLAIN</code>命令:</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="dadb" class="kd ke hu ll b fv lp lq l lr ls">EXPLAIN SELECT * FROM foo;<br/><br/>                       QUERY PLAN<br/>---------------------------------------------------------<br/> Seq Scan on foo  (cost=0.00..155.00 rows=10000 width=4)<br/>(1 row)<br/></span><span id="dc87" class="kd ke hu ll b fv lw lq l lr ls">EXPLAIN SELECT sum(i) FROM foo WHERE i &lt; 10;<br/><br/>                             QUERY PLAN<br/>--------------------------------------------------------------------<br/> Aggregate  (cost=23.93..23.93 rows=1 width=4)<br/>   -&gt;  Index Scan using fi on foo  (cost=0.00..23.92 rows=6 width=4)<br/>         Index Cond: (i &lt; 10)<br/>(3 rows)</span></pre><p id="cb05" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该工具将快速向您展示您的数据库引擎将使用的策略。即使你使用的是另一个数据库，关于<a class="ae lf" href="https://www.postgresql.org/docs/9.5/static/using-explain.html" rel="noopener ugc nofollow" target="_blank"> Postgres的解释</a>的文档也应该是可以遵循的。优秀的数据库管理工具<a class="ae lf" href="https://github.com/ankane/pghero" rel="noopener ugc nofollow" target="_blank"> PgHero </a>也会根据使用统计数据自动提出索引添加/删除建议。</p><p id="37f1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">序列化数据</strong></p><p id="85d9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">关系代数处理结构化数据:预定义的表、列和关系。尽管XML和JSON等半结构化数据并不总是预定义的。传统的解决方法是序列化XML或JSON，并将它们存储为文本记录。最近的数据库版本增加了对JSON(原始文本存储)和JSONB(二进制结构)的原生列支持。</p><p id="2678" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">API响应是存储在数据库中的常见JSON结构。使用本机JSON格式，在反序列化之后，可以在数据库中而不是在编程语言中轻松地查询API响应细节:</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="498b" class="kd ke hu ll b fv lp lq l lr ls">SELECT * FROM stripe_charges WHERE (transfer-&gt;'amount')::int &gt; 1000;</span></pre><p id="2273" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者，您可以从大型JSON对象中提取单个值:</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="fe96" class="kd ke hu ll b fv lp lq l lr ls">SELECT (transfer-&gt;'created'), (transfer-&gt;'amount')::int<br/>FROM stripe_charges;</span></pre><p id="1bdf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">数据库中的聚合</strong></p><p id="d506" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设您想选择所有购买金额超过100美元的用户:</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="6aaa" class="kd ke hu ll b fv lp lq l lr ls">users = User.includes(:payments).select do |u|<br/>  u.payments.map(&amp;:amount).sum &gt; 100<br/>end</span></pre><p id="08e3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将为表中的每个用户、表中的每个付款实例化一个ActiveRecord对象，然后丢弃它不需要的记录。相反，我们可以指示数据库进行过滤，只返回符合条件的用户记录:</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="9413" class="kd ke hu ll b fv lp lq l lr ls">User<br/>  .joins(:payments)<br/>  .group('users.id')<br/>  .select("users.*, SUM(payments.amount) AS total_amount")<br/>  .having("SUM(payments.amount) &gt; 100")</span></pre><p id="1f30" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这同时生成适当的<code class="eh lt lu lv ll b">JOIN</code>、<code class="eh lt lu lv ll b">HAVING</code>和<code class="eh lt lu lv ll b">GROUP BY</code>:</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="8dbb" class="kd ke hu ll b fv lp lq l lr ls">SELECT users.id, users.name, SUM(payments.amount) AS total_amount <br/>FROM users<br/>INNER JOIN payments ON payments.user_id = users.id<br/>GROUP BY users.id<br/>HAVING SUM(payments.amount) &gt; 100</span></pre><p id="8708" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">数据库总结</strong></p><p id="e944" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">数据库是成熟的、高度优化的数据存储。只要有可能，就让数据库做它们擅长的事情，而不是在你的web编程语言中做得更慢。</p><h2 id="0742" class="kd ke hu bd kf kg kh ki kj kk kl km kn jc ko kp kq jg kr ks kt jk ku kv kw kx dt translated">适当的缓存</h2><p id="4be2" class="pw-post-body-paragraph ir is hu it b iu ky iw ix iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo hn dt translated">开发社区中的一个常见说法是，在计算机科学中只有两件困难的事情:命名、缓存和相差1的错误。缓存可能很难得到正确的结果，从而导致难以追踪的陈旧值错误。我绝对不是说缓存是一颗银弹；但它肯定是你武器库中应该有的铅子弹。</p><p id="8b62" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通常，可以缓存整个响应，例如:</p><ul class=""><li id="a808" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx dt translated">对每个用户具有相同响应的API端点(例如，产品目录、提前搜索类型数据库)</li><li id="ea21" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">注销主页</li><li id="8929" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated"><code class="eh lt lu lv ll b">sitemap.xml</code></li></ul><p id="c063" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些可缓存的响应是我最喜欢的提高性能的方法。在缓存命中的情况下，不需要调用模板引擎，web服务器立即开始向客户端提供内容。很难打败0.1毫秒的响应。如果50%的流量是通过注销的主页进入的，那么缓存整个页面将是一个巨大的胜利。特别是因为谷歌在对搜索结果进行排名时，将页面响应时间视为一个信号。除了对用户和排名有利之外，缓存的响应还会减轻服务器的负载。</p><p id="8bd0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果一开始看起来整个响应不像是可缓存的，请三思。一个已登录的主页可能只是一个带有已登录菜单栏的已注销主页；在这种情况下，您可以快速提供注销的主页，然后使用AJAX将注销的菜单替换为登录的菜单。</p><figure class="lg lh li lj fq ly fe ff paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="fe ff lx"><img src="../Images/a24bc5b7772a4755bfb453d762014b31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ifmKX_bPisGY3ky3oRvH9Q.jpeg"/></div></div><figcaption class="mf mg fg fe ff mh mi bd b be z ek">Over 50% of requests to <a class="ae lf" href="http://www.cameralends.com" rel="noopener ugc nofollow" target="_blank">www.cameralends.com</a> were served in under 10ms</figcaption></figure><p id="3b1e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">即使整个响应不可缓存，昂贵的部分也可以:</p><ul class=""><li id="aac0" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx dt translated">高成本查询的结果(例如像<code class="eh lt lu lv ll b">SELECT COUNT(*)</code>这样的聚合查询，复杂的连接)</li><li id="15d5" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">需要大量计算、在同一页面上多次使用或者可以缓存很长时间的视图片段</li><li id="1905" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">第三方API响应</li></ul><p id="7afd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">缓存的一个常见问题是<a class="ae lf" href="https://en.wikipedia.org/wiki/Cache_stampede" rel="noopener ugc nofollow" target="_blank"> <em class="ld">缓存踩踏</em> </a>问题:</p><div class="mj mk fm fo ml mm"><a href="https://en.wikipedia.org/wiki/Cache_stampede" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab ej"><div class="mo ab mp cl cj mq"><h2 class="bd hv fv z el mr eo ep ms er et ht dt translated">缓存拥挤</h2><div class="mt l"><h3 class="bd b fv z el mr eo ep ms er et ek translated">缓存踩踏是一种级联故障，当具有缓存的大规模并行计算系统…</h3></div><div class="mu l"><p class="bd b gc z el mr eo ep ms er et ek translated">en.wikipedia.org</p></div></div></div></a></div><p id="44f5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该问题与缓存过期有关；想象一下，一个JSON端点需要10秒钟才能生成，并且即将过期:</p><ol class=""><li id="a63f" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo le jv jw jx dt translated">在到期之前，它会在0.1毫秒内返回</li><li id="eb42" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo le jv jw jx dt translated">它过期并被驱逐</li><li id="6c50" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo le jv jw jx dt translated">尝试访问缓存值的第一个进程发现它丢失了，并开始执行10s计算</li><li id="54a5" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo le jv jw jx dt translated">0.1秒后，第二个进程尝试访问缓存的值，发现它丢失了，并开始10秒的计算</li></ol><p id="118d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果每0.1秒就有一个请求，那么在最初的10秒请求结束之前，就会有100个昂贵的请求开始。如果它能完成的话！如果是一个昂贵的数据库查询，负载会急剧增加。可能需要20秒(或更长时间！)来完成第一个查询，这可能足以导致停机。如果只有100名网络工作人员，那么it <em class="ld">将</em>导致停机。</p><p id="18df" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个常见的解决方案是在值过期之前使用一个调度作业来缓存该值(或者甚至可能<em class="ld">永远不会</em>使该值过期，因此总是有一个快速响应)。这种策略可能有点像样板文件，不利于普遍使用。这就是为什么我喜欢异步缓存重新计算策略。</p><p id="3950" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">像产品目录这样的东西可能一天或一周只改变几次。即使这样，也可以接受成百上千的请求用一个稍微陈旧的目录来响应。我使用的异步缓存策略是这样工作的:</p><ol class=""><li id="b2e9" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo le jv jw jx dt translated">在到期之前，它会在0.1毫秒内返回</li><li id="402d" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo le jv jw jx dt translated">它软过期:<strong class="it hv">不是</strong>被驱逐，而是被标记为陈旧</li><li id="dd15" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo le jv jw jx dt translated">软过期将异步作业排队以刷新缓存值</li><li id="2cdf" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo le jv jw jx dt translated">在异步作业完成之前访问过时值的进程将在0.1毫秒内收到过时的缓存值</li><li id="7dc9" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo le jv jw jx dt translated">异步作业完成后，会更新缓存值并清除陈旧标志</li></ol><p id="d666" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种策略可以让您快速返回，除非是初始访问并且需要计算值。尽管如此，您也可以让它返回<code class="eh lt lu lv ll b">nil</code>并适度降级，并将一个异步作业排队以填充缓存值供将来响应。</p><p id="1984" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Rails通过<code class="eh lt lu lv ll b"><a class="ae lf" href="http://api.rubyonrails.org/classes/ActiveSupport/Cache/Store.html#method-i-fetch" rel="noopener ugc nofollow" target="_blank">ActiveSupport::Cache::Store#fetch</a></code>中的<code class="eh lt lu lv ll b">race_condition_ttl</code>提供了一个简单的缓存踩踏解决方案。设置此参数后，第一个访问旧值的进程将:</p><ol class=""><li id="15a4" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo le jv jw jx dt translated">将缓存的到期时间延长<code class="eh lt lu lv ll b">race_condition_ttl</code></li><li id="5802" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo le jv jw jx dt translated">重新计算缓存的值</li></ol><p id="4dbd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">访问高速缓存键第二个和进一步的进程将被返回稍微陈旧的值。如果重新计算的值还没有被<code class="eh lt lu lv ll b">race_condition_ttl</code>缓存，当前进程将跳过到期时间并重新计算。值得注意的是，一些不幸的请求将被重新计算的任务卡住，因此这种策略将对用户体验产生影响。</p><p id="5f38" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">静态缓存</strong></p><p id="fcc4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于大量不变的内容，静态缓存可能是一个不错的选择。像<a class="ae lf" href="https://github.com/jekyll/jekyll" rel="noopener ugc nofollow" target="_blank"> Jekyll </a>这样的静态站点生成器可以用来构建整个文件结构，以便通过Nginx或Apache提供服务。在Heroku上，你可以简单地使用Rack 来服务一个静态目录。</p><h2 id="7252" class="kd ke hu bd kf kg kh ki kj kk kl km kn jc ko kp kq jg kr ks kt jk ku kv kw kx dt translated">总结想法</h2><p id="c0d6" class="pw-post-body-paragraph ir is hu it b iu ky iw ix iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo hn dt translated">这一系列简单的成功远不是一个全面的优化指南，但可以让您的网站的可伸缩性惊人的远。在添加复杂的性能解决方案之前，有必要检查一下更简单、更直接的解决方案是否可行。</p><div class="lg lh li lj fq ab cb"><figure class="mv ly mw mx my mz na paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mv ly mw mx my mz na paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mv ly mw mx my mz na paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="nb nc nd"><p id="f922" class="ir is ld it b iu iv iw ix iy iz ja jb ne jd je jf nf jh ji jj ng jl jm jn jo hn dt translated"><a class="ae lf" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是AMI家庭的一员。我们现在<a class="ae lf" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae lf" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is ld it b iu iv iw ix iy iz ja jb ne jd je jf nf jh ji jj ng jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lf" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lf" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lg lh li lj fq ly fe ff paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="fe ff nh"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>