<html>
<head>
<title>Building a Facial Recognition Pipeline with Deep Learning in Tensorflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Tensorflow中用深度学习构建面部识别管道</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/building-a-facial-recognition-pipeline-with-deep-learning-in-tensorflow-66e7645015b8?source=collection_archive---------0-----------------------#2017-08-07">https://medium.com/hackernoon/building-a-facial-recognition-pipeline-with-deep-learning-in-tensorflow-66e7645015b8?source=collection_archive---------0-----------------------#2017-08-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/1bf9aa7b2ad4c3c782446218e939db49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wh1N-kogDMaZYS17lqyqeQ.jpeg"/></div></div></figure><p id="310f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我的<a class="ae ka" href="https://hackernoon.com/deep-learning-cnns-in-tensorflow-with-gpus-cba6efe0acc2" rel="noopener ugc nofollow" target="_blank">上一篇教程</a>中，你学习了卷积神经网络及其背后的理论。在本教程中，您将学习如何使用卷积神经<a class="ae ka" href="https://hackernoon.com/tagged/network" rel="noopener ugc nofollow" target="_blank">网络</a>来使用Tensorflow、Dlib和Docker执行面部识别。</p><h1 id="8ce0" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">概观</h1><ul class=""><li id="185b" class="kz la hu je b jf lb jj lc jn ld jr le jv lf jz lg lh li lj dt translated">面部识别简介</li><li id="77ec" class="kz la hu je b jf lk jj ll jn lm jr ln jv lo jz lg lh li lj dt translated">使用面部检测和对准预处理图像</li><li id="c7ee" class="kz la hu je b jf lk jj ll jn lm jr ln jv lo jz lg lh li lj dt translated">在Tensorflow中生成人脸嵌入</li><li id="7a2c" class="kz la hu je b jf lk jj ll jn lm jr ln jv lo jz lg lh li lj dt translated">训练SVM分类器</li></ul><h2 id="7efb" class="lp kc hu bd kd lq lr ls kh lt lu lv kl jn lw lx kp jr ly lz kt jv ma mb kx mc dt translated">先决条件</h2><ul class=""><li id="f5a5" class="kz la hu je b jf lb jj lc jn ld jr le jv lf jz lg lh li lj dt translated">线性代数的基本理解</li><li id="b70f" class="kz la hu je b jf lk jj ll jn lm jr ln jv lo jz lg lh li lj dt translated">卷积神经网络的基本理解</li><li id="c866" class="kz la hu je b jf lk jj ll jn lm jr ln jv lo jz lg lh li lj dt translated">基本张量流理解</li></ul></div><div class="ab cl md me hc mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hn ho hp hq hr"><h1 id="cb46" class="kb kc hu bd kd ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky dt translated"><strong class="ak">面部识别系统简介</strong></h1><p id="4115" class="pw-post-body-paragraph jc jd hu je b jf lb jh ji jj lc jl jm jn mp jp jq jr mq jt ju jv mr jx jy jz hn dt translated">面部识别是一种生物识别解决方案，可以测量一个人面部的独特特征。目前可用的应用包括<a class="ae ka" href="http://www.npr.org/sections/alltechconsidered/2017/06/26/534131967/facial-recognition-may-boost-airport-security-but-raises-privacy-worries" rel="noopener ugc nofollow" target="_blank">航班登记</a>，在照片中标记朋友和家人，以及<a class="ae ka" href="https://www.theguardian.com/media/pda/2010/sep/27/advertising-billboards-facial-recognition-japan" rel="noopener ugc nofollow" target="_blank">“量身定制”的广告。</a></p><p id="d619" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要执行面部识别，您需要一种唯一表示面部的方法。1960年，伍德罗·布莱索使用了一种标记面部显著特征坐标的技术。这些特征包括发际线、眼睛和鼻子的位置。</p><p id="7bdb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">2015年，来自谷歌的研究人员发布了一篇论文，<a class="ae ka" href="https://arxiv.org/abs/1503.03832" rel="noopener ugc nofollow" target="_blank"> FaceNet </a>，它使用了一个依赖于图像像素作为特征的卷积神经网络，而不是手动提取它们。它在<a class="ae ka" href="http://vis-www.cs.umass.edu/lfw/" rel="noopener ugc nofollow" target="_blank"> LFW数据集</a>上取得了99.63%的新纪录准确率。</p><p id="cd0b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> FaceNet: </strong>在FaceNet的论文中，提出了一种卷积神经网络架构。对于损失函数，FaceNet使用“三重损失”。三重损失依赖于最小化与正例的距离，同时最大化与负例的距离。</p><figure class="mt mu mv mw fq iv fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/7565640ef9458590a393acd7b1510a84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*dYCg9TdSj4yHfwygxKcxRQ.png"/></div><figcaption class="mx my fg fe ff mz na bd b be z ek">Triplet loss equation</figcaption></figure><figure class="mt mu mv mw fq iv fe ff paragraph-image"><div class="fe ff nb"><img src="../Images/4163720a37c76481e0612a3e781c575b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*gIW1Ak5KMvIDAugd3l15FA.png"/></div><figcaption class="mx my fg fe ff mz na bd b be z ek">Triplet loss Learning</figcaption></figure><p id="7eb1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从概念上讲，这是有道理的。相同身份的人脸看起来应该比另一个身份的人脸更接近。</p><p id="1f5e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">矢量嵌入:</strong>对于本教程来说，重要的一点是将人脸表示为128维的<strong class="je hv">嵌入</strong>。嵌入是将输入要素映射到矢量的统称。在面部识别系统中，这些输入是包含对象面部的图像，映射到数字向量表示。</p><figure class="mt mu mv mw fq iv fe ff paragraph-image"><div class="fe ff nc"><img src="../Images/d61d4081f7d4916b060a65f29753b401.png" data-original-src="https://miro.medium.com/v2/resize:fit:344/format:webp/1*tCeGt4fuK_gX1fh8OSyz1Q.png"/></div><figcaption class="mx my fg fe ff mz na bd b be z ek">Mapping input to embedding <a class="ae ka" href="https://www.slideshare.net/BhaskarMitra3/vectorland-brief-notes-from-using-text-embeddings-for-search" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><p id="1d8e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于这些向量嵌入在共享向量空间中表示，向量距离可以用于计算两个向量之间的相似性。在面部识别环境中，这可以应用向量距离来计算两张脸有多相似。此外，这些嵌入可用作分类、聚类或回归任务的特征输入。</p><figure class="mt mu mv mw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nd"><img src="../Images/6e79184adc8aace12f8355618775c67c.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*f1NMkaoh_SZmOP1-YKbF6A.jpeg"/></div></div><figcaption class="mx my fg fe ff mz na bd b be z ek">Example of plotting embeddings in a 3D vector space</figcaption></figure></div><div class="ab cl md me hc mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hn ho hp hq hr"><h1 id="e0bf" class="kb kc hu bd kd ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky dt translated">使用Dlib和Docker预处理数据</h1><pre class="mt mu mv mw fq ne nf ng nh aw ni dt"><span id="d938" class="lp kc hu nf b fv nj nk l nl nm"># Project Structure</span><span id="9ee6" class="lp kc hu nf b fv nn nk l nl nm">├── Dockerfile<br/>├── etc<br/>│ ├── 20170511–185253<br/>│ │ ├── 20170511–185253.pb<br/>├── data<br/>├── medium_facenet_tutorial<br/>│ ├── align_dlib.py<br/>│ ├── download_and_extract_model.py<br/>│ ├── __init__.py<br/>│ ├── lfw_input.py<br/>│ ├── preprocess.py<br/>│ ├── shape_predictor_68_face_landmarks.dat<br/>│ └── train_classifier.py<br/>├── requirements.txt</span></pre><h2 id="b609" class="lp kc hu bd kd lq lr ls kh lt lu lv kl jn lw lx kp jr ly lz kt jv ma mb kx mc dt translated"><strong class="ak">准备数据</strong></h2><p id="b552" class="pw-post-body-paragraph jc jd hu je b jf lb jh ji jj lc jl jm jn mp jp jq jr mq jt ju jv mr jx jy jz hn dt translated">您将使用LFW(野外标注的人脸)数据集作为训练数据。该目录的结构如下所示。您可以按照相同的结构用您的数据集替换它。</p><pre class="mt mu mv mw fq ne nf ng nh aw ni dt"><span id="3aa0" class="lp kc hu nf b fv nj nk l nl nm"># Download lfw dataset<br/>$ curl -O <a class="ae ka" href="http://vis-www.cs.umass.edu/lfw/lfw.tgz" rel="noopener ugc nofollow" target="_blank">http://vis-www.cs.umass.edu/lfw/lfw.tgz</a> # 177MB<br/>$ tar -xzvf lfw.tgz</span><span id="3a72" class="lp kc hu nf b fv nn nk l nl nm"># Directory Structure<br/># ├── Tyra_Banks<br/># │ ├── Tyra_Banks_0001.jpg<br/># │ └── Tyra_Banks_0002.jpg<br/># ├── Tyron_Garner<br/># │ ├── Tyron_Garner_0001.jpg<br/># │ └── Tyron_Garner_0002.jpg</span></pre><h2 id="c18d" class="lp kc hu bd kd lq lr ls kh lt lu lv kl jn lw lx kp jr ly lz kt jv ma mb kx mc dt translated"><strong class="ak">预处理</strong></h2><p id="d157" class="pw-post-body-paragraph jc jd hu je b jf lb jh ji jj lc jl jm jn mp jp jq jr mq jt ju jv mr jx jy jz hn dt translated">下面，您将在将图像传递到FaceNet模型之前对其进行预处理。面部识别环境中的图像预处理通常解决几个问题。这些问题包括照明差异、遮挡、对齐、分割。下面，您将解决分段和对齐问题。</p><p id="677d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，您将通过找到图像中最大的人脸来解决分割问题。这是很有用的，因为我们的训练数据不需要提前为人脸裁剪。</p><p id="e1b7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">其次，您将解决对齐问题。在照片中，脸部与图像中心不完全对齐是很常见的。为了标准化输入，您将根据眼睛和下唇的位置应用一个变换来使所有图像居中。</p><figure class="mt mu mv mw fq iv fe ff paragraph-image"><div class="fe ff no"><img src="../Images/f8e62f528cb033477393549d469caabb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*W-kzqrbo-zwIdxLgwZPHHg.jpeg"/></div><figcaption class="mx my fg fe ff mz na bd b be z ek">Segment, align, and crop</figcaption></figure><p id="4020" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">环境设置</strong></p><p id="5f19" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这里，您将使用docker来安装tensorflow、opencv和Dlib。Dlib提供了一个库，可以用于面部检测和对齐。这些库可能有点难以安装，所以您将使用Docker进行安装。</p><p id="66c7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Docker是一个简化部署的容器平台。它解决了在不同的服务器环境中安装软件依赖关系的问题。如果你是docker新手，可以在这里阅读更多<a class="ae ka" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank">。要安装docker，请运行</a></p><pre class="mt mu mv mw fq ne nf ng nh aw ni dt"><span id="847e" class="lp kc hu nf b fv nj nk l nl nm">curl <a class="ae ka" href="https://get.docker.com" rel="noopener ugc nofollow" target="_blank">https://get.docker.com</a> | sh</span></pre><p id="f4ad" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">安装docker后，您将创建两个文件。一个<strong class="je hv"> requirements.txt </strong>用于python依赖关系，一个<strong class="je hv">docker文件</strong>用于创建您的docker环境。</p><figure class="mt mu mv mw fq iv"><div class="bz el l di"><div class="np nq l"/></div></figure><figure class="mt mu mv mw fq iv"><div class="bz el l di"><div class="np nq l"/></div><figcaption class="mx my fg fe ff mz na bd b be z ek">Dockerfile</figcaption></figure><p id="bf5e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要构建这个映像，请运行:</p><pre class="mt mu mv mw fq ne nf ng nh aw ni dt"><span id="2cea" class="lp kc hu nf b fv nj nk l nl nm">$ docker build -t colemurray/medium-facenet-tutorial -f Dockerfile .</span><span id="9efb" class="lp kc hu nf b fv nn nk l nl nm"># This can take several minutes depending on your hardware<br/># On MBP, ~ 25mins<br/># Image can be pulled from dockerhub below</span></pre><p id="8918" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您想避免从源代码构建，可以使用以下命令从dockerhub中提取图像:</p><pre class="mt mu mv mw fq ne nf ng nh aw ni dt"><span id="0b49" class="lp kc hu nf b fv nj nk l nl nm">docker pull colemurray/medium-facenet-tutorial # Recommended</span><span id="ed35" class="lp kc hu nf b fv nn nk l nl nm"># A GPU supported environment can be found here<br/># nvidia-docker pull colemurray/medium-facenet-tutorial:latest-gpu</span></pre><h2 id="85f8" class="lp kc hu bd kd lq lr ls kh lt lu lv kl jn lw lx kp jr ly lz kt jv ma mb kx mc dt translated">使用Dlib检测、裁剪和对齐</h2><p id="167d" class="pw-post-body-paragraph jc jd hu je b jf lb jh ji jj lc jl jm jn mp jp jq jr mq jt ju jv mr jx jy jz hn dt translated">创建环境后，您可以开始预处理。</p><p id="bb41" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">先下载dlib的人脸地标预测器。</p><pre class="mt mu mv mw fq ne nf ng nh aw ni dt"><span id="de78" class="lp kc hu nf b fv nj nk l nl nm">$ curl -O <a class="ae ka" href="http://dlib.net/files/shape_predictor_68_face_landmarks.dat.bz2" rel="noopener ugc nofollow" target="_blank">http://dlib.net/files/shape_predictor_68_face_landmarks.dat.bz2</a><br/>$ bzip2 -d shape_predictor_68_face_landmarks.dat.bz2</span></pre><p id="7cab" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您将使用此面部标志预测器来查找图像中面部的内眼和下嘴唇的位置。这些坐标将用于居中对齐图像。</p><figure class="mt mu mv mw fq iv"><div class="bz el l di"><div class="np nq l"/></div><figcaption class="mx my fg fe ff mz na bd b be z ek">align_dlib.py</figcaption></figure><p id="2523" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个文件来自CMU，提供了检测图像中的人脸、寻找面部标志以及根据这些标志进行对齐的方法。</p><p id="b733" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，您将为数据集创建一个预处理器。这个文件会将每张图片读入内存，尝试找到最大的面，居中对齐，并将文件写入输出。如果在图像中找不到人脸，将会在控制台上显示日志记录和文件名。</p><p id="03a6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于每个图像可以独立处理，python的多重处理用于在每个可用的cpu内核上处理一个图像。</p><figure class="mt mu mv mw fq iv"><div class="bz el l di"><div class="np nq l"/></div></figure><p id="20eb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">获取结果</strong></p><p id="03b9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在您已经创建了一个管道，是时候获得结果了。由于脚本支持并行性，您将看到多核运行带来的性能提升。您需要在docker环境中运行预处理器来访问已安装的库。</p><p id="6009" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面，您将把项目目录作为一个卷挂载到docker容器中，并对输入数据运行预处理脚本。结果将被写入由命令行参数指定的目录。</p><pre class="mt mu mv mw fq ne nf ng nh aw ni dt"><span id="4e9c" class="lp kc hu nf b fv nj nk l nl nm">$ docker run -v $PWD:/medium-facenet-tutorial \<br/>-e PYTHONPATH=$PYTHONPATH:/medium-facenet-tutorial \<br/>-it colemurray/medium-facenet-tutorial python3 /medium-facenet-tutorial/medium_facenet_tutorial/preprocess.py \<br/>--input-dir /medium-facenet-tutorial/<strong class="nf hv">data</strong> \<br/>--output-dir /medium-facenet-tutorial/output/intermediate \<br/>--crop-dim 180</span></pre><blockquote class="nr ns nt"><p id="4890" class="jc jd nu je b jf jg jh ji jj jk jl jm nv jo jp jq nw js jt ju nx jw jx jy jz hn dt translated">到目前为止的代码可以在<a class="ae ka" href="https://github.com/ColeMurray/medium-facenet-tutorial/tree/add_alignment" rel="noopener ugc nofollow" target="_blank">这里</a>找到</p></blockquote><h2 id="a7fd" class="lp kc hu bd kd lq lr ls kh lt lu lv kl jn lw lx kp jr ly lz kt jv ma mb kx mc dt translated"><strong class="ak">回顾</strong></h2><p id="032e" class="pw-post-body-paragraph jc jd hu je b jf lb jh ji jj lc jl jm jn mp jp jq jr mq jt ju jv mr jx jy jz hn dt translated">使用Dlib，您检测到图像中最大的面部，并通过内眼和下唇对齐面部中心。这种对齐是一种标准化每个图像以用作特征输入的方法。</p><h1 id="3383" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated"><strong class="ak">在Tensorflow中创建嵌入</strong></h1><p id="d8b0" class="pw-post-body-paragraph jc jd hu je b jf lb jh ji jj lc jl jm jn mp jp jq jr mq jt ju jv mr jx jy jz hn dt translated">现在您已经预处理了数据，您将生成每个身份的矢量嵌入。然后，这些嵌入可以用作分类、回归或聚类任务的输入。</p><h2 id="cd3f" class="lp kc hu bd kd lq lr ls kh lt lu lv kl jn lw lx kp jr ly lz kt jv ma mb kx mc dt translated"><strong class="ak">下载重量</strong></h2><p id="58f5" class="pw-post-body-paragraph jc jd hu je b jf lb jh ji jj lc jl jm jn mp jp jq jr mq jt ju jv mr jx jy jz hn dt translated">您将使用Inception Resnet V1作为您的卷积神经网络。首先，创建一个文件，将权重下载到模型中。</p><p id="a561" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过使用预先训练的权重，您能够将<a class="ae ka" href="https://cs231n.github.io/transfer-learning/" rel="noopener ugc nofollow" target="_blank">转移学习</a>应用于新的数据集，在本教程中为LFW数据集:</p><figure class="mt mu mv mw fq iv"><div class="bz el l di"><div class="np nq l"/></div></figure><pre class="mt mu mv mw fq ne nf ng nh aw ni dt"><span id="e4cd" class="lp kc hu nf b fv nj nk l nl nm">$ docker run -v $PWD:/medium-facenet-tutorial \<br/>-e PYTHONPATH=$PYTHONPATH:/medium-facenet-tutorial \<br/>-it colemurray/medium-facenet-tutorial python3 /medium-facenet-tutorial/medium_facenet_tutorial/download_and_extract_model.py \<br/>--model-dir /medium-facenet-tutorial/etc</span></pre><h2 id="0535" class="lp kc hu bd kd lq lr ls kh lt lu lv kl jn lw lx kp jr ly lz kt jv ma mb kx mc dt translated"><strong class="ak">负载嵌入</strong></h2><p id="0a43" class="pw-post-body-paragraph jc jd hu je b jf lb jh ji jj lc jl jm jn mp jp jq jr mq jt ju jv mr jx jy jz hn dt translated">下面，您将利用Tensorflow的队列api并行加载预处理图像。通过使用队列，可以使用多线程并行加载图像。当使用GPU时，这允许在CPU上执行图像预处理，而在GPU上执行矩阵乘法。</p><figure class="mt mu mv mw fq iv"><div class="bz el l di"><div class="np nq l"/></div></figure><h2 id="5fbc" class="lp kc hu bd kd lq lr ls kh lt lu lv kl jn lw lx kp jr ly lz kt jv ma mb kx mc dt translated">训练分类器</h2><p id="9d7a" class="pw-post-body-paragraph jc jd hu je b jf lb jh ji jj lc jl jm jn mp jp jq jr mq jt ju jv mr jx jy jz hn dt translated">输入队列就绪后，您将继续创建嵌入。</p><p id="c937" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，您将从您创建的队列中加载图像。训练时，您将对图像应用预处理。这种预处理将向图像添加随机变换，从而创建更多的图像来进行训练。</p><p id="277c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些图像将以128的批量输入到模型中。这个模型将为每个图像返回一个128维的嵌入，为每个批次返回一个128 x 128的矩阵。</p><p id="683a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">创建这些嵌入后，您将使用它们作为scikit-learn的SVM分类器的特征输入，对每个身份进行训练。少于10个图像的身份将被丢弃。该参数可以从命令行进行调整。</p><figure class="mt mu mv mw fq iv"><div class="bz el l di"><div class="np nq l"/></div><figcaption class="mx my fg fe ff mz na bd b be z ek">train_classifier.py</figcaption></figure><pre class="mt mu mv mw fq ne nf ng nh aw ni dt"><span id="f64f" class="lp kc hu nf b fv nj nk l nl nm">$ docker run -v $PWD:/medium-facenet-tutorial \<br/>-e PYTHONPATH=$PYTHONPATH:/medium-facenet-tutorial \<br/>-it colemurray/medium-facenet-tutorial \<br/>python3 /medium-facenet-tutorial/medium_facenet_tutorial/train_classifier.py \<br/>--input-dir /medium-facenet-tutorial/output/intermediate \<br/>--model-path /medium-facenet-tutorial/etc/20170511-185253/20170511-185253.pb \<br/>--classifier-path /medium-facenet-tutorial/output/classifier.pkl \<br/>--num-threads 16 \<br/>--num-epochs 25 \<br/>--min-num-images-per-class 10 \<br/>--is-train </span><span id="8bfe" class="lp kc hu nf b fv nn nk l nl nm"># ~16 mins to complete on MBP</span></pre><p id="6150" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">评估结果</strong></p><p id="4a96" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，您已经训练了分类器，您将为它提供它没有训练过的新图像。您将从前面的命令中删除is_train标志来评估您的结果。</p><pre class="mt mu mv mw fq ne nf ng nh aw ni dt"><span id="3b0f" class="lp kc hu nf b fv nj nk l nl nm">docker run -v $PWD:/$(basename $PWD) \<br/>-e PYTHONPATH=$PYTHONPATH:/medium-facenet-tutorial \<br/>-it colemurray/medium-facenet-tutorial \<br/>python3 /medium-facenet-tutorial/medium_facenet_tutorial/train_classifier.py \<br/>--input-dir /medium-facenet-tutorial/output/intermediate \<br/>--model-path /medium-facenet-tutorial/etc/20170511-185253/20170511-185253.pb \<br/>--classifier-path /medium-facenet-tutorial/output/classifier.pkl \<br/>--num-threads 16 \<br/>--num-epochs 5 \<br/>--min-num-images-per-class 10</span></pre><p id="5d65" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在对每个图像的推断完成后，你会看到结果打印到控制台。在5个时期，你会看到大约85.0%的准确性。25个时期的训练给出了结果:</p><figure class="mt mu mv mw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ny"><img src="../Images/c5758b3824f3a69d498ba44bfdd14c29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*75xOtN-cLgAFeNSt6E7stg.png"/></div></div><figcaption class="mx my fg fe ff mz na bd b be z ek">90.8% @ 25 epochs</figcaption></figure><h1 id="8272" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">结论</h1><p id="ed4b" class="pw-post-body-paragraph jc jd hu je b jf lb jh ji jj lc jl jm jn mp jp jq jr mq jt ju jv mr jx jy jz hn dt translated">在本教程中，您了解了机器<a class="ae ka" href="https://hackernoon.com/tagged/learning" rel="noopener ugc nofollow" target="_blank">学习</a>的历史以及如何实现最先进的流水线。您利用docker来管理您的库依赖项，提供了一个与平台无关的一致环境。您使用Dlib进行预处理，使用Tensorflow + Scikit-learn训练能够根据图像预测身份的分类器。</p><p id="8408" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此处为完整代码:</p><div class="nz oa fm fo ob oc"><a href="https://github.com/ColeMurray/medium-facenet-tutorial" rel="noopener  ugc nofollow" target="_blank"><div class="od ab ej"><div class="oe ab of cl cj og"><h2 class="bd hv fv z el oh eo ep oi er et ht dt translated">cole Murray/medium-face net-教程</h2><div class="oj l"><h3 class="bd b fv z el oh eo ep oi er et ek translated">medium-facenet-tutorial -使用Dlib和Tensorflow的面部识别管道</h3></div><div class="ok l"><p class="bd b gc z el oh eo ep oi er et ek translated">github.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq ja oc"/></div></div></a></div><p id="8abc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">下一步:</strong></p><ul class=""><li id="693c" class="kz la hu je b jf jg jj jk jn or jr os jv ot jz lg lh li lj dt translated">在你自己的数据集上测试！</li><li id="91b7" class="kz la hu je b jf lk jj ll jn lm jr ln jv lo jz lg lh li lj dt translated">尝试不同的超参数</li><li id="29fc" class="kz la hu je b jf lk jj ll jn lm jr ln jv lo jz lg lh li lj dt translated">根据性别或年龄等其他标签进行培训</li><li id="44d9" class="kz la hu je b jf lk jj ll jn lm jr ln jv lo jz lg lh li lj dt translated">实现一个聚类算法来分组相似的脸</li></ul></div><div class="ab cl md me hc mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hn ho hp hq hr"><h1 id="dbe9" class="kb kc hu bd kd ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky dt translated">行动号召:</h1><blockquote class="nr ns nt"><p id="dca0" class="jc jd nu je b jf jg jh ji jj jk jl jm nv jo jp jq nw js jt ju nx jw jx jy jz hn dt translated">如果你喜欢这个教程，请关注并推荐！</p><p id="2ead" class="jc jd nu je b jf jg jh ji jj jk jl jm nv jo jp jq nw js jt ju nx jw jx jy jz hn dt translated">有兴趣了解更多关于深度学习/机器学习的知识吗？查看我的其他教程:</p><p id="4e12" class="jc jd nu je b jf jg jh ji jj jk jl jm nv jo jp jq nw js jt ju nx jw jx jy jz hn dt translated"><a class="ae ka" rel="noopener" href="/p/cba6efe0acc2"> -深度学习CNN的Tensorflow与GPU</a></p><p id="dbbd" class="jc jd nu je b jf jg jh ji jj jk jl jm nv jo jp jq nw js jt ju nx jw jx jy jz hn dt translated"><a class="ae ka" rel="noopener" href="/google-cloud/keras-inception-v3-on-google-compute-engine-a54918b0058"> -在谷歌计算引擎上使用Keras进行深度学习</a></p><p id="ea59" class="jc jd nu je b jf jg jh ji jj jk jl jm nv jo jp jq nw js jt ju nx jw jx jy jz hn dt translated"><a class="ae ka" rel="noopener" href="/google-cloud/recommendation-systems-with-spark-on-google-dataproc-bbb276c0dafd"> -在谷歌计算引擎上使用Apache Spark的推荐系统</a></p><p id="d08b" class="jc jd nu je b jf jg jh ji jj jk jl jm nv jo jp jq nw js jt ju nx jw jx jy jz hn dt translated">你可以在其他地方找到我:</p><p id="3d78" class="jc jd nu je b jf jg jh ji jj jk jl jm nv jo jp jq nw js jt ju nx jw jx jy jz hn dt translated">——推特:<a class="ae ka" href="https://twitter.com/_ColeMurray" rel="noopener ugc nofollow" target="_blank">https://twitter.com/_ColeMurray</a></p></blockquote><figure class="mt mu mv mw fq iv"><div class="bz el l di"><div class="ou nq l"/></div></figure></div></div>    
</body>
</html>