<html>
<head>
<title>Javascript: experience of migrating from MongoDB to PostgreSQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript:从MongoDB迁移到PostgreSQL的体验</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/javascript-experience-of-migrating-from-mongodb-to-postgresql-21f8bf140c05?source=collection_archive---------3-----------------------#2016-11-08">https://medium.com/hackernoon/javascript-experience-of-migrating-from-mongodb-to-postgresql-21f8bf140c05?source=collection_archive---------3-----------------------#2016-11-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/f2afea436a5ea8d9b92e0e9811d855d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GKscV-NlSC8lj0J2QgXI7g.jpeg"/></div></div></figure><h2 id="0e16" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">背景</h2><p id="bfb5" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">我们的项目(<a class="ae kv" href="http://labcup.net" rel="noopener ugc nofollow" target="_blank">labcup.net</a>)始于一个业余爱好周末项目，事实上..这自然是一个尝试新技术的好地方，这是我们大约2年前选择MongoDB的原因。该项目已经发展成为一项全职工作，并开始有付费客户。尽管试验在当时是一个正确的决定，但MongoDB显然不适合现在的任务(我们有相对较小的数据库，用户很少，但非常需要一致性)。<br/>我们知道这一点，但必须继续前进，直到今年夏天，当我们花了这么多时间来发现和修复<a class="ae kv" href="https://hackernoon.com/tagged/database" rel="noopener ugc nofollow" target="_blank">数据库</a>的不一致性，我们不能再忍受下去了，我们必须采取行动。<br/> <em class="kw">注意</em>:不一致不是因为缺少测试，而是因为缺少类型检查(或者静默转换)、缺少事务以及错误的假设；—除非检查代码，否则只能猜测结构和类型。<br/> <em class="kw">注</em>:项目规模在60K LOC左右(无注释，根据<a class="ae kv" href="https://github.com/AlDanial/cloc" rel="noopener ugc nofollow" target="_blank"> <em class="kw"> cloc </em> </a>)而且只是打字稿，绝对不是小项目。<br/>我还必须在这里提到，typescript在类型检查和结构定义方面帮助很大，但显然还需要更多。<br/> <em class="kw">注意</em>:MongoDB也有其他问题。例如:<br/>-ObjectId占用了32个字符，这对于在客户端发送和存储来说是一个很大的数目(我们在浏览器的indexedDb上缓存数据)。<br/> -不是最大的问题，但令人讨厌且容易出错的是总是转换查询的ObjectId(例如，如果字符串用于查询，它只是安静地返回，没有结果)<br/> -一些神秘的不一致可能是由于令人惊讶的索引使用，其中不是所有的记录都已返回。(见此<a class="ae kv" href="https://engineering.meteor.com/MongoDB-queries-dont-always-return-all-matching-documents-654b6594a827#.j1n0zyk2d" rel="noopener ugc nofollow" target="_blank">https://engineering . meteor . com/MongoDB-queries-dont-always-return-all-matching-documents-654 b 6594 a 827 #、j1n0zyk2d </a>)</p><h2 id="6d21" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">为什么选择PostgreSQL？</h2><p id="0070" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">之前我们都有使用MySQL/MariaDb的经验，但是PostgreSQL对JSON列和操作符有更好的支持，然而仅此一点就足以成为选择它的理由，但是像(<a class="ae kv" href="http://www.wikivs.com/wiki/MySQL_vs_PostgreSQL" rel="noopener ugc nofollow" target="_blank">http://www.wikivs.com/wiki/MySQL_vs_PostgreSQL</a>)这样的帖子也给我们留下了非常好的印象，我们希望深入了解。最后但并非最不重要的一点是，我不指望Oracle会花太多精力来长期开发MySQL。所以PostgreSQL是我们的自然选择。</p><h2 id="e119" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">PostgreSQL用哪个js库？</h2><p id="fc21" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">因为我们都对ORM有偏见，主要是因为<br/> -它们往往被过度设计<br/> -它们通常不支持额外的功能(因为最小公分母)<br/> -通常你必须学习一些新的语法，而不是使用纯SQL <br/> -通常你必须预定义许多东西，这是很大的开销<br/> -这不是真正的抽象，因为你必须对数据库和ORM都很好，这样它只是站在路上。</p><p id="2ecf" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn kz km kn jr la kp kq jv lb ks kt ku hn dt translated">…我们不会再更改数据库。</p><p id="4d94" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn kz km kn jr la kp kq jv lb ks kt ku hn dt translated">我们所寻找的是一个简单的库，轻松涵盖95%的查询(其余的可以用SQL完成)。它不应该使用回调，至少应该支持承诺，但是async-await会更棒。<br/>现在<a class="ae kv" href="https://github.com/brianc/node-postgres" rel="noopener ugc nofollow" target="_blank"> pg.js </a>支持async-await，但实际上，它太简单了。另一方面，看起来正是我们想要的。不幸的是，当我们开始使用它时，越来越多的限制出现了。例如，没有事务，没有池，每个查询打开和关闭一个连接，没有记录器，它只猜测JSON类型，当您插入一个空数组[]时会失败。主要是使用关系或完全JSON列表。经过几天的试验，我们决定编写自己的库。在pg.js上建立了完整的typescript和async-await支持，作为一名优秀的艺术家，s̶t̶e̶a̶l̶从Massive借鉴了一些想法，并最终编写了pogi。</p><p id="c70b" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn kz km kn jr la kp kq jv lb ks kt ku hn dt translated">起初，看起来编写我们自己的处理程序库需要更长的时间，但是我们实际上更快地直接编写我们需要的东西，而不是解决问题。</p><figure class="ld le lf lg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lc"><img src="../Images/61f486ce3950076efabe4f9ebca2b372.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sXhnV2BBka3-i3TLALPJ-Q.jpeg"/></div></div></figure><h2 id="f18f" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">花了多长时间？</h2><p id="02e2" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">加在一起大约是两个半人工月。大约1个月用于转换，1个多月用于测试应用程序的每个部分。(也浪费了大量时间来解决不一致的问题。)</p><p id="1fd7" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn kz km kn jr la kp kq jv lb ks kt ku hn dt translated">好的一面是，使用jsonb专栏，我们可以节省很多时间。只是必须转换的重要领域(一个与外键，需要(特殊)检查，必须或应该存在，一个可以有特殊索引等。)其余的可以放在jsonb列中，所以基本上不需要从MongoDB进行转换。</p><p id="4017" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn kz km kn jr la kp kq jv lb ks kt ku hn dt translated">至于查询，语法与MongoDB没有太大的不同，所以除了连接查询之外，几乎所有的修改都很简单。但是删除大量代码并用一个优雅的小连接代替它是一件令人愉快的事情。</p><p id="196c" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn kz km kn jr la kp kq jv lb ks kt ku hn dt translated">公平地说，这也是在一些技术部门工作的好时机。因为完整的测试无论如何都要进行，所以在那里也要进行几天。</p><h2 id="8e44" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">到目前为止，你最喜欢/不喜欢PostgreSQL的什么？</h2><p id="ce70" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">当然喜欢:<br/> - jsonb列<br/> -部分和转换的索引，例如:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="e910" class="jc jd hu li b fv lm ln l lo lp">CREATE UNIQUE INDEX “magical_idx” ON “users” (LOWER(“name”), NULLIF(“removed”, true));</span></pre><p id="7106" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn kz km kn jr la kp kq jv lb ks kt ku hn dt translated">因此不可能创建只有大小写不同的两个用户，但是如果用户被“删除”，您可以重用这个名称。(注:这只是一个例子，不一定是好的设计。)<br/>——数组式，主要结合枚举，感觉就是自然。</p><p id="5ef9" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn kz km kn jr la kp kq jv lb ks kt ku hn dt translated">不喜欢:<br/> -在MySQL中添加创建/更新的时间戳很容易-可以添加到表定义中-在这里为每个表添加触发器有点麻烦<br/> -复杂类型感觉有点像hack，没有外键检查和麻烦的查询，我只是觉得不值得使用它们。</p><figure class="ld le lf lg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lq"><img src="../Images/d8dfa3eda443b2fb6de51b231285dbe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zor8m63ojt2ufxtVn5yM_A.jpeg"/></div></div></figure><h2 id="eac7" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">有哪些棘手的部分？</h2><ul class=""><li id="34a7" class="lr ls hu kc b kd ke kh ki jn lt jr lu jv lv ku lw lx ly lz dt translated">在MongoDB中，你有唯一键(uuid ),这是很难猜测的，也使得暴力扫描有点困难。幸运的是，有一种简单的方法可以在PostgreSQL中创建不可猜测的索引，因此您可以在随机情况下拥有跨表的唯一键。通过将列定义为:</li></ul><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="c722" class="jc jd hu li b fv lm ln l lo lp">“id” varchar PRIMARY KEY NOT NULL DEFAULT (‘us’ || nextval(‘users_id_seq’)::text || (LPAD(floor(random()*1000)::text, 3, ‘0’))),</span></pre><p id="b7c9" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn kz km kn jr la kp kq jv lb ks kt ku hn dt translated">通过这种方式，每个表都有一个唯一的前缀(“us”代表“users”)，然后是一个序列号，最后是一个随机数，以使对用户/文件或其他内容的迭代变得更加困难(或者在适当的位置使用阻塞是不可能的)。这甚至可以通过将数字转换为使用所有字母的基数来缩短(<a class="ae kv" href="https://www.postgresql.org/message-id/482B7FAF.7000902%40lorenso.com" rel="noopener ugc nofollow" target="_blank">https://www . PostgreSQL . org/message-id/482 b 7 faf . 7000902% 40 lorenso . com</a>)。</p><ul class=""><li id="2adc" class="lr ls hu kc b kd kx kh ky jn ma jr mb jv mc ku lw lx ly lz dt translated">类型转换<br/>使用完整的json文档存储转换没有问题(只有ObjectId对MongoDB来说比较麻烦)，但是当你开始使用两个系统时，不可避免地会有一些东西有不同的表示。例如，PostgreSQL bigInt可以比<a class="ae kv" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> javascript </a>更精确地表示更大的数字。在我们的库中，我们已经解决了这个问题，如果这个数大于。MAX_SAFE_INTEGER，那么我们抛出一个异常，否则转换数字。对于95%的情况来说，这是一个很好的折衷，在其余的情况下，需要自己处理转换。<br/>对于处理数组，您还必须选择:<br/> -使用json(b)列，但随后您必须自己验证管理数据一致性<br/> -使用PostgreSQL，例如枚举、字符串、数字或复杂类型数组<br/>对于第二种情况，lib会自动转换前3种基本类型，但对于复杂类型，它需要一些额外的工作(要么在PostgreSQL中将其转换为json，要么在javascript中解析字符串表示)。</li><li id="902b" class="lr ls hu kc b kd md kh me jn mf jr mg jv mh ku lw lx ly lz dt translated">delete vs设置为null <br/>对于MongoDB(或者更像是对于JSON)，你是在操作对象，比如删除一个字段其实就是从对象中删除字段:<br/>delete record . price；然后将整个记录发送到服务器以覆盖先前的记录。<br/>但是对于关系数据库，因为你只覆盖已经改变的内容，所以你必须将字段设置为空。总的来说没什么大不了的，但这是一个很小的基本差异，需要特别注意。</li></ul><p id="8212" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn kz km kn jr la kp kq jv lb ks kt ku hn dt translated">仅此而已，它比我们最初预期的更容易改变(这也是我们一直推迟的原因)，只是很难找到时间完全停止开发并完全专注于这个庞大的技术部(因为我们不是MongoDB的目标受众)。正如预期的那样，现在我们有了事务支持，许多查询变得更快了，并且有许多类型检查，也可以作为文档…</p><div class="ld le lf lg fq ab cb"><figure class="mi iv mj mk ml mm mn paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mi iv mj mk ml mm mn paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mi iv mj mk ml mm mn paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mo mp mq"><p id="f922" class="ka kb kw kc b kd kx kf kg kh ky kj kk mr kz km kn ms la kp kq mt lb ks kt ku hn dt translated"><a class="ae kv" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是阿妹家庭的一员。我们现在<a class="ae kv" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae kv" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ka kb kw kc b kd kx kf kg kh ky kj kk mr kz km kn ms la kp kq mt lb ks kt ku hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kv" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kv" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ld le lf lg fq iv fe ff paragraph-image"><a href="https://goo.gl/Ahtev1"><div class="fe ff mu"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></a></figure><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="mv mw l"/></div></figure></div></div>    
</body>
</html>