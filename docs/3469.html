<html>
<head>
<title>Matreshka.js 2 — tl;dr</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">matreshka . js 2—TL；博士；医生</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/matreshka-js-2-tl-dr-dad0e941201a?source=collection_archive---------16-----------------------#2017-04-03">https://medium.com/hackernoon/matreshka-js-2-tl-dr-dad0e941201a?source=collection_archive---------16-----------------------#2017-04-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div class="ab fr cl iv"><img src="../Images/873c18dccd8e5af18402e8dac3d39631.png" data-original-src="https://miro.medium.com/v2/0*hiEWd1s9GoE1ehJ1."/></div></figure><p id="bc47" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><em class="jw">网址:</em><a class="ae jx" href="https://matreshka.io/?c" rel="noopener ugc nofollow" target="_blank"><em class="jw">matreshka . io</em></a><em class="jw"><br/>示例:</em><a class="ae jx" href="https://github.com/matreshkajs/examples-and-tutorials" rel="noopener ugc nofollow" target="_blank"><em class="jw">Github/matreshkajs/Examples-and-tutorials</em></a><em class="jw"><br/>关于Github:</em><a class="ae jx" href="https://github.com/matreshkajs/matreshka" rel="noopener ugc nofollow" target="_blank"><em class="jw">Github/matreshkajs/matreshkajs</em></a></p><p id="1953" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">提醒一下:Matreshka.js是单页面应用程序的替代JavaScript框架。</p><h1 id="5a24" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">主要功能</h1><p id="ae25" class="pw-post-body-paragraph iy iz hu ja b jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv hn dt translated">函数将一个对象的属性绑定到HTML节点。</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="1195" class="lk jz hu lg b fv ll lm l ln lo"><strong class="lg hv">const</strong> object = { name: 'Brendan' };<br/><strong class="lg hv">const</strong> node = document.querySelector('.name'); Matreshka.bindNode(object, 'name', node);<br/>object.name = 'Doug';</span></pre><figure class="lb lc ld le fq iu"><div class="bz el l di"><div class="lp lq l"/></div></figure><p id="191e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">属性改变也会改变绑定节点，反之亦然(例如，如果用户键入某些内容)。js处理所有现成的HTML表单元素。文档中的<a class="ae jx" href="https://matreshka.io/#!Matreshka-bindNode" rel="noopener ugc nofollow" target="_blank">描述了自定义元素绑定。</a></p><p id="6b14" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv"> calc </strong>函数使一个属性依赖于其他属性。</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="be35" class="lk jz hu lg b fv ll lm l ln lo"><strong class="lg hv">Matreshka</strong>.calc(<strong class="lg hv">object</strong>, 'fullName<strong class="lg hv">'</strong>, ['firstName', 'lastName'], (firstName, lastName) <strong class="lg hv">=&gt;</strong> {<br/>    <strong class="lg hv">return</strong> `${firstName} ${lastName}`<br/>});</span><span id="3277" class="lk jz hu lg b fv lr lm l ln lo"><strong class="lg hv">object</strong>.firstName = 'Brendan';<br/><strong class="lg hv">object</strong>.lastName = 'Eich';<br/><em class="jw">// …<br/></em>console.log(<strong class="lg hv">object</strong>.fullName); <em class="jw">// “Brendan Eich”</em></span></pre><p id="384c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">当源属性发生更改(<em class="jw">名字</em>或<em class="jw">姓氏</em>)时，目标属性(<em class="jw">全名</em>)会重新计算。</p><p id="0099" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv"> calc </strong>和<strong class="ja hv"> bindNode </strong>使得定义长的依赖链成为可能:属性<em class="jw"> a </em>依赖于元素<em class="jw"> e1 </em>，属性<em class="jw"> b </em>依赖于属性<em class="jw"> a </em>，属性<em class="jw"> c </em>依赖于元素<em class="jw"> e2 </em>和<em class="jw"> e3 </em>以及属性<em class="jw"> b </em>因此，属性<em class="jw"> b </em>的改变也会改变<em class="jw"> e1 </em>、<em class="jw"> e2 </em>、<em class="jw"> e3 </em>等等…</p><p id="0bd5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">你可以把这种依赖想象成一个Excell表。你每时每刻都在想一个公式，而不是所有细胞的众多依赖关系。因此，您得到的bug更少，因为没有必要把所有的“表”(应用程序)逻辑都记在脑子里。在<a class="ae jx" href="https://matreshka.io/#!Matreshka-calc" rel="noopener ugc nofollow" target="_blank">文档</a>中，你会找到更多关于<strong class="ja hv">计算</strong>的信息。</p><p id="6381" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">功能上的<strong class="ja hv">监听事件，而<strong class="ja hv">触发器</strong>功能触发它们。</strong></p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="73ae" class="lk jz hu lg b fv ll lm l ln lo"><strong class="lg hv">Matreshka</strong>.on(<strong class="lg hv">object</strong>, 'something', () =&gt; {<br/>  alert('something is happened')<br/>});</span><span id="f10c" class="lk jz hu lg b fv lr lm l ln lo"><strong class="lg hv">Matreshka</strong>.trigger(<strong class="lg hv">object</strong>, 'something');</span></pre><p id="461b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">上的<strong class="ja hv">函数可以监听属性改变事件来执行自定义代码。通过这种方式，您可以向依赖链添加另一个东西(例如fetch request)。</strong></p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="79d9" class="lk jz hu lg b fv ll lm l ln lo"><strong class="lg hv">const</strong> { on } = <strong class="lg hv">Matreshka</strong>;</span><span id="5caa" class="lk jz hu lg b fv lr lm l ln lo">on(<strong class="lg hv">object</strong>, 'change:fullName', <strong class="lg hv">async</strong> () =&gt; {<br/>  <strong class="lg hv">await</strong> fetch('/api/name', { method: 'post', body: this.fullName });<br/>  // …<br/>});</span></pre><figure class="lb lc ld le fq iu"><div class="bz el l di"><div class="lp lq l"/></div></figure><p id="e4a0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Matreshka.js的活动是一个广泛而有趣的话题。有了它们，可以监听对象的委托事件(例如，监听对象树深处的变化)、DOM事件、委托的DOM事件等。你可以在<a class="ae jx" href="https://github.com/matreshkajs/examples-and-tutorials/tree/master/events" rel="noopener ugc nofollow" target="_blank">“事件”</a>文章中读到他们。</p><p id="54d6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">调解</strong>功能增加了运行时验证和属性值转换。例如，您可以定义一个确定类型的属性，您可以将属性限制在一个指定的范围内，如果需要，您可以抛出一个异常。</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="b148" class="lk jz hu lg b fv ll lm l ln lo"><strong class="lg hv">Matreshka</strong>.mediate(object, 'x', x =&gt; String(x));<br/>object.x = 42;<br/>console.log(object.x, <strong class="lg hv">typeof</strong> object.x); <em class="jw">// “42”, “string”</em></span></pre><h1 id="b26b" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated"><strong class="ak">级</strong></h1><p id="c9c2" class="pw-post-body-paragraph iy iz hu ja b jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv hn dt translated"><strong class="ja hv"> Matreshka </strong>类实例具有相同的方法集，但有一个不同之处:<strong class="ja hv">此</strong>用于代替对象参数。</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="8e9e" class="lk jz hu lg b fv ll lm l ln lo"><strong class="lg hv">class</strong> <strong class="lg hv">User</strong> <strong class="lg hv">extends</strong> <strong class="lg hv">Matreshka</strong> {<br/>  constructor() {<br/>    <strong class="lg hv">super</strong>();<br/>    <strong class="lg hv">this</strong>.bindNode('fullName', '.full-name');<br/>    <strong class="lg hv">this</strong>.calc('fullName', ['firstName', 'lastName'],<br/>      (firstName, lastName) =&gt; `${firstName} ${lastName}`);<br/>    <em class="jw">// also chained call can be used there:<br/>    // super().bindNode(...).calc(...);<br/>  </em>}<br/>}</span></pre><p id="532b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">本课程将课程<strong class="ja hv"> Matreshka结合在一起。对象</strong>、<strong class="ja hv"> Matreshka。数组</strong>如下所述，使它们有一个共同的方法集。</p><p id="7aea" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">类<strong class="ja hv"> Matreshka。对象</strong>负责数据的键值类型。在Matreshka.js术语中，“数据”表示开发人员可能想要发送到本地数据库的服务器或存储中的属性。因此，框架需要知道哪些属性负责数据(例如用户名)，哪些负责临时应用程序状态(例如DOM元素是否隐藏)。此类属性由<strong class="ja hv">add datakey</strong>方法定义。</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="2f6b" class="lk jz hu lg b fv ll lm l ln lo"><strong class="lg hv">class</strong> <strong class="lg hv">User</strong> <strong class="lg hv">extends</strong> <strong class="lg hv">Matreshka</strong>.<strong class="lg hv">Object</strong> {<br/>  constructor() {<br/>    <strong class="lg hv">super</strong>();<br/>    <strong class="lg hv">this</strong>.firstName = 'Brendan';<br/>    <strong class="lg hv">this</strong>.lastName = 'Eich';<br/>    <strong class="lg hv">this</strong>.language = 'JavaScript';<br/>    <strong class="lg hv">this</strong>.addDataKeys(['firstName', 'lastName']);</span><span id="9c16" class="lk jz hu lg b fv lr lm l ln lo"><em class="jw">    // '{“firstName”: “Brendan”, “lastName”: “Eich”}'</em> <br/>    console.log(<strong class="lg hv">JSON</strong>.stringify(<strong class="lg hv">this</strong>));<br/>  }<br/>}</span></pre><p id="6368" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">关于<strong class="ja hv"> Matreshka更详细。对象</strong>类你可以在那里读到<a class="ae jx" href="https://github.com/matreshkajs/examples-and-tutorials/tree/master/matreshka-object" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="e356" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv"> Matreshka。Array </strong>负责框架中类似数组的集合。除了从<strong class="ja hv"> Matreshka </strong>继承的方法外，还有<strong class="ja hv"> Matreshka的实例。Array </strong>包含本机Array的所有方法(推送、拼接、映射、缩减……)。</p><p id="e8a4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">类似于主干网。集合中，可以定义一个"模型"(Model<strong class="ja hv">)属性。区别在于它可以是任何JavaScript类。</strong></p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="fb95" class="lk jz hu lg b fv ll lm l ln lo"><strong class="lg hv">class</strong> <strong class="lg hv">Users</strong> <strong class="lg hv">extends</strong> <strong class="lg hv">Matreshka</strong>.<strong class="lg hv">Array</strong> {<br/>  get <strong class="lg hv">Model</strong>() { <strong class="lg hv">return</strong> <strong class="lg hv">User</strong>; }<br/>  constructor() {<br/>    <strong class="lg hv">super</strong>();<br/>    <strong class="lg hv">this</strong>.push({ firstName: 'Brendan', lastName: 'Eich' }); <br/>    console.log(<strong class="lg hv">this</strong>[0] instanceof <strong class="lg hv">User</strong>); <em class="jw">// true<br/>  </em>}<br/>}</span></pre><p id="5b85" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">当集合的项目更改时，它可以自动呈现。为此，您需要设置在何处插入新创建的DOM元素以及如何呈现它们。要设置呈现元素的位置，需要将容器元素绑定到<strong class="ja hv">沙箱</strong>或<strong class="ja hv">容器</strong>属性(区别在文档中描述)。要声明如何渲染DOM元素，您应该定义虚拟方法<strong class="ja hv"> itemRenderer </strong>(或<strong class="ja hv"> renderer </strong>用于<strong class="ja hv">模型</strong>类)。</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="7a0f" class="lk jz hu lg b fv ll lm l ln lo"><strong class="lg hv">class</strong> <strong class="lg hv">Foo</strong> <strong class="lg hv">extends</strong> <strong class="lg hv">Matreshka</strong>.<strong class="lg hv">Array</strong> {<br/>  itemRenderer(){ <br/>    return '&lt;div&gt;Hello, world!&lt;/div&gt;'<br/>  }</span><span id="4e72" class="lk jz hu lg b fv lr lm l ln lo">  constructor() {<br/>    <strong class="lg hv">super</strong>();<br/>    <strong class="lg hv">this</strong>.bindNode('sandbox', '.sandbox-node');<br/>    <em class="jw">// inserts &lt;div&gt;Hello, world!&lt;/div&gt; to .sandbox-node</em><br/>    <strong class="lg hv">this</strong>.push({});<br/>  }<br/>}</span></pre><p id="9625" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">你可以在那里阅读<a class="ae jx" href="https://github.com/matreshkajs/examples-and-tutorials/tree/master/matreshka-array" rel="noopener ugc nofollow" target="_blank"/>更详细的关于<strong class="ja hv">玛特莱什卡的信息。阵</strong>级。</p><p id="850c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所有函数和类都可以作为CJS/ES2015模块导入。</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="5d0d" class="lk jz hu lg b fv ll lm l ln lo"><strong class="lg hv">import</strong> calc <strong class="lg hv">from</strong> 'matreshka/calc';<br/><strong class="lg hv">import</strong> MatreshkaArray <strong class="lg hv">from</strong> 'matreshka/array';</span></pre><h1 id="0c58" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">按指定路线发送</h1><p id="8d75" class="pw-post-body-paragraph iy iz hu ja b jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv hn dt translated">一个名为<a class="ae jx" href="https://github.com/matreshkajs/matreshka-router" rel="noopener ugc nofollow" target="_blank">的库负责路由。它将属性绑定到页面地址的部分。</a></p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="0983" class="lk jz hu lg b fv ll lm l ln lo"><strong class="lg hv">Matreshka</strong>.initRouter(<strong class="lg hv">object</strong>, ‘<strong class="lg hv">/a/b/c/</strong>’);<br/><strong class="lg hv">object</strong>.<strong class="lg hv">a</strong> = 'foo';<br/><strong class="lg hv">object</strong>.<strong class="lg hv">b</strong> = 'bar';<br/><strong class="lg hv">object</strong>.<strong class="lg hv">c</strong> = 'baz'; <em class="jw">// makes location.hash to be #!/foo/bar/baz/</em></span></pre><h1 id="715d" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">结论</h1><p id="102d" class="pw-post-body-paragraph iy iz hu ja b jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv hn dt translated">Matreshka.js填补了初级和高级之间的空白，允许在web开发人员职业生涯的开始编写模块化和可扩展的应用程序。开始之前你需要知道的一切都是JavaScript。</p><div class="lb lc ld le fq ab cb"><figure class="ls iu lt lu lv lw lx paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="ls iu lt lu lv lw lx paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="ls iu lt lu lv lw lx paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ly lz ma"><p id="f922" class="iy iz jw ja b jb jc jd je jf jg jh ji mb jk jl jm mc jo jp jq md js jt ju jv hn dt translated"><a class="ae jx" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客们开始他们下午的方式。我们是<a class="ae jx" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jx" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受提交</a>并很高兴<a class="ae jx" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="iy iz jw ja b jb jc jd je jf jg jh ji mb jk jl jm mc jo jp jq md js jt ju jv hn dt translated">如果您喜欢这个故事，我们建议您阅读我们的<a class="ae jx" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jx" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实视为理所当然！</p></blockquote><figure class="lb lc ld le fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="fe ff me"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>