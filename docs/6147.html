<html>
<head>
<title>I Promise you a Miracle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我向你保证一个奇迹</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/i-promise-you-a-miracle-396301751c4b?source=collection_archive---------15-----------------------#2017-09-05">https://medium.com/hackernoon/i-promise-you-a-miracle-396301751c4b?source=collection_archive---------15-----------------------#2017-09-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="4604" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">我正在滚动我自己的JavaScript承诺。</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff jj"><img src="../Images/06e59c4755aab7950424adb8a94d6c9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*e2gbdD2YoTUoNJhocvdI3g.png"/></div></figure><p id="d723" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">有时候，当你真的想理解一件事的时候，尝试自己去构建它是值得的。这就是我在这篇文章中对承诺所做的。我试图建立一个非常基本的“承诺”。</p><h2 id="0fb0" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ka ky kz la ke lb lc ld ki le lf lg lh dt translated">一开始有试镜…</h2><p id="fcd9" class="pw-post-body-paragraph jr js hu jt b ju li iv jw jx lj iy jz ka lk kc kd ke ll kg kh ki lm kk kl km hn dt translated">让我们从最基本的开始，在任何人听说承诺之前，我们有过回调。看看下面的片段。</p><pre class="jk jl jm jn fq ln lo lp lq aw lr dt"><span id="2408" class="kn ko hu lo b fv ls lt l lu lv">const testUrl = '<a class="ae lw" href="https://api.github.com/users/odemeulder" rel="noopener ugc nofollow" target="_blank">https://api.github.com/users/odemeulder</a>'<br/>const fetchData = (url, callback) =&gt; {<br/>  let xhr = new XMLHttpRequest()<br/>  xhr.onreadystatechange = () =&gt; {<br/>    if (xhr.readyState == 200 ) { <br/>      callback(xhr.responseText)<br/>    }<br/>  }<br/>  xhr.open(url)<br/>  xhr.send()<br/>}<br/>fetchData(testUrl, response =&gt; console.log(response) )</span></pre><p id="14cf" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">它是做什么的？它创建了一个非常简单的<a class="ae lw" href="https://hackernoon.com/tagged/function" rel="noopener ugc nofollow" target="_blank">函数</a>，该函数获取一个url，使用<code class="eh lx ly lz lo b">XMLHttpRequest</code>读取它，并允许回调函数对结果做一些事情。在最后一行，我们调用新函数。作为回调，我们提供了一个打印响应的函数。很简单。如果你对<code class="eh lx ly lz lo b">XMLHttpRequest</code>不熟悉，不要苦恼，对于文章的其余部分理解并不重要。只知道它是浏览器提供给<a class="ae lw" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>执行<code class="eh lx ly lz lo b">http </code>请求的对象。这是一个异步函数，它在<code class="eh lx ly lz lo b">onreadystatechange </code>事件触发时接受回调。</p><h2 id="1dcf" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ka ky kz la ke lb lc ld ki le lf lg lh dt translated">承诺是什么样子的？</h2><p id="57b8" class="pw-post-body-paragraph jr js hu jt b ju li iv jw jx lj iy jz ka lk kc kd ke ll kg kh ki lm kk kl km hn dt translated">在开始写我们自己的承诺之前，让我们看看最终的结果应该是什么样的。什么是呼叫签名？</p><pre class="jk jl jm jn fq ln lo lp lq aw lr dt"><span id="f658" class="kn ko hu lo b fv ls lt l lu lv">function fetchDataReturningPromise(url) {<br/>  // what happens here?<br/>}</span><span id="a79f" class="kn ko hu lo b fv ma lt l lu lv">function functionWithDelay(arg) {<br/>  // what happens here?<br/>}</span><span id="d2fd" class="kn ko hu lo b fv ma lt l lu lv">fetchDataReturningPromise(url).then(response =&gt; console.log(response))<br/>// or<br/>functionWithDelay(arg1).then(performFollowUpOperation)<br/>// or<br/>functionWithDelay(arg1).then((resolvedValue) =&gt;<br/>  PerformFollowUpOperation(resolvedValue))</span></pre><p id="5797" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">这是什么？让我们来关注第三个例子。</p><p id="76ab" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我们有一个延迟函数。函数内部的某个东西进行了异步调用。可能是超时、http请求、数据库调用。</p><p id="aaa5" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">那个函数返回“某物”。那个某物有一个<code class="eh lx ly lz lo b">then </code>方法，所以‘某物’一定是一个对象。事实上,“某物”将是一个函数。</p><p id="918f" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated"><code class="eh lx ly lz lo b">then </code>函数以函数或回调的形式接受一个参数。传递给<code class="eh lx ly lz lo b">then </code>函数的回调直到<code class="eh lx ly lz lo b">functionWithDelay </code>完成后才会执行。在我们的第三个例子中，传递给<code class="eh lx ly lz lo b">then</code>的函数被标记为<code class="eh lx ly lz lo b">performFollowUpOperation</code>。请注意，<code class="eh lx ly lz lo b">performFollowUpOperation</code>接受一个参数(<code class="eh lx ly lz lo b">resolvedValue</code>)，该参数由<code class="eh lx ly lz lo b">functionWithDelay</code>提供。这里有很多东西要打开。暂停，重读上一段(如果你愿意的话)。</p><p id="b487" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">总而言之:</p><ol class=""><li id="6a30" class="mb mc hu jt b ju jv jx jy ka md ke me ki mf km mg mh mi mj dt translated">用next函数定义一个函数。</li></ol><p id="ebca" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">2.定义一个具有延迟的函数，该函数返回一个具有下一个函数的函数(<code class="eh lx ly lz lo b">functionWithDelay</code>)</p><p id="2613" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">3.带<code class="eh lx ly lz lo b">next </code>函数的函数需要带另一个函数作为参数。在延迟功能完成之前，不能执行该后续功能。(<code class="eh lx ly lz lo b">performFollowUpOperation</code>)</p><p id="d157" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">4.具有延迟的函数必须以某种方式向后续函数传递一个值。</p><p id="c476" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">所以现在我们需要填充<code class="eh lx ly lz lo b">functionWithDelay</code>，首先我们需要定义那个有<code class="eh lx ly lz lo b">next </code>功能的东西。</p><h2 id="fc8e" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ka ky kz la ke lb lc ld ki le lf lg lh dt translated">第一次尝试</h2><p id="0d54" class="pw-post-body-paragraph jr js hu jt b ju li iv jw jx lj iy jz ka lk kc kd ke ll kg kh ki lm kk kl km hn dt translated">让我们做第一次尝试。</p><pre class="jk jl jm jn fq ln lo lp lq aw lr dt"><span id="6c54" class="kn ko hu lo b fv ls lt l lu lv"> 1: function FunctionWithAThenFunction() {<br/> 2:  this.then = function (followUpFunction) {<br/> 3:     followUpFunction()<br/> 4:   }<br/> 5: }</span><span id="c39c" class="kn ko hu lo b fv ma lt l lu lv"> 6: function functionWithDelay(param1) {<br/> 7:   let xhr = new XMLHttpRequest()<br/> 8:   xhr.onreadystatechange = () =&gt; {<br/> 9:     if (xhr.readyState == 200) callback(xhr.responseText)<br/>10:   }<br/>11:   xhr.open(param1)<br/>12:   xhr.send()<br/>13:   return new FunctionWithAThenFunction()<br/>14: }</span></pre><p id="6444" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">好的，我们有一个带有<code class="eh lx ly lz lo b">then</code>函数的函数。我们的<code class="eh lx ly lz lo b">functionWithDelay </code>用<code class="eh lx ly lz lo b">then</code>函数返回一个函数。酪9号线<code class="eh lx ly lz lo b">callback</code>是什么？不知何故，T8应该在回调中结束。这是不可能的。因此，<code class="eh lx ly lz lo b">followUpFunction </code>将立即执行，而不是等到<code class="eh lx ly lz lo b">functionWithDelay </code>完成。</p><p id="57e2" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我们如何让那个<code class="eh lx ly lz lo b">followUpFunction </code>成为<code class="eh lx ly lz lo b">callback</code>？</p><h2 id="ad57" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ka ky kz la ke lb lc ld ki le lf lg lh dt translated">第二次尝试</h2><p id="ec03" class="pw-post-body-paragraph jr js hu jt b ju li iv jw jx lj iy jz ka lk kc kd ke ll kg kh ki lm kk kl km hn dt translated">我们来看看<code class="eh lx ly lz lo b">functionWithDelay</code>。延迟函数的特征是什么？或者说异步函数的特征是什么？他们通常会以某种方式进行回调。因此，让我们试着将该函数重写为接受回调，这样我们就可以轻松地访问回调。</p><p id="b631" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">然后让我们重写我们的<code class="eh lx ly lz lo b">FunctionWithAThenFunction </code>,让它接受一个函数，更确切地说是一个带回调的异步函数。</p><pre class="jk jl jm jn fq ln lo lp lq aw lr dt"><span id="f9ba" class="kn ko hu lo b fv ls lt l lu lv">1: function FunctionWithAThenFunction(aFnWithDelayAndACallback){<br/> 2:   let nextThingToDo<br/> 3:   this.then = function ( followUpFunction) {<br/> 4:     nextThingToDo = followUpFunction<br/> 5:   }<br/> 6:   aFnWithDelayAndACallback( nextThingToDo )<br/> 7: }<br/> 8: function functionWithDelay(param1) {<br/> 9:   const httpRequestWithCallback = function (callback) {<br/>10:     let xhr = XMLHttpRequest()<br/>11:     xhr.onreadystatechange = () =&gt; {<br/>12:       if (xhr.readyState == 200) callback(xhr.responseText)<br/>13:     }<br/>14:     xhr.open(param1)<br/>15:     xhr.send()<br/>16:   }<br/>17:   return new FunctionWithAThenFunction(httpRequestWithCallback)<br/>18: }<br/>19: functionWithDelay('some argument').then(console.log)</span></pre><p id="17fb" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">第1–7行定义了我们的<code class="eh lx ly lz lo b">FunctionWithAThenFunction</code>。这是延迟函数返回的函数。它需要一个函数作为参数。更确切地说是带有回调的函数。然后，<code class="eh lx ly lz lo b">then</code>函数在一个局部变量中设置回调函数(<code class="eh lx ly lz lo b">nextThingToDo</code>)。这个函数实际上做了一件事，那就是用回调函数调用这个函数，在我们的例子中是标记为<code class="eh lx ly lz lo b">aFnWithDelayAndACallback</code>的函数。</p><p id="28ea" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">第8–18行定义了我们的<code class="eh lx ly lz lo b">functionWithDelay</code>。在我们的例子中，这个函数执行一个<code class="eh lx ly lz lo b">http </code>请求，并使用一个<code class="eh lx ly lz lo b">then</code>函数返回一些东西。具有<code class="eh lx ly lz lo b">then</code>功能的东西是<code class="eh lx ly lz lo b">FunctionWithAThenFunction</code>的新实例。它看起来和我们上面做的有点不同。我们创建一个新的名为<code class="eh lx ly lz lo b">httpRequestWithCallback</code>的本地临时函数，它接受一个回调参数，并包装前面示例中的整个<code class="eh lx ly lz lo b">XMLHttpRequest </code>代码。然后，这个新的局部函数作为参数传递给<code class="eh lx ly lz lo b">FunctionWithAThenFunction</code>。</p><p id="e8cb" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">现在，如果您尝试运行这个代码(第19行)，它仍然不能完成我们想要做的事情。如果你继续下去，你会看到在我们有机会给它赋值之前，我们称之为<code class="eh lx ly lz lo b">nextThingToDo </code>的是<code class="eh lx ly lz lo b">undefined </code>。我们缺少一样东西，那就是某种地位。</p><h2 id="a9d9" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ka ky kz la ke lb lc ld ki le lf lg lh dt translated">第三次尝试</h2><p id="72f7" class="pw-post-body-paragraph jr js hu jt b ju li iv jw jx lj iy jz ka lk kc kd ke ll kg kh ki lm kk kl km hn dt translated">让我们添加一个跟踪执行状态的变量。</p><pre class="jk jl jm jn fq ln lo lp lq aw lr dt"><span id="737f" class="kn ko hu lo b fv ls lt l lu lv">1: function FunctionWithAThenFunction(aFnWithDelayAndACallback){<br/> 2:   let nextThingToDo<br/> 3:   let status = 'pending'<br/> 4:   this.then = function ( followUpFunction) {<br/> 5:     if (status === 'pending') {<br/> 6:       nextThingToDo = followUpFunction<br/> 7:     }<br/> 8:     else {<br/> 9:       followUpFunction()<br/>10:     }<br/>11:   }<br/>12:   aFnWithDelayAndACallback( (newValue) =&gt; { <br/>13:      status = 'resolved'<br/>14:      nextThingToDo(newValue)<br/>15:   })<br/>16: }<br/>17: function functionWithDelay(param1) {<br/>18:   const httpRequestWithCallback = function (callback) {<br/>19:     let xhr = XMLHttpRequest()<br/>20:     xhr.onreadystatechange = () =&gt; {<br/>21:       if (xhr.readyState == 200) callback(xhr.responseText)<br/>22:     }<br/>23:     xhr.open(param1)<br/>24:     xhr.send()<br/>25:   }<br/>26:   return new FunctionWithAThenFunction(httpRequestWithCallback)<br/>27: }<br/>28: functionWithDelay('some argument').then(console.log)</span></pre><p id="603c" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">您会看到我们声明了一个<code class="eh lx ly lz lo b">status </code>变量(第3行)。这样我们就覆盖了所有的基础。如果在主函数完成之前调用了<code class="eh lx ly lz lo b">then</code>，我们将<code class="eh lx ly lz lo b">followUpFunction </code>存储在一个变量中，如果没有，我们可以安全地执行它。但是它没有主函数的值。让我们解决这个问题。</p><pre class="jk jl jm jn fq ln lo lp lq aw lr dt"><span id="9069" class="kn ko hu lo b fv ls lt l lu lv">1: function FunctionWithAThenFunction(aFnWithDelayAndACallback){<br/> 2:   let nextThingToDo, value<br/> 3:   let status = 'pending'<br/> 4:   this.then = function ( followUpFunction) {<br/> 5:     if (status === 'pending') {<br/> 6:       nextThingToDo = followUpFunction<br/> 7:     }<br/> 8:     else {<br/> 9:       followUpFunction(value)<br/>10:     }<br/>11:   }<br/>12:   aFnWithDelayAndACallback( (newValue) =&gt; { <br/>13:      status = 'resolved'<br/>14:      value = newValue<br/>15:      nextThingToDo(newValue)<br/>16:   })<br/>17: }<br/>18: function functionWithDelay(param1) {<br/>19:   const httpRequestWithCallback = function (callback) {<br/>20:     let xhr = XMLHttpRequest()<br/>21:     xhr.onreadystatechange = () =&gt; {<br/>22:       if (xhr.readyState == 200) callback(xhr.responseText)<br/>23:     }<br/>24:     xhr.open(param1)<br/>25:     xhr.send()<br/>26:   }<br/>27:   return new FunctionWithAThenFunction(httpRequestWithCallback)<br/>28: }<br/>29: functionWithDelay('some argument').then(console.log)</span></pre><p id="ff12" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">这里我们声明一个名为<code class="eh lx ly lz lo b">value</code>的新局部变量。(第2行)当我们解析main函数时，我们设置这个值。因此它可以作为参数传递给第9行的<code class="eh lx ly lz lo b">followUpFunction</code>。</p><p id="978e" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">说到解决，为了清楚起见，让我们添加重写这个。与以前的示例相比，功能没有变化。</p><pre class="jk jl jm jn fq ln lo lp lq aw lr dt"><span id="f753" class="kn ko hu lo b fv ls lt l lu lv">1: function FunctionWithAThenFunction(aFnWithDelayAndACallback){<br/> 2:   let nextThingToDo, value<br/> 3:   let status = 'pending'<br/> 4:   this.then = function ( followUpFunction) {<br/> 5:     if (status === 'pending') {<br/> 6:       nextThingToDo = followUpFunction<br/> 7:     }<br/> 8:     else {<br/> 9:       followUpFunction(value)<br/>10:     }<br/>11:   }<br/>12:   const resolve = newValue =&gt; {<br/>13:     value = newValue<br/>14:     status = 'resolved'<br/>15:     if (nextThingToDo) nextThingToDo(newValue)<br/>16:   }<br/>17:   aFnWithDelayAndACallback(resolve)<br/>17: }<br/>18: function functionWithDelay(param1) {<br/>19:   const httpRequestWithCallback = function (callback) {<br/>20:     let xhr = XMLHttpRequest()<br/>21:     xhr.onreadystatechange = () =&gt; {<br/>22:       if (xhr.readyState == 200) callback(xhr.responseText)<br/>23:     }<br/>24:     xhr.open(param1)<br/>25:     xhr.send()<br/>26:   }<br/>27:   return new FunctionWithAThenFunction(httpRequestWithCallback)<br/>28: }<br/>29: functionWithDelay('some argument').then(console.log)</span></pre><p id="2ae7" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">这里，为了清楚起见，我们在第12–16行引入了局部解析函数。它随后在第17行被调用。</p><h2 id="28ac" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ka ky kz la ke lb lc ld ki le lf lg lh dt translated">把所有的放在一起</h2><p id="5224" class="pw-post-body-paragraph jr js hu jt b ju li iv jw jx lj iy jz ka lk kc kd ke ll kg kh ki lm kk kl km hn dt translated">我们已经走了很长一段路。让我们再写一遍上一个例子，并稍微改变一下函数名。</p><ul class=""><li id="30f5" class="mb mc hu jt b ju jv jx jy ka md ke me ki mf km mk mh mi mj dt translated"><code class="eh lx ly lz lo b">FunctionWithAThenFunction </code>变为<code class="eh lx ly lz lo b">Promise</code></li><li id="318d" class="mb mc hu jt b ju ml jx mm ka mn ke mo ki mp km mk mh mi mj dt translated"><code class="eh lx ly lz lo b">functionWithDelay </code>变为<code class="eh lx ly lz lo b">fetchData</code></li><li id="2410" class="mb mc hu jt b ju ml jx mm ka mn ke mo ki mp km mk mh mi mj dt translated"><code class="eh lx ly lz lo b">httpRequestWithCallback </code>变为<code class="eh lx ly lz lo b">httpRequest</code></li><li id="cc99" class="mb mc hu jt b ju ml jx mm ka mn ke mo ki mp km mk mh mi mj dt translated"><code class="eh lx ly lz lo b">aFnWithDelayAndACallback </code>成为<code class="eh lx ly lz lo b">fn</code></li></ul><pre class="jk jl jm jn fq ln lo lp lq aw lr dt"><span id="a18e" class="kn ko hu lo b fv ls lt l lu lv">function Promise(fn){<br/>   let nextThingToDo, value<br/>   let status = 'pending'<br/>   this.then = function ( callback ) {<br/>     if (status === 'pending') {<br/>       nextThingToDo = callback<br/>     }<br/>     else {<br/>       callback(value)<br/>     }<br/>   }<br/>   const resolve = newValue =&gt; {<br/>     value = newValue<br/>     status = 'resolved'<br/>     if (nextThingToDo) nextThingToDo(newValue)<br/>   }<br/>   fn(resolve)<br/> }<br/>function fetchData(url) {<br/>  const httpRequest = function (callback) {<br/>    let xhr = XMLHttpRequest()<br/>    xhr.onreadystatechange = () =&gt; {<br/>      if (xhr.readyState == 200) callback(xhr.responseText)<br/>    }<br/>    xhr.open(url)<br/>    xhr.send()<br/>  }<br/>  return new Promise(httpRequest)<br/>}</span><span id="bc77" class="kn ko hu lo b fv ma lt l lu lv">const testUrl = '<a class="ae lw" href="https://api.github.com/users/odemeulder" rel="noopener ugc nofollow" target="_blank">https://api.github.com/users/odemeulder</a>'<br/>fetchData(testUrl).then(console.log)</span></pre><p id="172a" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated"><code class="eh lx ly lz lo b">Promise </code>代码现在可用于其他功能。假设您想要一个类似于<code class="eh lx ly lz lo b">setTimeout </code>的函数来返回一个承诺。让我们调用函数<code class="eh lx ly lz lo b">Wait </code>，它将接受以毫秒为单位的延迟时间。</p><pre class="jk jl jm jn fq ln lo lp lq aw lr dt"><span id="9ffc" class="kn ko hu lo b fv ls lt l lu lv">function Wait(milliSeconds) {<br/>  const fn = (callback) =&gt; setTimeout(callback, milliSeconds)<br/>  return new Promise(fn)<br/>}<br/>Wait(5000).then(() =&gt; console.log('we waited 5 seconds'))</span></pre><p id="f729" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">或者假设您想在Node中使用<code class="eh lx ly lz lo b">httpRequest</code>示例。在Node <code class="eh lx ly lz lo b">XmlHttpRequest </code>中无法工作，因为那是浏览器提供的对象，你必须使用Node的内置<code class="eh lx ly lz lo b">https </code>模块。</p><pre class="jk jl jm jn fq ln lo lp lq aw lr dt"><span id="29d8" class="kn ko hu lo b fv ls lt l lu lv">const https = require('https')<br/>const testUrl = '<a class="ae lw" href="https://api.github.com/users/odemeulder" rel="noopener ugc nofollow" target="_blank">https://api.github.com/users/odemeulder</a>'<br/>function fetchDataForNode(url) {<br/>  const fn = callback =&gt; {<br/>    const options = {<br/>      url: url,<br/>      headers: { 'User-Agent': 'request' }<br/>    }<br/>    https.get(options, response =&gt; {<br/>      let ret<br/>      response.on('data', chunk =&gt; ret += chunk)<br/>      response.on('end', () =&gt; callback(ret))<br/>    })<br/>  return new Promise(fn)<br/>}<br/>fetchDataForNode(testUrl).then(console.log)</span></pre><p id="bbe3" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">同样，不要担心<code class="eh lx ly lz lo b">https.get</code>在node中如何工作的技术细节。重要的部分是:创建一个接受回调并包装异步调用的函数，并将该函数传递给你的<code class="eh lx ly lz lo b">Promise </code>构造函数。</p><h2 id="de4b" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ka ky kz la ke lb lc ld ki le lf lg lh dt translated">后续步骤</h2><p id="32e9" class="pw-post-body-paragraph jr js hu jt b ju li iv jw jx lj iy jz ka lk kc kd ke ll kg kh ki lm kk kl km hn dt translated">很明显，承诺远不止我们刚刚概述的内容。这篇文章已经够长了。但是这里有一些改进/补充。</p><p id="f468" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">一件事是<code class="eh lx ly lz lo b">then</code>函数应该返回一个新的承诺。这让你可以连锁承诺。<code class="eh lx ly lz lo b">doSomething().then(somethingElse).then(aThirdThing)</code></p><p id="7570" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">另一件我们没有涉及的大事是错误处理。我们的<code class="eh lx ly lz lo b">Promise </code>函数也应该实现一个<code class="eh lx ly lz lo b">catch </code>函数。该函数将一个函数作为参数，如果有任何错误，将调用该函数。</p><h2 id="a71c" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ka ky kz la ke lb lc ld ki le lf lg lh dt translated">结论</h2><p id="2321" class="pw-post-body-paragraph jr js hu jt b ju li iv jw jx lj iy jz ka lk kc kd ke ll kg kh ki lm kk kl km hn dt translated">我们创建了一个非常基本的promise对象，我向您展示了如何创建一个返回Promise的函数的三个示例(<code class="eh lx ly lz lo b">fetchData </code>用于浏览器http请求，<code class="eh lx ly lz lo b">fetchDataForNode </code>用于Node中的http请求，<code class="eh lx ly lz lo b">wait</code>)。在每种情况下，您创建一个接受回调的函数，创建一个新的<code class="eh lx ly lz lo b">Promise </code>函数并将该函数作为回调传递。</p><p id="15f6" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我欢迎任何反馈和掌声。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mq mr l"/></div></figure></div></div>    
</body>
</html>