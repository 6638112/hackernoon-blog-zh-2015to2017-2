<html>
<head>
<title>How to Implement Key Authentication in Express Gateway</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在快递网关中实现密钥认证</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-implementing-key-authentication-in-express-gateway-4c9a87221e65?source=collection_archive---------5-----------------------#2017-08-03">https://medium.com/hackernoon/how-to-implementing-key-authentication-in-express-gateway-4c9a87221e65?source=collection_archive---------5-----------------------#2017-08-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="bc50" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由<a class="ae jp" href="https://jordankasper.com/" rel="noopener ugc nofollow" target="_blank">乔丹·卡斯帕</a></p><p id="f26e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以，你可能以前用过:密钥认证。基本思想很简单，用给定的服务认证你的应用或客户端，你发送一个密钥来识别(和授权)你自己。此外，这并不一定是针对单个用户的，而是针对系统之间的相互对话。(需要明确的是，对于验证自己身份的用户，您可能需要查看OAuth2，这也是Express Gateway提供的功能。)</p><p id="533c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本文中，我将向您展示如何使用Express Gateway (EG)快速轻松地启动和运行密钥认证。我们将讨论如何设置和配置您的网关、创建凭证以及发送经过身份验证的请求。这是一个简单的介绍，所以在部署API网关之前，请务必阅读文档并进行测试！</p><h1 id="bf6a" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">创建和配置网关</h1><p id="f3de" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">第一步可能是生成一个新的Express Gateway实例。(如果您已经这样做了，请随意跳过这一步。)您需要首先安装<code class="eh kt ku kv kw b">express-gateway</code>包，然后生成一个新的网关:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="1a86" class="lf jr hu kw b fv lg lh l li lj">~$ npm i -g express-gateway</span><span id="5857" class="lf jr hu kw b fv lk lh l li lj">~$ eg gateway create<br/> ? What's the name of your Express Gateway? widget-factory<br/> ? Where would you like to install your Express Gateway? widget-factory<br/> ? What type of Express Gateway do you want to create? Getting Started with Express Gateway<br/> created package.json<br/> created server.js</span><span id="d381" class="lf jr hu kw b fv lk lh l li lj">...</span><span id="bb8f" class="lf jr hu kw b fv lk lh l li lj">To start widget-factory, run the following commands:<br/> cd widget-factory &amp;amp;&amp;amp; npm start</span></pre><p id="bb11" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">太好了！在我们第一次启动网关之前，让我们继续进行配置。</p><h1 id="b383" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">网关配置</h1><p id="eb2a" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">Express Gateway在新项目的<code class="eh kt ku kv kw b">/config</code>目录中有两个主要的配置文件(加上模型配置):<code class="eh kt ku kv kw b">gateway.config.yml</code>文件和<code class="eh kt ku kv kw b">system.config.yml</code>文件。在系统配置文件中，您将设置数据库访问(针对网关，而不是您的单个微服务)等内容，以及OAuth2等内容的某些安全设置。我们今天不会在那个文件中工作(这也意味着我们的<strong class="it hv">用户和凭证不会被保存</strong>。</p><p id="5acf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">网关配置文件是配置HTTP、端点、策略(如密钥认证)和管道(只是应用于某些端点的一系列策略)的地方。默认生成的配置文件在<code class="eh kt ku kv kw b">/ip</code>为网关创建了一个API端点，并将这些请求代理给&lt;https://httpbin.org/ip&gt;——您稍后会想要更改它，但我们现在将它保留下来。我们需要做的是向“api-basic”管道添加一个策略(这里唯一的一个)。</p><p id="aa4e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<code class="eh kt ku kv kw b">gateway.config.yml</code>文件中找到您的“pipelines”块，使它看起来像这样:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="5baa" class="lf jr hu kw b fv lg lh l li lj">pipelines:<br/> - name: api-basic<br/> apiEndpoints:<br/> - api<br/> policies:<br/> - key-auth: ## This line is new!!<br/> - proxy:<br/> - action:<br/> serviceEndpoint: httpbin<br/> changeOrigin: true</span></pre><p id="e655" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，我们在“代理”策略之前添加了“密钥授权”策略。每个管道中的策略都是按顺序排序的，所以一定要按照您希望的顺序来执行。在我们的例子中，如果认证失败，我们应该<em class="ll">而不是</em>代理API请求。</p><p id="f7ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">信不信由你，这是您需要对我们的演示网关进行的唯一的<em class="ll">更改，以启用密钥认证！您可以通过启动网关并向<code class="eh kt ku kv kw b">/ip</code>(或任何其他端点)发出一个简单的<code class="eh kt ku kv kw b">GET</code>请求来测试这一点:</em></p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="cf25" class="lf jr hu kw b fv lg lh l li lj">~/widget-factory$ npm start</span></pre><p id="bad3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以使用cURL或者类似于<a class="ae jp" href="https://www.getpostman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>的工具(我强烈推荐用于API开发)来测试HTTP请求。下面是使用cURL可能得到的响应:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="2a76" class="lf jr hu kw b fv lg lh l li lj">~$ curl -D - "http://localhost:8080/ip"<br/> HTTP/1.1 401 Unauthorized<br/> X-Powered-By: Express<br/> Content-Type: text/html; charset=utf-8<br/> Content-Length: 9<br/> ETag: W/"9-PatfYBLj4Um1qTm5zrukoLhNyPU"<br/> Date: Sun, 16 Jul 2017 19:37:52 GMT<br/> Connection: keep-alive</span><span id="8f30" class="lf jr hu kw b fv lk lh l li lj">Forbidden</span></pre><p id="7c75" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，我们的响应代码是<code class="eh kt ku kv kw b">401</code>，因为我们发送的是<em class="ll">而不是</em>API密钥。稍后我们将更多地讨论这些状态代码，但是现在让我们创建一个API键。</p><h1 id="a7e3" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">正在生成密钥凭据</h1><p id="cefb" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们创建API键的第一步是在系统中创建一个“用户”。打开另一个终端窗口，导航到您的网关项目目录。现在，我们可以使用与生成网关相同的<code class="eh kt ku kv kw b">eg</code>命令来创建凭证:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="cfac" class="lf jr hu kw b fv lg lh l li lj">~/widget-factory$ eg users create<br/> ? Enter username [required]: jordan<br/> ? Enter firstname [required]: Jordan<br/> ? Enter lastname [required]: Kasper<br/> ? Enter email: jordan@widgets-r-us.com<br/> ? Enter redirectUri:<br/> ✔ Created jordan</span></pre><p id="3aa6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我在这里把<code class="eh kt ku kv kw b">redirectUri</code>留为空白，因为我们不在密钥认证中使用它，但是你可能需要其他方案。现在我们有了一个用户，可以为该用户创建一个“应用程序”，然后创建“凭据”，或者我们可以只为用户自己创建“凭据”。我现在做第二个选择:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="5784" class="lf jr hu kw b fv lg lh l li lj">~/widget-factory$ eg credentials create -c jordan -t key-auth<br/> ✔ Created<br/> {<br/> "isActive": true,<br/> "createdAt": "Sun Jul 16 2017 15:48:48 GMT-0400 (EDT)",<br/> "updatedAt": "Sun Jul 16 2017 15:48:48 GMT-0400 (EDT)",<br/> "keyId": "0J6961Lhn8JgxYybTXFdRg",<br/> "keySecret": "23BfI6QVqgdxP3ty8F4Jx3",<br/> "scopes": null,<br/> "consumerId": "jordan"<br/> }</span></pre><p id="2a0c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就是这样！注意，上面的输出显示出了<code class="eh kt ku kv kw b">"keyId"</code>和<code class="eh kt ku kv kw b">"keySecret"</code>。这两部分一起为系统创建了最终的API密匙。</p><h1 id="5957" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">发送经过身份验证的请求</h1><p id="85b8" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">现在我们有了一些凭证，我们可以向我们的API发送更多的请求(通过我们的网关)。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="e1fe" class="lf jr hu kw b fv lg lh l li lj">~$ curl -H "Authorization: apiKey 0J6961Lhn8JgxYybTXFdRg:23BfI6QVqgdxP3ty8F4Jx3" -I "http://localhost:8080/ip"<br/> HTTP/1.1 200 OK<br/> x-powered-by: Flask<br/> connection: close<br/> server: meinheld/0.6.1<br/> date: Sun, 16 Jul 2017 19:54:49 GMT<br/> content-type: text/html; charset=utf-8<br/> content-length: 12793<br/> access-control-allow-origin: *<br/> access-control-allow-credentials: true<br/> x-processed-time: 0.00561594963074<br/> via: 1.1 vegur</span></pre><p id="648d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上面有两点需要注意:首先，我们得到了一个<code class="eh kt ku kv kw b">200</code>响应！太好了，这意味着我们的认证检查通过了！那么我们是怎么做到的呢？我们发送了包含密钥的<code class="eh kt ku kv kw b">Authorization</code>报头。记住，我们的密钥由两部分组成。所以你可以看到上面的<code class="eh kt ku kv kw b">Authorization</code>头值实际上是由冒号(“:”)分隔的两条信息。此外，我们用我们的头方案“apiKey”作为该值的前缀。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="e74a" class="lf jr hu kw b fv lg lh l li lj">Authorization: apiKey 0J6961Lhn8JgxYybTXFdRg:23BfI6QVqgdxP3ty8F4Jx3</span><span id="c6a2" class="lf jr hu kw b fv lk lh l li lj">header name : scheme keyId : keySecret</span></pre><h1 id="dc8b" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">状态代码</h1><p id="e820" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">正如您在上面看到的，我们得到了一个<code class="eh kt ku kv kw b">200</code>响应状态代码，意味着成功！那个状态代码实际上来自我们的API服务(在这个例子中是httpbin.org)<em class="ll">而不是来自我们的网关</em>。例如，如果您请求一个在该服务上不存在的资源，您应该收到一个<code class="eh kt ku kv kw b">404</code>。当密钥没有通过认证或者完全丢失时，网关将发送回一个<code class="eh kt ku kv kw b">401</code>。但是如果用户通过了身份验证，但没有被授权使用给定的资源，它也可以发送回一个<code class="eh kt ku kv kw b">403</code>。如果您使用“范围”,这可能会发生。</p><h1 id="1985" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">什么是范围？</h1><p id="c7dd" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在这篇博文中，我们不会深入讨论作用域，但是作用域是在Express Gateway中指定授权的主要实体。范围只是添加到网关配置中的预定义字符串(在API端点上，然后在该端点的管道中的策略上)。API端点通过指定范围来保护。要获得受范围保护的API端点的授权，使用者必须拥有包含API端点上列出的范围的凭据。换句话说，端点上的范围必须与用户(或应用程序)的密钥凭证上的范围相匹配。</p><h1 id="4427" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">附加配置</h1><p id="6bce" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">您可以将更多选项添加到您的网关“key-auth”策略中，以进一步保护它或简单地定制它。例如，默认情况下，网关将接受头和查询字符串中的键。您可以使用<code class="eh kt ku kv kw b">disableQueryParam</code>选项轻松禁用此功能:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="49fc" class="lf jr hu kw b fv lg lh l li lj">pipelines:<br/> - name: api-basic<br/> apiEndpoints:<br/> - api<br/> policies:<br/> - key-auth:<br/> - disableQueryParam: true ## Disable API keys in the query string<br/> - proxy:<br/> - action:<br/> serviceEndpoint: httpbin<br/> changeOrigin: true</span></pre><p id="d15e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您还可以更改用于身份验证的标头(尽管这将违反当前标准)或使用的方案:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="4db5" class="lf jr hu kw b fv lg lh l li lj">pipelines:<br/> - name: api-basic<br/> apiEndpoints:<br/> - api<br/> policies:<br/> - key-auth:<br/> - apiKeyHeader: "X-My-Auth-Header"<br/> - apiKeyHeaderScheme: "key-pair"<br/> - proxy:<br/> - action:<br/> serviceEndpoint: httpbin<br/> changeOrigin: true</span></pre><p id="1961" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您使用上面的配置，您需要修改在所有经过身份验证的API请求中发送的报头，如下所示:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="ff7a" class="lf jr hu kw b fv lg lh l li lj">~$ curl -H "X-My-Auth-Header: key-pair 0J6961Lhn8JgxYybTXFdRg:23BfI6QVqgdxP3ty8F4Jx3" -I "http://localhost:8080/ip"</span></pre><h1 id="76fb" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">管理密钥凭据</h1><p id="1b6f" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们这篇文章的最后一个主题是关于管理你生成的那些密钥。您可能会发现需要取消用户访问权限的时候。这可以通过在命令行中停用他们的凭据来轻松实现:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="82d2" class="lf jr hu kw b fv lg lh l li lj">~$ eg credentials deactivate -t key-auth 0J6961Lhn8JgxYybTXFdRg<br/> ✔ Deactivated 0J6961Lhn8JgxYybTXFdRg</span></pre><p id="7ef7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">执行此操作后，给定的<code class="eh kt ku kv kw b">keyId</code>将不再在网关中被认证。这是<em class="ll">而不是</em>一个永久的动作，并且凭证可以很容易地用伴随的<code class="eh kt ku kv kw b">activate</code>子命令重新激活:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="758e" class="lf jr hu kw b fv lg lh l li lj">~$ eg credentials activate -t key-auth 0J6961Lhn8JgxYybTXFdRg<br/> ✔ Activated 0J6961Lhn8JgxYybTXFdRg</span></pre><h1 id="266c" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">包扎</h1><p id="4e0d" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">API网关可以为您做的最大的事情之一是为您的各种微服务集中认证。Express Gateway使这一过程变得非常简单。看一下<a class="ae jp" href="http://www.express-gateway.io/documentation" rel="noopener ugc nofollow" target="_blank">文档</a>试试看！</p><p id="0483" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">查看<strong class="it hv"/><a class="ae jp" href="http://www.express-gateway.io" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">Express Gateway</strong></a><strong class="it hv"/>成为这个完全基于Express.js构建的新开源API网关的贡献者或维护者</p></div></div>    
</body>
</html>