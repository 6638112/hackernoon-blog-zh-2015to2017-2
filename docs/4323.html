<html>
<head>
<title>Why is Marko Fast?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么马尔科很快？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/why-is-marko-fast-a20796cb8ae3?source=collection_archive---------6-----------------------#2017-05-25">https://medium.com/hackernoon/why-is-marko-fast-a20796cb8ae3?source=collection_archive---------6-----------------------#2017-05-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/94c5d9586d7e6723430e15cd3b4ce206.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QR3HJxrZnSPxhc33re7vew.png"/></div></div></figure><p id="9415" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在易贝，我们每天使用<a class="ae ka" href="http://markojs.com/" rel="noopener ugc nofollow" target="_blank"> Marko </a>来提交超过10亿个请求，这要求我们对我们的开源UI库Marko进行微调。我们对快速渲染的Marko、<a class="ae ka" href="http://www.ebaytechblog.com/2014/12/08/async-fragments-rediscovering-progressive-html-rendering-with-marko/" rel="noopener ugc nofollow" target="_blank">高级性能技术</a>进行了大量优化，以实现最小的页面重量(约10kb gzipped)。性能只是一个问题，因为我们还必须扩展Marko来支持跨越数百个团队的开发，以允许开发人员高效地创建可维护和健壮的web应用程序。</p><p id="1977" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们已经创造了<a class="ae ka" href="https://github.com/marko-js/isomorphic-ui-benchmarks" rel="noopener ugc nofollow" target="_blank">我们自己的基准</a>，我们已经<a class="ae ka" href="https://github.com/raxjs/server-side-rendering-comparison/pull/11" rel="noopener ugc nofollow" target="_blank">将Marko添加到其他基准</a>中，但是基准并不总是可信的。虽然我们尽一切努力公平对待我们的基准，但最重要的是现实应用中的性能，而不是关注微观基准。这是V8团队转向<a class="ae ka" href="https://v8project.blogspot.com/2016/12/how-v8-measures-real-world-performance.html" rel="noopener ugc nofollow" target="_blank">一种新的方法来衡量和理解真实世界的JavaScript性能</a>的原因之一。</p><p id="fb97" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">类似地，我们看了看我们的开发人员是如何<em class="kb">实际上</em>编写他们的Marko组件的，并且发现了可以进一步优化的模式。在这篇文章中，我不想把重点放在基准测试上，而是想把重点放在我们对Marko应用的优化的细节上。</p><h1 id="c08c" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">多个编译输出</h1><p id="d458" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">Marko是一个同构的UI库，既可以在服务器上运行，也可以在浏览器中运行。正如<a class="lf lg gr" href="https://medium.com/u/9d30414878d1?source=post_page-----a20796cb8ae3--------------------------------" rel="noopener" target="_blank"> Michael Rawlings </a>在“<a class="ae ka" href="https://hackernoon.com/server-side-rendering-shootout-with-marko-preact-rax-react-and-vue-25e1ae17800f" rel="noopener ugc nofollow" target="_blank">服务器端渲染枪战</a>”中提到的，当在服务器上渲染时，Marko直接渲染为文档的字符串表示(HTML)，可以作为HTTP响应发送。</p><p id="f7ad" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当在浏览器中呈现时，必须解析HTML字符串才能更新DOM。由于这个原因，Marko编译了一个程序的视图，该视图直接渲染到一个虚拟文档(VDOM)树，该树可用于在以浏览器为目标时有效地更新真实的DOM。</p><p id="96e9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">给定以下模板:</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div></figure><h2 id="ba6b" class="ln kd hu bd ke lo lp lq ki lr ls lt km jn lu lv kq jr lw lx ku jv ly lz ky ma dt translated">为服务器编译</h2><p id="c579" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">编译后的输出为服务器上的流<a class="ae ka" href="https://hackernoon.com/tagged/html" rel="noopener ugc nofollow" target="_blank"> HTML </a>输出进行了优化:</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div></figure><h2 id="d260" class="ln kd hu bd ke lo lp lq ki lr ls lt km jn lu lv kq jr lw lx ku jv ly lz ky ma dt translated">为浏览器编译</h2><p id="35aa" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">编译后的输出针对浏览器中的虚拟DOM呈现进行了优化:</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div></figure><h1 id="7a5e" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">模块化运行时</h1><p id="de6f" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">Marko运行时并不是作为一个单独的<a class="ae ka" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>文件发布的。相反，Marko编译器生成一个JavaScript模块，该模块只导入运行时中实际需要的部分。这允许我们在不增加现有应用程序的情况下向Marko添加新功能。例如，给定以下模板:</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="2d0f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在上面的例子中，需要额外的运行时代码来根据提供的JavaScript对象呈现<code class="eh mb mc md me b">style</code>属性。导入<code class="eh mb mc md me b">styleAttr</code>助手的编译代码如下所示:</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div></figure><h1 id="04af" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">高性能服务器端渲染</h1><p id="130d" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">与基于JSX的专门进行虚拟DOM渲染的解决方案相比，Marko在服务器端渲染方面有着巨大的优势。当渲染到服务器上的虚拟DOM树时，渲染HTML需要两个步骤:</p><ul class=""><li id="49db" class="mf mg hu je b jf jg jj jk jn mh jr mi jv mj jz mk ml mm mn dt translated">在内存中生成整个虚拟DOM树的第一步</li><li id="6941" class="mf mg hu je b jf mo jj mp jn mq jr mr jv ms jz mk ml mm mn dt translated">第二步是将虚拟DOM树序列化为HTML字符串，然后可以通过网络发送(这需要遍历整个树结构)</li></ul><p id="ece5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">相比之下，Marko只需一次操作就可以直接渲染成HTML流。没有中间树数据结构。</p><h1 id="c4be" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">静态子树的编译时优化</h1><p id="93af" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">给定以下模板:</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="cf81" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Marko将认识到模板片段每次都产生相同的输出，因此它将创建一次虚拟DOM节点，如以下编译后的输出所示:</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="63c9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">渲染静态子树的成本几乎为零。此外，Marko将跳过区分/修补静态子树。</p><p id="1be6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">类似地，在服务器上，Marko将把模板的静态部分合并成一个字符串:</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div></figure><h1 id="8e8d" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">静态属性的编译时优化</h1><p id="d263" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">Marko还会优化动态元素上的静态属性。</p><p id="0f89" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">给定以下模板:</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="1522" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Marko将生成以下编译后的输出:</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="632f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，属性对象仅创建一次，并且用于每次渲染。此外，静态属性不会发生差异/修补。</p><h1 id="458c" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">智能编译器</h1><p id="dcfe" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">对于Marko，我们倾向于在编译时做尽可能多的事情。这使得我们的编译器更加复杂，但是它在运行时给了我们很大的好处。我们有大约90%的代码覆盖率和超过2000次测试，以确保编译器正常工作。此外，在许多情况下，Marko编译器为给定模板的运行时提供提示，以便运行时可以针对特定模式进行优化。例如，Marko识别HTML元素是否仅定义了<code class="eh mb mc md me b">class</code> / <code class="eh mb mc md me b">id</code> / <code class="eh mb mc md me b">style</code>，并且在进行区分/修补时，运行时针对这些虚拟DOM节点进行优化(Marko编译器生成代码，为目标区分/修补逻辑标记简单的虚拟DOM节点)。</p><h1 id="c071" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">事件委托</h1><p id="be13" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">如果你正在构建一个UI组件，你可能需要编写代码来处理各种DOM事件(<code class="eh mb mc md me b">click</code>、<code class="eh mb mc md me b">submit</code>等)。).开发人员通常使用<code class="eh mb mc md me b">el.addEventListener(...)</code>或jQuery之类的库来编写添加DOM事件侦听器的代码。在使用Marko构建UI组件时，您仍然可以这样做，但是在初始化大量组件时，附加侦听器会产生开销。相反，Marko建议使用如下所示的声明性事件绑定:</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="76b3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当使用声明性事件绑定时，实际上没有为冒泡事件附加任何DOM事件侦听器。相反，Marko为每个冒泡的DOM事件在页面的根DOM元素上附加一个监听器(在启动时完成)。当Marko在根处接收到一个事件时，它处理将该事件委托给对该事件感兴趣的适当组件。这是通过查看<code class="eh mb mc md me b">event.target</code>属性来查看事件的来源，然后沿着树向上查找需要通知的组件来完成的。因此，当在根位置捕获DOM事件时，要做的工作稍微多一些，但是这种方法使用的内存要少得多，并且减少了初始化过程中的工作量。将事件委托给组件的额外开销不会很明显，因此这是一个非常有益的优化。</p></div><div class="ab cl mt mu hc mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="hn ho hp hq hr"><p id="cbf4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有兴趣了解更多关于Marko的信息吗？如果是这样，您可以在<a class="ae ka" href="http://markojs.com/" rel="noopener ugc nofollow" target="_blank"> Marko网站</a>上获得更多信息。加入对话，在<a class="ae ka" href="https://github.com/marko-js/marko" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上投稿，在<a class="ae ka" href="https://twitter.com/MarkoDevTeam" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我们。</p></div><div class="ab cl mt mu hc mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="hn ho hp hq hr"><p id="cc0a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="kb">封面图片鸣谢:</em> <a class="ae ka" href="https://thenounproject.com/search/?q=superhero&amp;i=990792" rel="noopener ugc nofollow" target="_blank"> <em class="kb">超级英雄由Zech Nelson从名词项目</em> </a></p><div class="lh li lj lk fq ab cb"><figure class="na iv nb nc nd ne nf paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="na iv nb nc nd ne nf paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="na iv nb nc nd ne nf paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ng nh ni"><p id="f922" class="jc jd kb je b jf jg jh ji jj jk jl jm nj jo jp jq nk js jt ju nl jw jx jy jz hn dt translated"><a class="ae ka" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ka" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ka" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ka" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd kb je b jf jg jh ji jj jk jl jm nj jo jp jq nk js jt ju nl jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ka" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ka" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lh li lj lk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nm"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="nn lm l"/></div></figure></div></div>    
</body>
</html>