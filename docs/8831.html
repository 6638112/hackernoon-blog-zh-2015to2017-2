<html>
<head>
<title>AlloyCI Dev Diary — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">合金开发日记—第二部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/alloyci-dev-diary-part-2-6a61b02faca8?source=collection_archive---------15-----------------------#2017-12-16">https://medium.com/hackernoon/alloyci-dev-diary-part-2-6a61b02faca8?source=collection_archive---------15-----------------------#2017-12-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="c7de" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">构建一个新的凤凰项目</h1><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/bda701d4c082c11567ccdbfe80710dd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I4a6MOBxYhgQsBRcwbShRw.jpeg"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Photo by <a class="ae kf" href="https://unsplash.com/photos/RkJF2BMrLJc?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">William Bout</a> on <a class="ae kf" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="28e7" class="pw-post-body-paragraph kg kh hu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hn dt translated">这篇博客文章是详述<a class="ae kf" href="https://hackernoon.com/tagged/alloyci" rel="noopener ugc nofollow" target="_blank"> AlloyCI </a>的<a class="ae kf" href="https://hackernoon.com/tagged/development" rel="noopener ugc nofollow" target="_blank">开发</a>过程的系列文章的一部分。之前的条目有:</p><ul class=""><li id="80d7" class="le lf hu ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm dt translated"><a class="ae kf" href="https://hackernoon.com/alloyci-dev-diary-part-1-8ae564fce9f3" rel="noopener ugc nofollow" target="_blank">第1部分:开始新项目</a></li></ul><p id="9993" class="pw-post-body-paragraph kg kh hu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hn dt translated">如果您来自Rails背景，您可能会发现Phoenix项目的文件夹结构有点奇怪，尤其是在1.3中的更改之后。但是不要因此而退缩，这个结构实际上很有意义，特别是新的1.3结构。</p><p id="01b9" class="pw-post-body-paragraph kg kh hu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hn dt translated">不像Rails，没有<code class="eh ln lo lp lq b">app/</code>文件夹来存放你的大部分代码。Phoenix 1.3项目遵循几乎所有常规Elixir项目的结构，这意味着您的大部分代码将位于<code class="eh ln lo lp lq b">lib/my_app</code>文件夹中。</p><p id="15ed" class="pw-post-body-paragraph kg kh hu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hn dt translated">正如你现在可能知道的，Phoenix 1.3改变了项目的结构。在这个改变之前，你的大部分代码都在<code class="eh ln lo lp lq b">web/</code>之下，几乎没有进一步的组织。你可以有一个<code class="eh ln lo lp lq b">models</code>目录，在那里你可以放置所有的业务逻辑，而不需要考虑它们是如何相互作用的。这个文件夹会变得很大，很快。另外，<code class="eh ln lo lp lq b">model</code>这个名字似乎意味着一个对象，但是在Elixir中没有对象，所以将数据访问层存储在名为<code class="eh ln lo lp lq b">models</code>的文件夹下没有什么上下文意义。</p><h2 id="cbb7" class="lr is hu bd it ls lt lu ix lv lw lx jb kr ly lz jf kv ma mb jj kz mc md jn me dt translated">数据和上下文</h2><p id="2491" class="pw-post-body-paragraph kg kh hu ki b kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz mj lb lc ld hn dt translated">默认情况下，Phoenix 1.3会引导您以更好的方式组织代码。控制器、视图、模板放在<code class="eh ln lo lp lq b">lib/my_app_web</code>下，数据库迁移和相关文件放在<code class="eh ln lo lp lq b">priv/repo</code>下，而你的灵药代码的其余部分将放在<code class="eh ln lo lp lq b">lib/my_app</code>下。这是基本的设置，您可以对其进行调整，并根据自己的喜好进行更改。你有完全的自由去组织你的代码。</p><p id="87b9" class="pw-post-body-paragraph kg kh hu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hn dt translated">自从我在凤凰1.3完全发布之前开始写AlloyCI <em class="mk">以来，一些文件夹结构与最新的1.3生成器创建的不同。我更喜欢AlloyCI现在的结构，因为我真的不喜欢他们把<code class="eh ln lo lp lq b">web/</code>文件夹重命名为<code class="eh ln lo lp lq b">alloy_ci_web/</code>的方式，以及里面的所有东西从<code class="eh ln lo lp lq b">AlloyCi.Web.XXX</code>重命名为<code class="eh ln lo lp lq b">AlloyCiWeb.XXX</code>。我真的更喜欢在模块名称中的分隔，以及在web文件夹名称中不重复应用程序名称的事实。不过，由于Phoenix提供的灵活性，我不需要遵循惯例。</em></p><p id="7916" class="pw-post-body-paragraph kg kh hu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hn dt translated">无论如何，关于结构变化的最重要的部分是，Phoenix现在指导您使用<strong class="ki hv">上下文</strong>来构建您的数据访问层。</p><p id="129c" class="pw-post-body-paragraph kg kh hu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hn dt translated">以AlloyCI为例，我们有<code class="eh ln lo lp lq b">Accounts</code>上下文(在<code class="eh ln lo lp lq b">lib/alloy_ci/accounts</code>文件夹下)，其中有<code class="eh ln lo lp lq b">User</code>、<code class="eh ln lo lp lq b">Authentication</code>和<code class="eh ln lo lp lq b">Installation</code>模式。这3种模式密切相关，属于同一个业务逻辑，即账户的处理。</p><p id="5ca3" class="pw-post-body-paragraph kg kh hu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hn dt translated">如果您仔细查看<code class="eh ln lo lp lq b">accounts</code>文件夹下的<a class="ae kf" href="https://github.com/AlloyCI/alloy_ci/tree/master/lib/alloy_ci/accounts" rel="noopener ugc nofollow" target="_blank">文件</a>，您会发现除了changeset函数之外，模式文件中没有其他函数。这意味着我需要直接通过<code class="eh ln lo lp lq b">Ecto</code>来操作数据库数据(不推荐),或者我需要一个API边界来允许我对帐户相关的模式执行操作。</p><p id="61d2" class="pw-post-body-paragraph kg kh hu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hn dt translated">这就是<code class="eh ln lo lp lq b">AlloyCi.Accounts</code>模块发挥作用的地方。如果AlloyCI需要对与帐户相关的任何模式执行操作，这个模块就是alloy ci与之交互的边界。该模块的所有公共函数提供了一种操作数据的简单方法，同时通过间接层提供了安全性。</p><p id="7b69" class="pw-post-body-paragraph kg kh hu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hn dt translated">这就是<strong class="ki hv">语境的目的。它们在你的数据层和你的业务逻辑之间提供了一个边界，并且允许你有一个明确的契约来告诉你如何操作你的数据。它还允许你保持独立于<code class="eh ln lo lp lq b">Ecto</code>。</strong></p><p id="7d54" class="pw-post-body-paragraph kg kh hu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hn dt translated">比方说，在未来，你想从<code class="eh ln lo lp lq b">Ecto</code>切换到“最新、最酷的DB驱动”。如果你不使用抽象层，比如上下文，你将不得不重构代码库中使用<code class="eh ln lo lp lq b">Ecto</code>与数据层通信的每一个函数。<em class="mk">但是</em>因为我们使用了上下文，我们只需要在上下文中重构代码。</p><h2 id="516f" class="lr is hu bd it ls lt lu ix lv lw lx jb kr ly lz jf kv ma mb jj kz mc md jn me dt translated">数据显示</h2><p id="df7c" class="pw-post-body-paragraph kg kh hu ki b kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz mj lb lc ld hn dt translated">将你的数据真实呈现给用户的代码可以存在于<code class="eh ln lo lp lq b">lib/my_app/web</code>或<code class="eh ln lo lp lq b">lib/my_app_web</code>文件夹下，这取决于你想如何构建它(自动生成器将默认为<code class="eh ln lo lp lq b">lib/my_app_web</code>，但我更喜欢前者)。</p><p id="3720" class="pw-post-body-paragraph kg kh hu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hn dt translated">在这里你可以找到你的控制器、视图、模板和通道所在的文件夹。让我们从表示层开始。</p><h2 id="8ee7" class="lr is hu bd it ls lt lu ix lv lw lx jb kr ly lz jf kv ma mb jj kz mc md jn me dt translated"><strong class="ak">视图&amp;模板</strong></h2><p id="823a" class="pw-post-body-paragraph kg kh hu ki b kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz mj lb lc ld hn dt translated">如果您来自Rails背景，您可能想知道为什么有两个组件来呈现数据，而在Rails中您所需要的只是<code class="eh ln lo lp lq b">views</code>文件夹。在Phoenix中,“视图”不是由模板化的HTML文件组成的，而是常规的Elixir模块。这些模块可以帮助您与模板共享代码，并实现与Rails“视图助手”相似的目的，但默认情况下，这些模块特定于单个控制器(不加载其他视图，不像Rails加载所有视图助手，不管调用哪个控制器)。这种分离使得在呈现数据所需的相似助手函数上使用相同的签名变得更加容易(而不会真正使它们过载)，这取决于调用的是哪个控制器，从而简化了您的代码。</p><p id="f8a7" class="pw-post-body-paragraph kg kh hu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hn dt translated">模板就是你的HTML代码所在的地方。模板文件保存为<code class="eh ln lo lp lq b">*.html.eex</code>文件(意思是嵌入的药剂)，与<code class="eh ln lo lp lq b">erb</code>文件非常相似。语法是完全相同的，但是您编写的不是Ruby代码，而是Elixir代码😄</p><p id="ac0a" class="pw-post-body-paragraph kg kh hu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hn dt translated">Phoenix和Rails之间一个非常重要的区别是如何在控制器和模板之间共享信息。在Rails中，用<code class="eh ln lo lp lq b">@something</code>声明一个实例变量就足够了，它将对模板/视图可用。</p><p id="861e" class="pw-post-body-paragraph kg kh hu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hn dt translated">鉴于Elixir的功能性质，在Phoenix中，您需要显式地将您希望提供的信息传递给<code class="eh ln lo lp lq b">render</code>函数中的视图。这些被称为分配。作为示例，下面是<code class="eh ln lo lp lq b">PipelineController</code>的<code class="eh ln lo lp lq b">show</code>动作:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="5489" class="pw-post-body-paragraph kg kh hu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hn dt translated">在<code class="eh ln lo lp lq b">"show.html"</code>之后的都是赋值变量，所以与<code class="eh ln lo lp lq b">show</code>动作相关的模板可用的变量是<code class="eh ln lo lp lq b">builds</code>、<code class="eh ln lo lp lq b">pipeline</code>和<code class="eh ln lo lp lq b">current_user</code>。我们可以在pipeline info头的代码片段中看到如何使用它们的示例:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="bad4" class="pw-post-body-paragraph kg kh hu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hn dt translated">一旦变量被赋值，它就可以通过<code class="eh ln lo lp lq b">@var_name</code>进入模板，就像Rails一样。定义了与控制器同名的视图文件的函数(在本例中为<code class="eh ln lo lp lq b">pipeline_view.ex</code>)可立即用于模板。在上面的例子中，<code class="eh ln lo lp lq b">sha_link/1</code>创建了一个指向GitHub上特定提交的HTML链接。</p><h2 id="7cd1" class="lr is hu bd it ls lt lu ix lv lw lx jb kr ly lz jf kv ma mb jj kz mc md jn me dt translated"><strong class="ak">控制器</strong></h2><p id="f89e" class="pw-post-body-paragraph kg kh hu ki b kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz mj lb lc ld hn dt translated">在结构上，Phoenix控制器与Rails控制器非常相似，主要区别如上所述。当由助手工具生成时，它们将像Rails中的对应对象一样执行相同的索引、显示、编辑、更新和删除操作。就像Rails控制器一样，您可以通过定义一个函数并连接一个路由来定义您想要的任何动作。</p><h2 id="c274" class="lr is hu bd it ls lt lu ix lv lw lx jb kr ly lz jf kv ma mb jj kz mc md jn me dt translated"><strong class="ak">频道</strong></h2><p id="1543" class="pw-post-body-paragraph kg kh hu ki b kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz mj lb lc ld hn dt translated">Phoenix通道用于通过web套接字与Web客户端通信。它们类似于Rails中的<code class="eh ln lo lp lq b">ActionCable</code>，但在我看来，要强大得多，而且<a class="ae kf" href="https://dockyard.com/blog/2016/08/09/phoenix-channels-vs-rails-action-cable" rel="noopener ugc nofollow" target="_blank"> performant </a>。在AlloyCI中，它们用于实时推送构建日志的输出，并接收一段预先格式化的HTML代码来显示用户的存储库(关于AlloyCI如何使用通道的更多信息将在另一篇文章中讨论)。</p></div><div class="ab cl mn mo hc mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hn ho hp hq hr"><p id="14aa" class="pw-post-body-paragraph kg kh hu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hn dt translated">现在你知道了。这是凤凰计划的基本架构。这里还有我们没有涉及的其他组件，比如<em class="mk">插头</em>，或者<em class="mk">后台工作</em>。我们将在以后的博客文章中讨论这些高级主题。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mu mm l"/></div></figure></div></div>    
</body>
</html>