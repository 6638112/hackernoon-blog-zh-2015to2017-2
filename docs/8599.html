<html>
<head>
<title>Generating Waveforms for Podcasts in Winds 2.0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Winds 2.0中为播客生成波形</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/generating-waveforms-for-podcasts-in-winds-2-0-82a32a1c77fa?source=collection_archive---------16-----------------------#2017-12-07">https://medium.com/hackernoon/generating-waveforms-for-podcasts-in-winds-2-0-82a32a1c77fa?source=collection_archive---------16-----------------------#2017-12-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/7939125900d0cb9f6f527481640f62e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*us8YCbXT3hvH7Ro10YTuyg.png"/></div></div></figure><p id="5641" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作为用于构建可扩展新闻源和活动流的API<a class="ae ka" href="http://getstream.io/" rel="noopener ugc nofollow" target="_blank">Stream</a>的开发人员，我和我的同事们一直在努力开发Winds 2.0。这个版本的Winds是一个开源的桌面应用程序，支持RSS提要和简单的播客收听，我们正在Electron、React和Node.js中构建它。</p><p id="a70d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">关于Winds 2.0的更多信息，请查看<a class="ae ka" href="https://getstream.io/blog/announcing-winds-2-0%E2%80%8A-%E2%80%8Aan-electron-app-support-rss-podcasts/" rel="noopener ugc nofollow" target="_blank">发布的博客文章</a>。</p><p id="72ba" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Winds的一个很酷的新特性是波形功能。在这篇博文中，我将简单介绍一下波形到底是什么，以及如何创建波形。</p><p id="5675" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">想跟着去吗？在<a class="ae ka" href="https://github.com/kenhoff/winds-waveform-example" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上查看源代码，然后查看<a class="ae ka" href="https://kenhoff.github.io/winds-waveform-example/" rel="noopener ugc nofollow" target="_blank">完成的示例</a>。</p><h2 id="129f" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">什么是波形？</h2><p id="3e6a" class="pw-post-body-paragraph jc jd hu je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">波形是音频文件随时间变化的音量的直观表示，这使得挑选歌曲或podcast的响亮/安静部分变得非常容易。</p><p id="ba90" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于那些视觉学习者来说，波形看起来是这样的:</p><figure class="lc ld le lf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lb"><img src="../Images/9acc984f27d761e456cab45343d5b882.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MaIzMkO5JYS4SaUl."/></div></div></figure><p id="a58a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Winds 2.0中，我们创建了一个风格化的波形组件，除了显示音频文件随时间变化的音量，还显示当前轨道的进度。以下是我们的设计师(他将基于<a class="ae ka" href="https://getstream.io/based-feed-ui-kit-sketch/" rel="noopener ugc nofollow" target="_blank">的UI套件</a>和基于<a class="ae ka" href="https://getstream.io/based-mobile-ui-kit/" rel="noopener ugc nofollow" target="_blank">的UI套件——移动</a>)所寻找的东西:</p><figure class="lc ld le lf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lg"><img src="../Images/50f84fc82d876c5ead9fa90cf3b1bc68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IqN97cZPYRGHk7A6."/></div></div></figure><p id="f48b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">应该有一个图书馆来放这个… </strong></p><p id="d023" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有！<a class="ae ka" href="https://www.npmjs.com/package/react-wavesurfer" rel="noopener ugc nofollow" target="_blank"> react-wavesurfer </a>是围绕<a class="ae ka" href="https://wavesurfer-js.org/" rel="noopener ugc nofollow" target="_blank"> wavesurfer.js </a>的react包装器，是一个用于在浏览器中播放和显示音频文件的JavaScript库。</p><p id="79d0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Wavesurfer是一个很棒的项目，但没有完全满足我们的要求。Wavesurfer使用HTML5画布(这对我们没用——稍后会详细介绍！)，看起来我们将不得不解决许多问题，将老派的JS库集成到我们的新派React/Redux/electronic应用程序中。</p><p id="4192" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">我们已经建立了音频播放器——我们只需要一个波形<em class="lh">渲染器……</em></strong></p><p id="237e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Winds 2.0已经有了一个轻量级的音频播放器，这只是一个包装<a class="ae ka" href="https://github.com/justinmc/react-audio-player" rel="noopener ugc nofollow" target="_blank">反作用音频播放器</a>。我们现在需要的只是一个波形渲染器——某种可以将音频文件转换成波形的组件。</p><p id="b20f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">同样重要的是要注意，我们还需要在波形上显示<strong class="je hv">进度</strong>，这样用户就知道在另一次保证驾驶休息之前，他们还有多少辉煌的几分钟闷热的电台播音员的声音。</p><h2 id="a73d" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">第1部分:获取波形数据</h2><p id="9da4" class="pw-post-body-paragraph jc jd hu je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">在绘制波形之前，我们必须获取音频数据，并将其转换为一种格式，以便实际应用于页面。</p><p id="efea" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请记住，数字音频文件实际上只是一个巨大的数字阵列，当足够快地按顺序播放时，听起来就像一个播客！或者黑暗咒语，如果反过来玩。</p><p id="9303" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了获取数据并对其进行处理，我们需要将其加载到AudioContext中，然后使用<code class="eh li lj lk ll b">getChannelData</code>方法获取音频值数组。基本上，我们只是把JS <code class="eh li lj lk ll b">ArrayBuffer</code>变成了<code class="eh li lj lk ll b">Float32Array</code>:</p><figure class="lc ld le lf fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><blockquote class="lo lp lq"><p id="933c" class="jc jd lh je b jf jg jh ji jj jk jl jm lr jo jp jq ls js jt ju lt jw jx jy jz hn dt translated">AudioContext对象是新的<a class="ae ka" href="https://webaudio.github.io/web-audio-api/" rel="noopener ugc nofollow" target="_blank"> Web Audio API </a>的一部分，对于浏览器来说，这是一个相对较新的概念，但是在所有现代浏览器中仍然可以使用<a class="ae ka" href="https://developer.mozilla.org/en-US/docs/Web/API/AudioContext#Browser_compatibility" rel="noopener ugc nofollow" target="_blank">。完全可能做到这一点与ffmpeg和其他音频库，如果这是更好地为您工作！<br/> <br/>同样，我们使用</a><a class="ae ka" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> axios </a>代替<a class="ae ka" href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest" rel="noopener ugc nofollow" target="_blank"> XMLHttpRequest </a>，只是因为它稍微容易一点。</p></blockquote><p id="710b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如，如果我们使用最新的<a class="ae ka" href="https://www.cartalk.com/show/1743-sherman-letank" rel="noopener ugc nofollow" target="_blank">汽车谈话集，#1743 </a>(嗯，最新的“最棒的”汽车谈话集，因为它在2012年停播了——RIP Tom)和<code class="eh li lj lk ll b">console.log</code>出了<code class="eh li lj lk ll b">decodedAudioData</code>，我得到了看起来有点像这样的东西:</p><figure class="lc ld le lf fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="d698" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我有一个143，669，376个32位浮点的数组。MP3的采样速率为每秒44，100个样本，运行时间为54分18秒，因此，数学:</p><p id="4494" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">(44100个样本/秒)* ( 3258秒)=总计143，677，800个样本</p><p id="b95a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这与我们阵列中的143，669，376个样本非常接近。太棒了。</p><h2 id="a908" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">将波形数据转换成我们可以渲染的东西</h2><p id="df54" class="pw-post-body-paragraph jc jd hu je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">在这个过程的最后，我想要一个从0到1的大约100个值的数组，我可以映射到波形上每个条的高度。(我的意思是，我可以尝试将所有143，669，376个值映射到波形的条形图上，但是我觉得<em class="lh">可能会</em>引起一些可用性问题……)</p><p id="2d2f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将使用分时段算法来生成N个时段——每个时段都表示音频文件在该时间间隔内音量的最大值(或平均值，或最小值，这取决于您要查找的内容)。</p><figure class="lc ld le lf fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="54d1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如您在上面看到的，音频数据可能是负面的！这就是音频数据的工作方式——音频样本的值可以是-1到1。然而，我们不希望在波形中出现负值，所以我们将只使用每个桶中的最大值。</p><p id="ff31" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们高度程式化的波形不一定是音频文件中数据的100%精确再现。我们只需要一个100小节的数组，每个小节都表示该部分音频文件的一般“响度”。</p><p id="172d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以下是分时段算法:</p><figure class="lc ld le lf fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="073c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在用100个桶通过这个算法运行我们的decodedAudioData(包含143，669，376个样本的<code class="eh li lj lk ll b">Float32Array</code>)之后，我们得到了类似如下的结果:</p><figure class="lc ld le lf fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="d28c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对我们来说，将它呈现到页面上要容易得多！</p><h2 id="f9ec" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">第2部分:绘制我们的波形</h2><p id="99fb" class="pw-post-body-paragraph jc jd hu je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">好了，现在我们有了100个值的数组，从0到1，每个值都表示音频文件该部分的最大响度。我们可以使用这些数据向页面实际呈现波形。</p><p id="2662" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请记住，这就是我们希望波形在最后的样子:</p><figure class="lc ld le lf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lg"><img src="../Images/96c47e311f9acbfe76a99132af049bd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lCuW9gcz-sO-jPMH."/></div></div></figure><p id="86cb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">基于这个模型，我们将有3个主要要求:</p><ol class=""><li id="8cb9" class="lu lv hu je b jf jg jj jk jn lw jr lx jv ly jz lz ma mb mc dt translated">该波形是播客音量随时间变化的近似值，我们已经从第1部分中获得了该数据。</li><li id="1411" class="lu lv hu je b jf md jj me jn mf jr mg jv mh jz lz ma mb mc dt translated">我们需要对组件的样式有一些控制:条的数量，它们之间的间距，颜色等等。</li><li id="b1a1" class="lu lv hu je b jf md jj me jn mf jr mg jv mh jz lz ma mb mc dt translated">当曲目播放时，我们需要让进度条在波形条中“闪耀”ᗛ<strong class="je hv">这是一个棘手的问题</strong>！</li></ol><h2 id="e0a0" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">实施方案</h2><p id="659f" class="pw-post-body-paragraph jc jd hu je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">有几种不同的方法可以实现这一点——每一种都有一些权衡。</p><p id="9205" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API" rel="noopener ugc nofollow" target="_blank"><strong class="je hv">Canvas</strong></a><strong class="je hv"/>——现有的波形库大多使用HTML5 Canvas元素。</p><p id="4d70" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="lh"> Pro: </em> Canvas非常适合2D和3D游戏，也是分层或动画视觉元素的像素级完美实现。听起来很适合我们，对吧？</p><p id="495b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="lh"> Con: </em> Canvas没有真正满足我们的#2要求，这很容易控制组件的样式。缩放波形“条”的高度、宽度和间距很困难，我们也很难提供容易改变的参数。</p><p id="500f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">(Canvas确实提供了一些使用剪辑蒙版的方法，但我并没有深入研究。)</p><p id="a1c7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model" rel="noopener ugc nofollow" target="_blank"><strong class="je hv">DOM</strong></a><strong class="je hv"/>——就是一堆<code class="eh li lj lk ll b">div</code> s！</p><p id="2eaa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="lh"> Pro: </em>对于web开发人员来说，使用CSS对DOM waveform进行大量定制是非常容易的。它可以很好地伸缩，我们可以很容易地设置填充，高度和宽度参数，我们甚至可以在播客加载或播放时添加动画。</p><p id="9f72" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="lh">缺点:</em>DOM对我们来说不容易做到的是屏蔽/剪辑——例如，播放时让进度条“穿透”波形。当然，我们可能会设置一些情况，根据音频文件的进度计算要填充多少小节，然后计算填充“当前播放”小节的百分比，但这有点混乱。</p><p id="dd91" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://developer.mozilla.org/en-US/docs/Web/SVG" rel="noopener ugc nofollow" target="_blank"><strong class="je hv">SVG</strong></a><strong class="je hv"/>——<code class="eh li lj lk ll b">rect</code>【s】<code class="eh li lj lk ll b">viewBox</code><code class="eh li lj lk ll b">preserveAspectRatio</code>。</p><p id="b04e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="lh"> Pro: </em> SVG给了我们<em class="lh">一些</em>样式选项—(填充颜色、矩形边框半径和其他SVG属性都可以通过CSS设置)。最重要的是，SVG允许我们对DOM元素进行“屏蔽”(或裁剪)。</p><p id="a560" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">反对:使用SVG的一个缺点是我们不能通过CSS获得布局控制。相反，我们必须对每个“条”使用绝对定位。然而，SVG确实给了我们一些拉伸和缩放的选项，比如<code class="eh li lj lk ll b">preserveAspectRatio="none"</code>。使用JavaScript，我们可以指定这些参数(条数、条间距等)，并使用<em class="lh"> math </em>计算出在哪里绘制它们。</p><h2 id="d3e9" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">SVG遮罩的工作原理</h2><p id="be36" class="pw-post-body-paragraph jc jd hu je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">我们讨论了实现波形的不同方法，但我们围绕的主要要求是“屏蔽”，或者让进度条“穿透”波形。</p><p id="38e9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们的SVG遮罩发挥作用有三个部分:</p><ol class=""><li id="37d4" class="lu lv hu je b jf jg jj jk jn lw jr lx jv ly jz lz ma mb mc dt translated">这个元素将作为一个“进度条”——动画显示一个从0%宽度到100%宽度的矩形。</li><li id="2c8f" class="lu lv hu je b jf md jj me jn mf jr mg jv mh jz lz ma mb mc dt translated">实际的遮罩:进度条应该“穿透”的“填充”线和区域。</li><li id="07b1" class="lu lv hu je b jf md jj me jn mf jr mg jv mh jz lz ma mb mc dt translated">CSS将两者连接在一起- <code class="eh li lj lk ll b">clip-path</code>。</li></ol><p id="8b98" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，请记住这是SVG，这意味着样式声明和属性看起来略有不同，但在样式化DOM元素时，操作原理是相同的。</p><p id="3e61" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第一部分——我们的“进度条”元素和“背景”元素:</p><figure class="lc ld le lf fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="5624" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh li lj lk ll b">viewBox</code>属性为我们的SVG定义了笛卡尔网格空间，从元素的左上角开始(0，0 ),到右下角的(100，100)。</p><p id="e471" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh li lj lk ll b">preserveAspectRatio</code>属性与您通常在SVG上看到的相反——我们没有使用“meet”或“slice”(确保图像被扩展/收缩以适应SVG框，或者被裁剪以适应SVG框)，而是使用“none ”,这迫使图像被拉伸和缩放以适应我们向它抛出的任何CSS尺寸。</p><p id="c231" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，我们定义两个SVG矩形——第一个是我们的波形“背景”(整个波形的灰色),第二个是实际的“进度条”,它在轨道播放时显示宽度。</p><p id="f186" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那两个SVG不是波形上的条！它们只是背景和进度条。为了创建条形，我们需要创建另一个SVG元素，这次高度和宽度为0:</p><figure class="lc ld le lf fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="96f8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个SVG的高度和宽度为0，因为我们实际上并不想将其呈现到页面上。相反，我们将在将它连接到进度和后台SVG时引用它。我们还使用了一些不太知名的SVG标签，比如<br/> <code class="eh li lj lk ll b">defs</code> ( <a class="ae ka" href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/defs" rel="noopener ugc nofollow" target="_blank">有点像SVG“模板”</a>)和<code class="eh li lj lk ll b">clipPath</code>，这正是我们在这种情况下想要使用的<em class="lh"/>。</p><p id="0382" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为在页面加载(并获取音频数据)之前我们不知道条形是什么样子，所以我们将使用JavaScript创建一组<code class="eh li lj lk ll b">rect</code>——每个桶一个:</p><figure class="lc ld le lf fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><blockquote class="lo lp lq"><p id="00ff" class="jc jd lh je b jf jg jh ji jj jk jl jm lr jo jp jq ls js jt ju lt jw jx jy jz hn dt translated">在Winds 2.0中，我们已经用React构建了所有东西，所以它在开源repo中看起来会略有不同:)Vanilla JS非常适合阐释这个概念！</p></blockquote><p id="7b8d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请记住，我们在0到100的坐标空间中绘制这些条，因为页面上的其他SVG使用的就是这个坐标空间。无论CSS的高度和宽度如何设置，这些条都将使用<code class="eh li lj lk ll b">viewBox</code>进行拉伸和缩放。</p><p id="640b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请记住，buckets只是我们从0到1的N个值的数组，表示在此时间间隔内音轨的一般响度。我们迭代所有的桶，然后使用一些Math来计算出这些矩形条的确切位置:</p><ol class=""><li id="625f" class="lu lv hu je b jf jg jj jk jn lw jr lx jv ly jz lz ma mb mc dt translated">矩形的起始X坐标，从SVG框的左侧开始，加上每个条之间的间距。</li><li id="638a" class="lu lv hu je b jf md jj me jn mf jr mg jv mh jz lz ma mb mc dt translated">矩形的宽度，即桶数/ 100减去间距。</li></ol><p id="2fbb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，我们得到了将两个(如果算上背景的话，是三个)SVG元素联系在一起的CSS:</p><figure class="lc ld le lf fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="0851" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这选择了“背景”和“进度条”两个矩形，并说“使用<code class="eh li lj lk ll b">#waveform-mask</code> SVG作为蒙版”——就好像<code class="eh li lj lk ll b">#waveform-mask</code> SVG只是进度条上的一个剪纸，我们可以通过剪纸看到像素。</p><p id="a4d6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">别忘了！我们需要在音轨播放时更新<code class="eh li lj lk ll b">.waveform-progress</code> SVG的宽度。根据音频播放器的实现，可能会有一个<code class="eh li lj lk ll b">onListen</code>回调，或者我们只是使用<code class="eh li lj lk ll b">setInterval</code>每500毫秒左右触发一次。我们所要做的就是将轨道的当前进度除以轨道的长度，乘以100并改变<code class="eh li lj lk ll b">.waveform-progress</code>矩形的宽度。</p><h2 id="3a5f" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">最终结果</h2><figure class="lc ld le lf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mi"><img src="../Images/3da355fcadd74949b1319c8f6a4e7552.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bNjTdti_ZWOZnUuM.gif"/></div></div></figure><p id="c23c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">嘣！看看——我们的剧集有一些喧闹的部分，一些安静的部分，音频播放，进度条填充……不知何故，我们又浪费了一个完美的小时听汽车对话。</p><p id="a234" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您有兴趣在您的应用程序中实现这样的东西，您可以查看这个<a class="ae ka" href="https://kenhoff.github.io/winds-waveform-example/" rel="noopener ugc nofollow" target="_blank">完整的工作示例</a>和<a class="ae ka" href="https://github.com/kenhoff/winds-waveform-example" rel="noopener ugc nofollow" target="_blank">源代码</a>。</p><p id="fbd1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这个例子中，我刚刚使用了一个<code class="eh li lj lk ll b">audio</code>元素作为音频播放器。我每100毫秒检查一次音频播放器的进度，然后调整进度条的宽度。</p><p id="147f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在重要的应用程序中，音频实现会有很大不同——例如，在Winds 2.0中，我们为<code class="eh li lj lk ll b">PlayerContainer</code>、<code class="eh li lj lk ll b">ReactAudioPlayer</code>和<code class="eh li lj lk ll b">Waveform</code>提供了单独的React组件。<code class="eh li lj lk ll b">ReactAudioPlayer</code>每隔500毫秒调用一个onListen道具，该道具计算进度，存储在PlayerContainer的状态中，然后用<code class="eh li lj lk ll b">progress</code>道具呈现<code class="eh li lj lk ll b">Waveform</code>组件。</p><h2 id="41b6" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">下一步是什么？</h2><p id="50f2" class="pw-post-body-paragraph jc jd hu je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">请只打一个网络电话。</p><p id="cc0c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在示例代码中，您可能会注意到实际上有两个网络调用来获取/car-talk.mp3文件——一个来自我们的脚本，它以<code class="eh li lj lk ll b">ArrayBuffer</code>格式获取音频，另一个来自页面上的<code class="eh li lj lk ll b">audio</code>元素。</p><p id="7b25" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下载两次30秒的蓝草音乐？没什么大不了的！<a class="ae ka" href="https://www.penny-arcade.com/podcasts/show/ai" rel="noopener ugc nofollow" target="_blank"> 2小时的一款龙与地下城游戏</a>，下载了两次？大概是要锤用户的网络连接。</p><p id="2591" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不幸的是，这是一个比最初看起来要复杂得多的问题，我仍在解决这个问题。我的最佳建议是:</p><ul class=""><li id="ef2c" class="lu lv hu je b jf jg jj jk jn lw jr lx jv ly jz mj ma mb mc dt translated">抓取音频数据(通过XHR，以<code class="eh li lj lk ll b">ArrayBuffer</code>格式)并将其加载到<code class="eh li lj lk ll b">audio</code>元素中。</li><li id="8882" class="lu lv hu je b jf md jj me jn mf jr mg jv mh jz mj ma mb mc dt translated">或者，反过来做——让<code class="eh li lj lk ll b">audio</code>元素获取音频数据，然后从元素中提取数据。</li><li id="cb30" class="lu lv hu je b jf md jj me jn mf jr mg jv mh jz mj ma mb mc dt translated">或者，开始黑暗咒语来调用<code class="eh li lj lk ll b">AudioContext</code>、<code class="eh li lj lk ll b">AnalyzerNode</code>和<code class="eh li lj lk ll b">AudioDestinationNode</code>——并且只使用网络音频API来播放音频。</li></ul><p id="cfc3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">也许最大响度不是我们应该使用的变量？</strong></p><p id="ce3a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我还想提高一点视觉效果——一些播客在章节之间有很好的小音景部分(谢谢，<a class="ae ka" href="http://www.radiolab.org/" rel="noopener ugc nofollow" target="_blank"> Jad和Robert </a>)，但大多数口语播客在整集中都很水平(谢谢，<a class="ae ka" href="https://99percentinvisible.org/" rel="noopener ugc nofollow" target="_blank"> Roman Mars </a>)。波形是准确的，但不一定有用——如果我想跳到另一章，我通常会在有间歇音乐或寂静的音频中寻找下降/峰值。</p><p id="75fd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这可能很简单，只需取整个时段的平均或最小量。或者，我们可以通过计算出某种非线性比例来变得更复杂，或者计算最大音量，并从那里开始缩放一切。只是用来实验的东西！</p><p id="8704" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是如果我想要更多的酒吧呢？还是把酒吧的边缘弄圆？！并使组件具有响应能力！？</p><p id="0b08" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些大多只是SVG的局限性——它是90%的解决方案。圆化一个<code class="eh li lj lk ll b">div</code>的角是微不足道的，但是圆化非常小的SVG矩形的角效果不好。而且，如果我们调整整个SVG的大小，条的数量保持不变，但是条之间的间距会扩大。波形响应不是很快，所以我们最好在页面上粘贴时坚持固定的宽度值。</p><h2 id="7751" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">播放结尾音乐</h2><p id="1b49" class="pw-post-body-paragraph jc jd hu je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">除了SVG的一些限制之外，这个组件非常棒！我们可以让用户的客户端处理所有的波形生成，而不必在服务器端使用ffmpeg或其他音频处理库来完成所有这些工作。</p><p id="a890" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们正在努力开发Winds 2.0，这样你就可以在一个应用程序中收听所有你喜欢的播客和阅读你喜欢的RSS源。它进展得非常好，所以请在明年年初寻找它。现在，看看我们的另一个示例应用程序，<a class="ae ka" href="https://github.com/GetStream/stream-react-example" rel="noopener ugc nofollow" target="_blank"> Cabin </a>。</p><blockquote class="lo lp lq"><p id="a5da" class="jc jd lh je b jf jg jh ji jj jk jl jm lr jo jp jq ls js jt ju lt jw jx jy jz hn dt translated">这是由GetStream.io的开发者倡导者Ken Hoff领导的GetStream.io团队的合作。原始博文可在<a class="ae ka" href="https://getstream.io/blog/generating-waveforms-for-podcasts-in-winds-2-0/" rel="noopener ugc nofollow" target="_blank">https://getstream . io/blog/generating-waveforms-for-podcast-in-winds-2-0/</a>找到。</p></blockquote></div></div>    
</body>
</html>