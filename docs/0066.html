<html>
<head>
<title>Writing a Blog Engine in Phoenix and Elixir: Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Phoenix和Elixir编写博客引擎:第1部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/introduction-fe138ac6079d?source=collection_archive---------0-----------------------#2015-09-30">https://medium.com/hackernoon/introduction-fe138ac6079d?source=collection_archive---------0-----------------------#2015-09-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="bfa5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">最后更新于</strong>:2016年7月20日</p><h2 id="f503" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">当前版本:</h2><p id="5288" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">在撰写本文时，我们应用程序的当前版本是:</p><ul class=""><li id="a369" class="kp kq hu it b iu iv iy iz jc kr jg ks jk kt jo ku kv kw kx dt translated"><strong class="it hv">仙丹</strong> : v1.3.1</li><li id="4a40" class="kp kq hu it b iu ky iy kz jc la jg lb jk lc jo ku kv kw kx dt translated"><strong class="it hv">凤凰:</strong> v1.2.0</li><li id="9475" class="kp kq hu it b iu ky iy kz jc la jg lb jk lc jo ku kv kw kx dt translated"><strong class="it hv"> Ecto: </strong> v2.0.2</li><li id="dcb3" class="kp kq hu it b iu ky iy kz jc la jg lb jk lc jo ku kv kw kx dt translated"><strong class="it hv">康美宁:</strong> v2.5.2</li></ul><p id="efc1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你正在读这篇文章，而这些不是最新的，请告诉我，我会相应地更新这篇教程。</p><h2 id="07a6" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">安装Phoenix</h2><p id="a8dc" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">安装Phoenix的最佳说明可以在Phoenix网站上找到<a class="ae ld" href="http://www.phoenixframework.org/docs/installation" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="b8a2" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">第一步:让我们添加帖子</h2><p id="d010" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">我们需要从使用Phoenix mix任务创建一个新项目开始，我们将其命名为“pxblog”。我们使用mix phoenix . new[project][command]来实现这一点。对所有问题回答Y，因为我们确实想使用phoenix.js和其他前端需求。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="f9ab" class="jp jq hu lj b fv ln lo l lp lq">mix phoenix.new pxblog</span></pre><p id="42b7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">输出:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="f952" class="jp jq hu lj b fv ln lo l lp lq">* creating pxblog/config/config.exs<br/>...</span><span id="2a23" class="jp jq hu lj b fv lr lo l lp lq">Fetch and install dependencies? [Yn] y<br/>* running mix deps.get<br/>* running npm install &amp;&amp; node node_modules/brunch/bin/brunch build</span><span id="2e8a" class="jp jq hu lj b fv lr lo l lp lq">We are all set! Run your Phoenix application:</span><span id="db44" class="jp jq hu lj b fv lr lo l lp lq">$ cd pxblog<br/>$ mix phoenix.server</span><span id="5f2f" class="jp jq hu lj b fv lr lo l lp lq">You can also run your app inside IEx (Interactive Elixir) as:</span><span id="9194" class="jp jq hu lj b fv lr lo l lp lq">$ iex -S mix phoenix.server</span><span id="71a3" class="jp jq hu lj b fv lr lo l lp lq">Before moving on, configure your database in config/dev.exs and run:</span><span id="9bce" class="jp jq hu lj b fv lr lo l lp lq">$ mix ecto.create</span></pre><p id="9f96" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们应该看到一串输出，表明我们的项目已经完成，初始工作已经完成。</p><p id="db0a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们没有正确设置postgres数据库或者配置我们的应用程序使用正确的凭证，那么<strong class="it hv"> mix ecto.create </strong>步骤可能会失败。如果您打开<strong class="it hv"> config/dev.exs </strong>，您应该在文件底部看到一些配置细节:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="4ca1" class="jp jq hu lj b fv ln lo l lp lq"># Configure your database<br/>config :pxblog, Pxblog.Repo,<br/>  adapter: Ecto.Adapters.Postgres,<br/>  username: "postgres",<br/>  password: "postgres",<br/>  database: "pxblog_dev",<br/>  hostname: "localhost",<br/>  pool_size: 10</span></pre><p id="2f71" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">只需将用户名和密码更改为拥有正确的数据库创建权限的角色。</p><p id="5da3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们有了工作，我们将启动服务器只是为了确保一切正常。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="db16" class="jp jq hu lj b fv ln lo l lp lq">$ iex -S mix phoenix.server</span></pre><p id="87a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们现在应该能够访问<a class="ae ld" href="http://localhost:4000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:4000/ </a>并看到“欢迎来到凤凰城！”页面。现在我们有了一个好的基线，让我们添加创建帖子的基本框架，因为这毕竟是一个博客引擎。</p><p id="5cbf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们要做的第一件事是利用Phoenix的一个生成器，不仅为我们构建了Ecto模型和迁移，还构建了UI脚手架来处理Post对象的CRUD ( <em class="ls"> Create、Read、Update、Delete </em>)操作。因为现在这是一个非常非常简单的博客引擎，所以让我们只关注标题和正文；标题是字符串，正文是文本。这些生成器的语法非常简单:</p><blockquote class="lt lu lv"><p id="f2f5" class="ir is ls it b iu iv iw ix iy iz ja jb lw jd je jf lx jh ji jj ly jl jm jn jo hn dt translated">混合phoenix.gen.html[模型名][表名][列名:列类型]…</p></blockquote><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="7cc9" class="jp jq hu lj b fv ln lo l lp lq">$ mix phoenix.gen.html Post posts title:string body:text</span></pre><p id="d735" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">输出:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="191b" class="jp jq hu lj b fv ln lo l lp lq">* creating web/controllers/post_controller.ex<br/>...</span><span id="66c8" class="jp jq hu lj b fv lr lo l lp lq">Add the resource to your browser scope in web/router.ex:</span><span id="cdc5" class="jp jq hu lj b fv lr lo l lp lq">    resources "/posts", PostController</span><span id="7019" class="jp jq hu lj b fv lr lo l lp lq">Remember to update your repository by running migrations:</span><span id="8348" class="jp jq hu lj b fv lr lo l lp lq">    $ mix ecto.migrate</span></pre><p id="2061" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，为了使这个脚手架可访问(并阻止Elixir抱怨)，我们将打开web/router.ex，并将以下内容添加到我们的根作用域(使用<strong class="it hv"> :browser </strong>管道的“/”作用域):</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="7696" class="jp jq hu lj b fv ln lo l lp lq">resources "/posts", PostController</span></pre><p id="015d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我们将通过调用<strong class="it hv"> mix ecto.migrate </strong>来确保我们的数据库加载了这个新的迁移。</p><p id="de27" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">输出:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="658f" class="jp jq hu lj b fv ln lo l lp lq">Compiling 9 files (.ex)<br/>Generated pxblog app</span><span id="c4f8" class="jp jq hu lj b fv lr lo l lp lq">15:52:20.004 [info]  == Running Pxblog.Repo.Migrations.CreatePost.change/0 forward</span><span id="4736" class="jp jq hu lj b fv lr lo l lp lq">15:52:20.004 [info]  create table posts</span><span id="f9a2" class="jp jq hu lj b fv lr lo l lp lq">15:52:20.019 [info]  == Migrated in 0.0s</span></pre><p id="fa8f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，让我们重新启动我们的服务器，然后访问<a class="ae ld" href="http://localhost:4000/posts" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/posts</a>，我们应该看到“Listing posts”标题和一个包含我们对象中的列的表格。</p><p id="25d0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">稍微摆弄一下，你应该能够创建新帖子、编辑帖子和删除帖子。对于很少的工作来说很酷！</p><h2 id="644f" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">步骤1B:职位的写作测试</h2><p id="be59" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">从一开始就使用脚手架的美妙之处在于，它将从一开始就为我们创建基线测试。我们甚至还不需要做太多的修改，因为我们还没有真正改变任何框架，但是让我们分析一下为我们创建了什么，以便我们可以更好地准备以后编写我们自己的测试。</p><p id="3bd7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，我们将打开<strong class="it hv">test/models/post _ test . exs</strong>看一看:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="6e52" class="jp jq hu lj b fv ln lo l lp lq">defmodule Pxblog.PostTest do<br/>  use Pxblog.ModelCase</span><span id="4574" class="jp jq hu lj b fv lr lo l lp lq">  alias Pxblog.Post</span><span id="0dac" class="jp jq hu lj b fv lr lo l lp lq">  @valid_attrs %{body: "some content", title: "some content"}<br/>  @invalid_attrs %{}</span><span id="0187" class="jp jq hu lj b fv lr lo l lp lq">  test "changeset with valid attributes" do<br/>    changeset = Post.changeset(%Post{}, @valid_attrs)<br/>    assert changeset.valid?<br/>  end</span><span id="168f" class="jp jq hu lj b fv lr lo l lp lq">  test "changeset with invalid attributes" do<br/>    changeset = Post.changeset(%Post{}, @invalid_attrs)<br/>    refute changeset.valid?<br/>  end<br/>end</span></pre><p id="e3b1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们把这个拆开，了解一下是怎么回事。</p><blockquote class="lt lu lv"><p id="a0d4" class="ir is ls it b iu iv iw ix iy iz ja jb lw jd je jf lx jh ji jj ly jl jm jn jo hn dt translated">defmodule Pxblog。测试后do</p></blockquote><p id="982a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">显然，我们需要使用应用程序的名称空间来定义测试模块。</p><blockquote class="lt lu lv"><p id="0a4c" class="ir is ls it b iu iv iw ix iy iz ja jb lw jd je jf lx jh ji jj ly jl jm jn jo hn dt translated">用Pxblog。模型案例</p></blockquote><p id="1818" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，我们告诉这个模块，它将使用ModelCase宏集引入的函数和DSL。</p><blockquote class="lt lu lv"><p id="a6b6" class="ir is ls it b iu iv iw ix iy iz ja jb lw jd je jf lx jh ji jj ly jl jm jn jo hn dt translated">别名Pxblog。邮政</p></blockquote><p id="b342" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在确保测试能够看到模型本身。</p><blockquote class="lt lu lv"><p id="4039" class="ir is ls it b iu iv iw ix iy iz ja jb lw jd je jf lx jh ji jj ly jl jm jn jo hn dt translated">@valid_attrs %{body:“某内容”，title:“某内容”}</p></blockquote><p id="5fcf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">设置一些能够创建成功变更集的基本有效属性。这只是提供了一个模块级的变量，每当我们希望能够创建一个有效的模型时，我们都可以从中提取变量。</p><blockquote class="lt lu lv"><p id="d69d" class="ir is ls it b iu iv iw ix iy iz ja jb lw jd je jf lx jh ji jj ly jl jm jn jo hn dt translated">@invalid_attrs %{}</p></blockquote><p id="3fd1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如上所述，但是不出所料，创建了一个无效的属性集。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="ccd8" class="jp jq hu lj b fv ln lo l lp lq">test "changeset with valid attributes" do<br/>  changeset = Post.changeset(%Post{}, @valid_attrs)<br/>  assert changeset.valid?<br/>end</span></pre><p id="6ccc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们通过使用“test”函数给它一个基于字符串的名称来创建我们的测试。在我们的函数体内部，我们首先从Post模型创建一个变更集(给它一个空结构和有效参数列表)。然后我们断言变更集是有效的，因为这就是我们对@valid_attrs变量的期望。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="c003" class="jp jq hu lj b fv ln lo l lp lq">test "changeset with invalid attributes" do<br/>  changeset = Post.changeset(%Post{}, @invalid_attrs)<br/>  refute changeset.valid?<br/>end</span></pre><p id="7138" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我们检查是否创建了带有无效参数列表的变更集，并且不是断言变更集是有效的，而是执行相反的操作。反驳本质上是断言不真实。</p><p id="2ae3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个如何编写模型测试文件的很好的例子。现在让我们来看看控制器测试。</p><p id="9eb0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们看看顶部，因为所有的看起来大致相同:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="5b6c" class="jp jq hu lj b fv ln lo l lp lq">defmodule Pxblog.PostControllerTest do<br/>  use Pxblog.ConnCase</span><span id="8a0d" class="jp jq hu lj b fv lr lo l lp lq">  alias Pxblog.Post<br/>  @valid_attrs %{body: "some content", title: "some content"}<br/>  @invalid_attrs %{}</span></pre><p id="fc0f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第一个变更集可以看到的是Pxblog。ConnCase我们依赖用于控制器级测试的DSL。除此之外，其余的台词应该很熟悉了。</p><p id="3e70" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们来看看第一个测试:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="6a33" class="jp jq hu lj b fv ln lo l lp lq">test "lists all entries on index", %{conn: conn} do<br/>  conn = get conn, post_path(conn, :index)<br/>  assert html_response(conn, 200) =~ "Listing posts"<br/>end</span></pre><p id="a517" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这里，我们获取将通过ConnCase中的设置块发送的“conn”变量。这个我以后再解释。下一步是我们调用适当的动词来访问预期的路线，在我们的例子中，这是针对我们的索引操作的get请求。</p><p id="571a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，我们断言这个动作的响应返回状态为200(“ok”)的HTML，并包含短语“Listing posts”</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="7029" class="jp jq hu lj b fv ln lo l lp lq">test "renders form for new resources", %{conn: conn} do<br/>  conn = get conn, post_path(conn, :new)<br/>  assert html_response(conn, 200) =~ "New post"<br/>end</span></pre><p id="7f94" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下一个测试基本上是相同的，但是我们只是验证“新”动作。简单的东西。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="6873" class="jp jq hu lj b fv ln lo l lp lq">test "creates resource and redirects when data is valid", %{conn: conn} do<br/>  conn = post conn, post_path(conn, :create), post: @valid_attrs<br/>  assert redirected_to(conn) == post_path(conn, :index)<br/>  assert Repo.get_by(Post, @valid_attrs)<br/>end</span></pre><p id="7683" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们正在做一些新的事情。首先，这次我们向<strong class="it hv"> post_path </strong>助手发送有效参数列表。我们期望被重定向到post资源的索引路径。<strong class="it hv"> redirected_to </strong>接受一个连接对象作为参数，因为我们需要看到这个连接对象被重定向到哪里。</p><p id="db06" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，通过查询我们的Ecto Repo，寻找与我们的@valid_attrs参数匹配的Post模型，我们断言由这些有效参数表示的对象被成功地插入到数据库中。</p><p id="e12d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们要测试创建新帖子的负面路径。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="9205" class="jp jq hu lj b fv ln lo l lp lq">test "does not create resource and renders errors when data is invalid", %{conn: conn} do<br/>  conn = post conn, post_path(conn, :create), post: @invalid_attrs<br/>  assert html_response(conn, 200) =~ "New post"<br/>end</span></pre><p id="5a19" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，我们使用invalid_attrs参数列表向相同的创建路径进行post，并断言它再次呈现新的Post表单。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="b4ea" class="jp jq hu lj b fv ln lo l lp lq">test "shows chosen resource", %{conn: conn} do<br/>  post = Repo.insert! %Post{}<br/>  conn = get conn, post_path(conn, :show, post)<br/>  assert html_response(conn, 200) =~ "Show post"<br/>end</span></pre><p id="d155" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了测试我们的显示动作，我们确保创建一个Post模型来使用。然后，我们调用post_path助手的get函数，并确保它返回适当的资源。但是，如果我们试图获取一个不存在的资源的显示路径，我们会执行以下操作:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="624b" class="jp jq hu lj b fv ln lo l lp lq">test "renders page not found when id is nonexistent", %{conn: conn} do<br/>  assert_error_sent 404, fn -&gt;<br/>    get conn, post_path(conn, :show, -1)<br/>  end<br/>end</span></pre><p id="f7d0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们在这里看到了一个新的模式，但它实际上很容易理解。我们希望，如果我们获取一个不存在的资源，我们应该收到一个404。然后，我们向它传递一个匿名函数，该函数包含我们要执行的代码，该代码应该会返回错误。简单！</p><p id="bcd7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了我们的删除操作之外，其余的测试只是对每个路径重复上面的测试。让我们来看看:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="78fd" class="jp jq hu lj b fv ln lo l lp lq">test "deletes chosen resource", %{conn: conn} do<br/>  post = Repo.insert! %Post{}<br/>  conn = delete conn, post_path(conn, :delete, post)<br/>  assert redirected_to(conn) == post_path(conn, :index)<br/>  refute Repo.get(Post, post.id)<br/>end</span></pre><p id="5eaa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这里，我们看到的大部分是相同的，除了使用我们的删除动词。我们断言，我们从删除页面重定向回索引，但是我们在这里做了一些新的事情:我们驳斥了Post对象不再存在的说法。断言和反驳都是真的，所以一个对象的存在将与断言一起工作，并导致反驳失败。</p><p id="4a55" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们没有向视图添加任何代码，所以我们没有对PostView模块做任何事情。</p><h2 id="4891" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">步骤2:添加用户</h2><p id="e8c1" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">除了几个不同的列之外，我们将遵循与创建Post对象几乎完全相同的步骤来创建用户对象。首先，我们将运行:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="dce3" class="jp jq hu lj b fv ln lo l lp lq">$ mix phoenix.gen.html User users username:string email:string password_digest:string</span></pre><p id="8200" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">输出:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="18c5" class="jp jq hu lj b fv ln lo l lp lq">* creating web/controllers/user_controller.ex<br/>...</span><span id="e5ca" class="jp jq hu lj b fv lr lo l lp lq">Add the resource to your browser scope in web/router.ex:</span><span id="1ec6" class="jp jq hu lj b fv lr lo l lp lq">    resources "/users", UserController</span><span id="9c4c" class="jp jq hu lj b fv lr lo l lp lq">Remember to update your repository by running migrations:</span><span id="f91e" class="jp jq hu lj b fv lr lo l lp lq">    $ mix ecto.migrate</span></pre><p id="a66a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，我们将打开web/router.ex，并再次将以下内容添加到我们的浏览器范围中:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="845c" class="jp jq hu lj b fv ln lo l lp lq">resources "/users", UserController</span></pre><p id="3550" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里的语法定义了一个标准的资源路由，其中第一个参数是URL，第二个是控制器的类名。然后，我们将运行mix ecto.migrate</p><p id="ecc9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">输出:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="0976" class="jp jq hu lj b fv ln lo l lp lq">Compiling 11 files (.ex)<br/>Generated pxblog app</span><span id="8d8f" class="jp jq hu lj b fv lr lo l lp lq">16:02:03.987 [info]  == Running Pxblog.Repo.Migrations.CreateUser.change/0 forward</span><span id="bca2" class="jp jq hu lj b fv lr lo l lp lq">16:02:03.987 [info]  create table users</span><span id="75e4" class="jp jq hu lj b fv lr lo l lp lq">16:02:03.996 [info]  == Migrated in 0.0s</span></pre><p id="95d9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，重启服务器并查看<a class="ae ld" href="http://localhost:4000/users." rel="noopener ugc nofollow" target="_blank"> http://localhost:4000/users。</a>我们现在可以独立创建帖子和用户了！不幸的是，这还不是一个非常有用的博客。毕竟，我们可以创建用户(事实上，任何人都可以)，但我们甚至不能登录。另外，密码摘要不是来自任何加密算法；用户只是创建它们，我们以纯文本的形式存储它们！不好了。</p><p id="bbd8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将使它看起来更像一个真实的用户注册屏幕。</p><p id="f009" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们对用户内容的测试看起来与为我们的帖子自动生成的测试完全一样，所以我们将把它们放在一边，直到我们开始修改逻辑(也就是现在！)</p><h2 id="cd8b" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">步骤3:保存密码哈希而不是密码</h2><p id="95c3" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">当我们访问<strong class="it hv"> /users/new </strong>时，我们看到三个字段:<strong class="it hv">用户名</strong>、<strong class="it hv">邮箱</strong>和<strong class="it hv">密码摘要</strong>。但是当你在其他网站注册时，你需要输入密码并确认密码！我们如何纠正这种情况？</p><p id="e456" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<strong class="it hv">web/templates/user/form . html . eex</strong>中，删除以下几行:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="ca27" class="jp jq hu lj b fv ln lo l lp lq">&lt;div class=”form-group”&gt;<br/>  &lt;%= label f, :password_digest, class: “control-label” %&gt;<br/>  &lt;%= text_input f, :password_digest, class: “form-control” %&gt;<br/>  &lt;%= error_tag f, :password_digest %&gt;<br/>&lt;/div&gt;</span></pre><p id="c593" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">并在它的位置添加:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="3f82" class="jp jq hu lj b fv ln lo l lp lq">&lt;div class="form-group"&gt;<br/>  &lt;%= label f, :password, "Password", class: "control-label" %&gt;<br/>  &lt;%= password_input f, :password, class: "form-control" %&gt;<br/>  &lt;%= error_tag f, :password %&gt;<br/>&lt;/div&gt;<br/><br/>&lt;div class="form-group"&gt;<br/>  &lt;%= label f, :password_confirmation, "Password Confirmation", class: "control-label" %&gt;<br/>  &lt;%= password_input f, :password_confirmation, class: "form-control" %&gt;<br/>  &lt;%= error_tag f, :password_confirmation %&gt;<br/>&lt;/div&gt;</span></pre><p id="79dd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">刷新页面(应该会自动发生)，输入用户详细信息，点击提交。</p><p id="e0a2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">错误:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="f322" class="jp jq hu lj b fv ln lo l lp lq">Oops, something went wrong! Please check the errors below.</span></pre><p id="0269" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是因为我们正在创建一个密码和密码确认，但是没有做任何事情来创建实际的password_digest。让我们编写一些代码来实现这一点。首先，我们将修改实际的模式来做一些新的事情:</p><p id="bb94" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<strong class="it hv"> web/models/user.ex </strong>中:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="1241" class="jp jq hu lj b fv ln lo l lp lq">schema "users" do<br/>  field :username, :string<br/>  field :email, :string<br/>  field :password_digest, :string</span><span id="0222" class="jp jq hu lj b fv lr lo l lp lq">  timestamps</span><span id="50be" class="jp jq hu lj b fv lr lo l lp lq">  # Virtual Fields<br/>  field :password, :string, virtual: true<br/>  field :password_confirmation, :string, virtual: true  <br/>end</span></pre><p id="d189" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意添加了两个字段:密码和密码确认。我们将这些字段声明为<strong class="it hv">虚拟</strong>字段，因为它们实际上并不存在于我们的数据库中，而是需要作为属性存在于我们的用户结构中。这也允许我们在变更集函数中应用转换。</p><p id="83e3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，我们修改必填字段和强制转换字段的列表，以包括:<strong class="it hv">密码</strong>和:<strong class="it hv">密码_确认</strong>。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="f72f" class="jp jq hu lj b fv ln lo l lp lq">def changeset(struct, params \\ %{}) do<br/>  struct<br/>  |&gt; cast(params, [:username, :email, :password, :password_confirmation])<br/>  |&gt; validate_required([:username, :email, :password, :password_confirmation])<br/>end</span></pre><p id="347a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您此时运行<strong class="it hv">test/models/user _ test . exs</strong>，您会注意到我们的“具有有效属性的变更集”测试现在失败了。这是因为我们要求输入password和password_confirmation，但是没有更新我们的@valid_attrs映射来包含这两者。让我们把这一行改成:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="2c6e" class="jp jq hu lj b fv ln lo l lp lq">@valid_attrs %{email: "<a class="ae ld" href="mailto:test@test.com" rel="noopener ugc nofollow" target="_blank">test@test.com</a>", password: "test1234", password_confirmation: "test1234", username: "testuser"}</span></pre><p id="f346" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的模型测试应该马上就能通过了！我们还需要通过控制器测试。在<strong class="it hv">test/controllers/user _ controller _ test . exs</strong>中，我们会做一些修改。首先，我们将区分有效的创建属性和有效的搜索属性:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="b84c" class="jp jq hu lj b fv ln lo l lp lq">@valid_create_attrs %{email: "<a class="ae ld" href="mailto:test@test.com" rel="noopener ugc nofollow" target="_blank">test@test.com</a>", password: "test1234", password_confirmation: "test1234", username: "testuser"}<br/>@valid_attrs %{email: "<a class="ae ld" href="mailto:test@test.com" rel="noopener ugc nofollow" target="_blank">test@test.com</a>", username: "testuser"}</span></pre><p id="3b95" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我们将修改我们的创建测试:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="8aba" class="jp jq hu lj b fv ln lo l lp lq">test "creates resource and redirects when data is valid", %{conn: conn} do<br/>  conn = post conn, user_path(conn, :create), user: @valid_create_attrs<br/>  assert redirected_to(conn) == user_path(conn, :index)<br/>  assert Repo.get_by(User, @valid_attrs)<br/>end</span></pre><p id="8850" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的更新测试:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="988a" class="jp jq hu lj b fv ln lo l lp lq">test "updates chosen resource and redirects when data is valid", %{conn: conn} do<br/>  user = Repo.insert! %User{}<br/>  conn = put conn, user_path(conn, :update, user), user: @valid_create_attrs<br/>  assert redirected_to(conn) == user_path(conn, :show, user)<br/>  assert Repo.get_by(User, @valid_attrs)<br/>end</span></pre><p id="b19e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">随着我们的测试变回绿色，我们需要修改changeset函数，将我们的密码动态地更改为密码摘要:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="ea40" class="jp jq hu lj b fv ln lo l lp lq">def changeset(struct, params \\ %{}) do<br/>    struct<br/>    |&gt; cast(params, [:username, :email, :password, :password_confirmation])<br/>    |&gt; validate_required([:username, :email, :password, :password_confirmation])<br/>    |&gt; hash_password<br/>  end</span><span id="a63a" class="jp jq hu lj b fv lr lo l lp lq">defp hash_password(changeset) do<br/>    changeset<br/>    |&gt; put_change(:password_digest, "ABCDE")<br/>  end</span></pre><p id="585d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们只是在研究散列函数的行为。第一步是确保我们可以在进行过程中修改我们的变更集。先验证一下这个行为。在我们的浏览器中返回到<a class="ae ld" href="http://localhost:4000/users" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/users</a>，点击“New user ”,创建一个包含任何详细信息的新用户。当我们再次点击索引页面时，我们应该会看到使用“ABCDE”的password_digest值创建的用户。</p><p id="a668" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">并再次对该文件进行测试。我们的测试通过了，但是我们还没有为这个新的<strong class="it hv"> hash_password </strong>工作添加任何测试。让我们在模型测试套件中添加一个测试，它将添加一个关于密码摘要的测试:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="0900" class="jp jq hu lj b fv ln lo l lp lq">test "password_digest value gets set to a hash" do<br/>  changeset = User.changeset(%User{}, @valid_attrs)<br/>  assert get_change(changeset, :password_digest) == "ABCDE"<br/>end</span></pre><p id="c55a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个很大的进步，但是对于安全性来说并不是很好！让我们用Bcrypt修改我们的散列，使之成为真正的密码散列，这是由<strong class="it hv">come on</strong>库提供的。</p><p id="6b25" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，打开<strong class="it hv"> mix.exs </strong>，将<strong class="it hv">:come on</strong>添加到我们的应用列表中:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="5e32" class="jp jq hu lj b fv ln lo l lp lq">def application do<br/>    [mod: {Pxblog, []},<br/>     applications: [:phoenix, :phoenix_pubsub, :phoenix_html, :cowboy, :logger, :gettext,<br/>                    :phoenix_ecto, :postgrex, :comeonin]]<br/>  end</span></pre><p id="fc88" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还需要修改我们的deps定义:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="cc59" class="jp jq hu lj b fv ln lo l lp lq">defp deps do<br/>  [{:phoenix, "~&gt; 1.2.0"},<br/>   {:phoenix_pubsub, "~&gt; 1.0"},<br/>   {:phoenix_ecto, "~&gt; 3.0"},<br/>   {:postgrex, "&gt;= 0.0.0"},<br/>   {:phoenix_html, "~&gt; 2.6"},<br/>   {:phoenix_live_reload, "~&gt; 1.0", only: :dev},<br/>   {:gettext, "~&gt; 0.11"},<br/>   {:cowboy, "~&gt; 1.0"},<br/>   {:comeonin, "~&gt; 2.3"}]<br/>end</span></pre><p id="69b7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里也一样，注意增加了<strong class="it hv"> {:comeonin，" ~ &gt; 2.3"} </strong>。现在，让我们关闭一直在运行的服务器，运行<strong class="it hv"> mix deps.get </strong>。如果一切顺利(应该的！)，那么现在你应该能够重新运行<strong class="it hv"> iex -S mix phoenix.server </strong>来重启你的服务器。</p><p id="aeda" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们旧的<strong class="it hv"> hash_password </strong>方法很简洁，但是我们需要用它来散列我们的密码。因为我们已经添加了<strong class="it hv">come on</strong>库，它为我们提供了一个带有hashpwsalt方法的Bcrypt模块，所以让我们将它导入到我们的用户模型中。</p><p id="dac1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<strong class="it hv"> web/models/user.ex </strong>中，在我们的<strong class="it hv"> use Pxblog下添加下面一行。网，:型号</strong>线:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="f508" class="jp jq hu lj b fv ln lo l lp lq">import Comeonin.Bcrypt, only: [hashpwsalt: 1]</span></pre><p id="b59d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们在这里做的是将Bcrypt模块拉入Comeonin名称空间下，并导入arity为1的hashpwsalt方法。现在我们要修改我们的<strong class="it hv"> hash_password </strong>方法来工作。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="814d" class="jp jq hu lj b fv ln lo l lp lq">defp hash_password(changeset) do<br/>  if password = get_change(changeset, :password) do<br/>    changeset<br/>    |&gt; put_change(:password_digest, hashpwsalt(password))<br/>  else<br/>    changeset<br/>  end<br/>end</span></pre><p id="cf0d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们再次尝试创建一个用户！这一次，在输入我们的用户名、电子邮件、密码和密码确认数据后，我们应该看到一个加密的摘要显示在<strong class="it hv"> password_digest </strong>字段中！</p><p id="a928" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们将想要处理我们添加的<strong class="it hv"> hash_password </strong>函数。我们要做的第一件事是更改我们测试环境的配置，以确保我们的测试在使用密码加密时不会明显变慢。打开<strong class="it hv"> config/test.exs </strong>并在底部添加以下内容:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="d826" class="jp jq hu lj b fv ln lo l lp lq">config :comeonin, bcrypt_log_rounds: 4</span></pre><p id="72dd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将配置ComeOnIn，当它在我们的测试环境中时，不要太努力地加密我们的密码。由于这只是为了测试，我们不需要任何超级安全的东西，而是更喜欢理智和速度！在<strong class="it hv"> config/prod.exs </strong>中，我们希望改为:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="046d" class="jp jq hu lj b fv ln lo l lp lq">config :comeonin, bcrypt_log_rounds: 14</span></pre><p id="d46f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们为comeonin调用编写一个测试。我们会说得不那么具体。我们只想验证加密。在<strong class="it hv">test/models/user _ test . exs</strong>中:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="e957" class="jp jq hu lj b fv ln lo l lp lq">test "password_digest value gets set to a hash" do<br/>  changeset = User.changeset(%User{}, @valid_attrs)<br/>  assert Comeonin.Bcrypt.checkpw(@valid_attrs.password, Ecto.Changeset.get_change(changeset, :password_digest))<br/>end</span></pre><p id="47d4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于更多的测试覆盖，让我们添加一个案例来处理没有命中password = get_change()行的情况:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="cedb" class="jp jq hu lj b fv ln lo l lp lq">test "password_digest value does not get set if password is nil" do<br/>  changeset = User.changeset(%User{}, %{email: "test@test.com", password: nil, password_confirmation: nil, username: "test"})<br/>  refute Ecto.Changeset.get_change(changeset, :password_digest)<br/>end</span></pre><p id="1e4b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于assert/reject使用了truthiness，我们可以看看这段代码是否将<strong class="it hv"> password_digest </strong>留空，它确实留空了！我们在用规范覆盖我们的工作方面做得很好！</p><h2 id="78b5" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">第四步:登录吧！</h2><p id="641b" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">让我们添加一个新的控制器SessionController和一个伴随的视图SessionView。我们将从简单开始，随着时间的推移，逐步实现更好的实现。</p><p id="86cf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">创建<strong class="it hv">网络/控制器/会话_控制器. ex: </strong></p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="a27c" class="jp jq hu lj b fv ln lo l lp lq">defmodule Pxblog.SessionController do<br/>  use Pxblog.Web, :controller</span><span id="5f22" class="jp jq hu lj b fv lr lo l lp lq">  def new(conn, _params) do<br/>    render conn, "new.html"<br/>  end<br/>end</span></pre><p id="de5e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">创建<strong class="it hv">web/views/session _ view . ex</strong>:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="6d17" class="jp jq hu lj b fv ln lo l lp lq">defmodule Pxblog.SessionView do<br/>  use Pxblog.Web, :view<br/>end</span></pre><p id="670f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">创建web/templates/session/new . html . eex:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="8075" class="jp jq hu lj b fv ln lo l lp lq">&lt;h2&gt;Login&lt;/h2&gt;</span></pre><p id="4ca0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，让我们更新路由器以包括这个新的控制器。将下面一行添加到我们的“/”范围中:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="d017" class="jp jq hu lj b fv ln lo l lp lq">resources "/sessions", SessionController, only: [:new]</span></pre><p id="c8f6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">目前我们想公开的唯一路线是<strong class="it hv">新</strong>，所以我们将仅限于此。同样，我们希望事情简单，并建立在稳定的基础上。</p><p id="d6f2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们访问<a class="ae ld" href="http://localhost:4000/sessions/new" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/sessions/new</a>，我们应该会看到Phoenix框架头和“Login”头。</p><p id="05b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们给它一个真实的形式。创建<strong class="it hv">web/templates/session/form . html . eex</strong></p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="a00c" class="jp jq hu lj b fv ln lo l lp lq">&lt;%= form_for @changeset, @action, fn f -&gt; %&gt;<br/>  &lt;%= if f.errors != [] do %&gt;<br/>    &lt;div class="alert alert-danger"&gt;<br/>      &lt;p&gt;Oops, something went wrong! Please check the errors below:&lt;/p&gt;<br/>      &lt;ul&gt;<br/>        &lt;%= for {attr, message} &lt;- f.errors do %&gt;<br/>          &lt;li&gt;&lt;%= humanize(attr) %&gt; &lt;%= message %&gt;&lt;/li&gt;<br/>        &lt;% end %&gt;<br/>      &lt;/ul&gt;<br/>    &lt;/div&gt;<br/>  &lt;% end %&gt;</span><span id="5a58" class="jp jq hu lj b fv lr lo l lp lq">  &lt;div class="form-group"&gt;<br/>    &lt;label&gt;Username&lt;/label&gt;<br/>    &lt;%= text_input f, :username, class: "form-control" %&gt;<br/>  &lt;/div&gt;</span><span id="b58e" class="jp jq hu lj b fv lr lo l lp lq">  &lt;div class="form-group"&gt;<br/>    &lt;label&gt;Password&lt;/label&gt;<br/>    &lt;%= password_input f, :password, class: "form-control" %&gt;<br/>  &lt;/div&gt;</span><span id="efde" class="jp jq hu lj b fv lr lo l lp lq">  &lt;div class="form-group"&gt;<br/>    &lt;%= submit "Submit", class: "btn btn-primary" %&gt;<br/>  &lt;/div&gt;<br/>&lt;% end %&gt;</span></pre><p id="5527" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">并修改<strong class="it hv">web/templates/session/new . html . eex</strong>通过添加一行来调用我们的新表单:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="6cca" class="jp jq hu lj b fv ln lo l lp lq">&lt;%= render "form.html", changeset: @changeset, action: session_path(@conn, :create) %&gt;</span></pre><p id="1239" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">自动重新加载将立即显示一个错误页面，因为我们实际上还没有定义<strong class="it hv"> @changeset </strong>，正如您所猜测的，它需要是一个变更集。因为我们使用的是成员对象，上面已经有了用户名和密码字段，让我们使用它吧！</p><p id="886c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<strong class="it hv">web/controllers/session _ controller . ex</strong>中，我们需要为用户模型添加别名，以便能够进一步使用它。在我们班的最上面，在我们的<strong class="it hv">下面用Pxblog。Web，:控制器</strong>行，添加以下内容:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="2b6b" class="jp jq hu lj b fv ln lo l lp lq">alias Pxblog.User</span></pre><p id="0f82" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">并在<strong class="it hv">新增的</strong>函数中，修改调用呈现如下:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="41ce" class="jp jq hu lj b fv ln lo l lp lq">render conn, "new.html", changeset: User.changeset(%User{})</span></pre><p id="9ec8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们需要向它传递连接、我们正在呈现的模板(不包括eex)以及应该向我们的模板公开的其他变量的列表。在这种情况下，我们希望公开@changeset，所以我们在这里指定changeset:并为具有空白用户结构的用户赋予它Ecto changeset。(%User{}是未设置值的用户结构)</p><p id="fc09" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在刷新，我们会得到类似如下的不同错误消息:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="33fa" class="jp jq hu lj b fv ln lo l lp lq">No helper clause for Pxblog.Router.Helpers.session_path/2 defined for action :create.<br/>The following session_path actions are defined under your router:    <br/>*:new</span></pre><p id="f6c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们的表单中，我们引用了一条实际上还不存在的路线！我们使用session_path帮助器，向它传递@conn对象，然后指定:create路径，我们还没有创建它。</p><p id="6816" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们已经走了一段路。现在，让我们创建它，这样我们就可以发布我们的登录详细信息并设置会话。</p><p id="0157" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们更新我们的路线，以允许发布创建。</p><p id="7a05" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<strong class="it hv"> web/router.ex </strong>中，将我们对SessionController的引用也改为包含:create。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="cc84" class="jp jq hu lj b fv ln lo l lp lq">resources "/sessions", SessionController, only: [:new, :create]</span></pre><p id="1a49" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<strong class="it hv">web/controllers/session _ controller . ex</strong>中，我们需要从Comeonin的Bcrypt模块中导入一个新的函数checkpw。我们通过以下代码行实现这一点:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="79a2" class="jp jq hu lj b fv ln lo l lp lq">import Comeonin.Bcrypt, only: [checkpw: 2]</span></pre><p id="96d7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这一行写着“从美国进口”。Bcrypt模块，但只有arity为2”的checkpw函数。然后让我们添加一个scrub_params插件来处理用户数据。在我们的函数之前，我们将添加:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="f04f" class="jp jq hu lj b fv ln lo l lp lq">plug :scrub_params, "user" when action in [:create]</span></pre><p id="f383" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">“scrub_params”是清理任何用户输入的特殊函数；例如，在某些内容作为空字符串传入的情况下，scrub_params会将其转换为一个nil值，以避免在数据库中创建包含空字符串的条目。</p><p id="0fa0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们添加我们的函数来处理创建帖子。我们将把它添加到SessionController模块的底部。这里会有很多代码，所以我们会一点一点来。</p><p id="89fe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<strong class="it hv">web/controllers/session _ controller . ex</strong>中:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="de9f" class="jp jq hu lj b fv ln lo l lp lq">def create(conn, %{"user" =&gt; user_params}) do<br/>    Repo.get_by(User, username: user_params["username"])<br/>    |&gt; sign_in(user_params["password"], conn)<br/>  end</span></pre><p id="4849" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这段代码的第一位，<strong class="it hv"> Repo.get_by(User，username:User _ params[" username "])</strong>从我们的Ecto Repo中提取具有匹配用户名的第一个适用用户，否则将返回nil。</p><p id="fc2f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是验证这种行为的一些输出:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="4a14" class="jp jq hu lj b fv ln lo l lp lq">iex(3)&gt; Repo.get_by(User, username: "flibbity")<br/>[debug] SELECT u0."id", u0."username", u0."email", u0."password_digest", u0."inserted_at", u0."updated_at" FROM "users" AS u0 WHERE (u0."username" = $1) ["flibbity"] OK query=0.7ms<br/>nil</span><span id="f756" class="jp jq hu lj b fv lr lo l lp lq">iex(4)&gt; Repo.get_by(User, username: "test")<br/>[debug] SELECT u0."id", u0."username", u0."email", u0."password_digest", u0."inserted_at", u0."updated_at" FROM "users" AS u0 WHERE (u0."username" = $1) ["test"] OK query=0.8ms<br/>%Pxblog.User{__meta__: %Ecto.Schema.Metadata{source: "users", state: :loaded},<br/> email: "test", id: 15,<br/> inserted_at: %Ecto.DateTime{day: 24, hour: 19, min: 6, month: 6, sec: 14,<br/>  usec: 0, year: 2015}, password: nil, password_confirmation: nil,<br/> password_digest: "$2b$12$RRkTZiUoPVuIHMCJd7yZUOnAptSFyM9Hw3Aa88ik4erEsXTZQmwu2",<br/> updated_at: %Ecto.DateTime{day: 24, hour: 19, min: 6, month: 6, sec: 14,<br/>  usec: 0, year: 2015}, username: "test"}</span></pre><p id="91f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我们获取用户，并将该用户链接到一个sign_in方法中。我们还没有写，所以让我们这样做吧！</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="e35f" class="jp jq hu lj b fv ln lo l lp lq">defp sign_in(user, password, conn) when is_nil(user) do<br/>  conn<br/>  |&gt; put_flash(:error, "Invalid username/password combination!")<br/>  |&gt; redirect(to: page_path(conn, :index))<br/>end</span><span id="0cf1" class="jp jq hu lj b fv lr lo l lp lq">defp sign_in(user, password, conn) do<br/>  if checkpw(password, user.password_digest) do<br/>    conn<br/>    |&gt; put_session(:current_user, %{id: user.id, username: user.username})<br/>    |&gt; put_flash(:info, "Sign in successful!")<br/>    |&gt; redirect(to: page_path(conn, :index))<br/>  else<br/>    conn<br/>    |&gt; put_session(:current_user, nil)<br/>    |&gt; put_flash(:error, "Invalid username/password combination!")<br/>    |&gt; redirect(to: page_path(conn, :index))<br/>  end<br/>end</span></pre><p id="d4fa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先要注意的是这些方法在。这些方法中的第一个有一个附加的guard子句，所以该方法只有在guard子句为真时才会被执行，所以如果用户是nil，我们用适当的flash消息重定向回页面(根)路径的索引。</p><p id="1df9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果guard子句为false，将调用第二个方法，该方法将处理所有其他场景。我们检查checkpw函数的结果，如果结果为真，我们将用户设置为current_user会话变量，并使用成功消息进行重定向。否则，我们清除当前的用户会话，设置一个错误消息，并重定向回根目录。</p><p id="3196" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们返回到我们的登录页面http://localhost:4000/sessions/new，我们应该能够用一组有效的凭据和无效的凭据测试登录，并看到相应的错误消息！</p><p id="5ab4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还需要为这个控制器写一些规范。我们将创建<strong class="it hv">test/controllers/session _ controller _ test . exs</strong>，并用以下内容填充它:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="f88e" class="jp jq hu lj b fv ln lo l lp lq">defmodule Pxblog.SessionControllerTest do<br/>  use Pxblog.ConnCase<br/>  alias Pxblog.User</span><span id="b999" class="jp jq hu lj b fv lr lo l lp lq">  setup do<br/>    User.changeset(%User{}, %{username: "test", password: "test", password_confirmation: "test", email: "<a class="ae ld" href="mailto:test@test.com" rel="noopener ugc nofollow" target="_blank">test@test.com</a>"})<br/>    |&gt; Repo.insert<br/>    {:ok, conn: build_conn()}<br/>  end</span><span id="dfbb" class="jp jq hu lj b fv lr lo l lp lq">  test "shows the login form", %{conn: conn} do<br/>    conn = get conn, session_path(conn, :new)<br/>    assert html_response(conn, 200) =~ "Login"<br/>  end</span><span id="7769" class="jp jq hu lj b fv lr lo l lp lq">  test "creates a new user session for a valid user", %{conn: conn} do<br/>    conn = post conn, session_path(conn, :create), user: %{username: "test", password: "test"}<br/>    assert get_session(conn, :current_user)<br/>    assert get_flash(conn, :info) == "Sign in successful!"<br/>    assert redirected_to(conn) == page_path(conn, :index)<br/>  end</span><span id="42ab" class="jp jq hu lj b fv lr lo l lp lq">  test "does not create a session with a bad login", %{conn: conn} do<br/>    conn = post conn, session_path(conn, :create), user: %{username: "test", password: "wrong"}<br/>    refute get_session(conn, :current_user)<br/>    assert get_flash(conn, :error) == "Invalid username/password combination!"<br/>    assert redirected_to(conn) == page_path(conn, :index)<br/>  end</span><span id="8854" class="jp jq hu lj b fv lr lo l lp lq">  test "does not create a session if user does not exist", %{conn: conn} do    <br/>    conn = post conn, session_path(conn, :create), user: %{username: "foo", password: "wrong"}<br/>    assert get_flash(conn, :error) == "Invalid username/password combination!"<br/>    assert redirected_to(conn) == page_path(conn, :index)<br/>  end<br/>end</span></pre><p id="b9f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们从标准设置块开始，为get请求编写一个非常标准的断言。这开始变得更有趣了:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="b682" class="jp jq hu lj b fv ln lo l lp lq">test "creates a new user session for a valid user", %{conn: conn} do<br/>  conn = post conn, session_path(conn, :create), user: %{username: "test", password: "test"}<br/>  assert get_session(conn, :current_user)<br/>  assert get_flash(conn, :info) == "Sign in successful!"<br/>  assert redirected_to(conn) == page_path(conn, :index)<br/>end</span></pre><p id="7173" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里的第一部分是提交到我们的会话创建路径。然后，我们验证我们设置了current_user会话变量、动作的flash消息，最后，我们断言我们被重定向到哪里。</p><p id="63a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">其他两个调用只是使用相同类型的断言(在一个例子中，是反驳)来确保我们测试了sign_in函数可以到达的所有路径。同样，非常简单的东西！</p><h2 id="adf6" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">步骤5:公开我们的当前用户</h2><p id="1f1c" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">让我们修改我们的布局，根据成员是否登录来显示消息或链接。</p><p id="35e4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<strong class="it hv"> web/views/layout_view.ex </strong>中，让我们编写一个帮助器，使我们能够方便地访问用户信息，因此我们将添加:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="8887" class="jp jq hu lj b fv ln lo l lp lq">def current_user(conn) do<br/>  Plug.Conn.get_session(conn, :current_user)<br/>end</span></pre><p id="a2d5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们编写一个测试来确保这是可行的。</p><p id="5b16" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<strong class="it hv">web/templates/layout/app . html . eex</strong>中，让我们执行以下操作，而不是“开始”链接:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="0dd3" class="jp jq hu lj b fv ln lo l lp lq">&lt;li&gt;<br/>        &lt;%= if user = current_user(@conn) do %&gt;<br/>          Logged in as<br/>          &lt;strong&gt;&lt;%= user.username %&gt;&lt;/strong&gt;<br/>          &lt;br&gt;<br/>          &lt;%= link "Log out", to: session_path(@conn, :delete, user.id), method: :delete %&gt;<br/>        &lt;% else %&gt;<br/>          &lt;%= link "Log in", to: session_path(@conn, :new) %&gt;<br/>        &lt;% end %&gt;<br/>      &lt;/li&gt;</span></pre><p id="754b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样，让我们一步一步来。我们需要做的第一件事是找出当前用户是谁，假设他们已经登录。我们将采用先简单，后重构的方法，所以现在我们将在模板中设置一个来自会话的用户对象。get_session是插件的一部分。连接对象。如果用户存在(这利用了Elixir的类似Ruby的真值，因为nil在这里将返回false。)</p><p id="ec06" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果用户已经登录，我们还想提供一个<strong class="it hv">注销</strong>链接。尽管这还不存在，但它最终需要存在，所以现在我们要把它发送出去。我们将会话视为资源，因此要注销，我们将“删除”该会话，因此我们将在这里提供一个到它的链接。</p><p id="7546" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还想输出当前用户的用户名。我们将用户结构存储在:current_user会话变量中，因此我们可以访问用户名user.username。</p><p id="c903" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们找不到用户，那么我们将只提供登录链接。同样，我们在这里将会话视为资源，因此“new”将提供创建新会话的适当路径。</p><p id="518d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可能已经注意到，当所有内容都刷新时，我们会收到另一条关于缺少匹配函数子句的错误消息。让我们添加我们的删除路线，以及让凤凰高兴！</p><p id="cfe3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<strong class="it hv"> web/router.ex </strong>中，我们将修改我们的“会话”路由，以便还允许:删除:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="7bf9" class="jp jq hu lj b fv ln lo l lp lq">resources "/sessions", SessionController, only: [:new, :create, :delete]</span></pre><p id="942f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们也修改一下控制器。在<strong class="it hv">web/controllers/session _ controller . ex</strong>中，添加以下内容:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="a84d" class="jp jq hu lj b fv ln lo l lp lq">def delete(conn, _params) do<br/>  conn<br/>  |&gt; delete_session(:current_user)<br/>  |&gt; put_flash(:info, "Signed out successfully!")<br/>  |&gt; redirect(to: page_path(conn, :index))<br/>end</span></pre><p id="87da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为我们只是删除了:current_user键，所以我们实际上并不关心参数是什么，所以我们用下划线将它们标记为未使用。我们设置了一个flash消息，使用户界面更加清晰，并重定向回我们的根路由。</p><p id="29fa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们现在可以登录、注销，还可以看到登录失败！事情正在向好的方向发展！但是首先，我们需要编写一些测试。我们将从LayoutView的测试开始。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="445e" class="jp jq hu lj b fv ln lo l lp lq">defmodule Pxblog.LayoutViewTest do<br/>  use Pxblog.ConnCase, async: true</span><span id="8025" class="jp jq hu lj b fv lr lo l lp lq">  alias Pxblog.LayoutView<br/>  alias Pxblog.User</span><span id="9e6f" class="jp jq hu lj b fv lr lo l lp lq">  setup do<br/>    User.changeset(%User{}, %{username: "test", password: "test", password_confirmation: "test", email: "<a class="ae ld" href="mailto:test@test.com" rel="noopener ugc nofollow" target="_blank">test@test.com</a>"})<br/>    |&gt; Repo.insert<br/>    {:ok, conn: build_conn()}<br/>  end</span><span id="9333" class="jp jq hu lj b fv lr lo l lp lq">  test "current user returns the user in the session", %{conn: conn} do<br/>    conn = post conn, session_path(conn, :create), user: %{username: "test", password: "test"}<br/>    assert LayoutView.current_user(conn)<br/>  end</span><span id="5d80" class="jp jq hu lj b fv lr lo l lp lq">  test "current user returns nothing if there is no user in the session", %{conn: conn} do<br/>    user = Repo.get_by(User, %{username: "test"})<br/>    conn = delete conn, session_path(conn, :delete, user)<br/>    refute LayoutView.current_user(conn)<br/>  end<br/>end</span></pre><p id="1ff0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们来分析一下。我们要做的第一件事是别名LayoutView和User模块，这样我们可以缩短一些代码。接下来，在我们的setup块中，我们创建一个用户并将其放入数据库。然后我们返回标准的<strong class="it hv"> {:ok，conn: build_conn()} </strong>元组。</p><p id="6bef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，我们编写第一个测试，登录到我们的会话create动作，并断言，登录后，LayoutView.current_user函数返回一些数据。</p><p id="c37b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我们为我们的负面情况写作；我们显式地删除了会话，并反驳了用户从我们的current_user调用中返回的说法。我们还通过添加一个删除操作来更新我们的SessionController，所以我们需要设置好我们的测试。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="be8a" class="jp jq hu lj b fv ln lo l lp lq">test "deletes the user session", %{conn: conn} do<br/>  user = Repo.get_by(User, %{username: "test"})<br/>  conn = delete conn, session_path(conn, :delete, user)<br/>  refute get_session(conn, :current_user)<br/>  assert get_flash(conn, :info) == "Signed out successfully!"<br/>  assert redirected_to(conn) == page_path(conn, :index)<br/>end</span></pre><p id="1781" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们确保会话中的current_user为空，然后我们检查flash消息并确保我们被重定向出去！</p><h2 id="2fcb" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">编译资产时可能出现的错误</h2><p id="3c13" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">需要注意的一点是，当您试图用brunch编译资产时，可能会遇到错误。我得到的错误消息是:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="962d" class="jp jq hu lj b fv ln lo l lp lq">16 Dec 23:30:20 — error: Compiling of ‘web/static/js/app.js’ failed. Couldn’t find preset “es2015” relative to directory “web/static/js” ; Compiling of ‘web/static/js/socket.js’ failed. Couldn’t find preset “es2015” relative to directory “web/static/js” ; Compiling of ‘deps/phoenix/web/static/js/phoenix.js’ failed. Couldn’t find preset “es2015” relative to directory “deps/phoenix/web/static/js” ; Compiling of ‘deps/phoenix_html/web/static/js/phoenix_html.js’ failed. Couldn’t find preset “es2015” relative to directory “deps/phoenix_html/web/static/js”</span></pre><p id="f162" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以用NPM安装<strong class="it hv"> babel-preset-es2015 </strong>来解决这个问题。我运行了以下命令:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="49e7" class="jp jq hu lj b fv ln lo l lp lq">npm install -g babel-preset-es2015</span></pre><p id="3d74" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，如果您启动服务器，您应该看到所有的资产都被正确编译了！</p><h2 id="085b" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">本系列的下一篇文章</h2><div class="lz ma fm fo mb mc"><a rel="noopener follow" target="_blank" href="/@diamondgfx/writing-a-blog-engine-in-phoenix-part-2-authorization-814c06fa7c0"><div class="md ab ej"><div class="me ab mf cl cj mg"><h2 class="bd hv fv z el mh eo ep mi er et ht dt translated">用Phoenix和Elixir编写博客引擎:第2部分，授权</h2><div class="mj l"><h3 class="bd b fv z el mh eo ep mi er et ek translated">最后更新时间:2016年7月21日</h3></div><div class="mk l"><p class="bd b gc z el mh eo ep mi er et ek translated">medium.com</p></div></div></div></a></div><h1 id="e14b" class="ml jq hu bd jr mm mn mo jv mp mq mr jz ms mt mu kc mv mw mx kf my mz na ki nb dt translated">看看我的新书！</h1><p id="8477" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">嘿大家好！如果你喜欢你在这里读到的东西，并且想和我一起学习更多，可以看看我的新书《长生不老药和凤凰网开发》:</p><div class="lz ma fm fo mb mc"><a href="https://www.packtpub.com/web-development/phoenix-web-development" rel="noopener  ugc nofollow" target="_blank"><div class="md ab ej"><div class="me ab mf cl cj mg"><h2 class="bd hv fv z el mh eo ep mi er et ht dt translated">凤凰网开发| PACKT图书</h2><div class="mj l"><h3 class="bd b fv z el mh eo ep mi er et ek translated">学习使用Elixir和……从头开始构建投票web应用程序的高性能功能原型</h3></div><div class="mk l"><p class="bd b gc z el mh eo ep mi er et ek translated">www.packtpub.com</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh ni mc"/></div></div></a></div><p id="1687" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我真的很兴奋终于可以把这个项目推向世界了！它的写作风格与我的其他教程一样，我们将从头到尾构建一个完整项目的框架，甚至涵盖一些更棘手的主题，如文件上传、Twitter/Google OAuth登录和API！</p><blockquote class="lt lu lv"><p id="9edb" class="ir is ls it b iu iv iw ix iy iz ja jb lw jd je jf lx jh ji jj ly jl jm jn jo hn dt translated"><a class="ae ld" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ld" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ld" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ld" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is ls it b iu iv iw ix iy iz ja jb lw jd je jf lx jh ji jj ly jl jm jn jo hn dt translated">要了解更多信息，<a class="ae ld" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">请阅读我们的“关于”页面</a>，<a class="ae ld" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae ld" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is ls it b iu iv iw ix iy iz ja jb lw jd je jf lx jh ji jj ly jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ld" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ld" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>