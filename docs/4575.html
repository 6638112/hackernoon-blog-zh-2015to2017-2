<html>
<head>
<title>Kotlin — A deeper look</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林——更深入的观察</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/kotlin-a-deeper-look-8569d4da36f?source=collection_archive---------1-----------------------#2017-06-08">https://medium.com/hackernoon/kotlin-a-deeper-look-8569d4da36f?source=collection_archive---------1-----------------------#2017-06-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="05be" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">这感觉像是魔法…但这是真的吗？</h2></div><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff jk"><img src="../Images/0fb28be339cb05fd94a75d19063dc0ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TJXYjBragnuWjtbxtEHQxg.png"/></div></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek"><a class="ae ka" href="https://trends.google.com/trends/explore?q=%2Fm%2F0_lcrx4" rel="noopener ugc nofollow" target="_blank">https://trends.google.com/trends/explore?q=%2Fm%2F0_lcrx4</a></figcaption></figure><p id="8106" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">你现在看到的是谷歌趋势，我在那里查了“<a class="ae ka" href="https://hackernoon.com/tagged/kotlin" rel="noopener ugc nofollow" target="_blank">科特林</a>”。你能看到那个突然的尖峰吗？几周前，在谷歌I/O大会上，谷歌宣布Kotlin编程语言现在是Android的一等公民。到目前为止，要么你在过去就已经在使用它，要么你一直埋头于这种语言，因为每个人都突然在谈论它。</p><p id="b0f3" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">该语言最突出的特点之一是<strong class="kd hv">与<a class="ae ka" href="https://hackernoon.com/tagged/java" rel="noopener ugc nofollow" target="_blank"> Java </a>的互操作性</strong>:这意味着你可以从Java中调用Kotlin代码，就像你可以从Kotlin中调用Java代码一样。这可能是(也一直是)推动采用的最重要的特性。您不需要一次迁移所有内容:您可以简单地从现有的代码库中取出一部分，开始添加Kotlin代码，就这样，它就可以工作了。你可以<strong class="kd hv">用科特林做实验</strong>，如果你不喜欢你看到的，你随时可以回去(尽管我谅你也不敢这么做)。</p><p id="b3fe" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">当我从5年的Java生涯中第一次开始使用Kotlin时，有些东西感觉就像魔术一样。</p><blockquote class="kx ky kz"><p id="27da" class="kb kc la kd b ke kf iv kg kh ki iy kj lb kl km kn lc kp kq kr ld kt ku kv kw hn dt translated">“等等，什么？我可以简单地写<code class="eh le lf lg lh b"><a class="ae ka" href="https://kotlinlang.org/docs/reference/data-classes.html" rel="noopener ugc nofollow" target="_blank">data class</a></code>来避免样板文件？”</p><p id="dd30" class="kb kc la kd b ke kf iv kg kh ki iy kj lb kl km kn lc kp kq kr ld kt ku kv kw hn dt translated">"等等，所以如果我写了<code class="eh le lf lg lh b">apply</code>，那么我就不再需要在每次调用对象上的方法时都指定对象了？"</p></blockquote><p id="1c80" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">在最初为终于有了一门不觉得陈旧笨重的语言而松了一口气之后，我开始感到有点不舒服。如果与Java的互操作性是一个需求，那么Kotlin是如何实现这些优秀的语言特性的呢？有什么条件？</p><p id="ebfe" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">这就是这篇文章的内容。我非常好奇Kotlin编译器如何翻译某些结构，以便它们可以与Java互操作，我选择看一看<a class="ae ka" href="https://kotlinlang.org/api/latest/jvm/stdlib/index.html" rel="noopener ugc nofollow" target="_blank"> Kotlin标准库</a>的四个最常用的方法:</p><ol class=""><li id="aa26" class="li lj hu kd b ke kf kh ki kk lk ko ll ks lm kw ln lo lp lq dt translated"><code class="eh le lf lg lh b">apply</code></li><li id="0d89" class="li lj hu kd b ke lr kh ls kk lt ko lu ks lv kw ln lo lp lq dt translated"><code class="eh le lf lg lh b">with</code></li><li id="c0e5" class="li lj hu kd b ke lr kh ls kk lt ko lu ks lv kw ln lo lp lq dt translated"><code class="eh le lf lg lh b">let</code></li><li id="eab8" class="li lj hu kd b ke lr kh ls kk lt ko lu ks lv kw ln lo lp lq dt translated"><code class="eh le lf lg lh b">run</code></li></ol><p id="bbfd" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">看完这篇文章，你应该不会再感到害怕了。我现在感觉自信多了，因为我知道事情是如何工作的，我知道我可以信任语言和编译器。</p><h1 id="fe3d" class="lw lx hu bd ly lz ma mb mc md me mf mg ja mh jb mi jd mj je mk jg ml jh mm mn dt translated">应用</h1><figure class="jl jm jn jo fq jp"><div class="bz el l di"><div class="mo mp l"/></div></figure><p id="8895" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated"><code class="eh le lf lg lh b">apply</code>非常简单:它是一个扩展函数，在扩展类型的实例(称为“receiver”)上执行<em class="la">块</em>参数，并返回接收者本身。<br/>在许多用例中，该功能都会派上用场。您可以将对象的创建绑定到其初始配置，如下所示:</p><pre class="jl jm jn jo fq mq lh mr ms aw mt dt"><span id="d472" class="mu lx hu lh b fv mv mw l mx my">val layout = LayoutStyle().apply { orientation = VERTICAL }</span></pre><p id="5b69" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">如你所见，我们正在创建站点为我们的新<code class="eh le lf lg lh b">LayoutStyle</code>提供配置，这有助于<strong class="kd hv">更清晰的代码</strong>和<strong class="kd hv">更少的</strong> <strong class="kd hv">易错实现</strong>。你有没有因为一个相似的名字而在错误的实例上调用方法的经历？或者更糟，重构出了可怕的错误？用这种方法，肯定很难掉进这些坑里。<br/>另外，注意我们不需要指定<code class="eh le lf lg lh b">this</code>参数:因为我们<strong class="kd hv">和类本身</strong>在同一个范围内，就好像我们正在扩展那个类，因此<code class="eh le lf lg lh b">this</code>是隐式的。</p><p id="c6e1" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">但是这是怎么做到的呢？让我们看一个简单的例子。考虑这个简单的片段:</p><figure class="jl jm jn jo fq jp"><div class="bz el l di"><div class="mo mp l"/></div></figure><p id="ac8e" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">感谢IntelliJ IDEA的“显示Kotlin字节码”工具(<code class="eh le lf lg lh b">Tools &gt; Kotlin &gt; Show Kotlin Bytecode</code>)，我们可以检查编译器如何将我们的代码翻译成JVM字节码:</p><figure class="jl jm jn jo fq jp"><div class="bz el l di"><div class="mo mp l"/></div></figure><p id="6117" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">如果你不太熟悉字节码，我建议你阅读<a class="ae ka" href="http://www.javaworld.com/article/2077233/core-java/bytecode-basics.html" rel="noopener ugc nofollow" target="_blank">这些</a> <a class="ae ka" href="https://arhipov.blogspot.de/2011/01/java-bytecode-fundamentals.html" rel="noopener ugc nofollow" target="_blank">伟大的</a> <a class="ae ka" href="https://www.wikiwand.com/en/Java_bytecode_instruction_listings" rel="noopener ugc nofollow" target="_blank">文章</a>，这会让你有一个更清晰的想法(在这种情况下，需要记住的一件重要事情是，每次方法调用都会弹出堆栈，所以编译器每次都需要加载对象)。</p><p id="80c1" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">让我们来分解一下:</p><ol class=""><li id="771d" class="li lj hu kd b ke kf kh ki kk lk ko ll ks lm kw ln lo lp lq dt translated">创建一个新的<code class="eh le lf lg lh b">LayoutStyle</code>实例，并将其复制到堆栈中</li><li id="1942" class="li lj hu kd b ke lr kh ls kk lt ko lu ks lv kw ln lo lp lq dt translated">用零参数调用构造函数</li><li id="f952" class="li lj hu kd b ke lr kh ls kk lt ko lu ks lv kw ln lo lp lq dt translated">执行一系列存储/加载操作(稍后将详细介绍)</li><li id="8f40" class="li lj hu kd b ke lr kh ls kk lt ko lu ks lv kw ln lo lp lq dt translated">将<code class="eh le lf lg lh b">Orientation.VERTICAL</code>值压入堆栈</li><li id="2631" class="li lj hu kd b ke lr kh ls kk lt ko lu ks lv kw ln lo lp lq dt translated">调用<code class="eh le lf lg lh b">setOrientation</code>，从堆栈中弹出对象和值</li></ol><p id="8b9c" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">我们注意到这里有几件事。首先，场景背后没有魔法，一切如你所料:在我们创建的<code class="eh le lf lg lh b">LayoutStyle</code>实例上调用<code class="eh le lf lg lh b">setOrientation</code>方法。此外，<code class="eh le lf lg lh b">apply</code>函数也不见踪影，因为编译器被指示将<a class="ae ka" href="https://kotlinlang.org/docs/reference/inline-functions.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kd hv">内联</strong>它</a>。</p><p id="6fad" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">最重要的是，字节码几乎与用Java做同样的事情所生成的字节码相同！你自己看吧:</p><figure class="jl jm jn jo fq jp"><div class="bz el l di"><div class="mo mp l"/></div></figure><p id="b2b2" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated"><em class="la">亲提示:你可能注意到了很多</em> <code class="eh le lf lg lh b">ASTORE/ALOAD</code> <em class="la">的操作。这些是由Kotlin编译器插入的，因此调试器也适用于lambdas！我们将在文章的最后一节详细阐述这一点。</em></p><h1 id="5716" class="lw lx hu bd ly lz ma mb mc md me mf mg ja mh jb mi jd mj je mk jg ml jh mm mn dt translated">随着</h1><figure class="jl jm jn jo fq jp"><div class="bz el l di"><div class="mo mp l"/></div></figure><p id="e5d3" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated"><code class="eh le lf lg lh b">with</code>可能看起来与<code class="eh le lf lg lh b">apply</code>相似，但表示一些显著的差异。首先，<code class="eh le lf lg lh b">with</code>不是类型上的扩展函数:接收者必须作为参数显式传递。此外，<code class="eh le lf lg lh b">with</code>返回<em class="la">块</em>函数的结果，而<code class="eh le lf lg lh b">apply</code>返回接收器本身。</p><p id="bf68" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">既然我们有自由去归还我们想要的任何东西，像这样的事情是完全合理的:</p><pre class="jl jm jn jo fq mq lh mr ms aw mt dt"><span id="b6b1" class="mu lx hu lh b fv mv mw l mx my">val layout = with(contextWrapper) { <br/>  // `this` is the contextWrapper<br/>  LayoutStyle(context, attrs).apply { orientation = VERTICAL }<br/>}</span></pre><p id="08dc" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">在这个例子中，我们可以省略<code class="eh le lf lg lh b">context</code>和<code class="eh le lf lg lh b">attrs</code>的<code class="eh le lf lg lh b">contextWrapper.</code>前缀，因为<code class="eh le lf lg lh b">contextWrapper</code>是<code class="eh le lf lg lh b">with</code>函数的接收器。尽管用例远没有你所能想到的<code class="eh le lf lg lh b">apply</code>那么明显，但是这个函数在特定的环境下会变得非常有用。</p><p id="3316" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">记住这一点，让我们回到我们的例子，看看如果我们使用<code class="eh le lf lg lh b">with</code>会发生什么:</p><figure class="jl jm jn jo fq jp"><div class="bz el l di"><div class="mo mp l"/></div></figure><p id="ee48" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated"><code class="eh le lf lg lh b">with</code>的接收器是一个名为<code class="eh le lf lg lh b">SharedState</code>的单例，它包含一个我们希望我们的布局拥有的方向参数。在<em class="la">块</em>函数中，我们创建了<code class="eh le lf lg lh b">LayoutStyle</code>实例，由于<code class="eh le lf lg lh b">apply</code>，我们可以简单地用从<code class="eh le lf lg lh b">SharedState</code>中读取的那个来设置方向。</p><p id="9e9a" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">现在让我们再次看看生成的字节码:</p><figure class="jl jm jn jo fq jp"><div class="bz el l di"><div class="mo mp l"/></div></figure><p id="36a9" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">还是那句话，这里真的没什么特别的。检索在<code class="eh le lf lg lh b">SharedState</code>类上作为静态字段实现的singleton像前面一样创建了<code class="eh le lf lg lh b">LayoutStyle</code>实例，调用了构造函数，另一个调用获取了<code class="eh le lf lg lh b">SharedState</code>中<code class="eh le lf lg lh b">previousOrientation</code>的值，最后一个调用将它分配给了我们的<code class="eh le lf lg lh b">LayoutStyle</code>实例。</p><p id="28a8" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated"><em class="la"> Pro提示:使用“显示Kotlin字节码”时，也可以按“反编译”来查看Kotlin编译器生成的字节码的Java表示。剧透:这正是你所期待的！</em></p><h1 id="2b2e" class="lw lx hu bd ly lz ma mb mc md me mf mg ja mh jb mi jd mj je mk jg ml jh mm mn dt translated">让</h1><figure class="jl jm jn jo fq jp"><div class="bz el l di"><div class="mo mp l"/></div></figure><p id="2e03" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated"><code class="eh le lf lg lh b">let</code>在处理可空对象时非常有用。您可以简单地将<code class="eh le lf lg lh b">?</code>操作符(称为“安全调用操作符”)与<code class="eh le lf lg lh b">let</code>结合起来，而不是将无尽的if-else语句链接起来:您最终得到的是一个lambda，其中参数<code class="eh le lf lg lh b">it</code>是原始对象的不可空版本。</p><pre class="jl jm jn jo fq mq lh mr ms aw mt dt"><span id="8efa" class="mu lx hu lh b fv mv mw l mx my">val layout = <!-- -->LayoutStyle<!-- -->()<br/>SharedState.previousOrientation?.<em class="la">let </em><strong class="lh hv">{ </strong>layout.orientation = <strong class="lh hv">it }</strong></span></pre><p id="353f" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">让我们看看整个例子:</p><figure class="jl jm jn jo fq jp"><div class="bz el l di"><div class="mo mp l"/></div></figure><p id="d9af" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">既然<code class="eh le lf lg lh b">previousOrientation</code>是可空的，如果我们试图将它直接赋给我们的布局，编译器会抱怨，因为可空类型不能赋给不可空类型。当然，我们可以写一个if语句，但是这意味着引用<code class="eh le lf lg lh b">SharedState.previousOrientation</code>值两次:通过使用<code class="eh le lf lg lh b">let</code>来代替，我们得到一个对同一个参数的不可空的引用，它可以安全地分配给我们的布局。</p><p id="27d8" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">从字节码的角度来看，这非常简单:</p><figure class="jl jm jn jo fq jp"><div class="bz el l di"><div class="mo mp l"/></div></figure><p id="8c72" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">这一切都求助于一个简单的条件跳转<code class="eh le lf lg lh b">IFNULL</code>，这基本上是你手工完成的，除了这一次编译器为你有效地完成了，并且语言为你提供了一个编写代码的好方法。我觉得这太棒了！</p><h1 id="70d5" class="lw lx hu bd ly lz ma mb mc md me mf mg ja mh jb mi jd mj je mk jg ml jh mm mn dt translated"><strong class="ak">运行</strong></h1><p id="068f" class="pw-post-body-paragraph kb kc hu kd b ke mz iv kg kh na iy kj kk nb km kn ko nc kq kr ks nd ku kv kw hn dt translated"><em class="la">run有两个版本，一个是简单函数，一个是泛型类型上的扩展函数。因为前者只不过是调用作为参数传递的块函数，所以我们将重点分析后者。</em></p><figure class="jl jm jn jo fq jp"><div class="bz el l di"><div class="mo mp l"/></div></figure><p id="a034" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated"><code class="eh le lf lg lh b">run</code>可能是我们目前遇到的函数中最简单的一个。它被定义为一个类型的扩展函数，其实例被作为接收者传递，并返回执行<code class="eh le lf lg lh b">block</code>函数的结果。你可能认为<code class="eh le lf lg lh b">run</code>是<code class="eh le lf lg lh b">let</code>和<code class="eh le lf lg lh b">apply</code>的混合体，你可能是对的，唯一的区别是返回值:在<code class="eh le lf lg lh b">apply</code>的情况下，我们返回接收者本身，在<code class="eh le lf lg lh b">run</code>的情况下，我们返回<em class="la">块</em>函数的结果(就像我们在<code class="eh le lf lg lh b">let</code>上做的一样)。</p><p id="5723" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">因此，下面的例子强调了这样一个事实，即<code class="eh le lf lg lh b">run</code>返回<em class="la">块</em>函数的结果，因此在这个例子中是一个赋值(<code class="eh le lf lg lh b">Unit</code>):</p><figure class="jl jm jn jo fq jp"><div class="bz el l di"><div class="mo mp l"/></div></figure><p id="180d" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">对应的字节码是:</p><figure class="jl jm jn jo fq jp"><div class="bz el l di"><div class="mo mp l"/></div></figure><p id="0717" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">我们可以看到<code class="eh le lf lg lh b">run</code>已经被内联，就像其他函数一样，一切都解析为简单的方法调用。这里也没什么奇怪的！</p></div><div class="ab cl ne nf hc ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="hn ho hp hq hr"><p id="ea1f" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">我们已经注意到标准库函数之间有很多相似之处:这是故意的，以便尽可能多地涵盖用例。另一方面，考虑到每种功能之间的细微差异，找出哪种功能最适合您的特定任务并不容易。<br/>为了帮助你浏览标准库，这里有一个方便的表格，总结了我们已经讨论过的主要函数之间的差异(除了<code class="eh le lf lg lh b"><a class="ae ka" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/also.html" rel="noopener ugc nofollow" target="_blank">also</a></code>):</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff nl"><img src="../Images/187d3f43fdcee09423a4f1d96de1cbcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bD7r_xcW5CWN389WEfgPDg.png"/></div></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">Huge thanks to <a class="ae ka" rel="noopener" href="/@workingkills">Eugenio</a> for sharing this with me!</figcaption></figure><h1 id="a74b" class="lw lx hu bd ly lz ma mb mc md me mf mg ja mh jb mi jd mj je mk jg ml jh mm mn dt translated">附录:额外的<code class="eh le lf lg lh b">store/load</code>操作</h1><p id="68d0" class="pw-post-body-paragraph kb kc hu kd b ke mz iv kg kh na iy kj kk nb km kn ko nc kq kr ks nd ku kv kw hn dt translated">在我们结束这一分析之前，当比较“Java字节码”和“Kotlin字节码”时，还有一些我不能真正理解的地方。更具体地说，正如我之前提到的，有一些额外的来自Kotlin的<code class="eh le lf lg lh b">astore/aload</code>操作是Java所缺少的。我知道这和兰姆达斯有关，但我不知道他们有什么用。</p><p id="7bb5" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">原来，这些额外的操作对于调试器来说是必要的，以便<strong class="kd hv">将lambdas视为</strong> <a class="ae ka" href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.6" rel="noopener ugc nofollow" target="_blank"> <strong class="kd hv">堆栈帧</strong> </a>，进而允许我们进入它们。这样我们可以看到什么是局部变量，谁是lambda的调用者，谁将从lambda中被调用，等等。</p><p id="55fc" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">然而，当我们将APK交付生产时，我们并不真正关心调试器的特性，不是吗？因此，我们可以把这些指令，即使很小，可以忽略不计，看作是应该而且能够消除的开销。</p><p id="d757" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated"><a class="ae ka" href="https://www.guardsquare.com/en/proguard" rel="noopener ugc nofollow" target="_blank"> <strong class="kd hv"> ProGuard </strong> </a>，这个我们都知道的工具和“爱”，可能是这项工作的合适工具。它在字节码级别上运行，除了模糊和收缩之外，它还进行优化，尝试精简字节码。所以我尝试用Java和Kotlin编写相同的代码，用相同的规则集对它们应用ProGuard，并比较结果。这是我的发现。</p><h2 id="ab81" class="mu lx hu bd ly nm nn no mc np nq nr mg kk ns nt mi ko nu nv mk ks nw nx mm ny dt translated">ProGuard配置</h2><figure class="jl jm jn jo fq jp"><div class="bz el l di"><div class="mo mp l"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">ProGuard configuration</figcaption></figure><h2 id="393d" class="mu lx hu bd ly nm nn no mc np nq nr mg kk ns nt mi ko nu nv mk ks nw nx mm ny dt translated">源代码</h2><figure class="jl jm jn jo fq jp"><div class="bz el l di"><div class="mo mp l"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek"><em class="jj">Java</em></figcaption></figure><figure class="jl jm jn jo fq jp"><div class="bz el l di"><div class="mo mp l"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">Kotlin</figcaption></figure><h2 id="0786" class="mu lx hu bd ly nm nn no mc np nq nr mg kk ns nt mi ko nu nv mk ks nw nx mm ny dt translated">字节码</h2><figure class="jl jm jn jo fq jp"><div class="bz el l di"><div class="mo mp l"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">Java</figcaption></figure><figure class="jl jm jn jo fq jp"><div class="bz el l di"><div class="mo mp l"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">Kotlin</figcaption></figure><p id="a310" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">在比较了两个字节码清单之后，我们可以观察到以下情况:</p><ol class=""><li id="2840" class="li lj hu kd b ke kf kh ki kk lk ko ll ks lm kw ln lo lp lq dt translated">“Kotlin字节码”中额外的<code class="eh le lf lg lh b">astore/aload</code>操作不见了，因为ProGuard认为它们是多余的，并立即删除了它们(有趣的是，一次优化并没有成功，需要两次)</li><li id="fc2a" class="li lj hu kd b ke lr kh ls kk lt ko lu ks lv kw ln lo lp lq dt translated">“Java字节码”和“Kotlin字节码”几乎相同；前者在处理枚举值时有些有趣/怪异，而在Kotlin中没有这样的事情</li></ol><h1 id="77e9" class="lw lx hu bd ly lz ma mb mc md me mf mg ja mh jb mi jd mj je mk jg ml jh mm mn dt translated">结论</h1><p id="7887" class="pw-post-body-paragraph kb kc hu kd b ke mz iv kg kh na iy kj kk nb km kn ko nc kq kr ks nd ku kv kw hn dt translated">有一种新的语言为开发人员提供了如此多的可能性，这很好，但是知道我们可以依赖我们使用的工具并且我们有信心使用它们也很重要。</p><p id="9d38" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">我很高兴我可以说“我可以信任Kotlin”，从某种意义上说，我知道编译器没有做任何过分或冒险的事情:它只是简单地做了我们在Java中必须手工做的事情，节省了我们的时间和资源(并恢复了JVM编码活动中一些久违的乐趣)。这在某种程度上也有利于最终用户，因为由于更强的类型安全，希望我们可以在应用程序中减少错误。</p><p id="a92c" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">此外，Kotlin编译器也在不断改进，因此它输出的代码会越来越好，越来越高效。也就是说，我们不应该试图基于编译器来优化我们的Kotlin代码，而是应该坚持我们能够编写的最好的(如高效和惯用的)Kotlin代码，并将所有其他的工作留给编译器本身。</p><div class="jl jm jn jo fq ab cb"><figure class="nz jp oa ob oc od oe paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nz jp oa ob oc od oe paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nz jp oa ob oc od oe paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="kx ky kz"><p id="f922" class="kb kc la kd b ke kf iv kg kh ki iy kj lb kl km kn lc kp kq kr ld kt ku kv kw hn dt translated"><a class="ae ka" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客们下午的开始。我们是<a class="ae ka" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ka" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ka" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="kb kc la kd b ke kf iv kg kh ki iy kj lb kl km kn lc kp kq kr ld kt ku kv kw hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ka" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ka" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff of"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="jl jm jn jo fq jp"><div class="bz el l di"><div class="og mp l"/></div></figure></div></div>    
</body>
</html>