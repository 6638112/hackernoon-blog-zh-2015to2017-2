<html>
<head>
<title>React Native Performance — An Updated Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应本机性能—更新的示例</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/react-native-performance-an-updated-example-6516bfde9c5c?source=collection_archive---------2-----------------------#2017-04-15">https://medium.com/hackernoon/react-native-performance-an-updated-example-6516bfde9c5c?source=collection_archive---------2-----------------------#2017-04-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/c17d3ffcbdbdcc09f4084c60efc6c4d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b6h_7LQ9Fhsp__sRCAzFgg.jpeg"/></div></div></figure><p id="67ab" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我正在为<a class="ae ka" href="https://react.amsterdam/" rel="noopener ugc nofollow" target="_blank"> React Amsterdam 2017 </a>进行我的性能演讲，它基于帖子“<a class="ae ka" rel="noopener" href="/@talkol/performance-limitations-of-react-native-and-how-to-overcome-them-947630d7f440">React Native的性能限制以及如何克服它们</a>”。我决定更新一下我们将要讨论的例子，以便介绍一些令人兴奋的新API。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><h2 id="3b85" class="ki kj hu bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated">一些背景</h2><p id="2299" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">在这篇文章中，我们假设你已经熟悉了<a class="ae ka" href="https://hackernoon.com/tagged/react-native" rel="noopener ugc nofollow" target="_blank">React Native</a>——<em class="li">Native realm</em>,<a class="ae ka" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"><em class="li">JavaScript</em></a><em class="li">realm</em>和连接两者的<em class="li">桥</em>的基本架构。如果没有，这个话题会在<a class="ae ka" rel="noopener" href="/@talkol/performance-limitations-of-react-native-and-how-to-overcome-them-947630d7f440">上一篇</a>中详细讨论。</p><p id="7610" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们也记住前一篇文章的主要结论，它将指导我们以性能为导向的讨论:</p><blockquote class="lj"><p id="2be1" class="lk ll hu bd lm ln lo lp lq lr ls jz ek translated">为了构建高性能的React本机应用程序，我们必须尽量减少过桥次数。</p></blockquote><p id="1e11" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">因此..是时候进入我们新的有趣用例了，事实证明，用React Native以一种高性能的方式实现这个用例并不容易。</p><h2 id="5e4a" class="ki kj hu bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated">一个新的现实生活的例子</h2><p id="7a52" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">我们的用例灵感来自<a class="ae ka" href="https://itunes.apple.com/il/app/wix.com/id1099748482?mt=8" rel="noopener ugc nofollow" target="_blank">Wix.com应用</a>的主屏幕。屏幕上有一堆卡片，并包含一个欢迎用户使用该应用程序的大标题图像。这是UX的样子:</p><figure class="lz ma mb mc fq iv fe ff paragraph-image"><div class="fe ff ly"><img src="../Images/a96b4d3ef81a18609ece5cd6d0da43fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:496/1*JEzdDNvJjNOy-mSvFM1-ig.gif"/></div></figure><p id="eb8b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意两个有趣的效果。第一个——当用户向下滚动卡片列表时，标题图像慢慢消失在灰色背景中。第二种——如果用户向上滚动并且已经在列表的顶部，为了移动的连续性，标题图像稍微缩放直到它反弹回来(这被称为<em class="li">过度滚动效应</em>)。</p><p id="de51" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">像这样的影响可能看起来很小，但却是最后一英里的一部分，它创造了神奇的用户体验，并将平庸的应用程序与伟大的应用程序区分开来。不过，我们必须小心实现。如果它不能以60 FPS的速度流畅运行，效果可能会适得其反，降低用户的沉浸感，而不是增强它。</p><p id="86c9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">屏幕的一般组件布局非常简单:</p><figure class="lz ma mb mc fq iv"><div class="bz el l di"><div class="md me l"/></div></figure><p id="323c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，标题图像不是ListView的一部分，因为它保持静态，不随列表内容滚动。还要注意，我们仍然使用旧的<a class="ae ka" href="https://facebook.github.io/react-native/docs/listview.html" rel="noopener ugc nofollow" target="_blank"> ListView </a>实现，而不是推荐的<a class="ae ka" href="https://facebook.github.io/react-native/docs/flatlist.html" rel="noopener ugc nofollow" target="_blank"> FlatList </a>。这是因为ListView提供了一些额外的<a class="ae ka" href="https://facebook.github.io/react-native/docs/listview.html#renderscrollcomponent" rel="noopener ugc nofollow" target="_blank">灵活性，而这在FlatList中还没有。</a></p><h2 id="5375" class="ki kj hu bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated">我们的第一个实现JavaScript中的onScroll事件</h2><p id="5ea2" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">像往常一样，我们将从简单的方法开始。如果我们希望效果与滚动位置相关联，我们可以监听滚动事件。每当滚动位置改变时，我们的事件监听器将被触发，我们将能够重新呈现标题图像并应用适当的效果。</p><p id="b100" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个设置有些棘手，因为<a class="ae ka" href="https://facebook.github.io/react-native/docs/listview.html" rel="noopener ugc nofollow" target="_blank"> ListView </a>没有公开用于滚动内容的内部<a class="ae ka" href="https://facebook.github.io/react-native/docs/scrollview.html" rel="noopener ugc nofollow" target="_blank"> ScrollView </a>。它允许我们使用<code class="eh mf mg mh mi b"><a class="ae ka" href="https://facebook.github.io/react-native/docs/listview.html#renderscrollcomponent" rel="noopener ugc nofollow" target="_blank">renderScrollComponent</a></code> prop提供自己的自定义ScrollView。</p><p id="ab5f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将效果应用到标题图像就像定义样式属性一样简单。我们将使用<code class="eh mf mg mh mi b"><a class="ae ka" href="https://facebook.github.io/react-native/docs/view.html#style" rel="noopener ugc nofollow" target="_blank">opacity</a></code>来控制溶解效果，使用<code class="eh mf mg mh mi b"><a class="ae ka" href="http://facebook.github.io/react-native/releases/0.40/docs/transforms.html" rel="noopener ugc nofollow" target="_blank">transform.scale</a></code>来控制缩放效果。我们将在本地组件状态中存储两者的值，并通过调用<code class="eh mf mg mh mi b">setState</code>来重新呈现。</p><p id="19e6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是完整的实现:</p><figure class="lz ma mb mc fq iv"><div class="bz el l di"><div class="md me l"/></div></figure><p id="2e70" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如你所见，在每个<code class="eh mf mg mh mi b">onScroll</code>事件中，我们根据滚动位置(<code class="eh mf mg mh mi b">contentOffset</code>)来决定应用哪种效果。如果滚动位置为正(向下滚动)，不透明度从<code class="eh mf mg mh mi b">1.0</code>降低到<code class="eh mf mg mh mi b">0.0</code>。如果滚动位置为负(向上过度滚动)，刻度从<code class="eh mf mg mh mi b">1.0</code>增加到<code class="eh mf mg mh mi b">1.4</code>。</p><h2 id="6a5b" class="ki kj hu bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated">第一次尝试—性能分析</h2><p id="b92f" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">我们应该从这个实现中期待什么样的性能？主要的性能瓶颈可能是通过桥的次数。</p><p id="752e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们通过分析运行在<em class="li"> JavaScript领域</em>(左边的紫色)和运行在<em class="li">本地领域</em>(右边的黑色)中的内容来计算通过次数:</p><figure class="lz ma mb mc fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mj"><img src="../Images/d48d3515cc885b17212f61b1684c2a57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4a_A-hBMc3fMuHpSYqnLXQ.png"/></div></div></figure><p id="3aee" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就像任何其他视图事件一样，滚动事件起源于<em class="li">本地领域。</em>我们的JavaScript逻辑运行在<em class="li"> JavaScript领域</em>中。一旦我们重新渲染，新的视图属性必须应用到<em class="li">本地领域</em>中的实际本地视图。这意味着我们每一帧都要过桥两次。</p><p id="bf90" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在繁忙的应用程序上，这将阻止我们以60 FPS运行。让我们改进。</p><h2 id="ae51" class="ki kj hu bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated">第二种实现尝试——本机滚动监听器</h2><p id="526d" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">关于哪些组件用JavaScript实现，哪些组件用纯Native实现，React Native非常灵活。本地组件可以包含JavaScript组件，JavaScript组件可以包含本地组件。</p><p id="5e98" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每当我们遇到性能问题时，我们通常可以从帽子里拉出这只兔子。将我们的一个组件移植到native通常可以解决问题。让我们试着在这里应用这个原则。</p><p id="722b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的性能瓶颈源于用JavaScript实现我们的滚动监听器。由于滚动事件起源于<em class="li">本地领域</em>，在JavaScript中执行我们的<code class="eh mf mg mh mi b">onScroll</code>逻辑总是会产生开销。让我们将<code class="eh mf mg mh mi b">onScroll</code>逻辑移到本机。</p><p id="287a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh mf mg mh mi b">onScroll</code>的目的是更新视图属性(不透明度和比例)。我们也可以通过在native中关闭整个循环来节省过桥的时间。我们可以用一个原生容器组件(方便地命名为<code class="eh mf mg mh mi b">NativeWrapper</code>)来包装图像，而不是直接改变标题图像的不透明度和比例，这将改变它自己的属性。这是可行的，因为容器的不透明度和缩放也会影响其子容器。这个<code class="eh mf mg mh mi b">NativeWrapper</code>组件将包含我们的<code class="eh mf mg mh mi b">onScroll</code>逻辑的本地实现。</p><p id="8492" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的新布局:</p><figure class="lz ma mb mc fq iv"><div class="bz el l di"><div class="md me l"/></div></figure><p id="3c64" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">到目前为止，唯一的挑战是将我们的本地scroll监听器连接到正确的ScrollView。ScrollView是ListView的一部分，它既不是我们的<code class="eh mf mg mh mi b">NativeWrapper</code>的子视图也不是父视图。为了连接侦听器，我们需要能够从本机实现中找到它。每个React组件都有一个<em class="li">节点句柄</em>——有时称为<em class="li"> React标签</em>。这只是唯一标识该组件实例的编号。我们可以使用<code class="eh mf mg mh mi b"><a class="ae ka" href="https://github.com/facebook/react/blob/72196da82915bee400edb1599d4223926aa2a8a0/src/renderers/native/findNodeHandle.js#L59" rel="noopener ugc nofollow" target="_blank">ReactNative.findNodeHandle</a></code>找到这个数字，并简单地将它作为道具传递给<code class="eh mf mg mh mi b">NativeWrapper</code>。</p><p id="ea58" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在JavaScript方面已经设置好了，是时候用Objective-C来弄脏我们的手了。</p><p id="002b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将<code class="eh mf mg mh mi b">onScroll</code>逻辑本身移植到Objective-C很容易。代码实际上看起来几乎完全一样。不用调用<code class="eh mf mg mh mi b">setState</code>来更新视图属性，我们可以简单地直接改变视图属性，因为我们是在<em class="li">本地领域</em>中运行的。</p><p id="fe28" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里唯一的挑战还是挂钩我们的本地滚动监听器。一旦ScrollView的数字<em class="li">节点句柄</em>通过props到达，我们需要将其转换回视图对象引用，以便访问底层的ScrollView实例。这涉及到一点借用的样板文件，它使用<a class="ae ka" href="https://github.com/facebook/react-native/blob/bc1ea548d0017f131c36a30ce06bf4d512cb2f8c/React/Modules/RCTUIManager.h" rel="noopener ugc nofollow" target="_blank"> UIManager </a>来完成翻译。</p><p id="a898" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是目标C的实现:</p><figure class="lz ma mb mc fq iv"><div class="bz el l di"><div class="md me l"/></div></figure><p id="edc9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如您所见，<code class="eh mf mg mh mi b">onScroll</code>的实现与JavaScript的几乎相同。如果滚动位置为正(向下滚动)，不透明度自然从<code class="eh mf mg mh mi b">1.0</code>降低到<code class="eh mf mg mh mi b">0.0</code>。如果滚动位置为负(向上过度滚动)，比例自然从<code class="eh mf mg mh mi b">1.0</code>增加到<code class="eh mf mg mh mi b">1.4</code>。</p><h2 id="e7f2" class="ki kj hu bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated">第二次尝试—性能分析</h2><p id="4a70" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">我们预计性能会好得多，因为这种实现是为减少过桥次数而定制的。</p><p id="58d0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们通过分析在<em class="li"> JavaScript领域</em>(左边的紫色)和<em class="li">原生领域</em>(右边的黑色)中运行的东西来统计遍数:</p><figure class="lz ma mb mc fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mk"><img src="../Images/1ed930177f1a4e4589f6704cff2df075.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TFOpiGcat_rSXVnxjcldqA.png"/></div></div></figure><p id="d6f6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这并不奇怪，我们确实已经消除了初始化后的所有过桥通道。相应地，滚动事件的处理和视图属性的更新现在都发生在<em class="li">本地领域</em>中。</p><p id="7c31" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">尽管如此，我们还是不开心。这种实现可能是高性能的，但是它相当复杂，并且需要本地的专业知识。我们能从JavaScript中做同样的事情吗？</p><h2 id="9895" class="ki kj hu bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated">第三次是一种魅力——胜利的宣告式API</h2><p id="678e" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">那么，我们能从JavaScript中做同样的事情吗？这是React Native的百万美元问题。为了让框架真正有用，我们必须找到解决这些性能问题的方法，而不求助于本机代码。</p><p id="e4ea" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">自从<a class="ae ka" rel="noopener" href="/@talkol/performance-limitations-of-react-native-and-how-to-overcome-them-947630d7f440">上一篇文章</a>以来，这是一个已经取得很大进展的领域。减少过桥次数的关键是<em class="li">声明式API </em>。它允许我们在JavaScript中预先声明行为，序列化整个声明，并在初始化期间通过桥发送一次。从这一点开始，一个通用的<em class="li">本机驱动程序</em>——一个你不需要自己编写的驱动程序——将根据声明的规范在<em class="li">本机领域</em>中执行行为。</p><p id="0343" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们想要的行为由两部分组成—监听滚动位置的变化和更新视图属性(不透明度和缩放)。对于后者，我们知道<a class="ae ka" href="https://facebook.github.io/react-native/docs/animated.html" rel="noopener ugc nofollow" target="_blank"> Animated </a>，作为核心一部分的优秀动画库，提供了很好的支持。</p><p id="69ae" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">鲜为人知的是，Animated也可以基于滚动事件<a class="ae ka" href="https://github.com/facebook/react-native/blob/c7387fefc85fd15dceadfa291857099ed3e848b8/Examples/UIExplorer/js/NativeAnimationsExample.js#L195" rel="noopener ugc nofollow" target="_blank">驱动一个<code class="eh mf mg mh mi b"><a class="ae ka" href="https://facebook.github.io/react-native/docs/animated.html#animatedvalue" rel="noopener ugc nofollow" target="_blank">Animated.Value</a></code>。</a></p><p id="e716" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是怎么回事？让我们进入完整的实现:</p><figure class="lz ma mb mc fq iv"><div class="bz el l di"><div class="md me l"/></div></figure><p id="3c6e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们从定义一个<code class="eh mf mg mh mi b">Animated.Value</code>开始，我们将使用它在任何给定的时间保持滚动位置。我们为ListView提供了一个定制的ScrollView组件——一个<code class="eh mf mg mh mi b">Animated.ScrollView</code>，而不是一个常规的ScrollView。<code class="eh mf mg mh mi b">Animated.ScrollView</code>让我们声明我们的<code class="eh mf mg mh mi b">Animated.Value</code>由本地<code class="eh mf mg mh mi b">onScroll</code>事件的<code class="eh mf mg mh mi b">contentOffset</code>属性驱动。</p><p id="0d6e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从这一点开始，我们可以使用基于<code class="eh mf mg mh mi b">Animated.Value</code>的内插视图属性的标准动画方法。这需要将我们的标题图像改为<code class="eh mf mg mh mi b">Animated.Image</code>，并允许我们从滚动位置插入<code class="eh mf mg mh mi b">opacity</code>和<code class="eh mf mg mh mi b">transform.scale</code>。</p><p id="b9fa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，整个实现是声明性的。我们不再有一个强制性的<code class="eh mf mg mh mi b">onScroll</code>函数来计算我们的效果。</p><p id="ee08" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还要注意，我们已经指定了<code class="eh mf mg mh mi b">useNativeDriver</code>。React Native最新版本中动画库的实现最终包含了一个<em class="li">本机驱动程序</em>，它可以在不使用桥的情况下执行来自<em class="li">本机领域</em>的整个声明。</p><h2 id="f120" class="ki kj hu bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated">第三次尝试—性能分析</h2><p id="4612" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">像往常一样，我们将通过分析运行在<em class="li"> JavaScript领域</em>(左边的紫色)和运行在<em class="li">本地领域</em>(右边的黑色)中的内容来计算通过次数:</p><figure class="lz ma mb mc fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ml"><img src="../Images/ceede3badf0d66523bda41866d77a052.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b338WkFCW3WDel08VxxApA.png"/></div></div></figure><p id="76c5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<em class="li"> JavaScript领域</em>中唯一运行的部分是我们声明的初始化。整个声明的行为被序列化并通过桥发送一次，以便配置动画的通用本地驱动程序<em class="li">。</em></p><p id="8497" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">配置好驱动程序后，它会在<em class="li">本地领域</em>中为我们一帧一帧地进行处理，无需额外的过桥。这一部分已经变灰，因为它不再由我们的代码负责。</p><h2 id="699b" class="ki kj hu bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated">比较三种实现</h2><p id="77c4" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">GitHub上提供了所有三个实现的完整代码:</p><div class="mm mn fm fo mo mp"><a href="https://github.com/wix/rn-perf-experiments2" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab ej"><div class="mr ab ms cl cj mt"><h2 class="bd hv fv z el mu eo ep mv er et ht dt translated">wix/rn-性能-实验2</h2><div class="mw l"><h3 class="bd b fv z el mu eo ep mv er et ek translated">rn-perf-experiments2 -重温反应本机性能实验</h3></div><div class="mx l"><p class="bd b gc z el mu eo ep mv er et ek translated">github.com</p></div></div><div class="my l"><div class="mz l na nb nc my nd ja mp"/></div></div></a></div><p id="dd09" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个演示项目让您选择使用哪个实现，以便可以并排比较它们。尝试在真实设备上运行它。在模拟器上判断性能通常是不准确的。</p><p id="250d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于它只是一个简单的演示应用程序，所以很少有无关的桥梁活动。您可能不会注意到实现之间的任何差异。为了帮助这一点，演示应用程序提供了一个开关来模拟大量活动的压力条件。如您所见，打开它将使性能差异更加明显:</p><figure class="lz ma mb mc fq iv fe ff paragraph-image"><div class="fe ff ne"><img src="../Images/e3c17a53468218078db8ce940bbae465.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/1*v29H0OZ-GngqseBG-7jqEA.gif"/></div></figure><h2 id="ef87" class="ki kj hu bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated">摘要</h2><p id="05ae" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">构建高性能的React本机应用程序并不总是简单明了的。通常你应该从简单的方法开始，但是如果你开始注意到你的应用程序的性能问题，总是要考虑过桥的次数。</p><p id="58a9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">随着框架的成熟，容易产生大量桥接流量的常见任务可以通过声明式API来解决，该API旨在减少桥接次数。<a class="ae ka" href="https://facebook.github.io/react-native/docs/animated.html" rel="noopener ugc nofollow" target="_blank">动画</a>库就是一个很好的例子。另一个有趣的例子是<a class="ae ka" href="https://github.com/wix/react-native-interactable" rel="noopener ugc nofollow" target="_blank">react-native-interactive</a>，我已经在<a class="ae ka" href="https://youtu.be/mjsv8NJnt5k" rel="noopener ugc nofollow" target="_blank"> ReactConf 2017 </a>中演示过了。要了解更多信息，请查看帖子“<a class="ae ka" href="https://hackernoon.com/moving-beyond-animations-to-user-interactions-at-60-fps-in-react-native-b6b1fa0ba525" rel="noopener ugc nofollow" target="_blank">在React Native </a>中以60 FPS的速度超越动画到用户交互”。</p><p id="611a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果遇到瓶颈，找不到解决性能问题的声明式API，您总是可以依靠本机实现。让一两个本地开发人员加入你的团队，像我们在第二个实现中所做的那样，将有问题的部分移植到本地。它并不总是漂亮的，但它的工作。</p><div class="lz ma mb mc fq ab cb"><figure class="nf iv ng nh ni nj nk paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nf iv ng nh ni nj nk paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nf iv ng nh ni nj nk paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="nl nm nn"><p id="f922" class="jc jd li je b jf jg jh ji jj jk jl jm no jo jp jq np js jt ju nq jw jx jy jz hn dt translated"><a class="ae ka" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ka" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ka" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ka" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd li je b jf jg jh ji jj jk jl jm no jo jp jq np js jt ju nq jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ka" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ka" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lz ma mb mc fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nr"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="lz ma mb mc fq iv"><div class="bz el l di"><div class="ns me l"/></div></figure></div></div>    
</body>
</html>