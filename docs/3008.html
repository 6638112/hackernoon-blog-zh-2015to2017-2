<html>
<head>
<title>In pursuit of better JVM Futures — Kotlin coroutines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">追求更好的JVM未来——科特林协程</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/in-pursuit-of-better-jvm-futures-kotlin-coroutines-281a79211b09?source=collection_archive---------2-----------------------#2017-03-06">https://medium.com/hackernoon/in-pursuit-of-better-jvm-futures-kotlin-coroutines-281a79211b09?source=collection_archive---------2-----------------------#2017-03-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/b0a060dcc571b943c88aa6f60bbbf3f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ltBh0rPOLOZOV72WmqmnVg.jpeg"/></div></div></figure><p id="637b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我已经使用C#的TPL有一段时间了，偶尔为Android或一些web东西回到Java总是让我讨厌它的每一点。不是JVM部分(在我看来JVM比CLR好得多)，而是它的编写部分(并不是说我到处都有C#的问题)。线程和回调的实现方式，以及函数直到最近才成为一等公民。虽然Java 8带来了很多东西，但仍有一些问题需要解决，其中之一是未来(或异步/等待或承诺或延迟)，我强烈地感觉到Kotlin即使在其婴儿期也比预期的要成功。在这篇博文中，我将解释为什么你需要一个更好的异步编程模型，我与Kotlin的一点历史，以及Kotlin如何带来有趣的东西。</p><p id="2124" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所有这些都是我<strong class="je hv">的个人观点</strong>，绝不是说一个技术比另一个技术更好。然而，我将向您展示过去做错了什么，以及各种技术是如何相互启发并为范例添加新内容的。</p><h2 id="919b" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">使用Android构建案例</h2><p id="f2ef" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">我将使用Android来构建我的案例，这是典型的开发人员的噩梦。引用Swing或JavaFX对大多数开发人员来说可能不太相关，因为现在有更多的人在使用Android。如果你尝试过编写一个Android应用程序，在主线程(也叫UI线程)和后台线程之间来回转换，你知道我会怎么做。作为复习，我将引用<a class="ae la" href="https://kylewbanks.com/blog/Tutorial-Android-Parsing-JSON-with-GSON" rel="noopener ugc nofollow" target="_blank">这篇教程</a>；你可以在StackOverflow和博客上找到大量这样的教程和技术。在任何类型的io或计算密集型进程的典型场景中，在完成一些调用回调或方法的操作后，您将启动一个后台线程，最终在UI(又名<code class="eh lb lc ld le b">runOnUiThread</code>)上运行其余代码。</p><p id="c77f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是等等，有一些库可以为这样的场景编写<em class="lf">更好的代码</em>，比如<a class="ae la" href="https://github.com/ReactiveX/RxJava" rel="noopener ugc nofollow" target="_blank"> RxJava </a>、<a class="ae la" href="http://square.github.io/otto/" rel="noopener ugc nofollow" target="_blank"> Otto </a>等等。“为什么不用它们？”有人可能会问。如果你去过UWP(通用视窗平台)的令人恐惧的地方，并且用C#开发了一个应用程序，你可能已经尝到了我所说的简单。<strong class="je hv">任务并行库</strong>使得大量任务的旋转变得轻而易举，并且控制哪个任务在哪个线程上运行，或者在什么上下文上执行将恢复。显然有一个学习曲线，但是一旦你掌握了它；你会在日常生活中的任何地方用任务来代替线程。虽然Android库提倡真正好的模式，但是没有一个模式比得上调用类似于在后台线程上运行的函数并像普通函数一样返回值的简单性。没有回调，没有事件跟踪，没有事件流，没有跟踪什么都没有。像调用这样简单的函数！这不仅简化了代码编写，也使调试变得更加容易。而不是猜测和搜索代码中的注释；您知道被调用的代码位于何处，以及调用完成后它如何恢复。</p><p id="5fed" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我这么说吧，你更喜欢什么？一个简单的<code class="eh lb lc ld le b">var user = await getUserInfo()</code>或(等等，我必须使用Otto并使用多行来显示问题的一部分):</p><pre class="lg lh li lj fq lk le ll lm aw ln dt"><span id="dff5" class="ka kb hu le b fv lo lp l lq lr">// Somewhere in code<br/>bus = <strong class="le hv">new</strong> Bus(ThreadEnforcer.MAIN);<br/>bus.register(this);<br/>...</span><span id="0281" class="ka kb hu le b fv ls lp l lq lr">// Somewhere else in code<br/><strong class="le hv">@Subscribe</strong><br/><strong class="le hv">public</strong> <strong class="le hv">void</strong> onUserInfo(User u) {<br/>    Toast.makeText(this, this.getUserMessage(u), Toast.LENGTH_LONG).show();<br/>} <br/>...</span><span id="decd" class="ka kb hu le b fv ls lp l lq lr">// In a galaxy far far away<br/><strong class="le hv">public class</strong> UserInfoFetcherRunnable <strong class="le hv">implements </strong>Runnable {<br/>    ...<br/>    <a class="ae la" href="http://twitter.com/Override" rel="noopener ugc nofollow" target="_blank">@Override</a><br/>    <strong class="le hv">public</strong> <strong class="le hv">void</strong> run() {<br/>        /*<br/>         * Code that does the fetching in background<br/>         */<br/>        ... </span><span id="f10d" class="ka kb hu le b fv ls lp l lq lr">        // carry the stupid bus around<br/>        this.<!-- -->bus.post(user);<br/>    }<br/>    ...<br/>}</span></pre><p id="5bbe" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">仅此一点就足以让您相信代码中存在问题。如果用代码解释起来很难而且很分散，那么就很难调试。我可以用RxJava引用一个类似的例子。</p><p id="27da" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">同样，不要误解我的意思，<em class="lf">我并没有暗示Otto或RxJava是愚蠢的duck tapes </em>，它们完全有合法的用法。我现在能想到的一个方法是当服务器有推送事件时，在UI上提供一个更新。但这并不意味着它对每个场景都是完美的，对吗？另一个选项可以是<a class="ae la" href="https://github.com/BoltsFramework/Bolts-Android" rel="noopener ugc nofollow" target="_blank">螺栓框架</a>。它的API几乎直接来自C# TPL。虽然它确实为你提供了<code class="eh lb lc ld le b">continueWith</code>、<code class="eh lb lc ld le b">onSuccess</code>或<code class="eh lb lc ld le b">onSuccessTask</code>等。仍然有回调的税收，和一些<code class="eh lb lc ld le b">Continuation</code>初始化。</p><h2 id="7845" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">需要异步/等待</h2><p id="817a" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">Android的工作流只是一个例子，即使在语言层面上有异步编程结构，然后能够在一个线程池中复用它是至关重要的。不管是HTTP服务器，还是数据库引擎；随着时间的推移，异步范式已经证明了它的合理性。</p><p id="3efe" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然Java 8已经支持<a class="ae la" href="http://www.deadcoderising.com/java8-writing-asynchronous-code-with-completablefuture/" rel="noopener ugc nofollow" target="_blank"> CompletableFuture </a> s，但async/await的奢华给了它某种我们都熟悉的直观性。像Node.js这样的回调函数也在向async/await支持发展，这是有原因的，Python 3.6最近做了一个非常好的<a class="ae la" href="https://docs.python.org/3/library/asyncio-task.html" rel="noopener ugc nofollow" target="_blank">实现</a>，C#有TPL。</p><h2 id="cb54" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">我和科特林的模糊约会</h2><p id="23c7" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">在尝试建立一个Android应用程序之前，我尝试了一两次Kotlin。科特林那时才刚刚起步。虽然我确实很喜欢这个非常小的运行时、互操作性、简洁的语法和更简洁的方法，但我理解得很好。具体到Android，能够传递像<code class="eh lb lc ld le b">fun onClick(listener: () -&gt; Unit)</code>这样的回调，并像函数体<code class="eh lb lc ld le b">view.onClick { ... }</code>一样不带括号地连接它们。它还允许更简单的数据类、函数扩展和已经支持它的大量库。高兴但不满意的是，我仍然在寻找某种async/await支持，并尽可能使用Kotlin回到我的日常工作中。如果你是Android发烧友，想阅读更多关于为什么你应该使用Kotlin的文章，有很多好的文章。</p><h1 id="6666" class="lt kb hu bd kc lu lv lw kg lx ly lz kk ma mb mc kn md me mf kq mg mh mi kt mj dt translated">遇见协程！！！</h1><p id="9a7d" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">随着最近<a class="ae la" href="https://kotlinlang.org/docs/reference/whatsnew11.html" rel="noopener ugc nofollow" target="_blank">kot Lin 1.1的发布</a>似乎我的愿望就要实现了。虽然该功能还处于试验阶段，但我认为它离生产就绪不会太远，因为我能够完全表达我在应用程序开发体验中实际看到的所有场景。在我听说新版本后，为了尝试一下，我重写了一个服务，使用协程对IP进行地理定位。</p><p id="7f09" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我<strong class="je hv">不会</strong>在这里进入关于协程的教程模式，因为你可以在<a class="ae la" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md#composing-suspending-functions" rel="noopener ugc nofollow" target="_blank">官方文档</a>上找到你需要的一切。对于Android用户来说，有一篇非常好的<a class="ae la" rel="noopener" href="/@haarman.niek/async-await-in-android-f0202cf31088#.ws939fkl8"> Kotlin协程文章</a>和几个已经支持Kotlin 1.1协程的<a class="ae la" href="https://github.com/metalabdesign/AsyncAwait" rel="noopener ugc nofollow" target="_blank">库</a>。在处理服务器代码时，我观察到一些关于协程的东西，我觉得它们超出了通常的async/await实现(甚至超出了C#所做的)。它们不仅对您可能已经做的事情进行了语法清理，而且还为复杂场景提供了一些表达代码的强大方法。让我们来看看其中的几个:</p><h2 id="f0cc" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">通道和选择表达式</h2><p id="f9c5" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">虽然C# TPL为您提供了任务的基本模块，并启发了许多现代异步实现；任务间的通信还没有得到很好的解决。有人可能会说你使用<code class="eh lb lc ld le b">BufferBlock </code>或者使用这里描述的<a class="ae la" href="http://blog.stephencleary.com/2012/11/async-producerconsumer-queue-using.html" rel="noopener ugc nofollow" target="_blank">技术</a>。但像Golang或Erlang，频道或邮箱是一等公民，表达沟通更干净。Kotlin coroutines从上面取了一页，并带有内置的通道支持(<a class="ae la" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md#channels" rel="noopener ugc nofollow" target="_blank">文档</a>)。这使您可以实现复杂的模式，如<a class="ae la" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md#pipelines" rel="noopener ugc nofollow" target="_blank">管道</a>、<a class="ae la" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md#fan-out" rel="noopener ugc nofollow" target="_blank">扇出</a>或<a class="ae la" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md#fan-in" rel="noopener ugc nofollow" target="_blank">扇入</a>等。将通道与选择表达式结合起来，您可以编写复杂的调度程序，如:</p><pre class="lg lh li lj fq lk le ll lm aw ln dt"><span id="18ea" class="ka kb hu le b fv lo lp l lq lr"><strong class="le hv">suspend fun</strong> chatMessageProcessor(users: ReceiveChannel&lt;IMessage&gt;, system: ReceiveChannel&lt;IMessage&gt;, timeout: ReceiveChannel&lt;IMessage&gt;) {<br/>    <strong class="le hv">select</strong>&lt;<strong class="le hv">Unit</strong>&gt; {<br/>        users.onReceive { value -&gt;  ... }<br/>        system.onReceive { value -&gt;  ... }<br/>        timeout.onReceive { value -&gt;  ... }<br/>    }<br/>}</span></pre><p id="d1c6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然这对于许多Golang人来说听起来很熟悉，但在JVM领域，等待多个事件中的一个，然后采取相应的行动，这确实是一种很好的方式(我已经可以看到一些Akka粉丝在拔头发)。这可以让您派生出一些协程，这些协程封装了一些状态，并根据来自环境的一些消息对它们进行操作。例如，等待来自UI的消息，然后对DB进行更新，或者对服务器进行API调用。另一个例子可能是向其他协同程序发布聊天消息，这些协同程序向同一聊天室中的其他用户推送聊天消息。这听起来熟悉吗？我们正在向演员靠拢。</p><h2 id="b1e0" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">演员</h2><blockquote class="mk"><p id="ea92" class="ml mm hu bd mn mo mp mq mr ms mt jz ek translated">参与者是封装了状态和行为的对象，它们专门通过交换放入接收者邮箱的消息来进行通信。— <a class="ae la" href="http://doc.akka.io/docs/akka/current/general/actor-systems.html#actor-systems" rel="noopener ugc nofollow" target="_blank">阿卡</a></p></blockquote><p id="224d" class="pw-post-body-paragraph jc jd hu je b jf mu jh ji jj mv jl jm jn mw jp jq jr mx jt ju jv my jx jy jz hn dt translated">Kotlin coroutines库提供了基本的actors支持，令人惊叹的是它的语法也很干净；您不必实现接口，也不必为礼仪目的定义所需的方法。它就像一个go例程或Erlang进程，一个简单的函数。这看起来很简单:</p><pre class="lg lh li lj fq lk le ll lm aw ln dt"><span id="1d41" class="ka kb hu le b fv lo lp l lq lr"><strong class="le hv">fun </strong>messageDeliveryActor() = actor&lt;ChatMessage&gt;(<strong class="le hv">CommonPool</strong>) {<br/>    // Do your stuff here...<br/>}</span></pre><p id="ac29" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">像任何其他的<code class="eh lb lc ld le b">async</code>或<code class="eh lb lc ld le b">run</code>一样，它需要一个上下文，仅此而已！请记住，已经有成熟的Java库提供了actor支持。我没有破坏他们中的任何人！</p><h2 id="1d8b" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">透明上下文切换</h2><p id="2f36" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">因此，在编写服务器时，我遇到了现有包不支持或利用异步API的典型问题(没有Java NIO，没有netty，什么都没有)。Maxmind GeoIP2库的<code class="eh lb lc ld le b">DatabaseReader</code>使用了<code class="eh lb lc ld le b">File</code>对象；现在调用任何读取文件的操作都会阻塞线程池中的线程。虽然一个解决方案是自己做一个异步实现，但这并不总是可行的。我使用的解决方案是为这种阻塞操作提供一个线程池，并让我的IO协程只绑定到那个上下文。这样我就不会阻塞我的请求处理线程。下面是我的查找类的内部结构:</p><pre class="lg lh li lj fq lk le ll lm aw ln dt"><span id="ad15" class="ka kb hu le b fv lo lp l lq lr">findContext = newFixedThreadPoolContext(4)</span><span id="39d4" class="ka kb hu le b fv ls lp l lq lr">suspend private fun find(ip: String): CityInfo? = run(findContext) {<br/>    // Do the blocking thread blocking lookups here<br/>}</span></pre><p id="d24b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从我的请求中调用这个子例程确实是透明的。在我的例子中，我使用的是<code class="eh lb lc ld le b">jooby</code>，它支持异步via <code class="eh lb lc ld le b">Deferred</code>。因此，我调用find的代码如下所示:</p><pre class="lg lh li lj fq lk le ll lm aw ln dt"><span id="a785" class="ka kb hu le b fv lo lp l lq lr"><strong class="le hv">        fun</strong> getGeoInfo()= Deferred { req, def -&gt;<br/>            launch (CommonPool) {<br/>                ...<br/>                <strong class="le hv">val</strong> ip = req.param("ip").value() ?: req.ip()<br/>                <br/>                // lookupEngine.find won't use CommonPool<br/>                <strong class="le hv">val</strong> info = lookupEngine.find(ip)<br/>                ...<br/>            }<br/>        }<br/></span></pre><p id="9ad0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">调用<code class="eh lb lc ld le b">find(ip)</code>时，可以看到无缝转换。在没有公开使用不同线程池的知识的情况下，我在不同的上下文中调用了一个协程，并且将得到没有任何欺骗的结果。现在，由于Kotlin的语法和协程实现，这是可能的，并显示了它们如何携手提供这样一个透明的上下文切换。这不仅将知识抽象化，还带走了我可能不得不支付的编码成本。服务器的完整代码在这里有<a class="ae la" href="http://chiselapp.com/user/mikeshinoda/repository/Kotlin-Maxmind/home" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="cd3b" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">包装它</h2><p id="bfa4" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">我想我会就此打住。我会让你们自己尝试并建立自己的观点。有人可能会说Scala已经有了<a class="ae la" href="http://docs.scala-lang.org/sips/pending/async.html" rel="noopener ugc nofollow" target="_blank">异步/等待支持</a>！科特林有什么让人激动或与众不同的地方？老实说，我已经尝试了很多次Scala，但总是被语法淹没(我不知道为什么，有这么多方法可以做这么多事情)。我真的很想去Scala town，在那里我可以混合使用函数式和面向对象的风格。但是现在，我很高兴看到一个语法上得体、干净的协程实现。Kotlin可能很年轻，但它令人惊讶地令人愉快、稳定，有一个令人敬畏的社区，并为JVM带来了一直想要的协程支持。</p><div class="lg lh li lj fq ab cb"><figure class="mz iv na nb nc nd ne paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mz iv na nb nc nd ne paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mz iv na nb nc nd ne paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="nf ng nh"><p id="f922" class="jc jd lf je b jf jg jh ji jj jk jl jm ni jo jp jq nj js jt ju nk jw jx jy jz hn dt translated"><a class="ae la" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客们下午的开始。我们是<a class="ae la" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae la" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae la" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd lf je b jf jg jh ji jj jk jl jm ni jo jp jq nj js jt ju nk jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae la" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae la" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lg lh li lj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nl"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>