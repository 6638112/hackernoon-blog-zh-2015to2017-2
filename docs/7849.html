<html>
<head>
<title>From CSV to Buxfer: an unexpected journey — Cleaner</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从CSV到巴克斯弗:一次意想不到的旅行——更干净</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/from-csv-to-buxfer-an-unexpected-journey-cleaner-c87e8a77fda6?source=collection_archive---------33-----------------------#2017-11-09">https://medium.com/hackernoon/from-csv-to-buxfer-an-unexpected-journey-cleaner-c87e8a77fda6?source=collection_archive---------33-----------------------#2017-11-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="01c0" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">第2部分—清理程序:一个关于如何编写清理原始数据的程序的故事</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/846eecc97d656cb8fb89978e3834478d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y5i8nyIuuRwil_YPYOz6rg.jpeg"/></div></div></figure><h1 id="9adc" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">序文</h1><p id="4527" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">在<a class="ae lj" rel="noopener" href="/@wilk/from-csv-to-buxfer-an-unexpected-journey-introduction-ba43ef768fe2">引言—第1部分</a>中，我已经定义了本项目的基础设施，绘制了整体图，并收集了所有的部分。<br/>现在是时候写第一个程序了:清洁工！</p><p id="d6dc" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">Cleaner要做的唯一一件事就是通过删除无用的数据和元数据，将原始的CSV文件解析为随时可用的CSV文件。<br/>结果将由收集器(<a class="ae lj" rel="noopener" href="/@wilk/from-csv-to-buxfer-an-unexpected-journey-collector-4dbde92c1e7b">第3部分</a>)使用。</p><h2 id="37ba" class="lp jw hu bd jx lq lr ls kb lt lu lv kf kw lw lx kh la ly lz kj le ma mb kl mc dt translated">旅行</h2><p id="f1a4" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">在本文中，我将介绍这一旅程的第二部分:</p><ol class=""><li id="1a87" class="md me hu kp b kq lk kt ll kw mf la mg le mh li mi mj mk ml dt translated"><a class="ae lj" rel="noopener" href="/@wilk/from-csv-to-buxfer-an-unexpected-journey-introduction-ba43ef768fe2">第1部分:引言</a></li><li id="c586" class="md me hu kp b kq mm kt mn kw mo la mp le mq li mi mj mk ml dt translated">第2部分(本部分):更清洁</li><li id="2dea" class="md me hu kp b kq mm kt mn kw mo la mp le mq li mi mj mk ml dt translated"><a class="ae lj" rel="noopener" href="/@wilk/from-csv-to-buxfer-an-unexpected-journey-collector-4dbde92c1e7b">第3部分:收集器</a></li><li id="ac79" class="md me hu kp b kq mm kt mn kw mo la mp le mq li mi mj mk ml dt translated"><a class="ae lj" rel="noopener" href="/@wilk/from-csv-to-buxfer-an-unexpected-journey-goxfer-88d8a14e8905">第4部分:Goxfer </a></li><li id="2263" class="md me hu kp b kq mm kt mn kw mo la mp le mq li mi mj mk ml dt translated"><a class="ae lj" rel="noopener" href="/@wilk/from-csv-to-buxfer-an-unexpected-journey-conclusions-b1274aa9841e">第5部分:结论</a></li></ol><h2 id="5d7c" class="lp jw hu bd jx lq lr ls kb lt lu lv kf kw lw lx kh la ly lz kj le ma mb kl mc dt translated">先安装！</h2><p id="b54d" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">Cleaner将是一个<a class="ae lj" href="https://hackernoon.com/tagged/python" rel="noopener ugc nofollow" target="_blank"> Python </a>程序，所以我需要首先设置码头工人容器！<br/>正如我在上一篇文章中提到的，我不想在我的系统上安装任何东西，所以我要通过添加一个新的<strong class="kp hv">命令</strong>来更新docker-composit . yml文件中的setup-python服务，该文件在开始时将只被调用一次:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="6a34" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">很好。<br/>我定义安装服务只是为了让Python开发环境做好准备。<br/>此外，我还告诉docker-const用这个Python Dockerfile构建<em class="mt"> data.python3:1 </em>图像(该图像将用于其他服务):</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="d06e" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">修复版本会让你的系统变得可预测和确定:<strong class="kp hv">不要依赖最新版本。</strong></p><p id="9998" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">Python容器只安装了python包管理器<a class="ae lj" href="https://pypi.python.org/pypi/pip" rel="noopener ugc nofollow" target="_blank"> <strong class="kp hv"> pip </strong> </a>，还有一个通用<em class="mt">入口点</em>用于传递来自外部的命令:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="a9ed" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">现在，让我们试试这个容器并安装一个新项目的依赖项:<a class="ae lj" href="https://api.mongodb.com/python/current/" rel="noopener ugc nofollow" target="_blank"> <strong class="kp hv"> pymongo </strong> </a>！<br/>耶，这将是<a class="ae lj" href="https://hackernoon.com/tagged/mongodb" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>的Python驱动程序。<br/>为此，我需要进入安装容器并启动"<em class="mt"> pip install </em>"和"<em class="mt"> pip freeze </em>"命令，这样我就可以安装依赖项和pip定义<strong class="kp hv">需求所需的每个文件。</strong></p><pre class="jk jl jm jn fq mu mv mw mx aw my dt"><span id="d81c" class="lp jw hu mv b fv mz na l nb nc"># first, build the image<br/>$ docker-compose build</span><span id="d04d" class="lp jw hu mv b fv nd na l nb nc"># --rm will remove the container after its execution<br/>$ docker-compose run --rm setup bash</span></pre><p id="3225" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">然后，从容器内部:</p><pre class="jk jl jm jn fq mu mv mw mx aw my dt"><span id="241c" class="lp jw hu mv b fv mz na l nb nc"># don't forget to initialize, so the project's dependencies will be stored locally<br/>$ virtualenv .<br/>$ source ./bin/activate</span><span id="ae6c" class="lp jw hu mv b fv nd na l nb nc"># install and freeze<br/># no need to mark a specific pymongo version during the setup phase<br/>$ pip install pymongo<br/>$ pip freeze &gt; requirements.txt</span></pre><p id="ba2e" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">好了，设置完成了！<br/>如果我需要在另一个系统上恢复环境，没问题，docker-compose会为我做同样的事情:</p><pre class="jk jl jm jn fq mu mv mw mx aw my dt"><span id="c40f" class="lp jw hu mv b fv mz na l nb nc">$ docker-compose run --rm setup-python</span></pre><h1 id="631f" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">清洁工:手放在上面！</h1><p id="4fba" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">最后，本文的核心。数据！耶！<br/>这是我要编码的项目的第一部分:<strong class="kp hv">清洁工</strong>。<br/>该工具必须从一个装满CSV文件的文件夹中读取，然后将清理后的文件写入另一个文件夹。<br/>我需要从这个样本出发:</p><pre class="jk jl jm jn fq mu mv mw mx aw my dt"><span id="e612" class="lp jw hu mv b fv mz na l nb nc"># this is a header row<br/><em class="mt">Date  Account Name Number Description  Notes  Memo Category Type Action Reconcile  To With Sym  From With Sym  To Num.  From Num.  To Rate/Price  From Rate/Price</em></span><span id="d621" class="lp jw hu mv b fv nd na l nb nc"># this is a data row<br/>"04/06/2016","Abbigliamento","","maglietta","","","Sbilancio-EUR","T","","N","€ 5,00","","5,00","","",""</span><span id="e8e1" class="lp jw hu mv b fv nd na l nb nc"># another data row, part of the previous one<br/>"","","","","","","Abbigliamento","S","","N","€ 5,00","","5,00","","1,00",""</span><span id="e040" class="lp jw hu mv b fv nd na l nb nc"># another data row, part of the previous one<br/>"","","","","","","Sbilancio-EUR","S","","N","","-€ 5,00","","-5,00","","1,00"</span></pre><p id="a3bb" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">对此:</p><pre class="jk jl jm jn fq mu mv mw mx aw my dt"><span id="4a4f" class="lp jw hu mv b fv mz na l nb nc"># header row<br/>Date,Account Name,Description,To Num.</span><span id="dcbb" class="lp jw hu mv b fv nd na l nb nc"># just one data row<br/>04/06/2016,Abbigliamento,maglietta,"5,00"</span></pre><p id="cba0" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">让我们用Python来做这个吧！<br/>要做的第一件事是定义<em class="mt">源文件夹</em>(清洗程序获取原始CSV数据的地方)和<em class="mt">目标文件夹</em>(存储清洗后的数据的地方)。<br/>让我们创建一个样本文件夹(源)和一个清理过的文件夹(目标)。<br/>顺便说一下，我希望用户有机会指定自己的目录:因此，我将使用<strong class="kp hv">环境变量</strong>和上面列出的默认值，一个名为<em class="mt"> SOURCE_FOLDER </em>，另一个名为<em class="mt"> CLEANED_FOLDER </em>。<br/>但是首先，我要在docker-compose.yaml中创建一个<strong class="kp hv"> cleaner </strong>服务:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="c679" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">Cleaner将使用与<em class="mt"> setup-python </em>服务相同的docker映像，因为它实际上是相同的。<br/>定义完环境变量后，我需要在容器中挂载整个根文件夹，这样当命令执行时，它会找到<strong class="kp hv"> python/src/cleaner.py </strong>。<br/>因此，让我们在src文件夹中添加一个空的cleaner.py:</p><pre class="jk jl jm jn fq mu mv mw mx aw my dt"><span id="f5e3" class="lp jw hu mv b fv mz na l nb nc">$ touch python/src/cleaner.py</span></pre><p id="55ff" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">现在，<strong class="kp hv">清洁工应该做什么？</strong> <br/>我们来定义一下程序:</p><ol class=""><li id="f5a0" class="md me hu kp b kq lk kt ll kw mf la mg le mh li mi mj mk ml dt translated">定义CSV <strong class="kp hv">列所需的</strong>索引(如“日期”、“描述”等)。)</li><li id="7841" class="md me hu kp b kq mm kt mn kw mo la mp le mq li mi mj mk ml dt translated">从环境中检索<strong class="kp hv">源和目标文件夹</strong></li><li id="f373" class="md me hu kp b kq mm kt mn kw mo la mp le mq li mi mj mk ml dt translated"><strong class="kp hv">恢复/创建</strong>dest文件夹(我想从之前的迭代中清理掉它)</li><li id="8efd" class="md me hu kp b kq mm kt mn kw mo la mp le mq li mi mj mk ml dt translated"><strong class="kp hv">从源文件夹中读取文件列表</strong></li><li id="eaf9" class="md me hu kp b kq mm kt mn kw mo la mp le mq li mi mj mk ml dt translated">对于每个原始文件，<strong class="kp hv">在dest文件夹中创建一个新的清理文件</strong></li></ol><p id="2467" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated"><strong class="kp hv">是时候写下来了！</strong></p><p id="c2e9" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">看着上面的样品(原始的和清洁的)，我可以说需要的色谱柱是:</p><ul class=""><li id="ec6f" class="md me hu kp b kq lk kt ll kw mf la mg le mh li ne mj mk ml dt translated"><em class="mt">日期</em>(指数:0)</li><li id="65e6" class="md me hu kp b kq mm kt mn kw mo la mp le mq li ne mj mk ml dt translated"><em class="mt">账户名称</em>(索引:1)</li><li id="38bb" class="md me hu kp b kq mm kt mn kw mo la mp le mq li ne mj mk ml dt translated"><em class="mt">描述</em>(索引:3)</li><li id="7c8a" class="md me hu kp b kq mm kt mn kw mo la mp le mq li ne mj mk ml dt translated"><em class="mt">去小水。</em>(指数:12)</li></ul><p id="b267" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">我要把它们放在常量里。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="e421" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">然后，让我们用<strong class="kp hv"> os.getenv </strong>从环境变量中获取source和dest文件夹:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="8811" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">恢复/创建过程可以依次定义为rmdir和mkdir，用<strong class="kp hv"> shutil.rmtree </strong>和<strong class="kp hv"> os.makedirs </strong>:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="b22f" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">使用<strong class="kp hv">列表目录</strong>和<strong class="kp hv">列表理解</strong>阅读CSV原始文件非常容易:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="30bc" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">现在，最重要的部分！<br/>用<strong class="kp hv"> csv.reader </strong>和<strong class="kp hv"> csv.writer </strong>扫描每个raw文件，解析它并在dest文件夹内创建一个新的清理文件:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="97e8" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">使用csv.reader打开并解析CSV文件。<br/>然后，在dest文件夹中创建清理后的文件。<br/>最后，解析CSV文件的每一行，只取那些<strong class="kp hv"> DATE_COLUMN </strong>字段非空的行。</p><p id="b0fe" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">好了，清洁剂也可以使用了。<br/>这就是全部源代码:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="b848" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">让我们试试:</p><pre class="jk jl jm jn fq mu mv mw mx aw my dt"><span id="1993" class="lp jw hu mv b fv mz na l nb nc">$ docker-compose run --rm cleaner</span></pre><p id="3d5d" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">当执行终止时，dest文件夹已经被清除的数据填充，就像上面列出的预期示例一样。<br/> <strong class="kp hv">干得好！</strong></p><h1 id="a9c8" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">第2部分结束</h1><p id="b95f" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">现在，我有了一个更干净的程序，可以将原始的不可读数据转换成干净的新数据，随时可以使用。<br/>我想产生这个中间步骤，因为我想检查清理后的数据是否可靠；事实上，下一个程序将是收集器，它将使用这些转换后的数据来完成工作。</p><p id="fd54" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">如果你喜欢这篇文章，不要忘记分享它！<br/>第三部:收藏家见！</p></div><div class="ab cl nf ng hc nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="hn ho hp hq hr"><h2 id="c6d6" class="lp jw hu bd jx lq lr ls kb lt lu lv kf kw lw lx kh la ly lz kj le ma mb kl mc dt translated">扰流器</h2><p id="4bab" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">源代码已经可以在这里获得:<a class="ae lj" href="https://github.com/wilk/from-csv-to-buxfer" rel="noopener ugc nofollow" target="_blank">https://github.com/wilk/from-csv-to-buxfer</a></p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nm ms l"/></div></figure></div></div>    
</body>
</html>