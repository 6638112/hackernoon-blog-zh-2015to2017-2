<html>
<head>
<title>Promise Pattern on Swift with PromiseKit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有PromiseKit的Swift上的Promise模式</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/promise-pattern-on-swift-with-promisekit-620efad7a5bd?source=collection_archive---------2-----------------------#2017-07-09">https://medium.com/hackernoon/promise-pattern-on-swift-with-promisekit-620efad7a5bd?source=collection_archive---------2-----------------------#2017-07-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="0f4b" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">以及为什么应该将异步调用迁移到它们</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/71c4ffff8603d753c80943fc14a77cc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZpX0H4v8JM5efPJ-FmFleA.jpeg"/></div></div></figure><p id="ce38" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">异步API/服务器调用几乎是移动应用程序的一个主要部分，从卸载硬件工作到设计可靠的网络行为，它有几个优点。</p><p id="5216" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果你开发iOS应用已经有一段时间了，你可能已经知道这方面的惯例:<strong class="jx hv">闭包</strong></p><blockquote class="kr ks kt"><p id="bd99" class="jv jw ku jx b jy jz iv ka kb kc iy kd kv kf kg kh kw kj kk kl kx kn ko kp kq hn dt translated">闭包可以从定义它们的上下文中获取并存储对任何常量和变量的引用。这就是所谓的封闭那些常量和变量。Swift为您处理捕获的所有内存<a class="ae ky" href="https://hackernoon.com/tagged/management" rel="noopener ugc nofollow" target="_blank">管理</a>。</p><p id="ad14" class="jv jw ku jx b jy jz iv ka kb kc iy kd kv kf kg kh kw kj kk kl kx kn ko kp kq hn dt translated">~ https://开发者. apple.com</p></blockquote><p id="ca90" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">可以理解，这是实现轻度异步通信的首选<a class="ae ky" href="https://hackernoon.com/tagged/design" rel="noopener ugc nofollow" target="_blank">设计</a>模式。您可以快速地让API调用访问您的局部变量，在那里它们可以随时调用/操作它们。</p><p id="5f25" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">像任何OOP模式一样，它们也可能被滥用。以这头野兽为例:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="kz la l"/></div><figcaption class="lb lc fg fe ff ld le bd b be z ek">Behold, the Pyramid of D00m</figcaption></figure><p id="bdc9" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">仔细观察，您会发现这段代码只是试图连续执行3个异步任务:</p><ol class=""><li id="6e32" class="lf lg hu jx b jy jz kb kc ke lh ki li km lj kq lk ll lm ln dt translated">为用户上传图像</li><li id="f9ff" class="lf lg hu jx b jy lo kb lp ke lq ki lr km ls kq lk ll lm ln dt translated">为用户注册一个帐户</li><li id="373c" class="lf lg hu jx b jy lo kb lp ke lq ki lr km ls kq lk ll lm ln dt translated">为用户登录令牌</li></ol><p id="4e5a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">每一个异步调用都带有一个完成块，它处理可以以两种不同方式切换的响应:成功或失败。</p><p id="dd0d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在，如果写这篇文章对你来说还不是一个巨大的痛苦，那么等到你必须保持它的时候。为了处理错误和成功的响应，您必须从3个不同的块中检查和编辑您的代码，也就是说，如果您还没有忘记应该编辑哪个块的话。</p><p id="aede" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">当然，一定有更好的方法来处理这件事？</p></div><div class="ab cl lt lu hc lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hn ho hp hq hr"><h1 id="7694" class="ma mb hu bd mc md me mf mg mh mi mj mk ja ml jb mm jd mn je mo jg mp jh mq mr dt translated">承诺模式</h1><blockquote class="kr ks kt"><p id="c0b2" class="jv jw ku jx b jy jz iv ka kb kc iy kd kv kf kg kh kw kj kk kl kx kn ko kp kq hn dt translated">承诺是表示异步任务的对象。传递该对象，并编写干净有序的代码；从一个异步任务到另一个异步任务的逻辑的、简单的、模块化的进展流。</p><p id="701a" class="jv jw ku jx b jy jz iv ka kb kc iy kd kv kf kg kh kw kj kk kl kx kn ko kp kq hn dt translated">~http://promisekit.org/docs</p></blockquote><p id="e0bf" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在其他语言中有时称为<strong class="jx hv"> <em class="ku"> Futures </em> </strong>，<strong class="jx hv"> <em class="ku"> Delay，</em> </strong>或<strong class="jx hv"> <em class="ku"> Deferred </em> </strong>，它们是专门为处理可能成功也可能失败的异步任务而构建的。</p><p id="6779" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">但是与闭包不同，承诺被设计成<strong class="jx hv">传递</strong>而不需要只在一个块中捕获整个上下文及其结果。</p><p id="8f94" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">该设计的工作原理是，实际上<em class="ku">将</em>异步函数包装在一个对象周围，并且只通过<strong class="jx hv"> <em class="ku">公开它们<em class="ku">承诺的</em>最终结果。然后{ } </em> </strong>块，然后可以修改它返回另一个承诺或其他对象。</p><pre class="jk jl jm jn fq ms mt mu mv aw mw dt"><span id="dd68" class="mx mb hu mt b fv my mz l na nb">intPromise.then { intResult -&gt; Promise&lt;Bool&gt; in<br/>    return boolPromise()<br/>}.then { boolResult -&gt; Promise&lt;String&gt;<br/>    return stringPromise()<br/>}.then { stringResult -&gt; Void<br/>    //finally do something with <br/>    //your end result here<br/>}.catch { error in<br/>    //oh noes error<br/>}</span></pre><p id="7c0c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这个例子展示了3个异步函数是如何相互级联的，其中它们的所有最终结果都可以使用<strong class="jx hv"> PromiseKit </strong>干净地处理。</p><p id="562b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">不仅你的错误被处理在一个单独的程序块中，所有进行中的任务被安排在一个更干净的顺序中，避免了长的缩进。</p><p id="9d73" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">到目前为止一切顺利吗？厉害！</p><p id="f6c7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在让我们看看是否可以将我们最初的“注册”代码转换成类似的代码。</p></div><div class="ab cl lt lu hc lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hn ho hp hq hr"><h1 id="cd82" class="ma mb hu bd mc md me mf mg mh mi mj mk ja ml jb mm jd mn je mo jg mp jh mq mr dt translated">整合承诺</h1><pre class="jk jl jm jn fq ms mt mu mv aw mw dt"><span id="a06f" class="mx mb hu mt b fv my mz l na nb">use_frameworks!<br/>swift_version = "3.0"<br/>pod "PromiseKit", "~&gt; 4.0"</span></pre><p id="f308" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">让我们从通过pods安装库开始，或者对于你喜欢的其他方法，查看他们的自述【https://github.com/mxcl/PromiseKit<a class="ae ky" href="https://github.com/mxcl/PromiseKit" rel="noopener ugc nofollow" target="_blank"/></p><p id="79b5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在我们之前的用户注册代码中，我们可以看到它使用了3个不同的服务器API调用，即:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="kz la l"/></div></figure><p id="8dd9" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">纸上看起来很干净，是吗？让我们看看我们还能如何改进这一点。</p><h2 id="783f" class="mx mb hu bd mc nc nd ne mg nf ng nh mk ke ni nj mm ki nk nl mo km nm nn mq no dt translated">转换异步调用</h2><p id="b5ac" class="pw-post-body-paragraph jv jw hu jx b jy np iv ka kb nq iy kd ke nr kg kh ki ns kk kl km nt ko kp kq hn dt translated">我们将从把<strong class="jx hv">闭包</strong>作为参数开始全面修改我们的调用:</p><pre class="jk jl jm jn fq ms mt mu mv aw mw dt"><span id="5853" class="mx mb hu mt b fv my mz l na nb">func asyncCall(parameter: String, completion: (String) -&gt; Void)</span></pre><p id="a2ca" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">回到承诺:</p><pre class="jk jl jm jn fq ms mt mu mv aw mw dt"><span id="5399" class="mx mb hu mt b fv my mz l na nb">func asyncCall(parameter: String) -&gt; Promise&lt;String&gt;</span></pre><p id="4ef4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">将使用块创建一个Promise对象，具有一个<strong class="jx hv"> <em class="ku">实现</em> </strong>和<strong class="jx hv"> <em class="ku">拒绝</em> </strong>参数。这两个是简单的函数，它们将接受泛型类型化参数或一个错误作为结果。</p><p id="f33f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">您可以在这个块中自由地实现异步调用，然后调用参数来发送结果信号。</p><p id="ab6e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">理想情况下，重构后的函数如下所示:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="kz la l"/></div><figcaption class="lb lc fg fe ff ld le bd b be z ek">a bit longer than our original calls, but take it for now</figcaption></figure><p id="da98" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">另外，请注意，我们现在正在模拟一个错误结果。这只是为了演示错误处理。现在，尝试使用新的承诺重新完成整个注册流程:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="kz la l"/></div><figcaption class="lb lc fg fe ff ld le bd b be z ek">Look at the Closures. Then look at these Promises. Look at the Closures again. Then look at these Promises.</figcaption></figure><p id="abfa" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在看起来不是更好吗？现在，您可以轻松管理您的呼叫、结果和错误的去向。它的可读性和可维护性很强。</p><h2 id="9302" class="mx mb hu bd mc nc nd ne mg nf ng nh mk ke ni nj mm ki nk nl mo km nm nn mq no dt translated">包装现有异步调用</h2><p id="0979" class="pw-post-body-paragraph jv jw hu jx b jy np iv ka kb nq iy kd ke nr kg kh ki ns kk kl km nt ko kp kq hn dt translated">如果为每个API调用创建新的承诺对您的开发流程来说似乎有点太多，那么还有另一个选择。实现起来有点繁琐，但这意味着需要编写更少的新API:</p><pre class="jk jl jm jn fq ms mt mu mv aw mw dt"><span id="c119" class="mx mb hu mt b fv my mz l na nb">public func wrap&lt;T&gt;(_ body: (@escaping (T?, Error?) -&gt; Void) throws -&gt; Void) -&gt; Promise&lt;T&gt;</span></pre><p id="abac" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv"> Wrap </strong>函数可从PromiseKit的库中获得，它们根据您的情况提供不同的参数选项。在这种情况下，假设您有一个如下所示的函数:</p><pre class="jk jl jm jn fq ms mt mu mv aw mw dt"><span id="ea27" class="mx mb hu mt b fv my mz l na nb">func asyncCall(parameter: String, completion: @escaping (Token?, Error?) -&gt; Void)</span></pre><p id="9ee5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">包装它将简单地看起来像这样:</p><pre class="jk jl jm jn fq ms mt mu mv aw mw dt"><span id="4adb" class="mx mb hu mt b fv my mz l na nb">wrap({ asyncCall(parameter: String, completion: $0) })</span></pre><p id="a712" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在，这将返回一个新的承诺，它将复制您的原始结果类型，并将其作为自己的结果类型传递。因为我们(嗯，至少<em class="ku">我</em>会)正在编写由枚举表示的结果对象:</p><pre class="jk jl jm jn fq ms mt mu mv aw mw dt"><span id="7e87" class="mx mb hu mt b fv my mz l na nb">enum Result&lt;T&gt;{</span><span id="6ea6" class="mx mb hu mt b fv nu mz l na nb">case success(result: T)</span><span id="c1e6" class="mx mb hu mt b fv nu mz l na nb">case failure(error: Error)</span><span id="a7b4" class="mx mb hu mt b fv nu mz l na nb">}</span></pre><p id="b907" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们必须编写一个新的包装函数来容纳我们的流:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="kz la l"/></div></figure><p id="2fab" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">仔细观察，您会发现这只是将您的闭包块转换成Promise对象。</p><p id="77ae" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在再次尝试实现原始的注册流程，但是现在使用包装的闭包:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="kz la l"/></div><figcaption class="lb lc fg fe ff ld le bd b be z ek">still looking good!</figcaption></figure><p id="6ce0" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">看来你得多写几个字了，是吧？</p><p id="f0f6" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在大多数情况下，我更喜欢这样。它使我不必重写或复制我的函数，从而减少可能的错误并提高代码的可维护性。</p><h2 id="4830" class="mx mb hu bd mc nc nd ne mg nf ng nh mk ke ni nj mm ki nk nl mo km nm nn mq no dt translated">阿拉莫菲尔承诺</h2><p id="cc3c" class="pw-post-body-paragraph jv jw hu jx b jy np iv ka kb nq iy kd ke nr kg kh ki ns kk kl km nt ko kp kq hn dt translated">如果您使用Alamofire进行REST调用，那么您应该检查一下他们的Alamofire扩展库，您可以通过它</p><pre class="jk jl jm jn fq ms mt mu mv aw mw dt"><span id="608d" class="mx mb hu mt b fv my mz l na nb">pod 'PromiseKit/Alamofire', '~&gt; 4.0'</span></pre><p id="5a79" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">或者在这里查看完整自述:<a class="ae ky" href="https://github.com/PromiseKit/Alamofire-" rel="noopener ugc nofollow" target="_blank">https://github.com/PromiseKit/Alamofire-</a></p><p id="ded2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">它附带的选项有:</p><pre class="jk jl jm jn fq ms mt mu mv aw mw dt"><span id="e562" class="mx mb hu mt b fv my mz l na nb">public func responseJsonDictionary(options: JSONSerialization.ReadingOptions = .allowFragments) -&gt; Promise&lt;[String: Any]&gt;</span></pre><p id="0658" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这使得Alamofire的数据请求返回一个Promise对象，而不是必须通过一个块来捕获它们。一个例子是这样的登录调用:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="kz la l"/></div><figcaption class="lb lc fg fe ff ld le bd b be z ek">This code is copied straight out of one of my projects</figcaption></figure><p id="a521" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这是我使用<strong class="jx hv"> <em class="ku">抛出</em> </strong>来处理错误的为数不多的案例之一，而且非常干净利落。</p><h2 id="60a0" class="mx mb hu bd mc nc nd ne mg nf ng nh mk ke ni nj mm ki nk nl mo km nm nn mq no dt translated">下一步是什么？</h2><p id="a48b" class="pw-post-body-paragraph jv jw hu jx b jy np iv ka kb nq iy kd ke nr kg kh ki ns kk kl km nt ko kp kq hn dt translated">承诺很有趣！从慢慢地将它们整合到你认为合适的项目中开始。直接从他们的网站上阅读更多关于PromiseKit的令人敬畏的用法:<a class="ae ky" href="http://promisekit.org/docs/" rel="noopener ugc nofollow" target="_blank">http://promisekit.org/docs/</a></p><p id="e1ff" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">寻找闭包开始变得混乱的地方。尝试包装一些函数。在代码中引入更多的承诺，而不是完成块。</p><p id="9c62" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">就像尝试任何新的设计模式一样，不要害怕后退一步，重新评估它们是否真正适合你的风格。</p><p id="929a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">祝你好运！</p><h2 id="c9e1" class="mx mb hu bd mc nc nd ne mg nf ng nh mk ke ni nj mm ki nk nl mo km nm nn mq no dt translated">快速跟进</h2><p id="c64e" class="pw-post-body-paragraph jv jw hu jx b jy np iv ka kb nq iy kd ke nr kg kh ki ns kk kl km nt ko kp kq hn dt translated">如果你想看关于如何管理你的自定义异步调用的更深入的指南，我写了一个简短的指南，所以请随意查看:</p><p id="0a88" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><a class="ae ky" href="https://hackernoon.com/wrapping-up-apis-with-promisekit-d1302f446ad6" rel="noopener ugc nofollow" target="_blank">https://hacker noon . com/wrapping-up-API-with-promise kit-d 1302 f 446 ad 6</a></p></div><div class="ab cl lt lu hc lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hn ho hp hq hr"><h1 id="ee02" class="ma mb hu bd mc md me mf mg mh mi mj mk ja ml jb mm jd mn je mo jg mp jh mq mr dt translated">你大老远跑来了！</h1><blockquote class="nv"><p id="804e" class="nw nx hu bd ny nz oa ob oc od oe kq ek translated">我希望当你打开这篇文章的时候，你已经得到了你想要的东西。如果是这样，如果你能把这个推荐给你的朋友^^，我将非常感激</p></blockquote><p id="d77f" class="pw-post-body-paragraph jv jw hu jx b jy of iv ka kb og iy kd ke oh kg kh ki oi kk kl km oj ko kp kq hn dt translated">如果您还有任何问题/反馈，请随时留言<a class="ae ky" href="https://twitter.com/raymundcat" rel="noopener ugc nofollow" target="_blank"/>！</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ok la l"/></div></figure></div></div>    
</body>
</html>