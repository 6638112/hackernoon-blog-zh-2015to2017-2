<html>
<head>
<title>How “Effective Java” may have influenced the design of Kotlin — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“有效的Java”可能如何影响Kotlin的设计—第1部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-effective-java-may-have-influenced-the-design-of-kotlin-part-1-45fd64c2f974?source=collection_archive---------0-----------------------#2017-01-06">https://medium.com/hackernoon/how-effective-java-may-have-influenced-the-design-of-kotlin-part-1-45fd64c2f974?source=collection_archive---------0-----------------------#2017-01-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/1852d8fcbd2fbeb13f1aef8edb42cb41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OOz5Cg0Xc034bwXtouFghQ.jpeg"/></div></div></figure><p id="9cbe" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Java是一种很棒的编程语言，但是有一些已知的缺陷、常见的陷阱和从早期继承的不太好的元素(1.0于1995年发布)。约书亚·布洛赫的“<a class="ae ka" href="https://www.amazon.com/gp/product/0321356683/ref=as_li_tl?ie=UTF8&amp;tag=lukle-20&amp;camp=1789&amp;creative=9325&amp;linkCode=as2&amp;creativeASIN=0321356683&amp;linkId=92d90357e585584c81b56f9e2a75a3e1" rel="noopener ugc nofollow" target="_blank">有效的Java </a>”是一本关于如何编写好的Java代码、避免常见的编码错误并处理其弱点的备受推崇的书它包含78个被称为“条目”的部分，为读者提供关于语言不同方面的有价值的建议。</p><p id="c346" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现代编程语言的创造者有一个很大的优势，因为他们能够分析现有语言的弱点，并自己做得更好。Jetbrains ，一家已经开发了几个非常受欢迎的ide的公司，在2010年决定为他们自己的开发创造一种编程语言<a class="ae ka" href="http://www.kotlinlang.org" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>。它的目标是更简洁和更有表现力，同时消除Java的一些弱点。他们的ide之前的所有代码都是用Java编写的，所以他们需要一种与Java高度互操作的语言，并且可以编译成Java字节码。他们还想让Java开发人员很容易地进入Kotlin。通过Kotlin，Jetbrains想要构建一个更好的Java。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff kb"><img src="../Images/78f14d87f776ca2dcf187e9d5cde117e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*z8D9LL3fGVfMZ2VrKGRiBQ.png"/></div></figure><p id="138a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在重读《有效的Java》时，我发现很多这些东西对Kotlin来说并不是必需的，所以这个关于这本书的内容如何影响Kotlin的设计的博客系列的想法就诞生了。</p><h1 id="4b73" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">1.Kotlin的默认值不需要更多的构建器</h1><p id="2b97" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">当Java中的构造函数有很多可选参数时，代码会变得冗长、难以阅读并且容易出错。为了有所帮助，有效Java的第2项描述了如何有效地使用<a class="ae ka" href="https://en.wikipedia.org/wiki/Builder_pattern" rel="noopener ugc nofollow" target="_blank">构建器模式</a>。构建这样一个对象需要大量代码，就像下面代码示例中的nutrition facts对象一样。它有两个必需参数(<code class="eh lj lk ll lm b">servingSize</code>、<code class="eh lj lk ll lm b">servings</code>)和四个可选参数(<code class="eh lj lk ll lm b">calories</code>、<code class="eh lj lk ll lm b">fat</code>、<code class="eh lj lk ll lm b">sodium</code>、<code class="eh lj lk ll lm b">carbohydrates</code>):</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="7e78" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">用Java实例化一个对象看起来像这样:</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="901c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用Kotlin，您根本不需要使用构建器模式，因为有默认参数的特性，它允许您为每个可选的构造函数参数定义默认值:</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="6e53" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Kotlin中创建一个对象如下所示:</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="1a87" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了提高可读性，您还可以将所需的参数命名为<code class="eh lj lk ll lm b">servingSize</code>和<code class="eh lj lk ll lm b">servings</code>:</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="f5ce" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">像Java一样，这里创建的对象是不可变的。</p><p id="827f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将所需的代码行从Java中的47行减少到了Kotlin中的7行，从而极大地提高了生产率。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff lp"><img src="../Images/6c48fef24177590b6a6b9cdb778c6fa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*PRAPkmHEMPaqy05bbSTxqw.png"/></div><figcaption class="lq lr fg fe ff ls lt bd b be z ek">NOT BAD</figcaption></figure><p id="cb7a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">提示:如果你想在Java中创建<code class="eh lj lk ll lm b">KotlinNutrition</code>对象，你当然可以这样做，但是你必须为每个可选参数指定一个值。幸运的是，如果添加了<code class="eh lj lk ll lm b">JvmOverloads</code>注释，就会生成多个构造函数。注意，如果你想使用注释，我们也需要关键字<code class="eh lj lk ll lm b">constructor</code>:</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><h1 id="4d48" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">2.轻松创建单件</h1><p id="0950" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">“有效的Java”的第3项展示了如何设计一个Java对象，使它表现得像一个单例，这是一个只能实例化一个实例的对象。下面的代码片段展示了一个“单一Elvis”的宇宙，其中只能存在一个Elvis:</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="4a85" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Kotlin有<a class="ae ka" href="https://kotlinlang.org/docs/reference/object-declarations.html#object-declarations" rel="noopener ugc nofollow" target="_blank">对象声明</a>的概念，它为我们提供了开箱即用的单例行为:</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="f28a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不再需要手动构建您的单件！</p><h1 id="bd62" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">3.现成的equals()和hashCode()</h1><p id="ccd1" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">起源于函数式编程并简化代码的良好编程实践是主要使用不可变的值对象。第15条建议“类应该是不可变的，除非有很好的理由让它们可变。”在Java中创建不可变值对象非常繁琐，因为对于每个对象，您都必须自己覆盖<code class="eh lj lk ll lm b">equals()</code>和<code class="eh lj lk ll lm b">hashCode()</code>函数。约书亚·布洛赫用了18页来描述如何遵守第8项和第9项中这两种方法的明确的一般契约。例如，如果你覆盖了<code class="eh lj lk ll lm b">equals()</code>，你必须确保<a class="ae ka" href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals%28java.lang.Object%29" rel="noopener ugc nofollow" target="_blank">契约</a>的反身性、对称性、传递性、一致性和非无效性都得到满足。听起来更像数学而不是编程。</p><p id="ac69" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Kotlin中，您可以简单地使用<a class="ae ka" href="https://kotlinlang.org/docs/reference/data-classes.html" rel="noopener ugc nofollow" target="_blank">数据类</a>来代替，编译器会自动派生出<code class="eh lj lk ll lm b">equals()</code>、<code class="eh lj lk ll lm b">hashCode()</code>等方法。这是可能的，因为标准功能可以从对象的属性中机械地派生出来。只需在你的班级前面输入关键字<code class="eh lj lk ll lm b">data</code>，就大功告成了。这里不需要18页的描述。</p><p id="7974" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">提示:最近，Java的<a class="ae ka" href="https://github.com/google/auto/tree/master/value" rel="noopener ugc nofollow" target="_blank"> AutoValue </a>变得流行起来。这个库为Java 1.6+生成不可变的值类。</p><h1 id="7f30" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">4.属性而不是字段</h1><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="f83b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第14项建议在公共类中使用访问器方法，而不是公共字段。如果您不坚持这个建议，您可能会遇到麻烦，因为字段是直接可访问的，您将失去封装和灵活性的所有好处。这意味着在将来，如果不改变它的公共API，你将不能改变你的类的内部表示。例如，以后不能限制字段的值，如人的年龄。这就是为什么我们总是在Java中创建那些冗长的默认getters和setters的原因之一。</p><p id="873e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Kotin实施了这个最佳实践，因为它使用了带有自动生成的默认getters和setters的<a class="ae ka" href="https://kotlinlang.org/docs/reference/properties.html" rel="noopener ugc nofollow" target="_blank">属性</a>,而不是字段。</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="4d24" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从语法上来说，你可以用<code class="eh lj lk ll lm b">person.name</code>或<code class="eh lj lk ll lm b">person.age</code>来访问这些属性，比如Java中的公共字段。您可以在以后添加自定义的getters和setters，而无需更改该类的API:</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="565f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">长话短说:利用Kotlin的属性，我们可以获得更简洁的类，并且开箱即用，灵活性更高。</p><h1 id="409c" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">5.作为强制关键字替代可选注释</h1><p id="a373" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">注释是在1.5版中添加到Java中的。最重要的一个是<code class="eh lj lk ll lm b">Override</code>，它标志着一个方法正在覆盖一个超类的方法。根据第36项，应该经常使用这个可选注释来避免恶意的错误。当你认为你正在从一个超类中重写一个方法，但实际上你没有，编译器就会抛出一个错误。只要你不忘记使用<code class="eh lj lk ll lm b">Override</code>注释，这就可以工作。</p><p id="f661" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Kotlin中，<code class="eh lj lk ll lm b">override</code>不是可选注释，而是强制关键字。所以这些讨厌的虫子不会再出现了。编译器会提前提醒你。科特林坚持把这些事情明确化。</p><h1 id="c191" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">好了</h1><p id="284d" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">这是“<a class="ae ka" href="https://www.amazon.com/gp/product/0321356683/ref=as_li_tl?ie=UTF8&amp;tag=lukle-20&amp;camp=1789&amp;creative=9325&amp;linkCode=as2&amp;creativeASIN=0321356683&amp;linkId=92d90357e585584c81b56f9e2a75a3e1" rel="noopener ugc nofollow" target="_blank">高效Java </a>”如何影响Kotlin设计的第一部分。您可以<a class="ae ka" href="https://twitter.com/LukasLechnerDev" rel="noopener ugc nofollow" target="_blank">在twitter上关注我</a>从我这里获取新的更新。</p><p id="318d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下次见！</p><p id="a241" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">编辑:<a class="ae ka" rel="noopener" href="/@lukleDev/how-effective-java-may-have-influenced-the-design-of-kotlin-part-2-89844d62ddf3#.o41z4tc0a"> Part 2 </a>这里的<a class="ae ka" rel="noopener" href="/@lukleDev/how-effective-java-may-have-influenced-the-design-of-kotlin-part-2-89844d62ddf3#.o41z4tc0a">就是</a>！</p><div class="kc kd ke kf fq ab cb"><figure class="lu iv lv lw lx ly lz paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="lu iv lv lw lx ly lz paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="lu iv lv lw lx ly lz paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ma mb mc"><p id="f922" class="jc jd md je b jf jg jh ji jj jk jl jm me jo jp jq mf js jt ju mg jw jx jy jz hn dt translated"><a class="ae ka" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是阿妹家庭的一员。我们现在<a class="ae ka" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ka" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd md je b jf jg jh ji jj jk jl jm me jo jp jq mf js jt ju mg jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ka" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ka" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mh"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>