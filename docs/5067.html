<html>
<head>
<title>Simplified Testing with ScalaTest and Custom Matchers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用ScalaTest和定制匹配器简化测试</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/simplified-testing-with-scalatest-and-custom-matchers-bd5297128ebc?source=collection_archive---------5-----------------------#2017-07-08">https://medium.com/hackernoon/simplified-testing-with-scalatest-and-custom-matchers-bd5297128ebc?source=collection_archive---------5-----------------------#2017-07-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/e7b15b5e671aa64ca85d87cc08975a0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*uuxRQFOIYZ4mgdszko_AsA.jpeg"/></div></figure><p id="aa30" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">首先测试对我们来说很重要。我们的一切都是建立在这个原则之上的，它对我们来说非常有效。然而，并不是每一个测试框架都是为了简单而设计的，有时我们不得不在它们的基础上构建一个更加精炼的产品，更好地满足我们对简单性的特殊需求。</p><p id="8a9f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">ScalaTest  令人印象深刻，它有非常有趣的功能。我们最喜欢的一点是，我们可以通过添加我们自己的匹配器来扩展它，这最终会给我们带来我们正在寻找的抽象层次。</p><p id="c967" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们从假设我们想测试一个函数的后续签名开始。</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="b29a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">一个非常简单的测试是</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="1158" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">正如我们所看到的，这是一个非常简单的测试，但是现在让我们找到一个给定了用户id的用户。</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="73b0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们可以为它编写一个测试，如下所示。</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="04b2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">等等什么？我们真的必须打开单子吗？另一个选择是休耕。</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="bda8" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这是一样的，不同的是我们现在把<code class="eh kd ke kf kg b">User</code>包装成<code class="eh kd ke kf kg b">Some</code>，这基本上是一样的。</p><p id="3cf7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们实际上想写的是类似下面这样的东西。</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="e48e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">正如我们所看到的，在这里我们的意图更加明确<strong class="ja hv"> <em class="jw">(这段代码还不会编译)</em> </strong></p></div><div class="ab cl kh ki hc kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hn ho hp hq hr"><h2 id="ae13" class="ko kp hu bd kq kr ks kt ku kv kw kx ky jj kz la lb jn lc ld le jr lf lg lh li dt translated">我们如何扩展ScalaTest以获得我们想要的功能(或编写测试的方式)？</h2><p id="1813" class="pw-post-body-paragraph iy iz hu ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hn dt translated">这种方法需要预先做一些工作，但是回报很快。</p><p id="2285" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">首先，我们需要创建一个将与我们的测试类混合的特征。</p><p id="95a8" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">然后，我们创建<code class="eh kd ke kf kg b">matchTo</code>函数，作为测试的一部分。这个函数实际上是返回一个负责匹配<code class="eh kd ke kf kg b">User</code>和<code class="eh kd ke kf kg b">Option[User]</code>的<code class="eh kd ke kf kg b">Matcher</code>实例。</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="f7b9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这让我们能够改变</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="caf0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">到</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="4127" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在这里，你也应该注意到我们将<code class="eh kd ke kf kg b">User </code>与<code class="eh kd ke kf kg b">Option[User]</code>进行匹配，但是比较是在幕后进行的。我们已经从测试中去除了这种复杂性。</p><p id="66c3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们可以为用户添加一个新的匹配器，这样我们就可以用下面的形状编写一个测试。</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="d2fe" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们给<code class="eh kd ke kf kg b">UserMatchers.</code>添加必要的代码</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="5774" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，我们可以通过<code class="eh kd ke kf kg b">Name</code>来匹配<code class="eh kd ke kf kg b">User</code>，同样，在幕后，我们正在进行所有需要的比较，以确保名称与<code class="eh kd ke kf kg b">Option[User]</code>中的用户名匹配。</p><p id="9437" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这个例子很简单，但是考虑一个更复杂的堆栈。假设我们有一个想要测试的函数，它的形状如下。</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="cd7e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">对于这个特殊的功能，我们需要解开<code class="eh kd ke kf kg b">Future</code>和<code class="eh kd ke kf kg b">Either</code>和<code class="eh kd ke kf kg b">Seq</code>。</p><p id="cf78" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">其中一个测试可能与此类似。</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="08a0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">能写下以下内容该多好？</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="eb8d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们可以为它编写一个自定义匹配器，让我们看看如何实现。</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="7a59" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如你所见，这个有点复杂。我们把所有脏东西都推给了匹配器，<code class="eh kd ke kf kg b">ValidUsersMatchers</code>。我们可以说这和我们以前做的是一样的，我们只是把复杂性移到了不同的地方，但是我们的测试现在更干净了，我们也可以在不同的测试中重用匹配器。</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="1bfb" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">此外，我们的测试以一种非常清晰的方式表达了我们的意图，而不会因为来自monads等堆叠结构的语法复杂性而污染代码。</p><h2 id="aeba" class="ko kp hu bd kq kr ks kt ku kv kw kx ky jj kz la lb jn lc ld le jr lf lg lh li dt translated">结论</h2><p id="3942" class="pw-post-body-paragraph iy iz hu ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hn dt translated">保持你的测试干净。ScalaTest有几种不同的方法可以做到这一点。为你的结构编写匹配器，这样你就可以在多个测试中重用它们。根据需要混合尽可能多的自定义匹配器，以获得尽可能多的简单性。把测试的复杂性推给你的匹配者，让他们在一个地方做脏活。</p></div></div>    
</body>
</html>