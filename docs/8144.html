<html>
<head>
<title>How we monitor Serverless apps with hundreds of functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们如何监控具有数百种功能的无服务器应用</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-we-monitor-serverless-apps-with-hundreds-of-functions-d0f1fa938d1e?source=collection_archive---------9-----------------------#2017-11-21">https://medium.com/hackernoon/how-we-monitor-serverless-apps-with-hundreds-of-functions-d0f1fa938d1e?source=collection_archive---------9-----------------------#2017-11-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/567867d8ada47c00ca4bca102f10e03c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gSd1l0tY_2mRwTVocTjs-Q.jpeg"/></div></div></figure><p id="a915" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在过去的两年里，我将大部分时间和精力放在构建无服务器应用程序上。高潮？我和我的朋友创建了<a class="ae ka" href="https://dashbird.io/monitor-aws-lambda" rel="noopener ugc nofollow" target="_blank"><strong class="je hv">dash bird</strong></a><strong class="je hv">——一个针对AWS Lambda </strong>的监控和错误警报服务。在开始<a class="ae ka" href="https://hackernoon.com/tagged/dashbird" rel="noopener ugc nofollow" target="_blank"> Dashbird </a>之前，我们在test lio——一家众包QA公司中构建了无服务器解决方案。今天，这两种服务都大量使用Lambda函数。</p><p id="e0c1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在无服务器中有很多领域我都想涉及，但是我将把重点放在房间里的大象上:<strong class="je hv">监视和洞察Lambda函数</strong>。我认为这是无服务器领域最大的问题之一，同时也是我认为我的专业知识最有影响力的领域。</p><h1 id="b036" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">弄清楚监控…</h1><p id="75a2" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">当采用无服务器时，我们不得不重新设想获取和显示应用程序指标的方法。我们希望保持我们的功能简洁明了——没有第三方代理和包装。我们还希望一切都可以通过<strong class="je hv">单一仪表板</strong>观察到——这是现有APM所缺乏的功能。最重要的是，我们希望能够找到并<strong class="je hv">深入调用级数据</strong>，包括日志和上下文，以便在出现问题时排除故障并调试代码。</p><p id="ee1d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">今天，我可以说，我们已经非常接近这一可见性水平，我想分享一下我的经验以及我们是如何实现这一目标的。</p><h1 id="45d2" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">从日志中获取一切！</h1><p id="aa13" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">分析日志是收集信息的一种非常有效的方式，没有什么是你不能做的。但是有了Lambda，你可以把它带到一个全新的水平。</p><p id="5ab3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我解释一下。</p><p id="71ed" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">CloudWatch根据功能、版本和容器组织日志，而Lambda为每次调用添加元数据。此外，日志中还包括运行时和容器错误。当然，您可以记录任何自定义指标，并将其转换为时间序列图。不过，这不是CloudWatch的工作。</p><div class="le lf lg lh fq ab cb"><figure class="li iv lj lk ll lm ln paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/03e9c60e1e455c214e8c87f047643867.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*yyUI8U3m5xd4hHHjQ6TOaQ.png"/></div></figure><figure class="li iv lo lk ll lm ln paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/631f7cd328043cdecddbcbfa05728190.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*rGvUVhu2xl79UMsvtH4tyQ.png"/></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek lt di lu lv">Log Stream history of a Lambda function.</figcaption></figure></div><h1 id="e844" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">让我们来分析一下。</h1><p id="f515" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">一般来说，监控一个应用程序有两个角度。<strong class="je hv">系统指标</strong>(如延迟、错误、调用和内存使用量)<strong class="je hv">业务</strong> <strong class="je hv">分析</strong>，如注册或发送电子邮件的数量。</p><p id="ebf9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">技术性能指标和错误检测非常普遍，这也是Dashbird的初衷——一种即插即用的监控服务。</p><p id="d4f3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，业务指标因服务而异，需要定制的方法。我们为此选择的武器是SumoLogic，但是您也可以使用其他服务，如Logs.io等。</p><p id="5872" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们首先处理系统指标…</p><h1 id="3b0e" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">是时候真正了解你的兰姆达斯了</h1><p id="6a76" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们构建了<a class="ae ka" href="https://dashbird.io" rel="noopener ugc nofollow" target="_blank"> Dashbird </a>来了解无服务器架构的技术指标。它通过实时收集和分析CloudWatch日志来工作。</p><p id="ffcf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于所有好的监控服务，在一个屏幕上获得一个概览是很重要的。主页就是为此而设计的。它包括所有调用的概述，最活跃的功能，最近的错误和系统健康。它应该告诉你<strong class="je hv">你是否在哪里有问题。</strong></p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lw"><img src="../Images/7533775e1147176e0b02b9212bdc5c97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MUwfAmo8EXpdjHff_EWY3Q.png"/></div></div></figure><p id="52dd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从那里，你可以进入Lambda视图并单独分析每个函数。</p><h2 id="b60d" class="lx kc hu bd kd ly lz ma kh mb mc md kl jn me mf kp jr mg mh kt jv mi mj kx mk dt translated">时序指标允许优化</h2><p id="6a3c" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">这个视图使开发人员能够判断延迟和内存使用情况。我们使用它来优化功能，通过调整配置的内存来匹配实际使用情况，从而提高成本效益。或者，通过增加更多的内存来加速端点<a class="ae ka" href="https://serverless.zone/my-accidental-3-5x-speed-increase-of-aws-lambda-functions-6d95351197f3" rel="noopener ugc nofollow" target="_blank">也是有用的。</a></p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ml"><img src="../Images/2c5a1d111387e846605a4a991b59e224.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*avwd7uLcZOn9q9GQy__mFA.png"/></div></div></figure><p id="c3ba" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于故障排除和修复问题，我们依赖日志中的故障识别。根据我们的经验，这种方法正好适合Lambda函数。</p><p id="6087" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以下是一些原因:</p><ul class=""><li id="a15b" class="mm mn hu je b jf jg jj jk jn mo jr mp jv mq jz mr ms mt mu dt translated"><strong class="je hv">超时永远不会到达警报服务，</strong>因为在库有时间发送警报之前，执行就被低层杀死了。</li><li id="2bff" class="mm mn hu je b jf mv jj mw jn mx jr my jv mz jz mr ms mt mu dt translated"><strong class="je hv">配置故障永远不会到达报警服务</strong>，因为执行会在容器启动时停止。</li><li id="0e09" class="mm mn hu je b jf mv jj mw jn mx jr my jv mz jz mr ms mt mu dt translated"><strong class="je hv">盲点少。</strong>有些功能你预计不会失败，所以你没有为它们添加提醒。尽管有时他们还是会失败。</li><li id="6131" class="mm mn hu je b jf mv jj mw jn mx jr my jv mz jz mr ms mt mu dt translated"><strong class="je hv"> Stacktraces将连接到执行日志</strong>，这意味着我们知道崩溃前发生了什么。</li></ul><div class="le lf lg lh fq ab cb"><figure class="li iv na lk ll lm ln paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/63fc49f19b58dfe3180c2ff61e6cf1fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*bSjsDdH7TGzU3hTdI2Iapg.png"/></div></figure><figure class="li iv nb lk ll lm ln paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/ba3e4ca7e014acd06974a1626bc0dcf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*0FYme6XA00xyNaScCzYssA.png"/></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek nc di nd lv">Here’s what debugging looks like 😎.</figcaption></figure></div><h1 id="2f57" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">我应该记录什么？</h1><p id="c2a1" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">故事并没有在这里结束。不管那些花哨的图表，我还是发现自己对发生的事情一无所知，尽管我不愿意承认。仅仅一个堆栈跟踪可能不足以理解失败执行的细节(尤其是Node.js的模糊跟踪)。为此，我们开发了一些登录Lambda函数的约定。</p><h2 id="974c" class="lx kc hu bd kd ly lz ma kh mb mc md kl jn me mf kp jr mg mh kt jv mi mj kx mk dt translated">我们总是注销:</h2><ul class=""><li id="d2a7" class="mm mn hu je b jf kz jj la jn ne jr nf jv ng jz mr ms mt mu dt translated"><strong class="je hv">事件对象</strong> ( <strong class="je hv">省略敏感信息</strong>如密码、信用卡详细信息等)</li><li id="ee6c" class="mm mn hu je b jf mv jj mw jn mx jr my jv mz jz mr ms mt mu dt translated"><strong class="je hv">错误和异常</strong>(如果你<em class="nh">尝试…捕捉</em>一个错误，添加一个<em class="nh"> console.log(error) </em>)</li><li id="b94f" class="mm mn hu je b jf mv jj mw jn mx jr my jv mz jz mr ms mt mu dt translated"><strong class="je hv">一切看起来可疑的事情</strong>(花了几个小时调试你的代码，却发现一个远程端点改变了它的响应体<em class="nh"> ) </em></li><li id="961d" class="mm mn hu je b jf mv jj mw jn mx jr my jv mz jz mr ms mt mu dt translated"><strong class="je hv">具有商业价值的事件</strong>(这些事件会在一分钟内出现在定制的仪表板上)</li></ul><h1 id="f5f0" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">收集业务指标</h1><p id="1ba6" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">商业分析遵循同样的基本思想。我们选择的武器是<a class="ae ka" href="https://sumologic.com" rel="noopener ugc nofollow" target="_blank"> SumoLogic </a>。</p><blockquote class="ni"><p id="5732" class="nj nk hu bd nl nm nn no np nq nr jz ek translated">SumoLogic是一个用于日志管理和时间序列度量的机器数据分析服务。</p></blockquote><p id="3939" class="pw-post-body-paragraph jc jd hu je b jf ns jh ji jj nt jl jm jn nu jp jq jr nv jt ju jv nw jx jy jz hn dt translated">这项服务的伟大之处在于它能够用几乎任何东西来构建定制的仪表板。设置和Dashbird有点不同，但是一样棒。这里有一个<a class="ae ka" href="https://github.com/SumoLogic/sumologic-aws-lambda/tree/master/cloudwatchlogs" rel="noopener ugc nofollow" target="_blank"> lambda函数</a>，它订阅一个日志组并将日志发送给服务😎。</p><h1 id="559d" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">构建自定义指标仪表板</h1><p id="7922" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">自定义指标中没有太多的约定和共同点，因此我们将通过一个示例来演示这一点。</p><p id="a4e7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我将演示我们如何为集成服务收集指标。这项服务的任务是在问题追踪账户之间同步问题(想想JIRA和阿萨纳)。我们希望记录所有针对客户端问题跟踪器的CRUD操作。</p><p id="23ba" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为此，让我们在每次发出此类请求时添加一个日志行:</p><pre class="le lf lg lh fq nx ny nz oa aw ob dt"><span id="2c83" class="lx kc hu ny b fv oc od l oe of">console.log(`-metrics.integrations.${env.STAGE}.crud.${method}`);</span></pre><p id="c31f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我们有能力将这些事件转化为时间序列指标。让我们对此进行查询…</p><pre class="le lf lg lh fq nx ny nz oa aw ob dt"><span id="4a6b" class="lx kc hu ny b fv oc od l oe of">"-metrics.integrations.prod.crud." | parse "-metrics.integrations.prod.crud.*" as method | timeslice 5m | count(method) group by  _timeslice, method | transpose row _timeslice column method</span></pre><p id="c364" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">看看我们得到了什么…</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff og"><img src="../Images/88aa0a0218ac863947bcdafa00ce77e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-1FpBxVzA8D7BfepeqqOLA.png"/></div></div></figure><p id="53c3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不错！将它添加到您的仪表板中。</p><h2 id="c1ae" class="lx kc hu bd kd ly lz ma kh mb mc md kl jn me mf kp jr mg mh kt jv mi mj kx mk dt translated"><strong class="ak">现在让它看得见。</strong></h2><p id="21a0" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">对于任何仪表板，一目了然是很重要的。仪表板的经验法则是，如果有问题，你需要在5秒钟内说出来。我们试图用数量来表示失败，用时间序列度量来表示预期事件。这是我们集成服务仪表板的最终结果。</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff oh"><img src="../Images/86af494b46e3579da8c1d62ea2ecc088.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mZdwfC4xKo6qYHPDADHQpg.png"/></div></div></figure><p id="9ac6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这项工作仍在进行中，因为我们正在测试不同的信息显示方式。</p><h1 id="a956" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">结论</h1><p id="17db" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">Lambda的短命、并行和高度可伸缩性迫使我们不断创新。前面提到的方法帮助我们将清晰和可见性带入我们的无服务器系统，我已经看到它对其他团队产生了类似的效果。这两个工具都有免费版本，所以您可以很容易地试用它们。</p><p id="26c4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="nh"> PS。如果你有其他想法或者想分享你在监测领域的工作，请在评论中告诉我。</em></p></div></div>    
</body>
</html>