<html>
<head>
<title>The Open-Closed Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开闭原则</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-open-closed-principle-c3dc45419784?source=collection_archive---------5-----------------------#2017-12-08">https://medium.com/hackernoon/the-open-closed-principle-c3dc45419784?source=collection_archive---------5-----------------------#2017-12-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="939a" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">隐藏在背后的是什么</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/766af9c37c8c0bc4bdba688742573597.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mb1vsmg303wMtj-CktW3MA.jpeg"/></div></div></figure><p id="ac94" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这是第二篇关于<a class="ae kr" href="https://hackernoon.com/solid-principles-530b2cc2badf" rel="noopener ugc nofollow" target="_blank">坚实</a>原则以及它们都有什么共同基础的帖子(此处查看单责任原则<a class="ae kr" rel="noopener" href="/@wrong.about/the-secret-behind-the-single-responsibility-principle-e2f3692bae25">)。</a></p><h2 id="acde" class="ks kt hu bd ku kv kw kx ky kz la lb lc ke ld le lf ki lg lh li km lj lk ll lm dt translated">伯特兰·迈耶，1988年</h2><p id="7fe2" class="pw-post-body-paragraph jv jw hu jx b jy ln iv ka kb lo iy kd ke lp kg kh ki lq kk kl km lr ko kp kq hn dt translated">这是Bertrand Meyers在他的书“<a class="ae kr" href="https://www.amazon.com/Object-Oriented-Software-Construction-Book-CD-ROM/dp/0136291554" rel="noopener ugc nofollow" target="_blank"> <em class="ls">面向对象软件构造</em> </a>”中写的，这个原则来源于此:</p><blockquote class="lt lu lv"><p id="d6d3" class="jv jw ls jx b jy jz iv ka kb kc iy kd lw kf kg kh lx kj kk kl ly kn ko kp kq hn dt translated">一个类是封闭的，因为它可能被编译、存储在库中、被基线化和被客户端类使用。但是它也是开放的，因为任何新的类都可以使用它作为父类，增加新的特性。当一个子类被定义时，没有必要改变原来的类或者打扰它的客户。</p></blockquote><p id="3b3e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">所以他提议用一个<a class="ae kr" rel="noopener" href="/@wrong.about/inheritance-based-on-internal-structure-is-evil-7474cc8e64dc">实现继承</a>。一点都不好。</p><h2 id="5aea" class="ks kt hu bd ku kv kw kx ky kz la lb lc ke ld le lf ki lg lh li km lj lk ll lm dt translated">罗伯特·马丁，1996</h2><p id="ed89" class="pw-post-body-paragraph jv jw hu jx b jy ln iv ka kb lo iy kd ke lp kg kh ki lq kk kl km lr ko kp kq hn dt translated">可怜的罗伯特·马丁经常因为贝特朗·梅耶的提议而受到指责。难怪，看看他在论文中写的<a class="ae kr" href="https://www.cs.duke.edu/courses/fall07/cps108/papers/ocp.pdf" rel="noopener ugc nofollow" target="_blank"><em class="ls"/></a>:</p><blockquote class="lt lu lv"><p id="f606" class="jv jw ls jx b jy jz iv ka kb kc iy kd lw kf kg kh lx kj kk kl ly kn ko kp kq hn dt translated">1.它们[模块，以及类]是“开放扩展的”。<br/>这意味着模块的行为可以扩展。随着应用程序需求的变化，或者为了满足新应用程序的需求，我们可以使模块以新的和不同的方式运行。</p><p id="48a3" class="jv jw ls jx b jy jz iv ka kb kc iy kd lw kf kg kh lx kj kk kl ly kn ko kp kq hn dt translated">2.它们“关闭以进行修改”。这样一个模块的源代码是不可侵犯的。不允许任何人对它进行源代码更改。</p></blockquote><p id="1bdc" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我意识到很大一部分读者没有读到更多，并且指责Robert Martin使用了实现继承。嗯，只是一个不幸的命名。下面是对他的意思的阐述。他很清楚这一点:</p><blockquote class="lt lu lv"><p id="57d5" class="jv jw ls jx b jy jz iv ka kb kc iy kd lw kf kg kh lx kj kk kl ly kn ko kp kq hn dt translated">抽象是关键。</p></blockquote><p id="30f2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">他演示了一个简单的例子，一个<em class="ls">客户机</em>类直接依赖于一个具体的<em class="ls">服务器</em>类:</p><pre class="jk jl jm jn fq lz ma mb mc aw md dt"><span id="ab14" class="ks kt hu ma b fv me mf l mg mh"><strong class="ma hv">class </strong>Client<br/>{<br/>    <strong class="ma hv">public function </strong>doSomeWork()<br/>    {<br/>        <strong class="ma hv">return </strong>(<strong class="ma hv">new </strong>Server())-&gt;run();<br/>    }<br/>}</span></pre><p id="2a74" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">显然，当<em class="ls">服务器</em>类必须被替换时，<em class="ls">客户端</em>会受到影响。所以这个故事的寓意是:引入抽象，让你的客户依赖它们，而不是具体的实现。这都是关于问题空间的正确分解，产生了一些抽象和相当多的可组合、松散耦合和高度一致的实现。</p><p id="1ef0" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在模块层面上，David Parnas在1972年描述的方法最好地应用了这一原则。它加强了<a class="ae kr" rel="noopener" href="/@wrong.about/how-to-decompose-a-system-into-modules-796bd941f036">高内聚</a>，而开闭原则建议提取抽象，从而支持松散耦合。</p><h2 id="79a1" class="ks kt hu bd ku kv kw kx ky kz la lb lc ke ld le lf ki lg lh li km lj lk ll lm dt translated">罗伯特·马丁，<a class="ae kr" href="https://www.amazon.com/UML-Java%C2%BF-Programmers-Robert-Martin/dp/0131428489/" rel="noopener ugc nofollow" target="_blank"> 2003 </a>，<a class="ae kr" href="https://www.amazon.com/Software-Development-Principles-Patterns-Practices/dp/0135974445" rel="noopener ugc nofollow" target="_blank"> 2004 </a>，<a class="ae kr" href="https://8thlight.com/blog/uncle-bob/2013/03/08/AnOpenAndClosedCase.html" rel="noopener ugc nofollow" target="_blank"> 2013 </a>，<a class="ae kr" href="https://8thlight.com/blog/uncle-bob/2014/05/12/TheOpenClosedPrinciple.html" rel="noopener ugc nofollow" target="_blank"> 2014 </a></h2><p id="f6f7" class="pw-post-body-paragraph jv jw hu jx b jy ln iv ka kb lo iy kd ke lp kg kh ki lq kk kl km lr ko kp kq hn dt translated">在接下来的几年里，他一直在努力阐明他的观点，即不是通过继承，而是通过交换有用抽象的实现来扩展行为。不太成功:2017年，<a class="ae kr" href="http://www.yegor256.com/2017/03/28/solid.html#o" rel="noopener ugc nofollow" target="_blank">有些还是没弄明白</a>。</p><h2 id="d073" class="ks kt hu bd ku kv kw kx ky kz la lb lc ke ld le lf ki lg lh li km lj lk ll lm dt translated">类<em class="mi">参数化</em></h2><p id="2ae6" class="pw-post-body-paragraph jv jw hu jx b jy ln iv ka kb lo iy kd ke lp kg kh ki lq kk kl km lr ko kp kq hn dt translated">我已经列出了两种不用修改现有代码就可以引入新类的方法。第一个是使用继承，这是不鼓励的，第二个是提取新的接口，以便它们可以被注入到一个类中。第三种方式是类参数化，如果我可以这样称呼它的话。它非常接近于引入新的抽象，但它是关于注入数据而不是行为。考虑下面的例子。我有一个计算雇主工资的课程。可以有不同的策略，这反映在下面(为了强调这一点，简化了一个示例):</p><pre class="jk jl jm jn fq lz ma mb mc aw md dt"><span id="78ee" class="ks kt hu ma b fv me mf l mg mh"><strong class="ma hv">class </strong>SalaryService<br/>{<br/>    <strong class="ma hv">const <em class="ls">TAX </em></strong>= 0.07;<br/><br/>    <strong class="ma hv">private $salaryStrategy</strong>;<br/><br/>    <strong class="ma hv">public function </strong>__construct(SalaryStrategy $salaryStrategy)<br/>    {<br/>        $this-&gt;<strong class="ma hv">salaryStrategy </strong>= $salaryStrategy;<br/>    }<br/><br/>    <strong class="ma hv">public function </strong>calculate()<br/>    {<br/>        <strong class="ma hv">return </strong>$this-&gt;<strong class="ma hv">salaryStrategy</strong>-&gt;calculate(<strong class="ma hv">self</strong>::<strong class="ma hv"><em class="ls">TAX</em></strong>);<br/>    }<br/>}</span></pre><p id="7cd7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">所以当一个新的策略出现时，我不需要修改一个<em class="ls"> SalaryService </em>类。这意味着OCP在这一要求方面没有受到侵犯。但是，当你被告知一项税收发生了变化时，你需要在代码中反映出来。会不会违反开闭原则？当然，因为你需要修改现有的代码。你有什么选择？简单常量不代表任何行为，它代表数据。尽管您仍然可以通过一个参数注入它，比如说构造函数参数:</p><pre class="jk jl jm jn fq lz ma mb mc aw md dt"><span id="2383" class="ks kt hu ma b fv me mf l mg mh"><strong class="ma hv">class </strong>SalaryService<br/>{<br/>    <strong class="ma hv">private $salaryStrategy</strong>;<br/>    <strong class="ma hv">private $tax</strong>;<br/><br/>    <strong class="ma hv">public function </strong>__construct(SalaryStrategy $salaryStrategy, $tax)<br/>    {<br/>        $this-&gt;<strong class="ma hv">salaryStrategy </strong>= $salaryStrategy;<br/>        $this-&gt;<strong class="ma hv">tax </strong>= $tax;<br/>    }<br/><br/>    <strong class="ma hv">public function </strong>calculate()<br/>    {<br/>        <strong class="ma hv">return </strong>$this-&gt;<strong class="ma hv">salaryStrategy</strong>-&gt;calculate($this-&gt;<strong class="ma hv">tax</strong>);<br/>    }<br/>}</span></pre><h2 id="ea05" class="ks kt hu bd ku kv kw kx ky kz la lb lc ke ld le lf ki lg lh li km lj lk ll lm dt translated">违反开闭原则</h2><p id="afae" class="pw-post-body-paragraph jv jw hu jx b jy ln iv ka kb lo iy kd ke lp kg kh ki lq kk kl km lr ko kp kq hn dt translated">在一个新出现的需求的上下文中，上面的代码没有违反OCP。基本上不存在仅仅是“违反开闭原则”这样的事情。只有在满足某些需求的情况下，才会违反它。所以第一个版本的<em class="ls"> SalaryService </em>可能多年来一直遵循开闭原则，直到税收发生变化。</p><p id="b521" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">每次你需要实现新的需求和修改现有的代码，这都是OCP违规。当然，你不可能提前找出你所有的抽象——只是因为你不可能提前找出所有的需求。所以违反开闭原则是可以的——当然，只有在你提取新的抽象时。</p><h2 id="6c1a" class="ks kt hu bd ku kv kw kx ky kz la lb lc ke ld le lf ki lg lh li km lj lk ll lm dt translated">总结一下</h2><p id="21e3" class="pw-post-body-paragraph jv jw hu jx b jy ln iv ka kb lo iy kd ke lp kg kh ki lq kk kl km lr ko kp kq hn dt translated">如果作为某个类的一部分的任何行为可以改变，那么它的实现应该隐藏在接口后面。这已经有了一个名字——它就是<a class="ae kr" href="https://en.wikipedia.org/wiki/Loose_coupling" rel="noopener ugc nofollow" target="_blank">松耦合</a>。但它不能通过提取几个接口来完全机械地实现。这一切都始于<a class="ae kr" rel="noopener" href="/@wrong.about/on-good-domain-decomposition-385ee8ce5a3">域分解</a>。</p></div></div>    
</body>
</html>