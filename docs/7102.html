<html>
<head>
<title>Nested categories with rails gem Ancestry.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有rails gem祖先的嵌套类别。</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/nested-categories-with-rails-gem-ancestry-112ca8bbbf98?source=collection_archive---------16-----------------------#2017-10-17">https://medium.com/hackernoon/nested-categories-with-rails-gem-ancestry-112ca8bbbf98?source=collection_archive---------16-----------------------#2017-10-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="1157" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://hackernoon.com/tagged/imagine" rel="noopener ugc nofollow" target="_blank">想象一下</a>你正在处理<a class="ae jp" href="https://hackernoon.com/tagged/project" rel="noopener ugc nofollow" target="_blank">项目</a>其中你有类别，以及这些类别中的产品，以服装网站为例。您可能有以下类别树:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="8050" class="jz ka hu jv b fv kb kc l kd ke">Women<br/>  - Bags<br/>  - Clothes<br/>    - Shirts<br/>    - Jeans [SELECTED]<br/>      - Straight<br/>      - Skinny<br/>  ...<br/>Men<br/>  - Accessories<br/>  - Shoes<br/>  ...</span></pre><p id="48a7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">数据库结构非常简单——id、parent_id、类别标题和产品类别id。非常简单，您可以很容易地获得某个类别的父类和/或子类。</p><p id="32ee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是你需要考虑——如果你选择了牛仔裤，就意味着你想要牛仔裤+直筒牛仔裤+紧身牛仔裤等等。要实现这一点，您需要选定的类别id及其子类别id。用rails很容易得到它们，只需为它编写一个小的自定义范围。</p><p id="ad41" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是如果孩子有自己的孩子，树深得多呢？您将不得不编写高级查询、连接、递归来获取所有级别上的子id。或者假设您已经选择了最后一个类别，并且您想要获取它的所有现有父类别，或者您想要所选类别的兄弟类别(所选级别上的所有项目，如衬衫、牛仔裤等)。通过为所有这样的情况编写定制的范围和方法，您将很快得到一个庞大而混乱的模型。</p><p id="3d58" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">处理嵌套类别的最好工具之一是gem Ancestry(<a class="ae jp" href="https://github.com/stefankroes/ancestry" rel="noopener ugc nofollow" target="_blank">https://github.com/stefankroes/ancestry</a>)，它有很多助手作用域和方法，特别是对于上面提到的情况。</p><h2 id="8b5e" class="jz ka hu bd kf kg kh ki kj kk kl km kn jc ko kp kq jg kr ks kt jk ku kv kw kx dt translated"><strong class="ak">用途</strong></h2><p id="0499" class="pw-post-body-paragraph ir is hu it b iu ky iw ix iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo hn dt translated">祖先非常容易理解和使用。</p><p id="dde2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此处举例项目:<a class="ae jp" href="https://github.com/gioch/ancestry_test.git" rel="noopener ugc nofollow" target="_blank">https://github.com/gioch/ancestry_test.git</a></p><ul class=""><li id="a072" class="ld le hu it b iu iv iy iz jc lf jg lg jk lh jo li lj lk ll dt translated">将gem <code class="eh lm ln lo jv b">ancestry</code>添加到Gemfile。</li><li id="1c98" class="ld le hu it b iu lp iy lq jc lr jg ls jk lt jo li lj lk ll dt translated">为类别创建模型(没有parent_id或类似东西，ancestry会为我们处理它)</li><li id="d68f" class="ld le hu it b iu lp iy lq jc lr jg ls jk lt jo li lj lk ll dt translated">生成迁移以将祖先字段添加到类别:</li></ul><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="27fd" class="jz ka hu jv b fv kb kc l kd ke">rails g migration add_ancestry_to_category ancestry:string:index</span><span id="e6f8" class="jz ka hu jv b fv lu kc l kd ke">### it will add new column to categories, which will handle parent/child stuff</span></pre><ul class=""><li id="6c04" class="ld le hu it b iu iv iy iz jc lf jg lg jk lh jo li lj lk ll dt translated">将“has_ancestry”添加到类别模型</li></ul><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="8ff1" class="jz ka hu jv b fv kb kc l kd ke">class Category &lt; ApplicationRecord<br/>  has_ancestry<br/>end</span></pre><h2 id="b5b6" class="jz ka hu bd kf kg kh ki kj kk kl km kn jc ko kp kq jg kr ks kt jk ku kv kw kx dt translated">创建类别和子类别</h2><p id="3dd3" class="pw-post-body-paragraph ir is hu it b iu ky iw ix iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo hn dt translated">创建子类别很容易，你只需要在创建时指定<code class="eh lm ln lo jv b">parent</code>:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="e22c" class="jz ka hu jv b fv kb kc l kd ke">women = Category.create(name: 'Women')<br/>women_bags = Category.create(name: 'Bags', parent: women)<br/>women_clothes = Category.create(name: 'Clothes', parent: women)</span><span id="5252" class="jz ka hu jv b fv lu kc l kd ke"># Check seeds.rb inside example project for more seeds.</span></pre><h2 id="dec6" class="jz ka hu bd kf kg kh ki kj kk kl km kn jc ko kp kq jg kr ks kt jk ku kv kw kx dt translated">获取所选类别的所有子类别</h2><p id="c357" class="pw-post-body-paragraph ir is hu it b iu ky iw ix iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo hn dt translated">祖先的助手们正在像魔法一样工作。使用方法<code class="eh lm ln lo jv b">children</code>获得子类别，或者使用<code class="eh lm ln lo jv b">child_ids</code>只获得子类别的id数组:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="293c" class="jz ka hu jv b fv kb kc l kd ke"># category {Women}<br/>cat = Category.first</span><span id="8b34" class="jz ka hu jv b fv lu kc l kd ke"># [{Bags}, {Clothes}]<br/>child_objects = cat.children</span><span id="aa6d" class="jz ka hu jv b fv lu kc l kd ke"># [2, 3]<br/>child_ids = cat.child_ids</span></pre><p id="26db" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，如上所述，如果树非常深，并且您想要所有级别的子节点，请使用<code class="eh lm ln lo jv b">descendants</code>来代替:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="8637" class="jz ka hu jv b fv kb kc l kd ke"># [{Bags}, {Clothes}, {Shirts}, {Jeans}, {Straight}, {Skinny}]<br/>all_children = cat.descendants</span><span id="5791" class="jz ka hu jv b fv lu kc l kd ke"># [2, 3, 4, 5, 6, 7]<br/>all_child_ids = cat.descendant_ids</span></pre><h2 id="014d" class="jz ka hu bd kf kg kh ki kj kk kl km kn jc ko kp kq jg kr ks kt jk ku kv kw kx dt translated">获取所选类别的所有父类别</h2><p id="d668" class="pw-post-body-paragraph ir is hu it b iu ky iw ix iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo hn dt translated">如果您选择了树中的最后一个类别，并且您想要获得所有父类别，请使用<code class="eh lm ln lo jv b">ancestors</code>或<code class="eh lm ln lo jv b">ancestor_ids</code>:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="d36a" class="jz ka hu jv b fv kb kc l kd ke"># get category {Straight}<br/>cat = Category.find(7)</span><span id="b6b7" class="jz ka hu jv b fv lu kc l kd ke"># get parent category objects [{Women}, {Clothes}, {Jeans}]<br/>all_parents = cat.ancestors</span><span id="a684" class="jz ka hu jv b fv lu kc l kd ke"># get parent category ids [1, 3, 5]<br/>all_parent_ids = cat.ancestor_ids</span></pre><h2 id="9068" class="jz ka hu bd kf kg kh ki kj kk kl km kn jc ko kp kq jg kr ks kt jk ku kv kw kx dt translated"><strong class="ak">获取指定类别的产品</strong></h2><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="ef2b" class="jz ka hu jv b fv kb kc l kd ke"># get category {Clothes}<br/>cat = Category.find(3)</span><span id="5d8e" class="jz ka hu jv b fv lu kc l kd ke"># get child ids<br/>descendant_ids<!-- --> = cat.<!-- -->descendant_ids</span><span id="8f31" class="jz ka hu jv b fv lu kc l kd ke"># include selected category id if needed<br/>descendant_ids<!-- --> &lt;&lt; cat.id</span><span id="96d7" class="jz ka hu jv b fv lu kc l kd ke">Product.where(category_id: <!-- -->descendant_ids<!-- -->)</span></pre><p id="f8aa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">祖先还有很多其他有用的方法。</p><h2 id="d4f6" class="jz ka hu bd kf kg kh ki kj kk kl km kn jc ko kp kq jg kr ks kt jk ku kv kw kx dt translated">额外资源</h2><p id="cb76" class="pw-post-body-paragraph ir is hu it b iu ky iw ix iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo hn dt translated">点击这里查看祖先的github页面-【https://github.com/stefankroes/ancestry T2】</p><p id="d2c8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">查查Railscast的血统—【http://railscasts.com/episodes/262-trees-with-ancestry T4】</p><figure class="jq jr js jt fq lv"><div class="bz el l di"><div class="lw lx l"/></div></figure></div></div>    
</body>
</html>