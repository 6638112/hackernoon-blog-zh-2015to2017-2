# 微服务误解

> 原文：<https://medium.com/hackernoon/the-microservices-misconception-684bc0584bb6>

如今，人们几乎不可能参加会议或浏览 HackerNews 的首页而不遇到微服务。支持者吹捧它在加强模块化、扩展系统、扩展组织和流程方面的超凡能力。当然，微服务只是旧的面向服务的架构范式的一个重新命名，没有人非常确定“微”首先意味着什么，但是让我们暂时忽略它。当谈到微服务时，我已经看到同样的谬论一次又一次地重复，所以我最终决定我必须写一篇反驳文章。

**模块化**

让我们从围绕服务的最严重的误解开始。我一次又一次地听到有能力的、备受尊敬的程序员告诉我们，模块化在单片中是不可能的，但在微服务中是简单的。似乎在过去的几年里，我们作为程序员已经完全忘记了软件系统在之前的几十年里是如何构建的。对于模块化来说，服务不是必需的，甚至不是有益的。

首先让我来定义模块化，因为人们可能对它的含义有自己的想法。模块化对我来说意味着能够:

1.  将代码库的各个部分分成概念单元，称为模块
2.  独立实现这些模块
3.  在不破坏依赖模块的代码的情况下重构模块。

请注意，我特别没有提到让多个工程师并行处理不同的模块。这是一个很好的好处，但不是目标。即使是一个程序员也会犯错，一次只能记住这么多代码。模块化确保*我们*不会破坏*我们自己的*契约，至少不会在没有意识到的情况下。一年后，当我们重构代码时，无论是添加新功能还是简单地做一些清理工作，我们都不会破坏那些早已被遗忘的契约。

现在记住这个定义，让我做一个肯定会激怒很多人的声明:*没有(静态)类型就不能实现模块化。这需要一篇(相当长的)文章来证明这一点，但是希望有几点就足够了:在动态语言中，我不能确定我正确地实现了我的接口，当重构时，我不能确定我没有意外地改变接口。在我继续之前，让我说，如果你不接受这个基本前提，那么不可避免地，我的论点的其余部分不会说服你。*

静态编程语言是实现模块化的工具，但当然仅有类型是不够的。诸如函数、类、接口，是的，还有模块之类的工具，使我们能够用定义良好的接口编写解耦的代码，我们可以将这些接口插在一起，但又可以单独实现。

作为一个练习，假设我们想将购物车功能添加到我们的应用程序中，这是我以前见过的关于微服务的一个例子。在 OCaml 中，我们将使用以下签名编写一个模块

```
module type SHOPPING_CART = sig
 type t val new_empty: t
 val add_item: t * item -> t
 val remove_item: t * item -> t
 val total_price: t -> money
 val quantity: t * item -> int
end
```

如果你不熟悉 ML 语言，这有点像用 Java 创建购物车界面。如果你对物体更熟悉，你可以使用这个心智模型。关键是，这是一个非常好的购物车服务接口。我们不需要创建一个新的代码库，启动新的机器，添加更多的 CI 管道，创建一个 HTTP 接口，等等。我们可以在代码库中使用它来处理湿漉漉的购物车。不仅如此，它还是*完全类型安全的*。

JSON API 远没有这么安全——它基本上不提供任何保证。如果你发送或接收的 JSON 的结构改变了，你就完了。即使使用 json-schema，一致性仍然只在运行时检查。我不知道你怎么想，但是我宁愿在编译时发现错误，而不是在凌晨 1 点生产时发现错误。

不提像 Thrift 或 Protobuf 这样的服务描述语言是不诚实的。这些都是很棒的[工具](https://hackernoon.com/tagged/tools)，对克服 REST 的缺点大有帮助。如果你确实写微服务，我推荐。但它们不是灵丹妙药；您仍然必须处理网络故障，您必须在您的构建管道中添加代码生成步骤，并且它们的类型系统通常没有我希望的那么强大。但是，如果不是必须的话，就没有理由使用它们。如果您已经*有*因为其他原因创建单独的服务，那么应该使用类似的工具；它们不应该成为*创造服务的理由。*

让我直截了当地说:物理上分离机器与模块化完全无关。网络不是某种神奇的屏障，它能确保你的工程师写出干净的代码。是个喜欢翻位掉包的麻烦怪物。我更愿意我的代码在我的计算机的本地总线上传输，而不是在网络上。除非万不得已，否则我不想和网络打交道。

程序员总是努力编写模块化代码。这在网络存在之前就已经存在了，并且在微服务宣传列车最终失去动力之后还将继续很长时间

**系统扩展**

随着用户群的增长，您的系统也必须扩展以满足不断增长的负载。在工程的各个方面，有许多方法可以实现缩放。

出于某种原因，支持者似乎认为横向扩展您的系统的唯一方法是将它分成几个部分。这是完全不真实的。我们可以通过添加更多服务器和复制来横向扩展单个应用程序。任何提供商——AWS、Heroku、GCP——都会让这一过程变得简单，即使你只有一个应用程序。服务的数量完全与您运行的物理机数量成正比。这不仅适用于无状态服务器，我们还可以扩展，例如，通过添加只读副本来扩展我们的数据库层，以及通过添加更多节点和碎片来扩展我们的弹性搜索集群。

我认为垂直缩放也经常被忽略。这个解决方案在财务上很昂贵，但是不需要改变应用程序代码或基础设施。在考虑成本时，我们还必须考虑到，程序员处理微服务带来的错误和开销所浪费的时间可能会超过成本

另一个被忽视的扩展方法是实际优化代码！现在承认，这可能是相当多的工作，但是使用更快的语言、更有效的数据结构或更智能的 SQL 查询可以对延迟和吞吐量产生巨大的影响。

在探索了所有其他途径之后，服务应该是优化管道的最后一步。

**组织规模**

我承认这是一个独立服务可以提供帮助的领域。在某些情况下，将代码库切割成垂直切片以与产品或功能保持一致是有益的。但是大多数组织都没有足够的工程师来完成这项工作。如果你一直让工程师在多个不同的服务上工作，那么这是错误的方法。

**费用**

很容易被卷入服务炒作的旋风，但我们不要忘记随之而来的成本。它们数不胜数，所以我将简单地列出它们的大致情况:

*   必须同步的多个应用程序会部署并保持版本同步
*   本地开发变得更加困难，因为您必须同时在几个存储库上工作，并保持它们之间的同步变化。像 vagger 和 Docker Compose 这样的工具在这方面有所帮助，但这仍然比使用单一语言的单一 repo 更困难。
*   您必须处理网络故障以及延迟问题。
*   您必须添加服务发现，以便您的应用程序可以找到彼此。这有多容易或有多困难取决于您的运营团队和工具的成熟度——可以说，如果您没有运营团队，您就没有为微服务做好准备。
*   同样，您可能需要建立一个编排系统来跨集群分发您的应用程序。
*   您需要多个数据库，这意味着您的应用程序状态没有一致的视图，也没有创建事务的简单方法。
*   出于日志记录的目的，您需要一种方法来关联跨服务的事务。

我们所有的这些棘手问题都可以管理吗？当然了。但是为什么要承担巨大的成本，除非有相应的巨大利益。

**结论**

我不认为微服务会消失。对我来说，它们让人想起了面向对象编程:有一段时间，面向对象编程语言是最流行的，用于任何可以想到的任务。最终，人们意识到 OOP 并不是每个应用程序的正确架构，并且有相当大的反弹(这是大众的突发奇想)。类和对象仍然有用，它们只是不再是编程的基石(这可以在现代多范式语言如 Scala、Go 和 Rust 中看到)。

作为工程师，我们必须始终努力写出我们能做到的最好的代码，创造出让客户和其他工程师满意的稳定产品。我们应该将精力集中在基础上:编写干净、模块化的代码，确定瓶颈并进行合理的优化，在工程团队内外进行清晰的沟通，并专注于理解我们当前的技术，而不是在技术墙上添加足够多的流行语，并希望某些东西能够坚持下来。

对于绝大多数组织来说，微服务是本末倒置。