<html>
<head>
<title>Dynamically Generate Tags for Database Entries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为数据库条目动态生成标签</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/dynamically-generate-tags-for-database-entries-d4fba077dd33?source=collection_archive---------6-----------------------#2017-12-23">https://medium.com/hackernoon/dynamically-generate-tags-for-database-entries-d4fba077dd33?source=collection_archive---------6-----------------------#2017-12-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/378475da8227505ad15c317f1f7d335c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OuB3PF8o1qUByY_YHXeUpg.jpeg"/></div></div></figure><div class=""/><p id="4a13" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">基于我最近在博客上收到的一个问题，我决定写这篇文章。让我简单解释一下这个想法的背景和上下文。我最近创建了一个网站，在后端保存了许多唐纳德·特朗普的演讲。在前端，用户可以搜索任何单词，以查看该单词是否包含在任何演讲中。如果有匹配的，它会给你统计特朗普最经常谈论用户搜索的任何内容的方式、时间和地点。如果你感兴趣的话，这里有一个这个网站的例子:<a class="ae ka" href="https://trumpspeechdata.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">https://trumpspeechdata.herokuapp.com/</a></p><p id="185a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在最近的一篇文章中，我提到，如果你有一个类似的项目，你可能会试图让用户搜索数据库，以及如何经常出现这样的问题，搜索结果与用户预期的结果不匹配。有一种方法可以帮助缓解这种情况，那就是使用单词的映射对象，它将相似的单词和搜索分组到一个关键字伞中。基本上，如果用户的搜索匹配映射对象中的任何单词，它将被替换为“雨伞”单词，以便返回的搜索结果更接近匹配主题，而不仅仅是用户搜索的特定单词。想了解更多信息，这里有一个帖子:<a class="ae ka" href="https://hackernoon.com/creating-more-accurate-search-results-for-small-sites-436e64da79b6" rel="noopener ugc nofollow" target="_blank">https://hacker noon . com/creating-more-accurate-search-results-for-small-sites-436 e 64 da 79 b 6</a></p><p id="ee28" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以今天的问题是:如果你的数据库结构看起来像这样:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="f08b" class="kk kl if kg b fv km kn l ko kp">{<br/>   "speechtitle": "Remarks by President Trump on TaxReform",<br/>   "speechdate": "September 2017",<br/>   "speechlocation": "Missouri",<br/>   "text": "blah, blah, blah, text here",<br/>}</span></pre><p id="db56" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还没有标签字段。如何动态地向数据库添加标签？首先，您可以手动完成，方法是阅读每篇演讲，并手动将字段和标签添加到每篇演讲中。但是，让我们面对它，这在大多数情况下是不可行的。我们想要做的是向每个数据库条目添加最相关的标签，而不必手动完成。我想到了一个解决办法。为了一窥我在这篇文章中所做的工作，你可以点击这里，并参考它，看看它如何与我正在编写的代码相匹配:</p><p id="13b2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">【https://trumpspeechdata.herokuapp.com/taginput T4】</p><p id="1005" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我先承认，我确信使用Python或PHP可能会有更好的解决方案。我的专长是Node。JS和JavaScript，所以这就是我的解决方案，如果你想跟进的话。我认为古老的格言是正确的，“如果你只有一把锤子，一切看起来都像钉子。”不管怎样，我们开始吧。这是我对此的思考过程:</p><h1 id="6c40" class="kq kl if bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">步骤1:从语音文本中提取标签</h1><p id="c6a7" class="pw-post-body-paragraph jc jd if je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">我需要整理每篇演讲的文本，找到最常用的词。哪些单词出现得最频繁，我将提取它们作为该数据库条目的标签。然而，如果我只是这样做，我会发现“和”、“the”、“it”和“if”是最常用的词。因此，我创建了一个可能主题的数组来循环遍历并匹配演讲文本…这样，我就不会得到很多“非主题”文本，并且我的结果更相关。以下是我使用的标签，我将它们存储在一个数组中:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="fdad" class="kk kl if kg b fv km kn l ko kp">let tags = [ "women's rights", "women", "deport", "border", "security", "immigration", "extremism", "terrorism", "tuition", "healthcare", "tax reform", "taxes", "citizenship", "abortion", "religion", "lgbt", "gay rights", "transgender", "military", "marriage", "gun control", "surveillance", "net neutrality", "drugs", "social security", "obamacare", "medicaid", "israel", "military spending", "north korea", "isis", "equal rights", "minimum wage", "welfare", "student loans", "education", "climate change", "transportation", "loans", "student", "school", "teacher", "jobs", "salary"];</span></pre><p id="bfe5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我将创建一个函数，将这些单词与每个演讲中的所有单词进行匹配。为此我将使用for循环。在使用fetch并将数据存储在一个名为“api”的变量中之后，我就可以开始了。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="c3a6" class="kk kl if kg b fv km kn l ko kp">response.json().then(function(data) {</span><span id="bdca" class="kk kl if kg b fv ls kn l ko kp">let api = data;<br/>            <br/>            <br/>            let tagsOutput = [];<br/>            for (var i = 0; i &lt; api.length; i++) {<br/>              let tags = [ "women's rights", "women", "deport", "border", "security", "immigration", "extremism", "terrorism", "tuition", "healthcare", "tax reform", "taxes", "citizenship", "abortion", "religion", "lgbt", "gay rights", "transgender", "military", "marriage", "gun control", "surveillance", "net neutrality", "drugs", "social security", "obamacare", "medicaid", "israel", "military spending", "north korea", "isis", "equal rights", "minimum wage", "welfare", "student loans", "education", "climate change", "transportation", "loans", "student", "school", "teacher", "jobs", "salary"];<br/>              <br/>              if(api[i].text.length &gt; 1) {<br/>                let index = api.indexOf(api[i]);<br/>                let stringX = api[i].text.split(" ");<br/>                for (var j = 0; j &lt; tags.length; j++) {<br/>                  for (var k = 0; k &lt; stringX.length; k++) {<br/>                    if (tags[j] == stringX[k]) {<br/>                      tagsOutput.push([<br/>                        index,<br/>                        tags[j],<br/>                        api[i].title,<br/>                        api[i].location,<br/>                        api[i].date,<br/>                        api[i].text,<br/>                    ])<br/>                   }<br/>                 }<br/>               }<br/>             }</span></pre><p id="68d5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我将“标签”数组放在for循环中。然后，我创建一个if语句，确保文本在那里。如果是，我执行一个嵌套的for循环，首先将原始文本拆分成单词，并将其存储在变量stringX中。然后我循环遍历我的标签，并在其中嵌套第二个for循环，在这里我循环遍历StringX，然后如果文本中的单词和标签中的单词匹配，我将几个东西放入一个名为“tagsOutput”的新数组中。下面是我将什么放入该阵列，以及原因:</p><ol class=""><li id="a385" class="lt lu if je b jf jg jj jk jn lv jr lw jv lx jz ly lz ma mb dt translated">index —我已经在这个变量中存储了api[i]的索引。因为我将创建一个新的数组，如果我以后需要访问原始api中的数据，我可以通过匹配索引号，轻松地将新数组中的项与api中的项进行匹配。</li><li id="7ff8" class="lt lu if je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">标签—这些是我将提取并最终发布到我的数据库中的标签。</li><li id="5d70" class="lt lu if je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">标题——我想把标题推过来，这样以后当我找到最常用的词时，我就可以把它们和具体的演讲联系起来。</li><li id="ecaa" class="lt lu if je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">地点、日期和文本——我不一定需要所有这些东西。因为我有索引，所以如果以后需要的话，我可以从api数组中获取这些项目。然而，我经常发现，如果可能的话，将我需要的所有东西放在一个数组中会更容易。就像去露营一样。我可能用不到我的雨衣、4个手电筒和8套换洗的内衣，但是如果我以后需要的话，拥有这些东西是很好的。</li></ol><h1 id="a7ad" class="kq kl if bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">步骤2:按频率对标签进行排序</h1><p id="2110" class="pw-post-body-paragraph jc jd if je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">接下来，我需要统计某些词在某些演讲中出现的频率。我将使用一个函数来计算项目频率，去掉重复的条目，并返回项目和频率。我将把磁贴和标签都交给函数。这样，如果演讲的标题是“亚利桑那州的集会”，标签“战争”在演讲中出现了6次，“妇女”出现了8次，我应该会得到如下结果:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="ed6f" class="kk kl if kg b fv km kn l ko kp">{women, rally in Arizona, 8}<br/>{war, rally in Arizona, 6}</span></pre><p id="f23e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这样，我不仅得到了标签的频率，或讲话的频率…而且把它们结合起来，得到了那个标签在讲话中的频率。下面是这个函数的样子:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="54e2" class="kk kl if kg b fv km kn l ko kp">Array.prototype.byCount= function(){<br/>            var itm, a= [], L= this.length, o= {};<br/>            for(var i= 0; i&lt;L; i++){<br/>              itm= this[i];<br/>              if(!itm) continue;<br/>              if(o[itm]== undefined) o[itm]= 1;<br/>              else ++o[itm];<br/>            }<br/>            for(var p in o) a[a.length]= {item: p, frequency: o[p]};<br/>            return a.sort(function(a, b){<br/>              return o[b.item]-o[a.item];<br/>            });<br/>          }</span><span id="a22d" class="kk kl if kg b fv ls kn l ko kp">let tagFreq = tagsOutput.byCount();</span></pre><h1 id="860f" class="kq kl if bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">步骤3:细化标签</h1><p id="51a0" class="pw-post-body-paragraph jc jd if je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">现在我要以很多频率为1，2或3的标签结束。我觉得，在一个45分钟的演讲中，如果“预算”只出现两次，那么它与演讲的相关性不足以作为一个标签。所以我要创建一个新的数组，遍历“tagFreq ”,只添加频率高于6的对象。这应该确保这些标签在语音中足够频繁地出现，以被添加为相关标签。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="5c7b" class="kk kl if kg b fv km kn l ko kp">let arrayOfTags = [];<br/>for (var i = 0; i &lt; tagFreq.length; i++) {<br/>  if (tagFreq[i].frequency &gt; 6) {<br/>    arrayOfTags.push([<br/>      tagFreq[i].item<br/>    ])<br/>  }<br/>}</span></pre><p id="8093" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下一部分完全没有必要，但我会把它包括进来。事后我意识到，这样做将返回一个巨大的字符串，后跟频率。我需要将该字符串的每个部分分隔到一个数组中，这样标题、日期、位置和文本都有自己的数组索引。有更好的方法来做到这一点。但是我使用了一系列逗号分隔的字符串来提取特定的元素。</p><h1 id="e73e" class="kq kl if bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">步骤4:重构数组中的数据</h1><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="62ca" class="kk kl if kg b fv km kn l ko kp">let matchedTags = [];<br/>for (var i = 0; i &lt; arrayOfTags.length; i++) {</span><span id="70da" class="kk kl if kg b fv ls kn l ko kp">let index = arrayOfTags[i][0].split(',', 1)[0];<br/>  let remainingString1 = arrayOfTags[i][0].split(/,(.+)/)[1];<br/>  let tag = remainingString1.split(',', 1)[0];<br/>  let remainingString2 = remainingString1.split(/,(.+)/)[1];<br/>  let title = remainingString2.split(',', 1)[0];<br/>  let remainingString3 = remainingString2.split(/,(.+)/)[1];<br/>  let location = remainingString3.split(',', 1)[0];<br/>  let remainingString4 = remainingString3.split(/,(.+)/)[1];<br/>  let date = remainingString4.split(',', 1)[0];<br/>  let text = remainingString4.split(/,(.+)/)[1];<br/>  <br/>  matchedTags.push([<br/>    index,<br/>    tag,<br/>    title,<br/>    location,<br/>    date,<br/>    text<br/>  ])<br/>}</span></pre><p id="dba6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我害怕演讲文本中的逗号太多，我害怕JavaScript会不小心不正确地将其拆分。所以在这里，我所做的基本上是，在第一个逗号处分割字符串，这给了我“索引”我分别保存“index”之后的所有内容，然后做同样的事情，拆分它，并在下一个逗号处获取标记，冲洗并重复。</p><h1 id="789d" class="kq kl if bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">步骤5:在节点中设置后端。射流研究…</h1><p id="7724" class="pw-post-body-paragraph jc jd if je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">“匹配标签”数组或多或少地给了我想要的数据结构。现在到了棘手的部分。我要在这里换挡，进入后端。带节点。JS我正在使用MongoDB来创建一个基于文档的数据库。我不是简单地在我的数据中添加一个“tags”字段，而是实际上返回添加两个字段。在这篇文章中，我不打算介绍在Node中设置后端的整个过程，而只是解释一下我在做什么。</p><p id="6bd1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最初，我使用Mongoose为我的数据创建模型。我只有一个模式，“演讲”。现在，我将返回并添加第二个名为“speechID”的模型。该模型的结构如下所示:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="7b36" class="kk kl if kg b fv km kn l ko kp">let Schema = mongoose.Schema;</span><span id="5a31" class="kk kl if kg b fv ls kn l ko kp">const speechIDSchema = new Schema({</span><span id="6974" class="kk kl if kg b fv ls kn l ko kp">speechID: {<br/>    type: String,<br/>  },</span><span id="d591" class="kk kl if kg b fv ls kn l ko kp">})<br/>speechIDSchema.plugin(timestamps);<br/>const SpeechID = mongoose.model('speechID', speechIDSchema);</span><span id="17db" class="kk kl if kg b fv ls kn l ko kp">module.exports = SpeechID;</span></pre><p id="c1d3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我的第二个模型中，我引用了第一个模型。这类似于在关系数据库中创建表关联。这里，我的语音文档将与我的speechID文档相关联。我这样做的原因是，稍后，我将需要在我的演讲中添加我的标签。通过在我的“speech”模型中包含一个语音ID，我可以在我的post方法中使用它来确保我添加的标签被添加到正确的语音中。下面是我的语音模型的样子:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="cbca" class="kk kl if kg b fv km kn l ko kp">let Schema = mongoose.Schema;</span><span id="555a" class="kk kl if kg b fv ls kn l ko kp">const speechSchema = new Schema({<br/>  <br/>  speechID: {<br/>  type: String,<br/>  ref: 'SpeechID',<br/>  },<br/>  title: {<br/>    type: String,<br/>  },<br/>  date: {<br/>    type: String,<br/>  },<br/>  location: {<br/>    type: String,<br/>  },<br/>  text: {<br/>    type: String,<br/>  },<br/>  tags: [{<br/>    type: String,<br/>  }],</span><span id="a0b9" class="kk kl if kg b fv ls kn l ko kp">})<br/>speechSchema.plugin(timestamps);<br/>const Speech = mongoose.model('speech', speechSchema);</span><span id="0c07" class="kk kl if kg b fv ls kn l ko kp">module.exports = Speech;</span></pre><p id="e389" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如您在这里看到的，每个语音都将获得一个speechID，但我不需要输入它，它只是从speechID模型中获得ID。在我的app.js中，下面是我如何构建我的app.post来适应这种变化:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="a125" class="kk kl if kg b fv km kn l ko kp">//====APP POST SPEECH===//</span><span id="f1ce" class="kk kl if kg b fv ls kn l ko kp">app.post('/speechnew/:speechID', function(req, res) {<br/>  Speech.create({<br/>  speechID: req.params.speechID,<br/>  title: req.body.title,<br/>  date: req.body.date,<br/>  location: req.body.location,<br/>  text: req.body.text,<br/>  tags: req.body.tags,<br/>}).then(speechs =&gt; {<br/>  res.json(speechs)<br/>});<br/>});</span><span id="15e1" class="kk kl if kg b fv ls kn l ko kp">//==========================//</span></pre><p id="18e5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">app.post操作将是/speechnew/:speechID。然而，我将在创建表单时给它实际的speechID，再次确保这样标记更新正确的文档。您可能会注意到这是“create”方法，但是当我添加标签时，我将使用“findOneAndUpdate”方法。猫鼬里也差不多，基本上就改了那一个字。下面是帖子请求外观:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="45ef" class="kk kl if kg b fv km kn l ko kp">//====APP UPDATE SPEECH===//</span><span id="f696" class="kk kl if kg b fv ls kn l ko kp">app.post('/speechupdate/:speechID', function(req, res) {<br/>  Speech.findOneAndUpdate({<br/>  speechID: req.params.speechID,<br/>  title: req.body.title,<br/>  date: req.body.date,<br/>  location: req.body.location,<br/>  text: req.body.text,<br/>  tags: req.body.tags,<br/>}).then(speechs =&gt; {<br/>  res.json(speechs)<br/>});<br/>});</span><span id="5512" class="kk kl if kg b fv ls kn l ko kp">//==========================//</span></pre><h1 id="e924" class="kq kl if bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">第6步:动态创建一个表单，将反馈后端。</h1><p id="61ae" class="pw-post-body-paragraph jc jd if je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">同样，我不会在这里深入讨论Node.js的内容。我需要做的就是确保我的表单动作与这里的路径匹配，并且我的表单输入名称与这里的req.body名称匹配。好了，让我们回到前端的JavaScript。我放弃了“matchedTags”数组，它保存了我想要的数据结构。我将一步一步地分解下一部分。基本上，接下来要做的是，我要循环遍历我的数组，为每个数组项创建一个表单和表单输入。我将为我创建的每个元素动态地设置唯一的ID，通过创建变量来用作元素ID。那我就要用。值，将这些表单输入的值设置为数组中的数据。我的表单操作将是我在后端创建的更新路由，所以当我更新时唯一会改变的应该是“标签”。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="cd15" class="kk kl if kg b fv km kn l ko kp">for (var i = 0; i &lt; api.length; i++) {<br/>let speechID = api[i].speechID;</span></pre><p id="b1db" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我再次遍历api，并将每个数组元素的ID保存在一个变量中。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="01f2" class="kk kl if kg b fv km kn l ko kp">for (var k = 0; k &lt; matchedTags.length; k++) {<br/>    let formID = "form"+matchedTags[k][0]+"";<br/>    let inputID1 = "input1"+matchedTags[k][0]+"";<br/>    let inputID2 = "input2"+matchedTags[k][0]+"";<br/>    let inputID3 = "input3"+matchedTags[k][0]+"";<br/>    let inputID4 = "input4"+matchedTags[k][0]+"";<br/>    let inputID5 = "input5"+matchedTags[k][0]+"";</span></pre><p id="29f3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我最初的for循环中，我开始了第二个for循环，在这里我循环了我的matchedTags数组。我创建的每个元素都需要有一个唯一的ID。因为我不知道我的数组会有多大，所以我必须让我的for循环来决定。我唯一知道的是，将有一个表格，和5个输入字段“标题”，“日期”，“地点”，“文本”，和“标签”。每个元素基于speechID获得一个惟一的ID，这个ID包含在“matchedTags[k][0]”中。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="0687" class="kk kl if kg b fv km kn l ko kp">if(matchedTags[k][0] == api.indexOf(api[i])) {</span></pre><p id="7c9a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，通过一个if语句，我要确保我之前提取的并存储在matchedTags[k][0]中的IndexOf与api数组的index相匹配。如果有匹配，我将启动一个新函数，创建我需要的所有表单元素，并使用我之前创建的那些id。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="87e6" class="kk kl if kg b fv km kn l ko kp">let newForm = document.createElement('form');</span><span id="1b06" class="kk kl if kg b fv ls kn l ko kp">newForm.id = formID;<br/>              document.body.appendChild(newForm);<br/>              document.getElementById('data').appendChild(newForm);<br/>              newForm.action = "/speechupdate/"+speechID+"";<br/>              newForm.method = "post";</span></pre><p id="2354" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是我的新表单，再次使用formID变量。在newForm.action中，我使用我在后端创建的路由/speechupdate/:speechID，只是在这里，speechID是一个包含语音ID的变量。这就是将表单连接到正确的数据库条目的原因。接下来，我将创建一些输入并将它们追加到表单中，就像我将表单追加到HTML主体中的and元素一样:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="b2e5" class="kk kl if kg b fv km kn l ko kp">let newInput1 = document.createElement('input');<br/>          newInput1.id = inputID1;<br/>          document.body.appendChild(newInput1);<br/>          document.getElementById(formID).appendChild(newInput1);<br/>          newInput1.name = "title";<br/>          newInput1.value = matchedTags[k][2];<br/>          <br/>          let newInput2 = document.createElement('input');<br/>          newInput2.id = inputID2;<br/>          document.body.appendChild(newInput2);<br/>          document.getElementById(formID).appendChild(newInput2);<br/>          newInput2.name = "date";<br/>          newInput2.value = matchedTags[k][4];<br/>          <br/>          let newInput3 = document.createElement('input');<br/>          newInput3.id = inputID3;<br/>          document.body.appendChild(newInput3);<br/>          document.getElementById(formID).appendChild(newInput3);<br/>          newInput3.name = "location";<br/>          newInput3.value = matchedTags[k][3];<br/>          <br/>          let newInput4 = document.createElement('input');<br/>          newInput4.id = inputID4;<br/>          document.body.appendChild(newInput4);<br/>          document.getElementById(formID).appendChild(newInput4);<br/>          newInput4.name = "text";<br/>          newInput4.value = matchedTags[k][5];<br/>          <br/>          let newInput5 = document.createElement('input');<br/>          newInput5.id = inputID5;<br/>          document.body.appendChild(newInput5);<br/>          document.getElementById(formID).appendChild(newInput5);<br/>          newInput5.name = "tags";<br/>          newInput5.value = matchedTags[k][1];<br/>          <br/>          let submitButton = document.createElement('input');<br/>          submitButton.id = "submitbtn";<br/>          document.body.appendChild(submitButton);<br/>          document.getElementById(formID).appendChild(submitButton);<br/>          submitButton.type = "submit";</span></pre><p id="1d52" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每个表单输入都被附加到表单中，并有自己唯一的ID。input.name也匹配我们在后端使用的req.body名称。下面是整个函数的整体外观:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="e377" class="kk kl if kg b fv km kn l ko kp">for (var i = 0; i &lt; api.length; i++) {<br/>  let speechID = api[i].speechID;<br/>  for (var k = 0; k &lt; matchedTags.length; k++) {<br/>    let formID = "form"+matchedTags[k][0]+"";<br/>    let inputID1 = "input1"+matchedTags[k][0]+"";<br/>    let inputID2 = "input2"+matchedTags[k][0]+"";<br/>    let inputID3 = "input3"+matchedTags[k][0]+"";<br/>    let inputID4 = "input4"+matchedTags[k][0]+"";<br/>    let inputID5 = "input5"+matchedTags[k][0]+"";<br/>    if(matchedTags[k][0] == api.indexOf(api[i])) {<br/>      <br/>      let newForm = document.createElement('form');</span><span id="e4ca" class="kk kl if kg b fv ls kn l ko kp">newForm.id = formID;<br/>              document.body.appendChild(newForm);<br/>              document.getElementById('data').appendChild(newForm);<br/>              newForm.action = "/speechupdate/"+speechID+"";<br/>              newForm.method = "post";<br/>          <br/>          let newInput1 = document.createElement('input');<br/>          newInput1.id = inputID1;<br/>          document.body.appendChild(newInput1);<br/>          document.getElementById(formID).appendChild(newInput1);<br/>          newInput1.name = "title";<br/>          newInput1.value = matchedTags[k][2];<br/>          <br/>          let newInput2 = document.createElement('input');<br/>          newInput2.id = inputID2;<br/>          document.body.appendChild(newInput2);<br/>          document.getElementById(formID).appendChild(newInput2);<br/>          newInput2.name = "date";<br/>          newInput2.value = matchedTags[k][4];<br/>          <br/>          let newInput3 = document.createElement('input');<br/>          newInput3.id = inputID3;<br/>          document.body.appendChild(newInput3);<br/>          document.getElementById(formID).appendChild(newInput3);<br/>          newInput3.name = "location";<br/>          newInput3.value = matchedTags[k][3];<br/>          <br/>          let newInput4 = document.createElement('input');<br/>          newInput4.id = inputID4;<br/>          document.body.appendChild(newInput4);<br/>          document.getElementById(formID).appendChild(newInput4);<br/>          newInput4.name = "text";<br/>          newInput4.value = matchedTags[k][5];<br/>          <br/>          let newInput5 = document.createElement('input');<br/>          newInput5.id = inputID5;<br/>          document.body.appendChild(newInput5);<br/>          document.getElementById(formID).appendChild(newInput5);<br/>          newInput5.name = "tags";<br/>          newInput5.value = matchedTags[k][1];<br/>          <br/>          let submitButton = document.createElement('input');<br/>          submitButton.id = "submitbtn";<br/>          document.body.appendChild(submitButton);<br/>          document.getElementById(formID).appendChild(submitButton);<br/>          submitButton.type = "submit";<br/>              <br/>              console.log(newInput3.value);</span><span id="b18d" class="kk kl if kg b fv ls kn l ko kp">}<br/>  }<br/>}</span></pre><p id="7a9b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，这个解决方案是可行的，但它可能更干净，而且在其他地方可能有更好的解决方案。但是如果你像我一样，真的喜欢node.js和JavaScript，如果你需要用数据库内容生成的标签动态地更新数据库，这个解决方案应该是可行的。如果您有任何问题或反馈，请联系我们。谢谢！</p></div></div>    
</body>
</html>