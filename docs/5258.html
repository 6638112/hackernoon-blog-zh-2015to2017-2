<html>
<head>
<title>A glance at MVI through a deck of cards</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">透过一副纸牌看MVI一眼</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-glance-at-mvi-through-a-deck-of-cards-4298a349b090?source=collection_archive---------12-----------------------#2017-07-18">https://medium.com/hackernoon/a-glance-at-mvi-through-a-deck-of-cards-4298a349b090?source=collection_archive---------12-----------------------#2017-07-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/fc7a8b4b798ae83d664cc2d68a490d2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*xFSaxe5_cwzmrwwOyQ5k3A.png"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">from <a class="ae jc" href="https://lambda-it.ch/blog/post/reactive-data-flow-in-angular-2" rel="noopener ugc nofollow" target="_blank">https://lambda-it.ch/blog/post/reactive-data-flow-in-angular-2</a></figcaption></figure><p id="af66" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">自从我看到使用RxSealedUnions 实现<a class="ae jc" href="https://github.com/pakoito/RxSealedUnions2/blob/master/rxsealedunions2/src/test/java/com/pacoworks/rxsealedunions2/tennis/TennisGame.java#L21" rel="noopener ugc nofollow" target="_blank">“网球形”的示例后，我就一直对MVI很好奇。老实说，我仍然不完全确定它是如何工作的(我认为它应该有自己的文章)——它在lambdas上看起来更好，它是一个有限状态机的实现，具有严格定义的状态，其中联合定义了给定的状态，以及它们在给定的状态下如何反应。</a></p><p id="f1e7" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">有了这个联合设置，无效的州是不可能的。</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kf kg l"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">Tennis Kata: scorePoints() by Pakoito</figcaption></figure><p id="9c7f" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">虽然这是MVI希望通过其不变的视图状态实现的——对我来说，也许还有许多其他人，MVI的概念似乎很难理解、掌握和实现。</p><p id="afb1" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">如果你想了解MVI，你会看到令人生畏的代码和令人生畏的框架，如<a class="ae jc" href="https://cycle.js.org/" rel="noopener ugc nofollow" target="_blank">cycle . JS</a>(JS)<a class="ae jc" href="http://redux.js.org/" rel="noopener ugc nofollow" target="_blank">Redux</a>(JS)<a class="ae jc" href="https://github.com/bkase/cyklic/blob/master/lib/src/main/java/com/bkase/cyklic/example/SimpleCounter.kt#L20-L35" rel="noopener ugc nofollow" target="_blank">Cyklic</a>(Kotlin)，以及最后但同样重要的<a class="ae jc" href="https://guide.elm-lang.org/architecture/" rel="noopener ugc nofollow" target="_blank"> Elm Architecture </a> <a class="ae jc" href="https://github.com/evancz/elm-todomvc/blob/master/Todo.elm#L119-L196" rel="noopener ugc nofollow" target="_blank">用Elm </a>(一种函数式语言，不像C#、C++或<a class="ae jc" href="https://hackernoon.com/tagged/java" rel="noopener ugc nofollow" target="_blank">Java</a>——它们是命令式的)！</p><p id="6d8b" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">最重要的是，许多<a class="ae jc" href="https://hackernoon.com/tagged/redux" rel="noopener ugc nofollow" target="_blank"> Redux </a>例子喜欢展示同步代码，在那里你添加一个TODO到一个没有持久性和异步操作的内存存储中——好吧，现实生活并不那么容易。</p><p id="24f5" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">但说够了，我答应MVI，所以我们走吧！</p><h1 id="3845" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">一副扑克牌</h1><p id="c35c" class="pw-post-body-paragraph jd je hu jf b jg lf ji jj jk lg jm jn jo lh jq jr js li ju jv jw lj jy jz ka hn dt translated">幸运的是，<a class="lk ll gr" href="https://medium.com/u/bbd9a49ea3d9?source=post_page-----4298a349b090--------------------------------" rel="noopener" target="_blank"> Zak Taccardi </a>(他是一个很酷的人，你应该跟随他)收集了一个基于MVI架构的相当平易近人的例子(这是他之前关于状态渲染器的<a class="ae jc" href="https://hackernoon.com/model-view-intent-mvi-part-1-state-renderer-187e270db15c" rel="noopener ugc nofollow" target="_blank">帖子的后续)。</a></p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div class="fe ff lm"><img src="../Images/b687dba071c8cc2fa2e34888a0baaba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*SUQfFtVmK3Dk6OMJA33fFg.png"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">Picture of the Deck of Cards app</figcaption></figure><p id="c54f" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">源代码可以在<a class="ae jc" href="https://github.com/ZakTaccardi/deck-of-cards" rel="noopener ugc nofollow" target="_blank"> Zak Taccardi的Github资源库(</a> <code class="eh ln lo lp lq b">ZakTaccardi/deck-of-cards</code> <a class="ae jc" href="https://github.com/ZakTaccardi/deck-of-cards" rel="noopener ugc nofollow" target="_blank"> ) </a>获得，并且是用Kotlin编写的。</p><p id="ef2e" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">然而，如果你对跟随Kotlin感到不安，那么幸运的是，我花了时间将代码转换为Java，这可以在一个fork (  <code class="eh ln lo lp lq b"><a class="ae jc" href="https://github.com/Zhuinden/deck-of-cards" rel="noopener ugc nofollow" target="_blank">zhuinden/deck-of-cards</a></code> <a class="ae jc" href="https://github.com/Zhuinden/deck-of-cards" rel="noopener ugc nofollow" target="_blank"> ) </a>中的<a class="ae jc" href="https://github.com/Zhuinden/deck-of-cards" rel="noopener ugc nofollow" target="_blank">我的名字下找到。</a></p><p id="32fa" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt">.</p><p id="9d8e" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt">.</p><p id="016b" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt">.</p><p id="ccb1" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">该应用程序本身看起来相当简单——你可以点击卡片来分发这副牌的顶部，你可以要求应用程序洗牌。并且你可以创建一副新的牌(它会把所有发的牌拿出来重新洗牌)。</p><p id="9870" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">操作本身不是即时的，它模拟了中间的“加载”，因为“网络请求”需要时间。</p><p id="6583" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">偶尔，也有随机注入的“错误”,以表明有时事情并不顺利，我们也需要处理错误状态。</p><h1 id="c1c3" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">组件概述</h1><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="fe ff lr"><img src="../Images/5e6b4f2b64542105bab312e532c0f143.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TDrEQN7izsDzF8e2lDm5GA.png"/></div></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">Components and their interactions with one another</figcaption></figure><p id="280c" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">这里有一些重要的事情需要注意。</p><ul class=""><li id="5919" class="lw lx hu jf b jg jh jk jl jo ly js lz jw ma ka mb mc md me dt translated"><strong class="jf hv">意图</strong>:指用户可以通过UI触发的动作。</li><li id="4759" class="lw lx hu jf b jg mf jk mg jo mh js mi jw mj ka mb mc md me dt translated"><strong class="jf hv"> Presenter </strong>:订阅所有暴露的请求和触发状态变化的操作。当一个请求/操作发生时，它们被映射到一种类型的<code class="eh ln lo lp lq b">Change</code>——用于根据先前的状态和变化减少(评估)新的状态。</li><li id="cad5" class="lw lx hu jf b jg mf jk mg jo mh js mi jw mj ka mb mc md me dt translated"><strong class="jf hv">变化</strong>:表示一种变化类型，它决定了状态应该如何变化。</li><li id="af98" class="lw lx hu jf b jg mf jk mg jo mh js mi jw mj ka mb mc md me dt translated"><strong class="jf hv">状态</strong>:表示应用程序的状态——在这种情况下，如果洗牌，当前的牌正在发牌，正在建立新的牌，或者是否有错误。</li><li id="b6c8" class="lw lx hu jf b jg mf jk mg jo mh js mi jw mj ka mb mc md me dt translated"><strong class="jf hv"> Ui </strong>:将<code class="eh ln lo lp lq b">render(State)</code>通话从主持人处委托给<code class="eh ln lo lp lq b">StateRenderer</code>。</li><li id="28b2" class="lw lx hu jf b jg mf jk mg jo mh js mi jw mj ka mb mc md me dt translated"><strong class="jf hv"> StateRenderer </strong>:将<code class="eh ln lo lp lq b">State</code>分成几个部分，并分别观察其中的变化(使用<code class="eh ln lo lp lq b">PublishRelay</code>和<code class="eh ln lo lp lq b">distinctUntilChanged()</code>过滤器)，然后调用<code class="eh ln lo lp lq b">UiActions</code>，当给定属性发生变化时，它会修改UI。</li><li id="961a" class="lw lx hu jf b jg mf jk mg jo mh js mi jw mj ka mb mc md me dt translated"><strong class="jf hv"> UiActions </strong>:表示可以操作UI的动作。基本上是MVP/MVVM的<em class="mk">视图</em>。</li></ul><h2 id="8869" class="ml ki hu bd kj mm mn mo kn mp mq mr kr jo ms mt kv js mu mv kz jw mw mx ld my dt translated">关于经销商…</h2><p id="752d" class="pw-post-body-paragraph jd je hu jf b jg lf ji jj jk lg jm jn jo lh jq jr js li ju jv jw lj jy jz ka hn dt translated">最后剩下的组件严格来说不是架构的一部分，它是一个特定于应用程序的组件:经销商。</p><p id="020b" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">事实上，我没有在上面列出它，因为它的行为有点…奇怪。不是使用<code class="eh ln lo lp lq b">flatMap()</code>或<code class="eh ln lo lp lq b">concatMap()</code>来连接“输入”请求和“输出”修改的卡片组或操作——而是使用<code class="eh ln lo lp lq b">doOnNext()</code>的组合来单独订阅<code class="eh ln lo lp lq b">BehaviorRelay</code>,但是由于<code class="eh ln lo lp lq b">deck</code>是一个<code class="eh ln lo lp lq b">BehaviorRelay</code>,它存储以前的值！</p><p id="d74d" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">如果这是严格的MVI，唯一的<code class="eh ln lo lp lq b">deck</code>将存在于<code class="eh ln lo lp lq b">State</code>中，庄家将接收状态，并从那里使用该副牌。</p><p id="e347" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">将<code class="eh ln lo lp lq b">doOnNext()</code>与继电器一起使用的异常现象很可能源于每个公开的操作提供了多个事件，通常既有甲板的变化，又有<code class="eh ln lo lp lq b">__Operation</code>。这可以替换为一个公共的密封类，并公开一个发出多个事件的<code class="eh ln lo lp lq b">Observable</code>(然后调用<code class="eh ln lo lp lq b">onComplete()</code>)。</p><p id="f6cf" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">但是，尽管与经销商的沟通并非完全无状态，我们仍然可以从这个例子中学到很多。</p><h1 id="68dc" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">意图</h1><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kf kg l"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">Intentions (user actions)</figcaption></figure><p id="a766" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">所有的用户操作都通过<code class="eh ln lo lp lq b">PublishRelay</code> s公开。演示者监听它们，并将它们映射到更改，另外触发<code class="eh ln lo lp lq b">Dealer</code>做它的事情。</p><h1 id="4f25" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">提出者</h1><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kf kg l"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">Presenter</figcaption></figure><p id="e256" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">演示者订阅了来自<code class="eh ln lo lp lq b">Intentions</code>(用户操作)和<code class="eh ln lo lp lq b">Dealer</code>的事件。这些都被转换成<code class="eh ln lo lp lq b">Change</code>对象的子类，基于这些子类，从先前的状态评估出新的状态，并将新的状态呈现给UI。</p><h1 id="65f2" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">变化</h1><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kf kg l"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">Change</figcaption></figure><p id="4b34" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">命名可以改变状态的动作是所有MVI方案 的<strong class="jf hv"> <em class="mk">心脏。在Redux中，这是<code class="eh ln lo lp lq b">Action</code>，在本例中，这是<code class="eh ln lo lp lq b">Change</code>。它代表了国家可以改变的方式。</em></strong></p><h1 id="642f" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">状态</h1><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kf kg l"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">State</figcaption></figure><p id="cf9c" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">状态存储当前状态(不出所料)，但也描述了如何使用<code class="eh ln lo lp lq b">Change</code>评估新状态。在Redux中，这将被称为<code class="eh ln lo lp lq b">StateReducer</code>。</p><p id="0216" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">当对象改变时，它的一个副本被返回，给定的变量根据它如何被<code class="eh ln lo lp lq b">Change</code>影响而修改。</p><h1 id="092c" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">状态渲染器</h1><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kf kg l"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">State Renderer</figcaption></figure><p id="9962" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">presenter告诉Ui呈现状态，但这实际上是由<code class="eh ln lo lp lq b">StateRenderer</code>处理的，它将调用右边的<code class="eh ln lo lp lq b">UiActions</code>来确定如何让Ui显示我们希望它显示的内容。</p><h1 id="c747" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">UiActions</h1><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kf kg l"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">UI Actions</figcaption></figure><p id="575f" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">正如我们所看到的，UiActions代表了MVI的<code class="eh ln lo lp lq b">View</code>，关于它就不多说了。</p><h1 id="ead9" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">结论</h1><p id="8dc6" class="pw-post-body-paragraph jd je hu jf b jg lf ji jj jk lg jm jn jo lh jq jr js li ju jv jw lj jy jz ka hn dt translated">纸牌的例子让我们看了一眼MVI。我们最重要的收获是:</p><ul class=""><li id="00cc" class="lw lx hu jf b jg jh jk jl jo ly js lz jw ma ka mb mc md me dt translated">应用程序逻辑是通过公开事件来驱动的，特别是对于与UI的交互(<code class="eh ln lo lp lq b">Intentions</code>，架构的名称由此而来)</li><li id="8713" class="lw lx hu jf b jg mf jk mg jo mh js mi jw mj ka mb mc md me dt translated">命名可以改变状态的动作</li><li id="c451" class="lw lx hu jf b jg mf jk mg jo mh js mi jw mj ka mb mc md me dt translated">状态是明确的，并且总是不可变的，并且总是在变化时被复制</li><li id="4b78" class="lw lx hu jf b jg mf jk mg jo mh js mi jw mj ka mb mc md me dt translated">在这种情况下，负责“驱动Ui”的是<code class="eh ln lo lp lq b">StateRenderer</code></li><li id="dc4d" class="lw lx hu jf b jg mf jk mg jo mh js mi jw mj ka mb mc md me dt translated">显然，<code class="eh ln lo lp lq b">PublishRelay</code>对于将我们的流分割成多个流非常有用！:)</li></ul><p id="f824" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">如需更多资源，您可以查看:</p><ul class=""><li id="1ab5" class="lw lx hu jf b jg jh jk jl jo ly js lz jw ma ka mb mc md me dt translated"><a class="ae jc" href="https://github.com/CesarValiente/KUnidirectional/" rel="noopener ugc nofollow" target="_blank">kunididirectional</a>(没有Rx的例子！)</li><li id="5cc9" class="lw lx hu jf b jg mf jk mg jo mh js mi jw mj ka mb mc md me dt translated"><a class="ae jc" href="http://hannesdorfmann.com/android/model-view-intent" rel="noopener ugc nofollow" target="_blank">汉尼斯·多夫曼关于MVI的著作</a></li><li id="a467" class="lw lx hu jf b jg mf jk mg jo mh js mi jw mj ka mb mc md me dt translated"><a class="ae jc" href="https://www.youtube.com/watch?v=1zj7M1LnJV4" rel="noopener ugc nofollow" target="_blank">这段视频由后面的家伙循环播放。JS </a>(这是Android上MVI变种背后的灵感)</li><li id="b393" class="lw lx hu jf b jg mf jk mg jo mh js mi jw mj ka mb mc md me dt translated">【Redux(与MVI非常相似)背后的人制作的这个视频讲述了他如何将商店转变为减速器</li><li id="8091" class="lw lx hu jf b jg mf jk mg jo mh js mi jw mj ka mb mc md me dt translated">这是杰克·沃顿关于管理国家的演讲。)</li><li id="f168" class="lw lx hu jf b jg mf jk mg jo mh js mi jw mj ka mb mc md me dt translated"><em class="mk">(也许也是这个</em> <a class="ae jc" href="https://news.realm.io/news/kau-lee-kase-reduxing-ui-borrowing-from-web/" rel="noopener ugc nofollow" target="_blank"> <em class="mk">由Christina Lee在ViewDrivers上谈</em> </a> <em class="mk">那也许有一天我们也会明白，连同这个</em> <a class="ae jc" href="https://gist.github.com/bkase/dbfc79353ed67a27a822" rel="noopener ugc nofollow" target="_blank"> <em class="mk">命题后面的</em></a><em class="mk">)</em></li></ul><p id="74d0" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">再次特别感谢<a class="lk ll gr" href="https://medium.com/u/bbd9a49ea3d9?source=post_page-----4298a349b090--------------------------------" rel="noopener" target="_blank"> Zak Taccardi </a>写了一个例子，看完就明白了。</p><p id="d06c" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated"><em class="mk">源代码可在Zak Taccardi </em>  <em class="mk">的</em> <a class="ae jc" href="https://github.com/ZakTaccardi/deck-of-cards" rel="noopener ugc nofollow" target="_blank"> <em class="mk"> Kotlin或me </em> </a> <em class="mk">的</em> <a class="ae jc" href="https://github.com/Zhuinden/deck-of-cards" rel="noopener ugc nofollow" target="_blank"> <em class="mk"> Java中抄录。</em></a></p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="mz kg l"/></div></figure></div></div>    
</body>
</html>