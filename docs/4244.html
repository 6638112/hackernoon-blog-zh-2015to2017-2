<html>
<head>
<title>Understanding JavaScript: Scope</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript:范围</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/understanding-javascript-scope-1d4a74adcdf5?source=collection_archive---------0-----------------------#2017-05-20">https://medium.com/hackernoon/understanding-javascript-scope-1d4a74adcdf5?source=collection_archive---------0-----------------------#2017-05-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/8c88cdcaf556a591092acef4fd308b1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Q3L7OsxvSwverM_-6Gw3w.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by Scott Webb from Pexels</figcaption></figure><p id="c483" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">变量或函数的作用域是它可用的代码部分。对于大多数开发人员来说，使用变量和范围是很直观的。我们有一些心理模型来帮助我们理解什么时候某些事情是不可接受的。</p><blockquote class="ke"><p id="6f89" class="kf kg hu bd kh ki kj kk kl km kn kd ek translated">范围是运行时代码不同部分中函数和变量的可见性</p></blockquote><p id="0a1f" class="pw-post-body-paragraph jg jh hu ji b jj ko jl jm jn kp jp jq jr kq jt ju jv kr jx jy jz ks kb kc kd hn dt translated">为了掌握JavaScript语言，我们必须在现有的心智模型的基础上构建，并深入细节。虽然我确信每个开发人员都可以在没有深入理解范围的情况下编写出优秀的代码，但是只有那些花时间阅读小字体的人才能避免所有的陷阱并回答最棘手的面试问题。</p><h1 id="4912" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">范围的类型</h1><p id="fe65" class="pw-post-body-paragraph jg jh hu ji b jj lr jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd hn dt translated">JavaScript中有三种类型的作用域:</p><ul class=""><li id="689c" class="lw lx hu ji b jj jk jn jo jr ly jv lz jz ma kd mb mc md me dt translated">全局范围—可以在任何地方访问变量。</li><li id="5458" class="lw lx hu ji b jj mf jn mg jr mh jv mi jz mj kd mb mc md me dt translated">函数范围—变量可以在定义它们的函数的边界内访问。</li><li id="a08e" class="lw lx hu ji b jj mf jn mg jr mh jv mi jz mj kd mb mc md me dt translated">块范围—可以在定义变量的块中访问变量。一个块由<code class="eh mk ml mm mn b">{</code>和<code class="eh mk ml mm mn b">}</code>分开。</li></ul><figure class="mp mq mr ms fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mo"><img src="../Images/74dd87eba32c4fbf6a1f26c0a8aaa96b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hNxfD82kOh6TrIfVeHsfBA.png"/></div></div></figure><p id="af57" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">正如你在例子中看到的，即使<code class="eh mk ml mm mn b">global</code>变量在函数中被赋予了不同的值，它也只保留在同一个函数的边界中。在它之外，变量有一个不同的值——在全局范围内声明的值。我们也不会因为使用相同的变量名而出错。</p><figure class="mp mq mr ms fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mt"><img src="../Images/8043b998cb539ee3bae5ef553503bff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BhbPNDcj1amnGQ4DGeOzGg.png"/></div></div></figure><p id="805f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这里我们可以看到，<code class="eh mk ml mm mn b">inner()</code>函数可以访问其父函数<code class="eh mk ml mm mn b">fn()</code>中声明的变量。每当我们需要一个函数中的变量时，引擎会首先在当前函数的范围内寻找它。那么它将在包含它的函数中上升一级。如果在那里找不到，它将继续上升，直到到达全局范围。如果没有找到变量，我们将得到一个<code class="eh mk ml mm mn b">ReferenceError</code>。</p><h1 id="5db9" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">未声明的变量</h1><p id="b7ec" class="pw-post-body-paragraph jg jh hu ji b jj lr jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd hn dt translated">JavaScript不会阻止你使用未声明的变量。这意味着您可以在任何时候为变量赋值，而无需使用<code class="eh mk ml mm mn b">const</code>、<code class="eh mk ml mm mn b">let</code>或<code class="eh mk ml mm mn b">var</code>。当你这样做的时候，引擎会试图寻找一个全局范围内的变量。如果没有找到，它会为你创建一个全局变量。</p><p id="54ef" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">根据经验，避免污染全局范围。如果一个变量是要全局使用的，那么就在全局范围内声明它，这样你的意图就很清楚了。否则，请将其保持在使用它的范围内。</p><h1 id="3a1a" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">提升</h1><p id="1adf" class="pw-post-body-paragraph jg jh hu ji b jj lr jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd hn dt translated">JavaScript中函数和变量的提升是我们可以在实际声明之前使用它们的原因。</p><figure class="mp mq mr ms fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mo"><img src="../Images/5294e708080068d121c623397206c3a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BVSMYAf4IkE43cNvteyHfA.png"/></div></div></figure><p id="0651" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">上面的代码将记录字符串<code class="eh mk ml mm mn b">"working"</code>,即使函数在声明之前被调用。</p><p id="fc21" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">对这种行为给出的常见解释是，函数和变量声明被拉到了它们作用域的顶部。所以当你试图访问它们的时候，它们已经被声明了。上面的例子实际上会变成:</p><figure class="mp mq mr ms fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mo"><img src="../Images/7888f5567480855b3857812c2771b16a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oqQrSQOLd5Xhw25IiO1ByQ.png"/></div></div></figure><p id="c823" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">变量也被提升，但方式不同。只有变量的声明被“拉到”顶部。赋值将保持不变。换句话说，我们不能像调用函数那样访问变量的值。</p><figure class="mp mq mr ms fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mo"><img src="../Images/88f221e628802fd8d319d7e64537dd2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Rr8WNbEnT0tyoHBxGahqg.png"/></div></div></figure><p id="0d3e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">变量被提升到顶部后，上面的代码看起来是这样的:</p><figure class="mp mq mr ms fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mo"><img src="../Images/030d598de8bbd2bac23db06327a54c09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*06PQyOVmDHVlGyb28uB1NA.png"/></div></div></figure><p id="de0f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这就是为什么我们在使用<strong class="ji hv">函数表达式</strong>时需要小心的原因。</p><figure class="mp mq mr ms fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mo"><img src="../Images/d846bebaba8cd43e740f504991fe2254.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BFsiIuWjKeAW7UwsIO0cMA.png"/></div></div></figure><p id="dafb" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">同样，只有声明被放在顶部，而函数作为值的实际赋值将保持不变。所以当我们试图调用函数<code class="eh mk ml mm mn b">test</code>时，我们会得到一个错误。</p><h1 id="169c" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">块范围</h1><p id="8d29" class="pw-post-body-paragraph jg jh hu ji b jj lr jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd hn dt translated">在ES6中，我们得到了两个新的变量声明关键字— <code class="eh mk ml mm mn b">let</code>和<code class="eh mk ml mm mn b">const</code>。它们和<code class="eh mk ml mm mn b">let</code>的主要区别在于用ES6关键字声明的变量是块范围的。这意味着它们只在定义它们的代码块中可用。代码块由花括号分隔。</p><p id="2235" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">因为我们在讨论范围，所以重要的是要注意用<code class="eh mk ml mm mn b">let</code>或<code class="eh mk ml mm mn b">const</code>创建的变量不会被提升。这意味着它们的定义不会像用<code class="eh mk ml mm mn b">var</code>声明的变量一样被拉到顶部。</p><figure class="mp mq mr ms fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mo"><img src="../Images/44654008dcbceed0ac6abdf465a20fc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kBgQN_g9LhY3iAbeFpZ4_A.png"/></div></div></figure><p id="1469" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">确保您的代码没有引用错误的一个方法是确保您只使用<code class="eh mk ml mm mn b">let</code>和<code class="eh mk ml mm mn b">const</code>进行变量声明。</p><h1 id="d8ca" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">汇编</h1><p id="aaba" class="pw-post-body-paragraph jg jh hu ji b jj lr jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd hn dt translated">现在我们已经理解了提升的概念，我们将深入了解语言的内部，并理解它实际上是如何工作的。V8引擎通过在执行代码之前将JavaScript编译成机器代码来提高性能。在编译过程中，引擎会多次运行我们的代码。在早期的一次运行中，它将声明所有的函数和变量。所以当代码被执行时，它们已经被定义了。</p><p id="1c38" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">所以，提升实际上是一个心理图像，帮助我们说明为什么我们可以在定义函数和变量之前访问它们。提升的常见解释只是一个代码在执行前如何重组的画面。当引擎实际执行我们的代码时，我们的函数和变量声明根本就不存在了。它们已经在之前的运行中声明过了。</p><h1 id="580d" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">结论</h1><p id="bb9c" class="pw-post-body-paragraph jg jh hu ji b jj lr jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd hn dt translated">范围的概念对于开发人员来说是直观的，但是为了精通一门语言，我们必须意识到它的特殊性。作为JavaScript开发人员，我们需要记住的是:</p><ul class=""><li id="5942" class="lw lx hu ji b jj jk jn jo jr ly jv lz jz ma kd mb mc md me dt translated">未声明的变量</li><li id="a3dc" class="lw lx hu ji b jj mf jn mg jr mh jv mi jz mj kd mb mc md me dt translated">块范围的变量</li><li id="2dab" class="lw lx hu ji b jj mf jn mg jr mh jv mi jz mj kd mb mc md me dt translated">提升</li></ul><div class="mu mv fm fo mw mx"><a href="https://hackernoon.com/understanding-javascript-scope-1d4a74adcdf5" rel="noopener  ugc nofollow" target="_blank"><div class="my ab ej"><div class="mz ab na cl cj nb"><h2 class="bd hv fv z el nc eo ep nd er et ht dt translated">理解JavaScript:范围</h2><div class="ne l"><h3 class="bd b fv z el nc eo ep nd er et ek translated">由于数量惊人的库、工具和各种各样的东西使你的开发更容易，很多…</h3></div><div class="nf l"><p class="bd b gc z el nc eo ep nd er et ek translated">hackernoon.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl ja mx"/></div></div></a></div><div class="mu mv fm fo mw mx"><a href="https://hackernoon.com/understanding-javascript-prototype-and-inheritance-d55a9a23bde2" rel="noopener  ugc nofollow" target="_blank"><div class="my ab ej"><div class="mz ab na cl cj nb"><h2 class="bd hv fv z el nc eo ep nd er et ht dt translated">理解JavaScript:原型和继承</h2><div class="ne l"><h3 class="bd b fv z el nc eo ep nd er et ek translated">由于数量惊人的库、工具和各种各样的东西使你的开发更容易，很多…</h3></div><div class="nf l"><p class="bd b gc z el nc eo ep nd er et ek translated">hackernoon.com</p></div></div><div class="ng l"><div class="nm l ni nj nk ng nl ja mx"/></div></div></a></div><div class="mu mv fm fo mw mx"><a href="https://hackernoon.com/understanding-javascript-the-this-keyword-4de325d77f68" rel="noopener  ugc nofollow" target="_blank"><div class="my ab ej"><div class="mz ab na cl cj nb"><h2 class="bd hv fv z el nc eo ep nd er et ht dt translated">理解JavaScript:这个关键字</h2><div class="ne l"><h3 class="bd b fv z el nc eo ep nd er et ek translated">由于数量惊人的库、工具和各种各样的东西使你的开发更容易，很多…</h3></div><div class="nf l"><p class="bd b gc z el nc eo ep nd er et ek translated">hackernoon.com</p></div></div><div class="ng l"><div class="nn l ni nj nk ng nl ja mx"/></div></div></a></div><div class="mu mv fm fo mw mx"><a href="https://hackernoon.com/understanding-javascript-new-keyword-ec67c8caaa74" rel="noopener  ugc nofollow" target="_blank"><div class="my ab ej"><div class="mz ab na cl cj nb"><h2 class="bd hv fv z el nc eo ep nd er et ht dt translated">理解JavaScript:新关键字</h2><div class="ne l"><h3 class="bd b fv z el nc eo ep nd er et ek translated">由于数量惊人的库、工具和各种各样的东西使你的开发更容易，很多…</h3></div><div class="nf l"><p class="bd b gc z el nc eo ep nd er et ek translated">hackernoon.com</p></div></div><div class="ng l"><div class="no l ni nj nk ng nl ja mx"/></div></div></a></div><div class="mu mv fm fo mw mx"><a href="https://hackernoon.com/understanding-js-coercion-ff5684475bfc" rel="noopener  ugc nofollow" target="_blank"><div class="my ab ej"><div class="mz ab na cl cj nb"><h2 class="bd hv fv z el nc eo ep nd er et ht dt translated">理解JS:强制</h2><div class="ne l"><h3 class="bd b fv z el nc eo ep nd er et ek translated">由于数量惊人的库、工具和各种各样的东西使你的开发更容易，很多…</h3></div><div class="nf l"><p class="bd b gc z el nc eo ep nd er et ek translated">hackernoon.com</p></div></div><div class="ng l"><div class="np l ni nj nk ng nl ja mx"/></div></div></a></div><div class="mu mv fm fo mw mx"><a href="https://hackernoon.com/understanding-js-the-event-loop-959beae3ac40" rel="noopener  ugc nofollow" target="_blank"><div class="my ab ej"><div class="mz ab na cl cj nb"><h2 class="bd hv fv z el nc eo ep nd er et ht dt translated">理解JS:事件循环</h2><div class="ne l"><h3 class="bd b fv z el nc eo ep nd er et ek translated">由于数量惊人的库、工具和各种各样的东西使你的开发更容易，很多…</h3></div><div class="nf l"><p class="bd b gc z el nc eo ep nd er et ek translated">hackernoon.com</p></div></div><div class="ng l"><div class="nq l ni nj nk ng nl ja mx"/></div></div></a></div></div></div>    
</body>
</html>