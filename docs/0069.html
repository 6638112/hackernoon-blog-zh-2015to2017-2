<html>
<head>
<title>Writing a Blog Engine in Phoenix and Elixir: Part 2, Authorization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Phoenix和Elixir编写博客引擎:第2部分，授权</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/writing-a-blog-engine-in-phoenix-part-2-authorization-814c06fa7c0?source=collection_archive---------0-----------------------#2015-10-07">https://medium.com/hackernoon/writing-a-blog-engine-in-phoenix-part-2-authorization-814c06fa7c0?source=collection_archive---------0-----------------------#2015-10-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/></div><div class="ab cl ir is hc it" role="separator"><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw"/></div><div class="hn ho hp hq hr"><p id="90ef" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">最后更新于:</strong>2016年7月21日</p><h2 id="29f9" class="jw jx hu bd jy jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq dt translated">本系列的前一篇文章</h2><div class="kr ks fm fo kt ku"><a rel="noopener follow" target="_blank" href="/@diamondgfx/introduction-fe138ac6079d"><div class="kv ab ej"><div class="kw ab kx cl cj ky"><h2 class="bd hv fv z el kz eo ep la er et ht dt translated">用Phoenix和Elixir编写博客引擎:第1部分</h2><div class="lb l"><h3 class="bd b fv z el kz eo ep la er et ek translated">最后更新时间:2016年7月20日</h3></div><div class="lc l"><p class="bd b gc z el kz eo ep la er et ek translated">medium.com</p></div></div></div></a></div><h2 id="5632" class="jw jx hu bd jy jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq dt translated">当前版本:</h2><p id="ccce" class="pw-post-body-paragraph iy iz hu ja b jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv hn dt translated">在撰写本文时，我们应用程序的当前版本是:</p><ul class=""><li id="6c3a" class="li lj hu ja b jb jc jf jg jj lk jn ll jr lm jv ln lo lp lq dt translated"><strong class="ja hv">仙丹</strong> : v1.3.1</li><li id="4a40" class="li lj hu ja b jb lr jf ls jj lt jn lu jr lv jv ln lo lp lq dt translated"><strong class="ja hv">凤凰:</strong> v1.2.0</li><li id="9475" class="li lj hu ja b jb lr jf ls jj lt jn lu jr lv jv ln lo lp lq dt translated"><strong class="ja hv"> Ecto: </strong> v2.0.2</li><li id="da34" class="li lj hu ja b jb lr jf ls jj lt jn lu jr lv jv ln lo lp lq dt translated"><strong class="ja hv">康美宁:</strong> v2.5.2</li></ul><p id="360a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果你正在读这篇文章，而这些不是最新的，请告诉我，我会相应地更新这篇教程。</p><h2 id="3054" class="jw jx hu bd jy jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq dt translated">修复一些错误</h2><p id="caf6" class="pw-post-body-paragraph iy iz hu ja b jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv hn dt translated">如果您一直在跟进，那么您应该有一个运行在Elixir/Phoenix中的(有点)功能性的博客引擎。如果你和我一样，这种东西会让你眼花缭乱，你迫不及待地想要更好的东西！</p><p id="86ff" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果你想检查你的进度，我已经把我们所有的工作放在网上了。</p><p id="f368" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">第一个很容易重现的错误是进入<a class="ae lw" href="http://localhost:4000/sessions/new" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/sessions/new</a>并点击submit。您应该会看到如下所示的错误消息:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="2bd3" class="jw jx hu mc b fv mg mh l mi mj">nil given for :username, comparison with nil is forbidden as it always evaluates to false. Pass a full query expression and use is_nil/1 instead.</span></pre><p id="c9a1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果我们看看<strong class="ja hv"> SessionController </strong>中的<strong class="ja hv"> create </strong>函数，这里发生了什么就很清楚了。</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="b53c" class="jw jx hu mc b fv mg mh l mi mj">def create(conn, %{"user" =&gt; user_params}) do<br/>  user = Repo.get_by(User, username: user_params["username"])<br/>  user<br/>  |&gt; sign_in(user_params["password"], conn)<br/>end</span></pre><p id="7f40" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">因此，如果我们发送的参数字符串包含一个空值(或没有值)的用户名，我们会遇到这个错误。让我们赶快解决这个问题；谢天谢地，这很容易用保护子句和模式匹配来解决。用以下内容替换当前的<strong class="ja hv">创建</strong>功能:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="5f5c" class="jw jx hu mc b fv mg mh l mi mj">def create(conn, %{"user" =&gt; %{"username" =&gt; username, "password" =&gt; password}})<br/>when not is_nil(username) and not is_nil(password) do<br/>  user = Repo.get_by(User, username: username)<br/>  sign_in(user, password, conn)<br/>end</span><span id="98da" class="jw jx hu mc b fv mk mh l mi mj">def create(conn, _) do<br/>  failed_login(conn)<br/>end</span></pre><p id="448b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们用下划线替换第二个<strong class="ja hv"> create </strong>函数中的params参数，因为我们不需要在任何地方使用它的结果。我们还添加了对这个<strong class="ja hv"> failed_login </strong>函数的引用，所以我们把它添加为私有函数。在<strong class="ja hv">web/controllers/session _ controller . ex</strong>中，修改顶部的Comeonin导入语句:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="6617" class="jw jx hu mc b fv mg mh l mi mj">import Comeonin.Bcrypt, only: [checkpw: 2, dummy_checkpw: 0]</span></pre><p id="0d92" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们需要调用dummy_checkpw()，这样某人就不能简单地迭代使用错误密码的用户名，并检查当用户名在我们的系统中不存在时，时间是否会改变。然后，我们添加我们的<strong class="ja hv"> failed_login </strong>函数:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="4988" class="jw jx hu mc b fv mg mh l mi mj">defp failed_login(conn) do<br/>  dummy_checkpw()<br/>  conn<br/>  |&gt; put_session(:current_user, nil)<br/>  |&gt; put_flash(:error, "Invalid username/password combination!")<br/>  |&gt; redirect(to: page_path(conn, :index))<br/>  |&gt; halt()<br/>end</span></pre><p id="a8e1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">同样，请注意对顶部的<strong class="ja hv"> dummy_checkpw() </strong>的调用！我们还清除了current_user会话，设置了一个flash消息，指示用户输入了无效的用户名/密码组合，并重定向回主索引和halt。此处停止的调用是针对双重渲染问题的明智之举。</p><p id="db4a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">然后，无论在哪里，只要我们有代码在做上面的任何工作，我们就可以用对新函数的调用来替换旧代码。</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="d074" class="jw jx hu mc b fv mg mh l mi mj">defp sign_in(user, _password, conn) when is_nil(user) do<br/>  failed_login(conn)<br/>end</span><span id="7bb3" class="jw jx hu mc b fv mk mh l mi mj">defp sign_in(user, password, conn) do<br/>  if checkpw(password, user.password_digest) do<br/>    conn<br/>    |&gt; put_session(:current_user, %{id: user.id, username: user.username})<br/>    |&gt; put_flash(:info, "Sign in successful!")<br/>    |&gt; redirect(to: page_path(conn, :index))<br/>  else<br/>    failed_login(conn)<br/>  end<br/>end</span></pre><p id="862c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这应该可以解决任何现有的登录错误，所以我们可以继续让我们的帖子与当前登录的用户相关联。</p><h2 id="e841" class="jw jx hu bd jy jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq dt translated">添加我们的迁移</h2><p id="b6d7" class="pw-post-body-paragraph iy iz hu ja b jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv hn dt translated">为了能够将帖子与用户相关联，我们需要做的第一件事是修改<strong class="ja hv">帖子</strong>表，以包含对<strong class="ja hv">用户</strong>表的引用。</p><p id="9a47" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">首先，我们将使用Ecto的迁移生成器来创建一个新的迁移。</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="e6cf" class="jw jx hu mc b fv mg mh l mi mj">$ mix ecto.gen.migration add_user_id_to_posts</span></pre><p id="f163" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们应该看到一些输出，让我们知道它成功地工作。</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="0a0a" class="jw jx hu mc b fv mg mh l mi mj">Compiling 1 file (.ex)<br/>* creating priv/repo/migrations<br/>* creating priv/repo/migrations/20160720211140_add_user_id_to_posts.exs</span></pre><p id="0847" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">但是，如果我们打开文件，那里还没有任何东西，所以我们将添加细节。</p><p id="fb44" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们将更改<strong class="ja hv">更改</strong>功能，以包含以下内容:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="d7eb" class="jw jx hu mc b fv mg mh l mi mj">def change do<br/>  alter table(:posts) do<br/>    add :user_id, references(:users)<br/>  end<br/>  create index(:posts, [:user_id])<br/>end</span></pre><p id="9488" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这将添加引用users表的user_id列。它还在posts表的user_id列上建立了一个索引。我们将运行<strong class="ja hv"> mix ecto.migrate </strong>并开始修改我们的模型。</p><h2 id="3dd8" class="jw jx hu bd jy jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq dt translated">将帖子与用户相关联</h2><p id="853e" class="pw-post-body-paragraph iy iz hu ja b jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv hn dt translated">让我们打开<strong class="ja hv"> web/models/post.ex </strong>并添加一个对<strong class="ja hv">用户</strong>模型的引用。</p><p id="8c15" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在“文章”模式下，添加以下内容:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="13ae" class="jw jx hu mc b fv mg mh l mi mj">belongs_to :user, Pxblog.User</span></pre><p id="2f4f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们将为<strong class="ja hv">用户</strong>模型添加一个反向关系，指向<strong class="ja hv">发布</strong>模型。在<strong class="ja hv"> web/models/user.ex </strong>中的“用户”模式下，添加以下内容:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="acee" class="jw jx hu mc b fv mg mh l mi mj">has_many :posts, Pxblog.Post</span></pre><p id="6f47" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们还需要打开<strong class="ja hv">帖子</strong>控制器，并将我们的帖子与用户相关联。</p><h2 id="6a16" class="jw jx hu bd jy jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq dt translated">修改我们的路线</h2><p id="71a3" class="pw-post-body-paragraph iy iz hu ja b jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv hn dt translated">首先，我们将更新路由器以指向用户下方的帖子。打开<strong class="ja hv"> web/router.ex </strong>，我们将稍微改变一下路线。</p><p id="8339" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们将稍微更改“/用户”和“/帖子”路径。删除这两个并替换为这个块:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="17c2" class="jw jx hu mc b fv mg mh l mi mj">resources "/users", UserController do<br/>  resources "/posts", PostController<br/>end</span></pre><h2 id="1f09" class="jw jx hu bd jy jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq dt translated">修理我们的控制器</h2><p id="8bf9" class="pw-post-body-paragraph iy iz hu ja b jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv hn dt translated">如果我们现在尝试运行<strong class="ja hv"> mix phoenix.routes </strong>，我们会得到一个错误。不过，没关系！由于我们改变了路由结构，我们失去了<strong class="ja hv"> post_path </strong>助手，取而代之的是嵌套资源版本的<strong class="ja hv"> user_post_path </strong>。嵌套的助手允许我们访问代表需要另一个资源存在的资源的路由(比如用户下面的帖子)。</p><p id="4388" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">因此，如果我们有一个常规的<strong class="ja hv"> post_path </strong>助手，我们这样调用它:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="1484" class="jw jx hu mc b fv mg mh l mi mj">post_path(conn, :show, post)</span></pre><p id="fb4b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv"> conn </strong>是我们的连接对象，<strong class="ja hv"> :show </strong>是我们链接到的动作，第三个参数可以是对象的模型或id。我们还可以做:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="c84b" class="jw jx hu mc b fv mg mh l mi mj">post_path(conn, :show, 1)</span></pre><p id="1dca" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">然而，当我们有一个嵌套的资源时，助手必须随着我们的routes文件的修改而改变。鉴于帖子现在嵌套在用户下，我们的路线也发生了变化:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="3fe7" class="jw jx hu mc b fv mg mh l mi mj">user_post_path(conn, :show, user, post)</span></pre><p id="a774" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">请注意，第三个参数更改为嵌套资源的顶层，每个附加的资源按顺序出现。鉴于我们对这一点的新理解，很清楚这是在哪里给我们抛出了错误，所以我们要清理这一点。我们希望向被请求的用户公开我们所有的控制器操作。对我们来说最好的方法是通过一个插件，所以我们将打开<strong class="ja hv">web/controllers/post _ controller . ex</strong>:</p><p id="bd6b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在顶部，我们将添加一个新的插件调用。</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="1a79" class="jw jx hu mc b fv mg mh l mi mj">plug :assign_user</span></pre><p id="aa1b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">然后在底部，我们将编写我们的assign_user插件:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="80e2" class="jw jx hu mc b fv mg mh l mi mj">defp assign_user(conn, _opts) do<br/>  case conn.params do<br/>    %{"user_id" =&gt; user_id} -&gt;<br/>      user = Repo.get(Pxblog.User, user_id)<br/>      assign(conn, :user, user)<br/>    _ -&gt;<br/>      conn<br/>  end<br/>end</span></pre><p id="5be8" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">然后在<strong class="ja hv"> post_path </strong>出现的任何地方，我们都将它替换为<strong class="ja hv"> user_post_path </strong>:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="1126" class="jw jx hu mc b fv mg mh l mi mj">def create(conn, %{"post" =&gt; post_params}) do<br/> changeset = Post.changeset(%Post{}, post_params)</span><span id="42f7" class="jw jx hu mc b fv mk mh l mi mj">  case Repo.insert(changeset) do<br/>    {:ok, _post} -&gt;<br/>      conn<br/>      |&gt; put_flash(:info, "Post created successfully.")<br/>      |&gt; redirect(to: user_post_path(conn, :index, conn.assigns[:user]))<br/>    {:error, changeset} -&gt;<br/>      render(conn, "new.html", changeset: changeset)<br/>  end<br/>end</span><span id="722a" class="jw jx hu mc b fv mk mh l mi mj">def update(conn, %{"id" =&gt; id, "post" =&gt; post_params}) do<br/>  post = Repo.get!(Post, id)<br/>  changeset = Post.changeset(post, post_params)</span><span id="9c78" class="jw jx hu mc b fv mk mh l mi mj">  case Repo.update(changeset) do<br/>    {:ok, post} -&gt;<br/>      conn<br/>      |&gt; put_flash(:info, "Post updated successfully.")<br/>      |&gt; redirect(to: user_post_path(conn, :show, conn.assigns[:user], post))<br/>    {:error, changeset} -&gt;<br/>      render(conn, "edit.html", post: post, changeset: changeset)<br/>  end<br/>end</span><span id="2af8" class="jw jx hu mc b fv mk mh l mi mj">def delete(conn, %{"id" =&gt; id}) do<br/>  post = Repo.get!(Post, id)</span><span id="719c" class="jw jx hu mc b fv mk mh l mi mj">  # Here we use delete! (with a bang) because we expect<br/>  # it to always work (and if it does not, it will raise).<br/>  Repo.delete!(post)</span><span id="84da" class="jw jx hu mc b fv mk mh l mi mj">  conn<br/>  |&gt; put_flash(:info, "Post deleted successfully.")<br/>  |&gt; redirect(to: user_post_path(conn, :index, conn.assigns[:user]))<br/>end</span></pre><h2 id="952e" class="jw jx hu bd jy jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq dt translated">修复我们的模板</h2><p id="f8e9" class="pw-post-body-paragraph iy iz hu ja b jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv hn dt translated">我们的控制器不再抛出错误信息，所以现在我们将在模板上工作。我们走了一条捷径，实现了一个影响我们所有控制器动作的插件。通过在我们的连接对象上使用<strong class="ja hv">赋值</strong>函数，我们已经暴露了一个可以在模板中使用的变量。我们将不得不修改相当多的模板，因为无论我们在哪里使用link helper和我们的<strong class="ja hv"> post_path </strong> helper，我们都需要将它更新为user_post_path，并确保动作之后的第一个参数是用户的id。</p><p id="d328" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">web/templates/post/index . html . eex</strong>:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="efaa" class="jw jx hu mc b fv mg mh l mi mj">&lt;h2&gt;Listing posts&lt;/h2&gt;</span><span id="d43a" class="jw jx hu mc b fv mk mh l mi mj">&lt;table class="table"&gt;<br/>  &lt;thead&gt;<br/>    &lt;tr&gt;<br/>      &lt;th&gt;Title&lt;/th&gt;<br/>      &lt;th&gt;Body&lt;/th&gt;</span><span id="bbf5" class="jw jx hu mc b fv mk mh l mi mj">&lt;th&gt;&lt;/th&gt;<br/>    &lt;/tr&gt;<br/>  &lt;/thead&gt;<br/>  &lt;tbody&gt;<br/>&lt;%= for post &lt;- @posts do %&gt;<br/>    &lt;tr&gt;<br/>      &lt;td&gt;&lt;%= post.title %&gt;&lt;/td&gt;<br/>      &lt;td&gt;&lt;%= post.body %&gt;&lt;/td&gt;</span><span id="dc9b" class="jw jx hu mc b fv mk mh l mi mj">&lt;td class="text-right"&gt;<br/>        &lt;%= link "Show", to: user_post_path(@conn, :show, @user, post), class: "btn btn-default btn-xs" %&gt;<br/>        &lt;%= link "Edit", to: user_post_path(@conn, :edit, @user, post), class: "btn btn-default btn-xs" %&gt;<br/>        &lt;%= link "Delete", to: user_post_path(@conn, :delete, @user, post), method: :delete, data: [confirm: "Are you sure?"], class: "btn btn-danger btn-xs" %&gt;<br/>      &lt;/td&gt;<br/>    &lt;/tr&gt;<br/>&lt;% end %&gt;<br/>  &lt;/tbody&gt;<br/>&lt;/table&gt;</span><span id="892e" class="jw jx hu mc b fv mk mh l mi mj">&lt;%= link "New post", to: user_post_path(@conn, :new, @user) %&gt;</span></pre><p id="b123" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">web/templates/post/show . html . eex</strong>:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="f0f9" class="jw jx hu mc b fv mg mh l mi mj">&lt;h2&gt;Show post&lt;/h2&gt;</span><span id="9741" class="jw jx hu mc b fv mk mh l mi mj">&lt;ul&gt;</span><span id="3019" class="jw jx hu mc b fv mk mh l mi mj">  &lt;li&gt;<br/>    &lt;strong&gt;Title:&lt;/strong&gt;<br/>    &lt;%= @post.title %&gt;<br/>  &lt;/li&gt;</span><span id="aa5b" class="jw jx hu mc b fv mk mh l mi mj">  &lt;li&gt;<br/>    &lt;strong&gt;Body:&lt;/strong&gt;<br/>    &lt;%= @post.body %&gt;<br/>  &lt;/li&gt;</span><span id="2256" class="jw jx hu mc b fv mk mh l mi mj">&lt;/ul&gt;</span><span id="2d64" class="jw jx hu mc b fv mk mh l mi mj">&lt;%= link "Edit", to: user_post_path(@conn, :edit, @user, @post) %&gt;<br/>&lt;%= link "Back", to: user_post_path(@conn, :index, @user) %&gt;</span></pre><p id="d1b9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">web/templates/post/new . html . eex</strong>:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="f5c8" class="jw jx hu mc b fv mg mh l mi mj">&lt;h2&gt;New post&lt;/h2&gt;</span><span id="e269" class="jw jx hu mc b fv mk mh l mi mj">&lt;%= render "form.html", changeset: @changeset,<br/>                        action: user_post_path(@conn, :create, @user) %&gt;</span><span id="5209" class="jw jx hu mc b fv mk mh l mi mj">&lt;%= link "Back", to: user_post_path(@conn, :index, @user) %&gt;</span></pre><p id="cc10" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">web/templates/post/edit . html . eex</strong>:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="527e" class="jw jx hu mc b fv mg mh l mi mj">&lt;h2&gt;Edit post&lt;/h2&gt;</span><span id="adba" class="jw jx hu mc b fv mk mh l mi mj">&lt;%= render "form.html", changeset: @changeset,<br/>                        action: user_post_path(@conn, :update, @user, @post) %&gt;</span><span id="987d" class="jw jx hu mc b fv mk mh l mi mj">&lt;%= link "Back", to: user_post_path(@conn, :index, @user) %&gt;</span></pre><p id="1e48" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，作为健全性检查，如果我们运行<strong class="ja hv"> mix phoenix.routes </strong>，我们应该会看到输出和成功的编译！</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="c9a2" class="jw jx hu mc b fv mg mh l mi mj">Compiling 14 files (.ex)<br/>     page_path  GET     /                               Pxblog.PageController :index<br/>     user_path  GET     /users                          Pxblog.UserController :index<br/>     user_path  GET     /users/:id/edit                 Pxblog.UserController :edit<br/>     user_path  GET     /users/new                      Pxblog.UserController :new<br/>     user_path  GET     /users/:id                      Pxblog.UserController :show<br/>     user_path  POST    /users                          Pxblog.UserController :create<br/>     user_path  PATCH   /users/:id                      Pxblog.UserController :update<br/>                PUT     /users/:id                      Pxblog.UserController :update<br/>     user_path  DELETE  /users/:id                      Pxblog.UserController :delete<br/>user_post_path  GET     /users/:user_id/posts           Pxblog.PostController :index<br/>user_post_path  GET     /users/:user_id/posts/:id/edit  Pxblog.PostController :edit<br/>user_post_path  GET     /users/:user_id/posts/new       Pxblog.PostController :new<br/>user_post_path  GET     /users/:user_id/posts/:id       Pxblog.PostController :show<br/>user_post_path  POST    /users/:user_id/posts           Pxblog.PostController :create<br/>user_post_path  PATCH   /users/:user_id/posts/:id       Pxblog.PostController :update<br/>                PUT     /users/:user_id/posts/:id       Pxblog.PostController :update<br/>user_post_path  DELETE  /users/:user_id/posts/:id       Pxblog.PostController :delete<br/>  session_path  GET     /sessions/new                   Pxblog.SessionController :new<br/>  session_path  POST    /sessions                       Pxblog.SessionController :create<br/>  session_path  DELETE  /sessions/:id                   Pxblog.SessionController :delete</span></pre><h2 id="f7ef" class="jw jx hu bd jy jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq dt translated">在控制器里把它们连接起来</h2><p id="6098" class="pw-post-body-paragraph iy iz hu ja b jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv hn dt translated">现在，我们需要做的就是完成控制器的连接，以使用新的关联。首先，我们将启动iex -S mix ,这样我们就可以了解一点如何获取用户的帖子。不过，在我们这样做之前，设置一个标准导入/别名列表会对我们有一点帮助，每次我们在项目中加载iex提示符时，都会加载这个列表。在项目根目录下创建一个名为<strong class="ja hv"> .iex.exs </strong>的新文件(注意文件名开头的句点)，并用以下内容填充它:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="716b" class="jw jx hu mc b fv mg mh l mi mj">import Ecto.Query<br/>alias Pxblog.User<br/>alias Pxblog.Post<br/>alias Pxblog.Repo<br/>import Ecto</span></pre><p id="5586" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，当iex启动时，我们不必每次都做类似下面这样的事情:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="7e27" class="jw jx hu mc b fv mg mh l mi mj">iex(1)&gt; import Ecto.Query<br/>nil<br/>iex(2)&gt; alias Pxblog.User<br/>nil<br/>iex(3)&gt; alias Pxblog.Post<br/>nil<br/>iex(4)&gt; alias Pxblog.Repo<br/>nil<br/>iex(5)&gt; import Ecto<br/>nil</span></pre><p id="f648" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">继续，运行<strong class="ja hv"> iex -S mix: </strong>我们的回购中至少应该有一个用户。如果没有，请先创建一个。然后我们会跑:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="ec11" class="jw jx hu mc b fv mg mh l mi mj">iex(8)&gt; user = Repo.get(User, 1)<br/>    [debug] SELECT u0."id", u0."username", u0."email", u0."password_digest", u0."inserted_at", u0."updated_at" FROM "users" AS u0 WHERE (u0."id" = $1) [1] OK query=8.2ms<br/>    %Pxblog.User{__meta__: #Ecto.Schema.Metadata&lt;:loaded&gt;, email: "test", id: 1,<br/>     inserted_at: #Ecto.DateTime&lt;2015-10-06T17:47:07Z&gt;, password: nil,<br/>     password_confirmation: nil,<br/>     password_digest: "$2b$12$pV/XBBCRl0RQhadQd9Y4mevOy5y0j4bCC/LjGgx7VJMosRdwme22a",<br/>     posts: #Ecto.Association.NotLoaded&lt;association :posts is not loaded&gt;,<br/>     updated_at: #Ecto.DateTime&lt;2015-10-06T17:47:07Z&gt;, username: "test"} </span><span id="e380" class="jw jx hu mc b fv mk mh l mi mj">iex(10)&gt; Repo.all(assoc(user, :posts))<br/>    [debug] SELECT p0."id", p0."title", p0."body", p0."user_id", p0."inserted_at", p0."updated_at" FROM "posts" AS p0 WHERE (p0."user_id" IN ($1)) [1] OK query=3.5ms<br/>    []</span></pre><p id="9f7d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们还没有创建任何与用户相关的帖子，所以我们在那里得到一个空白列表是有意义的。我们使用来自<strong class="ja hv"> Ecto </strong>的<strong class="ja hv"> assoc </strong>函数来给出一个将帖子链接到用户的查询。我们还可以做以下事情:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="f6a7" class="jw jx hu mc b fv mg mh l mi mj">iex(14)&gt; Repo.all from p in Post,<br/>...(14)&gt;          join: u in assoc(p, :user),<br/>...(14)&gt;          select: p<br/>[debug] SELECT p0."id", p0."title", p0."body", p0."user_id", p0."inserted_at", p0."updated_at" FROM "posts" AS p0 INNER JOIN "users" AS u1 ON u1."id" = p0."user_id" [] OK query=0.9ms</span></pre><p id="1810" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这将为我们提供一个带有内部连接的查询，而不是用户id上的直接where子句。请特别注意这两种情况下生成的查询；在使用生成查询的代码时，理解后台生成的SQL非常方便。</p><p id="fabb" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们还可以在获取帖子时使用<strong class="ja hv"> preload </strong>函数来预载用户，如下所示:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="2b66" class="jw jx hu mc b fv mg mh l mi mj">iex(18)&gt; Repo.all(from u in User, preload: [:posts])<br/>[debug] SELECT u0."id", u0."username", u0."email", u0."password_digest", u0."inserted_at", u0."updated_at" FROM "users" AS u0 [] OK query=0.9ms<br/>[debug] SELECT p0."id", p0."title", p0."body", p0."user_id", p0."inserted_at", p0."updated_at" FROM "posts" AS p0 WHERE (p0."user_id" IN ($1)) ORDER BY p0."user_id" [1] OK query=0.8ms</span><span id="3161" class="jw jx hu mc b fv mk mh l mi mj">iex(20)&gt; Repo.all(from p in Post, preload: [:user])<br/>[debug] SELECT p0."id", p0."title", p0."body", p0."user_id", p0."inserted_at", p0."updated_at" FROM "posts" AS p0 [] OK query=0.8ms<br/>[]</span></pre><p id="cecf" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们需要自己处理这些查询，所以我们将使用<strong class="ja hv"> Ecto的build_assoc </strong>函数。<strong class="ja hv"> build_assoc </strong>将我们想要添加关联的模型作为第一个参数，将我们想要挂钩的关联作为原子作为第二个参数，将参数作为第三个参数。</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="82e2" class="jw jx hu mc b fv mg mh l mi mj">iex(1)&gt; user = Repo.get(User, 1)<br/>iex(2)&gt; post = build_assoc(user, :posts, %{title: "Test Title", body: "Test Body"})<br/>iex(3)&gt; Repo.insert(post)<br/>iex(4)&gt; posts = Repo.all(from p in Post, preload: [:user])</span></pre><p id="4201" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在最后一个命令中，我们应该得到以下输出:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="c670" class="jw jx hu mc b fv mg mh l mi mj">iex(4)&gt; posts = Repo.all(from p in Post, preload: [:user])<br/>[debug] SELECT p0."id", p0."title", p0."body", p0."user_id", p0."inserted_at", p0."updated_at" FROM "posts" AS p0 [] OK query=0.7ms<br/>[debug] SELECT u0."id", u0."username", u0."email", u0."password_digest", u0."inserted_at", u0."updated_at" FROM "users" AS u0 WHERE (u0."id" IN ($1)) [1] OK query=0.7ms<br/>[%Pxblog.Post{__meta__: #Ecto.Schema.Metadata&lt;:loaded&gt;, body: "Test Body",<br/>  id: 1, inserted_at: #Ecto.DateTime&lt;2015-10-06T18:06:20Z&gt;, title: "Test Title",<br/>  updated_at: #Ecto.DateTime&lt;2015-10-06T18:06:20Z&gt;,<br/>  user: %Pxblog.User{__meta__: #Ecto.Schema.Metadata&lt;:loaded&gt;, email: "test",<br/>   id: 1, inserted_at: #Ecto.DateTime&lt;2015-10-06T17:47:07Z&gt;, password: nil,<br/>   password_confirmation: nil,<br/>   password_digest: "$2b$12$pV/XBBCRl0RQhadQd9Y4mevOy5y0j4bCC/LjGgx7VJMosRdwme22a",<br/>   posts: #Ecto.Association.NotLoaded&lt;association :posts is not loaded&gt;,<br/>   updated_at: #Ecto.DateTime&lt;2015-10-06T17:47:07Z&gt;, username: "test"},<br/>  user_id: 1}]</span></pre><p id="f647" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们将快速检查第一个结果:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="fc44" class="jw jx hu mc b fv mg mh l mi mj">iex(5)&gt; post = List.first posts<br/>%Pxblog.Post{__meta__: #Ecto.Schema.Metadata&lt;:loaded&gt;, body: "Test Body", id: 1,<br/> inserted_at: #Ecto.DateTime&lt;2015-10-06T18:06:20Z&gt;, title: "Test Title",<br/> updated_at: #Ecto.DateTime&lt;2015-10-06T18:06:20Z&gt;,<br/> user: %Pxblog.User{__meta__: #Ecto.Schema.Metadata&lt;:loaded&gt;, email: "test",<br/>  id: 1, inserted_at: #Ecto.DateTime&lt;2015-10-06T17:47:07Z&gt;, password: nil,<br/>  password_confirmation: nil,<br/>  password_digest: "$2b$12$pV/XBBCRl0RQhadQd9Y4mevOy5y0j4bCC/LjGgx7VJMosRdwme22a",<br/>  posts: #Ecto.Association.NotLoaded&lt;association :posts is not loaded&gt;,<br/>  updated_at: #Ecto.DateTime&lt;2015-10-06T17:47:07Z&gt;, username: "test"},<br/> user_id: 1}</span><span id="513b" class="jw jx hu mc b fv mk mh l mi mj">iex(6)&gt; post.title<br/>"Test Title"<br/>iex(7)&gt; post.user.username<br/>"test"</span></pre><p id="e5c2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">酷！我们的实验正在做我们期望的事情，所以让我们回到我们的控制器(<strong class="ja hv">web/controllers/post _ controller . ex)</strong>并开始修复代码。对于索引action，我们需要与一个用户相关联的所有帖子，所以让我们修复代码。我们将从索引操作开始:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="3ed4" class="jw jx hu mc b fv mg mh l mi mj">def index(conn, _params) do<br/>  posts = Repo.all(assoc(conn.assigns[:user], :posts))<br/>  render(conn, "index.html", posts: posts)<br/>end</span></pre><p id="364f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">然后，我们可以访问用户1 的<a class="ae lw" href="http://localhost:4000/users/1/posts" rel="noopener ugc nofollow" target="_blank">帖子索引，并看到一个帖子列表！但是，如果我们试图访问一个不存在的用户的post索引，我们会得到一个错误消息，这不是一个很好的用户体验，所以让我们清理我们的assign user插件。</a></p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="bacd" class="jw jx hu mc b fv mg mh l mi mj">defp assign_user(conn, _opts) do<br/>  case conn.params do<br/>    %{"user_id" =&gt; user_id} -&gt;<br/>      case Repo.get(Pxblog.User, user_id) do<br/>        nil  -&gt; invalid_user(conn)<br/>        user -&gt; assign(conn, :user, user)<br/>      end<br/>    _ -&gt; invalid_user(conn)<br/>  end<br/>end<br/><br/>defp invalid_user(conn) do<br/>  conn<br/>  |&gt; put_flash(:error, "Invalid user!")<br/>  |&gt; redirect(to: page_path(conn, :index))<br/>  |&gt; halt<br/>end</span></pre><p id="6106" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，当我们访问一个不存在的用户的帖子索引时，我们会得到一条很好的flash消息，并被友好地重定向回页面路径！接下来，我们需要改变我们的新行动:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="87f8" class="jw jx hu mc b fv mg mh l mi mj">def new(conn, _params) do<br/>  changeset =<br/>    conn.assigns[:user]<br/>    |&gt; build_assoc(:posts)<br/>    |&gt; Post.changeset()<br/>  render(conn, "new.html", changeset: changeset)<br/>end</span></pre><p id="5741" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们使用我们的<strong class="ja hv">用户</strong>模型，将其通过管道传输到Ecto的build_assoc函数，告诉它我们需要构建一个post，然后将得到的空白模型通过管道传输到Post.changeset函数，以获得一个空白的变更集。对于create方法，我们将遵循相同的模式(除了我们的post_params保持不变):</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="6956" class="jw jx hu mc b fv mg mh l mi mj">def create(conn, %{"post" =&gt; post_params}) do<br/>  changeset =<br/>    conn.assigns[:user]<br/>    |&gt; build_assoc(:posts)<br/>    |&gt; Post.changeset(post_params)</span><span id="4ec1" class="jw jx hu mc b fv mk mh l mi mj">  case Repo.insert(changeset) do<br/>    {:ok, _post} -&gt;<br/>      conn<br/>      |&gt; put_flash(:info, "Post created successfully.")<br/>      |&gt; redirect(to: user_post_path(conn, :index, conn.assigns[:user]))<br/>    {:error, changeset} -&gt;<br/>      render(conn, "new.html", changeset: changeset)<br/>  end<br/>end</span></pre><p id="def4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">然后修改我们的显示、编辑、更新和删除操作:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="e83f" class="jw jx hu mc b fv mg mh l mi mj">def show(conn, %{"id" =&gt; id}) do<br/>  post = Repo.get!(assoc(conn.assigns[:user], :posts), id)<br/>  render(conn, "show.html", post: post)<br/>end</span><span id="b347" class="jw jx hu mc b fv mk mh l mi mj">def edit(conn, %{"id" =&gt; id}) do<br/>  post = Repo.get!(assoc(conn.assigns[:user], :posts), id)<br/>  changeset = Post.changeset(post)<br/>  render(conn, "edit.html", post: post, changeset: changeset)<br/>end</span><span id="882c" class="jw jx hu mc b fv mk mh l mi mj">def update(conn, %{"id" =&gt; id, "post" =&gt; post_params}) do<br/>  post = Repo.get!(assoc(conn.assigns[:user], :posts), id)<br/>  changeset = Post.changeset(post, post_params)</span><span id="bc3a" class="jw jx hu mc b fv mk mh l mi mj">  case Repo.update(changeset) do<br/>    {:ok, post} -&gt;<br/>      conn<br/>      |&gt; put_flash(:info, "Post updated successfully.")<br/>      |&gt; redirect(to: user_post_path(conn, :show, conn.assigns[:user], post))<br/>    {:error, changeset} -&gt;<br/>      render(conn, "edit.html", post: post, changeset: changeset)<br/>  end<br/>end</span><span id="e262" class="jw jx hu mc b fv mk mh l mi mj">def delete(conn, %{"id" =&gt; id}) do<br/>  post = Repo.get!(assoc(conn.assigns[:user], :posts), id)</span><span id="45e4" class="jw jx hu mc b fv mk mh l mi mj">  # Here we use delete! (with a bang) because we expect<br/>  # it to always work (and if it does not, it will raise).<br/>  Repo.delete!(post)</span><span id="9e40" class="jw jx hu mc b fv mk mh l mi mj">  conn<br/>  |&gt; put_flash(:info, "Post deleted successfully.")<br/>  |&gt; redirect(to: user_post_path(conn, :index, conn.assigns[:user]))<br/>end</span></pre><p id="88d6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">当我们全部测试完毕后，我们应该会看到一切正常！除了…任何用户都可以删除/编辑/创建他们想要的任何用户id下的新帖子！</p><h2 id="8fd9" class="jw jx hu bd jy jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq dt translated">限制向用户发布</h2><p id="4ae3" class="pw-post-body-paragraph iy iz hu ja b jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv hn dt translated">我们不能发布一个有这样安全漏洞的博客引擎，不是吗？让我们通过添加另一个插件来修复它，确保当前用户与获取的用户相同。</p><p id="671d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在底部，我们将为<strong class="ja hv">web/controllers/post _ controller . ex</strong>添加一个新函数:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="5110" class="jw jx hu mc b fv mg mh l mi mj">defp authorize_user(conn, _opts) do<br/>    user = get_session(conn, :current_user)<br/>    if user &amp;&amp; Integer.to_string(user.id) == conn.params["user_id"] do<br/>      conn<br/>    else<br/>      conn<br/>      |&gt; put_flash(:error, "You are not authorized to modify that post!")<br/>      |&gt; redirect(to: page_path(conn, :index))<br/>      |&gt; halt()<br/>    end<br/>  end</span></pre><p id="513e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在顶部，我们将添加插件调用:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="f2f1" class="jw jx hu mc b fv mg mh l mi mj">plug :authorize_user when action in [:new, :create, :update, :edit, :delete]</span></pre><p id="5fe7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在一切都应该正常工作了！用户必须登录才能发帖，而且只能乱翻自己的帖子。我们所需要的是更新我们的测试套件来处理这些变化，我们应该一切就绪。让我们从运行<strong class="ja hv">混合测试</strong>开始，找出我们所处的位置。您很可能会看到如下所示的错误消息:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="a217" class="jw jx hu mc b fv mg mh l mi mj">** (CompileError) test/controllers/post_controller_test.exs:14: function post_path/2 undefined<br/>    (stdlib) lists.erl:1337: :lists.foreach/2<br/>    (stdlib) erl_eval.erl:669: :erl_eval.do_apply/6<br/>    (elixir) lib/code.ex:363: Code.require_file/2<br/>    (elixir) lib/kernel/parallel_require.ex:50: anonymous fn/4 in Kernel.ParallelRequire.spawn_requires/5</span></pre><p id="50b2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">不幸的是，我们不得不再次将<strong class="ja hv"> post_path </strong>的每个实例修改为<strong class="ja hv"> user_post_path </strong>。为了做到这一点，我们需要彻底改变我们的测试。我们将从添加一个设置块到<strong class="ja hv">test/controllers/post _ controller _ text . exs</strong>开始:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="5a6c" class="jw jx hu mc b fv mg mh l mi mj">alias Pxblog.User</span><span id="8514" class="jw jx hu mc b fv mk mh l mi mj">setup do<br/>  {:ok, user} = create_user<br/>  conn = build_conn()<br/>  |&gt; login_user(user)<br/>  {:ok, conn: conn, user: user}<br/>end</span><span id="92ba" class="jw jx hu mc b fv mk mh l mi mj">defp create_user do<br/>  User.changeset(%User{}, %{email: "test@test.com", username: "test", password: "test", password_confirmation: "test"})<br/>  |&gt; Repo.insert<br/>end</span><span id="1375" class="jw jx hu mc b fv mk mh l mi mj">defp login_user(conn, user) do<br/>  post conn, session_path(conn, :create), user: %{username: user.username, password: user.password}<br/>end</span></pre><p id="bcca" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这里已经发生了很多事情。我们做的第一件事是添加一个对我们需要编写的<strong class="ja hv"> create_user </strong>函数的调用。我们需要一些测试助手，所以我们将添加一些函数来处理这些。我们的<strong class="ja hv"> create_user </strong>函数只是将一个样本用户插入到我们的Repo中，所以这就是为什么我们要从那个函数调用中进行模式匹配<strong class="ja hv"> {:ok，user} </strong>。</p><p id="c5d5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">接下来，我们有一个<strong class="ja hv"> conn = build_conn() </strong>调用，您之前已经见过了。然后，我们将结果连接到这个<strong class="ja hv"> login_user </strong>函数中。这个连接发布到我们的登录函数，因为我们所有的主要发布操作都需要一个登录的用户。这里非常重要的一点是:我们<strong class="ja hv">需要</strong>返回连接器，并在每次测试中随身携带。如果我们不这样做，用户将无法保持登录状态！</p><p id="b9e4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">最后，我们修改了该函数的返回，以返回相同的标准:ok和:conn值，但是现在我们还包含了一个:用户进入dict。</p><p id="6e65" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们来看看我们必须修改的第一个测试:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="408a" class="jw jx hu mc b fv mg mh l mi mj">test "lists all entries on index", %{conn: conn, user: user} do<br/>  conn = get conn, user_post_path(conn, :index, user)<br/>  assert html_response(conn, 200) =~ "Listing posts"<br/>end</span></pre><p id="95ab" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">请注意，我们将“test”方法的第二个参数改为模式匹配到包含键<em class="ml">:连接</em>和<em class="ml">:用户</em>的映射，而不仅仅是<em class="ml">:连接</em>。这确保了我们公开了我们在设置块中使用的<em class="ml"> :user </em>键。除此之外，我们刚刚将<strong class="ja hv"> post_path </strong>助手调用更改为<strong class="ja hv"> user_post_path </strong>，并添加用户作为我们的第三个参数。立即显式运行此测试；您可以使用标记或通过运行以下命令指定行号来进行此测试:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="233b" class="jw jx hu mc b fv mg mh l mi mj">$ mix test test/controller/post_controller_test.exs:[line number]</span></pre><p id="6e87" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们的测试现在应该是绿色的！太好了！但是让我们继续修改这些:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="71b3" class="jw jx hu mc b fv mg mh l mi mj">test "renders form for new resources", %{conn: conn, user: user} do<br/>  conn = get conn, user_post_path(conn, :new, user)<br/>  assert html_response(conn, 200) =~ "New post"<br/>end</span></pre><p id="eb52" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">除了对设置处理程序和用户发布路径的更改之外，这里没有什么新的东西，所以我们将继续。</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="a883" class="jw jx hu mc b fv mg mh l mi mj">test "creates resource and redirects when data is valid", %{conn: conn, user: user} do<br/>  conn = post conn, user_post_path(conn, :create, user), post: @valid_attrs<br/>  assert redirected_to(conn) == user_post_path(conn, :index, user)<br/>  assert Repo.get_by(assoc(user, :posts), @valid_attrs)<br/>end</span></pre><p id="7b07" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">请记住，我们必须通过用户的关联来获取每个帖子，所以我们希望确保我们在这里这样做，并更改所有的<strong class="ja hv"> post_path </strong>调用。</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="f55d" class="jw jx hu mc b fv mg mh l mi mj">test "does not create resource and renders errors when data is invalid", %{conn: conn, user: user} do<br/>  conn = post conn, user_post_path(conn, :create, user), post: @invalid_attrs<br/>  assert html_response(conn, 200) =~ "New post"<br/>end</span></pre><p id="443c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">另一个容易修改的测试，所以我们将转移到下一个更有趣的测试。请再次记住，我们必须在用户关联下构建/获取所有帖子，因此我们将修改我们的“显示所选资源”测试:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="fd48" class="jw jx hu mc b fv mg mh l mi mj">test "shows chosen resource", %{conn: conn, user: user} do<br/>  post = build_post(user)<br/>  conn = get conn, user_post_path(conn, :show, user, post)<br/>  assert html_response(conn, 200) =~ "Show post"<br/>end</span></pre><p id="de23" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">以前，我们将post设置为一个简单的Repo.insert！%Post{}。这对我们不再适用，因为我们需要通过适当的关联来构建它。由于这一行在剩余的测试中出现得相当频繁，我们将编写一个帮助器方法来简化这一过程。</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="4ab8" class="jw jx hu mc b fv mg mh l mi mj">defp build_post(user) do<br/>  changeset =<br/>    user<br/>    |&gt; build_assoc(:posts)<br/>    |&gt; Post.changeset(@valid_attrs)<br/>  Repo.insert!(changeset)<br/>end</span></pre><p id="a82c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这个方法在我们的用户关联下创建一个有效的post模型，然后将其插入到数据库中。<strong class="ja hv">注意，Repo.insert！不返回{:ok，model}，而是只返回模型！</strong></p><p id="a5e3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">回到我们正在修改的测试，其余的都是非常简单的。我将把剩下的测试贴在下面；你只会一遍又一遍地重复同样的修改，直到它们都被处理好。</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="ce3c" class="jw jx hu mc b fv mg mh l mi mj">test "renders page not found when id is nonexistent", %{conn: conn, user: user} do<br/>    assert_raise Ecto.NoResultsError, fn -&gt;<br/>      get conn, user_post_path(conn, :show, user, -1)<br/>    end<br/>  end</span><span id="82a4" class="jw jx hu mc b fv mk mh l mi mj">  test "renders form for editing chosen resource", %{conn: conn, user: user} do<br/>    post = build_post(user)<br/>    conn = get conn, user_post_path(conn, :edit, user, post)<br/>    assert html_response(conn, 200) =~ "Edit post"<br/>  end</span><span id="ffd1" class="jw jx hu mc b fv mk mh l mi mj">  test "updates chosen resource and redirects when data is valid", %{conn: conn, user: user} do<br/>    post = build_post(user)<br/>    conn = put conn, user_post_path(conn, :update, user, post), post: @valid_attrs<br/>    assert redirected_to(conn) == user_post_path(conn, :show, user, post)<br/>    assert Repo.get_by(Post, @valid_attrs)<br/>  end</span><span id="7c2c" class="jw jx hu mc b fv mk mh l mi mj">  test "does not update chosen resource and renders errors when data is invalid", %{conn: conn, user: user} do<br/>    post = build_post(user)<br/>    conn = put conn, user_post_path(conn, :update, user, post), post: %{"body" =&gt; nil}<br/>    assert html_response(conn, 200) =~ "Edit post"<br/>  end</span><span id="a948" class="jw jx hu mc b fv mk mh l mi mj">  test "deletes chosen resource", %{conn: conn, user: user} do<br/>    post = build_post(user)<br/>    conn = delete conn, user_post_path(conn, :delete, user, post)<br/>    assert redirected_to(conn) == user_post_path(conn, :index, user)<br/>    refute Repo.get(Post, post.id)<br/>  end</span></pre><p id="336b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">当你修改了所有的东西，你应该能够运行<strong class="ja hv">混合测试</strong>并且得到绿色测试！</p><p id="92b7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">最后，我们编写了一些新代码作为插件来处理用户查找和授权，并且我们已经很好地测试了正面情况，但是我们还应该为负面情况添加测试。我们将从一个测试开始，测试当我们试图访问一个不存在的用户的文章列表时会发生什么:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="22c7" class="jw jx hu mc b fv mg mh l mi mj">test "redirects when the specified user does not exist", %{conn: conn} do<br/>  conn = get conn, user_post_path(conn, :index, -1)<br/>  assert get_flash(conn, :error) == "Invalid user!"<br/>  assert redirected_to(conn) == page_path(conn, :index)<br/>  assert conn.halted<br/>end</span></pre><p id="83df" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们不需要在我们的模式匹配块中包含:user，因为我们无论如何都不会使用它。此外，我们还断言连接会在结束时中止。</p><p id="ad63" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">最后，我们需要编写一个测试来测试我们何时编辑别人的帖子。</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="b6d1" class="jw jx hu mc b fv mg mh l mi mj">test "redirects when trying to edit a post for a different user", %{conn: conn, user: user} do<br/>  other_user = User.changeset(%User{}, %{email: "test2@test.com", username: "test2", password: "test", password_confirmation: "test"})<br/>  |&gt; Repo.insert!<br/>  post = build_post(user)<br/>  conn = get conn, user_post_path(conn, :edit, other_user, post)<br/>  assert get_flash(conn, :error) == "You are not authorized to modify that post!"<br/>  assert redirected_to(conn) == page_path(conn, :index)<br/>  assert conn.halted<br/>end</span></pre><p id="e381" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们创建另一个用户作为我们的坏用户，并将其插入到回购中。然后，我们尝试在第一个用户下访问帖子的编辑操作。这会触发我们<strong class="ja hv"> authorize_user </strong>插头的反面案例！保存该文件并运行<strong class="ja hv">混合测试</strong>，我们将等待结果:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="d587" class="jw jx hu mc b fv mg mh l mi mj">.......................................</span><span id="ae71" class="jw jx hu mc b fv mk mh l mi mj">Finished in 0.4 seconds<br/>39 tests, 0 failures</span><span id="d893" class="jw jx hu mc b fv mk mh l mi mj">Randomized with seed 102543</span></pre><p id="a215" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">咻！太多了！但是，我们现在有了一个功能性的(更受保护的)博客，帖子是在我们的用户下创建的，我们仍然有一些很好的测试覆盖面！休息一下，放松一下，去玩几代怪物猎人(或者至少，这是我的计划)！我们将继续这一系列教程，添加管理员角色、评论、降价支持，最后我们将通过一个实时评论系统进入频道！</p><p id="d804" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果您有兴趣了解如何在开发模式下调试这个应用程序，那么请在这里阅读更多关于<a class="ae lw" rel="noopener" href="/@diamondgfx/debugging-phoenix-with-iex-pry-5417256e1d11">调试Phoenix应用程序的内容！</a></p><p id="1c43" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果你想继续学习教程，那我们继续吧！</p><h2 id="24e2" class="jw jx hu bd jy jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq dt translated">本系列的下一篇文章</h2><div class="kr ks fm fo kt ku"><a rel="noopener follow" target="_blank" href="/@diamondgfx/writing-a-blog-engine-in-phoenix-and-elixir-part-3-adding-roles-to-our-models-3be45a4afe4b"><div class="kv ab ej"><div class="kw ab kx cl cj ky"><h2 class="bd hv fv z el kz eo ep la er et ht dt translated">用Phoenix和Elixir编写博客引擎:第3部分，向模型添加角色</h2><div class="lb l"><h3 class="bd b fv z el kz eo ep la er et ek translated">最新更新:2016年1月26日</h3></div><div class="lc l"><p class="bd b gc z el kz eo ep la er et ek translated">medium.com</p></div></div></div></a></div><h1 id="f8d9" class="mm jx hu bd jy mn mo mp kc mq mr ms kg mt mu mv kj mw mx my km mz na nb kp nc dt translated">看看我的新书！</h1><p id="8477" class="pw-post-body-paragraph iy iz hu ja b jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv hn dt translated">嘿大家好！如果你喜欢你在这里读到的东西，并且想和我一起学习更多，可以看看我的新书《长生不老药和凤凰网开发》:</p><div class="kr ks fm fo kt ku"><a href="https://www.packtpub.com/web-development/phoenix-web-development" rel="noopener  ugc nofollow" target="_blank"><div class="kv ab ej"><div class="kw ab kx cl cj ky"><h2 class="bd hv fv z el kz eo ep la er et ht dt translated">凤凰网开发| PACKT图书</h2><div class="lb l"><h3 class="bd b fv z el kz eo ep la er et ek translated">学习使用Elixir和……从头开始构建投票web应用程序的高性能功能原型</h3></div><div class="lc l"><p class="bd b gc z el kz eo ep la er et ek translated">www.packtpub.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni nj ku"/></div></div></a></div><p id="1687" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我真的很兴奋终于可以把这个项目推向世界了！它的写作风格与我的其他教程一样，我们将从头到尾构建一个完整项目的框架，甚至涵盖一些更棘手的主题，如文件上传、Twitter/Google OAuth登录和API！</p><blockquote class="nk nl nm"><p id="6fd0" class="iy iz ml ja b jb jc jd je jf jg jh ji nn jk jl jm no jo jp jq np js jt ju jv hn dt translated"><a class="ae lw" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae lw" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae lw" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae lw" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="iy iz ml ja b jb jc jd je jf jg jh ji nn jk jl jm no jo jp jq np js jt ju jv hn dt translated">要了解更多信息，请<a class="ae lw" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae lw" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae lw" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="iy iz ml ja b jb jc jd je jf jg jh ji nn jk jl jm no jo jp jq np js jt ju jv hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lw" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lw" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>