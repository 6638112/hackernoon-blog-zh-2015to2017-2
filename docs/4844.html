<html>
<head>
<title>Kotlin delegates in Android development — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android开发中的Kotlin代表—第1部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/kotlin-delegates-in-android-development-part-1-50346cf4aed7?source=collection_archive---------1-----------------------#2017-06-26">https://medium.com/hackernoon/kotlin-delegates-in-android-development-part-1-50346cf4aed7?source=collection_archive---------1-----------------------#2017-06-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/8f066cf27964961f1d4dbe474c804034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G1c07xFgTYfNZOhjb2LGig.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="fec6" class="pw-subtitle-paragraph jc ie if bd b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ek translated">惰性和映射标准委托和SharedPreferences自定义委托</h2></div><p id="37d1" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">使用Kotlin的一些特性很容易写出干净易读的代码。由于有了数据类、属性、扩展函数和委托，Kotlin类通常比同等的Java类更小，更容易阅读。在这篇文章中，我们将看到如何使用Kotlin委托属性来简化Android代码。如果你不熟悉这个主题你可以看看<a class="ae kq" href="https://kotlinlang.org/docs/reference/delegated-properties.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>或者去<a class="ae kq" href="https://proandroiddev.com/delegation-in-kotlin-e1efb849641" rel="noopener ugc nofollow" target="_blank">这个帖子</a>。</p><h2 id="1364" class="kr ks if bd kt ku kv kw kx ky kz la lb kd lc ld le kh lf lg lh kl li lj lk ll dt translated">懒惰代表</h2><p id="6bbb" class="pw-post-body-paragraph ju jv if jw b jx lm jg jz ka ln jj kc kd lo kf kg kh lp kj kk kl lq kn ko kp hn dt translated">Kotlin标准库包含许多有用的委托，例如<a class="ae kq" href="https://kotlinlang.org/docs/reference/delegated-properties.html#lazy" rel="noopener ugc nofollow" target="_blank"> lazy </a>函数可以用来创建一个只有在第一次使用时才初始化的属性。此委托有助于轻松初始化使用Dagger管理的属性:</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="6f99" class="kr ks if lw b fv ma mb l mc md">private val navigationController by <em class="me">lazy </em><strong class="lw ig">{ <br/>  </strong>(<em class="me">applicationContext </em>as GithubApp).component.navigationController() <br/><strong class="lw ig">}</strong></span></pre><p id="caf8" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">以标准方式使用Dagger不需要类似的东西，因为属性将通过调用组件上的<code class="eh mf mg mh lw b">inject</code>方法来填充。在一个<a class="ae kq" href="https://github.com/fabioCollini/ArchitectureComponentsDemo/blob/master/app/src/main/java/it/codingjam/github/MainActivity.kt" rel="noopener ugc nofollow" target="_blank">演示项目</a>中，你可以在<a class="ae kq" href="https://github.com/fabioCollini/ArchitectureComponentsDemo" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到我正在尝试以一种简化的方式使用Dagger，活动和片段依赖是从Dagger组件中手动检索的。</p><p id="2185" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">前一个例子的代码可以简化为定义两个扩展属性来从一个<code class="eh mf mg mh lw b">Context</code>或一个<code class="eh mf mg mh lw b">Fragment</code>中检索Dagger组件:</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="5807" class="kr ks if lw b fv ma mb l mc md">val Context.<em class="me">component</em>: AppComponent<br/>    get() = (<em class="me">applicationContext </em>as GithubApp).component<br/><br/>val Fragment.<em class="me">component</em>: AppComponent<br/>    get() = <em class="me">activity</em>.<em class="me">component</em></span></pre><p id="d286" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">现在可以用一种简单的方式定义该属性:</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="1ae1" class="kr ks if lw b fv ma mb l mc md">private val navigationController by <em class="me">lazy </em><strong class="lw ig">{<br/>    </strong><em class="me">component</em>.navigationController() <br/><strong class="lw ig">}</strong></span></pre><p id="bea8" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">如果你的类只包含几个注入的字段，你可以使用一个惰性委托来定义它们，你不需要定义和调用<code class="eh mf mg mh lw b">inject</code>方法，属性不需要任何注释(所以不涉及注释处理),它可以被声明为私有的，不需要<code class="eh mf mg mh lw b">lateinit</code>关键字。</p><h2 id="254a" class="kr ks if bd kt ku kv kw kx ky kz la lb kd lc ld le kh lf lg lh kl li lj lk ll dt translated">映射代理</h2><p id="27c7" class="pw-post-body-paragraph ju jv if jw b jx lm jg jz ka ln jj kc kd lo kf kg kh lp kj kk kl lq kn ko kp hn dt translated">Kotlin标准库中定义的另一个委托是<a class="ae kq" href="https://kotlinlang.org/docs/reference/delegated-properties.html#storing-properties-in-a-map" rel="noopener ugc nofollow" target="_blank"> map委托</a>。使用它，可以以静态方式使用键值映射。有时，我们需要使用一组预定义的键来管理地图，例如使用Firebase Cloud Messaging，服务器发送的参数在地图中可用:</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="d2d2" class="kr ks if lw b fv ma mb l mc md">class MyMessagingService : FirebaseMessagingService() {<br/>    <br/>    override fun onMessageReceived(message: RemoteMessage?) {<br/>        super.onMessageReceived(message)<br/>        val data = (message?.<em class="me">data </em>?: <em class="me">emptyMap</em>()).<em class="me">withDefault </em>{ "" }<br/><strong class="lw ig">        <br/>        </strong>val title = data["title"]<br/>        val content = data["content"]<br/>        <br/>        <em class="me">print</em>("$title $content")<br/>    }<br/>}</span></pre><p id="e3a1" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">使用定义为字符串的键容易出错，我知道你可以在某个地方的常量中定义它们，但是定义静态的final字段(或者Kotlin对象中的某个东西)是Java 1.4的风格。我们可以使用一个具有两个属性的类来改进这段代码，这两个属性是使用map委托管理的:</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="f53f" class="kr ks if lw b fv ma mb l mc md">class NotificationParams(val map: Map&lt;String, String&gt;) {<br/>    val title: String by map<br/>    val content: String by map<br/>}</span></pre><p id="1ff9" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">可以使用该类重写代码，如果字段中有拼写错误(对应于映射键)，它将不会编译:</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="1e95" class="kr ks if lw b fv ma mb l mc md">override fun onMessageReceived(message: RemoteMessage?) {<br/>    super.onMessageReceived(message)<br/>    val data = (message?.<em class="me">data </em>?: <em class="me">emptyMap</em>()).<em class="me">withDefault </em><strong class="lw ig">{ </strong>"" <strong class="lw ig">}<br/><br/></strong>    val params = NotificationParams(data)<br/><br/>    <em class="me">print</em>("${params.title} ${params.content}")<br/>}</span></pre><h2 id="0494" class="kr ks if bd kt ku kv kw kx ky kz la lb kd lc ld le kh lf lg lh kl li lj lk ll dt translated">共享偏好</h2><p id="9aea" class="pw-post-body-paragraph ju jv if jw b jx lm jg jz ka ln jj kc kd lo kf kg kh lp kj kk kl lq kn ko kp hn dt translated">在GitHub <a class="ae kq" href="https://github.com/MarcinMoskala/PreferenceHolder" rel="noopener ugc nofollow" target="_blank">上有</a> <a class="ae kq" href="https://github.com/MarcinMoskala/KotlinPreferences" rel="noopener ugc nofollow" target="_blank">已经有</a><a class="ae kq" href="https://github.com/chibatching/Kotpref" rel="noopener ugc nofollow" target="_blank"/><a class="ae kq" href="https://github.com/yongjhih/kotlin-extensions" rel="noopener ugc nofollow" target="_blank">许多</a> <a class="ae kq" href="https://github.com/takuji31/Koreference" rel="noopener ugc nofollow" target="_blank">库</a>可以用来简化Kotlin中SharedPreferences的用法。让我们来看看自定义委托如何对编写保存在共享首选项中的属性非常有用。首先，让我们编写一个定义委托的<code class="eh mf mg mh lw b">SharedPreferences</code>类的扩展函数:</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="b852" class="kr ks if lw b fv ma mb l mc md">fun SharedPreferences.int(<br/>    defaultValue: Int = 0,<br/>    key: String? = null<br/>): ReadWriteProperty&lt;Any, Int&gt; {<br/>  return object : ReadWriteProperty&lt;Any, Int&gt; {<br/>      override fun getValue(thisRef: Any, property: KProperty&lt;*&gt;) =<br/>          getInt(key ?: property.name, defaultValue)<br/><br/>      override fun setValue(thisRef: Any, property: KProperty&lt;*&gt;, <br/>              value: Int) =<br/>          edit().putInt(key ?: property.name, value).apply()<br/>  }<br/>}</span></pre><p id="20fe" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">如果您不熟悉Kotlin结构(即使您熟悉它们)，这段代码也不容易理解。它定义了一个新的扩展方法<code class="eh mf mg mh lw b">int</code>，可以在一个<code class="eh mf mg mh lw b">SharedPreferences</code>对象上调用，这个方法返回一个<code class="eh mf mg mh lw b">ReadWriteProperty</code>，定义如何读写属性。有两个可选参数:默认值和用于在共享首选项中存储该值的键(如果没有提供键，则使用属性名)。</p><p id="7457" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">使用这种方法，我们可以定义一个带有与共享首选项关联的字段的类:</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="b3df" class="kr ks if lw b fv ma mb l mc md">class MyClass(prefs: SharedPreferences) {<br/>    var count by prefs.<em class="me">int</em>()<br/>}</span></pre><p id="d2d5" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">每次调用该属性时，都会从共享首选项中读取(或写入)值。</p><p id="fcd1" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">我们可以为其他类型定义类似的方法，为了避免复制和粘贴，我们可以使用一个泛型方法(我知道，这比前面的定义可读性更差):</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="5741" class="kr ks if lw b fv ma mb l mc md">private inline fun &lt;T&gt; SharedPreferences.delegate(<br/>    defaultValue: T, <br/>    key: String?,<br/>    crossinline getter: SharedPreferences.(String, T) -&gt; T,<br/>    crossinline setter: Editor.(String, T) -&gt; Editor<br/>): ReadWriteProperty&lt;Any, T&gt; {<br/>  return object : ReadWriteProperty&lt;Any, T&gt; {<br/>    override fun getValue(thisRef: Any, property: KProperty&lt;*&gt;) =<br/>        getter(key ?: property.name, defaultValue)<br/><br/>    override fun setValue(thisRef: Any, property: KProperty&lt;*&gt;, <br/>            value: T) =<br/>        edit().setter(key ?: property.name, value).apply()<br/>    }<br/>}</span></pre><p id="36de" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">附加参数是两个函数(都是扩展函数，以简化调用<code class="eh mf mg mh lw b">delegate</code>函数时提供它们的方式):</p><ul class=""><li id="b4e2" class="mi mj if jw b jx jy ka kb kd mk kh ml kl mm kp mn mo mp mq dt translated">从<code class="eh mf mg mh lw b">SharedPreferences</code>对象中读取值的getter</li><li id="0d31" class="mi mj if jw b jx mr ka ms kd mt kh mu kl mv kp mn mo mp mq dt translated">将值写入<code class="eh mf mg mh lw b">Editor</code>的设置器</li></ul><p id="797e" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">这个函数被定义为<code class="eh mf mg mh lw b">inline</code>以避免运行时开销，使用这个关键字<code class="eh mf mg mh lw b">getter</code>和<code class="eh mf mg mh lw b">setter</code>参数不被翻译成字节码中的类(更多信息可在<a class="ae kq" href="https://kotlinlang.org/docs/reference/inline-functions.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>中获得)。</p><p id="65d2" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">现在，我们可以轻松地为所有可以在共享首选项中编写的类型编写方法(在Kotlin中，泛型也可以用于基本类型，这一点非常有用):</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="c2d2" class="kr ks if lw b fv ma mb l mc md">fun SharedPreferences.int(def: Int = 0, key: String? = null) =<br/>   <em class="me">delegate</em>(def, key, SharedPreferences::getInt, Editor::putInt)<br/><br/>fun SharedPreferences.long(def: Long = 0, key: String? = null) =<br/>   <em class="me">delegate</em>(def, key, SharedPreferences::getLong, Editor::putLong)</span><span id="7497" class="kr ks if lw b fv mw mb l mc md">//...</span></pre><p id="0af2" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">这些委托可用于编写一个存储令牌的类，并计算令牌保存的次数(不是太有用，只是一个例子):</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="af09" class="kr ks if lw b fv ma mb l mc md">class TokenHolder(prefs: SharedPreferences) {<br/>    var token by prefs.<em class="me">string</em>()<br/>        private set<br/><br/>    var count by prefs.<em class="me">int</em>()<br/>        private set<br/><br/>    fun saveToken(newToken: String) {<br/>        token = newToken<br/>        count++<br/>    }<br/>}</span></pre><p id="5303" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">当<code class="eh mf mg mh lw b">count++</code>被调用时，我们从共享的首选项中读取值，并保存增加1的值，就像这样(但是以可读和紧凑的形式！):</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="0f50" class="kr ks if lw b fv ma mb l mc md">prefs.edit().putInt("count", prefs.getInt("count", 0) + 1).apply()</span></pre><p id="0fb6" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated"><code class="eh mf mg mh lw b">SharedPreferences</code>是一个Android SDK类，使用这个委托我们在许多类中使用它，其中一些可能是应用程序的业务逻辑类。许多开发人员喜欢保持这些类与Android无关，以便使用JVM测试来测试它们。使用这个委托，我们的类在JVM上是可测试的，即使我们使用的是Android SDK类。我们可以使用一个<code class="eh mf mg mh lw b">SharedPreferences</code>假实现编写一个JVM测试，该实现使用一个映射来存储值:</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="071c" class="kr ks if lw b fv ma mb l mc md">@Test fun shouldCount() {<br/>    val prefs = FakeSharedPreferences()<br/>    val tokenHolder = TokenHolder(prefs)<br/><br/>    tokenHolder.saveToken("a")<br/>    tokenHolder.saveToken("b")<br/><br/>    assertThat(tokenHolder.count).isEqualTo(2)<br/>    assertThat(prefs.getInt("count", 0)).isEqualTo(2)<br/>}</span></pre><p id="2310" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">你可以在这里找到<code class="eh mf mg mh lw b">FakeSharedPreferences</code> <a class="ae kq" href="https://github.com/NaluLabs/prefs-delegates/blob/master/fake-prefs/src/main/java/com/nalulabs/prefs/fake/FakeSharedPreferences.kt" rel="noopener ugc nofollow" target="_blank">的Kotlin版本</a>和<a class="ae kq" href="https://github.com/android/platform_packages_apps_calendar/blob/master/tests/src/com/android/calendar/FakeSharedPreferences.java" rel="noopener ugc nofollow" target="_blank">日历库</a>的原Java版本(59 Vs 166行代码！).</p><p id="da3a" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">编辑:我基于这篇文章的例子创建了一个小库来使用Kotlin代理共享偏好，你可以在GitHub找到它:<a class="ae kq" href="https://github.com/NaluLabs/prefs-delegates" rel="noopener ugc nofollow" target="_blank">github.com/NaluLabs/prefs-delegates</a></p><p id="d61a" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">这就是这篇文章的第一部分，在第二部分我们将看到如何使用Kotlin委托来简化架构组件的使用(你可以在GitHub上预览这个<a class="ae kq" href="https://github.com/fabioCollini/ArchitectureComponentsDemo" rel="noopener ugc nofollow" target="_blank">演示项目</a>)。</p><div class="lr ls lt lu fq ab cb"><figure class="mx hw my mz na nb nc paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mx hw my mz na nb nc paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mx hw my mz na nb nc paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="nd ne nf"><p id="f922" class="ju jv me jw b jx jy jg jz ka kb jj kc ng ke kf kg nh ki kj kk ni km kn ko kp hn dt translated"><a class="ae kq" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kq" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kq" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae kq" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ju jv me jw b jx jy jg jz ka kb jj kc ng ke kf kg nh ki kj kk ni km kn ko kp hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kq" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kq" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lr ls lt lu fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nj"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="lr ls lt lu fq hw"><div class="bz el l di"><div class="nk nl l"/></div></figure></div></div>    
</body>
</html>