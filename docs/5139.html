<html>
<head>
<title>FAT Python : the next chapter in Python optimization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">胖Python:Python优化的下一章</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/fat-python-the-next-chapter-in-python-optimization-69dc974bcca2?source=collection_archive---------3-----------------------#2017-07-12">https://medium.com/hackernoon/fat-python-the-next-chapter-in-python-optimization-69dc974bcca2?source=collection_archive---------3-----------------------#2017-07-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/fbbd065cc32513055fe44804dfa04fc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*Od4p2OW559lUVbgIu8Whrw.png"/></div></figure><p id="0894" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">胖Python项目由Victor Stinner于2015年10月启动，旨在解决之前Python“静态优化器”尝试的问题。Victor对CPython (Python增强提案或“pep”)进行了一系列更改，并提供了一些示例优化和基准测试。</p><p id="d25d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们将在本文中探讨这三个层次。</p><h1 id="60b0" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">AST中的优化</h1><blockquote class="ku kv kw"><p id="7e91" class="iy iz kx ja b jb jc jd je jf jg jh ji ky jk jl jm kz jo jp jq la js jt ju jv hn dt translated">不确定AST是什么？<a class="ae lb" href="https://hackernoon.com/modifying-the-python-language-in-7-minutes-b94b0a99ce14?gi=70b2d55c18a5" rel="noopener ugc nofollow" target="_blank">然后先看我的另一篇文章</a>。</p></blockquote><p id="427f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">转换抽象语法树(AST)是优化代码的一种更符合逻辑的方式。通过停留在一个更高的层次，你可以作出跨越一个分支的决定。</p><p id="52a1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">例如，可以用AST优化器实现的一些优化:</p><ul class=""><li id="8718" class="lc ld hu ja b jb jc jf jg jj le jn lf jr lg jv lh li lj lk dt translated"><a class="ae lb" href="https://en.wikipedia.org/wiki/Copy_propagation" rel="noopener ugc nofollow" target="_blank">复制传播</a>:替换x = 1；y=x，x = 1；y=1</li><li id="f47a" class="lc ld hu ja b jb ll jf lm jj ln jn lo jr lp jv lh li lj lk dt translated"><a class="ae lb" href="https://en.wikipedia.org/wiki/Constant_folding" rel="noopener ugc nofollow" target="_blank">常数折叠</a>:用2代替1+1</li><li id="f2d7" class="lc ld hu ja b jb ll jf lm jj ln jn lo jr lp jv lh li lj lk dt translated"><a class="ae lb" href="https://en.wikipedia.org/wiki/Dead_code_elimination" rel="noopener ugc nofollow" target="_blank">死码消除</a></li></ul><p id="a32a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">使用<strong class="ja hv"><em class="kx"/></strong>(见下一章)，可以实现更广泛的优化选择。示例:</p><ul class=""><li id="8232" class="lc ld hu ja b jb jc jf jg jj le jn lf jr lg jv lh li lj lk dt translated">简化iterable:当用作iterable时，用(0，1，2)替换range(3)</li><li id="3dca" class="lc ld hu ja b jb ll jf lm jj ln jn lo jr lp jv lh li lj lk dt translated"><a class="ae lb" href="https://en.wikipedia.org/wiki/Loop_unrolling" rel="noopener ugc nofollow" target="_blank">循环展开</a></li><li id="4516" class="lc ld hu ja b jb ll jf lm jj ln jn lo jr lp jv lh li lj lk dt translated">调用纯内置:用3替换len(“ABC”)</li><li id="93a0" class="lc ld hu ja b jb ll jf lm jj ln jn lo jr lp jv lh li lj lk dt translated">将使用的内置符号复制到常量</li></ul><h1 id="297b" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">脂肪是如何工作的</h1><p id="f5b3" class="pw-post-body-paragraph iy iz hu ja b jb lq jd je jf lr jh ji jj ls jl jm jn lt jp jq jr lu jt ju jv hn dt translated">FAT Optimizer是一组静态优化，基于CPython的3个主要变化。这些变化可能会合并到Python 3.7或3.8中，但目前我们必须手工编译它们。</p><p id="b6a8" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为什么我们需要对CPython进行修改？嗯，CPython没有用于优化AST的API。AST不可插拔，因此输入<em class="kx"> PEP 511 </em>..</p><h2 id="46a5" class="lv jx hu bd jy lw lx ly kc lz ma mb kg jj mc md kk jn me mf ko jr mg mh ks mi dt translated">人教版511</h2><p id="b7be" class="pw-post-body-paragraph iy iz hu ja b jb lq jd je jf lr jh ji jj ls jl jm jn lt jp jq jr lu jt ju jv hn dt translated">PEP 511建议添加一个流程来优化AST实例。AST实例是代码的面向对象表示。优化器可以是通用的，着眼于一般的优化，或者更加定制化。</p><p id="8a6e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">定制优化器可以查看一组领域特定的变化，例如NumPy或Pandas“反模式”,并在语法树中优化它们。在取代简单地推荐更改的静态linter的过程中，优化器可以为您做出这些更改。</p><p id="736f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">PEP 511引出对<code class="eh mj mk ml mm b">sys</code>模块的改变，以设置可以使用的优化器，然后它为优化器实例提供API。</p><p id="d905" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">将来，优化器可以包含在Python包中，并在PyPi上共享(相当酷——哈！？).</p><p id="1f7a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">PEP 511还假设，为了有效，优化器需要对核心CPython内部进行一些其他更改，输入PEP 509..</p><h2 id="90de" class="lv jx hu bd jy lw lx ly kc lz ma mb kg jj mc md kk jn me mf ko jr mg mh ks mi dt translated">人教版509</h2><p id="54fa" class="pw-post-body-paragraph iy iz hu ja b jb lq jd je jf lr jh ji jj ls jl jm jn lt jp jq jr lu jt ju jv hn dt translated">在Python中，内置dict类型被许多指令使用。例如，<code class="eh mj mk ml mm b">LOAD_GLOBAL</code>指令在全局名称空间或内置名称空间中查找变量(两次字典查找)。Python使用dict作为内置名称空间、全局名称空间、类型名称空间、实例名称空间等。本地名称空间(函数名称空间)通常被优化为一个数组，但它也可以是一个字典。</p><p id="7e12" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Python很难优化，因为几乎所有东西都是可变的:内置函数、函数代码、全局变量、局部变量……都可以在运行时修改。实现尊重Python语义的优化需要检测何时“有变化”:我们将这些检查称为“保护”。</p><p id="5dca" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">优化的加速取决于安全检查的速度。PEP 509提议给字典添加一个私有版本来实现名字空间的快速保护。</p><p id="78ad" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Python里怎么弄守卫？输入PEP 510</p><h2 id="5240" class="lv jx hu bd jy lw lx ly kc lz ma mb kg jj mc md kk jn me mf ko jr mg mh ks mi dt translated">人教版510</h2><p id="9e1b" class="pw-post-body-paragraph iy iz hu ja b jb lq jd je jf lr jh ji jj ls jl jm jn lt jp jq jr lu jt ju jv hn dt translated">PEP 510提出在Python C API中增加一个<em class="kx"> public </em> <em class="kx"> API </em>来为一个函数增加带守卫的专门代码。当函数被调用时，如果什么都没有改变，就使用专门的代码，否则就使用原始的字节码。</p><blockquote class="mn"><p id="dd31" class="mo mp hu bd mq mr ms mt mu mv mw jv ek translated">更容易看到所有这些的运行，所以让我们安装这些pep并测试一个优化器。</p></blockquote><h1 id="a504" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh mx kj kk kl my kn ko kp mz kr ks kt dt translated">跑步变胖</h1><p id="e246" class="pw-post-body-paragraph iy iz hu ja b jb lq jd je jf lr jh ji jj ls jl jm jn lt jp jq jr lu jt ju jv hn dt translated">编译一份打了<a class="ae lb" href="https://www.python.org/dev/peps/pep-0509/" rel="noopener ugc nofollow" target="_blank"> PEP 509 </a>、<a class="ae lb" href="https://www.python.org/dev/peps/pep-0510" rel="noopener ugc nofollow" target="_blank"> PEP 510 </a>和<a class="ae lb" href="https://www.python.org/dev/peps/pep-0511/" rel="noopener ugc nofollow" target="_blank"> PEP 511 </a>补丁的CPython 3.6。你需要一个C编译器来完成这项工作，如果你还没有的话，<a class="ae lb" href="https://gcc.gnu.org/install/" rel="noopener ugc nofollow" target="_blank"> GCC是一个简单的选择。</a></p><pre class="na nb nc nd fq ne mm nf ng aw nh dt"><span id="a5e6" class="lv jx hu mm b fv ni nj l nk nl">git clone <a class="ae lb" href="https://github.com/haypo/cpython" rel="noopener ugc nofollow" target="_blank">https://github.com/haypo/cpython</a> -b fatpython fatpython<br/>cd fatpython<br/>./configure CFLAGS='-O0' --enable-shared<br/>make</span></pre><blockquote class="ku kv kw"><p id="d31b" class="iy iz kx ja b jb jc jd je jf jg jh ji ky jk jl jm kz jo jp jq la js jt ju jv hn dt translated">在我的mac上，我必须将<code class="eh mj mk ml mm b">_sysconfigdata_dm_darwin_darwin.py</code>从构建目录复制到lib目录。</p></blockquote><p id="e511" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">安装fat。FAT是PEP510的一种实现，用于专业警卫。</p><pre class="na nb nc nd fq ne mm nf ng aw nh dt"><span id="d625" class="lv jx hu mm b fv ni nj l nk nl">git clone <a class="ae lb" href="https://github.com/haypo/fat" rel="noopener ugc nofollow" target="_blank">https:<strong class="mm hv">//</strong>github<strong class="mm hv">.</strong>com<strong class="mm hv">/</strong>haypo<strong class="mm hv">/</strong>fat</a><br/>cd fat<br/><strong class="mm hv">../</strong>python setup<strong class="mm hv">.</strong>py build<br/>cp <strong class="mm hv">-</strong>v build<strong class="mm hv">/</strong>lib<strong class="mm hv">*/</strong>fat<strong class="mm hv">.*</strong>so <strong class="mm hv">../</strong>Lib<br/>cd <strong class="mm hv">..</strong></span></pre><blockquote class="ku kv kw"><p id="4fb1" class="iy iz kx ja b jb jc jd je jf jg jh ji ky jk jl jm kz jo jp jq la js jt ju jv hn dt translated">对于OS X用户，在本文中使用<code class="eh mj mk ml mm b">./python.exe</code>而不是<code class="eh mj mk ml mm b">./python </code></p></blockquote><p id="f550" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">安装<code class="eh mj mk ml mm b">fatoptimizer</code>，PEP 511的一个实现，有一组优化。</p><pre class="na nb nc nd fq ne mm nf ng aw nh dt"><span id="bc72" class="lv jx hu mm b fv ni nj l nk nl">git clone <a class="ae lb" href="https://github.com/haypo/fatoptimizer" rel="noopener ugc nofollow" target="_blank">https:<strong class="mm hv">//</strong>github<strong class="mm hv">.</strong>com<strong class="mm hv">/</strong>haypo<strong class="mm hv">/</strong>fatoptimizer</a><br/>cd Lib<br/>ln <strong class="mm hv">-</strong>s <strong class="mm hv">../</strong>fatoptimizer<strong class="mm hv">/</strong>fatoptimizer <strong class="mm hv">.</strong></span></pre><p id="8cf1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们有了一个带有FAT的工作CPython可执行文件。一个简单的测试可以显示PEP 510中描述的防护。</p><figure class="na nb nc nd fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="fe ff nm"><img src="../Images/9daa17786f30cd645e096770eeaecf65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oLIYskbGFLyCb9DuQPzhBQ.png"/></div></div></figure><p id="e1ae" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在为了比较速度，运行一个基本的timeit，检查返回基本字符串长度的函数的调用。</p><p id="5841" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><code class="eh mj mk ml mm b">$ ./python.exe -X fat -m timeit -s ‘def f(): return len(“abc”)’ ‘f()’<br/>2000000 loops, best of 5: 115 nsec per loop</code></p><figure class="na nb nc nd fq iv fe ff paragraph-image"><div class="fe ff nr"><img src="../Images/8f7b50669a4a3479d18a8b0ece8201eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*Kc2SY0OO6ssKeXyChvJjXA.png"/></div></figure><p id="706c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我用CPython 3.6和2.7再次测试了这个(去掉了<code class="eh mj mk ml mm b">-X fat</code>)。比3.6提高了24%。</p><p id="076a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">优化本身在<a class="ae lb" href="https://fatoptimizer.readthedocs.io/en/latest/optimizations.html" rel="noopener ugc nofollow" target="_blank"> fatoptimizer文档</a>中有描述。</p><h1 id="60ba" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">它是如何工作的？</h1><p id="b0f2" class="pw-post-body-paragraph iy iz hu ja b jb lq jd je jf lr jh ji jj ls jl jm jn lt jp jq jr lu jt ju jv hn dt translated">如果拆开基础测试，看起来很正常。调用内置函数，返回值。</p><pre class="na nb nc nd fq ne mm nf ng aw nh dt"><span id="51cd" class="lv jx hu mm b fv ni nj l nk nl">&gt;&gt;&gt; import dis<br/>&gt;&gt;&gt; dis.dis(func)<br/>  1           0 LOAD_GLOBAL              0 (len)<br/>              3 LOAD_CONST               1 ('abc')<br/>              6 CALL_FUNCTION            1 (1 positional, 0 keyword pair)<br/>              9 RETURN_VALUE</span></pre><p id="5844" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">但是，使用fat，您可以访问该功能的专用(即优化)版本。这是在方法加载到ast中时生成的。Fat保留了原始的ast并存储了一个优化的方法。</p><pre class="na nb nc nd fq ne mm nf ng aw nh dt"><span id="c1f5" class="lv jx hu mm b fv ni nj l nk nl">&gt;&gt;&gt; dis.dis(fat.get_specialized(func)[0][0])<br/>  1           0 LOAD_CONST               1 (3)<br/>              3 RETURN_VALUE</span></pre><p id="94e9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">当我们通过我们的方法调用timeit时，它正在运行优化的函数，该函数只返回3，而不是调用<code class="eh mj mk ml mm b">len</code>。很明显可以看出为什么这样更快。</p><p id="0964" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">然而，在Python中，你可以用任何东西替换任何东西，包括全局名称空间中的内置。如果您要用别的东西替换<code class="eh mj mk ml mm b">len</code>，它会移除保护并执行原来的ast。</p><h1 id="0ff9" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">脂肪的下一步是什么？</h1><p id="61d0" class="pw-post-body-paragraph iy iz hu ja b jb lq jd je jf lr jh ji jj ls jl jm jn lt jp jq jr lu jt ju jv hn dt translated">3.7中重新引入了(我认为)与FAST_METHODCALL实现的连接。这意味着调用方法的开销更少，大大降低了CPython的速度。</p><p id="212a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">结合这3个pep，我们可以在PyPi上看到guards和一系列优化器的实现。</p></div></div>    
</body>
</html>