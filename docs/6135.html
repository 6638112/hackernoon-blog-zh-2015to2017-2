<html>
<head>
<title>Android Butterknife vs Data Binding</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android Butterknife vs数据绑定</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/android-butterknife-vs-data-binding-fffceb77ed88?source=collection_archive---------3-----------------------#2017-09-05">https://medium.com/hackernoon/android-butterknife-vs-data-binding-fffceb77ed88?source=collection_archive---------3-----------------------#2017-09-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="2462" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们来对比一下<a class="ae jp" href="https://hackernoon.com/tagged/butterknife" rel="noopener ugc nofollow" target="_blank"> Butterknife </a>和数据绑定库，2017年哪个更先进？如果你不熟悉这两个，简单来说:它们让你的布局建设体验更好。在比较它们时，我将从设置开始，涵盖每个基本方面，这样您将学会如何使用它们！</p><h1 id="1e19" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">设置</h1><h2 id="74dd" class="ko jr hu bd js kp kq kr jw ks kt ku ka jc kv kw ke jg kx ky ki jk kz la km lb dt translated">黄油刀</h2><p id="c28e" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">对于Butterknife，您需要将这些依赖项添加到build.gradle</p><blockquote class="lh li lj"><p id="2748" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv">编译“com . jakewharton:butter knife:8 . 6 . 0”</strong></p><p id="8902" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv">annotation processor ' com . jakewharton:butter knife-compiler:8 . 6 . 0 '</strong></p></blockquote><h2 id="31aa" class="ko jr hu bd js kp kq kr jw ks kt ku ka jc kv kw ke jg kx ky ki jk kz la km lb dt translated">数据绑定</h2><p id="f606" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">在这里，您只需将它们添加到build.gradle中的android范围内</p><blockquote class="lh li lj"><p id="f30b" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv">安卓{ </strong></p><p id="0303" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv"> … </strong></p><p id="8486" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv">数据绑定{ </strong></p><p id="778d" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv">启用真</strong></p><p id="ff31" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv"> } </strong></p><p id="55d1" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv"> } </strong></p></blockquote><p id="7cdd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后用<em class="lk"> layout </em>标签包装所有的布局，这样它在任何地方都是根标签</p><blockquote class="lh li lj"><p id="81c2" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv"> &lt;布局&gt; </strong></p><p id="e23c" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv"> &lt;线性布局&gt;…&lt;/线性布局&gt; </strong></p><p id="03c0" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv">&lt;/布局&gt; </strong></p></blockquote><h1 id="891a" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">查找视图</h1><h1 id="e4db" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">老派</h1><p id="3921" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">在普通Android框架中，使用这种方法可以找到布局中的视图</p><blockquote class="lh li lj"><p id="328a" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv">findViewById(r . id . textview)；</strong></p></blockquote><p id="a30b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后你把它转换成正确的类型，把它保存为局部变量或者保存到字段中，这对于大的布局来说确实是大量的工作</p><h2 id="7bc7" class="ko jr hu bd js kp kq kr jw ks kt ku ka jc kv kw ke jg kx ky ki jk kz la km lb dt translated">黄油刀</h2><p id="1345" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">使用Butterknife，您可以用这个注释来声明字段</p><blockquote class="lh li lj"><p id="7502" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv">公共类MyActivity{ </strong></p><p id="a640" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv"><em class="hu">@ bind view</em>(r . id . TextView)TextView文本；</strong></p><p id="9166" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv"> … </strong></p><p id="ea2d" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv"> } </strong></p></blockquote><p id="2148" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">并以这种方式将每个视图声明为字段，不需要<em class="lk"> findViewById </em>方法。现在，如果您将这种方法与以前的方法进行比较，如果您将视图保存为字段，您可以节省50%的代码行。少了两行。</p><p id="76b0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，如果你有20个视图，你会在类的顶部有20个难看的字段，这只是视图，变量呢？</p><h2 id="1280" class="ko jr hu bd js kp kq kr jw ks kt ku ka jc kv kw ke jg kx ky ki jk kz la km lb dt translated">数据绑定</h2><p id="f8db" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">现在这是下一个层次，这里你需要做一些改变。用此替换默认的setContentView</p><blockquote class="lh li lj"><p id="b914" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv"><em class="hu">@覆盖</em> </strong></p><p id="b1eb" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv">受保护的void onCreate(Bundle saved instancestate){</strong></p><p id="a47f" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv">ActivityMainBinding binding = databindingutil . set content view(this，r . layout . activity _ main)；</strong></p><p id="400d" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv"> … </strong></p><p id="7ded" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv"> } </strong></p></blockquote><p id="da1a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如你看到的，有一些ActivityMainBinding类——这个类是为你的布局生成的，它基于转换为camel case的布局名称，在末尾添加绑定。当你用<em class="lk">布局</em>标签包装你的布局时，就会发生这种情况。如果您有一个名为layout.xml的布局，您将生成LayoutBinding类</p><p id="f185" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，要访问您刚刚使用的任何视图</p><blockquote class="lh li lj"><p id="aafc" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv"> binding.textView </strong></p></blockquote><p id="c136" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你已经意识到了数据绑定的优势，那就是你最多只有两行代码。如果需要，您只需将绑定变量保存为字段，就可以访问该类中任何地方的任何字段</p><h2 id="2399" class="ko jr hu bd js kp kq kr jw ks kt ku ka jc kv kw ke jg kx ky ki jk kz la km lb dt translated">结论</h2><p id="e11a" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">假设我们的布局中有20个视图，我们希望它们可以被一个类中的任何方法访问，所以我们需要将它们作为字段。</p><p id="4fbf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用findViewById，您将有40行代码，Butterknife有20行，DataBinding有2行。两行！数据绑定在这里是明显的赢家</p><h1 id="49ee" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">Butterknife还能做什么</h1><p id="e88a" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">如果你调查一下<a class="ae jp" href="https://github.com/JakeWharton/butterknife" rel="noopener ugc nofollow" target="_blank">butter knife</a>doc——基本上没有更多的。OnClick注释甚至不需要任何库，因为您可以使用<em class="lk"> android:onClick </em>属性在XML中查看视图</p><p id="cb48" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有些人使用的资源绑定，在数据绑定中没有。基本上就是这样</p><h1 id="861f" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">数据绑定</h1><p id="39cd" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">对于数据绑定来说，这只是一个开始。您可以将您的逻辑移动到XML文件中，这是构建布局时更自然的方法</p><p id="4041" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设您有一个包含20个字段的电影模型，您希望在布局中显示所有字段。通常你会为每个电影字段调用Java中的<em class="lk"> setText </em>和其他方法。使用数据绑定，您可以做到这一点</p><blockquote class="lh li lj"><p id="8a1d" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv"> &lt;布局&gt; </strong></p><p id="0ab3" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv"> &lt;数据&gt; </strong></p><p id="2e4c" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv">T36】变量</strong></p><p id="83cc" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv"> name="movie" </strong></p><p id="da6c" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv">type = " com . unified waves . movie "/&gt;</strong></p><p id="bace" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv">&lt;/数据&gt; </strong></p><p id="bccb" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv"> &lt;文本视图</strong></p><p id="bf9d" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv"> … </strong></p><p id="cf54" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv">Android:text = " @ { movie . name } "/&gt;</strong></p><p id="0be2" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv">&lt;/拉尤特&gt; </strong></p></blockquote><p id="3d72" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以在布局的顶部添加变量，然后就可以在那里设置视图。Name是Movie类中的变量名。</p><p id="115d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了将一个对象传递给你的布局，你在Java中调用这个方法，它是为你的每个变量生成的</p><blockquote class="lh li lj"><p id="8b53" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv"> binding.setMovie(新电影(…))；</strong></p></blockquote><p id="e249" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这并不是说这种方法节省了一些代码行，而是因为它更自然，在构建布局、编写Java时，您不需要一次又一次地从Java到XML来回切换。你只需要写布局，完成后，进入Java。简单。</p><h1 id="ba01" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">绑定适配器</h1><p id="aeeb" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">还有更多数据绑定可以提供，这是我想提到的最后一件事——自定义属性。通过使用绑定适配器，您可以为任何视图创建自定义属性，而无需实际扩展这些视图</p><p id="cc9d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我最喜欢的一个——<em class="lk">imageUrl</em>。有多少次你希望Android框架有这个属性，你只需把图片url传递给ImageView，它就加载它？嗯，当你刚刚开始的时候，你可能会这样做。</p><p id="80a9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">看看我们能做什么</p><blockquote class="lh li lj"><p id="3ba6" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv"><em class="hu">@ binding adapter</em>(“app:imageUrl”)</strong></p><p id="e99e" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv">公共静态void imageUrl(ImageView v，String url){ </strong></p><p id="89bb" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv"> //Glide.with()… </strong></p><p id="83d4" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv"> } </strong></p><p id="b930" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv"> &lt;布局&gt; </strong></p><p id="da49" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv"> &lt;数据&gt; </strong></p><p id="b392" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv">T38】变量</strong></p><p id="f161" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv"> name="movie" </strong></p><p id="1259" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv">type = " com . myhexaville . movie "/&gt;</strong></p><p id="32c8" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv">&lt;/数据&gt; </strong></p><p id="d548" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv"> &lt; ImageView </strong></p><p id="c6e5" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv"> … </strong></p><p id="182d" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv">app:imageUrl = " @ { movie . imageUrl } "/&gt;</strong></p><p id="5191" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv"> &lt; /layouyt &gt; </strong></p></blockquote><p id="f4dc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">imageUrl是电影模型的字符串字段变量。我们刚刚为ImageView声明了一个自定义属性。一旦您使用<em class="lk">binding . set movie(movie)</em>将电影对象传递到您的布局，您的ImageView将使用Glide从电影对象加载图像url</p><p id="99e7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">至于那个静态方法——你可以把它放在你的项目中任何你想放的地方。几乎在任何地方，它都会工作</p><h1 id="b37a" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">结论</h1><p id="7b56" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">在2015年我开始学习Android后不久，数据绑定就出现了，所以我用了几次Butterknife，当我看到数据绑定时，我意识到——这是下一个级别。看看简单的访问视图。</p><p id="c8f4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">顺便说一句，如果你使用kot Lin——有访问视图的Android扩展，就像数据绑定一样工作，但是开销更少</p><p id="b4b5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">感谢阅读！</p><figure class="lo lp lq lr fq ls"><div class="bz el l di"><div class="lt lu l"/></div></figure></div></div>    
</body>
</html>