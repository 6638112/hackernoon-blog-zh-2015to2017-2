<html>
<head>
<title>So, what the hell are goroutines?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">那么，goroutines到底是什么？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/goroutines-a-general-introduction-49bed9812c94?source=collection_archive---------18-----------------------#2017-12-07">https://medium.com/hackernoon/goroutines-a-general-introduction-49bed9812c94?source=collection_archive---------18-----------------------#2017-12-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/9b24d628a9ad6d83d2bb1f60d988a094.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AALvJk1OzHn4XR6ULQxuhA.png"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">The image is no over exaggeration</figcaption></figure><div class=""/><p id="e94e" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">对并发的本地支持是Go最受欢迎的特性之一，它允许开发人员轻松地创建并发应用程序。为了利用这种本地并发性，需要goroutines。</p><p id="aa72" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">Goroutines可以被认为是Go的主干，在设计固有的并发应用程序时非常重要。</p><p id="b8d2" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">那么让我们来了解一下什么是goroutines。</p><h1 id="9e23" class="ke kf ij bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated"><strong class="ak">什么是Goroutines </strong></h1><p id="3eb0" class="pw-post-body-paragraph jg jh ij ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hn dt translated">Goroutines可以比作轻量级线程。它们只是与其他函数或方法同时运行的函数或方法。</p><p id="1534" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">它们允许我们在同一个地址空间中同时创建和运行多个函数，并且没有显著的设置成本。</p><h1 id="dea9" class="ke kf ij bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated"><strong class="ak"> Goroutines vs Threads </strong></h1><p id="07cd" class="pw-post-body-paragraph jg jh ij ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hn dt translated">Go使用goroutines，而Java等其他语言使用线程。Goroutines很便宜(大约2 Kb ),其中as线程通常是内存密集型的(从1 Mb开始),因为它们需要更多的堆栈空间。这使得开发人员可以创建大量的goroutines，这在线程中是不可能的。</p><p id="e7dc" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">所以你可能会问，为什么goroutines这么轻？</p><p id="6ff1" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">goroutines之所以如此轻量级，是因为Go不使用传统的本地线程，而是使用绿色线程。本机线程或者更确切地说是OS线程具有单独的函数调用堆栈，并且它们的设置和拆卸成本很高。</p><p id="bfba" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们看看围棋如何做到这一点。</p><p id="868b" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">所以在运行时，调度器将go routine映射到线程上，但与Java线程中的1:1映射不同，一组go routine被映射到一个或一组线程上。此外，goroutines具有灵活的堆栈大小，可以根据需要扩展和收缩。这大大减少了内存占用，并改善了goroutines的内存重新分配时间。</p><p id="db61" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">但是你根本不需要担心所有这些漂亮的细节。</p><p id="ebe9" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">所有这些任务都由Go在运行时负责，并从用户那里抽象出来。</p><p id="a63a" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">因此，用户可以做他最擅长的事情，编写干净高效的代码，而不必担心堆栈分段和内存重新分配。</p><figure class="li lj lk ll fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lh"><img src="../Images/7b4e811d5cf2ddfca224eaf2471fec20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ugshDOhXfC287WWhG4IfSA.jpeg"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">The gopher-books analogy from <a class="ae lm" href="https://www.youtube.com/watch?v=cN_DpYBzKso" rel="noopener ugc nofollow" target="_blank">Rob Pike’s talk</a></figcaption></figure><h1 id="169d" class="ke kf ij bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated"><strong class="ak">如何启动Goroutine </strong></h1><p id="5c67" class="pw-post-body-paragraph jg jh ij ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hn dt translated">一个goroutine启动起来相当简单，只需在函数或方法前面使用关键字<strong class="ji ik"> <em class="ln"> go </em> </strong> <em class="ln"> </em>就可以完成，这样就可以让一个goroutine准备好并发工作。</p><pre class="li lj lk ll fq lo lp lq lr aw ls dt"><span id="8921" class="lt kf ij lp b fv lu lv l lw lx">package main<br/><br/>import (  <br/>    "fmt"<br/>)<br/><br/>func hello() {  <br/>    fmt.Println("Hi, I'm a goroutine!")<br/>}<br/>func main() {  <br/>    go hello()<br/>    fmt.Println("Inside main function")<br/>}</span></pre><p id="421f" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">上面的代码将创建一个goroutine，与执行自己的goroutine(称为主goroutine)的<code class="eh ly lz ma lp b">func main()</code>同时运行。</p><p id="b1e9" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">goroutines的创建非常简单，你不必担心后台的细节，因为它们都是由Go在运行时处理的。</p><h1 id="8a4e" class="ke kf ij bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">但是等等..</h1><p id="2a05" class="pw-post-body-paragraph jg jh ij ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hn dt translated">在执行代码时，您会收到一个小小的惊喜！</p><pre class="li lj lk ll fq lo lp lq lr aw ls dt"><span id="f09b" class="lt kf ij lp b fv lu lv l lw lx">Inside main function</span></pre><p id="8d3a" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">该代码仅打印来自<code class="eh ly lz ma lp b">func main()</code>的信息，而不打印来自<code class="eh ly lz ma lp b">func hello()</code>的信息。这可以解释如下—</p><ol class=""><li id="4888" class="mb mc ij ji b jj jk jn jo jr md jv me jz mf kd mg mh mi mj dt translated">当启动一个goroutine时，goroutine调用会立即返回。这意味着控件不会为了继续下一个函数或goroutine而等待goroutine执行完毕。</li><li id="372a" class="mb mc ij ji b jj mk jn ml jr mm jv mn jz mo kd mg mh mi mj dt translated">此外，主goroutine应该正在运行，以便运行任何其他goroutine。它的终止将导致任何其他goroutines的终止，程序将结束。</li></ol><p id="9f44" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这正是我们上面的代码所发生的情况。在调用<code class="eh ly lz ma lp b">go hello</code>之后，控件在主函数中打印出消息，之后程序终止。<code class="eh ly lz ma lp b">func hello()</code>没有得到执行的机会，因为主goroutine被终止，程序结束。</p><h1 id="9b74" class="ke kf ij bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">解决问题的方法</h1><p id="3ea7" class="pw-post-body-paragraph jg jh ij ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hn dt translated">准确地说，这与其说是修复，不如说是破解，因为我们将程序的执行限制在现实世界的时间约束内，但这对于这个例子来说已经足够了。请注意，这是一种不好的做法，应该避免，因为在现实中，我们总是使用通道进行任何此类同步。</p><pre class="li lj lk ll fq lo lp lq lr aw ls dt"><span id="27a4" class="lt kf ij lp b fv lu lv l lw lx">package main<br/><br/>import (  <br/>    "fmt"<br/>    "time"<br/>)<br/><br/>func hello() {  <br/>    fmt.Println("Hi, I'm a goroutine!")<br/>}<br/>func main() {  <br/>    go hello()<br/>    time.Sleep(1 * time.Second)<br/>    fmt.Println("Inside main function")<br/>}</span></pre><p id="4a9e" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh ly lz ma lp b">time.sleep(1 * time.Second)</code>行将当前的goroutine置于休眠状态，并给hello goroutine足够的时间来完成。</p><p id="f3b7" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，当我们运行程序时，我们得到的两条消息有1秒钟的间隔。</p><pre class="li lj lk ll fq lo lp lq lr aw ls dt"><span id="8a16" class="lt kf ij lp b fv lu lv l lw lx">Hi, I'm a goroutine! <br/>Inside main function</span></pre><h1 id="9eb8" class="ke kf ij bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">结束语</h1><p id="1b75" class="pw-post-body-paragraph jg jh ij ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hn dt translated">默认情况下，Go使用的CPU线程数等于当前的CPU内核数。您可以通过下面的语句<code class="eh ly lz ma lp b">runtime.GOMAXPROCS(-1)</code>得到线程的数量</p><p id="e61d" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">可以通过将值从1更改为任何数字来更改线程的数量，但是在选择它们时必须小心。虽然更多的线程可以提高性能，但是太多的线程会降低进程速度，所以理想的数量应该在运行性能扫描之后决定。</p></div><div class="ab cl mp mq hc mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hn ho hp hq hr"><p id="2a32" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">Go的本地并发模型使得它在创建真正的并发系统方面越来越受欢迎，而goroutines是其功能的重要组成部分。它们可以被认为是语言的心脏和灵魂，如果使用正确，它们可以提供巨大的性能提升。</p></div><div class="ab cl mp mq hc mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hn ho hp hq hr"><h1 id="4530" class="ke kf ij bd kg kh mw kj kk kl mx kn ko kp my kr ks kt mz kv kw kx na kz la lb dt translated">并发不等于并行</h1><p id="9bb3" class="pw-post-body-paragraph jg jh ij ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hn dt translated">我在这篇文章中多次使用并发性，但是如果你仍然想交替使用并发性和并行性这两个词，那么是时候看看Rob Pike关于这个话题的文章了。</p></div></div>    
</body>
</html>