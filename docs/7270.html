<html>
<head>
<title>An Introduction to Serverless DevOps with OpenFaaS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用OpenFaaS的无服务器DevOps简介</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/an-introduction-to-serverless-devops-with-openfaas-b978ab0eb2b?source=collection_archive---------5-----------------------#2017-10-22">https://medium.com/hackernoon/an-introduction-to-serverless-devops-with-openfaas-b978ab0eb2b?source=collection_archive---------5-----------------------#2017-10-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="c863" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">DevOps不仅仅是做CI/CD。但是CI/CD管道在DevOps中有着重要的作用。最近我一直在<a class="ae jp" href="https://www.openfaas.com/" rel="noopener ugc nofollow" target="_blank"> OpenFaaS </a>上投入时间，当我开始创建多个功能时，我想要一个易于使用和可访问的开发和交付流程，换句话说，一个CI/CD管道。</p><p id="b498" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一天，当我与Alex(OpenFaaS的创造者)交谈时，他让我整理一份关于open FAAS的CI/CD的指南(使用Github和Travis CI)。对我来说，这是一个完美的时机，因为我实际上正在考虑如何将我与其他项目一起应用的CI/CD管道集成到OpenFaaS无服务器管道中。下图显示了我得出的结论:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/f15a2a85aa99a3709cee19a3abce8e76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dG3BvjSH0baVQuOWbGGHOg.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">OpenFaaS CI/CD Pipeline</figcaption></figure><p id="d60a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">高层次的概述如下:</p><ul class=""><li id="83af" class="kg kh hu it b iu iv iy iz jc ki jg kj jk kk jo kl km kn ko dt translated">推送至GitHub</li><li id="d897" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated">流水线启动<br/>构建函数映像<br/>创建临时群环境<br/>运行函数测试<br/>如果测试通过则向注册表发布映像<br/>如果测试通过则部署函数</li><li id="94ff" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated">管道末端</li></ul><p id="9851" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于那些想一头扎进去的人来说，资源库发布在这里<a class="ae jp" href="https://github.com/kenfdev/faas-echo" rel="noopener ugc nofollow" target="_blank"/>。您可以在<code class="eh ku kv kw kx b">.travis.yml</code>文件中查看管道的阶段和命令。</p><p id="599d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我从这里开始一步一步解释上下文。</p><h1 id="98ae" class="ky kz hu bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv dt translated">在Travis CI构建中使用Docker和Swarm</h1><p id="ad89" class="pw-post-body-paragraph ir is hu it b iu lw iw ix iy lx ja jb jc ly je jf jg lz ji jj jk ma jm jn jo hn dt translated">好吧，我不打算进入“如何使用特拉维斯CI”的细节。有很多很好的文章解释这一点，官方文件也组织得很好。在我的用例中使用Travis的要点是:</p><ul class=""><li id="9e25" class="kg kh hu it b iu iv iy iz jc ki jg kj jk kk jo kl km kn ko dt translated">我们将使用Docker和Swarm</li><li id="5dd5" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated">我们将使用Node.js进行测试</li></ul><p id="00a6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如<a class="ae jp" href="https://docs.travis-ci.com/user/docker/" rel="noopener ugc nofollow" target="_blank">文档</a>中所述，我们需要包括:</p><pre class="jr js jt ju fq mb kx mc md aw me dt"><span id="72d4" class="mf kz hu kx b fv mg mh l mi mj">sudo: required<br/><br/>services:<br/>  - docker</span></pre><p id="30a9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了在构建中使用docker。此外，我们希望能够使用<code class="eh ku kv kw kx b">docker-compose</code> <code class="eh ku kv kw kx b">version 3.2</code>来部署我们的OpenFaaS堆栈，但这在Travis的默认docker版本中是不可能的。同样，正如<a class="ae jp" href="https://docs.travis-ci.com/user/docker/#Installing-a-newer-Docker-version" rel="noopener ugc nofollow" target="_blank">文档</a>所说，你需要写:</p><pre class="jr js jt ju fq mb kx mc md aw me dt"><span id="8e5d" class="mf kz hu kx b fv mg mh l mi mj">before_install:<br/>  - sudo apt-get update<br/>  - sudo apt-get -y -o Dpkg::Options::="--force-confnew" install docker-ce</span></pre><p id="797a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了安装docker的新版本。如果你错过了这一部分，你会看到</p><pre class="jr js jt ju fq mb kx mc md aw me dt"><span id="2618" class="mf kz hu kx b fv mg mh l mi mj">unsupported Compose file version: 3.2</span></pre><p id="37fd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">像这样的事情会失败的。</p><h1 id="dc5f" class="ky kz hu bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv dt translated">用Swarm创建临时测试环境</h1><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff mk"><img src="../Images/f5f4fd2e8c1d03e1b77579a13cba306d.png" data-original-src="https://miro.medium.com/v2/resize:fit:544/format:webp/1*kwDUmeMTygoQFnSDUWrHWA.png"/></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Open FaaS Temporary Testing Environment</figcaption></figure><p id="04e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如上图所示，我们需要一个OpenFaaS环境来全面测试功能(e2e测试)。创建一个Swarm环境很容易，但是准备一个OpenFaaS环境需要一点调整才能正常工作。</p><p id="db15" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了准备我们的测试环境，我们需要:</p><ul class=""><li id="374b" class="kg kh hu it b iu iv iy iz jc ki jg kj jk kk jo kl km kn ko dt translated">获取OpenFaaS CLI工具(<a class="ae jp" href="https://github.com/openfaas/faas-cli" rel="noopener ugc nofollow" target="_blank"> faas-cli </a>)</li><li id="c0e6" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated">初始化群集</li><li id="28bc" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated">部署网关和功能</li></ul><p id="7840" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">获取OpenFaaS CLI工具:<br/></strong>OpenFaaS CLI工具(<a class="ae jp" href="https://github.com/openfaas/faas-cli" rel="noopener ugc nofollow" target="_blank"> faas-cli </a>)使得使用open FAAS变得很容易，我们肯定会在管道中需要它。它就像调用这个命令一样简单:</p><pre class="jr js jt ju fq mb kx mc md aw me dt"><span id="42d4" class="mf kz hu kx b fv mg mh l mi mj">curl -sSL <a class="ae jp" href="https://cli.openfaas.com" rel="noopener ugc nofollow" target="_blank">https://cli.openfaas.com</a> | sudo sh</span></pre><p id="3b0b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">初始化蜂群:<br/> </strong>这是直截了当的。只需调用命令:</p><pre class="jr js jt ju fq mb kx mc md aw me dt"><span id="e116" class="mf kz hu kx b fv mg mh l mi mj">docker swarm init</span></pre><p id="1e03" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">部署网关和功能:</strong> <br/>好了，这是比较棘手的部分。通常，部署OpenFaaS是非常容易的<strong class="it hv"/>。我是真心的。如果你还没有，你一定要看看亚历克斯的“<a class="ae jp" href="https://skillsmatter.com/skillscasts/10813-faas-and-furious-0-to-serverless-in-60-seconds-anywhere" rel="noopener ugc nofollow" target="_blank"> FaaS与愤怒——在60秒内从0到无服务器，在任何地方</a>”。但是为CI/CD管道部署它会增加一些您通常不需要的顾虑。在测试运行之前，环境需要准备好。这意味着群服务需要准备好。为此，我编写了一个简单的shell脚本函数:</p><pre class="jr js jt ju fq mb kx mc md aw me dt"><span id="5846" class="mf kz hu kx b fv mg mh l mi mj"># This function checks if the service is in Running state<br/>check_service_is_running() {<br/>    local SERVICE_NAME=$1<br/>    local STATE=$(docker service ps --format '{{json .CurrentState}}' $SERVICE_NAME)<br/>    if [[ $STATE = \"Running* ]]; then<br/>      echo 1<br/>    else<br/>      echo 0<br/>    fi<br/>}</span></pre><p id="1b5e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它使用<code class="eh ku kv kw kx b">docker service ps</code>来检查服务的状态。如果是<code class="eh ku kv kw kx b">Running</code>，则返回<code class="eh ku kv kw kx b">1</code>，否则返回<code class="eh ku kv kw kx b">0</code>。除了这个功能，我们需要重试，直到服务准备好，所以我也添加了一个重试功能(它在内部调用<code class="eh ku kv kw kx b">check_service_is_running</code>):</p><pre class="jr js jt ju fq mb kx mc md aw me dt"><span id="ebb6" class="mf kz hu kx b fv mg mh l mi mj"># This function waits for the service to become available.<br/># Retries for 10 times and 3 second interval (hard coded for now)<br/>wait_for_service_to_start() {<br/>    local n=1<br/>    local max=10<br/>    local delay=3</span><span id="409a" class="mf kz hu kx b fv ml mh l mi mj">local SERVICE_NAME=$1<br/>    local SERVICE_IS_RUNNING=0<br/>    while [  "$SERVICE_IS_RUNNING" -eq 0 ]; do<br/>      if [[ $n -gt $max ]]; then<br/>        echo "ERROR: Retried $(($n-1)) times but $SERVICE_NAME didn't start. Exiting" &gt;&amp;2<br/>        exit 1<br/>      fi<br/>      SERVICE_IS_RUNNING=$(check_service_is_running $SERVICE_NAME)<br/>      echo "Waiting for $SERVICE_NAME to start"<br/>      n=$[$n+1]<br/>      sleep $delay<br/>    done<br/>    echo "$SERVICE_NAME is Running"<br/>}</span></pre><p id="e115" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们可以确保网关和功能按预期运行，我们可以使用以下命令设置环境:</p><pre class="jr js jt ju fq mb kx mc md aw me dt"><span id="3c9b" class="mf kz hu kx b fv mg mh l mi mj"># deploy the stack to swarm<br/>./deploy_stack.sh</span><span id="24c8" class="mf kz hu kx b fv ml mh l mi mj"># build the functions (assuming 4 cores)<br/>faas-cli build --parallel 4 -f stack.yml</span><span id="2866" class="mf kz hu kx b fv ml mh l mi mj"># we can't deploy unless the gateway is ready so wait<br/>wait_for_service_to_start func_gateway<br/># and then deploy<br/>faas-cli deploy -f stack.yml</span><span id="9976" class="mf kz hu kx b fv ml mh l mi mj"># wait for functions to become ready for testing<br/>wait_for_service_to_start echo</span></pre><p id="1b98" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ku kv kw kx b">deploy_stack.sh</code>只是简单地呼叫:</p><pre class="jr js jt ju fq mb kx mc md aw me dt"><span id="0581" class="mf kz hu kx b fv mg mh l mi mj">docker stack deploy func --compose-file docker-compose.yml</span></pre><p id="4587" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">并在Swarm内部部署堆栈。我想在本地机器上重用这个shell，因此它在一个外部文件中。<code class="eh ku kv kw kx b">faas-cli build</code>创建功能映像，<code class="eh ku kv kw kx b">faas-cli deploy</code>通过网关部署功能。通过这个调整，我们可以确保一个完全工作的OpenFaaS环境(您可以在<a class="ae jp" href="https://github.com/kenfdev/faas-echo/blob/master/ci-setup.sh" rel="noopener ugc nofollow" target="_blank"> ci-setup.sh </a>文件中查看完整的脚本)。</p><h1 id="b884" class="ky kz hu bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv dt translated">测试功能</h1><p id="5fac" class="pw-post-body-paragraph ir is hu it b iu lw iw ix iy lx ja jb jc ly je jf jg lz ji jj jk ma jm jn jo hn dt translated">现在我们有了一个测试环境，针对它的测试非常简单。您可以选择自己喜欢的任何框架，但是对于本文，我选择了Node.js和<a class="ae jp" href="https://github.com/dareid/chakram" rel="noopener ugc nofollow" target="_blank"> chakram </a>库。以下测试是对<code class="eh ku kv kw kx b">echo</code>功能的示例测试。只是检查响应是否是我发送的文本:</p><pre class="jr js jt ju fq mb kx mc md aw me dt"><span id="752e" class="mf kz hu kx b fv mg mh l mi mj">const chakram = require('chakram');<br/>const expect = chakram.expect;</span><span id="ef1f" class="mf kz hu kx b fv ml mh l mi mj">const ENDPOINT = "<a class="ae jp" href="http://localhost:8080/function/echo" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/function/echo</a>";</span><span id="0c81" class="mf kz hu kx b fv ml mh l mi mj">describe("FaaS echo function", () =&gt; {<br/>    it("should respond with the data you passed", () =&gt; {<br/>        // Arrange<br/>        const expected = "echo test";</span><span id="f450" class="mf kz hu kx b fv ml mh l mi mj">// Act<br/>        return chakram.post(ENDPOINT, expected, {json: false})<br/>            .then(response =&gt; {<br/>                // Assert<br/>                expect(response).to.have.status(200);<br/>                expect(response.body).to.contain(expected);<br/>            });<br/>    });<br/>});</span></pre><p id="3351" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了使用Node.js和缓存库，不要忘记在<code class="eh ku kv kw kx b">.travis.yml</code>中添加以下几行:</p><pre class="jr js jt ju fq mb kx mc md aw me dt"><span id="683b" class="mf kz hu kx b fv mg mh l mi mj">language: node_js<br/>node_js:<br/>  - "8"</span><span id="eeed" class="mf kz hu kx b fv ml mh l mi mj">cache: yarn</span></pre><h1 id="5513" class="ky kz hu bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv dt translated">清理虫群</h1><p id="e27e" class="pw-post-body-paragraph ir is hu it b iu lw iw ix iy lx ja jb jc ly je jf jg lz ji jj jk ma jm jn jo hn dt translated">这可能是不必要的，但我喜欢对称，所以我决定清理群体环境:</p><pre class="jr js jt ju fq mb kx mc md aw me dt"><span id="1b4b" class="mf kz hu kx b fv mg mh l mi mj">docker swarm leave -f</span></pre><h1 id="7bad" class="ky kz hu bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv dt translated">发布和部署</h1><p id="62e2" class="pw-post-body-paragraph ir is hu it b iu lw iw ix iy lx ja jb jc ly je jf jg lz ji jj jk ma jm jn jo hn dt translated">在测试按预期通过之后，我们希望发布功能映像，并将它们部署到其他环境中(开发、阶段、生产等)。这很简单，travis ci <a class="ae jp" href="https://docs.travis-ci.com/user/docker/#Branch-Based-Registry-Pushes" rel="noopener ugc nofollow" target="_blank">文档</a>中也有记载:</p><pre class="jr js jt ju fq mb kx mc md aw me dt"><span id="f9ce" class="mf kz hu kx b fv mg mh l mi mj">after_success:<br/>  - if [ "$TRAVIS_BRANCH" == "master" ]; then<br/>    docker login -u="$DOCKER_USERNAME" -p="$DOCKER_PASSWORD";<br/>    faas-cli push -f echo.yml<br/>    fi</span></pre><p id="7130" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这意味着只有当<strong class="it hv">测试成功</strong>并且在<strong class="it hv">主分支</strong>上时，图像才会被推送。<code class="eh ku kv kw kx b">faas-cli push</code>将函数推送到注册表。另一个有趣的部分是<code class="eh ku kv kw kx b">$DOCKER_USERNAME</code>和<code class="eh ku kv kw kx b">$DOCKER_PASSWORD</code>环境变量。您可以通过travis ci管理控制台设置这些凭据。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mm"><img src="../Images/a8d7e4af963179a906ceb04b5c05d710.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BOM4fDLexyATnFlSfJHQng.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">travis ci dashboard</figcaption></figure><p id="41ad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从设置中，您可以设置环境变量:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mm"><img src="../Images/7ca583177b2f88753e93f46b74587b71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ANu4CoM7YeKt2-ETpkeHug.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Setting Environment Variables</figcaption></figure><p id="17ec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，你不必在<code class="eh ku kv kw kx b">.travis.yml</code>里暴露你的身份。虽然上面的命令没有部署到任何环境中，但这只是触发一些deploy webhook(或类似的东西)的问题。因此，无论您使用什么后端(Swarm、Kubernetes、黄牛等)，您都将在这里执行某种触发命令。</p><h1 id="1042" class="ky kz hu bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv dt translated">运行管道！</h1><p id="545f" class="pw-post-body-paragraph ir is hu it b iu lw iw ix iy lx ja jb jc ly je jf jg lz ji jj jk ma jm jn jo hn dt translated">一切准备就绪！现在让我们做一些编辑并触发管道。您应该会看到类似这样的内容:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mn"><img src="../Images/43f07aeda0894f757d68ce3e9a1ff4a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2lx06h3dpXQmQfRMXHa7wA.png"/></div></div></figure><p id="6cef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您应该看到测试通过了，图像也发布了。<strong class="it hv">自动化全流水线！</strong></p><h1 id="007e" class="ky kz hu bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv dt translated">包扎</h1><p id="bcff" class="pw-post-body-paragraph ir is hu it b iu lw iw ix iy lx ja jb jc ly je jf jg lz ji jj jk ma jm jn jo hn dt translated">在本帖中，我们为OpenFaaS创建了一个完整的CI/CD管道。可以把服务换成自己喜欢的，GitLab，Gogs，Jenkins，Circle CI，GoCD，Drone等。(随你怎么说),你可以在云中或内部任何你喜欢的地方无缝地使用它们。不用说，能够完全控制管道是一个巨大的优势！</p><p id="d14d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尽管如此，仍有一些我们可以改进的地方，包括:</p><ul class=""><li id="32ed" class="kg kh hu it b iu iv iy iz jc ki jg kj jk kk jo kl km kn ko dt translated">每次更新docker以在流水线的开始使用docker-compose <code class="eh ku kv kw kx b">ver: 3.2</code>需要一点时间。希望有某种方式来切换特拉维斯的docker版本</li><li id="c76a" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated">CI每次都下载<code class="eh ku kv kw kx b">faas-cli</code>。也许我们可以创建一个<code class="eh ku kv kw kx b">faas-cli</code>容器，并在管道中重用它，利用图像缓存的优势。</li></ul><p id="31d8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你有任何想法，请随时与<a class="ae jp" href="https://twitter.com/kenfdev" rel="noopener ugc nofollow" target="_blank"> me </a>分享！也会喜欢反馈！</p><p id="4e76" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">延伸阅读:</p><ul class=""><li id="087f" class="kg kh hu it b iu iv iy iz jc ki jg kj jk kk jo kl km kn ko dt translated">你可以在这里找到这篇文章项目的完整回购:【https://github.com/kenfdev/faas-echo】T5</li><li id="ff32" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated">如果你还没有，你一定要看看Alex的“OpenFaaS:与Alex Ellis一起在60秒内从零到无服务器”:</li></ul><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mo mp l"/></div></figure><p id="27aa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="mq">如果你对OpenFaaS感兴趣，请给</em><a class="ae jp" href="https://github.com/openfaas/faas" rel="noopener ugc nofollow" target="_blank"><em class="mq">GitHub repo</em></a><em class="mq">打一个</em> <strong class="it hv"> <em class="mq">星</em> </strong> <em class="mq">以示支持！</em></p></div></div>    
</body>
</html>