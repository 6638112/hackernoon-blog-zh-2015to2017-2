# Python 生成器函数背后的魔力

> 原文：<https://medium.com/hackernoon/the-magic-behind-python-generator-functions-bc8eeea54220>

![](img/a18f830368fa79a9123e790546c8fb29.png)

Photo by [Kaique Rocha](https://www.pexels.com/u/kaiquestr/)

生成器函数是 Python 编程语言最酷的特性之一。网上有许多文章描述了生成器函数在我们的 python 程序的速度、可伸缩性和内存效率方面提供的许多好处。然而，并没有太多的材料来揭示生成器函数在幕后实际上是如何工作的。本文试图通过揭示 python 编程语言的一些关键特性来填补这一空白，这些特性使得生成器函数成为可能。

赋予发生器函数超能力的基本特征是能够在任何时候从任何函数中**暂停**然后**恢复** 。函数暂停后，生成器函数的本地状态保持不变，并在函数再次恢复时可用。这怎么可能呢？如何暂停一个函数，然后恢复它的本地状态不变？据我们所知，函数有单个**入口点** 和多个出口点**(**返回** 语句)。每次我们调用一个函数，代码从函数的第一行开始执行，直到遇到一个出口点。此时，控制权返回给函数的调用方，函数的局部变量堆栈被清除，相关的内存被操作系统回收。**

**然而，生成器函数并不这样运行。他们有**多个** 出入境点。生成器函数中的每个 **yield** 语句同时定义了一个退出点和一个重入点。发生器功能的执行一直持续到遇到 **yield** 语句。此时，函数的本地状态被保留，控制流被交给生成器函数的调用者。当发生器功能恢复时(通过调用下一个的**，**发送**或通过循环** *的**)，调用***其最后已知的本地状态，并从发生器功能最后暂停的 **yield** 语句后的行开始执行。这种行为令人难以置信，不符合函数的正常行为。**

**为了尝试和理解生成器函数背后的魔力，让我们从仔细观察一个普通函数开始:**

**每次调用 **add_two_numbers** 时，我们期望 CPython 解释器创建一个新的堆栈帧对象，并在该对象的上下文中执行 **add_two_numbers** 函数。我们期望局部变量 *s* 被推到堆栈框架上，并保持在那里，直到函数退出。在函数退出时，我们希望相关的堆栈帧被清空，相应的内存被回收。让我们确认这是事实:**

**我们使用内置的 **inspect** 模块来捕获 **add_two_numbers** 函数的当前执行帧。最后，我们打印堆栈框架对象和任何与之相关的局部变量。我们希望堆栈框架是空的，因此没有局部变量。让我们继续执行上面的代码片段:**

**什么？！在对 **add_two_numbers** 的调用结束后，堆栈框架及其所有相关的局部变量仍然存在！这里发生了什么事？我们在 CPython 中偶然发现了内存泄漏吗？不，事实并非如此。这个观察让我们想到了 Python 堆栈帧的一个基本特征: **Python 堆栈帧不在堆栈内存上分配。相反，它们被分配在堆内存中**。这实质上意味着 python 堆栈帧可以比它们各自的函数调用活得长！生成器函数利用这种行为来施展它们的魔法。**

**当 CPython 编译器在函数中遇到 **yield** 语句时，它会在编译后的[代码对象](https://docs.python.org/3.6/reference/datamodel.html)上设置一个标志，告诉 CPython 解释器该函数是一个生成器函数。我们可以使用 **dis** 模块来看看这是怎么回事:**

**当 CPython 解释器看到与函数相关的代码对象上的 ***生成器*** 标志时，它不执行函数，而是返回一个生成器对象。生成器对象是一个迭代器。这意味着我们可以使用 next 关键字或 for 循环来遍历它。**

**当我们遍历生成器函数时，执行会继续，直到遇到一个 **yield** 语句。此时，函数的堆栈框架被冻结，控制权返回给生成器函数的调用方。**

**当我们通过调用下一个的**或通过**的*调用循环*** *，*继续执行生成器函数时，执行正好从上次停止的点开始(最后一个**产生**语句)。CPython 解释器如何知道生成器函数实例的执行最后一次停止在哪里？它通过与正在执行的生成器实例相关联的堆栈框架对象来了解这一点。****

**我们之前看到 Python 堆栈帧是在堆内存上分配的，它们的状态在后续调用生成器函数实例上的 **next** 或 **send** 之间被保留(当然，生成器函数的每个新实例都获得一个新的堆栈帧)。除了存储关于局部和全局变量的信息，python 堆栈帧还封装了其他有用的信息。一条这样的信息是**最后的** **指令** **指针**。**

****最后指令指针** 是与生成器函数体相关联的代码对象的字节码串的索引，并且指向在堆栈框架的上下文中运行的最后字节码指令。当一个生成器函数的实例被恢复时，CPython 解释器使用**关联堆栈帧上的**最后指令指针** 来确定从哪里开始执行生成器函数的代码对象。我们可以使用由 **dis** 模块*提供的便利的 **disco** 方法来交互地看到这一点:*****

****我们创建一个简单的生成函数，它产生两个数字。调用生成器函数会创建并返回一个生成器对象。在这个调用过程中，生成器函数体中没有代码被执行，并且**最后一个指令指针**被初始化为-1。当我们通过调用 next 开始执行生成器函数时，**最后一条指令指针**从一条 yield 语句前进到另一条语句(在上面的代码片段中，每次调用 next 后**最后一条指令指针**的当前位置由→表示)，暂停然后从同一点恢复，直到生成器函数用尽并抛出 StopIteration 异常。****

****总结一下，要记住的关键是 python 生成器封装了一个堆栈帧和一个代码对象。堆栈帧被分配在堆内存中，并保存一个指针，指向在堆栈帧上下文中的代码对象上运行的最后一个字节码指令。最后一个指令指针告诉 CPython 解释器，当一个生成器函数恢复时，下一个要执行哪一行。这些是生成器功能赖以发展的核心构件。****

****如果你喜欢冒险，你可以通过 ***Python/ceval.c*** 中的 **_PyEval_EvalCodeWithName** 函数和 CPython 源代码中的**Python/ge object . c***模块来查看实现细节。这篇博客是用 CPython 3.6 的源代码写的。*****

*****如果发生器函数对你来说是一个谜，希望这篇文章有助于澄清发生器函数是如何工作的。*****