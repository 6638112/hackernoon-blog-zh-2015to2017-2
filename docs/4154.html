<html>
<head>
<title>Error Handling in C++ or: Why You Should Use Eithers in Favor of Exceptions and Error-codes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++中的错误处理或:为什么你应该使用这两者之一来支持异常和错误代码</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/error-handling-in-c-or-why-you-should-use-eithers-in-favor-of-exceptions-and-error-codes-f0640912eb45?source=collection_archive---------0-----------------------#2017-05-16">https://medium.com/hackernoon/error-handling-in-c-or-why-you-should-use-eithers-in-favor-of-exceptions-and-error-codes-f0640912eb45?source=collection_archive---------0-----------------------#2017-05-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="0dd0" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">TL；速度三角形定位法(dead reckoning)</h1><p id="90bf" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">考虑使用任一类型来处理错误，因为它们将错误提升到类型系统中，并且具有与错误代码相同的性能特征。</p><h2 id="f108" class="kn is hu bd it ko kp kq ix kr ks kt jb ka ku kv jf ke kw kx jj ki ky kz jn la dt translated">任一实现</h2><ul class=""><li id="341f" class="lb lc hu jr b js jt jw jx ka ld ke le ki lf km lg lh li lj dt translated"><a class="ae lk" href="https://github.com/loopperfect/neither" rel="noopener ugc nofollow" target="_blank">loop perfect/never</a></li><li id="a52c" class="lb lc hu jr b js ll jw lm ka ln ke lo ki lp km lg lh li lj dt translated"><a class="ae lk" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4109.pdf" rel="noopener ugc nofollow" target="_blank">标准::预期</a></li><li id="ef2c" class="lb lc hu jr b js ll jw lm ka ln ke lo ki lp km lg lh li lj dt translated"><a class="ae lk" href="https://ned14.github.io/boost.outcome/md_doc_md_02-tutorial_a.html" rel="noopener ugc nofollow" target="_blank">助推::预期</a></li><li id="5120" class="lb lc hu jr b js ll jw lm ka ln ke lo ki lp km lg lh li lj dt translated"><a class="ae lk" href="https://github.com/beark/ftl" rel="noopener ugc nofollow" target="_blank"> beark/ftl </a></li></ul><figure class="lr ls lt lu fq lv fe ff paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="fe ff lq"><img src="../Images/7557ee5345ea8aa7ba96b9fb3a2f6034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nkOUC8BfJFpuXp1_EVvWqw.jpeg"/></div></div></figure><h1 id="e33a" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">介绍</h1><p id="1683" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">编程语言设计总是一个权衡的问题。在C++的情况下，设计者优化了两件事:<em class="mc">运行时效率</em>和<em class="mc">高级抽象</em>。这在许多方面给了C++程序员巨大的灵活性，其中之一就是错误处理。</p><h1 id="13b9" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">异常和尝试捕捉</h1><p id="18d1" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">传统上，Try-catch被认为是C++中最常见的错误处理方法。</p><figure class="lr ls lt lu fq lv"><div class="bz el l di"><div class="md me l"/></div><figcaption class="mf mg fg fe ff mh mi bd b be z ek">Catching a divide-by-zero error</figcaption></figure><h2 id="c1e5" class="kn is hu bd it ko kp kq ix kr ks kt jb ka ku kv jf ke kw kx jj ki ky kz jn la dt translated">异常开销</h2><p id="9f9c" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">try-catch语言特性不是零成本的，确切的价格由编译器实现决定。在成功分支和失败分支中，实现者可以在增加代码大小和增加运行时开销之间进行选择。</p><p id="4f40" class="pw-post-body-paragraph jp jq hu jr b js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km hn dt translated">在大多数C++实现中，已经做出了一个有趣的选择:<code class="eh mo mp mq mr b">try</code>块中的代码运行起来和其他任何代码一样快。然而，分派到<code class="eh mo mp mq mr b">catch</code>块要慢几个数量级。这种损失随着调用堆栈的深度而线性增长。</p><p id="13d2" class="pw-post-body-paragraph jp jq hu jr b js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km hn dt translated">异常对您的项目是否有意义将取决于抛出异常的频率。如果错误率超过1%，那么开销可能会比其他方法大。(<a class="ae lk" href="https://youtu.be/XVofgKH-uu4?t=1h2m24s" rel="noopener ugc nofollow" target="_blank">来源</a>)</p><p id="551d" class="pw-post-body-paragraph jp jq hu jr b js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km hn dt translated">异常不是所有平台都支持的，<code class="eh mo mp mq mr b">throw</code>不容易被c理解的方法</p><h2 id="bf9c" class="kn is hu bd it ko kp kq ix kr ks kt jb ka ku kv jf ke kw kx jj ki ky kz jn la dt translated">人类工程学</h2><p id="1f44" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">异常很容易使用，也很容易推理。您可以在代码的任何地方<code class="eh mo mp mq mr b">throw</code>和<code class="eh mo mp mq mr b">catch</code>异常，异常甚至可以是任意类型。</p><p id="e69d" class="pw-post-body-paragraph jp jq hu jr b js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km hn dt translated">最大的缺点是处理异常不是由类型系统强制执行的。例如，与Java不同，Java中的异常必须由调用者捕获，捕获C++异常是可选的。这意味着在代码审查期间发现所有未处理的异常将是一项挑战，需要对所有调用的函数有深入的了解。</p><h2 id="0b51" class="kn is hu bd it ko kp kq ix kr ks kt jb ka ku kv jf ke kw kx jj ki ky kz jn la dt translated">但是<code class="eh mo mp mq mr b">noexcept </code>和throw呢？</h2><p id="d4b8" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">一个常见的误解是用<code class="eh mo mp mq mr b">noexcept</code>或<code class="eh mo mp mq mr b">throw</code>注释函数会有所帮助。</p><figure class="lr ls lt lu fq lv"><div class="bz el l di"><div class="md me l"/></div></figure><p id="b7c5" class="pw-post-body-paragraph jp jq hu jr b js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km hn dt translated">不幸的是，<code class="eh mo mp mq mr b">noexcept</code>和<code class="eh mo mp mq mr b">throw</code>只是规定在抛出一个未提及的异常的情况下调用<code class="eh mo mp mq mr b">std::terminate</code>。<em class="mc">这不会在编译时强制执行任何异常处理。</em></p><p id="7ea4" class="pw-post-body-paragraph jp jq hu jr b js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km hn dt translated">比如这些会编译抛出一个运行时错误！</p><figure class="lr ls lt lu fq lv"><div class="bz el l di"><div class="md me l"/></div><figcaption class="mf mg fg fe ff mh mi bd b be z ek">noexcept will not save you!</figcaption></figure><h1 id="a1d5" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">错误代码</h1><p id="8461" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">错误代码是古老的，到处都在使用。为了简单起见，让我们假设错误代码只是整数，但是它们可以被实现为类型安全的枚举或者甚至是复杂的对象。对于这次讨论来说，这并不重要。</p><p id="7375" class="pw-post-body-paragraph jp jq hu jr b js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km hn dt translated">有3种常见的错误代码实现形式。</p><h2 id="3313" class="kn is hu bd it ko kp kq ix kr ks kt jb ka ku kv jf ke kw kx jj ki ky kz jn la dt translated">1.作为返回值的错误代码</h2><p id="b5bd" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">这种模式在许多C APIs中都可以找到，因为它很容易实现，而且除了错误处理本身之外，没有性能开销。</p><figure class="lr ls lt lu fq lv"><div class="bz el l di"><div class="md me l"/></div></figure><p id="130c" class="pw-post-body-paragraph jp jq hu jr b js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km hn dt translated">可以非常武断地遵循这种模式，并且很容易在代码审查中验证所有的情况都被处理了。使用错误代码编写一个C友好的API是很容易的。</p><p id="ea04" class="pw-post-body-paragraph jp jq hu jr b js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km hn dt translated">不幸的是，它有一些缺点:</p><ul class=""><li id="f823" class="lb lc hu jr b js mj jw mk ka ms ke mt ki mu km lg lh li lj dt translated">功能组合很难。返回值被错误代码占用，所以结果必须是out变量，这使得函数不纯。</li><li id="bd95" class="lb lc hu jr b js ll jw lm ka ln ke lo ki lp km lg lh li lj dt translated">Out参数强制执行对优化器不友好的内存布局。</li><li id="ada4" class="lb lc hu jr b js ll jw lm ka ln ke lo ki lp km lg lh li lj dt translated">将错误处理从计算中分离出来是很困难的。</li><li id="7317" class="lb lc hu jr b js ll jw lm ka ln ke lo ki lp km lg lh li lj dt translated">推迟错误处理需要程序员通过调用图来处理错误代码。</li></ul><h2 id="2ad6" class="kn is hu bd it ko kp kq ix kr ks kt jb ka ku kv jf ke kw kx jj ki ky kz jn la dt translated">2.作为输出参数的错误代码</h2><p id="e0fc" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">交换out-parameter和返回值的语义没有显著的优势，除了可能稍微干净一点的API。在可以省略错误代码的情况下，API的使用得到了简化，功能组合变得更加容易。</p><p id="73c3" class="pw-post-body-paragraph jp jq hu jr b js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km hn dt translated">这种方法可以在<code class="eh mo mp mq mr b">boost::asio</code>中找到(事实上<code class="eh mo mp mq mr b">boost::asio</code>甚至让它成为可选的，如果没有提供out-parameter，就退回到抛出异常)。</p><h2 id="f407" class="kn is hu bd it ko kp kq ix kr ks kt jb ka ku kv jf ke kw kx jj ki ky kz jn la dt translated">3.错误单例</h2><p id="de97" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">错误单件有完全不同的人体工程学。它们大多出现在实现系统全局状态机的低级库中，比如驱动程序。一个突出的例子是OpenGL。</p><p id="4952" class="pw-post-body-paragraph jp jq hu jr b js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km hn dt translated">使用错误单例如下所示:</p><figure class="lr ls lt lu fq lv"><div class="bz el l di"><div class="md me l"/></div></figure><p id="1ffc" class="pw-post-body-paragraph jp jq hu jr b js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km hn dt translated">在这个范例中，驱动程序的状态必须在运行时通过一个单独的函数来查询。这似乎给了您更多的自由，因为您可以在最合适的时候查询错误，使您能够更好地分离关注点。这允许用户编写类似于基于异常的代码，但没有自动堆栈展开的成本。</p><p id="9837" class="pw-post-body-paragraph jp jq hu jr b js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km hn dt translated">API消费者的好处:</p><ul class=""><li id="d997" class="lb lc hu jr b js mj jw mk ka ms ke mt ki mu km lg lh li lj dt translated">随着时间的推移，错误处理可以减少到最低限度</li><li id="bb44" class="lb lc hu jr b js ll jw lm ka ln ke lo ki lp km lg lh li lj dt translated">错误处理分支越少，性能越好</li><li id="e16f" class="lb lc hu jr b js ll jw lm ka ln ke lo ki lp km lg lh li lj dt translated">不需要外部参数，这增加了功能的组合性</li><li id="920d" class="lb lc hu jr b js ll jw lm ka ln ke lo ki lp km lg lh li lj dt translated">发现错误时，可以手动执行终结</li></ul><p id="56b2" class="pw-post-body-paragraph jp jq hu jr b js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km hn dt translated">但是有一些重要的警告:</p><ul class=""><li id="6b76" class="lb lc hu jr b js mj jw mk ka ms ke mt ki mu km lg lh li lj dt translated">按照设计，单例具有共享状态，因此编写线程安全的代码非常困难</li><li id="b645" class="lb lc hu jr b js ll jw lm ka ln ke lo ki lp km lg lh li lj dt translated">没有计算流水线的捷径，因为没有栈展开发生</li><li id="7611" class="lb lc hu jr b js ll jw lm ka ln ke lo ki lp km lg lh li lj dt translated">不清楚哪些api调用会引发哪些错误。程序员必须检查文档。</li><li id="cbc9" class="lb lc hu jr b js ll jw lm ka ln ke lo ki lp km lg lh li lj dt translated">错误的严重性以及如何从错误中恢复可能不清楚</li></ul><h1 id="bb75" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">那么其他人呢？</h1><p id="02bf" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">任一类型是接受两种不同类型之一的单个值的容器。一个简单的实现可能如下所示:</p><figure class="lr ls lt lu fq lv"><div class="bz el l di"><div class="md me l"/></div><figcaption class="mf mg fg fe ff mh mi bd b be z ek">A simple Either type in C++</figcaption></figure><p id="6559" class="pw-post-body-paragraph jp jq hu jr b js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km hn dt translated">为了对包装后的值进行计算，an可以提供一些有用的方法:<code class="eh mo mp mq mr b">leftMap</code>、<code class="eh mo mp mq mr b">rightMap</code>和<code class="eh mo mp mq mr b">join</code>。</p><ul class=""><li id="3625" class="lb lc hu jr b js mj jw mk ka ms ke mt ki mu km lg lh li lj dt translated"><code class="eh mo mp mq mr b">leftMap</code>将<code class="eh mo mp mq mr b">leftValue</code>转换为一个新值(如果存在)，保持右值不变。</li><li id="49f3" class="lb lc hu jr b js ll jw lm ka ln ke lo ki lp km lg lh li lj dt translated"><code class="eh mo mp mq mr b">rightMap</code>将<code class="eh mo mp mq mr b">rightValue</code>转换为一个新值(如果存在),左值保持不变。</li><li id="e2f5" class="lb lc hu jr b js ll jw lm ka ln ke lo ki lp km lg lh li lj dt translated"><code class="eh mo mp mq mr b">join</code>对任一方的两端进行转换，这两种转换产生相同的类型。这允许要么被统一和展开。</li></ul><p id="57a4" class="pw-post-body-paragraph jp jq hu jr b js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km hn dt translated">这在代码中更容易理解！</p><figure class="lr ls lt lu fq lv"><div class="bz el l di"><div class="md me l"/></div></figure><p id="e24f" class="pw-post-body-paragraph jp jq hu jr b js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km hn dt translated">现在，我们能够将异常提升到类型系统中:</p><figure class="lr ls lt lu fq lv"><div class="bz el l di"><div class="md me l"/></div></figure><figure class="lr ls lt lu fq lv"><div class="bz el l di"><div class="md me l"/></div></figure><h2 id="74d7" class="kn is hu bd it ko kp kq ix kr ks kt jb ka ku kv jf ke kw kx jj ki ky kz jn la dt translated">那么，通过这个简单的改变，我们获得了什么呢？</h2><p id="42e9" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我们不再需要支付异常的开销，并且我们已经将异常类型编码到函数签名中。这记录了源代码中的错误，现在编译器将确保我们正确处理这些类型。</p><p id="a35b" class="pw-post-body-paragraph jp jq hu jr b js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km hn dt translated">这是一件大事，它说明了C++语言是多么强大。</p><h2 id="93ba" class="kn is hu bd it ko kp kq ix kr ks kt jb ka ku kv jf ke kw kx jj ki ky kz jn la dt translated">那么有什么弊端呢？</h2><p id="a755" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">首先，您需要向项目中添加一个任一类型。这里最好不要多此一举，幸好还有<a class="ae lk" href="https://github.com/loopperfect/neither" rel="noopener ugc nofollow" target="_blank">很多</a> <a class="ae lk" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4109.pdf" rel="noopener ugc nofollow" target="_blank">开源</a> <a class="ae lk" href="https://ned14.github.io/boost.outcome/md_doc_md_02-tutorial_a.html" rel="noopener ugc nofollow" target="_blank">实现</a> <a class="ae lk" href="https://github.com/beark/ftl" rel="noopener ugc nofollow" target="_blank">可用</a>。</p><p id="fda0" class="pw-post-body-paragraph jp jq hu jr b js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km hn dt translated">但是性能呢？乍一看，似乎每次调用<code class="eh mo mp mq mr b">leftMap</code>和<code class="eh mo mp mq mr b">rightMap</code>都会给可执行文件增加一个分支。实际上，编译器足够聪明，可以将这些优化掉！</p><p id="9012" class="pw-post-body-paragraph jp jq hu jr b js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km hn dt translated">看看<a class="ae lk" href="https://godbolt.org/g/5f6mT9" rel="noopener ugc nofollow" target="_blank">这个编译器资源管理器项目</a>；各种映射调用的分支会显示出来。</p><p id="4036" class="pw-post-body-paragraph jp jq hu jr b js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km hn dt translated">例如，您可能已经注意到以下标识:</p><pre class="lr ls lt lu fq mv mr mw mx aw my dt"><span id="ad63" class="kn is hu mr b fv mz na l nb nc">e.leftMap(f).leftMap(g) == e.leftmap([](auto x){ return g(f(x)); })</span></pre><p id="70f8" class="pw-post-body-paragraph jp jq hu jr b js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km hn dt translated">事实证明编译器也是如此。它组合两个lambdas来内联整个表达式。在优化步骤之后，所有的抽象都被折叠。一旦编译完成，错误代码实现和基于两者之一的实现之间就没有明显的区别了。</p><h1 id="dfe3" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">结论</h1><p id="195a" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">考虑使用任一类型来处理错误。它们将错误提升到类型系统中，使它们比异常更安全，同时产生与错误代码相同的性能特征。</p><h1 id="f5b3" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">资源</h1><h2 id="16da" class="kn is hu bd it ko kp kq ix kr ks kt jb ka ku kv jf ke kw kx jj ki ky kz jn la dt translated">任一实现</h2><ul class=""><li id="abcd" class="lb lc hu jr b js jt jw jx ka ld ke le ki lf km lg lh li lj dt translated"><a class="ae lk" href="https://github.com/loopperfect/neither" rel="noopener ugc nofollow" target="_blank">完美循环/都不是</a></li><li id="ab21" class="lb lc hu jr b js ll jw lm ka ln ke lo ki lp km lg lh li lj dt translated"><a class="ae lk" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4109.pdf" rel="noopener ugc nofollow" target="_blank"> std::预计</a></li><li id="e067" class="lb lc hu jr b js ll jw lm ka ln ke lo ki lp km lg lh li lj dt translated"><a class="ae lk" href="https://ned14.github.io/boost.outcome/md_doc_md_02-tutorial_a.html" rel="noopener ugc nofollow" target="_blank">助推::预期</a></li><li id="a6f7" class="lb lc hu jr b js ll jw lm ka ln ke lo ki lp km lg lh li lj dt translated"><a class="ae lk" href="https://github.com/beark/ftl" rel="noopener ugc nofollow" target="_blank"> beark/ftl </a></li></ul><h2 id="ce80" class="kn is hu bd it ko kp kq ix kr ks kt jb ka ku kv jf ke kw kx jj ki ky kz jn la dt translated">基准测试错误代码与异常或其他</h2><figure class="lr ls lt lu fq lv"><div class="bz el l di"><div class="nd me l"/></div><figcaption class="mf mg fg fe ff mh mi bd b be z ek"><a class="ae lk" href="https://youtu.be/XVofgKH-uu4?t=1h" rel="noopener ugc nofollow" target="_blank">Mongrel Monads, Dirty, Dirty, Dirty — Niall Douglas [ACCU 2017]</a></figcaption></figure><h2 id="9be3" class="kn is hu bd it ko kp kq ix kr ks kt jb ka ku kv jf ke kw kx jj ki ky kz jn la dt translated">返回值与输出参数</h2><figure class="lr ls lt lu fq lv"><div class="bz el l di"><div class="nd me l"/></div><figcaption class="mf mg fg fe ff mh mi bd b be z ek"><a class="ae lk" href="https://youtu.be/eR34r7HOU14?t=38m" rel="noopener ugc nofollow" target="_blank">2013 Keynote: Chandler Carruth: Optimizing the Emergent Structures of C++</a></figcaption></figure><h2 id="7cda" class="kn is hu bd it ko kp kq ix kr ks kt jb ka ku kv jf ke kw kx jj ki ky kz jn la dt translated">一些代码示例</h2><ul class=""><li id="dc40" class="lb lc hu jr b js jt jw jx ka ld ke le ki lf km lg lh li lj dt translated">gist:<a class="ae lk" href="https://gist.github.com/nikhedonia/db401285d9f3816e2a74d78c68dd4c6c" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nikhedonia/db 401285d 9 f 3816 e 2 a 74d 78 c 68 DD 4c 6 c</a></li><li id="2762" class="lb lc hu jr b js ll jw lm ka ln ke lo ki lp km lg lh li lj dt translated">组装:<a class="ae lk" href="https://godbolt.org/g/5f6mT9" rel="noopener ugc nofollow" target="_blank">https://godbolt.org/g/5f6mT9</a></li></ul><div class="lr ls lt lu fq ab cb"><figure class="ne lv nf ng nh ni nj paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="ne lv nf ng nh ni nj paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="ne lv nf ng nh ni nj paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="nk nl nm"><p id="f922" class="jp jq mc jr b js mj ju jv jw mk jy jz nn ml kc kd no mm kg kh np mn kk kl km hn dt translated"><a class="ae lk" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是AMI家庭的一员。我们现在<a class="ae lk" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae lk" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jp jq mc jr b js mj ju jv jw mk jy jz nn ml kc kd no mm kg kh np mn kk kl km hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lk" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lk" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lr ls lt lu fq lv fe ff paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="fe ff nq"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="lr ls lt lu fq lv"><div class="bz el l di"><div class="nr me l"/></div></figure></div></div>    
</body>
</html>