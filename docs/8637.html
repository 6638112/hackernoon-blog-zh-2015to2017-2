<html>
<head>
<title>How Stickler CI grew from a prototype to a product</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Stickler CI如何从原型发展成为产品</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-stickler-ci-grew-from-a-prototype-to-a-product-6d2a58987ac1?source=collection_archive---------15-----------------------#2017-12-08">https://medium.com/hackernoon/how-stickler-ci-grew-from-a-prototype-to-a-product-6d2a58987ac1?source=collection_archive---------15-----------------------#2017-12-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="e017" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">关于本系列文章</h1><p id="7852" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">在这个由三部分组成的系列中，我将讲述过去两年中Stickler CI从最初的原型到今天的演变。这篇具体的文章将介绍我如何将Stickler CI从一个无利可图的项目变成一个创收产品，以及围绕这一过程的成长烦恼。</p><p id="91ba" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated"><a class="ae ks" href="https://stickler-ci.com/" rel="noopener ugc nofollow" target="_blank"> Stickler CI </a>是一款软件即服务应用，自动化了代码评审的繁琐部分；强制样式和检查lint错误。它与GitHub集成，并检查每个pull请求的代码风格错误。当你的团队中有人犯了风格错误时，坚持不懈的CI会留下评论。这可以节省您的时间，因为对样式错误的反馈是自动处理的，您的团队不必通读构建报告来查找空白错误。我们的商业模式是免费访问公共存储库，而私人存储库需要付费。</p><h2 id="c9dc" class="kt is hu bd it ku kv kw ix kx ky kz jb ka la lb jf ke lc ld jj ki le lf jn lg dt translated">真正的客户，真正的问题</h2><p id="93b8" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">2017年1月，Stickler CI吸引了第一个付费客户。随着时间的推移，技术挑战不断增加，我们开始获得更多的客户。我们的一些不幸包括取消、<a class="ae ks" href="https://hackernoon.com/tagged/security" rel="noopener ugc nofollow" target="_blank">安全</a>，扩大审查工作和处理增加的需求。</p><h2 id="3af5" class="kt is hu bd it ku kv kw ix kx ky kz jb ka la lb jf ke lc ld jj ki le lf jn lg dt translated">不完全取消</h2><p id="d898" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">在第一个实现中，我们没有构建处理取消的工作流。我们认为，由于付费用户如此之少，客户流失在一段时间内不会发生。令我们惊讶的是，一位客户升级并需要取消的速度比我们预期的要快得多。这导致了通过电子邮件的手动取消，以及随后适当的取消工作流的实施。除了自愿取消，一个完善的计费集成需要处理由于未付款而导致的取消。在我们急于获得付费计划的过程中，我们也忽略了构建这一功能。这导致一些以前的客户在他们的订阅被取消后可以访问私有存储库。为了纠正这个疏忽，我们实现了<strong class="jr hv">customer . subscription . deleted</strong>和<strong class="jr hv">invoice . payment _ failed</strong>webhooks，当订阅错过付款或因错过付款而被取消时，Stripe会发送这些web hooks。今天，当这些网页挂钩到达时，订阅在我们的本地数据库中被取消，防止<a class="ae ks" href="https://hackernoon.com/tagged/future" rel="noopener ugc nofollow" target="_blank">未来</a>对私人储存库的评论。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lh"><img src="../Images/ef663c5071d23324d8501cb49787a2c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-8lMpLol5QMyBEeJ."/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek">Stripe Webhook workflow</figcaption></figure><h2 id="59b5" class="kt is hu bd it ku kv kw ix kx ky kz jb ka la lb jf ke lc ld jj ki le lf jn lg dt translated">安全第二</h2><p id="e253" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">最初提供的另一个问题是我们支持linters，允许用户使用他们用自己的代码创建的林挺规则。创建自定义规则的能力允许用户在Stickler CI服务器上运行他们想要的任何代码。这带来了一个很大的安全问题，因为恶意用户可以手工定制代码来获取API凭证或其他私人信息。为了弥补这一缺陷，审查作业和linter执行被移到docker容器中，该容器不能访问包含机密的主机文件系统。启动后，worker作业在运行linters之前放弃特权，成为无特权用户。删除特权可以防止自定义linter代码访问创建容器时使用的环境变量。</p><h2 id="d739" class="kt is hu bd it ku kv kw ix kx ky kz jb ka la lb jf ke lc ld jj ki le lf jn lg dt translated">保持工人可用</h2><p id="4fc3" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我们在审核工作的运作方式上走了很多弯路，以便快速向市场发布更具粘性的CI。一些linters，比如phpcs和eslint，支持在用户的应用程序代码中定义lint规则。这些linter让我们面临这样的风险:恶意用户可能会在他们的自定义linter规则中放入一个无限循环。一个无限循环将导致一个锁定的审查工作线程，停止所有其他用户的审查。通过终止运行时间超过10分钟的审查作业，降低了这一风险。我们再也不用担心令人不快的用户占用我们的服务器，出现无限循环，要求我们提供更多的工作人员并影响Stickler CI的盈利能力。</p><h2 id="cf7e" class="kt is hu bd it ku kv kw ix kx ky kz jb ka la lb jf ke lc ld jj ki le lf jn lg dt translated">记忆是变化无常的东西</h2><p id="e8ea" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">您可能还记得上一篇文章，Stickler CI最初部署在一台服务器上。我们没有预料到那个时期会有多短暂。</p><p id="3111" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">最初，网络服务器有1GB的内存，但随着审查工作流量的增加，很快就超载了。作为回应，那台机器被升级到2GB，但在将审查作业转移到docker后不久，我们开始看到各种进程被我的克星OOMKiller(内存不足黑仔)终止。系统日志包含许多“终止进程”日志消息。这告诉我们，是时候增加更多容量了，因为我们的生产环境已经超负荷了。</p><p id="3651" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">通过拼凑一个可行的剧本和一些手动配置，我们很快就组装了一台“工人”机器。这个配置让我们可以将docker和检查作业处理转移到新的机器上，释放主服务器上宝贵的RAM。我们还向工作主机和web服务器主机添加了小型交换驱动器。这让我们可以处理一些流量高峰，并阻止OOMKiller。这种变化产生的架构看起来像:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div class="fe ff lx"><img src="../Images/1e5635c70c9b68de95ccafae1b923514.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/0*Jx9DeO4KQPA9x1iC."/></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek">v2 of the Stickler CI architecture</figcaption></figure><p id="e8ef" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">这个配置允许worker节点连接到web服务器上的RabbitMQ，但是在自己的docker守护进程上运行检查作业。来自工人的日志被转发到网络服务器，使我们能够进行集中记录，这使得故障排除更加容易。通过在worker上运行docker和审查作业，我们可以更好地管理和隔离审查作业使用的资源(时间和内存),并保护我们的web服务器和数据库免受昂贵的审查作业工作量的影响。docker容器处理向GitHub发布评论，并允许我们轻松地对失败的作业重新排队。</p><h1 id="8284" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">结论</h1><p id="9325" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">纠正这些捷径的最终结果是一个更有利可图、高性能、安全的产品。Stickler CI体验到了能够接纳更多用户、更多评论和更多收入所带来的业务影响。下一篇文章将调查我们匆忙构建的worker node解决方案的后果以及自托管电子邮件的噩梦。</p><figure class="li lj lk ll fq lm"><div class="bz el l di"><div class="ly lz l"/></div></figure></div></div>    
</body>
</html>