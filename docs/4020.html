<html>
<head>
<title>Understand the keyword “this” in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript中的关键字“this”</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/get-your-head-around-this-73c23653b102?source=collection_archive---------5-----------------------#2017-05-07">https://medium.com/hackernoon/get-your-head-around-this-73c23653b102?source=collection_archive---------5-----------------------#2017-05-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="4384" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">JavaScript中的“<code class="eh jj jk jl jm b">this"</code>关键字可能会引起混淆。我们来揭秘一下吧！</h2></div><figure class="jo jp jq jr fq js fe ff paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="fe ff jn"><img src="../Images/d4265af439f787a8280f164c95c6c4c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FTiIwQEmhMqsqX-cVWJtHQ.jpeg"/></div></div></figure><p id="e3fb" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在<a class="ae kv" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>中，<code class="eh jj jk jl jm b">this</code>关键字的用法与我们在普通句子中使用它的用法相同:它指的是我们之前已经介绍过的内容。</p><p id="ba25" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如果我说:<em class="kw">“我昨天在一个网络大会上遇到了加里·韦纳尔查克。这家伙太厉害了。”</em>，你马上明白“这家伙”指的是加里·韦纳尔楚克。</p><p id="d3bf" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">同样，在JavaScript中使用时，<code class="eh jj jk jl jm b">this</code>指的是一个对象，更确切地说是调用代码的对象。</p><p id="f4e9" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">考虑这个例子:</p><figure class="jo jp jq jr fq js"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="8608" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">→ <a class="ae kv" href="https://jsbin.com/cijojefuja/edit?js,console" rel="noopener ugc nofollow" target="_blank">自己试试</a></p><p id="6448" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们创建了一个带有属性的<code class="eh jj jk jl jm b">customer</code>对象和一个<code class="eh jj jk jl jm b">greetCustomer</code>方法。该方法使用关键字<code class="eh jj jk jl jm b">this</code>来引用<code class="eh jj jk jl jm b">customer</code>对象。</p><p id="e96d" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">注意<code class="eh jj jk jl jm b">this</code>能够访问对象的属性(<code class="eh jj jk jl jm b">firstName</code>和<code class="eh jj jk jl jm b">lastName</code>)。这是因为<strong class="kb hv">不仅</strong> <code class="eh jj jk jl jm b"><strong class="kb hv">this</strong></code> <strong class="kb hv"> <em class="kw">引用</em>到</strong> <code class="eh jj jk jl jm b"><strong class="kb hv">customer</strong></code> <strong class="kb hv">对象，而且<em class="kw">包含</em>对象</strong>的值:因此它可以访问对象的方法和属性。</p><p id="7079" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">当<code class="eh jj jk jl jm b">greetCustomer</code>方法被调用时，方法内的<code class="eh jj jk jl jm b">this</code>自动引用调用该方法的对象:对象<code class="eh jj jk jl jm b">customer</code>。但是在方法被调用之前，这一点非常重要，没有给<code class="eh jj jk jl jm b"><em class="kw">this</em></code> <em class="kw">赋值</em>。</p><p id="26cd" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这是什么意思？</p><p id="b443" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">以这个函数为例:</p><pre class="jo jp jq jr fq kz jm la lb aw lc dt"><span id="4f99" class="ld le hu jm b fv lf lg l lh li">var sayCatName = function(catName){<br/>  	console.log("My cat's name is " + catName);<br/>};</span></pre><p id="5be2" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">它要打印什么？嗯，目前还不多，我们已经<em class="kw">定义了</em>函数，但是我们不知道<code class="eh jj jk jl jm b">catName</code>的值，直到我们<em class="kw">调用</em>函数并给它传递一个猫的名字:</p><pre class="jo jp jq jr fq kz jm la lb aw lc dt"><span id="5ac2" class="ld le hu jm b fv lf lg l lh li">sayCatName('Alphonse'); // Prints "My cat's name is Alphonse"</span></pre><p id="5406" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这也是关键字<code class="eh jj jk jl jm b">this</code>背后完全相同的想法:我们不知道它指的是什么，直到一个对象调用定义了<code class="eh jj jk jl jm b">this</code>的函数。换句话说，<code class="eh jj jk jl jm b">this</code>关键字直到定义它的函数被实际调用时才会被赋值。</p><p id="8c7b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">所以<strong class="kb hv">每当你试图弄清楚</strong> <code class="eh jj jk jl jm b"><strong class="kb hv">this</strong></code> <strong class="kb hv">关键字指的是什么时，问问自己这个问题:<em class="kw">“这个函数在哪里被调用？”</em> </strong>。不是定义它的地方，而是调用它的地方。</p><blockquote class="lj"><p id="0f71" class="lk ll hu bd lm ln lo lp lq lr ls ku ek translated">每当你试图弄清楚<code class="eh jj jk jl jm b">this</code>关键字指的是什么时，问问自己这个问题:<em class="lt">“这个函数在哪里被调用？”</em>。不是定义它的地方，而是调用它的地方。</p></blockquote><p id="912d" class="pw-post-body-paragraph jz ka hu kb b kc lu iv ke kf lv iy kh ki lw kk kl km lx ko kp kq ly ks kt ku hn dt translated">这是一个基本的例子，在我们的代码中，有时更难确定<code class="eh jj jk jl jm b">this</code>指的是什么。现在，让我们深入了解允许我们这样做的四条规则:</p><ul class=""><li id="6c84" class="lz ma hu kb b kc kd kf kg ki mb km mc kq md ku me mf mg mh dt translated"><strong class="kb hv">隐式绑定</strong>(当<code class="eh jj jk jl jm b">this</code>在声明的对象内部时)</li><li id="cd47" class="lz ma hu kb b kc mi kf mj ki mk km ml kq mm ku me mf mg mh dt translated"><strong class="kb hv">显式绑定</strong>(当我们使用<code class="eh jj jk jl jm b">call</code>、<code class="eh jj jk jl jm b">apply</code>或<code class="eh jj jk jl jm b">bind</code>显式设置<code class="eh jj jk jl jm b">this</code>的值时)</li><li id="fa97" class="lz ma hu kb b kc mi kf mj ki mk km ml kq mm ku me mf mg mh dt translated"><strong class="kb hv">全局上下文</strong>(当<code class="eh jj jk jl jm b">this</code>在声明对象之外时)</li><li id="4ffa" class="lz ma hu kb b kc mi kf mj ki mk km ml kq mm ku me mf mg mh dt translated"><strong class="kb hv"/><code class="eh jj jk jl jm b"><strong class="kb hv">new</strong></code><strong class="kb hv">关键字</strong>(创建新对象时)</li></ul><h1 id="124c" class="mn le hu bd mo mp mq mr ms mt mu mv mw ja mx jb my jd mz je na jg nb jh nc nd dt translated">1.隐式绑定(当<code class="eh jj jk jl jm b">this</code>在声明的对象内时)</h1><p id="1d96" class="pw-post-body-paragraph jz ka hu kb b kc ne iv ke kf nf iy kh ki ng kk kl km nh ko kp kq ni ks kt ku hn dt translated">当关键字<code class="eh jj jk jl jm b">this</code>在声明的对象中被发现时，<code class="eh jj jk jl jm b">this</code>的值将总是最近的父对象。</p><p id="b77b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">用新方法考虑我们的客户对象<code class="eh jj jk jl jm b">whatIsMyObject</code>:</p><figure class="jo jp jq jr fq js"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="fbbd" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><a class="ae kv" href="https://jsbin.com/jimiyehaju/edit?js,console" rel="noopener ugc nofollow" target="_blank"> →自己试试</a></p><p id="02eb" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们首先在函数<code class="eh jj jk jl jm b">greetCustomer</code>中找到关键字<code class="eh jj jk jl jm b">this</code>。最接近的父对象是<code class="eh jj jk jl jm b">customer</code>对象，这意味着<code class="eh jj jk jl jm b">this</code>的值是<code class="eh jj jk jl jm b">customer</code>对象。</p><p id="d3aa" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">当我们在函数<code class="eh jj jk jl jm b">whatIsMyObject</code>中单独打印<code class="eh jj jk jl jm b">this</code>时，其最近的父对象也是<code class="eh jj jk jl jm b">customer</code>对象，我们得到了控制台中打印的整个对象，所以我们现在确定<code class="eh jj jk jl jm b">this</code>的值是<code class="eh jj jk jl jm b">customer</code>对象。</p><p id="ab95" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这很好，但是当我们有一个嵌套对象时会发生什么呢？</p><figure class="jo jp jq jr fq js"><div class="bz el l di"><div class="kx ky l"/></div><figcaption class="nj nk fg fe ff nl nm bd b be z ek">A nested object</figcaption></figure><p id="0f19" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><a class="ae kv" href="https://jsbin.com/zecivoneya/edit?js,console" rel="noopener ugc nofollow" target="_blank"> →自己试试</a></p><p id="7667" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们给名为<code class="eh jj jk jl jm b">address</code>的<code class="eh jj jk jl jm b">customer</code>对象添加了一个键。<code class="eh jj jk jl jm b">address</code>的值是另一个对象。在这个对象中，我们有一个<code class="eh jj jk jl jm b">askAddress</code>函数，它使用<code class="eh jj jk jl jm b">this</code>来称呼客户的名字。</p><p id="c73c" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">但是<code class="eh jj jk jl jm b">this</code>似乎无法访问<code class="eh jj jk jl jm b">customer</code>对象的属性<code class="eh jj jk jl jm b">name</code>并打印<em class="kw">“亲爱的未定义，请输入您的地址”</em>。你猜到原因了吗？</p><p id="5aaa" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">让我们回到我们的规则，即<code class="eh jj jk jl jm b">this</code>的值总是最近的父对象:这里我们在<code class="eh jj jk jl jm b">customer</code>对象中，但也在嵌套的<code class="eh jj jk jl jm b">address</code>对象中，当它在函数<code class="eh jj jk jl jm b">askAdress</code>中时，它实际上是<code class="eh jj jk jl jm b">this</code>最近的父对象。</p><p id="9e0a" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">因为<code class="eh jj jk jl jm b">address</code>对象没有属性<code class="eh jj jk jl jm b">firstName</code>，所以<code class="eh jj jk jl jm b">this.firstName</code>是未定义的。我们还可以看到，<code class="eh jj jk jl jm b">address</code>对象内部的<code class="eh jj jk jl jm b">whatIsMyObject</code>函数不再引用<code class="eh jj jk jl jm b">customer</code>，而是引用<code class="eh jj jk jl jm b">address</code>。</p><p id="17fa" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">那么我们该如何解决这个问题呢？如果我们需要我们的<code class="eh jj jk jl jm b">askAddress</code>方法返回客户的名字，该怎么办？我们需要用<code class="eh jj jk jl jm b">call</code>、<code class="eh jj jk jl jm b">apply</code>或<code class="eh jj jk jl jm b">bind</code>方法显式地改变<code class="eh jj jk jl jm b">this</code>的值。</p><h1 id="fb55" class="mn le hu bd mo mp mq mr ms mt mu mv mw ja mx jb my jd mz je na jg nb jh nc nd dt translated">2.显式绑定(当我们使用<code class="eh jj jk jl jm b">call</code>、<code class="eh jj jk jl jm b">apply</code>或<code class="eh jj jk jl jm b">bind</code>显式设置<code class="eh jj jk jl jm b">this</code>的值时)</h1><p id="b6da" class="pw-post-body-paragraph jz ka hu kb b kc ne iv ke kf nf iy kh ki ng kk kl km nh ko kp kq ni ks kt ku hn dt translated">JavaScript中的函数是对象，作为对象，它们有几个方法。当我们想要完全控制关键字<code class="eh jj jk jl jm b">this</code>所指的内容时，我们使用函数的<code class="eh jj jk jl jm b">call</code>、<code class="eh jj jk jl jm b">apply</code>和<code class="eh jj jk jl jm b">bind</code>方法。</p><p id="db2b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">让我们看一下我们在前面的例子中使用的代码:</p><figure class="jo jp jq jr fq js"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="775e" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">之前，我们调用的是返回<em class="kw">“亲爱的未定义……”</em>的<code class="eh jj jk jl jm b">customer.address.askAddress</code>，因为<code class="eh jj jk jl jm b">askAddress</code>函数中<code class="eh jj jk jl jm b">this</code>的值引用了<code class="eh jj jk jl jm b">address</code>对象，而该对象没有<code class="eh jj jk jl jm b">firstName</code>属性。</p><h1 id="f52c" class="mn le hu bd mo mp mq mr ms mt mu mv mw ja mx jb my jd mz je na jg nb jh nc nd dt translated"><code class="eh jj jk jl jm b">call()</code></h1><p id="24ca" class="pw-post-body-paragraph jz ka hu kb b kc ne iv ke kf nf iy kh ki ng kk kl km nh ko kp kq ni ks kt ku hn dt translated">通过使用<code class="eh jj jk jl jm b">call</code>方法，我们可以改变我们想要的<code class="eh jj jk jl jm b">this</code>的值:这里我们将把<code class="eh jj jk jl jm b">this</code>的值改为<code class="eh jj jk jl jm b">customer</code>对象:</p><pre class="jo jp jq jr fq kz jm la lb aw lc dt"><span id="1ec0" class="ld le hu jm b fv lf lg l lh li">customer.address.askAddress.call(customer); // Prints "Dear John, please enter your address"</span></pre><p id="3fd2" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><a class="ae kv" href="https://jsbin.com/nireruvoca/edit?js,console" rel="noopener ugc nofollow" target="_blank"> →自己试试</a></p><p id="3b48" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">成功了！注意，我们不是<em class="kw">调用</em> <code class="eh jj jk jl jm b">askAddress</code>，我们只是<em class="kw">将方法<code class="eh jj jk jl jm b">call</code>附加到</em>上，所以当我们使用<code class="eh jj jk jl jm b">call</code>时在<code class="eh jj jk jl jm b">askAddress</code>方法后面没有括号。</p><p id="246a" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><code class="eh jj jk jl jm b">call</code>方法的参数是我们希望关键字<code class="eh jj jk jl jm b">this</code>引用的，在本例中是<code class="eh jj jk jl jm b">customer</code>对象。</p><h1 id="2f2c" class="mn le hu bd mo mp mq mr ms mt mu mv mw ja mx jb my jd mz je na jg nb jh nc nd dt translated"><code class="eh jj jk jl jm b">apply()</code></h1><p id="6e4c" class="pw-post-body-paragraph jz ka hu kb b kc ne iv ke kf nf iy kh ki ng kk kl km nh ko kp kq ni ks kt ku hn dt translated">当我们对想要使用<code class="eh jj jk jl jm b">call</code>或<code class="eh jj jk jl jm b">apply</code>的函数有参数时，就可以看出<code class="eh jj jk jl jm b">call</code>和<code class="eh jj jk jl jm b">apply</code>的区别。</p><figure class="jo jp jq jr fq js"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="fd90" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们创建了一个新方法<code class="eh jj jk jl jm b">calculateAge</code>，它有两个参数<code class="eh jj jk jl jm b">currentYear</code>和<code class="eh jj jk jl jm b">birthDate</code>。</p><figure class="jo jp jq jr fq js"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="2270" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">→ <a class="ae kv" href="https://jsbin.com/zakawamada/edit?js,console" rel="noopener ugc nofollow" target="_blank">自己试试</a></p><p id="c120" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">两种解决方案都有效，唯一的区别是:</p><ul class=""><li id="2618" class="lz ma hu kb b kc kd kf kg ki mb km mc kq md ku me mf mg mh dt translated">使用<code class="eh jj jk jl jm b">call</code>函数，我们传递由逗号分隔的参数，</li><li id="8ea2" class="lz ma hu kb b kc mi kf mj ki mk km ml kq mm ku me mf mg mh dt translated">使用<code class="eh jj jk jl jm b">apply</code>函数，我们将参数作为数组中的值传递</li></ul><h1 id="4a89" class="mn le hu bd mo mp mq mr ms mt mu mv mw ja mx jb my jd mz je na jg nb jh nc nd dt translated"><code class="eh jj jk jl jm b">bind()</code></h1><p id="7006" class="pw-post-body-paragraph jz ka hu kb b kc ne iv ke kf nf iy kh ki ng kk kl km nh ko kp kq ni ks kt ku hn dt translated"><code class="eh jj jk jl jm b">bind</code>的工作方式与<code class="eh jj jk jl jm b">call</code>类似，但是<em class="kw">并没有立即调用</em>函数，而是返回一个函数<em class="kw">定义</em>，将<code class="eh jj jk jl jm b">this</code>设置为传递给<code class="eh jj jk jl jm b">bind()</code>的第一个参数。</p><figure class="jo jp jq jr fq js"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="3714" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><a class="ae kv" href="https://jsbin.com/nuyajizuyu/edit?js,console" rel="noopener ugc nofollow" target="_blank"> →自己试试</a></p><p id="6845" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><code class="eh jj jk jl jm b">bind</code>允许我们明确地将<code class="eh jj jk jl jm b">this</code>设置为我们想要的对象。它生成一个我们存储在变量<code class="eh jj jk jl jm b">ageOfCustomer3</code>中的<code class="eh jj jk jl jm b">calculateAge</code>函数的副本，但是它不会立即<em class="kw">调用</em>函数。</p><p id="0e21" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们可以稍后在代码中调用该函数，并传递它需要执行的参数。创建带有预置参数的函数是非常有用的，这些函数将在以后被调用，而<code class="eh jj jk jl jm b">this</code>已经被设置为正确的对象。</p><h1 id="0778" class="mn le hu bd mo mp mq mr ms mt mu mv mw ja mx jb my jd mz je na jg nb jh nc nd dt translated">3.全局上下文(当<code class="eh jj jk jl jm b">this</code>在声明的对象之外时)</h1><p id="1838" class="pw-post-body-paragraph jz ka hu kb b kc ne iv ke kf nf iy kh ki ng kk kl km nh ko kp kq ni ks kt ku hn dt translated"><code class="eh jj jk jl jm b">this</code>是在全局上下文中，当你发现它“在野外”，在一个声明的对象之外(意味着没有一个包含关键字<code class="eh jj jk jl jm b">this</code>的对象被定义)。</p><p id="b271" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在这种情况下，它的值引用全局对象，在浏览器中，它对应于<code class="eh jj jk jl jm b">window</code>对象。</p><p id="a618" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">事实上，在全局范围内声明的每个变量实际上都附加到了窗口对象上:</p><figure class="jo jp jq jr fq js"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="bb36" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><a class="ae kv" href="https://jsbin.com/qiyizipujo/edit?js,console" rel="noopener ugc nofollow" target="_blank"> →自己试试</a></p><p id="ca97" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如果我们发现<code class="eh jj jk jl jm b">this</code>在一个常规的函数调用里面(不是一个对象或者一个对象的方法)怎么办？在这种情况下，<code class="eh jj jk jl jm b">this</code>关键字也指向全局对象。</p><figure class="jo jp jq jr fq js"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="3e90" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><a class="ae kv" href="https://jsbin.com/zubixiluto/edit?js,console" rel="noopener ugc nofollow" target="_blank"> →自己试试</a></p><p id="188f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这里当我调用<code class="eh jj jk jl jm b">greetCustomer</code>方法时，<code class="eh jj jk jl jm b">nestedFunction</code>将被调用，并打印全局窗口对象，即使我们在<code class="eh jj jk jl jm b">customer</code>对象内部。这是为什么呢？</p><p id="666d" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这里我们有一个方法内部的常规函数调用，而不是对象的方法。虽然它写在方法内部，但它仍然是一个简单的函数。</p><h1 id="4924" class="mn le hu bd mo mp mq mr ms mt mu mv mw ja mx jb my jd mz je na jg nb jh nc nd dt translated">4.<code class="eh jj jk jl jm b">new</code>关键字</h1><p id="a3e7" class="pw-post-body-paragraph jz ka hu kb b kc ne iv ke kf nf iy kh ki ng kk kl km nh ko kp kq ni ks kt ku hn dt translated">创建对象的一种方法是使用<code class="eh jj jk jl jm b">new</code>关键字。</p><p id="a3d8" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">考虑定义一个对象的函数Customer:</p><pre class="jo jp jq jr fq kz jm la lb aw lc dt"><span id="4909" class="ld le hu jm b fv lf lg l lh li">function Customer(firstName, lastName) {<br/>  this.firstName = firstName;<br/>  this.lastName = lastName;<br/>}</span></pre><p id="3d84" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在这个函数中，我们用关键字<code class="eh jj jk jl jm b">this</code>定义对象的属性，它们将等于传递给函数的值。</p><p id="e0fb" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">等等，我们在一个函数里面。正如我们前面看到的，<code class="eh jj jk jl jm b">this</code>的值不应该是全局对象吗？</p><p id="37aa" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">但是在这种情况下，我们不会进行常规的函数调用来创建一个新对象。相反，我们将使用<code class="eh jj jk jl jm b">new</code>关键字，规则是当您使用<code class="eh jj jk jl jm b">new</code>关键字时，<code class="eh jj jk jl jm b">this</code>的值会改变。</p><pre class="jo jp jq jr fq kz jm la lb aw lc dt"><span id="a615" class="ld le hu jm b fv lf lg l lh li">var customer1 = new Customer("John", "Smith");</span><span id="69f8" class="ld le hu jm b fv nn lg l lh li">console.log(customer1.firstName + " " + customer1.lastName); // Prints "John Smith"</span></pre><p id="1f40" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><a class="ae kv" href="https://jsbin.com/menitozemi/edit?js,console" rel="noopener ugc nofollow" target="_blank"> →自己试试</a></p><p id="47be" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><code class="eh jj jk jl jm b">this</code>现在指的是使用<code class="eh jj jk jl jm b">new</code>关键字时创建的对象。我们将该对象存储在一个名为<code class="eh jj jk jl jm b">customer1</code>的变量中，该变量现在可以访问<code class="eh jj jk jl jm b">firstName</code>和<code class="eh jj jk jl jm b">lastName</code>属性。</p><h1 id="0c98" class="mn le hu bd mo mp mq mr ms mt mu mv mw ja mx jb my jd mz je na jg nb jh nc nd dt translated">结论</h1><p id="0239" class="pw-post-body-paragraph jz ka hu kb b kc ne iv ke kf nf iy kh ki ng kk kl km nh ko kp kq ni ks kt ku hn dt translated">要知道代码中<code class="eh jj jk jl jm b">this</code>的值是多少，总是要问自己这样一个问题:</p><blockquote class="no np nq"><p id="8a53" class="jz ka kw kb b kc kd iv ke kf kg iy kh nr kj kk kl ns kn ko kp nt kr ks kt ku hn dt translated"><strong class="kb hv">在哪里调用函数？</strong></p></blockquote><p id="8fcf" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><code class="eh jj jk jl jm b">this</code>有一些非常棘手的部分，在本文<a class="ae kv" href="http://javascriptissexy.com/understand-javascripts-this-with-clarity-and-master-it/" rel="noopener ugc nofollow" target="_blank">中有详细介绍</a>:</p><blockquote class="no np nq"><p id="c481" class="jz ka kw kb b kc kd iv ke kf kg iy kh nr kj kk kl ns kn ko kp nt kr ks kt ku hn dt translated">当我们借用一个使用<code class="eh jj jk jl jm b">this</code>的方法时，当我们将一个使用<code class="eh jj jk jl jm b">this</code>的方法赋给一个变量时，当一个使用<code class="eh jj jk jl jm b">this</code>的函数作为回调函数被传递时，当<code class="eh jj jk jl jm b">this</code>被用在一个闭包——一个内部函数中时，<code class="eh jj jk jl jm b">this</code>关键字最容易被误解</p></blockquote><p id="45c1" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在使用原生JavaScript或jQuery之类的库时，您肯定会经常遇到一些现实世界中的问题，在这些情况下，理解<code class="eh jj jk jl jm b">this</code>的基本工作原理会有很大的帮助。</p></div><div class="ab cl nu nv hc nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="hn ho hp hq hr"><p id="c2d7" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">想了解更多？查看我关于JavaScript基础的其他文章:</p><ul class=""><li id="1dcd" class="lz ma hu kb b kc kd kf kg ki mb km mc kq md ku me mf mg mh dt translated"><a class="ae kv" href="https://hackernoon.com/hoisting-in-javascript-a-quick-guide-cc4d9597bbd7" rel="noopener ugc nofollow" target="_blank"><strong class="kb hv">JavaScript中的吊装:快速指南</strong> </a></li><li id="f056" class="lz ma hu kb b kc mi kf mj ki mk km ml kq mm ku me mf mg mh dt translated"><a class="ae kv" href="https://hackernoon.com/understand-javascript-variable-scope-with-ease-221a6d41dc43" rel="noopener ugc nofollow" target="_blank"> <strong class="kb hv">轻松理解JavaScript变量作用域</strong> </a></li><li id="71c6" class="lz ma hu kb b kc mi kf mj ki mk km ml kq mm ku me mf mg mh dt translated"><a class="ae kv" rel="noopener" href="/@lenafaure/how-to-use-javascript-closures-with-confidence-85cd1f841a6b"> <strong class="kb hv">如何放心使用JavaScript闭包</strong> </a></li><li id="bdea" class="lz ma hu kb b kc mi kf mj ki mk km ml kq mm ku me mf mg mh dt translated"><a class="ae kv" href="https://hackernoon.com/grasp-by-value-and-by-reference-in-javascript-7ed75efa1293" rel="noopener ugc nofollow" target="_blank"> <strong class="kb hv">掌握JavaScript </strong> </a>中的“按值”和“按引用”</li><li id="3e48" class="lz ma hu kb b kc mi kf mj ki mk km ml kq mm ku me mf mg mh dt translated"><a class="ae kv" href="https://hackernoon.com/a-quick-handbook-for-dates-in-javascript-7b71d0ef8e53" rel="noopener ugc nofollow" target="_blank"><strong class="kb hv">JavaScript中的日期快速手册</strong> </a></li><li id="2784" class="lz ma hu kb b kc mi kf mj ki mk km ml kq mm ku me mf mg mh dt translated"><a class="ae kv" rel="noopener" href="/@lenafaure/work-with-javascript-arrays-like-a-boss-97207a042e42"> <strong class="kb hv">像老板一样使用JavaScript数组</strong> </a></li></ul></div><div class="ab cl nu nv hc nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="hn ho hp hq hr"><p id="4729" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我希望你喜欢这篇关于JavaScript关键字“this”的介绍。</p><p id="26f2" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">请随意评论并喜欢这篇文章，以便其他人可以在Medium上轻松找到它！</p><figure class="jo jp jq jr fq js fe ff paragraph-image"><a href="http://eepurl.com/dvio9L"><div class="fe ff ob"><img src="../Images/3183c9cfe7a8644bc0a59d2e3e57fa27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*td_Zl-oX7vl2kIsoldqcLA.png"/></div></a></figure><div class="jo jp jq jr fq ab cb"><figure class="oc js od oe of og oh paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="oc js od oe of og oh paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="oc js od oe of og oh paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="no np nq"><p id="f922" class="jz ka kw kb b kc kd iv ke kf kg iy kh nr kj kk kl ns kn ko kp nt kr ks kt ku hn dt translated"><a class="ae kv" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是T21家庭的一员。我们现在<a class="ae kv" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae kv" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jz ka kw kb b kc kd iv ke kf kg iy kh nr kj kk kl ns kn ko kp nt kr ks kt ku hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kv" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kv" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jo jp jq jr fq js fe ff paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="fe ff oi"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="jo jp jq jr fq js"><div class="bz el l di"><div class="oj ky l"/></div></figure></div></div>    
</body>
</html>