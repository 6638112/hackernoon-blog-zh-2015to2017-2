<html>
<head>
<title>Don’t Just Relax; Slouch: A JS Client for CouchDB that Does the Heavy Lifting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要只是放松；没精打采:CouchDB的JS客户端，负责繁重的工作</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/dont-just-relax-slouch-a-js-client-for-couchdb-that-does-the-heavy-lifting-d8232eba8e2c?source=collection_archive---------9-----------------------#2017-07-19">https://medium.com/hackernoon/dont-just-relax-slouch-a-js-client-for-couchdb-that-does-the-heavy-lifting-d8232eba8e2c?source=collection_archive---------9-----------------------#2017-07-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/e53f3e53b882e8455f244ce319f3a0fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*fzqcC9PSXal7scFL7Cvvkg.png"/></div></figure><p id="f9ba" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">随着最近CouchDB 2的发布，CouchDB生态系统火了！现在有一种开箱即用的方式来设置多主节点集群，该集群可以扩展以处理大量数据。而且，像PouchDB这样的工具可以让你的应用程序直接与CouchDB对话，让你的应用程序先离线<a class="ae jw" href="http://offlinefirst.org/" rel="noopener ugc nofollow" target="_blank"/>。在应用程序的数据层使用CouchDB是一个激动人心的时刻！</p><p id="acaf" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">即使您专注于前端密集型设计，也有可能必须在后端编写大量代码来与CouchDB实例通信，包括订阅实时更改。</p><p id="045c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">当我们第一次开始开发数字投件箱和分级系统<a class="ae jw" href="https://quizster.co" rel="noopener ugc nofollow" target="_blank">Quizster</a>时，我们非常依赖令人敬畏的<a class="ae jw" href="https://github.com/apache/couchdb-nano" rel="noopener ugc nofollow" target="_blank"> nano </a>客户端。通过大量的反复试验，我们发现许多混乱的逻辑，主要是为了处理大型数据集和瞬时数据库错误，开始使应用层变得混乱。我们还需要比nano更简洁的东西，更接近于原始的CouchDB RESTful API。我们不希望必须将客户端绑定到特定的数据库，因为在实践中，这会导致大量的开销。我们还希望承诺成为客户的一部分，因为我们认为它们对于保持代码的可管理性至关重要。</p><p id="55dc" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">于是，<a class="ae jw" href="https://github.com/redgeoff/slouch" rel="noopener ugc nofollow" target="_blank">没精打采</a>诞生了。</p><p id="1757" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">没精打采提供了你期望在CouchDB客户端中找到的所有典型特性。让我们来看看一些很酷的东西。</p><h1 id="f5cc" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">容错</h1><p id="6b70" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">如果与数据库的连接暂时中断，lost会尝试重试您的请求。此外，它会重试max_dbs_open错误和其他瞬时错误，以防止应用程序在每次数据库出现问题时崩溃。</p><h1 id="acd4" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">流迭代器</h1><p id="76d8" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">如今，处理大型数据集实际上是一种需求。当然，您可以对数据进行分页，但是CouchDB支持流，流迭代器使得处理这些流变得轻而易举。</p><p id="e5e3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">StreamIterators适用于所有能够返回大量文档的请求，即<code class="eh la lb lc ld b">db.changes()</code>、<code class="eh la lb lc ld b">db.view()</code>、<code class="eh la lb lc ld b">doc.all()</code>、<code class="eh la lb lc ld b">system.updates()</code></p><p id="776a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">StreamIterators通过引入一种简单而强大的模式来处理承诺并减少代码。</p><h2 id="65af" class="le jy hu bd jz lf lg lh kd li lj lk kh jj ll lm kl jn ln lo kp jr lp lq kt lr dt translated"><strong class="ak">示例1 —顺序处理数据库中的所有文档</strong></h2><pre class="ls lt lu lv fq lw ld lx ly aw lz dt"><span id="3664" class="le jy hu ld b fv ma mb l mc md">slouch.doc.all('mydb', { include_docs: true })<br/>  .each(function (item) {<br/><br/>    // If we return a promise then the all() iterator won't move on<br/>    // to the next item until the promise resolves. This allows us<br/>    // to iterate through a large number of docs without consuming a<br/>    // lot of memory. It also allows us to control the flow of the<br/>    // docs and process them sequentially so that we don't end up<br/>    // thrashing the processor with too many concurrent promises.<br/>    return Promise.resolve('foo =&gt; ' + item.foo);<br/><br/>  }).then(function () {<br/><br/>    // Done iterating through all docs<br/><br/>  }).catch (function (err) {<br/><br/>    // An error occurred<br/><br/>  });</span></pre><h2 id="01fe" class="le jy hu bd jz lf lg lh kd li lj lk kh jj ll lm kl jn ln lo kp jr lp lq kt lr dt translated">示例2 —最多同时处理5个文档</h2><pre class="ls lt lu lv fq lw ld lx ly aw lz dt"><span id="5ad3" class="le jy hu ld b fv ma mb l mc md">var Throttler = require('squadron').Throttler;<br/>var throttler = new Throttler(5);<br/><br/>slouch.doc.all('mydb', { include_docs: true })<br/>  .each(function (item) {<br/><br/>    return Promise.resolve('foo =&gt; ' + item.foo);<br/><br/>  }, throttler).then(function () {<br/><br/>    // Done iterating through all docs<br/><br/>  });</span></pre><h1 id="7716" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">助手功能</h1><p id="b5cc" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">CouchDB冲突策略是一个非常强大的约定，是CouchDB及其离线功能的核心。然而，有时冲突对你来说并不重要，最好有一些函数来确保你的逻辑在这些冲突中保持不变。</p><h2 id="3be8" class="le jy hu bd jz lf lg lh kd li lj lk kh jj ll lm kl jn ln lo kp jr lp lq kt lr dt translated">upsert</h2><p id="61a0" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">有时，即使存在冲突，您也只想强制创建或更新:</p><pre class="ls lt lu lv fq lw ld lx ly aw lz dt"><span id="14bc" class="le jy hu ld b fv ma mb l mc md">slouch.doc.upsert('mydb', { _id: '1', foo: 'bar' });</span></pre><h2 id="ca16" class="le jy hu bd jz lf lg lh kd li lj lk kh jj ll lm kl jn ln lo kp jr lp lq kt lr dt translated">getMergeUpsert</h2><p id="1a06" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">getMergeUpsert允许您进行不考虑冲突的部分更新:</p><pre class="ls lt lu lv fq lw ld lx ly aw lz dt"><span id="25ae" class="le jy hu ld b fv ma mb l mc md">// Create a doc<br/>slouch.doc.create('mydb', { _id: '1', foo: 'bar' })<br/>  .then(function (doc) {</span><span id="cc5a" class="le jy hu ld b fv me mb l mc md">    // Add the `yar` attr to the doc and ignore any conflicts<br/>    return slouch.doc.getMergeUpsert('mydb',<br/>      { _id: '1', yar: 'nar' });</span><span id="bc3f" class="le jy hu ld b fv me mb l mc md">  });</span></pre><h1 id="8b36" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">无精打采</h1><p id="77b9" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">这仅仅是你能对懒散的人做的事情的皮毛。我们发现<a class="ae jw" href="https://github.com/redgeoff/slouch" rel="noopener ugc nofollow" target="_blank">懒散</a>在<a class="ae jw" href="https://quizster.co" rel="noopener ugc nofollow" target="_blank"> Quizster </a>的生产中工作得非常好，使用它极大地简化了我们的应用层，因为许多样板代码现在在<a class="ae jw" href="https://github.com/redgeoff/slouch" rel="noopener ugc nofollow" target="_blank">懒散</a>层。</p><p id="4a73" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们的下一步是使用<a class="ae jw" href="https://github.com/redgeoff/slouch" rel="noopener ugc nofollow" target="_blank">没精打采</a>来开源我们的<a class="ae jw" href="https://github.com/redgeoff/spiegel" rel="noopener ugc nofollow" target="_blank"> Spiegel </a>层，以便更容易实现可伸缩复制和更改CouchDB监听。</p><h1 id="2253" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">关于作者</h1><p id="de82" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">杰夫·考克斯是数字投件箱和评分系统Quizster的联合创始人。<a class="ae jw" href="https://quizster.co" rel="noopener ugc nofollow" target="_blank"> Quizster，</a>使用完整的JS栈，在数据层运行CouchDB和PouchDB。</p></div></div>    
</body>
</html>