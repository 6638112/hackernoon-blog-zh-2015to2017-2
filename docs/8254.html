<html>
<head>
<title>Unit Testing Redux Connected Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单元测试冗余连接组件</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/unit-testing-redux-connected-components-692fa3c4441c?source=collection_archive---------0-----------------------#2017-11-26">https://medium.com/hackernoon/unit-testing-redux-connected-components-692fa3c4441c?source=collection_archive---------0-----------------------#2017-11-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="075f" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">模拟函数和冗余存储</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/75e1bbd679a363b9c2935e167608fd20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bs6W6c6yYS36PcD9joLVtw.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Testing React+Redux with Jest+Enzyme</figcaption></figure><p id="63f3" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">当我写上一篇<a class="ae kv" href="https://hackernoon.com/implementing-basic-component-tests-using-jest-and-enzyme-d1d8788d627a" rel="noopener ugc nofollow" target="_blank">文章</a>时，我故意忽略了如何测试连接的组件。对于连接到Redux store的组件，设置测试文件和编写测试需要花费更多的精力。对于这个例子，我使用Jest和Enzyme来做测试。我将谈一谈如何使用模拟存储和模拟函数来测试这些组件。</p><h1 id="5fe5" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated">我们如何测试它们？</h1><p id="b03d" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">我将继续以我的登录组件为例。该组件的代码如下所示，</p><pre class="jk jl jm jn fq lt lu lv lw aw lx dt"><span id="ad3c" class="ly kx hu lu b fv lz ma l mb mc">// app/src/components/Login.js<br/>import React from 'react'<br/>import { connect } from 'react-redux'<br/>import { loginUser } from '../actions/users'</span><span id="e4f2" class="ly kx hu lu b fv md ma l mb mc">class Login extends React.Component {</span><span id="f46f" class="ly kx hu lu b fv md ma l mb mc">constructor() {<br/>  super()<br/>  this.state = {<br/>   username: '',<br/>   password: ''<br/>  }<br/> }</span><span id="104e" class="ly kx hu lu b fv md ma l mb mc">handleInputChange = (event) =&gt; {<br/>  this.setState({<br/>   [event.target.name]: event.target.value<br/>  })<br/> }</span><span id="f228" class="ly kx hu lu b fv md ma l mb mc">handleSubmit = (event) =&gt; {<br/>  event.preventDefault()<br/>  this.props.login(this.state)<br/> }</span><span id="d268" class="ly kx hu lu b fv md ma l mb mc">render() {<br/>  return (<br/>   &lt;form id='loginForm' className='login' onSubmit={this.handleSubmit}&gt;<br/>    &lt;label&gt;Username&lt;/label&gt;<br/>    &lt;input id='email' onChange={this.handleInputChange} name='email' type='text' /&gt;<br/>    &lt;label&gt;Password&lt;/label&gt;<br/>    &lt;input id='password' onChange={this.handleInputChange} name='password' type='password' /&gt;<br/>    &lt;button&gt;Submit&lt;/button&gt;<br/>   &lt;/form&gt;<br/>  )<br/> }<br/>}</span><span id="8c81" class="ly kx hu lu b fv md ma l mb mc">function mapDispatchToProps(dispatch) {<br/> return {<br/>  login: (userparams, history) =&gt; {<br/>   dispatch(loginUser(userparams, history))<br/>  }<br/> }<br/>}</span><span id="8242" class="ly kx hu lu b fv md ma l mb mc">export default connect(mapDispatchToProps)(Login)</span></pre><p id="89a0" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我将这个组件连接到我的Redux存储，并为调用handleSubmit函数的表单添加了一个onSubmit事件。我添加了mapDispatchToProps函数，它返回我的登录函数。这将调用我的操作创建者并分派我的登录用户操作。当表单提交后，它应该从props中调用我的登录函数，该函数将负责登录用户。</p><p id="d299" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">当试图为一个连接的组件编写一个测试时，您可能会遇到这个错误消息，</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff me"><img src="../Images/4e0e3bfafec6bdf05a20e241d6430951.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gHMaUTH-oITMPCQPtG_MHg.png"/></div></div></figure><p id="022e" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">此消息是Jest试图找到您的Redux商店，但无法找到它的结果。这很有意义，因为我们的测试文件与应用程序是分开的，所以我们没有创建商店或设置Redux。</p><h2 id="d7f8" class="ly kx hu bd ky mf mg mh lc mi mj mk lg ki ml mm li km mn mo lk kq mp mq lm mr dt translated">我们如何解决这个问题？</h2><p id="edc1" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">在我研究的时候，我发现了解决这个问题的几种不同的方法。有两个主要选择，都得到不同团体的支持。我主要看到了在连接到Redux时测试组件和在没有连接到Redux时测试组件之间的分歧。我将简单介绍一下每种方法，并告诉您我更喜欢哪一种。</p><h2 id="1b4b" class="ly kx hu bd ky mf mg mh lc mi mj mk lg ki ml mm li km mn mo lk kq mp mq lm mr dt translated">使用模拟存储测试组件</h2><p id="057b" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">在我看来，这种测试组件的方式是不推荐的。当使用这种方法时，我们越过了单元测试的边界，而是开始测试集成。我将向您展示如何建立一个模拟商店，但我不会用这种方法展示任何测试。</p><p id="5376" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">正如你所看到的，上面的错误信息给了我们两种解决问题的方法。我们可以显式地创建一个存储，并将其传递给我们连接的登录组件，或者我们可以将登录组件包装在保存存储的Redux提供程序中。我建议使用第一种方法，因为这样就不需要安装我们的组件，我们可以用浅层渲染来代替。<a class="ae kv" href="https://github.com/airbnb/enzyme/blob/master/docs/api/mount.md" rel="noopener ugc nofollow" target="_blank">挂载</a>需要酵素渲染完整的DOM，而<a class="ae kv" href="https://github.com/airbnb/enzyme/blob/master/docs/api/shallow.md" rel="noopener ugc nofollow" target="_blank">浅层渲染</a>只需要渲染组件。</p><p id="1d76" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">集成商店的一种方法是使用redux-mock-store来创建它。将它添加到您的项目运行中</p><pre class="jk jl jm jn fq lt lu lv lw aw lx dt"><span id="5a96" class="ly kx hu lu b fv lz ma l mb mc">npm install redux-mock-store --save-dev</span></pre><p id="287b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这将允许我们创建一个存储来传递给我们连接的组件。这就是我们如何创建一个模拟商店，</p><pre class="jk jl jm jn fq lt lu lv lw aw lx dt"><span id="07e8" class="ly kx hu lu b fv lz ma l mb mc">// app/src/components/__tests__/Login-test.js</span><span id="635f" class="ly kx hu lu b fv md ma l mb mc">import configureStore from 'redux-mock-store'<br/> </span><span id="f877" class="ly kx hu lu b fv md ma l mb mc">// create any initial state needed<br/>const initialState = {};<!-- --> </span><span id="97f5" class="ly kx hu lu b fv md ma l mb mc">// here it is possible to pass in any middleware if needed into //configureStore<br/>const mockStore = configureStore();<br/>let wrapper;<br/>let store;</span><span id="9b37" class="ly kx hu lu b fv md ma l mb mc">beforeEach(() =&gt; {</span><span id="5123" class="ly kx hu lu b fv md ma l mb mc">  //creates the store with any initial state or middleware needed  <br/>  store = mockStore(initialState)<br/>  wrapper = <em class="ms">see below...</em><br/> })</span></pre><p id="0566" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">传递给组件的两种方式是这样的，</p><pre class="jk jl jm jn fq lt lu lv lw aw lx dt"><span id="e4de" class="ly kx hu lu b fv lz ma l mb mc">wrapper = shallow(&lt;Login store={store}/&gt;)<br/>                        OR<br/>// not suggested<br/>wrapper = mount(&lt;Provider store={store}&lt;Login /&gt;&lt;/Provider&gt;)</span></pre><p id="473d" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如果您查看Redux模拟商店文档，就会发现创建这个库的原因是为了测试动作创建者和中间件。当我们以一种不是最初设计的方式使用这个库时，这似乎已经是一个危险信号了。</p><p id="2e31" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">有了这个模拟商店，我们可以测试通过动作创建者发送到我们商店的动作，看看它们是否与预期的动作相匹配。这更像是一个集成测试，测试我们组件的整个流程。这比单独测试应用程序的所有部分更复杂，也更没有必要。我觉得有一种更简单的方法来测试我们的组件，以确保它在Redux下正常工作。</p><h2 id="8f17" class="ly kx hu bd ky mf mg mh lc mi mj mk lg ki ml mm li km mn mo lk kq mp mq lm mr dt translated">测试没有冗余存储的组件</h2><p id="cc17" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">如果我们在组件没有连接到Redux存储时测试它，我们就不必担心创建模拟存储的额外工作。相反，我们只是测试组件的功能，看看它是否如我们所期望的那样运行。为此，我们可以简单地导出未连接的组件，以及连接组件的默认导出。我们通过在组件前添加导出来实现这一点，</p><pre class="jk jl jm jn fq lt lu lv lw aw lx dt"><span id="4875" class="ly kx hu lu b fv lz ma l mb mc">// app/src/components/Login.js<br/>import React from 'react'<br/>import { connect } from 'react-redux'</span><span id="ed07" class="ly kx hu lu b fv md ma l mb mc">// add export here to export the unconnected component<br/><strong class="lu hv">export</strong> class Login extends React.Component {</span><span id="10d8" class="ly kx hu lu b fv md ma l mb mc">    // ...code above<br/>}</span><span id="6dca" class="ly kx hu lu b fv md ma l mb mc">function mapDispatchToProps(dispatch) {<br/> return {<br/>  login: (userparams, history) =&gt; {<br/>   dispatch(loginUser(userparams, history))<br/>  }<br/> }<br/>}</span><span id="36bb" class="ly kx hu lu b fv md ma l mb mc">export default connect(mapDispatchToProps)(Login)</span></pre><p id="46d4" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在，当我们将组件导入到测试中时，我们必须像这样编写它，</p><pre class="jk jl jm jn fq lt lu lv lw aw lx dt"><span id="cf30" class="ly kx hu lu b fv lz ma l mb mc">// app/src/components/__tests__/Login-test.js<br/>import { Login } from '../Login'</span></pre><p id="9196" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这将导入未连接的元件，而不是默认的连接元件。</p><p id="8746" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">因为我们没有商店，所以用于登录的mapDispatchToProps函数没有提供给我们的组件。通过用Jest创建一个模拟函数，我们可以很容易地解决这个问题。这个函数将代替我们的动作创建者，我们将能够测试它是否被调用。为此，我们可以将此代码添加到我们的测试文件中，并将此函数作为我们的登录属性传递，</p><pre class="jk jl jm jn fq lt lu lv lw aw lx dt"><span id="3c45" class="ly kx hu lu b fv lz ma l mb mc">// app/src/components/__tests__/Login-test.js</span><span id="4439" class="ly kx hu lu b fv md ma l mb mc">describe('Login Component', () =&gt; {<br/>  let wrapper;<br/>  // our mock login function to replace the one provided by mapDispatchToProps<br/>  const mockLoginfn = jest.fn();<br/> <br/>   beforeEach(() =&gt; {<br/>     // pass the mock function as the login prop <br/>     wrapper = shallow(&lt;Login login={mockLoginfn}/&gt;)<br/>   })</span><span id="458f" class="ly kx hu lu b fv md ma l mb mc">// ...tests here...<br/>}</span></pre><p id="b8e0" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这取代了mapDispatchToProps传递给我们的组件的登录函数。没有必要测试我们的mapDispatchToProps是否正确地将我们的登录函数传递给连接的组件，因为Redux已经负责这个。现在我们的组件已经有了那个函数，我们可以测试当我们提交登录表单时我们的函数是否被调用。测试的代码如下所示，</p><pre class="jk jl jm jn fq lt lu lv lw aw lx dt"><span id="f1c6" class="ly kx hu lu b fv lz ma l mb mc">// app/src/components/__tests__/Login-test.js\</span><span id="684d" class="ly kx hu lu b fv md ma l mb mc">describe('When the form is submitted', () =&gt; {<br/>  it('should call the mock login function', () =&gt; {<br/>   wrapper.find('#loginForm').simulate(<br/>     'submit', <br/>     {preventDefault() {}}<br/>   )<br/>   expect(mockLoginfn.mock.calls.length).toBe(1)<br/>  })<br/>})</span></pre><p id="1b1b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">当我们模拟表单的提交时，我们需要在事件对象中传递preventDefault函数，否则我们会得到一个错误。这是因为handleSubmit函数将调用event.preventDefault()，如果我们不包含它，就会发生错误。一旦我们模拟了提交事件，我们就可以测试我们的模拟登录函数，看看它是否被调用了。我们的mockLoginfn本质上是一个间谍，就像您使用Sinon库一样。因此，通过检查以确保我们的mockLoginfn被调用一次，我们验证了当我们提交表单时，它将调用正确的prop函数并发送正确的动作。我们还可以添加一个测试，在这里我们填写用户名和密码字段，然后模拟提交。当我们这样做时，我们可以检查我们的mockLoginfn，以确保它被传递了正确的参数。看起来像这样，</p><pre class="jk jl jm jn fq lt lu lv lw aw lx dt"><span id="ca7f" class="ly kx hu lu b fv lz ma l mb mc">it('should be called with the email and password in the state as arguments', () =&gt; {</span><span id="1b62" class="ly kx hu lu b fv md ma l mb mc">   // fill in email field with <a class="ae kv" href="mailto:blah@gmail.com" rel="noopener ugc nofollow" target="_blank">blah@gmail.com</a>     <br/>   wrapper.find('#email').simulate(<br/>     'change', <br/>     {target: <br/>       {name: 'email', value: '<a class="ae kv" href="mailto:blah@gmail.com" rel="noopener ugc nofollow" target="_blank">blah@gmail.com</a>'}<br/>     }<br/>   )</span><span id="7bc6" class="ly kx hu lu b fv md ma l mb mc">   // fill in password field with cats  <br/>   wrapper.find('#password').simulate(<br/>     'change', <br/>     {target: <br/>        {name: 'password', value: 'cats'}<br/>     }<br/>   )</span><span id="fef8" class="ly kx hu lu b fv md ma l mb mc">   // simulate form submission   <br/>   wrapper.find('#loginForm').simulate(<br/>     'submit', <br/>     {preventDefault() {}}<br/>   )</span><span id="2f4c" class="ly kx hu lu b fv md ma l mb mc">   // test to see arguments used after its been submitted <br/>   expect(mockLoginfn.mock.calls[1][0]).toEqual(<br/>     {email: '<a class="ae kv" href="mailto:blah@gmail.com" rel="noopener ugc nofollow" target="_blank">blah@gmail.com</a>', password: 'cats'}<br/>   )<br/>  })</span></pre><p id="0ece" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们检查mockLoginfn.mock.calls[1],因为我们在之前的测试中已经调用了mockLoginfn。Calls[1]给了我们一个传入的参数数组。我们只使用了一个对象，所以我们测试数组中的第一个索引。</p><h1 id="4b43" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated">摘要</h1><p id="411a" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">在我看来，第二种测试方式要简单得多，可以减少代码和测试时间。通常在测试react应用程序时，我们可以将Redux部分与组件分开测试。因为我们的动作创建者和还原者本质上都是函数，所以我们可以像测试其他Javascript函数一样测试它们。在一次测试中测试从部件到动作到减速器再到悬挂物的整个流程并不重要。这将是一个集成测试，而不是我们组件的单元测试。如果我们能够通过自己的单元测试来确定每个部分都正常运行，那么我们就不需要任何其他东西。希望这有助于澄清您在编写连接组件的测试时可能遇到的任何问题！</p><h1 id="b208" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated">来源:</h1><div class="mt mu fm fo mv mw"><a href="https://redux.js.org/docs/recipes/WritingTests.html" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab ej"><div class="my ab mz cl cj na"><h2 class="bd hv fv z el nb eo ep nc er et ht dt translated">编写测试冗余</h2><div class="nd l"><h3 class="bd b fv z el nb eo ep nc er et ek translated">编辑描述</h3></div><div class="ne l"><p class="bd b gc z el nb eo ep nc er et ek translated">redux.js.org</p></div></div></div></a></div><div class="mt mu fm fo mv mw"><a href="https://facebook.github.io/jest/docs/en/mock-functions.html" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab ej"><div class="my ab mz cl cj na"><h2 class="bd hv fv z el nb eo ep nc er et ht dt translated">模拟函数Jest</h2><div class="nd l"><h3 class="bd b fv z el nb eo ep nc er et ek translated">模拟函数通过删除实际的</h3></div><div class="ne l"><p class="bd b gc z el nb eo ep nc er et ek translated">facebook.github.io</p></div></div><div class="nf l"><div class="ng l nh ni nj nf nk jt mw"/></div></div></a></div><div class="mt mu fm fo mv mw"><a href="https://github.com/airbnb/enzyme/issues/1002" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab ej"><div class="my ab mz cl cj na"><h2 class="bd hv fv z el nb eo ep nc er et ht dt translated">使用Enzyme Issue #1002 airbnb/enzyme测试Redux连接的组件</h2><div class="nd l"><h3 class="bd b fv z el nb eo ep nc er et ek translated">酶I)使用酶测试冗余连接组件时，最不容易出错的方法是什么？我查了很多链接…</h3></div><div class="ne l"><p class="bd b gc z el nb eo ep nc er et ek translated">github.com</p></div></div><div class="nf l"><div class="nl l nh ni nj nf nk jt mw"/></div></div></a></div><div class="mt mu fm fo mv mw"><a href="http://arnaudbenard.com/redux-mock-store/" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab ej"><div class="my ab mz cl cj na"><h2 class="bd hv fv z el nb eo ep nc er et ht dt translated">redux模拟商店文档</h2><div class="nd l"><h3 class="bd b fv z el nb eo ep nc er et ek translated">最简单的用例是同步动作。在本例中，我们将测试addTodo操作是否返回…</h3></div><div class="ne l"><p class="bd b gc z el nb eo ep nc er et ek translated">arnaudbenard.com</p></div></div></div></a></div><div class="mt mu fm fo mv mw"><a rel="noopener follow" target="_blank" href="/netscape/testing-a-react-redux-app-using-jest-and-enzyme-b349324803a9"><div class="mx ab ej"><div class="my ab mz cl cj na"><h2 class="bd hv fv z el nb eo ep nc er et ht dt translated">使用Jest和Enzyme测试React-Redux应用程序</h2><div class="nd l"><h3 class="bd b fv z el nb eo ep nc er et ek translated">随着我们进入新的一年(2017年)，我想暂停写一些让我兴奋的东西，比如开发…</h3></div><div class="ne l"><p class="bd b gc z el nb eo ep nc er et ek translated">medium.com</p></div></div><div class="nf l"><div class="nm l nh ni nj nf nk jt mw"/></div></div></a></div><div class="mt mu fm fo mv mw"><a href="https://github.com/reactjs/redux/issues/1534" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab ej"><div class="my ab mz cl cj na"><h2 class="bd hv fv z el nb eo ep nc er et ht dt translated">不能引用包装在提供者中的容器或通过与Enzyme连接问题#1534反应…</h2><div class="nd l"><h3 class="bd b fv z el nb eo ep nc er et ek translated">我好像引用不了什么包装在a和a中的connect//test let component = shallow()；component.find('#abc…</h3></div><div class="ne l"><p class="bd b gc z el nb eo ep nc er et ek translated">github.com</p></div></div><div class="nf l"><div class="nn l nh ni nj nf nk jt mw"/></div></div></a></div></div></div>    
</body>
</html>