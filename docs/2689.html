<html>
<head>
<title>GitHub statuses made easy with FaaS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">FaaS让GitHub状态变得简单</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/github-statuses-made-easy-with-faas-fd9236a41925?source=collection_archive---------6-----------------------#2017-02-11">https://medium.com/hackernoon/github-statuses-made-easy-with-faas-fd9236a41925?source=collection_archive---------6-----------------------#2017-02-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="ae2f" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">使用Azure函数自动化你的请求验证</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/661df2b5689256787c9340f3b46ceb38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F64E0wCSNcGZnOyf4pxl9Q.png"/></div></div></figure><p id="c55d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果你有一个开源项目，你能围绕拉式请求审查过程自动化得越多越好，至少我是这么认为的。</p><p id="b117" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">因此，如果你仔细检查你的期望清单，你会发现有些东西是明显的持续集成，已经存在良好的服务，但你的一些检查可能是独特的，目前是手动的——我最近的自动检查就是本文中的例子。</p><h2 id="2891" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">这个例子</h2><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff lm"><img src="../Images/816524bf7aa518ce0f015dd95b3a797b.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*jd-HNZVXG3lrfFwf1YYzRg.png"/></div></figure><p id="f475" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这篇博文中解释的例子将会进行验证，因此pull请求中的每个提交都来自一个已知的GitHub用户，这是一个非常容易的检查，但是当你检查自己时也很容易错过，因为pull请求本身总是来自一个已知的GitHub用户——所以仅仅通过查看GitHub上的pull请求，这不是一个明显的问题。</p><p id="8003" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这样做的原因可能是，如果你想在发布说明中自动归属作者，验证CLAs等等。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff ln"><img src="../Images/e05fceeab5245d91cf1fcde9cec72f06.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*EMyMcdtZqyTOkV4VnPiKYA.png"/></div></figure><p id="d1e6" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">发生这种情况的原因通常不是恶意的，而是使用了GitHub未知的电子邮件地址，即发行者的公司电子邮件地址。</p><p id="dcbb" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">最简单的解决方法是在GitHub设置/电子邮件下添加所有的电子邮件地址，另一种方法是用所需的电子邮件地址修改提交，并用新的提交进行强制推送。</p><h2 id="6403" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">这个概念</h2><p id="98ad" class="pw-post-body-paragraph jv jw hu jx b jy lo iv ka kb lp iy kd ke lq kg kh ki lr kk kl km ls ko kp kq hn dt translated">FaaS——功能即服务——非常适合这种情况，因为你不需要网站/服务器24/7全天候运行，而是FaaS使你能够拥有只在被调用时才启动和运行的代码——这种想法是只为你使用时使用的东西付费。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff lt"><img src="../Images/6d8252778b972ab837b4e0643a6f84f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*-BNvpMOTaRnmjIbkeJWyHw.png"/></div></figure><p id="972d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">大致的流程是GitHub触发对一个函数的webhook调用，该函数将从GitHub有效负载中解析出所需的内容，并将其放在Azure存储队列中，该队列将触发一个函数，该函数使用GitHub rest API进行验证并向pull请求报告状态。</p><h2 id="ba84" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">新功能</h2><p id="0924" class="pw-post-body-paragraph jv jw hu jx b jy lo iv ka kb lp iy kd ke lq kg kh ki lr kk kl km ls ko kp kq hn dt translated">我通常使用Azure Functions CLI脚手架，用VS代码编写我的函数，然后通过KUDU或选择的CI/CD进行部署。但是Azure门户也非常强大，可以作为快速入门的方式，并且完全有可能在以后获得源代码控制(<em class="lu">在生产中，源代码控制应该总是这样，但是当开始时，围绕门户进行原型制作和游戏实际上是非常高效的</em></p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff lv"><img src="../Images/a497d03837a35b28e64d9f3fdeb867a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xA6cNU8JIKRTvDGqbuUR-w.png"/></div></div></figure><p id="5e8f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Azure Functions有现成的模板，可以快速上手GitHub webhooks。</p><p id="1290" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这个模板将为您动态解析从GitHub发布的数据提供一个很好的起点，使得支持大多数场景变得容易。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lw lx l"/></div></figure><h2 id="e9cf" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">添加队列</h2><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff ly"><img src="../Images/bded46de85ccac3a3335158707a17f03.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/format:webp/1*aYXmjADGTPwxnPrpD5w3vw.png"/></div></figure><p id="a177" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">所以现在我们有了进入服务的数据设置，并且有了解析输入数据的能力。现在，我们只想快速地从GitHub有效载荷中挑选出需要的东西，将其放入队列供以后处理，并告诉GitHub我们得到了它。</p><p id="4038" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">转到“集成”，通过门户添加一个队列输出，单击<br/>“+新输出”，在这种情况下，我们需要一个Azure存储队列</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff lz"><img src="../Images/c26d14d7070231e27f171ad804f6a01a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3TmdiRvbIATo9LAqOQz27w.png"/></div></div></figure><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ma"><img src="../Images/b19908b4b7e4dc82a9181288e1bb15ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wx7sA8A82rpU8DEehhClWg.png"/></div></div></figure><p id="f86a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">然后给“队列输出”一个参数名，它将是函数中输出参数的名称，然后是要将消息推送到的队列的名称，最后选择存储队列连接字符串所在的<code class="eh mb mc md me b">appsetting</code>。点击save，我们的队列参数绑定就准备好了。</p><h2 id="b6f1" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">填充队列</h2><p id="e905" class="pw-post-body-paragraph jv jw hu jx b jy lo iv ka kb lp iy kd ke lq kg kh ki lr kk kl km ls ko kp kq hn dt translated">现在我们只需要将它作为输出参数添加到我们的函数中，这样我们就可以为它分配内容:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lw lx l"/></div></figure><p id="0008" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">正如您在这里看到的，使用output参数会失去async/await功能，如果您不需要多个输出，并且只想在成功处理和排队后返回<br/>“200—OK ”,那么您可以继续使用async/await，方法是在“Integrate”下移除HTTP结果绑定，并将队列设置为绑定到函数的返回值。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mf"><img src="../Images/db32446ee48da32c954b0b42271843a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wrjLBIpS9CYzk7AtYU-mLg.png"/></div></div></figure><p id="e285" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">因此，一个完整的函数在解析和排队的同时仍然支持async/await，可能如下所示:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lw lx l"/></div></figure><h2 id="10d4" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">类型化参数</h2><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mg"><img src="../Images/658d8c19924c0fdf3bffa4905c18eaa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*1HAZg-UzZJZ1viG0MnappQ.png"/></div></figure><p id="74bc" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">一个巧妙的事情是，队列项可以被更改为自定义类，然后它会自动序列化和反序列化JSON字符串。所以让我们创建一个类，为了保持它的整洁，我们将把它添加到自己的文件中。<br/>点击“查看文件”——&gt;“+添加”，然后输入文件名，点击回车。</p><p id="37f1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们的有效负载的类将如下所示</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lw lx l"/></div></figure><p id="5f7e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">然后，我们可以在函数<code class="eh mb mc md me b">run.csx</code>中使用类似<br/> <code class="eh mb mc md me b">#load "GitHubPayload.csx"</code>的<code class="eh mb mc md me b">#load</code>指令，它在我们的函数中是可用的，我们可以将我们的函数方法签名更改为类型化返回值，并最终得到如下所示的结果:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lw lx l"/></div></figure><p id="bbce" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">那么上面是做什么的呢？不多也不少，它解析GitHub <a class="ae mh" href="https://developer.github.com/v3/activity/events/types/#pullrequestevent" rel="noopener ugc nofollow" target="_blank"> pull请求事件</a>的动作、发布状态的URL和获取pull请求提交的URL。<br/>当我们将返回值绑定到队列时，它将被自动序列化为JSON并排队。</p><h2 id="0a6f" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">插队</h2><p id="842d" class="pw-post-body-paragraph jv jw hu jx b jy lo iv ka kb lp iy kd ke lq kg kh ki lr kk kl km ls ko kp kq hn dt translated">现在我们需要一些东西来弹出队列并做实际的工作。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mi"><img src="../Images/6ec7a54e8f07619484f4d2e73ac10190.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*FKaeEV-E7dEsY2F6dorj8A.png"/></div></figure><p id="6adb" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">要快速启动并运行，Azure Functions实际上提供了一个脚手架选项，可以让你快速启动并运行。</p><p id="fcae" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果你去整合我们之前创建的队列输出，有一个“创建一个由这个输出触发的新函数”动作。</p><p id="6596" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这将预先选择一个C#队列触发器，填写队列名称和使用的存储帐户连接。</p><p id="c021" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">你所需要做的就是他的hit create，但是你可能想把你的函数命名得比<code class="eh mb mc md me b">QueueTriggerCSharp1</code>更有意义。</p><p id="ce51" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">创建的函数如下所示。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lw lx l"/></div></figure><p id="187f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">当有东西进入队列时，它就会被触发，出队的值就是您得到的值，模板示例只是将它输出到跟踪日志中。</p><h2 id="a6ed" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">解析和验证</h2><p id="f968" class="pw-post-body-paragraph jv jw hu jx b jy lo iv ka kb lp iy kd ke lq kg kh ki lr kk kl km ls ko kp kq hn dt translated">此外，可以通过重用我们之前创建的类来对出列触发器进行类型化，这样Azure函数会自动将排队的JSON反序列化为我们可以轻松处理的类型化对象。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lw lx l"/></div></figure><p id="d516" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">上面的代码将验证我们感兴趣的是一个事件/动作，并确保我们得到了报告状态所需的状态API URL和获取拉请求提交细节所需的提交API URL。</p><h2 id="0f4b" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">GitHub授权</h2><p id="8157" class="pw-post-body-paragraph jv jw hu jx b jy lo iv ka kb lp iy kd ke lq kg kh ki lr kk kl km ls ko kp kq hn dt translated">现在我们已经解析好了队列项，下一步是从GitHub获取提交，在此之前，我们需要能够验证它们。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mj"><img src="../Images/76ce153594f8159f720fe310f15f210f.png" data-original-src="https://miro.medium.com/v2/resize:fit:412/format:webp/1*7pi2Wr9xtoWMEj8o554zlA.png"/></div></figure><p id="2b7d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">GitHub有几种方式来验证的API，一种方式是通过个人访问令牌，这就是我在这篇博文中使用的。</p><p id="1e6e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">进入“设置”,然后点击左侧菜单中的“个人访问令牌”,即可找到您的个人访问令牌。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mk"><img src="../Images/856b748c0c5cfaa66feac5a6a26d808a.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*UBeHcpOwjXM2-kOt9i-4Yg.png"/></div></figure><p id="9737" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">然后点击“生成令牌”按钮，给令牌一个描述，选择所需的访问权限，有很多可用的权限，但对于这篇文章，“repo:status”是唯一需要的访问权限</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ml"><img src="../Images/2c0881e34c24e6a0823f4f1b7c74fbcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vozCl7cZbxPBHOG0EHOByg.png"/></div></div></figure><p id="876b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">点击“生成令牌”，您将看到新生成的令牌。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mm"><img src="../Images/4e01bbded8a682053a0ae59117b3ad7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tXDoAKzk-Gie62EGwZR_tQ.png"/></div></div></figure><h2 id="8c7f" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">应用程序设置</h2><p id="8466" class="pw-post-body-paragraph jv jw hu jx b jy lo iv ka kb lp iy kd ke lq kg kh ki lr kk kl km ls ko kp kq hn dt translated">我们不想在源代码中存储我们的令牌，幸运的是，Azure的功能就像其他Azure应用服务一样，提供了存储应用设置的方法。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mn"><img src="../Images/626eea3134dd18b4edd132a1a6f0b3dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*73nk8F8UJVyScIyHbc6aBQ.png"/></div></div></figure><p id="07e6" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">你可以在“功能应用设置”-&gt;“配置应用设置”下找到它</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mo"><img src="../Images/30d06deee8280d4abefe02869de0d364.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*O-FhLQpKlc6itnUJO3Kxaw.png"/></div></figure><p id="58f5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这里有一个键值对列表，您可以添加、删除和修改应用程序设置和连接字符串。</p><p id="3f01" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">所有应用程序设置和连接字符串都可以作为环境变量来访问，这使得无论您选择使用Azure功能支持的语言，都可以轻松访问。</p><p id="c30d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">连接字符串环境变量以它的提供者为前缀，也就是说，如果你选择自定义提供者，它会以<code class="eh mb mc md me b">CUSTOMCONNSTR_</code>为前缀，所以如果你输入一个名为<code class="eh mb mc md me b">GITHUB_TOKEN</code>的变量，你会以<code class="eh mb mc md me b">CUSTOMCONNSTR_GITHUB_TOKEN</code>的名字访问它。</p><h2 id="4ef4" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">呼叫GitHub</h2><p id="df1e" class="pw-post-body-paragraph jv jw hu jx b jy lo iv ka kb lp iy kd ke lq kg kh ki lr kk kl km ls ko kp kq hn dt translated">现在，我们已经将令牌和应用程序设置就绪，我们希望<code class="eh mb mc md me b">get</code>迭代请求提交，验证每个请求，然后<code class="eh mb mc md me b">post</code>验证请求是否通过。的。NET <code class="eh mb mc md me b">HttpClient</code>用于调用GitHub API，为了方便和保持整洁，我将它包装在两个助手方法<code class="eh mb mc md me b">GetObjectAsync</code>和<code class="eh mb mc md me b">PostObjectAsJsonAsync</code>中，两者都使用相同的方法进行公共头和认证，都放在它自己的<code class="eh mb mc md me b">HttpClientHelper.csx</code>文件中</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lw lx l"/></div></figure><h2 id="d7ed" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">完成拼图</h2><p id="706c" class="pw-post-body-paragraph jv jw hu jx b jy lo iv ka kb lp iy kd ke lq kg kh ki lr kk kl km ls ko kp kq hn dt translated">把所有的部分放在一起，我们最终得到了这样一个函数</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lw lx l"/></div></figure><p id="80d5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在，我们的功能已经完成，准备好对GitHub webhook请求进行排队，验证输入，验证并报告提交是否有注册的GitHub用户作为作者。</p><h2 id="9191" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">配置webhook</h2><p id="dde6" class="pw-post-body-paragraph jv jw hu jx b jy lo iv ka kb lp iy kd ke lq kg kh ki lr kk kl km ls ko kp kq hn dt translated">现在我们只需要配置GitHub，以便在创建或修改pull请求时调用我们的函数。这是在存储库(或组织)设置“webhooks”-&gt;“添加web hook”下完成的</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mp"><img src="../Images/e25cb417e25d8c466216a4f96a0826cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1I6qlK9ZbKB4AslSoNjzxw.png"/></div></div></figure><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mq"><img src="../Images/f73fad90fea02c385c8b13f5f242135b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*iNBXzrvAiHmUsxv1jCldOA.png"/></div></figure><p id="82e9" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">你可以在你的GitHub webhook函数下找到要使用的URL和secret。输入这些内容作为有效负载URL、机密，并选择<code class="eh mb mc md me b">application/json</code>作为内容类型</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mr"><img src="../Images/9a7fec8671e27fb0bf4ab24a4731b301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xDB97DSkRAF2AqDMupnbbA.png"/></div></div></figure><p id="b0d8" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">选择以选择单个事件，并仅选择“拉”请求事件</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ms"><img src="../Images/340749d53f3e8a55a44042d291d481a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-wsFUtjBcZBQmF5IBlHjyw.png"/></div></div></figure><p id="7e09" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">然后只需点击“添加webhook”就大功告成了。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mt"><img src="../Images/20c6da682cc95bbbb8a00dc3e6849b62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XGvk3UEnuJ1exNNRS3Dhug.png"/></div></div></figure><h2 id="0f3a" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">测试第一次公关</h2><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/207c9cf3833e00befe51e4a32bfba129.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*VTZbpMzYAs7FhK7kFuYOYw.png"/></div></figure><p id="4cc6" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在，我们为配置了webhook的存储库创建第一个PR。</p><p id="15c1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果一切按计划进行，您应该看到已经执行了1个作者验证，由于我是一个已知的GitHub用户，测试通过了，一切正常。</p><p id="d542" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在我们将添加一个来自未知用户的提交，最简单的测试方法是在提交时覆盖作者。从命令行，看起来像这样</p><pre class="jk jl jm jn fq mv me mw mx aw my dt"><span id="9958" class="kr ks hu me b fv mz na l nb nc">git commit -a -m "Unknown update" --author "John &lt;<a class="ae mh" href="mailto:John@unknown.doe.com" rel="noopener ugc nofollow" target="_blank">John@unknown.doe.com</a>&gt;"</span></pre><p id="594e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">然后我们推送我们的更改，这将触发GitHub pull request <code class="eh mb mc md me b">synchronize</code>事件和我们的函数</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nd"><img src="../Images/08824e25a7cc655bf5b8f229a60f661f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JXamqtVMy8rK96PSKMcSRg.png"/></div></div></figure><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff ne"><img src="../Images/a82166e957a6a682ddbe799d1faadf97.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*-M7mmqnDQ_WasEygU9Khvw.png"/></div></figure><p id="3938" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">按下详细信息链接将把我们带到显示未知作者的提交页面。</p><h2 id="3f38" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">结论</h2><p id="e535" class="pw-post-body-paragraph jv jw hu jx b jy lo iv ka kb lp iy kd ke lq kg kh ki lr kk kl km ls ko kp kq hn dt translated">阅读这篇文章所花的时间可能比启动和运行这些功能所花的时间要长得多——因为当你知道它的时候，很多事情都很容易。它真的让你专注于你想要解决的问题，正如我所展示的，与第三方API的结合非常简单，这使得它非常强大。使用队列是一件轻而易举的事情，对于即将到来的web钩子来说，这是一个很好的方法，因为你只需要接收和确认——在一个单独的函数中做实际的工作，你可以为每个队列将函数挂接到一个有害的消息队列，使它成为一个非常健壮的解决方案——而不会使它<em class="lu">变得太</em>复杂。</p><p id="5ad1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">最后，用小规模的自动检查来扩展GitHub pull请求审查过程是一种很好的方式，不仅可以节省您的时间，还可以加快与您的贡献者的沟通——并且天空确实是您可以检查的极限！你也可以做类似机器人的事情，比如某些维护者的评论触发了一个集成测试，产生了新的问题，一个微软团队的消息，等等。</p><p id="4a85" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">因此，我认为对于这些场景，功能即服务方法非常合适！你怎么想呢?希望听到您的反馈！</p><h2 id="cbf0" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">代码</h2><p id="8376" class="pw-post-body-paragraph jv jw hu jx b jy lo iv ka kb lp iy kd ke lq kg kh ki lr kk kl km ls ko kp kq hn dt translated">这篇博文中函数的完整代码可以在GitHub上找到</p><div class="nf ng fm fo nh ni"><a href="https://github.com/azurevoodoo/OnlyKnownCommitters" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab ej"><div class="nk ab nl cl cj nm"><h2 class="bd hv fv z el nn eo ep no er et ht dt translated">azure voodoo/OnlyKnownCommitters</h2><div class="np l"><h3 class="bd b fv z el nn eo ep no er et ek translated">在GitHub上创建一个帐户，为OnlyKnownCommitters的开发做出贡献。</h3></div><div class="nq l"><p class="bd b gc z el nn eo ep no er et ek translated">github.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw jt ni"/></div></div></a></div><h2 id="3f8c" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">以前的帖子</h2><p id="596c" class="pw-post-body-paragraph jv jw hu jx b jy lo iv ka kb lp iy kd ke lq kg kh ki lr kk kl km ls ko kp kq hn dt nx translated"><span class="l ny nz oa bm ob oc od oe of di">如果</span>你想学习更多的Azure功能，请查看我以前写的一些关于这个主题的帖子！</p><div class="nf ng fm fo nh ni"><a href="https://hackernoon.com/bring-static-to-life-using-serverless-e722be5eaf84" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab ej"><div class="nk ab nl cl cj nm"><h2 class="bd hv fv z el nn eo ep no er et ht dt translated">使用serverless⚡赋予静电以生命</h2><div class="np l"><h3 class="bd b fv z el nn eo ep no er et ek translated">使用Azure函数给你的静态网站注入活力</h3></div><div class="nq l"><p class="bd b gc z el nn eo ep no er et ek translated">hackernoon.com</p></div></div><div class="nr l"><div class="og l nt nu nv nr nw jt ni"/></div></div></a></div><div class="nf ng fm fo nh ni"><a rel="noopener follow" target="_blank" href="/@devlead/azure-deployment-microsoft-teams-ed1c15df4a08"><div class="nj ab ej"><div class="nk ab nl cl cj nm"><h2 class="bd hv fv z el nn eo ep no er et ht dt translated">⚡Azure部署-&gt;微软团队</h2><div class="np l"><h3 class="bd b fv z el nn eo ep no er et ek translated">使用Azure函数将Azure应用服务部署通知连接到微软团队通道</h3></div><div class="nq l"><p class="bd b gc z el nn eo ep no er et ek translated">medium.com</p></div></div><div class="nr l"><div class="oh l nt nu nv nr nw jt ni"/></div></div></a></div><div class="nf ng fm fo nh ni"><a rel="noopener follow" target="_blank" href="/@devlead/going-serverless-with-powershell-705677a9ae86"><div class="nj ab ej"><div class="nk ab nl cl cj nm"><h2 class="bd hv fv z el nn eo ep no er et ht dt translated">使用PowerShell实现无服务器化</h2><div class="np l"><h3 class="bd b fv z el nn eo ep no er et ek translated">为什么JavaScript开发者应该享受所有的乐趣？</h3></div><div class="nq l"><p class="bd b gc z el nn eo ep no er et ek translated">medium.com</p></div></div><div class="nr l"><div class="oi l nt nu nv nr nw jt ni"/></div></div></a></div><div class="jk jl jm jn fq ab cb"><figure class="oj jo ok ol om on oo paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="oj jo ok ol om on oo paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="oj jo ok ol om on oo paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="op oq or"><p id="f922" class="jv jw lu jx b jy jz iv ka kb kc iy kd os kf kg kh ot kj kk kl ou kn ko kp kq hn dt translated"><a class="ae mh" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae mh" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae mh" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae mh" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jv jw lu jx b jy jz iv ka kb kc iy kd os kf kg kh ot kj kk kl ou kn ko kp kq hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae mh" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae mh" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ov"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>