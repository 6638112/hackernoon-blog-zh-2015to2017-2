<html>
<head>
<title>XML vs JSON Shootout: Which Should I Use in SQL Server?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">XML vs JSON Shootout:在SQL Server中应该用哪个？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/xml-vs-json-shootout-which-should-i-use-in-sql-server-7eefa4dc7553?source=collection_archive---------5-----------------------#2017-07-13">https://medium.com/hackernoon/xml-vs-json-shootout-which-should-i-use-in-sql-server-7eefa4dc7553?source=collection_archive---------5-----------------------#2017-07-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/67821356f93aca4c7d080b6ea7a630bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4xcDFtOlrwtrzBPgXgA-lA.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">“<a class="ae jg" href="https://www.flickr.com/photos/ehiuomo/8099788695/" rel="noopener ugc nofollow" target="_blank">A duel is a duel</a>” by <a class="ae jg" href="https://www.flickr.com/photos/ehiuomo/" rel="noopener ugc nofollow" target="_blank">Emanuele Rosso</a> is licensed under <a class="ae jg" href="https://creativecommons.org/licenses/by-nc-nd/2.0/" rel="noopener ugc nofollow" target="_blank">CC BY-NC-ND 2.0</a></figcaption></figure><figure class="jh ji jj jk fq iv"><div class="bz el l di"><div class="jl jm l"/></div></figure><p id="50a2" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated"><em class="kl">在</em> <a class="ae jg" href="https://blog.bertwagner.com/5-things-you-need-to-do-when-performance-testing-json-in-sql-and-c-8dfe0ee101a9" rel="noopener ugc nofollow" target="_blank"> <em class="kl">更新帖子</em> </a> <em class="kl">中提供了更多性能对比。</em></p><p id="10bf" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated"><em class="kl">来看看我在</em><a class="ae jg" href="http://www.sqlsaturday.com/653/EventHome.aspx" rel="noopener ugc nofollow" target="_blank"><em class="kl">SQL 7月22日星期六哥伦布</em> </a> <em class="kl">演讲JSON和XML吧！</em></p><p id="0e22" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">从2016版开始，SQL Server提供了原生JSON支持。虽然实现得并不完美，<a class="ae jg" href="https://blog.bertwagner.com/json-support-is-the-best-new-developer-feature-in-sql-2016-bbb3ced89ce8" rel="noopener ugc nofollow" target="_blank">我</a> <a class="ae jg" href="https://blog.bertwagner.com/json-support-is-the-best-new-developer-feature-in-sql-2016-bf031f3dc40f" rel="noopener ugc nofollow" target="_blank"> am </a> <a class="ae jg" href="https://blog.bertwagner.com/json-support-is-the-best-new-developer-feature-in-sql-2016-part-3-updating-adding-and-deleting-24cea5fc0ab5" rel="noopener ugc nofollow" target="_blank">依然</a> <a class="ae jg" href="https://blog.bertwagner.com/json-support-is-the-best-new-developer-feature-in-sql-2016-part-4-performance-comparisons-bd04dc7635f3" rel="noopener ugc nofollow" target="_blank">一个</a> <a class="ae jg" href="https://blog.bertwagner.com/when-is-it-appropriate-to-store-json-in-sql-server-8ed1eed1520d" rel="noopener ugc nofollow" target="_blank">巨大的</a> <a class="ae jg" href="https://blog.bertwagner.com/video-json-usage-and-performance-in-sql-server-2016-524edcc5a610" rel="noopener ugc nofollow" target="_blank">迷</a>。</p><p id="724a" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">即使像JSON支持这样的新特性很棒，我也只有在它实用并且性能优于其他选择的情况下才会使用它。</p><p id="e9da" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">今天我想将JSON与XML进行比较，看看哪种格式更适合在SQL Server中使用。</p><h1 id="50c5" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">输入XML，SQL的坏小子</h1><p id="67ef" class="pw-post-body-paragraph jn jo hu jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk hn dt translated">完全公开:我不喜欢XML，也不喜欢SQL Server对它的实现。</p><p id="9748" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">XML太罗嗦了(在结束标签上浪费了很多字符)，它有元素和属性(我不喜欢为两种不同的场景编程)，根据你用什么语言编程，有时你需要模式文件，有时不需要。</p><p id="c9d2" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">SQL Server的XML实现确实有一些不错的特性，比如可以减少存储空间和验证语法的专用数据类型，但是我发现XML的查询很笨拙。</p><p id="4c7f" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">抛开所有对XML的不满，如果XML优于JSON，我仍然愿意使用它。因此，让我们运行一些测试查询！</p><h1 id="49f6" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">JSON SQL Server的新警长来了吗？</h1><p id="2a4e" class="pw-post-body-paragraph jn jo hu jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk hn dt translated">虽然性能是这些比较测试的最终决定因素，但我认为JSON在可用性方面比XML领先。SQL Server的JSON函数签名更容易记忆，在屏幕上写起来也更清晰。</p><p id="877c" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">我使用的测试数据是来自<a class="ae jg" href="https://github.com/arthurkao/vehicle-make-model-data" rel="noopener ugc nofollow" target="_blank">https://github.com/arthurkao/vehicle-make-model-data</a>的车辆年份/品牌/型号数据。下面是我将它加载到一个名为<code class="eh lp lq lr ls b">dbo.XmlVsJson</code>的表中后的样子:</p><pre class="jh ji jj jk fq lt ls lu lv aw lw dt"><span id="c335" class="lx kn hu ls b fv ly lz l ma mb">CREATE TABLE dbo.XmlVsJson<br/>(<br/>  Id INT IDENTITY PRIMARY KEY,<br/>  XmlData XML,<br/>  JsonData NVARCHAR(MAX)<br/>)</span></pre><figure class="jh ji jj jk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mc"><img src="../Images/dc758d7aab3194f14827428e62ee0ead.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2eW-U6wHeG5QMRl_DCz4Iw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">(<a class="ae jg" href="https://gist.github.com/bertwagner/5350454abfc682c358c6ffbe5bf7d8e9" rel="noopener ugc nofollow" target="_blank">The full data query is available in this gist </a>if you want to play along at home)</figcaption></figure><h1 id="4384" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">数据量</h1><p id="0dd8" class="pw-post-body-paragraph jn jo hu jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk hn dt translated">所以XML应该更大，对吗？它有那些重复的结束标签？</p><pre class="jh ji jj jk fq lt ls lu lv aw lw dt"><span id="6720" class="lx kn hu ls b fv ly lz l ma mb">SELECT<br/>  DATALENGTH(XmlData)/1024.0/1024.0 AS XmlMB,<br/>  DATALENGTH(JsonData)/1024.0/1024.0 AS JsonMB<br/>FROM<br/>  dbo.XmlVsJson</span></pre><figure class="jh ji jj jk fq iv fe ff paragraph-image"><div class="fe ff md"><img src="../Images/8411ee15cec20a2b5b55c52d924c5bbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*rA2xqDbn4MoVJivmlhTnxA.png"/></div></figure><p id="eeaa" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">原来XML实际上更小！怎么会这样呢？这就是<a class="ae jg" href="https://docs.microsoft.com/en-us/sql/relational-databases/xml/xml-data-type-and-columns-sql-server" rel="noopener ugc nofollow" target="_blank"> SQL Server XML数据类型</a>背后的魔力。SQL不将XML存储为一个巨大的字符串；它只存储<a class="ae jg" href="https://www.w3.org/TR/xml-infoset/" rel="noopener ugc nofollow" target="_blank"> XML信息集</a>，从而减少了空间。</p><p id="9724" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">另一方面，JSON存储为常规的旧nvarchar(max ),因此它的完整字符串内容被写入磁盘。在这种情况下，XML胜出。</p><figure class="jh ji jj jk fq iv fe ff paragraph-image"><div class="fe ff me"><img src="../Images/0ee7d4dd3c06213541d8e67b8f051b7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*liAyTu4vkxAdqUGDbn1J3g.png"/></div></figure><h1 id="8bee" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">插入性能</h1><p id="7f10" class="pw-post-body-paragraph jn jo hu jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk hn dt translated">因此，在nvarchar(max)数据类型中，使用XML数据类型时，XML实际存储的数据比JSON少，这是否意味着它的插入速度也会更快？下面是我们的查询，它尝试插入第一个查询中的100个重复行:</p><pre class="jh ji jj jk fq lt ls lu lv aw lw dt"><span id="5149" class="lx kn hu ls b fv ly lz l ma mb">SET STATISTICS TIME ON</span><span id="2d4e" class="lx kn hu ls b fv mf lz l ma mb">INSERT INTO dbo.XmlVsJson (XmlData)<br/>SELECT XmlData FROM dbo.XmlVsJson <br/>  CROSS APPLY <br/>  (<br/>    SELECT DISTINCT number <br/>    FROM master..spt_values <br/>    WHERE number BETWEEN 1 AND 100<br/>  )t WHERE Id = 1<br/>GO</span><span id="e3cb" class="lx kn hu ls b fv mf lz l ma mb">INSERT INTO dbo.XmlVsJson (JsonData)<br/>SELECT JsonData FROM dbo.XmlVsJson <br/>  CROSS APPLY <br/>  (<br/>    SELECT DISTINCT number <br/>    FROM master..spt_values <br/>    WHERE number BETWEEN 1 AND 100<br/>  )t WHERE Id = 1<br/>GO</span></pre><p id="3caa" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">结果呢？在我的机器上，插入100个XML行用了613ms，而插入100个JSON行用了1305ms… <strong class="jp hv"> XML又赢了！</strong></p><figure class="jh ji jj jk fq iv fe ff paragraph-image"><div class="fe ff mg"><img src="../Images/8e332da58667de2155b312d6fd14dc11.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*4MHQuc51IGi8RHfH4PNzuA.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">JSON ain’t looking too hot. Wait for it…</figcaption></figure><p id="625a" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">我想既然XML数据类型物理上存储的数据更少，那么它也可以更快地将数据写到表中。</p><h1 id="bc4d" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">CRUD操作</h1><p id="4a37" class="pw-post-body-paragraph jn jo hu jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk hn dt translated"><a class="ae jg" href="https://blog.bertwagner.com/json-support-is-the-best-new-developer-feature-in-sql-2016-part-4-performance-comparisons-bd04dc7635f3#.qfb67pue8" rel="noopener ugc nofollow" target="_blank">与相比，SQL Server的JSON性能给我留下了难以置信的印象。NET</a>——但是它与SQL Server 上的XML相比如何呢？</p><h2 id="03f7" class="lx kn hu bd ko mh mi mj ks mk ml mm kw jy mn mo la kc mp mq le kg mr ms li mt dt translated">阅读</h2><p id="e4ef" class="pw-post-body-paragraph jn jo hu jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk hn dt translated">让我们从XML和JSON中选择第二辆汽车的片段:</p><pre class="jh ji jj jk fq lt ls lu lv aw lw dt"><span id="cdc5" class="lx kn hu ls b fv ly lz l ma mb">SELECT t.XmlData.query('/cars/car[2]') <br/>FROM dbo.XmlVsJson t <br/>WHERE Id = 1</span><span id="e330" class="lx kn hu ls b fv mf lz l ma mb">SELECT JSON_QUERY(t.JsonData, '$.cars[1]') <br/>FROM dbo.XmlVsJson t <br/>WHERE Id = 1</span></pre><figure class="jh ji jj jk fq iv fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/552c8040d1eff59d502aa7cec314f5d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*xIxEp1A6ebvVN38_vvpAvQ.png"/></div></figure><p id="dd9c" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">结果？当需要从我们更大的对象字符串中提取一个片段时，JSON赢了(对于XML是0毫秒对63毫秒)。</p><figure class="jh ji jj jk fq iv fe ff paragraph-image"><div class="fe ff mv"><img src="../Images/d4ab595726f04943c1b393516d98b43a.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*HZaxJaObi3DXqUrwRElF4w.png"/></div></figure><p id="7d9d" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">如果我们想抓取一个特定的值而不是一个片段呢？</p><pre class="jh ji jj jk fq lt ls lu lv aw lw dt"><span id="a4b2" class="lx kn hu ls b fv ly lz l ma mb">SELECT t.XmlData.value('(/cars/car[2]/model)[1]', 'varchar(100)') FROM dbo.XmlVsJson t <br/>WHERE Id = 1</span><span id="be88" class="lx kn hu ls b fv mf lz l ma mb">SELECT JSON_VALUE(t.JsonData, '$.cars[1].model') <br/>FROM dbo.XmlVsJson t <br/>WHERE Id = 1</span></pre><p id="015e" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">JSON又一次以0毫秒对11毫秒的成绩赢得了XML。</p><figure class="jh ji jj jk fq iv fe ff paragraph-image"><div class="fe ff mw"><img src="../Images/7f95b48039007506246653e88a7bd08a.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*eSaU9dtM4uezlxGaRZxb1Q.png"/></div></figure><p id="ec61" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">如果您查看最后两个查询的执行计划，很容易发现XML在检索数据方面还有很多工作要做:</p><p id="6ab0" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">XML:</p><figure class="jh ji jj jk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mx"><img src="../Images/df6232b20cd9396947cbec97a959e15d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FGAieCLnIoQa5-zytrRNdQ.png"/></div></div></figure><p id="e6e6" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">JSON:</p><figure class="jh ji jj jk fq iv fe ff paragraph-image"><div class="fe ff my"><img src="../Images/52c3eb41747c8b154096c5e91d0af096.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*s9AOp29_eiltKVsNsZKW9g.png"/></div></figure><h2 id="b775" class="lx kn hu bd ko mh mi mj ks mk ml mm kw jy mn mo la kc mp mq le kg mr ms li mt dt translated">创造</h2><p id="4ff3" class="pw-post-body-paragraph jn jo hu jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk hn dt translated">我们在上面看到，插入XML数据行比插入JSON数据行更快，但是如果我们想将新数据插入对象字符串本身，该怎么办呢？这里我想将属性“里程”插入到第一个汽车对象中:</p><figure class="jh ji jj jk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mz"><img src="../Images/b2ef27f5d8feb1f1cb96ab17df93ce6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bTrkakuspYaj8iu5Lq7wSg.png"/></div></div></figure><pre class="jh ji jj jk fq lt ls lu lv aw lw dt"><span id="e751" class="lx kn hu ls b fv ly lz l ma mb">UPDATE t SET XmlData.modify('<br/>insert &lt;mileage&gt;100,000&lt;/mileage&gt;<br/>into (/cars/car[1])[1]') <br/>FROM dbo.XmlVsJson t <br/>WHERE Id = 1</span><span id="a530" class="lx kn hu ls b fv mf lz l ma mb">UPDATE t SET JsonData = JSON_MODIFY(JsonData,<br/>'$.cars[0].mileage','100,000') <br/>FROM dbo.XmlVsJson t <br/>WHERE Id = 1</span></pre><p id="e332" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">除了更简洁的语法(<code class="eh lp lq lr ls b">JSON_MODIFY()</code>本质上与<code class="eh lp lq lr ls b">REPLACE()</code>相同)之外，JSON insert运行时间为22毫秒，而XML为206毫秒。<strong class="jp hv">又一个JSON赢了。</strong></p><figure class="jh ji jj jk fq iv fe ff paragraph-image"><div class="fe ff me"><img src="../Images/71798ce993bddcd3bdf8efe443db2caa.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*KNg0gJ5jDKK5UjD1qLG5ig.png"/></div></figure><h2 id="6bf5" class="lx kn hu bd ko mh mi mj ks mk ml mm kw jy mn mo la kc mp mq le kg mr ms li mt dt translated">更新</h2><p id="209a" class="pw-post-body-paragraph jn jo hu jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk hn dt translated">让我们更新刚刚添加的里程属性，使其值为110，000:</p><pre class="jh ji jj jk fq lt ls lu lv aw lw dt"><span id="6e06" class="lx kn hu ls b fv ly lz l ma mb">UPDATE t SET XmlData.modify('<br/>replace value of (/cars/car[1]/mileage/text())[1]<br/>with     "110,000"') <br/>FROM dbo.XmlVsJson t<br/>WHERE Id = 1</span><span id="9e0b" class="lx kn hu ls b fv mf lz l ma mb">UPDATE t SET JsonData = JSON_MODIFY(JsonData, '$.cars[0].mileage','110,000') <br/>FROM dbo.XmlVsJson t<br/>WHERE Id = 1</span></pre><figure class="jh ji jj jk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff na"><img src="../Images/54bac25a276647c4b541f35a1ad41de7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HpV3kBbGV88TZUyoZviNEg.png"/></div></div></figure><p id="e37a" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">结果？<strong class="jp hv"> JSON的速度更快</strong>，能够在54毫秒内完成这次更新，而XML则需要194毫秒。</p><figure class="jh ji jj jk fq iv fe ff paragraph-image"><div class="fe ff nb"><img src="../Images/d7fe01170024ea21e89f9591918bbe26.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*FVuAl_pu3eyAhvuMNfImqg.png"/></div></figure><h2 id="a883" class="lx kn hu bd ko mh mi mj ks mk ml mm kw jy mn mo la kc mp mq le kg mr ms li mt dt translated">删除</h2><p id="af0c" class="pw-post-body-paragraph jn jo hu jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk hn dt translated">删除大型字符串数据，DBA的梦想。</p><p id="20b0" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">让我们删除里程属性，撤销我们刚刚做的所有艰苦工作:</p><pre class="jh ji jj jk fq lt ls lu lv aw lw dt"><span id="d2b8" class="lx kn hu ls b fv ly lz l ma mb">UPDATE t SET XmlData.modify('<br/>delete /cars/car[1]/mileage[1]') <br/>FROM dbo.XmlVsJson t <br/>WHERE Id = 1</span><span id="8958" class="lx kn hu ls b fv mf lz l ma mb">UPDATE t SET JsonData = JSON_MODIFY(JsonData, '$.cars[0].mileage', null) <br/>FROM dbo.XmlVsJson t <br/>WHERE Id = 1</span></pre><p id="ce50" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated"><strong class="jp hv"> JSON不需要任何时间来重新加载，并再次战胜XML</strong>50毫秒到159毫秒。</p><figure class="jh ji jj jk fq iv fe ff paragraph-image"><div class="fe ff me"><img src="../Images/215ab7d6dce0c497d2872c9ae13d044c.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*OJmS_3YJDKtNNI2a3pQCrg.png"/></div></figure><h2 id="0e92" class="lx kn hu bd ko mh mi mj ks mk ml mm kw jy mn mo la kc mp mq le kg mr ms li mt dt translated">阅读第2部分:索引</h2><p id="d708" class="pw-post-body-paragraph jn jo hu jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk hn dt translated">因此，从上面我们可以看到，JSON在从一行序列化数据中读取片段和属性时比XML更快。但是我们的SQL Server可能有很多行数据——索引数据解析在我们的匹配中表现如何？</p><p id="7166" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">首先，让我们扩展我们的数据——不是将我们所有的汽车对象存储在一个字段中，而是构建一个新表，让每辆汽车各占一行:</p><figure class="jh ji jj jk fq iv fe ff paragraph-image"><div class="fe ff nc"><img src="../Images/d0e54379a68794b4896567ad52d290f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*7wCQifeEmu7jmg1b5B2sTw.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">(once again, <a class="ae jg" href="https://gist.github.com/bertwagner/9a11650dce444fc22476f3e2c7e23307" rel="noopener ugc nofollow" target="_blank">full dataset at GitHub</a> if you are playing along at home)</figcaption></figure><p id="af05" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">现在我们的表中有了扩展的数据，让我们添加一些索引。SQL Server中的XML数据类型有自己的索引类型，而<a class="ae jg" href="https://blog.bertwagner.com/one-sql-cheat-code-for-amazingly-fast-json-queries-1c2402b4b0d2" rel="noopener ugc nofollow" target="_blank"> JSON只需要一个应用了常规索引的计算列</a>。</p><pre class="jh ji jj jk fq lt ls lu lv aw lw dt"><span id="5cce" class="lx kn hu ls b fv ly lz l ma mb">DROP INDEX IF EXISTS PXML_XmlData ON XmlVsJson2<br/>CREATE PRIMARY XML INDEX PXML_XmlData<br/>ON XmlVsJson2 (XmlData);</span><span id="7482" class="lx kn hu ls b fv mf lz l ma mb">ALTER TABLE dbo.XmlVsJson2<br/>ADD MakeComputed AS JSON_VALUE(JsonData, '$.make')<br/>CREATE NONCLUSTERED INDEX IX_JsonData ON dbo.XmlVsJson2 (MakeComputed)</span></pre><p id="4330" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated"><em class="kl">(注意:我还尝试添加了一个</em> <a class="ae jg" href="https://docs.microsoft.com/en-us/sql/relational-databases/xml/xml-indexes-sql-server" rel="noopener ugc nofollow" target="_blank"> <em class="kl"> XML二级索引</em> </a> <em class="kl">以获得更好的性能，但是我无法让查询引擎在这样一个基本数据集上使用该二级索引)</em></p><p id="56ce" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">如果我们试图找到匹配谓词的所有行:</p><pre class="jh ji jj jk fq lt ls lu lv aw lw dt"><span id="cfbb" class="lx kn hu ls b fv ly lz l ma mb">SELECT Id, XmlData <br/>FROM dbo.XmlVsJson2 t <br/>WHERE t.XmlData.exist('/car/make[.="ACURA"]') = 1</span><span id="153c" class="lx kn hu ls b fv mf lz l ma mb">SELECT Id, JsonData <br/>FROM dbo.XmlVsJson2 t <br/>WHERE JSON_VALUE(t.JsonData, '$.make') = 'ACURA'</span></pre><p id="84d8" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">XML能够在200毫秒内过滤掉96行，JSON在9毫秒内完成同样的任务。JSON的最后胜利。</p><figure class="jh ji jj jk fq iv fe ff paragraph-image"><div class="fe ff mw"><img src="../Images/4d3cc07a6714f8e549fa73faad17ed51.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*-jtWONmiCCGvf25KsnmB3Q.png"/></div></figure><h1 id="50a0" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">结论</h1><p id="9015" class="pw-post-body-paragraph jn jo hu jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk hn dt translated">如果您需要在SQL Server中存储和操作序列化的字符串数据，毫无疑问:JSON是首选格式。尽管JSON的存储大小比它的XML前身稍大，但几乎在所有情况下，SQL Server的JSON函数在速度上都优于XML。</p><p id="6c95" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">将所有旧的XML代码重写为JSON是否有足够的性能差异？可能不会，但每个案例都不一样。</p><p id="d1bf" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">有一点很清楚:新的开发应该考虑利用SQL Server的新JSON功能。</p><figure class="jh ji jj jk fq iv"><div class="bz el l di"><div class="nd jm l"/></div></figure><p id="48db" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated">喜欢这篇文章吗？请推荐给它一颗绿色的心💚<em class="kl">下图。</em></p><p id="3653" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hn dt translated"><em class="kl">在SQL Server 2016+中，您还打算使用XML而不是JSON进行新的开发吗？我很想在下面的评论中知道为什么。</em></p><figure class="jh ji jj jk fq iv"><div class="bz el l di"><div class="nd jm l"/></div></figure></div></div>    
</body>
</html>