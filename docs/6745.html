<html>
<head>
<title>Trouble with Databases? Persevere with Persistent!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据库有问题？持之以恒的坚持！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/trouble-with-databases-persevere-with-persistent-e05aba9dd03f?source=collection_archive---------23-----------------------#2017-10-02">https://medium.com/hackernoon/trouble-with-databases-persevere-with-persistent-e05aba9dd03f?source=collection_archive---------23-----------------------#2017-10-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="3b0d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的<a class="ae jp" href="https://mmhaskell.com/blog/2017/8/7/the-future-is-functional-haskell-and-the-ai-native-world" rel="noopener ugc nofollow" target="_blank">最近系列</a>在<a class="ae jp" href="https://www.mmhaskell.com/" rel="noopener ugc nofollow" target="_blank">周一早上哈斯克尔</a>专注于机器学习。特别是，我们深入研究了Haskell张量流库。虽然人工智能确实是一个巨大的领域，但它并不占日常工作的大部分。要构建一个基本的生产系统，还有许多更简单的任务。在我们最新的系列中，我们将学习许多不同的库来执行这些任务！</p><p id="0b42" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在第一篇文章中，我们将讨论<a class="ae jp" href="https://hackage.haskell.org/package/persistent" rel="noopener ugc nofollow" target="_blank">持久性</a>。许多库允许您进行快速SQL调用。但是坚持不止于此。使用Persistent，您可以将Haskell类型链接到数据库定义。您还可以进行类型安全查询，以省去解码数据的麻烦。总而言之，这是一个非常酷的系统。</p><p id="f073" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个系列的所有代码都会在<a class="ae jp" href="https://github.com/jhb563/ProdHaskellSeries" rel="noopener ugc nofollow" target="_blank"> Github </a>上！为了跟随这篇文章，看一看<code class="eh jq jr js jt b"><a class="ae jp" href="https://github.com/jhb563/ProdHaskellSeries/tree/persistent" rel="noopener ugc nofollow" target="_blank">persistent</a></code> <a class="ae jp" href="https://github.com/jhb563/ProdHaskellSeries/tree/persistent" rel="noopener ugc nofollow" target="_blank">分支</a>。</p><h1 id="ebbb" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">我们的基本类型</h1><p id="91e5" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">我们首先考虑一个简单的用户类型，如下所示:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="2791" class="lf jv hu jt b fv lg lh l li lj">data User = User<br/>  { userName :: Text<br/>  , userEmail :: Text<br/>  , userAge :: Int<br/>  , userOccupation :: Text<br/>  }</span></pre><p id="1c18" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设我们想在SQL数据库中存储这种类型的对象。我们首先需要定义表来存储我们的用户。我们可以用手动SQL命令或通过编辑器来实现，但不管怎样，这个过程都容易出错。该命令类似于以下内容:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="c9a5" class="lf jv hu jt b fv lg lh l li lj">create table users (<br/>  name varchar(100),<br/>  email varchar(100),<br/>  age bigint,<br/>  occupation varchar(100)<br/>)</span></pre><p id="4cdb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们这样做时，没有任何东西将我们的Haskell数据类型链接到表结构。如果我们更新Haskell代码，我们必须记得更新数据库。这意味着编写另一个容易出错的命令。</p><p id="bc21" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从我们的Haskell程序中，我们还想基于用户的结构进行SQL查询。我们可以写出这些原始命令并执行它们，但同样的问题也适用。这种方法容易出错，而且根本不是类型安全的。坚持帮助我们解决这些问题。</p><h1 id="733b" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">持久和模板Haskell</h1><p id="6b34" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">我们可以从Persistent获得这些奖金，而不需要那么多额外的代码！为此，我们将使用模板Haskell (TH)。我们在过去为不同的数据类型派生<a class="ae jp" href="https://mmhaskell.com/blog/2017/6/12/taking-a-close-look-at-lenses" rel="noopener ugc nofollow" target="_blank">透镜和棱镜</a>时见过一次。在那种情况下，我们注意到了一些赞成和反对的意见。它确实允许我们避免编写一些样板代码。但是它也会使我们的编译时间变长。这也会让没有经验的Haskellers更难访问我们的代码。但是对于镜头，它只为我们节省了几十行代码。使用Persistent，th会生成更多的代码，所以好处肯定大于坏处。</p><p id="4974" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们用th创建镜头时，我们使用了一个简单的声明<code class="eh jq jr js jt b">makeLenses</code>。在这里，我们将做一些更复杂的事情。我们将使用一种叫做“准引用者”的语言结构。这是一个代码块，遵循程序员或库中设计的一些语法，而不是普通的Haskell语法。它经常用在做某种外来函数接口的库中。我们用括号和管道的组合来界定一个准报价器。下面是Haskell调用的模板。准引用者是最后一个论点:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="682b" class="lf jv hu jt b fv lg lh l li lj">import qualified Database.Persist.TH as PTH</span><span id="c285" class="lf jv hu jt b fv lk lh l li lj">PTH.share [PTH.mkPersist PTH.sqlSettings, PTH.mkMigrate "migrateAll"] [PTH.persistLowerCase|</span><span id="d270" class="lf jv hu jt b fv lk lh l li lj">|]</span></pre><p id="3c58" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jq jr js jt b">share</code>函数接受设置列表，然后接受准报价器本身。然后，它为我们的数据模式生成必要的模板Haskell。在本节中，我们将定义数据库将使用的所有不同类型。我们注意到某些特定的设置。我们特别指定了<code class="eh jq jr js jt b">sqlSettings</code>，所以我们在这里所做的一切都将集中在SQL数据库上。更重要的是，我们还创建了一个迁移函数，<code class="eh jq jr js jt b">migrateAll</code>。在这个模板Haskell被编译之后，这个函数将允许我们迁移我们的数据库。这意味着它将为我们创建所有的表！</p><p id="920e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是在我们看到这一点之前，我们需要重新定义我们的用户类型。我们将在准引用程序中定义<code class="eh jq jr js jt b">User</code>，而不是用普通的Haskell方式。注意，这个级别的模板Haskell需要许多编译器扩展。这是我们的定义:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="3b5b" class="lf jv hu jt b fv lg lh l li lj">{-# LANGUAGE TemplateHaskell            #-}<br/>{-# LANGUAGE QuasiQuotes                #-}<br/>{-# LANGUAGE TypeFamilies               #-}<br/>{-# LANGUAGE MultiParamTypeClasses      #-}<br/>{-# LANGUAGE GADTs                      #-}<br/>{-# LANGUAGE GeneralizedNewtypeDeriving #-}<br/>{-# LANGUAGE RecordWildCards            #-}<br/>{-# LANGUAGE FlexibleInstances          #-}<br/>{-# LANGUAGE OverloadedStrings          #-}</span><span id="d654" class="lf jv hu jt b fv lk lh l li lj">PTH.share [PTH.mkPersist PTH.sqlSettings, PTH.mkMigrate "migrateAll"] [PTH.persistLowerCase|<br/>  User sql=users<br/>    name Text<br/>    email Text<br/>    age Int<br/>    occupation Text<br/>    UniqueEmail email<br/>    deriving Show Read<br/>|]</span></pre><p id="2c12" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Haskell中的普通数据定义有很多相似之处。我们改变了格式，颠倒了类型和名称的顺序。但还是能看出来是怎么回事。字段名都在那里。我们仍然像在Haskell中一样派生基本实例。</p><p id="48d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是我们也增加了一些新的指令。例如，我们已经说明了表名应该是什么(默认情况下应该是<code class="eh jq jr js jt b">user</code>，而不是<code class="eh jq jr js jt b">users</code>)。我们还创建了一个<code class="eh jq jr js jt b">UniqueEmail</code>约束。这告诉我们的数据库，每个用户必须有一个唯一的电子邮件。迁移将处理创建所有必要的索引以使其工作！</p><p id="dddc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个模板Haskell将为我们生成普通的Haskell数据类型。所有字段都将有前缀<code class="eh jq jr js jt b">user</code>，并且按照我们的指定，将是骆驼大小写。编译器还会为我们的类型生成某些特殊的实例。这些将使我们能够使用Persistent的类型安全查询函数。最后，这段代码生成了我们将在查询中用作过滤器的镜头，我们将在后面看到。</p><h1 id="e00a" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">实体和键</h1><p id="b5fb" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">Persistent也有一个允许我们处理数据库id的构造。对于我们放入模式中的每个类型，我们都有一个相应的<code class="eh jq jr js jt b">Entity</code>类型。一个<code class="eh jq jr js jt b">Entity</code>引用我们数据库中的一行，它将一个数据库ID与对象本身相关联。数据库ID的类型为<code class="eh jq jr js jt b">SqlKey</code>，是<code class="eh jq jr js jt b">Int64</code>的包装器。所以下面看起来像是一个有效的实体:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="54f3" class="lf jv hu jt b fv lg lh l li lj">import Database.Persist (Entity(..))</span><span id="0138" class="lf jv hu jt b fv lk lh l li lj">sampleUser :: Entity User<br/>sampleUser = Entity (toSqlKey 1) $ User<br/>  { userName = “admin”<br/>  , userEmail = “admin@test.com”<br/>  , userAge = 23<br/>  , userOccupation = “System Administrator”<br/>  }</span></pre><p id="4d5b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个漂亮的小抽象允许我们避免用数据库id混淆用户类型。这允许我们的其他代码使用更纯的<code class="eh jq jr js jt b">User</code>类型。</p><h1 id="41d8" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">SqlPersistT Monad</h1><p id="ab4a" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">现在我们有了模式的基础，我们如何通过Haskell代码与数据库进行交互呢？作为一个具体的例子，我们将访问一个PostgresQL数据库。这需要<code class="eh jq jr js jt b">SqlPersistT</code>单子。所有查询函数都返回这个单子中的动作。monad转换器必须位于monad之上，monad是<code class="eh jq jr js jt b">MonadIO</code>，因为我们显然需要IO来运行数据库查询。</p><p id="a497" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们试图从一个普通的<code class="eh jq jr js jt b">IO</code>函数进行数据库查询，我们首先需要的是一个<code class="eh jq jr js jt b">ConnectionString</code>。该字符串对有关数据库位置的信息进行编码。连接字符串通常有4-5个组件。它包含主机/IP地址、端口、数据库用户名和数据库名称。例如，如果您在本地机器上运行Postgres，您可能会看到这样的内容:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="620f" class="lf jv hu jt b fv lg lh l li lj">{-# LANGUAGE OverloadedStrings #-}</span><span id="ace8" class="lf jv hu jt b fv lk lh l li lj">import Database.Persist.Postgresql (ConnectionString)</span><span id="4c78" class="lf jv hu jt b fv lk lh l li lj">connString :: ConnectionString<br/>connString = “host=127.0.0.1 port=5432 user=postgres dbname=postgres password=password”</span></pre><p id="9468" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们有了连接字符串，我们准备调用<code class="eh jq jr js jt b">withPostgresqlConn</code>。该函数接受字符串，然后接受需要一个<code class="eh jq jr js jt b">backend</code>的函数:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="7c22" class="lf jv hu jt b fv lg lh l li lj">-- Also various constraints on the monad m<br/>withPostgresqlConn :: (IsSqlBackend backend) =&gt; ConnectionString -&gt; (backend -&gt; m a) -&gt; m a</span></pre><p id="959f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jq jr js jt b">IsSqlBackend</code>约束迫使我们使用符合Persistent准则的类型。单子只是T2的同义词。所以一般来说，我们对这个后端做的唯一一件事就是把它作为<code class="eh jq jr js jt b">runReaderT</code>的参数。一旦我们做到了这一点，我们就可以将<code class="eh jq jr js jt b">SqlPersistT</code>中的任何动作作为参数来运行。</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="d641" class="lf jv hu jt b fv lg lh l li lj">import Control.Monad.Logger (runStdoutLoggingT)<br/>import Database.Persist.Postgresql (ConnectionString, withPostgresqlConn, SqlPersistT)</span><span id="51dd" class="lf jv hu jt b fv lk lh l li lj">…</span><span id="563e" class="lf jv hu jt b fv lk lh l li lj">runAction :: ConnectionString -&gt; SqlPersistT a -&gt;  IO a<br/>runAction connectionString action = runStdoutLoggingT $ withPostgresqlConn connectionString $ \backend -&gt;<br/>  runReaderT action backend</span></pre><p id="5bce" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意，我们添加了一个对<code class="eh jq jr js jt b">runStdoutLoggingT</code>的调用，这样我们的操作就可以记录它的结果，正如Persistent所期望的那样。每当我们使用<code class="eh jq jr js jt b">withPostgresqlConn</code>时，这是必要的。下面是我们运行迁移功能的方式:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="759c" class="lf jv hu jt b fv lg lh l li lj">migrateDB :: IO ()<br/>migrateDB = runAction connString (runMigration migrateAll)</span></pre><p id="d83c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将创建<code class="eh jq jr js jt b">users</code>表，完全符合我们的数据定义！</p><h1 id="bf14" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">问题</h1><p id="2768" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">现在，让我们快速检查一下可以运行的查询类型，以此结束本文。我们可以做的第一件事是在数据库中插入一个新用户。为此，持久具有<code class="eh jq jr js jt b">insert</code>功能。当我们插入用户时，我们将得到该用户的一个密钥。下面是为我们特定的<code class="eh jq jr js jt b">User</code>类型指定的<code class="eh jq jr js jt b">insert</code>的类型签名:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="6fac" class="lf jv hu jt b fv lg lh l li lj">insert :: (MonadIO m) =&gt; User -&gt; SqlPersistT m (Key User)</span></pre><p id="79a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然我们也可以反过来做。假设我们有一个用户的密钥，我们想从数据库中获取它。我们需要<code class="eh jq jr js jt b">get</code>函数。当然，如果数据库中没有相应的用户，这可能会失败，所以我们需要一个<code class="eh jq jr js jt b">Maybe</code>。：</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="e99c" class="lf jv hu jt b fv lg lh l li lj">get :: (MonadIO m) =&gt; Key User -&gt; SqlPersistT m (Maybe User)</span></pre><p id="395f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以对满足<code class="eh jq jr js jt b">PersistRecordBackend</code>类的任何类型使用这些函数。当我们使用模板Haskell方法时，这是免费的。因此，您可以对模式中的任何类型使用这些查询。</p><p id="6f49" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是SQL允许我们做的不仅仅是用键查询。假设我们想要得到所有符合特定标准的用户。我们将使用<code class="eh jq jr js jt b">selectList</code>函数，它复制了SQL <code class="eh jq jr js jt b">SELECT</code>命令的行为。运行选择的不同方式需要几个不同的参数。这两种列表类型看起来有点复杂，但是我们将更详细地研究它们:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="fc1c" class="lf jv hu jt b fv lg lh l li lj">selectList <br/>  :: PersistRecordBackend backend val <br/>  =&gt; [Filter val] <br/>  -&gt; [SelectOpt val]<br/>  -&gt; SqlPersistT m [val]</span></pre><p id="23e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">和以前一样，TH模式中的任何类型都可以满足<code class="eh jq jr js jt b">PersistRecordBackend</code>约束。所以我们知道我们的<code class="eh jq jr js jt b">User</code>型适合。让我们来看看第一个论点。它提供了不同过滤器的列表，这些过滤器将决定我们获取哪些元素。例如，假设我们想要所有年龄小于25岁、职业为“教师”的用户。还记得我提到的生成的透镜吗？我们将使用这些镜头创建两个不同的滤镜。</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="bb7b" class="lf jv hu jt b fv lg lh l li lj">selectYoungTeachers :: (MonadIO m, MonadLogger m) =&gt; SqlPersistT m [User]<br/>selectYoungTeachers = select [UserAge &lt;. 25, UserOccupation ==. “Teacher”] []</span></pre><p id="8369" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们使用<code class="eh jq jr js jt b">UserAge</code>镜头和<code class="eh jq jr js jt b">UserOccupation</code>镜头来选择要过滤的区域。我们使用“小于”运算符来表示年龄必须小于25岁。同样，我们使用<code class="eh jq jr js jt b">==.</code>操作符来匹配职业。然后我们提供一个<code class="eh jq jr js jt b">SelectOpts</code>的空列表。</p><p id="c004" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第二个选择操作列表提供了一些我们可能在<code class="eh jq jr js jt b">select</code>语句中预期的其他特性。首先，我们可以对返回的数据进行排序。我们还将在这里使用生成的镜头。例如，<code class="eh jq jr js jt b">Asc UserEmail</code>将通过电子邮件订购我们的清单。这里是一个有序查询，我们也将自己限制为100个条目。下面是该查询的样子:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="2067" class="lf jv hu jt b fv lg lh l li lj">selectYoungTeachers’ :: (MonadIO m) =&gt; SqlPersistT m [User]<br/>selectYoungTeachers’ = selectList [UserAge &lt;=. 25, UserOccupation ==. “Teacher”] [Asc UserEmail]</span></pre><p id="bb57" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">其他类型的<code class="eh jq jr js jt b">SelectOpts</code>包括极限和偏移。例如，我们可以进一步修改该查询以排除前5个用户(按照电子邮件的顺序)，然后将我们的选择限制为100:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="b2e4" class="lf jv hu jt b fv lg lh l li lj">selectYoungTeachers' :: (MonadIO m) =&gt; SqlPersistT m [Entity User]<br/>selectYoungTeachers' = selectList<br/>  [UserAge &lt;. 25, UserOccupation ==. "Teacher"] [Asc UserEmail, OffsetBy 5, LimitTo 100]</span></pre><p id="6ebd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是使查询类型安全和合理的全部内容。我们知道我们实际上是在过滤对我们类型有意义的价值观。我们不必担心错别字会在运行时破坏我们的代码。</p><h1 id="59ab" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">结论</h1><p id="1f78" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">Persistent为我们提供了一些与Haskell数据库交互的优秀工具。模板Haskell机制生成了许多样板代码来帮助我们。例如，我们可以迁移数据库，为Haskell类型创建正确的表。我们还可以执行以类型安全的方式过滤结果的查询。总而言之，这是一次奇妙的经历。</p><p id="7088" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">没试过哈斯克尔吗？每当您尝试运行SQL查询时，其他语言是否会因运行时错误而让您感到沮丧？你应该给哈斯克尔一个机会！下载我们的<a class="ae jp" href="https://www.mmhaskell.com/checklist" rel="noopener ugc nofollow" target="_blank">入门清单</a>以获得一些对您有帮助的工具！</p><p id="ee30" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你对Haskell有点熟悉，但不确定如何合并像Persistent这样的库，你应该看看我们的<a class="ae jp" href="http://academy.mondaymorninghaskell.com/p/your-first-haskell-project" rel="noopener ugc nofollow" target="_blank"> Stack迷你课程</a>。它将带你了解使用Stack创建一个简单的Haskell程序的基本知识。</p></div></div>    
</body>
</html>