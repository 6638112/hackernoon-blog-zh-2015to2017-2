<html>
<head>
<title>ʼ;ŚℇℒℇℂƮ *: How Unicode Homoglyphs Will Break Your Custom SQL Injection Sanitizing Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ʼ;śℇℒℇℂʈ*:unicode同形异义字符将如何破坏您的自定义SQL注入净化函数</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/%CA%BC-%C5%9B%E2%84%87%E2%84%92%E2%84%87%E2%84%82%CA%88-how-unicode-homoglyphs-will-break-your-custom-sql-injection-sanitizing-functions-1224377f7b51?source=collection_archive---------9-----------------------#2017-12-11">https://medium.com/hackernoon/%CA%BC-%C5%9B%E2%84%87%E2%84%92%E2%84%87%E2%84%82%CA%88-how-unicode-homoglyphs-will-break-your-custom-sql-injection-sanitizing-functions-1224377f7b51?source=collection_archive---------9-----------------------#2017-12-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/5148261a9585efb8a2f50c2b52367666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UMH0PXjEmggA1HzY.jpg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><em class="jg">Photo by </em><a class="ae jh" href="https://unsplash.com/photos/vJqSAasmCEY?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"><em class="jg">Niketh Vellanki</em></a><em class="jg"> on </em><a class="ae jh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"><em class="jg">Unsplash</em></a></figcaption></figure><p id="2029" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">在过去的几周里，我一直在写关于如何<a class="ae jh" href="https://blog.bertwagner.com/warning-are-your-queries-vulnerable-to-sql-injection-db914fb39668" rel="noopener ugc nofollow" target="_blank">保护你的数据库</a>免受<a class="ae jh" href="https://blog.bertwagner.com/how-to-safely-parameterize-table-names-63446a1033fb" rel="noopener ugc nofollow" target="_blank">SQL注入攻击</a>。今天，我们将通过观察隐式unicode转换如何使您的数据易受攻击来保持这一趋势。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="ed3b" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated"><em class="km">您也可以在我的</em><a class="ae jh" href="https://www.youtube.com/watch?v=DVWiMrqqMK0" rel="noopener ugc nofollow" target="_blank"><em class="km">YouTube</em></a><em class="km">频道观看此内容。</em></p><h1 id="4c47" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">什么是同形异义字？</h1><p id="62e2" class="pw-post-body-paragraph ji jj hu jk b jl ll jn jo jp lm jr js jt ln jv jw jx lo jz ka kb lp kd ke kf hn dt translated">同形异义字符是看起来像另一个字符的字符。L(小写“L”)和1(数字)被视为同形异义字符。O(字母)和0(数字)也是如此。</p><p id="a8af" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">同形异义词可以存在于一个字符集内(如上面的拉丁字符集示例)，也可以存在于字符集之间的<em class="km">。例如，您可能有unicode撇号，它是拉丁语单引号字符<code class="eh lq lr ls lt b">'</code>的同形异义字符。</em></p><h1 id="e4ec" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">SQL Server如何处理unicode同形异义字符？</h1><p id="e583" class="pw-post-body-paragraph ji jj hu jk b jl ll jn jo jp lm jr js jt ln jv jw jx lo jz ka kb lp kd ke kf hn dt translated">你这么问很有趣。如果将unicode字符传递给非unicode数据类型(如char)，<strong class="jk hv"> SQL隐式地将unicode字符转换为最接近的非unicode同形异义字符。</strong></p><p id="a68b" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">要了解这一点，我们可以使用上面示例中的unicode撇号:</p><pre class="kg kh ki kj fq lu lt lv lw aw lx dt"><span id="e63d" class="ly ko hu lt b fv lz ma l mb mc">SELECT<br/>  CAST(N'ʼ' AS nchar) AS UnicodeChar,<br/>  CAST(N'ʼ' AS char) AS NonUnicodeChar</span></pre><p id="0d45" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">您可以在第二列中看到SQL自动将撇号转换为单引号:</p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div class="fe ff md"><img src="../Images/4eff3c47bb66a93851dab0ce2f978c63.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*qJppqNrERuM3VAc1.png"/></div></figure><p id="20bd" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">虽然这种隐式字符转换在您希望在非unicode字符集中显示unicode字符时会很方便，但它会给您的<a class="ae jh" href="https://hackernoon.com/tagged/sql-server" rel="noopener ugc nofollow" target="_blank"> SQL Server </a> <a class="ae jh" href="https://hackernoon.com/tagged/security" rel="noopener ugc nofollow" target="_blank">安全性</a>带来灾难。</p><h1 id="d5b6" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">Unicode同形异义字符SQL注入</h1><p id="4b0d" class="pw-post-body-paragraph ji jj hu jk b jl ll jn jo jp lm jr js jt ln jv jw jx lo jz ka kb lp kd ke kf hn dt translated">如果您在构建动态sql查询时已经使用了<a class="ae jh" href="https://blog.bertwagner.com/warning-are-your-queries-vulnerable-to-sql-injection-db914fb39668" rel="noopener ugc nofollow" target="_blank"> sp_executesql </a>或<a class="ae jh" href="https://blog.bertwagner.com/how-to-safely-parameterize-table-names-63446a1033fb" rel="noopener ugc nofollow" target="_blank"> QUOTENAME() </a>，那么您就不会遇到这种类型的SQL注入。</p><p id="7a51" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">我知道，当像上面这样可靠、安全且经过测试的功能可用时，你不是那种会编写自己的安全功能的人。然而，就这一次，让我们假设你认为你可以通过编写自己的引号定界代码来战胜黑客。</p><p id="c20e" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated"><a class="ae jh" href="https://gist.github.com/bertwagner/c22bd5c068f30bef21bf3738c5a52029" rel="noopener ugc nofollow" target="_blank">使用与上周相同的数据集</a>，让我们创建一个新的存储过程，它将从用户的个人资料中返回一些数据:</p><pre class="kg kh ki kj fq lu lt lv lw aw lx dt"><span id="4e64" class="ly ko hu lt b fv lz ma l mb mc">DROP PROCEDURE IF EXISTS dbo.GetProfile<br/>GO<br/>CREATE PROCEDURE dbo.GetProfile<br/> <a class="ae jh" href="http://twitter.com/Username" rel="noopener ugc nofollow" target="_blank">@Username</a> nvarchar(100)<br/>AS<br/>BEGIN<br/> -- Add quotes to escape injection...or not?<br/> SET <a class="ae jh" href="http://twitter.com/Username" rel="noopener ugc nofollow" target="_blank">@Username</a> = REPLACE(<a class="ae jh" href="http://twitter.com/Username" rel="noopener ugc nofollow" target="_blank">@Username</a>, '''','''''')</span><span id="f6fe" class="ly ko hu lt b fv me ma l mb mc">DECLARE <a class="ae jh" href="http://twitter.com/Query" rel="noopener ugc nofollow" target="_blank">@Query</a> varchar(max)</span><span id="fd6a" class="ly ko hu lt b fv me ma l mb mc">SET <a class="ae jh" href="http://twitter.com/Query" rel="noopener ugc nofollow" target="_blank">@Query</a> = 'SELECT <br/>     FullName, <br/>     JoinDate<br/>    FROM<br/>     dbo.RegisteredUser<br/>    WHERE<br/>     UserName = ''' + <a class="ae jh" href="http://twitter.com/Username" rel="noopener ugc nofollow" target="_blank">@Username</a> + '''<br/>     '</span><span id="0e5d" class="ly ko hu lt b fv me ma l mb mc">EXEC(<a class="ae jh" href="http://twitter.com/Query" rel="noopener ugc nofollow" target="_blank">@Query</a>)<br/>END<br/>GO</span></pre><p id="0ed0" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">不要使用sp_executesql或QUOTENAME()，让我们尝试编写我们自己的聪明的REPLACE()函数，它将用两组单引号替换单引号。理论上，这应该可以防止SQL注入。</p><p id="59ea" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">如果我们在SQL注入测试一个“正常”的尝试，你会注意到这个逻辑非常有效。给自己一个鼓励！</p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div class="fe ff mf"><img src="../Images/62bcea0d00f8daec34db455ebb91a06a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/0*ZA6F3jdz-FUMbYut.png"/></div></figure><p id="098e" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">但是，如果我们传入一个unicode撇号:</p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mg"><img src="../Images/1e009df272a3af4fc967c4f40928f7c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*J-TeRdjjWjEeWZxw.png"/></div></div></figure><p id="a98f" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">发生这种情况的原因是因为我们将@Query参数声明为varchar，而不是unicode nvarchar。当我们构建动态SQL语句时，SQL <a class="ae jh" href="https://blog.bertwagner.com/are-your-indexes-being-thwarted-by-mismatched-datatypes-d3985375e528" rel="noopener ugc nofollow" target="_blank">隐式地将nvarchar @Username参数转换为非unicode varchar:</a></p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mh"><img src="../Images/4be58918478abc70c24207f93099ccc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mABXm5vSIf4R2Ixa.png"/></div></div></figure><h1 id="325c" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">所以如果我替换撇号，会让我安全吗？</h1><p id="6a01" class="pw-post-body-paragraph ji jj hu jk b jl ll jn jo jp lm jr js jt ln jv jw jx lo jz ka kb lp kd ke kf hn dt translated"><strong class="jk hv">号</strong></p><p id="ffdb" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">我知道看起来黑名单/替换unicode撇号可以解决我们所有的问题。</p><p id="25b0" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">它会…只在这种情况下。然而，unicode同音字不仅仅是一个撇号。</p><p id="dba6" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">出于好奇，我编写了一个脚本来搜索unicode字符空间，看看还存在哪些同形异义字符:</p><pre class="kg kh ki kj fq lu lt lv lw aw lx dt"><span id="8de1" class="ly ko hu lt b fv lz ma l mb mc">DECLARE <a class="ae jh" href="http://twitter.com/FirstNumber" rel="noopener ugc nofollow" target="_blank">@FirstNumber</a> INT=0;<br/>-- number of possible characters in the unicode space<br/>DECLARE <a class="ae jh" href="http://twitter.com/LastNumber" rel="noopener ugc nofollow" target="_blank">@LastNumber</a> INT=1114112;<br/> <br/>WITH Numbers AS (<br/>    SELECT <a class="ae jh" href="http://twitter.com/FirstNumber" rel="noopener ugc nofollow" target="_blank">@FirstNumber</a> AS n<br/>    UNION ALL<br/>    SELECT n+1 FROM Numbers WHERE n+1&lt;=<a class="ae jh" href="http://twitter.com/LastNumber" rel="noopener ugc nofollow" target="_blank">@LastNumber</a><br/>), UnicodeConversion AS (<br/>SELECT<br/>       n AS CharacterNumber,<br/>       CASE CAST(NCHAR(n) as CHAR(1))<br/>              WHEN '''' THEN NCHAR(n)<br/>              WHEN ';' THEN NCHAR(n)<br/>       END AS UnicodeCharacter,<br/>       CAST(NCHAR(n) as CHAR(1)) AS ASCIICharacter<br/>FROM Numbers<br/>)<br/>SELECT<br/>       *<br/>FROM<br/>       UnicodeConversion<br/>WHERE<br/>       UnicodeCharacter IS NOT NULL<br/>OPTION (MAXRECURSION 0)</span></pre><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div class="fe ff mi"><img src="../Images/2b585a8f62372a7916232dd4911f75df.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/0*SZDu087eav5lG3QD.png"/></div></figure><p id="21a5" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">尽管上面屏幕截图中的字符看起来很相似，但它们实际上是同形异义词。</p><p id="551d" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">我决定只搜索单引号和分号，因为它们在SQL注入攻击中经常使用，但这绝不是您想要列入黑名单的所有字符的详尽列表。</p><p id="1d19" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">不仅很难有把握地将每个危险的同形异义字符列入黑名单，而且新字符一直在添加到unicode中，因此维护黑名单将是一场维护噩梦。尤其是如果将来维护这段代码的人不熟悉这些类型的注入攻击。</p><p id="cea3" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">不要厚颜无耻地认为你可以过滤掉危险的SQL关键字——即使你替换了(@Username，' SELECT '，" ")，只要记住有人会过来传入一个像'śεℒℇℂʈ'.这样的值</p><h1 id="f689" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">结论</h1><p id="f197" class="pw-post-body-paragraph ji jj hu jk b jl ll jn jo jp lm jr js jt ln jv jw jx lo jz ka kb lp kd ke kf hn dt translated">不要编写自己的安全函数——它们会失败。</p><p id="11b4" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">防范SQL注入的最佳方法是不要使用动态SQL。如果您<em class="km">有</em>使用动态SQL，那么使用sp_executesql和QUOTENAME()中的一个。</p><p id="7d98" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated"><em class="km">你可能也会喜欢</em> <a class="ae jh" href="https://twitter.com/bertwagner" rel="noopener ugc nofollow" target="_blank"> <em class="km">在Twitter上关注我</em> </a> <em class="km">。</em></p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="mj kl l"/></div></figure><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="mj kl l"/></div></figure></div></div>    
</body>
</html>