<html>
<head>
<title>JavaScript: Do you like games? (part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:你喜欢游戏吗？(第二部分)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/javascript-do-you-like-games-part-2-9d4141ca2493?source=collection_archive---------3-----------------------#2016-10-24">https://medium.com/hackernoon/javascript-do-you-like-games-part-2-9d4141ca2493?source=collection_archive---------3-----------------------#2016-10-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="fe6a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">关于这个话题:<a class="ae jp" href="https://blog.hellojs.org/javascript-do-you-like-games-part-1-c1320c2c52ec" rel="noopener ugc nofollow" target="_blank">第1部分</a> |第2部分| <a class="ae jp" href="https://blog.hellojs.org/javascript-do-you-like-games-part-3-6225ec264902" rel="noopener ugc nofollow" target="_blank">第3部分</a> | <a class="ae jp" rel="noopener" href="/@radu.bogdan.gaspar/javascript-do-you-like-games-part-4-9d6e8adb5626">第4部分</a> | <a class="ae jp" rel="noopener" href="/@radu.bogdan.gaspar/javascript-do-you-like-games-part-5-a79bb69ad9e1">第5部分</a> | <a class="ae jp" rel="noopener" href="/@radu.bogdan.gaspar/javascript-do-you-like-games-part-6-7bff0b8ce05e">第6部分</a></p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/e0ca8667cb4037a29bca5fc0730ddfe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VUJsiIjFDp0UxHCI5uchlA.png"/></div></div></figure><p id="4188" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">是时候开始研究游戏的核心组件<a class="ae jp" href="https://hackernoon.com/tagged/engine" rel="noopener ugc nofollow" target="_blank">引擎</a>了。在本文结束之前，我们应该可以在<strong class="it hv"> <em class="kc">画布</em> </strong>上渲染一些东西！</p><blockquote class="kd ke kf"><p id="7a4f" class="ir is kc it b iu iv iw ix iy iz ja jb kg jd je jf kh jh ji jj ki jl jm jn jo hn dt translated">注意:请注意，我将在<a class="ae jp" href="https://github.com/raduGaspar/game-physx" rel="noopener ugc nofollow" target="_blank"> GIT库</a>历史树中添加特定代码片段的链接。这将使您更容易运行我在描述特定功能时所运行的代码。</p></blockquote><p id="537f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将从没有依赖关系的类开始工作，比如:<strong class="it hv"> <em class="kc"> Game，AssetLoader </em> </strong>和<strong class="it hv"><em class="kc">event dispatcher</em></strong>然后进展到其他可能扩展这些的类。</p><p id="b1d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">游戏<em class="kc">游戏</em>游戏</strong>类游戏:</p><ul class=""><li id="e56b" class="kj kk hu it b iu iv iy iz jc kl jg km jk kn jo ko kp kq kr dt translated">接受一个<strong class="it hv"> <em class="kc">场景</em> </strong>作为可选的构造函数参数</li><li id="f036" class="kj kk hu it b iu ks iy kt jc ku jg kv jk kw jo ko kp kq kr dt translated">保留对所有已创建场景的引用</li><li id="b152" class="kj kk hu it b iu ks iy kt jc ku jg kv jk kw jo ko kp kq kr dt translated">拥有添加和移除场景的公共方法</li><li id="9815" class="kj kk hu it b iu ks iy kt jc ku jg kv jk kw jo ko kp kq kr dt translated">有一个公共的<strong class="it hv"> <em class="kc"> loop() </em> </strong>方法，该方法将在所有存储的场景上触发<strong class="it hv"> <em class="kc"> update() </em> </strong>方法</li><li id="b0a3" class="kj kk hu it b iu ks iy kt jc ku jg kv jk kw jo ko kp kq kr dt translated">拥有暂停和恢复循环的公共方法；我们先把这些叫做:<strong class="it hv"> <em class="kc">【播放()】</em></strong><strong class="it hv"><em class="kc">【暂停()</em></strong><strong class="it hv"><em class="kc">toggle pause()</em></strong></li></ul><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="kx ky l"/></div><figcaption class="kz la fg fe ff lb lc bd b be z ek">engine/Game.js</figcaption></figure><p id="78d2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里需要做一些改进，比如检查添加的场景是否是真实的<strong class="it hv">场景</strong>实例，添加对没有requestAnimationFrame的浏览器的支持，可能会实现一个flux架构来存储数据并防止状态突变。</p><p id="acba" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">flux架构可能会在晚些时候出现，但目前我们将该引擎视为P.O.C .(概念验证)…这意味着我也不会费心添加对旧浏览器的支持，但如果你需要，你肯定可以使用<a class="ae jp" href="https://gist.github.com/paulirish/1579671" rel="noopener ugc nofollow" target="_blank"> rAF polyfill </a>。</p><p id="df88" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> AssetLoader </strong>类可以:</p><ul class=""><li id="aeab" class="kj kk hu it b iu iv iy iz jc kl jg km jk kn jo ko kp kq kr dt translated">成为单例，这样我们就可以从任何其他类中检索资产</li><li id="0e4c" class="kj kk hu it b iu ks iy kt jc ku jg kv jk kw jo ko kp kq kr dt translated">公开一个load方法，该方法将接收一组指向本地资产的路径；该方法应该返回一个承诺，这样我们就可以检测所有资产何时被加载</li><li id="f11b" class="kj kk hu it b iu ks iy kt jc ku jg kv jk kw jo ko kp kq kr dt translated">根据转换为camel case的名称存储资产</li><li id="f23e" class="kj kk hu it b iu ks iy kt jc ku jg kv jk kw jo ko kp kq kr dt translated">支持加载图像和音频文件</li></ul><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="kx ky l"/></div><figcaption class="kz la fg fe ff lb lc bd b be z ek">engine/utils/AssetsLoader.js</figcaption></figure><p id="890f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你通常会在单例类上实现一个<strong class="it hv"> <em class="kc"> getInstance() </em> </strong>方法，这里我们只是在调用类构造函数时返回先前创建的实例。</p><p id="8785" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里我们还依赖于一个<strong class="it hv"> Utils </strong>类，它目前只处理资产“名称到骆驼大小写”的逻辑；看起来是这样的:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="kx ky l"/></div><figcaption class="kz la fg fe ff lb lc bd b be z ek">engine/utils/Utils.js</figcaption></figure><p id="67bb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这实际上是一个静态类，为了实现这一点，我们只是在它的构造函数中抛出一个错误。这意味着试图调用<strong class="it hv"> <em class="kc"> new Utils() </em> </strong>将会失败。这个类目前相当简单，因为它只有一个静态方法；我们以后可能会添加更多。</p><p id="94a8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> EventDispatcher </strong>类可以:</p><ul class=""><li id="6ed9" class="kj kk hu it b iu iv iy iz jc kl jg km jk kn jo ko kp kq kr dt translated">成为单例，因为所有游戏类都需要能够引用同一个<strong class="it hv"> EventDispatcher </strong>实例。这通常不被认可，因为它基本上是一个全局事件调度器，但是如果我们以后想要实现flux架构，我们将需要它。</li><li id="ac63" class="kj kk hu it b iu ks iy kt jc ku jg kv jk kw jo ko kp kq kr dt translated">公开<strong class="it hv"> <em class="kc"> on() </em> </strong>和<strong class="it hv"> <em class="kc"> trigger() </em> </strong>方法，帮助我们订阅和发出事件。</li></ul><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="kx ky l"/></div><figcaption class="kz la fg fe ff lb lc bd b be z ek">engine/events/EventDispatcher.js</figcaption></figure><p id="4ad1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可能会认为这个看起来比其他的更奇怪，这是有原因的。使用ES6语法扩展singleton有点棘手，在这里阅读我描述这个问题的文章<a class="ae jp" rel="noopener" href="/@radu.bogdan.gaspar/javascript-extending-singletons-experiment-with-es6-e416c7d49723"/>。</p><p id="d6ef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还没完。在我们画出任何东西之前，我们还有一些编码工作要做。根据上一篇文章中的模式，我们现在可以专注于实现扩展<strong class="it hv"> EventDispatcher </strong>的<strong class="it hv">键盘</strong>类。</p><p id="7ab3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">键盘</strong>类可以:</p><ul class=""><li id="37eb" class="kj kk hu it b iu iv iy iz jc kl jg km jk kn jo ko kp kq kr dt translated">单身</li><li id="2f52" class="kj kk hu it b iu ks iy kt jc ku jg kv jk kw jo ko kp kq kr dt translated">暴露告诉我们某个键是否被按下的getters</li></ul><p id="eead" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">暴露<em class="kc"> A到Z </em>、<em class="kc">空格</em>、<em class="kc">箭头键</em>、<em class="kc"> tab </em>、<em class="kc"> enter </em>、<em class="kc"> shift </em>、<em class="kc"> ctrl </em>、<em class="kc"> alt </em>、<em class="kc"> esc </em>和功能键<em class="kc"> F1到F12 </em>的getters就足够了。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="kx ky l"/></div><figcaption class="kz la fg fe ff lb lc bd b be z ek">engine/inputs/Keyboard.js</figcaption></figure><p id="41d2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个类也使用<strong class="it hv"> KeyboardEvents </strong>，看起来像这样:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="kx ky l"/></div><figcaption class="kz la fg fe ff lb lc bd b be z ek">engine/events/KeyboardEvents.js</figcaption></figure><p id="9c53" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个类包含一些静态方法，这些方法返回基本上作为常量的事件名。你可能想知道为什么我没有简单地做:</p><pre class="jr js jt ju fq ld le lf lg aw lh dt"><span id="aebf" class="li lj hu le b fv lk ll l lm ln">export const KEY_UP = 'keyup';</span></pre><p id="b128" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是因为这种方法允许导入类，通过该类我们可以访问所有与<strong class="it hv">键盘</strong>相关的静态getters。我们不需要分别导入每个常量。</p><p id="43f3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">既然我们终于有了<strong class="it hv">键盘</strong>类，接下来我们可以关注<strong class="it hv">画布</strong>。</p><p id="7594" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">画布</strong>类可以:</p><ul class=""><li id="d698" class="kj kk hu it b iu iv iy iz jc kl jg km jk kn jo ko kp kq kr dt translated">单身</li><li id="9d4b" class="kj kk hu it b iu ks iy kt jc ku jg kv jk kw jo ko kp kq kr dt translated">能够在调整窗口大小时调整自身大小</li><li id="49e9" class="kj kk hu it b iu ks iy kt jc ku jg kv jk kw jo ko kp kq kr dt translated">允许访问<canvas>标签及其所有属性</canvas></li><li id="34f8" class="kj kk hu it b iu ks iy kt jc ku jg kv jk kw jo ko kp kq kr dt translated">暴露用于绘图的画布CTX(2D上下文)</li></ul><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="kx ky l"/></div><figcaption class="kz la fg fe ff lb lc bd b be z ek">engine/ui/Canvas.js</figcaption></figure><p id="6a3f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此时，我们可以通过使用<em class="kc"> ctx </em>属性直接在<strong class="it hv">画布</strong>上进行绘制，但是这样做既无聊又愚蠢，因为它不会使用我们在其他类中构建的任何逻辑。让我们把重点放在构建另一个能帮助我们的类上，即:<strong class="it hv">场景</strong>。</p><p id="be85" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">场景</strong>类可能:</p><ul class=""><li id="445e" class="kj kk hu it b iu iv iy iz jc kl jg km jk kn jo ko kp kq kr dt translated">扩展<strong class="it hv">画布</strong>并保留对自身的引用，以便在扩展<strong class="it hv">场景</strong>的其他类中访问</li><li id="956a" class="kj kk hu it b iu ks iy kt jc ku jg kv jk kw jo ko kp kq kr dt translated">允许初始化x，y，宽度和高度属性，这将需要有一些默认值</li><li id="548c" class="kj kk hu it b iu ks iy kt jc ku jg kv jk kw jo ko kp kq kr dt translated">允许添加和删除<strong class="it hv">显示对象</strong></li><li id="d1ba" class="kj kk hu it b iu ks iy kt jc ku jg kv jk kw jo ko kp kq kr dt translated">导出一个<strong class="it hv"> <em class="kc"> update() </em> </strong>方法，该方法将依次调用所有存储的<strong class="it hv"> DisplayObjects </strong>的<strong class="it hv"> <em class="kc"> update() </em> </strong>方法</li><li id="b9e6" class="kj kk hu it b iu ks iy kt jc ku jg kv jk kw jo ko kp kq kr dt translated">基于提供的x、y、宽度和高度，在每次更新时清除自身</li><li id="041c" class="kj kk hu it b iu ks iy kt jc ku jg kv jk kw jo ko kp kq kr dt translated">使所有绘制位置都相对于<strong class="it hv">场景</strong>实例——这意味着如果<strong class="it hv">场景</strong>有<em class="kc"> { x: 20，y: 20 } </em>并且我们给它添加了一个<strong class="it hv">显示对象</strong>和<em class="kc"> { x: 0，y: 0 } </em>，那么<strong class="it hv">显示对象</strong>将被绘制在<strong class="it hv">画布上的{ x: 20，y: 20 }处</strong></li><li id="8944" class="kj kk hu it b iu ks iy kt jc ku jg kv jk kw jo ko kp kq kr dt translated">隐藏在其视口之外绘制的任何元素，视口由x、y、宽度和高度定义</li><li id="3270" class="kj kk hu it b iu ks iy kt jc ku jg kv jk kw jo ko kp kq kr dt translated">提供一个静态的<strong class="it hv"> <em class="kc"> wrap() </em> </strong>方法，如果对象的x和y位置超出了<strong class="it hv">场景</strong>的边界，该方法将重置对象的x和y位置</li></ul><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="kx ky l"/></div><figcaption class="kz la fg fe ff lb lc bd b be z ek">engine/ui/Scene.js</figcaption></figure><p id="c0bb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们有一个<strong class="it hv">场景</strong>，基于它的逻辑，我们可以向它添加一个元素，该元素将被更新和渲染…前提是该元素有<strong class="it hv"> <em class="kc"> update() </em> </strong>和<strong class="it hv"> <em class="kc"> render() </em> </strong>方法。</p><p id="f14e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在是我们期待已久的时刻。这就是你如何用超级复杂的方式画出两个移动的方块…</p><p id="eb48" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<em class="kc"> js </em>目录下(与<em class="kc">引擎</em>目录同级)新建一个文件夹，命名为<em class="kc"> square </em>。使用以下逻辑创建一个<em class="kc"> index.js </em>文件:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="kx ky l"/></div><figcaption class="kz la fg fe ff lb lc bd b be z ek">square/index.js</figcaption></figure><p id="bcc5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了简洁起见，我在同一个文件中创建了<strong class="it hv"> Square </strong>类，但是我们现在有了一个在画布上创建和渲染静态或移动对象的基本引擎。</p><p id="117a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">方块<strong class="it hv"> </strong>以预定的速度在x和y轴上移动，如果按下SHIFT键，速度会加倍。对象的位置被包装到父屏幕<strong class="it hv">上，这样你就可以随意摆弄了。不要忘记你继承了所有的键盘功能，所以享受其中的乐趣吧。</strong></p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lo ky l"/></div></figure><p id="7ca8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">获取文件并在此进行测试:</p><div class="lp lq fm fo lr ls"><a href="https://github.com/raduGaspar/game-physx/tree/81b1d84d941da3e3a234e7586c656e57662d6110" rel="noopener  ugc nofollow" target="_blank"><div class="lt ab ej"><div class="lu ab lv cl cj lw"><h2 class="bd hv fv z el lx eo ep ly er et ht dt translated">红景天/游戏-physx</h2><div class="lz l"><h3 class="bd b fv z el lx eo ep ly er et ek translated">一个用于JavaScript游戏制作的小工具</h3></div><div class="ma l"><p class="bd b gc z el lx eo ep ly er et ek translated">github.com</p></div></div><div class="mb l"><div class="mc l md me mf mb mg ka ls"/></div></div></a></div><p id="5305" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">显然还有一些改进要做，比如:对所有单例实例使用"<em class="kc"> const </em>"而不是"<em class="kc"> let </em>"，弄清楚如何在有多个实例的类中使用私有变量而不导致覆盖(如果你在想"<a class="ae jp" href="https://hackernoon.com/tagged/weakmap" rel="noopener ugc nofollow" target="_blank">weak map</a>"……那可能弊大于利)，以及为我们的游戏引擎使用一个存储；仅举几个例子。</p><p id="1155" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将在下一篇文章中继续讨论运动在游戏中如何工作，覆盖精灵表、精灵、动画精灵、控制帧速率、显示对象枢轴点和另一个实现示例。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mh ky l"/></div></figure></div></div>    
</body>
</html>