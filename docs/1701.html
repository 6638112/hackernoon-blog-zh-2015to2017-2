<html>
<head>
<title>Akka.io, sbt-assembly and Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Akka.io，SBT-装配和对接</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/akka-io-sbt-assembly-and-docker-a88b649f63cf?source=collection_archive---------9-----------------------#2016-11-30">https://medium.com/hackernoon/akka-io-sbt-assembly-and-docker-a88b649f63cf?source=collection_archive---------9-----------------------#2016-11-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="981c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们使用akka功能已经有一段时间了，但我们也开始探索我们现在拥有的actor系统的Docker部署。在我之前的两篇帖子中，<a class="ae jp" href="https://hackernoon.com/yet-another-sbt-docker-introduction-2d9fb99fe367#.52uwpg3bt" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> <em class="jq">还有另一篇sbt-docker简介</em> </strong> </a>，以及<strong class="it hv"><em class="jq"/></strong><a class="ae jp" href="https://hackernoon.com/akka-cluster-in-docker-a-straight-forwards-configuration-b6deea32752d#.x5cpvjl0s" rel="noopener ugc nofollow" target="_blank"><strong class="it hv"><em class="jq">Akka集群在docker中，简单明了地配置了</em></strong></a><strong class="it hv"><em class="jq"/></strong>我们已经探索过如何使用一些工具，直接嵌入到我们的构建管道中，来做部署到Docker中。然而，我们的团队提出了一个问题，<em class="jq">我们是应该创建一个胖罐子并将其放在docker上，还是应该将所有依赖项一起进行部署？</em></p><h1 id="0be5" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated">sbt组件</h1><p id="525b" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">直接从文档中</p><blockquote class="ku kv kw"><p id="fc9a" class="ir is jq it b iu iv iw ix iy iz ja jb kx jd je jf ky jh ji jj kz jl jm jn jo hn dt translated">sbt-assembly是一个sbt插件，最初移植自codahale的assembly-sbt，我猜是受到了Maven的assembly插件的启发。目标很简单:为您的项目及其所有依赖项创建一个大容器。</p></blockquote><p id="630f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个很好的工具，对于管理依赖性非常有用。使用sbt-assembly，我们可以创建一个单独的JAR，然后将它添加到Docker中。让我们把sbt-docker和sbt-assembly插件结合起来。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="cbc9" class="lj js hu lf b fv lk ll l lm ln">lazy val dockerSettings = Seq(<br/>    dockerfile in docker := {<br/>        val artifact: File = assembly.value<br/>        val artifactTargetPath = s"/app/${artifact.name}"<br/>        <br/>        new Dockerfile {<br/>          from("java")<br/>          add(artifact, artifactTargetPath)<br/>          entryPoint("java", "-jar", artifactTargetPath)<br/>        }<br/>  },<br/><br/>  ....<br/>}</span></pre><p id="c4c1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个sbt设置将创建fat JAR，将其添加到Docker映像中，并创建一个入口点，这样当容器启动时，我们的应用程序就会运行。</p><p id="c910" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里没有什么特别的，这应该适用于任何应用程序，除非它不工作。</p><p id="3baf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">问题不在于插件，而在于Akka本身。Akka文档说每个模块依赖于它自己的配置，也就是说我们需要多个Akka配置文件。这就给我们带来了下一个问题，如果Akka用默认值生成配置文件，它们将如何在sbt-assembly过程中被合并？如果你跟随<a class="ae jp" href="http://letitcrash.com/post/21706121997/follow-up-sbt-assembly-now-likes-referenceconf" rel="noopener ugc nofollow" target="_blank"> <em class="jq">这个链接</em> </a>，你会意识到这已经为我们解决了。尽管如此，我们还是想提供一个名为<em class="jq"> application.prod.conf </em>的配置文件，它位于<em class="jq"> resources/confs/ </em>目录中，让我们看看如何实现。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="333f" class="lj js hu lf b fv lk ll l lm ln">lazy val dockerSettings = Seq(<br/>    dockerfile in docker := {<br/>    <br/>         val dockerFiles = {<br/>            val resources = (unmanagedResources in Runtime).value<br/>            val dockerFilesDir = resources<br/>                .find(_.getPath.endsWith("/confs"))<br/>                .get<br/>            resources<br/>                .filter(_.getPath.contains("/confs/"))<br/>                .map(r =&gt; <br/>                    dockerFilesDir<br/>                        .toURI<br/>                        .relativize(r.toURI)<br/>                        .getPath -&gt; r)<br/>                .toMap<br/>          }<br/>    <br/>        val artifact: File = assembly.value<br/>        val artifactTargetPath = s"/app/${artifact.name}"<br/>        <br/>        new Dockerfile {<br/>          from("java")<br/>          add(artifact, artifactTargetPath)<br/>          add(dockerFiles(<br/>            "application.prod.conf"),<br/>            ("/app/application.prod.conf")<br/>          )<br/>          entryPoint(<br/>            "java", <br/>            "-Dconfig.resource=/app/application.prod.conf", <br/>            "-jar", <br/>            artifactTargetPath<br/>          )<br/>        }<br/>  },<br/><br/>  ....<br/>}</span></pre><p id="05e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这里，我们已经添加了我们自己的配置，并在入口点指定我们希望将它用作资源。现在，我们的Docker映像将拥有fat JAR和我们将用作资源的配置。</p><p id="cd83" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种方法工作得很好，但是我们不喜欢这个过程。与这些容器相关的构建时间很长，因为sbt必须清理所有东西，然后编译、运行测试、组装所有东西(真的需要很长时间)并创建Docker映像。你可能会认为这是一个小问题，但是如果你每次都要构建一百个图像，相信我，这需要相当长的时间。</p><h2 id="6294" class="lj js hu bd jt lo lp lq jx lr ls lt kb jc lu lv kf jg lw lx kj jk ly lz kn ma dt translated">组装还是不组装</h2><p id="fb90" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">从您的应用程序创建一个单独的JAR在很多场景下都是有意义的，但是如果我们要在Docker上部署，真的值得经历所有这些耗时的过程吗？</p><p id="581c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">嗯，我们的应用程序有一个独特的JAR的想法是封装依赖关系，这使我们能够更有效地管理我们的发布过程。只有一个里面装着所有东西的罐子，最终还是很方便的。但是，Docker背后不也是这样的想法吗？Docker映像是我们的应用程序的封装，可以部署在任何地方，在这种情况下，它取代了(或像以前一样)使用单个JAR的想法。</p><p id="bf77" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些是我们作为一个团队讨论过的主张没有脂肪罐的集装箱化的想法。</p><p id="176d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们回顾一下所需的更改。</p><p id="1dcf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，我们从<strong class="it hv"> <em class="jq"> plugins.sbt </em> </strong>中移除<em class="jq"> sbt-assembly </em>，取而代之的是<em class="jq"> sbt-native-packager </em>。</p><p id="ccac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第二，我们改变了在我们的<strong class="it hv"> <em class="jq"> build.sbt </em> </strong>中创建Docker映像的方式</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="8c44" class="lj js hu lf b fv lk ll l lm ln">lazy val dockerSettings = Seq(<br/>    dockerfile in docker := {<br/>         val dockerFiles = {<br/>            val resources = (unmanagedResources in Runtime).value<br/>            val dockerFilesDir = resources<br/>                .find(_.getPath.endsWith("/confs"))<br/>                .get<br/>            resources<br/>                .filter(_.getPath.contains("/confs/"))<br/>                .map(r =&gt; <br/>                    dockerFilesDir<br/>                        .toURI<br/>                        .relativize(r.toURI)<br/>                        .getPath -&gt; r)<br/>                .toMap<br/>          }</span><span id="81ab" class="lj js hu lf b fv mb ll l lm ln"><br/>        val appDir: File = stage.value<br/>        val targetDir = "/app"<br/>    <br/>        new Dockerfile {<br/>          from("java")<br/>          add(appDir, targetDir)<br/>          add(dockerFiles(<br/>            "application.prod.conf"),<br/>            ("/app/application.conf"))          <br/>          entryPoint(<br/>              s"$targetDir/bin/${executableScriptName.value}"<br/>          )<br/>        }<br/>    },<br/> <br/> ...<br/> <br/>}</span></pre><p id="0cf9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意，现在我们不再依赖于汇编，而是使用<em class="jq"> stage.value </em>。换句话说，我们将由<em class="jq">阶段</em>生成的内容添加到我们容器中的<strong class="it hv"> /app </strong>中。还有，切入点变了。<em class="jq"> sbt-native-packager </em>使用一个启动脚本代替<em class="jq"> java -jar </em>命令。记住，我们需要将<em class="jq"> application.prod.conf </em>文件添加到其中，但是我们不想使用额外的JVM参数，我们将其重命名为默认的<em class="jq"> application.conf </em>。</p><p id="9780" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最终，不创建fat JARs的改变减少了我们80%的构建时间，这是我们最大的问题。</p><h1 id="8164" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated">最後的</h1><p id="a0d3" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">有时我们不知道该做什么，特别是在软件工程中，但是直到我们测试了不同的方法，看看哪一个最适合我们的需要。</p><p id="7023" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从来没有唯一的解决方案，大部分时间都是在各种想法的混合中找到我们的解决方案。在我们的例子中(Docker上的akka)，sbt-assembly很好，但是增加了太多的构建时间。另一方面，Docker是一个必须拥有的平台，同时它为我们的应用程序提供了与其他环境中的sbt-assembly相同的封装。</p><p id="ce09" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们希望这篇文章能让你对我们的问题有所了解，你可能正在用类似的部署策略构建系统。</p><p id="4fbd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">免责声明:我们在Docker之外的应用程序中使用sbt-assembly没有任何问题，我们没有任何反对，恰恰相反。你只需要为你的用例找到合适的平衡点。</p><blockquote class="ku kv kw"><p id="facf" class="ir is jq it b iu iv iw ix iy iz ja jb kx jd je jf ky jh ji jj kz jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is jq it b iu iv iw ix iy iz ja jb kx jd je jf ky jh ji jj kz jl jm jn jo hn dt translated">要了解更多信息，<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">请阅读我们的“关于”页面</a>，<a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is jq it b iu iv iw ix iy iz ja jb kx jd je jf ky jh ji jj kz jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>