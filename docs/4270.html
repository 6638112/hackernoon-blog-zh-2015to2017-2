<html>
<head>
<title>Type Class Patterns and Anti-patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类型类模式和反模式</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/type-class-patterns-and-anti-patterns-efd045c5af66?source=collection_archive---------7-----------------------#2017-05-22">https://medium.com/hackernoon/type-class-patterns-and-anti-patterns-efd045c5af66?source=collection_archive---------7-----------------------#2017-05-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="0815" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在之前的<a class="ae jp" href="https://hackernoon.com/typeclass-instance-selection-fea1068920e6" rel="noopener ugc nofollow" target="_blank">帖子</a>中，我写过类型类实例选择是如何工作的。为了帮助理解好的类型类设计，我想介绍一个类型类模式和一个相关的类型类反模式。</p><h1 id="a8af" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">到/自类型类</h1><p id="1699" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">第一种模式是<code class="eh kt ku kv kw b">To</code>和<code class="eh kt ku kv kw b">From</code>类型的类。这种模式出现在许多包中:<code class="eh kt ku kv kw b">aeson</code>、<code class="eh kt ku kv kw b"><a class="ae jp" href="https://hackage.haskell.org/package/cassava-0.4.5.1/docs/Data-Csv.html" rel="noopener ugc nofollow" target="_blank">cassava</a></code>、<code class="eh kt ku kv kw b"><a class="ae jp" href="https://hackage.haskell.org/package/postgresql-simple" rel="noopener ugc nofollow" target="_blank">postgresql-simple</a></code>等等。</p><p id="5fbf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一般来说，<code class="eh kt ku kv kw b">To</code>类看起来像:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="9f52" class="lf jr hu kw b fv lg lh l li lj">class ToBlah a where<br/>  toBlah :: a -&gt; Blah</span></pre><p id="fb74" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尽管它也可以具有以下形式:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="cdb6" class="lf jr hu kw b fv lg lh l li lj">class ToBlah a where<br/>  toBlah :: a -&gt; BlahBuilder</span></pre><p id="98e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里的<code class="eh kt ku kv kw b">BlahBuilder</code>是<code class="eh kt ku kv kw b">Blah</code>更有效的可组合中间版本(当通过<code class="eh kt ku kv kw b">Builder</code> s转换为<code class="eh kt ku kv kw b">ByteString</code> s时就是这种情况)。</p><p id="e0bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kt ku kv kw b">From</code>类型的类看起来像:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="7be0" class="lf jr hu kw b fv lg lh l li lj">class FromBlah a where<br/>  parseBlah :: Parser a</span></pre><p id="360b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kt ku kv kw b">Parser</code>类型通常公开一个带有某种状态类型的<code class="eh kt ku kv kw b">Monad</code>接口，以及一种简化解析以产生错误消息的方法。往往会有一些API函数使用解析器(这是<code class="eh kt ku kv kw b">aeson</code>中的<code class="eh kt ku kv kw b"><a class="ae jp" href="https://hackage.haskell.org/package/aeson-1.2.0.0/docs/Data-Aeson.html#v:decode" rel="noopener ugc nofollow" target="_blank">decode</a></code>函数和<code class="eh kt ku kv kw b">postgresql-simple</code>中的<code class="eh kt ku kv kw b"><a class="ae jp" href="https://hackage.haskell.org/package/postgresql-simple-0.5.3.0/docs/Database-PostgreSQL-Simple.html#g:15" rel="noopener ugc nofollow" target="_blank">query</a></code>函数)，它们只被直接用来组成其他解析器。</p><p id="240f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有时<code class="eh kt ku kv kw b">To</code>和<code class="eh kt ku kv kw b">From</code>类都有；其他时候，如在<code class="eh kt ku kv kw b"><a class="ae jp" href="https://hackage.haskell.org/package/yesod-core-1.4.33/docs/Yesod-Core-Content.html#t:ToContent" rel="noopener ugc nofollow" target="_blank">Yesod.Core.Content.ToContent</a></code>的情况下，只需要一个方向。</p><p id="11df" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一般来说，这种模式用于在用户定义的类型和围绕其构建API的特定类型之间进行转换。</p><h1 id="6874" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">为什么To模式是好的</h1><p id="9b00" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">让我们看一个带有<code class="eh kt ku kv kw b">aeson</code>的<code class="eh kt ku kv kw b">ToJSON</code>的例子，它用于将用户的类型转换为<code class="eh kt ku kv kw b">Value</code>或JSON表达式类型。</p><p id="8a27" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我有喜欢的类型，</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="87cf" class="lf jr hu kw b fv lg lh l li lj">data BigRecord = BigRecord<br/>  { fiestaPolicies  :: [Policy]<br/>  , brunchMenu      :: Menu<br/>  , dinnerMenu      :: Menu<br/>  , backgroundMusic :: Maybe (Either ScreamingMan [Song])<br/>  }</span></pre><p id="3255" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此类类型的<code class="eh kt ku kv kw b">ToJSON</code>实例往往很无聊，如*:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="1ccf" class="lf jr hu kw b fv lg lh l li lj">instance ToJSON BigRecord where<br/>  toJSON BigRecord {..} = object<br/>    [ ("fiesta-policy"   , toJSON fiestaPolicies )<br/>    , ("brunch-menu"     , toJSON brunchMenu     )<br/>    , ("dinner-menu"     , toJSON dinnerMenu     )<br/>    , ("background-music", toJSON backgroundMusic)<br/>    ]</span></pre><p id="6477" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">无聊就好。无聊意味着可预测。无聊是指我在写或者读的时候不用费劲思考。</p><p id="22b7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，类型类允许我们为像<code class="eh kt ku kv kw b">Maybe a</code>和<code class="eh kt ku kv kw b">Either a b</code>这样的多态类型编写一个函数。<code class="eh kt ku kv kw b">a</code>和<code class="eh kt ku kv kw b">b</code>的实例将自动正确使用。</p><p id="0bef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">类型类提供规范性，一个类型只有一个实例。对于每种类型只有一个有效转换的转换来说，<code class="eh kt ku kv kw b">To</code>类是一个很好的选择。类型类模式利用标识符重载和规范化来减少编写实例时的自由度。</p><h1 id="326e" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">自由不是免费的</h1><p id="1ee9" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">如果我不使用<code class="eh kt ku kv kw b">To</code>类型的类模式，我需要做出更多的选择。每次我做出选择，我就增加了做出错误选择的机会。</p><p id="f49f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里有一种我们可以像<code class="eh kt ku kv kw b">ToJSON</code>例子一样编写转换代码的方法:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="7b60" class="lf jr hu kw b fv lg lh l li lj">bigRecordToJSON :: BigRecord -&gt; Value<br/>bigRecordToJSON BigRecord {..} = object<br/>  [ ("fiesta-policy" . , listToJSON policyToJSON fiestaPolicies)<br/>  , ("brunch-menu"     , brunchMenuToJSON brunchMenu)<br/>  , ("dinner-menu"     , dinnerMenuToJSON dinnerMenu)<br/>  , ("background-music", maybeToJSON (eitherJSON screamingManToJSON           <br/>                                                 playlistToJSON<br/>                                     ) <br/>                                     backgroundMusic<br/>    )<br/>  ]</span></pre><p id="885b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">即使转换完全由类型决定，我也必须为转换选择正确的函数。此外，我必须向每个多态转换函数传递一个额外的函数——实际上，每个类型变量传递一个函数。</p><p id="23e0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这段代码是最好的情况。我已经预先分解了我的转换函数，并使用了命名约定。我并不总是发现自己处于如此幸运的境地。</p><p id="5bc9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于将代码分解成小函数的动机较小，它也可能看起来像这样:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="a4d2" class="lf jr hu kw b fv lg lh l li lj">bigRecordToJSON :: BigRecord -&gt; Value<br/>bigRecordToJSON BigRecord {..} = object<br/>  [ ("fiesta-policy"   , Array <br/>                       $ Vector.fromList <br/>                       $ map policyToJSON fiestaPolicies<br/>    )<br/>  , ("brunch-menu"     , Array <br/>                       $ Vector.fromList<br/>                       $ map brunchMenuItem brunchMenu    <br/>    )<br/>  , ("dinner-menu"     , Array <br/>                       $ Vector.fromList<br/>                       $ map dinnerMenuItem dinnerMenu    <br/>    )<br/>  , ("background-music", maybe (object []) <br/>                               (eitherJSON screamingManToJSON           <br/>                                           playlistToJSON<br/>                               ) <br/>                               backgroundMusic<br/>    )<br/>  ]</span></pre><p id="d435" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于这两个版本，我添加了潜在的问题。如果你还没有找到问题所在，试试看你能不能找到。</p><p id="c2fd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果一个人不使用类型类，他们会给自己比他们潜在需要更多的自由。这为错误、不一致和混乱打开了大门。</p><h1 id="8d24" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">往返反模式</h1><p id="172c" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">有时使用一个既有<code class="eh kt ku kv kw b">to</code>又有<code class="eh kt ku kv kw b">from</code>方法的类型类。</p><p id="92d9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">来自<code class="eh kt ku kv kw b">binary</code>包的<code class="eh kt ku kv kw b"><a class="ae jp" href="https://hackage.haskell.org/package/binary-0.8.5.1/docs/Data-Binary.html#g:1" rel="noopener ugc nofollow" target="_blank">Binary</a></code>类型类就是这种情况。在<code class="eh kt ku kv kw b">binary</code> API中没有要求指定两个方向的函数，但是无论如何我必须实现两个方向。</p><p id="9c91" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我正在编写一个向服务器发送数据的客户端，很可能我只会序列化数据类型而不会反序列化它们。我仍然需要一个反序列化的实现，所以我将创建一个伪实现，或者抛出一个错误。</p><p id="5b46" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">无意义的方法实现是维护的隐患。未来的程序员可能会认为实例已经完全实现，当反序列化失败时会感到困惑。</p><h1 id="73d9" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">制定法律</h1><p id="4cad" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">让<code class="eh kt ku kv kw b">Binary</code>的实现同时拥有<code class="eh kt ku kv kw b">to</code>和<code class="eh kt ku kv kw b">from</code>的理由可能是它允许一个人要求法律<code class="eh kt ku kv kw b">decode . encode = id</code>，而<code class="eh kt ku kv kw b">Binary</code>将法律<code class="eh kt ku kv kw b">decode . encode = id</code>记录为一个需求。</p><p id="f960" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">法律作为一种规范是有用的。它对等式推理也很有用，这意味着我可以用<code class="eh kt ku kv kw b">id</code>代替<code class="eh kt ku kv kw b">decode . encode</code>。这是一个非常有用的优化…如果有人曾经遇到过<code class="eh kt ku kv kw b">decode . encode</code>的实际使用。**</p><p id="73b0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">只是我不认为这在实践中会发生。编码和解码是完全不同的代码路径的一部分。</p><h1 id="661c" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">为什么不好</h1><p id="a1c9" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">实际上，你有一个类型类，它有时对方法有无意义的实现，有一个没有利用两个方向的API，有一个对等式推理不是特别有用的法则。</p><p id="ff21" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从这个角度来看，我认为往返类型类在很多时候是一种反模式。不是给程序提供更多的推理能力，而是因为被滥用而提供的更少。他们试图鼓励一种并不总是适用的最佳实践。它们不适合它们用来解决的问题。</p><p id="cc57" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们的类型应该从<code class="eh kt ku kv kw b">to</code>和<code class="eh kt ku kv kw b">from</code>方向往返，我们应该做与我们的法律相同的事情:记录它并测试它。***</p><p id="f3bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在某些情况下，在一个类型类中同时拥有<code class="eh kt ku kv kw b">to</code>和<code class="eh kt ku kv kw b">from</code>是有意义的，但是缺乏令人信服的理由(比如一个共享的关联类型，或者一个API函数需要一个类型的两个方向)，将它们包含在一起是错误的。</p><h1 id="6080" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">非法商品</h1><p id="bbbd" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">对于类型和转换函数之间存在单一映射的情况，可以使用<code class="eh kt ku kv kw b">To</code>和<code class="eh kt ku kv kw b">From</code>类型类来组成易于推理的函数。避免类型类会导致转换函数接受额外的元素函数(想想前面的<code class="eh kt ku kv kw b">eitherToJSON</code>例子)，或者一些定制的不一致的过程。<code class="eh kt ku kv kw b">To</code>和<code class="eh kt ku kv kw b">From</code>实例隐式地使用唯一且正确的实现。这个过程自动防止一类不正确的实现，并鼓励纯粹通过组合的正确性。</p><p id="d976" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">简而言之，<code class="eh kt ku kv kw b">To</code>和<code class="eh kt ku kv kw b">From</code>类型类是简单而强大的类型类模式，你不应该害怕使用。</p><p id="8918" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">*对于<code class="eh kt ku kv kw b">aeson</code> smarties，我避免使用<code class="eh kt ku kv kw b">.=</code>方法，因为大多数<code class="eh kt ku kv kw b">To</code>类没有类似的东西，这使得一般模式更加明显。</p><p id="fca0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">**等式推理不仅可用于重写表达式以简化它们，还可用于扩展表达式和导出函数。然而，除了Conal，我没有见过Haskellers这样做。</p><ul class=""><li id="5f04" class="lk ll hu it b iu iv iy iz jc lm jg ln jk lo jo lp lq lr ls dt translated">** Cale Gibbard除了帮助我完善我的想法之外，还指出了在对一个<code class="eh kt ku kv kw b">Just Nothing</code>进行编码和解码时，<code class="eh kt ku kv kw b">Maybe</code>的<code class="eh kt ku kv kw b">ToJSON</code>和<code class="eh kt ku kv kw b">FromJSON</code>实例不会往返。我认为<code class="eh kt ku kv kw b">postgresql-simple</code>的<code class="eh kt ku kv kw b">ToField</code>实例对于<code class="eh kt ku kv kw b">Maybe</code>来说也是如此。理想情况下，应该更清楚地记录这一点，因为Haskeller倾向于假设这些实例是往返的。</li></ul><blockquote class="lt lu lv"><p id="9b5f" class="ir is lw it b iu iv iw ix iy iz ja jb lx jd je jf ly jh ji jj lz jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是这个大家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">正在接受投稿</a>，并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is lw it b iu iv iw ix iy iz ja jb lx jd je jf ly jh ji jj lz jl jm jn jo hn dt translated">要了解更多信息，<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">请阅读我们的“关于”页面</a> , <a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">喜欢/在脸书给我们发消息</a>，或者简单地，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank">发推文/DM @HackerNoon。</a></p><p id="708a" class="ir is lw it b iu iv iw ix iy iz ja jb lx jd je jf ly jh ji jj lz jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kx ky kz la fq ma"><div class="bz el l di"><div class="mb mc l"/></div></figure></div></div>    
</body>
</html>