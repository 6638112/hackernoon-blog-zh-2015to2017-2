<html>
<head>
<title>Partially-applied (or curried) functions could obfuscate the JavaScript stack trace</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">部分应用的(或简化的)函数可能会混淆JavaScript堆栈跟踪</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/partially-applied-curried-functions-could-obfuscate-the-javascript-stack-trace-84d66bd8032e?source=collection_archive---------4-----------------------#2017-10-22">https://medium.com/hackernoon/partially-applied-curried-functions-could-obfuscate-the-javascript-stack-trace-84d66bd8032e?source=collection_archive---------4-----------------------#2017-10-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="fdad" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">在用JavaScript编写函数代码时，这是一个经常被忽视的权衡。</h2></div><p id="c19a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在学习JavaScript的函数式编程时，尽可能多地以<strong class="jl hv">无指针风格</strong>编写代码是非常有诱惑力的。</p><h1 id="0c10" class="kf kg hu bd kh ki kj kk kl km kn ko kp ja kq jb kr jd ks je kt jg ku jh kv kw dt translated">什么是无点风格？</h1><p id="f94d" class="pw-post-body-paragraph jj jk hu jl b jm kx iv jo jp ky iy jr js kz ju jv jw la jy jz ka lb kc kd ke hn dt translated">用pointfree-style编写函数意味着您编写一个函数而不提及输入参数。</p><p id="42c5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">考虑这个函数，它接受一个表示人的对象，并返回全名:</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="8542" class="ll kg hu lh b fv lm ln l lo lp"><strong class="lh hv">function</strong> fullName (<strong class="lh hv"><em class="lq">personObject</em></strong>) {<br/>  <strong class="lh hv">return</strong> [<br/>    <strong class="lh hv"><em class="lq">personObject</em></strong>.firstName,<br/>    <strong class="lh hv"><em class="lq">personObject</em></strong>.middleName,<br/>    <strong class="lh hv"><em class="lq">personObject</em></strong>.lastName<br/>  ]<br/>    .filter(<strong class="lh hv"><em class="lq">element</em></strong> =&gt; <strong class="lh hv"><em class="lq">element</em></strong>)<br/>    .join(' ')<br/>}</span><span id="082a" class="ll kg hu lh b fv lr ln l lo lp"><strong class="lh hv">const</strong> me = {<br/>  firstName: 'Thai',<br/>  lastName: 'P'<br/>}</span><span id="dd8f" class="ll kg hu lh b fv lr ln l lo lp">fullName(me)<br/>  <strong class="lh hv">// =&gt; 'Thai P'</strong></span></pre><p id="78a2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">注意名字，<code class="eh ls lt lu lh b"><strong class="jl hv"><em class="lq">personObject</em></strong></code>和<code class="eh ls lt lu lh b"><strong class="jl hv"><em class="lq">element</em></strong></code>。我们需要给我们的输入变量命名，这样我们就可以处理它们来得到一个结果。</p><p id="65a6" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是我们真的必须这么做吗？如果我们可以通过拼接更小的函数来创建这个函数呢？例如，<a class="ae lv" href="http://ramdajs.com/docs/" rel="noopener ugc nofollow" target="_blank"> Ramda </a>包含了一系列的实用函数来帮助我们做到这一点:</p><p id="2bb2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh ls lt lu lh b"><strong class="jl hv">R.props</strong></code>将一组属性名转换成一个函数，该函数接受一个对象并返回一组值:</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="ab21" class="ll kg hu lh b fv lm ln l lo lp"><strong class="lh hv">const</strong> nameComponents = R.props([<br/>  'firstName',<br/>  'middleName',<br/>  'lastName'<br/>])</span><span id="01d2" class="ll kg hu lh b fv lr ln l lo lp">nameComponents(me)<br/>  <strong class="lh hv">// =&gt; [ 'Thai', undefined, 'P' ]</strong></span></pre><p id="bce1" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh ls lt lu lh b"><strong class="jl hv">R.filter</strong></code>接受一个谓词并生成一个函数，该函数可以使用该谓词过滤数组。<code class="eh ls lt lu lh b"><strong class="jl hv">R.identity</strong></code>相当于<code class="eh ls lt lu lh b">element =&gt; element</code>。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="92f7" class="ll kg hu lh b fv lm ln l lo lp"><strong class="lh hv">const</strong> rejectEmpty = R.filter(R.identity)</span><span id="a680" class="ll kg hu lh b fv lr ln l lo lp">rejectEmpty([ 'Thai', undefined, 'P' ])<br/>  <strong class="lh hv">// =&gt; [ 'Thai', 'P' ]</strong></span></pre><p id="07f0" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh ls lt lu lh b"><strong class="jl hv">R.join</strong></code>接受一个分隔符字符串，并生成一个函数，将一个数组连接成一个中间带有分隔符的字符串。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="0ec8" class="ll kg hu lh b fv lm ln l lo lp"><strong class="lh hv">const</strong> unwords = R.join(' ')</span><span id="db66" class="ll kg hu lh b fv lr ln l lo lp">unwords([ 'Thai', 'P' ])<br/>  <strong class="lh hv">// =&gt; 'Thai P'</strong></span></pre><p id="d832" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，我们的<code class="eh ls lt lu lh b"><strong class="jl hv">fullName</strong></code>函数可以写成由这三个更小的函数组成的管道:</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="86d2" class="ll kg hu lh b fv lm ln l lo lp"><strong class="lh hv">const</strong> fullName = R.pipe(<br/>  nameComponents,<br/>  rejectEmpty,<br/>  unwords<br/>)</span></pre><p id="0f0b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们将它们串联起来，这样当我们阅读<code class="eh ls lt lu lh b"><strong class="jl hv">fullName</strong></code>的定义时，我们就能确切地知道将要发生什么:</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="79fc" class="ll kg hu lh b fv lm ln l lo lp"><strong class="lh hv">const</strong> fullName = R.pipe(<br/>  R.props([ 'firstName', 'middleName', 'lastName' ]),<br/>  R.filter(R.identity),<br/>  R.join(' ')<br/>)</span><span id="40bc" class="ll kg hu lh b fv lr ln l lo lp">fullName(me)<br/>  <strong class="lh hv">// =&gt; 'Thai P'</strong></span></pre><p id="1c80" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如你所见，现在我们不再需要编造<code class="eh ls lt lu lh b"><strong class="jl hv"><em class="lq">personObject</em></strong></code>和<code class="eh ls lt lu lh b"><strong class="jl hv"><em class="lq">element</em></strong></code>这样的名字。给事物命名是一个很难的计算机科学问题。以这种方式创建函数有助于减少命名事物的需要！</p><blockquote class="lw lx ly"><p id="e527" class="jj jk lq jl b jm jn iv jo jp jq iy jr lz jt ju jv ma jx jy jz mb kb kc kd ke hn dt translated"><strong class="jl hv">注:</strong>我只是以<code class="eh ls lt lu lh b">ramda</code>为例。也可以用<code class="eh ls lt lu lh b">lodash/fp</code>、<code class="eh ls lt lu lh b">sanctuary</code>，或者自己写这些函数。事情是你不自己写函数，而是你组合(重用)更小的函数来创建更大的函数。</p></blockquote><p id="fbbf" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当你部分应用函数时，你是在做无点风格:</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="d863" class="ll kg hu lh b fv lm ln l lo lp"><strong class="lh hv">const</strong> multiply = (a, b) =&gt; a * b<br/><strong class="lh hv">const double = multiply.bind(null, 2)</strong></span></pre><p id="e486" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">或者当你调用一个curried函数时:</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="2fbf" class="ll kg hu lh b fv lm ln l lo lp"><strong class="lh hv">const</strong> multiply = (a) =&gt; (b) =&gt; a * b<br/><strong class="lh hv">const double = multiply(2)</strong></span></pre><p id="066a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不管怎样，你最终得到的是一个由另一个函数生成的函数。</p></div><div class="ab cl mc md hc me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hn ho hp hq hr"><h1 id="4371" class="kf kg hu bd kh ki mj kk kl km mk ko kp ja ml jb kr jd mm je kt jg mn jh kv kw dt translated">但是我们应该一直使用它吗？</h1><p id="e732" class="pw-post-body-paragraph jj jk hu jl b jm kx iv jo jp ky iy jr js kz ju jv jw la jy jz ka lb kc kd ke hn dt translated">简而言之:不总是这样，因为这可能会混淆JavaScript堆栈跟踪。请继续阅读，了解更多解释。</p></div><div class="ab cl mc md hc me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hn ho hp hq hr"><h2 id="4a15" class="ll kg hu bd kh mo mp mq kl mr ms mt kp js mu mv kr jw mw mx kt ka my mz kv na dt translated">一个例子…</h2><p id="c110" class="pw-post-body-paragraph jj jk hu jl b jm kx iv jo jp ky iy jr js kz ju jv jw la jy jz ka lb kc kd ke hn dt translated">假设我们有一系列博客评论:</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="4a0b" class="ll kg hu lh b fv lm ln l lo lp"><strong class="lh hv">let</strong> comments = [<br/>  {<br/>    author: { firstName: 'Thai', lastName: 'P' },<br/>    text: 'I like functional programming!'<br/>  },<br/>  {<br/>    author: {<br/>      firstName: 'A',<br/>      middleName: 'random',<br/>      lastName: 'commenter'<br/>    },<br/>    text: 'Why?'<br/>  },<br/>  {<br/>    author: { firstName: 'Thai', lastName: 'P' },<br/>    text: 'Where should we begin?'<br/>  }<br/>]</span></pre><p id="8d99" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，我想获得一个评论者的列表，按字母顺序排序。</p><p id="d135" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我可以想出这样的东西:</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="463f" class="ll kg hu lh b fv lm ln l lo lp"><strong class="lh hv">function</strong> fullName (<em class="lq">personObject</em>) {<br/>  <strong class="lh hv">return</strong> [<br/>    <em class="lq">personObject</em>.firstName,<br/>    <em class="lq">personObject</em>.middleName,<br/>    <em class="lq">personObject</em>.lastName<br/>  ]<br/>    .filter(<em class="lq">element</em> =&gt; <em class="lq">element</em>)<br/>    .join(' ')<br/>}</span><span id="9ac4" class="ll kg hu lh b fv lr ln l lo lp"><strong class="lh hv">function</strong> commenters (<em class="lq">comments</em>) {<br/>  <strong class="lh hv">const</strong> <em class="lq">nameList</em> = <em class="lq">comments</em><br/>    .map(<em class="lq">comment</em> =&gt; fullName(<em class="lq">comment</em>.author))<br/>  <strong class="lh hv">return</strong> Array.from(new Set(<em class="lq">nameList</em>)).sort()<br/>}</span><span id="7f4c" class="ll kg hu lh b fv lr ln l lo lp">commenters(comments)<br/><strong class="lh hv">  // =&gt; [ 'A random commenter', 'Thai P' ]</strong></span></pre><p id="2ac4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">根据我们对pointfree-style的了解，我们可以将上面的内容重构为如下内容:</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="5d3a" class="ll kg hu lh b fv lm ln l lo lp"><strong class="lh hv">const</strong> fullName = R.pipe(<br/>  R.props([ 'firstName', 'middleName', 'lastName' ]),<br/>  R.filter(R.identity),<br/>  R.join(' ')<br/>)</span><span id="9a9f" class="ll kg hu lh b fv lr ln l lo lp"><strong class="lh hv">const</strong> commenters = R.pipe(<br/>  R.map(R.pipe(R.prop('author'), fullName)),<br/>  R.uniq,<br/>  R.sortBy(R.identity)<br/>)</span></pre><p id="76d5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这要简洁和声明性得多！</p></div><div class="ab cl mc md hc me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hn ho hp hq hr"><h2 id="b963" class="ll kg hu bd kh mo mp mq kl mr ms mt kp js mu mv kr jw mw mx kt ka my mz kv na dt translated">然后意想不到的事情发生了</h2><p id="959a" class="pw-post-body-paragraph jj jk hu jl b jm kx iv jo jp ky iy jr js kz ju jv jw la jy jz ka lb kc kd ke hn dt translated">后来评论系统允许人们匿名评论。这意味着注释的<code class="eh ls lt lu lh b">author</code>现在可以是<code class="eh ls lt lu lh b"><strong class="jl hv">null</strong></code>。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="4e15" class="ll kg hu lh b fv lm ln l lo lp">comments = [ ...comments, {<br/>  author: <strong class="lh hv">null</strong>,<br/>  text: 'How about referential transparency?'<br/>} ]</span></pre><p id="ade8" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">由于我们无法阅读<code class="eh ls lt lu lh b">comment.author.firstName</code>，应用程序崩溃了。</p><p id="2034" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在让我们比较两个版本之间的堆栈跟踪…</p></div><div class="ab cl mc md hc me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hn ho hp hq hr"><h2 id="c553" class="ll kg hu bd kh mo mp mq kl mr ms mt kp js mu mv kr jw mw mx kt ka my mz kv na dt translated">版本1(非无点数)</h2><figure class="lc ld le lf fq nc fe ff paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="fe ff nb"><img src="../Images/358bdb66c7ddcd2a422d65f66e762c3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y_hN64imSjGx2Uw2hRWIDw.png"/></div></div><figcaption class="nj nk fg fe ff nl nm bd b be z ek">This file is where the error was thrown.</figcaption></figure><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="cabb" class="ll kg hu lh b fv lm ln l lo lp"><strong class="lh hv">Uncaught TypeError: Cannot read property 'firstName' of null</strong><br/>    at fullName (app1.js:4)<br/>    at comments.map.comment (app1.js:15)<br/>    at Array.map (&lt;anonymous&gt;)<br/>    at commenters (app1.js:15)<br/>    at index2.html:35</span></pre><p id="858d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这个版本中，上面的堆栈跟踪显示了错误发生的确切位置:在从传递给<code class="eh ls lt lu lh b">comments.map</code>的<code class="eh ls lt lu lh b">commenters</code>映射函数调用的<code class="eh ls lt lu lh b">fullName</code>函数中。</p></div><div class="ab cl mc md hc me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hn ho hp hq hr"><h2 id="ca83" class="ll kg hu bd kh mo mp mq kl mr ms mt kp js mu mv kr jw mw mx kt ka my mz kv na dt translated">版本2(无点数)</h2><figure class="lc ld le lf fq nc fe ff paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="fe ff nb"><img src="../Images/311905369b3596956fb058e09e11b78a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z_0hwnTB7mr9Me7HfwoyXg.png"/></div></div><figcaption class="nj nk fg fe ff nl nm bd b be z ek">No red squiggly lines here? But my app’s code lives here!</figcaption></figure><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="60a0" class="ll kg hu lh b fv lm ln l lo lp"><strong class="lh hv">Uncaught TypeError: Cannot read property 'firstName' of null</strong><br/>    at props (ramda.js:7314)<br/>    at ramda.js:138<br/>    at f1 (ramda.js:31)<br/>    at ramda.js:2061<br/>    at ramda.js:2061<br/>    at ramda.js:205<br/>    at ramda.js:2061<br/>    at ramda.js:205<br/>    at _map (ramda.js:572)<br/>    at map (ramda.js:848)<br/>    at ramda.js:470<br/>    at ramda.js:138<br/>    at f1 (ramda.js:31)<br/>    at ramda.js:2061<br/>    at ramda.js:2061<br/>    at ramda.js:205<br/>    at index2.html:35</span></pre><p id="b4ab" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这个版本里，我们看到的都是拉姆达。</p><p id="a75a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">我们的应用代码</strong> (app2.js) <strong class="jl hv">从来没有在堆栈跟踪中提到过。</strong>事实上，我们从未在那个文件中创建任何函数。我们只是将Ramda函数组合在一起，也许是以一种错误的方式…</p><p id="ced1" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这个例子中，我们只使用了一次<code class="eh ls lt lu lh b">R.props</code>,所以我们知道去哪里找。但是如果应用程序更大并且在很多地方使用<code class="eh ls lt lu lh b">R.props</code>会怎么样呢？</p><p id="b280" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">祝你想明白的时候开心！</p><blockquote class="lw lx ly"><p id="7b61" class="jj jk lq jl b jm jn iv jo jp jq iy jr lz jt ju jv ma jx jy jz mb kb kc kd ke hn dt translated"><strong class="jl hv">注意:</strong>还是那句话，这不是Ramda(或者其他FP库)的问题。我们只是用它来生成函数，使我们的代码更具声明性和无指针性，所以Ramda很酷。不酷的是编写无指针代码而不考虑它对堆栈跟踪的影响。</p></blockquote></div><div class="ab cl mc md hc me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hn ho hp hq hr"><h2 id="2ebc" class="ll kg hu bd kh mo mp mq kl mr ms mt kp js mu mv kr jw mw mx kt ka my mz kv na dt translated"><code class="eh ls lt lu lh b">trace</code>功能</h2><p id="338d" class="pw-post-body-paragraph jj jk hu jl b jm kx iv jo jp ky iy jr js kz ju jv jw la jy jz ka lb kc kd ke hn dt translated">当提出对调试的担忧时，函数式编程的倡导者<a class="ae lv" rel="noopener" href="/javascript-scene/composing-software-an-introduction-27b72500d6ea#5312">会</a> <a class="ae lv" href="https://drboolean.gitbooks.io/mostly-adequate-guide/content/ch5.html#debugging" rel="noopener ugc nofollow" target="_blank">建议</a> <a class="ae lv" href="https://stackoverflow.com/questions/40289989/point-free-debugging" rel="noopener ugc nofollow" target="_blank">使用<code class="eh ls lt lu lh b">trace()</code>函数来处理</a>这个问题:</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="0bab" class="ll kg hu lh b fv lm ln l lo lp"><strong class="lh hv">const</strong> trace = text =&gt; (<br/>  value =&gt; (console.log(text, value), value)<br/>)</span></pre><p id="2fd5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这使我们能够看到流经管道的价值:</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="0681" class="ll kg hu lh b fv lm ln l lo lp"><strong class="lh hv">const</strong> pipeline = R.pipe(<br/>  trace('input'),<br/>  f,<br/>  trace('after f'),<br/>  g,<br/>  trace('after g (output)')<br/>)</span></pre><p id="5032" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，让我们继续将这些<code class="eh ls lt lu lh b">trace</code>呼叫放入我们的应用程序中吧！</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="ff31" class="ll kg hu lh b fv lm ln l lo lp"><strong class="lh hv">const</strong> fullName = R.pipe(<br/>  <strong class="lh hv">trace('fullName - input')</strong>,<br/>  R.props([ 'firstName', 'middleName', 'lastName' ]),<br/>  <strong class="lh hv">trace('fullName - after getting components')</strong>,<br/>  R.filter(R.identity),<br/>  <strong class="lh hv">trace('fullName - after filtering')</strong>,<br/>  R.join(' '),<br/>  <strong class="lh hv">trace('fullName - output')</strong><br/>)</span><span id="ea76" class="ll kg hu lh b fv lr ln l lo lp"><strong class="lh hv">const</strong> commenters = R.pipe(<br/>  <strong class="lh hv">trace('commenters - input')</strong>,<br/>  R.map(R.pipe(<br/>    <strong class="lh hv">trace('commenters - item - input')</strong>,<br/>    R.prop('author'),<br/>    <strong class="lh hv">trace('commenters - item - before fullName')</strong>,<br/>    fullName,<br/>    <strong class="lh hv">trace('commenters - item - after fullName')</strong><br/>  )),<br/>  <strong class="lh hv">trace('commenters - raw list of authors')</strong>,<br/>  R.uniq,<br/>  <strong class="lh hv">trace('commenters - after unique')</strong>,<br/>  R.sortBy(R.identity),<br/>  <strong class="lh hv">trace('commenters - after sort (output)')</strong><br/>)</span></pre><p id="8b1e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，这使我们能够更容易地看到错误的原因:</p><figure class="lc ld le lf fq nc fe ff paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="fe ff nn"><img src="../Images/df5c8325f583d8deab61cd71aac22b4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LbbcSYYsdRlQlt3l3331sQ.png"/></div></div><figcaption class="nj nk fg fe ff nl nm bd b be z ek">Ok, so in <code class="eh ls lt lu lh b"><strong class="bd no"><em class="np">commenters</em></strong></code> we tried to send <strong class="bd no">null</strong> into <strong class="bd no">fullName</strong></figcaption></figure><p id="69b5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">虽然这种调试技术在开发过程中有效，但对于运行在产品上的应用程序来说并不实用，比如在客户的浏览器上。你会在一个生产应用程序中留下很多这样的跟踪代码吗？</p><p id="2a50" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">生产中的意外错误通常发生在客户的浏览器上</strong>(否则，我们的测试会发现它们)，所以现在，我们剩下的只是一个带有堆栈跟踪的错误报告。我们不能只是告诉我们的客户编辑我们的应用程序的源代码，并加入<code class="eh ls lt lu lh b">trace()</code>调用！</p><p id="ecf4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当出现问题时，错误报告应该包含足够的信息供开发人员修复。如果误差不能确定地再现，这一点尤其重要。</p><p id="bc51" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当然，如果我们有更好的涵盖所有边缘情况的测试套件，这个问题本来可以更好地避免。但是意外的事情还是发生了。能够轻松处理生产中的意外错误是不容忽视的。</p><p id="4677" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当我从许多渠道学习函数式编程时，每个人都惊叹于如何使用curried函数来使函数像乐高积木一样组合在一起。</p><p id="fe27" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">他们说<code class="eh ls lt lu lh b"><strong class="jl hv">const</strong> g = (x) =&gt; f(x)</code>只相当于<code class="eh ls lt lu lh b"><strong class="jl hv">const</strong> g = f</code>。但是没有人提到过，在实践中，这是如何消除对跟踪错误源至关重要的堆栈帧的。</p></div><div class="ab cl mc md hc me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hn ho hp hq hr"><h1 id="67cd" class="kf kg hu bd kh ki mj kk kl km mk ko kp ja ml jb kr jd mm je kt jg mn jh kv kw dt translated">那么我们能做什么呢？</h1><p id="3a50" class="pw-post-body-paragraph jj jk hu jl b jm kx iv jo jp ky iy jr js kz ju jv jw la jy jz ka lb kc kd ke hn dt translated">如何让我们的功能代码更容易调试？如何才能让我们的堆栈跟踪更有意义？</p></div><div class="ab cl mc md hc me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hn ho hp hq hr"><h2 id="4a5e" class="ll kg hu bd kh mo mp mq kl mr ms mt kp js mu mv kr jw mw mx kt ka my mz kv na dt translated">自己创建一个函数来建立一个堆栈框架</h2><p id="788d" class="pw-post-body-paragraph jj jk hu jl b jm kx iv jo jp ky iy jr js kz ju jv jw la jy jz ka lb kc kd ke hn dt translated">我们可以创建非自由点函数，在适当的时候调用自由点函数:</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="8a26" class="ll kg hu lh b fv lm ln l lo lp"><strong class="lh hv">const</strong> fullNamePipeline = R.pipe(<br/>  R.props([ 'firstName', 'middleName', 'lastName' ]),<br/>  R.filter(R.identity),<br/>  R.join(' ')<br/>)</span><span id="9695" class="ll kg hu lh b fv lr ln l lo lp"><strong class="lh hv">function</strong> fullName (personObject) {<br/>  <strong class="lh hv">return</strong> fullNamePipeline(personObject)<br/>}</span><span id="3f7b" class="ll kg hu lh b fv lr ln l lo lp"><strong class="lh hv">const</strong> commentersPipeline = R.pipe(<br/>  R.map(R.pipe(R.prop('author'), fullName)),<br/>  R.uniq,<br/>  R.sortBy(R.identity)<br/>)</span><span id="8756" class="ll kg hu lh b fv lr ln l lo lp"><strong class="lh hv">function</strong> commenters (comments) {<br/>  <strong class="lh hv">return</strong> commentersPipeline(comments)<br/>}</span></pre><p id="ac33" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们的堆栈跟踪更有意义了:</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="e6dc" class="ll kg hu lh b fv lm ln l lo lp">Uncaught TypeError: Cannot read property 'firstName' of null<br/>    at props (ramda.js:7314)<br/>    at ramda.js:138<br/>    at f1 (ramda.js:31)<br/>    at ramda.js:2061<br/>    at ramda.js:2061<br/>    at ramda.js:205<br/>    at <strong class="lh hv">fullName (app2.js:9)</strong><br/>    at ramda.js:2061<br/>    at ramda.js:205<br/>    at _map (ramda.js:572)<br/>    at map (ramda.js:848)<br/>    at ramda.js:470<br/>    at ramda.js:138<br/>    at f1 (ramda.js:31)<br/>    at ramda.js:2061<br/>    at ramda.js:2061<br/>    at ramda.js:205<br/>    <strong class="lh hv">at commenters (app2.js:19)</strong><br/>    at index.html:35</span></pre><p id="f921" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是现在有了更多的代码。</p></div><div class="ab cl mc md hc me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hn ho hp hq hr"><h2 id="e49a" class="ll kg hu bd kh mo mp mq kl mr ms mt kp js mu mv kr jw mw mx kt ka my mz kv na dt translated">动态注入堆栈帧</h2><p id="51c9" class="pw-post-body-paragraph jj jk hu jl b jm kx iv jo jp ky iy jr js kz ju jv jw la jy jz ka lb kc kd ke hn dt translated">我们可以通过使用这个辅助函数来注入一个堆栈帧。它有助于在调用时注入一个人工堆栈帧:</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="4906" class="ll kg hu lh b fv lm ln l lo lp"><strong class="lh hv">// Note: This function only works correctly in Chrome.</strong></span><span id="b033" class="ll kg hu lh b fv lr ln l lo lp"><strong class="lh hv">function </strong>/* yourNameIs */ 名は (名, f) {<br/>  <strong class="lh hv">const</strong> キー = `(╯°□°）╯︵ ${名}`<br/>  <strong class="lh hv">return</strong> {<br/>    [キー] () { <strong class="lh hv">return</strong> f.apply(<strong class="lh hv">this</strong>, arguments) }<br/>  }[キー]<br/>}</span></pre><p id="1740" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">那么我们可以这样使用它:</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="3060" class="ll kg hu lh b fv lm ln l lo lp"><strong class="lh hv">const</strong> fullName = <strong class="lh hv">名は('fullName',</strong> R.pipe(<br/>  R.props([ 'firstName', 'middleName', 'lastName' ]),<br/>  R.filter(R.identity),<br/>  R.join(' ')<br/>)<strong class="lh hv">)</strong></span><span id="7ac4" class="ll kg hu lh b fv lr ln l lo lp"><strong class="lh hv">const</strong> commenters = <strong class="lh hv">名は('commenters',</strong> R.pipe(<br/>  R.map(R.pipe(R.prop('author'), fullName)),<br/>  R.uniq,<br/>  R.sortBy(R.identity)<br/>)<strong class="lh hv">)</strong></span></pre><p id="d3e0" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">堆栈跟踪现在看起来像这样:</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="3f46" class="ll kg hu lh b fv lm ln l lo lp">Uncaught TypeError: Cannot read property 'firstName' of null<br/>    at props (ramda.js:7314)<br/>    at ramda.js:138<br/>    at f1 (ramda.js:31)<br/>    at ramda.js:2061<br/>    at ramda.js:2061<br/>    at ramda.js:205<br/>    at <strong class="lh hv">(╯°□°）╯︵ fullName (util.js:3)</strong><br/>    at ramda.js:2061<br/>    at ramda.js:205<br/>    at _map (ramda.js:572)<br/>    at map (ramda.js:848)<br/>    at ramda.js:470<br/>    at ramda.js:138<br/>    at f1 (ramda.js:31)<br/>    at ramda.js:2061<br/>    at ramda.js:2061<br/>    at ramda.js:205<br/>    at <strong class="lh hv">(╯°□°）╯︵ commenters (util.js:3)</strong><br/>    at index.html:35</span></pre><p id="cd88" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在堆栈跟踪中可以更清楚地看到我们的函数，但是现在我们丢失了关于函数创建位置的信息(app2.js)。</p></div><div class="ab cl mc md hc me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hn ho hp hq hr"><h2 id="40b2" class="ll kg hu bd kh mo mp mq kl mr ms mt kp js mu mv kr jw mw mx kt ka my mz kv na dt translated">记录函数的起源</h2><p id="4c12" class="pw-post-body-paragraph jj jk hu jl b jm kx iv jo jp ky iy jr js kz ju jv jw la jy jz ka lb kc kd ke hn dt">We can improve our <code class="eh ls lt lu lh b">名は</code> function by making it record the call site when we try to name a function:</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="ca6e" class="ll kg hu lh b fv lm ln l lo lp"><strong class="lh hv">// Note: This function only works correctly in Chrome.</strong></span><span id="c436" class="ll kg hu lh b fv lr ln l lo lp"><strong class="lh hv">function</strong> 名は (名, f) {<br/>  <strong class="lh hv">const</strong> atOrigin = (<br/>    String(<strong class="lh hv">new</strong> Error('ヤバい！').stack).split('\n')[2] || ''<br/>  ).trim()<br/>  <strong class="lh hv">const</strong> キー = `(╯°□°）╯︵ ${名} (created ${atOrigin})`<br/>  <strong class="lh hv">return</strong> {<br/>    [キー] () { <strong class="lh hv">return</strong> f.apply(<strong class="lh hv">this</strong>, arguments) }<br/>  }[キー]<br/>}</span></pre><p id="de68" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们的堆栈跟踪看起来像这样:</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="64e1" class="ll kg hu lh b fv lm ln l lo lp">Uncaught TypeError: Cannot read property 'firstName' of null<br/>    at props (ramda.js:7314)<br/>    at ramda.js:138<br/>    at f1 (ramda.js:31)<br/>    at ramda.js:2061<br/>    at ramda.js:2061<br/>    at ramda.js:205<br/>    <strong class="lh hv">at (╯°□°）╯︵ fullName (created at app2.js:2:18)</strong> (util.js:5)<br/>    at ramda.js:2061<br/>    at ramda.js:205<br/>    at _map (ramda.js:572)<br/>    at map (ramda.js:848)<br/>    at ramda.js:470<br/>    at ramda.js:138<br/>    at f1 (ramda.js:31)<br/>    at ramda.js:2061<br/>    at ramda.js:2061<br/>    at ramda.js:205<br/>    <strong class="lh hv">at (╯°□°）╯︵ commenters (created at app2.js:8:20)</strong> (util.js:3)<br/>    at index.html:35</span></pre><p id="184f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这不仅告诉我们函数的名字，还告诉我们它是在哪里创建的。</p></div><div class="ab cl mc md hc me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hn ho hp hq hr"><h2 id="16c3" class="ll kg hu bd kh mo mp mq kl mr ms mt kp js mu mv kr jw mw mx kt ka my mz kv na dt translated">让库为我们注入有意义的堆栈框架</h2><p id="bf47" class="pw-post-body-paragraph jj jk hu jl b jm kx iv jo jp ky iy jr js kz ju jv jw la jy jz ka lb kc kd ke hn dt translated">这只是一个想法…但是如果FP库可以在适当的地方为我们注入辅助堆栈帧，那是不是很棒？发生错误时，堆栈跟踪可能如下所示:</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="45f9" class="ll kg hu lh b fv lm ln l lo lp">Uncaught TypeError: Cannot read property 'firstName' of null<br/>    at props (ramda.js:7314:19)<br/>    at ramda.js:138:46<br/>    <strong class="lh hv">at R.props([firstName,middleName,lastName])</strong> (ramda.js:31:17)<br/>    at ramda.js:2061:27<br/>    at ramda.js:2061:27<br/><strong class="lh hv">    at R.pipe(R.props([firstName,middleName,lastName]),<br/>              R.filter(R.identity),<br/>              R.join(' '))</strong> (ramda.js:204:43)<br/>    at ramda.js:2061:14<br/> <strong class="lh hv">   at R.pipe(R.prop(author),fullName) </strong>(ramda.js:204:43)<br/>    at _map (ramda.js:572:19)<br/>    at map (ramda.js:848:14)<br/>    at ramda.js:470:15<br/>    at ramda.js:138:46<br/><strong class="lh hv">    at R.map(R.pipe(R.prop(author),fullName))</strong> (ramda.js:31:17)<br/>    at ramda.js:2061:27<br/>    at ramda.js:2061:27<br/>    <strong class="lh hv">at</strong> <strong class="lh hv">R.pipe(R.map(R.pipe(R.prop(author),fullName)),<br/>              R.uniq,<br/>              R.sortBy(R.identity))</strong> (ramda.js:204:43)<br/>    at index2.html:43:13</span></pre><p id="8c12" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这将使开发人员更容易调试生产问题。</p></div><div class="ab cl mc md hc me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hn ho hp hq hr"><h2 id="c148" class="ll kg hu bd kh mo mp mq kl mr ms mt kp js mu mv kr jw mw mx kt ka my mz kv na dt translated">使用类型化语言，保证您的函数永远不会收到无效数据</h2><p id="f781" class="pw-post-body-paragraph jj jk hu jl b jm kx iv jo jp ky iy jr js kz ju jv jw la jy jz ka lb kc kd ke hn dt translated">像Haskell和<a class="ae lv" href="http://elm-lang.org/" rel="noopener ugc nofollow" target="_blank"> Elm </a>这样的语言有助于防止类型级别的运行时异常。这意味着你可以编写无点函数，并且确信它<strong class="jl hv"> <em class="lq">永远不会</em> </strong>接收到意想不到的值。</p><p id="7889" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">经常可以看到这些语言中的无指针风格的代码。他们甚至被认为是“良好的纪律”引用<a class="ae lv" href="https://wiki.haskell.org/Pointfree" rel="noopener ugc nofollow" target="_blank"> Haskell wiki </a>:</p><blockquote class="lw lx ly"><p id="91ac" class="jj jk lq jl b jm jn iv jo jp jq iy jr lz jt ju jv ma jx jy jz mb kb kc kd ke hn dt translated">这种风格在通过计算获得高效程序时特别有用，并且通常构成良好的纪律。它帮助作者(和读者)思考如何组合函数(高级)，而不是混洗数据(低级)。</p></blockquote><p id="9438" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">顺便说一句，玩得开心处理<a class="ae lv" href="https://guide.elm-lang.org/interop/json.html" rel="noopener ugc nofollow" target="_blank"> JSON解码器</a>和那些<a class="ae lv" href="https://guide.elm-lang.org/error_handling/maybe.html" rel="noopener ugc nofollow" target="_blank">也许</a> s！当涉及到处理来自外部服务的数据时，这些安全特性会使您的代码变得非常冗长，但是<a class="ae lv" href="https://charukiewi.cz/posts/elm/" rel="noopener ugc nofollow" target="_blank">从长远来看，这是非常值得的</a>。</p><p id="bb23" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">根据我的经验，重构Elm代码比重构JavaScript代码有趣得多，因为编译器在每一步都帮助了我。</p></div><div class="ab cl mc md hc me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hn ho hp hq hr"><h2 id="b438" class="ll kg hu bd kh mo mp mq kl mr ms mt kp js mu mv kr jw mw mx kt ka my mz kv na dt translated">或者只是不要过分使用JavaScript中的无指针风格</h2><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="1959" class="ll kg hu lh b fv lm ln l lo lp"><strong class="lh hv">function</strong> fullName (personObject) {<br/>  <strong class="lh hv">return</strong> [ 'firstName', 'middleName', 'lastName' ]<br/>    .map(key =&gt; personObject[key])<br/>    .filter(R.identity)<br/>    .join(' ')<br/>}<br/><strong class="lh hv">function</strong> commenters (comments) {<br/>  <strong class="lh hv">const</strong> nameList = comments<br/>    .map(comment =&gt; comment.author)<br/>    .map(fullName)<br/>  <strong class="lh hv">return</strong> R.sortBy(R.identity, R.uniq(nameList))<br/>}</span></pre></div><div class="ab cl mc md hc me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hn ho hp hq hr"><h1 id="9c30" class="kf kg hu bd kh ki mj kk kl km mk ko kp ja ml jb kr jd mm je kt jg mn jh kv kw dt translated">结论</h1><p id="b6f5" class="pw-post-body-paragraph jj jk hu jl b jm kx iv jo jp ky iy jr js kz ju jv jw la jy jz ka lb kc kd ke hn dt translated">用pointfree风格编写函数式代码可以让你的代码更简洁，更具声明性。命名的东西少了。但这也是有代价的。你不再免费获得堆栈跟踪清晰度。除非小心处理，否则它会使您的堆栈跟踪变得非常模糊，从而很难跟踪生产应用程序中的错误来源。</p><p id="0bd4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对如何提高函数式JavaScript代码的可调试性有更多的想法吗？请写回应！:)</p></div></div>    
</body>
</html>