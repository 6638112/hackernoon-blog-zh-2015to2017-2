<html>
<head>
<title>RealmList<realmstring> is an anti-pattern!</realmstring></title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RealmList <realmstring>是一个反模式！</realmstring></h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/realmlist-realmstring-is-an-anti-pattern-bfc10efb7ca5?source=collection_archive---------7-----------------------#2017-01-16">https://medium.com/hackernoon/realmlist-realmstring-is-an-anti-pattern-bfc10efb7ca5?source=collection_archive---------7-----------------------#2017-01-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/1e3ddbdb86752771ef44040ff4a32a08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-gSrCrcN1_LVMfV_w_wiIQ.png"/></div></div></figure><p id="ff81" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">编辑:任何来自4.0.0-RC1和更高版本的服务器都支持本地的<code class="eh ka kb kc kd b">RealmList&lt;String&gt;</code>，所以用那个代替。</p><p id="cd43" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt">— — — — — — — — — — — — — — — — — — — —</p><p id="299e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">老实说:我真的不喜欢说“<em class="ke"> X是反模式</em>”的标题。特别是当特定方法的缺陷不明显时，相反的方法也被认为是反模式，等等。</p><p id="cb86" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<code class="eh ka kb kc kd b">RealmList&lt;RealmString&gt;</code>的情况下，你根本无法真正“支持”它。我甚至应该在我的<a class="ae kf" rel="noopener" href="/@Zhuinden/designing-the-schema-of-realm-effectively-and-other-realm-tips-feb76c5b6072#.fxmu0jq9u">领域模式设计文章</a>中提到这一点。当没有更好的解决方案时，使用<code class="eh ka kb kc kd b">RealmList&lt;RealmString&gt;</code>来克服<code class="eh ka kb kc kd b"><a class="ae kf" href="https://github.com/realm/realm-java/issues/575" rel="noopener ugc nofollow" target="_blank">RealmList of primitives is not supported</a></code>(从4.0.0开始不再是一个限制)的想法是作为一个黑客设计的。除了丑陋和对开发者来说不完全短暂之外，它也带来了一些问题。</p><p id="0c2c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">好吧，有一个简单的解决方案，但是至少你不会用它来膨胀你的领域模式:)</p><h1 id="be5b" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">现实主义者的问题<realmstring/></h1><h2 id="9999" class="le kh hu bd ki lf lg lh km li lj lk kq jn ll lm ku jr ln lo ky jv lp lq lc lr dt translated">1.)您需要为它定义一个新的RealmObject</h2><p id="62c1" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">你需要创建一个RealmObject，它并不是一个独立的类，一个不必要的包装器。它还创建了一个链接，这意味着…</p><h2 id="fe86" class="le kh hu bd ki lf lg lh km li lj lk kq jn ll lm ku jr ln lo ky jv lp lq lc lr dt translated">2.)通过链接访问的对象需要手动删除</h2><p id="e5f7" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">基本上，如果你在一个类中使用了<code class="eh ka kb kc kd b">RealmList&lt;RealmString&gt;</code>，那么为了清除绑定到它的<code class="eh ka kb kc kd b">RealmString</code>对象，你必须首先迭代RealmResults，在它们的托管RealmList上调用<code class="eh ka kb kc kd b">deleteAllFromRealm()</code>，并且只有<strong class="je hv">然后</strong>才能真正删除对象。对RealmResults进行迭代会为每个被访问的对象创建一个代理，因此对于大型数据集来说这可能是内存密集型的，即使这些数据应该直接属于RealmObject，而不是通过链接。</p><h2 id="064d" class="le kh hu bd ki lf lg lh km li lj lk kq jn ll lm ku jr ln lo ky jv lp lq lc lr dt translated">3.)链接查询比普通查询慢</h2><p id="cdff" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">简单地说，链接查询比索引字段上的查询花费更多的时间。</p><h2 id="6825" class="le kh hu bd ki lf lg lh km li lj lk kq jn ll lm ku jr ln lo ky jv lp lq lc lr dt translated"><strong class="ak"> 4。)任何对</strong> <code class="eh ka kb kc kd b"><strong class="ak">RealmString</strong></code> <strong class="ak">表的写入都会通知任何其他具有</strong> <code class="eh ka kb kc kd b"><strong class="ak">link to it (pre-3.0)</strong></code>的 <code class="eh ka kb kc kd b"><strong class="ak">RealmObject</strong></code> <strong class="ak"/></h2><p id="10a9" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">(仅适用于Realm 3.0之前)粗粒度更改监听器假设如果修改了<code class="eh ka kb kc kd b">RealmString</code>，您的对象可能已经被修改，这会导致对<code class="eh ka kb kc kd b">RealmChangeListener</code>的不必要调用，而后者通常会调用<code class="eh ka kb kc kd b">adapter.notifyDataSetChanged()</code>。</p><h1 id="a418" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">解决方案:将RealmList <primitive>存储为字符串</primitive></h1><p id="d126" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">是的，问题是人们试图将原语存储为一个<code class="eh ka kb kc kd b">List</code>。不过，这不一定是一个列表。考虑一下——您可以将任何元素列表打包成一个字符串。甚至您的日常JSON解析器也一直在这么做。</p><p id="ab38" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于原始值列表，将列表打包成字符串特别容易。</p><p id="ee36" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从 <code class="eh ka kb kc kd b"><a class="ae kf" href="https://github.com/realm/realm-java/issues/575#issuecomment-173676006" rel="noopener ugc nofollow" target="_blank">RealmList&lt;RealmInteger&gt;, …</a></code> <a class="ae kf" href="https://github.com/realm/realm-java/issues/575#issuecomment-173676006" rel="noopener ugc nofollow" target="_blank">一期</a>看<a class="ae kf" href="https://github.com/realm/realm-java/issues/575#issuecomment-173676006" rel="noopener ugc nofollow" target="_blank">这个主旨:</a></p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="6fcf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它没有为<code class="eh ka kb kc kd b">List&lt;String&gt;</code>创建不必要的包装器，而是用连接分隔符将它映射到一个单独的<code class="eh ka kb kc kd b">String</code>字段中。对于<a class="ae kf" href="https://hackernoon.com/tagged/java" rel="noopener ugc nofollow" target="_blank"> Java </a>，这可以通过Commons-Lang的<code class="eh ka kb kc kd b">StringUtils.join()</code>或流API反向端口来完成。或者用<code class="eh ka kb kc kd b">StringBuilder</code>手动。哪个都行。</p><h1 id="3ec2" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">为什么这个效果很好？</h1><p id="dedc" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">由于<a class="ae kf" href="https://realm.io/news/realm-java-0.88.0/" rel="noopener ugc nofollow" target="_blank"> Realm 0.88.0，你需要将Realm作为一个Gradle插件</a>添加到项目中，对吗？随之而来的是Realm-Transformer，它将所有直接的字段访问转换成代理方法调用。</p><p id="3b78" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这很棒，因为这允许我们手动创建像<code class="eh ka kb kc kd b">total</code>和<code class="eh ka kb kc kd b">this.total = quantity * price;</code>一样的“计算属性”。</p><p id="6800" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是这允许我们创建自定义的getter/setter，即使你给它一个列表，它也设置String字段，或者返回一个列表，即使该字段是一个字符串。</p><p id="059c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">大概是这样的:</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="c129" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们不想将<code class="eh ka kb kc kd b">Commons-Lang</code>添加到项目中，可以使用Spring Framework中的这个方法:</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="ff07" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">或者类似的东西。加入一个字符串应该不会太难。</p><h1 id="9d7d" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">结论</h1><p id="3f11" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">不要创建不必要的链接。吹扫<code class="eh ka kb kc kd b">RealmList&lt;RealmString&gt;</code>。</p><h1 id="2465" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">添加注释(2017年1月17日):</h1><p id="73bd" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">但是如果您仍然需要将元素分离到它们自己的列表中，那么为它创建一个单独的RealmObject，而不是一个<code class="eh ka kb kc kd b">RealmString</code>。这里有一个具体的例子:</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="cb4c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这样，你保留了一个双向链接，你的电话号码可以独立地查询<strong class="je hv">和分类</strong>，允许像<code class="eh ka kb kc kd b">find the telephone numbers that contains “___"</code>这样的查询，然后使用<code class="eh ka kb kc kd b">telephoneNumber.getPerson()</code>来得到它属于谁。</p><div class="lx ly lz ma fq ab cb"><figure class="md iv me mf mg mh mi paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="md iv me mf mg mh mi paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="md iv me mf mg mh mi paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mj mk ml"><p id="f922" class="jc jd ke je b jf jg jh ji jj jk jl jm mm jo jp jq mn js jt ju mo jw jx jy jz hn dt translated"><a class="ae kf" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客们下午的开始。我们是<a class="ae kf" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kf" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae kf" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd ke je b jf jg jh ji jj jk jl jm mm jo jp jq mn js jt ju mo jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kf" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kf" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mp"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="mq mc l"/></div></figure></div></div>    
</body>
</html>