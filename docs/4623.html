<html>
<head>
<title>5 ways we improved our React Native app</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们改进React原生应用的5种方式</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/5-ways-we-improved-our-react-native-app-2704d5098b20?source=collection_archive---------3-----------------------#2017-06-11">https://medium.com/hackernoon/5-ways-we-improved-our-react-native-app-2704d5098b20?source=collection_archive---------3-----------------------#2017-06-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="283b" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">提高性能的真实场景</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/8093795353b8b3e7072b749960f1e51d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TJXMMkeSDUfabi8ZoSGUbQ.jpeg"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><a class="ae jz" href="https://unsplash.com/photos/5DigPgSH27U" rel="noopener ugc nofollow" target="_blank">unsplash</a></figcaption></figure><p id="7c1d" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">在过去的几天里，我有机会专注于改善我们公司开发的React原生应用程序的性能:由于已经在两个市场(iOS/Android)上市，我采取的方法主要是以JS为重点，以便能够通过微软的<a class="ae jz" href="https://github.com/Microsoft/react-native-code-push" rel="noopener ugc nofollow" target="_blank"> Codepush </a>工具部署调整。</p><p id="1a04" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">我必须承认，我对这些改变的有效性感到非常惊讶——这就是为什么我与你们分享它们，希望帮助你们理解提高绩效可以是简单的<strong class="kc hv"/>；正如我在上周之前所想的那样，这不是只有铁杆老兵才能完成的事情。</p></div><div class="ab cl kw kx hc ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hn ho hp hq hr"><h2 id="7aed" class="ld le hu bd lf lg lh li lj lk ll lm ln kj lo lp lq kn lr ls lt kr lu lv lw lx dt translated">起点:需要基准</h2><p id="0e75" class="pw-post-body-paragraph ka kb hu kc b kd ly iv kf kg lz iy ki kj ma kl km kn mb kp kq kr mc kt ku kv hn dt translated">正如任何从事表演工作的人都会告诉你的那样，在开始改善表演之前，你需要给自己配备一些with…🥁来衡量它们🎉</p><p id="ec2b" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">在<code class="eh md me mf mg b">react-native</code>基础项目中，有一个名为<code class="eh md me mf mg b">PerfMonitor</code>的基准测试工具。根据我的理解，这基本上是同一个标准的React Perf工具——你可以在这里阅读更多关于<a class="ae jz" href="https://facebook.github.io/react/docs/perf.html" rel="noopener ugc nofollow" target="_blank">的内容。基本上，它为你提供了一个关于你的应用程序在无用的重新渲染中浪费了多少时间的分析；但是它有一个缺陷，那就是它只能在调试器模式下运行，这是没有优化的。</a></p><p id="16d5" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">无论如何，它仍然是一段非常有价值的代码——我是这样设置它的:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="b237" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">我将这几行代码放在我们的根组件之一的ComponentDidMount中，这个根组件叫做Logged——它基本上“拥有”登录用户的主导航。在这些行未被注释的情况下，在“启动”时，该工具将开始记录发生的一切，并在20秒后(在我看来，这是将一切正确加载到应用程序中的良好“平稳”时间)，它将打印出关于渲染的分析。</p><p id="651a" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">我不能进入我们的应用程序架构的细节，但我认为你应该知道的是，提到的日志组件包含主导航标签栏(由4个标签组成)，第一个主标签包含自己的标签栏导航，也是4个标签(其中一个使用Airbnb的<a class="ae jz" href="https://github.com/airbnb/react-native-maps" rel="noopener ugc nofollow" target="_blank">地图</a>组件)。<br/> <em class="mh">(对了，我们用</em> <a class="ae jz" href="https://github.com/react-community/react-navigation" rel="noopener ugc nofollow" target="_blank"> <em class="mh">反应-导航</em> </a> <em class="mh"> ) </em></p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mk"><img src="../Images/b76d901bdf5de389a0333f2029f2c0b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nae_a4ZZdLydclEgp7-Gmg.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">The actual starting point</figcaption></figure><p id="88b9" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">这是我使用的基线:在应用任何优化之前，这是Perf工具提供的基准。</p><h2 id="3a12" class="ld le hu bd lf lg lh li lj lk ll lm ln kj lo lp lq kn lr ls lt kr lu lv lw lx dt translated">改进1:强制执行无绑定规则</h2><p id="d381" class="pw-post-body-paragraph ka kb hu kc b kd ly iv kf kg lz iy ki kj ma kl km kn mb kp kq kr mc kt ku kv hn dt translated">作为一个已经在v2.x中的应用程序，经过一年多的开发，难怪代码库没有在每个角落都得到完善——谢天谢地，我们使用<a class="ae jz" href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-no-bind.md" rel="noopener ugc nofollow" target="_blank"> Eslint </a>成功地找到并更新了所有不遵守规则的文件。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ml"><img src="../Images/76f364635eb9429487f1bc3ea7e55831.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TI4J1N3pTchCC7_w0_TyXw.png"/></div></div></figure><p id="7597" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">我们在前10名中获得了不错的~ <em class="mh"> 50ms </em>(只有几个例外，比如CellRenderer)。很好，但没什么大问题——所以我继续挖。</p><h2 id="8145" class="ld le hu bd lf lg lh li lj lk ll lm ln kj lo lp lq kn lr ls lt kr lu lv lw lx dt translated">改进2:改变比较器</h2><p id="e8e9" class="pw-post-body-paragraph ka kb hu kc b kd ly iv kf kg lz iy ki kj ma kl km kn mb kp kq kr mc kt ku kv hn dt translated">由于我们的一些组件有大量的项目要显示(<em class="mh">像大多数应用程序</em>)，我们需要以特定的方式对道具的变化做出反应。我们在componentWillReceiveProps中做的一项检查是对列表的数据集进行的，当我们将数组比较从standard ===更改为<a class="ae jz" href="https://lodash.com/docs/4.17.4#isEqual" rel="noopener ugc nofollow" target="_blank"> lodash </a> _时。isEqual()方法，事情是这样的:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mm"><img src="../Images/e56c2a33a7d575b316e6c78ea0266328.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IMbCQq0GIpzSuh581GtgEQ.png"/></div></div></figure><p id="c7bd" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">这是最有效的优化之一:显然lodash方法更适合比较数组——或者也许我只是个菜鸟，除了我之外，每个人都知道它😇</p><h2 id="e72a" class="ld le hu bd lf lg lh li lj lk ll lm ln kj lo lp lq kn lr ls lt kr lu lv lw lx dt translated">改进#3:功能组件FTW</h2><p id="b9fe" class="pw-post-body-paragraph ka kb hu kc b kd ly iv kf kg lz iy ki kj ma kl km kn mb kp kq kr mc kt ku kv hn dt translated">使用我不久前读过的这篇文章作为基线，我们决定重构许多组件，以使它们具有功能性。结果让我大吃一惊:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mn"><img src="../Images/a3eaa901e20a8dab69a8228758af4670.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IklCI6ny58On1kUzLlNVng.png"/></div></div></figure><p id="d2b7" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">另一个巨大的性能改进，通过简单的代码重构！我非常兴奋:我们在最重的组件上浪费的时间从大约750毫秒减少到了不到300毫秒！但是就在我准备🍾…</p><blockquote class="mo"><p id="3ce4" class="mp mq hu bd mr ms mt mu mv mw mx kv ek translated">现实。<strong class="ak">击杀</strong>。回来了。</p></blockquote><p id="4d62" class="pw-post-body-paragraph ka kb hu kc b kd my iv kf kg mz iy ki kj na kl km kn nb kp kq kr nc kt ku kv hn dt translated">任何人都不会感到惊讶，因为应用程序会不断地与后端进行通信，后端提供了需要在整个应用程序中显示的大多数数据。</p><p id="4a4e" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">结果是，在我所有的调整和修复以及对性能改进感到兴奋的过程中…我们的后端并没有完全工作👾</p><p id="7f14" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">因此，就在我准备运行最后一个基准测试时，我的老板通过Slack通知我，他已经修复了后端的一个bug，地图上的大头针终于又出现了。</p><blockquote class="mo"><p id="6a0d" class="mp mq hu bd mr ms mt mu mv mw mx kv ek translated">哦，不…</p></blockquote><p id="a277" class="pw-post-body-paragraph ka kb hu kc b kd my iv kf kg mz iy ki kj na kl km kn nb kp kq kr nc kt ku kv hn dt translated">我运行基准。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nd"><img src="../Images/031f508d6a20db5958b72e48bd5f4962.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Q3Fb7kS8LtqC0LH7JrZGQ.png"/></div></div></figure><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff ne"><img src="../Images/de47c7ca7d347905225db7042ab17a76.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/1*h2efgYEYGGMDSRAdLPinbw.gif"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">My reaction #truefact</figcaption></figure><p id="9a79" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">拥有(再次)满是大头针的地图创造了一个全新层次的浪费ms。</p><blockquote class="nf ng nh"><p id="eba1" class="ka kb mh kc b kd ke iv kf kg kh iy ki ni kk kl km nj ko kp kq nk ks kt ku kv hn dt translated">(小免责声明:不要认为这是对那些创建和维护地图组件的开发人员的咆哮，好吗！？这些巨大的数字肯定是由我缺乏经验造成的)</p></blockquote><p id="706a" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">所以，基本上，我又回到了起点…但我现在不能停下来，我离表演天堂是如此之近！</p><h2 id="820a" class="ld le hu bd lf lg lh li lj lk ll lm ln kj lo lp lq kn lr ls lt kr lu lv lw lx dt translated">改进4:让我们关注TabMap</h2><p id="0761" class="pw-post-body-paragraph ka kb hu kc b kd ly iv kf kg lz iy ki kj ma kl km kn mb kp kq kr mc kt ku kv hn dt translated">多亏了这个工具，很容易发现包含地图组件的选项卡根本没有优化。因此，我集中了我的智慧，为tabMap组件添加了一些小的修正，并把一些部分转移到了功能上:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nl"><img src="../Images/f4b3dcf6b1fead9608cb2a2740873698.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BB6NLoW-mIBmS469ZWCwbw.png"/></div></div></figure><p id="1a8e" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">我们又有了一些改进。但是还不够…是最后一次尝试的时候了💪</p><h2 id="9426" class="ld le hu bd lf lg lh li lj lk ll lm ln kj lo lp lq kn lr ls lt kr lu lv lw lx dt translated">改进5:修改TabMap的逻辑</h2><p id="be9a" class="pw-post-body-paragraph ka kb hu kc b kd ly iv kf kg lz iy ki kj ma kl km kn mb kp kq kr mc kt ku kv hn dt translated">通过改变tabMap的<code class="eh md me mf mg b">render()</code>方法中的逻辑，我设法只在组件实际“显示”时才加载引脚&amp;标记——代码类似于:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="2787" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">考虑到所有这些测量都是在一个<em class="mh"> 20000 ms </em>的时间跨度内进行的，这最后的改进设法让我们“回到了良好的表现”:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nm"><img src="../Images/c48e33e62f02c19eb0c53da97b32b076.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mu2xFeMbDbvOQLvpmNzSPw.png"/></div></div></figure></div><div class="ab cl kw kx hc ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hn ho hp hq hr"><p id="14b7" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">我最终对这些改进感到满意:一旦我们将它们代码化，⚛️应用程序发布版本的差异就可以感觉到了。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff nn"><img src="../Images/0b380ffdb725c2a6cf0e6b1b8a065801.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/1*Y-xQGTXOMwpLR4KwMAT4Rg.gif"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">this MAY have been my boss reaction</figcaption></figure><p id="b7b7" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">当然还可以做得更多:我不是JS专家，当然<a class="no np gr" href="https://medium.com/u/83a4f96844d0?source=post_page-----2704d5098b20--------------------------------" rel="noopener" target="_blank"> Tal Kol </a>能够编写出更多的性能代码(<em class="mh">如果你从未听说过他或读过他关于React Native performances的文章，请访问</em> <strong class="kc hv"> <em class="mh">现在</em></strong>)——但是，嘿，仍然得到了一些可靠的结果😊</p></div><div class="ab cl kw kx hc ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hn ho hp hq hr"><p id="e31c" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><em class="mh">我真诚地希望这篇文章可以帮助你开发自己的React原生应用，并且我上面写的没有重大错误。<br/>从这个意义上来说，我真的很期待你的反馈和/或建议:请随意发表评论或推文</em> <a class="ae jz" href="https://twitter.com/Kelset" rel="noopener ugc nofollow" target="_blank"> <em class="mh"> me </em> </a> <em class="mh">我很乐意与你们交谈</em>🤓</p><p id="383d" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><em class="mh">和一如既往的</em></p><p id="9e97" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv">快乐编码！🤖</strong></p><div class="jk jl jm jn fq ab cb"><figure class="nq jo nr ns nt nu nv paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nq jo nr ns nt nu nv paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nq jo nr ns nt nu nv paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="nf ng nh"><p id="f922" class="ka kb mh kc b kd ke iv kf kg kh iy ki ni kk kl km nj ko kp kq nk ks kt ku kv hn dt translated"><a class="ae jz" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是阿美族家庭的一员。我们现在<a class="ae jz" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jz" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ka kb mh kc b kd ke iv kf kg kh iy ki ni kk kl km nj ko kp kq nk ks kt ku kv hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jz" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jz" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nw"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>