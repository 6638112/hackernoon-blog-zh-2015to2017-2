<html>
<head>
<title>React Native + SignalR + .NET Core with dotNetify</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Native + SignalR +。带dotNetify的网络核心</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/react-native-signalr-net-core-with-dotnetify-f919083170d4?source=collection_archive---------8-----------------------#2017-09-27">https://medium.com/hackernoon/react-native-signalr-net-core-with-dotnetify-f919083170d4?source=collection_archive---------8-----------------------#2017-09-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/74774556c80bda8869d2dbd82d83a2d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*BQUmQot84um71PLZ30-XLg.png"/></div></figure><p id="a126" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在跨平台C#/上构建基于React的实时应用程序的简单、轻量级且强大的方法。网络后端。</p><p id="1661" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><a class="ae jx" href="http://dotnetify.net" rel="noopener ugc nofollow" target="_blank"> DotNetify </a>是一个免费的开源项目，旨在促进实时推送模型对<a class="ae jx" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank">使用的</a>网络应用做出反应。NET作为他们的后端。它超级容易使用，可以在WebSockets上运行，可以在浏览器和电子桌面应用程序上工作，现在它支持React原生移动应用程序！</p><h1 id="4778" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">活性MVVM</h1><p id="c1dd" class="pw-post-body-paragraph iy iz hu ja b jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv hn dt translated">在dotNetify的<a class="ae jx" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>模型中，容器组件本身并不显式地获取数据，而是被动的。它们只将动作分派给后端，后端通过将与动作相关联的数据推回该组件(或者可以推回其他组件)来异步响应。</p><p id="97ae" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">你会问，为什么这样更好？像大多数其他事情一样，它取决于用例。这种模型适用于复杂的应用程序，这些应用程序需要进行大量的数据编排、过滤、转换，可能还需要与其他(微)服务进行通信。与其在前端有这种逻辑，不如让后端来做这个。这正是它的用途。</p><p id="d8e4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">容器组件与MVVM风格的后端视图模型配对。视图模型实例遵循组件的生命周期，负责以组件所需的精确形式提供数据，并通过WebSockets推送数据，作为对组件自身操作或其他一些外部事件的反应(例如来自物联网传感器的数据更新)。</p><h1 id="5365" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">React Native +。网络核心演示</h1><p id="9897" class="pw-post-body-paragraph iy iz hu ja b jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv hn dt translated">React Native是构建原生移动应用的一种很好的方式，尤其是使用create-react-native-app (CRNA)工具，即使是新手移动开发人员也可以非常快速地工作。无论是在模拟器中还是在真实设备中，在保存时自动更新代码并立即看到更改的能力极大地改善了开发人员的体验。</p><p id="fdab" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我提供了一个简单的用CRNA引导的g <a class="ae jx" href="https://github.com/dsuryd/dotnetify-react-native-demo" rel="noopener ugc nofollow" target="_blank"> ithub演示程序</a>来展示你可以用dotNetify做的一些事情。您可以在本地运行服务器代码(用。NET Core，所以可以在任何地方运行:Windows、Linux、macOS)，或者使用托管在<a class="ae jx" href="http://dotnetify.net" rel="noopener ugc nofollow" target="_blank"> dotNetify网站</a>上的那个。</p><figure class="lc ld le lf fq iv fe ff paragraph-image"><div class="fe ff lb"><img src="../Images/43e352b5b7ff1ffadcb318c1e185f8e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/1*GpUdihDxgJ7DAYNpLPlNgg.gif"/></div></figure><h2 id="4718" class="lg jz hu bd ka lh li lj ke lk ll lm ki jj ln lo km jn lp lq kq jr lr ls ku lt dt translated">实时仪表</h2><p id="710a" class="pw-post-body-paragraph iy iz hu ja b jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv hn dt translated">演示如何实现实时数据更新。从组件构造函数中的一个简单API调用开始，连接到后端视图模型，数据将被定期推入组件状态，以触发重新呈现:</p><pre class="lc ld le lf fq lu lv lw lx aw ly dt"><span id="1a92" class="lg jz hu lv b fv lz ma l mb mc">dotnetify.react.connect("LiveGaugeVM", this);</span></pre><h2 id="ee61" class="lg jz hu bd ka lh li lj ke lk ll lm ki jj ln lo km jn lp lq kq jr lr ls ku lt dt translated">无限滚动</h2><p id="4464" class="pw-post-body-paragraph iy iz hu ja b jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv hn dt translated">演示了如何实现一个随着用户向下滚动而不断增长的列表。与该功能的常见实现相比，前端没有处理查询构造、分页或数据获取的代码。这些事情都是在后端完成的；该组件只保存它所在页面的引用，并在到达结尾时请求下一页。保持你的前端轻薄简洁！</p><h2 id="37c3" class="lg jz hu bd ka lh li lj ke lk ll lm ki jj ln lo km jn lp lq kq jr lr ls ku lt dt translated">基于令牌的认证</h2><p id="c7cb" class="pw-post-body-paragraph iy iz hu ja b jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv hn dt translated">DotNetify最近有能力为其WebSockets通信编写中间件，这对于身份验证来说非常方便。认证令牌不是放在查询字符串中，而是放在指定为“头”的有效负载的一部分中，由后端中间件提取和验证:</p><pre class="lc ld le lf fq lu lv lw lx aw ly dt"><span id="d648" class="lg jz hu lv b fv lz ma l mb mc">dotnetify.react.connect("AFITop100ListVM", this, {          <br/>   headers: { Authorization: "Bearer " + token }<br/>});</span></pre><h1 id="370a" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">一些警告</h1><p id="09dc" class="pw-post-body-paragraph iy iz hu ja b jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv hn dt translated">这个项目，连同它所依赖的技术，正处于风口浪尖。信号员。NET Core直到2010年才投入生产。网芯2.1出来了。</p><p id="1d70" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">虽然有一些API可以用来处理连接状态事件和服务器异常，但是要支持离线优先的应用程序还有很多工作要做。我目前没有把这作为优先事项，但请让我知道你的想法。</p><p id="f295" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果你对这个项目感兴趣，并想获得最新的更新，请在<a class="ae jx" href="https://twitter.com/dotnetify" rel="noopener ugc nofollow" target="_blank"> twitter @dotnetify </a>上关注我。我也非常感谢您能在<a class="ae jx" href="https://github.com/dsuryd/dotNetify" rel="noopener ugc nofollow" target="_blank">项目的GitHub问题论坛</a>上发布您的问题或反馈。谢谢！</p><figure class="lc ld le lf fq iv"><div class="bz el l di"><div class="md me l"/></div></figure></div></div>    
</body>
</html>