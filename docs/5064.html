<html>
<head>
<title>My neovim setup for Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我的neovim设置</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/my-neovim-setup-for-go-7f7b6e805876?source=collection_archive---------2-----------------------#2017-07-08">https://medium.com/hackernoon/my-neovim-setup-for-go-7f7b6e805876?source=collection_archive---------2-----------------------#2017-07-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="db6c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我经常收到关于如何配置我的<a class="ae jp" href="https://neovim.io" rel="noopener ugc nofollow" target="_blank"> neovim </a>进行Go开发的问题。所以在这篇文章中，我打算描述这一点。为了简洁起见，我不会概括地介绍设置，而是特别介绍Go部分。</p><p id="ed79" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的设置基于<a class="ae jp" href="https://neovim.io" rel="noopener ugc nofollow" target="_blank"> neovim </a>。除了调试器和代码补全(可以在vim中解决——但我不在这里讨论),下面的大部分内容在vim上应该也能很好地工作。</p><p id="d99d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我所有的点文件都在GitHub 上。</p><h1 id="2c44" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">基本vim-go设置配置</h1><p id="28d5" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated"><code class="eh kt ku kv kw b"><a class="ae jp" href="https://github.com/fatih/vim-go" rel="noopener ugc nofollow" target="_blank">vim-go</a></code>是<a class="kx ky gr" href="https://medium.com/u/b1ccd565df0a?source=post_page-----7f7b6e805876--------------------------------" rel="noopener" target="_blank">法提赫·阿尔斯兰</a>的伟大产品，也是(neo)vim中围棋开发者事实上的标准。我将向您介绍我为拥有一个出色的开发环境而做的基本vim-go配置。</p><h2 id="c240" class="kz jr hu bd js la lb lc jw ld le lf ka jc lg lh ke jg li lj ki jk lk ll km lm dt translated">配置缩进</h2><p id="0723" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我对源文件使用了制表符和宽度为4的制表符。这是为所有Go文件设置的配置。</p><pre class="ln lo lp lq fq lr kw ls lt aw lu dt"><span id="284a" class="kz jr hu kw b fv lv lw l lx ly">au FileType go set noexpandtab<br/>au FileType go set shiftwidth=4<br/>au FileType go set softtabstop=4<br/>au FileType go set tabstop=4</span></pre><h2 id="f3e6" class="kz jr hu bd js la lb lc jw ld le lf ka jc lg lh ke jg li lj ki jk lk ll km lm dt translated">代码突出显示</h2><p id="869a" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我喜欢颜色，我相信在开发时，它们通常非常有助于区分代码中的各种实体。所以我在vim-go中启用了很多可用的高亮选项。</p><pre class="ln lo lp lq fq lr kw ls lt aw lu dt"><span id="fe18" class="kz jr hu kw b fv lv lw l lx ly">let g:go_highlight_build_constraints = 1<br/>let g:go_highlight_extra_types = 1<br/>let g:go_highlight_fields = 1<br/>let g:go_highlight_functions = 1<br/>let g:go_highlight_methods = 1<br/>let g:go_highlight_operators = 1<br/>let g:go_highlight_structs = 1<br/>let g:go_highlight_types = 1</span></pre><p id="3a48" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将突出显示字段、函数、方法、操作符、结构、类型等。</p><p id="bf95" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我还启用了相同变量的高亮显示。因此，如果我将光标放在变量<code class="eh kt ku kv kw b">actualData</code>上，那么该变量在视口中的其他用法将会突出显示。请参见下面的示例:</p><figure class="ln lo lp lq fq ma fe ff paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="fe ff lz"><img src="../Images/ec3a4b567cb52bf3e1569c57c11d83bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KwuyBimYu3Nm_8CRzVxmDQ.png"/></div></div></figure><p id="c13f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要启用它，请添加:</p><pre class="ln lo lp lq fq lr kw ls lt aw lu dt"><span id="bac4" class="kz jr hu kw b fv lv lw l lx ly">let g:go_auto_sameids = 1</span></pre><h2 id="4b08" class="kz jr hu bd js la lb lc jw ld le lf ka jc lg lh ke jg li lj ki jk lk ll km lm dt translated">自动导入依赖项</h2><p id="7d45" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">当我来自Python背景时，我喜欢Go的一点是依赖项的自动导入。当导入了错误的包时，有时会有点沮丧。但最重要的是，它提高了我的工作效率。自动导入是<code class="eh kt ku kv kw b">gofmt</code>的一个特性，您可以像这样在vim中启用它:</p><pre class="ln lo lp lq fq lr kw ls lt aw lu dt"><span id="400c" class="kz jr hu kw b fv lv lw l lx ly">let g:go_fmt_command = "goimports"</span></pre><p id="430d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，您将在保存文件时导入依赖项。</p><h2 id="29a1" class="kz jr hu bd js la lb lc jw ld le lf ka jc lg lh ke jg li lj ki jk lk ll km lm dt translated">林挺电码</h2><p id="3e37" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我使用<code class="eh kt ku kv kw b"><a class="ae jp" href="https://github.com/w0rp/ale" rel="noopener ugc nofollow" target="_blank">ale</a></code>为我编写的所有语言lint编码。它开箱后工作得很好，我只做了一些小的调整，使它看起来更好，并与<code class="eh kt ku kv kw b"><a class="ae jp" href="https://github.com/vim-airline/vim-airline" rel="noopener ugc nofollow" target="_blank">airline</a></code>集成。<code class="eh kt ku kv kw b">ale</code>是异步的，所以它不会过多地干扰你的编码。</p><pre class="ln lo lp lq fq lr kw ls lt aw lu dt"><span id="9702" class="kz jr hu kw b fv lv lw l lx ly">" Error and warning signs.<br/>let g:ale_sign_error = '⤫'<br/>let g:ale_sign_warning = '⚠'</span><span id="0301" class="kz jr hu kw b fv mh lw l lx ly">" Enable integration with airline.<br/>let g:airline#extensions#ale#enabled = 1</span></pre><figure class="ln lo lp lq fq ma fe ff paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="fe ff mi"><img src="../Images/e8ef32e29851ba248243ca972af0f41a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MxxRkgXwwOIwHipTMT0QrQ.png"/></div></div><figcaption class="mj mk fg fe ff ml mm bd b be z ek">Warning from ALE for an optimization that can be made in the code.</figcaption></figure><h1 id="3152" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">航行</h1><p id="3a88" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在导航方面，我没有定制太多。但是我想强调一些有用的东西:</p><ul class=""><li id="5981" class="mn mo hu it b iu iv iy iz jc mp jg mq jk mr jo ms mt mu mv dt translated"><code class="eh kt ku kv kw b">]]</code>进入下一个功能或方法</li><li id="8ea8" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated"><code class="eh kt ku kv kw b">[[</code>带你到上一个函数或方法</li></ul><p id="97ec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以上两件东西都是随手拈来，开箱即用。但是它们仅限于您打开的文件中定义的函数或方法。就我个人而言，我尽量在每个文件中包含最少数量的函数，而不是包含很多文件。然后，我希望能够在包中的函数定义<em class="nb">之间进行搜索和轻松导航。</em></p><p id="33a5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这可以通过使用<code class="eh kt ku kv kw b">:GoDeclsDir</code>来实现。为此，你必须将<code class="eh kt ku kv kw b"><a class="ae jp" href="https://github.com/ctrlpvim/ctrlp.vim" rel="noopener ugc nofollow" target="_blank">ctrlp</a></code>和<code class="eh kt ku kv kw b">vim-go</code>一起安装。</p><figure class="ln lo lp lq fq ma fe ff paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="fe ff nc"><img src="../Images/351d042f2b7212e0d438eeb6d3a1ce15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qgJqYL8BtRmDE_-wGXokqQ.png"/></div></div></figure><p id="668f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为此，我在<code class="eh kt ku kv kw b">,gt</code>中添加了一个键映射:</p><pre class="ln lo lp lq fq lr kw ls lt aw lu dt"><span id="e52b" class="kz jr hu kw b fv lv lw l lx ly">au FileType go nmap &lt;leader&gt;gt :GoDeclsDir&lt;cr&gt;</span></pre><h1 id="1dfc" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">运行测试</h1><p id="b793" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我正在编写大量的测试用例，因此在实现和测试之间来回切换要做很多工作。vim-go提供了一个名为<code class="eh kt ku kv kw b">:GoAlternate</code>的命令，如果您在实现中，它会切换到测试用例，反之亦然。这真的很方便，我经常使用它，所以我为它添加了一个键绑定:</p><pre class="ln lo lp lq fq lr kw ls lt aw lu dt"><span id="8c17" class="kz jr hu kw b fv lv lw l lx ly">au Filetype go nmap &lt;leader&gt;ga &lt;Plug&gt;(go-alternate-edit)<br/>au Filetype go nmap &lt;leader&gt;gah &lt;Plug&gt;(go-alternate-split)<br/>au Filetype go nmap &lt;leader&gt;gav &lt;Plug&gt;(go-alternate-vertical)</span></pre><p id="71fa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以现在我只要做<code class="eh kt ku kv kw b">,ga</code>切换到测试(<code class="eh kt ku kv kw b">,</code>是我的leader键)或者<code class="eh kt ku kv kw b">,gav</code> / <code class="eh kt ku kv kw b">,gah</code>以垂直/水平分割打开。</p><p id="3dca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我还将<code class="eh kt ku kv kw b">:GoTest</code>命令映射到了<code class="eh kt ku kv kw b">&lt;F10&gt;</code>。请注意，我添加了<code class="eh kt ku kv kw b">-short</code>标志，以便只在我的编辑器中以短模式运行测试。这通常会绕过具有第三方依赖性(如数据库等)的测试。</p><pre class="ln lo lp lq fq lr kw ls lt aw lu dt"><span id="6487" class="kz jr hu kw b fv lv lw l lx ly">au FileType go nmap &lt;F10&gt; :GoTest -short&lt;cr&gt;</span></pre><p id="1049" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我经常使用的是代码覆盖报告，既用于我自己的开发，也用于代码审查，以识别哪些部分的代码没有被测试恰当地覆盖。我把它映射到<code class="eh kt ku kv kw b">&lt;F9&gt;</code>，就在常规测试旁边。</p><pre class="ln lo lp lq fq lr kw ls lt aw lu dt"><span id="483b" class="kz jr hu kw b fv lv lw l lx ly">au FileType go nmap &lt;F9&gt; :GoCoverageToggle -short&lt;cr&gt;</span></pre><p id="cadb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">覆盖率报告的结果可能看起来像这样。</p><figure class="ln lo lp lq fq ma fe ff paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="fe ff nd"><img src="../Images/2fecc6bf246674d7c2415c4ebfa5a1e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uYFINMuEdRb5chW0JlqnAQ.png"/></div></div><figcaption class="mj mk fg fe ff ml mm bd b be z ek">The implementation is on the left hand side and the tests on the right hand side</figcaption></figure><p id="fb04" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">再次按下<code class="eh kt ku kv kw b">&lt;F9&gt;</code>将去除绿色和红色。</p><h1 id="43cc" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">使用类型和定义</h1><h2 id="0285" class="kz jr hu bd js la lb lc jw ld le lf ka jc lg lh ke jg li lj ki jk lk ll km lm dt translated">在状态行显示类型信息</h2><p id="bf02" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我一直在使用的一个巧妙的小方法是将光标移到一个变量上，看看它是什么类型。或者将它移动到一个函数调用中，查看它的输入参数和返回值。</p><figure class="ln lo lp lq fq ma fe ff paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="fe ff ne"><img src="../Images/7fc6b1a0b30761d96df857bbad1a6356.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V0tk2ltqZOAmovv82h-tsg.png"/></div></div><figcaption class="mj mk fg fe ff ml mm bd b be z ek">actualData is a byte slice in this case</figcaption></figure><p id="f9a6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这确实是应该启用的基本卫生功能之一。启用以下功能:</p><pre class="ln lo lp lq fq lr kw ls lt aw lu dt"><span id="3517" class="kz jr hu kw b fv lv lw l lx ly">let g:go_auto_type_info = 1</span></pre><h2 id="5725" class="kz jr hu bd js la lb lc jw ld le lf ka jc lg lh ke jg li lj ki jk lk ll km lm dt translated">获取文档</h2><p id="585b" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我经常发现自己需要更多关于某些功能的细节。vim-go中有一个开箱即用的内置支持。只需在类型或函数上按下<code class="eh kt ku kv kw b">K</code>即可获得更多详细信息。</p><figure class="ln lo lp lq fq ma fe ff paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="fe ff nf"><img src="../Images/7cfb8adbff2c14c6f928d5a720314bc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xuNld7DQoVb8A2h3EzaTww.png"/></div></div></figure><h2 id="3cc8" class="kz jr hu bd js la lb lc jw ld le lf ka jc lg lh ke jg li lj ki jk lk ll km lm dt translated">转到定义</h2><p id="7b30" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">去定义是我经常做的事情，所以我在<code class="eh kt ku kv kw b">&lt;F12&gt;</code>上添加了一个映射。</p><pre class="ln lo lp lq fq lr kw ls lt aw lu dt"><span id="64dd" class="kz jr hu kw b fv lv lw l lx ly">au FileType go nmap &lt;F12&gt; &lt;Plug&gt;(go-def)</span></pre><p id="6e7e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它把我带到我光标下的任何东西的定义。当我需要回来时，我按下<code class="eh kt ku kv kw b">C-t</code>。</p><h1 id="d3b3" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">代码完成</h1><p id="82c0" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我正在——就像一般的neovim社区一样——使用<code class="eh kt ku kv kw b"><a class="ae jp" href="https://github.com/Shougo/deoplete.nvim" rel="noopener ugc nofollow" target="_blank">deoplete</a></code>来满足我所有语言的补全需求。为了让它和Go一起运行，你还需要安装<code class="eh kt ku kv kw b"><a class="ae jp" href="https://github.com/zchee/deoplete-go" rel="noopener ugc nofollow" target="_blank">deoplete-go</a></code>。</p><p id="467d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要默认启用<code class="eh kt ku kv kw b">deoplete</code>，请将其添加到您的配置中:</p><pre class="ln lo lp lq fq lr kw ls lt aw lu dt"><span id="7450" class="kz jr hu kw b fv lv lw l lx ly">if has('nvim')<br/>    " Enable deoplete on startup<br/>    let g:deoplete#enable_at_startup = 1<br/>endif</span></pre><p id="c195" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它实际上会是这样的:</p><figure class="ln lo lp lq fq ma fe ff paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="fe ff ng"><img src="../Images/c46af73782999d8dbc979dd90a87c50d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t_Qw1UredOrUEsA7Bg9prQ.png"/></div></div></figure><p id="1635" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，如果您也使用多个游标(<code class="eh kt ku kv kw b"><a class="ae jp" href="https://github.com/terryma/vim-multiple-cursors" rel="noopener ugc nofollow" target="_blank">terryma/vim-multiple-cursors</a></code>)，您会发现<code class="eh kt ku kv kw b">deoplete</code>会崩溃很多次。要防止这种情况，请在多光标模式下禁用完成功能:</p><pre class="ln lo lp lq fq lr kw ls lt aw lu dt"><span id="6694" class="kz jr hu kw b fv lv lw l lx ly">" Disable deoplete when in multi cursor mode<br/>function! Multiple_cursors_before()<br/>    let b:deoplete_disable_auto_complete = 1<br/>endfunction</span><span id="ea13" class="kz jr hu kw b fv mh lw l lx ly">function! Multiple_cursors_after()<br/>    let b:deoplete_disable_auto_complete = 0<br/>endfunction</span></pre><h1 id="d984" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">向结构添加JSON标记</h1><p id="4ef3" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">对于那些工作在JSON API上的人来说，定义<code class="eh kt ku kv kw b">struct</code>并手动输入所有JSON标签通常很麻烦。<code class="eh kt ku kv kw b">vim-go</code>是来救援的！如果你有一个这样的<code class="eh kt ku kv kw b">struct</code>:</p><pre class="ln lo lp lq fq lr kw ls lt aw lu dt"><span id="de65" class="kz jr hu kw b fv lv lw l lx ly">type jCreateInvoiceResponse struct {<br/>    Invoice        jInvoice<br/>    PaymentMethods []jPaymentMethod<br/>}</span></pre><p id="ce46" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你会想把它转换成</p><pre class="ln lo lp lq fq lr kw ls lt aw lu dt"><span id="cf41" class="kz jr hu kw b fv lv lw l lx ly">type jCreateInvoiceResponse struct {<br/>    Invoice        jInvoice            `json:"invoice"`<br/>    PaymentMethods []jPaymentMethod    `json:"payment_methods"`<br/>}</span></pre><p id="6b31" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为此，运行<code class="eh kt ku kv kw b">:GoAddTags</code>。我的API通常想要<code class="eh kt ku kv kw b">snakecase</code>属性，但是它也支持<code class="eh kt ku kv kw b">camelcase</code>。使用设置您的首选项</p><pre class="ln lo lp lq fq lr kw ls lt aw lu dt"><span id="f7c0" class="kz jr hu kw b fv lv lw l lx ly">let g:go_addtags_transform = "snakecase"</span></pre><p id="17ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是上述<code class="eh kt ku kv kw b">struct</code>的功能:</p><figure class="ln lo lp lq fq ma fe ff paragraph-image"><div class="fe ff nh"><img src="../Images/f13a0963373d99a1c525215d715bb9d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*XuwsyDX_ZfXcyyg8jFLrWg.gif"/></div></figure><h1 id="a1f0" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">片段驱动开发</h1><p id="b7f8" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">很长一段时间，我在编码时不使用代码片段。很大程度上是因为我不明白它们有多大用处。但是在一天结束的时候，你会一遍又一遍地重复代码中的模式。对于这些模式来说，用片段来填充通用部分是非常有效的。</p><p id="d2da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我正在使用<code class="eh kt ku kv kw b"><a class="ae jp" href="https://github.com/Shougo/neosnippet.vim" rel="noopener ugc nofollow" target="_blank">neosnippet</a></code>进行我的发展。这是最基本也是最重要的，编写自己的代码片段很容易。它的要点是，你写一个关键字，然后按下<code class="eh kt ku kv kw b">C-k</code>，以“扩展”片段。可能有多个地方可以插入您的代码。再次点击<code class="eh kt ku kv kw b">C-k</code>可以进入下一页。</p><p id="45ce" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要使<code class="eh kt ku kv kw b">vim-go</code>的<code class="eh kt ku kv kw b">neosnippet</code>有效，添加以下行:</p><pre class="ln lo lp lq fq lr kw ls lt aw lu dt"><span id="8136" class="kz jr hu kw b fv lv lw l lx ly">let g:go_snippet_engine = "neosnippet"</span></pre><p id="f485" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您需要单独安装<code class="eh kt ku kv kw b">neosnippet</code>和<code class="eh kt ku kv kw b">vim-go</code>。您还应该确保安装<code class="eh kt ku kv kw b"><a class="ae jp" href="https://github.com/Shougo/neosnippet-snippets" rel="noopener ugc nofollow" target="_blank">neosnippet-snippets</a></code>，它为您提供了一长串语言的默认代码片段。</p><p id="a37b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是我使用的几个最有力的片段:</p><ul class=""><li id="5852" class="mn mo hu it b iu iv iy iz jc mp jg mq jk mr jo ms mt mu mv dt translated"><code class="eh kt ku kv kw b">ts</code>扩展为<code class="eh kt ku kv kw b">type | struct</code></li><li id="54f1" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated"><code class="eh kt ku kv kw b">ti</code>展开为<code class="eh kt ku kv kw b">type | interface</code></li><li id="5b1b" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated"><code class="eh kt ku kv kw b"><a class="ae jp" href="https://github.com/sebdah/dotfiles/blob/master/config/nvim/snippets/go.snip#L22" rel="noopener ugc nofollow" target="_blank">funcTest</a></code>为基于表格的单元测试添加样板代码。这是我自己的自定义片段，不是<code class="eh kt ku kv kw b">neosnippet-snippets</code>的一部分。你可以在我的<a class="ae jp" href="https://github.com/sebdah/dotfiles/blob/master/config/nvim/snippets/go.snip#L22" rel="noopener ugc nofollow" target="_blank">点文件</a>里找到。</li><li id="ed39" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated"><code class="eh kt ku kv kw b">ife</code>扩展为<code class="eh kt ku kv kw b">if err != nil { | }</code>类型图案</li></ul><p id="7939" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我真的建议你花些时间学习使用片段，这真的是一个省时的方法。</p><h1 id="a168" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">调试Go代码</h1><p id="4950" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我希望在以后的文章中涵盖更多关于如何调试Go应用程序的内容。但在这一集里，我们将只涉及如何穿着neovim在战场上取得成功。</p><p id="9d3b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，你需要在你的机器上安装<code class="eh kt ku kv kw b"><a class="ae jp" href="https://github.com/derekparker/delve/" rel="noopener ugc nofollow" target="_blank">delve</a></code>。详情请参考他们的<a class="ae jp" href="https://github.com/derekparker/delve/tree/master/Documentation/installation" rel="noopener ugc nofollow" target="_blank">安装文件</a>。</p><p id="9447" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你需要的另一件事是我的包<code class="eh kt ku kv kw b"><a class="ae jp" href="https://github.com/sebdah/vim-delve" rel="noopener ugc nofollow" target="_blank">vim-delve</a></code>，它利用一些neovim特性来与<code class="eh kt ku kv kw b">delve</code>集成。所以不幸的是，这个包不能在常规的vim上运行。</p><p id="6a30" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">安装完依赖项后，现在可以开始调试Go代码了。可以用<code class="eh kt ku kv kw b">:DlvToggleBreakpoint</code>添加断点。然后用<code class="eh kt ku kv kw b">:DlvDebug</code>或<code class="eh kt ku kv kw b">:DlvTest</code>启动调试器(如果调试非<code class="eh kt ku kv kw b">main</code>包，使用<code class="eh kt ku kv kw b">:DlvTest</code>)。</p><p id="4d0c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也支持跟踪点。可以使用<code class="eh kt ku kv kw b">:DlvToggleTracepoint</code>在代码中切换它们。跟踪点不会停止你的执行，它只是打印一个记录，说明跟踪点被点击了。</p><p id="abff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kt ku kv kw b">delve</code>的一个实例:</p><figure class="ln lo lp lq fq ma fe ff paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="fe ff ni"><img src="../Images/1a28b99226bce4d84026668f65b95362.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_XrGYY5_F_w4F3Iw82ypFg.png"/></div></div><figcaption class="mj mk fg fe ff ml mm bd b be z ek">Code to the left with a breakpoint (●) and a tracepoint (◆). Delve output to the right.</figcaption></figure><h1 id="bbdc" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">结束了</h1><p id="bfd7" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">关于vim，我想写的还有很多。但是在某些时候，我可能会偏离本文的主题太多。</p><p id="cc97" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">无论如何，我的<code class="eh kt ku kv kw b"><a class="ae jp" href="https://github.com/sebdah/dotfiles" rel="noopener ugc nofollow" target="_blank">dotfiles</a></code>(和我的<code class="eh kt ku kv kw b"><a class="ae jp" href="https://github.com/sebdah/dotfiles/blob/master/config/nvim/init.vim" rel="noopener ugc nofollow" target="_blank">init.vim</a></code>)保存了所有的细节，所以你可以一直在那里挖掘更多关于我的设置的细节。</p><p id="1cf7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">2017年9月7日更新</strong>:变更林挺部分，将<code class="eh kt ku kv kw b">gometalinter</code>直接使用改为<code class="eh kt ku kv kw b">ale</code>。</p></div></div>    
</body>
</html>