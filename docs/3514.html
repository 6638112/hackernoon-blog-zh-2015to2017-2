<html>
<head>
<title>Smallest .Net ref type is 12 bytes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最小的。净引用类型是12字节</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/smallest-net-ref-type-is-12-bytes-or-why-you-should-consider-using-value-types-7ab87975876a?source=collection_archive---------18-----------------------#2017-04-05">https://medium.com/hackernoon/smallest-net-ref-type-is-12-bytes-or-why-you-should-consider-using-value-types-7ab87975876a?source=collection_archive---------18-----------------------#2017-04-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="0a04" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">为什么应该考虑使用值类型</h2></div><p id="7a79" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我偶然发现了萨沙·戈德斯坦的优秀著作《T2职业》。Net Performance:优化你的C#应用程序，几年前，我非常喜欢它。</p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div class="fe ff kh"><img src="../Images/b717826ec4118f9aba3294b11d95d817.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/0*_OysuY5yPI7tFbSB."/></div></figure><p id="7e18" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">尽管我读它已经快3年了，我已经忘记了很多我学过的东西，但我仍然清楚地记得这句话:</p><blockquote class="kp kq kr"><p id="09f9" class="jj jk kf jl b jm jn iv jo jp jq iy jr ks jt ju jv kt jx jy jz ku kb kc kd ke hn dt translated">…事实上，即使一个没有实例字段的类在实例化时也会占用<strong class="jl hv"> 12个字节</strong>…</p></blockquote><p id="8bc2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当然，这仅限于一个32位的系统。在<strong class="jl hv"> 64位</strong>系统上，最小的引用类型实例将占用<strong class="jl hv"> 24字节</strong>内存！</p><h1 id="29e1" class="kv kw hu bd kx ky kz la lb lc ld le lf ja lg jb lh jd li je lj jg lk jh ll lm dt translated">怎么会？！？</h1><p id="1e68" class="pw-post-body-paragraph jj jk hu jl b jm ln iv jo jp lo iy jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">之所以这样是由于方式。Net对象被放置在内存中:</p><ul class=""><li id="4980" class="ls lt hu jl b jm jn jp jq js lu jw lv ka lw ke lx ly lz ma dt translated">4字节用于对象头字；</li><li id="e014" class="ls lt hu jl b jm mb jp mc js md jw me ka mf ke lx ly lz ma dt translated">4字节用于方法表指针；和</li><li id="1cb8" class="ls lt hu jl b jm mb jp mc js md jw me ka mf ke lx ly lz ma dt translated">实例字段最少4个字节</li></ul><p id="0fd5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当你的类只有一个字节字段时，它仍然会为实例字段占用4个字节的空间，因为对象必须与4个字节的倍数对齐。即使你的类没有实例字段，它仍然会占用4个字节。因此，在32位系统上，最小的引用类型实例将是12字节。</p><p id="9c11" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在64位系统中，一个字是8个字节而不是4个字节，并且对象与最接近的8个字节的倍数对齐，因此在这种情况下，最小的引用类型实例将是24个字节。</p><p id="ecf0" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">侧栏:</strong> <em class="kf">对象头字和方法表指针被JIT和CLR使用。这本书详细介绍了它们的结构和用途，在这篇博文中我们将忽略这些。如果你有兴趣了解更多，去买这本书吧，这钱花得值。</em></p><h1 id="2209" class="kv kw hu bd kx ky kz la lb lc ld le lf ja lg jb lh jd li je lj jg lk jh ll lm dt translated">引用与值类型</h1><p id="380f" class="pw-post-body-paragraph jj jk hu jl b jm ln iv jo jp lo iy jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">当谈到引用与值类型时，有很多东西可以讨论，包括:</p><ul class=""><li id="e9c0" class="ls lt hu jl b jm jn jp jq js lu jw lv ka lw ke lx ly lz ma dt translated">堆栈与堆分配；</li><li id="ff88" class="ls lt hu jl b jm mb jp mc js md jw me ka mf ke lx ly lz ma dt translated">默认相等语义，即按引用比较与按值比较；</li><li id="d3d2" class="ls lt hu jl b jm mb jp mc js md jw me ka mf ke lx ly lz ma dt translated">按值传递与按引用传递；</li><li id="b312" class="ls lt hu jl b jm mb jp mc js md jw me ka mf ke lx ly lz ma dt">…</li></ul><p id="8816" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">出于本文的目的，让我们来关注当您拥有大量内存和缓存时，它们在内存消耗和缓存友好性方面有何不同。</p><h1 id="4178" class="kv kw hu bd kx ky kz la lb lc ld le lf ja lg jb lh jd li je lj jg lk jh ll lm dt translated">内存消耗</h1><p id="dc28" class="pw-post-body-paragraph jj jk hu jl b jm ln iv jo jp lo iy jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">假设您有一个只有X和Y整数字段的<em class="kf"> Point2D </em>类，这个类型的每个实例将在堆中总共占用16个字节(包括X和Y的8个字节)。考虑到一个4字节的引用指针(同样，在32位系统上)，它使我们对每个<em class="kf"> Point2D </em>类型实例的总投资达到20字节！</p><p id="88aa" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你有一个有10M个Point2D 实例的数组，那么你将为这个数组分配190MB的内存！</p><p id="3553" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">另一方面，如果<em class="kf"> Point2D </em>是值类型，那么每个实例将只占用X和Y值的8个字节，并且它们将被紧密地打包到数组中，而不需要每个引用指针额外的4个字节。总的来说，您提交给该阵列的内存量将下降到76MB。</p><h1 id="329a" class="kv kw hu bd kx ky kz la lb lc ld le lf ja lg jb lh jd li je lj jg lk jh ll lm dt translated">缓存友好性</h1><p id="b2ea" class="pw-post-body-paragraph jj jk hu jl b jm ln iv jo jp lo iy jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">虽然访问堆栈和堆分配的内存的速度没有本质上的区别(它们只是虚拟内存中不同的地址范围)，但是有许多与性能相关的考虑因素。</p><p id="2230" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">堆栈分配的内存不会产生GC开销</strong></p><p id="ccd4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">堆栈是自我管理的，当你离开一个作用域时，你只需将指针移回到先前的位置，你就已经“释放”了先前分配的内存。</p><p id="969f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于堆分配的内存，您会招致相当复杂的分代GC的开销，作为集合的一部分，它需要移动幸存的对象来压缩内存空间(随着您从gen 0迁移到gen 2，这变得越来越昂贵)。</p></div><div class="ab cl mg mh hc mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="hn ho hp hq hr"><p id="748f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">侧栏:</strong> <em class="kf">我记得几年前看过一篇帖子，讨论了StackOverflow的人如何检查他们的整个代码库，并尽可能多地将类转换为struct，以便减少由于GC暂停而导致的服务器上的延迟峰值。虽然我并不提倡您也这样做，只是为了说明GC暂停是web服务器上的一个常见问题。最近引入的后台GC模式。Net releases会减少这些暂停的频率，但明智地使用值类型在这方面仍然会有所帮助。</em></p></div><div class="ab cl mg mh hc mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="hn ho hp hq hr"><p id="3e00" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">在堆栈上，时间局部性意味着空间局部性和时间访问局部性</strong></p><p id="62a7" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这意味着，在时间上靠近分配的对象也在空间上靠近存储。此外，在时间上接近分配的对象(例如，在同一个方法中)也可能被一起使用。</p><p id="0062" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">空间和时间访问局部性与高速缓存的工作方式(例如，更少的高速缓存未命中)和操作系统分页的工作方式(例如，更少的虚拟内存交换)配合得很好。</p><p id="2530" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">在堆栈上，内存密度更高</strong></p><p id="27d7" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因为值类型没有引用类型的开销——对象头字和方法表指针——所以你可以在相同数量的内存中装入更多的对象。</p><p id="9ccc" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">更高的内存密度会带来更好的性能，因为这意味着从内存中提取的数据更少。</p><p id="cec1" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">在现代硬件上，整个线程堆栈可以放入CPU缓存</strong></p><p id="fa43" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当你生成一个新线程时，它被分配了1MB的堆栈空间。然而，如今的CPU配备了更大的L3缓存(例如，Nehalem拥有<a class="ae kg" href="https://en.wikipedia.org/wiki/Nehalem_(microarchitecture)" rel="noopener ugc nofollow" target="_blank">高达24MB的L3缓存</a>)，因此整个堆栈可以放入L3缓存中，与主内存相比，L3缓存的访问速度要快得多(看看PostSharp的创造者盖尔·弗雷特(Gael Fraiteur)的<a class="ae kg" href="http://theburningmonk.com/2012/06/takeaways-from-gael-fraiteurs-multithreading-talk/" rel="noopener ugc nofollow" target="_blank">这篇演讲</a>，了解访问时间有何不同)。</p><p id="27fc" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">无论是好是坏，现代硬件都是为了利用空间和时间局部性而构建的，这些优化表现在如何从高速缓存行中的主存储器获取数据。</p><p id="9224" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">考虑一下当你遍历一个由1000万个<em class="kf"> Point2D </em>对象组成的数组时，在硬件层面会发生什么。如果<em class="kf"> Point2D </em>是一个引用类型，那么每次迭代数组中它的一个实例时:</p><ul class=""><li id="f195" class="ls lt hu jl b jm jn jp jq js lu jw lv ka lw ke lx ly lz ma dt translated">CPU将从数组元素所在的位置提取一个缓存行(通常为64字节)</li><li id="177e" class="ls lt hu jl b jm mb jp mc js md jw me ka mf ke lx ly lz ma dt translated">它将访问内存来获取堆中对象的引用指针(4字节)</li><li id="2aaf" class="ls lt hu jl b jm mb jp mc js md jw me ka mf ke lx ly lz ma dt translated">它会丢弃缓存线的剩余部分</li><li id="5253" class="ls lt hu jl b jm mb jp mc js md jw me ka mf ke lx ly lz ma dt translated">它将从对象所在的位置获取另一个缓存行(同样是64字节)</li><li id="0ccf" class="ls lt hu jl b jm mb jp mc js md jw me ka mf ke lx ly lz ma dt translated">它会读取对象并做你要求它做的任何事情</li><li id="24e7" class="ls lt hu jl b jm mb jp mc js md jw me ka mf ke lx ly lz ma dt translated">然后它会对数组中的下一个元素做同样的事情，依此类推…</li></ul><p id="9b56" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">注意这里由于引用跳转浪费了多少工作？</p><p id="973a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">另一方面，如果<em class="kf"> Point2D </em>是只有X和Y值(8字节)的值类型:</p><ul class=""><li id="cf52" class="ls lt hu jl b jm jn jp jq js lu jw lv ka lw ke lx ly lz ma dt translated">CPU将从数组元素所在的位置获取一个缓存行(64字节)</li><li id="fceb" class="ls lt hu jl b jm mb jp mc js md jw me ka mf ke lx ly lz ma dt translated">它将读取对象(8字节)并完成它的工作</li><li id="ef5a" class="ls lt hu jl b jm mb jp mc js md jw me ka mf ke lx ly lz ma dt translated">它将尝试获取下一个对象，意识到它已经在缓存中了(多么幸运的一天！)</li><li id="1bc6" class="ls lt hu jl b jm mb jp mc js md jw me ka mf ke lx ly lz ma dt translated">它将从现有的缓存行中读取下一个对象(8字节),依此类推</li></ul><p id="ee3b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">CPU能够从一次读取中读取8个对象，而每个对象只能读取2次！</p><p id="7cdb" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">要了解这种缓存友好性如何转化为性能数字，我们可以很容易地测量—执行时间。让我们考虑这个简单的例子:</p><figure class="ki kj kk kl fq km"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="bd3f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">以下是在发布模式下运行上述测试的结果:</p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/b98eef73047b4cd9a78740b0c23e63c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/0*nilkrCwZ2Bu2f8pq."/></div></figure><p id="5ccc" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">或者以表格形式:</p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="fe ff mq"><img src="../Images/85e758db0b6cb79c3aadb42013591620.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3aQWITwSS1TMKTsPvKXtfw.png"/></div></div></figure><p id="1895" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">除了额外的内存开销之外，当对象被定义为引用类型时，创建一个包含1000万个对象的数组比<strong class="jl hv">慢10倍，比</strong>慢3倍。</p><p id="1941" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可能会说“嗯，这些仍然只是毫秒！”，但是对于一个需要处理大量并发请求的web服务器来说，这些余量是非常可观的！</p><p id="94b7" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在软件的某些领域，如高频交易或套利交易，即使是纳秒也能对你的底线产生很大的影响。</p><p id="a60a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">侧栏:</strong> <em class="kf">人们正在这些领域做一些真正时髦的事情，以获得对彼此的轻微优势，包括:</em></p><ul class=""><li id="eefe" class="ls lt hu jl b jm jn jp jq js lu jw lv ka lw ke lx ly lz ma dt translated"><em class="kf">在交易所旁边建立数据中心；</em></li><li id="674e" class="ls lt hu jl b jm mb jp mc js md jw me ka mf ke lx ly lz ma dt translated"><em class="kf">使用微波传输数据，使您接收数据的速度比通过光缆连接的交换机更快；</em></li><li id="3ab6" class="ls lt hu jl b jm mb jp mc js md jw me ka mf ke lx ly lz ma dt translated"><em class="kf">用FPGA运行你的交易逻辑；</em></li><li id="1e30" class="ls lt hu jl b jm mb jp mc js md jw me ka mf ke lx ly lz ma dt translated"><em class="kf">等。</em></li></ul><p id="f13c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是一个真正非常有趣的金融领域，我已经从在这些领域工作的朋友那里听到了一些有趣的故事。</p><h1 id="f702" class="kv kw hu bd kx ky kz la lb lc ld le lf ja lg jb lh jd li je lj jg lk jh ll lm dt translated">结论</h1><p id="0d35" class="pw-post-body-paragraph jj jk hu jl b jm ln iv jo jp lo iy jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">明智地使用值类型是提高。Net应用程序——对于C#和F#都是如此。在不走极端的情况下，您应该考虑使用<em class="kf">结构</em>，如果:</p><ul class=""><li id="6c22" class="ls lt hu jl b jm jn jp jq js lu jw lv ka lw ke lx ly lz ma dt translated">对象很小，你需要创建大量的对象；</li><li id="8a03" class="ls lt hu jl b jm mb jp mc js md jw me ka mf ke lx ly lz ma dt translated">你需要高内存密度；</li><li id="2d47" class="ls lt hu jl b jm mb jp mc js md jw me ka mf ke lx ly lz ma dt translated">内存消耗是一个限制因素；</li><li id="f03e" class="ls lt hu jl b jm mb jp mc js md jw me ka mf ke lx ly lz ma dt translated">您需要频繁地迭代它们的大型数组</li></ul><p id="4959" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">此外，以下是一些帮助您“正确使用值类型”的提示:</p><ul class=""><li id="d706" class="ls lt hu jl b jm jn jp jq js lu jw lv ka lw ke lx ly lz ma dt translated">使它们不可改变；</li><li id="88f9" class="ls lt hu jl b jm mb jp mc js md jw me ka mf ke lx ly lz ma dt translated">override <em class="kf">等于</em>(以<em class="kf">对象</em>为参数的那个)；</li><li id="4738" class="ls lt hu jl b jm mb jp mc js md jw me ka mf ke lx ly lz ma dt translated">重载<em class="kf">等于</em>取同值类型的另一个实例(如<em class="kf">等于(point 2d other)</em>)；</li><li id="de1f" class="ls lt hu jl b jm mb jp mc js md jw me ka mf ke lx ly lz ma dt translated">重载运算符==和！=</li><li id="9500" class="ls lt hu jl b jm mb jp mc js md jw me ka mf ke lx ly lz ma dt translated">覆盖<em class="kf"> GetHashCode </em></li></ul><p id="8660" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在下一篇文章中，我们将看看使用值类型的一些陷阱，以及为什么我们有上面的最佳实践。</p><p id="1db2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Scott Meyers在去年的NDC奥斯陆做了一个关于CPU缓存的<a class="ae kg" href="https://vimeo.com/97337258" rel="noopener ugc nofollow" target="_blank">精彩演讲，并触及了其他话题，如<strong class="jl hv">虚假共享</strong>等。如果您不熟悉CPU缓存如何影响代码的性能，这是一个很好的起点。</a></p><p id="4909" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">(因<a class="ae kg" href="http://martinfowler.com/articles/lmax.html" rel="noopener ugc nofollow" target="_blank">颠覆者</a>而出名的)马丁·汤普森有一个很棒的<a class="ae kg" href="http://mechanical-sympathy.blogspot.jp/" rel="noopener ugc nofollow" target="_blank">博客</a>，他在里面写了很多相关的话题，包括:</p><ul class=""><li id="94ad" class="ls lt hu jl b jm jn jp jq js lu jw lv ka lw ke lx ly lz ma dt translated"><a class="ae kg" href="http://mechanical-sympathy.blogspot.jp/2012/08/memory-access-patterns-are-important.html" rel="noopener ugc nofollow" target="_blank">为什么内存访问模式很重要</a></li><li id="8a3e" class="ls lt hu jl b jm mb jp mc js md jw me ka mf ke lx ly lz ma dt translated"><a class="ae kg" href="http://mechanical-sympathy.blogspot.jp/2011/07/memory-barriersfences.html" rel="noopener ugc nofollow" target="_blank">记忆屏障/栅栏</a></li><li id="cd4f" class="ls lt hu jl b jm mb jp mc js md jw me ka mf ke lx ly lz ma dt translated"><a class="ae kg" href="http://mechanical-sympathy.blogspot.jp/2011/07/false-sharing.html" rel="noopener ugc nofollow" target="_blank">虚假分享</a></li><li id="d4b3" class="ls lt hu jl b jm mb jp mc js md jw me ka mf ke lx ly lz ma dt translated"><a class="ae kg" href="http://mechanical-sympathy.blogspot.jp/2013/02/cpu-cache-flushing-fallacy.html" rel="noopener ugc nofollow" target="_blank"> CPU缓存刷新谬误</a></li></ul><p id="34d0" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Martin的文章使用Java作为例子，但是许多经验可以直接应用于。网也是。</p><h1 id="7db9" class="kv kw hu bd kx ky kz la lb lc ld le lf ja lg jb lh jd li je lj jg lk jh ll lm dt translated">链接</h1><ul class=""><li id="472d" class="ls lt hu jl b jm ln jp lo js mv jw mw ka mx ke lx ly lz ma dt translated"><a class="ae kg" rel="noopener" href="/@theburningmonk/beware-of-implicit-boxing-of-value-types-cb515354cef1">小心值类型的隐式装箱</a></li><li id="2c29" class="ls lt hu jl b jm mb jp mc js md jw me ka mf ke lx ly lz ma dt translated"><a class="ae kg" href="https://vimeo.com/97337258" rel="noopener ugc nofollow" target="_blank">Scott Meyers——CPU高速缓存以及您为什么应该关注它</a></li><li id="ab7b" class="ls lt hu jl b jm mb jp mc js md jw me ka mf ke lx ly lz ma dt translated"><a class="ae kg" href="http://mechanical-sympathy.blogspot.jp/" rel="noopener ugc nofollow" target="_blank">机器同情</a></li><li id="a13d" class="ls lt hu jl b jm mb jp mc js md jw me ka mf ke lx ly lz ma dt translated"><a class="ae kg" href="http://martinfowler.com/articles/lmax.html" rel="noopener ugc nofollow" target="_blank"> LMAX架构</a></li><li id="0201" class="ls lt hu jl b jm mb jp mc js md jw me ka mf ke lx ly lz ma dt translated"><a class="ae kg" href="http://theburningmonk.com/2012/06/takeaways-from-gael-fraiteurs-multithreading-talk/" rel="noopener ugc nofollow" target="_blank">从“超越锁关键字的多线程”中获得的经验</a></li></ul><div class="ki kj kk kl fq ab cb"><figure class="my km mz na nb nc nd paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="my km mz na nb nc nd paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="my km mz na nb nc nd paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="kp kq kr"><p id="f922" class="jj jk kf jl b jm jn iv jo jp jq iy jr ks jt ju jv kt jx jy jz ku kb kc kd ke hn dt translated"><a class="ae kg" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是AMI家庭的一员。我们现在<a class="ae kg" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae kg" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jj jk kf jl b jm jn iv jo jp jq iy jr ks jt ju jv kt jx jy jz ku kb kc kd ke hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kg" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kg" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="fe ff ne"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>