<html>
<head>
<title>Programming with JS: Recursion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JS编程:递归</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/programming-with-js-recursion-31371e2bf808?source=collection_archive---------5-----------------------#2017-07-09">https://medium.com/hackernoon/programming-with-js-recursion-31371e2bf808?source=collection_archive---------5-----------------------#2017-07-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/37d08f59ef48530663e2f7ab0720d735.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y7Wb9DOh8n63_tL7MaTCDQ.jpeg"/></div></div></figure><p id="e63f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">理解数据结构、算法和基本编程概念对于成为一名优秀的开发人员至关重要。现在，这些问题中的大部分都通过使用现代工具和库得到了解决，但是在该领域拥有更深入的知识肯定会拓宽你的软件开发视野。</p><p id="6e5e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就个人而言，对我来说很难理解其中的一些概念，因为我在日常工作中没有用到它们。我写这个系列是为了提高我自己对这些话题的理解，并帮助像我一样的其他人。</p><h1 id="ec04" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">什么是递归</h1><p id="792a" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">递归是编程中的主要概念之一。毫无疑问，你在算法书籍和文章中见过这个可怕的词，后面是计算斐波那契数的例子，或者类似的例子。作为一名web开发人员，你可能不会在每天的编码任务或实现排序算法中使用斐波那契数列——至少我不会。</p><p id="c826" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我第一次开始阅读递归时，我很难理解它到底在哪里有用。我理解这种方法的好处及其在某些算法中的应用，但很难找到我更喜欢递归而不是迭代方法的情况。</p><p id="6681" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在继续之前——本文希望您对什么是递归有一个基本的了解，并对JavaScript语言有一个基本的了解。所以，让我们从一个我觉得很容易理解的定义开始:</p><blockquote class="ld"><p id="20d9" class="le lf hu bd lg lh li lj lk ll lm jz ek translated">递归是当一个函数调用自己，直到它达到某个状态</p></blockquote><p id="1dcb" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">让我们把它分成两部分，分别讨论。一个<strong class="je hv">函数调用自己</strong>意味着在函数体内部我们将调用同一个函数——<em class="ls">inception</em>，对吗？第一次看到递归函数时，可能会打破你对代码执行的理解，但这是绝对正常的。</p><p id="890f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我们使用递归时，它将继续下去，直到<strong class="je hv">达到某个期望的状态</strong>。在某些情况下，我们必须调用函数固定的次数。在其他情况下，它将继续运行，直到条件检查告诉它停止。在这两种情况下，我们必须有一个明确定义的停止条件，以防止递归永远运行下去。</p><h1 id="874e" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated"><strong class="ak">应用递归</strong></h1><p id="c78b" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">定义和解释不会让我们有任何进展，所以让我们从一个实际的例子开始。我们将使用递归来说明如何将类别列表排序成树状层次结构。这是我们从服务中得到的分类。它们有名称和父类别:</p><figure class="lt lu lv lw fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="3322" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作为JavaScript开发人员，您的任务是将这些类别排列成树状结构，这样您就可以将它们列在页面的某个位置。你能想到的第一件事是使用一些嵌套循环，<em class="ls">然而</em>这不是最优雅的方法。它暂时可以工作，但是你将依赖于现在仍然存在的结构，如果在某个时候删除或添加了一个子级，你将不得不修改你的代码。</p><p id="6f61" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是一个很好的例子，说明使用递归比普通的迭代方法要好得多。我们将从创建一个函数开始，它将接受两个参数——数组和我们要寻找的类别的父类。请记住，我们不只是从全局状态访问类别，因为我们将递归地遍历它们。</p><pre class="lt lu lv lw fq lz ma mb mc aw md dt"><span id="0e06" class="me kb hu ma b fv mf mg l mh mi">const arrangeCategories = (category, parent) =&gt; { <br/>  let result = {}<br/>  // function body here <br/>  return result<br/>}</span></pre><h1 id="c100" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">递归体</h1><p id="7785" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">接下来，我们需要实际实现递归。我们的目标是拥有一个不依赖于嵌套层次的算法。下面是我们将使用的完整函数:</p><figure class="lt lu lv lw fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="6e11" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看看这里发生了什么。</p><ol class=""><li id="cfb8" class="mj mk hu je b jf jg jj jk jn ml jr mm jv mn jz mo mp mq mr dt translated">在第4行，我们过滤类别，只得到那些具有正确父类的类别(在第一次调用时将是<em class="ls"> null </em></li><li id="b19b" class="mj mk hu je b jf ms jj mt jn mu jr mv jv mw jz mo mp mq mr dt translated">在我们有了所需的类别之后，对于每一个类别，我们都将它们作为一个键添加到结果对象中，并进行递归调用来查找它的所有子类别</li><li id="2b87" class="mj mk hu je b jf ms jj mt jn mu jr mv jv mw jz mo mp mq mr dt translated">重复第一步</li></ol><h1 id="0b64" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">结果呢</h1><p id="c43f" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">在应用递归函数后，我们得到以下结果:</p><figure class="lt lu lv lw fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="f0e5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所有类别都是有序的，创建了一个适当的层次结构，这将更容易通过循环和列表。递归绝对是一个非常广泛的话题，它被用来解决比简单地列出未排序的类别更困难的问题，但是这是一个很好的起点。</p><p id="ddc7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">感谢您的阅读，如果您对JS相关的内容感兴趣，我的个人资料中有完整系列的核心JS概念！</p><blockquote class="mx my mz"><p id="7984" class="jc jd ls je b jf jg jh ji jj jk jl jm na jo jp jq nb js jt ju nc jw jx jy jz hn dt translated"><strong class="je hv">用JS编程:</strong></p><p id="2fa1" class="jc jd ls je b jf jg jh ji jj jk jl jm na jo jp jq nb js jt ju nc jw jx jy jz hn dt translated"><strong class="je hv">递归</strong>:<a class="ae nd" href="https://hackernoon.com/programming-with-js-recursion-31371e2bf808" rel="noopener ugc nofollow" target="_blank">https://hacker noon . com/programming-with-js-Recursion-31371 e2bf 808</a><br/><strong class="je hv">合并排序</strong>:<a class="ae nd" rel="noopener" href="/@KondovAlexander/programming-with-js-merge-sort-deb677b777c0">https://medium . com/@ KondovAlexander/programming-with-js-Merge-Sort-deb 677 b 777 c 0</a><br/><strong class="je hv">二分搜索法</strong>:<a class="ae nd" rel="noopener" href="/@KondovAlexander/programming-with-js-binary-search-aaf86cef9cb3">https://medium . com/@</a></p></blockquote></div></div>    
</body>
</html>