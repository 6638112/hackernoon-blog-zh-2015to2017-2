<html>
<head>
<title>Finding Non-Unique Elements in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Javascript中查找非唯一元素</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/finding-non-unique-elements-in-javascript-d934e6fd6260?source=collection_archive---------6-----------------------#2017-12-05">https://medium.com/hackernoon/finding-non-unique-elements-in-javascript-d934e6fd6260?source=collection_archive---------6-----------------------#2017-12-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="e263" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">令人惊讶的是，算法无处不在，而我们现代开发人员却常常不关心它们。我认为并且确信这些知识只适用于语言和框架核心开发团队。</p><p id="99c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">—如果Array.sort()完成了它的工作并且足够快，谁会关心它是如何工作的呢？</p><p id="0cdd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，我抱着这种心态参加了去年的Facebook Hacker Cup，希望赢得一件t恤，但在第一轮比赛中失败了，感到失望，开始思考如何才能改进，并开始慢慢潜入算法世界。</p><p id="362c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">长话短说，让我们考虑一个简单的例子:</p><p id="da90" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们有一个整数数组，任务是找出其中所有非唯一的元素。</p><h1 id="8c6d" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">天真的解决方案</h1><p id="5bed" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">想一想你会怎么做，让我展示我的第一个可行的解决方案:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="d833" class="lc jr hu ky b fv ld le l lf lg">var length = data.length;<br/>var unique = [];<br/>var distinct = [];</span><span id="40c3" class="lc jr hu ky b fv lh le l lf lg">for (var i = 0; i &lt; length; i++) {<br/>    var elem = data[i];<br/>    var uniqueInd = unique.indexOf(elem);</span><span id="ce52" class="lc jr hu ky b fv lh le l lf lg">    if (uniqueInd &gt; -1) {<br/>        unique.splice(uniqueInd, 1);<br/>    }</span><span id="d35d" class="lc jr hu ky b fv lh le l lf lg">    if (distinct.indexOf(elem) === -1) {<br/>        distinct.push(elem);<br/>        unique.push(elem);<br/>    }<br/>}</span><span id="d909" class="lc jr hu ky b fv lh le l lf lg">for (var i = length - 1; i &gt; -1; i--) {<br/>    if (unique.indexOf(data[i]) &gt; -1) {<br/>        data.splice(i, 1);<br/>    }<br/>}</span><span id="7f91" class="lc jr hu ky b fv lh le l lf lg">return data;</span></pre><p id="f17a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我写这段代码的时候，我不知道任何像<code class="eh li lj lk ky b">map</code>或<code class="eh li lj lk ky b">reduce</code>这样的函数式Javascript方法，所以它看起来很长。但这很有效，让我非常自豪。我花了不到一天的时间。</p><p id="11b5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我把它贴到<a class="ae ll" href="https://js.checkio.org/mission/non-unique-elements/" rel="noopener ugc nofollow" target="_blank">https://js.checkio.org/mission/non-unique-elements/</a>去和其他解决方案比较。</p><h1 id="ce70" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">不错的解决方案</h1><p id="486d" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">一旦你提交了自己的代码，你就可以看看其他人是如何完成的。</p><p id="b742" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这位美女名列榜首:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="ff2b" class="lc jr hu ky b fv ld le l lf lg">return data.filter(function(a){<br/>    return data.indexOf(a) !== data.lastIndexOf(a)<br/>});</span></pre><p id="e00e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它简短易读。背后的想法很聪明——如果一个元素的第一次和最后一次出现相同，那么这个元素只出现一次，所以它是唯一的。</p><p id="8b80" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">看看这个，和我的相比。你看到这个悬崖了吗？</p><p id="7b19" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我印象非常深刻，于是我开始做其他竞争性的编程测验，这一度让我想到了大O符号。</p><h1 id="a00e" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">快速解决方案</h1><p id="ab27" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">要快速理解为什么大O有意义，请看史蒂文·斯基纳书中的图表:</p><figure class="kt ku kv kw fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff ca"><img src="../Images/26fc718f2fa9497e270323f65df9737b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h4POW9O2LhVb7v1QR62BzQ.jpeg"/></div></div></figure><p id="6b09" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">想象我们的算法有n的平方复杂度。这意味着处理一百万个数字的数组大约需要16.7分钟。那不是太多了吗？我想说，这是考虑到在Facebook黑客杯上，一旦你获得输入数据，你只有5分钟的时间来上传结果。</p><p id="a35b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们从算法复杂性的角度来看时，我们的好解决方案还那么好吗？与我的第一个解决方案相同，可惜不是。让我们来看看为什么:</p><p id="fb95" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh li lj lk ky b">indexOf</code>和<code class="eh li lj lk ky b">lastIndexOf</code>在最坏的情况下进行n次运算(假设我们有一个所有唯一数字的数组)，因为它们基本上遍历了整个数据。我们在一个<code class="eh li lj lk ky b">filter</code>方法中执行它们，这个方法是一个n的循环，这意味着我们做了n次操作，也就是O(n * n)。哎呀。这慢得令人无法接受。</p><p id="c9d9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">解决这个问题的一个方法是使用排序。算法科学的基础告诉我们，我们可以以O(n * log(n))复杂度进行排序，也就是说，如果你检查上面的表比O(n * n)快得多，并且即使对于10亿条记录也需要合理的时间。</p><p id="ff79" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦我们对列表进行了排序，我们可以使用另一个基本的算法技巧，用二分搜索法覆盖<code class="eh li lj lk ky b">indexOf</code>和<code class="eh li lj lk ky b">lastIndexOf</code>方法。二分搜索法背后的想法是，在每一步中，我们将可搜索的数组分成两部分，并且只在其中的一部分中继续搜索。我们简单地检查数组中间的数字是大于还是小于我们搜索的数字，然后选择数据的左边部分或右边部分，知道它是排序的。直到我们得到一个只有一个元素的数组，这个元素要么是我们正在寻找的元素，要么不是，这意味着我们的元素根本不在数组中。因此，为了完成这一步，我们需要x个步骤，其中2的x次方是n(因为在每次迭代中，我们将数据量除以2)，这给了我们O(log(n))的复杂度来找到<code class="eh li lj lk ky b">indexOf</code>和<code class="eh li lj lk ky b">lastIndexOf</code>。因为O(log(n)) + O(log(n)) = O(log(n))，所以对于<code class="eh li lj lk ky b">indexOf</code>和<code class="eh li lj lk ky b">lastIndexOf</code>方法调用，我们总共得到O(log(n))复杂度。</p><p id="6177" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我们有一个n的循环(因为我们用<code class="eh li lj lk ky b">filter</code>遍历整个数组)，每次迭代的复杂度为O(log(n))，这样我们的总复杂度为O(n * log(n))。</p><p id="9bb9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这和排序的复杂度是一样的，所以最后，整个算法的复杂度是O(n * log(n))+O(n * log(n))= O(n * log(n))。酷！快多了。</p><p id="ba1c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们甚至可以在不到一分钟的时间内处理10亿条记录。</p><p id="1f3c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是我们如何在一个排序的数组上做复杂度为O(n * log(n))的<code class="eh li lj lk ky b">indexOf</code>:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="09fa" class="lc jr hu ky b fv ld le l lf lg">function newIndexOf(array, elem, startIndex, endIndex) {<br/>    if (array.length === 1) {<br/>        if (array[1] === elem) {<br/>            return startIndex;<br/>        } else {<br/>            return -1;<br/>        }<br/>    }<br/>  <br/>    var median = Math.floor(array.length / 2);<br/>  <br/>    if (elem &lt;= array[median]) {<br/>        return newIndexOf(array, elem, startIndex, median);<br/>    } else {<br/>        return newIndexOf(array, elem, median + 1, endIndex);<br/>    }<br/>}</span></pre><p id="7a11" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh li lj lk ky b">lastIndexOf</code>实施将是相同的，但我们将使用&lt;条件代替≤条件。</p><h1 id="494a" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">更快的解决方案</h1><p id="7e06" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">但是谈论一个高负载甚至~30秒的web服务器似乎太多了。我们能做得更好吗？</p><p id="cebb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每次想到高级阵列实用程序，我都会想到<code class="eh li lj lk ky b">lodash.js</code>库。这就是他们如何<a class="ae ll" href="https://github.com/lodash/lodash/issues/918" rel="noopener ugc nofollow" target="_blank">提议</a>这样做的:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="669f" class="lc jr hu ky b fv ld le l lf lg">_.transform(_.countBy(array), function(result, count, value) {<br/>    if (count &gt; 1) result.push(value);<br/>}, []);</span></pre><p id="5a0a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，我们使用<code class="eh li lj lk ky b">countBy</code>方法计算每个元素的出现次数。它给了我们一个JS对象，该对象将元素作为键，将它们的出现作为值。<code class="eh li lj lk ky b">countBy</code>方法在内部使用JS <code class="eh li lj lk ky b">reduce</code>方法，时间复杂度为O(n ),因为它基本上是遍历整个数组一次。</p><p id="39f3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后使用<code class="eh li lj lk ky b">transform</code>，我们遍历对象中的所有键，并获取那些值(出现次数)大于1的键，这又给了我们时间复杂度O(n ),因为我们在该对象中不能有超过n个键。</p><p id="822f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为O(n) + O(n) = O(n)，所以最终结果是O(n)复杂度。如果您查看上面的表格，您会发现我们现在处理10亿条记录的速度提高了30倍。哇！</p><figure class="kt ku kv kw fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lt"><img src="../Images/727ced14ae76525177eab57a119eefa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PeVn7_ctCrj4llymfwwLRw.jpeg"/></div></div></figure><h1 id="6099" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">结论</h1><p id="cb8e" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">不知何故，我的简短分析证实了像<code class="eh li lj lk ky b">lodash.js</code>这样的框架和实用程序库通常会处理算法的时间复杂度，从这个意义上说，我们可以信任它们。</p><p id="b366" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">与此同时，我们很容易陷入漂亮聪明的代码的陷阱，最终会大大降低我们应用程序的性能。</p><p id="8022" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，即使我们自己可能不会创建复杂的算法，知道如何计算给定算法的复杂性也是很好的，因为这样我们就可以确信，当我们决定将应用程序扩展到更大规模时，我们不会感到意外。</p><p id="9cfa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你真的感兴趣，我强烈推荐史蒂文·斯基纳<a class="ae ll" href="https://www.youtube.com/playlist?list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b" rel="noopener ugc nofollow" target="_blank">的课程</a>和学习书籍，以及【https://js.checkio.org/】的和<a class="ae ll" href="https://www.codewars.com/" rel="noopener ugc nofollow" target="_blank">的【https://www.codewars.com/】的</a>平台来获得一些实践。也许会在下一次编程比赛中见到你。；)</p></div></div>    
</body>
</html>