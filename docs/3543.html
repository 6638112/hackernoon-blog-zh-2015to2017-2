<html>
<head>
<title>Modern Binary Reverse-Engineering with node.js, for Elm, or Why We Really Need Elm Playgrounds</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代二进制逆向工程与节点。js，为榆树，或为什么我们真的需要榆树操场</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/modern-binary-reverse-engineering-with-node-js-for-elm-bd7546853e43?source=collection_archive---------4-----------------------#2017-04-07">https://medium.com/hackernoon/modern-binary-reverse-engineering-with-node-js-for-elm-bd7546853e43?source=collection_archive---------4-----------------------#2017-04-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/></div><div class="ab cl ir is hc it" role="separator"><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw"/></div><div class="hn ho hp hq hr"><p id="72b7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">看起来我已经有一段时间没有发表任何东西了，确切地说是从2014年9月开始，尽管我有很好的<a class="ae jw" href="http://shamansir.github.io/rpd/" rel="noopener ugc nofollow" target="_blank">话题</a>要讨论。因此，这里有一个新的尝试来回复你写书呆子文本。尤其是，考虑到它变得越来越流行，越来越花哨。</p><h2 id="04fc" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr dt translated">这个帖子的一个精髓(不说TL；博士):</h2><p id="cca2" class="pw-post-body-paragraph iy iz hu ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hn dt translated">存在一种语言榆树。这可能是对T4 JavaScript T5的一个很好的替代。【“这是一个粗略的、有争议的说法！”你会说。你有权这么说！].而且，正如每一种新语言都会发生的那样，它一步一步地为每一种现代代码编辑器/ IDE开发插件。每个这样的插件通常都是由新语言社区编写的，而不是由这个特定编辑器/ IDE的开发者编写的。</p><p id="75a1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">对于这些插件的开发者来说，一个问题是，目前Elm没有反射(一种获得实体类型的方法),并且倾向于根本没有反射。就其本身而言，没有反射是一件相当好的事情，通常它会使语言语法和/或库变得非常复杂。但是在编辑器中实现有用的东西需要详细的类型信息——漂亮的类型提示、漂亮的自动完成等。</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div class="fe ff kx"><img src="../Images/a4bfb675639cb5c482b89367d0213d45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*TLYEvS-_i01y29JvLs7NzA.jpeg"/></div><figcaption class="lf lg fg fe ff lh li bd b be z ek">By itself, having no reflection is rather a normal thing… Primitive joke, I know… Failed to resist.</figcaption></figure><p id="701a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">乍一看，这似乎没什么特别——许多语言没有反射，所以人们通常编写依赖于IDE的词法分析器和语法分析器，或者使用其他方法来获取类型信息。但是对于Elm，有一个微妙的区别:它有一个REPL，显示每个条目的实体(变量或函数)的正确类型。它不是在语言的帮助下工作，而是利用编译器的一些隐藏的棘手功能(我将在后面介绍)。那么，为什么不使用官方的REPL结果来获得这些有用的信息呢？..帖子回答为什么。</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="fe ff lj"><img src="../Images/97771ae05ad4ad479319a8e433bf240e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_8MzR6HmOLoCrUTI1gw7og.png"/></div></div><figcaption class="lf lg fg fe ff lh li bd b be z ek">Elm Language REPL (every pun intended… or not)</figcaption></figure><p id="e97e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">此外，这篇文章无耻地向那些为ide开发elm插件的人推销了名为<a class="ae jw" href="https://github.com/shamansir/node-elm-repl" rel="noopener ugc nofollow" target="_blank"> node-elm-repl </a>的node.js库，但只针对那些不介意在目标IDE中运行node.js进程的人。</p><p id="b603" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所以，如果你对Elm或者为ide编写插件或者解析二进制文件不感兴趣，那么这篇文章可能不会让你感兴趣……或者实际上它会让你感兴趣？</p><p id="c00d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">免责声明:</strong> <em class="lo">(我的帖子里总是有免责声明。那为什么要破坏传统呢？)</em>下面的每个结论都是讨论的主题，因为这里发生的只是一个由单一人类思维驱动的调查，通常倾向于如此令人不快的错误，以至于只有几十年才能证明它从一开始就是令人惊讶的正确；</p><h2 id="3b56" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr dt translated">为什么在Elm中获取类型很重要？</h2><p id="4510" class="pw-post-body-paragraph iy iz hu ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hn dt translated">有些人可能对确定类型的<a class="ae jw" href="http://lighttable.com/" rel="noopener ugc nofollow" target="_blank"> <em class="lo"> Lighttable </em> </a>方式感到满意——选择表达式并按一个特殊的键从后台REPL进程的执行中获得值和类型。</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="fe ff lp"><img src="../Images/54764498994e6ccb4093434e3c1812fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*AkVgf681MJsg8BhQXOUGTw.gif"/></div></div><figcaption class="lf lg fg fe ff lh li bd b be z ek">Elm REPL in Lighttable</figcaption></figure><p id="9c5a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Lighttable 可能是第一个受Bret Victor沙盒讲座启发的IDE，它给了我们一些关于它在现实生活中如何工作的想法。目前，有更多的沙盒驱动编程的实现，其中一些实际上实时显示结果。</p><p id="c890" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">XCode里有<a class="ae jw" href="https://developer.apple.com/swift/blog/?id=35" rel="noopener ugc nofollow" target="_blank"> Swift Playgrounds </a>，Mac里有<a class="ae jw" href="http://haskellformac.com/" rel="noopener ugc nofollow" target="_blank">Haskell</a>，ClojureScript里有<a class="ae jw" href="https://github.com/bhauman/devcards" rel="noopener ugc nofollow" target="_blank">dev cards</a>，ClojureScript里有<a class="ae jw" href="https://getstorybook.io/" rel="noopener ugc nofollow" target="_blank"> React故事书</a>，Wolfram Alpha 和新的<a class="ae jw" href="http://www.wolfram.com/development-platform/" rel="noopener ugc nofollow" target="_blank"> Wolfram语言</a>，还有<a class="ae jw" href="http://datalore.io" rel="noopener ugc nofollow" target="_blank"> datalore.io 其他的还有<em class="lo"> livecoding environments </em>，但是一般来说，这个概念是动态地观察代码表达式的结果和/或统计数据，并且通常是横向观察。</a></p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="fe ff lq"><img src="../Images/05aaf251e4e57ec67ced902f3ca54c50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oNFqeyvbXyOCVJI-ss-Mqg.png"/></div></div><figcaption class="lf lg fg fe ff lh li bd b be z ek">Different types of Sandboxes, Playgrounds and Visual REPLs for different languages (not Elm).</figcaption></figure><p id="7790" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">列出的几个环境为用户提供了在不修改实际代码的情况下使用特殊控件来更改输入值的方法，从而让用户监督细微的变化会如何影响输出。</p><p id="8ebc" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Haskell for Mac可能是最接近Elm的东西了。(特别是，考虑到Elm已经有了相当稳定的<a class="ae jw" href="http://package.elm-lang.org/packages/elm-community/webgl/latest" rel="noopener ugc nofollow" target="_blank"> WebGL包</a>，它可能会很大)。</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="fe ff lr"><img src="../Images/df86c416a9f5f6873513c1d6d5e33c78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HqegJWnjes3e55oJQxxgSg.png"/></div></div></figure><p id="df9a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为什么榆树会特别酷？</p><p id="e3eb" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">首先，与Python和JS不同，Elm是<em class="lo">严格类型语言</em>，所以实际上任何变量都100%保证是数字、字符串、HTML块、画布或一些用户定义的自定义类型，包括<em class="lo">选项</em>，并且这个变量保证永远保持这种状态，从它在代码中某处被定义的那一刻开始。</p><p id="02f1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">第二，与React一样，Elm可以将响应<em class="lo">状态</em>变化而返回一些标记(即HTML)的函数视为<em class="lo">组件</em>。因此，如果您的表达式返回HTML(或SVG或canvas context的命令，或任何您可以处理的东西<em class="lo"> visual </em>)并且您的IDE支持沙箱，您可能会在更改绑定到该组件的状态时观察到组件的更改。按照Elm架构，<em class="lo">视图</em>是响应于<code class="eh ls lt lu lv b">Model</code>中的任何变化而返回<code class="eh ls lt lu lv b">Html</code>的函数。</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="fe ff lw"><img src="../Images/32746dc49b568d35022f50a3b42e689c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aXcsZyEkSjod-PW-56Gw7A.png"/></div></div><figcaption class="lf lg fg fe ff lh li bd b be z ek">An example of Elm components provided by <a class="ae jw" href="https://debois.github.io/elm-mdl" rel="noopener ugc nofollow" target="_blank">elm-mdl</a> library.</figcaption></figure><p id="28f2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">第三，对Elm来说更好的是，所有的表达式都是函数，任何函数都可以省略一些参数来调用(在函数式编程中我们称之为“部分应用”)。例如，这允许所述插件用建议值替换一些参数，并绘制所有可能结果的图表。</p><p id="f01a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">哦，还有最重要的一点——这是Evan在看到调试器时所梦想的事情。</p><p id="7a63" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">因此，Elm是最适合沙盒的语言。</p><p id="419a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Mukesh Soni正在为Atom 开发一个插件，为Elm带来React故事书风格的界面。</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="fe ff lx"><img src="../Images/3115d08e8112eff95ffd8845392d6312.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M0SclhlskJw7uTJySRU2TQ.png"/></div></div><figcaption class="lf lg fg fe ff lh li bd b be z ek"><a class="ae jw" href="https://github.com/mukeshsoni/elm-instant" rel="noopener ugc nofollow" target="_blank">Elm-Instant</a> plugin for Atom by Mukesh Soni</figcaption></figure><p id="22bb" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">但是用户需要以特殊的形式包装代码块，并在游戏面板中编写可供尝试的东西，这与沙箱不同，沙箱为程序员提供了对正在开发的实际代码的查看和控制。</p><p id="31cc" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">二进制解析的想法实际上始于我与Mukesh联系的时候(他已经有了插件),我决定尝试通过检测类型来实现一些东西。他完全同意这将有所帮助，所以我匆忙进入二元调查，穆克什在我的发现中给了我很大帮助。不幸的是，由于各种原因，目前将工作类型检测集成到插件本身处于冻结状态。特别是，由于我目前的职业(JetBrains，如果你想知道的话)似乎更好地使用这个技能/代码来改进IDEA插件:)。不过，不管怎样，到处都有它会很酷。这也是我写这篇文章的原因之一。</p><p id="8cab" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">一些到Google Groups讨论的链接，为你提供从语言本身或它的工具外部获取类型的过程:</p><ul class=""><li id="67c3" class="ly lz hu ja b jb jc jf jg jj ma jn mb jr mc jv md me mf mg dt translated">2013.<a class="ae jw" href="https://groups.google.com/forum/#!searchin/elm-discuss/elmi|sort:relevance/elm-discuss/omXjo_4p8CM/-UqLefyCI78J" rel="noopener ugc nofollow" target="_blank"> Evan告诉他正在提供类型</a>，可能使用<code class="eh ls lt lu lv b">elmi</code>文件(这些实验后来被放弃了)；</li><li id="eda0" class="ly lz hu ja b jb mh jf mi jj mj jn mk jr ml jv md me mf mg dt translated">2013.<a class="ae jw" href="https://groups.google.com/forum/#!searchin/elm-discuss/elmi|sort:relevance/elm-discuss/bkEEN1P5f9U/hyNfMSur-d0J" rel="noopener ugc nofollow" target="_blank">二进制文件组织方式的探讨</a>；</li><li id="4161" class="ly lz hu ja b jb mh jf mi jj mj jn mk jr ml jv md me mf mg dt translated">2016.<a class="ae jw" href="https://groups.google.com/forum/#!searchin/elm-dev/elmi|sort:relevance/elm-dev/QPLPd8q1Od0/gYFfWgezBAAJ" rel="noopener ugc nofollow" target="_blank">AST工装讨论，第1页</a>；</li><li id="01e6" class="ly lz hu ja b jb mh jf mi jj mj jn mk jr ml jv md me mf mg dt translated">2016.<a class="ae jw" href="https://groups.google.com/forum/#!searchin/elm-dev/language$20server|sort:relevance/elm-dev/uDGGTEh8ZYg/MNO19dYDAwAJ" rel="noopener ugc nofollow" target="_blank">AST工装讨论，第2页</a>；</li><li id="1db4" class="ly lz hu ja b jb mh jf mi jj mj jn mk jr ml jv md me mf mg dt translated">2017.<a class="ae jw" href="https://groups.google.com/forum/#!searchin/elm-dev/elmi|sort:relevance/elm-dev/aDWFBg72Wt4/0ZUKGOq7CQAJ" rel="noopener ugc nofollow" target="_blank">关于Elm与MS语言服务器配对的讨论</a>；</li></ul><p id="6f7d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">因此，重要的是要注意，在Elm 0.19或稍晚一些的版本中，事情可能会发生巨大的变化，可能在最近的某个时候，我们会以某种方式调用编译器的类型，或者实现一个<a class="ae jw" href="https://github.com/Microsoft/language-server-protocol" rel="noopener ugc nofollow" target="_blank"> MS语言协议</a>。我<em class="lo">真的</em>考虑过这种信念的扭曲，我认为这可能会导致一个没有二进制解析的更好的Elm-IDE世界，而这正是我们真正需要的。另外，<code class="eh ls lt lu lv b">elmi</code>文件格式可以按照Evan想要的任何方式改变。但是我有很棒的测试。如果这种情况很快就会发生，那么这个故事就完全没有实际意义，反而可能是一堆有趣但毫无意义的信息。在进一步阅读之前，请<em class="lo">考虑</em>。</p><h2 id="c714" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr dt translated">现在有哪些Elm IDE插件使用类型建议？</h2><p id="91da" class="pw-post-body-paragraph iy iz hu ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hn dt translated">(此列表中可能有错误，如果有错误或过时，请纠正我)</p><ul class=""><li id="1949" class="ly lz hu ja b jb jc jf jg jj ma jn mb jr mc jv md me mf mg dt translated"><a class="ae jw" href="https://github.com/rundis/elm-light" rel="noopener ugc nofollow" target="_blank"> LightTable Elm插件</a>:之前用<a class="ae jw" href="https://github.com/ElmCast/elm-oracle" rel="noopener ugc nofollow" target="_blank"> elm-oracle </a>，现在直接用elm-repl就地求值代码，自己的<a class="ae jw" href="http://pegjs.majda.cz/" rel="noopener ugc nofollow" target="_blank"> peg.js </a>生成解析器提取类型。在获取类型和值方面，两者都有限制，并且有时间问题，至少是afaik</li><li id="2cdc" class="ly lz hu ja b jb mh jf mi jj mj jn mk jr ml jv md me mf mg dt translated"><a class="ae jw" href="https://github.com/durkiewicz/elm-plugin" rel="noopener ugc nofollow" target="_blank"> IntelliJ IDEA Elm插件</a>:用自己的解析器解析类型；</li><li id="0ffb" class="ly lz hu ja b jb mh jf mi jj mj jn mk jr ml jv md me mf mg dt translated"><a class="ae jw" href="https://github.com/ElmCast/elm-oracle" rel="noopener ugc nofollow" target="_blank"> elm-oracle </a>是一个JS工具，用于从在线的elm文档中提取类型:需要互联网连接；</li><li id="e811" class="ly lz hu ja b jb mh jf mi jj mj jn mk jr ml jv md me mf mg dt translated"><a class="ae jw" href="https://github.com/halohalospecial/atom-elmjutsu" rel="noopener ugc nofollow" target="_blank"> elmjutsu </a>，一个最近的开发，一个在Atom中开发Elm插件的工具箱:不需要<a class="ae jw" href="https://github.com/ElmCast/elm-oracle" rel="noopener ugc nofollow" target="_blank"> elm-oracle </a>仍然解析Elm文档，但是它在本地缓存中存储类型标记，所以通常工作得相当快，并且不需要持续的互联网连接；</li><li id="d3de" class="ly lz hu ja b jb mh jf mi jj mj jn mk jr ml jv md me mf mg dt translated"><a class="ae jw" href="https://github.com/edubkendo/atom-elm" rel="noopener ugc nofollow" target="_blank"> Atom Elm插件</a>:使用<a class="ae jw" href="https://github.com/ElmCast/elm-oracle" rel="noopener ugc nofollow" target="_blank">Elm-Oracle</a>；</li><li id="30ac" class="ly lz hu ja b jb mh jf mi jj mj jn mk jr ml jv md me mf mg dt translated"><a class="ae jw" href="https://github.com/sbrink/vscode-elm" rel="noopener ugc nofollow" target="_blank"> VSCode Elm插件</a>:使用<a class="ae jw" href="https://github.com/ElmCast/elm-oracle" rel="noopener ugc nofollow" target="_blank">Elm-Oracle</a>；</li></ul><p id="7749" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">因此，目前的解决方案是要么编写一个完全定制的Elm语法解析器，要么解析文档。关于第一个选项:自定义语法解析器也需要解析导入的包代码来获取它们的类型。第二种选择主要由JS驱动的<a class="ae jw" href="https://hackernoon.com/tagged/tools" rel="noopener ugc nofollow" target="_blank">工具</a>使用，而不是作为一个浪费时间的问题来解析需求代码。为了在没有指定的时候获取类型，Elm允许，程序员使用<code class="eh ls lt lu lv b">elm-repl</code>。但是Elm编译器本身在编译源代码时已经有了这些信息！</p><h2 id="d9be" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr dt translated">如何改进？</h2><p id="8f2c" class="pw-post-body-paragraph iy iz hu ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hn dt translated">不需要互联网连接仍然比有互联网连接好。在一些国家它仍然很慢，在一些国家一些网站仍然被限制访问。程序员确实想在火车、公共汽车、地铁上工作……很多地方仍然没有联网，或者你必须付费，或者即使你不想也必须授权——现在存在很多障碍(以前甚至更少),尤其是对旅行者而言。</p><p id="eea4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">然而，Elm language的作者Evan曾经注意到，在某些情况下，文档可以存储在软件包发行版本身中。</p><p id="a5ca" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在使用REPL的情况下，只有在您没有安装所需的软件包时才需要连接(“我没有在本地找到您的软件包，我可以下载您的软件包吗？”，它问，你可能会同意)。在所有其他情况下，您可以愉快地继续向它询问类型:</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="fe ff mm"><img src="../Images/83f61b8fee68279743010ca731d65457.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wN3HJKCosPD3X01wDopsqQ.png"/></div></div></figure><p id="e22f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">除了每个命令请求都很慢。作为用户，你可能根本没有注意到这一点，但是即使在我的现代机器上，每个请求都需要300毫秒到几秒钟。如果使用子进程用node.js包装调用，结果需要运行一个独立的REPL进程来检测单个表达式的类型，那么单个调用之间的暂停就变得完全不可预测。</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div class="fe ff mn"><img src="../Images/cc9b35568d25b4dc5915c8d4421b86ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/1*PMlc4nN90gUe2VWdl52vgg.gif"/></div><figcaption class="lf lg fg fe ff lh li bd b be z ek">The actual sensitive pause required to determine the type of the expression for the first time in Elm REPL.</figcaption></figure><p id="9917" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为什么是node.js？现在大多数流行的编辑器要么以JS为动力，要么可能从内部运行JS。另外，Elm目前编译为JS，另外您可以使用原生JS模块连接JS和Elm，还有用于与JS进行数据通信的JS端口——所以JS就像一个真正友好的邻居。至少现在是这样。虽然我们还没有进入WebAssembly。</p><p id="8ec4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">另一个问题是:如果您想以这种方式从REPL中提取类型，您需要从输出中解析它。这与编写语言语法解析器不同，它并不那么难，但是随着REPL输出格式的细微变化(这不能包括在新特性部分中)，您的工具就坏了。如果一些奇怪的操作系统中断了输出，你的工具也会中断。<em class="lo">并且这种格式不受限于编译器版本，实际上插件解析的文档也是如此</em>。完全没有保证。无论如何，REPL本身在寻找类型方面是一个中间人。</p><h2 id="2240" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr dt translated">挖掘REPL逻辑</h2><p id="a473" class="pw-post-body-paragraph iy iz hu ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hn dt translated">但是如果你深入研究一下Elm REPL代码，你会发现Elm编译器实际上创建了一个神奇的二进制文件来存储类型。不在有代码的目录下，而是在<code class="eh ls lt lu lv b">elm-packages</code>目录及以下。该文件的扩展名为<code class="eh ls lt lu lv b">.elmi </code>。REPL用它来得到这些类型，令人惊讶的是，以一种相当肮脏的方式:</p><ul class=""><li id="7e65" class="ly lz hu ja b jb jc jf jg jj ma jn mb jr mc jv md me mf mg dt translated">取新的输入表达式，应该只有一个；</li><li id="8b8f" class="ly lz hu ja b jb mh jf mi jj mj jn mk jr ml jv md me mf mg dt translated">将它附加到之前执行的表达式的所有导入中，因此导入将首先进行，并将与之前的表达式共享；</li><li id="8fc6" class="ly lz hu ja b jb mh jf mi jj mj jn mk jr ml jv md me mf mg dt translated">将您的表达式分配给一个唯一命名的变量(这里是Evan的复活节彩蛋，但我不会破坏它)；</li><li id="e636" class="ly lz hu ja b jb mh jf mi jj mj jn mk jr ml jv md me mf mg dt translated">将这几行连接起来，将所有内容放在一个临时的<code class="eh ls lt lu lv b">.elm</code>文件中；</li><li id="49b4" class="ly lz hu ja b jb mh jf mi jj mj jn mk jr ml jv md me mf mg dt translated">用<code class="eh ls lt lu lv b">elm-make</code>编译这个文件；</li><li id="6952" class="ly lz hu ja b jb mh jf mi jj mj jn mk jr ml jv md me mf mg dt translated">进入<code class="eh ls lt lu lv b">elm-stuff/build-artifacts/user/project/1.0.0</code>，在那里找到对应的<code class="eh ls lt lu lv b">.elmi</code>文件(是二进制的！);</li><li id="3a5d" class="ly lz hu ja b jb mh jf mi jj mj jn mk jr ml jv md me mf mg dt translated">用编译成二进制代码的Haskell代码解析这个文件，并从中提取变量类型；</li><li id="2ff6" class="ly lz hu ja b jb mh jf mi jj mj jn mk jr ml jv md me mf mg dt translated">同样，通过使用node.js执行编译过的<code class="eh ls lt lu lv b">.js</code>文件来获取这个表达式的值，包括一些记录评估值的附加内容；</li><li id="c729" class="ly lz hu ja b jb mh jf mi jj mj jn mk jr ml jv md me mf mg dt translated">删除所有临时的东西，就像它从未发生过一样(<code class="eh ls lt lu lv b">.elmi</code>文件留下来重新使用，到了源文件被改变的时刻)；</li></ul><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="fe ff mo"><img src="../Images/382b21518dd5e12f351da2ecfc2be3b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M7iTR5Q2GWLA_Uv4MR5THw.png"/></div></div><figcaption class="lf lg fg fe ff lh li bd b be z ek">Elm REPL Logic.</figcaption></figure><p id="0e07" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这是我能够从REPL的Haskell代码中得到的，同时使用一些UNIX实用程序来锁定位于已知目录中的文件以防止删除——所以我能够耐心地分析它们而不着急。</p><p id="51cd" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">你好，我亲爱的年轻闪亮的开发者！这是我给你的第一个练习。如果你已经读过一些关于UNIX shell的童话，你能帮我解决一个小问题吗？问题是:在创建文件之前，在不知道文件名的情况下，如何防止文件被删除？…</p><h2 id="c2a6" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr dt translated">摆脱中间人</h2><p id="8b0c" class="pw-post-body-paragraph iy iz hu ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hn dt translated">现在，当算法已知时，我们可能会丢弃一些我们不需要的动作，或者使它们可选。由于对我的要求是JS/node.js的使用，我决定去掉Haskell部分，让一切都由JS驱动。</p><p id="ad14" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这意味着，我们需要用服务器端JavaScript解析二进制文件<code class="eh ls lt lu lv b">.elmi</code>！</p><h2 id="9836" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr dt translated">实际上开始解析</h2><p id="5090" class="pw-post-body-paragraph iy iz hu ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hn dt translated">node.js有很多二进制解析器——然而，事实证明，并不是每个解析器都支持所有预期的东西——这与现实不符。一些解析器不能嵌套(并且<code class="eh ls lt lu lv b">.elmi</code>文件包含嵌套，因为类型定义可能递归地引用它们自己)，一些被放弃，一些需要特殊的解析器语法(像LEG/PEG等)。)所以他们花了很多时间将这种语法转换成JS友好的AST(说实话，使用这些解析器生成器，您通常可以将JS解析器预编译成一个可重用的JS文件，但通常这个文件会占用很多空间)。</p><p id="6425" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我认为拥有类似JS链的语法就足够了——既能从语法中感受到解析器的流程，又不会浪费用户资源。通过一些探索，我使用这些严格要求的列表选择了两个:</p><ul class=""><li id="7395" class="ly lz hu ja b jb jc jf jg jj ma jn mb jr mc jv md me mf mg dt translated"><a class="ae jw" href="https://github.com/substack/node-binary" rel="noopener ugc nofollow" target="_blank">node-binary</a>from<a class="ae jw" href="https://github.com/substack" rel="noopener ugc nofollow" target="_blank">substack</a>:它有很好的语法，并且是最小的；</li><li id="8ec9" class="ly lz hu ja b jb mh jf mi jj mj jn mk jr ml jv md me mf mg dt translated"><a class="ae jw" href="https://github.com/keichi/binary-parser" rel="noopener ugc nofollow" target="_blank">二进制解析器</a>来自<a class="ae jw" href="https://github.com/keichi" rel="noopener ugc nofollow" target="_blank"> keichi </a>:漂亮的语法，也是最小的，有嵌套；</li></ul><p id="46c5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">首先，我认为我可能只是使用node-binary的<code class="eh ls lt lu lv b">.tap()</code>函数来深入复杂的结构，但结果是我还需要有一个<code class="eh ls lt lu lv b">.choice()</code>函数来决定如果某个字节等于某个期望值时调用哪个子解析器，而且keichi的二进制解析器似乎也没有被抛弃(2012 vs 2016)。</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="fe ff mp"><img src="../Images/ac64bcda6602de0902b5091d5fa2730d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h9iwz9IyTK-ZEuD9jhdIFg.png"/></div></div><figcaption class="lf lg fg fe ff lh li bd b be z ek">Some code from the parser</figcaption></figure><p id="b881" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">然而，它需要一些修改。</p><p id="3086" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">首先，我需要<a class="ae jw" href="https://github.com/keichi/binary-parser/pull/41" rel="noopener ugc nofollow" target="_blank">实现对命名子解析器</a>(它们可以被定义为函数)的支持，以便能够在不重新实例化的情况下重用它们，并使用子解析器作为单元来实现真正的递归。</p><p id="1b71" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">第二，它使用类似于<code class="eh ls lt lu lv b">eval</code>的方式在所需的上下文中调用用户定义的回调(实际上，它是<code class="eh ls lt lu lv b">new Function</code>构造函数，它被视为不安全的，最终导致了<code class="eh ls lt lu lv b">eval</code>调用)，Atom基础设施不太喜欢它，所以我需要<a class="ae jw" href="https://github.com/keichi/binary-parser/pull/44" rel="noopener ugc nofollow" target="_blank">将</a> <a class="ae jw" href="https://www.npmjs.com/package/loophole" rel="noopener ugc nofollow" target="_blank">漏洞包</a>添加到<code class="eh ls lt lu lv b">package.json</code>中，并添加一些<em class="lo">猴子补丁、</em>以使代码安全(通过猴子补丁使代码变得安全，听起来真的很奇怪……)。</p><p id="b8b8" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">两个拉请求都没有合并到@_keichi_ yet的原始存储库中。</p><p id="5226" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">代码:</strong>这是解析器最终版本的<a class="ae jw" href="https://github.com/shamansir/node-elm-repl/blob/master/src/parser.js" rel="noopener ugc nofollow" target="_blank">代码，是在</a><a class="ae jw" href="https://github.com/shamansir/binary-parser" rel="noopener ugc nofollow" target="_blank">我自己修改的二进制解析器</a>包的帮助下编写的。</p><h2 id="0780" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr dt translated">潜入二元世界</h2><p id="13c3" class="pw-post-body-paragraph iy iz hu ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hn dt translated">作为<code class="eh ls lt lu lv b">.elmi</code>文件的源材料和正确解析的目标，我决定使用来自exercisem . io的<a class="ae jw" href="http://exercism.io/languages/elm/exercises" rel="noopener ugc nofollow" target="_blank">练习的</a><a class="ae jw" href="https://github.com/shamansir/exercism" rel="noopener ugc nofollow" target="_blank">我的实现</a>。它们有不同但简单的类型组合，我用它们来实际测试代码(chai和mocha来帮忙，nyan！).通过锁定REPL创建的文件，我能够看到REPL提取变量类型的方式(通过为每个新表达式创建一个临时创建的变量和一个文件，正如上面描述的<a class="ae jw" href="#digging-into-the-repl-logic" rel="noopener ugc nofollow">)然后得到二进制结果。</a></p><p id="088b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">首先(实际上，在编写当前80%的解析器代码的过程中)，这是一次手工试错:使用shell二进制查看器并将结果传递给MacOS页面(哈哈！)，我将字体改为等宽字体，用不同的颜色标记看似常见的区域，并试图找到它们之间的结构和关系:</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="fe ff mq"><img src="../Images/37bdaf4d1043220b93995eccc1406625.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tP3g5DwRTwgMLQ5howMLNQ.png"/></div></div><figcaption class="lf lg fg fe ff lh li bd b be z ek">In the process of decomposing binaries, using MacOS Pages and iTerm 2.</figcaption></figure><p id="6597" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv"> Trickity-trick #2: </strong>作为全能的UNIX大师，您会使用哪种UNIX工具以美观友好的方式查看二进制文件内容？</p><p id="fcdb" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">然后，在接近终点时，我发现了一个非常好的工具，名为“<a class="ae jw" href="https://itunes.apple.com/de/app/synalyze-it/id417074533" rel="noopener ugc nofollow" target="_blank"> Synalize it！</a>(原Hexinator)。基本上，这个工具是非常二进制逆向工程的朋友。</p><p id="aa2b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">它允许你打开二进制文件，在一个漂亮的网格中看到它的所有位，用鼠标轻松地标记区域，并给这些区域分配名称/颜色对，不管它们在一个文件中占多少位。之后，您可以重复使用这些配对，用一个名称/颜色标记相似的区域。除此之外，这个工具有自己的基于XML的<code class="eh ls lt lu lv b">.grammar</code>定义格式，支持不同的嵌套方式和重用已经定义的结构。是的，这个工具有点贵，如果这对你不利的话。</p><p id="874e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">用于<code class="eh ls lt lu lv b">.elmi</code>的<code class="eh ls lt lu lv b">.grammar</code>文件也<a class="ae jw" href="https://github.com/shamansir/node-elm-repl/blob/master/elmi.grammar" rel="noopener ugc nofollow" target="_blank">位于存储库</a>中。</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="fe ff mr"><img src="../Images/69bf323828a5863c8f0f817dc64e10c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WB6PLhUDWP0V5-cRdhSlwg.png"/></div></div><figcaption class="lf lg fg fe ff lh li bd b be z ek">A complete grammar structure and an example binary file, parsed with this grammar, side-by-side. Synalyze it!</figcaption></figure><h2 id="41f6" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr dt translated">解构ELMI的细节</h2><p id="d432" class="pw-post-body-paragraph iy iz hu ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hn dt translated">一些原始的结论从一开始就很容易确定:</p><ul class=""><li id="ef9e" class="ly lz hu ja b jb jc jf jg jj ma jn mb jr mc jv md me mf mg dt translated">字符串定义为8个字节长，内容跟随该字节；</li><li id="12c9" class="ly lz hu ja b jb mh jf mi jj mj jn mk jr ml jv md me mf mg dt translated">首先，是Elm版本和包名；</li><li id="6be4" class="ly lz hu ja b jb mh jf mi jj mj jn mk jr ml jv md me mf mg dt translated">然后，有进口，前缀使用的数量；</li><li id="2ac8" class="ly lz hu ja b jb mh jf mi jj mj jn mk jr ml jv md me mf mg dt translated">然后，有出口，前缀使用的数量；</li><li id="73a2" class="ly lz hu ja b jb mh jf mi jj mj jn mk jr ml jv md me mf mg dt translated">然后，是与变量名配对的类型定义；</li><li id="ad34" class="ly lz hu ja b jb mh jf mi jj mj jn mk jr ml jv md me mf mg dt translated">这通常会结束一个文件的重要部分(有时不会)；</li></ul><figure class="ky kz la lb fq lc fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/2932965ba752a262eabb29c2eda18bd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*UdPzfP1ctSje28UY7CBFXA.png"/></div><figcaption class="lf lg fg fe ff lh li bd b be z ek">Root ELMI File structure.</figcaption></figure><p id="82da" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">有些事情很难评估:例如，复杂的结构，当以二进制存储时，通常由几个带有数字的标记位单元组成，后面跟着带有相同数字的标记位单元，但是在这种情况下，这些相同的数字可能具有完全不同的含义，并且在理论上可以(或者不可以)定义在读取这样的标记之后我们应该读取的字节数，但是我们可能应该读取的这些字节也可能包括具有不同含义的标记， 它们内部的一些标记可以定义这个结构应该从现在开始分成三个分支，每个分支都以一些标记开始…确实，当你解构这些无意义的数字的简单序列并试图从它们中形成一个有意义的稳定的树时，感觉你是某种<em class="lo">整体侦探</em> …</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="fe ff mt"><img src="../Images/21b49ab12ea4242708b76dbbf02f2776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6SVz-O7vRmptezQCzDcDag.png"/></div></div><figcaption class="lf lg fg fe ff lh li bd b be z ek">How a line of random byte and string sequences could lead to a meaningful structure with cells and markers.</figcaption></figure><p id="d73f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">尤其是在Pages应用程序中完成时。所以，至少不要在Pages App里做这种东西，除非你真的想变得怪异。</p><p id="cbb4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">项目<a class="ae jw" href="https://github.com/shamansir/node-elm-repl/tree/master/test" rel="noopener ugc nofollow" target="_blank">有所有被发现的复杂类型的例子需要的测试</a>，包括预编译的<code class="eh ls lt lu lv b">.elmi</code>文件和尚未编译的<code class="eh ls lt lu lv b">.elm</code>文件要测试。</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/ad79f3343fe32c27342ab3621f45ebdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*pHve0qRExVL5g6ySUQ1aSg.png"/></div><figcaption class="lf lg fg fe ff lh li bd b be z ek">Package info definition.</figcaption></figure><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="fe ff mv"><img src="../Images/c5ab9afcd708e34374e6acc3545311a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*--9mh73qeRe10VFpR-NXdw.png"/></div></div><figcaption class="lf lg fg fe ff lh li bd b be z ek">Package Info example from HelloWorld.elm</figcaption></figure><p id="4845" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">包装信息。</strong>包信息不需要注释，它只包含Elm编译器版本、包作者用户名和项目名。</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="fe ff mw"><img src="../Images/f016d3c44b204fe6a5a39b6f5bb8dfa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IjAR0GlqbQhytPk_yRJORg.png"/></div></div><figcaption class="lf lg fg fe ff lh li bd b be z ek">Imports and Exports definition.</figcaption></figure><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="fe ff mx"><img src="../Images/ba1a11fe32d61efdda314e6a1609c213.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FzJu3Ky_SL14E44cOiGrpw.png"/></div></div><figcaption class="lf lg fg fe ff lh li bd b be z ek">Imports and Exports example from HelloWorld.elm</figcaption></figure><p id="dcf9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">进口。</strong>任何导入都可以是一个内部包，只通过名称(标记<code class="eh ls lt lu lv b">0001</code>)来定义，或者需要一个包的完整路径和类型(标记<code class="eh ls lt lu lv b">02</code>)。</p><p id="0948" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">出口。它们只是路径——不同长度的字符串数组。</strong></p><p id="ccc4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">类型定义。</strong>类型定义是一个文件中最复杂最繁琐的东西。他们是那些包含上述神秘的标记内标记结构的人。但我是来帮忙的。</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div class="fe ff my"><img src="../Images/4adf5956940922b6378a705e5dc0479b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_yEeWKrHp_Pzqe8nb_2HoA.png"/></div><figcaption class="lf lg fg fe ff lh li bd b be z ek">Type Definitions and Nodes kinds.</figcaption></figure><p id="8401" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这里的结构类型与实际的Elm类型有点不同，但是它们仍然以确定的方式定义了它们。单一类型是用数据单元的递归结构定义的，其中单元可以是:</p><ul class=""><li id="398e" class="ly lz hu ja b jb jc jf jg jj ma jn mb jr mc jv md me mf mg dt translated"><em class="lo">变量</em>(标记为<code class="eh ls lt lu lv b">1</code>):只是通过名称对某个已有变量的引用；</li><li id="b03c" class="ly lz hu ja b jb mh jf mi jj mj jn mk jr ml jv md me mf mg dt translated"><em class="lo"> Lambda </em>(标记为<code class="eh ls lt lu lv b">0</code>):定义将<em class="lo">左侧</em>应用到<em class="lo">右侧</em>的东西——在Elm代码中我们定义类型时用箭头(→)表示，即<code class="eh ls lt lu lv b">String -&gt; Int</code>，其中<code class="eh ls lt lu lv b">String</code>在左侧，<code class="eh ls lt lu lv b">Int</code>在右侧；</li><li id="ad83" class="ly lz hu ja b jb mh jf mi jj mj jn mk jr ml jv md me mf mg dt translated">括起<em class="lo"> Holley </em>或<em class="lo">填充类型</em>(标记为<code class="eh ls lt lu lv b">2</code>):该单元格可以在任何其他单元格内定义，其中<em class="lo"> Holley </em>表示在局部范围内定义的类型，因此由单个名称引用，<em class="lo">填充的</em>表示不仅由名称定义，还由用户、包和模块名称定义的类型；</li><li id="a978" class="ly lz hu ja b jb mh jf mi jj mj jn mk jr ml jv md me mf mg dt translated"><em class="lo">应用</em>(标记为<code class="eh ls lt lu lv b">3</code>):定义一个有<em class="lo">主语</em>和<em class="lo">宾语</em>的东西——在Elm代码中我们定义类型时用空格( )表示，即<code class="eh ls lt lu lv b">List Int</code>，其中<code class="eh ls lt lu lv b">List</code>是主语，<code class="eh ls lt lu lv b">Int</code>是宾语；无限数量的对象可以应用于一个单一的主题；</li><li id="07ee" class="ly lz hu ja b jb mh jf mi jj mj jn mk jr ml jv md me mf mg dt translated"><em class="lo">记录</em>(标记为<code class="eh ls lt lu lv b">4</code>):一条<a class="ae jw" href="http://elm-lang.org/docs/syntax#records" rel="noopener ugc nofollow" target="_blank">记录</a>，记录内有命名的field↔type对，前缀为内存储字段的个数；</li><li id="9df2" class="ly lz hu ja b jb mh jf mi jj mj jn mk jr ml jv md me mf mg dt translated"><em class="lo">别名</em>(标记为<code class="eh ls lt lu lv b">5</code>):推断出的类型，在类型定义中有一个可重用的别名——想想<code class="eh ls lt lu lv b">Html a</code>中的<code class="eh ls lt lu lv b">a</code>、<code class="eh ls lt lu lv b">Cmd msg</code>中的<code class="eh ls lt lu lv b">msg</code>、<code class="eh ls lt lu lv b">foo -&gt; foo</code>中的<code class="eh ls lt lu lv b">foo</code>等等；或者一个<a class="ae jw" href="https://guide.elm-lang.org/types/type_aliases.html" rel="noopener ugc nofollow" target="_blank">类型的别名</a>；</li></ul><p id="6511" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv"> NB: </strong> lambda只能有两部分，所以像<code class="eh ls lt lu lv b">String -&gt; Int -&gt; Bool</code>这样的定义存储为两个lambda，一个在另一个里面:lambda <code class="eh ls lt lu lv b">(Int -&gt; Bool)</code>应用于一个<code class="eh ls lt lu lv b">String</code>类型，根lambda单元格是<code class="eh ls lt lu lv b">(outer-lambda: String -&gt; (inner-lambda: Int -&gt; Bool))</code>；<strong class="ja hv"> Trickity-trick #3: </strong>思考这如何与Elm类型中的函数定义联系起来；</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="fe ff mz"><img src="../Images/0230b180dbad51c24f22262d5c85b503.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_EWmgLteGgooLh6SAsvTiQ.png"/></div></div><figcaption class="lf lg fg fe ff lh li bd b be z ek">All the Node kinds expanded (except Aliases).</figcaption></figure><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="fe ff na"><img src="../Images/f8256ebfc198cfb5239551c16364e5d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kxCvIHFYWbep70iww2Zs_g.png"/></div></div><figcaption class="lf lg fg fe ff lh li bd b be z ek">Type Definition example from HelloWorld.elm</figcaption></figure><p id="a637" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这里的技巧是，几乎每个单元格都可能包含另一个具有自己的内部定义和数字名称空间的单元格，这就是为什么字节的普通结构从一开始就看起来如此重复的原因。如果你有二进制逆向工程的博士学位(像我没有)，你会认为这是显而易见的，但对于新手来说，总有一个建议是不要害怕结构，要相信每一位、每一个字节、每一个生命、每一个宇宙和每一件事情背后都有一个有意义的原因…</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="fe ff nb"><img src="../Images/fa03cbc4b849d2c0d04ba985e13c1f1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h_mmFasHQJmn6EkLiNHO3w.png"/></div></div><figcaption class="lf lg fg fe ff lh li bd b be z ek">Aliased Node structure.</figcaption></figure><p id="aa52" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">联合、别名、固定件。这些似乎对类型定义没有影响，所以这些部分可以完全跳过解析。</strong></p><p id="b395" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">上面所有的方案，连同<code class="eh ls lt lu lv b">.grammar</code>文件，定义了任何<code class="eh ls lt lu lv b">.elmi</code>文件的结构。如果您发现<code class="eh ls lt lu lv b">.elmi</code>文件不符合此方案和语法，请派生<a class="ae jw" href="https://github.com/shamansir/node-elm-repl" rel="noopener ugc nofollow" target="_blank"> node-elm-repl </a>仓库，将此文件<a class="ae jw" href="https://github.com/shamansir/node-elm-repl/tree/master/test" rel="noopener ugc nofollow" target="_blank">添加到规格</a>中，然后向源发出拉取请求。</p><p id="e906" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所以，现在我们知道了任何表达式的类型(和值):</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="fe ff nc"><img src="../Images/33a0344b4513a3a7403c9083a8962f33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-LGFD-b3z5M6bRaDO3_Vbg.png"/></div></div><figcaption class="lf lg fg fe ff lh li bd b be z ek"><a class="ae jw" href="https://github.com/shamansir/node-elm-repl" rel="noopener ugc nofollow" target="_blank">node-elm-repl</a> in Action.</figcaption></figure><h2 id="3a47" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr dt translated">判决</h2><p id="289c" class="pw-post-body-paragraph iy iz hu ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hn dt translated">如果您是任何IDE的Elm插件开发人员，请寻找任何可能的方法在您最喜欢的IDE中开发和集成沙盒与Elm，因为，考虑到所有的语言特性，它完全有可能变得很棒。</p><p id="bc2c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果你是那种为了好玩而从头到尾看完这篇文章的人，请继续做这样的人。</p><p id="1fcc" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果您希望在不久的将来对一个文件进行二进制工程，并且阅读本文只是为了了解通常是如何完成的，那么考虑使用Synalize吧！对于这个案子。否则，就用手和纸。或者页面。或者Excel。无论如何，它训练你的思维去解决深层次的问题。但是有些工具真的有助于不要太疯狂。</p><p id="5526" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果您计划解析<code class="eh ls lt lu lv b">.elmi</code>文件并从中提取类型，那么现在您已经有了一个完整的技术规范……以及一段JS代码来自动完成这项工作。</p><h2 id="d99c" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr dt translated">技巧的解决方案</h2><p id="b271" class="pw-post-body-paragraph iy iz hu ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hn dt translated"><strong class="ja hv"> #1: </strong>没什么特别的，只是用<code class="eh ls lt lu lv b">chmod</code>和<code class="eh ls lt lu lv b">chown</code>在一个可能包含文件的目录上设置一个粘滞位，以防止运行应用程序的用户(这里是REPL)删除里面的任何东西:<a class="ae jw" href="http://unix.stackexchange.com/a/20106/7667" rel="noopener ugc nofollow" target="_blank">http://unix.stackexchange.com/a/20106/7667</a></p><p id="d95d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv"> #2: </strong>更不特别，名叫<code class="eh ls lt lu lv b">xdd</code>的好util是你的朋友:<a class="ae jw" href="http://unix.stackexchange.com/a/282220/7667" rel="noopener ugc nofollow" target="_blank">http://unix.stackexchange.com/a/282220/7667</a>，<a class="ae jw" href="http://stackoverflow.com/a/20305782/167262" rel="noopener ugc nofollow" target="_blank">http://stackoverflow.com/a/20305782/167262</a></p><p id="df02" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv"> #3: </strong>完全无解。</p><figure class="ky kz la lb fq lc"><div class="bz el l di"><div class="nd ne l"/></div></figure></div></div>    
</body>
</html>