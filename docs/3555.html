<html>
<head>
<title>📦 How to publish your package on npm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">📦如何在npm上发布您的包</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-publish-your-package-on-npm-7fc1f5aae600?source=collection_archive---------0-----------------------#2017-04-08">https://medium.com/hackernoon/how-to-publish-your-package-on-npm-7fc1f5aae600?source=collection_archive---------0-----------------------#2017-04-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/d495874239ff04b7a07efbfdb199afcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ASqubrsGsRTIrDh8hNV3HA.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="1fa3" class="pw-subtitle-paragraph jc ie if bd b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ek translated">关于如何在<a class="ae ju" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a>上轻松发布模块的深入指导。</h2></div><p id="d9e1" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">所以，你已经完成了一个lib，cli工具，组件或其他一些脚本，希望与世界分享。🌍所以是时候在<a class="ae ju" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a>上发布了。</p><h2 id="6c32" class="kr ks if bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">🥇你的第一个包裹</h2><p id="2b7f" class="pw-post-body-paragraph jv jw if jx b jy lm jg ka kb ln jj kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">让我们假设，您已经使用了<a class="ae ju" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a>作为您的依赖项。你用<code class="eh lr ls lt lu b">npm install XYZ</code>安装了它们，或者你很酷😎用<a class="ae ju" href="https://yarnpkg.com/lang/en/" rel="noopener ugc nofollow" target="_blank">纱</a></p><p id="e4fe" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果您现在想在npm上发布您的包，有一个简单的命令:</p><pre class="lv lw lx ly fq lz lu ma mb aw mc dt"><span id="1d21" class="kr ks if lu b fv md me l mf mg">npm publish</span></pre><p id="f6de" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">🔥但是在我们这样做之前，我们仍然有一些要点📋清单。</p><h2 id="a193" class="kr ks if bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">📦Package.json</h2><p id="d96c" class="pw-post-body-paragraph jv jw if jx b jy lm jg ka kb ln jj kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">您知道所有的依赖项都保存在您的<code class="eh lr ls lt lu b">package.json</code>中。此外，您还将关于您的包的相关信息保存在该文件中。你可以在这里找到它们</p><p id="2fdc" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">然而最重要的是</p><ul class=""><li id="2d03" class="mh mi if jx b jy jz kb kc ke mj ki mk km ml kq mm mn mo mp dt translated"><code class="eh lr ls lt lu b">name</code></li><li id="5781" class="mh mi if jx b jy mq kb mr ke ms ki mt km mu kq mm mn mo mp dt translated"><code class="eh lr ls lt lu b">version</code></li><li id="ff8f" class="mh mi if jx b jy mq kb mr ke ms ki mt km mu kq mm mn mo mp dt translated"><code class="eh lr ls lt lu b">description</code></li><li id="6095" class="mh mi if jx b jy mq kb mr ke ms ki mt km mu kq mm mn mo mp dt translated"><code class="eh lr ls lt lu b">author</code></li><li id="6044" class="mh mi if jx b jy mq kb mr ke ms ki mt km mu kq mm mn mo mp dt translated"><code class="eh lr ls lt lu b">license</code></li><li id="a3e7" class="mh mi if jx b jy mq kb mr ke ms ki mt km mu kq mm mn mo mp dt translated"><code class="eh lr ls lt lu b">repository</code></li><li id="acdf" class="mh mi if jx b jy mq kb mr ke ms ki mt km mu kq mm mn mo mp dt translated"><code class="eh lr ls lt lu b">main</code></li></ul><p id="25e4" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">字段定义了你的包在注册表中的名字，人们会用你定义的名字来安装你的包。<code class="eh lr ls lt lu b">yarn add XYZ</code>。</p><p id="1927" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">标签定义了你的包的版本。你真的应该考虑使用semver。因为可能很多人会用你的包。没有比破坏人们的生产代码更糟糕的感觉了，因为你引入了破坏性的改变，但是仅仅改变了你的包的补丁版本。🙈</p><p id="a60b" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在<code class="eh lr ls lt lu b">description</code>字段中，您应该添加一个关于您的包裹的快速且准确的描述。如果人们在npmjs.org上搜索你的包裹，就会看到它</p><figure class="lv lw lx ly fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mv"><img src="../Images/17a8f6a0f59086b2e072671ca1a487f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cxhtZKRvBSD58UKN51E25w.png"/></div></div><figcaption class="mw mx fg fe ff my mz bd b be z ek">npm search shows title, username, version and description defined in your package.json</figcaption></figure><p id="5564" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在<code class="eh lr ls lt lu b">author</code>字段中添加您的姓名和电子邮件，这样人们就知道是谁发布了这个包。常见的是以<code class="eh lr ls lt lu b">Name &lt;e-mail&gt;</code>的形式添加。</p><p id="6f58" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我猜<code class="eh lr ls lt lu b">license</code>场是最被遗忘的场之一。人们经常认为这并不重要。然而，如果你想让人们使用你的软件包，也许甚至在更大的项目中，你肯定应该添加一个许可证。所以他们知道是否可以在商业项目中使用，有什么限制等等。</p><p id="c04f" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">您还应该添加带有github repo链接的<code class="eh lr ls lt lu b">repository</code>字段，您还可以添加带有github问题页面链接的<code class="eh lr ls lt lu b">bugs</code>字段。因此人们可以报告错误并知道在哪里请求特性。</p><p id="9231" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">你也可以添加<code class="eh lr ls lt lu b">keywords</code>，如果人们在npmjs.org上搜索什么，它可以帮助他们找到你的包裹</p><h2 id="35d6" class="kr ks if bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">🗄属地</h2><p id="0ef5" class="pw-post-body-paragraph jv jw if jx b jy lm jg ka kb ln jj kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">所以我们都知道你可以在你的项目中添加依赖项。或者用<code class="eh lr ls lt lu b">yarn add</code>或<code class="eh lr ls lt lu b">yarn add -D</code>保存为<code class="eh lr ls lt lu b">devDependencies</code></p><p id="eeaa" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在，如果你在一个项目上工作，比如一个应用程序或网站，如果你把你的依赖项添加为一个依赖项或devDependency，这并不会有很大的不同。因为它们大部分时间都被捆绑在浏览器中。</p><p id="22dd" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">然而，如果你想发布一个包，一个库，一个组件等等。让你的依赖关系正确是很重要的。</p><p id="2c77" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">依赖关系是你的库工作所必需的。因此，如果你正在编写一个API或服务，并且你正在使用例如<a class="ae ju" href="https://github.com/request/request" rel="noopener ugc nofollow" target="_blank">请求</a>，这就是一个依赖。因为这是代码正常运行所必需的。</p><p id="7efa" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx ig"> DevDependencies </strong>是开发所需要的。比如林挺的<code class="eh lr ls lt lu b">eslint</code>或<code class="eh lr ls lt lu b">xo</code>或者测试的<code class="eh lr ls lt lu b">karma</code>或<code class="eh lr ls lt lu b">ava</code>。这很重要，因为如果有人在<code class="eh lr ls lt lu b">yarn add my-awesome-lib</code>上安装你的包，那么<code class="eh lr ls lt lu b">devDependencies</code>就不会被安装！因此，如果你添加<code class="eh lr ls lt lu b">request</code>作为<code class="eh lr ls lt lu b">devDependency</code>，而你的代码中有一个<code class="eh lr ls lt lu b">import request from 'request'</code>，这将不起作用。因为缺少依赖性。</p><p id="240e" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果你为某个东西写一个插件，通常会用到<strong class="jx ig">peer dependency</strong>。因为它要求用户已经安装了依赖项。例如，你想为<code class="eh lr ls lt lu b">webpack</code>写一个插件，你使用了<code class="eh lr ls lt lu b">webpack</code>的一些功能并扩展了它们。如果你将<code class="eh lr ls lt lu b">webpack</code>添加为一个依赖项，用户将会安装两个版本的<code class="eh lr ls lt lu b">webpack</code>，一个是他在构建过程中已经安装的，另一个是你的插件附带的。</p><p id="8428" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这是无稽之谈。你必须在每次发布新的<code class="eh lr ls lt lu b">webpack</code>补丁时更新你的<code class="eh lr ls lt lu b">package.json</code>，并更新依赖版本。你说，<em class="na">嘿，你需要webpack来运行我的插件，所以请安装它。如果有人愿意安装<code class="eh lr ls lt lu b">webpack 2.2.x</code>的话，你的插件也能正常工作。会有一个<code class="eh lr ls lt lu b">peerDependency version mismatch</code>，但只要没有重大变化，它就会起作用。通过这种方式，用户可以自由选择版本和升级依赖项。</em></p><h2 id="c194" class="kr ks if bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">🚪入口点</h2><p id="f99b" class="pw-post-body-paragraph jv jw if jx b jy lm jg ka kb ln jj kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">现在有趣的部分来了。你的库/包的入口点。这个<strong class="jx ig">很大程度上</strong>取决于你的包或者库的类型。是节点模块吗？是浏览器插件吗？</p><p id="d5f6" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">基本入口点将在<code class="eh lr ls lt lu b">main</code>字段上定义。在那里你可以添加你的例如<code class="eh lr ls lt lu b">index.js</code>。如果你传输或者捆绑你的源码，你可以在那里定义dist文件。</p><pre class="lv lw lx ly fq lz lu ma mb aw mc dt"><span id="3cb7" class="kr ks if lu b fv md me l mf mg">"main": "dist/my-awesome-lib.js",</span></pre><p id="8db7" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果你发布节点模块，你会很满意这个。</p><p id="de3b" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">但是如果你要为浏览器发布一些东西，有更多的领域需要了解。</p><p id="1a9a" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">例如<code class="eh lr ls lt lu b">unpkg</code>字段。如果你在npm上发布你的lib，它将在<a class="ae ju" href="https://unpkg.com/#/" rel="noopener ugc nofollow" target="_blank"> unpkg </a>上可用。这是一个CDN，所以人们可以把你的脚本放到他们的脚本中，而不用通过npm安装。</p><pre class="lv lw lx ly fq lz lu ma mb aw mc dt"><span id="4903" class="kr ks if lu b fv md me l mf mg"><a class="ae ju" href="https://unpkg.com/package@version/file" rel="noopener ugc nofollow" target="_blank">https://unpkg.com/package@version/file</a></span></pre><p id="1681" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在<code class="eh lr ls lt lu b">unpkg</code>字段中，您可以定义默认文件，如果某人包含<code class="eh lr ls lt lu b"><a class="ae ju" href="https://unpkg.com/package." rel="noopener ugc nofollow" target="_blank">https://unpkg.com/package</a></code> <a class="ae ju" href="https://unpkg.com/package." rel="noopener ugc nofollow" target="_blank">，则提供该文件。</a></p><p id="323b" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">大多数时候，在那里定义你的库的缩小版本是一个好的实践。</p><pre class="lv lw lx ly fq lz lu ma mb aw mc dt"><span id="db0f" class="kr ks if lu b fv md me l mf mg">"unpkg": "dist/my-awesome-lib.min.js",</span></pre><p id="f70e" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">最后但同样重要的是，还有两个字段。</p><p id="b720" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><code class="eh lr ls lt lu b">module</code>和<code class="eh lr ls lt lu b">jsnext:main</code>字段。它被像Webpack 2这样的现代构建系统用来获取ES6模块。</p><p id="15ff" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">所以你已经建立了你的库。大多用现代ES6。人们希望直接在浏览器中使用它。所以你需要把它转走。但是因为你也有依赖关系，你需要把依赖关系捆绑到它里面。所以你生成了一个<code class="eh lr ls lt lu b">UMD</code>模块。</p><p id="c272" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">但是有些人可能想把你的包和browserify和gulp一起用。或者使用webpack 1。所以你需要一个transpiled和捆绑的<code class="eh lr ls lt lu b">CommonJs</code>版本。然而，我们现在已经2017年了，像摇树这样的事情现在很流行。为此，你需要一个额外的构建。ES模块构建。其中除了导入和导出语句，大多数函数和语句都被传输到ES2015中。</p><p id="09fa" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我想现在，只有<a class="ae ju" href="https://rollupjs.org/" rel="noopener ugc nofollow" target="_blank"> Rollup </a>支持ES模块作为目标输出。(但是你也可以用babel来传输)所以如果你有一个ES模块，你可以在<code class="eh lr ls lt lu b">module</code>和/或<code class="eh lr ls lt lu b">jsnext:main</code>字段中设置条目。</p><p id="f7d0" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这样，您可以为不同的人和环境提供不同的构建。</p><h2 id="d5e1" class="kr ks if bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">⛓兼容性</h2><p id="ab74" class="pw-post-body-paragraph jv jw if jx b jy lm jg ka kb ln jj kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">对于节点模块最重要的是，您可以定义应该安装哪个最低版本的nodejs来运行您的模块。举例来说，如果你在使用<code class="eh lr ls lt lu b">async / await</code>的时候没有把它转换下来，这是很重要的。</p><pre class="lv lw lx ly fq lz lu ma mb aw mc dt"><span id="09c8" class="kr ks if lu b fv md me l mf mg">"engines": {<br/>    "node": "&gt;=7.8.0"<br/>  },</span></pre><h2 id="9245" class="kr ks if bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">🚫忽略和✅文件</h2><p id="b2b8" class="pw-post-body-paragraph jv jw if jx b jy lm jg ka kb ln jj kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">好了，现在我们已经定义了不同的包和构建，我们几乎准备好发布我们的包了。然而，您的git存储库中可能有一个日志。来源，可能是资产、捆绑文件等。将所有这些都包含在你的npm包中是不明智的。保持较小的大小是一个好习惯。</p><p id="c719" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">首先，您不希望您生成的文件出现在您的git repo中。所以你在你的<code class="eh lr ls lt lu b">.gitignore</code>中忽略它们</p><p id="15fc" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">还可以加一个<a class="ae ju" href="https://docs.npmjs.com/misc/developers#keeping-files-out-of-your-package" rel="noopener ugc nofollow" target="_blank">。npmignore </a>。</p><p id="df31" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果你没有创建一个<code class="eh lr ls lt lu b">.npmignore</code>但是你有一个<code class="eh lr ls lt lu b">.gitignore</code> npm将会排除所有在<code class="eh lr ls lt lu b">.gitignore</code>中定义的文件</p><p id="6f39" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">因此，我们忽略了<code class="eh lr ls lt lu b">.gitignore</code>中的<code class="eh lr ls lt lu b">dist</code>文件夹，因为我们不希望它出现在我们的回购中。现在我们需要告诉npm，我们希望包含这些文件。</p><p id="6d82" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">所以我们在我们的<code class="eh lr ls lt lu b">package.json</code>中添加了一个<code class="eh lr ls lt lu b">files</code>数组。</p><pre class="lv lw lx ly fq lz lu ma mb aw mc dt"><span id="be1d" class="kr ks if lu b fv md me l mf mg">"files": [<br/>    "dist"<br/>  ],</span></pre><p id="7226" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">您也可以更明确地只添加文件</p><pre class="lv lw lx ly fq lz lu ma mb aw mc dt"><span id="ea91" class="kr ks if lu b fv md me l mf mg">"files": [<br/>    "dist/my-awesome-lib.js",<br/>    "dist/my-awesome-lib.min.js",<br/>    "dist/my-awesome-lib.esm.js"<br/>  ],</span></pre><h2 id="0f39" class="kr ks if bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">💯出版</h2><p id="7911" class="pw-post-body-paragraph jv jw if jx b jy lm jg ka kb ln jj kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">现在我们准备发布我们的包。但是因为我们是开发人员，而开发人员很懒，所以我们应该在脚本中添加一个额外的命令。<code class="eh lr ls lt lu b">prepublish</code>命令脚本。</p><p id="3324" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这个运行，在每个<code class="eh lr ls lt lu b">npm publish</code>之前。因此，好的做法是清理node_modules并重新安装依赖项，lint并测试代码，然后在发布之前构建代码。但这取决于你！👇🏻</p><pre class="lv lw lx ly fq lz lu ma mb aw mc dt"><span id="6c2f" class="kr ks if lu b fv md me l mf mg">"scripts": {<br/>    "prepublish": "yarn run lint &amp;&amp; yarn run test &amp;&amp; yarn run build"<br/>  },</span></pre><p id="852c" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">最后我们跑<code class="eh lr ls lt lu b">npm publish</code>。请记住，您需要一个npmjs.org账户；)</p><h2 id="8614" class="kr ks if bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">🏷距离标签</h2><p id="0f99" class="pw-post-body-paragraph jv jw if jx b jy lm jg ka kb ln jj kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">最后一个主题非常方便！距离标签。如果您发布您的包，它将自动获得您发布的版本的<strong class="jx ig"> @latest </strong>标签。</p><p id="c180" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">人们可以给你的包安装一个严格版或者最新的标签:<code class="eh lr ls lt lu b">yarn add my-awesome-package@0.0.1</code>或者<code class="eh lr ls lt lu b">yarn add my-awesome-package</code>，相当于<code class="eh lr ls lt lu b">my-awesome-package@latest</code></p><p id="4d75" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在有一些情况下，你将需要距离标签。一个是如果你支持你的包的多个版本。webpack、vue等等就是很好的例子。从第一版开始，然后是第二版。</p><p id="a55f" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">假设您的软件包是1.10.0版，但是您正在开发2.0.0版，并且希望人们测试它并报告问题等等。</p><p id="a1e8" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">问题是，如果你简单地<code class="eh lr ls lt lu b">npm publish</code>它，它会得到最新的标签。所以每个通过<code class="eh lr ls lt lu b">npm install my-lib</code>安装它的人都会得到不稳定的v2.0.0，这不是我们想要的。为此，我们有标签。您可以使用<code class="eh lr ls lt lu b">npm dist-tag ls</code>列出您的标签，您将获得分配给它们的标签和软件包版本列表。</p><figure class="lv lw lx ly fq hw fe ff paragraph-image"><div class="fe ff nb"><img src="../Images/37dd588d13435543fe70856b8ba01836.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*0TzKsPs7Plfe99t42_eFQA.png"/></div></figure><p id="bd01" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">所以现在您可以向发布命令添加标签了。</p><pre class="lv lw lx ly fq lz lu ma mb aw mc dt"><span id="57d4" class="kr ks if lu b fv md me l mf mg">npm publish --tag beta</span></pre><p id="8326" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这样，当前版本2.0.0将被标记为测试版。并且<code class="eh lr ls lt lu b">@latest</code>标签保留在1.10.0版上</p><p id="d32c" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在你可以把它安装在<code class="eh lr ls lt lu b">npm install my-awesome-lib@beta -D</code>上了</p><p id="0b55" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">🔥<strong class="jx ig">知道一个标签只能分配一个版本是很重要的。您不能覆盖对版本的更改。</strong></p><p id="c0c5" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这对于测试来说非常重要。我艰难地认识到，仅仅因为你的代码在本地工作并且通过了单元测试，并不意味着发布在npm上的捆绑文件会像你想的那样工作。</p><p id="dff0" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这就是为什么在使用<code class="eh lr ls lt lu b">@latest</code>标签发布之前测试你的包是好的。为此，您可以使用优秀的旧版本候选。因为如果你把你的包的版本从2.0.0换成2.0.1，用<code class="eh lr ls lt lu b">beta</code>标签发布，然后你看到里面还是有bug，你需要用2.0.2发布下一个。您不能对2.0.1版本进行更改，并发布带有最新标签的相同版本。</p><p id="5638" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这就是为什么<em class="na">发布候选版本</em>或<em class="na"> beta </em>后缀会派上用场。</p><p id="f691" class="pw-post-body-paragraph jv jw if jx b jy jz jg ka kb kc jj kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">您只需将您的<code class="eh lr ls lt lu b">package.json</code>中的版本设置为2.0.0-rc1，并使用beta标签发布它。然后，您可以测试它，只将rc1提升到rc2等。如果你认为你准备好了，你可以把它发布为2.0.0 ⭐</p><div class="lv lw lx ly fq ab cb"><figure class="nc hw nd ne nf ng nh paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nc hw nd ne nf ng nh paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nc hw nd ne nf ng nh paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ni nj nk"><p id="f922" class="jv jw na jx b jy jz jg ka kb kc jj kd nl kf kg kh nm kj kk kl nn kn ko kp kq hn dt translated"><a class="ae ju" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ju" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ju" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ju" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jv jw na jx b jy jz jg ka kb kc jj kd nl kf kg kh nm kj kk kl nn kn ko kp kq hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ju" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ju" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lv lw lx ly fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff no"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>