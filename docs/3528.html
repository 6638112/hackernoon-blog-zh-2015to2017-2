<html>
<head>
<title>Don’t pay the for-loop tax</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要支付循环税</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/dont-pay-the-for-loop-tax-802d381d1cd4?source=collection_archive---------8-----------------------#2017-04-06">https://medium.com/hackernoon/dont-pay-the-for-loop-tax-802d381d1cd4?source=collection_archive---------8-----------------------#2017-04-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="057e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有一次，当我在工作中对一个TypeScript项目进行代码审查时，我遇到了几个我的一个同事使用了<code class="eh jp jq jr js b">for</code>循环的例子，尽管这并不是必要的(也就是说，一个可读性更好的声明性等价体是可用的)。在一个笑话中，我说我们应该对每一个不必要使用的循环征收“循环税”。</p><p id="4e01" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，这让我思考，为什么这么多人倾向于使用更长且更容易出错的循环解决方案，我得出了以下结论:我曾经上过/读过的几乎每一门【主要是】T2【命令式】 <a class="ae ju" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>语言课程/书籍(无论是高中的Pascal和C#，还是大学的C/C++和Wolfram Mathematica)都包含这样的部分</p><blockquote class="jv jw jx"><p id="1a85" class="ir is jt it b iu iv iw ix iy iz ja jb jy jd je jf jz jh ji jj ka jl jm jn jo hn dt translated">这些是可用的循环，这是你如何写它们，这是你如何使用它们来解决这些基本问题。</p></blockquote><p id="48d1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里有重要的一点需要注意:他们只教<em class="jt">如何</em>写一个循环，却很少解释<em class="jt">为什么</em>你需要一个循环(或者有时更糟糕的是，他们声称基于循环的解决方案是最好的)。为了将来参考，我决定写这本“食谱”,介绍循环经常被使用的主要情况以及如何替换它们。所有的例子都将使用JavaScript<a class="ae ju" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank">编写，因为它非常流行，但是这些例子背后的基本原理也可以在许多其他语言中使用。</a></p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><h2 id="2c23" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">#1:我需要遍历一个数组，得到一个单一的值作为结果</h2><p id="609b" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">我们从最简单的问题开始:</p><blockquote class="jv jw jx"><p id="447a" class="ir is jt it b iu iv iw ix iy iz ja jb jy jd je jf jz jh ji jj ka jl jm jn jo hn dt translated">给定一个数字数组，返回其元素之和。</p></blockquote><figure class="li lj lk ll fq lm"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="f6ea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你和我一样参加过类似的课程，你肯定认识这个代码。创建一个临时变量，用零初始化它，并使用for循环迭代数组，返回变量的最终值。尽管存在一些问题:</p><ol class=""><li id="e756" class="lp lq hu it b iu iv iy iz jc lr jg ls jk lt jo lu lv lw lx dt translated">对于简单的数组求和来说，7行代码似乎很多。</li><li id="5996" class="lp lq hu it b iu ly iy lz jc ma jg mb jk mc jo lu lv lw lx dt translated">您必须自己处理迭代的边界。换句话说，您必须知道从零开始(在JavaScript中，许多其他语言都有基于1的数组，例如Wolfram Mathematica ),并在严格小于数组长度的<code class="eh jp jq jr js b">i</code>结束(不小于或等于)。这很容易出错，尤其是当你同时用多种语言工作的时候。</li></ol><figure class="li lj lk ll fq lm"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="aed0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">解决这两个问题的方法是使用reduce函数(在其他语言中也称为<em class="jt"> fold </em>或<em class="jt"> aggregate </em>)。在单个表达式中，我们迭代每个数组元素，将它们加在一起(声明总和的默认值和初始值为零)。注意这里没有提到迭代边界，它只是保证从头到尾遍历所有元素。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><h2 id="2a12" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">#2:我需要从一个给定的数组创建一个新的数组，并转换所有的元素</h2><p id="504f" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">这是另一个常见问题，让我们用这个例子来说明:</p><blockquote class="jv jw jx"><p id="f88e" class="ir is jt it b iu iv iw ix iy iz ja jb jy jd je jf jz jh ji jj ka jl jm jn jo hn dt translated">给定价格数组，返回价格低n %的新数组。</p></blockquote><figure class="li lj lk ll fq lm"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="3c49" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">基于循环的方法非常类似于sum代码。但是还有一个额外的问题:为了不破坏输入数组，我们必须首先克隆它，然后转换新数组中的值。这很容易被忘记，在应用程序中引入了潜在的不希望的副作用。</p><figure class="li lj lk ll fq lm"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="9568" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用<a class="ae ju" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Map" rel="noopener ugc nofollow" target="_blank">图</a>功能可以完全避免克隆问题。对于给定的数组，它返回一个新的数组，其中每个元素都是使用提供的函数转换的原始数组中的相应元素(在我们的示例中是乘以折扣乘数)。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><h2 id="b3e0" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">#3:我需要从m到n的数字</h2><p id="33bc" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">使用循环的另一种常见情况是生成线性范围作为进一步变换的输入。一个经典的例子是:</p><blockquote class="jv jw jx"><p id="8f08" class="ir is jt it b iu iv iw ix iy iz ja jb jy jd je jf jz jh ji jj ka jl jm jn jo hn dt translated">返回前n个正方形的数组</p></blockquote><figure class="li lj lk ll fq lm"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="5f1d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个在使用循环时很难解决的问题。第一种简单的解决方案存在这样的问题，即每次迭代都要向数组中加入一个新元素。这会扩展阵列，并可能导致它在内存中重新分配缓慢(<a class="ae ju" href="https://jsperf.com/array-assign-into-new-array-vs-push" rel="noopener ugc nofollow" target="_blank">基准</a>)。</p><p id="d4d8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第二种方法预先实例化正确大小的数组，避免了这个问题，但是我们很容易在分配当前值时出错(参见第12行的<code class="eh jp jq jr js b">result[i — 1]</code>表达式)。</p><figure class="li lj lk ll fq lm"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="b500" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然在JavaScript中没有生成整数范围的本地方法，但有两种方法可以用map以更具声明性的方式解决这个问题:使用<a class="ae ju" href="https://lodash.com/docs#range" rel="noopener ugc nofollow" target="_blank"> lodash.range </a>函数，或者一个聪明的ES2015语法技巧(<a class="ae ju" href="http://stackoverflow.com/a/10050831/2546338" rel="noopener ugc nofollow" target="_blank"> source </a>)。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><h2 id="bdb4" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">#4:我需要做n次有副作用的事情</h2><p id="7eaa" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">我想在这里讨论循环的最后一个用例是多次调用有副作用的方法。正如埃德格·迪克斯特拉的名言所说:</p><blockquote class="jv jw jx"><p id="f408" class="ir is jt it b iu iv iw ix iy iz ja jb jy jd je jf jz jh ji jj ka jl jm jn jo hn dt translated">两个或更多，使用</p></blockquote><p id="d112" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">说明这种情况的最简单的例子是:</p><blockquote class="jv jw jx"><p id="80a4" class="ir is jt it b iu iv iw ix iy iz ja jb jy jd je jf jz jh ji jj ka jl jm jn jo hn dt translated">Console.log字符串“Hello world”n次</p></blockquote><figure class="li lj lk ll fq lm"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="9b9e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我看来，这是JavaScript中唯一合理的循环用例(不包括无限循环),因为这是最简洁、最高效的方式(至少在大多数环境中使用<a class="ae ju" href="http://2ality.com/2015/06/tail-call-optimization.html" rel="noopener ugc nofollow" target="_blank">尾调用优化</a>之前是如此)。</p><p id="8826" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，我强烈建议将它抽象成一个辅助函数，将循环限制在一个地方。正如我们在左边的例子中看到的(都是用从1到n的数字调用提供的函数)，迭代版本更短，写起来更简单。“无循环”版本也会在没有尾部调用优化的环境中导致堆栈溢出。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><h2 id="331a" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated"><em class="md">结论</em></h2><p id="fe00" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">在四种基本情况下，我们描述了如何使用声明式风格来替换循环，从而使我们的代码更短，更不容易出错。</p><p id="ec4a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你使用循环吗？你不同意这些解决方案吗？请评论！</p><figure class="li lj lk ll fq lm"><div class="bz el l di"><div class="me lo l"/></div></figure></div></div>    
</body>
</html>