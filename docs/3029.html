<html>
<head>
<title>Console Into Mass. The Transit to the Light Side. Automatization of Routine Tasks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">安慰成团。向光明面的过渡。日常任务的自动化</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/console-into-mass-the-transit-to-the-light-side-automatization-of-routine-tasks-af3200bd9a47?source=collection_archive---------10-----------------------#2017-03-07">https://medium.com/hackernoon/console-into-mass-the-transit-to-the-light-side-automatization-of-routine-tasks-af3200bd9a47?source=collection_archive---------10-----------------------#2017-03-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/8be78e6d2ea4c266f3c232e836b3bb02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vq_L9GHHLQcs8KiozAL_2Q.jpeg"/></div></div></figure><div class=""/><h1 id="f544" class="jc jd if bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">介绍</h1><p id="4ec8" class="pw-post-body-paragraph ka kb if kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">不管我们做了什么，输入命令有多快，事实是，我们仍然无法击败计算机的性能。从另一方面来说，如果我们多次重复同一个动作，我们很容易让计算机为难，不是吗？你可以写一个<code class="eh ky kz la lb b">bash</code>脚本(你最喜欢的编程语言),而不是输入相同的命令，浪费你的时间和精力，运行脚本，给自己一些时间，坐在座位上，想想永恒、宇宙或任何其他出现在你脑海中的东西。</p><p id="37bd" class="pw-post-body-paragraph ka kb if kc b kd lc kf kg kh ld kj kk kl le kn ko kp lf kr ks kt lg kv kw kx hn dt translated">在<a class="ae lh" rel="noopener" href="/@var_bin/console-into-mass-bash-scripting-698f75c20163#.5c94xtuwi">上一篇文章</a>中，我们讨论了<code class="eh ky kz la lb b">bash</code>编程的原则。今天我们将学习如何在实践中应用这些知识。</p><h2 id="3ea8" class="li jd if bd je lj lk ll ji lm ln lo jm kl lp lq jq kp lr ls ju kt lt lu jy lv dt translated">自动化计划</h2><ol class=""><li id="e9a3" class="lw lx if kc b kd ke kh ki kl ly kp lz kt ma kx mb mc md me dt translated">快速<code class="eh ky kz la lb b">diff</code></li><li id="007f" class="lw lx if kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated">快速<code class="eh ky kz la lb b">diff</code> +吉拉API</li><li id="49ed" class="lw lx if kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated">清洁<code class="eh ky kz la lb b">_dist</code></li><li id="a2c4" class="lw lx if kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated">更新大量存储库</li><li id="060b" class="lw lx if kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated">克隆大量的存储库</li><li id="44b7" class="lw lx if kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated">有用的别名</li></ol><p id="cce1" class="pw-post-body-paragraph ka kb if kc b kd lc kf kg kh ld kj kk kl le kn ko kp lf kr ks kt lg kv kw kx hn dt translated">给定的计划包括一些我每天做几次(有时甚至一小时)的任务。总的来说，自动化是一个独特的和原始的过程，它允许自动化你能想到的任何事情。希望在你读完这篇文章的时候，你会想出自己的自动化计划来超越你的PC性能。所以，在我们开始之前，给自己泡一杯热咖啡，享受我们用<code class="eh ky kz la lb b">bash</code>进入自动化世界的冒险。</p><h1 id="01c7" class="jc jd if bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">快速差分</h1><p id="1d9f" class="pw-post-body-paragraph ka kb if kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">个人比较喜欢用<a class="ae lh" href="https://git-scm.com/" rel="noopener ugc nofollow" target="_blank"> Git </a>。创建<code class="eh ky kz la lb b">diff</code>是一项频繁的任务，需要输入以下命令:<br/> <code class="eh ky kz la lb b">git diff origin/master origin/&lt;branch-name&gt; &gt; "${HOME}/diff/diff-&lt;branch-name&gt;.diff"</code></p><p id="7687" class="pw-post-body-paragraph ka kb if kc b kd lc kf kg kh ld kj kk kl le kn ko kp lf kr ks kt lg kv kw kx hn dt translated"><code class="eh ky kz la lb b">&lt;branch-name&gt;</code> —是我们需要为其创建<code class="eh ky kz la lb b">diff</code>的分支的名称</p><h2 id="09bc" class="li jd if bd je lj lk ll ji lm ln lo jm kl lp lq jq kp lr ls ju kt lt lu jy lv dt translated">给定方法的缺点</h2><ol class=""><li id="f589" class="lw lx if kc b kd ke kh ki kl ly kp lz kt ma kx mb mc md me dt translated">只能手动输入命令</li><li id="4438" class="lw lx if kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated">错误键入命令的风险</li><li id="3352" class="lw lx if kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated">不容易记住</li></ol><p id="ae29" class="pw-post-body-paragraph ka kb if kc b kd lc kf kg kh ld kj kk kl le kn ko kp lf kr ks kt lg kv kw kx hn dt translated">然而，如果你使用<code class="eh ky kz la lb b">bash</code>，这些问题都可以解决。您应该能够:</p><ol class=""><li id="322e" class="lw lx if kc b kd lc kh ld kl mk kp ml kt mm kx mb mc md me dt translated">输入命令</li><li id="ad0d" class="lw lx if kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated">输入分支机构的名称</li><li id="5f94" class="lw lx if kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated">获取<code class="eh ky kz la lb b">diff</code></li></ol><blockquote class="mn"><p id="4c51" class="mo mp if bd mq mr ms mt mu mv mw kx ek translated">顺利完成这一切。</p></blockquote><h2 id="4ee5" class="li jd if bd je lj mx ll ji lm my lo jm kl mz lq jq kp na ls ju kt nb lu jy lv dt translated">这是end命令的外观</h2><p id="74e5" class="pw-post-body-paragraph ka kb if kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated"><code class="eh ky kz la lb b">gdd &lt;branch-name&gt;</code></p><h2 id="636c" class="li jd if bd je lj lk ll ji lm ln lo jm kl lp lq jq kp lr ls ju kt lt lu jy lv dt translated">使自动化</h2><figure class="nc nd ne nf fq hw"><div class="bz el l di"><div class="ng nh l"/></div></figure><p id="2bb8" class="pw-post-body-paragraph ka kb if kc b kd lc kf kg kh ld kj kk kl le kn ko kp lf kr ks kt lg kv kw kx hn dt translated">现在不用输入很长的命令，输入<code class="eh ky kz la lb b">./fast_diff.sh &lt;branch-name&gt;</code>就够了。脚本会提醒您输入分支机构的名称，以防您忘记输入。</p><h2 id="0849" class="li jd if bd je lj lk ll ji lm ln lo jm kl lp lq jq kp lr ls ju kt lt lu jy lv dt translated">最后一笔</h2><p id="a9f1" class="pw-post-body-paragraph ka kb if kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">此时，您可能会对end命令感到疑惑，因为使用该脚本并不方便，因为我们仍然被绑定到我们使用的目录。</p><p id="a3c8" class="pw-post-body-paragraph ka kb if kc b kd lc kf kg kh ld kj kk kl le kn ko kp lf kr ks kt lg kv kw kx hn dt translated">让我们仔细看看如何为执行文件创建一个新命令，而不是每次都写一个相对/绝对路径。</p><p id="dbf6" class="pw-post-body-paragraph ka kb if kc b kd lc kf kg kh ld kj kk kl le kn ko kp lf kr ks kt lg kv kw kx hn dt translated">每个用户都有一个子目录<code class="eh ky kz la lb b">~/bin</code>，存储执行文件。如果你没有，你可以很容易地创建它。让它的使用如此方便的是，那里的所有文件都可以通过名字来访问，不需要指定它们的路径。我把用来创建<code class="eh ky kz la lb b">diff</code> : <br/> <code class="eh ky kz la lb b">#!/bin/bash <br/>"${HOME}/htdocs/rybka/tools/fast_diff.sh" "$@"</code>的<code class="eh ky kz la lb b">gdd</code>文件移到了这个子目录</p><p id="586c" class="pw-post-body-paragraph ka kb if kc b kd lc kf kg kh ld kj kk kl le kn ko kp lf kr ks kt lg kv kw kx hn dt translated"><strong class="kc ig">一些重要提示:</strong></p><ol class=""><li id="a384" class="lw lx if kc b kd lc kh ld kl mk kp ml kt mm kx mb mc md me dt translated">不需要指定文件扩展名。</li><li id="bc83" class="lw lx if kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated">属性<code class="eh ky kz la lb b">x</code>应该以明确的方式指定(<code class="eh ky kz la lb b">chmod +x &lt;filename&gt;</code>)</li><li id="546c" class="lw lx if kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated">如果在<code class="eh ky kz la lb b">$PATH</code>变量中没有找到<code class="eh ky kz la lb b">bin</code>，应该通过键入:<code class="eh ky kz la lb b">PATH="${PATH}:${HOME}/bin"</code>使其更加明显。</li></ol><p id="3df8" class="pw-post-body-paragraph ka kb if kc b kd lc kf kg kh ld kj kk kl le kn ko kp lf kr ks kt lg kv kw kx hn dt translated">重新启动终端，使该文件可访问。现在，为了创建<code class="eh ky kz la lb b">diff</code>，您只需要输入给定的命令:</p><p id="1ed9" class="pw-post-body-paragraph ka kb if kc b kd lc kf kg kh ld kj kk kl le kn ko kp lf kr ks kt lg kv kw kx hn dt translated"><code class="eh ky kz la lb b">gdd &lt;branch-name&gt;</code></p><p id="ab58" class="pw-post-body-paragraph ka kb if kc b kd lc kf kg kh ld kj kk kl le kn ko kp lf kr ks kt lg kv kw kx hn dt translated">如果您不喜欢为每个命令创建一个新文件，您可以使用符号链接来优化此过程:</p><p id="781b" class="pw-post-body-paragraph ka kb if kc b kd lc kf kg kh ld kj kk kl le kn ko kp lf kr ks kt lg kv kw kx hn dt translated"><code class="eh ky kz la lb b">ln -s "${HOME}/htdocs/rybka/tools/fast_diff.sh" gdd</code></p><h1 id="f518" class="jc jd if bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">快速差分+吉拉API</h1><p id="ee94" class="pw-post-body-paragraph ka kb if kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">如果你使用吉拉或任何其他API任务管理器，你可以走得更远。例如，在吉拉API的帮助下，可以将diff分配给某个任务。为此，您需要使用<a class="ae lh" href="https://curl.haxx.se/" rel="noopener ugc nofollow" target="_blank">卷曲</a>。</p><h2 id="c52b" class="li jd if bd je lj lk ll ji lm ln lo jm kl lp lq jq kp lr ls ju kt lt lu jy lv dt translated">求解算法</h2><ol class=""><li id="ac4b" class="lw lx if kc b kd ke kh ki kl ly kp lz kt ma kx mb mc md me dt translated">运行脚本</li><li id="2050" class="lw lx if kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated">定义任务<code class="eh ky kz la lb b">id</code></li><li id="057f" class="lw lx if kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated">如果任务<code class="eh ky kz la lb b">id</code>尚未提供，则向用户发送消息</li><li id="acb2" class="lw lx if kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated">假设所有操作都已正确完成，我们生成<code class="eh ky kz la lb b">diff</code>并将其分配给一个任务</li></ol><h2 id="0a2c" class="li jd if bd je lj lk ll ji lm ln lo jm kl lp lq jq kp lr ls ju kt lt lu jy lv dt translated">这是end命令的外观</h2><p id="fa13" class="pw-post-body-paragraph ka kb if kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated"><code class="eh ky kz la lb b">gdd_jira &lt;issue_id&gt;</code></p><h2 id="7ea5" class="li jd if bd je lj lk ll ji lm ln lo jm kl lp lq jq kp lr ls ju kt lt lu jy lv dt translated">使自动化</h2><figure class="nc nd ne nf fq hw"><div class="bz el l di"><div class="ng nh l"/></div></figure><p id="511b" class="pw-post-body-paragraph ka kb if kc b kd lc kf kg kh ld kj kk kl le kn ko kp lf kr ks kt lg kv kw kx hn dt translated">您可能已经注意到了，这一次我们不需要将分支的名称传递给脚本。我们可以通过使用<code class="eh ky kz la lb b">git</code>命令:<br/> <code class="eh ky kz la lb b">branch=$(git rev-parse — abbrev-ref HEAD)</code>执行一些简单的操作来得到它</p><h1 id="b65b" class="jc jd if bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">清洁_距离</h1><p id="9bae" class="pw-post-body-paragraph ka kb if kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">在我们继续之前，让我们看看<code class="eh ky kz la lb b">_dist</code>目录是做什么用的。简单来说，就是build系统启动后(<a class="ae lh" href="http://gruntjs.com/" rel="noopener ugc nofollow" target="_blank">咕噜</a>、<a class="ae lh" href="http://gulpjs.com/" rel="noopener ugc nofollow" target="_blank">大口</a>等)保存所有<code class="eh ky kz la lb b">CSS</code>、<code class="eh ky kz la lb b">JavaScript</code>、模板(<a class="ae lh" href="https://pugjs.org/api/getting-started.html" rel="noopener ugc nofollow" target="_blank">翡翠/泥巴</a>、<a class="ae lh" href="http://handlebarsjs.com/" rel="noopener ugc nofollow" target="_blank">车把</a>等)等文件的地方。该目录不一定必须带有<code class="eh ky kz la lb b">_dist</code>名称。你可以找到许多不同的变化。</p><figure class="nc nd ne nf fq hw fe ff paragraph-image"><div class="fe ff ni"><img src="../Images/338f1547f0d4f83ead2091c8c43ea3ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*s3X5XWUJhMX1-U-vsllLJg.jpeg"/></div></figure><p id="bb98" class="pw-post-body-paragraph ka kb if kc b kd lc kf kg kh ld kj kk kl le kn ko kp lf kr ks kt lg kv kw kx hn dt translated">在其中一个项目中，我们使用Grunt。然而，我们的团队经常会遇到一个问题，那就是在一些文件中似乎并不总是能看到变化，大多数文件中的<a class="ae lh" href="http://lesscss.org/" rel="noopener ugc nofollow" target="_blank">更少</a>。为了解决这个问题，你可以一次清理一个或者所有主题的<code class="eh ky kz la lb b">_dist</code>目录。为此，您也可以使用Grunt，手动清理目录，然而，它不会像使用<code class="eh ky kz la lb b">bash</code>那样有效。这里有更多的目录，不是一两个，甚至不是二十个。他们有很多人。使用脚本时的主要要求是不要在没有必要的情况下用包装器和/或依赖项使它过载。</p><p id="95ec" class="pw-post-body-paragraph ka kb if kc b kd lc kf kg kh ld kj kk kl le kn ko kp lf kr ks kt lg kv kw kx hn dt translated">让我们看看如何用shell的力量来做同样的事情:<br/> <code class="eh ky kz la lb b">find &lt;path-to-themes&gt; -type d -name "_dist" | xargs rm -rfv</code></p><p id="b2b4" class="pw-post-body-paragraph ka kb if kc b kd lc kf kg kh ld kj kk kl le kn ko kp lf kr ks kt lg kv kw kx hn dt translated"><code class="eh ky kz la lb b">&lt;path-to-themes&gt;</code> —主题目录的路径</p><p id="5ca0" class="pw-post-body-paragraph ka kb if kc b kd lc kf kg kh ld kj kk kl le kn ko kp lf kr ks kt lg kv kw kx hn dt translated">给定方法的缺点与<code class="eh ky kz la lb b">diff</code>创建的情况相同。另外，没有选项来指定我们想要删除的主题目录。</p><h2 id="6397" class="li jd if bd je lj lk ll ji lm ln lo jm kl lp lq jq kp lr ls ju kt lt lu jy lv dt translated">求解算法</h2><ol class=""><li id="6259" class="lw lx if kc b kd ke kh ki kl ly kp lz kt ma kx mb mc md me dt translated">运行脚本</li><li id="c1cb" class="lw lx if kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated">如果你没有主题的名称，你可以删除<code class="eh ky kz la lb b">_dist</code>目录中的所有主题</li><li id="3cdb" class="lw lx if kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated">如果你有一个特定的主题名称，删除<code class="eh ky kz la lb b">_dist</code>只为这一个</li></ol><h2 id="e128" class="li jd if bd je lj lk ll ji lm ln lo jm kl lp lq jq kp lr ls ju kt lt lu jy lv dt translated">这是end命令的外观</h2><p id="b448" class="pw-post-body-paragraph ka kb if kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated"><code class="eh ky kz la lb b">clean_dist [&lt;theme_name&gt;]</code></p><h2 id="3517" class="li jd if bd je lj lk ll ji lm ln lo jm kl lp lq jq kp lr ls ju kt lt lu jy lv dt translated">使自动化</h2><figure class="nc nd ne nf fq hw"><div class="bz el l di"><div class="ng nh l"/></div></figure><h1 id="6ae0" class="jc jd if bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">更新大量存储库</h1><figure class="nc nd ne nf fq hw fe ff paragraph-image"><div class="fe ff nj"><img src="../Images/f7f3bd34255161c37e4efc0da1691666.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/1*lsurkA-acsbTiU-2d15WTw.jpeg"/></div></figure><p id="59ae" class="pw-post-body-paragraph ka kb if kc b kd lc kf kg kh ld kj kk kl le kn ko kp lf kr ks kt lg kv kw kx hn dt translated">假设您在一个大型项目中工作，该项目包含第三方存储库的目录，即使您没有创建它们，您仍然需要支持和更新。如果他们是两个或三个，这可能不是一个大问题，虽然，就我个人而言，我不会这么有信心。</p><blockquote class="mn"><p id="1aef" class="mo mp if bd mq mr nk nl nm nn no kx ek translated">但是，如果您有超过10-15个存储库需要支持，该怎么办呢？</p></blockquote><p id="5d85" class="pw-post-body-paragraph ka kb if kc b kd np kf kg kh nq kj kk kl nr kn ko kp ns kr ks kt nt kv kw kx hn dt translated">你需要花很多时间不断地跟踪他们。那么为什么不将这个过程自动化呢？</p><h2 id="d167" class="li jd if bd je lj lk ll ji lm ln lo jm kl lp lq jq kp lr ls ju kt lt lu jy lv dt translated">求解算法</h2><ol class=""><li id="2422" class="lw lx if kc b kd ke kh ki kl ly kp lz kt ma kx mb mc md me dt translated">转到带有存储库的目录</li><li id="b13e" class="lw lx if kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated">检查仓库是否在<code class="eh ky kz la lb b">master</code>分支中</li><li id="6281" class="lw lx if kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated">如果不存在，运行<code class="eh ky kz la lb b">git checkout</code></li><li id="9550" class="lw lx if kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated">然后<code class="eh ky kz la lb b">git pull</code></li></ol><p id="c993" class="pw-post-body-paragraph ka kb if kc b kd lc kf kg kh ld kj kk kl le kn ko kp lf kr ks kt lg kv kw kx hn dt translated"><strong class="kc ig">重要提示。</strong>即使存储库已经切换到<code class="eh ky kz la lb b">master</code>分支，它仍然有可能没有被更新。考虑到这一点，无论如何都应该竞选<code class="eh ky kz la lb b">git pull</code>。</p><h2 id="99c1" class="li jd if bd je lj lk ll ji lm ln lo jm kl lp lq jq kp lr ls ju kt lt lu jy lv dt translated">这是end命令的外观</h2><p id="aaf2" class="pw-post-body-paragraph ka kb if kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated"><code class="eh ky kz la lb b">up_repo</code></p><h2 id="2279" class="li jd if bd je lj lk ll ji lm ln lo jm kl lp lq jq kp lr ls ju kt lt lu jy lv dt translated">使自动化</h2><figure class="nc nd ne nf fq hw"><div class="bz el l di"><div class="ng nh l"/></div></figure><h1 id="ed98" class="jc jd if bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">克隆大量的存储库</h1><p id="f495" class="pw-post-body-paragraph ka kb if kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">这个过程与前一个过程紧密相连。以使用户能够在实践中使用先前的命令。我需要为他/她提供一个第三方开发人员的存储库，将它添加到一个<code class="eh ky kz la lb b">bash/core/vendors</code>目录中(用户不一定需要知道)。根据<code class="eh ky kz la lb b">npm modules</code>的类比，这个存储库不应该和主存储库放在一起。用户所要做的就是执行命令，等待所有存储库的克隆完成。</p><h2 id="13b5" class="li jd if bd je lj lk ll ji lm ln lo jm kl lp lq jq kp lr ls ju kt lt lu jy lv dt translated">求解算法</h2><ol class=""><li id="22da" class="lw lx if kc b kd ke kh ki kl ly kp lz kt ma kx mb mc md me dt translated">储存库列表被设置为一个数组</li><li id="c9da" class="lw lx if kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated">运行阵列周期</li><li id="260c" class="lw lx if kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated">如果一个供应商有多个存储库，要特别注意</li><li id="e287" class="lw lx if kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated">多做几项检查</li><li id="4cc7" class="lw lx if kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated">执行<code class="eh ky kz la lb b">git clone</code></li></ol><h2 id="401b" class="li jd if bd je lj lk ll ji lm ln lo jm kl lp lq jq kp lr ls ju kt lt lu jy lv dt translated">这是end命令的外观</h2><p id="b225" class="pw-post-body-paragraph ka kb if kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated"><code class="eh ky kz la lb b">clone_repo</code></p><h2 id="93f0" class="li jd if bd je lj lk ll ji lm ln lo jm kl lp lq jq kp lr ls ju kt lt lu jy lv dt translated">使自动化</h2><figure class="nc nd ne nf fq hw"><div class="bz el l di"><div class="ng nh l"/></div></figure><h1 id="5d1f" class="jc jd if bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">有用的别名</h1><p id="3f33" class="pw-post-body-paragraph ka kb if kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">我想问我的读者几个问题，希望你诚实地回答。您多久使用一次这个命令？<br/>T10】</p><p id="23dc" class="pw-post-body-paragraph ka kb if kc b kd lc kf kg kh ld kj kk kl le kn ko kp lf kr ks kt lg kv kw kx hn dt translated">这个命令呢？<br/> <code class="eh ky kz la lb b">git status</code></p><p id="2de5" class="pw-post-body-paragraph ka kb if kc b kd lc kf kg kh ld kj kk kl le kn ko kp lf kr ks kt lg kv kw kx hn dt translated">这个呢？<br/> <code class="eh ky kz la lb b">git push origin &lt;branch-name&gt;</code></p><p id="af4d" class="pw-post-body-paragraph ka kb if kc b kd lc kf kg kh ld kj kk kl le kn ko kp lf kr ks kt lg kv kw kx hn dt translated">你经常用这个吗？<br/> <code class="eh ky kz la lb b">ps aux | grep &lt;user-name&gt;</code></p><p id="67b5" class="pw-post-body-paragraph ka kb if kc b kd lc kf kg kh ld kj kk kl le kn ko kp lf kr ks kt lg kv kw kx hn dt translated">这个列表可以扩展，很可能每个人都有他/她经常使用的命令。因此，您可能会突然想到，对于所有这些命令，创建别名是一个明智的想法。</p><figure class="nc nd ne nf fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nu"><img src="../Images/49f39b44ad4662436d72f55db327c183.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qho7T74ivpZyc5Ftb4NTDw.jpeg"/></div></div></figure><p id="3cc7" class="pw-post-body-paragraph ka kb if kc b kd lc kf kg kh ld kj kk kl le kn ko kp lf kr ks kt lg kv kw kx hn dt translated">在下面的列表中，你会发现一些我日常使用的别名:</p><figure class="nc nd ne nf fq hw"><div class="bz el l di"><div class="ng nh l"/></div></figure><p id="8976" class="pw-post-body-paragraph ka kb if kc b kd lc kf kg kh ld kj kk kl le kn ko kp lf kr ks kt lg kv kw kx hn dt translated">为了检查已经设置了哪些别名，您想要运行命令<code class="eh ky kz la lb b">alias</code>，但是没有特定的参数。</p><h2 id="69d1" class="li jd if bd je lj lk ll ji lm ln lo jm kl lp lq jq kp lr ls ju kt lt lu jy lv dt translated">存储别名的位置</h2><p id="ed76" class="pw-post-body-paragraph ka kb if kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">要创建永久别名，请将其添加到用户主目录(<code class="eh ky kz la lb b">~</code>)下的<code class="eh ky kz la lb b">.bashrc</code>文件中。您也可以将其添加到<code class="eh ky kz la lb b">.gitconfig</code>文件中，以便使用<code class="eh ky kz la lb b">git</code>。</p><h2 id="24eb" class="li jd if bd je lj lk ll ji lm ln lo jm kl lp lq jq kp lr ls ju kt lt lu jy lv dt translated">不要深夜改化名</h2><p id="e6de" class="pw-post-body-paragraph ka kb if kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">别名是一个强大的工具。然而，这里所有的密码。</p><blockquote class="mn"><p id="11f0" class="mo mp if bd mq mr nk nl nm nn no kx ek translated">睡觉前不要改化名。</p></blockquote><p id="9a3c" class="pw-post-body-paragraph ka kb if kc b kd np kf kg kh nq kj kk kl nr kn ko kp ns kr ks kt nt kv kw kx hn dt translated">我确实碰巧在深夜换了一个。接下来发生了什么你可以猜到。我不记得我做过，我花了一天的大部分时间试图找出为什么没有工作。</p><h1 id="46a5" class="jc jd if bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">最后</h1><p id="8817" class="pw-post-body-paragraph ka kb if kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">当我刚进入<code class="eh ky kz la lb b">bash</code>的原理时，我的第一个想法是:“停，它们不就是系统管理员需要的吗？”。然而，我确实明白这一知识的重要性，它能让我减轻日常事务的负担。今天，我可以自信地说，如果你的工作与远程服务器或<code class="eh ky kz la lb b">OS *nix</code>有关，或者你与<code class="eh ky kz la lb b">Windows OS</code>(<a class="ae lh" href="https://blogs.msdn.microsoft.com/commandline/2016/04/06/bash-on-ubuntu-on-windows-download-now-3/" rel="noopener ugc nofollow" target="_blank">Bash on Ubuntu on Windows</a>、<a class="ae lh" href="https://blogs.msdn.microsoft.com/wsl/2016/10/19/windows-and-ubuntu-interoperability/" rel="noopener ugc nofollow" target="_blank"> Windows和Ubuntu Interoperability </a>)一起工作，那么对<code class="eh ky kz la lb b">bash</code>原理的了解和理解将会非常有用。</p><blockquote class="mn"><p id="8a93" class="mo mp if bd mq mr nk nl nm nn no kx ek translated">简单地说，脚本只不过是系统命令的基本列表，全部写在一个文件中。</p></blockquote><p id="0dfa" class="pw-post-body-paragraph ka kb if kc b kd np kf kg kh nq kj kk kl nr kn ko kp ns kr ks kt nt kv kw kx hn dt translated">不过，使用这个文件可以简化许多例行任务的执行，否则，您需要手动完成这些任务。</p><p id="27a7" class="pw-post-body-paragraph ka kb if kc b kd lc kf kg kh ld kj kk kl le kn ko kp lf kr ks kt lg kv kw kx hn dt translated">这里有一些与<code class="eh ky kz la lb b">bash</code>功能相关的链接，其中一些我已经在我的例子中展示过了:</p><ol class=""><li id="f61c" class="lw lx if kc b kd lc kh ld kl mk kp ml kt mm kx mb mc md me dt translated"><a class="ae lh" href="http://tldp.org/LDP/abs/html/io-redirection.html" rel="noopener ugc nofollow" target="_blank">输入/输出重定向</a></li><li id="8582" class="lw lx if kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated"><a class="ae lh" href="http://tldp.org/LDP/abs/html/functions.html" rel="noopener ugc nofollow" target="_blank">功能</a></li><li id="2c67" class="lw lx if kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated"><a class="ae lh" href="http://tldp.org/LDP/abs/html/arrays.html" rel="noopener ugc nofollow" target="_blank">数组</a></li><li id="04f7" class="lw lx if kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated"><a class="ae lh" href="http://tldp.org/LDP/abs/html/dblparens.html#CVARS" rel="noopener ugc nofollow" target="_blank">双括号结构</a></li><li id="db52" class="lw lx if kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated"><a class="ae lh" href="http://tldp.org/LDP/abs/html/special-chars.html" rel="noopener ugc nofollow" target="_blank">特殊字符(管道)</a></li><li id="d055" class="lw lx if kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated"><a class="ae lh" href="http://tldp.org/LDP/abs/html/exit-status.html" rel="noopener ugc nofollow" target="_blank">退出和退出状态</a></li><li id="4081" class="lw lx if kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated"><a class="ae lh" href="http://tldp.org/LDP/abs/html/aliases.html" rel="noopener ugc nofollow" target="_blank">别名</a></li><li id="0ac2" class="lw lx if kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated"><a class="ae lh" href="http://unix.stackexchange.com/questions/26047/how-to-correctly-add-a-path-to-path" rel="noopener ugc nofollow" target="_blank">如何给$PATH变量添加路径</a></li></ol><p id="d97a" class="pw-post-body-paragraph ka kb if kc b kd lc kf kg kh ld kj kk kl le kn ko kp lf kr ks kt lg kv kw kx hn dt translated">就是这样。感谢您的关注，特别感谢那些把文章读完的人。</p><div class="nc nd ne nf fq ab cb"><figure class="nv hw nw nx ny nz oa paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nv hw nw nx ny nz oa paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nv hw nw nx ny nz oa paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ob oc od"><p id="f922" class="ka kb oe kc b kd lc kf kg kh ld kj kk of le kn ko og lf kr ks oh lg kv kw kx hn dt translated"><a class="ae lh" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae lh" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae lh" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae lh" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ka kb oe kc b kd lc kf kg kh ld kj kk of le kn ko og lf kr ks oh lg kv kw kx hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lh" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lh" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="nc nd ne nf fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff oi"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>