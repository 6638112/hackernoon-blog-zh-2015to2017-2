<html>
<head>
<title>How to Read and Write (with Monads!)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何读写(用单子！)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-read-and-write-with-monads-7b24495754bc?source=collection_archive---------18-----------------------#2017-02-27">https://medium.com/hackernoon/how-to-read-and-write-with-monads-7b24495754bc?source=collection_archive---------18-----------------------#2017-02-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="978c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本文原载于2017年2月20日的<a class="ae jp" href="https://mmhaskell.com/blog/2017/2/20/how-to-read-and-write-with-monads" rel="noopener ugc nofollow" target="_blank">周一早间哈斯克尔博客</a>。查看博客获取更多Haskell内容！</p><p id="f1c6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上周我们讨论了单子是什么。这不是只有拥有范畴理论神秘知识的巫师才能理解的可怕事情。它只是一个<strong class="it hv">类型的类</strong>，带有几个描述特定上下文的函数。这些函数，当正确使用时，可以极大地扩展我们的功能，同时保持代码的纯粹功能性。</p><p id="8cfe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还没有讨论这些函数需要遵循的所有“法则”。但是如果我们探索足够多的例子，我们会对应该发生什么有一个直观的理解。上次我们看到了一些简单的例子，有<code class="eh jq jr js jt b">Maybe</code>、<code class="eh jq jr js jt b">Either</code>和<code class="eh jq jr js jt b">IO</code>单子。在本文中，我们将看看<code class="eh jq jr js jt b">Reader</code>和<code class="eh jq jr js jt b">Writer</code>单子。</p><h1 id="1749" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">全局变量(或缺少全局变量)</h1><p id="5188" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">在Haskell中，我们的代码通常是“纯”的，这意味着函数只能与传递给它们的参数进行交互。这实际上意味着我们不能有全局变量。我们可以有全局表达式，但这些表达式在编译时是固定的。如果用户行为可能改变它们，我们必须将它们包装在<code class="eh jq jr js jt b">IO</code>单子中，这意味着它们不能在纯代码中使用。</p><p id="73c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">考虑这个例子，我们可能想要一个包含不同参数的<code class="eh jq jr js jt b">Environment</code>作为全局变量。然而，我们可能不得不从一个配置文件或命令行界面加载这些，这需要<code class="eh jq jr js jt b">IO</code> monad。</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="d98a" class="lf jv hu jt b fv lg lh l li lj">main :: IO ()<br/>main = do<br/>  env &lt;- loadEnv<br/>  let str = func1 env<br/>  print str</span><span id="4451" class="lf jv hu jt b fv lk lh l li lj">data Environment = Environment<br/>  { param1 :: String<br/>  , param2 :: String<br/>  , param3 :: String }</span><span id="2db2" class="lf jv hu jt b fv lk lh l li lj">loadEnv :: IO Environment<br/>loadEnv = …</span><span id="f2fa" class="lf jv hu jt b fv lk lh l li lj">func1 :: Environment -&gt; String<br/>func1 env = “Result: “ ++ (show (func2 env))</span><span id="9607" class="lf jv hu jt b fv lk lh l li lj">func2 :: Environment -&gt; Int<br/>func2 env = 2 + floor (func3 env)</span><span id="d2f0" class="lf jv hu jt b fv lk lh l li lj">func3 :: Environment -&gt; Float<br/>func3 env = … -- Some calculation based on the environment</span></pre><p id="c815" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">实际使用环境的唯一函数<strong class="it hv">是<code class="eh jq jr js jt b">func3</code>。然而<code class="eh jq jr js jt b">func3</code>是一个不纯的函数。这意味着它不能直接调用<code class="eh jq jr js jt b">loadEnv</code>，一个不纯的函数。这意味着环境必须作为变量传递给其他函数，这样它们才能最终将它传递给<code class="eh jq jr js jt b">func3</code>。在有全局变量的语言中，我们可以将<code class="eh jq jr js jt b">env</code>保存为<code class="eh jq jr js jt b">main</code>中的全局值。然后<code class="eh jq jr js jt b">func3</code>可以直接访问它。就不需要将它作为<code class="eh jq jr js jt b">func1</code>和<code class="eh jq jr js jt b">func2</code>的参数。在较大的程序中，这些“传递”变量会导致很多令人头疼的问题。</strong></p><h1 id="30b0" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">读者解决方案</h1><p id="6124" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">阅读器monad解决了这个问题。它有效地创建了一个指定类型的全局只读值。monad中的所有函数都可以“读取”该类型。让我们看看<code class="eh jq jr js jt b">Reader</code>单子如何改变我们代码的形状。我们的函数<strong class="it hv">不再需要</strong>的<code class="eh jq jr js jt b">Environment</code>作为<strong class="it hv">的显式参数</strong>，因为它们可以通过单子访问它。</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="7893" class="lf jv hu jt b fv lg lh l li lj">main :: IO ()<br/>main = do<br/>  env &lt;- loadEnv<br/>  let str = runReader func1 env<br/>  print str</span><span id="f5b7" class="lf jv hu jt b fv lk lh l li lj">data Environment = Environment<br/>  { param1 :: String<br/>  , param2 :: String<br/>  , param3 :: String }</span><span id="29f2" class="lf jv hu jt b fv lk lh l li lj">loadEnv :: IO Environment<br/>loadEnv = …</span><span id="e0f3" class="lf jv hu jt b fv lk lh l li lj">func1 :: Reader Environment String<br/>func1 = do<br/>  res &lt;- func2<br/>  return (“Result: “ ++ (show res))</span><span id="aae8" class="lf jv hu jt b fv lk lh l li lj">func2 :: Reader Environment Int<br/>func2 = do<br/>  env &lt;- ask<br/>  let res3 = func3 env<br/>  return (2 + (floor res3))</span><span id="bd5e" class="lf jv hu jt b fv lk lh l li lj">func3 :: Environment -&gt; Float<br/>...</span></pre><p id="984f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jq jr js jt b">ask</code>功能<strong class="it hv">打开环境</strong>以便我们可以使用它。单子的绑定动作允许我们将不同的<code class="eh jq jr js jt b">Reader</code>动作粘在一起。为了从纯代码中调用阅读器动作，我们需要做的就是调用<code class="eh jq jr js jt b">runReader</code>函数并提供环境作为参数。动作中的所有函数都能够像对待一个全局变量一样对待它。</p><p id="dff0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">看起来我们似乎没有完成多少，但是我们的代码现在更加直观了。我们保持现状。将它描述为从一个<code class="eh jq jr js jt b">Environment</code>到一个值的函数是有意义的。然而，我们的其他两个函数不再将环境作为显式参数。它们只是存在于<strong class="it hv">上下文</strong>中，其中<strong class="it hv">环境是一个全局变量</strong>。</p><h1 id="df24" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">累积值</h1><p id="0695" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">现在，为了激励作家莫纳德，我们来谈谈积累问题。假设我们有几个不同的函数。每一个都将执行一些我们指定了任意“成本”的字符串操作。我们希望跟踪运行完整计算的“代价”有多高。我们可以通过使用<strong class="it hv">累加器参数</strong>来跟踪到目前为止我们看到的成本。然后我们继续传递累积的值。</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="95f7" class="lf jv hu jt b fv lg lh l li lj">-- Calls func2 if even length, func3 and func4 if odd<br/>func1 :: String -&gt; (Int, String)<br/>func1 input = if length input `mod` 2 == 0<br/>  then func2 (0, input)<br/>  else (i1 + i2, str1 ++ str2)<br/>    where<br/>      (i1, str1) = func3 (0, tail input)<br/>      (i2, str2) = func4 (0, take 1 input)</span><span id="3bb5" class="lf jv hu jt b fv lk lh l li lj">-- Calls func4 on truncated version<br/>func2 :: (Int, String) -&gt; (Int, String)<br/>func2 (prev, input) = if (length input) &gt; 10<br/>  then func4 (prev + 1, take 9 input)<br/>  else (10, input)</span><span id="a78e" class="lf jv hu jt b fv lk lh l li lj">-- Calls func2 on expanded version if a multiple of 3<br/>func3 :: (Int, String) -&gt; (Int, String)<br/>func3 (prev, input) = if (length input) `mod` 3 == 0<br/>  then (prev + f2resI + 3, f2resStr)<br/>  else (prev + 1, tail input)<br/>  where<br/>    (f2resI, f2resStr) = func2 (prev, input ++ "ab")</span><span id="84c9" class="lf jv hu jt b fv lk lh l li lj">func4 :: (Int, String) -&gt; (Int, String)<br/>func4 (prev, input) = if (length input) &lt; 10<br/>  then (prev + length input, input ++ input)<br/>  else (prev + 5, take 5 input)</span></pre><p id="bcfb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，<code class="eh jq jr js jt b">Int</code>并不是我们可以积累的唯一类型的值。相反，我们可以累积一个字符串列表，作为日志消息打印出来，这样我们就知道运行了什么计算。这种行为有一个<strong class="it hv">概括:<code class="eh jq jr js jt b">Monoid</code>类型类。</strong></p><h1 id="9b1c" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">幺半群类型类</h1><p id="468d" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">在这个例子中，<code class="eh jq jr js jt b">Int</code>是幺半群的一个简单例子。让我们看看幺半群类型类的定义:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="273a" class="lf jv hu jt b fv lg lh l li lj">class Monoid a where<br/>  mempty :: a<br/>  mappend :: a -&gt; a -&gt; a</span></pre><p id="e981" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这实际上是一个<strong class="it hv">累积类</strong>。它定义了两个功能。<code class="eh jq jr js jt b">mempty</code>函数是我们幺半群的初始值。然后用<code class="eh jq jr js jt b">mappend</code>，我们可以把这种类型的两个值合并成一个结果。如何为<code class="eh jq jr js jt b">Int</code>创建一个幺半群实例非常简单:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="892d" class="lf jv hu jt b fv lg lh l li lj">instance Monoid Int where<br/>  memty = 0<br/>  mappend a b = a + b</span></pre><p id="2320" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的累加器从0开始，通过相加来组合值。</p><h1 id="580f" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">使用Writer跟踪累加器</h1><p id="e683" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">单子由某个单子类型参数化。它的主要工作是记录这种类型的累计值。因此，它的运营生活在拥有一个全局值的环境中，他们可以以这种特定的方式进行修改。我们可以修改上面的代码示例，使用如下的<code class="eh jq jr js jt b">Writer</code>单子:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="3ba5" class="lf jv hu jt b fv lg lh l li lj">func1 :: String -&gt; (String, Int)<br/>func1 input = if length input `mod` 2 == 0<br/>  then runWriter (func2 input)<br/>  else runWriter $ do<br/>    str1 &lt;- func3 input<br/>    str2 &lt;- func4 (take 1 input)<br/>    return (str1 ++ str2)</span><span id="c72d" class="lf jv hu jt b fv lk lh l li lj">func2 :: String -&gt; Writer Int String<br/>func2 input = if (length input) &gt; 10<br/>  then do<br/>    tell 1<br/>    func4 (take 9 input)<br/>  else do<br/>    tell 10<br/>    return input</span><span id="69eb" class="lf jv hu jt b fv lk lh l li lj">func3 :: String -&gt; Writer Int String<br/>func3 input = if (length input) `mod` 3 == 0<br/>  then do<br/>    tell 3<br/>    func2 (input ++ “ab”)<br/>  else do<br/>    tell 1<br/>    return $ tail input</span><span id="ff93" class="lf jv hu jt b fv lk lh l li lj">func4 :: String -&gt; Writer Int String<br/>func4 input = if (length input) &lt; 10<br/>  then do<br/>    tell (length input)<br/>    return (input ++ input)<br/>  else do<br/>    tell 5<br/>    return (take 5 input)</span></pre><p id="cc29" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，我们不再需要实际上<strong class="it hv">明确跟踪累加器的</strong>。它现在被<code class="eh jq jr js jt b">Writer</code>单子包裹着。我们可以通过调用“tell”在我们的任何函数中增加它。现在我们的代码更简单，类型更干净。</p><h1 id="35b7" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">结论</h1><p id="42c0" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">读者和作者单子都提供<strong class="it hv">纯函数方式</strong>来处理<strong class="it hv">常见副作用</strong>。读取器允许你跟踪一个共享的全局状态。它允许您避免将该状态作为显式参数传递给并不真正使用它的函数。<strong class="it hv">作者</strong> monad允许你用一个幺半群来跟踪一个全局累计值。如果你想知道如何将这些想法结合在一起，那就去周一早上哈斯克尔的博客看看那里关于<a class="ae jp" href="https://www.mmhaskell.com/2017/2/27/the-monadic-state-of-mind" rel="noopener ugc nofollow" target="_blank">州单子</a>的最新文章吧！</p><p id="7f56" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">希望这篇文章有助于让您相信单子(以及Haskell)并不那么可怕！如果这启发了你拿起Haskell并开始写一些代码，检查一下我们免费的清单<a class="ae jp" href="https://www.mmhaskell.com/checklist" rel="noopener ugc nofollow" target="_blank">来获得陈述！</a></p><p id="7251" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还没有为单子做好准备，但想尝试一些不同的Haskell技能？查看我们的<a class="ae jp" href="https://www.mmhaskell.com/workbook" rel="noopener ugc nofollow" target="_blank">递归工作簿</a>。它包括2章关于递归和高阶函数的内容，以及10个测试练习题。</p><div class="kx ky kz la fq ab cb"><figure class="ll lm ln lo lp lq lr paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="ll lm ln lo lp lq lr paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="ll lm ln lo lp lq lr paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="lu lv lw"><p id="f922" class="ir is lx it b iu iv iw ix iy iz ja jb ly jd je jf lz jh ji jj ma jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is lx it b iu iv iw ix iy iz ja jb ly jd je jf lz jh ji jj ma jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kx ky kz la fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="fe ff mb"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>