<html>
<head>
<title>Replacing the angular 1 router with Elm — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Elm替换angular 1路由器—第1部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/replacing-the-angular-1-router-with-elm-d71753e74e32?source=collection_archive---------12-----------------------#2017-01-10">https://medium.com/hackernoon/replacing-the-angular-1-router-with-elm-d71753e74e32?source=collection_archive---------12-----------------------#2017-01-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="e663" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您正试图从angular 1迁移出去(并且您对angular 2不感兴趣),似乎您有两个选择:您可以尝试替换单个组件并从内到外吃掉angular，或者您可以通过首先替换路由器来尝试从外到内吃掉它。</p><p id="6d42" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我对尝试从angular 1路由器下面出来很感兴趣，所以我真的想选择后者。这使我开始把angular 1仅仅作为一种呈现组件的方式，而不是一个负责所有事情的框架。</p><p id="a29e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我最感兴趣的技术是Elm，我受到了Richard Feldman关于Elm中Web组件的演讲的启发，在我看来，我们应该能够用angular 1组件/指令实现类似的东西。</p><p id="6404" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用Elm的Html中的“node”函数来呈现角度指令是很简单的。属性模块；问题是它不会做任何事情，除非angular框架知道它已经被添加到DOM中，并有机会编译它。</p><p id="c520" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，假设我有以下角度分量:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="c295" class="jz ka hu jv b fv kb kc l kd ke">angular.module('MyApp', [])<br/>    .component('pageOne', {<br/>    template: '&lt;div&gt;Page One&lt;/div&gt;',<br/>    controller: function PageOneController () {<br/>        console.log('we are in page one');<br/>    }<br/>});</span></pre><p id="8467" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我可以这样从Elm渲染这个:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="4c37" class="jz ka hu jv b fv kb kc l kd ke">node "page-one" [] []</span></pre><p id="f81d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但这对我没有好处，因为angular对此一无所知。我们需要告诉angular这件事。</p><p id="5e6f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然，Elm正在发出虚拟DOM，我们没有明显的方法知道真实DOM何时被更新。</p><h1 id="1442" class="kf ka hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">突变观察者</h1><p id="4039" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">因此，使用客户端路由解决方案，当路由改变时，我们可以有效地在单个根节点内外交换内容。我们可以使用一个变异观察器来监控根节点，然后在发生变化时指示angular编译内容。</p><p id="9984" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">大概是这样的:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="9b97" class="jz ka hu jv b fv kb kc l kd ke">var root = document.getElementById('root');<br/>var observer = new MutationObserver(triggerDigest);<br/>observer.observe(root, { childList: true, subtree: true });</span><span id="8f85" class="jz ka hu jv b fv lh kc l kd ke">function triggerDigest() {<br/>    var $body = angular.element(document.body);            <br/>    var $rootScope = $body.injector().get('$rootScope');  <br/>    var $compile = $body.injector().get('$compile');<br/>    $rootScope.$apply(function() {<br/>        $compile($body)($rootScope);<br/>    });<br/>}</span></pre><p id="d00c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，这里我们获得了一个对根元素的引用，我们将在其中嵌入Elm应用程序。我们创建了一个突变观察器，它将调用一个triggerDigest函数。该函数获取对angular的$rootScope及其$compile服务的引用。然后，它根据根范围编译整个树。</p><h1 id="33b3" class="kf ka hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">无限循环</h1><p id="ba28" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">但是我们有一个问题。目前，我们正在监视整个子树，编译angular指令将导致更多的变异，并触发另一次编译。这将导致编译和变异的无限循环，并杀死页面。</p><p id="aae4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个解决方案是让Elm告诉我们什么时候应该开始观察，然后在我们完成编译后就停止观察。这可以使用端口来完成。我们可以像这样在Elm中创建一个出站端口:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="3d57" class="jz ka hu jv b fv kb kc l kd ke">port watchDom : String -&gt; Cmd msg</span></pre><p id="4d15" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，当url发生变化时，我们需要向该端口发送一条消息:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="f3ca" class="jz ka hu jv b fv kb kc l kd ke">update : Msg -&gt; Model -&gt; ( Model, Cmd Msg )<br/>update msg model =<br/>    case msg of<br/>        UrlChange location -&gt;<br/>            ( { model | route = Url.parsePath route location }<br/>            , <strong class="jv hv">(watchDom "")</strong><br/>            )</span></pre><p id="f037" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，我们可以如下修改我们的javascript:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="73d2" class="jz ka hu jv b fv kb kc l kd ke">var root = document.getElementById('root');<br/><strong class="jv hv">var app = Elm.Main.embed(root);</strong><br/>var observer = new MutationObserver(triggerDigest);</span><span id="b075" class="jz ka hu jv b fv lh kc l kd ke"><strong class="jv hv">app.ports.watchDom.subscribe(function(msg) {<br/>    observer.observe(root, { childList: true, subtree: true });<br/>});</strong></span><span id="ba2f" class="jz ka hu jv b fv lh kc l kd ke">function triggerDigest() {<br/>    var $body = angular.element(document.body);            <br/>    var $rootScope = $body.injector().get('$rootScope');  <br/>    var $compile = $body.injector().get('$compile');<br/>    $rootScope.$apply(function() {<br/>        $compile($body)($rootScope);<br/>    });<br/>    <strong class="jv hv">observer.disconnect();</strong><br/>}</span></pre><p id="81fa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将打破我们的循环，给我们一个可行的解决方案的开端。不知道它的效率有多高，但至少看起来是有效的。</p><p id="3763" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以这种方式使用端口的一个警告是，这意味着0.18调试器将无法正常工作。通过包装“history.pushState”函数并跟踪“popstate”事件，可以避免使用端口。端口的一个优点是，它允许我们提供一些关于我们要导航到的路线的元数据，例如，它是否包含需要编译的内容。</p><h1 id="187f" class="kf ka hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">还有一个问题</h1><p id="a4e0" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">在第二部分中，我将探索如何处理内部角度链接。</p><p id="f413" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个概念证明的完整源代码可以在<a class="ae jp" href="https://github.com/travelrepublic/elm-angular-router" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div></div>    
</body>
</html>