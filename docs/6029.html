<html>
<head>
<title>Tips and tricks for logging and monitoring AWS Lambda functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">记录和监控AWS Lambda函数的提示和技巧</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/tips-and-tricks-for-logging-and-monitoring-aws-lambda-functions-885af6da29a5?source=collection_archive---------3-----------------------#2017-08-30">https://medium.com/hackernoon/tips-and-tricks-for-logging-and-monitoring-aws-lambda-functions-885af6da29a5?source=collection_archive---------3-----------------------#2017-08-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="73bf" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">使用代理/守护进程来缓冲和批量发送日志和指标的常见做法在无服务器的世界中不再适用。这里有一些技巧可以帮助您最大限度地利用日志记录和监控基础设施来实现您的功能。</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/e57805424dfdba56cba18b5d6ad93f15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tt-wAtUt2_3beiH_CrD1Yg.png"/></div></div></figure><p id="578f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这是关于管理AWS Lambda日志的3部分迷你系列的第2部分。</p><p id="d486" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果你还没有读过第一部分，请现在读一读。我们将在这篇文章中详细描述的CloudWatch日志的基础设施之上构建日志。</p><p id="35bd" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">第一部分:</strong> <a class="ae kr" rel="noopener" href="/@theburningmonk/centralised-logging-for-aws-lambda-b765b7ca9152">集中伐木</a></p><p id="c48b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">第三部分:</strong> <a class="ae kr" rel="noopener" href="/@theburningmonk/capture-and-forward-correlation-ids-through-different-lambda-event-sources-220c227c65f5">跟踪关联id</a></p><h1 id="fb33" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">新范式，新问题</h1><p id="f20c" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">无服务器模式改变了很多，它解决了我们面临的许多老问题，并用一些(我认为)更容易处理的新问题取代了它们。</p><p id="c3f6" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">因此，许多旧的实践不再适用，例如，使用代理/守护程序缓冲和批量发送指标和日志到监控和日志聚合服务。然而，即使我们为了无服务器的新世界抛弃了这些旧的实践，我们仍然在追求使我们的旧工具“好”的相同品质:</p><ol class=""><li id="259e" class="lp lq hu jx b jy jz kb kc ke lr ki ls km lt kq lu lv lw lx dt translated">能够收集丰富的系统和应用程序指标和日志</li><li id="63fe" class="lp lq hu jx b jy ly kb lz ke ma ki mb km mc kq lu lv lw lx dt translated">发布指标和日志不应增加面向用户的延迟(即它们应该在后台执行)</li><li id="22f6" class="lp lq hu jx b jy ly kb lz ke ma ki mb km mc kq lu lv lw lx dt translated">度量和日志应该实时出现(即几秒钟内)</li><li id="4140" class="lp lq hu jx b jy ly kb lz ke ma ki mb km mc kq lu lv lw lx dt translated">衡量标准应该是精细的</li></ol><p id="0e37" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">不幸的是，Lambda的当前工具——cloud watch metrics和cloud watch Logs——在其中一些问题上失败了，有些问题比其他问题更严重:</p><ul class=""><li id="b125" class="lp lq hu jx b jy jz kb kc ke lr ki ls km lt kq md lv lw lx dt translated">发布定制指标需要在函数执行期间进行额外的网络调用，<strong class="jx hv">增加了面向用户的延迟</strong></li><li id="aeb8" class="lp lq hu jx b jy ly kb lz ke ma ki mb km mc kq md lv lw lx dt translated">AWS服务的CloudWatch指标只能精确到1分钟的时间间隔(自定义指标可以精确到1秒<a class="ae kr" href="https://aws.amazon.com/about-aws/whats-new/2017/07/amazon-cloudwatch-introduces-high-resolution-custom-metrics-and-alarms/" rel="noopener ugc nofollow" target="_blank"/></li><li id="370d" class="lp lq hu jx b jy ly kb lz ke ma ki mb km mc kq md lv lw lx dt translated">CloudWatch指标通常会落后几分钟(尽管自定义指标可能会有更少的延迟，因为它们可以以1秒的间隔记录)</li><li id="2d4a" class="lp lq hu jx b jy ly kb lz ke ma ki mb km mc kq md lv lw lx dt translated">CloudWatch日志通常落后10s以上(不是精确测量，而是基于个人观察)</li></ul><p id="cc65" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">有了Lambda，我们必须依靠AWS来改进CloudWatch，以便让我们与现有的“全服务器”服务平起平坐。</p><p id="54ce" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">很多厂商都宣布支持Lambda，比如<a class="ae kr" href="https://www.datadoghq.com/blog/monitoring-lambda-functions-datadog/" rel="noopener ugc nofollow" target="_blank"> Datadog </a>和<a class="ae kr" href="https://www.wavefront.com/serverless-automatic-rollbacks-wavefront/" rel="noopener ugc nofollow" target="_blank"> Wavefront </a>。然而，由于他们使用的是来自CloudWatch的相同指标，因此会有相同的延迟。</p><p id="78a5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><a class="ae kr" href="https://www.iopipe.com/" rel="noopener ugc nofollow" target="_blank"> IOPipe </a>是监控Lambda函数的一个流行的替代方案，它们做的事情略有不同——通过给你一个围绕你的代码的包装函数，这样它们可以注入监控代码(对于过去使用过AOP框架的人来说，这是一个熟悉的模式)。</p><p id="983a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">对于他们的1.0版本，他们还宣布支持跟踪(见下面的演示视频)，我认为这很有趣，因为AWS已经提供了X射线，这是一个更完整的跟踪解决方案(尽管它有自己的缺点，正如我在<a class="ae kr" href="https://read.acloud.guru/im-here-to-tell-you-the-truth-the-good-the-bad-and-the-ugly-of-aws-x-ray-and-lambda-f212b5f332e9" rel="noopener ugc nofollow" target="_blank">这篇文章</a>中提到的)。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff me"><img src="../Images/8e30aea4f9c102eadc4d9c2b9bb813cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2TMll0rxo-G9iCWbqJwFZw.png"/></div></div></figure><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="2a4d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">IOPipe似乎是CloudWatch的一个可行替代方案，尤其是如果你是AWS Lambda的新手，并且只想快速入门的话。我完全明白这种简单的价值。</p><p id="40ef" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">然而，我对IOPipe的方法有一些严重的保留意见:</p><ul class=""><li id="bb72" class="lp lq hu jx b jy jz kb kc ke lr ki ls km lt kq md lv lw lx dt translated">包装我的每一个函数？对我的整个应用程序的这种无孔不入的访问需要大量的信任，尤其是在像这样的时候。</li><li id="a93f" class="lp lq hu jx b jy ly kb lz ke ma ki mb km mc kq md lv lw lx dt translated">CloudWatch异步收集日志和指标，不会增加我的函数的执行时间。但是使用IOPipe，他们必须将指标发送到他们自己的系统，并且他们必须在我的函数执行期间这样做，因此<strong class="jx hv">增加了面向用户的延迟</strong>(对于API)。</li><li id="d5c0" class="lp lq hu jx b jy ly kb lz ke ma ki mb km mc kq md lv lw lx dt translated">除了以上几点之外，即使在我的代码成功执行之后，还有一件事可能导致我的函数出错或超时。也许他们正在做一些聪明的事情来最小化风险，但我很难确定，我必须预见到失败。</li></ul><p id="8ea5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在上述所有因素中，延迟开销是我最关心的问题。在API网关和Lambda之间，我已经不得不处理冷启动和API网关和Lambda之间的延迟。随着您的微服务架构的扩展和服务间通信数量的增加，这些延迟将进一步增加。</p><p id="0207" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">对于后台任务来说，这不是一个大问题，但是我编写的Lambda函数中有相当大一部分必须处理HTTP请求，我需要尽可能降低这些函数的执行时间。</p><div class="mh mi fm fo mj mk"><a rel="noopener follow" target="_blank" href="/@theburningmonk/yubls-road-to-serverless-part-1-overview-ca348370acde"><div class="ml ab ej"><div class="mm ab mn cl cj mo"><h2 class="bd hv fv z el mp eo ep mq er et ht dt translated">Yubl的无服务器之路—第1部分，概述</h2><div class="mr l"><h3 class="bd b fv z el mp eo ep mq er et ek translated">这条路到此为止</h3></div><div class="ms l"><p class="bd b gc z el mp eo ep mq er et ek translated">medium.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my jt mk"/></div></div></a></div><h1 id="f9a9" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">异步发送自定义指标</h1><p id="bad8" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">我发现Datadog发送定制指标的方法非常有趣。本质上，您将自定义指标编写为Datadog将处理的特殊格式的日志消息(您必须为CloudWatch设置IAM权限以调用它们的函数),并将它们作为指标进行跟踪。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mz"><img src="../Images/36ed1e1d07d5a0785951d6a5f3d5c13d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YCMOIMDBuJqW7LC30y_5oA.png"/></div></div><figcaption class="na nb fg fe ff nc nd bd b be z ek">Datadog allows you to send custom metrics using log messages in their DogStatsD format.</figcaption></figure><p id="b130" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这是一种简单而优雅的方法，即使我们决定使用另一种监控服务，我们也可以自己采用这种方法。</p><p id="2e19" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在第1部分中，我们建立了一个基础设施，将日志从CloudWatch日志传送到我们选择的日志聚合服务。我们可以扩展日志传送功能来查找如下所示的日志消息:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ne"><img src="../Images/b297d885ff29515195985b2e54dc7252.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wFfwPZTULJIo3NwH6H1hTg.png"/></div></div><figcaption class="na nb fg fe ff nc nd bd b be z ek">Log custom metrics as specially formatted log messages</figcaption></figure><p id="b87e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">对于这些日志消息，我们将其解释为:</p><pre class="jk jl jm jn fq nf ng nh ni aw nj dt"><span id="c894" class="nk kt hu ng b fv nl nm l nn no">MONITORING|metric_value|metric_unit|metric_name|metric_namespace</span></pre><p id="5c69" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们不会将它们发送给日志聚合服务，而是将它们作为指标发送给我们的监控服务。在这个例子中，我在演示中使用了CloudWatch(见下面的链接)，所以日志消息的格式反映了我需要在<a class="ae kr" href="http://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_PutMetricData.html" rel="noopener ugc nofollow" target="_blank"> PutMetricData </a>调用中传递的字段。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff np"><img src="../Images/745ef77efad8bd2e10ff5ba716ff0188.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-nqcPOV24jJNzs76Q3s5Jg.png"/></div></div></figure><p id="77e3" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">为了发送自定义指标，我们将它们作为日志消息写入。同样，<strong class="jx hv">没有延迟开销</strong>因为Lambda服务为我们收集这些，并在后台将它们发送到CloudWatch。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nq"><img src="../Images/ca8a6b8382f641b8afd54ba5d52f5983.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B0YzfArILXYiJ67z39b3Hw.png"/></div></div></figure><p id="8d4e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">片刻之后，它们就出现在CloudWatch metrics中。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nr"><img src="../Images/62a3fbf85d91e9e94904ccce86b3cdff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vqu3YsMDM_uOU2k7fONBOA.png"/></div></div><figcaption class="na nb fg fe ff nc nd bd b be z ek">Custom metrics are recorded in CloudWatch as expected.</figcaption></figure><p id="089d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">看看这个<a class="ae kr" href="https://github.com/theburningmonk/lambda-logging-metrics-demo" rel="noopener ugc nofollow" target="_blank">回购</a>中的<code class="eh ns nt nu ng b">custom-metrics</code>函数。</p><div class="mh mi fm fo mj mk"><a href="https://github.com/theburningmonk/lambda-logging-metrics-demo" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab ej"><div class="mm ab mn cl cj mo"><h2 class="bd hv fv z el mp eo ep mq er et ht dt translated">burning monk/lambda-记录-指标-演示</h2><div class="mr l"><h3 class="bd b fv z el mp eo ep mq er et ek translated">lambda-logging-metrics-demo -如何应用Datadog的方法来异步发送自定义指标。</h3></div><div class="ms l"><p class="bd b gc z el mp eo ep mq er et ek translated">github.com</p></div></div><div class="mt l"><div class="nv l mv mw mx mt my jt mk"/></div></div></a></div><h1 id="2594" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">在CloudWatch中跟踪AWS Lambda函数的内存使用情况和计费持续时间</h1><p id="b3fd" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">Lambda报告使用的内存量，以及每次调用结束时的计费持续时间。虽然这些在CloudWatch中没有作为指标发布，但是您可以在CloudWatch日志中找到它们作为日志消息。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nw"><img src="../Images/1982c4645d3674d332d9b8ec242f0df0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F6r2dMB3bocyq6w6G44s-g.png"/></div></div><figcaption class="na nb fg fe ff nc nd bd b be z ek">At the end of every invocation, Lambda publishes a REPORT log message detailing the max amount of memory used by your function during this invocation, and how much time is billed (Lambda charges at 100ms blocks).</figcaption></figure><p id="c0a5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我很少发现内存使用是个问题，因为Nodejs函数占用的内存很少。我对内存分配的选择主要是基于获得成本和性能之间的平衡。事实上，CloudAcademy的Alex Casalboni写了一篇非常好的博文<a class="ae kr" href="https://serverless.com/blog/aws-lambda-power-tuning/" rel="noopener ugc nofollow" target="_blank">介绍如何使用阶跃函数来帮助你找到最佳点。</a></p><div class="mh mi fm fo mj mk"><a href="https://serverless.com/blog/aws-lambda-power-tuning/" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab ej"><div class="mm ab mn cl cj mo"><h2 class="bd hv fv z el mp eo ep mq er et ht dt translated">带AWS阶跃函数的AWS Lambda功率调谐</h2><div class="mr l"><h3 class="bd b fv z el mp eo ep mq er et ek translated">在过去的几个月里，我意识到大多数使用无服务器技术的开发人员不得不依靠盲目的选择…</h3></div><div class="ms l"><p class="bd b gc z el mp eo ep mq er et ek translated">serverless.com</p></div></div><div class="mt l"><div class="nx l mv mw mx mt my jt mk"/></div></div></a></div><p id="45a2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">另一方面，<code class="eh ns nt nu ng b">Billed Duration</code>与<code class="eh ns nt nu ng b">Invocation Duration</code>一起看是一个有用的指标。这让我大致了解了我的浪费量。例如，如果一个函数的平均<code class="eh ns nt nu ng b">Invocation Duration</code>是42毫秒，但平均<code class="eh ns nt nu ng b">Billed Duration</code>是100毫秒，那么有58%的浪费，也许我应该考虑在较低的内存分配上运行这个函数。</p><p id="2549" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">有趣的是，IOPipe将这些记录在开箱即用的仪表板中。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ny"><img src="../Images/a3adf77f0161e79808b0e0ba8e30f9f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cqlrLu-urGaEMOkvhvsOlA.png"/></div></div><figcaption class="na nb fg fe ff nc nd bd b be z ek">IOPipes records a number of additional metrics that are not available in CloudWatch, such as Memory Usage and CPU Usage over time, as well as coldstarts.</figcaption></figure><p id="fe9b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">然而，我们不需要仅仅为了获得这些指标而添加IOPipe。我们可以将类似的技术应用于前面的部分，并将它们作为自定义指标发布给我们的监控服务。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nz"><img src="../Images/006a0854e41e8d1e8a67b34f861eebda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IU_Iv00zM4bV1CsUAK2Gng.png"/></div></div></figure><p id="dee7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">为此，我们必须寻找这些<code class="eh ns nt nu ng b">REPORT</code>日志消息，并从中解析出相关信息。每条消息包含我们想要提取的3条信息:</p><ul class=""><li id="593f" class="lp lq hu jx b jy jz kb kc ke lr ki ls km lt kq md lv lw lx dt translated">计费持续时间(毫秒)</li><li id="f7c0" class="lp lq hu jx b jy ly kb lz ke ma ki mb km mc kq md lv lw lx dt translated">内存大小(MB)</li><li id="547c" class="lp lq hu jx b jy ly kb lz ke ma ki mb km mc kq md lv lw lx dt translated">使用的内存(MB)</li></ul><p id="22a3" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们将解析这些日志消息，并为每个消息返回一组CloudWatch指标数据，这样我们可以在以后对它们进行平面映射。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff oa"><img src="../Images/5ab91b34a02e9e42c939dd77eff29730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C3sTWJxd7Cb9z_96m7P9fw.png"/></div></div><figcaption class="na nb fg fe ff nc nd bd b be z ek">This is a function in the “parse” module, which maps a log message to an array of CloudWatch metric data.</figcaption></figure><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ob"><img src="../Images/a7e35d7de982e6f943e995368589c380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gIfe5BzVrss5775C7rUDUA.png"/></div></div><figcaption class="na nb fg fe ff nc nd bd b be z ek">Flat map over the CloudWatch metric data returned by the above parse.usageMetrics function and publish them.</figcaption></figure><p id="6338" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">果然，在为一个API订阅了日志组(在同一个演示项目中创建以测试这一点)并调用该API之后，我能够看到这些新的指标出现在CloudWatch指标中。</p><p id="490c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">看这个图，也许我可以通过在更小的内存上运行它来降低成本。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff oc"><img src="../Images/ae609fa1ff066d9499f31d5ca4dddae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QBZjjBt-TIeWYgFAC5RZlA.png"/></div></div></figure><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff od"><img src="../Images/6e3b600a2d2a65cd6bc190bee5fb90e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hrfLeeAN7pTIRNvfTo_kPA.png"/></div></div></figure><p id="4a6d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">看看这个<a class="ae kr" href="https://github.com/theburningmonk/lambda-logging-metrics-demo" rel="noopener ugc nofollow" target="_blank">回购</a>中的<code class="eh ns nt nu ng b">usage-metrics</code>函数。</p><div class="mh mi fm fo mj mk"><a href="https://github.com/theburningmonk/lambda-logging-metrics-demo" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab ej"><div class="mm ab mn cl cj mo"><h2 class="bd hv fv z el mp eo ep mq er et ht dt translated">burning monk/lambda-记录-指标-演示</h2><div class="mr l"><h3 class="bd b fv z el mp eo ep mq er et ek translated">lambda-logging-metrics-demo -如何应用Datadog的方法来异步发送自定义指标。</h3></div><div class="ms l"><p class="bd b gc z el mp eo ep mq er et ek translated">github.com</p></div></div><div class="mt l"><div class="nv l mv mw mx mt my jt mk"/></div></div></a></div><h1 id="71a3" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">注意并发性！</h1><p id="3b9a" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">当使用Lambda函数处理CloudWatch日志时，您需要注意它所创建的并发执行的数量，以便不违反<a class="ae kr" href="http://docs.aws.amazon.com/lambda/latest/dg/concurrent-executions.html" rel="noopener ugc nofollow" target="_blank">并发执行限制</a>。</p><p id="97d2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">由于这是一个帐户范围的限制，这意味着您的日志传送功能可能会导致整个应用程序中的<strong class="jx hv">级联故障</strong>。关键功能可能会受到限制，因为太多的执行被用来将日志推出CloudWatch日志——这不是一个好办法；-)</p><p id="ed32" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们需要的是一个更细粒度的Lambda节流机制。有一个帐户范围的限制是好的，但是我们应该能够创建一个函数池，它可以包含这个限制的一部分。例如，第1层功能(服务于核心业务需求的功能)获得了90%的可用并发执行。而二级功能(商业智能、监控等。)得到另外的10%。</p><p id="2322" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">就目前的情况而言，我们没有这样的功能，您所能做的最好的事情就是尽量简短地执行日志传送功能。也许这意味着在发送日志和指标时一劳永逸；或者将解码后的日志消息发送到Kinesis流中，这样您可以更好地控制并行性。</p><p id="997a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">或者，您可能会监视这些第2层功能的执行计数，当每分钟的执行数超过某个阈值时，您会暂时取消日志组对日志传送功能的订阅，以缓解问题。</p><p id="52eb" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">或者，也许你会通过将这些二级功能转移到一个单独的AWS帐户来安装一些隔板，并使用<a class="ae kr" href="https://read.iopipe.com/public-cross-account-functions-on-aws-lambda-bcc148303083" rel="noopener ugc nofollow" target="_blank">跨帐户调用</a>来触发它们。但是这似乎是一个解决问题的非常粗暴的方法！</p><div class="mh mi fm fo mj mk"><a href="https://read.iopipe.com/public-cross-account-functions-on-aws-lambda-bcc148303083" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab ej"><div class="mm ab mn cl cj mo"><h2 class="bd hv fv z el mp eo ep mq er et ht dt translated">AWS Lambda上的公共和交叉账户功能</h2><div class="mr l"><h3 class="bd b fv z el mp eo ep mq er et ek translated">AWS Lambda等无服务器平台上的公共和交叉帐户功能提供了引人注目的用例来构建非…</h3></div><div class="ms l"><p class="bd b gc z el mp eo ep mq er et ek translated">read.iopipe.com</p></div></div><div class="mt l"><div class="oe l mv mw mx mt my jt mk"/></div></div></a></div><p id="a6ed" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">关键是，这不是一个已经解决的问题，我还没有找到一个令人满意的解决方法。AWS意识到了这一差距，希望他们能增加对并发执行更好控制的支持。</p></div><div class="ab cl of og hc oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="hn ho hp hq hr"><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="ab fr cl om"><img src="../Images/8b4e4721bb1973db389b5b533d727ad1.png" data-original-src="https://miro.medium.com/v2/format:webp/0*b_1R345KzKSaI8sg.png"/></div></figure><p id="f870" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">嗨，我叫<strong class="jx hv">崔琰</strong>。我是一个<a class="ae kr" href="https://aws.amazon.com/developer/community/heroes/yan-cui/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx hv"> AWS无服务器英雄</strong> </a>和<a class="ae kr" href="https://bit.ly/production-ready-serverless" rel="noopener ugc nofollow" target="_blank"> <strong class="jx hv">量产无服务器</strong> </a>的作者。我已经在AWS中运行了近10年的大规模生产工作负载，我是一名架构师或首席工程师，涉足从银行、电子商务、体育流媒体到移动游戏等多个行业。我目前是一名专注于AWS和无服务器的独立顾问。</p><p id="c37e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">你可以通过<a class="ae kr" href="mailto:theburningmonk.com" rel="noopener ugc nofollow" target="_blank">邮箱</a>、<a class="ae kr" href="https://twitter.com/theburningmonk" rel="noopener ugc nofollow" target="_blank"> Twitter </a>和<a class="ae kr" href="https://www.linkedin.com/in/theburningmonk/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我。</p></div><div class="ab cl of og hc oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="hn ho hp hq hr"><p id="404d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">查看我的新课程，<a class="ae kr" href="https://theburningmonk.thinkific.com/courses/complete-guide-to-aws-step-functions" rel="noopener ugc nofollow" target="_blank"><strong class="jx hv">AWS步骤功能完全指南</strong> </a>。</p><p id="a329" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在本课程中，我们将介绍有效使用AWS Step Functions服务所需了解的一切。包括基本概念、HTTP和事件触发器、活动、设计模式和最佳实践。</p><p id="cd40" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">点击获取您的副本<a class="ae kr" href="https://theburningmonk.thinkific.com/courses/complete-guide-to-aws-step-functions" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl of og hc oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="hn ho hp hq hr"><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/2faf40b47320300fed81b3e09483ffb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZYcHhOOzUf5VB-Ri.png"/></div></div></figure><p id="ee8c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">来了解AWS Lambda: CI/CD的操作性<strong class="jx hv">最佳实践</strong>、本地测试&amp;调试功能、日志记录、监控、分布式跟踪、canary部署、配置管理、认证&amp;授权、VPC、安全性、错误处理等等。</p><p id="8bb5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">代码<strong class="jx hv"> ytcui </strong>还可以获得<strong class="jx hv">票面价格6折</strong>。</p><p id="2e68" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">点击获取您的副本<a class="ae kr" href="https://bit.ly/production-ready-serverless" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>