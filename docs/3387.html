<html>
<head>
<title>My take on Model View Intent (MVI) — Part 1: State Renderer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我对模型视图意图(MVI)的看法—第1部分:状态渲染器</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/model-view-intent-mvi-part-1-state-renderer-187e270db15c?source=collection_archive---------4-----------------------#2017-03-30">https://medium.com/hackernoon/model-view-intent-mvi-part-1-state-renderer-187e270db15c?source=collection_archive---------4-----------------------#2017-03-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="d74d" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">脱离UI线程，以可预测的状态和灵活性自动进行UI测试</h2></div><h1 id="19a9" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated">目标</h1><ol class=""><li id="4ba1" class="kb kc hu kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dt translated">全自动UI测试(Android上的Espresso)</li><li id="802d" class="kb kc hu kd b ke kt kg ku ki kv kk kw km kx ko kp kq kr ks dt translated">在后台线程上完成的所有计算(视图访问除外)</li><li id="b6db" class="kb kc hu kd b ke kt kg ku ki kv kk kw km kx ko kp kq kr ks dt translated">适合任何平台的前端架构。由于<a class="ae ky" href="http://reactivex.io/" rel="noopener ugc nofollow" target="_blank">react vex</a>的跨平台特性，同样的想法也适用于iOS、Android和网络。</li><li id="a1ae" class="kb kc hu kd b ke kt kg ku ki kv kk kw km kx ko kp kq kr ks dt translated">一个可以适应任何东西的UI层。边缘案例、新需求和增加的复杂性不需要重构</li></ol><p id="64d3" class="pw-post-body-paragraph kz la hu kd b ke lb iv lc kg ld iy le ki lf lg lh kk li lj lk km ll lm ln ko hn dt translated">本文涵盖了目标1和目标2。在以后的文章中，我会深入探究为什么第四条是正确的。</p><h1 id="08d8" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated">模型视图意图(MVI)</h1><p id="bc3a" class="pw-post-body-paragraph kz la hu kd b ke kf iv lc kg kh iy le ki lo lg lh kk lp lj lk km lq lm ln ko hn dt translated">我强烈推荐看看汉尼斯·多夫曼在MVI和安卓系统上的令人惊叹的博客系列。我不会深入探讨什么是模型视图意图，而是我对它的具体实现。</p><blockquote class="lr ls lt"><p id="72b3" class="kz la lu kd b ke lb iv lc kg ld iy le lv lf lg lh lw li lj lk lx ll lm ln ko hn dt translated">简而言之，我们将合并来自数据层的输入和用户输入，以输出一个随时间不断更新的<code class="eh ly lz ma mb b">ViewState</code>，将一个<code class="eh ly lz ma mb b">ViewState</code>的每个新实例呈现到我们的<code class="eh ly lz ma mb b">Ui</code> / <code class="eh ly lz ma mb b">View</code>上。</p></blockquote><h1 id="dc1d" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated">演示应用——一副“纸牌”</h1><figure class="mc md me mf fq mg"><div class="bz el l di"><div class="mh mi l"/></div><figcaption class="mj mk fg fe ff ml mm bd b be z ek">Deal a deck, shuffle, or build a new deck.</figcaption></figure><h2 id="ed93" class="mn jk hu bd jl mo mp mq jp mr ms mt jt ki mu mv jv kk mw mx jx km my mz jz na dt translated">成分</h2><p id="24aa" class="pw-post-body-paragraph kz la hu kd b ke kf iv lc kg kh iy le ki lo lg lh kk lp lj lk km lq lm ln ko hn dt translated">我的MVI实现有以下7个组件。注意:#2-5是你的UI/视图将要实现的所有接口。</p><ol class=""><li id="bcfb" class="kb kc hu kd b ke lb kg ld ki nb kk nc km nd ko kp kq kr ks dt translated"><code class="eh ly lz ma mb b">ViewState</code> —一个简单的POJO，表示<em class="lu">所有</em>在UI中显示的数据(<code class="eh ly lz ma mb b">Activity</code>、<code class="eh ly lz ma mb b">Fragment</code>、<code class="eh ly lz ma mb b">ViewGroup</code>等)。</li><li id="7d9d" class="kb kc hu kd b ke kt kg ku ki kv kk kw km kx ko kp kq kr ks dt translated"><code class="eh ly lz ma mb b">StateRenderer</code>—公开单个函数，该函数接受<code class="eh ly lz ma mb b">ViewState</code>的实例，并可以将其呈现给<code class="eh ly lz ma mb b">Ui</code>。这个单一入口点是修改用户可见内容的唯一方式。这个接口的实现将调用<code class="eh ly lz ma mb b">Ui.Actions</code>方法(参见#4)。<br/> — <code class="eh ly lz ma mb b">fun render(state: ViewState)</code></li><li id="40d8" class="kb kc hu kd b ke kt kg ku ki kv kk kw km kx ko kp kq kr ks dt translated"><code class="eh ly lz ma mb b">Ui</code> —查看界面。这是<strong class="kd hv"> MVP </strong>中的<strong class="kd hv"> V </strong>。由您的视图(<code class="eh ly lz ma mb b">Activity</code>、<code class="eh ly lz ma mb b">Fragment</code>、<code class="eh ly lz ma mb b">ViewGroup</code>等)执行。</li></ol><pre class="mc md me mf fq ne mb nf ng aw nh dt"><span id="acc1" class="mn jk hu mb b fv ni nj l nk nl"><em class="lu">/**<br/> * The user interface for dealing cards.<br/> *<br/> * </em><strong class="mb hv"><em class="lu">@see </em></strong><em class="lu">DealCardsActivity<br/> */<br/></em>interface DealCardsUi : StateRenderer&lt;DealCardsUi.State&gt; {<br/><br/>    val state: ViewState<br/><br/>    override fun render(state: ViewState)<br/>}</span></pre><p id="019e" class="pw-post-body-paragraph kz la hu kd b ke lb iv lc kg ld iy le ki lf lg lh kk li lj lk km ll lm ln ko hn dt translated">4.<code class="eh ly lz ma mb b">Ui.Actions</code> —视图界面的子集。<a class="ae ky" href="https://martinfowler.com/eaaDev/PassiveScreen.html" rel="noopener ugc nofollow" target="_blank">哑巴被动查看方法</a>。由您的视图执行(<code class="eh ly lz ma mb b">Activity</code>、<code class="eh ly lz ma mb b">Fragment</code>、<code class="eh ly lz ma mb b">ViewGroup</code>等)。</p><pre class="mc md me mf fq ne mb nf ng aw nh dt"><span id="99e1" class="mn jk hu mb b fv ni nj l nk nl">interface Actions {<br/>  <em class="lu">/**<br/>   * Show or hide the loading UI<br/>   * </em><strong class="mb hv"><em class="lu">@param </em></strong><em class="lu">isLoading true to show the loading UI, false to hide it<br/>   */<br/>  </em>fun showLoading(isLoading: Boolean = true)<br/>}</span></pre><p id="2ae3" class="pw-post-body-paragraph kz la hu kd b ke lb iv lc kg ld iy le ki lf lg lh kk li lj lk km ll lm ln ko hn dt translated">5.<code class="eh ly lz ma mb b">Ui.Intentions</code> —视图界面的子集。一段时间内的用户输入流。由您的视图执行(<code class="eh ly lz ma mb b">Activity</code>、<code class="eh ly lz ma mb b">Fragment</code>、<code class="eh ly lz ma mb b">ViewGroup</code>等)。</p><pre class="mc md me mf fq ne mb nf ng aw nh dt"><span id="8ae5" class="mn jk hu mb b fv ni nj l nk nl">interface Intentions {<br/>    <em class="lu">/**<br/>     * When the user requests to deal the top card from the deck<br/>     */<br/>    </em>fun dealCardRequests(): Observable&lt;Unit&gt;<br/>}</span></pre><p id="570d" class="pw-post-body-paragraph kz la hu kd b ke lb iv lc kg ld iy le ki lf lg lh kk li lj lk km ll lm ln ko hn dt translated">6.<code class="eh ly lz ma mb b">Presenter</code> —接收来自<code class="eh ly lz ma mb b">Ui.Intentions</code>的输入和来自数据层的输入，以输出一个新的<code class="eh ly lz ma mb b">ViewState</code>，它被渲染到视图上。<strong class="kd hv"> MVP </strong>中的<strong class="kd hv"> P </strong>。</p><p id="8af9" class="pw-post-body-paragraph kz la hu kd b ke lb iv lc kg ld iy le ki lf lg lh kk li lj lk km ll lm ln ko hn dt translated">7.<strong class="kd hv">数据层</strong> —你的磁盘和网络层。该层应输出任何事件，如<code class="eh ly lz ma mb b">Presenter</code>发生的“数据加载”或“网络错误”。</p><p id="48e1" class="pw-post-body-paragraph kz la hu kd b ke lb iv lc kg ld iy le ki lf lg lh kk li lj lk km ll lm ln ko hn dt translated">本文的其余部分将从上面开始讨论组件1-4(其他的将在后面的文章中讨论)。</p><h1 id="bde2" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated"><strong class="ak">视图状态&amp;状态渲染器</strong></h1><p id="4aa5" class="pw-post-body-paragraph kz la hu kd b ke kf iv lc kg kh iy le ki lo lg lh kk lp lj lk km lq lm ln ko hn dt translated">让我们更深入地了解一下<code class="eh ly lz ma mb b">ViewState</code>。</p><pre class="mc md me mf fq ne mb nf ng aw nh dt"><span id="57e3" class="mn jk hu mb b fv ni nj l nk nl"><em class="lu">/**<br/> * The view state for [DealCardsUi]<br/> */<br/></em>data class State(<br/>        val deck: Deck,<br/>        private val isShuffling: Boolean,<br/>        private val isDealing: Boolean,<br/>        private val isBuildingNewDeck: Boolean,<br/>        val error: String?<br/>) {<br/>    val isLoading: Boolean = isShuffling || isDealing || isBuildingNewDeck<br/>    val remaining: Int get() = deck.remaining.size <br/>    val dealt: List&lt;Card&gt; get() = deck.dealt<br/>}</span></pre><p id="f7f7" class="pw-post-body-paragraph kz la hu kd b ke lb iv lc kg ld iy le ki lf lg lh kk li lj lk km ll lm ln ko hn dt translated">下面，您可以看到状态是如何影响屏幕内容的。</p><figure class="mc md me mf fq mg fe ff paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="fe ff nm"><img src="../Images/47cee030d5140f9f32b9123626245561.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_wUcHman3W375_LcjMOVPA.png"/></div></div></figure><p id="5b97" class="pw-post-body-paragraph kz la hu kd b ke lb iv lc kg ld iy le ki lf lg lh kk li lj lk km ll lm ln ko hn dt translated">下面是<code class="eh ly lz ma mb b">StateRenderer&lt;DealCardsUi.State&gt;</code>的简化实现。</p><figure class="mc md me mf fq mg fe ff paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="fe ff nt"><img src="../Images/41043c9e37d903e8b3c2fb9608b0a4f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*26Puwta_adaBSN28fEnQHA.png"/></div></div></figure><p id="5912" class="pw-post-body-paragraph kz la hu kd b ke lb iv lc kg ld iy le ki lf lg lh kk li lj lk km ll lm ln ko hn dt translated">使用Rx的调度程序并观察最新的<code class="eh ly lz ma mb b">ViewState</code>，我们实现了目标# 2——尽可能远离UI线程。</p><h1 id="ef59" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated">自动化UI测试</h1><p id="eacb" class="pw-post-body-paragraph kz la hu kd b ke kf iv lc kg kh iy le ki lo lg lh kk lp lj lk km lq lm ln ko hn dt translated">我们所有的<code class="eh ly lz ma mb b">Ui</code>类都有以下功能——向用户显示信息的单一入口点。</p><pre class="mc md me mf fq ne mb nf ng aw nh dt"><span id="2d9f" class="mn jk hu mb b fv ni nj l nk nl">fun render(state: ViewState)</span></pre><p id="f64a" class="pw-post-body-paragraph kz la hu kd b ke lb iv lc kg ld iy le ki lf lg lh kk li lj lk km ll lm ln ko hn dt translated">测试被简化为简单的输入/输出功能。</p><ol class=""><li id="7274" class="kb kc hu kd b ke lb kg ld ki nb kk nc km nd ko kp kq kr ks dt translated"><strong class="kd hv">输入</strong>—<code class="eh ly lz ma mb b">ViewState</code>。抓取对您的<code class="eh ly lz ma mb b">Ui</code>的引用，并调用<code class="eh ly lz ma mb b">ui.render(viewState)</code>函数。</li><li id="b532" class="kb kc hu kd b ke kt kg ku ki kv kk kw km kx ko kp kq kr ks dt translated"><strong class="kd hv">输出</strong>—<code class="eh ly lz ma mb b">Ui</code>。使用Espresso验证<code class="eh ly lz ma mb b">Ui</code>看起来和预期的一样。</li></ol><p id="ecff" class="pw-post-body-paragraph kz la hu kd b ke lb iv lc kg ld iy le ki lf lg lh kk li lj lk km ll lm ln ko hn dt translated">想要测试配置更改吗？调用<code class="eh ly lz ma mb b">activity.recreate()</code>，再次验证输出不变。</p><p id="0959" class="pw-post-body-paragraph kz la hu kd b ke lb iv lc kg ld iy le ki lf lg lh kk li lj lk km ll lm ln ko hn dt translated">满足以下要求以简化测试。</p><ol class=""><li id="5e12" class="kb kc hu kd b ke lb kg ld ki nb kk nc km nd ko kp kq kr ks dt translated">在测试过程中，解除(禁用)每个<code class="eh ly lz ma mb b">Presenter</code>的激活，和/或禁用您的磁盘/网络层。</li><li id="afbb" class="kb kc hu kd b ke kt kg ku ki kv kk kw km kx ko kp kq kr ks dt translated">在没有演示者的情况下保持导航功能。通过意图导航简化了这一点。</li><li id="7a39" class="kb kc hu kd b ke kt kg ku ki kv kk kw km kx ko kp kq kr ks dt translated">能够获取对您的视图的引用。这可能是一个<code class="eh ly lz ma mb b">Activity</code>、<code class="eh ly lz ma mb b">Fragment</code>、<code class="eh ly lz ma mb b">ViewGroup</code>、<code class="eh ly lz ma mb b">Controller</code>等等——但是你必须能够调用你的<code class="eh ly lz ma mb b">view.render(state: ViewState)</code>函数。</li></ol><h1 id="5d8d" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated">结论</h1><p id="886a" class="pw-post-body-paragraph kz la hu kd b ke kf iv lc kg kh iy le ki lo lg lh kk lp lj lk km lq lm ln ko hn dt translated">我真的相信这种建筑风格是MVP，MVVM等的自然进化。单个<code class="eh ly lz ma mb b">ViewState</code>允许可预测的状态和最大的可测试性。</p><p id="4ff0" class="pw-post-body-paragraph kz la hu kd b ke lb iv lc kg ld iy le ki lf lg lh kk li lj lk km ll lm ln ko hn dt translated">在以后的文章中，我将更深入地研究其他组件，比如负责<code class="eh ly lz ma mb b">ViewState</code>的业务逻辑。</p><blockquote class="lr ls lt"><p id="d1a3" class="kz la lu kd b ke lb iv lc kg ld iy le lv lf lg lh lw li lj lk lx ll lm ln ko hn dt translated">在<a class="ae ky" href="https://www.reddit.com/r/androiddev/comments/637vho/model_view_intent_mvi_part_1_state_renderer/" rel="noopener ugc nofollow" target="_blank"> Reddit </a>上捕捉对话</p><p id="04d9" class="kz la lu kd b ke lb iv lc kg ld iy le lv lf lg lh lw li lj lk lx ll lm ln ko hn dt translated">所有源代码都可以在<a class="ae ky" href="https://github.com/ZakTaccardi/deck-of-cards" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><p id="9d24" class="kz la lu kd b ke lb iv lc kg ld iy le lv lf lg lh lw li lj lk lx ll lm ln ko hn dt translated">向许多使这种架构成为可能的反应式编程的先驱大声疾呼！</p><p id="9845" class="kz la lu kd b ke lb iv lc kg ld iy le lv lf lg lh lw li lj lk lx ll lm ln ko hn dt translated">其他资源—观看Jake Wharton关于管理Rx状态的精彩演讲<a class="ae ky" href="https://www.youtube.com/watch?v=0IKHxjkgop4" rel="noopener ugc nofollow" target="_blank">。</a></p></blockquote><div class="mc md me mf fq ab cb"><figure class="nu mg nv nw nx ny nz paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nu mg nv nw nx ny nz paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nu mg nv nw nx ny nz paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="lr ls lt"><p id="f922" class="kz la lu kd b ke lb iv lc kg ld iy le lv lf lg lh lw li lj lk lx ll lm ln ko hn dt translated"><a class="ae ky" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是AMI家庭的一员。我们现在<a class="ae ky" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ky" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="kz la lu kd b ke lb iv lc kg ld iy le lv lf lg lh lw li lj lk lx ll lm ln ko hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ky" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ky" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="mc md me mf fq mg fe ff paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="fe ff oa"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>