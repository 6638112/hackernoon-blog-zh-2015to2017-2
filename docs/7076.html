<html>
<head>
<title>ES6 Modules Today With TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">今天带TypeScript的ES6模块</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/es6-modules-today-with-typescript-22969cd360f0?source=collection_archive---------16-----------------------#2017-10-16">https://medium.com/hackernoon/es6-modules-today-with-typescript-22969cd360f0?source=collection_archive---------16-----------------------#2017-10-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/d48c1d3e516d7eef14a2ee3baa74d263.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DM02gE7XW4dVDm2yBgl--w.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Two work horses represent both ESM and CJS builds</figcaption></figure><p id="f3f1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">2017年的今天，很多常青树浏览器都支持开箱即用的ES6模块。一些浏览器将它隐藏在一个标志后面，包括Node.js。但是用同一个npm包支持新旧环境可能吗？是啊！</p><blockquote class="ke kf kg"><p id="fdf8" class="jg jh kh ji b jj jk jl jm jn jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kd hn dt translated"><em class="hu">编者按:ES6模块有时被称为ES2015模块，或ESM，或</em> <code class="eh kl km kn ko b"><em class="hu">module</em></code> <em class="hu">脚本，有时甚至被扩展名</em> <code class="eh kl km kn ko b"><em class="hu">.mjs</em></code> <em class="hu">读作“迈克尔杰克逊脚本”。我们都在谈论同一件事，所以如果你听到不同的术语，不要混淆。</em></p></blockquote><p id="b545" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我不会讨论使用ES6模块的优点或者为什么TypeScript很棒，因为已经有很多博客文章详细描述了这些。相反，我将着重于向npm发布一个用TypeScript编写但部署为<code class="eh kl km kn ko b">.mjs</code> (ESM)和<code class="eh kl km kn ko b">.js</code> (CommonJS)的包，这样任何消费者都可以使用您的包！</p><h1 id="cd31" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">入门指南</h1><p id="f192" class="pw-post-body-paragraph jg jh hu ji b jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd hn dt translated">第一步是设置您的<code class="eh kl km kn ko b">tsconfig.json</code>文件，这样TypeScript将使用最新最棒的JavaScript特性，如下所示:</p><pre class="ls lt lu lv fq lw ko lx ly aw lz dt"><span id="0973" class="ma kq hu ko b fv mb mc l md me">{<br/>  "compilerOptions": {<br/>    "module": "es2015",<br/>    "target": "ES2017",<br/>    "rootDir": "src",<br/>    "outDir": "dist",<br/>    "sourceMap": false,<br/>    "strict": true<br/>  }<br/>}</span></pre><p id="3530" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">显然，我们希望模块是<code class="eh kl km kn ko b">es2015</code>，因为它在本文的标题中，所以我们必须在某个时候解决它！让我们瞄准<code class="eh kl km kn ko b">es2017</code>，这样我们就可以像JS忍者一样使用<code class="eh kl km kn ko b">async</code>和<code class="eh kl km kn ko b">await</code>关键字。您可以将您的<code class="eh kl km kn ko b">rootDir</code>和<code class="eh kl km kn ko b">outDir</code>命名为您想要的任何名称，但是在JS Land中使用<code class="eh kl km kn ko b">dist</code>进行输出是一个惯例。源地图是可选的，但是我喜欢在需要的时候关闭它们。严格模式也是可选的，但是如果以后需要的话，从严格开始变得宽松一点更容易。我强烈建议启用它，因为默认情况下它是禁用的。</p><h1 id="84dd" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">连接起来</h1><p id="617a" class="pw-post-body-paragraph jg jh hu ji b jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd hn dt translated">现在我们可以讨论<code class="eh kl km kn ko b">package.json</code>文件了。这里有一个名为<a class="ae mf" href="https://github.com/styfle/copee" rel="noopener ugc nofollow" target="_blank"> copee </a>的包的例子:</p><pre class="ls lt lu lv fq lw ko lx ly aw lz dt"><span id="4a0a" class="ma kq hu ko b fv mb mc l md me">{ <br/>  "name": "copee",<br/>  "version": "1.0.0",<br/>  "description": "Copy text from browser to clipboard...natively!",<br/>  "repository": "styfle/copee",<br/>  "files": [ "dist" ],<br/>  "main": "dist/copee",<br/>  "types": "dist/copee.d.ts",<br/>  "scripts": {<br/>    "mjs": "tsc -d &amp;&amp; mv dist/copee.js dist/copee.mjs",<br/>    "cjs": "tsc -m commonjs",<br/>    "build": "npm run mjs &amp;&amp; npm run cjs"<br/>  },<br/>  "devDependencies": {<br/>    "typescript": "^2.5.3"<br/>  }<br/>}</span></pre><p id="c4e2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">前四行定义了包<code class="eh kl km kn ko b">name</code>、<code class="eh kl km kn ko b">version</code>、<code class="eh kl km kn ko b">description</code>和GitHub <code class="eh kl km kn ko b">repository</code>，它们是自我解释的。</p><p id="e226" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">接下来，我们定义<code class="eh kl km kn ko b">files</code>，我们简单地将它定义为一个单独的文件夹<code class="eh kl km kn ko b">dist</code>。这些是将发布到npm的文件。</p><p id="742b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">你的包的入口点被定义为<code class="eh kl km kn ko b">main</code>，这就是神奇发生的地方。请注意，没有像预期的那样有文件扩展名(比如<code class="eh kl km kn ko b">.js</code>)。这将允许Node根据用户导入软件包的方式选择文件——是旧的CJS还是新的ESM。</p><p id="a9e1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">接下来是<code class="eh kl km kn ko b">types</code>，这对于想要通过TypeScript导入的用户来说是必需的。如果你正在用TypeScript编写你的包，你应该明确地包含<code class="eh kl km kn ko b">types</code>以便你的TS用户获得类型安全！说真的，这样做是对的。</p><p id="0749" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在有趣的部分来了:<code class="eh kl km kn ko b">scripts</code>。这些是您可以通过<code class="eh kl km kn ko b">npm run thenameofthescriptgoeshere</code>运行的构建步骤。第一个构建步骤<code class="eh kl km kn ko b">mjs</code>使用TypeScript编译器(<code class="eh kl km kn ko b">tsc</code>)使用我们之前定义的<code class="eh kl km kn ko b">tsconfig.json</code>文件，加上一个发出我们的<code class="eh kl km kn ko b">.d.ts</code>类型定义的<code class="eh kl km kn ko b">-d</code>标志来构建我们的代码。还要注意将输出文件从<code class="eh kl km kn ko b">.js</code>移动到<code class="eh kl km kn ko b">.mjs</code>的<code class="eh kl km kn ko b">mv</code>命令。这是我们的ESM输出。</p><p id="bb31" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们的下一个脚本，<code class="eh kl km kn ko b">cjs</code>使用TypeScript编译器(<code class="eh kl km kn ko b">tsc</code>)构建相同的源代码，但是将输出作为CommonJS模块发出。这是Node.js的模块系统，由<code class="eh kl km kn ko b">browserify</code>、<code class="eh kl km kn ko b">webpack</code>等理解。</p><p id="a3b4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">最后，我们有<code class="eh kl km kn ko b">devDependencies</code>是你的构建工具。在这种情况下，我们所需要的是包含上面使用的<code class="eh kl km kn ko b">tsc</code>命令的<code class="eh kl km kn ko b">typescript</code>。</p><h1 id="1c87" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">节点使用</h1><p id="8661" class="pw-post-body-paragraph jg jh hu ji b jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd hn dt translated">我将向您展示如何编写一个导入上述包的消费者。如果您已经经常使用Node，请跳到下一节了解ESM的用法。</p><p id="2af9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">首先，安装<a class="ae mf" href="https://www.npmjs.com/package/copee" rel="noopener ugc nofollow" target="_blank"> copee </a>包:</p><pre class="ls lt lu lv fq lw ko lx ly aw lz dt"><span id="1b5c" class="ma kq hu ko b fv mb mc l md me">npm install --save copee</span></pre><p id="6d29" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">然后，用以下内容创建一个<code class="eh kl km kn ko b">index.js</code>文件:</p><pre class="ls lt lu lv fq lw ko lx ly aw lz dt"><span id="dd17" class="ma kq hu ko b fv mb mc l md me">const { toClipboard } = require('copee'); console.log('CJS: We found a ', typeof toClipboard);</span></pre><p id="91cb" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">新程序可以这样执行:</p><pre class="ls lt lu lv fq lw ko lx ly aw lz dt"><span id="e52d" class="ma kq hu ko b fv mb mc l md me">node index.js</span></pre><h1 id="ef36" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">节点ESM使用情况</h1><p id="296f" class="pw-post-body-paragraph jg jh hu ji b jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd hn dt translated">我将向您展示如何编写一个导入上面的<a class="ae mf" href="https://www.npmjs.com/package/copee" rel="noopener ugc nofollow" target="_blank"> copee </a>包的消费者。</p><p id="15c4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">安装<a class="ae mf" href="https://www.npmjs.com/package/copee" rel="noopener ugc nofollow" target="_blank"> copee </a>后，创建一个<code class="eh kl km kn ko b">index.mjs</code>文件。您必须使用迈克尔杰克逊脚本扩展(。mjs)。</p><pre class="ls lt lu lv fq lw ko lx ly aw lz dt"><span id="0d3b" class="ma kq hu ko b fv mb mc l md me">import { toClipboard } from 'copee';<br/>console.log('ESM: We found a ', typeof toClipboard);</span></pre><p id="15b3" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">新程序可以这样执行:</p><pre class="ls lt lu lv fq lw ko lx ly aw lz dt"><span id="f088" class="ma kq hu ko b fv mb mc l md me">node --experimental-modules index.mjs</span></pre><h1 id="0f78" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">浏览器ESM使用</h1><p id="50c1" class="pw-post-body-paragraph jg jh hu ji b jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd hn dt translated">节点的使用并不那么引人注目，因为从一开始就有模块，但是ESM的美妙之处在于，在节点模块中执行的相同代码将在浏览器中不变地运行！是的，是真的！请尽情欣赏下面这段优雅的代码片段:</p><pre class="ls lt lu lv fq lw ko lx ly aw lz dt"><span id="ca00" class="ma kq hu ko b fv mb mc l md me">&lt;script type="module"&gt;<br/>  import {<br/>    toClipboard<br/>  } from 'https://cdn.jsdelivr.net/npm/copee/dist/copee.mjs';</span><span id="21e0" class="ma kq hu ko b fv mg mc l md me">  $('#btn').on('click', () =&gt; {<br/>    const win = toClipboard('Wow, "copee" works!');<br/>      if (win) {<br/>        // it worked, check your clipboard!<br/>      }<br/>  });<br/>&lt;/script&gt;</span></pre><p id="1b4d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们为<code class="eh kl km kn ko b">module</code>提供了一个新的脚本类型，我们使用<a class="ae mf" href="https://www.jsdelivr.com/" rel="noopener ugc nofollow" target="_blank"> jsDelivr </a>在CDN上自动托管我们的代码。这使得编写一个单独的导入行并在全世界的浏览器中使用<a class="ae mf" href="https://www.npmjs.com/package/copee" rel="noopener ugc nofollow" target="_blank"> copee </a>包变得很容易！</p><h1 id="643b" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">传统浏览器</h1><p id="3f02" class="pw-post-body-paragraph jg jh hu ji b jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd hn dt translated">你会说，传统浏览器呢？不是所有人都支持ESM？这可以通过捆绑UMD和T1来解决。安装完<code class="eh kl km kn ko b">rollup</code>后，将它添加到你的<code class="eh kl km kn ko b">package.json</code>文件的<code class="eh kl km kn ko b">scripts</code>部分。</p><pre class="ls lt lu lv fq lw ko lx ly aw lz dt"><span id="02dc" class="ma kq hu ko b fv mb mc l md me">{<br/>  "umd": "rollup -i dist/copee.mjs -o dist/copee.umd.js -f umd -n copee"<br/>}</span></pre><p id="72fb" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">您可以在同一页面上包含ESM和UMD版本，而不会发生冲突。请参见下面的片段:</p><pre class="ls lt lu lv fq lw ko lx ly aw lz dt"><span id="db93" class="ma kq hu ko b fv mb mc l md me">&lt;script nomodule src="https://cdn.jsdelivr.net/npm/copee/dist/copee.umd.js"&gt;&lt;/script&gt; &lt;script type="module"&gt;<br/>  import {<br/>    toClipboard<br/>  } from 'https://cdn.jsdelivr.net/npm/copee/dist/copee.mjs';<br/>&lt;/script&gt;</span></pre><p id="63b1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">通过使用<code class="eh kl km kn ko b">nomodule</code>属性，您告诉新浏览器忽略UMD脚本。通过使用<code class="eh kl km kn ko b">type=module</code>,你是在告诉老浏览器忽略ESM。现在大家都赢了！</p><p id="2702" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">您可以在<a class="ae mf" href="https://styfle.github.io/copee/" rel="noopener ugc nofollow" target="_blank">演示页面</a>上看到该解决方案的工作演示。</p><p id="d9a7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">此外，请查看<a class="ae mf" href="https://github.com/styfle/copee" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>了解更多细节，当然还有工作源代码！</p></div><div class="ab cl mh mi hc mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hn ho hp hq hr"><p id="ca73" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="kh">原载于2017年10月16日</em><a class="ae mf" href="https://www.ceriously.com/blog/post.php?id=2017-10-16-es6-modules-today-with-typescript.md" rel="noopener ugc nofollow" target="_blank"><em class="kh">www.ceriously.com</em></a><em class="kh">。</em></p></div></div>    
</body>
</html>