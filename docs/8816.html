<html>
<head>
<title>Pushpin — An Open Source Library That Turns REST APIs into Realtime APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">pushpin——一个将REST APIs转化为实时API的开源库</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/pushpin-an-open-source-library-that-turns-rest-apis-into-realtime-apis-ebb3253e63ce?source=collection_archive---------0-----------------------#2017-12-16">https://medium.com/hackernoon/pushpin-an-open-source-library-that-turns-rest-apis-into-realtime-apis-ebb3253e63ce?source=collection_archive---------0-----------------------#2017-12-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="dba4" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">介绍事件API以及如何用图钉构建它们</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/7f6c753bb29edfacc4219d36213803d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*CkynRe-J1FVnUAk7JmOTdQ.gif"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><a class="ae jz" href="https://creatordev.io/ci20.html" rel="noopener ugc nofollow" target="_blank">Creator Ci20</a></figcaption></figure><p id="aca9" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">“实时”正在成为现代技术堆栈中无处不在的力量。随着消费者要求更快和更频繁的数据交易，公司越来越多地投资于加速这些交易的产品基础设施。尽管我们已经看到API成为经济和技术的必需品，但它们通常基于请求-响应风格的交互，这限制了它们在实时领域的范围和有效性。</p><h1 id="65c0" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated">请求-响应与事件驱动的API</h1><p id="a220" class="pw-post-body-paragraph ka kb hu kc b kd lo iv kf kg lp iy ki kj lq kl km kn lr kp kq kr ls kt ku kv hn dt translated">其核心是，请求-响应是一种消息交换模式，其中请求者向回复者系统发送请求消息。replier系统接收并处理请求，如果一切顺利，它将返回一条消息作为响应。虽然这种交换格式对于更结构化的请求很有效，但是它将集成限制在那些预期的系统清楚地知道自己想从对方那里得到什么的情况下。因此，这些请求-响应风格的API必须遵循来自调用服务的交互脚本。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff lt"><img src="../Images/63923298236a3f0749222780a3168fb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3ZNczU5CXLhrdB6F.jpg"/></div></div></figure><p id="2ffd" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">在事件驱动的架构中，应用程序基于事件驱动的交互，平等地集成多种服务和产品。这些交互由事件发射器、事件消费者和事件通道驱动，由此事件本身通常是产生、发布、传播、检测或消费的重大“状态变化”。这种架构模式支持软件组件和服务之间的松散耦合。这样做的好处是事件发射器不需要知道消费者的状态，消费者是谁，或者事件将如何处理(如果有的话)。这是一种通过持久流推送数据的机制。</p><h1 id="c7f0" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated">事件API解决方案</h1><p id="dde8" class="pw-post-body-paragraph ka kb hu kc b kd lo iv kf kg lp iy ki kj lq kl km kn lr kp kq kr ls kt ku kv hn dt translated">在技术生态系统中，有许多方法可以处理数据流和事件API。一些领先的SAAS解决方案包括<a class="ae jz" href="https://www.pubnub.com/" rel="noopener ugc nofollow" target="_blank"> PubNub </a>、<a class="ae jz" href="https://pusher.com/" rel="noopener ugc nofollow" target="_blank"> Pusher </a>、<a class="ae jz" href="https://kaazing.com/" rel="noopener ugc nofollow" target="_blank"> Kaazing </a>和<a class="ae jz" href="https://fanout.io/" rel="noopener ugc nofollow" target="_blank">Fanout</a>——它们各有利弊，并加大投资。为了理解事件驱动架构的基础，我们将探索一些叫做Pushpin的开源软件。</p><h1 id="5a3c" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated">图钉</h1><p id="ad16" class="pw-post-body-paragraph ka kb hu kc b kd lo iv kf kg lp iy ki kj lq kl km kn lr kp kq kr ls kt ku kv hn dt translated"><a class="ae jz" href="http://pushpin.org/" rel="noopener ugc nofollow" target="_blank"> Pushpin的</a>主要价值主张是，它是一个支持实时推送的开源解决方案——这是事件API的必备条件(<a class="ae jz" href="https://github.com/fanout/pushpin" rel="noopener ugc nofollow" target="_blank"> GitHub Repo </a>)。它的核心是一个反向代理服务器，使得实现WebSocket、HTTP流和HTTP长轮询服务变得容易。从结构上来说，图钉使用常规的、短期的HTTP请求与后端web应用程序进行通信。</p><p id="3956" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">这种架构提供了一些核心优势:</p><ul class=""><li id="e46f" class="lu lv hu kc b kd ke kg kh kj lw kn lx kr ly kv lz ma mb mc dt translated">后端语言可以用任何语言编写，可以使用任何网络服务器。</li><li id="8803" class="lu lv hu kc b kd md kg me kj mf kn mg kr mh kv lz ma mb mc dt translated">可以通过简单的HTTP POST请求将数据推送到Pushpin的私有控制API。</li><li id="0840" class="lu lv hu kc b kd md kg me kj mf kn mg kr mh kv lz ma mb mc dt translated">它对连接的客户端是不可见的。</li><li id="c23a" class="lu lv hu kc b kd md kg me kj mf kn mg kr mh kv lz ma mb mc dt translated">当需要来自后端服务器的数据时，它通过作为负责方来管理有状态元素。</li><li id="b60e" class="lu lv hu kc b kd md kg me kj mf kn mg kr mh kv lz ma mb mc dt translated">不需要图钉实例之间的通信，因此可水平扩展。</li><li id="f8fa" class="lu lv hu kc b kd md kg me kj mf kn mg kr mh kv lz ma mb mc dt translated">它利用发布-订阅模型进行数据传输。</li><li id="03c2" class="lu lv hu kc b kd md kg me kj mf kn mg kr mh kv lz ma mb mc dt translated">它可以充当代理服务器和发布-订阅代理。</li></ul><h1 id="c3fa" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated">集成图钉</h1><p id="1089" class="pw-post-body-paragraph ka kb hu kc b kd lo iv kf kg lp iy ki kj lq kl km kn lr kp kq kr ls kt ku kv hn dt translated">从更系统的角度来看，有几种方法可以将图钉集成到堆栈中。最基本的设置是将Pushpin放在典型的web服务后端的前面，后端将数据直接发布到Pushpin。web服务本身可能发布数据以响应传入的请求，或者可能有某种后台进程/作业发布数据。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mi"><img src="../Images/7105bbadf50af65462e7d2cdc0da4421.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PGdrA58pXpkDIVu-.jpg"/></div></div></figure><p id="aa05" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">因为Pushpin是一个代理服务器，它可以与大多数API管理系统一起工作——允许您执行实际的API开发。例如，您可以将代理链接在一起，将图钉放在前面，这样您的API管理系统就不会受到长期连接的影响。更重要的是，Pushpin可以将WebSocket协议翻译成HTTP，允许API管理系统对翻译后的数据进行操作。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mj"><img src="../Images/10abf13889e2205cb566cdd774292d4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*v9yRNkOKFWauOfKh.png"/></div></div></figure><p id="a351" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">你可以点击这里查看一些用图钉<a class="ae jz" href="http://pushpin.org/docs/examples/" rel="noopener ugc nofollow" target="_blank">构建的示例应用程序。</a></p><h1 id="c5c3" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated">事件API的未来</h1><p id="9cb5" class="pw-post-body-paragraph ka kb hu kc b kd lo iv kf kg lp iy ki kj lq kl km kn lr kp kq kr ls kt ku kv hn dt translated">在一些后续文章中，我将讨论一些我们可以在事件化API中看到的独特特性。其中包括事件批处理、显著性过滤器和标准订阅界面。如果您正在寻找一个实时插入式API代理，那么我强烈推荐您尝试一下图钉。</p></div></div>    
</body>
</html>