<html>
<head>
<title>Consuming REST API in PHP Using Guzzle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Guzzle在PHP中使用REST API</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/creating-rest-api-in-php-using-guzzle-d6a890499b02?source=collection_archive---------1-----------------------#2017-04-18">https://medium.com/hackernoon/creating-rest-api-in-php-using-guzzle-d6a890499b02?source=collection_archive---------1-----------------------#2017-04-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/8583f569af6007682759faabfb87ceb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9N-c3COr6dswpkK6PuCMjg.png"/></div></div></figure><div class=""/><p id="4742" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您熟悉Rest API，那么您一定知道为从客户机获取数据和向服务器发送数据而创建的HTTP调用。如果您希望用PHP创建一个REST API客户端，该怎么办？你的答案是用旋度。CURL是最广泛使用的进行HTTP调用的方法，但是它包含几个复杂的步骤。</p><p id="1e87" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看看PHP中一个简单的CURL请求:</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="4709" class="kj kk if kf b fv kl km l kn ko">$url = “<a class="ae kp" href="https://api.cloudways.com/api/v1" rel="noopener ugc nofollow" target="_blank">https://api.cloudways.com/api/v1</a>”</span><span id="5708" class="kj kk if kf b fv kq km l kn ko">$resource = curl_init($url);</span><span id="0137" class="kj kk if kf b fv kq km l kn ko">curl_setopt($ch, CURLOPT_HTTPHEADER, [‘Accept:application/json, Content-Type:application/json’]);</span><span id="48c5" class="kj kk if kf b fv kq km l kn ko">curl_setopt($ch, CURLOPT_CUSTOMREQUEST, ‘GET’);</span></pre><p id="399b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您需要调用<strong class="je ig"> curl_setopt() </strong>方法来定义头部和特定的HTTP动词，如GET、POST、PUT等。看起来确实很复杂。那么，什么是更好、更强大的替代方案呢？</p><p id="e01d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">来了<a class="ae kp" href="http://docs.guzzlephp.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="je ig">狂饮</strong> </a> <strong class="je ig">。</strong></p><p id="8e6e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看看Guzzle是如何创建请求的:</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="c119" class="kj kk if kf b fv kl km l kn ko">$client = new GuzzleHttp\Client();</span><span id="776b" class="kj kk if kf b fv kq km l kn ko">$res = $client-&gt;request(‘GET’, ‘<a class="ae kp" href="https://api.cloudways.com/api/v1" rel="noopener ugc nofollow" target="_blank">https://api.cloudways.com/api/v1</a>’, [</span><span id="f7a3" class="kj kk if kf b fv kq km l kn ko">‘headers’ =&gt; [</span><span id="dd13" class="kj kk if kf b fv kq km l kn ko">‘Accept’ =&gt; ‘application/json’,</span><span id="c303" class="kj kk if kf b fv kq km l kn ko">‘Content-type’ =&gt; ‘application/json’</span><span id="22ec" class="kj kk if kf b fv kq km l kn ko">]])</span></pre><p id="1d60" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你会发现这很简单。您只需要初始化Guzzle客户端，并给出HTTP动词和一个URL。之后，传递头部数组和其他选项。</p><h2 id="032c" class="kj kk if bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated">了解狂饮客户</h2><p id="e9fe" class="pw-post-body-paragraph jc jd if je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">Guzzle是一个简单PHP HTTP客户端，它提供了一个创建调用和集成web服务的简单方法。它是API用来通过服务器发送消息的标准抽象层。Guzzle的几个突出特点是:</p><ol class=""><li id="594d" class="lp lq if je b jf jg jj jk jn lr jr ls jv lt jz lu lv lw lx dt translated">Guzzle可以发送同步和异步请求。</li><li id="a164" class="lp lq if je b jf ly jj lz jn ma jr mb jv mc jz lu lv lw lx dt translated">它提供了一个简单的接口，用于构建查询字符串、POST请求、流式大型上传和下载、上传JSON数据等。</li><li id="a35b" class="lp lq if je b jf ly jj lz jn ma jr mb jv mc jz lu lv lw lx dt translated">允许使用与Guzzle兼容的其他PSR7库。</li><li id="ccbe" class="lp lq if je b jf ly jj lz jn ma jr mb jv mc jz lu lv lw lx dt translated">允许您编写与环境和传输无关的代码。</li><li id="a0d8" class="lp lq if je b jf ly jj lz jn ma jr mb jv mc jz lu lv lw lx dt translated">中间件系统允许您增加和组合客户端行为。</li></ol><h2 id="914f" class="kj kk if bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated">在PHP中安装Guzzle</h2><p id="9aa6" class="pw-post-body-paragraph jc jd if je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">安装Guzzle的首选方式是Composer。如果您还没有安装Composer，请从这里的<a class="ae kp" href="https://getcomposer.org/download/" rel="noopener ugc nofollow" target="_blank">下载</a></p><p id="aeb6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在要安装Guzzle，在SSH终端中运行以下命令:</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="44f1" class="kj kk if kf b fv kl km l kn ko"><strong class="kf ig">composer require guzzlehttp/guzzle</strong></span></pre><p id="05b0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个命令将在你的PHP项目中安装最新版本的Guzzle。或者，您也可以在<strong class="je ig"> composer.json </strong>文件中将其定义为一个依赖项，并在其中添加以下代码。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="ee89" class="kj kk if kf b fv kl km l kn ko">{<br/> “require”<strong class="kf ig">:</strong> {<br/> “guzzlehttp/guzzle”<strong class="kf ig">:</strong> “~6.0”<br/> }<br/>}</span></pre><p id="ea0d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">之后，运行<strong class="je ig"> composer install </strong>命令。最后，您需要要求自动加载程序，并添加一些更多的文件来使用Guzzle:</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="e70b" class="kj kk if kf b fv kl km l kn ko">require ‘vendor/autoload.php’;</span><span id="078d" class="kj kk if kf b fv kq km l kn ko">use GuzzleHttp\Client;</span><span id="2f58" class="kj kk if kf b fv kq km l kn ko">use GuzzleHttp\Exception\RequestException;</span><span id="f7a9" class="kj kk if kf b fv kq km l kn ko">use GuzzleHttp\Psr7\Request;</span></pre><p id="04ff" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">安装过程已经结束，现在是时候使用一个用API创建HTTP调用的真实例子了。出于本文的目的，我将使用<a class="ae kp" href="https://developers.cloudways.com/" rel="noopener ugc nofollow" target="_blank"> Cloudways API </a>。</p><h2 id="1eb6" class="kj kk if bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated">使用Cloudways API可以做什么</h2><p id="409d" class="pw-post-body-paragraph jc jd if je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">Cloudways是PHP、Magento、WordPress和许多其他框架和CMS的托管提供商。它有一个API，可以用来在服务器和应用程序上执行CRUD操作。查看Cloudways API 的流行用例，看看如何将它集成到您的项目中。</p><p id="a97a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在本文中，我将创建HTTP调用来在Cloudways服务器上使用Guzzle执行特定的操作。</p><h2 id="be96" class="kj kk if bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated">在Guzzle中创建HTTP请求</h2><p id="57f9" class="pw-post-body-paragraph jc jd if je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">正如我前面提到的，在Guzzle中创建HTTP请求非常容易；您只需要传递基本URI、HTTP谓词和头。如果外部API中有认证层，也可以在Guzzle中传递这些参数。类似地，Cloudways API需要电子邮件和API密钥来认证用户并发送响应。你需要<a class="ae kp" href="https://platform.cloudways.com/" rel="noopener ugc nofollow" target="_blank">注册</a>一个Cloudways账户来获得你的API证书。</p><p id="3346" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们首先创建一个CloudwaysAPIClient.php的<strong class="je ig">文件来设置进行HTTP调用的Guzzle。我还将创建一个类和几个使用HTTP调用的方法。</strong></p><p id="07be" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">API的URL没有改变，所以我将使用<strong class="je ig"> const </strong>数据类型。稍后，我将把它与其他URL后缀连接起来以获得响应。此外，我已经声明了变量<strong class="je ig"> $auth_key，$auth_email </strong>，它将保存认证电子邮件和API密钥。<strong class="je ig"> $accessToken </strong>将保存临时令牌，每次都会更新。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="3db4" class="kj kk if kf b fv kl km l kn ko">Class CloudwaysAPIClient</span><span id="0583" class="kj kk if kf b fv kq km l kn ko">{</span><span id="257e" class="kj kk if kf b fv kq km l kn ko">private $client = null;</span><span id="985e" class="kj kk if kf b fv kq km l kn ko">const API_URL = “https://api.cloudways.com/api/v1";</span><span id="8314" class="kj kk if kf b fv kq km l kn ko">var $auth_key;</span><span id="0cc9" class="kj kk if kf b fv kq km l kn ko">var $auth_email;</span><span id="976d" class="kj kk if kf b fv kq km l kn ko">var $accessToken;</span><span id="554d" class="kj kk if kf b fv kq km l kn ko">public function __construct($email,$key)</span><span id="0542" class="kj kk if kf b fv kq km l kn ko">{</span><span id="a12d" class="kj kk if kf b fv kq km l kn ko">$this-&gt;auth_email = $email;</span><span id="7e8a" class="kj kk if kf b fv kq km l kn ko">$this-&gt;auth_key = $key;</span><span id="c284" class="kj kk if kf b fv kq km l kn ko">$this-&gt;client = new Client();</span><span id="d66a" class="kj kk if kf b fv kq km l kn ko">}</span><span id="abcb" class="kj kk if kf b fv kq km l kn ko">}</span></pre><h2 id="f747" class="kj kk if bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated">创建Post请求以获取访问令牌</h2><p id="e4cb" class="pw-post-body-paragraph jc jd if je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">每次我访问API时，都会从这个URL:<a class="ae kp" href="https://api.cloudways.com/api/v1/oauth/access_token" rel="noopener ugc nofollow" target="_blank"><strong class="je ig">https://api.cloudways.com/api/v1/oauth/access_token</strong></a><strong class="je ig"/>生成访问令牌。这将在<strong class="je ig"> $url </strong>中设置，带有保存身份验证凭证的附加数据数组。后来，我用基本URL和查询字符串创建了一个<strong class="je ig"> POST </strong>请求。将对响应进行解码，并保存访问令牌以在方法中使用。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="13d0" class="kj kk if kf b fv kl km l kn ko">public function prepare_access_token()</span><span id="a4a0" class="kj kk if kf b fv kq km l kn ko">{</span><span id="2c34" class="kj kk if kf b fv kq km l kn ko">try</span><span id="380e" class="kj kk if kf b fv kq km l kn ko">{</span><span id="96ca" class="kj kk if kf b fv kq km l kn ko">$url = self::API_URL . “/oauth/access_token”;</span><span id="bcce" class="kj kk if kf b fv kq km l kn ko">$data = [‘email’ =&gt; $this-&gt;auth_email,’api_key’ =&gt; $this-&gt;auth_key];</span><span id="768f" class="kj kk if kf b fv kq km l kn ko">$response = $this-&gt;client-&gt;post($url, [‘query’ =&gt; $data]);</span><span id="96cd" class="kj kk if kf b fv kq km l kn ko">$result = json_decode($response-&gt;getBody()-&gt;getContents());</span><span id="e9e0" class="kj kk if kf b fv kq km l kn ko">$this-&gt;accessToken = $result-&gt;access_token;</span><span id="6edb" class="kj kk if kf b fv kq km l kn ko">}</span><span id="3f25" class="kj kk if kf b fv kq km l kn ko">catch (RequestException $e)</span><span id="ea6b" class="kj kk if kf b fv kq km l kn ko">{</span><span id="d197" class="kj kk if kf b fv kq km l kn ko">$response = $this-&gt;StatusCodeHandling($e);</span><span id="50ed" class="kj kk if kf b fv kq km l kn ko">return $response;</span><span id="d93c" class="kj kk if kf b fv kq km l kn ko">}</span><span id="ae4e" class="kj kk if kf b fv kq km l kn ko">}</span></pre><p id="8b38" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里完成了获取访问令牌的<strong class="je ig"> POST </strong>请求。此外，如果您在异常处理中观察到，我声明了一个方法<strong class="je ig"> StatusCodeHandling($e)，</strong>，它将处理响应代码(HTTP代码，如404、401、200等)，并抛出一个相关的异常。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="da0f" class="kj kk if kf b fv kl km l kn ko">public function StatusCodeHandling($e)</span><span id="ff4e" class="kj kk if kf b fv kq km l kn ko">{</span><span id="472a" class="kj kk if kf b fv kq km l kn ko">if ($e-&gt;getResponse()-&gt;getStatusCode() == ‘400’)</span><span id="83cf" class="kj kk if kf b fv kq km l kn ko">{</span><span id="ce1e" class="kj kk if kf b fv kq km l kn ko">$this-&gt;prepare_access_token();</span><span id="e8b9" class="kj kk if kf b fv kq km l kn ko">}</span><span id="f9ef" class="kj kk if kf b fv kq km l kn ko">elseif ($e-&gt;getResponse()-&gt;getStatusCode() == ‘422’)</span><span id="a98f" class="kj kk if kf b fv kq km l kn ko">{</span><span id="e194" class="kj kk if kf b fv kq km l kn ko">$response = json_decode($e-&gt;getResponse()-&gt;getBody(true)-&gt;getContents());</span><span id="906c" class="kj kk if kf b fv kq km l kn ko">return $response;</span><span id="1ffa" class="kj kk if kf b fv kq km l kn ko">}</span><span id="77eb" class="kj kk if kf b fv kq km l kn ko">elseif ($e-&gt;getResponse()-&gt;getStatusCode() == ‘500’)</span><span id="bad1" class="kj kk if kf b fv kq km l kn ko">{</span><span id="ed71" class="kj kk if kf b fv kq km l kn ko">$response = json_decode($e-&gt;getResponse()-&gt;getBody(true)-&gt;getContents());</span><span id="7b6c" class="kj kk if kf b fv kq km l kn ko">return $response;</span><span id="1182" class="kj kk if kf b fv kq km l kn ko">}</span><span id="39f4" class="kj kk if kf b fv kq km l kn ko">elseif ($e-&gt;getResponse()-&gt;getStatusCode() == ‘401’)</span><span id="de1a" class="kj kk if kf b fv kq km l kn ko">{</span><span id="e2b8" class="kj kk if kf b fv kq km l kn ko">$response = json_decode($e-&gt;getResponse()-&gt;getBody(true)-&gt;getContents());</span><span id="de5f" class="kj kk if kf b fv kq km l kn ko">return $response;</span><span id="9f3f" class="kj kk if kf b fv kq km l kn ko">}</span><span id="336e" class="kj kk if kf b fv kq km l kn ko">elseif ($e-&gt;getResponse()-&gt;getStatusCode() == ‘403’)</span><span id="a448" class="kj kk if kf b fv kq km l kn ko">{</span><span id="f728" class="kj kk if kf b fv kq km l kn ko">$response = json_decode($e-&gt;getResponse()-&gt;getBody(true)-&gt;getContents());</span><span id="06bb" class="kj kk if kf b fv kq km l kn ko">return $response;</span><span id="7b88" class="kj kk if kf b fv kq km l kn ko">}</span><span id="8f75" class="kj kk if kf b fv kq km l kn ko">else</span><span id="63a1" class="kj kk if kf b fv kq km l kn ko">{</span><span id="60c3" class="kj kk if kf b fv kq km l kn ko">$response = json_decode($e-&gt;getResponse()-&gt;getBody(true)-&gt;getContents());</span><span id="b2ca" class="kj kk if kf b fv kq km l kn ko">return $response;</span><span id="e318" class="kj kk if kf b fv kq km l kn ko">}</span><span id="67f1" class="kj kk if kf b fv kq km l kn ko">}</span></pre><p id="7505" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">主客户端类现在已经完成。我将扩展它，为不同的情况创建更多的HTTP请求。</p><h2 id="1705" class="kj kk if bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated">创建获取所有服务器的GET请求</h2><p id="ec02" class="pw-post-body-paragraph jc jd if je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">一旦用户通过身份验证，我就可以从Cloudways获取我所有的服务器和应用程序。<strong class="je ig"> /server </strong>是与基本URI连接的后缀。这一次，我将在Guzzle头中附加带有<strong class="je ig">授权</strong>字符串的<strong class="je ig"> accessToken </strong>来获取JSON响应中的所有服务器。为此，创建一个新方法:</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="8224" class="kj kk if kf b fv kl km l kn ko">Public function get_servers()</span><span id="4b2c" class="kj kk if kf b fv kq km l kn ko">{</span><span id="a306" class="kj kk if kf b fv kq km l kn ko">try</span><span id="be88" class="kj kk if kf b fv kq km l kn ko">{</span><span id="12b1" class="kj kk if kf b fv kq km l kn ko">$url = self::API_URL . “/server”;</span><span id="e455" class="kj kk if kf b fv kq km l kn ko">$option = array(‘exceptions’ =&gt; false);</span><span id="c428" class="kj kk if kf b fv kq km l kn ko">$header = array(‘Authorization’=&gt;’Bearer ‘ . $this-&gt;accessToken);</span><span id="6984" class="kj kk if kf b fv kq km l kn ko">$response = $this-&gt;client-&gt;get($url, array(‘headers’ =&gt; $header));</span><span id="848b" class="kj kk if kf b fv kq km l kn ko">$result = $response-&gt;getBody()-&gt;getContents();</span><span id="b375" class="kj kk if kf b fv kq km l kn ko">return $result;</span><span id="f3b3" class="kj kk if kf b fv kq km l kn ko">}</span><span id="8b35" class="kj kk if kf b fv kq km l kn ko">catch (RequestException $e)</span><span id="7278" class="kj kk if kf b fv kq km l kn ko">{</span><span id="599c" class="kj kk if kf b fv kq km l kn ko">$response = $this-&gt;StatusCodeHandling($e);</span><span id="16ba" class="kj kk if kf b fv kq km l kn ko">return $response;</span><span id="ffb3" class="kj kk if kf b fv kq km l kn ko">}</span><span id="7403" class="kj kk if kf b fv kq km l kn ko">}</span></pre><p id="d4a9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在创建<strong class="je ig">index.php</strong>文件，并在顶部包含<strong class="je ig">CloudwaysAPIClient.php</strong>。接下来，我将声明我的API键和电子邮件，将其传递给类构造函数，以最终获得服务器。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="3baf" class="kj kk if kf b fv kl km l kn ko">include ‘CloudwaysAPIClient.php’;</span><span id="4be6" class="kj kk if kf b fv kq km l kn ko">$api_key = ‘W9bqKxxxxxxxxxxxxxxxxxxxjEfY0’;</span><span id="325d" class="kj kk if kf b fv kq km l kn ko">$email = ‘shahroze.nawaz@cloudways.com’;</span><span id="4f3d" class="kj kk if kf b fv kq km l kn ko">$cw_api = new CloudwaysAPIClient($email,$api_key);</span><span id="8885" class="kj kk if kf b fv kq km l kn ko">$servers = $cw_api-&gt;get_servers();</span><span id="4b78" class="kj kk if kf b fv kq km l kn ko">echo ‘&lt;pre&gt;’;</span><span id="6bc3" class="kj kk if kf b fv kq km l kn ko">var_dump($servers);</span><span id="0186" class="kj kk if kf b fv kq km l kn ko">echo ‘&lt;/pre&gt;’;</span></pre><p id="ef41" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们在Postman中测试它，以验证信息和正确的响应代码正在被获取。</p><figure class="ka kb kc kd fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff md"><img src="../Images/c16643ef82d0abedb60e2beb1db482ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*67IO8OPa2CqVN_XOBdff8Q.png"/></div></div></figure><p id="b529" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以我所有托管在Cloudways平台上的服务器都被取出来了。类似地，您可以使用HTTP调用创建新的方法来获取应用程序、服务器设置、服务等。</p><p id="ea07" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们创建一个<strong class="je ig"> PUT </strong>调用来改变目前被<strong class="je ig">克隆的服务器标签——PHP应用程序</strong>。但是首先，我需要获得服务器ID标签，因为这个信息将被用作参数。要获得服务器ID，在<strong class="je ig">index.php</strong>文件中创建一个<strong class="je ig"> foreach </strong>循环:</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="7aa0" class="kj kk if kf b fv kl km l kn ko"><strong class="kf ig">foreach($servers-&gt;servers as $server){</strong></span><span id="2e6a" class="kj kk if kf b fv kq km l kn ko"><strong class="kf ig">echo $server-&gt;id;</strong></span><span id="b3bd" class="kj kk if kf b fv kq km l kn ko"><strong class="kf ig">echo $server-&gt;label;</strong></span><span id="1315" class="kj kk if kf b fv kq km l kn ko"><strong class="kf ig">}</strong></span></pre><p id="c8cf" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，如果我点击API，它将获取服务器id和标签。</p><figure class="ka kb kc kd fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff me"><img src="../Images/2f43ac008fb4081c5a47404738469440.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-lpI1dadZj_Q51Hs2Y2NrA.png"/></div></div></figure><h2 id="bc72" class="kj kk if bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated">创建一个PUT请求来更改服务器标签</h2><p id="8086" class="pw-post-body-paragraph jc jd if je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">现在要更改服务器标签，我需要在Guzzle中创建一个PUT调用。我将用一个新方法扩展这个类。记住，服务器id和标签是将在方法中传递的两个必要参数。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="936a" class="kj kk if kf b fv kl km l kn ko"><strong class="kf ig">public function changelabel($serverid,$label)</strong></span><span id="10cf" class="kj kk if kf b fv kq km l kn ko"><strong class="kf ig">{</strong></span><span id="0592" class="kj kk if kf b fv kq km l kn ko"><strong class="kf ig">try</strong></span><span id="6aba" class="kj kk if kf b fv kq km l kn ko"><strong class="kf ig">{</strong></span><span id="1188" class="kj kk if kf b fv kq km l kn ko"><strong class="kf ig">$url = self::API_URL . “/server/$serverid”;</strong></span><span id="0675" class="kj kk if kf b fv kq km l kn ko"><strong class="kf ig">$data = [‘server_id’ =&gt; $serverid,’label’ =&gt; $label];</strong></span><span id="4580" class="kj kk if kf b fv kq km l kn ko"><strong class="kf ig">$header = array(‘Authorization’=&gt;’Bearer ‘ . $this-&gt;accessToken);</strong></span><span id="5793" class="kj kk if kf b fv kq km l kn ko"><strong class="kf ig">$response = $this-&gt;client-&gt;put($url, array(‘query’ =&gt; $data,’headers’ =&gt; $header));</strong></span><span id="96a2" class="kj kk if kf b fv kq km l kn ko"><strong class="kf ig">return json_decode($response-&gt;getBody()-&gt;getContents());</strong></span><span id="e46c" class="kj kk if kf b fv kq km l kn ko"><strong class="kf ig">}</strong></span><span id="4325" class="kj kk if kf b fv kq km l kn ko"><strong class="kf ig">catch (RequestException $e)</strong></span><span id="e160" class="kj kk if kf b fv kq km l kn ko"><strong class="kf ig">{</strong></span><span id="1a4e" class="kj kk if kf b fv kq km l kn ko"><strong class="kf ig">$response = $this-&gt;StatusCodeHandling($e);</strong></span><span id="a4a2" class="kj kk if kf b fv kq km l kn ko"><strong class="kf ig">return $response;</strong></span><span id="676a" class="kj kk if kf b fv kq km l kn ko"><strong class="kf ig">}</strong></span><span id="c9f2" class="kj kk if kf b fv kq km l kn ko"><strong class="kf ig">}</strong></span></pre><p id="e035" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在在<strong class="je ig">index.php中，</strong>将这个条件放在<strong class="je ig"> foreach </strong>循环下面。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="b19b" class="kj kk if kf b fv kl km l kn ko"><strong class="kf ig">if($server-&gt;id == ‘71265’ &amp;&amp; $server-&gt;label == ‘Cloned-php applications’){</strong></span><span id="b70f" class="kj kk if kf b fv kq km l kn ko"><strong class="kf ig">$label = ‘Cloudways Server’;</strong></span><span id="71c8" class="kj kk if kf b fv kq km l kn ko"><strong class="kf ig">$changelabel = $cw_api-&gt;changelabel($server-&gt;id,$label);</strong></span><span id="73ad" class="kj kk if kf b fv kq km l kn ko"><strong class="kf ig">}</strong></span></pre><p id="d0bf" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当在Postman中测试时，我将获得更新的服务器标签。</p><figure class="ka kb kc kd fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mf"><img src="../Images/06801e050d2901e9808e759e2461b4b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ZDP0TnRK57UEb1SW2oETA.png"/></div></div></figure><h2 id="6153" class="kj kk if bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated">创建删除服务器的删除请求</h2><p id="80cb" class="pw-post-body-paragraph jc jd if je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">要使用Cloudways API删除服务器，我需要通过下面的方法在Guzzle中创建一个<strong class="je ig"> Delete </strong>请求。这与上面的方法非常相似，因为它也需要两个参数，服务器id和标签。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="ed42" class="kj kk if kf b fv kl km l kn ko">public function deleteServer($serverid,$label)</span><span id="c706" class="kj kk if kf b fv kq km l kn ko">{</span><span id="5b3f" class="kj kk if kf b fv kq km l kn ko">try</span><span id="c80f" class="kj kk if kf b fv kq km l kn ko">{</span><span id="d667" class="kj kk if kf b fv kq km l kn ko">$url = self::API_URL . “/server/$serverid”;</span><span id="98f6" class="kj kk if kf b fv kq km l kn ko">$data = [‘server_id’ =&gt; $serverid,’label’ =&gt; $label];</span><span id="7003" class="kj kk if kf b fv kq km l kn ko">$header = array(‘Authorization’=&gt;’Bearer ‘ . $this-&gt;accessToken);</span><span id="dec3" class="kj kk if kf b fv kq km l kn ko">$response = $this-&gt;client-&gt;delete($url, array(‘query’ =&gt; $data,’headers’ =&gt; $header));</span><span id="2d26" class="kj kk if kf b fv kq km l kn ko">return json_decode($response-&gt;getBody()-&gt;getContents());</span><span id="2eeb" class="kj kk if kf b fv kq km l kn ko">}</span><span id="8edf" class="kj kk if kf b fv kq km l kn ko">catch (RequestException $e)</span><span id="0ad7" class="kj kk if kf b fv kq km l kn ko">{</span><span id="4ad6" class="kj kk if kf b fv kq km l kn ko">$response = $this-&gt;StatusCodeHandling($e);</span><span id="efac" class="kj kk if kf b fv kq km l kn ko">return $response;</span><span id="26b8" class="kj kk if kf b fv kq km l kn ko">}</span><span id="dd9a" class="kj kk if kf b fv kq km l kn ko">}</span></pre><p id="9129" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Postman中尝试一下，或者刷新页面。该服务器将被删除。</p><h2 id="fc44" class="kj kk if bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated">最后的话</h2><p id="d6a3" class="pw-post-body-paragraph jc jd if je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">Guzzle是一个灵活的HTTP客户端，您可以根据自己的需求进行扩展。您还可以尝试上传数据、表单域、cookies、重定向和异常的新想法。您还可以为身份验证层创建中间件(如果需要)。总而言之，Guzzle是在PHP中创建REST API的一个很好的选择，不需要使用任何框架。</p><p id="aeea" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您有任何问题或疑问，可以在下面评论。</p><figure class="ka kb kc kd fq hw"><div class="bz el l di"><div class="mg mh l"/></div></figure></div></div>    
</body>
</html>