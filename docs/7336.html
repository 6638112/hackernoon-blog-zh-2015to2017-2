<html>
<head>
<title>Simplified JavaScript: Hoisting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简化的JavaScript:提升</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/simplified-javascript-hoisting-9128b74bb397?source=collection_archive---------15-----------------------#2017-10-24">https://medium.com/hackernoon/simplified-javascript-hoisting-9128b74bb397?source=collection_archive---------15-----------------------#2017-10-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/f846996cedfd073345e2743ab15013f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JlnA-Po7xSnbldZyH60Mgw.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">#hoisting</figcaption></figure><p id="2d2a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">提升仍然是<a class="ae ke" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>的古怪之处之一。当<a class="ae ke" href="https://hackernoon.com/tagged/developer" rel="noopener ugc nofollow" target="_blank">开发者</a>在JavaScript中声明一个变量时，那个变量<em class="kf">的行为</em>就好像它已经被提升到了它的可用范围的顶端。本文不打算关注在幕后究竟发生了什么导致了这种行为。相反，我希望提供一个对JavaScript新用户有意义的提升的简单解释。</p><h1 id="f491" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">在ES5中吊装</h1><p id="836d" class="pw-post-body-paragraph jg jh hu ji b jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz li kb kc kd hn dt translated">我花了大约一年半的时间没有真正理解起重。我只是坚持一个通用规则——我总是在文件的顶部声明和赋值我所有的变量。在ES6问世之前，它看起来类似于下面的代码:</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="b8c5" class="ls kh hu lo b fv lt lu l lv lw">var a = 1; <br/>var b = 2; <br/>var c = 3;</span><span id="194e" class="ls kh hu lo b fv lx lu l lv lw">var adder = function (a, b, c) { <br/>  return (a + b + c);<br/>};</span><span id="2033" class="ls kh hu lo b fv lx lu l lv lw">adder(a, b, c); // Returns 6</span></pre><p id="9617" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">上面的代码执行正确，当我运行它时返回数字6。我在顶部声明并赋值我的变量，然后定义一个函数表达式，然后调用我的函数，传入我之前赋值的变量。</p><p id="4311" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">但是当我在顶部声明变量而没有赋值时，我得到了相同的返回值，就像这样:</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="3283" class="ls kh hu lo b fv lt lu l lv lw">var a;<br/>var b;<br/>var c;</span><span id="c5e5" class="ls kh hu lo b fv lx lu l lv lw">var adder = function (a, b, c) {<br/>  console.log(a + b + c);<br/>};</span><span id="74f3" class="ls kh hu lo b fv lx lu l lv lw">a = 1;<br/>b = 2;<br/>c = 3;</span><span id="5f66" class="ls kh hu lo b fv lx lu l lv lw">adder(a, b, c); // Returns 6</span></pre><p id="f23d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">或者我可以在声明之前调用我的函数，我仍然会得到6:</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="b3e2" class="ls kh hu lo b fv lt lu l lv lw">var a = 1;<br/>var b = 2;<br/>var c = 3;</span><span id="0632" class="ls kh hu lo b fv lx lu l lv lw">adder(a, b, c); // Returns 6</span><span id="5ba2" class="ls kh hu lo b fv lx lu l lv lw">function adder(a, b, c) {<br/>  console.log(a + b + c);<br/>};</span></pre><p id="5697" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这里有一个挑战。在您继续阅读之前，请考虑下面的代码，并尝试确定它的计算结果。</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="e762" class="ls kh hu lo b fv lt lu l lv lw">function hoist() {<br/>  a = 1;<br/>  var b = 2;<br/>}<br/><br/>hoist();<br/><br/>console.log(a); <br/><br/>console.log(b);</span></pre><p id="8c32" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">明白了吗？好吧，我把答案分享给你。</p><p id="e1cc" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh ly lz ma lo b">console.log(a)</code>将返回<code class="eh ly lz ma lo b">1</code>。另一方面，<code class="eh ly lz ma lo b">console.log(b)</code>会带着<code class="eh ly lz ma lo b">`ReferenceError: b is not defined`</code>回来。<code class="eh ly lz ma lo b">a</code>和<code class="eh ly lz ma lo b">b</code>都被提升到它们作用域的顶部，但是因为<code class="eh ly lz ma lo b">b</code>是在<code class="eh ly lz ma lo b">hoist()</code>函数内部声明的，所以它对全局作用域不可用。</p></div><div class="ab cl mb mc hc md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hn ho hp hq hr"><h1 id="1779" class="kg kh hu bd ki kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz mm lb lc ld dt translated">ES6中的吊装</h1><p id="966d" class="pw-post-body-paragraph jg jh hu ji b jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz li kb kc kd hn dt translated"><code class="eh ly lz ma lo b">let</code>和<code class="eh ly lz ma lo b">const</code>介绍了一种不同的吊装方式。</p><h2 id="b14c" class="ls kh hu bd ki mn mo mp km mq mr ms kq jr mt mu ku jv mv mw ky jz mx my lc mz dt translated">让</h2><p id="18fa" class="pw-post-body-paragraph jg jh hu ji b jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz li kb kc kd hn dt translated">我们从<code class="eh ly lz ma lo b">let</code>开始。在下面的例子中，我试图记录<code class="eh ly lz ma lo b">hoist</code>变量，然后声明并分配它:</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="2f49" class="ls kh hu lo b fv lt lu l lv lw">console.log(hoist); // ReferenceError: hoist is not defined<br/>let hoist = 'hoisted';</span></pre><p id="936a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在这种情况下，我得到了一个<code class="eh ly lz ma lo b">ReferenceError</code>。这与我写下<code class="eh ly lz ma lo b">var hoist = 'hoisted';</code>时得到的结果不同。那样的话，我早就跟<code class="eh ly lz ma lo b">undefined</code>结束了。</p><p id="4923" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh ly lz ma lo b">var</code>和<code class="eh ly lz ma lo b">let</code>抛出不同的错误，因为JavaScript初始化它们的方式不同。当<code class="eh ly lz ma lo b">var</code>被声明时，JavaScript将其设置为<code class="eh ly lz ma lo b">undefined</code>。另一方面，<code class="eh ly lz ma lo b">let</code>仍未初始化。这样，它抛出一个有用的错误，而不仅仅是返回<code class="eh ly lz ma lo b">undefined</code>。</p><h2 id="9968" class="ls kh hu bd ki mn mo mp km mq mr ms kq jr mt mu ku jv mv mw ky jz mx my lc mz dt translated">常数</h2><p id="aa60" class="pw-post-body-paragraph jg jh hu ji b jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz li kb kc kd hn dt translated">让我们用<code class="eh ly lz ma lo b">const</code>试试这个:</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="927e" class="ls kh hu lo b fv lt lu l lv lw">console.log(hoist); // ReferenceError: hoist is not defined<br/>const hoist = 'hoisted';</span></pre><p id="a60f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">像<code class="eh ly lz ma lo b">let</code>一样，我们得到一个明确的错误，告诉我们<code class="eh ly lz ma lo b">hoist</code>在被调用之前没有被定义。</p></div><div class="ab cl mb mc hc md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hn ho hp hq hr"><h1 id="e157" class="kg kh hu bd ki kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz mm lb lc ld dt translated">功能</h1><p id="2f78" class="pw-post-body-paragraph jg jh hu ji b jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz li kb kc kd hn dt translated">JavaScript将提升函数声明，但不提升函数表达式。我将提供一些例子:</p><h2 id="a389" class="ls kh hu bd ki mn mo mp km mq mr ms kq jr mt mu ku jv mv mw ky jz mx my lc mz dt translated">函数声明</h2><p id="7fe9" class="pw-post-body-paragraph jg jh hu ji b jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz li kb kc kd hn dt translated">如果一个函数被声明但没有被赋值给一个变量，它将被提升到其作用域的顶部。</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="0ceb" class="ls kh hu lo b fv lt lu l lv lw">hoister(); // hoists</span><span id="b592" class="ls kh hu lo b fv lx lu l lv lw">function hoister() {<br/>  console.log('hoists');<br/>};</span></pre><h2 id="6d18" class="ls kh hu bd ki mn mo mp km mq mr ms kq jr mt mu ku jv mv mw ky jz mx my lc mz dt translated">函数表达式</h2><p id="09c9" class="pw-post-body-paragraph jg jh hu ji b jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz li kb kc kd hn dt translated">另一方面，函数表达式不会被提升，所以下面的代码返回一个<code class="eh ly lz ma lo b">TypeError</code>。</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="7b5b" class="ls kh hu lo b fv lt lu l lv lw">hoister(); // TypeError: hoister is not a function</span><span id="6765" class="ls kh hu lo b fv lx lu l lv lw">var hoister = function () { <br/>  console.log('hoists'); <br/>};</span></pre><p id="75ab" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">希望这篇文章能帮助你更好地理解提升。当然，总有更多的东西要学。</p><p id="bf18" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果你有任何问题，请在下面的评论中告诉我，如果你喜欢这篇文章，请鼓掌！</p><h1 id="75d9" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">继续读</h1><ul class=""><li id="611d" class="na nb hu ji b jj le jn lf jr nc jv nd jz ne kd nf ng nh ni dt translated"><a class="ae ke" href="https://scotch.io/tutorials/understanding-hoisting-in-javascript" rel="noopener ugc nofollow" target="_blank">理解JavaScript中的提升</a></li><li id="b5f3" class="na nb hu ji b jj nj jn nk jr nl jv nm jz nn kd nf ng nh ni dt translated"><a class="ae ke" href="https://developer.mozilla.org/en-US/docs/Glossary/Hoisting" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></li></ul><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="no np l"/></div></figure></div></div>    
</body>
</html>