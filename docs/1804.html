<html>
<head>
<title>An artificial example where MobX really shines and Redux is not really suited for it</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个人为的例子，MobX确实很出色，而Redux并不真正适合它</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/an-artificial-example-where-mobx-really-shines-and-redux-is-not-really-suited-for-it-1a58313c0c70?source=collection_archive---------0-----------------------#2016-12-09">https://medium.com/hackernoon/an-artificial-example-where-mobx-really-shines-and-redux-is-not-really-suited-for-it-1a58313c0c70?source=collection_archive---------0-----------------------#2016-12-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="19d4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，提醒一句。在这篇文章中，我不是说MobX更好，或者我更喜欢它，或者任何东西。</p><p id="6ce7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Redux和MobX我都用。</p><p id="9d4a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我喜欢他们两个，可能会再次使用他们两个。</p><p id="7fea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本文<strong class="it hv">仅</strong>给出了一个<strong class="it hv">人工示例</strong>一个应用程序，如果我们需要它在相同的<strong class="it hv">性能水平上运行，那么用MobX很容易编写，但用Redux很难。</strong>如果我没有说清楚，<strong class="it hv">这是一个不公平的比较。</strong></p><p id="52ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，这篇文章根本不是一个全面的比较，不应该被认为是基于现实世界的情况。所以请不要指着一个像这样的人造基准说“让我们都用<em class="jp">这个</em>而不是<em class="jp">那个</em>。快了<em class="jp">。</em></p><p id="b2f8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我不相信有一个最好的工具。我相信每个工具都有自己的闪光点和不擅长的地方。</p><p id="c3cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">凡事都有个时间。我做这种实验是为了更好地了解我使用的工具，这样我就可以在未来为正确的工作选择正确的工具。</p><p id="1730" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">说完了，我们继续。</p></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><h1 id="6bb8" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">版本</h1><p id="691b" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">就像JavaScript世界中的其他事情一样，我相信随着事情的进一步优化，这篇文章会很快过时。这就是为什么我要在这里列出版本号:</p><ul class=""><li id="38f7" class="la lb hu it b iu iv iy iz jc lc jg ld jk le jo lf lg lh li dt translated"><code class="eh lj lk ll lm b">react@15.4.1</code>，<code class="eh lj lk ll lm b">react-dom@15.4.1</code></li><li id="307b" class="la lb hu it b iu ln iy lo jc lp jg lq jk lr jo lf lg lh li dt translated"><code class="eh lj lk ll lm b">redux@3.6.0</code>，<code class="eh lj lk ll lm b">react-redux@5.0.0-rc.1</code></li><li id="cdc9" class="la lb hu it b iu ln iy lo jc lp jg lq jk lr jo lf lg lh li dt translated"><code class="eh lj lk ll lm b">mobx@2.6.4</code>，<code class="eh lj lk ll lm b">mobx-react@4.0.3</code></li></ul></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><h1 id="f320" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">任务:像素绘画</h1><p id="d40c" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">我将使用React创建一个<strong class="it hv">【像素绘画】</strong>应用程序。它有一个画布，在128×128的网格上显示可绘制的像素。</p><p id="3aec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以用鼠标悬停在任何像素上进行绘画。</p><p id="87ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将并排渲染两张画布，但两张画布共享同一个图像。否则，每个像素都可以使用自己的本地组件状态，我们根本不需要使用任何状态管理库。</p><figure class="lt lu lv lw fq lx fe ff paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="fe ff ls"><img src="../Images/630b785c263c1be3485fa0689e3e04d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*YphdwIFmwhtLIzepamN30Q.gif"/></div></div></figure><p id="e176" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每个像素由一个<code class="eh lj lk ll lm b">&lt;div&gt;</code>表示。</p><p id="fc72" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以要渲染和更新128×128×2=32768个DOM节点。</p><p id="81f8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个实验将会非常缓慢。</p><p id="cd93" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">注意:</strong>所有测试都是在生产版本上进行的。</p></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><h1 id="efce" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">MobX版本</h1><p id="f903" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">这是商店。(我在避免修饰语法，因为在撰写本文时，语法<a class="ae me" href="https://github.com/babel/babel/issues/2645" rel="noopener ugc nofollow" target="_blank">正在等待提案</a>。)</p><pre class="lt lu lv lw fq mf lm mg mh aw mi dt"><span id="6c89" class="mj jy hu lm b fv mk ml l mm mn"><strong class="lm hv">const</strong> store = observable({<br/>  pixels: asMap({ }),<br/>  isActive (i, j) {<br/>    <strong class="lm hv">return</strong> !!store.pixels.get(i + ',' + j)<br/>  },<br/>  toggle: action(<strong class="lm hv">function</strong> toggle (i, j) {<br/>    store.pixels.set(i + ',' + j, !store.isActive(i, j))<br/>  })<br/>})</span></pre><p id="c27a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的画布渲染每个像素。</p><pre class="lt lu lv lw fq mf lm mg mh aw mi dt"><span id="14ac" class="mj jy hu lm b fv mk ml l mm mn"><strong class="lm hv">function</strong> MobXCanvas () {<br/>  <strong class="lm hv">const</strong> items = [ ]<br/>  <strong class="lm hv">for</strong> (<strong class="lm hv">let</strong> i = 0; i &lt; 128; i++) {<br/>    <strong class="lm hv">for</strong> (<strong class="lm hv">let</strong> j = 0; j &lt; 128; j++) {<br/>      items.push(&lt;PixelContainer i={i} j={j} key={i + ',' + j} /&gt;)<br/>    }<br/>  }<br/>  <strong class="lm hv">return</strong> &lt;div&gt;{items}&lt;/div&gt;<br/>}</span></pre><p id="d44f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每个像素在存储中观察自己的状态。</p><pre class="lt lu lv lw fq mf lm mg mh aw mi dt"><span id="6182" class="mj jy hu lm b fv mk ml l mm mn"><strong class="lm hv">const</strong> PixelContainer = observer(<strong class="lm hv">function</strong> PixelContainer ({ i, j }) {<br/>  <strong class="lm hv">return</strong> &lt;Pixel<br/>    i={i}<br/>    j={j}<br/>    active={store.isActive(i, j)}<br/>    onToggle={() =&gt; store.toggle(i, j)}<br/>  /&gt;<br/>})</span></pre><p id="0731" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae me" href="https://dtinth.github.io/pixelpaint/?experiment=MobXCanvas" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">结果来了。</strong> </a>可以进入屏幕右上角的<code class="eh lj lk ll lm b"><a class="ae me" href="https://github.com/mobxjs/mobx-react-devtools" rel="noopener ugc nofollow" target="_blank">mobx-react-devtools</a></code>。</p><p id="5bf9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是分析应用程序性能的结果:</p><figure class="lt lu lv lw fq lx fe ff paragraph-image"><div class="fe ff mo"><img src="../Images/c212cb33d1a551def3beff5dd59d5861.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*A4WSez9ETvs8bGUXxtDuOg.png"/></div></figure><p id="3fa1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在上面的饼图中，脚本只占一小部分。大部分时间花在渲染和绘画上。</p><p id="5b50" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以这意味着MobX正在尽最大努力！</p></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><h1 id="8520" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">Redux版本:首次尝试</h1><p id="f715" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">这是减速器:</p><pre class="lt lu lv lw fq mf lm mg mh aw mi dt"><span id="b7b3" class="mj jy hu lm b fv mk ml l mm mn"><strong class="lm hv">const</strong> store = createStore((state = Immutable.Map(), action) =&gt; {<br/>  <strong class="lm hv">if</strong> (action.type === 'TOGGLE') {<br/>    <strong class="lm hv">const</strong> key = action.i + ',' + action.j<br/>    <strong class="lm hv">return</strong> state.set(key, !state.get(key))<br/>  }<br/>  <strong class="lm hv">return</strong> state<br/>})</span></pre><p id="601a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">选择器:</p><pre class="lt lu lv lw fq mf lm mg mh aw mi dt"><span id="0752" class="mj jy hu lm b fv mk ml l mm mn"><strong class="lm hv">const</strong> selectActive = (state, i, j) =&gt; state.get(i + ',' + j)</span></pre><p id="5fe0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">动作创建者:</p><pre class="lt lu lv lw fq mf lm mg mh aw mi dt"><span id="422f" class="mj jy hu lm b fv mk ml l mm mn"><strong class="lm hv">const</strong> toggle = (i, j) =&gt; ({ type: 'TOGGLE', i, j })</span></pre><p id="fb5a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的Redux商店准备好了。</p><p id="a8d1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的画布为每个像素提供了<code class="eh lj lk ll lm b">store</code>:</p><pre class="lt lu lv lw fq mf lm mg mh aw mi dt"><span id="fbbf" class="mj jy hu lm b fv mk ml l mm mn"><strong class="lm hv">function</strong> ReduxCanvas () {<br/>  <strong class="lm hv">const</strong> items = [ ]<br/>  <strong class="lm hv">for</strong> (<strong class="lm hv">let</strong> i = 0; i &lt; 128; i++) {<br/>    <strong class="lm hv">for</strong> (<strong class="lm hv">let</strong> j = 0; j &lt; 128; j++) {<br/>      items.push(&lt;PixelContainer i={i} j={j} key={i + ',' + j} /&gt;)<br/>    }<br/>  }<br/>  <strong class="lm hv">return</strong> &lt;Provider store={store}&gt;<br/>    &lt;div&gt;<br/>      {items}<br/>    &lt;/div&gt;<br/>  &lt;/Provider&gt;<br/>}</span></pre><p id="adc3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每个像素的T2对应于那个T3。</p><pre class="lt lu lv lw fq mf lm mg mh aw mi dt"><span id="093d" class="mj jy hu lm b fv mk ml l mm mn"><strong class="lm hv">const</strong> PixelContainer = connect(<br/>  (state, ownProps) =&gt; ({<br/>    active: selectActive(state, ownProps.i, ownProps.j)<br/>  }),<br/>  (dispatch, ownProps) =&gt; ({<br/>    onToggle: () =&gt; dispatch(toggle(ownProps.i, ownProps.j))<br/>  })<br/>)(Pixel)</span></pre><p id="340e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae me" href="https://dtinth.github.io/pixelpaint/?experiment=ReduxCanvas" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">下面是结果</strong> </a> <strong class="it hv">。</strong>你可以用<code class="eh lj lk ll lm b">redux-devtools-extension</code>来查看店铺状态、行动，还可以做一些时间旅行。</p><p id="1048" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好像这个版本比MobX的版本慢很多。让我们看看侧写。</p><figure class="lt lu lv lw fq lx fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/ae4ffc996742c63a8e1d9c9583f87527.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*T03ztEDkX76Z9Wv0uD2oNw.png"/></div></figure><p id="7dd8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">运行JavaScript花费了大量时间。</strong>差不多50%。这可不好。为什么要花这么长时间？</p><p id="9e11" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们做一些分析:</p><figure class="lt lu lv lw fq lx fe ff paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="fe ff mq"><img src="../Images/682446e8237eae6faf8c9d77bd25a23f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1t3i2Tz-8iXFrejqqhsp6A.png"/></div></div></figure><p id="271e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">原来Redux的订阅模式就是这么运作的。</p><p id="7c85" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在上面的例子中，每个像素都被<code class="eh lj lk ll lm b">connect</code>存储，这意味着它订阅了存储。当它改变时，每个订户决定它是否对该改变感兴趣，并做出相应的反应。</p><p id="363d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这意味着当我改变一个像素时，Redux会通知所有32，768个用户。</p><p id="1bf8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">与Angular 1的<em class="jp">检污机构</em>相同。而且它的建议对Redux也成立:<em class="jp">不要在屏幕上渲染太多东西。</em></p><p id="0789" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">使用Redux，只能整体订阅店铺。你不能订阅你的状态的子树，因为那个子树只是一个普通的旧JavaScript对象，不能被订阅。</strong></p><p id="5393" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有了MobX，每一个状态都是可观察的。因此，在MobX版本中，每个像素都订阅自己的状态子树。所以从第一次尝试就这么快。</p></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><h1 id="12d9" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">第二次尝试:单一订户</h1><p id="d0b4" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">因此，太多的用户可能是一个问题。所以这一次，我会让它只有一个订户。</p><p id="e20f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里，我们创建了一个<code class="eh lj lk ll lm b">Canvas</code>组件，它将订阅存储并呈现所有像素。</p><pre class="lt lu lv lw fq mf lm mg mh aw mi dt"><span id="918a" class="mj jy hu lm b fv mk ml l mm mn"><strong class="lm hv">function</strong> ReduxCanvas () {<br/>  return &lt;Provider store={store}&gt;&lt;Canvas /&gt;&lt;/Provider&gt;<br/>}</span><span id="d0f8" class="mj jy hu lm b fv mr ml l mm mn"><strong class="lm hv">const</strong> Canvas = connect(<br/>  (state) =&gt; ({ state }),<br/>  (dispatch) =&gt; ({ onToggle: (i, j) =&gt; dispatch(toggle(i, j)) })<br/>)(<strong class="lm hv">function</strong> Canvas ({ state, onToggle }) {<br/>  <strong class="lm hv">const</strong> items = [ ]<br/>  <strong class="lm hv">for</strong> (<strong class="lm hv">let</strong> i = 0; i &lt; 128; i++) {<br/>    <strong class="lm hv">for</strong> (<strong class="lm hv">let</strong> j = 0; j &lt; 128; j++) {<br/>      items.push(&lt;PixelContainer<br/>        i={i}<br/>        j={j}<br/>        active={selectActive(state, i, j)}<br/>        onToggle={onToggle}<br/>        key={i + ',' + j}<br/>      /&gt;)<br/>    }<br/>  }<br/>  <strong class="lm hv">return</strong> &lt;div&gt;{items}&lt;/div&gt;<br/>})</span></pre><p id="0a22" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，<code class="eh lj lk ll lm b">PixelContainer</code>将把从<code class="eh lj lk ll lm b">Canvas</code>收到的道具传递给它的<code class="eh lj lk ll lm b">Pixel</code>。</p><pre class="lt lu lv lw fq mf lm mg mh aw mi dt"><span id="9f86" class="mj jy hu lm b fv mk ml l mm mn"><strong class="lm hv">class</strong> PixelContainer <strong class="lm hv">extends</strong> React.PureComponent {<br/>  <strong class="lm hv">constructor</strong> (props) {<br/>    <strong class="lm hv">super</strong>(props)<br/>    <strong class="lm hv">this</strong>.handleToggle = <strong class="lm hv">this</strong>.handleToggle.bind(<strong class="lm hv">this</strong>)<br/>  }<br/>  handleToggle () {<br/>    <strong class="lm hv">this</strong>.props.onToggle(<strong class="lm hv">this</strong>.props.i, <strong class="lm hv">this</strong>.props.j)<br/>  }<br/>  render () {<br/>    <strong class="lm hv">return</strong> &lt;Pixel<br/>      i={<strong class="lm hv">this</strong>.props.i}<br/>      j={<strong class="lm hv">this</strong>.props.j}<br/>      active={<strong class="lm hv">this</strong>.props.active}<br/>      onToggle={<strong class="lm hv">this</strong>.handleToggle}<br/>    /&gt;<br/>  }<br/>}</span></pre><p id="39d9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae me" href="https://dtinth.github.io/pixelpaint/?experiment=ReduxCanvasV2" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">下面是结果</strong> </a> <strong class="it hv">。</strong></p><figure class="lt lu lv lw fq lx fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/72a281d7d44bf76928ac79b2db695fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*rrGDInAnuYIw_YYvnOyUTg.png"/></div></figure><p id="2c04" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个版本的表现比第一次更差。</p><p id="b24d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们看看是怎么回事。</p><figure class="lt lu lv lw fq lx fe ff paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="fe ff mt"><img src="../Images/9312fc8886afd437f6198c7a87df2c85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YNeQY-f-dKQeJ3O7IqyITQ.png"/></div></div></figure><p id="2952" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">问题好像是我们的<code class="eh lj lk ll lm b">Canvas</code>。因为它是唯一订阅该商店的用户，所以现在它负责管理所有16，384个像素。</p><p id="76b1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">每个店铺派单需要用正确的道具渲染16384个</strong> <code class="eh lj lk ll lm b"><strong class="it hv">Pixel</strong></code> <strong class="it hv"> s </strong>。</p><p id="a984" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这意味着16，384个<code class="eh lj lk ll lm b">React.createElement</code>调用，随后React试图为每个画布协调16，384个孩子。不太好。</p><p id="767a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以做得更好！</p></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><h1 id="d8a6" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">第三次尝试:平衡树</h1><p id="f66a" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">Redux的一个关键优势在于它的<strong class="it hv">不可变状态树</strong>(它支持一些很酷的特性，比如无痛热重装和时间旅行)。</p><p id="0550" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">事实证明，我们构建数据和视图的方式并不是一成不变的。</p><p id="ab4e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不可变状态树存储在平衡树中时效果最好。我在这篇文章中讨论过这个想法:</p><div class="mu mv fm fo mw mx"><a rel="noopener follow" target="_blank" href="/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2"><div class="my ab ej"><div class="mz ab na cl cj nb"><h2 class="bd hv fv z el nc eo ep nd er et ht dt translated">不可变的. js，持久数据结构和结构共享</h2><div class="ne l"><h3 class="bd b fv z el nc eo ep nd er et ek translated">为什么要用Immutable.js而不是普通的JavaScript对象？</h3></div><div class="nf l"><p class="bd b gc z el nc eo ep nd er et ek translated">medium.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl mc mx"/></div></div></a></div></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><h2 id="a956" class="mj jy hu bd jz nm nn no kd np nq nr kh jc ns nt kl jg nu nv kp jk nw nx kt ny dt translated"><strong class="ak">所以让我们对我们的应用程序做同样的事情。</strong></h2><p id="bf5a" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">我们将画布细分为四个象限。</p><figure class="lt lu lv lw fq lx fe ff paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="fe ff nz"><img src="../Images/873e1557c859eb532f1a805a319c6dff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SJ722sPE0-eESEFJCGRd_w.png"/></div></div></figure><p id="9927" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们需要改变一个像素时，</p><figure class="lt lu lv lw fq lx fe ff paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="fe ff nz"><img src="../Images/23e8eedbf63f999a40c3f53a7e525dbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MRgf7yA9LrXw8YjWu7qL2Q.png"/></div></div></figure><p id="49f8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以只更新相关的象限，不去管其他3个象限。</p><figure class="lt lu lv lw fq lx fe ff paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="fe ff nz"><img src="../Images/3c8c5890543a282a8927e481b255e6b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8sJ6ZydRzWhKBjWaSXU4PQ.png"/></div></div></figure><p id="f918" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以只重新渲染64×64=4096个像素，而不是重新渲染所有16，384个像素。这在性能上节省了75%。</p><p id="d5d5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">4096还是一个很大的数字。所以我们要做的是递归地细分画布，直到达到1×1像素的画布。</p><figure class="lt lu lv lw fq lx fe ff paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="fe ff nz"><img src="../Images/b054fd8c6f7d3ab5ee5b831cfd25fea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ic7mygkSr8SOCkQRG3Uubw.png"/></div></div></figure><p id="4061" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">为了能够以这种方式更新组件，我们也需要以同样的方式构造我们的状态，</strong>这样当状态改变时，我们可以使用<code class="eh lj lk ll lm b">===</code>操作符来确定象限的状态是否已经改变。</p><p id="ae83" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是(递归地)生成初始状态的代码:</p><pre class="lt lu lv lw fq mf lm mg mh aw mi dt"><span id="5017" class="mj jy hu lm b fv mk ml l mm mn"><strong class="lm hv">const</strong> generateInitialState = (size) =&gt; (size === 1<br/>  ? <strong class="lm hv">false</strong><br/>  : Immutable.List([<br/>    generateInitialState(size / 2),<br/>    generateInitialState(size / 2),<br/>    generateInitialState(size / 2),<br/>    generateInitialState(size / 2)<br/>  ])<br/>)</span></pre><p id="93ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们的状态是一个递归嵌套的树，<strong class="it hv"> </strong>不是像(58，52)那样通过坐标来引用每个像素，而是像(1，3，3，2，0，2，1)那样通过路径来引用每个像素。</p><p id="79bb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是要在屏幕上显示它们，我们需要能够根据路径计算出坐标:</p><pre class="lt lu lv lw fq mf lm mg mh aw mi dt"><span id="3cdf" class="mj jy hu lm b fv mk ml l mm mn"><strong class="lm hv">function</strong> keyPathToCoordinate (keyPath) {<br/>  <strong class="lm hv">let</strong> i = 0<br/>  <strong class="lm hv">let</strong> j = 0<br/>  <strong class="lm hv">for</strong> (<strong class="lm hv">const</strong> quadrant <strong class="lm hv">of</strong> keyPath) {<br/>    i &lt;&lt;= 1<br/>    j &lt;&lt;= 1<br/>    <strong class="lm hv">switch</strong> (quadrant) {<br/>      <strong class="lm hv">case</strong> 0: j |= 1; <strong class="lm hv">break</strong><br/>      <strong class="lm hv">case</strong> 2: i |= 1; <strong class="lm hv">break</strong><br/>      <strong class="lm hv">case</strong> 3: i |= 1; j |= 1; <strong class="lm hv">break</strong><br/>      <strong class="lm hv">default</strong>:<br/>    }<br/>  }<br/>  <strong class="lm hv">return</strong> [ i, j ]<br/>}</span></pre><p id="23a9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还需要反过来做:</p><pre class="lt lu lv lw fq mf lm mg mh aw mi dt"><span id="f71d" class="mj jy hu lm b fv mk ml l mm mn"><strong class="lm hv">function</strong> coordinateToKeyPath (i, j) {<br/>  <strong class="lm hv">const</strong> keyPath = [ ]<br/>  <strong class="lm hv">for</strong> (<strong class="lm hv">let</strong> threshold = 64; threshold &gt; 0; threshold &gt;&gt;= 1) {<br/>    keyPath.push(i &lt; threshold<br/>      ? j &lt; threshold ? 1 : 0<br/>      : j &lt; threshold ? 2 : 3<br/>    )<br/>    i %= threshold<br/>    j %= threshold<br/>  }<br/>  <strong class="lm hv">return</strong> keyPath<br/>}</span></pre><p id="b092" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们可以改变我们的减速器看起来像这样:</p><pre class="lt lu lv lw fq mf lm mg mh aw mi dt"><span id="2dc8" class="mj jy hu lm b fv mk ml l mm mn"><strong class="lm hv">const</strong> store = createStore(<br/>  <strong class="lm hv">function</strong> reducer (state = generateInitialState(128), action) {<br/>    <strong class="lm hv">if</strong> (action.type === 'TOGGLE') {<br/>      <strong class="lm hv">const</strong> keyPath = coordinateToKeyPath(action.i, action.j)<br/>      <strong class="lm hv">return</strong> state.updateIn(keyPath, (active) =&gt; !active)<br/><em class="jp">      //           </em>|<em class="jp"><br/>      //           This is why I use Immutable.js:<br/>      //           So that I can use this method.<br/></em>    }<br/>    return state<br/>  }<br/>)</span></pre><p id="e8e5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，我们创建一个组件来遍历这棵树，并把所有东西放在适当的位置。<code class="eh lj lk ll lm b">GridContainer</code>连接到商店并呈现最外面的<code class="eh lj lk ll lm b">Grid</code>。</p><pre class="lt lu lv lw fq mf lm mg mh aw mi dt"><span id="01d4" class="mj jy hu lm b fv mk ml l mm mn"><strong class="lm hv">function</strong> ReduxCanvas () {<br/>  <strong class="lm hv">return</strong> &lt;Provider store={store}&gt;&lt;GridContainer /&gt;&lt;/Provider&gt;<br/>}</span><span id="db42" class="mj jy hu lm b fv mr ml l mm mn"><strong class="lm hv">const</strong> GridContainer = connect(<br/>  (state, ownProps) =&gt; ({ state }),<br/>  (dispatch) =&gt; ({ onToggle: (i, j) =&gt; dispatch(toggle(i, j)) })<br/>)(<strong class="lm hv">function</strong> GridContainer ({ state, onToggle }) {<br/>  <strong class="lm hv">return</strong> &lt;Grid keyPath={[ ]} state={state} onToggle={onToggle} /&gt;<br/>})</span></pre><p id="0e71" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后每个<code class="eh lj lk ll lm b">Grid</code>递归地渲染自己的一个较小版本，直到它到达一片叶子(一个白色/黑色1x1像素的画布)。</p><pre class="lt lu lv lw fq mf lm mg mh aw mi dt"><span id="1bc6" class="mj jy hu lm b fv mk ml l mm mn"><strong class="lm hv">class</strong> Grid <strong class="lm hv">extends</strong> React.PureComponent {<br/>  <strong class="lm hv">constructor</strong> (props) {<br/>    <strong class="lm hv">super</strong>(props)<br/>    <strong class="lm hv">this</strong>.handleToggle = <strong class="lm hv">this</strong>.handleToggle.bind(<strong class="lm hv">this</strong>)<br/>  }<br/>  shouldComponentUpdate (nextProps) {<br/>    <em class="jp">// Required since we construct a new `keyPath` every render<br/>    // but we know that each grid instance will be rendered with<br/>    // a constant `keyPath`. Otherwise we need to memoize the<br/>    // `keyPath` for each children we render to remove this<br/>    // "escape hatch."</em><br/>    <strong class="lm hv">return</strong> this.props.state !== nextProps.state<br/>  }<br/>  handleToggle () {<br/>    <strong class="lm hv">const</strong> [ i, j ] = keyPathToCoordinate(<strong class="lm hv">this</strong>.props.keyPath)<br/>    <strong class="lm hv">this</strong>.props.onToggle(i, j)<br/>  }<br/>  render () {<br/>    <strong class="lm hv">const</strong> { keyPath, state } = <strong class="lm hv">this</strong>.props<br/>    <strong class="lm hv">if</strong> (<strong class="lm hv">typeof</strong> state === 'boolean') {<br/>      <strong class="lm hv">const</strong> [ i, j ] = keyPathToCoordinate(keyPath)<br/>      <strong class="lm hv">return</strong> &lt;Pixel<br/>        i={i}<br/>        j={j}<br/>        active={state}<br/>        onToggle={<strong class="lm hv">this</strong>.handleToggle}<br/>      /&gt;<br/>    } <strong class="lm hv">else</strong> {<br/>      <strong class="lm hv">return</strong> &lt;div&gt;<br/>        &lt;Grid onToggle={<strong class="lm hv">this</strong>.<strong class="lm hv">props</strong>.onToggle} keyPath={[ ...keyPath, 0 ]} state={state.get(0)} /&gt;<br/>        &lt;Grid onToggle={<strong class="lm hv">this</strong>.<strong class="lm hv">props</strong>.onToggle} keyPath={[ ...keyPath, 1 ]} state={state.get(1)} /&gt;<br/>        &lt;Grid onToggle={<strong class="lm hv">this</strong>.<strong class="lm hv">props</strong>.onToggle} keyPath={[ ...keyPath, 2 ]} state={state.get(2)} /&gt;<br/>        &lt;Grid onToggle={<strong class="lm hv">this</strong>.<strong class="lm hv">props</strong>.onToggle} keyPath={[ ...keyPath, 3 ]} state={state.get(3)} /&gt;<br/>      &lt;/div&gt;<br/>    }<br/>  }<br/>}</span></pre><p id="e847" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae me" href="https://dtinth.github.io/pixelpaint/?experiment=ReduxCanvasV3" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">下面是结果</strong> </a> <strong class="it hv">。</strong></p><figure class="lt lu lv lw fq lx fe ff paragraph-image"><div class="fe ff oa"><img src="../Images/fc4dd84e7895340127bb953b060d4da7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*3m_HHESm5vjZ7BHxnCKX8Q.png"/></div></figure><p id="97f4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">唷，我们又回到速度了！感觉和MobX版本一样快。另外，你还可以进行热重装和时间旅行。</p><p id="00e6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的DOM树看起来也更像树:</p><figure class="lt lu lv lw fq lx fe ff paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="fe ff ob"><img src="../Images/ee0ed929f9bac22d00bb5168032cddd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S35Xe0_HMbzPg5_mTMvLWg.png"/></div></div></figure><p id="c4f1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">与所有以前的方法相比:</p><figure class="lt lu lv lw fq lx fe ff paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="fe ff oc"><img src="../Images/2c254f636a35951e665f0d2789f73b37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ec7EX4NisoseQ-Yfch_oyw.png"/></div></div></figure></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><h1 id="8ef1" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">终极优化</h1><p id="9686" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">这个我没有编码，因为没用。</p><p id="5000" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面介绍:<strong class="it hv">为每个像素创建一个Redux store。</strong>我还没有测试过这个，但是我很确定这个方法是用Redux可以实现的最快的方法。</p><p id="0288" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你真的走这条路，你也会失去使用Redux的大部分好处。比如Redux DevTools很可能就坏了。一次一个像素的时间旅行不是很有用，不是吗？</p></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><h1 id="7e4f" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">更好的解决方案？</h1><p id="d2d3" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">所以我能想到的就这些了。</p><p id="c093" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你知道更好/更优雅的解决方案，请告诉我。</p><p id="0ad2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">更新:</strong></p><ul class=""><li id="fb81" class="la lb hu it b iu iv iy iz jc lc jg ld jk le jo lf lg lh li dt translated">丹·阿布拉莫夫 <a class="ae me" href="https://github.com/dtinth/pixelpaint/pull/1" rel="noopener ugc nofollow" target="_blank">提交了他的版本</a>，它比V1更快，但“效率不如V3，但也简单得多”</li></ul></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><h1 id="40f9" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">结论</h1><p id="9ca2" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">这是一个有趣的实验。</p><p id="e745" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们中的许多人在优化命令式算法方面都有扎实的知识，但当涉及到基于不可变数据的应用时，如果我们不知道性能影响，那么优化可能会很有挑战性。</p><p id="e3c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦我们优化了Redux版本，我们可以看到性能优化会导致代码可读性更差。<a class="ae me" href="https://github.com/dtinth/pixelpaint/blob/master/src/ReduxCanvasV3.js" rel="noopener ugc nofollow" target="_blank">我上面做的多乱啊！</a></p><p id="d0d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如丹·阿布拉莫夫所说的那样，<a class="ae me" rel="noopener" href="/@dan_abramov/you-might-not-need-redux-be46360cf367"> Redux提供了一种交换</a>(MobX也是如此)。那么，你会在不丧失热加载和时间旅行能力的情况下，用代码的清晰性和可读性来换取性能吗？</p></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><p id="b798" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我的<a class="ae me" href="https://our.wonderful.software/my-musical-instruments-f88ed8b12331" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> midi-instruments </strong> </a>项目中，应用程序将在MobileSafari中运行，因此性能非常重要，尤其是当一个乐器可能包含数百个按钮时。</p><p id="f162" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我还想快速构建新仪器的原型，而不必担心使用不可变数据时的性能影响。</p><p id="3d40" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我也发现热重装和时间旅行在这个项目中不是很有用。大多数状态持续几秒钟，我的项目足够小，我可以重新加载页面。</p><p id="3443" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以我很愉快地在这个项目中使用MobX。</p></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><p id="52e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我正在开发的节奏游戏<a class="ae me" href="https://github.com/bemusic/bemuse" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> Bemuse </strong> </a>中，我觉得使用不可变的数据有助于我编写简单且易于测试的代码。</p><p id="07d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我不必担心意外的状态突变，因为没有什么可以突变的。</p><p id="721b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也没有太多的数据需要渲染，所以我可能不需要像上面的例子那样进行优化。</p><p id="7d8f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">手头有一个Redux DevTools并且所有的状态更新都集中在一个地方也会让我受益匪浅。在这里，Redux大放异彩！</p><p id="ee47" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以我很愉快地在这个项目中使用Redux。</p></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><h2 id="0a21" class="mj jy hu bd jz nm nn no kd np nq nr kh jc ns nt kl jg nu nv kp jk nw nx kt ny dt translated">不公平的绩效比较</h2><p id="55b3" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">当我试图比较功能性方法(Redux)和命令性方法(MobX)时，这种比较从一开始就是不公平的。</p><p id="800a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">1996年，Chris Okasaki在他的<a class="ae me" href="https://www.cs.cmu.edu/~rwh/theses/okasaki.pdf" rel="noopener ugc nofollow" target="_blank"> 140页的论文</a>、<em class="jp">‘纯函数数据结构’</em>中总结道:</p><blockquote class="of og oh"><p id="b483" class="ir is jp it b iu iv iw ix iy iz ja jb oi jd je jf oj jh ji jj ok jl jm jn jo hn dt translated">不管编译器技术如何进步，只要函数式程序员可用的算法比命令式程序员可用的算法慢得多，函数式程序就永远不会比命令式程序快。</p></blockquote><p id="c6dd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在那篇论文中(<a class="ae me" href="https://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504" rel="noopener ugc nofollow" target="_blank">现已成为一本书</a>)，他试图让函数式编程中的数据结构和它的命令式对应物一样高效。</p><blockquote class="of og oh"><p id="7c59" class="ir is jp it b iu iv iw ix iy iz ja jb oi jd je jf oj jh ji jj ok jl jm jn jo hn dt translated">这篇论文提供了许多函数式数据结构，它们和最好的命令式实现一样有效</p></blockquote><p id="dd69" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我不会仅仅因为函数式编程永远不会像命令式算法那样快，就停止进行函数式编程</p><p id="ce00" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这都是权衡的问题。这也是为什么我从来不说‘让我们把Redux/MobX用于<em class="jp">一切吧！</em>.”这就是为什么当人们问“2017年我应该使用MobX还是Redux”时，我无法提供足够的答案没有任何其他背景。这就是我写这篇文章的原因。</p></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><h1 id="1cc1" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">感谢阅读！</h1><p id="248b" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">Reddit上有一些很好的讨论！</p><figure class="lt lu lv lw fq lx"><div class="bz el l di"><div class="ol om l"/></div></figure><p id="7661" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">丹·阿布拉莫夫的拉请求中还有一些讨论(谢谢！):</p><div class="mu mv fm fo mw mx"><a href="https://github.com/dtinth/pixelpaint/pull/1" rel="noopener  ugc nofollow" target="_blank"><div class="my ab ej"><div class="mz ab na cl cj nb"><h2 class="bd hv fv z el nc eo ep nd er et ht dt translated">通过gae Aron Pull Request # 1 dtinth/pixel paint添加一个简单但相当快速的Redux版本</h2><div class="ne l"><h3 class="bd b fv z el nc eo ep nd er et ek translated">它的效率比V3低，但也简单得多。依赖于道具的记忆(这是你想在…</h3></div><div class="nf l"><p class="bd b gc z el nc eo ep nd er et ek translated">github.com</p></div></div><div class="ng l"><div class="on l ni nj nk ng nl mc mx"/></div></div></a></div><div class="lt lu lv lw fq ab cb"><figure class="oo lx op oq or os ot paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="oo lx op oq or os ot paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="oo lx op oq or os ot paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="of og oh"><p id="f922" class="ir is jp it b iu iv iw ix iy iz ja jb oi jd je jf oj jh ji jj ok jl jm jn jo hn dt translated"><a class="ae me" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae me" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae me" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae me" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is jp it b iu iv iw ix iy iz ja jb oi jd je jf oj jh ji jj ok jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae me" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae me" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lt lu lv lw fq lx fe ff paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="fe ff ou"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>