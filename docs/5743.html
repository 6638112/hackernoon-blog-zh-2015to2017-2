<html>
<head>
<title>Unit testing Node.js with Tape</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用磁带对Node.js进行单元测试</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/unit-testing-node-js-38cf2b7e1a41?source=collection_archive---------9-----------------------#2017-08-14">https://medium.com/hackernoon/unit-testing-node-js-38cf2b7e1a41?source=collection_archive---------9-----------------------#2017-08-14</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/1682690effaad02185f00f697be67921.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vc-cNS-og_RkAIQWyFhhaA.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="https://unsplash.com/@gflandre" rel="noopener ugc nofollow" target="_blank">Guillaume Flandre</a></figcaption></figure><p id="ede6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我觉得有一种倾向，那就是忘记我们，或者其他人，将不得不在代码创建几周、几个月甚至几年后维护我们的代码。迟早会出现一些问题或新特性，这将使你不得不在忘记它所做的所有细节后很久才修改你的代码库。</p><blockquote class="kf"><p id="fc97" class="kg kh hu bd ki kj kk kl km kn ko ke ek translated">测试就像留下一份你的代码应该做什么的活文档</p></blockquote><h1 id="01b4" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">测试类型</h1><p id="e560" class="pw-post-body-paragraph jh ji hu jj b jk ln jm jn jo lo jq jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">我将特别关注单元测试，但只是给你一个思路:</p><ul class=""><li id="41c6" class="ls lt hu jj b jk jl jo jp js lu jw lv ka lw ke lx ly lz ma dt translated">单元测试——当代码依赖于数据库等外部资源时，通常使用虚假数据来测试功能；</li><li id="800f" class="ls lt hu jj b jk mb jo mc js md jw me ka mf ke lx ly lz ma dt translated">集成——假设您有一个数据库连接，集成测试是指您测试从该连接获得的数据；</li><li id="425e" class="ls lt hu jj b jk mb jo mc js md jw me ka mf ke lx ly lz ma dt translated">端到端——用于带有UI的应用程序，基本上是让<a class="ae jg" href="https://hackernoon.com/tagged/test" rel="noopener ugc nofollow" target="_blank">测试</a>模拟用户会做什么。</li></ul><figure class="mh mi mj mk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mg"><img src="../Images/cf234d2175d84cdb3746a549b3cc3c2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XjaoQNHGjq-DvF2LU_8DBA.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">The distribution is usually like this, end to end are the less amount you do and unit the most</figcaption></figure><p id="6379" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，根据图片，假设您已经实现了所有这三种类型的测试，您有10个测试1个应该是端到端的，2个是集成的，剩下的7个是单元测试。</p><p id="753a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你不必忠实地遵循这个标准，它只是一个好的指导方针。</p><p id="07c0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可以广泛阅读由<a class="ae jg" href="https://martinfowler.com/articles/mocksArentStubs.html" rel="noopener ugc nofollow" target="_blank">马丁·福勒</a>撰写的关于测试的文章。</p><h1 id="0461" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la ml lc ld le mm lg lh li mn lk ll lm dt translated">为什么要测试</h1><p id="6d58" class="pw-post-body-paragraph jh ji hu jj b jk ln jm jn jo lo jq jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">测试项目代码很重要，原因如下:</p><ul class=""><li id="332c" class="ls lt hu jj b jk jl jo jp js lu jw lv ka lw ke lx ly lz ma dt translated">逻辑是有文档记录的——不言自明的，只要通过阅读测试，你就可以对代码应该做什么有一个大致的了解；</li><li id="18e0" class="ls lt hu jj b jk mb jo mc js md jw me ka mf ke lx ly lz ma dt translated">更快的调试——如果出了问题，你将通过看到测试失败而得到即时反馈；</li><li id="caa2" class="ls lt hu jj b jk mb jo mc js md jw me ka mf ke lx ly lz ma dt translated">对新特性的担心更少——当开发可能对现有代码产生影响的新特性时，您可以改变逻辑，因为您知道如果您破坏了代码的任何部分，测试将会告诉您失败。</li></ul><p id="1437" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有一些有争议的缺点，比如:</p><ul class=""><li id="2d3c" class="ls lt hu jj b jk jl jo jp js lu jw lv ka lw ke lx ly lz ma dt translated">开发需要更多的时间——我反驳说，你花在测试开发和调试上的时间比你本来要花的时间要多；</li><li id="020e" class="ls lt hu jj b jk mb jo mc js md jw me ka mf ke lx ly lz ma dt translated">团队需要学习的另一件事是——项目中通常有相当大的技术堆栈，最终可能成为“我必须学习的另一件事”</li></ul><h1 id="cf65" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la ml lc ld le mm lg lh li mn lk ll lm dt translated"><strong class="ak">行话</strong></h1><p id="2741" class="pw-post-body-paragraph jh ji hu jj b jk ln jm jn jo lo jq jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">您通常看到的与测试相关的一些术语是:</p><ul class=""><li id="0aa0" class="ls lt hu jj b jk jl jo jp js lu jw lv ka lw ke lx ly lz ma dt translated">断言——这是你在测试中试图证明的，如果你在测试相等性和返回值的类型，你会说你有两个断言。每个测试可以有尽可能多的断言，但是为了简单和可读性，尽量保持每个测试有很少的断言；</li><li id="d1ab" class="ls lt hu jj b jk mb jo mc js md jw me ka mf ke lx ly lz ma dt translated">间谍——间谍是指当你使用一个真实的方法，而你的测试代码依赖于这个方法来工作；</li><li id="ff34" class="ls lt hu jj b jk mb jo mc js md jw me ka mf ke lx ly lz ma dt translated">fixtures——模拟应用程序的特定状态的代码或文件，以便每当您想要评估特定状态时，总是有一个固定的环境来重复您的测试；</li><li id="7d7a" class="ls lt hu jj b jk mb jo mc js md jw me ka mf ke lx ly lz ma dt translated">存根——您希望减少测试中的外部影响(如间谍),因此为了对测试有更多的控制，我们模拟了一种方法，这种方法是测试代码工作所必需的，而不是使用原来的方法。例如，假设我们使用第三方库来连接，我们会用自己的方法替换那个库的原始方法；</li><li id="b702" class="ls lt hu jj b jk mb jo mc js md jw me ka mf ke lx ly lz ma dt translated">模拟——这些是您自己为测试工作而创建的硬编码值，其中一个例子是测试使用的服务器响应样本。</li></ul><p id="4630" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这里你可以用例子<a class="ae jg" href="https://blog.pragmatists.com/test-doubles-fakes-mocks-and-stubs-1a7491dfa3da" rel="noopener ugc nofollow" target="_blank">进行更详尽的解释。</a></p><h1 id="9886" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la ml lc ld le mm lg lh li mn lk ll lm dt translated">例子</h1><p id="723d" class="pw-post-body-paragraph jh ji hu jj b jk ln jm jn jo lo jq jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">对于这个例子，我将使用一个轻量级的模块库来扩展它，用于单元测试，称为<a class="ae jg" href="https://github.com/substack/tape" rel="noopener ugc nofollow" target="_blank"> tape </a>，但是你也可以选择jest、jasmine和mocha。</p><p id="c9b2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">理想情况下，你应该尝试使用TDD(测试驱动开发)或者类似的方法，从创建测试开始，并且只在创建代码之后。当这是不可能的，并且你正在测试的方法已经被实现时，确保你改变你的方法，以便你看到你的测试失败。如果测试没有失败，那么你什么也没有测试。</p><p id="906e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们假设我们想要创建一个名为<em class="mo"> string </em>的实用程序文件，它将有一个用于小写的方法和一个用于连接的方法。我们创建自己的文件</p><figure class="mh mi mj mk fq iv fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/57cc1818980c9b48e3d0d6897971f2e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*R-BfMzdoIU3mbu8W7VkZeA.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">I prefer the tests near the file being tested approach but some people have all the tests in a separate folder, I leave it up to your preference to decide which approach to take</figcaption></figure><p id="a304" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在我们的测试文件中，我们用两个断言创建了我们的第一个测试，一个用于检查一切是否运行“正常”,另一个调用小写函数并将结果与预期的硬编码值进行比较</p><pre class="mh mi mj mk fq mq mr ms mt aw mu dt"><span id="d9d4" class="mv kq hu mr b fv mw mx l my mz">const test = require('tape')<br/>const stringUtils = require('./strings.js')</span><span id="9fb1" class="mv kq hu mr b fv na mx l my mz">test('lowercase should make everything in the original string lower case', function (t) {<br/>  const result = stringUtils.lowercase('Testing lowerCase')<br/>  const expected = 'testing lowercase'</span><span id="2b85" class="mv kq hu mr b fv na mx l my mz">  t.ok(result)<br/>  t.deepEqual(result, expected)</span><span id="f8e6" class="mv kq hu mr b fv na mx l my mz">  t.end()<br/>});</span></pre><p id="4d14" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这就是我们运行测试的地方，我们看到它悲惨地失败了，因为lowercase没有被定义，所以我们使用我们的<em class="mo"> string.js </em>并让它返回一个带有方法<em class="mo"> lowercase </em>的函数</p><pre class="mh mi mj mk fq mq mr ms mt aw mu dt"><span id="6dbc" class="mv kq hu mr b fv mw mx l my mz">function lowercase(value) {<br/>  return value.toLowerCase()<br/>}</span><span id="52ff" class="mv kq hu mr b fv na mx l my mz">module.exports = {<br/>  lowercase,<br/>}</span></pre><p id="3428" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果我们再次运行测试，应该会显示成功！万岁！第一次测试通过！</p><figure class="mh mi mj mk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nb"><img src="../Images/d9bb6e7eac0fe749663a0a069f376c23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tDoph-pgGuUtOB5EVpZxEg.png"/></div></div></figure><p id="9541" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们想“如果我给那个方法发送一个数字会怎么样？”在这种情况下，我们创建另一个测试来测试它，并根据我们的预期行为来实现，在这种情况下，我希望当一个无效类型被发送到我们的方法时抛出一个错误</p><p id="f3f0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">测试</p><pre class="mh mi mj mk fq mq mr ms mt aw mu dt"><span id="5ce2" class="mv kq hu mr b fv mw mx l my mz">test('if we send a number it should throw an error from lowercase method', function(t) {<br/>  const result = stringUtils.lowercase.bind(null, 1)<br/>  t.throws(result)<br/>  t.end()<br/>})</span></pre><p id="f687" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们看到测试失败后改变的函数</p><pre class="mh mi mj mk fq mq mr ms mt aw mu dt"><span id="005e" class="mv kq hu mr b fv mw mx l my mz">function lowercase(value) {<br/>  try {<br/>    return value.toLowerCase()<br/>  } catch(e) {<br/>    throw e<br/>  }<br/>}</span></pre><p id="301e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一个很好的方法是改变你的测试代码的随机部分，这样你就可以确保你的测试确实是有用的。在这种情况下，您可以更改<code class="eh nc nd ne mr b">return</code>的<code class="eh nc nd ne mr b">throw</code>。</p><blockquote class="nf ng nh"><p id="f0ed" class="jh ji mo jj b jk jl jm jn jo jp jq jr ni jt ju jv nj jx jy jz nk kb kc kd ke hn dt translated">请注意，磁带中的测试必须有<code class="eh nc nd ne mr b">t.plan([assertionsNumber])</code>或<code class="eh nc nd ne mr b">t.end()</code>，否则测试将会挂起。</p></blockquote><p id="e9aa" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于我们的concatenate方法，我们想测试它是否连接，当你发送一个对象时，我们希望它连接为{}而不是[object Object]。你可以自己试试，或者看看下面可能的解决方案</p><p id="8f8d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">测试</p><pre class="mh mi mj mk fq mq mr ms mt aw mu dt"><span id="97d0" class="mv kq hu mr b fv mw mx l my mz">test('concatenate should return the two strings concatenated', function (t) {<br/>  const result = stringUtils.concatenate('test', 'concat')<br/>  const expected = 'test concat'<br/>  <br/>  t.deepEqual(result, expected)<br/>  t.end()<br/>})</span><span id="aba4" class="mv kq hu mr b fv na mx l my mz">test('concatenate should consider {} as a string', function (t) {<br/>  const result = stringUtils.concatenate('test', {})<br/>  const expected = 'test {}'<br/>  t.deepEqual(result, expected)<br/>  t.end()<br/>});</span></pre><p id="b379" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">该功能</p><pre class="mh mi mj mk fq mq mr ms mt aw mu dt"><span id="a713" class="mv kq hu mr b fv mw mx l my mz">function concatenate(start, end) {<br/>  start = typeof start === 'string'<br/>    ? start<br/>    : JSON.stringify(start)<br/>  end = typeof end === 'string'<br/>    ? end<br/>    : JSON.stringify(end)</span><span id="df10" class="mv kq hu mr b fv na mx l my mz">  return `${start} ${end}`<br/>}</span></pre><p id="22f1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在用新方法出口</p><pre class="mh mi mj mk fq mq mr ms mt aw mu dt"><span id="6b42" class="mv kq hu mr b fv mw mx l my mz">module.exports = {<br/>  lowercase,<br/>  concatenate<br/>}</span></pre><p id="1231" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是为简单起见而做的“琐碎”测试，您应该为每个方法添加您认为必要的数量，“越多越好”，只要它们是有用的(这意味着他们正在测试方法的核心内容，而不仅仅是“有更多的断言”)。</p><p id="6c5b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">随着应用程序的增长，我们可以添加多个测试文件，并且我们可以使用下面的代码来运行它们</p><pre class="mh mi mj mk fq mq mr ms mt aw mu dt"><span id="3b7e" class="mv kq hu mr b fv mw mx l my mz">tape ./utils/*.test.js</span></pre><blockquote class="nf ng nh"><p id="6991" class="jh ji mo jj b jk jl jm jn jo jp jq jr ni jt ju jv nj jx jy jz nk kb kc kd ke hn dt translated">这个例子的演示<a class="ae jg" href="https://github.com/daspinola/unit-test-node-sample" rel="noopener ugc nofollow" target="_blank">在这里</a></p></blockquote><p id="e9ec" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于现有的项目，您可以从为新功能添加测试开始，对于旧功能，在添加测试的同时重构代码，最终您将不得不传播到大部分代码库，如果不是全部的话。</p><blockquote class="kf"><p id="5dc1" class="kg kh hu bd ki kj kk kl km kn ko ke ek translated">记住总是看到测试失败</p></blockquote><h1 id="7b5a" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">代码覆盖率</h1><p id="58d2" class="pw-post-body-paragraph jh ji hu jj b jk ln jm jn jo lo jq jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">有像<a class="ae jg" href="https://github.com/gotwarlost/istanbul" rel="noopener ugc nofollow" target="_blank">伊斯坦堡</a>这样的工具来检查你的代码有多少被测试，我不喜欢过多地关注这个指标，因为它会让你拿你的代码冒险，不是因为你需要，而是因为你想有100%的覆盖率，你想开发测试的新功能，而不必花太多时间来适应代码，只是为了达到100%。</p><p id="d40f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">测试10%的代码比什么都不测试要好，尽管如此，如果你想强加一个最小的覆盖率，我会说70%是一个好的起点。</p></div><div class="ab cl nl nm hc nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="hn ho hp hq hr"><p id="4650" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">30篇文章的第9篇，每周至少发表一篇文章的项目的一部分，从闲思到教程。留下评论，在<a class="ns nt gr" href="https://medium.com/u/fef03c291e56?source=post_page-----38cf2b7e1a41--------------------------------" rel="noopener" target="_blank">迪奥戈·斯皮诺拉</a>上关注我，然后回到你的精彩项目中去！</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure></div></div>    
</body>
</html>