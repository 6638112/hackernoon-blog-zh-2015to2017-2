<html>
<head>
<title>Javascript and Functional Programming: An Introduction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript和函数式编程:简介</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/javascript-and-functional-programming-an-introduction-286aa625e26d?source=collection_archive---------0-----------------------#2017-11-27">https://medium.com/hackernoon/javascript-and-functional-programming-an-introduction-286aa625e26d?source=collection_archive---------0-----------------------#2017-11-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir is it"><p id="79aa" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">注:这是《Javascript </em>  <em class="hu">与函数式编程》系列关于</em> <a class="ae jt" href="https://hackernoon.com/tagged/learning" rel="noopener ugc nofollow" target="_blank"> <em class="hu">学习JavaScript ES6+中的</em> </a> <em class="hu">函数式编程技巧的一部分。check out</em><a class="ae jt" href="https://hackernoon.com/javascript-and-functional-programming-pt-2-first-class-functions-4437a1aec217" rel="noopener ugc nofollow" target="_blank"><em class="hu">&lt;Part 2&gt;</em></a><em class="hu">关于第一类函数。</em></p></blockquote><p id="a093" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">我从来都是讲底线的。对伪知识概念、花哨的术语和炒作不感兴趣。相反，我总是寻求帮助我尽快发布代码的工具和技术。这种方法最初是有成效的——特别是当我构建较小的“概念验证”应用程序时。</p><p id="7f9f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">不幸的是，这种方法无法扩展。随着我作为一名开发人员的进步，我开始感受到生产力回报递减的定律。建立一个项目，并达到基本功能是很快的。但是当我的应用程序变得越来越复杂时，真正的问题开始出现了。我发现随着项目生命周期的推进，我正在编写复杂的代码。我写的代码变得难以理解。为了理解它，我必须极度集中注意力。</p><p id="9784" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">我有一种渴望的感觉，必须存在一种更好、更干净的开发软件的方法。我听说过一些关于函数式编程的传闻，以及它是如何让开发人员写出更简洁优雅的代码的。在使用React和Redux时，我第一次不知不觉地接触到了函数范式和模式。他们都融入了一些原则，我喜欢他们。我读到过FP——最初令我沮丧的是，我看到它的范例是基于抽象的数学概念，而且它在学术界非常流行。因为我的目标是尽可能快地运送产品，这似乎是一种违反直觉的方法，违背了我试图实现的目标。在工程学院读了4年后，我非常坚定地认为，学术界只解决理论问题，不太可能在我的日常构建工作中帮助我。</p><p id="506b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt">🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔</p><p id="5d35" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">但是FP一直缠着我。优雅的解决方案和范例散布在我最喜欢的开源项目、博客帖子和教程中。我把我的skeptecism放在一边，开始钻研FP。</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div class="fe ff jx"><img src="../Images/6d24691cb4f361b005afa64b76208f25.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/1*sLcHcxrOG0TlcKjRW31llA.gif"/></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">Let’s just do this FP thang!</figcaption></figure><p id="7b81" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">虽然这些概念涉及新的术语，并且包括陡峭的学习曲线，但我对这种“新方法”感到惊讶和兴奋。这一系列文章分享了我的学习经验，旨在提取和总结FP的精华，使开发体验更干净、更简洁。我将尝试对我讨论的模式建立一个直观的理解，并尽可能简单地构建问题和提供的解决方案，超越不必要的复杂定义。学习FP有一点令人生畏的名声，但是通过将概念分解成更小的部分，我们将使想法更容易消化。</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div class="fe ff kj"><img src="../Images/32acfebc01c3d1f9e23d0c2aa98b5391.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*V7-H9WZRg5OuaOjQBfqm5A.png"/></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">From the amazing Mostly Adequate FP Guide</figcaption></figure><p id="61b9" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">与其他编程范例相比，FP的主要区别在于<em class="iw">声明式</em>方法(FP)与<em class="iw">命令式</em>方法。在我们深入正式定义之前，让我们通过看一个例子来探究它们的区别。</p><h1 id="352c" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">必要的</h1><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="li lj l"/></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">Imperative functions in the wild</figcaption></figure><p id="026c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">这个代码看起来邪恶吗？应该的！以上方法有什么相似之处？</p><ol class=""><li id="d77e" class="lk ll hu ix b iy iz jc jd ju lm jv ln jw lo js lp lq lr ls dt translated">这段代码片段的主要复杂性源于这样一个事实，即我们不是告诉计算机<em class="iw">我们想要</em>它做什么，而是指导它<em class="iw">如何做</em>。告诉计算机如何操作的代码。转到索引为<em class="iw"> i的数组，并变异或交换一个值</em>称为命令式代码。</li><li id="6577" class="lk ll hu ix b iy lt jc lu ju lv jv lw jw lx js lp lq lr ls dt translated">这段代码不可读(😱😱😱).这是一个玩具例子，但是随着你的程序增长，你的功能变得更加复杂，像这样使用<em class="iw"> for loops </em>创建的代码并不简单，需要我们的大脑分析循环的内部工作，同时跟踪索引、变量等等。命令式代码增加了阅读时的认知负荷，随着时间的推移，更容易在推理和逻辑上出错。</li></ol><h1 id="1707" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">宣言的</h1><p id="7362" class="pw-post-body-paragraph iu iv hu ix b iy ly ja jb jc lz je jf ju ma ji jj jv mb jm jn jw mc jq jr js hn dt translated">让我们重写这段代码，但是以声明的方式。</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="c5a1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">。地图？。减少？这是什么妖术？</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div class="fe ff md"><img src="../Images/2c066ccf74a8428d80886ce49337a10b.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/1*mPUc2fU1VPbW6gjbw1DjeQ.gif"/></div></figure><p id="f72a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">首先，我保证给定相同的输入，这两种方法每次都会产生相同的输出<em class="iw">。</em></p><p id="84ee" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">声明性片段的一个小插曲-</p><p id="2ac2" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated"><code class="eh me mf mg mh b"><strong class="ix hv">.map()</strong></code> <em class="iw"> </em>是JS中每个数组都可以访问的方法。的。方法创建一个新数组，其结果是在调用数组中的每个元素上调用一个提供的函数。</p><p id="5aba" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">。<code class="eh me mf mg mh b"><strong class="ix hv">reduce()</strong></code>是一种对累加器和数组中的每个元素(从左到右)应用函数以将其缩减为单个值的方法。</p><p id="5eb3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">现在还不要担心这些。在接下来的文章中，我们将深入探讨这些方便的数组原生方法。但是很明显，声明性代码片段比命令性代码片段更简洁。读起来也轻松了很多。我没有指示程序我希望它访问哪些索引等等，而是简单地给<code class="eh me mf mg mh b"><strong class="ix hv">.map() </strong>and<strong class="ix hv"> .reduce()</strong></code>(在我们的例子中是一个匿名函数)提供一个表达式，告诉程序<em class="iw">我希望</em>对数组中的每个元素做什么。</p><p id="2748" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">这种声明式方法将通过以下方式全面地为我们服务:</p><ol class=""><li id="360e" class="lk ll hu ix b iy iz jc jd ju lm jv ln jw lo js lp lq lr ls dt translated">在你的代码中学习和使用众所周知的、可理解的模式，<em class="iw">和</em>被证明可以避免使代码更难理解的错误。</li></ol><p id="da19" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">2.编写更短、更有表现力、更简洁的代码。毕竟，我们写的代码越少，我们需要调试的就越少。</p><p id="5f0c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">最重要的是，这些工具和范例将帮助我们实现更快地运送产品的最终目标。看看下一篇文章<a class="ae jt" href="https://hackernoon.com/javascript-and-functional-programming-pt-2-first-class-functions-4437a1aec217" rel="noopener ugc nofollow" target="_blank">，我们将讨论JS中的函数，为什么它们是特殊的，以及它们的特性如何支持函数式编程。</a></p><h2 id="08e5" class="mi kl hu bd km mj mk ml kq mm mn mo ku ju mp mq ky jv mr ms lc jw mt mu lg mv dt translated">如果这篇文章有帮助，请点击拍手👏按钮以示支持！⬇⬇</h2><p id="7f78" class="pw-post-body-paragraph iu iv hu ix b iy ly ja jb jc lz je jf ju ma ji jj jv mb jm jn jw mc jq jr js hn dt translated">你可以在<a class="ae jt" href="https://www.instagram.com/omeragoldberg/" rel="noopener ugc nofollow" target="_blank"> Instagram </a>、<a class="ae jt" href="https://www.linkedin.com/in/omer-goldberg-680b40100/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>和<a class="ae jt" rel="noopener" href="/@omergoldberg"> Medium </a>上关注我。</p><p id="ff03" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">而且最重要的是！我正在使用<a class="ae jt" href="https://arieg419.wixsite.com/mindflow" rel="noopener ugc nofollow" target="_blank"> Mindflow.ai创建这些教程。</a> <a class="ae jt" href="https://arieg419.wixsite.com/mindflow" rel="noopener ugc nofollow" target="_blank"> Mindflow </a>会(几乎)自动创建您工作流程的智能摘要。它让记录我的工作变得轻而易举！在这里注册<a class="ae jt" href="https://arieg419.wixsite.com/mindflow" rel="noopener ugc nofollow" target="_blank"> alpha版本</a>。</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="mw lj l"/></div></figure></div></div>    
</body>
</html>