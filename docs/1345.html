<html>
<head>
<title>Redux Step by Step: A Simple and Robust Workflow for Real Life Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redux Step by Step:一个简单而健壮的现实生活应用工作流</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/redux-step-by-step-a-simple-and-robust-workflow-for-real-life-apps-1fdf7df46092?source=collection_archive---------0-----------------------#2016-10-16">https://medium.com/hackernoon/redux-step-by-step-a-simple-and-robust-workflow-for-real-life-apps-1fdf7df46092?source=collection_archive---------0-----------------------#2016-10-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/a34552ca1256caabe139b8c319d897db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7lHJdZ2Tupj7kb6AgHPt-Q.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">no trees, just rocks</figcaption></figure><p id="7fb1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><a class="ae ke" href="https://hackernoon.com/tagged/redux" rel="noopener ugc nofollow" target="_blank"> <em class="kf"> Redux </em> </a> <em class="kf">已经成为</em> <a class="ae ke" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank"> <em class="kf"> React </em> </a> <em class="kf">应用中管理数据流最流行的Flux实现之一。然而，阅读Redux经常会导致感官超负荷，从而只见树木不见森林。下面展示的是一个简单明了的工作流程，用于使用Redux实现现实生活中的应用。通过一个实际应用程序的一步一步的实现演示了这个例子。它试图以实用的方式应用Redux背后的原则，并详细说明每个决策背后的思维过程。</em></p></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><h2 id="e2c3" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">惯用重叠的自以为是方法</h2><p id="91b6" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">Redux已经不仅仅是一个图书馆，它是一个完整的生态系统。它受欢迎的原因之一是它能够适应不同的写作风格和许多不同的口味。如果我在寻找异步动作，我应该使用<a class="ae ke" href="https://github.com/gaearon/redux-thunk" rel="noopener ugc nofollow" target="_blank"> thunks </a>吗？又或许<a class="ae ke" href="https://github.com/acdlite/redux-promise" rel="noopener ugc nofollow" target="_blank">承诺</a>？还是<a class="ae ke" href="https://github.com/yelouafi/redux-saga" rel="noopener ugc nofollow" target="_blank">传奇</a>？</p><p id="a7b9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">哪种口味是“最好的”并没有一个正确的答案。而且使用Redux也没有一个正确的方法。说到这里，选择太多是<a class="ae ke" href="http://www.ted.com/talks/barry_schwartz_on_the_paradox_of_choice?language=en" rel="noopener ugc nofollow" target="_blank">压倒</a>。我想呈现一种我个人喜欢的<em class="kf">固执己见的</em>味道。它很健壮，可以处理复杂的现实生活场景——最重要的是——它很简单。</p><h2 id="fbf6" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">所以我们来建个app吧！</h2><p id="2689" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">我们需要一个真实的例子来说明。只要我们固执己见，互联网上最有趣的地方就是Reddit。让我们做一个应用程序，显示那里最有趣的帖子。</p><p id="04e1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在第一个屏幕上，我们将询问用户他们感兴趣的3个主题。我们将从Reddit的默认首页<a class="ae ke" href="https://www.reddit.com/subreddits/default" rel="noopener ugc nofollow" target="_blank">子编辑</a>列表中提取主题列表。</p><p id="dba7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">用户做出选择后，我们将在一个可过滤的列表中显示这3个主题中每个主题的帖子列表——所有主题或3个主题中的一个。当用户点击列表中的帖子时，我们将显示其内容。</p><h2 id="8ae6" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">设置</h2><p id="3cf2" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">由于我们使用React for web(我们可能会在未来的帖子中添加React Native)，我们的起点将是<a class="ae ke" href="https://github.com/facebookincubator/create-react-app" rel="noopener ugc nofollow" target="_blank"> Create React App </a>，官方入门套件。我们还将安装NPM<a class="ae ke" href="https://www.npmjs.com/package/redux" rel="noopener ugc nofollow" target="_blank">redux</a>、<a class="ae ke" href="https://www.npmjs.com/package/react-redux" rel="noopener ugc nofollow" target="_blank"> react-redux </a>和<a class="ae ke" href="https://www.npmjs.com/package/redux-thunk" rel="noopener ugc nofollow" target="_blank"> redux-thunk </a>。结果应该是类似于<a class="ae ke" href="https://github.com/wix/react-dataflow-example/tree/998decf6277717ffcee61dea30005c1fe917ae2a" rel="noopener ugc nofollow" target="_blank">这个</a>的东西。</p><p id="5a9e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">为了避免样板文件，让我们快速初始化Redux存储，并在<em class="kf"> index.js </em>中连接thunk中间件:</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="lr ls l"/></div></figure><h2 id="3d85" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">Redux应用程序中的生命流动圈</h2><p id="1779" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">Redux教程中经常缺少的一个主要东西是宏大的画面和Redux适合的地方。Redux是<a class="ae ke" href="https://facebook.github.io/flux/" rel="noopener ugc nofollow" target="_blank"> Flux </a>架构的一个实现——一种在React应用中传递数据的模式。</p><p id="5adc" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在classic Flux下，应用状态保存在<em class="kf">商店</em>中。分派的<em class="kf">动作</em>导致该状态改变，之后监听这些状态改变的<em class="kf">视图</em>将相应地重新呈现它们自己:</p><figure class="ln lo lp lq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lt"><img src="../Images/9b61ba3fff46e6620876ac19d11d0bf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*stmn8kxXJrX9hbk39hHQJA.png"/></div></div></figure><p id="23c1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">Flux通过使数据单向<em class="kf">流动来简化生活。随着代码库的增长和变得更加复杂，这减少了意大利面条效应。</em></p></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><p id="34af" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">理解Redux的困难之一是有太多不直观的术语，如<em class="kf">归约符</em>、<em class="kf">选择器</em>和<em class="kf"> thunks </em>。通过把它们放在通量图上，更容易看出它们的位置。这些只是实现循环不同部分的各种Redux构造的技术名称:</p><figure class="ln lo lp lq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lt"><img src="../Images/abda20f4cb4db9453e671b0b12bb3c82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9kbmrgH8voxp_rx25LPqIw.png"/></div></div></figure><p id="e22e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">你可能已经注意到，Redux生态系统中的其他术语，如<em class="kf">中间件</em>和<em class="kf">传奇</em>，都不存在。这是有意的，因为它们不会在我们的工作流程中扮演重要角色。</p><h2 id="69e5" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">项目目录结构</h2><p id="5eac" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">我们将根据<code class="eh lu lv lw lx b">/src</code>下面的顶级目录结构来组织我们的代码:</p><ul class=""><li id="7a5b" class="ly lz hu ji b jj jk jn jo jr ma jv mb jz mc kd md me mf mg dt translated"><code class="eh lu lv lw lx b">/src/components<br/></code>“哑”对不知道Redux的组件做出反应</li><li id="792d" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated"><code class="eh lu lv lw lx b">/src/containers</code><br/><em class="kf">连接</em>到我们Redux商店的“智能”React组件</li><li id="f57d" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated"><code class="eh lu lv lw lx b">/src/services</code> <br/>外部API的抽象外观(如后端服务器)</li><li id="cbc0" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated"><code class="eh lu lv lw lx b">/src/store</code> <br/>所有Redux特有的代码都在这里，包括我们应用的所有<em class="kf">业务逻辑</em></li></ul><p id="ac6c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh lu lv lw lx b">store</code>目录按<em class="kf">域</em>组织，每个域包含:</p><ul class=""><li id="4d05" class="ly lz hu ji b jj jk jn jo jr ma jv mb jz mc kd md me mf mg dt translated"><code class="eh lu lv lw lx b">/src/store/{domain}/reducer.js</code> <br/>减速器作为默认导出，所有选择器作为命名导出</li><li id="f065" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated"><code class="eh lu lv lw lx b">/src/store/{domain}/actions.js</code> <br/>所有的域动作处理程序(thunks和普通对象创建者)</li></ul><h2 id="dcfd" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">国家优先的方法</h2><p id="0c91" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">我们的应用程序有两个屏幕，我们将从第一个屏幕开始，让用户选择正好3个主题。我们可以开始实现通量循环的任何一点，但是我发现对我来说从状态<em class="kf">开始通常是最容易的。</em></p><p id="b864" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">那么我们的<em class="kf">话题</em>屏幕需要什么<em class="kf"> app状态</em>？</p><p id="3912" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们需要保存从服务器检索到的主题列表。我们还需要保存到目前为止用户选择的主题的ID(最多3个)。按照选择的顺序保存它们会很好，所以如果我们已经有了3个并且选择了另一个，我们可以简单地删除最老的一个。</p><p id="a5bc" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们将如何构建这个应用程序状态？在我之前的文章中有一个可行的建议列表——“在构建你的应用状态时避免意外的复杂性”。根据提示，这将是一个合适的结构:</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="lr ls l"/></div></figure><p id="cd3e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">主题URL将作为唯一的ID。</p><p id="fdb4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们将在哪里保持这种状态？在Redux中，<em class="kf">缩减器</em>是保存状态并更新状态的构造。我们将通过<em class="kf">域</em>来组织我们的代码，所以这个缩减器的自然位置将是:<code class="eh lu lv lw lx b">/src/store/topics/reducer.js</code></p><p id="77ea" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">有一些样板文件来创建一个缩减器，你可以在这里看到它<a class="ae ke" href="https://github.com/wix/react-dataflow-example/blob/0ff3077d3de9a4b2c0f1174a3fa204fee05ed594/src/store/topics/reducer.js" rel="noopener ugc nofollow" target="_blank"/>。注意，为了加强我们状态的<em class="kf">不变性</em>(如Redux所要求的)，我选择了使用名为<a class="ae ke" href="https://github.com/rtfeldman/seamless-immutable" rel="noopener ugc nofollow" target="_blank">无缝不可变</a>的不变性库。</p><h2 id="959a" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">我们的第一个场景</h2><p id="7e81" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">在对状态建模之后，我喜欢采用一个用户场景，并从头到尾实现它。在我们的例子中，让我们创建我们的<em class="kf">主题</em>屏幕，并在它一出现就显示一些主题。这个组件将连接到我们的reducer，这意味着它是一个“智能”组件，能够感知Redux。我们将把它放在<code class="eh lu lv lw lx b">/src/containers/TopicsScreen.js</code>中</p><p id="e9cb" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">有一些样板文件来创建一个连接的组件，你可以在这里看到它<a class="ae ke" href="https://github.com/wix/react-dataflow-example/blob/4151b3e702a002916f1d1579a2e33e0cf1cb0ba3/src/containers/TopicsScreen.js" rel="noopener ugc nofollow" target="_blank"/>。让我们也将它显示为我们的<a class="ae ke" href="https://github.com/wix/react-dataflow-example/blob/57d53f2901e46ab2d90f756fd8c5988a5521e8e8/src/App.js" rel="noopener ugc nofollow" target="_blank"> App组件</a>的内容。现在，当一切都设置好了，我们可以获取一些主题。</p><blockquote class="mm mn mo"><p id="1f30" class="jg jh kf ji b jj jk jl jm jn jo jp jq mp js jt ju mq jw jx jy mr ka kb kc kd hn dt translated"><strong class="ji hv"> <em class="hu">规则:</em> </strong> <em class="hu"> </em> <strong class="ji hv"> <em class="hu">智能组件不允许有除调度动作以外的任何逻辑。</em> </strong></p></blockquote><p id="7973" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">场景从视图的<code class="eh lu lv lw lx b">componentDidMount</code>开始。由于不能直接在视图上运行逻辑，我们将调度一个获取主题的动作。这个动作当然是异步的，所以它将是一个<a class="ae ke" href="https://github.com/gaearon/redux-thunk" rel="noopener ugc nofollow" target="_blank"> thunk </a>:</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="lr ls l"/></div></figure><p id="466e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">为了抽象Reddit服务器API，我们将创建一个新的<em class="kf">服务</em>来执行实际的网络获取。它的方法将是异步的，所以我们可以对响应进行<code class="eh lu lv lw lx b">await</code>。总的来说，我非常喜欢<a class="ae ke" href="https://jakearchibald.com/2014/es7-async-functions/" rel="noopener ugc nofollow" target="_blank"> async await API </a>，以至于我的代码已经很久没有直接使用过<code class="eh lu lv lw lx b">promises</code>了。</p><p id="08b0" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="kf">服务</em>返回一个<code class="eh lu lv lw lx b">array</code>，但是我们的状态结构将主题存储在一个<code class="eh lu lv lw lx b">map</code>中。动作体是进行转换的好地方。为了在状态中实际存储数据，我们必须通过调度一个标准的普通对象动作来调用我们的缩减器。</p><p id="2cc9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">此阶段的完整源代码可在<a class="ae ke" href="https://github.com/wix/react-dataflow-example/tree/a74d3607578c6ef65da738ab2f92b80789258b2b/src" rel="noopener ugc nofollow" target="_blank">此处</a>获得。</p><h2 id="0ca0" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">关于服务的几句话</h2><p id="6e58" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">服务用于抽象外部API——在许多情况下，服务器API就像Reddit的<a class="ae ke" href="https://www.reddit.com/dev/api/" rel="noopener ugc nofollow" target="_blank">提供的</a>一样。这个抽象层的好处是API的变化，我们希望尽可能地将代码与它们分离。如果将来Reddit决定重命名端点或更改域名，我们有望将对应用程序的影响控制在服务范围内。</p><blockquote class="mm mn mo"><p id="6b3a" class="jg jh kf ji b jj jk jl jm jn jo jp jq mp js jt ju mq jw jx jy mr ka kb kc kd hn dt translated"><strong class="ji hv"> <em class="hu">规则:服务必须完全无状态。</em> </strong></p></blockquote><p id="625f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在我们的方法论中，这是一个棘手的规则。想象一下如果我们的Reddit API需要登录会发生什么。我们可能会试图通过用登录详细信息实例化它来在<em class="kf">服务</em>中保存这个登录状态。</p><p id="a22b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这在我们的方法中是不允许的，因为所有的应用程序状态都必须包含在<em class="kf">存储</em>中。在<em class="kf">服务</em>中保持状态将是状态泄漏。在这种情况下，可接受的方法是为每个服务函数提供登录信息作为参数，并将登录状态保存在我们的一个<em class="kf">还原器</em>中。</p><p id="6640" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">实现服务相当简单，你可以在这里看到<a class="ae ke" href="https://github.com/wix/react-dataflow-example/blob/f0e4a6bc4ccdec0b757e3cca7a76b6812f66f49b/src/services/reddit.js" rel="noopener ugc nofollow" target="_blank"/>。</p><h2 id="d8dd" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">完成场景—缩减器和视图</h2><p id="011b" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">普通对象动作<code class="eh lu lv lw lx b">TOPICS_FETCHED</code>到达我们的缩减器，并包含新获取的<code class="eh lu lv lw lx b">topicsByUrl</code>作为参数。我们的reducer除了保存状态数据之外，不需要做太多工作:</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="lr ls l"/></div></figure><p id="04e6" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">请注意<a class="ae ke" href="https://github.com/rtfeldman/seamless-immutable#merge" rel="noopener ugc nofollow" target="_blank">无缝不可变</a>的用法，它使这种不可变的改变变得显而易见。不变性库当然是可选的，比起<a class="ae ke" href="http://redux.js.org/docs/recipes/UsingObjectSpreadOperator.html" rel="noopener ugc nofollow" target="_blank">对象传播技巧</a>，我更喜欢它们的语法糖。</p><p id="c0a2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">状态更新后，我们的视图需要重新呈现。这意味着视图需要监听它所关心的状态。这是通过<a class="ae ke" href="https://github.com/reactjs/react-redux" rel="noopener ugc nofollow" target="_blank"> mapStateToProps </a>完成的:</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="lr ls l"/></div></figure><p id="8030" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我决定我们的视图将使用一个单独的<code class="eh lu lv lw lx b">ListView</code>组件来呈现主题列表，该组件采用一个<code class="eh lu lv lw lx b">rowsById</code>地图和一个<code class="eh lu lv lw lx b">rowsIdArray</code>(受<a class="ae ke" href="https://facebook.github.io/react-native/docs/listview.html" rel="noopener ugc nofollow" target="_blank"> React Native </a>的启发)。我正在用<code class="eh lu lv lw lx b">mapStateToProps</code>准备<code class="eh lu lv lw lx b">TopicsScreen</code>中的这两个道具(稍后会直接传给<code class="eh lu lv lw lx b">ListView</code>)。这两个道具可以从我们的状态中推导出来。注意一些有趣的事情，我没有直接访问状态..</p><blockquote class="mm mn mo"><p id="0873" class="jg jh kf ji b jj jk jl jm jn jo jp jq mp js jt ju mq jw jx jy mr ka kb kc kd hn dt translated"><strong class="ji hv"> <em class="hu">规则:智能组件应该总是通过选择器访问状态。</em>T19】</strong></p></blockquote><p id="0e0e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">选择器是Redux中最重要的构造之一，但人们往往会忽略它。选择器是一个纯粹的函数，它将全局状态作为参数，并返回一些转换。选择器与<em class="kf">减速器</em>紧密耦合，位于<code class="eh lu lv lw lx b">reducer.js</code>内部。它们允许我们在视图使用数据之前对数据进行一些计算。在我们的方法中，我们将这一思想更进一步。每当有人需要访问状态的一部分时(像在<code class="eh lu lv lw lx b">mapStatetoProps</code>中)，他们需要通过一个选择器。</p><p id="59cf" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">为什么？想法是封装应用程序状态的内部结构，并从视图中隐藏它。想象一下，我们后来决定改变内部状态结构。我们不想检查应用程序中的所有视图并重构它们。传递一个选择器将允许我们将重构限制在<em class="kf">缩减器</em>上。</p><p id="dddc" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这就是我们的<code class="eh lu lv lw lx b">topics/reducer.js</code>的样子:</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="lr ls l"/></div></figure><p id="ee1a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们app的整个当前状态，包括<code class="eh lu lv lw lx b">ListView</code>，在这里可以看到<a class="ae ke" href="https://github.com/wix/react-dataflow-example/tree/6b115770ac82d6f78a9f209630d0e0165f359316/src" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="ab05" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">关于“哑”组件的一些话</h2><p id="8990" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated"><code class="eh lu lv lw lx b">ListView</code>是“哑”组件的一个很好的例子。它没有连接到商店，也不知道Redux。与位于<code class="eh lu lv lw lx b">/src/containers</code>的“智能”连接组件不同，这些组件位于<code class="eh lu lv lw lx b">/src/components</code></p><p id="72b1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">“哑”组件通过props从它们的父组件接收数据，并且可以保存本地组件状态。假设您正在从头开始实现一个<code class="eh lu lv lw lx b">TextInput</code>组件。闪烁的插入符号位置是本地组件状态的一个很好的例子，它不应该进入全局应用程序状态。</p><p id="5413" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">那么我们什么时候需要从“智能”组件转移到“笨”组件呢？</p><blockquote class="mm mn mo"><p id="85fb" class="jg jh kf ji b jj jk jl jm jn jo jp jq mp js jt ju mq jw jx jy mr ka kb kc kd hn dt translated"><strong class="ji hv"> <em class="hu">规则:将智能组件中的视图逻辑提取到哑组件中，使其最小化。</em>T12】</strong></p></blockquote><p id="2b1b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果你看一下<a class="ae ke" href="https://github.com/wix/react-dataflow-example/blob/6b115770ac82d6f78a9f209630d0e0165f359316/src/components/ListView.js" rel="noopener ugc nofollow" target="_blank"> ListView </a>的实现，你会看到它包含了视图逻辑，比如对行进行迭代。我们希望在我们的智能<a class="ae ke" href="https://github.com/wix/react-dataflow-example/blob/6b115770ac82d6f78a9f209630d0e0165f359316/src/containers/TopicsScreen.js" rel="noopener ugc nofollow" target="_blank"> TopicsScreen </a>组件中避免这种逻辑。这使得我们的智能组件仅作为布线。另一个好处是<code class="eh lu lv lw lx b">ListView</code>逻辑现在是可重用的。</p><h2 id="3d59" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">下一个场景—多主题选择</h2><p id="6dc9" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">我们已经完成了第一个场景。让我们继续下一个——让用户从列表中选择3个主题。</p><p id="8da6" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们的场景从用户点击其中一个主题开始。这个事件由<code class="eh lu lv lw lx b">TopicsScreen</code>处理，但是由于这个智能组件不能包含任何业务逻辑，我们将调度一个新的动作— <code class="eh lu lv lw lx b">selectTopic</code>。这个动作也将是一个<em class="kf"> thunk </em>，放置在<code class="eh lu lv lw lx b">topics/actions.js</code>中。如您所见，我们导出的几乎每个动作(由视图调度)都是一个<em class="kf"> thunk </em>。为了更新reducer状态，我们通常只从thunk内部分派普通的对象操作。</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="lr ls l"/></div></figure><p id="e425" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">关于这个thunk的一个有趣的方面是，它需要访问状态。注意我们是如何保持每个状态访问都要经过一个选择器的规则的(尽管有些人可能会说这有点过分)。</p><p id="813c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们必须更新reducer来处理<code class="eh lu lv lw lx b">TOPICS_SELECTED</code>动作并存储新选择的主题。有一个有趣的问题是<code class="eh lu lv lw lx b">selectTopic</code>是否需要成为<em class="kf"> thunk </em>。或者，我们可以让<code class="eh lu lv lw lx b">selectTopic</code>成为一个普通的对象动作，并将这个业务逻辑移到reducer本身。这是一个有效的策略。就我个人而言，我更喜欢将业务逻辑保持在thunks中。</p><p id="13d9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">一旦状态更新，我们需要将主题选择传播回我们的视图。这意味着在<code class="eh lu lv lw lx b">mapStateToProps</code>中添加选中的主题。由于视图需要查询每个<code class="eh lu lv lw lx b">rowId</code>是否被选中，所以将这些数据作为地图传递给视图更方便。由于数据无论如何都要经过一个选择器，这将是一个进行转换的好地方。</p><p id="c1f6" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">实现上述内容后，将由于行选择导致的背景颜色变化重构到一个新的哑组件——<code class="eh lu lv lw lx b">ListRow</code>——我们的app看起来就像<a class="ae ke" href="https://github.com/wix/react-dataflow-example/tree/a279a45055370ef769e5f799cf44a2b034131ab3/src" rel="noopener ugc nofollow" target="_blank">这个</a>。</p><h2 id="ab9e" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">关于业务逻辑的几句话</h2><p id="3dea" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">好方法的目标之一是实现视图和业务逻辑之间的适当分离。到目前为止，我们的业务逻辑是在哪里实现的？</p><p id="6593" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">所有的业务逻辑都在<code class="eh lu lv lw lx b">/src/store</code>目录下的Redux下实现。大部分在<code class="eh lu lv lw lx b">actions.js</code>的<em class="kf"> thunks </em>里面，还有一些在<code class="eh lu lv lw lx b">reducer.js</code>的<em class="kf">选择器</em>里面。这实际上是一个官方规则:</p><blockquote class="mm mn mo"><p id="bf3c" class="jg jh kf ji b jj jk jl jm jn jo jp jq mp js jt ju mq jw jx jy mr ka kb kc kd hn dt translated"><strong class="ji hv"> <em class="hu">规则:将所有业务逻辑放在动作处理程序(thunks)、选择器和归约器中。</em> </strong></p></blockquote><h2 id="b643" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">导航到下一个屏幕—帖子列表</h2><p id="7a94" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">当我们有不止一个屏幕时，我们需要一种导航方式。这通常是通过使用导航组件来实现的，比如<a class="ae ke" href="https://github.com/ReactTraining/react-router" rel="noopener ugc nofollow" target="_blank"> react-router </a>。为了使我们的例子简单，我想故意避免使用路由器。像路由器这样固执己见的外部依赖往往会将注意力从方法的概念讨论上转移开。</p><p id="e917" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">相反，让我们添加一个状态变量，<code class="eh lu lv lw lx b">selectionFinalized</code>，告诉我们用户是否完成了主题选择。一旦用户选择3个主题，我们将显示一个按钮，一旦点击，将完成选择，并移动到下一个屏幕。单击该按钮将调度一个直接设置该状态变量的操作。</p><p id="e0fa" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这与我们到目前为止所做的事情非常相似，唯一有趣的部分是知道何时显示按钮(只要至少选择了3个主题)。为此，我们可能会尝试添加另一个状态变量，但是这个变量实际上可以从我们现在状态中已经有的数据中导出。这意味着我们应该将这个业务逻辑实现为一个选择器<em class="kf"/>:</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="lr ls l"/></div></figure><p id="ec43" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">以上的完整实现可在<a class="ae ke" href="https://github.com/wix/react-dataflow-example/blob/2884e36fb3549b7aeb405145bef9e5f75eefaa1b/src/containers/TopicsScreen.js" rel="noopener ugc nofollow" target="_blank">这里</a>获得。为了进行实际的屏幕切换，我们需要将<code class="eh lu lv lw lx b">App</code>变成一个连接的组件，并让它在<code class="eh lu lv lw lx b">mapStateToProps</code>中监听<code class="eh lu lv lw lx b">selectionFinalized</code>。完整的实现可在<a class="ae ke" href="https://github.com/wix/react-dataflow-example/blob/5c9504d7138dfa08f98a77fc56c906288e4047e3/src/App.js" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><h2 id="7cf5" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">帖子屏幕—再次声明优先</h2><p id="5f89" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">既然我们现在对这个方法很有经验，我们可以更快地运行第二个屏幕的实现。这个新的屏幕处理一个新的领域— <em class="kf">帖子</em>。为了使我们的应用程序尽可能模块化，我们将给这个域一个单独的<em class="kf"> reducer </em>和单独的应用程序状态。</p><p id="0372" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">提醒—该屏幕的目的是显示可以根据主题过滤的帖子列表。用户可以点击列表中的帖子并查看其内容。根据我们的结构化提示<a class="ae ke" href="https://hackernoon.com/avoiding-accidental-complexity-when-structuring-your-app-state-6e6d22ad5e2a#.cn46edbo4" rel="noopener ugc nofollow" target="_blank">和</a>，这将会起作用:</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="lr ls l"/></div></figure><p id="1639" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">而我们的新<em class="kf">岗位</em>减速机是<a class="ae ke" href="https://github.com/wix/react-dataflow-example/blob/29f7a950a3c51143c4df85d92952a771014fb4ba/src/store/posts/reducer.js" rel="noopener ugc nofollow" target="_blank">出身</a>。</p><h2 id="1f0e" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">第一个场景—显示没有过滤器的帖子列表</h2><p id="d914" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">像往常一样，当我们的状态被建模时，我们转移到一个简单的用户场景，并从头到尾实现它。让我们从显示没有应用任何过滤器的完整帖子列表开始。</p><p id="8a59" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们需要一个新的智能容器来显示帖子，我们将其命名为<code class="eh lu lv lw lx b">PostsScreen</code>，并让它在挂载时调度一个名为<code class="eh lu lv lw lx b">fetchPosts</code>的新动作。在<code class="eh lu lv lw lx b">posts/actions.js</code>我们的新域名下，这个动作将会是<em class="kf"> thunk </em></p><p id="3f06" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这和我们之前做的很像，这里实现的是<a class="ae ke" href="https://github.com/wix/react-dataflow-example/blob/1298dc958b5c4c1b01b8f3f187f127d0dc291694/src/store/posts/actions.js" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><p id="56b5" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在thunk结束时，我们发出简单的动作<code class="eh lu lv lw lx b">POSTS_FETCHED</code>,将柱子运送到减速器。我们必须修改我们的减速器来存储数据。为了在<code class="eh lu lv lw lx b">PostsScreen</code>中显示列表，我们需要将其<code class="eh lu lv lw lx b">mapStateToProps</code>连接到提供这部分状态的选择器。然后，我们可以通过重用我们的<code class="eh lu lv lw lx b">ListView</code>组件来显示列表。</p><p id="13c7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">也没什么新的，这里的实现是<a class="ae ke" href="https://github.com/wix/react-dataflow-example/blob/5a521145eb3a49be1bf2d0c1c529db31f7841c3d/src/containers/PostsScreen.js" rel="noopener ugc nofollow" target="_blank"/>。</p><h2 id="1ef9" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">下一个场景—过滤帖子列表</h2><p id="682d" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">这个场景从向用户显示可用的过滤器开始。我们可以使用现有的选择器从<em class="kf">主题</em>缩减器状态中提取这些数据。当一个过滤器被改变时，我们将分派一个动作，直接在<em class="kf">post</em>reducer中改变它。</p><p id="8542" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">有趣的部分是将过滤器应用于帖子列表。在我们的应用程序状态下，我们目前持有所有的<code class="eh lu lv lw lx b">postsById</code>和<code class="eh lu lv lw lx b">currentFilter</code>。我们不希望将过滤后的结果保存在应用程序状态中，因为它可以从它们中派生出来。在到达<code class="eh lu lv lw lx b">mapStateToProps</code>中的视图之前，用于导出数据的业务逻辑在<em class="kf">选择器</em>中运行。因此，我们的选择器将是:</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="lr ls l"/></div></figure><p id="9fb4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">此阶段的完整实现可在<a class="ae ke" href="https://github.com/wix/react-dataflow-example/tree/938c0d6ef8cff2bdd66cdd8a5ad3693fd7ffaffa/src" rel="noopener ugc nofollow" target="_blank">此处</a>获得。</p><h2 id="5f72" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">最后一个场景—显示帖子详细信息</h2><p id="45ce" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">这个场景实际上是最简单的。我们有一个保存<code class="eh lu lv lw lx b">currentPostId</code>的应用程序状态变量。我们所要做的就是当用户点击列表中的一篇文章时，通过调度一个动作来更新它。<code class="eh lu lv lw lx b">PostsScreen</code>需要这个状态变量来显示文章细节，这意味着我们需要一个<em class="kf">选择器</em>来驱动它进入<code class="eh lu lv lw lx b">mapStateToProps</code>。</p><p id="4ad0" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这里看一下详细实现<a class="ae ke" href="https://github.com/wix/react-dataflow-example/blob/ae35eaa20b798b34225240a13a52c3e2586a4208/src/containers/PostsScreen.js" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><h2 id="a2e5" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">我们完事了。</h2><p id="74d0" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">这也完成了我们整个示例应用程序的实现。该应用程序的完整源代码可在GitHub上获得:<br/><a class="ae ke" href="https://github.com/wix/react-dataflow-example" rel="noopener ugc nofollow" target="_blank">https://github.com/wix/react-dataflow-example</a></p><figure class="ln lo lp lq fq iv fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/1172a24d932af66e27f0aef9a3d63fca.png" data-original-src="https://miro.medium.com/v2/resize:fit:256/format:webp/1*gVe7mIUjHcslYBUMBPGsRQ.png"/></div></figure><h2 id="5031" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">我们固执己见的工作流程规则摘要</h2><ul class=""><li id="d149" class="ly lz hu ji b jj li jn lj jr mt jv mu jz mv kd md me mf mg dt translated"><em class="kf"> App状态是一等公民，</em> <a class="ae ke" href="https://hackernoon.com/avoiding-accidental-complexity-when-structuring-your-app-state-6e6d22ad5e2a#.cn46edbo4" rel="noopener ugc nofollow" target="_blank"> <em class="kf">结构</em> </a> <em class="kf">它像一个内存中的数据库。</em></li><li id="0132" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated"><em class="kf">智能组件不允许有除调度动作以外的任何逻辑。</em></li><li id="7e77" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated"><em class="kf">智能组件应该总是通过选择器访问状态。</em></li><li id="3568" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated"><em class="kf">通过将智能组件中的视图逻辑提取到非智能组件中，使其最小化。</em></li><li id="9276" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated"><em class="kf">将所有业务逻辑放在动作处理器(thunks)、选择器和归约器中。</em></li><li id="fb39" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">服务必须是完全无状态的。</li></ul></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><p id="c178" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">记住，Redux为个人风格提供了很大的空间。有许多具有不同规则集的备用工作流。我想起了我的一些好朋友，他们更喜欢<a class="ae ke" href="https://github.com/pburtchaell/redux-promise-middleware" rel="noopener ugc nofollow" target="_blank">redux-promise-middleware</a>而不是<em class="kf"> thunks </em>，并且喜欢将所有的业务逻辑只放在<em class="kf">reducer</em>中。</p><p id="035f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果你想分享一个不同的为你工作的方法，请随意为上面的项目准备你自己的实现，我们将提供它作为一个比较的分支。</p><div class="ln lo lp lq fq ab cb"><figure class="mw iv mx my mz na nb paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mw iv mx my mz na nb paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mw iv mx my mz na nb paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mm mn mo"><p id="f922" class="jg jh kf ji b jj jk jl jm jn jo jp jq mp js jt ju mq jw jx jy mr ka kb kc kd hn dt translated"><a class="ae ke" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是阿美族家庭的一员。我们现在<a class="ae ke" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ke" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jg jh kf ji b jj jk jl jm jn jo jp jq mp js jt ju mq jw jx jy mr ka kb kc kd hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ke" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ke" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ln lo lp lq fq iv fe ff paragraph-image"><a href="https://goo.gl/Ahtev1"><div class="fe ff nc"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></a></figure><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="nd ls l"/></div></figure></div></div>    
</body>
</html>