<html>
<head>
<title>Timing Tests in Python for Fun and Profit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为了乐趣和利益用Python进行计时测试</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/timing-tests-in-python-for-fun-and-profit-1663144571?source=collection_archive---------2-----------------------#2016-11-09">https://medium.com/hackernoon/timing-tests-in-python-for-fun-and-profit-1663144571?source=collection_archive---------2-----------------------#2016-11-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="6606" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">因为提高测试性能的第一步是意识！</h2></div></div><div class="ab cl jj jk hc jl" role="separator"><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo"/></div><div class="hn ho hp hq hr"><p id="dcfd" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">为了更好的阅读体验，请在我的网站上查看<a class="ae km" href="https://hakibenita.com/timing-tests-in-python-for-fun-and-profit" rel="noopener ugc nofollow" target="_blank">这篇文章。</a></p></div><div class="ab cl jj jk hc jl" role="separator"><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo"/></div><div class="hn ho hp hq hr"><p id="9505" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">几天前我正准备推动一些改变，像往常一样，我进行了测试。当这些点在屏幕上快速移动时，我坐回到椅子上，突然我注意到其中一个点还在徘徊。“操作系统可能正在后台运行一些更新或什么的”我对自己说，并再次运行测试只是为了确认。我仔细看着这些点填满了屏幕，它又出现了——<strong class="js hv">我有一个慢速测试</strong>！</p><figure class="ko kp kq kr fq ks fe ff paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="fe ff kn"><img src="../Images/dd97d4c578258bc4b3484b55d5cb82b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xMVk_0cvPSOadYrT_Ay6Gg.png"/></div></div><figcaption class="kz la fg fe ff lb lc bd b be z ek"><strong class="bd ld">Can you spot the slow test? Neither can I…</strong></figcaption></figure><p id="71b4" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated"><strong class="js hv">我们将通过报告耗时超过某个阈值的测试来追踪缓慢的测试。</strong></p><h1 id="8dbe" class="le lf hu bd lg lh li lj lk ll lm ln lo ja lp jb lq jd lr je ls jg lt jh lu lv dt translated">基础知识</h1><p id="9aab" class="pw-post-body-paragraph jq jr hu js b jt lw iv jv jw lx iy jy jz ly kb kc kd lz kf kg kh ma kj kk kl hn dt translated">为了开始，让我们创建一个简单的测试用例，包括一个快速测试和一个慢速测试:</p><pre class="ko kp kq kr fq mb mc md me aw mf dt"><span id="d047" class="mg lf hu mc b fv mh mi l mj mk">import time<br/>import unittest</span><span id="47e5" class="mg lf hu mc b fv ml mi l mj mk">class <strong class="mc hv">SlowTestCase</strong>(unittest.TestCase):</span><span id="bd34" class="mg lf hu mc b fv ml mi l mj mk">    def <strong class="mc hv">test_should_run_fast</strong>(self):<br/>        self.assertEqual(1, 1)</span><span id="1d55" class="mg lf hu mc b fv ml mi l mj mk">    def <strong class="mc hv">test_should_run_slow</strong>(self):<br/><strong class="mc hv">        </strong>time.sleep(0.5)<strong class="mc hv"><br/></strong>        self.assertEqual(1, 1)</span></pre><p id="8595" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">从命令行运行此脚本会产生以下输出:</p><pre class="ko kp kq kr fq mb mc md me aw mf dt"><span id="369c" class="mg lf hu mc b fv mh mi l mj mk">&gt; python -m unittest timing.py<br/>..<br/>Ran 2 tests in 0.502s</span><span id="391b" class="mg lf hu mc b fv ml mi l mj mk"><strong class="mc hv">OK</strong></span></pre><p id="d4ec" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">对不起unittest，但是<strong class="js hv">这个</strong> <strong class="js hv">肯定不行</strong> —两次测试0.5s？</p><p id="7744" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">为了找出哪些测试很慢，我们需要<strong class="js hv">测量每个测试执行</strong>所花费的时间。</p><p id="04f4" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">python单元测试。TestCase有按以下顺序执行的钩子:</p><pre class="ko kp kq kr fq mb mc md me aw mf dt"><span id="88e2" class="mg lf hu mc b fv mh mi l mj mk">&gt; setUpClass<br/>    &gt; setUp<br/>        &gt; test_*<br/>    &gt; tearDown<br/>&gt; tearDownClass</span></pre><p id="44d1" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">如果我们想对单个测试(test_*)计时，我们需要在设置中启动一个计时器，并在拆卸时停止它:</p><pre class="ko kp kq kr fq mb mc md me aw mf dt"><span id="8726" class="mg lf hu mc b fv mh mi l mj mk">import time<br/>import unittest</span><span id="1eff" class="mg lf hu mc b fv ml mi l mj mk">class SlowTestCase(unittest.TestCase):</span><span id="8a52" class="mg lf hu mc b fv ml mi l mj mk">   <strong class="mc hv"> def setUp(self):<br/>        self._started_at = time.time()</strong></span><span id="a895" class="mg lf hu mc b fv ml mi l mj mk"><strong class="mc hv">    def tearDown(self):<br/>        elapsed = time.time() - self._started_at<br/>        print('{} ({}s)'.format(self.id(), round(elapsed, 2)))</strong></span><span id="d767" class="mg lf hu mc b fv ml mi l mj mk">    def test_should_run_fast(self):<br/>        self.assertEqual(1, 1)</span><span id="5797" class="mg lf hu mc b fv ml mi l mj mk">    def test_should_run_slow(self):<br/>        time.sleep(0.5)<br/>        self.assertEqual(1, 1)</span></pre><p id="c87b" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">这会产生以下输出:</p><pre class="ko kp kq kr fq mb mc md me aw mf dt"><span id="7fe2" class="mg lf hu mc b fv mh mi l mj mk">&gt; python -m unittest timing.py</span><span id="f86f" class="mg lf hu mc b fv ml mi l mj mk">__main__.SlowTestCase.test_should_run_fast (0.0s)<br/>.__main__.SlowTestCase.test_should_run_slow (0.5s)<br/>.</span><span id="a109" class="mg lf hu mc b fv ml mi l mj mk">Ran 2 tests in 0.503s<br/>OK</span></pre><p id="c3cd" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">太好了！我们得到了每次测试的时间，但我们真正想要的是<strong class="js hv">那些慢的</strong>。</p><p id="e138" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">假设慢速测试是指耗时超过0.3秒的测试:</p><pre class="ko kp kq kr fq mb mc md me aw mf dt"><span id="b88c" class="mg lf hu mc b fv mh mi l mj mk"><strong class="mc hv">SLOW_TEST_THRESHOLD = 0.3</strong></span><span id="44a5" class="mg lf hu mc b fv ml mi l mj mk">class SlowTestCase(unittest.TestCase):<br/>    …<br/>    def tearDown(self):<br/>        elapsed = time.time() - self._started_at<br/>        <strong class="mc hv">if elapsed &gt; SLOW_TEST_THRESHOLD:</strong><br/>            print('{} ({}s)'.format(self.id(), round(elapsed, 2)))</span></pre><p id="4058" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">输出是:</p><pre class="ko kp kq kr fq mb mc md me aw mf dt"><span id="e6d4" class="mg lf hu mc b fv mh mi l mj mk">&gt; python -m unittest timing.py <br/>.__main__.SlowTestCase.test_should_run_slow (0.5s)<br/>.<br/>Ran 2 tests in 0.503s</span><span id="c149" class="mg lf hu mc b fv ml mi l mj mk">OK</span></pre><p id="d3a5" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">厉害！我们完全得到了我们想要的，但它仍然是不完整的。我们是优秀的开发人员，所以我们很可能非常懒。我们不想到处去更新每个测试用例— <strong class="js hv">我们需要一个更健壮的解决方案</strong>。</p><h1 id="dc4d" class="le lf hu bd lg lh li lj lk ll lm ln lo ja lp jb lq jd lr je ls jg lt jh lu lv dt translated">跑步者</h1><p id="6fa8" class="pw-post-body-paragraph jq jr hu js b jt lw iv jv jw lx iy jy jz ly kb kc kd lz kf kg kh ma kj kk kl hn dt translated"><strong class="js hv"> TestRunner </strong>的作用之一是将测试结果打印到输出流中。运行程序使用一个<strong class="js hv"> TestResult </strong>对象来格式化结果。unittest模块自带默认的<a class="ae km" href="https://docs.python.org/3/library/unittest.html#unittest.TextTestRunner" rel="noopener ugc nofollow" target="_blank"><strong class="js hv">TextTestRunner</strong></a><strong class="js hv"/>和<a class="ae km" href="https://docs.python.org/3/library/unittest.html#unittest.TextTestResult" rel="noopener ugc nofollow" target="_blank"><strong class="js hv">TextTestResult</strong></a>。</p><p id="6cd5" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">让我们实现一个定制的TestResult来报告缓慢的测试:</p><pre class="ko kp kq kr fq mb mc md me aw mf dt"><span id="646b" class="mg lf hu mc b fv mh mi l mj mk">import time<br/>from unittest.runner import TextTestResult</span><span id="6361" class="mg lf hu mc b fv ml mi l mj mk">SLOW_TEST_THRESHOLD = 0.3</span><span id="dc06" class="mg lf hu mc b fv ml mi l mj mk">class <strong class="mc hv">TimeLoggingTestResult</strong>(<strong class="mc hv">TextTestResult</strong>):</span><span id="891a" class="mg lf hu mc b fv ml mi l mj mk">    def <strong class="mc hv">startTest</strong>(self, test):<br/>        self._started_at = time.time()<br/>        super().startTest(test)</span><span id="7583" class="mg lf hu mc b fv ml mi l mj mk">    def <strong class="mc hv">addSuccess</strong>(self, test):<br/>        elapsed = time.time() - self._started_at<br/>        if elapsed &gt; SLOW_TEST_THRESHOLD:<br/>            name = self.getDescription(test)<br/>            self.stream.write(<br/>                "\n{} ({:.03}s)\n".format(<br/>                    name, elapsed))<br/>        super().addSuccess(test)</span></pre><p id="7e52" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">几乎与我们已经拥有的相同，但使用了<strong class="js hv">不同的挂钩— </strong>我们使用testStart代替setUp，使用addSuccess代替tearDown。</p><p id="2dde" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">内置的TextTestRunner使用TextTestResult。为了使用不同的测试结果，我们用我们的Runner创建了一个<strong class="js hv"> TextTestRunner </strong>的实例:</p><pre class="ko kp kq kr fq mb mc md me aw mf dt"><span id="dec9" class="mg lf hu mc b fv mh mi l mj mk">from unittest import TextTestRunner</span><span id="1aec" class="mg lf hu mc b fv ml mi l mj mk">if __name__ == '__main__':<br/>    test_runner = <strong class="mc hv">TextTestRunner</strong>(<strong class="mc hv">resultclass=TimeLoggingTestResult</strong>)<br/>    unittest.main(<strong class="mc hv">testRunner=test_runner</strong>)</span></pre><p id="76d3" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">输出是:</p><pre class="ko kp kq kr fq mb mc md me aw mf dt"><span id="ecd7" class="mg lf hu mc b fv mh mi l mj mk">&gt; python runner.py<br/>.<br/>test_should_run_slow (__main__.SlowTestCase) (0.501s)<br/>.<br/>Ran 2 tests in 0.501s</span><span id="0cc5" class="mg lf hu mc b fv ml mi l mj mk">OK</span></pre><p id="eb85" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">我们得到了一份很好的报告<strong class="js hv">，而不需要对现有的测试用例做任何改变</strong>。</p><p id="26a2" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated"><strong class="js hv">盈利！</strong></p><h1 id="13c5" class="le lf hu bd lg lh li lj lk ll lm ln lo ja lp jb lq jd lr je ls jg lt jh lu lv dt translated">我们能做得更好吗？</h1><p id="67da" class="pw-post-body-paragraph jq jr hu js b jt lw iv jv jw lx iy jy jz ly kb kc kd lz kf kg kh ma kj kk kl hn dt translated">现在我们有一堆信息散布在屏幕上随机的地方。如果我们可以通过所有的慢速测试得到一个好的报告呢？嗯，我们可以！</p><p id="f613" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">让我们从让我们的测试结果存储计时而不报告计时开始:</p><pre class="ko kp kq kr fq mb mc md me aw mf dt"><span id="2ab8" class="mg lf hu mc b fv mh mi l mj mk">import time<br/>from unittest.runner import TextTestResult</span><span id="341b" class="mg lf hu mc b fv ml mi l mj mk">class TimeLoggingTestResult(TextTestResult):<br/>    def __init__(self, *args, **kwargs):<br/>        super().__init__(*args, **kwargs)<br/><strong class="mc hv">        self.test_timings = []</strong></span><span id="a42d" class="mg lf hu mc b fv ml mi l mj mk">    def startTest(self, test):<br/>        self._test_started_at = time.time()<br/>        super().startTest(test)</span><span id="650b" class="mg lf hu mc b fv ml mi l mj mk">    def addSuccess(self, test):<br/>        elapsed = time.time() - self._test_started_at<br/>        name = self.getDescription(test)<br/><strong class="mc hv">        self.test_timings.append((name, elapsed))<br/></strong>        super().addSuccess(test)</span><span id="bf03" class="mg lf hu mc b fv ml mi l mj mk"><strong class="mc hv">    def getTestTimings(self):<br/>        return self.test_timings</strong></span></pre><p id="61d5" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">测试结果现在包含一个元组列表，其中包含测试名称和运行时间。转到我们的定制TestRunner:</p><pre class="ko kp kq kr fq mb mc md me aw mf dt"><span id="e656" class="mg lf hu mc b fv mh mi l mj mk">import unittest</span><span id="1dad" class="mg lf hu mc b fv ml mi l mj mk">class TimeLoggingTestRunner(unittest.TextTestRunner):<br/>    <br/>    def <strong class="mc hv">__init__</strong>(self, slow_test_threshold=0.3, *args, **kwargs):<br/><strong class="mc hv">        self.slow_test_threshold = slow_test_threshold<br/></strong>        return super().__init__(<br/>            <strong class="mc hv">resultclass=TimeLoggingTestResult</strong>,<br/>            *args,<br/>            **kwargs,<br/>        )</span><span id="3866" class="mg lf hu mc b fv ml mi l mj mk">    def <strong class="mc hv">run</strong>(self, test):<br/>        result = super().run(test)</span><span id="3575" class="mg lf hu mc b fv ml mi l mj mk">        self.stream.writeln(<br/>            "\nSlow Tests (&gt;{:.03}s):".format(<br/>                self.slow_test_threshold))</span><span id="5fa9" class="mg lf hu mc b fv ml mi l mj mk">        <strong class="mc hv">for name, elapsed in result.getTestTimings():<br/>            if elapsed &gt; self.slow_test_threshold:<br/>                self.stream.writeln(<br/>                    "({:.03}s) {}".format(<br/>                        elapsed, name))</strong></span><span id="2643" class="mg lf hu mc b fv ml mi l mj mk"><strong class="mc hv">        </strong>return result</span></pre><p id="0d7a" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">让我们来分解一下:</p><ul class=""><li id="d296" class="mm mn hu js b jt ju jw jx jz mo kd mp kh mq kl mr ms mt mu dt translated">我们已经用init的一个参数替换了SLOW _ TEST _ THRESHOLD更加简洁。</li><li id="ef5b" class="mm mn hu js b jt mv jw mw jz mx kd my kh mz kl mr ms mt mu dt translated">我们已经设置了适当的TestResult类。</li><li id="18e9" class="mm mn hu js b jt mv jw mw jz mx kd my kh mz kl mr ms mt mu dt translated">我们已经覆盖了run并添加了自定义“慢速测试”报告。</li></ul><p id="68d1" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">这是输出的样子(我添加了一些缓慢的测试来说明):</p><pre class="ko kp kq kr fq mb mc md me aw mf dt"><span id="590d" class="mg lf hu mc b fv mh mi l mj mk">&gt; python timing.py<br/>.....<br/>Ran 5 tests in 1.706s</span><span id="b542" class="mg lf hu mc b fv ml mi l mj mk">OK</span><span id="d72b" class="mg lf hu mc b fv ml mi l mj mk"><strong class="mc hv">Slow Tests (&gt;0.3s):<br/>(0.501s) test_should_run_slow (__main__.SlowTestCase)<br/>(0.802s) test_should_run_very_slow (__main__.SlowTestCase)<br/>(0.301s) test_should_run_slow_enough (__main__.SlowTestCase)</strong></span></pre><p id="7a06" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">现在我们有了时间数据，我们可以用它来生成有趣的报告。我们可以按运行时间排序，显示潜在的时间减少，并突出显示缓慢的测试。</p><h1 id="1619" class="le lf hu bd lg lh li lj lk ll lm ln lo ja lp jb lq jd lr je ls jg lt jh lu lv dt translated">这个怎么和Django一起用？</h1><p id="a570" class="pw-post-body-paragraph jq jr hu js b jt lw iv jv jw lx iy jy jz ly kb kc kd lz kf kg kh ma kj kk kl hn dt translated">Django有自己的测试程序，所以我们需要做一些调整:</p><pre class="ko kp kq kr fq mb mc md me aw mf dt"><span id="698a" class="mg lf hu mc b fv mh mi l mj mk"># common/test/runner.py</span><span id="2922" class="mg lf hu mc b fv ml mi l mj mk"><strong class="mc hv">from django.test.runner import DiscoverRunner</strong></span><span id="2ef1" class="mg lf hu mc b fv ml mi l mj mk">class TimeLoggingTestRunner(DiscoverRunner):<br/>    def <strong class="mc hv">get_resultclass</strong>(self):<br/>        return TimeLoggingTestResult</span></pre><p id="3bfe" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">为了让Django使用我们的定制runner，我们设置了以下内容:</p><pre class="ko kp kq kr fq mb mc md me aw mf dt"><span id="5d15" class="mg lf hu mc b fv mh mi l mj mk"># settings.py</span><span id="1144" class="mg lf hu mc b fv ml mi l mj mk"><strong class="mc hv">TEST_RUNNER</strong> = ‘common.tests.runner.TimeLoggingTestRunner</span></pre><h1 id="3786" class="le lf hu bd lg lh li lj lk ll lm ln lo ja lp jb lq jd lr je ls jg lt jh lu lv dt translated">最后的话</h1><p id="831a" class="pw-post-body-paragraph jq jr hu js b jt lw iv jv jw lx iy jy jz ly kb kc kd lz kf kg kh ma kj kk kl hn dt translated">快去做些测试吧！</p><div class="ko kp kq kr fq ab cb"><figure class="na ks nb nc nd ne nf paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="na ks nb nc nd ne nf paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="na ks nb nc nd ne nf paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ng nh ni"><p id="f922" class="jq jr nj js b jt ju iv jv jw jx iy jy nk ka kb kc nl ke kf kg nm ki kj kk kl hn dt translated"><a class="ae km" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae km" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae km" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae km" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jq jr nj js b jt ju iv jv jw jx iy jy nk ka kb kc nl ke kf kg nm ki kj kk kl hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae km" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae km" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ko kp kq kr fq ks fe ff paragraph-image"><a href="https://goo.gl/Ahtev1"><div class="fe ff nn"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></a></figure></div></div>    
</body>
</html>