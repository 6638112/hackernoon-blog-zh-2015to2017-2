<html>
<head>
<title>Lexical Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">词汇分析</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/lexical-analysis-861b8bfe4cb0?source=collection_archive---------0-----------------------#2017-09-15">https://medium.com/hackernoon/lexical-analysis-861b8bfe4cb0?source=collection_archive---------0-----------------------#2017-09-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/aaf1f7a865a31d83a7b870a4686e550f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L18qT6AvHEfPvLMq7TTsuw.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="https://en.wikipedia.org/wiki/Cypress_Trees" rel="noopener ugc nofollow" target="_blank">Cypress Trees</a>, <a class="ae jg" href="https://en.wikipedia.org/wiki/Kan%C5%8D_Eitoku" rel="noopener ugc nofollow" target="_blank">Kanō Eitoku</a></figcaption></figure><p id="923b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">欢迎来到<a class="ae jg" href="https://hackernoon.com/lets-build-a-programming-language-2612349105c6" rel="noopener ugc nofollow" target="_blank"> <em class="kf">让我们构建一个编程语言(LBPL) </em>系列</a>的第三篇文章。如果这是你正在阅读的这个系列的第一篇文章，那么《LBPL》是带领读者从0到1实现编程语言的系列文章。你可以在这里查看第二篇关于编译器和解释器的文章<a class="ae jg" href="https://hackernoon.com/compilers-and-interpreters-3e354a2e41cf" rel="noopener ugc nofollow" target="_blank">，在这里</a>查看一般介绍<a class="ae jg" href="https://hackernoon.com/lets-build-a-programming-language-2612349105c6" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="b3ee" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">本文将描述如何构建编译器的第一阶段，<strong class="jj hv">lexer</strong>。在文章的最后，你会用一个<a class="ae jg" href="https://github.com/ftchirou/blink-lexer" rel="noopener ugc nofollow" target="_blank">挑战</a>弄脏你的手:为<a class="ae jg" href="https://hackernoon.com/lets-build-a-programming-language-2612349105c6#1d67" rel="noopener ugc nofollow" target="_blank"> Blink </a>构建一个lexer。</p><h1 id="2911" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">入门指南</h1><p id="6ec4" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated"><strong class="jj hv">词法分析器</strong>，也称为<strong class="jj hv">词法分析器</strong>或<strong class="jj hv">分词器</strong>，是一个将输入源代码分解成一系列词法序列的程序。它逐字符读取输入源代码，识别词位，并输出描述词位的标记序列。</p><h2 id="a11c" class="lj kh hu bd ki lk ll lm km ln lo lp kq js lq lr ku jw ls lt ky ka lu lv lc lw dt translated">什么是词位？</h2><p id="29ad" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">一个<strong class="jj hv">词位</strong>是一个可识别的字符序列，例如，关键字(如<code class="eh lx ly lz ma b">class</code>、<code class="eh lx ly lz ma b">func</code>、<code class="eh lx ly lz ma b">var</code>和<code class="eh lx ly lz ma b">while</code>)、文字(如数字和字符串)、标识符、运算符或标点符号(如<code class="eh lx ly lz ma b">{</code>、<code class="eh lx ly lz ma b">(</code>和<code class="eh lx ly lz ma b">.</code>)。</p><h2 id="2212" class="lj kh hu bd ki lk ll lm km ln lo lp kq js lq lr ku jw ls lt ky ka lu lv lc lw dt translated">什么是代币？</h2><p id="a87e" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated"><strong class="jj hv">标记</strong>是描述<em class="kf">词位</em>的对象。一个令牌有一个<strong class="jj hv">类型</strong>(例如关键字、标识符、数字或运算符)和一个<strong class="jj hv">值</strong>(所描述的词位<em class="kf"> ) </em>。一个标记还可以包含其他信息，比如在源代码中遇到词位的行号和列号。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">An implementation of a token in JavaScript (ES6). Using this class, the lexeme “Hello, Blink!”, for example, could be represented by the token <strong class="ak">Token</strong>(TokenType.<strong class="ak">String</strong>, “Hello, Blink!”).</figcaption></figure><h2 id="d21e" class="lj kh hu bd ki lk ll lm km ln lo lp kq js lq lr ku jw ls lt ky ka lu lv lc lw dt translated">代码中的词法分析器</h2><p id="2468" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">一个<strong class="jj hv">词法分析器</strong>可以被实现为一个类，它的构造函数在参数中接受一个输入字符串(代表要执行词法分析的源代码)。它公开了一个方法来识别并返回输入中的下一个标记。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Skeleton of the Lexer class</figcaption></figure><h2 id="8bb2" class="lj kh hu bd ki lk ll lm km ln lo lp kq js lq lr ku jw ls lt ky ka lu lv lc lw dt translated">如何识别令牌</h2><p id="5279" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">所有可能出现在用编程语言编写的代码中的词汇，都在该编程语言的规范中被描述为一组称为<strong class="jj hv">词汇语法</strong>的规则。词法语法中的规则经常被转换成称为<strong class="jj hv">有限状态机</strong> ( <em class="kf"> FSM </em>)的自动机。然后，lexer模拟有限状态机来识别令牌。</p><p id="39ec" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在本文的下一节中，我们将研究组成编程语言词法语法的规则、有限状态机、如何将词法语法中的规则转换成有限状态机，以及如何在<code class="eh lx ly lz ma b">Lexer</code>类的<code class="eh lx ly lz ma b">nextToken()</code>方法中实现和使用有限状态机来识别下一个令牌。</p><p id="de7f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在后面的部分中，我们将为一种迷你语言构建一个词法分析器，你将被介绍到一个挑战中，你将不得不为眨眼编写你自己的词法分析器。</p><h1 id="82e1" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">词汇语法</h1><p id="921a" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">一种编程语言的词汇语法是一组形式规则，控制着该编程语言中有效的词汇是如何构造的。例如，规则可以规定字符串是任何用双引号括起来的字符序列，或者标识符不能以数字开头。词汇语法中的规则通常用一组<strong class="jj hv">常规定义</strong>来表达。</p><p id="f10b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">正则定义的形式是<code class="eh lx ly lz ma b">&lt;element_name&gt; = &lt;production_rule&gt;</code>，其中<code class="eh lx ly lz ma b">&lt;element_name&gt;</code>是在编程语言中遇到的符号或词位的名称，<code class="eh lx ly lz ma b">&lt;production_rule&gt;</code>是描述该符号或词位的<a class="ae jg" href="#1b6b" rel="noopener ugc nofollow"> <strong class="jj hv">正则表达式</strong> </a>。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff mh"><img src="../Images/66efe286c06bc46e04133fa04ce5a146.png" data-original-src="https://miro.medium.com/v2/resize:fit:358/format:webp/1*1Wo0ZtH0pwbgKSwgaPpgPw.png"/></div></figure><p id="2b97" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">例如，上面的常规定义将<em class="kf">字母</em>定义为任何小写或大写字母字符。</p><p id="9133" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">正则定义可以在其正则表达式中使用在同一词法语法中定义的任何元素名。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff mi"><img src="../Images/85629c620c473aa7ab1b294d541500ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*w3TBytWGtz2-Y2yWjvQmcQ.png"/></div></figure><p id="8d41" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">作为一个例子，在上面的常规定义中，定义<em class="kf">标识符</em>重用定义<em class="kf">字母</em>和<em class="kf">数字</em>，在其产生规则中好像<em class="kf">字母</em>和<em class="kf">数字</em>是符号一样，以将标识符定义为以字母或下划线开头的任意字符串<em class="kf">，</em>后跟字母、数字或下划线的零个或多个出现。</p><h1 id="b4cc" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">有限状态机</h1><p id="aa04" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">有限状态机或FSM是一种抽象机器，在任何时间点都处于<em class="kf">且只有一个</em>状态。作为事件的结果，FSM可以从一种状态改变到另一种状态。从一种状态改变到另一种状态被称为<strong class="jj hv">转换</strong>。为了更好地理解这一点，让我们考虑下面的例子。</p><p id="7382" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">灯泡可以被认为是FSM。在任何时间点，灯泡只能处于两种状态之一，即<code class="eh lx ly lz ma b">ON</code>或<code class="eh lx ly lz ma b">OFF</code>。按下开关，灯泡从状态<code class="eh lx ly lz ma b">ON</code>转换到状态<code class="eh lx ly lz ma b">OFF</code>，按下同一开关，灯泡从状态<code class="eh lx ly lz ma b">OFF</code>转换到<code class="eh lx ly lz ma b">ON</code>。</p><p id="3ced" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">FSM通常用<a class="ae jg" href="https://en.wikipedia.org/wiki/State_diagram" rel="noopener ugc nofollow" target="_blank">状态图</a>表示。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff mj"><img src="../Images/c8db81e82796c806c912e7cff119c449.png" data-original-src="https://miro.medium.com/v2/resize:fit:432/format:webp/1*5GpNjuE2BgKsF5T1RU6qsA.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">A FSM simulating a light bulb. States are represented with circles and transitions with labeled arrows.</figcaption></figure><h2 id="edc1" class="lj kh hu bd ki lk ll lm km ln lo lp kq js lq lr ku jw ls lt ky ka lu lv lc lw dt translated">词汇语法和有限状态机</h2><p id="9325" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">为了识别由正则定义描述的记号，定义中的正则表达式通常被转换成FSM。得到的FSM具有有限数量的状态<strong class="jj hv">包括初始状态<strong class="jj hv">和接受状态</strong>的集合</strong>。</p><p id="cca6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">FSM通过使用正则表达式中的一个字符 <em class="kf">或元素</em>从一种状态转移到另一种状态。从初始状态到接受状态之一的转换产生了由正则表达式描述的有效字符串。</p><p id="d226" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">例如，正则表达式<em class="kf"> a | b </em>可以转换成下面的FSM。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff mk"><img src="../Images/cacb9d752904abf62858e6ea15e3c1a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*1iBERHUlaKDT7mJQN04Arg.png"/></div></figure><p id="47bb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">上述FSM有两种状态，标记为<strong class="jj hv"> 1 </strong>和<strong class="jj hv"> 2 </strong>。指向<strong class="jj hv"> 1 </strong>不知从哪里冒出来的箭头表示<strong class="jj hv"> 1 </strong>是<em class="kf">初始状态</em>，<strong class="jj hv"> 2 </strong>上的内圈表示<strong class="jj hv"> 2 </strong>是该FSM的<em class="kf">接受状态</em>。</p><p id="98ad" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">从<strong class="jj hv"> 1 </strong>到<strong class="jj hv"> 2 </strong>，我们可以通过消耗角色<code class="eh lx ly lz ma b">a</code>产生字符串<em class="kf"> a </em>来跟随顶部过渡，或者通过消耗角色<code class="eh lx ly lz ma b">b</code>产生字符串<em class="kf"> b </em>来跟随底部过渡。<em class="kf"> a </em>和<em class="kf"> b </em>实际上是由正则表达式<em class="kf"> a | b </em>描述的两个可能的字符串。</p><p id="a9e9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">再比如。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff ml"><img src="../Images/a871a1e80704fb3fd8508ae645d60991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*LlY3MUCSMn2PxNHXl5-O2Q.png"/></div></figure><p id="1763" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在上述FSM从初始状态<strong class="jj hv"> 1 </strong>转换到接受状态<strong class="jj hv"> 6 </strong>后，只能产生一个字符串，<em class="kf">闪烁</em>。</p><h2 id="9e5d" class="lj kh hu bd ki lk ll lm km ln lo lp kq js lq lr ku jw ls lt ky ka lu lv lc lw dt translated">从正则表达式到有限状态机</h2><p id="839a" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">通过建立以下三个基本规则，我们可以将任何正则表达式转换成FSM。</p><p id="276f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">甲|乙</strong></p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff mk"><img src="../Images/f8a0f295131c594c49bfe0b82593d88f.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*6JdOpHQwcl4zW_v3X8Qz-Q.png"/></div></figure><p id="c003" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">正则表达式<em class="kf"> A | B </em>由具有两种状态的FSM表示。从状态<strong class="jj hv"> 1 </strong>开始，我们可以消费A并移动到接受状态<strong class="jj hv"> 2 </strong>或者消费B并移动到接受状态<strong class="jj hv"> 2 </strong>。</p><p id="35f4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv"> AB </strong></p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff mm"><img src="../Images/605ca7521dea3375c9df80a4e6aa65e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*hVuKYgG98iBAzY_rG_N9YA.png"/></div></figure><p id="f8bf" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">级联<em class="kf"> AB </em>由具有三个状态的FSM表示。从<strong class="jj hv"> 1 </strong>开始，我们首先通过消费A移动到<strong class="jj hv"> 2 </strong>，然后通过消费b移动到接受状态<strong class="jj hv"> 3 </strong>。</p><p id="0e83" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">答* </strong></p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff mn"><img src="../Images/847364302e43626fb7a955e03d7e19a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:166/format:webp/1*djhLOUEdQPVp7CrK3sNVuA.png"/></div></figure><p id="77bd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf">*</em>由一个FSM表示，其中只有一个状态既是初始状态又是接受状态，并转换到自身，形成一个循环。从<strong class="jj hv"> 1 </strong>开始，我们可以不去任何地方，因为<strong class="jj hv"> 1 </strong>也是接受状态，从而产生<em class="kf">空字符串</em>，或者我们可以通过消耗A来跟随转换，这将导致回到<strong class="jj hv">1</strong>；同样，我们可以不去任何地方，也可以跟随转变。这将生成字符串<code class="eh lx ly lz ma b">A</code>、<code class="eh lx ly lz ma b">AA</code>、<code class="eh lx ly lz ma b">AAA</code>、<code class="eh lx ly lz ma b">AA...AAA</code>和空字符串<em class="kf">。</em></p><p id="fec1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通过重用上述基本规则中的一个或任意组合，任何其他正则表达式都可以转换成一个<em class="kf"> FSM </em>。</p><p id="16ab" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们来看一些例子。</p><p id="3ee6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv"> R = (a|b)c </strong></p><p id="0ed3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf"> R </em>是<em class="kf"> a|b </em>后跟<em class="kf"> c </em>。首先，<em class="kf"> a|b </em>的FSM为</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff mk"><img src="../Images/cacb9d752904abf62858e6ea15e3c1a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*1iBERHUlaKDT7mJQN04Arg.png"/></div></figure><p id="4390" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后，到<em class="kf"> c </em>的连接由从状态<strong class="jj hv"> 2 </strong>到新的接受状态的转变来表示。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff mo"><img src="../Images/8ff5817f128a4ee507a16265b40d1128.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*cAI4F8dUCYj4sZCrIZ_plA.png"/></div></figure><p id="87de" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通过模拟该FSM可以产生的两个可能的字符串是<code class="eh lx ly lz ma b">ac</code>和<code class="eh lx ly lz ma b">bc</code>。</p><p id="60cc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv"> R = (a|b)*c </strong></p><p id="a8eb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">首先，<em class="kf"> (a|b)* </em>的FSM是一个循环，在每次迭代中有两个选项<em class="kf"> a </em>和<em class="kf"> b </em>。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/b80184535f93cf46b44471f73c5e11de.png" data-original-src="https://miro.medium.com/v2/resize:fit:158/format:webp/1*kmg214dY2A7cw9fS3Sfcvw.png"/></div></figure><p id="8101" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后我们添加一个新的过渡来连接<em class="kf"> c. </em></p><figure class="mb mc md me fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mq"><img src="../Images/18528a9db4757997300d9bf663b24b11.png" data-original-src="https://miro.medium.com/v2/resize:fit:382/format:webp/1*JsSSKCIqeebFvCtBl-Flvw.png"/></div></div></figure><p id="dc11" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">模拟或运行上述有限状态机可以产生<code class="eh lx ly lz ma b">c</code>、<code class="eh lx ly lz ma b">ac</code>、<code class="eh lx ly lz ma b">abc</code>、<code class="eh lx ly lz ma b">bac</code>、<code class="eh lx ly lz ma b">bc</code>、<code class="eh lx ly lz ma b">bbabaabbc</code>、<code class="eh lx ly lz ma b">aaaaac</code>或<code class="eh lx ly lz ma b">abbbaabbbaabbc</code>等字符串。</p><p id="3234" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv"> R = a(bc)* </strong></p><p id="b7fd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf"> a(bc)* </em>是字符<em class="kf"> a </em>后跟零个或多个重复的串联<em class="kf"> bc </em>。用于<em class="kf"> a </em>的FSM很简单。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/ee4d87151a43b55db747949ffff2a30f.png" data-original-src="https://miro.medium.com/v2/resize:fit:384/format:webp/1*sFH_jihFsclTRJFwtPJIXw.png"/></div></figure><p id="8c32" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf"> (bc)* </em>的FSM将由<em class="kf"> bc </em>上的循环表示。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mq"><img src="../Images/0b03a345ca41107bb2425b8092d08bd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:382/format:webp/1*DXddyOdqNU_cgPbjDEFjhw.png"/></div></div></figure><p id="32a9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">将上述两个FSM连接起来，我们将得到<em class="kf"> a(bc)* </em>的FSM。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/9d72671de298b0719bc5a0da57fb33e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/1*7Go-BFfZCL3-2BE-sqC-gQ.png"/></div></figure><p id="07bf" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">运行这个<em class="kf"> FSM </em>，我们必须消耗<code class="eh lx ly lz ma b">a</code>才能从状态<strong class="jj hv"> 1 </strong>移动到接受状态<strong class="jj hv"> 2 </strong>。在<strong class="jj hv"> 2 </strong>处，我们可以停止并让出字符串<code class="eh lx ly lz ma b">a</code>或消耗<code class="eh lx ly lz ma b">b</code>以移动到状态<strong class="jj hv"> 3 </strong>。从<strong class="jj hv"> 3 </strong>开始，我们别无选择，只能消耗<code class="eh lx ly lz ma b">c</code>回到接受状态<strong class="jj hv">2</strong>；再次在<strong class="jj hv"> 2 </strong>处，我们可以停止或者通过消耗<code class="eh lx ly lz ma b">b</code>进入<strong class="jj hv"> 3 </strong>，循环继续。该FSM可能产生的字符串有<code class="eh lx ly lz ma b">a</code>、<code class="eh lx ly lz ma b">abc</code>、<code class="eh lx ly lz ma b">abcbc</code>、<code class="eh lx ly lz ma b">abcbc</code>、<code class="eh lx ly lz ma b">abc...bc</code>。</p><p id="7cb4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">作为最后一个例子，让我们看看对应于一个规则定义的FSM，它可以描述编程语言中的标识符。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff mi"><img src="../Images/85629c620c473aa7ab1b294d541500ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*w3TBytWGtz2-Y2yWjvQmcQ.png"/></div></figure><p id="ce2d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">首先，<em class="kf">字母| _ </em>的FSM是一个基本的<em class="kf"> A | B </em> FSM。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff mt"><img src="../Images/08eb3c28ec334c3965c2c2b5a76866fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:466/format:webp/1*rwwYEl4vOE6pN7qFbTBtgQ.png"/></div></figure><p id="d8bb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">那么<em class="kf">(字母|数字| _)* </em>的FSM将是一个循环，每次迭代有3个不同的选项。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/31fbeabb64adeda271a857f1a22f65d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:294/format:webp/1*Lop8G5KerWEFC6CI5efouQ.png"/></div></figure><p id="249a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们通过连接上面的2个<em class="kf">FSM</em>得到了<em class="kf">标识符</em>的最终FSM。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff mv"><img src="../Images/b67c3773c55ca55dc879065bc9dfbfa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*BR6J3KvNneBjLQQzjV8SdA.png"/></div></figure><h2 id="187d" class="lj kh hu bd ki lk ll lm km ln lo lp kq js lq lr ku jw ls lt ky ka lu lv lc lw dt translated">代码中的有限状态机</h2><p id="236d" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">FSM是以下各项的组合</p><ul class=""><li id="6007" class="mw mx hu jj b jk jl jo jp js my jw mz ka na ke nb nc nd ne dt translated">FSM可以处于的所有可能状态的集合</li><li id="7341" class="mw mx hu jj b jk nf jo ng js nh jw ni ka nj ke nb nc nd ne dt translated">FSM所处的<strong class="jj hv">初始状态</strong></li><li id="c040" class="mw mx hu jj b jk nf jo ng js nh jw ni ka nj ke nb nc nd ne dt translated">一组<strong class="jj hv">接受状态</strong></li><li id="017a" class="mw mx hu jj b jk nf jo ng js nh jw ni ka nj ke nb nc nd ne dt translated">以及所有<strong class="jj hv">转换的集合</strong>。</li></ul><p id="3248" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以从将FSM实现为一个类开始，该类具有状态、初始状态和接受状态的属性。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="5ed4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">FSM的转换可以用一个函数来建模，该函数在参数中取一个状态<code class="eh lx ly lz ma b">currentState</code>和一个字符或符号<code class="eh lx ly lz ma b">input</code>，并返回FSM在状态<code class="eh lx ly lz ma b">currentState</code>中消耗<code class="eh lx ly lz ma b">input</code>之后将处于的状态。我们可以将该函数称为<strong class="jj hv">转换函数</strong>，并将其命名为<code class="eh lx ly lz ma b">nextState()</code>。</p><p id="c6c0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最常见的情况是，转换函数是参数<code class="eh lx ly lz ma b">currentState</code>上的switch语句，每种情况都根据参数<code class="eh lx ly lz ma b">input</code>返回下一个状态。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Skeleton for a transition function</figcaption></figure><p id="19a7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了帮助实现转换功能，可以首先将FSM转换成<a class="ae jg" href="https://en.wikipedia.org/wiki/State_transition_table" rel="noopener ugc nofollow" target="_blank">转换表</a>。转换表将每个状态S和输入I映射到状态S’，其中S’是当输入I从状态S消耗时FSM将处于的状态</p><p id="e550" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">作为一个例子，让我们考虑下面的FSM。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff mo"><img src="../Images/8ff5817f128a4ee507a16265b40d1128.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*cAI4F8dUCYj4sZCrIZ_plA.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">(a|b)c</figcaption></figure><p id="8e52" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">相应的转换表是</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff nk"><img src="../Images/341f93866e43dac67ecf33ea0a7007a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*O2Z96vPtOrCrD4DxkD50DA.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Transition table for (a|b)c</figcaption></figure><p id="05b8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">转换表的行标有FSM的状态，列标有可能被消耗的所有字符或元素。如果相应列的字符被消耗，而FSM处于相应行的状态，则表格的每个单元包含FSM将处于的状态。包含<code class="eh lx ly lz ma b">—</code>的单元意味着对应的状态和字符在FSM中没有转换。</p><p id="5bf5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">编写转换函数时，转换表提供了一个快速的可视化参考。上述FSM的转换函数为:</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="9cf3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，为了完成我们的FSM类的构造函数，让我们给它添加一个类型为<code class="eh lx ly lz ma b">Function</code>的参数<code class="eh lx ly lz ma b">nextState</code>，表示转换函数。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="55d6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">实现我们的FSM的下一步是添加一个函数，允许<strong class="jj hv">运行</strong>、<strong class="jj hv">模拟</strong>或<strong class="jj hv">对输入字符串执行</strong>FSM。该函数将返回一个布尔值，指定输入字符串(或输入字符串的子集)是否与对应于FSM的正则表达式相匹配。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="ba94" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh lx ly lz ma b">run</code>功能的实现非常简单。该函数将逐字符读取输入，同时跟踪FSM的当前状态。对于每个读取的字符，它通过调用转换函数<code class="eh lx ly lz ma b">nextState()</code>，用FSM将处于的下一个状态更新当前状态。在循环执行结束时，如果当前状态是FSM的接受状态之一，则输入字符串(或输入字符串的子集)匹配对应于FSM的正则表达式。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><h2 id="4670" class="lj kh hu bd ki lk ll lm km ln lo lp kq js lq lr ku jw ls lt ky ka lu lv lc lw dt translated">有限状态机的使用</h2><p id="bf2d" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">为了结束关于FSM的这一部分，让我们看看如何使用我们新实现的<code class="eh lx ly lz ma b">FSM</code>类来识别标识符。</p><p id="3ce2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们重复使用下面的常规定义。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff mi"><img src="../Images/85629c620c473aa7ab1b294d541500ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*w3TBytWGtz2-Y2yWjvQmcQ.png"/></div></figure><p id="bb3b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">下面是对应的FSM。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff mv"><img src="../Images/b67c3773c55ca55dc879065bc9dfbfa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*BR6J3KvNneBjLQQzjV8SdA.png"/></div></figure><p id="cd2e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">和相应的转换表。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff nk"><img src="../Images/45a397326493c1b1c2ffad6c8ab25131.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*qryj_Jl2vNph8yrYUYRJeA.png"/></div></figure><p id="8001" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们可以创建我们的<code class="eh lx ly lz ma b">FSM</code>类的一个新实例，并配置它来识别标识符。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="49ab" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后，我们的<code class="eh lx ly lz ma b">FSM</code>实例可以用来识别标识符。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="27da" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">注意，调用<code class="eh lx ly lz ma b">fsm.<strong class="jj hv">run</strong>("lisp-case-identifier")</code>将返回<code class="eh lx ly lz ma b">true</code>，即使<code class="eh lx ly lz ma b">lisp-case-identifier</code>不是有效的标识符，因为<code class="eh lx ly lz ma b">—</code>不在正则表达式中。它返回<code class="eh lx ly lz ma b">true</code>，因为<code class="eh lx ly lz ma b">lisp-case-identifier</code>中的子集<code class="eh lx ly lz ma b">lisp</code>是有效的闪烁标识符。在本文的最后一部分，当使用您自己的lexer时，您必须更新我们的<code class="eh lx ly lz ma b">FSM</code>实现，以便<code class="eh lx ly lz ma b">run</code>方法除了返回一个布尔值之外，还返回匹配正则表达式的输入子集。</p><h1 id="7480" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">把所有的放在一起</h1><p id="aba8" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">配备所有必要的工具(词汇语法、正则表达式、有限状态机、转换表等)。)，我们现在可以看看它们是如何在lexer的实现中结合在一起的。</p><p id="11ef" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们考虑一种执行数学运算的简单语言。该语言支持四种基本算术运算符(+、-、*和/)、比较运算符(&gt;、≥、</p><p id="14dc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Below are examples of valid instructions in our mini language.</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="1c0a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">The valid lexemes for this language, <strong class="jj hv">标识符</strong>、<strong class="jj hv">数字</strong>、<strong class="jj hv">括号</strong>和<strong class="jj hv">运算符</strong>用以下常规定义描述。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff nl"><img src="../Images/c4c1777e473f7b49054db05d63d25207.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*sxQo5Wffb1Cvzy1nQEZZPw.png"/></div></figure><p id="7a28" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们通过完成我们在文章开头介绍的 <code class="eh lx ly lz ma b"><a class="ae jg" href="#d21e" rel="noopener ugc nofollow">Lexer</a></code> <a class="ae jg" href="#d21e" rel="noopener ugc nofollow">类</a>的<a class="ae jg" href="#d21e" rel="noopener ugc nofollow">骨架来为这种语言构建一个lexer。</a></p><h2 id="a760" class="lj kh hu bd ki lk ll lm km ln lo lp kq js lq lr ku jw ls lt ky ka lu lv lc lw dt translated">令牌类型</h2><p id="1d57" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">实现词法分析器的第一步是为每个有效的词法分析器添加一个标记类型。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="fc4f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因为运算符和括号的数量有限，所以我们将通过为每种类型的运算符和括号添加一个特定的标记来提高清晰度和粒度。添加一个特殊的令牌<code class="eh lx ly lz ma b">EndOfInput</code>也很有帮助，当输入中的所有字符都被读取后，将返回这个令牌。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="1490" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">下一步是完成<code class="eh lx ly lz ma b">Lexer</code>类的实现。</p><h2 id="de61" class="lj kh hu bd ki lk ll lm km ln lo lp kq js lq lr ku jw ls lt ky ka lu lv lc lw dt translated">Lexer类</h2><p id="2057" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">让我们从向<code class="eh lx ly lz ma b">Lexer</code>类添加属性开始，以跟踪输入中的当前位置，只要当前行和列。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="f5e0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，让我们实现<code class="eh lx ly lz ma b">nextToken()</code>方法。</p><p id="4662" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以对<code class="eh lx ly lz ma b">nextToken()</code>使用的策略是读取当前位置的字符。如果字符与一个词位的产生式规则中的起始字符相匹配，我们就将词位的识别委托给对应于该产生式规则的helper方法。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="19f7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们从最简单到最复杂来看看帮助器方法。</p><p id="39f4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">识别括号</strong></p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff nm"><img src="../Images/ff78755c2d4f435886c4d02229eac7aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:374/format:webp/1*fSIB4iciUnTKcixxi-TE9Q.png"/></div></figure><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="5c9d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">识别括号很简单。我们只需检查当前角色是<code class="eh lx ly lz ma b">(</code>还是<code class="eh lx ly lz ma b">)</code>并返回适当的令牌。我们还增加输入中的当前位置，以及当前列。</p><p id="7f68" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">识别操作员</strong></p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff nn"><img src="../Images/a301b414b3aa1634904e2f11ae7d3540.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*sLMtkZ6baDtkDzP8sZY-cg.png"/></div></figure><p id="e777" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在对<code class="eh lx ly lz ma b">operator</code>词位的定义中，我们可以注意到我们基本上有两种类型的操作符，<em class="kf">算术</em>和<em class="kf">比较</em>操作符(技术上我们有第三种，赋值操作符<code class="eh lx ly lz ma b">=</code>，但是为了简化实现，我们将它添加到这里的比较操作符组中)。</p><p id="7449" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了可读性，我们可以将每种类型的操作符的识别委托给一个特定的助手函数。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="5626" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">前瞻</strong>。<code class="eh lx ly lz ma b">recognizeComparisonOperator()</code>的实现使用了一个名为<code class="eh lx ly lz ma b">lookahead</code>的变量。因为一个操作符可以是<code class="eh lx ly lz ma b">&gt;</code>或<code class="eh lx ly lz ma b">&gt;=</code>，一旦我们阅读了字符<code class="eh lx ly lz ma b">&gt;</code>，我们需要知道下一个字符是什么，然后才能决定我们使用哪种操作符。如果下一个字符是<code class="eh lx ly lz ma b">=</code>，则识别的操作符是<code class="eh lx ly lz ma b">&gt;=</code>；如果下一个字符是任何其他字符，识别的操作符是<code class="eh lx ly lz ma b">&gt;</code>。这就是<code class="eh lx ly lz ma b">lookahead</code>变量的目的，在输入中进行实际的预测。</p><p id="e908" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">识别标识符</strong></p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff nl"><img src="../Images/33d9f9a70ddeb8271234406bb0a11a01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*70boa1UxIbnvGA6CAG7few.png"/></div></figure><p id="f122" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以为此构建一个FSM，并用它来识别标识符，但是这些规则非常简单，可以用一个循环来实现。我们只需不断读取输入中的字符，直到我们遇到一个不是字母、数字或下划线的字符。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="5320" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">识别数字</strong></p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff nl"><img src="../Images/bf07252a8ee9085496d3bddac94e2079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*lOHQKO0w84XGHaa_rF9ZYw.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Note: With these regular definitions, strings such as 00, 00.42 or 00e-00 are considered numbers.</figcaption></figure><p id="1edc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">根据上面的常规定义，一个数是一个或多个数字的连续。数字后面可以跟一个小数部分(由<code class="eh lx ly lz ma b">fraction</code>产生规则描述)或一个指数部分(由<code class="eh lx ly lz ma b">exponent</code>产生规则描述)，或者两者都跟。分数和指数部分都是可选的，如正则表达式中的<em class="kf"> | ε </em>所示。</p><p id="456a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有效数字的例子有<code class="eh lx ly lz ma b">42</code>、<code class="eh lx ly lz ma b">3.14</code>或<code class="eh lx ly lz ma b">6.6262e-34</code>。描述数字的正则表达式非常复杂，足以阻止我们像对待标识符一样尝试手动识别数字。FSM将大大简化这里的实现。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff no"><img src="../Images/1cacf77a1283babfdee947d6ebb17cea.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*eMrDXaZBz3RF60Cton6hzA.png"/></div></figure><p id="c7a8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一个数的正则表达式可以转换成上面的有限状态机，下面是相应的转换表。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff np"><img src="../Images/fe1b8b0448d813d909b854c25e5d7232.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*xLFZCxvKV9oJZzCWHhmXow.png"/></div></figure><p id="2ace" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有了转换表，我们可以构建一个<em class="kf"> FSM </em>并在我们的<code class="eh lx ly lz ma b">recognizeNumber()</code>方法中使用它。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="b57e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">随着<code class="eh lx ly lz ma b">recognizeNumber()</code>的完成，我们用来执行数学运算的小语种lexer也差不多完成了。</p><p id="38e3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了使我们的lexer完全完整，我们需要更新我们的<code class="eh lx ly lz ma b">nextToken()</code>方法来忽略空白(例如，<code class="eh lx ly lz ma b">1+2</code>、<code class="eh lx ly lz ma b">1 + 2</code>或<code class="eh lx ly lz ma b">1+ 2</code>)并处理错误。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Lexer class with complete nextToken() method</figcaption></figure><p id="4610" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这就完成了我们的<code class="eh lx ly lz ma b">Lexer</code>实现。通过重复调用<code class="eh lx ly lz ma b">nextToken()</code>直到返回一个<code class="eh lx ly lz ma b">EndOfInput</code>标记，我们可以很容易地得到一个输入中的所有标记。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure></div><div class="ab cl nq nr hc ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="hn ho hp hq hr"><h1 id="b2ed" class="kg kh hu bd ki kj nx kl km kn ny kp kq kr nz kt ku kv oa kx ky kz ob lb lc ld dt translated">测试你的力量！</h1><p id="6e0d" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">祝贺你在文章中走到这一步。如果你准备好了，是时候通过为Blink编写一个lexer来完成你的第一个挑战了。</p><p id="ea67" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">点击<a class="ae jg" href="https://github.com/ftchirou/blink-lexer" rel="noopener ugc nofollow" target="_blank">此链接</a>了解如何获得挑战以及如何完成挑战的说明。</p><p id="e5e2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你在阅读这篇文章或完成挑战时有任何问题、建议或需要澄清(或只是打个招呼)，请随时在Twitter上给我发短信。:)</p><p id="e2ef" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">感谢阅读。</p></div><div class="ab cl nq nr hc ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="hn ho hp hq hr"><h1 id="1b6b" class="kg kh hu bd ki kj nx kl km kn ny kp kq kr nz kt ku kv oa kx ky kz ob lb lc ld dt translated">正则表达式</h1><p id="8e02" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated"><em class="kf">这是一个正则表达式的快速介绍，介绍了掌握本文中</em> <a class="ae jg" href="#82e1" rel="noopener ugc nofollow"> <em class="kf">这里</em> </a> <em class="kf">讨论的词汇语法所必需的概念。</em></p><p id="3337" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一个<strong class="jj hv">正则表达式</strong>，简单来说就是描述所有可以由一组基本字符/符号构建的字符串的规则。</p><p id="05dc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最简单的正则表达式就是所描述的字符串。比如设<em class="kf"> R </em>为正则表达式<em class="kf"> lang </em>，<em class="kf"> R = lang </em>。<em class="kf"> R </em>描述第一个字符是<code class="eh lx ly lz ma b">l</code>，后面是<code class="eh lx ly lz ma b">a</code>，后面是<code class="eh lx ly lz ma b">n</code>，再后面是<code class="eh lx ly lz ma b">g</code>的字符串。只有一根这样的弦，那根弦就是<strong class="jj hv">郎</strong>。</p><p id="e358" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了描述更复杂的字符串，我们使用了<strong class="jj hv">正则表达式操作符</strong>。</p><h2 id="3140" class="lj kh hu bd ki lk ll lm km ln lo lp kq js lq lr ku jw ls lt ky ka lu lv lc lw dt translated">经营者</h2><p id="fe2e" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated"><strong class="jj hv">工会</strong>。<code class="eh lx ly lz ma b">|</code>操作符用于指定联合或替代。比如对于<em class="kf"> R = a | b </em>，<code class="eh lx ly lz ma b">a</code>是<em class="kf"> R </em>描述的有效字符串，<code class="eh lx ly lz ma b">b</code>也是。<code class="eh lx ly lz ma b">|</code>可称为<em class="kf">或</em>操作员。</p><p id="aea0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">串联</strong>。当字符/符号之间缺少运算符时，意味着串联。例如<em class="kf"> R = ab </em>描述了唯一字符串<code class="eh lx ly lz ma b">ab</code>。</p><p id="00ed" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">零次或多次出现</strong>。后缀*用于指定它所应用的元素可以重复<em class="kf">零次或多次</em>。比如<em class="kf"> R = a* </em>描述的是<code class="eh lx ly lz ma b">a</code>、<code class="eh lx ly lz ma b">aa</code>、<code class="eh lx ly lz ma b">aaa</code>、<code class="eh lx ly lz ma b">aaaa</code>、<code class="eh lx ly lz ma b">aaaaa...</code>、<em class="kf">等字符串和空字符串</em>。<strong class="jj hv"> * </strong>更正式的名称是<em class="kf">克莱尼闭包</em>，以帮助形式化正则表达式概念的<a class="ae jg" href="https://en.wikipedia.org/wiki/Stephen_Cole_Kleene" rel="noopener ugc nofollow" target="_blank">斯蒂芬·科尔·克莱尼</a>命名。</p><p id="a89d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">分组</strong>。就像数学表达式一样，括号<code class="eh lx ly lz ma b">()</code>用于分组。比如<em class="kf"> R = (a|b)*c </em>串联<em class="kf"> (a|b)* </em>到<em class="kf"> c </em>，描述<code class="eh lx ly lz ma b">c</code>、<code class="eh lx ly lz ma b">ac</code>、<code class="eh lx ly lz ma b">aac</code>、<code class="eh lx ly lz ma b">bc</code>、<code class="eh lx ly lz ma b">bbc</code>、<code class="eh lx ly lz ma b">abbc</code>、<code class="eh lx ly lz ma b">abbbabababc</code>等字符串。</p><p id="e485" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">人物类别</strong>。字符类可以用来缩短长的<em class="kf">或</em>正则表达式。比如正则表达式<em class="kf"> a | b | c | d </em>可以用字符类<em class="kf">【ABCD】</em>代替。如果一个字符类中的所有字符形成一个逻辑序列，该字符类可以使用范围符号<em class="kf">【–aⁿ】</em>进一步缩写，其中<em class="kf"> a </em>是该序列的第一个元素，<em class="kf"> aⁿ </em>是最后一个元素。例如<em class="kf"> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 </em>可以转换为字符类<em class="kf">【0123456789】</em>，可以进一步缩写为<em class="kf">【0–9】</em>。</p><p id="221a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">空弦</strong>。空字符串由<em class="kf">ε</em>(ε)描述。比如<em class="kf"> R = a | ε </em>描述字符串<code class="eh lx ly lz ma b">a</code>或者<em class="kf">空字符串</em>。</p><h2 id="2f23" class="lj kh hu bd ki lk ll lm km ln lo lp kq js lq lr ku jw ls lt ky ka lu lv lc lw dt translated">运算符优先级</h2><p id="1cd4" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">克莱尼闭包(*)的优先级最高，其次是串联运算符。union运算符(|)的优先级最低。</p><p id="72c9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">例如，在正则表达式<em class="kf"> ab*|c </em>中，首先对<em class="kf"> b* </em>求值，然后是<em class="kf"> ab* </em>，最后是用括号重写的<em class="kf"> c. </em>的并集，该正则表达式将等效于<em class="kf">((a(b *)| c)</em>。</p><p id="ec52" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于本文来说，这就是我们需要知道的关于正则表达式的全部内容。现在回到 <a class="ae jg" href="#82e1" rel="noopener ugc nofollow"> <em class="kf">词汇语法</em> </a> <em class="kf">。</em></p><p id="4100" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你已经到达终点了。🎉</p></div></div>    
</body>
</html>