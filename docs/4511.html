<html>
<head>
<title>Flexible Data with Aeson</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Aeson提供灵活的数据</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/flexible-data-with-aeson-d8a23ba2169e?source=collection_archive---------24-----------------------#2017-06-05">https://medium.com/hackernoon/flexible-data-with-aeson-d8a23ba2169e?source=collection_archive---------24-----------------------#2017-06-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="abd6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在某种程度上，我们的Haskell程序必须与网络上运行的其他程序兼容。考虑到微服务作为一种架构的使用越来越多，这一点尤其有用。不管怎样，在不同堆栈上的应用程序之间传输数据是很常见的。你需要某种格式来传输数据并在两端读取。</p><p id="3ec5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">做这件事有许多不同的方法。但是当前web编程的生态系统很大程度上依赖于JSON格式。JSON代表“JavaScript对象符号”。这是一种与Javascript程序兼容的数据编码方式。但它也是一个任何语言都可以解析的有用的序列化系统。在本文中，我们将探索如何在Haskell中使用这种数据格式。</p><h1 id="a2bc" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">JSON 101</h1><p id="2568" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">JSON将数据编码成几种不同的类型。有四种基本类型:字符串、数字、布尔值和空值。这些都以可预测的方式发挥作用。这里的每一行都是有效的JSON值。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="5e66" class="lb jq hu kx b fv lc ld l le lf">“Hello”</span><span id="cd80" class="lb jq hu kx b fv lg ld l le lf">4.5</span><span id="c280" class="lb jq hu kx b fv lg ld l le lf">3</span><span id="a23f" class="lb jq hu kx b fv lg ld l le lf">true</span><span id="5c4e" class="lb jq hu kx b fv lg ld l le lf">false</span><span id="5e03" class="lb jq hu kx b fv lg ld l le lf">null</span></pre><p id="9f90" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">JSON随后提供了两种不同的组合对象的方式。第一个是数组。数组包含多个值，并用括号分隔的列表来表示它们。与Haskell列表不同，您可以将多种类型的对象放在一个数组中。你甚至可以把数组放入你的数组中。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="08df" class="lb jq hu kx b fv lc ld l le lf">[1, 2, 3]</span><span id="caa4" class="lb jq hu kx b fv lg ld l le lf">[“Hello”, false, 5.5]</span><span id="fca5" class="lb jq hu kx b fv lg ld l le lf">[[1,2], [3,4]]</span></pre><p id="f58c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从Haskell来看，这种结构似乎有点粗略。毕竟，数组中的东西的类型并不清楚。但是你可以把多类型数组看作元组，而不是列表，这样更有意义。在JSON中创建对象的最后也是最重要的方法是通过对象格式。对象由大括号分隔。它们就像数组一样，可以包含任意数量的值。但是，每个值也作为键-值对分配给一个字符串名称。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="5768" class="lb jq hu kx b fv lc ld l le lf">{<br/>  “Name” : “Name”,<br/>  “Age” : 23,<br/>  “Grades” : [“A”, “B”, “C”]<br/>}</span></pre><p id="b6d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些对象是无限可嵌套的，所以你可以拥有数组的对象的数组等等。</p><h1 id="a1e3" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">编码Haskell类型</h1><p id="ba81" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">这很好，但是我们如何使用这种格式来传输Haskell数据呢？我们从一个虚拟的例子开始。我们将创建一个Haskell数据类型，并展示该数据的几种可能的JSON解释。首先，我们的类型和一些示例值:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="5b61" class="lb jq hu kx b fv lc ld l le lf">data Person = Person<br/>  { name :: String<br/>  , age :: Int<br/>  , occupation :: Occupation <br/>  } deriving (Show)</span><span id="a113" class="lb jq hu kx b fv lg ld l le lf">data Occupation = Occupation<br/>  { title :: String<br/>  , tenure :: Int<br/>  , salary :: Int <br/>  } deriving (Show)</span><span id="250a" class="lb jq hu kx b fv lg ld l le lf">person1 :: Person<br/>person1 = Person<br/>  { name = “John Doe”<br/>  , age = 26<br/>  , occupation = Occupation<br/>    { title = “teacher”<br/>    , tenure = 5<br/>    , salary = 60000<br/>    }<br/>  }</span><span id="4ff4" class="lb jq hu kx b fv lg ld l le lf">person2 :: Person<br/>person2 = Person<br/>  { name = “Jane Doe”<br/>  , age = 25<br/>  , occupation = Occupation<br/>    { title = “engineer”<br/>    , tenure = 4<br/>    , salary = 90000<br/>    }<br/>  }</span></pre><p id="8d13" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们可以选择许多不同的方式来编码这些值。最基本的方法可能是这样的:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="3a27" class="lb jq hu kx b fv lc ld l le lf">{<br/>  “name” : “John Doe”,<br/>  “age” : 26,<br/>  “occupation” : {<br/>    “title” : “teacher”,<br/>    “tenure” : 5,<br/>    “salary” : 60000<br/>    }<br/>}</span><span id="0009" class="lb jq hu kx b fv lg ld l le lf">{<br/>  “name” : “Jane Doe”,<br/>  “age” : 25,<br/>  “occupation” : {<br/>    “title” : “engineer”,<br/>    “tenure” : 4,<br/>    “salary” : 90000<br/>  }<br/>}</span></pre><p id="13d5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们可能希望使用动态类型语言来帮助我们的朋友。为此，我们可以围绕对象中包含的类型提供更多的上下文。这种格式可能看起来更像这样:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="7ec5" class="lb jq hu kx b fv lc ld l le lf">{<br/>  “type” : “person”,<br/>  “contents” : {<br/>    “name” : “John Doe”,<br/>    “age” : 26,<br/>    “occupation” = {<br/>        “type” : “Occupation”,<br/>        “contents” : {<br/>        “title” : “teacher”,<br/>        “tenure” : 5,<br/>        “salary” : 60000<br/>        }<br/>      }<br/>  }<br/>}</span></pre><p id="6f6c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">无论哪种方式，我们最终都必须决定与谁进行互操作的格式。不过，很可能您将与一个已经设定了他们期望的外部API一起工作。你必须确保你匹配他们。</p><h1 id="d086" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">数据。艾松</h1><p id="be09" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">现在我们知道了我们的目标值是什么，我们需要一个Haskell表示。这来自于<a class="ae lh" href="https://hackage.haskell.org/package/aeson" rel="noopener ugc nofollow" target="_blank">数据。Aeson </a>图书馆(以神话人物“杰森”的父亲命名)。该库包含类型<code class="eh li lj lk kx b">Value</code>。它在其构造函数中封装了所有基本的JSON类型。(为了清楚起见，我替换了几个同义词):</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="353a" class="lb jq hu kx b fv lc ld l le lf">data Value =<br/>  Object (HashMap Text Value) |<br/>  Array (Vector Value) |<br/>  String Text |<br/>  Number Scientific |<br/>  Bool Bool |<br/>  Null</span></pre><p id="e2fa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以我们看到所有六种元素都被表现出来了。所以当我们想要表示我们的项目时，我们将使用这些构造函数。像许多有用的Haskell思想一样，我们将在这里使用typeclasses来提供一些结构。我们将使用两个类型类:<code class="eh li lj lk kx b">ToJSON</code>和<code class="eh li lj lk kx b">FromJSON</code>。我们将首先把Haskell类型转换成JSON。我们必须在我们的类型上定义<code class="eh li lj lk kx b">toJSON</code>函数，这将把它变成一个<code class="eh li lj lk kx b">Value</code>。</p><p id="d943" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一般来说，我们希望将我们的数据类型放入一个对象中，这个对象将有一系列的“对”。A <code class="eh li lj lk kx b">Pair</code>是数据。键-值对的Aeson表示，它由一个<code class="eh li lj lk kx b">Text</code>和另一个值组成。然后我们将使用<code class="eh li lj lk kx b">object</code>函数将这些对组合成一个JSON <code class="eh li lj lk kx b">Object</code>。我们将从<code class="eh li lj lk kx b">Occupation</code>类型开始，因为这稍微简单一些。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="3593" class="lb jq hu kx b fv lc ld l le lf">{-# LANGUAGE OverloadedString #-}</span><span id="4dc4" class="lb jq hu kx b fv lg ld l le lf">import Data.Aeson (ToJSON(..), Value(..), object, (.=))</span><span id="8016" class="lb jq hu kx b fv lg ld l le lf">...</span><span id="4961" class="lb jq hu kx b fv lg ld l le lf">instance ToJSON Occupation where<br/>  toJSON :: Occupation -&gt; Value<br/>  toJSON occupation = object<br/>    [ “title” .= toJSON (title occupation)<br/>    , “tenure” .= toJSON (tenure occupation)<br/>    , “salary” .= toJSON (salary occupation)<br/>    ]</span></pre><p id="aba3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh li lj lk kx b">.=</code>操作符为我们创建了一个<code class="eh li lj lk kx b">Pair</code>。我们所有的字段都是简单类型，它们已经有了自己的<code class="eh li lj lk kx b">ToJSON</code>实例。这意味着我们可以对它们使用<code class="eh li lj lk kx b">toJSON</code>而不是<code class="eh li lj lk kx b">Value</code>构造函数。还要注意，我们使用重载字符串扩展(如这里介绍的<a class="ae lh" href="https://mmhaskell.com/blog/2017/5/15/untangling-haskells-strings" rel="noopener ugc nofollow" target="_blank"/>)，因为我们使用字符串文字代替<code class="eh li lj lk kx b">Text</code>对象。一旦我们为<code class="eh li lj lk kx b">Occupation</code>类型定义了实例，我们就可以在occupation对象上调用<code class="eh li lj lk kx b">toJSON</code>。这使得为<code class="eh li lj lk kx b">Person</code>类型定义一个实例变得容易。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="a0cc" class="lb jq hu kx b fv lc ld l le lf">instance ToJSON Person where<br/>  toJSON person = object<br/>    [ “name” .= toJSON (name person)<br/>    , “age” .= toJSON (age person)<br/>    , “occupation” .= toJSON (occupation person)<br/>    ]</span></pre><p id="d042" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们可以从我们的数据类型创建JSON值了！一般来说，我们还希望能够解析JSON值，并将它们转换成我们的数据类型。我们将使用一元符号来封装失败的可能性。如果我们要寻找的键没有出现，我们想要抛出一个错误:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="2132" class="lb jq hu kx b fv lc ld l le lf">import Data.Aeson (ToJSON(..), Value(..), object, (.=), (.:), FromJSON(..), withObject)</span><span id="cc63" class="lb jq hu kx b fv lg ld l le lf">...</span><span id="ae1d" class="lb jq hu kx b fv lg ld l le lf">instance FromJSON Occupation where<br/>  parseJSON = withObject “Occupation” $ \o -&gt; do<br/>    title_ &lt;- o .: “title”<br/>    tenure_ &lt;- o .: “tenure”<br/>    salary_ &lt;- o .: “salary”<br/>    return $ Occupation title_ tenure_ salary_</span><span id="2e8f" class="lb jq hu kx b fv lg ld l le lf">instance FromJSON Person where<br/>  parseJSON = withObject “Person” $ \o -&gt; do<br/>    name_ &lt;- o .: “name”<br/>    age_ &lt;- o .: “age”<br/>    occupation_ &lt;- o .: “occupation”<br/>    return $ Person name_ age_ occupation_</span></pre><p id="05a8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里有一些注释。<code class="eh li lj lk kx b">parseJSON</code>函数通过eta缩减来定义。这就是为什么似乎没有参数。<code class="eh li lj lk kx b">.:</code>操作符可以抓取任何符合<code class="eh li lj lk kx b">FromJSON</code>本身的数据类型。正如我们可以将<code class="eh li lj lk kx b">toJSON</code>与简单类型<code class="eh li lj lk kx b">String</code>和<code class="eh li lj lk kx b">Int</code>一起使用一样，我们也可以开箱即用地解析它们。另外，我们描述了如何解析一个<code class="eh li lj lk kx b">Occupation</code>，这就是为什么我们可以在occupation字段上使用操作符。此外，<code class="eh li lj lk kx b">withObject</code>函数的第一个参数是一条错误消息，如果解析失败，我们会收到这条消息。最后一点需要注意的是，我们的<code class="eh li lj lk kx b">FromJSON</code>和<code class="eh li lj lk kx b">ToJSON</code>实例是彼此相反的。这绝对是您在自己的API定义中实施的一个好属性。</p><p id="fbd2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们有了这些实例，我们可以看到不同对象的JSON字节串:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="2fc2" class="lb jq hu kx b fv lc ld l le lf">&gt;&gt; Data.Aeson.encode person1<br/>"{\"age\":26,\"name\":\"John Doe\",\"occupation\":{\"salary\":60000,\"tenure\":5,\"title\":\"teacher\"}}"<br/>&gt;&gt; Data.Aeson.encode person2<br/>"{\"age\":25,\"name\":\"Jane Doe\",\"occupation\":{\"salary\":90000,\"tenure\":4,\"title\":\"engineer\"}}"</span></pre><h1 id="4b9e" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">派生实例</h1><p id="795b" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">您可能会看到我们派生的实例，并认为代码看起来像样板文件。事实上，这些并不是特别有趣的实例。请记住，外部API可能有一些奇怪的需求。所以知道如何手工创建这些实例是很好的。不管怎样，你可能想知道是否有可能用我们可以派生<code class="eh li lj lk kx b">Eq</code>或<code class="eh li lj lk kx b">Ord</code>的相同方式来派生这些实例。我们可以，但是有点复杂。实际上有两种方法可以做到这一点，它们都涉及编译器扩展。第一种方式看起来更像是衍生路线。我们将最终把<code class="eh li lj lk kx b">deriving (ToJSON, FromJSON)</code>放入我们的类型中。但是在我们这样做之前，我们必须让它们派生出<code class="eh li lj lk kx b">Generic</code> typeclass。</p><p id="a8dd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh li lj lk kx b">Generic</code>是一个类，它允许GHC在通用构造函数的层次上表示你的类型。要使用它，首先需要打开<code class="eh li lj lk kx b">DeriveGeneric</code>的编译器扩展。这允许您为数据派生泛型类型类。然后你也需要打开<code class="eh li lj lk kx b">DeriveAnyClass</code>扩展。一旦你完成了这些，你就可以为你的类型派生出<code class="eh li lj lk kx b">Generic</code>、<code class="eh li lj lk kx b">ToJSON</code>和<code class="eh li lj lk kx b">FromJSON</code>实例。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="256b" class="lb jq hu kx b fv lc ld l le lf">{-# LANGUAGE DeriveGeneric     #-}<br/>{-# LANGUAGE DeriveAnyClass    #-}</span><span id="bbb6" class="lb jq hu kx b fv lg ld l le lf">…</span><span id="8234" class="lb jq hu kx b fv lg ld l le lf">data Person = Person<br/>  { name :: String<br/>  , age :: Int<br/>  , occupation :: Occupation<br/>  } deriving (Show, Generic, ToJSON, FromJSON)</span><span id="8dc7" class="lb jq hu kx b fv lg ld l le lf">data Occupation = Occupation<br/>  { title :: String<br/>  , tenure :: Int<br/>  , salary :: Int<br/>  } deriving (Show, Generic, ToJSON, FromJSON)</span></pre><p id="4a0a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有了这些定义，我们将获得与手动实例相同的编码输出:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="5bcf" class="lb jq hu kx b fv lc ld l le lf">&gt;&gt; Data.Aeson.encode person1<br/>"{\"age\":26,\"name\":\"John Doe\",\"occupation\":{\"salary\":60000,\"tenure\":5,\"title\":\"teacher\"}}"<br/>&gt;&gt; Data.Aeson.encode person2<br/>"{\"age\":25,\"name\":\"Jane Doe\",\"occupation\":{\"salary\":90000,\"tenure\":4,\"title\":\"engineer\"}}"</span></pre><p id="c3af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如你所看到的，这是一个超级酷的想法，它在Haskell生态系统中有着广泛的用途。有许多有用的类型类具有与<code class="eh li lj lk kx b">ToJSON</code>和<code class="eh li lj lk kx b">FromJSON</code>相似的模式。您需要实例来满足库约束。但是你要写的实例是非常样板化的。你可以通过结合使用泛型类型类和<code class="eh li lj lk kx b">DeriveAnyClass</code>得到很多这样的实例。</p><p id="1457" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第二条路线涉及编写模板Haskell。模板Haskell是另一个编译器扩展，允许GHC为你生成代码。有许多库有特定的模板Haskell函数。这些可以让你避免大量的样板代码，否则会非常乏味。<code class="eh li lj lk kx b">Data.Aeson</code>就是这些库中的一个。</p><p id="e0d4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，您需要启用模板Haskell扩展。然后导入<code class="eh li lj lk kx b">Data.Aeson.TH</code>，你就可以在你的类型上使用简单的功能<code class="eh li lj lk kx b">deriveJSON</code>。这将给你一些漂亮的新的<code class="eh li lj lk kx b">ToJSON</code>和<code class="eh li lj lk kx b">FromJSON</code>实例。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="c8d9" class="lb jq hu kx b fv lc ld l le lf">{-# LANGUAGE TemplateHaskell #-}</span><span id="2512" class="lb jq hu kx b fv lg ld l le lf">import Data.Aeson.TH (deriveJSON, defaultOptions)</span><span id="3aec" class="lb jq hu kx b fv lg ld l le lf">data Person = Person<br/>  { name :: String<br/>  , age :: Int<br/>  , occupation :: Occupation<br/>  } deriving (Show)<br/></span><span id="304b" class="lb jq hu kx b fv lg ld l le lf">data Occupation = Occupation<br/>  { title :: String<br/>  , tenure :: Int<br/>  , salary :: Int<br/>  } deriving (Show)</span><span id="07ea" class="lb jq hu kx b fv lg ld l le lf">-- The two apostrophes before a type name is template haskell syntax<br/>deriveJSON defaultOptions ''Occupation<br/>deriveJSON defaultOptions ''Person</span></pre><p id="195a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将再次得到类似的输出:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="8f05" class="lb jq hu kx b fv lc ld l le lf">&gt;&gt; Data.Aeson.encode person1<br/>"{\"name\":\"John Doe\",\"age\":26,\"occupation\":{\"title\":\"teacher\",\"tenure\":5,\"salary\":60000}}"<br/>&gt;&gt; Data.Aeson.encode person2<br/>"{\"name\":\"Jane Doe\",\"age\":25,\"occupation\":{\"title\":\"engineer\",\"tenure\":4,\"salary\":90000}}"</span></pre><p id="b206" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不像派生这些类型整块布料，您实际上在这里有选择。注意我们最初通过了<code class="eh li lj lk kx b">defaultOptions</code>。我们可以改变这一点，转而传递一些修改过的选项。例如，如果需要，我们可以在字段名前添加类型:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="6abd" class="lb jq hu kx b fv lc ld l le lf">deriveJSON (defaultOptions { fieldLabelModifier = ("occupation_" ++)}) ''Occupation<br/>deriveJSON (defaultOptions { fieldLabelModifier = ("person_" ++)}) ''Person</span></pre><p id="9c52" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">产生的输出是:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="3456" class="lb jq hu kx b fv lc ld l le lf">&gt;&gt; Data.Aeson.encode person1<br/>"{\"person_name\":\"John Doe\",\"person_age\":26,\"person_occupation\":{\"occupation_title\":\"teacher\",\"occupation_tenure\":5,\"occupation_salary\":60000}}"</span></pre><p id="c128" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">模板Haskell可以方便。它减少了您必须编写的样板代码的数量。但是这也会使你的代码需要更长的编译时间。当您使用模板Haskell时，可访问性也是有代价的。大多数Haskell新手都知道<code class="eh li lj lk kx b">deriving</code>语法。但是如果你使用<code class="eh li lj lk kx b">deriveJSON</code>，他们可能会挠头想知道你到底在哪里定义了JSON实例。</p><h1 id="b439" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">编码、解码和通过网络发送</h1><p id="3028" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">一旦我们定义了不同的实例，你可能想知道我们实际上是如何使用它们的。答案取决于您使用的库。例如，<code class="eh li lj lk kx b">Servant</code>库使它变得简单。除了定义实例之外，您不需要做任何序列化工作！服务端点定义它们的返回类型以及它们的响应内容类型。一旦定义了这些，序列化就会在后台进行。如果你需要做一个API，Servant是一个很棒的库。如果你想了解图书馆的基本情况，你应该看看我在BayHac 2017上的演讲。还可以看一下那个演讲中的<a class="ae lh" href="https://www.mmhaskell.com/bayhac" rel="noopener ugc nofollow" target="_blank">代码示例</a>中的一个特定示例。</p><p id="ae61" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，其他库会要求您处理JSON字节串。幸运的是，一旦定义了FromJSON和ToJSON实例，这也非常容易。正如我在本文的例子中所展示的，<code class="eh li lj lk kx b">Data.Aeson</code>具有<code class="eh li lj lk kx b">encode</code>功能。这将把您的JSON使能类型转换成一个可以通过网络发送的<code class="eh li lj lk kx b">ByteString</code>。很简单。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="7c53" class="lb jq hu kx b fv lc ld l le lf">&gt;&gt; Data.Aeson.encode person1<br/>"{\"name\":\"John Doe\",\"age\":26,\"occupation\":{\"title\":\"teacher\",\"tenure\":5,\"salary\":60000}}"</span></pre><p id="33ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一如既往，解码有点棘手。您必须考虑数据格式不正确的可能性。你可以调用简单的<code class="eh li lj lk kx b">decode</code>函数。这为您提供了一个<code class="eh li lj lk kx b">Maybe</code>值，因此如果解析不成功，您将得到<code class="eh li lj lk kx b">Nothing</code>。在解释器中，您还应该确保指定您想要从<code class="eh li lj lk kx b">decode</code>得到的结果类型，否则您将得到它试图将它解析为<code class="eh li lj lk kx b">()</code>，这将失败。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="a5e8" class="lb jq hu kx b fv lc ld l le lf">&gt;&gt; let b = Data.Aeson.encode person1<br/>&gt;&gt; Data.Aeson.decode b :: Maybe Person<br/>Just (Person {name = "John Doe", age = 26, occupation = Occupation {title = "teacher", tenure = 5, salary = 60000}})</span></pre><p id="3401" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了更好地处理错误情况，您应该选择<code class="eh li lj lk kx b">eitherDecode</code>。如果失败，这将给你一个错误信息。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="8617" class="lb jq hu kx b fv lc ld l le lf">&gt;&gt; Data.Aeson.eitherDecode b :: Either String Person<br/>Right (Person {name = "John Doe", age = 26, occupation = Occupation {title = "teacher", tenure = 5, salary = 60000}})<br/>&gt;&gt; let badString = "{\"name\":\"John Doe\",\"occupation\":{\"salary\":60000,\"tenure\":5,\"title\":\"teacher\"}}"<br/>&gt;&gt; Data.Aeson.decode badString :: Maybe Person<br/>Nothing<br/>&gt;&gt; Data.Aeson.eitherDecode badString :: Either String Person<br/>Left "Error in $: key \"age\" not present"</span></pre><h1 id="7f5e" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">摘要</h1><p id="0f70" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">现在我们知道了将Haskell数据序列化为JSON的所有要点。第一步是为您想要序列化的类型定义<code class="eh li lj lk kx b">ToJSON</code>和<code class="eh li lj lk kx b">FromJSON</code>实例。大多数情况下，这些都很容易写出来。但是也有一些不同的机制来推导它们。一旦你这样做了，像Servant这样的库就可以直接使用这些实例了。但是处理手动<code class="eh li lj lk kx b">ByteString</code>值也很容易。你可以简单地使用<code class="eh li lj lk kx b">encode</code>功能和<code class="eh li lj lk kx b">decode</code>的各种风格。</p><p id="8b0c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也许你总是对自己说，“Haskell不可能对web编程有用。”我希望这让你看到了一些可能性。你应该试试哈斯克尔！下载我们的<a class="ae lh" href="https://www.mmhaskell.com/checklist" rel="noopener ugc nofollow" target="_blank">入门清单</a>，获取一些有用工具的链接！</p><p id="ea24" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也许你已经使用了一些Haskell，但是你担心自己在尝试web编程时走在了前面。你应该下载我们的<a class="ae lh" href="https://www.mmhaskell.com/workbook" rel="noopener ugc nofollow" target="_blank">递归练习册</a>。它将帮助您巩固您的函数式编程技能！</p><blockquote class="ll lm ln"><p id="4060" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated"><a class="ae lh" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae lh" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae lh" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae lh" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae lh" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae lh" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上给我们点赞/发消息</a>，或者简单地说，<a class="ae lh" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lh" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lh" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>