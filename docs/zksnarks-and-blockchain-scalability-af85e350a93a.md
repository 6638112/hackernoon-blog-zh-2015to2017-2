# zksnarks 和区块链可伸缩性

> 原文：<https://medium.com/hackernoon/zksnarks-and-blockchain-scalability-af85e350a93a>

## 实现区块链可伸缩性四种有趣方法

**免责声明:**我不是 zksnark 专家。接下来的可能是垃圾，任何错误都是我的。非常感谢[克里斯·雷特维纳](/@chriseth)审阅这篇文章。我推荐他在 zksnarks 上的[介绍文章。也感谢来自 Zcash 的 Ariel Gabizon 指出了我忽略的几个细微之处。](http://chriseth.github.io/notes/articles/zksnarks/zksnarks.pdf)

## 定义

设 **P** 是一个有两个输入的程序。第一个输入 **i** 是公共的。第二个输入 **w** 是可以保密的见证。我们使用 **o** 作为 **P** 的输出。

给定一个程序 **P** ，一个输入 **i** 和一个输出 **o** ，如果证明者知道一个证人 **w** 使得 **o = P(i，w)** 那么证明者可以给出一个证明，其中:

1.  (空间密度)证明非常短(即使对于非常大的程序也只有几百个字节；例如 Zcash 达到 288 字节)
2.  (时间密度)证明时间与 **i** 和 **o** 的长度成线性关系
3.  (零知识)除了 **w** 的存在之外，该证明没有泄露关于 **P** 的执行或 **w** 的内容

这样的证明被称为 zksnarks。

(作为一个技术题外话，zksnarks 只为验证程序 **P** 所知，这些验证程序在多项式时间内运行到 **i** 和 **w** 的长度。我们还假设安全参数“λ”是固定的。)

## 直觉

我喜欢把 zksnarks 同时看作是用于计算的[加密](https://hackernoon.com/tagged/cryptographic)散列和签名的等价物(将这两种加密原语扩展到数据之外)。像哈希一样，zksnarks 将计算“压缩”成一个短而快速的验证指纹。像签名一样，zksnarks“证明”计算的有效性。

下面我们展示了使用 zksnarks 解决[区块链](https://hackernoon.com/tagged/blockchain)可伸缩性的方法。鉴于当今的技术水平，这些大多是理论上的。zksnarks 的验证很便宜，但证明的生成是真正的瓶颈。近年来，围绕 zksnarks 的密码学研究进展迅速。数量级的改进使 Zcash 成为现实。下面概述的方法有可能在几年后变得实用。

# 1)快速同步

传统上，同步区块链需要带宽、存储和计算。例如，在比特币中，大部分计算都是检查签名。有了 zksnarks，就可以消除逐个显式验证事务签名的负担。一个 zksnark 可以证明一个块的所有签名。这意味着同步比特币的计算要求可以大大降低。

看到这个让 **P** 是程序在哪里:

*   **i** 是一个块哈希
*   **w** 是块
*   如果 **w** 具有 hash **i** 并且 **w** 中的所有事务都具有有效签名，则 **P** 返回 True，否则 **P** 返回 False

假设块的大小是有限的(例如 1 MB ),那么只要 **o** 为真，就可以为 **P** 生成 zksnarks。这种 zksnarks 用密码证明签名是有效的，而不需要验证(甚至下载！)的签名。这是有效的类固醇。请注意， **i** 和 **o** 的大小是恒定的(分别为 256 位和 1 位),因此验证需要恒定的时间。

# 2)超轻客户端

传统上，想要回答一些关于区块链的问题的轻客户端必须做两件事。首先，它必须下载相关的区块链数据，然后对这些数据进行相关的计算。例如，一个想回答问题“这个特定的众筹基金达到目标了吗？”会下载众筹交易并把金额加起来。有了 zksnarks，就可以用密码向客户展示这些事实，而无需下载数据或对数据进行计算。这为“超轻”客户端打开了大门，这些客户端拥有接近于零的带宽、存储和计算资源，但仍然保持加密主权。

要了解这一点，让 **P** 成为一个轻客户端查询虚拟机，其中:

*   I 包含指定要查询的区块链的块散列和指定对该区块链的查询的脚本(例如，一些 web3 JavaScript)
*   w 是查询所需的区块链数据，以及用于轻型客户端验证的 Patricia-Merkle 树的所需部分
*   **o** 是脚本的输出

给定一个查询 **i** 和一个输出 **o** ，可以产生一个相应的 zksnark 来证明查询结果的有效性。

你可以想象这样一个世界，专用证明者为超轻客户端提供 zksnarks-as-a-service。因为生成 zksnarks 可能会很昂贵，所以专用集成电路会加速这个过程。证明者将成为新的矿工，专用硬件的效用从提供安全性转变为提供可扩展性，采矿费转变为“证明费”。

# 3)抽象出代码和存储

目前在以太坊上，智能合约的代码和存储(它们一起描述状态)完全存储在区块链上。这会占用资源，而且不利于隐私。事实证明，zksnarks 可以将智能合约的状态浓缩到一个哈希中，混淆底层代码和存储。

要了解这一点，让 **P** 成为以太坊轻客户端验证器，其中:

*   **i** 是哈希的三元组。第一个散列是指定当前状态的区块链的块散列。第二个散列值 **h_now** 记录了当前在区块链中表示的智能合约的状态。最后， **h_future** 是智能合约在未来某个时间的状态的散列。
*   **w** 具有智能合约在时间 **h_now** 的状态，加上将状态从 **h_now** 推进到 **h_future** 的中介交易，加上 Patricia-Merkle 树中需要进行状态的轻型客户端验证的部分
*   如果 **h_future** 对应的状态有效，P 返回真，否则返回假

可以为 **P** 生成 zksnarks，其证明智能合约的状态改变的有效性，而不暴露智能合约的代码或其存储。

# **4)通用状态通道**

上述用于从区块链中抽象出代码和存储的技术(将状态推离链，例如在 IPFS 上)还允许批处理在 **h_now** 和 **h_future** 之间发生的状态变化。这个构造实际上是一个通用的状态通道。除了设置和结算交易之外，所有活动都发生在链外。

这种构造允许状态通道仅在区块链上存储单个散列，并且通过单个 zksnark 验证在区块链上强制执行状态更改。

你可以想象一个区块链(zEthereum？)中，它只存储智能合约的散列，其中唯一的操作码用于 zksnark 验证。

> [黑客中午](http://bit.ly/Hackernoon)是黑客如何开始他们的下午。我们是 [@AMI](http://bit.ly/atAMIatAMI) 家庭的一员。我们现在[接受投稿](http://bit.ly/hackernoonsubmission)，并乐意[讨论广告&赞助](mailto:partners@amipublications.com)机会。
> 
> 要了解更多信息，请[阅读我们的“关于”页面](https://goo.gl/4ofytp)、[在脸书上点赞/给我们发消息](http://bit.ly/HackernoonFB)，或者简单地说， [tweet/DM @HackerNoon。](https://goo.gl/k7XYbx)
> 
> 如果你喜欢这个故事，我们推荐你阅读我们的[最新科技故事](http://bit.ly/hackernoonlatestt)和[趋势科技故事](https://hackernoon.com/trending)。直到下一次，不要把世界的现实想当然！