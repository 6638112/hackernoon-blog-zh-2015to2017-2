<html>
<head>
<title>How to decouple state and UI (a.k.a. you don’t need componentWillMount)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何分离状态和用户界面(也就是你不需要组件)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-decouple-state-and-ui-a-k-a-you-dont-need-componentwillmount-cc90b787aa37?source=collection_archive---------0-----------------------#2016-08-22">https://medium.com/hackernoon/how-to-decouple-state-and-ui-a-k-a-you-dont-need-componentwillmount-cc90b787aa37?source=collection_archive---------0-----------------------#2016-08-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/5f77d3ecdab478b032b475ffe3f1448a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qHdzvFpEH0dxY-IzPuKuIw.jpeg"/></div></div></figure><div class=""/><p id="5d74" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">在没有UI层的情况下处理路由、数据获取、认证和工作流测试的策略</em></p><p id="aecb" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">管理像<a class="ae kb" href="http://mobxjs.github.io/mobx" rel="noopener ugc nofollow" target="_blank"> MobX </a>这样的开源项目让我有机会窥视许多代码库。在这样做的时候，我发现大多数React应用程序不是由存储在存储中的状态驱动的；它们也由安装元件的逻辑驱动。这听起来可能有点模糊，所以让我们看两个例子:</p><ul class=""><li id="5083" class="kc kd if je b jf jg jj jk jn ke jr kf jv kg jz kh ki kj kk dt translated">解释路由更改通常是在组件中完成的；尤其是在使用react-router时。路由器基于当前URL构建一个组件树，这将触发<em class="ka">组件的</em>处理程序，这些处理程序将解释参数并相应地更新状态。</li><li id="c11e" class="kc kd if je b jf kl jj km jn kn jr ko jv kp jz kh ki kj kk dt translated">数据获取通常由组件将要被呈现的事实触发，并由<em class="ka"> componentWillMount </em>生命周期挂钩启动。</li></ul><p id="23e2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">尽管这种方法非常可行，但是它也有一些缺点:首先，我们不能仅仅通过查看我们的存储状态来推断我们的应用程序状态和流程。其次，我们需要知道哪些组件将被呈现给某些路线，以及它们在被挂载时执行什么活动。用图片来描述:</p><figure class="kr ks kt ku fq hw fe ff paragraph-image"><div class="fe ff kq"><img src="../Images/c30e459df083b7bd86e004345d9dc9ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*DVJZ1jRLKt05wnMH5zJboA.png"/></div></figure><p id="6d40" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这看起来不像我们的UI是状态的函数。看起来更像是我们的状态，最初是我们组件的函数。在这篇博客中，我将展示如何将这种关系转化为下图:</p><figure class="kr ks kt ku fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff kv"><img src="../Images/be4ee780a4d111f8f896d41a3ffb6c2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*nvvQASQnw9FjvCehAq76UQ.png"/></div></div></figure><p id="9d3a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种方法具有更好的状态和UI解耦性。这有几个优点:</p><ol class=""><li id="d712" class="kc kd if je b jf jg jj jk jn ke jr kf jv kg jz kw ki kj kk dt translated">无需实例化组件就可以测试完整的应用程序流。</li><li id="d509" class="kc kd if je b jf kl jj km jn kn jr ko jv kp jz kw ki kj kk dt translated">更多的组件可以是哑的；他们不必获取数据或处理路由。</li><li id="4022" class="kc kd if je b jf kl jj km jn kn jr ko jv kp jz kw ki kj kk dt translated">我们的存储变得更像一个状态机，使得跟踪应用程序的转换变得容易。</li></ol><h1 id="d1fa" class="kx ky if bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">示例应用程序</h1><p id="7228" class="pw-post-body-paragraph jc jd if je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz hn dt translated">为了演示这一点，我们将构建一个简单的文档查看器应用程序。该应用程序本身是琐碎的，但是具有路由、认证和数据获取的特性，这使它与真实的应用程序有一些相似之处。该应用程序由具有以下属性的两个页面组成:</p><ol class=""><li id="1b2e" class="kc kd if je b jf jg jj jk jn ke jr kf jv kg jz kw ki kj kk dt translated">有一个文档概述(route " <em class="ka"> document/" </em>)</li><li id="c81d" class="kc kd if je b jf kl jj km jn kn jr ko jv kp jz kw ki kj kk dt translated">存在文档查看页面(route "<em class="ka">document/&lt;document-id&gt;"</em>)</li><li id="8a94" class="kc kd if je b jf kl jj km jn kn jr ko jv kp jz kw ki kj kk dt translated">任何人都可以访问概览，但是要想看到特定文档的内容，必须登录。</li></ol><p id="31a4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该动画展示了应用程序的整个功能集。请注意地址栏、加载和错误消息中的变化。</p><figure class="kr ks kt ku fq hw fe ff paragraph-image"><div class="fe ff ma"><img src="../Images/37c177c5c05e5b1f5727f85f2b1c4318.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*SQOtIz7_OrUXXVmQp6uzJA.gif"/></div></figure><p id="5019" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该应用程序是使用React和<a class="ae kb" href="http://mobxjs.github.io/mobx" rel="noopener ugc nofollow" target="_blank"> MobX </a>构建的。尽管如此，我认为所展示的原则可以应用于，或者已经存在于许多现有的框架中。应用程序最初是使用<a class="ae kb" href="https://github.com/cafreeman/generator-mobx-react" rel="noopener ugc nofollow" target="_blank"> mobx-react yeoman生成器</a>生成的。完整的源代码可以在这个<a class="ae kb" href="https://github.com/mweststrate/state-routing-blog-sources" rel="noopener ugc nofollow" target="_blank"> github repo </a>中找到。</p><h1 id="5b5b" class="kx ky if bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">视图存储:捕获应用程序状态</h1><p id="3394" class="pw-post-body-paragraph jc jd if je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz hn dt translated">大多数应用程序状态将在<em class="ka">视图存储</em>中捕获。它捕获两个重要的数据:当前用户和当前视图。<br/> <em class="ka">当前用户</em>反映登录用户的身份。<em class="ka"> currentView </em>描述当前可见的页面，并捕获该页面所需的数据。</p><figure class="kr ks kt ku fq hw"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="f8c1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们可以介绍我们的第一个动作，它更新了<em class="ka"> currentView </em>来反映我们正在显示文档的概览。</p><figure class="kr ks kt ku fq hw"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="31e1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先我们商店接受<em class="ka"> fetch </em>作为构造函数参数。这基本上是一个围绕<em class="ka">窗口的小包装器。它会自动解析JSON，并对任何非200响应进行保释。我们显式地将它传递给我们的存储，以便我们可以在单元测试中轻松地将其存根化。</em></p><p id="0676" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka"> showOverview </em>方法是有趣的部分，它更新<em class="ka"> currentView </em> <br/>并开始从我们的HTTP服务器(本演示中的一个静态文件服务器)获取文档。<em class="ka"> fetch </em>返回的承诺从<a class="ae kb" href="https://github.com/mobxjs/mobx-utils#frompromise" rel="noopener ugc nofollow" target="_blank"> mobx-utils </a>包传递给<em class="ka"> fromPromise </em>，mobx-utils 包将承诺转化为<a class="ae kb" href="https://hackernoon.com/tagged/mobx" rel="noopener ugc nofollow" target="_blank"> MobX </a>可观察。这允许MobX在UI和测试中观察承诺的进展。</p><h1 id="c668" class="kx ky if bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">测试文档概述</h1><p id="f6dd" class="pw-post-body-paragraph jc jd if je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz hn dt translated">此时，ViewStore捕获应用程序的当前状态或“路线”,并获取必要的数据。由于ViewStore中没有特定于浏览器的东西，我们可以使用node和<a class="ae kb" href="https://github.com/substack/tape" rel="noopener ugc nofollow" target="_blank"> tape </a>轻松测试这个服务器端。在我们的测试中，我们用一个简单的文件系统调用stub <em class="ka"> fetch </em>(我很清楚有很棒的库可以做得更好，但是为了这个博客，我想保持简单和透明)。</p><figure class="kr ks kt ku fq hw"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="df67" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，我们使用MobX的<em class="ka"> when </em>来等待，直到可观察到的承诺完成，然后检查是否加载了正确数量的文档。</p><h1 id="4f58" class="kx ky if bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">显示特定文档</h1><p id="d793" class="pw-post-body-paragraph jc jd if je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz hn dt translated">是时候采取更具挑战性的行动了；打开特定文档。请记住，只有登录的用户才允许这样做。</p><figure class="kr ks kt ku fq hw"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="1cb3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了检查用户是否已经登录，我们引入了一个computed属性来检查是否设置了<em class="ka"> currentUser </em>。<em class="ka"> showDocument </em>函数与<em class="ka"> showOverview </em>非常相似，除了这次如果用户没有登录，我们会立即拒绝承诺，而不是获取数据。</p><p id="0b46" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，我们仍然更新<em class="ka">当前视图</em>。这样做的好处是，我们已经可以更新URL(见下文)并在UI中反映用户的预期位置。</p><p id="d890" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将可观察到的承诺存储在<em class="ka"> currentView </em>中有一个好处:<br/>它消除了竞争条件。对外界可见为<em class="ka"> currentView.document </em>的可观察承诺，永远是最后一个<em class="ka"> showDocument </em>调用创建的承诺。</p><h1 id="6309" class="kx ky if bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">证明</h1><p id="9b66" class="pw-post-body-paragraph jc jd if je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz hn dt translated">为了支持用户实际登录的场景，ViewStore公开了<em class="ka"> performLogin </em>动作，该动作接受一个<em class="ka">用户名、密码</em>和<em class="ka">回调。</em>如果成功登录，将调用回调函数<em class="ka"> true </em>，否则调用<em class="ka"> false </em>。</p><figure class="kr ks kt ku fq hw"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="9360" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">(是的，我确实意识到这是最糟糕的登录方式；-).一个合适的登录调用会给示例增加一些噪音，但不会从根本上改变方法本身)</p><p id="aeca" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有了身份验证，我们可以引入两个额外的测试来检查我们是否可以在登录(退出)的情况下访问文档。与前面的测试类似，我们调用将存储转换到正确状态的操作，并检查是否所有承诺都将正确结算。</p><figure class="kr ks kt ku fq hw"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="8e38" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">到目前为止还不错，对吧？我们已经测试了整个工作流程，还没有涉及到单个组件或路由库。ViewStore完全不知道这些事情。</p><h1 id="9772" class="kx ky if bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">去大教堂！</h1><p id="3919" class="pw-post-body-paragraph jc jd if je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz hn dt translated">是时候渲染我们的视图库了！因为我们所有的逻辑都是在视图存储中捕获的，所以大多数组件可能是哑的、无状态的组件。</p><figure class="kr ks kt ku fq hw"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="5651" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先是“App”组件，它使用一个简单的switch语句获取商店并根据商店的名称<em class="ka"> currentView.name </em>初始化适当的视图。此外，它还显示当前登录的用户。</p><p id="bb01" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">呈现文档概览的组件与呈现单个文档的组件非常相似。后者更有趣，所以我们现在省略了<em class="ka">文档概述</em>  <em class="ka"> </em>的<a class="ae kb" href="https://github.com/mweststrate/state-routing-blog-sources/blob/90b7fb8d5350b3367cb6e1be8facdc18b1390670/src/components/App.jsx#L26" rel="noopener ugc nofollow" target="_blank">来源。(为简单起见，在本例中所有组件都放在同一个文件中)。</a></p><figure class="kr ks kt ku fq hw"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="07d5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">文档</em>组件打开由<em class="ka">显示文档</em>动作创建的<em class="ka">视图.文档</em>可观察承诺的状态。<br/>基于承诺的状态，它呈现加载消息、错误消息或已解决的文档。</p><p id="4691" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是在呈现文档之前，我们检查当前用户是否已经过身份验证。如果不是这样，我们将呈现登录表单并提供一个<em class="ka"> afterLogin </em>回调。如果我们不检查这一点，用户将会看到被拒绝的<em class="ka">文档</em>承诺的认证错误。这不是非常用户友好的。</p><p id="74bd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了能够看到“正在加载”的消息，你可以在chrome devtools中启用网络节流:</p><figure class="kr ks kt ku fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff md"><img src="../Images/54e5613c4ebdd27816e541344cfa1b1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K8ClKkNnHtOGt2yeqF0c5w.png"/></div></div></figure><h1 id="27b1" class="kx ky if bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">登录表单</h1><p id="0187" class="pw-post-body-paragraph jc jd if je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz hn dt translated">登录表单本身也非常简单。它有一些存储当前用户名、密码和反馈消息的本地可观察状态。一旦用户成功登录，就会调用<em class="ka"> afterLogin </em>，这是通过<em class="ka"> ViewStore.performLogin </em>动作完成的。</p><figure class="kr ks kt ku fq hw"><div class="bz el l di"><div class="mb mc l"/></div></figure><h1 id="c4bb" class="kx ky if bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">路由:将路由转换为状态</h1><p id="0520" class="pw-post-body-paragraph jc jd if je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz hn dt translated">我们还没有实现路由。如前所述，我们希望路由器直接在我们的存储上调用操作。而不是间接地通过构建一个组件树并触发<em class="ka">组件来挂载</em>钩子。这使得测试和推理更加简单，因为UI完全基于存储中的状态。</p><p id="1716" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当路由改变时调用存储方法是微不足道的。任何通用的<a class="ae kb" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>路由库都可以这样做。例如，你可以使用<a class="ae kb" href="https://github.com/mjackson/history" rel="noopener ugc nofollow" target="_blank"> <em class="ka">历史</em> </a>库(它也支持react-router ),但是在这个例子中，我选择了<a class="ae kb" href="https://github.com/flatiron/director" rel="noopener ugc nofollow" target="_blank"> director </a>,它有一个方便的URL匹配机制。</p><figure class="kr ks kt ku fq hw"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="6b0e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用<em class="ka">控制器</em>，设置路由非常简单。我们定义两条路线来触发<em class="ka"> showDocument </em>或<em class="ka"> showOverview </em>动作。后者也被用作默认路由。请注意，<em class="ka"> startRouter </em>函数位于我们商店之外，因为它主要是一个浏览器专用的东西。</p><h1 id="6b6e" class="kx ky if bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">路由:将状态转换为路由</h1><p id="2cbd" class="pw-post-body-paragraph jc jd if je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz hn dt translated">这很简单。每当在浏览器的地址栏中输入URL时，商店将转换到正确的状态，并呈现正确的UI。然而，相反的过程却不见了。如果我们单击概览中的一个文档，地址栏中的URL应该会更新。</p><p id="8be1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">人们可以简单地通过在商店的适当动作中调用<em class="ka"> history.pushState </em>来解决这个问题。那会起作用，但是不要着急。这种方法有两个缺点。首先，它会让我们的商店浏览器知道。其次，这是解决问题的一种繁琐而又迫切的方法。如果你的用户界面有很多可能的视图，你会在很多地方使用<em class="ka"> pushState </em>调用。</p><p id="6e83" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请考虑这一点:应用程序的URL只是应用程序状态的一种表示。与UI一样，它可以完全从当前应用程序状态中派生出来。从状态中派生事物，这是MobX擅长的地方。因此，让我们在viewStore中引入一个计算属性，该属性派生出表示当前视图的路径:</p><figure class="kr ks kt ku fq hw"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="504f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">当前路径</em>是我们当前状态的抽象字符串表示。但它仍然只是一个值。我们需要一个副作用来让它成为历史。所以我们在之前定义的<em class="ka"> startRouter </em>中设置了一个自动运行(可以用来自动触发副作用)来解决这个问题。</p><figure class="kr ks kt ku fq hw"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="517e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了避免URL更新触发URL更改和无休止的循环，我们添加了一个简单的保护措施，在推送历史记录项目之前检查URL是否确实发生了更改。我们的路由流现在看起来像这样:</p><figure class="kr ks kt ku fq hw fe ff paragraph-image"><div class="fe ff me"><img src="../Images/e7211588220a8107b6f718edd7c1aac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*ksoMhK4GRob9QHbzzb0SBA.png"/></div></figure><h1 id="6ca5" class="kx ky if bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">将这些点连接起来</h1><p id="c5d9" class="pw-post-body-paragraph jc jd if je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz hn dt translated">我们现在有了一个捕捉应用程序状态的通用视图存储、呈现状态的React组件和一个设置路由的函数。现在，我们可以简单地将这些部分粘合在一起，得到一个可工作的应用程序，而不仅仅是单元测试:</p><figure class="kr ks kt ku fq hw"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="7381" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">仅此而已。</p><h1 id="ab06" class="kx ky if bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">结论</h1><p id="140b" class="pw-post-body-paragraph jc jd if je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz hn dt translated">现在，我们刚刚构建了一个执行路由、数据获取和身份验证的应用程序。虽然它只有大约200 LOC，但是它很好地展示了如何在实际应用程序中实现这些概念。</p><p id="c146" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我们在管理应用程序状态(完全可以独立测试)、呈现UI和路由之间实现了高度的解耦。这是通过(1)从React组件的c<em class="ka">componentwillmount</em>处理程序中移除数据获取和路由解释的责任，以及(2)确保UI的全局状态由ViewStore管理来实现的。这使得测试组件和测试应用程序流变得更加简单。</p><p id="7bb1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我希望这给了你一个很好的概述，关于一个<em class="ka">如何通过清楚地描述状态和可以从它派生的东西来建立MobX应用程序(或其他框架)中的项目结构。如果你想了解更多关于MobX的知识，请确保查看<a class="ae kb" href="https://egghead.io/courses/manage-complex-state-in-react-apps-with-mobx" rel="noopener ugc nofollow" target="_blank">免费egghead.io课程</a>！</em></p><p id="67b8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">简而言之，来源:</p><ul class=""><li id="c007" class="kc kd if je b jf jg jj jk jn ke jr kf jv kg jz kh ki kj kk dt translated"><a class="ae kb" href="https://github.com/mweststrate/state-routing-blog-sources/blob/master/src/store/ViewStore.js" rel="noopener ugc nofollow" target="_blank"> ViewStore.js </a> ( <a class="ae kb" href="https://github.com/mweststrate/state-routing-blog-sources/blob/master/src/store/ViewStore.test.js" rel="noopener ugc nofollow" target="_blank">测试</a>)</li><li id="62eb" class="kc kd if je b jf kl jj km jn kn jr ko jv kp jz kh ki kj kk dt translated"><a class="ae kb" href="https://github.com/mweststrate/state-routing-blog-sources/blob/master/src/components/App.jsx" rel="noopener ugc nofollow" target="_blank"> App.jsx </a></li><li id="bcd8" class="kc kd if je b jf kl jj km jn kn jr ko jv kp jz kh ki kj kk dt translated"><a class="ae kb" href="https://github.com/mweststrate/state-routing-blog-sources/blob/master/src/store/router.js" rel="noopener ugc nofollow" target="_blank"> router.js </a></li><li id="b23a" class="kc kd if je b jf kl jj km jn kn jr ko jv kp jz kh ki kj kk dt translated"><a class="ae kb" href="https://github.com/mweststrate/state-routing-blog-sources/blob/master/src/store/fetch.js" rel="noopener ugc nofollow" target="_blank"> fetch.js </a></li></ul></div><div class="ab cl mf mg hc mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hn ho hp hq hr"><h2 id="d1e4" class="mm ky if bd kz mn mo mp ld mq mr ms lh jn mt mu ll jr mv mw lp jv mx my lt mz dt translated">回答潜在问题的补充说明:)</h2><p id="0649" class="pw-post-body-paragraph jc jd if je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz hn dt translated">您可能已经注意到，我没有将所有的状态放入视图存储中。只有与应用程序的不同部分相关的状态，或者在导航时应该保持的状态，等等。</p><p id="b851" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我不认为必须移除所有<em class="ka">组件才能安装</em>挂钩。我只是想表达一个人应该小心使用它们。避免它们会使应用程序流更清晰，组件更简单。</p><p id="3163" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不要误解我。React-router是一个非常棒的工具。React-router可能是与MobX结合使用最多的路由器库，如果你已经有了这些东西，没有理由抛弃它。</p><p id="3aae" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们的项目中观察到，在组件树的根中通常有一个组件，其唯一的目的是在路由改变时更新状态。我们注意到不同的路由经常使用这个组件作为路由处理器。这就提出了一个问题，当直接改变状态会产生完全相同的结果时，是否真的需要构建组件树。</p><p id="b4ef" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">是的，在MobX中使用decorators是完全可选的。</p><div class="kr ks kt ku fq ab cb"><figure class="na hw nb nc nd ne nf paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="na hw nb nc nd ne nf paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="na hw nb nc nd ne nf paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ng nh ni"><p id="f922" class="jc jd ka je b jf jg jh ji jj jk jl jm nj jo jp jq nk js jt ju nl jw jx jy jz hn dt translated"><a class="ae kb" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kb" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kb" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae kb" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd ka je b jf jg jh ji jj jk jl jm nj jo jp jq nk js jt ju nl jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kb" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kb" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kr ks kt ku fq hw fe ff paragraph-image"><a href="https://goo.gl/Ahtev1"><div class="fe ff nm"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></a></figure><figure class="kr ks kt ku fq hw"><div class="bz el l di"><div class="nn mc l"/></div></figure></div></div>    
</body>
</html>