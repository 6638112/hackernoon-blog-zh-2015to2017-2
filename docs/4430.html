<html>
<head>
<title>Hands On Mobile API Security: Pinning Client Connections</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">移动API安全性实践:固定客户端连接</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/hands-on-mobile-api-security-pinning-client-connections-ebee4d82a911?source=collection_archive---------7-----------------------#2017-06-01">https://medium.com/hackernoon/hands-on-mobile-api-security-pinning-client-connections-ebee4d82a911?source=collection_archive---------7-----------------------#2017-06-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="4363" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">删除客户端机密时添加TLS和证书锁定</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/8404e836f07cff055c322b4a801d3696.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JnoCWNc50DE-_cKtpB-pvw.jpeg"/></div></div></figure><p id="c1cb" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><a class="ae kr" href="https://hackernoon.com/hands-on-mobile-api-security-get-rid-of-client-secrets-a79f111b6844" rel="noopener ugc nofollow" target="_blank">手把手教移动API安全:清除客户端秘密</a>教程演示了如何通过<a class="ae kr" href="https://hackernoon.com/we-reverse-engineered-16k-apps-heres-what-we-found-51bdf3b456bb" rel="noopener ugc nofollow" target="_blank">从移动应用中移除易受攻击的API秘密</a>来提高移动应用的安全性。在本教程中，您将使用一个简单的照片客户端，它需要一个API键来访问<a class="ae kr" href="https://apod.nasa.gov/" rel="noopener ugc nofollow" target="_blank"> NASA的每日图片服务</a>。在客户端和图片服务之间引入的API代理消除了在客户端本身存储和保护API密钥的需要。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff ks"><img src="../Images/2ad43c9aee91a3021db28d541192d06f.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*k-S01hDonp3WlyqjkzTuzw.png"/></div></figure><p id="bc65" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">因为我希望大多数人在模拟器中使用Android客户端运行本教程，在本地主机上使用代理服务器，所以我特意在客户端和代理之间运行普通的HTTP协议。虽然这简化了教程，但它不适合生产环境。为了增强安全性，您可能希望运行带有证书锁定的<a class="ae kr" href="https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning" rel="noopener ugc nofollow" target="_blank"> HTTPS协议</a>来防范中间人(MitM)攻击。</p><p id="ee21" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">因此，在这个续集中，您将在配置期间生成一个自签名证书，并将修改Android客户端，以便只接受来自持有证书私钥的服务器的连接请求。</p><h1 id="c8eb" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">TLS和固定</h1><p id="7240" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated"><a class="ae kr" href="https://en.wikipedia.org/wiki/Transport_Layer_Security" rel="noopener ugc nofollow" target="_blank">传输层安全性(TLS) </a>在客户端和服务器之间建立安全连接，提供隐私和数据完整性。<a class="ae kr" href="https://en.wikipedia.org/wiki/Public_key_infrastructure" rel="noopener ugc nofollow" target="_blank">公钥基础设施(PKI) </a>用于建立客户端和服务器之间的信任，建立安全通信。</p><p id="536d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">但是，如果攻击者能够将自己插入到客户端和服务器之间，他就可以截获初始TLS握手，出示自己的有效PKI证书，并在中间截获点建立一个人，在那里他可以读取和更改客户端和服务器之间的通信。</p><p id="c054" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">证书锁定建立了客户端将接受的证书的白名单。即使MitM攻击可能提供合法证书，客户端也只会接受由已知证书签名的连接。</p><h1 id="1076" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">入门指南</h1><p id="8bae" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">首先，下载更新的动手API代理源代码<em class="lq">。</em>在终端或命令窗口中，切换到存储教程的目录，并克隆这个公共git存储库:</p><pre class="jk jl jm jn fq lr ls lt lu aw lv dt"><span id="9c00" class="lw ku hu ls b fv lx ly l lz ma"><em class="lq">tutorials$</em> <strong class="ls hv">git clone </strong><a class="ae kr" href="https://github.com/approov/hands-on-api-proxy.git" rel="noopener ugc nofollow" target="_blank"><strong class="ls hv">https://github.com/approov/hands-on-api-proxy.git</strong></a></span></pre><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mb"><img src="../Images/6a3307c8794d8a1904d5f9b258caa4c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/format:webp/1*o2REiZIvbqMVYl3hJXGX0g.png"/></div></figure><p id="3668" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">遵循<a class="ae kr" href="https://hackernoon.com/hands-on-mobile-api-security-get-rid-of-client-secrets-a79f111b6844#c7b3" rel="noopener ugc nofollow" target="_blank">原始教程</a>中的附加设置说明。</p><p id="3f31" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><code class="eh mc md me ls b">steps</code>目录包含教程每一步的代理和服务器代码的工作版本，包括最终固定的客户机和代理项目的工作版本。</p><p id="8c2a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">当您运行配置设置时，它将生成一个自签名的数字证书和相应的私钥，并将它们放在适当的固定客户端和代理项目位置。</p><p id="5bc7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">或者，您可以使用现有的证书-私钥对，或者您可以使用<a class="ae kr" href="https://www.openssl.org/" rel="noopener ugc nofollow" target="_blank"> OpenSSL </a>生成自己的自签名证书-私钥对:</p><pre class="jk jl jm jn fq lr ls lt lu aw lv dt"><span id="67b6" class="lw ku hu ls b fv lx ly l lz ma"><em class="lq">$</em> <strong class="ls hv">openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem<br/>        -nodes -days 365</strong></span></pre><p id="63bb" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果您完成了前面的教程，您的<code class="eh mc md me ls b">pen</code>目录应该包含工作客户端和代理项目。如果从一个新的存储库开始，应该从安全客户端和增强代理的工作副本开始。将安全客户端和增强代理步骤复制到相应的游戏围栏目录中，例如:</p><pre class="jk jl jm jn fq lr ls lt lu aw lv dt"><span id="5152" class="lw ku hu ls b fv lx ly l lz ma"><em class="lq">api-proxy$</em> <strong class="ls hv">rm -rf pen/client</strong><br/><em class="lq">api-proxy$</em> <strong class="ls hv">cp -r steps/client/android/2_secure-client pen/client</strong><br/><em class="lq">api-proxy$</em> <strong class="ls hv">rm -rf pen/proxy</strong><br/><em class="lq">api-proxy$</em> <strong class="ls hv">cp -r steps/proxy/node/3_enhanced-proxy pen/proxy</strong></span></pre><p id="cf8b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">您可以构建当前的<code class="eh mc md me ls b">pen</code>项目，并确认客户端和代理正在按预期工作。</p><h1 id="ac78" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">将HTTPS添加到本地主机代理</h1><p id="6ba3" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">首先，确保您的数字证书和私钥对位于代理的源目录中。如果您使用的是在配置过程中生成的证书，它们分别被命名为<code class="eh mc md me ls b">cert.pem</code>和<code class="eh mc md me ls b">key.pem</code>:</p><pre class="jk jl jm jn fq lr ls lt lu aw lv dt"><span id="e249" class="lw ku hu ls b fv lx ly l lz ma"><em class="lq">api-proxy$</em> <strong class="ls hv">cp steps/proxy/node/4_pinned-proxy/src/cert.pem<br/>   pen/proxy/src/</strong><br/><em class="lq">api-proxy$</em> <strong class="ls hv">cp steps/proxy/node/4_pinned-proxy/src/key.pem<br/>   pen/proxy/src/</strong></span></pre><p id="8272" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在代理<code class="eh mc md me ls b">pen</code>中，确保安装了所需的模块:</p><pre class="jk jl jm jn fq lr ls lt lu aw lv dt"><span id="aee9" class="lw ku hu ls b fv lx ly l lz ma"><em class="lq">api-proxy$</em> <strong class="ls hv">cd pen/proxy</strong><br/><em class="lq">api-proxy/pen/proxy$</em> <strong class="ls hv">npm install</strong><br/><em class="lq">api-proxy/pen/proxy$</em> <strong class="ls hv">npm install https --save</strong></span></pre><p id="30a2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">接下来，修改节点代理以运行HTTPS。需要<code class="eh mc md me ls b">https</code>包，并用一个调用替换默认HTTP服务器的<code class="eh mc md me ls b">app.listen()</code>调用，以创建一个</p><p id="a7c1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">使用密钥对的HTTPS服务器。修改如下所示:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="9e73" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">启动代理服务器:</p><pre class="jk jl jm jn fq lr ls lt lu aw lv dt"><span id="02cf" class="lw ku hu ls b fv lx ly l lz ma"><em class="lq">api-proxy/pen/proxy$</em> <strong class="ls hv">npm start</strong></span></pre><p id="6cd0" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">使用浏览器调用代理来试用您的代理。假设您正在本地运行端口<code class="eh mc md me ls b">8080</code>，用现在代理的调用<code class="eh mc md me ls b">htttps://localhost:8080/api.nasa.gov/planetary/apod?date=2017–01–01</code>替换对NASA的直接调用。使用chrome，我看到了这样的回应:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mh"><img src="../Images/0c34b32d82e390ddea387982b85ddfe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GEsIZt-Ga8ZevmjhNHcD_w.png"/></div></div></figure><p id="0de4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Chrome不信任自签名证书，所以它警告我们，我们正试图使用不可信的证书运行HTTPS，如果我们仍然使用<code class="eh mc md me ls b">ADVANCED</code>继续，我们应该会通过localhost API代理看到来自NASA服务器的正确响应:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mh"><img src="../Images/d36b926a95e4627062436788c9605f62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3uFKxZUg99szt_cTZ6FiHg.png"/></div></div></figure><p id="a0f9" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果您仍然没有看到有效的JSON响应，请仔细检查您的代理URL、网络连接和数字证书。三重检查代理URL是否指定了HTTPS协议。同样在<code class="eh mc md me ls b">src/config.js</code>中，检查并强制<code class="eh mc md me ls b">approov_enforcement</code>值为<code class="eh mc md me ls b">false</code>。重新启动代理服务器，您将在代理日志中看到失败的证明，但服务不会被阻止。</p><p id="b8e3" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果您使用由公认的<a class="ae kr" href="https://en.wikipedia.org/wiki/Certificate_authority" rel="noopener ugc nofollow" target="_blank">认证机构(CA) </a>签署的证书，浏览器将使用CA的公钥来验证签名。由于浏览器信任CA，如果签名有效，那么浏览器将依次信任证书。</p><p id="a65b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">相比之下，自签名证书很容易生成且免费，但大多数浏览器或网络客户端堆栈不信任它们。对于自签名证书，我们必须以另一种方式建立信任，通常是通过验证我们收到了预期的数字证书，并且我们认识发送它的主机。</p><p id="9d63" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">要在生产环境中固定连接，您可能会使用由可信CA签名的证书，这实际上是更容易实现的方法。使用自签名证书进行pin需要在客户端内部做更多的工作，这一点我们将在接下来讨论。</p><p id="2be6" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><em class="lq">作为参考，此阶段完成的API代理版本在</em> <code class="eh mc md me ls b"><em class="lq">steps/proxy/android/4_pinned-proxy</em></code> <em class="lq">中。</em></p><h1 id="f920" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">Android客户端锁定</h1><p id="23fd" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">在Android客户端应用程序中，我们希望锁定HTTPS通道，以便只接受持有我们的数字证书的连接。</p><p id="7326" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">首先将<code class="eh mc md me ls b">config.xml</code>中的<code class="eh mc md me ls b">api_url</code>改为使用HTTPS而不是HTTP:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="abc5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">对于联网，Android客户端使用<a class="ae kr" href="http://square.github.io/okhttp/" rel="noopener ugc nofollow" target="_blank"> OKHttp库</a>。如果我们的数字证书是由Android认可的CA签署的，那么可以使用默认的信任管理器来验证证书。要锁定连接，只需向客户端添加主机名和证书公钥的散列值<code class="eh mc md me ls b">builder()</code>。请看<a class="ae kr" href="https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java" rel="noopener ugc nofollow" target="_blank">这个OKHttp配方</a>的例子。具有相同主机名和公钥的所有证书都将匹配散列，因此可以采用诸如证书轮换之类的技术，而无需更新客户端。多个主机名-公钥元组也可以添加到客户端<code class="eh mc md me ls b">builder()</code>。</p><p id="348a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">对于本教程，我们使用自签名证书，而不是CA签名证书。要使用自签名证书建立信任，您必须创建一个自定义的<code class="eh mc md me ls b">TrustManager</code>，并提供一个方法来验证目标主机。OKHttp提供了一个<a class="ae kr" href="https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java" rel="noopener ugc nofollow" target="_blank">自定义</a> <code class="eh mc md me ls b"><a class="ae kr" href="https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java" rel="noopener ugc nofollow" target="_blank">TrustManager</a></code> <a class="ae kr" href="https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java" rel="noopener ugc nofollow" target="_blank">菜谱</a>。</p><p id="1f87" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在<code class="eh mc md me ls b">pen</code>客户端项目中，首先将自签名证书<code class="eh mc md me ls b">cert.pem</code>添加到应用程序的主<code class="eh mc md me ls b">assets</code>目录中。<code class="eh mc md me ls b">cert.pem</code>的副本可以在<code class="eh mc md me ls b">steps/client/android/4_pinned-client/app/src/main/assets</code>中找到。</p><p id="a150" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在<code class="eh mc md me ls b">App.java</code>文件中，在<code class="eh mc md me ls b">App</code>类中创建一个私有的<code class="eh mc md me ls b">SSLContextPinner</code>类，它将你的数字证书读入到一个<code class="eh mc md me ls b">KeyStore</code>中，这又会初始化一个新的<code class="eh mc md me ls b">TrustManager</code>链。然后<code class="eh mc md me ls b">TrustManager</code>链初始化TLS <code class="eh mc md me ls b">SSLContext</code>。添加返回<code class="eh mc md me ls b">SSLContext</code>和初始<code class="eh mc md me ls b">X509Trustmanagerfrom</code>链的方法:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="d431" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">接下来，您必须提供一个主机名验证器。通常，您可以将DNS名称与证书相关的主机名进行比较，但是对于绝对IP地址，这种<a class="ae kr" href="https://developer.android.com/training/articles/security-ssl.html#CommonHostnameProbs" rel="noopener ugc nofollow" target="_blank">技术在浏览器和其他网络堆栈中会失效</a>。因为我们在这个例子中是固定一个已知的证书，所以我们将盲目地接受主机名对于本教程是有效的。只要没有人窃取我们的证书的匹配私钥，这是可以接受的风险；但是，在生产中，您将使用更强的检查。现在，在<code class="eh mc md me ls b">App</code>类中创建一个始终为真的主机名验证器:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="8130" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">使用这些类进行证书固定和主机名检查，为您的自签名证书构建固定客户端。修改<code class="eh mc md me ls b">App</code>类的<code class="eh mc md me ls b">onCreate()</code>方法:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="9425" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">完成这些更改后，您就可以测试客户机和服务器之间的固定连接了。确保代理服务器正在运行，像以前一样在Android模拟器或设备上构建并运行修改后的客户端应用程序。您应该在模拟器中看到当前NASA照片的图库，并在API代理控制台日志中看到照片请求。</p><p id="d1a7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果您看不到照片，请仔细检查您的代理URL、网络连接和数字证书。仔细检查代理IP地址(通常来自Android模拟器的<code class="eh mc md me ls b">10.0.2.2</code>)和端口地址(通常设置为<code class="eh mc md me ls b">8080</code>)。在<code class="eh mc md me ls b">src/config.js</code>中，检查并强制<code class="eh mc md me ls b">approov_enforcement</code>值为<code class="eh mc md me ls b">false</code>。重新启动代理服务器和客户端应用程序。在代理上，您将看到失败的证明，但服务不会被阻止。</p><p id="67c0" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果您想要执行客户端证明检查，您必须像在<a class="ae kr" href="https://hackernoon.com/hands-on-mobile-api-security-get-rid-of-client-secrets-a79f111b6844#3333" rel="noopener ugc nofollow" target="_blank">原始教程</a>中所做的那样，向Approov演示服务注册修改后的客户端应用。</p><p id="84c2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><em class="lq">作为参考，此阶段完成的API代理版本在</em> <code class="eh mc md me ls b"><em class="lq">steps/proxy/android/4_pinned-proxy</em></code> <em class="lq">中。</em></p><h1 id="2838" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">不会又是一个秘密吧？</h1><p id="5894" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">祝贺您成功锁定自签名证书。在这一点上，你可能会问自己“如果教程的目的是从客户端应用程序中删除秘密，我们不是刚刚在应用程序中添加了一个新的秘密吗？”</p><p id="cc95" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">嗯，我们确实在应用程序中添加了一个<em class="lq">常量</em>，如果使用自签名，它就是证书本身。但是，证书是公钥-私钥对的公开方。API代理服务器将把这个证书发给任何试图建立安全连接的人。这不是秘密。私钥保存在服务器上，而不是客户端上，是真正的秘密信息。</p><p id="b296" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">关键是防止任何人用自己的证书添加或替换你的证书，并重新打包应用程序。任何使用修改后的应用程序的人都容易受到MitM攻击。这就是像<a class="ae kr" href="https://approov.io" rel="noopener ugc nofollow" target="_blank">approv</a>这样的客户证明的关键所在。任何篡改应用程序的尝试都将导致认证失败。</p><h1 id="89f8" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">在野外</h1><p id="f0dd" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">如果您还没有这样做，我建议您确保<a class="ae kr" href="https://approov.io/demo-reg.html" rel="noopener ugc nofollow" target="_blank">approv演示包</a>是最新的，并按照<a class="ae kr" href="https://hackernoon.com/hands-on-mobile-api-security-get-rid-of-client-secrets-a79f111b6844#3333" rel="noopener ugc nofollow" target="_blank">原始教程</a>的最后步骤重新注册您的最终固定客户端-代理对。这大大加强了您的安全性。</p><p id="6165" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">将HTTPS与锁定结合使用可以提供隐私和数据完整性。牵制是防止中间人攻击的一项重要技术，但是如果客户端被篡改，它就很容易受到攻击。在这种情况下，这不是隐藏秘密的问题，而是确保公共证书不能在app中被修改。使用客户端证明服务可以有效地消除这种攻击媒介，恢复连接的私密性和完整性。</p><h1 id="becb" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">前进</h1><p id="7abc" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">感谢阅读！如果你推荐这个教程(点击❤按钮)让其他人也能找到它，我会非常感激。</p><p id="7df8" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">要了解更多关于API安全和相关主题的信息，请访问<a class="ae kr" href="https://www.approov.io/" rel="noopener ugc nofollow" target="_blank">approv . io</a>或在twitter上关注@critblue。</p><div class="jk jl jm jn fq ab cb"><figure class="mi jo mj mk ml mm mn paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mi jo mj mk ml mm mn paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mi jo mj mk ml mm mn paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mo mp mq"><p id="f922" class="jv jw lq jx b jy jz iv ka kb kc iy kd mr kf kg kh ms kj kk kl mt kn ko kp kq hn dt translated"><a class="ae kr" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kr" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kr" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae kr" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jv jw lq jx b jy jz iv ka kb kc iy kd mr kf kg kh ms kj kk kl mt kn ko kp kq hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kr" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kr" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mu"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>