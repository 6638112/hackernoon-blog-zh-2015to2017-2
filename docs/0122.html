<html>
<head>
<title>Elastic view animation, or how I built DGElasticPullToRefresh</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">弹性视图动画，或我如何构建DGElasticPullToRefresh</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/elastic-view-animation-or-how-i-built-dgelasticpulltorefresh-269a3ba8636e?source=collection_archive---------0-----------------------#2015-12-18">https://medium.com/hackernoon/elastic-view-animation-or-how-i-built-dgelasticpulltorefresh-269a3ba8636e?source=collection_archive---------0-----------------------#2015-12-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="9a6a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">嘿！我已经很久没有在媒体上发布任何东西了。</p><p id="e5d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这篇文章教程已经发表在了<a class="ae jp" href="http://iostuts.io/2015/10/17/elastic-bounce-using-uibezierpath-and-pan-gesture/" rel="noopener ugc nofollow" target="_blank"> iostuts.io </a>上。但是我喜欢把所有的东西都放在同一个地方，所以我决定找个时间，调整一下这篇文章，也把它发表在这里。</p><p id="d2df" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本教程主要讲解我前阵子发表的<a class="ae jp" href="https://github.com/gontovnik/DGElasticPullToRefresh" rel="noopener ugc nofollow" target="_blank"> DGElasticPullToRefresh </a>中弹性反弹效果是如何实现的:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff jq"><img src="../Images/828c1402e9e788d4a26880bceeab7a81.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/1*4wzMFJP-SX8zZejPuUR4ug.gif"/></div></figure><h2 id="1735" class="jy jz hu bd ka kb kc kd ke kf kg kh ki jc kj kk kl jg km kn ko jk kp kq kr ks dt translated">先决条件/要求</h2><ol class=""><li id="2df1" class="kt ku hu it b iu kv iy kw jc kx jg ky jk kz jo la lb lc ld dt translated"><a class="ae jp" href="https://hackernoon.com/tagged/xcode" rel="noopener ugc nofollow" target="_blank"> Xcode </a> 7</li><li id="0eec" class="kt ku hu it b iu le iy lf jc lg jg lh jk li jo la lb lc ld dt translated">Swift 2.0</li><li id="c072" class="kt ku hu it b iu le iy lf jc lg jg lh jk li jo la lb lc ld dt translated">至少对<a class="ae jp" href="https://hackernoon.com/tagged/uibezierpath" rel="noopener ugc nofollow" target="_blank"> UIBezierPath </a>和UIGestureRecognizer有基本的了解和认识</li></ol></div><div class="ab cl lj lk hc ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hn ho hp hq hr"><h2 id="3222" class="jy jz hu bd ka kb kc kd ke kf kg kh ki jc kj kk kl jg km kn ko jk kp kq kr ks dt translated">理解逻辑</h2><p id="0dd4" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">UIBezierPath是这个反弹动画的核心——它允许我们使用控制点创建曲线。为了在屏幕上显示创建的路径，我决定使用CAShapeLayer <em class="lt">(另一种方法是覆盖drawRect) </em>。贝塞尔路径的每个控制点应该表示为一个不可见的UIView。当手指移动时，所有控制点视图都应移动，曲线应更新，CAShapeLayer路径应设置为新值。当释放手指时，所有视图都使用弹簧动画动画到它们的初始位置。当视图被动画化时，我们需要观察它们的中心并更新我们的cashaplayer——这就是CADisplayLink的由来。</p><p id="0844" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是一个例子，如果我将所有控制点视图都设为红色，会是什么样子:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff lu"><img src="../Images/42561d52ca5cb62742a923cc01300fcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*vAmk8ulHh4OJji_X35zW4g.png"/></div></figure><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="fe ff lu"><img src="../Images/ba3413410d025c4662c59e30aedd7ff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*ru8KwJ6DZWXgJm1tm_Sw_Q.png"/></div></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek"><em class="md">See second screenshot for control point views variable names</em></figcaption></figure><p id="877e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">我相信你一定很想尝试一下！</strong></p></div><div class="ab cl lj lk hc ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hn ho hp hq hr"><p id="2799" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">创建一个单一视图应用程序，并将此代码粘贴到类声明内的<strong class="it hv"> ViewController.swift </strong>文件中:</p><pre class="jr js jt ju fq me mf mg mh aw mi dt"><span id="fc7d" class="jy jz hu mf b fv mj mk l ml mm">// MARK: -<br/>// MARK: Vars</span><span id="d5a2" class="jy jz hu mf b fv mn mk l ml mm">private let minimalHeight: CGFloat = 50.0<br/>private let shapeLayer = CAShapeLayer()</span><span id="e7b3" class="jy jz hu mf b fv mn mk l ml mm">// MARK: -</span><span id="82a3" class="jy jz hu mf b fv mn mk l ml mm">override func loadView() {<br/>  super.loadView()<br/>  <br/>  shapeLayer.frame = CGRect(x: 0.0, y: 0.0, width: view.bounds.width, height: minimalHeight)<br/>  shapeLayer.backgroundColor = UIColor(red: 57/255.0, green: 67/255.0, blue: 89/255.0, alpha: 1.0)<br/>  view.layer.addSublayer(shapeLayer)<br/>  <br/>  view.addGestureRecognizer(UIPanGestureRecognizer(target: self, action: "panGestureDidMove:"))<br/>}<br/><br/>// MARK: -<br/>// MARK: Methods<br/><br/>func panGestureDidMove(gesture: UIPanGestureRecognizer) {<br/>  if gesture.state == .Ended || gesture.state == .Failed || gesture.state == .Cancelled {<br/><br/>  } else {<br/>    shapeLayer.frame.size.height = minimalHeight + max(gesture.translationInView(view).y, 0)<br/>  }<br/>}<br/><br/>override func preferredStatusBarStyle() -&gt; UIStatusBarStyle {<br/>  return .LightContent<br/>}</span></pre><p id="0016" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们在这里做的是:</p><ol class=""><li id="6879" class="kt ku hu it b iu iv iy iz jc mo jg mp jk mq jo la lb lc ld dt translated">声明了两个变量:<em class="lt"> shapeLayer </em> —图层，将用于显示贝塞尔路径；<em class="lt">最小高度</em> —定义最小形状层高度；</li><li id="129e" class="kt ku hu it b iu le iy lf jc lg jg lh jk li jo la lb lc ld dt translated">向view.layer添加了形状层；</li><li id="f283" class="kt ku hu it b iu le iy lf jc lg jg lh jk li jo la lb lc ld dt translated">向视图添加了平移手势；</li><li id="0b69" class="kt ku hu it b iu le iy lf jc lg jg lh jk li jo la lb lc ld dt translated">添加了panGestureDidMove方法，当手指移动时将调用该方法。目前，它只改变形状层的高度；</li><li id="9968" class="kt ku hu it b iu le iy lf jc lg jg lh jk li jo la lb lc ld dt translated">重写preferredStatusBarStyle函数，使我们的UI看起来更好。</li></ol><p id="b2c5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">构建您的项目并检查它。它应该这样工作:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/176edbe1bd483efc3ad88498a7f012bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/1*XNtBBQ6VX2vU30VxX-5R6w.gif"/></div></figure><p id="75e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一切都按照我们预期的方式工作，除了一件事——它通过延迟/动画改变高度。它的发生是因为隐含的动画。我们绝对不希望出现这种情况。在将shapeLayer添加到子层之前添加这行代码，以禁用<em class="lt">位置</em>、<em class="lt">边界</em>和<em class="lt">路径</em>的隐式动画:</p><pre class="jr js jt ju fq me mf mg mh aw mi dt"><span id="9371" class="jy jz hu mf b fv mj mk l ml mm">shapeLayer.actions = [“position” : NSNull(), “bounds” : NSNull(), “path” : NSNull()]</span></pre><p id="c8b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">运行project并重试:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/f797341a530794974dddf3b8da0e6486.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/1*lSWR6zbrMJSVDEvqFAaNAQ.gif"/></div></figure><p id="9fb1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">修复！</strong></p><p id="cb35" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下一步是添加我们的控制点视图<em class="lt"> (L3，L2，L1，C，R1，R2，R3，如上所示)</em>并应用所有必要的逻辑。</p><p id="afdb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们一步一步来:</p><ul class=""><li id="4f45" class="kt ku hu it b iu iv iy iz jc mo jg mp jk mq jo mt lb lc ld dt translated">声明<em class="lt"> maxWaveHeight </em>变量:</li></ul><pre class="jr js jt ju fq me mf mg mh aw mi dt"><span id="911b" class="jy jz hu mf b fv mj mk l ml mm">private let maxWaveHeight: CGFloat = 100.0</span></pre><p id="a112" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们定义和使用这个变量的唯一原因是让我们的波形看起来更好。如果我们不指定最大值，它可能会太大，看起来很糟糕。</p><ul class=""><li id="6c75" class="kt ku hu it b iu iv iy iz jc mo jg mp jk mq jo mt lb lc ld dt translated">为我们的控制点视图声明这些变量:</li></ul><pre class="jr js jt ju fq me mf mg mh aw mi dt"><span id="55c1" class="jy jz hu mf b fv mj mk l ml mm">private let l3ControlPointView = UIView()   <br/>private let l2ControlPointView = UIView()   <br/>private let l1ControlPointView = UIView()   <br/>private let cControlPointView = UIView()   <br/>private let r1ControlPointView = UIView()   <br/>private let r2ControlPointView = UIView()   <br/>private let r3ControlPointView = UIView()</span></pre><ul class=""><li id="0edc" class="kt ku hu it b iu iv iy iz jc mo jg mp jk mq jo mt lb lc ld dt translated">应用红色背景色和3x3大小<em class="lt">(我们需要它来查看我们的视图，在教程的最后我们将使它们不可见)</em>并添加到子视图中。将这段代码复制并粘贴到<em class="lt"> loadView </em>方法的末尾:</li></ul><pre class="jr js jt ju fq me mf mg mh aw mi dt"><span id="25c5" class="jy jz hu mf b fv mj mk l ml mm">l3ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)<br/>l2ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)<br/>l1ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)<br/>cControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)<br/>r1ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)<br/>r2ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)<br/>r3ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)<br/><br/>l3ControlPointView.backgroundColor = .redColor()<br/>l2ControlPointView.backgroundColor = .redColor()<br/>l1ControlPointView.backgroundColor = .redColor()<br/>cControlPointView.backgroundColor = .redColor()<br/>r1ControlPointView.backgroundColor = .redColor()<br/>r2ControlPointView.backgroundColor = .redColor()<br/>r3ControlPointView.backgroundColor = .redColor()<br/><br/>view.addSubview(l3ControlPointView)<br/>view.addSubview(l2ControlPointView)<br/>view.addSubview(l1ControlPointView)<br/>view.addSubview(cControlPointView)<br/>view.addSubview(r1ControlPointView)<br/>view.addSubview(r2ControlPointView)<br/>view.addSubview(r3ControlPointView)</span></pre><ul class=""><li id="8fd5" class="kt ku hu it b iu iv iy iz jc mo jg mp jk mq jo mt lb lc ld dt translated">用这段代码创建UIView扩展，并将其放在<em class="lt"> ViewController </em>声明之上:</li></ul><pre class="jr js jt ju fq me mf mg mh aw mi dt"><span id="5704" class="jy jz hu mf b fv mj mk l ml mm">extension UIView {<br/>  func dg_center(usePresentationLayerIfPossible: Bool) -&gt; CGPoint {<br/>    if usePresentationLayerIfPossible, let presentationLayer = layer.presentationLayer() as? CALayer {<br/>      return presentationLayer.position<br/>    }         <br/>    return center     <br/>  } <br/>}</span></pre><p id="091e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当您将UIView从一帧动画到另一帧，并且您试图访问UIView.frame，UIView.center时，它将为您提供最终动画值，而不是当前值。为此，我们创建了一个扩展，当我们请求时，它将给出UIView.layer.presentationLayer的位置。关于presentationLayer的信息可以在这里找到<a class="ae jp" href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CALayer_class/#//apple_ref/occ/instm/CALayer/presentationLayer" rel="noopener ugc nofollow" target="_blank">。</a></p><ul class=""><li id="bab2" class="kt ku hu it b iu iv iy iz jc mo jg mp jk mq jo mt lb lc ld dt translated">声明<em class="lt">当前路径</em>函数:</li></ul><pre class="jr js jt ju fq me mf mg mh aw mi dt"><span id="cb88" class="jy jz hu mf b fv mj mk l ml mm">private func currentPath() -&gt; CGPath {<br/>  let width = view.bounds.width<br/>  let bezierPath = UIBezierPath()<br/><br/>  bezierPath.moveToPoint(CGPoint(x: 0.0, y: 0.0))<br/>  bezierPath.addLineToPoint(CGPoint(x: 0.0, y: l3ControlPointView.dg_center(false).y))<br/>  bezierPath.addCurveToPoint(l1ControlPointView.dg_center(false), controlPoint1: l3ControlPointView.dg_center(false), controlPoint2: l2ControlPointView.dg_center(false))<br/>  bezierPath.addCurveToPoint(r1ControlPointView.dg_center(false), controlPoint1: cControlPointView.dg_center(false), controlPoint2: r1ControlPointView.dg_center(false))<br/>  bezierPath.addCurveToPoint(r3ControlPointView.dg_center(false), controlPoint1: r1ControlPointView.dg_center(false), controlPoint2: r2ControlPointView.dg_center(false))<br/>  bezierPath.addLineToPoint(CGPoint(x: width, y: 0.0))<br/><br/>  bezierPath.closePath()<br/><br/>  return bezierPath.CGPath <br/>}</span></pre><p id="d57c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此函数返回shapeLayer的当前CGPath。它使用我们之前创建和讨论过的控制点。</p><ul class=""><li id="9781" class="kt ku hu it b iu iv iy iz jc mo jg mp jk mq jo mt lb lc ld dt translated">声明<em class="lt"> updateShapeLayer </em>函数:</li></ul><pre class="jr js jt ju fq me mf mg mh aw mi dt"><span id="8835" class="jy jz hu mf b fv mj mk l ml mm">func updateShapeLayer() {<br/>  shapeLayer.path = currentPath()<br/>}</span></pre><p id="8b55" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们需要更新shapeLayer时，就会调用这个函数。它不是一个私有函数，因为我们将为CADisplayLink使用Selector()。</p><ul class=""><li id="8f0b" class="kt ku hu it b iu iv iy iz jc mo jg mp jk mq jo mt lb lc ld dt translated">声明<em class="lt">布局控制点</em>功能:</li></ul><pre class="jr js jt ju fq me mf mg mh aw mi dt"><span id="b3b7" class="jy jz hu mf b fv mj mk l ml mm">private func layoutControlPoints(baseHeight baseHeight: CGFloat, waveHeight: CGFloat, locationX: CGFloat) {<br/>  let width = view.bounds.width<br/>  let minLeftX = min((locationX - width / 2.0) * 0.28, 0.0)<br/>  let maxRightX = max(width + (locationX - width / 2.0) * 0.28, width)<br/><br/>  let leftPartWidth = locationX - minLeftX<br/>  let rightPartWidth = maxRightX - locationX<br/><br/>  l3ControlPointView.center = CGPoint(x: minLeftX, y: baseHeight)<br/>  l2ControlPointView.center = CGPoint(x: minLeftX + leftPartWidth * 0.44, y: baseHeight)<br/>  l1ControlPointView.center = CGPoint(x: minLeftX + leftPartWidth * 0.71, y: baseHeight + waveHeight * 0.64)<br/>  cControlPointView.center = CGPoint(x: locationX , y: baseHeight + waveHeight * 1.36)<br/>  r1ControlPointView.center = CGPoint(x: maxRightX - rightPartWidth * 0.71, y: baseHeight + waveHeight * 0.64)<br/>  r2ControlPointView.center = CGPoint(x: maxRightX - (rightPartWidth * 0.44), y: baseHeight)<br/>  r3ControlPointView.center = CGPoint(x: maxRightX, y: baseHeight)<br/>}</span></pre><p id="2853" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这一部分可能需要解释一下每个变量的含义。给你:</p><ol class=""><li id="4e06" class="kt ku hu it b iu iv iy iz jc mo jg mp jk mq jo la lb lc ld dt translated"><strong class="it hv"> baseHeight </strong> —“底座”的高度。baseHeight + waveHeight =我们的全高；</li><li id="3003" class="kt ku hu it b iu le iy lf jc lg jg lh jk li jo la lb lc ld dt translated"><strong class="it hv">波高</strong> —我们曲线的高度，我们希望它具有我们之前定义的最大值。如果没有最大值，看起来可能会很奇怪。我在玩弄价值观，寻找最合适的；</li><li id="88c1" class="kt ku hu it b iu le iy lf jc lg jg lh jk li jo la lb lc ld dt translated"><strong class="it hv"> locationX </strong> —手指在视图中的X位置<em class="lt">(我们波的顶点)</em>；</li><li id="9623" class="kt ku hu it b iu le iy lf jc lg jg lh jk li jo la lb lc ld dt translated"><strong class="it hv">宽度</strong>——正如你可能理解的，我们视野的宽度；</li><li id="3aa9" class="kt ku hu it b iu le iy lf jc lg jg lh jk li jo la lb lc ld dt translated"><strong class="it hv"> minLeftX </strong> —定义L3控制点视图的最小位置X。这个值可以小于零，所以它在视觉上看起来既漂亮又干净。我在玩价值观，你也可以玩玩；</li><li id="93ec" class="kt ku hu it b iu le iy lf jc lg jg lh jk li jo la lb lc ld dt translated"><strong class="it hv"> maxRightX </strong> —与minLeftX相同，但为r3ControlPointView定义了最大位置X；</li><li id="278c" class="kt ku hu it b iu le iy lf jc lg jg lh jk li jo la lb lc ld dt translated"><strong class="it hv">left part width</strong>-定义minLeftX和locationX之间的距离；</li><li id="286d" class="kt ku hu it b iu le iy lf jc lg jg lh jk li jo la lb lc ld dt translated"><strong class="it hv">right part width</strong>-定义locationX和maxRightX之间的距离。</li></ol><p id="f149" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可能会问为什么我们用这些值以这种方式布置控制点。答案很简单:我使用了PaintCode和bezier路径。在我找到我喜欢的值后，我把它们都放在代码中，并进行更多的操作以找到最合适的值。</p><ul class=""><li id="ae7c" class="kt ku hu it b iu iv iy iz jc mo jg mp jk mq jo mt lb lc ld dt translated">更新我们的<em class="lt"> panGestureDidMove </em>方法，这样当手指移动时所有的控制点都会移动。用以下代码替换所有<em class="lt"> panGestureDidMove </em>函数:</li></ul><pre class="jr js jt ju fq me mf mg mh aw mi dt"><span id="d1de" class="jy jz hu mf b fv mj mk l ml mm">func panGestureDidMove(gesture: UIPanGestureRecognizer) {<br/>  if gesture.state == .Ended || gesture.state == .Failed || gesture.state == .Cancelled {<br/>  } else {<br/>    let additionalHeight = max(gesture.translationInView(view).y, 0)<br/>    let waveHeight = min(additionalHeight * 0.6, maxWaveHeight)<br/>    let baseHeight = minimalHeight + additionalHeight - waveHeight<br/>    let locationX = gesture.locationInView(gesture.view).x<br/><br/>    layoutControlPoints(baseHeight: baseHeight, waveHeight: waveHeight, locationX: locationX)<br/><br/>    updateShapeLayer()<br/>  }<br/>}</span></pre><p id="38e5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们所做的是计算波高，底部高度，手指的位置，并调用我们的函数:layout control指向布局控制点，updateShapeLayer更新我们的形状层路径。</p><ul class=""><li id="7597" class="kt ku hu it b iu iv iy iz jc mo jg mp jk mq jo mt lb lc ld dt translated">将这两行添加到<em class="lt"> loadView </em>函数的末尾，这样当我们打开应用程序时，我们的形状层可以正确显示:</li></ul><pre class="jr js jt ju fq me mf mg mh aw mi dt"><span id="da69" class="jy jz hu mf b fv mj mk l ml mm">layoutControlPoints(baseHeight: minimalHeight, waveHeight: 0.0, locationX: view.bounds.width / 2.0)<br/>updateShapeLayer()</span></pre><ul class=""><li id="6afb" class="kt ku hu it b iu iv iy iz jc mo jg mp jk mq jo mt lb lc ld dt translated">更改此行:</li></ul><pre class="jr js jt ju fq me mf mg mh aw mi dt"><span id="0c63" class="jy jz hu mf b fv mj mk l ml mm">shapeLayer.backgroundColor = UIColor(red: 57/255.0, green: 67/255.0, blue: 89/255.0, alpha: 1.0).CGColor</span></pre><p id="0bff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对此:</p><pre class="jr js jt ju fq me mf mg mh aw mi dt"><span id="12eb" class="jy jz hu mf b fv mj mk l ml mm">shapeLayer.fillColor = UIColor(red: 57/255.0, green: 67/255.0, blue: 89/255.0, alpha: 1.0).CGColor</span></pre><p id="27ec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">运行您的项目并检查它是如何工作的。它应该这样工作:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/519768fbfa591fe5f9b17e20dcc9a412.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/1*8IP7zFTjhgZMO6HSR1GETg.gif"/></div></figure><p id="b978" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">剩下要做的最后一件事是当你释放手指时集成我们的弹跳动画。</p><p id="5a04" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们一步一步来。</p><ul class=""><li id="0953" class="kt ku hu it b iu iv iy iz jc mo jg mp jk mq jo mt lb lc ld dt translated">声明<strong class="it hv">显示链接</strong>变量:</li></ul><pre class="jr js jt ju fq me mf mg mh aw mi dt"><span id="36c2" class="jy jz hu mf b fv mj mk l ml mm">private var displayLink: CADisplayLink!</span></pre><p id="edd4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">并在<em class="lt"> loadView </em>方法结束时对其进行初始化:</p><pre class="jr js jt ju fq me mf mg mh aw mi dt"><span id="ba8d" class="jy jz hu mf b fv mj mk l ml mm">displayLink = CADisplayLink(target: self, selector: Selector("updateShapeLayer"))<br/>displayLink.addToRunLoop(NSRunLoop.mainRunLoop(), forMode: NSDefaultRunLoopMode)<br/>displayLink.paused = true</span></pre><p id="9209" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如开始提到的，我们的CADisplayLink将在每一帧调用所需的函数<em class="lt"> updateShapeLayer </em>，因此我们的ShapeLayer路径在UIView动画期间是最新的。</p><ul class=""><li id="766c" class="kt ku hu it b iu iv iy iz jc mo jg mp jk mq jo mt lb lc ld dt translated">声明<em class="lt">动画</em>变量:</li></ul><pre class="jr js jt ju fq me mf mg mh aw mi dt"><span id="55ec" class="jy jz hu mf b fv mj mk l ml mm">private var animating = false {<br/>  didSet {<br/>    view.userInteractionEnabled = !animating         displayLink.paused = !animating<br/>  }<br/>}</span></pre><p id="1b76" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它将启用/禁用交互，并将暂停/取消暂停显示链接。</p><ul class=""><li id="4919" class="kt ku hu it b iu iv iy iz jc mo jg mp jk mq jo mt lb lc ld dt translated">更新<em class="lt"> currentPath </em>方法，因此使用之前定义的<em class="lt">动画</em>变量调用<em class="lt"> dg_center(Bool) </em>:</li></ul><pre class="jr js jt ju fq me mf mg mh aw mi dt"><span id="2c2e" class="jy jz hu mf b fv mj mk l ml mm">private func currentPath() -&gt; CGPath {  <br/>  let width = view.bounds.width<br/><br/>  let bezierPath = UIBezierPath()<br/><br/>  bezierPath.moveToPoint(CGPoint(x: 0.0, y: 0.0))<br/>  bezierPath.addLineToPoint(CGPoint(x: 0.0, y: l3ControlPointView.dg_center(animating).y))<br/><br/>  bezierPath.addCurveToPoint(l1ControlPointView.dg_center(animating), controlPoint1: l3ControlPointView.dg_center(animating), controlPoint2: l2ControlPointView.dg_center(animating))<br/><br/>  bezierPath.addCurveToPoint(r1ControlPointView.dg_center(animating), controlPoint1: cControlPointView.dg_center(animating), controlPoint2: r1ControlPointView.dg_center(animating))<br/><br/>  bezierPath.addCurveToPoint(r3ControlPointView.dg_center(animating), controlPoint1: r1ControlPointView.dg_center(animating), controlPoint2: r2ControlPointView.dg_center(animating))<br/>  bezierPath.addLineToPoint(CGPoint(x: width, y: 0.0))<br/><br/>  bezierPath.closePath()<br/><br/>  return bezierPath.CGPath<br/>}</span></pre><p id="3e7e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们发送<em class="lt"> true </em>，它将使用<em class="lt"> presentationLayer </em> <em class="lt">(如前所述)</em>的值。</p><ul class=""><li id="a474" class="kt ku hu it b iu iv iy iz jc mo jg mp jk mq jo mt lb lc ld dt translated">最后一步是更新<em class="lt"> panGestureDidMove </em>方法中的语句。将此函数中的所有代码替换为:</li></ul><pre class="jr js jt ju fq me mf mg mh aw mi dt"><span id="38d1" class="jy jz hu mf b fv mj mk l ml mm">if gesture.state == .Ended || gesture.state == .Failed || gesture.state == .Cancelled {  <br/>  let centerY = minimalHeight<br/><br/>  animating = true<br/>  UIView.animateWithDuration(0.9, delay: 0.0, usingSpringWithDamping: 0.57, initialSpringVelocity: 0.0, options: [], animations: { () -&gt; Void in<br/>    self.l3ControlPointView.center.y = centerY<br/>    self.l2ControlPointView.center.y = centerY<br/>    self.l1ControlPointView.center.y = centerY<br/>    self.cControlPointView.center.y = centerY<br/>    self.r1ControlPointView.center.y = centerY<br/>    self.r2ControlPointView.center.y = centerY<br/>    self.r3ControlPointView.center.y = centerY<br/>    }, completion: { _ in<br/>      self.animating = false<br/>  })<br/>} else {<br/>  let additionalHeight = max(gesture.translationInView(view).y, 0)<br/><br/>  let waveHeight = min(additionalHeight * 0.6, maxWaveHeight)<br/>  let baseHeight = minimalHeight + additionalHeight - waveHeight<br/><br/>  let locationX = gesture.locationInView(gesture.view).x<br/><br/>  layoutControlPoints(baseHeight: baseHeight, waveHeight: waveHeight, locationX: locationX)<br/>  updateShapeLayer()<br/>}</span></pre><p id="3cda" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们添加了一个UIView spring动画，让我们的控制点视图以一个非常漂亮的弹跳回到它们原来的位置。用这些价值观来玩一玩，也许你会把动画做得更好！</p><p id="d9aa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在您的设备上构建项目，准备好大吃一惊吧..</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/4a165c4b6b759e139f5a6b64443b47fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/1*i67gfk96fveNB1yQqj9Lcw.gif"/></div></figure><p id="b6ce" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可能不想看到这些点。删除负责在loadView中设置控制点视图backgroundColor和frame的所有代码行。</p><p id="eb55" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">再次运行..</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/ac9148685869fd43deade7a39f09ed88.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/1*jsDkgFaoAtyIljyBukq1Ug.gif"/></div></figure><p id="9058" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它工作得很完美，但是，有一件事我们在本教程中忘记了——我们没有改变shapeLayer的高度，我们只改变了路径。它不是很好，应该被修复。我认为这对你来说是很棒的作业。使用框架、路径和所有其他值:)</p></div><div class="ab cl lj lk hc ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hn ho hp hq hr"><p id="ce72" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我希望你喜欢这个教程。请在下面留下你的评论和建议，让我知道你接下来想看哪个教程！</p><p id="f734" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本教程的源代码可以在<a class="ae jp" href="https://github.com/gontovnik/DGElasticBounceTutorial" rel="noopener ugc nofollow" target="_blank">这里找到</a>T2<strong class="it hv">的源代码可以在<a class="ae jp" href="https://github.com/gontovnik/DGElasticPullToRefresh" rel="noopener ugc nofollow" target="_blank">这里找到</a></strong></p><p id="8df7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">下次见！</strong></p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mv mw l"/></div></figure></div></div>    
</body>
</html>