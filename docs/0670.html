<html>
<head>
<title>Testing Strategies for Docker Containers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">码头集装箱的测试策略</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/testing-strategies-for-docker-containers-f633e261e75a?source=collection_archive---------0-----------------------#2016-03-07">https://medium.com/hackernoon/testing-strategies-for-docker-containers-f633e261e75a?source=collection_archive---------0-----------------------#2016-03-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="04c8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">恭喜你！您知道如何构建一个<a class="ae jp" href="https://hackernoon.com/tagged/docker" rel="noopener ugc nofollow" target="_blank"> Docker </a>映像，并且能够将多个容器组合成一个有意义的<a class="ae jp" href="https://hackernoon.com/tagged/application" rel="noopener ugc nofollow" target="_blank">应用程序</a>。希望您已经创建了一个连续的交付管道，并且知道如何将新创建的映像推入生产或测试环境。</p><p id="f549" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，问题是</p><blockquote class="jq"><p id="623b" class="jr js hu bd jt ju jv jw jx jy jz jo ek translated">我们如何测试Docker容器？</p></blockquote><p id="373a" class="pw-post-body-paragraph ir is hu it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn jo hn dt translated">我们可以应用多种测试策略。在这篇文章中，我将强调它们各自的优点和缺点。</p><h1 id="c909" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">“天真”的方法</h1><p id="209a" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">这是大多数人的默认方法。它依靠CI服务器来完成这项工作。当采用这种方法时，开发人员使用Docker作为包管理器，这是比<strong class="it hv"> jar/rpm/deb </strong>方法更好的选择。CI服务器编译应用程序代码并执行测试(单元、服务、功能等)。构建工件在Docker <strong class="it hv"> build </strong>中被重用以产生新的图像。这成为一个核心部署工件。生成的映像不仅包含应用程序“二进制文件”，还包含所需的运行时，包括所有依赖项和应用程序配置。</p><p id="bae5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们获得了应用程序的可移植性，然而，我们失去了开发和测试的可移植性。我们无法在CI之外复制完全相同的开发和测试环境。为了创建一个新的测试环境，我们将需要设置测试工具(正确的版本和插件)，配置运行时和操作系统设置，并获得相同版本的测试脚本以及测试数据。</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff li"><img src="../Images/f70825d90e1389b0903520eac24ab210.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mJESo7V6r1tlLCmJ.png"/></div></div></figure><p id="1073" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">解决了这些问题，我们就进入下一个问题。</p><h1 id="b7f8" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">应用和测试容器方法</h1><p id="4dbd" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">在这里，我们尝试创建一个包含应用程序“二进制文件”的包，包括必需的包、测试工具(特定版本)、测试工具插件、测试脚本、测试环境以及所有必需的包。</p><p id="3a43" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种方法的<strong class="it hv">优势</strong>:</p><ul class=""><li id="3677" class="lu lv hu it b iu iv iy iz jc lw jg lx jk ly jo lz ma mb mc dt translated">我们有一个可重复的测试环境，在我们的CI、开发、试运行或生产环境中，我们可以使用相同的测试工具运行完全相同的测试</li><li id="9e0d" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo lz ma mb mc dt translated">我们在特定的时间点捕获测试脚本，这样我们就可以在任何环境中重现它们</li><li id="e57d" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo lz ma mb mc dt translated">我们不需要设置和配置我们的测试工具——它们是我们映像的一部分</li></ul><p id="fb9b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种方法有明显的缺点:</p><ul class=""><li id="921d" class="lu lv hu it b iu iv iy iz jc lw jg lx jk ly jo lz ma mb mc dt translated">增加图像大小——因为它包含测试工具、必需的包、测试脚本，甚至可能包含测试数据</li><li id="a72b" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo lz ma mb mc dt translated">用特定于测试的配置污染映像运行时环境，甚至可能引入不必要的依赖(集成测试所需要的)</li><li id="c2dd" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo lz ma mb mc dt translated">我们还需要决定如何处理测试结果和日志；如何以及在哪里出口它们</li></ul><p id="2bfa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里有一个简化的<strong class="it hv"> <em class="mi"> Dockerfile </em> </strong>。它说明了这种方法。</p><figure class="lj lk ll lm fq ln"><div class="bz el l di"><div class="mj mk l"/></div></figure><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff li"><img src="../Images/2fb2770d17470461940b80ba0db072a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*m69Si_dS8cY9v44f.png"/></div></div></figure><p id="1ec7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">容器内测试肯定有更好的方法，而且确实有。</p><h1 id="727c" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">测试感知容器方法</h1><p id="57b9" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">今天，Docker的承诺是</p><blockquote class="jq"><p id="f5a8" class="jr js hu bd jt ju jv jw jx jy jz jo ek translated"><strong class="ak">号建造- &gt;舰- &gt;号运行</strong></p></blockquote><p id="5c03" class="pw-post-body-paragraph ir is hu it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn jo hn dt translated">构建映像，将其发送到某个注册中心，并在任何地方运行它。在我看来，这里缺少了一个关键的步骤——测试。</p><p id="02b7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正确完整的顺序应该是<strong class="it hv"> : </strong></p><blockquote class="jq"><p id="0c72" class="jr js hu bd jt ju jv jw jx jy jz jo ek translated"><strong class="ak">构建- &gt;测试- &gt;发布- &gt;运行</strong></p></blockquote><p id="6e5a" class="pw-post-body-paragraph ir is hu it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn jo hn dt translated">让我们看看一个“测试友好”的Docker文件语法和Docker命令的扩展。这一重要步骤可以得到本地支持。这不是一个真正的语法，但是请原谅我。我将定义“理想”版本，并展示如何实现非常接近的东西。</p><pre class="lj lk ll lm fq ml mm mn mo aw mp dt"><span id="7693" class="mq kg hu mm b fv mr ms l mt mu"><strong class="mm hv">ONTEST</strong> [INSTRUCTION]</span></pre><p id="a588" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们定义一个特殊的<strong class="it hv"> ONTEST </strong>指令，类似于现有的<strong class="it hv"> ONBUILD </strong>指令。<strong class="it hv"> ONTEST </strong>指令向图像添加一个触发指令，在稍后图像测试时执行。任何构建指令都可以注册为触发器。</p><p id="ac68" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">新的<strong class="it hv">对接测试</strong>命令应识别<strong class="it hv"> ONTEST </strong>指令。</p><pre class="lj lk ll lm fq ml mm mn mo aw mp dt"><span id="f17e" class="mq kg hu mm b fv mr ms l mt mu"><strong class="mm hv">docker test</strong> [OPTIONS] IMAGE [COMMAND] [ARG...]</span></pre><p id="d9ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> docker test </strong>命令语法将类似于<strong class="it hv"> docker run </strong>命令，有一个显著的区别:一个新的“可测试”图像将被自动生成，甚至被标记上<strong class="it hv"> <em class="mi"> &lt;图像名称&gt; : &lt;图像标签&gt; -test </em> </strong>标签(“test”后缀被添加到原始图像标签)。该“可测试”映像将从应用映像的中生成<strong class="it hv">，执行所有构建指令，在<strong class="it hv"> ONTEST </strong>命令后定义，并执行<strong class="it hv"> ONTEST CMD </strong>(或<strong class="it hv"> ONTEST ENTRYPOINT </strong>)。如果任何测试失败，docker test命令应该返回一个非零代码。测试结果应该写入自动生成的<strong class="it hv">卷</strong>中，该卷指向<strong class="it hv"><em class="mi">/var/tests/results</em></strong>文件夹。</strong></p><p id="66e3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们来看看下面一个修改过的docker文件——它包含了新提出的<strong class="it hv"> ONTEST </strong>指令。</p><figure class="lj lk ll lm fq ln"><div class="bz el l di"><div class="mj mk l"/></div></figure><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff li"><img src="../Images/411ced33710cbd9324db3e4ccebd7ad5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lA5gp0Asgt8eG35c.png"/></div></div></figure><h1 id="48fe" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">让“测试感知容器”成为现实</h1><p id="01c7" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">我们认为Docker应该让<strong class="it hv"> docker-test </strong>成为容器管理生命周期的一部分。现在需要一个简单的工作解决方案，我将描述一个非常接近理想状态的解决方案。</p><p id="63a2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如前所述，Docker有一个非常有用的<strong class="it hv"> ONBUILD </strong>指令。这条指令允许我们在后续构建中触发另一条构建指令。基本思想是在运行d <strong class="it hv"> ocker-test </strong>命令时使用<strong class="it hv"> ONBUILD </strong>指令。</p><p id="5b31" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由<strong class="it hv"> docker-test </strong>命令执行的流程:</p><ol class=""><li id="c54b" class="lu lv hu it b iu iv iy iz jc lw jg lx jk ly jo mv ma mb mc dt translated"><strong class="it hv"> docker-test </strong>将在应用Dockerfile中搜索<strong class="it hv"> ONBUILD </strong>指令，并将…</li><li id="04bf" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo mv ma mb mc dt translated">从原来的<strong class="it hv"> <em class="mi"> Dockerfile </em> </strong>生成临时的<strong class="it hv"> <em class="mi"> Dockerfile.test </em> </strong></li><li id="84b2" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo mv ma mb mc dt translated">执行<strong class="it hv">docker build-f docker file . test[OPTIONS]PATH</strong>和<strong class="it hv"> docker build </strong>命令支持的附加选项:<strong class="it hv"> -test </strong>将自动追加到<strong class="it hv">标签</strong>选项</li><li id="5d2f" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo mv ma mb mc dt translated">如果构建成功，执行<strong class="it hv">docker run-v ./tests/results:/var/tests/results[OPTIONS]IMAGE:TAG-test[COMMAND][ARG…]</strong></li><li id="6fe7" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo mv ma mb mc dt translated">移除<strong class="it hv">文件<em class="mi">文件</em>文件</strong>文件</li></ol><p id="852a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为什么不创建一个新的<strong class="it hv"><em class="mi">docker file . test</em></strong>而不需要<strong class="it hv"> ONBUILD </strong>指令呢？</p><p id="4d91" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为为了测试正确的图像(和标签),我们需要保持<strong class="it hv">从</strong>一直更新到<strong class="it hv">图像:标签</strong>,我们想要测试。这可不是小事。</p><p id="8177" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所描述的方法有一个限制——它不适合“onbuild”映像(用于自动构建应用程序的映像),比如<a class="ae jp" href="https://hub.docker.com/_/maven/" rel="noopener ugc nofollow" target="_blank"> Maven:onbuild </a></p><p id="074d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们看一下<strong class="it hv"> docker-test </strong>命令的简单实现。它强调了这个概念:<strong class="it hv"> docker-test </strong>命令应该能够处理构建和运行命令选项，并且能够正确处理错误。</p><figure class="lj lk ll lm fq ln"><div class="bz el l di"><div class="mj mk l"/></div></figure><p id="81f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们把重点放在最有趣和最相关的部分。</p><h1 id="35e0" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">集成测试容器—测试策略</h1><p id="2fdf" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">假设我们有一个由数十或数百个微服务构建的应用程序。假设我们有一个自动化CI/CD管道，其中每个微服务都由我们的CI构建和测试，并在构建和测试通过后部署到某个环境(测试、试运行或生产)中。很酷，是吧？我们的CI测试能够独立测试每个微服务——运行单元和服务测试(或API契约测试)。甚至可能是微集成测试——在子系统上运行的测试是以特别的方式创建的(例如使用<strong class="it hv"> docker compose </strong> help)。</p><p id="5de9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这导致了一些我们需要解决的问题:</p><ul class=""><li id="6e1c" class="lu lv hu it b iu iv iy iz jc lw jg lx jk ly jo lz ma mb mc dt translated">真正的集成测试或者长时间运行的测试(比如性能和压力)怎么样？</li><li id="1d1b" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo lz ma mb mc dt translated">弹性测试怎么样(“混沌猴”一样的测试)？</li><li id="a53f" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo lz ma mb mc dt translated">安全扫描？</li><li id="4fd5" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo lz ma mb mc dt translated">需要时间并且应该在完全可操作的系统上运行的测试和扫描活动怎么办？</li></ul><p id="70a8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">应该有更好的方法，而不是仅仅将新的微服务版本投入生产并严密监控一段时间。</p><p id="048d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">应该有专门的<strong class="it hv">集成测试容器</strong>。这些容器将只包含测试工具和测试工件:测试脚本、测试数据、测试环境配置等。为了简化这种容器的编排和自动化，我们应该定义并遵循一些约定，并使用元数据标签(Dockerfile <strong class="it hv"> LABEL </strong>指令)。</p><h2 id="f734" class="mq kg hu bd kh mw mx my kl mz na nb kp jc nc nd kt jg ne nf kx jk ng nh lb ni dt translated">集成测试标签</h2><ul class=""><li id="eaec" class="lu lv hu it b iu ld iy le jc nj jg nk jk nl jo lz ma mb mc dt translated"><strong class="it hv">测试类型</strong> —测试类型；默认集成；可以是其中之一:<strong class="it hv"><em class="mi"/></strong>，<strong class="it hv"> <em class="mi">性能</em> </strong>，<strong class="it hv"> <em class="mi">安全</em> </strong>，<strong class="it hv"> <em class="mi">混乱</em> </strong>或任何文本；该标签的出现表明这是<strong class="it hv">集成测试容器</strong></li><li id="24b4" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo lz ma mb mc dt translated"><strong class="it hv">测试结果</strong> —测试结果卷；默认<strong class="it hv"><em class="mi">/var/测试/结果</em> </strong></li><li id="109c" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo lz ma mb mc dt translated"><strong class="it hv">测试。XXX </strong> —任何其他与测试相关的元数据；使用<strong class="it hv">测试即可。</strong>标签名称的前缀</li></ul><h2 id="45a7" class="mq kg hu bd kh mw mx my kl mz na nb kp jc nc nd kt jg ne nf kx jk ng nh lb ni dt translated">集成测试容器</h2><p id="bb28" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated"><strong class="it hv">集成测试容器</strong>只是一个普通的Docker容器。它不包含任何应用程序逻辑和代码。它的唯一目的是创建可重复和可移植的测试。<strong class="it hv">集成测试容器</strong>的推荐内容:</p><ul class=""><li id="63ce" class="lu lv hu it b iu iv iy iz jc lw jg lx jk ly jo lz ma mb mc dt translated"><em class="mi">测试工具</em> — Phantom.js，Selenium，Chakram，Gatling，…</li><li id="5e58" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo lz ma mb mc dt translated"><em class="mi">测试工具运行时</em> — Node.js，JVM，Python，Ruby，…</li><li id="282f" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo lz ma mb mc dt translated"><em class="mi">测试环境配置</em> —环境变量、配置文件、引导脚本等</li><li id="b38f" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo lz ma mb mc dt translated"><em class="mi">测试</em> —作为编译的包或脚本文件</li><li id="ae33" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo lz ma mb mc dt translated"><em class="mi">测试数据</em> —测试使用的任何类型的数据文件:json、csv、txt、xml、…</li><li id="6c07" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo lz ma mb mc dt translated"><em class="mi">测试启动脚本</em> —运行测试的一些“主”启动脚本；只需创建test.sh并从中启动您的测试工具。</li></ul><p id="29f2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">集成测试容器</strong>应该在部署了所有微服务的操作环境中运行:测试、试运行或生产。这些容器可以像所有其他服务一样进行部署。它们使用相同的网络层，因此可以访问多种服务；使用选定的服务发现方法(通常是DNS)。真正的集成测试需要访问多个服务——我们需要模拟和验证我们的系统如何在多个地方工作。将集成测试放在某个应用服务容器中不仅会增加容器的占用空间，还会在多个服务之间产生不必要的依赖。我们将所有这些依赖保持在<strong class="it hv">集成测试容器</strong>的级别。一旦我们的测试(和测试工具)被打包到容器中，我们总是可以在任何环境中重新运行相同的测试，包括开发人员的机器。您可以随时回到过去，重新运行特定版本的<strong class="it hv">集成测试容器</strong>。</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff nm"><img src="../Images/6c1706dffb24be50c784ea69e33ac957.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Qtrr_WhX8naTEZUl.png"/></div></div></figure><p id="ae87" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">WDYT？非常感谢您的反馈，尤其是关于标准化<strong class="it hv"> docker-test </strong>命令的反馈。</p></div><div class="ab cl nn no hc np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="hn ho hp hq hr"><p id="a808" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="mi">视频和幻灯片可在Codefresh </em> <a class="ae jp" href="https://codefresh.io/docker-tutorial/testing-strategies-for-docker/" rel="noopener ugc nofollow" target="_blank"> <em class="mi">网站</em> </a>获得</p><div class="lj lk ll lm fq ab cb"><figure class="nu ln nv nw nx ny nz paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nu ln nv nw nx ny nz paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nu ln nv nw nx ny nz paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="oa ob oc"><p id="f922" class="ir is mi it b iu iv iw ix iy iz ja jb od jd je jf oe jh ji jj of jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是阿妹家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>的机会。</p><p id="708a" class="ir is mi it b iu iv iw ix iy iz ja jb od jd je jf oe jh ji jj of jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lj lk ll lm fq ln fe ff paragraph-image"><a href="https://goo.gl/Ahtev1"><div class="fe ff og"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></a></figure><figure class="lj lk ll lm fq ln"><div class="bz el l di"><div class="oh mk l"/></div></figure></div></div>    
</body>
</html>