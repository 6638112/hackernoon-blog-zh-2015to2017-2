<html>
<head>
<title>A/B Testing Our Way to a Better Payment Gateway</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">A/B测试我们通往更好的支付网关的道路</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-b-testing-our-way-to-a-better-payment-gateway-d291b86dd74b?source=collection_archive---------14-----------------------#2017-03-13">https://medium.com/hackernoon/a-b-testing-our-way-to-a-better-payment-gateway-d291b86dd74b?source=collection_archive---------14-----------------------#2017-03-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="dd56" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">想象一下，由于各种业务用例，您必须重写现有的web服务，以迁移到新的支付网关(PSP或支付服务提供商)。你的第一个想法可能是用新的完全取代旧的，然后推出新的。这是一种幼稚的方法，尤其是当您使用支付网关时，这些网关有自己的SLA、与收单银行的协议、风险和欺诈检测软件等。这使得这一过程在转化率、收入、客户保持和最终业务方面风险更大。在这篇博客文章中，我们讨论了在转换支付网关时降低风险的方法，以及为什么它如此重要。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/515742446fa2fc44d4bd0910a658ead4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iSNwhmq9jnitBxF8YqY3JA.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">dubizzle Checkout Page</figcaption></figure><h2 id="a2c3" class="kg kh hu bd ki kj kk kl km kn ko kp kq jc kr ks kt jg ku kv kw jk kx ky kz la dt translated">这一切都始于我们过去的支付服务…</h2><p id="2e5e" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">我们旧的支付服务是用Python 2编写的，与旧的支付网关(支付服务提供商)高度耦合。当我们第一次剖析这个问题时，我们认为在相同的流量、URL和<a class="ae lg" href="https://bottlepy.org/docs/dev/" rel="noopener ugc nofollow" target="_blank"> Python瓶</a>视图中集成一个全新的支付网关是微不足道的。当我们开始着手第一个POC时，我们意识到我们已经生成了大量的意大利面条式代码，因为这两个支付网关的API流完全不同。虽然旧的支付网关API设计不得不严重依赖<a class="ae lg" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>和<a class="ae lg" href="http://www.gevent.org/" rel="noopener ugc nofollow" target="_blank"> Gevent </a>来优化用户和支付流程，但绝对没有理由从新的API中重新引入这种依赖性。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff lh"><img src="../Images/4a6e2c7cde644a04d54a1d74888f3e81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*OJ1w1q9xdNz16rSEChZLew.gif"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Payment Service Integrated with Old Payment Gateway</figcaption></figure><blockquote class="li lj lk"><p id="705b" class="ir is jp it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><strong class="it hv">只要简单，A/B测试就是好的</strong></p><p id="2f68" class="ir is jp it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated">A/B测试在做出产品决策时非常有力。在OLX dubizzle公司，这些测试传统上更倾向于面向用户的组件，如页面流量、页面组件、位置和产品。</p><p id="4943" class="ir is jp it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated">然而，当您想要测试高度相互依赖的底层系统时，这些测试会使事情变得复杂。</p></blockquote><p id="9042" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们还在进行POC时，我们意识到我们想要执行的A/B测试不应该使用诸如<a class="ae lg" href="https://www.optimizely.com/" rel="noopener ugc nofollow" target="_blank">优化</a>之类的工具来完成，即使我们设法在相同的视图和用户流中集成了新的网关。原因如下:</p><ul class=""><li id="96b6" class="lo lp hu it b iu iv iy iz jc lq jg lr jk ls jo lt lu lv lw dt translated">在支付服务上引入第三方托管的JavaScript可能会捕获信用卡的详细信息，这是一个巨大的安全风险。</li><li id="7238" class="lo lp hu it b iu lx iy ly jc lz jg ma jk mb jo lt lu lv lw dt translated">走优化路线将要求我们在web服务的每个视图上实现一些A/B测试逻辑，以确保我们基于cookie将跨所有视图的交易请求定向到正确的支付网关。在每个视图中，这可能类似于以下内容，并且肯定不整洁:</li></ul><pre class="jr js jt ju fq mc md me mf aw mg dt"><span id="b039" class="kg kh hu md b fv mh mi l mj mk">if cookie == ‘OLD’:<br/>  use old payment gateway API<br/>else:  <br/>  use new payment gateway API</span></pre><ul class=""><li id="b776" class="lo lp hu it b iu iv iy iz jc lq jg lr jk ls jo lt lu lv lw dt translated">调试两个不同的支付网关，使用相同的名称空间，如Redis，UUID生成和日志肯定会火回来，我们会在任何时候抓我们的头。</li></ul><blockquote class="li lj lk"><p id="350d" class="ir is jp it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated">请注意，一旦用户进入bucket A (web服务与旧的支付网关对话)，该web服务需要确保该用户的支付流在最初启动时所在的支付网关上继续。例如，web服务不应该在旧的支付网关上启动交易，而尝试在新的支付网关上完成交易。这个问题可以使用Optimizely和HAProxy都支持的粘性会话来解决。</p></blockquote><h2 id="2af8" class="kg kh hu bd ki kj kk kl km kn ko kp kq jc kr ks kt jg ku kv kw jk kx ky kz la dt translated">两种支付服务的故事…</h2><p id="ed98" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">一旦我们对我们试图处理的问题有了一些想法，我们决定编写一个与新网关集成的新支付服务，并通过50-50分割A/B测试来比较性能。整个A/B测试必须至少满足以下要求:</p><ul class=""><li id="a628" class="lo lp hu it b iu iv iy iz jc lq jg lr jk ls jo lt lu lv lw dt translated">新服务的卡详细信息页面的外观和感觉应该与旧服务完全匹配，以确保我们不会扭曲任何转换。在这种情况下，转换被视为卡“提交”事件。</li><li id="1526" class="lo lp hu it b iu lx iy ly jc lz jg ma jk mb jo lt lu lv lw dt translated">与旧服务相比，任何内部后端任务或API调用都不能增加新服务中的事务失败率。这意味着大多数用户流本质上应该以与旧的相同的方式工作。</li></ul><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff ml"><img src="../Images/375b75662c7e35d2291bc1fc81cf1f3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*_6Nd65IHQxu9s8dPgM6u9w.gif"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Payment Service Integrated with New Payment Gateway</figcaption></figure><h2 id="9e96" class="kg kh hu bd ki kj kk kl km kn ko kp kq jc kr ks kt jg ku kv kw jk kx ky kz la dt translated">通过HAProxy进行的A/B测试</h2><p id="e7be" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">由于Optimizely不在考虑范围内，我们决定利用HAProxy来运行测试。</p><p id="c98b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">HAProxy是一个强大的第4层和第7层负载均衡器，具有广泛的功能。其中一个特性是它能够在后端支持基于cookie的持久性，这发生在第7层。</p><p id="39ec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将HAProxy配置为具有三个后端:</p><ul class=""><li id="9af4" class="lo lp hu it b iu iv iy iz jc lq jg lr jk ls jo lt lu lv lw dt translated">主后端</li><li id="8a40" class="lo lp hu it b iu lx iy ly jc lz jg ma jk mb jo lt lu lv lw dt translated">旧服务后端</li><li id="f37f" class="lo lp hu it b iu lx iy ly jc lz jg ma jk mb jo lt lu lv lw dt translated">新服务后端</li></ul><p id="5c6c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了让您体验一下，下面是我们HAProxy后端的一个示例:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="0d00" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可能会想为什么我们有静态后端？一旦我们来到HAProxy <code class="eh mo mp mq md b">frontend</code>这就变得很清楚了，所以让我们先讨论一下<code class="eh mo mp mq md b">main</code>后端。</p><p id="9a3d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们采用加权循环法来平衡<code class="eh mo mp mq md b">old-service-old-pg</code>和<code class="eh mo mp mq md b">new-service-new-pg</code>之间的负载请求。这对于A/B测试来说是有意义的，在A/B测试中，您只需将流量分成A和B两个存储桶，但需要注意的是，在会话持续期间，任何到达存储桶A的请求都不应到达存储桶B。我们通过非常强大的T2指令巧妙地实现了这一点。假设任何发起事务的用户都将在2小时内完成事务，我们告诉HAProxy在2小时后丢弃一个会话cookie，并根据round robin为该请求决定的内容生成一个新的cookie。</p><p id="4699" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这为我们解决了两个非常重要的使用案例:</p><ul class=""><li id="ab91" class="lo lp hu it b iu iv iy iz jc lq jg lr jk ls jo lt lu lv lw dt translated">让我们能够灵活地调整A/B测试权重，在2小时内传播给所有用户，而不会中断任何会话或用户流。</li><li id="d81f" class="lo lp hu it b iu lx iy ly jc lz jg ma jk mb jo lt lu lv lw dt translated">增加了用户在A/B测试的生命周期内尝试在两个服务上进行交易的概率。这有助于我们识别问题，即一个网关拒绝另一个网关接受的同一张信用卡。我们真的很惊讶地看到，在涉及跨大洲的多个级联系统的更大环境中，事情会如何发展！</li></ul><p id="e7fd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的设置中有一个小漏洞，你可能还没有注意到。请考虑下图:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/ebb637efe0f290af8bb54cf017bd3eba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*cROooa2vxHqu7v6zfBPXWQ.jpeg"/></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Payment Flow Through HAProxy</figcaption></figure><p id="2ade" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">用户在收到cookie后的第45分钟开始在旧的支付服务上进行交易。然后，他在1小时59分进入银行的<a class="ae lg" href="https://en.wikipedia.org/wiki/3-D_Secure" rel="noopener ugc nofollow" target="_blank">三维安全</a>页面，并在2小时标记后被重定向回我们的成功url。由于HAProxy配置了2小时的cookie <code class="eh mo mp mq md b">maxlife</code>，它将丢弃会话cookie，并尝试在重定向到成功url时插入一个新的cookie。如果我们运气不好，round robin可能会将新的会话绑定到新的支付服务，而新的支付服务不知道如何处理旧服务配置的成功重定向。</p><p id="2fe2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们的例子中，我们选择忽略这个问题，因为我们之前已经看到，发起事务的用户通常会在两个小时内完成事务。但是，举例来说，如果我们将cookie <code class="eh mo mp mq md b">maxlife</code>设置为1分钟，你能想象这个问题的严重性吗？</p><p id="ddcc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们回到我们的讨论，为什么我们有<code class="eh mo mp mq md b">old_service</code>和<code class="eh mo mp mq md b">new_service</code>后端以及<code class="eh mo mp mq md b">main</code>。HAProxy通常配置有一个处理所有ACL(访问控制列表)的<code class="eh mo mp mq md b">frontend</code>代理，在我们的例子中是这样配置的:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="62d8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您在配置中看到的这些webhooks和端点是处理来自外部网关的请求的特定视图。由于新旧服务无法与彼此的支付网关对话，将它们置于循环负载均衡器之下将意味着多达100%的请求使用400或404。此外，由于这些请求来自支付网关，因此不需要任何类型的持久性，因为这些请求不包含跨越不同视图的流(所有请求都是一触即发的200)。</p><p id="b1bb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">解决这个问题的最好方法是在负载均衡器上，我们通过定义ACL来控制通过<code class="eh mo mp mq md b">old_service</code>和<code class="eh mo mp mq md b">new_service</code>静态后端到适当应用服务器的请求流。简而言之，这将是<em class="jp">支付网关发起的请求</em>和HAProxy之间的常规对话，最终将到达适当的应用服务器:</p><p id="1d28" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">支付网关:嘿，我是来自旧支付网关的内部请求，我需要告诉你，我已经成功收到付款。</em></p><p id="b9d1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">嘿，我认得你！您应通过 <code class="eh mo mp mq md b"><em class="jp">old_service</em></code> <em class="jp">门到达您申请的目的地。</em></p><p id="f9d2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">目的地申请:嘿，我知道怎么处理你了！让我们为该用户激活订单。我会给你200这个数字作为回报！</em></p><h2 id="7866" class="kg kh hu bd ki kj kk kl km kn ko kp kq jc kr ks kt jg ku kv kw jk kx ky kz la dt translated">监控请求流</h2><p id="7cff" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">在所有条件都具备的情况下，您将如何测试如此复杂的A/B测试？</p><p id="4754" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">HAProxy为您提供非常精确的日志来调试如此复杂的系统。让我们通过实际的A/B测试日志中的一些例子来理解这一点。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="f930" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意针对同一订单id的每个请求的标志<code class="eh mo mp mq md b">NI</code>、<code class="eh mo mp mq md b">VU</code>和<code class="eh mo mp mq md b">VN</code>。这些标志提供了大量关于客户端、服务器和HAProxy如何处理持久性的信息，是测试和调试时最重要的指标之一。</p><p id="5c71" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在此引用HAProxy <a class="ae lg" href="http://cbonte.github.io/haproxy-dconv/1.6/configuration.html#8.5" rel="noopener ugc nofollow" target="_blank">文档</a><strong class="it hv">:</strong></p><p id="427d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">—</strong><em class="jp">暂留cookie未启用。</em> <strong class="it hv">这是请求路径为</strong> <code class="eh mo mp mq md b">webhook-new</code> <strong class="it hv">并且将其置于A/B测试下没有意义的情况。</strong></p><p id="9d50" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> NI : </strong> <em class="jp">客户端没有提供cookie，在<br/>响应中插入了一个。这通常发生在“插入”模式下来自每个用户<br/>的第一个请求，这使得统计真实用户变得容易。</em> <strong class="it hv">这是循环法为用户决定测试桶的地方。</strong></p><p id="7ab4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> VU : </strong> <em class="jp">客户端提供了一个cookie，其上次访问日期<br/>不是完全最新的，因此在<br/>响应中提供了一个更新的cookie。如果根本没有日期，或者如果<br/>有日期但没有设置“maxidle”参数，也可能发生这种情况，因此<br/> cookie可以切换到无限时间。</em></p><p id="6594" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> VN : </strong> <em class="jp">客户端提供了一个cookie，在<br/>响应中没有插入任何cookie。对于客户端已经获得cookie的大多数响应，都会发生这种情况。</em> <strong class="it hv">这就是HAProxy如何为用户找到当前的桶，并引导他到正确的后端。</strong></p><p id="4092" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意，一旦HAProxy决定了服务器<code class="eh mo mp mq md b">new-service-new-pg</code>并设置了cookie，来自该用户的所有后续请求都通过<code class="eh mo mp mq md b">main</code>后端被定向到<code class="eh mo mp mq md b">new-service-new-pg</code>。</p><p id="ad76" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于匹配其中一个ACL的其他所有东西，HAProxy直接请求而不设置任何cookie。这也确保了A/B测试结果不会被来自计算机而不是人类的HTTP调用所歪曲。</p><h2 id="9eb8" class="kg kh hu bd ki kj kk kl km kn ko kp kq jc kr ks kt jg ku kv kw jk kx ky kz la dt translated">A/B测试的架构布局</h2><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff ms"><img src="../Images/0af816194f6cece94e9fe08c827bc237.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NikFr3ElRXQVL7YZGyVLiQ.jpeg"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Architecture Layout For The A/B Test</figcaption></figure><p id="c3b0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，DNS和边缘层在我们所有的微服务中都是通用的。所有的A/B测试奇迹都发生在流量通过HAProxy负载平衡器之后。</p><h2 id="9422" class="kg kh hu bd ki kj kk kl km kn ko kp kq jc kr ks kt jg ku kv kw jk kx ky kz la dt translated">结论</h2><p id="979d" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">虽然这对我们来说已经很完美了，但是还有更复杂的负载平衡用例，它们可能需要比会话持久性更多的参数。Shopify通过利用Nginx和OpenResty在一篇出色的博客文章<a class="ae lg" href="https://engineering.shopify.com/232808527-surviving-flashes-of-high-write-traffic-using-scriptable-load-balancers-part-i" rel="noopener ugc nofollow" target="_blank">中谈到了这一点。</a></p><p id="fff3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个A/B测试是整个dubizzle基础设施团队和产品工程团队的主要工作。感谢所有参与的人！</p></div><div class="ab cl mt mu hc mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="hn ho hp hq hr"><p id="fb77" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">希望你喜欢这篇文章。请随意添加评论或提问。你也可以通过我的推特账号联系我:<a class="ae lg" href="https://twitter.com/mrafayaleem" rel="noopener ugc nofollow" target="_blank"> mrafayaleem </a></p><p id="9a29" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="jp"> PS: </em> </strong> <em class="jp">本帖也发表在</em> <a class="ae lg" href="http://blog.dubizzle.com/boilerroom/2017/03/07/changed-payment-service-provider-ab-test-via-haproxy/" rel="noopener ugc nofollow" target="_blank"> <em class="jp"> dubizzle工程博客</em> </a> <em class="jp">上。</em></p><div class="jr js jt ju fq ab cb"><figure class="na jv nb nc nd ne nf paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="na jv nb nc nd ne nf paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="na jv nb nc nd ne nf paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="li lj lk"><p id="f922" class="ir is jp it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated"><a class="ae lg" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae lg" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae lg" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae lg" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is jp it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lg" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lg" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff ng"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>