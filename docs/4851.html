<html>
<head>
<title>Organizing React Props</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">组织反应道具</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/organizing-react-props-e916e3c579a4?source=collection_archive---------8-----------------------#2017-06-26">https://medium.com/hackernoon/organizing-react-props-e916e3c579a4?source=collection_archive---------8-----------------------#2017-06-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="1a87" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">随着<a class="ae jp" href="https://hackernoon.com/tagged/codebase" rel="noopener ugc nofollow" target="_blank">代码库</a>中组件数量的增长，道具的数量也在增长，拥有一个将道具从“容器”传递到“哑组件”的良好模式变得非常重要。我想介绍一下传递道具通常是如何开始的，以及一些改善体验的模式。</p><p id="afd3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">作为一个例子，我将使用一个todo应用程序，其功能在这篇文章中的<a class="ae jp" rel="noopener" href="/@scott.lively/a-react-journey-9f8c885cfbce">中列出，但是我们将把这个应用程序分成多个组件。我还假设所有的数据和处理程序都通过使用</a><a class="ae jp" href="https://hackernoon.com/tagged/redux" rel="noopener ugc nofollow" target="_blank"> redux </a>、recompose、RxJS等作为道具传递给TodosListPage容器</p></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><h1 id="d62d" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">开始时，我们通过了道具，这很好</h1><p id="096c" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">一般来说，我们从一个装有所有道具的容器开始，然后把它们传给孩子们。这些孩子可能会将这些道具传递给他们的孩子，等等。这里的一个大问题是，如果我们需要向TodosListPage的任何子节点添加一个新道具，我们需要将它添加到每个组件，直到到达需要该道具的节点。如果这是一个深度嵌套的组件，那么以任何方式重构道具都将成为一大痛苦。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="2766" class="lj jy hu lf b fv lk ll l lm ln">class TodosListPage extends Component {</span><span id="d13b" class="lj jy hu lf b fv lo ll l lm ln">propTypes = {<br/>  todos: PropTypes.array.isRequired, <br/>  newTodoText: PropTypes.string.isRequired,<br/>  filterText: PropTypes.string.isRequired,<br/>  fetchTodos: PropTypes.func.isRequired, <br/>  addTodo: PropTypes.func.isRequired, <br/>  setNewTodoText: PropTypes.func.isRequired, <br/>  setFilterText: PropTypes.func.isRequired<br/> };<br/><br/> render() {<br/>  const { <br/>   todos, <br/>   newTodoText, <br/>   addTodo, <br/>   filterText, <br/>   setFilterText <br/>  } = this.props;<br/><br/>  return (<br/>   &lt;div&gt;<br/>    &lt;AddTodoForm newTodoText={newTodoText} addTodo={addTodo}/&gt;<br/>    &lt;TodosFilter filterText={filterText} <br/>                    setFilterText={setFilterText}/&gt;<br/>    &lt;TodoList todos={todos}<br/>   &lt;/div&gt;<br/>  );<br/> }<br/><br/> componentDidMount() {<br/>  this.props.fetchTodos();<br/> }<br/>}</span></pre></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><h1 id="dc19" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">然后我们的道具成型了，更好了</h1><p id="adc5" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">现在，我们将传递代表容器子项道具的对象，而不是将每个道具传递给容器。这意味着只需要在两个地方改变道具，一个是创建传入道具的对象(redux、reselect、RxJS等)，另一个是接收组件。任何传递组件现在都只是简单地将道具传递给孩子们，而不关心道具包里是什么。它还有一个很大的副作用，可以帮助你快速了解哪些道具只被你正在查看的组件使用。来自PropTypes.shape的警告也更准确地描述了道具类型警告来自何处。转向这种模式对我来说是一个巨大的胜利。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="764e" class="lj jy hu lf b fv lk ll l lm ln">class TodosListPage extends Component {</span><span id="2970" class="lj jy hu lf b fv lo ll l lm ln"> propTypes = {<br/>  fetchTodos: PropTypes.func.isRequired,  <br/>  addTodoForm: PropTypes.shape(AddTodoForm.propTypes).isRequired,<br/>  todosFilter: PropTypes.shape(TodosFilter.propTypes).isRequired,<br/>  todosList: PropTypes.shape(TodoList.propTypes).isRequired<br/> };</span><span id="f2fb" class="lj jy hu lf b fv lo ll l lm ln"> render() {<br/>  const { addTodoForm, todosList, todosFilter } = this.props;</span><span id="58fd" class="lj jy hu lf b fv lo ll l lm ln"> return (<br/>   &lt;div&gt;<br/>    &lt;AddTodoForm {...addTodoForm}/&gt;<br/>    &lt;TodosFilter {...todosFilter}/&gt;<br/>    &lt;TodoList {...todosList}/&gt;<br/>   &lt;/div&gt;<br/>  );<br/> }</span><span id="9692" class="lj jy hu lf b fv lo ll l lm ln"> componentDidMount() {<br/>  this.props.fetchTodos();<br/> }<br/>}</span></pre></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><h1 id="fcc8" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated"><a class="ae jp" href="https://en.wikipedia.org/wiki/Dr._Strangelove" rel="noopener ugc nofollow" target="_blank">我是如何学会不再担心并爱上这个容器的</a></h1><p id="5a26" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">最后，随着我开始使用PropTypes.shape，越来越清楚的是，每个使用实例可能代表一个应该只是容器的组件。根据我的经验，这可能有点难以管理。您希望确保不要做得太过，这需要在React之外如何存储和处理状态的原则。如果不确定，我宁愿选择只有一个容器，但是在上面的例子中，将每个组件连接到商店(从而创建一个容器)可能是合理的。我认为这种方法如果做得正确是理想的。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="21d6" class="lj jy hu lf b fv lk ll l lm ln">class TodosListPage extends Component {</span><span id="6544" class="lj jy hu lf b fv lo ll l lm ln"> propTypes = {<br/>  fetchTodos: PropTypes.func.isRequired<br/> };</span><span id="d9bc" class="lj jy hu lf b fv lo ll l lm ln"> render() {<br/>  return (<br/>   &lt;div&gt;<br/>    &lt;AddTodoForm/&gt;<br/>    &lt;TodosFilter/&gt;<br/>    &lt;TodoList/&gt;<br/>   &lt;/div&gt;<br/>  );<br/> }</span><span id="10eb" class="lj jy hu lf b fv lo ll l lm ln">componentDidMount() {<br/>  this.props.fetchTodos();<br/> }<br/>}</span></pre></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><p id="ffd3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我强烈建议尽快放弃第一种方法。它解决了许多令人头痛的问题，帮助您看到UI中出现的组件和模式，同时也使重构变得更加容易。</p><blockquote class="lp lq lr"><p id="7856" class="ir is ls it b iu iv iw ix iy iz ja jb lt jd je jf lu jh ji jj lv jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is ls it b iu iv iw ix iy iz ja jb lt jd je jf lu jh ji jj lv jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is ls it b iu iv iw ix iy iz ja jb lt jd je jf lu jh ji jj lv jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="la lb lc ld fq lw"><div class="bz el l di"><div class="lx ly l"/></div></figure></div></div>    
</body>
</html>