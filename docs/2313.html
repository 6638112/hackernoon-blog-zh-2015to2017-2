<html>
<head>
<title>Is C#7 starting to look like a functional language?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#7开始看起来像函数式语言了吗？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/is-c-7-starting-to-look-like-a-functional-language-d4326b427aaa?source=collection_archive---------1-----------------------#2017-01-19">https://medium.com/hackernoon/is-c-7-starting-to-look-like-a-functional-language-d4326b427aaa?source=collection_archive---------1-----------------------#2017-01-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="d18a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">本文摘自《C# </em> 中的 <a class="ae jq" href="https://www.manning.com/books/functional-programming-in-c-sharp?a_aid=functional-programming-in-c-sharp&amp;a_bid=ad9af506" rel="noopener ugc nofollow" target="_blank"> <em class="jp">函数式编程》第一章</em></a></p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="fe ff jr"><img src="../Images/975761ba443281b24113ba9f23ec0732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dJLO5UiAes6S5lZ62-ib4g.jpeg"/></div></div></figure><p id="f08a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">许多程序员默认“你只能用函数式语言进行函数式编程(FP)”，考虑到C#是一种面向对象的语言，尝试用C#进行函数式编程是不值得的。</p><p id="ccf9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然，这是一种肤浅的看法。如果你对C#及其发展有更深入的了解，你可能知道<strong class="it hv"> C#是一种<em class="jp">多范例</em>语言</strong>(就像F#一样)，尽管它最初是一种命令式和面向对象的语言，<strong class="it hv">随着每个后续版本的发布，已经添加了许多功能特性，并且仍在添加。</strong></p><p id="f702" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以，这就引出了一个问题:C#对函数式编程的支持有多好？为了回答这个问题，让我首先澄清我所说的函数式编程是什么意思；也就是说，一个编程范例:</p><ol class=""><li id="d576" class="kd ke hu it b iu iv iy iz jc kf jg kg jk kh jo ki kj kk kl dt translated">强调函数的使用，并且</li><li id="bdc5" class="kd ke hu it b iu km iy kn jc ko jg kp jk kq jo ki kj kk kl dt translated">避免状态突变</li></ol><p id="2432" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了支持这种编程风格，语言必须:</p><ol class=""><li id="d3d2" class="kd ke hu it b iu iv iy iz jc kf jg kg jk kh jo ki kj kk kl dt translated"><strong class="it hv">支持一级值功能</strong>；也就是说，必须能够像对待任何其他值一样对待函数；具体来说，您可以将函数用作其他函数的参数或返回值，或者将函数<br/>存储在集合中</li><li id="8bc1" class="kd ke hu it b iu km iy kn jc ko jg kp jk kq jo ki kj kk kl dt translated">不鼓励就地更新(或者让就地更新变得不可能):默认情况下，变量、对象和数据结构应该是不可变的，创建对象的修改版本应该很容易</li><li id="6573" class="kd ke hu it b iu km iy kn jc ko jg kp jk kq jo ki kj kk kl dt translated"><strong class="it hv">自动管理内存</strong>:因为我们正在创建这样的修改副本，而不是就地改变数据，所以我们最终会创建更多的对象；这在没有自动内存管理的语言中是不切实际的</li></ol><p id="a03f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">考虑到这一点，我们准备提出这个问题:</p><h1 id="6a0e" class="kr ks hu bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">C#语言的功能性如何？</h1><p id="c816" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">嗯……让我想想。</p><p id="0aa5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">1)函数在C#中确实是一等价值。例如，<br/>考虑以下代码:</p><pre class="js jt ju jv fq lu lv lw lx aw ly dt"><span id="ed6e" class="lz ks hu lv b fv ma mb l mc md">Func&lt;int, int&gt; triple = x =&gt; x * 3;<br/>var range = Enumerable.Range(1, 3);<br/>var triples = range.Select(triple);</span><span id="af1a" class="lz ks hu lv b fv me mb l mc md">triples // =&gt; [3, 6, 9]</span></pre><p id="54c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这演示了作为第一类值的函数，因为我们可以将我们的<br/>乘3函数赋给变量<code class="eh mf mg mh lv b">triple</code>，并将其作为参数赋予<code class="eh mf mg mh lv b">Select</code>。</p><p id="7613" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">事实上，从语言的最早版本开始，通过<code class="eh mf mg mh lv b">Delegate</code>类型，C#就支持作为一级值的函数，随后引入的<em class="jp"> lambda表达式</em>使得语法支持变得更好。</p><p id="b462" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，对于类型推断(尤其是当我们想要将多参数函数作为参数传递给另一个函数时)，有一些奇怪的地方和限制；我将在第八章讨论这些。但是，总的来说，对作为一级值的函数的支持相当好。</p><p id="e7e4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2)理想情况下，我们也希望语言能够<em class="jp">阻止</em>就地更新。这是C#最大的缺点:默认情况下一切都是可变的，程序员必须付出大量的努力来实现不变性。默认情况下，字段和变量都是可变的，必须显式标记<code class="eh mf mg mh lv b">readonly</code>以防止变异。(与F#相比，F #中的变量在默认情况下是不可变的，必须显式标记为<code class="eh mf mg mh lv b">mutable</code>才能允许变异。)</p><p id="8984" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">类型呢？虽然框架中有一些不可变类型，<br/>如<code class="eh mf mg mh lv b">string</code>和<code class="eh mf mg mh lv b">DateTime</code>，但是对用户定义的不可变类型的语言支持很差(尽管，正如您接下来将看到的，它在C#6中已经得到了改进，并且很可能在未来的版本中进一步改进)。最后，框架中的集合是可变的，但是不可变集合的可靠库是可用的。</p><p id="927d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">3)另一方面，C#确实满足了自动内存管理这一更重要的需求。这意味着，尽管它不鼓励避免就地更新的编程模型，但由于垃圾收集，它支持这种编程模型。</p><p id="4003" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">总之，C#对<em class="jp">一些</em>函数技术、<br/>有很好的支持，但对其他的没有。在其发展过程中，它已经有所改进，并将继续<br/>改进对函数式技术的支持。</p><p id="6154" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，我们将回顾C#过去、现在和未来版本中与FP特别相关的一些语言特性。</p><h1 id="b9e5" class="kr ks hu bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">LINQ的功能性质</h1><p id="78c5" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">当C# 3和。NET framework 3.5，它包含了一系列受函数式语言启发的特性:这包括LINQ库(<code class="eh mf mg mh lv b">System.Linq</code>)和一些新的语言特性，支持或增强你可以用LINQ做的事情，比如扩展方法和表达式树。</p><p id="2be2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">LINQ为列表上的许多常见操作提供了实现(或者，更一般地说，在“序列”上，技术上应该叫“T5”)。其中最常见的是映射、排序和过滤。这里有一个结合了这三者的例子:</p><pre class="js jt ju jv fq lu lv lw lx aw ly dt"><span id="db92" class="lz ks hu lv b fv ma mb l mc md">Enumerable.Range(1, 100).<br/>   Where(i =&gt; i % 20 == 0).<br/>   OrderBy(i =&gt; -i).<br/>   Select(i =&gt; $”{i}%”)<br/>// =&gt; [“100%”, “80%”, “60%”, “40%”, “20%”]</span></pre><p id="375d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意<code class="eh mf mg mh lv b">Where</code>、<code class="eh mf mg mh lv b">OrderBy</code>和<code class="eh mf mg mh lv b">Select</code>如何将其他函数作为参数，并且不改变给定的<code class="eh mf mg mh lv b">IEnumerable</code>，而是返回一个新的<code class="eh mf mg mh lv b">IEnumerable</code>，说明了我上面提到的FP的两个原则。</p><p id="0090" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">LINQ不仅方便查询内存中的对象(LINQ到对象)，<br/>还方便查询各种其他数据源，比如SQL表和XML数据。C#程序员已经将LINQ作为工作的标准工具集<br/>，尤其是列表和关系数据(占典型代码库的相当大一部分)。从好的方面来看，这意味着您已经对函数库的API有了一些了解。</p><p id="b21d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一方面，当使用其他类型时，C#程序员通常坚持命令式风格，使用控制流语句来表达程序的预期行为。因此，我见过的大多数C#代码库都是函数式风格(当使用<code class="eh mf mg mh lv b">IEnumerable</code> -s和<code class="eh mf mg mh lv b">IQueryable</code> -s)和命令式风格(其他的)的拼凑。</p><p id="f619" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这意味着，</p><blockquote class="mi mj mk"><p id="c2c4" class="ir is jp it b iu iv iw ix iy iz ja jb ml jd je jf mm jh ji jj mn jl jm jn jo hn dt translated">虽然C#程序员意识到了使用像LINQ这样的函数库的好处，但他们还没有充分接触到LINQ背后的设计原则，无法在自己的设计中利用这些技术。</p></blockquote><p id="7eee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是本书旨在解决的问题。</p><h1 id="902f" class="kr ks hu bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">C#6和C#7中的功能特性</h1><p id="87e4" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">虽然不像C#3那样具有革命性，但C#6和C#7带来了许多更小的语言特性，综合起来，为函数式编码提供了更好的体验和更惯用的语法。</p><p id="308c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">注意:</strong>C # 6和C#7中的大多数特性引入了更好的语法，<em class="jp">而不是</em>新功能。因此，如果你使用的是C#的旧版本，你仍然可以应用本书中介绍的所有技术。然而，这些特性极大地提高了可读性，使函数式编程更具吸引力。</p><p id="6592" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们在下面的清单中看看这些特性，然后讨论为什么它们与FP相关。</p><p id="dde7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">清单1。与FP相关的C#6和C#7特性</strong></p><pre class="js jt ju jv fq lu lv lw lx aw ly dt"><span id="2312" class="lz ks hu lv b fv ma mb l mc md">using static System.Math;                          &lt;1&gt;</span><span id="4aaa" class="lz ks hu lv b fv me mb l mc md">public class Circle<br/>{<br/>   public Circle(double radius) <br/>      =&gt; Radius = radius;                          &lt;2&gt;</span><span id="f861" class="lz ks hu lv b fv me mb l mc md">   public double Radius { get; }                   &lt;2&gt;</span><span id="c488" class="lz ks hu lv b fv me mb l mc md">   public double Circumference                     &lt;3&gt;<br/>      =&gt; PI * 2 * Radius;                          &lt;3&gt;<br/>   <br/>   public double Area<br/>   {<br/>      get<br/>      {<br/>         double Square(double d) =&gt; Pow(d, 2);     &lt;4&gt;<br/>         return PI * Square(Radius);<br/>      }<br/>   }</span><span id="ed8a" class="lz ks hu lv b fv me mb l mc md">   public (double Circumference, double Area) Stats   &lt;5&gt;<br/>      =&gt; (Circumference, Area);<br/>}</span></pre><ol class=""><li id="8399" class="kd ke hu it b iu iv iy iz jc kf jg kg jk kh jo ki kj kk kl dt translated"><code class="eh mf mg mh lv b">using static</code>允许无限制地访问<code class="eh mf mg mh lv b">System.Math</code>的静态成员，如<code class="eh mf mg mh lv b">PI</code>和下面的Pow</li><li id="5944" class="kd ke hu it b iu km iy kn jc ko jg kp jk kq jo ki kj kk kl dt translated">仅getter自动属性只能在构造函数中设置</li><li id="f508" class="kd ke hu it b iu km iy kn jc ko jg kp jk kq jo ki kj kk kl dt translated">表达丰富的特性</li><li id="fd00" class="kd ke hu it b iu km iy kn jc ko jg kp jk kq jo ki kj kk kl dt translated">局部函数是在另一个方法中声明的方法</li><li id="072f" class="kd ke hu it b iu km iy kn jc ko jg kp jk kq jo ki kj kk kl dt translated">C#7元组语法允许成员名</li></ol><h2 id="f3be" class="lz ks hu bd kt mo mp mq kx mr ms mt lb jc mu mv lf jg mw mx lj jk my mz ln na dt translated">用"<code class="eh mf mg mh lv b">using static"</code>导入静态成员</h2><p id="45fa" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">C#6中的<code class="eh mf mg mh lv b">using static</code>语句允许我们“导入”一个类的静态成员(在这个例子中，是<code class="eh mf mg mh lv b">System.Math</code>类)。因此，在我们的示例中，我们可以调用<code class="eh mf mg mh lv b">Math</code>的<code class="eh mf mg mh lv b">PI</code>和<code class="eh mf mg mh lv b">Pow </code>成员，而无需进一步限定。</p><pre class="js jt ju jv fq lu lv lw lx aw ly dt"><span id="c209" class="lz ks hu lv b fv ma mb l mc md">using static System.Math;<br/>//...</span><span id="1b57" class="lz ks hu lv b fv me mb l mc md">public double Circumference<br/>   =&gt; PI * 2 * Radius;</span></pre><p id="c18f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为什么这很重要？在FP中，我们优先考虑那些行为只依赖于其输入参数的函数，因为我们可以孤立地推理和测试这些函数(与实例方法相反，实例方法的实现依赖于实例成员)。这些函数在C#中是作为静态方法实现的，所以C#中的函数库将主要由静态方法组成。</p><p id="786b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">允许我们更容易地使用这样的库，尽管过度使用会导致命名空间污染，但合理的使用可以产生干净、可读的代码。</p><h2 id="5224" class="lz ks hu bd kt mo mp mq kx mr ms mt lb jc mu mv lf jg mw mx lj jk my mz ln na dt translated">具有纯getter自动属性的更简单的不可变类型</h2><p id="24bc" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">当你声明一个只支持getter的自动属性时，比如<code class="eh mf mg mh lv b">Radius</code>，编译器会隐式声明一个<code class="eh mf mg mh lv b">readonly</code>支持字段。因此，这些属性只能在构造函数或内联中赋值。</p><pre class="js jt ju jv fq lu lv lw lx aw ly dt"><span id="adc3" class="lz ks hu lv b fv ma mb l mc md">public Circle(double radius) <br/>   =&gt; Radius = radius;</span><span id="1665" class="lz ks hu lv b fv me mb l mc md">public double Radius { get; }</span></pre><p id="d264" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">C#6中的纯Getter自动属性有助于定义不可变类型。<code class="eh mf mg mh lv b">Circle</code>类演示了这一点:它只有一个字段(<code class="eh mf mg mh lv b">Radius</code>的后台字段)，就是<code class="eh mf mg mh lv b">readonly</code>；所以，一旦创建，一个<code class="eh mf mg mh lv b">Circle</code>就永远不能改变。</p><h2 id="6fc0" class="lz ks hu bd kt mo mp mq kx mr ms mt lb jc mu mv lf jg mw mx lj jk my mz ln na dt translated">具有表达式主体成员的更简洁的函数</h2><p id="a969" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated"><code class="eh mf mg mh lv b">Circumference</code>属性是用<code class="eh mf mg mh lv b">=&gt;</code>引入的“表达式体”声明的，而不是用<code class="eh mf mg mh lv b">{ }</code>中常见的“语句体”。请注意，与<code class="eh mf mg mh lv b">Area</code>属性相比，这要简洁得多！</p><pre class="js jt ju jv fq lu lv lw lx aw ly dt"><span id="3344" class="lz ks hu lv b fv ma mb l mc md">public double Circumference<br/>   =&gt; PI * 2 * Radius;</span></pre><p id="7618" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在FP中，我们倾向于编写许多简单的函数，其中许多是一行程序，然后将它们组合成更复杂的工作流。表达式主体方法允许我们以最小的语法干扰来完成这项工作。当我们想要编写一个返回函数的函数时，这一点尤其明显——这是我们将在本书中经常用到的。</p><p id="65e5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">表达式主体语法是在C#6中为方法和属性引入的，并在C#7中推广到也适用于构造函数、析构函数、getters和setters。</p><h2 id="bfd8" class="lz ks hu bd kt mo mp mq kx mr ms mt lb jc mu mv lf jg mw mx lj jk my mz ln na dt translated">本地功能</h2><p id="edea" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">编写大量简单的函数意味着通常只能从一个位置调用函数，而C#7允许我们通过在方法范围内声明方法来明确这一点；例如，<code class="eh mf mg mh lv b">Square</code>方法是在<code class="eh mf mg mh lv b">Area</code> getter的范围内声明的。</p><pre class="js jt ju jv fq lu lv lw lx aw ly dt"><span id="9a05" class="lz ks hu lv b fv ma mb l mc md">get<br/>{<br/>   double Square(double d) =&gt; Pow(d, 2);<br/>   return PI * Square(Radius);<br/>}</span></pre><h2 id="aeb4" class="lz ks hu bd kt mo mp mq kx mr ms mt lb jc mu mv lf jg mw mx lj jk my mz ln na dt translated">更好的元组语法</h2><p id="695b" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">这大概是C#7最重要的特点。它允许我们轻松地创建和使用元组，最重要的是，为它们的元素指定有意义的名称。例如，<code class="eh mf mg mh lv b">Stats</code>属性返回一个类型为<code class="eh mf mg mh lv b">(double, double)</code>的元组，但是另外指定了有意义的名称，通过这些名称可以访问它的元素。</p><pre class="js jt ju jv fq lu lv lw lx aw ly dt"><span id="993e" class="lz ks hu lv b fv ma mb l mc md">public (double Circumference, double Area) Stats<br/>   =&gt; (Circumference, Area);</span></pre><p id="d38b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">元组在FP中重要的原因再次归结于将任务分解成非常小的函数的趋势。我们可能最终得到一种数据类型，它的唯一目的是捕获一个函数返回的信息，并期望作为另一个函数的输入。为这样的结构定义专用的类型是不切实际的，这与有意义的领域抽象不对应，这就是元组的用武之地。</p><h1 id="b777" class="kr ks hu bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">C#更具功能性的未来？</h1><p id="9da9" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">当我在2016年初撰写本章的第一稿时，C#7的开发还处于早期阶段，有趣的是看到语言团队确定“强烈感兴趣”的所有功能都是通常与函数式语言相关的功能。其中包括:</p><ul class=""><li id="8cc9" class="kd ke hu it b iu iv iy iz jc kf jg kg jk kh jo nb kj kk kl dt translated">记录类型(无样板的不可变类型)</li><li id="1b4a" class="kd ke hu it b iu km iy kn jc ko jg kp jk kq jo nb kj kk kl dt translated">代数数据类型(对类型系统的强大补充)</li><li id="b12a" class="kd ke hu it b iu km iy kn jc ko jg kp jk kq jo nb kj kk kl dt translated">模式匹配(类似于对数据的“形状”起作用的“开关”语句，例如数据的类型，而不仅仅是值)</li><li id="7f6a" class="kd ke hu it b iu km iy kn jc ko jg kp jk kq jo nb kj kk kl dt translated">更好的元组语法</li></ul><p id="6288" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一方面，令人失望的是，只有最后一个项目能够交付。模式匹配的有限实现也已经发布，但是仍然与函数式语言中可用的模式匹配相差甚远，并且通常不足以满足我们在函数式编程时使用模式匹配的方式。</p><p id="690f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一方面，这些特性仍然在未来版本的桌面上，并且已经在各自的提议上做了工作。这意味着我们可能会在C#的未来版本中看到记录类型和更完整的模式匹配实现。</p><p id="0c6f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以，C#已经准备好继续作为<strong class="it hv">的进化，一种多范例语言，具有越来越强大的功能组件</strong>。你在这本书里学到的将会给你一个良好的基础来跟上语言和行业的发展，并且很好的理解语言未来版本背后的概念<br/>和动机。</p></div><div class="ab cl nc nd hc ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="hn ho hp hq hr"><p id="4333" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">更多信息(和折扣代码！)下载免费的<a class="ae jq" href="https://www.manning.com/books/functional-programming-in-c-sharp?a_aid=functional-programming-in-c-sharp&amp;a_bid=ad9af506" rel="noopener ugc nofollow" target="_blank">第一章</a>或者看这个<a class="ae jq" href="http://www.slideshare.net/ManningBooks/a-pragmatic-approach-to-functional-programming" rel="noopener ugc nofollow" target="_blank">幻灯片演示</a>。</p><div class="nj nk fm fo nl nm"><a href="https://www.manning.com/books/functional-programming-in-c-sharp?a_aid=functional-programming-in-c-sharp&amp;a_bid=ad9af506" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab ej"><div class="no ab np cl cj nq"><h2 class="bd hv fv z el nr eo ep ns er et ht dt translated">Manning |中的函数式编程</h2><div class="nt l"><h3 class="bd b fv z el nr eo ep ns er et ek translated">函数式编程是一种强调功能，同时避免状态突变的程序思维方式。它…</h3></div><div class="nu l"><p class="bd b gc z el nr eo ep ns er et ek translated">www.manning.com</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa kb nm"/></div></div></a></div><div class="js jt ju jv fq ab cb"><figure class="ob jw oc od oe of og paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="ob jw oc od oe of og paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="ob jw oc od oe of og paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mi mj mk"><p id="f922" class="ir is jp it b iu iv iw ix iy iz ja jb ml jd je jf mm jh ji jj mn jl jm jn jo hn dt translated"><a class="ae jq" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jq" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jq" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae jq" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is jp it b iu iv iw ix iy iz ja jb ml jd je jf mm jh ji jj mn jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jq" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jq" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="js jt ju jv fq jw fe ff paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="fe ff oh"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>