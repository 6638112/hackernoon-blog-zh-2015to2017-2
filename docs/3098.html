<html>
<head>
<title>Moving Beyond Animations to User Interactions at 60 FPS in React Native</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React Native中以60 FPS的速度从动画过渡到用户交互</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/moving-beyond-animations-to-user-interactions-at-60-fps-in-react-native-b6b1fa0ba525?source=collection_archive---------3-----------------------#2017-03-13">https://medium.com/hackernoon/moving-beyond-animations-to-user-interactions-at-60-fps-in-react-native-b6b1fa0ba525?source=collection_archive---------3-----------------------#2017-03-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/d1ed46e9e89e839b0bc0b6a24748ef9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fVGpmcyiacmS5l1W3PRdNQ.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">presentation is everything</figcaption></figure><p id="d22a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="ke"/><a class="ae kf" href="https://hackernoon.com/tagged/react-native" rel="noopener ugc nofollow" target="_blank"><em class="ke">React Native</em></a><em class="ke">桥的异步特性招致固有的性能损失，阻止JavaScript代码以高帧率运行。现代动画库，如Animated，通过减少过桥次数来解决这个问题。用户交互是更进一步的发展，UI不断地对用户的手势做出反应。我们怎样才能以60帧/秒的速度运行呢？</em></p></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><h2 id="b6b4" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">穿越最后一英里</h2><p id="8c31" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">React Native作为现代移动应用的首选堆栈具有很大的吸引力。这个框架提供的主要优势是生产率的显著提高。简而言之，你开发应用程序的速度要快得多——部分原因是你终于可以在平台之间共享代码了。</p><p id="9bd0" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">不过，总会有人担心。React Native能带我走过最后一英里吗？我将开发的应用程序能达到纯本地实现的顶级应用程序吗？</p><p id="71d4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我不得不承认这种担心是有道理的。在Wix.com，大约一年前，我们将我们的移动堆栈从一个纯粹的原生堆栈切换到原生堆栈，为iOS和Android提供单独的代码库。最初95%的开发是轻而易举的。我们发现自己前进的速度是之前的4倍。不过，最后的5%更具挑战性。我们发现这5%，我称之为最后一英里，仍然不能用React Native直接实现。</p><p id="d7a8" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">作为社区，我们的目标是改善这种情况。</p><h2 id="f03e" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">那么是什么造就了伟大的应用呢？</h2><p id="ea92" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">区分最好的应用和平庸的应用的细微差别是什么？在手机领域，我们越来越希望物体不再只是在屏幕上弹出。事情预计会平稳过渡。</p><p id="ffb2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">60 FPS的流体动画是最后5%的重要组成部分。动画曾经是React Native中的一个大问题。这个问题最终用<a class="ae kf" href="https://facebook.github.io/react-native/docs/animated.html" rel="noopener ugc nofollow" target="_blank"> Animated </a>解决了，它是核心的一部分，是一个优秀的动画库。</p><p id="7348" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们看看动画之外的下一步——模拟现实的动态用户交互。当用户在一个视图上执行一个手势时，一个交互就发生了，这个视图不断地以物理真实感响应用户的手势。</p><p id="da5a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们来看一些现实生活中的例子，以便更好地理解我们正在谈论的内容。我翻遍了我的私人手机，开始在一些我最喜欢的应用程序中列举一些精彩互动的例子:</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="lr ls l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">UX Inspirations</figcaption></figure><ul class=""><li id="8b0f" class="lt lu hu ji b jj jk jn jo jr lv jv lw jz lx kd ly lz ma mb dt translated"><strong class="ji hv"> ListView行操作</strong>——左边是苹果官方的iOS邮件应用和谷歌Gmail 应用的<a class="ae kf" href="https://itunes.apple.com/us/app/inbox-by-gmail/id905060486?mt=8" rel="noopener ugc nofollow" target="_blank">收件箱。当用户在ListView中滑动行时，行操作的按钮逐渐从侧面出现。</a></li><li id="18c5" class="lt lu hu ji b jj mc jn md jr me jv mf jz mg kd ly lz ma mb dt translated"><strong class="ji hv">可刷卡卡</strong>——左起第二个是谷歌的<a class="ae kf" href="https://itunes.apple.com/us/app/google-search-made-just-for-mobile/id284815942?mt=8" rel="noopener ugc nofollow" target="_blank"> Google Now </a>应用程序和Lifehack Labs的<a class="ae kf" href="https://itunes.apple.com/us/app/flic-delete-manage-camera-roll-easily-delete-photos/id918263212?mt=8" rel="noopener ugc nofollow" target="_blank"> Flic </a>应用程序，后者有类似<a class="ae kf" href="https://itunes.apple.com/us/app/tinder/id547702041?mt=8" rel="noopener ugc nofollow" target="_blank"> Tinder </a>的用户界面。当用户刷卡时，这些卡片会改变它们的外观，如果刷卡的力度足够大，它们就会飞出屏幕。</li><li id="ac64" class="lt lu hu ji b jj mc jn md jr me jv mf jz mg kd ly lz ma mb dt translated"><strong class="ji hv">可折叠视图</strong>——右边第二个是<a class="ae kf" href="https://itunes.apple.com/us/app/airbnb/id401626263?mt=8" rel="noopener ugc nofollow" target="_blank"> Airbnb </a>和Any.DO的<a class="ae kf" href="https://itunes.apple.com/us/app/cal-shared-calendar-daily-organizer-weekly-planner/id648287824?mt=8" rel="noopener ugc nofollow" target="_blank"> Cal </a>应用程序。这两个应用程序都有用户可以在多个状态之间折叠的视图。在Airbnb中的过滤器和搜索之间切换，以及在Cal中的月视图和周视图之间切换。</li><li id="bd76" class="lt lu hu ji b jj mc jn md jr me jv mf jz mg kd ly lz ma mb dt translated"><strong class="ji hv">滑动面板&amp;抽屉</strong>——右边是苹果官方iOS顶部通知面板和苹果官方iOS地图应用。用户可以拖动这些面板来显示通常隐藏的其他UI元素。很像流行的导航抽屉/侧边菜单。</li></ul><p id="565e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这些例子有什么共同点？它们本质上都是物理的。视图的速度随着它们被拖动和投掷而变化。注意细微的差别，比如当用力投掷时，通知面板如何从地面反弹。</p><h2 id="279c" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">用JavaScript实现</h2><p id="65d3" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">当使用React Native时，我们自然会尝试用JavaScript实现这些交互。让我们回顾一下这样一个实现。第一个灵感示例——ListView行操作——实际上是在React Native core中以名称<a class="ae kf" href="https://github.com/facebook/react-native/blob/edd957007d689f9a0d559363bb88d3151f8e6c58/Libraries/Experimental/SwipeableRow/SwipeableRow.js" rel="noopener ugc nofollow" target="_blank"> SwipeableRow </a>实现的。</p><p id="380a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">它有一个现代化的实现与所有最新和最伟大的。它强调性能并大量使用动画库。让我们把注意力集中在实现交互本身的部分:</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="mh ls l"/></div></figure><p id="b166" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">该实现依赖于<a class="ae kf" href="https://facebook.github.io/react-native/docs/panresponder.html" rel="noopener ugc nofollow" target="_blank"> PanResponder </a>来计算触摸事件之间的视图变化。我们应该从这种方法中期待什么样的性能？</p><p id="b3e6" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">为了分析性能，我们必须研究React本机内部机制。React Native有两个领域并行运行:一个是<em class="ke"> JavaScript领域</em>——我们在那里实现业务逻辑，另一个是<em class="ke">本地领域</em>——我们的本地视图驻留在那里。两个领域之间的交流通过<em class="ke">桥</em>进行。因为需要序列化来通过桥发送数据，所以频繁的通信是昂贵的。</p><p id="effa" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">触摸事件是一种本地构造，它们起源于<em class="ke">本地领域</em>。对于交互的每一帧，这些事件都通过桥发送，由<em class="ke"> JavaScript领域</em>中的<em class="ke">_ handlePanResponderMove</em>处理。一旦业务逻辑计算出响应，就会设置一个动态值。由于更新视图必须发生在本地领域<em class="ke">中</em>，我们必须再一次过桥。</p><p id="d36a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">正如您所看到的，每个帧都需要数据通过网桥进行序列化。如果你的应用很忙，你会发现这种性能开销会阻止交互以60 FPS运行。</p><h2 id="0ada" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">用本机实现</h2><p id="c895" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">在开发Wix应用程序时，我们最初开始实现与JavaScript的所有交互。当性能不如预期的顺利时，我们开始将特定的用例移植到native。</p><p id="bb15" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这意味着每件事都要实现两次——一次在iOS上用Objective-C实现，一次在Android上用Java实现。使用本机实现通常更容易达到60 FPS，因为我们可以避免在桥上传递数据，并在<em class="ke">本机领域</em>中关闭整个循环、业务逻辑和视图。</p><p id="07fa" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">由于我们开源了几乎所有的本机代码，我们最终拥有了多个库，比如实现可刷卡器的<a class="ae kf" href="https://github.com/wix/react-native-swipe-view" rel="noopener ugc nofollow" target="_blank">react-native-swipe-view</a>和实现可刷卡器的<a class="ae kf" href="https://github.com/wix/react-native-action-view" rel="noopener ugc nofollow" target="_blank">react-native-action-view</a>。如果没有通用的解决方案，每一个新的用例都会产生另一个定制的库。</p><p id="31e2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这种方法的主要问题是它需要本地技能，通常需要两个不同的开发人员。在Wix，我们有大约10%的前端员工是本地工程师，他们拥有Objective-C/Swift或Java方面的专业知识。</p><p id="b57b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这还不够好。我们应该志存高远，努力找到一个优雅的通用解决方案。</p><h2 id="67fa" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">从动画中学习</h2><p id="9ec2" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">动画实际上提出了一个非常相似的挑战。简单的实现是在JavaScript的框架之间补间视图属性。这将在网桥上产生大量噪声，并导致帧丢失。正如我们所知，库<a class="ae kf" href="https://facebook.github.io/react-native/docs/animated.html" rel="noopener ugc nofollow" target="_blank"> Animated </a>作为React Native中处理60 FPS动画的解决方案而出现。它是如何工作的？</p><p id="91ee" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">动画背后的概念是使用一个<em class="ke">声明式API </em>来描述动画。如果我们能够提前声明整个动画，那么JavaScript中的声明可以被序列化并通过桥发送一次。从那时起，<em class="ke">通用驱动</em>将根据声明中的规范逐帧执行动画。</p><p id="da98" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">动画的原始驱动程序是用JavaScript实现的。不过，最近的<a class="ae kf" href="https://github.com/facebook/react-native/commit/19e2388a76a7792ace166b64b9f1fc4695b62f1f" rel="noopener ugc nofollow" target="_blank">版本</a>提供了一个<em class="ke">原生驱动</em>，它能够在<em class="ke">原生领域</em>中逐帧执行动画，并更新原生视图，而无需过桥。</p><p id="4a4d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这种方法只在初始化阶段减少了网桥上的流量。这带给我们一个有趣的结论:</p><blockquote class="mi"><p id="1f90" class="mj mk hu bd ml mm mn mo mp mq mr kd ek translated">声明式API是我们跨越最后一英里的方式</p></blockquote><p id="8787" class="pw-post-body-paragraph jg jh hu ji b jj ms jl jm jn mt jp jq jr mu jt ju jv mv jx jy jz mw kb kc kd hn dt translated">这是一个非常强大的概念。这些是我们应该考虑的图书馆类型。每当我们在React Native中发现一个性能边界时，这都是一种克服它的方法。我们所要做的就是找到几个示例用例，并设计一个可以涵盖所有用例的声明式API。这正是我们接下来要做的。</p><h2 id="0cbd" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">用于用户交互的声明性API</h2><p id="5018" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">为了设计一个成功的API，我们应该定义几个目标:</p><ol class=""><li id="7c21" class="lt lu hu ji b jj jk jn jo jr lv jv lw jz lx kd mx lz ma mb dt translated">我们的API应该是通用的。验证的一个好方法是确保它涵盖了我们在上面的UX灵感中看到的所有8个例子。</li><li id="cee5" class="lt lu hu ji b jj mc jn md jr me jv mf jz mg kd mx lz ma mb dt translated">我们的API应该是简单的。验证这一点的一个好方法是确保每个交互的定义不超过3-5行代码。</li></ol><p id="347b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在我们进入API的细节之前，我想提一下正在进行的一些非常有趣的工作，目的是为用户交互增加一些支持。一个有趣的补充是<a class="ae kf" href="https://github.com/facebook/react-native/blob/0a712f5335d1bf04c4ff93a79b14c9e23dbd5831/Examples/UIExplorer/js/NativeAnimationsExample.js#L195" rel="noopener ugc nofollow" target="_blank">动画。ScrollView </a>允许根据<a class="ae kf" href="http://facebook.github.io/react-native/docs/scrollview.html" rel="noopener ugc nofollow" target="_blank"> ScrollView </a>位置执行视图属性插值。另一个正在进行的有趣工作是由Krzysztof Magiera 开发的名为<a class="ae kf" href="https://github.com/kmagiera/react-native-gesture-handler" rel="noopener ugc nofollow" target="_blank">react-native-gesture-handler</a>的库，它允许基于手势参数执行视图属性插值。</p><p id="3fbc" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们现在要一起采取的方法有点不同。我们将从上面显示的8个UX灵感开始，设计一个可以定义所有这些灵感的最简单的高级API。</p><h2 id="9b62" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">定义API —第1阶段</h2><p id="71e2" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">分析我们的8 <a class="ae kf" href="https://youtu.be/zqsnGEcMeV0" rel="noopener ugc nofollow" target="_blank"> UX灵感</a>，我们可以看到一些视图可以自由水平移动，一些可以自由垂直移动。因此，指定<em class="ke">方向</em>对于我们的API来说是一个好的开始。</p><p id="01ce" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">另一个观察结果是视图只能在被拖动时自由移动。一旦用户放开，他们通常会捕捉到一个预定义的<em class="ke">捕捉点</em>。例如，抽屉可以快速打开或关闭。</p><p id="5f52" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">最后，为了给捕捉行为一个真实的感觉，我们需要使用类似弹簧动画曲线的东西。如果我们不希望弹簧永远振荡，我们还应该在我们的API中指定<em class="ke">摩擦力</em>(或者弹簧的阻尼)。</p><p id="0308" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">总之，我们的声明性API的第一阶段可以依赖于道具:</p><ul class=""><li id="2e48" class="lt lu hu ji b jj jk jn jo jr lv jv lw jz lx kd ly lz ma mb dt translated"><strong class="ji hv">水平</strong> / <strong class="ji hv">垂直</strong></li><li id="3229" class="lt lu hu ji b jj mc jn md jr me jv mf jz mg kd ly lz ma mb dt translated"><strong class="ji hv">捕捉点</strong></li><li id="8d5b" class="lt lu hu ji b jj mc jn md jr me jv mf jz mg kd ly lz ma mb dt translated"><strong class="ji hv">摩擦力</strong></li></ul><p id="aa00" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们尝试使用这个简单的API来声明前两个UX的灵感——ListView行操作(左)和可刷卡(右):</p><figure class="ln lo lp lq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff my"><img src="../Images/d69e0aac6616911f14be89206005c4ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aiOqWyvqDaSX-H_94ZT8LA.png"/></div></div></figure><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="mh ls l"/></div></figure><p id="ddb8" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">为了允许可刷卡被刷走，我们简单地定义了完全在屏幕外的捕捉点(-360和360逻辑像素)。注意，为了简单起见，我们目前使用像素值。我们可以在以后添加对更适合多屏幕分辨率的单位的支持，比如百分比。</p><p id="30c1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这是一个很好的开始，但是设计<em class="ke">声明式API </em>只是前半部分。后半部分是实现<em class="ke">原生驱动</em>。让我们接下来做那件事。</p><h2 id="30b0" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">实现本机驱动程序—尝试1</h2><p id="5ef1" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">在<em class="ke"> JavaScript领域</em>中将交互规范声明为道具后，它们在初始化期间由React Native序列化，并通过桥发送到<em class="ke">本地领域</em>。我们的通用<em class="ke">本机驱动</em>将接收这些规范，并完全从本机驱动交互。计算每一帧不再需要通过网桥，从而以60 FPS的速度执行，没有额外开销。</p><p id="473b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们从Objective-C中的一个简单实现开始。我们将通过使用<a class="ae kf" href="https://developer.apple.com/reference/uikit/uipangesturerecognizer?language=objc" rel="noopener ugc nofollow" target="_blank"> UIPanGestureRecognizer </a>来拖动视图，当平移手势结束时，我们将找到最近的捕捉点，并用一条弹簧曲线将我们的视图动画化:</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="mh ls l"/></div></figure><p id="ccd3" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这个实现足够好了。问题是我们用动画来伪装物理。考虑当视图被用户以某个初始速度抛出时会发生什么。我们使用的动画函数只能在弹簧方向应用速度。如果用户将视图转向另一个方向会发生什么？我们的模型不足以驱动这个案子。</p><h2 id="0505" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">实现本机驱动程序—尝试2</h2><p id="d6d5" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">让我们看看更强大的模型来推动互动。如果你深入到原生SDK，并检查苹果如何推荐实现物理现实主义的复杂交互，你会遇到<a class="ae kf" href="https://developer.apple.com/reference/uikit/uidynamicanimator?language=objc" rel="noopener ugc nofollow" target="_blank"> UIKit Dynamics </a>。</p><p id="4ec7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这个疯狂的API是在iOS 7中引入的。它在引擎盖下运行一个完全成熟的物理引擎，并允许我们将物理属性如<a class="ae kf" href="https://developer.apple.com/reference/uikit/uidynamicitembehavior/1624395-density?language=objc" rel="noopener ugc nofollow" target="_blank">质量</a>、<a class="ae kf" href="https://developer.apple.com/reference/uikit/uidynamicitembehavior/1624391-addlinearvelocity?language=objc" rel="noopener ugc nofollow" target="_blank">速度</a>和<a class="ae kf" href="https://developer.apple.com/reference/uikit/uifieldbehavior" rel="noopener ugc nofollow" target="_blank">力</a>应用到视图中。场景的物理参数通过应用<a class="ae kf" href="https://developer.apple.com/reference/uikit/uidynamicbehavior?language=objc" rel="noopener ugc nofollow" target="_blank">行为</a>来定义。我们可以很容易地修改上面的实现:</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="mh ls l"/></div></figure><p id="e959" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们越来越近了，但还是没到。使用UIKit Dynamics有两个主要缺点。首先，没有Android支持。这个API是iOS独有的，在Android SDK中没有类似的东西。第二，一些行为，例如<a class="ae kf" href="https://developer.apple.com/reference/uikit/uisnapbehavior?language=objc" rel="noopener ugc nofollow" target="_blank">捕捉</a>，没有提供足够的控制——例如，没有办法指定捕捉力的强度。</p><h2 id="430c" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">实现本机驱动程序—尝试3</h2><p id="b72d" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">让我们变得更疯狂一点。为什么不尝试自己实现UIKit Dynamics？归根结底，物理力是相对简单的数学方程。从头开始构建物理引擎应该不会太难。</p><p id="af91" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">UIKit Dynamics会给我们指路。我们甚至可以采用它的行为模式。让我们以捕捉行为为例——我们可以使用一个<em class="ke">弹簧</em>来实现它。弹簧的表现如何？是时候回忆一些<a class="ae kf" href="https://en.wikipedia.org/wiki/Hooke's_law" rel="noopener ugc nofollow" target="_blank">物理101 </a>:</p><figure class="ln lo lp lq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mz"><img src="../Images/e110b44e74d58fd10bc36044eb83d858.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VjI-h26_nzvCQwfRAGk0nQ.png"/></div></div></figure><p id="46f4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">不要太担心数学，这是图书馆内部会做的事情。维基百科中关于<a class="ae kf" href="https://en.wikipedia.org/wiki/Newton%27s_laws_of_motion" rel="noopener ugc nofollow" target="_blank">牛顿运动定律</a>和<a class="ae kf" href="https://en.wikipedia.org/wiki/Hooke's_law" rel="noopener ugc nofollow" target="_blank">胡克定律</a>的条目可以为你提供完整的背景。</p><p id="a2cd" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们必须计算每一帧上的力和速度。为此，我们需要一个以60 FPS运行的高精度计时器。幸运的是，有专门为此任务设计的本地API—<a class="ae kf" href="https://developer.apple.com/reference/quartzcore/cadisplaylink" rel="noopener ugc nofollow" target="_blank">CADisplayLink</a>。将所有这些放在一起会产生以下结果:</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="mh ls l"/></div></figure><p id="f49b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在这种感觉是对的，并带给我们一个非常有趣的认识…</p><blockquote class="mi"><p id="8498" class="mj mk hu bd ml mm mn mo mp mq mr kd ek translated">我们正在为React Native编写一个声明式物理引擎</p></blockquote><p id="e81a" class="pw-post-body-paragraph jg jh hu ji b jj ms jl jm jn mt jp jq jr mu jt ju jv mv jx jy jz mw kb kc kd hn dt translated">这真是太酷了。</p><p id="fdd3" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们终于控制住了<em class="ke">本地驱动</em>。是时候利用我们强大的引擎，并为我们的<em class="ke">声明式API </em>添加更多功能了。</p><h2 id="9be2" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">丰富API —更多道具</h2><p id="1e40" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">到目前为止，我们所拥有的声明式API提供了一个坚实的基础，但是仍然缺乏在我们的8个UX灵感中实现一些更复杂的交互的能力。考虑苹果官方的iOS顶部通知面板。当用户用足够的力向下投掷面板时，面板<a class="ae kf" href="https://www.youtube.com/watch?v=zqsnGEcMeV0&amp;feature=youtu.be&amp;t=8s" rel="noopener ugc nofollow" target="_blank">会从地面上弹起</a>。</p><p id="1d3e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们可以很容易地将对这种行为的支持添加到我们的声明式API中。我们将使用<strong class="ji hv">边界</strong>限制视图的移动，并从边缘添加<strong class="ji hv">反弹</strong>:</p><figure class="ln lo lp lq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff na"><img src="../Images/df610881b7780544b9a97de084db9066.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ewoMExGXo5TJp14KXFna3g.gif"/></div></div></figure><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="mh ls l"/></div></figure><p id="f8d3" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们考虑另一个复杂的用例，这次涉及ListView行操作。有些行两侧没有操作按钮。在这种情况下，常见的UX行为是允许行在暴露按钮的方向上自由移动，但是当在另一个方向上移动时，移动将更加困难并且遇到越来越大的阻力。</p><p id="e2ab" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们可以通过使用一个恒定的<strong class="ji hv">弹簧</strong>将行的一个边缘绑到屏幕的边缘来增加行移动的阻力。与捕捉点不同，此弹簧在拖动时也是活动的。</p><p id="f509" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们还需要解决另一个问题。该行应该无阻力地向左移动(该方向暴露按钮)，但有阻力地向右移动(无按钮的方向)。我们可以通过赋予每一个力，比如我们的弹簧，一个可选的<strong class="ji hv">影响区域</strong>，来将这种行为添加到我们的API中。</p><p id="2ba6" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">当视图在影响区域之外时，力将消失。</p><figure class="ln lo lp lq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff na"><img src="../Images/ee27f8937945ddb3ba801f61c6b60721.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ejbPzrEyyjrCGJYy1IkRGw.gif"/></div></div></figure><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="mh ls l"/></div></figure><p id="37b9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">正如你所看到的，随着我们遇到越来越多的用例，我们可以简单地丰富我们的声明式API，并添加通用功能来描述它们。</p><h2 id="cd84" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">丰富API —与动画的集成</h2><p id="6fc1" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">我们仍然缺少一大块拼图。考虑ListView行操作用例。当您扫动该行时，操作按钮会逐渐从下方出现。一种常见的模式是在显示时改变它们的外观，如比例和不透明度。</p><p id="ed27" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">您可以在下面看到这种行为(蓝色的操作按钮):</p><figure class="ln lo lp lq fq iv fe ff paragraph-image"><div class="fe ff nb"><img src="../Images/7961ac5e0ffddad97c607d459fb3a86b.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/1*aKAhy9ak9XNXat3awZD22w.gif"/></div></figure><p id="46ab" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">还要注意，我们想要激活的视图(蓝色的动作按钮)不同于用户正在交互的视图(灰色的行封面)。</p><p id="f107" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">实现这种效果并不容易，因为动画的阶段取决于行的水平位置，而不是时间。然而，这仍然是一个动画，其中视图属性(比例和不透明度)是按顺序修改的。我们已经有了一个强大的工具来制作视图属性的动画——动画库<a class="ae kf" href="https://facebook.github.io/react-native/docs/animated.html" rel="noopener ugc nofollow" target="_blank">。让我们找到一种方法来使用它。</a></p><p id="1c28" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">通过在<a class="ae kf" href="https://facebook.github.io/react-native/docs/animated.html#animatedvalue" rel="noopener ugc nofollow" target="_blank">动画上定义插值，以声明方式执行带动画的视图属性动画。数值</a>:</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="mh ls l"/></div></figure><p id="71d9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">因为动画依赖于行的水平位置，如果我们把位置转换成动画。价值？这将允许我们根据交互视图的位置来定义插值，这些位置会影响其他不直接参与交互的视图(比如按钮)。</p><p id="1632" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这在我们的声明式API中是如何工作的？我们可以通过传递动画。作为道具的值(<em class="ke"> animatedValueX </em>):</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="mh ls l"/></div></figure><p id="3c94" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们的本地驱动程序将执行引擎盖下的实际传输。这可以通过使用<a class="ae kf" href="https://facebook.github.io/react-native/docs/animated.html#event" rel="noopener ugc nofollow" target="_blank">动画事件</a>来完成。最近版本的Animated甚至支持使用一个<a class="ae kf" href="https://github.com/facebook/react-native/commit/fc11a5fde847f40f446823ac2bbb0d2e64236306" rel="noopener ugc nofollow" target="_blank">本地驱动</a>来驱动Animated.events。这意味着整个动画——从传输位置到插值和更新视图属性——可以在<em class="ke">本地领域</em>中执行，而无需通过桥发送数据。如果我们的目标是60 FPS，这是个好消息。</p><h2 id="7586" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">丰富API——收尾工作</h2><p id="0bdf" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">如果我们在做我们自己的物理，我们也可以加上其余的力。我们已经有了<em class="ke">弹簧</em>，让我们再加上<em class="ke">重力</em>和<em class="ke">磁力</em>。这将为开发人员提供定义各种疯狂的物理交互所需的灵活性。</p><p id="28ed" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们还应该添加对<em class="ke">事件</em>的支持，这样我们的JavaScript代码就可以在交互停止或视图捕捉到某个点时得到通知。同时，添加触觉反馈也是一个不错的触摸——因此每当视野与周围环境发生冲突时，该设备都会轻微振动。这些细微差别为出色的用户体验增添了光彩。</p><p id="8c18" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">该收拾东西了…</p><p id="e7a2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我想向你展示我们在这里创造的全部力量。看看下面的声明，你能猜出它实现了什么吗？</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="mh ls l"/></div></figure><p id="e861" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们的神秘视图可以贴在屏幕的左边或右边。底部有一个重力井，当它靠得太近时会把里面的景色吸走。另外，请注意，我们没有限制移动，而是允许视图向两个方向移动。</p></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><p id="3cb2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们这里有一个完整的<em class="ke">聊天标题</em>实现，只有7行代码！</p><figure class="ln lo lp lq fq iv fe ff paragraph-image"><div class="fe ff nb"><img src="../Images/97e19843ab20c89b16f8f0407673cce3.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/1*nKtWaAaxsBjeJjlhCythpw.gif"/></div></figure><h2 id="aa92" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">真的以60 FPS运行吗？</h2><p id="c2f9" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">观看视频和自己在真实设备上体验互动是不一样的。请注意，即使是模拟器也不能提供真实的体验，因为它会丢帧。</p><p id="715e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">那么，在真实的设备上，它真的能以60 FPS的速度运行吗？自己判断。我已经用我们刚刚在React Native中创建的引擎实现了所有8个<a class="ae kf" href="https://youtu.be/zqsnGEcMeV0" rel="noopener ugc nofollow" target="_blank"> UX灵感</a>。你可以在<a class="ae kf" href="https://itunes.apple.com/us/app/react-native-interactions/id1209875831?ls=1&amp;mt=8" rel="noopener ugc nofollow" target="_blank">苹果应用商店</a> (iOS)和<a class="ae kf" href="https://play.google.com/store/apps/details?id=com.wix.interactions&amp;hl=en" rel="noopener ugc nofollow" target="_blank"> Google Play </a> (Android)找到最终的演示应用。</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="lr ls l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Download the demo app</figcaption></figure><p id="60ce" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">GitHub上提供了物理引擎、我们的iOS和Android原生驱动程序以及演示应用程序的完整实现:</p><div class="nc nd fm fo ne nf"><a href="https://github.com/wix/react-native-interactable" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab ej"><div class="nh ab ni cl cj nj"><h2 class="bd hv fv z el nk eo ep nl er et ht dt translated">wix/react-本机-可交互</h2><div class="nm l"><h3 class="bd b fv z el nk eo ep nl er et ek translated">React-Native-interactable-React Native中高性能交互式视图的实验性实现</h3></div><div class="nn l"><p class="bd b gc z el nk eo ep nl er et ek translated">github.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt ja nf"/></div></div></a></div><p id="f056" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">特别感谢<a class="nu nv gr" href="https://medium.com/u/60e6105b5bc7?source=post_page-----b6b1fa0ba525--------------------------------" rel="noopener" target="_blank">罗滕·米兹拉奇-梅丹</a>和察奇·科皮洛维兹帮助我们在2017年ReactConf上及时将它带回家。</p><h2 id="74b0" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jr ky kz la jv lb lc ld jz le lf lg lh dt translated">穿越最后一英里</h2><p id="420f" class="pw-post-body-paragraph jg jh hu ji b jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz lm kb kc kd hn dt translated">我希望您从这个有趣的实验中获得的不仅仅是在React Native中实现出色的用户交互的酷方法。作为一个社区，我们的目标是确定React Native的边界，然后推动它们。</p><p id="ca08" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">当您在React Native中偶然发现一个有趣的性能问题时，我建议您找到几个示例用例，并尝试设计一个简单的声明性API来定义它们。如果性能问题源于桥接开销(通常是这样)，API的本地驱动程序可能会提供一个很好的解决方案。</p><p id="a829" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们一起走过最后一英里。</p><div class="ln lo lp lq fq ab cb"><figure class="nw iv nx ny nz oa ob paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nw iv nx ny nz oa ob paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nw iv nx ny nz oa ob paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="oc od oe"><p id="f922" class="jg jh ke ji b jj jk jl jm jn jo jp jq of js jt ju og jw jx jy oh ka kb kc kd hn dt translated"><a class="ae kf" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kf" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kf" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae kf" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jg jh ke ji b jj jk jl jm jn jo jp jq of js jt ju og jw jx jy oh ka kb kc kd hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kf" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kf" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ln lo lp lq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff oi"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="oj ls l"/></div></figure></div></div>    
</body>
</html>