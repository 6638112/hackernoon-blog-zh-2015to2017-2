<html>
<head>
<title>Building a Dashboard that recognizes you</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建一个能够识别您的仪表板</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/building-a-dashboard-that-recognizes-you-d000fb85f7d2?source=collection_archive---------11-----------------------#2017-03-02">https://medium.com/hackernoon/building-a-dashboard-that-recognizes-you-d000fb85f7d2?source=collection_archive---------11-----------------------#2017-03-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/b4917fbc99bab1e72752dc191c6acde7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*88ogqEWmGrI5VhUBO46K7g.jpeg"/></div></div></figure><p id="61fc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在20nine，我们最近在公共区域安装了一台大型壁挂式电视——主要用于我们的日常会议和偶尔的YouTube视频。但是我注意到，当它与我们的内部资源管理工具(我们称之为Forge)连接时，它在90%的时间里是关闭的。为了补救这一点，我认为创建一个实时仪表板将是一个令人兴奋的R&amp;D项目，它将从我们的资源管理应用程序中获取数据，并显示到期的项目、谁正在处理它以及我们打开的项目的状态的高级每周概述。为了鼓励团队参与其中，我认为内置面部识别功能会很有趣，这样当有人靠近屏幕时，它会显示欢迎消息、状态更新和与他们相关的内容。</p><h1 id="6724" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">创建公共API和仪表板</h1><p id="017d" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">Forge是我们自己专有的定制资源管理工具，它主要在NodeJS上运行。它帮助我们管理诸如个人工作量、里程碑、可交付成果和项目时间表之类的事情。我需要创建一个公共API，它不仅可以获取数据，还可以通过Socket IO进行连接，以便在有人进行编辑时进行实时更新。</p><p id="2650" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我用NodeJS和Angular 1创建了仪表板，以无缝连接到主应用程序。我还从我们的会议室日历中获取信息，实时显示它们是否被使用、被谁使用以及用途。</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ld"><img src="../Images/b17c666c3da1bc34ee7ef0d267c52108.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CS9eCiQerd7XYoYy."/></div></div><figcaption class="li lj fg fe ff lk ll bd b be z ek">A mockup of the dashboard layout</figcaption></figure><h1 id="911e" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">面部识别</h1><p id="f057" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">经过一些研究，我决定使用OpenCV和Python来处理人脸检测和识别。我非常依赖Bytefish的教程和代码<em class="ln">(下面的链接)</em>来启动和运行一个基本系统，但基本思想是该程序首先检测人脸，然后根据训练好的模型进行检查。使用Haar-Cascade正面人脸检测可以在图像中找到人脸。一旦程序检测到人脸，它会根据训练好的模型进行检查，并使用k-最近邻模型返回最接近的匹配，其中k=1。k-最近邻是用于分类和回归的相对简单的算法。</p><div class="lo lp fm fo lq lr"><a href="https://github.com/bytefish/facerec/" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab ej"><div class="lt ab lu cl cj lv"><h2 class="bd hv fv z el lw eo ep lx er et ht dt translated">GitHub - bytefish/facerec:实现MATLAB/GNU Octave和Python的人脸识别算法。</h2><div class="ly l"><h3 class="bd b fv z el lw eo ep lx er et ek translated">facerec -为MATLAB/GNU Octave和Python实现人脸识别算法。</h3></div><div class="lz l"><p class="bd b gc z el lw eo ep lx er et ek translated">github.com</p></div></div></div></a></div><p id="3019" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我很早就意识到，为每个用户手动查找、裁剪和创建训练图像会非常耗时。为了避免这种繁琐的劳动，我使用了上面的方法来寻找脸，采取了每一个它找到的脸裁剪图片。我让团队几次站在摄像机前抓拍。下面是一些脸书的个人资料准备，我自己的质量例子。</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div class="fe ff ma"><img src="../Images/2dee7243c780dd8eb01f4fb94993b8be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*dWaD1LPIAeggJymy."/></div><figcaption class="li lj fg fe ff lk ll bd b be z ek">What the OpenCV crop captures</figcaption></figure><p id="8a7d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了构建训练数据，为Forge中的每个用户创建了文件夹，并以他们的用户id命名。如果检测到匹配，它将提取文件夹名称(用户id)，向仪表板节点API发出post请求，并通过套接字IO向客户端发出一个事件。客户端向公共API发出Get请求，该请求只获取与该用户相关联的里程碑和项目，并通过angular scope更新屏幕。</p><p id="1e13" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在检测到一张脸之后，该算法被设置为总是返回一个匹配，不管它距离多远。通过反复试验，我设置了一个限制，如果匹配不太接近，就返回false。在这种情况下，准确性比总是找到匹配更重要。</p><h1 id="ac89" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">硬件</h1><p id="4eb0" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">我拿了一个树莓Pi 3设置和一个Pi摄像头来安装仪表盘和面部识别应用程序。设置依赖关系肯定比我最初预期的更耗时，但大多数情况下一切都很顺利。我遇到的唯一问题是OpenCVs视频捕获和pi摄像头的兼容性。出于时间的原因，我最终将下面的编解码器添加到Pi启动脚本中，但我计划在将来使用Pi Camera实用程序。</p><pre class="le lf lg lh fq mb mc md me aw mf dt"><span id="2808" class="mg kb hu mc b fv mh mi l mj mk">sudo modprobe bcm2835-v4l2</span></pre><p id="f73a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Pi首先通过Forever(【https://github.com/foreverjs/forever】)运行节点应用程序，然后在开发模式下运行chromium。我还安装了XScreenSaver，作为一种简单的方法来防止Pi在一段时间后关闭屏幕。下面是一个测试仪表盘和面部识别的视频。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="b4d6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">感谢阅读！如果您有任何问题，请随时联系Twitter @joezeoli。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mn mm l"/></div></figure></div></div>    
</body>
</html>