<html>
<head>
<title>Do you still register window event listeners in each component? (React in example)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你仍然在每个组件中注册窗口事件监听器吗？(在示例中反应)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/do-you-still-register-window-event-listeners-in-each-component-react-in-example-31a4b1f6f1c8?source=collection_archive---------3-----------------------#2017-11-29">https://medium.com/hackernoon/do-you-still-register-window-event-listeners-in-each-component-react-in-example-31a4b1f6f1c8?source=collection_archive---------3-----------------------#2017-11-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/4c2b4061f8d9378e36717ef118af6837.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JSpJXMCq2veTsUKutpknVg.jpeg"/></div></div></figure><blockquote class="jc jd je"><p id="02c9" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">每次调用<code class="eh ke kf kg kh b"><strong class="ji hv">addEventListener()</strong></code>方法时，它会将指定的<code class="eh ke kf kg kh b">EventListener</code>兼容对象添加到调用它的<code class="eh ke kf kg kh b">EventTarget</code>上指定事件类型的事件监听器列表中。事件目标可以是文档中的<code class="eh ke kf kg kh b">Element</code>、<code class="eh ke kf kg kh b">Document</code>本身、<code class="eh ke kf kg kh b">Window</code>或任何其他支持事件的对象(如<code class="eh ke kf kg kh b">XMLHttpRequest</code>)。</p></blockquote></div><div class="ab cl ki kj hc kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hn ho hp hq hr"><p id="a438" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kp js jt ju kq jw jx jy kr ka kb kc kd hn dt translated">从描述中我们可以发现，每次当你调用<code class="eh ke kf kg kh b">window.addEventListener('resize', callback)</code>到body元素时，对象都会被添加到resize事件监听器列表中。</p><p id="8ee8" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kp js jt ju kq jw jx jy kr ka kb kc kd hn dt translated">在React中，您可能会经常看到这样方法:</p><pre class="ks kt ku kv fq kw kh kx ky aw kz dt"><span id="604c" class="la lb hu kh b fv lc ld l le lf">componentDidMount() {<br/>   window.addEventListener('resize', <strong class="kh hv">this</strong>.handleResize)<br/>}<br/><em class="jh"><br/></em>componentWillUnmount() {<br/>   window.removeEventListener('resize', <strong class="kh hv">this</strong>.handleResize)<br/>}</span></pre><p id="235c" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kp js jt ju kq jw jx jy kr ka kb kc kd hn dt translated">这是可行的，但是正如我们之前提到的，当你重用这个组件时，调整事件列表的大小会增加很多倍。最终，你会看到这样照片:</p><figure class="ks kt ku kv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lg"><img src="../Images/adf42a477ad0b16c05d947e0ee65cd1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a7WnWc_olxaTiby7_0meqA.png"/></div></div></figure><p id="ffd5" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kp js jt ju kq jw jx jy kr ka kb kc kd hn dt translated">一个主线程活动的火焰图。</p><figure class="ks kt ku kv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lh"><img src="../Images/948b1cfc6272b745108a99c0a04279bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DayrIspn3OP_tDCTNTk0Jg.png"/></div></div></figure><p id="a046" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kp js jt ju kq jw jx jy kr ka kb kc kd hn dt translated">我觉得看起来不太好。它会给你带来什么？首先，很难调试，代码不可伸缩。当每个resizes事件被触发时，如果你需要做一些事情怎么办？会很难，对吧？您需要转到resize事件正在侦听的每个组件并进行更改。其次，它可能会导致你表现不佳。</p><h1 id="22cd" class="li lb hu bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me dt translated">让我们改进</h1><p id="ae06" class="pw-post-body-paragraph jf jg hu ji b jj mf jl jm jn mg jp jq kp mh jt ju kq mi jx jy kr mj kb kc kd hn dt translated">我们需要什么？</p><ol class=""><li id="b59b" class="mk ml hu ji b jj jk jn jo kp mm kq mn kr mo kd mp mq mr ms dt translated">一个调整大小事件侦听器</li><li id="9fa8" class="mk ml hu ji b jj mt jn mu kp mv kq mw kr mx kd mp mq mr ms dt translated">如果需要，每个组件应该有可能监听调整大小事件，当组件被卸载时，它不应该监听</li></ol><p id="3050" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kp js jt ju kq jw jx jy kr ka kb kc kd hn dt translated">听起来发布/订阅模式可能会有所帮助。</p><blockquote class="jc jd je"><p id="1fc3" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这是系统中的对象可以订阅其他对象并在感兴趣的事件发生时得到通知的地方。~ <a class="ae my" href="http://twitter.com/addyosmani" rel="noopener ugc nofollow" target="_blank">阿迪·奥斯马尼</a></p></blockquote><p id="add3" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kp js jt ju kq jw jx jy kr ka kb kc kd hn dt translated">让我们创建一个可以订阅、取消订阅和发布的对象:</p><figure class="ks kt ku kv fq iv"><div class="bz el l di"><div class="mz na l"/></div></figure><p id="0f49" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kp js jt ju kq jw jx jy kr ka kb kc kd hn dt translated">查看发布/订阅UMD软件包，了解更好的用法:</p><div class="nb nc fm fo nd ne"><a href="https://www.npmjs.com/package/publish-subscribe-js" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab ej"><div class="ng ab nh cl cj ni"><h2 class="bd hv fv z el nj eo ep nk er et ht dt translated">发布-订阅-js</h2><div class="nl l"><h3 class="bd b fv z el nj eo ep nk er et ek translated">发布/订阅UMD套餐</h3></div><div class="nm l"><p class="bd b gc z el nj eo ep nk er et ek translated">www.npmjs.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns ja ne"/></div></div></a></div><p id="a19a" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kp js jt ju kq jw jx jy kr ka kb kc kd hn dt translated">然后，我们需要一个地方来监听resize事件，并在事件触发时发布给每个订阅者。</p><p id="17ad" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kp js jt ju kq jw jx jy kr ka kb kc kd hn dt translated">首先，让我们创建一个将在应用程序间共享的全局对象，并设置<code class="eh ke kf kg kh b">resizeEvent</code>属性。</p><figure class="ks kt ku kv fq iv"><div class="bz el l di"><div class="mz na l"/></div></figure><p id="8b52" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kp js jt ju kq jw jx jy kr ka kb kc kd hn dt translated">当DOM准备好的时候监听窗口事件。</p><figure class="ks kt ku kv fq iv"><div class="bz el l di"><div class="mz na l"/></div></figure><p id="0e34" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kp js jt ju kq jw jx jy kr ka kb kc kd hn dt translated">因此，我们创建了订阅者/发布者，在一个地方监听整个应用程序的调整大小事件，并在事件触发时发布给每个订阅者。还剩下什么？好的，让我们从一个组件订阅事件。</p><figure class="ks kt ku kv fq iv"><div class="bz el l di"><div class="mz na l"/></div></figure><p id="b4d4" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kp js jt ju kq jw jx jy kr ka kb kc kd hn dt translated">就是这样:)</p><p id="714e" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kp js jt ju kq jw jx jy kr ka kb kc kd hn dt translated">您可以为每个窗口事件侦听器使用subPub。结果，我们有了一个清晰的窗口调整事件侦听器列表，代码也更具可伸缩性。</p><figure class="ks kt ku kv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nt"><img src="../Images/925c85179dc86d909dd9ce246d974319.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NkHMauu2rFom45dEgz5p9g.png"/></div></div></figure><p id="4e2d" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kp js jt ju kq jw jx jy kr ka kb kc kd hn dt translated">在此处查找完整代码示例(page Resize_SubPub):</p><div class="nb nc fm fo nd ne"><a href="https://www.npmjs.com/package/create-react-redux-app-structure" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab ej"><div class="ng ab nh cl cj ni"><h2 class="bd hv fv z el nj eo ep nk er et ht dt translated">创建-反应-还原-应用-结构</h2><div class="nl l"><h3 class="bd b fv z el nj eo ep nk er et ek translated">使用构建配置创建react redux应用程序结构</h3></div><div class="nm l"><p class="bd b gc z el nj eo ep nk er et ek translated">www.npmjs.com</p></div></div><div class="nn l"><div class="nu l np nq nr nn ns ja ne"/></div></div></a></div><p id="dba4" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kp js jt ju kq jw jx jy kr ka kb kc kd hn dt translated"><strong class="ji hv">感谢您的阅读。欢迎建议、评论、想法:)</strong></p><p id="6922" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kp js jt ju kq jw jx jy kr ka kb kc kd hn dt translated"><strong class="ji hv">如果你喜欢这个，鼓掌，跟我上</strong> <a class="ae my" rel="noopener" href="/@shystruk"> <strong class="ji hv">中</strong> </a> <strong class="ji hv">，</strong> <a class="ae my" href="https://twitter.com/shystrukk" rel="noopener ugc nofollow" target="_blank"> <strong class="ji hv">推特</strong> </a> <strong class="ji hv">，</strong><a class="ae my" href="https://github.com/shystruk" rel="noopener ugc nofollow" target="_blank"><strong class="ji hv">github</strong></a><strong class="ji hv">跟你的朋友们分享一下</strong> ✌️</p><figure class="ks kt ku kv fq iv"><div class="bz el l di"><div class="nv na l"/></div></figure></div></div>    
</body>
</html>