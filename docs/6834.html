<html>
<head>
<title>How we make npm packages work in the browser</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们如何让npm包在浏览器中工作</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-we-make-npm-packages-work-in-the-browser-announcing-the-new-packager-6ce16aa4cee6?source=collection_archive---------3-----------------------#2017-10-06">https://medium.com/hackernoon/how-we-make-npm-packages-work-in-the-browser-announcing-the-new-packager-6ce16aa4cee6?source=collection_archive---------3-----------------------#2017-10-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/de7cfc0169e2429416938e12d827973e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XVBD6d2uHNhlZnN5ZJfv-Q.png"/></div></div></figure><p id="f4f6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在CodeSandbox的初始开发期间，我总是将npm依赖支持排除在范围之外。我以为在浏览器里安装一个任意的，随机数量的包是不可能的，甚至想想都让我大脑堵塞。</p><p id="8d82" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如今，npm支持是CodeSandbox最具定义性的特性之一，所以我们成功地让它工作了。它需要多次迭代才能在任何场景下工作，我们进行了多次重写，即使现在我们仍然可以改进逻辑。我将解释npm支持是如何开始的，我们现在有什么，以及我们还可以做些什么来改进它。</p><h1 id="3ccd" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">第一版</h1><p id="9c92" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">我真的不知道如何解决这个问题，所以我从一个非常简单的npm支持版本开始:</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ld"><img src="../Images/e799bb5f744774a977eefec1d786eba4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Jc2DZLv0Grmajz_gwKalg.png"/></div></div><figcaption class="li lj fg fe ff lk ll bd b be z ek">The absolute first version, importing styled-components and React (25 Nov 2016)</figcaption></figure><p id="9a56" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个版本的npm支持非常简单。这甚至不是真正的npm支持，我只是在本地安装了依赖项，并用已经安装的依赖项来阻止每个依赖项调用。当然，这绝对不能扩展到400，000个不同版本的包。</p><p id="e93a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">尽管这个版本不太好用，但看到我至少能够让两个依赖项在沙盒环境中工作，还是令人鼓舞的。</p><h1 id="c298" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">网络包版本</h1><p id="3644" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">我对第一个版本相当满意，我认为它足以满足一个MVP(code sandbox的第一个版本)。我认为如果不施展魔法，安装任何依赖项都是不可能的。直到我偶然发现了https://esnextb.in/的T2。它们已经支持来自npm的任何依赖，您只需在package.json中定义它们，它就神奇地工作了！</p><p id="ecd6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这对我来说是一个重要的学习时刻。我从来不敢给予适当的国家预防机制支持，因为我认为“这是不可能的”。只有在看到它的“可能性”的活生生的证据后，我才开始投入更多的思考。在放弃这个想法之前，我应该先探索一下可能性。</p><p id="b1a4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以！我开始思考如何解决这个问题。天哪，我把它弄得太复杂了。我的第一个版本不适合我的大脑，所以我必须画一个图表:</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div class="fe ff ln"><img src="../Images/8e054a17eef6d744bd740fb72f55adb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*SwB5ly1ODbaCv-s-LhClXw.png"/></div><figcaption class="li lj fg fe ff lk ll bd b be z ek">The first idea, probably wrong even</figcaption></figure><p id="05da" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种过于复杂的方法有一个优点:实际实现比预期的要容易得多！</p><p id="902b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我了解到<a class="ae lm" href="https://webpack.js.org/plugins/dll-plugin/" rel="noopener ugc nofollow" target="_blank"> Webpack DLL插件</a>能够捆绑依赖项，并生成一个带有清单的JS包。这份清单是这样的:</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="56b0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每个路径都映射到一个模块id。如果我需要<code class="eh lq lr ls lt b">react</code>,我只需要打电话给<code class="eh lq lr ls lt b">dll_bundle(3)</code>,我就会得到反馈！这对于我们的用例来说是完美的，所以我开始打字，想出了这个实际的系统:</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lu"><img src="../Images/3d7076a8d60229d1773ccc881b43b808.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X7Q04eBdfNLSJYPlYoUk-g.png"/></div></div><figcaption class="li lj fg fe ff lk ll bd b be z ek">The source of the service can be found here: <a class="ae lm" href="https://github.com/CompuIves/codesandbox-bundler" rel="noopener ugc nofollow" target="_blank">https://github.com/CompuIves/codesandbox-bundler</a>. This service also contains code to publish any sandbox to npm (really cool), we scrapped this feature later on.</figcaption></figure><p id="b2f3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于打包程序的每个请求，我会在<code class="eh lq lr ls lt b">/tmp/:hash</code>中创建一个新的目录，运行<code class="eh lq lr ls lt b">yarn add ${dependencyList}</code>，然后让webpack捆绑。我会把这个新包保存在gcloud上，作为一种缓存方式。比图简单多了，主要是因为我用yarn代替了安装依赖项，用webpack代替了捆绑。</p><p id="92e1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当你加载一个沙箱时，我们首先要确保在评估之前我们有清单和捆绑包。在评估期间，我们将为每个依赖项调用<code class="eh lq lr ls lt b">dll_bundle(:id)</code>。这工作得非常好，我得到了我的第一个具有适当的npm依赖的版本！</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lv"><img src="../Images/3b86287075d45f99aa4e1961a2db9c78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xlS6lLLJOLTo7Ms8Z01R3Q.png"/></div></div><figcaption class="li lj fg fe ff lk ll bd b be z ek">Whoop! We got material-ui and react running dynamically! (24 Dec 2016)</figcaption></figure><p id="c293" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个系统仍然有很大的局限性。它不支持不在Webpack依赖图中的文件。这意味着例如<code class="eh lq lr ls lt b">require('react-icons/lib/fa/fa-beer')</code>不会工作，因为依赖项的入口点根本不需要它。</p><p id="f638" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不过，我确实发布了这个版本的CodeSandbox，并联系了<a class="ae lm" href="https://webpackbin.com" rel="noopener ugc nofollow" target="_blank">WebpackBin</a><a class="lw lx gr" href="https://medium.com/u/d4ec01100893?source=post_page-----6ce16aa4cee6--------------------------------" rel="noopener" target="_blank">Christian Alfoni</a>的作者。我们使用了一个非常相似的系统来支持npm依赖性，我们也有同样的限制。因此，我们决定联合力量，建立<strong class="je hv">终极</strong>包装机！</p><h1 id="cd76" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">带有条目的Webpack</h1><p id="15a1" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">“终极”打包程序保留了与我们之前的打包程序相同的功能，除了<a class="lw lx gr" href="https://medium.com/u/d4ec01100893?source=post_page-----6ce16aa4cee6--------------------------------" rel="noopener" target="_blank"> Christian </a>创建了一种算法，可以根据文件的重要性将文件添加到包中。这意味着我们手动添加入口点，以确保Webpack也会捆绑这些文件。在对这个系统进行了大量的调整之后，我们让它可以在任何(？)组合。所以你能够要求反应图标，以及css文件🎉。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="ly lp l"/></div></figure><p id="3cbf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">新系统还得到了架构升级:我们有一个dll服务作为负载平衡器和缓存。然后，我们有多个打包程序进行捆绑，这些打包程序可以动态添加。</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lz"><img src="../Images/836745940a822d98068bf3eb6265ec7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eKIAVhOxoa2ToP9a3_2UfA.png"/></div></div><figcaption class="li lj fg fe ff lk ll bd b be z ek">Packager teamwork!</figcaption></figure><p id="06ce" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们想让每个人都可以使用打包服务。这就是为什么我们建立了<a class="ae lm" href="http://webpack-dll-prod.herokuapp.com" rel="noopener ugc nofollow" target="_blank">一个网站</a>来解释这项服务是如何运作的，以及你如何利用它。这被证明是一个巨大的成功，我们甚至在<a class="ae lm" href="https://blog.codepen.io/2017/08/11/using-resources-npm-codepen/" rel="noopener ugc nofollow" target="_blank"> CodePen博客</a>中被提及！</p><p id="4a0c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个“终极”包装器仍然有一些限制和缺点。随着我们变得越来越受欢迎，成本呈指数增长，我们通过包<em class="ma">组合进行缓存。</em>这意味着如果你添加了依赖项，我们必须重新捆绑你的整个包组合。</p><h1 id="f74c" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">走向无服务器</h1><p id="fbb4" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">我一直想尝试这种叫做“<a class="ae lm" href="https://martinfowler.com/articles/serverless.html" rel="noopener ugc nofollow" target="_blank">无服务器</a>”的酷炫技术。使用无服务器，你可以定义一个函数，这个函数将根据请求执行，它将加速运行，处理请求，然后在一段时间后自行终止。这意味着您有非常高的可伸缩性:如果您有1000个并发请求，您可以立即启动1000台服务器。这也意味着您只需为服务器实际运行的时间付费。</p><p id="df08" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">无服务器听起来非常适合我们的服务:它不是全时运行的，我们需要高并发性，以防同时有多个请求。所以我开始急切地使用一个名为<a class="ae lm" href="https://serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器</a>的框架。</p><p id="1689" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">转换我们的服务进行顺利(感谢无服务器！)，2天内就有了工作版。我创建了三个无服务器函数:</p><ol class=""><li id="bf53" class="mb mc hu je b jf jg jj jk jn md jr me jv mf jz mg mh mi mj dt translated">元数据解析器:该服务将解析版本和对等依赖，并请求打包器功能。</li><li id="809c" class="mb mc hu je b jf mk jj ml jn mm jr mn jv mo jz mg mh mi mj dt translated">打包者:这个服务将完成依赖项的实际安装和捆绑</li><li id="09c8" class="mb mc hu je b jf mk jj ml jn mm jr mn jv mo jz mg mh mi mj dt translated">丑化者:负责异步丑化生成的包。</li></ol><p id="540d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我把新服务和旧服务放在一起运行，效果非常好！我们每月的预计成本为0.18美元(相比之下为100美元)，我们的响应时间缩短了40%到700%。</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/f0bc1e1594451511f5ab27906f13ca86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*-b_wBf1k4pltY4NagxDWeQ.png"/></div><figcaption class="li lj fg fe ff lk ll bd b be z ek">This felt sooooo good</figcaption></figure><p id="7e81" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">几天后，我开始注意到一个限制:一个lambda函数只有500MB的最大磁盘空间，这意味着一些依赖组合无法安装。这是一个交易破坏者，我不得不回到绘图板。</p><h2 id="d743" class="mq kb hu bd kc mr ms mt kg mu mv mw kk jn mx my ko jr mz na ks jv nb nc kw nd dt translated">无服务器重访</h2><p id="2b11" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">几个月后，我为CodeSandbox发布了一个新的bundler 。这个捆绑器非常强大，允许我们轻松地支持更多像Vue和Preact这样的库。通过支持这些库，我们得到了一些有趣的请求。例如:如果您想在Preact中使用React库，您需要将<code class="eh lq lr ls lt b">require('react')</code>别名为<code class="eh lq lr ls lt b">require('preact-compat')</code>。对于Vue，你可能想把<code class="eh lq lr ls lt b">@/components/App.vue</code>解析到你的沙盒文件中。我们的打包程序不会为依赖项这样做，但是我们的打包程序会。</p><p id="3f57" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那时我开始想，我们也许可以让浏览器捆绑器来做实际的打包工作。如果我们只是将相关的文件发送到浏览器，我们会让捆绑器进行依赖项的实际捆绑。这应该会更快，因为我们不是评估整个包，只是评估它的一部分。</p><p id="e7da" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种方法有一个很大的优势:我们将能够独立地安装和缓存依赖项。我们可以在客户端合并依赖文件。这意味着，如果您在现有依赖项的基础上请求一个新的依赖项，我们只需要为新的依赖项收集文件！这将解决AWS Lambda的500MB限制，因为我们只安装了一个依赖项。我们也可以将Webpack从打包程序中删除，因为打包程序现在唯一的责任是找出哪些文件是相关的并发送它们。</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ne"><img src="../Images/bc81ecde7cef1720ab5739d578edda7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z8d2YmPcuz63HQALGDZrew.png"/></div></div><figcaption class="li lj fg fe ff lk ll bd b be z ek">We parallelize the packaging of the dependencies</figcaption></figure><p id="1260" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ma">注意:我们也可以删除打包程序，从unpkg.com动态请求每个文件。这可能比我的新方法还要快。我决定仍然保留打包程序(至少对于编辑器来说)，因为我想提供离线支持。这只有在你随身携带所有相关文件的情况下才有可能。</em></p><h2 id="9ab6" class="mq kb hu bd kc mr ms mt kg mu mv mw kk jn mx my ko jr mz na ks jv nb nc kw nd dt translated">它在实践中是如何工作的</h2><p id="9a81" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">当我们请求依赖项的组合时，我们首先检查这个组合是否已经存储在S3上。如果它不在S3上，我们从api服务请求组合；该服务为每个依赖项独立地请求所有打包程序。我们一拿回200 OK，就再次请求S3。</p><p id="f7db" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">打包程序使用yarn安装依赖项，并通过遍历入口点目录中所有文件的AST找到所有相关文件。它搜索require语句并将它们添加到文件列表中。这是递归发生的，所以我们得到一个依赖图。<code class="eh lq lr ls lt b">react@latest</code>的输出示例如下:</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="lo lp l"/></div></figure><h1 id="cb2b" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">优势</h1><h2 id="22be" class="mq kb hu bd kc mr ms mt kg mu mv mw kk jn mx my ko jr mz na ks jv nb nc kw nd dt translated">节省成本</h2><p id="2b7f" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">我已经部署了新的包装两天前，我们支付了高达0.02美元的那两天！这是为了建立缓存。与每月100美元相比，这是一笔巨大的节省。</p><h2 id="4107" class="mq kb hu bd kc mr ms mt kg mu mv mw kk jn mx my ko jr mz na ks jv nb nc kw nd dt translated">更高的性能</h2><p id="5205" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">现在，您可以在3秒钟内获得任何组合的新依赖关系组合。对于旧系统，这有时需要一分钟。如果组合被缓存，你将在50毫秒内通过快速连接得到它。我们在世界各地使用Amazon Cloudfront缓存依赖项。我们的沙箱也运行得更快，因为我们现在只为您的沙箱解析和执行相关的JS文件。</p><h2 id="1695" class="mq kb hu bd kc mr ms mt kg mu mv mw kk jn mx my ko jr mz na ks jv nb nc kw nd dt translated">更多灵活性</h2><p id="b745" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">我们的bundler现在可以像处理本地文件一样处理依赖关系。这意味着我们的错误堆栈跟踪现在更清晰了，我们现在可以包含来自依赖项的任何文件(比如。scss，。vue等。)而且我们很容易支持别名之类的东西。它的工作方式就像依赖项是本地安装的一样。</p><h1 id="a9a9" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">释放；排放；发布</h1><p id="2432" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">两天前，我开始使用新的打包程序以及旧的打包程序，以建立缓存。它已经缓存了2000种不同的组合和1400种不同的依赖关系。我想在实际迁移之前广泛测试新版本。您可以通过在您的首选项中启用它来尝试它！</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nf"><img src="../Images/e1450252cef2bfb19f816ea70d046e93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cZzaCqjlxpv-0tURT14KRw.png"/></div></div></figure><p id="b666" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ma">还有，如果你对出处感兴趣，可以在这里找到:</em><a class="ae lm" href="https://github.com/CompuIves/dependency-packager" rel="noopener ugc nofollow" target="_blank"><em class="ma"/></a><em class="ma">。现在很乱，我来清理一下，给它一个README.md等。未来一周。</em></p><h2 id="b547" class="mq kb hu bd kc mr ms mt kg mu mv mw kk jn mx my ko jr mz na ks jv nb nc kw nd dt translated">去无服务器！</h2><p id="2bbe" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">无服务器给我留下了深刻的印象，它使服务器的可扩展性和管理变得异常简单。唯一让我无法使用无服务器的是非常复杂的设置，但是serverless.com的人做出了这个孩子的游戏。我非常感谢他们的工作，我确实认为无服务器是许多不同应用形式的未来。</p><h2 id="5b8c" class="mq kb hu bd kc mr ms mt kg mu mv mw kk jn mx my ko jr mz na ks jv nb nc kw nd dt translated">将来的</h2><p id="cec6" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">我们仍然可以在很多方面改进系统，我渴望探索动态请求嵌入和离线保存的需求。这是一个很难保持的平衡，但应该是可能的。我们也可以开始在浏览器中独立缓存依赖项，这取决于浏览器允许什么。在这种情况下，当访问具有不同依赖组合的新沙箱时，有时甚至不需要下载新的依赖。我还将进一步探索依赖性解决方案，新系统可能会出现版本冲突，我想在全面上线之前解决这个问题。</p><p id="ada7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">尽管如此，我对新版本非常满意，继续为CodeSandbox开发新的东西！</p><p id="c3e1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ma">如果你对CodeSandbox感兴趣，我们90%开源！最活跃的是</em> <a class="ae lm" href="https://github.com/CompuIves/codesandbox-client" rel="noopener ugc nofollow" target="_blank"> <em class="ma">这里的</em> </a> <em class="ma">。</em></p></div></div>    
</body>
</html>