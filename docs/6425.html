<html>
<head>
<title>Crystal — the Ruby you’ve never heard of</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">水晶——你从未听说过的红宝石</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/crystal-the-ruby-youve-never-heard-of-57bad2efac9c?source=collection_archive---------4-----------------------#2017-09-18">https://medium.com/hackernoon/crystal-the-ruby-youve-never-heard-of-57bad2efac9c?source=collection_archive---------4-----------------------#2017-09-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="9691" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">一种速度极快的编程语言，具有Ruby风格的语法</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/fd77861cf3eea4c6769e8a6d4375e0c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rHm4XkrFFvAJDHinuBo3Sg.png"/></div></div></figure><h1 id="26c3" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated"><em class="kn">什么</em>？</h1><p id="0e46" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated"><a class="ae lk" href="https://crystal-lang.org/" rel="noopener ugc nofollow" target="_blank"> Crystal </a>是一种新的、优雅的、多范例的编程语言，高效且快速。它有R̶u̶b̶y̶'̶s的Ruby风格的语法，可以编译成本地代码。这种语言看起来和Ruby有多相似是不真实的。<br/>这种语言结合了高效的代码和开发人员的生产力，增加了完整的OOP，一个伟大的并发模型和一个握着你手的编译器。</p><p id="2f24" class="pw-post-body-paragraph ko kp hu kq b kr ll iv kt ku lm iy kw kx ln kz la lb lo ld le lf lp lh li lj hn dt translated">本文旨在向您提供一个简短的概述，一个与Ruby的直接性能比较，并展示一些使它与众不同的东西。建议你在继续阅读之前至少了解一些Ruby。</p><h1 id="f867" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">从有趣的东西开始——一个表演的例子</h1><p id="fa39" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated">让我们实际感受一下Crystal的性能。<br/>我在<a class="ae lk" href="https://github.com/Enether/crystal-aa-tree/blob/master/AA_Tree.cr" rel="noopener ugc nofollow" target="_blank">水晶</a>和<a class="ae lk" href="https://github.com/Enether/crystal-aa-tree/blob/ruby-conversion/AA_Tree.rb" rel="noopener ugc nofollow" target="_blank">红宝石</a>中都写了一个<a class="ae lk" href="https://en.wikipedia.org/wiki/AA_tree" rel="noopener ugc nofollow" target="_blank"> AA树</a>。<br/> <em class="lq">注意:代码质量可能不是一流的。Crystal代码的一些行被有意写得更加明确</em></p><p id="90c4" class="pw-post-body-paragraph ko kp hu kq b kr ll iv kt ku lm iy kw kx ln kz la lb lo ld le lf lp lh li lj hn dt translated">我们将运行这段代码来对每个实现进行基准测试:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lr ls l"/></div></figure><p id="e98e" class="pw-post-body-paragraph ko kp hu kq b kr ll iv kt ku lm iy kw kx ln kz la lb lo ld le lf lp lh li lj hn dt translated">这实际上是将数字添加到我们的树中(内部排序)，然后一个接一个地删除每个数字。每次添加/删除时，我们还检查树是否包含给定的数字两次。</p><p id="af3d" class="pw-post-body-paragraph ko kp hu kq b kr ll iv kt ku lm iy kw kx ln kz la lb lo ld le lf lp lh li lj hn dt translated">上面的代码片段实际上是水晶代码。<br/>就像我说的，这些语言乍一看是一样的。对于一个360行的文件，从Crystal到Ruby重写代码总共花费了我50行的修改。<a class="ae lk" href="https://github.com/Enether/crystal-aa-tree/pull/2/files" rel="noopener ugc nofollow" target="_blank"> <em class="lq"> 27如果你是贪婪的</em> </a> <br/>值得注意的是，那些改变仅仅是移除<code class="eh lt lu lv lw b">.as()</code>方法调用和类型注释。</p><h2 id="8f7d" class="lx jw hu bd jx ly lz ma kb mb mc md kf kx me mf kh lb mg mh kj lf mi mj kl mk dt translated">好吧，它们看起来一样，但是Crystal快多少呢？</h2><p id="ebc1" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated">让我们构建可执行文件并开始测试</p><pre class="jk jl jm jn fq ml lw mm mn aw mo dt"><span id="20dd" class="lx jw hu lw b fv mp mq l mr ms">&gt; enether$ crystal build AA_Tree.cr -o crystal_tree — release</span><span id="5ee6" class="lx jw hu lw b fv mt mq l mr ms"># 100 elements<br/>&gt; enether$ ./crystal_tree 100<br/>Time it took: 0.0006560 seconds.<br/>&gt; enether$ ruby AA_Tree.rb 100<br/>Time it took: 0.00172 seconds.</span><span id="089a" class="lx jw hu lw b fv mt mq l mr ms"># 10K elements<br/>&gt; enether$ ./crystal_tree 10000<br/>Time it took: 0.0044000 seconds.<br/>&gt; enether$ ruby AA_Tree.rb 10000<br/>Time it took: 0.288619 seconds.</span><span id="6f4a" class="lx jw hu lw b fv mt mq l mr ms"># 100K elements<br/>&gt; enether$ ./crystal_tree 100000<br/>Time it took: 0.0498230 seconds.<br/>&gt; enether$ ruby AA_Tree.rb 100000<br/>Time it took: 3.414404 seconds.</span><span id="dfa7" class="lx jw hu lw b fv mt mq l mr ms"># 1 million elements<br/>&gt; enether$ ./crystal_tree 1000000<br/>Time it took: 0.5007820 seconds.<br/>&gt; enether$ ruby AA_Tree.rb 1000000<br/>Time it took: 39.370083 seconds.</span><span id="5020" class="lx jw hu lw b fv mt mq l mr ms"># 10 million elements<br/>&gt; enether$ ./crystal_tree 100000000<br/>Time it took: 5.6283920 seconds.<br/>&gt; enether$ ruby AA_Tree.rb 100000000<br/># Still running</span></pre><p id="1fd5" class="pw-post-body-paragraph ko kp hu kq b kr ll iv kt ku lm iy kw kx ln kz la lb lo ld le lf lp lh li lj hn dt translated">正如你所看到的，它绕着Ruby跑了几圈，如果我们以100万个元素为例来判断的话，它被证明要快<strong class="kq hv"> ~80 </strong>倍。</p></div><div class="ab cl mu mv hc mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="hn ho hp hq hr"><h1 id="9483" class="jv jw hu bd jx jy nb ka kb kc nc ke kf ja nd jb kh jd ne je kj jg nf jh kl km dt translated">Ruby的怪癖和不同之处</h1><p id="d5e6" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated">尽管有相似之处，但与Ruby还是有很大的不同，这里我们将重点介绍最明显和最有趣的一些。</p><h2 id="0efa" class="lx jw hu bd jx ly lz ma kb mb mc md kf kx me mf kh lb mg mh kj lf mi mj kl mk dt translated">类型、类型检查和类型联合</h2><p id="e4e0" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated">最明显的区别是Crystal使用并强制变量的类型。它有很强的类型推断能力——如果你没有明确定义变量的类型，编译器会自己计算出来。</p><p id="1661" class="pw-post-body-paragraph ko kp hu kq b kr ll iv kt ku lm iy kw kx ln kz la lb lo ld le lf lp lh li lj hn dt translated">这种语言打字的方式是静态和动态打字的一种混合。它允许你改变变量的类型</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lr ls l"/></div></figure><p id="6581" class="pw-post-body-paragraph ko kp hu kq b kr ll iv kt ku lm iy kw kx ln kz la lb lo ld le lf lp lh li lj hn dt translated">但是它也允许你强制变量的类型</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lr ls l"/></div></figure><h2 id="ce77" class="lx jw hu bd jx ly lz ma kb mb mc md kf kx me mf kh lb mg mh kj lf mi mj kl mk dt translated">类型联合</h2><p id="e4ef" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated">您是否想知道上面的错误消息中的<code class="eh lt lu lv lw b">(Int32 | String)</code>类型是什么？<br/>这是所谓的类型联合，是多个类型的集合。<br/>如果我们将<code class="eh lt lu lv lw b">a</code>强制成为<code class="eh lt lu lv lw b">Int32</code>和<code class="eh lt lu lv lw b">String</code>的并集，编译器将允许我们将其中一种类型赋给该变量，因为它知道这两种类型都有可能出现。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lr ls l"/></div></figure><h2 id="0336" class="lx jw hu bd jx ly lz ma kb mb mc md kf kx me mf kh lb mg mh kj lf mi mj kl mk dt translated">类型推理和类型检查</h2><p id="803b" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated">在大多数情况下，编译器可以自己判断出变量的类型。类型推断算法是专门构建的，当变量的类型对人类读者来说显而易见，并且不需要深究特定类型时就可以工作。</p><p id="7dba" class="pw-post-body-paragraph ko kp hu kq b kr ll iv kt ku lm iy kw kx ln kz la lb lo ld le lf lp lh li lj hn dt translated">在多个条件似乎合理的情况下，编译器对变量使用联合类型。如果可能的类型不支持在其上调用的给定方法，Crystal code <strong class="kq hv">不会编译</strong>。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lr ls l"/></div><figcaption class="ng nh fg fe ff ni nj bd b be z ek">Does not compile!</figcaption></figure><p id="3aad" class="pw-post-body-paragraph ko kp hu kq b kr ll iv kt ku lm iy kw kx ln kz la lb lo ld le lf lp lh li lj hn dt translated">这是编译器保护你避免类型不匹配的愚蠢错误的方法，这在动态语言中很常见。这就像拥有自己的编程助手一样！</p><p id="dc09" class="pw-post-body-paragraph ko kp hu kq b kr ll iv kt ku lm iy kw kx ln kz la lb lo ld le lf lp lh li lj hn dt translated">编译器足够聪明，可以判断出一个变量何时明显来自给定的类型</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lr ls l"/></div></figure><p id="1ebc" class="pw-post-body-paragraph ko kp hu kq b kr ll iv kt ku lm iy kw kx ln kz la lb lo ld le lf lp lh li lj hn dt translated">有一些方法可以确保编译器设置了适当的类型。<br/> <code class="eh lt lu lv lw b">puts a.as(String).camelcase</code> <br/>检查<code class="eh lt lu lv lw b">a</code>变量是否是字符串，如果不是，抛出错误。</p><h2 id="0a96" class="lx jw hu bd jx ly lz ma kb mb mc md kf kx me mf kh lb mg mh kj lf mi mj kl mk dt translated">强制类型</h2><p id="c2c7" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated">正如我们所说的，我们可以选择强制变量的类型或者让它成为其他类型。<br/>这也适用于方法的参数。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lr ls l"/></div></figure><p id="85e3" class="pw-post-body-paragraph ko kp hu kq b kr ll iv kt ku lm iy kw kx ln kz la lb lo ld le lf lp lh li lj hn dt translated">不强制变量通常是一种好的做法，因为它会导致更通用的代码。</p><h2 id="2d59" class="lx jw hu bd jx ly lz ma kb mb mc md kf kx me mf kh lb mg mh kj lf mi mj kl mk dt translated">并发</h2><p id="23d1" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated">其并发模型受Go的启发，即<a class="ae lk" href="https://en.wikipedia.org/wiki/Communicating_sequential_processes" rel="noopener ugc nofollow" target="_blank"> CSP </a>(通信顺序处理)。<br/>它使用轻量级线程(称为纤程),其执行由运行时调度程序管理，而不是操作系统。所述线程之间的通信是通过通道完成的，这些通道可以是缓冲的或无缓冲的。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff nk"><img src="../Images/1d7a31bfd7a89ff20e69f6bed14a191b.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*e5AdUi_a9wliayYFy4bR9g.png"/></div><figcaption class="ng nh fg fe ff ni nj bd b be z ek">A lot of fibers who communicate between each other through channels</figcaption></figure><p id="bdf2" class="pw-post-body-paragraph ko kp hu kq b kr ll iv kt ku lm iy kw kx ln kz la lb lo ld le lf lp lh li lj hn dt translated">Crystal目前在单线程中运行，但是他们的路线图打算实现多线程。这意味着它目前还不支持并行性(除了进程分叉)，但这可能会改变。</p><p id="02d4" class="pw-post-body-paragraph ko kp hu kq b kr ll iv kt ku lm iy kw kx ln kz la lb lo ld le lf lp lh li lj hn dt translated">因为此时只有一个线程在执行你的代码，所以在不同的纤程中访问和修改一个变量就可以了。然而，一旦语言中引入了多线程，它可能会崩溃。这就是为什么推荐的数据通信机制是通过通道。</p><h2 id="4e30" class="lx jw hu bd jx ly lz ma kb mb mc md kf kx me mf kh lb mg mh kj lf mi mj kl mk dt translated">元编程</h2><p id="57e5" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated">Crystal对通过宏进行元编程有很好的支持。宏是在编译期间将代码粘贴到文件中的东西。</p><p id="c2fa" class="pw-post-body-paragraph ko kp hu kq b kr ll iv kt ku lm iy kw kx ln kz la lb lo ld le lf lp lh li lj hn dt translated">让我们定义我们自己版本的Ruby的<code class="eh lt lu lv lw b">attr_writer</code></p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lr ls l"/></div></figure><p id="bf3a" class="pw-post-body-paragraph ko kp hu kq b kr ll iv kt ku lm iy kw kx ln kz la lb lo ld le lf lp lh li lj hn dt translated">调用<code class="eh lt lu lv lw b">attr_writer(foo, Int32)</code>将评估为</p><pre class="jk jl jm jn fq ml lw mm mn aw mo dt"><span id="8c98" class="lx jw hu lw b fv mp mq l mr ms">def foo(foo : Int32)<br/> <a class="ae lk" href="http://twitter.com/foo" rel="noopener ugc nofollow" target="_blank">@foo</a> = foo<br/>end</span></pre><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lr ls l"/></div></figure><p id="3354" class="pw-post-body-paragraph ko kp hu kq b kr ll iv kt ku lm iy kw kx ln kz la lb lo ld le lf lp lh li lj hn dt translated">Crystal宏支持迭代和条件，并且可以访问常量。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lr ls l"/></div></figure><h2 id="5908" class="lx jw hu bd jx ly lz ma kb mb mc md kf kx me mf kh lb mg mh kj lf mi mj kl mk dt translated">多方面的</h2><p id="a60c" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated">Crystal从其他语言中吸取了很多很酷的特性，并提供了各种语法糖，真是太棒了！</p><h2 id="1325" class="lx jw hu bd jx ly lz ma kb mb mc md kf kx me mf kh lb mg mh kj lf mi mj kl mk dt translated">直接在方法中初始化类实例变量</h2><p id="8c39" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated"><code class="eh lt lu lv lw b">def initialize(@name, @age, @gender, @nationality)</code> <br/>等于</p><pre class="jk jl jm jn fq ml lw mm mn aw mo dt"><span id="5ba9" class="lx jw hu lw b fv mp mq l mr ms">def initialize(name, age, gender, nationality)<br/> @name = name<br/> @age = age<br/> @gender = gender<br/> @nationality = nationality<br/>end</span><span id="32ae" class="lx jw hu lw b fv mt mq l mr ms">def initialize(name, age, gender, nationality)<br/> <a class="ae lk" href="http://twitter.com/name" rel="noopener ugc nofollow" target="_blank">@name</a> = name<br/> <a class="ae lk" href="http://twitter.com/age" rel="noopener ugc nofollow" target="_blank">@age</a> = age<br/> <a class="ae lk" href="http://twitter.com/gender" rel="noopener ugc nofollow" target="_blank">@gender</a> = gender<br/> <a class="ae lk" href="http://twitter.com/nationality" rel="noopener ugc nofollow" target="_blank">@nationality</a> = nationality<br/>end</span></pre><h2 id="999e" class="lx jw hu bd jx ly lz ma kb mb mc md kf kx me mf kh lb mg mh kj lf mi mj kl mk dt translated">隐式对象符号</h2><p id="c70a" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated">Switch语句支持调用给定对象上的方法，而无需重复指定其名称。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lr ls l"/></div></figure><h2 id="aa4a" class="lx jw hu bd jx ly lz ma kb mb mc md kf kx me mf kh lb mg mh kj lf mi mj kl mk dt translated">外部关键字参数</h2><p id="2b89" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated">我个人最喜欢的——Crystal允许你为外部世界命名一个函数的参数，为方法体命名一个函数的参数</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lr ls l"/></div><figcaption class="ng nh fg fe ff ni nj bd b be z ek">Hooray, readability!</figcaption></figure><h2 id="8f26" class="lx jw hu bd jx ly lz ma kb mb mc md kf kx me mf kh lb mg mh kj lf mi mj kl mk dt translated">编译程序</h2><p id="538e" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated">正如您前面看到的，这种语言被编译成可执行文件。不管怎样，它仍然有一个类似于REPL的东西，被证明与我们心爱的<code class="eh lt lu lv lw b">irb</code>—<a class="ae lk" href="https://github.com/crystal-community/icr" rel="noopener ugc nofollow" target="_blank">https://github.com/crystal-community/icr</a><br/>你也可以直接运行一个文件，而不必编译它，然后通过<code class="eh lt lu lv lw b">crystal</code>命令运行它。</p><pre class="jk jl jm jn fq ml lw mm mn aw mo dt"><span id="da56" class="lx jw hu lw b fv mp mq l mr ms">&gt; enether$ crystal AA_Tree.cr 200000<br/>Time it took: 0.536102 seconds.</span></pre><p id="324c" class="pw-post-body-paragraph ko kp hu kq b kr ll iv kt ku lm iy kw kx ln kz la lb lo ld le lf lp lh li lj hn dt translated">这运行起来有点慢，因为我们没有利用<code class="eh lt lu lv lw b">- release</code>构建标志本身带来的优化。</p><h2 id="9c40" class="lx jw hu bd jx ly lz ma kb mb mc md kf kx me mf kh lb mg mh kj lf mi mj kl mk dt translated">c绑定</h2><p id="18ce" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated">有一种方法可以在Crystal中编写一个可以在Ruby代码中运行的性能库。你这样做的方法是将Crystal绑定到C，这允许你从Ruby中使用它。<br/>我没有深究这个问题，但显然它很简单，你不用写一行C代码<a class="ae lk" href="https://crystal-lang.org/docs/syntax_and_semantics/c_bindings/" rel="noopener ugc nofollow" target="_blank">就能做到。太棒了。</a></p><h1 id="02f2" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">结论</h1><p id="6ff5" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated">如果您编写Ruby，使用Crystal是很自然的，并且可以很快发现自己在其中编写性能关键的软件。我相信它有很大的潜力，可以给我们的社区带来很多好处，也可以给非ruby程序员带来很多好处，因为语法太容易错过了。写作是一种享受，运行速度也快得惊人，这是很少有语言能与之媲美的独特组合。我希望这些简短的例子已经引起了你的兴趣！我强烈建议你自己看一看这种语言，如果我遗漏了什么，请通知我。</p><p id="4ba9" class="pw-post-body-paragraph ko kp hu kq b kr ll iv kt ku lm iy kw kx ln kz la lb lo ld le lf lp lh li lj hn dt translated">以下是一些可以进一步阅读的资源:<br/> <a class="ae lk" href="https://groups.google.com/forum/#!forum/crystal-lang" rel="noopener ugc nofollow" target="_blank">谷歌集团</a><br/><a class="ae lk" href="https://gitter.im/crystal-lang/crystal" rel="noopener ugc nofollow" target="_blank">Gitter Chat</a><br/><a class="ae lk" href="https://webchat.freenode.net/?channels=%23crystal-lang" rel="noopener ugc nofollow" target="_blank">IRC</a><br/><a class="ae lk" href="https://www.reddit.com/r/crystal_programming/" rel="noopener ugc nofollow" target="_blank">Subreddit</a><br/><a class="ae lk" href="http://crystalweekly.com" rel="noopener ugc nofollow" target="_blank">时事通讯</a></p></div></div>    
</body>
</html>