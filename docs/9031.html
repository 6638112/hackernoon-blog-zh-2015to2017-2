<html>
<head>
<title>A monorepo, GitHub Flow and automation FTW</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">monorepo、GitHub流程和自动化FTW</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-monorepo-github-flow-and-automation-ftw-c41a2d9c48bb?source=collection_archive---------0-----------------------#2017-12-23">https://medium.com/hackernoon/a-monorepo-github-flow-and-automation-ftw-c41a2d9c48bb?source=collection_archive---------0-----------------------#2017-12-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="ec3e" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">我们的生产部署如何从🙀到一块🍰</h2></div><p id="12a6" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">访问https://www.mikenikles.com的<a class="ae kf" href="https://www.mikenikles.com" rel="noopener ugc nofollow" target="_blank"><strong class="jl hv"/></a><strong class="jl hv">获取我的最新博文。</strong></p><p id="6438" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kg">这篇博文是我分享我们从部署在AWS上的单片应用程序(每个都有自己的源代码库)迁移到部署在Google云平台上的分布式服务架构(所有源代码都托管在monorepo中)的系列文章的一部分。</em></p><ul class=""><li id="825f" class="kh ki hu jl b jm jn jp jq js kj jw kk ka kl ke km kn ko kp dt translated"><em class="kg">第1部分(本文):“monorepo、GitHub流和自动化FTW”</em></li><li id="c092" class="kh ki hu jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp dt translated"><em class="kg">第2部分:“</em> <a class="ae kf" rel="noopener" href="/@mikenikles/one-vs-many-why-we-moved-from-multiple-git-repos-to-a-monorepo-and-how-we-set-it-up-f4abb0cfe469"> <em class="kg">一对多——为什么我们从多个git回购转移到一个monorepo，以及我们如何设置它</em></a><em class="kg">”</em></li><li id="8df2" class="kh ki hu jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp dt translated"><em class="kg">第三部分:</em> <a class="ae kf" rel="noopener" href="/@mikenikles/a-mostly-automated-release-process-63bb9516985a"> <em class="kg">一个(大部分)自动化的发布过程</em></a><em class="kg"/></li><li id="91bd" class="kh ki hu jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp dt translated"><em class="kg">第四部分:</em> <a class="ae kf" rel="noopener" href="/@mikenikles/our-approach-to-software-development-consistency-d101995bb843">我们对软件开发一致性的方法</a><em class="kg"/></li><li id="67bf" class="kh ki hu jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp dt translated"><em class="kg">第5部分(即将推出):“本地调试微服务”</em></li></ul><p id="9afe" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我认为在新项目中降低风险的最简单的方法是坚持你所知道的。虽然有时候，为了取得进步，最好走出你的舒适区。</p><h1 id="e2b8" class="kv kw hu bd kx ky kz la lb lc ld le lf ja lg jb lh jd li je lj jg lk jh ll lm dt translated">背景(三层架构)</h1><p id="07a0" class="pw-post-body-paragraph jj jk hu jl b jm ln iv jo jp lo iy jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">2017年早些时候，当我加入一家新的创业公司领导工程团队时，我坚持我所知道的。很快，很明显，一点点的不适和探索正是我们所需要的。不过，首先要说明一下我们做了什么:我们为市场研究人员建立聊天机器人，与他们的社区互动。高层次的要求是:</p><ul class=""><li id="e094" class="kh ki hu jl b jm jn jp jq js kj jw kk ka kl ke km kn ko kp dt translated">一个管理网络界面来创作，部署和监控聊天机器人</li><li id="b7a9" class="kh ki hu jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp dt translated">一个后端系统来处理业务逻辑，验证和处理发送到聊天机器人的消息</li><li id="2a94" class="kh ki hu jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp dt translated">保存所有数据的(关系)数据库</li></ul><p id="ba96" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这就叫“<a class="ae kf" href="https://en.wikipedia.org/wiki/Multitier_architecture#Three-tier_architecture" rel="noopener ugc nofollow" target="_blank"> 3层架构</a>”全部结束了，于是我们构建了一个3层架构。</p><h2 id="e904" class="ls kw hu bd kx lt lu lv lb lw lx ly lf js lz ma lh jw mb mc lj ka md me ll mf dt translated">您如何部署所有代码？</h2><p id="a424" class="pw-post-body-paragraph jj jk hu jl b jm ln iv jo jp lo iy jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated"><em class="kg">回答</em>:你坚持你知道的。在我的例子中，我之前使用了<a class="ae kf" href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow" rel="noopener ugc nofollow" target="_blank"> Gitflow工作流</a>。</p><figure class="mh mi mj mk fq ml fe ff paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="fe ff mg"><img src="../Images/22c1ee84bbc9feb3eb2e635f56bb6fb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J7M-iVWUK02MKEAXr7rzCQ.png"/></div></div><figcaption class="ms mt fg fe ff mu mv bd b be z ek">Gitflow Workflow (Source: <a class="ae kf" href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow" rel="noopener ugc nofollow" target="_blank">Atlassian</a>)</figcaption></figure><p id="b78a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">每当一个特性被合并到<code class="eh mw mx my mz b">develop</code>分支中，<code class="eh mw mx my mz b">develop</code>分支就会被部署到一个阶段环境中。<br/>定期地(稍后会详细介绍)，从<code class="eh mw mx my mz b">develop</code>分支中创建一个<code class="eh mw mx my mz b">release</code>分支，审查并合并到<code class="eh mw mx my mz b">master</code>中。一旦发生这种情况，<code class="eh mw mx my mz b">master</code>就会被部署到生产环境中。</p><p id="6259" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们有多个git存储库(前端、后端、用于长期运行任务的作业服务和一个与后端REST API对话的SDK)。Gitflow工作流适用于所有存储库。</p><h2 id="79c9" class="ls kw hu bd kx lt lu lv lb lw lx ly lf js lz ma lh jw mb mc lj ka md me ll mf dt translated">那么，“周期性”是什么意思呢？</h2><p id="7443" class="pw-post-body-paragraph jj jk hu jl b jm ln iv jo jp lo iy jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">这就是Gitflow工作流出现问题的地方。你在哪个时间点切一个<code class="eh mw mx my mz b">release</code>分支？每周一早上9点？如果有人在早上8:30将一个特性合并到<code class="eh mw mx my mz b">develop</code>中会怎样？你是否在周一上午9点创建一个<code class="eh mw mx my mz b">release</code>分支，彻底测试发布分支，并在周三/周四将<code class="eh mw mx my mz b">release</code>分支合并到<code class="eh mw mx my mz b">master</code>中？？？。谁负责生产部署？</p><p id="572d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在最坏的情况下，创建<code class="eh mw mx my mz b">release</code>分支，测试它并合并到<code class="eh mw mx my mz b">master</code>是一个冗长的过程。不知不觉中，距离您最后一次发布产品已经有一个月或更长时间了。🙀</p><p id="892f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们尝试了各种方法，尝试了更多或更少的自动化，等等。</p><h1 id="73b7" class="kv kw hu bd kx ky kz la lb lc ld le lf ja lg jb lh jd li je lj jg lk jh ll lm dt translated">模块化程度更高，所有代码都在一个monorepo中</h1><p id="93b2" class="pw-post-body-paragraph jj jk hu jl b jm ln iv jo jp lo iy jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">随着我们与上述方法的斗争加剧，我们聚集在白板前，重新定义了我们希望如何部署到生产环境中。</p><p id="2cd0" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">主要目标是更频繁地部署到生产环境中。在最好的情况下，我们在试运行环境中测试完每个拉请求后，就将它发布到生产中。</p><p id="f50b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kg">第一步</em>:将所有代码放入一个monorepo中，以更好地处理依赖关系。(<em class="kg">这个值得自己博文。</em>)</p><p id="e3c9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kg">第二步</em>:去掉<code class="eh mw mx my mz b">develop</code>分支，只剩下<code class="eh mw mx my mz b">master</code>和<code class="eh mw mx my mz b">feature</code>分支。等一下…听起来很熟悉！当然是<a class="ae kf" href="https://guides.github.com/introduction/flow/" rel="noopener ugc nofollow" target="_blank"> GitHub流量</a>💡。</p><p id="0e1a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">第三步:自动化，自动化，自动化！(<em class="kg">值得再发一篇博文……</em>)</p><p id="0f61" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">经过大量白板演示、试验和多次失败的部署后，我们现在有了一个monorepo，遵循GitHub工作流程，每天多次部署到生产环境中。</p><figure class="mh mi mj mk fq ml fe ff paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="fe ff na"><img src="../Images/58bf9b1057955392362e2c11ef78e853.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i8ySffq8oMkVGng82RkDlw.png"/></div></div><figcaption class="ms mt fg fe ff mu mv bd b be z ek">Release Process with a monorepo and the GitHub workflow</figcaption></figure><p id="52ad" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">绿色矩形是完全自动化的，蓝色矩形需要手动批准才能继续工作流程。</p><h1 id="6775" class="kv kw hu bd kx ky kz la lb lc ld le lf ja lg jb lh jd li je lj jg lk jh ll lm dt translated">利益</h1><p id="4cd5" class="pw-post-body-paragraph jj jk hu jl b jm ln iv jo jp lo iy jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">采用上述方法，我们有许多好处:</p><ul class=""><li id="8737" class="kh ki hu jl b jm jn jp jq js kj jw kk ka kl ke km kn ko kp dt translated">生产部署每天会发生几次。每个版本都是以前版本的一小部分。</li><li id="9d48" class="kh ki hu jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp dt translated">将代码部署到生产环境的责任由所有团队成员共同承担。在我们的例子中，拉取请求的审查者部署到试运行和生产。</li><li id="3084" class="kh ki hu jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp dt translated">使用GitHub流程方法，我们需要处理的分支更少，而且发布代码的流程也更少。</li></ul><p id="ded3" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在<a class="ae kf" rel="noopener" href="/@mikenikles/a-mostly-automated-release-process-63bb9516985a">的后续文章</a>中，我将分享CircleCI配置和一些其他工具，它们帮助我们自动化大部分发布过程。</p></div></div>    
</body>
</html>