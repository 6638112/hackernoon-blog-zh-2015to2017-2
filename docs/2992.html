<html>
<head>
<title>RESTful API design with Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node.js的RESTful API设计</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/restful-api-design-with-node-js-26ccf66eab09?source=collection_archive---------0-----------------------#2017-03-05">https://medium.com/hackernoon/restful-api-design-with-node-js-26ccf66eab09?source=collection_archive---------0-----------------------#2017-03-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/669b7e5aec760b9ea999d814750e0020.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jjYC9tuf4C3HkHCP5PcKTA.jpeg"/></div></div></figure><div class=""/><p id="0f7f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Node.js是一个了不起的工具，如果你是初学者、有抱负的程序员或It学生，可能很难理解它，但当你最终习惯它时，它会让你大开眼界。本教程将带您了解API设计的基础知识，教您如何建立REST API的主干，以及如何以逻辑方式构建代码。</p><p id="5607" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">随着教程的进展，我希望你能跟着我一起写代码。每个代码片段后面都会有一个解释，正确理解它的最好方法就是自己一路编码。</p><p id="e290" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在开始之前，您需要了解一些关于Node.js和一些EcmaScript标准的知识，我将在本教程中使用这些标准。我不会使用ES6，因为我认为它不像传统的JavaScript那样对初学者友好。但是，我希望您已经了解Node.js的基础知识，包括如何设置一个基本的节点服务器，该服务器将根据用户访问的路径返回一些信息。如果没有，请绕道，并在继续之前检查这一点。</p><div class="ht hu fm fo hv kb"><a rel="noopener follow" target="_blank" href="/@adnanrahic/hello-world-app-with-node-js-and-express-c1eb7cfa8a30"><div class="kc ab ej"><div class="kd ab ke cl cj kf"><h2 class="bd ig fv z el kg eo ep kh er et ie dt translated">“你好世界！”带有Node.js和Express的应用程序</h2><div class="ki l"><h3 class="bd b fv z el kg eo ep kh er et ek translated">你使用Node…？你会的。</h3></div><div class="kj l"><p class="bd b gc z el kg eo ep kh er et ek translated">medium.com</p></div></div><div class="kk l"><div class="kl l km kn ko kk kp ib kb"/></div></div></a></div><p id="d8de" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">其次，我将使用CommonJS的基本实现。不要担心，这将在下面解释。请随意查看<a class="ae kq" href="https://en.wikipedia.org/wiki/CommonJS" rel="noopener ugc nofollow" target="_blank">这里的</a>，以及<a class="ae kq" href="https://nodejs.org/docs/latest/api/modules.html#modules_the_module_object" rel="noopener ugc nofollow" target="_blank">这里的</a>，以便进一步参考。但是不要忘记回到这个教程。:)<br/>最后，如果你想看完整版，整个演示都在GitHub上。文章底部有链接。</p></div><div class="ab cl kr ks hc kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hn ho hp hq hr"><h1 id="d2c1" class="ky kz if bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv dt translated">准备好代码了吗？</h1><p id="b87c" class="pw-post-body-paragraph jc jd if je b jf lw jh ji jj lx jl jm jn ly jp jq jr lz jt ju jv ma jx jy jz hn dt translated">不，只是开玩笑。我们需要设置和安装应用程序正常工作所需的依赖项和节点模块。由于我们将创建一个API，显然需要一个数据库。我们将使用<a class="ae kq" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>，一个<a class="ae kq" href="https://en.wikipedia.org/wiki/NoSQL" rel="noopener ugc nofollow" target="_blank"> NOSQL数据库</a>。这是满足我们需求的最佳选择，因为我们不需要关系数据库。为了简单起见，我们将在<a class="ae kq" href="https://mlab.com" rel="noopener ugc nofollow" target="_blank"> mLab </a>上连接一个沙盒数据库，而不是在本地安装和运行它。</p><p id="2bd4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是，请记住，mLab就像一个玩具，我建议使用<a class="ae kq" href="https://www.mongodb.com/cloud/atlas" rel="noopener ugc nofollow" target="_blank"> MongoDB Atlas </a>在生产环境中托管您的数据库。这是官方的MongoDB云托管服务。</p><p id="7dc6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">继续，创建一个帐户，并创建一个新的MongoDB部署。</p><figure class="mc md me mf fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mb"><img src="../Images/1a72b4acffbca5ca8d0491ec46d37627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1QZtJo6SiwbClNEnCT0lxg.png"/></div></div><figcaption class="mg mh fg fe ff mi mj bd b be z ek">On the home page of your account create a new MongoDB deployment</figcaption></figure><p id="09c8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">选择免费的沙盒数据库，并给它一个你选择的名字。</p><figure class="mc md me mf fq hw fe ff paragraph-image"><div class="fe ff mk"><img src="../Images/b710b668c02e8a9a9092ed8ac9761251.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BoaDdspS3gd1H74ZWfypig.png"/></div><figcaption class="mg mh fg fe ff mi mj bd b be z ek">Select single-node and sandbox</figcaption></figure><p id="fd1e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">干得好，只需再做一件事，你的数据库就可以运行了。单击您新创建的数据库，并按照黄色文本中的说明进行操作。点击“用户”标签，添加新用户。</p><figure class="mc md me mf fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ml"><img src="../Images/83360935ee50325327ba0081986e8fdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eUe7td5FymLYuPTbFjHjKw.png"/></div></div><figcaption class="mg mh fg fe ff mi mj bd b be z ek">Add a new user to your database</figcaption></figure><p id="d175" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就是这样。数据库现在可以使用了。您将使用数据库名称下面的MongoDB URI连接到它。</p><p id="b394" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">至此，您已经准备好开始配置应用程序本身了。初始化npm并安装以下模块:</p><pre class="mc md me mf fq mm mn mo mp aw mq dt"><span id="8ab4" class="mr kz if mn b fv ms mt l mu mv">npm init<br/>npm install express --save<br/>npm install mongoose --save<br/>npm install body-parser --save</span></pre><p id="9383" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将在这个应用程序中使用<a class="ae kq" href="http://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>，因为它是当今大多数节点应用程序的事实标准。Mongoose是一个<a class="ae kq" href="https://en.wikipedia.org/wiki/Object-relational_mapping" rel="noopener ugc nofollow" target="_blank">ORM——对象关系映射器</a>。准确的说是MongoDB使用的官方ORM。为了分解它，我们使用ORM来简化应用程序和数据库之间的数据传输。它映射我们应用程序中的数据，以支持数据库设置的一组严格规则。body-parser模块只是一个中间件，我们用它来解析通过HTTP请求发送的数据。</p><h1 id="8abf" class="ky kz if bd la lb mw ld le lf mx lh li lj my ll lm ln mz lp lq lr na lt lu lv dt translated">你终于可以写一些代码了。</h1><p id="ef9c" class="pw-post-body-paragraph jc jd if je b jf lw jh ji jj lx jl jm jn ly jp jq jr lz jt ju jv ma jx jy jz hn dt translated">让我们先跳进去，好吗？首先，创建一个应用程序文件，编写一个基本的设置。把这个写到你的<em class="ka"> app.js. </em></p><pre class="mc md me mf fq mm mn mo mp aw mq dt"><span id="8eee" class="mr kz if mn b fv ms mt l mu mv">// app.js<br/>var express = require('express');<br/>var app = express();</span><span id="480c" class="mr kz if mn b fv nb mt l mu mv">module.exports = app;</span></pre><p id="13e0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该文件将用于配置应用程序，仅此而已。所有的逻辑都将被放在与它将要实现的特定特性相关的各自的目录中。当我们使用<code class="eh nc nd ne mn b">require()</code>调用这个app对象时，我们使用<code class="eh nc nd ne mn b">module.exports</code>使它对程序的其余部分可见。</p><p id="4701" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们需要告诉应用程序在哪里听。继续创建另一个名为<em class="ka"> server.js，</em>的文件，并将它记下来。</p><pre class="mc md me mf fq mm mn mo mp aw mq dt"><span id="c54a" class="mr kz if mn b fv ms mt l mu mv">// server.js<br/>var app = require('./app');<br/>var port = process.env.PORT || 3000;</span><span id="c7d6" class="mr kz if mn b fv nb mt l mu mv">var server = app.listen(port, function() {<br/>  console.log('Express server listening on port ' + port);<br/>});</span></pre><p id="5cff" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里你需要应用程序，并把它放在一个变量中。这个app就是你在<em class="ka"> app.js </em>中创建的实际app对象。继续选择应用程序运行的端口，最后用<code class="eh nc nd ne mn b">app.listen</code>启动服务器。继续打开一个终端窗口，测试这是否有效。切换到创建这些文件的目录并运行<code class="eh nc nd ne mn b">node server.js</code>。您应该看到<code class="eh nc nd ne mn b">Express server listening on port 3000</code>被登录到命令行。</p><h1 id="1f69" class="ky kz if bd la lb mw ld le lf mx lh li lj my ll lm ln mz lp lq lr na lt lu lv dt translated">你已经让服务器运行了，万岁！</h1><p id="2418" class="pw-post-body-paragraph jc jd if je b jf lw jh ji jj lx jl jm jn ly jp jq jr lz jt ju jv ma jx jy jz hn dt translated">搞定两个，还剩三个。服务器启动并运行后，现在您需要连接数据库。回到您的文本编辑器，创建一个新文件，非常有创意地命名为<em class="ka"> db.js </em>，因为它将用于存储您的数据库连接。它应该是这样的:</p><pre class="mc md me mf fq mm mn mo mp aw mq dt"><span id="5d5a" class="mr kz if mn b fv ms mt l mu mv">// db.js<br/>var mongoose = require('mongoose');<br/>mongoose.connect('mongodb://yourDatabaseURI');</span></pre><p id="4116" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将<em class="ka"> yourDatabaseURI </em>改为上面提到的URI。回到你的mLab账户，复制MongoDB URI。将它粘贴到您的代码中，在两个引号之间。为您创建的用户更改您输入的凭证的&lt; dbuser &gt;和&lt; dbpassword &gt;。完成这些后，你现在需要告诉应用程序它有一个可用的连接。只需在<em class="ka"> app.js </em>中添加一个<code class="eh nc nd ne mn b">require()</code>，就像这样:</p><pre class="mc md me mf fq mm mn mo mp aw mq dt"><span id="2a97" class="mr kz if mn b fv ms mt l mu mv">// app.js</span><span id="a32c" class="mr kz if mn b fv nb mt l mu mv">var express = require('express');<br/>var app = express();<br/>var db = require('./db'); //ADD THIS LINE</span><span id="6fda" class="mr kz if mn b fv nb mt l mu mv">module.exports = app;</span></pre><p id="5a60" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过这样指定，我们告诉require在<em class="ka"> app.js </em>所在的同一个目录中抓取一个文件并包含它。就是这样。现在我们的应用程序知道它有一个准备好的数据库，等待被访问。</p><p id="5b84" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你的程序现在应该有三个文件。一个<em class="ka"> app.js </em>用于配置应用程序，一个<em class="ka"> db.js </em>用于指定到数据库的连接，一个<em class="ka"> server.js </em>用于在您选择的特定端口上启动节点服务器。</p><p id="80f1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在您已经准备好开始编写程序的业务逻辑了。</p><h1 id="53d4" class="ky kz if bd la lb mw ld le lf mx lh li lj my ll lm ln mz lp lq lr na lt lu lv dt translated">言归正传。</h1><p id="d684" class="pw-post-body-paragraph jc jd if je b jf lw jh ji jj lx jl jm jn ly jp jq jr lz jt ju jv ma jx jy jz hn dt translated">首先创建一个名为<em class="ka"> user的新文件夹。</em>该文件夹将包含与我们关于用户的数据库通信相关的所有文件。您将从创建一个用户模型开始。这个模型将作为一个蓝图，展示数据库中所有用户的样子。创建一个名为<em class="ka"> User.js </em>的文件，并编写这段代码:</p><pre class="mc md me mf fq mm mn mo mp aw mq dt"><span id="1751" class="mr kz if mn b fv ms mt l mu mv">// User.js<br/>var mongoose = require('mongoose');  <br/>var UserSchema = new mongoose.Schema({  <br/>  name: String,<br/>  email: String,<br/>  password: String<br/>});<br/>mongoose.model('User', UserSchema);</span><span id="853e" class="mr kz if mn b fv nb mt l mu mv">module.exports = mongoose.model('User');</span></pre><p id="71a1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您正在创建一个模式，它将为数据库中的每个用户提供特定的外观。用户将有一个名字，一个电子邮件和一个密码。通过指定<code class="eh nc nd ne mn b">mongoose.model('User', UserSchema)</code>，您将模式的布局绑定到名为<code class="eh nc nd ne mn b">'User'</code>的模型。这是您将用来访问数据库中的数据的内容，这也是您将它导出以在程序的其他部分使用的原因。</p><p id="347a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在有趣的部分来了，为你的应用程序创建路线，并将它们绑定到各自的动作。</p><p id="5719" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">创建另一个文件，命名为<em class="ka"> UserController.js。</em>您将在它的名字中用<em class="ka">控制器</em>来命名它，这不仅是为了简单，还因为它将包含控制数据流入和流出数据库的动作。</p><pre class="mc md me mf fq mm mn mo mp aw mq dt"><span id="70bc" class="mr kz if mn b fv ms mt l mu mv">// UserController.js</span><span id="83b3" class="mr kz if mn b fv nb mt l mu mv">var express = require('express');<br/>var router = express.Router();<br/>var bodyParser = require('body-parser');<br/>router.use(bodyParser.urlencoded({ extended: true }));<br/>router.use(bodyParser.json());</span><span id="b72a" class="mr kz if mn b fv nb mt l mu mv">var User = require('./User');</span><span id="b54e" class="mr kz if mn b fv nb mt l mu mv">module.exports = router;</span></pre><p id="24c1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面是用户控制器的裸布局。您将使用快速路由器创建一个路由子集，该子集可以是模块化的，并且独立于整个应用程序。如果你需要重新构建你的程序，你可以很容易地做到，因为这种方法给了你从一个地方把它从<em class="ka">插入</em>而从另一个地方把它从<em class="ka">插入</em>的能力。主体解析器模块被用作中间件，以更优雅的方式处理数据。这在使用表单通过HTTP请求发送数据时会很方便。</p><p id="9ce6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">好玩的部分只有<code class="eh nc nd ne mn b">require('./User')</code>才有。现在你明白了为什么需要从<em class="ka"> User.js. </em>中导出模型。你将在<em class="ka"> UserController.js. </em>中真正使用它。每当你像上面那样创建一个模型时，它会自动接收与数据库交互的所有必要方法，包括创建、读取、更新和删除动作。最后，在文件的底部，导出路由器，因为在<em class="ka"> app.js </em>中需要它。</p><h1 id="bcc0" class="ky kz if bd la lb mw ld le lf mx lh li lj my ll lm ln mz lp lq lr na lt lu lv dt translated">我跑题了！</h1><p id="c7b6" class="pw-post-body-paragraph jc jd if je b jf lw jh ji jj lx jl jm jn ly jp jq jr lz jt ju jv ma jx jy jz hn dt translated">让我们简单介绍一下REST，以便更好地理解与数据库交互的4个操作。他们被称为CRUD。代表<strong class="je ig"> C </strong> reate，<strong class="je ig"> R </strong> ead，<strong class="je ig"> U </strong> pdate，<strong class="je ig"> D </strong> elete。使用HTTP请求，我们可以使用各自的动作来触发这四个CRUD操作中的每一个。</p><ul class=""><li id="0648" class="nf ng if je b jf jg jj jk jn nh jr ni jv nj jz nk nl nm nn dt translated"><strong class="je ig"> POST </strong>用于向服务器发送数据— <strong class="je ig"> Create </strong></li><li id="4a36" class="nf ng if je b jf no jj np jn nq jr nr jv ns jz nk nl nm nn dt translated"><strong class="je ig"> GET </strong>用于从服务器获取数据— <strong class="je ig"> Read </strong></li><li id="fe59" class="nf ng if je b jf no jj np jn nq jr nr jv ns jz nk nl nm nn dt translated"><strong class="je ig"> PUT </strong>用于发送和更新数据— <strong class="je ig"> Update </strong></li><li id="6222" class="nf ng if je b jf no jj np jn nq jr nr jv ns jz nk nl nm nn dt translated"><strong class="je ig">删除</strong>用于删除数据— <strong class="je ig">删除</strong></li></ul><p id="3728" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">理解这一点的最好方法是直接投入进去。</p><h1 id="5a71" class="ky kz if bd la lb mw ld le lf mx lh li lj my ll lm ln mz lp lq lr na lt lu lv dt translated">回到正题。</h1><pre class="mc md me mf fq mm mn mo mp aw mq dt"><span id="e6f0" class="mr kz if mn b fv ms mt l mu mv">// UserController.js</span><span id="48a6" class="mr kz if mn b fv nb mt l mu mv">var express = require('express');<br/>var router = express.Router();<br/>var bodyParser = require('body-parser');</span><span id="98d4" class="mr kz if mn b fv nb mt l mu mv">router.use(bodyParser.urlencoded({ extended: true }));<br/>router.use(bodyParser.json());<br/>var User = require('./User');</span><span id="f2e3" class="mr kz if mn b fv nb mt l mu mv">// ADD THIS PART</span><span id="5e80" class="mr kz if mn b fv nb mt l mu mv">// CREATES A NEW USER<br/>router.post('/', function (req, res) {</span><span id="1255" class="mr kz if mn b fv nb mt l mu mv">    User.create({<br/>            name : req.body.name,<br/>            email : req.body.email,<br/>            password : req.body.password<br/>        }, <br/>        function (err, user) {<br/>            if (err) return res.status(500).send("There was a problem adding the information to the database.");<br/>            res.status(200).send(user);<br/>        });</span><span id="20aa" class="mr kz if mn b fv nb mt l mu mv">});</span><span id="3b84" class="mr kz if mn b fv nb mt l mu mv">// RETURNS ALL THE USERS IN THE DATABASE<br/>router.get('/', function (req, res) {</span><span id="b2bb" class="mr kz if mn b fv nb mt l mu mv">    User.find({}, function (err, users) {<br/>        if (err) return res.status(500).send("There was a problem finding the users.");<br/>        res.status(200).send(users);<br/>    });</span><span id="4de6" class="mr kz if mn b fv nb mt l mu mv">});</span><span id="6749" class="mr kz if mn b fv nb mt l mu mv">module.exports = router;</span></pre><p id="3b15" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">查看第一个方法，您会看到router对象有一个带两个参数的<code class="eh nc nd ne mn b">.post</code>方法。第一个是将被链接到一个函数的路由。这个函数是第二个参数。它需要另外两个参数，这两个参数代表对服务器的请求和来自服务器的响应。在函数内部，您将使用上面要求的用户模型。用户模型有一个create方法，它也接受两个参数。第一个是对象，第二个是函数。该对象包含要插入数据库的值。你看，它们的结构就像你在上面创建的模式一样。创建后，回调函数用另外两个参数调用，一个<strong class="je ig">错误</strong>值和一个<strong class="je ig">成功</strong>值。您将检查在创建新用户的过程中是否有错误，并做出相应的响应，或者如果一切正常，则使用新创建的用户的数据进行响应。</p><p id="232a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第二种方法简单一点。路由器对象也有一个<code class="eh nc nd ne mn b">.get</code>方法，它也有两个参数。在这个函数中，您现在调用用户模型上的<code class="eh nc nd ne mn b">find()</code>方法，它也接受两个参数。Find是一种从数据库中返回值的方法。它的第一个参数是一个对象，定义了返回值必须满足的要求。因为在本例中对象是空的，所以将返回数据库中的所有用户。</p><p id="6a36" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，您需要让应用程序知道它有一个用户控制器。将此添加到您的<em class="ka"> app.js </em>中。</p><pre class="mc md me mf fq mm mn mo mp aw mq dt"><span id="7ce9" class="mr kz if mn b fv ms mt l mu mv">// app.js</span><span id="6406" class="mr kz if mn b fv nb mt l mu mv">var express = require('express');<br/>var app = express();<br/>var db = require('./db');</span><span id="92d9" class="mr kz if mn b fv nb mt l mu mv">// ADD THESE TWO LINES<br/>var UserController = require('./user/UserController');<br/>app.use('/users', UserController);</span><span id="2428" class="mr kz if mn b fv nb mt l mu mv">module.exports = app;</span></pre><p id="8d6c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这到底是什么魔法？我们真的没什么。你要求用户控制器和<code class="eh nc nd ne mn b">app.use</code>告诉应用程序链接到路线<code class="eh nc nd ne mn b">/users</code>。现在，用户控制器中的<code class="eh nc nd ne mn b">/</code>路线将被映射到<code class="eh nc nd ne mn b">/users</code>。这太酷了，对吧！？</p><h1 id="b3cb" class="ky kz if bd la lb mw ld le lf mx lh li lj my ll lm ln mz lp lq lr na lt lu lv dt translated">你测试过吗，兄弟？</h1><p id="370f" class="pw-post-body-paragraph jc jd if je b jf lw jh ji jj lx jl jm jn ly jp jq jr lz jt ju jv ma jx jy jz hn dt translated">唷，那是一把。让我们休息一下，测试一下我们的应用程序。对于测试API，我总是使用<a class="ae kq" href="https://www.getpostman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>。这是一个非常棒的工具，可以测试所有4个HTTP动作的URL。它还增加了在HTTP请求体中发送数据的可能性。正是你需要测试你的应用。下载、安装并启动Postman，然后跟随。</p><p id="a1cb" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Postman是一个非常基本的工具，你输入想要发送HTTP请求的URL，选择一个方法，如果需要，输入参数。让我们从向<code class="eh nc nd ne mn b">http://localhost:3000/users</code>发送POST请求开始。这意味着您需要在请求正文中输入一组参数。</p><figure class="mc md me mf fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nt"><img src="../Images/9d3f751905fb7617a18b3dadc0670d5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rkgRt0nyzHd3fO5MhGQkfw.png"/></div></div></figure><p id="c90c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">切换到body选项卡，输入与您之前创建的用户模型相匹配的键-值对。你需要一个名字，一个电子邮件和一个密码。点击发送。瞧啊。一个回应。如果一切顺利，响应将包含与最近创建的用户相匹配的数据。</p><p id="7a7a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，继续将HTTP方法改为GET，并再次点击send。您将看到所有创建的用户都从数据库中返回。继续使用它，添加更多的用户，并观察GET请求的行为。</p><h1 id="be3b" class="ky kz if bd la lb mw ld le lf mx lh li lj my ll lm ln mz lp lq lr na lt lu lv dt translated">回到代码。</h1><p id="f5b6" class="pw-post-body-paragraph jc jd if je b jf lw jh ji jj lx jl jm jn ly jp jq jr lz jt ju jv ma jx jy jz hn dt translated">到目前为止，您已经设置了一个服务器，配置了您的应用程序，将它连接到一个数据库，并创建了两个用于与数据库通信的API。还有三个API需要实现。从数据库中检索单个用户，更新用户，最后删除用户。所有这些都有一个共同点。它们都有一个查询参数，通常称为路径参数。不要害怕。它只是一个将随请求传递的值。让我们跳进来。</p><pre class="mc md me mf fq mm mn mo mp aw mq dt"><span id="bb84" class="mr kz if mn b fv ms mt l mu mv">// UserController.js</span><span id="e6d1" class="mr kz if mn b fv nb mt l mu mv">//...</span><span id="7c40" class="mr kz if mn b fv nb mt l mu mv">// GETS A SINGLE USER FROM THE DATABASE<br/>router.get('/:id', function (req, res) {</span><span id="0df7" class="mr kz if mn b fv nb mt l mu mv">    User.findById(req.params.id, function (err, user) {<br/>        if (err) return res.status(500).send("There was a problem finding the user.");<br/>        if (!user) return res.status(404).send("No user found.");<br/>        res.status(200).send(user);<br/>    });</span><span id="1aa8" class="mr kz if mn b fv nb mt l mu mv">});</span><span id="3cd0" class="mr kz if mn b fv nb mt l mu mv">//...</span></pre><p id="ff56" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在您已经添加了另一个GET请求，但是看看route,<code class="eh nc nd ne mn b">router.get</code>方法的第一个参数。现在，它有一个由冒号后跟一些文本组成的值。这个符号意味着它是一个查询参数的占位符，一个简单的值，它将随请求一起发送。传递给<code class="eh nc nd ne mn b">'/:id'</code>的值可以通过<code class="eh nc nd ne mn b">req.params</code>对象访问。其中查询参数的名称将被映射到<code class="eh nc nd ne mn b">req.params</code>对象上具有相同名称的属性。</p><p id="0503" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">继续，Mongoose有一个很棒的方法叫做<code class="eh nc nd ne mn b">.findById</code>,它只需要返回用户的ID。ID是第一个参数，回调函数是第二个参数。你能看到一种模式出现了吗？所有的Mongoose方法都需要一个值作为第一个参数，一个回调函数作为最后一个参数。这个回调将在数据库返回查询值后被调用。删除请求也可以看到相同的模式。</p><pre class="mc md me mf fq mm mn mo mp aw mq dt"><span id="ec46" class="mr kz if mn b fv ms mt l mu mv">// UserController.js</span><span id="9099" class="mr kz if mn b fv nb mt l mu mv">//...</span><span id="dab8" class="mr kz if mn b fv nb mt l mu mv">// DELETES A USER FROM THE DATABASE<br/>router.delete('/:id', function (req, res) {</span><span id="0d73" class="mr kz if mn b fv nb mt l mu mv">    User.findByIdAndRemove(req.params.id, function (err, user) {<br/>        if (err) return res.status(500).send("There was a problem deleting the user.");<br/>        res.status(200).send("User "+ user.name +" was deleted.");<br/>    });</span><span id="6f05" class="mr kz if mn b fv nb mt l mu mv">});</span><span id="df6e" class="mr kz if mn b fv nb mt l mu mv">//...</span></pre><p id="41f2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh nc nd ne mn b">router.delete</code>方法看起来和上面的<code class="eh nc nd ne mn b">router.get</code>完全一样。甚至猫鼬方法看起来都一样，除了它的名字。您将通过向方法提供您想要删除的用户的ID来从数据库中删除用户。<code class="eh nc nd ne mn b">.findByIdAndRemove</code>方法会像<code class="eh nc nd ne mn b">findById</code>一样找到一个用户，但也会将其从数据库中删除。</p><p id="b8ec" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">应用程序的最后一步是实现一种更新数据库中现有用户的方法。这是通过PUT请求完成的。</p><pre class="mc md me mf fq mm mn mo mp aw mq dt"><span id="69fe" class="mr kz if mn b fv ms mt l mu mv">// UserController.js</span><span id="4482" class="mr kz if mn b fv nb mt l mu mv">//...</span><span id="bbc5" class="mr kz if mn b fv nb mt l mu mv">// UPDATES A SINGLE USER IN THE DATABASE<br/>router.put('/:id', function (req, res) {<br/>    <br/>    User.findByIdAndUpdate(req.params.id, req.body, {new: true}, function (err, user) {<br/>        if (err) return res.status(500).send("There was a problem updating the user.");<br/>        res.status(200).send(user);<br/>    });</span><span id="4da8" class="mr kz if mn b fv nb mt l mu mv">});</span><span id="5c1f" class="mr kz if mn b fv nb mt l mu mv">//...</span></pre><p id="e654" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh nc nd ne mn b">router.put</code>请求和你上面写的两个请求很像。它还接受一个查询参数，一个ID。与众不同的是，它还需要主体参数，就像您首先编写的POST请求一样。唯一有主体的HTTP方法是POST和PUT。记住这一点。</p><p id="5548" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">想猜猜<code class="eh nc nd ne mn b">.findByIdAndUpdate</code>是做什么的吗？你说得对。这个方法和你上面写的有点不一样。它有三个主要参数，一个ID，一个对应于其值将被更新的用户的对象，当然还有一个回调函数。您将把请求体作为第二个参数传递，即对象，因为它已经被我们需要的中间件正确解析，并在<em class="ka"> UserController.js </em>的顶部使用。更新某些值时，一个好的做法是请求将更新后的值发送给您。这一点很重要，因为您希望能够访问最新更新的值。因此，您添加了另一个第四参数<code class="eh nc nd ne mn b">{new:true}</code>,它代表您想要返回哪个版本的值的选项，在您的例子中是用户。更新前的那个，还是更新后的那个。返回该值将显示您更新的用户。</p><h1 id="c755" class="ky kz if bd la lb mw ld le lf mx lh li lj my ll lm ln mz lp lq lr na lt lu lv dt translated">准备好接受更多测试了吗？</h1><p id="71aa" class="pw-post-body-paragraph jc jd if je b jf lw jh ji jj lx jl jm jn ly jp jq jr lz jt ju jv ma jx jy jz hn dt translated">编程通常是混乱和宁静之间的平衡。解决看似不合逻辑的问题时的混乱，与最终解决问题时的平静。测试是你获得平静的方法。我遇到过一句话，这句话深深植根于我见过的所有程序员的思维模式中。</p><blockquote class="nu"><p id="8aca" class="nv nw if bd nx ny nz oa ob oc od jz ek translated">编写在第一次尝试、第一次编译或第一次运行时有效的代码被称为编程大奖。</p><p id="38c1" class="nv nw if bd nx ny nz oa ob oc od jz ek translated">—每一个程序员</p></blockquote><p id="ab64" class="pw-post-body-paragraph jc jd if je b jf oe jh ji jj of jl jm jn og jp jq jr oh jt ju jv oi jx jy jz hn dt translated">当它真的发生时，如果有的话，你会觉得好像是太阳特意选择照耀在你身上。不要习惯这个。建立这样一种认识:这种事情永远不会发生。你需要点击东西，按下按钮，并投入到开发工具中，才能平息混乱，获得宁静。</p><p id="093d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">准备好了吗？让我们按一些按钮。</p><p id="eb39" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">再次打开命令提示符，用<code class="eh nc nd ne mn b">node server.js</code>启动服务器。打开Postman，继续尝试你刚刚创建的新方法。针对单个用户的普通GET请求看起来有点像这样:</p><figure class="mc md me mf fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff oj"><img src="../Images/d2962277c2cebfdcc157e42ad9aa1029.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c-zJXFbAnxa5_EhKvHXr4Q.png"/></div></div></figure><p id="0313" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将用户的ID作为查询参数添加到URL中实际上只会返回具有该特定ID的用户。</p><p id="980f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">转到PUT请求，将方法更改为PUT，向主体添加值(确保属性与您在上面创建的用户模式的属性相匹配),然后点击send。</p><figure class="mc md me mf fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ok"><img src="../Images/6cf0c4e77f3ea5cd82498ab3e5f3562c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FZCmeX72a6hLfiTtx2VCJA.png"/></div></div></figure><p id="83ff" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您已经将“admin”的名称更改为“imNotTheAdminAnymore”。</p><p id="b96c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你明白这一点，删除方法将是小菜一碟。将方法更改为删除，并再次点击发送。现在，您将从数据库中删除具有给定ID的用户。</p><figure class="mc md me mf fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ol"><img src="../Images/81ff091ff60c7cf235dfbe775ba26036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iLV6tsWEbpbU5z2fxZ5k4g.png"/></div></div></figure><p id="faf5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我知道这么快让你明白所有的事情是很困难的。这也是我把所有代码都推给GitHub的原因。如果你在某个地方卡住了，请随意查看整个项目的整体<a class="ae kq" href="https://github.com/adnanrahic/nodejs-restful-api" rel="noopener ugc nofollow" target="_blank">这里</a>。或者如果你想看我最新的文章，请到这里来。</p><div class="ht hu fm fo hv kb"><a href="https://medium.com/@adnanrahic/latest" rel="noopener follow" target="_blank"><div class="kc ab ej"><div class="kd ab ke cl cj kf"><h2 class="bd ig fv z el kg eo ep kh er et ie dt translated">阿德南·拉希奇写的最新故事</h2><div class="ki l"><h3 class="bd b fv z el kg eo ep kh er et ek translated">阅读Adnan Rahi在Medium上写的最新故事。软件工程师@bookvar_co .编码教育家@ACADEMY387…</h3></div><div class="kj l"><p class="bd b gc z el kg eo ep kh er et ek translated">medium.com</p></div></div><div class="kk l"><div class="om l km kn ko kk kp ib kb"/></div></div></a></div></div><div class="ab cl kr ks hc kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hn ho hp hq hr"><h1 id="2a40" class="ky kz if bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv dt translated">所以你认为就这样了？</h1><p id="dbe3" class="pw-post-body-paragraph jc jd if je b jf lw jh ji jj lx jl jm jn ly jp jq jr lz jt ju jv ma jx jy jz hn dt translated">你只是刮到了冰山的一角。但是，现在已经足够了。保持好奇，提出问题，并不断按下按钮。我已经给了你在成为明星的过程中需要知道的许多核心技能的基础。</p><p id="0778" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不要让Node吓到你。这只是普通的JavaScript。用在浏览器中编写代码的方式来查看它。分解一下，它只是一堆事件侦听器和处理程序。例如:</p><pre class="mc md me mf fq mm mn mo mp aw mq dt"><span id="1718" class="mr kz if mn b fv ms mt l mu mv">router.get('/:id', function (req, res) {</span><span id="efb0" class="mr kz if mn b fv nb mt l mu mv">    User.findById(req.params.id, function (err, user) {<br/>        if (err) return res.status(500).send("There was a problem finding the user.");<br/>        if (!user) return res.status(404).send("No user found.");<br/>        res.status(200).send(user);<br/>    });</span><span id="88d6" class="mr kz if mn b fv nb mt l mu mv">});</span></pre><p id="c46d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">服务器正在侦听HTTP请求，以使用GET方法找到路由<code class="eh nc nd ne mn b">'/:id'</code>。当这样的请求发生时，回调函数将被调用。这个函数中的所有内容都将被计算和执行。很熟悉不是吗？</p><pre class="mc md me mf fq mm mn mo mp aw mq dt"><span id="452a" class="mr kz if mn b fv ms mt l mu mv">button.addEventListener('click', function (e) {<br/>    <br/>    console.log("Well it's very familiar for me.");</span><span id="5f1e" class="mr kz if mn b fv nb mt l mu mv">});</span></pre></div><div class="ab cl kr ks hc kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hn ho hp hq hr"><p id="3d7e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">希望你们喜欢读这篇文章，就像我喜欢写这篇文章一样。很好奇，它确实帮了我很多。</p><p id="32eb" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">你觉得这个教程会对某个人有帮助吗？不要犹豫分享。如果你喜欢它，点击下面的</em> <strong class="je ig"> <em class="ka">【击掌】</em> </strong> <em class="ka">，这样其他人会在媒体上看到它。</em></p><p id="f584" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">感谢我的父亲，他是我的灵感来源，并一直让我保持好奇。</p></div></div>    
</body>
</html>