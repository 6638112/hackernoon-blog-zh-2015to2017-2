<html>
<head>
<title>Making Life Easier for Java Devs: ModRun vs. Project Jigsaw</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让Java开发者的生活更轻松:ModRun vs . Jigsaw项目</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/making-life-easier-for-java-devs-modrun-vs-project-jigsaw-747094d114a4?source=collection_archive---------4-----------------------#2016-12-15">https://medium.com/hackernoon/making-life-easier-for-java-devs-modrun-vs-project-jigsaw-747094d114a4?source=collection_archive---------4-----------------------#2016-12-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/81373a5337b83cf4e29eee6a3fd47874.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k6TjvaZiLQODcI4fDZKPsg.png"/></div></div></figure><p id="bea9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<a class="ae ka" href="https://hackernoon.com/modrun-java-classloading-made-easy-1dfd0d64f780#.ams4oy2xb" rel="noopener ugc nofollow" target="_blank">之前的帖子</a>中，我们基本上介绍了<a class="ae ka" href="https://github.com/nanosai/modrun" rel="noopener ugc nofollow" target="_blank"> ModRun </a>作为一个Java类加载器，能够直接从Maven仓库加载和运行类，并在运行时解析依赖关系。今天，我们将更进一步，将<a class="ae ka" href="https://github.com/nanosai/modrun" rel="noopener ugc nofollow" target="_blank"> ModRun </a>作为一款有用的多功能工具，帮助Java开发人员发布、(卸载)、安装、运行和升级Java应用，同时解决一些所谓的“T6项目拼图”还没有解决的问题(据我们所知)。</p><p id="3121" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你是一个Java开发者，我们不需要提醒你安装和运行Java应用程序的挑战和麻烦。是的，有几个模型试图解决这个问题，但在我们看来，它们都没有真正成功地使Java应用程序的安装和启动像我们应该用<a class="ae ka" href="https://github.com/nanosai/modrun" rel="noopener ugc nofollow" target="_blank"> ModRun </a>做的那样简单。尤其是当您使用各种服务的最新版本来更新多台服务器时。</p><p id="9999" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们继续之前，我们将把<a class="ae ka" href="https://github.com/nanosai/modrun" rel="noopener ugc nofollow" target="_blank"> ModRun </a>的定义扩展为一个Java应用程序安装器/启动器/类加载器，它可以直接从Maven存储库中加载和运行模块。另一种描述ModRun的方式是把它看作Java应用程序的NPM或RPM。现在我们已经扩展了ModRun的定义，让我们与您分享随着项目的成熟，我们计划如何在未来几周/几个月内解决以下问题:</p><ul class=""><li id="c411" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">Java应用程序的发布。</li><li id="c9de" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">从远程存储库安装Java应用程序。</li><li id="a4e6" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">运行存储在本地Maven存储库中的Java应用程序。</li><li id="5fa1" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">升级Java应用程序。</li><li id="d1ad" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">卸载Java应用程序。</li></ul><h2 id="cf1f" class="kp kq hu bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated">Java应用程序的发布</h2><p id="bc91" class="pw-post-body-paragraph jc jd hu je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">由于ModRun可以直接从Maven资源库下载应用程序，所以开发人员发布Java应用程序所需要做的就是将其Maven工件(JAR文件)发布到Maven资源库。ModRun可以从那里下载它，解析它的依赖项并下载它们。</p><p id="c4ee" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将应用程序发布到Maven存储库使得发布非常标准化和小。开发人员只需上传他们的应用程序的JAR文件，假设所有的依赖项都已经存储在Maven存储库中。</p><p id="197b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">安装Java应用程序</strong></p><p id="cafa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如前所述，ModRun将能够直接从Maven仓库下载应用程序的JAR文件。ModRun将JAR文件本地存储在对应于本地Maven存储库的位置(JAR和POM文件的目录结构和位置相同)。这使得应用程序及其依赖项的安装非常标准化。</p><p id="3d36" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将应用程序JAR文件及其依赖项保存在本地Maven存储库结构中，可以很容易地同时安装应用程序的多个版本。</p><h2 id="d73e" class="kp kq hu bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated">运行Java应用程序</h2><p id="8f99" class="pw-post-body-paragraph jc jd hu je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">一旦Java应用程序的JAR文件位于本地Maven存储库结构中，ModRun就可以从那里加载并运行应用程序。所有需要做的就是给ModRun本地Maven存储库目录的路径，以及要运行的groupId、artifactId、artifactVersion和main类，加上应用程序需要的任何其他命令行参数。</p><p id="83cc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用ModRun运行Java应用程序使得类路径非常简单。类路径中只需要ModRun的JAR文件。应用程序工件及其依赖项都在运行时解析，并使用ModRun的特殊类加载器结构加载。</p><p id="fe2d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">ModRun特殊的类加载器结构可以在运行时解析和加载Maven工件的依赖关系。类加载器结构能够将一个模块(工件)的依赖关系与其他工件的依赖关系隔离开来。这意味着可以将同一个工件的不同版本加载到内存中，甚至是在同一个应用程序中(只要满足某些条件)。ModRun还可以将同一个应用多次加载到同一个JVM中(或者不同的应用)，并使它们彼此完全隔离。从安全角度来说很好！:)</p><h2 id="33b2" class="kp kq hu bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated">升级Java应用程序</h2><p id="3e46" class="pw-post-body-paragraph jc jd hu je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">用ModRun升级一个Java应用程序并不比一开始安装它更难！新版本是从远程Maven仓库下载的，并与任何新的依赖项一起安装在本地。</p><h2 id="08d6" class="kp kq hu bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated">卸载Java应用程序和依赖项</h2><p id="afdc" class="pw-post-body-paragraph jc jd hu je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">当ModRun在本地Maven存储库结构中安装工件时，它会跟踪哪些工件是应用程序，哪些只是依赖关系。通过这种方式，ModRun可以轻松卸载一个应用程序，或者一个应用程序的特定版本。</p><p id="e5c5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">卸载应用程序后，ModRun可以遍历整个本地Maven存储库结构，并找出哪些依赖项不再被任何应用程序引用。然后也可以删除这些依赖项(如果将来需要，它们总是可以很容易地再次下载)。</p><h1 id="2763" class="lp kq hu bd kr lq lr ls kv lt lu lv kz lw lx ly lc lz ma mb lf mc md me li mf dt translated">魔龙大战竖锯</h1><p id="3b16" class="pw-post-body-paragraph jc jd hu je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">ModRun解决了一些与Java 9中的Jigsaw项目相同的问题。然而，Jigsaw没有解决工件版本控制，也没有提供标准化的Java应用程序/模块存储库结构，也没有提供标准化的安装和卸载程序(据我们所知)。ModRun提供了所有这些！ModRun当然适用于Java 8，我们将确保它也适用于Java 9。</p><p id="0183" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，除了上面几节中描述的特性，我们还有许多关于ModRun的其他想法。例如，保持大型服务器网格与相同的Java应用程序保持同步的特性(<strong class="je hv">例如微服务</strong>)，或者成组升级服务器(alpha服务器、beta服务器等)。</p><h2 id="b8d9" class="kp kq hu bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated"><strong class="ak"> ModRun GitHub资源库</strong></h2><p id="1300" class="pw-post-body-paragraph jc jd hu je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">ModRun是开源的(Apache license 2.0)，可以在<a class="ae ka" href="https://github.com/nanosai/modrun" rel="noopener ugc nofollow" target="_blank"> GitHub这里</a>找到。如果你喜欢它，请随时查看并开始使用它，还有一些由我们的联合创始人兼首席技术官Jakob Jenkov在<a class="ae ka" href="http://www.nanosai.com" rel="noopener ugc nofollow" target="_blank"> Nanosai </a>写的<a class="ae ka" href="http://tutorials.jenkov.com/modrun/index.html" rel="noopener ugc nofollow" target="_blank">教程</a>。</p><div class="mg mh mi mj fq ab cb"><figure class="mk iv ml mm mn mo mp paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mk iv ml mm mn mo mp paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mk iv ml mm mn mo mp paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mq mr ms"><p id="f922" class="jc jd mt je b jf jg jh ji jj jk jl jm mu jo jp jq mv js jt ju mw jw jx jy jz hn dt translated"><a class="ae ka" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是阿妹家庭的一员。我们现在<a class="ae ka" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ka" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd mt je b jf jg jh ji jj jk jl jm mu jo jp jq mv js jt ju mw jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ka" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ka" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="mg mh mi mj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mx"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>