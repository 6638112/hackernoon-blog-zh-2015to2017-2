<html>
<head>
<title>Idempotency, APIs, and Retries — Oh My!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">幂等性、API和重试——天哪！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/idempotency-apis-and-retries-34b161f64cb4?source=collection_archive---------2-----------------------#2017-03-31">https://medium.com/hackernoon/idempotency-apis-and-retries-34b161f64cb4?source=collection_archive---------2-----------------------#2017-03-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/b52db113632a0dc757b35a83c889ab82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CRA0XvNbeo3DJLpp6ojH1g.png"/></div></div></figure><p id="fcf5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在当今世界，应用程序分布在许多网络组件上是很常见的。无论这些组件是您自己的堆栈中的微服务还是第三方SaaS API，依赖它们的组件都需要能够与它们对话。这通常是通过API客户机来完成的，通常只是一个简单的类，提供易于使用的方法来包装HTTP请求。</p><h1 id="3c05" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">一个示例客户端</h1><p id="9a5d" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">ButterCMS 是一个SaaS API与相关客户端的很好的例子。ButterCMS是一个“内容<a class="ae ld" href="https://hackernoon.com/tagged/management" rel="noopener ugc nofollow" target="_blank">管理</a>系统即服务”——CMS的<a class="ae ld" href="https://hackernoon.com/tagged/database" rel="noopener ugc nofollow" target="_blank">数据库</a>、逻辑和管理仪表板作为托管服务提供，其<a class="ae ld" href="https://buttercms.com/cms/" rel="noopener ugc nofollow" target="_blank">内容通过web API </a>提供。有了Butter的<a class="ae ld" href="https://buttercms.com/cms" rel="noopener ugc nofollow" target="_blank"> API-first CMS和content API </a>，你可以通过它的<a class="ae ld" href="https://github.com/buttercms" rel="noopener ugc nofollow" target="_blank"> API客户端</a>检索内容，并将其插入你的网站。在C#中，API方法可以通过一个<a class="ae ld" href="https://github.com/ButterCMS/buttercms-csharp/blob/master/ButterCMS/ButterCMSClient.cs" rel="noopener ugc nofollow" target="_blank">单个类</a>来调用。</p><p id="c02d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们来看看这个类的结构。它有许多公共方法，通过私有的<code class="eh le lf lg lh b">Execute(string queryString)</code>和<code class="eh le lf lg lh b">ExecuteAsync(string queryString)</code>方法发送API请求。为了简单起见，我们只处理<code class="eh le lf lg lh b">Execute</code>方法和它的同步调用者。下面是一个公共方法，用于检索博客文章列表:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="ba94" class="lq kb hu lh b fv lr ls l lt lu">private string authToken; // Authorization token set in the ButterCMSClient constructor<br/>private const string retrievePostsEndpoint = "v2/posts/{0}"; // Base URL for blog posts on the API<br/><br/>// ... Code excluded for brevity ...<br/><br/>public PostResponse RetrievePost(string postSlug)<br/>{<br/>    var queryString = new StringBuilder();<br/>    queryString.Append(string.Format(retrievePostEndpoint, postSlug));<br/>    queryString.Append("?");<br/>    queryString.Append(authTokenParam);<br/>    var postResponse = JsonConvert.DeserializeObject&lt;PostResponse&gt;(Execute(queryString.ToString()), serializerSettings);<br/>    return postResponse;<br/>}</span></pre><p id="68e7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">简单明了。正如您所看到的，它接受一个<code class="eh le lf lg lh b">postSlug</code>参数(这只是标识我们想要加载的博客文章的唯一URL段)，将它组装到ButterCMS服务器上文章的URL中，并将其传递给<code class="eh le lf lg lh b">Execute(string queryString)</code>方法，该方法获得一个JSON响应并将其返回，以便封送到我们的<code class="eh le lf lg lh b">PostResponse</code>类中。然后，我们可以获取这些数据，并将其呈现在我们公共网站的页面模板中。</p><p id="1fad" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们更深入地了解一下<code class="eh le lf lg lh b">Execute</code>方法内部发生了什么:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="9509" class="lq kb hu lh b fv lr ls l lt lu">private HttpClient httpClient; // System.Net.Http.HttpClient instance, set in the ButterCMSClient constructor<br/><br/>// ... Code excluded for brevity ...<br/><br/>private string Execute(string queryString)<br/>{<br/>    try<br/>    {<br/>        var response = httpClient.GetAsync(queryString).Result;<br/>        if (response.IsSuccessStatusCode)<br/>        {<br/>            return response.Content.ReadAsStringAsync().Result;<br/>        }<br/>        if (response.StatusCode == System.Net.HttpStatusCode.Unauthorized)<br/>        {<br/>            throw new InvalidKeyException("No valid API key provided.");<br/>        }<br/>        if (response.StatusCode &gt;= System.Net.HttpStatusCode.InternalServerError)<br/>        {<br/>            throw new Exception("There is a problem with the ButterCMS service");<br/>        }<br/>    }<br/>    catch (TaskCanceledException taskException)<br/>    {<br/>        if (!taskException.CancellationToken.IsCancellationReques‌​ted)<br/>        {<br/>            throw new Exception("Timeout expired trying to reach the ButterCMS service.");<br/>        }<br/>        throw taskException;<br/>    }<br/>    catch (HttpRequestException httpException)<br/>    {<br/>        throw httpException;<br/>    }<br/>    catch (Exception ex)<br/>    {<br/>        throw ex;<br/>    }<br/>    return string.Empty;<br/>}</span></pre><p id="4e06" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个方法简单地向给定的URL发出一个HTTP <code class="eh le lf lg lh b">GET</code>请求，并以字符串的形式返回响应体，调用者可以将其解析为JSON、XML等。它有一些内置的错误检查，用于在错误响应的情况下抛出异常。这可以防止调用方意外地试图将它们解析为合法数据。</p><p id="a7a8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个API客户端完成了工作，但是您知道最好拥有什么吗？自动重试失败请求的能力。由于间歇性的连接问题，请求可能偶尔会失败。假设在我们发出请求时连接中断了，或者服务器收到了请求，但是在它完成发送响应之前连接被断开了。这些问题可能是间歇性的，只需重新发送请求就可以解决。当我们可以再次尝试并向用户显示他们想要的内容时，向用户显示错误页面是一种耻辱。</p><h1 id="acf9" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">幂等性和安全性</h1><p id="85e0" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">让我们尝试在这个API客户机中实现自动重试功能。这里需要注意的是，对于像这样的客户端，这是相对简单的<em class="lv">——我们所要做的就是捕捉由<code class="eh le lf lg lh b">Execute</code>方法抛出的任何异常，并使用相同的参数再次调用它，直到有限的尝试次数(如果有持续的问题，我们不希望重试永远继续下去)。这是因为这个客户端只发出<code class="eh le lf lg lh b">GET</code>请求。<code class="eh le lf lg lh b">GET</code>请求，如果正确实现和使用，有一个重要的属性叫做<em class="lv">幂等性</em>。</em></p><h2 id="c822" class="lq kb hu bd kc lw lx ly kg lz ma mb kk jn mc md ko jr me mf ks jv mg mh kw mi dt translated">幂等性和安全性</h2><p id="8e2d" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">幂等性听起来像是一个花哨的词，但它是一个简单的概念——多次执行相同的操作，而只在服务器上产生一次“副作用”的能力。副作用被定义为对服务器上持久数据的更改。正确实现的<code class="eh le lf lg lh b">GET</code>请求仅用于从服务器检索数据，从不修改数据，因此它们自然是幂等的。这是一个叫做<em class="lv">安全</em>的特例。安全方法是等幂的方法，因为它们不会产生任何副作用。HTTP <code class="eh le lf lg lh b">OPTIONS</code>和<code class="eh le lf lg lh b">HEAD</code>动词也有这个属性。</p><h2 id="5446" class="lq kb hu bd kc lw lx ly kg lz ma mb kk jn mc md ko jr me mf ks jv mg mh kw mi dt translated">幂等性和不安全性</h2><p id="e00f" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">有两个HTTP动词是幂等的但不安全，即<code class="eh le lf lg lh b">PUT</code>和<code class="eh le lf lg lh b">DELETE</code>方法。也就是说，它们在第一次成功时会产生副作用，但在随后的请求中什么也不做。例如，如果我在<code class="eh le lf lg lh b">myrestapi.com/resources/{id}</code>调用资源上的<code class="eh le lf lg lh b">DELETE</code>，该URL上的资源将被删除。如果我再次调用它，什么也不会发生，因为那个资源已经不存在了。对于<code class="eh le lf lg lh b">PUT</code>也是一样——调用一次用一些新数据替换资源，然后再调用一次，什么都不会发生，因为现在你正在把它“更新”到已经存在的相同数据。</p><p id="8aa1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">既然我们理解了幂等性，就很容易理解为什么简单的重试机制对所有类型的请求都不安全。每当我们在服务器上发出成功的非幂等请求，但是响应没有到达我们这里，一个“哑”重试机制将再次发送该请求。如果它不是等幂的，那可能是灾难性的(或者至少会导致一些愤怒的客户— <em class="lv">“我的信用卡被双重收费了，嗯？!"</em>)。</p><p id="ff23" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于我们的示例API客户机实际上是只读的(只发出<code class="eh le lf lg lh b">GET</code>请求)，我们可以使用一个“哑”重试机制，简单地重新发送请求，直到一个请求成功或者我们超过了最大允许重试次数。为非幂等请求构造重试机制需要服务器的配合。也就是说，客户端为每个请求附加一个惟一的ID(GUID/UUID就足够了)。当服务器成功处理一个请求时，它保存ID和它想要发送回的响应的副本。如果该响应没有返回到客户端，客户端将再次发送请求，使用相同的ID。服务器将识别ID，跳过请求的实际处理，只发送回存储的响应。从客户端的角度来看，这使得所有请求都是有效的幂等的。虽然在客户机或服务器上实现这种机制并不特别复杂，但本文只是对幂等性和重试的介绍，因此我们将坚持使用更简单的情况，即我们的示例中的<code class="eh le lf lg lh b">GET</code>请求和“哑”重试。</p><h1 id="949f" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">实现自动重试</h1><p id="a122" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">让我们回到代码上。我们需要“观察”<code class="eh le lf lg lh b">Execute</code>方法，这样如果它抛出异常，我们就可以重新执行它。这可以通过捕捉异常的简单包装方法来完成。首先，让我们将旧的<code class="eh le lf lg lh b">Execute</code>方法重命名为<code class="eh le lf lg lh b">ExecuteSingle</code>，以便更准确地表达其目的。</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="e5e5" class="lq kb hu lh b fv lr ls l lt lu">- private string Execute(string queryString)<br/>+ private string ExecuteSingle(string queryString)</span></pre><p id="6e06" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在让我们构建我们的包装方法。我们将其命名为<code class="eh le lf lg lh b">Execute</code>，这样我们现有的公共方法将调用它，而不是我们刚刚重命名的函数。现在，我们只做一个简单的包装器，不添加任何功能:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="675e" class="lq kb hu lh b fv lr ls l lt lu">private string Execute(string queryString)<br/>{<br/>    return ExecuteSingle(queryString);<br/>}</span></pre><p id="27e8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">API客户端现在应该完全像以前一样工作，所以我们实际上还没有完成任何事情。让我们从编写一个简单的循环开始，在一定的次数内重试请求。为了在<code class="eh le lf lg lh b">ExecuteSingle</code>抛出异常的情况下“继续循环”,我们需要在循环中捕获这些异常。</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="275d" class="lq kb hu lh b fv lr ls l lt lu">private string Execute(string queryString)<br/>{<br/>    // maxRequestTries is a private class member set to 3 by default, <br/>    // optionally set via a constructor parameter (not shown)<br/>    var remainingTries = maxRequestTries;  <br/><br/>    do <br/>    {<br/>        --remainingTries;<br/>        try <br/>        {<br/>            return ExecuteSingle(queryString);<br/>        }<br/>        catch (Exception) <br/>        {<br/><br/>        }<br/>    }<br/>    while (remainingTries &gt; 0)<br/>}</span></pre><p id="4d2e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果请求成功，这段代码将通过<code class="eh le lf lg lh b">return</code>语句退出循环。如果<code class="eh le lf lg lh b">ExecuteSingle</code>抛出一个异常，它将被吞掉，循环将继续到<code class="eh le lf lg lh b">maxRequestTries</code>次。<code class="eh le lf lg lh b">do { ... } while ()</code>语法确保请求总是至少执行一次，即使<code class="eh le lf lg lh b">maxRequestTries</code>被错误配置并设置为类似于<code class="eh le lf lg lh b">0</code>或<code class="eh le lf lg lh b">-10</code>的值。</p><p id="93a0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当然，这段代码有一个明显的问题——它包含了所有的异常。如果所有的请求都失败了，它只会返回一个<code class="eh le lf lg lh b">null</code>字符串。但是我们该如何处理呢？我们不能从<code class="eh le lf lg lh b">catch (Exception) { }</code>块内部抛出异常，否则执行将会脱离循环，这违背了整个方法的目的。我们应该在所有请求失败后抛出异常，并且只有当所有请求失败时才抛出异常。我们可以通过将它们聚集在一个<code class="eh le lf lg lh b">List&lt;Exception&gt;</code>中并在方法末尾抛出一个<code class="eh le lf lg lh b">AggregateException</code>来实现这一点。</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="5ece" class="lq kb hu lh b fv lr ls l lt lu">private string Execute(string queryString)<br/>{<br/>    var remainingTries = maxRequestTries;  <br/>    var exceptions = new List&lt;Exception&gt;();<br/><br/>    do <br/>    {<br/>        --remainingTries;<br/>        try <br/>        {<br/>            return ExecuteSingle(queryString);<br/>        }<br/>        catch (Exception e) <br/>        {<br/>            exceptions.Add(e);<br/>        }<br/>    }<br/>    while (remainingTries &gt; 0)<br/><br/>    throw new AggregateException(exceptions)<br/>}</span></pre><p id="9c36" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果所有的请求都失败了，这个方法将抛出一个<code class="eh le lf lg lh b">AggregateException</code>,包含每个请求抛出的所有异常的列表。如果任何请求成功，将不会抛出异常，我们将只得到我们的响应字符串。这绝对够用。但是让我们把它变得更好一点——大多数重复的失败都是由一个持久的问题引起的，所以每个请求都会抛出完全相同的异常。如果我们所有的请求都抛出一个<code class="eh le lf lg lh b">InvalidKeyException</code>(当我们的API auth令牌无效时就会发生这种情况)，我们真的想要返回一个<code class="eh le lf lg lh b">AggregateException</code>，比如说，有3个相同的<code class="eh le lf lg lh b">InvalidKeyException</code>吗？只扔一个<code class="eh le lf lg lh b">InvalidKeyException</code>不是更符合人体工程学吗？为此，我们需要将异常列表中的任何重复项“折叠”成一个“代表性”异常。我们可以使用Linq的<code class="eh le lf lg lh b">Distinct</code>方法来做到这一点，但是默认情况下它不会折叠异常，因为它们是...良好的...<em class="lv">不同的</em>对象和<code class="eh le lf lg lh b">Distinct</code>会参照比较。我们可以使用它的重载，它接受一个自定义的<code class="eh le lf lg lh b">IEqualityComparer&lt;T&gt;</code>，我们可以用它来识别异常，这些异常可以被认为是重复的。下面是我们的实现:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="9ea5" class="lq kb hu lh b fv lr ls l lt lu">private class ExceptionEqualityComparer : IEqualityComparer&lt;Exception&gt;<br/>{<br/>    public bool Equals(Exception e1, Exception e2)<br/>    {<br/>        if (e2 == null &amp;&amp; e1 == null)<br/>            return true;<br/>        else if (e1 == null | e2 == null)<br/>            return false;<br/>        else if (e1.GetType().Name.Equals(e2.GetType().Name) &amp;&amp; e1.Message.Equals(e2.Message))<br/>            return true;<br/>        else<br/>            return false;<br/>    }<br/><br/>    public int GetHashCode(Exception e)<br/>    {<br/>        return (e.GetType().Name + e.Message).GetHashCode();<br/>    }<br/>}</span></pre><p id="3406" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果两个异常共享相同的类型和<code class="eh le lf lg lh b">Message</code>属性，这个相等比较器认为它们相等。就我们的目的而言，这是“重复”的一个足够好的定义。</p><p id="92a9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我们可以折叠由请求尝试引发的重复异常:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="aacf" class="lq kb hu lh b fv lr ls l lt lu">private string Execute(string queryString)<br/>{<br/>    var remainingTries = maxRequestTries;  <br/>    var exceptions = new List&lt;Exception&gt;();<br/><br/>    do <br/>    {<br/>        --remainingTries;<br/>        try <br/>        {<br/>            return ExecuteSingle(queryString);<br/>        }<br/>        catch (Exception e) <br/>        {<br/>            exceptions.Add(e);<br/>        }<br/>    }<br/>    while (remainingTries &gt; 0)<br/><br/>    var uniqueExceptions = exceptions.Distinct(new ExceptionEqualityComparer());<br/><br/>    if (uniqueExceptions.Count()) == 1)<br/>        throw uniqueExceptions.First();<br/><br/>    return new AggregateException("Could not process request", uniqueExceptions);<br/>}</span></pre><p id="532a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这更符合人体工程学。简而言之，我们只抛出由请求尝试产生的不同异常。如果只有一个，要么是因为我们只做了一次尝试，要么是因为多次尝试都因为同样的原因失败了，我们抛出这个异常。如果有多个异常，我们抛出一个<code class="eh le lf lg lh b">AggregateException</code>,每个类型/消息组合一个。</p><h1 id="2f61" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">包扎</h1><p id="16ef" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">在API客户机上实现幂等请求的重试功能就是这么简单。即使对于非幂等请求，我们也可以在循环之前创建一个新的<code class="eh le lf lg lh b">Guid</code>,并在每次请求尝试中包含它。服务器将负责跟踪请求id和响应。</p><p id="e93f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一定要看看<a class="ae ld" href="https://buttercms.com/" rel="noopener ugc nofollow" target="_blank"> ButterCMS </a>，这是一个<a class="ae ld" href="https://buttercms.com/cms/" rel="noopener ugc nofollow" target="_blank">托管的API优先CMS和内容API </a>，让你使用任何编程语言构建CMS驱动的应用，包括<a class="ae ld" href="https://buttercms.com/ruby-cms" rel="noopener ugc nofollow" target="_blank"> Ruby </a>、<a class="ae ld" href="https://buttercms.com/rails-cms" rel="noopener ugc nofollow" target="_blank"> Rails </a>、<a class="ae ld" href="https://buttercms.com/nodejs-cms" rel="noopener ugc nofollow" target="_blank"> Node.js </a>、<a class="ae ld" href="https://buttercms.com/asp-net-cms" rel="noopener ugc nofollow" target="_blank">。网</a>、<a class="ae ld" href="https://buttercms.com/python-cms" rel="noopener ugc nofollow" target="_blank">巨蟒</a>、<a class="ae ld" href="https://buttercms.com/phoenix-cms" rel="noopener ugc nofollow" target="_blank">凤凰</a>、<a class="ae ld" href="https://buttercms.com/django-cms" rel="noopener ugc nofollow" target="_blank">姜戈</a>、<a class="ae ld" href="https://buttercms.com/flask-cms" rel="noopener ugc nofollow" target="_blank">烧瓶</a>、<a class="ae ld" href="https://buttercms.com/react-cms" rel="noopener ugc nofollow" target="_blank">反应</a>、<a class="ae ld" href="https://buttercms.com/angular-cms" rel="noopener ugc nofollow" target="_blank">有角</a>、<a class="ae ld" href="https://buttercms.com/golang-cms" rel="noopener ugc nofollow" target="_blank">围棋</a>、<a class="ae ld" href="https://buttercms.com/php-cms" rel="noopener ugc nofollow" target="_blank"> PHP </a>、<a class="ae ld" href="https://buttercms.com/laravel-cms" rel="noopener ugc nofollow" target="_blank">拉拉夫尔</a>、<a class="ae ld" href="https://buttercms.com/elixir-cms" rel="noopener ugc nofollow" target="_blank">仙丹</a>、<a class="ae ld" href="https://buttercms.com/meteor-cms" rel="noopener ugc nofollow" target="_blank">流星</a>。</p><p id="bde9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我希望这篇教程对你有所帮助。愿你的API永远符合人体工程学，愿你的网站永远可靠。愿你永远不会向顾客重复收费。</p><div class="li lj lk ll fq ab cb"><figure class="mj iv mk ml mm mn mo paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mj iv mk ml mm mn mo paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mj iv mk ml mm mn mo paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mp mq mr"><p id="f922" class="jc jd lv je b jf jg jh ji jj jk jl jm ms jo jp jq mt js jt ju mu jw jx jy jz hn dt translated"><a class="ae ld" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ld" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ld" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ld" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd lv je b jf jg jh ji jj jk jl jm ms jo jp jq mt js jt ju mu jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ld" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ld" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="li lj lk ll fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mv"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="mw mx l"/></div></figure></div></div>    
</body>
</html>