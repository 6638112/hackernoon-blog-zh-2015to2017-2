<html>
<head>
<title>Comparing Diesel and rust-postgres</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">柴油和rust-postgres的比较</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/comparing-diesel-and-rust-postgres-97fd8c656fdd?source=collection_archive---------1-----------------------#2016-12-10">https://medium.com/hackernoon/comparing-diesel-and-rust-postgres-97fd8c656fdd?source=collection_archive---------1-----------------------#2016-12-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="8bbd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">随着<a class="ae jp" href="https://github.com/diesel-rs/diesel/releases/tag/v0.9.0" rel="noopener ugc nofollow" target="_blank"> Diesel 0.9.0 </a>的发布，我想重温一下Diesel和rust-postgres之间的性能差异，看看自从我上次在0.1.0中测量这两个版本以来，情况是否发生了显著变化<a class="ae jp" href="https://gist.github.com/sgrif/da762c08f9a567c80d44" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="49d8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">TL；DR:在惯用代码方面，Diesel始终比rust-postgres高出25-30%。它也更简洁，并在编译时捕捉错误，以帮助您更快地编写工作代码。你可以在这里找到完整的基准代码<a class="ae jp" href="https://gist.github.com/sgrif/0d948fb06fab9b1f6db51c6fddf93023" rel="noopener ugc nofollow" target="_blank"/>。rust-postgres基准可以进一步优化，以获得大约10%的性能提升。然而，这样做会导致代码变得更脆弱，更难理解。</p><p id="73fe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你想在这个假期做些什么，并且你还没有尝试过Diesel，看看我们的<a class="ae jp" href="http://diesel.rs/guides/getting-started/" rel="noopener ugc nofollow" target="_blank">入门指南</a>。本文的其余部分将研究这两种用法之间的区别。</p><p id="e7a9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">基准测试结果完全基于select语句的结果，而不是数据的插入。由SQL数据库支持的大多数应用程序都是读负载，而不是写负载。此外，rust-postgres严重依赖绑定参数的动态调度。这意味着对于具有过多绑定参数的查询，比如批量插入，其性能降低到了我认为不公平的程度。</p></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><h1 id="bb28" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">设置数据</h1><p id="daf5" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">我们来看两个基准测试。第一个将把一些行数设置到一个3列的表中，然后执行<code class="eh la lb lc ld b">SELECT * FROM users</code>或等效操作。第二个将使用两个包含更多数据的表，并在两个表之间建立一个连接。这是Diesel的设置:</p><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="5950" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh la lb lc ld b">NewUser</code>的定义在顶部，看起来像:</p><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="0b78" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh la lb lc ld b">#[derive(Insertable)]</code>来自<code class="eh la lb lc ld b">diesel_codegen</code>机箱，并生成适当的代码在insert语句中使用这个结构。我们从顶部看起来像<code class="eh la lb lc ld b">infer_schema!("env:DATABASE_URL")</code>的一行代码中知道数据库模式，它将在编译时加载数据库模式。使用<code class="eh la lb lc ld b">NewUser</code>的矢量或切片进行批量插入会自动进行。我们正在对结果执行<code class="eh la lb lc ld b">assert_eq!</code>,以再次检查我们是否确实插入了预期的行数。</p><p id="9bb0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">rust-postgres基准测试的设置稍微复杂一些。</p><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="f623" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然，这总是有点冗长，因为我们必须手动构造SQL。对于批量插入，这意味着大量的动态查询结构，这些SQL只不过是难以阅读的<code class="eh la lb lc ld b">($1, $2)</code>。这是意料之中的，rust-postgres并不想成为一个查询生成器。然而，我们不得不通过绑定参数跳过的圈圈让我感到惊讶。</p><p id="f2ee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">rust-postgres尽可能推迟绑定参数的序列化。然而，它也没有提供任何保存绑定参数的数据结构。这意味着我们必须将它们放入一个trait对象列表中，即使所有的绑定都是同一类型。这也意味着它依赖于动态调度，这将严重阻碍编译器优化序列化代码的能力。</p><p id="8c91" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">rust-postgres提供的API看起来可能很好，如果您正在构建简单的查询，或者如果您所有的绑定值都是硬编码的，或者简单地借用了已经在范围内的东西。但是一旦你在做动态的事情，就很难弄清楚到底该做什么。我花了很长时间才弄明白我需要在那里构造借来的绑定参数的确切咒语。</p><p id="3afc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，因为我们只是在简单的SQL字符串上操作，所以我们还需要检查以确保我们没有试图插入0行。由于rust-postgres只处理原始SQL，它无法理解我们自动处理这种情况的意图。</p><h1 id="fb30" class="jx jy hu bd jz ka ll kc kd ke lm kg kh ki ln kk kl km lo ko kp kq lp ks kt ku dt translated">简单查询执行</h1><p id="6b66" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">对于第一个基准测试，我们将执行<code class="eh la lb lc ld b">SELECT * FROM users</code>或等价的，将所有的行反序列化为一个<code class="eh la lb lc ld b">Vec&lt;User&gt;</code>，然后检查向量的长度是否是我们期望的。两个基准的结构定义如下所示:</p><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="c066" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Diesel基准测试中，该结构用<code class="eh la lb lc ld b">#[derive(Queryable)]</code>进行了注释，生成代码将行反序列化到该结构中。柴油的基准看起来像这样:</p><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="ce36" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">需要注意的一点是，它生成的查询与您自己编写的略有不同。准确的查询是<code class="eh la lb lc ld b">SELECT "users"."id", "users"."name", "users"."hair_color" FROM "users"</code>。我们必须在这里为<code class="eh la lb lc ld b">::&lt;User&gt;</code>添加一条turbofish，因为我们从来没有使用过vector，编译器也无法判断出它的类型。</p><p id="b57a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">rust-postgres基准有点类似:</p><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="c3a2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">需要注意的一点是，我们已经内联编写了反序列化代码，而不是提取一个名为<code class="eh la lb lc ld b">User::from_row</code>或类似的函数。在代码中使用rust-postgres创建该函数是一种常见的模式，但它最终非常脆弱。除了这个查询之外，我们不知道这些列是否已经被重命名。正如我们将在后面看到的，经常需要重命名。我们也不知道这段代码是否出现在一个连接中。如果它在左外部连接的右侧，我们将需要返回<code class="eh la lb lc ld b">Option&lt;User&gt;</code>。由于<code class="eh la lb lc ld b">User::from_row</code>函数的重用有限，所以我选择不提取它。</p><p id="fa2e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们显式地列出每一列，并通过索引而不是名称获取结果，我们也可以获得一些改进。然而，这个基准测试的目标是从用户的角度编写代码，花费同样的精力，做大致相同的事情。通过索引获取结果是非常脆弱的，而且由于<code class="eh la lb lc ld b">Row</code>类型对数据的底层SQL类型一无所知，所以非常容易意外地将垃圾数据反序列化为错误的类型。我在野外看到的所有代码都通过名称访问字段，这可能是正确的决定。</p><p id="307f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些是“简单查询”基准测试的结果。</p><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="cf37" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于用postgres执行一个查询的开销，会有很大的差异，但是Diesel每次运行都会快25%到30%。</p><h1 id="4459" class="jx jy hu bd jz ka ll kc kd ke lm kg kh ki ln kk kl km lo ko kp kq lp ks kt ku dt translated">复杂的查询</h1><p id="3c0a" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">对于第二个基准，我们将变得稍微复杂一些。对于数据，我们将为用户改变头发颜色，并给每三个用户一个帖子。这是Diesel的设置代码。</p><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="72b7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于<code class="eh la lb lc ld b">NewPost</code>，我们主要使用静态数据。<code class="eh la lb lc ld b">#[derive(Insertable)]</code>是不是<a class="ae jp" href="https://hackernoon.com/tagged/designed" rel="noopener ugc nofollow" target="_blank">设计的</a>既可以处理自有数据，也可以处理借来的数据，所以你可以使用最适合这种情况的数据。在我们生成动态字符串的<code class="eh la lb lc ld b">NewUser</code>的例子中，将结果放在自己的字符串中要容易得多。</p><p id="45f1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">rust-postgres的设置也类似于第一个基准测试。</p><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="1654" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为posts查询收集绑定参数甚至比第一个基准测试还要困难。如果数据只是稍微静态一点，我们就可以马上把它放到一个<code class="eh la lb lc ld b">Vec&lt;&amp;ToSql&gt;</code>中，就像它的作者想要的那样。然而，我们必须给计数器加1来得到<code class="eh la lb lc ld b">user_id</code>，这意味着我们有一个动态构造的值。由于这一次绑定参数的类型不同，我们必须将它们打包以获得单一类型的向量。即使在那之后，我们仍然需要第二次迭代，从<code class="eh la lb lc ld b">Vec&lt;Box&lt;ToSql&gt;&gt;</code>到<code class="eh la lb lc ld b">Vec&lt;&amp;ToSql&gt;</code>，最终我们可以借用到rust-postgres想要的特定<code class="eh la lb lc ld b">&amp;[&amp;ToSql]</code>。</p><p id="6293" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对第二基准的查询是<code class="eh la lb lc ld b">SELECT * FROM users LEFT OUTER JOIN posts ON posts.user_id = users.id WHERE hair_color = "black" ORDER BY name DESC</code>或等效的。柴油版的代码如下所示:</p><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="be8f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您会注意到我们从来没有为这个查询指定过<code class="eh la lb lc ld b">ON</code>子句。关于如何执行连接的信息是由类似于<code class="eh la lb lc ld b">#[has_many(posts)]</code>的<code class="eh la lb lc ld b">User</code>上的注释生成的。我们默认假设外键的形式是<code class="eh la lb lc ld b">parent_id</code>。如果您不使用这个约定，或者有一个更复杂的连接，那么很容易覆盖这个缺省值。</p><p id="844e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该基准测试的rust-postgres代码如下所示:</p><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="bf03" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里的查询要长得多。我们需要手动列出每一列，并给它们起别名，这样我们就可以确保以后获取的是正确的列。rust-postgres提供的API不允许您为列指定表名。在发生冲突的情况下，执行<code class="eh la lb lc ld b">row.get("id")</code>会自动给出先出现的<code class="eh la lb lc ld b">id</code>列，没有任何迹象表明您可能使用了错误的数据。</p><p id="4ad9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们再次以内联方式执行了反序列化。这个例子证明了我之前的观点。许多代码库使用的通用抽象非常脆弱。不幸的是，rust-postgres没有提供为这类情况编写通用反序列化代码所需的API。</p><p id="63ea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">rust-postgres的一个优点是这是一个比其他查询更容易执行的查询。我们所有的绑定参数都是静态的，所以我们能够将它内嵌到查询中。我相信这是它的作者优化的案例类型，当你在这些界限内时，它工作得很好。</p><p id="d00f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第二项基准测试的结果是:</p><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="lj lk l"/></div></figure><h1 id="d2ac" class="jx jy hu bd jz ka ll kc kd ke lm kg kh ki ln kk kl km lo ko kp kq lp ks kt ku dt translated">结论</h1><p id="f36e" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">希望这有助于说明柴油和rust-postgres之间的一些关键差异。尽管专注于保持比柴油低的水平，rust-postgres并没有提供比柴油更好的性能。</p><p id="2f98" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">需要注意的是，rust-postgres基准测试用时2.76秒，而Diesel基准测试用时3.4秒。我预计在大型代码库上，这个差距会越来越大。rust-postgres基准测试的二进制文件大约比Diesel基准测试的二进制文件大25%,我认为不管代码库有多大，Diesel的二进制文件都会更小。</p><p id="b19e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我真的相信Diesel提供的安全保证会显著提高开发人员的生产力。我尝试了很多次才让rust-postgres基准真正发挥作用。与Diesel给出的快速编译时反馈相比，等待运行时错误告诉我该做什么的反馈周期(假设消息是有用的)非常慢。</p><p id="4ef0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你还没有尝试过Diesel，我希望你能抓住这个机会在假期尝试一下。可以在<a class="ae jp" href="http://diesel.rs" rel="noopener ugc nofollow" target="_blank"> http://diesel.rs </a>了解更多</p><p id="8e35" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">感谢阅读！</p><blockquote class="lq lr ls"><p id="2caf" class="ir is lt it b iu iv iw ix iy iz ja jb lu jd je jf lv jh ji jj lw jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is lt it b iu iv iw ix iy iz ja jb lu jd je jf lv jh ji jj lw jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上给我们点赞/发消息</a>，或者简单地说，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is lt it b iu iv iw ix iy iz ja jb lu jd je jf lv jh ji jj lw jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="lx lk l"/></div></figure></div></div>    
</body>
</html>