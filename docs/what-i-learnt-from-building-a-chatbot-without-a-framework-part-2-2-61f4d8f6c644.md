# 我从构建一个没有框架的聊天机器人中学到了什么(第二部分)

> 原文：<https://medium.com/hackernoon/what-i-learnt-from-building-a-chatbot-without-a-framework-part-2-2-61f4d8f6c644>

![](img/b52fbcb9a8cd9a7b5a424f1fc096ca5f.png)

在[第 1 部分](/p/what-i-learnt-from-building-a-chatbot-without-a-framework-part-1-2-438ef9f4dab3)中，我提到了直接将一个机器人与一个机器人 API 对接，而不通过外部的机器人构建框架，这有很大的学习价值。

我解释说，这是了解不同聊天平台(如 Telegram 或 Messenger)上的各种交互和消息的好方法，这使我们能够优化单个平台上的用户体验。此外，如果我们最终使用一个跨平台的[框架](https://hackernoon.com/tagged/framework)，我们会更加意识到它的局限性。

在这篇后续文章中，我将分享我在解析消息、处理时区和处理多种边缘情况方面的学习经验。

# 我简化了消息解析

平台可以向机器人发送不同的消息。例如，包含来自用户的文本的消息不同于包含图片和标题的消息。我们需要解析并提取接收到的有效载荷的内容，它通常是通过 HTTP POST 接收到的一个 [JSON](https://hackernoon.com/tagged/json) 对象。让我们看一些用 Python 写的代码例子。

```
def post(self):
  # Called when the bot gets a POST request. update = json.loads(self.request.body) chat = None
  if ("message" in update and update["message"] is not None and "chat" in update["message"] and update["message"]["chat"] is not None):
    chat = update["message"]["chat"] if chat is None:
    return # More parsing ...
```

为了安全地提取嵌套属性，我们需要验证父属性存在并且具有非空值。如果上述 If 语句中的任何一个检查结果为 False，则不会计算下一个条件，因为整个语句已经为 False。

这些检查对于可选的属性是必需的，即它们可能不存在于有效载荷中。此外，即使它们存在，也可能为空。只有当 API 保证某个属性是强制的并且具有非空值时，我们才能避免这种费力的检查。

然而，上述方法过于冗长，难以维护。例如，如果我们错过了某个特定的检查怎么办？这是一个大问题，因为我们需要提取更多的属性，比如 chat_id 和时间戳。这些属性可以进一步嵌套在 JSON 对象中。

为了解决这个问题，我们可以用 try-except 子句替换 if 语句。

```
def post(self):
  update = json.loads(self.request.body) try:
    chat = update["message"]["chat"]
  except:
    chat = None

  if chat is None:
    return # More parsing ...
```

如果“消息”或“聊天”属性不存在，将会引发异常。如果“message”属性为空，也会引发异常。

尽管这种方法更好，但是 post 方法仍然会因为许多低级解析细节而负担过重。此外，在解析更多属性时复制 try-excepts 是个坏主意。

为了解决这些问题，我创建了一个单独的更新类。它本质上是一个围绕 JSON 更新的轻量级包装类，只公开我们在应用程序中关心的属性。

```
class Update(object):
  def __init__(self, raw_update):
    self.update = json.loads(raw_update)
    self.chat = self._get_prop_value("chat")
    ... def _get_prop_value(self, alias):
    try:
      return self._resolve(alias)
    except:
      return None def _resolve(self, alias):
    if alias == "chat":
      return self.update["message"]["chat"]
    ...... def post(self):
    update = Update(self.request.body)

    if update.chat is None:
      return
    ...
```

从上面的代码片段中可以看出，try-except 子句被放入了可以重用的`_get_prop_value`方法中。因此，没有必要重复。此外，在创建更新对象之后使用它变得非常简单。我们只需要通过点符号访问所需的属性。

当我成功简化代码时，我欣喜若狂！虽然第一个版本工作正常，但它不断地要求我改进。我甚至想到创建一个解析器对象来提取所需的信息。然而，当我看到如何在原始 JSON 对象周围放置一个包装器时，一切都明白了。我认识到重构可能是一个视角问题。

# 我简化了时区处理

![](img/cbd4428e2ab64357a63a6144096c707c.png)

概括地说，我的机器人的主要功能是向用户发送每日 Twitter 动态。但是，这个每日更新应该什么时候发呢？

我可以向用户询问首选时间，但是我也需要询问时区。这两个步骤使入职体验变得复杂，许多用户甚至可能不会尝试或完成这两个步骤。

在权衡利弊之后，我认为让用户设置精确的时间是不值得的。然而，我仍然需要设置一个合理的默认时间。

我想到的简单解决方案是，当用户开始订阅时，即当用户发送`/start`消息时，记录当前的协调世界时(UTC)作为首选更新时间。记录首选 UTC 时间不需要了解用户的具体时区。然后，我安排我的更新程序每小时运行一次，并更新应该在该小时更新的订阅者。

更详细地说，如果用户在上午 8:30(UTC)发送`/start`,首选更新时间将保存为 8。当更新程序在第二天早上 8 点运行时，该用户将被更新。

要做好这件事，需要注意一些细节。例如，应该只更新最近没有发出`/start`命令的用户。此外，由于调度程序调用更新程序的时间可能比预期稍早，我们可能希望将它安排在整点后的几分钟，或者将当前时间四舍五入到最近的整点，这样我们就可以始终更新正确的用户组。

# 我评估了技术优势案例

关于对话式用户体验，有许多边缘情况需要考虑；这是最好的解决在一个单独的职位。相反，我将阐述我在没有框架的情况下构建我的 Telegram bot 时遇到的三个技术边缘案例。

## 1.重试策略

每个平台都应该有一个重试策略，以便在机器人没有成功确认消息时重新发送消息。

当 Telegram 使用 webhook 将用户的消息发送给机器人时，它期待来自机器人的 HTTP 200 确认，以指示机器人已成功接收到消息。如果机器人没有给出这个回复，平台可能会在以后再次发送相同的消息。

在开发过程中，我们可以通过记录请求和执行以下操作来查看实际的重试策略:

1.  部署引发错误或返回 HTTP 500 的 bot 版本
2.  发送几条来自用户的消息
3.  稍后部署一个没有错误的 bot 版本

![](img/fff8a5680a4178093336b5ae7c736ebd.png)

Sample logs showing that the platform resends failed messages

通过检查应用程序日志，我意识到 Telegram 采用了指数后退策略，即它增加了后续重试之间的时间延迟。然而，如果机器人在多次尝试后仍未能确认消息，Telegram 将停止尝试重新发送消息。也就是说，如果将来任何其他*消息被确认，它将尝试重新发送尚未被确认的旧消息。请注意，这些细节并没有通过电报正式记录下来。*

虽然重试很棒，但是有一个问题。如果出现这种情况，bot 可能不会按照用户第一次发送消息的顺序接收消息。这就把我们带到了下一个边缘案例。

## 2.消息排序

在正常情况下，机器人应该按照用户发送消息的顺序接收用户消息。但是，至少在两种情况下，机器人不会以正确的顺序处理消息。

第一种情况发生在根据平台的重试策略重新发送失败的消息时。例如，用户发送 A，然后发送 B。机器人未能确认 A，但成功接收 B。接下来，当平台重新发送它时，它会收到一个。结果 bot 先处理 B 再处理 A，顺序不对。

第二种情况发生在同一用户在很短的时间内发送许多消息时(例如，每秒 3 条或更多消息)。这在群聊中可能很常见，在群聊中，同一个群里的人同时聊天。

当处理大量用户消息时，我们通常会启动多个实例来并发处理请求。请求可以被发送到不同的队列等待轮到它们。因此，首先处理来自用户的稍后消息的可能性很小。同时处理来自同一用户的两条消息的可能性也很小，这使得消息排序不明确。

## 为什么消息排序可能很重要

如果机器人只给出信息，并且可以一步完成请求，那么消息排序就不那么重要了。

但是，如果机器人需要在多个消息上设置用户数据，这一点很重要，因为这将影响数据的准确性。考虑下面的例子。

> 用户:一个
> 机器人:知道了。用户:B.
> 机器人:你想点 B1 还是 B2？

然而，如果顺序颠倒过来，就会发生这种情况。

> 用户:A
> 用户:B
> Bot 接收:B
> Bot: B1 还是 B2？机器人接收:A
> 机器人:对不起，我们没有 A。你想点 B1 还是 B2？

在这一点上，用户会感到非常困惑。

更糟糕的是，如果 A 是“B1 还是 B2？”的合理答案，那么机器人会错误地将 A 记录为答案。

## 怎么才能解决这个问题？

解决这个问题的一个方法是简单地丢弃迟到的内容。我们可以通过比较最后收到的用户消息的时间戳来确定消息是否迟到。

此外，在一系列消息之后采取任何关键行动之前，机器人可以要求用户进行最终确认。

## 我们能防止这个问题吗？

调用重试策略时，可能会以错误的顺序处理消息。为了防止这种情况发生，bot 应该成功地确认所有消息，除非它遇到无法或不应该从中恢复的错误。

将重试次数保持在最低限度可以通过以下方法实现

*   广泛测试
*   分离开发和生产环境
*   充分扩展以保持响应能力

如果同一个用户在很短的时间内发送了太多的消息，也可能会出现这个问题。在一对一的聊天中，这种情况不应该发生，除非用户正在发送垃圾邮件(考虑向垃圾邮件发送者发出警告)。然而，如果机器人需要能够在群组中聊天，机器人可以合法地一次从群组接收许多消息。

考虑设置群组提醒的行为。为了防止 Bob 在 Alice 试图设置群组提醒的细节时进行干预，机器人可以将 Bob 所说的任何事情视为单独的请求。为此，机器人可能需要为组中的每个用户分配单独的内存。此外，它可以在适当的时候提交对共享组内存的更改。

除了防止这里讨论的问题之外，这种安排还赋予了 bot 更好的上下文感知能力，因为它了解组中的各个用户和组本身。

## 3.争论

到目前为止，我们已经看到重试策略和消息的涌入会导致消息以错误的顺序被处理。但是，它们也可能导致数据库争用，从而导致对数据库的不准确更新。

假设机器人接收到用户的消息，对数据库进行更改，并生成回复。这种改变会立即生效吗？

我们可以同步写入数据库，这可以保证在生成回复之前已经提交了更改。但是，根据数据库的不同，该更改可能需要一段时间才能对另一个数据库查询可见。

考虑一个场景，机器人应该在列表中记录聊天历史。将现有历史记录表示为 h。

在消息 m1 到达之后，历史应该被保存为 H + m1。几毫秒后，消息 m2 也到达了。由于更改还不可见，查询的历史仍然是 H，所以历史被保存为 H + m2。令人不安的是，用户会认为没有任何问题，因为机器人像往常一样回复了两条消息。

为了解决这个问题，我们可以应用与前面边缘案例中描述的相同的缓解措施。此外，我们需要了解我们选择的数据库如何处理读写一致性，以及如何执行原子事务，尤其是在强一致性是一个重要需求的情况下。

## 边缘案例的一般评论

在投入时间实施各种针对边缘情况的预防或缓解措施之前，评估其发生的可能性以及对用户的影响非常重要。如果风险和影响不小，最好提前告知理解和处理它们所需的时间和精力。

# 最后

我从构建一个没有框架的机器人中学到了很多。它使我能够发现所选 bot 平台(Telegram)的具体情况，并让我思考如何简化消息解析和时区处理。此外，我了解了边缘情况以及如何处理它们。

如果你没有看过第 1 部分，点击[这里](/p/what-i-learnt-from-building-a-chatbot-without-a-framework-part-1-2-438ef9f4dab3)。

## 如果你觉得这篇文章很有见地，并希望看到更多，请❤和关注我！

[![](img/50ef4044ecd4e250b5d50f368b775d38.png)](http://bit.ly/HackernoonFB)[![](img/979d9a46439d5aebbdcdca574e21dc81.png)](https://goo.gl/k7XYbx)[![](img/2930ba6bd2c12218fdbbf7e02c8746ff.png)](https://goo.gl/4ofytp)

> [黑客中午](http://bit.ly/Hackernoon)是黑客如何开始他们的下午。我们是 [@AMI](http://bit.ly/atAMIatAMI) 家庭的一员。我们现在[接受投稿](http://bit.ly/hackernoonsubmission)并乐意[讨论广告&赞助](mailto:partners@amipublications.com)机会。
> 
> 如果你喜欢这个故事，我们推荐你阅读我们的[最新科技故事](http://bit.ly/hackernoonlatestt)和[趋势科技故事](https://hackernoon.com/trending)。直到下一次，不要把世界的现实想当然！

[![](img/be0ca55ba73a573dce11effb2ee80d56.png)](https://goo.gl/Ahtev1)