<html>
<head>
<title>How Eve unifies your entire programming stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Eve如何统一您的整个编程堆栈</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-eve-unifies-your-entire-programming-stack-900ca80c58a7?source=collection_archive---------0-----------------------#2016-11-21">https://medium.com/hackernoon/how-eve-unifies-your-entire-programming-stack-900ca80c58a7?source=collection_archive---------0-----------------------#2016-11-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="e47c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">欢迎来到我的关于Eve的系列文章的第一部分，这是一种令人兴奋和着迷的新编程语言。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff jq"><img src="../Images/5d00ee5f811d19fdacd64945cf7dc021.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*c42MkKUBa0HE3th2MG8pDw.png"/></div></figure><ul class=""><li id="4c89" class="jy jz hu it b iu iv iy iz jc ka jg kb jk kc jo kd ke kf kg dt translated"><strong class="it hv"><em class="kh">I .</em>Eve如何统一你的整个编程栈</strong></li><li id="e0b2" class="jy jz hu it b iu ki iy kj jc kk jg kl jk km jo kd ke kf kg dt translated"><a class="ae jp" href="https://hackernoon.com/when-logic-programming-meets-cqrs-1137ab2a5f86" rel="noopener ugc nofollow" target="_blank"> <em class="kh">二世。</em>当逻辑编程遇上CQRS </a></li><li id="f94d" class="jy jz hu it b iu ki iy kj jc kk jg kl jk km jo kd ke kf kg dt translated"><a class="ae jp" href="https://hackernoon.com/throwing-off-our-scope-chains-7567beb2d0b6" rel="noopener ugc nofollow" target="_blank"> <em class="kh">三世。</em>挣脱我们的镜链</a></li><li id="69e4" class="jy jz hu it b iu ki iy kj jc kk jg kl jk km jo kd ke kf kg dt translated"><a class="ae jp" href="https://hackernoon.com/smalltalk-and-protein-programming-4da245ac93e2" rel="noopener ugc nofollow" target="_blank"> <em class="kh">四世。</em> Smalltalk和蛋白质编程</a></li><li id="f2b6" class="jy jz hu it b iu ki iy kj jc kk jg kl jk km jo kd ke kf kg dt translated"><a class="ae jp" href="https://hackernoon.com/the-rock-solid-foundation-for-eves-big-vision-225b80b91e11" rel="noopener ugc nofollow" target="_blank"> <em class="kh">五、</em>夏娃远大理想的坚实基础</a></li><li id="a91e" class="jy jz hu it b iu ki iy kj jc kk jg kl jk km jo kd ke kf kg dt translated"><a class="ae jp" href="https://hackernoon.com/why-eve-will-be-perfect-for-realtime-apps-92b965b80ad" rel="noopener ugc nofollow" target="_blank"> <em class="kh">六。</em>为什么Eve是实时应用的完美选择</a></li></ul><p id="b6e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Eve是之前创立<a class="ae jp" href="http://lighttable.com" rel="noopener ugc nofollow" target="_blank">光桌</a>的远见团队多年研发的巅峰之作。Eve的0.2版本在上个月推出，并在<a class="ae jp" href="https://news.ycombinator.com/item?id=12817468" rel="noopener ugc nofollow" target="_blank">黑客新闻</a>上大放异彩，这也是我第一次听说它的原因。</p><p id="5b26" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Eve的这个最新版本带来了一些非常酷的现场演示，比如“<a class="ae jp" href="http://play.witheve.com/#/examples/flappy.eve" rel="noopener ugc nofollow" target="_blank"> Flappy Eve </a>”:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="fe ff kn"><img src="../Images/07e2137a92beee8742f18f222074afe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iQ-YI93T0NpnhFTbCcq9qw.png"/></div></div></figure><p id="d3a3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第一次滚动浏览<em class="kh"> flappy.eve </em>演示时，一些引人注目的功能跃然而出:</p><ul class=""><li id="3296" class="jy jz hu it b iu iv iy iz jc ka jg kb jk kc jo kd ke kf kg dt translated">IDE看起来像一个所见即所得的博客编辑器。Eve代码被设计成嵌入在Markdown格式的散文中；这是最大限度的文化编程。</li><li id="03cd" class="jy jz hu it b iu ki iy kj jc kk jg kl jk km jo kd ke kf kg dt translated">语法并不熟悉，但看起来仍然简洁易懂——大部分情况下，它看起来很简单。我不禁会想，“我看到了所有这些带括号的部分，但实际代码在哪里？”</li><li id="869e" class="jy jz hu it b iu ki iy kj jc kk jg kl jk km jo kd ke kf kg dt translated">代码非常紧凑——大约100行。同样，他们的<a class="ae jp" href="http://play.witheve.com/#/examples/todomvc.eve" rel="noopener ugc nofollow" target="_blank"> todomvc.eve </a>只有63行。相比之下，<a class="ae jp" href="https://github.com/tastejs/todomvc/tree/gh-pages/examples/react" rel="noopener ugc nofollow" target="_blank"> React的TodoMVC </a>有300多行JavaScript。</li></ul><p id="3add" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是我的第一印象。这是我花了几个小时浏览示例、思考文档和观看技术演讲视频后的印象:哇！</p><p id="3439" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Eve是一个解决问题的聚宝盆，我甚至没有意识到我们有这些问题。这就像我在一个骑自行车的社会中长大，在第一次看到机动车辆后，我突然明白了基于踏板的建筑的局限性。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff ks"><img src="../Images/d673eeebe8ed328fb3841bd6016f6809.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*-WHmnEaiKTSli0TYHqWuVg.png"/></div></figure><p id="42f1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在接触过Eve之后，我可以追溯性地诊断主流编程栈架构中的各种问题。在这个系列中，我将尝试解释所有这些问题是什么以及Eve如何解决它们。</p><h1 id="c1e4" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">问题:层做同样的事情不同</h1><p id="d3e7" class="pw-post-body-paragraph ir is hu it b iu lr iw ix iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo hn dt translated">您的软件堆栈有许多层。以下三层通常是承担重任的“核心系统”:</p><ul class=""><li id="cf19" class="jy jz hu it b iu iv iy iz jc ka jg kb jk kc jo kd ke kf kg dt translated">数据库层</li><li id="de93" class="jy jz hu it b iu ki iy kj jc kk jg kl jk km jo kd ke kf kg dt translated">远程API层</li><li id="fc18" class="jy jz hu it b iu ki iy kj jc kk jg kl jk km jo kd ke kf kg dt translated">应用层</li></ul><p id="93f6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，核心系统还与许多其他层进行对话:</p><ul class=""><li id="9afe" class="jy jz hu it b iu iv iy iz jc ka jg kb jk kc jo kd ke kf kg dt translated">渲染层</li><li id="8f20" class="jy jz hu it b iu ki iy kj jc kk jg kl jk km jo kd ke kf kg dt translated">I/O事件层</li><li id="0f0f" class="jy jz hu it b iu ki iy kj jc kk jg kl jk km jo kd ke kf kg dt translated">配置层</li><li id="9bbf" class="jy jz hu it b iu ki iy kj jc kk jg kl jk km jo kd ke kf kg dt translated">记录层</li></ul><p id="05b5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在高层次上，这些层都做同样的事情:它们处理数据。它们读取输入值，计算其他值，改变内部状态，输出值传递给其他层。但是，当您放大到每一层时，您会看到无数的差异，这些差异掩盖了一个事实，即它们都是关于数据处理的。</p><h2 id="b559" class="lw ku hu bd kv lx ly lz kz ma mb mc ld jc md me lh jg mf mg ll jk mh mi lp mj dt translated">不同的数据模型</h2><p id="5c94" class="pw-post-body-paragraph ir is hu it b iu lr iw ix iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo hn dt translated">您有一个或多个在线数据库系统。他们的数据模型看起来像SQL表、文档集合、键值映射和/或图形。</p><p id="50b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您有一个远程API，它将数据建模为JSON或XML块，或者可能是GraphQL图。</p><p id="116b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您有一个正在运行的应用程序，它在作用域链中模拟内存中的数据结构和变量。</p><h2 id="a35c" class="lw ku hu bd kv lx ly lz kz ma mb mc ld jc md me lh jg mf mg ll jk mh mi lp mj dt translated">不同的操作</h2><p id="e262" class="pw-post-body-paragraph ir is hu it b iu lr iw ix iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo hn dt translated">要在数据库层上操作，您可以发送各种SQL或NoSQL查询。</p><p id="f27f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要在API层上操作，可以通过HTTP GET查询数据，通过HTTP POST和friends更新数据。如果是GraphQL API，你操作的是GQL查询和变异。</p><p id="b6b1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了在应用层上操作，可以从作用域链中查找变量，并且可以遍历或改变内存中的数据结构。</p></div><div class="ab cl mk ml hc mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hn ho hp hq hr"><p id="72f6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于堆栈的每一层，都有不同的数据模型和操作:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/4898c83e397058328bf430d673faa74f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*5REPO9fgVMpKJVcxiuwyeQ.png"/></div></figure><p id="2a38" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于每一层都不同，这就产生了摩擦和误差。您必须分别考虑每一个的属性和保证，并为每一个使用单独的编程模式。而且你还要写很多“胶水代码”。</p><h1 id="4b65" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">解决方案:统一的数据处理语言</h1><p id="ee87" class="pw-post-body-paragraph ir is hu it b iu lr iw ix iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo hn dt translated">Eve有一个单一的底层数据模型和一组操作，您可以跨堆栈的每一层使用它们。</p><h2 id="d2e0" class="lw ku hu bd kv lx ly lz kz ma mb mc ld jc md me lh jg mf mg ll jk mh mi lp mj dt translated">统一数据模型</h2><p id="ecf8" class="pw-post-body-paragraph ir is hu it b iu lr iw ix iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo hn dt translated">在Eve中，数据(也称为状态)存在于一组<strong class="it hv">数据库</strong>中。堆栈的不同层可能对应不同的数据库，例如:</p><ul class=""><li id="556d" class="jy jz hu it b iu iv iy iz jc ka jg kb jk kc jo kd ke kf kg dt translated">内存中的应用程序数据保存在<code class="eh ms mt mu mv b">@session</code>数据库中</li><li id="80db" class="jy jz hu it b iu ki iy kj jc kk jg kl jk km jo kd ke kf kg dt translated">浏览器的DOM树位于<code class="eh ms mt mu mv b">@browser</code>数据库中</li><li id="b2dc" class="jy jz hu it b iu ki iy kj jc kk jg kl jk km jo kd ke kf kg dt translated">用户I/O事件存在于<code class="eh ms mt mu mv b">@event</code>数据库中</li></ul><p id="d60b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每个数据库包含<strong class="it hv">记录</strong>。记录是一个键值映射，可以存储原始值以及对其他记录的引用。记录具有简单的括号语法:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff mw"><img src="../Images/d0f3164cac6932825a1521ef093adaa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*7y-uSPVDOqEUSVoG18ZQQQ.png"/></div></figure><p id="8653" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">数据库中没有保存记录的表或集合，只有包含记录的链接结构的数据库。</p><p id="87be" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Eve的链接记录通用数据模型让人想起“语义网”技术，如<a class="ae jp" href="https://en.wikipedia.org/wiki/Resource_Description_Framework" rel="noopener ugc nofollow" target="_blank"> RDF </a>和<a class="ae jp" href="http://json-ld.org/" rel="noopener ugc nofollow" target="_blank"> JSON-LD </a>。但是Eve不仅仅是一个统一的数据模型…</p><h2 id="60c6" class="lw ku hu bd kv lx ly lz kz ma mb mc ld jc md me lh jg mf mg ll jk mh mi lp mj dt translated">统一操作集</h2><p id="10b8" class="pw-post-body-paragraph ir is hu it b iu lr iw ix iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo hn dt translated">也是一套统一的操作。三个操作<code class="eh ms mt mu mv b">search</code>、<code class="eh ms mt mu mv b">commit</code>和<code class="eh ms mt mu mv b">bind</code>构成了Eve的全部功能:</p><ul class=""><li id="d9a1" class="jy jz hu it b iu iv iy iz jc ka jg kb jk kc jo kd ke kf kg dt translated"><code class="eh ms mt mu mv b">search</code>查询数据，类似于SQL的<code class="eh ms mt mu mv b">SELECT</code></li><li id="30b3" class="jy jz hu it b iu ki iy kj jc kk jg kl jk km jo kd ke kf kg dt translated"><code class="eh ms mt mu mv b">commit</code>改变数据的状态，类似于SQL的<code class="eh ms mt mu mv b">INSERT</code> / <code class="eh ms mt mu mv b">UPDATE</code> / <code class="eh ms mt mu mv b">DELETE</code></li><li id="5692" class="jy jz hu it b iu ki iy kj jc kk jg kl jk km jo kd ke kf kg dt translated"><code class="eh ms mt mu mv b">bind</code>写特殊的“推导值”，比如SQL的<a class="ae jp" href="https://en.wikipedia.org/wiki/Materialized_view" rel="noopener ugc nofollow" target="_blank">物化视图</a>或者MobX的<a class="ae jp" href="https://mobxjs.github.io/mobx/refguide/computed-decorator.html" rel="noopener ugc nofollow" target="_blank">计算值</a>。在这个系列的后面，我会说更多关于<code class="eh ms mt mu mv b">bind</code>的精彩之处。</li></ul><p id="6e4e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">令人惊讶的是，我们可以通过在Eve的统一数据模型上使用这种统一的操作集来控制堆栈的不同层。例如，下面是我们如何将一个<code class="eh ms mt mu mv b">&lt;div&gt;</code>渲染到DOM中:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff mx"><img src="../Images/272eb59bfa21c511b5f0db05eac43930.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*4Vvdz7ee4YndJ_ac4m40MA.png"/></div></figure><p id="368c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为DOM树存在于<code class="eh ms mt mu mv b">@browser</code>数据库中，所以呈现一个<code class="eh ms mt mu mv b">&lt;div&gt;</code>仅仅意味着用<code class="eh ms mt mu mv b">tag: "div"</code>处理一个记录。</p></div><div class="ab cl mk ml hc mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hn ho hp hq hr"><p id="06cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，对于堆栈的每一层，只有一个数据模型和一组操作:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff my"><img src="../Images/78c1b0a6ed7a551acb191b1b325906ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*1TvRKiUNEUX7UfgtIlDjpA.png"/></div></figure><p id="e37c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为每一层都是一样的，所以摩擦更少，误差也更小。您可以更容易地对属性和保证进行推理，并对每个属性和保证使用相似的编程模式。你不需要把任何东西“粘”在一起，因为所有东西都已经连接在一起了。</p><h1 id="24c5" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">更高的抽象</h1><p id="c6af" class="pw-post-body-paragraph ir is hu it b iu lr iw ix iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo hn dt translated">Eve团队发明了一个统一的数据模型和一组统一的操作，可以跨整个应用程序堆栈运行。为了完成这一壮举，他们必须确定一个更高的抽象，我们其他人都没有意识到这是可能的。</p><p id="887f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你已经努力去理解今年出现的另一个抽象飞跃:<a class="ae jp" href="http://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>，这将有助于你理解这一成就。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff mz"><img src="../Images/ee4ff299834507bb286beffbc67b5137.png" data-original-src="https://miro.medium.com/v2/resize:fit:316/format:webp/1*49M2kyC4ncD5kc0e4DmVxg.png"/></div></figure><p id="b4da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">人们需要一段时间才能理解GraphQL不是一个数据库或服务器，而是一种图形查询语言(如果你愿意，也可以称为“GraphQL”)。GraphQL的目的是将客户对API的看法从一个小的严格的REST端点集合改变为一个统一的链接数据结构，该结构接受任意的图形查询。</p><p id="6118" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">像GraphQL一样，Eve也不是数据库后端或服务器；这是一种比我们习惯的抽象层次更高的语言。考虑Eve<a class="ae jp" href="http://witheve.com/" rel="noopener ugc nofollow" target="_blank">主页</a>中题为“一个简单的模型:作为数据的世界”部分的示例代码:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="fe ff na"><img src="../Images/1b275d53de5883732028873b8f78c5c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lYw3w-3whO96J8u7Lw_dpw.png"/></div></div></figure><p id="6409" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当您运行那个<code class="eh ms mt mu mv b">search @slack</code>块时，您正在与第三方Slack应用程序通信，该应用程序当然有自己的内部数据库。但是你可以<em class="kh">假装</em>一切都是Eve数据宇宙的一部分——就像GraphQL让你假装任意的API调用是一个大图宇宙的一部分。</p><p id="9d0f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，如果你喜欢GraphQL为API层所做的事情，但只是希望有人能一下子为所有其他层做同样的事情…向Eve问好。</p></div><div class="ab cl mk ml hc mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hn ho hp hq hr"><p id="aa03" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">下篇:<br/> </strong> <a class="ae jp" href="https://hackernoon.com/when-logic-programming-meets-cqrs-1137ab2a5f86" rel="noopener ugc nofollow" target="_blank"> <em class="kh">二。</em>当逻辑编程遇上CQRS </a></p><div class="jr js jt ju fq ab cb"><figure class="nb jv nc nd ne nf ng paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nb jv nc nd ne nf ng paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nb jv nc nd ne nf ng paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="nh ni nj"><p id="f922" class="ir is kh it b iu iv iw ix iy iz ja jb nk jd je jf nl jh ji jj nm jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是阿妹家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>的机会。</p><p id="708a" class="ir is kh it b iu iv iw ix iy iz ja jb nk jd je jf nl jh ji jj nm jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jr js jt ju fq jv fe ff paragraph-image"><a href="https://goo.gl/Ahtev1"><div class="fe ff nn"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></a></figure></div></div>    
</body>
</html>