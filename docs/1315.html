<html>
<head>
<title>Using Models with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用带React的模型</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/introducing-react-axiom-84bf37a50adb?source=collection_archive---------1-----------------------#2016-10-11">https://medium.com/hackernoon/introducing-react-axiom-84bf37a50adb?source=collection_archive---------1-----------------------#2016-10-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/a45dac7e28632ea39b17c0e200c3ce66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zzLVMt2f4cFoMH6_NlOSxg.png"/></div></div></figure><div class=""/><div class=""><h2 id="ae43" class="pw-subtitle-paragraph jc ie if bd b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ek translated">引入React公理</h2></div><p id="582c" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated"><em class="kq">2016年11月16日编辑反映了自本文最初发表以来API的变化。</em></p><p id="3364" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">在React应用程序中的某个时刻，在单个组件级别描述应用程序数据的状态变化变得很困难，需要在业务逻辑和表示组件之间进行清晰的抽象。Redux在这一点上当然是一个选项，但是假设Redux提供的<a class="ae kr" rel="noopener" href="/@dan_abramov/you-might-not-need-redux-be46360cf367">权衡</a>是不利的呢？</p><p id="9ac5" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated"><a class="ae kr" href="https://github.com/wgoto/react-axiom" rel="noopener ugc nofollow" target="_blank"> React Axiom </a>是一种轻量级的(~12kb)方式，通过React组件树来使用模型。一个基本的React Axiom模型如下所示:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="2e6f" class="lb lc if kx b fv ld le l lf lg">class ListItemModel extends ReactAxiom.Model {</span><span id="5d24" class="lb lc if kx b fv lh le l lf lg">  static defaultState() {<br/>    return {<br/>      id: null,<br/>      description: '',<br/>      completed: false<br/>    };<br/>  }</span><span id="3e50" class="lb lc if kx b fv lh le l lf lg">}</span></pre><p id="b321" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated"><code class="eh li lj lk kx b">Model</code>将argument对象存储在<code class="eh li lj lk kx b">this.state</code>中，并自动创建getter和setter函数:<code class="eh li lj lk kx b">id</code>属性的<code class="eh li lj lk kx b">getId</code>、<code class="eh li lj lk kx b">setId</code>、<code class="eh li lj lk kx b">hasId</code>、<code class="eh li lj lk kx b">description</code>属性的<code class="eh li lj lk kx b">getDescription</code>、<code class="eh li lj lk kx b">setDescription</code>、<code class="eh li lj lk kx b">hasDescription</code>、<code class="eh li lj lk kx b">completed</code>属性的<code class="eh li lj lk kx b">isCompleted</code>、<code class="eh li lj lk kx b">setCompleted</code>、<code class="eh li lj lk kx b">hasCompleted</code>(注意:由于completed属性是布尔值，所以这是不同的)。在类上定义同名的方法会覆盖getter或setter:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="0cf4" class="lb lc if kx b fv ld le l lf lg">class ListItemModel extends ReactAxiom.Model {</span><span id="9167" class="lb lc if kx b fv lh le l lf lg">  static defaultState() {<br/>    return {<br/>      id: null,<br/>      description: '',<br/>      completed: false<br/>    };<br/>  }</span><span id="4497" class="lb lc if kx b fv lh le l lf lg">  getDescription() {<br/>    return this.state.description.toLowerCase();<br/>  }</span><span id="df9c" class="lb lc if kx b fv lh le l lf lg">}</span></pre><p id="d6a9" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">当一个React Axiom模型被传递到一个组件中时，该组件监听模型中的状态变化并更新自己。下面是一个React组件的例子，它使用了下面作为<code class="eh li lj lk kx b">listItem</code>传递的模型:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="71ca" class="lb lc if kx b fv ld le l lf lg">class ListItemComponent extends React.Component {</span><span id="2b31" class="lb lc if kx b fv lh le l lf lg">  render() {<br/>    const { listItem } = this.props;<br/>    return (<br/>      &lt;li&gt;<br/>        {listItem.getDescription()}<br/>        {listItem.isCompleted() ? null : this.renderButton()}<br/>      &lt;/li&gt;<br/>    );<br/>  }</span><span id="b9aa" class="lb lc if kx b fv lh le l lf lg">  renderButton() {<br/>    const { listItem } = this.props;<br/>    return (<br/>      &lt;button onClick={() =&gt; listItem.setCompleted(true)}&gt;<br/>        complete<br/>      &lt;/button&gt;<br/>    );<br/>  }</span><span id="99b3" class="lb lc if kx b fv lh le l lf lg">}</span></pre><p id="4ab2" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">注意组件如何调用<code class="eh li lj lk kx b">listItem</code>模型上的<code class="eh li lj lk kx b">setCompleted</code>来更新状态。将所有东西放在一起:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="841e" class="lb lc if kx b fv ld le l lf lg">const listItem = new ListItemModel({<br/>  id: '1',<br/>  description: 'Teach mom how to use Slack'<br/>});</span><span id="aa5b" class="lb lc if kx b fv lh le l lf lg">const ListItemSubscriber = ReactAxiom.subscribe(ListItemComponent);</span><span id="5d2b" class="lb lc if kx b fv lh le l lf lg">ReactDOM.render(<br/>  &lt;ListItemSubscriber listItem={listItem} /&gt;,<br/>  document.getElementById('app')<br/>);</span></pre><p id="bcd5" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">高阶<code class="eh li lj lk kx b">subscribe</code>函数包装<code class="eh li lj lk kx b">ListItemComponent</code>并返回一个新的<code class="eh li lj lk kx b">ListItemSubscriber</code>组件。然后，<code class="eh li lj lk kx b">ListItemSubscriber</code>组件将订阅<code class="eh li lj lk kx b">listItem</code>模型，并在状态改变时自我更新。在上面的具体例子中，点击完成按钮将导致按钮消失。</p><h1 id="637c" class="ll lc if bd lm ln lo lp lq lr ls lt lu jl lv jm lw jo lx jp ly jr lz js ma mb dt translated">引用变得复杂</h1><p id="4845" class="pw-post-body-paragraph ju jv if jw b jx mc jg jz ka md jj kc kd me kf kg kh mf kj kk kl mg kn ko kp hn dt translated">React Axiom模型中的状态变化是通过突变发生的。因此，这种设计允许对其他对象、数组和模型的引用在状态中很好地操作。以下示例将一个<code class="eh li lj lk kx b">dependencies</code>字段添加到<code class="eh li lj lk kx b">ListItemModel</code>中，并添加一些额外的逻辑来完成一个列表项。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="5492" class="lb lc if kx b fv ld le l lf lg">class ListItemComponent extends ReactAxiom.Model {</span><span id="4751" class="lb lc if kx b fv lh le l lf lg">  static defaultState() {<br/>    return {<br/>      id: null,<br/>      description: '',<br/>      completed: false,<br/>      dependencies: [],<br/>    };<br/>  }</span><span id="78c0" class="lb lc if kx b fv lh le l lf lg">  complete() {<br/>    this.getDependencies().forEach(dependency =&gt; {<br/>      dependency.complete();<br/>    });</span><span id="8a8d" class="lb lc if kx b fv lh le l lf lg">    this.setCompleted(true);<br/>  }</span><span id="e22f" class="lb lc if kx b fv lh le l lf lg">}</span></pre><p id="ad40" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">为了递归地呈现列表项，<code class="eh li lj lk kx b">ListItemComponent</code>组件可以为每个依赖项呈现<code class="eh li lj lk kx b">ListItemSubscriber</code>组件:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="5883" class="lb lc if kx b fv ld le l lf lg">class ListItemComponent extends React.Component {</span><span id="3766" class="lb lc if kx b fv lh le l lf lg">  render() {<br/>    const { listItem } = this.props;<br/>    return (<br/>      &lt;li&gt;<br/>        {listItem.getDescription()}<br/>        {listItem.isCompleted() ? null : this.renderButton()}<br/>        &lt;ul&gt;<br/>          {this.renderDependencies()}<br/>        &lt;/ul&gt;<br/>      &lt;/li&gt;<br/>    );<br/>  }</span><span id="040c" class="lb lc if kx b fv lh le l lf lg">  renderButton() {<br/>    const { listItem } = this.props;<br/>    return (<br/>      &lt;button onClick={() =&gt; listItem.complete()}&gt;<br/>        complete<br/>      &lt;/button&gt;<br/>    );<br/>  }</span><span id="b957" class="lb lc if kx b fv lh le l lf lg">  renderDependencies() {<br/>    const { listItem } = this.props;<br/>    return listItem.getDependencies().map(dependency =&gt; (<br/>      &lt;ListItemSubscriber listItem={dependency} /&gt;<br/>    ));<br/>  }</span><span id="31fb" class="lb lc if kx b fv lh le l lf lg">}</span><span id="2783" class="lb lc if kx b fv lh le l lf lg">const ListItemSubscriber = ReactAxiom.subscribe(ListItemComponent);</span></pre><p id="9b09" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">现在，点击一个完整的按钮将会改变该模型的<code class="eh li lj lk kx b">completed</code>状态值及其所有依赖的<code class="eh li lj lk kx b">completed</code>状态值。此外，订阅任何变异列表项的任何组件都将更新并呈现正确的状态。</p><h1 id="9fd5" class="ll lc if bd lm ln lo lp lq lr ls lt lu jl lv jm lw jo lx jp ly jr lz js ma mb dt translated">与服务器渲染一起使用</h1><p id="2854" class="pw-post-body-paragraph ju jv if jw b jx mc jg jz ka md jj kc kd me kf kg kh mf kj kk kl mg kn ko kp hn dt translated">React Axiom的一个特别的缺点是，数据存储需要将模型名称作为可传输数据的一部分进行传递。这对于从服务器到客户机的数据传输来说很好，但是如果模型名称以任何方式改变，那么在快照和将状态保存到本地存储方面就不太灵活了。下面是一个用React Axiom <code class="eh li lj lk kx b">Store</code>序列化和解析模型和模型数据的例子:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="0f8b" class="lb lc if kx b fv ld le l lf lg">const listItem1 = new ListItemModel({<br/>  id: '1',<br/>  description: 'Teach mom how to use Slack'<br/>});</span><span id="f8b3" class="lb lc if kx b fv lh le l lf lg">const listItem2 = new ListItemModel({<br/>  id: '2',<br/>  description: 'Meditate',<br/>  dependencies: [listItem1]<br/>});</span><span id="f317" class="lb lc if kx b fv lh le l lf lg">ReactAxiom.Store.setModelRefs([ListItemModel]);</span><span id="6a9a" class="lb lc if kx b fv lh le l lf lg">const serverStore = new ReactAxiom.Store({<br/>  title: 'Things to do',<br/>  createdAt: Date.now(),<br/>  listItems: [listItem1, listItem2]<br/>});</span><span id="4ca7" class="lb lc if kx b fv lh le l lf lg">const json = serverStore.stringify();</span><span id="ab4f" class="lb lc if kx b fv lh le l lf lg">// Transfer the data to the client<br/>// to hydrate the client store, and<br/>// reinitialize the application.</span><span id="07ac" class="lb lc if kx b fv lh le l lf lg">ReactAxiom.Store.setModelRefs([ListItemModel]);</span><span id="073e" class="lb lc if kx b fv lh le l lf lg">const clientStore = new ReactAxiom.Store();</span><span id="50d7" class="lb lc if kx b fv lh le l lf lg">clientStore.parse(json);</span></pre><p id="6e3b" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">注意<code class="eh li lj lk kx b">listItem2</code>是如何在服务器存储中包含对<code class="eh li lj lk kx b">listItem1</code>的引用的。通过传入类来初始化客户端存储，它能够从提供的JSON字符串重新构建这个引用。换句话说，<code class="eh li lj lk kx b">listItem2.getDependences()[0] === listItem1</code>上<code class="eh li lj lk kx b">clientStore</code>。</p><h1 id="6ccf" class="ll lc if bd lm ln lo lp lq lr ls lt lu jl lv jm lw jo lx jp ly jr lz js ma mb dt translated">何时使用模型</h1><p id="3ac2" class="pw-post-body-paragraph ju jv if jw b jx mc jg jz ka md jj kc kd me kf kg kh mf kj kk kl mg kn ko kp hn dt translated">像任何设计一样，也有权衡。例如，Redux需要简单的对象来描述系统中的变化，需要纯粹的函数来描述处理这些变化的逻辑(许多开发人员称之为“样板”)，但却获得了更灵活的数据存储。React Axiom需要模型来描述系统中的变化<em class="kq">和</em>来描述处理这些变化的逻辑，但是具有以下优点:</p><ul class=""><li id="83f2" class="mh mi if jw b jx jy ka kb kd mj kh mk kl ml kp mm mn mo mp dt translated">组织和清除业务逻辑变得更加容易。</li><li id="5333" class="mh mi if jw b jx mq ka mr kd ms kh mt kl mu kp mm mn mo mp dt translated">视图、模型和数据之间的接口变得更加灵活。</li><li id="a8f7" class="mh mi if jw b jx mq ka mr kd ms kh mt kl mu kp mm mn mo mp dt translated">编写语义透明的代码变得更加容易。</li></ul><p id="9b5d" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">对于React生态系统的新手来说，React Axiom可能比Redux更有意义，但是像任何固执己见的框架或设计一样，只有在解决特定问题或适合特定情况时才使用它。</p><h1 id="f943" class="ll lc if bd lm ln lo lp lq lr ls lt lu jl lv jm lw jo lx jp ly jr lz js ma mb dt translated">下一步是什么？</h1><p id="7e5a" class="pw-post-body-paragraph ju jv if jw b jx mc jg jz ka md jj kc kd me kf kg kh mf kj kk kl mg kn ko kp hn dt translated">React Axiom仍处于起步阶段。我欢迎任何帮助，让这个设计范例成为JavaScript社区大规模应用程序的健壮解决方案。请随时通过查看GitHub库或通过Twitter 联系我<a class="ae kr" href="https://twitter.com/wrgoto" rel="noopener ugc nofollow" target="_blank">参与进来。🙏🏽</a></p><div class="ks kt ku kv fq ab cb"><figure class="mv hw mw mx my mz na paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mv hw mw mx my mz na paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mv hw mw mx my mz na paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="nb nc nd"><p id="f922" class="ju jv kq jw b jx jy jg jz ka kb jj kc ne ke kf kg nf ki kj kk ng km kn ko kp hn dt translated"><a class="ae kr" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kr" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kr" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae kr" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ju jv kq jw b jx jy jg jz ka kb jj kc ne ke kf kg nf ki kj kk ng km kn ko kp hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kr" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kr" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ks kt ku kv fq hw fe ff paragraph-image"><a href="https://goo.gl/Ahtev1"><div class="fe ff nh"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></a></figure></div></div>    
</body>
</html>