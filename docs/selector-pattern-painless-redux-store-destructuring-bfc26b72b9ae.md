# 选择器模式:无痛还原商店销毁

> 原文：<https://medium.com/hackernoon/selector-pattern-painless-redux-store-destructuring-bfc26b72b9ae>

Redux 很棒，因为它明确定义了所有可能的状态转换(动作)以及这些转换如何改变存储(reducers)——但它没有为组件*查询*存储规定一种方式。

解决这个问题的一个方法是通过使用*选择器模式*，将状态访问集中在一个地方，降低代码复杂度。

![](img/2bade6b44e349cbc4ba23f4f7c6fa5c5.png)

## TLDR

*   [选择器模式](#7264)
*   [React 组件中的实现](#9ca1)
*   [派生选择器实现](#bc2c)
*   [性能优化:缓存](#5f2d)

*这篇文章由* [*卡梅隆·桑普森*](http://cameronsampson.com/) 进行了同行评议

## 选择器模式

Redux 存储允许[应用](https://hackernoon.com/tagged/application)集中全局应用状态(例如，在两个或更多组件之间共享的状态)。这是一件好事，因为它降低了应用程序的复杂性。选择器模式解决了应用程序应该如何从这种集中状态获取值的问题。

这个问题的一个常见解决方案是通过直接引用来访问存储:

这种方法的问题是，它要求你的应用程序代码知道商店的确切形状——如果商店的形状发生变化，你就必须更新从中读取的每一位应用程序代码。这种解决方案延续了集中关注点的良好实践，最大限度地降低了代码的复杂性。

**选择器模式**是一种抽象，它标准化了应用程序的存储查询逻辑。*很简单*:对于应用程序需要访问的存储的任何部分，定义一个函数，当给定完整的存储时，该函数返回期望的存储部分(或派生部分)。

跳过选择器模式并让组件拥有商店形状的一些基本知识是很有诱惑力的，特别是如果它是一个简单的引用:

我建议对于所有的存储查询，应用程序应该使用选择器模式，不管查找的复杂性如何。如果商店的实现被重构，那么通过使用选择器模式，需要相关更新的引用数量将被最小化。

## React 组件中的实现

对于所有的存储查询，应用程序只需要将完整的存储传递给适当的选择器:

在`mapStateToProps`中，我们简单地将`store`传递给正确的选择器。该组件不知道选择器的实现，只知道特定的选择器将返回正确的部分或`store`的*或*。

选择器是从根缩减器模块导入的:

在根归约器模块中包含选择器是有意义的，因为它们需要了解应用程序存储的根的形状。这是知识生活的模块。因此，如果存储根的形状发生变化，这可能是唯一需要更改的文件。

这些选择器共享一个公共接口:它们期望应用程序的完整的`store`对象作为函数的第一个参数。为了解析所需的值，这些函数由一个或多个*私有*选择器调用组成。由于*公共*选择器期望*完整存储*作为其第一个参数，每个私有选择器期望存储的*子集作为其第一个参数。*

每个私有选择器与完整存储的一个特定子集相关联，就像每个缩减器配置与完整存储的一个片相关联一样。因此，私有选择器和归约器配置可以优雅地存在于同一个模块中:

选择器的这种公共/私有模式允许:

1.  缩减器的配置需要更改，而公共选择器实现不太可能需要更改
2.  两个或多个公共选择器可以共享更干燥、更易于维护的代码的私有选择器

## 派生选择器实现

如前所述，公共选择器的实现可以像调用一个私有选择器一样简单。然而，更复杂的实现当然是可能的。

*   **由多个私有选择器组成的选择器**:一个公共选择器可以返回多个私有选择器的结果。想象一下一个`isLoading`公共选择器被实现为两个或更多`isLoading`私有选择器的结果:

*   ***计算*来自** `**store**`某部分的结果的选择器:

## 性能优化:缓存

如果发现特定的公共选择器缺乏实时性能(例如，在大列表上搜索、昂贵的数学计算等。)，缓存选择器调用的结果可能证明是有益的。 [Reselect](https://github.com/reactjs/reselect) 库是选择器*记忆化*的一个流行实现(即缓存函数调用的结果，以传递的参数为键)，它也为从多个私有选择器合成公共选择器提供了一个简单的语法。