<html>
<head>
<title>Creating websites using React and Django REST Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React和Django REST框架创建网站</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/creating-websites-using-react-and-django-rest-framework-b14c066087c7?source=collection_archive---------0-----------------------#2017-07-25">https://medium.com/hackernoon/creating-websites-using-react-and-django-rest-framework-b14c066087c7?source=collection_archive---------0-----------------------#2017-07-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/53cf19e479c9b3db6f2128d1d1454d1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*93A43jqOXZYUr0yFMkcnNw.png"/></div></div></figure><p id="bff7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最近在工作中，我们使用React前端和Django REST框架(DRF)后端来创建网站。这两者在前端通过使用axios的API调用来连接。一些<a class="ae ka" href="https://hackernoon.com/tagged/redux" rel="noopener ugc nofollow" target="_blank"> Redux </a>也用于存储全局应用状态。这是我们的首选方法，因为它允许前端和后端完全解耦。只要我们定义一个端点和返回数据的列表，前端和后端就可以并行开发。这也让我们可以选择在未来轻松地为任何项目创建移动应用程序，因为他们可以只使用后端API。另外，我们目前正在考虑在未来的移动应用项目中使用React Native。</p><p id="948f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这篇文章的其余部分，我将介绍如何设置一个反应前端和DRF后端项目。注:我假设你已经熟悉React，Redux，Django，DRF，npm等。这不是他们的教程。</p><h1 id="ca1e" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">后端</h1><p id="6dd5" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">除了简单地安装Django和DRF，并设置数据库之外，默认后端没有太多事情要做。从你的项目文件夹的根目录，创建一个virtualenv并安装Django和DRF。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="6d45" class="ln kc hu lj b fv lo lp l lq lr">$ virtualenv env<br/>$ source env/bin/activate<br/>$ pip3 install django djangorestframework<br/>$ pip3 freeze &gt; requirements.txt</span></pre><p id="0f9c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在开始一个新的Django项目和Django app。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="af0c" class="ln kc hu lj b fv lo lp l lq lr">$ django-admin startproject backend<br/>$ cd backend<br/>$ django-admin startapp api</span></pre><p id="3c6e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，您应该设置数据库并编辑项目设置以使用该数据库。在<a class="ae ka" href="https://docs.djangoproject.com/en/1.11/topics/install/#get-your-database-running" rel="noopener ugc nofollow" target="_blank"> Django的网站</a>上可以找到关于如何为您的特定DB做这件事的好文档。然后你应该按照他们网站上的说明配置DRF。</p><p id="3666" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下一步您很可能要在API中设置身份验证。如果您不需要认证(例如，没有用户登录)，您可以跳过这一步。我公司的React/Django模板项目目前使用普通令牌认证，因为它最容易设置。我也向那些学习者推荐这种方法，但它对生产来说不是最好的。这些令牌永不过期，一旦泄露，会带来相当大的安全风险。很快我们将更新模板项目，使用oauth或过期JWT令牌之类的东西——目前还没有决定。配置令牌认证的文档在这里是<a class="ae ka" href="http://www.django-rest-framework.org/api-guide/authentication/#tokenauthentication" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="5e47" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦令牌认证被配置，你将想要在你的应用中创建一个<code class="eh ls lt lu lj b">urls.py </code>(如果你还没有的话)，并且使用DRF的令牌认证视图。这个位于<code class="eh ls lt lu lj b">/auth</code>的端点允许用户发布他们的用户名和密码，并获得他们的身份验证令牌作为响应。在前端，这个令牌将被存储在Redux存储中，以供进一步的API调用。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="a9af" class="ln kc hu lj b fv lo lp l lq lr"># file: api/urls.py</span><span id="c1a6" class="ln kc hu lj b fv lv lp l lq lr">from django.conf.urls import url<br/>from rest_framework.authtoken import views as drf_views</span><span id="869e" class="ln kc hu lj b fv lv lp l lq lr">urlpatterns = [<br/>    url(r'^auth$', drf_views.obtain_auth_token, name='auth'),<br/>]</span></pre><p id="351e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了确保它是清楚的，你的<code class="eh ls lt lu lj b">backend/urls.py</code>文件现在应该是这样的</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="ecd9" class="ln kc hu lj b fv lo lp l lq lr"># file: backend/urls.py</span><span id="4900" class="ln kc hu lj b fv lv lp l lq lr">from django.conf.urls import url, include<br/><br/>urlpatterns = [<br/>    url(r'^', include('api.urls', namespace='api', app_name='api')),<br/>]</span></pre><p id="2c96" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过这样做，我们只是让每个应用程序关注自己的URL。也许将来你会在后端添加更多的应用程序，把所有东西都添加到<code class="eh ls lt lu lj b">backend/urls.py</code>会变得很麻烦</p><p id="14b4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在您应该有了一个运行正常的后端DRF API，它有一个端点<code class="eh ls lt lu lj b">/auth</code>，让用户获得他们的身份验证令牌。让我们设置一个用户，然后运行后端服务器进行测试。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="b6d2" class="ln kc hu lj b fv lo lp l lq lr">$ python3 manage.py migrate<br/>$ python3 manage.py createsuperuser<br/>$ python3 manage.py runserver 0.0.0.0:8000</span></pre><p id="789f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">记得第一次运行migrate来创建数据库。然后，我们将创建一个用户，我们可以为其获取一个身份验证令牌。现在服务器正在运行，您可以使用curl快速测试您的<code class="eh ls lt lu lj b">/auth</code>端点的工作情况</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="f87f" class="ln kc hu lj b fv lo lp l lq lr">$ curl -X POST -d "username=username&amp;password=password" http://localhost:8000/auth</span></pre><h1 id="d667" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">前端</h1><p id="a6e9" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">对于前端，我们使用脸书的create-react-app作为起点。所以要做的第一件事就是安装它，并使用它在项目文件夹的根目录下创建一个新项目。当我们需要更多的控制时，我们也退出配置，我们团队中的每个人都可以使用webpack等。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="f189" class="ln kc hu lj b fv lo lp l lq lr">$ npm install -g create-react-app<br/>$ create-react-app frontend<br/>$ cd frontend<br/>$ npm run eject</span></pre><p id="4260" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我们希望安装一些附加的依赖项。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="0f7e" class="ln kc hu lj b fv lo lp l lq lr">$ npm install --save-dev babel-preset-es2015 babel-preset-stage-3<br/>$ npm install --save redux redux-logger redux-persist react-redux<br/>$ npm install --save axios react-router-dom lodash</span></pre><p id="f6c2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我不再列出React模板项目使用的所有代码，而是展示连接前端和后端的重要部分。首先创建一个redux存储，因为我们希望保存用户的auth令牌，以便将来进行更多的API调用</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="0cc8" class="ln kc hu lj b fv lo lp l lq lr">// file: src/store.js<br/>import { compose, createStore, applyMiddleware } from 'redux';<br/>import { createLogger } from 'redux-logger';<br/>import { persistStore, autoRehydrate } from 'redux-persist';<br/>import rootReducer from './reducers';<br/><br/>const store = createStore(<br/>  rootReducer,<br/>  compose(<br/>    applyMiddleware(<br/>      createLogger(),<br/>    ),<br/>    autoRehydrate()<br/>  )<br/>);<br/>persistStore(store);<br/>export default store;</span></pre><p id="de6a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后设置令牌缩减器</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="02e8" class="ln kc hu lj b fv lo lp l lq lr">// file: src/reducers/index.js<br/>import { combineReducers } from 'redux';<br/>import * as actionType from '../actions/types';<br/><br/>const tokenInitialState = null;<br/>const token = (state = tokenInitialState, action) =&gt; {<br/>  switch(action.type) {<br/>    case actionType.SET_TOKEN:<br/>      return action.data;<br/>    default:<br/>      return state;<br/>  }<br/>}<br/><br/>const appReducer = combineReducers({<br/>  token,<br/>})<br/><br/>const rootReducer = (state, action) =&gt; {<br/>  return appReducer(state, action);<br/>}<br/><br/>export default rootReducer;</span></pre><p id="0acf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后是动作(注意这是一个代码块中的两个文件)</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="5a40" class="ln kc hu lj b fv lo lp l lq lr">// file: src/actions/index.js<br/>import * as actionType from './types';<br/><br/>export const setToken = (data) =&gt; {<br/>  return {<br/>    type: actionType.SET_TOKEN,<br/>    data<br/>  }<br/>}</span><span id="fbf5" class="ln kc hu lj b fv lv lp l lq lr">// file: src/actions/types.js<br/>export const SET_TOKEN = "SET_TOKEN";</span></pre><p id="2399" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们现在有了一个可以在登录后发送以存储用户令牌的操作。接下来让我们看看如何登录</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="f015" class="ln kc hu lj b fv lo lp l lq lr">// file: src/util/Auth.js<br/>import axios from 'axios';<br/>import _ from 'lodash';<br/>import store from '../store';<br/>import { setToken } from '../actions'<br/>import { URL, LOGIN } from '../config/Api';<br/><br/>export function InvalidCredentialsException(message) {<br/>    this.message = message;<br/>    this.name = 'InvalidCredentialsException';<br/>}<br/><br/>export function login(username, password) {<br/>  return axios<br/>    .post(URL + LOGIN, {<br/>      username,<br/>      password<br/>    })<br/>    .then(function (response) {<br/>      store.dispatch(setToken(response.data.token));<br/>    })<br/>    .catch(function (error) {<br/>      // raise different exception if due to invalid credentials<br/>      if (_.get(error, 'response.status') === 400) {<br/>        throw new InvalidCredentialsException(error);<br/>      }<br/>      throw error;<br/>    });<br/>}<br/><br/>export function loggedIn() {<br/>  return store.getState().token !== null;<br/>}</span></pre><p id="4967" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这段代码使用axios发送到我们的<code class="eh ls lt lu lj b">/auth</code>后端，然后将返回的令牌发送到我们的redux存储。一旦完成，我们现在就可以创建一个基于axios的API客户端，使用我们存储的令牌从React组件中的其他地方进行进一步的API调用。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="763f" class="ln kc hu lj b fv lo lp l lq lr">// file: src/util/ApiClient.js<br/>import axios from 'axios';<br/>import store from '../store';<br/>import { URL } from '../config/Api';<br/><br/>export const apiClient = function() {<br/>        const token = store.getState().token;<br/>        const params = {<br/>            baseURL: URL,<br/>            headers: {'Authorization': 'Token ' + token}<br/>        };<br/>        return axios.create(params);<br/>}</span></pre><p id="1494" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们在最后两个代码块中引用了文件<code class="eh ls lt lu lj b">../config/Api</code>。这个文件看起来是这样的——它只是一个将常量映射到端点的文件，使得代码可读性更好，以后也更容易修改。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="cc89" class="ln kc hu lj b fv lo lp l lq lr">export const URL = process.env.API_URL;<br/>export const LOGIN = "/auth";</span></pre><p id="337d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是连接我们前端和后端的全部内容。您现在可以尝试使用<code class="eh ls lt lu lj b">Auth.js</code>登录函数来获取我们之前创建的用户的auth令牌。如果是这样，可以查看浏览器的开发工具，检查redux-logger的输出，以查看setToken redux操作的结果。</p></div><div class="ab cl lw lx hc ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hn ho hp hq hr"><p id="0584" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我很想听听其他人对这种设置的反馈:我可以如何改进它，有什么需要改变或可以做得更好的，等等。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="md me l"/></div></figure></div></div>    
</body>
</html>