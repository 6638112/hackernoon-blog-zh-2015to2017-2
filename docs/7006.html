<html>
<head>
<title>Functors in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的函子</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/functors-in-javascript-20a647b8f39f?source=collection_archive---------2-----------------------#2017-10-13">https://medium.com/hackernoon/functors-in-javascript-20a647b8f39f?source=collection_archive---------2-----------------------#2017-10-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/fae85a175fff2e529b3923b920855609.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E7dBSGXMu8gPRXIuWYJrMg.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">where F is a Functor</figcaption></figure><blockquote class="jg jh ji"><p id="7620" class="jj jk jl jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">“数学家就像画家或诗人一样，是图案的制造者。如果他的模式比他们的更持久，那是因为他们是用思想创造的。”</p><p id="cbaa" class="jj jk jl jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">——g·h·哈代，<strong class="jm hv">一位数学家的道歉</strong></p></blockquote><p id="76ef" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">有时，在实际编程中，由于数据固有的复杂性，逻辑准确性是不可能的。数据抽象是一个非常有用的工具，它帮助我们创建数据的简化表示。</p><p id="a7a5" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">为了实现这一点，我们创建了“<strong class="jm hv">容器</strong>，这些容器只包含我们的数据，不做任何其他事情，我们不像在OOP中那样为它们提供属性或方法。</p><p id="829d" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">我们取一个值，并把它放在我们的容器中，容器将保护我们的值的安全，同时我们通过我们漂亮的函数逻辑传递它。只有当我们迫切需要时，我们才会取出那个值。这样，我们的容器将只有两个任务:</p><ul class=""><li id="a206" class="kl km hu jm b jn jo jr js ki kn kj ko kk kp kh kq kr ks kt dt translated"><em class="jl">保持自身内部的价值。</em></li><li id="3a81" class="kl km hu jm b jn ku jr kv ki kw kj kx kk ky kh kq kr ks kt dt translated"><em class="jl">只有在我们需要的时候才把价值还给我们</em>。</li></ul><p id="263e" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated"><em class="jl">此外，永远不要改变其中的值。</em></p><p id="c1a9" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">这些容器并不是什么新东西，自从我们开始使用Java脚本以来，我们就一直在使用它们，只有现在了解它们才能让我们成为更强大的程序员。</p><p id="ed50" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">当我们进行函数式编程时，这些容器非常强大，因为它们有助于我们函数构造的基础，并帮助我们使用常见的技术，如纯函数式错误处理和异步操作<em class="jl">(以及许多其他东西)</em>。</p><figure class="la lb lc ld fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kz"><img src="../Images/1688ae5e2a51a823a03971a7c16758b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*GbH6_EAvPrtQGc9fiVZpMA.gif"/></div></div></figure><p id="024e" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">在我们深入讨论这些容器之前，我们将讨论一种特殊类型的容器，称为<strong class="jm hv"> <em class="jl">函子。</em>T15】</strong></p><p id="d84a" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated"><strong class="jm hv"> <em class="jl">那么，什么是函子呢？</em> </strong> <strong class="jm hv"> <em class="jl">函子是可以与‘映射’函数一起使用的容器。</em> </strong></p><p id="4688" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">在我们创建自己的容器之前，让我们先来看看一些从小到大一直在使用的常见容器。</p><h1 id="06ee" class="le lf hu bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb dt translated">数组</h1><figure class="la lb lc ld fq iv fe ff paragraph-image"><div class="fe ff mc"><img src="../Images/5ce102fbc5e8f2e3bcb2d08116e4a998.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*1SZBEOSAtTXoy8TUqnOHjA.gif"/></div></figure><p id="87e4" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">数组是我们在日常编程中最常用的容器，它们不仅包含一个值，还包含多个值。它们是所有数据抽象中最简单的，但却如此强大。让我们和他们一起工作，</p><pre class="la lb lc ld fq md me mf mg aw mh dt"><span id="ecb5" class="mi lf hu me b fv mj mk l ml mm">const arr = [ 8, 10, 23, 35, 54 ];</span></pre><p id="9d7f" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">我们可以从这些数据中得到数值，比如</p><pre class="la lb lc ld fq md me mf mg aw mh dt"><span id="35c6" class="mi lf hu me b fv mj mk l ml mm">const b = a[1];</span></pre><p id="2cc9" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">现在，如果你保证只在数组上使用这些操作，我保证这些数组将永远是你的朋友。</p><p id="0fe0" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">永远不要修改原始数组，</p><pre class="la lb lc ld fq md me mf mg aw mh dt"><span id="9a50" class="mi lf hu me b fv mj mk l ml mm">arr.push(45) ❌</span><span id="31d8" class="mi lf hu me b fv mn mk l ml mm">or</span><span id="b65e" class="mi lf hu me b fv mn mk l ml mm">arr[1] = 45 ❌</span></pre><p id="8aca" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">但是你可以用它们来创造新的，</p><pre class="la lb lc ld fq md me mf mg aw mh dt"><span id="1c3a" class="mi lf hu me b fv mj mk l ml mm">const arr2 = [ ...arr, 38, 52 ]</span><span id="7b2c" class="mi lf hu me b fv mn mk l ml mm">or</span><span id="7952" class="mi lf hu me b fv mn mk l ml mm">const even = filter(x =&gt; x%2 === 0, arr)</span></pre><p id="44bf" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">我们从来没有在数组上应用任何可能改变数组中值的方法，我们只是创建数组或者取出值，仅此而已。</p><p id="1476" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">虽然Java的人会说这样做使我的数组变得毫无用处，但我会说，“不，我刚刚创建了一个强大得超乎你想象的数组”。</p><p id="21c5" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">是的，数组是一个函子。</p><p id="0f9e" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated"><strong class="jm hv">函子是一个容器，它可以被一元函数<em class="jl">映射</em>。</strong></p><p id="6dbb" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">当我说mapped upon时，我的意思是这个容器可以用一个特殊的函数(比如说<em class="jl"> fmap或map </em>)来处理，这个函数将任何一元函数应用于这个容器的每个内容，并返回一个包含结果值的容器作为它的内容。</p><figure class="la lb lc ld fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mo"><img src="../Images/51e0fc2e456563fa4a4a9c1da935e26d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GSDZ76ZSmgqCQPa-qlms_w.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">This truck is a functor</figcaption></figure><p id="9f0b" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">在数组的情况下，这个特殊函数被简单地称为<em class="jl">映射</em>函数。</p><h1 id="bde1" class="le lf hu bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb dt translated">地图功能</h1><figure class="la lb lc ld fq iv fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/5875eeac7ec6819177b9066ff786953d.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*IICPwSzmL6f1pNlhIoqVpg.gif"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Not this Map</figcaption></figure><p id="7060" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">Map function in arrays接受一个数组，并对其所有元素逐一应用特定的函数，然后返回另一个数组。</p><pre class="la lb lc ld fq md me mf mg aw mh dt"><span id="be24" class="mi lf hu me b fv mj mk l ml mm">[1,2,3,4].map(multiplyBy2) <br/><em class="jl">//=&gt; [2,4,6,8]</em></span><span id="b296" class="mi lf hu me b fv mn mk l ml mm">or</span><span id="ea52" class="mi lf hu me b fv mn mk l ml mm"><strong class="me hv">map(multiplyBy2, [1,2,3,4]) <br/><em class="jl">//=&gt; [2,4,6,8]</em></strong></span><span id="25d5" class="mi lf hu me b fv mn mk l ml mm"><em class="jl">where multiplyBy2 = x =&gt; x * 2 and map = (fn, arr) =&gt; arr.map(fn)</em></span></pre><p id="eea2" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">因为，我们总是从映射中得到另一个数组，我们总是可以再次映射它来创建一个数组转换链。</p><pre class="la lb lc ld fq md me mf mg aw mh dt"><span id="9dec" class="mi lf hu me b fv mj mk l ml mm">[1,2,3].<strong class="me hv">map</strong>(x =&gt; x * 3).<strong class="me hv">map</strong>(x =&gt; x * 2).<strong class="me hv">map</strong>(x =&gt; x / 6)</span></pre><p id="9aa0" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">Map函数不仅仅是一个迭代器函数，<em class="jl">记住</em>，当我们的值在一个容器中时，我们不能直接对它应用一个函数，然后期望值被改变。举个例子，</p><pre class="la lb lc ld fq md me mf mg aw mh dt"><span id="cb4f" class="mi lf hu me b fv mj mk l ml mm">const a = [1, 2, 3]</span><span id="1eb2" class="mi lf hu me b fv mn mk l ml mm">String(a) = ‘[1 ,2, 3]’ and not [‘1’, ‘2’, ‘3’]</span></pre><p id="43d8" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated"><strong class="jm hv"> <em class="jl">一个map函数给一个函数访问容器的内容。</em> </strong></p><pre class="la lb lc ld fq md me mf mg aw mh dt"><span id="ac86" class="mi lf hu me b fv mj mk l ml mm">map(String, [1, 2, 3]) = [‘1’, ‘2’, ‘3’]</span></pre><p id="6e40" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">此外，映射函数从不改变容器，相反，它只是对其内容进行操作。保持容器不动。</p><figure class="la lb lc ld fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mq"><img src="../Images/1e2627cac815af889623aabc75c34f88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YyqMH3irZ_cvfBi2TjKWNQ.png"/></div></div></figure><p id="e658" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">地图不会改变容器的类型，但是它可以改变里面的东西的类型。 </p><p id="b3c1" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">内容的类型可能会改变，我们可以从map函数的类型定义中看出这一点。</p><pre class="la lb lc ld fq md me mf mg aw mh dt"><span id="2680" class="mi lf hu me b fv mj mk l ml mm">map :: (a -&gt; b) -&gt; [a] -&gt; [b]</span><span id="2e07" class="mi lf hu me b fv mn mk l ml mm">or</span><span id="6669" class="mi lf hu me b fv mn mk l ml mm">fmap :: (a -&gt; b) -&gt; F a -&gt; F b </span></pre><p id="72c7" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">这里，<code class="eh mr ms mt me b">a</code>和<code class="eh mr ms mt me b">b</code>可以是相同的类型，也可以是不同的类型。</p><p id="6102" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">现在，如果你仔细看，你会看到地图函数从<code class="eh mr ms mt me b">a -&gt; b</code>获取一个函数，并从<code class="eh mr ms mt me b">Fa -&gt; Fb</code>返回一个函数</p><p id="e09f" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">这里，<code class="eh mr ms mt me b">a -&gt; b</code>指的是任何一个接受<code class="eh mr ms mt me b">a</code>并返回<code class="eh mr ms mt me b">b</code>的一元函数，比如</p><pre class="la lb lc ld fq md me mf mg aw mh dt"><span id="78ba" class="mi lf hu me b fv mj mk l ml mm">multiplyBy2(3) = 6 // is a -&gt; b as 3 -&gt; 6</span></pre><p id="fd2e" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">而<code class="eh mr ms mt me b">Fa -&gt; Fb</code>表示任何一元函数，它接受一个内部带有<code class="eh mr ms mt me b">a</code>的容器，并返回一个内部带有<code class="eh mr ms mt me b">b</code>的容器。</p><pre class="la lb lc ld fq md me mf mg aw mh dt"><span id="5e3e" class="mi lf hu me b fv mj mk l ml mm">multiplyArrBy2([1]) = [2] // is Fa -&gt; Fb as [1] -&gt; [2], F is []</span></pre><p id="d907" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">要了解我们如何使用这些类型，请阅读此处，</p><div class="mu mv fm fo mw mx"><a href="https://hackernoon.com/function-type-signatures-in-javascript-5c698c1e9801" rel="noopener  ugc nofollow" target="_blank"><div class="my ab ej"><div class="mz ab na cl cj nb"><h2 class="bd hv fv z el nc eo ep nd er et ht dt translated">Javascript中的函数类型签名</h2><div class="ne l"><h3 class="bd b fv z el nc eo ep nd er et ek translated">当一个Javascript开发人员开始探索函数式编程的深层秘密时，他经常会发现这些…</h3></div><div class="nf l"><p class="bd b gc z el nc eo ep nd er et ek translated">hackernoon.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl ja mx"/></div></div></a></div><p id="00a8" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">现在我们的地图功能将从<code class="eh mr ms mt me b">multiplyBy2</code>变为<code class="eh mr ms mt me b">multiplyArrBy2</code>让我们看看这个，</p><figure class="la lb lc ld fq iv"><div class="bz el l di"><div class="nm nn l"/></div></figure><p id="d370" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">现在我们的函数<code class="eh mr ms mt me b">multiplyBy2</code>过去作用于整数，现在因为<code class="eh mr ms mt me b">map</code>将作用于整数数组。在某种程度上，我们的map函数提升了或者说<strong class="jm hv"> <em class="jl">提升了</em> </strong>我们的函数，这样它就可以在这种情况下作用于我们的容器或数组。</p><p id="b483" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">我们偶尔会提升我们的函数，这样它们就可以作用于我们容器中的数据。<em class="jl">(因为正常功能不能)</em></p><p id="b00f" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">我们尽可能使用部分应用的地图功能，因为这样我们就可以用它来创建另一个功能，或者我们可以将它与<em class="jl">合成</em>功能一起使用，当数据非常紧急时，我们将使用我们正常的地图功能。</p><p id="039b" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">为什么要使用部分应用的函数？</p><div class="mu mv fm fo mw mx"><a href="https://hackernoon.com/partial-application-of-functions-dbe7d9b80760" rel="noopener  ugc nofollow" target="_blank"><div class="my ab ej"><div class="mz ab na cl cj nb"><h2 class="bd hv fv z el nc eo ep nd er et ht dt translated">函数的部分应用</h2><div class="ne l"><h3 class="bd b fv z el nc eo ep nd er et ek translated">为函数提供比预期更少的参数称为函数的部分应用。</h3></div><div class="nf l"><p class="bd b gc z el nc eo ep nd er et ek translated">hackernoon.com</p></div></div><div class="ng l"><div class="no l ni nj nk ng nl ja mx"/></div></div></a></div><p id="ba81" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated"><strong class="jm hv"> <em class="jl">在更进一步之前，</em> </strong>我们知道，我们用容器来保存我们的价值观，它们唯一的目的就是保存它们。我们还知道<strong class="jm hv"> <em class="jl">函子</em> </strong>是特殊的容器，我们可以在上面进行<strong class="jm hv"> <em class="jl">映射</em> </strong>操作。我们知道如何在数组上使用映射函数，我们也见过我们的第一个容器和一个函子，数组，我们在日常编程中经常使用。</p><p id="ce08" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">现在，让我们来看看第二个容器，它也是一个函子。这个容器从我们的功能冒险开始就一直伴随着我们。</p><h1 id="d95c" class="le lf hu bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb dt translated">功能</h1><blockquote class="np"><p id="3dbe" class="nq nr hu bd ns nt nu nv nw nx ny kh ek translated">所有的函数也是函子，因此也是容器。T19】</p></blockquote><p id="cdb8" class="pw-post-body-paragraph jj jk hu jm b jn oa jp jq jr ob jt ju ki oc jx jy kj od kb kc kk oe kf kg kh hn dt translated"><strong class="jm hv">容器的功能是什么？</strong></p><p id="f26b" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">好吧，容器包含数据，但是我们的函数明明包含逻辑，函数怎么可能是容器。</p><p id="d3bd" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">如果你仔细想想:一个函数在被调用时，会返回一个值。所以在某种程度上，它包含了我们的值，唯一的区别是这个值是动态计算的。</p><pre class="la lb lc ld fq md me mf mg aw mh dt"><span id="5169" class="mi lf hu me b fv mj mk l ml mm">aFunction(45) // =&gt; 90</span><span id="eec3" class="mi lf hu me b fv mn mk l ml mm">So aFunction gives the value 90, when it is passed 45</span></pre><p id="3206" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">把它们想象成无限数量的值的数组，如果你想从这些数组中得到一个特定的值，你需要用一个或多个特定的参数来调用函数。</p><figure class="la lb lc ld fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/535bc50aeebc8e662dbfede59f506952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*33Xq701x2Jyirz6xxE0eBQ.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Functions are arrays with Infinite Values</figcaption></figure><p id="445a" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated"><strong class="jm hv">那么，函数是像数组一样的容器？</strong></p><p id="4cfc" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">是的，就像数组在传递索引时给出值一样，函数在传递参数时给出结果。</p><pre class="la lb lc ld fq md me mf mg aw mh dt"><span id="3ac7" class="mi lf hu me b fv mj mk l ml mm">const a = [ 8, 10, 23, 35, 54 ]</span><span id="5ed0" class="mi lf hu me b fv mn mk l ml mm">const f = z =&gt; z * 2 </span><span id="029a" class="mi lf hu me b fv mn mk l ml mm">a[1] = 10<br/>f(2) = 4</span></pre><p id="4a6a" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">只有我们的数组比较弱，因为它们只给出范围整数的结果作为索引，但是我们的函数可以接受任何类型的参数，因为对它们没有限制，它们也可以接受其他函数作为参数。</p><p id="5d8d" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated"><em class="jl">函数是有无限个值的容器。</em></p><p id="b4c4" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">因为它们是函子，所以它们也有一个映射？</p><p id="bc0e" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">是的，它是这样定义的</p><pre class="la lb lc ld fq md me mf mg aw mh dt"><span id="1013" class="mi lf hu me b fv mj mk l ml mm">const fnMap = (f, mappingFn) =&gt; (x =&gt; f(mappingFn(x)))</span></pre><p id="b133" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">就像<em class="jl"> map </em>函数获取数组，将函数应用于内容并返回数组。类似地，<em class="jl"> fnMap </em>接受一个函数，将另一个函数应用于它的结果并返回该函数，在某种程度上它组合了两个函数<strong class="jm hv"> s <em class="jl"> uch，一个函数的结果是第二个函数的参数。</em> </strong></p><p id="75b2" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">嗯，好吧，让我们用这个</p><pre class="la lb lc ld fq md me mf mg aw mh dt"><span id="adda" class="mi lf hu me b fv mj mk l ml mm">const multiplyBy6 = fnMap(multiplyBy2, multiplyBy3)</span></pre><p id="5f9e" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">这看起来很熟悉，我们以前见过。</p><blockquote class="jg jh ji"><p id="3634" class="jj jk jl jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated"><strong class="jm hv">是我们的<em class="hu">作曲</em>功能。</strong></p></blockquote><figure class="la lb lc ld fq iv fe ff paragraph-image"><div class="fe ff of"><img src="../Images/25f7e1350d4752a98ee940cd1a40ee2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/1*8PrkCmEbL7aer0lmmIRpBw.gif"/></div></figure><p id="1809" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">因此，我们的函数也有一个<em class="jl">映射</em>函数，如果我们将一个函数映射到另一个函数，我们就在某种程度上融合了这两个函数。映射函数称为<em class="jl">合成</em>函数。</p><h2 id="f202" class="mi lf hu bd lg og oh oi lk oj ok ol lo ki om on ls kj oo op lw kk oq or ma os dt translated"><strong class="ak">TL；博士</strong></h2><ul class=""><li id="f2a8" class="kl km hu jm b jn ot jr ou ki ov kj ow kk ox kh kq kr ks kt dt translated">假设我们有一个函数<code class="eh mr ms mt me b">multiplyBy2</code>。</li><li id="d462" class="kl km hu jm b jn ku jr kv ki kw kj kx kk ky kh kq kr ks kt dt translated">在从中取出值或者调用它之前，我们用<code class="eh mr ms mt me b">multiplyBy3</code>映射它。</li><li id="f673" class="kl km hu jm b jn ku jr kv ki kw kj kx kk ky kh kq kr ks kt dt translated">所以<code class="eh mr ms mt me b">multiplyBy2</code>里面的所有值都乘以3。</li><li id="f397" class="kl km hu jm b jn ku jr kv ki kw kj kx kk ky kh kq kr ks kt dt translated">现在，每当我们调用<code class="eh mr ms mt me b">multiplyBy2</code>比如说<code class="eh mr ms mt me b">x</code>，我们得到的值将是<code class="eh mr ms mt me b">x * 3 * 2</code>。</li></ul><p id="bbb7" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">也许，现在这一点会更清楚，</p><pre class="la lb lc ld fq md me mf mg aw mh dt"><span id="7e46" class="mi lf hu me b fv mj mk l ml mm">const fnMap = (f, mappingFn) =&gt; (x =&gt; f(mappingFn(x)))</span></pre></div><div class="ab cl oy oz hc pa" role="separator"><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd"/></div><div class="hn ho hp hq hr"><p id="0d01" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">函数就像数组，是一种数据抽象。只有函数根据我们的要求计算数据。</p><p id="9044" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">或者我们可以说数组就像函数，当我们对它们使用'[]'时，它们会立即给出结果。</p><p id="dc9a" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">我们可以用任何方式弯曲我们的思想来理解这一点，这都是真的。</p><p id="d52e" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">我们只需要记住一件事，我们的值只有在容器中才有价值，无论是函数，数组还是我们创建的容器，只有这样，我们才能将代码中复杂的结构，可能是由于数据的复杂性而产生的，分解成简单的结构。</p><p id="4c7b" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">从现在开始，我需要你记住这个东西，在函数式编程<strong class="jm hv"> <em class="jl">中永远不要赤裸裸地使用你的数据</em> </strong>。总是把它包在容器里。</p><p id="f5ea" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">现在，这篇文章太长了，无法讨论更多关于函子的内容。但我保证，我们会在另一部里继续。</p><figure class="la lb lc ld fq iv fe ff paragraph-image"><div class="fe ff pf"><img src="../Images/bea411cda74aa4c91b01c802f76d21e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/1*TiWApZN1GVKNTdz3X0Q3ww.gif"/></div></figure><p id="729f" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju ki jw jx jy kj ka kb kc kk ke kf kg kh hn dt translated">用...书写💖。</p></div></div>    
</body>
</html>