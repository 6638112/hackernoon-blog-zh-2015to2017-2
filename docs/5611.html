<html>
<head>
<title>Logical replication with PostgreSQL 10</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PostgreSQL 10进行逻辑复制</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/postgresql-logical-replication-86df5b51cc5a?source=collection_archive---------1-----------------------#2017-08-06">https://medium.com/hackernoon/postgresql-logical-replication-86df5b51cc5a?source=collection_archive---------1-----------------------#2017-08-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="8743" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">有简单例子的入门书</h2></div><p id="7e76" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在PostgreSQL 10(即将推出测试版)中，我们看到了逻辑<a class="ae kf" href="https://hackernoon.com/tagged/replication" rel="noopener ugc nofollow" target="_blank">复制</a>的引入，这是一个长期以来备受追捧的特性。</p><h2 id="8e50" class="kg kh hu bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la dt translated">为什么是逻辑复制？</h2><p id="5b1b" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated">目前，在9.x中，我们有内置的流式复制功能，可处理物理WAL数据。</p><blockquote class="lg lh li"><p id="ee6a" class="jj jk lj jl b jm jn iv jo jp jq iy jr lk jt ju jv ll jx jy jz lm kb kc kd ke hn dt translated"><em class="hu">物理复制是指在数据块级别而不是行级别进行复制。</em></p></blockquote><p id="82f6" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">换句话说，流复制将原始数据块级别的更改复制到其备用服务器，但很少了解这些数据块实际上对数据库做了什么<em class="lj"/><em class="lj"/>。</p><p id="fa62" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，随着<a class="ae kf" href="https://www.postgresql.org/docs/10/static/logical-replication.html" rel="noopener ugc nofollow" target="_blank">逻辑复制</a>的出现，这种情况发生了变化，在T9中，数据在一个逻辑级别上复制。这意味着流复制现在实际上了解这些块在数据库行为方面做了什么。</p><figure class="lo lp lq lr fq ls fe ff paragraph-image"><div class="fe ff ln"><img src="../Images/1ffbb3ebfe3d6c8d28cfacc835aa3484.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*QDl7TRra1oKAVwoBRvHkQA.png"/></div></figure><p id="5c73" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，我们可以决定要复制哪些表，并且我们还可以在备用服务器上写入数据，而不是使用需要精确的二进制副本的备用服务器。这些事情在以前是不可能的，除非使用第三方复制软件(各有利弊)。</p><p id="4152" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个特性源自于<a class="ae kf" href="https://www.2ndquadrant.com/" rel="noopener ugc nofollow" target="_blank"> 2ndQuadrant </a>的天才开发人员和他们在<a class="ae kf" href="https://www.2ndquadrant.com/en/resources/pglogical/" rel="noopener ugc nofollow" target="_blank"> pglogical </a>上的惊人工作。虽然pglogical的所有特性并没有在PostgreSQL 10中实现，但我们现在已经正式支持PostgreSQL中的逻辑复制，这是一个巨大的进步。</p><h2 id="5823" class="kg kh hu bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la dt translated">体系结构</h2><p id="e5b0" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated">逻辑复制基于发布和订阅。这是一种常见的方法，其他流行的RDBMS(如Oracle和Microsoft SQL)也使用这种方法。</p><figure class="lo lp lq lr fq ls fe ff paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="fe ff lv"><img src="../Images/dec46fe726e0e2c7a2b63ac296f5de0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0vO0cm-OW5UN7fW3ZyVu7A.png"/></div></div><figcaption class="ma mb fg fe ff mc md bd b be z ek">Pub / Sub Architecture of Logical Replication. A publication may be limited to just a few tables or all tables. One can achieve per-table sharding this way with multiple standby servers.</figcaption></figure><h2 id="a7f2" class="kg kh hu bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la dt translated">基本示例</h2><p id="9211" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated">在本例中，我们将在localhost上设置两个PostgreSQL 10集群。一个运行在端口<strong class="jl hv"> 5432 </strong>(主)上，另一个运行在端口<strong class="jl hv"> 5433 </strong>(备用)上。postgresql.conf唯一的修改是<em class="lj"> wal_level=logical。</em>在两个集群上执行此操作。</p><p id="8e08" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">假设这些集群现在都在运行，我们创建一些表，希望从主服务器复制到备用服务器。</p><p id="b4ed" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们先在母版上这样做:</p><pre class="lo lp lq lr fq me mf mg mh aw mi dt"><span id="5b16" class="kg kh hu mf b fv mj mk l ml mm">master=# create table foo (foo text PRIMARY KEY, quux text); <br/>         create table bar (bar text PRIMARY KEY, quux text);<br/><strong class="mf hv">CREATE TABLE<br/>CREATE TABLE</strong></span></pre><p id="51d5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在让我们为这两个表创建一个出版物(同样在母版上)。我们还需要一个拥有复制权限的用户，我们称之为<em class="lj">备用用户</em>。</p><pre class="lo lp lq lr fq me mf mg mh aw mi dt"><span id="1266" class="kg kh hu mf b fv mj mk l ml mm">master=# create publication my_pub for table foo, bar;<br/><strong class="mf hv">CREATE PUBLICATION</strong></span><span id="d556" class="kg kh hu mf b fv mn mk l ml mm">master=# create role standby_user with login password '12345' <br/>         replication; <br/><strong class="mf hv">CREATE ROLE</strong></span></pre><p id="c420" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在我们做任何事情之前，让我们在母版上添加几行。</p><pre class="lo lp lq lr fq me mf mg mh aw mi dt"><span id="36a1" class="kg kh hu mf b fv mj mk l ml mm">master=# insert into foo (foo, quux) values ('hi', 'there');<br/><strong class="mf hv">INSERT 1</strong><br/>master=# insert into bar (bar, quux) values ('and', 'here');<br/><strong class="mf hv">INSERT 1</strong></span></pre><p id="0c33" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在备用服务器上，我们现在设置订阅。</p><pre class="lo lp lq lr fq me mf mg mh aw mi dt"><span id="e9f8" class="kg kh hu mf b fv mj mk l ml mm">standby=# create subscription my_sub <br/>        connection 'host=localhost dbname=my_db <br/>                    user=standby_user password=12345 port=5432' <br/>        publication my_pub;<br/><strong class="mf hv">CREATE SUBSCRIPTION</strong></span></pre><p id="af0b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">激活订阅后，我们将在备用服务器的日志中看到以下内容:</p><pre class="lo lp lq lr fq me mf mg mh aw mi dt"><span id="f5a1" class="kg kh hu mf b fv mj mk l ml mm">LOG:  logical replication apply worker for subscription "my_sub" has started<br/>LOG:  logical replication table synchronization worker for subscription "my_sub", table "foo" has started<br/>...</span></pre><p id="6be2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在主服务器上，我们将看到复制槽已经自动创建，并且正在进行初始同步。在备用数据库中，我们将看到两个表现在各包含一行。</p><p id="b99d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">请注意，逻辑复制仍然利用您在旧的流复制中使用的复制插槽，因此应该使用<em class="lj"> pg_replication_slots表</em>进行监控。</p><h2 id="f186" class="kg kh hu bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la dt translated">结论</h2><p id="3737" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated">我们已经看到，逻辑复制很容易设置，只要有一种方法可以通过TCP从备用服务器直接连接到主服务器。</p><p id="df2e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于通过互联网复制的生产系统，一定要在Postgres中使用<strong class="jl hv"> ssl=on </strong>。不仅仅是因为安全原因，还因为当使用SSL模式时，默认情况下会启用压缩。</p><p id="8b1f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">与任何功能一样，深入研究官方文档以确定可能与您的需求相关的限制和潜在问题非常重要。参见:</p><div class="mo mp fm fo mq mr"><a href="https://www.postgresql.org/docs/10/static/logical-replication.html" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab ej"><div class="mt ab mu cl cj mv"><h2 class="bd hv fv z el mw eo ep mx er et ht dt translated">PostgreSQL:文档:10:第31章。逻辑复制</h2><div class="my l"><h3 class="bd b fv z el mw eo ep mx er et ek translated">表的逻辑复制通常从拍摄发布者数据库上的数据快照开始，然后…</h3></div><div class="mz l"><p class="bd b gc z el mw eo ep mx er et ek translated">www.postgresql.org</p></div></div><div class="na l"><div class="nb l nc nd ne na nf lt mr"/></div></div></a></div><figure class="lo lp lq lr fq ls"><div class="bz el l di"><div class="ng nh l"/></div></figure></div></div>    
</body>
</html>