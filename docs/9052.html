<html>
<head>
<title>One vs. many — Why we moved from multiple git repos to a monorepo and how we set it up</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一对多——为什么我们从多个git回购转移到一个monorepo，以及我们如何设置它</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/one-vs-many-why-we-moved-from-multiple-git-repos-to-a-monorepo-and-how-we-set-it-up-f4abb0cfe469?source=collection_archive---------2-----------------------#2017-12-24">https://medium.com/hackernoon/one-vs-many-why-we-moved-from-multiple-git-repos-to-a-monorepo-and-how-we-set-it-up-f4abb0cfe469?source=collection_archive---------2-----------------------#2017-12-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="78c1" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">管理源代码如何变得透明</h2></div><p id="b3a3" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">访问</strong><a class="ae kf" href="https://www.mikenikles.com" rel="noopener ugc nofollow" target="_blank"><strong class="jl hv">【https://www.mikenikles.com】</strong></a><strong class="jl hv">获取我的最新博文。</strong></p><p id="bb5f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kg">这篇博文是我分享我们从部署在AWS上的单片应用程序(每个都有自己的源代码库)迁移到部署在Google云平台上的分布式服务架构(所有源代码都托管在monorepo中)的系列文章的一部分。</em></p><ul class=""><li id="825f" class="kh ki hu jl b jm jn jp jq js kj jw kk ka kl ke km kn ko kp dt translated"><em class="kg">第一部分:</em> <a class="ae kf" href="https://hackernoon.com/a-monorepo-github-flow-and-automation-ftw-c41a2d9c48bb" rel="noopener ugc nofollow" target="_blank"> <em class="kg">一个monorepo，GitHub流和自动化FTW</em></a><em class="kg"/></li><li id="c092" class="kh ki hu jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp dt translated"><em class="kg">第2部分(本文):“一对多——为什么我们从多个git回购转移到一个monorepo，以及我们如何设置它”</em></li><li id="8df2" class="kh ki hu jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp dt translated"><em class="kg">第三部分:</em><a class="ae kf" rel="noopener" href="/@mikenikles/a-mostly-automated-release-process-63bb9516985a"><em class="kg"/></a><em class="kg"/></li><li id="91bd" class="kh ki hu jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp dt translated"><em class="kg">第四部分:</em> <a class="ae kf" rel="noopener" href="/@mikenikles/our-approach-to-software-development-consistency-d101995bb843">我们对软件开发一致性的方法</a><em class="kg"/></li><li id="8fc7" class="kh ki hu jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp dt translated"><em class="kg">第5部分(即将推出):“本地调试微服务”</em></li></ul><h1 id="fcb4" class="kv kw hu bd kx ky kz la lb lc ld le lf ja lg jb lh jd li je lj jg lk jh ll lm dt translated">多个存储库意味着多种一切</h1><p id="0ba2" class="pw-post-body-paragraph jj jk hu jl b jm ln iv jo jp lo iy jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">让我们列出一些我们需要用存储库来管理的东西:</p><ul class=""><li id="3a59" class="kh ki hu jl b jm jn jp jq js kj jw kk ka kl ke km kn ko kp dt translated">属国</li><li id="0e95" class="kh ki hu jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp dt translated">测试配置</li><li id="2011" class="kh ki hu jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp dt translated">拉式请求模板</li><li id="3c93" class="kh ki hu jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp dt translated">拉式请求/标签</li><li id="f04b" class="kh ki hu jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp dt translated">埃斯林特</li><li id="5dcb" class="kh ki hu jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp dt translated">较美丽</li><li id="02a6" class="kh ki hu jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp dt translated">部署和发布脚本</li></ul><p id="16bf" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于某些事情，比如管理依赖性，像<a class="ae kf" href="https://greenkeeper.io/" rel="noopener ugc nofollow" target="_blank"> Greenkeeper </a>这样的服务可能会有所帮助。然而，如果一个依赖项发布了一个新的主要版本，您必须手动地将它应用到所有的存储库并运行测试。</p><p id="3f7e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">很明显，我们都不喜欢这些维护任务，我们宁愿花时间让我们的市场研究聊天机器人对我们的客户更有价值。</p><h1 id="85fd" class="kv kw hu bd kx ky kz la lb lc ld le lf ja lg jb lh jd li je lj jg lk jh ll lm dt translated">属国</h1><h2 id="7774" class="ls kw hu bd kx lt lu lv lb lw lx ly lf js lz ma lh jw mb mc lj ka md me ll mf dt translated">莱尔纳</h2><p id="a7f1" class="pw-post-body-paragraph jj jk hu jl b jm ln iv jo jp lo iy jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">我们的代码主要是用Javascript写的，这就带我们来看看<a class="ae kf" href="https://lerna.js.org/" rel="noopener ugc nofollow" target="_blank"> Lerna </a>。</p><blockquote class="mg mh mi"><p id="1cfe" class="jj jk kg jl b jm jn iv jo jp jq iy jr mj jt ju jv mk jx jy jz ml kb kc kd ke hn dt translated">Lerna是一个用多个包管理JavaScript项目的工具。</p></blockquote><p id="a70f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们决定更进一步。我们不仅管理我们的npm包，还将Lerna配置为管理我们的服务，这些服务位于同一个monorepo中。</p><p id="c05a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们的monorepo目录结构如下:</p><pre class="mm mn mo mp fq mq mr ms mt aw mu dt"><span id="2f3c" class="ls kw hu mr b fv mv mw l mx my">.<br/>├── lerna.json<br/>├── package.json<br/>├── packages<br/>└── services</span></pre><p id="1851" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh mz na nb mr b">lerna.json</code>文件非常简单:</p><pre class="mm mn mo mp fq mq mr ms mt aw mu dt"><span id="0c23" class="ls kw hu mr b fv mv mw l mx my">{<br/>  "lerna": "2.4.0",<br/>  "npmClient": "yarn",<br/>  "useWorkspaces": true, // See "Yarn Workspaces" below<br/>  "packages": ["packages/*", "services/*"],<br/>  "version": "independent"<br/>}</span></pre><p id="cb9b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通过这种配置，我们的服务可以依赖于包，Lerna负责对它们进行符号链接。例如，我们可以在<code class="eh mz na nb mr b">services/service-a</code>目录下运行<code class="eh mz na nb mr b">yarn add package-z</code>，并正确地学习符号链接<code class="eh mz na nb mr b">package-z</code>。不再与<code class="eh mz na nb mr b">yarn link</code>打交道。</p><h2 id="b5ca" class="ls kw hu bd kx lt lu lv lb lw lx ly lf js lz ma lh jw mb mc lj ka md me ll mf dt translated">NPM范围的包</h2><p id="5c3c" class="pw-post-body-paragraph jj jk hu jl b jm ln iv jo jp lo iy jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">对勒纳来说，<code class="eh mz na nb mr b">packages/*</code>和<code class="eh mz na nb mr b">services/*</code>被认为是包。大多数lerna命令支持<code class="eh mz na nb mr b">--scope</code> <a class="ae kf" href="https://github.com/lerna/lerna#--scope-glob" rel="noopener ugc nofollow" target="_blank">标志</a>，但只有在<code class="eh mz na nb mr b">package.json</code>文件中遵循严格的<code class="eh mz na nb mr b">name</code>属性命名约定时，这种情况才会发生。</p><p id="e15b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们决定通过使用不同的<a class="ae kf" href="https://docs.npmjs.com/misc/scope" rel="noopener ugc nofollow" target="_blank">范围的包</a>将包和服务分开。由于<code class="eh mz na nb mr b">packages/*</code>被部署到NPM，他们使用公司默认范围(例如<code class="eh mz na nb mr b">@my-company</code>)。<code class="eh mz na nb mr b">services/*</code>中的服务使用<code class="eh mz na nb mr b">@my-company-services</code>范围。包和服务进一步以<code class="eh mz na nb mr b">web-*</code> vs <code class="eh mz na nb mr b">svr-*</code>为前缀，以区分不同类型的包和服务。</p><h2 id="0198" class="ls kw hu bd kx lt lu lv lb lw lx ly lf js lz ma lh jw mb mc lj ka md me ll mf dt translated">纱线工作空间</h2><p id="62c1" class="pw-post-body-paragraph jj jk hu jl b jm ln iv jo jp lo iy jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">Lerna非常擅长管理相互依赖关系，运行npm脚本，甚至跨所有包或其子集运行任意命令。</p><p id="a500" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是，默认情况下，每个包和服务都有自己的<code class="eh mz na nb mr b">node_modules</code>文件夹。这是一个很大的重复…</p><p id="a6e5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">给我们Yarn的好心人发布了“工作空间”,并友好地在博客上介绍了如何与Lerna一起使用它:<a class="ae kf" href="https://yarnpkg.com/blog/2017/08/02/introducing-workspaces/" rel="noopener ugc nofollow" target="_blank">https://yarnpkg.com/blog/2017/08/02/introducing-workspaces/</a></p><p id="09af" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">除了<code class="eh mz na nb mr b">lerna.json</code>中的<code class="eh mz na nb mr b">"useWorkspaces": true</code>之外，您还必须将<code class="eh mz na nb mr b">"workspaces": ["packages/*", "services/*"]</code>添加到您的根<code class="eh mz na nb mr b">package.json</code>文件中。就是这样。</p><p id="a8a2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在当你运行<code class="eh mz na nb mr b">yarn</code>和<code class="eh mz na nb mr b">lerna bootstrap</code>时，你的根<code class="eh mz na nb mr b">node_modules</code>文件夹包含了几乎所有你需要的npm包。这既节省了时间又节省了磁盘空间。下面展示了不使用Yarn工作空间和在我们的monorepo中使用它之间的区别。这些统计数据是基于Lerna管理的20个包，在2016年的MacBook Pro上运行。</p><p id="2ffe" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">无纱线工作区</strong></p><pre class="mm mn mo mp fq mq mr ms mt aw mu dt"><span id="b7a1" class="ls kw hu mr b fv mv mw l mx my">+-----------------+--------+<br/>|     Command     |  Time  |<br/>+-----------------+--------+<br/>| yarn install    | 13.23s |<br/>| lerna bootstrap | 72.33s |<br/>+-----------------+--------+</span></pre><p id="4e08" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这将向磁盘添加96，112个文件，总容量为666.4mb。</p><p id="c980" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">带纱线工作区</strong></p><pre class="mm mn mo mp fq mq mr ms mt aw mu dt"><span id="6d47" class="ls kw hu mr b fv mv mw l mx my">+-----------------+--------+<br/>|     Command     |  Time  |<br/>+-----------------+--------+<br/>| yarn install    | 17.26s |<br/>| lerna bootstrap | 3.85s  |<br/>+-----------------+--------+</span></pre><p id="34e9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这将向磁盘添加32，008个文件，总容量为267.1mb。</p><h2 id="16de" class="ls kw hu bd kx lt lu lv lb lw lx ly lf js lz ma lh jw mb mc lj ka md me ll mf dt translated">结论</h2><p id="d9a4" class="pw-post-body-paragraph jj jk hu jl b jm ln iv jo jp lo iy jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">多等4秒钟来安装根包是值得的。通过在持续集成服务器上进行一点缓存，事情看起来会更好，但是我想得太多了。</p><h1 id="88ac" class="kv kw hu bd kx ky kz la lb lc ld le lf ja lg jb lh jd li je lj jg lk jh ll lm dt translated">测试配置</h1><p id="6ea4" class="pw-post-body-paragraph jj jk hu jl b jm ln iv jo jp lo iy jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">我们使用<a class="ae kf" href="http://facebook.github.io/jest/" rel="noopener ugc nofollow" target="_blank"> Jest </a>，但是决定让Lerna管理测试运行程序实例。(仅供参考，Jest附带了一个<a class="ae kf" href="https://facebook.github.io/jest/blog/2017/05/06/jest-20-delightful-testing-multi-project-runner.html" rel="noopener ugc nofollow" target="_blank">多项目运行器</a>，可能对您的用例有用。)</p><p id="323e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在我们的例子中，我们喜欢Lerna提供的<code class="eh mz na nb mr b">--scope</code>标志，以便只在某些目录中运行命令。<br/>更重要的是，我们有各种各样的包和服务，有些可以在Node.js中使用，有些可以在浏览器中使用，有些是同构的。</p><p id="aecf" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了适应这种情况，我们有以下Jest配置设置:</p><pre class="mm mn mo mp fq mq mr ms mt aw mu dt"><span id="4c89" class="ls kw hu mr b fv mv mw l mx my">.<br/>├── jest.config.js<br/>├── packages<br/>│   ├── iso-package<br/>│   │   ├── jest.config.js<br/>│   ├── svr-package<br/>│   │   └── jest.config.js<br/>│   └── web-package<br/>│       └── jest.config.js<br/>├── services<br/>│   ├── svr-service<br/>│   │   └── jest.config.js<br/>│   ├── web-service<br/>│       └── jest.config.js<br/>└── tests-setup<br/>    ├── polyfill.js<br/>    └── setup.js</span></pre><p id="f323" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">根级<code class="eh mz na nb mr b">jest.config.js</code>包含我们应用于所有包和服务的基本Jest配置。它看起来像这样:</p><pre class="mm mn mo mp fq mq mr ms mt aw mu dt"><span id="68d4" class="ls kw hu mr b fv mv mw l mx my">// jest.config.js<br/>module.exports = {<br/>  collectCoverageFrom: ['**/*.js'],<br/>  resetMocks: true,<br/>  verbose: true<br/>}</span></pre><h2 id="cd9c" class="ls kw hu bd kx lt lu lv lb lw lx ly lf js lz ma lh jw mb mc lj ka md me ll mf dt translated">Web包和服务</h2><p id="fe05" class="pw-post-body-paragraph jj jk hu jl b jm ln iv jo jp lo iy jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">一个<code class="eh mz na nb mr b">web-*</code>包或服务在其根目录中使用下面的<code class="eh mz na nb mr b">jest.config.js</code>:</p><pre class="mm mn mo mp fq mq mr ms mt aw mu dt"><span id="c37c" class="ls kw hu mr b fv mv mw l mx my">// packages/web-*/jest.config.js or services/web-*/jest.config.js<br/>const jestBase = require('../../jest.config.js')<br/>module.exports = {<br/>  ...jestBase,<br/>  coverageThreshold: {<br/>    global: {<br/>      statements: 100,<br/>      branches: 100,<br/>      functions: 100,<br/>      lines: 100<br/>    }<br/>  },<br/>  browser: true,<br/>  setupFiles: [<br/>    '&lt;rootDir&gt;/../../tests-setup/polyfill.js',<br/>    '&lt;rootDir&gt;/../../tests-setup/setup.js'<br/>  ]<br/>}</span></pre><h2 id="a30d" class="ls kw hu bd kx lt lu lv lb lw lx ly lf js lz ma lh jw mb mc lj ka md me ll mf dt translated">Node.js /同构包和服务</h2><p id="a76c" class="pw-post-body-paragraph jj jk hu jl b jm ln iv jo jp lo iy jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated"><code class="eh mz na nb mr b">iso-*</code>或<code class="eh mz na nb mr b">svr-*</code>包或服务在其根目录中使用以下<code class="eh mz na nb mr b">jest.config.js</code>:</p><pre class="mm mn mo mp fq mq mr ms mt aw mu dt"><span id="fc95" class="ls kw hu mr b fv mv mw l mx my">const jestBase = require('../../jest.config.js')<br/>module.exports = {<br/>  ...jestBase,<br/>  coverageThreshold: {<br/>    global: {<br/>      statements: 100,<br/>      branches: 100,<br/>      functions: 100,<br/>      lines: 100<br/>    }<br/>  },<br/>  testEnvironment: 'node'<br/>}</span></pre><p id="d148" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">注意我们是如何在每个包/服务级别上配置<code class="eh mz na nb mr b">coverageThreshold</code>的？这允许各个团队设置自己的阈值。管理每个包/服务要比在monorepo根级别简单得多。</p><h2 id="a830" class="ls kw hu bd kx lt lu lv lb lw lx ly lf js lz ma lh jw mb mc lj ka md me ll mf dt translated">测试执行</h2><p id="1339" class="pw-post-body-paragraph jj jk hu jl b jm ln iv jo jp lo iy jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">根文件<code class="eh mz na nb mr b">package.json</code>包含一个<code class="eh mz na nb mr b">"test": "lerna exec yarn test"</code>脚本。每个包和服务都有自己的<code class="eh mz na nb mr b">test</code>脚本，该脚本简单地调用Jest: <code class="eh mz na nb mr b">"test: jest"</code>。这种模式也适用于<code class="eh mz na nb mr b">test:coverage</code>。</p><p id="01e0" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们现在可以使用Lerna的<a class="ae kf" href="https://github.com/lerna/lerna#flags" rel="noopener ugc nofollow" target="_blank">标志</a>做各种各样的好事:</p><ul class=""><li id="9d99" class="kh ki hu jl b jm jn jp jq js kj jw kk ka kl ke km kn ko kp dt translated">对所有服务进行测试:<code class="eh mz na nb mr b">yarn test --scope @my-company-services/*</code>。</li><li id="12f1" class="kh ki hu jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp dt translated">对所有web包运行测试覆盖率:<code class="eh mz na nb mr b">yarn test:coverage --scope @my-company/web-*</code>。</li><li id="4fe2" class="kh ki hu jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp dt translated">对<code class="eh mz na nb mr b">@my-company/iso-package</code>包以及依赖于它的所有包和服务运行测试:<code class="eh mz na nb mr b">yarn test --scope @my-company/iso-package --include-filtered-dependencies</code>。</li></ul><p id="83f9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">为什么使用</strong> <code class="eh mz na nb mr b"><strong class="jl hv">lerna exec</strong></code> <strong class="jl hv">来执行一个npm脚本，而</strong> <code class="eh mz na nb mr b"><strong class="jl hv">lerna run</strong></code> <strong class="jl hv">正是这样做的？</strong></p><p id="d558" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">从我们遇到的情况来看，<code class="eh mz na nb mr b">lerna run</code>吞掉了npm脚本的输出。使用<code class="eh mz na nb mr b">--stream</code>标志，我们得到了输出，但它既没有格式化，也没有彩色控制台输出。</p><h2 id="b2ec" class="ls kw hu bd kx lt lu lv lb lw lx ly lf js lz ma lh jw mb mc lj ka md me ll mf dt translated">结论</h2><p id="1fb6" class="pw-post-body-paragraph jj jk hu jl b jm ln iv jo jp lo iy jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">虽然我可以想象Jest的多项目运行器比我们的解决方案更有性能，但我们喜欢Lerna的强大标志，并决定放弃Jest的方法。随着越来越多的测试加入monorepo，这种情况很可能会改变。(如果有人有什么想法，我很乐意与之交流)</p><h1 id="7efc" class="kv kw hu bd kx ky kz la lb lc ld le lf ja lg jb lh jd li je lj jg lk jh ll lm dt translated">埃斯林特&amp;更漂亮</h1><p id="4a50" class="pw-post-body-paragraph jj jk hu jl b jm ln iv jo jp lo iy jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">没有必要特别考虑。只需将您的配置文件添加到存储库根目录，它就可以像预期的那样工作了。</p><h1 id="de9a" class="kv kw hu bd kx ky kz la lb lc ld le lf ja lg jb lh jd li je lj jg lk jh ll lm dt translated">拉式请求、模板和标签</h1><p id="cb80" class="pw-post-body-paragraph jj jk hu jl b jm ln iv jo jp lo iy jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">拉取请求模板在<code class="eh mz na nb mr b">.github/PULL_REQUEST_TEMPLATE.md</code>文件中配置一次。它适用于所有软件包和服务。</p><p id="5a63" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">与多个存储库相比，在monorepo中管理拉请求需要更多的思考。在撰写本文时，我们还没有决定如何处理这个问题。初步讨论的一些注意事项包括:</p><ul class=""><li id="e82e" class="kh ki hu jl b jm jn jp jq js kj jw kk ka kl ke km kn ko kp dt translated">为每个包装/服务使用独特颜色的标签(尽管我们会很快用完可区分的颜色)</li><li id="d9e2" class="kh ki hu jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp dt translated">对新特性使用绿色标签，对错误使用红色标签。为每个包/服务创建绿色和红色标签，并将包/服务名称添加为标签名称。</li></ul><h1 id="546a" class="kv kw hu bd kx ky kz la lb lc ld le lf ja lg jb lh jd li je lj jg lk jh ll lm dt translated">结论</h1><p id="5b64" class="pw-post-body-paragraph jj jk hu jl b jm ln iv jo jp lo iy jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">团队很快就意识到了单一回购的好处。在此之前，我们使用<code class="eh mz na nb mr b">yarn link</code>来处理一个我们用来与后端API集成的小型SDK。这是可行的，如果你小心谨慎，不要像我们在当地发展那样与Docker打交道。尽管如此，这仍然是从事SDK的每个开发人员的精神负担。</p><p id="1083" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">配置好一切需要时间，我不打算粉饰这一点。感谢一个令人惊讶和好奇的团队，他们在整个过渡期表现出了耐心，我们现在可以花更多的时间来构建软件，而不是维护源代码库。谢谢大家！</p></div></div>    
</body>
</html>