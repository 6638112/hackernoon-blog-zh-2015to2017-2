<html>
<head>
<title>Let’s talk about Resilience</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们来谈谈弹性</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/lets-talk-about-resilience-97051e14761f?source=collection_archive---------9-----------------------#2017-07-26">https://medium.com/hackernoon/lets-talk-about-resilience-97051e14761f?source=collection_archive---------9-----------------------#2017-07-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="d3d0" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">度过停机时间并创造关键时刻体验</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff jj"><img src="../Images/ef79cf48d2509400aeb00ab3be765148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*m8i6EoRz7ClAL-kvGc_yEA.jpeg"/></div><figcaption class="jr js fg fe ff jt ju bd b be z ek">Fail Whale from Twitter’s Golden Years</figcaption></figure><p id="c4a9" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">贵公司的产品上一次停机是什么时候？它对您的客户有什么影响？</p><p id="056f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这个问题通常是开发团队视而不见的。我们希望应用程序始终保持运行，当它关闭时，我们会做出反应。这种被动的推理对我们开发者来说是公平的，但是要以用户体验为代价。</p><p id="6323" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果您是服务和应用程序开发的新手，您可能会想，<em class="kr">我还能做些什么来保持高正常运行时间？</em></p><p id="6327" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">让我介绍一下<em class="kr">弹性</em>的概念。</p><p id="1e10" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">弹性通常被定义为从失败中快速恢复的能力，倾向于弹性。在这篇文章中，我将讨论客户端和网络相关的<a class="ae ks" href="https://hackernoon.com/tagged/resilience" rel="noopener ugc nofollow" target="_blank">弹性</a>以及如何改进您当前的堆栈。</p><p id="5832" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我将使用awesome <a class="ae ks" href="https://github.com/mzabriskie/axios" rel="noopener ugc nofollow" target="_blank"> axios库</a>来说明下面的例子。</p><div class="kt ku fm fo kv kw"><a href="https://github.com/mzabriskie/axios" rel="noopener  ugc nofollow" target="_blank"><div class="kx ab ej"><div class="ky ab kz cl cj la"><h2 class="bd hv fv z el lb eo ep lc er et ht dt translated">mzabriskie/axios</h2><div class="ld l"><h3 class="bd b fv z el lb eo ep lc er et ek translated">浏览器和node.js的基于axios - Promise的HTTP客户端</h3></div><div class="le l"><p class="bd b gc z el lb eo ep lc er et ek translated">github.com</p></div></div><div class="lf l"><div class="lg l lh li lj lf lk jp kw"/></div></div></a></div><pre class="jk jl jm jn fq ll lm ln lo aw lp dt"><span id="4d14" class="lq lr hu lm b fv ls lt l lu lv">const axios = require('axios');</span></pre><h1 id="ca67" class="lw lr hu bd lx ly lz ma mb mc md me mf ja mg jb mh jd mi je mj jg mk jh ml mm dt translated">超时</h1><p id="18df" class="pw-post-body-paragraph jv jw hu jx b jy mn iv ka kb mo iy kd ke mp kg kh ki mq kk kl km mr ko kp kq hn dt translated">网络是不可预测的野兽。我们无法预测连接何时以及如何断开。我们能做的就是做好准备。</p><p id="63a1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><em class="kr">我的app达不到某个API会怎么样？反应慢一点怎么样？</em></p><p id="23cc" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">通常，开发人员会对此置之不理，因为我们希望用户总是连接到快速网络。这是一个危险的假设，尤其是当我们不知道谁是用户的时候。</p><p id="5981" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">为了做好准备，<em class="kr">总是给你的请求添加一个超时:</em></p><pre class="jk jl jm jn fq ll lm ln lo aw lp dt"><span id="4ec3" class="lq lr hu lm b fv ls lt l lu lv">async function MakeRequest() {<br/>  try {<br/>    await axios.get('/slow', {<br/>      timeout: 5000<br/>    });<br/>  } catch (err) {<br/>    // ...<br/>  }<br/>}</span></pre><p id="25d9" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这可以确保用户不必为你的应用程序的响应等待很长时间。你可以和你的UX同事讨论适应这种情况的各种方法。我最喜欢的是实现…</p><h1 id="f196" class="lw lr hu bd lx ly lz ma mb mc md me mf ja mg jb mh jd mi je mj jg mk jh ml mm dt translated">重试</h1><p id="aec9" class="pw-post-body-paragraph jv jw hu jx b jy mn iv ka kb mo iy kd ke mp kg kh ki mq kk kl km mr ko kp kq hn dt translated"><em class="kr">当我的请求失败或超时时会发生什么？</em></p><p id="47f9" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">客户端和网络错误比比皆是，任何开发人员都不应忽视这一事实。有很多请求失败的场景，我们必须考虑应用程序应该如何反应。</p><p id="7d6b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">一个好的策略是实现重试。通常的阈值是在真正失败之前重试3次。</p><pre class="jk jl jm jn fq ll lm ln lo aw lp dt"><span id="b2e9" class="lq lr hu lm b fv ls lt l lu lv">async function MakeRequest(retry = 0) {<br/>  try {<br/>    await axios.get('/failing', {<br/>      timeout: 5000<br/>    });<br/>  } catch (err) {<br/>    if (err &lt; 3) {<br/>      await MakeRequest(retry + 1);<br/>    } else {<br/>      // ...<br/>    }<br/>  }<br/>}</span></pre><p id="fcf5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这确保了应用程序有足够的尝试次数来尝试到达曾经失败的端点。</p><p id="982c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><em class="kr">就此场景与您的UX同事合作，确定如何处理正在重试的临时请求和最终的正常失败。</em></p><h1 id="302b" class="lw lr hu bd lx ly lz ma mb mc md me mf ja mg jb mh jd mi je mj jg mk jh ml mm dt translated">撤退</h1><p id="ac14" class="pw-post-body-paragraph jv jw hu jx b jy mn iv ka kb mo iy kd ke mp kg kh ki mq kk kl km mr ko kp kq hn dt translated">如果我的请求失败了怎么办？我应该向用户展示什么？</p><p id="bb2d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">不可避免地会出现停机。仅仅因为你在使用AWS，并不意味着你的应用不会失败。一切终将失败，你得有退路。</p><pre class="jk jl jm jn fq ll lm ln lo aw lp dt"><span id="5bde" class="lq lr hu lm b fv ls lt l lu lv">async function MakeRequest(retry = 0, fallback = false) {<br/>  try {<br/>    const url = fallback === false ? '/failing' : '/fallback';<br/>    await axios.get(url, {<br/>      timeout: 5000<br/>    });<br/>  } catch (err) {<br/>    if (err &lt; 3) {<br/>      await MakeRequest(retry + 1, fallback);<br/>    } else {<br/>      if (fallback === false) {<br/>        await MakeRequest(0, true);<br/>      } else {<br/>        // ...<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="bee1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这确保了在请求失败的情况下，应用程序会收到一些东西。这不会破坏用户的体验，因为在他们看来这并不一定会导致失败。</p><h1 id="af0a" class="lw lr hu bd lx ly lz ma mb mc md me mf ja mg jb mh jd mi je mj jg mk jh ml mm dt translated">记录</h1><p id="4251" class="pw-post-body-paragraph jv jw hu jx b jy mn iv ka kb mo iy kd ke mp kg kh ki mq kk kl km mr ko kp kq hn dt translated"><em class="kr">我怎么知道哪个请求/屏幕/api失败了？</em></p><p id="ddc9" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这是编写应用程序之前必须涵盖的基础知识之一。确保在您的开发和生产环境中可以进行适当的监控。这包括客户端和服务器端。</p><p id="29cc" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">从服务器端对您的监控工具实施集中日志记录。捕获所有已处理的异常，并将它们丢到可搜索的日志中。当最坏的情况发生时，这将大大有助于您的调试工作。</p><p id="e0ca" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">也实现客户端错误处理，如果可能的话，将它们放在监控工具中的一个单独的桶中。它将帮助您确定以前无法预测的故障点。</p><h1 id="0402" class="lw lr hu bd lx ly lz ma mb mc md me mf ja mg jb mh jd mi je mj jg mk jh ml mm dt translated">断路器</h1><p id="d2be" class="pw-post-body-paragraph jv jw hu jx b jy mn iv ka kb mo iy kd ke mp kg kh ki mq kk kl km mr ko kp kq hn dt translated"><em class="kr">如果服务经常失败，我该怎么办？</em></p><p id="c7e7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这一点涵盖了更多的微服务方法，在我看来，在大多数情况下你应该完全避免(在评论中问我<em class="kr">为什么</em>)。如果你已经处于这种情况，<strong class="jx hv">让我们的朋友</strong> <a class="ae ks" href="https://martinfowler.com/bliki/CircuitBreaker.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jx hv">马丁福勒解释一下</strong> </a> <strong class="jx hv">。</strong></p><div class="kt ku fm fo kv kw"><a href="https://martinfowler.com/bliki/CircuitBreaker.html" rel="noopener  ugc nofollow" target="_blank"><div class="kx ab ej"><div class="ky ab kz cl cj la"><h2 class="bd hv fv z el lb eo ep lc er et ht dt translated">断路器</h2><div class="ld l"><h3 class="bd b fv z el lb eo ep lc er et ek translated">连续交付应用程序架构标签:软件系统远程调用软件是很常见的…</h3></div><div class="le l"><p class="bd b gc z el lb eo ep lc er et ek translated">martinfowler.com</p></div></div><div class="lf l"><div class="ms l lh li lj lf lk jp kw"/></div></div></a></div><p id="7be5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">本质上，您的应用程序需要能够选择性能良好的服务节点，并在这些服务节点关闭时保护您的服务。一个显著的好处是对可用资源的智能处理。防止不必要的cpu和内存使用，你可以把它分配到其他地方。</p><p id="3f94" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">回退、重试和日志记录的组合对于实现这一点至关重要。</p><p id="43e7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">请阅读马丁·福勒的观点，因为他是最好的解释者。您也可以查看<a class="ae ks" rel="noopener" href="/netflix-techblog/introducing-hystrix-for-resilience-engineering-13531c1ab362">网飞/海斯特里克斯</a>库进行参考。</p><div class="kt ku fm fo kv kw"><a rel="noopener follow" target="_blank" href="/netflix-techblog/making-the-netflix-api-more-resilient-a8ec62159c2d"><div class="kx ab ej"><div class="ky ab kz cl cj la"><h2 class="bd hv fv z el lb eo ep lc er et ht dt translated">提高网飞API的弹性</h2><div class="ld l"><h3 class="bd b fv z el lb eo ep lc er et ek translated">为每天处理十亿次请求的系统保持高可用性和弹性。</h3></div><div class="le l"><p class="bd b gc z el lb eo ep lc er et ek translated">medium.com</p></div></div><div class="lf l"><div class="mt l lh li lj lf lk jp kw"/></div></div></a></div><h1 id="89f3" class="lw lr hu bd lx ly lz ma mb mc md me mf ja mg jb mh jd mi je mj jg mk jh ml mm dt translated">结论</h1><p id="e658" class="pw-post-body-paragraph jv jw hu jx b jy mn iv ka kb mo iy kd ke mp kg kh ki mq kk kl km mr ko kp kq hn dt translated">最后，所有这一切都是在开发者、建筑师和UX之间进行的，目的是为用户提供一个好的体验。这永远是终极目标。</p><p id="fe40" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">永远记住，UX并没有以<a class="ae ks" href="https://hackernoon.com/tagged/design" rel="noopener ugc nofollow" target="_blank">设计</a>结束，它也是用户如何通过不同的场景体验你的应用程序。无论是故障、缓慢，甚至是停机。</p><p id="677c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我可能没有涵盖每一个角落，但我希望它能在您考虑构建下一个堆栈时，为您提供一个正确的方向。</p><p id="cca0" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">祝你好运！</p></div><div class="ab cl mu mv hc mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="hn ho hp hq hr"><p id="9593" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">通过网飞的博客了解更多关于弹性的内容，他们那里有很棒的东西。别忘了去看看Hystrix和混沌猴。</p><div class="kt ku fm fo kv kw"><a rel="noopener follow" target="_blank" href="/netflix-techblog/making-the-netflix-api-more-resilient-a8ec62159c2d"><div class="kx ab ej"><div class="ky ab kz cl cj la"><h2 class="bd hv fv z el lb eo ep lc er et ht dt translated">提高网飞API的弹性</h2><div class="ld l"><h3 class="bd b fv z el lb eo ep lc er et ek translated">为每天处理十亿次请求的系统保持高可用性和弹性。</h3></div><div class="le l"><p class="bd b gc z el lb eo ep lc er et ek translated">medium.com</p></div></div><div class="lf l"><div class="mt l lh li lj lf lk jp kw"/></div></div></a></div><div class="kt ku fm fo kv kw"><a rel="noopener follow" target="_blank" href="/netflix-techblog/introducing-hystrix-for-resilience-engineering-13531c1ab362"><div class="kx ab ej"><div class="ky ab kz cl cj la"><h2 class="bd hv fv z el lb eo ep lc er et ht dt translated">弹性工程中的Hystrix简介</h2><div class="ld l"><h3 class="bd b fv z el lb eo ep lc er et ek translated">在分布式环境中，任何给定服务的失败都是不可避免的。</h3></div><div class="le l"><p class="bd b gc z el lb eo ep lc er et ek translated">medium.com</p></div></div><div class="lf l"><div class="nb l lh li lj lf lk jp kw"/></div></div></a></div><div class="kt ku fm fo kv kw"><a rel="noopener follow" target="_blank" href="/netflix-techblog/chaos-engineering-upgraded-878d341f15fa"><div class="kx ab ej"><div class="ky ab kz cl cj la"><h2 class="bd hv fv z el lb eo ep lc er et ht dt translated">混沌工程升级</h2><div class="ld l"><h3 class="bd b fv z el lb eo ep lc er et ek translated">混沌金刚是迄今为止最具破坏力的混沌猴子</h3></div><div class="le l"><p class="bd b gc z el lb eo ep lc er et ek translated">medium.com</p></div></div><div class="lf l"><div class="nc l lh li lj lf lk jp kw"/></div></div></a></div><div class="kt ku fm fo kv kw"><a rel="noopener follow" target="_blank" href="/netflix-techblog/the-netflix-simian-army-16e57fbab116"><div class="kx ab ej"><div class="ky ab kz cl cj la"><h2 class="bd hv fv z el lb eo ep lc er et ht dt translated">网飞猿人军</h2><div class="ld l"><h3 class="bd b fv z el lb eo ep lc er et ek translated">保持我们的云安全、可靠且高度可用</h3></div><div class="le l"><p class="bd b gc z el lb eo ep lc er et ek translated">medium.com</p></div></div></div></a></div></div><div class="ab cl mu mv hc mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="hn ho hp hq hr"><p id="efb2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果你在新加坡，想要这些东西，就来加入我们吧:</p><div class="kt ku fm fo kv kw"><a href="https://foxcareers.com/Search/JobDetail/FOX0003GA?organization=Fox+Networks+Group" rel="noopener  ugc nofollow" target="_blank"><div class="kx ab ej"><div class="ky ab kz cl cj la"><h2 class="bd hv fv z el lb eo ep lc er et ht dt translated">数字产品经理-订阅、支付和合作伙伴-福克斯职业</h2><div class="ld l"><h3 class="bd b fv z el lb eo ep lc er et ek translated">数字产品经理-订阅、支付和合作伙伴</h3></div><div class="le l"><p class="bd b gc z el lb eo ep lc er et ek translated">- Fox Careers数字产品经理-订阅、支付和Partnershipsfoxcareers.com</p></div></div><div class="lf l"><div class="nd l lh li lj lf lk jp kw"/></div></div></a></div><div class="kt ku fm fo kv kw"><a href="https://foxcareers.com/Search/JobDetail/FOX0003G9?organization=Fox+Networks+Group" rel="noopener  ugc nofollow" target="_blank"><div class="kx ab ej"><div class="ky ab kz cl cj la"><h2 class="bd hv fv z el lb eo ep lc er et ht dt translated">Fox+ - Fox Careers视频开发和运营经理</h2><div class="ld l"><h3 class="bd b fv z el lb eo ep lc er et ek translated">商标和版权声明:商标和福克斯及其相关实体。保留所有权利。使用本网站假设…</h3></div><div class="le l"><p class="bd b gc z el lb eo ep lc er et ek translated">foxcareers.com</p></div></div><div class="lf l"><div class="ne l lh li lj lf lk jp kw"/></div></div></a></div><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nf ng l"/></div></figure></div></div>    
</body>
</html>