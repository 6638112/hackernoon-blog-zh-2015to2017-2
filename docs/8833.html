<html>
<head>
<title>Kafka &amp; Redis Streams</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">卡夫卡和雷迪斯溪流</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/introduction-to-redis-streams-133f1c375cd3?source=collection_archive---------0-----------------------#2017-12-17">https://medium.com/hackernoon/introduction-to-redis-streams-133f1c375cd3?source=collection_archive---------0-----------------------#2017-12-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="b2aa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">先说队列设计。</p><p id="f626" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们有一本很长的书，我们想让很多人读。有些人可以在午餐时间阅读，有些人在周一晚上阅读，有些人把它带回家过周末。这本书太长了，以至于在任何时候，我们都有数百人在阅读它。</p><p id="a196" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们书的读者需要知道他们在书里读到哪里了，所以他们通过在书里放一个书签来记录他们的位置。有些读者读得很慢，把书签放在靠近开头的地方。其他读者半途而废，把他们的放在中间，再也不回来了。</p><p id="d1bb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">更糟糕的是，我们<strong class="it hv">每天都在给这本书增加页面</strong>。没有人能真正完成这本书。</p><p id="8bb3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最终我们的书塞满了书签，直到有一天它变得太重而无法携带，没有人能再阅读它。</p><p id="386d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个非常聪明的人于是决定不允许读者在书里面放书签，而是必须由<strong class="it hv">在他们的日记上写下他们读到的第</strong>页。</p><p id="b8ea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是阿帕奇卡夫卡的设计，而且是非常有韧性的设计。读者往往不是负责任的公民，往往不会清理自己的垃圾，这本书可能是我们公司发生的所有重要事件的日志。</p><p id="5346" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">其他队列的常见替代设计是让队列服务跟踪读取器的位置——这意味着需要为每个读取器分配内存。表现不佳的读取器可能会重复请求新的队列会话，这会使队列服务不堪重负。这通常不是一个好的设计，因为我们希望读者可以自由阅读，而不会对队列造成任何风险。</p><h1 id="ed17" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated"><strong class="ak">阿帕奇卡夫卡</strong></h1><p id="a3cf" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">卡夫卡是围绕一系列事件设计的，比如:</p><blockquote class="ks kt ku"><p id="1392" class="ir is kv it b iu iv iw ix iy iz ja jb kw jd je jf kx jh ji jj ky jl jm jn jo hn dt translated">1001.<strong class="it hv"> tim </strong>已经<strong class="it hv">购买了</strong>travel deal’<strong class="it hv">Fiji</strong>’<br/>1002。<strong class="it hv">蒂姆</strong>已经<strong class="it hv">将</strong>他的订阅偏好更新为<strong class="it hv">每日</strong><br/>1003。使用'<strong class="it hv"> iphone </strong> ' <br/> 1004，<strong class="it hv"> sam </strong>已在中<strong class="it hv">登录</strong> <strong class="it hv">。<strong class="it hv">山姆</strong>已经<strong class="it hv">开通</strong>旅游交易<strong class="it hv">巴厘岛</strong>’<br/>1005。<strong class="it hv">山姆</strong>已经<strong class="it hv">使用<strong class="it hv">桌面网页</strong><br/>1006在</strong>中登录</strong> <strong class="it hv">。<strong class="it hv">山姆</strong>已经<strong class="it hv">购买了</strong>交易<strong class="it hv">巴厘岛</strong></strong></p></blockquote><p id="6a13" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Kafka事件读取器跟踪它们一直读到的流中的ID，这意味着事件服务器不需要跟踪它们。这允许Kafka事件服务器保持可预测的内存使用，即使有许多行为不良的读取器。编辑:这过于简化了，因为卡夫卡确实通过跟踪消费者群体的补偿来提供帮助——不管一般原理是什么。</p><h1 id="e6d6" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">卡夫卡听起来很棒，为什么是Redis Streams？</h1><p id="d2c5" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">Kafka是存储事件流的绝佳选择，它是为高规模而设计的。为了达到这种规模，卡夫卡采取了额外的复杂性。供应和管理Kafka设置确实需要理解一些复杂的概念。对于较小的项目，更简单、更小的系统可能是更好的选择。虽然我们都喜欢解决谷歌规模的问题，但这是很少需要的。</p><p id="91d9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Redis是简单的、通常非持久的数据存储最常见的选择之一。它在所有流行的编程语言中都有很好的库支持，并且被大多数开发人员很好地理解。这是为了简单性而牺牲强大的分布式弹性的一个极好的例子。Redis现在支持Kafka事件流概念的一个更简单的版本，使得每个人都可以容易且廉价地获得架构概念。</p><p id="1062" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了开始使用Redis流，我将介绍Redis版本5中的两个新命令。按照这个例子，您可以在大约2分钟内创建一个使用AWS ElastiCache的在线Redis实例。</p><h1 id="c16a" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">写入Redis流</h1><blockquote class="ks kt ku"><p id="bec4" class="ir is kv it b iu iv iw ix iy iz ja jb kw jd je jf kx jh ji jj ky jl jm jn jo hn dt translated">XADD stream _ name * key 1 value 1 key 2 value 2(等等)</p></blockquote><p id="b32e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">XADD允许我们编写事件流。让我们创建一个反映上面例子的事件流。我们将把我们的流命名为“事件”。</p><pre class="kz la lb lc fq ld le lf lg aw lh dt"><span id="63d3" class="li jq hu le b fv lj lk l ll lm">XADD events * user tim action purchase item travel:fiji<br/>XADD events * user tim action preferences subscription daily<br/>XADD events * user sam action login platform iPhone<br/>XADD events * user sam action visit item travel:bali<br/>XADD events * user sam action login platform “desktop web”<br/>XADD events * user sam action purchase item travel:bali</span></pre><p id="e1b2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">“*”用于将可选参数与键值集分开。</p><p id="b4ce" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将把所有这些动作写到“事件”流中。</p><h1 id="32a8" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">从Redis流中读取</h1><blockquote class="ks kt ku"><p id="b56b" class="ir is kv it b iu iv iw ix iy iz ja jb kw jd je jf kx jh ji jj ky jl jm jn jo hn dt translated">XREAD COUNT 2流事件项目id</p></blockquote><p id="da95" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">XREAD允许我们从这个队列中读取项目。让我们一次读两个项目:</p><pre class="kz la lb lc fq ld le lf lg aw lh dt"><span id="5e76" class="li jq hu le b fv lj lk l ll lm">demo.wiftycloud.com:6379&gt; XREAD COUNT 2 STREAMS events 0<br/>1) 1) “events”<br/>   2) 1) 1) 1512991598699–0<br/>         2) 1) “user”<br/>            2) “tim”<br/>            3) “action”<br/>            4) “purchase”<br/>            5) “item”<br/>            6) “travel:fiji”<br/>      2) 1) 1512991602438–0<br/>         2) 1) “user”<br/>            2) “tim”<br/>            3) “action”<br/>            4) “preferences”<br/>            5) “subscription”<br/>            6) “daily”</span></pre><p id="51dc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们正在请求流“events”中的项目，从列表的开头开始(通过传递“0”)。我们只要求2个项目。为了获得接下来的两个项目，我们现在从Redis返回的最后一个ID开始，而不是从“0”开始，在上面的示例中是“1512991602438–0”。</p><pre class="kz la lb lc fq ld le lf lg aw lh dt"><span id="5e7f" class="li jq hu le b fv lj lk l ll lm">&gt; XREAD COUNT 2 streams events 1512991602438–0<br/>1) 1) “events”<br/>   2) 1) 1) 1512991605766-0<br/>         2) 1) “user”<br/>            2) “sam”<br/>            3) “action”<br/>            4) “logon”<br/>            5) “platform”<br/>            6) “iPhone”<br/>      2) 1) 1512991617871-0<br/>         2) 1) “user”<br/>            2) “sam”<br/>            3) “action”<br/>            4) “visit”<br/>            5) “item”<br/>            6) “travel:bali”</span></pre><p id="5ed8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">其他选项是可用的— BLOCK允许我们让Redis服务器在连接上等待，直到事件可用。</p><p id="b7e1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这两个命令XADD和XREAD之间，我们可以非常容易地构建一个业务事件队列。</p><p id="8362" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> Node.js示例</strong></p><p id="b9e1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">库对流的支持还没有完全准备好，但是目前可以使用自定义命令。使用ioredis做这件事的一个例子可以在<a class="ae ln" href="https://gist.github.com/forkfork/c27d741650dd65631578771ab264dd2c" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="1cdf" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">TL；速度三角形定位法(dead reckoning)</h1><p id="76c1" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">Kafka令人惊叹，Redis Streams正在成为Kafka的一个伟大的LoFi替代品，用于管理一系列事件。</p></div></div>    
</body>
</html>