<html>
<head>
<title>Build, publish, and manage React Native apps with ease</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">轻松构建、发布和管理React本机应用</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/build-publish-and-manage-react-native-apps-with-ease-5e4529b812f9?source=collection_archive---------6-----------------------#2017-04-12">https://medium.com/hackernoon/build-publish-and-manage-react-native-apps-with-ease-5e4529b812f9?source=collection_archive---------6-----------------------#2017-04-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir"><p id="9cd3" class="is it hu bd iu iv iw ix iy iz ja jb ek translated">如何利用React Native上的<a class="ae jc" href="https://new.shoutem.com/" rel="noopener ugc nofollow" target="_blank"> Shoutem </a>平台</p></blockquote></div><div class="ab cl jd je hc jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hn ho hp hq hr"><p id="1a3b" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg jb hn dt translated">来自Cordova/Ionic &amp; AngularJS的背景，我有机会成为Shoutem平台测试阶段的首批开发人员之一。</p><p id="fb58" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg jb hn dt translated">在这篇文章中，我将回顾我是如何使用<a class="ae jc" href="https://hackernoon.com/tagged/shouthem" rel="noopener ugc nofollow" target="_blank"> Shoutem </a>平台构建一个全功能应用程序的。以下是我面临的最大挑战，以及我如何看待应用开发生态系统中的<a class="ae jc" href="https://new.shoutem.com/" rel="noopener ugc nofollow" target="_blank"> Shoutem平台</a>。</p><p id="e101" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg jb hn dt translated">一方面，我与一些Shoutem内部组件紧密耦合，但另一方面，我也可以作为一名使用Shoutem平台作为服务的开发人员，从一个鸟瞰的角度来说。所以我们开始吧。</p><h2 id="1b32" class="kh ki hu bd kj kk kl km kn ko kp kq kr jv ks kt ku jz kv kw kx kd ky kz la lb dt translated">从开发人员的角度来看</h2><p id="0e43" class="pw-post-body-paragraph jk jl hu jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg jb hn dt translated">作为一名开发人员，你可以将Shoutem平台视为一个非常灵活的层，位于<a class="ae jc" href="https://hackernoon.com/tagged/react-native" rel="noopener ugc nofollow" target="_blank"> React Native </a>和<a class="ae jc" href="https://hackernoon.com/tagged/redux" rel="noopener ugc nofollow" target="_blank"> Redux </a>之上。它引入了用于构建React本地应用的新架构，并附带了一个GUI，因此非技术用户也可以构建他们的应用。</p><p id="ab98" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg jb hn dt translated">Shoutem平台的最大优势是它加快了应用程序的开发过程。Shoutem封装了常见的应用程序特性，称为扩展，可以跨应用程序重用。Shoutem自带40多个现成的常用应用程序扩展。扩展包括登录脸书，推送通知，用户管理等。你可以在这个<a class="ae jc" href="https://github.com/shoutem/extensions" rel="noopener ugc nofollow" target="_blank"> github repo </a>上找到扩展的完整列表。</p><p id="ffb1" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg jb hn dt translated">重要的一点是GUI，它允许非技术用户定制应用程序中使用的扩展，甚至不需要接触任何代码行。此外，您可以使用<a class="ae jc" href="https://facebook.github.io/react-native/" rel="noopener ugc nofollow" target="_blank"> React Native </a>从头开始构建您的扩展。</p><p id="a498" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg jb hn dt translated">对我来说，最困难的事情是理解扩展背后的概念以及它们如何相互作用。设想一个处理脸书登录和用户名/密码登录的身份验证扩展。最初，您只需开发一个独立的身份验证扩展。但是在应用程序的上下文中，该扩展必须与其他组件进行大量的交互。例如，一个扩展，根据登录的用户显示一些用户特定的内容。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lh"><img src="../Images/23c42273a5412c3ef7b07aaf77f2d50a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2pz5EF_jZBTbk742."/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek">Shoutem Ecosystem</figcaption></figure><p id="e993" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg jb hn dt translated">在内部，Shoutem使用<a class="ae jc" href="http://redux.js.org" rel="noopener ugc nofollow" target="_blank"> redux </a>来管理应用程序的全局状态。您可以将状态视为所有扩展都可以访问的一致容器。身份验证扩展可以将登录的用户注入到状态中，定义一些用于从状态访问用户的内部API，因此任何其他扩展都可以访问状态中的用户对象。</p><p id="ba38" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg jb hn dt translated">很好地理解<a class="ae jc" href="http://redux.js.org" rel="noopener ugc nofollow" target="_blank"> redux </a>对于编写定制的Shoutem扩展非常重要。</p><h2 id="1783" class="kh ki hu bd kj kk kl km kn ko kp kq kr jv ks kt ku jz kv kw kx kd ky kz la lb dt translated">推送通知集成</h2><p id="4425" class="pw-post-body-paragraph jk jl hu jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg jb hn dt translated">我起初对Shoutem非常怀疑，因为我认为它是市场上常见的应用程序生成器。正如我们所知，应用构建器对于开发者来说远非可定制、灵活和开放的。</p><p id="4bf0" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg jb hn dt translated">我很快了解到Shoutem不是一个应用构建器——它是React本地开发者的平台，除了其他部分之外，它还有一个用于管理应用的GUI。GUI在开发者和他们的客户之间提供了一个更简单的连接。我将给出一个我所面对的简短的例子，来说明我所说的对开发人员灵活和开放是什么意思。</p><p id="8472" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg jb hn dt translated">在我的应用程序中使用firebase云消息集成推送通知时，我使用了<a class="ae jc" href="https://github.com/shoutem/extensions/tree/master/shoutem-firebase" rel="noopener ugc nofollow" target="_blank"> shoutem-firebase </a>扩展，该扩展将所有Firebase特定的组件封装在一个扩展中。</p><p id="59d5" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg jb hn dt translated">你要做的第一件事就是去app builder安装shoutem-firebase扩展。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lx"><img src="../Images/0c469b25218500e6fe86984e635343cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*brzg3J7tKh75fobDHn67_w.png"/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek">Installing the Firebase extension for your app via the App Builder</figcaption></figure><p id="d15f" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg jb hn dt translated">下次您使用Shoutem CLI在本地运行应用程序时</p><pre class="li lj lk ll fq ly lz ma mb aw mc dt"><span id="0486" class="kh ki hu lz b fv md me l mf mg">shoutem run-ios &lt;your app id&gt;</span></pre><p id="c4f4" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg jb hn dt translated">您可以将<a class="ae jc" href="https://github.com/shoutem/extensions/tree/master/shoutem-firebase" rel="noopener ugc nofollow" target="_blank"> shoutem-firebase </a>扩展捆绑到React本地应用程序中。仅供参考，Shoutem将您的React原生应用程序捆绑到~/中。shou tem/平台/构建。</p><p id="d69c" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg jb hn dt translated">因此，从这一点开始，firebase扩展驻留在您的应用程序中。到目前为止还不错，但是要使用推送通知，我需要将Firebase云消息令牌发送到我自己的后端并与用户关联。此外，我想在应用程序的特定点触发“请求推送通知权限对话框”，而不是在应用程序启动后立即触发。所以，我不得不做一些定制来实现它，这也是Shoutem平台发挥作用的地方。</p><p id="c2b7" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg jb hn dt translated">shoutem-firebase扩展在内部触发一个名为<em class="mh"> REQUEST_PUSH_PERMISSION </em>的<a class="ae jc" href="http://redux.js.org/docs/basics/Actions.html" rel="noopener ugc nofollow" target="_blank"> redux动作</a>，当被触发时会被某个<a class="ae jc" href="http://redux.js.org/docs/advanced/Middleware.html" rel="noopener ugc nofollow" target="_blank"> redux中间件</a>捕获，以显示“请求推送通知权限对话框”。整个应用程序中的任何组件都可以看到所有这些触发的操作。这也是我注入逻辑的地方。所以当我想显示对话框时，我首先触发的是<em class="mh"> REQUEST_PUSH_PERMISSION </em>动作。所以我从我的Shoutem扩展中触发了这个<a class="ae jc" href="https://hackernoon.com/tagged/redux" rel="noopener ugc nofollow" target="_blank"> redux </a>动作。</p><pre class="li lj lk ll fq ly lz ma mb aw mc dt"><span id="b636" class="kh ki hu lz b fv md me l mf mg">screens/MyOwnScreen.js</span><span id="05ee" class="kh ki hu lz b fv mi me l mf mg">componentDidMount() {<br/>    ...<br/>    this.props.actions.requestPushPermission(access_token);<br/>    ...<br/>}</span><span id="29e7" class="kh ki hu lz b fv mi me l mf mg">redux.js:</span><span id="b762" class="kh ki hu lz b fv mi me l mf mg">export function requestPushPermission(accessToken) {<br/>  return { type: REQUEST_PUSH_PERMISSION, accessToken: accessToken};<br/>}</span></pre><p id="8cdb" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg jb hn dt translated">这个片段的作用是，当MyOwnScreen.js被挂载时，触发一个<em class="mh">REQUEST _ PUSH _ PERMISSION</em>动作。此时，该操作被触发两次，一次来自shoutem-firebase扩展，另一次来自我自己的扩展。为了防止默认操作，我在自己的shoutem扩展中安装了一个定制的中间件。</p><pre class="li lj lk ll fq ly lz ma mb aw mc dt"><span id="ce46" class="kh ki hu lz b fv md me l mf mg">middleware.js</span><span id="dd6a" class="kh ki hu lz b fv mi me l mf mg">const requestPermissions = store =&gt; next =&gt; action =&gt; {<br/>    if (action.type === REQUEST_PUSH_PERMISSION) {</span><span id="b51a" class="kh ki hu lz b fv mi me l mf mg">      if (action.hasOwnProperty(‘accessToken’)) {<br/>        FCM.getFCMToken().then(token =&gt; {<br/>        console.log(‘Firebase device token:’, token);</span><span id="6da7" class="kh ki hu lz b fv mi me l mf mg">        // TODO: send the token to your backend</span><span id="5f35" class="kh ki hu lz b fv mi me l mf mg">        // show the request push notification permission dialog<br/>        FCM.requestPermissions();<br/>      } else {<br/>        return next(action);<br/>      }<br/>    }<br/>};</span><span id="5537" class="kh ki hu lz b fv mi me l mf mg">setPriority(requestPermissions, priorities.FIRST);</span></pre><p id="8850" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg jb hn dt translated">这个定制中间件监听<em class="mh">REQUEST _ PUSH _ PERMISSION</em>动作，并检查接收到的动作是否包含<em class="mh"> accessToken </em>(只有定制动作中包含<em class="mh"> accessToken </em>)。如果动作包含一个<em class="mh"> accessToken </em>，中间件识别从MyOwnScreen.js内部触发的自定义动作，当动作被触发时，中间件将收到的令牌发送到服务器，并显示推送通知权限对话框。否则，它将动作分派给下一个中间件。在最后一行，我们确保中间件是第一个被调用的。</p><p id="59ec" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg jb hn dt translated">这个例子应该让您了解到，在完全不涉及shoutem-firebase扩展的情况下，扩展现有扩展的功能是多么容易。如果你愿意，你也可以用你自己的逻辑来扩展默认的shoutem扩展，它们都是开源的，或者你可以从头开始编写你自己的扩展。</p><p id="dda7" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg jb hn dt translated">最后，你用Shoutem构建的应用程序可以归结为一个普通的React原生应用程序，作为开发人员，每个方面都在你的掌握之中。</p><h2 id="69f6" class="kh ki hu bd kj kk kl km kn ko kp kq kr jv ks kt ku jz kv kw kx kd ky kz la lb dt translated">结论</h2><p id="6d35" class="pw-post-body-paragraph jk jl hu jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg jb hn dt translated">在没有任何React Native / Redux背景的情况下，在开始使用Shoutem平台之前，一开始就获得整体概念并不容易。老实说，Shoutem给整个堆栈增加了一些复杂性，尤其是当你以前从未使用过React Native / Redux的时候。但是一旦你理解了这个概念，好处是多种多样的，而且对你来说这一切都是自然的和合乎逻辑的。</p><p id="0522" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg jb hn dt translated">随着越来越多的开发者适应Shoutem平台，我看到了它背后的巨大潜力。Shoutem在React Native之上建立了一个干净、专业的层，可以以不同的方式使用。该平台提供了一个简单易用的图形应用构建器，无需编写任何代码即可构建应用。更重要的是，该平台没有通过引入扩展的概念和让第三方开发者选择从头构建完全属于自己的扩展来削减构建应用程序的任何灵活性。</p><div class="li lj lk ll fq ab cb"><figure class="mj lm mk ml mm mn mo paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mj lm mk ml mm mn mo paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mj lm mk ml mm mn mo paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mp mq mr"><p id="f922" class="jk jl mh jm b jn jo jp jq jr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg jb hn dt translated"><a class="ae jc" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jc" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jc" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae jc" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jk jl mh jm b jn jo jp jq jr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg jb hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jc" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jc" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff mv"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="li lj lk ll fq lm"><div class="bz el l di"><div class="mw mx l"/></div></figure></div></div>    
</body>
</html>