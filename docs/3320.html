<html>
<head>
<title>Escaping a Python sandbox with a memory corruption bug</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">逃离带有内存损坏错误的Python沙盒</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/python-sandbox-escape-via-a-memory-corruption-bug-19dde4d5fea5?source=collection_archive---------4-----------------------#2017-03-27">https://medium.com/hackernoon/python-sandbox-escape-via-a-memory-corruption-bug-19dde4d5fea5?source=collection_archive---------4-----------------------#2017-03-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="5f72" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">几周前，我决定挠一挠已经痒了一段时间的痒——参加一些臭虫奖励计划。也许bug bounty游戏中最艰巨的任务是选择一个投资回报率最高的程序。不过不久，我偶然发现了一个在<a class="ae jp" href="https://hackernoon.com/tagged/python" rel="noopener ugc nofollow" target="_blank"> Python </a>沙箱中执行用户提交代码的web应用程序。这看起来很有趣，所以我决定继续下去。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff jq"><img src="../Images/d3e517f6d992c432c20830095c4e9081.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*WestfdzvkSEriY7WmvHkJg.jpeg"/></div><figcaption class="jy jz fg fe ff ka kb bd b be z ek">Let me out of this god-forsaken sandbox!</figcaption></figure><p id="3d0d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">经过一段时间的探索，我发现了如何通过对Python层的一些攻击来打破沙盒。报告存档。几天之内，bug被修复，还有丰厚的奖励。太棒了。我的昆虫赏金冒险之旅有了一个好的开始。但是这篇文章不是关于那份报告的。总而言之，从技术角度来看，我发现的问题并不那么有趣。事实证明，这些问题只是因为回归才出现的。</p><p id="f84a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是我不相信保护Python沙盒会这么容易。在不涉及太多细节的情况下，沙箱使用了操作系统级隔离和锁定Python解释器的组合。Python环境使用定制的白名单/黑名单方案来防止对未屏蔽的内置、模块、函数等的访问。基于操作系统的隔离提供了一些额外的保护，但以今天的标准来看已经过时了。突破锁定的Python解释器并不是100%的胜利，但是它使攻击者危险地接近能够危害整个系统。</p><p id="fbf0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以我回到应用程序，并刺激了一些。运气不好。这的确是一块难啃的饼干。但是后来我有了一个想法——Python模块通常只是堆积如山的C代码库的薄薄的包装。肯定有一些内存损坏漏洞等着被发现。利用一个内存损坏错误可以让我脱离受限的Python环境。</p><p id="9df4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从哪里开始？我知道一组Python模块，它们被列入白名单，可以在沙箱中导入。也许我应该运行一个AFL fuzzers的分布式网络？还是符号执行引擎？或者我应该用最先进的静态分析工具扫描它们？当然，我可以做任何这些事情。或者我可以只查询一些错误追踪器。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff kc"><img src="../Images/89075d0cae3a107c7e6f94290fe37cd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*33rRIWftnWT0ElEkrr5hzg.png"/></div></div></figure><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff kh"><img src="../Images/5711fe3c8ca445f35404b9f05a628575.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kkXiLeWm_gfPC-e7_BIk5g.png"/></div></div></figure><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff ki"><img src="../Images/b3d9319c14c717660c3754c3515f3699.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jxZwfG_RJebtuzBXxkIdyg.png"/></div></div></figure><p id="2cc2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">原来我在开始狩猎时没有这种后知之明，但这并不重要。我的直觉告诉我，通过手动代码审查和测试，在沙箱的白名单模块之一中发现了一个可利用的内存损坏漏洞。这个bug在Numpy中，它是科学计算的基础库，是许多流行软件包的核心，包括scipy和pandas。为了大致了解Numpy作为内存损坏bug的潜在来源，让我们来看看代码行数。</p></div><div class="ab cl kj kk hc kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hn ho hp hq hr"><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="kq kr l"/></div><figcaption class="jy jz fg fe ff ka kb bd b be z ek">Nearly 200,000 lines of C code. Surely there are some juicy bugs in here!</figcaption></figure><p id="8dc8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这篇文章的剩余部分，我首先描述导致漏洞的条件。接下来，我将讨论开发人员应该注意的CPython运行时的一些奇怪之处，然后我将介绍实际的开发。最后，我总结了在Python应用程序中量化内存损坏风险的想法。</p><h1 id="2fb0" class="ks kt hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">漏洞</h1><p id="aa47" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">我要介绍的漏洞是Numpy v1.11.0(可能还有更老的版本)中的一个整数溢出错误。该问题自1.12.0版以来已得到修复，但没有发布<a class="ae jp" href="https://hackernoon.com/tagged/security" rel="noopener ugc nofollow" target="_blank">安全</a>建议。</p><p id="8edc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该漏洞存在于用于调整Numpy的类似多维数组的对象、<code class="eh lv lw lx ly b">ndarray</code>和朋友的API中。使用定义数组的<em class="lz">形状</em>的元组调用<code class="eh lv lw lx ly b">resize</code>，其中元组的每个元素都是一个维度的大小。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="kq kr l"/></div></figure><p id="719c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="lz">旁注:是的，数组正在泄漏未初始化的内存，但是我们不会在这篇文章中关注这个问题。</em></p><p id="a943" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在幕后，<code class="eh lv lw lx ly b">resize</code>实际上是一个缓冲区，其大小计算为形状元组中每个元素与元素大小的乘积。所以在前面的代码片段中，<code class="eh lv lw lx ly b">arr.resize((2, 3))</code>归结为C代码<code class="eh lv lw lx ly b">realloc(buffer, 2 * 3 * sizeof(int32))</code>。下一个代码片段是用c语言大量解释的<code class="eh lv lw lx ly b">resize</code>实现。</p></div><div class="ab cl kj kk hc kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hn ho hp hq hr"><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="kq kr l"/></div></figure><p id="1ca1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">发现漏洞？您可以在for循环(第13行)中看到，每个维度都被相乘以产生新的大小。稍后(第25行),新大小和元素大小的乘积作为大小传递给保存数组的<code class="eh lv lw lx ly b">realloc</code>内存。在<code class="eh lv lw lx ly b">realloc</code>之前，对新的大小有一些验证，但是它不检查整数溢出，这意味着非常大的维度可能导致分配的数组大小不足。最终，这给了攻击者一个强大的利用原语:通过从溢出大小的数组中进行索引来读取或写入任意内存的能力。</p><p id="397f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们开发一个快速的概念证明来证明bug的存在。</p></div><div class="ab cl kj kk hc kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hn ho hp hq hr"><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="kq kr l"/></div></figure><h1 id="f60c" class="ks kt hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">CPython运行时的古怪之处</h1><p id="5bde" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">在我们开始开发漏洞利用之前，我想讨论一下CPython运行时简化漏洞利用的一些方法，以及它挫败漏洞利用开发人员的一些方法。如果您想直接研究这个漏洞，请随意跳过这一部分。</p><h2 id="0783" class="ma kt hu bd ku mb mc md ky me mf mg lc jc mh mi lg jg mj mk lk jk ml mm lo mn dt translated">泄漏内存地址</h2><p id="cacf" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">通常，漏洞利用必须解决的第一个障碍是挫败地址空间布局随机化(ASLR)。对攻击者来说幸运的是，Python让这变得很容易。内置的<code class="eh lv lw lx ly b">id</code>函数返回一个对象的内存地址，或者更准确地说是封装该对象的<code class="eh lv lw lx ly b">PyObject</code>结构的地址。</p></div><div class="ab cl kj kk hc kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hn ho hp hq hr"><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="kq kr l"/></div></figure><p id="b757" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在现实世界的应用程序中，开发者应该确保不向用户公开<code class="eh lv lw lx ly b">id(object)</code>。在沙盒环境中，你对这种行为无能为力，也许除了将<code class="eh lv lw lx ly b">id</code>列入黑名单或者重新实现<code class="eh lv lw lx ly b">id</code>来返回散列。</p><h2 id="55ce" class="ma kt hu bd ku mb mc md ky me mf mg lc jc mh mi lg jg mj mk lk jk ml mm lo mn dt translated">了解内存分配行为</h2><p id="033d" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">理解您的分配器对于编写漏洞是至关重要的。Python根据对象类型和大小有不同的分配策略。让我们看看我们的大字符串<code class="eh lv lw lx ly b">0xa52cd0</code>、小字符串<code class="eh lv lw lx ly b">0x7ffff7f65848</code>和numpy数组<code class="eh lv lw lx ly b">0x7ffff7e777b0</code>在哪里着陆。</p></div><div class="ab cl kj kk hc kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hn ho hp hq hr"><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="kq kr l"/></div><figcaption class="jy jz fg fe ff ka kb bd b be z ek">Big string is in the regular heap. Small string and numpy array are in separate mmap’d regions.</figcaption></figure><h2 id="bcdd" class="ma kt hu bd ku mb mc md ky me mf mg lc jc mh mi lg jg mj mk lk jk ml mm lo mn dt translated">Python对象结构</h2><p id="76ef" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">泄漏和破坏Python对象元数据可能非常强大，因此了解Python对象是如何表示的非常有用。在幕后，Python对象都源自<code class="eh lv lw lx ly b">PyObject</code>，这是一个包含引用计数和对象实际类型描述符的结构。值得注意的是，类型描述符包含许多字段，包括函数指针，这对于读取或重写是很有用的。</p><p id="0c4f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们检查一下我们在上一节中创建的小字符串。</p></div><div class="ab cl kj kk hc kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hn ho hp hq hr"><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="kq kr l"/></div><figcaption class="jy jz fg fe ff ka kb bd b be z ek">Lots of useful fields to read or write —type pointer, function pointers, data pointers, sizes, and more.</figcaption></figure><h2 id="4ec6" class="ma kt hu bd ku mb mc md ky me mf mg lc jc mh mi lg jg mj mk lk jk ml mm lo mn dt translated">伪装成1999年的样子</h2><p id="8d0d" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">ctypes 库是Python和C代码之间的桥梁。它提供C兼容的数据类型，并允许调用dll或共享库中的函数。许多具有C绑定或需要调用共享库的模块需要导入ctypes。</p><p id="3db4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我注意到导入ctypes会导致映射一个4K大小的内存区域，并设置读/写/执行权限。如果这还不明显的话，这意味着攻击者甚至不需要编写ROP链。假设您已经定位了RWX区域，那么利用bug就像将指令指针指向您的外壳代码一样简单。</p><p id="55b9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">自己测试一下吧！</p></div><div class="ab cl kj kk hc kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hn ho hp hq hr"><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="kq kr l"/></div></figure><p id="bac8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过进一步的调查，我发现<a class="ae jp" href="http://www.chiark.greenend.org.uk/doc/libffi-dev/html/The-Closure-API.html" rel="noopener ugc nofollow" target="_blank"> libffi的闭包API </a>负责<a class="ae jp" href="https://github.com/libffi/libffi/blob/master/src/closures.c#L762" rel="noopener ugc nofollow" target="_blank">RWX区域的</a>。但是，在某些平台上不能为该区域分配RWX，例如带有selinux enforced或PAX mprotect enabled的系统，有代码可以解决这一限制。</p><p id="c24c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我没有花太多时间来尝试可靠地定位RWX映射，但理论上，如果您有一个任意读取的漏洞利用原语，这应该是可能的。当ASLR应用于库时，动态链接器以可预测的顺序映射库的区域。库的区域包括库和代码本身私有的全局变量。Libffi将对RWX区域的引用存储为一个全局。例如，如果您在堆上找到一个指向libffi函数的指针，那么您可以预先计算RWX区域指针的地址，作为libffi函数指针地址的偏移量。需要为每个库版本调整偏移量。</p><h2 id="2873" class="ma kt hu bd ku mb mc md ky me mf mg lc jc mh mi lg jg mj mk lk jk ml mm lo mn dt translated">事实上的漏洞缓解</h2><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff mo"><img src="../Images/f544d145159996cfe8593741afd5d665.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*v8q9I9UQOAja28l0nEo_0Q.jpeg"/></div></figure><p id="affb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我在Ubuntu 14.04.5和16.04.1上测试了Python2.7二进制文件的安全相关编译器标志。有几个弱点对攻击者非常有用:</p><ul class=""><li id="4b62" class="mp mq hu it b iu iv iy iz jc mr jg ms jk mt jo mu mv mw mx dt translated">Partial RELRO:可执行文件的<a class="ae jp" href="https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html" rel="noopener ugc nofollow" target="_blank">get部分</a>，包含指向动态链接到二进制文件的库函数的指针，是可写的。例如，漏洞利用可以用<code class="eh lv lw lx ly b">system()</code>替换<code class="eh lv lw lx ly b">printf()</code>的地址。</li><li id="29bc" class="mp mq hu it b iu my iy mz jc na jg nb jk nc jo mu mv mw mx dt translated">没有馅饼:二进制文件不是独立于位置的可执行文件，这意味着当内核将ASLR应用于大多数内存映射时，二进制文件本身的内容被映射到静态地址。因为GOT部分是二进制文件的一部分，所以没有PIE可以让攻击者更容易地定位和写入GOT。</li></ul><h2 id="2777" class="ma kt hu bd ku mb mc md ky me mf mg lc jc mh mi lg jg mj mk lk jk ml mm lo mn dt translated">路障</h2><p id="c0b6" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">虽然CPython是一个为漏洞开发者准备的充满工具的环境，但是有一些力量破坏了我的许多漏洞尝试，并且很难调试。</p><ul class=""><li id="ca16" class="mp mq hu it b iu iv iy iz jc mr jg ms jk mt jo mu mv mw mx dt translated">如果您不小心破坏对象元数据，垃圾收集器、类型系统以及可能的其他未知力量将会破坏您的漏洞。</li><li id="88a5" class="mp mq hu it b iu my iy mz jc na jg nb jk nc jo mu mv mw mx dt translated"><code class="eh lv lw lx ly b">id()</code>可以靠不住。出于我无法确定的原因，Python有时会在使用原始对象时传递对象的副本。</li><li id="cd88" class="mp mq hu it b iu my iy mz jc na jg nb jk nc jo mu mv mw mx dt translated">分配对象的区域有些不可预测。出于我无法确定的原因，某些编码模式导致在<code class="eh lv lw lx ly b">brk</code>堆中分配缓冲区，而其他模式导致在特定于python的<code class="eh lv lw lx ly b">mmap</code>堆中分配缓冲区。</li></ul><h1 id="a700" class="ks kt hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">利用</h1><p id="76f2" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">在发现numpy整数溢出后不久，我向bug bounty提交了一份报告，提供了劫持指令指针的概念证明，但没有注入任何代码。当我最初提交时，我没有意识到PoC实际上相当不可靠，并且我无法在他们的服务器上正确地测试它，因为验证指令指针的劫持需要访问核心转储或调试器。供应商承认这个问题的合法性，但是他们给的奖励没有我第一份报告给的多。</p><p id="ac0e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">很公平！</p><p id="a2a5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我不是一个真正的漏洞开发者，但我挑战自己做得更好。经过反复试验，我终于写出了一个看起来可靠的漏洞。不幸的是，我从来没有能够在供应商的沙箱中测试它，因为他们在我完成之前更新了numpy，但是当在Python解释器中进行本地测试时，它确实可以工作。</p><p id="396d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在高级别上，该漏洞利用通过溢出numpy数组的大小来获得任意读/写漏洞利用原语。该原语用于将<code class="eh lv lw lx ly b">system</code>的地址写入<code class="eh lv lw lx ly b">fwrite</code>的GOT/PLT条目。最后，Python的内置<code class="eh lv lw lx ly b">print</code>在幕后调用<code class="eh lv lw lx ly b">fwrite</code>，所以现在你可以调用<code class="eh lv lw lx ly b">print '/bin/sh'</code>来获得一个shell，或者用任何命令替换/bin/sh。</p><p id="92cb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了高层次的解释之外，还有更多的东西，所以请查看下面的完整漏洞利用。我建议从下往上开始阅读，包括评论。如果您使用的是不同版本的Python，请在运行之前调整<code class="eh lv lw lx ly b">fwrite</code>和<code class="eh lv lw lx ly b">system</code>的get位置。</p></div><div class="ab cl kj kk hc kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hn ho hp hq hr"><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="kq kr l"/></div></figure><p id="3790" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">运行漏洞会给你一个“被黑”的外壳。</p></div><div class="ab cl kj kk hc kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hn ho hp hq hr"><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="kq kr l"/></div><figcaption class="jy jz fg fe ff ka kb bd b be z ek">If you are not running Python 2.7.12, see comments inside the exploit for how to make it work for your Python version.</figcaption></figure><h1 id="0c92" class="ks kt hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">量化风险</h1><p id="f456" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">众所周知，Python的大部分核心和许多第三方模块都是C代码的薄薄的包装。可能较少被认识到的事实是，在流行的Python模块中，内存损坏错误总是被报告，甚至没有CVE、安全建议，甚至在发行说明中没有提到安全修复。</p><p id="41e7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以没错，Python模块里有很多内存崩溃的bug。当然不是所有的都可以利用，但是你必须从某个地方开始。为了解释内存损坏错误带来的风险，我发现用两个不同的用例来组织对话是有帮助的:常规Python应用程序和沙箱化不可信代码。</p><h2 id="0683" class="ma kt hu bd ku mb mc md ky me mf mg lc jc mh mi lg jg mj mk lk jk ml mm lo mn dt translated">常规应用</h2><p id="0009" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">我们关注的应用程序类型是那些具有有意义的攻击面的应用程序。想想web应用程序和其他面向网络的服务，处理不可信内容的客户端应用程序，特权系统服务等。这些应用程序中的许多都从项目中导入了针对堆积如山的C代码构建的Python模块，而这些项目并没有将它们的内存损坏错误视为安全问题。这种纯粹的想法可能会让一些安全专业人员夜不能寐，但在现实中，这种风险通常被淡化或忽略。我怀疑有几个原因:</p><ul class=""><li id="5774" class="mp mq hu it b iu iv iy iz jc mr jg ms jk mt jo mu mv mw mx dt translated">远程识别和利用内存损坏问题的难度非常高，尤其是对于闭源和远程应用程序。</li><li id="bd88" class="mp mq hu it b iu my iy mz jc na jg nb jk nc jo mu mv mw mx dt translated">应用程序暴露不受信任的输入到达易受攻击的函数的路径的可能性可能非常低。</li><li id="e0cd" class="mp mq hu it b iu my iy mz jc na jg nb jk nc jo mu mv mw mx dt translated">意识很低，因为Python模块中的内存损坏错误通常不作为安全问题来跟踪。</li></ul><p id="826b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">公平地说，由于某个随机Python模块中的缓冲区溢出而受到危害的可能性很低。但话说回来，内存损坏缺陷一旦发生，可能会造成极大的破坏。有时甚至不需要任何人明确地利用它们来造成伤害。更糟糕的是，当库维护者不考虑安全方面的内存损坏问题时，几乎不可能给库打补丁。</p><p id="646e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您开发了一个主要的Python应用程序，我建议您至少清点一下正在使用的Python模块。尝试找出您的模块对C代码的依赖程度，并分析本机代码暴露在应用程序边缘的可能性。</p><h2 id="b55b" class="ma kt hu bd ku mb mc md ky me mf mg lc jc mh mi lg jg mj mk lk jk ml mm lo mn dt translated">沙盒</h2><p id="2617" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">有许多服务允许用户在沙箱中运行不受信任的Python代码。操作系统级沙盒特性，如linux命名空间和seccomp，只是最近才以Docker、LXC等形式流行起来。不幸的是，较弱的沙盒技术今天仍在使用——以chroot jails的形式出现在操作系统层，或者更糟的是，沙盒可以完全在Python中完成(参见<a class="ae jp" href="http://doc.pypy.org/en/latest/sandbox.html" rel="noopener ugc nofollow" target="_blank"> pypy-sandbox </a>和<a class="ae jp" href="https://github.com/haypo/pysandbox" rel="noopener ugc nofollow" target="_blank"> pysandbox </a>)。</p><p id="5d95" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">内存损坏错误完全破坏了沙盒，而沙盒不是由操作系统强制执行的。执行Python代码子集的能力使得利用比在常规应用程序中更可行。甚至pypy-sandbox也可能被缓冲区溢出破坏，pypy-sandbox声称是安全的，因为它的双进程模型虚拟化了系统调用。</p><p id="f434" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您想运行任何类型的不受信任的代码，请努力构建一个安全的操作系统和网络架构来保护它。</p><div class="jr js jt ju fq ab cb"><figure class="nd jv ne nf ng nh ni paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nd jv ne nf ng nh ni paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nd jv ne nf ng nh ni paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="nj nk nl"><p id="f922" class="ir is lz it b iu iv iw ix iy iz ja jb nm jd je jf nn jh ji jj no jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is lz it b iu iv iw ix iy iz ja jb nm jd je jf nn jh ji jj no jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff np"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="nq kr l"/></div></figure></div></div>    
</body>
</html>