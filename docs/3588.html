<html>
<head>
<title>Is it possible to sort an array faster than O(n*log(n)) time?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有可能比O(n*log(n))时间更快地对数组排序吗？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/is-it-possible-to-sort-an-array-faster-than-o-n-log-n-time-a053b942c5fe?source=collection_archive---------13-----------------------#2017-04-10">https://medium.com/hackernoon/is-it-possible-to-sort-an-array-faster-than-o-n-log-n-time-a053b942c5fe?source=collection_archive---------13-----------------------#2017-04-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="e519" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个问题可能出现在每个曾经接触过<strong class="it hv">算法设计和分析的人的脑海中。</strong>通常我们假设对n元素数组进行排序的最佳时间是O(n*log(n))，事实证明这个假设也是可以证明的。</p><p id="265f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">事实证明，当我们将自己限制在基于比较数组元素的<strong class="it hv">排序算法时，这<strong class="it hv">是不可能的</strong>。<br/>时间复杂度的下限可以通过将排序视为一个<strong class="it hv">过程</strong>来证明，其中数组中两个元素的每次比较都会给出更多关于其内容的<a class="ae jp" href="https://hackernoon.com/tagged/information" rel="noopener ugc nofollow" target="_blank">信息</a>。我们可以把这个过程想象成一个树形结构的子过程链。</strong></p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff jq"><img src="../Images/74ad295fe5360f5f23b61083d090284c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*ox_RYNFv-hyyGuf4WkGM-Q.jpeg"/></div></figure><p id="21a5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们假设“x &lt; y ?” means that some elements x and y in the array are compared. This expression if true evaluates that the process continues to the left, and otherwise to the right. The results of the process are the possible ways to sort the array and this amounts to n! possible ways.</p><p id="b443" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">1+ 2+ 3+ 4+ 5+……+n sub-processes = n! ways.</p><p id="dca4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Now, taking log2 on both the sides-</p><p id="8f34" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> log2(1)+ log2(2)+ log2(3)+..+ log2(n) = log2(n！)</strong></p><p id="b6dc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们选择最后的n/2个元素，并将每个元素的值修改为log2(n /2 ),因此我们可以将上面的表达式写成<br/> <strong class="it hv"> log2(n！)≥ (n /2) * log2(n /2) </strong></p><p id="5c77" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以树的高度和最坏情况下排序算法中的最小可能步骤数至少是n *log(n)。</p><p id="6015" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，我们以简化的方式将上述计算总结如下</p><p id="0833" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们有一个高度为log(n)的流程树，由于总数组大小为n，因此在每一层我们至少要做n项工作。将这两者结合起来，我们可以得到对数组排序的总n*log(n)步数。</p><p id="2e88" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">参考:竞技程序员<a class="ae jp" href="https://hackernoon.com/tagged/handbook" rel="noopener ugc nofollow" target="_blank">手册</a></p><div class="jr js jt ju fq ab cb"><figure class="jy jv jz ka kb kc kd paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="jy jv jz ka kb kc kd paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="jy jv jz ka kb kc kd paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ke kf kg"><p id="f922" class="ir is kh it b iu iv iw ix iy iz ja jb ki jd je jf kj jh ji jj kk jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是T21家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is kh it b iu iv iw ix iy iz ja jb ki jd je jf kj jh ji jj kk jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff kl"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="kq kr l"/></div></figure></div></div>    
</body>
</html>