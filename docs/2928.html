<html>
<head>
<title>Your Guide to testing in Ruby on Rails 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby on Rails 5测试指南</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/your-guide-to-testing-in-ruby-on-rails-5-c8bd122e38ad?source=collection_archive---------1-----------------------#2017-03-01">https://medium.com/hackernoon/your-guide-to-testing-in-ruby-on-rails-5-c8bd122e38ad?source=collection_archive---------1-----------------------#2017-03-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/33709e7891bad81f574a126cb762655b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*93IwLs7qo_Xw-Rj2vKFLkg.png"/></div></div></figure><p id="ce77" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意:这篇文章来自我即将出版的书<a class="ae ka" href="https://buildasaasappinrails.com" rel="noopener ugc nofollow" target="_blank">中的一个样本章节，在Rails 6 </a>中构建一个SaaS应用。这本书指导你从卑微的开始，通过部署一个应用到生产。这本书现在已经开始预售了，你可以马上拿到免费的一章！</p><p id="c0fd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另外，我的新项目<a class="ae ka" href="https://pullmanager.com" rel="noopener ugc nofollow" target="_blank">的测试版已经发布了。如果你失去了对拉取请求的跟踪，让旧的请求留在身边，或者只是喜欢一个通过多个服务(Github、Gitlab和Bitbucket)聚集这些请求的仪表板，</a><a class="ae ka" href="https://pullmanager.com" rel="noopener ugc nofollow" target="_blank">查看一下</a>。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><p id="8311" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">测试，虽然需要更多一点的认知负荷，甚至被一些开发人员所厌恶，但通常会在以后得到回报。在某些时候，你几乎总是会说“我很高兴我为此写了测试”。TDD(测试驱动开发)是Rails社区发展起来的一种方法。虽然，没有完全被社区中的所有人接受。这种方法让您首先编写测试，然后编写代码使您的测试通过。</p><h1 id="cce8" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">为什么要测试</h1><p id="2782" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">当测试正确进行时，它将提供一些主要的好处。首先，它将帮助你开发应用程序中的行为。您可以编写一个测试，验证您的模型是否存在电子邮件。然后意识到您需要验证密码或者添加一个“重新输入密码”输入框。</p><p id="5487" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">测试的另一个重要原因是在修改代码或添加新特性时保护自己免受应用程序中的退化。当您重构类、折叠代码或删除无关代码时，这也将给你信心和保证。如果笔试在修改前后都通过了，你就可以开始了！另一种测试方法是在发现应用程序中的问题或错误后编写测试。确保修复有效，并且不会在将来困扰您的应用程序。</p><h1 id="a9be" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">测试框架</h1><p id="e10a" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">像Rails的许多其他部分一样，也有默认的gem和库。以及其他可选的替代项，它们有时比缺省值更常用。</p><p id="ce07" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> RSpec vs MiniTest </strong></p><p id="a39a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从Rails的最新版本开始，默认的测试框架是MiniTest。这本身就是对Rails Test::Unit的原始测试框架的改进。在选择Rails应用程序的许多方面时，个人偏好可以发挥很大的作用。测试也不例外。</p><p id="930e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">MiniTest的最大替代品是RSpec。关注测试的可读性和可组合性。当命名测试和测试组时，它使用诸如“描述”和“它”这样的词。例如:</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="e6d2" class="lu kj hu lq b fv lv lw l lx ly">describe “the test” do</span><span id="2bba" class="lu kj hu lq b fv lz lw l lx ly">  it “is a success” do</span><span id="615d" class="lu kj hu lq b fv lz lw l lx ly">    expect(1).to eq(1)</span><span id="10b2" class="lu kj hu lq b fv lz lw l lx ly">  end</span><span id="d564" class="lu kj hu lq b fv lz lw l lx ly">end</span></pre><p id="0829" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">而MiniTest将使用其他编程测试框架中的资产术语。就我个人而言，我喜欢RSpec，觉得它更容易推理，而且命令行界面(CLI)也更好一些。</p><p id="d474" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">水豚特征测试vs综合测试</strong></p><p id="78f2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">测试工作中另一个值得注意的选择是增加了水豚。虽然您可以使用内置集成测试来测试工作流。它让人们对现实世界的浏览器工作流有了更多的渴望。这就是水豚的用武之地。允许您编写功能测试，引导您在应用程序中选择页面。执行行为，如点击、填写表格或验证一切正常。</p><p id="3912" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Capybara直接插入RSpec，允许您使用相同的语法和措辞来编写测试。这是一个来自他们文档的例子！</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="00d6" class="lu kj hu lq b fv lv lw l lx ly">describe “the signin process”, :type =&gt; :feature do<br/> before :each do<br/>   User.make(email: ‘user@example.com’, password: ‘password’)<br/> end</span><span id="7cd8" class="lu kj hu lq b fv lz lw l lx ly"> it “signs me in” do<br/>   visit ‘/sessions/new’<br/>   within(“#session”) do<br/>     fill_in ‘Email’, with: ‘user@example.com’<br/>     fill_in ‘Password’, with: ‘password’<br/>   end<br/>   click_button ‘Sign in’<br/>   expect(page).to have_content ‘Success’<br/> end<br/>end</span></pre><p id="6775" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> FactoryGirl </strong></p><p id="067b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我要提到的最后一个选择是gem FactoryGirl。Rails中测试对象的默认方法是fixtures。夹具文件是以YAML格式编写的。提供基本的静态模拟对象表示。随着模型对象变得越来越复杂，夹具会变得越来越难。包括他们的社团激增。FactoryGirl将自己描述为创建测试对象的API。也就是说，您将通过编程使用API为您的测试创建模拟对象。你可以在Ruby中提供一个工厂定义，然后像普通对象一样使用API来`. build '或`. create`。factory girl还使得通过工厂定义包含关联变得非常简单。</p><h1 id="c51d" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">测试类型</h1><p id="e9b4" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">在典型的Rails应用程序中，有三种主要的测试类型。模型(单元)测试、控制器测试和视图测试。此外，您还可以使用功能测试。这些测试将作为应用程序的端到端演练测试。每种类型的测试在测试世界中都有它的位置，并且可能同等重要。</p><h1 id="d249" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">模型/单元测试</h1><p id="279e" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">模型规格很可能是您将在Rails中处理的最简单的测试类型。通过这些测试，您正在测试模型对象上的普通CRUD(创建/读取/更新/删除)操作。此外，他们将测试验证和/或关联。模型规格通常会运行得非常快，并且相当独立</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="1406" class="lu kj hu lq b fv lv lw l lx ly">FactoryGirl.define do</span><span id="dfb6" class="lu kj hu lq b fv lz lw l lx ly">  factory :user do</span><span id="4de7" class="lu kj hu lq b fv lz lw l lx ly">    name “Same Name”</span><span id="9c68" class="lu kj hu lq b fv lz lw l lx ly">    email “test@user.com”</span><span id="eb30" class="lu kj hu lq b fv lz lw l lx ly">  end</span><span id="7437" class="lu kj hu lq b fv lz lw l lx ly">end</span><span id="75ee" class="lu kj hu lq b fv lz lw l lx ly">class User &lt; ApplicationRecord</span><span id="0efc" class="lu kj hu lq b fv lz lw l lx ly">  validates :email, presence: true<br/>  validates :email, uniqueness: true<br/>  validates :name, presence: true</span><span id="a4f6" class="lu kj hu lq b fv lz lw l lx ly">…</span><span id="e461" class="lu kj hu lq b fv lz lw l lx ly">describe User do</span><span id="b805" class="lu kj hu lq b fv lz lw l lx ly">  it “has a valid factory” do</span><span id="92c3" class="lu kj hu lq b fv lz lw l lx ly">    expect(FactoryGirl.build(:user).save).to be_true</span><span id="9587" class="lu kj hu lq b fv lz lw l lx ly">  end</span><span id="39fe" class="lu kj hu lq b fv lz lw l lx ly">  it “is invalid without a name” do</span><span id="126d" class="lu kj hu lq b fv lz lw l lx ly">    expect(FactoryGirl.build(:user, name: nil).save).to be_false</span><span id="cde7" class="lu kj hu lq b fv lz lw l lx ly">  end</span><span id="d1da" class="lu kj hu lq b fv lz lw l lx ly">  it “is invalid without a unique name” do</span><span id="4de5" class="lu kj hu lq b fv lz lw l lx ly">    user = FactoryGirl.create(:user)</span><span id="5d69" class="lu kj hu lq b fv lz lw l lx ly">    expect(FactoryGirl.build(:user, name: “Same Name”)).to be_false</span><span id="a8e1" class="lu kj hu lq b fv lz lw l lx ly">  end</span><span id="459f" class="lu kj hu lq b fv lz lw l lx ly">  it “is invalid without an email” do</span><span id="e824" class="lu kj hu lq b fv lz lw l lx ly">    expect(FactoryGirl.build(:user, email: nil)).to be_false</span><span id="2533" class="lu kj hu lq b fv lz lw l lx ly">  end</span><span id="2c9a" class="lu kj hu lq b fv lz lw l lx ly">end</span></pre><p id="1384" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于这个例子，有一个已经有效的用户工厂定义，它正在设置一些默认值。这个特定的场景是测试用户模型是否可以创建用户。然后在这个用户模型的几个关键Rails模型验证器上验证用户创建失败。</p><h1 id="20d2" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">控制器测试</h1><p id="42b2" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">当涉及到测试你所有的条件逻辑时，控制器测试将是你的面包和黄油。测试基于请求类型、用户类型、模型的成功/失败等等。控制器规格比模型规格稍慢一些，因为它们使用了请求/响应周期。尽管仍然比功能规格快得多。这使得它成为进行大量测试的好地方。</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="0bde" class="lu kj hu lq b fv lv lw l lx ly">describe UsersController do</span><span id="f6f4" class="lu kj hu lq b fv lz lw l lx ly">  describe “GET index” do</span><span id="d4d3" class="lu kj hu lq b fv lz lw l lx ly">    it “assigns @users” do</span><span id="777b" class="lu kj hu lq b fv lz lw l lx ly">      user = FactoryGirl.create(:user)</span><span id="670c" class="lu kj hu lq b fv lz lw l lx ly">      get :index</span><span id="8fef" class="lu kj hu lq b fv lz lw l lx ly">      expect(assigns(:users)).to eq([user])</span><span id="5afd" class="lu kj hu lq b fv lz lw l lx ly">    end</span><span id="69d2" class="lu kj hu lq b fv lz lw l lx ly">    it “renders the index template” do</span><span id="6791" class="lu kj hu lq b fv lz lw l lx ly">      get :index</span><span id="9539" class="lu kj hu lq b fv lz lw l lx ly">      expect(response).to render_template(“index”)</span><span id="c208" class="lu kj hu lq b fv lz lw l lx ly">    end</span><span id="7779" class="lu kj hu lq b fv lz lw l lx ly">  end</span><span id="1f9a" class="lu kj hu lq b fv lz lw l lx ly">  describe “GET #show” do</span><span id="046b" class="lu kj hu lq b fv lz lw l lx ly">    it “renders the #show view” do</span><span id="5568" class="lu kj hu lq b fv lz lw l lx ly">      get :index, {id:user.id}</span><span id="324e" class="lu kj hu lq b fv lz lw l lx ly">      response.should render_template :show</span><span id="99be" class="lu kj hu lq b fv lz lw l lx ly">    end</span><span id="4665" class="lu kj hu lq b fv lz lw l lx ly">  end</span><span id="d64b" class="lu kj hu lq b fv lz lw l lx ly"> end</span><span id="7fbe" class="lu kj hu lq b fv lz lw l lx ly">end</span></pre><p id="78d8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这个测试文件中，您会发现我们正在测试一个列出用户的页面。首先，测试动作分配正确的输出。在创建一个用户并获得:index操作之后，控制器将拥有一个实例变量，该变量等于来自测试的一个用户的数组。第二个测试是简单地测试获取:index动作是否会呈现索引模板。</p><p id="c984" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">显然，这些测试并不复杂，只是为了让您体验一下控制器测试有多简单。在真实世界的控制器文件中，您将测试每个动作。测试其行为和渲染。以及操作的每个分支，如数据库事务的成功或失败。</p><h1 id="0242" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">查看测试</h1><p id="9d0d" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">在特性测试中测试视觉表现的所有方面的开发人员经常忽略视图规格。特性测试意味着给你高层次的行为测试。然而，它们绝对不应该用来测试服务器渲染模板的每一个细节。很多时候，您需要基于某种if语句或逻辑来测试不同的标记，这可以在视图规范中完成。</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="05bf" class="lu kj hu lq b fv lv lw l lx ly">FactoryGirl.define do</span><span id="acd4" class="lu kj hu lq b fv lz lw l lx ly">  factory :user do<br/>    name “Same Name”<br/>    email “<a class="ae ka" href="mailto:test@user.com" rel="noopener ugc nofollow" target="_blank">test@user.com</a>”<br/>    admin false<br/>  end</span><span id="3aa9" class="lu kj hu lq b fv lz lw l lx ly">end</span><span id="7130" class="lu kj hu lq b fv lz lw l lx ly">&lt;%- if @user.admin? %&gt;</span><span id="9747" class="lu kj hu lq b fv lz lw l lx ly">  &lt;h1&gt;Welcome back admin&lt;/h1&gt;</span><span id="e46a" class="lu kj hu lq b fv lz lw l lx ly">&lt;%- else %&gt;</span><span id="2de5" class="lu kj hu lq b fv lz lw l lx ly">  &lt;h1&gt;Welcome back pal&lt;/h1&gt;</span><span id="fed5" class="lu kj hu lq b fv lz lw l lx ly">&lt;%- end %&gt;</span><span id="260a" class="lu kj hu lq b fv lz lw l lx ly">describe “rendering homepage” do</span><span id="7e83" class="lu kj hu lq b fv lz lw l lx ly">  it “displays admin message” do</span><span id="0afe" class="lu kj hu lq b fv lz lw l lx ly">    assign(:user, FactoryGirl.create(:user, admin: true))</span><span id="8f6a" class="lu kj hu lq b fv lz lw l lx ly">    render :template =&gt; “home/index.html.erb”</span><span id="a053" class="lu kj hu lq b fv lz lw l lx ly">    expect(rendered).to match /admin/</span><span id="690b" class="lu kj hu lq b fv lz lw l lx ly">  end</span><span id="7933" class="lu kj hu lq b fv lz lw l lx ly">  it “displays regular user message” do</span><span id="7b75" class="lu kj hu lq b fv lz lw l lx ly">    assign(:user, FactoryGirl.create(:user))</span><span id="22b0" class="lu kj hu lq b fv lz lw l lx ly">    render :template =&gt; “home/index.html.erb”</span><span id="8ed8" class="lu kj hu lq b fv lz lw l lx ly">    expect(rendered).to match /pal/</span><span id="1313" class="lu kj hu lq b fv lz lw l lx ly">  end</span><span id="d5a4" class="lu kj hu lq b fv lz lw l lx ly">end</span></pre><p id="3c3a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这个例子中，我们有一个简单的视图模板，它在标记中呈现一条消息。该名词基于用户变量中引用的用户是否是管理员。在这里，视图规范使用每个测试(一个管理员，一个非管理员)中创建的用户对象呈现消息，并使用正则表达式测试文本。</p><h1 id="c900" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">功能测试</h1><p id="d3df" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">最后，特性规格(测试)是一次性测试整个应用程序(或者大部分行为)的好方法。使用RSpec和Capybara，您将能够编写简单明了的测试，就像您是最终用户一样浏览您的应用程序。</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="6caa" class="lu kj hu lq b fv lv lw l lx ly">describe “Signing Up”, :type =&gt; :feature do</span><span id="41dd" class="lu kj hu lq b fv lz lw l lx ly">it “allows a user to sign up” do<br/> visit root_path</span><span id="233d" class="lu kj hu lq b fv lz lw l lx ly"> expect(page).to have_content ‘Sign Up’<br/> within(“form#user_new”) do</span><span id="eaf6" class="lu kj hu lq b fv lz lw l lx ly">   fill_in ‘Name’, with: ‘John’<br/>   fill_in ‘Email’, with: ‘user@example.com’<br/>   fill_in ‘Password’, with: ‘password’</span><span id="b3b0" class="lu kj hu lq b fv lz lw l lx ly">   fill_in ‘Retype Password’, with: ‘password’<br/> end<br/> click_button ‘Sign Up’<br/> expect(page).to have_content ‘Welcome to Sample App’</span><span id="3da4" class="lu kj hu lq b fv lz lw l lx ly"> expect(page).to have_content ‘John’<br/> end<br/>end</span></pre><p id="81b8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个测试模拟一个用户第一次访问您的应用程序。然后看到一个注册页面，填写完毕，注册后成功访问应用。</p><p id="989f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如你所看到的，特性测试提供了一种令人惊奇的高级测试方式，就像用户与你的应用程序交互一样。然而，随之而来的是事实特性测试的运行速度会比其他类型的测试慢。因此，不测试应用程序中的每个分支或可能性是明智的。使用控制器或其他规格来测试边缘情况。</p><h1 id="8a59" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">其他测试工具</h1><p id="83d9" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">此外，我还想介绍一些额外的工具，它们将包含在您的应用程序的代码库中。这些工具将有助于解决诸如测试清理这样的问题。另一个是测试覆盖完整性工具，它包括一个本地web工具来逐个文件地查看分析。最后，是一个很容易模仿外部资源的工具，比如第三方API。</p><p id="a0d4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">数据库清理器(Database Cleaner):数据库清理器是一个测试工具，它允许你在每次测试后使用不同的策略将数据库清理到干净的状态。这里的重要性在于，虽然Rails试图将它们的测试包装在事务中。这可以防止一个测试数据库的更改影响另一个测试。然而，当使用javascript驱动程序时，这些测试是在另一个线程中执行的。这意味着您将需要另一种方法来将数据库恢复到原始状态，即使用截断。特别是，数据库清理器将允许你基于测试类型设置“清理”方法。</p><p id="8160" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> Simplecov </strong>:我们将使用这个gem来计算、显示和调查代码覆盖率。这个工具将使用内置的Ruby覆盖信息，以及合并不同工具和测试类型覆盖的结果。之后，它将生成信息，保存到一个报告中，并自动创建一个HTML站点供您浏览代码覆盖率分析。</p><p id="3167" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> VCR </strong> : VCR允许你“记录”HTTP事务，并在本地保存它们的响应。这允许您“回放”来自文件的响应，使得运行与外部资源交互的测试变得容易和快速。随着速度的提高，它允许离线测试，不用担心第三方的改变会影响你的测试。但是，我建议您仍然对实际的外部资源的响应执行某种测试。</p><h1 id="d085" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">CI和你</h1><p id="ba94" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">本章最后要讨论的是持续集成。这意味着您将不断地将变更合并到主分支中，在主分支中，各种管道对新合并的代码进行处理。在大多数情况下，这是一种将变更合并到一个中心分支的方法。然后在外部系统上运行测试，并使用测试结果来选择另一个操作，比如部署或请求对代码库进行修复。</p><p id="5980" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有一些不同的工具可以用于CI。第一个可能在<a class="ae ka" href="http://jenkins.io/" rel="noopener ugc nofollow" target="_blank">詹金斯</a>中推荐。Jenkins的伟大之处在于它是一个开源项目，并且是免费的。但是，他们的网站上没有托管解决方案。也就是说，你要么必须建立和维护你的Jenkins服务器，要么寻找一个能为你做这些的服务。</p><p id="51ac" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于那些不想维护自己的服务器来运行持续集成的人来说，这是一个好消息。有相当多的服务运行CI服务。拥有主要存储库服务的集成墙(GitHub、Bitbucket等)。这意味着对您的存储库的简单推送可以触发您的测试在他们的服务上自动运行。随后是一份用你喜欢的任何反应介质写的结果报告。例如电子邮件、聊天服务等。</p><p id="aac6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在没有任何从属关系的情况下，我的应用程序通常使用的服务器是<a class="ae ka" href="http://circleci.com/" rel="noopener ugc nofollow" target="_blank"> CircleCI </a>。我发现它们的易用性和价格(对我来说是免费的)很好地满足了我的需求。其他选择还有<a class="ae ka" href="https://travis-ci.org/" rel="noopener ugc nofollow" target="_blank"> TravisCI </a>和<a class="ae ka" href="https://semaphoreci.com/" rel="noopener ugc nofollow" target="_blank">semaphoresci</a>。我建议检查一下这些产品，选择最适合你的。</p><div class="ll lm ln lo fq ab cb"><figure class="ma iv mb mc md me mf paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="ma iv mb mc md me mf paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="ma iv mb mc md me mf paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mg mh mi"><p id="f922" class="jc jd mj je b jf jg jh ji jj jk jl jm mk jo jp jq ml js jt ju mm jw jx jy jz hn dt translated"><a class="ae ka" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ka" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ka" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ka" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd mj je b jf jg jh ji jj jk jl jm mk jo jp jq ml js jt ju mm jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ka" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ka" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ll lm ln lo fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mn"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>