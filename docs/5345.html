<html>
<head>
<title>Swift Codability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快速编码能力</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/swift-codability-d0d232065cad?source=collection_archive---------11-----------------------#2017-07-21">https://medium.com/hackernoon/swift-codability-d0d232065cad?source=collection_archive---------11-----------------------#2017-07-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="85f1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尝试过在swift中解析JSON吗？我知道！没错，大量的样板文件和大量的零支票让这种体验变得非常糟糕。</p><p id="9885" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我在这里为您提供一个新推出的Swift 4解决这个问题的方案，有了它，苹果终于毫无痛苦地回答了解析JSON的问题。</p><h1 id="95f4" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">让我们从基础开始</h1><p id="be30" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">让我们看一个基本的JSON结构</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="3f50" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的swift映射模型将如下所示:</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="8603" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了将这些JSON数据转换成我们的模型，这就是我们需要编写的全部代码</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="19c8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您也可以将这个模型编码到JSON中</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="9393" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">太好了！！不是吗？</p><p id="7b8d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我已经将Person模型标记为可编码的，它是两个单向协议的组合。所以，如果你只想编码或解码，你可以采用适当的协议。</p><p id="dfcb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，<code class="eh kz la lb lc b">Codable</code>带有默认实现，您可以采用这个协议来获得<strong class="it hv">的免费实现。</strong></p><p id="5616" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有一个陷阱！<br/>模型中的变量名应该与JSON中的键名相匹配。</p><p id="8a2b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">哇…生活是不公平的，大多数API都是基于蛇的案例命名的😢。好吧，放松…</p><h1 id="c8f4" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">使用自定义键名</h1><p id="968d" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">键名由编译器在符合<code class="eh kz la lb lc b">CodingKey</code>协议的<code class="eh kz la lb lc b">CodingKeys</code>枚举中自动生成。它定义了我们如何将一个属性与一个值联系起来。</p><p id="8560" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，要定制密钥，我们必须编写自己的<code class="eh kz la lb lc b">CodingKeys</code>实现，在那里我们可以为您想要更改的密钥提供<code class="eh kz la lb lc b">String</code>值。</p><p id="9d0c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们举个例子，考虑这个JSON</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="ee81" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是我们的模型的样子</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="dfdb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">嗯，就是这样👍🏻</p><p id="6244" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Swift Encoder &amp; Decoder使用这个<code class="eh kz la lb lc b">CodingKeys</code> enum作为查找，并将相应的JSON键匹配到模型变量。</p><blockquote class="ld le lf"><p id="9569" class="ir is lg it b iu iv iw ix iy iz ja jb lh jd je jf li jh ji jj lj jl jm jn jo hn dt translated">此外，由于<code class="eh kz la lb lc b">String</code>枚举被隐式地赋予原始值作为每个案例的名称，我们只需要为有问题的案例提供原始值。</p></blockquote><p id="776b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是等等，对象或包装呢？</p><h1 id="2fa9" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">对象和包装</h1><p id="5fa3" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">假设我们的JSON是</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="49e3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这里，你必须确保你的<code class="eh kz la lb lc b">Film</code>对象也符合<code class="eh kz la lb lc b">Codable</code>，基本上就是这样。来，看一看。</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="78f0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">根级数组呢？任何简单的解码方法，如果我们的JSON被包装在一个数组中。\_(ツ)_/以这个JSON为例。</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="7535" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你只需要写这个，</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="771d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt">😬</p><h1 id="2ef6" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">如何处理日期？</h1><p id="e468" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">好吧，让你的生活在一起，^.~</p><p id="8e6e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而在斯威夫特看来，</p><p id="6cd3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为JSON没有表示日期的数据类型，所以这些信息要么以ISO 8601、从参考日期算起的秒数，要么以某种自定义格式进行序列化。然后使用<code class="eh kz la lb lc b">String</code>对其进行处理，并使用DateFormatter将其转换为<code class="eh kz la lb lc b">Date</code>。啊！我知道！！</p><p id="107e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好消息是，现在您可以使用<code class="eh kz la lb lc b">JSONDecoder</code>将JSON中的日期字符串解码到模型中。检查一下</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="778d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kz la lb lc b">Encoder</code>也是如此。除了这些策略，你甚至可以使用定制的编码器和解码器</p><pre class="ks kt ku kv fq lk lc ll lm aw ln dt"><span id="8f43" class="lo jq hu lc b fv lp lq l lr ls">custom((Decoder) throws -&gt; Date)  //For Decoding<br/>custom((Date, Encoder) throws -&gt; Void)  //For Encoding</span></pre><p id="52b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我知道，我知道，举个例子就好了。这里</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><h1 id="ed11" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">处理Swift。数据和网址！！</h1><p id="fd32" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">您可能会在JSON中遇到base64编码字符串形式的<code class="eh kz la lb lc b">Data</code>,为了处理这种情况，<code class="eh kz la lb lc b">JSONEncoder</code>给出了两种策略</p><pre class="ks kt ku kv fq lk lc ll lm aw ln dt"><span id="edb3" class="lo jq hu lc b fv lp lq l lr ls">.base64<br/>.custom((Data, Encoder) throws -&gt; Void)</span></pre><p id="d3ce" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">T4也是如此。</p><p id="b8f5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">到了<code class="eh kz la lb lc b">URL</code>，只需将数据类型从<code class="eh kz la lb lc b">String</code>替换为<code class="eh kz la lb lc b">URL</code>即可</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><h1 id="96a7" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">处理浮点？？</h1><p id="a2af" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">嗯，这并不经常发生，但有时JSON可能包含无效的<strong class="it hv"><em class="lg">【NaN】、“+Infinity”或“-Infinity”</em></strong>。这些在Swift中不被认可！</p><p id="040f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通常，如果您不提供处理这种不一致性的实现，您的解码器将抛出一个错误。只管写</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="c631" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样，这也可以用<code class="eh kz la lb lc b">JSONEncoder</code>来完成。</p><p id="bdff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">等等，但是单向一致性呢？没有默认的实现！我给你看，真的很酷</p><h1 id="630a" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">单向可编码和可解码</h1><p id="6561" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">有时你可能只想遵从<code class="eh kz la lb lc b">Encodable</code>或<code class="eh kz la lb lc b">Decodable</code>并从那里开始工作。但是，在此之前，我们需要理解容器的概念。以下是一些类型的容器:</p><ul class=""><li id="113b" class="lt lu hu it b iu iv iy iz jc lv jg lw jk lx jo ly lz ma mb dt translated"><strong class="it hv">键控容器:</strong>这本质上是一个字典类型，包含键值对。</li><li id="0de7" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo ly lz ma mb dt translated"><strong class="it hv">未加密的容器:</strong>表示一个包装器，本质上是一个数组。</li><li id="0b09" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo ly lz ma mb dt translated"><strong class="it hv">单值容器:</strong>表示由键表示的raw类型。</li></ul><p id="a611" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，你所要做的就是指导编译器你希望数据如何被解码，就这样。看一看</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="d58e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们假设我们有下面的JSON，现在我们可以做一个嵌套模型<strong class="it hv">或者</strong>我们可以这样做:</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="46e4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于电影名和导演名嵌套在一个容器中，我们可以使用decoder的嵌套容器属性来提取值并在相应的键中使用。这里，我将<code class="eh kz la lb lc b">"film"</code>对象提取到<code class="eh kz la lb lc b">filmInfo</code>容器中，然后用它来解码<code class="eh kz la lb lc b">movieName</code>和<code class="eh kz la lb lc b">director</code>键中的值。</p><p id="b2a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">类似地，对于<code class="eh kz la lb lc b">Encoder</code>，我们获取<code class="eh kz la lb lc b">movieName</code>和<code class="eh kz la lb lc b">director</code>键，并在<code class="eh kz la lb lc b">filmInfo</code>容器中对它们进行编码，这将像以前一样返回准确的JSON。这就是编码键的力量。</p><h1 id="d5e3" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">处理字典和枚举？</h1><p id="0123" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">您不经常需要这样做，但是您也可以在字典或枚举中解析您的JSON。</p><h2 id="8ab3" class="lo jq hu bd jr mh mi mj jv mk ml mm jz jc mn mo kd jg mp mq kh jk mr ms kl mt dt translated">词典</h2><p id="016a" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">考虑下面的JSON</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="aeb3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你能找出这些物体之间的相似之处吗？两个<code class="eh kz la lb lc b">"Death Star" &amp; "Millennium Falcon"</code>都在里面嵌套了一个模型。让我们看看我们能对此做些什么</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><h2 id="5caa" class="lo jq hu bd jr mh mi mj jv mk ml mm jz jc mn mo kd jg mp mq kh jk mr ms kl mt dt translated">列举</h2><p id="ed06" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">让我们直接进入这个JSON</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="8f44" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">耶！这是一个奇怪的JSON，但它会做的把戏。让我们看看我们的代码</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="279f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">恭喜你。您已经成功地将JSON解析为枚举案例。</p><h1 id="75ab" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">有一些错误需要处理:)</h1><p id="5303" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">到目前为止，我们所使用的只是一个简单的<code class="eh kz la lb lc b">catch</code>作为灵丹妙药，但是有一些已知的情况，我们可以相应地捕捉和处理。</p><ol class=""><li id="75a1" class="lt lu hu it b iu iv iy iz jc lv jg lw jk lx jo mu lz ma mb dt translated"><strong class="it hv">DecodingError . data corrupted(DecodingError。Context): </strong>如果您收到的数据不是JSON，可能是HTML或API错误，就会出现这种情况。您将使用<code class="eh kz la lb lc b">context</code>获得这些信息。</li><li id="c16a" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo mu lz ma mb dt translated"><strong class="it hv">DecodingError . keynotfound(coding key，DecodingError。Context): </strong>如果在JSON中找不到所需的密钥，就会出现这种情况，<code class="eh kz la lb lc b">CodingKey</code>会给出有问题的密钥，<code class="eh kz la lb lc b">context</code>会给出关于在哪里发生了什么的信息。</li><li id="6920" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo mu lz ma mb dt translated"><strong class="it hv">decodingerror . type mismatch(Any。类型，DecodingError。上下文):</strong>如果键之间的类型不匹配，就会出现这种情况。你可以用<code class="eh kz la lb lc b">context</code>和<code class="eh kz la lb lc b">type</code>来了解发生了什么。</li></ol><p id="db70" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">看一看</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="676c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kz la lb lc b">Encoder</code>也是如此，这些错误非常有助于您灵活地适应某些情况并适当地处理它们。</p><h1 id="5efa" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">进一步学习</h1><p id="e511" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">没有比WWDC 2017资源本身更好的了。这里…</p><div class="mv mw fm fo mx my"><a href="https://developer.apple.com/videos/play/wwdc2017/212/" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab ej"><div class="na ab nb cl cj nc"><h2 class="bd hv fv z el nd eo ep ne er et ht dt translated">基础新功能- WWDC 2017 -视频-苹果开发者</h2><div class="nf l"><h3 class="bd b fv z el nd eo ep ne er et ek translated">无论你是在为iOS、macOS、watchOS还是tvOS开发应用，你都可以从苹果的SDK中获得很多功能…</h3></div><div class="ng l"><p class="bd b gc z el nd eo ep ne er et ek translated">developer.apple.com</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm nn my"/></div></div></a></div><div class="mv mw fm fo mx my"><a href="https://developer.apple.com/documentation/foundation/archives_and_serialization/using_json_with_custom_types" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab ej"><div class="na ab nb cl cj nc"><h2 class="bd hv fv z el nd eo ep ne er et ht dt translated">将JSON用于自定义类型| Apple开发人员文档</h2><div class="nf l"><h3 class="bd b fv z el nd eo ep ne er et ek translated">您从其他应用程序、服务和文件发送或接收的JSON数据可以有许多不同的形状和结构…</h3></div><div class="ng l"><p class="bd b gc z el nd eo ep ne er et ek translated">developer.apple.com</p></div></div><div class="nh l"><div class="no l nj nk nl nh nm nn my"/></div></div></a></div><h1 id="08d5" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">结论</h1><p id="4799" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">呼！这是一个漫长的旅程，但这是Swift JSON解析的未来。欢迎评论/建议:)</p><h2 id="2309" class="lo jq hu bd jr mh mi mj jv mk ml mm jz jc mn mo kd jg mp mq kh jk mr ms kl mt dt translated">阿迪奥斯 (-ω-ゞ</h2><h2 id="2da5" class="lo jq hu bd jr mh mi mj jv mk ml mm jz jc mn mo kd jg mp mq kh jk mr ms kl mt dt translated">愿原力与你同在</h2></div></div>    
</body>
</html>