<html>
<head>
<title>Avoiding Mocks in ScalaTest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在ScalaTest中避免模仿</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/avoiding-mocks-in-scalatest-940bb8bfdb10?source=collection_archive---------3-----------------------#2017-08-08">https://medium.com/hackernoon/avoiding-mocks-in-scalatest-940bb8bfdb10?source=collection_archive---------3-----------------------#2017-08-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/eb703d32ad68fb7e77cb3eadd22ecdd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*3e6CYr3w9IqB_A7rmL90LQ.jpeg"/></div></figure><p id="6f7b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">很多次有人问我，在为Scala应用程序编写测试时，我是如何模仿的。既然测试对我们来说很重要(参见<a class="ae jw" href="https://hackernoon.com/simplified-testing-with-scalatest-and-custom-matchers-bd5297128ebc" rel="noopener ugc nofollow" target="_blank"> <strong class="ja hv"> <em class="jx">使用ScalaTest和自定义匹配器的简化测试</em> </strong> </a> <strong class="ja hv"> <em class="jx"> ) </em> </strong>看来嘲讽是我们测试技术中不可或缺的一部分，所以让我们探讨一下这方面的一些想法。</p><p id="efc2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们从展示一个每天都会发生在我们身上的常见问题开始。请注意，这个例子可能非常简单，但是给定一个上下文，它可以外推至日常现实问题。</p><p id="0854" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们的问题领域是与<em class="jx">应用程序用户操作相关的领域。</em></p><p id="6b7f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们从一开始就定义一些高层次的抽象。</p><figure class="jy jz ka kb fq iv"><div class="bz el l di"><div class="kc kd l"/></div></figure><p id="4515" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">首先，我们有一个从某种存储中存储和检索对象接口。正如你可能看到的，这个定义非常抽象，在某些时候，我们需要它的专门化。</p><p id="73ae" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，我们可以定义另一个更接近我们领域的抽象。</p><figure class="jy jz ka kb fq iv"><div class="bz el l di"><div class="kc kd l"/></div></figure><p id="ad4b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv"><em class="jx">user repository</em></strong>是一个抽象概念，表示我们将如何管理应用程序中的用户。</p><p id="769a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在这一点上，我们需要实现<strong class="ja hv"> <em class="jx">用户存储库</em> </strong>，它需要一个<strong class="ja hv"> <em class="jx">数据库</em> </strong>的具体表示来处理。</p><p id="7dea" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们从编写一些测试开始。</p><figure class="jy jz ka kb fq iv"><div class="bz el l di"><div class="kc kd l"/></div></figure><p id="fb8f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这个测试没什么不寻常的。它唯一做的事情是确保用户一旦被添加就可以恢复。它的问题是它需要一些<strong class="ja hv"> <em class="jx"> DB </em> </strong>的实例。</p><p id="9589" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">此时，我们可以给我们的依赖项添加一个嘲讽库，开始嘲讽<strong class="ja hv"><em class="jx">DB</em></strong>；但问题是这真的有必要吗？</p><p id="130d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果只是实现一个我们可以在测试中使用的版本呢？</p><figure class="jy jz ka kb fq iv"><div class="bz el l di"><div class="kc kd l"/></div></figure><p id="71d3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，在我们的测试中，我们需要在运行它们之前初始化InMemDB  中的<strong class="ja hv"> <em class="jx">。</em></strong></p><figure class="jy jz ka kb fq iv"><div class="bz el l di"><div class="kc kd l"/></div></figure><p id="5983" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在某种程度上，我们正在创建一个真正的<strong class="ja hv"> <em class="jx"> DB </em> </strong>的实现，这对于很多情况来说是很好的，但有时我们希望有更多的灵活性，这就是嘲讽库的闪光点。</p><figure class="jy jz ka kb fq iv"><div class="bz el l di"><div class="kc kd l"/></div></figure><p id="ca4e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在这种情况下，我们不必实现<strong class="ja hv"> <em class="jx"> DB </em> </strong>来使用它。我们可以用我们想要的方式嘲笑/模拟它的行为。然而，为了设置模仿，需要额外的步骤。</p><p id="24e9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们使用这种技术编写另一个测试。</p><figure class="jy jz ka kb fq iv"><div class="bz el l di"><div class="kc kd l"/></div></figure><p id="36c3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在这里，我们测试谓词(user.name.length ≤ 3)是否正在执行。</p><p id="720a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">正如您所看到的，建立这些模拟并不难，但这也可能是另一种方式来做同样的事情，而不会给我们的测试引入额外的依赖。</p><p id="42db" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果我们可以用下面的方式写同样的测试呢？</p><figure class="jy jz ka kb fq iv"><div class="bz el l di"><div class="kc kd l"/></div></figure><p id="c93f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们实际上可以创建一个<strong class="ja hv"> <em class="jx"> DB </em> </strong>的实例，并内联实现它。缺点是，我们还需要有其他功能，即使我们不使用它们。</p><p id="6b08" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们可以通过用默认实现创建另一个特征，然后在测试中使用这个新的特征来规避这个问题。</p><figure class="jy jz ka kb fq iv"><div class="bz el l di"><div class="kc kd l"/></div></figure><p id="0a4d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们可以如下重写我们测试。</p><figure class="jy jz ka kb fq iv"><div class="bz el l di"><div class="kc kd l"/></div></figure><p id="8aaa" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">重要的是要记住，在这里我们根本不是在测试<strong class="ja hv"> <em class="jx"> DB </em> </strong>。这里重要的是能够成功地测试<strong class="ja hv"> <em class="jx">用户存储库</em> </strong>。</p><p id="d467" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">对于我们可以在<strong class="ja hv"><em class="jx">user repository</em></strong>中使用的东西，至少还有一种方法可以替换<strong class="ja hv"> <em class="jx"> DB </em> </strong>。我们可以将<strong class="ja hv"> <em class="jx"> DB </em> </strong>与我们的测试类混合在一起。</p><figure class="jy jz ka kb fq iv"><div class="bz el l di"><div class="kc kd l"/></div></figure><p id="914e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">以这种特殊的方式，我们需要在我们的测试类中实现<strong class="ja hv"> <em class="jx"> DB </em> </strong>函数，这使它成为<strong class="ja hv"> <em class="jx"> DB </em>的一个实例。</strong>这和我们用<strong class="ja hv"><em class="jx">UserDBForTesting</em></strong>做的有点像，但是在这种情况下，我们不需要额外的类，实现正是我们测试所需要的，没有别的。</p></div><div class="ab cl ke kf hc kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hn ho hp hq hr"><p id="8f72" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们看另一个例子，它通过使用类型类和上下文带来了一种不同的模拟/替换实现的方式。</p><figure class="jy jz ka kb fq iv"><div class="bz el l di"><div class="kc kd l"/></div></figure><p id="8151" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这个<code class="eh kl km kn ko b">type class</code>是一个抽象的<strong class="ja hv"> <em class="jx">编写器</em> </strong>，我们可以通过某种专门化来实现它，特别是对于<strong class="ja hv"> <em class="jx">用户</em> </strong>。</p><p id="5568" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这个想法是我们可以做下面的函数调用。</p><figure class="jy jz ka kb fq iv"><div class="bz el l di"><div class="kc kd l"/></div></figure><p id="ed91" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了实现这一点，我们需要实现<strong class="ja hv"><em class="jx">Write【User】</em></strong>，它实际上将<strong class="ja hv"> <em class="jx">用户</em> </strong>写到磁盘上。<em class="jx">写一个用户应该永远不会失败。</em></p><figure class="jy jz ka kb fq iv"><div class="bz el l di"><div class="kc kd l"/></div></figure><p id="e192" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv"> <em class="jx"> Writer【用户】</em> </strong>的相关测试可以用多种方式完成，集成测试可能是解决这个问题的好方法。但是，从这一层开始，我们就不用再处理磁盘了。我们可以简单地替换<strong class="ja hv"> <em class="jx">的实现，将</em> </strong>放到我们的测试中。</p><p id="9452" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">假设我们必须编写在某些上下文中覆盖用户信息的用户管理器。上下文本身不必是固定的。</p><figure class="jy jz ka kb fq iv"><div class="bz el l di"><div class="kc kd l"/></div></figure><p id="05d1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv"> <em class="jx">。替换</em> </strong>不仅写磁盘，还对用户做其他验证。</p><p id="d883" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们看看它的测试是什么样的。</p><figure class="jy jz ka kb fq iv"><div class="bz el l di"><div class="kc kd l"/></div></figure><p id="5e42" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">对内，<strong class="ja hv">、<em class="jx">取代</em>、</strong>应该在某些时候做到。</p><figure class="jy jz ka kb fq iv"><div class="bz el l di"><div class="kc kd l"/></div></figure><p id="275c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">问题是为了测试<strong class="ja hv"> <em class="jx">用户管理器</em> </strong>我们根本不应该去磁盘。我们可以简单地替换测试调用。一种方法是替换测试过程中选择的上下文。</p><figure class="jy jz ka kb fq iv"><div class="bz el l di"><div class="kc kd l"/></div></figure><p id="7db1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">然后我们隐式导入<strong class="ja hv"><em class="jx">TrueTestingUserStorage</em></strong>模仿/模拟被测类(<strong class="ja hv"> <em class="jx"> UserManager </em> </strong>)所具有的依赖关系。</p></div><div class="ab cl ke kf hc kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hn ho hp hq hr"><p id="b258" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">回到问题<strong class="ja hv"> <em class="jx">我如何嘲讽？</em> </strong> <em class="jx"> </em>嗯，我一般不会。</p><p id="9908" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们刚刚看到了几种不同的替代模拟的方法。我不嘲笑，因为我从来不记得框架的细节；因为团队中的人对如何模仿有强烈的意见，而且每个人对框架都有不同的偏好。要考虑的事情太多了，因此复杂性和决策更难处理。</p><p id="5784" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我个人认为使用纯Scala技术来模拟测试依赖的实现，同时保持小的构建和库依赖，更容易。</p><p id="b164" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">看起来，当应用程序组件中有大量状态需要管理时，模仿就成了一种方式。然而，在我们的模块中使用纯函数和较少的状态使得测试应用程序/模块的不同部分变得更加容易。有时候，接受纯函数式编程需要时间，但是它带来的好处之一是测试的简单性。</p><blockquote class="kp kq kr"><p id="ca2e" class="iy iz jx ja b jb jc jd je jf jg jh ji ks jk jl jm kt jo jp jq ku js jt ju jv hn dt translated">Scala mix很好地完成了这项工作。</p></blockquote><p id="1b5a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">许多人在这些想法中挣扎。请分享你对此的看法，以及你是如何进行嘲讽和测试的。我将很高兴从社区中学到更多。</p></div><div class="ab cl ke kf hc kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hn ho hp hq hr"><p id="49a6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><em class="jx">注意，我们使用了一些测试技术和Scala隐式，正如我们在之前的帖子中所讨论的(参见</em> <a class="ae jw" href="https://hackernoon.com/simplified-testing-with-scalatest-and-custom-matchers-bd5297128ebc" rel="noopener ugc nofollow" target="_blank"> <strong class="ja hv"> <em class="jx">使用ScalaTest和自定义匹配器的简化测试</em></strong></a><strong class="ja hv"><em class="jx">)</em></strong></p></div></div>    
</body>
</html>