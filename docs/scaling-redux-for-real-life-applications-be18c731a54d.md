# 现实生活应用的缩放冗余

> 原文：<https://medium.com/hackernoon/scaling-redux-for-real-life-applications-be18c731a54d>

![](img/fe5aa20a3c2c45dfae0a580b2b2c6231.png)

React + [Redux](https://hackernoon.com/tagged/redux) stack 已经成为构建现代 web 应用程序的一个非常流行的选择。关于它们有足够多的 [**好教程**](https://teropa.info/blog/2015/09/10/full-stack-redux-tutorial.html) ，但我还没找到一个解释 ToDo-app 完成后该做什么的。

在这篇文章中，我将解释我是如何在水平方向(相邻的特性)和垂直方向(复杂的特性)上扩展我的项目的。

# 关于命名

在我们深入研究代码示例之前，让我们就一些命名约定达成一致。对我来说，给事物命名总是很难，而且感觉固执己见，所以请对此有所保留。

当我们谈论 React 时， [**表示和容器组件**](https://medium.com/u/a3a8af6addc1#.sxxr1fdf7) 之间的区别。

使用 Redux，我尝试用几种不同的方式组织我的动作创建器和还原器，现在我最终使用了 [Erik Rasmussen](https://medium.com/u/a9d3e1c4ef5f?source=post_page-----be18c731a54d--------------------------------) 的提议，将 Redux 应用程序拆分成 [**还原器包(又名 ducks)**](https://github.com/erikras/ducks-modular-redux) 。我喜欢这个想法，但不喜欢这个名字，所以我将谈论**概念**而不是鸭子(就此而言，还不如说是**服务**)。他们的目的是创建尽可能内聚和可重用的代码模块来构建我们的应用程序。

# 基础知识

举例来说，假设我们正在实现一个显示某种用户列表的应用程序。让我们从一个简单的概念开始，它从 API 获取用户，并将它们存储到 Redux store 中。

然后，容器组件使用这个概念来呈现获取的数据。

这有点工作，但我不喜欢我的商店的内部结构泄漏到容器中的想法(我在看着你，`mapToState` function)。例如，如果我想重命名商店中的`loading`为`isLoading`，我必须使用这个概念对每个容器进行修改。因为我们正在讨论为更复杂的应用程序进行扩展，所以这是不可能的。

# 简介:选择器

解决上述问题的一个简单方法是使用**选择器**实现一个 API 来访问 concept 的存储。就此而言，它们可以被称为 getters，但是我喜欢使用 [**Reselect**](https://github.com/reactjs/reselect) 库，因为它提供了记忆化的结果和选择器组合，所以命名有点儿固定。

所以，让我们在概念中加入一些选择器。

并且还更新容器:

现在，我们的容器不需要知道存储的内部表示，我们也有了更多可测试和可重用的 API 来访问应用程序状态的一部分。

根据我的经验，当大多数连接的容器只依赖于单个概念时，像这样构造代码对于更简单的 CRUD 类型的应用程序来说效果很好。

当我们开始添加更复杂的功能时，这种方法的局限性就开始显现出来，这些功能通常意味着数据聚合和/或将多个操作编排到应用程序逻辑中。

# 发育期痛

我们的最终用户对我们的应用程序很满意，但现在他们想要更多。他们要求在用户列表中查看每个用户的提醒数量和某种用户活动分数。

我们使用的 API 不提供现成的信息，所以我们必须发出多个请求来获得我们需要的所有信息。

我们可以重构`fetchUsers()`来发出其他请求，但是这将加载用户、警报和活动评分紧密耦合在一起。如果我们只想获取用户信息(或者将它与其他信息聚合在一起)，我们必须向 action creator 和 reducer 添加更多的参数和/或条件。

如果我们不断给我们的概念添加越来越多的逻辑，我们最终会得到一大团意大利面条。而且既然我们要 [**干**](https://en.wikipedia.org/wiki/Don't_repeat_yourself) 和 [**亲**](https://en.wikipedia.org/wiki/KISS_principle) ，这太不行了。

一个症状可能是 React 组件中`componentWillReceiveProps()`函数数量的增加，你试图从当前和下一个道具中推断实际发生了什么。

我们也可以在容器组件中实现这个逻辑。一种方法是将连接容器实现为[高阶组件](/@franleplant/react-higher-order-components-in-depth-cf9032ee6c3e)，它只包装表示组件，而不自己呈现任何东西。这已经很好了，但我要说它仍然有一些缺点；我们可以让单元测试变得简单一点，但是我们仍然需要一个好的地方来存储特定于视图的数据(例如，搜索词等等)。

# 简介:容器概念

最近我开始将我的概念组织成两个不同的类别:**基本概念**和**容器概念**。

前者很像我们已经写过的那个。它们是我们应用程序的基本构件，这意味着它们…

*   **包含大部分应用状态，**
*   **提供一个内聚的通用 API，用于访问和更新他们的状态部分，**
*   **包含最少量的应用程序逻辑，不依赖于其他概念**
*   **理想情况下不被任何容器使用**

在我们的例子中，我们可能有单独的`users`、`alerts`和`activityScores`概念。这听起来可能有点过度工程化，在这一点上确实如此，但请记住，我们将在未来为这些概念添加越来越多的新功能。

另一方面，容器概念几乎是相反的。他们…

*   **状态中包含最少数据或没有数据，**
*   **提供一个为单个容器定制的非常具体的 API，**
*   **通过组合基本概念的功能来实现大部分应用逻辑**
*   **理想情况下仅由一个容器使用**

因此，让我们看看这些容器的概念是什么样的，并创建一个容器来处理获取和聚合用户、警报和活动分数数据。

因为我们的用户列表特定概念没有任何自己的状态，所以我们不需要它的缩减器。如果我们想要添加支持，比方说，通过搜索项过滤，搜索项可以被添加到这个概念的存储中，因为它可以被视为一个视图/容器特定的关注点。

不过，动作创建器和选择器是更有趣的部分。

`fetchUsers()`动作创建器现在通过利用其他概念提供的动作创建器来封装向不同端点发出多个请求的逻辑。它不需要知道如何或在哪里准确地检索数据的细节。它唯一关心的是确保需要的信息在需要的时候被获取。

有时候，我只是从其他概念中重新导出动作创建者，而不添加任何包装。比起依赖容器中的多个概念，我更喜欢这种方法。

`getUsers()`使用 Reselect 中的`createSelector()`函数组合并重新格式化数据，使其更适合容器。例如，我们正在计算过去 7 天用户活动得分的最小值、最大值和平均值。注意，我们还将键值数据转换为按用户名排序的列表，这样更容易按组件呈现。

因为 Reselect 为我们提供了结果的记忆，所以我们也不必太担心性能影响。

到目前为止，我们已经设法使基本概念保持简单、独立和易于测试。应用程序逻辑没有泄漏到 React 组件中，这意味着单元测试也很容易。另外，它与容器的一对一关系意味着，如果我们修改容器概念，我们不必担心在其他地方破坏某些东西。同样值得注意的是，容器使用的 API 仍然和我们开始时一样。

# 结论

对于像我这样一直使用 MVVM 模式的人来说，这应该不是什么新鲜事。**基本概念是模型，容器概念是视图——模型和容器是视图。**

在现实生活中，这种方法也有一些限制。在某些情况下，我们已经注意到这种两层的概念方法是不够的，但是我们已经通过添加依赖于它们下面的概念的更精炼的基本概念解决了这个问题。只要确保在你的概念依赖树中有一个清晰的层次结构。

通用 API 和特定于容器的 API 之间也没有明确的界限。我们将我们的概念保存在同一个目录中，但是通过将它们保存在不同的目录中来明确区分它们也是有意义的，这有助于您的思考过程。我建议选择最适合你的解决方案。

我目前的工作项目是类似仪表板的应用程序(超过 60kLOC ),具有大量的数据聚合和数据提炼，以及复杂的应用程序逻辑。以这种方式构建我们的代码使我们能够轻松地进行纵向和横向伸缩。对我们来说，这意味着更少的回归，意味着更快乐的客户，最终意味着更快乐的编码员。

我很想听听你对以这种方式构建代码的想法？你在你的项目中使用了什么样的解决方案，它们对你有什么作用？

[![](img/50ef4044ecd4e250b5d50f368b775d38.png)](http://bit.ly/HackernoonFB)[![](img/979d9a46439d5aebbdcdca574e21dc81.png)](https://goo.gl/k7XYbx)[![](img/2930ba6bd2c12218fdbbf7e02c8746ff.png)](https://goo.gl/4ofytp)

> [黑客中午](http://bit.ly/Hackernoon)是黑客如何开始他们的下午。我们是 [@AMI](http://bit.ly/atAMIatAMI) 家庭的一员。我们现在[接受投稿](http://bit.ly/hackernoonsubmission)，并乐意[讨论广告&赞助](mailto:partners@amipublications.com)机会。
> 
> 如果你喜欢这个故事，我们推荐你阅读我们的[最新科技故事](http://bit.ly/hackernoonlatestt)和[趋势科技故事](https://hackernoon.com/trending)。直到下一次，不要把世界的现实想当然！

![](img/be0ca55ba73a573dce11effb2ee80d56.png)