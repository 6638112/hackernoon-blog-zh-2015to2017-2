<html>
<head>
<title>Reusable API Resource with Nested Relationship — Laravel 5.5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有嵌套关系的可重用API资源— Laravel 5.5</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/reusable-api-resource-with-nested-relationship-laravel-5-5-c654c7243869?source=collection_archive---------2-----------------------#2017-08-26">https://medium.com/hackernoon/reusable-api-resource-with-nested-relationship-laravel-5-5-c654c7243869?source=collection_archive---------2-----------------------#2017-08-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/713397ddb1614a6b63d19a2139fcc082.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*90sTRHyVbH-mMcKQ_5ktSg.png"/></div></div></figure><p id="f26a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">两天前，我发表了我对Laravel最新API资源特性的第一印象。本文将更进一步，在转换层中使用一种更加Laravel友好的方法。</p><p id="c89e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="kb">注意:本文将从第4步开始。步骤1~3与上一篇文章中的相同(模型、迁移、数据库、环境设置)。点击这里</em>  <em class="kb">可以查看</em> <a class="ae ka" href="https://hackernoon.com/first-impressions-on-laravel-api-resources-4869b73b7847" rel="noopener ugc nofollow" target="_blank"> <em class="kb">。</em></a></p><h2 id="444e" class="kc kd hu bd ke kf kg kh ki kj kk kl km jn kn ko kp jr kq kr ks jv kt ku kv kw dt translated">4-重命名资源(修复遗留问题)</h2><p id="b661" class="pw-post-body-paragraph jc jd hu je b jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv lb jx jy jz hn dt translated">前一篇文章创建了一个名为<code class="eh lc ld le lf b">UsersWithPostsResource</code>的资源。让我们将其重命名为<code class="eh lc ld le lf b">UsersResource</code>，并了解如何在下面的步骤中重用它。</p><h2 id="7e28" class="kc kd hu bd ke kf kg kh ki kj kk kl km jn kn ko kp jr kq kr ks jv kt ku kv kw dt translated">5-使用控制器内部的API资源</h2><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="8b35" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">静态的<code class="eh lc ld le lf b">collection</code>方法将接受一组要转换的记录，并确保为每条记录实例化一个新的<code class="eh lc ld le lf b">UsersResource</code>。</p><h2 id="f9cd" class="kc kd hu bd ke kf kg kh ki kj kk kl km jn kn ko kp jr kq kr ks jv kt ku kv kw dt translated">6-用户资源类</h2><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="6d64" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里有两个关键部分:属性访问器和可选的嵌套转换</p><ul class=""><li id="b4f5" class="lm ln hu je b jf jg jj jk jn lo jr lp jv lq jz lr ls lt lu dt translated">在一个<code class="eh lc ld le lf b">Resource</code>类中，可以通过<code class="eh lc ld le lf b">$this</code>直接访问模型属性。这个<em class="kb">魔法</em>是在基础<code class="eh lc ld le lf b">Resource</code>类中包含的<code class="eh lc ld le lf b">DelegatesToResource</code>特征中完成的。</li><li id="cbbb" class="lm ln hu je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu dt translated">如果数据可用(立即加载)，可以转换关系；如果数据尚未加载，可以忽略关系。这将防止N+1问题，同时仍然能够用单个资源类处理不同的场景。如果关系不可用，它将被忽略，否则包括在内。</li></ul><h2 id="0666" class="kc kd hu bd ke kf kg kh ki kj kk kl km jn kn ko kp jr kq kr ks jv kt ku kv kw dt translated">7-员额资源</h2><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lk ll l"/></div></figure><h2 id="8639" class="kc kd hu bd ke kf kg kh ki kj kk kl km jn kn ko kp jr kq kr ks jv kt ku kv kw dt translated">8-结论</h2><p id="8a05" class="pw-post-body-paragraph jc jd hu je b jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv lb jx jy jz hn dt translated">保持简单，一次一个步骤，本文的重点是通过学习使用<code class="eh lc ld le lf b">Resource::collection</code>而不是手动实例化类来改进从上一篇文章中收集的知识，并且将给出(或不给出)关系数据的责任委托给控制器。通过简单地从控制器中移除<code class="eh lc ld le lf b">with('posts')</code>，API将不再在响应中包含每个用户的帖子。</p><p id="f01a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然Fractal会在Transformer层中提供<code class="eh lc ld le lf b">default</code>和<code class="eh lc ld le lf b">available</code> includes，但是Laravel上的原生API资源更倾向于让控制器处理该逻辑。毕竟，理解请求是管制员的工作。</p><p id="567a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在下一篇文章中，我打算为API的用户实现一种请求包含关系的方法。考虑在Medium上关注我，获取更多类似的文章。</p></div></div>    
</body>
</html>