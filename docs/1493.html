<html>
<head>
<title>Elixir for Rubyists: Pattern matching and Recursion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rubyists的灵丹妙药:模式匹配和递归</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/elixir-for-rubyists-pattern-matching-and-recursion-37a4416ba9c?source=collection_archive---------3-----------------------#2016-11-07">https://medium.com/hackernoon/elixir-for-rubyists-pattern-matching-and-recursion-37a4416ba9c?source=collection_archive---------3-----------------------#2016-11-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="051e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">注意:这是从我在http://www.weeklycommit.com的博客上截取的</em></p><p id="0f94" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个博客系列将为来自Ruby <a class="ae jq" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>语言的人介绍<a class="ae jq" href="https://hackernoon.com/tagged/elixir" rel="noopener ugc nofollow" target="_blank">灵丹妙药</a>的基础知识。</p><p id="9527" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为什么？</p><p id="0f33" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从外表上看，Elixir和Ruby在语法上看起来非常相似。然而，这是他们真正的共同点。</p><p id="3138" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当你开始使用Elixir时，你会意识到这两种语言是多么的不同，我的意思是对于初学者来说，Elixir是一种函数式编程语言，而Ruby是面向对象的(虽然可以说Elixir是所有面向对象语言中最受反对的语言，但那是另一个时间的争论)。</p><p id="533f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本系列不打算探究为什么人们想要使用Elixir而不是Ruby，但是如果你想得到一个想法，可以看看这些帖子:</p><ul class=""><li id="0d98" class="jr js hu it b iu iv iy iz jc jt jg ju jk jv jo jw jx jy jz dt translated"><a class="ae jq" href="https://www.quora.com/Will-Elixir-Phoenix-destroy-Ruby-on-Rails" rel="noopener ugc nofollow" target="_blank">凤凰会摧毁Rails — Quora </a></li><li id="3dac" class="jr js hu it b iu ka iy kb jc kc jg kd jk ke jo jw jx jy jz dt translated"><a class="ae jq" href="http://blog.carbonfive.com/2016/04/19/elixir-and-phoenix-the-future-of-web-apis-and-apps/" rel="noopener ugc nofollow" target="_blank">仙丹与凤凰——五碳</a></li><li id="11af" class="jr js hu it b iu ka iy kb jc kc jg kd jk ke jo jw jx jy jz dt translated"><a class="ae jq" rel="noopener" href="/@kenmazaika/why-im-betting-on-elixir-7c8f847b58#.p010tmtsx">我为什么要赌灵药——灵媒</a></li></ul><h1 id="8245" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">模式匹配</h1><p id="8a38" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">好了，现在让我们进入我最喜欢的仙丹特性之一——模式匹配。</p><p id="15af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你以前从未使用过模式匹配，警告你，一旦开始，你就不能回头了。</p><p id="48bb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最简单的形式，模式匹配是一种解构复杂数据类型的方式。</p><p id="c331" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但这意味着什么呢？</p><p id="9991" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">举个例子，假设你有一张地图(相当于Ruby Hash <code class="eh li lj lk ll b">{key: "val"}</code>的灵丹妙药):</p><p id="098c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh li lj lk ll b">%{age: 22, name: "Harry"}</code></p><p id="5051" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你将如何获取<code class="eh li lj lk ll b">:name</code>键的值？</p><p id="b9bb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在ruby中，您可能会这样做:</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="a713" class="lu kg hu ll b fv lv lw l lx ly">person = {name: "harry", age: 22}  <br/>person[:name]  <br/># =&gt; "harry"</span></pre><p id="b283" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，在Elixir中，您可以这样做:</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="1aab" class="lu kg hu ll b fv lv lw l lx ly">%{name: name} = %{age: 22, name: "Harry"}<br/>name  <br/># =&gt; "Harry"</span></pre><p id="1a92" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这样做的原因是因为Elixir中的<code class="eh li lj lk ll b">=</code>操作符并不意味着赋值，而是匹配。因此上面的声明是在说:</p><p id="02d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使<code class="eh li lj lk ll b">%{name: name}</code>匹配<code class="eh li lj lk ll b">%{age: 22, name: "Harry"}</code>。</p><p id="895b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么它是如何做到这一点的呢？</p><p id="292e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">过程大概是这样的:</p><ol class=""><li id="e19b" class="jr js hu it b iu iv iy iz jc jt jg ju jk jv jo lz jx jy jz dt translated">看起来左边和右边是相同的数据类型(地图)</li><li id="a4eb" class="jr js hu it b iu ka iy kb jc kc jg kd jk ke jo lz jx jy jz dt translated">然后，它发现两个映射都有一个名为<code class="eh li lj lk ll b">:name</code>的键，所以它们匹配</li><li id="a5f7" class="jr js hu it b iu ka iy kb jc kc jg kd jk ke jo lz jx jy jz dt translated">然后它注意到左边的地图没有<code class="eh li lj lk ll b">:name</code>键的值，但是右边的地图有值。因此，它一定意味着<code class="eh li lj lk ll b">name</code>和<code class="eh li lj lk ll b">"Harry"</code>是一样的。</li></ol><p id="369c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一种思考方式就像代数。例如</p><p id="fb24" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh li lj lk ll b">1 + x = 1 + 2</code></p><p id="ff26" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">X的值是多少？</p><p id="a34d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh li lj lk ll b">2</code></p><p id="88d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是你可以做得更多。假设有了上面的，我们想再要一个人，看看是不是和第二个一样。在Ruby中，您可能会这样做:</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="7473" class="lu kg hu ll b fv lv lw l lx ly">person = {name: "harry", age: 22}  <br/>person2 = {name: "glen", age: 33}</span><span id="23fe" class="lu kg hu ll b fv ma lw l lx ly">person[:name] == person2[:name]</span></pre><p id="9a24" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有了长生不老药，你可以这样做:</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="6388" class="lu kg hu ll b fv lv lw l lx ly">%{name: name} = {age: 22, name: "harry"}<br/>%{name: ^name} = {age: 33, name: "glen"}</span><span id="8e21" class="lu kg hu ll b fv ma lw l lx ly"># =&gt; Error. No match on right hand side....</span></pre><p id="604e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们在这里使用的是“pin”操作符。这基本上就是说，我们之前将<code class="eh li lj lk ll b">name</code>的值与一个特定的值进行了匹配，所以使用那个值，而不是尝试匹配一个新值。</p><p id="c720" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这样做的好处可能不会马上显现出来。然而，对我来说，模式匹配的威力在编写函数时大放异彩。</p><p id="8683" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设你有一个方法，它接受一个散列，然后把两个数相乘，<strong class="it hv">只有当它们相等的时候</strong>。Ruby中的一个实现可能是:</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="99b1" class="lu kg hu ll b fv lv lw l lx ly">def multiply_equal(n1, n2)  <br/> raise "Not equal" if n1 != n2<br/> n1 * n2<br/>end</span></pre><p id="3e9c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">很简单。</p><p id="fab5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，我们可以做得更好。</p><p id="7667" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Elixir中，使用模式匹配，您可以这样做:</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="5b82" class="lu kg hu ll b fv lv lw l lx ly">def multiply_equal(x,x) do  <br/>  x * x<br/>end</span><span id="eaef" class="lu kg hu ll b fv ma lw l lx ly">def multiply_equal(_,_) do  <br/>  raise "Not Equal"<br/>end</span><span id="8905" class="lu kg hu ll b fv ma lw l lx ly"># or in one line</span><span id="63b3" class="lu kg hu ll b fv ma lw l lx ly">def multiply_equal(x,x), do: x * x  <br/>def multiply_eqaul(_,_), do: raise "Not Equal"</span></pre><p id="be60" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是怎么回事？一开始可能不明显，但有一点要注意，在elixir中，你可以多次定义一个函数。</p><p id="c3e2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在上面的例子中，我们定义了两个双参数<code class="eh li lj lk ll b">multiply_equal</code>函数。第一个函数只有在两个参数都相同的情况下才会被调用，第二个函数将针对两个参数的每一个其他组合被调用。</p><p id="2d49" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于一个变量只能有一个值，当我们用相同的两个参数定义一个函数头时，例如<code class="eh li lj lk ll b">(x,x)</code>，我们说这个函数只有在两个参数相同时才会被调用。它对传入的数据类型不做任何假设。</p><p id="054d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，这些都将由第一功能头调用</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="f22c" class="lu kg hu ll b fv lv lw l lx ly">multiply_equal( [1,2,3,4], [1,2,3,4] )  <br/>multiply_equal( "foo", "foo" )  <br/>multiply_equal( 'N', [78] )</span></pre><p id="3380" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(点击<a class="ae jq" href="http://elixir-lang.org/getting-started/binaries-strings-and-char-lists.html#char-lists" rel="noopener ugc nofollow" target="_blank">此处</a>查看最后一个匹配的原因)</p><p id="89ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这样做的好处可能不会马上显现出来，但是相信我，当你越来越深入到长生不老药和凤凰城的时候，你会越来越喜欢它，而不是生活本身。</p><h1 id="7342" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">把所有的放在一起</h1><p id="d21c" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">为了说明如何结合使用模式匹配和递归，我们将创建自己的乘法函数。</p><p id="358c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">基本上，我们将复制大多数语言中常见的<code class="eh li lj lk ll b">*</code>函数。</p><p id="1e3f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我花了很长时间才意识到乘法就是加法，乘以倍数。</p><p id="5d83" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么我们如何使用模式匹配和递归来创建它呢？</p><p id="c333" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为此，我们将定义两个函数。在elixir中，如果一个函数有相同的名字但不同的arity(即参数的数量，它们被认为是独立的函数)。</p><p id="0889" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以:</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="023c" class="lu kg hu ll b fv lv lw l lx ly">def func(a,b)  <br/>  IO.puts a<br/>end</span></pre><p id="fb98" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">是不同于的功能:</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="d2d7" class="lu kg hu ll b fv lv lw l lx ly">def func(a)  <br/>  IO.puts a<br/>end</span></pre><p id="ecc3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为此，我们有两个函数。</p><p id="3382" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh li lj lk ll b">multiply/2</code>是一个被其他模块公开暴露和消费的模块，<code class="eh li lj lk ll b">mulitply/3</code>是由<code class="eh li lj lk ll b">multiply/2</code>函数调用的模块。</p><p id="f7f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以基本上我们需要首先创建一个函数，它接受两个要相乘的数字，并调用我们的第二个<code class="eh li lj lk ll b">multiply/3</code>函数，传入一个累加器。我们将使用累加器来跟踪函数的最终结果。</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="12c0" class="lu kg hu ll b fv lv lw l lx ly">def multiply(n1,n2) do  <br/>  mutliply(n1,n2,0)<br/>end</span></pre><p id="f7a7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(我们甚至可以把它写在一行上)</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="cc35" class="lu kg hu ll b fv lv lw l lx ly">def multiply(n1,n2), do: multiply(n1,n2,0)</span></pre><p id="1427" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们需要实际实现乘法器逻辑。</p><p id="f809" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在elixir中处理递归时，最好先写success或end函数头，这样函数实际上就有了一个退出点(例如，不会运行到无穷大)。</p><p id="38c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的递归函数的工作方式是，对于<code class="eh li lj lk ll b">n2</code>的每个值，我们将把<code class="eh li lj lk ll b">n1</code>加到累加器(从0开始)上，并从<code class="eh li lj lk ll b">n2</code>中减去1，直到我们达到0。</p><p id="41f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以基本上:</p><p id="bb54" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">10 * 10看起来像是:</p><figure class="lm ln lo lp fq mc fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mb"><img src="../Images/0d879ce41c2ff95d0ce4775a6c7f552c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aHvayUjvp604Q-BZqLTjOw.png"/></div></div></figure><p id="390a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由此，我们可以知道我们的成功或结束案例是在<code class="eh li lj lk ll b">n2</code>等于0时。</p><p id="39e7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，该函数将如下所示:</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="b365" class="lu kg hu ll b fv lv lw l lx ly">def multiply(n1,n2), do: multiply(n1,n2,0)</span><span id="d043" class="lu kg hu ll b fv ma lw l lx ly">defp multiply(_n1, 0, acc), do: acc</span></pre><p id="2c06" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(记得<code class="eh li lj lk ll b">defp</code>让它成为私有方法)。</p><p id="4e14" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以这里我们是说如果调用了<code class="eh li lj lk ll b">multiply/3</code>并且<code class="eh li lj lk ll b">n2</code>的值等于<code class="eh li lj lk ll b">0</code>，那么就不要再迭代了，取而代之的只是返回累加器的当前值。</p><p id="b19d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是我们的最终结果。现在我们需要实现迭代逻辑。</p><p id="134f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在记住我们需要将<code class="eh li lj lk ll b">n1</code>的值加到<code class="eh li lj lk ll b">acc</code>上，并将<code class="eh li lj lk ll b">n2</code>的值减1。</p><p id="9cd7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">看起来像这样:</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="b3c5" class="lu kg hu ll b fv lv lw l lx ly">def multiply(n1,n2,acc) do  <br/>  new_acc = n1 + acc<br/>  new_n2 = n2 - 1</span><span id="2b7b" class="lu kg hu ll b fv ma lw l lx ly">  #recursive call<br/>  multiply(n1, new_n2, new_acc)<br/>end</span></pre><p id="39d7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后一行用新的值<code class="eh li lj lk ll b">n2</code>和<code class="eh li lj lk ll b">acc</code>再次调用相同的函数。</p><p id="d98c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，这看起来相当混乱..让我们稍微重构一下，看起来更合适。</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="dfdb" class="lu kg hu ll b fv lv lw l lx ly">def multiply(n1,n2,acc) do  <br/>  multiply(n1, n2 - 1, acc + n1)<br/>end</span></pre><p id="3da1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们甚至可以用一行代码来说明这一点:</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="96ab" class="lu kg hu ll b fv lv lw l lx ly">def multiply(n1,n2,acc), do: multiply(n1, n2 - 1, acc + n1)</span></pre><p id="8210" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就这样，我们现在可以用三行长生不老药将两个数相乘。</p><p id="15ef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最终的实现看起来像这样:</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="e7ea" class="lu kg hu ll b fv lv lw l lx ly">def multiply(n1,n2), do: multiply(n1,n2,0)  <br/>defp multiply(_n1, 0, acc), do: acc  <br/>defp multiply(n1,n2,acc), do: multiply(n1, n2 - 1, acc + n1)</span></pre><p id="8eb8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">很漂亮吧？</p><p id="f1c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">很明显这不能处理负数，但是也很容易处理。</p><p id="1dbb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样，这里不需要使用if语句，相反我们可以使用<a class="ae jq" href="http://elixir-lang.org/getting-started/case-cond-and-if.html#expressions-in-guard-clauses" rel="noopener ugc nofollow" target="_blank"><em class="jp">guard _ clauses</em></a>。</p><p id="cff9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">保护子句本质上是函数头的一部分，它向传入的参数添加条件。这基本上是另一种模式匹配的方式。</p><p id="03b8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们的例子中，这可以通过检查<code class="eh li lj lk ll b">n2</code>的值是否小于0来实现。如果是，我们只需颠倒<code class="eh li lj lk ll b">n2</code>和<code class="eh li lj lk ll b">acc</code>上的操作(例如，我们给<code class="eh li lj lk ll b">n2</code>加1，从<code class="eh li lj lk ll b">acc</code>减去<code class="eh li lj lk ll b">n1</code>)。</p><p id="5a41" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是头部看起来样子:</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="074d" class="lu kg hu ll b fv lv lw l lx ly">def multiply(n1,n2,acc) when n2 &lt; 0 do  <br/>  multiply(n1, n2 + 1, acc - n1)<br/>end</span><span id="11b2" class="lu kg hu ll b fv ma lw l lx ly"># or on one line</span><span id="5769" class="lu kg hu ll b fv ma lw l lx ly">def multiply(n1,n2,acc) when n2 &lt; 0, do: multiply(n1, n2 + 1, acc - n1)</span></pre><p id="12aa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那部分是保护条款。我们在这里说，如果参数可以匹配到<code class="eh li lj lk ll b">n1,n2,acc</code>(它们可以匹配)<strong class="it hv">和</strong>(如果<code class="eh li lj lk ll b">n2</code>小于0 ),那么首先只调用这个函数头。</p><p id="a52a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为这是递归的，所以Elixir中的函数按照定义的顺序进行检查。例如，如果我们在原来的方法下面有这个方法，它永远不会被调用:</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="1055" class="lu kg hu ll b fv lv lw l lx ly">def multiply(n1,n2), do: multiply(n1,n2,0) # 1</span><span id="0f2b" class="lu kg hu ll b fv ma lw l lx ly">  defp multiply(_n1,0,acc), do: acc # 2<br/>  defp multiply(n1,n2,acc), do: multiply(n1,n2 - 1, acc + n1) #3<br/>  defp multiply(n1,n2,acc) when n2 &lt; 0, do: multiply(n1,n2 + 1, acc - n1) #4 - Never called</span></pre><p id="9652" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是因为函数头<code class="eh li lj lk ll b">#3</code>将总是匹配参数(假设它通过函数头<code class="eh li lj lk ll b">#2</code>)。因此，我们需要做的就是将<code class="eh li lj lk ll b">#4</code>移动到<code class="eh li lj lk ll b">#3</code>上方，例如</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="1fac" class="lu kg hu ll b fv lv lw l lx ly">def multiply(n1,n2), do: multiply(n1,n2,0) </span><span id="3d06" class="lu kg hu ll b fv ma lw l lx ly">  defp multiply(_n1,0,acc), do: acc<br/>  defp multiply(n1,n2,acc) when n2 &lt; 0, do: multiply(n1,n2 + 1, acc - n1)<br/>  defp multiply(n1,n2,acc), do: multiply(n1,n2 - 1, acc + n1)</span></pre><p id="8cc1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们已经使用模式匹配和递归从头开始编写了一个完整的多功能函数。</p><p id="d0bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是一些示例输出(注意该方法是在一个名为<code class="eh li lj lk ll b">Recurse</code>的模块下定义的):</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="5cf4" class="lu kg hu ll b fv lv lw l lx ly">iex(1)&gt; Recurse.multiply(2,-3)  <br/>#=&gt; -6<br/>iex(2)&gt; Recurse.multiply(-2,-3)  <br/>#=&gt; 6<br/>iex(3)&gt; Recurse.multiply(2, 3)  <br/>#=&gt; 6<br/>iex(4)&gt; Recurse.multiply(-2, 3)  <br/>#=&gt; -6</span></pre><p id="ff5c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你喜欢这个小指南或者有任何问题，请在下面的评论中告诉我。我很乐意帮助你！</p><blockquote class="mj mk ml"><p id="a47b" class="ir is jp it b iu iv iw ix iy iz ja jb mm jd je jf mn jh ji jj mo jl jm jn jo hn dt translated">黑客中午是黑客如何开始他们的下午。我们是这个家庭的一员。我们现在<a class="ae jq" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jq" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is jp it b iu iv iw ix iy iz ja jb mm jd je jf mn jh ji jj mo jl jm jn jo hn dt translated">要了解更多信息，<a class="ae jq" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">请阅读我们的“关于”页面</a> , <a class="ae jq" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">喜欢/在脸书给我们发消息</a>，或者简单地，<a class="ae jq" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank">发推文/DM @HackerNoon。</a></p><p id="708a" class="ir is jp it b iu iv iw ix iy iz ja jb mm jd je jf mn jh ji jj mo jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jq" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jq" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lm ln lo lp fq mc"><div class="bz el l di"><div class="mp mq l"/></div></figure></div></div>    
</body>
</html>