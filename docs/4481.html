<html>
<head>
<title>How does Ember Boot?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ember怎么开机？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-does-ember-boot-5e1f9e7a1117?source=collection_archive---------9-----------------------#2017-06-04">https://medium.com/hackernoon/how-does-ember-boot-5e1f9e7a1117?source=collection_archive---------9-----------------------#2017-06-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/></div><div class="ab cl ir is hc it" role="separator"><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw"/></div><div class="hn ho hp hq hr"><figure class="iz ja jb jc fq jd fe ff paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="fe ff iy"><img src="../Images/52c3a5e1d5cb22596453975295b035d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KzOc7IBARdE5arCEdGBCCg.png"/></div></div></figure><p id="1d72" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">自诞生以来，Ember已经从一个<a class="ae ki" href="https://en.wikipedia.org/wiki/SproutCore" rel="noopener ugc nofollow" target="_blank"> SproutCore 2.0 </a>框架发展成为一个现代可信的Javascript框架，被苹果、LinkedIn和Vine等主要科技公司使用。它是由Rails开发人员Yehuda Katz开发的，所以它相信约定胜于配置。Ember社区不仅非常支持，而且遵循六周发布周期，确保安全性和功能，使其成为最佳考虑框架。它试图尽可能地保持向后兼容，这样每一个新的主要版本你都不必浪费大量的时间去学习新的突破性的东西和语法。<br/> <br/>我正在做我的Ember项目，它花了很多时间来启动，这不是一件平常的事情，在挖掘其原因之前，这个问题击中了我“Ember是如何启动的？”。虽然这额外时间的原因是我的API上的一个调试器。知道ember是如何启动的很有启发性。</p><p id="6dc8" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">我做了一些研究，主要是查看Ember git资源库来寻找我的答案。了解余烬启动过程，不仅让我的根变得强壮，也改变了我看待它的方式。</p><p id="203f" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">涵盖整个Ember启动过程超出了任何文章的范围，要做到这一点，需要有一本书，但我可以明确地简要介绍对我有意义并且值得一提的事情。所以让我们开始…</p></div><div class="ab cl ir is hc it" role="separator"><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw"/></div><div class="hn ho hp hq hr"><p id="c509" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">当您启动任何Ember应用程序时，发生的第一件事就是创建<code class="eh kj kk kl km b">Ember.Application</code>实例，这是由</p><p id="334a" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated"><code class="eh kj kk kl km b">window.App = Ember.Application.create();</code></p><p id="035f" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">保存此实例的对象是一个全局对象，并且只创建一次。该类中的任何方法或变量都有一个全局名称空间<code class="eh kj kk kl km b">Ember.Application</code>。虽然您可以将<code class="eh kj kk kl km b">Ember.Application</code>视为保存应用程序中其他类的容器，但是还有其他一些职责，比如初始化、事件委托和路由。</p><p id="d3ec" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">创建实例时调用的第一个方法是<code class="eh kj kk kl km b">_bootSync()</code>。当Ember执行所需的所有资源都被下载并解析后，触发<code class="eh kj kk kl km b">domReady()</code>时调用该函数。</p><p id="112a" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">下面的代码列出了<code class="eh kj kk kl km b">Ember.Application</code>引导过程中涉及的所有方法。</p><pre class="iz ja jb jc fq kn km ko kp aw kq dt"><span id="14b5" class="kr ks hu km b fv kt ku l kv kw">Ember.Application{<br/>  //other methods and variables<br/>  ....<br/>  _bootSync(){<br/>    this.runInitializers();<br/>    this.advanceReadiness(){<br/>      this.didBecomeReady();<br/>    }<br/>  }<br/>  ....<br/>  //other methods and variables<br/>  ....<br/>  didBecomeReady(){<br/>    if(this.autoboot){<br/>    //instantiate Ember.ApplicationInstance<br/>      let instance = this.buildInstance();<br/>      instance._bootSync();<br/>      intance.startRouting();<br/>      //or instance.handleURL(url)<br/>    }<br/>  }<br/>  ....<br/>  //other methods and variables<br/>}</span></pre><p id="b80b" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated"><code class="eh kj kk kl km b">Ember.Application</code>有以下职责:</p><ol class=""><li id="3aad" class="kx ky hu jm b jn jo jr js jv kz jz la kd lb kh lc ld le lf dt translated"><strong class="jm hv">初始化</strong></li></ol><p id="b932" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">初始化器的目标是注册依赖和注入。它们提供了对内部注册表的访问，内部注册表组织了Ember应用程序的不同组件。此外，它们还提供了访问实例化应用程序的机会。</p><p id="102d" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">它只运行一次。因为这些初始化器可能会加载代码，所以它们被允许推迟应用程序准备就绪时间并提前。当某个异步任务需要在某个初始化器之前执行时，可以使用<code class="eh kj kk kl km b">deferReadiness()</code>来控制<code class="eh kj kk kl km b">advanceReadiness()</code>，只有当<code class="eh kj kk kl km b">deferReadiness()</code>计数器设置为零时，才会调用<code class="eh kj kk kl km b">advanceReadiness()</code>。当我们调用<code class="eh kj kk kl km b">deferReadiness()</code>时，计数器被设置为递减，变成-1。路由停止，直到<code class="eh kj kk kl km b">deferReadiness()</code>计数器变为零。一旦异步任务执行完毕，使计数器增加1，如果计数器=0，则调用<code class="eh kj kk kl km b">advanceReadiness()</code>。</p><p id="9a8c" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">可以在Ember上添加自定义初始化器，如下所示:</p><pre class="iz ja jb jc fq kn km ko kp aw kq dt"><span id="cc33" class="kr ks hu km b fv kt ku l kv kw">Ember.Application.initializer({ <br/>  name: ‘api-adapter’, <br/>  initialize: function(application) { <br/>    application.register(‘api-adapter:main’, ApiAdapter); <br/>  } <br/>});</span></pre><p id="083a" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">2.<strong class="jm hv">事件委托</strong></p><p id="dbbb" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">Ember使用了一种叫做<code class="eh kj kk kl km b">_event delegation_</code>的技术。这允许框架建立一个全局的、共享的事件监听器，而不是要求每个视图手动完成。</p><p id="9c71" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">例如，Ember在<code class="eh kj kk kl km b">&lt;body&gt;</code>上设置了一个<code class="eh kj kk kl km b">mousedown </code>监听器，而不是每个视图在其相关元素上注册自己的<code class="eh kj kk kl km b">mousedown</code>监听器。如果一个<code class="eh kj kk kl km b">mousedown</code>事件发生，Ember将查看事件的目标并开始遍历DOM节点树，找到相应的视图并调用它们的<code class="eh kj kk kl km b">mouseDown</code>方法。</p><p id="c42f" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated"><code class="eh kj kk kl km b">Ember.Application</code>有许多它监听的默认事件，以及从小写事件到大小写视图方法名的映射。例如，<code class="eh kj kk kl km b">keypress</code>事件导致视图上的<code class="eh kj kk kl km b">keyPress</code>方法被调用，<code class="eh kj kk kl km b">dblclick</code>事件导致<code class="eh kj kk kl km b">doubleClick</code>被调用，等等。</p><p id="d40a" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">如果有一个默认情况下Ember不监听的冒泡浏览器事件，您可以通过设置应用程序的<code class="eh kj kk kl km b">customEvents</code>属性来指定自定义事件及其相应的视图方法名称:</p><pre class="iz ja jb jc fq kn km ko kp aw kq dt"><span id="063f" class="kr ks hu km b fv kt ku l kv kw">let App = Ember.Application.create({<br/>    customEvents: {<br/>      // add support for the paste event<br/>      paste: 'paste'<br/>    }<br/>});</span></pre><p id="eb4a" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">要防止Ember为默认事件设置侦听器，请在“customEvents”属性中用“null”值指定事件名称:</p><pre class="iz ja jb jc fq kn km ko kp aw kq dt"><span id="748e" class="kr ks hu km b fv kt ku l kv kw">let App = Ember.Application.create({<br/>    customEvents: {<br/>      // prevent listeners for mouseenter/mouseleave events<br/>      mouseenter: null,<br/>      mouseleave: null<br/>    }<br/>});</span></pre><p id="8848" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">默认情况下，应用程序在文档正文上设置这些事件侦听器。但是，在现有页面中嵌入Ember应用程序的情况下，您可能希望它在主体内的元素上设置侦听器。</p><p id="16fd" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">例如，如果只有ID为<code class="eh kj kk kl km b">ember-app</code>的DOM元素中的事件应该被委托，那么设置应用程序的<code class="eh kj kk kl km b">rootElement</code>属性:</p><pre class="iz ja jb jc fq kn km ko kp aw kq dt"><span id="abd0" class="kr ks hu km b fv kt ku l kv kw">let App = Ember.Application.create({<br/>    rootElement: '#ember-app'<br/>});</span></pre><p id="1bc2" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated"><code class="eh kj kk kl km b">rootElement</code>可以是DOM元素，也可以是jQuery兼容的选择器字符串。<code class="eh kj kk kl km b">Ember.EventDispatcher</code>负责将事件委托给应用程序的视图。事件调度程序由应用程序在初始化时创建，并在应用程序的<code class="eh kj kk kl km b">rootElement</code>属性描述的DOM元素上设置事件侦听器。</p><p id="6401" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">注意，追加到根元素之外的DOM的<em class="lg">视图不会接收事件</em>。如果您指定了一个定制的根元素，请确保您只在其中添加了视图！</p><p id="42d1" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">3.<strong class="jm hv">路由</strong></p><p id="30cf" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated"><code class="eh kj kk kl km b">Ember.Application</code>不仅创建您的应用路由器，还控制路由。默认情况下，一旦浏览器发出<code class="eh kj kk kl km b">DOMContentReady </code>事件，路由器将开始尝试将当前URL转换为应用程序状态。如果需要推迟路由，可以调用应用程序的<code class="eh kj kk kl km b">deferReadiness()</code>方法。一旦路由可以开始，调用<code class="eh kj kk kl km b">advanceReadiness()</code>方法。如果在路由开始之前需要任何设置，您可以在您的应用程序上实现一个<code class="eh kj kk kl km b">ready()</code>方法，该方法将在路由开始之前立即被调用。</p><p id="5277" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">这些是由<code class="eh kj kk kl km b">Ember.Application</code>初始化执行的主要任务。</p><p id="84fe" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">一旦完成，我们的应用程序就处于<code class="eh kj kk kl km b">advanceReadiness()</code>状态，下一个被调用的方法是<code class="eh kj kk kl km b">didBecomeReady()</code>。这让我们想到了下一件重要的事情，那就是<code class="eh kj kk kl km b">Ember.ApplicationInstance</code>初始化。</p></div><div class="ab cl ir is hc it" role="separator"><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw"/></div><div class="hn ho hp hq hr"><p id="242e" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">当我们谈论<code class="eh kj kk kl km b">Ember.Application</code>初始化时，我们主要是处理Ember的注册，这发生在容器被创建之前。一旦完成，初始化<code class="eh kj kk kl km b">Ember.ApplicationInstance</code>。它封装了正在运行的<code class="eh kj kk kl km b">Application</code>的所有有状态方面。</p><p id="feb5" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">在一个高层次上，我们将应用程序引导分为两个不同的阶段:<br/> *定义时间，在此加载所有的类、模板和其他<br/>依赖项(通常在浏览器中)。<br/> *运行时，一旦所有的东西<br/>都已加载，我们就开始执行应用程序。</p><p id="00b8" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated"><strong class="jm hv">注册中心</strong>类似于应用程序的类级(静态)成员，需要在实例创建之前进行处理。另一方面，单例驻留在<strong class="jm hv">容器</strong>中。Registry用于保存无状态或静态部分，而container用于保存应用程序的有状态或动态部分。</p><p id="a2b8" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">请注意，每个应用程序实例都维护着自己的注册表/容器，因此默认情况下它们将完全独立运行。</p><p id="a63d" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">现在我们知道了<code class="eh kj kk kl km b">_bootSync()</code>如何处理<code class="eh kj kk kl km b">this.didBecomeReady()</code>的时间。</p><pre class="iz ja jb jc fq kn km ko kp aw kq dt"><span id="8838" class="kr ks hu km b fv kt ku l kv kw">Ember.Application{<br/>  //other methods and variables<br/>  ....<br/>  didBecomeReady(){<br/>    if(this.autoboot){<br/>    //instantiate Ember.ApplicationInstance<br/>      let instance = this.buildInstance();<br/>      instance._bootSync();<br/>      intance.startRouting();<br/>      //or instance.handleURL(url)<br/>    }<br/>  }<br/>  ....<br/>  //other methods and variables<br/>}</span></pre><p id="139b" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">在<code class="eh kj kk kl km b">didBecomeReady()</code>，我们检查<code class="eh kj kk kl km b">this.autoboot</code>。它用于检查应用程序是否应该自动开始向DOM ready上的“rootElement”发送和呈现模板。虽然默认为true，但其他环境(如快速启动或测试工具)可以将此属性设置为“false ”,并控制启动过程的精确计时和行为。</p><p id="54a9" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">快速启动是一个特殊的环境，通常用于服务器端渲染。这种设置允许您使用Node.js在服务器环境中运行Ember应用程序，并将其内容呈现为静态HTML以用于SEO目的。</p><p id="7dc4" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">1.<strong class="jm hv">自动引导</strong></p><p id="c88b" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">当我们想在渲染过程开始前等待一些资源获取时,<code class="eh kj kk kl km b">this.autoboot</code>也很方便。正如<code class="eh kj kk kl km b">advanceReadiness()</code>用于控制路由，同样的方式<code class="eh kj kk kl km b">this.autoboot</code>用于控制渲染。</p><p id="8fd6" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">2.<code class="eh kj kk kl km b"><strong class="jm hv">Ember.ApplicationInstance</strong></code> <strong class="jm hv">初始化</strong></p><p id="f8f5" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">一旦<code class="eh kj kk kl km b">this.autoboot</code>被设置为真，接下来发生的事情就是<code class="eh kj kk kl km b">this.buildInstance()</code>。用于初始化<code class="eh kj kk kl km b">Ember.ApplicationInstance</code>。与在引导过程中仅运行一次的<code class="eh kj kk kl km b">Ember.Application</code>不同，<code class="eh kj kk kl km b">Ember.AppplicationInstance</code>被多次创建。正如我们有每次创建实例都会被调用的构造函数一样，<code class="eh kj kk kl km b">Ember.ApplicationInstance</code>也会被多次调用。它确保所有的注册表都已加载，所有的实例变量都已初始化。它们是根据每个请求创建和销毁的。因此，这是我们可能希望保存与我们的应用程序相关的敏感数据的地方，因为如果保存在注册表中，它可能会暴露出来，并且所有实例都可以不必要地访问它。</p><p id="5c29" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">3.<code class="eh kj kk kl km b"><strong class="jm hv">instance._bootSync()</strong></code></p><p id="f9e4" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">就像它<code class="eh kj kk kl km b">Ember.Application</code>一样，我们有<code class="eh kj kk kl km b">_bootSync()</code>方法来设置<code class="eh kj kk kl km b">Ember.ApplicationInstance.</code>的实例，它有如下代码:</p><pre class="iz ja jb jc fq kn km ko kp aw kq dt"><span id="052f" class="kr ks hu km b fv kt ku l kv kw">Ember.ApplicationInstance{<br/>  //other methods and variables<br/>  ....<br/>  _bootSync(){<br/>    this.setupRegistry();<br/>    //define root element<br/>    //define location<br/>    this.runInstanceIntializers(){<br/>      if(isInteractive){<br/>        this.setupEventDispatcher();<br/>      }<br/>    }<br/>  }<br/>  ....<br/>  //other methods and variables<br/>  ....<br/>  startRouting() {<br/>    let initialURL = get(this, 'initialURL');<br/>    if (this.setupRouter()) {<br/>      if (initialURL === undefined) {<br/>        initialURL = get(this, 'location').getURL();<br/>      }<br/>      let initialTransition = this.handleURL(initialURL);<br/>    }<br/>  }<br/>  ....<br/>  //other methods and variables<br/>}</span></pre><p id="8ff4" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated"><code class="eh kj kk kl km b">this.setupRegistry()</code>确保实例所需的所有工厂都已正确注册。如果任何需要的工厂没有注册，那么它会在这个过程中注册。</p><p id="adfc" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated"><code class="eh kj kk kl km b">this.runInstanceInitializers()</code>用于定义根元素和实例将被呈现的位置。我们还可以指定监听什么类型的事件来检测导航。一旦知道了呈现元素和根元素的位置，就可以使用实例初始化器来初始化实例。</p><p id="714b" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated"><code class="eh kj kk kl km b">isInteractive</code>是应用程序准备好监听<strong class="jm hv">事件委托中提到的事件的阶段。</strong>如果应用程序仍在获取一些资源，则其<code class="eh kj kk kl km b">isInteractive</code>被设置为假，因此没有事件调度程序在工作。当我们的应用程序准备好监听事件时，它的<code class="eh kj kk kl km b">isInteractive</code>被设置为true，并且使用<code class="eh kj kk kl km b">setupEventDispatcher()</code>设置事件调度程序。它设置了全局事件调度程序，能够监听所有事件。</p><p id="8685" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">至此<code class="eh kj kk kl km b">_bootSycn()</code>完成，接下来发生的事情是路由。</p><p id="31fd" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">4.<code class="eh kj kk kl km b"><strong class="jm hv">startRouting()</strong></code></p><p id="bc3f" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">在这里，URL的路由开始。在此阶段，在<code class="eh kj kk kl km b">Ember.Application</code>初始化期间为路由设置的内容实际上在浏览器上可见。应用程序能够根据应用程序状态(router.js)更改URL。</p><p id="ed7c" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">它初始化当前路由器实例，并设置由实例“位置”实现使用的改变处理事件监听器。名为<code class="eh kj kk kl km b">initialURL</code>的属性将用于确定初始URL。如果找不到值，将使用`/'。在任何状态改变时，<code class="eh kj kk kl km b">get(this, ‘location’).getURL()</code>获取浏览器需要指向的新url，而<code class="eh kj kk kl km b">this.handleURL(initialURL)</code>更新该url。</p><p id="df83" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">这是所有的乡亲，希望这使了解余烬启动更好。</p><p id="4e44" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">感谢阅读。</p><p id="0565" class="pw-post-body-paragraph jk jl hu jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">来源:<a class="ae ki" href="https://github.com/emberjs/ember.js/" rel="noopener ugc nofollow" target="_blank"> Ember github页面</a>和<a class="ae ki" href="https://www.youtube.com/watch?v=BEteW2srG0w" rel="noopener ugc nofollow" target="_blank">穿越Ember.js Glue的旅程:由Mike North启动</a></p><div class="iz ja jb jc fq ab cb"><figure class="lh jd li lj lk ll lm paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="lh jd li lj lk ll lm paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="lh jd li lj lk ll lm paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ln lo lp"><p id="f922" class="jk jl lg jm b jn jo jp jq jr js jt ju lq jw jx jy lr ka kb kc ls ke kf kg kh hn dt translated"><a class="ae ki" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ki" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ki" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae ki" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jk jl lg jm b jn jo jp jq jr js jt ju lq jw jx jy lr ka kb kc ls ke kf kg kh hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ki" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ki" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="iz ja jb jc fq jd fe ff paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="fe ff lt"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>