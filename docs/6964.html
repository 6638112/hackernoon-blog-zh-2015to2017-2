<html>
<head>
<title>Need for Speed: How We Optimized Performance in the Joget Workflow v6 Platform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对速度的需求:我们如何在Joget Workflow v6平台中优化性能</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/need-for-speed-how-we-optimized-performance-in-the-joget-workflow-v6-platform-efc565f8e8d8?source=collection_archive---------22-----------------------#2017-10-11">https://medium.com/hackernoon/need-for-speed-how-we-optimized-performance-in-the-joget-workflow-v6-platform-efc565f8e8d8?source=collection_archive---------22-----------------------#2017-10-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/aaf727774c83bbe698b5fac20a317109.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jPQCT043wUs04lFT."/></div></div></figure><p id="d096" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作为一个<a class="ae ka" href="https://hackernoon.com/tagged/open-source" rel="noopener ugc nofollow" target="_blank">开源</a> <a class="ae ka" href="https://www.joget.org/" rel="noopener ugc nofollow" target="_blank">的低代码/无代码应用平台</a>，Joget Workflow让非编码人员和编码人员都可以可视化地快速构建应用。然而，在这种简单的背后，有很多事情在进行，性能一直是优先考虑的问题。重点是为应用程序提供一个快速的运行时，我们努力确保在平台层面上有尽可能少的开销。</p><p id="20c4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Joget团队一直在努力开发<a class="ae ka" href="https://www.joget.org/joget-workflow-v6/" rel="noopener ugc nofollow" target="_blank"> Joget Workflow v6 </a>，目前处于公开测试阶段。我们最近一直在寻找进一步简化和优化平台性能的方法。</p><p id="2af0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这篇技术文章详细介绍了在最新的测试版中是如何做到这一点的，并且可以为您自己的项目或产品提供有用的提示。这篇文章非常专业，面向对平台内部工作感兴趣的开发人员。让我们来看看引擎盖下。</p><h1 id="df61" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">服务器端代码分析</h1><p id="87d3" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">Joget平台是基于Java构建的，所以只需在Google上搜索一下，就可以获得大量的代码分析工具。在我们的<a class="ae ka" href="https://hackernoon.com/tagged/development" rel="noopener ugc nofollow" target="_blank">开发</a>环境中，我们使用了<a class="ae ka" href="https://profiler.netbeans.org/" rel="noopener ugc nofollow" target="_blank"> Netbeans Profiler </a>，这是一个集成到NetBeans IDE中的全功能Java分析工具。</p><p id="c32d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">早在2014年，我们就已经对v4进行了性能分析。这里有一个在采样时发现的热点的截图。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff le"><img src="../Images/8abf357fd670288a20f0d96aa7c17c30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qoa_-Kc7zhtWsUQg."/></div></div><figcaption class="lj lk fg fe ff ll lm bd b be z ek">v4 Snapshot Hot Spots</figcaption></figure><p id="4742" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">自v4版本以来，通过代码优化和适当的缓存，所有这些突出的热点和瓶颈都已消除。</p><p id="403e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在最新的v6快照中，我们发现了几个控制器方法中的一些额外的热点，它们可能是优化的候选对象。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff le"><img src="../Images/80ded8f0b54829608da011832b368ec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*k_niv9VeJynW1KDX."/></div></div><figcaption class="lj lk fg fe ff ll lm bd b be z ek">v6 Snapshot Pre-Optimization Hot Spots</figcaption></figure><p id="86b2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">方法调用实际上非常快，但似乎有很多调用，所以我们决定尝试使用<a class="ae ka" href="http://www.ehcache.org/" rel="noopener ugc nofollow" target="_blank"> Ehcache库</a>实现一些重构和缓存，以减少所需的调用数量。</p><p id="a6d8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">优化后的结果显示，所有这些调用都被避免了，这将减少高负载下的CPU周期。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff le"><img src="../Images/aea0e805ab02efd3b57a6747f5b0282f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jU-IYvD-kFbAZ47O."/></div></div><figcaption class="lj lk fg fe ff ll lm bd b be z ek">v6 Snapshot Post-Optimization Hot Spots</figcaption></figure><p id="58d0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所有可避免的服务器端热点看起来都已经被消除了，所以接下来我们转移到客户端浏览器渲染部分的性能。</p><h1 id="e9f6" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">客户端浏览器关键渲染路径和感知速度测量</h1><p id="340f" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">使用Chrome 60中引入的由Lighthouse支持的新<a class="ae ka" href="https://developers.google.com/web/updates/2017/05/devtools-release-notes#lighthouse" rel="noopener ugc nofollow" target="_blank">谷歌Chrome审计</a>面板，我们运行了一系列测试，以测量使用最新<a class="ae ka" href="https://material.io/guidelines/" rel="noopener ugc nofollow" target="_blank">材料设计</a>灵感<a class="ae ka" href="https://dev.joget.org/community/display/KBv6/V6+Universal+Theme" rel="noopener ugc nofollow" target="_blank"> v6通用主题</a>的Joget应用程序的质量。</p><p id="6937" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是我们开始优化之前的审计结果:</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff le"><img src="../Images/8131f8ee81e216aef2af09e1e38b19ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NAkBSP9LEohhBDS4."/></div></div><figcaption class="lj lk fg fe ff ll lm bd b be z ek">Pre-Optimization Performance Audit</figcaption></figure><p id="c2ca" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">性能得分很低，只有36分，对于4秒钟后才看到UI的第一个有意义的绘制的用户来说，感知速度很慢。哎哟！为什么会发生这种情况？</p><p id="c2a1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用Chrome DevTools <a class="ae ka" href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference" rel="noopener ugc nofollow" target="_blank">性能分析</a>，我们发现<a class="ae ka" href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/" rel="noopener ugc nofollow" target="_blank">关键渲染路径</a>没有优化。这仅仅意味着浏览器必须做很多工作，比如加载和解析HTML、脚本和CSS，然后才能向用户呈现一些东西。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff le"><img src="../Images/0ce69ac8864cc7b19cc97cc6013795da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MOfQMvrzRTMyRPfs."/></div></div><figcaption class="lj lk fg fe ff ll lm bd b be z ek">Pre-Optimization Performance Analysis</figcaption></figure><p id="0ad4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这种特殊情况下:</p><ul class=""><li id="26e6" class="ln lo hu je b jf jg jj jk jn lp jr lq jv lr jz ls lt lu lv dt translated">有一个客户端AJAX请求来处理一个少于<a class="ae ka" href="http://lesscss.org/" rel="noopener ugc nofollow" target="_blank">的CSS </a>文件，并且</li><li id="8ef8" class="ln lo hu je b jf lw jj lx jn ly jr lz jv ma jz ls lt lu lv dt translated">在能够执行第一次有意义的绘制之前，当浏览器需要加载所有资源文件(脚本、CSS等)时，出现了阻塞。</li><li id="b105" class="ln lo hu je b jf lw jj lx jn ly jr lz jv ma jz ls lt lu lv dt translated">在onload和document ready事件中有一些阻塞的JavaScript函数。</li></ul><p id="3343" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所有这些因素共同延迟了页面的呈现，因此影响了用户对页面加载速度的感知。</p><p id="f924" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">发现这些问题后，我们开始着手解决它们:</p><ul class=""><li id="599d" class="ln lo hu je b jf jg jj jk jn lp jr lq jv lr jz ls lt lu lv dt translated">使用<a class="ae ka" href="https://github.com/asual/lesscss-engine" rel="noopener ugc nofollow" target="_blank"> LESS引擎</a>将LESS CSS处理移至服务器端并缓存。</li><li id="0220" class="ln lo hu je b jf lw jj lx jn ly jr lz jv ma jz ls lt lu lv dt translated">我们通过利用<a class="ae ka" href="https://bitsofco.de/async-vs-defer/" rel="noopener ugc nofollow" target="_blank">异步加载脚本</a>以及<a class="ae ka" href="https://github.com/filamentgroup/loadCSS" rel="noopener ugc nofollow" target="_blank"> CSS </a>移除了不必要的资源加载阻塞。</li><li id="d870" class="ln lo hu je b jf lw jj lx jn ly jr lz jv ma jz ls lt lu lv dt translated">在onload和document ready事件期间调用的非关键JavaScript函数被修改为使用<a class="ae ka" href="https://www.w3schools.com/jsref/met_win_settimeout.asp" rel="noopener ugc nofollow" target="_blank"> setTimeout </a>异步调用。</li></ul><p id="3d90" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">进行更改后，运行Chrome性能分析得出以下结果:</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff le"><img src="../Images/a8b4348a9cb855d9d40bd1e03c97c746.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*O7RwGzMRpjSiFcB_."/></div></div><figcaption class="lj lk fg fe ff ll lm bd b be z ek">Post-Optimization Performance Analysis</figcaption></figure><p id="864d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">渲染速度有很大差异，第一次有意义的绘制时间大幅下降。绩效审计也显示出显著的改进。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff le"><img src="../Images/3a52d4b1b7b783841a99861e0c7f6d98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QIHamNF62E2z1WQn."/></div></div><figcaption class="lj lk fg fe ff ll lm bd b be z ek">Post-Optimization Performance Audit</figcaption></figure><h1 id="f925" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">那么，优化的结果是什么呢？</h1><p id="5a2f" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们使用<a class="ae ka" href="http://jmeter.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache JMeter </a>运行了一个负载测试，以比较当前稳定版本的Joget Workflow v5与最新版本的优化版本6代码的性能。在Apache Tomcat 8.5.16上运行混合用例测试应用程序，吞吐量(每秒请求数)提高了26.2%，因此看起来优化是有回报的。如果听起来不多，那可能是因为以前的版本已经进行了很好的优化，最新的优化工作挤出了剩余的低效部分。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mb"><img src="../Images/3852e7c9b43c9dd0efb9c992931a2ebf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hkffdibVf2Tom_Bi."/></div></div><figcaption class="lj lk fg fe ff ll lm bd b be z ek">Throughput Comparison</figcaption></figure><h1 id="4c7a" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">下一步是什么</h1><p id="ba50" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">由于强调平台级的性能优化，Joget Workflow在运行应用程序时开销较低。从v4开始就是这样，甚至在即将到来的v6中也有所改进。</p><p id="c434" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果有任何特定的瓶颈，通常是在应用程序级别。在应用程序级别，在<a class="ae ka" href="https://dev.joget.org/community/display/KBv6/Joget+Workflow+v6+Knowledge+Base" rel="noopener ugc nofollow" target="_blank"> Joget工作流知识库</a>的<a class="ae ka" href="https://dev.joget.org/community/display/KBv6/Performance+Optimization+and+Scalability+Tips" rel="noopener ugc nofollow" target="_blank">性能优化和可伸缩性技巧</a>文章中提供了各种指南和最佳实践。v6还提供了<a class="ae ka" href="https://dev.joget.org/community/display/KBv6/Performance+Analyzer" rel="noopener ugc nofollow" target="_blank">性能分析器</a>，并引入了易于使用的缓存功能，如<a class="ae ka" href="https://dev.joget.org/community/display/KBv6/Performance+Improvement+with+Userview+Caching" rel="noopener ugc nofollow" target="_blank">使用用户视图缓存提高性能</a>中所述。</p><p id="d7ba" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要了解更多信息并开始使用Joget工作流，请访问<a class="ae ka" href="https://www.joget.org/" rel="noopener ugc nofollow" target="_blank">https://www.joget.org</a></p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="mc md l"/></div></figure></div></div>    
</body>
</html>