<html>
<head>
<title>Node8’s util.promisify is so freakin’ awesome!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node8的util.promisify太牛逼了！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/node8s-util-promisify-is-so-freakin-awesome-1d90c184bf44?source=collection_archive---------1-----------------------#2017-09-27">https://medium.com/hackernoon/node8s-util-promisify-is-so-freakin-awesome-1d90c184bf44?source=collection_archive---------1-----------------------#2017-09-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/c0e6f41540eba0d296972c0aee688f0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WGs_j1qUOupeLNVqkApUSQ.png"/></div></div></figure><p id="bb49" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在本指南中，你将学习如何使用Node的<code class="eh ka kb kc kd b">util.promisify</code>来保证你自己的功能。这个实用函数包含在NodeJS版本8中。如果你打算遵循这个指南，你需要安装最新版本。作为额外的收获，我还会告诉你如何使用<code class="eh ka kb kc kd b">promisify</code>和<code class="eh ka kb kc kd b">await</code>和<code class="eh ka kb kc kd b">async</code>。</p><h1 id="8039" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">TLDR；</h1><ul class=""><li id="7e24" class="lc ld hu je b jf le jj lf jn lg jr lh jv li jz lj lk ll lm dt translated"><code class="eh ka kb kc kd b">util.promisify</code>将常规函数转换成异步函数，即返回承诺的函数</li><li id="9ba1" class="lc ld hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">传递给<code class="eh ka kb kc kd b">util.promisify</code>的函数必须遵循NodeJS回调风格。该函数必须传递一个回调函数作为最后一个参数，并且该回调函数必须按以下顺序接受以下参数:<code class="eh ka kb kc kd b">(err, value) =&gt; { /* … */ }</code></li><li id="4842" class="lc ld hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">promise函数可以与<code class="eh ka kb kc kd b">await</code>和<code class="eh ka kb kc kd b">async</code>一起使用，以帮助避免混乱的promise链，并引入一种更干净、更合理的方式来进行异步编程。</li></ul><h1 id="6270" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">util.promisify是做什么的？</h1><p id="6c3e" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz hn dt translated">官方节点文档说:</p><blockquote class="lv lw lx"><p id="951d" class="jc jd ly je b jf jg jh ji jj jk jl jm lz jo jp jq ma js jt ju mb jw jx jy jz hn dt translated">取一个遵循common Node.js回调风格的函数，即取一个<code class="eh ka kb kc kd b">(err, value) =&gt; ...</code>回调作为最后一个参数，返回一个返回promises的版本。</p></blockquote><p id="152d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还有…</p><blockquote class="lv lw lx"><p id="8a09" class="jc jd ly je b jf jg jh ji jj jk jl jm lz jo jp jq ma js jt ju mb jw jx jy jz hn dt translated"><code class="eh ka kb kc kd b">promisify(original)</code>假设<code class="eh ka kb kc kd b">original</code>是一个在所有情况下都以回调作为最终参数的函数，如果不这样，返回的函数将导致未定义的行为。</p></blockquote><p id="5b0a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以基本上它是一个效用函数，接受一个常规函数，并将其转换为一个返回承诺的函数。</p><p id="1642" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">传递给<code class="eh ka kb kc kd b">util.promisify</code>的函数必须遵循几个约定:</p><ol class=""><li id="f22d" class="lc ld hu je b jf jg jj jk jn mc jr md jv me jz mf lk ll lm dt translated">传递给<code class="eh ka kb kc kd b">promisify</code>的函数的最后一个参数必须是回调。</li><li id="71ca" class="lc ld hu je b jf ln jj lo jn lp jr lq jv lr jz mf lk ll lm dt translated">回调必须遵循节点的回调样式。</li></ol><p id="9e72" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是一个有效函数的示例:</p><figure class="mg mh mi mj fq iv"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="c5f7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">注意:</strong>对于不熟悉语法的人，我使用的是<a class="ae mm" href="https://github.com/lukehoban/es6features" rel="noopener ugc nofollow" target="_blank"> ES6 </a>。我也使用Airbnb风格指南。</p><p id="037e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了演示<code class="eh ka kb kc kd b">util.promisify</code>如何工作，让我们从创建一个在很长一段时间内执行任务的常规函数开始。然后，我们将把这个功能转换成一个承诺。</p><h1 id="5768" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">创建常规函数</h1><p id="04f8" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz hn dt translated">下面我有一个函数叫<code class="eh ka kb kc kd b">wait</code>。它的目的是让你等待一段未知的时间:</p><figure class="mg mh mi mj fq iv"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="d5e5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">出于演示的目的，我编写了等待一段未知时间的函数。它通过使用<code class="eh ka kb kc kd b">setInterval</code>每隔<code class="eh ka kb kc kd b">x</code>秒调用一个匿名函数，并将该数字与一组值进行比较，以决定是继续等待还是停止:</p><ul class=""><li id="f23a" class="lc ld hu je b jf jg jj jk jn mc jr md jv me jz lj lk ll lm dt translated">如果数字大于<code class="eh ka kb kc kd b">0.95</code>，函数将停止运行，并调用回调函数。</li><li id="e6b0" class="lc ld hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">如果数字小于<code class="eh ka kb kc kd b">0.01</code>，一个错误将被传递给回调函数。</li><li id="2d8f" class="lc ld hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">最后，如果随机数在范围内，一条消息将被打印到STDOUT。</li></ul><h1 id="af38" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">NodeJS回调样式</h1><p id="2505" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz hn dt translated"><code class="eh ka kb kc kd b">util.promisify</code>期望一个符合NodeJS回调风格的函数。要了解更多关于Node回调风格的信息，请阅读本文:<a class="ae mm" href="http://fredkschott.com/post/2014/03/understanding-error-first-callbacks-in-node-js/" rel="noopener ugc nofollow" target="_blank">The Node . js Way——理解错误优先回调</a></p><p id="c4e0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<code class="eh ka kb kc kd b">wait</code>函数中，你会注意到我用了两种不同的方式来使用回调。当随机数大于<code class="eh ka kb kc kd b">0.95</code>时，这被认为是成功的，等待结束。因此我们可以这样调用回调函数:</p><pre class="mg mh mi mj fq mn kd mo mp aw mq dt"><span id="903f" class="mr kf hu kd b fv ms mt l mu mv">callback(null, ‘Congratulations, you have finished waiting.’);</span></pre><p id="b146" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里我将<code class="eh ka kb kc kd b">null</code>传递给了第一个参数。没有发生错误。没什么可报告的。使用第二个参数，我传递一些在回调或承诺链中可用的数据。</p><p id="9d7b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当<code class="eh ka kb kc kd b">wait</code>功能失败时(在这种情况下，当随机数低于<code class="eh ka kb kc kd b">0.01</code>时)，错误消息被传递给第一个参数。第二个参数设置为<code class="eh ka kb kc kd b">null</code>。</p><pre class="mg mh mi mj fq mn kd mo mp aw mq dt"><span id="7385" class="mr kf hu kd b fv ms mt l mu mv">callback(‘Could not wait any longer!’, null);</span></pre><p id="cc3c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这遵循节点的回调风格。</p><h1 id="886f" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">使用</h1><p id="a20f" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz hn dt translated">这个函数是这样调用的:</p><figure class="mg mh mi mj fq iv"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="bbf7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该函数需要两个参数。第一个是在<code class="eh ka kb kc kd b">setInterval</code>调用回调函数之前等待的毫秒数。第二个参数是回调。</p><p id="52f8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意我是如何检查错误的:<code class="eh ka kb kc kd b">if (err) throw new Error(err)</code> …如果<code class="eh ka kb kc kd b">err</code>是<code class="eh ka kb kc kd b">null</code>，回调继续。否则会引发异常。</p><h1 id="0437" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">试运转</h1><p id="3c60" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz hn dt translated">运行上述代码会在成功时产生以下输出:</p><figure class="mg mh mi mj fq iv"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="56df" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">…以及错误时的以下输出:</p><figure class="mg mh mi mj fq iv"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="d36f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们确认函数如预期的那样运行。接下来我们将把它变成一个承诺。</p><h1 id="2a15" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">承诺正则函数</h1><p id="bd91" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz hn dt translated">神奇的事情就发生在这里。</p><p id="7dda" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们有了一个普通的函数，我可以演示如何把它变成一个返回承诺的函数。这出奇的简单…</p><figure class="mg mh mi mj fq iv"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="d53c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就是这样。在两行代码中，我将函数转换为承诺。第7到9行显示了如何使用新的承诺。你会同意它更干净，更容易阅读。</p><h1 id="84cc" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">引入异步和等待</h1><p id="6813" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz hn dt translated">等等，我们还没说完。我有更多有趣的东西要和你分享。Node 8还提供了对<code class="eh ka kb kc kd b">async</code>和<code class="eh ka kb kc kd b">await</code>的支持。太酷了。</p><p id="3d97" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">除了使用承诺链(这很快就会变得非常混乱)，您还可以用正常的过程化风格编写代码，如下所示:</p><figure class="mg mh mi mj fq iv"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="bb18" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不再有承诺链:)</p><p id="30ab" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">关于async/await的更多信息，我强烈推荐以下文章:<a class="ae mm" href="https://blog.risingstack.com/mastering-async-await-in-nodejs/" rel="noopener ugc nofollow" target="_blank">https://blog . rising stack . com/mastering-async-await-in-nodejs/</a></p><h1 id="34c8" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt">😊</h1><p id="48c4" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz hn dt translated">附言:如果你在推特上，给我一个关注。我经常写关于软件开发和安全的文章:【https://twitter.com/JamesJefferyUK T4】</p></div></div>    
</body>
</html>