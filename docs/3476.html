<html>
<head>
<title>Code Splitting for React Router with Webpack and HMR</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有Webpack和HMR的React路由器的代码拆分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/code-splitting-for-react-router-with-webpack-and-hmr-bb509968e86f?source=collection_archive---------1-----------------------#2017-04-04">https://medium.com/hackernoon/code-splitting-for-react-router-with-webpack-and-hmr-bb509968e86f?source=collection_archive---------1-----------------------#2017-04-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/dcecef5204c33957b95e1b955a46ecab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*74w0uj8zZAkz2h8NJPw1pw.jpeg"/></div></div></figure><p id="649c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">在本指南中，我们将创建一个</em> <a class="ae kb" href="https://github.com/mozilla-neutrino/react-router-starter" rel="noopener ugc nofollow" target="_blank"> <em class="ka">启动器应用程序</em> </a> <em class="ka">，它使用带代码拆分的路线。</em></p><p id="22a3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于大型web应用程序，将所有代码放在一个文件中是没有效率的。大型应用应该只下载启动应用所需的<a class="ae kb" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>。我们希望能够将单个文件分成许多片段。将你的代码分割成多个块就是我们所说的“代码分割”。当用户四处导航时，块将被加载。</p><p id="7c53" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae kb" href="https://neutrino.js.org/" rel="noopener ugc nofollow" target="_blank">中微子</a>，将被用来看看我们如何用React、Webpack和React路由器实现代码拆分。Neutrino是一个非常棒的工具，它利用Webpack的强大功能，让您在零初始配置的情况下创建和构建现代JavaScript应用程序。它的工作原理是允许我们注入共享的预置或配置。我们将使用反应预设。后者需要你在Node.js v6.9+上。根据<a class="ae kb" href="https://neutrino.js.org/presets/neutrino-preset-react/" rel="noopener ugc nofollow" target="_blank">中微子文件</a>，React预置特性:</p><ul class=""><li id="5997" class="kc kd hu je b jf jg jj jk jn ke jr kf jv kg jz kh ki kj kk dt translated">现代巴别塔编译支持ES模块，最近两个主要的浏览器版本，异步功能和动态导入</li><li id="87b0" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kh ki kj kk dt translated">支持导入CSS、HTML、图像、字体和图标</li><li id="e62f" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kh ki kj kk dt translated">摇动树木以产生更小的束</li><li id="54d8" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kh ki kj kk dt translated">热模块替换，没有HTML模板，等等</li></ul><p id="6d01" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这篇文章的全部源代码可以在GitHub 上找到。事不宜迟，我们开始吧。</p><p id="2fc5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，我们需要一个目录来开始工作。从您的终端，创建一个新的目录，并进入其中。然后我们将安装<code class="eh kq kr ks kt b">neutrino</code>、<code class="eh kq kr ks kt b">neutrino-preset-react</code>和<code class="eh kq kr ks kt b">react-hot-loader</code>作为开发依赖项。我们还需要<code class="eh kq kr ks kt b">react</code>、<code class="eh kq kr ks kt b">react-dom</code>和<code class="eh kq kr ks kt b">react-router-dom</code>进行实际的React开发。<code class="eh kq kr ks kt b">react-hot-loader@3.0.0-beta-6</code>是撰写本文时的最新版本。</p><pre class="ku kv kw kx fq ky kt kz la aw lb dt"><span id="6c8a" class="lc ld hu kt b fv le lf l lg lh">❯ mkdir react-code-splitting<br/>❯ cd react-code-splitting/<br/>❯ yarn add --dev neutrino neutrino-preset-react<br/>❯ yarn add --dev react-hot-loader<a class="ae kb" href="http://twitter.com/3" rel="noopener ugc nofollow" target="_blank">@3</a>.0.0-beta.6<br/>❯ yarn add react react-dom <!-- -->react-router-dom</span></pre><p id="d6df" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">默认情况下，React预置在主入口点为<code class="eh kq kr ks kt b">index.js</code>的<code class="eh kq kr ks kt b">src</code>目录中查找源代码。</p><pre class="ku kv kw kx fq ky kt kz la aw lb dt"><span id="0691" class="lc ld hu kt b fv le lf l lg lh">❯<!-- --> mkdir src &amp;&amp; touch src/index.js</span></pre><p id="cc5a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们用一个简单的hello world例子来编辑<code class="eh kq kr ks kt b">index.js</code>。我们稍后会更改该文件，但现在，为了测试最低限度，我们将保持它的简单。</p><pre class="ku kv kw kx fq ky kt kz la aw lb dt"><span id="ea89" class="lc ld hu kt b fv le lf l lg lh">import React from 'react';<br/>import { render } from 'react-dom';<br/><br/>render(&lt;h1&gt;Hello world!&lt;/h1&gt;, document.getElementById('root'));</span></pre><p id="2b31" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在编辑项目的<code class="eh kq kr ks kt b">package.json</code>,添加启动和构建应用程序的命令:</p><pre class="ku kv kw kx fq ky kt kz la aw lb dt"><span id="2092" class="lc ld hu kt b fv le lf l lg lh">{<br/>  "scripts": {<br/>    "start": "neutrino start --use neutrino-preset-react",<br/>    "build": "neutrino build --use neutrino-preset-react"<br/>  },<br/>  "devDependencies": {<br/>    "neutrino": "^5.2.0",<br/>    "neutrino-preset-react": "^5.2.0"<br/>  },<br/>  "dependencies": {<br/>    "react": "^15.4.2",<br/>    "react-dom": "^15.4.2",<br/>    "react-hot-loader": "3.0.0-beta.6",<br/>    "react-router-dom": "^4.0.0"<br/>  }<br/>}</span></pre><p id="cfec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">启动应用程序，然后在控制台中打开浏览器访问该地址。</p><pre class="ku kv kw kx fq ky kt kz la aw lb dt"><span id="df6e" class="lc ld hu kt b fv le lf l lg lh">❯ yarn start<br/>✔ Development server running on: http://localhost:5000<br/>✔ Build completed</span></pre><figure class="ku kv kw kx fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/870e436d1a7579c9e255798fdec9061f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CgA9AEhNtEm6cjKxAK-cDw.png"/></div></div></figure><p id="185f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">太好了，我们现在可以像真正的忍者一样分解代码了:-)</p><p id="5a9f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为支持热模块更换(HMR)，将先前创建的文件<code class="eh kq kr ks kt b">index.js</code>更改为以下内容:</p><pre class="ku kv kw kx fq ky kt kz la aw lb dt"><span id="a948" class="lc ld hu kt b fv le lf l lg lh">// index.js</span><span id="0598" class="lc ld hu kt b fv li lf l lg lh">import React from 'react';<br/>import { render } from 'react-dom';<br/>import { AppContainer } from 'react-hot-loader';<br/><br/>import <em class="ka">App </em>from './App';<br/><br/>const <em class="ka">renderApp </em>= () =&gt; {<br/>  render(<br/>    &lt;AppContainer&gt;<br/>      &lt;App /&gt;<br/>    &lt;/AppContainer&gt;,<br/>    document.getElementById('root'),<br/>  );<br/>};<br/><br/>// This is needed for Hot Module Replacement<br/>if (module.hot) {<br/>  module.hot.accept('./App', () =&gt; <em class="ka">renderApp</em>());<br/>}<br/><br/><em class="ka">renderApp</em>();</span></pre><p id="3680" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们添加了<code class="eh kq kr ks kt b">AppContainer</code>来指定我们希望HMR应用程序的哪一部分，并添加了<code class="eh kq kr ks kt b">if</code>语句来在开发模式下激活它。我们还导入了下一步要创建的<code class="eh kq kr ks kt b">App.js</code>。</p><pre class="ku kv kw kx fq ky kt kz la aw lb dt"><span id="1b98" class="lc ld hu kt b fv le lf l lg lh">// App.js</span><span id="d2b4" class="lc ld hu kt b fv li lf l lg lh">import React from 'react';<br/>import { BrowserRouter as Router, Route, Link } from 'react-router-dom';<br/>import asyncComponent from './components/asyncComponent';<br/><br/>const Page1 = asyncComponent(() =&gt; import('./components/Page1')<br/>  .then(module =&gt; module.default), { name: 'Page 1' });<br/>const Page2 = asyncComponent(() =&gt; import('./components/Page2')<br/>  .then(module =&gt; module.default), { name: 'Page 2' });<br/>const Home = asyncComponent(() =&gt; import('./components/Home')<br/>  .then(module =&gt; module.default), { name: 'Home' });<br/><br/>const App = () =&gt; (<br/>  &lt;Router&gt;<br/>    &lt;div className="App"&gt;<br/>      &lt;ul&gt;<br/>        &lt;li&gt;&lt;Link to="/"&gt;Home&lt;/Link&gt;&lt;/li&gt;<br/>        &lt;li&gt;&lt;Link to="/page1"&gt;Page 1&lt;/Link&gt;&lt;/li&gt;<br/>        &lt;li&gt;&lt;Link to="/page2"&gt;Page 2&lt;/Link&gt;&lt;/li&gt;<br/>      &lt;/ul&gt;<br/><br/>      &lt;Route exact path="/" component={Home} /&gt;<br/>      &lt;Route path="/page1" component={Page1} /&gt;<br/>      &lt;Route path="/page2" component={Page2} /&gt;<br/>    &lt;/div&gt;<br/>  &lt;/Router&gt;<br/>);<br/><br/>export default App;</span></pre><p id="b629" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kq kr ks kt b">App.js</code>导入<code class="eh kq kr ks kt b">react-router-dom</code>并返回注入了<code class="eh kq kr ks kt b">routes</code>的路由器组件。</p><h1 id="b80e" class="lj ld hu bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf dt translated">动态路线</h1><p id="2c57" class="pw-post-body-paragraph jc jd hu je b jf mg jh ji jj mh jl jm jn mi jp jq jr mj jt ju jv mk jx jy jz hn dt translated">从您的终端创建要使用的路线。我们还需要<code class="eh kq kr ks kt b">asyncComponent.js</code>来延迟加载组件。</p><pre class="ku kv kw kx fq ky kt kz la aw lb dt"><span id="cfaa" class="lc ld hu kt b fv le lf l lg lh">❯ <!-- -->mkdir src/components<br/>❯ <!-- -->touch src/components/Page1.js<br/>❯ <!-- -->touch src/components/Page2.js<br/>❯ <!-- -->touch src/components/Home.js<br/>❯ <!-- -->touch src/components/asyncComponent.js</span></pre><p id="41e2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将填写路线的最低要求。</p><pre class="ku kv kw kx fq ky kt kz la aw lb dt"><span id="b806" class="lc ld hu kt b fv le lf l lg lh">// Page1.js</span><span id="3c87" class="lc ld hu kt b fv li lf l lg lh">import React from 'react';<br/><br/>const <em class="ka">Page1 </em>= (props) =&gt; &lt;h1&gt;{props.name}&lt;/h1&gt;;<br/><br/>export default <em class="ka">Page1</em>;</span><span id="7c61" class="lc ld hu kt b fv li lf l lg lh">// Page2.js</span><span id="576d" class="lc ld hu kt b fv li lf l lg lh">import React from 'react';<br/><br/>const <em class="ka">Page2 </em>= (props) =&gt; &lt;h1&gt;{props.name}&lt;/h1&gt;;<br/><br/>export default <em class="ka">Page2</em>;</span><span id="7b0a" class="lc ld hu kt b fv li lf l lg lh">// Home.js</span><span id="2958" class="lc ld hu kt b fv li lf l lg lh">import React from 'react';<br/><br/>const <em class="ka">Home </em>= (props) =&gt; &lt;h1&gt;{props.name}&lt;/h1&gt;;<br/><br/>export default <em class="ka">Home</em>;</span></pre><p id="3b48" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们快完成了。我们最后的任务是编写逻辑来延迟加载组件。我们将通过<code class="eh kq kr ks kt b">asyncComponent.js</code>来实现。</p><pre class="ku kv kw kx fq ky kt kz la aw lb dt"><span id="f426" class="lc ld hu kt b fv le lf l lg lh">// asyncComponent.js</span><span id="e84e" class="lc ld hu kt b fv li lf l lg lh">import React from 'react';<br/><br/>export default (loader, collection) =&gt; (<br/>  class AsyncComponent extends React.Component {<br/>    constructor(props) {<br/>      super(props);<br/><br/>      this.Component = null;<br/>      this.state = { Component: AsyncComponent.Component };<br/>    }<br/><br/>    componentWillMount() {<br/>      if (!this.state.Component) {<br/>        loader().then((Component) =&gt; {<br/>          AsyncComponent.Component = Component;<br/><br/>          this.setState({ Component });<br/>        });<br/>      }<br/>    }<br/><br/>    render() {<br/>      if (this.state.Component) {<br/>        return (<br/>          &lt;this.state.Component { ...this.props } { ...collection } /&gt;<br/>        )<br/>      }<br/><br/>      return null;<br/>    }<br/>  }<br/>);</span></pre><p id="43fc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们完事了。</p><h1 id="5b11" class="lj ld hu bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf dt translated"><strong class="ak">快速启动</strong></h1><p id="867f" class="pw-post-body-paragraph jc jd hu je b jf mg jh ji jj mh jl jm jn mi jp jq jr mj jt ju jv mk jx jy jz hn dt translated">用<code class="eh kq kr ks kt b">yarn start</code>启动app，然后打开浏览器到<code class="eh kq kr ks kt b"><a class="ae kb" href="http://localhost:3000." rel="noopener ugc nofollow" target="_blank">http://localhost:5000</a></code>。</p><pre class="ku kv kw kx fq ky kt kz la aw lb dt"><span id="563e" class="lc ld hu kt b fv le lf l lg lh">❯ yarn start<br/>✔ Development server running on: <a class="ae kb" href="http://localhost:5000" rel="noopener ugc nofollow" target="_blank">http://localhost:5000</a><br/>✔ Build completed</span></pre><figure class="ku kv kw kx fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/5d9cb8010b94886e3c311cfeaa981582.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*19BmQqKad8xzQYlPMhE0Ug.png"/></div></div></figure><p id="9a2c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">打开<a class="ae kb" href="https://hackernoon.com/tagged/network" rel="noopener ugc nofollow" target="_blank">网络</a>选项卡，查看正在缓慢加载的各个块。</p><figure class="ku kv kw kx fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ml"><img src="../Images/a894a7c2626bd95fc2a47e45d05bda7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uBN_6SBbOWKspX1TlunGKA.png"/></div></div></figure><h1 id="382c" class="lj ld hu bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf dt translated">建筑物</h1><p id="c89d" class="pw-post-body-paragraph jc jd hu je b jf mg jh ji jj mh jl jm jn mi jp jq jr mj jt ju jv mk jx jy jz hn dt translated">默认情况下，React预设会将静态资源构建到构建目录中。</p><figure class="ku kv kw kx fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mm"><img src="../Images/4aa200e6c9ce91392f847e996b5707c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ObUdys87n9QuS0YosaLXsg.png"/></div></div></figure></div><div class="ab cl mn mo hc mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hn ho hp hq hr"><p id="3e51" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，我们使用<a class="ae kb" href="https://github.com/mozilla-neutrino/neutrino-dev" rel="noopener ugc nofollow" target="_blank">中微子</a>卷起一个React应用程序，并将我们的代码分成多个块。我们还加入了HMR来注入更新的模块，而无需重新加载页面。完整代码见<a class="ae kb" href="https://github.com/mozilla-neutrino/react-router-starter" rel="noopener ugc nofollow" target="_blank">反应路由器启动器</a>。</p><div class="ku kv kw kx fq ab cb"><figure class="mu iv mv mw mx my mz paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mu iv mv mw mx my mz paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mu iv mv mw mx my mz paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="na nb nc"><p id="f922" class="jc jd ka je b jf jg jh ji jj jk jl jm nd jo jp jq ne js jt ju nf jw jx jy jz hn dt translated"><a class="ae kb" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kb" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kb" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae kb" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd ka je b jf jg jh ji jj jk jl jm nd jo jp jq ne js jt ju nf jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kb" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kb" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ku kv kw kx fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ng"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="ku kv kw kx fq iv"><div class="bz el l di"><div class="nh ni l"/></div></figure></div></div>    
</body>
</html>