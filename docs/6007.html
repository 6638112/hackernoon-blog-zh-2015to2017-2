<html>
<head>
<title>How to implement Dijkstra’s Algorithm in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用JavaScript实现Dijkstra的算法</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-implement-dijkstras-algorithm-in-javascript-abdfd1702d04?source=collection_archive---------0-----------------------#2017-08-29">https://medium.com/hackernoon/how-to-implement-dijkstras-algorithm-in-javascript-abdfd1702d04?source=collection_archive---------0-----------------------#2017-08-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="aa5a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我一直在读<a class="ae jp" href="https://www.manning.com/books/grokking-algorithms" rel="noopener ugc nofollow" target="_blank"> Grokking Algorithms </a>，我推荐给任何算法新手。基本上就是我几个月前就希望有的介绍了！书中的例子都是用<a class="ae jp" href="https://hackernoon.com/tagged/python" rel="noopener ugc nofollow" target="_blank"> Python </a>写的，所以我想分享一个<a class="ae jp" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>版本的<a class="ae jp" href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm" rel="noopener ugc nofollow" target="_blank"> Dijkstra的算法</a>。该算法使用有向加权图来确定到达一个节点的“最便宜”路径。</p><p id="02fd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我将把每个部分分成几个步骤，并提供一些背景信息。如果你喜欢只看代码，这里有<a class="ae jp" href="https://gist.github.com/stella-yc/49a7b96679ab3bf06e26421fc81b5636" rel="noopener ugc nofollow" target="_blank">要点的链接。</a></p><h1 id="ed4c" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">背景:什么是图？</h1><p id="7f6e" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">图形是一种抽象数据类型，用于对一组连接进行建模。例如，假设Bob在Twitter上关注Sarah和Lou。莎拉跟着林。楼跟着林和马克。我们可以用图表来表示这些联系。</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="fe ff kt"><img src="../Images/708159fed88c8ee6c1a704856bf8e261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZtgLYNcZENrjQY42Z5FGGQ.jpeg"/></div></div><figcaption class="lf lg fg fe ff lh li bd b be z ek">This graph illustrates a very basic Twitter network.</figcaption></figure><p id="f27e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每个人是一个<em class="lj">节点</em>，每个连接是一条<em class="lj">边。</em>每个节点可以连接到许多其他节点。图表可以<em class="lj">定向</em>，这样每个连接都是单向的，就像这个Twitter示例中一样——Bob关注Sarah，但是Sarah不关注Bob。图形也可以是<em class="lj">无向的</em>，这样连接是双向的。</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="fe ff lk"><img src="../Images/b1f50fe3e8c3cc3933c8efeb677779a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S8FtwB2w4PWBHLEwvOr5gA.jpeg"/></div></div></figure><p id="6fe8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">图中的边也可以<em class="lj">加权。</em>例如，在下图中，每个权重代表从一点到另一点的成本。</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="fe ff ll"><img src="../Images/cd3f59059e8be327b14fca52fd11d805.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y0ounZjSO5xd8NVFL5bQsw.jpeg"/></div></div></figure><h1 id="a543" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">挑战</h1><p id="7847" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">假设你正试图找出到达目的地的最便宜的方式，如下图所示。“开始”和“结束”之间的节点是你可以走的桥和路，权重是指你必须支付的通行费/汽油费。</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="fe ff lm"><img src="../Images/dbcbfea8c1d91172fd6d3a416cb9bf50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lzYuC6dIVTVl0gt3MOuCyw.jpeg"/></div></div><figcaption class="lf lg fg fe ff lh li bd b be z ek">Our problem we are trying to solve</figcaption></figure><p id="d0e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">乍一看，这看起来像事情会变得毛骨悚然！有许多不同的可能途径可供评估和比较。而且这个图相对简单——如果我们遇到一个更复杂的问题，有更多的节点和可能的路径呢？</p><p id="e127" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是Dijkstra的算法采用这个令人生畏的问题，并将其分解，使用几个简单的步骤来达到最终的解决方案。Dijkstra的算法也非常适合这个特殊的用例。用于表示可能路径的图是有向的和非循环的(意味着没有循环)。</p><h1 id="36dd" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">方法</h1><h2 id="7a03" class="ln jr hu bd js lo lp lq jw lr ls lt ka jc lu lv ke jg lw lx ki jk ly lz km ma dt translated"><strong class="ak"> <em class="mb">实施图</em> </strong></h2><p id="ea39" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">让我们弄清楚如何在我们的程序中实现这个图。我将使用嵌套的JavaScript对象:</p><pre class="ku kv kw kx fq mc md me mf aw mg dt"><span id="484b" class="ln jr hu md b fv mh mi l mj mk">const graph = {<br/>  start: {A: 5, B: 2},<br/>  A: {C: 4, D: 2},<br/>  B: {A: 8, D: 7},<br/>  C: {D: 6, finish: 3},<br/>  D: {finish: 1},<br/>  finish: {}<br/>};</span></pre><p id="731a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每个节点由图形对象中的键表示。每个键都有一个对象作为其值，表示直接邻居和到达该邻居的开销。</p><p id="1e23" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，节点<strong class="it hv"> A </strong>连接到节点<strong class="it hv"> C </strong>和<strong class="it hv"> D </strong>。节点<strong class="it hv"> A </strong>是节点<strong class="it hv"> C </strong>和<strong class="it hv"> D、</strong>的“父节点”,它们是节点<strong class="it hv"> A. </strong>的“子节点”</p><h2 id="5342" class="ln jr hu bd js lo lp lq jw lr ls lt ka jc lu lv ke jg lw lx ki jk ly lz km ma dt translated"><strong class="ak">理解算法</strong></h2><p id="6ba7" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">现在让我们概述一下Dijkstra算法的主要步骤。</p><ol class=""><li id="9642" class="ml mm hu it b iu iv iy iz jc mn jg mo jk mp jo mq mr ms mt dt translated">找到“最便宜”的节点。</li><li id="dbf6" class="ml mm hu it b iu mu iy mv jc mw jg mx jk my jo mq mr ms mt dt translated">更新此节点的直接邻居的开销。</li><li id="15cb" class="ml mm hu it b iu mu iy mv jc mw jg mx jk my jo mq mr ms mt dt translated">重复步骤1和2，直到对每个节点都完成了这一步。</li><li id="8a24" class="ml mm hu it b iu mu iy mv jc mw jg mx jk my jo mq mr ms mt dt translated">返回到达该节点的最低成本，以及到达该节点的最佳路径。</li></ol><p id="1aaa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，如果我们从<strong class="it hv"> start </strong>开始，我们拥有的前两个节点是<strong class="it hv"> A </strong>成本为5，以及<strong class="it hv"> B </strong>成本为2。<strong class="it hv"> B </strong>是最便宜的节点。除了完成，这些是我们目前所知的唯一节点。由于我们还不知道<strong class="it hv">结束</strong>的成本，我们将它设为无穷大。</p><p id="038e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">已经有很多东西需要跟踪了，而且我们只从第一个节点开始！为什么我们不用一种新的数据结构来记录到达每个节点的最低成本？</p><p id="eba5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将使用一个对象来跟踪它。到目前为止，它看起来像这样:</p><pre class="ku kv kw kx fq mc md me mf aw mg dt"><span id="d053" class="ln jr hu md b fv mh mi l mj mk">const costs = {<br/>  A: 5,<br/>  B: 2,<br/>  finish: Infinity<br/>};</span></pre><p id="2573" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但我们不只是想知道到达终点节点需要多少成本。我们想知道我们需要走哪条路才能到达那里！这需要使用另一种数据结构来保持<strong class="it hv">对每个节点的父节点的跟踪。当一个节点有许多可能的父节点时，我们将只保留成本最低的父节点。</strong></p><p id="e44d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是我们如何从起点到终点回溯最便宜的路径。</p><pre class="ku kv kw kx fq mc md me mf aw mg dt"><span id="9d88" class="ln jr hu md b fv mh mi l mj mk">const parents = {<br/>  A: 'start', <br/>  B: 'start', <br/>  finish: null<br/>};</span></pre><p id="9f89" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们还不知道到达<strong class="it hv">完成</strong>节点的完整路径，因为我们没有<strong class="it hv">完成的父节点。</strong></p><p id="f9f4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们也不想浪费时间一遍又一遍地检查相同的节点。<strong class="it hv">我们想要跟踪哪些节点已经被“处理”“已处理”意味着我们已经计算了到达每个节点子节点的成本。</strong></p><p id="76f1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为此我们可以简单地使用一个数组。处理完一个节点后，我们会将其推送到数组中。</p><pre class="ku kv kw kx fq mc md me mf aw mg dt"><span id="706c" class="ln jr hu md b fv mh mi l mj mk">const processed = [“start”, “A”, “B”];</span></pre><p id="ea70" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好的，这是我们再次使用的图表。</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="fe ff lm"><img src="../Images/dbcbfea8c1d91172fd6d3a416cb9bf50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lzYuC6dIVTVl0gt3MOuCyw.jpeg"/></div></div></figure><p id="2955" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们希望继续寻找最便宜的节点，并更新该节点子节点的开销。最便宜的节点是B，其子节点是A(开销为8)和D(开销为7)。我们将这些添加到我们的成本对象中，现在看起来像这样:</p><pre class="ku kv kw kx fq mc md me mf aw mg dt"><span id="bf23" class="ln jr hu md b fv mh mi l mj mk">console.log(costs)<br/>// returns something like<br/>  { A: 5,<br/>    B: 2,<br/>    D: 9<br/>    finish: Infinity<br/>  };</span></pre><p id="fad4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们不更新<strong class="it hv"> A </strong>的成本，因为5比8便宜。我们加上值为9的<strong class="it hv"> D </strong>，因为到达<strong class="it hv"> B </strong>的开销是2，从<strong class="it hv"> B </strong>到达<strong class="it hv"> D </strong>的开销是7，所以7 + 2 = 9。</p><p id="11c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还更新了我们的<strong class="it hv">处理过的</strong>和<strong class="it hv">父</strong>数据结构。我们将重复上述步骤，直到处理完所有节点。</p><h1 id="2eaa" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">实现算法</h1><p id="891c" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">如果这还不清楚，不要担心，我们即将进入代码。</p><p id="566a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，我们将定义一个函数，给定<strong class="it hv">成本</strong>和<strong class="it hv">已处理的</strong>节点，将返回尚未处理的最便宜的节点。</p><pre class="ku kv kw kx fq mc md me mf aw mg dt"><span id="bf09" class="ln jr hu md b fv mh mi l mj mk">const lowestCostNode = (costs, processed) =&gt; {<br/>  return Object.keys(costs).reduce((lowest, node) =&gt; {<br/>    if (lowest === null || costs[node] &lt; costs[lowest]) {<br/>      if (!processed.includes(node)) {<br/>        lowest = node;<br/>      }<br/>    }<br/>    return lowest;<br/>  }, null);<br/>};</span></pre><p id="c517" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我们将定义主函数，<strong class="it hv"> dijkstra </strong>，它将初始图形作为参数。我们将从创建<strong class="it hv">成本</strong>、<strong class="it hv">父数据</strong>和<strong class="it hv">已处理数据</strong>开始。</p><pre class="ku kv kw kx fq mc md me mf aw mg dt"><span id="f5aa" class="ln jr hu md b fv mh mi l mj mk">const dijkstra = (graph) =&gt; {</span><span id="7ac1" class="ln jr hu md b fv mz mi l mj mk">  const costs = Object.assign({finish: Infinity}, graph.start);</span><span id="701c" class="ln jr hu md b fv mz mi l mj mk">  const parents = {finish: null};</span><span id="1745" class="ln jr hu md b fv mz mi l mj mk">  for (let child in graph.start) {  // add children of start node<br/>    parents[child] = 'start';<br/>  }</span><span id="75f2" class="ln jr hu md b fv mz mi l mj mk">  const processed = [];</span><span id="2f34" class="ln jr hu md b fv mz mi l mj mk">...</span></pre><p id="a343" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，我们将使用<strong class="it hv"> lowestCostNode </strong>函数设置正在处理的节点的初始值。然后，我们将开始一个<strong class="it hv"> while </strong>循环，它将不断寻找最便宜的节点。</p><pre class="ku kv kw kx fq mc md me mf aw mg dt"><span id="5f16" class="ln jr hu md b fv mh mi l mj mk">  let node = lowestCostNode(costs, processed);<br/>  while (node) {</span><span id="4708" class="ln jr hu md b fv mz mi l mj mk">    let cost = costs[node];</span><span id="0f5c" class="ln jr hu md b fv mz mi l mj mk">    let children = graph[node];</span><span id="30ee" class="ln jr hu md b fv mz mi l mj mk">    for (let n in children) {<br/>      let newCost = cost + children[n];<br/>      if (!costs[n]) {<br/>        costs[n] = newCost;<br/>        parents[n] = node;<br/>      }<br/>      if (costs[n] &gt; newCost) {<br/>        costs[n] = newCost;<br/>        parents[n] = node;<br/>      }<br/>    }</span><span id="90c1" class="ln jr hu md b fv mz mi l mj mk">    processed.push(node);</span><span id="b616" class="ln jr hu md b fv mz mi l mj mk">    node = lowestCostNode(costs, processed);</span><span id="f6ee" class="ln jr hu md b fv mz mi l mj mk">  }</span></pre><p id="6c7f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是对上述情况的更详细描述:</p><ol class=""><li id="bc59" class="ml mm hu it b iu iv iy iz jc mn jg mo jk mp jo mq mr ms mt dt translated">获取当前节点的成本</li><li id="adbd" class="ml mm hu it b iu mu iy mv jc mw jg mx jk my jo mq mr ms mt dt translated">获取当前节点的所有邻居(又名“子节点”)。</li><li id="922d" class="ml mm hu it b iu mu iy mv jc mw jg mx jk my jo mq mr ms mt dt translated">遍历每个子节点，并计算到达该子节点的开销。我们将在<strong class="it hv">成本</strong>对象<strong class="it hv"> </strong>中更新该节点的成本，如果它是最便宜的或者是唯一可用的成本。</li><li id="4fd8" class="ml mm hu it b iu mu iy mv jc mw jg mx jk my jo mq mr ms mt dt translated">我们还将更新parents数据结构，以便我们最终可以追溯我们的步骤。</li><li id="1eda" class="ml mm hu it b iu mu iy mv jc mw jg mx jk my jo mq mr ms mt dt translated">一旦节点被完全处理，我们将把它推到我们处理过的数据结构中。</li><li id="755c" class="ml mm hu it b iu mu iy mv jc mw jg mx jk my jo mq mr ms mt dt translated">将当前节点的值重置为最便宜的、未处理的节点，然后重复。</li></ol><p id="ec98" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，一旦while循环完成，我们到达<strong class="it hv">结束</strong>节点的成本将会最低。我们现在想要获得到那个节点的路径，这可以通过使用<strong class="it hv"> parents </strong>对象回溯我们的步骤来实现。</p><pre class="ku kv kw kx fq mc md me mf aw mg dt"><span id="4ccb" class="ln jr hu md b fv mh mi l mj mk">  let optimalPath = ['finish'];</span><span id="0410" class="ln jr hu md b fv mz mi l mj mk">  let parent = parents.finish;</span><span id="deaa" class="ln jr hu md b fv mz mi l mj mk">  while (parent) {<br/>    optimalPath.push(parent);<br/>    parent = parents[parent];<br/>  }<br/>  <br/>  optimalPath.reverse();  // reverse array to get correct order</span><span id="c9b6" class="ln jr hu md b fv mz mi l mj mk">  const results = {<br/>    distance: costs.finish,<br/>    path: optimalPath<br/>  };</span><span id="f6e8" class="ln jr hu md b fv mz mi l mj mk">  return results;</span><span id="8321" class="ln jr hu md b fv mz mi l mj mk">}; <em class="lj">//end of function</em></span></pre><p id="efee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们最终的结果应该是这样的！</p><pre class="ku kv kw kx fq mc md me mf aw mg dt"><span id="58c7" class="ln jr hu md b fv mh mi l mj mk">{ distance: 8, path: [ 'start', 'A', 'D', 'finish' ] }</span></pre><p id="07b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要查看完整的解决方案，请查看<a class="ae jp" href="https://gist.github.com/stella-yc/49a7b96679ab3bf06e26421fc81b5636" rel="noopener ugc nofollow" target="_blank">要点。</a></p><p id="98d7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你仍然有问题，我建议在你的机器上运行代码，并修改程序的部分内容。我发现调整和摆弄代码确实有助于我更深入地理解正在发生的事情。</p><p id="e09c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我希望你喜欢这个解释。感谢您花时间阅读这篇文章！</p><p id="1ec7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">**更新:为了更加清晰，我重新审视了我的原始解决方案，并加入了反馈和更清晰的变量名，以及一些日志记录来帮助理解正在发生的事情。这里可以找到<a class="ae jp" href="https://repl.it/@stella_sighs/dijkstramedium" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="888f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">— <br/> <em class="lj">如果你喜欢这首曲子，请点击绿心💚所以其他人也可能偶然发现它！欢迎在</em> <a class="ae jp" href="https://github.com/stella-yc" rel="noopener ugc nofollow" target="_blank"> <em class="lj"> Github </em> </a> <em class="lj">或</em><a class="ae jp" href="https://twitter.com/stellasometimes" rel="noopener ugc nofollow" target="_blank"><em class="lj">Twitter</em></a><em class="lj">上关注我。</em></p><figure class="ku kv kw kx fq ky"><div class="bz el l di"><div class="na nb l"/></div></figure></div></div>    
</body>
</html>