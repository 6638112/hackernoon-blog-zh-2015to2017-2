<html>
<head>
<title>Getting the User’s Opinion: Options in Haskell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">获取用户意见:Haskell中的选项</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/getting-the-users-opinion-options-in-haskell-3b6b02130037?source=collection_archive---------13-----------------------#2017-07-24">https://medium.com/hackernoon/getting-the-users-opinion-options-in-haskell-3b6b02130037?source=collection_archive---------13-----------------------#2017-07-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="4239" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">GUI很难创建。幸运的是，我们经常可以通过命令行界面使代码可用。随着您开始编写更多的Haskell程序，您可能会在某个时候不得不这样做。</p><p id="5666" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本文将介绍CLI的一些细节。特别是，我们将看看处理选项的基础。然后，我们将看到一些测试CLI行为的漂亮技术。</p><h1 id="ff59" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">简单的样品</h1><p id="10ac" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">为了激发本文中的例子，让我们设计一个简单的程序，让用户输入一条<strong class="it hv">消息</strong>。然后，我们将把消息打印到一个文件中一定的次数，并将用户的名字作为作者列在顶部。如果他们愿意，我们也允许他们将信息大写。因此，我们将从用户那里获得五条输入:</p><ol class=""><li id="b202" class="ks kt hu it b iu iv iy iz jc ku jg kv jk kw jo kx ky kz la dt translated">他们想要的文件名</li><li id="134a" class="ks kt hu it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la dt translated">把他们的名字放在最上面</li><li id="2ced" class="ks kt hu it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la dt translated">不管他们想不想大写</li><li id="340d" class="ks kt hu it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la dt translated">信息</li><li id="d377" class="ks kt hu it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la dt translated">重复次数</li></ol><p id="2c8c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于前三条信息，我们将使用<strong class="it hv">参数和选项</strong>。然后我们会有一个<strong class="it hv">命令行提示</strong>给另外两个。例如，我们坚持让用户将预期的文件名作为参数传递。然后，我们将选择用户希望放在顶部的名称。最后，我们将标记用户是否希望消息是大写的。这里有几个不同的程序调用。</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="e352" class="lp jq hu ll b fv lq lr l ls lt">&gt;&gt; run-cli “myfile.txt” -n “John Doe”<br/>What message do you want in the file?<br/>Sample Message<br/>How many times should it be repeated?<br/>5</span></pre><p id="4e86" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将把以下输出打印到<code class="eh lu lv lw ll b">myfile.txt</code>:</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="f607" class="lp jq hu ll b fv lq lr l ls lt">From: John Doe<br/>Sample Message<br/>Sample Message<br/>Sample Message<br/>Sample Message<br/>Sample Message</span></pre><p id="832e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是另一次运行，这次输入有错误:</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="a4dd" class="lp jq hu ll b fv lq lr l ls lt">&gt;&gt; run-cli “myfile2.txt” -n “Jane Doe” -u<br/>What message do you want in the file?<br/>A new message<br/>How many times should it be repeated?<br/>asdf<br/>Sorry, that isn't a valid number. Please enter a number.<br/>3</span></pre><p id="c376" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该文件将类似于:</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="5029" class="lp jq hu ll b fv lq lr l ls lt">From: Jane Doe<br/>A NEW MESSAGE<br/>A NEW MESSAGE<br/>A NEW MESSAGE</span></pre><p id="894b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，如果我们没有得到正确的参数，我们应该得到一个用法错误:</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="2e0f" class="lp jq hu ll b fv lq lr l ls lt">&gt;&gt; run-cli<br/>Missing: FILENAME -n USERNAME</span><span id="5165" class="lp jq hu ll b fv lx lr l ls lt">Usage: CLIPractice-exe FILENAME -n USERNAME [-u]<br/>  Comand Line Sample Program</span></pre><h1 id="50e9" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">获取输入</h1><p id="a1ad" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">所以这个项目最重要的方面是<strong class="it hv">获取信息和重复</strong>。我们暂时忽略这些选项。我们将打印几条消息，然后使用<code class="eh lu lv lw ll b">getLine</code>函数获取它们的输入。他们没有办法给我们一个坏消息，所以这一节很简单。</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="41cd" class="lp jq hu ll b fv lq lr l ls lt">getMessage :: IO String<br/>getMessage = do<br/>  putStrLn "What message do you want in the file?"<br/>  getLine</span></pre><p id="b3b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是他们可能会给我们一个我们无法解析的数字。因此，对于这个任务，我们将不得不建立一个循环，在这个循环中，我们不断地向用户询问一个数字，直到他们给我们一个好的值。在失败的情况下，这将是递归的。如果用户不输入有效的数字，他们将别无选择，只能通过其他方式终止程序。</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="c770" class="lp jq hu ll b fv lq lr l ls lt">getRepetitions :: IO Int<br/>getRepetitions = do<br/>  putStrLn "How many times should it be repeated?"<br/>  getNumber</span><span id="9fa5" class="lp jq hu ll b fv lx lr l ls lt">getNumber :: IO Int<br/>getNumber = do<br/>  rep &lt;- getLine<br/>  case readMaybe rep of<br/>    Nothing -&gt; do<br/>      putStrLn "Sorry, that isn't a valid number. Please enter a number."<br/>      getNumber<br/>    Just i -&gt; return i</span></pre><p id="c6f8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦我们读取了输入，我们将输出到一个文件。在这种情况下，我们现在对所有选项进行硬编码。这是完整的节目单。</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="6cbc" class="lp jq hu ll b fv lq lr l ls lt">import Data.Char (toUpper)<br/>import System.IO (writeFile)<br/>import Text.Read (readMaybe)</span><span id="fb0f" class="lp jq hu ll b fv lx lr l ls lt">runCLI :: IO ()<br/>runCLI = do<br/>  let fileName = "myfile.txt"<br/>  let userName = "John Doe"<br/>  let isUppercase = False<br/>  message &lt;- getMessage<br/>  reps &lt;- getRepetitions<br/>  writeFile fileName (fileContents userName message reps isUppercase)</span><span id="52fb" class="lp jq hu ll b fv lx lr l ls lt">fileContents :: String -&gt; String -&gt; Int -&gt; Bool -&gt; String<br/>fileContents userName message repetitions isUppercase = unlines $<br/>  ("From: " ++ userName) :<br/>  (replicate repetitions finalMessage)<br/>  where<br/>    finalMessage = if isUppercase <br/>     then map toUpper message <br/>    else message</span></pre><h1 id="7cd8" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">解析选项</h1><p id="64f7" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">现在我们必须处理我们实际上如何<strong class="it hv">解析不同选项</strong>的问题。我们可以用<code class="eh lu lv lw ll b">getArgs</code>函数手工完成，但是这有点容易出错。一般来说，更好的选择是使用<code class="eh lu lv lw ll b">Options.Applicative</code>库。我们将探索这个库允许的不同可能性。我们将使用三个不同的助手函数来处理我们需要的三部分输入。</p><p id="3812" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们要做的第一件事是构建一个数据结构来保存我们需要的不同选项。我们想知道要存储的文件名、顶部的名称以及大写状态。</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="d48d" class="lp jq hu ll b fv lq lr l ls lt">data CommandOptions = CommandOptions<br/>  { fileName :: FilePath<br/>  , userName :: String<br/>  , isUppercase :: Bool }</span></pre><p id="409d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们需要解析其中的每一个。我们将从大写值开始。我们拥有的最简单的解析器是<code class="eh lu lv lw ll b">flag</code>函数。它告诉我们，如果一个特定的标志(我们称之为<code class="eh lu lv lw ll b">-u</code>)存在，我们将大写消息，否则不。它用选项库这样编码:</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="03b6" class="lp jq hu ll b fv lq lr l ls lt">uppercaseParser :: Parser Bool<br/>uppercaseParser = flag False True (short 'u')</span></pre><p id="a728" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意，我们在最后一个参数中使用了<code class="eh lu lv lw ll b">short</code>来表示旗帜字符。我们也可以使用<code class="eh lu lv lw ll b">switch</code>函数，因为这个标志只是一个布尔值，但是这个版本更通用。</p><p id="851c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们将转移到文件名的参数<strong class="it hv">上。这使用了<code class="eh lu lv lw ll b">argument</code>辅助函数。我们将使用一个字符串解析器(<code class="eh lu lv lw ll b">str</code>)来确保获得实际的字符串。我们不会担心文件名有特殊的格式。注意，我们给这个参数添加了一些元数据。这告诉用户，如果他们没有使用正确的格式，他们错过了什么。</strong></p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="7e80" class="lp jq hu ll b fv lq lr l ls lt">fileNameParser :: Parser String<br/>fileNameParser = argument str (metavar "FILENAME")</span></pre><p id="a78b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我们将处理将什么名字放在顶部的选项。我们也可以把它作为一个论点，但是让我们看看这个选项是什么样的。自变量是<strong class="it hv">要求的位置参数</strong>。另一方面，选项出现在特定标志之后的<strong class="it hv">。为了更好地显示错误消息，我们还在这里添加了元数据。我们的元数据的<code class="eh lu lv lw ll b">short</code>部分确保它将使用我们想要的选项字符。</strong></p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="a57b" class="lp jq hu ll b fv lq lr l ls lt">userNameParser :: Parser FilePath<br/>userNameParser = option str (short 'n' &lt;&gt; metavar "USERNAME")</span></pre><p id="f4ff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们必须组合这些不同的解析器，并添加一些关于我们程序的信息。</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="4ef0" class="lp jq hu ll b fv lq lr l ls lt">import Options.Applicative (execParser, info, helper, Parser, fullDesc, <br/>  progDesc, short, metavar, flag, argument, str, option)</span><span id="2644" class="lp jq hu ll b fv lx lr l ls lt">parseOptions :: IO CommandOptions<br/>parseOptions = execParser $ info (helper &lt;*&gt; commandOptsParser) commandOptsInfo<br/>  where<br/>    commandOptsParser = CommandOptions &lt;$&gt; fileNameParser &lt;*&gt; userNameParser &lt;*&gt; uppercaseParser<br/>    commandOptsInfo = fullDesc &lt;&gt; progDesc "Command Line Sample Program"</span><span id="92c8" class="lp jq hu ll b fv lx lr l ls lt">-- Revamped to take options<br/>runCLI :: CommandOptions -&gt; IO ()<br/>runCLI commandOptions = do<br/>  let file = fileName commandOptions<br/>  let user = userName commandOptions<br/>  let uppercase = isUppercase commandOptions<br/>  message &lt;- getMessage<br/>  reps &lt;- getRepetitions<br/>  writeFile file (fileContents user message reps uppercase)</span></pre><p id="039b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们完成了！我们使用这三种不同的解析器来构建命令对象。我们使用应用程序将操作链接在一起！然后我们把结果传递给我们的主程序。如果你不太熟悉<a class="ae ly" href="https://mmhaskell.com/blog/2017/1/30/the-easiest-haskell-idiom" rel="noopener ugc nofollow" target="_blank">函子</a>和<a class="ae ly" href="https://mmhaskell.com/blog/2017/2/6/applicatives-one-step-further" rel="noopener ugc nofollow" target="_blank">应用程序</a>，我们不久前在博客上讨论过这些。<a class="ae ly" href="https://mmhaskell.com/blog/2017/1/30/the-easiest-haskell-idiom" rel="noopener ugc nofollow" target="_blank">刷新</a>你的<a class="ae ly" href="https://mmhaskell.com/blog/2017/2/6/applicatives-one-step-further" rel="noopener ugc nofollow" target="_blank">内存</a>！</p><h1 id="260a" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">IO测试</h1><p id="d84d" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">现在我们的程序运行了，我们需要问自己如何测试它的行为。我们可以自己进行手工命令行测试，但是如果有一个自动化的解决方案就更好了。这里的关键是<code class="eh lu lv lw ll b">Handle</code>抽象。</p><p id="445c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们先来看看一些基本的文件处理类型。</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="b87f" class="lp jq hu ll b fv lq lr l ls lt">openFile :: FilePath -&gt; IO Handle<br/>hGetLine :: Handle -&gt; IO String<br/>hPutStrLn :: Handle -&gt; IO ()<br/>hClose :: Handle -&gt; IO ()</span></pre><p id="a643" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通常当我们向文件写东西时，我们会为它打开一个句柄。我们对所有不同的操作使用句柄(而不是字符串名称)。完成后，我们关上把手。</p><p id="7478" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好消息是<code class="eh lu lv lw ll b">stdin</code>和<code class="eh lu lv lw ll b">stdout</code>流实际上是完全相同的<code class="eh lu lv lw ll b">Handle</code>类型！</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="f594" class="lp jq hu ll b fv lq lr l ls lt">stdin :: Handle<br/>stdout :: Handle</span></pre><p id="3cdd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这对我们的测试有什么帮助？第一步是抽象出我们正在使用的句柄。我们不想使用<code class="eh lu lv lw ll b">print</code>和<code class="eh lu lv lw ll b">getLine</code>，而是想使用<code class="eh lu lv lw ll b">hGetLine</code>和<code class="eh lu lv lw ll b">hPutStrLn</code>。然后我们把这些参数作为程序和函数的参数。让我们看看我们的阅读功能:</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="5e3f" class="lp jq hu ll b fv lq lr l ls lt">getMessage :: Handle -&gt; Handle -&gt; IO String<br/>getMessage inHandle outHandle = do<br/>  hPutStrLn outHandle "What message do you want in the file?"<br/>  hGetLine inHandle</span><span id="a47b" class="lp jq hu ll b fv lx lr l ls lt">getRepetitions :: Handle -&gt; Handle -&gt; IO Int<br/>getRepetitions inHandle outHandle = do<br/>  hPutStrLn outHandle "How many times should it be repeated?"<br/>  getNumber inHandle outHandle</span><span id="8581" class="lp jq hu ll b fv lx lr l ls lt">getNumber :: Handle -&gt; Handle -&gt; IO Int<br/>getNumber inHandle outHandle = do<br/>  rep &lt;- hGetLine inHandle<br/>  case readMaybe rep of<br/>    Nothing -&gt; do<br/>      hPutStrLn outHandle "Sorry, that isn't a valid number. Please enter a number."<br/>      getNumber inHandle outHandle<br/>    Just i -&gt; return i</span></pre><p id="4aff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦我们完成了这些，我们就可以为我们的程序设置输入和输出句柄参数，如下所示。我们的包装器可执行文件将通过<code class="eh lu lv lw ll b">stdin</code>和<code class="eh lu lv lw ll b">stdout</code>:</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="043e" class="lp jq hu ll b fv lq lr l ls lt">-- Library File:<br/>runCLI :: Handle -&gt; Handle -&gt; CommandOptions -&gt; IO ()<br/>runCLI inHandle outHandle commandOptions = do<br/>  let file = fileName commandOptions<br/>  let user = userName commandOptions<br/>  let uppercase = isUppercase commandOptions<br/>  message &lt;- getMessage inHandle outHandle<br/>  reps &lt;- getRepetitions inHandle outHandle<br/>  writeFile file (fileContents user message reps uppercase)</span><span id="84aa" class="lp jq hu ll b fv lx lr l ls lt">-- Executable File<br/>main :: IO ()<br/>main = do<br/>  options &lt;- parseOptions<br/>  runCLI stdin stdout options</span></pre><p id="2cb9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们的库API将句柄作为参数。这意味着在我们的测试代码中，我们可以传递我们想要的任何句柄给来测试代码。而且，正如您可能已经猜到的，我们将用文件来做这件事，而不是用<code class="eh lu lv lw ll b">stdin</code>和<code class="eh lu lv lw ll b">stdout</code>。我们将用预期的终端输出创建一个文件:</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="408a" class="lp jq hu ll b fv lq lr l ls lt">What message do you want in the file?<br/>How many times should it be repeated?</span></pre><p id="83de" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将使用我们的输入创建另一个文件:</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="e52d" class="lp jq hu ll b fv lq lr l ls lt">Sample Message<br/>5</span></pre><p id="2f86" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后是我们期望创建的文件:</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="d08c" class="lp jq hu ll b fv lq lr l ls lt">From: John Doe<br/>Sample Message<br/>Sample Message<br/>Sample Message<br/>Sample Message<br/>Sample Message</span></pre><p id="6353" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们可以编写一个调用库函数的测试。它将传递预期的参数对象以及正确的文件句柄。然后我们可以比较测试文件和输出文件的输出。</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="f0c7" class="lp jq hu ll b fv lq lr l ls lt">import Lib</span><span id="202e" class="lp jq hu ll b fv lx lr l ls lt">import System.IO<br/>import Test.HUnit</span><span id="9e4f" class="lp jq hu ll b fv lx lr l ls lt">main :: IO ()<br/>main = do<br/>  inputHandle &lt;- openFile "input.txt" ReadMode<br/>  outputHandle &lt;- openFile "terminal_output.txt" WriteMode<br/>  runCLI inputHandle outputHandle options<br/>  hClose inputHandle<br/>  hClose outputHandle<br/>  expectedTerminal &lt;- readFile "expected_terminal.txt"<br/>  actualTerminal &lt;- readFile "terminal_output.txt"<br/>  expectedFile &lt;- readFile "expected_output.txt"<br/>  actualFile &lt;- readFile "testOutput.txt"<br/>  assertEqual "Terminal Output Should Match" expectedTerminal actualTerminal<br/>  assertEqual "Output File Should Match" expectedFile actualFile</span><span id="addd" class="lp jq hu ll b fv lx lr l ls lt">options :: CommandOptions<br/>options = CommandOptions "testOutput.txt" "John Doe" False</span></pre><p id="f276" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就是这样！我们还可以使用这个过程来添加关于错误情况的测试，比如当用户输入无效数字时。</p><h1 id="c38e" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">摘要</h1><p id="bda2" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">编写命令行界面并不总是最容易的任务。如果用户没有给你想要的信息，获取用户的输入有时需要创建循环。那么处理争论会是一件很痛苦的事情。<code class="eh lu lv lw ll b">Options.Applicative</code>库包含许多选项解析工具。它帮助您处理标志、选项和参数。当你准备好测试你的程序时，你会想要抽象出文件句柄。你可以在主可执行文件中使用<code class="eh lu lv lw ll b">stdin</code>和<code class="eh lu lv lw ll b">stdout</code>。但是当您测试时，您可以使用文件作为您的输入和输出句柄。</p><p id="52e4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">想试着写一个CLI但是还不了解Haskell？没问题！下载我们的<a class="ae ly" href="https://www.mmhaskell.com/checklist" rel="noopener ugc nofollow" target="_blank">入门清单</a>，开始学习语言吧！</p><p id="0ff0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当你用可执行文件和测试套件做一个完整的项目时，你需要保持有条理！参加我们免费的<a class="ae ly" href="http://academy.mondaymorninghaskell.com/p/your-first-haskell-project" rel="noopener ugc nofollow" target="_blank"> Stack迷你课程</a>来学习如何用Stack组织你的Haskell。</p></div></div>    
</body>
</html>