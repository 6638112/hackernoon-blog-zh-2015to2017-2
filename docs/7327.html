<html>
<head>
<title>Building a Raffle Smart Contract Using Oraclize</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Oraclize构建抽奖智能合同</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/building-a-raffle-contract-using-oraclize-e746e5edff6b?source=collection_archive---------6-----------------------#2017-10-24">https://medium.com/hackernoon/building-a-raffle-contract-using-oraclize-e746e5edff6b?source=collection_archive---------6-----------------------#2017-10-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/2bc5c2b7a88062cae7156f35fbb46d0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rt15EIylwiXdJ85wqK-gHg.jpeg"/></div></div></figure><div class=""/><p id="c9eb" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<a class="ae ka" href="https://hackernoon.com/tagged/solidity" rel="noopener ugc nofollow" target="_blank">实度</a>中生成随机数并不简单。首先，由于系统的确定性，坚固性并不是天生的随机函数。</p><blockquote class="kb kc kd"><p id="40d9" class="jc jd ke je b jf jg jh ji jj jk jl jm kf jo jp jq kg js jt ju kh jw jx jy jz hn dt translated">在数学和物理学中，<strong class="je ig">确定性系统</strong>是<strong class="je ig">系统</strong>，其中<strong class="je ig">系统</strong>的未来状态的发展不涉及随机性。一个<strong class="je ig">确定性</strong>模型因此将总是从给定的起始条件或初始状态产生相同的输出。—<a class="ae ka" href="https://en.wikipedia.org/wiki/Deterministic_system" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Deterministic_system</a></p></blockquote><p id="65b6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有许多服务和API允许我们生成随机数，但问题是它们不是分散的，你必须相信别人生成的数是真正随机的。</p><p id="3f09" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此外，您不能相信契约中看似随机的值，比如blockhash、timestamp或其他miner定义的值。矿工可以在这样的程度上操纵这些值，并且事件选择不发布块。对于一个赌场应用程序，你不能只相信矿工，但有很多其他的用例，你可以依靠<a class="ae ka" href="https://hackernoon.com/tagged/blockhash" rel="noopener ugc nofollow" target="_blank"> blockhash </a>来生成随机结果，只要依赖于这种随机性的质量的总价值低于矿工通过开采单个区块获得的价值。<strong class="je ig"> </strong> <em class="ke">更多相关信息:</em><a class="ae ka" href="https://ethereum.stackexchange.com/questions/419/when-can-blockhash-be-safely-used-for-a-random-number-when-would-it-be-unsafe" rel="noopener ugc nofollow" target="_blank"><em class="ke">https://ether eum . stack exchange . com/questions/419/when-can-block hash-be-safely-used-for-a-random-number-when-when-be-it-be-unsafe</em></a></p><p id="0b49" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那么，我们如何在一个可靠的智能契约中安全地生成一个随机数呢？</p><p id="5be1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有一些解决方案可以帮助我们实现这一点，比如Randao(Randao:<a class="ae ka" href="https://github.com/randao/randao" rel="noopener ugc nofollow" target="_blank">https://github.com/randao/randao</a>)。)和Oraclize(<a class="ae ka" href="http://www.oraclize.it/#services" rel="noopener ugc nofollow" target="_blank">http://www.oraclize.it/#services</a>)。在本文中，我将重点介绍Oraclize，主要是因为它非常容易上手，其次是因为除了生成随机数之外，它还可以用来做更多的事情，比如从Solidity smart contract内部访问任何其他API。</p><h1 id="3b20" class="ki kj if bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">建立抽奖合同</h1><p id="b2cc" class="pw-post-body-paragraph jc jd if je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">在本教程中，我们将构建一个非常简单的抽奖智能合约，以展示如何使用Oraclize来生成一个随机数。合同将按如下方式工作:<br/>我们将部署合同，并设置抽奖将接受的最小和最大参与者数量。一旦有足够多的参与者，抽彩组织者(或任何人)可以执行函数，让Oraclize生成一个随机数。有了这个随机数，我们将从参与者的数组中选择获胜者。<br/>*在这个第一版中，我们不会包括所有的支付逻辑，所以任何人都可以自由参与，但他们不会获得任何ETH奖，当然。</p><h2 id="bdef" class="ll kj if bd kk lm ln lo ko lp lq lr ks jn ls lt kw jr lu lv la jv lw lx le ly dt translated">项目设置</h2><p id="3d2d" class="pw-post-body-paragraph jc jd if je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">对于本教程，我们将在Remix上部署所有东西，使用Metamask连接到Ropsten，因为Oraclize不能在本地或JavaScript VM上工作。我假设你对如何使用Remix和Metamask有一些基本的了解。此外，请确保您至少有3或4个帐户有一些余额，因为我们将需要它来支付参加抽奖的汽油费用以及支付Oraclize以生成随机数(稍后将详细介绍)。</p><h2 id="77cf" class="ll kj if bd kk lm ln lo ko lp lq lr ks jn ls lt kw jr lu lv la jv lw lx le ly dt translated">为合同编码</h2><p id="2e0c" class="pw-post-body-paragraph jc jd if je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">在Remix中，创建一个名为Raffle.sol的新文件，这将是我们包含所有抽奖逻辑的合同。</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="a719" class="ll kj if me b fv mi mj l mk ml">pragma solidity ^0.4.4;</span><span id="3dae" class="ll kj if me b fv mm mj l mk ml">contract Raffle {</span><span id="18b0" class="ll kj if me b fv mm mj l mk ml">  uint private chosenNumber;<br/>  address private winnerParticipant;<br/>  uint8 maxParticipants;<br/>  uint8 minParticipants;<br/>  uint8 joinedParticipants;<br/>  address organizer;</span><span id="4fc5" class="ll kj if me b fv mm mj l mk ml">  bool raffleFinished = false;</span><span id="98e5" class="ll kj if me b fv mm mj l mk ml">  address[] participants;<br/>  mapping (address =&gt; bool) participantsMapping;</span><span id="b875" class="ll kj if me b fv mm mj l mk ml">  event ChooseWinner(uint _chosenNumber,address winner);<br/>  event RandomNumberGenerated(uint);</span><span id="2d96" class="ll kj if me b fv mm mj l mk ml">  function Raffle(){<br/>    address _org = msg.sender; <br/>    uint8 _min = 2; <br/>    uint8 _max = 10; </span><span id="3b44" class="ll kj if me b fv mm mj l mk ml">    require(_min &lt; _max &amp;&amp; _min &gt;=2 &amp;&amp; _max &lt;=50);</span><span id="b173" class="ll kj if me b fv mm mj l mk ml">    organizer = _org;<br/>    chosenNumber = 999;<br/>    maxParticipants = _max;<br/>    minParticipants = _min;<br/>  }</span><span id="b68c" class="ll kj if me b fv mm mj l mk ml">function() payable {}</span><span id="c661" class="ll kj if me b fv mm mj l mk ml">function joinraffle(){<br/>    require(!raffleFinished);<br/>    require(msg.sender != organizer);<br/>    require(joinedParticipants + 1 &lt; maxParticipants);<br/>    require(!participantsMapping[msg.sender]);</span><span id="ab20" class="ll kj if me b fv mm mj l mk ml">    participants.push(msg.sender);<br/>    participantsMapping[msg.sender] = true;</span><span id="10f4" class="ll kj if me b fv mm mj l mk ml">    joinedParticipants ++;<br/>  }</span><span id="2e1c" class="ll kj if me b fv mm mj l mk ml">function chooseWinner(uint _chosenNum) internal{<br/>    chosenNumber = _chosenNum;<br/>    winnerParticipant = participants[chosenNumber];<br/>    ChooseWinner(chosenNumber,participants[chosenNumber]);<br/>}</span><span id="8633" class="ll kj if me b fv mm mj l mk ml">function generateRandomNum(){<br/>    require(!raffleFinished);<br/>    require(joinedParticipants &gt;=minParticipants &amp;&amp; joinedParticipants&lt;=maxParticipants);</span><span id="ff4f" class="ll kj if me b fv mm mj l mk ml">    raffleFinished=true;<br/>    <br/>    chooseWinner(0); //We'll replace this with a call to Oraclize service later on.</span><span id="14c7" class="ll kj if me b fv mm mj l mk ml">}</span><span id="8338" class="ll kj if me b fv mm mj l mk ml">function getChosenNumber() constant returns (uint) {<br/>    return chosenNumber;<br/>  }</span><span id="e040" class="ll kj if me b fv mm mj l mk ml">function getWinnerAddress() constant returns (address) {<br/>    return winnerParticipant;<br/>  }</span><span id="9b40" class="ll kj if me b fv mm mj l mk ml">function getParticipants() constant returns (address[]) {<br/>    return participants;<br/>  }</span><span id="de75" class="ll kj if me b fv mm mj l mk ml">}</span></pre><p id="b307" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我将介绍代码中最重要的部分:</p><ul class=""><li id="7888" class="mn mo if je b jf jg jj jk jn mp jr mq jv mr jz ms mt mu mv dt translated"><strong class="je ig">函数Raffle(): </strong>合约的构造者设置合约的配置状态变量，比如所需的最小和最大参与者，以及抽奖的组织者是谁(目前是合约的创建者)。注意，我们硬编码了这些变量，只是为了使例子更简单，但是您可以让构造函数接收这些参数。此外，我们要求至少有2名参与者，不超过50人。如果您愿意，这个最大值也可以更改。</li><li id="dcd6" class="mn mo if je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated"><strong class="je ig">回退功能:</strong>我添加了回退功能，因为我们需要向合同发送Ether，这样它就可以为Oraclize的服务付费。你认为他们会免费提供服务吗？:)—稍后会有更多相关内容。</li><li id="0b90" class="mn mo if je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated"><strong class="je ig">函数joinRaffle(): </strong>该函数允许呼叫者加入抽彩。首先，我们进行一些检查，以确保我们没有向已经结束或已经达到参与者最大数量的抽奖活动添加新的参与者。我们还会检查组织者是否试图加入，以及此人是否已经加入。然后，我们将新的参与者添加到参与者数组中(这样我们以后可以随机选择其中一个参与者)，并且我们还将它添加到参与者映射中(这允许我们容易地检查该参与者是否已经加入)。让两个变量保存相同的信息对我来说有点奇怪，但是鉴于这个例子相当简单，我觉得我们可以摆脱它。</li><li id="453a" class="mn mo if je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated"><strong class="je ig">函数generateRandomNumber(): </strong>这个函数将被调用，让Oraclize生成随机数。请注意，我们将它公开，并不要求组织者是调用它的人。这是故意的，所以如果组织者，出于某种原因，消失了，参与者可以选择一个赢家。这也可以被改变，例如，允许这种机制，但是只有在一段时间过去之后。目前，该函数所做的只是将raffleFinished标志设置为true(因此该函数只能调用一次),并调用参数为0的chooseWinner。当我们实现Oraclize时，我们将生成一个随机数，而不是发送一个硬编码的0(这将自动使第一个参加抽奖的人成为赢家)。</li><li id="bfe7" class="mn mo if je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated"><strong class="je ig">函数chooseWinner(): </strong>这是一个内部函数，它接收一个指示获胜者在参与者数组中的位置的uint。有了这个号码，我们还可以设置获胜者的地址，并触发一个事件来记录获胜者是谁，这样我们以后就可以检索并显示它。</li><li id="78b1" class="mn mo if je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated">剩下的函数只是稍后在前端用来显示获胜者。</li></ul><p id="3015" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">继续尝试<a class="ae ka" href="https://remix.ethereum.org/" rel="noopener ugc nofollow" target="_blank">混音</a>中的合约。只需复制并粘贴上面的代码，然后部署契约。您应该能够使用不同的帐户加入抽彩，然后，在有足够的参与者后，您可以调用generateRandomNumber()来选择一个获胜者(它将始终是参与者数组中位置0的地址)。</p><p id="a2f1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们已经确保了抽奖的逻辑是正确的，是时候使用Oraclize为我们生成一个随机数了。</p><h2 id="b3a2" class="ll kj if bd kk lm ln lo ko lp lq lr ks jn ls lt kw jr lu lv la jv lw lx le ly dt translated">使用Oraclize生成随机数</h2><p id="0e97" class="pw-post-body-paragraph jc jd if je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">将Oraclize集成到我们的智能合约中非常简单直接。第一步是在我们的合同中导入Oraclize API。在抽奖合同声明前添加以下行。</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="4ded" class="ll kj if me b fv mi mj l mk ml">import "github.com/oraclize/ethereum-api/oraclizeAPI.sol";</span><span id="b303" class="ll kj if me b fv mm mj l mk ml">contract Raffle is usingOraclize{<br/>...<br/>}</span></pre><p id="f7f9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，我们还将Raffle更改为从usingOraclize继承。</p><p id="60db" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">既然我们导入了Oraclize，我们就可以访问它的功能了。你应该知道的一件事是，以这种方式导入Oraclize将会失败，例如，如果你使用Truffle来编译你的合同。如果您使用Truffle，您将必须制作Oraclize文件的本地副本，并将其重命名为“usingOraclize.sol ”,因为Truffle需要该文件与合同同名。</p><p id="2519" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们要做的第一件事是添加Oraclize回调函数。Oraclize的工作方式是首先进行查询——我们可以查询外部API、Wolfram的Mathematica，或者像我们的情况一样，查询内置的随机数生成器——它将向Oraclize契约触发一个事务，在该事务得到处理后，它将触发我们在契约中定义的回调函数，并产生相应的结果。</p><p id="4967" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是回调函数的样子:</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="7ca0" class="ll kj if me b fv mi mj l mk ml">// the callback function is called by Oraclize when the result is ready<br/>// the oraclize_randomDS_proofVerify modifier prevents an invalid proof to execute this function code:<br/>// the proof validity is fully verified on-chain</span><span id="6b0a" class="ll kj if me b fv mm mj l mk ml">function __callback(bytes32 _queryId, string _result, bytes _proof)<br/>{<br/>  // If we already generated a random number, we can't generate a new one.<br/>  require(!raffleFinished);<br/>  // if we reach this point successfully, it means that the attached authenticity proof has passed!<br/>  require (msg.sender == oraclize_cbAddress());</span><span id="2749" class="ll kj if me b fv mm mj l mk ml">  if (oraclize_randomDS_proofVerify__returnCode(_queryId, _result, _proof) != 0) {<br/>    // the proof verification has failed, do we need to take any action here? (depends on the use case)<br/>  } else {<br/>    // the proof verification has passed<br/>    raffleFinished=true;</span><span id="e1d3" class="ll kj if me b fv mm mj l mk ml">    // for simplicity of use, let's also convert the random bytes to uint if we need<br/>    uint maxRange = joinedParticipants; // this is the highest uint we want to get. It should never be greater than 2^(8*N), where N is the number of random bytes we had asked the datasource to return<br/>    uint randomNumber = uint(sha3(_result)) % maxRange; // this is an efficient way to get the uint out in the [0, maxRange] range<br/>    <br/>    chooseWinner(randomNumber);</span><span id="7a78" class="ll kj if me b fv mm mj l mk ml">    RandomNumberGenerated(randomNumber); // this is the resulting random number (uint)<br/>  }<br/>}</span></pre><p id="0ca0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，我们将确保raffleFinished为false，所以我们不允许这个函数被调用多次。</p><p id="d1cc" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，我们检查我们获得的数据在交付给智能合约时没有被篡改。你可以在这里了解更多信息:<a class="ae ka" href="https://blog.oraclize.it/the-random-datasource-chapter-2-779946e54f49" rel="noopener ugc nofollow" target="_blank">https://blog . oraclize . it/the-random-data source-chapter-2-779946 e54f 49</a></p><p id="2f0e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果验证已经通过，意味着数据没有被篡改，那么我们继续使用随机数。我们将调用之前使用的chooseWinner()函数，但是我们将传递我们生成的随机数，而不是硬编码的0作为参数。<br/>如您所见，生成的随机数使用joinedPaticipants状态变量来确定其最大范围。我们还触发了一个事件来记录我们生成的随机数。</p><p id="8ee4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们要做的最后一件事是修改我们的generateRandomNum()函数，这样当有人执行它时，它会使查询变成Oraclize。</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="c78f" class="ll kj if me b fv mi mj l mk ml">function generateRandomNum(){<br/>    require(!raffleFinished);<br/>    require(joinedParticipants &gt;=minParticipants &amp;&amp; joinedParticipants&lt;=maxParticipants);</span><span id="807f" class="ll kj if me b fv mm mj l mk ml">    oraclize_setProof(proofType_Ledger); // sets the Ledger authenticity proof<br/>    uint N = 4; // number of random bytes we want the datasource to return<br/>    uint delay = 0; // number of seconds to wait before the execution takes place<br/>    uint callbackGas = 200000; // amount of gas we want Oraclize to set for the callback function<br/>    bytes32 queryId = oraclize_newRandomDSQuery(delay, N, callbackGas); // this function internally generates the correct oraclize_query and returns its queryId</span><span id="d80a" class="ll kj if me b fv mm mj l mk ml">}</span></pre><p id="7e38" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过调用oraclize _ newRandomDSQuery(delay，N，callbackGas)我们将让Oraclize为我们生成一个随机数，当它准备好了，我们前面定义的回调函数将被触发。oraclize_newRandomDSQuery接收3个参数。</p><ul class=""><li id="d9f8" class="mn mo if je b jf jg jj jk jn mp jr mq jv mr jz ms mt mu mv dt translated">delay:这是在执行发生之前等待的秒数。我们将它设置为0，这样一旦有结果，它就会执行回调。</li><li id="78c6" class="mn mo if je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated">n:这是我们希望数据源返回的字节数。在我们的例子中，如果组织者愿意的话，我们的抽彩最多可以接受50个参与者，4个字节就足够了。</li><li id="51e7" class="mn mo if je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated">callbackGas:我们将转发或调整多少Gas，以便它可以执行回调函数。我们将其设置为200.000，这足以执行该功能。(在我的测试中，它消耗了大约125.000汽油)。</li></ul><p id="3da2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就是这样！你可以在Remix里试一试，看看效果如何。一些注意事项和建议:</p><ul class=""><li id="b7ab" class="mn mo if je b jf jg jj jk jn mp jr mq jv mr jz ms mt mu mv dt translated"><strong class="je ig"> Oraclize的定价模式:</strong>正如我之前提到的，Oraclize不是免费的。你可以在这里查看他们的定价:<a class="ae ka" href="http://docs.oraclize.it/#pricing" rel="noopener ugc nofollow" target="_blank">http://docs.oraclize.it/#pricing</a>。请注意，您的合同进行的第一次查询是免费的，然后您将不得不为交易付费。怎么会？执行查询的契约从其余额中支付费用。因此，在调用generateRandomNum()函数之前，请确保向契约发送一些以太网。—这就是我们包含回退功能的原因。</li><li id="ec77" class="mn mo if je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated">测试你的合同可能会很乏味。首先，由于我们使用的是Oraclize，您不能在本地测试它，我们需要连接到一个testnet(我使用的是Ropsten)。你应该记住，当你调用generateRandomNum()时，需要30-50秒来挖掘，然后，需要一分钟来实际处理回调函数。还有，在Metamask + Remix里切换账号也要费点功夫。用耐心武装自己。</li><li id="d1e8" class="mn mo if je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated"><strong class="je ig">执行这个需要多少汽油？我仍在研究执行这份合同所需的必要气体。在Remix上，我不得不在部署合同时将限制提高到5.000.000。确保你在生成随机数时也发送了足够的气体，否则回调函数将失败。</strong></li></ul><p id="a3e9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们今天建立的合同允许我们运行一个简单的抽奖活动，人们可以加入，然后通过使用Oraclize生成一个随机数来选择一个获胜者，我们可以肯定这个随机数没有被篡改。有很多改进和新功能的空间，例如允许人们用乙醚参加抽奖并赢得奖励。</p><p id="cadf" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你有任何建议或者你在代码中遇到任何问题，请在下面的评论部分告诉我。</p><figure class="lz ma mb mc fq hw"><div class="bz el l di"><div class="nb nc l"/></div></figure></div></div>    
</body>
</html>