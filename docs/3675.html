<html>
<head>
<title>Modifying the Python language in 6 minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在6分钟内修改Python语言</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/modifying-the-python-language-in-7-minutes-b94b0a99ce14?source=collection_archive---------0-----------------------#2017-04-17">https://medium.com/hackernoon/modifying-the-python-language-in-7-minutes-b94b0a99ce14?source=collection_archive---------0-----------------------#2017-04-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="f8de" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本周，我向CPython核心项目提出了我的第一个pull-request，但遭到了拒绝:-(为了不浪费我的时间，我写下了我对CPython如何工作的发现，并向您展示修改Python语法是多么容易。</p><p id="c92b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我将向您展示如何向Python语法添加新的<strong class="it hv">特性</strong>。该语法是递增/递减运算符，是大多数语言中的常见运算符。为了证明这一点，打开REPL试试吧。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/1aa2a8eccf020dae6db5ac0a83e9ab44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*najLze94Eq03dWps2O38Mw.png"/></div></div></figure><h1 id="5b19" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">第一级:pep</h1><p id="f888" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">在改变Python语法之前，需要提出一个建议，包括一系列理由、设计和行为。所有语言更改都由核心Python团队讨论，并由BDFL批准。增量运算符不被认可(可能永远不会被认可)，这给了我们一个很好的测试。</p><h1 id="ae3a" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">第二级:语法</h1><p id="52d6" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/python/cpython/blob/v3.6.1/Grammar/Grammar" rel="noopener ugc nofollow" target="_blank">语法</a>文件是描述Python语言所有元素的简单文本文件。不仅CPython使用这种方法，PyPy等其他实现也使用这种方法来保持一致性，并就语言语义的类型达成一致。</p><p id="58c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在内部，这些键形成了令牌，由lexer解析。当你使用一个命令将它们转换成C头文件中的一组枚举和常量。这允许我们以后引用它们。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="d5b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以，<code class="eh lf lg lh li b">simple_stmt</code>是一个简单的语句，它可以选择有一个分号，就像你把<code class="eh lf lg lh li b">import pdb; pdb.set_trace()</code>放在新的一行<code class="eh lf lg lh li b">NEWLINE</code>中结束。一个<code class="eh lf lg lh li b">pass_stmt</code>是单词pass，一个<code class="eh lf lg lh li b">break_stmt</code>是工间休息。简单吧？</p><p id="9a08" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们添加一个增量和减量表达式，这在语言中是不存在的。它将是表达式语句中的另一个选项，与yields、augmented赋值和regular赋值一起，即<code class="eh lf lg lh li b">foo=1</code>。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="b0c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将它添加到可能的小语句列表中(这在AST中会变得很明显)。<code class="eh lf lg lh li b">incr_stmt</code>将是我们的增量方法，而<code class="eh lf lg lh li b">decr_stmt</code>将是减量方法。两者都跟在一个<code class="eh lf lg lh li b">NAME</code>(变量名)后面，形成一个小的独立语句。当我们构建Python项目时，它会为我们生成组件(还没有)。</p><p id="5996" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您使用-d启动Python并尝试使用它，您应该会得到:</p><blockquote class="ll lm ln"><p id="e934" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated">令牌<errortoken> /'++' …非法令牌</errortoken></p></blockquote><p id="67e6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">什么是代币？让我们找出答案..</p><h1 id="a87c" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">第三级:Lexer</h1><p id="9cd3" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">当您点击return时，Python会执行四个步骤:词法分析、解析、编译和解释。Lexing正在中断您刚刚输入到令牌中的代码行。CPython lexer被称为<code class="eh lf lg lh li b">tokenizer.c</code>。它具有从文件中读取的功能(如<code class="eh lf lg lh li b">python file.py</code>、<a class="ae jp" href="https://github.com/python/cpython/blob/v3.6.1/Parser/tokenizer.c#L809-L824" rel="noopener ugc nofollow" target="_blank">一个字符串</a>(如REPL)。它还处理文件顶部的特殊编码注释，并且<a class="ae jp" href="https://github.com/python/cpython/blob/v3.6.1/Parser/tokenizer.c#L827-L853" rel="noopener ugc nofollow" target="_blank">将你的文件</a>解析为UTF-8，等等。它处理嵌套、异步和yield关键字，检测集合和元组分配，但只处理语法。它不知道那些东西是什么，也不知道如何处理它们。它只关心文本。</p><p id="ff0f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，允许您对八进制值使用<code class="eh lf lg lh li b">o</code>符号的代码在<a class="ae jp" href="https://github.com/python/cpython/blob/v3.6.1/Parser/tokenizer.c#L1635-L1652" rel="noopener ugc nofollow" target="_blank">记号赋予器</a>中。实际创建八进制值的代码在编译器中。</p><p id="f344" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们给Parser/tokenizer.c添加两个东西，新的<code class="eh lf lg lh li b">INCREMENT</code>和<code class="eh lf lg lh li b">DECREMENT</code>标记，这些是标记器为代码的每个部分返回的键。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="701d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，我们添加check来返回一个<code class="eh lf lg lh li b">INCREMENT</code>或<code class="eh lf lg lh li b">DECREMENT</code>令牌，每当我们看到++或-。已经有一个用于2字符操作符的函数，所以我们扩展它以适合我们的情况。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="effc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些在<code class="eh lf lg lh li b">token.h</code>中定义</p><blockquote class="ll lm ln"><p id="aaf9" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated">#定义增量58</p><p id="9be1" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated">#定义减量59</p></blockquote><p id="298f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，当我们用-d运行Python并尝试我们的语句时，我们看到:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff ls"><img src="../Images/0fde479c3a797d688f9dea14aa8108cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DGfDsyF37ESu4AUeRvYDfA.png"/></div></div></figure><blockquote class="ll lm ln"><p id="56d0" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated">这是我们知道的象征——成功！</p></blockquote><h1 id="aab4" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">第4级:解析器</h1><p id="92bf" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">解析器接受这些标记，并生成一个结构来显示它们之间的关系。对于Python和许多其他语言来说，这就是抽象语法树(或AST)。然后，编译器获取AST并将其转换成一个(或多个)代码对象。最后，解释器获取每个代码对象并执行它所代表的代码。把你的代码想象成一棵树。顶层是根，函数可能是分支，类是分支，类方法是分支。语句是分支中的叶子。</p><p id="24d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">AST在ast.py和ast.c中都有定义，ast.c是我们需要更改的文件。AST代码被分成处理标记类型的方法，<code class="eh lf lg lh li b">ast_for_stmt</code>处理语句，<code class="eh lf lg lh li b">ast_for_expr</code>处理表达式。我们把<code class="eh lf lg lh li b">incr_stmt</code>和<code class="eh lf lg lh li b">decr_stmt</code>作为可能的表达式语句。它们几乎等同于增强表达式，如<code class="eh lf lg lh li b">test += 1</code>但没有右手表达式(1)，它是隐式的。</p><p id="b5bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是我们添加来处理增量和减量的代码。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="f839" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将返回一个扩充的赋值，而不是一个常数值为1的新表达式类型。根据令牌类型<code class="eh lf lg lh li b">incr_stmt</code>或<code class="eh lf lg lh li b">decr_stmt</code>，运算符为Add或Sub(tract)。编译后回到Python REPL——我们可以看到我们的新语句！</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff lt"><img src="../Images/de104f49d2fd301907f07528a2d5ff14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DiWYV-O3vjVzp0g18MCDJg.png"/></div></div></figure><p id="ec30" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在REPL，您可以试试这个:<code class="eh lf lg lh li b">ast.parse("test=1; test++).body[1]</code>，您将看到返回的<code class="eh lf lg lh li b">AugAssign</code>类型。AST刚刚将语句转换成一个语句表达式，然后编译器可以处理它。<code class="eh lf lg lh li b">AugAssign</code>函数设置编译器使用的字段<code class="eh lf lg lh li b">Kind</code>。</p><h1 id="7abf" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">第5级:编译器</h1><p id="d202" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">编译器然后获取语法树并“访问”每个分支，CPython编译器有一个访问语句的方法，称为<code class="eh lf lg lh li b">compile_visit_stmt</code>，它只是一个查看语句类型的大开关语句。我们的是一个<code class="eh lf lg lh li b">AugAssign</code>类型，所以它调用<code class="eh lf lg lh li b">compiler_augassign</code>来处理细节。然后，这个函数将我们的语句转换成一组字节码。这些是机器码(01010101)和语法树之间的中间语言。<em class="lo">字节码序列是缓存在。pyc文件。</em></p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="b198" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">输出将是VISIT(load value——对我们来说是1)、ADDOP(二元OP的加法运算，取决于操作符(subtract，add)和STORE_NAME(将ADDOP的结果存储到名称中)。这些方法用更具体的字节码来响应。</p><p id="1ce3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您加载<code class="eh lf lg lh li b">dis</code>模块，您可以看到自己的字节码</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff lu"><img src="../Images/a5202fa3a9524a9675a8809de669affe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oQzOgryXK4xLe7N-3_eRRg.png"/></div></div></figure><h1 id="e45f" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">第6级:口译员</h1><p id="c8f3" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">最后一级是翻译。它获取字节码序列，并将其转换成特定于机器的操作。这就是为什么mac和Linux的Python.exe和Python都是独立的二进制文件。一些字节码需要操作系统特定的处理和检查。例如，线程API需要与GNU/Linux的线程API一起工作，这与Windows线程非常不同。</p><blockquote class="lv"><p id="2e09" class="lw lx hu bd ly lz ma mb mc md me jo ek translated">就是这样！</p></blockquote><h1 id="f7b1" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn mf kp kq kr mg kt ku kv mh kx ky kz dt translated">进一步阅读</h1><p id="f43e" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">如果你对解释器感兴趣，我做过一个关于Pyjion的演讲，这是一个CPython的插件架构，后来成为了<a class="ae jp" href="https://www.python.org/dev/peps/pep-0523/" rel="noopener ugc nofollow" target="_blank"> PEP523 </a></p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mi lk l"/></div></figure><p id="2259" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你还想玩，我把代码上传到了<a class="ae jp" href="https://github.com/tonybaloney/cpython/commit/fd7c20c3a3a02b4f2dae8ec7a90448627aa0d757" rel="noopener ugc nofollow" target="_blank"> GitHub </a>，还有我对<code class="eh lf lg lh li b">await</code>记号赋予器的修改。</p><div class="jr js jt ju fq ab cb"><figure class="mj jv mk ml mm mn mo paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mj jv mk ml mm mn mo paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mj jv mk ml mm mn mo paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ll lm ln"><p id="f922" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客们下午的开始。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mp"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>