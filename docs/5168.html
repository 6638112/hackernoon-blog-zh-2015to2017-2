<html>
<head>
<title>Learn from Folly source code the new C++11 features.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Folly源代码中学习C++11的新特性。</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/learn-from-folly-source-code-the-new-c-11-features-121823fdd525?source=collection_archive---------13-----------------------#2017-07-13">https://medium.com/hackernoon/learn-from-folly-source-code-the-new-c-11-features-121823fdd525?source=collection_archive---------13-----------------------#2017-07-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="9945" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">五年前，脸书发布了他们名为<a class="ae jp" href="https://github.com/facebook/folly" rel="noopener ugc nofollow" target="_blank">fully</a>的C++库，这是一个可重用的C++库组件的大集合，在脸书内部被广泛使用。</p><p id="02bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是很多成熟的C++开源库都存在，为什么还要引入另一个呢？以下是他们网站的效用背后的动机:</p><blockquote class="jq jr js"><p id="b096" class="ir is jt it b iu iv iw ix iy iz ja jb ju jd je jf jv jh ji jj jw jl jm jn jo hn dt translated">Folly(脸书开源库的缩写)是一个C++11组件库，设计时考虑了实用性和效率。它补充了Boost等产品，当然还有<code class="eh jx jy jz ka b">std</code>。事实上，只有当我们需要的东西不可用，或者不满足所需的性能时，我们才开始定义我们自己的组件。</p></blockquote><p id="31d9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里有一个<a class="ae jp" href="https://github.com/facebook/folly/blob/master/folly/docs/FBVector.md" rel="noopener ugc nofollow" target="_blank">的例子，详细解释</a>为什么Folly引入了另一个向量类FBVector。正如愚蠢的开发者所声称的，这是一个C++11组件库，如果你看一下他们的源代码，这是完全可以确认的，C++11的特性被广泛使用，而且几乎所有新的C++11特性都被使用。</p><p id="f644" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当c++0x在几年前发布时，我认为它不会对c++语言产生很大影响，但我错了，看看这段来自Folly的代码片段，它看起来像是用一种新语言开发的。</p><figure class="kc kd ke kf fq kg fe ff paragraph-image"><div class="fe ff kb"><img src="../Images/498f49ca6c3d7874fc34cd6bf29f1894.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/0*cSLiiasb2G2tphp9.png"/></div></figure><p id="a9e4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样的评论涉及几乎所有的源代码，它的实现看起来不同于c++03源代码。</p><p id="4ec2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于有兴趣掌握C++11新特性的开发人员来说，更好的方法是了解成熟的库是如何使用它们的。Folly是探索新特性的一个非常好的候选对象。让我们从它的源代码中发现其中的一些。</p><p id="a620" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 1-自动</strong></p><p id="e159" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">C++11使用auto关键字引入了类型推断功能，这意味着编译器在声明时推断变量的类型。Folly在几乎所有的变量声明中都使用了auto，下面是一个来自其源代码的例子</p><figure class="kc kd ke kf fq kg fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff kj"><img src="../Images/f8700c77fad634c9c326a3f8e9c62f41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/0*Yg78KoJLji-wrI_h.png"/></div></div></figure><p id="687d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用auto关键字允许花费更少的时间写出编译器已经知道的东西。</p><p id="d0d4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 2- nullptr </strong></p><p id="1a9a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">常量0具有常量整数和空指针常量的双重作用。C++11通过引入一个新的关键字作为可识别的空指针常量来纠正这个问题:nulptr</p><p id="4161" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在完整的源代码中，所有的空指针都由新的关键字nullptr表示，没有使用常量0的地方。</p><p id="3132" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 3-共享_ptr </strong></p><p id="7890" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">智能指针不是一个新概念，许多库在许多年前就实现了它，流行的是<a class="ae jp" href="http://www.boost.org/doc/libs/1_50_0/libs/smart_ptr/shared_ptr.htm" rel="noopener ugc nofollow" target="_blank"> boost::shared_ptr </a>，新的是它的标准化，不再需要使用外部库来处理智能指针。</p><p id="3028" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Folly广泛使用了标准化的共享指针，只有少数原始指针保留在它的源代码中。</p><p id="1a06" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 4-强类型枚举</strong></p><p id="8198" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">C++中的“传统”枚举在周围的作用域中导出它们的枚举器，这可能会导致名称冲突，如果同一个中的两个不同枚举具有相同名称的作用域定义枚举器，</p><p id="7565" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">C++11引入了枚举类关键字。它们不再导出周围范围内的枚举数。此外，我们现在也可以从枚举继承。</p><figure class="kc kd ke kf fq kg fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff ko"><img src="../Images/e2b929fb59ad795d2375ed413afa755c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RgiOCDtXQ9E2UmS3.png"/></div></div></figure><p id="f3cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 5-静态断言</strong></p><p id="2947" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">C++11引入了一种在编译时测试断言的新方法，使用了新的关键字static_assert，这个特性对于向模板参数添加条件非常有用，如来自Folly源代码的这个模板类所示:</p><figure class="kc kd ke kf fq kg fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff kp"><img src="../Images/faf4725fb7ebeaecf8e715df04172141.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nGYszwxJCOT8TRkv.png"/></div></div></figure><p id="05a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 6变量模板</strong></p><p id="0265" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">可变模板是一个模板，它可以接受任意数量的任何类型的模板参数。类和函数都可以是可变的。full定义了许多可变模板，下面是来自full源代码的两个可变模板函数:</p><figure class="kc kd ke kf fq kg fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff kq"><img src="../Images/df385d770d2a3453b067ab9baf46a1cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*X7anOWg6QcA2ndGV.png"/></div></div></figure><p id="5549" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 7-基于范围的for循环</strong></p><p id="4969" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">C++11扩充了for语句，以支持迭代集合的“foreach”范式。它使代码更加简单和清晰。Folly广泛使用了这个特性，下面是一个关于Folly的例子</p><figure class="kc kd ke kf fq kg fe ff paragraph-image"><div class="fe ff kr"><img src="../Images/1c7f274f8ebdb8efcb2da079a3520a0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/0*EQnbrzBg-aS1noD1.png"/></div></figure><p id="2cdb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">8-初始化列表</strong></p><p id="7e42" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在C++03中，初始化列表只关注数组，在C++11中不再仅仅是数组了。接受<strong class="it hv"> {} </strong> -list的机制是一个接受<strong class="it hv">STD::initializer _ list&lt;T&gt;</strong>类型参数的函数(通常是构造函数)。下面是一个函数接受std::initializer_list作为参数的例子</p><figure class="kc kd ke kf fq kg fe ff paragraph-image"><div class="fe ff ks"><img src="../Images/ba0ce0119d291b84432cb38f3d59984e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/0*oGHAtwXyn3qZN6l3.png"/></div></figure><p id="f26f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是它是如何被调用的</p><figure class="kc kd ke kf fq kg fe ff paragraph-image"><div class="fe ff kt"><img src="../Images/ab9550a58ae72f48e26c0aeee2429815.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/0*UXBId2ZnUCnRI_iD.png"/></div></figure><p id="7f37" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 9-无异常</strong></p><p id="8ba3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果一个函数不能抛出异常，或者如果程序没有被编写来处理一个函数抛出的异常，那么这个函数可以被声明为<strong class="it hv"> noexcept。</strong></p><p id="0871" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个来自愚蠢源代码的例子</p><figure class="kc kd ke kf fq kg fe ff paragraph-image"><div class="fe ff ku"><img src="../Images/121724562ecfb866fbb80fcf77ac6b0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/0*o8kR2Eo-2u7Oh7hL.png"/></div></figure><p id="19da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 10-移动</strong></p><p id="8320" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">C++11引入了右值引用的概念(用&amp;&amp;)来区分对左值或右值的引用。左值是有名称的对象，而右值是没有名称的对象(临时对象)。移动语义允许修改右值。</p><p id="c3ff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为此，C++11引入了两个新的特殊成员函数:<em class="jt">移动构造函数</em>和<em class="jt">移动赋值运算符</em>。</p><figure class="kc kd ke kf fq kg fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff kv"><img src="../Images/6010da1189a5056080cd22d42b440ab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*f2b8QDbMJlCI4wui.png"/></div></div></figure><figure class="kc kd ke kf fq kg fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff kq"><img src="../Images/1a42a882e04ced17af4bd381a5ff4c86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dPY6YinJmUfUf-W-.png"/></div></div></figure><p id="caed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里有一个<a class="ae jp" href="http://www.stroustrup.com/move.pdf" rel="noopener ugc nofollow" target="_blank">好文档</a>，它更好地解释了移动语义的好处。</p><p id="34d7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">11-λ</strong></p><p id="707d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">C++11提供了创建匿名函数的能力，称为lambda函数，你可以参考<a class="ae jp" href="http://www.stroustrup.com/C++11FAQ.html#lambda" rel="noopener ugc nofollow" target="_blank">这里的</a>了解更多关于这个新特性的细节。</p><p id="abfc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Folly在许多函数中使用它，下面是一个来自其源代码的例子:</p><figure class="kc kd ke kf fq kg fe ff paragraph-image"><div class="fe ff kw"><img src="../Images/e56929e627ed04798a28552bee52870a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/0*QbbwHU7vxRJpi2sh.png"/></div></figure><p id="5be7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 12-明确默认并删除特殊成员函数</strong></p><p id="b39e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在C++03中，编译器为自己没有提供的类提供了默认构造函数、复制构造函数、复制赋值运算符(<code class="eh jx jy jz ka b">operator=</code>)和析构函数。程序员可以通过定义自定义版本来覆盖这些默认值。</p><p id="9348" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，对这些默认值的创建几乎没有控制。例如，要使一个类本质上不可复制，需要声明一个私有的复制构造函数和复制赋值操作符，并且不定义它们。</p><p id="91bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在C++11中，某些特性可以被显式禁用。例如，下面的类型是不可复制的，这使得代码更加简单和干净。</p><figure class="kc kd ke kf fq kg fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff kx"><img src="../Images/4af48564c1c59eda16373dd51ca252b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eDvzDsbfHU0qmhOz.png"/></div></div></figure><p id="c03d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 13-覆盖标识符</strong></p><p id="0d43" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在C++03中，当一个人打算重写一个基类函数时，可能会意外地创建一个新的虚函数。</p><p id="d995" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jx jy jz ka b">override</code>特殊标识符意味着编译器将检查基类，看看是否有一个虚函数具有这个确切的签名。如果没有，编译器会指出一个错误。</p><p id="df92" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Folly广泛使用了这个新特性:</p><figure class="kc kd ke kf fq kg fe ff paragraph-image"><div class="fe ff ky"><img src="../Images/e3fd625f09e336f0ee0e085fec9f81fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/0*KYc38FvTxrSvloxY.png"/></div></figure><p id="a52e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 14- std::thread </strong></p><p id="45a7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">提供了一个线程类(<code class="eh jx jy jz ka b">std::thread</code>)，它接受一个函数对象——以及传递给它的一系列可选参数——在新线程中运行。</p><p id="c28c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在C++11中，使用线程变得更加简单，下面是定义新线程的新标准方法:</p><figure class="kc kd ke kf fq kg fe ff paragraph-image"><div class="fe ff kz"><img src="../Images/3602161b434e1c85511efdb05769a487.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/0*Jiw68T9i_rNdeZjU.png"/></div></figure><p id="c603" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 15-未订购的集装箱</strong></p><p id="f7a9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">无序容器是一种哈希表。C++11提供了四个标准的:</p><ul class=""><li id="996d" class="la lb hu it b iu iv iy iz jc lc jg ld jk le jo lf lg lh li dt translated">无序地图</li><li id="5460" class="la lb hu it b iu lj iy lk jc ll jg lm jk ln jo lf lg lh li dt translated">无序集合</li><li id="f90e" class="la lb hu it b iu lj iy lk jc ll jg lm jk ln jo lf lg lh li dt translated">无序_多重映射</li><li id="f800" class="la lb hu it b iu lj iy lk jc ll jg lm jk ln jo lf lg lh li dt translated">无序_多重集</li></ul><p id="8fe5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">愚蠢在许多地方使用这些新的容器</p><figure class="kc kd ke kf fq kg fe ff paragraph-image"><div class="fe ff lo"><img src="../Images/24a92146e8a3ed5dcf58d74feeffa08d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*BsMA1vGJYue4sfpM.png"/></div></figure><p id="66d8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">结论</strong></p><p id="0151" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Folly使用了几乎所有C++11的新特性，探索它的源代码会让你更好地了解C++的新功能，以及它们是如何实现的。</p><p id="c036" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我鼓励任何对C++11感兴趣的C++开发人员下载Folly源代码，发现这种新语言的强大之处。</p></div></div>    
</body>
</html>