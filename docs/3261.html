<html>
<head>
<title>Never Use Passwords Again with Ethereum and Metamask</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">永远不要在以太坊和元掩码中使用密码</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/never-use-passwords-again-with-ethereum-and-metamask-b61c7e409f0d?source=collection_archive---------0-----------------------#2017-03-23">https://medium.com/hackernoon/never-use-passwords-again-with-ethereum-and-metamask-b61c7e409f0d?source=collection_archive---------0-----------------------#2017-03-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/881467b756d7cd2152a3c3dbc0aadc84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4OVkgH58fl0F5KiBB_mvOw.jpeg"/></div></div></figure><div class=""/><p id="54cf" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我在<a class="ae ka" href="https://consensys.net/enterprise/" rel="noopener ugc nofollow" target="_blank"> ConsenSys </a>为各种客户建立了许多概念证明，通常他们想要利用<a class="ae ka" rel="noopener" href="/@asmiller1989/what-is-ethereum-c82a4b558553">以太坊</a>区块链来解决一些业务用例。奇怪的是，这些系统通常被设计成标准的网络登录(即用户名和<a class="ae ka" href="https://hackernoon.com/tagged/password" rel="noopener ugc nofollow" target="_blank">密码</a>)。</p><p id="64ca" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我总是问自己为什么要这样设计，毕竟，这是以太坊现在可以解决的每个web应用程序的一个恼人的方面。因此，我终于下定决心，设计出了这个解决方案。</p><h1 id="6bd6" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">JSON Web令牌</h1><p id="3a6b" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">登录标准web系统(和/或使用其API)的一种非常流行的方式是向身份验证端点提交密码(在客户端经过哈希处理),并接收一个令牌作为回报。这(通常)被称为JSON Web令牌，通常在有限的时间内有效(几分钟到几天)。这里的是一个关于标准实现的很好的教程。</p><p id="7e99" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">JSON Web令牌很棒，但我认为在区块链上验证自己很容易。其实你在使用以太坊的时候，也是在不断的做。</p><p id="6bbb" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你把一个以太坊地址(它只是你公钥的sha3散列)想象成一个网站上的账户，那么通过用你的私钥签署一段数据来证明你拥有那个账户是非常容易的。这些数据是任意的，可以是网站API提供的任何随机字符串。因此，我们可以使用地址作为用户名，而不需要密码。事实上，我们甚至不需要使用区块链来做到这一点。</p><p id="2893" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是使用Express时的样子:</p><p id="bef9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，我们需要用私钥做一个椭圆曲线签名:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="8c3c" class="ln kc if lj b fv lo lp l lq lr">var ethUtil = require(‘ethereumjs-util’);  // &gt;=5.1.1</span><span id="29ce" class="ln kc if lj b fv ls lp l lq lr">var data = ‘i am a string’;<br/>// Elliptic curve signature must be done on the Keccak256 Sha3 hash of a piece of data.<br/>var message = ethUtil.toBuffer(data);    <br/>var msgHash = ethUtil.hashPersonalMessage(message);    <br/>var sig = ethUtil.ecsign(msgHash, privateKey);    <br/>var serialized = ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))    <br/>return serialized</span></pre><p id="61ee" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在还不用太担心这些参数是什么。这里有一些加密技术，我鼓励你阅读椭圆曲线签名。比特币维基是一个不错的起点。</p><p id="3cc0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">无论如何，一旦我们有了我们的签名组件，我们就可以将它们与用户的地址一起打包，并将其全部发送到一个身份验证端点。</p><p id="2245" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">发布/认证</strong></p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="b7e0" class="ln kc if lj b fv lo lp l lq lr">var jwt = require(‘jsonwebtoken’);<br/>var ethUtil = require('ethereumjs-util');</span><span id="80c5" class="ln kc if lj b fv ls lp l lq lr">function checkSig(req, res) {<br/>  var sig = req.sig;<br/>  var owner = req.owner;</span><span id="0d72" class="ln kc if lj b fv ls lp l lq lr">  // Same data as before<br/>  var data = ‘i am a string’;</span><span id="75e6" class="ln kc if lj b fv ls lp l lq lr">  var message = ethUtil.toBuffer(data)<br/>  var msgHash = ethUtil.hashPersonalMessage(message)</span><span id="e6f2" class="ln kc if lj b fv ls lp l lq lr">  // Get the address of whoever signed this message  <br/>  var signature = ethUtil.toBuffer(sig)<br/>  var sigParams = ethUtil.fromRpcSig(signature)<br/>  var publicKey = ethUtil.ecrecover(msgHash, sigParams.v, sigParams.r, sigParams.s)<br/>  var sender = ethUtil.publicToAddress(publicKey)<br/>  var addr = ethUtil.bufferToHex(sender)<br/> <br/>  // Determine if it is the same address as 'owner' <br/>  var match = false;<br/>  if (addr == owner) { match = true; }</span><span id="7a1a" class="ln kc if lj b fv ls lp l lq lr">  if (match) {<br/>    // If the signature matches the owner supplied, create a<br/>    // JSON web token for the owner that expires in 24 hours.<br/>    var token = jwt.sign({user: req.body.addr}, ‘i am another string’,  { expiresIn: “1d” });<br/>    res.send(200, { success: 1, token: token })<br/>  } else {<br/>    // If the signature doesn’t match, error out<br/>    res.send(500, { err: ‘Signature did not match.’});<br/>  }</span><span id="6483" class="ln kc if lj b fv ls lp l lq lr">}</span></pre><p id="e1f3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，基本上，给定一些数据、地址和EC签名的组成部分，我们可以用密码证明该地址属于签署数据的人。很酷吧。</p><p id="cfe2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦我们对签名和地址匹配感到满意，我们就可以为地址服务器端签署一个JSON Web令牌。在这种情况下，令牌的有效期为1天。</p><p id="551a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们只需要放入一些中间件来保护任何提供或修改受保护信息的路由。</p><p id="efd0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">中间件/auth.js </strong></p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="b5a8" class="ln kc if lj b fv lo lp l lq lr">function auth(req, res, next) {<br/>  jwt.verify(req.body.token, ‘i am another string’, function(err, decoded) {<br/>    if (err) { res.send(500, { error: ‘Failed to authenticate token.’}); }<br/>    else {<br/>      req.user = decoded.user;<br/>      next();<br/>    };<br/>  });<br/>}</span></pre><p id="d513" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig"> app.js </strong></p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="4da4" class="ln kc if lj b fv lo lp l lq lr">// Routes<br/>app.post(‘/UpdateData’, auth, Routes.UpdateData);<br/>…</span></pre><p id="2a4d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果提供的令牌对应于发送请求的用户，我们继续请求的路由。注意中间件<strong class="je ig">修改了请求</strong>。我们需要引用的就是这个新的“用户”参数，因为我们知道它是在我们的中间件中设置的。</p><p id="f0da" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">发布/更新数据</strong></p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="1420" class="ln kc if lj b fv lo lp l lq lr">function UpdateData(req, res) {<br/>  // Only use the user that was set in req by auth middleware!<br/>  var user = req.user;<br/>  updateYourData(user, req.body.data);<br/>  ...<br/>}</span></pre><p id="b085" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们做到了！您的用户实际上已经<em class="lt">登录</em>了，但是不需要密码。</p><h1 id="1779" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">UI材料</h1><p id="5311" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">但是用户如何在浏览器中签署这些数据呢？<a class="ae ka" href="https://metamask.io/" rel="noopener ugc nofollow" target="_blank"> Metamask </a>来救援了！Metamask 是一个简洁的chrome扩展，它将web3 注入到你的浏览器窗口中。</p><p id="2b0d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig"> mycomponent.jsx </strong></p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="0c37" class="ln kc if lj b fv lo lp l lq lr">makeSig(dispatch) {<br/> <br/> function toHex(s) {<br/>   var hex = ‘’;<br/>   for(var i=0;i&lt;s.length;i++) { hex += ‘’+s.charCodeAt(i).toString(16); }<br/>   return `0x${hex}`;<br/> }<br/> <br/> var data = toHex(‘i am a string’);<br/> web3.currentProvider.sendAsync({ id: 1, method: 'personal_sign', params: [web3.eth.accounts[0], data] },<br/>   function(err, result) {<br/>     let sig = result.result;<br/>     dispatch(exchange.authenticate(sig, user))<br/>    })<br/>  }<br/>}</span><span id="0246" class="ln kc if lj b fv ls lp l lq lr">render(){<br/>  let { dispatch, _main: { sig } } = this.props;<br/>  if (Object.keys(sig).length == 0) { this.makeSig(dispatch); }<br/>  return (<br/>   &lt;p&gt;I am a webpage&lt;/p&gt;<br/>  );<br/>}</span></pre><p id="00e1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这将触发Metamask弹出一个窗口，要求用户签署消息:</p><figure class="le lf lg lh fq hw fe ff paragraph-image"><div class="fe ff lu"><img src="../Images/45d37eba8b3bc7553dcfd080cdabfda2.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*hm3c0wy4Ddt8-q17mVGI1g.png"/></div></figure><p id="d5f1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦回调被调用，它将调用以下操作:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="c92c" class="ln kc if lj b fv lo lp l lq lr">authenticate(sig, user) {<br/>  return (dispatch) =&gt; {<br/>    fetch(`${this.api}/Authenticate`, {<br/>      method: 'POST',<br/>      body: JSON.stringify({ owner: user, sig: sig}),<br/>      headers: { "Content-Type": "application/json" }<br/>    })<br/>    .then((res) =&gt; { return res.text(); })<br/>    .then((body) =&gt; {<br/>      var token = JSON.parse(body).token;<br/>      dispatch({ type: 'SET_AUTH_TOKEN', result: token})<br/>    })<br/>  }<br/>}</span></pre><p id="e1f2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦在reducer中保存了auth令牌，就可以调用经过身份验证的端点了。我们做到了！</p><p id="d366" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，<code class="eh lv lw lx lj b">v</code>、<code class="eh lv lw lx lj b">r</code>和<code class="eh lv lw lx lj b">s</code>值必须从签名中恢复。元掩码有一个<a class="ae ka" href="https://github.com/MetaMask/eth-sig-util" rel="noopener ugc nofollow" target="_blank">签名实用程序模块</a>，它显示了签名是如何构造的。可以这样解构:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="2c5b" class="ln kc if lj b fv lo lp l lq lr">var solidity_sha3 = require('solidity-sha3').default;</span><span id="d8dd" class="ln kc if lj b fv ls lp l lq lr">let hash = solidity_sha3(data);<br/>let sig = result.result.substr(2, result.result.length);<br/>let r = sig.substr(0, 64);<br/>let s = sig.substr(64, 64);<br/>let v = parseInt(sig.substr(128, 2));</span></pre><p id="1fcd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">其中<code class="eh lv lw lx lj b">r</code>将被解析为<code class="eh lv lw lx lj b">0</code>或<code class="eh lv lw lx lj b">1</code>。还要注意，这使用了<a class="ae ka" href="https://github.com/raineorshine/solidity-sha3" rel="noopener ugc nofollow" target="_blank"> solidity-sha3模块</a>来确保这个哈希算法与solidity的本地哈希方法使用的是同一个算法(我们正在哈希之前签名的十六进制字符串)。</p><h1 id="289b" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">生产就绪</h1><p id="5079" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我再怎么强调也不为过，每一个使用JSON web令牌的web应用程序都可以很容易地利用今天的T30和T31。任何具有元掩码扩展的用户都可以简单地绕过登录屏幕，其安全性可以说比您当前用来管理登录的任何东西都要好。这意味着忘记的密码更少，浪费的时间更少，用户群更快乐。</p><p id="9d2e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">而且，你知道，如果你想让你的用户在没有中介的情况下互相支付(或者你，或者任何其他使用它的系统上的用户),或者如果你想利用以太坊的数百万其他<a class="ae ka" href="https://github.com/ethereum/wiki/wiki" rel="noopener ugc nofollow" target="_blank">功能</a>,这也能让你做到这一点。</p><p id="cf59" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">今天就做出改变。<a class="ae ka" href="https://www.reddit.com/r/ethereum/" rel="noopener ugc nofollow" target="_blank">加入</a>美国以太坊民间，征服世界。</p><p id="f7ed" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt">— — — —</p><p id="9741" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="lt">以上作者表达的观点不一定代表Consensus Systems LLC DBA Consensys的观点。ConsenSys是一个分散的社区，ConsenSys Media是一个供成员自由表达其不同想法和观点的平台。要了解更多关于ConsenSys和以太坊的信息，请访问我们的网站。如果你喜欢这个作品，在这里注册</em><a class="ae ka" href="http://consensys.us11.list-manage.com/subscribe?u=947c9b18fc27e0b00fc2ad055&amp;id=257df01285" rel="noopener ugc nofollow" target="_blank"><em class="lt"/></a><em class="lt">为我们的每周简讯。</em></p><div class="le lf lg lh fq ab cb"><figure class="ly hw lz ma mb mc md paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="ly hw lz ma mb mc md paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="ly hw lz ma mb mc md paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="me mf mg"><p id="f922" class="jc jd lt je b jf jg jh ji jj jk jl jm mh jo jp jq mi js jt ju mj jw jx jy jz hn dt translated"><a class="ae ka" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是AMI家庭的一员。我们现在<a class="ae ka" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ka" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd lt je b jf jg jh ji jj jk jl jm mh jo jp jq mi js jt ju mj jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ka" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ka" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="le lf lg lh fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mk"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="le lf lg lh fq hw"><div class="bz el l di"><div class="ml mm l"/></div></figure></div></div>    
</body>
</html>