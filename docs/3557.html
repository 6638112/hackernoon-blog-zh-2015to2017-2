<html>
<head>
<title>The Angry Angular AsyncPipe &amp; The Evil Elvis Operator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">愤怒的角状不对称管道&amp;邪恶的猫王操作员</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-angry-angular-asyncpipe-the-evil-elvis-operator-89293e37e04d?source=collection_archive---------2-----------------------#2017-04-08">https://medium.com/hackernoon/the-angry-angular-asyncpipe-the-evil-elvis-operator-89293e37e04d?source=collection_archive---------2-----------------------#2017-04-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir"><p id="d6f9" class="is it hu bd iu iv iw ix iy iz ja jb ek translated"><code class="eh jc jd je jf b">async</code>烟斗和猫王(？)运算符非常有用…</p></blockquote><p id="f013" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc jb hn dt translated"><strong class="ji hv">但只有在你做原型| |开发的时候。</strong></p><p id="85d8" class="pw-post-body-paragraph jg jh hu ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jb hn dt ki translated">这些看似良性且超级方便的功能实际上令人担忧。虽然它们是对模板的小改动，但实际上比您想象的要多得多。此外，它们是隐藏潜在问题的糟糕实践，糟糕的代码……但我们稍后会谈到。</p></div><div class="ab cl ks kt hc ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hn ho hp hq hr"><p id="0055" class="pw-post-body-paragraph jg jh hu ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jb hn dt translated">首先，简单介绍一下angular实际使用你写的html模板的方式。Angular必须编译html并把它转换成javascript，非常非常漂亮的javascript。至少编译器已经尽了最大的努力，你知道……使用了所有的Elvis操作符和异步管道。</p><p id="7102" class="pw-post-body-paragraph jg jh hu ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jb hn dt translated">编译器将这个模板变成一个<a class="ae kz" href="https://hackernoon.com/tagged/ngfactory" rel="noopener ugc nofollow" target="_blank"> ngFactory </a>。如果你正在使用AoT(提前)编译，那么这是一个在你的文件系统上生成的实际文件，你可以打开它来阅读、检查和编辑它。这是一次很棒的学习经历。</p><blockquote class="ir"><p id="ca23" class="is it hu bd iu iv la lb lc ld le jb ek translated">很开心，很多头疼，很多白头发。</p></blockquote><p id="9d99" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc jb hn dt translated">否则，编译器会在运行时、内存中、浏览器中为每个客户端创建ngFactory，但这是另一篇文章的主题。你现在需要知道的是，ngFactory是渲染你的视图的东西。为了简单起见，可以把它想象成一堆带有一些事件监听器的<code class="eh jc jd je jf b">document.createElement</code> <em class="kr"> </em>调用，用于变化检测和其他魔法。</p><h1 id="929e" class="lf lg hu bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc dt translated">拆毁工厂</h1><p id="6da0" class="pw-post-body-paragraph jg jh hu ji b jj md jl jm jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc jb hn dt translated">当您添加这些特性中的任何一个时，ngFactory的代码都会发生相当大的变化，特别是在变化检测方法<code class="eh jc jd je jf b">detectChangesInternal</code>中传递给插值器的参数。</p><blockquote class="mi mj mk"><p id="06a2" class="jg jh kr ji b jj kd jl jm jn ke jp jq ml kf jt ju mm kg jx jy mn kh kb kc jb hn dt translated">一个简单的字符串插值看起来像这样，所以我们有一个比较的基础</p></blockquote><pre class="mo mp mq mr fq ms jf mt mu aw mv dt"><span id="c571" class="mw lg hu jf b fv mx my l mz na">{{ response.email }}</span></pre><figure class="mo mp mq mr fq nb"><div class="bz el l di"><div class="nc nd l"/></div><figcaption class="ne nf fg fe ff ng nh bd b be z ek">I’ve added some (generous) white-space for readability. I’ve also removed a lot of things to highlight the important bits.</figcaption></figure><p id="61bc" class="pw-post-body-paragraph jg jh hu ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jb hn dt translated">这很简单。如果有变化，<code class="eh jc jd je jf b">detectChangesInternal </code>触发并插入字符串<code class="eh jc jd je jf b">this.context.response.email</code>，并将其设置为<code class="eh jc jd je jf b">currVal_0</code>的值。然后，它将<code class="eh jc jd je jf b">this._text_1</code>的文本值(用<code class="eh jc jd je jf b">renderer.createElement()</code>创建的元素)设置为我们的插值字符串。</p><h1 id="ff91" class="lf lg hu bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc dt translated">猫王的，Elivs的，Elvi的还是精灵的？</h1><p id="7049" class="pw-post-body-paragraph jg jh hu ji b jj md jl jm jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc jb hn dt translated">这个操作符防止了许多运行时错误。如果你试图访问一个并不存在的嵌套很深的属性，你会有一段不好的时间。这就是这个运算符的作用。但是在你开始写这样的东西之前:</p><pre class="mo mp mq mr fq ms jf mt mu aw mv dt"><span id="6875" class="mw lg hu jf b fv mx my l mz na">{{ user?.account?.service?.joined?.dateFormatted }}</span></pre><blockquote class="mi mj mk"><p id="8fb1" class="jg jh kr ji b jj kd jl jm jn ke jp jq ml kf jt ju mm kg jx jy mn kh kb kc jb hn dt translated">这是我们得到的，我用几种不同的方式格式化了它</p></blockquote><figure class="mo mp mq mr fq nb"><div class="bz el l di"><div class="nc nd l"/></div><figcaption class="ne nf fg fe ff ng nh bd b be z ek">I’ve excluded the rest of the method, for brevity.</figcaption></figure><p id="3c78" class="pw-post-body-paragraph jg jh hu ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jb hn dt translated">这只是在一个页面上呈现一个字符串。四个嵌套的三元运算符。现在想象一下，如果你的模板中有这样的东西，会是什么样子:</p><pre class="mo mp mq mr fq ms jf mt mu aw mv dt"><span id="e599" class="mw lg hu jf b fv mx my l mz na">Service: {{ user?.account?.service?.name }}<br/>Formatted: {{ user?.account?.service?.joined?.dateFormatted }}<br/>Raw: {{ user?.account?.service?.joined?.dateRaw }}</span></pre><p id="942b" class="pw-post-body-paragraph jg jh hu ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jb hn dt translated">在里面放一些函数，可能是一两个可见的…</p><p id="2257" class="pw-post-body-paragraph jg jh hu ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jb hn dt translated"><code class="eh jc jd je jf b">*ngFor="let user of users"</code></p><p id="615e" class="pw-post-body-paragraph jg jh hu ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jb hn dt translated">然后乘以组件的数量…这就变成了一场噩梦。很快的。</p><p id="ec9d" class="pw-post-body-paragraph jg jh hu ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jb hn dt translated">人们想知道为什么他们的ng2应用程序运行缓慢且不稳定。</p><p id="4c52" class="pw-post-body-paragraph jg jh hu ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jb hn dt translated">谢天谢地，有办法避免这种情况。详情如下。</p><h1 id="fd4d" class="lf lg hu bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc dt translated">异步-只有5个字符，对吗？</h1><p id="b7e0" class="pw-post-body-paragraph jg jh hu ji b jj md jl jm jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc jb hn dt translated">异步管道将<code class="eh jc jd je jf b">ValueUnwrapper</code> <em class="kr"> </em>中的<code class="eh jc jd je jf b">reset</code> <em class="kr"> </em>和<code class="eh jc jd je jf b">unwrap</code> <em class="kr"> </em>方法添加到ngFactory中，这些只是一些我们并不真正需要进入的帮助器函数。肉是来自<code class="eh jc jd je jf b">AsyncPipe</code><em class="kr"/>的<code class="eh jc jd je jf b">transform</code>方法，它基本上将价值包装在一个可观察的(或者有时是一个承诺)中。</p><blockquote class="mi mj mk"><p id="7d5e" class="jg jh kr ji b jj kd jl jm jn ke jp jq ml kf jt ju mm kg jx jy mn kh kb kc jb hn dt translated">让我们看看下面的代码编译成了什么</p></blockquote><pre class="mo mp mq mr fq ms jf mt mu aw mv dt"><span id="1a66" class="mw lg hu jf b fv mx my l mz na">{{ (response | async) .email }}</span></pre><figure class="mo mp mq mr fq nb"><div class="bz el l di"><div class="nc nd l"/></div></figure><p id="e856" class="pw-post-body-paragraph jg jh hu ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jb hn dt translated">编译器还在条件中添加了另一个检查，确保从<code class="eh jc jd je jf b">AsyncPipe.transform</code>返回的值是一个包装值(<code class="eh jc jd je jf b">value.wrapped</code>而不仅仅是<code class="eh jc jd je jf b">value</code>)。不是非常昂贵的操作，但仍然增加了一些复杂性。</p><p id="b003" class="pw-post-body-paragraph jg jh hu ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jb hn dt translated">我要重点介绍的部分是<code class="eh jc jd je jf b">AsyncPipe.transform</code>。如上所述，这种方法创建了一个可观察对象，并订阅它(魔术)。当可观察对象发出一个值时，<code class="eh jc jd je jf b">AsyncPipe</code>标记<code class="eh jc jd je jf b">ViewRef</code>进行检查，认为AngularJS脏检查。但是在ng2里就不一样了。</p><p id="3960" class="pw-post-body-paragraph jg jh hu ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jb hn dt translated">变更检测上升到根元素。这意味着带有<code class="eh jc jd je jf b">AsyncPipe</code>的组件和根组件之间的每个组件都触发了它们的变更检测方法(标记为dirty/forCheck)。</p><p id="799d" class="pw-post-body-paragraph jg jh hu ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jb hn dt translated">还有更多的事情要做，但是你明白了。这需要执行大量代码，增加了复杂性。</p><p id="2cb1" class="pw-post-body-paragraph jg jh hu ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jb hn dt translated">如果这个管道被添加到一个5层深的组件中，它会对您的性能产生巨大的影响。尽管如此，angular团队在变更检测的实现上做了一些正确的事情。如果在实际运行变更检测之前，异步管道的数量发出了一个新值，那么每个被标记的组件只被检查一次。</p><p id="ac9b" class="pw-post-body-paragraph jg jh hu ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jb hn dt translated">然而，可能发生完全相反的情况，其中每个订阅连续发出一个值，并且所涉及的组件被检查多次，这可能是非常昂贵的操作。</p><h1 id="784d" class="lf lg hu bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc dt translated">结论(如何修复)</h1><p id="e60c" class="pw-post-body-paragraph jg jh hu ji b jj md jl jm jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc jb hn dt translated">elvis操作器和异步管道都可以一击解决。</p><blockquote class="mi mj mk"><p id="8580" class="jg jh kr ji b jj kd jl jm jn ke jp jq ml kf jt ju mm kg jx jy mn kh kb kc jb hn dt translated">国家管理- 1真理的源泉</p></blockquote><p id="c418" class="pw-post-body-paragraph jg jh hu ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jb hn dt translated">您的状态管理解决方案是:</p><ul class=""><li id="b2a0" class="ni nj hu ji b jj kd jn ke jr nk jv nl jz nm jb nn no np nq dt translated">真理的终极源泉- <code class="eh jc jd je jf b">AppStore</code></li><li id="4875" class="ni nj hu ji b jj nr jn ns jr nt jv nu jz nv jb nn no np nq dt translated">不变的</li><li id="906b" class="ni nj hu ji b jj nr jn ns jr nt jv nu jz nv jb nn no np nq dt translated">描述数据的形状-提供默认值</li></ul><p id="837c" class="pw-post-body-paragraph jg jh hu ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jb hn dt translated">最后一点很重要。如果你的组件订阅了你的状态，或者它的一个属性，而不是一个http请求，那么<code class="eh jc jd je jf b">AppStore</code>可以立即以组件需要的确切形式向组件发送默认值。然后，组件可以在服务上触发一个方法，服务发出一个API调用，当它完成时，它将更新状态，最后，由状态变化触发，<code class="eh jc jd je jf b">AppStore</code>向组件发出新数据。</p><p id="50e3" class="pw-post-body-paragraph jg jh hu ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jb hn dt translated">哇哦。如此简单。许多伟大的。</p><blockquote class="mi mj mk"><p id="f5e7" class="jg jh kr ji b jj kd jl jm jn ke jp jq ml kf jt ju mm kg jx jy mn kh kb kc jb hn dt translated"><a class="ae kz" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kz" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kz" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae kz" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="jg jh kr ji b jj kd jl jm jn ke jp jq ml kf jt ju mm kg jx jy mn kh kb kc jb hn dt translated">要了解更多信息，请<a class="ae kz" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae kz" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae kz" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="jg jh kr ji b jj kd jl jm jn ke jp jq ml kf jt ju mm kg jx jy mn kh kb kc jb hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kz" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kz" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="mo mp mq mr fq nb"><div class="bz el l di"><div class="nw nd l"/></div></figure></div></div>    
</body>
</html>