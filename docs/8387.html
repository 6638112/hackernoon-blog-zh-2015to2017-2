<html>
<head>
<title>Redux Patterns: Rethinking `byId` and `byHash` Structures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">冗余模式:反思“byId”和“byHash”结构</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/redux-patterns-rethinking-byid-and-byhash-structures-854e8a0fa32d?source=collection_archive---------7-----------------------#2017-11-30">https://medium.com/hackernoon/redux-patterns-rethinking-byid-and-byhash-structures-854e8a0fa32d?source=collection_archive---------7-----------------------#2017-11-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="cbfd" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">迭代Object.keys()并删除byId</h2></div><p id="af18" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在之前的一篇文章中(这是我阅读量最大的一篇文章)，我描述了一种在Redux存储中管理数据的模式，在Redux存储中，使用对象的id作为键对对象列表进行散列，然后在散列的旁边维护这些id的数组。</p><div class="kf kg fm fo kh ki"><a href="https://hackernoon.com/redux-patterns-add-edit-remove-objects-in-an-array-6ee70cab2456" rel="noopener  ugc nofollow" target="_blank"><div class="kj ab ej"><div class="kk ab kl cl cj km"><h2 class="bd hv fv z el kn eo ep ko er et ht dt translated">Redux模式:添加/编辑/删除数组中的对象</h2><div class="kp l"><h3 class="bd b fv z el kn eo ep ko er et ek translated">前几天我写了一篇关于如何在单个React组件中实现Redux风格的存储和缩减器的帖子…</h3></div><div class="kq l"><p class="bd b gc z el kn eo ep ko er et ek translated">hackernoon.com</p></div></div></div></a></div><p id="2711" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">结构看起来像这样:</p><pre class="kr ks kt ku fq kv kw kx ky aw kz dt"><span id="626a" class="la lb hu kw b fv lc ld l le lf">const reduxStore = {<br/>  data: {<br/>    byId: ['a', 'b'],<br/>    byHash: {<br/>      a: {someKey: "someValue", id: "a"},<br/>      b: {someKey: "someOtherValue", id: "b"}<br/>    }<br/>  }<br/>}</span></pre><p id="76fc" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">任何改变这个数据结构的动作都将被处理两次:一次是添加/删除<code class="eh lg lh li kw b">byId</code>数组中的任何键，另一次是添加/删除/更新存储在<code class="eh lg lh li kw b">byHash</code>散列中的相关数据。然而，现在我已经使用这个结构好几个月了，我发现大多数时候我都不用<code class="eh lg lh li kw b">byId</code>数组。所以我的结构是:</p><pre class="kr ks kt ku fq kv kw kx ky aw kz dt"><span id="dbcf" class="la lb hu kw b fv lc ld l le lf">const reduxStore = {<br/>  data: {<br/>    a: {someKey: "someValue", id: "a"},<br/>    b: {someKey: "someOtherValue", id: "b"}<br/>  }<br/>}</span></pre><p id="45a5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为什么我会掉<code class="eh lg lh li kw b">byId</code>？</p><h2 id="d911" class="la lb hu bd lj lk ll lm ln lo lp lq lr js ls lt lu jw lv lw lx ka ly lz ma mb dt translated">优点:</h2><ul class=""><li id="7804" class="mc md hu jl b jm me jp mf js mg jw mh ka mi ke mj mk ml mm dt translated">处理动作更简单，因为我只需更新一个数据结构来响应最常见的动作。</li><li id="2f4d" class="mc md hu jl b jm mn jp mo js mp jw mq ka mr ke mj mk ml mm dt translated">Redux存储对象具有较少嵌套</li><li id="52e7" class="mc md hu jl b jm mn jp mo js mp jw mq ka mr ke mj mk ml mm dt translated">使用<code class="eh lg lh li kw b">Object.keys(data).forEach</code>很容易实现迭代，或者在React应用程序中更常见的是:<code class="eh lg lh li kw b">Object.keys(data).map</code>。</li><li id="c606" class="mc md hu jl b jm mn jp mo js mp jw mq ka mr ke mj mk ml mm dt translated">长度随时可用<code class="eh lg lh li kw b">Object.keys(data).length</code>。</li></ul><h2 id="8bca" class="la lb hu bd lj lk ll lm ln lo lp lq lr js ls lt lu jw lv lw lx ka ly lz ma mb dt translated">预期缺点:</h2><ul class=""><li id="8ad1" class="mc md hu jl b jm me jp mf js mg jw mh ka mi ke mj mk ml mm dt translated">没有吗？(我错过了什么？)</li></ul><h2 id="d7df" class="la lb hu bd lj lk ll lm ln lo lp lq lr js ls lt lu jw lv lw lx ka ly lz ma mb dt translated">边缘案例缺点:</h2><ul class=""><li id="b777" class="mc md hu jl b jm me jp mf js mg jw mh ka mi ke mj mk ml mm dt translated">如果我的散列变得出乎意料的大，必须不断地计算长度，而不是直接从数组中取出长度，这可能是很昂贵的。实际上，我的散列通常只有不到几十个对象按键存储，所以维护<code class="eh lg lh li kw b">byId</code>属性的负担花费了更多的时间(并且让我编写更多的测试)。</li></ul><h1 id="7fec" class="ms lb hu bd lj mt mu mv ln mw mx my lr ja mz jb lu jd na je lx jg nb jh ma nc dt translated">结果，我到处都在使用这种模式</h1><p id="4947" class="pw-post-body-paragraph jj jk hu jl b jm me iv jo jp mf iy jr js nd ju jv jw ne jy jz ka nf kc kd ke hn dt translated">最典型的用例是我经常需要迭代这个数据结构(forEach)或者做一些类似函数的操作(map/filter/reduce)。这很容易实现:</p><ol class=""><li id="d4d2" class="mc md hu jl b jm jn jp jq js ng jw nh ka ni ke nj mk ml mm dt translated">呈现React组件列表</li></ol><pre class="kr ks kt ku fq kv kw kx ky aw kz dt"><span id="0faf" class="la lb hu kw b fv lc ld l le lf">{Object.keys(this.props.data)<br/>  .map(key =&gt; {<br/>    // operate on the full value since `key` is just the key<br/>    <strong class="kw hv">const renderData = this.props.data[key]; </strong></span><span id="8868" class="la lb hu kw b fv nk ld l le lf">    return &lt;div&gt;{renderData.someValue}&lt;/div&gt;<br/>  })<br/>}</span></pre><p id="c66a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">2.基于每个对象中的一些值进行过滤</p><pre class="kr ks kt ku fq kv kw kx ky aw kz dt"><span id="e0a0" class="la lb hu kw b fv lc ld l le lf">{Object.keys(this.props.data)<br/>  .filter(key =&gt; {<br/>    // again, operate on the full value, not the key<br/>    return <strong class="kw hv">this.props.data[key].value</strong> === condition;<br/>  })<br/>  .map( ....)<br/>}</span></pre><p id="fcce" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您可以一遍又一遍地重复使用这个基本模式。想按对象中的值排序吗？<code class="eh lg lh li kw b">Object.keys(data).sort((a,b) =&gt; {})</code>如果列表长度为零，想要避免显示某些数据吗？所有的问题都由相同的基本代码解决。</p><p id="8c63" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当然这有点多余，但这并不比:</p><pre class="kr ks kt ku fq kv kw kx ky aw kz dt"><span id="5d10" class="la lb hu kw b fv lc ld l le lf">{data.byId.map(id =&gt; {<br/>  const renderData = data.byHash[id];<br/>  return &lt;div&gt;{renderData.someValue}&lt;/div&gt;<br/>})}</span></pre></div><div class="ab cl nl nm hc nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="hn ho hp hq hr"><h1 id="8d9f" class="ms lb hu bd lj mt ns mv ln mw nt my lr ja nu jb lu jd nv je lx jg nw jh ma nc dt translated">性能考虑因素</h1><p id="1852" class="pw-post-body-paragraph jj jk hu jl b jm me iv jo jp mf iy jr js nd ju jv jw ne jy jz ka nf kc kd ke hn dt translated">感谢<a class="nx ny gr" href="https://medium.com/u/846abfc7bfa9?source=post_page-----854e8a0fa32d--------------------------------" rel="noopener" target="_blank">马克·埃里克森</a>对<a class="ae nz" rel="noopener" href="/@mark.erikson/i-do-have-a-few-thoughts-here-afa330de153a">的精彩评论</a>将过滤逻辑转移到渲染周期中的一些性能影响。</p><blockquote class="oa ob oc"><p id="07be" class="jj jk od jl b jm jn iv jo jp jq iy jr oe jt ju jv of jx jy jz og kb kc kd ke hn dt translated">虽然在<code class="eh lg lh li kw b">mapState</code>函数和组件的<code class="eh lg lh li kw b">render</code>方法中应该做什么没有严格的规则，但是我的一般建议是<code class="eh lg lh li kw b">mapState</code>应该负责形成组件实际需要的数据。这与这样一个事实相联系，即连接更多的组件通常会导致更好的性能，并且最小化给定的已连接组件从存储中需要的数据量将意味着它将更少地重新呈现。所以，我的方法通常是在<code class="eh lg lh li kw b">mapState</code>级别应用过滤和排序类型的行为，这样组件只得到它实际需要渲染的数据。</p><p id="9be0" class="jj jk od jl b jm jn iv jo jp jq iy jr oe jt ju jv of jx jy jz og kb kc kd ke hn dt translated">此外，如果<code class="eh lg lh li kw b">mapState</code>从一个调用到另一个调用返回完全相同的值，那么<code class="eh lg lh li kw b">connect</code>将跳过重新渲染普通组件，这通常是一种性能改进。</p></blockquote><p id="ae87" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><a class="ae nz" rel="noopener" href="/@justintulk/reselect-style-memoization-in-3-functions-aff30f8cba11">我将深入研究记忆</a>并在将来的某个时候更新，但现在我将确保在我的Redux选择器中尽可能多地处理这些。一个简单的例子:</p><pre class="kr ks kt ku fq kv kw kx ky aw kz dt"><span id="62a7" class="la lb hu kw b fv lc ld l le lf">render() {<br/>  return (<br/>    &lt;div&gt;{Object.keys(this.props.data).map(key =&gt; {<br/>      const val = this.props.data[key]<br/>      return (&lt;span&gt;{val.text}&lt;/span&gt;)<br/>    })&lt;/div&gt;<br/>  )<br/>}</span><span id="1134" class="la lb hu kw b fv nk ld l le lf">const mapStateToProps = state =&gt; ({ data: state.myData })</span><span id="06e8" class="la lb hu kw b fv nk ld l le lf">// could easily become this to clean up logic:</span><span id="0d00" class="la lb hu kw b fv nk ld l le lf">render() {<br/>  return (<br/>    &lt;div&gt;{this.props.data.map(val =&gt; (<br/>      &lt;span&gt;{val.text}&lt;/span&gt;<br/>    ))}&lt;/div&gt;<br/>  )<br/>}</span><span id="b365" class="la lb hu kw b fv nk ld l le lf">const mapStateToProps = state =&gt; ({ <br/>  data: Object.keys(state.myData).map(key =&gt; state.myData[key])<br/>})</span></pre><p id="6ac3" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您甚至可以在选择器中重新创建<code class="eh lg lh li kw b">byId</code>和<code class="eh lg lh li kw b">byHash</code>模式，以获得其好处，而不必在您的商店中维护一个并行数组。</p><pre class="kr ks kt ku fq kv kw kx ky aw kz dt"><span id="3f36" class="la lb hu kw b fv lc ld l le lf">const mapStateToProps = state =&gt; {<br/>  const myKeys = Object.keys(state.myData)</span><span id="cf32" class="la lb hu kw b fv nk ld l le lf">  return {<br/>    byId: myKeys,<br/>    byHash: myKeys.map(key =&gt; state.myData[key])<br/>  }<br/>}</span></pre></div><div class="ab cl nl nm hc nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="hn ho hp hq hr"><p id="b983" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">像往常一样，如果您不同意，或者您看到了我忽略的东西，请留言。</p><div class="kf kg fm fo kh ki"><a rel="noopener follow" target="_blank" href="/@justintulk/reselect-style-memoization-in-3-functions-aff30f8cba11"><div class="kj ab ej"><div class="kk ab kl cl cj km"><h2 class="bd hv fv z el kn eo ep ko er et ht dt translated">3个函数中的重选式记忆</h2><div class="kp l"><h3 class="bd b fv z el kn eo ep ko er et ek translated">我一直在通读Reselect的源代码(只有107行没有被修改)，我认为它可能值得拆包…</h3></div><div class="kq l"><p class="bd b gc z el kn eo ep ko er et ek translated">medium.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om on ki"/></div></div></a></div></div></div>    
</body>
</html>