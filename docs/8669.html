<html>
<head>
<title>Java Default Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java默认方法</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/java-8-default-methods-37fc65c6a85a?source=collection_archive---------7-----------------------#2017-12-10">https://medium.com/hackernoon/java-8-default-methods-37fc65c6a85a?source=collection_archive---------7-----------------------#2017-12-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/5a1cb5ce2b3b5590272043efacecf1d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ynnaISC0gTdj1_RnWsSv7A.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/xnUQO2DwXOo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Christian Kaindl</a> on <a class="ae jg" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1f20" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">作为一名多年的Java开发人员，您可能对Java应该是什么样子有非常强烈的感觉。面向对象、单继承、多接口实现、泛型等。但是自从Java 8诞生以来，情况略有变化。你试过如何在接口中声明可选函数吗？</p><h1 id="d485" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">历史</h1><p id="eb7b" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">Java 8带来了许多现代的、强大的新特性——<a class="ae jg" rel="noopener" href="/@jintin/lambda-expression-in-java-ca9e1222eb7c"/>、流等等。尽管全新的特性伴随着我们不熟悉的全新语法而来，但Java的基础依然牢固。但是如果我们想在接口层支持的话，这将是一个突破性的改变。比方说，如果我们想在现有的接口中添加新的功能，所有的实现都应该更新，否则就会中断。对我们来说，将会有一个很大的兼容问题，所以这里出现了默认方法的想法。它允许我们将功能实现添加到接口中。所以升级到Java 8不会让我们头疼。</p><blockquote class="li lj lk"><p id="091f" class="jh ji ll jj b jk jl jm jn jo jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd ke hn dt translated">如果你对Lambda感兴趣，可以在这里查看Java中的<a class="ae jg" rel="noopener" href="/@jintin/lambda-expression-in-java-ca9e1222eb7c"> Lambda表达式</a></p></blockquote></div><div class="ab cl lp lq hc lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hn ho hp hq hr"><h1 id="18b9" class="kf kg hu bd kh ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc dt translated">默认方法</h1><p id="f31c" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">可以想象，在现有的接口中添加新的功能是很困难的，因为我们需要在世界各地添加实现。所以我们决定将实现直接添加到接口本身。下面是一个基本的例子:</p><pre class="mb mc md me fq mf mg mh mi aw mj dt"><span id="06f9" class="mk kg hu mg b fv ml mm l mn mo">public interface A {<br/><br/>  <strong class="mg hv">default</strong> void a() <strong class="mg hv">{</strong><br/>    // add implementation here<br/>  <strong class="mg hv">}</strong><br/>}</span></pre><p id="897d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">是的，就这么简单。如果你把关键字<code class="eh mp mq mr mg b">default</code>放在接口中函数声明的前面，那么你可以像普通函数一样添加实现。</p><p id="7ce9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有了这个新功能，我们可以实现一些以前做不到的事情，甚至是一些邪恶的事情。</p><ol class=""><li id="622a" class="ms mt hu jj b jk jl jo jp js mu jw mv ka mw ke mx my mz na dt translated">可选功能。</li><li id="9d3a" class="ms mt hu jj b jk nb jo nc js nd jw ne ka nf ke mx my mz na dt translated">多重遗传。</li><li id="4c01" class="ms mt hu jj b jk nb jo nc js nd jw ne ka nf ke mx my mz na dt translated">共同实施。</li></ol><h1 id="f831" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">任选功能</h1><p id="ac28" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">如果我们在接口中有一个函数，我们想把它标记为可选的，我们可以给它添加一个空的实现。</p><pre class="mb mc md me fq mf mg mh mi aw mj dt"><span id="ad7d" class="mk kg hu mg b fv ml mm l mn mo">public interface A {<br/><br/>  <strong class="mg hv">default void a() {<br/>  }<br/></strong>}</span><span id="a7f5" class="mk kg hu mg b fv ng mm l mn mo">public Class realA implement A {<br/>  // no need to implement a() again<br/>}</span></pre><p id="0a63" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">除了多余的气味之外，你应该问问你自己，你的界面是否承担了太多我们可以分成不同部分的责任。没有对错之分，但是在你动笔之前，一定要多考虑一秒钟。</p><h1 id="cc8d" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">多重遗传</h1><p id="74de" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">Java不支持多重继承，但由于接口现在可以实现，它几乎像一种可多重继承的语言。</p><pre class="mb mc md me fq mf mg mh mi aw mj dt"><span id="73e5" class="mk kg hu mg b fv ml mm l mn mo">public interface A {<br/>  <strong class="mg hv">default void common() {<br/>    System.out.println("This is common a.");<br/>  }</strong><br/>}</span><span id="2833" class="mk kg hu mg b fv ng mm l mn mo">public interface B {<br/>  <strong class="mg hv">default void common() {<br/>    System.out.println("This is common b.");<br/>  }</strong><br/>}</span><span id="a0ab" class="mk kg hu mg b fv ng mm l mn mo">public Class realAB implement A, B {<br/>  public void test() {<br/>    <strong class="mg hv">common();</strong><br/>  }<br/>}</span></pre><p id="342a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh mp mq mr mg b">common()</code>会执行哪一个？a还是B？结果是编译失败。多重继承不仅仅是Java 8的问题，这里有一个通用的解决方案:我们应该向编译器提供上下文。</p><pre class="mb mc md me fq mf mg mh mi aw mj dt"><span id="951e" class="mk kg hu mg b fv ml mm l mn mo">public Class realAB implement A, B {<br/>  public void test() {<br/>    <strong class="mg hv">A.super.common(); // execute A<br/>    B.super.common(); // execute B</strong><br/>  }<br/>}</span></pre><p id="82ab" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">问题解决了。但是如果可能的话，我们应该尽量避免重复命名的情况。</p><h1 id="3e4b" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">通用实现</h1><p id="a633" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">如果一个接口包含一些通用的实现。这是默认方法的最佳匹配。这里有一个简单的例子。</p><pre class="mb mc md me fq mf mg mh mi aw mj dt"><span id="1ad6" class="mk kg hu mg b fv ml mm l mn mo">public interface Callback&lt;T&gt; {<br/>  void success(T t);</span><span id="eb82" class="mk kg hu mg b fv ng mm l mn mo">  default void fail(String msg) {<br/>    LogUtils.log(msg);<br/>    UIUtils.showError(msg);<br/>  }<br/>}</span><span id="090b" class="mk kg hu mg b fv ng mm l mn mo">public Class ClassA implement Callback&lt;A&gt; {</span><span id="411d" class="mk kg hu mg b fv ng mm l mn mo">  public void success(A a) {<br/>    // success A<br/>  }<br/>}</span><span id="692a" class="mk kg hu mg b fv ng mm l mn mo">public Class ClassB implement Callback&lt;B&gt; {</span><span id="255d" class="mk kg hu mg b fv ng mm l mn mo">  public void success(B b) {<br/>    // success B<br/>  }<br/>}</span></pre><p id="7f6d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果每个<code class="eh mp mq mr mg b">fail()</code>功能都有相同的逻辑，就没有必要重复。</p><h1 id="1838" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">摘要</h1><p id="8205" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">默认方法为开发Java应用程序带来了一个新世界。但是我们仍然需要区分类、抽象类和接口的不同角色。我们应该利用默认方法的能力，但仍然遵守我们的基本规则——接口是接口，而不是类或抽象类。</p><h1 id="3cb8" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">参考</h1><div class="nh ni fm fo nj nk"><a href="https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab ej"><div class="nm ab nn cl cj no"><h2 class="bd hv fv z el np eo ep nq er et ht dt translated">默认方法(Java教程&gt;学习Java语言&gt;接口和继承)</h2><div class="nr l"><h3 class="bd b fv z el np eo ep nq er et ek translated">这篇Java初学者教程描述了Java编程语言的编程基础</h3></div><div class="ns l"><p class="bd b gc z el np eo ep nq er et ek translated">docs.oracle.com</p></div></div></div></a></div></div></div>    
</body>
</html>