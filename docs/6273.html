<html>
<head>
<title>Simple HTTP middleware with Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带Go的简单HTTP中间件</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/simple-http-middleware-with-go-79a4ad62889b?source=collection_archive---------4-----------------------#2017-09-11">https://medium.com/hackernoon/simple-http-middleware-with-go-79a4ad62889b?source=collection_archive---------4-----------------------#2017-09-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="a0d4" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">只使用标准库</h2></div><p id="830f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">围绕传入服务器的<a class="ae kf" href="https://hackernoon.com/tagged/http" rel="noopener ugc nofollow" target="_blank"> HTTP </a>请求进行各种操作是一种常见的需求。最常见的例子是日志记录和跟踪。尽管有各种框架提供这种现成的功能，但我想说明只使用标准库来创建这种逻辑是多么简单。构建您自己的实现为您提供了完全的灵活性和对行为的控制，减少了对外部依赖性的需求。</p><p id="4b4b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">理想情况下，在我的简单示例的上下文中，我希望API看起来像这样:</p><figure class="kg kh ki kj fq kk"><div class="bz el l di"><div class="kl km l"/></div></figure><p id="46d7" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在上面的例子中，我使用<code class="eh kn ko kp kq b">chainMiddleware</code>为我的所有处理程序创建了一个包装器，它用我定义并作为参数传递给这个函数的日志和跟踪中间件<a class="ae kf" href="https://hackernoon.com/tagged/middleware" rel="noopener ugc nofollow" target="_blank">来增强<code class="eh kn ko kp kq b">home</code>和<code class="eh kn ko kp kq b">about</code>。</a></p><p id="ec79" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了做到这一点，我们需要定义一个中间件类型。它可以定义为:</p><figure class="kg kh ki kj fq kk"><div class="bz el l di"><div class="kl km l"/></div></figure><p id="e0c1" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，<code class="eh kn ko kp kq b">middleware</code>将被定义为返回新处理程序的函数，该处理程序将在调用作为参数提供的下一个处理程序之前(或之后)执行一些操作。为了简洁起见，我们将使用<code class="eh kn ko kp kq b"><a class="ae kf" href="https://golang.org/pkg/net/http#HandlerFunc" rel="noopener ugc nofollow" target="_blank">http.HandlerFunc</a></code>而不是经典的<code class="eh kn ko kp kq b"><a class="ae kf" href="https://golang.org/pkg/net/http#Handler" rel="noopener ugc nofollow" target="_blank">http.Handler</a></code>来举例说明这些例子。行为是相同的。</p><p id="e976" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">使用这个模式，我们将虚拟的<code class="eh kn ko kp kq b">withLogging</code>和<code class="eh kn ko kp kq b">withTracing</code>中间件定义如下:</p><figure class="kg kh ki kj fq kk"><div class="bz el l di"><div class="kl km l"/></div></figure><p id="aa5d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们的中间件纯粹是说明性的，除了记录已经采取的行动之外什么也不做。</p><p id="ea1e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">理论上，我们已经可以使用这种实现，而不需要<code class="eh kn ko kp kq b">chainMiddleware</code>，只需将每条路由定义如下:</p><figure class="kg kh ki kj fq kk"><div class="bz el l di"><div class="kl km l"/></div></figure><p id="efd2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这很好，也很有效，但是如果我们引入更多的中间件，很快就会变得乏味和冗长。因此，我们的chain函数为将多个中间件链接成一个中间件提供了很好的语法糖。</p><p id="26c9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们看一下实现:</p><figure class="kg kh ki kj fq kk"><div class="bz el l di"><div class="kl km l"/></div></figure><p id="ebac" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通过利用Go的函数式编程特性，我们可以使用上面的实现来链接一系列中间件，这些中间件按照提供的顺序相互调用，为我们的处理程序返回一个新的包装器。我们以相反的顺序获取列表中的每个中间件函数，并将它的返回值作为参数传递给它前面的函数，从<code class="eh kn ko kp kq b">final</code>处理程序开始。这样，链就按照传入的顺序发生了。</p><p id="62c6" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，如果我们运行程序并在浏览器中访问<code class="eh kn ko kp kq b">http://localhost:8080</code>,在调用最终处理程序之前，我们应该会在控制台中看到类似下面的输出:</p><p id="b52e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kn ko kp kq b">main.go:34: Logged connection from [::1]:54962</code> <br/> <code class="eh kn ko kp kq b">main.go:41: Tracing request for /</code></p><p id="b4c8" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">就这么简单！你可以在这里找到完整的运行示例<a class="ae kf" href="https://gist.github.com/gbbr/85448fc35bf1a008363a4f5da469fa4d" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="kg kh ki kj fq kk"><div class="bz el l di"><div class="kr km l"/></div></figure></div></div>    
</body>
</html>