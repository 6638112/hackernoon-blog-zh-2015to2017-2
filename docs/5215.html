<html>
<head>
<title>No REST for the wicked</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">恶人不得安宁</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/no-rest-for-the-wicked-989c933be99b?source=collection_archive---------7-----------------------#2017-07-16">https://medium.com/hackernoon/no-rest-for-the-wicked-989c933be99b?source=collection_archive---------7-----------------------#2017-07-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="5173" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这篇文章(也读作<em class="jp">咆哮</em>)受到了阅读<a class="ae jq" href="https://mmikowski.github.io/the_lie/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>的沉重启发，这篇文章用文字表达了这些年来在我脑海中浮动的一些东西，让服务彼此之间进行对话，无论是API、移动客户端还是其他什么。</p><blockquote class="jr js jt"><p id="8754" class="ir is jp it b iu iv iw ix iy iz ja jb ju jd je jf jv jh ji jj jw jl jm jn jo hn dt translated">为什么我们他妈的到处都在用<em class="hu"> REST~ish </em> API？</p></blockquote><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div class="fe ff jx"><img src="../Images/5c10d8c424c833960a80533335754e19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*xlUf1WFioivefp16."/></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">if you don’t get this, we cannot talk about music…</figcaption></figure><h2 id="85c2" class="kj kk hu bd kl km kn ko kp kq kr ks kt jc ku kv kw jg kx ky kz jk la lb lc ld dt translated">问题是</h2><p id="4d6f" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">似乎现在一个体面的开发人员必须知道并使用REST，但是我们是如何做的呢？<br/>对我来说，实施它或只是消费它显然有很多问题。开头引用的那篇文章已经涵盖了主要观点，但我只对其中的一些观点进行评论:</p><h2 id="d0ea" class="kj kk hu bd kl km kn ko kp kq kr ks kt jc ku kv kw jg kx ky kz jk la lb lc ld dt translated">1." RESTful APIs通常绑定在HTTP上"</h2><p id="0cfe" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">并利用它分散了太多的逻辑:标题、动词、uri、响应代码和正文。这使得调试变得困难，而且完全不直观，导致随机实现。<br/>当你想使用第三方RESTxxx API时，你<strong class="it hv">必须</strong>阅读文档，因为你不能想当然地给出任何东西:</p><ul class=""><li id="c94b" class="lj lk hu it b iu iv iy iz jc ll jg lm jk ln jo lo lp lq lr dt translated">我需要在查询字符串中提供一个头或一个令牌来认证调用吗？</li><li id="699e" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">表头是如何命名的？</li><li id="ef92" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">要创建资源，我应该使用POST还是PUT？</li><li id="81e2" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">最新消息呢。</li><li id="01b1" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">对于一个upsert？</li><li id="b278" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">出现错误时，我是只检查状态代码还是还要检查有效载荷？(有多少API在有效负载中有“status”字段？我自己也做过，很多次)</li><li id="7c6d" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">错误信息是什么？</li><li id="802e" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">要过滤或查询资源列表，我应该在查询字符串中使用哪些字段？</li><li id="2b03" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">如果我想要的不是普通的资源，而是混合的集合呢？</li></ul><h2 id="89b1" class="kj kk hu bd kl km kn ko kp kq kr ks kt jc ku kv kw jg kx ky kz jk la lb lc ld dt translated">2.“其余词汇不够丰富”</h2><p id="2bb5" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">这是绝对正确的，因为REST是在<em class="jp">资源</em>、<em class="jp"> CRUD </em>操作以及将它们链接起来的概念之后设计的。这是一个很好的模型来表示链接的数据并像在RDBMS上一样管理它，但是API通常不仅仅是这样。<br/>让我们想象一个移动社交应用程序API，其中您必须:</p><ul class=""><li id="9a3a" class="lj lk hu it b iu iv iy iz jc ll jg lm jk ln jo lo lp lq lr dt translated">注册一个用户<br/> - &gt; <em class="jp">放、贴用户资源？</em></li><li id="f3fc" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">认证一个用户<br/> - &gt; <em class="jp">是资源吗？？？</em></li><li id="3a9b" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">创建一个新的博客条目<br/>-&gt;-<em class="jp">这个我知道！！</em> <code class="eh lx ly lz ma b"><em class="jp">POST /blog</em></code> <em class="jp">曹真！！完成了。休息太棒了！</em></li><li id="50ef" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">像一个帖子<br/> - &gt; <em class="jp"> mmm可能是</em> <code class="eh lx ly lz ma b"><em class="jp">POST /blog/666</em></code> <em class="jp">，但是我没有有效载荷！我可以用GET吗？这个动作真的创建了一个“like”资源还是仅仅是博客条目资源上的一个标志？我应该使用PUT来更新博客条目资源吗？… wtf </em></li><li id="4d5e" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">搜索收藏资源<br/> - &gt; <code class="eh lx ly lz ma b"><em class="jp">GET /resource</em></code> <em class="jp">是的！搜索标准和过滤器？queryString参数？车身有效载荷？如果我需要一个帖子，但我没有创造任何东西:(他妈的肥皂不是更好吗？绝对不会。但是wtf！</em></li><li id="273b" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">求一个用户的个人资料但有或多或少的信息<br/> - &gt; <em class="jp">查询字符串参数？另一个uri端点？</em></li><li id="bb5f" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">结交新朋友请求<br/> - &gt; <em class="jp">嚯操！</em></li></ul><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div class="fe ff mb"><img src="../Images/724ecae4aff31c828a3694307a2b5fd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*HlVw0Hly7m8727AV.gif"/></div></figure><p id="275d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个混乱，每个人都在以不同的方式做这件事，其他相关的框架也有他们自己的理念。</p><p id="3d7f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">休息是一种祝福，因为它让我们从肥皂的束缚中解脱出来，但代价是什么呢？我猜是困惑。<br/>每当我们必须设计一个REST~ish API时，我们必须回答太多的问题，问题是<strong class="it hv">没有正确的答案</strong>。</p><h2 id="2ba5" class="kj kk hu bd kl km kn ko kp kq kr ks kt jc ku kv kw jg kx ky kz jk la lb lc ld dt translated">现有解决方案</h2><p id="13d3" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">显然我不是唯一一个有这些感觉的人，所以周围有人试图解决这些问题，引用文章的作者提出了他的解决方案<a class="ae jq" href="https://mmikowski.github.io/json-pure/" rel="noopener ugc nofollow" target="_blank"> JSON-pure API </a>。我认为它不是很漂亮和有用，有点像回到了一个类似肥皂的东西，但是它有很棒的想法:</p><ul class=""><li id="8641" class="lj lk hu it b iu iv iy iz jc ll jg lm jk ln jo lo lp lq lr dt translated">不知道传输，没有更多重要的内容附加到协议特定的东西，如响应代码和头部，使我们能够使用我们应该需要的任何传输:HTTP，Websocket，XMPP …</li><li id="078c" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">JSON很容易调试</li></ul><p id="fef6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">更稳定和被采用的东西就在那里:<a class="ae jq" href="http://jsonapi.org/" rel="noopener ugc nofollow" target="_blank"> jsonapi </a>，<a class="ae jq" href="http://stateless.co/hal_specification.html" rel="noopener ugc nofollow" target="_blank"> HAL </a>，<a class="ae jq" href="https://github.com/JornWildt/Mason" rel="noopener ugc nofollow" target="_blank"> Mason </a>，<a class="ae jq" href="https://github.com/collection-json/spec" rel="noopener ugc nofollow" target="_blank"> Collection json </a>。我认为每一个都不是完整的，或者只是以不同的方式处理相同的资源/CRUD模型。</p><p id="d083" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我还认为:我们需要一种标准来做标准的事情。我认为应该有一个最佳实践来验证API、错误处理和响应格式，从API消费者的角度来看，这些东西可以让您更快地集成。SOAP虽然很糟糕，但是让你自己创建客户端可能太多了，但是它使用起来很直观，其他的东西则不然。<br/>不，我不想回到SOAP :P所以…</p><h2 id="62f8" class="kj kk hu bd kl km kn ko kp kq kr ks kt jc ku kv kw jg kx ky kz jk la lb lc ld dt translated">一个想法…</h2><p id="fd53" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">新思想是旧思想。我不打算写一个新的协议规范</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div class="fe ff mc"><img src="../Images/90eb9dda375b0544b667cb3e1133867f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*A-KwNlmdkUdMlKfo.png"/></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">xkcd</figcaption></figure><p id="a24f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我认为正确的东西已经存在，但只是需要放在一起。因此，我想写的更多的是“最佳实践的规范”或“只是已知协议组合的协议”。</p><h2 id="a711" class="kj kk hu bd kl km kn ko kp kq kr ks kt jc ku kv kw jg kx ky kz jk la lb lc ld dt translated">它应该由什么组成？</h2><ul class=""><li id="3e9d" class="lj lk hu it b iu le iy lf jc md jg me jk mf jo lo lp lq lr dt translated">既然API不仅仅是CRUD操作，而是更多类似于<em class="jp">动作</em>或<em class="jp">过程</em>的东西，也许一个简单的<strong class="it hv"> RPC </strong>就是我们所需要的。我们已经有了一个很好的规范:<a class="ae jq" href="http://www.jsonrpc.org/specification" rel="noopener ugc nofollow" target="_blank"> JSON-RPC </a>。它很干净，像json一样简单，与传输无关，而且已经有很多客户端库了。</li><li id="87de" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">请求认证，在需要的地方，应该嵌入在这个协议和<a class="ae jq" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> JWT </strong> </a>我认为是合适的。<br/>关于认证的RPC方法也应该在协议规范中标准化jwt生成。</li><li id="f933" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">我们可以冒险一跳，让JSON-RPC有效负载上的<a class="ae jq" href="http://json-schema.org" rel="noopener ugc nofollow" target="_blank"> JSON Schema </a>来验证API格式，并且毫不费力地从schema (hello again SOAP :3)自动生成API客户端库。</li></ul><h2 id="c175" class="kj kk hu bd kl km kn ko kp kq kr ks kt jc ku kv kw jg kx ky kz jk la lb lc ld dt translated">你确定你需要RPC吗有个东西叫GraphQL …</h2><p id="f8b9" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">我记下这些关于休息的想法已经有一段时间了，但是从来没有进行过有机的讨论，看来我等得太久了。我并不是昨天才偶然发现GraphQL的，我对它只是略知一二，我认为它是一种检索数据的好方法。近距离的观察让我完全重新考虑RPC。有了<em class="jp">突变</em>你可以实现任何事情，这真的就像一个RPC提前声明你想要的结果，很美。RPC所缺少的是响应中统一的错误处理，GraphQL在这方面没有强制任何东西。与RPC不同的是，GraphQL也不处理认证，所以你必须自己处理，谁说的JWT？？。<br/>我们可以在查询/变异中嵌入两者，类似于:</p><pre class="jy jz ka kb fq mg ma mh mi aw mj dt"><span id="c629" class="kj kk hu ma b fv mk ml l mm mn">mutation {<br/>  login(username: String!, password: String!) {<br/>    token<br/>    error<br/>  }<br/>}<br/><br/><br/>query {<br/>    myUltraAwesomeApi(token: String, aParameter: String) {<br/>        error,<br/>        result<br/>    }<br/>}</span></pre><h2 id="9305" class="kj kk hu bd kl km kn ko kp kq kr ks kt jc ku kv kw jg kx ky kz jk la lb lc ld dt translated">结论</h2><p id="3560" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">是时候让REST安息了，通过结合这些在很多情况下确实更合适的旧/新技术来制作API。所以出去玩玩<strong class="it hv"> RPC </strong>、<strong class="it hv"> GraphQL </strong>和<strong class="it hv"> JWT </strong>！</p></div></div>    
</body>
</html>