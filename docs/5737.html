<html>
<head>
<title>A Closer Look At How Python f-strings Work</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">仔细看看Python f字符串是如何工作的</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-closer-look-at-how-python-f-strings-work-f197736b3bdb?source=collection_archive---------3-----------------------#2017-08-14">https://medium.com/hackernoon/a-closer-look-at-how-python-f-strings-work-f197736b3bdb?source=collection_archive---------3-----------------------#2017-08-14</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/3e16b4e68e9aa10ed0ffe155481b260a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ww1GIXkTV2XdF_hYKyiWfA.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo By<a class="ae jg" href="https://www.pexels.com/photo/accessory-bobbin-close-up-clothing-355148/" rel="noopener ugc nofollow" target="_blank"> Fancycrave</a></figcaption></figure><p id="8237" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><a class="ae jg" href="https://www.python.org/dev/peps/pep-0498/" rel="noopener ugc nofollow" target="_blank"> PEP 498 </a>引入了一种新的字符串格式化机制，被称为<strong class="jj hv">文字字符串插值</strong>，或者更普遍地被称为<strong class="jj hv"> F字符串(因为在字符串文字前面有一个前导的F字符)</strong>。F-strings提供了一种简洁而方便的方法来将python表达式嵌入到字符串文字中进行格式化:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="baae" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以在f字符串中执行函数:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="3d76" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">f弦很快！比<strong class="jj hv"> %-formatting </strong>和<strong class="jj hv"> str.format() </strong>快得多——这是两种最常用的字符串格式化机制:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="1856" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为什么f弦这么快，它们实际上是如何工作的？<a class="ae jg" href="https://www.python.org/dev/peps/pep-0498/" rel="noopener ugc nofollow" target="_blank"> PEP 498 </a>提供了一个线索:</p><blockquote class="kl km kn"><p id="8073" class="jh ji ko jj b jk jl jm jn jo jp jq jr kp jt ju jv kq jx jy jz kr kb kc kd ke hn dt translated">string提供了一种在字符串中嵌入表达式的方法，使用了最少的语法。应该注意，f字符串实际上是一个在运行时计算的表达式，而不是一个常数值。在Python源代码中，f-string是一个文字字符串，以' f '为前缀，在大括号内包含表达式。表达式被替换为它们的值。</p></blockquote><p id="fcb4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里的关键点是，<strong class="jj hv">f字符串实际上是一个在运行时计算的表达式，而不是一个常量值</strong> <em class="ko">。</em>这实质上意味着f字符串中的表达式就像它们出现的范围内的任何其他python表达式一样被求值。CPython编译器在解析阶段完成繁重的工作，将f-string分成字符串文字和表达式，以生成适当的<a class="ae jg" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="noopener ugc nofollow" target="_blank"> <strong class="jj hv">抽象语法树</strong> </a> (AST):</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="6d6a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们使用<a class="ae jg" href="https://docs.python.org/3/library/ast.html" rel="noopener ugc nofollow" target="_blank"> ast </a>模块来查看与f字符串内外的简单表达式<code class="eh ks kt ku kv b">a + b</code>相关联的抽象语法树。我们可以看到f字符串<code class="eh ks kt ku kv b">f{a + b}</code>中的表达式<code class="eh ks kt ku kv b">a + b</code>被解析成一个普通的二元运算，就像它在f字符串之外一样。</p><p id="988c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们甚至可以看到，在字节码级别，f-string表达式就像任何其他python表达式一样被求值:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="18b7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv"> add_two </strong>函数简单地将本地变量<strong class="jj hv"> a </strong>和<strong class="jj hv"> b </strong>相加并返回结果。函数<strong class="jj hv"> add_two_fstring </strong>做同样的事情，但是加法发生在f字符串内。除了<strong class="jj hv"> add_two_fstring函数</strong>的反汇编字节码中的<strong class="jj hv"> FORMAT_VALUE </strong>指令之外(该指令的存在是因为f-string毕竟需要对包含的表达式的结果进行字符串化)，在f-string内部和外部计算<code class="eh ks kt ku kv b">a + b</code>的字节码指令是相同的。</p><p id="a450" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">处理f字符串可以简单地分解为计算花括号内的表达式(就像任何其他python表达式一样),然后将它与f字符串的字符串文字部分结合起来，以返回最终字符串的值。不需要额外的运行时处理。这使得f弦非常快速有效。</p><p id="8748" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为什么<strong class="jj hv"> str.format() </strong>比f字符串慢很多？一旦我们使用str.format()查看函数的反汇编字节代码，答案就变得很清楚了:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="a7b5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">从被拆解的字节码中，立刻跳出两条字节码指令:<strong class="jj hv"> LOAD_ATTR </strong>和<strong class="jj hv"> CALL_FUNCTION </strong>。当我们使用<strong class="jj hv"> str.format() </strong>时，需要在全局范围内查找<strong class="jj hv">格式</strong>函数<strong class="jj hv"> </strong>第一个<strong class="jj hv"> </strong>。这是通过<strong class="jj hv"> LOAD_ATTR </strong>字节码指令完成的。全局变量查找并不是一个真正廉价的操作，它包括许多步骤(如果你好奇，可以看看我之前的一篇关于属性查找如何工作的文章<a class="ae jg" rel="noopener" href="/stepping-through-the-cpython-interpreter/how-does-attribute-access-work-d19371898fee">。一旦定位到<strong class="jj hv">格式</strong>函数，调用二进制加法运算(<strong class="jj hv"> BINARY_ADD) </strong>对变量<strong class="jj hv"> a </strong>和<strong class="jj hv"> b. </strong>求和，最后<strong class="jj hv"> </strong>通过<strong class="jj hv"> CALL_FUNCTION </strong>字节码指令执行<strong class="jj hv">格式</strong>函数，返回字符串化的结果。python中的函数调用并不便宜，而且开销相当大。当使用<strong class="jj hv"> str.format()，</strong>花费在<strong class="jj hv"> LOAD_ATTR </strong>和<strong class="jj hv"> CALL_FUNCTION </strong>上的额外时间是str.format()比f-strings慢很多的原因。</a></p><p id="affc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">那么<strong class="jj hv"> %-string </strong>格式呢？我们看到这比str.format()快，但仍然比f-strings慢。同样，让我们看看使用%字符串格式的函数的反汇编字节代码:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="c4de" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">马上，我们看不到<strong class="jj hv"> LOAD_ATTR </strong>和<strong class="jj hv"> CALL_FUNCTION </strong>字节码指令——所以% string格式避免了全局属性查找和python函数调用的开销。这解释了为什么它比str.format()快。但是为什么% string格式化还是比f-string慢？% string格式可能花费额外时间的一个潜在地方是在<strong class="jj hv"> BINARY_MODULO </strong>字节码指令<strong class="jj hv">中。</strong>我还没有对<strong class="jj hv"> BINARY_MODULO </strong>字节码指令进行过全面的剖析，但是看一下CPython源代码，我们可以理解为什么调用<strong class="jj hv"> BINARY_MODULO: </strong>会有一点点开销</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="299f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">从上面的python C源代码片段中，我们看到<strong class="jj hv"> BINARY_MODULO </strong>操作被重载。每次被调用时，它都需要检查其操作数的类型(上面代码片段中的第7 -13行)，以确定操作数是否是字符串对象。如果是，则模运算符执行字符串格式化操作。否则，它计算通常的模(返回第一个参数除以第二个参数所得的余数)。虽然很小，但这种类型检查确实带来了f字符串可以避免的开销。</p><p id="c7f8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">希望这篇文章有助于解释为什么f-strings在字符串格式化方面鹤立鸡群。f-string速度快，使用简单，实用，代码更简洁。使用它们！</p></div></div>    
</body>
</html>