<html>
<head>
<title>Is server side rendering a good choice for React application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">服务器端渲染是React应用的好选择吗</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/is-server-side-rendering-a-good-choice-for-react-application-f6975755f555?source=collection_archive---------7-----------------------#2017-10-28">https://medium.com/hackernoon/is-server-side-rendering-a-good-choice-for-react-application-f6975755f555?source=collection_archive---------7-----------------------#2017-10-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/0a7d6d55d0ae7b17b7bd1c0429810f89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sjR8Y14yzo1LIdaqE1PVTA.png"/></div></div></figure><p id="d31c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">像<a class="ae ka" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank"> react </a>这样的单页面应用提供了极好的用户体验，然而，它也带来了两个问题:</p><ol class=""><li id="5c60" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">对于第一次访问网站的用户来说，浏览器中没有<a class="ae ka" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> javascript </a>的缓存，如果react应用庞大，下载javascript并执行可能需要很长时间。那么第一次渲染的时间就很长。</li><li id="e442" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">html是通过运行react应用的javascript在浏览器中生成的，那么SEO就成问题了。</li></ol><p id="d5ee" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">服务器端渲染(SSR)的出现解决了上述问题。在服务器上运行react应用程序并将渲染后的html返回给客户端听起来很棒，然后当客户端在后台运行react应用程序时，客户端可以直接渲染html，但不会重新渲染，因为生成的DOM树是相同的。然后搜索引擎会看到网页的html。在过去的一年里，我写了<a class="ae ka" href="https://www.npmjs.com/nashorn-polyfill" rel="noopener ugc nofollow" target="_blank"> nashorn-polyfill </a>在JVM中运行SSR。但这也带来了一些问题:</p><ol class=""><li id="978f" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">在服务器端渲染react应用程序甚至需要更长的时间。通常它通过两个过程进行渲染:第一个过程是运行所有需要的API来收集数据(例如<code class="eh kp kq kr ks b">react-apollo</code>中的<code class="eh kp kq kr ks b">getDataFromTree</code>，第二个过程是生成html的渲染。对于复杂的应用程序，生成html可能需要1秒以上的时间，并发性能可能是5页/秒。(存在等待API返回数据的空闲时间，该时间用于呈现其他请求)。这意味着它需要大量的服务器来满足高流量的请求。</li><li id="77d7" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">每次页面访问都会触发服务器端渲染，即使浏览器缓存了react应用程序的javascript。当没有缓存时，它可能会减少首次渲染的时间，但如果有缓存，实际上会增加首次渲染的时间。假设页面有两个API调用<code class="eh kp kq kr ks b">A</code>和<code class="eh kp kq kr ks b">B</code>，但是它们应该顺序运行。当它在服务器上运行时，服务器不会渲染生成html的第二遍，直到它们都被解析，但当它在浏览器中运行时，它运行<code class="eh kp kq kr ks b">A</code>并在<code class="eh kp kq kr ks b">A</code>解析时渲染任何可以渲染的内容，然后运行<code class="eh kp kq kr ks b">B</code>并在<code class="eh kp kq kr ks b">B</code>解析时再次渲染。由于这一根本差异，首次渲染可能总是需要更长的时间。</li></ol><p id="eb4d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果SEO对你的应用不是那么重要，那么做SSR的最大需求就没有了。如果很重要，最好只对搜索引擎做SSR，而不是对人类。它可以通过基于用户代理的web代理重定向请求(我没有这样做过，理想情况下应该可以)。</p><p id="f952" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">(<strong class="je hv">更新</strong>:对于已认证的内容，没有必要做SSR，因为搜索引擎无法抓取。那么SSR只适用于未认证/公开的内容，这意味着每个人看到的都一样，除了那些基于匿名cookie的内容。可以在SSR服务器前面建立一个<code class="eh kp kq kr ks b">squid</code>服务器，以便缓存和提供每个唯一url的输出，并且可以显著减少SSR服务器上的负载。)</p><p id="5e5a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当只在浏览器中渲染时，有一些方法可以提高首次渲染的性能和时间。</p><p id="fd3e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在复杂的应用程序中，一个页面可能需要生成10多个API请求。这不仅增加了服务器处理请求的负担，而且对客户端也有不利影响，即每个解析的API调用都将触发重新呈现，并且大的网络延迟对性能的影响更大。</p><p id="0b9a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我的例子中，我使用GraphQL而不是RESTful API，并且我使用了<code class="eh kp kq kr ks b">apollo-client</code>，它有一个很好的特性，可以在一个请求中批处理多个GraphQL调用。</p><figure class="ku kv kw kx fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kt"><img src="../Images/8e54052f6607fe35883a44f80aebac96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BJJcHqKJdPz5UaH438PloA.png"/></div></div></figure><p id="d2a1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可能注意到<code class="eh kp kq kr ks b">X-Run-Time-ms</code>对于10个GraphQL查询只有<code class="eh kp kq kr ks b">40</code>毫秒(这是本地开发环境)。通常，后端服务器需要对每个请求进行身份验证。有10个请求意味着后端服务器需要经历10次认证，而在一个请求中批量处理它们只需要一次。</p><p id="12b1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于React应用中需要认证的页面，通常是先调用API获取用户信息，然后根据用户信息显示菜单和内容。这导致了顺序API调用模式:第一个API调用用于用户信息，第二个用于其他内容。</p><p id="4912" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们如何避免这种连续的API调用来获取用户信息？考虑一种类型的服务器端呈现，<code class="eh kp kq kr ks b">rehydrate</code>SSR返回存储的状态，客户端使用它作为初始状态来合并客户端存储(在这种情况下为<code class="eh kp kq kr ks b">redux</code>)。通常，获取用户信息的API调用不依赖于任何东西，应该是相同的。如果我们总是在服务器上运行获取用户信息API，而不是通过新的服务器端呈现方式，会怎么样呢？这可以通过传统的服务器渲染来完成。我们可以在<code class="eh kp kq kr ks b">jsp</code>(Java中)中服务react应用程序的<code class="eh kp kq kr ks b">index.html</code>，调用API获取用户信息并作为<code class="eh kp kq kr ks b">window.__INITIAL_STATE__</code>返回。</p><p id="aa0a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">事实证明，我的react应用程序中的大多数页面只生成一个请求，这很好。</p><figure class="ku kv kw kx fq iv"><div class="bz el l di"><div class="ky kz l"/></div></figure></div></div>    
</body>
</html>