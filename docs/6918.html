<html>
<head>
<title>Solving the problems of Higher Order Components without throwing the baby out with the bathwater</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解决高阶组件的问题，而不用把婴儿和洗澡水一起倒掉</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/solving-the-problems-of-higher-order-components-without-throwing-the-baby-out-with-the-bathwater-40ddc72df5aa?source=collection_archive---------5-----------------------#2017-10-10">https://medium.com/hackernoon/solving-the-problems-of-higher-order-components-without-throwing-the-baby-out-with-the-bathwater-40ddc72df5aa?source=collection_archive---------5-----------------------#2017-10-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/ac7aa85cf0b34973d1493cc0bbb56390.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CvqcHB4DZKbdV51g0z-u_A.png"/></div></div></figure><p id="9ecc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在最近的文章中有一些对高阶组件的批评——特别是“间接”和“命名冲突”,它们实际上不是特设模式固有的问题，而是可以容易避免的使用错误。</p><h2 id="9c53" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">显式定义属性名</h2><p id="87c2" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">这是重新组合的</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="94f8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">关于道具<code class="eh la lb lc ld b">counter</code>和<code class="eh la lb lc ld b">setCounter</code>的来源没有混淆，而且既然你能控制道具的命名，碰撞也不是问题。</p><p id="8506" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们将同样的原理应用于迈克尔杰克逊的<a class="ae lk" href="https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce" rel="noopener ugc nofollow" target="_blank">使用渲染道具</a>中的<code class="eh la lb lc ld b">withMouse</code>示例！</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="3f3a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为你声明了你将要收到的道具的名称，所以不存在间接或冲突的问题。</p><h2 id="3e4a" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">如果你的HoC需要返回多个道具怎么办？</h2><p id="b0e6" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">想象一下，<code class="eh la lb lc ld b">withMouse</code> HoC返回了两个props - <code class="eh la lb lc ld b">position</code>，它包含了<code class="eh la lb lc ld b">x</code>和<code class="eh la lb lc ld b">y</code>坐标，以及<code class="eh la lb lc ld b">changeCounter</code>，它记录了位置改变的次数。</p><p id="4ce5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要求显式命名每一个属性会使HoC与它提供的每一个附加属性一起使用时更加麻烦。但是如果不明确命名这些道具，您可能会得到如下结果:</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="c8b5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你只能猜测<code class="eh la lb lc ld b">position</code>和<code class="eh la lb lc ld b">changeCounter</code>道具来自<code class="eh la lb lc ld b">withMouse</code>而不是其他的hoc，并且你必须假设没有其他的hoc返回相同名称的道具。</p><h2 id="d738" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">命名空间高阶组件</h2><p id="8f00" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">这种模糊性/间接性和潜在的冲突可以通过命名空间来解决:</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="b4f4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以更进一步，命名所有的HoC(这适用于任何返回props的HoC)</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="1032" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Props现在可以通过名称空间追溯到提供它们的HoC，由于名称空间是在HoC被组合时设置的，所以冲突也可以避免。</p><p id="8d25" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh la lb lc ld b">namespace</code>函数的代码实际上非常简单</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="li lj l"/></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Credits to <a class="ae lk" href="https://twitter.com/jephuff" rel="noopener ugc nofollow" target="_blank">Jeffrey Burt</a> for the <a class="ae lk" href="https://github.com/acdlite/recompose/issues/358#issue-221319488" rel="noopener ugc nofollow" target="_blank">initial code solution</a> and <a class="ae lk" href="https://twitter.com/icelabaratory" rel="noopener ugc nofollow" target="_blank">Ivan Starkov</a> for <a class="ae lk" href="https://github.com/acdlite/recompose/issues/358#issuecomment-293637999" rel="noopener ugc nofollow" target="_blank">making it more readable</a></figcaption></figure><p id="083d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里有一个沙盒，里面有所有的东西</p><h2 id="5269" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">渲染道具做得更好</h2><p id="ae52" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">渲染道具确实有好处，因为你可以把它分散到渲染函数中。M <em class="lp"> y </em>朋友<a class="ae lk" rel="noopener" href="/@benevolentNinja">阿历克斯·威尔默</a>有一个很好的例子展示了它的效用，我希望它能很快变成博客的形式，但同时这里有一个更简单、更做作的例子——</p><p id="3aa1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设您在JSX的一个大型街区内，并且有一些硬编码的和重复的变量(在本例中为“东亚”)，您可能希望停止使用这些变量。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="271b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你有几个选择。</p><ol class=""><li id="5c02" class="lq lr hu je b jf jg jj jk jn ls jr lt jv lu jz lv lw lx ly dt translated">在函数的顶部向上声明变量(坚持“在靠近使用变量的地方声明变量”的人可能不喜欢这样)</li><li id="180e" class="lq lr hu je b jf lz jj ma jn mb jr mc jv md jz lv lw lx ly dt translated">创建一个单独的组件并传递重复的值(这有点麻烦)</li><li id="b042" class="lq lr hu je b jf lz jj ma jn mb jr mc jv md jz lv lw lx ly dt translated">创建一个名为<code class="eh la lb lc ld b">&lt;Assign/&gt;</code>的组件，我们可以通过props为其赋值，然后在render函数中接收这些值。</li></ol><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="8358" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们进一步说，这些值来自异步请求。您可以制作一个<code class="eh la lb lc ld b">&lt;Resolve /&gt;</code>组件来完成这项工作…</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="li lj l"/></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Find the implementation of the `&lt;Resolve/&gt;` component at <a class="ae lk" href="https://codesandbox.io/s/w8vp4k2pw" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/w8vp4k2pw</a></figcaption></figure><p id="116a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我不确定使用这些组件是否是一个好主意(咨询你最近的思想领袖😄)，但它展示了渲染道具允许某种灵活性的地方，而据我所知，HoC是不允许的。</p><h2 id="5756" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">摘要</h2><p id="b73c" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">我们似乎经历了</p><ol class=""><li id="c68f" class="lq lr hu je b jf jg jj jk jn ls jr lt jv lu jz lv lw lx ly dt translated">“哈，我不知道你能做到这一点”</li><li id="d257" class="lq lr hu je b jf lz jj ma jn mb jr mc jv md jz lv lw lx ly dt translated">“这似乎是一个很好的解决方案”<em class="lp">(对于某些使用案例)</em></li><li id="ae7c" class="lq lr hu je b jf lz jj ma jn mb jr mc jv md jz lv lw lx ly dt translated">“这就是客观上的优解！”</li><li id="2770" class="lq lr hu je b jf lz jj ma jn mb jr mc jv md jz lv lw lx ly dt translated">“存在权衡和陷阱。这是该解决方案更有意义的地方，这是您需要小心的地方，这是最好使用其他方法的地方。”</li></ol><p id="a8cc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我认为我们正处于高阶元件的第4阶段，有可能陷入的<a class="ae lk" href="https://reactjs.org/docs/higher-order-components.html#caveats" rel="noopener ugc nofollow" target="_blank">陷阱，但也有解决方案</a>。有了渲染道具，我目前看到的文章好像还停留在阶段2和阶段3之间。</p><p id="e9b4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一切都是交易。我怀疑一个被描述为全是好处而没有成本的解决方案——这通常意味着成本还没有被发现😄</p><p id="7330" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">欢迎在评论中告诉我我错过了什么，<a class="ae lk" href="https://www.reddit.com/r/javascript/comments/75hkrk/solving_the_problems_of_higher_order_components/" rel="noopener ugc nofollow" target="_blank">在reddit上讨论</a>，或者发微博给我<a class="ae lk" href="https://twitter.com/cheapsteak" rel="noopener ugc nofollow" target="_blank"> @CheapSteak </a></p></div><div class="ab cl me mf hc mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hn ho hp hq hr"><p id="9395" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">本文由<a class="ae lk" href="https://npmcharts.com/" rel="noopener ugc nofollow" target="_blank"><strong class="je hv">npmcharts.com</strong></a><strong class="je hv">赞助📈</strong></p><p id="2f8d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是一张<a class="ae lk" href="https://www.npmjs.com/package/recompose" rel="noopener ugc nofollow" target="_blank">重组</a>的互动下载图</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="ml lj l"/></div></figure></div></div>    
</body>
</html>