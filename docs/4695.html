<html>
<head>
<title>Detect DOM Element Additions Matching a Selector</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">检测与选择器匹配的DOM元素添加</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/promise-based-detection-of-element-injection-94bc12e33966?source=collection_archive---------4-----------------------#2017-06-15">https://medium.com/hackernoon/promise-based-detection-of-element-injection-94bc12e33966?source=collection_archive---------4-----------------------#2017-06-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="e535" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">停止轮询动态插入元素的DOM</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/110d0d210e0f8c7cf21b4c6090b0f19b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WctrCG6yWWpjJP2d_pVq8A.jpeg"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><a class="ae jz" href="http://www.burtchworks.com/2014/12/08/8-biggest-job-search-mistakes-quants-still-making/" rel="noopener ugc nofollow" target="_blank">Photo credit</a></figcaption></figure><p id="3af0" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">在很多情况下，您的页面可能需要等待DOM中特定操作的发生。通常，人们可能只依赖于<code class="eh kw kx ky kz b">document</code> ready或<code class="eh kw kx ky kz b">window</code> load事件来执行一些静态初始化，或者如果Ajax调用需要首先完成，显然您会在收到成功的响应后进行初始化。</p><p id="5022" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">当您的初始化依赖于一个未知事件时，事情可能会变得很糟糕，这个未知事件在您的控制之外，但是负责将内容插入DOM。例如，您可能有一个需要加载和执行的第三方<code class="eh kw kx ky kz b">&lt;script&gt;</code>，或者您可能需要根据某种用户交互对修改DOM的供应商插件代码做出反应。</p><h2 id="23b0" class="la lb hu bd lc ld le lf lg lh li lj lk kj ll lm ln kn lo lp lq kr lr ls lt lu dt translated">古代史</h2><p id="3454" class="pw-post-body-paragraph ka kb hu kc b kd lv iv kf kg lw iy ki kj lx kl km kn ly kp kq kr lz kt ku kv hn dt translated">过去，开发人员总是不情愿地使用两种常用方法来处理这种情况:</p><ol class=""><li id="5662" class="ma mb hu kc b kd ke kg kh kj mc kn md kr me kv mf mg mh mi dt translated">这是一个足够简单的解决方案，对吗？只需调用<code class="eh kw kx ky kz b">setInterval()</code>并每隔几毫秒检查一下DOM，看看是否添加了元素。</li><li id="1fa1" class="ma mb hu kc b kd mj kg mk kj ml kn mm kr mn kv mf mg mh mi dt translated"><strong class="kc hv">设置长超时</strong> <br/>“我知道，我会猜测<code class="eh kw kx ky kz b">&lt;script&gt;</code>加载的最长时间，然后我会<code class="eh kw kx ky kz b">setTimeout()</code>甚至<em class="mo">更长的时间</em>，这样我们就没事了！”</li></ol><p id="81a6" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">轮询解决方案通常采用以下形式，带有间隔或自动执行超时:</p><pre class="jk jl jm jn fq mp kz mq mr aw ms dt"><span id="e0ff" class="la lb hu kz b fv mt mu l mv mw">const myDynamicElementHandler = () =&gt; {<br/>  /* ...do something... */<br/>}</span><span id="deb6" class="la lb hu kz b fv mx mu l mv mw">// Poll the DOM every 100ms<br/>const uglyDomCheckerInterval = setInterval(() =&gt; {<br/>  if ($('#some-dynamic-element-id').length === 0) return</span><span id="4132" class="la lb hu kz b fv mx mu l mv mw">  clearInterval(uglyDomCheckerInterval)</span><span id="a8b5" class="la lb hu kz b fv mx mu l mv mw">  // Yay, our element now exists! ... do something with it<br/>  myDynamicElementHandler()<br/>}, 100)</span></pre><p id="8d92" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">超时“解决方案”与此类似，但更加草率……应该会让你感到惭愧:</p><pre class="jk jl jm jn fq mp kz mq mr aw ms dt"><span id="6b3d" class="la lb hu kz b fv mt mu l mv mw">// "I guess my element should exist after 10 seconds, so<br/>// I'll just set a timeout... Problem solved!"</span><span id="0b29" class="la lb hu kz b fv mx mu l mv mw">setTimeout(myDynamicElementHandler, 10000)</span></pre><p id="574d" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">如果这些解决方案没有让你内心感到一丝不快，那你就错了。</p><p id="0f70" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">理想情况下，如果你正在处理第三方内容(无论是一个<code class="eh kw kx ky kz b">&lt;script&gt;</code>还是一个插件，等等)。)您希望他们的代码执行一个您可以定义的回调，或者触发一个您可以挂接的事件；你可能只是想让代码以某种方式响应DOM中的特定变化。如果没有提供这样的选项，当我们<em class="mo">知道</em>相关内容确实存在于DOM中时，我们至少希望有一些其他的方法来执行我们的处理程序一次。</p><p id="863a" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">多亏了现代浏览器，我们肮脏的DOM轮询时代已经结束，我们基于承诺的DOM通知时代才刚刚开始。</p><h2 id="74ed" class="la lb hu bd lc ld le lf lg lh li lj lk kj ll lm ln kn lo lp lq kr lr ls lt lu dt translated">突变观察者</h2><p id="b557" class="pw-post-body-paragraph ka kb hu kc b kd lv iv kf kg lw iy ki kj lx kl km kn ly kp kq kr lz kt ku kv hn dt translated">曾经存在一系列DOM突变事件，这是一个伟大的想法，但执行不力，因为它们带来了性能问题和浏览器支持和实现的不一致性…然后又出现了MutationObserver。</p><p id="3d6b" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><code class="eh kw kx ky kz b"><a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver" rel="noopener ugc nofollow" target="_blank">MutationObserver</a></code>允许您定义一个回调，当您感兴趣的特定类型的DOM突变发生时，将执行该回调。它有很多内容，所以我建议仔细阅读它，以防它对你有通用用途。值得注意的一点是，它在所有现代浏览器中都得到支持，甚至包括IE11。</p><p id="0ac2" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">就我的意图和目的而言，MutationObserver是一个很好的产品，帮助我很好地完成了我的目标。</p><h2 id="c953" class="la lb hu bd lc ld le lf lg lh li lj lk kj ll lm ln kn lo lp lq kr lr ls lt lu dt translated">awaitSelector()</h2><pre class="jk jl jm jn fq mp kz mq mr aw ms dt"><span id="00ec" class="la lb hu kz b fv mt mu l mv mw">const awaitSelector = (selector, rootNode, fallbackDelay) =&gt; new Promise((resolve, reject) =&gt; {<br/>  try {<br/>    const root = rootNode || document<br/>    const ObserverClass = MutationObserver || WebKitMutationObserver || null<br/>    const mutationObserverSupported = typeof ObserverClass === 'function'</span><span id="3dbe" class="la lb hu kz b fv mx mu l mv mw">let observer</span><span id="75b6" class="la lb hu kz b fv mx mu l mv mw">const stopWatching = () =&gt; {<br/>      if (observer) {<br/>        if (mutationObserverSupported) {<br/>          observer.disconnect()<br/>        } else {<br/>          clearInterval(observer)<br/>        }</span><span id="5df0" class="la lb hu kz b fv mx mu l mv mw">observer = null<br/>      }<br/>    }</span><span id="4aba" class="la lb hu kz b fv mx mu l mv mw">const findAndResolveElements = () =&gt; {<br/>      const allElements = root.querySelectorAll(selector)</span><span id="835b" class="la lb hu kz b fv mx mu l mv mw">if (allElements.length === 0) return</span><span id="7643" class="la lb hu kz b fv mx mu l mv mw">const newElements = []</span><span id="fbed" class="la lb hu kz b fv mx mu l mv mw">const attributeForBypassing = 'data-awaitselector-resolved'</span><span id="017f" class="la lb hu kz b fv mx mu l mv mw">allElements.forEach((el, i) =&gt; {<br/>        if (typeof el[attributeForBypassing] === 'undefined') {<br/>          allElements[i][attributeForBypassing] = ''<br/>          newElements.push(allElements[i])<br/>        }<br/>      })</span><span id="f92a" class="la lb hu kz b fv mx mu l mv mw">if (newElements.length &gt; 0) {<br/>        stopWatching()<br/>        resolve(newElements)<br/>      }<br/>    }</span><span id="6eac" class="la lb hu kz b fv mx mu l mv mw">if (mutationObserverSupported) {<br/>      observer = new ObserverClass(mutationRecords =&gt; {<br/>        const nodesWereAdded = mutationRecords.reduce(<br/>          (found, record) =&gt; found || (record.addedNodes &amp;&amp; record.addedNodes.length &gt; 0),<br/>          false<br/>        )</span><span id="88f6" class="la lb hu kz b fv mx mu l mv mw">if (nodesWereAdded) {<br/>          findAndResolveElements()<br/>        }<br/>      })</span><span id="21c4" class="la lb hu kz b fv mx mu l mv mw">observer.observe(root, {<br/>        childList: true,<br/>        subtree: true,<br/>      })<br/>    } else {<br/>      observer = setInterval(findAndResolveElements, fallbackDelay || 250)<br/>    }</span><span id="0ee5" class="la lb hu kz b fv mx mu l mv mw">findAndResolveElements()<br/>  } catch (exception) {<br/>    reject(exception)<br/>  }<br/>})</span><span id="8242" class="la lb hu kz b fv mx mu l mv mw">const watchAwaitSelector = (callback, selector, rootNode, fallbackDelay) =&gt; {<br/>  (function awaiter(continueWatching = true) {<br/>    if (continueWatching === false) return</span><span id="feb1" class="la lb hu kz b fv mx mu l mv mw">awaitSelector(selector, rootNode, fallbackDelay)<br/>      .then(callback)<br/>      .then(awaiter)<br/>  }())<br/>}</span></pre><p id="96a3" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">我使用了MutationObserver作为这个相当简单的<code class="eh kw kx ky kz b">awaitSelector()</code>函数的基础，它允许您指定一个元素选择器，并返回一个承诺，该承诺将与插入到与您的选择器匹配的DOM中的<em class="mo">新的</em>元素一起解析。如果您的元素在调用<code class="eh kw kx ky kz b">awaitSelector()</code>时已经存在，那么Promise将立即解析这些元素，否则，它将监听DOM中的元素插入，并解析是否有与您的选择器匹配的<em class="mo">新的</em>元素出现。下面是该功能的一个简单示例:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="my mz l"/></div></figure><p id="8d4d" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><code class="eh kw kx ky kz b">awaitSelector()</code>接受以下三个参数:</p><ul class=""><li id="da34" class="ma mb hu kc b kd ke kg kh kj mc kn md kr me kv na mg mh mi dt translated"><code class="eh kw kx ky kz b">selector </code> —与元素匹配的CSS选择器字符串</li><li id="c606" class="ma mb hu kc b kd mj kg mk kj ml kn mm kr mn kv na mg mh mi dt translated">[ <code class="eh kw kx ky kz b">rootNode</code> ] —要在其中搜索元素的元素；<em class="mo">默认:</em> <code class="eh kw kx ky kz b">document</code></li><li id="647a" class="ma mb hu kc b kd mj kg mk kj ml kn mm kr mn kv na mg mh mi dt translated">[<code class="eh kw kx ky kz b">fallbackDelay</code>]—如果不支持MutationObserver，则使用超时延迟；<em class="mo">默认值:</em>250毫秒</li></ul><p id="b64a" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">为了彻底起见，我们不希望假设MutationObserver总是可用的，也不希望让需要支持旧浏览器的开发人员无法使用<code class="eh kw kx ky kz b">awaitSelector()</code>，因此内置了一个后备方案，使用前面提到的旧轮询方法来继续检查DOM中的<em class="mo">新</em>匹配元素。</p><p id="c0e9" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">这里一个棘手的事情是，如果发现了与我们的选择器匹配的<strong class="kc hv">新的</strong>元素，我们只希望我们的承诺得到解决；我们希望函数是显式非幂等的。换句话说，如果我们用相同的参数第二次执行<code class="eh kw kx ky kz b">awaitSelector()</code>，我们不希望它立即解析出与第一次执行时相同的元素。相反，我们希望它在返回新的匹配DOM元素之前等待任何新的匹配DOM元素。</p><p id="b4c2" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">另一个考虑是如何处理<code class="eh kw kx ky kz b">awaitSelector()</code>的初始执行，以匹配DOM中已经存在的元素。它会像您可能期望的那样，立即解决任何这样的元素。</p><h2 id="a0ab" class="la lb hu bd lc ld le lf lg lh li lj lk kj ll lm ln kn lo lp lq kr lr ls lt lu dt translated">watchAwaitSelector()</h2><p id="fe69" class="pw-post-body-paragraph ka kb hu kc b kd lv iv kf kg lw iy ki kj lx kl km kn ly kp kq kr lz kt ku kv hn dt translated">一个常见的用例是，每当插入任何匹配的元素时，您都希望在页面上无限次地执行回调，因此为了帮助实现这一点，还有一个名为<code class="eh kw kx ky kz b">watchAwaitSelector()</code>的包装器函数。这个函数将回调作为它的第一个参数，其余的参数与<code class="eh kw kx ky kz b">awaitSelector()</code>匹配。它将侦听与您的选择器匹配的新元素，并使用这些元素执行您的回调，然后继续侦听更多元素。如果你需要停止收听，你的回叫可以<code class="eh kw kx ky kz b">return false</code>，它将停止观看。</p><h2 id="eabf" class="la lb hu bd lc ld le lf lg lh li lj lk kj ll lm ln kn lo lp lq kr lr ls lt lu dt translated">结论</h2><p id="9a53" class="pw-post-body-paragraph ka kb hu kc b kd lv iv kf kg lw iy ki kj lx kl km kn ly kp kq kr lz kt ku kv hn dt translated">大多数开发人员仍然需要处理无穷无尽的遗留代码，但是随着现代标准和更广泛、更可靠的浏览器支持，越来越多的优秀解决方案成为了潜在的解决方案，而以前只有黑客和肮脏的变通方法。在还没有更好的解决方案的情况下，轮询可能仍然有它的位置，但是至少在等待DOM元素插入时，您可以很容易地创建一个有用的承诺，使您的手不会太脏。</p><p id="dd26" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">为了完全透明，应该注意的是，当一个元素被插入到指定的DOM子树中时，MutationObserver仍然会导致<code class="eh kw kx ky kz b">awaitSelector()</code>的内部逻辑寻找所需的选择器，但这显然比任何基于轮询的方法都要好。</p><p id="a09f" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">注意:由于我的GitHub中上面链接的默认await-selector.js脚本是用ES6编写的，所以我也为任何想在非Babel环境中使用它的人提供了一个ES5版本(尽管它仍然使用Promise，所以如果有必要，您可能需要自己填充它)。</p><div class="jk jl jm jn fq ab cb"><figure class="nb jo nc nd ne nf ng paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nb jo nc nd ne nf ng paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nb jo nc nd ne nf ng paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="nh ni nj"><p id="f922" class="ka kb mo kc b kd ke iv kf kg kh iy ki nk kk kl km nl ko kp kq nm ks kt ku kv hn dt translated"><a class="ae jz" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客们下午的开始。我们是<a class="ae jz" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jz" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jz" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ka kb mo kc b kd ke iv kf kg kh iy ki nk kk kl km nl ko kp kq nm ks kt ku kv hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jz" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jz" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nn"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>