<html>
<head>
<title>Using RxJS to handle HTTP requests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用RxJS处理HTTP请求</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/using-rxjs-to-handle-http-requests-what-ive-learned-4640aaf4646c?source=collection_archive---------0-----------------------#2016-11-25">https://medium.com/hackernoon/using-rxjs-to-handle-http-requests-what-ive-learned-4640aaf4646c?source=collection_archive---------0-----------------------#2016-11-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="71af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我第一次开始学习RxJS时，我可以本能地看到，可观察流为解决我在前端web应用程序开发中每天遇到的许多问题提供了各种可能性。我已经使用flux架构有一段时间了，它给我的web应用带来的组织结构的清晰性和关注点的分离令我惊叹不已。我读到过RxJS也能做到这一点，并且很想知道是如何做到的。对HTTP请求的优雅处理似乎是这个学习旅程的明显起点。</p><p id="aee4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，我很快就感到沮丧，因为我在一个地方所能找到的关于这个主题(特别是错误处理)的良好实践的信息是如此之少，并且不得不通过四处阅读、大量浏览Stackoverflow和Github问题线程以及个人实验来找出大多数东西。这篇文章是我迄今为止所学内容的目录。</p><p id="816e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我将解释一些简便的方法来完成以下任务:</p><ul class=""><li id="cee9" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx dt translated">从HTTP请求创建可观察的流</li><li id="72c2" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">处理HTTP错误响应</li><li id="7e8c" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">无序HTTP请求完成的优雅处理</li><li id="fea8" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">限制用户输入</li><li id="c04c" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">一些额外的额外提示和技巧</li></ul><p id="a439" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我将假设一些创建和订阅observables的绝对基础知识，因为这很容易在网上找到<a class="ae kd" href="https://www.sitepoint.com/functional-reactive-programming-rxjs/" rel="noopener ugc nofollow" target="_blank">，并且是我开始试验RxJS和HTTP请求的地方。</a></p><h1 id="30fb" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">示例应用程序</h1><p id="332b" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">为了演示所有这些技术，我们将创建一个使用g <a class="ae kd" href="https://api.github.com/users/jamesflight" rel="noopener ugc nofollow" target="_blank"> ithub用户api </a>的迷你应用程序示例。它将使用户能够在一个框中键入github用户名，如果有效，将在下面显示他们的头像。我将使用该应用程序的许多变体来演示使用RxJS的不同方式。为了保持简单，该应用程序只使用RxJS，bootstrap和一点点jQuery来粘合页面。</p><p id="b0e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意:github用户api，在未经授权的情况下，每小时有60个请求的可怜的速率限制。因此，如果你对这些例子过于乐观，它们可能会停止工作一段时间。</p><h2 id="f25b" class="lh kf hu bd kg li lj lk kk ll lm ln ko jc lo lp ks jg lq lr kw jk ls lt la lu dt translated">设置</h2><p id="bfbc" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">首先，让我们创建一个文本输入，并从它的“keyup”事件创建一个可观察对象。</p><figure class="lv lw lx ly fq lz"><div class="bz el l di"><div class="ma mb l"/></div><figcaption class="mc md fg fe ff me mf bd b be z ek">Example 1: Input Box</figcaption></figure><figure class="lv lw lx ly fq lz"><div class="bz el l di"><div class="mg mb l"/></div></figure><p id="1b6c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在框中键入并点击搜索按钮，以查看包含文本输入值的警告。注意在可观察到的<code class="eh mh mi mj mk b">fromEvent</code>之后链接的额外的<code class="eh mh mi mj mk b">map</code>。这使我们能够将搜索输入框的当前输入值映射到我们的<code class="eh mh mi mj mk b">userClicksSearchButton</code>可观察对象，替换通常会发出的默认事件对象。</p><h1 id="f181" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">处理HTTP请求</h1><p id="181f" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">好了，我们现在有了一个可观察对象，当用户点击搜索按钮时，它将发出用户输入。为了启动我们的HTTP请求，我们将创建一个可观察的流，我们可以使用我们的<code class="eh mh mi mj mk b">userClicksSearchButton</code>作为源进行订阅:</p><figure class="lv lw lx ly fq lz"><div class="bz el l di"><div class="ma mb l"/></div><figcaption class="mc md fg fe ff me mf bd b be z ek">Example 2: Button Search</figcaption></figure><figure class="lv lw lx ly fq lz"><div class="bz el l di"><div class="mg mb l"/></div></figure><p id="b35f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">试着在框中输入你的github用户名，点击搜索，你应该会看到你的头像出现在下面。要知道，目前，如果你搜索一个无效的用户名，它将打破应用程序。现在不要担心这个；我们一会儿会解决这个问题。</p><p id="75b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们在第一个可观察对象之后链接了<code class="eh mh mi mj mk b">flatMap</code>,订阅了结果可观察对象，并将一些接收到的数据写入DOM。</p><p id="7a73" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们已经使用标准的jQuery get执行了请求，我们已经将它封装在RxJS的有用的<code class="eh mh mi mj mk b">fromPromise</code>中，以将其转化为可观察的。</p><h2 id="f9b2" class="lh kf hu bd kg li lj lk kk ll lm ln ko jc lo lp ks jg lq lr kw jk ls lt la lu dt translated"><strong class="ak">平面地图</strong></h2><p id="df94" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">看看例子中“平面图”的用法。我必须承认，当我第一次看到这类事情的一些例子时，我感到非常困惑。乍一看，我们应该能够像对点击事件那样调用<code class="eh mh mi mj mk b">map</code>，毕竟，我们已经通过调用<code class="eh mh mi mj mk b">fromPromise</code>将承诺转化为可观察的结果，对吗？</p><p id="5130" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">实际上，<code class="eh mh mi mj mk b">fromPromise</code>返回的是一个可观察到的承诺流<em class="ml"/>，而不是承诺解析时发出的对象流。<code class="eh mh mi mj mk b">flatMap</code>允许我们将所有这些承诺的解析整合到一个可观察的流中，当我们订阅它时，我们得到的只是jQuery最初在<code class="eh mh mi mj mk b">then()</code>发出的响应对象。</p><h1 id="4382" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">处理错误</h1><p id="da00" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">之前我提到过，如果你搜索一个无效的用户名，这个应用程序就会崩溃(试着搜索一些胡言乱语，然后是完全有效的东西)。这显然很糟糕，最初，根本不清楚为什么会发生这种情况。为了理解为什么，让我们来看看承诺解决时事件发生的顺序:</p><ol class=""><li id="dfe6" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo mm jv jw jx dt translated">HTTP请求完成，jQuery拒绝了这个承诺(因为它是404)</li><li id="65dd" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo mm jv jw jx dt translated">由<code class="eh mh mi mj mk b">fromPromise</code>创建的可观察对象抛出一个错误，因为这是它对被拒绝的承诺的反应</li><li id="e342" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo mm jv jw jx dt translated">该错误未被捕获，因此在父<code class="eh mh mi mj mk b">flatMap</code> observable中再次抛出。</li><li id="2f46" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo mm jv jw jx dt translated"><code class="eh mh mi mj mk b">flatMap</code> observable将不再发出，因为在一个observable流抛出一个错误后，它被终止。</li></ol><p id="fbc2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这有一个意想不到的副作用，那就是每当我们得到一个错误响应时，我们的搜索按钮就变得毫无用处。这不太好，那么我们该如何处理这个问题呢？</p><p id="79bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这又是一个应用程序，但这次是错误处理:</p><figure class="lv lw lx ly fq lz"><div class="bz el l di"><div class="ma mb l"/></div><figcaption class="mc md fg fe ff me mf bd b be z ek">Example 3: Button Search With Error Handling</figcaption></figure><figure class="lv lw lx ly fq lz"><div class="bz el l di"><div class="mg mb l"/></div></figure><p id="6b3d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们在错误向上游传播之前捕捉并处理它，并用一个空的完整的错误替换可观察的错误，该错误将在其位置变平。为此我们使用了方便的<code class="eh mh mi mj mk b">Rx.Observable.empty()</code>。</p><h1 id="942c" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">处理无序请求</h1><p id="b865" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">让我们稍微改变一下这个例子。假设我们希望用户能够在输入框中输入内容，而不是点击按钮进行搜索，并在输入的同时进行搜索。为此，我们需要将<code class="eh mh mi mj mk b">userClicksSearchButton</code>可观测值替换为<code class="eh mh mi mj mk b">userTypesInSearchBox</code>可观测值，如下所示:</p><figure class="lv lw lx ly fq lz"><div class="bz el l di"><div class="ma mb l"/></div><figcaption class="mc md fg fe ff me mf bd b be z ek">Example 4: Text Search</figcaption></figure><figure class="lv lw lx ly fq lz"><div class="bz el l di"><div class="mg mb l"/></div></figure><p id="1e44" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们现在发现，因为我们的每个请求都被快速连续地触发，所以我们不能再保证它们会按照发起的顺序完成。这可能会导致我们的搜索结果不匹配的头像显示在下面。这并不好，所以为了解决这个问题，我们将使用<code class="eh mh mi mj mk b">concatMap</code>。</p><h2 id="0431" class="lh kf hu bd kg li lj lk kk ll lm ln ko jc lo lp ks jg lq lr kw jk ls lt la lu dt translated">串联图</h2><p id="e0de" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated"><code class="eh mh mi mj mk b">concatMap</code>和<code class="eh mh mi mj mk b">flatMap</code>很像，除了它会保持源发射的顺序，即使被它拉平的可观测物以不同的顺序发射。例如，如果我搜索“Elle”，然后立即搜索“Ellen”，而“Ellen”请求恰好首先完成，<code class="eh mh mi mj mk b">concatMap</code>将等待“Elle”请求完成，然后以“Elle”“Ellen”的顺序连续发出两个结果。</p><p id="fc50" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是代码，修改后使用了“concatMap”。</p><figure class="lv lw lx ly fq lz"><div class="bz el l di"><div class="ma mb l"/></div><figcaption class="mc md fg fe ff me mf bd b be z ek">Example 5: Text Search Preserving Request Order</figcaption></figure><figure class="lv lw lx ly fq lz"><div class="bz el l di"><div class="mg mb l"/></div></figure><p id="9b13" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">编辑:我刚刚得知我们也可以用<code class="eh mh mi mj mk b">switchMap</code>来做这件事。这提供了额外的好处，即在必要时取消底层的冗余http请求。</p><h1 id="ebb9" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">限制用户输入</h1><p id="1422" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">目前，我们的应用程序会在用户每次向文本框中输入一个字母时发出一个请求。考虑到用户直到在输入框中输入至少几个字母后才真正有兴趣看到结果，这看起来有点过了。当服务器对用户体验没有任何帮助时，为什么还要敲打它呢？使用RxJS，我们可以通过一个简单的额外函数调用“去反跳”来缓解这个问题。</p><figure class="lv lw lx ly fq lz"><div class="bz el l di"><div class="ma mb l"/></div><figcaption class="mc md fg fe ff me mf bd b be z ek">Example 6: Text Search Throttled</figcaption></figure><figure class="lv lw lx ly fq lz"><div class="bz el l di"><div class="mg mb l"/></div></figure><p id="f420" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本例中，值得一提的是，在控制台窗口的network选项卡中，当您在框中键入内容时，会发现发送的请求比前一个示例少得多。</p><h2 id="d59e" class="lh kf hu bd kg li lj lk kk ll lm ln ko jc lo lp ks jg lq lr kw jk ls lt la lu dt translated">去抖</h2><p id="4ccc" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">“去抖”接受一个数字参数，该参数代表可观测对象在上次发射后再次发射前应等待的毫秒数。在这段时间过去后，可观测物体将只发出这段时间内的最后一次辐射，而忽略其他任何辐射。我发现这对基于实时文本的搜索功能非常有帮助。</p><p id="4827" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意:如果您需要它发射相反的信号，即该时间段内的第一次发射，您可以使用<code class="eh mh mi mj mk b">throttle</code>方法。</p><h1 id="0d72" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated"><strong class="ak">额外提示和技巧</strong></h1><p id="914e" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">上述技术将处理大多数HTTP请求用例，但是您可以做一些其他很酷的事情来减轻异步请求处理带来的一些痛苦:</p><h2 id="c404" class="lh kf hu bd kg li lj lk kk ll lm ln ko jc lo lp ks jg lq lr kw jk ls lt la lu dt translated">拿</h2><p id="cb6b" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">有时候，你只对前1、2或n个用户交互感兴趣。对于这些情况，RxJS提供了“take”方法。在我们的搜索按钮示例中，假设我们只想显示第一个有效的结果:</p><figure class="lv lw lx ly fq lz"><div class="bz el l di"><div class="ma mb l"/></div><figcaption class="mc md fg fe ff me mf bd b be z ek">Example 7: Text Search With Take</figcaption></figure><figure class="lv lw lx ly fq lz"><div class="bz el l di"><div class="mg mb l"/></div></figure><p id="ea6e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，执行的第一个搜索将会起作用，但是随后在框中键入的任何内容都将被忽略。</p><h2 id="3fc2" class="lh kf hu bd kg li lj lk kk ll lm ln ko jc lo lp ks jg lq lr kw jk ls lt la lu dt translated">过滤器</h2><p id="7f36" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">有时，我们希望根据条件过滤掉某些可观察到的辐射。为了演示，让我们使用<code class="eh mh mi mj mk b">filter</code>让我们的文本搜索示例忽略搜索，直到它们至少有5个字符长:</p><figure class="lv lw lx ly fq lz"><div class="bz el l di"><div class="ma mb l"/></div><figcaption class="mc md fg fe ff me mf bd b be z ek">Example 8: Text Search Filtered</figcaption></figure><figure class="lv lw lx ly fq lz"><div class="bz el l di"><div class="mg mb l"/></div></figure><h2 id="6679" class="lh kf hu bd kg li lj lk kk ll lm ln ko jc lo lp ks jg lq lr kw jk ls lt la lu dt translated">合并</h2><p id="3656" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">有时，将多个可观测值合并成一个可观测值是很有用的。为了演示，让我们使用<code class="eh mh mi mj mk b">merge</code>为我们的搜索应用程序提供两个输入，您可以通过键入任意一个进行搜索:</p><figure class="lv lw lx ly fq lz"><div class="bz el l di"><div class="ma mb l"/></div><figcaption class="mc md fg fe ff me mf bd b be z ek">Example 9: Text Search With Merge</figcaption></figure><figure class="lv lw lx ly fq lz"><div class="bz el l di"><div class="mg mb l"/></div></figure><h2 id="6153" class="lh kf hu bd kg li lj lk kk ll lm ln ko jc lo lp ks jg lq lr kw jk ls lt la lu dt translated">为以后保留数据</h2><p id="788c" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">以上所有示例的一个潜在问题是，当我们处于可观察流的后期阶段时，在请求完成之后，我们已经丢失了对原始有效负载的引用(在本例中，是我们的搜索词文本)。我们可以将原始有效负载与响应有效负载捆绑在一起，同时仍然可以通过词法范围访问它。例如，假设我们想将搜索词作为<code class="eh mh mi mj mk b">render</code>函数的一部分再次写入页面:</p><figure class="lv lw lx ly fq lz"><div class="bz el l di"><div class="ma mb l"/></div><figcaption class="mc md fg fe ff me mf bd b be z ek">Example 10: Text Search With Retained Data</figcaption></figure><figure class="lv lw lx ly fq lz"><div class="bz el l di"><div class="mg mb l"/></div></figure><h2 id="00fd" class="lh kf hu bd kg li lj lk kk ll lm ln ko jc lo lp ks jg lq lr kw jk ls lt la lu dt translated">合并最新</h2><p id="c923" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">RxJS最好的特性之一是将多个流合并成一个流是多么容易。为了演示，让我们修改我们的示例来执行两个搜索，并允许用户比较彼此相邻的结果头像，但仅在两个搜索都有结果之后:</p><figure class="lv lw lx ly fq lz"><div class="bz el l di"><div class="ma mb l"/></div><figcaption class="mc md fg fe ff me mf bd b be z ek">Example 11: Text Search With Combine Latest</figcaption></figure><figure class="lv lw lx ly fq lz"><div class="bz el l di"><div class="mg mb l"/></div></figure><h1 id="c434" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">接下来呢？</h1><p id="273a" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">有许多方法可以最大限度地利用RxJS处理HTTP请求的能力，我们已经提到了其中的一些方法。然而，RxJS API是一个复杂的庞然大物，我们仅仅触及了RxJS方法可以用HTTP流做的许多不同方式的表面。一旦你了解了一些，就很有必要查看一下<a class="ae kd" href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/libraries/main/rx.complete.md" rel="noopener ugc nofollow" target="_blank">文档</a>,尝试更多可能有助于更具体用例的文档。</p><div class="lv lw lx ly fq ab cb"><figure class="mn lz mo mp mq mr ms paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mn lz mo mp mq mr ms paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mn lz mo mp mq mr ms paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mv mw mx"><p id="f922" class="ir is ml it b iu iv iw ix iy iz ja jb my jd je jf mz jh ji jj na jl jm jn jo hn dt translated"><a class="ae kd" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kd" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kd" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae kd" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is ml it b iu iv iw ix iy iz ja jb my jd je jf mz jh ji jj na jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kd" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kd" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lv lw lx ly fq lz fe ff paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="fe ff nb"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>