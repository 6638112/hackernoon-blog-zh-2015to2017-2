<html>
<head>
<title>Numbers of Every Shape and Size</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">各种形状和大小的数字</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/numbers-of-every-shape-and-size-e277232d776b?source=collection_archive---------18-----------------------#2017-05-22">https://medium.com/hackernoon/numbers-of-every-shape-and-size-e277232d776b?source=collection_archive---------18-----------------------#2017-05-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="8024" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上周我们探索了Haskell中许多不同的字符串类型。但这不是我们似乎有大量相似类型的唯一情况。我们也可以在Haskell的<strong class="it hv">数字类型</strong>中看到这一点。同样，我们也有这样的问题，我们经常想用稍微不同的方式来表示数字。但是Haskell的类型系统迫使我们为每种不同的情况使用不同的类型。这些类型之间的互操作可能非常痛苦。</p><p id="8471" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是Haskell的另一个特点，肯定会让初学者陷入困境。它甚至可以让他们说:“唉，这种语言太烂了，我要回到Javascript”(在那里数字更容易)。但是有一些简单的规则你必须掌握，然后事情会变得更好。让我们从总结我们可以使用的不同数字类型开始。</p><h1 id="9142" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">Int类型</h1><p id="0236" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">最熟悉的整数型是简单的<code class="eh ks kt ku kv b">Int</code>型。这代表你的标准的机器可变的，有界的，有符号的整数。根据文件，它保证至少有从-2^29到2^29.的射程因此，如果您在32位机器上，那么您的<code class="eh ks kt ku kv b">Int</code>可能有一组不同于64位机器上的界限。幸运的是，<code class="eh ks kt ku kv b">Int</code>是<code class="eh ks kt ku kv b">Bounded</code>类型类的成员。因此，在您的代码中，您总是可以查询最大和最小界限来检查溢出。</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="8454" class="le jq hu kv b fv lf lg l lh li">class Bounded a where<br/>  minBound :: a<br/>  maxBound :: a</span></pre><p id="a1dd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，假设你不想被你能储存多大价值的机器所左右。有时候，你想知道你的int会占用多少内存。有几种不同的<code class="eh ks kt ku kv b">Int</code>类型可以让你做到这一点。我们有<code class="eh ks kt ku kv b">Int8</code>、<code class="eh ks kt ku kv b">Int16</code>、<code class="eh ks kt ku kv b">Int32</code>和<code class="eh ks kt ku kv b">Int64</code>。它们允许你在数量上有更明确的界限，同时给你和<code class="eh ks kt ku kv b">Int</code>一样的基本功能。显然<code class="eh ks kt ku kv b">Int8</code>是8位，<code class="eh ks kt ku kv b">Int16</code>是16位，以此类推。</p><p id="d341" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，也有一些情况，你希望你的整数是无界的。在这种情况下，您需要使用<code class="eh ks kt ku kv b">Integer</code>类型。这种类型对你的数量没有限制。它没有实现<code class="eh ks kt ku kv b">Bounded</code> typeclass。自然，这是以性能损失为代价的。如果您的数字太大，无法放入内存中的单个寄存器，Haskell将使用一个字节数组来表示该数字。对这个数字的运算会比较慢。硬件被设计成能以极快的速度对较小的值进行数学运算。在更大的数字上，你将无法获得这些加速。但是如果你需要更高的界限，那么你没有选择。</p><h1 id="4c6f" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">单词类型</h1><p id="6fec" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">一旦你理解了不同的<code class="eh ks kt ku kv b">Int</code>类，接下来就是<code class="eh ks kt ku kv b">Word</code>类型了。每种<code class="eh ks kt ku kv b">Int</code>尺寸都有相应的<code class="eh ks kt ku kv b">Word</code>型号。这些类型以同样的方式工作，除了它们是无符号的。因此，<code class="eh ks kt ku kv b">Int8</code>从-128到127，而<code class="eh ks kt ku kv b">Word8</code>可以包含从0到255的值。事实上，<code class="eh ks kt ku kv b">Data.ByteString</code>有一个函数给你一个<code class="eh ks kt ku kv b">Word8</code>值的列表，作为字节串的表示。</p><p id="d8c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么我们能从这些不同的积分类型中学到什么呢？我们如何选择使用什么类型？大多数情况下，<code class="eh ks kt ku kv b">Int</code>可能没问题。根据域的不同，您可以限制需要使用的字节数。这就是不同大小的整数发挥作用的地方。如果你知道你的值将是正的而不是负的，那么一定要使用<code class="eh ks kt ku kv b">Word</code>类型而不是<code class="eh ks kt ku kv b">Int</code>类型。这将会给你更多的回旋余地。如果您正在处理可能超过64位界限的值，您别无选择，只能使用<code class="eh ks kt ku kv b">Integer</code>。请注意，如果值这么大，您将面临性能损失。</p><h1 id="9dcb" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">整型类</h1><p id="db24" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">你经常会遇到这样的情况，你想写一个关于数字的更通用的函数。你不知道你会和什么类型的人打交道。但是你知道它是这些整数类型中的一个。像一个优秀的Haskell开发人员一样，您希望您的代码尽可能多态。这就是<code class="eh ks kt ku kv b">Integral</code> typeclass的用途。它封装了一些不同的功能。</p><p id="de2a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，它有助于不同积分类型之间的转换。它提供了一个<code class="eh ks kt ku kv b">toInteger</code>函数，类型为:</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="ac07" class="le jq hu kv b fv lf lg l lh li">toInteger :: Integral a =&gt; a -&gt; Integer</span></pre><p id="e10c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这允许您使用无界的<code class="eh ks kt ku kv b">Integer</code>类型作为整数类型之间的媒介。它允许您编写合理的多态代码。但是也有缺点。通过使用最小公分母，您可能会使您的程序性能更差。因此，对于性能关键型代码，您可能需要更系统地考虑应该使用哪种类型。</p><p id="9c83" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ks kt ku kv b">Integral</code> typeclass中的其他函数处理整数类型上的<strong class="it hv">除法。例如，有商和余数函数。这些允许你在不知道确切类型的时候进行整数除法。</strong></p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="51b1" class="le jq hu kv b fv lf lg l lh li">class Integral a where<br/>  toInteger :: a -&gt; Integer<br/>  quot :: a -&gt; a -&gt; a <br/>  -- ^^ Integer division, e.g. 9 `quot` 2 = 4<br/>  rem :: a -&gt; a -&gt; a<br/>  -- ^^ Remainder, e.g. 9 `rem` 2 = 1<br/>  div :: a -&gt; a -&gt; a<br/>  mod :: a -&gt; a -&gt; a</span></pre><p id="33ea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">值得注意的是，<code class="eh ks kt ku kv b">div</code>和<code class="eh ks kt ku kv b">mod</code>函数类似于<code class="eh ks kt ku kv b">quot</code>和<code class="eh ks kt ku kv b">rem</code>，但是向负无穷大而不是0舍入。不得不穿过这些圈圈可能会有点困难。尤其是当你的javascript朋友可以一直写<code class="eh ks kt ku kv b">5 / 2</code>而不受惩罚的时候。但这是强类型系统的代价。</p><h1 id="680e" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">浮点数</h1><p id="ed4c" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">当然，我们也有一些不同的类型来表示浮点数。Haskell有两种主要的浮点类型:<code class="eh ks kt ku kv b">Float</code>和<code class="eh ks kt ku kv b">Double</code>。<code class="eh ks kt ku kv b">Float</code>类型是单精度浮点数。当然，<code class="eh ks kt ku kv b">Double</code>是双精度。它们代表相同的基本概念，但是<code class="eh ks kt ku kv b">Double</code>允许更大范围的值和更精确的<strong class="it hv">。同时占用的内存是a <code class="eh ks kt ku kv b">Float</code>的两倍。使用以下函数可以很容易地在这两种类型之间进行转换:</strong></p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="c72e" class="le jq hu kv b fv lf lg l lh li">float2Double :: Float -&gt; Double<br/>double2Float :: Double -&gt; Float</span></pre><p id="c5fa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有一个封装了这些类型的typeclass(以及几个更模糊的版本)。这是<code class="eh ks kt ku kv b">Floating</code>类型类。它允许在这些类型上执行许多不同的操作。很多都是数学函数。</p><p id="8d93" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，其中一个功能就是<code class="eh ks kt ku kv b">pi</code>。因此，如果您的函数采用<code class="eh ks kt ku kv b">Floating</code> typeclass中的任何类型，您仍然可以获得pi的可靠值。<code class="eh ks kt ku kv b">Floating</code>也融合了其他数学概念，比如平方根、指数、三角函数等等。</p><h1 id="11cd" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">其他数值类型类</h1><p id="fb27" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">还有一些其他的数字类型类。它们封装了浮点数和整数的行为。例如，我们有一个<code class="eh ks kt ku kv b">Real</code> typeclass，它允许我们将任何东西转换成一个<code class="eh ks kt ku kv b">Rational</code>数字。还有<code class="eh ks kt ku kv b">Fractional</code>类型类。它允许我们对分数进行某些自然的运算。这些包括计算<strong class="it hv">倒数和执行真(非整数)除法</strong>。然后我们可以将这两个类混合在一起得到<code class="eh ks kt ku kv b">RealFrac</code>。这个typeclass允许我们将一个数表示为一个真分数(因此是两个整数的元组)。它还有其他几个有用的功能，如<code class="eh ks kt ku kv b">ceiling</code>、<code class="eh ks kt ku kv b">round</code>、<code class="eh ks kt ku kv b">truncate</code>等等。</p><h1 id="a271" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">皈依狂热</h1><p id="a956" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">我们已经讨论了相似类型之间的一些转换。但是很难跟踪所有不同的值之间的转换方式。要获得更详尽的列表，请查看<a class="ae lj" href="https://www.haskell.org/tutorial/numbers.html" rel="noopener ugc nofollow" target="_blank">Haskell简介</a>。除了我们已经讨论过的，两种类型的转换最为突出。</p><p id="e0d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第一，有<code class="eh ks kt ku kv b">fromIntegral</code>。这允许您从任何整数类型转换为任何数字类型。当你<strong class="it hv">需要一个浮点数</strong>但<strong class="it hv">有一些整数类型</strong>时，它应该是你的首选。第二，有一个从浮点数到整数类型的过程。你通常会使用<code class="eh ks kt ku kv b">round</code>、<code class="eh ks kt ku kv b">floor</code>和<code class="eh ks kt ku kv b">ceiling</code>中的一个，这取决于你想要的强制。最后，记住<code class="eh ks kt ku kv b">toInteger</code>函数。这通常是在整型之间转换的答案。</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="d2c4" class="le jq hu kv b fv lf lg l lh li">fromIntegral :: (Integral a, Num b) =&gt; a -&gt; b<br/>round :: (Fractional a, Integral b) =&gt; a -&gt; b<br/>floor :: (Fractional a, Integral b) =&gt; a -&gt; b<br/>ceiling :: (Fractional a, Integral b) =&gt; a -&gt; b<br/>toInteger :: (Integral a) =&gt; a -&gt; Integer</span></pre><h1 id="8875" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">科学的</h1><p id="06e0" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">如果您从事任何级别的web编程，您可能会使用<code class="eh ks kt ku kv b">Data.Aeson</code>库在JSON中编码。我们将在后面的文章中更深入地介绍这个库(它非常有用)。但是它使用了<code class="eh ks kt ku kv b">Scientific</code>类型，用“科学”符号表示数字。在这种格式中，你有一个基数乘以10的某次方。您不会经常遇到这种类型，但是知道如何构造它是很有用的。特别是，您可能经常希望获得简单的整数或浮点值，并在它们之间来回转换。以下是一些代码示例:</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="4cf3" class="le jq hu kv b fv lf lg l lh li">-- Creates 70000<br/>createScientificNum :: Scientific<br/>createScientificNum = scientific 7 4</span><span id="f3fe" class="le jq hu kv b fv lk lg l lh li">-- Conversion to float (i.e. 70000.0)<br/>convertToFloat :: Double<br/>convertToFloat = toBoundedRealFloat createScientificNum</span><span id="ebae" class="le jq hu kv b fv lk lg l lh li">-- Convert to integer, might fail if the scientific is not an integer<br/>convertToInt :: Maybe Integer<br/>convertToInt = toBoundedInteger createScientificNum</span></pre><h1 id="bdef" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">Num Typeclass</h1><p id="485a" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">所以在不同的浮点和整型类型类之上，我们还有<code class="eh ks kt ku kv b">Num</code>类型类。这使他们都聚集在一个屋檐下。这个typeclass的必需元素是基本的数学运算符。</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="c98c" class="le jq hu kv b fv lf lg l lh li">class Num a where<br/>  (+), (*), (-) :: a -&gt; a -&gt; a<br/>  negate :: a -&gt; a<br/>  abs :: a -&gt; a<br/>  signum :: a -&gt; a<br/>  fromInteger :: Integer -&gt; a</span></pre><p id="2024" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个类也有点类似于<code class="eh ks kt ku kv b">IsString</code>类型类。<code class="eh ks kt ku kv b">IsString</code>类让我们用一个字符串来表示代码中的不同类型。同样地，<code class="eh ks kt ku kv b">Num</code> typeclass允许我们使用数字文字来表示我们的值。我们甚至不需要它的编译器扩展！当您在一个数字周围创建“新类型”时，这尤其有用。不必总是为它编写构造函数，这很好。</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="6b24" class="le jq hu kv b fv lf lg l lh li">newtype MyNumberType = MyNumberType Int</span><span id="3b4d" class="le jq hu kv b fv lk lg l lh li">instance Num MyNumberType where<br/>  -- Implement math functions using underlying int value<br/>  ...</span><span id="f8fd" class="le jq hu kv b fv lk lg l lh li">myNumWithLiteral :: MyNumberType<br/>myNumWithLiteral = 5</span></pre><h1 id="db67" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">结论</h1><p id="b60f" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">在Haskell中，数字和字符串类型一样，非常容易混淆。很难让它们保持直线。当您试图在不同类型之间进行互操作时，这尤其困难。感觉上，既然数字类型如此相似，使用它们应该很容易。这一次，类型系统似乎妨碍了简单性。</p><p id="390b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">幸运的是，多态性允许我们用许多不同的方法来解决这个问题。我们几乎总能让我们的函数适用于许多不同的数字类型。我们经常需要转换我们的类型，以使事情互操作。但是通常有一些很好的函数可以让我们轻松地做到这一点。</p><p id="6a7e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你以前从未用Haskell编程，并且想尝试一下，你应该看看我们的<a class="ae lj" href="https://www.mmhaskell.com/checklist" rel="noopener ugc nofollow" target="_blank">入门清单</a>。它将引导您在计算机上安装Haskell。它还会给你指出一些帮助你学习语言的工具。</p><p id="e0c1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你已经做过一点实验，并且想要一些额外的练习，你应该下载我们的<a class="ae lj" href="https://www.mmhaskell.com/workbook" rel="noopener ugc nofollow" target="_blank">递归练习册</a>。它包含了两章的材料以及10道练习题！</p><p id="55cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最重要的是，请务必访问<a class="ae lj" href="https://www.mmhaskell.com/" rel="noopener ugc nofollow" target="_blank">周一早间Haskell </a>博客，获取更多精彩的Haskell内容，每周一都会有一篇新文章！</p><blockquote class="ll lm ln"><p id="4df5" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated"><a class="ae lj" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是阿妹家庭的一员。我们现在<a class="ae lj" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae lj" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated">要了解更多信息，<a class="ae lj" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">请阅读我们的“关于”页面</a> , <a class="ae lj" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">喜欢/在脸书给我们发消息</a>，或者简单地，<a class="ae lj" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank">发推文/DM @HackerNoon。</a></p><p id="708a" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lj" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lj" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>