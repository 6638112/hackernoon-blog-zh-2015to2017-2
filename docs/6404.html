<html>
<head>
<title>React + Typescript + RxJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React + Typescript + RxJS</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/react-typescript-rxjs-f50791aa596c?source=collection_archive---------4-----------------------#2017-09-16">https://medium.com/hackernoon/react-typescript-rxjs-f50791aa596c?source=collection_archive---------4-----------------------#2017-09-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="504e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最近我一直在尝试<a class="ae jp" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank"> React </a>、<a class="ae jp" href="https://hackernoon.com/tagged/typescript" rel="noopener ugc nofollow" target="_blank"> Typescript </a>和RxJS，到目前为止我真的很喜欢这个结果。基本的前提是有一个单一的可观察的库，并连接它以对更新的组件作出反应。然后将所有的状态和业务逻辑推到可观察的地方。这是因为花了大量时间使用Redux(添加了中间件)、重新组合和重新选择，然后对简单地将组件连接到可观察对象并计算派生状态所需的大量库和样板文件感到沮丧。几年前，我有幸在Angular 1项目中与一个非常聪明的开发人员一起工作，这个项目使用了一个简单的自主开发的observable库进行状态管理，在不使用大量库的情况下，一切都运行得非常好。这个例子是为了用更现代的工具重新创建那个概念。它是围绕一个待办事项列表构建的，该列表显示从服务器获取的待办事项列表，并允许用户向该列表添加新的待办事项。</p><p id="d431" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">免责声明:</strong>这种方法打破了将所有状态保存在单个存储中的冗余原则。如果你是这种方法的强烈拥护者，那么你不会喜欢这样，这很酷。我个人已经取得了很大的成功，并且发现用多个相互交互的状态存储来构建一个项目更容易。</p></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><p id="c19d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了将Typescript、React和RxJS集成为一个简单的todos列表容器，我创建了4个文件。</p><p id="08f2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> TodosListComponent.ts </strong></p><p id="b5cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个文件导出了“哑”组件，它只是将道具渲染为JSX。</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="078b" class="kg kh hu kc b fv ki kj l kk kl"><strong class="kc hv">import </strong>* <strong class="kc hv">as </strong>React <strong class="kc hv">from </strong>'react';<br/><strong class="kc hv">import </strong>{TodosListComponentProps} <strong class="kc hv">from </strong>'./TodosListComponentProps';<br/><strong class="kc hv">import </strong>{FormEventHandler, KeyboardEventHandler} <strong class="kc hv">from </strong>'react';<br/><strong class="kc hv">import </strong>{TodoEntity} <strong class="kc hv">from </strong>'service-entities/todos';<br/><strong class="kc hv">import </strong>{Key} <strong class="kc hv">from </strong>'ts-keycode-enum';<br/><br/><strong class="kc hv">interface </strong>TodosListState {<br/> todoText: <strong class="kc hv">string</strong>;<br/>}<br/><br/><strong class="kc hv">export class </strong>TodosListComponent <strong class="kc hv">extends </strong>React.PureComponent&lt;TodosListComponentProps, TodosListState&gt; {</span><span id="8e03" class="kg kh hu kc b fv km kj l kk kl"> state = {<br/>  todoText: ''<br/> };<br/><br/> render() {<br/>  <strong class="kc hv">const </strong>{todos} = <strong class="kc hv">this</strong>.props;<br/><br/>  <strong class="kc hv">return </strong>(<br/>   &lt;div&gt;<br/>    &lt;button onClick={<strong class="kc hv">this</strong>.addTodo}&gt;add&lt;/button&gt;<br/>    &lt;input type='text' <br/>           value={<strong class="kc hv">this</strong>.state.todoText} <br/>           onChange={<strong class="kc hv">this</strong>.updateTodoText} <br/>           onKeyPress={<strong class="kc hv">this</strong>.handleEnter}/&gt;<br/>    &lt;ol&gt;<br/>     {<br/>      todos.map((todo: TodoEntity) =&gt; <br/>        &lt;li key={todo.id}&gt;{todo.text}&lt;/li&gt;<br/>      )<br/>     }<br/>    &lt;/ol&gt;<br/>   &lt;/div&gt;<br/>  );<br/> }<br/><br/> componentDidMount() {<br/>  <strong class="kc hv">this</strong>.props.refresh();<br/> }<br/><br/> updateTodoText: FormEventHandler&lt;HTMLInputElement&gt; = <br/>  e =&gt; <strong class="kc hv">this</strong>.setState({todoText: e.currentTarget.value});<br/><br/> addTodo = () =&gt; {<br/>  <strong class="kc hv">this</strong>.props.addTodo({text: <strong class="kc hv">this</strong>.state.todoText});<br/>  <strong class="kc hv">this</strong>.setState({todoText: ''});<br/> };<br/><br/> handleEnter: KeyboardEventHandler&lt;HTMLInputElement&gt; = e =&gt; {<br/>  <strong class="kc hv">if </strong>(e.which === Key.<em class="kn">Enter</em>) {<br/>   <strong class="kc hv">this</strong>.addTodo();<br/>  }<br/> }<br/>}</span></pre></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><p id="d9c8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">todos listcomponentprops . ts</strong></p><p id="f355" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个文件导出了定义TodosListComponent属性的接口，RxJS需要完成这个接口来创建TodosList容器。</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="c604" class="kg kh hu kc b fv ki kj l kk kl"><strong class="kc hv">import </strong>{TodoEntity, CreateTodoEntity} <strong class="kc hv">from </strong>'service-entities/todos';<br/><br/><strong class="kc hv">export interface </strong>TodosListComponentProps {<br/> todos: TodoEntity[];<br/> refresh: () =&gt; <strong class="kc hv">void</strong>;<br/> addTodo: (todo: CreateTodoEntity) =&gt; <strong class="kc hv">void</strong>;<br/>}</span></pre></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><p id="492b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> TodosListStore.ts </strong></p><p id="3424" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是我们的存储，它将实现由TodosListComponentProps定义的所有属性和方法。为了存储来自服务器的todos列表，我们使用了来自RxJS的<a class="ae jp" href="http://reactivex.io/rxjs/manual/overview.html#behaviorsubject" rel="noopener ugc nofollow" target="_blank"> BehaviorSubject </a>。当存储应用程序状态时，BehaviorSubject给了我们两个很好的特性。我们可以使用“value”属性获得可观察流的当前值，对流的任何更改都将多播给所有订阅者(就像订阅redux一样)。注意，我们导出类不仅仅是为了类型信息，也是为了通过基本的依赖注入使单元测试变得容易。此外，如果我们需要多个TodosListStore对象，我们可以通过注入不同的依赖项来轻松创建它们。</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="fea6" class="kg kh hu kc b fv ki kj l kk kl"><strong class="kc hv">import </strong>{todosService} <strong class="kc hv">from </strong>'todos/TodosService';<br/><strong class="kc hv">import </strong>{BehaviorSubject} <strong class="kc hv">from </strong>'rxjs/BehaviorSubject';<br/><strong class="kc hv">import </strong>{CreateTodoEntity, TodoEntity} <strong class="kc hv">from </strong>'service-entities/todos';<br/><br/><strong class="kc hv">export class </strong>TodosListStore {<br/><br/> <strong class="kc hv">constructor</strong>(<br/>  <strong class="kc hv">readonly </strong>todos = <strong class="kc hv">new </strong>BehaviorSubject&lt;TodoEntity[]&gt;([]),<br/>  <strong class="kc hv">private </strong>service = todosService<br/> ) {}</span><span id="a3aa" class="kg kh hu kc b fv km kj l kk kl"> // fetch todos from the server and update the value of todos<br/> <strong class="kc hv">readonly </strong>refresh = () =&gt; <br/>  <strong class="kc hv">this</strong>.service.find().then((todos: TodoEntity[]) =&gt;<br/>    <strong class="kc hv">this</strong>.todos.next(todos)<br/>  );</span><span id="ce5f" class="kg kh hu kc b fv km kj l kk kl">  // add the todo to the server and prepend it to our todos list<br/>  <strong class="kc hv">readonly </strong>addTodo = (todo: CreateTodoEntity) =&gt;<br/>   <strong class="kc hv">this</strong>.service.create(todo).then(<br/>     (addedTodo: TodoEntity) =&gt; <br/>       <strong class="kc hv">this</strong>.todos.next([addedTodo, ...<strong class="kc hv">this</strong>.todos])<br/>   );<br/>}<br/><br/><strong class="kc hv">export const </strong>todosListStore = <strong class="kc hv">new </strong>TodosListStore();</span></pre></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><p id="fbd1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">todo list . ts</strong></p><p id="e027" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该文件导出最终的容器组件<code class="eh ko kp kq kc b">&lt;TodosList/&gt;</code>。要将TodosListStore连接到TodosListComponent，我们需要做两件事。</p><p id="9a84" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，为组件需要的所有道具创建一个可观察对象。我们使用一个名为<a class="ae jp" href="https://github.com/slively/fullstack-typescript/blob/master/ui/src/lib/combineLatestObj.ts" rel="noopener ugc nofollow" target="_blank"> combineLatestObj </a>的函数来完成这项工作，该函数基于RxJS函数<a class="ae jp" href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-combineLatest" rel="noopener ugc nofollow" target="_blank"> combineLatest </a>。combineLatest操作符只需获取一个观察值列表，当其中任何一个观察值发生变化时，它会将所有观察值中的最新值作为参数发送给订阅者。</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="8a36" class="kg kh hu kc b fv ki kj l kk kl">// combineLatest Example<br/>const observer1 = Observable.<em class="kn">of('a');<br/></em>const observer2 = Observable.<em class="kn">of(1);</em></span><span id="3ea1" class="kg kh hu kc b fv km kj l kk kl">combineLatest(<br/> observer1, <br/> observer2, <br/> (value1, value2) =&gt; value1 + value2<br/>)<br/> .subscribe(combinedValue =&gt; console.log(combinedValue));</span><span id="0826" class="kg kh hu kc b fv km kj l kk kl">observer1.next('b');<br/>observer2.next(2);</span><span id="76ba" class="kg kh hu kc b fv km kj l kk kl">// a1<br/>// b1<br/>// b2</span></pre><p id="47a9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的函数combineLatestObj是同样的想法，但是我们想给它一个键映射到可观察值，并让它将键映射解析到每个可观察值的最新值。它还有一个传递静态值的特性，所以我们不需要为不变的值创建可观察值(比如在组件外部定义的函数或常数)。</p><p id="de4a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意:这也可以通过组合来创建嵌套对象</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="36d9" class="kg kh hu kc b fv ki kj l kk kl">// combineLatestObj Example<br/>const observer1 = Observable.<em class="kn">of('a');<br/></em>const observer2 = Observable.<em class="kn">of(1);<br/>const constantValue = 'no changes';</em></span><span id="3d01" class="kg kh hu kc b fv km kj l kk kl">combineLatest({<br/> value1: observer1, <br/> value2: observer2,<br/> <em class="kn">constantValue</em><br/>})<br/> .subscribe(latestObject =&gt; console.log(latestObject));</span><span id="5d41" class="kg kh hu kc b fv km kj l kk kl">observer1.next('b');<br/>observer2.next(2);</span><span id="3168" class="kg kh hu kc b fv km kj l kk kl">// { value1: a, value2: 1, <em class="kn">constantValue: 'no changes'</em> }<br/>// { value1: b, value2: 1, <em class="kn">constantValue: 'no changes'</em> }<br/>// { value1: b, value2: 2, <em class="kn">constantValue: 'no changes'</em> }</span></pre><p id="c290" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用combineLatestObj很容易创建一个满足TodosListComponentProps和todosListStore的单个可观察对象，并且是强类型的:</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="3a28" class="kg kh hu kc b fv ki kj l kk kl">combineLatestObj&lt;TodosListComponentProps&gt;(todosListStore);</span></pre><p id="d16b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">其次，我们需要将新的observable连接到TodosListComponent来创建一个容器，就像您使用react-redux <a class="ae jp" href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options" rel="noopener ugc nofollow" target="_blank"> connect </a> <a class="ae jp" href="https://facebook.github.io/react/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">高阶组件</a>一样。为了做到这一点，我们有一个类似的称为<a class="ae jp" href="https://github.com/slively/fullstack-typescript/blob/master/ui/src/lib/withObservable.tsx" rel="noopener ugc nofollow" target="_blank"> withObservable </a>的高阶组件，它将订阅给定的可观察对象，并且每当有更新时，可观察对象的值(而不是其他值)将被传递给给给定的组件。该函数像任何其他高阶组件一样使用，并提供强类型，以确保可观察对象和组件都满足给定的接口:</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="0b8f" class="kg kh hu kc b fv ki kj l kk kl">withObservable&lt;TodosListComponentProps&gt;(TodosListObservable)(TodosListComponent);</span></pre><p id="679c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在导出我们的容器就像导出这两个步骤的结果一样简单:</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="7f00" class="kg kh hu kc b fv ki kj l kk kl"><strong class="kc hv">import </strong>{TodosListComponent} <strong class="kc hv">from </strong>'todos/TodosList/TodosListComponent';<br/><strong class="kc hv">import </strong>{TodosListComponentProps} <strong class="kc hv">from </strong>'todos/TodosList/TodosListComponentProps';<br/><strong class="kc hv">import </strong>{todosListStore} <strong class="kc hv">from </strong>'todos/TodosList/TodosListStore';<br/><strong class="kc hv">import </strong>{withObservable} <strong class="kc hv">from </strong>'lib/withObservable';<br/><strong class="kc hv">import </strong>combineLatestObj <strong class="kc hv">from </strong>'lib/combineLatestObj';<br/><br/><strong class="kc hv">const </strong>TodosListObservable = combineLatestObj&lt;TodosListComponentProps&gt;(todosListStore);<br/><br/><strong class="kc hv">export const </strong>TodosList = withObservable&lt;TodosListComponentProps&gt;(TodosListObservable)(TodosListComponent);</span></pre></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><p id="f9ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我喜欢这种方法，不仅因为我过去使用过类似的模式并取得了很好的结果，而且通过使用普通的类、可观察的流和单个高阶组件，我们已经取代了redux、redux-thunk、reselect和recompose。这篇文章基于一个更复杂的例子,这个例子通过添加过滤待办事项列表的功能演示了两个商店的交互。</p><figure class="jx jy jz ka fq kr"><div class="bz el l di"><div class="ks kt l"/></div></figure></div></div>    
</body>
</html>