<html>
<head>
<title>Smart Pointer, shared_ptr, Automatic Pointer and unique_ptr</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">智能指针、共享指针、自动指针和唯一指针</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/smart-pointer-shared-ptr-automatic-pointer-and-unique-ptr-4fb12ff53914?source=collection_archive---------19-----------------------#2017-10-09">https://medium.com/hackernoon/smart-pointer-shared-ptr-automatic-pointer-and-unique-ptr-4fb12ff53914?source=collection_archive---------19-----------------------#2017-10-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/87f0893f919a2fe003a9e844023f8114.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6M9p4OQrah54BYMoi82cRA.jpeg"/></div></div></figure><p id="5925" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对象的生命周期至关重要。确定对象生命周期的错误会导致资源(如内存、fd)泄漏，因为所拥有的资源不能被正确释放和回收以供<a class="ae ka" href="https://hackernoon.com/tagged/future" rel="noopener ugc nofollow" target="_blank">将来</a>使用。当泄漏累积到一定程度时，它会使整个系统崩溃。<br/>对象生命周期也很复杂，因为一个对象的所有权可能被不同的实体放弃、转移或共享，这些实体包括但不限于变量、<a class="ae ka" href="https://hackernoon.com/tagged/function" rel="noopener ugc nofollow" target="_blank">函数</a>参数、模块、数据结构、容器和线程。同样，资源必须由所有者之一在某个不确定的点上释放和回收。没有事实上的标准来确定对象的生命周期。像Java中使用的<strong class="je hv"> GC </strong>(垃圾收集)，Objective-C中使用的<strong class="je hv"> ARC </strong>以及C++中的所有那些指针(ptr)都有它们的优缺点。然而，本文不是关于利弊，而是集中在C++资源管理助手类、智能指针、<code class="eh kb kc kd ke b">shared_ptr</code>、<code class="eh kb kc kd ke b">auto_ptr</code>和<code class="eh kb kc kd ke b">unique_ptr</code>。</p><h1 id="8e26" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">智能指针</h1><p id="c248" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">智能指针是普通指针的包装类。<strong class="je hv">智能指针</strong>用引用计数定义生命周期，引用计数反映智能指针对象被引用的次数。</p><p id="1edb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我将展示一个<strong class="je hv">智能指针</strong>的简单实现。该代码仅用于演示目的，因此没有健全性检查、异常处理和线程安全保证。</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="f12f" class="lq kg hu ke b fv lr ls l lt lu">#include &lt;stdio.h&gt;<br/><br/>template &lt; typename T &gt; class SmartPointer {<br/>private:<br/>  T* _pRes;<br/>  int* _refCount;</span><span id="913b" class="lq kg hu ke b fv lv ls l lt lu">void _release() {<br/>    if(--(*_refCount) == 0) {<br/>      printf("---Valar Morghulis:%d\n",*_refCount);<br/>      delete _pRes;<br/>      delete _refCount;<br/>    } else {<br/>      printf("---not today:%d\n",*_refCount);<br/>    }<br/>  }</span><span id="0b57" class="lq kg hu ke b fv lv ls l lt lu">public:<br/>  SmartPointer() : _pRes(NULL), _refCount(NULL) {<br/>    _refCount = new int(0);<br/>    printf("SP default cons:%d\n",*_refCount);<br/>  }</span><span id="a359" class="lq kg hu ke b fv lv ls l lt lu">SmartPointer(T* pRes) : _pRes(pRes), _refCount(NULL) {<br/>    _refCount = new int(1);<br/>    printf("SP cons:%d\n",*_refCount);<br/>  }</span><span id="0651" class="lq kg hu ke b fv lv ls l lt lu">SmartPointer(const SmartPointer&lt;T&gt;&amp; sp) : _pRes(sp._pRes), _refCount(sp._refCount) {<br/>    (*_refCount)++;<br/>    printf("SP copy cons:%d\n",*_refCount);<br/>  }</span><span id="0778" class="lq kg hu ke b fv lv ls l lt lu">SmartPointer&lt;T&gt;&amp; operator = (const SmartPointer&lt;T&gt;&amp; sp) {<br/>    this-&gt;_release(); // release the last resource it points to <br/>    _pRes = sp._pRes;<br/>    _refCount = sp._refCount;<br/>    (*_refCount)++;<br/>    printf("SP assign:%d\n",*_refCount);<br/>    return *this;<br/>  }</span><span id="be70" class="lq kg hu ke b fv lv ls l lt lu">~SmartPointer() {<br/>    this-&gt;_release();<br/>  }</span><span id="3f71" class="lq kg hu ke b fv lv ls l lt lu">// to mimic a real pointer<br/>  T&amp; operator* () {<br/>    return *_pRes;<br/>  }</span><span id="182f" class="lq kg hu ke b fv lv ls l lt lu">// to mimic a real pointer<br/>  T* operator-&gt; () {<br/>    return _pRes;<br/>  }<br/>};</span><span id="5d21" class="lq kg hu ke b fv lv ls l lt lu">class AClass {<br/>public:<br/>  AClass() { printf("aclass cons\n"); }<br/>  ~AClass() { printf("aclass des\n"); }<br/>};</span><span id="53a5" class="lq kg hu ke b fv lv ls l lt lu">void l2(SmartPointer&lt;AClass&gt;&amp; p) {<br/>  SmartPointer&lt;AClass&gt; use3 = p;        // &gt;&gt; SP copy cons:3<br/>}                                       // &gt;&gt; ---not today:2</span><span id="7c00" class="lq kg hu ke b fv lv ls l lt lu">void l1(SmartPointer&lt;AClass&gt;&amp; p) {<br/>  SmartPointer&lt;AClass&gt; use2 = p;        // &gt;&gt; SP copy cons:2<br/>  l2(p);<br/>}                                       // &gt;&gt; ---not today:1</span><span id="bb26" class="lq kg hu ke b fv lv ls l lt lu">int main() {<br/>  AClass *res = new AClass();           // &gt;&gt; aclass cons<br/>  SmartPointer&lt;AClass&gt; aSmartP(res);    // &gt;&gt; SP cons:1<br/>  l1(aSmartP);<br/>}                                       // &gt;&gt; ---Valar Morghulis:0<br/>                                        // &gt;&gt; aclass des</span></pre><p id="e6a0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">结果:</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="bfed" class="lq kg hu ke b fv lr ls l lt lu">aclass cons<br/>SP cons:1<br/>SP copy cons:2<br/>SP copy cons:3<br/>---not today:2<br/>---not today:1<br/>---Valar Morghulis:0<br/>aclass des</span></pre><p id="caaa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">简单解释一下上面的代码:</p><ol class=""><li id="1937" class="lw lx hu je b jf jg jj jk jn ly jr lz jv ma jz mb mc md me dt translated"><code class="eh kb kc kd ke b">SmartPointer</code>的生命周期不过是一个普通的阶级。因此，超出(函数)范围的逻辑流会破坏它；</li><li id="a71a" class="lw lx hu je b jf mf jj mg jn mh jr mi jv mj jz mb mc md me dt translated"><code class="eh kb kc kd ke b">SmartPointer</code>有两个属性，<code class="eh kb kc kd ke b">_pRes</code>和<code class="eh kb kc kd ke b">_refCount</code>，都是从堆中分配的。因此，超出(功能)范围的逻辑流不会破坏它们；</li><li id="faab" class="lw lx hu je b jf mf jj mg jn mh jr mi jv mj jz mb mc md me dt translated">每次用有效的<code class="eh kb kc kd ke b">_pRes</code>(类型<code class="eh kb kc kd ke b">T</code>)构造一个<code class="eh kb kc kd ke b">SmartPointer</code>时，<code class="eh kb kc kd ke b">_refCount</code>加上<code class="eh kb kc kd ke b">1</code>；</li><li id="7be2" class="lw lx hu je b jf mf jj mg jn mh jr mi jv mj jz mb mc md me dt translated">每次a被<code class="eh kb kc kd ke b">SmartPointer</code>析构，在我们的例子中，是被一个超出范围的逻辑流析构，即<code class="eh kb kc kd ke b">_refCount</code>减去<code class="eh kb kc kd ke b">1</code>；</li><li id="3be0" class="lw lx hu je b jf mf jj mg jn mh jr mi jv mj jz mb mc md me dt translated">然而，<code class="eh kb kc kd ke b">SmartPointer</code>的毁灭并不一定导致<code class="eh kb kc kd ke b">_pRes</code>的毁灭:</li></ol><p id="eebd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">a)当<code class="eh kb kc kd ke b">_refCount</code>仍大于<code class="eh kb kc kd ke b">0</code>，<code class="eh kb kc kd ke b">SmartPointer</code>只需减小<code class="eh kb kc kd ke b">_refCount</code>并打印</p><figure class="li lj lk ll fq iv fe ff paragraph-image"><div class="fe ff mk"><img src="../Images/3b824f665dfd65df458a6bb06cf05052.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*hKjxn1ElbbBRdULwjGRejA.jpeg"/></div><figcaption class="ml mm fg fe ff mn mo bd b be z ek">not today</figcaption></figure><p id="7b8a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">b)只有当<code class="eh kb kc kd ke b">_refCount</code>被减号设置为<code class="eh kb kc kd ke b">0</code>时，<code class="eh kb kc kd ke b">SmartPointer</code>才会析构<code class="eh kb kc kd ke b">_pRes</code>引用的资源并打印</p><figure class="li lj lk ll fq iv fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/085fdc66cf36a0628fd35abeff047983.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*RTRp8bUx3dL_s1NQ_ql4aA.jpeg"/></div><figcaption class="ml mm fg fe ff mn mo bd b be z ek">All men must die</figcaption></figure><p id="b348" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以智能指针就像程序的不同部分用来跟踪和控制资源实例的句柄。当所有句柄都被销毁时，该资源被视为“未使用”，并被删除。在本文的最后，我将展示一些在现实世界中体现智能指针的真实句柄。</p><p id="3e3a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该示例展示了在线性程序中使用<strong class="je hv">智能指针</strong>，这在真实场景中很少出现。相反，如前所述，资源(即<code class="eh kb kc kd ke b">AClass</code>的实例)可以由多个并行的数据结构和变量共享。</p><h1 id="fd85" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">shared_ptr (C++11)</h1><p id="06a0" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated"><code class="eh kb kc kd ke b">shared_ptr</code>是<em class="mq"> std </em>对<strong class="je hv">智能指针</strong>的实现，比上面列出的演示代码更加健壮。并且它不会生成不可靠的日志。</p><h1 id="f261" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated"><strong class="ak">自动指针</strong></h1><p id="3f80" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">一个<strong class="je hv">自动指针</strong>，虽然看起来和<strong class="je hv">智能指针</strong>很像，但是完全不同。这是一个方便的助手类，只要逻辑流超出范围，它就会析构资源，以防程序员忘记。在某种程度上，它使指针(指运行时动态分配的内存块)的工作方式类似于堆栈变量(在编译时静态分配)。</p><p id="3d97" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如，自动指针1.0版:</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="6e0c" class="lq kg hu ke b fv lr ls l lt lu">#include &lt;stdio.h&gt;</span><span id="dd84" class="lq kg hu ke b fv lv ls l lt lu">template &lt; typename T &gt; class AutoPointer {<br/>private:<br/>  T* _pRes;<br/> <br/>public:<br/>  AutoPointer() : _pRes(NULL) {}<br/> <br/>  AutoPointer(T* pRes) : _pRes(pRes) {}<br/> <br/>  AutoPointer(const AutoPointer&lt;T&gt;&amp; ap) : _pRes(ap._pRes) {}<br/> <br/>  AutoPointer&lt;T&gt;&amp; operator = (const AutoPointer&lt;T&gt;&amp; ap) {<br/>    delete _pRes;<br/>    _pRes = ap._pRes;<br/> <br/>    return *this;<br/>  }<br/> <br/>  ~AutoPointer() {<br/>    delete _pRes;<br/>  }<br/> <br/>  // to mimic a real pointer<br/>  T&amp; operator* () {<br/>    return *_pRes;<br/>  }<br/>  // to mimic a real pointer<br/>  T* operator-&gt; () {<br/>    return _pRes;<br/>  }<br/>};<br/> <br/>class AClass {<br/>public:<br/>  AClass() {printf(“cons\n”);}<br/>  ~AClass() {printf(“des\n”);}<br/>  int i;<br/>};<br/> <br/>void l1(AutoPointer&lt;AClass&gt;&amp; p) {<br/>  AutoPointer&lt;AClass&gt; use2 = p;<br/>}//the resource has already been deallocated here<br/> <br/>int main() {<br/>  AClass *res = new AClass();<br/>  res-&gt;i = 5;<br/>  AutoPointer&lt;AClass&gt; use1(res);<br/>  l1(use1);<br/>}// abort, repeat deallocating pointer</span></pre><p id="a46d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">结果:</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="8772" class="lq kg hu ke b fv lr ls l lt lu">cons<br/>des<br/>des<br/>autop(1148,0x7fff74eff000) malloc: *** error for object 0x7f9940c03240: pointer being freed was not allocated<br/>*** set a breakpoint in malloc_error_break to debug<br/>[1] 1148 abort ./a.out</span></pre><p id="4b10" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如上面的代码片段所给出的，<strong class="je hv">自动指针</strong>在内部的工作方式就像一个简化的<strong class="je hv">智能指针</strong>一样，不管引用计数是多少(实际上根本没有引用计数)。</p><p id="4808" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="mq"> coredump </em>显示了<strong class="je hv">自动指针</strong>的一个主要缺点:所有权不能转移(到<code class="eh kb kc kd ke b">l1()</code>)。结果，即使资源已经在<code class="eh kb kc kd ke b">l1()</code>中被解除分配，<code class="eh kb kc kd ke b">main()</code>仍然认为自己是<strong class="je hv">自动指针</strong>的所有者，并且再次解除分配指针。</p><p id="417b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">实现复制构造函数和赋值操作符，以便所有权可以正确转移，怎么样？</p><p id="6680" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如，自动指针2.0版:</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="6738" class="lq kg hu ke b fv lr ls l lt lu">......<br/>  AutoPointer(AutoPointer&lt;T&gt;&amp; ap) : _pRes(ap._pRes) {<br/>    ap._pRes = NULL;<br/>  }<br/> <br/>  AutoPointer&lt;T&gt;&amp; operator = (AutoPointer&lt;T&gt;&amp; ap) {<br/>    delete _pRes;<br/>    _pRes = ap._pRes;</span><span id="b4a0" class="lq kg hu ke b fv lv ls l lt lu">    ap._pRes = NULL;<br/>    return *this;<br/>  }<br/>......</span></pre><p id="c548" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">结果:</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="75ed" class="lq kg hu ke b fv lr ls l lt lu">cons<br/>des</span></pre><p id="e875" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一切似乎都很好。然而，这是“修复一个错误导致另一个错误”的又一个例子。</p><p id="b294" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">新的问题是所有权转移和复制这两个语义是耦合在一起的。因此，它与一些库函数不兼容，例如<code class="eh kb kc kd ke b">std::sort</code>需要一个额外的副本(作为快速排序中的枢纽),因为它破坏了仍在使用的前一个副本。问题的详细解释可以在这里找到<a class="ae ka" href="http://www.gotw.ca/gotw/025.htm" rel="noopener ugc nofollow" target="_blank">，感谢</a><a class="ae ka" href="https://www.reddit.com/user/" rel="noopener ugc nofollow" target="_blank">patata harpour</a>指出原实现中的错误。</p><p id="ec5f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kb kc kd ke b">std::auto_ptr</code>是<strong class="je hv">自动指针</strong>的<em class="mq"> std </em>实现。如上所述，它要么不是很有趣，要么有问题，所以现在被弃用。我们应该用<code class="eh kb kc kd ke b">std::unique_ptr</code>来代替。</p><h1 id="89c6" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">std::unique_ptr (C++11)</h1><p id="07aa" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated"><code class="eh kb kc kd ke b">std::unique_ptr</code>是C++11中<em class="mq"> std </em>对<code class="eh kb kc kd ke b">std::auto_ptr</code>的替代。通过新添加的<a class="ae ka" href="https://hackernoon.com/one-shot-learning-of-c-r-value-and-move-27e5d6bcec3b" rel="noopener ugc nofollow" target="_blank">右值和移动语义</a>，一个<code class="eh kb kc kd ke b">unique_ptr</code>的所有权可以安全地转移到另一个实体。此外，复制语义对于<code class="eh kb kc kd ke b">unique_ptr</code> s是禁用的，以避免我们在自动指针v2.0中看到的歧义。像<strong class="je hv">自动指针</strong>一样，指针的最后一个所有者负责解除分配。</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="6e5d" class="lq kg hu ke b fv lr ls l lt lu">#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>#include &lt;memory&gt;<br/>#include &lt;cstdio&gt;<br/>#include &lt;fstream&gt;<br/>#include &lt;cassert&gt;<br/> <br/>class AClass {<br/>public:<br/>  AClass() {printf(“cons\n”);}<br/>  ~AClass() {printf(“des\n”);}<br/>  int i;<br/>};<br/> <br/>std::vector&lt; std::unique_ptr&lt;AClass&gt; &gt; v;<br/> <br/>void l1() {<br/>  std::unique_ptr&lt;AClass&gt; p1(new AClass());    // &gt;&gt; cons<br/>  p1-&gt;i = 1;<br/>  v.push_back(std::move(p1));<br/>  std::unique_ptr&lt;AClass&gt; p2(new AClass());    // &gt;&gt; cons<br/>  p2-&gt;i = 2;<br/>  v.push_back(std::move(p2));<br/>} // p1 and p2 are not destructed here<br/> <br/>int main() {<br/>  l1();<br/>  for(auto&amp; p: v) printf(“%d\n”, p-&gt;i);<br/>}                                              // &gt;&gt; des<br/>                                               // &gt;&gt; des</span></pre><p id="29d7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">结果:</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="0794" class="lq kg hu ke b fv lr ls l lt lu">cons<br/>cons<br/>1<br/>2<br/>des<br/>des</span></pre><p id="abf4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如上面的代码片段所示，<strong class="je hv">唯一指针</strong>被保存在不同的所有者中。当所有权已经从<strong class="je hv">移动到<code class="eh kb kc kd ke b">vector v</code>时，<code class="eh kb kc kd ke b">l1()</code>不再释放资源。这使得<strong class="je hv">唯一指针</strong>有了更广泛的用途。</strong></p><p id="c9f2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，我宁愿相信<strong class="je hv">独特的指针</strong>是引入新的<em class="mq">移动语义的主要原因。因为</em>与这里获得的改进相比，通过<em class="mq">移动</em>和<em class="mq">右值</em>  <em class="mq"> </em>实现的<a class="ae ka" href="https://hackernoon.com/one-shot-learning-of-c-r-value-and-move-27e5d6bcec3b" rel="noopener ugc nofollow" target="_blank">优化不太显著。</a></p><h1 id="c565" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">带回家</h1><p id="0996" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">"我能理解这些东西，但我不确定第二天早上我是否还记得它们。"</p><p id="dd37" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当然可以。我会找一些真实世界的对应物来增强你的记忆。</p><p id="5c32" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">1) a <code class="eh kb kc kd ke b">std::shared_ptr</code>就像是视频游戏机的手柄。</p><figure class="li lj lk ll fq iv fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/6205d493988ba55a2f017327eb6b0da7.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*0YWiaPJqO_88RW9PT9quzQ.jpeg"/></div></figure><p id="f34b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">控制台(资源)被多个有手柄的玩家“<strong class="je hv">共享”</strong>，即使只剩下一个玩家，游戏也要继续。因此，只有当所有玩家停止游戏时，“游戏结束”。</p><p id="1c21" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">2)一个<code class="eh kb kc kd ke b">std::unique_ptr</code>就像一个便携式游戏机。</p><figure class="li lj lk ll fq iv fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/b130e494201c9f00b95c87f5399db393.png" data-original-src="https://miro.medium.com/v2/resize:fit:408/format:webp/1*8ZrHIhqWvTqi9dewTrbDNg.jpeg"/></div></figure><p id="9eb7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一次一个玩家，其中一个应该"<strong class="je hv">移动"</strong>它让另一个玩家玩。当最后一个玩家停止游戏时，游戏结束。</p><p id="c10d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">3)<code class="eh kb kc kd ke b">std::auto_ptr</code>是一个</p><figure class="li lj lk ll fq iv fe ff paragraph-image"><div class="fe ff mt"><img src="../Images/8987806cd8f58e0afc5d6c7b25475e09.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*brPAmA9AfQh9wCdT8lRHug.jpeg"/></div></figure><p id="fba2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为它不能轻易<strong class="je hv">移动</strong> d。</p><p id="c048" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你喜欢这篇文章，请为它鼓掌或点击按钮。谢谢，希望下次再见。</p></div><div class="ab cl mu mv hc mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="hn ho hp hq hr"><p id="80f6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="mq">最初发布于</em><a class="ae ka" href="http://holmeshe.me/cpp-pointers/" rel="noopener ugc nofollow" target="_blank"><em class="mq">holmeshe . me</em></a><em class="mq">。</em></p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="nb nc l"/></div></figure></div></div>    
</body>
</html>