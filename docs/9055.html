<html>
<head>
<title>Test-Driven Code Review</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试驱动的代码评审</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/test-driven-code-review-3f05f6cee400?source=collection_archive---------5-----------------------#2017-12-24">https://medium.com/hackernoon/test-driven-code-review-3f05f6cee400?source=collection_archive---------5-----------------------#2017-12-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/f0c8611dc8bf52674c10c663ad38cac2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WF-8zCNqB85AHiQKRn9TOA.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">source: <a class="ae jg" href="https://commons.wikimedia.org/wiki/File:Icon_stamp_under_Review_textured.svg" rel="noopener ugc nofollow" target="_blank">wikimedia</a></figcaption></figure><p id="d99c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一年前，我和我最好的朋友Alex就代码审查进行了一次有趣的讨论。他说当他做代码审查时，他总是从测试开始。他使用这种技术是为了理解代码真正做了什么，它是如何工作的，以及它覆盖了什么功能。</p><p id="f683" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在检查完测试之后，他接着检查产品代码。生产代码应该是有意义的，并且遵循团队设定的<a class="ae jg" href="https://hackernoon.com/the-importance-of-team-culture-af6fffead7b5" rel="noopener ugc nofollow" target="_blank">原则/指导方针和模式</a>(团队所说的“干净代码”的一切)，这样每个人都可以遵循。</p><p id="07ca" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当您想要实现一个特性时，您将一个单一的需求转化为用例。您将单个用例转换为测试用例。您在生产代码中实现这些测试用例。</p><p id="834b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你正在练习TDD，那么你正在遵循TDD 的<a class="ae jg" href="http://blog.cleancoder.com/uncle-bob/2014/12/17/TheCyclesOfTDD.html" rel="noopener ugc nofollow" target="_blank">三定律。这三个定律是:</a></p><ul class=""><li id="c6fb" class="kg kh hu jj b jk jl jo jp js ki jw kj ka kk ke kl km kn ko dt translated">在编写任何产品代码之前，您必须编写一个失败的测试。</li><li id="ba71" class="kg kh hu jj b jk kp jo kq js kr jw ks ka kt ke kl km kn ko dt translated">您不能编写超过足以导致失败或编译失败的测试。</li><li id="a0a9" class="kg kh hu jj b jk kp jo kq js kr jw ks ka kt ke kl km kn ko dt translated">您不得编写超过足以使当前失败的测试通过的生产代码。</li></ul><p id="28e1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里真正有趣的是第三条法则，因为它意味着如果你的测试通过了，你就不能添加更多的产品代码，如果你想添加更多的代码，你必须添加更多的测试用例。换句话说，您的产品代码仅仅是为了覆盖您的测试用例所描述的内容而编写的。仅仅通过查看需求并对照测试用例进行检查，您就可以很好地理解实现应该是什么样的，它涵盖了什么功能，以及开发人员是否忽略了任何用例并且需求没有得到满足。</p><h1 id="8d49" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">代码的行为受到测试用例的约束</h1><p id="de1e" class="pw-post-body-paragraph jh ji hu jj b jk ls jm jn jo lt jq jr js lu ju jv jw lv jy jz ka lw kc kd ke hn dt translated">因为您的测试是API的第一个客户端，所以它们可以帮助您暴露设计问题，比如封装问题或者组件之间的紧密耦合。</p><p id="2a8b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果测试模仿了许多组件，那么您需要检查封装是否被违反，以及这些组件中的一些是否可以被包保护或私有。封装是最重要的OOP概念之一，也是被开发人员滥用最多的概念。</p><p id="9abf" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果测试花了太多时间模仿单个对象的方法调用链，那么你可以非常确定违反了Demeter 的<a class="ae jg" href="https://hackernoon.com/the-law-of-demeter-in-the-era-of-microservices-3186f4c399a1" rel="noopener ugc nofollow" target="_blank">法则。如果违反了Demeter定律，那么您可以非常确定代码存在封装问题。然而，我知道，甚至不用看代码，只要看一下测试的结构就知道了。</a></p><p id="70fc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">此外，您可以猜测开发人员没有实践TDD，因为测试人员对实现的内部了解太多。只有在编写了产品代码之后再编写测试，这种情况才会发生。</p><p id="947d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果您知道测试是在实现之后编写的，那么您需要检查产品代码是否包含隐藏的特性，并且没有描述这些特性的测试。这真的很糟糕，你不能让它发生，因为你会对你的测试套件失去信任。在提交代码几个月后的某一天，你会重构它，甚至可能在没有注意到的情况下删除整个特性，因为没有描述该特性的测试用例。这真的很糟糕！</p><h1 id="9610" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">顺便说一下，测试也是代码</h1><p id="5cb6" class="pw-post-body-paragraph jh ji hu jj b jk ls jm jn jo lt jq jr js lu ju jv jw lv jy jz ka lw kc kd ke hn dt translated">测试是你拥有的消除对改变生产代码的恐惧的唯一工具。随着代码复杂性的增加(不管是不是偶然的)，您将重构代码，测试可以确保代码的行为是相同的。有一本<em class="kf">马丁·福勒</em>写的很棒的书叫<em class="kf"> </em> <a class="ae jg" href="https://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672" rel="noopener ugc nofollow" target="_blank"> <em class="kf">《重构:改进现有代码的设计》，</em> </a>你应该读一读！</p><p id="02cc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以花同样的时间，甚至更多的时间来确保你的测试总是处于良好状态。您需要代码审查和重构您的测试。测试应该遵循与生产代码相同的标准。</p></div><div class="ab cl lx ly hc lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hn ho hp hq hr"><h1 id="2815" class="ku kv hu bd kw kx me kz la lb mf ld le lf mg lh li lj mh ll lm ln mi lp lq lr dt translated">进一步阅读</h1><ol class=""><li id="e651" class="kg kh hu jj b jk ls jo lt js mj jw mk ka ml ke mm km kn ko dt translated"><a class="ae jg" href="http://blog.cleancoder.com/uncle-bob/2014/12/17/TheCyclesOfTDD.html" rel="noopener ugc nofollow" target="_blank">TDD的周期</a></li><li id="eff4" class="kg kh hu jj b jk kp jo kq js kr jw ks ka kt ke mm km kn ko dt translated"><a class="ae jg" href="https://hackernoon.com/the-law-of-demeter-in-the-era-of-microservices-3186f4c399a1" rel="noopener ugc nofollow" target="_blank">微服务时代的德米特里定律</a></li><li id="3426" class="kg kh hu jj b jk kp jo kq js kr jw ks ka kt ke mm km kn ko dt translated"><a class="ae jg" href="https://hackernoon.com/the-importance-of-team-culture-af6fffead7b5" rel="noopener ugc nofollow" target="_blank">团队文化的重要性</a></li><li id="c4f3" class="kg kh hu jj b jk kp jo kq js kr jw ks ka kt ke mm km kn ko dt translated"><a class="ae jg" href="https://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672" rel="noopener ugc nofollow" target="_blank">重构:改进现有代码的设计</a>作者<em class="kf">马丁·福勒</em>和<em class="kf">肯特·贝克</em></li></ol></div></div>    
</body>
</html>