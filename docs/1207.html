<html>
<head>
<title>Elixir console application with JSON parsing. Let’s print to console!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有JSON解析的Elixir控制台应用程序。让我们打印到控制台！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/elixir-console-application-with-json-parsing-lets-print-to-console-b701abf1cb14?source=collection_archive---------1-----------------------#2016-09-24">https://medium.com/hackernoon/elixir-console-application-with-json-parsing-lets-print-to-console-b701abf1cb14?source=collection_archive---------1-----------------------#2016-09-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="650e" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">使用HTTPoison、Poison和Escript进行维基百科搜索</h2></div><p id="e554" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">朋友们好。我一直在玩JSON解析，并在Elixir中从收到的地图中提取信息。我想我应该写一下，我也认为我们可以一起写一个非常简单的基于控制台的维基百科搜索应用程序。我们将在这个应用程序中使用几个十六进制软件包:</p><h2 id="a4ac" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">http poison</h2><p id="f643" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated"><em class="lf">“HTTP客户端为仙丹，基于</em><a class="ae lg" href="https://github.com/myfreeweb/httpotion" rel="noopener ugc nofollow" target="_blank"><em class="lf">HTTP药水</em></a><em class="lf">”<br/></em>我们需要一个HTTP客户端来连接维基百科的web API。</p><h2 id="d67b" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">毒药</h2><p id="2ff0" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">“一个令人难以置信的快速、纯粹的JSON库”<br/>一旦我们从维基百科的web API收集了JSON数据，我们就需要解析它。</p><h2 id="e623" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">描述</h2><p id="eb69" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">"生成可从命令行调用的可执行文件。escript可以在任何安装了Erlang的机器上运行，默认情况下不需要安装Elixir，因为Elixir是作为escript的一部分嵌入的。<br/>这样我们就可以像运行常规命令行应用程序一样运行我们的应用程序。</p><p id="2e28" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">好吧，让我们开始吧！</p><p id="0434" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">像往常一样，我们将从创建一个新项目开始。我将把我的应用程序称为“维基梦”:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="bd71" class="kf kg hu lm b fv lq lr l ls lt"><strong class="lm hv">~/</strong>$ mix new wiki_dream<br/>* creating README.md<br/>* creating .gitignore<br/>* creating mix.exs</span></pre><p id="1cd9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们将cd放入应用程序，并将依赖项添加到mix.exs文件中。因为HTTPoison运行在不同的进程上，所以我们需要将它添加到我们的应用程序函数中，以便它在我们启动应用程序时启动:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="3155" class="kf kg hu lm b fv lq lr l ls lt"># mix.exs<br/>......</span><span id="a4fe" class="kf kg hu lm b fv lu lr l ls lt">def application do<br/>  [applications: [:logger, :httpoison]]<br/>end</span><span id="4012" class="kf kg hu lm b fv lu lr l ls lt">defp deps do<br/>  [{:httpoison, “~&gt; 0.9.0”},<br/>  {:poison, “~&gt; 2.0”}]<br/>end</span></pre><p id="cded" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们将获取并安装我们添加的依赖项:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="7926" class="kf kg hu lm b fv lq lr l ls lt"><strong class="lm hv">~/wiki_dream</strong>$ mix deps.get<br/>Running dependency resolution<br/>Dependency resolution completed<br/>certifi: 0.4.0<br/>hackney: 1.6.1<br/>......</span></pre><p id="6bbc" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，让我们也像这样设置我们的文件夹结构:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="656a" class="kf kg hu lm b fv lq lr l ls lt">wiki_dream/ <br/>- lib/<br/>  — wiki_dream/<br/>    - cli.ex<br/>  - wiki_dream.ex</span></pre><p id="b758" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你看上面的结构，你还会注意到我添加了一个新文件，cli.ex. Perfect，都设置好了。我们开始工作吧。</p><h2 id="0f5e" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">我们的应用程序将如何运行:</h2><ul class=""><li id="d15c" class="lv lw hu jl b jm la jp lb js lx jw ly ka lz ke ma mb mc md dt translated">从我们的控制台处理给定的参数</li><li id="ec64" class="lv lw hu jl b jm me jp mf js mg jw mh ka mi ke ma mb mc md dt translated">从维基百科获取数据</li><li id="9535" class="lv lw hu jl b jm me jp mf js mg jw mh ka mi ke ma mb mc md dt translated">解析提取的数据</li><li id="c1ac" class="lv lw hu jl b jm me jp mf js mg jw mh ka mi ke ma mb mc md dt translated">从数据中提取我们想要的信息</li><li id="baa0" class="lv lw hu jl b jm me jp mf js mg jw mh ka mi ke ma mb mc md dt translated">把数据打印到我们的控制台</li></ul><h1 id="e94a" class="mj kg hu bd kh mk ml mm kl mn mo mp kp ja mq jb ks jd mr je kv jg ms jh ky mt dt translated">从我们的控制台处理给定的参数</h1><p id="f426" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">我们的cli.ex文件将处理来自控制台的输入。如果您还不知道，CLI代表“命令行界面”，是基于控制台的应用程序的前端。因为我们正在用escript构建一个可执行的应用程序，所以我们的第一个函数将是main/1。这是escript所要求的:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="83a1" class="kf kg hu lm b fv lq lr l ls lt"># lib/wiki_dream/cli.ex</span><span id="09b9" class="kf kg hu lm b fv lu lr l ls lt">defmodule WikiDream.CLI do<br/>  def main(args) do<br/>    parse_args(args)<br/>    |&gt; process<br/>  end<br/>end</span></pre><p id="391d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们还添加了一个函数parse_args/1，这个函数我们还没有定义。该函数将调用内置的<a class="ae lg" href="http://elixir-lang.org/docs/stable/elixir/OptionParser.html" rel="noopener ugc nofollow" target="_blank"> OptionParser模块</a>，该模块包含解析命令行选项的函数。process/1函数将包含我们的应用程序的不同步骤:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="87d7" class="kf kg hu lm b fv lq lr l ls lt"># lib/wiki_dream/cli.ex <br/>......</span><span id="6670" class="kf kg hu lm b fv lu lr l ls lt">def parse_args(args) do<br/>  parse = OptionParser.parse(args, switches: [help: :boolean], <br/>                             aliases: [h: :help])</span><span id="5cd2" class="kf kg hu lm b fv lu lr l ls lt">  case parse do<br/>    {[help: true], _, _}<br/>      -&gt; :help<br/>    {_, [search_term], _}<br/>      -&gt; {search_term}<br/>  end<br/>end</span></pre><p id="433d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">OptionParser将接受我们给它的任何参数，并将其放入我们的parse变量。它还会寻找帮助或-h标志。我们将添加一个case结构，如果给出了一个帮助标志，它将返回atom :help，或者以一个元素元组的形式返回我们的搜索词。让我们看看是否能让我们的控制台打印一些东西。我们将编写一个非常简单的流程函数，看看它是否有效:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="05da" class="kf kg hu lm b fv lq lr l ls lt"># lib/wiki_dream/cli.ex<br/>......</span><span id="eadc" class="kf kg hu lm b fv lu lr l ls lt">def process({search_term}) do<br/>  IO.inspect search_term<br/>end</span></pre><p id="15eb" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，要将我们的应用程序作为可执行文件运行，我们需要用escript构建它。为此，我们需要将它添加到我们的mix.exs文件中，并赋予它我们的主模块(main/1函数所在的模块):</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="63ea" class="kf kg hu lm b fv lq lr l ls lt"># mix.exs<br/>......</span><span id="3b6c" class="kf kg hu lm b fv lu lr l ls lt">def project do<br/>  [app: :wiki_dream,<br/>  version: “0.1.0”,<br/>  elixir: “~&gt; 1.3”,<br/>  build_embedded: Mix.env == :prod,<br/>  start_permanent: Mix.env == :prod,<br/>  escript: [main_module: WikiDream.CLI], #Added escript<br/>  deps: deps()]<br/>end</span><span id="b50e" class="kf kg hu lm b fv lu lr l ls lt">......</span></pre><p id="f199" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在我们的控制台中，我们将使用mix来构建它:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="711c" class="kf kg hu lm b fv lq lr l ls lt"><strong class="lm hv">~/wiki_dream</strong>$ mix escript.build<br/>===&gt; Compiling idna<br/>===&gt; Compiling mimerl<br/>......<br/>Generated httpoison app<br/>==&gt; wiki_dream<br/>Compiling 2 files (.ex)<br/>Generated wiki_dream app<br/>Generated escript wiki_dream with MIX_ENV=dev</span></pre><p id="e606" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们试着运行它，给它一个参数:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="1485" class="kf kg hu lm b fv lq lr l ls lt"><strong class="lm hv">~/wiki_dream</strong>$ ./wiki_dream hello<br/>“hello”</span></pre><p id="9c8d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">太棒了。有用！现在，如果我们给它一个帮助标志会发生什么？</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="e1fd" class="kf kg hu lm b fv lq lr l ls lt"><strong class="lm hv">~/wiki_dream</strong>$ ./wiki_dream --help<br/>** (FunctionClauseError) no function clause matching in WikiDream.CLI.process/1<br/>(wiki_dream) lib/wiki_dream/cli.ex:18: WikiDream.CLI.process(:help)<br/>(elixir) lib/kernel/cli.ex:76: anonymous fn/3 in Kernel.CLI.exec_fun/2</span></pre><p id="4eb4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">它爆炸了。不出所料，因为我们还没有编写任何函数来处理它。让我们接下来这样做:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="542f" class="kf kg hu lm b fv lq lr l ls lt"># lib/wiki_dream/cli.ex<br/>......</span><span id="df1e" class="kf kg hu lm b fv lu lr l ls lt">def process(:help) do<br/>  IO.puts “””<br/>  Wiki Dream<br/>  — — — — — <br/>  usage: wiki_dream &lt;search_term&gt;<br/>  example: wiki_dream lion<br/>  “””<br/>end</span></pre><p id="e49c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们将再次构建我们的可执行文件，看看它是否有效:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="fab5" class="kf kg hu lm b fv lq lr l ls lt"><strong class="lm hv">~/wiki_dream</strong>$ ./wiki_dream --help<br/>Wiki Dream<br/>— — — — — <br/>usage: wiki_dream &lt;search_term&gt;<br/>example: wiki_dream lion</span></pre><p id="7066" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">厉害！我们已经得到了控制台参数解析工作！</p><h1 id="1a36" class="mj kg hu bd kh mk ml mm kl mn mo mp kp ja mq jb ks jd mr je kv jg ms jh ky mt dt translated">从维基百科获取数据</h1><p id="d8fd" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">现在我们将使用HTTPoison。我们需要访问维基百科的API并获取一些JSON数据。如果我们给出“长生不老药”作为参数，我们将从Wikipedia的长生不老药文章中接收JSON数据。现在，维基百科不允许从他们的网页上抓取文章，所以从<a class="ae lg" href="https://en.wikipedia.org/wiki/Lion" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/E</a>lixir那里获取信息是行不通的。但是，如果浏览他们的API，</p><p id="e854" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><a class="ae lg" href="https://en.wikipedia.org/w/api.php?format=json&amp;action=query&amp;prop=extracts&amp;exintro=&amp;explaintext=&amp;titles=elixir" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/w/api.php?format=json&amp;action = query&amp;prop = extracts&amp;exin tro =&amp;explain text =&amp;titles =仙丹</a></p><p id="5af7" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">维基百科会给我们一个JSON文件，里面有我们需要的所有东西。我们将创建一个新的文件和模块json_fetch.ex，它将处理获取和解析接收到的json。首先，我们将从process/1中移除IO.inspect，并让它调用我们尚未编写的fetch/1函数:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="c0df" class="kf kg hu lm b fv lq lr l ls lt"># lib/wiki_dream/cli.ex<br/>......</span><span id="dbd2" class="kf kg hu lm b fv lu lr l ls lt">def process({search_term}) do<br/>  WikiDream.JSONFetch.fetch(search_term)<br/>end<br/>......</span></pre><p id="8bb0" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在我们新的fetch_json.ex文件中:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="43aa" class="kf kg hu lm b fv lq lr l ls lt"># lib/wiki_dream/fetch_json.ex</span><span id="6ba1" class="kf kg hu lm b fv lu lr l ls lt">defmodule WikiDream.JSONFetch do<br/>  def fetch(search_term) do<br/>    wiki_url(search_term)<br/>    |&gt; HTTPoison.get<br/>    |&gt; IO.inspect<br/>  end</span><span id="4dc0" class="kf kg hu lm b fv lu lr l ls lt">  defp wiki_url(search_term) do<br/>    “<a class="ae lg" href="https://en.wikipedia.org/w/api.php?format=json&amp;action=query&amp;prop=extracts&amp;exintro=&amp;explaintext=&amp;titles=#{search_term" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/w/api.php? format=json&amp;action=query&amp;prop=extracts&amp;exintro=&amp;explaintext=&amp;titles= #{search_term</a>}"<br/>  end<br/>end</span></pre><p id="10de" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了减少fetch/1函数的噪声，我添加了一个带有Wikipedia API URL的私有函数。请注意URL中的字符串插值。</p><p id="0ff9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后，我们通过HTTPoison用管道将我们的URL与搜索词连接起来。我添加了一个IO.inspect，这样我们可以在终端中看到输出。构建新的脚本并启动我们的应用程序:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="63be" class="kf kg hu lm b fv lq lr l ls lt"><strong class="lm hv">~/wiki_dream</strong>$ ./wiki_dream elixir<br/>{:ok, %HTTPoison.Response{body: “{\”batchcomplete\”:\”\”,\”query\”:{\”normalized\”:[{\”from\”:\”elixir\”,\”to\”:\”Elixir\”}],\”pages\”:{\”457424\”:{\”pageid\”:457424,\”ns\”:0,\”title\”:\”Elixir\”,\”extract\”:\”An elixir (from Arabic: \\u0627\\u0644\\u0625\\u06................</span></pre><p id="18fd" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">很好，我们收到噪音了！如果您查看输出，您会发现一个元组，它返回:ok(这很好！)，还有一大堆其他数据。(正文和页眉)。如果我们观察身体，我们可以看到维基百科关于长生不老药(一种液体，不是我们的语言)的文章中的字符串。</p><h1 id="ba8d" class="mj kg hu bd kh mk ml mm kl mn mo mp kp ja mq jb ks jd mr je kv jg ms jh ky mt dt translated">解析提取的数据</h1><p id="3005" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">我们将使用我们安装的第二个依赖项Poison来处理和提取我们获取的数据体:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="f455" class="kf kg hu lm b fv lq lr l ls lt"># lib/wiki_dream/json_fetch.ex<br/>......</span><span id="1f3d" class="kf kg hu lm b fv lu lr l ls lt">def handle_json({:ok, %{status_code: 200, body: body}}) do<br/>  {:ok, Poison.Parser.parse!(body)}<br/>end<br/>def handle_json({_, %{status_code: _, body: body}}) do<br/>  IO.puts “Something went wrong. Please check your internet <br/>           connection”<br/>end</span><span id="e9f2" class="kf kg hu lm b fv lu lr l ls lt">......</span></pre><p id="4332" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，我们有两个handle_json/1函数，一个用atom :ok处理一个元组，用status_code: 200处理一个map，另一个处理所有其他的事情。我们的第一个handle_json/1函数将返回一个带有:ok的tuple和一个带有主体的map。另一个将返回我们的错误。</p><p id="519b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们将handle_json/1添加到fetch/1函数中:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="5543" class="kf kg hu lm b fv lq lr l ls lt"># lib/wiki_dream/json_fetch.ex</span><span id="8b86" class="kf kg hu lm b fv lu lr l ls lt">def fetch(search_term) do<br/>  wiki_url(search_term)<br/>  |&gt; HTTPoison.get<br/>  |&gt; handle_json<br/>  |&gt; IO.inspect<br/>end</span><span id="dc9b" class="kf kg hu lm b fv lu lr l ls lt">......</span></pre><p id="1afb" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">构建脚本，并运行应用程序:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="8cac" class="kf kg hu lm b fv lq lr l ls lt"><strong class="lm hv">~/wiki_dream</strong>$ ./wiki_dream elixir<br/>{:ok,<br/>%{“batchcomplete” =&gt; “”,<br/>“query” =&gt; %{“normalized” =&gt; [%{“from” =&gt; “elixir”, “to” =&gt; “Elixir”}],<br/>“pages” =&gt; %{“457424” =&gt; %{“extract” =&gt; “An elixir (from Arabic: الإكسير — al-’iksīr) is a clear, sweet-flavored liquid used for medicinal purposes, to be taken orally and intended to cure one’s illness. When used as a pharmaceutical preparation, an elixir contains at least one active ingredient designed to be taken orally.”,“ns” =&gt; 0, “pageid” =&gt; 457424, “title” =&gt; “Elixir”}}}}}</span></pre><p id="c38e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">太好了。一切都如预期的那样。我们收到了一个带有:ok的元组和一个带有主体的地图。现在，继续删除fetch/1，IO.inspect中的行，因为我们不再需要它了。</p><h1 id="a71a" class="mj kg hu bd kh mk ml mm kl mn mo mp kp ja mq jb ks jd mr je kv jg ms jh ky mt dt translated">从数据中提取我们想要的信息</h1><p id="4f2f" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">现在，如果您看一看接收到的数据，您会注意到我们正在寻找的信息是键“extract”的值。我们需要在这张地图中找出路，并获取“extract”的值。</p><p id="d666" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们将从创建一个新文件extract_map.ex开始，该文件将包含我们将用作挖掘工具的函数:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="7875" class="kf kg hu lm b fv lq lr l ls lt"># lib/wiki_dream/extract_map.ex</span><span id="748e" class="kf kg hu lm b fv lu lr l ls lt">defmodule WikiDream.ExtractMap do<br/>  def extract_from_body(map) do<br/>    {:ok, body} = map<br/>    IO.inspect body<br/>  end<br/>end</span></pre><p id="9ddd" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这里，我们很好地利用了模式匹配。如前所述，我们的数据现在是一个带有:ok原子和映射的元组。我们对元组和主体进行模式匹配，并将主体存储在名为body的变量中。我们将添加一个IO.inspect来查看数据输出。<br/>我们还需要将这个函数添加到我们的process/1函数中:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="7987" class="kf kg hu lm b fv lq lr l ls lt"># lib/wiki_dream/cli.ex<br/>......</span><span id="b7c5" class="kf kg hu lm b fv lu lr l ls lt">def process({search_term}) do<br/>  WikiDream.JSONFetch.fetch(search_term)<br/>  |&gt; WikiDream.ExtractMap.extract_from_body<br/>end</span><span id="af3a" class="kf kg hu lm b fv lu lr l ls lt">......</span></pre><p id="bd00" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们将构建并运行我们的应用程序:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="2a71" class="kf kg hu lm b fv lq lr l ls lt"><strong class="lm hv">~/wiki_dream</strong>$ ./wiki_dream elixir<br/>%{"batchcomplete" =&gt; "",<br/>"query" =&gt; %{"normalized" =&gt; [%{"from" =&gt; "elixir", "to" =&gt; "Elixir"}],<br/>"pages" =&gt; %{"457424" =&gt; %{"extract" =&gt; "An elixir (from Arabic: الإكسير - al-'iksīr) is a clear, sweet-flavored liquid used for medicinal purposes, to be taken orally and intended to cure one's illness. When used as a pharmaceutical preparation, an elixir contains at least one active ingredient designed to be taken orally.", "ns" =&gt; 0, "pageid" =&gt; 457424, "title" =&gt; "Elixir"}}}}</span></pre><p id="40d0" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">酷毙了。元组不见了，因为我们要求只检查其中的映射。现在，如果你用不同的参数运行应用程序，你会注意到除了页码(整数串)之外的每个键都是静态的，固定的，不会改变。我们可以使用一个内置的Elixir函数(get_in/2)来为我们做一些繁重的工作。</p><blockquote class="mu mv mw"><p id="5dc0" class="jj jk lf jl b jm jn iv jo jp jq iy jr mx jt ju jv my jx jy jz mz kb kc kd ke hn dt translated"><a class="ae lg" href="http://elixir-lang.org/docs/master/elixir/Kernel.html#get_in/2" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hv"> get_in(data，keys) </strong> </a> <strong class="jl hv"> <br/> </strong> <em class="hu">从嵌套结构中获取值<br/> / Elixir documentation </em></p></blockquote><p id="51b0" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们需要深入挖掘“查询”、“页数”、“页码”和“摘录”。前两个键应该很容易，因为它们不会改变。<br/>让我们试一试:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="3f83" class="kf kg hu lm b fv lq lr l ls lt"># lib/wiki_dream/extract_map.ex<br/>......</span><span id="6f74" class="kf kg hu lm b fv lu lr l ls lt">def extract_from_body(map) do<br/>  {:ok, body} = map</span><span id="1923" class="kf kg hu lm b fv lu lr l ls lt">  extract_article = get_in(body, ["query"])<br/>  |&gt; get_in(["pages"])<br/>  IO.inspect extract_article<br/>end</span><span id="c513" class="kf kg hu lm b fv lu lr l ls lt">......</span></pre><p id="6127" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，我们从“查询”键获得值，这使我们能够访问“页面”键。让我们看看“pages”键里面有什么:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="8cd3" class="kf kg hu lm b fv lq lr l ls lt"><strong class="lm hv">~/wiki_dream</strong>$ ./wiki_dream elixir<br/>%{“457424” =&gt; %{“extract” =&gt; “An elixir (from Arabic: الإكسير — al-’iksīr) is a clear, sweet-flavored liquid used for medicinal purposes, to be taken orally and intended to cure one’s illness. When used as a pharmaceutical preparation, an elixir contains at least one active ingredient designed to be taken orally.”,<br/>“ns” =&gt; 0, “pageid” =&gt; 457424, “title” =&gt; “Elixir”}}</span></pre><p id="6a33" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">干得好。我们挖到了页码。我们离“提取”键越来越近了。现在，我们的下一个目标比之前的稍微复杂一点。关键字名称将根据文章的页码而变化。然而，键名总是一个整数，所以我们可以为此写一个函数。</p><blockquote class="mu mv mw"><p id="f3d2" class="jj jk lf jl b jm jn iv jo jp jq iy jr mx jt ju jv my jx jy jz mz kb kc kd ke hn dt translated"><strong class="jl hv">枚举。</strong> <a class="ae lg" href="http://elixir-lang.org/docs/stable/elixir/Enum.html#find/3" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hv"> find(enumerable，default \\ nil，fun)</strong></a><strong class="jl hv"><br/></strong><em class="hu">返回fun返回真值的第一个项目。如果没有找到这样的项目，则返回默认的<br/> /酏剂文档</em></p></blockquote><p id="78e1" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们将使用Enum.find返回第一个整数键。因为只有一个键，而且这个键是一个整数，我们应该可以更进一步:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="976d" class="kf kg hu lm b fv lq lr l ls lt"># lib/wiki_dream/extract_map.ex</span><span id="6ba4" class="kf kg hu lm b fv lu lr l ls lt">def extract_from_body(map) do<br/>  {:ok, body} = map</span><span id="ff14" class="kf kg hu lm b fv lu lr l ls lt">  extract_article = get_in(body, [“query”])<br/>  |&gt; get_in([“pages”])<br/>  |&gt; Enum.find(fn {key, _value} -&gt;<br/>       case Integer.parse(key) do<br/>         :error -&gt; false<br/>         _ -&gt; key<br/>       end<br/>     end)<br/>  |&gt; IO.inspect<br/>end</span></pre><blockquote class="mu mv mw"><p id="6cab" class="jj jk lf jl b jm jn iv jo jp jq iy jr mx jt ju jv my jx jy jz mz kb kc kd ke hn dt translated"><strong class="jl hv">整数。</strong> <a class="ae lg" href="http://elixir-lang.org/docs/stable/elixir/Integer.html#parse/2" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hv"> parse(binary，base \ \ 10)</strong></a><strong class="jl hv"><br/></strong><em class="hu">解析一个整数的文本表示<br/> / Elixir文档</em></p></blockquote><p id="32a0" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以我们使用Integer.parse来查找一个整数的文本表示的键。如果存在，我们返回密钥，如果不存在，我们返回false。</p><p id="811f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果我们运行我们的程序，我们将收到一个元组，其中页码作为第一个元素，其余的映射作为第二个元素。我们不再关心页码，所以我们将做更多的模式匹配来获得“extract”键。然后我们将使用Map.fetch！/2从“extract”键获取值:</p><blockquote class="mu mv mw"><p id="b0ab" class="jj jk lf jl b jm jn iv jo jp jq iy jr mx jt ju jv my jx jy jz mz kb kc kd ke hn dt translated"><strong class="jl hv">地图。</strong> <a class="ae lg" href="http://elixir-lang.org/docs/stable/elixir/Map.html#fetch!/2" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hv">取回来！(map，key)</strong></a><strong class="jl hv"><br/></strong><em class="hu">获取特定键<br/> /药剂文档</em>的值</p></blockquote><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="38e3" class="kf kg hu lm b fv lq lr l ls lt"># lib/wiki_dream/extract_map.ex</span><span id="a78e" class="kf kg hu lm b fv lu lr l ls lt">def extract_from_body(map) do<br/>  {:ok, body} = map</span><span id="c518" class="kf kg hu lm b fv lu lr l ls lt">  extract_article = get_in(body, [“query”])<br/>  |&gt; get_in([“pages”])<br/>  |&gt; Enum.find(fn {key, _value} -&gt;<br/>       case Integer.parse(key) do<br/>         :error -&gt; false<br/>         _ -&gt; key<br/>       end<br/>     end)</span><span id="c6bf" class="kf kg hu lm b fv lu lr l ls lt">  {_, extract_article_content} = extract_article<br/>  Map.fetch!(extract_article_content, “extract”)<br/>end</span></pre><h1 id="5ad4" class="mj kg hu bd kh mk ml mm kl mn mo mp kp ja mq jb ks jd mr je kv jg ms jh ky mt dt translated">把数据打印到我们的控制台</h1><p id="1ed2" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">我的朋友，我们已经走了很长一段路了。我们现在搜索数据，接收数据，解析数据，从数据中提取信息。现在，我们需要将数据打印到控制台。让我们从IO.inspect开始，看看我们得到了什么:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="2184" class="kf kg hu lm b fv lq lr l ls lt"># lib/wiki_dream/cli.ex<br/>......</span><span id="f3a3" class="kf kg hu lm b fv lu lr l ls lt">def process({search_term}) do<br/>  WikiDream.JSONFetch.fetch(search_term)<br/>  |&gt; WikiDream.ExtractMap.extract_from_body<br/>  |&gt; IO.inspect<br/>end</span><span id="a14b" class="kf kg hu lm b fv lu lr l ls lt">......</span></pre><p id="e44f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">构建并运行:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="d813" class="kf kg hu lm b fv lq lr l ls lt"><strong class="lm hv">~/wiki_dream</strong>$ ./wiki_dream elixir<br/>“An elixir (from Arabic: الإكسير — al-’iksīr) is a clear, sweet-flavored liquid used for medicinal purposes, to be taken orally and intended to cure one’s illness. When used as a pharmaceutical preparation, an elixir contains at least one active ingredient designed to be taken orally.”</span></pre><p id="2bb7" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们输出文章内容的字符串。这正是我们想要的！既然是字符串，我们就真的不需要再用IO.inspect了。我们可以使用IO.puts来输出字符串。让我们也使用一些非常简单的字符串格式，在每个句点处换行:</p><blockquote class="mu mv mw"><p id="2fb0" class="jj jk lf jl b jm jn iv jo jp jq iy jr mx jt ju jv my jx jy jz mz kb kc kd ke hn dt translated"><strong class="jl hv">弦。</strong> <a class="ae lg" href="http://elixir-lang.org/docs/stable/elixir/String.html#replace/4" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hv"> replace(subject，pattern，replacement，options \ \[])</strong></a><strong class="jl hv"><br/></strong><em class="hu">返回用replacement<br/>/Elixir documentation</em>替换主题中出现的模式所创建的新字符串</p></blockquote><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="2ff9" class="kf kg hu lm b fv lq lr l ls lt"># lib/wiki_dream/cli.ex<br/>......</span><span id="7338" class="kf kg hu lm b fv lu lr l ls lt">def process({search_term}) do<br/>  WikiDream.JSONFetch.fetch(search_term)<br/>  |&gt; WikiDream.ExtractMap.extract_from_body<br/>  |&gt; string_format<br/>end</span><span id="d48a" class="kf kg hu lm b fv lu lr l ls lt">......</span><span id="dca3" class="kf kg hu lm b fv lu lr l ls lt">def string_format(string) do<br/>  String.replace(string, “. “, “. \n”)<br/>  |&gt; IO.puts<br/>end</span><span id="a6e5" class="kf kg hu lm b fv lu lr l ls lt">......</span></pre><p id="1c2b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">构建并运行:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="cb93" class="kf kg hu lm b fv lq lr l ls lt"><strong class="lm hv">~/wiki_dream</strong>$ ./wiki_dream elixir<br/>An elixir (from Arabic: الإكسير — al-’iksīr) is a clear, sweet-flavored liquid used for medicinal purposes, to be taken orally and intended to cure one’s illness.<br/>When used as a pharmaceutical preparation, an elixir contains at least one active ingredient designed to be taken orally.</span></pre><p id="d35a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">仅此而已。一个非常无用的JSON解析、地图挖掘CLI应用程序！</p><p id="9cdd" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当然，还可以添加其他字符串格式来使应用程序看起来更好，但是这超出了本文的范围。</p><p id="bea9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">可能有更简单或不同的方法来做到这一点。然而，我发现这种方法对我很有效。我还认为它清楚地展示了函数式编程是如何工作的。其中不同的函数一个接一个地修改数据，直到得到想要的结果。我们没有改变我们开始时的原始数据，我们只是拿走它，复制它，沿途修改它，最后得到完全不同的东西。</p><p id="3e69" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Escript可执行文件的酷之处在于，整个应用程序及其所有依赖项和代码都在这个文件中。如果您将它移到应用程序文件夹之外并运行它，它仍然可以工作。您甚至可以在不同的计算机上运行它，只要该计算机安装了Erlang。</p><p id="11df" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">目前就这些。</p><p id="7d4d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">下次再见斯蒂芬·巴克伦德·瓦卢瓦</p><blockquote class="mu mv mw"><p id="f3f7" class="jj jk lf jl b jm jn iv jo jp jq iy jr mx jt ju jv my jx jy jz mz kb kc kd ke hn dt translated"><a class="ae lg" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae lg" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae lg" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae lg" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="jj jk lf jl b jm jn iv jo jp jq iy jr mx jt ju jv my jx jy jz mz kb kc kd ke hn dt translated">要了解更多信息，<a class="ae lg" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">请阅读我们的“关于”页面</a>、<a class="ae lg" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae lg" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="jj jk lf jl b jm jn iv jo jp jq iy jr mx jt ju jv my jx jy jz mz kb kc kd ke hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lg" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lg" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>