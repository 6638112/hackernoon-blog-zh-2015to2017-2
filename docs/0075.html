<html>
<head>
<title>Writing a Blog Engine in Phoenix and Elixir: Part 3, Adding Roles to our Models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Phoenix和Elixir编写博客引擎:第3部分，向模型添加角色</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/writing-a-blog-engine-in-phoenix-and-elixir-part-3-adding-roles-to-our-models-3be45a4afe4b?source=collection_archive---------0-----------------------#2015-10-20">https://medium.com/hackernoon/writing-a-blog-engine-in-phoenix-and-elixir-part-3-adding-roles-to-our-models-3be45a4afe4b?source=collection_archive---------0-----------------------#2015-10-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="21ba" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">最新更新:</strong>2016年7月21日</p><h2 id="d3bd" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">本系列的前一篇文章</h2><div class="kk kl fm fo km kn"><a rel="noopener follow" target="_blank" href="/@diamondgfx/writing-a-blog-engine-in-phoenix-part-2-authorization-814c06fa7c0"><div class="ko ab ej"><div class="kp ab kq cl cj kr"><h2 class="bd hv fv z el ks eo ep kt er et ht dt translated">用Phoenix和Elixir编写博客引擎:第2部分，授权</h2><div class="ku l"><h3 class="bd b fv z el ks eo ep kt er et ek translated">最后更新时间:2016年7月21日</h3></div><div class="kv l"><p class="bd b gc z el ks eo ep kt er et ek translated">medium.com</p></div></div></div></a></div><h2 id="6fc3" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">当前版本</h2><p id="5ffb" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">在撰写本文时，我们应用程序的当前版本是:</p><ul class=""><li id="fe99" class="lb lc hu it b iu iv iy iz jc ld jg le jk lf jo lg lh li lj dt translated"><strong class="it hv">仙丹</strong> : v1.3.1</li><li id="4a40" class="lb lc hu it b iu lk iy ll jc lm jg ln jk lo jo lg lh li lj dt translated"><strong class="it hv">凤凰:</strong> v1.2.0</li><li id="9475" class="lb lc hu it b iu lk iy ll jc lm jg ln jk lo jo lg lh li lj dt translated"><strong class="it hv"> Ecto: </strong> v2.0.2</li><li id="dcb3" class="lb lc hu it b iu lk iy ll jc lm jg ln jk lo jo lg lh li lj dt translated"><strong class="it hv">康美宁:</strong> v2.5.2</li></ul><p id="c085" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你正在读这篇文章，而这些不是最新的，请告诉我，我会相应地更新这篇教程。</p><h2 id="8b97" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">我们离开的地方</h2><p id="79d9" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">当我们最后一次停止时，我们完成了我们的帖子与用户的关联，并开始适当地限制对帖子的访问，除非我们有有效的用户(并且用户首先创建了帖子)，但是如果我们想要有多个用户呢？我们希望用理智的用户规则来控制事情，这样我们就不会出现某个流氓用户突然删除所有人的账户或帖子的情况。我们将用一个相当标准的解决方案来解决这个问题:创建角色。</p></div><div class="ab cl lp lq hc lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hn ho hp hq hr"><h2 id="d7a5" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">创建角色</h2><p id="e86a" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">我们将从在终端中运行以下命令开始:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="5b4d" class="jp jq hu mb b fv mf mg l mh mi">$ mix phoenix.gen.model Role roles name:string admin:boolean</span></pre><p id="8907" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们应该会看到类似于下面的输出:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="e420" class="jp jq hu mb b fv mf mg l mh mi">* creating web/models/role.ex<br/>* creating test/models/role_test.exs<br/>* creating priv/repo/migrations/20160721151158_create_role.exs</span><span id="2518" class="jp jq hu mb b fv mj mg l mh mi">Remember to update your repository by running migrations:</span><span id="8d53" class="jp jq hu mb b fv mj mg l mh mi">$ mix ecto.migrate</span></pre><p id="eb72" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将按照脚本的建议，立即运行<strong class="it hv"> mix ecto.migrate </strong>。假设我们的数据库已经正确设置，我们应该看到类似如下的输出:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="95be" class="jp jq hu mb b fv mf mg l mh mi">Compiling 21 files (.ex)<br/>Generated pxblog app</span><span id="ca6f" class="jp jq hu mb b fv mj mg l mh mi">11:12:04.736 [info]  == Running Pxblog.Repo.Migrations.CreateRole.change/0 forward</span><span id="a4a2" class="jp jq hu mb b fv mj mg l mh mi">11:12:04.736 [info]  create table roles</span><span id="6e81" class="jp jq hu mb b fv mj mg l mh mi">11:12:04.742 [info]  == Migrated in 0.0s</span></pre><p id="8c6a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还将运行混合测试来检查我们的新模型添加没有干扰任何其他测试。如果一切正常，那么我们就可以继续修改我们的用户模型，关联一个相关的角色。</p><h2 id="7abe" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">添加角色关联</h2><p id="d845" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">对于这个特定的特性实现，我遵循的一般设计是每个用户有一个角色，每个角色有多个用户，因此我们将修改<strong class="it hv"> web/models/user.ex </strong>文件来反映这一点:</p><p id="ed69" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在模式“users”do部分，我们将添加下面一行:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="3b0c" class="jp jq hu mb b fv mf mg l mh mi">belongs_to :role, Pxblog.Role</span></pre><p id="a20b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本例中，我们将把role_id外键放在Users表上，所以我们想说一个用户“属于”一个角色。我们还将打开<strong class="it hv"> web/models/role.ex </strong>并通过添加以下行来更改模式“roles”do部分:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="b2f8" class="jp jq hu mb b fv mf mg l mh mi">has_many :users, Pxblog.User</span></pre><p id="e324" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，我们将再次运行混合测试，但我们应该会遇到许多失败。我们告诉Ecto，我们的users表与roles表有关系，但是我们从未在数据库中定义过，所以我们必须修改users表来保存对role_id的引用。</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="a2b4" class="jp jq hu mb b fv mf mg l mh mi">$ mix ecto.gen.migration add_role_id_to_users</span><span id="e84f" class="jp jq hu mb b fv mj mg l mh mi">Compiling 5 files (.ex)<br/>* creating priv/repo/migrations<br/>* creating priv/repo/migrations/20160721184919_add_role_id_to_users.exs</span></pre><p id="5fd6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们打开它创建的迁移文件。默认情况下，它将包含:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="9848" class="jp jq hu mb b fv mf mg l mh mi">defmodule Pxblog.Repo.Migrations.AddRoleIdToUsers do<br/>  use Ecto.Migration</span><span id="8a58" class="jp jq hu mb b fv mj mg l mh mi">  def change do<br/>  end<br/>end</span></pre><p id="7fbb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们需要补充一些东西。第一件事是我们需要改变users表来添加对角色的引用，所以我们将用下面的代码来做这件事:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="2e3f" class="jp jq hu mb b fv mf mg l mh mi">alter table(:users) do<br/>  add :role_id, references(:roles)<br/>end</span></pre><p id="3c36" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们应该为role_id添加一个索引，因此我们将添加下面一行:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="afec" class="jp jq hu mb b fv mf mg l mh mi">create index(:users, [:role_id])</span></pre><p id="7666" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我们将再次运行<strong class="it hv"> mix ecto.migrate </strong>，应该会看到一切都成功迁移了！如果我们现在运行我们的测试，一切应该又变绿了！不幸的是，我们的测试并不完美。首先，我们从来没有修改过Post/User模型的测试，以确保一个Post必须有一个用户定义。同样，当用户没有角色时，我们也不希望能够创建用户。在<strong class="it hv"> web/models/user.ex </strong>中，我们将changeset函数改为如下所示(注意<strong class="it hv">的两个附加项:role_id </strong>):</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="f439" class="jp jq hu mb b fv mf mg l mh mi">def changeset(struct, params \\ %{}) do<br/>    struct<br/>    |&gt; cast(params, [:username, :email, :password, :password_confirmation, :role_id])<br/>    |&gt; validate_required([:username, :email, :password, :password_confirmation, :role_id])<br/>    |&gt; hash_password<br/>  end</span></pre><h2 id="ed7d" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">创建测试助手</h2><p id="c353" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">现在运行我们的测试会导致很多失败，但是没关系！我们将做大量的工作来清理我们的测试，我们需要的东西之一是某种测试助手，以避免我们不得不一遍又一遍地编写相同的代码。我们将创建一个新文件来帮助我们构建这些模型。创建<strong class="it hv">test/support/test _ helper . ex</strong>并用以下代码填充它:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="276e" class="jp jq hu mb b fv mf mg l mh mi">defmodule Pxblog.TestHelper do<br/>  alias Pxblog.Repo<br/>  alias Pxblog.User<br/>  alias Pxblog.Role<br/>  alias Pxblog.Post</span><span id="c1b9" class="jp jq hu mb b fv mj mg l mh mi">  import Ecto, only: [build_assoc: 2]</span><span id="f98c" class="jp jq hu mb b fv mj mg l mh mi">  def create_role(%{name: name, admin: admin}) do<br/>    Role.changeset(%Role{}, %{name: name, admin: admin})<br/>    |&gt; Repo.insert<br/>  end</span><span id="fde1" class="jp jq hu mb b fv mj mg l mh mi">  def create_user(role, %{email: email, username: username, password: password, password_confirmation: password_confirmation}) do<br/>    role<br/>    |&gt; build_assoc(:users)<br/>    |&gt; User.changeset(%{email: email, username: username, password: password, password_confirmation: password_confirmation})<br/>    |&gt; Repo.insert<br/>  end</span><span id="e155" class="jp jq hu mb b fv mj mg l mh mi">  def create_post(user, %{title: title, body: body}) do<br/>    user<br/>    |&gt; build_assoc(:posts)<br/>    |&gt; Post.changeset(%{title: title, body: body})<br/>    |&gt; Repo.insert<br/>  end<br/>end</span></pre><p id="3b01" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们继续修正我们的测试之前，让我们讨论一下这个文件在做什么。首先要注意的是我们放置文件的位置:<strong class="it hv"> test/support </strong>，在这里我们可以放置任何我们希望对我们的测试套件可用的模块。我们仍然需要在每个文件中对这些文件进行别名引用，但是没关系！</p><p id="ab47" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们首先别名化我们的Repo、User、Role和Post模块，这样我们可以用更短的语法访问它们，我们还<strong class="it hv">导入Ecto </strong>以便我们可以访问<strong class="it hv"> build_assoc </strong>方法来构建关联。</p><p id="12bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在create_role中，我们期望一个映射包含一个角色名称以及它是否是管理员。我们在这里使用Repo.insert，这意味着我们将对成功的插入返回标准的<strong class="it hv"> {:ok，model} </strong>响应。否则，它只是一个角色变更集的简单插入。</p><p id="ea54" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<strong class="it hv"> create_user </strong>中，我们将想要使用的角色作为第一个参数，将用于创建用户的参数映射作为第二个参数。我们从我们的角色开始，然后通过管道将其传递到我们的构建函数中，创建一个用户模型(因为我们指定了:users作为关联)，然后通过管道将其传递到User.changeset中，并带有前面提到的参数。最终结果会被传送到Repo.insert()中，我们就完成了！</p><p id="f3ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然解释起来有点复杂，但我们最终得到了可读性和可理解性都非常好的代码。扮演一个角色，构建一个关联用户，准备将其插入到数据库中，然后插入！</p><p id="42cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于<strong class="it hv"> create_post </strong>我们做了同样的事情，除了用帖子和用户代替用户和角色！</p><h2 id="0521" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">修正我们的测试</h2><p id="0621" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">我们将从修复<strong class="it hv">test/models/user _ test . exs</strong>开始。我们需要做的第一件事是添加<strong class="it hv">别名Pxblog。TestHelper </strong>添加到我们的模块定义的顶部，这样我们就可以使用我们之前创建的那些方便的助手。接下来，我们将在测试之前创建一个设置块来重用一个角色。</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="a997" class="jp jq hu mb b fv mf mg l mh mi">setup do<br/>  {:ok, role}  = TestHelper.create_role(%{name: "user", admin: false})<br/>  {:ok, role: role}<br/>end</span></pre><p id="2a91" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，在我们的第一个测试中，我们将根据我们的设置块中的角色键对其进行模式匹配。每当我们想要包含这个角色时，我们都要节省一点打字的时间，所以我们要编写一个助手函数并修改测试:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="1ef7" class="jp jq hu mb b fv mf mg l mh mi">defp valid_attrs(role) do<br/>  Map.put(@valid_attrs, :role_id, role.id)<br/>end</span><span id="565e" class="jp jq hu mb b fv mj mg l mh mi">test "changeset with valid attributes", %{role: role} do<br/>  changeset = User.changeset(%User{}, valid_attrs(role))<br/>  assert changeset.valid?<br/>end</span></pre><p id="9d6a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">概括地说，我们对来自设置块的角色键进行模式匹配，然后我们修改了<strong class="it hv"> valid_attrs </strong>键，以便在我们的帮助器方法中包含一个有效的角色id！当我们修改并运行这个规范时，我们现在应该回到绿色的<strong class="it hv">test/models/user<em class="mk">_</em>test . exs</strong>规范！</p><p id="a810" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，打开<strong class="it hv">test/controllers/user _ controller<em class="mk">_</em>test . exs</strong>，我们将使用相同的课程让这个文件再次通过。我们将添加一个<strong class="it hv">别名Pxblog。Role </strong>语句，以及一个别名Pxblog。TestHelper 语句，并添加设置代码来创建一个角色，并用conn返回。</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="c22d" class="jp jq hu mb b fv mf mg l mh mi">setup do<br/>  {:ok, user_role}  = TestHelper.create_role(%{name: "user", admin: false})<br/>  {:ok, admin_role} = TestHelper.create_role(%{name: "admin", admin: true})<br/>  {:ok, conn: build_conn(), user_role: user_role, admin_role: admin_role}<br/>end</span></pre><p id="3200" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将添加一个名为<strong class="it hv"> valid_create_attrs </strong>的助手函数，它接受一个角色作为参数，并返回一个设置了role_id的新映射。</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="b16c" class="jp jq hu mb b fv mf mg l mh mi">defp valid_create_attrs(role) do<br/>  Map.put(@valid_create_attrs, :role_id, role.id)<br/>end</span></pre><p id="d229" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我们将修改我们的创建和更新操作，以使用这个新的助手和来自映射的user_role值的模式匹配。</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="b46d" class="jp jq hu mb b fv mf mg l mh mi">test "creates resource and redirects when data is valid", %{conn: conn, user_role: user_role} do<br/>  conn = post conn, user_path(conn, :create), user: valid_create_attrs(user_role)<br/>  assert redirected_to(conn) == user_path(conn, :index)<br/>  assert Repo.get_by(User, @valid_attrs)<br/>end</span><span id="0e62" class="jp jq hu mb b fv mj mg l mh mi">test "updates chosen resource and redirects when data is valid", %{conn: conn, user_role: user_role} do<br/>  user = Repo.insert! %User{}<br/>  conn = put conn, user_path(conn, :update, user), user: valid_create_attrs(user_role)<br/>  assert redirected_to(conn) == user_path(conn, :show, user)<br/>  assert Repo.get_by(User, @valid_attrs)<br/>end</span></pre><p id="8ea7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的用户控制器测试现在应该都是绿色的了！可悲的是，运行混合测试仍然会给我们带来失败。</p><h2 id="2766" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">修复开机自检控制器测试</h2><p id="b2a5" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">在我们的帖子控制器中，我们最终创建了许多帮助器函数，以便于我们与用户一起构建帖子，因此我们需要修改这些帮助器并添加角色的概念，以便我们可以创建有效的用户。我们将从添加对<strong class="it hv"> Pxblog的引用开始。角色</strong>在我们岗位控制员的顶端。在<strong class="it hv">test/controllers/post _ controller _ test . exs</strong>中:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="ebbc" class="jp jq hu mb b fv mf mg l mh mi">alias Pxblog.Role<br/>alias Pxblog.TestHelper</span></pre><p id="e3ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，我们将创建我们的设置块，与我们在前面的设置块中所做的略有不同。</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="feb0" class="jp jq hu mb b fv mf mg l mh mi">setup do<br/>  {:ok, role} = TestHelper.create_role(%{name: "User Role", admin: false})<br/>  {:ok, user} = TestHelper.create_user(role, %{email: "test@test.com", username: "testuser", password: "test", password_confirmation: "test"})<br/>  {:ok, post} = TestHelper.create_post(user, %{title: "Test Post", body: "Test Body"})<br/>  conn = build_conn() |&gt; login_user(user)<br/>  {:ok, conn: conn, user: user, role: role, post: post}<br/>end</span></pre><p id="ce53" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们需要做的第一件事是创建一个角色，在这里一个标准的非管理员角色就可以了。在下一行中，我们还将创建一个使用该角色的用户。接下来，我们将为用户创建一个帖子。我们已经讨论了登录部分，所以我们将跳过它。最后，我们返回我们创建的所有新模型，以允许每个测试根据需要进行模式匹配。</p><p id="e629" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们有一个测试，我们也将修改，以获得一切绿色。我们的“为不同用户编辑帖子时的重定向”测试失败了，因为它试图在没有角色概念的情况下动态创建第二个用户。我们会稍微改变一下:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="5461" class="jp jq hu mb b fv mf mg l mh mi">test "redirects when trying to edit a post for a different user", %{conn: conn, user: user, role: role, post: post} do<br/>  {:ok, other_user} = TestHelper.create_user(role, %{email: "test2@test.com", username: "test2", password: "test", password_confirmation: "test"})<br/>  conn = get conn, user_post_path(conn, :edit, other_user, post)<br/>  assert get_flash(conn, :error) == "You are not authorized to modify that post!"<br/>  assert redirected_to(conn) == page_path(conn, :index)<br/>  assert conn.halted<br/>end</span></pre><p id="0701" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，在这里我们将role: role位添加到我们的测试定义中，以在角色键上进行模式匹配，并将other_user创建位改为使用TestHelper并引用我们模式匹配的角色。</p><p id="1937" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们有一个快速重构的机会，因为我们包含了一个来自TestHelper的post对象，作为我们可以进行模式匹配的值之一。在我们之前调用<strong class="it hv"> build_post </strong>的任何地方，我们都可以删除，取而代之的是在我们的post对象上进行模式匹配。经过我们所有的修改后，完整的文件应该是:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="e18f" class="jp jq hu mb b fv mf mg l mh mi">defmodule Pxblog.PostControllerTest do<br/>  use Pxblog.ConnCase</span><span id="11df" class="jp jq hu mb b fv mj mg l mh mi">  alias Pxblog.Post<br/>  alias Pxblog.TestHelper</span><span id="3e6c" class="jp jq hu mb b fv mj mg l mh mi">  @valid_attrs %{body: "some content", title: "some content"}<br/>  @invalid_attrs %{}</span><span id="89aa" class="jp jq hu mb b fv mj mg l mh mi">  setup do<br/>    {:ok, role} = TestHelper.create_role(%{name: "User Role", admin: false})<br/>    {:ok, user} = TestHelper.create_user(role, %{email: "test@test.com", username: "testuser", password: "test", password_confirmation: "test"})<br/>    {:ok, post} = TestHelper.create_post(user, %{title: "Test Post", body: "Test Body"})<br/>    conn = build_conn() |&gt; login_user(user)<br/>    {:ok, conn: conn, user: user, role: role, post: post}<br/>  end</span><span id="252d" class="jp jq hu mb b fv mj mg l mh mi">  defp login_user(conn, user) do<br/>    post conn, session_path(conn, :create), user: %{username: user.username, password: user.password}<br/>  end</span><span id="b438" class="jp jq hu mb b fv mj mg l mh mi">  test "lists all entries on index", %{conn: conn, user: user} do<br/>    conn = get conn, user_post_path(conn, :index, user)<br/>    assert html_response(conn, 200) =~ "Listing posts"<br/>  end</span><span id="e5ef" class="jp jq hu mb b fv mj mg l mh mi">  test "renders form for new resources", %{conn: conn, user: user} do<br/>    conn = get conn, user_post_path(conn, :new, user)<br/>    assert html_response(conn, 200) =~ "New post"<br/>  end</span><span id="5846" class="jp jq hu mb b fv mj mg l mh mi">  test "creates resource and redirects when data is valid", %{conn: conn, user: user} do<br/>    conn = post conn, user_post_path(conn, :create, user), post: @valid_attrs<br/>    assert redirected_to(conn) == user_post_path(conn, :index, user)<br/>    assert Repo.get_by(assoc(user, :posts), @valid_attrs)<br/>  end</span><span id="5156" class="jp jq hu mb b fv mj mg l mh mi">  test "does not create resource and renders errors when data is invalid", %{conn: conn, user: user} do<br/>    conn = post conn, user_post_path(conn, :create, user), post: @invalid_attrs<br/>    assert html_response(conn, 200) =~ "New post"<br/>  end</span><span id="8f3d" class="jp jq hu mb b fv mj mg l mh mi">  test "shows chosen resource", %{conn: conn, user: user, post: post} do<br/>    conn = get conn, user_post_path(conn, :show, user, post)<br/>    assert html_response(conn, 200) =~ "Show post"<br/>  end</span><span id="5096" class="jp jq hu mb b fv mj mg l mh mi">  test "renders page not found when id is nonexistent", %{conn: conn, user: user} do<br/>    assert_error_sent 404, fn -&gt;<br/>      get conn, user_post_path(conn, :show, user, -1)<br/>    end<br/>  end</span><span id="cbdc" class="jp jq hu mb b fv mj mg l mh mi">  test "renders form for editing chosen resource", %{conn: conn, user: user, post: post} do<br/>    conn = get conn, user_post_path(conn, :edit, user, post)<br/>    assert html_response(conn, 200) =~ "Edit post"<br/>  end</span><span id="d6b3" class="jp jq hu mb b fv mj mg l mh mi">  test "updates chosen resource and redirects when data is valid", %{conn: conn, user: user, post: post} do<br/>    conn = put conn, user_post_path(conn, :update, user, post), post: @valid_attrs<br/>    assert redirected_to(conn) == user_post_path(conn, :show, user, post)<br/>    assert Repo.get_by(Post, @valid_attrs)<br/>  end</span><span id="6aff" class="jp jq hu mb b fv mj mg l mh mi">  test "does not update chosen resource and renders errors when data is invalid", %{conn: conn, user: user, post: post} do<br/>    conn = put conn, user_post_path(conn, :update, user, post), post: %{"body" =&gt; nil}<br/>    assert html_response(conn, 200) =~ "Edit post"<br/>  end</span><span id="eea2" class="jp jq hu mb b fv mj mg l mh mi">  test "deletes chosen resource", %{conn: conn, user: user, post: post} do<br/>    conn = delete conn, user_post_path(conn, :delete, user, post)<br/>    assert redirected_to(conn) == user_post_path(conn, :index, user)<br/>    refute Repo.get(Post, post.id)<br/>  end</span><span id="3979" class="jp jq hu mb b fv mj mg l mh mi">  test "redirects when the specified user does not exist", %{conn: conn} do<br/>    conn = get conn, user_post_path(conn, :index, -1)<br/>    assert get_flash(conn, :error) == "Invalid user!"<br/>    assert redirected_to(conn) == page_path(conn, :index)<br/>    assert conn.halted<br/>  end</span><span id="09a6" class="jp jq hu mb b fv mj mg l mh mi">  test "redirects when trying to edit a post for a different user", %{conn: conn, role: role, post: post} do<br/>    {:ok, other_user} = TestHelper.create_user(role, %{email: "test2@test.com", username: "test2", password: "test", password_confirmation: "test"})<br/>    conn = get conn, user_post_path(conn, :edit, other_user, post)<br/>    assert get_flash(conn, :error) == "You are not authorized to modify that post!"<br/>    assert redirected_to(conn) == page_path(conn, :index)<br/>    assert conn.halted<br/>  end<br/>end</span></pre><h2 id="0c62" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">修复会话控制器测试</h2><p id="15bc" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated"><strong class="it hv">test/controllers/session _ controller _ test . exs</strong>也有一些失败的测试，因为我们没有更新它来使用我们的TestHelper。我们将在顶部添加一个别名，并修改设置块，就像我们在其他地方做的那样:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="c230" class="jp jq hu mb b fv mf mg l mh mi">defmodule Pxblog.SessionControllerTest do<br/>  use Pxblog.ConnCase</span><span id="056e" class="jp jq hu mb b fv mj mg l mh mi">  alias Pxblog.User<br/>  alias Pxblog.TestHelper</span><span id="50dc" class="jp jq hu mb b fv mj mg l mh mi">  setup do<br/>    {:ok, role} = TestHelper.create_role(%{name: "User", admin: false})<br/>    {:ok, _user} = TestHelper.create_user(role, %{username: "test", password: "test", password_confirmation: "test", email: "test@test.com"})<br/>    {:ok, conn: build_conn()}<br/>  end</span></pre><p id="969a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这应该足以让这些测试通过！万岁！</p><h2 id="0799" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">修正我们剩下的测试</h2><p id="a567" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">我们还有两项测试失败。让我们得到那些绿色！</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="fcbe" class="jp jq hu mb b fv mf mg l mh mi">1) test current user returns the user in the session (Pxblog.LayoutViewTest)<br/> test/views/layout_view_test.exs:13<br/> Expected truthy, got nil<br/> code: LayoutView.current_user(conn)<br/> stacktrace:<br/> test/views/layout_view_test.exs:15</span><span id="b6db" class="jp jq hu mb b fv mj mg l mh mi">2) test current user returns nothing if there is no user in the session (Pxblog.LayoutViewTest)<br/> test/views/layout_view_test.exs:18<br/> ** (ArgumentError) cannot convert nil to param<br/> stacktrace:<br/> (phoenix) lib/phoenix/param.ex:67: Phoenix.Param.Atom.to_param/1<br/> (pxblog) web/router.ex:1: Pxblog.Router.Helpers.session_path/4<br/> test/views/layout_view_test.exs:20</span></pre><p id="d628" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">打开<strong class="it hv">test/views/layout _ view _ test . exs</strong>，在顶部我们看到一个没有角色的用户被创建！在我们的setup块中，我们也没有传递我们创建的用户，所以我们必须一遍又一遍地查找它！恶心！我们将重构整个文件:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="3ab9" class="jp jq hu mb b fv mf mg l mh mi">defmodule Pxblog.LayoutViewTest do<br/>  use Pxblog.ConnCase, async: true</span><span id="8a34" class="jp jq hu mb b fv mj mg l mh mi">  alias Pxblog.LayoutView<br/>  alias Pxblog.TestHelper</span><span id="ed31" class="jp jq hu mb b fv mj mg l mh mi">  setup do<br/>    {:ok, role} = TestHelper.create_role(%{name: "User Role", admin: false})<br/>    {:ok, user} = TestHelper.create_user(role, %{email: "<a class="ae ml" href="mailto:test@test.com" rel="noopener ugc nofollow" target="_blank">test@test.com</a>", username: "testuser", password: "test", password_confirmation: "test"})<br/>    {:ok, conn: build_conn(), user: user}<br/>  end</span><span id="85fe" class="jp jq hu mb b fv mj mg l mh mi">  test "current user returns the user in the session", %{conn: conn, user: user} do<br/>    conn = post conn, session_path(conn, :create), user: %{username: user.username, password: user.password}<br/>    assert LayoutView.current_user(conn)<br/>  end</span><span id="5aaa" class="jp jq hu mb b fv mj mg l mh mi">  test "current user returns nothing if there is no user in the session", %{conn: conn, user: user} do<br/>    conn = delete conn, session_path(conn, :delete, user)<br/>    refute LayoutView.current_user(conn)<br/>  end<br/>end</span></pre><p id="c5fa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们为我们的角色模型添加一个别名，创建一个有效的角色，用该角色创建一个有效的用户，然后返回带有conn的用户。现在，运行混合测试和…</p><p id="c401" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一切都是绿色的！但是当运行我们的测试时，我们得到了一些警告(因为我们把一切都做得如此可爱和干净)。</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="b4e5" class="jp jq hu mb b fv mf mg l mh mi">test/controllers/post_controller_test.exs:20: warning: function create_user/0 is unused<br/>test/views/layout_view_test.exs:6: warning: unused alias Role<br/>test/views/layout_view_test.exs:5: warning: unused alias User<br/>test/controllers/user_controller_test.exs:5: warning: unused alias Role<br/>test/controllers/post_controller_test.exs:102: warning: variable user is unused<br/>test/controllers/post_controller_test.exs:6: warning: unused alias Role</span></pre><p id="8e52" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">只需进入每个文件并删除不合适的别名和函数，因为我们不再需要它们了！</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="c500" class="jp jq hu mb b fv mf mg l mh mi">$ mix test<br/>.........................................</span><span id="4644" class="jp jq hu mb b fv mj mg l mh mi">Finished in 0.4 seconds<br/>41 tests, 0 failures</span><span id="7737" class="jp jq hu mb b fv mj mg l mh mi">Randomized with seed 588307</span></pre><h2 id="cd27" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">创建管理种子</h2><p id="06f4" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">最终，我们将限制新用户的创建仅限于管理员。然而，对我们来说，这样做意味着我们将处于一个奇怪的第22条军规的状态，我们没有成员或管理员，因此意味着我们不能创建成员或管理员，等等。我们将通过为默认管理员用户提供种子来解决这个问题。打开<strong class="it hv"> priv/repo/seeds.exs </strong>并插入以下代码:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="ed48" class="jp jq hu mb b fv mf mg l mh mi">alias Pxblog.Repo<br/>alias Pxblog.Role<br/>alias Pxblog.User</span><span id="700d" class="jp jq hu mb b fv mj mg l mh mi">role = %Role{}<br/>  |&gt; Role.changeset(%{name: "Admin Role", admin: true})<br/>  |&gt; Repo.insert!</span><span id="d462" class="jp jq hu mb b fv mj mg l mh mi">admin = %User{}<br/>  |&gt; User.changeset(%{username: "admin", email: "admin@test.com", password: "test", password_confirmation: "test", role_id: role.id})<br/>  |&gt; Repo.insert!</span></pre><p id="ed46" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，我们将通过调用以下命令来运行种子文件:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="9fc9" class="jp jq hu mb b fv mf mg l mh mi">$ mix run priv/repo/seeds.exs</span></pre><h2 id="dfa5" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">接下来</h2><p id="b178" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">现在，我们已经设置好了模型，并准备好处理我们的角色，我们的测试也变回绿色，我们需要开始修改控制器中的功能，以限制某些操作，除非您是适当的用户或管理员。在下一篇文章中，我们将探索如何最好地实现这个功能，如何添加一个助手模块，当然，我们将保持我们的测试绿色！</p><h2 id="74bc" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">本系列的下一篇文章</h2><div class="kk kl fm fo km kn"><a rel="noopener follow" target="_blank" href="/@diamondgfx/writing-a-blog-engine-in-phoenix-and-elixir-part-4-adding-roles-to-our-controllers-9f4678b48468"><div class="ko ab ej"><div class="kp ab kq cl cj kr"><h2 class="bd hv fv z el ks eo ep kt er et ht dt translated">用Phoenix和Elixir编写博客引擎:第4部分，向控制器添加角色</h2><div class="ku l"><h3 class="bd b fv z el ks eo ep kt er et ek translated">最新更新:2016年1月26日</h3></div><div class="kv l"><p class="bd b gc z el ks eo ep kt er et ek translated">medium.com</p></div></div><div class="mm l"><div class="mn l mo mp mq mm mr ms kn"/></div></div></a></div><h1 id="7a90" class="mt jq hu bd jr mu mv mw jv mx my mz jz na nb nc kc nd ne nf kf ng nh ni ki nj dt translated">看看我的新书！</h1><p id="8477" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">嘿大家好！如果你喜欢你在这里读到的东西，并且想和我一起学习更多，可以看看我的新书《长生不老药和凤凰网开发》:</p><div class="kk kl fm fo km kn"><a href="https://www.packtpub.com/web-development/phoenix-web-development" rel="noopener  ugc nofollow" target="_blank"><div class="ko ab ej"><div class="kp ab kq cl cj kr"><h2 class="bd hv fv z el ks eo ep kt er et ht dt translated">凤凰网开发| PACKT图书</h2><div class="ku l"><h3 class="bd b fv z el ks eo ep kt er et ek translated">学习使用Elixir和……从头开始构建投票web应用程序的高性能功能原型</h3></div><div class="kv l"><p class="bd b gc z el ks eo ep kt er et ek translated">www.packtpub.com</p></div></div><div class="mm l"><div class="nk l mo mp mq mm mr ms kn"/></div></div></a></div><p id="1687" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我真的很兴奋终于可以把这个项目推向世界了！它的写作风格与我的其他教程一样，我们将从头到尾构建一个完整项目的框架，甚至涵盖一些更棘手的主题，如文件上传、Twitter/Google OAuth登录和API！</p><blockquote class="nl nm nn"><p id="fa61" class="ir is mk it b iu iv iw ix iy iz ja jb no jd je jf np jh ji jj nq jl jm jn jo hn dt translated"><a class="ae ml" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ml" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ml" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae ml" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is mk it b iu iv iw ix iy iz ja jb no jd je jf np jh ji jj nq jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae ml" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae ml" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae ml" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is mk it b iu iv iw ix iy iz ja jb no jd je jf np jh ji jj nq jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ml" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ml" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>