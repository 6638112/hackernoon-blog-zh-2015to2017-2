<html>
<head>
<title>Sockets in action</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">正在运行的套接字</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/this-post-series-aims-to-clarify-the-different-operations-you-could-do-with-a-network-socket-and-65dbe59294f8?source=collection_archive---------3-----------------------#2016-11-16">https://medium.com/hackernoon/this-post-series-aims-to-clarify-the-different-operations-you-could-do-with-a-network-socket-and-65dbe59294f8?source=collection_archive---------3-----------------------#2016-11-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="2ce2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本系列文章旨在阐明您可以使用网络套接字进行的不同操作，以及在讨论这些操作时要使用的动词。</p><p id="fcba" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么什么是插座，我为什么要关心我能用它做的事情呢？来自维基百科:</p><blockquote class="jp jq jr"><p id="d818" class="ir is js it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt translated">网络套接字是计算机网络中连接的端点。它是一个程序可以传递给网络应用程序<a class="ae jw" href="https://hackernoon.com/tagged/proghramming" rel="noopener ugc nofollow" target="_blank">编程</a>接口(API)的句柄(抽象引用)，以使用连接来接收和发送数据。套接字通常在内部表示为整数。</p></blockquote><p id="2a8a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，如果您的应用程序以某种方式使用套接字，并且很可能是这样，您应该熟悉套接字上的操作。让我们从创建一个套接字开始。</p><h2 id="09c1" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">创建套接字</h2><p id="8b6a" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">创建一个套接字是通过<a class="ae jw" href="https://linux.die.net/man/2/socket" rel="noopener ugc nofollow" target="_blank">套接字</a>系统调用完成的。要创建一个套接字，我们需要指定3样东西——这是套接字方法的签名:</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="4003" class="jx jy hu lc b fv lg lh l li lj"><strong class="lc hv">#include &lt;sys/types.h&gt;</strong><br/><strong class="lc hv">#include &lt;sys/socket.h&gt;</strong></span><span id="14f0" class="jx jy hu lc b fv lk lh l li lj"><strong class="lc hv">int socket(int</strong> <em class="js">domain</em><strong class="lc hv">, int</strong> <em class="js">type</em><strong class="lc hv">, int</strong> <em class="js">protocol</em><strong class="lc hv">);</strong></span></pre><p id="923b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么，什么是域、类型和协议呢？</p><p id="27f0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">域指定将用于通信的协议族。协议族是<a class="ae jw" href="https://hackernoon.com/tagged/network" rel="noopener ugc nofollow" target="_blank">网络</a>接口配置中的一组逻辑属性。协议族包括组成协议组的所有协议。最流行的是IPv4、IPv6和UNIX。</p><p id="0658" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该类型描述了协议的语义，这些协议是由前面的参数指定的协议族的一部分，例如，我想要一个具有传递保证的面向双向连接的字节流，或者我只想发送数据报(固定最大长度的无连接、不可靠的消息)。</p><p id="dce6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好了，我们已经指定了协议族，以及我们想从中获得什么。最后一个参数指定了该系列的具体协议实现。一般情况下，只有一个协议满足(family，type)对，所以省略此参数(<code class="eh ll lm ln lc b">0</code>被传递)，但如果存在多个实现，则必须相应地设置此参数。</p><p id="161f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">创建套接字后，我们可以连接到远程套接字，或者监听传入的连接。先说后面的。</p><h2 id="f1c3" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">将地址绑定到套接字</h2><p id="f198" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">为了监听传入的连接，或者只是接收数据报，我们首先需要为套接字指定一个地址(就像给套接字分配一个名称一样)。这个操作被称为绑定——我们<a class="ae jw" href="https://linux.die.net/man/2/bind" rel="noopener ugc nofollow" target="_blank">将一个地址(名称)绑定到套接字。</a></p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="d1d4" class="jx jy hu lc b fv lg lh l li lj"><strong class="lc hv">int</strong> <strong class="lc hv">bind(int</strong> sockfd, <strong class="lc hv">const struct sockaddr *</strong>addr,<br/>                <strong class="lc hv">socklen_t</strong> addrlen<strong class="lc hv">);</strong></span></pre><p id="04a7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个调用接受套接字描述符、应该使用的地址和地址类型的字节大小。为<code class="eh ll lm ln lc b">addr</code>参数传递的实际结构将取决于地址族(我们之前讨论过协议族，还记得吗？).<code class="eh ll lm ln lc b">struct sockaddr</code>结构的唯一目的是强制转换在<code class="eh ll lm ln lc b">addr</code>中传递的结构指针，以避免编译器警告。让我们看一个将127.0.0.1:8000 IPv4/TCP地址绑定到套接字的示例。(为简单起见，省略了错误处理)</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="a67c" class="jx jy hu lc b fv lg lh l li lj">int sockfd;<br/>struct sockaddr_in serv_addr;</span><span id="a7ce" class="jx jy hu lc b fv lk lh l li lj">sockfd = socket(PF_INET, SOCK_STREAM, 0);</span><span id="af87" class="jx jy hu lc b fv lk lh l li lj">memset(&amp;serv_addr, 0, sizeof(serv_addr));</span><span id="952d" class="jx jy hu lc b fv lk lh l li lj">serv_addr.sin_family = AF_INET;<br/>serv_addr.sin_addr.s_addr = INADDR_LOOPBACK;<br/>serv_addr.sin_port = htons(8000);</span><span id="1767" class="jx jy hu lc b fv lk lh l li lj">bind(sockfd, (struct sockaddr *) &amp;serv_addr, sizeof(serv_addr));</span></pre><p id="0aab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">太好了！我们现在有了与套接字关联的地址。如果我们已经指定了一个无连接协议，例如UDP，我们可以直接从套接字开始读取。但是，既然我们选择了面向连接的协议TCP，我们就应该宣布愿意接受传入的连接，然后从这些连接中读取数据。让我们看看这是如何发生的。</p><h2 id="d431" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">监听套接字</h2><p id="eebb" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">监听是通过<a class="ae jw" href="https://linux.die.net/man/2/listen" rel="noopener ugc nofollow" target="_blank">监听</a>系统调用完成的:</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="57a4" class="jx jy hu lc b fv lg lh l li lj"><strong class="lc hv">int</strong> <strong class="lc hv">listen(int</strong> sockfd, <strong class="lc hv">int</strong> backlog<strong class="lc hv">);</strong></span></pre><p id="be4b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第一个参数是我们想要监听的套接字，第二个参数指定了所谓的backlog。(由操作系统)为每个套接字创建一个等待传入连接的队列。backlog表示队列的大小。如果连接请求在队列已满时到达，客户端可能会收到一个错误，或者该请求可能会被忽略(取决于底层协议)。请注意，队列大小可能会受到某些协议细节或操作系统配置的影响，因此它可能不会采用通过<code class="eh ll lm ln lc b">listen</code>指定的值。</p><h2 id="ea10" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">接受传入连接</h2><p id="3343" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">在我们宣布我们想要接受连接之后，最后一部分是实际接受这样的连接。这是通过(惊喜！)的<a class="ae jw" href="https://linux.die.net/man/2/accept" rel="noopener ugc nofollow" target="_blank">接受</a>系统调用。</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="15e3" class="jx jy hu lc b fv lg lh l li lj"><strong class="lc hv">int</strong> <strong class="lc hv">accept(int</strong> sockfd, <strong class="lc hv">struct sockaddr</strong> <strong class="lc hv">*</strong>addr, <strong class="lc hv">socklen_t</strong> <strong class="lc hv">*</strong>addrlen<strong class="lc hv">);</strong></span></pre><p id="693b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ll lm ln lc b">sockfd</code>是我们之前监听的插座。参数<code class="eh ll lm ln lc b">addr</code>是一个指向<code class="eh ll lm ln lc b">sockaddr</code>结构的指针。这个结构中填充了对等套接字的地址(客户机的地址)，这是通信层所知道的。返回地址的确切格式由套接字的地址族决定。如果我们不关心对等地址，我们可以直接通过<code class="eh ll lm ln lc b">NULL</code>。</p><p id="0750" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ll lm ln lc b">addrlen</code>参数是一个值-结果参数:调用者必须初始化它以包含<code class="eh ll lm ln lc b">addr</code>所指向的结构的大小(以字节为单位)。返回时，它将包含对等地址的实际大小。</p><h2 id="3439" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">例子</h2><p id="2c54" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">让我们把它们放在一起。请注意，只有在尝试接受传入连接时出现错误，下面的示例才会退出。</p><figure class="kx ky kz la fq lo"><div class="bz el l di"><div class="lp lq l"/></div></figure><p id="a2bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在构建和运行之后，我们可以验证行为是正确的。首先，让我们看看程序正在监听所需的地址:</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="1e9b" class="jx jy hu lc b fv lg lh l li lj">$ ss -tnl src :8000<br/>State      Recv-Q Send-Q   Local Address:Port     Peer Address:Port<br/>LISTEN     0      128                  *:8000                *:*</span></pre><p id="12ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以看到我们有一个处于<code class="eh ll lm ln lc b">LISTEN</code>状态的<code class="eh ll lm ln lc b">TCP</code>套接字。套接字的本地地址是<code class="eh ll lm ln lc b">*:8000</code>，对应于我们已经配置的<code class="eh ll lm ln lc b">INADDR_ANY:8000</code>。<code class="eh ll lm ln lc b">Send-Q</code>的大小是<code class="eh ll lm ln lc b">128</code>，由<code class="eh ll lm ln lc b">listen</code>系统调用的<code class="eh ll lm ln lc b">backlog</code>参数指定。</p><p id="5181" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们使用<code class="eh ll lm ln lc b">netcat</code>与我们的程序建立连接，我们会看到“Hello，socket！”消息。</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="bd5c" class="jx jy hu lc b fv lg lh l li lj">$ nc localhost 8000<br/>Hello, socket!</span></pre><p id="bd33" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们程序的输出打印了对等体的地址(如果我们是从同一台机器连接的，则为127.0.0.1):</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="defe" class="jx jy hu lc b fv lg lh l li lj">$ ./main<br/>received connection from peer: 127.0.0.1</span></pre><h2 id="ac34" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">摘要</h2><p id="9546" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">在这篇文章中，我们解释了套接字上的<code class="eh ll lm ln lc b">socket</code>、<code class="eh ll lm ln lc b">bind</code>、<code class="eh ll lm ln lc b">listen</code>和<code class="eh ll lm ln lc b">accept</code>动作的目的。我们重申一下。</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="7104" class="jx jy hu lc b fv lg lh l li lj"><strong class="lc hv">socket</strong> — create a socket endpoint for communication<br/><strong class="lc hv">bind</strong> — bind a name (address) to a socket<br/><strong class="lc hv">listen</strong> — listen for connections on a socket<br/><strong class="lc hv">accept</strong> — accept a connection on a socket</span></pre><p id="d6bb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本系列的下一部分中，我们将从客户的角度出发，通过在套接字上启动连接、发送和接收数据以及清理来进行观察。敬请关注。</p><blockquote class="jp jq jr"><p id="5cae" class="ir is js it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt translated"><a class="ae jw" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是AMI家庭的一员。我们现在<a class="ae jw" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jw" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is js it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt translated">要了解更多信息，<a class="ae jw" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">请阅读我们的“关于”页面</a>、<a class="ae jw" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">喜欢/在脸书给我们发消息</a>，或者简单地说，<a class="ae jw" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is js it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jw" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jw" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kx ky kz la fq lo"><div class="bz el l di"><div class="lr lq l"/></div></figure></div></div>    
</body>
</html>