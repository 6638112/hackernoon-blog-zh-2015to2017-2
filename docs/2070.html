<html>
<head>
<title>Simpler Android apps with Flowless 1.0-RC2 (or Flow 1.0-alpha2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更简单的Android应用，无流量1.0-RC2(或流量1.0-alpha2)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/simpler-android-apps-with-flow-1-0-alpha2-or-flowless-1-0-rc1-228a9ae8a5a2?source=collection_archive---------15-----------------------#2017-01-04">https://medium.com/hackernoon/simpler-android-apps-with-flow-1-0-alpha2-or-flowless-1-0-rc1-228a9ae8a5a2?source=collection_archive---------15-----------------------#2017-01-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/7ea7bf9c25c3afe575280749ee5bf905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rm7bwbakSD2cJ4PjJSwjnw.png"/></div></div></figure><p id="79a6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">注意:我已经弃用了Flowless(并且已经放弃了使用Flow)而支持我从头开始写的:</strong> <a class="ae ka" href="https://github.com/Zhuinden/simple-stack" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> <em class="kb">简单堆栈</em> </strong> </a> <strong class="je hv">。</strong></p><p id="ee04" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">所以你应该记住，我不再使用它了，因为简单堆栈解决了我不喜欢的Flow设计的奇怪之处。</strong></p><p id="bc21" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt">— — — — — — — — — — — — — — — — — — — — — — — — —</p><p id="648a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是<a class="ae ka" rel="noopener" href="/@Zhuinden/saying-no-to-fragments-and-activities-creating-view-driven-applications-with-flow-8f7d02315442#.7v27hfa5h">对片段和活动说不:用流创建视图驱动的应用</a>的后续文章。</p><p id="3152" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然我声称那篇文章会切中要点，但它更多的是一个关于最近使用<a class="ae ka" href="https://github.com/square/flow" rel="noopener ugc nofollow" target="_blank"> Flow 1.0-alpha2 </a>(和<a class="ae ka" href="https://github.com/Zhuinden/flowless/" rel="noopener ugc nofollow" target="_blank"> Flowless </a>)、<a class="ae ka" rel="noopener" href="/square-corner-blog/simpler-android-apps-with-flow-and-mortar-5beafcd83761#.3lhst05ys">与过去使用Flow 0.8 </a>的情况的比较。因此，有人可能会说，它毕竟没有直奔主题。</p><p id="a7e8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们开始吧，好吗？</p><h1 id="5e33" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">流程:幕后经理</h1><p id="0a4f" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">正如<a class="ae ka" rel="noopener" href="/@Zhuinden/eli5-what-does-squares-flow-library-do-ecd497b61dc3#.iibimfys2">在上一篇文章</a>中所述，Flow(以及<code class="eh lf lg lh li b">Flow</code>实例本身)的主要任务是管理<a class="ae ka" href="https://hackernoon.com/tagged/backstack" rel="noopener ugc nofollow" target="_blank"> backstack </a>。它真正关心的是<code class="eh lf lg lh li b">History</code>(本质上是一个<code class="eh lf lg lh li b">List&lt;Object&gt;</code>，并公开允许<a class="ae ka" href="https://hackernoon.com/tagged/manipulating" rel="noopener ugc nofollow" target="_blank">操作</a>它的操作符。</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><h1 id="e8aa" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">键:应用程序状态的表示</h1><p id="af9b" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">与只使用活动相比，使用流的主要区别在于，它没有由一系列意图创建的隐式backstack来打开一堆活动，而是有一个“关键”对象的历史，这些对象只是一般的可打包对象，用<code class="eh lf lg lh li b">hashCode()</code>和<code class="eh lf lg lh li b">equals()</code>来表示应该显示什么视图。</p><p id="c730" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="kb">(事实上，它不一定是一个观点，如果你是一个异教徒，你甚至可以用片段来描述它。不，真的；只需使用新增加的</em> <code class="eh lf lg lh li b"><em class="kb">FragmentManager.commitNow()</em></code> <em class="kb">，而不要使用</em> <code class="eh lf lg lh li b"><em class="kb">addToBackStack()</em></code> <em class="kb">，推迟backstack操纵改为Flow。理论上应该可以，虽然我必须承认我还没试过。)</em></p><p id="babf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个可能的密钥示例如下:</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="9ec3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是如果您不喜欢从注释中提取值，那么您可以只使用接口和方法调用。看你的了！</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="08bb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这允许对应用程序的状态进行简单的初始化。</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="9cda" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它还允许您轻松地设置任何您想要用插装测试来测试的视图。</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="dc83" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可能会想，“等等，这是一大堆方法，我以为这会让我的生活更简单？!"</p><p id="4a4a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">事实上，确实如此。确切地说，因为这种编码在键中的“行为”曾经被随机地扔进片段中，直接操纵活动中的工具栏标题。</p><p id="10dc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这里，这是您可以在dispatcher实现中全局执行的操作，并且它也可以在back press上以最小的工作量正确设置(事实上，它开箱即用)。</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><h1 id="256f" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">自定义视图，并倾听生命周期</h1><p id="a567" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">这是一个<a class="ae ka" href="https://github.com/Zhuinden/flowless/" rel="noopener ugc nofollow" target="_blank">无流</a>特有的特性，部分依附于原始流中的<code class="eh lf lg lh li b">InternalLifecycleIntegration</code>片段之上。</p><p id="7354" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您通常需要知道您的视图什么时候准备好，它的状态什么时候恢复。您还必须知道视图何时被终止，以便您可以取消订阅，或者从事件总线中取消注册。</p><p id="11ec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以前的流示例曾经显示<code class="eh lf lg lh li b">onAttachedToWindow</code>和<code class="eh lf lg lh li b">onDetachedFromWindow</code>作为要使用的回调，但这实际上是不可靠的。有调用<code class="eh lf lg lh li b">onFinishInflate()</code>而不调用<code class="eh lf lg lh li b">onAttachedToWindow()</code>的情况。在这种情况下，您不会收到对<code class="eh lf lg lh li b">onDetachedFromWindow()</code>的任何回调，这意味着您可能会丢失您的状态！</p><p id="2683" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你很好奇，这很可能就是为什么<a class="ae ka" href="https://github.com/square/coordinators" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">广场/协调者</strong> </a>库存在的原因。</p><p id="6207" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">相反，Flowless引入了<code class="eh lf lg lh li b">FlowLifecycles.ViewLifecycleListener</code>接口，如果你实现了这个接口，那么它将为你提供回调:<code class="eh lf lg lh li b">onViewRestored()</code>和<code class="eh lf lg lh li b">onViewDestroyed()</code>。</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><h2 id="edb5" class="lp kd hu bd ke lq lr ls ki lt lu lv km jn lw lx kq jr ly lz ku jv ma mb ky mc dt translated">额外的生命周期回访</h2><p id="5580" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">在其他情况下，比如写一个<code class="eh lf lg lh li b">CameraView</code>，你可能需要监听许可结果，或者活动结果。</p><p id="1912" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于<code class="eh lf lg lh li b">onActivityResult</code>和<code class="eh lf lg lh li b">onPermissionResult</code>，你需要手动将这些回调委托给调度器。</p><p id="a68f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对您隐藏这一点的一个可能的基本活动如下:</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="3900" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">添加许可结果委托后，调度程序会将该事件转发给当前活动视图。</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="ab2f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这样，您可以在视图中处理任何您需要的生命周期事件回调。</p><h1 id="fd67" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">ServiceProvider:在视图层次结构中共享服务</h1><p id="7b40" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">这是无流中的一个新类，它的对应物曾经是<code class="eh lf lg lh li b">Flow.Services</code>。与其相对应的<code class="eh lf lg lh li b">ServiceFactory</code>。<code class="eh lf lg lh li b">ServiceProvider</code>实际上只是一个<code class="eh lf lg lh li b">Map&lt;Object, Map&lt;String, Object&gt;&gt;</code>，它存储在Flow的<code class="eh lf lg lh li b">InternalLifecycleIntegration</code>中，以在配置变化时保存它们，这与本质上是一个<code class="eh lf lg lh li b">Map&lt;String, Map&lt;String, Object&gt;&gt;</code>的Mortar非常相似。当然，这种情况下的初始键是<code class="eh lf lg lh li b">Key</code>本身，而不是指定为字符串的“作用域名称”。</p><p id="2ab5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不同之处在于，在最初的流1.0-alpha2中，<code class="eh lf lg lh li b">Flow.Services</code>是基于引用计数、基于诸如<code class="eh lf lg lh li b">TreeKey</code>或<code class="eh lf lg lh li b">MultiKey</code>之类的接口在内部管理的。这可能会导致问题，即使你不使用它，这是导致崩溃，使我分叉流，并创建无流摆在首位。</p><p id="cf40" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">相反，在Flowless中，<code class="eh lf lg lh li b">ServiceProvider</code>希望您在Dispatcher中以您认为合适的方式设置它。</p><p id="7be3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过<a class="ae ka" href="https://github.com/Zhuinden/realm-book-example/commit/619546401dcade1fbc02001e8b12d71bfcec2952" rel="noopener ugc nofollow" target="_blank">重新定义</a> <code class="eh lf lg lh li b"><a class="ae ka" href="https://github.com/Zhuinden/realm-book-example/commit/619546401dcade1fbc02001e8b12d71bfcec2952" rel="noopener ugc nofollow" target="_blank">getSystemService()</a></code>的魔力，<code class="eh lf lg lh li b">ServiceProvider</code>允许你从你的上下文中获得任何服务，就像你可以通过<code class="eh lf lg lh li b">Flow.get(context)</code>获得流量一样。</p><h2 id="f2a1" class="lp kd hu bd ke lq lr ls ki lt lu lv km jn lw lx kq jr ly lz ku jv ma mb ky mc dt translated">共享Dagger2组件</h2><p id="4af0" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">在MVP示例中，这就是如何在视图层次结构中向下提供作用域组件的。这允许我们从任何上下文中获取Dagger2组件—主要是在自定义视图的视图层次结构中。</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><h1 id="4e1e" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">Dispatcher:它决定了状态改变时会发生什么</h1><p id="9199" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">基于流的应用程序的最后也是最重要的组件是它的Dispatcher实现。这是全局处理，当你从A键到b键时应该发生的事情。</p><p id="4b3c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最典型的实现将保持前一视图的状态，膨胀新视图，将状态恢复到新视图，移除前一视图，添加新视图，并回调以发出完成信号。</p><p id="1fd9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以下示例还通过<code class="eh lf lg lh li b">DaggerService.TAG</code>添加Dagger2组件，并将其与给定的键相关联，从而使该组件在视图层次结构中可访问。</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="5906" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在中间，您可以看到为当前键设置的服务:Dagger2组件。</p><p id="65cd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这基本上就是“奇迹”发生的地方。在本例中，它有60行注释，而FragmentManager有2000行。我想简单就是胜利。</p><h1 id="9cf3" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">结论</h1><p id="95aa" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">希望这有助于理解如何使用<a class="ae ka" href="https://github.com/Zhuinden/flowless/" rel="noopener ugc nofollow" target="_blank">无流</a>，以及如何创建一个简单的基于MVP(或者甚至是基于MVVM的数据绑定或RxJava！)应用程序，除了明确的背景说明之外，不使用片段或任何种类的附加“神秘民间传说”。</p><p id="d7e7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该应用程序仅由简单的可打包POJOs驱动，你只需编写一次如何在状态之间切换。比<code class="eh lf lg lh li b">FragmentTransaction</code>和<code class="eh lf lg lh li b">Intent</code>都简单</p><p id="1236" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">本文中多次引用的例子在<a class="ae ka" href="https://github.com/Zhuinden/flowless/tree/master/flowless-mvp-example" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">这里</strong> </a>可用。流主要负责<code class="eh lf lg lh li b">presentation</code>层的工作方式。</p><div class="lj lk ll lm fq ab cb"><figure class="md iv me mf mg mh mi paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="md iv me mf mg mh mi paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="md iv me mf mg mh mi paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mj mk ml"><p id="f922" class="jc jd kb je b jf jg jh ji jj jk jl jm mm jo jp jq mn js jt ju mo jw jx jy jz hn dt translated"><a class="ae ka" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是阿妹家庭的一员。我们现在<a class="ae ka" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ka" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd kb je b jf jg jh ji jj jk jl jm mm jo jp jq mn js jt ju mo jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ka" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ka" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mp"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="mq lo l"/></div></figure></div></div>    
</body>
</html>