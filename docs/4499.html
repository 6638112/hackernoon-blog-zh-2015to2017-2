<html>
<head>
<title>Assume It Worked and Fix Later</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">假设它工作了，以后再修复</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/assume-it-worked-and-fix-later-8436d18b7ed3?source=collection_archive---------12-----------------------#2017-06-05">https://medium.com/hackernoon/assume-it-worked-and-fix-later-8436d18b7ed3?source=collection_archive---------12-----------------------#2017-06-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="79b5" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">如何让你的应用更快更可靠</h1><p id="2b69" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">在帐户注册期间，web服务器将发出HTTP请求来发送电子邮件。不仅同步请求很慢，而且如果远程主机没有响应，应用程序也会变得没有响应。</p><p id="e0d8" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">提高<a class="ae ks" href="https://hackernoon.com/tagged/performance" rel="noopener ugc nofollow" target="_blank">性能</a>的一个简单方法是使用像<code class="eh kt ku kv kw b"><a class="ae ks" href="https://hackage.haskell.org/package/async" rel="noopener ugc nofollow" target="_blank">async</a></code>这样的库，在进行其他计算的同时并发地发出请求。然而，如果您需要一个传出的<a class="ae ks" href="https://hackernoon.com/tagged/network" rel="noopener ugc nofollow" target="_blank">网络</a>请求的结果，如果远程主机关闭，您仍然会遇到可靠性问题。</p><p id="ded3" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">通常，当处理程序发出请求时，从客户端的角度来看，不需要响应。注册电子邮件可以满足这个标准，但时间敏感的通知是一个更好的例子，因为它们通常是尽力而为的服务。</p><p id="169f" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">如果您的电子邮件服务中断，不管怎样，让注册成功都是有益的。通过将电子邮件请求的成功与帐户注册的成功分离，您可以提高应用程序的可靠性。这是标题的“假设它工作了”部分，您仍然需要持久化发送了哪些消息的记录和发送它们的定期作业，这是“以后修复它”部分。根据您的需求，可能根本没有“修复”阶段。</p><p id="63be" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">在理想情况下，您应该有一个像Kafka这样的持久队列服务，与您的服务器位于同一位置，具有低延迟或亚毫秒延迟。这个神奇的卡夫卡是比我将要提出的更好更简单的解决方案。然而，你可能不会发现自己处在这样一个幸运的环境中。</p><p id="c103" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">我将通过一个例子，使用亚马逊简单邮件服务和相应的<code class="eh kt ku kv kw b"><a class="ae ks" href="https://hackage.haskell.org/package/amazonka" rel="noopener ugc nofollow" target="_blank">amazonka</a></code>包、<code class="eh kt ku kv kw b"><a class="ae ks" href="https://hackage.haskell.org/package/amazonka-ses" rel="noopener ugc nofollow" target="_blank">amazonka-ses</a></code>，让邮件变得不阻塞。</p><h1 id="f098" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">同步基线</h1><p id="4aa3" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">最简单的方法是打电话给AWS SES inline发送电子邮件。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="b64a" class="lf is hu kw b fv lg lh l li lj">post "/user" $ do<br/>  input &lt;- Scotty.body<br/>  email &lt;- maybe missingEmailError return<br/>         $ input ^? key "email" . _String</span><span id="11d0" class="lf is hu kw b fv lk lh l li lj">  resp &lt;- liftIO<br/>        $ runResourceT<br/>        $ runAWS env<br/>        $ AWS.send<br/>        $ makeEmail email</span><span id="5637" class="lf is hu kw b fv lk lh l li lj">  logFailedRequest resp</span><span id="afca" class="lf is hu kw b fv lk lh l li lj">  -- Imagine there is code here for <br/>  -- inserting a user into the database</span><span id="aa9d" class="lf is hu kw b fv lk lh l li lj">  json $ object ["id" .= email]</span></pre><h1 id="fcb3" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">尝试1:分叉线程</h1><p id="a0e0" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">实现非阻塞异步行为的一个简单方法是在每次需要发送电子邮件时分叉一个线程。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="b8e8" class="lf is hu kw b fv lg lh l li lj">liftIO $ forkIO $ handle logExcept $ do<br/>  resp &lt;- liftIO<br/>        $ runResourceT<br/>        $ runAWS env<br/>        $ AWS.send<br/>        $ makeEmail email</span><span id="e049" class="lf is hu kw b fv lk lh l li lj">  logFailedRequest resp</span></pre><p id="9e7d" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">如果AWS变慢，或者超时，我的线程就会排队。线程将开始消耗资源，如果情况变得足够糟糕，我的应用程序可能会变得无响应和崩溃。</p><p id="1a14" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">分叉另一个线程已经解决了典型案例中的性能问题，但是如果AWS SES下降，我增加了<strong class="jr hv">系统风险。一个关闭的电子邮件服务现在可以导致我的整个应用程序崩溃。以前，只有账户创建请求会失败。</strong></p><h1 id="dddf" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">解决方案1:添加超时线程</h1><p id="7e2b" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">为了限制可以累积的线程数量，我们可以添加一个超时:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="7c26" class="lf is hu kw b fv lg lh l li lj">liftIO $ forkIO $ handle logExcept $ <br/>  logTimeout &lt;=&lt; timeout (60 * 1000000) $ do<br/>    resp &lt;- liftIO<br/>          $ runResourceT<br/>          $ runAWS env<br/>          $ AWS.send<br/>          $ makeEmail email<br/>    logFailedRequest resp</span></pre><p id="1fd9" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">只要注册率低于我们的最大并发请求数，有问题的电子邮件服务就不会关闭我们的网站。</p><p id="542e" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">不利的一面是，我们是否阻止了灾难性的失败还不太清楚。首先，我们需要估计并发注册的最大数量。如果我们的注册率是每分钟10，000人，而电子邮件服务正在下降，我们可能会有麻烦……但即使电子邮件服务在上升，我们也可能会有麻烦。报名的人很多。此外，我们选择了一分钟的任意时间作为超时时间。这可能是一个太小的值，我们正在超时的潜在成功的电子邮件请求。</p><p id="9dd9" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">我们也没有任何方法来限制同时请求的并发性，或者确保所有的线程在我们关闭之前已经完成。这种变化可能是一个解决方案，但它留下了改进的空间。</p><h1 id="3d30" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">解决方案2:有界队列</h1><p id="543e" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我们需要一种快速排队通知请求的方法，而不是为每个请求分配一个线程。队列应该是有界的，有非阻塞写(我们将只记录失败)和阻塞读，所以<code class="eh kt ku kv kw b">TBMQueue</code>就足够了。</p><p id="22ff" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">首先，我们在服务器启动期间创建队列和工作线程:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="0ccb" class="lf is hu kw b fv lg lh l li lj">worker :: Env -&gt; TBMQueue SendEmail -&gt; IO ()<br/>worker env queue = do<br/>  -- Make a loop enclosing the thread, env, and queue vars.<br/>  let go = do<br/>        -- Block waiting for a new email to send<br/>        mpayload &lt;- liftIO $ atomically $ readTBMQueue queue<br/>        case mpayload of<br/>         -- Nothing means the queue is closed and empty.<br/>         -- Stop the loop ending the thread<br/>          Nothing -&gt; return ()<br/>          Just payload -&gt; do<br/>            resp &lt;- AWS.send payload<br/>            logFailedRequest resp</span><span id="ff26" class="lf is hu kw b fv lk lh l li lj">            -- Start the loop again<br/>            go</span><span id="8353" class="lf is hu kw b fv lk lh l li lj">  handle logExcept $ runResourceT $ runAWS env go</span><span id="98fa" class="lf is hu kw b fv lk lh l li lj">main = do <br/>  env      &lt;- newEnv Discover  <br/>  queue    &lt;- newTBMQueueIO 100000<br/>  threadId &lt;- forkIO $ worker env queue<br/>  scotty ...</span></pre><p id="ff45" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">我们为排队编写了一个简单的助手函数:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="30cd" class="lf is hu kw b fv lg lh l li lj">enqueueEmail :: TBMQueue SendEmail -&gt; Text -&gt; IO ()<br/>enqueueEmail queue email = do<br/>  msuccess &lt;- atomically<br/>            $ tryWriteTBMQueue queue<br/>            $ makeEmail email</span><span id="3d9a" class="lf is hu kw b fv lk lh l li lj">  case msuccess of <br/>    Nothing -&gt; putStrLn "Wat!! The email queue is closed?"<br/>    Just success -&gt; unless success <br/>                  $ putStrLn "Failed to enqueue email!"</span></pre><p id="629f" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">然后我们可以在处理程序中使用<code class="eh kt ku kv kw b">queue</code>:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="a396" class="lf is hu kw b fv lg lh l li lj">post "/user" $ do<br/>  input &lt;- Scotty.body<br/>  email &lt;- maybe missingEmailError return<br/>         $ input ^? key "email" . _String</span><span id="8111" class="lf is hu kw b fv lk lh l li lj">  liftIO $ enqueueEmail queue email<br/>  json $ object ["id" .= email]</span></pre><p id="0342" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">我们结束了。无论电子邮件服务的速度有多慢，我们的应用程序最多只会使用我们有限队列中的内存(很小),并且只使用工作线程所需的资源。我们最坏的情况是，我们将无法发送一些电子邮件，但我们的应用程序将保持稳定，性能将是好的。</p><h1 id="ec3a" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">让它成真</h1><p id="263f" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">好吧，我们还没完。我们必须在关机时优雅地处理排队。我们还必须在异常后重启线程。</p><p id="4865" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">为了帮助我们进行关机和重启，我们将使用一个名为<code class="eh kt ku kv kw b">immortal</code>的库。<code class="eh kt ku kv kw b">immortal</code>提供在异常后重启的线程，我们可以等待它们的完成。它还使用适当的异常屏蔽卫生来在新产生的线程上设置异常处理程序，我在上面的示例中省略了这一点(但是在<a class="ae ks" href="https://github.com/jfischoff/asynchronous-email-example" rel="noopener ugc nofollow" target="_blank">示例项目</a>中更好，对于这些示例来说也没什么关系)。</p><p id="b5b7" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">我们的新员工功能如下所示:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="d7b5" class="lf is hu kw b fv lg lh l li lj">worker :: Thread -&gt; Env -&gt; TBMQueue SendEmail -&gt; IO ()<br/>worker thread env queue = do<br/>  -- Make a loop enclosing the thread, env, and queue vars.<br/>  let go :: AWS ()<br/>      go = do<br/>        -- Block waiting for a new email to send<br/>        mpayload &lt;- liftIO $ atomically $ readTBMQueue queue<br/>        case mpayload of<br/>         -- Nothing means the queue is closed and empty.<br/>         -- Stop the loop and kill the thread.<br/>          Nothing -&gt; liftIO $ stop thread<br/>          Just payload -&gt; do<br/>            resp &lt;- AWS.send payload<br/>            logFailedRequest resp</span><span id="f88d" class="lf is hu kw b fv lk lh l li lj">            -- Start the loop again<br/>            go</span><span id="c6c3" class="lf is hu kw b fv lk lh l li lj">handle logExcept $ runResourceT $ runAWS env go</span></pre><p id="b4f6" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">唯一改变的是，我们现在接收一个<code class="eh kt ku kv kw b">Thread</code>并在队列为空时停止<code class="eh kt ku kv kw b">Thread</code>，并用:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="6fd1" class="lf is hu kw b fv lg lh l li lj">Nothing -&gt; liftIO $ stop thread</span></pre><p id="6d59" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">为了在我们的<code class="eh kt ku kv kw b">main</code>函数中创建线程，我们编写:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="6420" class="lf is hu kw b fv lg lh l li lj">thread &lt;- create $ \thread -&gt; worker thread env queue</span></pre><p id="a216" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">就在<code class="eh kt ku kv kw b">main</code>结束之前，我们添加:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="1d21" class="lf is hu kw b fv lg lh l li lj">atomically $ closeTBMQueue queue<br/>wait thread</span></pre><p id="cda9" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">这将关闭<code class="eh kt ku kv kw b">queue</code>并防止程序退出，直到<code class="eh kt ku kv kw b">queue</code>被排空。我将此扩展到了<a class="ae ks" href="https://github.com/jfischoff/asynchronous-email-example" rel="noopener ugc nofollow" target="_blank">示例项目</a>中的多个工人。</p><h1 id="6a36" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">进一步的考虑</h1><p id="638b" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">在我们的简单例子中，我们仅仅是记录问题，但是一个真实的系统可能想要填充丢失的电子邮件；拥有一种存储哪些客户已经收到电子邮件的方法可能会有所帮助。</p><p id="3027" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">此外，应该扩展循环，以发出对监控有用的事件，比如将队列大小发送到度量服务器。我将在以后的博客文章中介绍这一点，作为奖励，将包括一个测试命令式代码的技巧。</p><h1 id="e4bd" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">结论</h1><p id="43ca" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">这里的步骤越来越复杂，开发人员的工作量也越来越大。编写最终版本并不需要花费太多时间，但是可以根据您的需求和经验进行扩展(我会跳过尝试一…只需添加超时)；只要确保你明白权衡。最终拥有一个像Kafka一样持久的队列可能是最好的，但是有选择总是好的。</p><p id="9efc" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">“稍后修复”部分将需要轮询数据库中未发送的电子邮件。我还不知道怎么做。通过使用内存中的队列，可以减少及时发送电子邮件所需的轮询时间。此外，在除注册电子邮件之外的其他情况下，例如对时间敏感的实时通知，您可能<strong class="jr hv">而</strong>根本不需要回填丢失的通知。很容易使用，所以我选择它作为例子。</p><p id="48b7" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">如果你想试试上面的例子，看看这个展示web服务器项目，它突出了这些例子:<a class="ae ks" href="https://github.com/jfischoff/asynchronous-email-example" rel="noopener ugc nofollow" target="_blank">https://github.com/jfischoff/asynchronous-email-example</a></p><blockquote class="ll lm ln"><p id="3475" class="jp jq lo jr b js kn ju jv jw ko jy jz lp kp kc kd lq kq kg kh lr kr kk kl km hn dt translated"><a class="ae ks" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ks" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ks" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae ks" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="jp jq lo jr b js kn ju jv jw ko jy jz lp kp kc kd lq kq kg kh lr kr kk kl km hn dt translated">要了解更多信息，请<a class="ae ks" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae ks" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae ks" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="jp jq lo jr b js kn ju jv jw ko jy jz lp kp kc kd lq kq kg kh lr kr kk kl km hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ks" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ks" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kx ky kz la fq ls"><div class="bz el l di"><div class="lt lu l"/></div></figure></div></div>    
</body>
</html>