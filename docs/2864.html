<html>
<head>
<title>Testing our iOS networking layer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试我们的iOS网络层</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/unit-testing-our-ios-network-layer-d0a83172aa66?source=collection_archive---------3-----------------------#2017-02-24">https://medium.com/hackernoon/unit-testing-our-ios-network-layer-d0a83172aa66?source=collection_archive---------3-----------------------#2017-02-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="5ab8" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">为什么？</h1><p id="9c50" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">在过去的一周里，我一直在WeVat重构我们的网络层。对于可能由<a class="ae kn" href="https://hackernoon.com/tagged/network" rel="noopener ugc nofollow" target="_blank">网络</a>引起的错误场景的单元测试覆盖率非常低，所以我认为这是一个撒下更大网的好机会，以确保我们的网络重构不会引入任何麻烦🐞、🕷或🐜南</p><p id="ac47" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">下面我将简要解释我们正在使用的单元测试套件，然后将转移到我们如何在不编写大量代码的情况下动态测试多个错误场景。</p><h1 id="e37a" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">方法</h1><p id="c39c" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated"><strong class="jr hv">ohhttpsubs</strong></p><p id="8dce" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">我在以前的一个项目上使用过<a class="ae kn" href="https://github.com/AliSoftware/OHHTTPStubs" rel="noopener ugc nofollow" target="_blank"> OHTTPStubs </a>，它似乎是iOS的网络存根库的行业标准。它提供了一套工具来帮助清除任何使用<code class="eh kt ku kv kw b">NSURLConnection, NSURLSession</code>或<code class="eh kt ku kv kw b">Alamofire</code>进行的网络调用，因此非常适合我们这里的需求。</p><p id="9f86" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">我还在库周围创建了一个小包装器，以我们需要的方式向我们提供所有的存根代码。</p><p id="59a1" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">下面的方法让我们能够用一个200和一个定义好的<a class="ae kn" href="https://hackernoon.com/tagged/json" rel="noopener ugc nofollow" target="_blank"> JSON </a>响应来连接网络。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="4dca" class="lf is hu kw b fv lg lh l li lj">static func stubNetwork(forService service: Service.Type) {</span><span id="c8b8" class="lf is hu kw b fv lk lh l li lj">     stub(condition: isHost(baseUrl)) { _ in<br/>          guard let path = OHPathForFileInBundle(stubPath(forService: service), Bundle.main) else {<br/>      preconditionFailure(“Stub not found!”)<br/>     }</span><span id="c1f5" class="lf is hu kw b fv lk lh l li lj">      return OHHTTPStubsResponse(<br/>         fileAtPath: path,<br/>         statusCode: 200,<br/>         headers: [ “Content-Type”: “application/json” ]<br/>        )<br/>     }<br/>}</span></pre><p id="f5f7" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">我会解释这里发生了什么</p><ol class=""><li id="368a" class="ll lm hu jr b js ko jw kp ka ln ke lo ki lp km lq lr ls lt dt translated">我们传入我们想要存根的服务类型。服务是一种协议，我们所有的服务都遵循这种协议。这提供了切换服务的能力。键入并提供每个服务所需的存根数据。</li><li id="7ab5" class="ll lm hu jr b js lu jw lv ka lw ke lx ki ly km lq lr ls lt dt translated">我们给存根一个条件。这将是我们想要存根的主机url。它将存根任何请求与这个网址。</li><li id="74aa" class="ll lm hu jr b js lu jw lv ka lw ke lx ki ly km lq lr ls lt dt translated">我们获得本地文件路径，该路径保存响应的JSON数据。</li><li id="caa5" class="ll lm hu jr b js lu jw lv ka lw ke lx ki ly km lq lr ls lt dt translated">返回这个文件，清除所有使用这个url的请求，直到使用<code class="eh kt ku kv kw b">OHHTTPStubs.removeAllStubs()</code>删除这个存根。</li></ol><p id="2d0c" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated"><strong class="jr hv">敏捷</strong></p><p id="fd24" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">我们选择减少使用XCTest提供的一些更冗长的语法和编码结构，并继续使用<a class="ae kn" href="https://github.com/Quick/Nimble" rel="noopener ugc nofollow" target="_blank"> Nimble </a>框架。</p><p id="520c" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">这让我们从建立期望</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="39c8" class="lf is hu kw b fv lg lh l li lj">let expect = expectation(description: “Get Receipts”)<br/>...<br/>expect.fulfill()<br/>...<br/>waitForExpectations(timeout: 2) { (error) in<br/>    XCTAssertTrue(asyncReceipts?.count &gt; 0)<br/>}</span></pre><p id="41e4" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">简单来说:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="28a8" class="lf is hu kw b fv lg lh l li lj">expect(asyncReceipts!.count &gt; 0).toEventually(beTrue())</span></pre><p id="b493" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt">👍🏻👍🏻👍🏻</p><p id="9201" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated"><strong class="jr hv">测试🙂路径</strong></p><p id="6ef7" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">这应该在单个测试案例中得到证明。只需设置成功存根，调用服务并断言异步结果已经实现。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="18dc" class="lf is hu kw b fv lg lh l li lj">var asyncReceipts: [Receipts]?<br/>StubHelper.stubNetwork(forService: GetReceiptsService.self)</span><span id="1917" class="lf is hu kw b fv lk lh l li lj">GetReceiptsService.getReceipts(forUser: UUID().uuidString) { (result) in</span><span id="5870" class="lf is hu kw b fv lk lh l li lj">     switch result {<br/>     case .success(let receipts):<br/>          asyncReceipts = receipts<br/>     default: break<br/>     }<br/>}</span><span id="62ce" class="lf is hu kw b fv lk lh l li lj">expect(asyncReceipts).toEventuallyNot(beNil())<br/>expect(asyncReceipts!.count &gt; 0).toEventually(beTrue())</span></pre><p id="1aa4" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated"><strong class="jr hv">测试🙁路径</strong></p><p id="44b3" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">这是单元测试真正开始证明其价值的地方。</p><p id="2729" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">我们可以类似地为网络调用编写一个测试用例，它将为我们想要测试的错误代码设置存根，调用服务，并断言错误是异步设置的。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="ee40" class="lf is hu kw b fv lg lh l li lj">var asyncError: Error?<br/>stubNetworkWithNoConnection()</span><span id="71a3" class="lf is hu kw b fv lk lh l li lj">GetReceiptsService.getReceipts(forUser: “”) { (result) in</span><span id="9f4f" class="lf is hu kw b fv lk lh l li lj">    switch result {<br/>    case .failure(let error):<br/>         asyncError = error<br/>    default: break<br/>    }<br/>}</span><span id="2c51" class="lf is hu kw b fv lk lh l li lj">expect(asyncError).toEventuallyNot(beNil())<br/>expect(asyncError as! HTTPError).toEventually(equal(HTTPError.noConnection))</span></pre><p id="1c06" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">太酷了。但我听到你说，这似乎可以优化。我们不想每次测试不同的错误时都重复这段代码。</p><h1 id="75f0" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">让我们协议</h1><p id="1141" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">因此，考虑一下我们的需求，我们需要在每个服务上测试来自服务器的每个可能的错误响应。我们还需要断言返回的错误是我们所期望的。</p><p id="fd47" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated"><strong class="jr hv">服务可测试协议</strong></p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="5095" class="lf is hu kw b fv lg lh l li lj">protocol ServiceTestable {</span><span id="80ab" class="lf is hu kw b fv lk lh l li lj">     func testFailures()</span><span id="86c2" class="lf is hu kw b fv lk lh l li lj">     func setupNetworkFailureTest(withStub stub: (() -&gt; Void), andErrorToAssert errorAssertion: HTTPError)</span><span id="4c0b" class="lf is hu kw b fv lk lh l li lj">}</span></pre><p id="8333" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">这里我定义了一个协议，它将为我们如何测试我们的服务类提供一个工具。通过确保我们的服务符合这个协议，我们可以调用<code class="eh kt ku kv kw b">testFailures()</code>，它将为我们需要的每个场景调用<code class="eh kt ku kv kw b">setupNetworkFailureTest()</code>函数。然后，我们将存根和我们想要断言的错误注入到测试中。</p><p id="83a0" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">现在你问的实现在哪里？等一下，我告诉你！</p><p id="edbc" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated"><strong class="jr hv">输入协议扩展</strong></p><p id="9374" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">通过扩展我们的<code class="eh kt ku kv kw b">ServiceTestable</code>协议，我们可以给我们的测试用例一些默认行为。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="4411" class="lf is hu kw b fv lg lh l li lj">extension ServiceTestable where Self: WeVatTests {</span><span id="ebc1" class="lf is hu kw b fv lk lh l li lj">func testFailuresWithStatusCodes() {<br/>         let failures = [</span><span id="7a98" class="lf is hu kw b fv lk lh l li lj">         (stub: StubHelper.stubNetworkWithNotFound, error: HTTPError.notFound),</span><span id="b6a5" class="lf is hu kw b fv lk lh l li lj">         (stub: StubHelper.stubNetworkWithForbidden, error: HTTPError.invalidCredentials),</span><span id="7b28" class="lf is hu kw b fv lk lh l li lj">         (stub: StubHelper.stubNetworkTimeout, error: HTTPError.timeout),</span><span id="39d9" class="lf is hu kw b fv lk lh l li lj">         (stub: StubHelper.stubNetworkNoConnection, error: HTTPError.noConnection),</span><span id="32ed" class="lf is hu kw b fv lk lh l li lj">         (stub: StubHelper.stubNetworkWithBadRequest, error: HTTPError.invalidRequest),</span><span id="e875" class="lf is hu kw b fv lk lh l li lj">         (stub: StubHelper.stubNetworkWithServerError, error: HTTPError.serverError),</span><span id="1985" class="lf is hu kw b fv lk lh l li lj">         (stub: StubHelper.stubNetworkWithUnauthorized, error: HTTPError.invalidCredentials),</span><span id="b591" class="lf is hu kw b fv lk lh l li lj">         (stub: StubHelper.stubNetworkWithServerTimeout, error: HTTPError.timeout)</span><span id="5fe6" class="lf is hu kw b fv lk lh l li lj">           ]</span><span id="783a" class="lf is hu kw b fv lk lh l li lj">         for failure in failures {</span><span id="434b" class="lf is hu kw b fv lk lh l li lj">              setupNetworkFailureTest(withStub: failure.stub, andErrorToAssert: failure.error)</span><span id="0aa3" class="lf is hu kw b fv lk lh l li lj">         }</span><span id="3c90" class="lf is hu kw b fv lk lh l li lj">    }</span><span id="013c" class="lf is hu kw b fv lk lh l li lj">}</span></pre><p id="d0a5" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">这看起来像一大块旧的o '代码，但它将提供相当大的。我们建立了一个元组数组，每个数组元素包含</p><ol class=""><li id="a4fd" class="ll lm hu jr b js ko jw kp ka ln ke lo ki lp km lq lr ls lt dt translated">对我们要使用的存根的引用。</li><li id="00d0" class="ll lm hu jr b js lu jw lv ka lw ke lx ki ly km lq lr ls lt dt translated">我们要反对的错误。</li></ol><p id="972f" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">现在，符合我们的<code class="eh kt ku kv kw b">ServiceTestable</code>协议的类将看起来像这样:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="21d8" class="lf is hu kw b fv lg lh l li lj">class GetReceiptsServiceTests: WeVatTests, ServiceTestable {</span><span id="0d0a" class="lf is hu kw b fv lk lh l li lj">    override func tearDown() {<br/>        super.tearDown()<br/>        StubHelper.unStubNetwork()<br/>    }</span><span id="04eb" class="lf is hu kw b fv lk lh l li lj">    ...</span><span id="a49a" class="lf is hu kw b fv lk lh l li lj">    func testFailures() {<br/>        testFailuresWithStatusCodes()<br/>    }</span><span id="8344" class="lf is hu kw b fv lk lh l li lj">    func setupNetworkFailureTest(withStub stub: (() -&gt; Void), andErrorToAssert errorAssertion: HTTPError) {</span><span id="a40b" class="lf is hu kw b fv lk lh l li lj">        var asyncError: Error?<br/>        stub()</span><span id="94c7" class="lf is hu kw b fv lk lh l li lj">        GetReceiptsService.getReceipts(forUser: UUID().uuidString) { (result) in</span><span id="9a3e" class="lf is hu kw b fv lk lh l li lj">              switch result {<br/>              case .failure(let error):<br/>                 asyncError = error<br/>              default: break<br/>             }<br/>         }</span><span id="4175" class="lf is hu kw b fv lk lh l li lj">         expect(asyncError).toEventuallyNot(beNil())<br/>         expect(asyncError as! HTTPError).toEventually(equal(errorAssertion))<br/>    }<br/>}</span></pre><p id="9625" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">我将带你了解现在的情况:</p><ol class=""><li id="bb48" class="ll lm hu jr b js ko jw kp ka ln ke lo ki lp km lq lr ls lt dt translated">我们现在确保服务测试类符合<code class="eh kt ku kv kw b">ServiceTestable</code>协议</li><li id="55ef" class="ll lm hu jr b js lu jw lv ka lw ke lx ki ly km lq lr ls lt dt translated"><code class="eh kt ku kv kw b">testFailures()</code>在运行我们的单元测试套件时被XCTest调用</li><li id="7beb" class="ll lm hu jr b js lu jw lv ka lw ke lx ki ly km lq lr ls lt dt translated">我们在协议扩展中调用了<code class="eh kt ku kv kw b">testFailuresWithStatusCodes()</code>。</li><li id="c17f" class="ll lm hu jr b js lu jw lv ka lw ke lx ki ly km lq lr ls lt dt translated">对于我们想要的每一个错误，这个扩展在调用我们在<code class="eh kt ku kv kw b">setupNetworkFailureTest</code>中的实现时起作用。</li></ol><h1 id="aac2" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">包裹</h1><p id="f7b9" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我们现在拥有的是一个可扩展的服务层测试工具。当我们添加另一个服务时，很容易将其与ServiceTestable协议联系起来，这将确保所有的错误案例都得到充分的测试。如果我们想添加更多的错误场景，我们可以将它们添加到数组中，并引用它们对应的错误存根。</p><blockquote class="lz ma mb"><p id="f340" class="jp jq mc jr b js ko ju jv jw kp jy jz md kq kc kd me kr kg kh mf ks kk kl km hn dt translated"><a class="ae kn" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是AMI家庭的一员。我们现在<a class="ae kn" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae kn" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="jp jq mc jr b js ko ju jv jw kp jy jz md kq kc kd me kr kg kh mf ks kk kl km hn dt translated">要了解更多信息，<a class="ae kn" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">请阅读我们的“关于”页面</a> , <a class="ae kn" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">喜欢/在脸书给我们发消息</a>，或者简单地，<a class="ae kn" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank">发推文/DM @HackerNoon。</a></p><p id="708a" class="jp jq mc jr b js ko ju jv jw kp jy jz md kq kc kd me kr kg kh mf ks kk kl km hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kn" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kn" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kx ky kz la fq mg"><div class="bz el l di"><div class="mh mi l"/></div></figure></div></div>    
</body>
</html>