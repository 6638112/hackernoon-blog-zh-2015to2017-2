<html>
<head>
<title>Determining file format using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python确定文件格式</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/determining-file-format-using-python-c4e7b18d4fc4?source=collection_archive---------4-----------------------#2017-12-31">https://medium.com/hackernoon/determining-file-format-using-python-c4e7b18d4fc4?source=collection_archive---------4-----------------------#2017-12-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="9b5a" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">史前史</h1><p id="98a9" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">大家好！最近，我遇到了一个问题:由于无法解释的原因，存储卡开始将所有文件移动到LOST。没有任何扩展名的目录文件夹。长期以来，这里积累了500多种不同类型的文件:图片、视频、音频、文档。不可能独立理解<a class="ae kn" href="https://hackernoon.com/tagged/file" rel="noopener ugc nofollow" target="_blank">文件</a>的格式，所以我开始寻找一种以编程方式解决这个问题的方法。</p><h1 id="846f" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">寻找决策</h1><p id="f43f" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我不想使用web服务或程序形式的现成解决方案，所以有一个想法是编写一个控制台实用程序，它将检查所有文件并自动安装扩展。<a class="ae kn" href="https://hackernoon.com/tagged/python" rel="noopener ugc nofollow" target="_blank"> Python </a>被选中来编写这个实用程序。对合适的模块和库的搜索没有带来结果，原因有几个:</p><ul class=""><li id="0f59" class="ko kp hu jr b js kq jw kr ka ks ke kt ki ku km kv kw kx ky dt translated">缺乏开发商的支持</li><li id="c6b0" class="ko kp hu jr b js kz jw la ka lb ke lc ki ld km kv kw kx ky dt translated">功能过多</li><li id="9b6c" class="ko kp hu jr b js kz jw la ka lb ke lc ki ld km kv kw kx ky dt translated">缺乏对新版本Python的支持</li><li id="ef90" class="ko kp hu jr b js kz jw la ka lb ke lc ki ld km kv kw kx ky dt translated">过度的代码复杂性</li></ul><p id="d0a9" class="pw-post-body-paragraph jp jq hu jr b js kq ju jv jw kr jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">在众多的库中，python-magic非常受欢迎(GitHub上几乎有1000颗星)。这是libmagic库的包装器。但是如果没有Unix库的DLL，就不可能在Windows下使用python-magic。所以这个选项不够好。</p><h1 id="62ac" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">问题的解决方案</h1><p id="9219" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">从上面开始，我决定不使用第三方库和模块，不用它们来解决问题。在对如何实现这一任务的信息进行了简短的搜索之后，唯一正确的方法是通过文件的签名(也称为“幻数”)来确定格式。</p><p id="5e0b" class="pw-post-body-paragraph jp jq hu jr b js kq ju jv jw kr jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">文件签名是提供文件格式定义的一组字节。该签名具有以下十六进制表示形式:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="95f4" class="lq is hu lm b fv lr ls l lt lu">50 4D 4F 43 43 4D 4F 43</span></pre><p id="ee19" class="pw-post-body-paragraph jp jq hu jr b js kq ju jv jw kr jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">幸运的是，互联网上有两个不错的网站，有很多不同格式的签名。最常见的格式成为目标。<br/>事实证明，有些签名适用于不同的文件格式，比如微软Office文件的签名。基于此，在某些情况下，有必要返回合适的文件扩展名列表。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="6bc5" class="lq is hu lm b fv lr ls l lt lu">print(get("D:\\some_ms_office_document")) # prints ['doc', 'ppt', 'xls']</span></pre><p id="68ca" class="pw-post-body-paragraph jp jq hu jr b js kq ju jv jw kr jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">此外，签名通常与文件开头有一个偏移量，如3GP多媒体容器。</p><h1 id="f7a5" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">1.汇编数据列表</h1><p id="9398" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">作为数据列表，我决定使用一个JSON文件，带有“data”对象，它的值将是以下形式的对象数组:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="fcfe" class="lq is hu lm b fv lr ls l lt lu">{"format": "jpg", "offset": 0, "signature": ["FF D8 FF E0", "FF D8 FF E1", "FF D8 FF E2", "FF D8 FF E8"]}</span></pre><p id="9882" class="pw-post-body-paragraph jp jq hu jr b js kq ju jv jw kr jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">其中:</p><ul class=""><li id="f35d" class="ko kp hu jr b js kq jw kr ka ks ke kt ki ku km kv kw kx ky dt translated">格式—文件格式；</li><li id="3b1b" class="ko kp hu jr b js kz jw la ka lb ke lc ki ld km kv kw kx ky dt translated">offset —签名距文件开头的偏移量；</li><li id="fe5e" class="ko kp hu jr b js kz jw la ka lb ke lc ki ld km kv kw kx ky dt translated">签名—适用于指定文件格式的签名数组。</li></ul><h1 id="5fcb" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">2.编写实用程序</h1><p id="b8b3" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">导入必要的模块:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="ca97" class="lq is hu lm b fv lr ls l lt lu">import os<br/>import json</span></pre><p id="b0fc" class="pw-post-body-paragraph jp jq hu jr b js kq ju jv jw kr jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">读取数据列表:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="0f0c" class="lq is hu lm b fv lr ls l lt lu">abspath = os.path.abspath(os.path.dirname(__file__))<br/>data = json.loads(open(os.path.join(abspath, "data.json"), "r", encoding="utf-8").read())["data"]</span></pre><p id="c1eb" class="pw-post-body-paragraph jp jq hu jr b js kq ju jv jw kr jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">太好了，数据列表加载完毕。现在我们将文件作为字节数组来读取。我们将只读取前32个字节，因为确定通用格式并不需要更多，完整读取一个大文件将需要很长时间。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="503c" class="lq is hu lm b fv lr ls l lt lu">file = open("path_to_the_file", "rb").read(32)</span></pre><p id="0453" class="pw-post-body-paragraph jp jq hu jr b js kq ju jv jw kr jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">如果您打印' file '变量，您将会看到类似如下的内容:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="8350" class="lq is hu lm b fv lr ls l lt lu">\x90\x00\x03\x00\x00\x00\x04</span></pre><p id="2405" class="pw-post-body-paragraph jp jq hu jr b js kq ju jv jw kr jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">现在字节必须转换成十六进制系统:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="c6ee" class="lq is hu lm b fv lr ls l lt lu">hex_bytes = " ".join(['{:02X}'.format(byte) for byte in file])</span></pre><p id="4de0" class="pw-post-body-paragraph jp jq hu jr b js kq ju jv jw kr jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">接下来，我们创建一个列表，其中将添加适当的格式:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="1463" class="lq is hu lm b fv lr ls l lt lu">out = []</span></pre><p id="9cbe" class="pw-post-body-paragraph jp jq hu jr b js kq ju jv jw kr jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">现在，我们创建一个循环确定文件格式的结构:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="5700" class="lq is hu lm b fv lr ls l lt lu">for element in data:<br/>        for signature in element["signature"]:<br/>            offset = element["offset"]*2+element["offset"]<br/>            if signature == hex_bytes[offset:len(signature)+offset].upper():<br/>                out.append(element["format"])</span></pre><p id="4171" class="pw-post-body-paragraph jp jq hu jr b js kq ju jv jw kr jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">关于这个字符串:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="7b87" class="lq is hu lm b fv lr ls l lt lu">offset = element["offset"]*2+element["offset"]</span></pre><p id="198d" class="pw-post-body-paragraph jp jq hu jr b js kq ju jv jw kr jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">由于我们的字节表示为一个字符串，两个符号表示一个字节，我们将偏移量乘以2，并在“字节”之间添加空格数。</p><p id="2759" class="pw-post-body-paragraph jp jq hu jr b js kq ju jv jw kr jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">我们唯一要做的就是输出一个合适格式的列表，用‘out’变量表示。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="7c9b" class="lq is hu lm b fv lr ls l lt lu">print(out) # prints something like ['extension_1', 'extension_2']</span></pre><h1 id="50fe" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">结论</h1><p id="5b3c" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">事实证明，各种项目都面临着识别文件格式的需求，所以我决定以开源方式发布我的解决方案，作为Python的一个模块，名为fleep<a class="ae kn" href="https://github.com/floyernick/fleep" rel="noopener ugc nofollow" target="_blank">link to the GitHub page</a>。您可以使用标准python实用程序“pip”安装该模块:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="88c8" class="lq is hu lm b fv lr ls l lt lu">pip install fleep</span></pre><p id="c019" class="pw-post-body-paragraph jp jq hu jr b js kq ju jv jw kr jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">GitHub项目页面上还有使用示例和支持的文件格式的完整列表。<br/>我每天都在改进fleep，增加新的功能和格式。您可以在您的项目中使用它:)</p><h1 id="e50c" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">感谢关注！</h1><p id="86b6" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">附注:我很高兴听到你对我的模块的意见。<br/> P.P.S .英语不是我的母语，因此，请原谅我的任何错误:)</p><figure class="lh li lj lk fq lv"><div class="bz el l di"><div class="lw lx l"/></div></figure></div></div>    
</body>
</html>