<html>
<head>
<title>The rock-solid foundation for Eve’s big vision</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">夏娃远大理想的坚实基础</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-rock-solid-foundation-for-eves-big-vision-225b80b91e11?source=collection_archive---------4-----------------------#2016-12-05">https://medium.com/hackernoon/the-rock-solid-foundation-for-eves-big-vision-225b80b91e11?source=collection_archive---------4-----------------------#2016-12-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="c73e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">欢迎来到我关于<a class="ae jp" href="http://witheve.com/" rel="noopener ugc nofollow" target="_blank"> Eve </a>的系列文章的第五部分，这是一种令人兴奋和着迷的新编程语言。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff jq"><img src="../Images/5d00ee5f811d19fdacd64945cf7dc021.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*c42MkKUBa0HE3th2MG8pDw.png"/></div></figure><ul class=""><li id="4c89" class="jy jz hu it b iu iv iy iz jc ka jg kb jk kc jo kd ke kf kg dt translated"><a class="ae jp" href="https://hackernoon.com/how-eve-unifies-your-entire-programming-stack-900ca80c58a7" rel="noopener ugc nofollow" target="_blank"><em class="kh">I .</em>Eve如何统一你的整个编程栈</a></li><li id="96c2" class="jy jz hu it b iu ki iy kj jc kk jg kl jk km jo kd ke kf kg dt translated"><a class="ae jp" href="https://hackernoon.com/when-logic-programming-meets-cqrs-1137ab2a5f86" rel="noopener ugc nofollow" target="_blank"> <em class="kh">二世。</em>当逻辑编程遇上CQRS </a></li><li id="f94d" class="jy jz hu it b iu ki iy kj jc kk jg kl jk km jo kd ke kf kg dt translated"><a class="ae jp" href="https://hackernoon.com/throwing-off-our-scope-chains-7567beb2d0b6" rel="noopener ugc nofollow" target="_blank"> <em class="kh">三世。</em>挣脱我们的镜链</a></li><li id="f2b6" class="jy jz hu it b iu ki iy kj jc kk jg kl jk km jo kd ke kf kg dt translated"><a class="ae jp" href="https://hackernoon.com/smalltalk-and-protein-programming-4da245ac93e2" rel="noopener ugc nofollow" target="_blank"> <em class="kh">四世。</em> Smalltalk和蛋白质编程</a></li><li id="c7b5" class="jy jz hu it b iu ki iy kj jc kk jg kl jk km jo kd ke kf kg dt translated"><strong class="it hv"> <em class="kh">五、</em>夏娃远大理想的坚实基础</strong></li><li id="a91e" class="jy jz hu it b iu ki iy kj jc kk jg kl jk km jo kd ke kf kg dt translated"><a class="ae jp" href="https://hackernoon.com/why-eve-will-be-perfect-for-realtime-apps-92b965b80ad" rel="noopener ugc nofollow" target="_blank"> <em class="kh">六。</em>为什么Eve是实时应用的完美选择</a></li></ul></div><div class="ab cl kn ko hc kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hn ho hp hq hr"><blockquote class="ku kv kw"><p id="be97" class="ir is kh it b iu iv iw ix iy iz ja jb kx jd je jf ky jh ji jj kz jl jm jn jo hn dt translated">还有很多事情要做，还有很多事情要弄清楚，但幸运的是，我们有一个良好的基础，我们可以利用它来确保事情不会偏离轨道太远。很高兴知道，只要我们可以将我们的语义解析回X，我们就可以保持X的属性。这是一件非常困难的事情，但结果似乎是这样的:)</p></blockquote><p id="4927" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">— <a class="la lb gr" href="https://medium.com/u/2826fea8bb47?source=post_page-----225b80b91e11--------------------------------" rel="noopener" target="_blank">克里斯·格兰杰</a>，Eve的创始人之一。</p><p id="d648" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这篇文章中，我将尝试通过列出我认为Eve可以从根本上改进的编程领域来解开Chris的说法，这要归功于其核心构建块的属性。</p><h1 id="3695" class="lc ld hu bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz dt translated">声明式编程</h1><p id="ed74" class="pw-post-body-paragraph ir is hu it b iu ma iw ix iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo hn dt translated">数据库通常有<a class="ae jp" href="https://en.wikipedia.org/wiki/Declarative_programming" rel="noopener ugc nofollow" target="_blank">声明性的</a>查询语言语义。在一个SQL <code class="eh mf mg mh mi b">SELECT</code>查询中，你说<em class="kh">你想要搜索什么</em>数据，而不是<em class="kh">查询计划器应该如何</em>去寻找它。</p><p id="360d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是应用层语言通常没有声明性语义。如<a class="ae jp" href="http://www.datomic.com/" rel="noopener ugc nofollow" target="_blank">文档</a>在其查询<a class="ae jp" href="http://remarks" rel="noopener ugc nofollow" target="_blank">文档</a>中所述:</p><blockquote class="ku kv kw"><p id="2d19" class="ir is kh it b iu iv iw ix iy iz ja jb kx jd je jf ky jh ji jj kz jl jm jn jo hn dt translated">独立编程是非常强大的，遗憾的是它已经被降级到数据库服务器，而不为应用程序员所用。</p></blockquote><p id="e79a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">语言总是为声明性结构提供一些支持，比如获得一个数组的过滤视图:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mj mk l"/></div></figure><p id="8894" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但通常它并没有融入到语言的基本构件中；例如，您无法获得变量的过滤视图:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mj mk l"/></div></figure><p id="0731" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用Eve，您可以声明性地读取您的应用层状态，因为您可以在堆栈的每一层使用与数据库层<a class="ae jp" href="https://hackernoon.com/how-eve-unifies-your-entire-programming-stack-900ca80c58a7" rel="noopener ugc nofollow" target="_blank">相同的<code class="eh mf mg mh mi b">search</code>操作。</a></p><h1 id="cd94" class="lc ld hu bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz dt translated">验证数据</h1><h2 id="b3af" class="ml ld hu bd le mm mn mo li mp mq mr lm jc ms mt lq jg mu mv lu jk mw mx ly my dt translated">数据库数据</h2><p id="e988" class="pw-post-body-paragraph ir is hu it b iu ma iw ix iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo hn dt translated">想象一下您的应用程序的数据库现在是什么样子。它可能有各种您没有意识到的数据验证问题，对吗？</p><p id="25fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在您的程序插入违规数据时，要么它有一个bug，要么它运行的是以前版本的代码，对什么是有效的有不同的想法。然后，当您修复bug或更新您的程序逻辑时，您没有一个简单的方法来清除可能存在的每个小的不一致。所以你说，“管它呢，我只要在收到错误报告时修复它们就行了”。</p><h2 id="c9c0" class="ml ld hu bd le mm mn mo li mp mq mr lm jc ms mt lq jg mu mv lu jk mw mx ly my dt translated">应用状态</h2><p id="f9e9" class="pw-post-body-paragraph ir is hu it b iu ma iw ix iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo hn dt translated">在应用层有一个类似的问题:你有多确信你的<em class="kh">状态</em>总是正确的？即使你有很多断言，他们也很难监管你的整个程序。</p><h2 id="d1b0" class="ml ld hu bd le mm mn mo li mp mq mr lm jc ms mt lq jg mu mv lu jk mw mx ly my dt translated">伊夫溶液</h2><p id="3baf" class="pw-post-body-paragraph ir is hu it b iu ma iw ix iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo hn dt translated">使用Eve，您只需编写一小段代码，就可以得到一个全局数据验证规则，如下所示:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="fe ff mz"><img src="../Images/97f2be52407c0d1137fe6d54b973b04f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hv74ejdLmOWLlmDO2RV4Hw.png"/></div></div><figcaption class="ne nf fg fe ff ng nh bd b be z ek"><a class="ae jp" href="http://witheve.com/" rel="noopener ugc nofollow" target="_blank">witheve.com</a></figcaption></figure><p id="b737" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">关键是这个代码块不必被另一个代码块调用；<em class="kh">它被它监视的无效数据调用</em>！这就是为什么Eve比传统的数据库和编程语言有更好的数据验证基础。</p><h1 id="9127" class="lc ld hu bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz dt translated">类型和模式</h1><p id="b21f" class="pw-post-body-paragraph ir is hu it b iu ma iw ix iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo hn dt translated">类型和模式实际上只是数据块应该遵守的约束。这意味着我们可以通过编写如上的数据验证块在Eve中构建类型系统和模式。嗯，你和我可能不会这样做，但这是建立各种更高级别库的基础。</p><h1 id="99a7" class="lc ld hu bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz dt translated">依赖性跟踪</h1><p id="0146" class="pw-post-body-paragraph ir is hu it b iu ma iw ix iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo hn dt translated">假设你的程序有一个变量<code class="eh mf mg mh mi b">x</code>，在不同的点上，它也需要知道<code class="eh mf mg mh mi b">x</code>的值，四舍五入到最近的一百:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mj mk l"/></div></figure><p id="047f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">嗯，你可能不想给<code class="eh mf mg mh mi b">nearestHundred</code>它自己的变量，因为你不想让它在你的程序状态中成为一个独立的自由度；你的意思是它是<code class="eh mf mg mh mi b">x</code>的固定<strong class="it hv">依赖</strong>。因此，你可以把它写成一个函数:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mj mk l"/></div></figure><p id="cf6b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于一个简单的<code class="eh mf mg mh mi b">Math.round</code>来说这很好，但是如果<code class="eh mf mg mh mi b">getNearestHundred</code>是一个CPU繁重的计算呢？那么你应该尽可能少的计算它——也就是说，计算一次，然后缓存结果直到<code class="eh mf mg mh mi b">x</code>改变。如果你的语言或框架自动帮你做到这一点，那就叫做<strong class="it hv">依赖跟踪</strong>。</p><p id="b229" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">依赖跟踪类似于<a class="ae jp" href="https://en.wikipedia.org/wiki/Memoization" rel="noopener ugc nofollow" target="_blank">记忆化</a>，但是我们不能记忆<code class="eh mf mg mh mi b">getNearestHundred</code>，因为它不是一个<a class="ae jp" href="https://en.wikipedia.org/wiki/Pure_function" rel="noopener ugc nofollow" target="_blank">纯函数</a>——它依赖于<code class="eh mf mg mh mi b">x</code>但是它不把<code class="eh mf mg mh mi b">x</code>作为参数。</p><p id="fea0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">基本上有两种方法来处理类似<code class="eh mf mg mh mi b">nearestHundred</code>的情况:</p><ol class=""><li id="324e" class="jy jz hu it b iu iv iy iz jc ka jg kb jk kc jo ni ke kf kg dt translated">成为<a class="ae jp" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">函数式编程</a>的纯粹主义者，永远不要让函数访问任何程序状态，除了它们的参数。所以<code class="eh mf mg mh mi b">getNearestHundred()</code>变成了<code class="eh mf mg mh mi b">getNearestHundred(x)</code>，以此类推。这就是像<a class="ae jp" href="https://en.wikipedia.org/wiki/Elm_%28programming_language%29" rel="noopener ugc nofollow" target="_blank"> Elm </a>这样的纯函数式语言让你做的事情。</li><li id="a8d6" class="jy jz hu it b iu ki iy kj jc kk jg kl jk km jo ni ke kf kg dt translated">使用依赖跟踪框架。这就是JavaScript库<a class="ae jp" href="http://mobxjs.github.io/mobx/" rel="noopener ugc nofollow" target="_blank"> MobX </a>最出名的地方，尽管它也被<a class="ae jp" href="https://docs.meteor.com/api/tracker.html" rel="noopener ugc nofollow" target="_blank"> Meteor </a>、<a class="ae jp" href="http://knockoutjs.com/documentation/computed-dependency-tracking.html" rel="noopener ugc nofollow" target="_blank"> Knockout </a>、<a class="ae jp" href="https://github.com/ds300/derivablejs" rel="noopener ugc nofollow" target="_blank">derived</a>和其他人做过。</li></ol><p id="c031" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(<a class="ae jp" href="https://github.com/reactjs/redux" rel="noopener ugc nofollow" target="_blank"> Redux </a>是介于#1和#2之间的一个尴尬的中间地带:你将状态块从你的UI视图中分离出来，并将它们隔离在一个只支持函数式编程的区域中。)</p><p id="14a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<a class="ae jp" href="https://hackernoon.com/how-eve-unifies-your-entire-programming-stack-900ca80c58a7" rel="noopener ugc nofollow" target="_blank">第一部分</a>中，我指出Eve中的一个<code class="eh mf mg mh mi b">bind</code>块类似于MobX中的一个<code class="eh mf mg mh mi b">computed</code>表达式。直觉上，两者都类似于电子表格公式:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff nj"><img src="../Images/a73be6a4994c14da17a86f518e284c87.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/format:webp/1*LMJwLFa3bHDMqFInhJJ7vg.png"/></div><figcaption class="ne nf fg fe ff ng nh bd b be z ek">@computed function B1() {return (Math.round(A1) / 100) * 100}</figcaption></figure><p id="1c2e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有了Eve，您可以享受语言级的依赖跟踪，在代码中的任何地方使用<code class="eh mf mg mh mi b">nearestHundred</code>，就像在电子表格中的任何地方使用单元格<code class="eh mf mg mh mi b">B1</code>一样。</p><h1 id="bc6b" class="lc ld hu bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz dt translated">运行时调试</h1><h2 id="e145" class="ml ld hu bd le mm mn mo li mp mq mr lm jc ms mt lq jg mu mv lu jk mw mx ly my dt translated">观察表情</h2><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="fe ff nk"><img src="../Images/5a60e1571f9ee08c7bd99a3d4a9b3254.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LNMb9Oei2nu19uFfevDS9w.png"/></div></div></figure><p id="56d0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">运行时调试时使用观察表达式的频率有多高？这通常不值得努力，因为状态与作用域链<a class="ae jp" href="https://hackernoon.com/throwing-off-our-scope-chains-7567beb2d0b6" rel="noopener ugc nofollow" target="_blank">紧密耦合。</a></p><p id="a0b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Eve中，你也不需要手表表情，因为一个<code class="eh mf mg mh mi b">search</code>段已经<em class="kh">就是</em>一个手表表情了。如果你想使用一个<code class="eh mf mg mh mi b">search</code>块进行调试，你所要做的就是添加一个<code class="eh mf mg mh mi b">commit</code>或者<code class="eh mf mg mh mi b">bind</code>段来写入<code class="eh mf mg mh mi b">@view</code>数据库。</p><h2 id="15f1" class="ml ld hu bd le mm mn mo li mp mq mr lm jc ms mt lq jg mu mv lu jk mw mx ly my dt translated">热重装</h2><p id="4c8e" class="pw-post-body-paragraph ir is hu it b iu ma iw ix iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo hn dt translated">热重载通常是一种奢侈品，必须煞费苦心地将其融入大多数语言和框架中。但是Eve在第一天就发布了它，这要感谢该语言的热重加载友好的构建模块。</p><p id="1e6f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在编辑器中，每个代码块都可以用勾号激活或停用，一切都会神奇地调整。</p><h2 id="7211" class="ml ld hu bd le mm mn mo li mp mq mr lm jc ms mt lq jg mu mv lu jk mw mx ly my dt translated">可串行化状态</h2><p id="e5ef" class="pw-post-body-paragraph ir is hu it b iu ma iw ix iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo hn dt translated">正在运行的Eve程序的整个状态很容易序列化到一个文件中。您的用户可以将“状态文件”附加到他们的错误报告中，并且您可以重现他们的确切状态:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="fe ff nl"><img src="../Images/0f2d7c67a8db8477aa61fb2c26a550bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zHZ0QW8VFQwsKt9jTLUVLA.png"/></div></div><figcaption class="ne nf fg fe ff ng nh bd b be z ek"><a class="ae jp" href="https://www.youtube.com/watch?v=TWAMr72VaaU" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=TWAMr72VaaU</a></figcaption></figure><h2 id="3994" class="ml ld hu bd le mm mn mo li mp mq mr lm jc ms mt lq jg mu mv lu jk mw mx ly my dt translated">更智能的UI检查工具</h2><p id="d013" class="pw-post-body-paragraph ir is hu it b iu ma iw ix iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo hn dt translated">web浏览器的inspector工具很好地向您展示了UI的状态，但是它不理解您的代码如何与该状态相关联。Eve理解为什么UI看起来是这样的。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff nm"><img src="../Images/e3e1d0273bd0dc75380cd779b754ab41.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*-4rOxogXAM0zjO6XDTzgJw.png"/></div></figure><p id="6c06" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">演示视频已经展示了令人印象深刻的GUI特性，用于在检查UI时跳转到相关的代码块。</p><h2 id="66fb" class="ml ld hu bd le mm mn mo li mp mq mr lm jc ms mt lq jg mu mv lu jk mw mx ly my dt translated">…以及更多</h2><p id="e818" class="pw-post-body-paragraph ir is hu it b iu ma iw ix iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo hn dt translated">除了Eve对现有调试工具的改进之外，我们可以期待Eve社区构思出比我们以往更好的调试工具。事实上，我敢想象Eve会让主机打印过时。</p><p id="0bac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对了，你知道Eve <em class="kh">没有</em>的什么调试功能吗？堆栈跟踪。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="fe ff nn"><img src="../Images/41c882ef70a413154d08d3011c18bd6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hP3dwMfxf-FOtdg-s50X7A.png"/></div></div><figcaption class="ne nf fg fe ff ng nh bd b be z ek">“Focusing on the machine and ignoring the human factors of software engineering have led us down a difficult road.” — <a class="ae jp" href="http://witheve.com" rel="noopener ugc nofollow" target="_blank">witheve.com</a></figcaption></figure><h1 id="f26e" class="lc ld hu bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz dt translated">单元测试</h1><p id="6bf5" class="pw-post-body-paragraph ir is hu it b iu ma iw ix iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo hn dt translated">在传统的单元测试中，通常很难伪造整个基于范围链的状态。此外，有时很难隔离一个模块化单元进行测试。使用Eve，您可以随时测试单独的代码块，并清楚地了解它们的数据流。</p><h1 id="3c75" class="lc ld hu bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz dt translated">性能优化</h1><p id="1d2e" class="pw-post-body-paragraph ir is hu it b iu ma iw ix iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo hn dt translated">如果您曾经使用过CPU分析器来找出如何优化某个地方的循环，那么您就会知道，理解哪一级调用堆栈是真正的罪魁祸首是一件痛苦的事情。比方说函数A调用函数B，函数B调用函数c，如果A在大量使用CPU，那不一定说明A写得不好；也可能是B或者c。</p><p id="2e8f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Eve没有调用栈；代码块不能直接调用其他代码块。因此，如果某个东西很慢，您可以很容易地隔离哪个代码块是负责任的。</p><p id="b30b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您曾经使用过内存分析器来改善内存泄漏，那么传统的内存泄漏在Eve中是不可能的！过时状态没有办法陷入错综复杂的闭包链中，所以不需要内存分析器。</p><p id="5c04" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">扪心自问，你处理过多少次内存泄露？您遇到过多少次将大量记录插入数据库的错误？好极了，因为你的Eve程序占用大量内存的唯一方法是你故意把大量记录放入本地数据库。</p><h1 id="08f9" class="lc ld hu bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz dt translated">分布式数据和计算</h1><p id="eec3" class="pw-post-body-paragraph ir is hu it b iu ma iw ix iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo hn dt translated">很难管理并行发生的事情的混乱，无论是数据还是计算。最初基于<a class="ae jp" href="https://databeta.wordpress.com/2010/01/05/introducing-dedalus/" rel="noopener ugc nofollow" target="_blank">迪达勒斯</a>的语言<a class="ae jp" href="http://bloom-lang.net/features/" rel="noopener ugc nofollow" target="_blank">布鲁姆</a>的网站解释了这个问题:</p><blockquote class="ku kv kw"><p id="1e78" class="ir is kh it b iu iv iw ix iy iz ja jb kx jd je jf ky jh ji jj kz jl jm jn jo hn dt translated">传统分布式编程中的许多痛苦来自这种不匹配:程序员被期望从有序的编程模型过渡到执行他们代码的无序现实。</p></blockquote><p id="05ff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">夏娃是一种“无序的语言”。Eve唯一的排序保证是<strong class="it hv">同步块。</strong>在每个时间步，所有代码块(每个代码块都有一个或多个<code class="eh mf mg mh mi b">search</code> / <code class="eh mf mg mh mi b">bind</code> / <code class="eh mf mg mh mi b">commit</code>段)读入该时间步的世界快照，它们都写入下一个时间步的世界快照。有点像<a class="ae jp" href="https://hackernoon.com/smalltalk-and-protein-programming-4da245ac93e2" rel="noopener ugc nofollow" target="_blank"> Smalltalk和蛋白质编程</a>。</p><p id="a386" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Eve有可能让分布式数据和计算变得更容易访问:</p><ul class=""><li id="e65f" class="jy jz hu it b iu iv iy iz jc ka jg kb jk kc jo kd ke kf kg dt translated">编写简单的Eve代码来管理大规模的复杂数据事务，这种事务需要锁定多个遥远的碎片。</li><li id="0d03" class="jy jz hu it b iu ki iy kj jc kk jg kl jk km jo kd ke kf kg dt translated">通过编写与单核机器相同的代码，使用Eve将计算密集型任务分散到多核CPU或云中的大型服务器群。</li></ul><p id="cfbc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Eve团队将这一愿景称为“<strong class="it hv">世界规模的计算机</strong>”。</p></div><div class="ab cl kn ko hc kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hn ho hp hq hr"><p id="ab4e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">下篇:<br/> </strong> <a class="ae jp" href="https://hackernoon.com/why-eve-will-be-perfect-for-realtime-apps-92b965b80ad" rel="noopener ugc nofollow" target="_blank"> <em class="kh">六</em>。为什么Eve是实时应用的完美选择</a></p><div class="jr js jt ju fq ab cb"><figure class="no jv np nq nr ns nt paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="no jv np nq nr ns nt paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="no jv np nq nr ns nt paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ku kv kw"><p id="f922" class="ir is kh it b iu iv iw ix iy iz ja jb kx jd je jf ky jh ji jj kz jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is kh it b iu iv iw ix iy iz ja jb kx jd je jf ky jh ji jj kz jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="fe ff nu"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>