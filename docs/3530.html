<html>
<head>
<title>How does the SQL Server Query Optimizer Works</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL Server查询优化器是如何工作的</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-does-the-sql-server-query-optimizer-works-47541e2205aa?source=collection_archive---------10-----------------------#2017-04-06">https://medium.com/hackernoon/how-does-the-sql-server-query-optimizer-works-47541e2205aa?source=collection_archive---------10-----------------------#2017-04-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="52a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">SQL Server <a class="ae jp" href="https://hackernoon.com/tagged/database" rel="noopener ugc nofollow" target="_blank">数据库</a>引擎的核心是两个主要组件:<strong class="it hv">存储引擎</strong>和<strong class="it hv">查询处理器</strong>，也称为关系引擎。</p><ul class=""><li id="3e9a" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">存储引擎:以优化并发性的方式在磁盘和内存之间读取数据，同时保持数据的完整性</li><li id="6f8e" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">查询处理器:1。由<strong class="it hv">查询优化器</strong> 2负责设计查询计划(实现什么算法/操作符)。由<strong class="it hv">执行引擎</strong>根据该计划执行查询</li></ul><p id="ac2b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">查询处理器执行以下操作:</p><ol class=""><li id="34cc" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo ke jw jx jy dt translated">查询解析</li><li id="a1a6" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ke jw jx jy dt translated">将查询绑定到对象</li><li id="45fb" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ke jw jx jy dt translated">生成可能的执行计划</li><li id="9b04" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ke jw jx jy dt translated">每个计划的成本评估</li></ol><p id="f165" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">执行引擎做以下事情:</p><ol class=""><li id="1119" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo ke jw jx jy dt translated">查询执行</li><li id="f267" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ke jw jx jy dt translated">计划缓存</li></ol><p id="f12b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">解析将SQL查询翻译成初始的树表示。绑定主要与名称解析有关。</p><h1 id="3999" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">搜索空间</h1><p id="ac3a" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">我们将给定查询的搜索空间定义为该查询的所有可能的执行计划的集合，在该搜索空间中的任何可能的计划都返回相同的结果。</p><h1 id="74c7" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">生成候选人执行计划</h1><p id="6c84" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">如前所述，查询优化器的基本目的是为您的查询找到一个有效的执行计划。即使对于相对简单的查询，也可能有大量不同的方法来访问数据以产生相同的最终结果。因此，查询优化器必须从可能非常多的候选执行计划中选择最佳计划，做出明智的选择非常重要，因为根据选择的计划，向用户返回结果所需的时间可能会有很大差异。</p><p id="1dde" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">查询优化器必须在优化时间和计划质量之间取得平衡。SQL Server不会进行彻底的搜索，而是尝试尽快找到一个合适的高效计划。</p><h1 id="cc32" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">评估每个计划的成本</h1><p id="b9a4" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">查询优化器需要估计这些计划的成本，并选择最便宜的一个。为了估计计划的成本，它使用考虑了I/O、CPU和内存等资源使用的成本计算公式来估计该计划中每个物理操作符的成本。</p><p id="23f0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">基数估计</strong>:查询计划的成本估计主要取决于物理操作符使用的算法，以及需要处理的记录的估计数量；这种对记录数量的估计称为基数估计。</p><h1 id="87ae" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">查询执行和计划缓存</h1><p id="b3b5" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">优化查询后，执行引擎将使用生成的计划来检索所需的数据。生成的执行计划可以存储在内存中的计划缓存(在SQL Server的早期版本中称为过程缓存)中，以便在再次执行同一查询时可以重用。</p><p id="9ecc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，对于给定的查询，重用现有的计划并不总是最佳的解决方案。根据表中数据的分布情况，给定查询的最佳执行计划可能会因所述查询中提供的参数而有很大差异，而被称为<a class="ae jp" href="https://www.brentozar.com/archive/2013/06/the-elephant-and-the-mouse-or-parameter-sniffing-in-sql-server/" rel="noopener ugc nofollow" target="_blank">参数嗅探</a>的行为可能会导致选择次优计划。</p><p id="8969" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">即使执行计划在计划缓存中可用，一些元数据更改(如删除索引或约束，或者对数据库内容进行足够大的更改)也可能会使现有计划无效或次优，从而导致该计划从计划缓存中被丢弃，并生成新的优化。</p><h1 id="a9f8" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">重新编译</h1><p id="4e65" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">您可以强制SQL Server在每次运行存储过程时重新编译它。这样做的好处是，每次运行时都会创建最佳的查询计划。但是，重新编译是一项CPU密集型操作。对于频繁运行的存储过程，或者在已经受到CPU资源限制的服务器上，这可能不是理想的解决方案。另一件要记住的事情是，计划不会存储在缓存中，这使得如果它们有问题的话更难被发现。</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="7497" class="lr kg hu ln b fv ls lt l lu lv"><strong class="ln hv">ALTER</strong> <strong class="ln hv">PROCEDURE</strong> Get_OrderID_OrderQty<br/>@ProductID INT<br/><strong class="ln hv">WITH</strong> RECOMPILE<br/><strong class="ln hv">AS</strong><br/><strong class="ln hv">SELECT</strong> SalesOrderDetailID, OrderQty<br/><strong class="ln hv">FROM</strong> Sales.SalesOrderDetail<br/><strong class="ln hv">WHERE</strong> ProductID = @ProductID;</span></pre><h1 id="1639" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">暗示</h1><p id="e307" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">另一种选择是使用OPTIMIZE FOR查询提示。这告诉SQL Server在编译计划时使用指定的值。如果，通过测试，你能找到一个每次都能产生一个“足够好”的计划的值，并且性能对老鼠和大象来说都是可以接受的，这对你来说是一个好的选择。</p><p id="ce04" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，要明白您是在指挥查询优化器。你告诉它你认为最好的。OPTIMIZE FOR的最大缺点是在数据分布发生变化的表上。变化越快，这个提示就越过时。如果你提供的价值在一个月或一年内都不是最优的呢？你需要有一个方法来定期检查和修改它。</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="4125" class="lr kg hu ln b fv ls lt l lu lv"><strong class="ln hv">ALTER</strong> <strong class="ln hv">PROCEDURE</strong> Get_OrderID_OrderQty<br/>@ProductID INT<br/><strong class="ln hv">AS</strong><br/><strong class="ln hv">SELECT</strong> SalesOrderDetailID, OrderQty<br/><strong class="ln hv">FROM</strong> Sales.SalesOrderDetail<br/><strong class="ln hv">WHERE</strong> ProductID = @ProductID<br/><strong class="ln hv">OPTION</strong> (<strong class="ln hv">OPTIMIZE</strong> <strong class="ln hv">FOR</strong> (@ProductID=945));</span></pre><blockquote class="lw lx ly"><p id="35ee" class="ir is lz it b iu iv iw ix iy iz ja jb ma jd je jf mb jh ji jj mc jl jm jn jo hn dt translated">现实是，即使经过30多年的研究，查询优化器仍然是高度复杂的软件，仍然面临一些技术挑战。因此，可能会出现这样的情况，即使您已经为查询优化器提供了它需要的所有信息，而且似乎没有任何明显的问题，您仍然没有得到一个有效的计划。</p></blockquote><p id="d5cf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">来源:</p><ul class=""><li id="9483" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated"><a class="ae jp" href="https://www.brentozar.com/archive/2013/06/the-elephant-and-the-mouse-or-parameter-sniffing-in-sql-server/" rel="noopener ugc nofollow" target="_blank">大象和鼠标，或者，SQL Server中的参数嗅探</a></li><li id="99a8" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated"><a class="ae jp" href="https://www.simple-talk.com/sql/sql-training/the-sql-server-query-optimizer/" rel="noopener ugc nofollow" target="_blank">SQL Server查询优化器</a></li></ul></div><div class="ab cl md me hc mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hn ho hp hq hr"><p id="70cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="lz">原载于</em><a class="ae jp" href="http://xameeramir.github.io/How-SQL-Server-Query-Optimizer-Works/" rel="noopener ugc nofollow" target="_blank"><em class="lz">xameeramir . github . io</em></a><em class="lz">。</em></p><figure class="li lj lk ll fq mk"><div class="bz el l di"><div class="ml mm l"/></div></figure></div></div>    
</body>
</html>