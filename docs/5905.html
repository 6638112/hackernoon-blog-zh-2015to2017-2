<html>
<head>
<title>Cypress.io &amp; Docker: the Ultimate E2E Stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Cypress.io &amp; Docker:终极E2E堆栈</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/cypress-io-docker-the-ultimate-e2e-stack-a20ee25654b1?source=collection_archive---------3-----------------------#2017-08-23">https://medium.com/hackernoon/cypress-io-docker-the-ultimate-e2e-stack-a20ee25654b1?source=collection_archive---------3-----------------------#2017-08-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/edd1c7bb8e440122ca2abf09f3d6da57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IrV85j4bpBjZocD5jVnCHQ.jpeg"/></div></div></figure><h1 id="6e09" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">爱达荷（Idaho的缩写）</h1><p id="7e8b" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">人们对端到端测试又爱又恨，这是有充分理由的。我已经看到许多项目(包括我自己的)着迷于自动化端到端测试，并逐渐达到测试用例变得古怪、缓慢和完全被忽略的程度。让我们看看为什么以及如何让E2E测试成为一个好的开发者体验和软件回归的坚固防火墙。</p><p id="f69e" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">出于演示的目的，我们将测试一个<a class="ae ld" href="https://dashbouquet.com/viewcase/hr-software-mvp" rel="noopener ugc nofollow" target="_blank"> <strong class="kc hv"> React\Node.js应用程序</strong> </a>，这是一个人力资源机构的招聘平台。到本文结束时，我们将实现这些测试用例:</p><ul class=""><li id="841e" class="le lf hu kc b kd ky kh kz kl lg kp lh kt li kx lj lk ll lm dt translated">用户可以注册</li><li id="a79b" class="le lf hu kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm dt translated">用户可以登录</li><li id="0c47" class="le lf hu kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm dt translated">用户可以发布招聘广告</li><li id="f810" class="le lf hu kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm dt translated">用户可以看到候选人出现在职务公告板上</li></ul><h1 id="d583" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">使用Cypress.io</h1><p id="e1dc" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">很长一段时间以来，在E2E web应用程序测试领域有一个主要参与者——selenium。大多数解决方案基本上都是在selenium之上构建API，所以它们都面临着selenium所面临的相同问题。Cypress.io是一个新的播放器，不依赖于selenium，旨在解决其前任的缺点。</p><p id="1533" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">让我们看看Cypress API在我们的测试用例中会是什么样子。</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="c8c8" class="mb jd hu lx b fv mc md l me mf">describe('Smoke tests', () =&gt; {<br/>  it('User can sign up', () =&gt; {<br/>    cy<br/>      .signup()<br/>      .get('body').contains('Create Your First Job');<br/>    });<br/> <br/>  it('user can login', () =&gt; {<br/>    cy<br/>      .login()<br/>      .get('body').contains('Create Your First Job')<br/>  });<br/>});</span></pre><p id="cc5e" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">好吧，这里没有神奇的signup()或login()方法，但是有一个很好的API可以用自定义方法扩展'<strong class="kc hv"> cy </strong>'全局:</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="4885" class="mb jd hu lx b fv mc md l me mf">Cypress.addParentCommand("login", (email, password) =&gt; {<br/>    cy<br/>      .visit('/')<br/>      .get('form input[name="email"]').clear().type(email)<br/>      .get('form input[name="password"]').clear().type(password)<br/>      .get('form button').click()<br/>  });<br/> <br/>  Cypress.addParentCommand("signup", (name, email, password) =&gt; {<br/>    cy<br/>      .visit('/')<br/>      .get('body').contains('Sign Up').click()<br/>      .submitSignupForm(name, email)<br/>      .followLinkFromEmail()<br/>      .submitProfileForm(name, email)<br/>      .get('body').contains('Create Your Company')<br/>      .submitCompanyForm()<br/>      .get('body').contains('Add Team Members')<br/>      .get('button').contains('Skip').click()<br/>      .get('body').contains('Create Your First Job')<br/>  });</span></pre><h1 id="c073" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">为每个测试用例设计初始状态</h1><p id="2e73" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">如果我们要使测试快速，我们将需要从应用程序的预定义状态开始每个测试用例。让我们定义每个测试用例的初始状态:</p><ul class=""><li id="5561" class="le lf hu kc b kd ky kh kz kl lg kp lh kt li kx lj lk ll lm dt translated"><strong class="kc hv">“用户可以注册”</strong>。我们并不真的需要数据库中任何与用户相关的数据。尽管可能存在一些只读数据来支持应用程序。姑且称之为“<strong class="kc hv">空</strong>状态。</li><li id="e7a1" class="le lf hu kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm dt translated"><strong class="kc hv">“用户可以登录”</strong>、<strong class="kc hv">用户可以发布工作广告</strong>都表示用户已经经历了注册流程，所以最小初始状态是——“<strong class="kc hv">已注册</strong></li><li id="8159" class="le lf hu kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm dt translated">最后<strong class="kc hv">“用户可以看到候选人出现在工作公告板上”</strong>需要工作出现，因此为“<strong class="kc hv">工作发布</strong>”状态。</li></ul><p id="8c5f" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">因此，让我们更新我们的测试用例来明确定义状态:</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="a106" class="mb jd hu lx b fv mc md l me mf">describe('Smoke tests', () =&gt; {<br/>  it('User can sign up', () =&gt; {<br/>    cy<br/>      .state('empty')<br/>      .signup()<br/>      .get('body').contains('Create Your First Job');<br/>    });<br/> <br/>  it('user can login', () =&gt; {<br/>    cy<br/>      .state('signed-up')<br/>      .login()<br/>      .get('body').contains('Create Your First Job')<br/>  });<br/>});</span></pre><p id="4e56" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">state函数向API发出一个XHR请求，API将其状态重置为某个预定义的状态。</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="7b9b" class="mb jd hu lx b fv mc md l me mf">Cypress.addParentCommand("state", (...states) =&gt; {<br/>  cy<br/>    .request({<br/>      url: `${Cypress.env('BASE_API')}/integration/state`,<br/>      method: 'POST',<br/>      headers: { 'content-type': 'application/json' },<br/>      body: JSON.stringify({ states: states })<br/>    });<br/>});</span></pre><p id="862d" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我们确实需要一些支持代码来帮助设置状态，但是所付出的努力在测试的性能和可维护性方面是值得的。在后端，我们使用MongoDB native，因此有问题的代码可能如下所示:</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="c2de" class="mb jd hu lx b fv mc md l me mf">const stateLoaders = {<br/>  'empty': require('./states/empty'),<br/>  'signed-up': require('./states/signed-up'),<br/>  ...<br/>};<br/> <br/>export const loadState = async (db, states = ['empty']) =&gt; {<br/>  await clean(db);<br/> <br/>  for (let state of states) { //many states? well sometimes you need to test complex <!-- -->scenarios<br/>    await stateLoaders[state].load(db);<br/>  }<br/>};<br/> <br/>const clean = async (db) =&gt; {<br/>  const collections = await db.listCollections().toArray();<br/>  const names = collections<br/>    .filter(c =&gt; c.name.indexOf('system.') !== 0)<br/>    .map(c =&gt; c.name);<br/> <br/>  return Promise.all(names.map(name =&gt; db.collection(name).remove()));<br/>};</span></pre><p id="7d80" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">有人可能会争辩说，既然可以有一个适用于所有情况的大州，为什么还要有多个州。答案是可维护性和性能。首先，不加载不需要的数据可以节省大量时间。但更重要的是可维护性。您的应用程序声明，您将需要测试可能会相互冲突。</p><p id="3639" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">例如，您想要测试一个用户提交了一个注册表单但没有验证他的电子邮件的情况，因此您需要一个特殊的用户，现在我们在您的数据库中有两个用户，您必须在测试中区分他们。您将很快注意到您所在州的数据量很难推理。然而，如果您选择针对最小可能状态运行测试用例，那么跟踪状态变化就很容易了。</p><h1 id="d413" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">二。</h1><p id="df27" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">在本文的第一部分，我们看到了如何使用ypress和选择正确的模拟策略来帮助我们编写高性能、可靠且易于使用的端到端测试。想感受一下这种快速的感觉，看看赛普拉斯在试运行期间为我们录制的视频。在这一部分中，我们将关注E2E测试的另一个实际方面——在CI上运行测试。</p><figure class="ls lt lu lv fq iv"><div class="bz el l di"><div class="mg mh l"/></div></figure><h1 id="8df0" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">使用docker-compose</h1><p id="cd18" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">通过E2E测试，我们希望引入尽可能多的应用方(微服务、API、传输),这样我们就可以确保最佳的覆盖和集成。理想情况下，我们应该测试一个生产克隆，但是这会带来很大的性能开销——我们不想在每个构建的部署上浪费时间和资源。我们想要的是给开发者一个快速的反馈，无论他的提交是否引入了回归。Docker来了。Docker-compose为您提供了这种能力，以声明的方式将您的应用程序需要的所有微服务集合在一起，在CI上运行它们以及您的测试。</p><p id="ccf1" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">让我们在一个漂亮的docker-compose.yml文件中组装我们的测试应用程序。对于演示，我们仍然使用这个典型的React/Node.js应用程序，其中包含4个图像:</p><ul class=""><li id="a574" class="le lf hu kc b kd ky kh kz kl lg kp lh kt li kx lj lk ll lm dt translated">frontend——是react应用程序，带有一个提供静态文件的服务器</li><li id="70bc" class="le lf hu kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm dt translated">API —是Node.js API</li><li id="772f" class="le lf hu kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm dt translated">MongoDB —持久性</li><li id="1073" class="le lf hu kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm dt translated">cypress——是我们的测试运行程序，它将在浏览器中打开前端图像URL，但也可以向API发送请求来重置应用程序的状态</li></ul><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="d2c7" class="mb jd hu lx b fv mc md l me mf">#docker-compose.yml<br/>version: '2'<br/>services:<br/> cypress:<br/>   build:<br/>     context: .<br/>     dockerfile: Dockerfile.cypress<br/>   links:<br/>     - frontend<br/>     - api<br/>   command: /app/wait-for-it.sh frontend:3000 -t 60 -- npm run test<br/> frontend:<br/>   environment:<br/>     - NODE_ENV=integration<br/>   build:<br/>     context: .<br/>     dockerfile: Dockerfile.frontend<br/>   ports:<br/>     - 3000:3000<br/>   expose:<br/>     - 3000<br/>   links:<br/>     - api<br/>   command: /app/wait-for-it.sh api:4000 -t 60 -- npm run start<br/> api:<br/>   environment:<br/>     - NODE_ENV=integration<br/>   image: 'noviopus/api-dev:latest'<br/>   ports:<br/>     - 4000:4000<br/>   expose:<br/>     - 4000<br/>   links:<br/>     - mongodb<br/> mongodb:<br/>   image: mongo:3.2</span></pre><p id="8958" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><strong class="kc hv">这里有一些值得注意的事情</strong>。</p><p id="9db9" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">首先，我们在这里使用最新版本的API映像。主要思想是，API是以向后兼容的方式开发和部署的，所以当新版本的API出来时，我们知道所有部署的前端将继续工作(在特定的环境中)。这允许我们在不依赖于构建版本的情况下发展应用程序。</p><p id="b1ad" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">其次，我们使用这个简单而有用的<a class="ae ld" href="https://github.com/vishnubob/wait-for-it" rel="noopener ugc nofollow" target="_blank"> <strong class="kc hv">脚本</strong> </a>明确地等待映像的依赖项准备好接受连接，这样我们就知道在运行第一个测试之前所有的服务都准备好了。</p><p id="a8aa" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">以下是使用Docker-compose时Circle CI 2.0配置文件的外观:</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="bea1" class="mb jd hu lx b fv mc md l me mf">version: 2<br/>jobs:<br/> build:<br/>   docker:<br/>     #run all commands in this image:<br/>     - image: dziamid/ubuntu-docker-compose #ubuntu + docker + docker-compose<br/>     - checkout<br/>     - setup_remote_docker<br/>     - run:<br/>         #need to login so we can pull private repos from hub in the following runs<br/>         name: Login <br/>         command: docker login -u $DOCKERHUB_USER -e $DOCKERHUB_EMAIL -p $DOCKERHUB_PASSWORD<br/>     - run:<br/>         name: Build<br/>         command: docker-compose -p app build<br/>     - run:<br/>         name: Test<br/>         command: docker-compose -p app run cypress<br/>     - run:<br/>         name: Collect artifacts<br/>         command: |<br/>           docker cp app_cypress_run_1:/app/cypress/artifacts $(pwd)/cypress/artifacts<br/>         when: always #execute this run command on success or failure of previous run<br/>     - store_test_results:<br/>	#expose test results so you can see failing tests on the top of the page<br/>         path: cypress/artifacts<br/>         when: always<br/>     - store_artifacts:<br/>	#expose video and screenshots from cypress<br/>         path: cypress/artifacts<br/>         when: always<br/>     - run:<br/>         name: Deploy<br/>         command: |<br/>	# deployment is out of scope of this article</span></pre><p id="427d" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">运行`<strong class="kc hv">docker-compose-p app-f bundle . yml run cypress</strong>`显示了Docker-compose的荣耀。该命令将:</p><ol class=""><li id="9550" class="le lf hu kc b kd ky kh kz kl lg kp lh kt li kx mi lk ll lm dt translated">启动Cypress图像并附加到其输出</li><li id="9985" class="le lf hu kc b kd ln kh lo kl lp kp lq kt lr kx mi lk ll lm dt translated">找到Cypress图像的所有依赖项，并在后台启动它们</li><li id="e904" class="le lf hu kc b kd ln kh lo kl lp kp lq kt lr kx mi lk ll lm dt translated">当Cypress image中的进程退出时，它将优雅地终止后台的所有进程</li><li id="c2cc" class="le lf hu kc b kd ln kh lo kl lp kp lq kt lr kx mi lk ll lm dt translated">所有进程终止后，您可以访问</li></ol><p id="7506" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">通过显示测试结果，您将在页面顶部看到测试摘要。</p><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mj"><img src="../Images/31cb0ead5434afdeb4e394a68bd31d14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vj-fipU4zYDKXzb0gSnFhw.jpeg"/></div></div></figure><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mk"><img src="../Images/72b385f1c8b6965b16ed6f3ea2216a2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pin4dpgf-Nez5PJQCKhoLw.jpeg"/></div></div></figure><p id="d56d" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">结果，我们将E2E集成到了开发工作流程中。现在，我们可以发展我们的微服务，并确信它们可以相互集成，并且最关键的应用程序流正在按预期工作。</p></div><div class="ab cl ml mm hc mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hn ho hp hq hr"><p id="835e" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><a class="ae ld" href="https://github.com/dziamid" rel="noopener ugc nofollow" target="_blank"> <em class="ms">作者Dziamid Zayankouski </em> </a></p><p id="9567" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><em class="ms">想了解更多？</em> <a class="ae ld" href="https://dashbouquet.com/blog" rel="noopener ugc nofollow" target="_blank"> <em class="ms">在这里查看</em> </a></p></div></div>    
</body>
</html>