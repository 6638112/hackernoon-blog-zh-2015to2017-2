<html>
<head>
<title>Keducer — Automate writing redux reducers with 5 lines of javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ke ducer——用5行javascript自动编写redux reducers</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/automate-writing-redux-reducers-with-5-lines-of-javascript-cecb79fb9a35?source=collection_archive---------7-----------------------#2017-12-07">https://medium.com/hackernoon/automate-writing-redux-reducers-with-5-lines-of-javascript-cecb79fb9a35?source=collection_archive---------7-----------------------#2017-12-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/952fbb3b7c09d25ee3a35dc0551de798.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m3vlxneAo50hBQYOZbT_ug.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/2EJCSULRwC8?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Alex Knight</a> on <a class="ae jg" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="038e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我喜欢与<a class="ae jg" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank"> React </a>一起工作，并对这种前端模式的发展感到惊讶。React和<a class="ae jg" href="https://hackernoon.com/tagged/redux" rel="noopener ugc nofollow" target="_blank"> Redux </a>是两项出色的技术。对他们来说，再多的赞美也是不够的。</p><p id="1ade" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是我一直在想的一个问题是，我够干吗？</p><p id="5558" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">来自香草通量的世界，Redux感觉简洁。但是几个大项目之后，我又在做同样的事情，一遍又一遍。整个周期中感觉特别冗长的一部分是编写reducers。我们采取一个行动和一个有效载荷，然后发射一个突变。</p><p id="f1d1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我首先想消除编写reducers的过程，所以我想出了<a class="ae jg" href="https://github.com/shivekkhurana/mutex" rel="noopener ugc nofollow" target="_blank">互斥</a>——一个没有副作用的通量，但从未完成它，因为<a class="ae jg" href="https://github.com/jaystack" rel="noopener ugc nofollow" target="_blank"> JayStack </a>想出了一个类似的库，叫做<a class="ae jg" href="https://github.com/jaystack/repatch" rel="noopener ugc nofollow" target="_blank"> Repatch </a>。</p><p id="597d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">回想起来，Repatch的想法是一脉相承的，但极其成熟。如果我在Mutex上工作了大约2年，我会得到Repatch。作为一个懒惰的程序员，我最好放弃自己的库，使用Repatch。</p><h1 id="2b9c" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">但是接下来是遗留代码(和心智模型)的实现</h1><p id="b1c0" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">我花了很多时间调整<a class="ae jg" href="https://hackernoon.com/fractal-a-react-app-structure-for-infinite-scale-4dab943092af" rel="noopener ugc nofollow" target="_blank">分形——一个无限缩放的react应用程序结构，</a>,它依赖于raw Redux。尽管Repatch符合我的理念，但我并不放心押注于此，因为:</p><ul class=""><li id="8ed4" class="li lj hu jj b jk jl jo jp js lk jw ll ka lm ke ln lo lp lq dt translated">紧密耦合的动作和reducers使得编写自动化测试变得困难。</li><li id="c123" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke ln lo lp lq dt translated">重新修补意味着没有回头路。如果我构建了一个应用程序，但过了一段时间后感觉不太好，我就被困住了。</li></ul><p id="7dee" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">还有其他值得注意的项目，如<a class="ae jg" href="https://github.com/concretesolutions/redux-zero" rel="noopener ugc nofollow" target="_blank"> redux-zero、</a>，但第二点仍然适用。</p><h1 id="60d8" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated"><strong class="ak">我想要的东西</strong></h1><p id="dbcc" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">理想情况下，我想要一个系统:</p><ul class=""><li id="51bb" class="li lj hu jj b jk jl jo jp js lk jw ll ka lm ke ln lo lp lq dt translated">非常符合我们的分形模式</li><li id="2865" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke ln lo lp lq dt translated">不会使构建膨胀</li><li id="1d7f" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke ln lo lp lq dt translated">减少(或完全消除)编写reducer的需要</li><li id="6c81" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke ln lo lp lq dt translated">不影响商店的可测试性</li><li id="dacd" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke ln lo lp lq dt translated">交换机的成本应该是最低的</li></ul><h1 id="8d83" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">尤里卡。</h1><p id="ff14" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">在引导一个新项目并复制粘贴我常用的认证模块时，我发现我的大多数reducers:</p><ul class=""><li id="0e25" class="li lj hu jj b jk jl jo jp js lk jw ll ka lm ke ln lo lp lq dt translated">只拿了有效载荷并把它们放在我的州</li><li id="ecfb" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke ln lo lp lq dt translated">reducer是我定义的一个函数(用一个大的开关盒)</li></ul><p id="b2b5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我想到了写一个函数，它生成一个默认的reducer，将有效负载放到状态上。它叫ke ducer(“Kay-Deu-Cer”；仅仅5行代码就消除了我95%的reducers)。</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="8126" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我很想为此建立一个npm模块，但感觉最好不要对js疲劳有更多的贡献，所以我只做了一个要点。</p><h1 id="efcf" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">Redux如何在没有keducers的情况下工作</h1><p id="9ee2" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">在一般的Redux设置中，典型的登录缩减器如下所示:</p><pre class="lw lx ly lz fq mc md me mf aw mg dt"><span id="8e41" class="mh kg hu md b fv mi mj l mk ml">export default function reducer(state={}, action) {<br/>  switch (action.type) {<br/>    case 'auth.loginError':<br/>      return {...state, loginErrors: action.payload.errors};</span><span id="bac4" class="mh kg hu md b fv mm mj l mk ml">    case 'auth.loginSuccess':<br/>      return {...state, isUserLoggedIn: true};</span><span id="2c0b" class="mh kg hu md b fv mm mj l mk ml">    default:<br/>        return state;<br/>  }<br/>}</span></pre><p id="0fd0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">动作定义可能是这样的:</p><pre class="lw lx ly lz fq mc md me mf aw mg dt"><span id="c41f" class="mh kg hu md b fv mi mj l mk ml">export function login(email, password) {<br/>  return (dispatch) =&gt; {<br/>    api<br/>      .post('/auth/login', {email, password})<br/>      .then((res) =&gt; {<br/>        Promise<br/>          .all([<br/>            storage.setItem('token', res.token),<br/>            storage.setItem('user', JSON.stringify(res.user)),<br/>          ])<br/>          .then(() =&gt; {<br/>            dispatch({type: 'auth.loginSuccess'});<br/>          })<br/>        ;<br/>      })<br/>      .catch((err) =&gt; {<br/>        dispatch({<br/>          type: 'auth.loginError',<br/>          payload: {<br/>            errors: Object.values(err.data)<br/>          }<br/>        });<br/>      })<br/>    ;<br/>  };<br/>}</span></pre><p id="d21b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您只需将这个缩减器加载到一个存储中，并将其“提供”给根组件，然后<code class="eh mn mo mp md b">dispatch(login)</code>在点击事件上运行。</p><h1 id="db0b" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">Redux如何与keducers一起工作</h1><p id="6a23" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">使用keducer，无论您传递什么作为有效载荷，它都会被粘贴在您的状态之上。但是它确实希望你的动作是由<code class="eh mn mo mp md b">. (dot)</code>分隔的字符串，所以你可能必须在那里做一些工作。</p><h2 id="1215" class="mh kg hu bd kh mq mr ms kl mt mu mv kp js mw mx kt jw my mz kx ka na nb lb nc dt translated">第一步:设置一个模块</h2><p id="7e49" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">模块基本上是一个ducks结构术语，表示一个文件中的actions + reducers。你可以在我的<a class="ae jg" href="https://hackernoon.com/fractal-a-react-app-structure-for-infinite-scale-4dab943092af" rel="noopener ugc nofollow" target="_blank">分形结构</a>文章中了解更多。</p><p id="b65d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">唯一值得注意的区别是缺少一个缩减器，而是导出一个默认的keducer。注意，keducer使用一个名为<code class="eh mn mo mp md b">auth</code>的键，这个键基本上告诉它监听所有带有<code class="eh mn mo mp md b">auth.</code>前缀的动作。</p><p id="c8b5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，keducer将自动获取您的有效负载，并将其添加到auth树下的state中。</p><pre class="lw lx ly lz fq mc md me mf aw mg dt"><span id="7745" class="mh kg hu md b fv mi mj l mk ml">import config from 'config';<br/>import api from 'utils/api';<br/>import storage from 'utils/localStoragePromise';<br/>import keducer from 'utils/keducer';</span><span id="1328" class="mh kg hu md b fv mm mj l mk ml">export default keducer('auth'); // &lt;---- Where the magic happens</span><span id="02dd" class="mh kg hu md b fv mm mj l mk ml">export function login(email, password) {<br/>  return (dispatch) =&gt; {<br/>    api.post('/auth/login', {email, password})<br/>      .then(res =&gt; {<br/>        Promise.all([<br/>          storage.setItem('token', res.token),<br/>          storage.setItem('user', JSON.stringify(res.user)),<br/>        ]);<br/>        dispatch({<br/>          type: 'auth.loginSuccess', payload: {token, user}<br/>        });<br/>      })<br/>      .catch(err =&gt; {<br/>        dispatch({<br/>          type: 'auth.loginError', <br/>          payload: {loginErrors: err.data.err}});<br/>      })<br/>    ;<br/>  };<br/>}</span></pre><h2 id="4d50" class="mh kg hu bd kh mq mr ms kl mt mu mv kp js mw mx kt jw my mz kx ka na nb lb nc dt translated">步骤2:设置您的根存储</h2><p id="a7db" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">因为keducer返回一个函数，所以这里不需要做什么新的事情。只是像平常一样组合减少器并将其传递给提供者。</p><pre class="lw lx ly lz fq mc md me mf aw mg dt"><span id="149c" class="mh kg hu md b fv mi mj l mk ml">const rootReducer = combineReducers({<br/>  auth,<br/>});</span><span id="f381" class="mh kg hu md b fv mm mj l mk ml">const store = createStore(<br/>  rootReducer,<br/>  compose(<br/>    applyMiddleware(thunk),<br/>    window.devToolsExtension ? window.devToolsExtension() : f =&gt; f<br/>  )<br/>);</span></pre><p id="a4c6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这应该足够开始了，但是如果您是Redux power用户，您可能会想:</p><ul class=""><li id="afeb" class="li lj hu jj b jk jl jo jp js lk jw ll ka lm ke ln lo lp lq dt translated">“嗯，这扼杀了Redux的整个概念，因为你不可能在不同的Redux之间共享动作”</li><li id="e3f4" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke ln lo lp lq dt translated">“如果状态依赖于以前的状态，你甚至不能更新状态(例如，当用户滚动到页面底部时，在列表中加载更多项目)”。</li></ul><p id="848f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不要担心超级用户，keducer会保护你。</p><h2 id="f3d9" class="mh kg hu bd kh mq mr ms kl mt mu mv kp js mw mx kt jw my mz kx ka na nb lb nc dt translated"><strong class="ak">步骤3:访问旧状态或在keducers之间共享操作</strong></h2><p id="a6e0" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated"><code class="eh mn mo mp md b">keducer</code>函数接受第二个参数，这是一个类似于:</p><pre class="lw lx ly lz fq mc md me mf aw mg dt"><span id="c7fc" class="mh kg hu md b fv mi mj l mk ml">export default keducer('users', {<br/>  'auth.loginSuccess': (state, payload) =&gt; ({<br/>    ...state, ...payload, ...{customStuff: true}<br/>  })<br/>})</span></pre><p id="c189" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个映射的关键字是您希望捕获的动作类型，值是获取状态和有效负载作为参数的函数。这个状态是本地reducer状态，而不是应用程序状态，所以如果你愿意的话，你可以期望完成所有正常的redux魔法(但是你很少会这么做)。</p><h2 id="1131" class="mh kg hu bd kh mq mr ms kl mt mu mv kp js mw mx kt jw my mz kx ka na nb lb nc dt translated">示范项目</h2><p id="8c52" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">我正在做一个，很快就会有了。越快是相对于这篇文章获得的掌声和观点的数量。</p><h1 id="72d6" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">结束语</h1><p id="1b3c" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">这5行代码节省了大量编写reducers的时间，但更重要的是像我这样的人(没有太多经验)能够想出如此显而易见的东西，而整个js社区都押注于冗长的版本。</p><p id="3173" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">此外，竞争标准和js疲劳阻止了我构建另一个模块。我对js被教授、使用和改进的方式有点恼火，这看起来像是一种时尚。</p><p id="b78d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我去寻找更好的解决方案，并在clojurescript中找到了一个。我对它的理解没有js那么成熟，但是非常非常非常有前途。非常非常。这就像将js定位为JVM，并得到cogn itect(clo jure背后的公司，Rich Hickey在那里工作)的支持。</p><h1 id="6956" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt">🤙</h1><p id="d2f2" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">我目前正在大量试验它(clojurescript)，如果你想让我写它，请让我知道。</p><h1 id="3091" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt">🙏🏼</h1><p id="6996" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">感谢您花时间阅读我的作品。希望对你的项目有帮助。</p><h1 id="b2c1" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt">❤️</h1><p id="26c3" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">您可能还想阅读:</p><ul class=""><li id="4a03" class="li lj hu jj b jk jl jo jp js lk jw ll ka lm ke ln lo lp lq dt translated"><a class="ae jg" href="https://hackernoon.com/fractal-a-react-app-structure-for-infinite-scale-4dab943092af" rel="noopener ugc nofollow" target="_blank">分形——无限尺度的反应app结构</a></li><li id="99ec" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke ln lo lp lq dt translated"><a class="ae jg" href="https://hackernoon.com/blockchain-is-like-the-transistor-of-the-main-frame-financial-system-b77034c2762e" rel="noopener ugc nofollow" target="_blank">区块链就像主机金融系统的晶体管</a></li><li id="3636" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke ln lo lp lq dt translated"><a class="ae jg" rel="noopener" href="/@shivekkhurana/the-99-that-went-before-196c57e3714e">走在前面的99</a>【诗】&amp;</li><li id="4910" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke ln lo lp lq dt translated"><a class="ae jg" rel="noopener" href="/@shivekkhurana/14-life-lessons-learnt-after-1-year-of-graduation-423de966c4a0">毕业一年后学到的14条人生经验</a></li></ul><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="nd mb l"/></div></figure></div></div>    
</body>
</html>