<html>
<head>
<title>Making right things using Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker做正确的事情</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/making-right-things-using-docker-7296cf0f6c6e?source=collection_archive---------6-----------------------#2017-10-23">https://medium.com/hackernoon/making-right-things-using-docker-7296cf0f6c6e?source=collection_archive---------6-----------------------#2017-10-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="ddd7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本文中，我想展示如何使用docker进行<strong class="it hv">开发</strong>和<strong class="it hv">测试</strong>。为了表明现在是从开发切换到<strong class="it hv">工程</strong>，从单栈切换到<strong class="it hv">全栈</strong>的时候了。当然，全栈不仅仅是前端和后端，它也是环境。docker是一个很好的工具。</p><p id="de3c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还有一些想法认为在不久的将来<strong class="it hv"> </strong> <a class="ae jp" href="https://hackernoon.com/how-i-started-with-learning-ai-in-the-last-2-months-251d19b23597" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">全栈将包含和机器学习</strong> </a>。我将展示在这个领域使用docker是多么容易。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff jq"><img src="../Images/fd89dc72b287aed0a058bc5fa22d6a9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*d-HKujYLR5Q2QED4ybEiPw.png"/></div></figure></div><div class="ab cl jy jz hc ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hn ho hp hq hr"><h2 id="1c06" class="kf kg hu bd kh ki kj kk kl km kn ko kp jc kq kr ks jg kt ku kv jk kw kx ky kz dt translated">码头工人哲学</h2><p id="2326" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">Docker容器是一个开源软件开发平台。它的主要好处是将应用程序打包在“容器”中，允许它们在任何运行Linux操作系统(OS)的系统之间移植。</p><p id="436b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">可以把Docker容器看作是虚拟化的另一种形式。虚拟机(VM)允许将一个硬件分割成不同的VM(或虚拟化),以便不同的用户可以共享硬件能力，并显示为独立的服务器或机器。Docker容器将操作系统虚拟化，将其分成虚拟化的隔间来运行容器应用程序。</p><blockquote class="lf lg lh"><p id="7bae" class="ir is li it b iu iv iw ix iy iz ja jb lj jd je jf lk jh ji jj ll jl jm jn jo hn dt translated">这种方法允许将代码片段放入更小的、易于移植的片段中，这些片段可以在任何运行Linux的地方运行。这是一种使应用程序更加分散的方式，并将它们分解成特定的功能。</p></blockquote><p id="2e34" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">容器映像是一个轻量级的、独立的、可执行的软件包，包含了运行它所需的一切:代码、运行时、系统工具、系统库、设置。基于Linux和Windows的应用程序都可以使用容器化软件，无论环境如何，容器化软件都可以运行。容器将软件从其周围环境中隔离出来，例如开发和阶段环境之间的差异，并有助于减少在同一基础设施上运行不同软件的团队之间的冲突。</p><p id="cbad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">docker <a class="ae jp" href="https://docs.docker.com/engine/installation/" rel="noopener ugc nofollow" target="_blank">安装</a>后，它使用命令行工作:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lm"><img src="../Images/e19ee9cac0e3777e8835e1f99e43b35c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7tq30P5RR5uhoaODvjLrRw.png"/></div></div></figure><p id="7b2d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有很多参数和选项。我们将主要用<a class="ae jp" href="https://docs.docker.com/engine/reference/commandline/build/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">构建</strong></a><a class="ae jp" href="https://docs.docker.com/engine/reference/commandline/images/" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">图像</strong></a><a class="ae jp" href="https://docs.docker.com/engine/reference/commandline/run/" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">运行</strong></a><a class="ae jp" href="https://docs.docker.com/engine/reference/commandline/exec/" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">exec</strong></a><a class="ae jp" href="https://docs.docker.com/engine/reference/commandline/rm/" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">RM</strong></a><strong class="it hv"/>和<a class="ae jp" href="https://docs.docker.com/engine/reference/commandline/rmi/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> rmi </strong> </a>。</p><h2 id="9db2" class="kf kg hu bd kh ki kj kk kl km kn ko kp jc kq kr ks jg kt ku kv jk kw kx ky kz dt translated">使用YEPS将node.js应用程序归档</h2><p id="4e7b" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">可以从node官方文档文章开始:<a class="ae jp" href="https://nodejs.org/uk/docs/guides/nodejs-docker-webapp/" rel="noopener ugc nofollow" target="_blank">dockering a node . js web app</a>。</p><p id="64c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要使用<a class="ae jp" href="https://www.docker.com/what-container" rel="noopener ugc nofollow" target="_blank"> docker容器</a>，您需要从<a class="ae jp" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> docker hub </a>获取图像，或者使用<a class="ae jp" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank"> Dockerfile </a>和<a class="ae jp" href="https://docs.docker.com/engine/reference/commandline/build/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> docker build </strong> </a>命令创建自己的图像。让我们使用node.js和<a class="ae jp" href="https://yeps.info/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> YEPS </strong>框架</a>创建自己的映像。</p><p id="bd87" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我在github 上创建了<a class="ae jp" href="https://github.com/evheniy/yeps-docker-example" rel="noopener ugc nofollow" target="_blank">库，所以你可以获得源代码:</a></p><pre class="jr js jt ju fq lr ls lt lu aw lv dt"><span id="fa51" class="kf kg hu ls b fv lw lx l ly lz">git clone https://github.com/evheniy/yeps-docker-example.git</span><span id="5734" class="kf kg hu ls b fv ma lx l ly lz">cd yeps-docker-example</span></pre><p id="841c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> Dockerfile </strong>:</p><pre class="jr js jt ju fq lr ls lt lu aw lv dt"><span id="b7ed" class="kf kg hu ls b fv lw lx l ly lz"><strong class="ls hv">FROM</strong> node:latest</span><span id="fa39" class="kf kg hu ls b fv ma lx l ly lz"># Create app directory<br/><strong class="ls hv">RUN</strong> mkdir -p /usr/src/app<br/><strong class="ls hv">WORKDIR</strong> /usr/src/app</span><span id="4e03" class="kf kg hu ls b fv ma lx l ly lz"># Install app dependencies<br/><strong class="ls hv">COPY</strong> package.json /usr/src/app/<br/><strong class="ls hv">RUN</strong> npm install</span><span id="d25e" class="kf kg hu ls b fv ma lx l ly lz"># Bundle app source<br/><strong class="ls hv">COPY</strong> . /usr/src/app</span><span id="d21a" class="kf kg hu ls b fv ma lx l ly lz"><strong class="ls hv">EXPOSE</strong> 3000</span><span id="4faa" class="kf kg hu ls b fv ma lx l ly lz"><strong class="ls hv">CMD</strong> [ "<strong class="ls hv">npm</strong>", "<strong class="ls hv">start</strong>" ]</span></pre><p id="1d17" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要创建自己的图像，您需要使用中的<strong class="it hv">从现有图像扩展它。该图像扩展了<a class="ae jp" href="https://hub.docker.com/_/node/" rel="noopener ugc nofollow" target="_blank"> docker hub </a>上的原始节点图像的最新版本。</strong></p><p id="c84c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">之后，我们需要在容器中创建工作目录。使用node.js有一个很好的做法，即复制package.json并在复制所有其他文件之前安装所有依赖项。所以我复制它并运行<strong class="it hv"> npm install </strong>命令来获取所有依赖项。在我将所有文件复制到容器后。</p><p id="3bd5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> EXPOSE </strong>命令使docker容器监听端口。而<strong class="it hv"> CMD </strong>命令运行我们的服务器。</p><p id="c792" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">只能有一个CMD </strong>命令。这是docker的理念— <strong class="it hv">每个容器一个流程</strong>。</p><p id="3889" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">建成后，我们可以在docker中心或自己的私人图像库存储我们的图像。但我不会在这篇文章中描述。</p><p id="7ab1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要构建它，请运行:</p><pre class="jr js jt ju fq lr ls lt lu aw lv dt"><span id="21d4" class="kf kg hu ls b fv lw lx l ly lz">docker build -t yeps .</span></pre><p id="36f5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我在<a class="ae jp" href="https://github.com/evheniy/yeps-docker-example" rel="noopener ugc nofollow" target="_blank"> README.md </a>文件中描述了如何处理该图像的所有示例和命令。选项<strong class="it hv"> -t </strong>为图像创建名称，在我们的例子中是<strong class="it hv"> yeps </strong>。</p><p id="03ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要运行容器:</p><pre class="jr js jt ju fq lr ls lt lu aw lv dt"><span id="a3d3" class="kf kg hu ls b fv lw lx l ly lz">docker run -p 3000:3000 --name yeps -d yeps</span></pre><p id="a033" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">选项<strong class="it hv"> -p </strong>将端口从主机映射到容器端口，选项<strong class="it hv"> -d </strong>将其作为服务运行。打开<a class="ae jp" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a>看到工作节点应用。</p><p id="11bb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有很多命令可以阻止它。简单的就是<strong class="it hv">docker stop&lt;continer id&gt;</strong>。要检查<strong class="it hv">集装箱id </strong>，运行<strong class="it hv"> docker ps -a </strong>。如果你运行<strong class="it hv"> docker image ls </strong>你可以找到图像:<strong class="it hv"> node </strong>和<strong class="it hv"> yeps </strong>。并使用<strong class="it hv"> docker镜像rm </strong>将其删除。但是还有其他方法来覆盖和移除图像:</p><pre class="jr js jt ju fq lr ls lt lu aw lv dt"><span id="cc9f" class="kf kg hu ls b fv lw lx l ly lz">docker rm -f yeps</span></pre><h2 id="adc5" class="kf kg hu bd kh ki kj kk kl km kn ko kp jc kq kr ks jg kt ku kv jk kw kx ky kz dt translated"><strong class="ak">交互模式</strong></h2><p id="920b" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">Docker帮助处理图像，但不构建自己的图像。在docker hub上，你可以找到很多有趣的官方和非官方图片。你可以扩展它来制作自己的新图像，或者只是出于某些原因运行它。</p><p id="0e44" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个有趣的例子是测试。在node.js的官方docker hub页面上，有许多不同node.js版本的图片。这对测试很有用。例如，我将展示如何测试任何node.js应用程序。再来试试<strong class="it hv"> YEPS </strong>框架。首先我们应该从github获取代码:</p><pre class="jr js jt ju fq lr ls lt lu aw lv dt"><span id="a596" class="kf kg hu ls b fv lw lx l ly lz">git clone https://github.com/evheniy/yeps.git<br/>cd yeps</span></pre><p id="1256" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们需要使用任何节点版本运行npm测试命令之后，如下所示:</p><pre class="jr js jt ju fq lr ls lt lu aw lv dt"><span id="2cf1" class="kf kg hu ls b fv lw lx l ly lz">docker run -it --rm -v "$PWD":/www -w /www <strong class="ls hv">node:8</strong> /bin/bash -c "node -v &amp;&amp; npm -v &amp;&amp; npm i &amp;&amp; npm t"</span></pre><p id="145d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里我们使用<strong class="it hv"> node:8 </strong> image运行docker image(我使用最新的8版本，你可以指定任何其他版本)。<strong class="it hv"> -it </strong>参数有助于在交互模式下运行它，并在完成后清除所有数据我们放入<strong class="it hv"> — rm </strong>参数。如何从旧的容器和图像中清理光盘，我将在教程中描述。</p><p id="ac74" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">命令<strong class="it hv"> -v </strong>帮助将当前目录映射到<strong class="it hv"> /www </strong>和<strong class="it hv"> -w </strong>命令是<strong class="it hv"> cd </strong>命令的模拟(改变目录)，它帮助在这个目录中运行我们的命令。</p><p id="4fd6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们运行node.js命令<strong class="it hv">node-v&amp;&amp;NPM-v&amp;&amp;NPM I&amp;&amp;NPM t</strong>，使用标志<strong class="it hv"> -c </strong>。</p><p id="ac02" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您需要使用<strong class="it hv"> node.js 7 </strong>运行相同的命令，只需更改节点的docker映像:</p><pre class="jr js jt ju fq lr ls lt lu aw lv dt"><span id="c66e" class="kf kg hu ls b fv lw lx l ly lz">docker run -it --rm -v "$PWD":/www -w /www <strong class="ls hv">node:7</strong> /bin/bash -c "<strong class="ls hv">node -v &amp;&amp; npm -v &amp;&amp; npm i &amp;&amp; npm t</strong>"</span></pre><p id="34c9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以在<a class="ae jp" href="https://hub.docker.com/_/node/" rel="noopener ugc nofollow" target="_blank"> docker hub </a>上找到来自官方资料库的所有节点图片。但是作为一个好的实践，如果你看到有基于alpine linux的映像，最好使用它们来减少磁盘空间。因此，如果我们需要使用最新的节点版本测试我们的应用程序，只需运行即可(在alpine linux中，我们需要使用<strong class="it hv"> /bin/sh </strong>而不是<strong class="it hv"> bash </strong>):</p><pre class="jr js jt ju fq lr ls lt lu aw lv dt"><span id="6016" class="kf kg hu ls b fv lw lx l ly lz">docker run -it --rm -v "$PWD":/www -w /www <strong class="ls hv">node:alpine</strong> <strong class="ls hv">/bin/sh</strong> -c "<strong class="ls hv">node -v &amp;&amp; npm -v &amp;&amp; npm i &amp;&amp; npm t</strong>"</span></pre><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff mb"><img src="../Images/928cfef4d2cdc09cba907657d333445b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KxZqK5CGumnvX_O1IRBFag.png"/></div></div></figure><h2 id="9a94" class="kf kg hu bd kh ki kj kk kl km kn ko kp jc kq kr ks jg kt ku kv jk kw kx ky kz dt translated">数据库即服务</h2><p id="e11f" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">为了测试不同数据库的YEPS包，我使用了docker。比如<a class="ae jp" href="https://github.com/evheniy/yeps-redis" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> yeps-redis </strong> </a>。为了运行和停止测试，我在<strong class="it hv"> package.json </strong>的脚本部分添加了命令:</p><pre class="jr js jt ju fq lr ls lt lu aw lv dt"><span id="3d4e" class="kf kg hu ls b fv lw lx l ly lz">"<strong class="ls hv">db:start</strong>": "docker run -d --name redis -p 6379:6379 redis:latest",    "<strong class="ls hv">db:stop</strong>": "docker rm -f redis"</span></pre><p id="598d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样适用于<a class="ae jp" href="https://github.com/evheniy/yeps-mysql" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> yeps-mysql </strong> </a>:</p><pre class="jr js jt ju fq lr ls lt lu aw lv dt"><span id="ec91" class="kf kg hu ls b fv lw lx l ly lz">"<strong class="ls hv">db:start</strong>": "docker run -d --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=yeps mysql:latest",    </span><span id="e964" class="kf kg hu ls b fv ma lx l ly lz">"<strong class="ls hv">db:stop</strong>": "docker rm -f mysql"</span></pre><p id="e023" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里使用<strong class="it hv"> -e </strong>选项我设置环境变量，如用户和密码。</p><p id="3572" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">而对于<a class="ae jp" href="https://github.com/evheniy/yeps-mongoose" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">yeps-mongose</strong></a>:</p><pre class="jr js jt ju fq lr ls lt lu aw lv dt"><span id="6651" class="kf kg hu ls b fv lw lx l ly lz">"<strong class="ls hv">db:start</strong>": "docker run -d --name mongo -p 27017:27017 mongo",    "<strong class="ls hv">db:stop</strong>": "docker rm -f mongo"</span></pre><p id="59b2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我使用<a class="ae jp" href="https://travis-ci.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> TravisCI </strong> </a>进行测试时，使用docker作为服务很容易，因为TravisCI基于docker。只需注册存储库并创建<strong class="it hv"> .travis.yml </strong>就像我为<strong class="it hv"/><a class="ae jp" href="https://github.com/evheniy/yeps-mongoose/blob/master/.travis.yml" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">yeps-mongose</strong></a>:</p><pre class="jr js jt ju fq lr ls lt lu aw lv dt"><span id="aff9" class="kf kg hu ls b fv lw lx l ly lz">sudo: required<br/>language: node_js<br/>node_js:<br/>  - "7"<br/>  - "8"<br/><strong class="ls hv">services:<br/>  - docker</strong><br/>before_install:<br/>  - npm install<br/>script:<br/>  - docker version<br/>  - node --version<br/>  - npm --version<br/>  - npm run lint<br/>  - npm run test<br/>  - npm run report<br/></span></pre><p id="02ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您需要使用私有CI服务，您可以使用<a class="ae jp" href="https://jenkins.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> Jenkins </strong> </a>或<a class="ae jp" href="https://www.jetbrains.com/teamcity/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> TeamCity </strong> </a>。詹金斯在docker hub 上有<a class="ae jp" href="https://hub.docker.com/_/jenkins/" rel="noopener ugc nofollow" target="_blank">官方资源库，你可以在那里找到如何运行它的文档。例如:</a></p><pre class="jr js jt ju fq lr ls lt lu aw lv dt"><span id="eec9" class="kf kg hu ls b fv lw lx l ly lz">docker run --name jenkins -p 8080:8080 -d jenkins</span></pre><p id="f17a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要访问管理员界面，您需要获得管理员<strong class="it hv">密码</strong>。当我们用<strong class="it hv"> -d </strong>选项运行我们的容器时，我们只能从<strong class="it hv">/var/Jenkins _ home/secrets/initial admin password</strong>中获得它:</p><pre class="jr js jt ju fq lr ls lt lu aw lv dt"><span id="c9bb" class="kf kg hu ls b fv lw lx l ly lz">docker exec jenkins <strong class="ls hv">cat /var/jenkins_home/secrets/initialAdminPassword</strong></span></pre><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff mc"><img src="../Images/4e776c29fab777b0bf45a4c8523cfde7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*67iMpBjUAG_IAFcg5JtW3g.png"/></div></div></figure><p id="8956" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里我使用<strong class="it hv"> exec </strong>命令。它有助于在运行容器中运行类似于"<strong class="it hv">cat/var/Jenkins _ home/secrets/initialAdminPassword "</strong>的命令。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff mc"><img src="../Images/15c5a3f0a31bfc325ff62ac252b6cb27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oYsW1zvA4uZuKQODTykpjw.png"/></div></div></figure><p id="b52b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">并命令<strong class="it hv">“docker RM-f Jenkins”</strong>将其停止。</p><p id="2311" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">团队合作也差不多。但是这里我们需要运行主进程(服务器)并在单独的容器中构建代理。</p><p id="a61f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是首先，我们需要创建目录来存储我们的配置和日志:</p><pre class="jr js jt ju fq lr ls lt lu aw lv dt"><span id="fa61" class="kf kg hu ls b fv lw lx l ly lz">mkdir teamcity<br/>cd teamcity</span></pre><p id="6df6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要启动<a class="ae jp" href="https://hub.docker.com/r/jetbrains/teamcity-server/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> TeamCity服务器</strong> </a>只需运行:</p><pre class="jr js jt ju fq lr ls lt lu aw lv dt"><span id="0bc2" class="kf kg hu ls b fv lw lx l ly lz">docker run -it --name teamcity-server-instance  -v "$PWD"/datadir:/data/teamcity_server/datadir -v "$PWD"/logs:/opt/teamcity/logs -p 8111:8111 -d jetbrains/teamcity-server</span></pre><p id="3724" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于<a class="ae jp" href="https://hub.docker.com/r/jetbrains/teamcity-agent/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">构建代理</strong> </a> <strong class="it hv"> </strong>几乎相同(在免费版本中，我们只能使用3个构建代理):</p><pre class="jr js jt ju fq lr ls lt lu aw lv dt"><span id="9b05" class="kf kg hu ls b fv lw lx l ly lz">docker run -it -d -e SERVER_URL="teamcity-server-instance:8111" -v "$PWD"/<strong class="ls hv">agent1</strong>:/data/teamcity_agent/conf --link teamcity-server-instance:teamcity-server-instance --privileged jetbrains/teamcity-agent</span><span id="b4ac" class="kf kg hu ls b fv ma lx l ly lz">docker run -it -d -e SERVER_URL="teamcity-server-instance:8111" -v "$PWD"/<strong class="ls hv">agent2</strong>:/data/teamcity_agent/conf --link teamcity-server-instance:teamcity-server-instance --privileged jetbrains/teamcity-agent</span><span id="1e26" class="kf kg hu ls b fv ma lx l ly lz">docker run -it -d -e SERVER_URL="teamcity-server-instance:8111" -v "$PWD"/<strong class="ls hv">agent3</strong>:/data/teamcity_agent/conf --link teamcity-server-instance:teamcity-server-instance --privileged jetbrains/teamcity-agent</span></pre><p id="48ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我为每个代理指定了不同的名称和目录。如您所见，我将服务器和代理的目录映射到本地目录<strong class="it hv"> teamcity </strong>。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff mc"><img src="../Images/2174ce310de64717695931422f376521.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5BR30g4gLRVYxlOyheKT2Q.png"/></div></div></figure><h2 id="f666" class="kf kg hu bd kh ki kj kk kl km kn ko kp jc kq kr ks jg kt ku kv jk kw kx ky kz dt translated">Docker撰写</h2><p id="1df4" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">如果您需要构建和运行单个映像，Docker是个好东西。但是在大多数真正的应用程序中，你需要同时处理不同的东西。数据库、集群模式下的实例、微服务…以及<a class="ae jp" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">Docker compose</strong></a>是这方面的完美工具。</p><blockquote class="lf lg lh"><p id="0b70" class="ir is li it b iu iv iw ix iy iz ja jb lj jd je jf lk jh ji jj ll jl jm jn jo hn dt translated">Compose是一个定义和运行多容器Docker应用程序的工具。使用Compose，您可以使用YAML文件来配置应用程序的服务。然后，只需一个命令，您就可以从您的配置中创建并启动所有服务。要了解更多关于Compose的所有特性，请参见特性列表。</p></blockquote><p id="a207" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Compose具有用于管理应用程序整个生命周期的命令:</p><ul class=""><li id="5b73" class="md me hu it b iu iv iy iz jc mf jg mg jk mh jo mi mj mk ml dt translated">启动、停止和重建服务</li><li id="97b7" class="md me hu it b iu mm iy mn jc mo jg mp jk mq jo mi mj mk ml dt translated">查看运行服务的状态</li><li id="15c7" class="md me hu it b iu mm iy mn jc mo jg mp jk mq jo mi mj mk ml dt translated">流式传输正在运行的服务的日志输出</li><li id="fd4c" class="md me hu it b iu mm iy mn jc mo jg mp jk mq jo mi mj mk ml dt translated">在服务上运行一次性命令</li></ul><p id="4ab7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们为我们的<strong class="it hv"> TeamCity </strong>集群创建一个组合版本— <strong class="it hv"> docker-compose.yml </strong>:</p><pre class="jr js jt ju fq lr ls lt lu aw lv dt"><span id="9c46" class="kf kg hu ls b fv lw lx l ly lz">version: '2'<br/>services:<br/>  <strong class="ls hv">server</strong>:<br/>    restart: unless-stopped<br/>    <strong class="ls hv">image</strong>: jetbrains/teamcity-server<br/>    <strong class="ls hv">ports</strong>:<br/>      - "8111:8111"<br/>    <strong class="ls hv">volumes</strong>:<br/>      - "./server/datadir:/data/teamcity_server/datadir"<br/>      - "./server/logs:/opt/teamcity/logs"<br/>  <strong class="ls hv">agent1</strong>:<br/>    restart: unless-stopped<br/>    <strong class="ls hv">image</strong>: jetbrains/teamcity-agent<br/>    <strong class="ls hv">links</strong>:<br/>      - "server:server"<br/>    <strong class="ls hv">environment</strong>:<br/>      SERVER_URL: server:8111<br/>    <strong class="ls hv">volumes</strong>:<br/>      - "./<strong class="ls hv">agent1</strong>:/data/teamcity_agent/conf"<br/>  <strong class="ls hv">agent2</strong>:<br/>    restart: unless-stopped<br/>    <strong class="ls hv">image</strong>: jetbrains/teamcity-agent<br/>    <strong class="ls hv">links</strong>:<br/>      - "server:server"<br/>    <strong class="ls hv">environment</strong>:<br/>      SERVER_URL: server:8111<br/>    <strong class="ls hv">volumes</strong>:<br/>      - "./<strong class="ls hv">agent2</strong>:/data/teamcity_agent/conf"<br/>  <strong class="ls hv">agent3</strong>:<br/>    restart: unless-stopped<br/>    <strong class="ls hv">image</strong>: jetbrains/teamcity-agent<br/>    <strong class="ls hv">links</strong>:<br/>      - "server:server"<br/>    <strong class="ls hv">environment</strong>:<br/>      SERVER_URL: server:8111<br/>    <strong class="ls hv">volumes</strong>:<br/>      - "./<strong class="ls hv">agent3</strong>:/data/teamcity_agent/conf"</span></pre><p id="0496" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们使用几乎相同的参数(<strong class="it hv">端口</strong>、<strong class="it hv">映像</strong>、<strong class="it hv">卷</strong>)，但有一些特定的更新。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lm"><img src="../Images/ce9c2c5a347abfe1a07dca3c6cc87c7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*li5ZQEsfQsGBVGxOQ0ug3A.png"/></div></div></figure><p id="a32d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要开始编写，只需运行<strong class="it hv"> docker-compose up </strong>或将其作为服务运行:</p><pre class="jr js jt ju fq lr ls lt lu aw lv dt"><span id="1245" class="kf kg hu ls b fv lw lx l ly lz">docker-compose up -d</span></pre><p id="f0cb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">并停止:</p><pre class="jr js jt ju fq lr ls lt lu aw lv dt"><span id="6ca8" class="kf kg hu ls b fv lw lx l ly lz">docker-compose stop</span></pre><p id="92c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">把所有东西都拿下来(用卷):</p><pre class="jr js jt ju fq lr ls lt lu aw lv dt"><span id="daab" class="kf kg hu ls b fv lw lx l ly lz">docker-compose down --volumes</span></pre><p id="3566" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者，如果您想要删除docker图像:</p><pre class="jr js jt ju fq lr ls lt lu aw lv dt"><span id="31e4" class="kf kg hu ls b fv lw lx l ly lz">docker-compose down --rmi all</span></pre><p id="4d13" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们用node.js实例集群和作为负载平衡器的<a class="ae jp" href="https://nginx.org/" rel="noopener ugc nofollow" target="_blank"> nginx </a>来更新我们之前的node.js <strong class="it hv"> YEPS </strong>示例。</p><p id="1288" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我创建了一个<a class="ae jp" href="https://github.com/evheniy/yeps-docker-compose-example" rel="noopener ugc nofollow" target="_blank"> github库</a>，所以只需克隆它:</p><pre class="jr js jt ju fq lr ls lt lu aw lv dt"><span id="0230" class="kf kg hu ls b fv lw lx l ly lz">git clone <a class="ae jp" href="https://github.com/evheniy/yeps-docker-compose-example.git" rel="noopener ugc nofollow" target="_blank">https://github.com/evheniy/yeps-docker-compose-example.git</a><br/>cd <a class="ae jp" href="https://github.com/evheniy/yeps-docker-compose-example.git" rel="noopener ugc nofollow" target="_blank">yeps-docker-compose-example</a></span><span id="8ccc" class="kf kg hu ls b fv ma lx l ly lz">docker-compose up -d</span></pre><p id="100f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个例子中，我们有<a class="ae jp" href="https://github.com/evheniy/yeps-docker-compose-example/blob/master/docker-compose.yml" rel="noopener ugc nofollow" target="_blank"> docker-compose.yml </a>和两个目录:<a class="ae jp" href="https://github.com/evheniy/yeps-docker-compose-example/tree/master/nginx" rel="noopener ugc nofollow" target="_blank"> nginx </a>和<a class="ae jp" href="https://github.com/evheniy/yeps-docker-compose-example/tree/master/node" rel="noopener ugc nofollow" target="_blank">节点</a>。您可以打开链接并检查每个文件。我使用了与前面的合成示例相同的想法。但是这次我为nginx构建了自己的映像:</p><pre class="jr js jt ju fq lr ls lt lu aw lv dt"><span id="5cdb" class="kf kg hu ls b fv lw lx l ly lz"># Set nginx base image<br/><strong class="ls hv">FROM</strong> nginx:latest<br/><br/># Copy custom configuration file from the current directory<br/><strong class="ls hv">COPY</strong> nginx.conf /etc/nginx/nginx.conf</span></pre><p id="471d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于节点I，使用现有的<a class="ae jp" href="https://github.com/evheniy/yeps-docker-compose-example/blob/master/node/Dockerfile" rel="noopener ugc nofollow" target="_blank"> Dockerfile </a>。</p><p id="c99a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> Docker </strong>和<strong class="it hv"> Docker compose </strong>即使使用<strong class="it hv">微服务架构</strong>，也能真正帮助开发和测试真正的现代应用。但是你不仅可以用它来开发。接下来我将向您展示如何使用它进行数据科学实验。</p><h2 id="94c2" class="kf kg hu bd kh ki kj kk kl km kn ko kp jc kq kr ks jg kt ku kv jk kw kx ky kz dt translated">机器学习</h2><p id="1094" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">同样的想法不仅对开发有用，我指的是计算机科学。它对数据科学很有用。在docker容器中运行机器学习实验也是一个不错的选择。</p><p id="9ad4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了我在<strong class="it hv">机器学习</strong>中的实验，我基于<a class="ae jp" href="https://hub.docker.com/r/continuumio/anaconda3/" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">python anaconda</strong></a>创建了<a class="ae jp" href="https://github.com/evheniy/python-docker" rel="noopener ugc nofollow" target="_blank"> github库</a>。</p><p id="64f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要使用这个容器，只需克隆git存储库并构建映像:</p><pre class="jr js jt ju fq lr ls lt lu aw lv dt"><span id="557e" class="kf kg hu ls b fv lw lx l ly lz">$ git clone https://github.com/evheniy/python-docker.git<br/>$ cd python-docker</span></pre><p id="e511" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于我经常使用<strong class="it hv"> node.js </strong>和<strong class="it hv"> npm </strong>，我在<strong class="it hv"> package.json </strong> <a class="ae jp" href="https://github.com/evheniy/python-docker/blob/master/package.json" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">脚本部分</strong> </a>中创建了命令，并在<a class="ae jp" href="https://github.com/evheniy/python-docker" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> README.md </strong> </a>文件中进行了描述。</p><p id="afff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以对于build只需运行<strong class="it hv"> npm运行build </strong>或<strong class="it hv"> docker build -t python </strong> <strong class="it hv">。</strong>”。并开始:<strong class="it hv"> npm start </strong>或“<strong class="it hv">docker run—name python-p 8888:8888-v $ PWD/python:/opt/notebooks-d python</strong>”。在这里，我使用参数<strong class="it hv"> -d </strong>进行恶魔化处理，使用参数<strong class="it hv"> -v </strong>映射当前目录，并在停止容器后保存我的所有数据。</p><p id="e0d8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">并使用密码<strong class="it hv"> root </strong>打开<a class="ae jp" href="http://localhost:8888/" rel="noopener ugc nofollow" target="_blank"> http://localhost:8888 </a>。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff mr"><img src="../Images/721c19c45991787cb79068f8e58a3ae4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Co7ihmakA_MqCS1aDzW2_w.png"/></div></div></figure><p id="6583" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以使用<strong class="it hv"> jupyter笔记本</strong>的web UI找到一些示例，并运行任何示例<strong class="it hv"> plot_face_recognition </strong>:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff mc"><img src="../Images/109c617b3e8c6b42e5ecd8ea648bcf40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mbJtP1b3dBw5xGOC4mnbtw.png"/></div></div></figure><p id="f338" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Docker有助于在任何地方使用相同的环境(<strong class="it hv"> python </strong>、<a class="ae jp" href="http://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> scikit-learn </strong> </a>、<a class="ae jp" href="https://pypi.python.org/pypi" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">SkPy</strong></a>……)工作。完成后，需要使用<strong class="it hv"> npm运行停止</strong>停止容器，并使用<strong class="it hv"> npm运行rm </strong>清洁圆盘空间。</p><h2 id="461c" class="kf kg hu bd kh ki kj kk kl km kn ko kp jc kq kr ks jg kt ku kv jk kw kx ky kz dt translated"><strong class="ak">清洁</strong></h2><p id="d824" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">Docker使得将应用程序和服务封装在容器中变得容易，这样你就可以在任何地方运行它们。然而，当您使用Docker时，也很容易积累大量未使用的图像、容器和数据卷，从而使输出混乱并消耗磁盘空间。</p><p id="ba38" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Docker没有提供直接的清理命令，但是它提供了从命令行清理系统所需的所有工具。在本教程中，你可以找到一些命令的快速参考，这些命令有助于通过删除未使用的Docker映像、容器和卷来释放磁盘空间并保持系统有序。</p><p id="2955" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我将在这里提供一些有用的命令:</p><p id="bdc5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">所有图像列表:</strong></p><pre class="jr js jt ju fq lr ls lt lu aw lv dt"><span id="9386" class="kf kg hu ls b fv lw lx l ly lz">docker image ls</span></pre><p id="bdad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">运行容器</strong>:</p><pre class="jr js jt ju fq lr ls lt lu aw lv dt"><span id="5f3e" class="kf kg hu ls b fv lw lx l ly lz">docker ps -a</span></pre><p id="5c24" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">一行停止并移除所有容器:</strong></p><pre class="jr js jt ju fq lr ls lt lu aw lv dt"><span id="626f" class="kf kg hu ls b fv lw lx l ly lz">docker rm -f $(docker ps -a -q)</span></pre><p id="60fc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">并删除所有图像:</strong></p><pre class="jr js jt ju fq lr ls lt lu aw lv dt"><span id="4a72" class="kf kg hu ls b fv lw lx l ly lz">docker rmi -f $(docker images -q)</span></pre><p id="7f84" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">删除所有悬空卷:</strong></p><pre class="jr js jt ju fq lr ls lt lu aw lv dt"><span id="435c" class="kf kg hu ls b fv lw lx l ly lz">docker volume rm $(docker volume ls -f dangling=true -q)</span></pre><h2 id="301b" class="kf kg hu bd kh ki kj kk kl km kn ko kp jc kq kr ks jg kt ku kv jk kw kx ky kz dt translated"><strong class="ak">结论</strong></h2><p id="8a76" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">在本教程中，我展示了一些使用docker的有用例子和命令。有许多其他的组合和标志可以与每一个一起使用。要获得更多信息，你可以阅读docker文档，我建议你完成T2的Udemy课程。</p><p id="21d5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Docker可以帮助研究和测试新工具、数据库、机器学习和大数据工具，如<a class="ae jp" href="http://hadoop.apache.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> Hadoop </strong> </a>和<a class="ae jp" href="https://spark.apache.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> Apache Spark </strong> </a>。您可以在本地运行它，并在停止后保持您的电脑干净。</p><p id="4103" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如我之前所说，docker是一个用于<strong class="it hv">开发</strong>和<strong class="it hv">测试</strong>的伟大工具。在生产中，您将使用<strong class="it hv"> devops </strong>帮助来配置web服务，如<strong class="it hv"> AWS </strong>。所以有了docker，你现在可以使用任何东西，让我们devops关心生产。</p></div></div>    
</body>
</html>