<html>
<head>
<title>You Don’t Need a Domain Service Class in DDD</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在DDD你不需要域服务类</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/you-dont-need-a-domain-service-class-in-ddd-9ecd3140782?source=collection_archive---------4-----------------------#2017-09-03">https://medium.com/hackernoon/you-dont-need-a-domain-service-class-in-ddd-9ecd3140782?source=collection_archive---------4-----------------------#2017-09-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="029c" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">你也不需要一个应用服务类！</h2></div><p id="c9f2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们检查一下这个概念的作者所下的定义:</p><blockquote class="kf kg kh"><p id="a09f" class="jj jk ki jl b jm jn iv jo jp jq iy jr kj jt ju jv kk jx jy jz kl kb kc kd ke hn dt translated">当领域中的重要过程或转换不是实体或值对象的自然职责时，将操作作为独立接口添加到模型中，并声明为服务。根据模型的语言定义接口，并确保操作名称是通用语言的一部分。使服务无状态。</p><p id="fc92" class="jj jk ki jl b jm jn iv jo jp jq iy jr kj jt ju jv kk jx jy jz kl kb kc kd ke hn dt translated"><a class="ae km" href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hv">埃里克·埃文斯，</strong>领域驱动设计</a></p></blockquote><h2 id="fd41" class="kn ko hu bd kp kq kr ks kt ku kv kw kx js ky kz la jw lb lc ld ka le lf lg lh dt translated">服务类别是程序性的</h2><p id="e649" class="pw-post-body-paragraph jj jk hu jl b jm li iv jo jp lj iy jr js lk ju jv jw ll jy jz ka lm kc kd ke hn dt translated">用简单的英语来说，这意味着它只不过是一个程序。为什么？因为你接受一个对象，操作它的数据并把它传递给另一个对象。这与面向对象的基本原则相矛盾，面向对象的基本原则是数据和行为共存。所以在我的客体世界里，一切都是某个客体的责任。涉及域服务的程序代码的典型例子是<a class="ae km" href="http://Consider an example of password hashing given here." rel="noopener ugc nofollow" target="_blank">密码散列</a>。</p><h2 id="4114" class="kn ko hu bd kp kq kr ks kt ku kv kw kx js ky kz la jw lb lc ld ka le lf lg lh dt translated">请使用装饰者</h2><p id="5a4a" class="pw-post-body-paragraph jj jk hu jl b jm li iv jo jp lj iy jr js lk ju jv jw ll jy jz ka lm kc kd ke hn dt translated">每当你需要一些新的行为时，你应该考虑使用一个<a class="ae km" href="https://en.wikipedia.org/wiki/Decorator_pattern" rel="noopener ugc nofollow" target="_blank">装饰模式</a>。所以上面的例子可以这样改写:</p><pre class="ln lo lp lq fq lr ls lt lu aw lv dt"><span id="b4f2" class="kn ko hu ls b fv lw lx l ly lz"><strong class="ls hv">try </strong>{<br/>    <strong class="ls hv">echo<br/>    </strong>(<strong class="ls hv">new </strong>HashedPassword(<br/>        <strong class="ls hv">new </strong>RegexMatchedPassword(<br/>            <strong class="ls hv">new </strong>NonEmptyPassword(<br/>                <strong class="ls hv">new </strong>Password(<strong class="ls hv">'asdSd12@A1'</strong>)<br/>            ),<br/>            <strong class="ls hv">new </strong>Regex(<strong class="ls hv">'/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[$@$!%*?&amp;])[A-Za-z\d$@$!%*?&amp;]{8,10}$/'</strong>)<br/>        )<br/>    ))<br/>        -&gt;string()<br/>    ;<br/>} <strong class="ls hv">catch </strong>(Exception $exception) {<br/>    <strong class="ls hv">echo </strong>$exception-&gt;getMessage();<br/>}</span></pre><p id="bf5a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所有人注意' HashedPassword '类。所有散列功能都驻留在那里。我喜欢这个名字——哈希密码。它非常具有声明性，不像“哈希密码”，它更像是“如何”，而不是“什么”，因此本质上是必要的。</p><p id="1aa0" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">除了将域服务的功能转移到<a class="ae km" href="https://en.wikipedia.org/wiki/Domain-driven_design" rel="noopener ugc nofollow" target="_blank"> DDD的</a> <a class="ae km" href="http://deviq.com/value-object/" rel="noopener ugc nofollow" target="_blank">值对象</a>之外，我还使用了<a class="ae km" href="http://www.yegor256.com/2016/01/26/defensive-programming.html" rel="noopener ugc nofollow" target="_blank">验证装饰器</a>，这是叶戈尔·布加延科引入的概念。</p><p id="62b6" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">下面是剩余的代码:</p><pre class="ln lo lp lq fq lr ls lt lu aw lv dt"><span id="fc25" class="kn ko hu ls b fv lw lx l ly lz"><strong class="ls hv">interface </strong>IPassword<br/>{<br/>    <strong class="ls hv">public function </strong>string();<br/>}<br/><br/><strong class="ls hv">class </strong>Password <strong class="ls hv">implements </strong>IPassword<br/>{<br/>    <strong class="ls hv">private $password</strong>;<br/><br/>    <strong class="ls hv">public function </strong>__construct($password)<br/>    {<br/>        $this-&gt;<strong class="ls hv">password </strong>= $password;<br/>    }<br/><br/>    <strong class="ls hv">public function </strong>string()<br/>    {<br/>        <strong class="ls hv">return </strong>$this-&gt;<strong class="ls hv">password</strong>;<br/>    }<br/>}<br/><br/><strong class="ls hv">class </strong>NonEmptyPassword <strong class="ls hv">implements </strong>IPassword<br/>{<br/>    <strong class="ls hv">private $password</strong>;<br/><br/>    <strong class="ls hv">public function </strong>__construct(IPassword $password)<br/>    {<br/>        $this-&gt;<strong class="ls hv">password </strong>= $password;<br/>    }<br/><br/>    <strong class="ls hv">public function </strong>string()<br/>    {<br/>        <strong class="ls hv">if </strong>(<em class="ki">is_null</em>($this-&gt;<strong class="ls hv">password</strong>-&gt;string())) {<br/>            <strong class="ls hv">throw new </strong>Exception(<strong class="ls hv">'Password can not be empty'</strong>);<br/>        }<br/><br/>        <strong class="ls hv">return </strong>$this-&gt;<strong class="ls hv">password</strong>-&gt;string();<br/>    }<br/>}<br/><br/><strong class="ls hv">class </strong>RegexMatchedPassword <strong class="ls hv">implements </strong>IPassword<br/>{<br/>    <strong class="ls hv">private $password</strong>;<br/>    <strong class="ls hv">private $regex</strong>;<br/><br/>    <strong class="ls hv">public function </strong>__construct(IPassword $password, IRegex $regex)<br/>    {<br/>        $this-&gt;<strong class="ls hv">password </strong>= $password;<br/>        $this-&gt;<strong class="ls hv">regex </strong>= $regex;<br/>    }<br/><br/>    <strong class="ls hv">public function </strong>string()<br/>    {<br/>        <em class="ki">// https://stackoverflow.com/a/21456918/618020<br/>        </em><strong class="ls hv">if </strong>(!<em class="ki">preg_match</em>($this-&gt;<strong class="ls hv">regex</strong>-&gt;value(), $this-&gt;<strong class="ls hv">password</strong>-&gt;string())) {<br/>            <strong class="ls hv">throw new </strong>Exception(<br/>                <strong class="ls hv">'Password must have minimum eight and maximum 10 characters, at least one uppercase letter,<br/>                one lowercase letter, one number and one special character.'<br/>            </strong>);<br/>        }<br/><br/>        <strong class="ls hv">return </strong>$this-&gt;<strong class="ls hv">password</strong>-&gt;string();<br/>    }<br/>}<br/><br/><strong class="ls hv">interface </strong>IRegex<br/>{<br/>    <strong class="ls hv">public function </strong>value();<br/>}<br/><br/><strong class="ls hv">class </strong>Regex <strong class="ls hv">implements </strong>IRegex<br/>{<br/>    <strong class="ls hv">private $regex</strong>;<br/><br/>    <strong class="ls hv">public function </strong>__construct($regex)<br/>    {<br/>        $this-&gt;<strong class="ls hv">regex </strong>= $regex;<br/>    }<br/><br/>    <strong class="ls hv">public function </strong>value()<br/>    {<br/>        <strong class="ls hv">if </strong>(<em class="ki">preg_match</em>($this-&gt;<strong class="ls hv">regex</strong>, <strong class="ls hv">null</strong>) === <strong class="ls hv">false</strong>) {<br/>            <strong class="ls hv">throw new </strong>Exception(<strong class="ls hv">'Your regex is broken.'</strong>);<br/>        }<br/><br/>        <strong class="ls hv">return </strong>$this-&gt;<strong class="ls hv">regex</strong>;<br/>    }<br/>}<br/><br/><strong class="ls hv">class </strong>HashedPassword <strong class="ls hv">implements </strong>IPassword<br/>{<br/>    <strong class="ls hv">private $password</strong>;<br/><br/>    <strong class="ls hv">public function </strong>__construct(IPassword $password)<br/>    {<br/>        $this-&gt;<strong class="ls hv">password </strong>= $password;<br/>    }<br/><br/>    <strong class="ls hv">public function </strong>string()<br/>    {<br/>        <strong class="ls hv">return </strong><em class="ki">sha1</em>($this-&gt;<strong class="ls hv">password</strong>-&gt;string());<br/>    }<br/>}</span></pre><p id="b69f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，如果对象设计得当，就不会有服务。只有正常的物体，代表真实的东西。所以根据这个启发，我认为应用服务也是一个错误。</p><p id="fde2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">敬请关注。</p></div></div>    
</body>
</html>