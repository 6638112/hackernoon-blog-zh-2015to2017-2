<html>
<head>
<title>Threaded Asynchronous Magic and How to Wield It</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">线程异步魔法及其使用方法</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/threaded-asynchronous-magic-and-how-to-wield-it-bba9ed602c32?source=collection_archive---------1-----------------------#2016-12-06">https://medium.com/hackernoon/threaded-asynchronous-magic-and-how-to-wield-it-bba9ed602c32?source=collection_archive---------1-----------------------#2016-12-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/469be7cbc4b75f46dda2b29334c5185f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VG4z1QlZa6J7siTU0zkTjQ.jpeg"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Photo Credit: <a class="ae ih" href="https://en.wikipedia.org/wiki/File:CTA_loop_junction.jpg" rel="noopener ugc nofollow" target="_blank">Daniel Schwen</a> via Wikipedia</figcaption></figure><div class=""/><div class=""><h2 id="763a" class="pw-subtitle-paragraph jh ij ik bd b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy ek translated">深入Python的asyncio任务和事件循环</h2></div><p id="4421" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">好吧，面对现实吧。时钟速度不再决定计算机处理器改进的速度。相反，我们看到晶体管密度增加，内核数量增加。翻译成软件术语，这意味着代码不会运行得更快，但更多的代码可以并行运行。</p><p id="20b0" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">尽管充分利用我们新发现的硅资源需要改进软件，但许多编程语言已经通过添加有助于并行执行的功能开始走上这条道路。事实上，他们已经在那里等了好几年，等着我们去利用。</p><p id="99ce" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">那我们为什么不呢？一个好的工程师总是耳听八方，倾听他所在行业的最新趋势，所以让我们看看Python正在为我们构建什么。</p><h2 id="e088" class="kv kw ik bd kx ky kz la lb lc ld le lf ki lg lh li km lj lk ll kq lm ln lo lp dt translated">到目前为止我们有什么？</h2><p id="b5ad" class="pw-post-body-paragraph jz ka ik kb b kc lq jl ke kf lr jo kh ki ls kk kl km lt ko kp kq lu ks kt ku hn dt translated">Python通过线程库和多处理库实现了并行性。然而直到3.4分支才给了我们<em class="lv"> asyncio </em>库来帮助单线程并发。这一增加是从版本2开始交换的更有说服力的最终推动力的关键。</p><p id="3cea" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">asyncio包允许我们定义协程。这些代码块能够将执行让给其他代码块。它们运行在一个<em class="lv">事件循环</em>中，该循环遍历调度的任务并逐个执行它们。当到达<code class="eh lw lx ly lz b">await</code>语句或当前任务完成时，发生任务切换。</p><p id="b470" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">任务执行本身与单线程系统中的情况相同。意思是，这不是并行的实现，它实际上更接近于多线程。在代码块依赖于外部动作的情况下，我们可以察觉到并发性。</p><p id="99e7" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这种错觉是可能的，因为块可以在等待时产生执行，这使得任何依赖于外部IO的东西，如网络或磁盘存储，都是一个很好的候选对象。当IO完成时，协程接收到一个中断，可以继续执行。与此同时，其他任务也在执行。</p><p id="e846" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">asyncio事件循环也可以用作任务调度程序。异步函数和阻塞函数都可以根据需要排队执行。</p><h2 id="5ee9" class="kv kw ik bd kx ky kz la lb lc ld le lf ki lg lh li km lj lk ll kq lm ln lo lp dt translated">任务</h2><p id="e46b" class="pw-post-body-paragraph jz ka ik kb b kc lq jl ke kf lr jo kh ki ls kk kl km lt ko kp kq lu ks kt ku hn dt translated">一个<code class="eh lw lx ly lz b">Task </code>表示为在事件循环中异步执行而设计的可调用代码块。它们单线程执行，但可以通过不同线程上的循环并行运行。</p><p id="298d" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">用<code class="eh lw lx ly lz b">async</code>关键字作为函数定义的前缀会把它变成一个异步协程。尽管任务本身在添加到循环中之前是不存在的。这在调用大多数循环方法时通常是隐式的，但是<code class="eh lw lx ly lz b">asyncio.ensure_future(your_coroutine)</code>是更直接的机制。</p><p id="6b4b" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">为了表示可以产生执行的操作或指令，我们使用<code class="eh lw lx ly lz b">await</code>关键字。尽管它只在协程块中可用，如果在其他地方使用会导致语法错误。</p><p id="0474" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">请注意，直到Python版才实现async关键字。所以当使用旧版本时，使用<code class="eh lw lx ly lz b">@asyncio.coroutine</code>装饰器和<code class="eh lw lx ly lz b">yield from</code>关键字。</p><h2 id="61e7" class="kv kw ik bd kx ky kz la lb lc ld le lf ki lg lh li km lj lk ll kq lm ln lo lp dt translated">行程安排</h2><p id="bc7f" class="pw-post-body-paragraph jz ka ik kb b kc lq jl ke kf lr jo kh ki ls kk kl km lt ko kp kq lu ks kt ku hn dt translated">为了执行一个任务，我们需要一个对运行它的事件循环的引用。使用<code class="eh lw lx ly lz b">loop = asyncio.get_event_loop()</code>给了我们执行线程中的当前循环。现在的问题是调用<code class="eh lw lx ly lz b">loop.run_until_complete(<em class="lv">your_coroutine</em>)</code>或<code class="eh lw lx ly lz b">loop.run_forever()</code>让它做一些工作。</p><p id="3793" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">让我们看一个简短的例子来说明几点。我强烈建议您打开一个解释器，然后跟着做:</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="6f6d" class="kv kw ik lz b fv mi mj l mk ml">import time<br/>import asyncio</span><span id="7be8" class="kv kw ik lz b fv mm mj l mk ml">async def do_some_work(x):<br/>    print("Waiting " + str(x))<br/>    await asyncio.sleep(x)</span><span id="22c0" class="kv kw ik lz b fv mm mj l mk ml">loop = asyncio.get_event_loop()<br/>loop.run_until_complete(do_some_work(5))</span></pre><p id="cd88" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这里我们将<code class="eh lw lx ly lz b">do_some_work()</code>定义为一个协程，它等待外部工作负载的结果。通过<code class="eh lw lx ly lz b">asyncio.sleep</code>模拟工作量。</p><p id="8bdb" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">运行代码可能会令人惊讶。你以为<code class="eh lw lx ly lz b">run_until_complete</code>会是一个<em class="lv">阻塞</em>的呼叫吗？请记住，我们正在使用来自当前 <strong class="kb il">线程</strong>的事件循环来执行任务。我们稍后将更详细地讨论替代方案。所以现在，重要的部分是理解当执行阻塞时，<code class="eh lw lx ly lz b">await</code>关键字仍然支持并发。</p><p id="9194" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">为了更好地了解情况，让我们稍微改变一下测试代码，看看如何批量执行任务:</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="17c0" class="kv kw ik lz b fv mi mj l mk ml">tasks = [asyncio.ensure_future(do_some_work(2)), <br/>         asyncio.ensure_future(do_some_work(5))]</span><span id="838c" class="kv kw ik lz b fv mm mj l mk ml">loop.run_until_complete(asyncio.gather(*tasks))</span></pre><p id="07e5" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">引入<code class="eh lw lx ly lz b">asyncio.gather()</code>函数可以实现结果聚合。它等待同一个线程中的几个任务完成，并将结果放在一个列表中。</p><p id="c5d9" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这里的主要观察是两个函数调用没有按顺序执行。它没有等待2秒，然后5秒，总共7秒。相反，它<em class="lv">开始</em>等待2s，然后移动到下一个项目<em class="lv">开始</em>等待5s，当较长的任务完成时返回，总共5s。如果有助于可视化，可以随意向基本函数添加更多的打印语句。</p><p id="6aba" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这意味着我们可以将带有<em class="lv">代码的长时间运行的任务放在一个执行批处理中，然后让Python并行运行它们，直到它们全部完成。如果计划得当，这将比按顺序运行更快。</em></p><p id="dd3f" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">可以把它看作是<code class="eh lw lx ly lz b">threading</code>包的一种替代，在这个包中，在旋转了一些<code class="eh lw lx ly lz b">Threads</code>之后，我们等待它们完成<code class="eh lw lx ly lz b">.join()</code>。主要区别在于，与为每个函数创建一个新线程相比，开销更少。</p><p id="17ca" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">当然，指出你的里程数可能因手头的任务而异总是好的。如果您正在做计算繁重的工作，几乎没有时间等待，那么您得到的唯一好处就是将代码分组到逻辑批中。</p><h2 id="ff7c" class="kv kw ik bd kx ky kz la lb lc ld le lf ki lg lh li km lj lk ll kq lm ln lo lp dt translated">在不同的线程中运行循环</h2><p id="cc1e" class="pw-post-body-paragraph jz ka ik kb b kc lq jl ke kf lr jo kh ki ls kk kl km lt ko kp kq lu ks kt ku hn dt translated">如果我们不是在当前线程中做所有的事情，而是产生一个单独的线程来为我们做这些事情，会怎么样呢？</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="f888" class="kv kw ik lz b fv mi mj l mk ml">from threading import Thread<br/>import asyncio</span><span id="b77b" class="kv kw ik lz b fv mm mj l mk ml">def start_loop(loop):<br/>    asyncio.set_event_loop(loop)<br/>    loop.run_forever()</span><span id="6669" class="kv kw ik lz b fv mm mj l mk ml">new_loop = asyncio.new_event_loop()<br/>t = Thread(target=start_loop, args=(new_loop,))<br/>t.start()</span></pre><p id="7ffe" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">注意，这次我们通过<code class="eh lw lx ly lz b">asyncio.new_event_loop()</code>创建了一个新的事件循环。想法是产生一个新的线程，给它传递新的循环，然后调用线程安全函数(稍后讨论)来调度工作。</p><p id="2bf8" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这种方法的优点是由另一个事件循环执行的工作不会阻塞当前线程中的执行。从而允许主线程管理工作，并启用新类别的执行机制。</p><h2 id="7fde" class="kv kw ik bd kx ky kz la lb lc ld le lf ki lg lh li km lj lk ll kq lm ln lo lp dt translated">队列工作在不同的线程中</h2><p id="6cad" class="pw-post-body-paragraph jz ka ik kb b kc lq jl ke kf lr jo kh ki ls kk kl km lt ko kp kq lu ks kt ku hn dt translated">使用前面代码块中的线程和事件循环，我们可以用<code class="eh lw lx ly lz b">call_soon()</code>、<code class="eh lw lx ly lz b">call_later()</code>或<code class="eh lw lx ly lz b">call_at()</code>方法轻松完成工作。它们能够在一个事件循环中运行常规的函数代码块(那些没有被定义为协程的代码块)。</p><p id="d9e4" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">然而，最好使用他们的<code class="eh lw lx ly lz b">_threadsafe</code>替代品。让我们看看这是什么样子:</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="fda0" class="kv kw ik lz b fv mi mj l mk ml">import time</span><span id="1d67" class="kv kw ik lz b fv mm mj l mk ml">def more_work(x):<br/>  print("More work %s" % x)<br/>  time.sleep(x)<br/>  print("Finished more work %s" % x)</span><span id="86cf" class="kv kw ik lz b fv mm mj l mk ml">new_loop.call_soon_threadsafe(more_work, 6)<br/>new_loop.call_soon_threadsafe(more_work, 3)</span></pre><p id="8273" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在我们正在谈话！执行这段代码不会阻塞主解释器，允许我们给它更多的工作。因为工作是按顺序执行的，所以我们现在实际上有了一个任务队列。</p><p id="da40" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们刚刚讨论了单线程代码的多线程执行，但是并发性不是我们从asyncio获得的一部分吗？当然是！工作线程上的那个循环仍然是异步的，所以让我们通过给它一个合适的协程来启用并行性。</p><p id="63f3" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这样做是使用<code class="eh lw lx ly lz b">asyncio.run_coroutine_threadsafe()</code>的问题，如下所示:</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="57b3" class="kv kw ik lz b fv mi mj l mk ml">new_loop.call_soon_threadsafe(more_work, 20)<br/>asyncio.run_coroutine_threadsafe(do_some_work(5), new_loop)<br/>asyncio.run_coroutine_threadsafe(do_some_work(10), new_loop)</span></pre><p id="3588" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这些指令说明了python是如何执行的。对<code class="eh lw lx ly lz b">more_work</code>的第一个调用阻塞20秒，而对<code class="eh lw lx ly lz b">do_some_work</code>的调用在<code class="eh lw lx ly lz b">more_work</code>完成后立即并行执行。</p></div><div class="ab cl mn mo hc mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hn ho hp hq hr"><h2 id="e095" class="kv kw ik bd kx ky kz la lb lc ld le lf ki lg lh li km lj lk ll kq lm ln lo lp dt translated">真实世界示例#1 —发送通知</h2><p id="fc1e" class="pw-post-body-paragraph jz ka ik kb b kc lq jl ke kf lr jo kh ki ls kk kl km lt ko kp kq lu ks kt ku hn dt translated">如今，一种常见的情况是由于任务或事件而发送通知。这通常很简单，但与电子邮件服务器对话以提交新邮件可能需要时间，制作电子邮件本身也是如此。</p><p id="4588" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在很多情况下，我们没有闲工夫等待任务完成。这样做对最终用户没有好处。一个主要的例子是密码重置请求，或者触发存储库构建并通过电子邮件发送结果的webhook事件。</p><p id="09fc" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">到目前为止，推荐的实践是在像<code class="eh lw lx ly lz b">rabbitmq</code>这样的消息队列服务器之上使用像<code class="eh lw lx ly lz b">celery</code>这样的任务队列系统来调度工作。我在这里告诉你，对于那些可以从你的主应用程序的另一个线程中轻松执行的小事情，只使用asyncio并不是一个坏主意。这种模式与我们到目前为止看到的代码示例非常相似:</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="bfac" class="kv kw ik lz b fv mi mj l mk ml">import asyncio<br/>import smtplib<br/>from threading import Thread</span><span id="ca03" class="kv kw ik lz b fv mm mj l mk ml">def send_notification(email):<br/>    """Generate and send the notification email"""</span><span id="b07f" class="kv kw ik lz b fv mm mj l mk ml">    # Do some work to get email body<br/>    message = ...<br/>    <br/>    # Connect to the server<br/>    server = smtplib.SMTP("smtp.gmail.com:587")<br/>    server.ehlo()<br/>    server.starttls()<br/>    server.login(username, password)</span><span id="31aa" class="kv kw ik lz b fv mm mj l mk ml">    # Send the email<br/>    server.sendmail(from_addr, email, message)</span><span id="0a54" class="kv kw ik lz b fv mm mj l mk ml">    server.quit()</span><span id="a219" class="kv kw ik lz b fv mm mj l mk ml">def start_email_worker(loop):<br/>    """Switch to new event loop and run forever"""<br/> <br/>    asyncio.set_event_loop(loop)<br/>    loop.run_forever()</span><span id="80fd" class="kv kw ik lz b fv mm mj l mk ml"># Create the new loop and worker thread<br/>worker_loop = asyncio.new_event_loop()<br/>worker = Thread(target=star_email_worker, args=(worker_loop,))</span><span id="253e" class="kv kw ik lz b fv mm mj l mk ml"># Start the thread<br/>worker.start()</span><span id="7510" class="kv kw ik lz b fv mm mj l mk ml"># Assume a Flask restful interface endpoint<br/>@app.route("/notify")<br/>def notify(email):<br/>    """Request notification email"""</span><span id="3ec4" class="kv kw ik lz b fv mm mj l mk ml">    worker_loop.call_soon_threadsafe(send_notification, email)</span></pre><p id="190e" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这里我们假设一个Flask web API，其端点安装在<code class="eh lw lx ly lz b">/notify</code>上，请求某种通知邮件。</p><p id="83f0" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">注意<code class="eh lw lx ly lz b">send_notification</code>不是协程，所以每封邮件都是阻塞调用。工作线程的事件循环将作为跟踪传出电子邮件的队列。</p><p id="646b" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">你想知道为什么SMTP调用是同步的吗？嗯，虽然这是一个很好的例子，说明了什么样的IO应该是一个合适的IO，但我目前还不知道异步SMTP库。如果你真的找到了一个，请随意用<code class="eh lw lx ly lz b">async def</code>、<code class="eh lw lx ly lz b">await</code>和<code class="eh lw lx ly lz b">run_coroutine_threadsafe</code>来代替。</p><h2 id="a4da" class="kv kw ik bd kx ky kz la lb lc ld le lf ki lg lh li km lj lk ll kq lm ln lo lp dt translated">真实世界示例#2 —并行Web请求</h2><p id="c13a" class="pw-post-body-paragraph jz ka ik kb b kc lq jl ke kf lr jo kh ki ls kk kl km lt ko kp kq lu ks kt ku hn dt translated">下面是一个批处理并发运行到几个服务器的HTTP请求的例子，在处理之前等待响应。我希望它对那些做大量搜集工作的人有用，同时也是对<code class="eh lw lx ly lz b"><a class="ae ih" href="http://aiohttp.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank">aiohttp</a></code>模块的一个快速介绍。</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="4fee" class="kv kw ik lz b fv mi mj l mk ml">import asyncio<br/>import aiohttp</span><span id="f58a" class="kv kw ik lz b fv mm mj l mk ml">async def fetch(url):<br/>    """Perform an HTTP GET to the URL and print the response"""</span><span id="b626" class="kv kw ik lz b fv mm mj l mk ml">    response = await aiohttp.request('GET', url)<br/>    return await response.text()</span><span id="5187" class="kv kw ik lz b fv mm mj l mk ml"># Get a reference to the event loop<br/>loop = asyncio.get_event_loop()</span><span id="cfcc" class="kv kw ik lz b fv mm mj l mk ml"># Create the batch of requests we wish to execute<br/>requests = [asyncio.ensure_future(fetch("https://github.com")),<br/>            asyncio.ensure_future(fetch("https://google.com"))]</span><span id="3de8" class="kv kw ik lz b fv mm mj l mk ml"># Run the batch<br/>responses = loop.run_until_complete(asyncio.gather(*requests))</span><span id="f891" class="kv kw ik lz b fv mm mj l mk ml"># Examine responses<br/>for resp in responses:<br/>  print(resp)</span></pre><p id="a925" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">非常简单，就是将工作分组到一个任务列表中，并使用<code class="eh lw lx ly lz b">run_until_complete</code>来获得响应。这可以很容易地更改为使用一个单独的线程来发出请求，通过前面描述的线程安全方法添加所有的URL会很简单。</p><p id="d9c6" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我想指出的是，<code class="eh lw lx ly lz b"><a class="ae ih" href="http://docs.python-requests.org/en/v0.10.6/user/advanced/#asynchronous-requests" rel="noopener ugc nofollow" target="_blank">requests</a></code>库通过<code class="eh lw lx ly lz b">gevent</code>提供了异步支持，但是我还没有弄清楚这是如何绑定到<code class="eh lw lx ly lz b">asyncio</code>的。相比之下，我不知道流行的抓取框架<code class="eh lw lx ly lz b">scrapy</code>的<code class="eh lw lx ly lz b">asyncio</code>计划，但我假设他们正在努力。</p><h2 id="975a" class="kv kw ik bd kx ky kz la lb lc ld le lf ki lg lh li km lj lk ll kq lm ln lo lp dt translated">停止循环</h2><p id="026c" class="pw-post-body-paragraph jz ka ik kb b kc lq jl ke kf lr jo kh ki ls kk kl km lt ko kp kq lu ks kt ku hn dt translated">如果在任何时候你发现自己想要停止一个无限的事件循环，或者想要取消尚未完成的任务，我倾向于使用<code class="eh lw lx ly lz b">KeyboardInterrupt</code>异常子句来触发取消，如下所示。虽然同样可以通过使用<code class="eh lw lx ly lz b">signal</code>模块并为<code class="eh lw lx ly lz b">signal.SIGINT</code>注册一个处理程序来完成。</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="77a1" class="kv kw ik lz b fv mi mj l mk ml">try:<br/>    loop.run_forever()</span><span id="ed01" class="kv kw ik lz b fv mm mj l mk ml">except KeyboardInterrupt:<br/>    # Canceling pending tasks and stopping the loop<br/>    asyncio.gather(*asyncio.Task.all_tasks()).cancel()</span><span id="fc7f" class="kv kw ik lz b fv mm mj l mk ml">    # Stopping the loop<br/>    loop.stop()</span><span id="e550" class="kv kw ik lz b fv mm mj l mk ml">    # Received Ctrl+C<br/>    loop.close()</span></pre><p id="dfed" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这一次，我们将介绍使用<code class="eh lw lx ly lz b">Task.all_tasks()</code>来生成所有当前正在运行或计划的任务的列表。当与<code class="eh lw lx ly lz b">gather()</code>结合时，我们可以向每个人发送<code class="eh lw lx ly lz b">cancel()</code>命令，并让他们停止执行或从队列中删除。</p><p id="39a1" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">请注意，由于Windows中信号不足，如果循环为空，键盘中断将永远不会被触发。这种情况的一种变通方法是将休眠几秒钟的任务排队。这保证了如果任务休眠时中断到达，循环会在唤醒时注意到。</p></div><div class="ab cl mn mo hc mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hn ho hp hq hr"><p id="f592" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">异步编程可能非常令人困惑。我必须承认，我开始时有一些基本的假设，结果证明是错误的。直到我深入其中，我才意识到到底发生了什么。</p><p id="805a" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我希望这能很好地介绍asyncio事件循环和任务，以及它们可能的用途。我知道还有很多其他的文章，但是我想做一些事情，把事情和一些真实世界的例子联系起来。如果您有任何问题或评论，请在下面留言，我将尽我所能提供帮助。</p></div><div class="ab cl mn mo hc mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hn ho hp hq hr"><figure class="ma mb mc md fq hw fe ff paragraph-image"><a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fpublish.twitter.com%2F&amp;ref_src=twsrc%5Etfw&amp;region=follow_link&amp;screen_name=tryexceptpass&amp;tw_p=followbutton"><div class="fe ff mu"><img src="../Images/4e728960fa1d1a8a3847021955abc3a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:362/format:webp/1*_04PhhMqHB3qXQnOQNP5ag.png"/></div></a></figure><p id="4316" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如果你喜欢这篇文章并想跟上我的工作，请推荐它，访问<a class="ae ih" href="http://tryexceptpass.org" rel="noopener ugc nofollow" target="_blank">tryexecptpass.org</a>获取更多话题，并在推特上<a class="ae ih" href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fpublish.twitter.com%2F&amp;ref_src=twsrc%5Etfw&amp;region=follow_link&amp;screen_name=tryexceptpass&amp;tw_p=followbutton" rel="noopener ugc nofollow" target="_blank">关注我。</a></p><div class="ma mb mc md fq ab cb"><figure class="mv hw mw mx my mz na paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mv hw mw mx my mz na paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mv hw mw mx my mz na paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="nb nc nd"><p id="f922" class="jz ka lv kb b kc kd jl ke kf kg jo kh ne kj kk kl nf kn ko kp ng kr ks kt ku hn dt translated"><a class="ae ih" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客午间</a>是黑客们下午的开始。我们是<a class="ae ih" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家族的一员。我们现在<a class="ae ih" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受提交</a>并很高兴<a class="ae ih" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jz ka lv kb b kc kd jl ke kf kg jo kh ne kj kk kl nf kn ko kp ng kr ks kt ku hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ih" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ih" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ma mb mc md fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nh"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>