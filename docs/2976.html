<html>
<head>
<title>Translating Unix Philosophy into modern environments</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Unix理念转化为现代环境</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/translating-unix-philosophy-into-modern-environments-80d7949834f3?source=collection_archive---------8-----------------------#2017-03-03">https://medium.com/hackernoon/translating-unix-philosophy-into-modern-environments-80d7949834f3?source=collection_archive---------8-----------------------#2017-03-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/91e3e14e7ab920c5fdf732433e24a49a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XGo8ipRVY9A3yg7LHKRLQg.png"/></div></div></figure><p id="5423" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">简单来说，<em class="ka">Unix风格</em>是一套工具，将小单元组合成复杂的操作。从这个意义上说，它很像函数式编程，但是生活在应用中而不是理论中。这个时代最值得注意的两个操作是操作符的配置和连接。</p><p id="a1b8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">举个例子，一个程序寻找有制表符而不是空格的源文件</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="375d" class="kk kl hu kg b fv km kn l ko kp">find . -name test.py -print -exec cat {} \; | egrep './|\t'</span></pre><p id="8c68" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种构造基本上是多余的，但关键是开发人员有很多选择，既可以配置现有的操作符，也可以根据需要加入新的操作符。在这里的一行中，有一个目录搜索、一个参数替换、函数连接和通过正则表达式的搜索。这种代码通常需要大约10行程序。这听起来可能没那么糟糕，但是如果考虑到一个Unix用户一天可能会编写数千个这样的短程序，那么使用shell会变得更加愉快。</p><p id="915a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">另一方面，函数式风格</em>在可组合性方面更加丰富，但是完全缺少配置部分(所有命名的操作符只允许一种狭义的含义)。现代环境通常可以访问Unix工具集，但是选择不使用它。这是为什么呢？</p><p id="d637" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在应用程序中不使用Unix的第一个原因是安全性。对终端的控制通常是如此强大，以至于任何级别调用<em class="ka"> exec </em>调用的应用都被认为是低级趣味。Unix是为系统管理员设计的，当然不是web应用。</p><p id="4464" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第二，Unix的学习曲线很高。所有的命令和选项都是晦涩难懂的，而且通常是反直觉的。如果运营商之间有一个共同点，那就是对<em class="ka">阅读手册页</em>的简单回应。</p><p id="642f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第三也是最后一点，Unix不太容易组合。Unix只允许文本到文本的合成。由于这种有意的限制，复杂的数据结构必须简化为JSON等。或者陷入应用程序逻辑的泥潭。应用程序变成整体是有原因的，通常不是因为“性能原因”。</p><p id="309b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那么，前进的道路是什么？</p><p id="62ff" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，让我们坚持以前的标准。让我们打造一个更好的<em class="ka"> sh </em>。从今天的角度来看，那会是什么样子呢？</p><p id="1bbd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果Unix风格不是前进的方向，那么什么才是呢？如果我们着眼于学术理论，那么我们可能想要尝试泛函。Haskell或者ML怎么样？</p><p id="05b4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为我对ML分支稍微熟悉一些，所以让我们试试。OCaml包含一个REPL，所以如果您想继续学习，可以从在shell中安装并运行<em class="ka"> ocaml </em>开始。</p><p id="c606" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">数据类型？检查。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="29e1" class="kk kl hu kg b fv km kn l ko kp"># type 'a btree = BTree of 'a btree * 'a * 'a btree | Empty;;</span><span id="5212" class="kk kl hu kg b fv kq kn l ko kp">type 'a btree = BTree of 'a btree * 'a * 'a btree | Empty</span><span id="657d" class="kk kl hu kg b fv kq kn l ko kp"># BTree(Empty,1,Empty);;</span><span id="75b3" class="kk kl hu kg b fv kq kn l ko kp">- : int btree = BTree (Empty, 1, Empty)</span></pre><p id="a64c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">管道操作员？检查。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="281f" class="kk kl hu kg b fv km kn l ko kp"># let ( |&gt; ) x f = f x;;</span><span id="dfcf" class="kk kl hu kg b fv kq kn l ko kp">val ( |&gt; ) : 'a -&gt; ('a -&gt; 'b) -&gt; 'b = &lt;fun&gt;</span><span id="7866" class="kk kl hu kg b fv kq kn l ko kp"># let f x = x+1;;</span><span id="facb" class="kk kl hu kg b fv kq kn l ko kp">val f : int -&gt; int = &lt;fun&gt;</span><span id="9db3" class="kk kl hu kg b fv kq kn l ko kp"># let g x = x+1;;</span><span id="9341" class="kk kl hu kg b fv kq kn l ko kp">val g : int -&gt; int = &lt;fun&gt;</span><span id="ee42" class="kk kl hu kg b fv kq kn l ko kp"># f 1 |&gt; g;;</span><span id="4593" class="kk kl hu kg b fv kq kn l ko kp">- : int = 3</span></pre><p id="ecb2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">性能和安全？对比检查检查。</p><p id="bf74" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以我们现在缺少两样东西，可配置性和内置。</p><p id="c506" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于内置，Haskell有一个名为Turtle的库，它很好地移植了尽可能多的标准shell操作符。<em class="ka">我不知道OCaml有类似的项目。</em>结果略显尴尬，可能与旧款shells相比并无改进。</p><p id="a65f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于可配置性，没有一个包含在参数化操作符方面做得很好。Haskell不允许我所期望的shell的简洁语法。尽管OCaml支持函数的可选参数，但前景并没有好到哪里去。如果我们要充分利用数据类型的优势，那么我们就需要像特别多态性这样的东西。虽然这个特性通常被认为是有帮助的，但是在函数社区中并没有得到广泛的支持，因为它与类型推断的实现方式不兼容。</p><p id="115b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">综上所述，我乐观地认为Unix哲学将继续存在，并将其风格转化为现代语言和shell使用。然而，暂时不要期望抛弃过去40年中幸存下来的所有代码。好主意很难放弃。</p><div class="kb kc kd ke fq ab cb"><figure class="ks iv kt ku kv kw kx paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="ks iv kt ku kv kw kx paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="ks iv kt ku kv kw kx paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ky kz la"><p id="f922" class="jc jd ka je b jf jg jh ji jj jk jl jm lb jo jp jq lc js jt ju ld jw jx jy jz hn dt translated"><a class="ae kr" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kr" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kr" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae kr" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd ka je b jf jg jh ji jj jk jl jm lb jo jp jq lc js jt ju ld jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kr" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kr" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff le"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>