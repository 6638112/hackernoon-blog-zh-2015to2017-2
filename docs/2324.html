<html>
<head>
<title>NumPy Tutorial: Array Computing in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NumPy教程:Python中的数组计算</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/numpy-tutorial-array-computing-in-python-fb7321f417ba?source=collection_archive---------12-----------------------#2017-01-19">https://medium.com/hackernoon/numpy-tutorial-array-computing-in-python-fb7321f417ba?source=collection_archive---------12-----------------------#2017-01-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="9dc1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">本文原载于</em><a class="ae jq" href="https://www.datacamp.com/community/tutorials/python-numpy-tutorial" rel="noopener ugc nofollow" target="_blank"><em class="jp">https://www . data camp . com/community/tutorials/python-numpy-tutorial</em></a></p><p id="db74" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">NumPy是，就像SciPy，Scikit-Learn，Pandas等。这是你在学习<a class="ae jq" href="https://hackernoon.com/tagged/data-science" rel="noopener ugc nofollow" target="_blank">数据科学</a>时不可错过的一个包，主要是因为这个库为你提供了一个数组数据结构，它比Python列表有一些好处，比如:更紧凑，读写项目更快，更方便，更高效。</p><p id="a872" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些好处已经在我们的<a class="ae jq" href="https://www.datacamp.com/community/tutorials/18-most-common-python-list-questions-learn-python" rel="noopener ugc nofollow" target="_blank"> 18最常见的Python列表问题</a>博文中描述过了，这篇博文教你如何使用Python列表，如何在使用它们时解决一些棘手的问题，以及何时选择其他数据结构，比如NumPy数组。</p><p id="c63a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">今天的帖子将集中讨论最后一点。本NumPy教程不仅将向您展示NumPy数组实际上是什么以及如何安装Python，而且您还将学习如何制作数组(即使您的数据来自文件！)，广播是如何工作的，你如何寻求帮助，如何操纵你的阵列以及如何可视化它们。</p><p id="9519" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您想了解更多关于NumPy数组和数据科学之旅中需要的其他数据结构的信息？考虑一下DataCamp的<a class="ae jq" href="https://www.datacamp.com/courses/intro-to-python-for-data-science" rel="noopener ugc nofollow" target="_blank">数据科学Python入门</a>和<a class="ae jq" href="https://www.datacamp.com/courses/intermediate-python-for-data-science" rel="noopener ugc nofollow" target="_blank">数据科学中级Python</a>课程。</p><h2 id="c280" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">什么是NumPy数组？</h2><p id="4b2a" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">您已经在介绍中读到NumPy数组有点像Python列表，但同时又有很大的不同。对于那些刚接触这个话题的人，让我们来澄清一下它到底是什么，它有什么好处。</p><p id="8543" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">顾名思义，NumPy数组是<code class="eh kr ks kt ku b">numpy</code>库的中心数据结构。库的名字其实是“数值Python”或者“数值Python”的简称。</p><p id="f603" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这已经让你知道你在处理什么了，对吗？</p><p id="269e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">换句话说，NumPy是一个Python库，是Python中科学计算的核心库。它包含一组工具和技术，可以用来在计算机上解决科学和工程中的数学模型问题。其中一个工具是高性能多维数组对象，这是一个强大的数据结构，用于高效计算数组和矩阵。为了处理这些数组，需要对这些矩阵和数组进行大量的高级数学运算。</p><p id="5903" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么，什么是数组呢？</p><p id="26cb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当你看一对数组的打印时，你可以看到它是包含相同类型值的网格。该数组以结构化的方式保存和表示任何常规数据。</p><p id="cb3c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，你应该知道，在结构层次上，数组基本上就是指针。它是内存地址、数据类型、形状和步幅的组合:</p><ul class=""><li id="53e1" class="kv kw hu it b iu iv iy iz jc kx jg ky jk kz jo la lb lc ld dt translated"><code class="eh kr ks kt ku b">data</code>指针指示数组中第一个字节的内存地址，</li><li id="f3fd" class="kv kw hu it b iu le iy lf jc lg jg lh jk li jo la lb lc ld dt translated">数据类型或<code class="eh kr ks kt ku b">dtype</code>指针描述了数组中包含的元素种类，</li><li id="6e5e" class="kv kw hu it b iu le iy lf jc lg jg lh jk li jo la lb lc ld dt translated"><code class="eh kr ks kt ku b">shape</code>表示数组的形状，并且</li><li id="77b7" class="kv kw hu it b iu le iy lf jc lg jg lh jk li jo la lb lc ld dt translated"><code class="eh kr ks kt ku b">strides</code>是为了进入下一个元素，应该在内存中跳过的字节数。如果你的步幅是(10，1)，你需要前进一个字节到达下一列，前进10个字节定位下一行。</li></ul><p id="0974" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者换句话说，数组包含关于原始数据、如何定位元素以及如何解释元素的信息。</p><p id="7888" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">理论说够了。让我们自己来看看这个:</p><p id="ad79" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以通过探索<code class="eh kr ks kt ku b">numpy</code>数组属性来轻松测试这一点。</p><figure class="lk ll lm ln fq lo fe ff paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="fe ff lj"><img src="../Images/45dd037492c4cb395f32e15069cf99ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*A5SA0vIQeFid6AK1.png"/></div></div></figure><p id="5928" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在二维数组中，有行和列。行表示为“轴0”，而列表示为“轴1”。轴的数量随着维度的数量而相应地增加:在三维数组中，您在前面的代码块中已经看到了一个例子，您将有一个额外的“轴2”。请注意，这些轴只对至少有2维的数组有效，因为1维数组没有任何意义；</p><p id="5208" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些轴将在以后操作NumPy数组的形状时派上用场。</p><h2 id="e8ea" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">如何安装NumPy</h2><p id="4da4" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">在您开始亲自尝试这些NumPy数组之前，您首先必须确保您已经在本地安装了它(假设您正在您的pc上工作)。如果您已经有了Python库，请跳过这一部分:)</p><p id="3fcf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您仍然需要设置您的环境，您必须知道在您的pc上安装NumPy有两种主要方式:借助Python wheels或Anaconda Python发行版。</p><p id="d903" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先确保你已经安装了Python。如果你还需要这样做，你可以去<a class="ae jq" href="https://www.python.org/downloads/" rel="noopener ugc nofollow" target="_blank">这里</a>:)</p><p id="c803" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您正在使用Windows，请确保已将Python添加到PATH环境变量中。然后，不要忘记安装一个包管理器，比如<code class="eh kr ks kt ku b">pip</code>，它将确保您能够使用Python的开源库。</p><p id="125a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，Python 3的最新版本附带了pip，所以请仔细检查您是否有pip，如果有，请在安装NumPy之前升级它:</p><pre class="lk ll lm ln fq lv ku lw lx aw ly dt"><span id="d0fc" class="jr js hu ku b fv lz ma l mb mc">pip install pip --upgrade pip --version</span></pre><p id="277d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，你可以到<a class="ae jq" href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#numpy" rel="noopener ugc nofollow" target="_blank">这里</a>或者<a class="ae jq" href="https://pypi.python.org/pypi/numpy" rel="noopener ugc nofollow" target="_blank">这里</a>去拿你的NumPy轮。下载后，通过终端导航到pc上存储它的文件夹并安装它:</p><pre class="lk ll lm ln fq lv ku lw lx aw ly dt"><span id="358c" class="jr js hu ku b fv lz ma l mb mc">install "numpy-1.9.2rc1+mkl-cp34-none-win_amd64.whl" <br/>import numpy <br/>numpy.__version__</span></pre><p id="7016" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后两行允许您验证是否已经安装了NumPy并检查软件包的版本。</p><p id="9b9a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">完成这些步骤后，您就可以开始使用NumPy了！</p><p id="e3c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要获得NumPy，您还可以下载Anaconda Python发行版。这很简单，可以让你快速上手！如果您还没有下载，请点击<a class="ae jq" href="https://www.continuum.io/downloads" rel="noopener ugc nofollow" target="_blank">这里</a>下载。按照说明进行安装，您就可以开始了！</p><p id="f246" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你想知道为什么这实际上可能更容易吗？</p><p id="3ca2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">获得这个Python发行版的好处是，您不需要太担心单独安装NumPy或您将用于数据分析的任何主要包，如pandas、scikit-learn等。</p><p id="450f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为，特别是如果你对Python、编程或终端非常陌生，Anaconda已经包含了数据科学领域最流行的 Python、R和Scala包中的<a class="ae jq" href="https://docs.continuum.io/anaconda/pkg-docs" rel="noopener ugc nofollow" target="_blank"> 100个，这真的会让你松一口气。但是对于更有经验的数据科学家来说，如果您想快速开始处理数据科学问题，Anaconda是一个不错的选择。</a></p><p id="8427" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">更重要的是，Anaconda还包含了Jupyter、Spyder等几个开源开发环境。如果您想在本教程结束后开始使用Jupyter笔记本，请转到<a class="ae jq" href="https://www.datacamp.com/community/tutorials/tutorial-jupyter-notebook" rel="noopener ugc nofollow" target="_blank">本页</a>。</p><p id="55eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">简而言之，考虑下载Anaconda，开始使用<code class="eh kr ks kt ku b">numpy</code>和其他与数据科学相关的包！</p><h1 id="7f5c" class="md js hu bd jt me mf mg jx mh mi mj kb mk ml mm ke mn mo mp kh mq mr ms kk mt dt translated">如何创建NumPy数组</h1><p id="97bb" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">现在，您已经设置好了环境，是时候开始真正的工作了。不可否认，您已经在上面的DataCamp Light块中尝试了一些使用数组的东西。然而，你还没有真正的实践过，因为你首先需要在你自己的电脑上安装NumPy。既然您已经完成了这些，那么是时候看看您需要做些什么来自己运行上面的代码块了。</p><p id="fa7b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面包括了一些练习，这样你就可以在自己开始之前练习如何做了！</p><p id="7b79" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要创建一个<code class="eh kr ks kt ku b">numpy</code>数组，你可以使用<code class="eh kr ks kt ku b">np.array()</code>函数。您所需要做的就是向它传递一个列表，也可以指定数据的数据类型。如果你想知道更多关于你可以选择的可能的数据类型，去这里<a class="ae jq" href="https://docs.scipy.org/doc/numpy/user/basics.types.html" rel="noopener ugc nofollow" target="_blank">或者考虑看一下DataCamp的</a><a class="ae jq" href="https://www.datacamp.com/community/blog/python-numpy-cheat-sheet" rel="noopener ugc nofollow" target="_blank"> NumPy备忘单</a>。</p><p id="fa33" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你是一个新用户，没有必要去记忆这些NumPy数据类型；但是您必须知道并关心您正在处理的数据。当您需要更好地控制数据在内存和磁盘上的存储方式时，可以使用这些数据类型。尤其是在处理大量数据的情况下，知道如何控制存储类型是很好的。</p><p id="70ca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不要忘记，为了使用<code class="eh kr ks kt ku b">np.array()</code>函数，您需要确保<code class="eh kr ks kt ku b">numpy</code>库存在于您的环境中。NumPy库遵循一个导入惯例:当您导入这个库时，您必须确保您将它作为<code class="eh kr ks kt ku b">np</code>导入。通过这样做，您将确保其他python爱好者更容易理解您的代码。</p><p id="1f67" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你想知道更多关于如何列清单的信息，请点击<a class="ae jq" href="https://www.datacamp.com/community/tutorials/18-most-common-python-list-questions-learn-python" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="0174" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，有时您不知道要将什么数据放入数组，或者要将数据从另一个源导入到<code class="eh kr ks kt ku b">numpy</code>数组中。在这些情况下，您将分别利用初始占位符或函数将数据从文本加载到数组中。</p><p id="317b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面几节将向您展示如何做到这一点。</p><h2 id="fc87" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">创建空数组</h2><p id="7627" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">当人们说他们正在创建“空”数组时，他们通常的意思是他们想利用初始占位符，您可以在以后填充这些占位符。可以用1或0初始化数组，但也可以用均匀分布的值、常量或随机值填充数组。</p><p id="a16c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，你也可以创建一个完全空的数组。</p><p id="cf94" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">幸运的是，有相当多的函数可以组成数组:</p><ul class=""><li id="f8de" class="kv kw hu it b iu iv iy iz jc kx jg ky jk kz jo la lb lc ld dt translated">对于一些，例如<code class="eh kr ks kt ku b">np.ones()</code>、<code class="eh kr ks kt ku b">np.random.random()</code>、<code class="eh kr ks kt ku b">np.empty()</code>、<code class="eh kr ks kt ku b">np.full()</code>或<code class="eh kr ks kt ku b">np.zeros()</code>，为了生成带有1或0的数组，你唯一需要做的就是传递你想要生成的数组的形状。作为<code class="eh kr ks kt ku b">np.ones()</code>和<code class="eh kr ks kt ku b">np.zeros()</code>的选项，您还可以指定数据类型。在使用<code class="eh kr ks kt ku b">np.full()</code>的情况下，您还必须指定想要插入到数组中的常量值。</li><li id="8ca5" class="kv kw hu it b iu le iy lf jc lg jg lh jk li jo la lb lc ld dt translated">使用<code class="eh kr ks kt ku b">np.linspace()</code>和<code class="eh kr ks kt ku b">np.arange()</code>你可以创建均匀分布的数组。这两个函数的区别在于，上面代码块中传递的三个函数的最后一个值指定了<code class="eh kr ks kt ku b">np.linspace()</code>的步长值或<code class="eh kr ks kt ku b">np.arange()</code>的样本数。例如，第一种情况是，您想要一个介于0和2之间的9个值的数组。对于后者，您指定希望数组从10开始，每5步为您正在创建的数组生成值。</li></ul><p id="7baf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">记住NumPy还允许你用<code class="eh kr ks kt ku b">np.eye()</code>和<code class="eh kr ks kt ku b">np.identity()</code>创建一个单位数组或矩阵。单位矩阵是一个方阵，其主对角线上的所有元素都是1，其他元素都是0。当你用一个单位矩阵乘一个矩阵时，给定的矩阵保持不变。</p><p id="cff3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">换句话说，如果您将一个矩阵乘以一个单位矩阵，那么根据矩阵乘法的标准约定，所得乘积将再次是同一个矩阵。</p><p id="7235" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尽管本教程的重点不是演示单位矩阵是如何工作的，但可以说，当您开始进行矩阵计算时，单位矩阵是有用的:它们可以简化数学方程，从而使您的计算更加高效和健壮。</p><p id="cba6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">借助初始占位符或一些示例数据创建数组是开始使用<code class="eh kr ks kt ku b">numpy</code>的好方法。但是当您想开始数据分析时，您需要从文本文件中加载数据。</p><h2 id="e630" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">将数据从文件加载到数组</h2><p id="3fb6" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">以你到目前为止所看到的，你真的不能做太多。利用一些特定的函数从文件中加载数据，例如<code class="eh kr ks kt ku b">loadtxt()</code>或<code class="eh kr ks kt ku b">genfromtxt()</code>。</p><p id="bed7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设您有以下包含数据的文本文件:</p><pre class="lk ll lm ln fq lv ku lw lx aw ly dt"><span id="1126" class="jr js hu ku b fv lz ma l mb mc"># This is your data in the text file <br/># Value1 Value2 Value3 <br/># 0.2536 0.1008 0.3857 <br/># 0.4839 0.4536 0.3561 <br/># 0.1292 0.6875 0.5929 <br/># 0.1781 0.3049 0.8928 <br/># 0.6253 0.3486 0.8791 <br/># Import your data </span><span id="4184" class="jr js hu ku b fv mu ma l mb mc">x, y, z = np.loadtxt('data.txt', skiprows=1, unpack=True)</span></pre><p id="8729" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在上面的代码中，您使用<code class="eh kr ks kt ku b"><a class="ae jq" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.loadtxt.html#numpy.loadtxt" rel="noopener ugc nofollow" target="_blank">loadtxt()</a></code>在您的环境中加载数据。您会看到两个函数的第一个参数是文本文件<code class="eh kr ks kt ku b">data.txt</code>。接下来，每种方法都有一些特定的参数:在第一条语句中，您跳过第一行，用<code class="eh kr ks kt ku b">unpack=TRUE</code>将列作为单独的数组返回。这意味着列<code class="eh kr ks kt ku b">Value1</code>中的值将被放入<code class="eh kr ks kt ku b">x</code>，依此类推。</p><p id="17da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，如果您有逗号分隔的数据，或者如果您想要指定数据类型，也可以将参数<code class="eh kr ks kt ku b">delimiter</code>和<code class="eh kr ks kt ku b">dtype</code>添加到<code class="eh kr ks kt ku b">loadtxt()</code>参数中。</p><p id="5031" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这很简单明了，对吗？</p><p id="46a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们看看您的第二个数据文件:</p><pre class="lk ll lm ln fq lv ku lw lx aw ly dt"><span id="32a7" class="jr js hu ku b fv lz ma l mb mc"># Your data in the text file <br/># Value1 Value2 Value3 <br/># 0.4839 0.4536 0.3561 <br/># 0.1292 0.6875 MISSING <br/># 0.1781 0.3049 0.8928 <br/># MISSING 0.5801 0.2038 <br/># 0.5993 0.4357 0.7410 </span><span id="8946" class="jr js hu ku b fv mu ma l mb mc">my_array2 = np.genfromtxt('data2.txt', skip_header=1, filling_values=-999)</span></pre><p id="a1fe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你看这里，你求助于<code class="eh kr ks kt ku b">genfromtxt()</code>来加载数据。在这种情况下，您必须处理一些由<code class="eh kr ks kt ku b">'MISSING'</code>字符串指示的缺失值。因为<code class="eh kr ks kt ku b">genfromtxt()</code>函数将数字列中的字符串转换为<code class="eh kr ks kt ku b">nan</code>，所以您可以通过指定<code class="eh kr ks kt ku b">filling_values</code>参数将这些值转换为其他值。在这种情况下，您选择将这些缺失值的值设置为-999。</p><p id="e40e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您碰巧有没有被<code class="eh kr ks kt ku b">genfromtxt()</code>转换成<code class="eh kr ks kt ku b">nan</code>的值，那么总有一个<code class="eh kr ks kt ku b">missing_values</code>参数允许您指定数据中丢失的值到底是什么。</p><p id="1bd7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但这还不是全部。</p><p id="d47c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">提示</strong>:查看<a class="ae jq" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.genfromtxt.html#numpy.genfromtxt" rel="noopener ugc nofollow" target="_blank">这一页</a>，看看你还可以添加哪些片段来成功导入你的数据。</p><p id="66e5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您现在可能想知道这两个函数之间的真正区别是什么。</p><p id="ae77" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些例子暗示了这一点，但是，总的来说，<code class="eh kr ks kt ku b">genfromtxt()</code>给了你更多的灵活性；比<code class="eh kr ks kt ku b">loadtxt()</code>更健壮。</p><p id="c0b5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们把这个区别变得更实际一点:后者，<code class="eh kr ks kt ku b">loadtxt()</code>，只有当文本文件中的每一行都有相同数量的值时才起作用；因此，当您想轻松处理丢失的值时，您通常会发现使用<code class="eh kr ks kt ku b">genfromtxt()</code>更容易。</p><p id="f53d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但这绝对不是唯一的原因。</p><p id="27d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">简单看一下<code class="eh kr ks kt ku b">genfromtxt()</code>必须提供的参数数量，您会发现在您的导入中确实有更多的东西可以指定，比如要读取的最大行数或者从变量中自动去除空格的选项。</p><h2 id="7018" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">将数组保存到文件</h2><p id="93c7" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">一旦您完成了所有需要对阵列进行的操作，您还可以将它们保存到文件中。如果你想将数组保存到一个文本文件中，你可以使用<code class="eh kr ks kt ku b">savetxt()</code>函数来完成:</p><pre class="lk ll lm ln fq lv ku lw lx aw ly dt"><span id="9e5a" class="jr js hu ku b fv lz ma l mb mc">import numpy as np <br/>x = np.arange(0.0,5.0,1.0) <br/>np.savetxt('test.out', x, delimiter=',')</span></pre><p id="8610" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">记住<code class="eh kr ks kt ku b">np.arange()</code>创建一个等距值的NumPy数组。传递给这个函数的第三个值是步长值。</p><p id="121b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然，还有其他方法可以将NumPy数组保存到文本文件中。如果您想将数据保存到二进制文件或档案中，请查看下表中的函数:</p><p id="a87e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kr ks kt ku b">save()</code>将数组保存到NumPy中的二进制文件。npy格式<code class="eh kr ks kt ku b">savez()</code>将几个数组保存成一个未压缩的。npz存档<code class="eh kr ks kt ku b">savez_compressed()</code>将几个数组保存成一个压缩的。npz档案</p><p id="bd26" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有关如何使用上述功能保存数据的更多信息或示例，请点击<a class="ae jq" href="https://docs.scipy.org/doc/numpy/reference/routines.io.html" rel="noopener ugc nofollow" target="_blank">此处</a>或使用NumPy提供的帮助功能，立即了解更多信息！</p><p id="ec68" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你不确定这些数字帮助功能是什么吗？</p><p id="edc2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">别担心！在接下来的一节中，您将了解更多关于它们的内容！</p><h2 id="64ab" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">检查您的阵列</h2><p id="8813" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">除了上面提到的数组属性，即<code class="eh kr ks kt ku b">data</code>、<code class="eh kr ks kt ku b">shape</code>、<code class="eh kr ks kt ku b">dtype</code>和<code class="eh kr ks kt ku b">strides</code>，您还可以使用更多的属性来更容易地了解您的数组。</p><p id="3126" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些几乎是数组可以拥有的所有属性。</p><p id="c485" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果在这一点上你没有感觉到它们都对你有用，也不要担心；这很正常，因为正如您在上一节中读到的，当您处理大型数据集时，您只会担心内存问题。</p><p id="c1e5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在您已经创建了您的数组，无论是通过自己用<code class="eh kr ks kt ku b">np.array()</code>或一个初始占位符函数创建，还是通过<code class="eh kr ks kt ku b">loadtxt()</code>或<code class="eh kr ks kt ku b">genfromtxt()</code>函数加载您的数据，现在是时候更仔细地研究真正定义NumPy库的第二个关键元素:科学计算。</p><h2 id="8380" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">广播是如何工作的？</h2><p id="9ab1" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">在深入研究科学计算之前，最好先了解一下广播到底是什么:它是一种机制，允许NumPy在执行算术运算时处理不同形状的数组。</p><p id="bfe3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在更实际的环境中，你经常会有一个大一点的数组和一个小一点的数组。理想情况下，您希望多次使用较小的数组来执行运算(如求和、乘法等)。)在更大的数组上。</p><p id="17a2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为此，您可以使用广播机制。</p><p id="2169" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，如果你想使用它，有一些规则。在你感叹之前，你会发现这些“规则”非常简单明了！</p><ul class=""><li id="06dd" class="kv kw hu it b iu iv iy iz jc kx jg ky jk kz jo la lb lc ld dt translated">首先，为了确保广播成功，阵列的尺寸需要兼容。当两个维度相等时，它们是相容的。</li><li id="39cb" class="kv kw hu it b iu le iy lf jc lg jg lh jk li jo la lb lc ld dt translated">当其中一个维度为1时，两个维度也是兼容的</li></ul><p id="6cf2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意，如果尺寸不兼容，你会得到一个<code class="eh kr ks kt ku b">ValueError</code>。</p><p id="a1b1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">提示:在完成计算后，还要测试结果数组的大小！您将看到大小实际上是沿着输入数组的每个维度的最大大小。</p><ul class=""><li id="e38a" class="kv kw hu it b iu iv iy iz jc kx jg ky jk kz jo la lb lc ld dt translated">最后，只有在所有维度都兼容的情况下，阵列才能一起广播。</li></ul><p id="8c09" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">简而言之，如果你想利用广播，你将很大程度上依赖于你所工作的阵列的形状和尺寸。</p><p id="7eec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是如果维度不兼容呢？</p><p id="2914" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果它们不相等或者其中一个不等于1呢？</p><p id="568a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你必须通过操纵你的数组来解决这个问题！您将在下一节中看到如何做到这一点。</p><h2 id="1541" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">如何做数组数学</h2><p id="cb74" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">您已经看到，当您进行算术运算时，广播非常方便。在这一节中，您将发现一些可以用来对数组进行数学运算的函数。</p><p id="bf4f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，您可能不会感到惊讶，您可以使用<code class="eh kr ks kt ku b">+</code>、<code class="eh kr ks kt ku b">-</code>、<code class="eh kr ks kt ku b">*</code>、<code class="eh kr ks kt ku b">/</code>或<code class="eh kr ks kt ku b">%</code>来加、减、乘、除或计算两个(或更多)数组的余数。然而，NumPy如此方便的很大一部分原因是因为它也有这样的功能。你刚才看到的操作的等价函数分别是<code class="eh kr ks kt ku b">np.add()</code>、<code class="eh kr ks kt ku b">np.subtract()</code>、<code class="eh kr ks kt ku b">np.multiply()</code>、<code class="eh kr ks kt ku b">np.divide()</code>和<code class="eh kr ks kt ku b">np.remainder()</code>。</p><p id="535e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你也可以很容易地用<code class="eh kr ks kt ku b">np.exp()</code>和<code class="eh kr ks kt ku b">np.sqrt()</code>计算你的数组的指数和平方根，或者用<code class="eh kr ks kt ku b">np.sin()</code>和<code class="eh kr ks kt ku b">np.cos()</code>计算你的数组的正弦或余弦。最后，值得一提的是，还有一种方法可以让你用<code class="eh kr ks kt ku b">np.log()</code>计算自然对数，或者通过对你的数组应用<code class="eh kr ks kt ku b">dot()</code>来计算点积。</p><p id="e715" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是还有更多。</p><p id="82ce" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">点击查看这个聚合函数的小列表<a class="ae jq" href="https://www.datacamp.com/community/tutorials/python-numpy-tutorial" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="3577" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了所有这些函数之外，您可能还会发现，了解一些允许您比较数组元素的机制是很有用的。例如，如果您想检查两个数组的元素是否相同，您可以使用<code class="eh kr ks kt ku b">==</code>操作符。要检查数组元素是变小了还是变大了，可以使用<code class="eh kr ks kt ku b">&lt;</code>或<code class="eh kr ks kt ku b">&gt;</code>操作符。</p><p id="0275" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这看起来很简单，是吗？</p><p id="cdca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，你也可以比较整个数组！在这种情况下，您使用<code class="eh kr ks kt ku b">np.array_equal()</code>功能。只需传入两个你想相互比较的数组，就大功告成了。</p><p id="901a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，除了比较之外，您还可以对阵列执行逻辑运算。可以从<code class="eh kr ks kt ku b">np.logical_or()</code>、<code class="eh kr ks kt ku b">np.logical_not()</code>、<code class="eh kr ks kt ku b">np.logical_and()</code>开始。这基本上类似于典型的OR、NOT和and逻辑运算；</p><p id="09fc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在最简单的例子中，您使用OR来查看您的元素是否相同(例如，1)，或者两个数组元素之一是否为1。如果两者都是0，你就返回<code class="eh kr ks kt ku b">FALSE</code>。您可以使用AND来查看第二个元素是否也是1，而不是查看第二个元素是否与1不同。</p><h2 id="1cc2" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">子集化、切片和索引</h2><p id="274a" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">除了数学运算，您还可以考虑只取原始数组(或结果数组)的一部分，或者只取一些数组元素用于进一步的分析或其他运算。在这种情况下，您需要对阵列进行子集划分、切片和/或索引。</p><p id="84e3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些操作与在Python列表上执行这些操作非常相似。如果你想自己找出相似之处，或者想要更详细的解释，你可以考虑看看DataCamp的<a class="ae jq" href="https://www.datacamp.com/community/tutorials/18-most-common-python-list-questions-learn-python" rel="noopener ugc nofollow" target="_blank"> Python列表教程</a>。</p><p id="5f76" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您对这些操作是如何工作的毫无头绪，那么现在知道这两个基本的事情就足够了:</p><ul class=""><li id="6278" class="kv kw hu it b iu iv iy iz jc kx jg ky jk kz jo la lb lc ld dt translated">您使用方括号<code class="eh kr ks kt ku b">[]</code>作为索引操作符，并且</li><li id="58eb" class="kv kw hu it b iu le iy lf jc lg jg lh jk li jo la lb lc ld dt translated">通常，您将整数传递给这些方括号，但是您也可以放一个冒号<code class="eh kr ks kt ku b">:</code>或冒号与整数的组合来指定您想要选择的元素/行/列。</li></ul><p id="811f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了这两点之外，了解这一切是如何结合在一起的最简单的方法是看一些子集化的例子。这里可以找到一些<a class="ae jq" href="https://www.datacamp.com/community/tutorials/python-numpy-tutorial" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="cc5f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">比子集化稍微高级一点的东西，如果你愿意，是切片。在这里，您不仅要考虑数组的特定值，还要考虑行和列的级别。您基本上是在处理数据的“区域”，而不是纯粹的“位置”。</p><p id="1d6d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你会发现，从本质上来说，以下情况成立:</p><pre class="lk ll lm ln fq lv ku lw lx aw ly dt"><span id="922c" class="jr js hu ku b fv lz ma l mb mc">a[start:end] # items start through the end (but the end is not included!)<br/>a[start:] # items start through the rest of the array <br/>a[:end] # items from the beginning through the end (but the end is not included!)</span></pre><p id="4056" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，还有索引。说到NumPy，有布尔索引和高级或“花式”索引。</p><p id="201e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">(以防你好奇，这是真的NumPy行话，最后一个不是我编的！)</em></p><p id="c1bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先是布尔索引。这里，不是根据索引号选择元素、行或列，而是从满足特定条件的数组中选择那些值。</p><p id="e57b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意，为了指定一个条件，您还可以使用逻辑操作符<code class="eh kr ks kt ku b">|</code> (OR)和<code class="eh kr ks kt ku b">&amp;</code> (AND)。如果你想以这样一种方式重写上面的条件(这将是低效的，但我在这里展示它是出于教育目的:)，你将得到<code class="eh kr ks kt ku b">bigger_than_3 = (my_3d_array &gt; 3) | (my_3d_array == 3)</code>。</p><p id="49cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于已经加载的数组，没有太多的可能性，但是对于包含名称或大写字母的数组，可能性是无限的！</p><p id="8b36" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">说到有趣的索引，你基本上是这样做的:你传递一个整数列表或数组来指定你想从原始数组中选择的行子集的顺序。</p><p id="a7c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你觉得这听起来有点抽象吗？在这里进行一些练习<a class="ae jq" href="https://www.datacamp.com/community/tutorials/python-numpy-tutorial" rel="noopener ugc nofollow" target="_blank"/>。</p><h2 id="21c0" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">寻求帮助</h2><p id="df57" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">作为一个简短的插曲，你应该知道你可以随时询问关于你正在使用的模块、函数或类的更多信息，特别是因为当你第一次开始使用NumPy时，它可能是相当了不起的。</p><p id="fce1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">寻求帮助相当容易。</p><p id="89d2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您只需利用<code class="eh kr ks kt ku b">numpy</code>提供的特定帮助功能，就可以上路了:</p><ul class=""><li id="bf00" class="kv kw hu it b iu iv iy iz jc kx jg ky jk kz jo la lb lc ld dt translated">使用<code class="eh kr ks kt ku b">lookfor()</code>对文档字符串进行关键字搜索。如果你刚刚开始，这特别方便，因为它背后的“理论”可能会在你的记忆中消失。一个缺点是，如果您的查询不是那么具体，您必须浏览所有的搜索结果，正如下面的代码示例中的情况。这可能会让你更难看到它。</li><li id="ea57" class="kv kw hu it b iu le iy lf jc lg jg lh jk li jo la lb lc ld dt translated">使用<code class="eh kr ks kt ku b">info()</code>获得函数、类或模块的快速解释和代码示例。如果你是一个在实践中学习的人，这就是你要走的路！使用这个函数的唯一缺点可能是您需要知道某些属性或函数所在的模块。如果您不知道这是什么意思，请查看下面的代码示例。</li></ul><p id="268e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意，你确实需要知道<code class="eh kr ks kt ku b">dtype</code>是<code class="eh kr ks kt ku b">ndarray</code>的一个属性。此外，确保您不要忘记在您要查询信息的模块、类或术语前面加上<code class="eh kr ks kt ku b">np</code>,否则您将得到如下错误消息:</p><pre class="lk ll lm ln fq lv ku lw lx aw ly dt"><span id="8963" class="jr js hu ku b fv lz ma l mb mc">Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; NameError: name 'ndarray' is not defined</span></pre><p id="670a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你现在知道如何寻求帮助，这是一件好事。本NumPy教程的下一个主题是数组操作。</p><p id="4f89" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">并不是说你自己不能克服这个话题，恰恰相反！</p><p id="1289" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是有些函数可能会产生问题，因为调整大小和整形之间有什么区别？</p><p id="b89f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">水平和垂直堆叠阵列有什么区别？</p><p id="5164" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下一节将回答这些问题，但是如果您有疑问，请随意使用您刚刚看到的帮助功能来快速上手。</p><h2 id="0159" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">数组操作</h2><p id="df35" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">在你的数组上执行数学运算是你要做的事情之一，但可能最重要的是让这个和广播工作知道如何操作你的数组。</p><p id="d6ea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是你将会做的一些最常见的操作。</p><p id="d800" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">置换数组实际上是改变它的维数。换句话说，你可以改变数组的形状。</p><p id="6ed2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">提示</strong>:如果数组和它的转置版本之间的视觉比较不完全清楚，请检查两个数组的形状，以确保您理解了为什么维度被置换。</p><p id="5d2a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意有两个转置函数。两者做的一样；没有太大区别。你必须考虑到<code class="eh kr ks kt ku b">T</code>看起来更像是一个方便的功能，而且你可以更加灵活地使用<code class="eh kr ks kt ku b">np.transpose()</code>。这就是为什么如果你想要更多的参数，建议使用这个函数。</p><p id="689a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当你转置一维以上的数组时，一切都很好，但是当你只有一维数组时会发生什么呢？你觉得会有什么影响吗？</p><p id="0014" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">提示:在这里尝试一下<a class="ae jq" href="https://www.datacamp.com/community/tutorials/python-numpy-tutorial" rel="noopener ugc nofollow" target="_blank"/>。</p><h2 id="b939" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">调整数组大小与改变数组形状</h2><p id="53fc" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">您可能在广播部分读到过，如果您希望数组成为算术运算的良好候选，那么数组的维数需要兼容。但是当情况不是这样的时候，你应该怎么做，这个问题还没有答案。</p><p id="be04" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">嗯，这就是你得到答案的地方！</p><p id="29c9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果数组没有相同的维数，你能做的就是调整数组的大小。然后，您将返回一个新数组，该数组具有您传递给<code class="eh kr ks kt ku b">np.resize()</code>函数的形状。如果您将原始数组与新维度一起传递，并且如果新数组大于原始数组，则新数组将被原始数组的副本填充，这些副本将根据需要重复多次。</p><p id="d89b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，如果您只是将<code class="eh kr ks kt ku b">np.resize()</code>应用于数组，并将新的形状传递给它，那么新的数组将被填充零。</p><p id="7bdb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了调整大小，你还可以重塑你的数组。这意味着你给一个数组一个新的形状而不改变它的数据。整形的关键是确保新数组的总大小不变。如果你以上面使用的数组<code class="eh kr ks kt ku b">x</code>为例，它的大小是3 X 4或者12，你必须确保新数组的大小也是12。</p><p id="811b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Psst…如果你想用代码计算数组的大小，确保使用<code class="eh kr ks kt ku b">size</code>属性:<code class="eh kr ks kt ku b">x.size.</code></p><p id="89e5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果所有这些都失败了，您还可以将一个数组附加到原始数组，或者插入或删除数组元素，以确保您的维数与您要用于计算的另一个数组相匹配。</p><p id="75c1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当你改变数组的形状时，另一个操作是<code class="eh kr ks kt ku b">ravel()</code>。这个函数允许你展平你的数组。这意味着，如果你有2D，3D或n-D数组，你可以使用这个函数把它们展平成1-D数组。</p><p id="e4ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">很方便，不是吗？</p><h2 id="c598" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">如何应用数组</h2><p id="9181" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">当您将数组追加到原始数组时，它们会“粘附”到原始数组的末尾。如果你想确保你添加的内容不会出现在数组的末尾，你可以考虑插入它。如果您想了解更多信息，请进入下一部分。</p><p id="f810" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">多亏了NumPy库，追加是一件非常容易的事情；你可以只使用<code class="eh kr ks kt ku b">np.append()</code>。</p><p id="55fe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了追加之外，还可以插入和删除数组元素。您可能已经猜到了，允许您执行这些操作的函数是<code class="eh kr ks kt ku b">np.insert()</code>和<code class="eh kr ks kt ku b">np.delete().</code></p><h2 id="18d0" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">如何堆叠和拆分数组？</h2><p id="825f" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">您还可以“合并”或加入您的阵列。有许多函数可以用于这个目的，下面列出了其中的大部分。</p><p id="1927" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在使用这些函数时，您会注意到一些事情:</p><ul class=""><li id="ab64" class="kv kw hu it b iu iv iy iz jc kx jg ky jk kz jo la lb lc ld dt translated">如果想用<code class="eh kr ks kt ku b">np.concatenate()</code>连接两个数组，维数需要相同。因此，如果你想用一维的<code class="eh kr ks kt ku b">my_array</code>连接一个数组，你需要确保你的第二个数组也是一维的。</li><li id="be2f" class="kv kw hu it b iu le iy lf jc lg jg lh jk li jo la lb lc ld dt translated">有了<code class="eh kr ks kt ku b">np.vstack()</code>，你可以毫不费力地把<code class="eh kr ks kt ku b">my_array</code>和<code class="eh kr ks kt ku b">my_2d_array</code>结合起来。你只需要确保，当你按行堆叠数组时，两个数组中的列数是相同的。因此，您也可以添加一个形状为<code class="eh kr ks kt ku b">(2,4)</code>或<code class="eh kr ks kt ku b">(3,4)</code>到<code class="eh kr ks kt ku b">my_2d_array</code>的数组，只要列数匹配。换句话说，除了第一个轴之外，阵列必须具有相同的形状。当你想使用<code class="eh kr ks kt ku b">np.r[]</code>时也是如此。</li><li id="5d60" class="kv kw hu it b iu le iy lf jc lg jg lh jk li jo la lb lc ld dt translated">对于<code class="eh kr ks kt ku b">np.hstack()</code>，你必须确保维数相同，并且两个数组中的行数相同。这意味着你可以堆叠像<code class="eh kr ks kt ku b">(2,3)</code>或者<code class="eh kr ks kt ku b">(2,4)</code>到<code class="eh kr ks kt ku b">my_2d_array</code>这样的数组，它们本身就是<code class="eh kr ks kt ku b">(2,4)</code>的一种形式。只要确保行数匹配，一切皆有可能。这个功能NumPy还是支持的，不过你应该更喜欢<code class="eh kr ks kt ku b">np.concatenate()</code>或者<code class="eh kr ks kt ku b">np.stack()</code>。</li><li id="8d6a" class="kv kw hu it b iu le iy lf jc lg jg lh jk li jo la lb lc ld dt translated">使用<code class="eh kr ks kt ku b">np.column_stack()</code>，您必须确保您输入的数组具有相同的第一维度。在这种情况下，两种形状是相同的，但是如果<code class="eh kr ks kt ku b">my_resized_array</code>是<code class="eh kr ks kt ku b">(2,1)</code>或<code class="eh kr ks kt ku b">(2,)</code>，数组仍然是堆叠的。</li><li id="25fe" class="kv kw hu it b iu le iy lf jc lg jg lh jk li jo la lb lc ld dt translated"><code class="eh kr ks kt ku b">np.c_[]</code>是串联的另一种方式。这里，两个数组的第一维也需要匹配。</li></ul><p id="4dd1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当您加入数组时，您可能还想在某个时候拆分它们。就像你可以水平堆叠它们一样，你也可以垂直堆叠它们。你分别用<code class="eh kr ks kt ku b">np.hsplit()</code>和<code class="eh kr ks kt ku b">np.vsplit()</code>。</p><p id="abdf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当你使用这两个分裂函数时，你需要记住的是你的数组的形状。</p><p id="a4f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，一定会派上用场的是知道如何绘制数组。这在数据探索中尤其方便，但在数据科学工作流的后期阶段，当您想要可视化您的阵列时也是如此。</p><h2 id="3ae0" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">如何绘制数组</h2><p id="8cf5" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">与函数所暗示的相反，<code class="eh kr ks kt ku b">np.histogram()</code>函数并不绘制直方图，但是它会计算数组在每个区间内的出现次数；这将决定直方图中每一条所占的面积。</p><p id="41e4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">传递给<code class="eh kr ks kt ku b">np.histogram()</code>函数的首先是输入数据或者你正在处理的数组。计算直方图时，数组将变平。</p><p id="b056" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">结果，您将看到直方图将被计算出来:第一个数组列出了数组中所有元素的频率，而第二个数组列出了如果您不指定任何仓，将会使用的仓。</p><p id="6cd9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你指定了一些容器，计算的结果将会不同:浮点数将会消失，你将会看到所有容器的整数。</p><p id="2bb3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您还可以指定一些其他参数，这些参数会影响直方图的计算。你可以在这里找到所有的<a class="ae jq" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.histogram.html" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="d620" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是如果不能可视化，计算这样的直方图又有什么意义呢？</p><p id="c2bb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">借助Matplotlib，可视化是小菜一碟，但你不需要<code class="eh kr ks kt ku b">np.histogram()</code>来计算直方图。<code class="eh kr ks kt ku b">plt.hist()</code>当您将(展平的)数据和bin传递给它时，它会自动执行此操作:</p><pre class="lk ll lm ln fq lv ku lw lx aw ly dt"><span id="6139" class="jr js hu ku b fv lz ma l mb mc"># Import numpy and matplotlib <br/>import numpy as np <br/>import matplotlib.pyplot as plt </span><span id="0f9b" class="jr js hu ku b fv mu ma l mb mc"># Construct the histogram with a flattened 3d array and a range of bins <br/>plt.hist(my_3d_array.ravel(), bins=range(0,13)) </span><span id="0951" class="jr js hu ku b fv mu ma l mb mc"># Add a title to the plot <br/>plt.title('Frequency of My 3D Array Elements') </span><span id="c899" class="jr js hu ku b fv mu ma l mb mc"># Show the plot <br/>plt.show()</span></pre><p id="1c78" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上面的代码将为您提供以下(基本)直方图:</p><figure class="lk ll lm ln fq lo fe ff paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="fe ff mv"><img src="../Images/caca15e2d4ebcde1c2e950c972ac88e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hWsAt4eJo7rWGows.png"/></div></div></figure><p id="1ad6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一种(间接)可视化你的数组的方法是使用<code class="eh kr ks kt ku b">np.meshgrid()</code>。数组面临的问题是，你需要x和y坐标值的二维数组。使用上面的函数，您可以用一个x值数组和一个y值数组创建一个矩形网格:<code class="eh kr ks kt ku b">np.meshgrid()</code>函数采用两个1D数组，并生成两个2D矩阵，对应于这两个数组中的所有(x，y)对。然后，你可以用这些矩阵做出各种各样的图。</p><p id="7f40" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您想在网格上计算函数，那么<code class="eh kr ks kt ku b">np.meshgrid()</code>特别有用，如下面的代码所示:</p><pre class="lk ll lm ln fq lv ku lw lx aw ly dt"><span id="cabe" class="jr js hu ku b fv lz ma l mb mc"># Import NumPy and Matplotlib <br/>import numpy as np import <br/>matplotlib.pyplot as plt </span><span id="3179" class="jr js hu ku b fv mu ma l mb mc"># Create an array <br/>points = np.arange(-5, 5, 0.01) </span><span id="0b1f" class="jr js hu ku b fv mu ma l mb mc"># Make a meshgrid <br/>xs, ys = np.meshgrid(points, points) <br/>z = np.sqrt(xs ** 2 + ys ** 2)</span><span id="3242" class="jr js hu ku b fv mu ma l mb mc"># Display the image on the axes <br/>plt.imshow(z, cmap=plt.cm.gray) </span><span id="1905" class="jr js hu ku b fv mu ma l mb mc"># Draw a color bar <br/>plt.colorbar() </span><span id="2b63" class="jr js hu ku b fv mu ma l mb mc"># Show the plot <br/>plt.show()</span></pre><p id="369c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上面的代码给出了以下结果:</p><figure class="lk ll lm ln fq lo fe ff paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="fe ff mv"><img src="../Images/7021688616d8d0fba4962ee097b4192f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*V-J89kXCkx6nxW8D.png"/></div></div></figure><h2 id="a1f2" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">使用Python进行数据分析:续</h2><p id="810c" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">恭喜你，你已经到达NumPy教程的结尾！</p><p id="e62b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你已经涉及了很多领域，所以现在你必须确保记住你所获得的知识。别忘了拿你的DataCamp的NumPy备忘单来帮助你做这件事！</p><p id="9838" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在所有这些理论之后，是时候用你在本教程中学到的概念和技术进行更多的实践了。一种方法是回到<a class="ae jq" href="https://www.datacamp.com/community/tutorials/machine-learning-python" rel="noopener ugc nofollow" target="_blank"> scikit-learn教程</a>并开始进一步试验用于构建<a class="ae jq" href="https://hackernoon.com/tagged/machine-learning" rel="noopener ugc nofollow" target="_blank">机器学习</a>模型的数据阵列。</p><p id="3c8e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果这不是你喜欢的，请再次检查你是否下载了Anaconda。然后，通过这本<a class="ae jq" href="https://www.datacamp.com/community/tutorials/tutorial-jupyter-notebook" rel="noopener ugc nofollow" target="_blank">Jupyter笔记本权威指南</a>，开始使用Jupyter中的NumPy数组。此外，请务必查看这个Jupyter笔记本，它还会在Jupyter笔记本的交互式数据科学环境中指导您使用Python和NumPy以及其他一些库进行数据分析。</p><p id="220d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，考虑一下DataCamp关于数据操作和可视化的课程。尤其是我们与Continuum Analytics合作的最新课程肯定会让您感兴趣！看看<a class="ae jq" href="https://www.datacamp.com/courses/manipulating-dataframes-with-pandas" rel="noopener ugc nofollow" target="_blank">用熊猫操纵数据框</a>或<a class="ae jq" href="https://www.datacamp.com/courses/pandas-foundations" rel="noopener ugc nofollow" target="_blank">熊猫基础</a>课程。</p></div><div class="ab cl mw mx hc my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="hn ho hp hq hr"><p id="646f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">原载于</em><a class="ae jq" href="http://www.datacamp.com/community/tutorials/python-numpy-tutorial" rel="noopener ugc nofollow" target="_blank"><em class="jp">www.datacamp.com</em></a><em class="jp">。</em></p><div class="lk ll lm ln fq ab cb"><figure class="nd lo ne nf ng nh ni paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nd lo ne nf ng nh ni paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nd lo ne nf ng nh ni paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="nj nk nl"><p id="f922" class="ir is jp it b iu iv iw ix iy iz ja jb nm jd je jf nn jh ji jj no jl jm jn jo hn dt translated">黑客中午是黑客如何开始他们的下午。我们是这个家庭的一员。我们现在<a class="ae jq" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jq" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is jp it b iu iv iw ix iy iz ja jb nm jd je jf nn jh ji jj no jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jq" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jq" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lk ll lm ln fq lo fe ff paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="fe ff np"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="lk ll lm ln fq lo"><div class="bz el l di"><div class="nq nr l"/></div></figure></div></div>    
</body>
</html>