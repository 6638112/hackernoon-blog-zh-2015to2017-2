<html>
<head>
<title>A Cache is Fast: Enhancing our API with Redis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">缓存更快:用Redis增强我们的API</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-cache-is-fast-enhancing-our-api-with-redis-bd61d13c3ca8?source=collection_archive---------1-----------------------#2017-10-16">https://medium.com/hackernoon/a-cache-is-fast-enhancing-our-api-with-redis-bd61d13c3ca8?source=collection_archive---------1-----------------------#2017-10-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="3864" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在过去的几周里，我们已经使用<a class="ae jp" href="https://hackage.haskell.org/package/persistent" rel="noopener ugc nofollow" target="_blank">持久化</a>在Postgresql数据库中存储了一个<code class="eh jq jr js jt b">User</code>类型。然后我们能够使用<a class="ae jp" href="https://hackage.haskell.org/package/servant" rel="noopener ugc nofollow" target="_blank"> Servant </a>创建一个非常简单的API，将这个数据库暴露给外界。本周，我们将看看如何使用<a class="ae jp" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>缓存来提高API的性能。</p><p id="6d76" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">无论怎样强调缓存在软件和硬件中的重要性都不为过。内存类型有一个层次结构，从寄存器到RAM，到文件系统，再到远程数据库。访问每一个都变得越来越慢(数量级)。但是更快的存储方式更贵，所以我们不能总是想要多少就有多少。</p><p id="7a95" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是内存使用遵循一个非常重要的原则。当我们使用一块内存一次，我们很可能在不久的将来再次使用它。所以当我们把一些东西从长期记忆中提取出来时，我们也可以把它暂时储存在短期记忆中。这样，当我们再次需要它时，我们可以更快地得到它。在某个点之后，该项目将被其他更紧急的项目覆盖。这就是缓存的本质。</p><h1 id="b9cd" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">Redis 101</h1><p id="2ae2" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">Redis是一个允许我们创建项目的键值存储的应用程序。它的功能类似于数据库，只是它只使用这些键。它缺少复杂的连接、外部表引用和索引。所以我们不能运行SQL数据库上可能的复杂查询。但是我们可以运行简单的键查找，而且速度更快。在本文中，我们将使用Redis作为用户对象的短期缓存。</p><p id="cd1f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于本文，我们有一个缓存集成的主要目标。每当我们使用API中的<code class="eh jq jr js jt b">GET</code>端点“获取”用户时，我们都希望将该用户存储在Redis缓存中。下一次有人从我们的API中请求该用户时，我们将从缓存中获取他们。这将省去我们长时间调用Postgres数据库的麻烦。</p><h1 id="c124" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">连接到Redis</h1><p id="76e4" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">Haskell的Redis库与Persistent和Postgres有很多相似之处。首先，我们需要某种数据来告诉我们在哪里寻找我们的数据库。对于Postgres，我们使用了一个简单的具有特定格式的<code class="eh jq jr js jt b">ConnectionString</code>。Redis使用一种叫做<code class="eh jq jr js jt b">ConnectInfo</code>的完整数据类型。</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="aae5" class="lf jv hu jt b fv lg lh l li lj">data ConnectInfo = ConnectInfo<br/>  { connectHost :: HostName -- String<br/>  , connectPort :: PortId   -- (Can just be a number)<br/>  , connectAuth :: Maybe ByteString<br/>  , connectDatabase :: Integer<br/>  , connectMaxConnection :: Int<br/>  , connectMaxIdleTime :: NominalDiffTime<br/>  }</span></pre><p id="163f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">其中有许多与我们存储在PG字符串中的字段相同的字段，比如主机IP地址和端口号。本文的其余部分假设您正在端口6379上运行一个本地Redis实例。这意味着我们可以使用<code class="eh jq jr js jt b">defaultConnectInfo</code>。和往常一样，在真实的系统中，您希望从配置中获取这些信息，所以您需要<code class="eh jq jr js jt b">IO</code>。</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="b444" class="lf jv hu jt b fv lg lh l li lj">fetchRedisConnection :: IO ConnectInfo<br/>fetchRedisConnection = return defaultConnectInfo</span></pre><p id="51c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于Postgres，我们使用<code class="eh jq jr js jt b">withPostgresqlConn</code>来实际连接到数据库。在Redis中，我们用<code class="eh jq jr js jt b">connect</code>函数来完成这项工作。我们将得到一个<code class="eh jq jr js jt b">Connection</code>对象，我们可以用它来运行Redis操作。</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="3f4f" class="lf jv hu jt b fv lg lh l li lj">connect :: ConnectInfo -&gt; IO Connection</span></pre><p id="7a66" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有了这个联系，我们就简单的用<code class="eh jq jr js jt b">runRedis</code>，然后结合一个动作。这是我们为此编写的包装器<code class="eh jq jr js jt b">runRedisAction</code>:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="c275" class="lf jv hu jt b fv lg lh l li lj">runRedisAction :: ConnectInfo -&gt; Redis a -&gt; IO a<br/>runRedisAction redisInfo action = do<br/>  connection &lt;- connect redisInfo<br/>  runRedis connection action</span></pre><h1 id="8d45" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">雷迪斯单子</h1><p id="955f" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">正如我们将<code class="eh jq jr js jt b">SqlPersistT</code>单子用于Persist一样，我们将使用<code class="eh jq jr js jt b">Redis</code>单子与Redis缓存进行交互。我们的API很简单，所以我们将坚持使用三个基本函数。这些函数的真实类型稍微复杂一些。但这是因为与事务相关的多态性，我们不会使用它们。</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="6b39" class="lf jv hu jt b fv lg lh l li lj">get :: ByteString -&gt; Redis (Either x (Maybe ByteString))<br/>set :: ByteString -&gt; ByteString -&gt; Redis (Either x ())<br/>setex :: ByteString -&gt; ByteString -&gt; Int -&gt; Redis (Either x ())</span></pre><p id="67d4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Redis是一个键值存储，所以我们在这里设置的所有东西都将使用<code class="eh jq jr js jt b">ByteString</code>项。但是一旦我们完成了这些，我们就只需要使用这些函数了。<code class="eh jq jr js jt b">get</code>函数获取键的一个<code class="eh jq jr js jt b">ByteString</code>，并将该值作为另一个<code class="eh jq jr js jt b">ByteString</code>传递。<code class="eh jq jr js jt b">set</code>函数获取序列化的键和值，并将它们存储在缓存中。<code class="eh jq jr js jt b">setex</code>函数的功能与<code class="eh jq jr js jt b">set</code>相同，只是它还为我们存储的项目设置了一个到期时间。</p><p id="7722" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">到期是一个非常有用的特性，因为大多数关系数据库没有这个特性。缓存的本质是，在任何给定的时间，它只能存储我们信息的一个子集。如果我们从来没有过期或删除任何东西，它最终可能会存储我们的整个数据库。这将违背使用缓存的目的！与我们的数据库相比，它的内存占用应该很低。所以我们将在我们的API中使用<code class="eh jq jr js jt b">setex</code>。</p><h1 id="1e28" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">在Redis中保存用户</h1><p id="d0d3" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">所以现在让我们继续我们将在API中实际使用的动作。首先，我们将编写一个函数，它将在数据库中实际存储一个<code class="eh jq jr js jt b">Int64</code>键和<code class="eh jq jr js jt b">User</code>键-值对。我们从这里开始:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="03de" class="lf jv hu jt b fv lg lh l li lj">cacheUser :: ConnectInfo -&gt; Int64 -&gt; User -&gt; IO ()<br/>cacheUser redisInfo uid user = runRedisAction redisInfo $ setex ??? ??? ???</span></pre><p id="eb72" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们现在需要做的就是将我们的键和值转换成<code class="eh jq jr js jt b">ByteString</code>值。我们将保持它的简单，并结合我们的<code class="eh jq jr js jt b">Show</code>和<code class="eh jq jr js jt b">Read</code>实例使用<code class="eh jq jr js jt b">Data.ByteString.Char8</code>。然后我们将使用<code class="eh jq jr js jt b">setex</code>创建一个<code class="eh jq jr js jt b">Redis</code>动作，并在3600秒(一小时)后使密钥过期。</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="800e" class="lf jv hu jt b fv lg lh l li lj">import Data.ByteString.Char8 (pack, unpack)</span><span id="ac78" class="lf jv hu jt b fv lk lh l li lj">...</span><span id="bec5" class="lf jv hu jt b fv lk lh l li lj">cacheUser :: ConnectInfo -&gt; Int64 -&gt; User -&gt; IO ()<br/>cacheUser redisInfo uid user = runRedisAction redisInfo $ void $ <br/>  setex (pack . show $ uid) 3600 (pack . show $ user)</span></pre><p id="8964" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(我们使用<code class="eh jq jr js jt b">void</code>来忽略Redis调用的结果)。</p><h1 id="f83b" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">从Redis获取</h1><p id="4cc1" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">获取用户是一个类似的过程。我们会带走连接信息和我们要找的密钥。我们将创建的动作使用字节字符串表示并调用<code class="eh jq jr js jt b">get</code>。但是我们不能像以前那样忽视这次通话的结果！找回任何东西都会给我们<code class="eh jq jr js jt b">Either e (Maybe ByteString)</code>。一个<code class="eh jq jr js jt b">Left</code>响应指示一个错误，而<code class="eh jq jr js jt b">Right Nothing</code>指示该键不存在。我们将忽略这些错误，并将结果视为<code class="eh jq jr js jt b">Maybe User</code>。如果出现任何错误，我们将返回<code class="eh jq jr js jt b">Nothing</code>。这意味着我们运行一个简单的模式匹配:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="43f0" class="lf jv hu jt b fv lg lh l li lj">fetchUserRedis :: ConnectInfo -&gt; Int64 -&gt; IO (Maybe User)<br/>fetchUserRedis redisInfo uid = runRedisAction redisInfo $ do<br/>  result &lt;- Redis.get (pack . show $ uid)<br/>  case result of<br/>    Right (Just userString) -&gt; return $ Just (read . unpack $ userString)<br/>    _ -&gt; return Nothing</span></pre><p id="d0f5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们为那个键找到了什么，我们将把它从它的<code class="eh jq jr js jt b">ByteString</code>格式中读取出来，然后我们就有了最终的<code class="eh jq jr js jt b">User</code>对象。</p><h1 id="820e" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">将此应用于我们的API</h1><p id="2272" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">现在我们已经设置好了Redis函数，我们需要更新<code class="eh jq jr js jt b">fetchUsersHandler</code>来使用这个缓存。首先，我们现在需要将Redis连接信息作为另一个参数传递。为了便于阅读，从现在开始，我们将使用类型同义词(<code class="eh jq jr js jt b">PGInfo</code>和<code class="eh jq jr js jt b">RedisInfo</code>)来引用它们:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="85db" class="lf jv hu jt b fv lg lh l li lj">type PGInfo = ConnectionString<br/>type RedisInfo = ConnectInfo</span><span id="35e6" class="lf jv hu jt b fv lk lh l li lj">…</span><span id="a17b" class="lf jv hu jt b fv lk lh l li lj">fetchUsersHandler :: PGInfo -&gt; RedisInfo -&gt; Int64 -&gt; Handler User<br/>fetchUsersHandler pgInfo redisInfo uid = do<br/>  ...</span></pre><p id="d913" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们要做的第一件事是通过Redis缓存中的ID来查找用户。如果用户存在，我们将立即返回该用户。</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="d351" class="lf jv hu jt b fv lg lh l li lj">fetchUsersHandler :: PGInfo -&gt; RedisInfo -&gt; Int64 -&gt; Handler User<br/>fetchUsersHandler pgInfo redisInfo uid = do<br/>  maybeCachedUser &lt;- liftIO $ fetchUserRedis redisInfo uid<br/>  case maybeCachedUser of<br/>    Just user -&gt; return user<br/>    Nothing -&gt; do<br/>      ...</span></pre><p id="6c28" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果用户不存在，那么我们将进入在数据库中获取用户的逻辑。如果我们发现用户实际上不存在，我们将重复抛出错误的逻辑。但是如果找到用户，我们还需要一步。在我们返回它之前，我们应该调用<code class="eh jq jr js jt b">cacheUser</code>并存储它以备将来使用。</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="7f4b" class="lf jv hu jt b fv lg lh l li lj">fetchUsersHandler :: PGInfo -&gt; RedisInfo -&gt; Int64 -&gt; Handler User<br/>fetchUsersHandler pgInfo redisInfo uid = do<br/>  maybeCachedUser &lt;- liftIO $ fetchUserRedis redisInfo uid<br/>  case maybeCachedUser of<br/>    Just user -&gt; return user<br/>    Nothing -&gt; do<br/>      maybeUser &lt;- liftIO $ fetchUserPG pgInfo uid<br/>      case maybeUser of<br/>        Just user -&gt; liftIO (cacheUser redisInfo uid user) &gt;&gt; return user<br/>        Nothing -&gt; Handler $ (throwE $ err401 { errBody = "Could not find user with that ID" })</span></pre><p id="e390" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为我们改变了我们的类型签名，我们还必须做一些其他的更新，但是这些都很简单:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="5dc1" class="lf jv hu jt b fv lg lh l li lj">usersServer :: PGInfo -&gt; RedisInfo -&gt; Server UsersAPI<br/>usersServer pgInfo redisInfo =<br/>  (fetchUsersHandler pgInfo redisInfo) :&lt;|&gt; <br/>  (createUserHandler pgInfo)<br/></span><span id="061f" class="lf jv hu jt b fv lk lh l li lj">runServer :: IO ()<br/>runServer = do<br/>  pgInfo &lt;- fetchPostgresConnection<br/>  redisInfo &lt;- fetchRedisConnection<br/>  run 8000 (serve usersAPI (usersServer pgInfo redisInfo))</span></pre><p id="567a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就是这样！我们有一个带有过期条目的正常工作的缓存。这意味着对我们的获取端点的重复查询应该快得多！</p><h1 id="ddb0" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">结论</h1><p id="d69b" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">缓存是一种非常重要的方式，我们可以用它来为用户编写更快的软件。Redis是一个键值存储，我们可以将它用作最常用数据的缓存。我们可以用它来代替强制每个API调用访问我们的数据库。在Haskell中，Redis API要求所有东西都是<code class="eh jq jr js jt b">ByteString</code>。所以我们必须处理一些编码和解码的逻辑。但除此之外，它的运行方式与Persistent和Postgres非常相似。</p><p id="7ea2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一定要在<a class="ae jp" href="https://github.com/jhb563/ProdHaskellSeries/tree/redis" rel="noopener ugc nofollow" target="_blank"> Github </a>上看看这段代码！这篇文章有一个<code class="eh jq jr js jt b">redis</code>分支。它包括所有的代码样本，包括我跳过的东西，比如导入！</p><p id="411f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们开始在Haskell应用程序中使用许多不同的库！知道如何组织一切是值得的，所以包管理是至关重要的！我倾向于使用<a class="ae jp" href="https://docs.haskellstack.org/en/stable/README/" rel="noopener ugc nofollow" target="_blank">栈</a>来管理我所有的包。将所有这些不同的库整合在一起非常容易。如果您想学习如何使用Stack，请查看我们免费的<a class="ae jp" href="http://academy.mondaymorninghaskell.com/p/your-first-haskell-project" rel="noopener ugc nofollow" target="_blank"> Stack迷你课程</a>！</p><p id="8131" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你以前从未学习过Haskell，你应该尝试一下！下载我们的<a class="ae jp" href="https://www.mmhaskell.com/checklist" rel="noopener ugc nofollow" target="_blank">入门清单</a>！</p></div></div>    
</body>
</html>