<html>
<head>
<title>Docker FastPath: Only Build Your Images Once</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker FastPath:只构建一次映像</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/docker-fastpath-only-build-your-images-once-a4c3beeae7d3?source=collection_archive---------9-----------------------#2017-04-24">https://medium.com/hackernoon/docker-fastpath-only-build-your-images-once-a4c3beeae7d3?source=collection_archive---------9-----------------------#2017-04-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="d06e" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">使用您喜欢的Git工作流程，通过Docker实现快速无误的环境升级</h2></div><p id="54cd" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf">TL；在您的构建系统中部署</em><a class="ae kg" href="https://github.com/mfornasa/docker-fastpath" rel="noopener ugc nofollow" target="_blank"><em class="kf">Docker fast path</em></a><em class="kf">DR。</em></p><p id="7a29" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我从Humble和Farley的经典<a class="ae kg" href="https://www.amazon.com/Continuous-Delivery-Deployment-Automation-Addison-Wesley/dp/0321601912/" rel="noopener ugc nofollow" target="_blank"> <em class="kf">连续交付</em> </a>中学到的最有用的信息之一(立即获取您的副本！)就是<strong class="jl hv">只编译你的二进制文件一次</strong>。</p><blockquote class="kh ki kj"><p id="e21c" class="jj jk kf jl b jm jn iv jo jp jq iy jr kk jt ju jv kl jx jy jz km kb kc kd ke hn dt translated">许多构建系统使用版本控制系统中保存的源代码作为许多步骤的规范源。代码将在不同的上下文中反复编译[…]。每次编译代码，你都冒着引入一些差异的风险<br/>【j . Humble，D. Farley，Continuous Delivery，p. 133】</p></blockquote><p id="23b5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可以注意到，这本书是在2011年写的，使用了“编译”这个词。快进到2017年，在最近的<a class="ae kg" href="https://stackoverflow.com/insights/survey/2017" rel="noopener ugc nofollow" target="_blank"> StackOverlow开发者调查</a>中，基于Javascript的技术达到了惊人的85%的偏好，动态语言正在主导<a class="ae kg" href="https://hackernoon.com/tagged/web-development" rel="noopener ugc nofollow" target="_blank"> web开发</a>。不出所料，这个建议在今天仍然很有价值:你只需要用你喜欢的构建方法(<code class="eh kn ko kp kq b">npm install</code>、<code class="eh kn ko kp kq b">bundle install</code>、<code class="eh kn ko kp kq b">webpack</code>等)来改变“编译”。).</p><p id="ec3a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在一项研究中，研究人员发现:</p><blockquote class="kh ki kj"><p id="069f" class="jj jk kf jl b jm jn iv jo jp jq iy jr kk jt ju jv kl jx jy jz km kb kc kd ke hn dt translated">[…]构建中断的典型情况是缺少引用的文件，错误地检入正在进行的工作，以及可传递的依赖关系。</p></blockquote><p id="f7dd" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">此外，一次又一次地构建相同的代码库既费时又让开发人员难以获得及时的反馈。</p><p id="d18d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以，现在更有必要“只编译一次你的二进制文件”。在<a class="ae kg" href="https://hackernoon.com/tagged/docker" rel="noopener ugc nofollow" target="_blank"> Docker </a>开发管道中，这转化为:</p><blockquote class="kr"><p id="a94d" class="ks kt hu bd ku kv kw kx ky kz la ke ek translated"><strong class="ak">只构建一次映像</strong></p></blockquote><h1 id="e8c9" class="lb lc hu bd ld le lf lg lh li lj lk ll ja lm jb ln jd lo je lp jg lq jh lr ls dt translated">典型的Git + Docker持续集成管道</h1><p id="6422" class="pw-post-body-paragraph jj jk hu jl b jm lt iv jo jp lu iy jr js lv ju jv jw lw jy jz ka lx kc kd ke hn dt translated">使用Docker的典型持续集成流程是:</p><ul class=""><li id="71ca" class="ly lz hu jl b jm jn jp jq js ma jw mb ka mc ke md me mf mg dt translated">对git库的代码推送触发了构建过程(Jenkins、TravisCI、GitLab等)。)</li><li id="df4f" class="ly lz hu jl b jm mh jp mi js mj jw mk ka ml ke md me mf mg dt translated">构建(标记)Docker映像并将其推送到Docker注册表</li><li id="94ad" class="ly lz hu jl b jm mh jp mi js mj jw mk ka ml ke md me mf mg dt translated">图像被自动测试</li><li id="b1a1" class="ly lz hu jl b jm mh jp mi js mj jw mk ka ml ke md me mf mg dt translated">该映像部署在您最喜欢的Docker orchestrator (Kubernetes、ECS、Swarm等)上。)在测试环境中</li><li id="b98f" class="ly lz hu jl b jm mh jp mi js mj jw mk ka ml ke md me mf mg dt translated">对管道中的以下环境重复该过程(试运行、生产等。)</li></ul><p id="fdc2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通常，您有不止一个服务器环境。环境标签变化很大；常见的选择有<code class="eh kn ko kp kq b">development</code>、<code class="eh kn ko kp kq b">qa</code>、<code class="eh kn ko kp kq b">staging</code>。当给定环境的目标实现时，就需要促进向更高环境的改变。</p><p id="83a9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里的目标是将我们的工件(Docker映像)从一个环境推到下一个环境。一种可能性是将这个过程从代码存储库中分离出来:映像提升发生在外部系统上。这种方法不容易与常见的git工作流(G <a class="ae kg" href="http://nvie.com/posts/a-successful-git-branching-model/" rel="noopener ugc nofollow" target="_blank"> itflow </a>、<a class="ae kg" href="https://help.github.com/articles/about-pull-requests/" rel="noopener ugc nofollow" target="_blank"> GitHub Pull Requests </a>、<a class="ae kg" href="https://docs.gitlab.com/ee/gitlab-basics/add-merge-request.html" rel="noopener ugc nofollow" target="_blank"> GitLab Merge Requests </a>、<a class="ae kg" href="http://endoflineblog.com/gitflow-considered-harmful" rel="noopener ugc nofollow" target="_blank">别的东西</a>)集成，在这些工作流中，控制权掌握在开发人员手中。但是，正如Humble和Farley告诉我们的，在代码级别提升是不好的。</p><h1 id="60c5" class="lb lc hu bd ld le lf lg lh li lj lk ll ja mm jb ln jd mn je lp jg mo jh lr ls dt translated">介绍Docker FastPath</h1><p id="ba05" class="pw-post-body-paragraph jj jk hu jl b jm lt iv jo jp lu iy jr js lv ju jv jw lw jy jz ka lx kc kd ke hn dt translated">我在这里提倡将控制权掌握在开发人员手中，让他们使用自己喜欢的Git工作流，享受<strong class="jl hv">只构建一次映像的强大功能</strong>。该方法独立于正在使用的特定Git工作流，它基于两个简单的规则:</p><ol class=""><li id="46f9" class="ly lz hu jl b jm jn jp jq js ma jw mb ka mc ke mp me mf mg dt translated">用Git commit ID标记这个映像，这个映像就是从这个Git commit ID构建的。</li><li id="d730" class="ly lz hu jl b jm mh jp mi js mj jw mk ka ml ke mp me mf mg dt translated">如果代码库与现有映像相同，则不要在代码推送时重新构建:而是部署该映像。</li></ol><p id="4402" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">要应用第2条规则，有必要检查Git历史记录，并将结果与图像的Docker注册表标记列表进行交叉检查。请注意，在大多数情况下，您可以有两个相同的代码库，但有不同的Git提交id:因此比较Git IDs是不够的，您需要区分这两个代码库。<a class="ae kg" href="https://github.com/mfornasa/docker-fastpath" rel="noopener ugc nofollow" target="_blank"> Docker FastPath </a>就是这么做的。</p><p id="ecc3" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们看一些例子。</p><h2 id="978a" class="mq lc hu bd ld mr ms mt lh mu mv mw ll js mx my ln jw mz na lp ka nb nc lr nd dt translated">示例#1:合并特征分支</h2><figure class="nf ng nh ni fq nj fe ff paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="fe ff ne"><img src="../Images/f566961597192a6423b6481b4cc24974.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FhxmYbIpSS2L1M65WNjlOg.png"/></div></div></figure><p id="f615" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是GitHub Pull请求的默认行为。使用合并提交(使用<code class="eh kn ko kp kq b">--no-ff</code>选项)将特性分支的所有提交添加到基础分支<code class="eh kn ko kp kq b">master</code>。在这种情况下，提交<code class="eh kn ko kp kq b">1044aee</code>与提交<code class="eh kn ko kp kq b">e51acc3</code>相同，不需要重新构建。图像标记为<code class="eh kn ko kp kq b">1044aee</code>可以直接部署。</p><h2 id="c9f2" class="mq lc hu bd ld mr ms mt lh mu mv mw ll js mx my ln jw mz na lp ka nb nc lr nd dt translated">示例2:挤压和合并</h2><figure class="nf ng nh ni fq nj fe ff paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="fe ff nq"><img src="../Images/36988dde09a7cd9364f074ec2c9199a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6L1RVo2oDCDH4dXQ6lCaOQ.png"/></div></div></figure><p id="cac2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是当你选择“挤压和合并”时GitHub Pull请求的行为。所有特性分支提交都被压缩成一个提交，并使用Git快进添加到基本分支。在这种情况下，提交<code class="eh kn ko kp kq b">af49f3d</code>与提交<code class="eh kn ko kp kq b">e51acc3</code>相同，不需要重新构建。标记为<code class="eh kn ko kp kq b">e51acc3</code>的图像可以直接部署。</p><h2 id="6887" class="mq lc hu bd ld mr ms mt lh mu mv mw ll js mx my ln jw mz na lp ka nb nc lr nd dt translated">例子#3:重定基础和合并</h2><figure class="nf ng nh ni fq nj fe ff paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="fe ff nr"><img src="../Images/964fe4192e255dbbfb4d7597a5ab150c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mef4_kbdbfeJO3V2oWmabQ.png"/></div></div></figure><p id="34e3" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当您选择“Rebase and merge”时，这是GitHub Pull请求的行为:来自feature分支的所有提交都被添加到base分支，没有合并提交。在这种情况下，提交<code class="eh kn ko kp kq b">1eb55b3</code>与提交<code class="eh kn ko kp kq b">e51acc3</code>相同，不需要重新构建。标记为<code class="eh kn ko kp kq b">e51acc3</code>的图像可以直接部署。</p><h1 id="a7aa" class="lb lc hu bd ld le lf lg lh li lj lk ll ja mm jb ln jd mn je lp jg mo jh lr ls dt translated">尝试</h1><p id="8513" class="pw-post-body-paragraph jj jk hu jl b jm lt iv jo jp lu iy jr js lv ju jv jw lw jy jz ka lx kc kd ke hn dt translated"><a class="ae kg" href="https://github.com/mfornasa/docker-fastpath" rel="noopener ugc nofollow" target="_blank"> Docker FastPath </a>代码可以在GitHub上作为命令行工具获得。您可以下载一个适用于MacOS或Linux的可执行文件，它可以很容易地部署在大多数构建系统上，但是如果您愿意，您也可以从源代码构建它。</p><p id="c1de" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">提供了两个部署示例:一个使用<a class="ae kg" href="https://github.com/mfornasa/docker-fastpath-jenkins" rel="noopener ugc nofollow" target="_blank"> Jenkins </a>，另一个使用<a class="ae kg" href="https://github.com/mfornasa/docker-fastpath-travis" rel="noopener ugc nofollow" target="_blank"> Travis CI </a>。使用这些例子来使FastPath适应您现有的基于Docker的软件项目应该很容易。</p><blockquote class="kr"><p id="4c35" class="ks kt hu bd ku kv kw kx ky kz la ke ek translated">如果你喜欢这篇文章，请点击下面的“♥︎”按钮。更多关于DevOps和Docker的文章，请加入我的邮件列表。</p></blockquote><div class="ns nt nu nv nw ab cb"><figure class="nx nj ny nz oa ob oc paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nx nj ny nz oa ob oc paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nx nj ny nz oa ob oc paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="kh ki kj"><p id="f922" class="jj jk kf jl b jm jn iv jo jp jq iy jr kk jt ju jv kl jx jy jz km kb kc kd ke hn dt translated"><a class="ae kg" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kg" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kg" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae kg" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jj jk kf jl b jm jn iv jo jp jq iy jr kk jt ju jv kl jx jy jz km kb kc kd ke hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kg" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kg" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="nf ng nh ni fq nj fe ff paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="fe ff od"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="nf ng nh ni fq nj"><div class="bz el l di"><div class="oe of l"/></div></figure></div></div>    
</body>
</html>