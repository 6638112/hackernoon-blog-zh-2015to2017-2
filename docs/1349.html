<html>
<head>
<title>Truly atomic deployments with NGINX and PHP-FPM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NGINX和PHP-FPM真正的原子部署</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/truly-atomic-deployments-with-nginx-and-php-fpm-aed8a8ac1cd9?source=collection_archive---------2-----------------------#2016-10-17">https://medium.com/hackernoon/truly-atomic-deployments-with-nginx-and-php-fpm-aed8a8ac1cd9?source=collection_archive---------2-----------------------#2016-10-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="4854" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">注意:</strong>这个解决方案只有在NGINX和PHP-FPM都驻留在同一个服务器上时才有效。</p><p id="6128" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在实时服务器上进行“git pull”部署并不理想，因为磁盘上的所有文件不会在同一毫秒内发生变化。从一个版本的代码开始的请求可能会访问其他文件，这些文件可能会在请求过程中被更新。为了获得真正的原子部署，像Capistrano这样的PHP部署应用程序有一个指向当前构建的符号链接，一旦新的构建文件夹准备好了，就简单地将符号链接更新到新的构建。因为Linux本身没有任何磁盘缓存，所以将符号链接改为指向新的构建是原子性的。在同一毫秒，符号链接文件夹中的所有文件现在都指向它们的较新版本。</p><p id="29f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个构建过程有一些问题。</p><h1 id="c5ec" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated"><strong class="ak">设置:</strong></h1><p id="d505" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">1)NGINX(web服务器)和PHP-FPM(PHP FastCGI进程管理器)都驻留在同一个服务器上。</p><p id="fa13" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2) NGINX从文档根目录(/var/www/app.com)提供服务，该根目录是指向当前版本的符号链接。</p><p id="859d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">3)访问者请求【https://app.com/hello.php.】T4 NGINX代理PHP-FPM，并请求它执行/var/www/app . com/hello . PHP。PHP-FPM将上述脚本的输出返回给Nginx，Nginx将它返回给访问者。</p><p id="a785" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">4) PHP Opcache是一个缓存，它维护了(脚本路径-&gt;机器代码翻译)的映射。这种缓存可以防止一次又一次地解释PHP代码，并对性能产生很大影响。</p><p id="b18b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">5) PHP的Realpath缓存是一个包含路径映射的缓存，用于PHP脚本中的相关文件。如果脚本中使用了大量的“require/require_once”和“include/include_once”语句，性能也会有很大的不同。</p><h1 id="3c12" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated"><strong class="ak">问题</strong></h1><p id="b441" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">构建过程的最后一步是更改符号链接。在改变符号链接时，FPM仍然在旧的构建文件夹中执行PHP脚本。</p><p id="a17f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后意识到。如果NGINX告诉PHP-FPM执行/var/www/app.com/hello.php，Opcache将简单地获取旧的脚本机器翻译(因为OpCache仍然获得相同的文件路径)，除非它的缓存被刷新。</p><p id="c687" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Opcache本身向Realpath缓存查询一些路径映射。</p><h2 id="b050" class="kt jq hu bd jr ku kv kw jv kx ky kz jz jc la lb kd jg lc ld kh jk le lf kl lg dt translated"><strong class="ak">如果我们可以刷新Opcache和Realpath缓存会怎么样</strong></h2><p id="9fe4" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">即使每次构建时都刷新这两种缓存，在刷新缓存和符号链接更改之间也会有几毫秒的时间。在此期间，由于服务器上的传入请求，缓存将再次开始构建，刷新缓存将是无用的。</p><p id="7878" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果在进行符号链接更改后刷新缓存，那么旧代码将在刷新缓存和符号链接更改之间的时间内执行。</p><h2 id="5741" class="kt jq hu bd jr ku kv kw jv kx ky kz jz jc la lb kd jg lc ld kh jk le lf kl lg dt translated"><strong class="ak">PHP-FPM重装了怎么办</strong></h2><p id="983a" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">这本身有两个问题:</p><p id="8aaa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">a)在重新加载过程中，一些请求可能会丢弃/未完成/失败。</p><p id="380c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">b)同样，在创建符号链接和开始重新加载FPM之间可能会有几毫秒的时间。在这段时间内，旧代码可能会再次执行，因为符号链接在此之前可能已经更改过了。</p><p id="1c96" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，这显然不是一个解决方案。</p><h2 id="d1ff" class="kt jq hu bd jr ku kv kw jv kx ky kz jz jc la lb kd jg lc ld kh jk le lf kl lg dt translated"><strong class="ak">如果NGINX从新的构建文件夹(不是符号链接的那个)提供服务并重新加载会怎样？</strong></h2><p id="4642" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">NGINX可以从新的构建文件夹而不是符号链接文件夹提供服务，因此，消除了所有缓存问题。</p><p id="a464" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每次构建时，可以在NGINX conf文件中动态更改文档根，然后可以重新加载NGINX。</p><p id="5aa7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个潜在的值得研究的解决方案。想避免重新加载NGINX。</p><h1 id="2009" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated"><strong class="ak">解决方案</strong></h1><p id="0046" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">经过一番研究，我发现了一个易于实施的解决方案:</p><p id="4234" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">fastcgi _ param SCRIPT _ FILENAME $ document _ root $ fastcgi _ SCRIPT _ name；</p><p id="4e0c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt">=&gt;</p><p id="4b62" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">fastcgi _ param SCRIPT _ FILENAME $ real path _ root $ fastcgi _ SCRIPT _ name；</p><p id="0f03" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">NGINX配置中从$document_root到$realpath_root的简单更改将使NGINX传递实际的脚本路径(在跟随符号链接之后解析)。由于PHP-FPM现在获得了脚本的实际路径(每次构建时总是新的)，所有的缓存问题都会消失，因为所有文件的路径现在都是新的。</p><h2 id="6ce0" class="kt jq hu bd jr ku kv kw jv kx ky kz jz jc la lb kd jg lc ld kh jk le lf kl lg dt translated"><strong class="ak">解决方案仍然无效</strong></h2><p id="b06c" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">解决方案没有成功。在启用了PHP FPM的访问日志和NGINX的调试日志以找出NGINX在对FPM的请求中传递的确切路径之后，结果是传递的路径类似于/var/www/app.com/hello.php</p><p id="e5d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是带有符号链接的路径，而不是绝对真实的路径。那么，为什么这不起作用呢？我当前版本的NGINX支持Realpath功能吗？经过一些研究，我发现在NGINX 0.8版中启用了Realpath功能。我的环境中有1.4版，因此应该可以工作。</p><p id="e3de" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我在NGINX中注释了fastcgi_pass这一行，只是为了确定这一行还在被拾取。NGINX重新加载，应用程序仍然工作。我不知道FPM是如何知道该执行哪个文件的。然后，我意识到这一行可能会在某处被覆盖。事实证明这是正确的。</p><p id="126d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在下面两行，NGINX配置显示如下:include/etc/NGINX/fastcgi _ params</p><p id="0011" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个文件有一个传递给FPM的常用fastcgi参数列表。我从这个文件中删除了SCRIPT_FILENAME参数，并重新加载了NGINX，现在NGINX正在将真正的解析路径传递给FPM。唷。</p><p id="2551" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我将fastcgi_pass语句放在include语句下面，这种情况就可以避免，因为这样我的变量值就会覆盖该文件中的值。因为我的语句在它上面，所以文件中的变量覆盖了我定义的变量。</p><h1 id="6416" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated"><strong class="ak">新的构建过程</strong></h1><p id="5c96" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">1)现在构建是完全原子化的，因为一个符号链接的改变足以告诉NGINX从新的文档根开始服务。</p><p id="0e8e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2)无需在每次构建后重新加载NGINX或FPM。因此，每一个要求都可以得到满足。</p><p id="b589" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">3) NGINX负责将每个PHP文件的绝对解析路径传递给FPM，因此，新构建后的缓存问题不再存在。因此，在新的构建之后，不需要刷新Opcache或Realpath缓存。</p><p id="654c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">4)如果在新版本上有任何问题，指向先前版本的符号链接更改就足够了:)</p><p id="49d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">交叉发布于<a class="ae ks" href="https://kanishkdudeja.in/truly-atomic-deployments-with-nginx-and-php-fpm/" rel="noopener ugc nofollow" target="_blank">https://kanishkdudeja . in/true-atomic-deployments-with-nginx-and-PHP-fpm/</a></p></div></div>    
</body>
</html>