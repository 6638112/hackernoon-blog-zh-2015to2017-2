<html>
<head>
<title>(Finally) Understanding Monads (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">(最后)理解单子(第1部分)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/finally-understanding-monads-part-1-2a4904f11042?source=collection_archive---------8-----------------------#2017-02-20">https://medium.com/hackernoon/finally-understanding-monads-part-1-2a4904f11042?source=collection_archive---------8-----------------------#2017-02-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="a851" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这篇文章最初发表在2017年2月13日的<a class="ae jp" href="https://mmhaskell.com/blog/2017/2/13/finally-understanding-monads-part-1" rel="noopener ugc nofollow" target="_blank">周一早间哈斯克尔博客</a>上。查看博客获取更多Haskell内容！</p><p id="37e3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们现在应该对<a class="ae jp" href="https://mmhaskell.com/blog/2017/1/30/the-easiest-haskell-idiom" rel="noopener ugc nofollow" target="_blank">函子</a>和<a class="ae jp" href="https://mmhaskell.com/blog/2017/2/6/applicatives-one-step-further" rel="noopener ugc nofollow" target="_blank">适用函子</a>有了一个不错的理解(如果你没有，请查看链接！).现在是时候迈出下一步了。我们将处理可怕的单子概念。网上有几十个monad教程和描述。这是有道理的。单子对于用Haskell编写任何有意义的程序都是至关重要的。它们不是函数式编程中最难的概念，但是由于它们的重要性，它们是最大的障碍。在这一系列文章中，我们将尝试以小的、可管理的块来处理这个概念。</p><p id="843c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以事不宜迟，下面是我的定义:单子用特定的<strong class="it hv">上下文</strong>包装一个值或一个计算。单子必须定义一种在上下文中包装正常值的方式<strong class="it hv">，以及一种在上下文中组合计算</strong>的方式<strong class="it hv">。</strong></p><p id="1288" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个定义相当宽泛。所以让我们从更实际的层面来理解这一点。</p><h1 id="7841" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">单子类型类</h1><p id="2d77" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">就像函子和应用函子一样，Haskell用类型类表示单子。它有两个功能:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="f839" class="lc jr hu ky b fv ld le l lf lg">class Monad m where<br/>  return :: a -&gt; m a<br/>  (&gt;&gt;=) :: m a -&gt; a -&gt; m b -&gt; m b</span></pre><p id="bf75" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这两个功能对应了上面的两个思路。<code class="eh lh li lj ky b">return</code>函数指定了如何在单子的上下文中<strong class="it hv">包装</strong>值。<code class="eh lh li lj ky b">&gt;&gt;=</code>操作符，我们称之为“bind”函数，指定如何在上下文中<strong class="it hv">组合</strong>两个操作。让我们通过探索几个具体的单子实例来进一步阐明这一点。</p><h1 id="00d9" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">可能单子</h1><p id="aefe" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">正如<code class="eh lh li lj ky b">Maybe</code>是函子和应用函子，它也是单子。为了激励<code class="eh lh li lj ky b">Maybe</code>单子，让我们考虑这个代码。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="1998" class="lc jr hu ky b fv ld le l lf lg">maybeFunc1 :: String -&gt; Maybe Int<br/>maybeFunc1 “” = Nothing<br/>maybeFunc1 str = Just $ length str</span><span id="6906" class="lc jr hu ky b fv lk le l lf lg">maybeFunc2 :: Int -&gt; Maybe Float<br/>maybeFunc2 i = if i `mod` 2 == 0<br/>  then Nothing<br/>  Else Just ((fromIntegral i) * 3.14159)</span><span id="2fe5" class="lc jr hu ky b fv lk le l lf lg">maybeFunc3 :: Float -&gt; Maybe [Int]<br/>maybeFunc3 f = if f &gt; 15.0<br/>  then Nothing<br/>  else $ Just [floor f, ceil f]</span><span id="4c15" class="lc jr hu ky b fv lk le l lf lg">runMaybeFuncs :: String -&gt; Maybe [Int]<br/>runMaybeFuncs input = case maybeFunc1 input of<br/>  Nothing -&gt; Nothing<br/>  Just i -&gt; case maybeFunc2 i of<br/>    Nothing -&gt; Nothing<br/>    Just f -&gt; maybeFunc3 f</span></pre><p id="2ba9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以看到，当我们继续对连续函数调用的结果进行模式匹配时，我们开始开发一个可怕的三角形模式。如果我们给它添加更多的功能，它会变得越来越糟糕。当我们将<code class="eh lh li lj ky b">Maybe</code>视为单子时，我们可以使代码更加清晰。让我们看看Haskell是如何作为单子实现<code class="eh lh li lj ky b">Maybe</code>的。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="6426" class="lc jr hu ky b fv ld le l lf lg">instance Monad Maybe where<br/>  return = Just<br/>  Nothing &gt;&gt;= _ = Nothing<br/>  Just a &gt;&gt;= f = f a</span></pre><p id="04e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Maybe monad描述的上下文很简单。Maybe中的计算可能会失败，也可能会成功，其值为。我们可以将任何值包装在这个上下文中，称之为“成功”。我们用<code class="eh lh li lj ky b">Just</code>构造函数来做这件事。我们用<code class="eh lh li lj ky b">Nothing</code>来代表失败。</p><p id="d43a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们通过检查第一次计算的结果来组合这种情况下的计算。如果它<strong class="it hv">成功</strong>，我们取其值，并将其传递给<strong class="it hv">第二次计算</strong>。如果它失败了，那么我们就没有值可以传递给下一步。所以<strong class="it hv">总计算失败</strong>。让我们看看如何使用bind操作符来组合我们的操作:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="7464" class="lc jr hu ky b fv ld le l lf lg">runMaybeFuncs :: String -&gt; Maybe [Int]<br/>runMaybeFuncs input = maybeFunc1 input &gt;&gt;= maybeFunc2 &gt;&gt;= maybeFunc3</span></pre><p id="1165" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个看起来干净多了！让我们来看看为什么这些类型行得通。<code class="eh lh li lj ky b">maybeFunc1 input</code>的结果简单来说就是<code class="eh lh li lj ky b">Maybe Int</code>。然后，bind操作符允许我们获取这个<code class="eh lh li lj ky b">Maybe Int</code>值，并将其与<code class="eh lh li lj ky b">maybeFunc2</code>组合，后者的类型是<code class="eh lh li lj ky b">Int -&gt; Maybe Float</code>。<strong class="it hv">绑定操作符将</strong>这些解析为<code class="eh lh li lj ky b">Maybe Float</code>。然后我们通过bind操作符将它传递给<code class="eh lh li lj ky b">maybeFunc3</code>，得到我们的最终类型<code class="eh lh li lj ky b">Maybe [Int]</code>。</p><p id="7668" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不过，您的函数不会总是组合得如此清晰。这就是<code class="eh lh li lj ky b">do</code>符号发挥作用的地方。我们可以将上述内容改写为:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="4bcc" class="lc jr hu ky b fv ld le l lf lg">runMaybeFuncs :: String -&gt; Maybe [Int]<br/>runMaybeFuncs input = do<br/>  i &lt;- maybeFunc1 input<br/>  f &lt;- maybeFunc2 f<br/>  maybeFunc3 f</span></pre><p id="3b54" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lh li lj ky b">&lt;-</code>操作符是特殊的。它有效地<strong class="it hv">从单子展开</strong>右边的值。这意味着值<code class="eh lh li lj ky b">i</code>具有类型<code class="eh lh li lj ky b">Int</code>，<strong class="it hv">，即使</strong>的结果为<code class="eh lh li lj ky b">Maybe Int</code>。绑定操作在幕后进行，如果函数返回<code class="eh lh li lj ky b">Nothing</code>，那么整个<code class="eh lh li lj ky b">runMaybeFuncs</code>函数将返回<code class="eh lh li lj ky b">Nothing</code>。</p><p id="f675" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">乍一看，这比bind示例更复杂。然而，它给了我们更多的灵活性。考虑一下，在调用<code class="eh lh li lj ky b">maybeFunc2</code>之前，我们是否想在整数上加2。在<code class="eh lh li lj ky b">do</code>符号中，这<strong class="it hv">很容易</strong>处理，但是当简单地使用绑定时就更困难了:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="3bb8" class="lc jr hu ky b fv ld le l lf lg">runMaybeFuncs :: String -&gt; Maybe [Int]<br/>runMaybeFuncs input = do<br/>  i &lt;- maybeFunc1 input<br/>  f &lt;- maybeFunc2 (i + 2)<br/>  maybeFunc3 f</span><span id="c502" class="lc jr hu ky b fv lk le l lf lg">-- Not so nice<br/>runMaybeFuncsBind :: String -&gt; Maybe [Int]<br/>runMaybeFuncsBind input = maybeFunc1 input<br/>  &gt;&gt;= (\i -&gt; maybeFunc2 (i + 2))<br/>  &gt;&gt;= maybeFunc3</span></pre><p id="cbb2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们想在一个函数调用中使用<strong class="it hv">多个先前的结果</strong>，收益会更加明显。使用绑定，我们将不得不在匿名函数中不断地积累参数。关于do符号的一个注意事项:我们从不使用<code class="eh lh li lj ky b">&lt;-</code>来展开do块中的最后一个操作。我们对<code class="eh lh li lj ky b">maybeFunc3</code>的调用具有类型<code class="eh lh li lj ky b">Maybe [Int]</code>。这是我们的最终类型(不是<code class="eh lh li lj ky b">[Int]</code>)，所以我们不打开包装。</p><h1 id="8208" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">要么是单子</h1><p id="541f" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">现在，让我们检查一下<code class="eh lh li lj ky b">Either</code>单子，它与<code class="eh lh li lj ky b">Maybe</code>单子非常相似。定义如下:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="8188" class="lc jr hu ky b fv ld le l lf lg">instance Monad (Either a) where<br/>  return r = Right r<br/>  (Left l) &gt;&gt;= _ = Left l<br/>  (Right r) &gt;&gt;= f = f r</span></pre><p id="e9eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">鉴于<code class="eh lh li lj ky b">Maybe</code>要么成功，要么失败，而<code class="eh lh li lj ky b">Either</code>单子<strong class="it hv">将信息</strong>附加到失败。就像<code class="eh lh li lj ky b">Maybe</code>一样，它通过调用successful将值包装在其上下文中。一元行为还通过在第一次失败时短路来组合操作。让我们看看如何使用它来使上面的代码更加清晰。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="47f8" class="lc jr hu ky b fv ld le l lf lg">maybeFunc1 :: String -&gt; Either String Int<br/>maybeFunc1 “” = Left “String cannot be empty!”<br/>maybeFunc1 str = Right $ length str</span><span id="6760" class="lc jr hu ky b fv lk le l lf lg">maybeFunc2 :: Int -&gt; Either String Float<br/>maybeFunc2 i = if i `mod` 2 == 0<br/>  then Left “Length cannot be even!”<br/>  else Right ((fromIntegral i) * 3.14159)</span><span id="8b08" class="lc jr hu ky b fv lk le l lf lg">maybeFunc3 :: Float -&gt; Either String [Int]<br/>maybeFunc3 f = if f &gt; 15.0<br/>  then Left “Float is too large!”<br/>  else $ Right [floor f, ceil f]</span><span id="6ed9" class="lc jr hu ky b fv lk le l lf lg">runMaybeFuncs :: String -&gt; Either String [Int]<br/>runMaybeFuncs input = do<br/>  i &lt;- maybeFunc1 input<br/>  f &lt;- maybeFunc2 i<br/>  maybeFunc3 f</span></pre><p id="a5cb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以前，每次失败只是给了我们一个<code class="eh lh li lj ky b">Nothing</code>值:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="e9c2" class="lc jr hu ky b fv ld le l lf lg">&gt;&gt; runMaybeFuncs ""<br/>Nothing<br/>&gt;&gt; runMaybeFuncs "Hi"<br/>Nothing<br/>&gt;&gt; runMaybeFuncs "Hithere"<br/>Nothing<br/>&gt;&gt; runMaybeFuncs "Hit"<br/>Just [9,10]</span></pre><p id="56f4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，当我们运行我们的代码时，我们可以查看产生的错误字符串，这将告诉我们<strong class="it hv">哪个函数实际上失败了</strong>。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="3ecd" class="lc jr hu ky b fv ld le l lf lg">&gt;&gt; runMaybeFuncs ""<br/>Left "String cannot be empty!"<br/>&gt;&gt; runMaybeFuncs "Hi"<br/>Left "Length cannot be even!"<br/>&gt;&gt; runMaybeFuncs "Hithere"<br/>Left "Float is too large!"<br/>&gt;&gt; runMaybeFuncs "Hit"<br/>Right [9,10]</span></pre><p id="81dc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意，我们通过错误类型来参数化<code class="eh lh li lj ky b">Either</code>单子。如果我们有:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="6598" class="lc jr hu ky b fv ld le l lf lg">maybeFunc2 :: Either CustomError Float<br/>…</span></pre><p id="4046" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个函数现在在不同的单子上。将它与我们的其他功能结合起来就不那么简单了。如果你想知道我们会怎么做，看看quora 上的这个<a class="ae jp" href="https://www.quora.com/What-are-some-practical-uses-of-bifunctors-in-Haskell/answer/James-Bowen-13" rel="noopener ugc nofollow" target="_blank">答案。</a></p><h1 id="389c" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">木卫一单子</h1><p id="6bd3" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">IO单子可能是Haskell中最重要的单子<strong class="it hv">。这也是最难理解的单子之一。第一次学习单子时，讨论它的实际实现有点太复杂了。所以我们就通过例子来学习。</strong></p><p id="9620" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">IO monad将计算包装在以下上下文中:“该计算可以从终端、文件系统、操作系统和/或网络读取信息或向其写入信息”。如果你想让<strong class="it hv">用户输入</strong>，<strong class="it hv">打印</strong>一条消息给用户，从<strong class="it hv">文件</strong>中读取信息，或者进行<strong class="it hv">网络调用</strong>，你需要在IO Monad中完成这些。这些都是“副作用”。我们不能从“纯”Haskell代码中执行它们。</p><p id="abb6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">几乎所有计算机程序最重要的工作就是以某种方式与外界互动。因此，所有可执行Haskell代码的根都是一个名为<code class="eh lh li lj ky b">main</code>的函数，类型为<code class="eh lh li lj ky b">IO ()</code>。所以每个程序都从IO单子开始。从这里，您可以获得您需要的任何输入，用输入调用相对“纯”的代码，然后以某种方式输出结果。反之则不行。你不能从纯代码中调用IO代码，就像你可以从纯代码中调用<code class="eh lh li lj ky b">Maybe</code>函数一样。</p><p id="71d7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们看一个简单的程序，展示一些基本的IO功能。我们将使用do符号来说明与我们讨论过的其他单子的相似性。为了清楚起见，我们列出了每个IO函数的类型。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="4ae2" class="lc jr hu ky b fv ld le l lf lg">main :: IO ()<br/>main = do<br/>  -- getLine :: IO String<br/>  input &lt;- getLIne<br/>  let uppercased = map Data.Char.toUpper input<br/>  -- print :: String -&gt; IO ()<br/>  print uppercased</span></pre><p id="fb5a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以我们再次看到程序的每一行都有类型<code class="eh lh li lj ky b">IO a</code>。(一个<code class="eh lh li lj ky b">let</code>语句<strong class="it hv">可以出现在任何一个单子</strong>中)。正如我们可以在maybe示例中展开<code class="eh lh li lj ky b">i</code>以获得<code class="eh lh li lj ky b">Int</code>而不是<code class="eh lh li lj ky b">Maybe Int</code>，我们可以使用<code class="eh lh li lj ky b">&lt;-</code>来<strong class="it hv">展开<code class="eh lh li lj ky b">getLine</code>的结果</strong>作为<code class="eh lh li lj ky b">String</code>。然后我们可以使用字符串函数操作这个值，并将结果传递给<code class="eh lh li lj ky b">print</code>函数。</p><p id="3255" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个简单的echo程序。它从终端读取一行，然后以全部大写的形式打印出来。希望它能让您对IO的工作原理有一个基本的了解。我们将在接下来的两篇文章中讨论更多的细节。</p><h1 id="0787" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">摘要</h1><p id="a286" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">单子将计算包装在一个<strong class="it hv">特定的上下文</strong>中。它为上下文中的<strong class="it hv">包装值</strong>和上下文中的<strong class="it hv">组合操作</strong>定义了函数。<strong class="it hv">也许</strong>是单子。我们通过说它的计算可以<strong class="it hv">成功或失败</strong>来描述它的上下文。<strong class="it hv">任一</strong>类似于Maybe，除了它可以将错误信息添加到故障中。<strong class="it hv"> IO monad </strong>非常重要，它封装了读写终端、网络和文件系统的操作上下文。学习一元代码最简单的方法是使用<strong class="it hv"> do符号</strong>。在这个符号中，每一行都有一个右边的单子值。然后，您可以使用<code class="eh lh li lj ky b">&lt;-</code>操作符打开左侧的值。</p><p id="4039" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你想了解单子，一定要去博客<a class="ae jp" href="https://mmhaskell.com/" rel="noopener ugc nofollow" target="_blank">看看！本周我们有一篇关于</a><a class="ae jp" href="https://mmhaskell.com/blog/2017/2/20/how-to-read-and-write-with-monads" rel="noopener ugc nofollow" target="_blank">读者和作者单子</a>的新文章，并展示了它们如何封装我们可能从IO单子获得的不同种类的副作用。</p><p id="e795" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">希望这篇文章已经让你开始(最终)理解单子。如果您还没有编写任何Haskell代码，并且想要开始测试您的单子知识，请务必查看我们免费的Haskell入门清单!</p><p id="6a26" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还没有为单子做好准备，但想尝试一些不同的Haskell技能？查看我们的<a class="ae jp" href="https://www.mmhaskell.com/workbook" rel="noopener ugc nofollow" target="_blank">递归工作簿</a>。它包括2章关于递归和高阶函数的内容，以及10个测试练习题。</p><blockquote class="ll lm ln"><p id="d959" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated">要了解更多信息，<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">请阅读我们的“关于”页面</a> , <a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">喜欢/在脸书给我们发消息</a>，或者简单地，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank">发推文/DM @HackerNoon。</a></p><p id="708a" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>