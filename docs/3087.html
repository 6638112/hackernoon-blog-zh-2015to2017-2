<html>
<head>
<title>Neat optimization trick: reduce the number of jumps in a nested loop</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简洁的优化技巧:减少嵌套循环中的跳转次数</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/neat-optimization-trick-reduce-the-number-of-jumps-in-a-nested-loop-a97fdbfd4c2b?source=collection_archive---------2-----------------------#2017-03-12">https://medium.com/hackernoon/neat-optimization-trick-reduce-the-number-of-jumps-in-a-nested-loop-a97fdbfd4c2b?source=collection_archive---------2-----------------------#2017-03-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/9890c1089a00c3e6cbce277cd48d9ae3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zaKQh9BUMhXUC9g5f-f43g.png"/></div></div></figure><p id="2003" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过重新排序嵌套循环，你可以很容易地获得更高效的代码，也就是说，代码跳转更少。最初的想法归功于史蒂夫·麦康奈尔写的《代码完整》,但我打算用数学进一步扩展它…</p></div><div class="ab cl ka kb hc kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hn ho hp hq hr"><p id="064d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该书中的示例比较了同一嵌套for循环的这两个版本:</p><pre class="kh ki kj kk fq kl km kn ko aw kp dt"><span id="e663" class="kq kr hu km b fv ks kt l ku kv">int a, b;<br/>for (a = 0; a &lt; 10; a++)<br/>  for (b = 0; b &lt; 500; b++)<br/>    printf("hi");</span></pre><p id="4bd8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">和</p><pre class="kh ki kj kk fq kl km kn ko aw kp dt"><span id="3462" class="kq kr hu km b fv ks kt l ku kv">int a, b;<br/>for (b = 0; b &lt; 500; b++)<br/>  for (a = 0; a &lt; 10; a++)<br/>    printf("hi");</span></pre><p id="6f38" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你很容易看到第一个例子跳了10 + 10*500 = 5010次，第二个例子:500 + 500*10 = 5500 <strong class="je hv"> </strong>但是两个例子循环的次数是一样的。这意味着即使它们完成了同样的事情，第一个嵌套循环还是要快一点。但是到底快了多少呢？我们能计算一下吗？</p><h1 id="3afe" class="kw kr hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">计算可能的效率增益</h1><p id="e71a" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">首先，我们假设<strong class="je hv"> X </strong>和<strong class="je hv"> Y </strong>是两个自然数。例如，我们有两个循环。A循环:</p><pre class="kh ki kj kk fq kl km kn ko aw kp dt"><span id="d98f" class="kq kr hu km b fv ks kt l ku kv">int a, b;<br/>for (a = 0; a &lt; X; a++)<br/>  for (b = 0; b &lt; Y; b++)<br/>    printf("hi");</span></pre><p id="ac8d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">B循环:</p><pre class="kh ki kj kk fq kl km kn ko aw kp dt"><span id="1d06" class="kq kr hu km b fv ks kt l ku kv">int a, b;<br/>for (b = 0; b &lt; Y; b++)<br/>  for (a = 0; a &lt; X; a++)<br/>    printf("hi");</span></pre><p id="e16f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">A循环循环<strong class="je hv"> X </strong> + <strong class="je hv"> X </strong> * <strong class="je hv"> Y </strong>次，而第二循环循环<strong class="je hv">Y</strong>+<strong class="je hv">X</strong>*<strong class="je hv">Y</strong>次。B回路和A回路的区别是<strong class="je hv"> Y </strong> - <strong class="je hv"> X </strong>。如果<strong class="je hv"> X </strong> &gt; <strong class="je hv"> Y </strong>那么差值为负，如果<strong class="je hv"> X </strong> == <strong class="je hv"> Y </strong>那么差值为零，如果<strong class="je hv"> X </strong> &lt; <strong class="je hv"> Y </strong>那么差值为正。这意味着，如果<strong class="je hv"> X </strong> &lt; <strong class="je hv"> Y </strong>，那么我们在A循环中执行的<strong class="je hv"> Y </strong> - <strong class="je hv"> X </strong>跳转指令比在B循环中少。</p><p id="0856" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过检查原始示例，您可以看到这确实是真的。在原来的例子中<strong class="je hv"> X </strong> = 10，<strong class="je hv"> Y </strong> = 500。<strong class="je hv"> X </strong> &lt; <strong class="je hv"> Y </strong>为真，<strong class="je hv"> Y </strong> - <strong class="je hv"> X </strong>为490。第一个循环循环5010次，而第二个循环循环5500次。两者相差490也就是<strong class="je hv"> Y </strong> - <strong class="je hv"> X </strong>！</p><p id="f5c4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">总之，你可以说<strong class="je hv"> X </strong>和<strong class="je hv"> Y </strong>之间的差异越大，通过重新排序循环，在<strong class="je hv"> Y </strong>之前的for循环中使用较小的数字<strong class="je hv"> X </strong>，你就可以获得更多的效率。</p><h1 id="477f" class="kw kr hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">更深的嵌套循环呢？</h1><p id="b419" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">对于更深层次的嵌套循环，我们可以继续同样的推理，但让我们这样来描述这个问题:我们需要证明像<strong class="je hv">a</strong>+<strong class="je hv">a</strong>*<strong class="je hv">b</strong>+<strong class="je hv">a</strong>*<strong class="je hv">b</strong>*<strong class="je hv">c</strong>这样的和是最小的，当且仅当<strong class="je hv">是自然数我的证明将类似于数学归纳法。我们之前已经确立了<strong class="je hv">b</strong>+<strong class="je hv">b</strong>*<strong class="je hv">c</strong>在<strong class="je hv"> b </strong> &lt; <strong class="je hv"> c </strong>时较低。所以我们可以这样重组求和:<strong class="je hv">a</strong>+<strong class="je hv">a</strong>*(<strong class="je hv">b</strong>+<strong class="je hv">b</strong>*<strong class="je hv">c</strong>)。我们已经知道了圆括号:为了使总和最小，<strong class="je hv"> b </strong>必须小于<strong class="je hv"> c </strong>，或者换句话说，<strong class="je hv"> b </strong> &lt; <strong class="je hv"> c. </strong>显然可以看出<strong class="je hv"> a </strong>必须尽可能小，以使总和最小。这意味着<strong class="je hv"> a </strong>必须低于<strong class="je hv"> b </strong>和<strong class="je hv"> c </strong>。因此，我们得到当a<strong class="je hv"/>&lt;<strong class="je hv">b</strong>&lt;<strong class="je hv">c</strong>时，和最小。可以将这个相同的逻辑扩展到<strong class="je hv">a</strong>+<strong class="je hv">a</strong>*<strong class="je hv">b</strong>+<strong class="je hv">a</strong>*<strong class="je hv">b</strong>*<strong class="je hv">c</strong>+<strong class="je hv">a</strong>*<strong class="je hv">b</strong>*<strong class="je hv">c</strong>*<strong class="je hv">d</strong>等等。</strong></p><h1 id="d648" class="kw kr hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">摘要</h1><p id="5d14" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">规则是这样的:当编写嵌套循环时，确保变化最大的变量在最内层循环中，而变化最小的变量在最外层循环中。如果循环数很大，这将显著减少跳转次数。</p><h2 id="691e" class="kq kr hu bd kx ly lz ma lb mb mc md lf jn me mf lj jr mg mh ln jv mi mj lr mk dt translated">如果您喜欢该内容，请按心形图标。它鼓励我写更多这样的东西。另外，如果你在我的推理中发现任何错误，请评论。</h2><div class="kh ki kj kk fq ab cb"><figure class="ml iv mm mn mo mp mq paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="ml iv mm mn mo mp mq paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="ml iv mm mn mo mp mq paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mr ms mt"><p id="f922" class="jc jd mu je b jf jg jh ji jj jk jl jm mv jo jp jq mw js jt ju mx jw jx jy jz hn dt translated"><a class="ae my" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae my" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae my" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae my" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd mu je b jf jg jh ji jj jk jl jm mv jo jp jq mw js jt ju mx jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae my" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae my" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kh ki kj kk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mz"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>