<html>
<head>
<title>Tensorflow &amp; PyTorch Design Tradeoffs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Tensorflow和PyTorch设计权衡</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/ml-framework-design-reliability-composition-flexibility-9314f72d2c73?source=collection_archive---------13-----------------------#2017-10-10">https://medium.com/hackernoon/ml-framework-design-reliability-composition-flexibility-9314f72d2c73?source=collection_archive---------13-----------------------#2017-10-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="a5f0" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">ML符合通用编程</h2></div><p id="545a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最近的<a class="ae kf" href="http://nicodjimenez.github.io/2017/10/08/tensorflow.html" rel="noopener ugc nofollow" target="_blank"> Tensorflow Sucks </a>帖子不是新观点，但触动了我的神经，这是我的反应。</p><p id="cddc" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">知道什么<strong class="jl hv">烂</strong>便宜。另一方面，知道什么是<strong class="jl hv">难</strong>是有价值的。</p><p id="53d4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">知道了什么是困难的，你就不会去买蛇油，因为蛇油可以解决所有人的所有问题。它让头脑专注于选择正确的问题，并对其他问题说不。最后，它的好处是提供实际的洞察力和真正进步的机会。</p><p id="5155" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">机器学习有一个独特的设计挑战，因为ML本身的领域正趋向于作为一个主题的通用计算，而不仅仅是实现细节。这意味着它将在我们所认为的“传统编程”中留下越来越多的足迹</p><p id="ea4d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">随之而来的是传统的工程挑战。比如可靠性、重用、架构灵活性。这些问题的解决方案不会免费提供，因为这是一个新游戏。它们需要被设计成。</p><p id="83f3" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这篇文章是关于成为通用语言所带来的一些难题，以及与其他选择相比，Tensorflow特别提供了什么解决方案。这并不是因为张量流是一种银弹，而是因为对于张量流的工作方式，似乎存在一种近乎FUD的普遍困惑。</p><h1 id="fc2f" class="kg kh hu bd ki kj kk kl km kn ko kp kq ja kr jb ks jd kt je ku jg kv jh kw kx dt translated">ML框架难在哪里？</h1><p id="8b2f" class="pw-post-body-paragraph jj jk hu jl b jm ky iv jo jp kz iy jr js la ju jv jw lb jy jz ka lc kc kd ke hn dt translated">虽然ML的过去是一种有限的、特定领域的语言，但ML的未来是一种通用的、通用的语言。</p><p id="0948" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">目前的事态处于中间状态。像许多DSL一样，ML已经发展到需要通用编程原语:条件、循环、(喘息)递归。它还发展到包含一个更大的支持基础设施或“运行时”,如IO、分布式计算、序列化等。</p><p id="d2d1" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">与许多DSL相比，ML的另一个特点是，许多DSL都是非平凡的扩展。递归在ML程序中的含义与在C中的含义是不同的，因为它必须以特定的方式使用，以允许学习发生。</p><p id="f3ce" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在构建ML框架时如何解决这个问题？你可以从头发明一种全新的语言，比如斯坦。您可以通过添加新的原语来扩展现有的语言，比如PyTorch。或者你可以做一些中间的事情，通过构建一种新的语言，但是把它嵌入到一个现有的语言中来获得额外的功能。Tensorflow是最后一个类别的一个例子。</p><p id="46f9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">每个选择都有问题。</p><p id="7df3" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">从头发明一门语言意味着单干，但是如果你的语言语义不能被强加到现有的选项中，那可能是字面上唯一的选择。</p><p id="74bd" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">采用一种现有的语言X对X的用户来说听起来很棒。但是因为语言X不是每个人都使用的，所以可能它并不是在所有事情上都很棒，并且它自己也有一些明显的缺点。如果你想让你的ML框架在X语言不能到达的地方使用，那么这不是一个选择。</p><p id="860a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">将DSL嵌入另一种语言是第三种选择。你使用语言X作为制造机器来构建你的组件，一种元编程。元编程造成了跟踪编译时和运行时之间的区别的心理负担，并使调试更加困难。</p><p id="62ef" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">由此我们可以看出，没有灵丹妙药。但是为了更深入，我们需要更具体地了解我们面临的问题。</p><h1 id="e0b7" class="kg kh hu bd ki kj kk kl km kn ko kp kq ja kr jb ks jd kt je ku jg kv jh kw kx dt translated">99个问题，模特不是一个</h1><p id="f678" class="pw-post-body-paragraph jj jk hu jl b jm ky iv jo jp kz iy jr js la ju jv jw lb jy jz ka lc kc kd ke hn dt translated">“我来了。我看到了。“我做模特”似乎是初露头角的人工智能爱好者的信条，他们正等着被镌刻在体现他们能力的纪念碑上。脑海中浮现出单枪匹马革新这个领域，或者至少获得不错的点击率提升的景象。别挡我的路，我在用魔法！</p><p id="da2f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不幸的是，即使对那些以模特为生的人来说，模特的认知行为也是在舍入误差。在你花了90%的时间清理数据之后，你还会花另外90%的时间与其他系统集成，只是让事情运行起来。(是的这加起来至少是180%，和经验一致。)</p><p id="2d64" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">比特腐蚀、向后不兼容的破坏、拙劣的错误吞咽集成、一时兴起的未记录的假设、总线分解的遗留代码库仍然是甚至成熟的软件工程学科的祸害，并在ML中横行。</p><p id="caf0" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">ML不是工程最佳实践的先锋。部分原因是它的学术血统和相关的DIY编码文化。另一个原因是传统的软件工程在很大程度上忽略了科学所必需的基础:实验。直到最近十年，“数据”才成为一种东西。仅仅能够在IDE中绘制点在今天是一个进步的创新。ML的版本控制是TBD。</p><p id="72d0" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这就是说，在重要的规模上使用和部署这种新的计算范式存在大量的软件工程摩擦。</p><p id="149f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们从基础开始。你的模型运行吗，它会随着时间的推移继续运行吗(可靠性)？我能把它和其他模型组合在一起吗(重用)？以及如何将它与其他组件连接起来解决整体问题(架构灵活性)？</p><h1 id="e049" class="kg kh hu bd ki kj kk kl km kn ko kp kq ja kr jb ks jd kt je ku jg kv jh kw kx dt translated">可靠性</h1><p id="01a2" class="pw-post-body-paragraph jj jk hu jl b jm ky iv jo jp kz iy jr js la ju jv jw lb jy jz ka lc kc kd ke hn dt translated">Tensorflow的图形抽象是一个自包含的模型定义。一个模型在今天和五年后的意义是一样的。这个图形抽象的一个关键方面是<strong class="jl hv">张量流模型不包含外部依赖</strong>。</p><p id="2344" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果运行您的模型需要Python、Lua或任何其他语言运行时，很难做出同样的保证。为了准确地再现模型，您必须准确地再现整个环境，从操作系统级别，通过第三方库，到用户代码。</p><p id="ab0f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">今天，这意味着把它冷冻在一个码头集装箱里。这是一种严重的依赖性，无论是在规模上还是在对下游消费者的要求上。现在，每个模型消费者都必须应对虚拟机边界。</p><p id="44f9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然而集装箱化的最大问题是它给用户带来的负担。<strong class="jl hv">可靠性现在是用户要解决的问题</strong>。如果每个人都做正确的事情，它或多或少会起作用。但是这并不能保证，而且自己解决问题也很复杂。</p><p id="30f4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">“设计可靠”是Tensorflow提供的一个有价值的属性。</p><h1 id="ffec" class="kg kh hu bd ki kj kk kl km kn ko kp kq ja kr jb ks jd kt je ku jg kv jh kw kx dt translated">合成和重用</h1><p id="617f" class="pw-post-body-paragraph jj jk hu jl b jm ky iv jo jp kz iy jr js la ju jv jw lb jy jz ka lc kc kd ke hn dt translated">如果你从事模特行业，很快你就会有很多模特。最终，由于某种原因，你会想同时使用两种型号。也许是为了服务，为了组成一个更大的模型，或者仅仅是为了进行比较。</p><p id="4fb1" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在Tensorflow中，这是微不足道的，不是问题，因为如上所述，模型是自包含的描述，没有额外的依赖性。这足以构成进一步自动化的基础。</p><p id="0b41" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">“采用Python”方法有一个不同的故事。如果模型A依赖于整个环境，而模型B依赖于另一个独立的环境，那该怎么办？</p><p id="71f3" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果模型A需要Python 3.3，模型B需要Python 3.4，也许可以，也许不行。如果这个模型被篡改了，您甚至可能无法反序列化它。或者，在某些方面更糟，您可能在您的无限依赖关系树中的某个地方有冲突的依赖关系。</p><p id="7d7c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">传统的软件工程方法是合并代码库，解决冲突，并重新运行模型。但是再培训模型可能极其昂贵和缓慢。并且数据甚至可能仍然不可用。因此，有非常充分的理由说明为什么您希望能够可靠地重用现有的模型，而不做任何修改。</p><p id="a872" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一个训练有素、技术熟练的团队可以通过首先最小化依赖性、通过测试以及通过强调向后兼容性来减轻这种风险。但是这如何在组织范围内扩展，跨越许多团队呢？给想玩ML进口宇宙的金融实习生？对于面临压力的高级工程师来说，离解决他们眼前的问题只有一步之遥？</p><p id="af08" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">“通过设计可组合和可重用”是Tensorflow提供的一个有价值的属性。</p><h1 id="3e47" class="kg kh hu bd ki kj kk kl km kn ko kp kq ja kr jb ks jd kt je ku jg kv jh kw kx dt translated">建筑灵活性</h1><p id="b329" class="pw-post-body-paragraph jj jk hu jl b jm ky iv jo jp kz iy jr js la ju jv jw lb jy jz ka lc kc kd ke hn dt translated">没有一个模型是孤岛。他们必须连接到数据源进行培训，并将基础架构部署为服务或部署在边缘设备中。除此之外，还有一组不受限制的开发和ops工具，它们可能与模型有关。</p><p id="4c8f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你的模型还可以集成哪些软件？</p><p id="f2be" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Tensorflow可以集成任何可以调用简单C api的东西。它只涉及很少的概念(DAG、session、Tensors ),并且它的基本结构是以文档化的普通格式序列化的。本质上，任何重要的系统最终都会有一个Tensorflow集成，所以你甚至不需要自己去做。这允许极大的架构灵活性，因为您可以选择要集成的点。</p><p id="d534" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果运行您的模型需要Python或任何其他特定语言，情况就大不相同了。现在，您可以将Python/Language X拖到任何地方，或者使用桥，或者使用某种本地消息总线。</p><p id="04a1" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你是Python爱好者，这听起来可能很棒，但是对于投资于其他技术的人来说，这是一个复杂性和问题的来源。这不是一个“去任何地方都不用担心”的情况；您现在处于设计空间的“让我们确保GCs正确交互”分支。当您在错误的Python版本中反序列化模型时，希望所有定制的机器将优雅地、有意义地失败。</p><p id="ab0b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">“与他人合作愉快”是Tensorflow的一项宝贵优势。</p><h1 id="3b05" class="kg kh hu bd ki kj kk kl km kn ko kp kq ja kr jb ks jd kt je ku jg kv jh kw kx dt translated">但是Onnx！</h1><p id="0c79" class="pw-post-body-paragraph jj jk hu jl b jm ky iv jo jp kz iy jr js la ju jv jw lb jy jz ka lc kc kd ke hn dt translated">Onnx试图恢复Tensorflow的优点，本质上是通过提供相同类型的独立、自包含的声明图。通过跟踪Python执行，可以从命令式模型中恢复这个静态图。这是一个非常酷和有前途的项目。</p><p id="99df" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是，它也受到与Tensorflow相同的限制。它不容易表示复杂的递归逻辑。这并不意味着调用任意的Python函数。您的图现在是静态的和声明性的，就像在TF中一样。</p><p id="084a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">好处是，您仍然可以在开发时使用命令式模型，并在调试后将其导出。你可以把它导出到像Caffe2这样可以在更多地方集成的框架中。从本质上来说，现有工具能发挥更大的作用。</p><p id="0a2e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">成本是，嗯，没有保证你的模型将出口，直到你尝试。它只能代表PyTorch模型的子集。因为PyTorch模型只是具有任意依赖性的任意代码，所以您通常无法提前知道导出是否会正确工作。你怎么知道导出是正确的？那是你的责任。</p><p id="1146" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">即使您的模型满足正确的属性，仍然有多个DL框架的复杂性，行为差异的机会，更多的版本需要调整。不是给我，尤其是在游戏的这个阶段。权衡。</p><h1 id="67ac" class="kg kh hu bd ki kj kk kl km kn ko kp kq ja kr jb ks jd kt je ku jg kv jh kw kx dt translated">权衡是永远的？</h1><p id="016c" class="pw-post-body-paragraph jj jk hu jl b jm ky iv jo jp kz iy jr js la ju jv jw lb jy jz ka lc kc kd ke hn dt translated">在设计良好的系统中，权衡可能是暂时的，因为缺失的部分堆积在基础之上。Onnx是一个很好的例子，说明如何继续协商权衡。Tensorflows即将推出的渴望模式是另一个例子。还有一个是XLA，Tensorflow正在填补“无依赖性”故事中的空白，以实现高效的定制操作，而没有携带用户创建的C++代码的环境负担。</p><p id="c6cf" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然而，这需要知道问题所在，不要陷入无望的方向。最重要的是，不要让粉丝主义使人对正在解决的问题视而不见。希望这篇文章能对这个方向有所贡献。</p></div></div>    
</body>
</html>