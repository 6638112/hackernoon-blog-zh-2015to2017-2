<html>
<head>
<title>Redux Patterns: Add/Edit/Remove Objects in an Array</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redux模式:添加/编辑/删除数组中的对象</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/redux-patterns-add-edit-remove-objects-in-an-array-6ee70cab2456?source=collection_archive---------0-----------------------#2016-12-29">https://medium.com/hackernoon/redux-patterns-add-edit-remove-objects-in-an-array-6ee70cab2456?source=collection_archive---------0-----------------------#2016-12-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="6efd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">更新</em>:在实践中，我越来越简化这个结构。不是因为它不好，而是因为它经常比我需要的解决方案更多。阅读更多信息:</p><div class="jq jr fm fo js jt"><a rel="noopener follow" target="_blank" href="/@justintulk/redux-patterns-rethinking-byid-and-byhash-structures-854e8a0fa32d"><div class="ju ab ej"><div class="jv ab jw cl cj jx"><h2 class="bd hv fv z el jy eo ep jz er et ht dt translated">冗余模式:反思“byId”和“byHash”结构</h2><div class="ka l"><h3 class="bd b fv z el jy eo ep jz er et ek translated">迭代Object.keys()并删除byId</h3></div><div class="kb l"><p class="bd b gc z el jy eo ep jz er et ek translated">medium.com</p></div></div></div></a></div></div><div class="ab cl kc kd hc ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hn ho hp hq hr"><p id="58c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae kj" rel="noopener" href="/@justintulk/implement-redux-as-vanilla-js-in-a-single-react-component-1492e9f06472#.n1ozvpm9d">前几天我写了一篇文章</a>关于如何在一个React组件中实现Redux风格的store和reducer，而不实际使用Redux。我没有在文章中写出逻辑，但是当我在JSBin中修改时，我使用了一种模式来更新数组中的对象，如下所示:</p><figure class="kk kl km kn fq ko"><div class="bz el l di"><div class="kp kq l"/></div></figure><p id="2697" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种方法的问题是，随着阵列大小的增长，每次更新时映射整个阵列会导致性能下降。此外，我们必须做一些额外的工作，以确保我们不会意外地在数组中为每个对象创建多个副本。</p><h2 id="067b" class="kr ks hu bd kt ku kv kw kx ky kz la lb jc lc ld le jg lf lg lh jk li lj lk ll dt translated">哈希表</h2><p id="cdf6" class="pw-post-body-paragraph ir is hu it b iu lm iw ix iy ln ja jb jc lo je jf jg lp ji jj jk lq jm jn jo hn dt translated">如果我们使用哈希表而不是数组来存储数据会怎么样？哈希表可用于使用键-值对将数组中的项目映射到对象，从而轻松避免重复并提高查找性能。但是，某些数组属性(如长度)将不会那么容易访问。为了绕过这个限制，我们将在<code class="eh lr ls lt lu b">state</code>中保留两个属性，一个是哈希数组，另一个是每个单独对象的哈希表。</p><pre class="kk kl km kn fq lv lu lw lx aw ly dt"><span id="116e" class="kr ks hu lu b fv lz ma l mb mc">const initialState = {<br/>  byId: [],<br/>  byHash: {}<br/>}</span></pre><p id="ec03" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每当我们通过reducer添加、编辑或更新一个对象时，我们将执行两个动作:一个将更新数组(如果必要的话),另一个将更新哈希表。</p><figure class="kk kl km kn fq ko"><div class="bz el l di"><div class="kp kq l"/></div></figure><p id="2a9d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">很快:在大规模运行时，一个更有效的减速器。如果我们在React视图中使用它来构建子组件列表，我们可以利用<code class="eh lr ls lt lu b">state</code>对象的两个部分来映射子组件，然后填充它们。</p><pre class="kk kl km kn fq lv lu lw lx aw ly dt"><span id="5997" class="kr ks hu lu b fv lz ma l mb mc">// assuming Redux passes in the state object as this.props.data</span><span id="9c8e" class="kr ks hu lu b fv md ma l mb mc">{this.props.data.byId.map((item, index) =&gt; (<br/>  &lt;div key={index}&gt;<br/>    {this.props.data.byHash[item].content.title}<br/>  &lt;/div&gt;<br/>)}</span></pre><p id="f49e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在一个实际的Redux示例中，可以通过组合两个独立的reducers来构建状态对象，以独立地作用于<code class="eh lr ls lt lu b">state</code>对象的<code class="eh lr ls lt lu b">byHash</code>和<code class="eh lr ls lt lu b">byId</code>属性，从而简化逻辑。</p></div><div class="ab cl kc kd hc ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hn ho hp hq hr"><p id="27d8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">完全披露:我不确定这是解决这个问题的最佳方式。如果你有更好的解决方案，或者可以链接到任何相关内容，请分享。</p><p id="a4e2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">注意:reducer逻辑应该确保</em> <code class="eh lr ls lt lu b"><em class="jp">state</em></code> <em class="jp">总是作为一个新对象返回，以确保React/Redux中的视图更新。在我写这篇博文的时候，我没有在视图中测试这段代码，所以可能有一两个语法错误，或者可能只是一些不必要的逻辑。请随时提出改进意见。</em></p><h1 id="7136" class="me ks hu bd kt mf mg mh kx mi mj mk lb ml mm mn le mo mp mq lh mr ms mt lk mu dt translated">有关系的</h1><div class="jq jr fm fo js jt"><a rel="noopener follow" target="_blank" href="/@justintulk/redux-patterns-caching-an-api-response-f85f8d8d73c6"><div class="ju ab ej"><div class="jv ab jw cl cj jx"><h2 class="bd hv fv z el jy eo ep jz er et ht dt translated">Redux模式:缓存API响应</h2><div class="ka l"><h3 class="bd b fv z el jy eo ep jz er et ek translated">避免重复调用稳定的数据</h3></div><div class="kb l"><p class="bd b gc z el jy eo ep jz er et ek translated">medium.com</p></div></div></div></a></div><div class="jq jr fm fo js jt"><a rel="noopener follow" target="_blank" href="/@justintulk/implement-redux-as-vanilla-js-in-a-single-react-component-1492e9f06472"><div class="ju ab ej"><div class="jv ab jw cl cj jx"><h2 class="bd hv fv z el jy eo ep jz er et ht dt translated">在单个React组件中将Redux实现为普通JS</h2><div class="ka l"><h3 class="bd b fv z el jy eo ep jz er et ek translated">我目前正在做一个项目，将一些React组件一点一点地修补到现有的ASP.NET版本中…</h3></div><div class="kb l"><p class="bd b gc z el jy eo ep jz er et ek translated">medium.com</p></div></div></div></a></div><figure class="kk kl km kn fq ko"><div class="bz el l di"><div class="mv kq l"/></div></figure></div></div>    
</body>
</html>