<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://medium.com/hackernoon/micro-services-and-fault-injection-testing-8a350e95b42e?source=collection_archive---------7-----------------------#2016-10-17">https://medium.com/hackernoon/micro-services-and-fault-injection-testing-8a350e95b42e?source=collection_archive---------7-----------------------#2016-10-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><h2 id="4e54" class="hs ht hu bd hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq dt translated">微服务和故障注入测试</h2><p id="24e0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb ie jc jd je ii jf jg jh im ji jj jk jl hn dt translated">随着微服务的发展，软件开发世界已经永远改变了。由于要维护的代码更少，要遵循的合同更清晰，并且能够独立地将组件推向生产，开发人员的生活变得容易多了。</p><p id="4eba" class="pw-post-body-paragraph ir is hu it b iu jm iw ix iy jn ja jb ie jo jd je ii jp jg jh im jq jj jk jl hn dt translated">有了更小的代码，它也带来了尝试新技术栈/架构模式的机会，例如基于异步消息的通信、基于JSON(Rest)的通信、内存缓存等等。</p><blockquote class="jr js jt"><p id="7386" class="ir is ju it b iu jm iw ix iy jn ja jb jv jo jd je jw jp jg jh jx jq jj jk jl hn dt translated">纵观所有这些，它描绘了一幅高度可用和可伸缩的企业软件将会是什么样子，以及它如何适应更快和更频繁地交付特性的敏捷方法。</p></blockquote><p id="33bf" class="pw-post-body-paragraph ir is hu it b iu jm iw ix iy jn ja jb ie jo jd je ii jp jg jh im jq jj jk jl hn dt translated">虽然大部分是真的，但是端到端特性的更快交付仍然暗示着大多数开发团队，即使在微服务领域，高可用性也不是免费的。</p><blockquote class="jr js jt"><p id="cbbd" class="ir is ju it b iu jm iw ix iy jn ja jb jv jo jd je jw jp jg jh jx jq jj jk jl hn dt translated">是什么阻止了团队更快地交付端到端特性？为什么可用性仍然是一个问题？让我们仔细看看。</p></blockquote><h2 id="9dac" class="hs ht hu bd hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq dt translated">发展不再是瓶颈了吗？</h2><p id="78b1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb ie jc jd je ii jf jg jh im ji jj jk jl hn dt translated">微服务和更新的技术栈承诺的是大大减少开发工作，它确实做到了。但是它是否也削减了sdlc阶段的其他部分？</p><p id="21cb" class="pw-post-body-paragraph ir is hu it b iu jm iw ix iy jn ja jb ie jo jd je ii jp jg jh im jq jj jk jl hn dt translated">虽然它简化了开发周期，但是微服务增加了监视、识别故障点和一般测试的大量开销。</p><h2 id="eb4f" class="hs ht hu bd hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq dt translated">微服务领域的测试挑战</h2><ul class=""><li id="6454" class="jy jz hu it b iu iv iy iz ie ka ii kb im kc jl kd ke kf kg dt translated"><strong class="it kh">环境设置</strong></li></ul><p id="6e3f" class="pw-post-body-paragraph ir is hu it b iu jm iw ix iy jn ja jb ie jo jd je ii jp jg jh im jq jj jk jl hn dt translated">每个服务现在都有几个依赖项。其中一些是直接依赖，许多是可传递的。每个团队都在不断增加新的功能，这反过来又为上游客户增加了新的依赖性。留意别人的世界几乎是不可能的。因此，第一个挑战是建立一个具有所有依赖关系的环境，在这个环境中可以运行功能性的端到端测试用例。在许多情况下，所有这些服务都可以在一台机器上运行。在这种情况下，生活还是很容易控制的。有时，由于许多底层基础设施的问题，所有这些服务可能不会在同一个机器上运行，例如，多个服务侦听同一个端口，一个机器上处理太多服务，相互冲突的依赖关系(Java 1.7与Java 1.8)。</p><p id="42e1" class="pw-post-body-paragraph ir is hu it b iu jm iw ix iy jn ja jb ie jo jd je ii jp jg jh im jq jj jk jl hn dt translated">我们拥有的服务越来越多，陷入这种混乱的可能性就越来越大。</p><ul class=""><li id="6364" class="jy jz hu it b iu jm iy jn ie ki ii kj im kk jl kd ke kf kg dt translated"><strong class="it kh">负面/弹性测试和故障注入</strong></li></ul><p id="9ca8" class="pw-post-body-paragraph ir is hu it b iu jm iw ix iy jn ja jb ie jo jd je ii jp jg jh im jq jj jk jl hn dt translated">系统的弹性来自于这样一个事实，即系统的每个部分都能够处理至少一些合理级别的错误和故障。无论是下游服务不可用、网络延迟、缓存问题还是数据库问题；分布式系统充满了这种隐含的非功能性需求和相应的处理。</p><p id="cd42" class="pw-post-body-paragraph ir is hu it b iu jm iw ix iy jn ja jb ie jo jd je ii jp jg jh im jq jj jk jl hn dt translated">直到我们做了一定程度的否定/容错测试，我们的测试才能完成。</p><p id="6408" class="pw-post-body-paragraph ir is hu it b iu jm iw ix iy jn ja jb ie jo jd je ii jp jg jh im jq jj jk jl hn dt translated">为此设置环境更加困难。考虑到数百个测试需要不同级别的错误，并且每个设置需要一大堆盒子，这里的场景看起来相当可怕。毫不夸张地说，许多团队/公司实际上没有进行大规模测试的设置。</p><h2 id="fe97" class="hs ht hu bd hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq dt translated">支持故障注入的集中式测试环境</h2><p id="b44d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb ie jc jd je ii jf jg jh im ji jj jk jl hn dt translated">我们将要讨论的方法是添加一个智能路由组件/代理层，它可以检查请求并将其转发给正确的服务，如果需要，还可以在测试期间注入所需的故障。</p><p id="c3c0" class="pw-post-body-paragraph ir is hu it b iu jm iw ix iy jn ja jb ie jo jd je ii jp jg jh im jq jj jk jl hn dt translated">我们可以运行同一个组件的多个实例，以确保测试基础设施的高可用性。</p><p id="d3e5" class="pw-post-body-paragraph ir is hu it b iu jm iw ix iy jn ja jb ie jo jd je ii jp jg jh im jq jj jk jl hn dt translated">为了简单起见，假设我们有3个服务为不同的实体提供restful端点。服务A监听端口A，下游依赖于服务B监听端口B，而服务B又依赖于服务c监听端口c。</p><p id="8b0f" class="pw-post-body-paragraph ir is hu it b iu jm iw ix iy jn ja jb ie jo jd je ii jp jg jh im jq jj jk jl hn dt translated">让我们假设我们有一个公共的头请求id，它将标识整个请求流，并将在所有下游/侧流服务调用中传递。</p><h2 id="be0e" class="hs ht hu bd hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq dt translated">测试设置</h2><figure class="km kn ko kp fq kq fe ff paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="fe ff kl"><img src="../Images/f47e1545520825eba10fde72d27102ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PwaX4_VX5utTQ4gv_Dk3Ig.png"/></div></div><figcaption class="kx ky fg fe ff kz la bd b be z ek">Test Setup with Proxy layer handling proxying and fault injection</figcaption></figure><h2 id="6cd5" class="hs ht hu bd hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq dt translated">路由/代理组件</h2><p id="9fd6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb ie jc jd je ii jf jg jh im ji jj jk jl hn dt translated">我们可以使用nginx+lua来设置代理层。</p><p id="b38a" class="pw-post-body-paragraph ir is hu it b iu jm iw ix iy jn ja jb ie jo jd je ii jp jg jh im jq jj jk jl hn dt translated">你可以在这里阅读更多关于nginx和lua的内容:</p><div class="lb lc fm fo ld le"><a href="https://blog.cloudflare.com/pushing-nginx-to-its-limit-with-lua/" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab ej"><div class="lg ab lh cl cj li"><h2 class="bd kh fv z el lj eo ep lk er et ll dt translated">用Lua将Nginx推向极限</h2><div class="lm l"><h3 class="bd b fv z el lj eo ep lk er et ek translated">在CloudFlare，Nginx是我们工作的核心。这是我们反向代理服务基础的一部分…</h3></div><div class="ln l"><p class="bd b gc z el lj eo ep lk er et ek translated">blog.cloudflare.com</p></div></div><div class="lo l"><div class="lp l lq lr ls lo lt kv le"/></div></div></a></div><div class="lb lc fm fo ld le"><a href="https://openresty.org/en/" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab ej"><div class="lg ab lh cl cj li"><h2 class="bd kh fv z el lj eo ep lk er et ll dt translated">OpenResty -官方网站</h2><div class="lm l"><h3 class="bd b fv z el lj eo ep lk er et ek translated">OpenResty不是Nginx分支。它只是一个软件包。大多数应用于Nginx核心的补丁…</h3></div><div class="ln l"><p class="bd b gc z el lj eo ep lk er et ek translated">openresty.org</p></div></div><div class="lo l"><div class="lu l lq lr ls lo lt kv le"/></div></div></a></div><p id="d247" class="pw-post-body-paragraph ir is hu it b iu jm iw ix iy jn ja jb ie jo jd je ii jp jg jh im jq jj jk jl hn dt translated"><a class="ae lv" href="http://www.staticshin.com/programming/definitely-an-open-resty-guide/" rel="noopener ugc nofollow" target="_blank">http://www . static shin . com/programming/definitely-an-open-resty-guide/</a></p><p id="80de" class="pw-post-body-paragraph ir is hu it b iu jm iw ix iy jn ja jb ie jo jd je ii jp jg jh im jq jj jk jl hn dt translated">我们将使用openresty来实现代理。</p><p id="2ae3" class="pw-post-body-paragraph ir is hu it b iu jm iw ix iy jn ja jb ie jo jd je ii jp jg jh im jq jj jk jl hn dt translated">对代理的要求:</p><ol class=""><li id="2945" class="jy jz hu it b iu jm iy jn ie ki ii kj im kk jl lw ke kf kg dt translated">将请求负载平衡到不同的上游。我们可以运行多个服务实例，并且我们可以路由服务的传入请求，以使用多个实例中的一个。</li><li id="2dd5" class="jy jz hu it b iu lx iy ly ie lz ii ma im mb jl lw ke kf kg dt translated">每请求故障注入。Request-id可用于确定和注入必要的故障。</li></ol><h2 id="3092" class="hs ht hu bd hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq dt translated">负载平衡</h2><p id="3970" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb ie jc jd je ii jf jg jh im ji jj jk jl hn dt translated">我们可以使用Redis来存储服务和主机映射。对于特定服务的每个请求，我们的Lua代码可以从Redis获取上游细节，并以循环方式转发请求。</p><p id="009b" class="pw-post-body-paragraph ir is hu it b iu jm iw ix iy jn ja jb ie jo jd je ii jp jg jh im jq jj jk jl hn dt translated">redis条目示例:</p><blockquote class="jr js jt"><p id="68cb" class="ir is ju it b iu jm iw ix iy jn ja jb jv jo jd je jw jp jg jh jx jq jj jk jl hn dt translated">Redis键:服务发现</p><p id="b912" class="ir is ju it b iu jm iw ix iy jn ja jb jv jo jd je jw jp jg jh jx jq jj jk jl hn dt translated">子密钥:9001</p><p id="63da" class="ir is ju it b iu jm iw ix iy jn ja jb jv jo jd je jw jp jg jh jx jq jj jk jl hn dt translated">值:服务器1，服务器2</p></blockquote><h2 id="4693" class="hs ht hu bd hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq dt translated">故障注入</h2><p id="cc71" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb ie jc jd je ii jf jg jh im ji jj jk jl hn dt translated">基本方法:在测试设置步骤中，生成一个请求id，并将所需的故障细节存储在路由层可以访问的共享位置。路由层在接收到请求后，检查request-id并对照Redis检查即时服务调用中是否需要任何故障注入。如果不是，那么它像先前一样继续，否则，它分析存储的故障信息并相应地作出响应。</p><p id="6924" class="pw-post-body-paragraph ir is hu it b iu jm iw ix iy jn ja jb ie jo jd je ii jp jg jh im jq jj jk jl hn dt translated">格式如下所示:</p><blockquote class="jr js jt"><p id="b69b" class="ir is ju it b iu jm iw ix iy jn ja jb jv jo jd je jw jp jg jh jx jq jj jk jl hn dt translated">Redis键:faultinjection</p><p id="151f" class="ir is ju it b iu jm iw ix iy jn ja jb jv jo jd je jw jp jg jh jx jq jj jk jl hn dt translated">子关键字:request_f7a7bb674caec</p><p id="6830" class="ir is ju it b iu jm iw ix iy jn ja jb jv jo jd je jw jp jg jh jx jq jj jk jl hn dt translated">" {\ "降价\":{\"uri\":[\ "用户\"]}，\ "延迟\":{\ "书籍\ ":\ " 10 \ " } } "；</p></blockquote><ol class=""><li id="146f" class="jy jz hu it b iu jm iy jn ie ki ii kj im kk jl lw ke kf kg dt translated">下游故障:我们可以有指示说markdown，这将有效地导致一个500当流试图击中特定的服务。</li><li id="f470" class="jy jz hu it b iu lx iy ly ie lz ii ma im mb jl lw ke kf kg dt translated">延迟响应:我们可以有像Delayed这样的指令，它会将响应延迟给定的时间，以秒为单位。</li><li id="11e4" class="jy jz hu it b iu lx iy ly ie lz ii ma im mb jl lw ke kf kg dt translated">模拟/失败响应:我们还可以用来自服务的模拟假响应填充信息。对于难以在下游系统中复制故障场景，这对于可预测的结果很有用。</li><li id="38b0" class="jy jz hu it b iu lx iy ly ie lz ii ma im mb jl lw ke kf kg dt translated">事实上，我们可以增强这一点，也做记录/回放组件测试。所有下游依赖项都可以很容易地模仿出来。</li></ol><p id="07c4" class="pw-post-body-paragraph ir is hu it b iu jm iw ix iy jn ja jb ie jo jd je ii jp jg jh im jq jj jk jl hn dt translated"><strong class="it kh">样本代码:</strong></p><p id="95bc" class="pw-post-body-paragraph ir is hu it b iu jm iw ix iy jn ja jb ie jo jd je ii jp jg jh im jq jj jk jl hn dt translated"><strong class="it kh">负载均衡:</strong></p><figure class="km kn ko kp fq kq"><div class="bz el l di"><div class="mc md l"/></div></figure><p id="80b7" class="pw-post-body-paragraph ir is hu it b iu jm iw ix iy jn ja jb ie jo jd je ii jp jg jh im jq jj jk jl hn dt translated"><strong class="it kh">故障注入:</strong></p><figure class="km kn ko kp fq kq"><div class="bz el l di"><div class="mc md l"/></div></figure><p id="a12d" class="pw-post-body-paragraph ir is hu it b iu jm iw ix iy jn ja jb ie jo jd je ii jp jg jh im jq jj jk jl hn dt translated"><strong class="it kh">Githublink:</strong><a class="ae lv" href="https://github.com/Mitendra/fault_injection_proxy" rel="noopener ugc nofollow" target="_blank">https://github.com/Mitendra/fault_injection_proxy</a></p><div class="km kn ko kp fq ab cb"><figure class="me kq mf mg mh mi mj paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="me kq mf mg mh mi mj paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="me kq mf mg mh mi mj paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="jr js jt"><p id="f922" class="ir is ju it b iu jm iw ix iy jn ja jb jv jo jd je jw jp jg jh jx jq jj jk jl hn dt translated"><a class="ae lv" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是阿妹家庭的一员。我们现在<a class="ae lv" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae lv" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is ju it b iu jm iw ix iy jn ja jb jv jo jd je jw jp jg jh jx jq jj jk jl hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lv" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lv" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="km kn ko kp fq kq fe ff paragraph-image"><a href="https://goo.gl/Ahtev1"><div class="fe ff mk"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></a></figure></div></div>    
</body>
</html>