<html>
<head>
<title>Machine Learning for Android Developers with the Mobile Vision API — Part 2— Barcode Detection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用移动视觉API的Android开发人员的机器学习—第2部分—条形码检测</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/machine-learning-for-android-developers-with-the-mobile-vision-api-part-2-barcode-detection-61e84c858518?source=collection_archive---------1-----------------------#2016-10-25">https://medium.com/hackernoon/machine-learning-for-android-developers-with-the-mobile-vision-api-part-2-barcode-detection-61e84c858518?source=collection_archive---------1-----------------------#2016-10-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="4109" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我最近开始用移动视觉API为<a class="ae jp" href="https://hackernoon.com/tagged/android" rel="noopener ugc nofollow" target="_blank"> Android </a>开发者探索机器<a class="ae jp" href="https://hackernoon.com/tagged/learning" rel="noopener ugc nofollow" target="_blank">学习</a>。我<a class="ae jp" href="https://hackernoon.com/machine-learning-for-android-developers-with-the-mobile-vision-api-part-1-face-detection-e7e24a3e472f#.sc2kfcbai" rel="noopener ugc nofollow" target="_blank">在本系列的第一篇文章中写了关于人脸检测API </a>的文章，我将在本文中继续讨论条形码检测API。</p><h1 id="464b" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">条形码检测API</h1><p id="811b" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">条形码检测API用于在设备(本例中为Android设备)上以任何方向本地处理条形码<strong class="it hv">。根据<a class="ae jp" href="https://developers.google.com/vision/barcodes-overview" rel="noopener ugc nofollow" target="_blank">条形码API概述</a>，有两种主要的条形码格式；1D和2D格式。大多数可用的条形码都可以归类为这些格式。API允许读取两种不同的条形码格式，并自动解析它们的值。1D条形码包含嵌入在条形码中的数字，而2D条形码包含结构化数据，可包括URL、联系信息、日历事件、电子邮件、手机短信、ISBN、WiFi、地理位置和AAMVA驾照/ID。</strong></p><h1 id="1e34" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">入门指南</h1><p id="3320" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在本文中，就像第一篇文章一样，我们将浏览创建一个非常基本的应用程序的过程，该应用程序使用条形码检测API解析预加载的图像以获取信息。<a class="ae jp" href="https://github.com/moyheen/barcode-detector" rel="noopener ugc nofollow" target="_blank">代码在Github </a>上，尽管这个初始版本不包含测试或遵循任何特定的架构。还没有。</p><p id="8fdc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">开始了…</p><ul class=""><li id="f254" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">在Android Studio中创建新项目。</li><li id="4324" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">将用于移动视觉API的Google Play Services SDK导入到您的应用程序级build.gradle文件中。在撰写本文时，最新版本是9.8.00。像往常一样，如果您导入整个SDK而不是您需要的特定SDK(play-services-vision ),您肯定会达到65k的方法限制。</li></ul><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="88d5" class="lq jr hu lm b fv lr ls l lt lu">compile 'com.google.android.gms:play-services-vision:9.8.00'</span></pre><ul class=""><li id="eef2" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">要为条形码检测自动安装视觉依赖项，请将此元数据添加到清单文件中。这确保了首次使用该应用程序的用户能够及时下载适当的库。</li></ul><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="e7e6" class="lq jr hu lm b fv lr ls l lt lu">&lt;meta-data<br/>    android:name="com.google.android.gms.vision.DEPENDENCIES"<br/>    android:value="<strong class="lm hv">barcode</strong>"/&gt;</span></pre><ul class=""><li id="aca2" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">我们将创建一个非常简单的布局，由一个<em class="lv">按钮</em>、一个<em class="lv">图像视图</em>和一个<em class="lv">文本视图</em>组成。<em class="lv"> ImageView </em>显示drawable文件夹中的条形码(这只是出于本教程的目的。现实生活中的场景最有可能涉及通过设备摄像头检测条形码)。该按钮启动图像处理，而<em class="lv"> TextView </em>显示从图像中获取的任何数据。</li><li id="185f" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">像人脸检测API一样，图像必须被转换成位图<em class="lv">才能被处理。但是与人脸检测API不同，不需要使<em class="lv">位图</em>可变(至少在本文中),因为我们在这里想要做的只是在另一个视图中显示条形码的日期。</em></li></ul><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="befb" class="lq jr hu lm b fv lr ls l lt lu">Bitmap barcodeBitmap = BitmapFactory.<em class="lv">decodeResource</em>(getResources(), R.drawable.barcode_image);</span></pre><p id="37f5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如前所述，点击按钮开始处理<em class="lv">图像视图</em>中的条形码。我们将继续使用条形码检测API来实现这一点。我们可以设置希望API关注的条形码格式。这可以包括1D或2D格式中的任何一种。您可以拥有任意多种格式，例如(条形码。<em class="lv">短信</em> |条形码。<em class="lv">驾驶证</em> |条形码。国际标准书号)但是为了涵盖本文中的所有内容，我们将只关注所有的格式。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="4b6e" class="lq jr hu lm b fv lr ls l lt lu">BarcodeDetector barcodeDetector = new BarcodeDetector.Builder(this)<br/>        .setBarcodeFormats(<strong class="lm hv">Barcode.<em class="lv">ALL_FORMATS</em></strong>)<br/>        .build();</span></pre><ul class=""><li id="a6b1" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">接下来，我们需要检查条形码检测器是否已经运行。总有可能第一次不会成功，因为需要将一个库下载到设备上，而它可能没有及时完成供使用。</li></ul><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="38f6" class="lq jr hu lm b fv lr ls l lt lu">if (!barcodeDetector.isOperational()) {<br/>    new AlertDialog.Builder(this)<br/>            .setMessage("Barcode detector could not be set up on your device :(")<br/>            .show();<br/>    return;<br/>}</span></pre><ul class=""><li id="e722" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">然后，我们使用条形码位图创建一个帧，并调用条形码检测器。</li></ul><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="9e4d" class="lq jr hu lm b fv lr ls l lt lu">Frame frame = new Frame.Builder().setBitmap(barcodeBitmap).build();<br/>SparseArray&lt;Barcode&gt; barcode = barcodeDetector.detect(frame);</span></pre><ul class=""><li id="bb4d" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">我们的结果现在包含在稀疏数组中。数组可以是空的，也可以包含值，这取决于解析的成功程度，或者图像中是否有条形码。更安全的做法是执行检查来捕捉这样的错误。下一步是让UI准备好显示数组中的值。在真正的应用程序中，我可能会在RecyclerView中显示结果，或者通过编程添加更多的TextViews。我在这里做的只是在一个TextView中显示所有的值。</li></ul><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="2895" class="lq jr hu lm b fv lr ls l lt lu">if (size == 0) {<br/>    textView.setText("No information available");<br/>} else {<br/>    for (int i = 0; i &lt; size; i++) {<br/>        barcodeValue += (barcode.valueAt(i).displayValue + "\n");<br/>    }<br/>    textView.setText(barcodeValue);<br/>}</span></pre><ul class=""><li id="149a" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">作为优秀的Android公民，我们还应该记得在交易完成后释放条形码检测器。</li></ul><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="3a97" class="lq jr hu lm b fv lr ls l lt lu">barcodeDetector.release();</span></pre><figure class="lh li lj lk fq lw"><div class="bz el l di"><div class="lx ly l"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Go on ahead and find out what’s embedded in this barcode. I believe in you! :D</figcaption></figure><p id="f37f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是这篇文章的全部内容，但我只是略略涉猎了一下。可以通过设备的摄像头而不是默认图像来检测条形码。您可以在一个图像中放置多个条形码，让您的应用程序检测它们，即使它们是颠倒的。你可以解析驾照，允许人们自动连接到你的WiFi，交换名片，这些都是通过这个API实现的。这篇文章的代码是Github上的<a class="ae jp" href="https://github.com/moyheen/barcode-detector" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><p id="7ba2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你想出了更酷的方法来使用这个API，请在下面留下评论。</p><p id="68fe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">参考资料:</p><div class="md me fm fo mf mg"><a href="https://developers.google.com/vision/multi-tracker-tutorial" rel="noopener  ugc nofollow" target="_blank"><div class="mh ab ej"><div class="mi ab mj cl cj mk"><h2 class="bd hv fv z el ml eo ep mm er et ht dt translated">跟踪人脸和条形码|移动视觉|谷歌开发者</h2><div class="mn l"><h3 class="bd b fv z el ml eo ep mm er et ek translated">本页演示了如何构建一个使用后置摄像头来显示检测到的人脸视图的应用程序…</h3></div><div class="mo l"><p class="bd b gc z el ml eo ep mm er et ek translated">developers.google.com</p></div></div><div class="mp l"><div class="mq l mr ms mt mp mu mv mg"/></div></div></a></div><div class="md me fm fo mf mg"><a href="https://codelabs.developers.google.com/codelabs/bar-codes/#0" rel="noopener  ugc nofollow" target="_blank"><div class="mh ab ej"><div class="mi ab mj cl cj mk"><h2 class="bd hv fv z el ml eo ep mm er et ht dt translated">使用移动视觉API进行条形码检测</h2><div class="mn l"><h3 class="bd b fv z el ml eo ep mm er et ek translated">随着Google Play services 7.8的发布，我们很高兴地宣布，我们已经添加了新的移动视觉APIs</h3></div><div class="mo l"><p class="bd b gc z el ml eo ep mm er et ek translated">codelabs.developers.google.com</p></div></div><div class="mp l"><div class="mw l mr ms mt mp mu mv mg"/></div></div></a></div><div class="md me fm fo mf mg"><a href="https://github.com/moyheen/barcode-detector" rel="noopener  ugc nofollow" target="_blank"><div class="mh ab ej"><div class="mi ab mj cl cj mk"><h2 class="bd hv fv z el ml eo ep mm er et ht dt translated">moyheen/条形码检测器</h2><div class="mn l"><h3 class="bd b fv z el ml eo ep mm er et ek translated">这个应用程序包含了我的文章中关于条形码检测器API的所有代码。https:…</h3></div><div class="mo l"><p class="bd b gc z el ml eo ep mm er et ek translated">github.com</p></div></div><div class="mp l"><div class="mx l mr ms mt mp mu mv mg"/></div></div></a></div><p id="7cfc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="lv">以为这就了不起了？请不要忘记“推荐”和“分享”。</em>T3】</strong></p><div class="lh li lj lk fq ab cb"><figure class="my lw mz na nb nc nd paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="my lw mz na nb nc nd paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="my lw mz na nb nc nd paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="nf ng nh"><p id="f922" class="ir is lv it b iu iv iw ix iy iz ja jb ni jd je jf nj jh ji jj nk jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is lv it b iu iv iw ix iy iz ja jb ni jd je jf nj jh ji jj nk jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lh li lj lk fq lw fe ff paragraph-image"><a href="https://goo.gl/Ahtev1"><div class="fe ff nl"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></a></figure><figure class="lh li lj lk fq lw"><div class="bz el l di"><div class="nm ly l"/></div></figure></div></div>    
</body>
</html>