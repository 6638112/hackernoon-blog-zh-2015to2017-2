<html>
<head>
<title>Understanding JavaScript: This Keyword</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript:这个关键字</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/understanding-javascript-the-this-keyword-4de325d77f68?source=collection_archive---------2-----------------------#2017-06-25">https://medium.com/hackernoon/understanding-javascript-the-this-keyword-4de325d77f68?source=collection_archive---------2-----------------------#2017-06-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/0583900272135e3efed3c87ca9f57fbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZsggKi3Tr5g1Widl3nLoFg.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="http://www.tedxhsg.org/program-2/#program" rel="noopener ugc nofollow" target="_blank">Photo credit</a></figcaption></figure><p id="f4c4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">由于数量惊人的库、工具和各种各样的东西使你的开发变得更容易，许多程序员在没有深入了解某些东西如何工作的情况下就开始构建应用程序。JavaScript就是这种行为的典型代表。虽然它是最复杂和传播最广的语言之一，但许多开发人员被吸引到使用更高级的工具和抽象掉语言的“不好的部分”。</p><p id="daca" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">虽然您仍然能够构建令人惊叹的应用程序，但是进入JavaScript maelstrom对您非常有益。理解“奇怪的部分”是普通普通程序员和高级开发人员的区别，虽然JS生态系统是不断变化的，但基础是所有其他工具构建的基础。理解这些会给你一个更广阔的视野，并改变你看待开发过程的方式。</p><p id="d110" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">另一个引起大量讨论的话题是<strong class="jj hv">这个</strong>关键字。更具体地说，这是有时意想不到的行为。大约一年前，我的一个同事让我看一下她的JS代码，因为她有奇怪的错误。作为一名刚开始接触JavaScript的Java开发人员，她犯了一个错误，认为自己在真正学习之前就能理解这门语言——就像许多人一样。</p><p id="bac7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有多少其他进入JS的开发者对<strong class="jj hv">这个</strong>有问题，我不知道，但我预计这个数字会很高。事实上，这可能是你必须理解的最简单的JavaScript概念。如果要我用自己的话来解释，我可能会说出这样的话:</p><blockquote class="kf"><p id="b0fc" class="kg kh hu bd ki kj kk kl km kn ko ke ek translated">this关键字不涉及使用它的函数或它的作用域。它指的是一个函数正在其上执行的对象，并且完全依赖于该函数的调用点。</p></blockquote><p id="2c40" class="pw-post-body-paragraph jh ji hu jj b jk kp jm jn jo kq jq jr js kr ju jv jw ks jy jz ka kt kc kd ke hn dt translated">让我们创建一个非常基本的例子来说明这是怎么回事:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="fbc3" class="ld le hu kz b fv lf lg l lh li">function testThisKeyword() {<br/>    console.log(this) // [object Window]<br/>}</span><span id="6d50" class="ld le hu kz b fv lj lg l lh li">testThisKeyword()</span></pre><p id="51fe" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我给你另一个更能质疑你对JavaScript理解的问题:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="b741" class="ld le hu kz b fv lf lg l lh li">function testThisKeyword() { <br/>    console.log(this.name) // Alex<br/>}</span><span id="56de" class="ld le hu kz b fv lj lg l lh li">var name = 'Alex'<br/>testThisKeyword()</span></pre><p id="bf74" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">什么？那到底是怎么输入名字变量的呢？它甚至不是在函数的范围内创建的！这是开发人员感到非常难过的原因之一。它只是不像你期望的那样工作。与普遍的看法相反，地下并没有黑魔法。这里发生的事情是，name变量是在全局对象中声明的，因此它可以作为它的一个属性被访问。如果我们看看函数的调用点，我们会发现我们并没有在一个对象上隐式调用它，所以这将引用全局对象。</p><p id="a255" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">这个</strong>关键字在每个函数的范围内自动定义，它的绑定以三种方式发生——<strong class="jj hv">默认</strong>、<strong class="jj hv">隐式</strong>和<strong class="jj hv">显式</strong>。独立函数调用的例子已经向您展示了<strong class="jj hv">默认绑定</strong>是如何工作的。需要记住的是，如果没有指定另一个绑定，这就是后备绑定。让我们更详细地了解一下<strong class="jj hv">隐式</strong>和<strong class="jj hv">显式</strong>绑定。</p><h1 id="5aaf" class="lk le hu bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg dt translated">隐式结合</h1><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="3fc1" class="ld le hu kz b fv lf lg l lh li">const person = {<br/>  name: 'Alex',<br/>  greet() {<br/>    console.log('Hey my name is ' + this.name)<br/>  }<br/>}</span><span id="2648" class="ld le hu kz b fv lj lg l lh li">person.greet() // Hey my name is Alex</span></pre><p id="4922" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了理解它的值，你需要看看它在哪里被调用。<strong class="jj hv">不是使用它的函数，而是调用点。在本例中，所有者或包含对象是person对象。我喜欢用的一个技巧是看函数调用的左边。站在点之前的对象就是this关键字将要绑定的对象。</strong></p><p id="6521" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">需要记住的是，如果您开始将函数作为引用传递，这种绑定可能会“丢失”。即使你引用的函数是一个对象的属性，如果你单独调用它，它也不会有你期望的绑定，而是使用默认绑定。这就是为什么对于<strong class="jj hv">这个</strong>唯一重要的是函数的<strong class="jj hv">调用点</strong>。一个更好更深入的例子可以在Kyle Simpson关于这个和对象原型的书中找到，所以我在这里就不赘述了。</p><h1 id="304f" class="lk le hu bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg dt translated">显式绑定</h1><p id="b864" class="pw-post-body-paragraph jh ji hu jj b jk mi jm jn jo mj jq jr js mk ju jv jw ml jy jz ka mm kc kd ke hn dt translated">在隐式绑定的例子中，我们必须使用一个所有者对象来实现我们想要的绑定。但是如果我们不想引用对象上的函数，或者我们不能改变它，该怎么办呢？有一个解决方案可以明确地告诉一个函数它应该为此使用什么对象——使用诸如<strong class="jj hv">调用、应用</strong>和<strong class="jj hv">绑定</strong>之类的函数。使用显式绑定是如此普遍，以至于这两个函数都可以从函数原型中获得，但是它们之间存在差异。</p><p id="88e9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">调用</strong>函数允许你传入<strong class="jj hv">这个</strong>关键字应该绑定到的对象。它还允许您将函数的参数作为附加参数传递。</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="02b5" class="ld le hu kz b fv lf lg l lh li">function greet() {<br/>    console.log( this.name );<br/>}<br/><br/>var person = {<br/>    name: 'Alex'<br/>};<br/><br/>greet.call( person, arg1, arg2, arg3, ... ); // Alex</span></pre><p id="e815" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">应用</strong>函数类似于<strong class="jj hv">调用</strong>，不同之处在于函数参数是作为数组或类数组对象传递的。</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="0ded" class="ld le hu kz b fv lf lg l lh li">function greet() {<br/>    console.log( this.name );<br/>}<br/><br/>var person = {<br/>    name: 'Alex'<br/>};<br/><br/>greet.apply( person, [args]); // Alex</span></pre><p id="0ebd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">绑定</strong>函数与前两个略有不同。它<strong class="jj hv">创建一个新的</strong>函数，该函数将调用原来的函数，而<strong class="jj hv">这个</strong>绑定到传入的任何内容。</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="bd3c" class="ld le hu kz b fv lf lg l lh li">function greet() {<br/>    console.log( this.name );<br/>}<br/><br/>var person = {<br/>    name: 'Alex'<br/>};<br/><br/>var greetPerson = greet.bind( person );<br/>greetPerson(); // Alex</span></pre><p id="e1e2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在文章的前面，我告诉过你这些是关键字的主要绑定。我可能骗了你，因为当你使用<strong class="jj hv"> new </strong>关键字时，也发生了绑定。然而，我打算写一篇关于这个的小文章，所以我现在跳过解释。</p><p id="6e1d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你对更多的JS相关内容感兴趣，你可以从<a class="ae jg" href="https://buttondown.email/kondov" rel="noopener ugc nofollow" target="_blank"> <strong class="jj hv"> <em class="mh">这里</em> </strong> </a>订阅我的时事通讯，或者你可以看看同一系列的其他文章:</p><div class="mn mo fm fo mp mq"><a href="https://hackernoon.com/understanding-javascript-scope-1d4a74adcdf5" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab ej"><div class="ms ab mt cl cj mu"><h2 class="bd hv fv z el mv eo ep mw er et ht dt translated">理解JavaScript:范围</h2><div class="mx l"><h3 class="bd b fv z el mv eo ep mw er et ek translated">由于数量惊人的库、工具和各种各样的东西使你的开发更容易，很多…</h3></div><div class="my l"><p class="bd b gc z el mv eo ep mw er et ek translated">hackernoon.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne ja mq"/></div></div></a></div><div class="mn mo fm fo mp mq"><a href="https://hackernoon.com/understanding-javascript-prototype-and-inheritance-d55a9a23bde2" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab ej"><div class="ms ab mt cl cj mu"><h2 class="bd hv fv z el mv eo ep mw er et ht dt translated">理解JavaScript:原型和继承</h2><div class="mx l"><h3 class="bd b fv z el mv eo ep mw er et ek translated">由于数量惊人的库、工具和各种各样的东西使你的开发更容易，很多…</h3></div><div class="my l"><p class="bd b gc z el mv eo ep mw er et ek translated">hackernoon.com</p></div></div><div class="mz l"><div class="nf l nb nc nd mz ne ja mq"/></div></div></a></div><div class="mn mo fm fo mp mq"><a href="https://hackernoon.com/understanding-javascript-the-this-keyword-4de325d77f68" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab ej"><div class="ms ab mt cl cj mu"><h2 class="bd hv fv z el mv eo ep mw er et ht dt translated">理解JavaScript:这个关键字</h2><div class="mx l"><h3 class="bd b fv z el mv eo ep mw er et ek translated">由于数量惊人的库、工具和各种各样的东西使你的开发更容易，很多…</h3></div><div class="my l"><p class="bd b gc z el mv eo ep mw er et ek translated">hackernoon.com</p></div></div><div class="mz l"><div class="ng l nb nc nd mz ne ja mq"/></div></div></a></div><div class="mn mo fm fo mp mq"><a href="https://hackernoon.com/understanding-javascript-new-keyword-ec67c8caaa74" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab ej"><div class="ms ab mt cl cj mu"><h2 class="bd hv fv z el mv eo ep mw er et ht dt translated">理解JavaScript:新关键字</h2><div class="mx l"><h3 class="bd b fv z el mv eo ep mw er et ek translated">由于数量惊人的库、工具和各种各样的东西使你的开发更容易，很多…</h3></div><div class="my l"><p class="bd b gc z el mv eo ep mw er et ek translated">hackernoon.com</p></div></div><div class="mz l"><div class="nh l nb nc nd mz ne ja mq"/></div></div></a></div><div class="mn mo fm fo mp mq"><a href="https://hackernoon.com/understanding-js-coercion-ff5684475bfc" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab ej"><div class="ms ab mt cl cj mu"><h2 class="bd hv fv z el mv eo ep mw er et ht dt translated">理解JS:强制</h2><div class="mx l"><h3 class="bd b fv z el mv eo ep mw er et ek translated">由于数量惊人的库、工具和各种各样的东西使你的开发更容易，很多…</h3></div><div class="my l"><p class="bd b gc z el mv eo ep mw er et ek translated">hackernoon.com</p></div></div><div class="mz l"><div class="ni l nb nc nd mz ne ja mq"/></div></div></a></div><div class="mn mo fm fo mp mq"><a href="https://hackernoon.com/understanding-js-the-event-loop-959beae3ac40" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab ej"><div class="ms ab mt cl cj mu"><h2 class="bd hv fv z el mv eo ep mw er et ht dt translated">理解JS:事件循环</h2><div class="mx l"><h3 class="bd b fv z el mv eo ep mw er et ek translated">由于数量惊人的库、工具和各种各样的东西使你的开发更容易，很多…</h3></div><div class="my l"><p class="bd b gc z el mv eo ep mw er et ek translated">hackernoon.com</p></div></div><div class="mz l"><div class="nj l nb nc nd mz ne ja mq"/></div></div></a></div></div></div>    
</body>
</html>