<html>
<head>
<title>Replacing the angular 1 router with Elm — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Elm替换angular 1路由器—第2部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/replacing-the-angular-1-router-with-elm-part-2-bf9c84934abf?source=collection_archive---------23-----------------------#2017-01-11">https://medium.com/hackernoon/replacing-the-angular-1-router-with-elm-part-2-bf9c84934abf?source=collection_archive---------23-----------------------#2017-01-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="7e80" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是<a class="ae jp" rel="noopener" href="/@julianjelfs_61852/replacing-the-angular-1-router-with-elm-d71753e74e32#.2fd4y8xip">第一部分</a>的后续帖子。</p><p id="efb3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们成功地渲染了Elm路由器下面的角形组件，非常棒。但是有一个问题。如果我们正在尝试迁移使用angular路由器的现有angular应用程序，那么我们很有可能使用$location服务来执行程序化的路由更改，例如:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="21ac" class="jz ka hu jv b fv kb kc l kd ke">$location.path('/pagefour/1234');</span></pre><p id="1f90" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这不会再起作用了，因为Elm在控制。所以我们需要想办法告诉Elm改变路线，而不是告诉angular改变路线。我们最好不要以任何干扰的方式改变我们的角度代码(因为我们可能有很多角度代码)。</p><p id="0f38" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一种方法是修饰$location服务并覆盖它的默认行为，向一个入站Elm端口发送一条消息，以便Elm可以接管。大概是这样的:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="3231" class="jz ka hu jv b fv kb kc l kd ke">const app = Elm.Main.embed(root);</span><span id="4a5f" class="jz ka hu jv b fv kf kc l kd ke">angular.module('MyApp', [])<br/>    .config(function($locationProvider, $provide) {<br/>    <br/>    $locationProvider.html5Mode(true);</span><span id="132e" class="jz ka hu jv b fv kf kc l kd ke">    $provide.decorator('$location', ['$delegate', <br/>        function $locationDecorator($delegate) {<br/>            const p = $delegate.path;<br/>            <strong class="jv hv">$delegate.path = function(url) {<br/>                app.ports.newUrl.send(url);<br/>            }</strong><br/>            return $delegate;<br/>        }]);<br/>});</span></pre><p id="b3d5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将拦截所有对$location.path的调用，并将url发送到我们的newUrl端口。在Elm端，我们需要如下定义该端口:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="472e" class="jz ka hu jv b fv kb kc l kd ke">port newUrl : (String -&gt; msg) -&gt; Sub msg</span></pre><p id="a17d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，我们需要订阅该端口，因此我们的订阅功能变为:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="c40a" class="jz ka hu jv b fv kb kc l kd ke">subscriptions : Model -&gt; Sub Msg<br/>subscriptions model =<br/>    newUrl NewUrl</span></pre><p id="404b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们已经在我们的更新功能中处理了NewUrl消息，一切似乎都正常。</p><h1 id="cd57" class="kg ka hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">但是仍然有一个问题</h1><p id="6512" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">锚定标签仍然不起作用。因此，事实证明，修饰$location.path并不是正确的方法，因为这只是angular改变位置的一种方式，我们需要覆盖所有的方式。解决方案是监听angular的$locationChangeStart事件，并在事件发生时将消息发送到我们的Elm端口。</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="90cd" class="jz ka hu jv b fv kb kc l kd ke">angular.module('MyApp', []).run(function($rootScope) {<br/>    $rootScope.$on('$locationChangeStart', (e, newUrl) =&gt; {<br/>        app.ports.newUrl.send(newUrl);<br/>    });<br/>});</span></pre><p id="b8e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这还有最后一个问题。如果路线改变是由<em class="li"> Elm </em>发起的，我们实际上不想听angular事件——除非它是由angular发起的。因此，我们可以创建一个标志，并在Elm触发路由更改时设置它(我们知道何时会发生这种情况，因为我们正在侦听来自Elm的出站端口),并稍微修改我们的侦听代码。</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="8fc4" class="jz ka hu jv b fv kb kc l kd ke">angular.module('MyApp', []).run(function($rootScope) {<br/>    $rootScope.$on('$locationChangeStart', (e, newUrl) =&gt; {<br/>        <strong class="jv hv">if(!listenForRouteChanges) {<br/>            return;<br/>        }</strong><br/>        app.ports.newUrl.send(newUrl);<br/>    });<br/>});</span></pre><p id="7665" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们处理完Elm发起的路由更改后，我们只需将listForRouteChanges标志设置回true。</p><h1 id="cc6b" class="kg ka hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">但是仍然有一个问题</h1><p id="1e70" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">浏览器的历史越来越混乱，更多细节和某种解决方案在<a class="ae jp" rel="noopener" href="/@julianjelfs_61852/replacing-the-angular-1-router-with-elm-part-3-d56e40bf251#.k0v54hssi">第三部</a> …</p><p id="db45" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">和以前一样，可以在<a class="ae jp" href="https://github.com/travelrepublic/elm-angular-router" rel="noopener ugc nofollow" target="_blank">这里</a>找到这个概念验证的完整源代码。</p></div></div>    
</body>
</html>