<html>
<head>
<title>Managing fleet on Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">管理库本内特斯号上的舰队</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/managing-fleet-on-kubernetes-8cac6483b64?source=collection_archive---------9-----------------------#2017-08-13">https://medium.com/hackernoon/managing-fleet-on-kubernetes-8cac6483b64?source=collection_archive---------9-----------------------#2017-08-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir is it"><p id="0e2d" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">几个月前，我们正在应对系统可扩展性方面的挑战，并寻求找到合适的编排工具来帮助快速扩展系统。这份草稿概述了我们一路上尝试和学习的东西，大部分你可能听起来都很熟悉。快速浏览一下我们在Kubernetes建造舰队时遇到的事情。</p></blockquote><p id="a849" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们开始探索由谷歌管理的流行项目:编排管理，DevOps<a class="ae jw" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank">Kubernetes</a>。从两周的学习曲线开始，我们在<em class="iw"> kubes </em>(简称kubernetes)建立了我们的工作阶段系统，并做了一些小的工作设置来可视化这个编排框架的力量。</p><h2 id="580e" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jt ki kj kk ju kl km kn jv ko kp kq kr dt translated">微服务</h2><p id="a485" class="pw-post-body-paragraph iu iv hu ix b iy ks ja jb jc kt je jf jt ku ji jj ju kv jm jn jv kw jq jr js hn dt translated">微服务架构之所以成为趋势，是因为它的架构风格旨在通过将软件解决方案分解成预计会失败的较小功能服务来解决管理现代应用程序的问题。</p><p id="0602" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这有助于从较小功能单元的故障中快速恢复，而不是从大型单片软件系统中恢复。微服务有助于让您的发布周期更快，因为您将专注于单个应用程序中的较小变化，而不是在具有多个依赖项的较大软件系统中推动代码变化。</p><h2 id="a315" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jt ki kj kk ju kl km kn jv ko kp kq kr dt translated">容器</h2><p id="0f21" class="pw-post-body-paragraph iu iv hu ix b iy ks ja jb jc kt je jf jt ku ji jj ju kv jm jn jv kw jq jr js hn dt translated">当Docker inc .在2013年发布Docker技术时，微服务架构掀起了一股浪潮。<strong class="ix hv"> Docker containers </strong>为<strong class="ix hv"> </strong>提供了虚拟机的完美替代品，并以更友好的方式驱动软件打包方法。码头工人集装箱比虚拟机(VMs)相对更小。它共享底层主机操作系统资源，我们可以在几毫秒的时间内旋转数百个这样的小单元。由于其可移植性，其较小的尺寸有助于更快的打包、测试甚至部署。</p><p id="1b30" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">Docker的基于容器的平台允许高度可移植的工作负载。Docker容器可以在开发人员的本地笔记本电脑上、数据中心的物理或虚拟机上、云提供商上或多种环境中运行。</p></div><div class="ab cl kx ky hc kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hn ho hp hq hr"><p id="a0ed" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们从<a class="ae jw" href="https://cloud.google.com/container-engine/" rel="noopener ugc nofollow" target="_blank">谷歌容器引擎</a> (GCE)开始，以快速完成工作。我们从一个只有几个<em class="iw"> 10个节点</em>的集群开始，每个节点都有配置<em class="iw"> 12个vCore </em>和<em class="iw"> 30 GB </em>在<a class="ae jw" href="https://cloud.google.com/container-engine/docs/node-pools" rel="noopener ugc nofollow" target="_blank"> <em class="iw">默认池</em> </a> <em class="iw"> </em>中运行无状态组件。</p><p id="8709" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在深入研究之前，我们需要一些<em class="iw">齿轮</em>(概念/工具/理论)来登上集装箱船，然后出航进行巡航。</p><p id="b05e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们将我们需要了解的齿轮分成两部分，即第一部分将是<strong class="ix hv"> Docker </strong>，第二部分将关注<strong class="ix hv"> Kubernetes </strong>。</p></div><div class="ab cl kx ky hc kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hn ho hp hq hr"><h1 id="4de8" class="le jy hu bd jz lf lg lh kd li lj lk kh ll lm ln kk lo lp lq kn lr ls lt kq lu dt translated">第一部分(了解码头工人)</h1><h2 id="6ff7" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jt ki kj kk ju kl km kn jv ko kp kq kr dt translated">无状态和有状态组件</h2><p id="8277" class="pw-post-body-paragraph iu iv hu ix b iy ks ja jb jc kt je jf jt ku ji jj ju kv jm jn jv kw jq jr js hn dt translated">在计算中，无状态协议是一种发送方或接收方都不保留任何信息的通信协议。发送方将数据包发送给接收方，并不期待收到确认。面向UDP连接的会话是一种无状态连接，因为两个系统都不会在会话生命周期内维护会话信息。<br/>相反，需要在服务器上保存内部状态的协议被称为有状态协议。面向TCP连接的会话是一种“有状态”连接，因为两个系统都在会话生命周期内维护会话本身的信息。</p><h2 id="08d5" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jt ki kj kk ju kl km kn jv ko kp kq kr dt translated"><a class="ae jw" href="https://www.redhat.com/en/containers" rel="noopener ugc nofollow" target="_blank">理解集装箱化概念</a></h2><p id="8551" class="pw-post-body-paragraph iu iv hu ix b iy ks ja jb jc kt je jf jt ku ji jj ju kv jm jn jv kw jq jr js hn dt translated">Container通过一个拥有自己的进程和网络空间的虚拟环境提供操作系统级的虚拟化，而不是创建一个完全成熟的虚拟机<a class="ae jw" href="https://en.wikipedia.org/wiki/Virtual_machine" rel="noopener ugc nofollow" target="_blank">(https://en.wikipedia.org/wiki/Virtual_machine)</a>。这使得操作系统的内核允许存在多个独立的用户空间实例，而不是只有一个。</p><h2 id="0291" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jt ki kj kk ju kl km kn jv ko kp kq kr dt translated"><a class="ae jw" href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/" rel="noopener ugc nofollow" target="_blank">为模块编写好docker file</a></h2><p id="fec8" class="pw-post-body-paragraph iu iv hu ix b iy ks ja jb jc kt je jf jt ku ji jj ju kv jm jn jv kw jq jr js hn dt translated">Dockerfile是Docker用来构建映像的一组指令。容器是使用docker映像创建的，可以通过手动执行命令或通过Dockerfile自动构建。Docker通过为名为“<strong class="ix hv"> docker容器</strong>”的应用程序创建安全的、基于LXC(即Linux容器)的环境来实现这一点。</p><p id="8357" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">*编写优化的Dockerfile，理解命令的顺序。我们在Dockerfile中运行的每个命令都是作为一个层执行的，后续的命令将建立在前一层之上。每一层都由Docker工具在缓存中管理。Docker自己管理缓存，以重用以前构建的Docker映像层，从而节省时间和磁盘。</p><figure class="lv lw lx ly fq lz"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="d124" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><a class="ae jw" href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#each-container-should-have-only-one-concern" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hv">在Docker容器中运行单个进程</strong> </a> <br/>“每个容器一个进程”通常是一个很好的经验法则，它不是一个硬性的规则。</p><blockquote class="ir is it"><p id="1cee" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">使用你最好的判断来保持容器尽可能的干净和模块化。</p></blockquote><p id="6ec3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">了解远程<strong class="ix hv"> docker容器注册表</strong>为了存储/推送我们本地构建的Docker映像，这里我们使用了<strong class="ix hv"> Google容器注册表</strong> (GCR)进行Docker映像管理。</p><blockquote class="ir is it"><p id="8f57" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">推送图片到GCR(<a class="ae jw" href="https://cloud.google.com/container-registry/docs/pushing-and-pulling" rel="noopener ugc nofollow" target="_blank">https://Cloud . Google . com/container-registry/docs/Push-and-Pulling</a>)<br/>推送图片到Docker Cloud(<a class="ae jw" href="https://docs.docker.com/docker-cloud/builds/push-images/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/docker-cloud/builds/push-images/</a>)</p></blockquote></div><div class="ab cl kx ky hc kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hn ho hp hq hr"><h1 id="68d2" class="le jy hu bd jz lf lg lh kd li lj lk kh ll lm ln kk lo lp lq kn lr ls lt kq lu dt translated">第二部分(了解海洋中的Kubernetes)</h1><p id="0957" class="pw-post-body-paragraph iu iv hu ix b iy ks ja jb jc kt je jf jt ku ji jj ju kv jm jn jv kw jq jr js hn dt translated"><strong class="ix hv">学习kubernetes的基础知识&amp; </strong> <a class="ae jw" href="https://kubernetes.io/docs/tutorials/kubernetes-basics/" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hv">工作流程培训</strong> </a></p><blockquote class="ir is it"><p id="b39a" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">Kubernetes是一个开源平台，用于跨主机集群自动部署、扩展和操作应用程序容器，提供以容器为中心的基础设施——kubernetes . io</p></blockquote><p id="0c2d" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><a class="ae jw" href="https://kubernetes.io/docs/concepts/workloads/pods/pod/#what-is-a-pod" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hv">什么是豆荚</strong> </a> <strong class="ix hv">？容器如何在容器内运行？</strong></p><p id="a1b1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">* Pods是Kubernetes平台上的原子单位。Pod是一个Kubernetes抽象，表示一组一个或多个应用程序容器(比如Nginx或redis)，以及这些容器的一些共享资源。</p><figure class="lv lw lx ly fq lz fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mc"><img src="../Images/3277217b6218978cccd815003fcb3d3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o68H9ID0OxR7yc4qeaBokA.png"/></div></div><figcaption class="mj mk fg fe ff ml mm bd b be z ek">Pod Overview : Images by Kubernetes.io</figcaption></figure><p id="3815" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><a class="ae jw" href="https://kubernetes.io/docs/concepts/nodes/node/#what-is-a-node" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hv">什么是节点</strong> </a> <strong class="ix hv">？</strong> <em class="iw">(又称工人或奴才)</em></p><p id="0580" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">* Pod始终在节点内运行。在Kubernetes中，节点是一个工作机，可以是虚拟机，也可以是物理机，这取决于集群。节点由Kubernetes主节点控制。Kubernetes管理集群中运行的节点的pods调度。</p><figure class="lv lw lx ly fq lz fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mn"><img src="../Images/41aea79eeb123392a1df4f08b5819697.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_DvKCivXyOXdtSvJiPp-RQ.png"/></div></div><figcaption class="mj mk fg fe ff ml mm bd b be z ek">Node Overview : Images by Kubernetes.io</figcaption></figure><p id="5622" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><a class="ae jw" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hv">有哪些部署</strong> </a> <strong class="ix hv">？</strong></p><p id="e7a6" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">*我们使用部署来创建新资源，或者通过定义的配置用新资源替换现有资源。你可以把它想象成一个pods管理的主管。</p><figure class="lv lw lx ly fq lz"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="28a0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><a class="ae jw" href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hv">什么是复制控制器和副本集</strong> </a> <strong class="ix hv">？</strong></p><p id="9d1e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">*复制控制器和副本集确保指定数量的pod“副本”在任一时刻都在运行。换句话说，它确保一个pod或一组同类的pod始终可用。如果豆荚太多，会杀死一些。太少的话，会多启动。</p><blockquote class="ir is it"><p id="411c" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">在上面的<em class="hu"> yaml </em>文件中，你可以看到<strong class="ix hv">副本</strong>关键字，这是由复制工具管理的。</p></blockquote><p id="7c21" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><a class="ae jw" href="https://kubernetes.io/docs/concepts/overview/components/" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hv">什么是Kubernetes大师</strong> </a> <strong class="ix hv">？</strong></p><p id="050d" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">* Kubernetes集群中的控制服务称为主组件或控制平面组件。例如，主组件负责做出关于集群的全局决策(例如，调度)，以及检测和响应集群事件(例如，当复制控制器的‘副本’字段不满足时启动新的pod)。Kubernetes提供了一个REST API，主要支持(大部分)持久性资源上的CRUD操作，这些资源充当其控制平面的中枢。</p><p id="59bd" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><a class="ae jw" href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/architecture.md#architecture" rel="noopener ugc nofollow" target="_blank"> <em class="iw">库伯内特生态系统由多种成分组成</em> </a> <em class="iw">。</em></p><p id="b686" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><a class="ae jw" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hv">什么是服务</strong> </a> <strong class="ix hv">？</strong></p><p id="c45c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">* Kubernetes服务是一种抽象，它定义了一组逻辑单元和访问它们的策略。一个服务所针对的一组pod(通常)是由一个标签选择器决定的。服务继续寻找分配了特定标签的pod，并跟踪这些pod以请求卸载。</p><figure class="lv lw lx ly fq lz fe ff paragraph-image"><div class="fe ff mo"><img src="../Images/5cf84c14ada3f124c045707acb6396e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*GdTo4cb2iujH-z2Koy4gxw.png"/></div><figcaption class="mj mk fg fe ff ml mm bd b be z ek">Service Overview : Images by Kubernetes.io</figcaption></figure><figure class="lv lw lx ly fq lz"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="5de0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><a class="ae jw" href="https://kubernetes.io/docs/user-guide/kubectl-cheatsheet/" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hv">如何从命令行</strong> </a> <strong class="ix hv">调试或获取集群信息？</strong></p><p id="0d07" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">* <strong class="ix hv"> <em class="iw"> kubectl </em> </strong>是针对Kubernetes集群运行命令的命令行界面。</p><figure class="lv lw lx ly fq lz"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="b7a4" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们如何在GCE中运行容器？</p><p id="5eeb" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们有许多<strong class="ix hv">部署</strong>，它们根据我们需要的处理来管理扩展。<em class="iw">pod</em>运行集群中可用的<em class="iw">节点</em>内的容器。我们需要遵循正确的模块版本，以区分您的系统内部正在运行什么，这有助于在生产中出现问题时回滚发布。</p><blockquote class="ir is it"><p id="0bc2" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">我们需要公开的服务/API怎么样？</p></blockquote><p id="e01b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">——库贝斯<strong class="ix hv"> <em class="iw">服务</em> </strong>来了。我们有大量的API需要向外界公开。为了实现这一点，我们使用分配了公共IP的tcp loadbalancer公开了几个kube服务。在内部，这些服务继续使用<strong class="ix hv">标签选择器</strong>进行服务发现，以找到pod并将其附加到该服务，具有相同标签的pod将被服务作为目标。它与我们在云上管理负载平衡器的概念相同，将虚拟机连接到负载平衡器以卸载传入流量。</p><blockquote class="ir is it"><p id="d02e" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">Kube船内部运行的资源彼此非常了解。每个服务/单元可以通过分配给每个服务/单元的名称进行通信。您可以使用FQDN这样的名称，而不是使用分配给它们的IP(私有)。由于网络资源分配的动态特性，使用名称而不是IP是一个很好的实践，因为在容器生命周期管理中，资源会被破坏和重新创建。Kube-DNS维护所有内部分配的IP列表，并帮助按名称查找资源。</p></blockquote><p id="477e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><a class="ae jw" href="https://kubernetes.io/docs/tasks/configure-pod-container/assign-cpu-ram-container/" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hv">如何决定应该给你的pods资源分配什么资源</strong>？</a></p><figure class="lv lw lx ly fq lz"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="815d" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">每个容器都有自己的资源需求(即<em class="iw"> CPU、RAM、磁盘、网络</em>等)，在kubes中有<strong class="ix hv">请求</strong> &amp; <strong class="ix hv">限制</strong>。这有助于保持您的节点健康。很多时候，由于糟糕的限制或没有定义限制，您的pod会在利用率方面发疯。它们可能会吃掉任何资源，并导致节点饥饿，从而使节点不健康，并由于资源耗尽而进入<strong class="ix hv">【未就绪】</strong>状态。在早期阶段，我们多次面临这种情况，但现在我们已经根据其饥饿行为微调了每个豆荚的资源。</p><p id="130d" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><strong class="ix hv">如何定义kubernetes集群中的节点资源？</strong></p><p id="a68e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">根据容器类型(在<em class="iw"> pod </em>中运行)，您可以定义不同的<strong class="ix hv"> <em class="iw">节点池</em> </strong>。假设您有名为``<strong class="ix hv"> Core的模块。X </strong>、<strong class="ix hv">核心。Y </strong>和<strong class="ix hv">型芯。Z </strong>`` `，它们都需要```<strong class="ix hv"> 2个内核，2 GB </strong>`` `才能运行，然后您可以使用<em class="iw">标准节点池</em>来运行它们。在这种情况下，我将为我的节点池分配以下配置。</p><p id="86ed" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">-名称:标准池<br/>-池大小:2<br/>-节点配置:4个核心，4gb<br/>-节点池资源:8个核心，8gb<br/>-<strong class="ix hv">利用率</strong> : 6个核心，6 GB (75 %已用核心&amp; RAM)</p><p id="64e4" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">现在，假设我有高内存消耗模块。让我们称他们为Mem。x，Mem。y和Mem。Z ` `，它们都需要``<strong class="ix hv"> 0.5核，4 GB </strong>` `每个才能运行，那么你需要<em class="iw">高内存节点池</em>才能运行它们。在这种情况下，我将为我的节点池分配不同的配置。</p><p id="aa35" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">-名称:HighMem池<br/> -池大小:2 <br/> -节点配置:1个核心，8 GB <br/> -节点池资源:2个核心，16 GB <br/> - <strong class="ix hv">利用率</strong> : 1.5个核心，12 GB (75 %已用核心&amp; RAM)</p><blockquote class="ir is it"><p id="cf05" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">因此，基于您的节点池类型(<a class="ae jw" href="https://cloud.google.com/container-engine/docs/node-pools" rel="noopener ugc nofollow" target="_blank">https://cloud.google.com/container-engine/docs/node-pools</a>)，您可以通过使用kubes中的nodeSelector在不同的节点池中部署您的pod。</p></blockquote><figure class="lv lw lx ly fq lz"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="c496" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><strong class="ix hv">我们如何监控Kubernetes？</strong></p><p id="aebd" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们可以运行定制的监控设置来监视节点。你可以运行[heap ster](<a class="ae jw" href="https://github.com/kubernetes/heapster" rel="noopener ugc nofollow" target="_blank">https://github.com/kubernetes/heapster</a>)，即。负责容器集群的计算资源使用分析和监控，与【influxdb】(<a class="ae jw" href="https://github.com/influxdata/influxdb" rel="noopener ugc nofollow" target="_blank">https://github.com/influxdata/influxdb</a>)挂钩，消费heapster推送的报告，可以在【grafana】(<a class="ae jw" href="https://grafana.com/" rel="noopener ugc nofollow" target="_blank">https://grafana.com/</a>可视化。</p><figure class="lv lw lx ly fq lz fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mp"><img src="../Images/4d50f5bb3f173564dd10c6013be87086.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nvskytQPJNyNBethBoGm8w.png"/></div></div><figcaption class="mj mk fg fe ff ml mm bd b be z ek">Monitoring in Grafana</figcaption></figure></div><div class="ab cl kx ky hc kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hn ho hp hq hr"><p id="c146" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><strong class="ix hv">注意:</strong>需要注意GCE中的一些配置，比如<strong class="ix hv">自动升级kubernetes版本</strong>。如果您正在运行RabbitMQ、Redis或任何其他需要正常运行时间的消息队列服务，您最好关闭自动升级，因为kubernetes新版本将安排您的所有节点进行维护，但是它会逐个滚动更新，但可能会影响您的生产系统。否则，如果您是完全无状态的，您可以保留默认值或跳过此警告！</p><p id="8732" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><a class="ae jw" href="https://cloud.google.com/container-engine/docs/node-auto-upgrade" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/container-engine/docs/node-auto-upgrade</a></p><blockquote class="ir is it"><p id="fdd7" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">gcloud beta容器节点池更新<nodepool> —集群<cluster> —区域<zone> —无-启用-自动升级</zone></cluster></nodepool></p></blockquote><p id="95a9" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">几乎所有以上的理解都是基于我过去六个月在kubernetes生产中所学到的。容器管理很容易适应，随着我们的发展，许多新的观察结果还没有被发现。</p><p id="9b23" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">看看今天的部署，Kubernetes在自动驾驶和自我修复方面绝对出色。我们在集群中一起运行超过1000个pod，每月处理数十亿个API调用，并推动更多的处理。</p><blockquote class="ir is it"><p id="5ad6" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><strong class="ix hv"> <em class="hu">结论:</em> </strong> <em class="hu"> Kubernetes解除了大量服务器管理，帮助更快部署&amp;扩展系统。适应性更快，大部分安全和其他问题都由谷歌管理。Kubernetes的目标是在集群基础设施之上提供一个更好的编排管理系统。Kubernetes上的开发一直在以暴风般的速度进行，Kubernauts(</em><a class="ae jw" href="https://kubernetes.io/community/" rel="noopener ugc nofollow" target="_blank"><em class="hu"/></a><em class="hu">)的社区已经变得越来越大。</em></p></blockquote></div><div class="ab cl kx ky hc kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hn ho hp hq hr"><p id="0b11" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt mq translated"><span class="l mr ms mt bm mu mv mw mx my di"> D </span> <strong class="ix hv"> aemon博客:</strong><a class="ae jw" href="https://sunnykrgupta.github.io/managing-fleet-on-kubernetes.html" rel="noopener ugc nofollow" target="_blank">https://sunnykrgupta . github . io/managing-fleet-on-kubernetes . html</a></p><div class="mz na fm fo nb nc"><a href="https://sunnykrgupta.github.io/managing-fleet-on-kubernetes.html" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab ej"><div class="ne ab nf cl cj ng"><h2 class="bd hv fv z el nh eo ep ni er et ht dt translated">守护程序博客-管理Kubernetes上的车队</h2><div class="nj l"><h3 class="bd b fv z el nh eo ep ni er et ek translated">桑尼·库马尔的文章和文章</h3></div><div class="nk l"><p class="bd b gc z el nh eo ep ni er et ek translated">sunnykrgupta.github.io</p></div></div><div class="nl l"><div class="nm l nn no np nl nq mh nc"/></div></div></a></div></div></div>    
</body>
</html>