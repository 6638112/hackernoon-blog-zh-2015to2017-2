<html>
<head>
<title>Serverless and Bitcoin — creating price watchers dynamically</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器和比特币——动态创造价格观察者</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/serverless-and-bitcoin-creating-price-watchers-dynamically-beea36ef194e?source=collection_archive---------15-----------------------#2017-12-27">https://medium.com/hackernoon/serverless-and-bitcoin-creating-price-watchers-dynamically-beea36ef194e?source=collection_archive---------15-----------------------#2017-12-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="64d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://hackernoon.com/tagged/bitcoin" rel="noopener ugc nofollow" target="_blank">比特币</a>在上个月达到了一个新的宣传水平。如果你花过时间研究比特币，你就会知道它非常不稳定，价格可以在几分钟内上下波动。我是一个相当厌恶风险的人，所以我没有把太多的个人资金投入比特币，但我很幸运地在2013年购买了一小部分，作为一项实验，现在已经有了相当大的增长。我一直在做一点交易和交换，以充分利用它——但考虑到当前价格的巨大可变性，我很难跟上当前价格。</p><p id="643c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我不需要经常查看比特币基地或Bittrex，而是希望获得关于我拥有或想要的硬币的提醒。我想要一种方法，当越过正确的阈值时，自动购买或出售硬币。前几天晚上，我开始构建一个无服务器的加密货币观察器——我可以通过从我的手机上发送类似“观察btc 18000”的文本来指定新的观察器——当硬币超过限制时，它会提醒我。我很高兴地说，这个星期我就做了这个，而且从那以后一直使用得很成功。这是它是如何组合在一起的。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/cb02fbcf496b715f9802b07c9bc51df9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ld_dtoMbYTqcVvAWlbk9fw.jpeg"/></div></div></figure><h1 id="74ce" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">无服务器“观看”模式</h1><p id="1b58" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">当您只有一个或静态数量的观察器时，在无服务器中观察事件可以相当简单。例如，前几周我构建了一个Azure函数来观察ring.com门铃的新事件<a class="ae jp" rel="noopener" href="/@jeffhollan/serverless-doorbell-azure-functions-and-ring-com-f24b44e01645">。</a>这种模式在计时器上有一个单一的功能，可以唤醒并检查物品。然而，在这种情况下，我希望有一个动态的观察者“池”。有一天，如果以太币超过813美元，我可能会要求一个观察者观察它，三个小时后，我希望一个平行的观察者检查莱特币。虽然任务本身看起来很简单，但在云中构建持久的托管可能很棘手。你如何吸引新的观察者？一个守望者能跑多久？它们耐用吗？可以终止一个观察者吗？另外，当使用无服务器时:<strong class="it hv">我怎样才能让我的观察者存在的时间比传统的5-10分钟更长？</strong></p><p id="c8a2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我考虑了几个选项来在无服务器堆栈上实现这一点:</p><ol class=""><li id="62a6" class="lf lg hu it b iu iv iy iz jc lh jg li jk lj jo lk ll lm ln dt translated">为每个观察者创建新的<a class="ae jp" href="https://hackernoon.com/tagged/azure" rel="noopener ugc nofollow" target="_blank"> Azure </a>函数。将有一个“主”功能，它将接收文本消息请求，然后根据我想要的阈值在计时器触发器上部署完整的Azure功能。<strong class="it hv">缺点:</strong>对于这种类型的场景来说不是“一流”的模式。创建一个全新的函数是一个相对昂贵的操作——特别是对于像我希望这些观察器那样短暂的东西(只观察大约一周，一旦超过阈值，它就应该消失)。使用此选项，处理工人的拆卸和管理可能会变得相当复杂。</li><li id="bda4" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><a class="ae jp" href="https://docs.microsoft.com/en-us/azure/logic-apps/logic-apps-what-are-logic-apps" rel="noopener ugc nofollow" target="_blank">使用Azure Logic Apps </a>每当有请求进来时，就触发一个“观察者”的编排。从功能上来说，所有的部分都在那里，这是可行的。<strong class="it hv">缺点:</strong>比选项1好得多，但这意味着我需要将Azure功能和逻辑应用作为独立的资源来管理。为诸如“while”循环之类的东西做更复杂的条件通常比仅仅写一个C#表达式更复杂。</li><li id="fb59" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><a class="ae jp" href="https://docs.microsoft.com/en-us/azure/azure-functions/durable-functions-overview" rel="noopener ugc nofollow" target="_blank">使用Azure持久功能</a>在请求到来时编排一个“观察者”。允许我编写可以无限期存在的Azure函数。与选项2非常相似，但所有编排都存在于具有持久扩展的功能应用程序中。允许我在代码中编写编排逻辑，并在同一个应用程序中编写功能。<strong class="it hv">缺点:</strong>比逻辑应用程序更难监控活动的观察器，在逻辑应用程序中，我可以看到所有活动的运行，它们处于哪个步骤，以及失败。还需要为这些步骤编写所有代码，而不是在Logic应用程序中利用类似“Twilio”的SMS连接器。</li></ol><p id="9613" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第2条和第3条都非常有效，但是因为我想在类似于观察者的“成功条件”这样的事情上有更多的灵活性，所以我选择了持久函数。这是我制作的最复杂的配器，但是它工作起来没有任何问题，并且对我的选择很满意。</p><h1 id="2007" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">创建具有持久功能的持久观察器</h1><p id="81b5" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">第一个函数接收开始观察硬币的请求，并启动一个新的观察器进程。我创建了一个HttpWebhook函数，它监听一个Twilio webhook，每当我向一个特定的号码发送文本时，它就会通知我的函数。我解析发送的命令(“watch”或“stop”)，然后为一个观察器创建一个新的编排。</p><p id="4916" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">硬币监视器是持久函数的一个实例。在这种情况下，持久函数是一个while循环:“当当前价格低于阈值价格时，继续检查价格。”为了确保多年来没有观察器检查，我还对while循环进行了限制(可通过应用程序设置进行设置，现在如果没有达到阈值，我会有一个观察器在1周后超时)。我还添加了一个延迟，这样我就不会连续快速地检查价格。</p><p id="447a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是硬币观察者持久编制器的代码:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lt lu l"/></div></figure><p id="1239" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有几个标注值得详述:当一个持久函数运行时，它管理短期函数中运行的长期进程的方式是利用在<code class="eh lv lw lx ly b">context</code>中检索的状态，并重放该函数以在下一步继续。这意味着你需要在你的持久函数中非常小心，以便重放提供确定的和一致的结果。你会注意到，为了获得当前时间，我实际上利用了表达式<code class="eh lv lw lx ly b">context.CurrentUtcDateTime</code>的上下文，而不是像<code class="eh lv lw lx ly b">DateTime.Now</code>这样的东西，因为<code class="eh lv lw lx ly b">context</code>将在重放时返回相同的值，所以不会丢弃其他条件。</p><p id="2e2e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我还在while循环中添加了一个延迟，这样我就不会受到exchange API(在本例中是Bittrex)的限制。我用下面一行代码添加了15分钟的延迟，这一行代码从我的Azure应用程序设置中下拉了延迟间隔(这样我就可以自定义而不必重新部署)。</p><p id="3ec0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lv lw lx ly b">await context.CreateTimer(context.CurrentUtcDateTime.AddMinutes(double.Parse(Constants.DelayInterval)), CancellationToken.None);</code></p><p id="472e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">像“send_message”和“watcher_getticker”这样被调用的动作是什么？这些只是简单的Azure函数，如下所示:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lt lu l"/></div></figure><p id="1600" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，每当我发送类似“观看eth 900”的文本时，一个持久的实例就会旋转起来，并继续检查以太坊的价格，直到它超过900美元或while循环超时(如果我想续订，它会发送一条友好的文本消息通知我超时)。</p><h1 id="e40c" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">终止活动实例</h1><p id="630f" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">构建时最令人惊喜的事情之一是终止一个活动实例是多么容易。你可能从上面的截图中注意到，我提供了一种通过发送“STOP”和一些ID来取消观察者的方法。每当持久orchestrator启动时，它都会返回一个实例ID。我可以很容易地回复“停止{instanceId}”并完成。但是实例ID是类似于<code class="eh lv lw lx ly b">fe5cb9b39e0445f4b751d95fc6410ade</code>的GUID，在电话上键入会很麻烦。所以每当我创建一个实例时，我都会在Azure表存储中为它创建一个别名。在我的例子中，我生成一个介于1-1000之间的数字。我知道，我知道..这意味着每个电话号码会发生1/1000次冲突，但我只计划一次有4个左右的观察者活跃，并选择容易打字而不是高熵。如果有人想打开一个拉请求，以生成一个4字符大小写敏感的字母数字别名，我会很乐意接受它😀。</p><p id="264e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦接收到stop命令，我将它映射到实例ID，并可以用我的主函数中的一行代码终止实例:</p><p id="3838" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lv lw lx ly b">await starter.TerminateAsync(((Alias)result.Result).Id, “User requested terminate”);</code></p><p id="bf5c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这正是我所需要的，而且非常容易实现。</p><h1 id="7df4" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">扩展观察器模型</h1><p id="ec5f" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">这真的只是我想要建设的开始。我计划扩展上面的“send_event”函数，也向Azure Event Grid发出一个事件。当我用更多的信息来补充我的请求时，它也可以在超过阈值时触发硬币的自动购买或出售。</p><p id="b29c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我无法表达我有多喜欢在云中创建这些小逻辑，让它们“整天、每天”运行，但只为我主动消耗的计算时间付费。</p><p id="e696" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/jeffhollan/functions-durable-csharp-bittrex-watcher" rel="noopener ugc nofollow" target="_blank">整个解决方案在这里</a>签入GitHub，如果你想部署自己的，应该与Visual Studio 2017中的Azure Functions工具兼容。这是写在。NET Core也可以跨平台编译和运行。</p><div class="lz ma fm fo mb mc"><a href="https://github.com/jeffhollan/functions-durable-csharp-bittrex-watcher" rel="noopener  ugc nofollow" target="_blank"><div class="md ab ej"><div class="me ab mf cl cj mg"><h2 class="bd hv fv z el mh eo ep mi er et ht dt translated">jeffhollan/functions-durable-cs harp-bittrex-watcher</h2><div class="mj l"><h3 class="bd b fv z el mh eo ep mi er et ek translated">Azure功能可以监控Bittrex上的硬币价格，并在超过阈值时通过短信通知。利用Azure…</h3></div><div class="mk l"><p class="bd b gc z el mh eo ep mi er et ek translated">github.com</p></div></div><div class="ml l"><div class="mm l mn mo mp ml mq ka mc"/></div></div></a></div><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mr lu l"/></div></figure></div></div>    
</body>
</html>