<html>
<head>
<title>Things I Brushed Up On This Week: The HTTP Request Lifecycle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">本周我复习的内容:HTTP请求生命周期</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/things-i-brushed-up-on-this-week-the-http-request-lifecycle-a321775a1282?source=collection_archive---------22-----------------------#2017-07-25">https://medium.com/hackernoon/things-i-brushed-up-on-this-week-the-http-request-lifecycle-a321775a1282?source=collection_archive---------22-----------------------#2017-07-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/f6aaefc21ab9c46a55146e541b196dc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*Z2CwOsDfI9Mcf58DLHk9iQ.gif"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">After a week of staring at this GIF I still can’t tell if it’s a dog or a hedgehog</figcaption></figure><p id="192c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我最近一直在面试，正如大多数开发人员所知，在面试中你可能会被问到的问题的广度和深度是不可估量的。考虑到这一点，我一直在询问招聘人员，在技术面试中我可能会被问到什么问题。有时我发现很难在我的头脑中保持所有可能的问题类别，更不用说问题本身了。我在压力下容易忘记事情，<a class="ae ka" href="https://stackoverflow.com/questions/9553628/piping-and-redirection" rel="noopener ugc nofollow" target="_blank"> <em class="kb">就像bash中的</em> </a> <code class="eh kc kd ke kf b"><a class="ae ka" href="https://stackoverflow.com/questions/9553628/piping-and-redirection" rel="noopener ugc nofollow" target="_blank"><em class="kb">|</em></a></code> <a class="ae ka" href="https://stackoverflow.com/questions/9553628/piping-and-redirection" rel="noopener ugc nofollow" target="_blank"> <em class="kb">是针对流程/程序的，</em> </a> <code class="eh kc kd ke kf b"><a class="ae ka" href="https://stackoverflow.com/questions/9553628/piping-and-redirection" rel="noopener ugc nofollow" target="_blank"><em class="kb">&gt;</em></a></code> <a class="ae ka" href="https://stackoverflow.com/questions/9553628/piping-and-redirection" rel="noopener ugc nofollow" target="_blank"> <em class="kb">一般是针对文件的</em> </a>。为了更好地保留信息并强迫自己写作，我决定开始张贴我温习过的内容。我倾向于需要至少3个来源来获得一个完整的、正确的、写得很好的主题解释。我想为其他人巩固这一点。</p><p id="4fd6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">本周，我查看了HTTP请求生命周期。这是一个非常宽泛的概述，它针对的是简单的HTTP 1.1请求，而不是持久连接，但是它可以作为HTTP/2和持久连接请求的一个很好的起点。我不会过多地介绍各种HTTP方法，因为这可能是一篇独立的文章，并且因为它们与许多开发人员的工作流程非常接近，读者可能已经掌握了基本知识。</p><blockquote class="kg kh ki"><p id="4931" class="jc jd kb je b jf jg jh ji jj jk jl jm kj jo jp jq kk js jt ju kl jw jx jy jz hn dt translated">注意:Medium不支持脚注，所以所有脚注都链接到原始dev.to post</p></blockquote></div><div class="ab cl km kn hc ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hn ho hp hq hr"><h2 id="b18a" class="kt ku hu bd kv kw kx ky kz la lb lc ld jn le lf lg jr lh li lj jv lk ll lm ln dt translated">步骤1:本地处理</h2><p id="babe" class="pw-post-body-paragraph jc jd hu je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz hn dt translated">根据您想要获得的深度，根据发出请求的应用程序，在这个步骤中可能会发生很多事情。我将继续理解这个请求是由浏览器发出的，而不是cURL，一个像Postman这样的API客户端，或者其他一些应用程序。</p><ol class=""><li id="561f" class="lt lu hu je b jf jg jj jk jn lv jr lw jv lx jz ly lz ma mb dt translated">您的浏览器提取“方案”/协议(我们已经建立了<br/>这将是HTTP)、主机(<em class="kb">www.example.com)</em>，以及可选的端口号、资源路径和查询字符串，这些都在表单<code class="eh kc kd ke kf b">&lt;protocol&gt;://&lt;host&gt;&lt;:optional port&gt;/&lt;path/to/resource&gt;&lt;?query&gt;</code>中指定。一个例子是<code class="eh kc kd ke kf b">|http|://|www.example.com||:5000||/mainpage||?query=param&amp;query2=param2|</code></li><li id="8e2a" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">既然浏览器已经有了请求的主机名，它需要解析一个IP地址<a class="ae ka" href="https://dev.to/dangolant/things-i-brushed-up-on-this-week-the-http-request-lifecycle-#fn1" rel="noopener ugc nofollow" target="_blank"> </a>。然后，浏览器会查看自己最近请求的URL的缓存、操作系统最近查询的缓存、路由器的缓存和DNS缓存。</li></ol><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="fe ff mh"><img src="../Images/c379658e329abe93a8b7e3b0ddcb3b4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*37HQafkW3rk2eJKZrsmOBw.gif"/></div></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">Making GIFs is hard</figcaption></figure></div><div class="ab cl km kn hc ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hn ho hp hq hr"><h2 id="ef87" class="kt ku hu bd kv kw kx ky kz la lb lc ld jn le lf lg jr lh li lj jv lk ll lm ln dt translated">步骤2:解析IP</h2><p id="79cf" class="pw-post-body-paragraph jc jd hu je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz hn dt translated">与本地完成的处理一样，从“DNS服务器”<a class="ae ka" href="https://dev.to/dangolant/things-i-brushed-up-on-this-week-the-http-request-lifecycle-#fn2" rel="noopener ugc nofollow" target="_blank"> </a>解析IP是一个包括许多步骤的序列，如果第一个请求未能返回地址，还包括故障转移。</p><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div class="fe ff mq"><img src="../Images/a5f9e0eb5ad4453930898c22a1514c6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/1*clLVofnUSJ2TquY89OJCkQ.gif"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">I have no idea whether this dot is actually on the shortest path</figcaption></figure><ol class=""><li id="72dd" class="lt lu hu je b jf jg jj jk jn lv jr lw jv lx jz ly lz ma mb dt translated">如果缓存查找失败(我们假设它会失败)，您的浏览器将使用<a class="ae ka" href="https://en.wikipedia.org/wiki/User_Datagram_Protocol" rel="noopener ugc nofollow" target="_blank"><em class="kb">UDP</em></a><em class="kb"/><a class="ae ka" href="https://dev.to/dangolant/things-i-brushed-up-on-this-week-the-http-request-lifecycle-#fn3" rel="noopener ugc nofollow" target="_blank"/>发出一个<a class="ae ka" href="https://tools.ietf.org/html/rfc1035" rel="noopener ugc nofollow" target="_blank"> <em class="kb"> DNS请求</em> </a>。DNS请求包含为您的DNS服务器预先配置的IP，并在其标题中包含您的返回IP。您尝试解析IP的主机名位于请求的“问题”部分。UDP是一种轻量级协议，但代价是它不提供交付方面的保证，并且除了发送和接收响应之外没有确认。</li><li id="dbaa" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">您的请求现在必须通过许多网络设备才能到达其目标DNS服务器。每当数据包到达一台网络设备时，该设备就会使用路由表来确定它所连接的另一台设备最有可能位于到达目的地的最短路径上。<a class="ae ka" href="https://dev.to/dangolant/things-i-brushed-up-on-this-week-the-http-request-lifecycle-#fn4" rel="noopener ugc nofollow" target="_blank"> ⁴ </a></li><li id="9e16" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">一旦您的请求到达您配置的DNS服务器，服务器就会寻找与请求的主机名相关联的地址。如果它找到一个，它发送一个响应。另一方面，如果您的目标DNS服务器无法定位给定的主机名，它会将请求传递给另一个它被配置为<em class="kb">委托</em>的DNS服务器。这种情况递归地发生，直到找到地址，或者命中一个<a class="ae ka" href="https://en.wikipedia.org/wiki/Name_server#Authoritative_name_server" rel="noopener ugc nofollow" target="_blank"> <em class="kb">【权威】域名服务器</em> </a>。如果无法解析给定域的地址，服务器会以失败响应，并且您的浏览器会返回一个错误。</li><li id="c5a8" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">尽管如此，我们将假设请求是成功的，因为所有这些仍然是一个前兆。如果响应返回(记住，使用UDP是没有保证的！)，请求客户端现在有了一个目标IP。它还会收到一条信息，作为答案的一部分，让它知道返回的答案可以缓存多长时间。这意味着后续请求将从<strong class="je hv">步骤1.2 </strong>到这里走捷径。</li></ol></div><div class="ab cl km kn hc ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hn ho hp hq hr"><h2 id="7544" class="kt ku hu bd kv kw kx ky kz la lb lc ld jn le lf lg jr lh li lj jv lk ll lm ln dt translated">步骤3:建立TCP连接</h2><p id="69f0" class="pw-post-body-paragraph jc jd hu je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz hn dt translated">现在客户机有了IP地址，它可以发送一个HTTP <a class="ae ka" href="https://dev.to/dangolant/things-i-brushed-up-on-this-week-the-http-request-lifecycle-#fn5" rel="noopener ugc nofollow" target="_blank"> ⁵ </a>请求，对吗？差不多，但是首先，由于请求是通过<a class="ae ka" href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol" rel="noopener ugc nofollow" target="_blank"><em class="kb">TCP</em></a><em class="kb"/><a class="ae ka" href="https://dev.to/dangolant/things-i-brushed-up-on-this-week-the-http-request-lifecycle-#fn6" rel="noopener ugc nofollow" target="_blank">⁶</a>发送的，这是一个<em class="kb">传输层协议</em>像UDP，客户端必须打开一个TCP连接。</p><ol class=""><li id="bea4" class="lt lu hu je b jf jg jj jk jn lv jr lw jv lx jz ly lz ma mb dt translated">TCP和UDP的一个关键区别是，TCP确保交付和有序的数据传输。大部分操作非常简单，对发送的每个字节使用一个被称为<em class="kb">的序列号</em>。这允许接收方将接收到的数据包重新排序为原始顺序，并允许发送方重新发送任何没有得到接收方确认的数据包。</li><li id="4503" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">这些保证和更多的保证可以在维基百科上找到，值得一读，但最相关的是TCP连接是使用所谓的<em class="kb">三次握手</em>打开的。服务器必须已经在“监听”一个端口，执行<em class="kb">被动打开</em>，之后客户端可以发起<em class="kb">主动打开</em>，握手过程如下:</li><li id="4b1a" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">客户端通过向服务器发送一个<code class="eh kc kd ke kf b">SYN</code> <a class="ae ka" href="https://dev.to/dangolant/things-i-brushed-up-on-this-week-the-http-request-lifecycle-#fn7" rel="noopener ugc nofollow" target="_blank"> ⁷ </a>【控制】<a class="ae ka" href="https://dev.to/dangolant/things-i-brushed-up-on-this-week-the-http-request-lifecycle-#fn8" rel="noopener ugc nofollow" target="_blank"> ⁸ </a>数据包来发起主动打开。出于安全考虑，客户端特意将第一个数据包的序列号<em class="kb">设置为随机值。我们现在将这个数字称为<code class="eh kc kd ke kf b">x</code>。</em></li><li id="a773" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">服务器用一个<code class="eh kc kd ke kf b">SYN-ACK</code>消息<a class="ae ka" href="https://dev.to/dangolant/things-i-brushed-up-on-this-week-the-http-request-lifecycle-#fn9" rel="noopener ugc nofollow" target="_blank"> ⁹ </a>进行响应，它包含一个用于原始消息的<em class="kb">确认号</em>总是<code class="eh kc kd ke kf b">x+1</code>，以及一个用于响应本身的新序列号，它是另一个随机数<code class="eh kc kd ke kf b">y</code>。</li><li id="8a1a" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">在第三步中，客户端向服务器发回一个序列号等于<code class="eh kc kd ke kf b">x+1</code>的<code class="eh kc kd ke kf b">ACK</code>消息<a class="ae ka" href="https://dev.to/dangolant/things-i-brushed-up-on-this-week-the-http-request-lifecycle-#fn10" rel="noopener ugc nofollow" target="_blank"> ⁰ </a>，该序列号应该与<code class="eh kc kd ke kf b">SYN-ACK</code>消息的确认号相匹配，并确保我们的数据被可靠地传送。<code class="eh kc kd ke kf b">ACK</code>消息的确认号(因为是<em class="kb">确认</em>和<code class="eh kc kd ke kf b">SYN-ACK</code>)被设置为比接收到的序列号或<code class="eh kc kd ke kf b">y+1</code>多1。</li><li id="ebf8" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">我们现在有了一个完整的三次握手和一个已建立的连接，其中客户端和服务器都收到了来自另一方的连接确认。该连接还为每个通信方向(客户端- &gt;服务器，服务器- &gt;客户端)建立了随机的顺序序列<a class="ae ka" href="https://dev.to/dangolant/things-i-brushed-up-on-this-week-the-http-request-lifecycle-#fn11" rel="noopener ugc nofollow" target="_blank"> 11 </a>，允许沿着该连接进行双向并发通信，这也被称为<a class="ae ka" href="https://en.wikipedia.org/wiki/Duplex_(telecommunications)#Full_duplex" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">全双工通信</strong> </a> <strong class="je hv">。</strong></li></ol></div><div class="ab cl km kn hc ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hn ho hp hq hr"><h2 id="a3a2" class="kt ku hu bd kv kw kx ky kz la lb lc ld jn le lf lg jr lh li lj jv lk ll lm ln dt translated">步骤4:发送一个HTTP请求</h2><p id="3e90" class="pw-post-body-paragraph jc jd hu je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz hn dt translated">哇，那是一堆台阶！但是现在客户机有了IP地址<em class="kb">和TCP连接</em>，它终于可以发送一个<a class="ae ka" href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" rel="noopener ugc nofollow" target="_blank"> <em class="kb"> HTTP </em> </a>请求了！除了…..不，我在开玩笑，这次我们真的可以发请求了！</p><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="fe ff mr"><img src="../Images/55a5ccee474f58eed7f3f80eb1004efb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PK-1bFVT0-x_03JL.png"/></div></div></figure><ol class=""><li id="b72a" class="lt lu hu je b jf jg jj jk jn lv jr lw jv lx jz ly lz ma mb dt translated">请求由“请求行”、请求头和请求体组成。“请求行”仅仅是一个指示HTTP <a class="ae ka" href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">方法</strong> </a>、被请求的资源和协议版本的行。请求的报头由形式为<code class="eh kc kd ke kf b">name:value &lt;CR&gt;&lt;LF&gt;</code>的对组成。两个连续的<code class="eh kc kd ke kf b">&lt;CR&gt;&lt;LF&gt;</code>对表示标题部分的结束。HTTP请求中唯一的必填字段是<code class="eh kc kd ke kf b">HOST</code>，它包含请求发送到的域和端口(<code class="eh kc kd ke kf b">domain.com:8080</code>，尽管在某些情况下可以省略端口。在主机字段之外，常见的标准HTTP头字段包括<code class="eh kc kd ke kf b">Origin</code>、<code class="eh kc kd ke kf b">Accept</code>、<code class="eh kc kd ke kf b">Accept-Encoding</code>等等。请求还可以包含任何非标准的头字段，历史上的非标准字段通过在字段名前加上前缀<code class="eh kc kd ke kf b">X-</code>来表示。HTTP请求的主体内容完全是可选的，但通常包含表单数据或JSON之类的内容。</li><li id="17be" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">一旦发送了HTTP请求，它将遵循与前面讨论的类似的路由过程，不同之处在于，使用TCPs神奇的序列号功能，服务器可以确保以正确的顺序接收整个请求。</li><li id="1bee" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">一旦服务器收到请求，处理它，并找到被请求的资源，它就生成一个HTTP响应。HTTP响应的结构与HTTP请求类似，包含“状态行”、响应头字段和可选的主体。状态行包含一个<a class="ae ka" href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" rel="noopener ugc nofollow" target="_blank"> <em class="kb"> HTTP状态代码</em> </a>，指示请求的成功、失败或错误状态，以及一个提供详细信息的“原因消息”。</li><li id="12d9" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">一旦生成响应，服务器就会响应请求。在TCP层，客户端接收第一个数据包，其第一个字节应该包含HTTP响应头。更多的数据包开始进入，在TCP层根据需要对它们进行重新排序。对于客户端在TCP层收到的每两个数据包，它都会向服务器发送一条<code class="eh kc kd ke kf b">ACK</code>消息。这种情况一直持续到响应(希望)被完全加载。</li></ol></div><div class="ab cl km kn hc ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hn ho hp hq hr"><h2 id="fe61" class="kt ku hu bd kv kw kx ky kz la lb lc ld jn le lf lg jr lh li lj jv lk ll lm ln dt translated">第五步:拆除和清理</h2><p id="e66b" class="pw-post-body-paragraph jc jd hu je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz hn dt translated"><strong class="je hv">我们就快到了！</strong></p><ol class=""><li id="bb76" class="lt lu hu je b jf jg jj jk jn lv jr lw jv lx jz ly lz ma mb dt translated">一旦响应被完全传递，客户端在TCP层发送一个<code class="eh kc kd ke kf b">FIN</code>包，服务器用一个<code class="eh kc kd ke kf b">ACK</code>响应，然后通常发送自己的<code class="eh kc kd ke kf b">FIN</code>，客户端用自己的<code class="eh kc kd ke kf b">ACK</code>信号响应。然后，客户端等待短暂的超时，在此期间它不能接受新的连接，以防止在端口上的后续活动期间来自先前连接的延迟数据包到达。这个<em class="kb">四路握手</em> <a class="ae ka" href="https://dev.to/dangolant/things-i-brushed-up-on-this-week-the-http-request-lifecycle-#fn12" rel="noopener ugc nofollow" target="_blank"> </a> <em class="kb"> </em>信号表示TCP连接的结束。</li><li id="41c6" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">此时，您的浏览器开始处理它收到的内容。如果是图像、数据或其他媒体文件被浏览器中的某个应用程序使用，可能会发生各种情况。如果收到的数据是HTML，浏览器将开始解析HTML，并呈现您请求的页面。在解析过程中，浏览器可能会遇到图片或其他媒体的链接，这些链接位于它接收到的HTML的外部，并且会对这些内容提出新的请求，重新开始整个过程(尽管由于缓存，通常会跳过步骤1和2)。但是，假设我们只对单个请求的生命周期感兴趣:我们(应用程序)的工作已经完成，恭喜！</li></ol></div><div class="ab cl km kn hc ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hn ho hp hq hr"><p id="1c7b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">同样，以上所有内容只是对简单HTTP事务的描述，而不是对持久事务的描述，持久事务将为多个请求保持相同的连接，但是除了TCP连接打开和交换第一个控制包时发生的行为之外，该模型没有太大的不同。它也没有涵盖并行HTTP事务，一旦第一个请求的连接建立，并行HTTP事务就会为后续请求建立额外的连接，但是生命周期并没有太大的变化。首先，这些其他方法有助于减轻您在阅读时可能注意到的问题:单个TCP连接的握手启动和拆除过程可能非常耗时，开发人员可以避免重复执行或连续执行它们。</p><p id="f647" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">好了，就是这样，这就是单个HTTP请求的多层生命周期！感谢您的阅读，请让我知道您的想法，如果您觉得需要任何更正，请联系我们！</p></div><div class="ab cl km kn hc ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hn ho hp hq hr"><p id="2e3a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="kb">原载于</em> <a class="ae ka" href="https://dev.to/dangolant/things-i-brushed-up-on-this-week-the-http-request-lifecycle-" rel="noopener ugc nofollow" target="_blank"> <em class="kb"> dev.to </em> </a> <em class="kb">。列表来源见</em> <a class="ae ka" href="https://dev.to/dangolant/things-i-brushed-up-on-this-week-the-http-request-lifecycle-" rel="noopener ugc nofollow" target="_blank"> <em class="kb">末</em> </a> <em class="kb">原帖。</em></p><figure class="mi mj mk ml fq iv"><div class="bz el l di"><div class="ms mt l"/></div></figure></div></div>    
</body>
</html>