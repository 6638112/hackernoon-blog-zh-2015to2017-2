<html>
<head>
<title>React.js Efficient Server Rendering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React.js高效服务器渲染</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/react-js-efficient-server-rending-5dcb2a0ae14a?source=collection_archive---------5-----------------------#2017-03-01">https://medium.com/hackernoon/react-js-efficient-server-rending-5dcb2a0ae14a?source=collection_archive---------5-----------------------#2017-03-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div class="fe ff hs"><img src="../Images/f78d51615ccebcd4f1101945a1cb4b68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*jhD-rWxuFvo17Q1Mw6LuEw.jpeg"/></div></figure><div class=""/><p id="3475" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">大约一年来，我一直在开发基于React.js的Web应用程序，令我惊讶的是，我编写的代码实际上可以与JSX组件而不是函数一起伸缩，这使得前端更加简单。</p><p id="a347" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">但在某些情况下，我们需要动态JSX内容的搜索引擎优化，或者我们需要更多的前端页面加载时间的性能。在这种情况下，脸书的开发人员以这种方式制作了React.js，因此它也可以在服务器端使用Node.js的基本功能进行渲染。</p><p id="7b2d" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所以流程和这个差不多</p><ol class=""><li id="db0e" class="jw jx ib ja b jb jc jf jg jj jy jn jz jr ka jv kb kc kd ke dt translated">客户端发送请求以获取一些JSX模板页面</li><li id="ef4b" class="jw jx ib ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke dt translated">Node.js服务器获取包含JSX代码的主文件</li><li id="4aa1" class="jw jx ib ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke dt translated">将其呈现为普通的HTML代码</li><li id="42fe" class="jw jx ib ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke dt translated">向客户端发送HTML响应</li><li id="ef24" class="jw jx ib ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke dt translated">使用HTML标记，然后客户端加载React.js客户端代码，用于向呈现的HTML添加动态逻辑</li></ol><p id="2741" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这有助于以比React更快的速度显示HTML内容，并且有助于向搜索引擎机器人或网站爬虫提供一些内容。</p><h1 id="e79e" class="kk kl ib bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">但是如果你没有Node呢？JS后端？</h1><p id="ff7e" class="pw-post-body-paragraph iy iz ib ja b jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv hn dt translated">当我开始从事大型项目时，这是我真正的追求。我决定把React.js作为前端，但是他们在后端有很多Python的东西，我不能仅仅为了服务器端渲染而重写所有代码。当时我找到了一些解决方案，将一些JS引擎嵌入到Python中，并将服务器端渲染交给Python，但是<code class="eh ln lo lp lq b">Seriously!! Do we need to embed JS to Python just for server side rendering?</code>我认为我们<strong class="ja ic">真的不需要！</strong></p><p id="f23c" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我有了一个想法，只为React.js JSX模板渲染建立独立的Node.js服务器，所以我可以向该服务器发出代理请求，它将为我渲染JSX内容，并将纯HTML响应回Python Django模板。<br/> <strong class="ja ic">这就像一个基本的JSX渲染的代理服务器。</strong></p><figure class="ls lt lu lv fq hw fe ff paragraph-image"><div class="fe ff lr"><img src="../Images/b2aa42d072b5ba4ec02f34668ab6fc99.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*9AZG5YUcLpotwNuxRTM0qw.png"/></div></figure><p id="7a65" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所以在几个小时的测试和破坏之后，我做了一个项目<a class="ae lw" href="https://github.com/tigranbs/proxy-render" rel="noopener ugc nofollow" target="_blank"> React.js代理渲染</a>，它拯救了我的项目，让我成为了提供更多性能的超级英雄。</p><h1 id="3a30" class="kk kl ib bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">代理渲染？那是什么？</h1><p id="7218" class="pw-post-body-paragraph iy iz ib ja b jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv hn dt translated">因此，利用代理请求的基本原理，我为Python编写了非常简单的代码</p><pre class="ls lt lu lv fq lx lq ly lz aw ma dt"><span id="a02c" class="mb kl ib lq b fv mc md l me mf">import requests<br/>import json<br/><br/><br/>PROXY_RENDER_ADDRESS = 'http://localhost:3000/'<br/><br/><br/>def get_html(filename, props):<br/>    try:<br/>        props_str = json.dumps(props)<br/>        r = requests.post(url=PROXY_RENDER_ADDRESS + filename<br/>                          , data=props_str<br/>                          , headers={'Content-Type': 'application/json'})<br/><br/>        if r.status_code == 200:<br/>            return r.text, props_str<br/>    except Exception as e:<br/>        print(e)<br/><br/>    return False, False</span></pre><p id="3279" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这基本上是将<code class="eh ln lo lp lq b">POST Request</code>转换为代理渲染服务，并通过将全局状态作为JSON传递，取回Node.js服务器渲染的HTML代码。</p><p id="791d" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所以我的主要优势是</p><ol class=""><li id="7596" class="jw jx ib ja b jb jc jf jg jj jy jn jz jr ka jv kb kc kd ke dt translated">不需要在后端集成Node.js，或者在Python中使用蹩脚的js引擎，这些引擎会占用大量内存</li><li id="8159" class="jw jx ib ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke dt translated">能够保持JSX模板缓存，这极大地改善了加载时间</li><li id="8f95" class="jw jx ib ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke dt translated">扩展后端服务，而不扩展基本渲染服务，因此您可以拥有多个具有单个缓存渲染服务的服务器，并获得更好的性能</li><li id="d4c9" class="jw jx ib ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke dt translated">编写代码的巨大灵活性。不，我知道我只需要将一个对象传递给代理渲染工具并接收HTML，我不需要担心JS中的状态变量或服务器端代码执行</li><li id="1ac9" class="jw jx ib ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke dt translated"><strong class="ja ic">最后，这是守护美丽的策略，分别移动不同的部分:)</strong></li></ol><h1 id="a356" class="kk kl ib bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">生产中的代理渲染</h1><p id="4d43" class="pw-post-body-paragraph iy iz ib ja b jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv hn dt translated">在生产代理渲染工具运行了近3个月，没有任何重新启动和内存，CPU使用率最低。第一次渲染页面平均需要600毫秒，但是第一次渲染之后，平均HTML响应时间是10毫秒，这是因为Node.js本身需要缓存和服务缓存。</p><p id="d5e4" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这个工具对我继续使用Python、Go、Ruby或Java进行开发帮助很大，但仍然使用花哨的前端框架和工具。希望你也不要待在Node.js监狱:)</p><div class="ls lt lu lv fq ab cb"><figure class="mg hw mh mi mj mk ml paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mg hw mh mi mj mk ml paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mg hw mh mi mj mk ml paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mm mn mo"><p id="f922" class="iy iz mp ja b jb jc jd je jf jg jh ji mq jk jl jm mr jo jp jq ms js jt ju jv hn dt translated"><a class="ae lw" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae lw" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae lw" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae lw" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="iy iz mp ja b jb jc jd je jf jg jh ji mq jk jl jm mr jo jp jq ms js jt ju jv hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lw" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lw" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ls lt lu lv fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="fe ff mt"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>