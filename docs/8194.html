<html>
<head>
<title>From CSV to Buxfer: an unexpected journey — Goxfer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从CSV到Buxfer:意想不到的旅程——go xfer</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/from-csv-to-buxfer-an-unexpected-journey-goxfer-88d8a14e8905?source=collection_archive---------19-----------------------#2017-11-22">https://medium.com/hackernoon/from-csv-to-buxfer-an-unexpected-journey-goxfer-88d8a14e8905?source=collection_archive---------19-----------------------#2017-11-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="8ed9" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">第4部分——Goxfer:关于在线推送交易数据集的故事</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/396c34049b543e47d8d4cffa5d0b19b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cCdSJ0mOqjQkm-soL5hlIw.jpeg"/></div></div></figure><h1 id="db32" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">序文</h1><p id="4527" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">在<a class="ae lj" rel="noopener" href="/@wilk/from-csv-to-buxfer-an-unexpected-journey-collector-4dbde92c1e7b">收集器-第3部分</a>中，我已经编写了收集器程序，将清理后的数据放入一个<a class="ae lj" href="https://hackernoon.com/tagged/mongodb" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>实例中。<br/>现在，是时候使用Buxfer的API将整个数据集放到网上了！</p><p id="aeeb" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated"><a class="ae lj" href="https://hackernoon.com/tagged/goxfer" rel="noopener ugc nofollow" target="_blank"> Goxfer </a>是一个从MongoDB中读取结构化数据，然后通过<a class="ae lj" href="http://buxfer.com/help/api" rel="noopener ugc nofollow" target="_blank"> Buxfer的API</a>将其推送到网上的程序。</p><h2 id="c2e2" class="lp jw hu bd jx lq lr ls kb lt lu lv kf kw lw lx kh la ly lz kj le ma mb kl mc dt translated">旅行</h2><p id="f1a4" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">在本文中，我将介绍这一旅程的第四部分:</p><ol class=""><li id="1a87" class="md me hu kp b kq lk kt ll kw mf la mg le mh li mi mj mk ml dt translated"><a class="ae lj" rel="noopener" href="/@wilk/from-csv-to-buxfer-an-unexpected-journey-introduction-ba43ef768fe2">第1部分:简介</a></li><li id="c586" class="md me hu kp b kq mm kt mn kw mo la mp le mq li mi mj mk ml dt translated"><a class="ae lj" href="https://hackernoon.com/from-csv-to-buxfer-an-unexpected-journey-cleaner-c87e8a77fda6" rel="noopener ugc nofollow" target="_blank">第二部分:清洁剂</a></li><li id="2dea" class="md me hu kp b kq mm kt mn kw mo la mp le mq li mi mj mk ml dt translated"><a class="ae lj" rel="noopener" href="/@wilk/from-csv-to-buxfer-an-unexpected-journey-collector-4dbde92c1e7b">第3部分:收集器</a></li><li id="ac79" class="md me hu kp b kq mm kt mn kw mo la mp le mq li mi mj mk ml dt translated">第四部分(本部分):Goxfer</li><li id="2263" class="md me hu kp b kq mm kt mn kw mo la mp le mq li mi mj mk ml dt translated"><a class="ae lj" rel="noopener" href="/@wilk/from-csv-to-buxfer-an-unexpected-journey-conclusions-b1274aa9841e">第5部分:结论</a></li></ol><h1 id="0c79" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">设置</h1><p id="c8f8" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">这个新程序将用GoLang编码:这意味着我需要构建一个定制的docker镜像，并通过最好的Go包管理器之一<a class="ae lj" href="https://github.com/Masterminds/glide" rel="noopener ugc nofollow" target="_blank"> <strong class="kp hv"> glide </strong> </a>安装任何依赖项。</p><p id="c42f" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">好了，从docker开始吧！<br/>首先，我需要更新<strong class="kp hv"> setup-golang </strong>服务来构建容器映像:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="960b" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">然后，构建图像并进入容器:</p><pre class="jk jl jm jn fq mt mu mv mw aw mx dt"><span id="172e" class="lp jw hu mu b fv my mz l na nb">$ docker-compose build setup-golang<br/>$ docker-compose run --rm setup-golang bash</span></pre><p id="a867" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">Goxfer需要一些依赖项，如<a class="ae lj" href="https://github.com/go-mgo/mgo/tree/v2" rel="noopener ugc nofollow" target="_blank"><strong class="kp hv">MgO</strong></a>(GoLang的MongoDB驱动程序)和<a class="ae lj" href="https://github.com/parnurzeal/gorequest" rel="noopener ugc nofollow" target="_blank"> <strong class="kp hv"> gorequest </strong> </a>(少数HTTP客户端):我必须用glide来获得它们，因为它将使用锁文件来跟踪它们，这对于在另一个系统上恢复项目非常有用。</p><pre class="jk jl jm jn fq mt mu mv mw aw mx dt"><span id="b0df" class="lp jw hu mu b fv my mz l na nb"># from inside the setup-golang container<br/>$ glide create<br/>$ glide get github.com/parnurzeal/gorequest<br/>$ glide get gopkg.in/mgo.v2</span></pre><p id="d9b2" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">用<strong class="kp hv"> glide创建</strong>两个新文件被添加到项目中:</p><ol class=""><li id="1945" class="md me hu kp b kq lk kt ll kw mf la mg le mh li mi mj mk ml dt translated">glide.yaml :这是glide清单，其中列出了所有的依赖项，并按照语义版本规范标记了固定版本</li><li id="06cf" class="md me hu kp b kq mm kt mn kw mo la mp le mq li mi mj mk ml dt translated"><strong class="kp hv"> glide.lock </strong>:这是一个锁文件，用于确保确定性恢复过程</li></ol><p id="12a0" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">使用<strong class="kp hv"> glide get </strong>将依赖项下载到新的本地<strong class="kp hv">供应商</strong>文件夹中，并添加到glide.yaml和glide.lock文件中。</p><p id="5191" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">现在，使用docker-compose可以在任何系统上恢复/初始化项目:</p><pre class="jk jl jm jn fq mt mu mv mw aw mx dt"><span id="0518" class="lp jw hu mu b fv my mz l na nb">$ docker-compose run --rm setup-golang</span></pre><h1 id="af18" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">手放在上面！</h1><p id="e925" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">那么，Goxfer要做什么呢？<br/>我们来定义一下程序流程:</p><ol class=""><li id="13a4" class="md me hu kp b kq lk kt ll kw mf la mg le mh li mi mj mk ml dt translated">连接到MongoDB</li><li id="8f1e" class="md me hu kp b kq mm kt mn kw mo la mp le mq li mi mj mk ml dt translated">初始化Buxfer的会话</li><li id="d99c" class="md me hu kp b kq mm kt mn kw mo la mp le mq li mi mj mk ml dt translated">检索Buxfer的帐户列表</li><li id="6f14" class="md me hu kp b kq mm kt mn kw mo la mp le mq li mi mj mk ml dt translated">从数据库中提取事务并构建事务的批量</li><li id="e445" class="md me hu kp b kq mm kt mn kw mo la mp le mq li mi mj mk ml dt translated">通过Buxfer的API在线推送批量交易</li></ol><p id="9942" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">我必须一步一步来锻造它。</p><h2 id="45e2" class="lp jw hu bd jx lq lr ls kb lt lu lv kf kw lw lx kh la ly lz kj le ma mb kl mc dt translated">数据库ˌ资料库</h2><p id="b85f" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">我需要编码的第一件事是数据库连接。<br/> <strong class="kp hv"> mgo </strong>是一个MongoDB驱动程序，它只需要数据库主机建立连接，加上数据库名称和它将查询的事务集合的名称。<br/>我需要将<strong class="kp hv"> docker-compose.yml </strong>中的那些信息定义为<strong class="kp hv"> goxfer服务</strong>的环境变量，已经在<a class="ae lj" href="https://hackernoon.com/from-csv-to-buxfer-an-unexpected-journey-introduction-ba43ef768fe2" rel="noopener ugc nofollow" target="_blank">第1部分</a>中起草:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="83e5" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">太好了！环境变量永远是从外部配置事物的最佳选择，<a class="ae lj" href="https://12factor.net/config" rel="noopener ugc nofollow" target="_blank">正如十二因子App教导的</a>。</p><p id="218c" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">现在，我必须使用mgo驱动程序来连接MongoDB。但是首先，我必须得到那些环境变量… <strong class="kp hv"> os。Getenv </strong>会帮我做的:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="5236" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">是时候创建MongoDB连接并获取事务集合了:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="e677" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">下一步需要数据库连接，所以如果执行失败，我必须停止程序:<a class="ae lj" href="https://golang.org/pkg/builtin/#panic" rel="noopener ugc nofollow" target="_blank"><strong class="kp hv"/></a>不会有问题。</p><h2 id="11a0" class="lp jw hu bd jx lq lr ls kb lt lu lv kf kw lw lx kh la ly lz kj le ma mb kl mc dt translated">巴克斯费尔会议</h2><p id="bbe5" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">Buxfer为每个执行的请求要求一个<strong class="kp hv">认证令牌</strong>；所以，在继续之前，我必须建立一个新的会话。我将使用gorequest，它是一个HTTP客户端，具有实用且易于使用的界面。<br/><a class="ae lj" href="https://www.buxfer.com/help/api#login" rel="noopener ugc nofollow" target="_blank">登录API </a>需要用户名和密码，所以我必须在docker-compose.yml文件中放置新的环境变量:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="b545" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">然后，我必须在Goxfer中执行HTTP请求:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="a7d2" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">当然，我还定义了<strong class="kp hv"> LoginResponse </strong>结构来存储登录响应。然后，我检查了lib和http错误:如果一切正常，那么我可以使用从响应中获取的令牌。</p><h2 id="c96b" class="lp jw hu bd jx lq lr ls kb lt lu lv kf kw lw lx kh la ly lz kj le ma mb kl mc dt translated">帐户列表</h2><p id="b89f" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">在进行交易之前，我需要获得帐户列表，因为稍后我将需要每个帐户的id。因此，现在，我只需要将支出和收入账户与它们的id对应起来:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="2698" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">同样在这里，我使用了gorequest来执行HTTP GET调用。<br/>buffer的API认证是通过会话令牌完成的，所以我将它附加到querystring ( <em class="nc">)。查询(" token=" + token) </em>)。<br/>然后，响应被存储在自定义结构<strong class="kp hv">accounts list response</strong>中:下一个步骤也需要这一步，所以如果至少出现了一个错误，我就会惊慌失措。如果一切顺利，我可以检查账目清单。我只有两个账户，所以控制权可以是独占的。</p><p id="2adc" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">现在，我需要用<strong class="kp hv"> EXPENSE_ACCOUNT_BUXFER </strong>和<strong class="kp hv"> INCOME_ACCOUNT_BUXFER </strong>常量更新docker-compose.yml文件，这样上面的代码就不会中断:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="d27a" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">太好了！<br/>继续前进！</p><h2 id="1e64" class="lp jw hu bd jx lq lr ls kb lt lu lv kf kw lw lx kh la ly lz kj le ma mb kl mc dt translated">交易的批量</h2><p id="7b1e" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">现在，我想做的是从MongoDB获取所有事务，然后<br/>将它们推送到Buxfer上。<br/>但是，有一个问题:Buxfer的API是有限的。事实上，每次只推送一个事务是可能的:<a class="ae lj" href="https://www.buxfer.com/help/api#add_transaction" rel="noopener ugc nofollow" target="_blank">https://www.buxfer.com/help/api#add_transaction</a><br/>嗯，我不想等到每个请求结束后再执行一个新的，也不想并行执行1000个调用。<br/>所以，我想我会选择每次20笔的批量交易。要做到这一点，我需要两样东西:</p><ol class=""><li id="76db" class="md me hu kp b kq lk kt ll kw mf la mg le mh li mi mj mk ml dt translated">将事务打包到一个矩阵中(<strong class="kp hv">批量数组</strong>(基本上是数组的数组))</li><li id="592c" class="md me hu kp b kq mm kt mn kw mo la mp le mq li mi mj mk ml dt translated">(ab)使用<a class="ae lj" href="https://gobyexample.com/goroutines" rel="noopener ugc nofollow" target="_blank"> <strong class="kp hv"> GoLang的goroutines </strong> </a>并行执行HTTP调用</li></ol><p id="fd25" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">每个bulk都有一个固定的大小，由环境变量<strong class="kp hv"> BULK_LENGTH </strong>定义，我将把它放在docker-compose.yml文件中:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="6493" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">现在，让我们定义从数据库获取交易并填充批量矩阵的过程:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="c1f9" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">开始时，事务存储在变量<strong class="kp hv"> results </strong>中，该变量是<strong class="kp hv">事务</strong>(事务的模型)的数组(GoLang中的<a class="ae lj" href="https://gobyexample.com/slices" rel="noopener ugc nofollow" target="_blank">片</a>)。然后，我通过将事务列表的长度除以BULK_LEN来计算填充事务矩阵的迭代次数。<br/>如果交易量不是BULK_LEN的倍数，则进行第二次迭代。</p><h2 id="4346" class="lp jw hu bd jx lq lr ls kb lt lu lv kf kw lw lx kh la ly lz kj le ma mb kl mc dt translated">推向巴克斯费尔</h2><p id="e72d" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">好了，这是<strong class="kp hv">最难的部分</strong>。<br/>正如我所说，我想推动20次交易的批量。这意味着我必须并行启动<strong class="kp hv"> 20个goroutines】，然后等待它们完成。全部都是。然后，我可以开始一个新的批量等等。</strong></p><p id="d91d" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated"><a class="ae lj" href="https://golang.org/pkg/sync/" rel="noopener ugc nofollow" target="_blank"> <strong class="kp hv"> sync </strong> </a>将帮助我处理并发的goroutines执行:在这个包中有<a class="ae lj" href="https://golang.org/pkg/sync/#WaitGroup" rel="noopener ugc nofollow" target="_blank"> <strong class="kp hv"> WaitGroup </strong> </a>，它基本上提供了三种方法:</p><ol class=""><li id="ce1c" class="md me hu kp b kq lk kt ll kw mf la mg le mh li mi mj mk ml dt translated"><a class="ae lj" href="https://golang.org/pkg/sync/#WaitGroup.Add" rel="noopener ugc nofollow" target="_blank">增加</a>:增加工人计数器</li><li id="8074" class="md me hu kp b kq mm kt mn kw mo la mp le mq li mi mj mk ml dt translated"><a class="ae lj" href="https://golang.org/pkg/sync/#WaitGroup.Wait" rel="noopener ugc nofollow" target="_blank">等待</a>:停止主线程，直到workers计数器等于零</li><li id="72fe" class="md me hu kp b kq mm kt mn kw mo la mp le mq li mi mj mk ml dt translated"><a class="ae lj" href="https://golang.org/pkg/sync/#WaitGroup.Done" rel="noopener ugc nofollow" target="_blank">完成</a>:减少工人计数器</li></ol><p id="3b33" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">所以，我要做的是:</p><ul class=""><li id="d51f" class="md me hu kp b kq lk kt ll kw mf la mg le mh li nd mj mk ml dt translated">通过批量矩阵循环</li><li id="ea5d" class="md me hu kp b kq mm kt mn kw mo la mp le mq li nd mj mk ml dt translated">然后，对于每一行(也称为bulk ),我必须通过增加bulk的长度来增加WaitGroup计数器</li><li id="c362" class="md me hu kp b kq mm kt mn kw mo la mp le mq li nd mj mk ml dt translated">然后，我需要遍历当前的批量数据，并为每个事务实例化一个新的goroutine，以将数据推送到Buxfer上</li><li id="0e90" class="md me hu kp b kq mm kt mn kw mo la mp le mq li nd mj mk ml dt translated">对于每个已经完成的goroutine，我需要通过Done方法递减WaitGroup计数器</li><li id="ac38" class="md me hu kp b kq mm kt mn kw mo la mp le mq li nd mj mk ml dt translated">最终，我不得不使用WaitGroup的Wait方法停止，直到整个批量操作完成，这样循环才能继续处理矩阵的下一行</li></ul><p id="703e" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">在这个过程中，我想存储已经添加了多少事务，还有多少没有添加。稍后我会记录这些信息。</p><p id="bf9c" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">下面是代码，除了对Buxfer的实际请求:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="d6b3" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">现在，最后要编写的是<strong class="kp hv"> addTransaction </strong>函数。<br/>这将是一个函数，如果在线推动交易时出错，它可能会返回一个错误，遵循<a class="ae lj" href="https://blog.golang.org/error-handling-and-go" rel="noopener ugc nofollow" target="_blank">GoLang如何将错误视为错误而不是异常</a>:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="51e8" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">简言之，HTTP请求有效负载由以下字段组成:</p><ul class=""><li id="dc7a" class="md me hu kp b kq lk kt ll kw mf la mg le mh li nd mj mk ml dt translated"><strong class="kp hv">描述</strong>:交易的描述</li><li id="d45e" class="md me hu kp b kq mm kt mn kw mo la mp le mq li nd mj mk ml dt translated"><strong class="kp hv">金额</strong>:交易金额</li><li id="b338" class="md me hu kp b kq mm kt mn kw mo la mp le mq li nd mj mk ml dt translated"><strong class="kp hv"> accountId </strong>:与之前提取的Buxfer账户列表匹配计算</li><li id="9d9f" class="md me hu kp b kq mm kt mn kw mo la mp le mq li nd mj mk ml dt translated"><strong class="kp hv">标签</strong>:转换成逗号分隔字符串的交易标签</li><li id="944b" class="md me hu kp b kq mm kt mn kw mo la mp le mq li nd mj mk ml dt translated"><strong class="kp hv">日期</strong>:采用<strong class="kp hv"> YYYY-MM-DD </strong>格式的日期</li><li id="612c" class="md me hu kp b kq mm kt mn kw mo la mp le mq li nd mj mk ml dt translated"><strong class="kp hv">令牌</strong>:会话令牌</li><li id="273c" class="md me hu kp b kq mm kt mn kw mo la mp le mq li nd mj mk ml dt translated"><strong class="kp hv">类型</strong>:交易的类型，计算方式与accountId相同</li></ul><p id="c2f3" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">然后发出请求，并将响应存储在新结构<strong class="kp hv"> AddResponseBody </strong>中:如果没有发生错误，它将返回<strong class="kp hv"> nil </strong>。</p><p id="9ef2" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">把所有东西放在一起(在github上因为太长无法在这里展示):<a class="ae lj" href="https://github.com/wilk/from-csv-to-buxfer/blob/master/go/src/goxfer.go" rel="noopener ugc nofollow" target="_blank">https://github . com/wilk/from-CSV-to-buxfer/blob/master/go/src/goxfer . go</a></p><h2 id="3eaa" class="lp jw hu bd jx lq lr ls kb lt lu lv kf kw lw lx kh la ly lz kj le ma mb kl mc dt translated">快跑，伙计！</h2><p id="86b3" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">最后一步:启动它🚀！</p><pre class="jk jl jm jn fq mt mu mv mw aw mx dt"><span id="e080" class="lp jw hu mu b fv my mz l na nb">$ docker-compose run --rm goxfer</span></pre><p id="d3c0" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">(美)雅皮士(属于中上阶层的年轻专业人士)🎉</p><h1 id="5f46" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">第4部分结束</h1><p id="177e" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">哇，这最后一部分很难😵这需要大量的工作和测试。事实上，最初在Buxfer上添加交易的API是不同的(<strong class="kp hv">和bugged </strong>)，它在10月底进行了更改(<strong class="kp hv">并修复了</strong>)。我不得不修改源代码，在运行程序安全之前，用<a class="ae lj" href="https://www.getpostman.com/" rel="noopener ugc nofollow" target="_blank"> PostMan </a>和<a class="ae lj" href="https://curl.haxx.se/" rel="noopener ugc nofollow" target="_blank"> curl </a>执行新的测试。</p><p id="a30b" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">然而，即使我事先测试了所有东西，我还是得到了这个:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ne"><img src="../Images/bb4eb0f7329259fa7257c98b08600fdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j04Aeb962oBC4ncdvGsrbw.png"/></div></div></figure><p id="918f" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">无话可说。我意识到了这个缺陷(事实上，我没有准备任何日志来跟踪未刷新的事务)，但是我还是想尝试一下，把我所有的信任都投入到我之前做的手工测试中。这需要我手动在成千上万的日志中搜索:这很痛苦，但这是我应得的，所以没关系😬</p><p id="4f1d" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">但是现在，<strong class="kp hv">我已经把我2016年的所有交易都放在Buxfer </strong>上了🎉<br/>我想在这部分花更多的话，但我会在下一部分:<a class="ae lj" rel="noopener" href="/@wilk/from-csv-to-buxfer-an-unexpected-journey-conclusions-b1274aa9841e"> <strong class="kp hv">结论</strong> </a>！</p><p id="fd54" class="pw-post-body-paragraph kn ko hu kp b kq lk iv ks kt ll iy kv kw lm ky kz la ln lc ld le lo lg lh li hn dt translated">如果你喜欢这篇文章，不要忘记分享它！<br/>第五部分:结论见！</p></div><div class="ab cl nf ng hc nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="hn ho hp hq hr"><h2 id="c6d6" class="lp jw hu bd jx lq lr ls kb lt lu lv kf kw lw lx kh la ly lz kj le ma mb kl mc dt translated">来源</h2><p id="4bab" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">源代码可以在这里找到:<a class="ae lj" href="https://github.com/wilk/from-csv-to-buxfer" rel="noopener ugc nofollow" target="_blank">https://github.com/wilk/from-csv-to-buxfer</a></p><h2 id="1589" class="lp jw hu bd jx lq lr ls kb lt lu lv kf kw lw lx kh la ly lz kj le ma mb kl mc dt translated">更新</h2><p id="c73f" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">我改进了未清空的事务日志，发现其中一个原始事务被破坏了:它的日期是<strong class="kp hv"> 29/11/1898 </strong>，这就是Buxfer拒绝接受它的原因。总之，清洁工、清洁工和搬运工完成了工作，而且他们做得很好！</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nm ms l"/></div></figure></div></div>    
</body>
</html>