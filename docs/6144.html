<html>
<head>
<title>Root level slugs for multiple controllers with FriendlyId</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有FriendlyId的多个控制器的根级slugs</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/root-level-slugs-for-multiple-controllers-with-friendlyid-1a4a7ba03ec1?source=collection_archive---------12-----------------------#2017-09-05">https://medium.com/hackernoon/root-level-slugs-for-multiple-controllers-with-friendlyid-1a4a7ba03ec1?source=collection_archive---------12-----------------------#2017-09-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="0be6" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">FriendlyId gem可以让你的应用程序与“友好的”URL slugs一起工作，如“myapp /cities/amsterdam”。您可以将slug映射到根路径，但是如果您有两个包含友好slug的资源，并且您希望它们都在根路径中，该怎么办呢？</h1><p id="62e3" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">最近我在为<a class="ae kn" href="http://www.womenwhocode.com" rel="noopener ugc nofollow" target="_blank">women hocode</a>做网站时遇到了这个问题。这是我们解决方案的基本版本。</p><p id="8c29" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">我们希望实现应用程序可以在根级别为2个不同且不相关的资源使用带有slugs的URL，让我们将它们命名为<code class="eh kt ku kv kw b">City</code>和<code class="eh kt ku kv kw b">Flower</code>。代替像<code class="eh kt ku kv kw b">myapp/cities/amsterdam,</code>这样的URL，我们希望两个资源都在根级别上，这样应用程序就可以使用<code class="eh kt ku kv kw b">myapp/amsterdam</code> <em class="kx">和</em> <code class="eh kt ku kv kw b">myapp/tulips</code>。</p><h2 id="588b" class="ky is hu bd it kz la lb ix lc ld le jb ka lf lg jf ke lh li jj ki lj lk jn ll dt translated">基本设置友好ID</h2><p id="a2ce" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">在我们开始之前，快速提醒一下基本的FriendlyId设置:</p><figure class="lm ln lo lp fq lq"><div class="bz el l di"><div class="lr ls l"/></div></figure><blockquote class="lt lu lv"><p id="3dc7" class="jp jq kx jr b js ko ju jv jw kp jy jz lw kq kc kd lx kr kg kh ly ks kk kl km hn dt translated">对于5.2.1之前的Rails 5.1+和FriendlyId版本:<br/>在运行迁移之前，进入生成的迁移文件并指定Rails版本:<br/> <code class="eh kt ku kv kw b">class CreateFriendlyIdSlugs &lt; ActiveRecord::Migration<strong class="jr hv">[5.1]</strong></code></p></blockquote><p id="62d6" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">我们解决方案的关键是带有<code class="eh kt ku kv kw b">friendly_id_slugs</code>表的<code class="eh kt ku kv kw b">:history</code>模块，它是由friendly_id生成器(6^).行)生成的该表有一个<code class="eh kt ku kv kw b">slugs</code>列，还有一个<code class="eh kt ku kv kw b">sluggable_type</code>和<code class="eh kt ku kv kw b">sluggable_id</code>。sluggable _ type以slug所属的资源命名。看到了吗？这在以后会派上用场的！</p><p id="53fa" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">设置好FriendlyId后，我们就可以使用gem的<code class="eh kt ku kv kw b">finder</code>方法了。给定一个有<code class="eh kt ku kv kw b">id: 123</code>的东西<code class="eh kt ku kv kw b">:something</code>，我们可以友好地找到它们；<code class="eh kt ku kv kw b">Thing.friendly.find(params[:id])</code>会返回我们的<code class="eh kt ku kv kw b">something</code>无论我们传入的是slug还是<code class="eh kt ku kv kw b">id</code>。因此应用程序可以同时使用<code class="eh kt ku kv kw b">/things/something</code>和<code class="eh kt ku kv kw b">things/123</code>。</p><p id="987d" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">对于本文，我们使用friendly_id默认值；查看文档中的调整和提示。</p><h2 id="79dd" class="ky is hu bd it kz la lb ix lc ld le jb ka lf lg jf ke lh li jj ki lj lk jn ll dt translated">目标</h2><p id="955a" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">通过<code class="eh kt ku kv kw b">resources: flowers</code>照常设置路由，显示视图通过<code class="eh kt ku kv kw b">myapp/flowers/tulip</code>指向。但是现在我们想要根级别的鼻涕虫:<code class="eh kt ku kv kw b">myapp/tulip</code>。</p><p id="e233" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">对于单个控制器，我们可以通过在路线中添加<code class="eh kt ku kv kw b">path</code>选项来实现:</p><pre class="lm ln lo lp fq lz kw ma mb aw mc dt"><span id="cc03" class="ky is hu kw b fv md me l mf mg"># one controller root level slug<br/># routes.rb </span><span id="754b" class="ky is hu kw b fv mh me l mf mg">resources :flowers, only: :show, path: '' </span></pre><p id="859c" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">…然后<code class="eh kt ku kv kw b">/myapp/tulip</code>转到<code class="eh kt ku kv kw b">flowers</code>控制器的<code class="eh kt ku kv kw b">#show</code>动作</p><p id="b599" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">到目前为止没问题。<strong class="jr hv">但是现在我们要的是</strong> <code class="eh kt ku kv kw b"><strong class="jr hv">flowers</strong></code> <strong class="jr hv">鼻涕虫<em class="kx">和</em></strong><code class="eh kt ku kv kw b"><strong class="jr hv">cities </strong></code><strong class="jr hv">鼻涕虫的根层次。</strong></p><p id="26b8" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">如果我们为<code class="eh kt ku kv kw b">cities</code>添加第二个路由声明，也是用<code class="eh kt ku kv kw b">path:''</code>，那么Rails路由器不知道它应该指向flowers控制器还是city控制器。实际上:因为路线是按照它们在<code class="eh kt ku kv kw b">routes.rb,</code>中出现的顺序执行的，所以它总是指向首先列出的控制器。所以，如果花路线出现在城市路线之前，用<code class="eh kt ku kv kw b">myapp/amsterdam</code>，是<em class="kx">花</em>控制器介入并试图用<code class="eh kt ku kv kw b">:slug </code>参数找到a _flower_而不是我们要找的城市。</p><h2 id="dfd7" class="ky is hu bd it kz la lb ix lc ld le jb ka lf lg jf ke lh li jj ki lj lk jn ll dt translated">行动计划:SlugsController</h2><p id="37b5" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">解决方案:我们将添加一个新的SlugsController，而不是使用资源自己的控制器。我们将不会使用资源表，而是使用friendly_id_slugs表来查找正确的记录并呈现其显示视图(步骤1)。我们将把根级slugs路由到这个新方法(步骤2)。为了更好的用户界面(和消毒？)我们将规范化用户输入(步骤3)。最后，我们需要确保slug不仅对于它自己的模型是唯一的，而且对于共享根级别slug的其他模型也是唯一的。为此，我们需要一个定制的唯一性验证器(步骤5)，由数据库约束支持(步骤6)。</p><p id="c3c5" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">计划是这样的:</p><ol class=""><li id="c72c" class="mi mj hu jr b js ko jw kp ka mk ke ml ki mm km mn mo mp mq dt translated">创建(或<code class="eh kt ku kv kw b">generate</code>)一个具有<code class="eh kt ku kv kw b">:show</code>动作的SlugsController，它使用friendly_id_slugs表及其<code class="eh kt ku kv kw b">sluggable_type</code>字段来区分<code class="eh kt ku kv kw b">flowers</code>和<code class="eh kt ku kv kw b">cities</code>，并呈现视图。</li><li id="0a56" class="mi mj hu jr b js mr jw ms ka mt ke mu ki mv km mn mo mp mq dt translated">将根级slugs指向新的SlugsController</li><li id="640d" class="mi mj hu jr b js mr jw ms ka mt ke mu ki mv km mn mo mp mq dt translated">规范化用户输入</li><li id="82f2" class="mi mj hu jr b js mr jw ms ka mt ke mu ki mv km mn mo mp mq dt translated">为两个模型的slugs的唯一性创建一个定制的验证器</li><li id="65b9" class="mi mj hu jr b js mr jw ms ka mt ke mu ki mv km mn mo mp mq dt translated">添加数据库约束</li></ol><h2 id="4cd1" class="ky is hu bd it kz la lb ix lc ld le jb ka lf lg jf ke lh li jj ki lj lk jn ll dt translated">步骤1 - Slugs控制器找到正确的记录</h2><figure class="lm ln lo lp fq lq"><div class="bz el l di"><div class="lr ls l"/></div></figure><p id="f40b" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">这里发生了什么？首先，我们在<code class="eh kt ku kv kw b">friendly_id_slugs</code>表(L4)中找到<code class="eh kt ku kv kw b">slug</code>记录。</p><p id="5aef" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">现在我们已经可以访问<code class="eh kt ku kv kw b">sluggable_type,</code>了，我们使用类型来区分<code class="eh kt ku kv kw b">:render_view </code>方法(L19)中的模型。然后，我们使用friendly_id finder方法来设置ivar并呈现视图。正确的ivar被一起发送，因此视图可以使用它，我们不必通过资源自己的控制器。</p><p id="a9f8" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">但是，这在当前的路线上是行不通的，所以让我们来解决这个问题。</p><h2 id="00ed" class="ky is hu bd it kz la lb ix lc ld le jb ka lf lg jf ke lh li jj ki lj lk jn ll dt translated">步骤2 -将废料发送到新的废料控制器</h2><figure class="lm ln lo lp fq lq"><div class="bz el l di"><div class="lr ls l"/></div></figure><p id="d0a8" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">这里，我们将slugs指向slugs控制器中的show动作。常规航线排在第一位，以保持像<code class="eh kt ku kv kw b">/myapp/cities</code>这样的航线运行。<br/>如果你碰巧有命名空间的路线，比如<code class="eh kt ku kv kw b">/admin/flowers</code>，确保把它们放在routes文件中更高的位置，否则slugs控制器会去寻找一朵花或者一个叫做‘admin’的城市。</p><blockquote class="lt lu lv"><p id="9cf1" class="jp jq kx jr b js ko ju jv jw kp jy jz lw kq kc kd lx kr kg kh ly ks kk kl km hn dt translated">为了实现这一点，请确保检查原始的显示操作。在那里设置的任何ivar，或者在ivar上执行的任何逻辑，在视图中都不可用。在我们的例子中，这意味着我们需要重构show动作，最终得到一个漂亮干净的oneliner: <code class="eh kt ku kv kw b">@city = City.friendly.find(params[:id]<br/></code>剩下的部分被转移到视图助手、模型中的范围和实例方法。</p></blockquote><p id="9080" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">现在，让我们确保我们只接受像FriendlyId格式的slug。</p><h2 id="7f3a" class="ky is hu bd it kz la lb ix lc ld le jb ka lf lg jf ke lh li jj ki lj lk jn ll dt translated">步骤3 -规范化用户输入</h2><figure class="lm ln lo lp fq lq"><div class="bz el l di"><div class="lr ls l"/></div></figure><p id="87c8" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">normalizer方法去掉所有非单词字符，加上<code class="eh kt ku kv kw b">—</code>，因为FriendlyId使用它作为单词分隔符。regex中的<code class="eh kt ku kv kw b">\w</code>匹配字母、数字和下划线。</p><p id="596b" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">我们将规范化的字符串存储在<code class="eh kt ku kv kw b">@slug_params</code>中。有了这里设置的ivar，我们就不再需要<code class="eh kt ku kv kw b">:slug_params</code>方法了，所以我们跳过它，把所有的<code class="eh kt ku kv kw b">slug_params</code>都改成<code class="eh kt ku kv kw b">@slug_params</code> (L6，还有<code class="eh kt ku kv kw b">render_view</code>方法中的2次)。</p></div><div class="ab cl mw mx hc my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="hn ho hp hq hr"><p id="f521" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">路由和渲染工作正常。还有一件事要做:验证子弹的独特性。我们不希望一株名为“阿姆斯特丹”的郁金香被允许使用“阿姆斯特丹”这个鼻涕虫，如果这个鼻涕虫已经被用于“阿姆斯特丹”这个城市的话。</p><h2 id="27b0" class="ky is hu bd it kz la lb ix lc ld le jb ka lf lg jf ke lh li jj ki lj lk jn ll dt translated">步骤4 -验证所有slugs的唯一性:每个验证器</h2><p id="1dfc" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">模型中常规的Rails唯一性验证器将确保一个资源的slugs是唯一的。但是我们有一个额外的要求，因为我们使用了“双路由”。与FriendlyId的默认行为相反，我们的花蛞蝓不能与现有的城市蛞蝓相同。</p><p id="b37d" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">因此，我们将创建一个定制的验证器来验证两个模型的唯一性。我们将在每个模型中使用这个验证器。</p><figure class="lm ln lo lp fq lq"><div class="bz el l di"><div class="lr ls l"/></div></figure><p id="995f" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated"><a class="ae kn" href="http://api.rubyonrails.org/v3.2/classes/ActiveModel/EachValidator.html" rel="noopener ugc nofollow" target="_blank"> EachValidator </a>是验证属性的方法。它需要实现一个<code class="eh kt ku kv kw b">validate_each</code>方法。我使无效slugs的消息与标准唯一性验证的消息相同。<br/><code class="eh kt ku kv kw b">valid_slug?</code>方法(L10)迭代带有模型名称的数组。我们需要模型<em class="kx">常量</em>，而不是模型名称，所以我们<code class="eh kt ku kv kw b">constantize</code>字符串。</p><p id="e938" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">然后(L13)我们使用FriendlyId::FinderMethods模块中的谓词方法来检查每个模型中是否存在slug。我对<code class="eh kt ku kv kw b">return false if-</code> <a class="ae kn" href="https://hackernoon.com/tagged/statement" rel="noopener ugc nofollow" target="_blank">语句</a>不是特别满意，但是现在，我更喜欢它，主要是为了可读性。</p><p id="0b00" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">只要有匹配，我们就退出循环，因为任何匹配都会使新的slug无效。在我们的例子中，其中一个模型比另一个模型有更多的记录；该型号在数组中排在最后(L4)。</p><p id="b6ed" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">我们在两个模型中都称这个验证器为:</p><pre class="lm ln lo lp fq lz kw ma mb aw mc dt"><span id="868f" class="ky is hu kw b fv md me l mf mg">#in flower.rb and city.rb: </span><span id="023d" class="ky is hu kw b fv mh me l mf mg">validates :slug, presence: true, <strong class="kw hv">slug: true</strong>, if: :slug_changed?</span></pre><p id="c2a1" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated"><code class="eh kt ku kv kw b">slug:true</code>是对自定义SlugValidator的实际调用。只有当废料浆发生变化时，它才会被触发。在示例项目中，这仅发生在<code class="eh kt ku kv kw b">:create</code>；在实际项目中，这需要微调。</p><h2 id="68b2" class="ky is hu bd it kz la lb ix lc ld le jb ka lf lg jf ke lh li jj ki lj lk jn ll dt translated">步骤5 -添加数据库约束</h2><p id="9a7b" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我从这个问题中学到的一个有价值的教训是用数据库约束来支持惟一性验证。当两个用户同时添加相同的slug时，Rails验证可能会通过。在这种情况下，我们希望<a class="ae kn" href="https://hackernoon.com/tagged/database" rel="noopener ugc nofollow" target="_blank">数据库</a>防止相同的slugs都被保存。</p><p id="2544" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">我们已经有了每个模型的数据库约束(见上面，第一个要点，L7 &amp; 8)。我们所要做的就是为friendly_id_slugs表添加一个惟一的索引。(注意拼写<code class="eh kt ku kv kw b">uniq</code>。)</p><pre class="lm ln lo lp fq lz kw ma mb aw mc dt"><span id="6ee8" class="ky is hu kw b fv md me l mf mg"># in terminal:</span><span id="a85c" class="ky is hu kw b fv mh me l mf mg">$ rails g migration AddIndexToFriendlyIdSlugs slug:<strong class="kw hv">uniq</strong></span><span id="dbc1" class="ky is hu kw b fv mh me l mf mg"># don't migrate yet</span></pre><p id="1799" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">这将创建迁移文件。拆下<code class="eh kt ku kv kw b">add_column</code>线。</p><pre class="lm ln lo lp fq lz kw ma mb aw mc dt"><span id="71ae" class="ky is hu kw b fv md me l mf mg"># in db/migrate/2017...._add_index_to_friendly_id_slugs.rb</span><span id="aabb" class="ky is hu kw b fv mh me l mf mg"><strong class="kw hv">class <em class="kx">AddIndexToFriendlyIdSlugs </em></strong>&lt; <strong class="kw hv"><em class="kx">ActiveRecord</em></strong>::<strong class="kw hv"><em class="kx">Migration</em></strong>[5.1]<strong class="kw hv"><br/>  def </strong><em class="kx">change<br/>    # remove the following line: <br/>    add_column </em>:friendly_id_slugs, :slug, :string<strong class="kw hv"><br/>    <br/>    </strong><em class="kx">add_index </em><strong class="kw hv">:friendly_id_slugs</strong>, <strong class="kw hv">:slug</strong>, <strong class="kw hv">unique</strong>: <strong class="kw hv">true<br/>  end</strong></span><span id="9d40" class="ky is hu kw b fv mh me l mf mg"># then run <br/>$ rails db:migrate</span></pre><p id="21a6" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">从变更方法中移除冗余行并迁移后，以下索引被添加到<code class="eh kt ku kv kw b">db/schema.rb</code>:</p><pre class="lm ln lo lp fq lz kw ma mb aw mc dt"><span id="dde5" class="ky is hu kw b fv md me l mf mg"><em class="kx">t</em>.index [<strong class="kw hv">"slug"</strong>], <strong class="kw hv">name</strong>: <strong class="kw hv">"index_friendly_id_slugs_on_slug"</strong>, <strong class="kw hv">unique</strong>: <strong class="kw hv">true</strong></span></pre></div><div class="ab cl mw mx hc my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="hn ho hp hq hr"><p id="463a" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">最后一步，我们的根级slug系统已经就绪。这么🎉！</p><p id="736f" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">为了简化示例项目，我们使用默认的FriendlyId。请务必查看文档并阅读其他示例，以便为您的用户提供更好的体验。<br/>完整样本项目:<a class="ae kn" href="https://github.com/F3PiX/slugs_example" rel="noopener ugc nofollow" target="_blank">https://github.com/F3PiX/slugs_example</a></p><p id="18cb" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated"><strong class="jr hv">谢谢各位代码和文字评审:</strong> <a class="nd ne gr" href="https://medium.com/u/35f228a3e290?source=post_page-----1a4a7ba03ec1--------------------------------" rel="noopener" target="_blank">扎斯敏</a><a class="nd ne gr" href="https://medium.com/u/76884823fc9d?source=post_page-----1a4a7ba03ec1--------------------------------" rel="noopener" target="_blank">珍妮·索特伍德</a>和托尼(推特:@托尼)。<br/>感谢Pablo Rivera关于技术帖子的鼓舞人心的故事:<a class="ae kn" href="https://dev.to/yelluw/how-to-do-technical-blogging" rel="noopener ugc nofollow" target="_blank">https://dev.to/yelluw/how-to-do-technical-blogging</a>我用这些技巧写了这篇帖子。</p><p id="6103" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">阅读更多信息:</p><ul class=""><li id="34f0" class="mi mj hu jr b js ko jw kp ka mk ke ml ki mm km nf mo mp mq dt translated">friendly id:<a class="ae kn" href="https://github.com/norman/friendly_id" rel="noopener ugc nofollow" target="_blank">https://github.com/norman/friendly_id</a></li><li id="eb0d" class="mi mj hu jr b js mr jw ms ka mt ke mu ki mv km nf mo mp mq dt translated">一篇关于开始并微调friendly_id的好文章:<a class="ae kn" href="http://vaidehijoshi.github.io/blog/2015/12/15/youve-got-a-friend-in-friendly-id/" rel="noopener ugc nofollow" target="_blank">http://vaidehijoshi . github . io/blog/2015/12/15/youve-get-a-friend-in-friend-id/</a></li><li id="3d4d" class="mi mj hu jr b js mr jw ms ka mt ke mu ki mv km nf mo mp mq dt translated">RailsCast:过时，但永远是一种乐趣:<a class="ae kn" href="http://railscasts.com/episodes/314-pretty-urls-with-friendlyid?view=asciicast" rel="noopener ugc nofollow" target="_blank">http://rails casts . com/episodes/314-pretty-URLs-with-friendly id？view = ascicast</a></li><li id="fcb6" class="mi mj hu jr b js mr jw ms ka mt ke mu ki mv km nf mo mp mq dt translated">关于验证和约束:(短:<a class="ae kn" href="https://stackoverflow.com/questions/2367281/ruby-on-rails-is-it-better-to-validate-in-the-model-or-the-database" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/2367281/ruby-on-rails-it-better-to-validate-in-the-model-or-the-database</a>；long:<a class="ae kn" href="https://robots.thoughtbot.com/validation-database-constraint-or-both" rel="noopener ugc nofollow" target="_blank">https://robots . thoughtbot . com/validation-database-constraint-or-both</a></li></ul><p id="bfb3" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">对文本或代码有问题或意见吗？我很想收到你的来信！</p><figure class="lm ln lo lp fq lq"><div class="bz el l di"><div class="ng ls l"/></div></figure></div></div>    
</body>
</html>