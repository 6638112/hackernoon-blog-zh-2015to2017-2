<html>
<head>
<title>What Characteristics My Services Should Possess</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我的服务应该具备什么特征</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/what-characteristics-my-services-should-possess-ca22294bbea6?source=collection_archive---------6-----------------------#2017-06-28">https://medium.com/hackernoon/what-characteristics-my-services-should-possess-ca22294bbea6?source=collection_archive---------6-----------------------#2017-06-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="2cd0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在上一篇文章中，我列出了你不应该使用的分割方法。但是在正确分割它之前，我想回答以下问题:它们应该有什么性质？你可以用无数种方式划分你的系统，但是你应该只选择一种。要做出这个决定，你需要明白你应该遵循哪些原则。为了做到这一点，你需要意识到你想要达到的目标，也就是说，你的服务应该具备什么样的特征。</p></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><h2 id="a8b1" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">低耦合</h2><p id="067a" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">你已经看到了错误的整块石头分裂的<a class="ae jp" rel="noopener" href="/@wrong.about/wrong-ways-of-defining-service-boundaries-d9e313007bcc">例子</a>。这些例子共有的问题是什么？它是紧密耦合的，这正是我试图用<a class="ae jp" rel="noopener" href="/@wrong.about/why-you-should-split-the-monolith-e946f57db38c">来摆脱</a>的原因:如果你需要修改一个服务，很可能你必须修改更多的服务。伴随着低耦合的通常是高内聚。当耦合紧密时，内聚力较低。有趣的是，反过来也是正确的，但是有一点要注意:有了正确的服务粒度，高内聚就会导致松散耦合。这不是公认的事实或规则，这只是我的观察。我用它来寻找服务边界，服务是松散耦合的。对我个人来说，这更简单，因为“松散耦合”的概念似乎太短暂了，不能用作识别服务边界的灯塔。</p><h2 id="5630" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">高内聚力</h2><p id="6bff" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">在一个整体中，内聚力很低，因为一个整体，一段代码完成了所有的事情。如果你使用我在“<a class="ae jp" rel="noopener" href="/@wrong.about/wrong-ways-of-defining-service-boundaries-d9e313007bcc">错误的重用</a>一章中描述的方法来分割你的整体，内聚性也很低，尽管所有这些服务都是考虑到这种能力而创建的。例如，通常的思维模式是“好吧，票务服务包含了所有与票相关的逻辑。为什么没有凝聚力？”。问题是“所有的逻辑”是一个非常模糊的概念。它只是一组与票据相关的功能<em class="kx"/>，在票据的整个生命周期中被其他服务使用。这种票务服务本质上不可能是内聚的。<br/>这类似于我围绕设计模式将项目分成模块:单件、工厂、策略等等。另一种方法是围绕程序结构分割系统:类、接口、对象(如果语言支持的话)等。而应该遵循的原则是语义。属于一个<a class="ae jp" href="https://hackernoon.com/how-to-decompose-a-system-into-modules-796bd941f036" rel="noopener ugc nofollow" target="_blank">模块</a>的类被一起使用，形成一个连贯的功能块，讲述领域。这就是模块的用途，这就是它们的用途。谈到服务一致性，我记得同样的方法——“功能的一致性”。也许我应该从它开始，但是，尽管如此，为了以防万一，让我们消除所有的疑虑，澄清“凝聚力”这个词。这就是<a class="ae jp" href="https://en.wikipedia.org/wiki/Cohesion_(computer_science)" rel="noopener ugc nofollow" target="_blank">维基百科</a>对此的看法:</p><blockquote class="ky kz la"><p id="eb67" class="ir is kx it b iu iv iw ix iy iz ja jb lb jd je jf lc jh ji jj ld jl jm jn jo hn dt translated">(…)内聚性度量给定模块中功能块之间的关系强度。例如，在高度内聚的系统中，功能是紧密相关的。</p></blockquote><p id="a07c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是我努力的方向。</p><h2 id="dc9f" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">正确的粒度</h2><p id="02f4" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">我使用的方法是基于从Eric Evans的书<a class="ae jp" href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215" rel="noopener ugc nofollow" target="_blank">领域驱动设计:解决软件核心的复杂性</a>中得到的<a class="ae jp" href="https://martinfowler.com/bliki/BoundedContext.html" rel="noopener ugc nofollow" target="_blank">有界上下文</a>的概念。<br/>如果我在服务代码中使用的一些概念变得模糊不清(<em class="kx">客户</em>是浏览页面的人还是已经购买的人？)，如果相同的概念被用在语义上非常不同的地方，这些地方对不同的数据和行为感兴趣(购买时的“订单”和交付时的“订单”)，或者相同的实体在其生命周期的每个阶段都反映了一些领域概念(这两个例子都是有效的)，那么服务可能太粗粒度了，并且其内聚性很低。我强烈建议将它进一步分割，以获得更有凝聚力的部分。一旦我们获得了具有单语义有界上下文的服务，其中每个概念都是明确的——您就大功告成了。不需要进一步分裂。</p><h2 id="213f" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">高度自治</h2><p id="b912" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">低耦合导致完全概念性的服务自治。我所说的自治是指服务完成工作的能力不依赖于其他服务的可用性。服务为了完成它的工作既不需要其他服务的功能也不需要其他服务的数据。此外，服务可能甚至不知道其他服务(在大多数情况下也不应该知道)。服务自治体现在服务存储数据的方式以及它们相互通信的方式上。但是它当然不会自己来。您应该通过识别正确的服务边界来有意识地遵循自治，但是您不会对花费的时间感到遗憾，因为高自治带来高<a class="ae jp" rel="noopener" href="/@wrong.about/why-you-should-split-the-monolith-e946f57db38c">业务敏捷性</a>，这是关键的业务属性。</p><p id="bd52" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">自治通过事件和分散的数据存储体现在通信中。</p><h2 id="d3bf" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">服务通过事件进行通信</h2><p id="2a20" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">服务不是生活在真空中，所以它们是相互通信的。如何实现这一点？我提倡使用以行为为中心和业务驱动的<a class="ae jp" href="http://www.enterpriseintegrationpatterns.com/patterns/messaging/EventMessage.html" rel="noopener ugc nofollow" target="_blank">事件消息类型</a>，与<a class="ae jp" rel="noopener" href="/@wrong.about/wrong-ways-of-defining-service-boundaries-d9e313007bcc">同步请求和命令消息</a>相反。这种架构被称为<a class="ae jp" href="https://hackernoon.com/event-driven-architecture-implementation-140c51820845" rel="noopener ugc nofollow" target="_blank">事件驱动架构</a>。发布的事件应该反映业务概念，一些发生在域中的<a class="ae jp" href="https://martinfowler.com/eaaDev/DomainEvent.html" rel="noopener ugc nofollow" target="_blank">真实事件:订单完成、交易处理、发票支付。通常，业务策略不需要即时的事务性反应。但是，如果您认为事件应该在数据库事务中处理，因此它的结果应该是“要么全部处理，要么不处理，并且立即处理！”—再想想。就我个人而言，想象一下一百年前这个行业是如何运作的(或者本来会是如何运作的)会有所帮助，当时没有交易，甚至没有计算机，这使得数据交换、数据处理和通信非常迅速。顺便说一句，部分原因是因为这种服务边界识别是如此困难的任务。但即使现在，有了所有这些技术，我们的生活仍然不是那么事务性的，很少同步，大多是消息驱动的。</a></p><p id="a117" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">看一看这样一个交易性的，从第一眼开始，像买房子这样的事情。房地产经纪人准备文件。你做第一笔存款(它已经变得越来越少交易，一点一点，不是吗？).但是你的房产经纪人突然取消了交易。或许他找到了更有利可图的提议。或者原来房子情况紧急，卖不出去。可能他甚至在电话联系不上你后给你写了封邮件，但不幸的是你在存款后看到了。在这种情况下，我希望房地产经纪人会把钱还给你，然后你就可以去找新房子了。这里的电子邮件是一个基于<a class="ae jp" href="http://www.enterpriseintegrationpatterns.com/patterns/messaging/CommandMessage.html" rel="noopener ugc nofollow" target="_blank">命令的消息</a>，它的语义是fire and forget。房地产经纪人给你写了一封电子邮件，但是回复是什么并不重要。反正交易取消了，你要想尽办法把钱拿回来，找个新房子。房地产经纪人不怎么参与你的活动。谈到交易性，首先，你还没有付全款，只是第一笔定金。其次，无论如何交易被取消了，但是现在你没有你的钱。这几乎不能称之为事务性交互。<br/>还是转账的经典例子。如果卡是由不同的银行发行的，转账可能需要几天时间，而汇款人可以立即被扣款。数据库事务是否跨越了这个传输周期？不会。大致来说，这个过程可以是这样的(不过也可以是另一种方式，取决于具体的银行):首先，汇款人的账户被借记，然后汇款人的发卡银行开始<a class="ae jp" href="http://markets.ft.com/research/Lexicon/Term?term=clearing-system" rel="noopener ugc nofollow" target="_blank">清算</a>过程——银行之间资金流动的物理过程。此后，接收者的账户被记入贷方。如你所见，它远非事务性的。</p><p id="15a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">换句话说，我们生活中相当多看似事务性、同步性的事情其实并不是这样。没关系。</p><h2 id="a398" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">但是有时候你真的需要一个命令</h2><p id="faba" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">在某些情况下，服务本质上类似于请求/回复。例如，这是服务做一些分析工作的有效情况。在这种情况下，它需要一些输入数据，并在输出端报告结果。我所说的情况是，这实际上是一个单独的服务，代表了与其他服务相同抽象级别的一些业务价值，因此它不能放在任何现有的服务中。在这种情况下，命令消息或异步请求/回复就派上了用场。但是这样的服务不应该被阻塞，这样调用所考虑的服务的客户机服务就不会等待它完成它的工作。</p><h2 id="0b3c" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">分散数据</h2><p id="6796" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">除了通过事件进行通信之外，服务自治意味着不能(也不应该！)成为共享数据库。</p><p id="7435" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">嗯，当服务边界被正确地指定，当每个服务高度内聚时，它们就不需要其他服务的数据了。但是，如果某个服务需要另一个服务的数据(本质上是同步操作)，那么它们很可能应该是一个服务。我喜欢把它和<a class="ae jp" href="http://wiki.c2.com/?FeatureEnvySmell" rel="noopener ugc nofollow" target="_blank">特征羡慕气味</a>相比较，这明显违反了来自<a class="ae jp" href="https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)" rel="noopener ugc nofollow" target="_blank">把握准则</a>的信息专家原则。这只是概念统一性在不同层次上的另一种表现——无论是对象还是服务。</p><p id="8b83" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当数据被分散时，在EDA的情况下，它以一种质量上不同的方式被修改。现在没有一个服务可以调用和修改它的数据。这只能通过事件来实现。为什么是质的不同的方式？<br/>首先，在大多数情况下，这意味着出版商应该从商业角度理解发生了什么。否则，发布事件有时看起来甚至不自然:这不是我们都习惯的简单的CRUD操作，这是不同的东西，需要不同的方法。这种不同的方法让我们更接近<a class="ae jp" href="https://en.wikipedia.org/wiki/Domain-driven_design" rel="noopener ugc nofollow" target="_blank">领域驱动的设计</a>，这本身就是一个巨大的好处。其次，订户决定如何对事件做出反应，修改什么数据以及如何修改。出版商甚至不知道它的订户。</p><p id="f587" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这让我想起了<a class="ae jp" href="https://martinfowler.com/articles/dipInTheWild.html" rel="noopener ugc nofollow" target="_blank">依赖反转原理</a>。考虑以下代码:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="52d2" class="jx jy hu lj b fv ln lo l lp lq">class Server {</span><span id="bfbc" class="jx jy hu lj b fv lr lo l lp lq">}</span><span id="532c" class="jx jy hu lj b fv lr lo l lp lq">class Client {<br/>    public function do(Server $server) {<br/>        // ...<br/>    }<br/>}</span></pre><p id="90da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在同步请求-应答中，客户端直接依赖于它请求的具体服务，依赖于它的API和可用性。</p><p id="acd3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在基于<a class="ae jp" href="https://www.infoq.com/presentations/pub-sub-domains" rel="noopener ugc nofollow" target="_blank">发布-订阅</a>的事件驱动架构中，订阅者不关心发布者。订阅者不知道谁在发布事件。订户站在一个有经验的冥想者的立场，接受现实，只是看着它。它不关心发布者的可用性——没关系，消息可以晚一点发送。换句话说，发布者完全从订阅者中抽象出来，隐藏在发布者可以发出的一组事件之后，即它的契约。<br/>因此，前一段代码转换为以下代码:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="59fc" class="jx jy hu lj b fv ln lo l lp lq">interface IEvent {</span><span id="e1f0" class="jx jy hu lj b fv lr lo l lp lq">}</span><span id="a346" class="jx jy hu lj b fv lr lo l lp lq">class Subscriber {<br/>    public function subscribe(IEvent $event) {<br/>        // ...<br/>    }<br/>}</span></pre><p id="07c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">分散数据使高可扩展性成为可能。通常，数据库会成为性能瓶颈，因为通常在请求处理时您必须锁定一些数据。当所有数据都位于一个数据库中时，某个请求需要已经在并行请求的事务中锁定的数据的可能性就会增加。因此每个请求都要等待前一个请求的结束。当数据是分散的，锁也是分散的:事务跨越更少的数据，因为请求处理被分散在不同的服务上，并且有更少的“意外”锁，我在我的<a class="ae jp" rel="noopener" href="/@wrong.about/wrong-ways-of-defining-service-boundaries-d9e313007bcc">前一篇文章</a>的“集中数据”一章中提到过。</p><h2 id="3c1d" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">服务编排</h2><p id="7547" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">服务编排是同步通信拒绝、使用业务事件和集中式数据存储拒绝的自然结果。EDA中的管理权威看起来像是来自同步过去的一种古老说法。</p><h2 id="1fd8" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr dt translated">收益</h2><p id="3dc0" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">因此，有了事件驱动架构，我们就没有了同步通信、基于命令的通信、分布式事务和编排的缺点。因此，这是一个双赢的局面:通过这种<a class="ae jp" href="http://www.enterpriseintegrationpatterns.com/patterns/conversation/FireAndForget.html" rel="noopener ugc nofollow" target="_blank">一劳永逸的方法</a>，我们在逻辑上和技术上分离了我们的服务，因为消息传递基础设施促进了无阻塞通信。<br/>关于复用，EDA中的复用单元是事件，而不是服务。如果您需要某个事件的新功能，那么您只需要添加一个新的事件订阅者。</p><p id="d001" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了敏捷性、可靠性和可用性之外，这种方法还带来了几乎无限的可伸缩性前景:服务不需要应对峰值负载。当我们收到大量消息时，它们只是驻留在我们的ESB或代理中，直到它们被处理。</p><p id="e568" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种方法只不过是基于失败的系统架构设计方法的经验的常识。这不是一种趋势。它不依赖于任何具体的技术。这肯定不是新的。你可以称之为<a class="ae jp" href="http://udidahan.com/category/soa/" rel="noopener ugc nofollow" target="_blank"> SOA </a>、<a class="ae jp" href="https://martinfowler.com/articles/microservices.html" rel="noopener ugc nofollow" target="_blank">微服务架构</a>、<a class="ae jp" href="https://www.slideshare.net/jboner/going-reactive-eventdriven-scalable-resilient-systems" rel="noopener ugc nofollow" target="_blank">反应式编程</a>或者<a class="ae jp" href="http://scs-architecture.org/" rel="noopener ugc nofollow" target="_blank">自包含系统</a>。对我来说，这就像一群人想要利用一套坚实的原则的(金融)优势，想出一个新的吸引人的标签，试图在历史上写下他们的名字。</p></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><p id="fd57" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在下一篇<a class="ae jp" rel="noopener" href="/@wrong.about/how-to-define-service-boundaries-251c4fc0f205">文章</a>中，我将会谈到我是如何确定服务边界的。</p></div></div>    
</body>
</html>