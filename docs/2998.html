<html>
<head>
<title>Redux and React-Router v4: a Tale of Two Datastores</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redux和React-路由器v4:两个数据存储库的故事</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/redux-and-react-router-v4-a-tale-of-two-datastores-8dd91f47d14e?source=collection_archive---------6-----------------------#2017-03-05">https://medium.com/hackernoon/redux-and-react-router-v4-a-tale-of-two-datastores-8dd91f47d14e?source=collection_archive---------6-----------------------#2017-03-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="870a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt jp translated">作为这篇文章的预期读者，你可能知道Redux将你的应用程序状态放在一个单独的存储中，使用一个漂亮的基于消息的API根据需要改变状态。</p><p id="f690" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Redux之前有Flux架构，它做的大致相同，但是有许多数据存储和许多实现尝试。事情相当混乱，Redux带来了秩序和快乐。我❤️ Redux。</p><p id="3e89" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由此我得出结论，将所有应用程序状态存储在一个数据存储中是保持代码可维护性的一个重要因素。</p><p id="6b4a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt jp translated"><span class="l jq jr js bm jt ju jv jw jx di"> E </span>进入这个故事的第二个主角，React路由器(RR)。RR允许你创建一个单页面应用程序，用URL假装它是一个服务器渲染的多页面应用程序，就像我们在黑暗时代所做的那样。这对于使用浏览器历史导航和允许搜索引擎链接到应用程序中的特定内容非常重要。</p><p id="8ae5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当RR最初出现的时候，在React v0.x的那些疯狂的日子里，它从其他框架带来了一些关于应用程序路由的想法。你可以使用React-like-but-not-actual-React语法指定路由，将你的应用程序包装在路由器中，然后RR会神奇地只显示你的应用程序的相关部分。</p><p id="65bb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">作为“神奇”部分的结果，应用程序状态的一个非常重要的部分<em class="jy">不在Redux存储中</em>🙀。亵渎！悲伤！哭泣的孩子！如果您想根据当前的URL做一些事情，您要么必须使用这个全新的不太具有声明性的RR API，要么提取RR状态并将其输入Redux。</p><figure class="ka kb kc kd fq ke fe ff paragraph-image"><div class="fe ff jz"><img src="../Images/d0e9652d5c8d019386182133733cb404.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*uHEGS14BWOVw71Vli_dVVw.jpeg"/></div><figcaption class="kh ki fg fe ff kj kk bd b be z ek">fight for who gets to store the data — <a class="ae kl" href="https://www.flickr.com/photos/doug88888/8390613308" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><p id="26bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt jp translated"><span class="l jq jr js bm jt ju jv jw jx di">以我当时的拙见，当前的URL只是应用程序状态的派生，而不是相反。我试验了一个系统，该系统像React处理绑定输入一样处理URL栏，这样新的URL事件被输入Redux，然后从存储中计算URL。这工作得相当好，但也不像是最好的解决方案。</span></p><p id="8c33" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种方法的主要问题是必须在一个位置维护URL到Redux操作的映射以及Redux存储到URL的映射。这意味着特定的应用程序逻辑需要放在应用程序中至少两个不同的地方，这很少是好现象。</p><p id="34c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，请注意，RR一直到v3都有完全相同的问题。</p><p id="c155" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt jp translated">现在，我们到了美好未来的部分，事实上，就是现在:React路由器v4带来了一个简单的、模块化的API，不是“类React ”,而是真正的React组件进行路由。</p><p id="ab80" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以在应用程序的每一层进行路由，而不是在一个位置放置所有的路由，只需将块包装在一个<code class="eh km kn ko kp b">&lt;Route/&gt;</code>组件中，该组件指定何时匹配。您甚至可以通过使用<code class="eh km kn ko kp b">@withRouter</code>装饰器来进行超级高级的路由。</p><p id="6bd1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这提供了如此多的好处:如果您想在选择某个路由时执行动作，您可以简单地使用React生命周期回调。如果你想扩展API，你可以直接包装它。如果您想在应用程序的某个部分维护特定的路径，请继续。</p><p id="519b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我非常喜欢的一个具体结果是，现在您可以创建可以在应用程序的任何位置使用的组件，并且它们可以自己操纵路线。例如，您可以拥有一个列表/细节视图，它自动将当前细节项的id添加到URL中，您甚至可以嵌套它！</p><p id="cf6d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt jp translated"><span class="l jq jr js bm jt ju jv jw jx di">所以</span>现在你可能想知道，Redux怎么样？那单店理想呢？</p><p id="b825" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好吧，应用程序状态仍然被分为两个域，Redux存储和浏览器历史，但现在它是可管理和可预测的。您可以轻松地获取位置参数，使您的应用程序依赖于URL，并且您可以非常简单地在组件中将其与Redux state结合起来。</p><p id="dd7e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当前安装的组件树是应用程序中声明性路由配置的结果，因此您只需知道当前位置及其派生参数，就可以呈现应用程序，Redux存储包含所有其他应用程序信息。这两个数据存储携带完全正交的信息，一个可以改变，而另一个不必更新。</p><p id="b173" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然我对这个API不是100%满意，但是模块化的本质允许<a class="ae kl" href="https://gist.github.com/wmertens/b581322d5212035ffe7e6b4fd6222647" rel="noopener ugc nofollow" target="_blank">以一种完全可互操作的方式包装它</a>，所以现在我终于可以说:</p><p id="c72b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我❤️反应-路由器v4。</p><figure class="ka kb kc kd fq ke fe ff paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="fe ff kq"><img src="../Images/95b6163c4a39fabf31a7be0db1081e1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dd0FT8nRMvv_6p9bjexA-Q.jpeg"/></div></div><figcaption class="kh ki fg fe ff kj kk bd b be z ek">hugtime, no need to fight!</figcaption></figure><div class="ka kb kc kd fq ab cb"><figure class="kv ke kw kx ky kz la paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="kv ke kw kx ky kz la paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="kv ke kw kx ky kz la paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="lb lc ld"><p id="f922" class="ir is jy it b iu iv iw ix iy iz ja jb le jd je jf lf jh ji jj lg jl jm jn jo hn dt translated"><a class="ae kl" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kl" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kl" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae kl" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is jy it b iu iv iw ix iy iz ja jb le jd je jf lf jh ji jj lg jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kl" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kl" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ka kb kc kd fq ke fe ff paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="fe ff lh"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>