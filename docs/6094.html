<html>
<head>
<title>ReactJs component lifecycle methods — A deep dive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ReactJs组件生命周期方法——深入探讨</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/reactjs-component-lifecycle-methods-a-deep-dive-38275d9d13c0?source=collection_archive---------0-----------------------#2017-09-03">https://medium.com/hackernoon/reactjs-component-lifecycle-methods-a-deep-dive-38275d9d13c0?source=collection_archive---------0-----------------------#2017-09-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/c48c1e6db0b70c31c707fe2864472924.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MdOuMPSdHlBdHz9QdJA_gg.jpeg"/></div></div></figure><div class=""/><p id="654a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这篇博文是针对React 16.3以下版本的。<br/>在React v16.3中，组件生命周期方法发生了重大变化。如果你正在使用React 16.3以上的版本，请参考下面的博客文章。</p><div class="ht hu fm fo hv ka"><a href="https://blog.bitsrc.io/understanding-react-v16-4-new-component-lifecycle-methods-fa7b224efd7d" rel="noopener  ugc nofollow" target="_blank"><div class="kb ab ej"><div class="kc ab kd cl cj ke"><h2 class="bd ig fv z el kf eo ep kg er et ie dt translated">了解React v16.4+新的组件生命周期方法</h2><div class="kh l"><h3 class="bd b fv z el kf eo ep kg er et ek translated">React新组件生命周期方法的实践指南；构建一个简单的音乐播放器！</h3></div><div class="ki l"><p class="bd b gc z el kf eo ep kg er et ek translated">blog.bitsrc.io</p></div></div><div class="kj l"><div class="kk l kl km kn kj ko ib ka"/></div></div></a></div><h2 id="3c8f" class="kp kq if bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated">React及其用户界面</h2><p id="ee1d" class="pw-post-body-paragraph jc jd if je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">“ReactJs是一个javascript库，用于构建<strong class="je ig">用户界面</strong>”<em class="lp"/>是关于ReactJs的官方一行介绍。</p><h2 id="a2d5" class="kp kq if bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated"><strong class="ak">什么是用户界面？</strong></h2><p id="df59" class="pw-post-body-paragraph jc jd if je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">用户通过点击、悬停、按键或在UI组件上执行许多其他事件来与应用程序交互。所有的UI组件都在浏览器中诞生，并在某个时间点消亡。整个界面都由一个神来治理，那就是<strong class="je ig">用户</strong>。</p><p id="2b70" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">用户界面是一个多选项的游乐场，用户可以做任何事情，像ReactJs这样的库可以帮助我们创建这个游乐场。</p><h2 id="5a61" class="kp kq if bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated">什么是生命周期方法，为什么它很重要？</h2><p id="8a4d" class="pw-post-body-paragraph jc jd if je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">我们周围的一切都经历了出生、成长和死亡的循环。想想树，任何软件应用程序，你自己，一个<code class="eh lq lr ls lt b">div container</code>或者网页浏览器中的UI组件，每一个都会诞生，通过更新成长，然后消亡。</p><p id="282a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">生命周期方法是在组件生命周期的不同阶段调用的各种方法。假设如果我们正在创建YouTube应用程序，那么显然我们的应用程序将使用网络来缓冲视频，它会消耗电池电量<em class="lp">(假设只有这两个)</em>。<br/>如果用户在播放完视频后切换到另一个应用程序，那么作为优秀的开发者，我们应该确保以最有效的方式使用网络和电池等资源。每当用户切换到另一个应用程序时，我们可以停止/暂停视频的缓冲，这将停止使用网络和电池。</p><p id="319e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是ReactJs中的生命周期方法为我们提供的，这样开发人员就可以生产出高质量的应用程序，并确保开发人员可以真正计划在UI界面的诞生、发展或死亡的各个时间点做什么以及如何做。</p><blockquote class="lu lv lw"><p id="b66e" class="jc jd lp je b jf jg jh ji jj jk jl jm lx jo jp jq ly js jt ju lz jw jx jy jz hn dt translated">对组件生命周期有很好的理解将超越你开发高质量用户界面的能力。</p></blockquote><h1 id="aca8" class="ma kq if bd kr mb mc md kv me mf mg kz mh mi mj lc mk ml mm lf mn mo mp li mq dt translated">反应组分的四个阶段</h1><p id="1425" class="pw-post-body-paragraph jc jd if je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">React组件和世界上的任何其他组件一样，都要经历以下几个阶段</p><ul class=""><li id="1100" class="mr ms if je b jf jg jj jk jn mt jr mu jv mv jz mw mx my mz dt translated"><strong class="je ig">初始化</strong></li><li id="b921" class="mr ms if je b jf na jj nb jn nc jr nd jv ne jz mw mx my mz dt translated"><strong class="je ig">安装</strong></li><li id="752d" class="mr ms if je b jf na jj nb jn nc jr nd jv ne jz mw mx my mz dt translated"><strong class="je ig">更新</strong></li><li id="6ab1" class="mr ms if je b jf na jj nb jn nc jr nd jv ne jz mw mx my mz dt translated"><strong class="je ig">卸载</strong></li></ul><p id="d06b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下图直观地展示了ReactJs生命周期的各个阶段和方法。</p><figure class="ng nh ni nj fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nf"><img src="../Images/d39733d13b72810717e6b8ac9b8a7441.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sn-ftowp0_VVRbeUAFECMA.png"/></div></div><figcaption class="nk nl fg fe ff nm nn bd b be z ek">ReactJs lifecycle phases and methods</figcaption></figure><p id="eb01" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了可视化这些生命周期挂钩的实现，我们将创建一个名为Contra music player的音乐播放器React应用程序。让我们从这些阶段开始讨论。</p><h2 id="91ae" class="kp kq if bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated">1)初始化</h2><p id="6a19" class="pw-post-body-paragraph jc jd if je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">在这个阶段，React组件通过设置初始状态和默认道具(如果有的话)为即将到来的艰难旅程做准备。</p><p id="bcc6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">魂斗罗音乐播放器应用程序的初始化如下</p><figure class="ng nh ni nj fq hw"><div class="bz el l di"><div class="no np l"/></div></figure><p id="b406" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">组件在构造函数中设置初始状态，稍后可以通过使用<code class="eh lq lr ls lt b">setState</code>方法进行更改。</p><p id="8698" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh lq lr ls lt b">defaultProps</code>被定义为组件的一个属性，用来定义props的所有默认值，可以用新的props值覆盖。</p><p id="c8dd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过渲染像<code class="eh lq lr ls lt b">&lt;ContraMusicPlayer/&gt;</code>魂斗罗音乐播放器会以<em class="lp">音量</em> 70%开始，在<em class="lp">暂停</em>状态下以<em class="lp">黑暗主题</em>。</p><p id="1535" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过渲染像<code class="eh lq lr ls lt b">&lt;ContraMusicPlayer theme="light"/&gt;</code>魂斗罗音乐播放器将从<em class="lp">音量</em> 70%开始，在<em class="lp">暂停</em>状态下用<em class="lp">灯光主题</em>。</p><h2 id="9263" class="kp kq if bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated">2)安装</h2><p id="0c28" class="pw-post-body-paragraph jc jd if je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">在准备好基本需求、状态和道具之后，我们的React组件就可以挂载到浏览器DOM中了。这个阶段给出了组件安装前后的挂钩方法。在这个阶段调用的方法有</p><ul class=""><li id="ce48" class="mr ms if je b jf jg jj jk jn mt jr mu jv mv jz mw mx my mz dt translated"><strong class="je ig"> componentWillMount </strong>在React组件即将挂载到DOM之前执行。因此，在此方法之后，组件<strong class="je ig">将</strong>安装。在组件挂载之前，您需要做的所有事情都必须在这里定义。<br/>该方法在组件的生命周期中第一次渲染之前执行一次。<br/> <strong class="je ig"> <em class="lp">用法:</em> </strong> componentWillMount用于初始化状态或道具，关于是否将其与构造函数合并，目前存在巨大争议。</li><li id="b51c" class="mr ms if je b jf na jj nb jn nc jr nd jv ne jz mw mx my mz dt translated"><strong class="je ig">渲染</strong>将组件挂载到浏览器上。这是一个纯方法，这意味着每次提供相同的输入时，它都会给出相同的输出。</li></ul><p id="4a72" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的音乐播放器的呈现方法可能如下所示</p><figure class="ng nh ni nj fq hw"><div class="bz el l di"><div class="no np l"/></div></figure><ul class=""><li id="bc1c" class="mr ms if je b jf jg jj jk jn mt jr mu jv mv jz mw mx my mz dt translated"><strong class="je ig"> componentDidMount </strong>这是在组件<strong class="je ig">在dom上挂载</strong>之后执行的钩子方法。<br/>该方法在组件的生命周期中第一次渲染后执行一次。因为在这个方法中，我们可以访问DOM，我们应该初始化需要访问DOM的JS库，如D3或Jquery。<br/> <strong class="je ig"> <em class="lp">用法:</em> </strong>在我们的魂斗罗音乐播放器app中，我们想要绘制出整首歌曲的声波图，这是与D3或其他第三方Javascript库集成的正确方法。</li></ul><p id="4b26" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面的例子展示了当DOM准备好时highcharts的设置</p><figure class="ng nh ni nj fq hw"><div class="bz el l di"><div class="no np l"/></div></figure><blockquote class="lu lv lw"><p id="f232" class="jc jd lp je b jf jg jh ji jj jk jl jm lx jo jp jq ly js jt ju lz jw jx jy jz hn dt translated"><strong class="je ig">应该在哪里进行API调用？</strong></p><p id="8992" class="jc jd lp je b jf jg jh ji jj jk jl jm lx jo jp jq ly js jt ju lz jw jx jy jz hn dt translated"><em class="if">API调用应该总是在componentDidMount方法中进行。</em></p></blockquote><div class="ht hu fm fo hv ka"><a href="https://hackernoon.com/where-to-integrate-api-calls-in-reactjs-componentwillmount-vs-componentdidmount-710085dc05c3" rel="noopener  ugc nofollow" target="_blank"><div class="kb ab ej"><div class="kc ab kd cl cj ke"><h2 class="bd ig fv z el kf eo ep kg er et ie dt translated">ReactJs中哪里集成API调用？— componentWillMount与componentDidMount</h2><div class="kh l"><h3 class="bd b fv z el kf eo ep kg er et ek translated">每个想要获取数据或向服务器发送数据的React应用程序都需要集成API。</h3></div><div class="ki l"><p class="bd b gc z el kf eo ep kg er et ek translated">hackernoon.com</p></div></div><div class="kj l"><div class="nq l kl km kn kj ko ib ka"/></div></div></a></div><p id="3e11" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请参考上面的博文，了解更多关于集成API调用的信息。</p><h2 id="eee0" class="kp kq if bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated">3)更新</h2><p id="c6c1" class="pw-post-body-paragraph jc jd if je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">这个阶段从react组件在浏览器上诞生开始，并通过接收新的更新而成长。组件可以通过两种方式更新，发送新的道具或更新状态。</p><p id="2ba6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们来看看通过调用setState更新当前状态时的钩子方法列表</p><ul class=""><li id="de38" class="mr ms if je b jf jg jj jk jn mt jr mu jv mv jz mw mx my mz dt translated"><strong class="je ig"> shouldComponentUpdate </strong>告诉React当组件收到新的道具或者状态被更新时，React应该重新渲染还是可以跳过渲染？<br/>这个方法是一个问题，<strong class="je ig">该不该</strong>把<strong class="je ig">组件</strong>变成<strong class="je ig">更新</strong> d？<br/>因此，该方法应该返回true或false，相应地，组件将被重新呈现或跳过。默认情况下，该方法返回true。<strong class="je ig"> <br/> <em class="lp">用法:</em> </strong>例子是我想只在道具状态改变时重新渲染组件的情况之一。</li></ul><figure class="ng nh ni nj fq hw"><div class="bz el l di"><div class="no np l"/></div></figure><p id="8b1e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种方法通常在渲染是一种非常繁重的方法时使用，这时你应该避免不时地渲染。例如，假设每次渲染，组件都会生成一千个质数，让我们考虑某个应用程序具有这种逻辑，然后我们可以控制何时需要它，然后只渲染组件。</p><ul class=""><li id="335e" class="mr ms if je b jf jg jj jk jn mt jr mu jv mv jz mw mx my mz dt translated"><strong class="je ig"> componentWillUpdate </strong>仅在<code class="eh lq lr ls lt b">shouldComponentUpdate</code>返回true后执行。该方法仅用于为即将到来的渲染做准备，类似于componentWillMount或constructor。当在渲染某个项目之前需要一些计算或准备时，可能会有一些用例，这是这样做的地方。</li><li id="e0b5" class="mr ms if je b jf na jj nb jn nc jr nd jv ne jz mw mx my mz dt translated"><strong class="je ig">渲染</strong>然后组件被渲染。</li><li id="115b" class="mr ms if je b jf na jj nb jn nc jr nd jv ne jz mw mx my mz dt translated"><strong class="je ig"> componentDidUpdate </strong>在新的更新组件已经在DOM中更新时执行。该方法用于重新触发第三方库，以确保这些库也能更新和重新加载。</li></ul><h2 id="bde9" class="kp kq if bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated">当父节点发送新的属性时，将调用的方法列表如下:</h2><ul class=""><li id="9a1f" class="mr ms if je b jf lk jj ll jn nr jr ns jv nt jz mw mx my mz dt translated"><strong class="je ig">componentWillReceiveProps</strong>在属性已经改变并且不是第一次渲染时被执行。有时状态依赖于道具，因此每当道具改变时，状态也应该同步。这是应该做的方法。<br/>在状态改变之前，状态的类似方法并不存在，因为属性在组件中是只读的，永远不能依赖于状态。<br/> <strong class="je ig"> <em class="lp">用法:</em> </strong>这就是状态如何与新道具保持同步。</li></ul><figure class="ng nh ni nj fq hw"><div class="bz el l di"><div class="no np l"/></div></figure><p id="7b05" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就状态而言，其余方法的行为与上面定义的完全相同。</p><ul class=""><li id="8414" class="mr ms if je b jf jg jj jk jn mt jr mu jv mv jz mw mx my mz dt translated"><strong class="je ig"> shouldComponentUpdate </strong></li><li id="4a9f" class="mr ms if je b jf na jj nb jn nc jr nd jv ne jz mw mx my mz dt translated"><strong class="je ig">组件将更新</strong></li><li id="57b9" class="mr ms if je b jf na jj nb jn nc jr nd jv ne jz mw mx my mz dt translated"><strong class="je ig">渲染</strong></li><li id="cbe7" class="mr ms if je b jf na jj nb jn nc jr nd jv ne jz mw mx my mz dt translated"><strong class="je ig">组件更新</strong></li></ul><h2 id="45c7" class="kp kq if bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated">4)卸载</h2><p id="e039" class="pw-post-body-paragraph jc jd if je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">在这个阶段，不需要组件，组件将从DOM中卸载。在此阶段调用的方法</p><ul class=""><li id="de91" class="mr ms if je b jf jg jj jk jn mt jr mu jv mv jz mw mx my mz dt translated"><strong class="je ig"> componentWillUnmount </strong>该方法是生命周期中的最后一个方法。这在组件从DOM中移除之前执行。<strong class="je ig"> <br/> <em class="lp">用法:</em> </strong>在这个方法中，我们做了所有与组件相关的清理。<br/>例如，在注销时，可以在卸载主要组件之前清除用户详细信息和所有授权令牌。</li></ul><figure class="ng nh ni nj fq hw"><div class="bz el l di"><div class="no np l"/></div></figure></div><div class="ab cl nu nv hc nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="hn ho hp hq hr"><figure class="ng nh ni nj fq hw fe ff paragraph-image"><div class="fe ff ob"><img src="../Images/436774fbc80b39256ed738f4ffa570c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*N274G84ZMJk7k80Xay-P2Q.jpeg"/></div></figure><p id="8906" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请在评论区告诉我你的想法。如果这篇文章对你有帮助，那么你可以给我买杯咖啡😊</p><figure class="ng nh ni nj fq hw"><div class="bz el l di"><div class="od np l"/></div></figure></div></div>    
</body>
</html>