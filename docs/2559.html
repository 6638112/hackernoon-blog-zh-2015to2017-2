<html>
<head>
<title>Rewriting Transmission UI with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React重写传输UI</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/rewriting-transmission-ui-with-react-8f76c44c1c54?source=collection_archive---------11-----------------------#2017-02-03">https://medium.com/hackernoon/rewriting-transmission-ui-with-react-8f76c44c1c54?source=collection_archive---------11-----------------------#2017-02-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="aead" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我记得大约两个月前，我和Eduardo Lanchares谈论下一个webapp的最佳堆栈。有时候你在工作，你被当前的框架设置和<a class="ae jr" href="https://hackernoon.com/tagged/tools" rel="noopener ugc nofollow" target="_blank">工具</a>所困扰，这些很难改变或重构。这迫使你总是以同样的心态工作，不允许你测试解决问题的新方法。</p><p id="31a5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">遵循我们学习新东西以使我们的生活更轻松的愿望，我们想尝试新的<a class="ae jr" href="https://hackernoon.com/tagged/technology" rel="noopener ugc nofollow" target="_blank">技术</a>来构建一个附带项目，该项目具有更好地满足应用程序需求的全新堆栈。</p><p id="c312" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在同一周，我的一个朋友谈到了Transmission的web客户端中影响他的一个bug。这个<a class="ae jr" href="https://trac.transmissionbt.com/ticket/5857" rel="noopener ugc nofollow" target="_blank"> bug </a>正在影响更多的人，因为我们在2年前的追踪器中发现了一个公开的bug报告。我们决定检查源代码并尝试修复它，因为我们认为这是小菜一碟。但是几个小时后，我们发现这并不像我们预期的那么容易，在某个时候我们放弃了。</p><p id="300b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">考虑到所有这些事情，我们有了一个完美的场景和借口开始玩一个新的副业项目。我们决定从头开始构建一个新的界面，以理解新的模式、新的方法，并发现<em class="js">终极界面</em>的下一个挑战。</p><h1 id="56bf" class="jt ju hu bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dt translated">我们的实验堆栈</h1><p id="cbcd" class="pw-post-body-paragraph ir is hu it b iu kr iw ix iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo hn dt translated">回顾当前Transmission web客户端中的所有功能，我们选择的堆栈是React用于用户界面，Mobx用于状态管理，CSS模块用于所有与应用程序风格相关的内容，新的构建过程由Webpack管理。</p><p id="b802" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一方面，考虑到上面的内容，我们决定使用一些最佳实践来保证这个项目的长期质量。其中一些是像一套严格的Eslint规则、单元测试、UI测试和国际化。</p><p id="77f2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过这一决定，我们希望实现更可靠的接口、更好的性能、安全性和正确性。总之，维护这个web应用程序的更好的方法。</p><p id="8557" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在接下来的部分中，我们将讨论开发原始传输源代码的方式和我们的方法之间的差异。好奇的话可以查一下<a class="ae jr" href="https://github.com/transmission/transmission/tree/master/web" rel="noopener ugc nofollow" target="_blank">原码</a>和<a class="ae jr" href="https://github.com/fcsonline/react-transmission" rel="noopener ugc nofollow" target="_blank">我们码</a>。</p><h1 id="422a" class="jt ju hu bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dt translated">成分</h1><p id="dae0" class="pw-post-body-paragraph ir is hu it b iu kr iw ix iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo hn dt translated">就应用程序模块化而言，最初的客户端是用一组加入到单个静态HTML文件中的<em class="js">视图</em>实现的。jQuery代码修改了这些视图以保持更新。虽然这种方法像预期的那样工作，但它的缺点是会生成多个DOM更新，这会影响UI性能。此外，在这个文件中使用硬编码的字符串使得支持I18n和动态内容生成变得困难(例如当显示可用的<a class="ae jr" href="https://github.com/transmission/transmission/blob/master/web/index.html#L380" rel="noopener ugc nofollow" target="_blank">速度限制</a>时)</p><p id="242d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的新应用程序将每个组件存储在一个独立的文件夹中，其中包含所有相关的内容。像样式、测试或子组件这样的东西是共存的。这让我们可以管理所有的应用程序组件，了解它们之间的所有依赖关系，并尽可能实现最佳的解耦。</p><h1 id="7a3e" class="jt ju hu bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dt translated">状态管理</h1><p id="e594" class="pw-post-body-paragraph ir is hu it b iu kr iw ix iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo hn dt translated">在用jQuery实现的传统web应用程序中，在意识到一些元素已经过时后，您需要手动更新所有的UI。这些变化通常来自一些用户交互或服务器更新，所以应用程序状态的概念几乎不存在。</p><p id="5896" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用React和Mobx管理的新堆栈，我们遵循<em class="js">单向数据流</em>约定，这使得推断应用程序状态变得更加容易。所有这些状态都在名为stores的Mobx容器中进行管理。这是理解其工作原理的一个很好的图表:</p><figure class="kx ky kz la fq lb fe ff paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="fe ff kw"><img src="../Images/975062b619a78fa7cdf3e83e16800bcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wMejzY3Wsrynv5s3."/></div></div></figure><p id="89b0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Mobx使用以下主要概念来建模您的应用程序状态:</p><ul class=""><li id="437b" class="li lj hu it b iu iv iy iz jc lk jg ll jk lm jo ln lo lp lq dt translated"><code class="eh lr ls lt lu b">observable</code>属性:基本跟踪属性</li><li id="fcb2" class="li lj hu it b iu lv iy lw jc lx jg ly jk lz jo ln lo lp lq dt translated"><code class="eh lr ls lt lu b">computed</code>属性:从可观察的事物中导出的属性</li><li id="bc21" class="li lj hu it b iu lv iy lw jc lx jg ly jk lz jo ln lo lp lq dt translated"><code class="eh lr ls lt lu b">actions</code>:更新状态的方法</li><li id="db92" class="li lj hu it b iu lv iy lw jc lx jg ly jk lz jo ln lo lp lq dt translated"><code class="eh lr ls lt lu b">reactions</code>:每次状态变化要执行的副作用</li></ul><p id="cc7c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，在下面的例子中，当我们点击preferences按钮时，我们发送一个更新<code class="eh lr ls lt lu b">isPreferencesDialogShown</code> observable属性的动作。这种变化会导致观察者组件的更新。在这种情况下,<code class="eh lr ls lt lu b">PreferenceDialog</code>对这种变化做出反应，并重新呈现自身，从而在UI中显示对话框。</p><figure class="kx ky kz la fq lb fe ff paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="fe ff ma"><img src="../Images/f29fbedc403d7ceba9b5007b922deecc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EF_Pl0nRgru8dZRC."/></div></div></figure><h1 id="5afe" class="jt ju hu bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dt translated">式样</h1><p id="3018" class="pw-post-body-paragraph ir is hu it b iu kr iw ix iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo hn dt translated">很长一段时间以来，我们一直通过元素中的类属性引用的CSS类列表来设计HTML组件的样式。在过去的5年中，新的工具已经出现，以改善我们的生活，如SASS，LESS或CSS模块。</p><p id="7209" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你习惯于编写大量的组件，你可能会犯一个常见的错误:为不同的组件重用样式类。但是当这些组件的风格开始不同时会发生什么呢？你有麻烦了。</p><p id="215b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如前所述，在我们的堆栈中，我们决定使用CSS模块来设计所有组件的样式。我们认为这是实现模块化和可重用类集的最佳方法。每个组件所需的所有类都在一起。就可维护性而言，这确实很好，因为对组件进行解耦很简单。CSS模块让你玩组合，这样你就可以从两个世界获得最好的特性。</p><p id="b6d2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如你在下面的例子中看到的，我们使用了两个CSS模块引用，分别叫做<code class="eh lr ls lt lu b">content</code>和<code class="eh lr ls lt lu b">logo</code>。这些名称用于引用样式表文件中的类。</p><p id="4dea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">反应过来看<code class="eh lr ls lt lu b">ConnectionDialog/index.js</code>:</p><figure class="kx ky kz la fq lb fe ff paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="fe ff mb"><img src="../Images/18dd0bd9aeee7fb3d888bed509001130.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZQyfmXDM-oXYQHCS."/></div></div></figure><p id="c51f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">样式文件<code class="eh lr ls lt lu b">ConnectionDialog/styles/index.css:</code></p><figure class="kx ky kz la fq lb fe ff paragraph-image"><div class="fe ff mc"><img src="../Images/8e4ed0a97dc1d4ae02d598ca1f30d1a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/0*KrToTbWj8X5d0cLm."/></div></figure><h1 id="badf" class="jt ju hu bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dt translated">试验</h1><p id="4dfb" class="pw-post-body-paragraph ir is hu it b iu kr iw ix iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo hn dt translated">最初的应用程序根本没有测试，所以我们很容易在这方面进行改进。</p><p id="b64d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在新的应用程序中，我们不仅要测试业务逻辑，还要测试UI。为此，我们选择了<a class="ae jr" href="https://facebook.github.io/jest/" rel="noopener ugc nofollow" target="_blank"> Jest </a>框架和<em class="js">快照</em>测试技术。这样我们就能确保每个组件都能呈现出预期的效果。这很重要，因为大多数组件都包含几个路径，我们需要确保每个路径都被覆盖。</p><p id="bb7a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">将这组新的测试集成到一些CI中，我们可以对应用程序的未来更改更有信心。</p><p id="240e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如我们在这个例子中看到的，我们用模拟的种子数据渲染进度条组件。</p><figure class="kx ky kz la fq lb fe ff paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="fe ff md"><img src="../Images/2b615ef7374ae2eb76111a809ec8b77e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FR8PXXpeQEVRyA8C."/></div></div></figure><p id="f540" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后使用快照技术，我们可以确保渲染结果与之前的快照相比是我们所期望的。以这种方式测试组件是一个像记录JSX代码一样简单的过程。</p><figure class="kx ky kz la fq lb fe ff paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="fe ff me"><img src="../Images/0f56002f802ac4145a9e3387f8e4ac9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/0*Ps8K6DpYrdxrP1JH."/></div></div></figure><h1 id="00e6" class="jt ju hu bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dt translated">额外功能</h1><p id="658b" class="pw-post-body-paragraph ir is hu it b iu kr iw ix iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo hn dt translated">回顾原始传输web界面中的所有可用功能，我们发现了桌面通知等不完善的功能。我们想恢复它们，因为我们认为这是一个非常好的功能。</p><p id="f032" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，一个额外的功能，新的界面包括拖放文件支持种子文件。这增强了快速添加torrent文件的常见用例，如下例所示:</p><figure class="kx ky kz la fq lb fe ff paragraph-image"><div class="fe ff mf"><img src="../Images/c418d2f6feea1110c524caf7d72d3e0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*csJIMnQo841M9k-H."/></div></figure><h1 id="7a75" class="jt ju hu bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dt translated">结论</h1><p id="85ac" class="pw-post-body-paragraph ir is hu it b iu kr iw ix iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo hn dt translated">我们启动这个项目是为了尝试新技术，以便能够理解如果您选择某个特定的堆栈，一个更大的项目将会面临的所有挑战。在某个时候，我们看到了实现包含在原始界面中的新特性是多么容易。所以我们决定向前推进，并设定一个个人目标:实现所有的目标。今天，我们可以说我们已经实现了95%的功能。</p><p id="a560" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的最后一个目标是将这个项目提交给社区进行评估。我们决定尽可能尊重原始界面，主要有两个原因:</p><ul class=""><li id="f064" class="li lj hu it b iu iv iy iz jc lk jg ll jk lm jo ln lo lp lq dt translated">我们不想在UI设计中引起争论。所以我们决定遵循当前的设计，我们只是想提出一个新的代码架构。</li><li id="231e" class="li lj hu it b iu lv iy lw jc lx jg ly jk lz jo ln lo lp lq dt translated">我们不想在考虑将这些代码包含在主传输库中的情况下影响最终用户。</li></ul><p id="b45a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，即使这个项目消失了，不管出于什么原因，我们还是很开心，因为在它的开发过程中，我们学到了很多东西，度过了一段非常愉快的时光。:D</p></div><div class="ab cl mg mh hc mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="hn ho hp hq hr"><p id="0260" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以在这里查看源代码:</p><div class="mn mo fm fo mp mq"><a href="https://github.com/fcsonline/react-transmission" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab ej"><div class="ms ab mt cl cj mu"><h2 class="bd hv fv z el mv eo ep mw er et ht dt translated">FCS online/反应式传输</h2><div class="mx l"><h3 class="bd b fv z el mv eo ep mw er et ek translated">React-Transmission-React Transmission是正在进行的Transmission web接口的再实现。</h3></div><div class="my l"><p class="bd b gc z el mv eo ep mw er et ek translated">github.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne lg mq"/></div></div></a></div></div><div class="ab cl mg mh hc mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="hn ho hp hq hr"><p id="6c4e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="js">如果你喜欢这篇文章，请点击下面的</em> ❤️ <em class="js">按钮，关注这篇文章，这样你就不会错过。</em></p><div class="kx ky kz la fq ab cb"><figure class="nf lb ng nh ni nj nk paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nf lb ng nh ni nj nk paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nf lb ng nh ni nj nk paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="nl nm nn"><p id="f922" class="ir is js it b iu iv iw ix iy iz ja jb no jd je jf np jh ji jj nq jl jm jn jo hn dt translated"><a class="ae jr" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jr" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jr" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jr" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is js it b iu iv iw ix iy iz ja jb no jd je jf np jh ji jj nq jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jr" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jr" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kx ky kz la fq lb fe ff paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="fe ff nr"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="kx ky kz la fq lb"><div class="bz el l di"><div class="ns nt l"/></div></figure></div></div>    
</body>
</html>