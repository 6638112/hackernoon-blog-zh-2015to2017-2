<html>
<head>
<title>Quick Thoughts on React (virtual DOM)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快速思考React(虚拟DOM)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/quick-thoughts-on-react-virtual-dom-4bba0c2547aa?source=collection_archive---------24-----------------------#2017-09-26">https://medium.com/hackernoon/quick-thoughts-on-react-virtual-dom-4bba0c2547aa?source=collection_archive---------24-----------------------#2017-09-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="ab06" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我在想如何回答我们的一个面试问题:“React的好处是什么？”我感觉这里大部分通常的回答都是不相关的。</p><ul class=""><li id="06d4" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx dt translated">“React允许渲染为纯函数”——没错，但这真的是一个好处吗？在代码中使用纯函数的主要好处是能够自信地组合函数。函数组合在很大程度上不是呈现DOM的问题。渲染函数接受状态并返回DOM，有些函数本身不能被合成。一个函数可能调用另一个函数在树中的特定位置呈现另一段DOM，而不是对DOM执行重大转换。渲染函数本质上离非纯粹的效果只有一步之遥，即DOM的变异。所以纯度并不是真正的“好处”(尽管检查虚拟DOM输出的能力可能对调试有一点帮助)。</li><li id="3f56" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">改进的状态管理——这与React本身没有什么关系。大量的“React框架”显示了把状态管理搞得一团糟是多么容易，因为它们都使用完全相同的底层React，但在状态处理上有所不同。改进之处在于，您不必显式地将DOM作为状态来处理，例如，使用jQuery来查询当前DOM并对其进行转换，而是直接表达当前状态和DOM之间的函数关系。但是，React的性质可能会导致应用程序状态管理更加混乱。</li><li id="e620" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">性能——使用React虚拟DOM差分肯定比重新渲染整个DOM要快。这可能比必须首先搜索想要改变的DOM元素的类似jQuery的方法更快，因为虚拟DOM允许您对树中不同标记位的关系进行某种隐式簿记。但是React在性能上无法与fReactive这样的直接反应式绑定方法相媲美。</li></ul><p id="2fae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们可以筛选出React的一个好处，那就是能够表达状态和DOM之间的直接函数关系，而不是担心状态的变化如何导致DOM的变化。Render函数被传递状态的更新值，吐出一个新的虚拟DOM块，然后React(启发式地)计算出实际DOM的哪些部分需要更新。基本上，React是在做渲染函数的“数值导数”。以前的la jQuery方法实际上是试图直接编码render函数的“分析”派生物，直接将状态变化映射到DOM变化，这显然会非常复杂，除了最简单的状态-&gt;DOM映射。</p><p id="1f6b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是虚拟世界区分不是唯一的方法，甚至可以说不是最好的方法。React(和所有虚拟DOM框架)使用启发式算法来近似diff，因为在两棵树之间做完全精确的差异真的很昂贵(<em class="kd"> O(n ) </em>，其中<em class="kd"> n </em>是树中元素的数量)。React的试探法在<em class="kd"> O(n) </em>中运行。然而，直接反应结合实际上是O(1) (-ish，实际上随着结合数量的变化而变化)。考虑一下fReactive采取的方法。与fReactive相比，om-next的渲染函数几乎没有区别，主要是fReactive中状态变量的显式解引用(与Reagent相比，这种区别甚至更小)。然而，实现方式却大不相同。fReactive的“render function”被调用一次，以在那些显式定义的变量和DOM元素和属性之间建立绑定。此后，对变量的更改直接传播到DOM中的更改，不需要中间人虚拟DOM操作。</p><p id="5cf0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么，为什么虚拟DOM和所有不同的复杂性赢得了胜利呢？部分答案可能是隐含的架构。不管出于什么原因，虚拟DOM方法似乎已经启发了一些合理的架构方法来管理应用程序状态更新的复杂性。反应式方法似乎像病毒一样传播，到处都在鼓励反应式编程。fReactive无疑就是这种情况，一旦您跳过了非常基本的应用程序，就会导致不同关注点和代码的复杂，这是非常难以调试的。当然，您可以将受虚拟DOM启发的状态管理方法与直接绑定DOM更新结合起来，这或许值得考虑。这可能还没有发生，因为不管出于什么原因，当考虑状态时，虚拟DOM方法将您置于一个不同于反应的顶部空间。但是技术上看起来是可行的。</p><p id="2c44" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是所有这些都回避了真正的问题:DOM对应用程序来说很糟糕。像HTML这样的标记语言非常适合制作文档，这种语言的树形结构直接映射了文档的语义和视觉结构。虽然应用程序的各个部分可以作为标记以文档形式有效地呈现，但是应用程序UI的更大结构肯定不能由标记很好地表示。想想像模态对话框这样简单的东西:内容可能通过标记很好地呈现出来。但是对话框“元素”到底在全局HTML树中的什么位置呢？它在树上的位置是什么意思？这当然在视觉上没有任何意义，但也许在某种程度上污染了事件的传播方式，等等。整件事都很恶心。HTML最初是作为一种在线呈现科学论文的方式。它在应用程序中的使用仅仅是因为web浏览器作为一个接口的独特性。改进或取代HTML的尝试，如XAML，已经彻底失败，不是因为HTML更优越，而是因为当不得不从头学习一项新技术时，应用程序对标记的巨大吸收变得更加明显。每个人都习惯了HTML的缺点。像React这样可以减轻一些痛苦的工具因此被视为“解决方案”。</p><p id="0783" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也许是时候从另一个角度审视这个问题了。我们应该独立地考虑如何最好地表示应用程序UI，而不是从HTML开始并试图找出如何最小化由此带来的麻烦。应该特别注意将应用程序状态更改转换为UI状态更改的问题，尽量减少计算呈现函数“导数”的复杂性。这让我们考虑如何最好地表现视觉元素之间的关系。HTML很大程度上试图将这些关系表达为层次和顺序，但是一个更明确的数学模型可能会简化状态到UI的转换。从这些需求中，我们总能找到如何将这种更自然的表示转换成DOM的方法。</p></div></div>    
</body>
</html>