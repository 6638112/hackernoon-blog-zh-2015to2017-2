<html>
<head>
<title>Programming Pearls and Python Fails</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pearls和Python编程失败</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/programming-pearls-and-python-fails-c4fc2962c3ed?source=collection_archive---------1-----------------------#2016-09-21">https://medium.com/hackernoon/programming-pearls-and-python-fails-c4fc2962c3ed?source=collection_archive---------1-----------------------#2016-09-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="846f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">计算机科学书籍包含永恒的智慧，但是性能建议<a class="ae jp" href="https://nopointerexception.wordpress.com/2015/07/16/optimizers-anonymous-1st-step-is-admitting-you-probably-dont-have-a-problem/" rel="noopener ugc nofollow" target="_blank">并不总是适用。在阅读乔恩·本特利的《T4编程》时，我发现了更多现代硬件的进步，打破了传统观念。</a></p><p id="2d44" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">考虑以下问题:</p><p id="d858" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">将n个元素的数组向左旋转I个位置。例如，将“abcdefgh”旋转3，得到“defghabc”。有没有可能做到这一点并与n成正比？</strong></p><p id="a9a9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该问题模拟了真实计算场景中的几个问题:</p><ul class=""><li id="f1b5" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">在文本编辑器中移动文本可以看作是旋转要移动到新位置的文本。</li><li id="ae49" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">交换相邻的不相等的内存块。</li></ul><p id="ae9a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">考虑到用例，操作不应该懒散地进行。</p><p id="d51b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一种算法涉及到一个微妙的杂耍动作:取第一个元素，然后将I处的元素移动到它的最终位置，然后将2i处的元素移动到I，依此类推。重复这一过程，直到整个阵列旋转完毕。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff ke"><img src="../Images/35b51e57091ef57dd40acb0b82cd720d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y8joXN653pddZhIfNCDbIg.jpeg"/></div></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">Credits: Programming Pearls, 2nd Edition, page 14.</figcaption></figure><p id="bd06" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">考虑这个问题的另一种方法是将数组视为两个不同的段，A和B，然后旋转数组等同于将数组AB转换为数组BA。如果我们能把A倒过来产生A’，那么</p><p id="8666" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(甲‘乙’)’-&gt;巴</p><p id="760a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">杂耍算法对每个数组元素读写一次。反向旋转对每个数组元素读写两次。传统智慧会让我们得出杂耍算法运行更快的结论。在编程Pearls时，杂耍代码据说快了一倍。这个结果在21世纪仍然成立吗？</p><p id="fa35" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是用Python实现的杂耍旋转:</p><figure class="kf kg kh ki fq kj"><div class="bz el l di"><div class="ku kv l"/></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">Juggle Swap</figcaption></figure><p id="a0ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过使用类型化的Python数组，我认为与列表相比，它会产生更好的性能。不幸的是，我犯了过早优化的罪。</p><figure class="kf kg kh ki fq kj"><div class="bz el l di"><div class="ku kv l"/></div></figure><p id="6ed4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在包含10000个元素的Python数组上运行旋转杂耍并重复10000次会得到以下结果:</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="fe ff kw"><img src="../Images/5694492fe8a6f0e1fede5ca7d37cfe47.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*VVzKROoFVyNHWk6Gy-GkAA.png"/></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">……..15 seconds?</figcaption></figure><p id="862d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我在4GHz英特尔i7-6700K上运行了测试。作为快速检查，我的CPU应该能够每秒处理几十亿次整数运算。杂耍旋转移动大约1000万个整数(10000个元素* 10000次重复)，对于它必须做的工作来说，15秒似乎长得可笑。</p><p id="df69" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用列表时会发生什么？</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="fe ff kx"><img src="../Images/c276574a334b20299fe34279f3415124.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*TwCLt3vMMpu4_S9N4oZadw.png"/></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">12.56 seconds…. eh….</figcaption></figure><p id="875d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好点了，但还是不太好。阅读<a class="ae jp" href="https://github.com/python/cpython/blob/master/Modules/arraymodule.c" rel="noopener ugc nofollow" target="_blank">Python源代码</a>发现，在元素检索过程中，Python会创建一个PyObject并包装结果。每当它访问一个从未见过的整数时，就会产生这种开销。如果我们内联函数呢？</p><figure class="kf kg kh ki fq kj"><div class="bz el l di"><div class="ku kv l"/></div></figure><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="fe ff ky"><img src="../Images/0676b6b9c026050729d3727619e5bf79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*XOQaQG14kd-7vZvTuA6Pyg.png"/></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">A 5 second improvement via inlining….not bad</figcaption></figure><p id="36af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对，没有函数内联。对于像map()和filter()这样本质上需要反复调用函数的东西来说，这并不好。</p><p id="f4af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">反向旋转呢？</p><figure class="kf kg kh ki fq kj"><div class="bz el l di"><div class="ku kv l"/></div></figure><p id="cd05" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从两端开始，我们一次循环一个，交换元素，我们做3个片段反转。非常简单。</p><p id="9e7c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">设置剖析工作台…</p><figure class="kf kg kh ki fq kj"><div class="bz el l di"><div class="ku kv l"/></div></figure><p id="8242" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们走吧:</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="fe ff kz"><img src="../Images/f36ebea3fb026810f512dace2eff0e23.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*UW_Pcl0shj_LvSGFYBwLsw.png"/></div></figure><p id="8ce8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这一点上，虽然反向函数看起来相当慢，但一切似乎都很慢。</p><p id="9378" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">嗯，我们可以用JIT运行Python环境，比如<a class="ae jp" href="http://pypy.org/" rel="noopener ugc nofollow" target="_blank"> PyPy </a>。</p><p id="daf2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们试一试</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="fe ff la"><img src="../Images/a2b02a1ede0fd4be2ca3f2cc71bcf49b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*v-0-UvahdTAXouRrKW9IsA.png"/></div></figure><p id="e2a7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们已经成功实现了10倍的杂耍函数加速和200倍的反向函数加速。由于某种原因，反向旋转比杂耍旋转快多了。</p><p id="f293" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还能进一步提高吗？</p><p id="b02f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过<a class="ae jp" href="http://cython.org/" rel="noopener ugc nofollow" target="_blank"> Cython </a>，并添加一些类型注释，可以编译代码，省去了更多的开销。这是转换后的函数</p><figure class="kf kg kh ki fq kj"><div class="bz el l di"><div class="ku kv l"/></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">Note how similar it is to the Python code we wrote before</figcaption></figure><p id="c080" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们进展如何？</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="fe ff lb"><img src="../Images/572ea219345d3bb4478816b0c797459c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*EnZuKsyKDgoqXbLz8panGQ.png"/></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">Wow</figcaption></figure><p id="8ffd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">作为另一个健全性检查，如果我们的CPU每秒可以处理几十亿条指令，那么处理1000万个整数应该在百分之一秒的范围内，我们的反向交换在0.07秒内完成。</p></div><div class="ab cl lc ld hc le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hn ho hp hq hr"><p id="3746" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所有这些仍然留给我们一个问题:<strong class="it hv">尽管做了更多的工作，为什么反向旋转函数比杂耍函数快？</strong></p><p id="7825" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我用C重新实现了这两个函数，我们在Linux下使用perf。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="fe ff lj"><img src="../Images/bd023e5950039292d6f1e02969767e36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*oBeCtECuq8lsZLowc8_TPw.png"/></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">Hmm….</figcaption></figure><p id="d4eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有趣的是，我们的C代码似乎比我们的Cython优化代码慢，编译后的Python怎么可能比C跑得快？</p><p id="3b0f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我已经将元素的数量增加到一百万个整数，我们现在正在做5000次重复，让我们再次重复Cython结果</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff lk"><img src="../Images/5243c19f0349740d925fbf361d6202d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5P4osSyAkYHcdxsPJvWduA.png"/></div></div></figure><p id="6b1f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的C程序表现如何？</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="fe ff ll"><img src="../Images/e6707b58a8b33b5e11445dfd79e38dfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*3KJAMHI1afhM3dr7Cnm3kA.png"/></div></figure><p id="f0bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">关于基准测试的重要经验:始终确保它们运行足够长的时间，以便结果不会被其他因素扭曲。</strong></p><p id="9009" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从我们的基准测试中，我们可以推断出Cython已经生成了相当纯的C。通过分析我们的C程序，我们应该能够得到关于我们性能的结论性结果。</p><p id="ff7b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">运行perf给了我们最后的拼图。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff lm"><img src="../Images/bf79c78bc339991e73400e4505b1f3cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lX-0NrspM2nbr5pKKQl7IA.png"/></div></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">Reverse Rotate</figcaption></figure><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff ln"><img src="../Images/d6754c4d65abbf3e897a5f7a766d38e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w1M8GTMLvVN4YZPgJ9i1cQ.png"/></div></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">Juggle Rotate</figcaption></figure><p id="2c82" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我想强调几个统计数据:</p><ol class=""><li id="0d04" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo lo jw jx jy dt translated">看看L1数据缓存加载(L1-dcache-loads)，反向交换的加载量大约是杂耍程序的两倍，这就是我们所期望的:两倍的内存访问。</li><li id="4c17" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo lo jw jx jy dt translated">Swap程序在L1数据和最后一级高速缓存(LLC)中的高速缓存未命中要少得多，而杂耍程序在高速缓存未命中中招致相当大的损失。</li></ol><p id="6264" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">简而言之，与进行计算相比，访问主存储器是昂贵的。在Skylake CPU上，访问RAM的成本是42个周期+ 51纳秒。CPU缓存基于这样的假设:代码将频繁访问彼此靠近的数据<strong class="it hv"/>，而数据访问在时间上靠近的是<strong class="it hv">。通过将这些数据放入高速缓存，CPU只需要访问快得多的高速缓存，而不是不断地访问主内存。</strong></p><p id="dc07" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有些人可能会想，为什么会有128%的缓存未命中？<a class="ae jp" href="https://sites.utexas.edu/jdm4372/2013/07/14/notes-on-the-mystery-of-hardware-cache-performance-counters/" rel="noopener ugc nofollow" target="_blank">有一个复杂的答案</a>，但TL；dr时，CPU可能会多次尝试从缓存中检索结果。</p><p id="9411" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">再看了看杂耍代码:</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff ke"><img src="../Images/35b51e57091ef57dd40acb0b82cd720d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y8joXN653pddZhIfNCDbIg.jpeg"/></div></div></figure><p id="32cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">杂耍代码通过不断以某个偏移跳跃来访问存储器。在较大的跳转时，这对于CPU缓存是有害的—不访问彼此靠近的数据会经常导致缓存未命中。回头看perf结果，杂耍轮换中有3，200万个最后一级缓存命中，而反向轮换中只有6.3万个。</p><p id="1f07" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在反向循环中，访问内存是按顺序从两端完成的，数据访问非常接近，因此我们获得了更高的速度，尽管读和写的速度是前者的两倍。</p><p id="959f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">值得注意的是，两种算法都有相同的渐近增长函数，都是O(n)算法，但由于使用了高速缓存，它们在运行时的大小不同。还值得注意的是，在C++中，反向旋转用作std::rotate实现的一部分。</p><p id="11e6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果要运行此blogpost中的任何代码，它们都将在此处收集:</p><div class="lp lq fm fo lr ls"><a href="https://github.com/FrozenXZeus/pyfails" rel="noopener  ugc nofollow" target="_blank"><div class="lt ab ej"><div class="lu ab lv cl cj lw"><h2 class="bd hv fv z el lx eo ep ly er et ht dt translated">FrozenXZeus/pyfairs</h2><div class="lz l"><h3 class="bd b fv z el lx eo ep ly er et ek translated">pyfairs——针对Python的不同实现的一组实现基准</h3></div><div class="ma l"><p class="bd b gc z el lx eo ep ly er et ek translated">github.com</p></div></div><div class="mb l"><div class="mc l md me mf mb mg ko ls"/></div></div></a></div><h1 id="c3f1" class="mh mi hu bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne dt translated">最后</h1><ul class=""><li id="ae1b" class="jq jr hu it b iu nf iy ng jc nh jg ni jk nj jo jv jw jx jy dt translated">高速缓存访问模式很重要！他们常常可以成就或破坏业绩。</li><li id="b5c7" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated"><a class="ae jp" href="https://nopointerexception.wordpress.com/2015/07/16/optimizers-anonymous-1st-step-is-admitting-you-probably-dont-have-a-problem/" rel="noopener ugc nofollow" target="_blank">谨防过早“优化”</a>。在仔细分析的基础上验证假设。</li><li id="74d2" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">在将代码部署到生产环境时，请考虑不同的Python解释器和Cython。一个例子就是由Dropbox编写的Python JIT<a class="ae jp" href="https://blog.pyston.org/" rel="noopener ugc nofollow" target="_blank">Pyston</a>。</li></ul><div class="kf kg kh ki fq ab cb"><figure class="nk kj nl nm nn no np paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nk kj nl nm nn no np paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nk kj nl nm nn no np paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="nq nr ns"><p id="f922" class="ir is nt it b iu iv iw ix iy iz ja jb nu jd je jf nv jh ji jj nw jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is nt it b iu iv iw ix iy iz ja jb nu jd je jf nv jh ji jj nw jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kf kg kh ki fq kj fe ff paragraph-image"><a href="https://goo.gl/Ahtev1"><div class="fe ff nx"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></a></figure><figure class="kf kg kh ki fq kj"><div class="bz el l di"><div class="ny kv l"/></div></figure></div></div>    
</body>
</html>