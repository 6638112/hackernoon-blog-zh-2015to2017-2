<html>
<head>
<title>React.PureComponent Considered Harmful</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">做出反应。被认为有害的纯成分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/react-purecomponent-considered-harmful-8155b5c1d4bc?source=collection_archive---------1-----------------------#2017-03-06">https://medium.com/hackernoon/react-purecomponent-considered-harmful-8155b5c1d4bc?source=collection_archive---------1-----------------------#2017-03-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="7989" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">编辑:我不再袖手旁观这篇文章的观点，但是导致PureComponent经常无法阻止渲染的技术问题仍然值得理解。</p><p id="4e96" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">浪费渲染是performant React.js代码中的一个大问题。React核心团队想出了一个解决方案:React.PureComponent我们来看看它是如何工作的，解决了哪些问题，没有解决哪些问题。</p><p id="152b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那是什么？PureComponent与React完全一样。组件有一个不同之处:它实现了shouldComponentUpdate。这允许它根据一些启发来阻止渲染。PureComponent实现了对新属性和旧属性的浅层相等性检查，对状态也是如此。因此，如果你有道具“a”和“b ”,它基本上会做以下事情:</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="ju jv l"/></div></figure><p id="6f81" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这在理论上很棒，因为我们可以避免昂贵的渲染，大大提高我们的性能。但是，等等！“这太好了，不像是真的”，我听到你说。嗯……你是对的。我们遇到了这些问题！==支票。假设Foo是一个从React.PureComponent扩展而来的组件。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="ju jv l"/></div></figure><p id="3c81" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这三个例子有着相同的问题:Foo将总是重新呈现，因为shouldComponentUpdate总是返回true！在前两个示例中，shouldComponentUpdate检查this.props.x！== nextProps.x，而且自从{}！== {}，对于。地图，它将总是看到的道具已经改变。同样的事情也发生在儿童道具上，这里this.props.children！== nextProps.children。</p><p id="f6ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里的小问题是，我们正在进行shouldComponentUpdate检查，但没有任何收获，这比我上面给出的例子更昂贵，因为它必须迭代当前和下一个props对象的键。</p><p id="ae66" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">更大的问题是，我们假设我们已经解决了一个性能问题，但大多数时候只会让它变得更糟。</p><p id="62d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">嗯…那么我们如何防止不必要的渲染和差异呢？一招！回车:<a class="ae jw" href="https://github.com/brigand/react-update-if-changed" rel="noopener ugc nofollow" target="_blank"> react-update-if-changed </a>。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="ju jv l"/></div></figure><p id="9c2f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个例子中，Foo使用的是react-update-if-changed，而不是PureComponent。而不是检查这个。道具。孩子们！== nextProps.children，它只是检查updateIfChanged属性是否相等。一次相等检查；就是这样。</p><p id="c369" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还有两个遗留问题。</p><ol class=""><li id="68e2" class="jx jy hu it b iu iv iy iz jc jz jg ka jk kb jo kc kd ke kf dt translated">我们可能有多个可以改变的值，或者一个应该通过深度相等来比较的值。在这种情况下，可以使用updateIfChangedEqual={[a，b]} prop。</li><li id="5b8e" class="jx jy hu it b iu kg iy kh jc ki jg kj jk kk jo kc kd ke kf dt translated">我们仍然需要计算上面例子中的<h1>(但不是diff it)，这实际上可能计算起来很昂贵。请参见解决此问题的react-update-if-changed中的<a class="ae jw" href="https://github.com/brigand/react-update-if-changed#updateifchanged-component" rel="noopener ugc nofollow" target="_blank"> UpdateIfChanged </a>组件。</h1></li></ol><p id="f6f2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">做出反应。PureComponent很少有用，但是不要对React.js的出色性能放弃希望！</p><blockquote class="kl km kn"><p id="135a" class="ir is ko it b iu iv iw ix iy iz ja jb kp jd je jf kq jh ji jj kr jl jm jn jo hn dt translated"><a class="ae jw" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jw" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jw" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae jw" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is ko it b iu iv iw ix iy iz ja jb kp jd je jf kq jh ji jj kr jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae jw" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae jw" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae jw" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is ko it b iu iv iw ix iy iz ja jb kp jd je jf kq jh ji jj kr jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jw" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jw" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>