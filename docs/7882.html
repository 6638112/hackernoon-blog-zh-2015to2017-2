<html>
<head>
<title>Let’s make a JavaScript Wait function</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们制作一个JavaScript等待函数</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/lets-make-a-javascript-wait-function-fa3a2eb88f11?source=collection_archive---------0-----------------------#2017-11-11">https://medium.com/hackernoon/lets-make-a-javascript-wait-function-fa3a2eb88f11?source=collection_archive---------0-----------------------#2017-11-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/161fdb89a1a5ad806eca6c82a9431a28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QtrfvQ_JAJO7RoQys0jjtg.jpeg"/></div></div></figure><p id="87d8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Async/await及其对承诺的底层使用正在席卷JS世界。现在，在大多数客户端和服务器JS平台T1的支持下，回调T2编程T3已经成为过去。</p><p id="94de" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当然，基于回调的编程是丑陋的。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff kb"><img src="../Images/7cfcbac6732dfbf621f5da29da433782.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*RcuvxRaseJDfG-fRlDbSIA.jpeg"/></div></figure><p id="3cc7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您还没有了解过，那么有必要了解一下async/await和promises。在async/await之前，我个人并不热衷于承诺，因为你可以得到这样的代码:</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff kg"><img src="../Images/cbe3f33437d378cee8c02c0586e1f8ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*aZ35C3n3Tot22E6Phcq4AA.png"/></div></figure><p id="bf42" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">总比回调地狱好，但没有<strong class="je hv">赏心悦目。</strong></p><p id="3175" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有很多关于async/await的很好的介绍，所以我不会在这里进行全面的讨论，而是15秒。教程是，你让你的函数返回一个<em class="kh">承诺</em>，然后使用await(在一个异步函数中)来调用这个承诺。</p><p id="c0ea" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些例子还将利用JS的一个新特性——箭头函数。如果你不熟悉这种风格的写作，基本上是这样的:</p><p id="e06d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">函数(a) { return console.log(a) } </strong></p><p id="7789" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在用这个，</p><p id="7a22" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">(a)=&gt;console . log(a)</strong></p><p id="e9d7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这样，我们就可以创建我们的等待函数了。</p><p id="2f81" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用等待函数，在某些环境中也称为<em class="kh"> Sleep </em>，非常容易理解、读取和写入。这很容易理解。我们希望执行等待一段时间。</p><p id="eead" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">只需设置一个解决承诺的超时时间。我们可以提供等待多长时间的ms。</p><pre class="kc kd ke kf fq ki kj kk kl aw km dt"><span id="356f" class="kn ko hu kj b fv kp kq l kr ks">var wait = ms =&gt; new Promise((r, j)=&gt;setTimeout(r, ms))</span></pre><p id="93cb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">wait(2000)返回一个将在2000毫秒(2秒)内解决的承诺。)</p><pre class="kc kd ke kf fq ki kj kk kl aw km dt"><span id="2ed6" class="kn ko hu kj b fv kp kq l kr ks">// Promise syntax<br/>var prom = wait(2000)  // prom, is a promise<br/>var showdone = ()=&gt;console.warn('done')<br/>prom.then(showdone)</span><span id="a14d" class="kn ko hu kj b fv kt kq l kr ks">// same thing, using await syntax<br/>await wait(2000)<br/>console.warn('done')</span></pre><p id="16ed" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用async/await语法，这比promise的好。then()语法。为了简洁起见，让我们将它包装在一个立即调用的函数中。</p><pre class="kc kd ke kf fq ki kj kk kl aw km dt"><span id="72bd" class="kn ko hu kj b fv kp kq l kr ks">(async () =&gt; { await wait(2000); console.warn('done') })()</span></pre><p id="4ffb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">或者在常规代码中</p><pre class="kc kd ke kf fq ki kj kk kl aw km dt"><span id="d9ad" class="kn ko hu kj b fv kp kq l kr ks">var x = 1<br/>var y = 2<br/>await wait(2000)<br/>console.warn(x)</span></pre><p id="dd2b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们想等待一个事件，而不是仅仅等待x毫秒的时间呢？<br/>承诺解决的时候控制就好。</p><p id="8994" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果事件从未发生，我们甚至可以<em class="kh">超时</em>调用，这样代码就不会永远等待。</p><p id="234e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设我们希望等待一个DOM元素在网页中被设置为“Hello World”。我们将每100毫秒检查一次，2秒后超时。</p><pre class="kc kd ke kf fq ki kj kk kl aw km dt"><span id="6902" class="kn ko hu kj b fv kp kq l kr ks">&lt;div id=a&gt;s&lt;/div&gt;<br/>&lt;script&gt;</span><span id="14e7" class="kn ko hu kj b fv kt kq l kr ks">var e = document.querySelector('#a')<br/>  <br/>  var waitForHello = timeoutms =&gt; new Promise((r, j)=&gt;{<br/>    var check = () =&gt; {<br/>      console.warn('checking')<br/>      if(e.innerHTML == 'Hello world') <br/>        r()<br/>      else if((timeoutms -= 100) &lt; 0)<br/>        j('timed out!')<br/>      else<br/>        setTimeout(check, 100)<br/>    }<br/>    setTimeout(check, 100)<br/>  })</span><span id="6dcf" class="kn ko hu kj b fv kt kq l kr ks">//setTimeout(()=&gt;{e.innerHTML='Hello world'}, 1000)</span><span id="797c" class="kn ko hu kj b fv kt kq l kr ks">  (async ()=&gt;{<br/>    a.innerHTML = 'waiting..'<br/>    waitForHello(2000)<br/>  })()<br/>  <br/>&lt;/script&gt;</span></pre><p id="3989" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">取消对setTimeout行的注释将在1秒后设置DIV，否则将超时。</p><p id="5a63" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如您所见，async/await为您的代码开辟了新的可能性。</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="ku kv l"/></div></figure></div></div>    
</body>
</html>