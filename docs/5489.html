<html>
<head>
<title>Useful Entity Mapping Supporting SharePoint Using TypeScript … and More???</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TypeScript支持SharePoint的有用实体映射…等等？？？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/useful-entity-mapping-supporting-sharepoint-using-typescript-and-more-90f4aef99782?source=collection_archive---------4-----------------------#2017-07-29">https://medium.com/hackernoon/useful-entity-mapping-supporting-sharepoint-using-typescript-and-more-90f4aef99782?source=collection_archive---------4-----------------------#2017-07-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="3f1d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">TL；DR——我用TypeScript编写了一个实体映射器，它利用了抽象类，非常适合SharePoint。这种技术可能同样适用于其他后端领域。TypeScript是这种工具的有力支持者。</p></div><div class="ab cl jp jq hc jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hn ho hp hq hr"><h1 id="14d0" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">历史</h1><p id="1a44" class="pw-post-body-paragraph ir is hu it b iu ku iw ix iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo hn dt translated">如果您只想获得代码，请跳过这一部分。</p><p id="f130" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">多年来，我们SharePoint开发人员一直在编写将SharePoint部分视为数据库的应用程序。对于许多不太了解它的人来说，SharePoint是一个协作平台，支持各种协作，包括社交、工作流程、文档管理和相关的等等。</p><p id="c32e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它还有一个“列表”的概念，很像一个数据库表。MSFT提供了API，让我们可以对它们执行常见的CRUD操作。然而，列表项实际上是比DB表更高级的实体。它们可以通过API来保护，它们可以被社会标记(评分和喜欢)。他们可以被批准，参与工作流程和其他yadda yadda yaddas。SharePoint也为列表项提供了非常实用的用户界面。</p><p id="96a7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在SharePoint客户端开发的早期，我们倾向于使用像<a class="ae kz" href="http://sympmarc.github.io/SPServices/" rel="noopener ugc nofollow" target="_blank"> SPServices </a>这样的<a class="ae kz" href="https://hackernoon.com/tagged/tools" rel="noopener ugc nofollow" target="_blank">工具</a>，由聪明绝顶的Marc D Anderson组装和管理。没有他的工具，你会写很多美元。ajax()调用端点，解析XML或JSON响应，希望它是格式良好的，等等。人们仍然在使用它。太棒了。</p><p id="86fc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">大约两年前，在微软发布“SharePoint框架”(或者SPFx，他们最新的一款SP开发工具)之前，我开始使用TypeScript。那时没有抽象类，这影响了我使用它的方式。</p><h1 id="0e02" class="jw jx hu bd jy jz la kb kc kd lb kf kg kh lc kj kk kl ld kn ko kp le kr ks kt dt translated">基本模型和实体映射</h1><p id="87fd" class="pw-post-body-paragraph ir is hu it b iu ku iw ix iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo hn dt translated">当我必须编写一个使用SharePoint列表的终端用户特性时，我会从一种模型对象开始，由列表的列通知。我们可以创建一个SharePoint列表来支持滚动新闻滚动条，如下所示:</p><ul class=""><li id="6520" class="lf lg hu it b iu iv iy iz jc lh jg li jk lj jo lk ll lm ln dt translated"><strong class="it hv">标题</strong>:字符串</li><li id="8970" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><strong class="it hv">描述</strong>:多行文本</li><li id="ef95" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><strong class="it hv">生效日期</strong>:日期</li><li id="ad61" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><strong class="it hv">截止日期</strong>:日期</li><li id="ca5a" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><strong class="it hv">显示顺序</strong>:数字</li></ul><p id="6387" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是这个列表的一个非常简单的类型脚本模型:</p><figure class="lt lu lv lw fq lx"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="f3bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这给了我一个简单的存储桶来保存列表项，从那里，我可以完成所有的UI工作，并将其与列表同步(数据检索和将更新保存回列表)。同步过程基于连接到SharePoint REST端点的通用“调用sharepoint api”类型函数。读取操作采取以下形式:</p><ol class=""><li id="60bc" class="lf lg hu it b iu iv iy iz jc lh jg li jk lj jo ma ll lm ln dt translated">调用通用的“调用SharePoint API”函数。(一般是指它只接受一个端点url并执行GET/POST；不是<t>通用)。</t></li><li id="1ac0" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo ma ll lm ln dt translated">从“物理”的角度处理回答，意思是——它出错了吗？这是最低限度的有效反应吗？</li><li id="17e8" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo ma ll lm ln dt translated">将有效响应(通常以JSON格式)返回给调用者。</li><li id="d753" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo ma ll lm ln dt translated">然后调用者将这个JSON字符串传递给一个工厂对象。工厂对象理解特定的JSON响应，并为我创建一个TypeScript对象。</li></ol><p id="6333" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是工厂:</p><figure class="lt lu lv lw fq lx"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="0132" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是基本的实体映射。CreateNewsItemFromJSON是NewsItem()对象的工厂。它将JSON响应映射回实体。其中，您可以看到SharePoint列名不一定与TypeScript字段名匹配。</p><p id="f6d0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我有点过于简化了，因为我实际上费了很大劲定义了一个接口来匹配JSON响应，所以我得到了一些很好的智能感知，因为我不需要依赖任何输入参数。</p><p id="885f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我花了一点时间在我的书<a class="ae kz" href="https://goo.gl/fk12K2" rel="noopener ugc nofollow" target="_blank"> <em class="mb">和另一本打字本</em> </a> <em class="mb">中谈到了这一点。</em></p><h1 id="74c7" class="jw jx hu bd jy jz la kb kc kd lb kf kg kh lc kj kk kl ld kn ko kp le kr ks kt dt translated">更好的建模和映射</h1><p id="3ca0" class="pw-post-body-paragraph ir is hu it b iu ku iw ix iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo hn dt translated">这很有效。我有我的模型实体，代码可以对它进行操作，而没有“天哪，这是一个共享列表，x0020去哪里了？？？“这些东西被安全地藏在工厂方法中，并与应用程序的其他部分很好地隔离开来。</p><p id="3e54" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一方面，我最终写了很多工厂对象。他们每个人都差不多。它们都有一个接受JSon参数的“createObjectFromJSon()”方法。我使用了接口来描述JSON，所以这很有帮助，但是即使这样，你最终还是会得到很多重复的代码。这是一个复制/粘贴的烂摊子，远远没有干。</p><p id="fab7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，当TypeScript中出现真正的泛型时，我已经忍受了一段时间。使用泛型非常有意义。SharePoint列表支持的每个实体都可以参与相同的操作，例如:</p><ul class=""><li id="bae7" class="lf lg hu it b iu iv iy iz jc lh jg li jk lj jo lk ll lm ln dt translated">创造</li><li id="b176" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">阅读</li><li id="b896" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">更新</li><li id="9c0a" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">删除</li></ul><p id="8a5e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">而且:</p><ul class=""><li id="2069" class="lf lg hu it b iu iv iy iz jc lh jg li jk lj jo lk ll lm ln dt translated">分配和删除安全性</li><li id="123f" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">用1到5的等级给这个项目打分</li><li id="135e" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">“喜欢”一个项目</li><li id="2d8e" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">获取其包含列表的ID (Guid)</li></ul><p id="94b0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">能做这样的事情不是很好吗？</p><figure class="lt lu lv lw fq lx"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="117e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">TypeScript泛型使之成为可能:</p><figure class="lt lu lv lw fq lx fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mc"><img src="../Images/e7fef503136578320274278b28e127a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oogg8rviiTdr4qqtHD43Jw.png"/></div></div></figure><p id="7dc5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上面的小屏幕截图显示了一个“列表助手”对象能够对“新闻条目”执行所有这些操作</p><p id="661e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了实现这一点，我必须用新的功能扩展这个模型。从上面的基本模型到我的代码库的当前状态，我没有一个很好的中间步骤，所以这个清单有点令人吃惊:</p><figure class="lt lu lv lw fq lx"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="a0b8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们把它分成更小的部分:</p><figure class="lt lu lv lw fq lx"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="dd75" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">文件的顶部导入了一些对象和实用程序类:</p><ul class=""><li id="ee27" class="lf lg hu it b iu iv iy iz jc lh jg li jk lj jo lk ll lm ln dt translated"><strong class="it hv"> EntityHelper </strong>:在模型中进一步使用的一些静态实用程序类的主页</li><li id="df09" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><strong class="it hv"> EntityReadWriteAccess </strong>:表示某些属性是应该读写到SharePoint还是只是读取。例如，我们不想写回SharePoint IDs。</li><li id="7405" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><strong class="it hv"> AbstractViewPortItem </strong>:这包含了一系列对象(新闻条目、特色新闻、收藏等)共有的属性集合。</li><li id="5116" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><strong class="it hv"> SFInterfaces: </strong>定义了一些公共接口。</li></ul><p id="3381" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是下一大块:</p><figure class="lt lu lv lw fq lx"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="e1cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，它在清单的第1行为模型定义了一个接口。注意，它定义了一个接口，该接口扩展了另一个接口“<strong class="it hv">ISharePointListBackedEntity</strong>”。这很重要，因为实现该接口的任何实体现在都可以使用上面显示的所有SharePoint列表操作。(如果你想深入了解抽象类的解释，<a class="ae kz" href="https://hackernoon.com/abstract-classes-in-typescript-text-video-cda9a4e6a56a" rel="noopener ugc nofollow" target="_blank">试试我不久前发布的这篇博文+视频组合</a>)</p><p id="39be" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它定义了核心模型属性，如标题、生效日期和截止日期等。</p><p id="d2d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">实体的构造函数在第22行调用超级的构造函数，然后给属性分配有用的默认值。</p><p id="74c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是最后一块:</p><figure class="lt lu lv lw fq lx"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="8219" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这段代码定义了一个静态方法<strong class="it hv"> GetSharePointMetadata() </strong>。正如您将看到的，通用SP List Helper使用此元数据在运行时在SharePoint列表的列和此实体的属性之间进行映射。</p><p id="cdd9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">发生了很多事。我们先来看第10行。这定义了实际的映射，并通过填充一个数组colMappings来实现。下面是一个典型的映射:</p><figure class="lt lu lv lw fq lx fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mj"><img src="../Images/3590d6ed8ebae91787d7b992792d535c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YdzENWqG-Mmkyez7Vrx-wA.png"/></div></div></figure><p id="d7a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这定义了名为“ID”的SharePoint列表列和模型属性“SharePointID”之间的映射。在运行时，代码将SharePointID”列表列填充到模型的“SharePointID”属性中，以进行读取操作。可选的第三个参数，“EntityReadWriteAccess。READ_ONLY”表示写回SharePoint时忽略此映射。(缺省值是Read和Write，这就是为什么在其他属性中看不到它的原因)。</p><p id="7503" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">低级映射是通过EntityMapper类上的静态方法集合来完成的。每种SharePoint数据类型都有一个关联的方法。这些mapplet函数了解如何将整数的JSON响应转换为类型脚本数字，将SharePoint JSON MMS对象转换为字符串数组等。</p><p id="c37a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还有最后一个强制链接SharePoint列表本身的名称。这在第8行完成。</p><p id="d1c6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了直接映射之外，还有一些最后的事情要做。</p><p id="28f3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在第4行，我定义了一个“控制台日志标签”。助手使用它来发出带有标签的日志消息，以区别于可能注销到控制台的其他助手。</p><p id="2334" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，有这样一行:</p><figure class="lt lu lv lw fq lx fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mk"><img src="../Images/b93b9bc219134f6b73172ffd676c58b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5tpLa7z1umzuqsTb5wHAwg.png"/></div></div></figure><p id="2c40" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在运行时，为了验证映射的完整性，创建一个空实例是很有帮助的。该验证在运行时由以下函数实现:</p><figure class="lt lu lv lw fq lx fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff ml"><img src="../Images/e10abc2584457748bc05000d6fd37d03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vqr5A-JeV17d-qluSBZXYQ.png"/></div></div></figure><p id="6fc0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通用实体助手在运行时调用这些验证函数，以帮助减少使用区分大小写的字段名和棘手拼写时出现的常见问题，当您被迫将JSON中的文本字符串与类属性或其他<a class="ae kz" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>变量进行匹配时，就会出现这些问题。如果我们试图将一个类属性“xyzzy”映射到一个不存在的SharePoint列表列，这些验证函数将抛出一个错误，反之亦然。它将捕获如下无效映射:</p><blockquote class="mm mn mo"><p id="78e0" class="ir is mb it b iu iv iw ix iy iz ja jb mp jd je jf mq jh ji jj mr jl jm jn jo hn dt translated"><em class="hu">好</em>:</p><p id="4dd3" class="ir is mb it b iu iv iw ix iy iz ja jb mp jd je jf mq jh ji jj mr jl jm jn jo hn dt translated">实体助手。GetIntegerMapping("ID "，" SharePointID "，……)；</p><p id="8637" class="ir is mb it b iu iv iw ix iy iz ja jb mp jd je jf mq jh ji jj mr jl jm jn jo hn dt translated">不好:</p><p id="1076" class="ir is mb it b iu iv iw ix iy iz ja jb mp jd je jf mq jh ji jj mr jl jm jn jo hn dt translated">实体助手。GetIntegerMapping("ID "，" SharepointID "，……)；</p></blockquote><p id="2233" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在“好”的情况下，ID映射到SharePointID。</p><p id="9a8c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这种情况下，SharepointID拼写错误。运行时验证逻辑检测到这个问题，并向您发出警告。</p><figure class="lt lu lv lw fq lx fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mj"><img src="../Images/3590d6ed8ebae91787d7b992792d535c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YdzENWqG-Mmkyez7Vrx-wA.png"/></div></div></figure><p id="46d7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">基本思想是，我们可以创建一个model.ts文件，以一种更具声明性的方式将模型连接到SharePoint列表。通过设置具有映射(例如“VP _ Effective Date”←→“生效日期”)和适当的序列化/反序列化函数的<strong class="it hv"> colMappings </strong>数组，我们不再需要关心解析JSON、构造正确命中REST端点的URL等等。就实体映射而言，有一个真实的来源。</p><p id="86cf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">能够在运行时验证映射是锦上添花。</p><h1 id="5445" class="jw jx hu bd jy jz la kb kc kd lb kf kg kh lc kj kk kl ld kn ko kp le kr ks kt dt translated">实际效果</h1><p id="205d" class="pw-post-body-paragraph ir is hu it b iu ku iw ix iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo hn dt translated">这里有一个简短的视频，展示了使用这样的工具是什么感觉:</p><figure class="lt lu lv lw fq lx"><div class="bz el l di"><div class="ms lz l"/></div></figure><p id="bb2d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用这样的抽象类有几个非常好的结果:</p><ul class=""><li id="ef40" class="lf lg hu it b iu iv iy iz jc lh jg li jk lj jo lk ll lm ln dt translated">强类型结果。</li><li id="b19e" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">自动映射到SharePoint列表列。</li><li id="3b73" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">一致的CRUD+操作。总是“帮手。SaveItem()”或“helper。DeleteItem()”。</li><li id="4b5a" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">修复一个方法的错误就能修复所有方法。我记得在一个项目中，我在一个早期的工厂地图绘制器中犯了一个常见的错误。我必须对十几个工厂进行同样的更新，在我做的时候引入了一个新的错误，等等。</li><li id="48cc" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">为一个模型实体添加新的功能意味着所有的模型实体都可以享受它。例如，当我开始做这个的时候，我只关注获取、保存和删除。有一次，我需要设置安全性。我用安全功能增强了核心splisthelper对象，现在所有模型都可以得到保护。</li></ul><h1 id="9c9d" class="jw jx hu bd jy jz la kb kc kd lb kf kg kh lc kj kk kl ld kn ko kp le kr ks kt dt translated">明智的后续步骤</h1><p id="8257" class="pw-post-body-paragraph ir is hu it b iu ku iw ix iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo hn dt translated">这种实体映射代码是有机发展的，是一次很好的学习经历。它运行良好，但有一些明显的机会来改善它。</p><p id="e91e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">做这样的事情会很好:</p><figure class="lt lu lv lw fq lx"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="1968" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">基本上，使用TypeScript Decorators来指定实体映射，而不是我正在使用的静态方法。</p><p id="6ec9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"/><p id="e684" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><postscript/></p><p id="0508" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我最近出版了一本关于TypeScript的书！这是免费的，你可以在这里获得:<a class="ae kz" href="https://www.gitbook.com/book/pagalvin/yet-another-typescript-book/details" rel="noopener ugc nofollow" target="_blank">https://www . git book . com/book/pagal vin/yet-another-typescript-book/details</a></p><p id="b2ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"/><figure class="lt lu lv lw fq lx"><div class="bz el l di"><div class="mt lz l"/></div></figure></div></div>    
</body>
</html>