<html>
<head>
<title>Functional data validation in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的功能数据验证</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/functional-data-validation-in-swift-2cf2c28d55cd?source=collection_archive---------7-----------------------#2017-09-24">https://medium.com/hackernoon/functional-data-validation-in-swift-2cf2c28d55cd?source=collection_archive---------7-----------------------#2017-09-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="f3f3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我将谈谈我在Swift中创建的一个小库，它既可以独立使用，也可以与<a class="ae jp" href="https://github.com/typelift/Swiftz" rel="noopener ugc nofollow" target="_blank"> Swiftz </a> lib一起使用。它叫做<a class="ae jp" href="https://github.com/RPallas92/Swiftz-Validation" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> Swiftz-Validation。</strong> </a></p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/1ee2a8f80000436a0ade407958498b13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gfmaVQKjba0As4J_Bdo5vQ.png"/></div></div></figure><h2 id="e0e7" class="kc kd hu bd ke kf kg kh ki kj kk kl km jc kn ko kp jg kq kr ks jk kt ku kv kw dt translated">什么是Swiftz-验证？</h2><p id="d3ab" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">这是一种典型的表单验证模型的数据结构，在其他场景中，您希望聚合所有失败，而不是在发生错误时短路(Swiftx更适合这种情况)。验证可能是成功的(值)，包含成功的值，也可能是失败的(值)，包含错误。</p><p id="b2bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">验证是实现应用接口(<code class="eh lc ld le lf b">.ap</code>)的数据结构，并且以这样的方式实现:如果一个失败被应用到另一个失败，则它导致包含两个验证的失败的新验证。换句话说，验证是一种为可以聚集的错误而创建的数据结构，它在表单验证这样的上下文中是有意义的，在表单验证中，您希望向用户显示所有未通过验证的字段，而不仅仅是在第一次失败时就停止。</p><p id="22a3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">验证不能很容易地用于排序操作，因为<code class="eh lc ld le lf b">.ap</code>方法需要两个验证，所以创建它们的操作必须已经执行了。虽然有可能以连续的方式使用验证，但是最好将这项工作留给<a class="ae jp" href="https://github.com/typelift/Swiftx/blob/master/Sources/Either.swift" rel="noopener ugc nofollow" target="_blank">或者</a>，一个为此而设计的数据结构。</p><h2 id="54b4" class="kc kd hu bd ke kf kg kh ki kj kk kl km jc kn ko kp jg kq kr ks jk kt ku kv kw dt translated">验证数据示例</h2><p id="a642" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">在下面的例子中，我们将验证一个密码:它应该包含8个以上的字符，它应该包含一个特殊字符，它必须不同于用户名。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lg lh l"/></div></figure><h1 id="106a" class="li kd hu bd ke lj lk ll ki lm ln lo km lp lq lr kp ls lt lu ks lv lw lx kv ly dt translated">使用Swiftz-Validation的优势</h1><p id="900f" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">像表单和模式验证这样的事情在<a class="ae jp" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>中很常见，但是我们最终要么使用分支，要么为每种情况设计非常具体的解决方案。</p><p id="d94f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于分支，我的意思是使用if-else条件，事情会很快失控，它无法扩展，因为很难抽象它，也很难推理每个规则。让我们看一个使用分支的相同验证的例子:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lg lh l"/></div></figure><p id="ab91" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为这个函数使用了<code class="eh lc ld le lf b">if</code>条件并修改了一个局部变量，所以它不是很模块化。这意味着不可能将这些检查分割成更小的部分，让它们自己完全理解——它们修改了某些东西，所以你必须理解它们是如何修改那个东西的，在什么环境下，等等。对于非常简单的事情来说，这还不算太糟糕，但是随着复杂性的增长，它变得难以管理。</p><h2 id="c4ce" class="kc kd hu bd ke kf kg kh ki kj kk kl km jc kn ko kp jg kq kr ks jk kt ku kv kw dt translated">优势</h2><p id="6a33" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">Swiftz-Validation的主要优势在于:</p><ul class=""><li id="38bf" class="lz ma hu it b iu iv iy iz jc mb jg mc jk md jo me mf mg mh dt translated">每个验证都易于理解和推理</li><li id="312d" class="lz ma hu it b iu mi iy mj jc mk jg ml jk mm jo me mf mg mh dt translated">易于构建验证规则</li><li id="5ee3" class="lz ma hu it b iu mi iy mj jc mk jg ml jk mm jo me mf mg mh dt translated">易于重用验证规则和组成更复杂的验证<a class="ae jp" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">(干原理)</a></li><li id="d369" class="lz ma hu it b iu mi iy mj jc mk jg ml jk mm jo me mf mg mh dt translated">它有一个众所周知的接口或抽象来工作(它是一个函子，指出，应用和半群)。因此，您可以用<strong class="it hv"> sconcat(半群)</strong>组合验证，用<strong class="it hv"> ap(适用的)</strong>应用函数，用<strong class="it hv"> fmap(仿函数)</strong>转换结果，用<strong class="it hv"> switch </strong>语句对某种模式匹配的结果做出反应。</li></ul><p id="66ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在下面的例子中，您可以看到验证结构如何为您提供一个<a class="ae jp" href="https://hackernoon.com/tagged/tool" rel="noopener ugc nofollow" target="_blank">工具</a>,用于以可重用(DRY)和可组合的方式建立验证库和函数:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lg lh l"/></div></figure><h1 id="5797" class="li kd hu bd ke lj lk ll ki lm ln lo km lp lq lr kp ls lt lu ks lv lw lx kv ly dt translated">如何使用图书馆</h1><p id="de96" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">验证库作为一个<strong class="it hv">枚举</strong>实现，有两种情况:</p><ul class=""><li id="cbfd" class="lz ma hu it b iu iv iy iz jc mb jg mc jk md jo me mf mg mh dt translated"><strong class="it hv">成功</strong>(成功值)—代表一个成功值。</li><li id="8e12" class="lz ma hu it b iu mi iy mj jc mk jg ml jk mm jo me mf mg mh dt translated"><strong class="it hv">失败</strong>(Failure value)——代表一个不成功的值。</li></ul><p id="60d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">验证函数只是返回这两种情况中的一种，而不是抛出错误或改变其他变量。使用验证的关键是:</p><ul class=""><li id="9d00" class="lz ma hu it b iu iv iy iz jc mb jg mc jk md jo me mf mg mh dt translated"><strong class="it hv">组合验证:</strong>有时候我们想要创建非常复杂的验证规则。关键是创建简单的可重用和可组合的验证，并将它们组合成一个复杂的验证结构。</li><li id="2978" class="lz ma hu it b iu mi iy mj jc mk jg ml jk mm jo me mf mg mh dt translated"><strong class="it hv">转换验证值:</strong>有时我们得到的验证值并不是我们想要的。我们真的不想改变任何关于验证状态的东西(不管是通过还是失败)，但是我们想稍微调整一下<em class="mn">值</em>。这相当于在表达式中应用函数。</li><li id="838b" class="lz ma hu it b iu mi iy mj jc mk jg ml jk mm jo me mf mg mh dt translated"><strong class="it hv">对验证结果做出反应:</strong>一旦我们有了验证结果，我们需要一种方法来相应地对值是成功还是失败做出反应。</li></ul><p id="f91f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们将看到一些例子:</p><p id="f53a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">组合验证</strong></p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lg lh l"/></div></figure><p id="8199" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">转换验证值</strong></p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lg lh l"/></div></figure><p id="5367" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">对验证结果做出反应</strong></p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lg lh l"/></div></figure><h1 id="eedb" class="li kd hu bd ke lj lk ll ki lm ln lo km lp lq lr kp ls lt lu ks lv lw lx kv ly dt translated">结论</h1><p id="555b" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">我写这个库是作为一个个人实验，因为核心SwiftZ库不包括类似的数据结构，我认为这是一个非常重要的数据结构，因为验证在每个sowftware程序中都很常见。该库仍在开发中，但它可以与SwiftZ一起使用，也可以独立使用。我会添加更多像liftA3和类似的操作。</p><p id="81b8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">随时拉要求回购和改善它，谢谢！。</p><p id="fe6a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个库的灵感来自Haskell的验证包:<a class="ae jp" href="https://hackage.haskell.org/package/Validation" rel="noopener ugc nofollow" target="_blank">https://hackage.haskell.org/package/Validation</a></p><p id="6218" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">鸣谢</strong></p><ul class=""><li id="36c3" class="lz ma hu it b iu iv iy iz jc mb jg mc jk md jo me mf mg mh dt translated">感谢<a class="mo mp gr" href="https://medium.com/u/d278e9977263?source=post_page-----2cf2c28d55cd--------------------------------" rel="noopener" target="_blank">何塞·路易斯·阿尔卡拉</a>在Swift和SwiftZ上对我的帮助。</li><li id="3fa8" class="lz ma hu it b iu mi iy mj jc mk jg ml jk mm jo me mf mg mh dt translated">感谢@jlopez_rz帮我做测试用例。</li><li id="6080" class="lz ma hu it b iu mi iy mj jc mk jg ml jk mm jo me mf mg mh dt translated">感谢Jorge Aznar 帮我写这篇文章。</li></ul><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mq lh l"/></div></figure></div></div>    
</body>
</html>