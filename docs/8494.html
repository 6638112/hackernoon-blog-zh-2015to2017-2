<html>
<head>
<title>From on-prem to AWS to ECS and beyond. The past 5 years at Arthrex Digital Media.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从内部部署到AWS再到ECS等等。在亚瑟王数字媒体公司的过去5年。</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/from-on-prem-to-aws-to-ecs-and-beyond-the-past-5-years-at-arthrex-digital-media-f68bc2bc534e?source=collection_archive---------17-----------------------#2017-12-04">https://medium.com/hackernoon/from-on-prem-to-aws-to-ecs-and-beyond-the-past-5-years-at-arthrex-digital-media-f68bc2bc534e?source=collection_archive---------17-----------------------#2017-12-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="1dfe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">今年12月标志着我在Arthrex数字媒体部门工作了5年(当我开始工作时，这个部门还不存在)。Arthrex是一家医疗保健公司，专门从事矫形器械、硬件和技术。数字媒体团队特别关注外科医生和患者教育、手术结果跟踪等。</p><p id="40bb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">回顾这5年的里程碑，我觉得这是一个值得分享的基础设施发展故事。我们最初从由另一个内部团队管理的本地虚拟机迁移到AWS云的故事。然后，您可以跟随我们从以EC2为中心的部署到当前ECS方法的迁移。然后，我们可以展望一下不久的将来，并涵盖我们2018年的计划。我将掩饰我们使用过的过时/退役的技术，并在我们的部署更新时提供更多细节。</p></div><div class="ab cl jp jq hc jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hn ho hp hq hr"><p id="9e80" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第一天:2012年12月17日，离所谓的世界末日还有短短的4天，我们负责的少数web应用程序是用coldfusion或flex编写的。我们这个时代的研究主题将是arthrex.com，它托管在两个Windows 2008虚拟机和一个裸机Windows系统上(被亲切地称为“节点a”、b和c)。这些应用服务器由Cisco NetScaler进行负载平衡。当时，我们所有应用程序的数据存储是一个2008 MSSQL server设置，用于跨数据中心进行手动故障转移。</p><p id="a5c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">软件和系统补丁以及部署都是手动完成的，最多需要从负载平衡器中删除节点、打补丁并重新启动机器，然后再手动将它们重新添加到负载平衡器中，完全不需要自动化。至少在部署过程中需要重启应用服务器。</p><p id="34ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">随着时间的推移，这些节点开始显示它们的年龄，主要是在部署期间，这在当时有一个坏习惯，即在一天的晚些时候发生。每当一个节点必须重启时，我们都不确定它是否会及时恢复。再加上负载均衡器上的请求备份，当非常慢的(当时的)应用服务器准备好服务并返回负载均衡器时，它们就会过载。我们最终不得不在添加节点之前预热它们，通过WebEx协调将它们加入和退出负载平衡组。</p><p id="ba43" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们刚刚谈到的所有这些资源，以及DNS、电子邮件、监控(或缺乏监控)都是由我们部门之外的基础架构团队管理的。在一个成长中的公司中，相互冲突的优先级和不同的技术意识形态有时会给变更、规划部署甚至故障排除带来困难。</p><p id="acf7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">事情需要改变，是时候把我们的命运掌握在自己手中了。</p></div><div class="ab cl jp jq hc jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hn ho hp hq hr"><p id="3cfe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们跳到一年后的2013年第四季度，以及surgicaloutcomesystems.com(SOS)的背景，这是一个内部开发的Rails应用程序，已准备好进行部署。这个应用程序是对当时包含PHI的本地flex应用程序的重写。随着它从flex转移到rails，问题是，我们如何托管它？我们是否可以提交一张服务台票证，并通过电子邮件发送给基础架构团队，然后随时待命？经过许多内部辩论、与AWS的讨论以及许多会议之后，商业案例被提出并被同意转移到AWS。据我所知，我们是首批签署AWS HIPAA合规性BAA的公司之一。当然，至少SOS会成为第一个托管在云中的Arthrex应用程序。</p><p id="576c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">舞台已经搭好，繁文缛节已经取消，手铐也已经取下。order，one rails应用程序在AWS上以高可用性、HIPAA兼容的方式托管。基础设施即代码是我们DevOps团队的核心租户。对于配置管理，Puppet solo会将系统与我们期望的状态同步。编排是通过嵌套的云信息堆栈完成的，这些堆栈在网络、计算、数据存储等方面进行了逻辑分区。至于CI和部署工作，我们安装了一个Jenkins服务器，在这里我们还安装了<a class="ae jw" href="https://github.com/hubotio/hubot" rel="noopener ugc nofollow" target="_blank"> Hubot </a>用于Hipchat中ChatOps驱动的部署。为了监控，我们带来了新的遗物。OpenVPN将为开发人员、质量保证人员、数据库管理员和运营人员提供我们需要的任何私有<a class="ae jw" href="https://hackernoon.com/tagged/network" rel="noopener ugc nofollow" target="_blank">网络</a>。</p><p id="3d7a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的VPC设计将公共子网用于带有互联网网关的elb，将带有EC2 nat实例的私有子网用于我们的应用程序和数据库服务器。为了将AWS最佳实践与高可用性相结合，我们在具有预烘焙ami的自动扩展组中跨多个AZs *部署了我们的EC2实例，这意味着不再有宠物节点a、b和心爱的节点c。在自动扩展组中和EC2上，这些应用节点必须是无状态的，这里没有本地会话存储，因为现在它们可能随时消失，这与本地不同。</p><p id="113d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">VPC设计(简化版):</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff jx"><img src="../Images/5bc2f947a4bf9c0fc6e42da720c2d50b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tp8_xV2hISZ7beCCFnQFGA.png"/></div></div></figure><p id="65e0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在任何生产代码变更过程中，一旦它已经过QA测试并签字同意，我们将对单个节点进行金丝雀部署。一旦看起来不错，我们就基于那个节点烘焙一个新的AMI，用新的AMI更新一个cloudformation参数，用滚动部署更新我们的自动伸缩组。为了开始这个全自动的过程，您将运行<code class="eh kj kk kl km b">hubot deploy production</code>来做金丝雀，运行<code class="eh kj kk kl km b">hubot ship production</code>来烘焙AMI并更新云形成。</p><p id="0c97" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">*跨区域部署仍然是我们希望完成的事情，新的<a class="ae jw" href="https://aws.amazon.com/about-aws/whats-new/2017/11/announcing-support-for-inter-region-vpc-peering/" rel="noopener ugc nofollow" target="_blank">跨区域VPC对等</a>让这变得更加令人兴奋！</p><p id="f211" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了检查合规性，我们仅限于AWS服务的一个子集，其中一些有特定的限制，一些要求今天仍然存在。任何EC2资源都必须位于专用的VPC内，所有PHI都必须在静态和传输中加密，ELB只能在tcp/ssl模式下运行，这使得捕获请求者的真实远程ip变得更加困难，没有RDS支持，这样的例子不胜枚举。</p><p id="3bcf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">数据迁移计划已准备好从旧模式迁移到新模式。DNS已准备好更新。基础设施、监控和部署流程都已就绪。2014年初，SOS在AWS上重新启动，并继续运行相同的代码库，但基础架构和流程发生了巨大变化。</p></div><div class="ab cl jp jq hc jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hn ho hp hq hr"><p id="6429" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">SOS中使用的基础设施架构模式被应用到团队承担的所有新建项目中。我们有一些由yaml驱动的可预处理的cloudformation模板，您可以更简洁地在其中声明应用程序，以便轻松地遵循该模式。我们也可以将一些网站转移到s3静态网站。到2014年底，我们在AWS上有了稳固的立足点，但我们在内部仍有相当大的份额，包括arthrex.com及其不断增长的各种问题。</p><p id="e7dd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们开始部署和迁移更多的支持企业<a class="ae jw" href="https://hackernoon.com/tagged/tools" rel="noopener ugc nofollow" target="_blank">工具</a>到云，如吉拉、Confluence和Github，考虑到我们公司办公室有许多用户，在办公室使用AWS VPN连接建立VPN连接是有意义的。我们还将我们的整体部署划分为多个VPC，以实现职责的逻辑分离，并通过VPN连接将每个新的VPC连接到办公室。这演变成了基于职责的多帐户策略，我们可以使用IAM角色来控制跨帐户的权限和访问。</p></div><div class="ab cl jp jq hc jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hn ho hp hq hr"><p id="5603" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2015年，进入我们的容器采用时代。作为一个DevOps团队，我们花了一段时间来寻找将容器引入工作流的方法，以及如何运行生产docker集群。实验横跨K8s、Deis、Flynn、Panamax、ECS等。当时，其中一些还不成熟，或者运行它们意味着DIY etcd或ceph管理和HA架构……经过一段时间的实验后，我发现这不值得付出额外的开销或压力，至少当有一个很好的开源管理的AWS ECS产品叫做<a class="ae jw" href="https://convox.com/" rel="noopener ugc nofollow" target="_blank"> Convox </a>时，它可以立即用于本地开发和生产质量部署。</p><p id="969e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Convox AWS架构:</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff kn"><img src="../Images/a523b68f97c6aaa8c094d5503ba9eed6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TcdWVSNj02oBRXyZc2w8hg.jpeg"/></div></div></figure><p id="dd7d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Convox提供了一个核心的预处理cloudformation模板，它为您提供了上述架构(或接近它的日期图),它在AWS ECS中运行自己的api。</p><p id="7024" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Convox强大的<code class="eh kj kk kl km b">convox start</code>命令在cwd中查找Dockerfile和“docker-compose.yml”文件。它们支持docker compose v2的子集来描述本地开发和部署。<code class="eh kj kk kl km b">convox start</code>将在后台运行一个<code class="eh kj kk kl km b">docker-compose up</code>命令，连接代码同步，从您的应用程序中附加stdout日志，并将它们路由到您的终端。</p><p id="bf8c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要在AWS上安装你的应用程序，你可以创建<code class="eh kj kk kl km b">convox apps create my-app</code>，然后通过<code class="eh kj kk kl km b">convox deploy -a my-app -f docker-compose.prod.yml</code>部署你的应用程序，这反过来又会创建一个新的cloudformation堆栈。我们使用多个docker-compose。*.yml文件来控制我们是否需要某个容器或端口配置用于不同的目的。这个新的应用程序堆栈将创建一个负载平衡器，在每个docker compose进程的基础上公开docker-compose.yml文件中定义的端口。它还将使用您的docker文件创建ECS任务定义和ECS服务，docker文件附加到调配的负载平衡器。还有一些其他的AWS服务，但这些是最重要的。</p><p id="6fb3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最初，我必须添加对专用网络和定制VPC CIDR设计的支持，以便我们能够部署生产负载和连接我们的VPN。但除此之外，开箱即用的它提供了我们需要的一切，让我们所有的应用程序容器化，并准备开始使用标准的CI管道。综上所述，我们已经找到了我们的容器平台，并开始了对剩余的遗留本地应用程序和现有的基于ec2的应用程序进行容器化的艰难过程。从这一点开始，在2016年初，所有新的开发都是基于docker的。到目前为止，Convox一直是一个很好的操作和部署平台，并在有限的资源下加速了我们最初的容器采用。</p><p id="440c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于使用convox/ecs的服务发现，我们使用<a class="ae jw" href="https://github.com/Kong/kong" rel="noopener ugc nofollow" target="_blank"> kong </a>和<a class="ae jw" href="https://github.com/mybuilder/kongfig" rel="noopener ugc nofollow" target="_blank"> kongfig </a>来声明我们的API。Kong是一个开源API网关，其中我们为dev运行一个kong节点，为prod运行一个集群。我们将它用于web应用的DNS，并作为微服务的真正api网关，包括报头注入、JWT认证等等。我们在这一层保持服务发现的不可知性和声明性，以确保它在应用程序之间是可重复的和一致的。</p><p id="9e5d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们在三个环境中运行kong，本地、开发和生产。每个都有自己的一组api消费者、JWT秘密和通过基于主机名的路由可到达的api端点，允许我们将地址和端口映射到DNS名称，这正是我们需要寻址到我们的单个容器的名称，而不必担心端口，任何东西都可以使用:443和:80，而不管我们的elb上暴露了什么。当然，Kong本身作为一个容器部署在我们的convox local或ecs集群上。</p><p id="d112" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每个kong环境在route53中获得2个映射到其ELB的dns条目，一个直接映射到kong api，即<code class="eh kj kk kl km b">mydevdomain.com</code>，以及一个通配符条目，用于该节点将托管的任何api，即<code class="eh kj kk kl km b">*.mydevdomain.com</code>，其说明了在<code class="eh kj kk kl km b">myservice.mydevdomain.com</code>或<code class="eh kj kk kl km b">mybetterservice.mydevdomain.com</code>暴露的kong API，而无需直接在route53中注册。</p><p id="ef16" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">进一步看一下本地开发，我们正在运行一套容器来提供更好的开发-生产对等性，即kong及其支持容器、postgres和kong dashboard。Kong仪表板用于查看本地和部署的kong并对其进行故障排除。该套件在docker-compose应用程序中描述，当安装docker.sock时，该应用程序还提供用户定义的网络。我们将它隐藏在本地cli后面，但其内部工作原理如下:</p><p id="907e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">创建或启动名为“arthrex”的应用程序，并分离流程:</p><p id="7b83" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kj kk kl km b">docker-compose --project-name arthrex up -d --force-recreate</code>。</p><p id="2afe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">而这里是对应的docker-compose.yml:</p><pre class="jy jz ka kb fq ko km kp kq aw kr dt"><span id="8a26" class="ks kt hu km b fv ku kv l kw kx">version: '2'<br/>services:<br/>  kong-database:<br/>    image: postgres:9.4<br/>    ports:<br/>      - 5432:5432<br/>    networks:<br/>      dev:<br/>        aliases:<br/>         - kong-database.arthrex.xyz<br/>  kong:<br/>    image: kong:0.9.3<br/>    ports:<br/>      - 80:8000<br/>      - 443:8443<br/>      - 8001:8001<br/>      - 7946:7946<br/>      - 7946:7946/udp<br/>    environment:<br/>      - KONG_PG_HOST=kong-database.arthrex.xyz<br/>      - KONG_PG_DATABASE=postgres<br/>      - KONG_PG_USER=postgres<br/>      - KONG_PG_PASSWORD=postgres<br/>    restart: always<br/>    security_opt:<br/>      - seccomp:unconfined<br/>    networks:<br/>      dev:<br/>        aliases:<br/>          - kong.arthrex.xyz<br/>  kongdashboard:<br/>    image: pgbi/kong-dashboard:v2.0.0<br/>    ports:<br/>      - 3070:8080<br/>    networks:<br/>      dev:<br/>        aliases:<br/>          - kong-dashboard.arthrex.xyz<br/>  mailcatcher:<br/>    image: yappabe/mailcatcher:latest<br/>    ports:<br/>      - 1025:1025<br/>      - 1080:1080<br/>    networks:<br/>      dev:<br/>        aliases:<br/>          - mailcatcher.arthrex.xyz<br/>networks:<br/>  dev:<br/>    driver: bridge</span></pre><p id="07bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，让我们来看一个用kongfigure引导的示例应用程序，用于在<code class="eh kj kk kl km b">convox start</code>和<code class="eh kj kk kl km b">convox deploy</code>上进行自我声明。</p><pre class="jy jz ka kb fq ko km kp kq aw kr dt"><span id="bb20" class="ks kt hu km b fv ku kv l kw kx">version: "2"<br/>services:<br/>  kongfigure:<br/>    build: ./kongfigure<br/>    environment:<br/>      - WWW_NAME<br/>      - KONG_HOST<br/>      - WWW_VIRTUAL_HOST<br/>      - API_URL<br/>    links:<br/>      - www<br/>    volumes:<br/>      - /var/run/docker.sock:/var/run/docker.sock<br/>  www:<br/>    build: ./www<br/>    environment:<br/>      - API_URL<br/>    ports:<br/>      - 4200<br/>networks:<br/>  dev:<br/>    external:<br/>      name: arthrex_dev</span></pre><p id="40f5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">。/kongfigure/Dockerfile</p><p id="ff40" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kj kk kl km b">FROM arthrex/kongfigure:0.3</code></p><p id="1009" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">。/kongfigure/kongfig.yml</p><pre class="jy jz ka kb fq ko km kp kq aw kr dt"><span id="235c" class="ks kt hu km b fv ku kv l kw kx">apis:<br/>  - name: $WWW_NAME<br/>    attributes:<br/>      request_host: $WWW_VIRTUAL_HOST<br/>      upstream_url: "<a class="ae jw" href="http://$WWW_HOST:$WWW_PORT" rel="noopener ugc nofollow" target="_blank">http://$WWW_HOST:$WWW_PORT</a>"</span></pre><p id="4073" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当应用程序启动时，kongfigure执行其在ONBUILD中烘焙的命令<code class="eh kj kk kl km b">kongfig apply</code>。这将使用本地kongfig.yml文件向kong注册应用程序负载平衡器。<code class="eh kj kk kl km b">$KONG_HOST</code>变量决定了我们的目标是哪个kong环境，本地、开发还是生产。通过与docker-compose.yml链接部分的集成来填充<code class="eh kj kk kl km b">$WWW_NAME</code>和其他变量。</p><p id="54f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Kongfigure还管理我们的docker-compose.yml文件“arthrex_dev”中指定的应用程序专用网络配置，该网络只存在于本地。这只是由基础设施作为代码驱动的另一种方法，这里我们有由代码声明的服务路由。</p><p id="0a26" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">到2016年底，我们将最后一个应用从内部迁移到docker，到2017年初，我们所有的应用都在convox上运行。极大地简化和通用化了我们的rails、go、coldfusion、node和其他应用的操作。目前大约有35个docker节点、130多个应用程序实例和300多个容器。</p></div><div class="ab cl jp jq hc jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hn ho hp hq hr"><p id="ea70" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2017年是我们改造基础设施以使其更易于使用和操作的又一年。两个DevOps团队成员的加入大大加速了这一过程，所以现在我们实际上有了一个真正的团队，而不是一个人的军队！今年的一些重大改进包括环境变量的标准化、从MSSQL到Postgresql的迁移、PRs现在创建并部署到用于隔离测试的按需容器中、我们引入vault作为我们配置的单一真实来源等等！</p><p id="09f4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Vault现在是hashicorp的中央配置和秘密存储。我们在其中存储多种类型的数据，包括第三方工具凭据、数据库凭据、服务器凭据、应用程序配置和机密，不胜枚举。我们建立这样一个商店的主要原因之一是为了应用程序配置的编程访问，以支持我们的自动化计划。</p><p id="fb32" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的新(ish)同事，高级DevOps工程师Braxton Beyer，一直忙着用基于github hook的CircleCI替换我们基于hipchat/hubot/jenkins的部署方案。这个新平台已经经历了几次考验，从circle 1，到circle 2，再到一个定制的docker构建映像，该映像托管了一个用ruby编写的通用构建pipline。ruby built pipeline允许跨我们所有应用程序的标准化部署，因为管道与我们的应用程序的接触点是Convox级别，它不知道它正在部署什么。从运营的角度来看，现在只需学习一个部署流程，但无需动手。从开发人员的角度来看，他们的github PR现在都是部署的动力和接口。展望未来，这个标准管道是开始实施代码质量检查、林挺、静态分析和其他与您的服务/应用程序的可部署性相关的自定义检查的最佳位置，所有这些都在一个位置，并且一次针对所有适用的应用程序。</p><p id="0fe2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个管道中的一个关键步骤是实现一个长期持有的想法，即从github PR's创建按需环境。每当在我们的一个回购上打开一个新的PR时，circleci都会启动一个新的convox/ecs应用程序的供应流程。</p><p id="ec38" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">遵循我们的约定，我们然后将变量<code class="eh kj kk kl km b">$APP_NAME</code>和<code class="eh kj kk kl km b">$APP_ENVIRONMENT</code>注入到构建管道中，这基于github分支或PR名称。然后，我们从vault中提取模板化的env文件，并对其进行评估，即:</p><pre class="jy jz ka kb fq ko km kp kq aw kr dt"><span id="7dcb" class="ks kt hu km b fv ku kv l kw kx">MY_SECRET=thisissecret<br/>VIRTUAL_HOST=$APP_NAME.$APP_ENVIRONMENT.mydevdomain.com<br/>NEW_RELIC_NAME=$APP_NAME-$APP_ENVIRONMENT</span></pre><p id="c210" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">鉴于<code class="eh kj kk kl km b">APP_NAME=myapp</code>和<code class="eh kj kk kl km b">APP_ENVIRONMENT=shiny-feature</code>。这个env文件变成</p><pre class="jy jz ka kb fq ko km kp kq aw kr dt"><span id="a33b" class="ks kt hu km b fv ku kv l kw kx">MY_SECRET=thisissecret<br/>VIRTUAL_HOST=myapp.shiny-feature.mydevdomain.com<br/>NEW_RELIC_NAME=myapp-shiny-feature</span></pre><p id="5fe8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，我们通过<code class="eh kj kk kl km b">convox env set</code>将环境注入到convox中。然后，我们通过<code class="eh kj kk kl km b">convox deploy</code>部署您的应用程序，从那里，您的应用程序将启动，kongfigure将运行并声明您的应用程序路由配置，hipchat/github将收到构建成功的通知并提供新生成的端点。快速冒烟测试、全面的QA测试或开发人员评审可以在代码的实时版本上进行，而不必在本地克隆和运行。这些环境是临时的，并且被设置为在PR合并时被销毁。</p><p id="7a0d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个github PR管道是所有管道中最健壮的，由于它是我们标准开发CI环境和生产环境部署过程的超集，我们的整个基础设施作为代码画面变得非常枯燥。</p><p id="a1af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了向开发人员公开应用程序配置控制，他们每个人都可以通过vault-web UI访问vault，并且能够将他们的应用程序实例的条目更新为JSON对象。我们在集群上运行一个守护进程，确保应用程序配置的状态在我们的convox集群上得到满足。从我们的PR管道生成的评估后的env文件也被写回到vault中，以提供对新应用程序配置的访问。</p></div><div class="ab cl jp jq hc jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hn ho hp hq hr"><p id="e175" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，我们在这里，结束了2017年，仍然将我们的旧应用程序纳入PR管道流程，并开始超越我们的convox部署，展望未来。AWS托管EKS看起来非常令人兴奋，k8s提供的控制平面功能是首屈一指的，AWS上的托管产品是一大胜利。我们在Convox和ECS方面的经验将极大地推动我们对这个新平台进行审查，如果准备好了，就可以投入使用。</p><p id="598f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还希望采取进一步措施来定义关键应用元数据，这些元数据用于为新的和现有的应用提供和推动从概念到部署后监控的整个自动化管道，缩短新服务的启动时间，同时让我们的传统应用与当前的内部最佳实践保持一致。这种顶级元数据将进一步推动下游集成、基础设施和应用程序的配置。</p></div><div class="ab cl jp jq hc jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hn ho hp hq hr"><p id="4ccd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果这些听起来对你有吸引力，Arthrex正在从dev、devops等部门招聘许多职位，请发电子邮件到cleblanc@arthrex.com给我。</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="ky kz l"/></div></figure></div></div>    
</body>
</html>