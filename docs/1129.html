<html>
<head>
<title>Why I’m dropping Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我会生锈</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/why-im-dropping-rust-fd1c32986c88?source=collection_archive---------0-----------------------#2016-09-11">https://medium.com/hackernoon/why-im-dropping-rust-fd1c32986c88?source=collection_archive---------0-----------------------#2016-09-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="10d8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我看到有一种新的系统级编程语言，提供与C++类似的性能，并且没有垃圾收集时，我立刻产生了兴趣。虽然我喜欢用C#或javascript之类的GC语言解决问题，但我有一种挥之不去的感觉，我正在失去C++的原始力量。但是C++有太多的漏洞和其他众所周知的问题，所以我通常会放弃它。</p><p id="0545" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以我一头扎了进去。好家伙，我潜水很深。</p><p id="5e2b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于Rust本身还相当年轻，它的生态系统仍处于发展阶段。对于一些用例来说，<a class="ae jp" href="https://github.com/cyderize/rust-websocket" rel="noopener ugc nofollow" target="_blank"> websockets </a>或者<a class="ae jp" href="https://github.com/serde-rs/json" rel="noopener ugc nofollow" target="_blank"> serialization </a>都有非常好的解决方案，并且很受欢迎。对于其他用例，Rust还是欠缺的。一个这样的用例是OpenGL GUI，比如<a class="ae jp" href="http://cegui.org.uk/" rel="noopener ugc nofollow" target="_blank"> CEGUI </a>或<a class="ae jp" href="https://github.com/wjakob/nanogui" rel="noopener ugc nofollow" target="_blank"> nanogui </a>。为了帮助社区和语言，我选择将nanogui移植到Rust，完全在Rust中，没有使用到C/C++的绑定。这个项目可以在<a class="ae jp" href="https://github.com/Oipo/nanogui-rust-sdl" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="23e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt jq translated">通常在Rust中开始的阶段被称为与借货检查阶段作斗争。和其他人一样，我也有一段时间被如何解决某些问题难住了。幸运的是，在<a class="ae jp" href="https://client00.chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust-beginners" rel="noopener ugc nofollow" target="_blank"># rust-初学者</a>有一个很棒的社区，他们愿意帮助我解决这些愚蠢的问题。这花了我几个星期的时间，但是我已经开始掌握这门语言了。</p><p id="f8f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但我不知道的是，当你遇到障碍时，寻找解决方案就像在丛林中穿行。通常有多个答案看起来像是你问题的解决方案，但是由于一个小细节，不能使用。</p><p id="fe91" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">举个例子:假设您有一个基类小部件，并且希望所有实际的小部件(如标签、按钮或复选框)都具有某些易于共享的功能。在C++或C#等语言中，这是一个很容易解决的问题。您可以根据语言创建一个抽象类或基类，并在实际的类中继承它。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="29f1" class="kj kk hu kf b fv kl km l kn ko">public abstract class Widget {<br/>    private Theme _theme { get; set; }<br/>    private int _fontSize { get; set; }<br/>    public int GetFontSize() {<br/>        return (_fontSize &lt; 0) ? _theme.GetStandardFontSize() : _fontSize;<br/>    }<br/>}</span></pre><p id="4f82" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Rust中，要做类似的事情，你需要<a class="ae jp" href="https://doc.rust-lang.org/book/traits.html" rel="noopener ugc nofollow" target="_blank">特征</a>。然而，特征不知道底层的实现。所以一个trait可以定义抽象函数，但是不能访问任何底层字段。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="915c" class="kj kk hu kf b fv kl km l kn ko">trait Widget {<br/>    fn font_size(&amp;self) -&gt; i32 {<br/>        if self.font_size &lt; 0 { //compiler error<br/>            return self.theme.get_standard_font_size(); //compiler error<br/>        } else {<br/>            return self.font_size; //compiler error<br/>        }<br/>    }<br/>}</span><span id="c68e" class="kj kk hu kf b fv kp km l kn ko">// <a class="ae jp" href="https://play.rust-lang.org/?gist=e3d55a448df62f9d5172a76c5ecdc425&amp;version=nightly&amp;backtrace=0" rel="noopener ugc nofollow" target="_blank">playground</a></span></pre><p id="9c63" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让那件事深入你的内心。我对此的第一反应是“对不起，什么？!"。虽然对OOP有一些合理的批评，但是把它作为一个解决方案是愚蠢的。</p><p id="1b67" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">幸运的是，我发现，有一个很好的方法可以通过请求改变来改变语言。我不是唯一一个认为这是语言中严重受限的部分的人，目前有一个RFC正在让它变得不那么愚蠢。然而，这至少从2016年3月就开始了。特征作为一个概念已经成为语言的一部分很多年了。目前是2016年9月。为什么语言中如此重要和关键的部分仍然缺失？</p><p id="dd16" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在某些情况下，您可以通过向trait添加一个函数来解决这个问题，这个函数不是在trait本身中实现的，而是在一个实际的对象上实现的，然后使用这个函数来完成您的功能。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="b07b" class="kj kk hu kf b fv kl km l kn ko">trait Widget {<br/>    fn get_theme(&amp;self) -&gt; Theme;<br/>    fn get_internal_font_size(&amp;self) -&gt; i32;<br/>    fn get_actual_font_size(&amp;self) -&gt; i32 {<br/>        if self.get_internal_font_size() &lt; 0 {<br/>            return self.get_theme().get_standard_font_size();<br/>        } else {<br/>            return self.get_internal_font_size();<br/>        }<br/>    }<br/>}</span><span id="7493" class="kj kk hu kf b fv kp km l kn ko">// <a class="ae jp" href="https://play.rust-lang.org/?gist=f66f06effd0afa7352e21a25115d892e&amp;version=nightly&amp;backtrace=0" rel="noopener ugc nofollow" target="_blank">playground</a></span></pre><p id="77df" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是现在你有了一个公共函数(特征函数就像一个接口，目前不可能将特征函数标记为mod-only)，你<strong class="it hv"> <em class="jz">仍然</em> </strong>必须在你所有的具体类型中实现它。因此，要么不使用抽象函数并有大量的代码重复，要么使用示例的设置并有稍微少一些但仍然太多的代码重复和一个泄漏的API。两者都不可接受。在C++、C#和heck等成熟语言中，这也不是问题，甚至<a class="ae jp" href="https://github.com/luciotato/golang-notes/blob/master/OOP.md" rel="noopener ugc nofollow" target="_blank"> Go也有合适的答案</a>。</p><p id="37ee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt jq translated">另一个例子。对于nanogui，CEGUI也使用了这个概念，每个小部件都有一个指向父部件的指针和一个指向其子部件的指针向量。这个概念如何映射到Rust？有几个答案:</p><ol class=""><li id="aed9" class="kq kr hu it b iu iv iy iz jc ks jg kt jk ku jo kv kw kx ky dt translated">使用简单的Vec <t>实现</t></li><li id="0819" class="kq kr hu it b iu kz iy la jc lb jg lc jk ld jo kv kw kx ky dt translated">使用Vec </li><li id="9bc0" class="kq kr hu it b iu kz iy la jc lb jg lc jk ld jo kv kw kx ky dt translated">使用Vec <rc>&gt; &gt;</rc></li><li id="6086" class="kq kr hu it b iu kz iy la jc lb jg lc jk ld jo kv kw kx ky dt translated">使用C绑定</li></ol><p id="a318" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从我的旅程开始，我已经尝试了选项1到3，但都有一些缺点，每一个都不适合使用。我目前认为第4点是我唯一剩下的选择。让我逐一介绍一下:</p><p id="c031" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">选项1 </strong></p><p id="40fa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是初学这门语言的人会选择的选项。我也选择了这作为第一个选项，并立即在借用检查器中遇到了问题。当然，使用这种实现意味着小部件成为子部件和父部件的所有者。这是不可能的，因为这样一来，父节点和子节点将会循环引用拥有彼此。</p><p id="83f0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">选项2 </strong></p><p id="8bd2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是我接下来选择的选项。它的优势在于，它相当类似于nanogui的C++风格。有几个缺点，比如不得不在库内外到处使用不安全的块，并且不能让rust借用检查器检查指针的有效性。但是这个选项的主要突破点是目前不可能创建自引用计数对象。注意，我不是指C++的智能指针或者Rust自己的Rc类型。我指的是一个对象，它计算自己被引用了多少次，当这个值达到0时，它就会删除自己。你可以在nanogui的C++版本中找到一个<a class="ae jp" href="https://github.com/wjakob/nanogui/blob/master/include/nanogui/object.h#L25" rel="noopener ugc nofollow" target="_blank">的例子</a>。</p><p id="6d19" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要做到这一点，您需要能够告诉编译器只允许从对象内部删除自己。以下面的Rust为例:</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="3b2d" class="kj kk hu kf b fv kl km l kn ko">struct WidgetObj {<br/>    pub parent: Option&lt;*mut WidgetObj&gt;,<br/>    pub font_size: i32<br/>}</span><span id="77eb" class="kj kk hu kf b fv kp km l kn ko">impl WidgetObj {<br/>    fn new(font_size: i32) -&gt; WidgetObj {<br/>        WidgetObj {<br/>            parent: None,<br/>            font_size: font_size<br/>        }<br/>    }<br/>}</span><span id="c378" class="kj kk hu kf b fv kp km l kn ko">impl Drop for WidgetObj {<br/>    fn drop(&amp;mut self) {<br/>        println!("widget font_size {} dropped", self.font_size);<br/>    }<br/>}</span><span id="2c22" class="kj kk hu kf b fv kp km l kn ko">fn main() {<br/>    let mut w1 = WidgetObj::new(1);<br/>    {<br/>        let mut w2 = WidgetObj::new(2);<br/>        w1.parent = Some(&amp;mut w2);<br/>    }</span><span id="7900" class="kj kk hu kf b fv kp km l kn ko">    unsafe { println!("parent font_size: {}", (*w1.parent.unwrap()).font_size) };<br/>}</span><span id="0a9d" class="kj kk hu kf b fv kp km l kn ko">// <a class="ae jp" href="https://play.rust-lang.org/?gist=4878c275e299e53a8f24684966e15996&amp;version=nightly&amp;backtrace=0" rel="noopener ugc nofollow" target="_blank">playground</a></span></pre><p id="6220" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将产生以下输出:</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="ab53" class="kj kk hu kf b fv kl km l kn ko">widget font_size 2 dropped<br/>parent font_size: 2<br/>widget font_size 1 dropped</span></pre><p id="f8c6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这碰巧在自由错误之后没有使用，因为可能在删除之后存储器没有被设置为0，但是行为当然是未定义的。</p><p id="0200" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，要有一个正确工作的自引用计数对象，您需要将它分配到全局的某个位置。根本没有办法告诉编译器在变量超出范围时不要自动丢弃它。</p><p id="dee7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好吧，我说。随你便吧，拉斯特。做循环有向图的惯用方法是什么？</p><p id="8eb8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">选项三</strong></p><p id="93da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">经过一番搜索，我找到了一个很好的铁锈库，用来创建名为<a class="ae jp" href="https://github.com/SimonSapin/rust-forest/" rel="noopener ugc nofollow" target="_blank">铁锈森林</a>的树。它巧妙地创建了一种拥有节点、使用智能指针引用节点以及插入/移除节点的方法。然而，rust-forest中给出的实现不允许不同T类型的节点出现在同一个图中，这是nanogui等库的要求。</p><p id="6eb5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了说明见<a class="ae jp" href="https://play.rust-lang.org/?gist=18327500a1f25de57707f92ae75b96d3&amp;version=nightly&amp;backtrace=0" rel="noopener ugc nofollow" target="_blank">这个操场</a>。这里要完整地包括有点太长了，但问题在于这个函数:</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="1627" class="kj kk hu kf b fv kl km l kn ko">// Widget is a trait<br/>// focused_widgets is a Vec&lt;Rc&lt;RefCell&lt;Widget&gt;&gt;&gt;<br/>fn update_focus(&amp;self, w: &amp;Widget) {<br/>    self.focused_widgets.clear();<br/>    self.focused_widgets.push_child(w); // This will never work, we don't have the reference counted version of the widget here.<br/>}</span><span id="0587" class="kj kk hu kf b fv kp km l kn ko">// <a class="ae jp" href="https://play.rust-lang.org/?gist=18327500a1f25de57707f92ae75b96d3&amp;version=nightly&amp;backtrace=0" rel="noopener ugc nofollow" target="_blank">playground</a></span></pre><p id="48b9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">顺便说一句，以下是一个可以解决的奇怪问题，但是我不明白为什么这是一个问题:</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="6e1a" class="kj kk hu kf b fv kl km l kn ko">let refObj = Rc::new(RefCell::new(WidgetObj::new(1)));<br/>&amp;refObj as &amp;Rc&lt;RefCell&lt;Widget&gt;&gt;; // non-scalar cast</span><span id="519c" class="kj kk hu kf b fv kp km l kn ko">// <a class="ae jp" href="https://play.rust-lang.org/?gist=824a67d6161ef8144cff5e0d99ee704a&amp;version=nightly&amp;backtrace=0" rel="noopener ugc nofollow" target="_blank">playground</a></span></pre><p id="126f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">结论</strong></p><p id="f15e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我在选项1到3中遇到的问题让我相信，选项4，绑定到C，将是我试图编写的库的唯一可行的替代方案。现在我在这个阶段，我在想，当我可以用C写的时候，为什么要写C绑定呢？还是C++？</p><p id="290f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Rust作为一种编程语言有一些好的方面。我很喜欢Match的工作方式。我喜欢traits背后的想法，就像Go中的接口一样，我喜欢将cargo作为一种打包工具。但是当谈到特征、引用计数和不可能重写编译器行为的实现细节时，我只能说:不，这对我不起作用。</p><p id="514a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">真心希望大家继续使用和改进Rust。但是我想写游戏。不用与编译器较劲，也不用编写RFC来使语言更有利于我的目标。</p><p id="8f1c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果到目前为止你已经阅读了整篇文章并坚持下去，那么感谢你阅读我的长篇大论。如果没有，就没有TL；我是医生，抱歉。这里有太多的概念和解决方案，我无法进一步浓缩。</p><blockquote class="le lf lg"><p id="b662" class="ir is jz it b iu iv iw ix iy iz ja jb lh jd je jf li jh ji jj lj jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is jz it b iu iv iw ix iy iz ja jb lh jd je jf li jh ji jj lj jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is jz it b iu iv iw ix iy iz ja jb lh jd je jf li jh ji jj lj jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ka kb kc kd fq lk"><div class="bz el l di"><div class="ll lm l"/></div></figure></div></div>    
</body>
</html>