<html>
<head>
<title>Machine Learning for Android Developers with the Mobile Vision API— Part 1 — Face Detection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用移动视觉API的Android开发人员的机器学习—第1部分—人脸检测</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/machine-learning-for-android-developers-with-the-mobile-vision-api-part-1-face-detection-e7e24a3e472f?source=collection_archive---------0-----------------------#2016-10-11">https://medium.com/hackernoon/machine-learning-for-android-developers-with-the-mobile-vision-api-part-1-face-detection-e7e24a3e472f?source=collection_archive---------0-----------------------#2016-10-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="a07b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">机器学习是计算机科学中一个非常有趣的领域，很长一段时间以来一直排在我的学习清单的前列。有这么多来自RxJava、测试、<a class="ae jp" href="https://hackernoon.com/tagged/android" rel="noopener ugc nofollow" target="_blank"> Android </a> N、Android Studio和其他Android好东西的更新，我还没有时间去学习它。Udacity甚至还有一门关于机器学习的纳米学位课程。唷。</p><p id="7eb9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我非常兴奋地发现，现在任何人都可以在基于谷歌移动视觉API的Android应用中实现机器学习，而无需事先了解该领域的知识。你只需要知道如何使用API。</p><p id="c1c8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在云和移动设备上有很多用于机器学习的API，但在这个系列中，我将只关注移动视觉API，因为它们是专门为Android开发人员创建的。移动视觉API目前包括三种:人脸检测API、条形码检测API和文本API。我们将在本文中讨论人脸检测，其余两种将在后续文章中讨论。</p><h1 id="9e85" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">人脸检测API</h1><p id="52c6" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">该API用于检测和跟踪图像或视频中的人脸，但它还不提供人脸识别功能。它允许检测面部标志，并提供面部分类。地标是面部中的兴趣点，例如眼睛、鼻子和嘴。面部分类用于检查某些特征的标志，例如笑脸或闭眼，这是目前唯一支持的分类。API还检测不同角度的人脸，并报告<strong class="it hv">欧拉Y </strong>和<strong class="it hv">欧拉Z </strong>角度。</p><h1 id="af41" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">入门指南</h1><p id="fbb8" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们将创建一个名为<strong class="it hv"> printf("%s Story "，yourName) </strong>的应用程序，带有两个过滤器。请注意，这篇文章的目的只是展示API的使用，所以这段代码的初始版本不会有测试或遵循任何特定的架构。还要注意，所有的处理最好在UI线程之外完成。Github 上的<a class="ae jp" href="https://github.com/moyheen/face-detector" rel="noopener ugc nofollow" target="_blank">代码将会更新以反映这一点。</a></p><p id="63f1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">开始了…</p><ul class=""><li id="f254" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">在Android Studio中创建新项目。</li><li id="4324" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">将用于移动视觉API的Google Play Services SDK导入到您的应用程序级build.gradle文件中。在撰写本文时，最新版本是9.6.1。这里要特别小心，因为如果您导入整个SDK而不是您需要的特定SDK(play-services-vision ),您肯定会达到65k的方法限制。</li></ul><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="88d5" class="lq jr hu lm b fv lr ls l lt lu">compile 'com.google.android.gms:play-services-vision:9.6.1'</span></pre><ul class=""><li id="a48e" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">要使可用库能够用于人脸检测，请将此元数据添加到您的清单文件中。</li></ul><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="e6c8" class="lq jr hu lm b fv lr ls l lt lu">&lt;meta-data<br/>    android:name="com.google.android.gms.vision.DEPENDENCIES"<br/>    android:value="face"/&gt;</span></pre><ul class=""><li id="c50d" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">接下来，你需要添加一个<em class="lv"> ImageView </em>和一个<em class="lv">按钮</em>到你的布局中。该按钮通过选择图像、处理图像并将其显示在<em class="lv">图像视图</em>中来启动图像处理。图像可以通过相机或图库从设备中加载。为了节省时间，我只是把一张图片保存到我的drawable文件夹中并使用它。</li><li id="71de" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">在按钮的点击动作中，创建一个新的<em class="lv"> BitmapFactory。Options </em>对象并将<em class="lv"> inmutable </em>设置为true。这是为了确保位图是可变的，以便我们能够以编程方式对其应用效果。</li></ul><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="b37b" class="lq jr hu lm b fv lr ls l lt lu">BitmapFactory.Options bitmapOptions = new BitmapFactory.Options();<br/>bitmapOptions.inMutable = true;</span></pre><ul class=""><li id="5ebe" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">接下来，使用BitmapFactory类中的<em class="lv"> decodeResource </em>方法创建一个新的位图。您将使用drawable文件夹中的图像和上一步中创建的<em class="lv"> BitmapOptions </em>对象作为该方法的参数。</li></ul><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="9c16" class="lq jr hu lm b fv lr ls l lt lu">Bitmap defaultBitmap = BitmapFactory.<em class="lv">decodeResource</em>(getResources(), R.drawable.<em class="lv">image</em>, bitmapOptions);</span></pre><ul class=""><li id="dd6c" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">创建一个<em class="lv">绘制</em>对象，并将样式设置为笔画。这确保了形状不会被填充，因为我们希望看到头部的哪些部分形成了矩形。</li></ul><p id="a720" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="lv">注意</em>:如果你在做一个叫<strong class="it hv"> <em class="lv">的游戏！(认出我)</em> </strong>当你需要遮挡图像中的人脸，让你的玩家猜测是谁时，你可能会想要设置填充样式，就像这样<em class="lv">绘画。样式填充</em>。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="dd93" class="lq jr hu lm b fv lr ls l lt lu">Paint rectPaint = new Paint();<br/>rectPaint.setStrokeWidth(5);<br/>rectPaint.setColor(Color.<em class="lv">CYAN</em>);<br/>rectPaint.setStyle(Paint.Style.<em class="lv">STROKE</em>);</span></pre><ul class=""><li id="5ee0" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">我们需要一个画布来显示我们的位图。我们将首先用临时位图创建画布。这个临时位图将与原始位图具有相同的尺寸，但这是相似之处的终点。我们稍后将在同一画布上绘制原始位图。</li></ul><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="43d2" class="lq jr hu lm b fv lr ls l lt lu">Bitmap temporaryBitmap = Bitmap.<em class="lv">createBitmap</em>(defaultBitmap.getWidth(), defaultBitmap<br/>        .getHeight(), Bitmap.Config.<em class="lv">RGB_565</em>);<br/><br/>Canvas canvas = new Canvas(temporaryBitmap);<br/>canvas.drawBitmap(defaultBitmap, 0, 0, null);</span></pre><ul class=""><li id="5972" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">最后，我们到达使用<em class="lv"> FaceDectector </em> API的地方。跟踪被禁用，因为我们使用的是静态图像。应该为视频启用它。</li></ul><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="0390" class="lq jr hu lm b fv lr ls l lt lu">FaceDetector faceDetector = new FaceDetector.Builder(this)<br/>        .setTrackingEnabled(false)<br/>        .setLandmarkType(FaceDetector.<em class="lv">ALL_LANDMARKS</em>)<br/>        .build();</span></pre><ul class=""><li id="43d4" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">检查面部检测器是否已经运行。有可能第一次不会成功，因为需要将一个库下载到设备上，当您需要使用它时，它可能没有及时完成。</li></ul><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="71da" class="lq jr hu lm b fv lr ls l lt lu">if (!faceDetector.isOperational()) {<br/>            new AlertDialog.Builder(this)<br/>            .setMessage("Face Detector could not be set up on your device :(")<br/>            .show();<br/><br/>    return;<br/>}</span></pre><ul class=""><li id="9666" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">接下来，我们使用默认位图创建一个帧，并调用人脸检测器来获取人脸对象。</li></ul><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="76d2" class="lq jr hu lm b fv lr ls l lt lu">Frame frame = new Frame.Builder().setBitmap(defaultBitmap).build();<br/>SparseArray&lt;Face&gt; sparseArray = <strong class="lm hv">faceDetector.detect(frame)</strong>;</span></pre><ul class=""><li id="a8f6" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">在这一步中，矩形绘制在面上。我们只能从每个面得到左边和上边的位置，但是我们还需要右边和下边的尺寸来画矩形。为了解决这个问题，我们将宽度和高度分别添加到左侧和顶部位置。</li></ul><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="9af0" class="lq jr hu lm b fv lr ls l lt lu">for (int i = 0; i &lt; sparseArray.size(); i++) {<br/>    Face face = sparseArray.valueAt(i);<br/><br/>    float left = face.getPosition().x;<br/>    float top = face.getPosition().y;<br/>   <strong class="lm hv"> float right = left + face.getWidth();<br/>    float bottom = top + face.getHeight();</strong><br/>    float cornerRadius = 2.0f;<br/><br/>    RectF rectF = new RectF(left, top, right, bottom);<br/><br/>    canvas.drawRoundRect(rectF, cornerRadius, cornerRadius, rectPaint);<br/>}</span></pre><ul class=""><li id="f0a0" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">然后，我们用临时位图创建一个新的<em class="lv"> BitmapDrawable </em>，并在我们布局的ImageView上设置它，之后我们释放人脸检测器。</li></ul><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="dc3f" class="lq jr hu lm b fv lr ls l lt lu">imageView.setImageDrawable(new BitmapDrawable(getResources(), temporaryBitmap));<br/><br/>faceDetector.release();</span></pre><p id="52f3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些步骤刚好够在每个面上画出矩形。如果你想突出每个面上的地标，你需要做的就是修改最后两步的循环。现在，您将遍历每个面的界标，获得界标的x和y位置，并在每个面上画一个圆，如下所示。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="3fa9" class="lq jr hu lm b fv lr ls l lt lu">for (int i = 0; i &lt; sparseArray.size(); i++) {<br/>    Face face = sparseArray.valueAt(i);<br/><br/>    float left = face.getPosition().x;<br/>    float top = face.getPosition().y;<br/>    float right = left + face.getWidth();<br/>    float bottom = top + face.getHeight();<br/>    float cornerRadius = 2.0f;<br/><br/>    RectF rectF = new RectF(left, top, right, bottom);<br/>    canvas.drawRoundRect(rectF, cornerRadius, cornerRadius, rectPaint);<br/><br/>   <strong class="lm hv"> for (Landmark landmark : face.getLandmarks()) {<br/>        int x = (int) (landmark.getPosition().x);<br/>        int y = (int) (landmark.getPosition().y);<br/>        float radius = 10.0f;</strong></span><span id="4655" class="lq jr hu lm b fv lw ls l lt lu"><strong class="lm hv">        canvas.drawCircle(x, y, radius, rectPaint);<br/>    }</strong><br/>}</span></pre><figure class="lh li lj lk fq lx"><div class="bz el l di"><div class="ly lz l"/></div><figcaption class="ma mb fg fe ff mc md bd b be z ek">Picture with facial landmarks highlighted</figcaption></figure><p id="f863" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我很好奇地标是如何表示的，所以我使用了<em class="lv">landmark . gettype()；</em>找出答案。原来每个地标都有特定的数字。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="51c9" class="lq jr hu lm b fv lr ls l lt lu">for (Landmark landmark : face.getLandmarks()) {<br/><br/>    int cx = (int) (landmark.getPosition().x);<br/>    int cy = (int) (landmark.getPosition().y);<br/><br/>    // canvas.drawCircle(cx, cy, 10, rectPaint);<br/><br/>    <strong class="lm hv">String type = String.<em class="lv">valueOf</em>(landmark.getType());<br/>    rectPaint.setTextSize(50);    <br/>    canvas.drawText(type, cx, cy, rectPaint);</strong><br/>}</span></pre><figure class="lh li lj lk fq lx fe ff paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="fe ff me"><img src="../Images/ae8880b1725032fe18140701317eb3f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mu_uTct0zPLyq-63Yl_rsQ.png"/></div></div></figure><p id="0c61" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们想要相对于特定的面部标志在屏幕上定位对象时，这种知识是有用的。如果我们要构建我们的<strong class="it hv"> printf("%s Story "，yourName) </strong> app <strong class="it hv">，</strong>我们所要做的就是相对于一个地标的位置定位一个图像，因为我们现在知道它被表示为什么数字。下面让我们继续做吧…</p><p id="fd9c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设我们是海上的海盗，我们想通过一个非常酷的<strong class="it hv"> printf("%s Story "，yourName) </strong>应用过滤器来描绘这个场景，我们需要在左眼上戴一个眼罩。眼罩位图的位置是相对于左眼绘制的。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="40af" class="lq jr hu lm b fv lr ls l lt lu">for (Landmark landmark : face.getLandmarks()) {<br/><br/>    int cx = (int) (landmark.getPosition().x);<br/>    int cy = (int) (landmark.getPosition().y);<br/><br/>    // canvas.drawCircle(cx, cy, 10, rectPaint);<br/><br/>    // String type = String.valueOf(landmark.getType());<br/>    // rectPaint.setTextSize(50);<br/>    // canvas.drawText(type, cx, cy, rectPaint);</span><span id="38e7" class="lq jr hu lm b fv lw ls l lt lu">    <strong class="lm hv">// the left eye is represented by 4 </strong><br/>    <strong class="lm hv">if (landmark.getType() == 4) {<br/>        canvas.drawBitmap(eyePatchBitmap, cx - 270, cy - 250, null);<br/>    }</strong><br/>}</span></pre><figure class="lh li lj lk fq lx"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="acc9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是来自<strong class="it hv"> printf("%s Story "，yourName) </strong>应用程序的更多内容…</p><figure class="lh li lj lk fq lx"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="1d2d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个API还有很多内容要介绍。我们可以更新应用程序来跟踪视频中的人脸，并允许过滤器随着头部移动。本文的代码是Github上的<a class="ae jp" href="https://github.com/moyheen/face-detector" rel="noopener ugc nofollow" target="_blank">这里是</a>。在这里阅读本系列的第二篇文章。</p><p id="dc06" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">参考资料:</p><div class="ml mm fm fo mn mo"><a href="https://developers.google.com/vision/detect-faces-tutorial" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab ej"><div class="mq ab mr cl cj ms"><h2 class="bd hv fv z el mt eo ep mu er et ht dt translated">检测照片中的面部特征|移动视觉|谷歌开发者</h2><div class="mv l"><h3 class="bd b fv z el mt eo ep mu er et ek translated">第一次在设备上安装使用Face API的应用程序时，GMS会将原生库下载到…</h3></div><div class="mw l"><p class="bd b gc z el mt eo ep mu er et ek translated">developers.google.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc mj mo"/></div></div></a></div><div class="ml mm fm fo mn mo"><a href="https://codelabs.developers.google.com/codelabs/face-detection/index.html" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab ej"><div class="mq ab mr cl cj ms"><h2 class="bd hv fv z el mt eo ep mu er et ht dt translated">使用移动视觉API进行人脸检测</h2><div class="mv l"><h3 class="bd b fv z el mt eo ep mu er et ek translated">随着Google Play服务7.8的发布，您现在可以使用新的移动视觉API，它提供了新的人脸检测功能…</h3></div><div class="mw l"><p class="bd b gc z el mt eo ep mu er et ek translated">codelabs.developers.google.com</p></div></div><div class="mx l"><div class="nd l mz na nb mx nc mj mo"/></div></div></a></div><div class="ml mm fm fo mn mo"><a href="https://github.com/moyheen/face-detector" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab ej"><div class="mq ab mr cl cj ms"><h2 class="bd hv fv z el mt eo ep mu er et ht dt translated">莫伊亨/面部检测器</h2><div class="mv l"><h3 class="bd b fv z el mt eo ep mu er et ek translated">在GitHub上创建一个帐户，为人脸检测器的开发做出贡献。</h3></div><div class="mw l"><p class="bd b gc z el mt eo ep mu er et ek translated">github.com</p></div></div><div class="mx l"><div class="ne l mz na nb mx nc mj mo"/></div></div></a></div><p id="5ce4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="lv">以为这就了不起了？请不要忘记“推荐”和“分享”。</em> </strong></p><div class="lh li lj lk fq ab cb"><figure class="nf lx ng nh ni nj nk paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nf lx ng nh ni nj nk paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nf lx ng nh ni nj nk paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="nl nm nn"><p id="f922" class="ir is lv it b iu iv iw ix iy iz ja jb no jd je jf np jh ji jj nq jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是T21家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is lv it b iu iv iw ix iy iz ja jb no jd je jf np jh ji jj nq jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lh li lj lk fq lx fe ff paragraph-image"><a href="https://goo.gl/Ahtev1"><div class="fe ff nr"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></a></figure><figure class="lh li lj lk fq lx"><div class="bz el l di"><div class="ns lz l"/></div></figure></div></div>    
</body>
</html>