<html>
<head>
<title>A Project in Haskell: One Week Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Haskell的一个项目:一周应用</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-project-in-haskell-one-week-apps-6ccb87e6ce10?source=collection_archive---------16-----------------------#2017-04-24">https://medium.com/hackernoon/a-project-in-haskell-one-week-apps-6ccb87e6ce10?source=collection_archive---------16-----------------------#2017-04-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="0b65" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最近我们关注了如何学习Haskell的一些细节。但是在某一点上，我们真的想要建造东西。下一系列文章将关注Haskell的一些更实际的方面。本周，我将介绍我自己的一个Haskell项目。我们将首先考察我选择Haskell的一些原因。然后我们将看看我是如何组织这个项目的，以及这些选择的利弊。</p><h1 id="7b83" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">一周应用简介</h1><p id="fc79" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">我创建的程序叫做一周应用程序(名字从来不是我的强项…我愿意接受更好的想法)。它旨在帮助你<strong class="it hv">快速创建移动原型</strong>。它允许你用一种简单的领域特定语言来指定应用程序的重要元素。截至本文撰写之时，支持的应用程序功能有:</p><ol class=""><li id="fbee" class="ks kt hu it b iu iv iy iz jc ku jg kv jk kw jo kx ky kz la dt translated">颜色；色彩；色调</li><li id="032b" class="ks kt hu it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la dt translated">字体</li><li id="be40" class="ks kt hu it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la dt translated">警告弹出窗口</li><li id="cfb7" class="ks kt hu it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la dt translated">程序员错误(想想NSError)</li><li id="86a5" class="ks kt hu it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la dt translated">本地化字符串</li><li id="565b" class="ks kt hu it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la dt translated">查看布局</li><li id="419d" class="ks kt hu it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la dt translated">简单的模型对象。</li></ol><p id="4220" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，假设您想从头开始创建一个应用程序，并添加一个简单的登录屏幕。您将从使用<code class="eh lg lh li lj b">owa new</code>命令生成XCode项目本身开始。首先，您将通过命令行提示符输入一些关于应用程序的信息。然后，它将生成项目以及一些目录，供您放置代码。</p><pre class="lk ll lm ln fq lo lj lp lq aw lr dt"><span id="4608" class="ls jq hu lj b fv lt lu l lv lw">&gt;&gt; owa new<br/>Creating new OWA project!<br/>What is the name of your app:<br/>&gt;&gt; Blog Example<br/>What is the prefix of your app (3 letters):<br/>&gt;&gt; BEX<br/>What is the author's name:<br/>&gt;&gt; James<br/>What is your company name (optional):<br/>&gt;&gt; Monday Morning Haskell<br/>Your new app "Blog Example" has been created!</span></pre><p id="39ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，我们开始指定应用程序的不同元素。为了表示颜色，我们将把下面的代码放在生成的<code class="eh lg lh li lj b">app</code>目录下的一个<code class="eh lg lh li lj b">.colors</code>文件中。</p><pre class="lk ll lm ln fq lo lj lp lq aw lr dt"><span id="443d" class="ls jq hu lj b fv lt lu l lv lw">Color labelColor<br/>  Hex 0x000000</span><span id="1f85" class="ls jq hu lj b fv lx lu l lv lw">Color fieldColor<br/>  Hex 0xAAAAAA</span><span id="fe91" class="ls jq hu lj b fv lx lu l lv lw">Color buttonColor<br/>  Blue 255<br/>  Red 0<br/>  Green 0</span></pre><p id="638d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还可以为屏幕上的元素指定一些不同的字体:</p><pre class="lk ll lm ln fq lo lj lp lq aw lr dt"><span id="1899" class="ls jq hu lj b fv lt lu l lv lw">Font labelFont<br/>  FontFamily HelveticaNeue<br/>  Size 12.0<br/>  Styles Light</span><span id="5121" class="ls jq hu lj b fv lx lu l lv lw">Font fieldFont<br/>  FontFamily Helvetica<br/>  Size 16</span><span id="ecef" class="ls jq hu lj b fv lx lu l lv lw">Font buttonFont<br/>  FontFamily Arial<br/>  Size 24<br/>  Styles Bold</span></pre><p id="b2ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们将为字符串添加一些本地化内容:</p><pre class="lk ll lm ln fq lo lj lp lq aw lr dt"><span id="c910" class="ls jq hu lj b fv lt lu l lv lw">NAME_TITLE = “Name”<br/>“NAME_PLACEHOLDER” = “Enter Your Name”<br/>PASSWORD_TITLE = “Password”<br/>“PASSWORD_PLACEHOLDER” = “Enter Your Password”<br/>SUBMIT_BUTTON_TITLE = “Log In!”</span></pre><p id="112e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我们将指定视图布局本身。我们可以使用上面写的颜色和字体。我们还可以修改不同元素的布局。</p><pre class="lk ll lm ln fq lo lj lp lq aw lr dt"><span id="8a0b" class="ls jq hu lj b fv lt lu l lv lw">View loginView<br/>  Type BEXLoginView<br/>  Elements<br/>    Label nameLabel<br/>      Text “NAME_TITLE”<br/>      TextColor labelColor<br/>      Font labelFont<br/>      Layout<br/>        AlignTop 40<br/>        AlignLeft 40<br/>        Height 30<br/>        Width 100<br/>    TextField nameField<br/>      PlaceholderText “NAME_PLACEHOLDER”<br/>      PlaceholderTextColor fieldColor<br/>      PlaceholderFont fieldFont<br/>      Layout<br/>        Below nameLabel 20<br/>        AlignLeft nameLabel<br/>        Height 30<br/>        Width 300<br/>    Label passwordLabel<br/>      Text “PASSWORD_TITLE”<br/>      TextColor labelColor<br/>      Font labelFont<br/>      Layout<br/>        Below nameField 40<br/>        AlignLeft nameLabel<br/>        Height 30<br/>        Width 100<br/>    TextField passwordField<br/>      PlaceholderText “PASSWORD_PLACEHOLDER”<br/>      PlaceholderTextColor fieldColor<br/>      PlaceholderFont fieldFont<br/>      Layout<br/>        Below passwordLabel 40<br/>        AlignLeft nameLabel<br/>        Height 30<br/>        Width 300<br/>    Button submitButton<br/>      Text “SUBMIT_BUTTON_TITLE”<br/>      TextColor buttonColor<br/>      Font buttonFont<br/>      Layout<br/>        Below passwordField 40<br/>        CenterX<br/>        Height 45<br/>        Width 200</span></pre><p id="feae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我们将运行<code class="eh lg lh li lj b">owa gen</code>命令来生成文件。我们需要手动将它们添加到您的XCode项目中(目前)，但它们至少应该出现在正确的文件夹中。最后，我们将在视图控制器中添加几行简单的连接代码:</p><pre class="lk ll lm ln fq lo lj lp lq aw lr dt"><span id="da42" class="ls jq hu lj b fv lt lu l lv lw">class ViewController: UIViewController {</span><span id="38d5" class="ls jq hu lj b fv lx lu l lv lw">  override func loadView() {<br/>    view = BEXLoginView()<br/>  }<br/>...</span></pre><p id="b571" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以看看我们的基本观点:</p><figure class="lk ll lm ln fq lz fe ff paragraph-image"><div class="fe ff ly"><img src="../Images/08b22e16c5d9825440877e584d560b1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*-puRueq3nIAzVEbIyJhyVA.png"/></div></figure><h1 id="aedd" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">Haskell的基本原理</h1><p id="48f2" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">当我第一次提出这个项目的想法时，我知道Haskell是一个不错的选择。我们应该注意的一个主要特征是程序的<strong class="it hv">简单结构。它有<strong class="it hv">有限的IO边界</strong>。我们在开始时读入一堆文件，然后在最后写入一堆文件。在这两者之间，我们有的只是复杂的业务逻辑。我们解析文件内容，并将它们转换成代数数据结构。然后我们根据所选择的语言对它们执行更多的转换(你现在可以使用Objective C或者Swift)。</strong></p><p id="46d9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">几乎没有全局状态可以跟踪(至少现在没有“编译”发生)。没有任何数据库连接。许多让Haskell难以处理的东西(IO内容和全局状态)并没有出现在程序的主体中。</p><p id="066b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">相反，身体由计算组成，这符合哈斯克尔的长处。这些包括字符串处理、抽象地表示数据等等。这些是为这个项目选择Haskell的主要标准。当然，有一些库可以处理我前面提到的所有“笨拙”的问题。但是我们甚至不需要为这个项目学习那些。</p><h1 id="e6e8" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">体系结构</h1><p id="0416" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">现在我将给出一个我如何设计这个程序的基本概述。我决定采用多包方法。我们可以在我的<code class="eh lg lh li lj b">stack.yaml</code>文件中看到不同的包:</p><pre class="lk ll lm ln fq lo lj lp lq aw lr dt"><span id="e9b6" class="ls jq hu lj b fv lt lu l lv lw">packages:<br/>  - './owa-core'<br/>  - './owa-model'<br/>  - './owa-utils'<br/>  - './owa-parse'<br/>  - './owa-objc'<br/>  - './owa-swift'</span></pre><ol class=""><li id="b505" class="ks kt hu it b iu iv iy iz jc ku jg kv jk kw jo kx ky kz la dt translated"><code class="eh lg lh li lj b">model</code>部分包含移动应用程序对象的数据类型。其他软件包依赖于此。</li><li id="cc07" class="ks kt hu it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la dt translated"><code class="eh lg lh li lj b">parse</code>包包含所有与解析文件相关的代码和测试。</li><li id="daa2" class="ks kt hu it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la dt translated"><code class="eh lg lh li lj b">objc</code>包包含了创建目标C文件并打印出来的所有代码。它也有这些功能的测试。</li><li id="e6fa" class="ks kt hu it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la dt translated"><code class="eh lg lh li lj b">swift</code>包对Swift代码做同样的事情。</li><li id="0b61" class="ks kt hu it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la dt translated"><code class="eh lg lh li lj b">core</code>包处理诸如CLI、解释命令、搜索文件等功能。</li><li id="1185" class="ks kt hu it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la dt translated"><code class="eh lg lh li lj b">utils</code>包包含多个包需要的某些额外代码。</li></ol><h1 id="d514" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">赞成和反对</h1><p id="0e6d" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">让我们来看看这种架构的一些优点和缺点。作为替代，我们可以使用单包装结构。所选方法的一个优点是开发周期内的编译时间<strong class="it hv">更短。总编译时间是有代价的。拥有许多包会导致库之间更多的链接，这需要一些时间。然而，一旦你编译了这个项目一次，每次后续的重新编译将花费更少的时间。在大多数情况下，你只需要重新编译你正在处理的模块。这导致了更快的开发周期。在这种情况下，开发周期比总的编译时间更重要。如果程序需要在部署机器上有规律地从头开始编译，我们可能会做出不同的选择。</strong></p><p id="0c83" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">代码的<strong class="it hv">组织是另一个重要因素。现在，您想在哪里添加解析代码已经很明显了。如果一个特性看起来有问题，你知道去哪里找到一个失败的测试或者添加一个新的测试来重现这个错误。这个系统比我之前遇到的随意的基于版本的测试组织要好得多。</strong></p><p id="5d2c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我想列举的另一个优点是现在<strong class="it hv">添加另一种语言</strong>来支持是一个更干净的过程。为了支持一种新的语言，对核心模块的改动很少。您将添加另一个包(比如说<code class="eh lg lh li lj b">owa-android</code>)并向Core添加更多选项。这将使它成为一个简单的存储库，比如说，对于任何想开发android版本的人来说。</p><p id="6f72" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们也考虑一些缺点。这些封装中的许多封装不太可能<strong class="it hv">彼此完全隔离</strong>使用。例如，<code class="eh lg lh li lj b">owa-parse</code>模块牢牢依赖于<code class="eh lg lh li lj b">owa-model</code>包。特定于语言的模块不会相互交互。但是它们也不是特别有用，除非你正在使用解析器。</p><p id="9ba6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，<code class="eh lg lh li lj b">utils</code>模块是一个真正的眼中钉。它有几个随机的实用程序，用于几个包的测试代码和打印代码。它似乎建议应该只有一个包用于测试，但我发现这并不令人满意。相反，它建议应该有共同的印刷代码。简单地让这些代码在某些地方重复可能是一个合理的解决方案。这是另一种代码气味。但是如果不同的语言分别进化，那么它们的实用程序代码也可能。</p><h1 id="9fde" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">摘要</h1><p id="3ed1" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">那么我们从这个项目中学到了什么呢？Haskell非常擅长内部处理。但是具有宽IO边界的程序会引起一些麻烦。幸运的是，One Week Apps有很多内部处理，但是IO限制有限。所以哈斯克尔是自然的选择。同时，多包组织在代码组织方面有一些优势。但是，就放置公共代码而言，这也会导致一些令人头疼的问题。</p><p id="30a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae mc" href="https://github.com/jhb563/OneWeekApps" rel="noopener ugc nofollow" target="_blank"> One Week Apps </a>现已开源，请随时登陆<a class="ae mc" href="https://github.com/jhb563/OneWeekApps" rel="noopener ugc nofollow" target="_blank"> Github </a>查看！你喜欢这个想法吗？你认为它会大大提高你写应用程序的速度吗？您应该联系我并查看我们的<a class="ae mc" href="https://github.com/jhb563/OneWeekApps/issues" rel="noopener ugc nofollow" target="_blank">问题</a>页面！</p><p id="3dd2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">想投稿但没接触过Haskell？您很幸运，因为我们有一些很好的资源可供您开始使用！首先，您应该查看我们的<a class="ae mc" href="https://www.mmhaskell.com/checklist" rel="noopener ugc nofollow" target="_blank">入门清单</a>。它将引导您完成安装Haskell的一些基本步骤。它还会向您展示一些极好的资源，帮助您开始编写Haskell代码。</p><p id="efb3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你有一点经验，但想要更多的实践，你应该下载我们的<a class="ae mc" href="https://www.mmhaskell.com/workbook" rel="noopener ugc nofollow" target="_blank">递归工作簿</a>。它会教你递归，一个基本的函数范式。它也有一些练习问题让你学习！</p><div class="lk ll lm ln fq ab cb"><figure class="md lz me mf mg mh mi paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="md lz me mf mg mh mi paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="md lz me mf mg mh mi paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mj mk ml"><p id="f922" class="ir is mm it b iu iv iw ix iy iz ja jb mn jd je jf mo jh ji jj mp jl jm jn jo hn dt translated"><a class="ae mc" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae mc" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae mc" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae mc" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is mm it b iu iv iw ix iy iz ja jb mn jd je jf mo jh ji jj mp jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae mc" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae mc" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lk ll lm ln fq lz fe ff paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="fe ff mq"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>