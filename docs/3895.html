<html>
<head>
<title>React Native Effective Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应本地有效模式</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/react-native-effective-patterns-3e0c9db6c32c?source=collection_archive---------1-----------------------#2017-04-30">https://medium.com/hackernoon/react-native-effective-patterns-3e0c9db6c32c?source=collection_archive---------1-----------------------#2017-04-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="97ec" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">7个简单的模式来提高你的反应能力</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/4d9ce4ae3e8f85d23180e660cbf76bdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XxHPh5AP4YaorDlVKnE-_w.png"/></div></div></figure><p id="aee6" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt kr translated">我已经和React Native一起工作了一段时间，无论是从个人角度还是从职业角度，我都非常喜欢它；在这篇文章中，我将描述我使用的一些模式。请记住，对一个团队起作用的东西，不一定对另一个团队起作用，并且这些例子中的许多本身不会起作用(它们是代码中孤立的部分)。</p><h2 id="6736" class="la lb hu bd lc ld le lf lg lh li lj lk ke ll lm ln ki lo lp lq km lr ls lt lu dt translated">1.让你的大部分组件保持愚蠢</h2><p id="a6e0" class="pw-post-body-paragraph jv jw hu jx b jy lv iv ka kb lw iy kd ke lx kg kh ki ly kk kl km lz ko kp kq hn dt translated">对于任何React应用程序都是如此。你的<strong class="jx hv">视图</strong>和组件<strong class="jx hv">应该依靠道具和回调</strong>而<strong class="jx hv">容器</strong>(智能)组件<strong class="jx hv">应该依靠状态</strong>。我推荐使用Redux，但是在一些应用程序中，您可以使用普通的旧setState。MobX也是一个很好的选择。</p><h2 id="798f" class="la lb hu bd lc ld le lf lg lh li lj lk ke ll lm ln ki lo lp lq km lr ls lt lu dt translated">2.依靠回调</h2><p id="b2e5" class="pw-post-body-paragraph jv jw hu jx b jy lv iv ka kb lw iy kd ke lx kg kh ki ly kk kl km lz ko kp kq hn dt translated">在学习如何在Swift中编写iOS应用程序时，我被教导使用委托模式将视图与其行为分离。在React Native中，同样的效果可以通过回调来实现。回调只是可以传递给组件的箭头函数。组件有责任执行它们，但不需要知道它实际在做什么。</p><p id="6f5a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">大多数组件不应该有任何行为。暴露简单的<strong class="jx hv">回调</strong>，它们<strong class="jx hv">就像你的组件</strong>的公共API。你应该通过读他们的名字来知道他们什么时候被处决。例如，如果你正在开发一个电子商务应用程序，像<strong class="jx hv"><em class="ma">onSelectProduct</em></strong><em class="ma">或</em><strong class="jx hv"><em class="ma">onProductAddedToShoppingCart</em></strong>这样的名字就非常具有说明性。</p><p id="a718" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">当决定是否公开回调时，每当组件有某种用户交互时，问自己这样一个问题:<br/>这个交互只对这个特定的组件重要吗，或者它能触发应用程序另一部分的变化吗？如果你的答案是后者，那么你应该公开一个回调。</p><h2 id="7200" class="la lb hu bd lc ld le lf lg lh li lj lk ke ll lm ln ki lo lp lq km lr ls lt lu dt translated">3.让你的导航栈远离你的视图</h2><p id="83bc" class="pw-post-body-paragraph jv jw hu jx b jy lv iv ka kb lw iy kd ke lx kg kh ki ly kk kl km lz ko kp kq hn dt translated">对于这个特定的应用程序，我们能够从React Native的默认<a class="ae mb" href="https://facebook.github.io/react-native/docs/navigation.html#navigator" rel="noopener ugc nofollow" target="_blank">导航器</a>，迁移到<a class="ae mb" href="https://facebook.github.io/react-native/docs/navigation.html#navigationexperimental" rel="noopener ugc nofollow" target="_blank">导航实验</a>，再迁移到<a class="ae mb" href="https://github.com/react-community/react-navigation" rel="noopener ugc nofollow" target="_blank"> React导航</a>。这些变化只涉及几行代码。这个想法很简单:</p><p id="51b5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">屏幕和视图不一样。你的<strong class="jx hv">视图不应该有任何关于导航栈</strong>的知识，而<strong class="jx hv">屏幕</strong>(或者路线，取决于你喜欢什么名字)<strong class="jx hv">必须知道如何导航</strong>以及如何与导航栏/ TabBar通信。使用这种方法，您的屏幕将简单地用导航感知的东西包装实际的视图。例如:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mc md l"/></div></figure><p id="bbe2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如您所见，FavoritesView只是公开了一个“onSelectFavorite”回调，并不关心它实际做了什么。FavoritesScreen使用该回调来告诉导航器导航到另一个屏幕。因此，这为您提供了替换导航栈工作方式的灵活性，并提供了良好的分离。</p><h2 id="1998" class="la lb hu bd lc ld le lf lg lh li lj lk ke ll lm ln ki lo lp lq km lr ls lt lu dt translated">4.保持你的回调链接在一起</h2><p id="2fd1" class="pw-post-body-paragraph jv jw hu jx b jy lv iv ka kb lw iy kd ke lx kg kh ki ly kk kl km lz ko kp kq hn dt translated">一个非常常见的模式是将行为注入到高阶组件内的回调中(Redux的mapStateToProps实际上就是这么做的)，但许多人忘记了公共回调可能会在应用程序的另一部分中使用(例如，外部组件)。</p><p id="6562" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">每当您的一个视图公开一个可能在应用程序的另一部分使用的回调时(例如mapStateToProps)，首先调用在Props上传递的实际回调。例如，这使您能够导航到一个屏幕，并获取一些信息以提供给下一个视图。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mc md l"/></div></figure><p id="e989" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">按照前面的例子，如果FavoritesScreen告诉FavoritesView在选择一个收藏夹时导航到FavoriteScreen，Redux会遵守这个命令，但也会调用一些Redux操作。</p><p id="9268" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">正如你可能看到的，每个领域都知道如何处理它的东西:屏幕知道如何导航，连接的视图知道如何处理redux动作，视图是哑的，无状态的，依赖于它们的道具。</p><h2 id="3349" class="la lb hu bd lc ld le lf lg lh li lj lk ke ll lm ln ki lo lp lq km lr ls lt lu dt translated">5.保持你的归约器简单明了</h2><p id="733c" class="pw-post-body-paragraph jv jw hu jx b jy lv iv ka kb lw iy kd ke lx kg kh ki ly kk kl km lz ko kp kq hn dt translated">任何开发人员都应该能够查看您的缩减器的代码，并理解它在做什么。在大多数情况下，每个动作类型有一个函数可以增加可读性。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mc md l"/></div></figure><p id="6e87" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">用许多单行函数组成reducer函数可以给你更大的灵活性和代码重用。</p><h2 id="3054" class="la lb hu bd lc ld le lf lg lh li lj lk ke ll lm ln ki lo lp lq km lr ls lt lu dt translated">6.保持商业逻辑远离你的减速器</h2><p id="dc8e" class="pw-post-body-paragraph jv jw hu jx b jy lv iv ka kb lw iy kd ke lx kg kh ki ly kk kl km lz ko kp kq hn dt translated"><strong class="jx hv">你的Redux商店</strong>不是你商业模式的一部分，<strong class="jx hv">它是一个视图模式</strong>。像这样对待它。你的减压器应该只影响商店的变化，你需要对它们有高度的信心。你的下属对你的商业规则了解得越少，他们就会变得越简单。</p><p id="07ac" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这不是最好的方法，但是更好的方法是将业务逻辑放在动作创建器中，特别是当您使用像Thunk这样的中间件时。传奇和史诗也很棒。</p><h2 id="1e82" class="la lb hu bd lc ld le lf lg lh li lj lk ke ll lm ln ki lo lp lq km lr ls lt lu dt translated">7.尽量减少特定于平台的组件</h2><p id="7b0e" class="pw-post-body-paragraph jv jw hu jx b jy lv iv ka kb lw iy kd ke lx kg kh ki ly kk kl km lz ko kp kq hn dt translated">不要误解我的意思，每个平台都有自己的设计/UX语言，在许多情况下，你必须编写组件的不同版本。记住React Native的座右铭是<strong class="jx hv"> <em class="ma">学一次，写任何地方</em> </strong>，但是首先尽量不要急着写平台特定的组件。</p><p id="2426" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在许多情况下，简单的样式改变和条件操作符就足够了。我创建了一个简单的助手函数，叫做platformSpecific，它允许我根据平台设置样式。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mc md l"/></div></figure><p id="94d1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这是一个非常简单的函数，但是非常有用。后来有人提到，React原生舰有一个<a class="ae mb" href="https://facebook.github.io/react-native/docs/platform-specific-code.html#platform-module" rel="noopener ugc nofollow" target="_blank"> <strong class="jx hv">平台，选择</strong> </a>功能也是如此。</p><h2 id="ec87" class="la lb hu bd lc ld le lf lg lh li lj lk ke ll lm ln ki lo lp lq km lr ls lt lu dt translated">结论</h2><p id="071b" class="pw-post-body-paragraph jv jw hu jx b jy lv iv ka kb lw iy kd ke lx kg kh ki ly kk kl km lz ko kp kq hn dt translated">用不用这些模式都没关系。我想说的最重要的一点是:保持事物的简单和分离。这将提高生产率，并允许更容易的测试。这些模式中的许多都实现了这一点。</p><blockquote class="me"><p id="1fb4" class="mf mg hu bd mh mi mj mk ml mm mn kq ek translated">保持事物的简单和独立</p></blockquote></div></div>    
</body>
</html>