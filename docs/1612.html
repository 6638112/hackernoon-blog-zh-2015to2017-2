<html>
<head>
<title>JavaScript: Do you like games? (part 5)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:你喜欢游戏吗？(第五部分)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/javascript-do-you-like-games-part-5-a79bb69ad9e1?source=collection_archive---------8-----------------------#2016-11-21">https://medium.com/hackernoon/javascript-do-you-like-games-part-5-a79bb69ad9e1?source=collection_archive---------8-----------------------#2016-11-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="794c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">关于这个话题:<a class="ae jp" href="https://blog.hellojs.org/javascript-do-you-like-games-part-1-c1320c2c52ec" rel="noopener ugc nofollow" target="_blank">第1部分</a> | <a class="ae jp" href="https://blog.hellojs.org/javascript-do-you-like-games-part-2-9d4141ca2493" rel="noopener ugc nofollow" target="_blank">第2部分</a> | <a class="ae jp" href="https://blog.hellojs.org/javascript-do-you-like-games-part-3-6225ec264902" rel="noopener ugc nofollow" target="_blank">第3部分</a> | <a class="ae jp" href="https://blog.hellojs.org/javascript-do-you-like-games-part-4-9d6e8adb5626" rel="noopener ugc nofollow" target="_blank">第4部分</a> |第5部分| <a class="ae jp" rel="noopener" href="/@radu.bogdan.gaspar/javascript-do-you-like-games-part-6-7bff0b8ce05e">第6部分</a></p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/e0ca8667cb4037a29bca5fc0730ddfe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VUJsiIjFDp0UxHCI5uchlA.png"/></div></div></figure><p id="8c29" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我相信现在是我们尝试用现有的引擎开发一款游戏的时候了；你同意吗？我们将制作小行星，它于1979年11月首次亮相；由雅达利公司发布。</p><p id="0154" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以用很多方法来实现这个游戏:</p><ul class=""><li id="e26d" class="kc kd hu it b iu iv iy iz jc ke jg kf jk kg jo kh ki kj kk dt translated">我们可以使用sprite sheets，因为我们现在确实支持它们</li><li id="80f6" class="kc kd hu it b iu kl iy km jc kn jg ko jk kp jo kh ki kj kk dt translated">我们可以使用代码来绘制游戏元素</li><li id="d453" class="kc kd hu it b iu kl iy km jc kn jg ko jk kp jo kh ki kj kk dt translated">我们甚至可以添加声音，因为<strong class="it hv"> AssetsLoader </strong>类支持这样做</li></ul><p id="9b4c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我相信尝试使用<a class="ae jp" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>绘制游戏元素会有更多的学习价值，所以像:玩家、子弹、小行星和星域都将是单独的类。</p><p id="494e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还没有像碰撞这样花哨的东西，所以游戏一开始会很无聊，但是不要担心…碰撞肯定是要做的事情。</p><p id="8e9e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将从玩家开始……我们需要某种船，它根据我们之前实现的<strong class="it hv">虚拟模型</strong>移动。画布笛卡尔坐标系从左上角的x = 0，y = 0开始，所以我们画的任何东西都是相对于那个的；我们想要这艘船:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff kq"><img src="../Images/18768e1c8b748199a7d84f35650be41c.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*fAw03-O971vts91OBsnAHA.png"/></div></figure><p id="64d4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">画这个需要的指令是:<em class="kr"> moveTo() </em>点A然后<em class="kr"> lineTo() </em>点B，C，D然后回到A，从D到A的线是可选的，因为我们可以简单地调用<em class="kr"> closePath() </em>。我们将重用点B，C和D，加上一些偏移，来创建船舶推进器。</p><p id="166f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以创建一个实用的绘图方法。它需要两个参数:一组<strong class="it hv"> <em class="kr">动作</em> </strong>和每个动作的一组<strong class="it hv"> <em class="kr">坐标</em> </strong>。这个方法应该是<strong class="it hv"> DisplayObject </strong>类的一部分，因为任何绘制的东西都会扩展它。</p><p id="9e96" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们现在只使用<em class="kr"> moveTo() </em>和<em class="kr"> lineTo() </em>，所以我们的引擎将被指示使用这些:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ks kt l"/></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">engine/ui/DisplayObject.js</figcaption></figure><p id="36dc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="kr"> draw() </em>方法可以这样使用:</p><pre class="jr js jt ju fq ky kz la lb aw lc dt"><span id="63fc" class="ld le hu kz b fv lf lg l lh li">// normal approach<br/>// moveTo(10, 10)<br/>// lineTo(10, 20)<br/>// lineTo(20, 20)</span><span id="7741" class="ld le hu kz b fv lj lg l lh li">// draw method approach<br/>draw([0, 1, 1], [[10, 10], [10, 20], [20, 20]]);</span></pre><p id="a768" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可能会说这种方法弊大于利，没有适当的<a class="ae jp" href="https://hackernoon.com/tagged/documentation" rel="noopener ugc nofollow" target="_blank">文档</a>我承认，它可能会令人困惑…但它是一个辅助方法，我们不必使用它。为了清楚起见，我不会在这些帖子中使用它。</p><p id="085a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的船需要围绕它的中心点旋转，所以当我们计算绘制它所需的坐标时，必须考虑这个事实。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ks kt l"/></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">asteroids/objects/Player.js</figcaption></figure><p id="5692" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如您所见，我们的<strong class="it hv">玩家</strong>类既是一个视图又是一个控制器。您可以使用箭头键或(W，A，D)和空格键来控制船只，以播放射击声音(尽管我们还没有子弹)。我们遗漏了<strong class="it hv"> PlayerModel </strong> …让我们也补充一下:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ks kt l"/></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">asteroids/models/PlayerModel.js</figcaption></figure><p id="99c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个类似于我们在前面的例子中实现的，但是有一些额外的特性。<strong class="it hv"> PlayerModel </strong>的更新功能也处理旋转，并增加了一个速度陷阱，如果推进器关闭，它会使船减速。我们可以将所有这些特性直接添加到<strong class="it hv"> VerletModel </strong>中，并在需要的时候启用它们，但是现在这样就可以了。</p><p id="a9ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以做的下一件事是创建一个<strong class="it hv"> Map </strong>类。这将绘制场景中所有渲染对象的一些指示器，比如玩家和小行星。</p><p id="a4e2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这基本上是一个游戏中的地图，它需要两个参数:</p><ul class=""><li id="74d8" class="kc kd hu it b iu iv iy iz jc ke jg kf jk kg jo kh ki kj kk dt translated">标记(指示器)尺寸和</li><li id="ef7c" class="kc kd hu it b iu kl iy km jc kn jg ko jk kp jo kh ki kj kk dt translated">地图比例因子。</li></ul><p id="20e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">后者将表示贴图大小相对于场景大小的百分比。<strong class="it hv">映射</strong>类如下所示:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ks kt l"/></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">asteroids/objects/Map.js</figcaption></figure><p id="87e7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当标记接近地图的外边缘时，<em class="kr"> getSize() </em>方法将调整标记的大小。这是为了防止它溢出<strong class="it hv">地图</strong>容器大小。</p><p id="2b4d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们也加入一个<strong class="it hv">星域</strong>来更好的衡量；它应该产生:</p><ul class=""><li id="a195" class="kc kd hu it b iu iv iy iz jc ke jg kf jk kg jo kh ki kj kk dt translated">动态数量的恒星</li><li id="d057" class="kc kd hu it b iu kl iy km jc kn jg ko jk kp jo kh ki kj kk dt translated">这将是很好的自动生成3种类型的恒星大小(大，中，小)，以模拟某种深度；我们还会把它们的颜色从亮白色变成深灰色。</li><li id="eb0c" class="kc kd hu it b iu kl iy km jc kn jg ko jk kp jo kh ki kj kk dt translated">它应该相对于播放器模型和恒星大小来移动恒星，从而产生一种视差效果，即较近的恒星比较远的恒星移动得快</li></ul><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff lk"><img src="../Images/0a0d68e4d61c4a9c3047669b235bd00a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*8UG_wmrA9mnj9aCyg0Lfyg.jpeg"/></div></figure><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ks kt l"/></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">asteroids/objects/StarField.js</figcaption></figure><p id="2741" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你会注意到我们在<em class="kr"> update() </em>方法中调用了<em class="kr"> super.update() </em>。这是为了确保我们在<em class="kr"> generateStars() </em>方法中添加的所有星星都被渲染。或者，我们可以编写自己的<em class="kr"> render() </em>方法来完成这个任务，但是让我们使用:D引擎！</p><p id="85d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">视差效应在第62 &amp; 63行开始起作用，我们根据模型速度和恒星比例计算每个恒星的x和y位置。我们还将星星包裹在场景中，所以感觉我们正在穿越一个永无止境的领域。根据大小改变星星的颜色也给整体效果增加了一点美感。</p><p id="ba1c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你也会注意到我们在这里使用了一个<strong class="it hv">粒子</strong>类。这是新的东西，是引擎的一部分。它绘制一个指定半径和颜色的圆:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ks kt l"/></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">engine/ui/Particle.js</figcaption></figure><p id="ef63" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们把所有东西放在一起，看看它是如何工作的:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ks kt l"/></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">asteroids/index.js</figcaption></figure><p id="c1b0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">演示(免费codepen帐户中没有声音):</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ll kt l"/></div></figure><p id="3d5d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">源代码:</p><div class="lm ln fm fo lo lp"><a href="https://github.com/raduGaspar/game-physx/tree/c94de6e128a25a188443968d172a21155dbed787" rel="noopener  ugc nofollow" target="_blank"><div class="lq ab ej"><div class="lr ab ls cl cj lt"><h2 class="bd hv fv z el lu eo ep lv er et ht dt translated">红景天/游戏-physx</h2><div class="lw l"><h3 class="bd b fv z el lu eo ep lv er et ek translated">一个用于JavaScript游戏制作的小工具</h3></div><div class="lx l"><p class="bd b gc z el lu eo ep lv er et ek translated">github.com</p></div></div><div class="ly l"><div class="lz l ma mb mc ly md ka lp"/></div></div></a></div><p id="a418" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下一次我们将学习如何生成随机的小行星，这样所有的岩石看起来都有一点不同，将它们添加到地图中用于追踪和子弹生成逻辑。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="me kt l"/></div></figure></div></div>    
</body>
</html>