<html>
<head>
<title>Computer Graphics: Scan Line Polygon Fill Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计算机图形学:扫描线多边形填充算法</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/computer-graphics-scan-line-polygon-fill-algorithm-3cb47283df6?source=collection_archive---------0-----------------------#2016-11-09">https://medium.com/hackernoon/computer-graphics-scan-line-polygon-fill-algorithm-3cb47283df6?source=collection_archive---------0-----------------------#2016-11-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/080bc3003f0fa3a28bc5efef950d7576.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*28lYPHj0iO3At-3turb-uA.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">All hail tea pot</figcaption></figure><p id="a65f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这篇文章是我对“博客世界”的第一次介绍，也希望是许多关于计算和一般技术的文章的第一篇。好了，让我们继续吧。</p><p id="48b9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">今天我将讨论扫描线多边形填充(SLPF)算法，然后展示我用C++实现的算法。SLPF算法的目的是在给定图形顶点的情况下填充(着色)多边形的内部像素。</p></div><div class="ab cl ke kf hc kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hn ho hp hq hr"><h1 id="d0ba" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">基本理念:</h1><p id="e892" class="pw-post-body-paragraph jg jh hu ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hn dt translated">基本思想是收集组成多边形的所有边(除了水平边),使用边作为起点和终点逐行扫描填充图形。</p></div><div class="ab cl ke kf hc kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hn ho hp hq hr"><h1 id="654c" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">主要组件:</h1><p id="c195" class="pw-post-body-paragraph jg jh hu ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hn dt translated">为了成功填充多边形，将使用三个主要组件:<strong class="ji hv">边缘桶</strong>、<strong class="ji hv">边缘表</strong>和<strong class="ji hv">活动列表</strong>。这些组件将包含一条边的信息，保存组成图形的所有边，并分别维护用于填充多边形的当前边。</p><h2 id="3e9f" class="lo km hu bd kn lp lq lr kr ls lt lu kv jr lv lw kz jv lx ly ld jz lz ma lh mb dt translated">边缘铲斗</h2><p id="63e5" class="pw-post-body-paragraph jg jh hu ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hn dt translated">边桶是一种保存多边形边信息的结构。取决于算法的实现，边缘桶看起来不同，在我的例子中，它看起来像这样:</p><figure class="md me mf mg fq iv fe ff paragraph-image"><div class="fe ff mc"><img src="../Images/3371d663d4b2f56f96a39962c42d5990.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*r_VnrPXCszWG_3m4uogULg.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Edge Bucket representation</figcaption></figure><p id="e4c6" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">以下是每个成员在边缘存储桶中所代表的内容的细分:</p><ul class=""><li id="27e6" class="mh mi hu ji b jj jk jn jo jr mj jv mk jz ml kd mm mn mo mp dt translated"><strong class="ji hv"> yMax: </strong>边缘的最大Y位置</li><li id="2767" class="mh mi hu ji b jj mq jn mr jr ms jv mt jz mu kd mm mn mo mp dt translated"><strong class="ji hv"> yMin: </strong>边缘的最小Y位置</li><li id="9705" class="mh mi hu ji b jj mq jn mr jr ms jv mt jz mu kd mm mn mo mp dt translated"><strong class="ji hv"> x: </strong>沿扫描线的当前x位置，最初从与边缘的<strong class="ji hv"> yMin </strong>相同的点开始</li><li id="c902" class="mh mi hu ji b jj mq jn mr jr ms jv mt jz mu kd mm mn mo mp dt translated"><strong class="ji hv">符号:</strong>边缘斜率的符号(要么是-1，要么是1)</li><li id="b217" class="mh mi hu ji b jj mq jn mr jr ms jv mt jz mu kd mm mn mo mp dt translated"><strong class="ji hv"> dX: </strong>边的顶点之间的绝对差值x(差值)</li><li id="b59b" class="mh mi hu ji b jj mq jn mr jr ms jv mt jz mu kd mm mn mo mp dt translated"><strong class="ji hv"> dY: </strong>边的顶点之间的绝对差值y(差值)</li><li id="e0d5" class="mh mi hu ji b jj mq jn mr jr ms jv mt jz mu kd mm mn mo mp dt translated"><strong class="ji hv">求和:</strong>初始化为零。用作扫描线被填充到x到下一个位置</li></ul><h2 id="1791" class="lo km hu bd kn lp lq lr kr ls lt lu kv jr lv lw kz jv lx ly ld jz lz ma lh mb dt translated">边缘表</h2><p id="a230" class="pw-post-body-paragraph jg jh hu ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hn dt translated">ET是包含组成图形的所有边的列表。</p><p id="bc69" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv">重要ET注意事项:</strong></p><ul class=""><li id="bbcd" class="mh mi hu ji b jj jk jn jo jr mj jv mk jz ml kd mm mn mo mp dt translated">创建边时，边的顶点需要从左到右排序</li><li id="cada" class="mh mi hu ji b jj mq jn mr jr ms jv mt jz mu kd mm mn mo mp dt translated">边缘以yMin递增的顺序保持</li><li id="d40b" class="mh mi hu ji b jj mq jn mr jr ms jv mt jz mu kd mm mn mo mp dt translated">一旦活动列表处理完这些边，就从ET中删除这些边</li><li id="d51a" class="mh mi hu ji b jj mq jn mr jr ms jv mt jz mu kd mm mn mo mp dt translated">一旦从ET中移除了所有的边，该算法就完成了填充多边形</li></ul><h2 id="393b" class="lo km hu bd kn lp lq lr kr ls lt lu kv jr lv lw kz jv lx ly ld jz lz ma lh mb dt translated">活动列表</h2><p id="2cb0" class="pw-post-body-paragraph jg jh hu ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hn dt translated">AL包含正在处理/用于填充多边形的边。AL中的每个边都有一个配对的伙伴边，因为当填充扫描线时，从一个边开始填充像素，直到遇到伙伴边。</p><p id="35df" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv">重要铝注:</strong></p><ul class=""><li id="2d80" class="mh mi hu ji b jj jk jn jo jr mj jv mk jz ml kd mm mn mo mp dt translated">一旦边缘的yMin等于正在处理的当前扫描线，边缘就从边缘表被推入AL</li><li id="634f" class="mh mi hu ji b jj mq jn mr jr ms jv mt jz mu kd mm mn mo mp dt translated">边缘总是成对出现在AL中</li><li id="cf41" class="mh mi hu ji b jj mq jn mr jr ms jv mt jz mu kd mm mn mo mp dt translated">AL中的边缘以递增的x顺序保持。</li><li id="e405" class="mh mi hu ji b jj mq jn mr jr ms jv mt jz mu kd mm mn mo mp dt translated">每次通过后，铝将被重新分类</li></ul></div><div class="ab cl ke kf hc kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hn ho hp hq hr"><h1 id="52ae" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">步骤:</h1><p id="c55f" class="pw-post-body-paragraph jg jh hu ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hn dt translated">现在我们已经讨论了主要的组成部分，让我们更详细地回顾一下SLPF算法。</p><p id="47bd" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv">~一般假设~ </strong></p><ul class=""><li id="d009" class="mh mi hu ji b jj jk jn jo jr mj jv mk jz ml kd mm mn mo mp dt translated">用户可以使用一种方法来设置单个像素的颜色。您将看到，每当我填充一个像素时，我只需调用setPixel()方法。</li><li id="bf7e" class="mh mi hu ji b jj mq jn mr jr ms jv mt jz mu kd mm mn mo mp dt translated">给定形状的顶点围绕多边形的圆周按顺序列出</li><li id="9ed5" class="mh mi hu ji b jj mq jn mr jr ms jv mt jz mu kd mm mn mo mp dt translated">这一点很重要，否则多边形将无法正确绘制</li></ul><p id="de60" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">以下是步骤:</p><pre class="md me mf mg fq mv mw mx my aw mz dt"><span id="52c9" class="lo km hu mw b fv na nb l nc nd">1. Create ET<br/>    1. Process the vertices list in pairs, start with [numOfVertices-1] and [0].<br/>    2. For each vertex pair, create an edge bucket<br/>2. Sort ET by yMin<br/>3. Process the ET<br/>    1. Start on the scan line equal to theyMin of the first edge in the ET<br/>    2. While the ET contains edges<br/>        1. Check if any edges in the AL need to be removes (when yMax == current scan line)<br/>            1. If an edge is removed from the AL, remove the associated the Edge Bucket from the Edge Table.<br/>        2. If any edges have a yMin == current scan line, add them to the AL<br/>        3. Sort the edges in AL by X<br/>        4. Fill in the scan line between pairs of edges in AL<br/>        5. Increment current scan line<br/>        6. Increment all the X's in the AL edges based on their slope<br/>            1. If the edge's slope is vertical, the bucket's x member is <strong class="mw hv">NOT</strong> incremented.</span></pre><p id="3800" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">(为什么Medium不支持嵌套列表？？)</p><p id="4b74" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv">最终重要提示:</strong></p><ul class=""><li id="e7a2" class="mh mi hu ji b jj jk jn jo jr mj jv mk jz ml kd mm mn mo mp dt translated">创建边桶时，如果边的顶点不是按从左到右的顺序排列，则桶的符号可能不正确。如果边缘铲斗有错误的符号，当您试图装满它们时会发生这种情况:</li></ul><figure class="md me mf mg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ne"><img src="../Images/0265bb76293b84685c91e1f4ad486867.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XIB3nmlCRwNu4eec.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Something is not right here…</figcaption></figure><p id="32d9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">为了在边缘桶中仅维护整数，斜率并不实际计算，而是作为三个不同的成员维护:sign、dX、dY。</p><ul class=""><li id="e15d" class="mh mi hu ji b jj jk jn jo jr mj jv mk jz ml kd mm mn mo mp dt translated">这允许边缘桶的x成员谨慎地递增，而不用担心在点中遇到实数时会发生什么</li><li id="95ab" class="mh mi hu ji b jj mq jn mr jr ms jv mt jz mu kd mm mn mo mp dt translated">如果斜率解释不正确，可能会出现以下情况:</li></ul><figure class="md me mf mg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nf"><img src="../Images/c0e3dd3697e4f25d78b9b32928d9ae34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cO1kMfie6s0dNj4k.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">No x increment == pixelated image?</figcaption></figure></div><div class="ab cl ke kf hc kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hn ho hp hq hr"><h1 id="3596" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">实施:</h1><p id="a5d0" class="pw-post-body-paragraph jg jh hu ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hn dt translated">现在已经介绍了细节，下面是SLPF在C++中的实现。</p><blockquote class="ng"><p id="3a44" class="nh ni hu bd nj nk nl nm nn no np kd ek translated">由于我的教授的要求，代码的C++实现已经被删除，并替换为伪代码(非常担心学生将复制项目的代码)。如果你对我的C++实现感兴趣，请随时给我发消息。</p></blockquote><p id="0f1c" class="pw-post-body-paragraph jg jh hu ji b jj nq jl jm jn nr jp jq jr ns jt ju jv nt jx jy jz nu kb kc kd hn dt translated"><strong class="ji hv">主程序(伪代码)</strong></p><pre class="md me mf mg fq mv mw mx my aw mz dt"><span id="e555" class="lo km hu mw b fv na nb l nc nd">/*<br/>    Creates edge buckets from the given edges<br/> <br/>    <a class="ae nv" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> n    Number of vertices<br/>    <a class="ae nv" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> x[]  array of x points<br/>    <a class="ae nv" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> y[]  array of y points<br/> <br/>    <a class="ae nv" href="http://twitter.com/return" rel="noopener ugc nofollow" target="_blank">@return</a>     List of edge buckets<br/> */<br/>createEdges(n, x[], y[]) {<br/>    instantiate a new edge table</span><span id="d47f" class="lo km hu mw b fv nw nb l nc nd">   loop through x[] &amp; y[] pairs {<br/>        if the edge's slope is NOT undefined (verticle) {<br/>            create bucket with edge<br/>            add bucket to edge table<br/>        }<br/>    }<br/>}</span><span id="18fe" class="lo km hu mw b fv nw nb l nc nd">/*<br/>    Given the edge table of the polygon, fill the polygons<br/> <br/>    <a class="ae nv" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> edgeTable The polygon's edge table representation<br/> */<br/>processEdgeTable (edgeTable) {<br/>    while (edge table is NOT empty) {</span><span id="bb81" class="lo km hu mw b fv nw nb l nc nd">// Remove edges from the active list if y == ymax<br/>        if (active list is NOT empty) {<br/>            for (iterate through all buckets in the active list) {<br/>                if (current bucket's ymax == current scanline) {<br/>                    remove bucket from active list<br/>                    remove bucket from edge table<br/>                }<br/>            }<br/>        }</span><span id="9d54" class="lo km hu mw b fv nw nb l nc nd">// Add edge from edge table to active list if y == ymin<br/>        for (iterate through the bucket in the edge table) {<br/>            if (bucket's ymin == scanline) {<br/>                add bucket to active list<br/>            }<br/>        }</span><span id="4303" class="lo km hu mw b fv nw nb l nc nd">// Sort active list by x position and slope<br/>        sortTheActiveList();</span><span id="40bc" class="lo km hu mw b fv nw nb l nc nd">// Fill the polygon pixel<br/>        for (iterate through the active list) {<br/>            for (from vertex1.x to vertex2.x of the bucket) {<br/>                setPixelColor()<br/>            }<br/>        }</span><span id="a795" class="lo km hu mw b fv nw nb l nc nd">// Increment X variables of buckets based on the slope<br/>        for (all buckets in the active list) {<br/>            if (bucketsdX != 0) {<br/>                bucket's sum += bucket's dX</span><span id="0a8c" class="lo km hu mw b fv nw nb l nc nd">       while (bucket's sum &gt;= bucket's dY) {<br/>            increment or decrement bucket's X depending on sign of   bucket's slope<br/>            edge's sum -= dY<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</span><span id="2113" class="lo km hu mw b fv nw nb l nc nd">///<br/>// Draw a filled polygon in the Canvas C.<br/>//<br/>// The polygon has n distinct vertices.  The coordinates of the vertices<br/>// making up the polygon are stored in the x and y arrays.  The ith<br/>// vertex will have coordinate (x[i],y[i]).<br/>//<br/>// <a class="ae nv" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> n - number of vertices<br/>// <a class="ae nv" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> x - x coordinates<br/>// <a class="ae nv" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> y - y coordinates<br/>///<br/>drawPolygon(n, x[], y[]) {<br/>    // Create edge table<br/>    finalEdgeTable = createEdges()</span><span id="6951" class="lo km hu mw b fv nw nb l nc nd">// Sort edges by minY<br/>    sort(finalEdgeTable)</span><span id="5dc2" class="lo km hu mw b fv nw nb l nc nd">processEdgeTable(finalEdgeTable)<br/>}</span></pre><p id="c2bc" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv">带结构的头文件</strong></p><pre class="md me mf mg fq mv mw mx my aw mz dt"><span id="2e9d" class="lo km hu mw b fv na nb l nc nd">/*<br/>    Bucket struct to hold edge information<br/> */<br/>struct Bucket {<br/>    int yMax;<br/>    int yMin;<br/>    int x;<br/>    int sign;<br/>    int dX;<br/>    int dY;<br/>    double sum;<br/>};</span><span id="d003" class="lo km hu mw b fv nw nb l nc nd">/*<br/>    Vertex struct to hold x and y values<br/> */<br/>struct Vertex {<br/>    int x;<br/>    int y;<br/>};</span></pre></div><div class="ab cl ke kf hc kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hn ho hp hq hr"><p id="85fb" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这就是实现SLPF算法所需要的一切！我希望这篇文章是有建设性的，并且你喜欢阅读它。如果有任何错误，你想留下评论，随时这样做或给我发消息。</p><p id="b124" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">干杯！</p><div class="md me mf mg fq ab cb"><figure class="nx iv ny nz oa ob oc paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nx iv ny nz oa ob oc paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nx iv ny nz oa ob oc paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="od oe of"><p id="f922" class="jg jh og ji b jj jk jl jm jn jo jp jq oh js jt ju oi jw jx jy oj ka kb kc kd hn dt translated"><a class="ae nv" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae nv" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae nv" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae nv" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jg jh og ji b jj jk jl jm jn jo jp jq oh js jt ju oi jw jx jy oj ka kb kc kd hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae nv" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae nv" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="md me mf mg fq iv fe ff paragraph-image"><a href="https://goo.gl/Ahtev1"><div class="fe ff ok"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></a></figure></div></div>    
</body>
</html>