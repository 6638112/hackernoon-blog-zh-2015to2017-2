<html>
<head>
<title>Client, Network, Server and Application Caching on the Web</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Web上的客户端、网络、服务器和应用程序缓存</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/client-network-server-and-application-caching-on-the-web-2fcdcd856886?source=collection_archive---------2-----------------------#2017-04-17">https://medium.com/hackernoon/client-network-server-and-application-caching-on-the-web-2fcdcd856886?source=collection_archive---------2-----------------------#2017-04-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/7985184bc4173a193c31932e672a2569.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L8GvaTHxVE2JXzguf0NV7g.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Web Caching</figcaption></figure><p id="fc45" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">本文涵盖了高可伸缩性和高性能的秘密之一。一篇关于Flickr架构的<a class="ae ke" href="http://highscalability.com/flickr-architecture" rel="noopener ugc nofollow" target="_blank">博客文章</a>有超过<a class="ae ke" href="https://www.flickr.com/photos/franckmichel/6855169886" rel="noopener ugc nofollow" target="_blank">50亿张照片</a>带给我们以下内容:<em class="kf">缓存和RAM是一切的答案</em>。</p><p id="5d83" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">一个<a class="ae ke" href="https://hackernoon.com/tagged/website" rel="noopener ugc nofollow" target="_blank">网站</a>可以在三个不同的层和环境上存储数据以加速未来的请求:1)客户端，2) <a class="ae ke" href="https://hackernoon.com/tagged/network" rel="noopener ugc nofollow" target="_blank">网络</a>，3)服务器，以及4)应用程序。</p><figure class="kh ki kj kk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kg"><img src="../Images/fab6dd94c788e8576e2f8a649e3399e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4tWOpYfh4CArRxahgMQ46A.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Chapter 1. Client Caching</figcaption></figure><p id="4a5e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">网站的不同页面通常共享相同的资源。用户应该在导航过程中重用资产。<em class="kf">图像</em>、<em class="kf">脚本、</em>和<em class="kf">样式</em>可以缓存数月，文档页面本身也可以在客户端浏览器上缓存数分钟。</p><p id="77c2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">HTTP头负责定义是否可以缓存响应<strong class="ji hv">以及缓存多长时间</strong>。下面的<code class="eh kl km kn ko b">Cache-Control</code>头示例表明响应可能会被缓存7天。只有当缓存过期或者用户强制刷新页面时，浏览器才会再次请求它:</p><figure class="kh ki kj kk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kp"><img src="../Images/d84f82e987e0f6d00222c8a1a5b095b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tvFLId9NNE5BNYoXCMmZhA.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Request and response that could be cached for 604800 seconds</figcaption></figure><p id="e10b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">响应还可以包括一个<code class="eh kl km kn ko b">Last-Modified</code>报头或一个<code class="eh kl km kn ko b">Etag</code>报头。这些头用于验证过期的响应是否可以重用。响应状态304指示内容没有改变并且<strong class="ji hv">不需要再次下载</strong>。注意下面的<code class="eh kl km kn ko b">Last-Modified</code>和<code class="eh kl km kn ko b">If-Modified-Since</code>标题对和日期:</p><figure class="kh ki kj kk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kq"><img src="../Images/c99c05e38682acd1673cc6d470d872bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e1OgtTK5B31zH3qssMsUmA.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Response with Last-Modified header and subsequent request using it</figcaption></figure><p id="3aaa" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh kl km kn ko b">Etag</code>标题与<code class="eh kl km kn ko b">If-None-Match</code>一起使用，以类似的方式交换代码来识别内容是否改变。</p><p id="35ea" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">明智地定义HTTP头的网站将为用户提供更好的体验。基于此，浏览器可以节省时间和网络带宽。</p><figure class="kh ki kj kk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kr"><img src="../Images/527ce3de86e2b0a11e008251c8ee9ad7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kcpjw0hHP8waLQ13xQ6gfw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Chapter 2. Network Caching</figcaption></figure><p id="135b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">维基百科将内容交付网络(CDN)定义为代理服务器的全球分布式网络。cdn是关于缓存的——共享缓存。</p><p id="379a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">HTTP header指令允许网络的不同部分缓存响应。在任何地方，发现带有<code class="eh kl km kn ko b">Cache-Control: public, max-age=31536000</code>的资产意味着它可以持续一年是很常见的。</p><p id="851c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">你可能知道还有其他的<a class="ae ke" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control" rel="noopener ugc nofollow" target="_blank">头缓存指令</a>。还有一个<a class="ae ke" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Vary" rel="noopener ugc nofollow" target="_blank">强大的头</a>来处理认证和其他类型的动态响应。</p><figure class="kh ki kj kk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kr"><img src="../Images/de99f1c2c84dc8341f7aa66121ede5af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DcKZPX628BU-1ADpBVI-4g.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Chapter 3. Server Caching</figcaption></figure><p id="53f9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">最后，控制权全在你手上，开发者！除了设置正确的响应头和正确处理请求头之外，在服务器端和应用程序端还有许多可以改进的地方。</p><p id="4287" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">更快响应和节省资源的第一种方法是在应用程序和客户端之间建立一个缓存服务器。</p><figure class="kh ki kj kk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kr"><img src="../Images/a1f0fa2d6da2b5c3f9264055f1d4f7c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PG5FLonsY8oCWHPLsrqT6Q.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Clients requesting the same content to a proxy server</figcaption></figure><p id="5390" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">像<a class="ae ke" href="https://varnish-cache.org" rel="noopener ugc nofollow" target="_blank"> Varnish </a>、<a class="ae ke" href="http://www.squid-cache.org" rel="noopener ugc nofollow" target="_blank"> Squid </a>和<a class="ae ke" href="https://www.nginx.com" rel="noopener ugc nofollow" target="_blank"> nginx </a>这样的工具可能会缓存<em class="kf">图像</em>、<em class="kf">脚本</em>和其他用户共享的内容。下面的例子设置了一个nginx服务器代理，它只依靠应用程序HTTP头上的<strong class="ji hv">来缓存内容:</strong></p><figure class="kh ki kj kk fq iv"><div class="bz el l di"><div class="ks kt l"/></div></figure><p id="3eaf" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">还有一个叫做<code class="eh kl km kn ko b">proxy_cache_lock</code>的指令，它允许代理服务器一次只为应用程序<strong class="ji hv">委托第一个类似的客户端请求</strong>。如果设置为on，客户机将在第一个请求返回时收到响应。</p><figure class="kh ki kj kk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kp"><img src="../Images/52bd66c1a4c7280af8944e2afba9da1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*61hXRoLh1xEmtJPiazAZaQ.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Many clients requesting the same content at the same time</figcaption></figure><p id="ebdb" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这是一个简单而强大的机制，当内容过期、<strong class="ji hv">、</strong>并且许多客户端请求它时，<strong class="ji hv">避免了应用程序端的混乱。</strong></p><p id="86b4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">服务器代理还可以使用指令<code class="eh kl km kn ko b">proxy_cache_use_stale: updating;</code>为后续的类似请求传递过期的内容。这加快了响应时间，减少了等待服务器响应的客户端数量。</p><p id="a7a8" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">最后但同样重要的是，<strong class="ji hv">代理可以提高应用程序</strong>的容错能力。当应用程序返回错误状态或者当服务器代理和应用程序之间的通信没有按预期工作时，<code class="eh kl km kn ko b">proxy_cache_use_stale</code>指令有标志来传递过期的内容。</p><p id="c3d1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">文章<a class="ae ke" href="https://www.nginx.com/blog/nginx-caching-guide/" rel="noopener ugc nofollow" target="_blank">使用NGINX和NGINX Plus进行缓存的指南</a>有更多的细节和配置选项。</p><figure class="kh ki kj kk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kp"><img src="../Images/7102b4439bc3dc057568a627582c5822.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xcHwBcWQEaS5F-9AzluhSQ.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Chapter 4. Application Caching</figcaption></figure><p id="f7fa" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">应用程序缓存减少了特定操作的时间。复杂的计算、对其他服务的数据请求或跨请求共享的公共数据就是一些例子。</p><h2 id="b5cf" class="ku kv hu bd kw kx ky kz la lb lc ld le jr lf lg lh jv li lj lk jz ll lm ln lo dt translated">4.1.记忆化</h2><figure class="kh ki kj kk fq iv"><div class="bz el l di"><div class="ks kt l"/></div></figure><p id="1e9b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">上面的Ruby代码使用了简单的<strong class="ji hv"> <em class="kf">内存缓存</em>技术</strong>。它存储<em class="kf">产品</em> <em class="kf">价格</em>以避免将来的计算。在这种情况下，它将把数据存储在对象实例上，并且只在请求期间节省资源。</p><p id="d08b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这种技术可以应用于代码中的任何地方。但是它的使用带来了一些问题。例如，记住你的数据不会过期是很重要的。<strong class="ji hv">全局代码<em class="kf">记忆</em>将在整个应用程序执行周期中持续存在于内存中。</strong></p><h2 id="941c" class="ku kv hu bd kw kx ky kz la lb lc ld le jr lf lg lh jv li lj lk jz ll lm ln lo dt translated">4.2.智能内存缓存</h2><figure class="kh ki kj kk fq iv"><div class="bz el l di"><div class="ks kt l"/></div></figure><p id="a31c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">上面的代码使用<a class="ae ke" href="http://guides.rubyonrails.org/caching_with_rails.html#low-level-caching" rel="noopener ugc nofollow" target="_blank"> Rails缓存API </a>在一分钟<strong class="ji hv">内跨请求</strong>存储和重用<em class="kf">类别税</em>。<em class="kf">缓存键</em>定义使用<code class="eh kl km kn ko b">category_id</code>来识别数据。该技术用于减少对外部类别Tax Service的请求量，从而节省资源和时间。</p><p id="8dc0" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">有许多库提供这种模式。但是重要的是要提到应用程序内存是一种有限的资源。例如，<a class="ae ke" href="https://github.com/ptarjan/node-cache/issues/77" rel="noopener ugc nofollow" target="_blank">节点缓存模块不管理消耗的内存量</a>。如果您的应用程序大量缓存数据，消耗所有可用的内存，这可能是一个问题。</p><p id="e916" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">Rails内存缓存 <strong class="ji hv">通过删除最近最少使用的条目，在缓存数据超过分配的内存大小时明智地删除缓存数据。它允许缓存不可变的数据，而无需定义到期时间。</strong></p><h2 id="ccc5" class="ku kv hu bd kw kx ky kz la lb lc ld le jr lf lg lh jv li lj lk jz ll lm ln lo dt translated">4.3.缓存存储—共享缓存</h2><p id="c398" class="pw-post-body-paragraph jg jh hu ji b jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd hn dt translated">处理越来越多用户和请求是Web开发的一个重要主题。扩展应用程序的方法之一是添加更多的应用程序实例(水平扩展)。正如您可能想象的那样，简单的内存缓存不能在实例之间共享。</p><figure class="kh ki kj kk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kp"><img src="../Images/ac52854b06f45bec5b1b2cea4e411f8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CJEiCCJvrphm5ydYcpLIag.png"/></div></div></figure><p id="8751" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">十二因素应用，一种构建软件即服务(SaaS)的方法，指出<a class="ae ke" href="https://12factor.net/processes" rel="noopener ugc nofollow" target="_blank">一个应用程序永远不应该假设缓存在内存或磁盘上的任何东西在未来的请求</a>或作业中是可用的——随着每种类型的许多进程的运行，未来的请求将由不同的进程服务的可能性很高。</p><p id="cc50" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">像<a class="ae ke" href="http://memcached.org" rel="noopener ugc nofollow" target="_blank"> Memcached </a>或<a class="ae ke" href="http://redis.io" rel="noopener ugc nofollow" target="_blank"> Redis </a>这样的键值存储可以用来在应用程序实例之间共享缓存数据。这些工具有<a class="ae ke" href="https://github.com/memcached/memcached/wiki/UserInternals#when-are-items-evicted" rel="noopener ugc nofollow" target="_blank">不同的</a> <a class="ae ke" href="https://redis.io/topics/lru-cache" rel="noopener ugc nofollow" target="_blank">策略</a>来修剪缓存的数据量。缓存存储也可以通过<a class="ae ke" href="http://redis.io/topics/replication" rel="noopener ugc nofollow" target="_blank">复制</a>和<a class="ae ke" href="http://redis.io/topics/persistence" rel="noopener ugc nofollow" target="_blank">持续</a>来容错。它应该有如此不同的要求，以至于<a class="ae ke" href="https://www.slideshare.net/ShashiShekarMadappa/evcache-at-netflix" rel="noopener ugc nofollow" target="_blank">网飞建立了自己的工具</a>。</p><p id="074e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在使用缓存存储时要考虑的另一个重要方面是<em class="kf">竞争条件</em>，当不同的应用程序实例同时获取未缓存的数据时会发生这种情况。<a class="ae ke" href="http://api.rubyonrails.org/classes/ActiveSupport/Cache/Store.html#method-i-fetch" rel="noopener ugc nofollow" target="_blank"> Rails缓存获取API </a>有<code class="eh kl km kn ko b">race_condition_ttl</code>来最小化这种影响。</p><p id="7e1b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">很难完全消除多个应用程序实例的缓存更新竞争条件问题。一个解决方案是在应用程序流之外更新缓存数据，只使用应用程序上的缓存数据。在微服务架构上，也可以使用nginx代理服务器保护应用程序和服务之间的通信，如上所述。</p></div><div class="ab cl lu lv hc lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hn ho hp hq hr"><p id="4094" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我希望这篇文章能帮助您理解并选择最适合您的应用程序的策略。<strong class="ji hv">用于缓存的HTTP头很简单，你应该尽快设置。当您解决一些性能问题时，您应该设置其他缓存策略，请记住“过早优化是万恶之源”</strong></p><div class="kh ki kj kk fq ab cb"><figure class="mb iv mc md me mf mg paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mb iv mc md me mf mg paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mb iv mc md me mf mg paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mh mi mj"><p id="f922" class="jg jh kf ji b jj jk jl jm jn jo jp jq mk js jt ju ml jw jx jy mm ka kb kc kd hn dt translated"><a class="ae ke" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ke" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ke" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae ke" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jg jh kf ji b jj jk jl jm jn jo jp jq mk js jt ju ml jw jx jy mm ka kb kc kd hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ke" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ke" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kh ki kj kk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mn"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="kh ki kj kk fq iv"><div class="bz el l di"><div class="mo kt l"/></div></figure></div></div>    
</body>
</html>