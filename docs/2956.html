<html>
<head>
<title>Counting lines 60% faster than wc, with Clojure + core.async</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Clojure + core.async，计算行数比wc快60%</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/counting-lines-60-faster-than-wc-with-clojure-core-async-1af4ce058884?source=collection_archive---------8-----------------------#2017-03-02">https://medium.com/hackernoon/counting-lines-60-faster-than-wc-with-clojure-core-async-1af4ce058884?source=collection_archive---------8-----------------------#2017-03-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="12db" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">昨天我注意到<a class="ae jp" rel="noopener" href="/@atroche/file-processing-in-clojure-can-easily-become-cpu-bound-3c1c38669daf">我笔记本电脑的固态硬盘速度非常快，任何一个单核都跟不上</a>——即使是像计算<a class="ae jp" href="https://hackernoon.com/tagged/file" rel="noopener ugc nofollow" target="_blank">文件中的行数</a>这样简单的任务，以及像<a class="ae jp" href="https://en.wikipedia.org/wiki/Wc_(Unix)" rel="noopener ugc nofollow" target="_blank"> wc </a>这样久经考验的工具。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/dbd6ccb563927a5f780c599639e3124d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IxXyky43JoAeNqz7cIY5lA.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">833MB/s is not even close to maxing out my SSD’s throughput</figcaption></figure><p id="928c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">今天晚上，在接受了reddit帖子上可爱的评论者的许多建议后，我找到了一个更好的方法。</p><p id="71f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">关键思想是让一个线程什么也不做，除了:</p><ul class=""><li id="4b73" class="kg kh hu it b iu iv iy iz jc ki jg kj jk kk jo kl km kn ko dt translated">将数据读入字节数组，以及</li><li id="0955" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated">将数组传递给另一个线程进行“处理”(如果你可以用这个词来美化换行计数的话)。</li></ul><p id="9d0b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">古老的unix工具WC<strong class="it hv">计算同一线程中的行数(查看我昨天从BSD wc源代码中勾画的这个<a class="ae jp" href="https://gist.github.com/atroche/fe757cc547cace688a65324fa8f99de9" rel="noopener ugc nofollow" target="_blank">超级精简实现</a>)。</strong></p><p id="be6b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://hackernoon.com/tagged/clojures" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> Clojure的</strong> </a>默认读取行的方式(line-seq，它使用了BufferedReader)在同一个线程上执行UTF解码，这(正如我昨天注意到的)是一个真正的瓶颈，当你的SSD每秒钟泵送超过1gb的数据时。</p><p id="5c0f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">而我2015年中期的MBP中的那一款再也不是顶级的了:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff ku"><img src="../Images/1e49b5bf4a92977d80b286263b3c6c87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gA7RuXKqsT3U4UkW9VQvYQ.png"/></div></div></figure><p id="aa31" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我今晚编写的并行版本平均需要6.9秒才能完成，大约提高了60%。不仅如此，它没有使用JVM丑陋的低级线程和并发原语，而是使用了core.async的相当高级的抽象。</p><p id="9f14" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(我还对小得多的文件进行了测试，发现了类似的加速效果)。</p><p id="f0ff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">代码如下:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="kv kw l"/></div></figure><p id="8b43" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里已经很晚了，所以我不打算深入讨论它，但它只是实现了我上面提到的核心思想，即保持一个线程专用于进行系统调用，其他的很少。这里是<a class="ae jp" href="https://gist.github.com/atroche/08b966664489f80e87a145cef6775b07" rel="noopener ugc nofollow" target="_blank">完整的名称空间，要求和所有的</a>。如果你有问题或意见，请跳到<a class="ae jp" href="https://www.reddit.com/r/Clojure/comments/5x2n47/counting_lines_60_faster_than_wc_with_clojure/" rel="noopener ugc nofollow" target="_blank">/r/clo jure Reddit线程</a>。</p><p id="70d0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">随着我们向更快的固态硬盘、更多的内核和静态时钟速度发展，CPU绑定IO的问题似乎变得更加重要。我想知道标准库(像Clojure的和Java的)将如何适应以跟上步伐？</p><p id="c214" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="kx">【编辑:查看</em> <a class="ae jp" href="https://www.reddit.com/r/programming/comments/5x39jh/counting_lines_60_faster_than_wc_with_clojure/" rel="noopener ugc nofollow" target="_blank"> <em class="kx">令人敬畏的unix-y处理多核IO的方式</em> </a> <em class="kx">人们在/r/编程线程中想到的</em></p><p id="52b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="kx">【edit 2:这里有</em> <a class="ae jp" href="https://gist.github.com/atroche/08b966664489f80e87a145cef6775b07" rel="noopener ugc nofollow" target="_blank"> <em class="kx">整个Clojure文件</em> </a> <em class="kx">，如果你想试着运行或者修改的话。而如果你想生成一个测试文件，试试:"</em>head-c 10G/dev/random&gt;random . txt "<em class="kx">]</em></p><div class="jr js jt ju fq ab cb"><figure class="ky jv kz la lb lc ld paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="ky jv kz la lb lc ld paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="ky jv kz la lb lc ld paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="le lf lg"><p id="f922" class="ir is kx it b iu iv iw ix iy iz ja jb lh jd je jf li jh ji jj lj jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是T21家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is kx it b iu iv iw ix iy iz ja jb lh jd je jf li jh ji jj lj jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff lk"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ll kw l"/></div></figure></div></div>    
</body>
</html>