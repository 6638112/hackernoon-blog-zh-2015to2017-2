<html>
<head>
<title>Options for Adding a Blog to an Existing .NET Web App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将博客添加到现有。NET Web应用程序</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/options-for-adding-a-blog-to-an-existing-net-web-app-4a990ee7e046?source=collection_archive---------5-----------------------#2017-06-26">https://medium.com/hackernoon/options-for-adding-a-blog-to-an-existing-net-web-app-4a990ee7e046?source=collection_archive---------5-----------------------#2017-06-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/7c507080b2e9b7dba8e751b5df5a4c82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wmzWK1C3OHQofPaJ.png"/></div></div></figure><p id="b1a9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您有一个现有的网站或应用程序，突然需要像博客这样的高级内容管理功能，您会怎么做？拆了在WordPress这样的博客平台上重建？将自己的博客作为现有网站的一个组成部分？这两种解决方案都需要大量的工作。围绕一个特定的平台重新构建一个应用程序不是一件简单的事情，您的应用程序将永远与这个平台结合在一起。考虑到写博客是一个已经解决了很多次的问题，建立自己的博客系统似乎是一种浪费。</p><p id="a078" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">理想情况下，你可以利用一个现有的博客平台，将它整合到你的网站中，只需对你现有的做最小的改动。为了找到一个符合这个要求的平台，我们需要从一个基本需求清单开始。这里有一些我们需要的东西:</p><ul class=""><li id="9a37" class="ka kb hu je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki dt translated"><strong class="je hv">关注点分离:</strong>假设我们有一个web应用程序，其现有的业务逻辑与博客无关。我们不想给应用程序本身增加博客功能——我们想保持它的实现是独立的，但从用户的角度来看是无缝集成的。</li><li id="dd1f" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated"><strong class="je hv">最少的开发人员工作:</strong>我们不想为了在应用程序和博客页面上获得相同的外观和感觉而维护视图模板的不同版本。</li><li id="1700" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated"><strong class="je hv">常见的博客功能:</strong>我们不妨定义一下博客的含义——我们需要创建博客帖子和单个页面的能力，与多个作者打交道，并拥有发布工作流。</li></ul><p id="3d52" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我们这样做的时候，我们还应该考虑一些“值得拥有”的东西:</p><ul class=""><li id="741f" class="ka kb hu je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki dt translated">粒度(Granularity):如果能够用博客驱动页面的特定部分就好了，而不是采取全有或全无的方法，即某些页面完全由博客控制，而其他页面必须在没有博客支持的情况下完全存在。例如，我们可能有一个现有的应用程序，它有一个登陆/登录页面。如果我们可以在侧边栏中显示最近的帖子列表，而不必将整个页面的控制权移交给博客平台，那就太好了。</li><li id="5e86" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated"><strong class="je hv">语言不可知</strong>:我们更喜欢一个通用的解决方案——如果<a class="ae ko" href="https://hackernoon.com/tagged/cms" rel="noopener ugc nofollow" target="_blank"> CMS </a>碰巧是用不同于我们现有应用程序的语言编写的，我们不必担心维护两个独立的运行时。</li><li id="232f" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated"><strong class="je hv">主持人</strong>:如果我们可以完全避免支持博客的实现，那就太理想了。如果我们真的想把它从我们现有的应用程序中分离出来，我们很可能会以<a class="ae ko" href="https://hackernoon.com/tagged/maintaining" rel="noopener ugc nofollow" target="_blank">维护</a>两个独立的代码体和两个独立的数据库而告终。最好的情况是，我们可以使用托管解决方案，但显示内容和页面，就好像它们是我们自己网站的一部分。这也可能使我们不必担心上面提到的多运行时问题。</li></ul><p id="50d6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于我们的例子来说，假设我们有一个用. NET编写的web应用程序，那么什么样的博客平台能满足我们的需求呢？</p><h1 id="b7e7" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">wordpress软件</h1><p id="38c2" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">考虑到WordPress的受欢迎程度和出色的社区支持，认真考虑它是很自然的。它当然有我们创建页面和博客文章所需的功能。然而，除此之外，我们很快就会遇到问题。</p><p id="aaef" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">WordPress的托管实例是存在的，但是我们如何将这些整合到一个现有的网站中还不清楚。如果我们的站点在<code class="eh ls lt lu lv b">example.com</code>，我们可以将<code class="eh ls lt lu lv b">blog.example.com</code>指向我们托管的WordPress，但是如果我们不想这么做呢？这种解决方案缺乏灵活性。这也意味着我们可以忘记粒度。</p><p id="ac5c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们希望我们的博客驻留在<code class="eh ls lt lu lv b">example.com/blog</code>，我们需要自己托管它，并将某些页面发送到WordPress。同样，这缺乏粒度。没有简单的方法从WordPress中提取最近的文章标题列表，并将其插入到我们的。NET应用程序可能会使用。这也意味着我们必须维护自己的WordPress代码、数据库和PHP运行时，以及为WordPress/PHP编写的视图模板的单独版本。</p><h1 id="da69" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">DotNetNuke / SiteFinity</h1><p id="4aea" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">DotNetNuke是一个流行的。NET CMS通过插件模块支持博客。利用DNN或其他人。像SiteFinity这样的. NET CMS可以立即缓解维护独立技术栈的问题——但这仅仅是因为我们的示例web应用程序碰巧是用. NET编写的。</p><p id="2fb2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们还需要维护一个单独的数据库，或者在我们现有的模式中包含CMS数据库表。</p><h1 id="b3df" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">卷你自己的</h1><p id="cd41" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">开始感觉像是推出我们自己的博客平台，虽然是一个糟糕的解决方案，但和前面提到的那些一样好。我们可以根据自己的需要将它细化，随意将单个内容字段或整个页面放入现有的模板中。也许我们可以用这样一种方式来设计我们的代码，将博客代码与现有的应用程序完全分离。但是这仍然需要大量的努力和费用。</p><p id="5fd8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当考虑建立我们自己的博客时，很明显我们真正需要的是一个博客引擎。我们需要逻辑和管理UI来管理内容，但没有前端——它应该完全不受路由、模板和呈现页面的影响。这将给我们处理内容的工具，同时给我们以我们认为合适的方式显示和整合内容的灵活性。</p><h1 id="5093" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">无头内容管理</h1><p id="e36d" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">“博客引擎”的另一个词，按照我们的设想，可能是一个<em class="lw">无头博客</em>或<em class="lw">无头CMS </em>。这是一个CMS，有后端，但没有前端。内容是通过引擎的API获取的，但是向用户显示内容则完全由开发人员决定。由于其灵活性和非侵入式集成，这种架构最近变得非常流行。</p><p id="03d0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个这样的平台是ButterCMS。这是一个托管解决方案，带有一个管理仪表板，用于编辑博客文章、处理创作工作流、国际化等。通过这个后端创建的内容通过REST API公开，可以通过用多种语言(包括C#/编写的各种客户端库访问该API。网)。</p><p id="3650" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这可能有用。让我们看看我们的需求，看看它是否能满足我们的需求:</p><ul class=""><li id="7264" class="ka kb hu je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki dt translated"><strong class="je hv">关注点分离:</strong>因为ButterCMS是托管的，所以代码、数据库和维护完全由ButterCMS处理。</li><li id="ed2d" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated"><strong class="je hv">最少的开发工作:</strong>通过调用REST API，使用字符串键来识别页面和博客文章，从而获取内容。在大多数情况下，显示一个页面就像向API请求原始HTML内容一样简单，将它放在视图模板中，然后呈现它。</li><li id="293e" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated"><strong class="je hv">通用CMS特性:</strong>博客文章、自定义页面、多作者和发布工作流都受支持。</li><li id="781e" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated"><strong class="je hv">粒度:</strong> ButterCMS允许创建多种类型的内容，从整个页面到文本字段，再到简单的对象和数组结构。</li><li id="125b" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated"><strong class="je hv">语言不可知:</strong>官方Ruby，JavaScript，Python，PHP，和。当前存在. NET客户端。</li><li id="99a0" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">托管: ButterCMS是一个完全托管的解决方案。您所需要的只是一个帐户、一个API密匙和一个您选择的语言的客户端。</li></ul><p id="c8dc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过API客户端获取内容并呈现它听起来确实很简单，但是让我们尝试一下以确保万无一失。我们将用C#实现一个简单的<a class="ae ko" href="http://asp.net/" rel="noopener ugc nofollow" target="_blank">ASP.NET</a>MVC控制器来为一条路线呈现合适的博客文章。</p><p id="aa48" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在此之前，我们需要一个ButterCMS帐户。注册并登录后，我们可以在控制面板的左上角单击我们的名字。在出现的下拉菜单中，单击“设置”并转到API选项卡。这将显示我们的API令牌。我们需要将这个令牌传递给我们的API客户机，客户机在每次请求时将这个令牌传递给ButterCMS API来标识我们。</p><p id="aa61" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们还需要一些博客文章来渲染。点击左侧边栏菜单上的“新文章”。写“我的第一篇测试文章”作为标题，并添加一些内容(不管是什么，我们只需要一些东西来渲染)，然后单击顶部的“发布”按钮。然后做同样的事情添加另一个帖子，但标题是“我的第二个测试帖子”。</p><p id="2aea" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每个帖子都有一个唯一的可读标识符，称为“slug”，默认情况下由帖子标题自动生成。我们刚刚创建的两个帖子的slugs分别是“我的第一个测试帖子”和“我的第二个测试帖子”。我们将在MVC控制器中使用这些来处理路由到适当的post。</p><p id="41a7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们的MVC应用程序中，我们首先需要安装<a class="ae ko" href="https://www.nuget.org/packages/ButterCMS/" rel="noopener ugc nofollow" target="_blank"> ButterCMS NuGet包</a>。这个包包含我们将用来与API通信的客户端。</p><p id="2d19" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">安装完这个包之后，让我们制作一个新的MVC控制器，我们将使用它来呈现博客文章:</p><pre class="lx ly lz ma fq mb lv mc md aw me dt"><span id="7801" class="mf kq hu lv b fv mg mh l mi mj">using ButterCMS;<br/>using System.Threading.Tasks;<br/>using System.Web.Mvc;<br/>using System.Net;</span><span id="5208" class="mf kq hu lv b fv mk mh l mi mj">namespace MyApp.Controllers <br/>{<br/>  public class BlogController : Controller <br/>  {<br/>    private static string _apiToken = "{your_api_token}";</span><span id="2946" class="mf kq hu lv b fv mk mh l mi mj">    private ButterCmsClient _client;</span><span id="4798" class="mf kq hu lv b fv mk mh l mi mj">    public BlogController() <br/>    {<br/>      _client = new ButterCMSClient(_apiToken);<br/>    }<br/>  }<br/>}</span></pre><p id="73ea" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这将创建一个新的ButterCMS客户端，它被配置为从我们刚刚创建的ButterCMS帐户获取内容。现在，让我们创建一个简单的路线，并获取我们的邮件。</p><pre class="lx ly lz ma fq mb lv mc md aw me dt"><span id="df65" class="mf kq hu lv b fv mg mh l mi mj">public class BlogController : Controller <br/>{<br/>  /// ...</span><span id="ce2d" class="mf kq hu lv b fv mk mh l mi mj">  [Route("blog/{slug}")]<br/>  public async Task&lt;ActionResult&gt; ShowPost(string slug) <br/>  {<br/>    var response = await Client.RetrievePostAsync(slug);<br/>    ViewBag.Post = response.Data;<br/>    return View("Post");<br/>  }<br/>}</span></pre><p id="d6a9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这将根据我们通过URL传递的slug为我们获取一篇博客文章的内容。因此，如果我们启动应用程序并导航到<code class="eh ls lt lu lv b">http://{my_app_host}/blog/my-first-test-post</code>，我们将获取我们写的第一篇文章的内容。</p><p id="760c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">显然这是不完整的——我们还没有制作一个“Post”视图模板来呈现。让我们现在就开始吧:</p><pre class="lx ly lz ma fq mb lv mc md aw me dt"><span id="cbb0" class="mf kq hu lv b fv mg mh l mi mj">&lt;h2&gt;@ViewBag.Post.Title&lt;/h2&gt;</span><span id="d0de" class="mf kq hu lv b fv mk mh l mi mj">@Html.Raw(ViewBag.Post.Body)</span></pre><p id="b5e4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这只是呈现文章的标题和正文内容。我们应该总是使用<code class="eh ls lt lu lv b">@Html.Raw()</code>来呈现文章内容，因为ButterCMS使用HTML标签进行格式化，无论是手动还是使用其内置的WYSIWYG编辑器。</p><p id="0043" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就是这样！很简单。API客户端有其他方法来列出和分页文章，按作者或类别获取文章，等等。，但它们都像上面的例子一样容易使用。</p><p id="118b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="lw">本文原载于ButterCMS博客上的</em><a class="ae ko" href="https://buttercms.com/blog/options-for-adding-a-blog-to-an-existing-dot-net-web-app" rel="noopener ugc nofollow" target="_blank"><em class="lw"/></a><em class="lw">。ButterCMS是一个</em> <a class="ae ko" href="https://buttercms.com/api-first-cms/" rel="noopener ugc nofollow" target="_blank"> <em class="lw">托管的API-first CMS </em> </a> <em class="lw">和</em> <a class="ae ko" href="https://buttercms.com/blog-engine/" rel="noopener ugc nofollow" target="_blank"> <em class="lw">博客引擎</em> </a> <em class="lw">让您使用任何编程语言构建基于CMS的应用程序，包括</em><a class="ae ko" href="https://buttercms.com/ruby-cms" rel="noopener ugc nofollow" target="_blank"><em class="lw">Ruby</em></a><em class="lw">、</em><a class="ae ko" href="https://buttercms.com/rails-blog-engine/" rel="noopener ugc nofollow" target="_blank"><em class="lw">Rails</em></a><em class="lw">、</em> <a class="ae ko" href="https://buttercms.com/nodejs-cms" rel="noopener ugc nofollow" target="_blank"> <em class="lw"> Node.jsNET </em> </a> <em class="lw">，</em><a class="ae ko" href="https://buttercms.com/python-cms" rel="noopener ugc nofollow" target="_blank"><em class="lw">Python</em></a><em class="lw">，</em><a class="ae ko" href="https://buttercms.com/react-cms" rel="noopener ugc nofollow" target="_blank"><em class="lw">React</em></a><em class="lw">，</em><a class="ae ko" href="https://buttercms.com/angular-cms" rel="noopener ugc nofollow" target="_blank"><em class="lw">Angular</em></a><em class="lw">，</em><a class="ae ko" href="https://buttercms.com/php-cms" rel="noopener ugc nofollow" target="_blank"><em class="lw">PHP</em></a><em class="lw">，</em><a class="ae ko" href="https://buttercms.com/laravel-cms" rel="noopener ugc nofollow" target="_blank"><em class="lw">Laravel</em></a></p><div class="lx ly lz ma fq ab cb"><figure class="ml iv mm mn mo mp mq paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="ml iv mm mn mo mp mq paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="ml iv mm mn mo mp mq paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mr ms mt"><p id="f922" class="jc jd lw je b jf jg jh ji jj jk jl jm mu jo jp jq mv js jt ju mw jw jx jy jz hn dt translated"><a class="ae ko" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ko" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ko" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ko" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd lw je b jf jg jh ji jj jk jl jm mu jo jp jq mv js jt ju mw jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ko" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ko" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mx"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="my mz l"/></div></figure></div></div>    
</body>
</html>