<html>
<head>
<title>Why You Shouldn’t Use ‘var’ Anymore</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么不应该再使用“var”</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/why-you-shouldnt-use-var-anymore-f109a58b9b70?source=collection_archive---------0-----------------------#2016-10-17">https://medium.com/hackernoon/why-you-shouldnt-use-var-anymore-f109a58b9b70?source=collection_archive---------0-----------------------#2016-10-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="602f" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">以及'<code class="eh jj jk jl jm b">let’</code>如何解决一个常见的JavaScript“gotcha”…</h2></div><figure class="jo jp jq jr fq js fe ff paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="fe ff jn"><img src="../Images/e5976211ca3e4303d297e9d39afa449e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_w57I_pvH1qr6BNi_pR9mw.png"/></div></div></figure><p id="5b9c" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我使用ES2015 (ES6)语法编写JavaScript已经有一段时间了，并且已经开始欣赏许多优雅和简单的语言变化。我适应的第一个也是最容易的变化之一是使用<code class="eh jj jk jl jm b">let</code> / <code class="eh jj jk jl jm b">const</code>而不是<code class="eh jj jk jl jm b">var</code>。然而，我认为<code class="eh jj jk jl jm b">let</code>比<code class="eh jj jk jl jm b">var</code>提供的好处理所当然；它不仅仅是一个华丽的新语法，而是提供了一个重要的作用域机制。</p><blockquote class="kv"><p id="1716" class="kw kx hu bd ky kz la lb lc ld le ku ek translated">我认为<code class="eh jj jk jl jm b">let</code>比<code class="eh jj jk jl jm b">var...</code>提供的好处是理所当然的</p></blockquote><p id="24d2" class="pw-post-body-paragraph jz ka hu kb b kc lf iv ke kf lg iy kh ki lh kk kl km li ko kp kq lj ks kt ku hn dt translated">首先值得注意的是，我声明的绝大多数变量最适合使用 <code class="eh jj jk jl jm b"><em class="lk">const</em></code>而不是<code class="eh jj jk jl jm b">let</code> / <code class="eh jj jk jl jm b">var</code>。这是因为在声明之后，如果试图改变它的值，那么<code class="eh jj jk jl jm b">const</code>将抛出一个错误，这是一个防止意外突变的有用特性。然而，经常需要一个可变变量，特别是在循环场景中作为计数器。但是在这些情况下，如果它们都提供了所需的基本可变性，为什么要使用<code class="eh jj jk jl jm b">let</code>而不是<code class="eh jj jk jl jm b">var</code>?</p><p id="1397" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">简单的答案是<code class="eh jj jk jl jm b"><strong class="kb hv">let</strong></code> <strong class="kb hv">提供了函数作用域<code class="eh jj jk jl jm b">var</code>所没有的块作用域</strong>。这个解释显然需要一个实际的例子。请允许我用一个经典的前端工程面试问题来展示这一重要区别:</p><p id="aa69" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在本例中，控制台中将打印什么内容？</p><pre class="jo jp jq jr fq ll jm lm ln aw lo dt"><span id="64d1" class="lp lq hu jm b fv lr ls l lt lu">var callbacks = [];<br/>(function() {<br/>  for (var i = 0; i &lt; 5; i++) {<br/>    callbacks.push( function() { return i; } );<br/>  }<br/>})();</span><span id="db13" class="lp lq hu jm b fv lv ls l lt lu">console.log(callbacks.map( function(cb) { return cb(); } ));</span></pre><p id="7dc5" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在这个例子中，我们循环了5次，每次都将一个函数推入到<code class="eh jj jk jl jm b">callback</code>数组中。在用5个函数填充数组后，我们运行每个函数，将它们的结果记录到控制台。一个新手工程师可能会(错误地)回答结果是<code class="eh jj jk jl jm b">[0, 1, 2, 3, 4]</code>，<em class="lk">一个合理的分析，但是却成为了JavaScript“提升”陷阱</em>的牺牲品。</p><figure class="jo jp jq jr fq js fe ff paragraph-image"><div class="fe ff lw"><img src="../Images/21a89e5746e81de35a5f53ea50482364.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*8Fu7Zf7FToKMRUIMSqkSXw.gif"/></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">Don’t be a victim. Avoid the hoisting trap with ‘let’!</figcaption></figure><p id="b5a0" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">正确答案实际上是<code class="eh jj jk jl jm b">[5, 5, 5, 5, 5]</code>，当您考虑吊装在幕后做什么时，这是有意义的:</p><pre class="jo jp jq jr fq ll jm lm ln aw lo dt"><span id="8304" class="lp lq hu jm b fv lr ls l lt lu">var callbacks = [];<br/>(function() {<br/>  <strong class="jm hv">var i;</strong><br/>  for (<strong class="jm hv">i</strong> = 0; i &lt; 5; i++) {<br/>    callbacks.push( function() { return i; } );<br/>  }<br/>})();</span><span id="529c" class="lp lq hu jm b fv lv ls l lt lu">console.log(callbacks.map( function(cb) { return cb(); } ));</span></pre><p id="b946" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">请注意JavaScript如何将变量声明提升到函数块的顶部，导致在每个回调函数执行时,<code class="eh jj jk jl jm b">i</code>的值为<code class="eh jj jk jl jm b">5</code>,因为在调用这些函数之前,<code class="eh jj jk jl jm b">for</code>循环已经完全递增。</p><p id="43d2" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">有很多方法可以经典地解决这个问题，让脚本将<code class="eh jj jk jl jm b">[0, 1, 2, 3, 4]</code>记录到控制台，但是<code class="eh jj jk jl jm b">let</code>给了我们一个非常简单的解决方案:</p><pre class="jo jp jq jr fq ll jm lm ln aw lo dt"><span id="bea1" class="lp lq hu jm b fv lr ls l lt lu">var callbacks = [];<br/>(function() {<br/>  for (<strong class="jm hv">let</strong> i = 0; i &lt; 5; i++) {<br/>    callbacks.push( function() { return i; } );<br/>  }<br/>})();</span><span id="2c9b" class="lp lq hu jm b fv lv ls l lt lu">console.log(callbacks.map( function(cb) { return cb(); } ));</span></pre><p id="32de" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">就是这样— <strong class="kb hv">只需将</strong> <code class="eh jj jk jl jm b"><strong class="kb hv">var</strong></code> <strong class="kb hv">替换为</strong> <code class="eh jj jk jl jm b"><strong class="kb hv">let</strong></code>，示例就可以正常工作了！这要归功于<code class="eh jj jk jl jm b">let</code>的块范围行为。<code class="eh jj jk jl jm b"><em class="lk">let</em></code> <em class="lk">没有被提升到函数范围的顶部，而是停留在循环</em>的块范围内，导致每次迭代都有一个单独的<code class="eh jj jk jl jm b">i</code>实例。</p><p id="224d" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">那么，你应该使用<code class="eh jj jk jl jm b">var</code>吗？正如你可能已经从这篇文章的标题中推断出的，我认为你不应该使用 <code class="eh jj jk jl jm b"><strong class="kb hv">var</strong></code>。从技术上来说，<code class="eh jj jk jl jm b">var</code>在您希望维护函数作用域而不是块作用域的情况下仍然有用，但是我坚信，如果您需要依靠不直观的提升来让您的脚本工作，您会遇到更大的问题😜。</p><p id="b059" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><strong class="kb hv">更新:</strong>针对读者提出的两个最常见的讨论点:</p><ol class=""><li id="fa2d" class="mb mc hu kb b kc kd kf kg ki md km me kq mf ku mg mh mi mj dt translated">诚然<code class="eh jj jk jl jm b">const</code>并不是<em class="lk">真正的</em>不可改变。例如:</li></ol><pre class="jo jp jq jr fq ll jm lm ln aw lo dt"><span id="7cd7" class="lp lq hu jm b fv lr ls l lt lu">const myNotQuiteImmutableObject = {<br/>  thisCanBeChanged: "not immutable"<br/>};</span><span id="0883" class="lp lq hu jm b fv lv ls l lt lu">myNotQuiteImmutableObject.thisCanBeChanged = "see I changed it.";</span></pre><p id="8f07" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">然而，这仍然阻止了基本突变，例如:</p><pre class="jo jp jq jr fq ll jm lm ln aw lo dt"><span id="0846" class="lp lq hu jm b fv lr ls l lt lu">const immutableString = "you can't change me";</span><span id="925c" class="lp lq hu jm b fv lv ls l lt lu">immutableString = "D'OH!"; // error</span></pre><p id="7d0c" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如果你需要真正的不变性，去看看脸书优秀的不可变库。</p><p id="781d" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">2.<code class="eh jj jk jl jm b">{mySuperAncientBrowser}</code>中不支持<code class="eh jj jk jl jm b">let</code>这是真的，甚至<a class="ae mk" href="http://caniuse.com/#feat=let" rel="noopener ugc nofollow" target="_blank">有些近的浏览器仍然不支持</a> <code class="eh jj jk jl jm b"><a class="ae mk" href="http://caniuse.com/#feat=let" rel="noopener ugc nofollow" target="_blank">let</a></code>。这有一个显而易见的简单解决方案:使用<a class="ae mk" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank">巴别塔</a>。Babel将允许您使用JavaScript的所有最好和最新的特性，然后转换成一个即使简单的旧IE8也能理解的词汇表(有一些例外)。</p><div class="jo jp jq jr fq ab cb"><figure class="ml js mm mn mo mp mq paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="ml js mm mn mo mp mq paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="ml js mm mn mo mp mq paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mr ms mt"><p id="f922" class="jz ka lk kb b kc kd iv ke kf kg iy kh mu kj kk kl mv kn ko kp mw kr ks kt ku hn dt translated"><a class="ae mk" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae mk" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae mk" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae mk" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jz ka lk kb b kc kd iv ke kf kg iy kh mu kj kk kl mv kn ko kp mw kr ks kt ku hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae mk" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae mk" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jo jp jq jr fq js fe ff paragraph-image"><a href="https://goo.gl/Ahtev1"><div class="fe ff mx"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></a></figure></div></div>    
</body>
</html>