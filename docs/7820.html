<html>
<head>
<title>Function Composition with Lodash</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">含Lodash的函数组合</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/function-composition-with-lodash-d30eb50153d1?source=collection_archive---------4-----------------------#2017-11-09">https://medium.com/hackernoon/function-composition-with-lodash-d30eb50153d1?source=collection_archive---------4-----------------------#2017-11-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div class="ab fr cl iv"><img src="../Images/0ddfa42e98623547b528146159217e0c.png" data-original-src="https://miro.medium.com/v2/format:webp/1*oCtk28IdNdpjnyMGiRsfLA.jpeg"/></div></figure><p id="f510" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">你最近在看JavaScript帖子吗？也许你已经注意到函数式编程现在非常流行。这是一种非常强大的编程方式，但是一开始就让人不知所措。谢天谢地，最受欢迎的NPM软件包(这个月有4800万次下载)有一个非常有用的函数式编程软件包来帮助我们开始！</p><p id="058e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在这篇文章中，我们将看看如何使用Lodash/fp来组合我们自己的函数，以及你今天可能已经在使用的Lodash函数！</p><p id="19af" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在我们开始编码之前——让我们确保我们知道我们在谈论什么！</p><h2 id="21c3" class="jw jx hu bd jy jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq dt translated">函数式编程:</h2><blockquote class="kr ks kt"><p id="6a32" class="iy iz ku ja b jb jc jd je jf jg jh ji kv jk jl jm kw jo jp jq kx js jt ju jv hn dt translated">一种编程方法，侧重于使用函数作为一级变量。它避免突变(改变)数据，并试图将应用程序视为一个线性流程，将功能拼凑成一个整体。</p></blockquote><h2 id="c30e" class="jw jx hu bd jy jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq dt translated">功能组成:</h2><blockquote class="kr ks kt"><p id="724b" class="iy iz ku ja b jb jc jd je jf jg jh ji kv jk jl jm kw jo jp jq kx js jt ju jv hn dt translated">按顺序调用已经列出的函数，将每个函数的结果传递给列表中的下一个函数，然后将最终的函数结果作为整体的结果返回。</p></blockquote><p id="de81" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">通常当你编写函数时，你可以这样做(不知道你正在编写):</p><pre class="ky kz la lb fq lc ld le lf aw lg dt"><span id="60a6" class="jw jx hu ld b fv lh li l lj lk">const myResult = myFunction(myOtherFunction(myData));</span></pre><p id="85cc" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在这个例子中，你给<code class="eh ll lm ln ld b">myFunction</code>的结果是<code class="eh ll lm ln ld b">myOtherFunction</code>的唯一参数。请注意，这些函数将从右向左调用，或者从内向外调用。我们对函数组合做了类似的事情。</p><pre class="ky kz la lb fq lc ld le lf aw lg dt"><span id="c2ab" class="jw jx hu ld b fv lh li l lj lk">const getMyResult = compose(<br/>  myFunction,<br/>  myOtherFunction,<br/>);<br/>const myResult = getMyResult(myData);</span></pre><p id="5f4c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了让事情更清楚，我想为我们的复合函数定义几个目标。</p><ul class=""><li id="77ab" class="lo lp hu ja b jb jc jf jg jj lq jn lr jr ls jv lt lu lv lw dt translated">它们将有单一的输入和输出。</li><li id="5738" class="lo lp hu ja b jb lx jf ly jj lz jn ma jr mb jv lt lu lv lw dt translated">它们不会有副作用。</li><li id="fdba" class="lo lp hu ja b jb lx jf ly jj lz jn ma jr mb jv lt lu lv lw dt translated">当链接在一起时，它们可以作为一组数据上的单个“动作”来使用。</li></ul></div><div class="ab cl mc md hc me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hn ho hp hq hr"><h2 id="8d20" class="jw jx hu bd jy jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq dt translated">Lodash/fp</h2><p id="fbe1" class="pw-post-body-paragraph iy iz hu ja b jb mj jd je jf mk jh ji jj ml jl jm jn mm jp jq jr mn jt ju jv hn dt translated">为了实现这些目标，我们将使用Lodash库的子集Lodash/fp。函数式编程的“Fp”。当你安装Lodash的时候，这个包已经被安装了！唯一的区别是函数变成了不可变的、自动定制的、迭代优先的和数据最后的。</p><p id="a74c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">那是什么意思？</p><ul class=""><li id="f5fb" class="lo lp hu ja b jb jc jf jg jj lq jn lr jr ls jv lt lu lv lw dt translated"><strong class="ja hv">不可变</strong>:函数不会改变它们的任何参数。</li><li id="e82b" class="lo lp hu ja b jb lx jf ly jj lz jn ma jr mb jv lt lu lv lw dt translated"><strong class="ja hv">自动定制</strong>:传入的参数比函数接受的少，只会返回另一个函数。该函数需要其余的参数。</li><li id="43a7" class="lo lp hu ja b jb lx jf ly jj lz jn ma jr mb jv lt lu lv lw dt translated">迭代优先(iterate-first):通常情况下，你将对数据做什么作为最后一个参数来传递。想想数组函数。你最后传入回调。在FP中，你首先传入它！</li><li id="b947" class="lo lp hu ja b jb lx jf ly jj lz jn ma jr mb jv lt lu lv lw dt translated"><strong class="ja hv"> Data-last </strong>:函数最不期望的就是数据。因为它是可定制的，这允许你定义函数要做什么，把它赋给一个变量，然后在一个组合函数中(或单独)给它数据。</li><li id="8204" class="lo lp hu ja b jb lx jf ly jj lz jn ma jr mb jv lt lu lv lw dt translated"><strong class="ja hv">回调/迭代的参数</strong>被封顶(通常只到第一个参数)。这避免了像<code class="eh ll lm ln ld b">parseInt </code>这样有可选额外参数的函数的副作用。请注意，这并不意味着函数本身只能有一个参数。</li></ul><p id="68af" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所有这些现在看起来都很混乱。所以让我们来看一个代码示例！</p></div><div class="ab cl mc md hc me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hn ho hp hq hr"><h2 id="a081" class="jw jx hu bd jy jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq dt translated">问题:</h2><p id="743f" class="pw-post-body-paragraph iy iz hu ja b jb mj jd je jf mk jh ji jj ml jl jm jn mm jp jq jr mn jt ju jv hn dt translated">您正在构建一个向用户显示联系信息的网页。企业规定联系人必须按名字排序，过滤掉没有电话号码的联系人，联系人可能被添加了两次，因此只应显示唯一的联系人号码，号码的格式必须像<code class="eh ll lm ln ld b">(xxx)xxx-xxxx</code>一样。</p><p id="31d0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">联系对象看起来像这样:</p><pre class="ky kz la lb fq lc ld le lf aw lg dt"><span id="9a1d" class="jw jx hu ld b fv lh li l lj lk">{<br/>  firstName: 'justin',<br/>  lastName: 'fuller',<br/>  phone: '1234568490'<br/>}</span></pre><h2 id="2cbc" class="jw jx hu bd jy jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq dt translated">命令式版本:</h2><pre class="ky kz la lb fq lc ld le lf aw lg dt"><span id="cafb" class="jw jx hu ld b fv lh li l lj lk">import _ from 'lodash';<br/>const data = [ /* data in here */ ];</span><span id="7c2d" class="jw jx hu ld b fv mo li l lj lk">const sorted = _.sortBy(data, 'firstName');</span><span id="ef23" class="jw jx hu ld b fv mo li l lj lk">const filtered = _.filter(sorted, 'phone');</span><span id="2572" class="jw jx hu ld b fv mo li l lj lk">const unique = _.uniqBy(filtered, 'phone');</span><span id="586c" class="jw jx hu ld b fv mo li l lj lk">const formatPhone = c =&gt; ({<br/>  ...c,<br/>  phone: `(${c.phone.slice(0, 2)})${c.phone.slice(3, 5)-${c.phone.slice(6)}}`<br/>});</span><span id="fda7" class="jw jx hu ld b fv mo li l lj lk">const formatted = _.map(unique, formatPhone);</span><span id="5e35" class="jw jx hu ld b fv mo li l lj lk">console.log(formatted);</span></pre><h2 id="c9f3" class="jw jx hu bd jy jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq dt translated">命令式版本2:</h2><pre class="ky kz la lb fq lc ld le lf aw lg dt"><span id="00a2" class="jw jx hu ld b fv lh li l lj lk">import _ from 'lodash';<br/>const data = [ /* data here */ ];</span><span id="342d" class="jw jx hu ld b fv mo li l lj lk">const formatPhone = c =&gt; ({<br/>  ...c,<br/>  phone: `(${c.phone.slice(0, 2)})${c.phone.slice(3, 5)-${c.phone.slice(6)}}`<br/>});</span><span id="714a" class="jw jx hu ld b fv mo li l lj lk">const formatted = _.map(<br/>  _.uniqBy(<br/>    _.filter(<br/>      _.sortBy(data, 'firstName')<br/>      'phone',    <br/>    ), <br/>    'phone',  <br/>  ),<br/>  formatPhone,<br/>);</span><span id="e4e9" class="jw jx hu ld b fv mo li l lj lk">console.log(formatted);</span></pre><h2 id="636f" class="jw jx hu bd jy jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq dt translated">功能版本:</h2><pre class="ky kz la lb fq lc ld le lf aw lg dt"><span id="7f10" class="jw jx hu ld b fv lh li l lj lk">import fp from ‘lodash/fp’;<br/>const data = [ /* data here **/ ];</span><span id="68d7" class="jw jx hu ld b fv mo li l lj lk">const formatPhone = c =&gt; ({<br/>  ...c,<br/>  phone: `(${c.phone.slice(0, 2)})${c.phone.slice(3, 5)-${c.phone.slice(6)}}`<br/>});</span><span id="d875" class="jw jx hu ld b fv mo li l lj lk">const formatData = fp.compose(<br/>  fp.map(formatPhone),<br/>  fp.uniqBy('phone'),<br/>  fp.filter('phone'),<br/>  fp.sortBy('firstName'),<br/>);</span><span id="8dd6" class="jw jx hu ld b fv mo li l lj lk">console.log(formatData(data));</span></pre><p id="91ce" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">那些喜欢函数式编程的人会告诉你，最后一个版本更具声明性。它不是告诉你<em class="ku">这个函数如何工作，而是告诉你<em class="ku">它做了什么</em>！</em></p><p id="bcbf" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">因此，让我们通过代码的每一步来解开它做什么。</p><ul class=""><li id="699f" class="lo lp hu ja b jb jc jf jg jj lq jn lr jr ls jv lt lu lv lw dt translated">fp.compose —一个接受任意数量的函数作为参数的函数。然后它从右到左调用它们，就像当你把它们作为参数传递时调用函数一样。</li><li id="4cdf" class="lo lp hu ja b jb lx jf ly jj lz jn ma jr mb jv lt lu lv lw dt translated">Fp。SortBy、uniqBy、filter和map都最后接受数据。因此，首先我们告诉函数排序、过滤和映射的依据，然后它接受数据并返回结果。</li><li id="37e0" class="lo lp hu ja b jb lx jf ly jj lz jn ma jr mb jv lt lu lv lw dt translated">当我们用数据调用formatData时，它获取每个函数的结果，并将其传递给下一个函数。最后一个函数的结果是整个链的结果。</li></ul></div><div class="ab cl mc md hc me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hn ho hp hq hr"><p id="6e2c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们已经看到了Lodash函数式编程的强大表达能力，我想探索更多的问题。您将开始看到这是多么容易，并且希望您将看到这种编程风格带来的安全性！</p><h2 id="dac2" class="jw jx hu bd jy jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq dt translated">应用组合</h2><p id="310b" class="pw-post-body-paragraph iy iz hu ja b jb mj jd je jf mk jh ji jj ml jl jm jn mm jp jq jr mn jt ju jv hn dt translated">合成不仅限于处理数据。一个完整的应用程序可以通过许多更小的功能组合在一起。</p><p id="1110" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们做一个心理练习:思考一个应用程序的步骤。</p><ul class=""><li id="bab8" class="lo lp hu ja b jb jc jf jg jj lq jn lr jr ls jv lt lu lv lw dt translated">检索任何初始配置(环境变量、命令行参数)，然后打包成一个可重用的对象。</li><li id="c19d" class="lo lp hu ja b jb lx jf ly jj lz jn ma jr mb jv lt lu lv lw dt translated">导入任何第三方依赖项。</li><li id="26f0" class="lo lp hu ja b jb lx jf ly jj lz jn ma jr mb jv lt lu lv lw dt translated">使用配置和依赖项来引导应用程序。</li><li id="35d1" class="lo lp hu ja b jb lx jf ly jj lz jn ma jr mb jv lt lu lv lw dt translated">实例化路线，服务，组件，无论它是什么应用程序。</li></ul><p id="6489" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">你能看出这个例子或者其他例子是如何串联起来的吗？你看到消除副作用的好处了吗？</p><p id="a314" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在这一点上，你很有希望开始使用composition和Lodash/fp来解决问题，所以下面我会包含一个fp文档的链接。使用它来了解如何在函数/组合风格中使用您最喜欢的Lodash方法！</p><div class="mp mq fm fo mr ms"><a href="https://github.com/lodash/lodash/wiki/FP-Guide" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab ej"><div class="mu ab mv cl cj mw"><h2 class="bd hv fv z el mx eo ep my er et ht dt translated">洛达什/洛达什</h2><div class="mz l"><h3 class="bd b fv z el mx eo ep my er et ek translated">lodash——一个现代的JavaScript实用程序库，提供模块化、高性能和额外功能。</h3></div><div class="na l"><p class="bd b gc z el mx eo ep my er et ek translated">github.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng iw ms"/></div></div></a></div></div><div class="ab cl mc md hc me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hn ho hp hq hr"><p id="63ab" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">嗨，我是贾斯汀·富勒。很高兴你看了我的帖子！我需要让你知道，我在这里写的一切都是我自己的观点，并不代表我的雇主。所有代码样本都是我自己的，与美国银行的代码完全无关。</p><p id="5c8a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我也很乐意收到您的来信，请随时通过<a class="ae nh" href="https://www.linkedin.com/in/justin-fuller-8726b2b1/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>、<a class="ae nh" href="https://github.com/justindfuller" rel="noopener ugc nofollow" target="_blank"> Github </a>或<a class="ae nh" rel="noopener" href="/@justindanielfuller"> Medium </a>与我联系。再次感谢阅读！</p></div></div>    
</body>
</html>