<html>
<head>
<title>Generating a Single-Include C++ Header File Using Buck</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Buck生成单包含C++头文件</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/generating-a-single-include-c-header-file-using-buck-827f20be3f9d?source=collection_archive---------8-----------------------#2017-10-12">https://medium.com/hackernoon/generating-a-single-include-c-header-file-using-buck-827f20be3f9d?source=collection_archive---------8-----------------------#2017-10-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="f33b" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">TL；速度三角形定位法(dead reckoning)</h1><p id="bc59" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">使用<a class="ae kn" href="https://buckbuild.com/" rel="noopener ugc nofollow" target="_blank"> Buck </a>为你的库生成一个单包含头文件。这为您的用户提供了一个快速开发的选项，可以在以后进行优化。看看GitHub 上的一个<a class="ae kn" href="https://github.com/njlr/buck-single-header" rel="noopener ugc nofollow" target="_blank">工作实例。</a></p><h1 id="3eb1" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">介绍</h1><p id="0647" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">C++库中的一个常见模式是提供一个头文件，其中包含该库中所有其他的头文件。</p><p id="979f" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">例如，假设我们有一个带有这些头的库:</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="7d6e" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">要使用这个库，我们需要包含我们需要的每个头文件:</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="9669" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">或者，库设计者可以提供一个单包含头，为我们完成所有这些工作:</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">mathutils.hpp</figcaption></figure><p id="0779" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">用户所要做的就是包含这个标题:</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><h2 id="73db" class="le is hu bd it lf lg lh ix li lj lk jb ka ll lm jf ke ln lo jj ki lp lq jn lr dt translated">警告</h2><p id="6895" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">这种方法当然更方便，但也有一些缺点。</p><p id="4076" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">首先，单包含头可能会增加编译时间。如果我们只使用来自<code class="eh ls lt lu lv b">add.hpp</code>的定义，那么包含<em class="lw">的所有内容</em>将需要解析器和预处理器做更多不必要的工作。</p><p id="ba57" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">第二，它掩盖了你实际上所依赖的头文件。例如，在检查包含图以更好地理解项目时，这会造成混乱。</p><p id="e8b0" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">所以这是两个大的缺点，但是如果你仍然在迭代你的代码，使用单包含可能是一个好主意。为什么要在确定需要哪些标题之前优化你的includes呢？</p><h1 id="3756" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">履行</h1><p id="1e85" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">好的，作为一个库设计者，提供一个单包含头可能是一个好主意，但是我们怎样才能生成一个呢？</p><p id="fd6b" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated"><a class="ae kn" href="https://buckbuild.com/" rel="noopener ugc nofollow" target="_blank">巴克建立</a>可以在这里帮助我们。如果您不熟悉它，Buck是来自脸书的高性能构建系统。与其他解决方案相比，使用降压构建的优势在于:</p><ul class=""><li id="9d35" class="lx ly hu jr b js ko jw kp ka lz ke ma ki mb km mc md me mf dt translated">构建是可复制的</li><li id="342e" class="lx ly hu jr b js mg jw mh ka mi ke mj ki mk km mc md me mf dt translated">构建工件可以被缓存和共享</li><li id="8f6f" class="lx ly hu jr b js mg jw mh ka mi ke mj ki mk km mc md me mf dt translated">巴克是跨平台的</li><li id="e04d" class="lx ly hu jr b js mg jw mh ka mi ke mj ki mk km mc md me mf dt translated">它作用于哈希，而不是时间戳，这样可以防止不必要的重建</li><li id="fc10" class="lx ly hu jr b js mg jw mh ka mi ke mj ki mk km mc md me mf dt translated">还有更多…</li></ul><div class="ml mm fm fo mn mo"><a href="https://hackernoon.com/7-reasons-to-use-buck-build-5b44d7413585" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab ej"><div class="mq ab mr cl cj ms"><h2 class="bd hv fv z el mt eo ep mu er et ht dt translated">使用降压构建的7个理由</h2><div class="mv l"><h3 class="bd b fv z el mt eo ep mu er et ek translated">Buck是一个跨平台、跨语言构建系统，在脸书为大规模编译而设计。所有牛仔…</h3></div><div class="mw l"><p class="bd b gc z el mt eo ep mu er et ek translated">hackernoon.com</p></div></div></div></a></div><p id="8ee8" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">Buck构建脚本是用Python编写的，所以我们可以利用Python的list和dictionary函数来生成头。让我们开始吧…</p><p id="1659" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated"><em class="lw">如果你只是想直奔一个工作实例，那就看看</em><a class="ae kn" href="https://github.com/njlr/buck-single-header" rel="noopener ugc nofollow" target="_blank"><em class="lw">GitHub repo</em></a><em class="lw">。</em></p><p id="810f" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">首先，我们需要获取库中所有的头文件。Buck为此提供了一个有用的效用函数，称为<code class="eh ls lt lu lv b">subdir_glob</code>。</p><p id="d264" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">假设这种文件布局…</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="9a05" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">还有这个剧本…</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="7193" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">…输出将是:</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="dfd4" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">一旦我们有了头文件映射，我们需要把它转换成C++头文件。这在Python中相当容易:</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">Python’s join function is weird!</figcaption></figure><p id="7f24" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">然后，我们需要创建一个<code class="eh ls lt lu lv b">genrule</code>，它接受<code class="eh ls lt lu lv b">single_header</code>字符串并将其写入一个文件:</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="7b3d" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">最后一步是将<code class="eh ls lt lu lv b">genrule</code>的输出作为头部包含在我们的<code class="eh ls lt lu lv b">cxx_library</code>中。幸运的是，Buck允许我们通过规则的名称来处理规则的输出，从而简化了这一过程:</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="ad2c" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">然而，我们<em class="lw">也</em>想要包含未生成的头；我们需要合并这两本词典。Python没有为字典提供<code class="eh ls lt lu lv b">+</code>操作符，但是我们可以编写一个小函数来完成这项工作:</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="f1c8" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">因此，我们的<code class="eh ls lt lu lv b">mathutils</code>目标将是:</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="2b21" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">如果您构建库，那么您将在构建文件夹中看到生成的标题:</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="e419" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">这个解决方案最好的一点是它是自动的。如果您将一个<code class="eh ls lt lu lv b">.hpp</code>文件添加到<code class="eh ls lt lu lv b">include</code>文件夹，那么Buck会自动检测到这一点，并重新生成头文件。</p><h1 id="51ab" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">既然你在这里…</h1><p id="4c84" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我们创建了<a class="ae kn" href="https://github.com/LoopPerfect/buckaroo" rel="noopener ugc nofollow" target="_blank"> Buckaroo </a>来使集成C++库变得更容易。如果你想尝试一下，最好从文档开始。您可以在<a class="ae kn" href="https://buckaroo.pm/" rel="noopener ugc nofollow" target="_blank"> Buckaroo.pm </a>或<a class="ae kn" href="https://github.com/LoopPerfect/buckaroo-wishlist" rel="noopener ugc nofollow" target="_blank">上浏览现有套餐，并在愿望清单</a>上请求更多。</p><div class="ml mm fm fo mn mo"><a href="https://hackernoon.com/approaches-to-c-dependency-management-or-why-we-built-buckaroo-26049d4646e7" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab ej"><div class="mq ab mr cl cj ms"><h2 class="bd hv fv z el mt eo ep mu er et ht dt translated">C++依赖管理的方法，或者我们为什么要建立Buckaroo</h2><div class="mv l"><h3 class="bd b fv z el mt eo ep mu er et ek translated">C++是一种不寻常的语言，因为它还没有一个占主导地位的包管理器(我们正在努力！).结果是…</h3></div><div class="mw l"><p class="bd b gc z el mt eo ep mu er et ek translated">hackernoon.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc nd mo"/></div></div></a></div></div></div>    
</body>
</html>