<html>
<head>
<title>Firebase to the Rescue: Dynamic Routing via Hosting + Functions Integration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">救火基地:通过托管+功能集成实现动态路由</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/firebase-to-the-rescue-dynamic-routing-via-hosting-functions-integration-aef888ddf311?source=collection_archive---------6-----------------------#2017-06-30">https://medium.com/hackernoon/firebase-to-the-rescue-dynamic-routing-via-hosting-functions-integration-aef888ddf311?source=collection_archive---------6-----------------------#2017-06-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/5e235ae868d5536c2014ab7a1ead59a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hxRH_xOH2wdGahxVJEz9Ag.jpeg"/></div></div></figure><div class=""/><p id="7318" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这篇文章有点像回忆录，我在其中分享了让动态路由与Firebase一起工作的经验。要了解这是怎么回事，你应该熟悉他们的<a class="ae ka" href="https://firebase.google.com/docs/hosting/" rel="noopener ugc nofollow" target="_blank">主机</a>和<a class="ae ka" href="https://firebase.google.com/docs/functions/" rel="noopener ugc nofollow" target="_blank">功能</a>产品。我已经将所有重要的技术内容浓缩到了迷你教程中。如果你愿意阅读整篇文章，可以跳过这一部分。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><h1 id="86b6" class="ki kj if bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">TL；迷你博士教程</h1><p id="b740" class="pw-post-body-paragraph jc jd if je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">Firebase托管服务来自您的自定义域的静态文件。Firebase函数是通过难看的<code class="eh ll lm ln lo b">cloudfunctions.net</code>URL调用它们来执行的。截至谷歌IO 2017，他们现在合作得很好。在您的<code class="eh ll lm ln lo b">firebase.json</code>的<code class="eh ll lm ln lo b">hosting</code>配置中，您可以<code class="eh ll lm ln lo b">rewrite</code>自定义域上的任何特定路由来调用一个<code class="eh ll lm ln lo b">function</code>而不是服务一个静态页面。查看文件。</p><p id="7df3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了模拟像<code class="eh ll lm ln lo b">example.com/posts/123</code>这样的动态路线，我做了以下工作:创建一个名为<code class="eh ll lm ln lo b"><a class="ae ka" href="https://gist.github.com/pejalo/1715c896658d660e0ded0d49d9910896" rel="noopener ugc nofollow" target="_blank">post</a></code>的函数。设置<code class="eh ll lm ln lo b">firebase.json</code>让所有对<code class="eh ll lm ln lo b">/posts/**</code>的请求调用<code class="eh ll lm ln lo b">post</code>函数。该函数获取数据并返回预呈现的HTML<a class="ae ka" href="https://hackernoon.com/tagged/html" rel="noopener ugc nofollow" target="_blank"/>，其中包含所请求帖子的所有适当的社交和SEO元标签，以使爬虫感到满意并支持<a class="ae ka" rel="noopener" href="/slack-developer-blog/everything-you-ever-wanted-to-know-about-unfurling-but-were-afraid-to-ask-or-how-to-make-your-e64b4bb9254">展开</a>。</p><p id="d1c6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该页面还包括一个<a class="ae ka" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a> <code class="eh ll lm ln lo b">window.location</code>重定向片段，因此一个真实的用户被重定向到<code class="eh ll lm ln lo b">example.com/?post=123</code>。这个静态索引页面读取查询参数，显示包含文章内容的正确屏幕，并利用HTML5的<code class="eh ll lm ln lo b">replaceState()</code>将<code class="eh ll lm ln lo b">example.com/posts/123</code>放回浏览器的地址栏。面向所有人的无服务器动态路由！</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><h1 id="3678" class="ki kj if bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">❤燃烧基地</h1><p id="c28d" class="pw-post-body-paragraph jc jd if je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">Firebase单枪匹马地重新点燃了我与web开发的关系。我现在只需要担心前端，而不是为每个项目构建前端和后端。尽管Firebase的产品范围很广，但它仍然缺乏许多受欢迎的<a class="ae ka" href="https://medium.freecodecamp.com/firebase-the-great-the-meh-and-the-ugly-a07252fbcf15" rel="noopener ugc nofollow" target="_blank">功能</a>(如<a class="ae ka" rel="noopener" href="/google-cloud/firebase-search-a-bigger-boat-c85695546d02">搜索</a>，复杂数据库<a class="ae ka" href="https://stackoverflow.com/questions/26700924/query-based-on-multiple-where-clauses-in-firebase" rel="noopener ugc nofollow" target="_blank">查询</a>，洞察<a class="ae ka" href="https://startupsventurecapital.com/firebase-costs-increased-by-7-000-81dc0a27271d" rel="noopener ugc nofollow" target="_blank">使用</a>等)。但是我在这一点上太投入了，以至于我宁愿跳过几个圈来让Firebase工作，而不是回去自己建立一个基础后端，就好像我们仍然生活在前<a class="ae ka" href="http://parseplatform.org/" rel="noopener ugc nofollow" target="_blank">解析</a>时代一样。(没错，我们开发者就是懒。)</p><p id="2542" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">几周前，我在做一个产品搜索克隆，它有一个非常简单的需求:动态路由。像<code class="eh ll lm ln lo b">example.com/posts/123</code>一样，每篇文章都需要自己的网址在网络上分享。这些链接必须返回预先渲染的社会和搜索引擎优化元标签，以支持<a class="ae ka" rel="noopener" href="/slack-developer-blog/everything-you-ever-wanted-to-know-about-unfurling-but-were-afraid-to-ask-or-how-to-make-your-e64b4bb9254">展开</a>。</p><p id="9cd8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">到目前为止，我在Firebase上愉快地托管了所有东西，作为一个臭名昭著的<em class="lp">单页应用</em>，从客户端直接连接到数据库。但是有了这个新的预渲染需求，Firebase还不支持，看起来好像我必须将我们的域指向一个定制的VPS并自己托管站点。</p><p id="223d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以我花了一个周末的时间来学习关于<a class="ae ka" href="http://dokku.viewdocs.io/dokku/" rel="noopener ugc nofollow" target="_blank"> Dokku </a>(顺便说一下，这是一个很好的选择)，让我们的网站启动并运行，做一些负载测试，观察网站崩溃，搜索互联网试图找出原因，说服自己这个应用程序有内存泄漏，然后意识到我只需要一台内存更大的机器，bla bla bla一直希望我可以回到构建功能上来，停止处理这些开发运营的废话。</p><p id="dbfa" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">几天后，Firebase Slack团队中的某个人发布了一个<a class="ae ka" href="https://events.google.com/io/" rel="noopener ugc nofollow" target="_blank"> Google IO </a>直播。我调进来只是为了好玩，就在那里，我需要的确切功能被宣布:<a class="ae ka" href="https://firebase.google.com/docs/hosting/functions" rel="noopener ugc nofollow" target="_blank">主机+功能！</a>有了这种新的集成，开发人员可以在向客户端发送HTTP响应之前，在自定义域后面运行一些后端代码。几个小时后，我就有了生产中的动态路由，并可以将Dokku放回货架上。</p><h1 id="8afb" class="ki kj if bd kk kl lq kn ko kp lr kr ks kt ls kv kw kx lt kz la lb lu ld le lf dt translated">托管+功能</h1><p id="9eb5" class="pw-post-body-paragraph jc jd if je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">Firebase主机现在有了一个新的配置选项。在<code class="eh ll lm ln lo b">firebase.json</code>中，你可以指定所有的<a class="ae ka" href="https://firebase.google.com/docs/hosting/url-redirects-rewrites" rel="noopener ugc nofollow" target="_blank">托管行为</a>，比如缓存、重写、重定向等等，你可以<code class="eh ll lm ln lo b">rewrite</code>任何指向函数而不是静态文件的路径。这里有一个例子:</p><pre class="lv lw lx ly fq lz lo ma mb aw mc dt"><span id="b3fc" class="md kj if lo b fv me mf l mg mh">// firebase.json</span><span id="c8de" class="md kj if lo b fv mi mf l mg mh">{<br/>  "hosting": {<br/>    "public": "public",<br/>    "rewrites": [<br/>      { "source": "/posts/**", "function": "post" }<br/>    ]<br/>  }<br/>}</span></pre><p id="b5b5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有了这个配置，任何对<code class="eh ll lm ln lo b">example.com/posts/postidorhashorwhatever</code>的请求都将忽略你可能已经托管在那里的静态文件，而是调用你的<code class="eh ll lm ln lo b">post</code>函数。使用Express <a class="ae ka" href="https://expressjs.com/en/api.html#req" rel="noopener ugc nofollow" target="_blank"> Request </a>和<a class="ae ka" href="https://expressjs.com/en/api.html#res" rel="noopener ugc nofollow" target="_blank"> Response </a>对象调用该函数，通过这些对象可以发送任意HTTP响应。</p><p id="84c4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这让我们可以在返回客户端之前执行任何我们想要的逻辑！(只要它运行在Firebase的云功能节点环境中……)很好，您可能会想:我们可以返回任何内容，但是当网站被构建为静态页面时，我们如何返回显示适当帖子内容的整个网站页面呢？</p><p id="68f1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">事实是，我不知道。也许有一天，Webpack大师们会创建超级花哨的插件，将动态路由分成具有自己的部署配置的功能。谁知道他们下一步会想出什么。与此同时，我有一个不太复杂的解决方案，可以达到同样的效果。</p><h1 id="9ef5" class="ki kj if bd kk kl lq kn ko kp lr kr ks kt ls kv kw kx lt kz la lb lu ld le lf dt translated">重新寄送</h1><p id="98ec" class="pw-post-body-paragraph jc jd if je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">因为我们的函数可以返回任何东西，所以让它返回带有我们需要的任何特定于内容的社交和SEO元标签的有效HTML非常容易。这是我们页面中唯一真正需要预渲染以支持展开的部分。如果我们能让它返回一个HTML字符串，我们当然可以在其中包含一段JavaScript来帮助异步显示页面的其余部分。</p><p id="1633" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是我的<code class="eh ll lm ln lo b">post</code>函数的简化版本:</p><figure class="lv lw lx ly fq hw"><div class="bz el l di"><div class="mj mk l"/></div><figcaption class="ml mm fg fe ff mn mo bd b be z ek"><a class="ae ka" href="https://gist.github.com/pejalo/1715c896658d660e0ded0d49d9910896" rel="noopener ugc nofollow" target="_blank">Click here for the full version of this file</a></figcaption></figure><p id="ec05" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">可以看到，要发送的HTML响应包括<code class="eh ll lm ln lo b">'&lt;script&gt;window.location="<a class="ae ka" href="https://example.com/?post=" rel="noopener ugc nofollow" target="_blank">https://example.com/?post=</a>' + post.id + '";&lt;/script&gt;'</code>。一个只寻找你的元标签的爬虫会很高兴收到它们，不会费心去执行这个脚本。但是在浏览器中加载这个页面的真实用户会立即被重定向到<code class="eh ll lm ln lo b">example.com/?post=123</code>。</p><p id="8bb1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在<code class="eh ll lm ln lo b">example.com/?post=123</code>上到底发生了什么已经超出了本文的范围，因为它完全取决于您正在使用的前端框架。您只想显示文章内容，而不需要将浏览器重定向回<code class="eh ll lm ln lo b">/posts/123</code>。(我的网站是用<a class="ae ka" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue.js </a>构建的，所以在我的索引页面的<code class="eh ll lm ln lo b">beforeMount()</code>功能中我勾选了<code class="eh ll lm ln lo b">this.$route.query.post</code>。如果存在，我会在索引页面中显示请求的文章，而不触及路由。)需要知道的重要一点是，你可以<a class="ae ka" href="https://developer.mozilla.org/en-US/docs/Web/API/History_API" rel="noopener ugc nofollow" target="_blank">操纵</a>浏览器地址栏中显示的内容，使其看起来更漂亮。把难看的<code class="eh ll lm ln lo b">?post=123</code>换成<code class="eh ll lm ln lo b">/posts/123</code>，可以叫<code class="eh ll lm ln lo b">window.history.replaceState({}, ‘Title’, ‘/posts/’ + postId);</code>。</p><p id="7c6a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">瞧啊。除非用户强迫性地注意他们的地址栏，否则他们所知道的就是他们点击了一个链接，并最终出现在我们网站的正确页面上。</p><p id="a03d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">老实说，作为一个设计狂，这种双重重定向确实让我有点恼火。它不是闪闪发光的干净。但是这种情况只会发生在那些从其他来源通过像<code class="eh ll lm ln lo b">example.com/posts/123</code>这样的独立链接导航到我们网站的用户身上。从推荐网站跳到我们网站的不和谐体验掩盖了后台发生的快速重定向。</p><p id="5e84" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你知道什么比小小的重定向更肮脏吗？启动一个新的虚拟机，安装Ubuntu，添加你的SSH密钥，创建一个新的sudo用户，<code class="eh ll lm ln lo b">sudo apt-get update</code>等等，你明白了…</p><p id="be4d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Firebase FTW。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><p id="c915" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">坚持到最后学到了什么？留点爱💚</p><p id="9239" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="lp"> Peter LoBue是一名自由职业的UX设计师、网页开发人员和iOS开发人员，居住在费城和旧金山之间。伸手可得:</em> <a class="ae ka" href="https://twitter.com/pejalo" rel="noopener ugc nofollow" target="_blank"> <em class="lp"> @pejalo </em> </a></p><div class="lv lw lx ly fq ab cb"><figure class="mp hw mq mr ms mt mu paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mp hw mq mr ms mt mu paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mp hw mq mr ms mt mu paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mv mw mx"><p id="f922" class="jc jd lp je b jf jg jh ji jj jk jl jm my jo jp jq mz js jt ju na jw jx jy jz hn dt translated"><a class="ae ka" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ka" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ka" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae ka" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd lp je b jf jg jh ji jj jk jl jm my jo jp jq mz js jt ju na jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ka" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ka" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lv lw lx ly fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nb"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="lv lw lx ly fq hw"><div class="bz el l di"><div class="nc mk l"/></div></figure></div></div>    
</body>
</html>