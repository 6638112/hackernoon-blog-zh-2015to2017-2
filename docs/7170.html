<html>
<head>
<title>Adventures in Programming Interviews: Misleadingly (NP-)Hard Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编程面试中的冒险:误导性(NP-)难题</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/adventures-in-programming-interviews-misleadingly-difficult-np-hard-problem-43092597018c?source=collection_archive---------2-----------------------#2017-10-19">https://medium.com/hackernoon/adventures-in-programming-interviews-misleadingly-difficult-np-hard-problem-43092597018c?source=collection_archive---------2-----------------------#2017-10-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/df522fb61437b26e75f0401558bb0c01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fUYL09d0lff3BAvvcyp3aQ.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">A directed graph denoting debts between five participants</figcaption></figure><p id="5a35" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">当时已经很晚了，有些人会认为是晚上，我已经连续面试了五次；这家公司没有提供真正的喘息机会；一些面试官问我是否需要休息，但这些问题往往只有一个“正确”的答案。我真的很累。剩下的只是一对面试官的算法面试。</p><p id="52f4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">他们问了这个简单的框架问题:</p><blockquote class="ke kf kg"><p id="aeb5" class="jg jh kh ji b jj jk jl jm jn jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kd hn dt translated">给定一份两人之间的债务清单，尽可能减少清理所有债务所需的交易数量。</p></blockquote><p id="f073" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我最终得到了一份工作，但我在这次面试中表现糟糕。我最初的直觉是这是一个图形问题，也许是NP难的。我的第二直觉是，他们不会为一个简单的软件工程角色问一个NP难的问题。这是假设我的面试官完全理解他们问的问题。</p><h1 id="5a9a" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">他们的解决方案</h1><p id="89d8" class="pw-post-body-paragraph jg jh hu ji b jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd hn dt translated">后来，我和其中一位面试官成了朋友，并了解到他们的想法是这样的:</p><ol class=""><li id="59d1" class="lp lq hu ji b jj jk jn jo jr lr jv ls jz lt kd lu lv lw lx dt translated">请注意，重要的是人们接受或支付使他们变得完整所需的金额，而不是这些钱从哪里来。例如，如果爱丽丝欠鲍勃20美元，鲍勃欠卡尔20美元，那么这些债务可以通过爱丽丝给卡尔20美元来清偿，尽管爱丽丝从未直接欠卡尔任何钱。</li><li id="c308" class="lp lq hu ji b jj ly jn lz jr ma jv mb jz mc kd lu lv lw lx dt translated">将每个人的债务减少到一个数字，例如，如果爱丽丝欠3个人每人20美元，2个人欠爱丽丝每人50美元，那么爱丽丝被欠40美元(-$20 x 3 + $50 x 2 = $40)。删除债务为0美元的人。</li><li id="acc2" class="lp lq hu ji b jj ly jn lz jr ma jv mb jz mc kd lu lv lw lx dt translated">将欠钱的人和欠钱的人分成单独的排序列表或排序数据结构，然后从每个类别中的最高值开始，将他们配对，并重复此操作，直到列表用尽。</li></ol><p id="de12" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">那天沮丧的回家，后来更深入的分析了这个问题。这个问题无疑是NP难的。这是一个有趣的问题，但不适合软件工程面试。</p><p id="09f5" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">观察和还原是正确的。贪婪的解决方案不是。在上面的步骤1和2之后，考虑这个反例:</p><figure class="me mf mg mh fq iv fe ff paragraph-image"><div class="fe ff md"><img src="../Images/a4c710199ba99d7e3eebe6e938edb750.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*lSIO-ACjzFf5rtJDG3qmhw.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">The optimal perfect groupings are drawn in blue and red</figcaption></figure><ul class=""><li id="c749" class="lp lq hu ji b jj jk jn jo jr lr jv ls jz lt kd mi lv lw lx dt translated">有三个人分别欠了10美元、3美元和3美元。</li><li id="092c" class="lp lq hu ji b jj ly jn lz jr ma jv mb jz mc kd mi lv lw lx dt translated">有三个人分别被欠6美元、5美元和5美元。</li></ul><p id="7466" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">正确的解决方案是4个事务，其中6将与两个3配对，10将与两个5配对。贪婪方法产生5个事务。</p><p id="7ec4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">每笔交易可以消除1或2个参与者。最优解使可以消除2个参与者的交易数量最大化。让我们称一个<strong class="ji hv">完美分组</strong>为一组欠债务和被欠债务的参与者，它们可以被配对在一起而没有余数。每个完美的参与者分组引入一个可以消除2个参与者的交易。</p><p id="d576" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">最佳解决方案将找到两个完美的分组，($10 | $5，$5)和($3，$3 | $6)。贪婪的解决方案只会发现每个人都是一个完美的组合($10 $3 $3 | $6 $5 $5)。</p><h1 id="c98d" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated"><strong class="ak">NP-硬证明</strong></h1><p id="f5e0" class="pw-post-body-paragraph jg jh hu ji b jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd hn dt translated">为了证明这个问题是NP难的，大家熟知的<a class="ae kl" href="https://en.wikipedia.org/wiki/Subset_sum_problem" rel="noopener ugc nofollow" target="_blank">子集和问题</a>，也就是<a class="ae kl" href="https://en.wikipedia.org/wiki/NP-completeness" rel="noopener ugc nofollow" target="_blank"> NP完全</a>，可以<a class="ae kl" href="https://en.wikipedia.org/wiki/Reduction_(complexity)" rel="noopener ugc nofollow" target="_blank">化简</a>为这个问题，从而证明这个问题至少和子集和一样难。子集和问题是一个<a class="ae kl" href="https://en.wikipedia.org/wiki/Decision_problem" rel="noopener ugc nofollow" target="_blank">决策问题</a>，其中，给定一组整数<strong class="ji hv"> <em class="kh"> S </em> </strong>和一个目标整数<strong class="ji hv"> <em class="kh"> s </em> </strong>，是否存在一个<strong class="ji hv"> <em class="kh"> S </em> </strong>的非空子集，其和为<strong class="ji hv"> <em class="kh"> s </em> </strong>。这种约简将使用子集问题的正变型，其中<strong class="ji hv"> <em class="kh"> S </em> </strong>和目标整数<strong class="ji hv"> <em class="kh"> s </em> </strong>的所有元素都是正的。</p><figure class="me mf mg mh fq iv fe ff paragraph-image"><div class="fe ff mj"><img src="../Images/f4ae49b12bf2037a7021920e91735401.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*sQsDdLgCGyB5fLAilVfEIg.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">The subset sum problem reduction visualized</figcaption></figure><p id="070f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这是还原:</p><ol class=""><li id="acd9" class="lp lq hu ji b jj jk jn jo jr lr jv ls jz lt kd lu lv lw lx dt translated">将整数集合<strong class="ji hv"> <em class="kh"> S </em> </strong>转化为参与者各自所欠债务的整数值。</li><li id="d7fb" class="lp lq hu ji b jj ly jn lz jr ma jv mb jz mc kd lu lv lw lx dt translated">添加两个被欠债务的参与者<strong class="ji hv"> <em class="kh"> s </em> </strong>和<strong class="ji hv"> <em class="kh"> t </em> </strong>，其中<strong class="ji hv"> <em class="kh"> t </em> </strong>是集合<strong class="ji hv"> <em class="kh"> S </em> </strong>减去<strong class="ji hv"> <em class="kh"> s </em> </strong>中所有整数之和。这确保了债务总额和欠款总额是平衡的。</li><li id="01c7" class="lp lq hu ji b jj ly jn lz jr ma jv mb jz mc kd lu lv lw lx dt translated">计算清偿所有债务所需的最小交易数。<strong class="ji hv"> <em class="kh"> n </em> </strong>是欠钱的参与者数量，例如设置<strong class="ji hv"> <em class="kh"> S </em> </strong>的大小。约化问题有<strong class="ji hv"> <em class="kh"> n + 2 </em> </strong>个参与者。因为只有两个人被欠了钱，所以最多只能有两个完美的组合。如果找到2个，那么需要的最小事务数是<strong class="ji hv"> <em class="kh"> n </em> </strong>，并且有一个<strong class="ji hv"> <em class="kh"> S </em> </strong>的非空子集总计为<strong class="ji hv"> <em class="kh"> s </em> </strong>。如果是<strong class="ji hv"> <em class="kh"> n + 1 </em> </strong>，那就没有。</li></ol><p id="9a2a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">通过上面的归约，这个问题可以决定子集和问题，也就是说这个问题至少和子集和一样难。这个问题是NP难的。QED。</p><h1 id="27f0" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">解决方案</h1><p id="379c" class="pw-post-body-paragraph jg jh hu ji b jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd hn dt translated">解决方案是最大化完美分组的数量以最小化事务的数量，因为每个完美分组将清除所有债务所需的事务数量减少1。当没有完全匹配的严格子集时，整个解决方案就变成了一个完整的分组。换句话说，解决方案是最大化总计为0的不同子集的数量。</p><figure class="me mf mg mh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mk"><img src="../Images/9ec005ab370c5c097ca74f90d18afa19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kSq9lTnmDTSFmi5IvVc1DA.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Stepping through the above counterexample to the greedy solution. Invalid states are not drawn in this visualization (there are 60 undrawn states).</figcaption></figure><p id="3ab5" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这是我找到的解决方案:</p><ol class=""><li id="3fe0" class="lp lq hu ji b jj jk jn jo jr lr jv ls jz lt kd lu lv lw lx dt translated">把每个个人的债务减少为他们欠集体的债务的一个单一数字，那些被欠债务的人把他们的债务表示为负数。</li><li id="b6f1" class="lp lq hu ji b jj ly jn lz jr ma jv mb jz mc kd lu lv lw lx dt translated">删除债务减少值为0的人员。设<strong class="ji hv"> <em class="kh"> n </em> </strong>代表移除后剩余的参与者数量。</li><li id="e0a8" class="lp lq hu ji b jj ly jn lz jr ma jv mb jz mc kd lu lv lw lx dt translated">使用一个位掩码来表示状态，它是一系列长度为n. 0的0和1，在第<strong class="ji hv">位T5【I</strong><em class="kh">第</em>位表示第<strong class="ji hv"> <em class="kh"> i </em> </strong> <em class="kh">第</em>位参与者的债务尚未结清，1表示第<strong class="ji hv"> <em class="kh"> i </em> </strong> <em class="kh">第</em>位参与者的债务已经结清。有2^n这样的状态:所有的0代表没有清偿债务的开始状态，所有的1代表所有债务清偿的结束状态。</li><li id="06c2" class="lp lq hu ji b jj ly jn lz jr ma jv mb jz mc kd lu lv lw lx dt translated">每个状态映射到一个整数，表示非空子集和的最大数量。所有0都没有非空的子集和，因为没有已结清的债务，所以值为0。</li><li id="3d77" class="lp lq hu ji b jj ly jn lz jr ma jv mb jz mc kd lu lv lw lx dt translated">创建一个方法，接受给定的状态，以及来自未结算参与者债务的所有子集总和。对于找到的每个子集和，将这些位翻转为1以表示它们已经被解决，并使用新状态递归调用相同的方法。</li><li id="2662" class="lp lq hu ji b jj ly jn lz jr ma jv mb jz mc kd lu lv lw lx dt translated">调用初始状态全为0的方法。</li><li id="a665" class="lp lq hu ji b jj ly jn lz jr ma jv mb jz mc kd lu lv lw lx dt translated">与将被高速缓存/记忆的每个状态相关联的整数值是到达该状态所花费的来自所有0的递归调用栈的最大深度，表示最长的链(以及找到的最大数量的非空子集和分组)。高速缓存/记忆将确保没有状态被计算两次。</li><li id="73fc" class="lp lq hu ji b jj ly jn lz jr ma jv mb jz mc kd lu lv lw lx dt translated">找出所有1的整数值。这个问题的解决方案是参与者的数量减去这个数字，</li></ol><p id="1ad8" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">运行时分析:在每个状态，都需要2^k运算，其中k是要考虑的未结算参与者债务的数量。对于给定的k，有(n选k)个状态。预先计算所有可能的和，并将它们存储到查找表O(2^n).中使用预计算的查找表，每个状态有O(2^k运算，该算法的最大运行时间是:</p><figure class="me mf mg mh fq iv fe ff paragraph-image"><div class="fe ff ml"><img src="../Images/a5d5209cddc3f2d782154426e0ca0b0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/1*e4Z65yw6YT7XJozOnSbMLQ.png"/></div></figure><p id="e3c2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">很好的解释了为什么两边相等可以在这里找到<a class="ae kl" href="https://math.stackexchange.com/questions/1679305/prove-sumn-k-0n-choose-k-2k-3n" rel="noopener ugc nofollow" target="_blank">。该算法将占用O(2^n空间，因为存在O(2^n状态和O(2^n总和。</a></p><h1 id="f3ce" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">然后</h1><p id="8402" class="pw-post-body-paragraph jg jh hu ji b jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd hn dt translated">最令人沮丧的是，我的面试官认为这个问题比实际要简单得多，并报告说我无法在45分钟内解决这么简单的问题。这个特别的面试严重伤害了我收到的录用通知。不幸的是，面试过程中有很多运气，因为生活中有很多运气。最好的办法是学会不要假设面试官完全理解他们自己的问题，并就此写一篇博文。</p><p id="fba3" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="kh">谢谢丹尼尔·乏色曼帮我看完这篇文章！</em></p></div></div>    
</body>
</html>