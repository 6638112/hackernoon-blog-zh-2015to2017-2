<html>
<head>
<title>Serverless is bigger than FaaS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器比FaaS还大</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/serverless-is-bigger-than-faas-a5fe0f088981?source=collection_archive---------13-----------------------#2017-11-29">https://medium.com/hackernoon/serverless-is-bigger-than-faas-a5fe0f088981?source=collection_archive---------13-----------------------#2017-11-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/4dc759dd20db02370e7fa8191444a836.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bPG8ZINuJkoYOqafZwmKwQ.jpeg"/></div></div></figure><p id="ac3d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">开发人员社区对无服务器模式越来越感兴趣，这种想法让开发人员无需配置或管理服务器即可交付工作负载。</p><p id="7f83" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在其核心，无服务器架构依赖于编制一个充满活力的生态系统的全面管理的服务。随着越来越多的此类后端服务(即后端即服务(BaaS))得到所有关键云基础设施(IaaS)提供商的支持，我认为可以说2018年将是无服务器年。</p><p id="58e2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">令人兴奋的是，对于什么构成了无服务器架构，也存在困惑。传统观点——由云提供商的说辞推动——认为只有功能即服务(FaaS)实现代表无服务器架构。</p><p id="6cb5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我写这篇文章是为了挑战其中的一些观点，希望提出一个案例，将这个定义从功能级抽象扩展到应用级抽象，从而被认为是无服务器的。</p><h2 id="f330" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">无服务器1.0</h2><p id="4f80" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">在软件开发过程中没有服务器概念的想法——或者无服务器——并不新鲜。Heroku可能是第一个在2008年左右引入这一概念的人，这一概念被开发人员社区广泛采用(可以说Google App Engine是第一个，但将在另一篇文章中讨论)。</p><p id="7043" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Heroku抱着开发者第一的心态，承诺了三件主要的事情:</p><ol class=""><li id="a49e" class="la lb hu je b jf jg jj jk jn lc jr ld jv le jz lf lg lh li dt translated">与IaaS提供商提供的虚拟机相比，通过将工作负载隔离在更小的容器映像中，成本更低，最适合运行大多数应用程序工作负载</li><li id="4f18" class="la lb hu je b jf lj jj lk jn ll jr lm jv ln jz lf lg lh li dt translated">一套全面管理的后端，可从具有联合身份和整合计费的市场中访问</li><li id="3f24" class="la lb hu je b jf lj jj lk jn ll jr lm jv ln jz lf lg lh li dt translated">使用出色的命令行工具开发、调试和交付工作负载的出色开发人员体验</li></ol><p id="db5b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于用Heroku支持的语言/框架编写的应用程序，开发人员可以遵循一个非常熟悉的基于git的工作流程来部署他们的代码。Heroku将无缝处理工作负载的可用性和扩展。12因素方法的声明格式承诺最大化迭代速度，并提供与底层操作系统的清晰契约，提供最大的可移植性</p><p id="af5e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于容器的占用空间比虚拟机小得多，它们允许Heroku在不同配置的不同机器上高效地调度工作负载，并优化性价比。</p><p id="3027" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了实现这一点，Heroku构建了容器运行时和编排引擎，它们运行在对用户关闭的Amazon Web Services之上。</p><p id="bdfc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，12因素设计所承诺的简单性缺乏部署具有复杂需求的工作负载的灵活性。您不能部署任何非12因素的工作负载，也不能让您的工作负载在私有网络中运行。市场主要由外部供应商组成，很少或根本不关注应用程序和后端之间的延迟，这往往会导致性能下降。</p><p id="53bf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">封闭的方法、缺乏灵活性和降级的性能使Heroku无法被具有复杂需求的企业所采用，并驱使它继续作为“业余爱好”开发人员非常喜爱的平台。</p><p id="f4fc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这一市场缺口催生了平台，即所谓的平台即服务(PaaS)，如cloud foundry(EMC和VMWare的一个分拆)、Makara (RedHat OpenShift)和DotCloud(后更名为Docker)</p><p id="1faa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过采用开放的方法，这些平台承诺了Heroku风格工作流的易用性，同时提供了灵活性或使用您自己的硬件，重点是简单性</p><p id="5557" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">像Heroku一样，这些平台也严重依赖Linux容器——这是一个相对较老但当时不为人知的概念——作为交付工作负载的打包和隔离机制。Linux提供的本地容器运行时——称为LXC——使用起来很难，也不舒服；仅限于像Google这样的公司的高级团队和构建基础设施工具的团队采用。</p><p id="0599" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">DotCloud是一家相对不知名的公司，其产品无法与竞争对手区分开来——面临灭绝的可能性——开源了他们开发的一款工具，以简化对LXC的使用，名为“Docker”</p><p id="20de" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Docker简单性的关键是图像格式——在清单文件中声明的图像内容然后用于构建图像，该图像可以在任何地方构建，并通过存储在中央存储库中与其他人共享。这种一次构建，随处运行的方法让位于开发人员解决特别棘手的开发到生产的对等问题。</p><p id="3204" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">开发人员很快就接受了Docker，这导致了对云原生生态系统的寒武纪展示。虽然Docker为单个工作负载提供了映像格式和运行时，但Kubernetes等工具的诞生是为了协调各种工作负载，并以容错方式对它们进行调度。</p><p id="64e7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Heroku的无服务器承诺——应用程序运行时抽象——为蓬勃发展的生态系统铺平了道路，改变了我们设计分布式工作负载交付的基本方式</p><h2 id="7626" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">无服务器2.0</h2><p id="37de" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">随着越来越多的工作负载转移到云，IaaS提供商很快就明白了提供完全托管的后端(如数据库、缓存、负载平衡器等)的价值，这是工作负载所需的支持基础架构</p><p id="a5b5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于Amazon Web Services (AWS)这样的提供商，从简单的托管对象存储产品开始，扩展到70多种服务(截至本文撰写之时)；对于许多提供商来说，一种编排这些丰富的后端的方法是显而易见的。通过利用编排和容器化浪潮，重新思考抽象层次成为可能。</p><p id="9b39" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这催生了一个新的抽象层次——功能即服务。AWS Lambda是一个提供功能抽象的产品，同时承诺更快的迭代速度、零管理和更细粒度的定价模型。</p><p id="2bc3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里的区别在于，开发关注的是单个功能或模块，而不是像应用程序运行时抽象中那样具有大表面积的服务。</p><p id="4f99" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">应用程序级抽象和功能级抽象之间的另一个基本区别是在哪里以及如何定义工作负载的调用机制。在应用程序抽象中，调用机制在应用程序代码本身中描述，并为开发人员选择框架提供了灵活性。对于功能性调用，调用在提供者设计的清单文件中定义。在AWS Lamda的情况下，通过将消息放入受管队列(SQS)的异步调用，以及通过调用受管路由器上的预定义端点(API网关)的基于web的调用</p><p id="ac21" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">本质上，FaaS是由提供商创建和管理的应用程序框架。这使得FaaS对那些不一定在乎供应商锁定，并且可以灵活地采用供应商清单来换取一点想法的开发人员很有吸引力。</p><h2 id="1be5" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">结论</h2><p id="b489" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">现在很明显，应用程序和功能运行时抽象提供了无服务器的承诺——在未来，开发人员可以专注于编写向用户提供功能的代码，而不是处理交付代码的复杂性。</p></div></div>    
</body>
</html>