<html>
<head>
<title>Mixing Python with Elixir</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将蟒蛇与仙丹混合</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/mixing-python-with-elixir-7a2b7ac6696?source=collection_archive---------3-----------------------#2017-09-15">https://medium.com/hackernoon/mixing-python-with-elixir-7a2b7ac6696?source=collection_archive---------3-----------------------#2017-09-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/cf8ccd41ed54852f3639f3b18fda7ee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MIbs2DZaaiUf_DL6J6dhOg.png"/></div></div></figure><p id="cbaa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">使用Elixir app中的Python模块生成和解码二维码</em></p><p id="326d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">运行Elixir的Erlang VM对于特定领域的应用程序来说是高效的，但是当涉及到其他操作，如数据处理和计算密集型的东西时就显得不够了。另一方面，Python有一套丰富的包来处理数据处理和科学计算。</p><p id="7c0b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">幸运的是，Erlang VM允许使用<a class="ae kb" href="http://erlang.org/doc/reference_manual/ports.html" rel="noopener ugc nofollow" target="_blank"> Erlang端口协议</a>与其他语言进行互操作。</p><p id="78f4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">ErlPort是一个Elixir库，它使得使用Erlang端口协议将Erlang连接到许多其他编程语言变得更加容易。目前Erlport支持<a class="ae kb" href="http://erlport.org/docs/python.html" rel="noopener ugc nofollow" target="_blank"> Python </a>和<a class="ae kb" href="http://erlport.org/docs/ruby.html" rel="noopener ugc nofollow" target="_blank"> Ruby </a>。</p><p id="46fc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这篇文章中，我们将看到如何调用Python模块从我们的Elixir应用程序中生成二维码。</p><p id="f000" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> Erlport Python入门<br/> </strong>要使用Erlport，只需添加到您的依赖项中</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="a6b3" class="kl km hu kh b fv kn ko l kp kq">#mix.exs<br/>{:erlport, "~&gt; 0.9"}</span></pre><p id="ead1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦Erlport被添加到您的项目中，您就可以访问您的elixir代码中的<code class="eh kr ks kt kh b">:<em class="ka">python</em></code>模块。这个Erlport python模块允许您启动一个Elixir进程来执行python代码。</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="2ebf" class="kl km hu kh b fv kn ko l kp kq">#creates and Elixir process for calling python functions<br/>{:ok, pid} = :python.start()</span><span id="c791" class="kl km hu kh b fv ku ko l kp kq">#get the current python version<br/>:python.call(pid, :sys, :'version.__str__', [])</span></pre><p id="1cc2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">更好的是，Erlport允许您配置python路径，这样您就可以<br/>从特定目录加载定制的python模块！</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="d22f" class="kl km hu kh b fv kn ko l kp kq">#Automatically load all modules in directory with path /custom/modules/directory</span><span id="48af" class="kl km hu kh b fv ku ko l kp kq">{:ok, pid} = :python.start([{:python_path, '/custom/modules/directory'}])</span></pre><p id="d5da" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过调用<code class="eh kr ks kt kh b">start/1</code>返回的进程，您可以使用熟悉的<strong class="je hv"> MFA </strong> - <em class="ka">模块</em>、<em class="ka">函数</em>、<em class="ka">参数</em>格式调用python模块中的函数</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="f245" class="kl km hu kh b fv kn ko l kp kq">{:ok, pid} = :python.start([{:python_path, 'custom_modules_directory'}])<br/><strong class="kh hv">module</strong> = :test #python module to call <br/><strong class="kh hv">function</strong> = :hello # function in module<br/><strong class="kh hv">arguments</strong> = ["World"] # list of arguments pass to function the function<br/>result = :python.call(p, module, function, arguments)</span></pre><p id="cbd1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果python函数返回数据，它将被绑定到上面代码中的<code class="eh kr ks kt kh b">result</code>变量。否则<code class="eh kr ks kt kh b">:python.call/4</code>为不返回任何数据的python函数返回<code class="eh kr ks kt kh b">:undefined</code>。</p><p id="cf51" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">让我们创建Elixir项目</strong> <em class="ka"> <br/> </em>在这个项目中，我们将创建一个简单的应用程序，将字符串编码为二维码图像。然后解码二维码图像文件，把字符串拿回来。我们将从我们的应用程序中调用Python模块(<a class="ae kb" href="https://github.com/primetang/qrtools" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> qrtools </strong> </a>)来进行编码和解码，而不是使用原生的Elixir/Erlang lib。检查此处的<a class="ae kb" href="https://github.com/primetang/qrtools" rel="noopener ugc nofollow" target="_blank">以设置qrtools。<br/> <br/> <strong class="je hv"> 1。</strong> <em class="ka">创建灵药OTP app </em></a></p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="5089" class="kl km hu kh b fv kn ko l kp kq">$ mix new elixir_python_qrcode </span></pre><p id="bed3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 2。</strong> <em class="ka">添加依赖关系</em> <br/> <br/>添加<code class="eh kr ks kt kh b">erlport</code>到你的依赖关系<code class="eh kr ks kt kh b">mix.exs</code></p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="db20" class="kl km hu kh b fv kn ko l kp kq">defp deps do<br/>    [<br/>      # {:dep_from_hexpm, "~&gt; 0.3.0"},<br/>      # {:dep_from_git, git: "https://github.com/elixir-lang/my_dep.git", tag: "0.1.0"},<br/>      <strong class="kh hv">{:erlport, "~&gt; 0.9"}</strong>,<br/>    ]<br/>  end</span></pre><p id="1e13" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后安装项目依赖项。</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="eb53" class="kl km hu kh b fv kn ko l kp kq">$ mix deps.get</span></pre><p id="f72b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 3。</strong> <em class="ka">让我们为Erlport</em><br/><br/>Create<code class="eh kr ks kt kh b">lib/helper.ex</code>添加包装药剂模块，添加名为<code class="eh kr ks kt kh b">ElixirPythonQrcode.Helper</code>的药剂模块并添加这些辅助函数。</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="a16b" class="kl km hu kh b fv kn ko l kp kq">defmodule ElixirPythonQrcode.Helper do<br/>  @doc """<br/>  ## Parameters<br/>    - path: directory to include in python path (charlist)<br/>  """<br/>  def python_instance(path) when is_list(path) do<br/>    {:ok, pid} = :python.start([{:python_path, to_charlist(path)}])<br/>    pid<br/>  end<br/><br/>  def python_instance(_) do<br/>    {:ok, pid} = :python.start()<br/>    pid<br/>  end<br/><br/>  @doc """<br/>  Call python function using MFA format<br/>  """<br/>  def call_python(pid, module, function, arguments \\ []) do<br/>    pid<br/>    |&gt;:python.call(module, function, arguments)<br/><br/>  end<br/>end</span></pre><p id="ff1d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 4。</strong> <em class="ka">为main添加模块代码。</em></p><p id="db0d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将有两个函数<code class="eh kr ks kt kh b">encode/2</code>——它接受一些字符串和文件路径。它对数据进行编码，并将二维码图像写入给定的文件路径，以及<code class="eh kr ks kt kh b">decode/1</code>——它接受二维码图像的文件路径，并解码得到原始数据。<br/> <br/>我们来编辑一下<code class="eh kr ks kt kh b">lib/elixir_python_qrcode.ex</code></p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="e209" class="kl km hu kh b fv kn ko l kp kq">#<!-- -->lib/elixir_python_qrcode.ex</span><span id="717d" class="kl km hu kh b fv ku ko l kp kq">defmodule ElixirPythonQrcode do<br/>  @moduledoc """<br/>  Documentation for ElixirPythonQrcode.<br/>  """<br/>  alias ElixirPythonQrcode.Helper<br/><br/>  def encode(data, file_path) do<br/>    call_python(:qrcode, :encode, [data, file_path])<br/>  end<br/><br/>  def decode(file_path) do<br/>    call_python(:qrcode, :decode, [file_path])<br/>  end</span><span id="f180" class="kl km hu kh b fv ku ko l kp kq">  defp default_instance() do<br/>    #Load all modules in our priv/python directory<br/>    path = [:code.priv_dir(:elixir_python_qrcode), "python"] <br/>          |&gt; Path.join()<br/>    Helper.python_instance(to_charlist(path))<br/>  end<br/><br/>  # wrapper function to call python functions using<br/>  # default python instance<br/>  defp call_python(module, function, args \\ []) do<br/>    default_instance()<br/>    |&gt; Helper.call_python(module, function, args)<br/>  end</span><span id="e1ef" class="kl km hu kh b fv ku ko l kp kq">end</span></pre><p id="d392" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 5。</strong> <em class="ka">现在让我们创建我们的python模块</em> <br/> <br/>创建包含我们的python函数的<code class="eh kr ks kt kh b">priv/python/qrcode.py</code>模块。这些函数处理实际的QR码生成和解码。</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="74a7" class="kl km hu kh b fv kn ko l kp kq">#<!-- -->priv/python/qrcode.py</span><span id="b3aa" class="kl km hu kh b fv ku ko l kp kq">def decode(file_path):<br/>    import qrtools<br/>    qr = qrtools.QR()<br/>    qr.decode(file_path)<br/>    return qr.data<br/><br/>def encode(data, file_path):<br/>    import qrtools<br/>    qr = qrtools.QR(data.encode("utf-8"))<br/>    return qr.encode(filename=file_path)<br/>    </span></pre><p id="8bbf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 6。让我们测试一下我们的代码。</strong></p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="caea" class="kl km hu kh b fv kn ko l kp kq">$ iex -S mix<br/>iex(1)&gt; ElixirPythonQrcode.encode("Some test to encode", "qrcode.png")<br/>0<br/>iex(2)&gt; ElixirPythonQrcode.decode("qrcode.png")<br/>'Some test to encode'<br/>iex(3)&gt; ElixirPythonQrcode.decode("qrcode.png") |&gt; to_string()<br/>"Some test to encode"</span></pre><p id="e3ac" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就是这样。查看<a class="ae kb" href="https://github.com/badubizzle/elixir_python_qrcode" rel="noopener ugc nofollow" target="_blank">github repo</a>。</p><p id="4ac2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">编码快乐！</p><p id="cd3a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">查看<a class="ae kb" rel="noopener" href="/@badu_bizzle/mixing-python-with-elixir-ii-async-e8586f9b2d53">第二部分</a>了解Elixir和Python之间的异步通信</p></div></div>    
</body>
</html>