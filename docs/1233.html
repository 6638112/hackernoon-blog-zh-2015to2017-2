<html>
<head>
<title>Lesser known Git commands</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">鲜为人知的Git命令</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/lesser-known-git-commands-151a1918a60?source=collection_archive---------1-----------------------#2016-09-29">https://medium.com/hackernoon/lesser-known-git-commands-151a1918a60?source=collection_archive---------1-----------------------#2016-09-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="b3fe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Git对向后兼容性有很强的承诺:许多强大的特性隐藏在选项后面，而不是作为默认行为公开。幸运的是，Git还支持<em class="jq">别名</em>，因此您可以创建自己的命令来实现各种各样的Git魔术。下面是我的<em class="jq">中定义的一些更有用(或者至少有趣)的别名。gitconfig </em>:</p><h1 id="fa5c" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated">请给我</h1><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="38aa" class="ky js hu ku b fv kz la l lb lc">$ git config --global alias.please 'push --force-with-lease'</span></pre><p id="0e7d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每个开发人员都和他们的团队领导讨论过强制推进到共享分支(即不要这样做)。重置、修改和挤压。都很有趣，直到你重写了一些共享的历史，并且在你的存储库中到处都是重复的提交。幸运的是，Git不会让你随意在服务器上重写历史。你必须显式地将<em class="jq"> - force </em>选项传递给<em class="jq"> git push </em>来表明你是认真的。但是强制推送有点重:它用您的本地版本踩踏上游分支，并且您尚未获取的任何更改都将从历史中删除。</p><figure class="kp kq kr ks fq le fe ff paragraph-image"><div class="fe ff ld"><img src="../Images/69d7efca2ec58b389ed2f4c87379993d.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*rV0zYWOA8k5f_ixFXDF-aA.jpeg"/></div><figcaption class="lh li fg fe ff lj lk bd b be z ek">Quality meme courtesy of <a class="ae jp" href="https://twitter.com/tarkasteve" rel="noopener ugc nofollow" target="_blank">@tarkasteve</a></figcaption></figure><p id="7d98" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Git的<a class="ae jp" href="https://developer.atlassian.com/blog/2015/04/force-with-lease/?utm_source=medium&amp;utm_medium=blog&amp;utm_campaign=lesser-git" rel="noopener ugc nofollow" target="_blank"><em class="jq">-force-with-lease</em></a><em class="jq"/>选项要客气得多:它会在覆盖之前检查您正在覆盖的ref的本地副本是否是最新的。这表明您至少已经获取了将要踩踏的更改。因为<em class="jq">git push-force-with-lease</em>每次都要输入很多，所以我为它创建了一个礼貌的别名:<em class="jq"> git please </em></p><h1 id="e3c2" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated">给予表扬</h1><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="482c" class="ky js hu ku b fv kz la l lb lc">$ git config --global alias.commend 'commit --amend --no-edit'</span></pre><p id="d46f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有没有提交后马上意识到忘记上传文件的经历？别再烦恼了！gitcomm荐悄悄地将任何暂存文件添加到您创建的最后一次提交中，重用您现有的提交消息。所以，只要你还没有努力，没有人会知道。</p><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="ab00" class="ky js hu ku b fv kz la l lb lc">$ git add Dockerfile<br/>$ git commit -m ‘Update Bitbucket pipeline with new Docker image’<br/># (facepalm)<br/>$ git add bitbucket-pipelines.yml<br/>$ git commend</span></pre><h1 id="9d13" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated">抓住它</h1><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="175a" class="ky js hu ku b fv kz la l lb lc">$ git config --global alias.it \<br/>'!git init &amp;&amp; git commit -m “root” --allow-empty'</span></pre><p id="dca3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">存储库的第一次提交不能像常规提交一样被重新确定基础，所以创建一个空提交作为存储库根是一个好的实践。git it 在一个快速的步骤中初始化您的存储库并创建一个空的根提交。下次你启动一个项目时，不要只是把它添加到版本控制中:<em class="jq"> git it </em>！</p><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="d01d" class="ky js hu ku b fv kz la l lb lc">$ cd shiny-new-thing<br/>$ git it<br/>Initialized empty Git repository in /shiny-new-thing/.git/<br/>[master (root-commit) efc9119] root</span></pre><h1 id="3b53" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated">git staaash</h1><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="1080" class="ky js hu ku b fv kz la l lb lc">$ git config --global alias.stsh 'stash --keep-index'<br/>$ git config --global alias.staash 'stash --include-untracked'<br/>$ git config --global alias.staaash 'stash --all'</span></pre><p id="ef12" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://www.atlassian.com/git/tutorials/git-stash/?utm_source=medium&amp;utm_medium=blog&amp;utm_campaign=lesser-git" rel="noopener ugc nofollow" target="_blank"> <em class="jq"> git stash </em> </a> <em class="jq"> </em>是最令人愉快和有用的git命令之一。它会对你的工作树中被跟踪的文件进行任何修改，然后<em class="jq">将它们藏起来</em>以备后用，给你留下一个干净的工作树，让你开始处理其他东西。然而，如果你已经创建了任何<em class="jq">新的</em>文件并且还没有暂存它们，默认情况下<em class="jq"> git stash </em>不会接触它们，留给你一个脏的工作树。同样，默认情况下不会隐藏未跟踪或忽略的文件的内容。</p><p id="ea97" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我已经创建了几个方便的别名来处理不同种类的<em class="jq"> git stash </em>，基于你的工作树的哪些部分你需要存储:</p><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="7a72" class="ky js hu ku b fv kz la l lb lc">git stsh      # stash only unstaged changes to tracked files<br/>git stash     # stash any changes to tracked files<br/>git staash    # stash untracked and tracked files<br/>git staaash   # stash ignored, untracked, and tracked files </span></pre><p id="61b2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果有疑问，长的那个(<em class="jq"> git staaash </em>)将总是把你的工作树恢复到看起来像你的库的一个新克隆。</p><h1 id="4295" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated">矮子</h1><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="d4ec" class="ky js hu ku b fv kz la l lb lc">$ git config --global alias.shorty 'status --short --branch'</span></pre><p id="98f2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我运行<a class="ae jp" href="https://www.atlassian.com/git/tutorials/inspecting-a-repository/?utm_source=medium&amp;utm_medium=blog&amp;utm_campaign=lesser-git" rel="noopener ugc nofollow" target="_blank"> <em class="jq"> git status </em> </a>的次数可能比任何其他git命令都多。这些年来，Git的内联帮助变得更加友好，这对初学者来说非常好，但是对于那些更熟悉Git的人来说，输出过于冗长。例如，<em class="jq"> git status </em>发出<strong class="it hv"> 18行代码</strong>告诉我，我有几个分阶段的、未分阶段的和未跟踪的变更:</p><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="dd8c" class="ky js hu ku b fv kz la l lb lc">$ git status<br/>On branch master<br/>Changes to be committed:<br/>  (use “git reset HEAD &lt;file&gt;…” to unstage)</span><span id="4bc2" class="ky js hu ku b fv ll la l lb lc">    modified: package.json</span><span id="34e2" class="ky js hu ku b fv ll la l lb lc">Changes not staged for commit:<br/>  (use “git add &lt;file&gt;…” to update what will be committed)<br/>  (use “git checkout -- &lt;file&gt;…” to discard changes)</span><span id="3b8b" class="ky js hu ku b fv ll la l lb lc">    modified: package.json</span><span id="b3d3" class="ky js hu ku b fv ll la l lb lc">Untracked files:<br/>  (use “git add &lt;file&gt;…” to include in what will be committed)</span><span id="c8f5" class="ky js hu ku b fv ll la l lb lc">    index.js</span></pre><p id="a821" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jq"> git shorty </em>用三行告诉我同样的事情:</p><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="0350" class="ky js hu ku b fv kz la l lb lc">$ git shorty<br/>## master<br/>AM test<br/>?? .gitignore</span></pre><p id="b830" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(好吧，为了简单起见，我实际上把这个别名叫做<em class="jq"> git st </em>，但是我无法抗拒。)</p><h1 id="823c" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated">git merc</h1><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="22c5" class="ky js hu ku b fv kz la l lb lc">$ git config --global alias.merc 'merge --no-ff'</span></pre><p id="2bed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你正在使用一个标准的非基础分支工作流，运行一个标准的<em class="jq"> git merge </em>来合并主功能分支实际上并不理想。在没有选项的情况下，<em class="jq"> git merge </em>使用<em class="jq"> - ff </em>合并策略，该策略仅在主分支上没有新的更改时创建合并提交，否则它会简单地“快进”您的主分支以指向您的特性分支上的最新提交。只有<em class="jq">有时候</em>创建一个合并提交会让你在查看你的git历史时很难推断出哪个代码是在哪个分支上开发的。</p><figure class="kp kq kr ks fq le fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lm"><img src="../Images/81df6f92cb1cd2e53c34f02b145909b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*VYHiXlWZE6JIs4zEMxE4UQ.gif"/></div></div></figure><p id="6843" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jq"> git merc </em>使用<em class="jq"> - no-ff </em>策略，总是创建一个合并提交。</p><figure class="kp kq kr ks fq le fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lm"><img src="../Images/c650d02fa5c4bdf2434a51f58c50e9a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0lNVIAH5g_MfMAloAnbyUQ.gif"/></div></div></figure><p id="6304" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">顺便提一下，<em class="jq"> - no-ff </em>也是我们在<a class="ae jp" href="https://bitbucket.org?utm_source=medium&amp;utm_medium=blog&amp;utm_campaign=lesser-git" rel="noopener ugc nofollow" target="_blank">位桶</a>中合并拉请求时使用的(默认情况下)。</p><h1 id="9eb6" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated">git grog</h1><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="ae59" class="ky js hu ku b fv kz la l lb lc">$ git config --global alias.grog 'log --graph --abbrev-commit --decorate --all --format=format:"%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(dim white) - %an%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n %C(white)%s%C(reset)"'</span></pre><p id="efd7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的别名<em class="jq"> git grog </em>(或“<strong class="it hv"> gr </strong> aphical l <strong class="it hv"> og </strong>”)已经发展了这么多年，我已经不确定自己是否确切了解它的功能。但是它看起来很漂亮:</p><figure class="kp kq kr ks fq le fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lr"><img src="../Images/7babcc3b4f4153564c80ab657c93284c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PgKTuG5-Qtrt_CqiCT35uw.png"/></div></div><figcaption class="lh li fg fe ff lj lk bd b be z ek"><em class="ls">git grog</em></figcaption></figure><p id="e7bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是标准的<em class="jq"> git日志</em>用于比较:</p><figure class="kp kq kr ks fq le fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lt"><img src="../Images/06214fa9d5669e679bb849523e77b537.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TFwMkiXknawT1N4cI0ycsw.png"/></div></div><figcaption class="lh li fg fe ff lj lk bd b be z ek">git log</figcaption></figure><p id="433b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有各种各样的<a class="ae jp" href="https://git-scm.com/docs/pretty-formats" rel="noopener ugc nofollow" target="_blank">漂亮的格式</a>可用，所以分叉上面的命令，让它成为你自己的！</p><h1 id="f209" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated">对于GUI粉丝来说</h1><p id="157f" class="pw-post-body-paragraph ir is hu it b iu lu iw ix iy lv ja jb jc lw je jf jg lx ji jj jk ly jm jn jo hn dt translated">如果你是Git GUI爱好者，并且使用Mac或Windows，你可能会使用我们的免费Git客户端:Atlassian SourceTree。如果是这样的话，您可以通过在您的<a class="ae jp" href="https://hackernoon.com/tagged/sourcetree" rel="noopener ugc nofollow" target="_blank"> SourceTree </a>首选项中创建一个新的<em class="jq">自定义操作— </em>和可选的键盘快捷键来利用这些别名:</p><figure class="kp kq kr ks fq le fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lz"><img src="../Images/2b054a1f3afa96abd567f6d21c83d1b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QKq8cnE1O9skf6ADYGc5lw.png"/></div></div></figure><p id="839c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后您可以通过<em class="jq">动作</em>-&gt;-<em class="jq">自定义动作</em>菜单或您选择的键盘快捷键来访问它:</p><figure class="kp kq kr ks fq le fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff ma"><img src="../Images/912c678e5c1124771b471d72b6352e2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yIEAGTd_fhhvUOC9oaYbXA.png"/></div></div></figure><p id="3846" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">快乐别名！如果你自己有一些整洁的Git别名，请在评论中分享，或者发推特给我<a class="ae jp" href="https://twitter.com/kannonboy" rel="noopener ugc nofollow" target="_blank"> @kannonboy </a>。</p><div class="kp kq kr ks fq ab cb"><figure class="mb le mc md me mf mg paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mb le mc md me mf mg paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mb le mc md me mf mg paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mh mi mj"><p id="f922" class="ir is jq it b iu iv iw ix iy iz ja jb mk jd je jf ml jh ji jj mm jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是这个家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is jq it b iu iv iw ix iy iz ja jb mk jd je jf ml jh ji jj mm jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kp kq kr ks fq le fe ff paragraph-image"><a href="https://goo.gl/Ahtev1"><div class="fe ff mn"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></a></figure><figure class="kp kq kr ks fq le"><div class="bz el l di"><div class="mo mp l"/></div></figure></div></div>    
</body>
</html>