<html>
<head>
<title>Higher Order Functions: Behind the Scenes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高阶函数:幕后</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/higher-order-functions-behind-the-scenes-5853179cfd9c?source=collection_archive---------8-----------------------#2017-08-27">https://medium.com/hackernoon/higher-order-functions-behind-the-scenes-5853179cfd9c?source=collection_archive---------8-----------------------#2017-08-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/283b0e2d9b95ba47e201231664beff82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*0klm8TN3bY1pa_CmeNBuCw.png"/></div></figure><p id="2d43" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这篇文章不是向你展示如何使用<code class="eh jw jx jy jz b">forEach</code>、<code class="eh jw jx jy jz b">map</code>、<code class="eh jw jx jy jz b">filter</code>和<code class="eh jw jx jy jz b">reduce</code>、<a class="ae ka" href="https://hackernoon.com/tagged/nor" rel="noopener ugc nofollow" target="_blank">和</a>的，也不是展示高阶函数的好处的。有的是<a class="ae ka" rel="noopener" href="/humans-create-software/a-dirt-simple-introduction-to-higher-order-functions-in-javascript-b33bf9e19056">其他的</a> <a class="ae ka" rel="noopener" href="/javascript-scene/higher-order-functions-composing-software-5365cf2cbe99">文章</a> <a class="ae ka" rel="noopener" href="/functional-javascript/higher-order-functions-78084829fff4">那个</a> <a class="ae ka" href="https://medium.freecodecamp.org/higher-order-functions-in-javascript-d9101f9cf528" rel="noopener ugc nofollow" target="_blank">做</a>那个。</p><p id="fc7a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">当我想理解一个基本概念的时候，我喜欢尝试<em class="kb">自己实现</em>，哪怕是很基础的版本。人们以不同的方式学习，这对我很有用。所以让我带你踏上这段旅程，我试着在<a class="ae ka" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>中创建我自己的<code class="eh jw jx jy jz b">forEach</code>、<code class="eh jw jx jy jz b">map</code>、<code class="eh jw jx jy jz b">reduce</code>和<code class="eh jw jx jy jz b">filter</code>函数。</p><h2 id="6953" class="kc kd hu bd ke kf kg kh ki kj kk kl km jj kn ko kp jn kq kr ks jr kt ku kv kw dt translated">myForEach</h2><p id="a0ab" class="pw-post-body-paragraph iy iz hu ja b jb kx jd je jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv hn dt translated">为了与内置的<code class="eh jw jx jy jz b">forEach</code>区别开来，让我们称我的新函数为<code class="eh jw jx jy jz b">myForEach</code>。</p><p id="eff0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">首先要做的是查看调用签名。你知道的forEach函数是这样做的:</p><pre class="lc ld le lf fq lg jz lh li aw lj dt"><span id="3cd2" class="kc kd hu jz b fv lk ll l lm ln">let arr = [ 1, 2, 3, 4 ]</span><span id="7998" class="kc kd hu jz b fv lo ll l lm ln">// log each item of the array<br/>arr.forEach(console.log)</span><span id="86e2" class="kc kd hu jz b fv lo ll l lm ln">// double each item of the array and log it to the console<br/>arr.forEach((val) =&gt; console.log(val * 2))</span></pre><p id="0349" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们在寻找一个带两个参数的函数，一个数组和一个回调函数。回调函数可以是函数定义或匿名函数。我们要做的是迭代数组中的每一项，并调用该项的回调函数。所以让我们试一试。</p><pre class="lc ld le lf fq lg jz lh li aw lj dt"><span id="9d3f" class="kc kd hu jz b fv lk ll l lm ln">function myForEach(arr, callback) {<br/>  for (let i = 0; i &lt; arr.length; i++) {<br/>    callback(arr[i])<br/>  }<br/>}</span><span id="69c5" class="kc kd hu jz b fv lo ll l lm ln">let arr = [ 1, 2, 3, 4 ]</span><span id="4c7d" class="kc kd hu jz b fv lo ll l lm ln">// log each item of the array<br/>myForEach(arr, console.log)</span><span id="d50b" class="kc kd hu jz b fv lo ll l lm ln">// double each item of the array and log it to the console<br/>myForEach(arr, val =&gt; console.log(val * 2))</span></pre><p id="8521" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">看起来很简单，而且很有效。但是…但是…不完全一样。如果你尝试<code class="eh jw jx jy jz b">arr.myForEach(console.log)</code>，你会得到<code class="eh jw jx jy jz b">TypeError: arr.myForEach is not a function</code>。这是因为我们将myForEach声明为一个全局函数。实际上，它应该是数组对象原型的一部分。注意本文的目的不是解释原型继承是如何工作的。为了实现我们想要的，我们需要这样做。</p><pre class="lc ld le lf fq lg jz lh li aw lj dt"><span id="093a" class="kc kd hu jz b fv lk ll l lm ln">Array.prototype.myForEach = (callback) =&gt; {<br/>  for (let i = 0; i &lt; this.length; i++) {<br/>    callback(arr[i])<br/>  }<br/>}</span><span id="0f74" class="kc kd hu jz b fv lo ll l lm ln">// log each item of the array<br/>arr.myForEach(console.log)</span></pre><p id="d33b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">当我尝试运行上面的代码时，什么也没有发生。怎么了？</p><p id="0d07" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">尝试使用箭头函数。箭头函数没有自己的<code class="eh jw jx jy jz b">this</code>或<code class="eh jw jx jy jz b">arguments</code>绑定。因此，当我在函数定义中调用<code class="eh jw jx jy jz b">this</code>时，它并没有像我天真地期望的那样引用数组对象本身。这是正确的做法。这个<a class="ae ka" href="https://stackoverflow.com/questions/34361379/arrow-function-vs-function-declaration-expressions-are-they-equivalent-exch" rel="noopener ugc nofollow" target="_blank"> StackOverflow帖子</a>有解释。</p><pre class="lc ld le lf fq lg jz lh li aw lj dt"><span id="178a" class="kc kd hu jz b fv lk ll l lm ln">Array.prototype.myForEach = function (callback) {<br/>  for (let i = 0; i &lt; arr.length; i++) {<br/>    callback(arr[i])<br/>  }<br/>}</span><span id="6cef" class="kc kd hu jz b fv lo ll l lm ln">// log each item of the array<br/>arr.myForEach(console.log)</span></pre><p id="079a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">太美了。既然我们已经了解了这些机制，我们可以继续讨论其他高阶函数了。</p><h2 id="59dd" class="kc kd hu bd ke kf kg kh ki kj kk kl km jj kn ko kp jn kq kr ks jr kt ku kv kw dt translated">我的地图</h2><p id="df22" class="pw-post-body-paragraph iy iz hu ja b jb kx jd je jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv hn dt translated">签名如下。假设我们有一个数字数组，想要得到这些数字的平方数组。</p><pre class="lc ld le lf fq lg jz lh li aw lj dt"><span id="a5ee" class="kc kd hu jz b fv lk ll l lm ln">let arr = [ 1, 2, 3, 4 ]</span><span id="7b4f" class="kc kd hu jz b fv lo ll l lm ln">let arrNew = arr.map(val =&gt; val * val)</span><span id="c26b" class="kc kd hu jz b fv lo ll l lm ln">// or <br/>const squareNumber = n =&gt; n * n<br/>let arrNew2 = arr.map(squareNumber)</span><span id="6029" class="kc kd hu jz b fv lo ll l lm ln">console.log(arrNew)<br/>// outputs [ 1, 4, 9, 16 ]</span></pre><p id="dbfc" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所以我们应用于一个数组:一个接受回调的函数，并返回一个新的数组。回调是一个接受输入值的函数，通常将输入值转换成其他值。</p><pre class="lc ld le lf fq lg jz lh li aw lj dt"><span id="0923" class="kc kd hu jz b fv lk ll l lm ln">Array.prototype.myMap = function(callback) {  <br/>  let ret = []<br/>  for (var i = 0; i &lt; this.length; i++) {<br/>    let newVal = callback(this[i])<br/>    ret.push(newVal)<br/>  }<br/>  return ret<br/>}</span></pre><p id="5846" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们遍历数组(由<code class="eh jw jx jy jz b">this</code>表示)，应用回调函数，并将结果值推送到一个新的数组上。并随后返回新数组。</p><p id="c2e0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们可以使用新的<code class="eh jw jx jy jz b">myForEach</code>函数更简洁地编写这个。</p><pre class="lc ld le lf fq lg jz lh li aw lj dt"><span id="c8e9" class="kc kd hu jz b fv lk ll l lm ln">Array.prototype.myMap = function(callback) {  <br/>  let ret = []<br/>  this.myForEach(val =&gt; ret.push(callback(val)))<br/>  return ret<br/>}</span></pre><p id="d37f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">继续前进。</p><h2 id="e2b5" class="kc kd hu bd ke kf kg kh ki kj kk kl km jj kn ko kp jn kq kr ks jr kt ku kv kw dt translated">我的过滤器</h2><p id="88b2" class="pw-post-body-paragraph iy iz hu ja b jb kx jd je jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv hn dt translated">现在我们开始掌握它的窍门了。这是过滤器调用签名。</p><pre class="lc ld le lf fq lg jz lh li aw lj dt"><span id="c2c8" class="kc kd hu jz b fv lk ll l lm ln">let people = [ <br/>  { 'name': 'Bob', 'age': 70 },<br/>  { 'name': 'Sue', 'age': 30 },<br/>  { 'name': 'Joe', 'age': 18 } ]</span><span id="3e2d" class="kc kd hu jz b fv lo ll l lm ln">let youngPeople = people.filter( person =&gt; person.age &lt; 69 )<br/>// returns array with two objects.<br/>//  [ { 'name': 'Sue', 'age': 30 },<br/>//  { 'name': 'Joe', 'age': 18 } ]</span><span id="f5fc" class="kc kd hu jz b fv lo ll l lm ln">// or<br/>const isYoung = person =&gt; person.age &lt; 59<br/>let youngPeople = people.filter(isYoung)</span></pre><p id="b02c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">因此，过滤器期望回调返回一个<code class="eh jw jx jy jz b">true</code>或<code class="eh jw jx jy jz b">false</code>，也称为谓词。该函数返回一个新数组。根据我们的经验，我们可以很快做出这个。</p><pre class="lc ld le lf fq lg jz lh li aw lj dt"><span id="c4be" class="kc kd hu jz b fv lk ll l lm ln">Array.prototype.myFilter = function(callback) {<br/>  let ret = []<br/>  this.myForEach( (val) =&gt; {<br/>    if (callback(val) === true) ret.push(val)<br/>  }<br/>  return ret<br/>}</span></pre><p id="90b1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">相当直接。注意，我可以写<code class="eh jw jx jy jz b">if (callback(val))</code>而不是<code class="eh jw jx jy jz b">if (callback(val) === true)</code>，但是我这样做是为了强调我们期望回调返回<code class="eh jw jx jy jz b">true</code>或<code class="eh jw jx jy jz b">false</code>。</p><h2 id="7b2a" class="kc kd hu bd ke kf kg kh ki kj kk kl km jj kn ko kp jn kq kr ks jr kt ku kv kw dt translated">myReduce</h2><p id="cbeb" class="pw-post-body-paragraph iy iz hu ja b jb kx jd je jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv hn dt translated">reduce函数对于grok来说有点复杂。课本上的reduce例子是对一个数组的元素求和。这就是它看起来的样子。</p><pre class="lc ld le lf fq lg jz lh li aw lj dt"><span id="9be1" class="kc kd hu jz b fv lk ll l lm ln">let arr = [ 1, 2, 3, 4 ]</span><span id="4ce2" class="kc kd hu jz b fv lo ll l lm ln">let sum = arr.reduce( (acc, val) =&gt; acc + val )</span><span id="83e4" class="kc kd hu jz b fv lo ll l lm ln">console.log(sum)<br/>// prints out 10</span></pre><p id="0c2f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">回调函数有两个参数，第一个参数通常被称为累加器，第二个参数是数组中特定项的值。在这个例子中，累加器保存了一个运行总数，并且随着数组的每次迭代，它的值被添加到累加器中。最后累加器包含了我们想要得到的值。</p><p id="1510" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这是这个函数最基本的形式。</p><pre class="lc ld le lf fq lg jz lh li aw lj dt"><span id="b478" class="kc kd hu jz b fv lk ll l lm ln">Array.prototype.myReduce = function (callback) {<br/>  let ret<br/>  this.myForEach( val =&gt; {<br/>    if (ret === undefined) ret = val<br/>    else ret = callback(ret, val)<br/>  }<br/>  return ret<br/>}</span></pre><p id="f0c6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这比我们上面定义的其他高阶函数要稍微复杂一些。注意我们需要检查<code class="eh jw jx jy jz b">ret</code>是否是<code class="eh jw jx jy jz b">undefined</code>。这又引出了另一个问题。JavaScript reduce函数允许您指定初始值。这不难添加到我们的功能中。我们只需在函数定义中添加一个init参数，并将<code class="eh jw jx jy jz b">ret</code>变量初始设置为<code class="eh jw jx jy jz b">init</code>。</p><pre class="lc ld le lf fq lg jz lh li aw lj dt"><span id="b74c" class="kc kd hu jz b fv lk ll l lm ln">Array.prototype.myReduce = function (callback, init) {<br/>  let ret = init<br/>  this.myForEach( val =&gt; {<br/>    if (ret === undefined) ret = val<br/>    else ret = callback(ret, val)<br/>  }<br/>  return ret<br/>}</span><span id="5ce3" class="kc kd hu jz b fv lo ll l lm ln">const sumTwoValues = (a, b) =&gt; a + b</span><span id="0bb4" class="kc kd hu jz b fv lo ll l lm ln">let sum = arr.myReduce( sumTwoValues , 0 ) // added 0 as an argument for initial value.</span><span id="4ac9" class="kc kd hu jz b fv lo ll l lm ln">console.log(sum)<br/>// prints 10</span></pre><h2 id="ea17" class="kc kd hu bd ke kf kg kh ki kj kk kl km jj kn ko kp jn kq kr ks jr kt ku kv kw dt translated">丰富</h2><p id="770c" class="pw-post-body-paragraph iy iz hu ja b jb kx jd je jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv hn dt translated">对于上面的每个函数，我们可以在回调签名中包含数组元素的索引，并使其在回调中可用。例如，这将允许我们执行以下操作。</p><pre class="lc ld le lf fq lg jz lh li aw lj dt"><span id="8029" class="kc kd hu jz b fv lk ll l lm ln">var arr = [ 1, 2, 3, 4, 5, 6 ]</span><span id="d58c" class="kc kd hu jz b fv lo ll l lm ln">arr.forEach( (val, idx) =&gt; { if (idx % 2 === 0) console.log(val) }<br/>// prints the value of every other item in the array.</span><span id="c712" class="kc kd hu jz b fv lo ll l lm ln">arr.map( (val, idx) =&gt; idx % 2 === 0 ? val * 2 : val * 3 )<br/>// create a new array where every even item has been doubled and every odd item has been trippled</span><span id="ff1e" class="kc kd hu jz b fv lo ll l lm ln">arr.map( (val, idx) =&gt; idx == 0) <br/>// return an array with only the first item </span></pre><p id="06fc" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">实现相当容易。在myForEach函数中，我们将值和索引传递给回调函数。由于我们在所有其他函数中使用myForEach，我们可以很容易地在回调调用中包含索引。</p><pre class="lc ld le lf fq lg jz lh li aw lj dt"><span id="ea57" class="kc kd hu jz b fv lk ll l lm ln">Array.prototype.myForEach = function(callback) {<br/>  for (var i = 0; i &lt; this.length; i++) {<br/>    callback(this[i], i)<br/>  }<br/>}</span><span id="afba" class="kc kd hu jz b fv lo ll l lm ln">Array.prototype.myMap = function(callback) {<br/>  let ret = []<br/>  this.myForEach((val, idx) =&gt; ret.push(callback(val, idx)))<br/>  return ret<br/>}</span><span id="5133" class="kc kd hu jz b fv lo ll l lm ln">Array.prototype.myFilter = function(callback) {<br/>  let ret = []<br/>  this.myForEach((val, idx) =&gt; { if (callback(val, idx)) ret.push(val)} )<br/>  return ret<br/>}</span><span id="b52f" class="kc kd hu jz b fv lo ll l lm ln">Array.prototype.myReduce = function(callback, init) {<br/>  let ret = init<br/>  this.myForEach( ( val, idx ) =&gt; {<br/>    if (ret === undefined) ret = val<br/>    else ret = callback(ret, val, idx)<br/>  })<br/>  return ret<br/>}</span></pre><p id="ad19" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们应该做的另一件事是一些错误检查。例如，我们应该确保回调是一个函数。我们应该检查数组是否不为空。</p><pre class="lc ld le lf fq lg jz lh li aw lj dt"><span id="ed3f" class="kc kd hu jz b fv lk ll l lm ln">Array.prototype.myForEach = function(callback) {<br/>  <!-- -->if (this == null) {<br/>    throw new TypeError('array is null')<br/>  }<br/>  if (typeof callback !== 'function') {<br/>      throw new TypeError(callback + ' is not a function'<br/>  }<br/>  for (var i = 0; i &lt; this.length; i++) {<br/>    callback(this[i], i)<br/>  }<br/>}</span><span id="a239" class="kc kd hu jz b fv lo ll l lm ln">Array.prototype.myMap = function(callback) {<br/>  <!-- -->if (this == null) {<br/>    throw new TypeError('array is null')<br/>  }<br/>  if (typeof callback !== 'function') {<br/>      throw new TypeError(callback + ' is not a function'<br/>  }<br/>  let ret = []<br/>  this.myForEach((val, idx) =&gt; ret.push(callback(val, idx)))<br/>  return ret<br/>}</span><span id="45b9" class="kc kd hu jz b fv lo ll l lm ln">Array.prototype.myFilter = function(callback) {<br/>    <!-- -->if (this == null) {<br/>    throw new TypeError('array is null')<br/>  }<br/>  if (typeof callback !== 'function') {<br/>      throw new TypeError(callback + ' is not a function'<br/>  }<br/>  <!-- -->let ret = []<br/>  this.myForEach((val, idx) =&gt; { if (callback(val, idx)) ret.push(val)} )<br/>  return ret<br/>}</span><span id="4231" class="kc kd hu jz b fv lo ll l lm ln">Array.prototype.myReduce = function(callback, init) {<br/>  <!-- -->if (this == null) {<br/>    throw new TypeError('array is null')<br/>  }<br/>  if (typeof callback !== 'function') {<br/>      throw new TypeError(callback + ' is not a function'<br/>  }<br/>  let ret = init<br/>  this.myForEach( ( val, idx ) =&gt; {<br/>    if (ret === undefined) ret = val<br/>    else ret = callback(ret, val, idx)<br/>  })<br/>  return ret<br/>}</span></pre><p id="c9e9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">结束了。实际的Javascript <code class="eh jw jx jy jz b">forEach</code>、<code class="eh jw jx jy jz b">map</code>、<code class="eh jw jx jy jz b">filter</code>和<code class="eh jw jx jy jz b">reduce</code>函数更加复杂。但是通过编写这个基本实现，您可以更好地理解它们是如何工作的。</p><p id="307d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果你喜欢它，给我一些爱，点击下面的心。</p><figure class="lc ld le lf fq iv"><div class="bz el l di"><div class="lp lq l"/></div></figure></div></div>    
</body>
</html>