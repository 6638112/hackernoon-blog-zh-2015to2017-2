<html>
<head>
<title>Testing React components with Jest and Enzyme</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Jest和酶测试反应组分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/testing-react-components-with-jest-and-enzyme-41d592c174f?source=collection_archive---------0-----------------------#2016-12-06">https://medium.com/hackernoon/testing-react-components-with-jest-and-enzyme-41d592c174f?source=collection_archive---------0-----------------------#2016-12-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="917f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">【2019年8月:这篇文章过时了，查一下 <a class="ae jp" href="https://blog.sapegin.me/all/react-testing-2-jest-and-enzyme/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">我的关于用Jest和酶测试React组件的新文章</strong> </a> <strong class="it hv">。</strong></p></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><p id="9108" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">【2017年10月:文章更新为React 16和Enzyme 3。</p></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><p id="7f25" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有些人说测试React组件是无用的，在许多情况下确实如此，但是在一些情况下我认为它是有用的:</p><ul class=""><li id="dee4" class="jx jy hu it b iu iv iy iz jc jz jg ka jk kb jo kc kd ke kf dt translated">组件库，</li><li id="c967" class="jx jy hu it b iu kg iy kh jc ki jg kj jk kk jo kc kd ke kf dt translated">开源项目，</li><li id="b307" class="jx jy hu it b iu kg iy kh jc ki jg kj jk kk jo kc kd ke kf dt translated">与第三方组件集成，</li><li id="d0ff" class="jx jy hu it b iu kg iy kh jc ki jg kj jk kk jo kc kd ke kf dt translated">错误，以防止倒退。</li></ul><p id="41a6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我尝试了许多工具，最终找到了一个我非常喜欢的组合，并向其他开发人员推荐:</p><ul class=""><li id="4930" class="jx jy hu it b iu iv iy iz jc jz jg ka jk kb jo kc kd ke kf dt translated"><a class="ae jp" href="https://facebook.github.io/jest/" rel="noopener ugc nofollow" target="_blank"> Jest </a>，试跑者；</li><li id="3abf" class="jx jy hu it b iu kg iy kh jc ki jg kj jk kk jo kc kd ke kf dt translated"><a class="ae jp" href="http://airbnb.io/enzyme/" rel="noopener ugc nofollow" target="_blank">酶</a>，用于反应的测试工具；</li><li id="f1be" class="jx jy hu it b iu kg iy kh jc ki jg kj jk kk jo kc kd ke kf dt translated"><a class="ae jp" href="https://github.com/adriantoine/enzyme-to-json" rel="noopener ugc nofollow" target="_blank">酶到json </a>为Jest快照匹配器转换酶包装器。</li></ul><p id="a408" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我的大部分测试中，我使用Jest快照进行浅层渲染。</p><figure class="km kn ko kp fq kq fe ff paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="fe ff kl"><img src="../Images/da2f858961f6a107a68b0ea1e33a6240.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uzyh_xxWJkTYZC3riCpHhg.png"/></div></div><figcaption class="kx ky fg fe ff kz la bd b be z ek">Snapshot testing in Jest</figcaption></figure><h2 id="2bc1" class="lb lc hu bd ld le lf lg lh li lj lk ll jc lm ln lo jg lp lq lr jk ls lt lu lv dt translated">浅层渲染</h2><p id="da65" class="pw-post-body-paragraph ir is hu it b iu lw iw ix iy lx ja jb jc ly je jf jg lz ji jj jk ma jm jn jo hn dt translated">浅层渲染只渲染组件本身，而不渲染其子组件。所以如果你改变了子组件中的一些东西，它不会改变你的组件的浅层输出。或者引入到子组件中的一个bug不会破坏组件的测试。它也不需要DOM。</p><p id="2b44" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，该组件:</p><pre class="km kn ko kp fq mb mc md me aw mf dt"><span id="c641" class="lb lc hu mc b fv mg mh l mi mj">const ButtonWithIcon = ({icon, children}) =&gt; (<br/>    &lt;button&gt;&lt;Icon icon={icon} /&gt;{children}&lt;/button&gt;<br/>);</span></pre><p id="379b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">会被反应成这样:</p><pre class="km kn ko kp fq mb mc md me aw mf dt"><span id="bb87" class="lb lc hu mc b fv mg mh l mi mj">&lt;button&gt;<br/>    &lt;i class="icon icon_coffee"&gt;&lt;/i&gt;<br/>    Hello Jest!<br/>&lt;/button&gt;</span></pre><p id="3e6c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是像这样用浅显的渲染:</p><pre class="km kn ko kp fq mb mc md me aw mf dt"><span id="b13d" class="lb lc hu mc b fv mg mh l mi mj">&lt;button&gt;<br/>    &lt;Icon icon="coffee" /&gt;<br/>    Hello Jest!<br/>&lt;/button&gt;</span></pre><p id="e438" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，没有呈现图标组件。</p><h2 id="b407" class="lb lc hu bd ld le lf lg lh li lj lk ll jc lm ln lo jg lp lq lr jk ls lt lu lv dt translated">快照测试</h2><p id="d329" class="pw-post-body-paragraph ir is hu it b iu lw iw ix iy lx ja jb jc ly je jf jg lz ji jj jk ma jm jn jo hn dt translated">Jest快照就像那些带有由文本字符组成的窗口和按钮的旧文本ui:它是存储在文本文件中的组件的渲染输出。</p><p id="4088" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您告诉Jest，您希望确保该组件的输出永远不会意外更改，Jest将它保存到一个文件中，如下所示:</p><pre class="km kn ko kp fq mb mc md me aw mf dt"><span id="2e2a" class="lb lc hu mc b fv mg mh l mi mj">exports[`test should render a label 1`] = `<br/>&lt;label<br/>  className="isBlock"&gt;<br/>  Hello Jest!<br/>&lt;/label&gt;<br/>`;<br/><br/>exports[`test should render a small label 1`] = `<br/>&lt;label<br/>  className="isBlock isSmall"&gt;<br/>  Hello Jest!<br/>&lt;/label&gt;<br/>`;</span></pre><p id="8000" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每次你改变你的标记Jest会显示一个差异，并要求你更新一个快照，如果改变是有意的。</p><p id="c060" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Jest在_ _ snapshot _ _/label . spec . js . snap之类的文件中存储测试快照，您需要在代码中提交它们。</p><h2 id="22b2" class="lb lc hu bd ld le lf lg lh li lj lk ll jc lm ln lo jg lp lq lr jk ls lt lu lv dt translated">为什么开玩笑</h2><ul class=""><li id="fc9c" class="jx jy hu it b iu lw iy lx jc mk jg ml jk mm jo kc kd ke kf dt translated">非常快。</li><li id="1dae" class="jx jy hu it b iu kg iy kh jc ki jg kj jk kk jo kc kd ke kf dt translated">快照测试。</li><li id="f8de" class="jx jy hu it b iu kg iy kh jc ki jg kj jk kk jo kc kd ke kf dt translated">令人敬畏的交互式观察模式，只重新运行与您的更改相关的测试。</li><li id="e68b" class="jx jy hu it b iu kg iy kh jc ki jg kj jk kk jo kc kd ke kf dt translated">有用的失败消息。</li><li id="23cc" class="jx jy hu it b iu kg iy kh jc ki jg kj jk kk jo kc kd ke kf dt translated">配置简单。</li><li id="e0c0" class="jx jy hu it b iu kg iy kh jc ki jg kj jk kk jo kc kd ke kf dt translated">嘲笑和间谍。</li><li id="24be" class="jx jy hu it b iu kg iy kh jc ki jg kj jk kk jo kc kd ke kf dt translated">使用单一命令行开关的覆盖报告。</li><li id="7dd7" class="jx jy hu it b iu kg iy kh jc ki jg kj jk kk jo kc kd ke kf dt translated">积极发展。</li><li id="c9c4" class="jx jy hu it b iu kg iy kh jc ki jg kj jk kk jo kc kd ke kf dt translated">不可能在Chai中默写错误的断言像expect(foo).to.be.a.function而不是expect(foo).to.be.a('function ')因为在(正确的)expect(foo)to . be . true之后写是唯一自然的事情。</li></ul><h2 id="aa10" class="lb lc hu bd ld le lf lg lh li lj lk ll jc lm ln lo jg lp lq lr jk ls lt lu lv dt translated">为什么是酶</h2><ul class=""><li id="7d24" class="jx jy hu it b iu lw iy lx jc mk jg ml jk mm jo kc kd ke kf dt translated">使用浅层渲染、静态渲染标记或DOM渲染的便利工具。</li><li id="1b1c" class="jx jy hu it b iu kg iy kh jc ki jg kj jk kk jo kc kd ke kf dt translated">类似jQuery的API，用于查找元素、读取属性等。</li></ul><h2 id="9e23" class="lb lc hu bd ld le lf lg lh li lj lk ll jc lm ln lo jg lp lq lr jk ls lt lu lv dt translated">安装</h2><p id="7ecf" class="pw-post-body-paragraph ir is hu it b iu lw iw ix iy lx ja jb jc ly je jf jg lz ji jj jk ma jm jn jo hn dt translated">首先安装所有依赖项，包括对等依赖项:</p><pre class="km kn ko kp fq mb mc md me aw mf dt"><span id="18e4" class="lb lc hu mc b fv mg mh l mi mj">npm install --save-dev jest react-test-renderer enzyme enzyme-adapter-react-16 enzyme-to-json</span></pre><p id="73dc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您还需要<a class="ae jp" href="https://github.com/facebook/jest/tree/master/packages/babel-jest" rel="noopener ugc nofollow" target="_blank">巴别塔-玩笑</a>代替巴别塔，以及<a class="ae jp" href="https://github.com/kulshekhar/ts-jest" rel="noopener ugc nofollow" target="_blank">ts-玩笑</a>代替打字稿。</p><p id="7381" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">更新您的包。json:</p><pre class="km kn ko kp fq mb mc md me aw mf dt"><span id="2a53" class="lb lc hu mc b fv mg mh l mi mj">"scripts": {<br/>  "test": "jest",<br/>  "test:watch": "jest --watch",<br/>  "test:coverage": "jest --coverage"<br/>},<br/>"jest": {<br/>  "setupFiles": ["./test/jestsetup.js"],<br/>  "snapshotSerializers": ["enzyme-to-json/serializer"]<br/>}</span></pre><p id="f340" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">snapshotSerializers允许您将酶包装器直接传递给Jest的快照匹配器，而无需通过调用酶到json的toJson函数来手动转换它们。</p><p id="5449" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">创建一个测试/jestsetup.js文件来定制Jest环境(参见上面的setupFiles):</p><pre class="km kn ko kp fq mb mc md me aw mf dt"><span id="73ce" class="lb lc hu mc b fv mg mh l mi mj">import Enzyme, { shallow, render, mount } from 'enzyme';<br/>import Adapter from 'enzyme-adapter-react-16';</span><span id="8b71" class="lb lc hu mc b fv mn mh l mi mj">// React 16 Enzyme adapter<br/>Enzyme.configure({ adapter: new Adapter() });</span><span id="fda2" class="lb lc hu mc b fv mn mh l mi mj">// Make Enzyme functions available in all test files without importing<br/>global.shallow = shallow;<br/>global.render = render;<br/>global.mount = mount;</span></pre><p id="a023" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于CSS模块，还可以添加到包中的jest部分。</p><pre class="km kn ko kp fq mb mc md me aw mf dt"><span id="164a" class="lb lc hu mc b fv mg mh l mi mj">"jest": {<br/>  "moduleNameMapper": {<br/>    "^.+\\.(css|scss)$": "identity-obj-proxy"<br/>  }<br/>}</span></pre><p id="2886" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后运行:</p><pre class="km kn ko kp fq mb mc md me aw mf dt"><span id="595e" class="lb lc hu mc b fv mg mh l mi mj">npm install --save-dev identity-obj-proxy</span></pre><p id="af8d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意<a class="ae jp" href="https://github.com/keyanzhang/identity-obj-proxy" rel="noopener ugc nofollow" target="_blank"> identity-obj-proxy </a>要求节点4和5有节点-协调-代理标志。</p><h2 id="f45b" class="lb lc hu bd ld le lf lg lh li lj lk ll jc lm ln lo jg lp lq lr jk ls lt lu lv dt translated">写作测试</h2><h2 id="23d2" class="lb lc hu bd ld le lf lg lh li lj lk ll jc lm ln lo jg lp lq lr jk ls lt lu lv dt translated">测试基本组件渲染</h2><p id="f7be" class="pw-post-body-paragraph ir is hu it b iu lw iw ix iy lx ja jb jc ly je jf jg lz ji jj jk ma jm jn jo hn dt translated">对于大多数非交互式组件来说，这已经足够了:</p><pre class="km kn ko kp fq mb mc md me aw mf dt"><span id="9c05" class="lb lc hu mc b fv mg mh l mi mj">test('render a label', () =&gt; {<br/>    const wrapper = shallow(<br/>        &lt;Label&gt;Hello Jest!&lt;/Label&gt;<br/>    );<br/>    expect(wrapper).toMatchSnapshot();<br/>});<br/><br/>test('render a small label', () =&gt; {<br/>    const wrapper = shallow(<br/>        &lt;Label small&gt;Hello Jest!&lt;/Label&gt;<br/>    );<br/>    expect(wrapper).toMatchSnapshot();<br/>});<br/><br/>test('render a grayish label', () =&gt; {<br/>    const wrapper = shallow(<br/>        &lt;Label light&gt;Hello Jest!&lt;/Label&gt;<br/>    );<br/>    expect(wrapper).toMatchSnapshot();<br/>});</span></pre><h2 id="f4b6" class="lb lc hu bd ld le lf lg lh li lj lk ll jc lm ln lo jg lp lq lr jk ls lt lu lv dt translated">测试道具</h2><p id="d38d" class="pw-post-body-paragraph ir is hu it b iu lw iw ix iy lx ja jb jc ly je jf jg lz ji jj jk ma jm jn jo hn dt translated">有时，您想更明确地看到测试中的真实值。在这种情况下，使用酶API和常规的Jest断言:</p><pre class="km kn ko kp fq mb mc md me aw mf dt"><span id="7737" class="lb lc hu mc b fv mg mh l mi mj">test('render a document title', () =&gt; {<br/>    const wrapper = shallow(<br/>        &lt;DocumentTitle title="Events" /&gt;<br/>    );<br/>    expect(wrapper.prop('title')).toEqual('Events');<br/>});<br/><br/>test('render a document title and a parent title', () =&gt; {<br/>    const wrapper = shallow(<br/>        &lt;DocumentTitle title="Events" parent="Event Radar" /&gt;<br/>    );<br/>    expect(wrapper.prop('title')).toEqual('Events — Event Radar');<br/>});</span></pre><p id="2099" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在某些情况下，您不能使用快照。例如，如果您有随机身份证或类似的东西:</p><pre class="km kn ko kp fq mb mc md me aw mf dt"><span id="9238" class="lb lc hu mc b fv mg mh l mi mj">test('render a popover with a random ID', () =&gt; {<br/>    const wrapper = shallow(<br/>        &lt;Popover&gt;Hello Jest!&lt;/Popover&gt;<br/>    );<br/>    expect(wrapper.prop('id')).toMatch(/Popover\d+/);<br/>});</span></pre><h2 id="a004" class="lb lc hu bd ld le lf lg lh li lj lk ll jc lm ln lo jg lp lq lr jk ls lt lu lv dt translated">测试事件</h2><p id="9e13" class="pw-post-body-paragraph ir is hu it b iu lw iw ix iy lx ja jb jc ly je jf jg lz ji jj jk ma jm jn jo hn dt translated">您可以模拟单击或更改等事件，然后将组件与快照进行比较:</p><pre class="km kn ko kp fq mb mc md me aw mf dt"><span id="4328" class="lb lc hu mc b fv mg mh l mi mj">test('render Markdown in preview mode', () =&gt; {<br/>    const wrapper = shallow(<br/>        &lt;MarkdownEditor value="*Hello* Jest!" /&gt;<br/>    );<br/><br/>    expect(wrapper).toMatchSnapshot();<br/><br/>    wrapper.find('[name="toggle-preview"]').simulate('click');<br/><br/>    expect(wrapper).toMatchSnapshot();<br/>});</span></pre><p id="8fa2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有时，您希望与子组件中的元素进行交互，以测试组件中的效果。为此，您需要使用酶的挂载方法进行适当的DOM渲染:</p><pre class="km kn ko kp fq mb mc md me aw mf dt"><span id="2183" class="lb lc hu mc b fv mg mh l mi mj">test('open a code editor', () =&gt; {<br/>    const wrapper = mount(<br/>        &lt;Playground code={code} /&gt;<br/>    );<br/><br/>    expect(wrapper.find('.ReactCodeMirror')).toHaveLength(0);<br/><br/>    wrapper.find('button').simulate('click');<br/><br/>    expect(wrapper.find('.ReactCodeMirror')).toHaveLength(1);<br/>});</span></pre><h2 id="c1c3" class="lb lc hu bd ld le lf lg lh li lj lk ll jc lm ln lo jg lp lq lr jk ls lt lu lv dt translated">测试事件处理程序</h2><p id="51ae" class="pw-post-body-paragraph ir is hu it b iu lw iw ix iy lx ja jb jc ly je jf jg lz ji jj jk ma jm jn jo hn dt translated">类似于事件测试，但是使用Jest的模拟函数来测试事件处理程序本身，而不是用快照来测试组件的呈现输出:</p><pre class="km kn ko kp fq mb mc md me aw mf dt"><span id="f940" class="lb lc hu mc b fv mg mh l mi mj">test('pass a selected value to the onChange handler', () =&gt; {<br/>    const value = '2';<br/>    const onChange = jest.fn();<br/>    const wrapper = shallow(<br/>        &lt;Select items={ITEMS} onChange={onChange} /&gt;<br/>    );<br/><br/>    expect(wrapper).toMatchSnapshot();<br/><br/>        wrapper.find('select').simulate('change', {<br/>        target: { value },<br/>    });<br/><br/>    expect(onChange).toBeCalledWith(value);<br/>});</span></pre><h2 id="5eba" class="lb lc hu bd ld le lf lg lh li lj lk ll jc lm ln lo jg lp lq lr jk ls lt lu lv dt translated">不仅是JSX</h2><p id="d860" class="pw-post-body-paragraph ir is hu it b iu lw iw ix iy lx ja jb jc ly je jf jg lz ji jj jk ma jm jn jo hn dt translated">Jest快照与JSON一起工作，所以您可以像测试组件一样测试任何返回JSON的函数:</p><pre class="km kn ko kp fq mb mc md me aw mf dt"><span id="7bc1" class="lb lc hu mc b fv mg mh l mi mj">test('accept custom properties', () =&gt; {<br/>    const wrapper = shallow(<br/>        &lt;Layout<br/>            flexBasis={0}<br/>            flexGrow={1}<br/>            flexShrink={1}<br/>            flexWrap="wrap"<br/>            justifyContent="flex-end"<br/>            alignContent="center"<br/>            alignItems="center"<br/>        /&gt;<br/>    );<br/>    expect(wrapper.prop('style')).toMatchSnapshot();<br/>});</span></pre><h2 id="7015" class="lb lc hu bd ld le lf lg lh li lj lk ll jc lm ln lo jg lp lq lr jk ls lt lu lv dt translated">调试和故障排除</h2><p id="8937" class="pw-post-body-paragraph ir is hu it b iu lw iw ix iy lx ja jb jc ly je jf jg lz ji jj jk ma jm jn jo hn dt translated"><strong class="it hv">调试浅层渲染器输出</strong></p><p id="3fd3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用酶的调试方法打印浅渲染器的输出:</p><pre class="km kn ko kp fq mb mc md me aw mf dt"><span id="aeaf" class="lb lc hu mc b fv mg mh l mi mj">const wrapper = shallow(/*~*/);<br/>console.log(wrapper.debug());</span></pre><p id="c6f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">在启用承保范围的情况下未通过测试</strong></p><p id="ce1d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当您的测试因coverage标志为diff而失败时，如下所示:</p><pre class="km kn ko kp fq mb mc md me aw mf dt"><span id="78c8" class="lb lc hu mc b fv mg mh l mi mj">-&lt;Button<br/>+&lt;Component</span></pre><p id="843d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尝试用常规函数替换箭头函数组件:</p><pre class="km kn ko kp fq mb mc md me aw mf dt"><span id="fb1b" class="lb lc hu mc b fv mg mh l mi mj">- export default const Button = ({ children }) =&gt; {<br/>+ export default function Button({ children }) {</span></pre><p id="cc9d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">请求动画帧错误</strong></p><p id="87cb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">运行测试时，您可能会看到类似以下的错误:</p><pre class="km kn ko kp fq mb mc md me aw mf dt"><span id="65f0" class="lb lc hu mc b fv mg mh l mi mj">console.error node_modules/fbjs/lib/warning.js:42<br/>  Warning: React depends on requestAnimationFrame. Make sure that you load a polyfill in older browsers. <a class="ae jp" href="http://fb.me/react-polyfills" rel="noopener ugc nofollow" target="_blank">http://fb.me/react-polyfills</a></span></pre><p id="2680" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">反应16 <a class="ae jp" href="https://reactjs.org/docs/javascript-environment-requirements.html" rel="noopener ugc nofollow" target="_blank">取决于</a> <code class="eh mo mp mq mc b"><a class="ae jp" href="https://reactjs.org/docs/javascript-environment-requirements.html" rel="noopener ugc nofollow" target="_blank">requestAnimationFrame</a></code>，所以您需要在测试中加入<a class="ae jp" href="https://github.com/chrisdickinson/raf" rel="noopener ugc nofollow" target="_blank">一种多晶型</a>:</p><pre class="km kn ko kp fq mb mc md me aw mf dt"><span id="4d8d" class="lb lc hu mc b fv mg mh l mi mj">// test/jestsetup.js<br/>import 'raf/polyfill';</span></pre><h2 id="7e58" class="lb lc hu bd ld le lf lg lh li lj lk ll jc lm ln lo jg lp lq lr jk ls lt lu lv dt translated">资源</h2><ul class=""><li id="8fb8" class="jx jy hu it b iu lw iy lx jc mk jg ml jk mm jo kc kd ke kf dt translated"><a class="ae jp" href="https://github.com/sapegin/jest-cheat-sheet" rel="noopener ugc nofollow" target="_blank">玩笑备忘单</a></li><li id="4267" class="jx jy hu it b iu kg iy kh jc ki jg kj jk kk jo kc kd ke kf dt translated">马克斯·斯托伊伯的《测试React应用程序》</li><li id="a8d4" class="jx jy hu it b iu kg iy kh jc ki jg kj jk kk jo kc kd ke kf dt translated"><a class="ae jp" rel="noopener" href="/@kentcdodds/migrating-to-jest-881f75366e7e#.pc4s5ut6z">迁移到笑话</a>作者肯特·c·多兹</li><li id="a72f" class="jx jy hu it b iu kg iy kh jc ki jg kj jk kk jo kc kd ke kf dt translated"><a class="ae jp" href="http://browniefed.com/blog/migrating-ava-to-jest/" rel="noopener ugc nofollow" target="_blank">杰森·布朗将艾娃迁移到Jest </a></li></ul></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><p id="d9bb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">感谢<a class="ae jp" href="http://cpojer.net/" rel="noopener ugc nofollow" target="_blank">克里斯·波杰尔</a>、<a class="ae jp" href="http://mxstbr.com/" rel="noopener ugc nofollow" target="_blank">马克斯·斯托伊伯</a>和安娜·格鲁斯的校对和评论。</p><p id="670c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">页（page的缩写）查看我的开源项目:<a class="ae jp" href="https://github.com/sapegin/react-styleguidist" rel="noopener ugc nofollow" target="_blank"> React Styleguidist </a>，一个带有热重载开发服务器的组件样式向导生成器。</p><p id="b1f5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">订阅我的简讯:</strong><a class="ae jp" href="https://tinyletter.com/sapegin" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">https://tinyletter.com/sapegin</strong></a></p><blockquote class="mr ms mt"><p id="7491" class="ir is mu it b iu iv iw ix iy iz ja jb mv jd je jf mw jh ji jj mx jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是T21家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is mu it b iu iv iw ix iy iz ja jb mv jd je jf mw jh ji jj mx jl jm jn jo hn dt translated">要了解更多信息，请阅读我们的“关于”页面、<a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">喜欢/在脸书上给我们发消息</a>，或者简单地发送<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is mu it b iu iv iw ix iy iz ja jb mv jd je jf mw jh ji jj mx jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>