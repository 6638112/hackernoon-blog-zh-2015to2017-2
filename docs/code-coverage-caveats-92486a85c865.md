# 代码覆盖率警告

> 原文：<https://medium.com/hackernoon/code-coverage-caveats-92486a85c865>

对语句级代码覆盖测试的一个相对常见的[批评](https://hackernoon.com/tagged/criticism)是，即使所有的语句可能已经被执行(即，你有 100%的语句覆盖率)，你也可能没有命中所有可能的*执行路径*。抽象地理解这一点是一回事，但昨天我遇到了一个案例，在一个[的实际场景中，这一点对我来说非常清楚。](https://hackernoon.com/tagged/practical)

我有一个类似如下的函数:

您会注意到，根据 *a* (1，2，或者都不是)和 *b* (2，或者都不是 2)的值，该函数有六种可能的路径。如果我们在这里运行一个语句级的覆盖率测试，那么我们能很清楚地发现哪些情况是正确的，哪些情况是错误的。

所以我在这里，使用我的覆盖工具来帮助确保我的测试用例没有遗漏任何东西。假设我正在添加测试，它们看起来像这样:

我运行了测试，我方便的代码覆盖工具提醒我仍然缺少两条语句。谢谢，代码覆盖工具！

但是！看那些内部的树枝！他们彼此不是非常相似吗？！为什么我们不把它们分解成一个函数，就像这样:

啊，真可爱。我们越来越少重复自己。但是等等！让我们来看看我们的测试:

哦不！我的语句覆盖率上升到了 100%,而没有添加任何新的测试！呀！还好我已经有了一个相当全面的测试列表，因为如果我只是依赖我的代码覆盖工具，我会有麻烦的！

在这种情况下，分支覆盖测试会有所帮助，但不幸的是，它们运行起来非常耗时，所以我不会在每次添加测试后都运行它。

这个故事的寓意是，即使是代码结构的简单变化也可以人为地提高您的覆盖率数字，所以您应该有所保留地接受这些数字——尤其是在编写新的测试和重构时。

示例的完整源代码: