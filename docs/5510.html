<html>
<head>
<title>Evil things you do with redux — dispatch in updating lifecycle methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你用redux做的坏事——在更新生命周期方法中调度</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/evil-things-you-do-with-redux-dispatch-in-updating-lifecycle-methods-ad116de882d4?source=collection_archive---------3-----------------------#2017-07-31">https://medium.com/hackernoon/evil-things-you-do-with-redux-dispatch-in-updating-lifecycle-methods-ad116de882d4?source=collection_archive---------3-----------------------#2017-07-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="2674" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我工作的代码库中，我们正在做一件邪恶的事情。一些不该做的事。我们在<a class="ae jp" href="https://facebook.github.io/react/docs/react-component.html#updating" rel="noopener ugc nofollow" target="_blank"> React生命周期方法</a>中进行调度调用，例如componentWillReceiveProps、componentWillUpdate和componentDidUpdate。</p><p id="7ff4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里有一个这样的场景。我们有两个不同的组件来访问两种不同的状态。</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="5856" class="jz ka hu jv b fv kb kc l kd ke">class Address extends React.Component {<br/>  render() {<br/>    return &lt;input value={this.props.address} onChange={this.props.changeAddress}/&gt;;<br/>  }<br/>}</span><span id="83b7" class="jz ka hu jv b fv kf kc l kd ke">function mapStateToProps(state) {<br/>  return {<br/>    address: state.address<br/>  }<br/>}</span><span id="51b1" class="jz ka hu jv b fv kf kc l kd ke">function mapDispatchToProps(dispatch) {<br/>  return {<br/>    changeAddress: (address) =&gt; dispatch(changeAddress(address)),<br/>  }<br/>}</span><span id="5e9a" class="jz ka hu jv b fv kf kc l kd ke">connect(mapStateToProps, mapDispatchToProps)(Address);</span></pre></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><pre class="ju jv jw jx aw jy dt"><span id="cbb9" class="jz ka hu jv b fv kn ko kp kq kr kc l kd ke">class Zipcode extends React.Component {<br/>  render() {<br/>    return &lt;input value={this.props.zipcode} onChange={this.props.changeZipcode}/&gt;;<br/>  }<br/>}</span><span id="57cd" class="jz ka hu jv b fv kf kc l kd ke">function mapStateToProps(state) {<br/>  return {<br/>    zipcode: state.zipcode<br/>  }<br/>}</span><span id="a5d1" class="jz ka hu jv b fv kf kc l kd ke">function mapDispatchToProps(dispatch) {<br/>  return {<br/>    changeZipcode: (zipcode) =&gt; dispatch(changeZipcode(zipcode)),<br/>  }<br/>}</span><span id="57bf" class="jz ka hu jv b fv kf kc l kd ke">connect(mapStateToProps, mapDispatchToProps)(Zipcode);</span></pre><p id="18e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在假设我们想在address组件中添加一个警告，如果用户输入的地址不在他们输入的邮政编码中。我们将在redux状态下存储这些警报数据。我们有很多方法可以做到这一点。但是当(1)地址改变或者(2)邮政编码改变时，解决方案需要检查地址。</p><p id="f027" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的应用程序使用redux-saga，所以这些解决方案是从那个角度出发的。我还假设我们需要打一些<a class="ae jp" href="https://hackernoon.com/tagged/network" rel="noopener ugc nofollow" target="_blank">网络</a>电话来做实际的检查。因此，我们需要在一些异步中间件中完成这项工作。</p><h2 id="3382" class="jz ka hu bd ks kt ku kv kw kx ky kz la jc lb lc ld jg le lf lg jk lh li lj lk dt translated">解决方案1</h2><p id="1a2e" class="pw-post-body-paragraph ir is hu it b iu ll iw ix iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo hn dt translated">当调用changeZipcode或changeAddress时，我们调度另一个操作。例如，Zipcode组件的mapDispatchToProps函数将更改为:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="713e" class="jz ka hu jv b fv kb kc l kd ke">function mapDispatchToProps(dispatch) {<br/>  return {<br/>    changeZipcode: (zipcode) =&gt; {<br/>      dispatch(changeZipcode(zipcode));<br/>      dispatch(checkAddress());<br/>    }<br/>  }<br/>}</span></pre><p id="e195" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，我们有一个saga等待checkAddress动作根据邮政编码对地址进行实际检查，并更新一些状态以便在Address组件中呈现。</p><p id="34dd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我不太喜欢这个解决方案，因为changeZipcode和changeAddress都需要完全相同的逻辑。</p><h2 id="99a9" class="jz ka hu bd ks kt ku kv kw kx ky kz la jc lb lc ld jg le lf lg jk lh li lj lk dt translated">解决方案2</h2><p id="3000" class="pw-post-body-paragraph ir is hu it b iu ll iw ix iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo hn dt translated">也许我们只是有一个等待changeZipcode或changeAddress操作的传奇，并在这些操作发生时进行检查。现在我们不需要checkAddress操作。</p><h2 id="bad9" class="jz ka hu bd ks kt ku kv kw kx ky kz la jc lb lc ld jg le lf lg jk lh li lj lk dt translated">解决方案永远不要这样做</h2><p id="9aa6" class="pw-post-body-paragraph ir is hu it b iu ll iw ix iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo hn dt translated">我们是这样做的。邮政编码根本不会改变。相反，我们在Address上添加了一个<code class="eh lq lr ls jv b">componentWillReceiveProps</code>来检查地址或邮政编码是否改变。如果是，调度另一个操作来检查地址。</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="6d43" class="jz ka hu jv b fv kb kc l kd ke">class Address extends React.Component {<br/>  componentWillReceiveProps(nextProps) {<br/>    if (this.props.zipcode !== nextProps.zipCode || this.props.address !== nextProps.address) {<br/>      this.props.checkAddress();<br/>    }<br/>  }</span><span id="585c" class="jz ka hu jv b fv kf kc l kd ke">  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;p&gt;{this.props.addressAlert}&lt;/p&gt;<br/>        &lt;input value={this.props.address} onChange={this.props.changeAddress}/&gt;;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span><span id="81a4" class="jz ka hu jv b fv kf kc l kd ke">function mapStateToProps(state) {<br/>  return {<br/>    address: state.address,<br/>    addressAlert: state.addressAlert,<br/>    zipcode: state.zipcode,<br/>  }<br/>}</span><span id="4d02" class="jz ka hu jv b fv kf kc l kd ke">function mapDispatchToProps(dispatch) {<br/>  return {<br/>    changeAddress: (address) =&gt; dispatch(changeAddress(address)),<br/>    checkAddress: () =&gt; dispatch(checkAddress()),<br/>  }<br/>}</span><span id="b921" class="jz ka hu jv b fv kf kc l kd ke">connect(mapStateToProps, mapDispatchToProps)(Address);</span></pre><p id="ba4b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我第一次看到这个时，我感到不寒而栗。我抬头问了很多次为什么。感觉很不对劲。<strong class="it hv"> <em class="lt">它使组件比它应该知道的方式更多</em> </strong>。为什么Address又关心zipcode了？？</p><p id="4dcd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这可能看起来没那么糟糕。事实上，你可能会说这很好。Address关心zipcode，因为当zipcode改变时，它需要更新地址警告。但问题是。您的组件不应该考虑外部状态转换。这种担忧存在于<a class="ae jp" href="https://hackernoon.com/tagged/redux" rel="noopener ugc nofollow" target="_blank"> redux </a>的土地上，而且只有在那里。</p><h2 id="dad2" class="jz ka hu bd ks kt ku kv kw kx ky kz la jc lb lc ld jg le lf lg jk lh li lj lk dt translated">潜在的问题</h2><p id="849d" class="pw-post-body-paragraph ir is hu it b iu ll iw ix iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo hn dt translated">为了进一步说明我的观点，这里有一些潜在的问题。例如，您可能有一个非常热的状态，当它改变时，您的应用程序的很多部分都需要改变。您需要将该状态添加到关心它的每个组件中，然后编写componentWillReceiveProps check。当两个组件看到状态改变时，如何防止它们分派相同的动作？</p><p id="4030" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者更糟的是，你可以有一连串的渲染。</p><ol class=""><li id="e0ed" class="lu lv hu it b iu iv iy iz jc lw jg lx jk ly jo lz ma mb mc dt translated">组件A首先调度</li><li id="9070" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo lz ma mb mc dt translated">组件B从组件A的分派中观察状态的变化，并进行第二次分派</li><li id="8632" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo lz ma mb mc dt translated">组件C从组件B的分派中观察状态的变化，并进行第三次分派</li><li id="8106" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo lz ma mb mc dt translated">诸如此类。</li></ol><p id="8380" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您的应用程序可以经历这些多步转换，但是很难追溯开始整个转换的第一个动作。</p><p id="4cc7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后一件事。我并不是说这些更新生命周期的方法不好。当你的组件有自己的内部状态时，你绝对需要它们。或者在与非react库交互时需要做一些必要的DOM工作。但是它们应该<strong class="it hv"> <em class="lt">永远不要</em> </strong>用于启动你的redux状态的其他变化，以响应其他redux事件。</p><p id="f73b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">总之，让你的组件尽可能简单。最好的组件只是它的道具的功能。如果您曾经在更新生命周期方法(如componentWillReceiveProps、componentWillUpdate和componentDidUpdate)时看到调度调用，那么肯定有更好的方法。</p><figure class="jq jr js jt fq mi"><div class="bz el l di"><div class="mj mk l"/></div></figure></div></div>    
</body>
</html>