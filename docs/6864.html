<html>
<head>
<title>Angular NgRx: Resolving Route Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度NgRx:解析路径数据</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/angular-ngrx-resolving-route-data-53f88e0b8a5d?source=collection_archive---------1-----------------------#2017-10-08">https://medium.com/hackernoon/angular-ngrx-resolving-route-data-53f88e0b8a5d?source=collection_archive---------1-----------------------#2017-10-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/1206642b7253a18f3aef3bcdf13fa212.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gfsTpGpWE5dld34ygNZc6w.jpeg"/></div></div></figure><p id="188a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这些<strong class="je hv"> Angular NgRX </strong>故事系列中，我将介绍Angular应用程序的一些具体部分，这些部分用NgRX库实现起来并不明显。</p><p id="8dea" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://github.com/ngrx" rel="noopener ugc nofollow" target="_blank"> NgRx </a>是受<a class="ae ka" href="https://hackernoon.com/tagged/redux" rel="noopener ugc nofollow" target="_blank"> Redux </a>启发，针对角度应用的<a class="ae ka" href="http://reactivex.io/rxjs/" rel="noopener ugc nofollow" target="_blank"> RxJS </a>供电状态<a class="ae ka" href="https://hackernoon.com/tagged/management" rel="noopener ugc nofollow" target="_blank">管理</a>。它帮助我们管理应用程序的状态，并且比标准的面向服务的方法有一些好处。</p><h1 id="e78d" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">短篇小说</h1><p id="e563" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">如果你懒得阅读一步步的解释，请查看<a class="ae ka" href="https://github.com/kobvel/ng-ngrx-resolve" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> Github回购示例</strong> </a> <strong class="je hv"> </strong>以了解完整的实现。</p></div><div class="ab cl le lf hc lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="hn ho hp hq hr"><h1 id="abbd" class="kb kc hu bd kd ke ll kg kh ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky dt translated">问题</h1><p id="9c0f" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们正在用NgRX方法编写一个Angular应用程序。我们希望确保在进入<strong class="je hv"> Profile </strong>页面之前，我们有数据显示在该组件中。您可以从官方文档中查看<a class="ae ka" href="https://angular.io/api/router/Resolve" rel="noopener ugc nofollow" target="_blank">路由解析器的标准实现。我们将进一步了解如何通过NgRX状态管理来实现这一点。</a></p><figure class="lq lr ls lt fq iv"><div class="bz el l di"><div class="lu lv l"/></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">/app.routes.ts</figcaption></figure><h2 id="2215" class="ma kc hu bd kd mb mc md kh me mf mg kl jn mh mi kp jr mj mk kt jv ml mm kx mn dt translated">先决条件</h2><p id="23e1" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们来看看<code class="eh mo mp mq mr b">ProfileComponent</code> <strong class="je hv"> <em class="ms">。</em> </strong>来自<code class="eh mo mp mq mr b">ApiService</code> <em class="ms">的经典订阅可观察被网络调用返回。</em>不管<code class="eh mo mp mq mr b">ProfileComponent</code>使用这些数据是为了什么，让我们假设我们需要在进入组件之前确定数据存在。</p><figure class="lq lr ls lt fq iv"><div class="bz el l di"><div class="lu lv l"/></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">/profile/profile.component.ts</figcaption></figure><h2 id="047b" class="ma kc hu bd kd mb mc md kh me mf mg kl jn mh mi kp jr mj mk kt jv ml mm kx mn dt translated">定义减速器和动作</h2><p id="776e" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我个人倾向于以面向特征的结构保存文件。因此，我们将把新文件放在与放置<code class="eh mo mp mq mr b">ProfileComponent</code> <em class="ms"> </em>相同的文件夹中。这是我们创建了<code class="eh mo mp mq mr b">profile.reducer.ts</code>和<code class="eh mo mp mq mr b">profile.actions.ts</code>之后的一个新的文件夹结构。</p><p id="7601" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">配置文件文件夹结构</p><ul class=""><li id="cdde" class="mt mu hu je b jf jg jj jk jn mv jr mw jv mx jz my mz na nb dt translated"><em class="ms"> profile.component.ts </em></li><li id="cf18" class="mt mu hu je b jf nc jj nd jn ne jr nf jv ng jz my mz na nb dt translated"><em class="ms">profile.component.html</em></li><li id="2082" class="mt mu hu je b jf nc jj nd jn ne jr nf jv ng jz my mz na nb dt translated"><em class="ms"> profile.actions.ts </em></li><li id="6955" class="mt mu hu je b jf nc jj nd jn ne jr nf jv ng jz my mz na nb dt translated"><em class="ms"> profile.reducer.ts </em></li></ul><p id="5ab3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">看一看<code class="eh mo mp mq mr b">profile.actions.ts</code></p><figure class="lq lr ls lt fq iv"><div class="bz el l di"><div class="lu lv l"/></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">/profile/profile.actions.ts</figcaption></figure><ul class=""><li id="91ca" class="mt mu hu je b jf jg jj jk jn mv jr mw jv mx jz my mz na nb dt translated"><code class="eh mo mp mq mr b">IProfileActions</code> —我们将用来操作与配置文件实体相关的数据的动作列表。如果需要扩展功能，可以添加<code class="eh mo mp mq mr b">PORFILE_INIT</code>、<code class="eh mo mp mq mr b">PROFILE_CHANGE</code>等动作。目前，我们对触发配置文件数据更新的操作没有问题。</li><li id="0276" class="mt mu hu je b jf nc jj nd jn ne jr nf jv ng jz my mz na nb dt translated"><code class="eh mo mp mq mr b">UpdateAction</code> —是我们定义的单一动作类型，用来描述获取新数据的动作(<code class="eh mo mp mq mr b">IProfileData</code>类型)。</li></ul><p id="bba2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在让我们在<code class="eh mo mp mq mr b">profile.reducer.ts</code>中处理这个动作</p><figure class="lq lr ls lt fq iv"><div class="bz el l di"><div class="lu lv l"/></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">/profile/profile.reducer.ts</figcaption></figure><ul class=""><li id="588d" class="mt mu hu je b jf jg jj jk jn mv jr mw jv mx jz my mz na nb dt translated"><code class="eh mo mp mq mr b">IProfileState</code> —描述我们将如何扩展基本减速器的应用。</li><li id="fa76" class="mt mu hu je b jf nc jj nd jn ne jr nf jv ng jz my mz na nb dt translated"><code class="eh mo mp mq mr b">initialState</code>—<code class="eh mo mp mq mr b">ProfileData</code>的默认值</li><li id="3406" class="mt mu hu je b jf nc jj nd jn ne jr nf jv ng jz my mz na nb dt translated"><code class="eh mo mp mq mr b">reducer</code> —处理单个动作(更新)以描述在用一些有效负载触发动作后的状态变化</li></ul><h2 id="260d" class="ma kc hu bd kd mb mc md kh me mf mg kl jn mh mi kp jr mj mk kt jv ml mm kx mn dt translated">延伸根部减速器</h2><figure class="lq lr ls lt fq iv"><div class="bz el l di"><div class="lu lv l"/></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">/app.state.ts</figcaption></figure><p id="ee3b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们通过将reducer <em class="ms">对象</em>添加到all <code class="eh mo mp mq mr b">reducers</code> (LOC: 11 <code class="eh mo mp mq mr b">app.state.ts</code>)来组成应用程序的根状态。</p><figure class="lq lr ls lt fq iv"><div class="bz el l di"><div class="lu lv l"/></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">/app.module.ts</figcaption></figure><p id="9a24" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后一件事——我们用在<code class="eh mo mp mq mr b">storeReducers</code> (LOC: 8 <code class="eh mo mp mq mr b">app.module.ts</code>)之前创建的reducers来定义StoreModule。</p></div><div class="ab cl le lf hc lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="hn ho hp hq hr"><h1 id="02f9" class="kb kc hu bd kd ke ll kg kh ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky dt translated">设置路径解析器</h1><p id="6a26" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">现在，让我们将resolver放在我们希望等待数据加载的路线上。</p><figure class="lq lr ls lt fq iv"><div class="bz el l di"><div class="lu lv l"/></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">/app.routes.ts</figcaption></figure><p id="6c5f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">继续用相应的类创建<code class="eh mo mp mq mr b">profile.resolver.ts</code>，正如我们在上面的<code class="eh mo mp mq mr b">app.routes.ts</code>中在LOC: 8上命名的那样。这一行表示等待导航到<code class="eh mo mp mq mr b">/profile</code>路线，直到数据在<code class="eh mo mp mq mr b">ProfileResolver</code>中被解析，我们马上就要实现。</p><figure class="lq lr ls lt fq iv"><div class="bz el l di"><div class="lu lv l"/></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">/profile.resolver.ts</figcaption></figure><p id="7d1b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">新创建的实现<code class="eh mo mp mq mr b"><a class="ae ka" href="https://angular.io/api/router/Resolve" rel="noopener ugc nofollow" target="_blank">Resolve</a></code>接口的类，它要求我们定义<code class="eh mo mp mq mr b"><em class="ms">resolve</em></code>功能。该函数可以直接返回<strong class="je hv">承诺</strong>、<strong class="je hv">可观测</strong>或预期类型。</p><p id="e251" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">功能</strong> <code class="eh mo mp mq mr b"><strong class="je hv">waitForProfileDataToLoad</strong></code>:</p><p id="d650" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ms"> LOC 23: </em> Subscribe store监听<code class="eh mo mp mq mr b">profile</code>对象变化。</p><p id="ddcd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ms"> LOC 24: </em>从普通<code class="eh mo mp mq mr b">profile</code>对象中获取唯一的<code class="eh mo mp mq mr b">profileData</code>映射值</p><p id="1ebe" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ms"> LOC 25: </em>忽略不存在<code class="eh mo mp mq mr b">profileData</code>的所有触发器</p><p id="9052" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ms"> LOC 26: </em> take(1) —仅获取第一个值，只要我们需要一个值来解析路径</p><p id="a64e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">功能</strong> <code class="eh mo mp mq mr b"><strong class="je hv">initProfileData</strong></code>:</p><p id="a904" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">获取位于商店中的<code class="eh mo mp mq mr b">profile</code>对象的第一个值。如果没有值:</p><ol class=""><li id="09d0" class="mt mu hu je b jf jg jj jk jn mv jr mw jv mx jz nh mz na nb dt translated">使用<code class="eh mo mp mq mr b">getProfileData()</code>获取数据</li><li id="4d8d" class="mt mu hu je b jf nc jj nd jn ne jr nf jv ng jz nh mz na nb dt translated">将其转换为<strong class="je hv">承诺</strong>(我们只需要一次，所以没有订阅可观察的点)</li><li id="7877" class="mt mu hu je b jf nc jj nd jn ne jr nf jv ng jz nh mz na nb dt translated">用我们刚从服务器上得到的<code class="eh mo mp mq mr b">data</code>派遣<code class="eh mo mp mq mr b">UpdateAction</code></li></ol><h2 id="6fbc" class="ma kc hu bd kd mb mc md kh me mf mg kl jn mh mi kp jr mj mk kt jv ml mm kx mn dt translated">路由解析器结论</h2><p id="5542" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们通过从服务器获取数据来初始化数据，并为应用程序商店分派新的状态。同时，我们告诉我们的<strong class="je hv"> resolve </strong>函数监听商店的变化，并返回<strong class="je hv"> Observable </strong>和它将在商店中找到的第一个非空的<code class="eh mo mp mq mr b">ProfileData</code>。</p></div><div class="ab cl le lf hc lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="hn ho hp hq hr"><h1 id="86b4" class="kb kc hu bd kd ke ll kg kh ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky dt translated">在组件中使用路线数据</h1><p id="0788" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">最后，我们从路线快照中获取<code class="eh mo mp mq mr b">profileData</code>，假设<strong class="je hv">必须</strong>存在于此。</p><figure class="lq lr ls lt fq iv"><div class="bz el l di"><div class="lu lv l"/></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">/profile/profile.component.ts</figcaption></figure><h1 id="223c" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">结论</h1><p id="e8b7" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">NgRx驱动的应用程序使整个应用程序的数据流过程非常清晰。我希望这能给你一些解决路径分解问题的模式。</p><p id="fe1c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里有几件事你也可以做，以改善你的应用程序体验:</p><ul class=""><li id="b7b2" class="mt mu hu je b jf jg jj jk jn mv jr mw jv mx jz my mz na nb dt translated"><code class="eh mo mp mq mr b"><strong class="je hv">initProfileData</strong></code> <strong class="je hv"> — </strong>可以移动或移除，如果你有一些不同的地方来初始化数据。</li><li id="637a" class="mt mu hu je b jf nc jj nd jn ne jr nf jv ng jz my mz na nb dt translated">您可以实现spinner来显示路由解析器的运行情况。<a class="ae ka" href="https://github.com/kobvel/ng-ngrx-resolve/blob/master/src/app/app.component.html#L7" rel="noopener ugc nofollow" target="_blank">全回购示例</a>中有一些基本实现。</li><li id="4967" class="mt mu hu je b jf nc jj nd jn ne jr nf jv ng jz my mz na nb dt translated">如果您希望从另一个地方更改数据，您的组件可以直接订阅store。在这种情况下，您可以转换<code class="eh mo mp mq mr b">ProfileResolver</code>以返回<strong class="je hv">布尔值</strong>而不是数据。可能是掌握这个话题的很好的家庭作业😜。</li></ul><h2 id="94a8" class="ma kc hu bd kd mb mc md kh me mf mg kl jn mh mi kp jr mj mk kt jv ml mm kx mn dt translated"><a class="ae ka" href="https://github.com/kobvel/ng-ngrx-resolve" rel="noopener ugc nofollow" target="_blank"> Github回购示例</a></h2></div><div class="ab cl le lf hc lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="hn ho hp hq hr"><blockquote class="ni nj nk"><p id="a4c3" class="jc jd ms je b jf jg jh ji jj jk jl jm nl jo jp jq nm js jt ju nn jw jx jy jz hn dt translated">感谢阅读！如果你想让我写更多类似的故事，推荐这篇文章(点击❤按钮)。</p><p id="4030" class="jc jd ms je b jf jg jh ji jj jk jl jm nl jo jp jq nm js jt ju nn jw jx jy jz hn dt translated">把你的想法写在评论里，订阅我的<a class="ae ka" rel="noopener" href="/@kobvel">媒介</a>寻找更多故事。</p></blockquote><figure class="lq lr ls lt fq iv"><div class="bz el l di"><div class="no lv l"/></div></figure></div></div>    
</body>
</html>