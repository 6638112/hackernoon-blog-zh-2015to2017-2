<html>
<head>
<title>SICP 1.3.3: “Formulating Abstractions with Higher-Order Procedures: Procedures as Returned Values”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SICP 1.3.3:“用高阶过程制定抽象:作为返回值的过程”</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/sicp-1-3-3-formulating-abstractions-with-higher-order-procedures-procedures-as-general-methods-d78f39ad5eb7?source=collection_archive---------24-----------------------#2017-11-06">https://medium.com/hackernoon/sicp-1-3-3-formulating-abstractions-with-higher-order-procedures-procedures-as-general-methods-d78f39ad5eb7?source=collection_archive---------24-----------------------#2017-11-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="7a01" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">(计算机程序的结构和解释)</h2></div><p id="35f3" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我的1.3.3习题解答也在Github这里:<a class="ae kf" href="https://github.com/bolducp/SICP/tree/master/exercises/chapter_01/1.3_exercises" rel="noopener ugc nofollow" target="_blank">https://Github . com/bold UCP/SICP/tree/master/exercises/chapter _ 01/1.3 _ exercises</a></p></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><p id="d9be" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">本节主要通过两个具体的详细例子来说明<a class="ae kf" href="https://hackernoon.com/tagged/high-order-procedures" rel="noopener ugc nofollow" target="_blank">高阶程序</a>的有用性:<strong class="jl hv"> 1。)</strong>求一个方程的根<em class="kn">f</em>(<em class="kn">x</em>)= 0；<strong class="jl hv"> 2。)</strong>求函数的不动点。</p><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div class="fe ff ko"><img src="../Images/949e0eb2cb9e64b32aba10514a1c0444.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*_VUfIryAd-1KgsVJck3yfw.png"/></div><figcaption class="kw kx fg fe ff ky kz bd b be z ek"><a class="ae kf" href="https://thenounproject.com/term/f-cut-violin/1367014/" rel="noopener ugc nofollow" target="_blank">F Cut Violin by Cristian Scarlat</a> from the Noun Project</figcaption></figure><h2 id="21d5" class="la lb hu bd lc ld le lf lg lh li lj lk js ll lm ln jw lo lp lq ka lr ls lt lu dt translated">“用半区间法求方程的根”</h2><p id="7415" class="pw-post-body-paragraph jj jk hu jl b jm lv iv jo jp lw iy jr js lx ju jv jw ly jy jz ka lz kc kd ke hn dt translated"><em class="kn">半区间法</em>是一种简单但强大的技术，用于寻找方程f(x)=0f(x)=0的根，其中<em class="kn"> f </em>是一个连续函数。”(第67页)</p><p id="671e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这种方法的2页长的解释是一个简洁明了的读物，所以我不会在这里试图总结它。它演示了高阶函数的定义，以及如何在另一个也处理错误情况的函数中使用它。(参见第67–68页)</p><blockquote class="ma mb mc"><p id="0a09" class="jj jk kn jl b jm jn iv jo jp jq iy jr md jt ju jv me jx jy jz mf kb kc kd ke hn dt translated"><strong class="jl hv">寻找函数的固定点</strong></p><p id="b70d" class="jj jk kn jl b jm jn iv jo jp jq iy jr md jt ju jv me jx jy jz mf kb kc kd ke hn dt translated">如果x满足方程f(x)=x，那么数xx称为函数f的不动点</p></blockquote><p id="be83" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">本节回顾了第1.1.7节中用于寻找平方根的策略，该策略还实现了一个<a class="ae kf" href="https://hackernoon.com/tagged/procedure" rel="noopener ugc nofollow" target="_blank">过程</a>，用于递归应用一个函数，直到返回值与前一个返回值的差值在一个确定的范围内(在本例中，在0.00001以内)。本例还展示了一种方法(称为“平均转储”)，如果最初的实现导致无限循环，“在答案附近振荡”(第70页)，该方法可使后续的猜测以更小的间隔变化。</p><h1 id="bff5" class="mg lb hu bd lc mh mi mj lg mk ml mm lk ja mn jb ln jd mo je lq jg mp jh lt mq dt translated">练习</h1><p id="8b4b" class="pw-post-body-paragraph jj jk hu jl b jm lv iv jo jp lw iy jr js lx ju jv jw ly jy jz ka lz kc kd ke hn dt translated">我的答案在每个练习题下面的灰色文本块中提供。</p><h2 id="b36b" class="la lb hu bd lc ld le lf lg lh li lj lk js ll lm ln jw lo lp lq ka lr ls lt lu dt translated">练习1.35</h2><blockquote class="ma mb mc"><p id="2f76" class="jj jk kn jl b jm jn iv jo jp jq iy jr md jt ju jv me jx jy jz mf kb kc kd ke hn dt translated">证明黄金分割率(1.2.2节)是变换x↦1+1/x的不动点，并利用这一事实通过不动点方法计算ϕ。</p></blockquote><pre class="kp kq kr ks fq mr ms mt mu aw mv dt"><span id="fb50" class="la lb hu ms b fv mw mx l my mz">x = 1 + 1/x<br/>x^2 = x + 1</span><span id="697a" class="la lb hu ms b fv na mx l my mz">Turn this into a quadratic equation: x^2 - x - 1 = 0<br/>And use<a class="ae kf" href="https://en.wikipedia.org/wiki/Quadratic_equation" rel="noopener ugc nofollow" target="_blank"> quadratic equation factorization</a> to get the roots:<br/>x = 1/2(1 - √5)<br/>x = 1/2(1 + √5)</span><span id="3ad8" class="la lb hu ms b fv na mx l my mz">which shows what the golden ratio we learned in 1.2.2 (ϕ = (1 + √5) / 2 = 1.618033988)is a fixed point of the transformation x = 1 + 1/x.</span><span id="0191" class="la lb hu ms b fv na mx l my mz">We use the fixed-point function that SICP provides for us: </span><span id="3397" class="la lb hu ms b fv na mx l my mz">(define tolerance 0.00001)<br/><br/>(define (fixed-point f first-guess)<br/>  (define (close-enough? v1 v2)<br/>    (&lt; (abs (- v1 v2)) tolerance))<br/>  (define (try guess)<br/>    (let ((next (f guess)))<br/>      (if (close-enough? guess next)<br/>          next<br/>          (try next))))<br/>  (try first-guess))</span><span id="ded7" class="la lb hu ms b fv na mx l my mz">and plug in the function that we're trying to find a fixed point for x = 1 + 1/x, which we can turn into the anonymous Scheme function (<strong class="ms hv">lambda</strong> (x) (<strong class="ms hv">+</strong> 1 (<strong class="ms hv">/</strong> 1 x))), and we can choose any starting value</span><span id="234b" class="la lb hu ms b fv na mx l my mz">Thus: <!-- -->(fixed-point (lambda (x) (+ 1 (/ 1 x))) 1.0)<br/>= 1.6180327868852458</span></pre><h2 id="ceb5" class="la lb hu bd lc ld le lf lg lh li lj lk js ll lm ln jw lo lp lq ka lr ls lt lu dt translated">练习1.36</h2><blockquote class="ma mb mc"><p id="06a0" class="jj jk kn jl b jm jn iv jo jp jq iy jr md jt ju jv me jx jy jz mf kb kc kd ke hn dt translated">使用练习1.22中所示的换行符和显示原语，修改定点，以便打印它生成的近似序列。</p><p id="a74d" class="jj jk kn jl b jm jn iv jo jp jq iy jr md jt ju jv me jx jy jz mf kb kc kd ke hn dt translated">然后通过找到x ↦ log(1000) / log(x)的一个不动点来找到x^x=1000的解。(使用Scheme的原始对数过程，它计算自然对数。)比较使用和不使用平均阻尼时的步数。</p><p id="68ba" class="jj jk kn jl b jm jn iv jo jp jq iy jr md jt ju jv me jx jy jz mf kb kc kd ke hn dt translated">(注意，不能以猜测值1开始定点，因为这将导致除以log(1)=0。)</p></blockquote><pre class="kp kq kr ks fq mr ms mt mu aw mv dt"><span id="8f29" class="la lb hu ms b fv mw mx l my mz">(define tolerance 0.00001)</span><span id="c9d1" class="la lb hu ms b fv na mx l my mz">(define (fixed-point f first-guess)<br/>  (define (close-enough? v1 v2)<br/>    (&lt; (abs (- v1 v2)) tolerance))<br/>  (define (try guess)<br/>    (let ((next (f guess)))<br/>    (newline)<br/>    (display next)<br/>      (if (close-enough? guess next)<br/>          next<br/>          (try next))))<br/>  (try first-guess))</span><span id="9f6d" class="la lb hu ms b fv na mx l my mz">(define (average x y)<br/>  (/ (+ x y) 2))</span><span id="ebb0" class="la lb hu ms b fv na mx l my mz">(fixed-point (lambda (x) (/ (log 1000)(log x))) 1.5)</span><span id="6a70" class="la lb hu ms b fv na mx l my mz"><br/>here's the solution using average dumping:<br/>(fixed-point (lambda (x) (average x (/ (log 1000)(log x)))) 1.5)</span><span id="5e30" class="la lb hu ms b fv na mx l my mz">As shown in the screen shots below, using average dumping decreased the number of iterations by about two thirds.</span></pre><div class="kp kq kr ks fq ab cb"><figure class="nb kt nc nd ne nf ng paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><img src="../Images/1b2d7b831b0afb1b490bdc54afa3e630.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/format:webp/1*OuyI99Fbwxq_g57lMIDjyQ.png"/></div></figure><figure class="nb kt nl nd ne nf ng paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><img src="../Images/c14af57163a0bdf790dbf24738792b0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1446/format:webp/1*ItN7SbP8JUInC_DGg9vPmQ.png"/></div><figcaption class="kw kx fg fe ff ky kz bd b be z ek nm di nn no">without average dumping (left) vs. with average dumping (right)</figcaption></figure></div><h2 id="5336" class="la lb hu bd lc ld le lf lg lh li lj lk js ll lm ln jw lo lp lq ka lr ls lt lu dt translated">练习1.37</h2><blockquote class="ma mb mc"><p id="aa4a" class="jj jk kn jl b jm jn iv jo jp jq iy jr md jt ju jv me jx jy jz mf kb kc kd ke hn dt translated">无穷连分数是以下形式的表达式:</p></blockquote><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="fe ff np"><img src="../Images/990bbcd90f21faf6c8aaff9e0ff97214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y_gBLvUWAoc_E_dSOO5ltQ.png"/></div></div><figcaption class="kw kx fg fe ff ky kz bd b be z ek">infinite continued fraction</figcaption></figure><blockquote class="ma mb mc"><p id="3d8c" class="jj jk kn jl b jm jn iv jo jp jq iy jr md jt ju jv me jx jy jz mf kb kc kd ke hn dt translated">作为一个例子，可以证明Ni和Di都等于1的无穷连分数展开产生1ϕ，其中ϕ是黄金比例(在1.2.2节中描述)。逼近无穷连分数的一种方法是在给定项数后截断展开式。这种截断——所谓的<em class="hu"> k项有限连分式</em>——具有以下形式:</p></blockquote><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="fe ff nq"><img src="../Images/a67062ed7a75e51c0044e66dab00cece.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OTVx8cU6FIrqXY6Qu7BmQA.png"/></div></div></figure><blockquote class="ma mb mc"><p id="e11a" class="jj jk kn jl b jm jn iv jo jp jq iy jr md jt ju jv me jx jy jz mf kb kc kd ke hn dt translated">假设n和d是一个自变量的过程(返回连分式项的Ni和Di的项索引I。定义一个过程cont-frac，使得evaluation(cont-frac n d k)计算k项有限连分式的值。通过使用近似1ϕ来检查您的程序</p></blockquote><pre class="kp kq kr ks fq mr ms mt mu aw mv dt"><span id="51e7" class="la lb hu ms b fv mw mx l my mz">(cont-frac (lambda (i) 1.0)<br/>           (lambda (i) 1.0)<br/>           k)</span></pre><blockquote class="ma mb mc"><p id="39ff" class="jj jk kn jl b jm jn iv jo jp jq iy jr md jt ju jv me jx jy jz mf kb kc kd ke hn dt translated">对于k的连续值，为了得到精确到小数点后4位的近似值，k必须取多大？</p><p id="8048" class="jj jk kn jl b jm jn iv jo jp jq iy jr md jt ju jv me jx jy jz mf kb kc kd ke hn dt translated">B.如果您的cont-frac过程生成了一个递归过程，请编写一个生成迭代过程的过程。如果它生成一个迭代过程，那么就写一个生成递归过程的程序。</p></blockquote><pre class="kp kq kr ks fq mr ms mt mu aw mv dt"><span id="1ef0" class="la lb hu ms b fv mw mx l my mz">(define (cont-frac n d k)<br/>  (define (recursive-frac i)<br/>    (if (&lt; i k)(/ (n i) (+ (d i) (recursive-frac(+ i 1))))<br/>               (/ (n i) (d i))))<br/>(recursive-frac 1))</span><span id="8482" class="la lb hu ms b fv na mx l my mz">; k = 12 gives us accuracy within 0.0001 of the expected 0.61803<br/>(cont-frac (lambda (i) 1.0)<br/>  (lambda (i) 1.0)<br/>  12)<br/>;.6180257510729613</span><span id="ae84" class="la lb hu ms b fv na mx l my mz"><br/>Part B- iterative version:</span><span id="5837" class="la lb hu ms b fv na mx l my mz">(define (cont-frac-iterative n d k)<br/>  (define (iterative-frac i acc)<br/>    (if (= i 0) acc<br/>               (iterative-frac (- i 1)(/ (n i)<br/>                                         (+ (d i) acc)))))<br/>(iterative-frac k (/ (n k)(d k))))</span><span id="457c" class="la lb hu ms b fv na mx l my mz">; k = 12 gives us accuracy within 0.0001 of the expected 0.61803<br/>(cont-frac-iterative (lambda (i) 1.0)<br/>  (lambda (i) 1.0)<br/>  11)<br/>;.6180371352785146</span></pre><h2 id="284e" class="la lb hu bd lc ld le lf lg lh li lj lk js ll lm ln jw lo lp lq ka lr ls lt lu dt translated">练习1.38</h2><blockquote class="ma mb mc"><p id="c5f7" class="jj jk kn jl b jm jn iv jo jp jq iy jr md jt ju jv me jx jy jz mf kb kc kd ke hn dt translated">1737年，瑞士数学家莱昂哈德·欧拉出版了回忆录《连续分数》,其中包括对E2的连分式展开，其中e是自然对数的底。在这个分数中，Ni都是1，Di依次是1，2，1，1，4，1，1，6，1，1，8…根据欧拉展开式，编写一个程序，使用练习1.37中的cont-frac程序来逼近e。</p></blockquote><pre class="kp kq kr ks fq mr ms mt mu aw mv dt"><span id="555a" class="la lb hu ms b fv mw mx l my mz">(define (cont-frac d k)<br/>  (define (recursive-frac i)<br/>    (if (&lt; i k) (/ 1.0 (+ (d i) (recursive-frac(+ i 1))))<br/>               (/ 1.0 (d i))))<br/>(recursive-frac 1))</span><span id="7b3f" class="la lb hu ms b fv na mx l my mz">(define (d i)<br/>  (if (= (remainder i 3) 2) (/ (+ i 1) 1.5)<br/>                            1))</span><span id="6fa7" class="la lb hu ms b fv na mx l my mz">(define (euler-e k)<br/>  (+ 2.0 (cont-frac d k)))</span><span id="fd74" class="la lb hu ms b fv na mx l my mz">(euler-e 10)</span><span id="b291" class="la lb hu ms b fv na mx l my mz">The tricky part here was figuring out the correct function implementation for d, such that Euler's Di pattern would be maintained. Also, rather than using my final iterative function solution and supplying d as a function to cont-frac-iterative, I refactored the recursive cont-frac implementation to use the new n and d function values directly.</span></pre><h2 id="d27a" class="la lb hu bd lc ld le lf lg lh li lj lk js ll lm ln jw lo lp lq ka lr ls lt lu dt translated">练习1.39</h2><blockquote class="ma mb mc"><p id="8566" class="jj jk kn jl b jm jn iv jo jp jq iy jr md jt ju jv me jx jy jz mf kb kc kd ke hn dt translated">德国数学家J.H. Lambert在1770年发表了正切函数的连分式表示:</p></blockquote><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="fe ff nr"><img src="../Images/20335ec8d266a4c03815461f525bfd6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q1i_8P01031FBBBcP7Ef0w.png"/></div></div></figure><blockquote class="ma mb mc"><p id="8e69" class="jj jk kn jl b jm jn iv jo jp jq iy jr md jt ju jv me jx jy jz mf kb kc kd ke hn dt translated">其中<em class="hu"> x </em>以弧度为单位。定义一个程序(tan-cf x k ),根据Lambert公式计算正切函数的近似值。k指定要计算的项数，如练习1–37中所示。</p></blockquote><pre class="kp kq kr ks fq mr ms mt mu aw mv dt"><span id="231a" class="la lb hu ms b fv mw mx l my mz">(define (cont-frac-iterative n d k)<br/>  (define (iterative-frac i acc)<br/>    (if (= i 0) acc<br/>               (iterative-frac (- i 1)(/ (n i)<br/>                                         (+ (d i) acc)))))<br/>(iterative-frac k (/ (n k)(d k))))<br/></span><span id="8bf3" class="la lb hu ms b fv na mx l my mz">(define (square x) (* x x))</span><span id="5614" class="la lb hu ms b fv na mx l my mz">(define (d i) (- (* 2 i) 1))</span><span id="e244" class="la lb hu ms b fv na mx l my mz">(define (tan-cf x k)<br/>  (define (n i)<br/>    (if (&gt; i 1) (- (square x))<br/>                x))<br/>  (cont-frac-iterative n d k))</span></pre><figure class="kp kq kr ks fq kt"><div class="bz el l di"><div class="ns nt l"/></div></figure></div></div>    
</body>
</html>