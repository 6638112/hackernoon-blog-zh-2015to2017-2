<html>
<head>
<title>The Magic Behind Python Generator Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python生成器函数背后的魔力</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-magic-behind-python-generator-functions-bc8eeea54220?source=collection_archive---------4-----------------------#2017-08-01">https://medium.com/hackernoon/the-magic-behind-python-generator-functions-bc8eeea54220?source=collection_archive---------4-----------------------#2017-08-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/a18f830368fa79a9123e790546c8fb29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6PpBwJOQIYho7GMjijh0Gw.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://www.pexels.com/u/kaiquestr/" rel="noopener ugc nofollow" target="_blank">Kaique Rocha</a></figcaption></figure><p id="37c2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">生成器函数是Python编程语言最酷的特性之一。网上有许多文章描述了生成器函数在我们的python程序的速度、可伸缩性和内存效率方面提供的许多好处。然而，并没有太多的材料来揭示生成器函数在幕后实际上是如何工作的。本文试图通过揭示python编程语言的一些关键特性来填补这一空白，这些特性使得生成器函数成为可能。</p><p id="71e1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">赋予发生器函数超能力的基本特征是能够在任何时候从任何函数中<strong class="jj hv">暂停</strong>然后<strong class="jj hv">恢复</strong> <em class="kf"> </em>。函数暂停后，生成器函数的本地状态保持不变，并在函数再次恢复时可用。这怎么可能呢？如何暂停一个函数，然后恢复它的本地状态不变？据我们所知，函数有单个<strong class="jj hv">入口点</strong> <em class="kf"> </em>和多个<em class="kf"> </em>出口点<strong class="jj hv"/>(<strong class="jj hv">返回</strong> <em class="kf"> </em>语句)。每次我们调用一个函数，代码从函数的第一行开始执行，直到遇到一个出口点。此时，控制权返回给函数的调用方，函数的局部变量堆栈被清除，相关的内存被操作系统回收。</p><p id="63a9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然而，生成器函数并不这样运行。他们有<strong class="jj hv">多个</strong> <em class="kf"> </em>出入境点。生成器函数中的每个<strong class="jj hv"> yield </strong>语句同时定义了一个退出点和一个重入点。发生器功能的执行一直持续到遇到<strong class="jj hv"> yield </strong> <em class="kf"> </em>语句。此时，函数的本地状态被保留，控制流被交给生成器函数的调用者。当发生器功能恢复时(通过调用下一个的<strong class="jj hv">，<strong class="jj hv">发送</strong>或通过循环</strong> <em class="kf">的<strong class="jj hv">)，调用</strong></em>其最后已知的本地状态，并从发生器功能最后暂停的<strong class="jj hv"> yield </strong>语句后的行开始执行。这种行为令人难以置信，不符合函数的正常行为。</p><p id="f87c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了尝试和理解生成器函数背后的魔力，让我们从仔细观察一个普通函数开始:</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="0a22" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">每次调用<strong class="jj hv"> add_two_numbers </strong>时，我们期望CPython解释器创建一个新的堆栈帧对象，并在该对象的上下文中执行<strong class="jj hv"> add_two_numbers </strong>函数。我们期望局部变量<em class="kf"> s </em>被推到堆栈框架上，并保持在那里，直到函数退出。在函数退出时，我们希望相关的堆栈帧被清空，相应的内存被回收。让我们确认这是事实:</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="08c8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们使用内置的<strong class="jj hv"> inspect </strong> <em class="kf"> </em>模块来捕获<strong class="jj hv"> add_two_numbers </strong>函数的当前执行帧。最后，我们打印堆栈框架对象和任何与之相关的局部变量。我们希望堆栈框架是空的，因此没有局部变量。让我们继续执行上面的代码片段:</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="d3da" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">什么？！在对<strong class="jj hv"> add_two_numbers </strong>的调用结束后，堆栈框架及其所有相关的局部变量仍然存在！这里发生了什么事？我们在CPython中偶然发现了内存泄漏吗？不，事实并非如此。这个观察让我们想到了Python堆栈帧的一个基本特征:<strong class="jj hv"> Python堆栈帧不在堆栈内存上分配。相反，它们被分配在堆内存中</strong>。这实质上意味着python堆栈帧可以比它们各自的函数调用活得长！生成器函数利用这种行为来施展它们的魔法。</p><p id="1b2e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当CPython编译器在函数中遇到<strong class="jj hv"> yield </strong>语句时，它会在编译后的<a class="ae jg" href="https://docs.python.org/3.6/reference/datamodel.html" rel="noopener ugc nofollow" target="_blank">代码对象</a>上设置一个标志，告诉CPython解释器该函数是一个生成器函数。我们可以使用<strong class="jj hv"> dis </strong>模块来看看这是怎么回事:</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="c6b5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当CPython解释器看到与函数相关的代码对象上的<strong class="jj hv"> <em class="kf">生成器</em> </strong>标志时，它不执行函数，而是返回一个生成器对象。生成器对象是一个迭代器。这意味着我们可以使用next关键字或for循环来遍历它。</p><p id="bab9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当我们遍历生成器函数时，执行会继续，直到遇到一个<strong class="jj hv"> yield </strong>语句。此时，函数的堆栈框架被冻结，控制权返回给生成器函数的调用方。</p><p id="6df6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当我们通过调用下一个的<strong class="jj hv">或通过<strong class="jj hv">的<em class="kf">调用循环</em> </strong> <em class="kf">，</em>继续执行生成器函数时，执行正好从上次停止的点开始(最后一个<strong class="jj hv">产生</strong>语句)。CPython解释器如何知道生成器函数实例的执行最后一次停止在哪里？它通过与正在执行的生成器实例相关联的堆栈框架对象来了解这一点。</strong></p><p id="8c1c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们之前看到Python堆栈帧是在堆内存上分配的，它们的状态在后续调用生成器函数实例上的<strong class="jj hv"> next </strong> <em class="kf"> </em>或<strong class="jj hv"> send </strong> <em class="kf"> </em>之间被保留(当然，生成器函数的每个新实例都获得一个新的堆栈帧)。除了存储关于局部和全局变量的信息，python堆栈帧还封装了其他有用的信息。一条这样的信息是<strong class="jj hv">最后的</strong> <em class="kf"> </em> <strong class="jj hv">指令</strong> <em class="kf"> </em> <strong class="jj hv">指针</strong>。</p><p id="faf4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">最后指令指针</strong> <em class="kf"> </em>是与生成器函数体相关联的代码对象的字节码串的索引，并且指向在堆栈框架的上下文中运行的最后字节码指令。当一个生成器函数的实例被恢复时，CPython解释器使用<em class="kf"/><em class="kf"/>关联堆栈帧上的<strong class="jj hv">最后指令指针</strong> <em class="kf"> </em>来确定从哪里开始执行生成器函数的代码对象。我们可以使用由<strong class="jj hv"> dis </strong>模块<em class="kf">T45】提供的便利的<strong class="jj hv"> disco </strong>方法来交互地看到这一点:</em></p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="3481" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们创建一个简单的生成函数，它产生两个数字。调用生成器函数会创建并返回一个生成器对象。在这个调用过程中，生成器函数体中没有代码被执行，并且<strong class="jj hv">最后一个指令指针</strong>被初始化为-1。当我们通过调用next开始执行生成器函数时，<strong class="jj hv">最后一条指令指针</strong>从一条yield语句前进到另一条语句(在上面的代码片段中，每次调用next后<strong class="jj hv">最后一条指令指针</strong>的当前位置由→表示)，暂停然后从同一点恢复，直到生成器函数用尽并抛出StopIteration异常。</p><p id="304c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">总结一下，要记住的关键是python生成器封装了一个堆栈帧和一个代码对象。堆栈帧被分配在堆内存中，并保存一个指针，指向在堆栈帧上下文中的代码对象上运行的最后一个字节码指令。最后一个指令指针告诉CPython解释器，当一个生成器函数恢复时，下一个要执行哪一行。这些是生成器功能赖以发展的核心构件。</p><p id="b6b7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你喜欢冒险，你可以通过<strong class="jj hv"> <em class="kf"> Python/ceval.c </em> </strong>中的<strong class="jj hv"> _PyEval_EvalCodeWithName </strong>函数<em class="kf"> </em>和CPython源代码中的<strong class="jj hv">Python/ge object . c</strong><em class="kf"/>模块来查看实现细节。这篇博客是用CPython 3.6的源代码写的。</p><p id="9690" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果发生器函数对你来说是一个谜，希望这篇文章有助于澄清发生器函数是如何工作的。</p></div></div>    
</body>
</html>