<html>
<head>
<title>What I have learned using ngrx/Redux with Angular 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用ngrx/Redux和Angular 2我学到了什么</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/what-i-have-learned-using-ngrx-redux-with-angular-2-20a748149661?source=collection_archive---------2-----------------------#2017-04-10">https://medium.com/hackernoon/what-i-have-learned-using-ngrx-redux-with-angular-2-20a748149661?source=collection_archive---------2-----------------------#2017-04-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/b8405415eab50794ac894b8e481d1161.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3TlW9rXWIgQS3NWjDhckeA.jpeg"/></div></div></figure><p id="38f0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">包括我在内的大部分Angular开发者都有一些后端编程背景。它有一些优点，但它也对我们如何解决某些问题有一些影响。我们把世界看成是一堆物体，它们是责任的容器。在redux中，你必须稍微转换一下你的思维模式。</p><h2 id="0812" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">不要和样板文件较劲。</h2><p id="5684" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">当我开始使用redux时，我讨厌这些动作创建者和这个又大又丑的switch语句。所以我从定义一些受alt.js实现启发的约定开始。然后，我实现了如下内容</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="8db5" class="ka kb hu lf b fv lj lk l ll lm"><strong class="lf hv">export class </strong>SavedConfigurationStore {<br/><br/>  <em class="ln">setBusy</em>(state, _, busy) {<br/>    <strong class="lf hv">return </strong> {...state, busy);<br/>  }<br/><br/>  <em class="ln">invalidate</em>(state) {<br/>    <strong class="lf hv">return {</strong>...state, invalidate<strong class="lf hv">: true}</strong>;<br/>  }<br/><br/>  <em class="ln">onFetchSavedConfigsSuccess</em>(state, action) {<br/>    <strong class="lf hv">return {...</strong>state, configs<strong class="lf hv">: </strong>action.payload, invalidate<strong class="lf hv">: false</strong>};<br/>  }</span><span id="690d" class="ka kb hu lf b fv lo lk l ll lm">  ....</span><span id="dbc3" class="ka kb hu lf b fv lo lk l ll lm">}</span><span id="e578" class="ka kb hu lf b fv lo lk l ll lm"><strong class="lf hv">const </strong>savedStore <strong class="lf hv">= new </strong>SavedConfigurationStore();<br/><strong class="lf hv">export const </strong>savedConfigurationReducer <strong class="lf hv">= </strong>ReducerBinder.<em class="ln">start</em>()<br/>  .<em class="ln">bindActionsByConvention</em>(SavedActions, savedStore)<br/>  .<em class="ln">bindAsyncAction</em>(SavedActions.<em class="ln">FETCH_SAVED_CONFIGS</em>, savedStore.<em class="ln">setBusy</em>)</span></pre><p id="90cc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我创建它只是为了让简单的POJO对象具有动作。然后我定义了这个ReducerBinder类来绑定我的对象方法作为动作处理程序。尽管它看起来对后端开发人员更有吸引力，但它也有很多缺点。除了我没有人知道这个惯例，如果我强迫我的团队成员基于这个redux包装器来构建整个应用程序，他们很快就会恨我。其次，它使用面向对象模式。Redux是关于使用功能方法，将所有的东西分成小的可组合的功能。在上面的例子中，我们把所有的东西都放在一个大的对象中。</p><p id="bd94" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">redux附带的这个样板文件利大于弊。你有完全的控制权。您将会真正感到惊讶，使用该架构实现离线状态、重做/撤消功能、乐观更新功能以及更多功能是多么容易。没有理由为此而战。如果你想完全控制你的代码，你就不要用抽象来覆盖一切。</p><p id="112f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">让你的状态正常化</strong></p><p id="ffb2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你应该保持你的减速器相对较小和紧凑。当你的状态没有正常化，你把所有东西都放在一个大模型里，结果会是一团糟。在你的reducer中，你会有lodash提供的一大堆工具来遍历这些大对象树，找到你想要更新的对象。当你最终找到叶对象，你想要更新你需要为每个父对象创建新的对象直到你的模型的根。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="bd7d" class="ka kb hu lf b fv lj lk l ll lm"><strong class="lf hv">const </strong>initialState <strong class="lf hv">= </strong>{<br/>  genres<strong class="lf hv">: </strong>[<br/>    {<br/>      id<strong class="lf hv">: </strong>1, name<strong class="lf hv">: </strong><em class="ln">'rock'</em>, bands<strong class="lf hv">: </strong>[<br/>      {<br/>        id<strong class="lf hv">: </strong>1, name<strong class="lf hv">: </strong><em class="ln">'led zeppelin'</em>, albums<strong class="lf hv">: </strong>[<br/>        {id<strong class="lf hv">: </strong>1, name<strong class="lf hv">: </strong><em class="ln">'I'</em>, items<strong class="lf hv">: </strong>3},<br/>        {id<strong class="lf hv">: </strong>2, name<strong class="lf hv">: </strong><em class="ln">'II'</em>, items<strong class="lf hv">: </strong>66},<br/>        {id<strong class="lf hv">: </strong>3, name<strong class="lf hv">: </strong><em class="ln">'III'</em>, items<strong class="lf hv">: </strong>3},<br/>      ]<br/>      },<br/>      {id<strong class="lf hv">: </strong>2, name<strong class="lf hv">: </strong><em class="ln">'boston'</em>},<br/>    ]<br/>    }<br/>  ]<br/>};<br/><br/><br/><strong class="lf hv">export const </strong><em class="ln">albums </em><strong class="lf hv">= </strong>(state = initialState, {<em class="ln">type</em>, payload}) <strong class="lf hv">=&gt; </strong>{<br/>  <strong class="lf hv">switch </strong>(<em class="ln">type</em>) {<br/>    <strong class="lf hv">case </strong>UPDATE_ITEMS_COUNT<strong class="lf hv">:<br/>      const </strong>nextGenres <strong class="lf hv">= </strong>state.genres.<em class="ln">map</em>(g <strong class="lf hv">=&gt; </strong>{<br/>        <strong class="lf hv">const </strong>nextBands <strong class="lf hv">= </strong>g.bands.<em class="ln">map</em>(b <strong class="lf hv">=&gt; </strong>{<br/>          <strong class="lf hv">return </strong>b.albums.<em class="ln">map</em>(a <strong class="lf hv">=&gt; </strong>{<br/>            <strong class="lf hv">if </strong>(a.id <strong class="lf hv">!= </strong>payload.id) {<br/>              <strong class="lf hv">return </strong>a;<br/>            }<br/>            <strong class="lf hv">return </strong>{...a, items<strong class="lf hv">: </strong>payload.items};<br/>          });<br/>        });<br/>        <strong class="lf hv">return </strong>{...g, bands<strong class="lf hv">: </strong>nextBands}<br/>      });<br/><br/>      <strong class="lf hv">return </strong>{...state, genres<strong class="lf hv">: </strong>nextGenres};<br/>    <strong class="lf hv">default:<br/>      return </strong>state<br/>  }<br/>};</span></pre><p id="aa86" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是你的代码看起来的样子。当你将你的状态正常化时，你将有三个缩减者:流派、乐队、专辑。你的责任会被合理分配。Albums reducer将负责对相册模型进行更新。流派和乐队减少器可以负责将专辑从一个组转移到另一个组。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="2ca7" class="ka kb hu lf b fv lj lk l ll lm"><strong class="lf hv">const </strong>initialState <strong class="lf hv">= </strong>{<br/>  [1]<strong class="lf hv">: </strong>{id<strong class="lf hv">: </strong>1, name<strong class="lf hv">: </strong><em class="ln">'I'</em>, items<strong class="lf hv">: </strong>3},<br/>  [2]<strong class="lf hv">: </strong>{id<strong class="lf hv">: </strong>2, name<strong class="lf hv">: </strong><em class="ln">'II'</em>, items<strong class="lf hv">: </strong>66},<br/>  [3]<strong class="lf hv">: </strong>{id<strong class="lf hv">: </strong>3, name<strong class="lf hv">: </strong><em class="ln">'III'</em>, items<strong class="lf hv">: </strong>3}<br/>};<br/><br/><br/><strong class="lf hv">export const </strong><em class="ln">albums </em><strong class="lf hv">= </strong>(state <strong class="lf hv">= </strong>initialState, {<em class="ln">type</em>, payload}) <strong class="lf hv">=&gt; </strong>{<br/>  <strong class="lf hv">switch </strong>(<em class="ln">type</em>) {<br/>    <strong class="lf hv">case </strong>UPDATE_ITEMS_COUNT<strong class="lf hv">:<br/>      const </strong>{id, items} <strong class="lf hv">= </strong>payload;<br/>      <strong class="lf hv">const </strong>album <strong class="lf hv">= </strong>state[id];<br/>      <strong class="lf hv">return </strong>{...state, [id]<strong class="lf hv">: </strong>{...album, items}};<br/>    <strong class="lf hv">default:<br/>      return </strong>state<br/>  }<br/>};</span></pre><p id="96cf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面你可以看到归一化的reducer是什么样子。值得注意的是，您不仅有扁平的结构，而且您只将所有对象保存在“字典”中，而不是将所有内容保存在数组中。当您拥有以关键字作为id的字典时，找到要更新的对象就容易多了。</p><p id="5b0c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">我怎样才能使状态正常化？</strong></p><p id="02f9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这可以在服务类实现中手动完成。或者你可以使用第三方库来帮助你。我强烈推荐去看看<a class="ae lp" href="https://github.com/paularmstrong/normalizr" rel="noopener ugc nofollow" target="_blank"> normalizr </a>库。使用normlizr，您可以定义从下面的服务器链接中检索的模式数据:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="29ce" class="ka kb hu lf b fv lj lk l ll lm">import { normalize, schema } from 'normalizr';<br/><br/>const album = new schema.Entity('album');<br/>const bands = new schema.Entity('bands', {<br/>  albums: [album]<br/>});<br/>const genres = new schema.Entity('genres', { <br/>  bands: [ bands]<br/>});<br/><br/>const normalizedData = normalize(originalData, genres);</span></pre><p id="b9cf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">结果将如下所示</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="4894" class="ka kb hu lf b fv lj lk l ll lm"><strong class="lf hv">var </strong>a <strong class="lf hv">= </strong>{<br/>  result<strong class="lf hv">: </strong><em class="ln">"123"</em>,<br/>  entities<strong class="lf hv">: </strong>{<br/>    <em class="ln">"genres"</em><strong class="lf hv">: </strong>{<br/>      <em class="ln">"123"</em><strong class="lf hv">: </strong>{id<strong class="lf hv">: </strong>1, name<strong class="lf hv">: </strong><em class="ln">'rock'</em>, bands<strong class="lf hv">: </strong>[1, 2]}<br/>    },<br/>    <em class="ln">"albums"</em><strong class="lf hv">: </strong>{<br/>      <em class="ln">"1"</em><strong class="lf hv">: </strong>{id<strong class="lf hv">: </strong>1, name<strong class="lf hv">: </strong><em class="ln">'I'</em>, items<strong class="lf hv">: </strong>3},<br/>      <em class="ln">"2"</em><strong class="lf hv">: </strong>{id<strong class="lf hv">: </strong>2, name<strong class="lf hv">: </strong><em class="ln">'I'</em>, items<strong class="lf hv">: </strong>3},<br/>      <em class="ln">"3"</em><strong class="lf hv">: </strong>{id<strong class="lf hv">: </strong>3, name<strong class="lf hv">: </strong><em class="ln">'I'</em>, items<strong class="lf hv">: </strong>3}<br/>    },<br/>    <em class="ln">"bnads"</em><strong class="lf hv">: </strong>{<br/>      <em class="ln">"1"</em><strong class="lf hv">: </strong>{id<strong class="lf hv">: </strong><em class="ln">"1"</em>, name<strong class="lf hv">: </strong><em class="ln">'led zeppelin'</em>, albums<strong class="lf hv">:</strong>[<em class="ln">"1"</em>, <em class="ln">"2"</em>, <em class="ln">"3"</em>]},<br/>      <em class="ln">"2"</em><strong class="lf hv">: </strong>{id<strong class="lf hv">: </strong><em class="ln">"1"</em>, name<strong class="lf hv">: </strong><em class="ln">'boston'</em>, albums<strong class="lf hv">: </strong>[]},<br/>    }<br/>  }<br/>};</span></pre><p id="b42a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">如何对视图的状态进行反规范化？</strong></p><p id="0190" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，规范化简化了更新操作，却使读取变得更加复杂。但是它也给了你更多的灵活性。当您的一个视图需要连接两个实体，而另一个视图需要连接另外三个实体时，那么您可以相对容易地做到这一点。这对你的表现也有很好的影响。当您的视图只需要2个实体作为视图模型，并且您正在更新第三个实体时，则您的视图不会被不必要地刷新。但是您必须使用onPush通知模式，并且必须灵活地对视图模型的数据进行反规范化。</p><p id="0f38" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我正在寻找一些建议，没有找到任何有帮助的东西，所以我做了我的反规格化状态。如果有人有更好的方法，请让我知道。</p><p id="d435" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设我们希望视图以与初始模型完全相同的形状呈现我们的数据:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="5d4d" class="ka kb hu lf b fv lj lk l ll lm">&lt;div class="genre"  *ngFor="let genre of genres"&gt;<br/>  &lt;div class="band" *ngFor="let band of genre.bands"&gt;<br/>    &lt;div class="album" *ngFor="let album of band.albums"&gt;{{genre.name}}{{band.name}}:{{album.name}}&lt;/div&gt;<br/>    &lt;img  [attr.src]="album.coverImage" /&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="5a7a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们不能这样做，因为我们的模型是标准化的。例如，流派模型只有乐队id列表。我们可以通过定义如下的映射选择器来实现:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="9e1c" class="ka kb hu lf b fv lj lk l ll lm"><strong class="lf hv">const </strong><em class="ln">getGenres </em><strong class="lf hv">= </strong>state<strong class="lf hv">=&gt;</strong>{<br/>  <strong class="lf hv">const </strong>{albums, genres, bands} <strong class="lf hv">= </strong>state.entities;<br/>  <strong class="lf hv">return </strong>values(genres).map(g<strong class="lf hv">=&gt;</strong>{<br/>    <strong class="lf hv">const </strong>bands <strong class="lf hv">= </strong>g.bands.map(bid<strong class="lf hv">=&gt; </strong>{<br/>      <strong class="lf hv">const </strong>band <strong class="lf hv">= </strong>bands[bid];<br/>      <strong class="lf hv">const </strong>bandAlbums <strong class="lf hv">= </strong>band.albums.map(aid<strong class="lf hv">=&gt;</strong>{<br/>        <strong class="lf hv">const </strong>a <strong class="lf hv">= </strong>albums[aid];<br/>        <strong class="lf hv">return </strong>{...a, coverImage <strong class="lf hv">: </strong><em class="ln">`images/</em>${a.name}<em class="ln">.jpg`</em>}<br/>      });<br/>      <strong class="lf hv">return </strong>{...band, albums<strong class="lf hv">: </strong>bandAlbums};<br/>    })<br/>  })<br/>};<br/><br/>store.select(<em class="ln">getGenres</em>).<em class="ln">subscribe</em>((g)<strong class="lf hv">=&gt;</strong>{<br/>  <strong class="lf hv">this</strong>.genres <strong class="lf hv">= </strong>g;<br/>})</span></pre><p id="f76e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是我不建议你这么做，有两个原因:</p><ul class=""><li id="c434" class="lq lr hu je b jf jg jj jk jn ls jr lt jv lu jz lv lw lx ly dt translated">我们在这里混合了两个关注点——遍历对象树和映射到视图模型。</li><li id="504c" class="lq lr hu je b jf lz jj ma jn mb jr mc jv md jz lv lw lx ly dt translated">每当一个单独的相册被更新，angular将重新创建整个视图模型树作为新的实例，这将导致整个事情的重新渲染，即使我们使用onPush策略。</li></ul><p id="2d57" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了打破绩效和划分责任，我们可以做如下事情:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="7bb4" class="ka kb hu lf b fv lj lk l ll lm">@Component({<br/>  template<strong class="lf hv">: </strong><em class="ln">`   <br/>    &lt;div class="genre"  *ngFor="let genre of (genres$|async)"&gt;<br/>        &lt;genre-view [genre]="gendre"&gt;&lt;/genre-view&gt;<br/>    &lt;/div&gt;`<br/></em>})<br/><strong class="lf hv">export class </strong>HomeComponent {<br/>  genres$;<br/><br/>  <strong class="lf hv">constructor</strong>(store<strong class="lf hv">: </strong>Store<strong class="lf hv">&lt;</strong>AppState<strong class="lf hv">&gt;</strong>) {<br/>    <strong class="lf hv">this</strong>.genres$ <strong class="lf hv">= this</strong>.store.<em class="ln">select</em>(getAllGenres);<br/>  }<br/>}</span></pre><p id="f547" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后在GenreComponent中，我们有如下代码</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="6a74" class="ka kb hu lf b fv lj lk l ll lm">@Component({<br/>  selector<strong class="lf hv">: </strong><em class="ln">'genre-view'</em>,<br/>  template<strong class="lf hv">: </strong><em class="ln">`<br/>&lt;div class="band" *ngFor="let band of (bands$|async$)"&gt;<br/>  &lt;band-view [band]="band" [genre]="genre"&gt;&lt;/band-view&gt;<br/>&lt;/div&gt;<br/>`<br/></em>})<br/><strong class="lf hv">export class </strong>GenreComponent {<br/>  @Input() genre;<br/>  bands$;<br/>  <strong class="lf hv">constructor</strong>(store<strong class="lf hv">: </strong>Store<strong class="lf hv">&lt;</strong>AppState<strong class="lf hv">&gt;</strong>) {<br/>    <strong class="lf hv">this</strong>.bands$ <strong class="lf hv">= this</strong>.store.<em class="ln">select</em>(getBandsByIds(<strong class="lf hv">this</strong>.genre.bands))<br/>  }<br/>}</span></pre><p id="b188" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后在乐队内部</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="7c62" class="ka kb hu lf b fv lj lk l ll lm">@Component({<br/>  selector<strong class="lf hv">: </strong><em class="ln">'band-view'</em>,<br/>  template<strong class="lf hv">: </strong><em class="ln">`<br/>&lt;div class="album" *ngFor="let album of (albums$|async)"&gt;{{genre.name}}{{band.name}}:{{album.name}}<br/>&lt;img  [attr.src]="album.coverImage" /&gt;<br/>&lt;/div&gt;<br/>`<br/></em>})<br/><strong class="lf hv">export class </strong>BandComponent {<br/>  @Input() genre;<br/>  @Input() band;<br/>  albums$;<br/>  <strong class="lf hv">constructor</strong>(store<strong class="lf hv">: </strong>Store<strong class="lf hv">&lt;</strong>AppState<strong class="lf hv">&gt;</strong>) {<br/>    <strong class="lf hv">this</strong>.albums$ <strong class="lf hv">= this</strong>.store.<em class="ln">select</em>(getAlbumsByIds(<strong class="lf hv">this</strong>.band.ablums)).<em class="ln">map</em>(a<strong class="lf hv">=&gt;</strong>({<br/>      name<strong class="lf hv">: </strong>a.name,<br/>      coverImage<strong class="lf hv">: </strong><em class="ln">`</em>${a.name}<em class="ln">.jpg`  <br/>    </em>}))<br/>  }<br/>}</span></pre><p id="3c05" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">到目前为止一切顺利。但是这个解决方案有两个问题。我们没有完全从OnPush变化检测策略中获益。第二件事是，我们在构造函数中只定义了一次子列表，这意味着当输入参数改变时，我们根本没有反应。当BandComponent乐队输入改变时，它仍将呈现属于上一个乐队的专辑。为了解决这个问题，我的方法如下。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="493e" class="ka kb hu lf b fv lj lk l ll lm">@Component({<br/>  selector<strong class="lf hv">: </strong><em class="ln">'band-view'</em>,<br/>  changeDetection<strong class="lf hv">: </strong>ChangeDetectionStrategy.<em class="ln">OnPush</em>,<br/>  template<strong class="lf hv">: </strong><em class="ln">`<br/>&lt;div class="album" *ngFor="let album of props.albums"&gt;{{album.name}}<br/>&lt;img  [attr.src]="album.coverImage" /&gt;<br/>&lt;/div&gt;<br/>`<br/></em>})<br/><strong class="lf hv">export class </strong>BandComponent {<br/>  @Input() band;<br/>  band$ <strong class="lf hv">= new </strong>Subject<strong class="lf hv">&lt;</strong>any<strong class="lf hv">&gt;</strong>();<br/>  props <strong class="lf hv">=</strong>{};<br/>  <strong class="lf hv">constructor</strong>(store<strong class="lf hv">: </strong>Store<strong class="lf hv">&lt;</strong>AppState<strong class="lf hv">&gt;</strong>, <strong class="lf hv">private </strong>cd <strong class="lf hv">: </strong>ChangeDetectorRef) {<br/>    <strong class="lf hv">this</strong>.store.let(<em class="ln">queryBandAlbums</em>(<strong class="lf hv">this</strong>.band$)).map(a<strong class="lf hv">=&gt;</strong>({<br/>      name<strong class="lf hv">: </strong>a.name,<br/>      coverImage<strong class="lf hv">: </strong><em class="ln">`</em>${a.name}<em class="ln">.jpg`<br/>    </em>})).<em class="ln">subscribe</em>(a<strong class="lf hv">=&gt;</strong>{<br/>      <strong class="lf hv">this</strong>.props <strong class="lf hv">= </strong>{albums<strong class="lf hv">: </strong>a};<br/>      cd.<em class="ln">markForCheck</em>();<br/>    });<br/><br/>  }<br/>  <em class="ln">onChanges</em>(){<br/>    <strong class="lf hv">this</strong>.band$.<em class="ln">next</em>(<strong class="lf hv">this</strong>.band);<br/>  }<br/>}<br/><br/><br/><strong class="lf hv">export const </strong><em class="ln">queryBandAlbums </em><strong class="lf hv">= </strong>band$ <strong class="lf hv">=&gt; </strong>store$ <strong class="lf hv">=&gt; </strong>{<br/>  <strong class="lf hv">return </strong>band$.switchMap(b <strong class="lf hv">=&gt; </strong>store$.<em class="ln">select</em>(getAlbumsByIds(b.ablums)))<br/>    .distinctUntilChanged();<br/>};</span></pre><ul class=""><li id="2b75" class="lq lr hu je b jf jg jj jk jn ls jr lt jv lu jz lv lw lx ly dt translated">我们使用Angular onChanges生命周期钩子来监视输入参数的每一个变化。每次乐队参数改变，我们都会得到新的专辑列表</li><li id="85a5" class="lq lr hu je b jf lz jj ma jn mb jr mc jv md jz lv lw lx ly dt translated">我们使用OnPush变化检测策略来获得更好的性能。然而，使用这种策略，angular将不知道相册对象是否会改变自身。因此，我们需要用cd.markForCheck()通知angular关于更改的信息。</li></ul><p id="630b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有了这种方法，我们就拥有了两个世界的精华。我们有很好的标准化数据，很容易处理。我们有很好的表现，因为当一些东西将会改变，在只有一个专辑，然后只有这个元素将被重新呈现。所有其他参考将保持不变。让我知道你是否有更好的方法，来处理带角度的归一化状态。</p><div class="la lb lc ld fq ab cb"><figure class="me iv mf mg mh mi mj paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="me iv mf mg mh mi mj paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="me iv mf mg mh mi mj paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mk ml mm"><p id="f922" class="jc jd ln je b jf jg jh ji jj jk jl jm mn jo jp jq mo js jt ju mp jw jx jy jz hn dt translated"><a class="ae lp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae lp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae lp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae lp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd ln je b jf jg jh ji jj jk jl jm mn jo jp jq mo js jt ju mp jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="la lb lc ld fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mq"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>