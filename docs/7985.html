<html>
<head>
<title>Coding for iOS 11: How to drag &amp; drop into collections &amp; tables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS 11编码:如何拖放到收藏和表格中</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/drag-it-drop-it-in-collection-table-ios-11-6bd28795b313?source=collection_archive---------1-----------------------#2017-11-15">https://medium.com/hackernoon/drag-it-drop-it-in-collection-table-ios-11-6bd28795b313?source=collection_archive---------1-----------------------#2017-11-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/d73b6a8f8912698279050b461ac06850.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3IIeDZy7NnarO_zPWahEag@2x.png"/></div></div></figure><p id="2868" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">随着<strong class="je hv"> iOS-11 </strong>的发布，苹果在<code class="eh ka kb kc kd b">UITableView</code>和<code class="eh ka kb kc kd b">UICollectionView</code>中引入了<strong class="je hv">拖放</strong>，以及一个基于<strong class="je hv">交互</strong>(类似手势)概念的专门API。</p><p id="20dd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">表格视图和集合视图有相似的API来支持拖放，只是有一些小的不同。</p><p id="775d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<strong class="je hv"> iPhone </strong>和<strong class="je hv"> iPad </strong>中都支持拖放。在iPad上，用户可以在多个应用程序中拖放。但对于iPhone来说，这种支持只在一个应用程序中提供。</p><p id="43f6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将讨论拖放在集合视图中是如何工作的，这同样适用于表格视图。我会根据需要指出表格视图中的不同之处。所以不用担心。您会发现它既适用于集合视图，也适用于表格视图。</p><h1 id="fff3" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">我们开始吧🚀</h1><p id="bc57" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">在集合视图中采用拖放是一个多步骤的过程。我们将讨论在集合视图中集成拖放元素所需的每一个细节。</p><h2 id="4b1a" class="lh kf hu bd kg li lj lk kk ll lm ln ko jn lo lp ks jr lq lr kw jv ls lt la lu dt translated">UICollectionViewDragDelegate</h2><p id="abf0" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">要使<strong class="je hv">拖动</strong>，自定义对象必须符合<code class="eh ka kb kc kd b"><a class="ae lv" href="https://developer.apple.com/documentation/uikit/uicollectionviewdragdelegate" rel="noopener ugc nofollow" target="_blank">UICollectionViewDragDelegate</a></code> <em class="lw"> </em>协议。</p><p id="7b78" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它包含多种方法，可以实现这些方法来定制集合视图的拖动行为。</p><p id="028b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该协议中唯一需要用来支持拖动行为的方法是:</p><pre class="lx ly lz ma fq mb kd mc md aw me dt"><span id="e4b6" class="lh kf hu kd b fv mf mg l mh mi"><a class="ae lv" href="https://developer.apple.com/documentation/uikit/uicollectionviewdragdelegate/2897389-collectionview" rel="noopener ugc nofollow" target="_blank">collectionView(_:itemsForBeginning:at:)</a></span></pre><p id="cfda" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将在接下来的章节中研究该方法的细节。</p><p id="b6af" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另外，在<code class="eh ka kb kc kd b">viewDidLoad()</code>中设置收藏视图的<code class="eh ka kb kc kd b">dragDelegate</code>委托对象，以管理从中拖动项目。</p><pre class="lx ly lz ma fq mb kd mc md aw me dt"><span id="fbc6" class="lh kf hu kd b fv mf mg l mh mi">collectionView.dragDelegate = self</span></pre><h2 id="4e32" class="lh kf hu bd kg li lj lk kk ll lm ln ko jn lo lp ks jr lq lr kw jv ls lt la lu dt translated">UICollectionViewDropDelegate协议</h2><p id="df43" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">要启用<strong class="je hv"> drops </strong>，自定义对象必须符合<code class="eh ka kb kc kd b"><a class="ae lv" href="https://developer.apple.com/documentation/uikit/uicollectionviewdropdelegate" rel="noopener ugc nofollow" target="_blank">UICollectionViewDropDelegate</a></code> <em class="lw"> </em>协议。</p><p id="d46f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">本协议唯一需要的<strong class="je hv">方法</strong>是:</p><pre class="lx ly lz ma fq mb kd mc md aw me dt"><span id="d304" class="lh kf hu kd b fv mf mg l mh mi"><a class="ae lv" href="https://developer.apple.com/documentation/uikit/uicollectionviewdropdelegate/2897304-collectionview" rel="noopener ugc nofollow" target="_blank">collectionView(_:performDropWith:)</a></span></pre><p id="bb5d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以根据需要实现其他方法来自定义集合视图的放置行为。</p><p id="162a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此外，将您的定制委托对象分配给<code class="eh ka kb kc kd b">viewDidLoad()</code>中集合视图的<code class="eh ka kb kc kd b">dropDelegate</code>属性。</p><pre class="lx ly lz ma fq mb kd mc md aw me dt"><span id="f245" class="lh kf hu kd b fv mf mg l mh mi">collectionView.dropDelegate = self</span></pre><h2 id="5251" class="lh kf hu bd kg li lj lk kk ll lm ln ko jn lo lp ks jr lq lr kw jv ls lt la lu dt translated">启用拖动交互</h2><p id="e738" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">要启用/禁用拖动，您可以自定义收藏视图的<code class="eh ka kb kc kd b">dragInteractionEnabled</code>属性。</p><p id="b55b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该属性的默认值在iPad上为true，在iPhone上为false。</p><p id="ce1e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，如果您在iPhone中提供拖放支持，将它设置为<strong class="je hv"> true </strong>以启用从收藏视图拖动内容。</p><pre class="lx ly lz ma fq mb kd mc md aw me dt"><span id="a882" class="lh kf hu kd b fv mf mg l mh mi">collectionView.dragInteractionEnabled = true</span></pre><h2 id="c5cb" class="lh kf hu bd kg li lj lk kk ll lm ln ko jn lo lp ks jr lq lr kw jv ls lt la lu dt translated">拖动单个项目</h2><p id="6945" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">既然我们已经配置了集合视图来支持拖放，那么是时候实际编写实现它的代码了。</p><p id="6801" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们首先介绍一些支持拖放所需的重要类。我们开始吧:</p><ol class=""><li id="e527" class="mj mk hu je b jf jg jj jk jn ml jr mm jv mn jz mo mp mq mr dt translated"><a class="ae lv" href="https://developer.apple.com/documentation/foundation/nsitemprovider" rel="noopener ugc nofollow" target="_blank">nsiteprovider</a><strong class="je hv">—</strong>拖拽过程中在进程间传递数据或文件的项目提供者。</li><li id="096f" class="mj mk hu je b jf ms jj mt jn mu jr mv jv mw jz mo mp mq mr dt translated"><a class="ae lv" href="https://developer.apple.com/documentation/uikit/uidragitem" rel="noopener ugc nofollow" target="_blank"> UIDragItem </a> <strong class="je hv"> — </strong>底层数据项从一个位置拖到另一个位置的表示。</li></ol><p id="ad00" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每一个需要拖动的项目都必须表示为一个<code class="eh ka kb kc kd b">UIDragItem</code>的对象。</p><p id="68eb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了允许从集合视图中拖动项目，实现唯一需要的方法<code class="eh ka kb kc kd b">UICollectionViewDragDelegate</code>，并在指定的<code class="eh ka kb kc kd b">indexPath</code>返回项目的一个或多个<code class="eh ka kb kc kd b">UIDragItem</code>对象。</p><p id="dd92" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">OMG！😯那是什么？太多了，无法理解..！！！</p><p id="0d21" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">别担心。我们将在下面的代码中完成每个步骤:</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="1a18" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看看代码是怎么说的..</p><ol class=""><li id="bad8" class="mj mk hu je b jf jg jj jk jn ml jr mm jv mn jz mo mp mq mr dt translated">第1行—实施<code class="eh ka kb kc kd b">UICollectionViewDragDelegate</code>的<code class="eh ka kb kc kd b">collectionView(_:itemsForBeginning:at:)</code>方法。</li><li id="f444" class="mj mk hu je b jf ms jj mt jn mu jr mv jv mw jz mo mp mq mr dt translated">第3行——获取与所选项目的<code class="eh ka kb kc kd b">indexPath</code>相对应的数据。使用作为集合视图数据源的模型。<br/>这里我使用了一组<code class="eh ka kb kc kd b">String</code>对象作为集合视图的数据源。因此，项目将对应于一个<code class="eh ka kb kc kd b">String</code>值。</li><li id="ae57" class="mj mk hu je b jf ms jj mt jn mu jr mv jv mw jz mo mp mq mr dt translated">第4行——使用第3行提取的<code class="eh ka kb kc kd b">item</code>创建一个对象<code class="eh ka kb kc kd b">NSItemProvider</code>。<code class="eh ka kb kc kd b">item</code>被强制转换为<code class="eh ka kb kc kd b">NSString</code>，因为<code class="eh ka kb kc kd b"><strong class="je hv">NSItemProvider</strong></code> <strong class="je hv">接受一个对象</strong>，而swift <code class="eh ka kb kc kd b">String</code>是值类型而不是对象类型。</li><li id="91f7" class="mj mk hu je b jf ms jj mt jn mu jr mv jv mw jz mo mp mq mr dt translated">第5行—从<code class="eh ka kb kc kd b">itemProvider</code>创建一个<code class="eh ka kb kc kd b">UIDragItem</code>对象。</li><li id="1242" class="mj mk hu je b jf ms jj mt jn mu jr mv jv mw jz mo mp mq mr dt translated">第6行— <code class="eh ka kb kc kd b">localObject</code>是与拖动项相关联的自定义对象。它仅适用于启动拖动活动的应用程序。<br/>这是<strong class="je hv">可选的</strong>，但是可以更快地在同一个应用程序中拖放内容。</li><li id="25ed" class="mj mk hu je b jf ms jj mt jn mu jr mv jv mw jz mo mp mq mr dt translated">第7行—返回一个<code class="eh ka kb kc kd b">dragItem</code>的<strong class="je hv">数组</strong>。</li></ol><p id="1a4d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你想忽略拖动，返回一个空数组。</p><h2 id="9807" class="lh kf hu bd kg li lj lk kk ll lm ln ko jn lo lp ks jr lq lr kw jv ls lt la lu dt translated">拖动多个项目</h2><p id="e3e9" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">我们已经看到了如何从集合视图中拖动单个项目。如果我想一次拖动多个项目怎么办？</p><p id="a5c7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">嗯，我们有一个<code class="eh ka kb kc kd b">UICollectionViewDragDelegate</code>方法来实现这一点。</p><pre class="lx ly lz ma fq mb kd mc md aw me dt"><span id="570d" class="lh kf hu kd b fv mf mg l mh mi"><a class="ae lv" href="https://developer.apple.com/documentation/uikit/uicollectionviewdragdelegate/2897367-collectionview" rel="noopener ugc nofollow" target="_blank">collectionView(_:itemsForAddingTo:at:point:)</a></span></pre><p id="a9b9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此方法将指定的项添加到现有的拖动会话中。</p><p id="67f0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">点击<strong class="je hv">一次</strong>即可将项目添加到活动拖动会话中。如果不实现此方法，在收藏视图中点击会触发项目选择或其他行为。</p><p id="6387" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">其实现与<code class="eh ka kb kc kd b">collectionView(_:itemsForBeginning:at:)</code>类似。</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="d6c9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以根据需要添加自己的约束。</p><p id="07a7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">示例</strong>:如果项目已经存在于您正在拖放的收藏视图中，则忽略添加项目。在这种情况下，返回一个空数组。</p><h2 id="1cae" class="lh kf hu bd kg li lj lk kk ll lm ln ko jn lo lp ks jr lq lr kw jv ls lt la lu dt translated">删除建议UICollectionViewDropProposal</h2><p id="a8a6" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">我们选择了项目，然后拖动它。现在，我们不能只是把这个项目拖得太久。现在该怎么办？放在哪里？当我放下物品时会发生什么？</p><p id="794d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所有这些问题都指向一个非常具体的问题:<br/>“你打算如何处理在指定位置的投递？<br/>您是要复制该项目，还是只是将其移动到新位置？<br/>还是想在某些特定条件下禁止运动？哦，不..！！我可以直接取消吗？”</p><p id="db09" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">嗯嗯嗯..！！！您的所有问题只有一个答案— <strong class="je hv">撤销提议。</strong>drop proposal顾名思义就是当用户举起手指时，你打算如何处理特定位置的drop的提议。</p><p id="1582" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae lv" href="https://developer.apple.com/documentation/uikit/uidropproposal" rel="noopener ugc nofollow" target="_blank">uidroproposal</a>—一个拖放交互行为的配置，如果视图接受拖放活动，则需要该配置。</p><p id="4ec6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每个提议都定义了一个<strong class="je hv">操作</strong>—<a class="ae lv" href="https://developer.apple.com/documentation/uikit/uidropoperation" rel="noopener ugc nofollow" target="_blank">enum uidropooperation</a>，它决定了当用户放下一个拖动项时，拖放活动如何解析。由定义的操作可以是以下类型:</p><ol class=""><li id="2eb8" class="mj mk hu je b jf jg jj jk jn ml jr mm jv mn jz mo mp mq mr dt translated"><code class="eh ka kb kc kd b">cancel</code> —不应传输任何数据，取消拖动。</li><li id="6554" class="mj mk hu je b jf ms jj mt jn mu jr mv jv mw jz mo mp mq mr dt translated"><code class="eh ka kb kc kd b">forbidden</code> —虽然在这种情况下移动或复制操作通常是合法的，但是不允许放置活动。</li><li id="f07b" class="mj mk hu je b jf ms jj mt jn mu jr mv jv mw jz mo mp mq mr dt translated"><code class="eh ka kb kc kd b">copy</code> —拖动项目所代表的数据应复制到目标视图。</li><li id="2315" class="mj mk hu je b jf ms jj mt jn mu jr mv jv mw jz mo mp mq mr dt translated"><code class="eh ka kb kc kd b">move</code>-拖动项目所代表的数据应该移动，而不是复制。</li></ol><p id="10b1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae lv" href="https://developer.apple.com/documentation/uikit/uicollectionviewdropproposal" rel="noopener ugc nofollow" target="_blank">uicollectionviewdroposal</a>—uidroproposal的一个子类，专门用于处理DropProposal的集合视图。</p><p id="89af" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">集合视图建议还定义了一个可选的<strong class="je hv">intent</strong>—<a class="ae lv" href="https://developer.apple.com/documentation/uikit/uicollectionviewdropintent" rel="noopener ugc nofollow" target="_blank">enum UICollectionViewDropIntent</a>，它决定了如何将内容合并到集合视图中。您可以在项目之间插入内容，或将其添加到现有项目中。意向的可能值包括:</p><ol class=""><li id="f7de" class="mj mk hu je b jf jg jj jk jn ml jr mm jv mn jz mo mp mq mr dt translated"><code class="eh ka kb kc kd b">unspecified</code> —未指定撤销提议。</li><li id="2a6f" class="mj mk hu je b jf ms jj mt jn mu jr mv jv mw jz mo mp mq mr dt translated"><code class="eh ka kb kc kd b">insertAtDestinationIndexPath</code> —在指定的索引路径插入拖放的项目。</li><li id="6257" class="mj mk hu je b jf ms jj mt jn mu jr mv jv mw jz mo mp mq mr dt translated"><code class="eh ka kb kc kd b">insertIntoDestinationIndexPath</code> —将拖放的项目合并到指定索引路径的项目中。</li></ol><p id="39d5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">集合视图使用<code class="eh ka kb kc kd b">intent</code>信息向用户提供适当的<strong class="je hv">视觉反馈</strong>。</p><p id="da6a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们知道了什么是撤销提议，我们现在需要弄清楚的是如何以及在哪里实现它。</p><p id="3e87" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ka kb kc kd b">UICollectionViewDropDelegate</code>提供了一种方法，您可以在其中指定想要使用的删除建议，即:</p><pre class="lx ly lz ma fq mb kd mc md aw me dt"><span id="e9f2" class="lh kf hu kd b fv mf mg l mh mi"><a class="ae lv" href="https://developer.apple.com/documentation/uikit/uicollectionviewdropdelegate/2897375-collectionview" rel="noopener ugc nofollow" target="_blank">collectionView(_:dropSessionDidUpdate:withDestinationIndexPath:)</a></span></pre><p id="60d8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当用户拖动内容时，集合视图会重复调用此方法，以确定如果放置发生在指定位置，您将如何处理放置。</p><p id="3a3c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为这个方法在用户拖动集合视图时被重复调用，<strong class="je hv">您的实现应该尽快返回</strong>。</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="4e98" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在上面的代码中，我使用了两个属性:</p><ol class=""><li id="2347" class="mj mk hu je b jf jg jj jk jn ml jr mm jv mn jz mo mp mq mr dt translated"><a class="ae lv" href="https://developer.apple.com/documentation/uikit/uidropsession/2890985-localdragsession" rel="noopener ugc nofollow" target="_blank"> localDragSession </a> —如果拖动活动在不同的应用程序中启动，则本地拖动会话为<code class="eh ka kb kc kd b">nil</code>。</li><li id="ee58" class="mj mk hu je b jf ms jj mt jn mu jr mv jv mw jz mo mp mq mr dt translated"><a class="ae lv" href="https://developer.apple.com/documentation/uikit/uicollectionview/2897415-hasactivedrag" rel="noopener ugc nofollow" target="_blank"> hasActiveDrag </a> —一个布尔值，指示项目是否已从集合视图中被提升且尚未被丢弃。</li></ol><p id="9bea" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以上代码说明了这一点:</p><ol class=""><li id="6b46" class="mj mk hu je b jf jg jj jk jn ml jr mm jv mn jz mo mp mq mr dt translated">第16行—如果拖动活动是在另一个应用程序中开始的，<strong class="je hv">禁止</strong>拖放。</li><li id="0573" class="mj mk hu je b jf ms jj mt jn mu jr mv jv mw jz mo mp mq mr dt translated">第7行——否则，如果该项是从您正在拖放它的同一个集合视图中被提升的，那么<strong class="je hv">将它从源索引路径移动(重新排序)</strong>到目标索引路径。</li><li id="27f1" class="mj mk hu je b jf ms jj mt jn mu jr mv jv mw jz mo mp mq mr dt translated">第11行——否则，如果您将它放到另一个集合视图中，那么<strong class="je hv">将该项复制到目标索引路径。</strong></li></ol><h2 id="bd52" class="lh kf hu bd kg li lj lk kk ll lm ln ko jn lo lp ks jr lq lr kw jv ls lt la lu dt translated">处理丢弃—复制</h2><p id="4894" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">在明确了我们打算如何处理放置之后，让我们来看看一旦实际放置完成，我们需要做什么的实现细节。</p><p id="2515" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要允许在集合视图中拖放项目，实现唯一需要的方法<code class="eh ka kb kc kd b">UICollectionViewDropDelegate</code>。</p><p id="bd5d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">也就是:<br/> <code class="eh ka kb kc kd b">collectionView(_:performDropWith:)</code> —告诉您的代理将拖放数据合并到集合视图中。</p><p id="e400" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个方法为您提供了一个<a class="ae lv" href="https://developer.apple.com/documentation/uikit/uicollectionviewdropcoordinator" rel="noopener ugc nofollow" target="_blank">UICollectionViewDropCoordinator</a>对象，您可以使用它来处理拖放操作。使用<code class="eh ka kb kc kd b">coordinator</code>，您可以获取以下项目来更新您的收藏视图的数据源:</p><ol class=""><li id="497e" class="mj mk hu je b jf jg jj jk jn ml jr mm jv mn jz mo mp mq mr dt translated"><code class="eh ka kb kc kd b">items</code> —被拖动的项目</li><li id="7cee" class="mj mk hu je b jf ms jj mt jn mu jr mv jv mw jz mo mp mq mr dt translated"><code class="eh ka kb kc kd b">destinationIndexPath</code> —在集合视图中插入项目的索引路径。这是一个<strong class="je hv">可选的</strong>值。如果项目被插入到空的集合视图或集合视图的末尾，则返回<code class="eh ka kb kc kd b">nil</code>。</li><li id="b71c" class="mj mk hu je b jf ms jj mt jn mu jr mv jv mw jz mo mp mq mr dt translated"><code class="eh ka kb kc kd b">proposal</code> —当前关于如何合并已删除项目的建议</li></ol><p id="4edb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此外，当合并项目时，使用<code class="eh ka kb kc kd b">coordinator</code>对象的<code class="eh ka kb kc kd b">drop(_:to:)</code>或<code class="eh ka kb kc kd b">drop(_:toItemAt:)</code>方法来制作从拖动项目的预览到集合视图中相应项目的动画。</p><p id="d8ce" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在让我们看一些代码。</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="4cce" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面的代码非常简单:</p><ol class=""><li id="af5d" class="mj mk hu je b jf jg jj jk jn ml jr mm jv mn jz mo mp mq mr dt translated"><code class="eh ka kb kc kd b">destinationIndexPath</code>取自<code class="eh ka kb kc kd b">coordinator</code>。在是<code class="eh ka kb kc kd b">nil</code>的情况下，集合视图的最后一个索引路径被用作放置项目的目的地。</li><li id="6b0a" class="mj mk hu je b jf ms jj mt jn mu jr mv jv mw jz mo mp mq mr dt translated">根据撤销建议的<code class="eh ka kb kc kd b">operation</code> — <code class="eh ka kb kc kd b">move/copy/forbidden/cancel</code>采取适当的措施来更新集合视图。</li></ol><p id="3c7c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您的丢弃建议是<code class="eh ka kb kc kd b"><strong class="je hv">cancel/forbidden</strong></code>，将不会调用<code class="eh ka kb kc kd b">collectionView(_:performDropWith:)</code>来处理丢弃，因此您不需要对其做任何特殊处理。</p><p id="5d7b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果建议的处理方式是<code class="eh ka kb kc kd b"><strong class="je hv">move</strong></code>，我们需要重新排序项目。我们将在下一节讨论更多关于重新排序的内容。</p><p id="6d4c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这一节中，让我们看看如果我们打算<code class="eh ka kb kc kd b"><strong class="je hv">copy</strong></code>这些项目，如何处理drop。</p><p id="2c05" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以使用收藏视图的<code class="eh ka kb kc kd b"><a class="ae lv" href="https://developer.apple.com/documentation/uikit/uicollectionview/1618045-performbatchupdates" rel="noopener ugc nofollow" target="_blank">performBatchUpdates(_:completion:)</a></code>在收藏视图中进行更改。</p><p id="fc0b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果希望在一个动画操作中对集合视图进行多次更改，而不是在几个单独的动画中进行更改，则可以使用此方法。</p><p id="0443" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在批处理操作中，删除是在插入之前处理的。这意味着相对于批处理操作之前集合视图状态的索引来处理删除的索引，相对于批处理操作中所有删除之后状态的索引来处理插入的索引。</p><p id="d4b1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可以这样做:</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="c283" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要获取与拖动项目相对应的数据，您可以使用以下选项之一:</p><ol class=""><li id="9703" class="mj mk hu je b jf jg jj jk jn ml jr mm jv mn jz mo mp mq mr dt translated"><code class="eh ka kb kc kd b">localObject</code>如果设置了拖拽项的属性，则可以使用。如果内容来自您应用程序中的其他地方，它将可用。</li><li id="4d45" class="mj mk hu je b jf ms jj mt jn mu jr mv jv mw jz mo mp mq mr dt translated">此外，您可以使用拖动项的<code class="eh ka kb kc kd b">itemProvider</code>属性来获取数据。</li></ol><h2 id="9715" class="lh kf hu bd kg li lj lk kk ll lm ln ko jn lo lp ks jr lq lr kw jv ls lt la lu dt translated">处理丢弃-重新排序</h2><p id="8379" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">当drop proposal被指定为— <strong class="je hv"> move </strong>时，将对单元格进行重新排序。</p><p id="773d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">重新排序</strong> —根据您的要求，在相同/不同的集合视图或表格视图中将项目从源索引路径移动到目标索引路径。</p><p id="724c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我在这里明确地指的是表视图，因为表视图和集合视图处理重新排序的方式有点不同。我们将在这里讨论这两个问题。</p><p id="6a7c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">在表格视图</strong>中，重新排序功能早就可以使用了。好的一面是我们可以继续使用它😅。不需要做任何特殊的事情来支持表视图中的重新排序。你只需要:</p><ol class=""><li id="523b" class="mj mk hu je b jf jg jj jk jn ml jr mm jv mn jz mo mp mq mr dt translated">返回<code class="eh ka kb kc kd b">move</code>作为您在<code class="eh ka kb kc kd b"><a class="ae lv" href="https://developer.apple.com/documentation/uikit/uitableviewdropdelegate/2897302-tableview" rel="noopener ugc nofollow" target="_blank">tableView(_:dropSessionDidUpdate:withDestinationIndexPath:)</a></code>中的丢弃建议，以支持重新订购。</li><li id="a2f8" class="mj mk hu je b jf ms jj mt jn mu jr mv jv mw jz mo mp mq mr dt translated">实现<code class="eh ka kb kc kd b">UITableViewDataSource</code>的<code class="eh ka kb kc kd b"><a class="ae lv" href="https://developer.apple.com/documentation/uikit/uitableviewdatasource/1614927-tableview" rel="noopener ugc nofollow" target="_blank">tableView(_:canMoveRowAt:)</a></code>和<code class="eh ka kb kc kd b"><a class="ae lv" href="https://developer.apple.com/documentation/uikit/uitableviewdatasource/1614867-tableview" rel="noopener ugc nofollow" target="_blank">tableView(_:moveRowAt:to:)</a></code>方法。</li></ol><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="2c2e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果实现了上述<code class="eh ka kb kc kd b">UITableViewDataSource</code>方法，将不会调用<code class="eh ka kb kc kd b"><a class="ae lv" href="https://developer.apple.com/documentation/uikit/uitableviewdropdelegate/2897427-tableview" rel="noopener ugc nofollow" target="_blank">tableView(_:performDropWith:)</a></code>来处理掉落。</p><p id="4965" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">在收藏视图</strong>中，重新排序的处理方式与复制相同。唯一的区别是——<strong class="je hv">在复制</strong>时，您在目标索引路径插入了一个全新的项目，但是<strong class="je hv">在重新排序</strong>时，您需要从源索引路径删除一个项目，并将其插入到目标索引路径。</p><p id="30b3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">逻辑稍有改变，其余一切保持不变。</p><p id="43fd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">注意:</strong>从<code class="eh ka kb kc kd b">collectionView(_:performDropWith:)</code>中的<code class="eh ka kb kc kd b">coordinator</code>获得的<code class="eh ka kb kc kd b">destinationIndexPath</code>可能是集合视图中的项目数，如果您尝试将项目重新排序到集合视图的末尾。在重新排序的情况下，集合视图中的项目数量保持不变。所以你需要明确地处理它，因为它可能会抛出<code class="eh ka kb kc kd b">Array index out of bounds</code>运行时错误。</p><p id="e485" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">哦等等！我有<code class="eh ka kb kc kd b">destinationIndexPath</code>，但是我从哪里得到<code class="eh ka kb kc kd b">sourceIndexPath</code>？</p><p id="b150" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们对此也有答案。</p><p id="35e2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用<code class="eh ka kb kc kd b">coordinator</code>可以获得与每个项目相对应的<code class="eh ka kb kc kd b"><a class="ae lv" href="https://developer.apple.com/documentation/uikit/uicollectionviewdropitem/2897392-sourceindexpath" rel="noopener ugc nofollow" target="_blank">sourceIndexPath</a></code>。如果该项源自同一个集合视图，则此属性包含该项的原始索引路径。</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="fbdb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在上面的代码中，单个项目被重新排序。您可以根据自己的需求对多个项目进行测试。</p><h2 id="26bc" class="lh kf hu bd kg li lj lk kk ll lm ln ko jn lo lp ks jr lq lr kw jv ls lt la lu dt translated">重新排序速度—重新排序节奏</h2><p id="3e40" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">在重新排序的情况下，当您将项目拖动到接受拖放的集合视图上时，集合视图会向用户提供适当的视觉反馈——移动/重新排序单元格以容纳新的单元格。</p><p id="1417" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以在集合视图对象上使用类型<a class="ae lv" href="https://developer.apple.com/documentation/uikit/uicollectionviewreorderingcadence" rel="noopener ugc nofollow" target="_blank">enum uicollectionviewrorderingcadence</a>的<a class="ae lv" href="https://developer.apple.com/documentation/uikit/uicollectionview/2897347-reorderingcadence" rel="noopener ugc nofollow" target="_blank"> reorderingCadence </a>来控制重新排序的速度，以获得更好的用户体验。</p><p id="a98d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ka kb kc kd b">reorderingCadence</code>可以有这些可能的值:</p><ol class=""><li id="760f" class="mj mk hu je b jf jg jj jk jn ml jr mm jv mn jz mo mp mq mr dt translated"><code class="eh ka kb kc kd b">immediate</code> —项目会立即重新排序到位。(<strong class="je hv">默认值</strong>)</li><li id="005f" class="mj mk hu je b jf ms jj mt jn mu jr mv jv mw jz mo mp mq mr dt translated"><code class="eh ka kb kc kd b">fast</code> —商品会很快重新排序，但会有短暂的延迟。</li><li id="a7fc" class="mj mk hu je b jf ms jj mt jn mu jr mv jv mw jz mo mp mq mr dt translated"><code class="eh ka kb kc kd b">slow</code> —项目在延迟后重新排序。</li></ol><p id="5312" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<code class="eh ka kb kc kd b">viewDidLoad()</code>中为您的集合视图对象设置适当的<code class="eh ka kb kc kd b">reorderingCadence</code>值。</p><pre class="lx ly lz ma fq mb kd mc md aw me dt"><span id="20b2" class="lh kf hu kd b fv mf mg l mh mi">collectionView.reorderingCadence = .fast</span></pre><h2 id="2130" class="lh kf hu bd kg li lj lk kk ll lm ln ko jn lo lp ks jr lq lr kw jv ls lt la lu dt translated">拖动预览UIDragPreviewParameters</h2><p id="b127" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">当某项被提升时，默认情况下，集合视图使用该项的可见边界来创建预览。如果您想要自定义项目的外观，可以通过预览参数来实现。</p><p id="357c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae lv" href="https://developer.apple.com/documentation/uikit/uidragpreviewparameters" rel="noopener ugc nofollow" target="_blank">UIDragPreviewParameters</a>—一组用于调整拖动项目预览外观的参数。</p><p id="017d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些参数指定预览的不同视觉方面，包括背景颜色和与预览相关联的视图的可见区域。</p><p id="ef9e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您不想对拖动预览进行任何更改，请不要实现该方法，或者如果实现了该方法，请返回<code class="eh ka kb kc kd b">nil </code>。</p><p id="7d5e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要定制拖动预览，实现<code class="eh ka kb kc kd b">UICollectionViewDropDelegate</code>的<code class="eh ka kb kc kd b"><a class="ae lv" href="https://developer.apple.com/documentation/uikit/uicollectionviewdragdelegate/2897459-collectionview" rel="noopener ugc nofollow" target="_blank">collectionView(_:dragPreviewParametersForItemAt:)</a></code>方法。</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="5c1d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就是这样。这就是在集合和表格视图中使用拖放功能所需的全部内容。继续..试试看！！</p><h1 id="27c0" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">示例项目</h1><p id="1750" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">你可以从<a class="ae lv" href="https://github.com/pgpt10/DragAndDrop-CollectionView" rel="noopener ugc nofollow" target="_blank">这里</a>下载示例项目。</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div class="fe ff mz"><img src="../Images/7cfee7e2813040235f6ca6b0744659de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*ST2JF7fK3Ao5L82amVt0RA.gif"/></div></figure><h1 id="cb0a" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">促销</h1><p id="5c62" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">别忘了阅读我的其他文章:</p><ol class=""><li id="b604" class="mj mk hu je b jf jg jj jk jn ml jr mm jv mn jz mo mp mq mr dt translated"><a class="ae lv" href="https://hackernoon.com/everything-about-codable-in-swift-4-97d0e18a2999" rel="noopener ugc nofollow" target="_blank">Swift 4中关于Codable的一切</a></li><li id="5752" class="mj mk hu je b jf ms jj mt jn mu jr mv jv mw jz mo mp mq mr dt translated"><a class="ae lv" href="https://medium.freecodecamp.org/ios-10-notifications-inshorts-all-in-one-ad727e03983a" rel="noopener ugc nofollow" target="_blank">你一直想知道的关于iOS通知的一切</a></li><li id="e944" class="mj mk hu je b jf ms jj mt jn mu jr mv jv mw jz mo mp mq mr dt translated"><a class="ae lv" href="https://hackernoon.com/color-it-with-gradients-ios-a4b374c3c79f" rel="noopener ugc nofollow" target="_blank">用渐变给它上色——iOS</a></li><li id="f6f5" class="mj mk hu je b jf ms jj mt jn mu jr mv jv mw jz mo mp mq mr dt translated"><a class="ae lv" href="https://hackernoon.com/app-extensions-and-today-extensions-widget-in-ios-10-e2d9fd9957a8" rel="noopener ugc nofollow" target="_blank">关于iOS 10中的今日扩展(Widget)你需要知道的一切</a></li><li id="7841" class="mj mk hu je b jf ms jj mt jn mu jr mv jv mw jz mo mp mq mr dt translated"><a class="ae lv" href="https://hackernoon.com/uicollectionviewcell-selection-made-easy-41dae148379d" rel="noopener ugc nofollow" target="_blank"> UICollectionViewCell选择变得简单..！！</a></li></ol><p id="2fef" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你有任何疑问，请随时发表评论。</p></div></div>    
</body>
</html>