<html>
<head>
<title>Caching — Necessary evil</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">缓存——不可避免的罪恶</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/caching-necessary-evil-b5511140b26d?source=collection_archive---------8-----------------------#2016-12-26">https://medium.com/hackernoon/caching-necessary-evil-b5511140b26d?source=collection_archive---------8-----------------------#2016-12-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="0b24" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在设计低延迟、高吞吐量的系统时，缓存起着重要的作用。当您希望处理请求时，您希望尽可能避免I/O操作。原因是这样做需要时间—磁盘寻道成本高，网络呼叫成本高。典型时间(<a class="ae jp" href="http://norvig.com/21-days.html" rel="noopener ugc nofollow" target="_blank">来源</a>)</p><p id="44bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过1 Gbps网络发送2K字节— 20，000纳秒</p><p id="6100" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从内存中顺序读取1MB—250，000 ns</p><p id="41cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从磁盘顺序读取1MB—20，000，000 ns</p><p id="62e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在缓存时，应该始终牢记数据的规模。我思考缓存的过程如下。</p><h2 id="9dca" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated"><strong class="ak">你真的需要缓存吗？</strong></h2><p id="095a" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">缓存会导致不一致，应该尽可能避免。检查系统是否满足非功能性要求(NFR)、延迟和吞吐量，无需缓存。如果这样做，不要在系统中添加缓存。如果没有，检查需求是否正确，是否真的需要严格的nfr。例如:</p><p id="cc15" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(a)如果有人说您需要在10毫秒内获取30个项目的数据，这可能不现实。如果等待时间为100毫秒，这可能是合理的。</p><p id="7198" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(b)许多时候，对不同系统的调用是并行进行的。考虑一个调用服务A和B的系统，然后计算合并结果的输出。如果有人说延迟应该是100毫秒，而B应该是200毫秒。你的系统在没有缓存的情况下可以工作150毫秒。你应该尝试在100毫秒的数字背后进行推理(你应该总是质疑来自魔法帽的数字)。如果没有推理，应该改成200 ms，不做缓存。</p><h2 id="3186" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">数据大小和使用模式</h2><p id="3ea2" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">一种安全的缓存方法是使用中央缓存存储。它确保您的所有应用程序实例读取相同的值(为了简单起见，让我们忽略缓存存储中的复制延迟)。更新值也很容易，因为您只需要在中央缓存中进行更新。但是根据我们需要缓存的数据和大小，我们可以采用几种不同的方法。</p><p id="847c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="kq"> (a)几MBs的不可变数据或缓慢变化的数据</em></p><p id="3cc9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于这种情况，可以考虑在应用程序内存中进行缓存。在运行时使用预加载，或者在第一次读取时使用惰性加载。对于不可变数据，不需要传播写操作。此外，它还减少了一个需要维护的组件。为了更新，实体可以在一段时间后到期，以便可以加载新数据。例如:假设您想要缓存某个国家/地区的名称或pin。或参加特定比赛的运动员名单。</p><p id="68b2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="kq"> (b)数百兆字节的不可变或缓慢变化的数据</em></p><p id="2c33" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于变化缓慢的数据，您不应该将数据保存在内存中，而应该将其移动到数据存储中。但是，您可以将数据保存在与服务相同的盒子中，即，将应用程序和缓存数据存储放在同一台机器中。它减少了网络延迟，但代价是陈旧数据和写入复杂性的增加(因为您必须写入所有机器的缓存)。但是，如果您在处理请求时需要获取大量数据，这可能是值得探索的。将写入传播到缓存的一个策略可以是在主存储上设置侦听器，它更新所有应用程序计算机上的缓存。只有当中央缓存存储不符合我的要求时，我才会选择它。</p><p id="f587" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一个代价是，无论何时添加新实例，缓存都需要预热。因此，新机器高效运行可能需要时间。</p><p id="c474" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="kq"> (c)单位为GBs </em></p><p id="d5f2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你应该选择中央缓存。否则，它可能会限制您可以使用的机器类型。如果你使用云服务，你可能需要更贵的机器。缓存预热时间也会增加。更大的数据意味着更多的实体。即使单个的变化率更大，累积的变化率也可能很大。</p><blockquote class="kr ks kt"><p id="1639" class="ir is kq it b iu iv iw ix iy iz ja jb ku jd je jf kv jh ji jj kw jl jm jn jo hn dt translated">(d)不同数据中心的数据</p></blockquote><p id="01ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这种情况下，每个数据中心一个缓存数据存储可能是有用的。如果仅在一个数据中心，网络延迟会很大，可能会抵消缓存的优势(因为从主数据存储读取的时间可能会少于网络延迟)。</p><h2 id="0014" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">驱逐政策</h2><p id="9815" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">对于缓存，你通常必须考虑驱逐策略。如果空间不足，应该使用基于大小的策略来清除缓存。如果数据在一定时间后变得陈旧，请使用基于时间的策略。如果你有足够的内存并且数据不会过时，你可以不驱逐数据。</p><p id="be01" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一般来说，LRU和LFU的策略是选择需要删除的条目。</p><h2 id="7b08" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated"><strong class="ak">战争故事</strong></h2><p id="181f" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">(a)每天晚上7点的DB负载</p><p id="a54c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每天晚上7点，db的负载增加。这是因为使用了基于时间的缓存策略。同时也是网站流量最高的时候。将缓存重新加载时间移到网站流量较少的清晨解决了这个问题。</p><p id="55aa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">学习:如果你使用基于时间的驱逐。确保你在网站流量少的时候做</p><p id="090c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(b)用户无法更新个人资料</p><p id="1209" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我听说的一个例子是人们缓存了个人资料页面显示的用户数据。当人们更新他们的信息，并再次进入个人资料页面，他们看到相同的数据。他们又试了一次，结果还是一样。虽然它在数据库中更新，由于缓存用户数据无法看到更新的结果。</p><p id="e33f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">学习:你应该小心更新和你应该在哪里缓存数据</p><p id="2755" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">页（page的缩写）这是我随着时间的推移学到的东西的杂凑。如果我漏掉了什么参考文献，一定要告诉我，我会补充的</p><blockquote class="kr ks kt"><p id="ab17" class="ir is kq it b iu iv iw ix iy iz ja jb ku jd je jf kv jh ji jj kw jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is kq it b iu iv iw ix iy iz ja jb ku jd je jf kv jh ji jj kw jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is kq it b iu iv iw ix iy iz ja jb ku jd je jf kv jh ji jj kw jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>