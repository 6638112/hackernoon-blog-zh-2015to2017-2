<html>
<head>
<title>Defeating Evil with Data Structures!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用数据结构战胜邪恶！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/defeating-evil-with-data-structures-56335c0a6403?source=collection_archive---------12-----------------------#2017-06-25">https://medium.com/hackernoon/defeating-evil-with-data-structures-56335c0a6403?source=collection_archive---------12-----------------------#2017-06-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="f345" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在上周的文章的<a class="ae jp" href="https://www.mmhaskell.com/blog/2017/6/19/profiling-in-haskell" rel="noopener ugc nofollow" target="_blank">中，我们使用基准测试来确定我们的代码在某些输入上的表现。首先，我们使用标准库来获取代码的一些度量。然后，我们能够在一些漂亮的输出中查看这些测量。我们还分析了我们的代码，试图确定是哪部分代码降低了我们的速度。</a></p><p id="75e2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">分析输出突出显示了两个耗费大量时间的函数。当我们分析它们时，我们发现它们效率很低。在本文中，我们将解决这些问题，并以几种不同的方式改进我们的代码。首先，我们将使用一个数组而不是一个列表来使我们的值访问更快。然后，我们将添加一个很酷的数据结构，称为段树。这将帮助我们快速获得特定间隔内的最小高度值。</p><p id="27e4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本系列文章中的代码示例很好地利用了堆栈工具。如果您以前从未使用过Stack，您应该看看我们新推出的免费<a class="ae jp" href="http://academy.mondaymorninghaskell/p/your-first-haskell-project" rel="noopener ugc nofollow" target="_blank"> Stack迷你课程</a>。它将带您了解组织代码、获取依赖关系和运行命令的基本知识。</p><h1 id="f8ca" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">哪里出了问题？</h1><p id="3b66" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">所以首先让我们花点时间提醒自己为什么这些功能会让我们慢下来。我们的最小高度函数和索引函数的值都在<code class="eh kt ku kv kw b">O(n)</code>时间内运行。这意味着在最坏的情况下，他们每个人都可以扫描整个列表。接下来，我们观察到这两个函数都将被调用<code class="eh kt ku kv kw b">O(n)</code>次。这样我们的总算法将是<code class="eh kt ku kv kw b">O(n^2)</code>时间。我们采用的时间基准支持了这一理论。</p><p id="d2d8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们上面提到的数据结构将帮助我们在不进行全面扫描的情况下获得我们需要的值。我们将从用一个数组替换我们的列表开始，因为这要容易得多。</p><h1 id="9c28" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">数组</h1><p id="4508" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">当我们解决函数式编程问题时，链表是非常常见的。它们有一些很好的属性，并且非常适合递归。但是，它们不允许通过索引进行快速访问。对于这些情况，我们需要使用数组。数组在Haskell中不像其他语言那样常见，也有一些不同。</p><p id="ceb1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，Haskell数组有两个类型参数。当你在Java中创建一个数组时，你可以说它是一个int数组(<code class="eh kt ku kv kw b">int[]</code>)还是一个string数组(<code class="eh kt ku kv kw b">String[]</code>)，或者其他任何类型。所以这只是一个单一的参数。每当我们想对数组进行索引时，我们总是使用整数。</p><p id="0bbf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Haskell中，我们可以选择数组存储的类型和索引数组的类型。现在，索引类型必须属于index ( <code class="eh kt ku kv kw b">Ix</code> ) typeclass。在这种情况下，我们将使用<code class="eh kt ku kv kw b">Int</code>。但是知道你有更多的灵活性是很酷的。例如，考虑表示一个矩阵。在Java中，我们必须使用“数组的数组”。这涉及到许多笨拙的语法。在Haskell中，我们可以使用由整数元组索引的单个数组！如果我们愿意，我们也可以从1开始而不是从0开始索引。</p><p id="2b1a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以对于我们的问题，我们将使用<code class="eh kt ku kv kw b">Array Int Int</code>作为我们的内部栅栏值，而不是一个普通的列表。不过，我们只需要对代码做一些修改！首先，我们将导入几个模块，并更改我们的类型以使用数组:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="8ef4" class="lf jr hu kw b fv lg lh l li lj">import Data.Array<br/>import Data.Ix (range)</span><span id="5325" class="lf jr hu kw b fv lk lh l li lj">...</span><span id="2216" class="lf jr hu kw b fv lk lh l li lj">newtype FenceValues = FenceValues { unFenceValues :: Array Int Int }</span></pre><p id="bdfa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，我们将使用专门的数组索引<code class="eh kt ku kv kw b">(!)</code>操作符来访问它们，而不是使用<code class="eh kt ku kv kw b">(!!)</code>来按索引访问。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="62a7" class="lf jr hu kw b fv lg lh l li lj">valueAtIndex :: FenceValues -&gt; FenceIndex -&gt; Int<br/>valueAtIndex values index = (unFenceValues values) ! (unFenceIndex index)</span></pre><p id="f31e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我们来改进一下我们的<code class="eh kt ku kv kw b">minimumHeight</code>功能。我们现在将在数组上使用<code class="eh kt ku kv kw b">range</code>函数，而不是求助于<code class="eh kt ku kv kw b">drop</code>和<code class="eh kt ku kv kw b">take</code>。注意，我们现在使用<code class="eh kt ku kv kw b">right - 1</code>，因为我们想排除区间的右端点。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="a19d" class="lf jr hu kw b fv lg lh l li lj">where<br/>    valsInInterval :: [(FenceIndex, Int)]<br/>    valsInInterval = zip <br/>      (FenceIndex &lt;$&gt; intervalRange) <br/>      (map ((unFenceValues values) !) intervalRange)<br/>      where<br/>        intervalRange = range (left, right - 1)</span></pre><p id="ec51" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还必须改变我们的基准测试代码，以产生数组而不是列表:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="8421" class="lf jr hu kw b fv lg lh l li lj">import Data.Array(listArray)</span><span id="fbb4" class="lf jr hu kw b fv lk lh l li lj">…</span><span id="c2e8" class="lf jr hu kw b fv lk lh l li lj">randomList :: Int -&gt; IO FenceValues<br/>randomList n = FenceValues . mkListArray &lt;$&gt; <br/>  (sequence $ replicate n (randomRIO (1, 10000 :: Int)))<br/>  where<br/>    mkListArray vals = listArray (0, (length vals) - 1) vals</span></pre><p id="3b10" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的库和我们的基准现在都需要在Cabal文件的<code class="eh kt ku kv kw b">build-depends</code>部分使用<code class="eh kt ku kv kw b">array</code>。我们需要确保添加这个！一旦我们做到了，我们可以再次对我们的代码进行基准测试，我们会发现它已经加快了不少！</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="9de9" class="lf jr hu kw b fv lg lh l li lj">&gt;&gt; stack bench --profile<br/>Running 1 benchmarks...<br/>Benchmark fences-benchmarks: RUNNING...<br/>benchmarking fences tests/Size 1 Test<br/>time                 49.33 ns   (48.98 ns .. 49.71 ns)<br/>                     1.000 R²   (0.999 R² .. 1.000 R²)<br/>mean                 49.46 ns   (49.16 ns .. 49.86 ns)<br/>std dev              1.105 ns   (861.0 ps .. 1.638 ns)<br/>variance introduced by outliers: 33% (moderately inflated)</span><span id="8078" class="lf jr hu kw b fv lk lh l li lj">benchmarking fences tests/Size 10 Test<br/>time                 4.541 μs   (4.484 μs .. 4.594 μs)<br/>                     0.999 R²   (0.998 R² .. 1.000 R²)<br/>mean                 4.496 μs   (4.456 μs .. 4.531 μs)<br/>std dev              132.0 ns   (109.6 ns .. 164.3 ns)<br/>variance introduced by outliers: 36% (moderately inflated)</span><span id="fe04" class="lf jr hu kw b fv lk lh l li lj">benchmarking fences tests/Size 100 Test<br/>time                 79.81 μs   (79.21 μs .. 80.45 μs)<br/>                     0.999 R²   (0.999 R² .. 1.000 R²)<br/>mean                 79.51 μs   (78.93 μs .. 80.39 μs)<br/>std dev              2.396 μs   (1.853 μs .. 3.449 μs)<br/>variance introduced by outliers: 29% (moderately inflated)</span><span id="ecab" class="lf jr hu kw b fv lk lh l li lj">benchmarking fences tests/Size 1000 Test<br/>time                 1.187 ms   (1.158 ms .. 1.224 ms)<br/>                     0.995 R²   (0.992 R² .. 0.998 R²)<br/>mean                 1.170 ms   (1.155 ms .. 1.191 ms)<br/>std dev              56.61 μs   (48.02 μs .. 70.28 μs)<br/>variance introduced by outliers: 37% (moderately inflated)</span><span id="1023" class="lf jr hu kw b fv lk lh l li lj">benchmarking fences tests/Size 10000 Test<br/>time                 15.03 ms   (14.71 ms .. 15.32 ms)<br/>                     0.997 R²   (0.994 R² .. 0.999 R²)<br/>mean                 15.71 ms   (15.44 ms .. 16.03 ms)<br/>std dev              729.7 μs   (569.3 μs .. 965.4 μs)<br/>variance introduced by outliers: 16% (moderately inflated)</span><span id="f1a5" class="lf jr hu kw b fv lk lh l li lj">benchmarking fences tests/Size 100000 Test<br/>time                 191.4 ms   (189.2 ms .. 193.9 ms)<br/>                     1.000 R²   (1.000 R² .. 1.000 R²)<br/>mean                 189.3 ms   (188.2 ms .. 190.5 ms)<br/>std dev              1.471 ms   (828.0 μs .. 1.931 ms)<br/>variance introduced by outliers: 14% (moderately inflated)</span><span id="35ef" class="lf jr hu kw b fv lk lh l li lj">Benchmark fences-benchmarks: FINISH</span></pre><p id="9fdb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是乘法因子:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="73f2" class="lf jr hu kw b fv lg lh l li lj">Size 1: 49.33 ns<br/>Size 10: 4.451 μs (increased ~90x)<br/>Size 100: 79.81 μs (increased ~18x)<br/>Size 1000: 1.187 ms (increased ~15x)<br/>Size 10000: 15.03 ms (increased ~13x)<br/>Size 100000: 191.4 ms (increased ~13x)</span></pre><p id="329c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于后一种情况，将大小增加10倍似乎只会将时间增加13-15倍。我们认为我们已经达到了<code class="eh kt ku kv kw b">O(n log n)</code>时间，这是情有可原的！</p><h1 id="7231" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">更好的测试案例</h1><p id="84d4" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">但是有些事情还是不对劲。我们必须记住，这个理论并不能完全证明我们在这里的兴奋。事实上，我们的旧代码非常糟糕，正常情况是<code class="eh kt ku kv kw b">O(n^2)</code>。现在看起来我们可能已经得到了一般情况下的<code class="eh kt ku kv kw b">O(n log n)</code>。但是我们想尽可能为最坏的情况做准备。想象我们的代码被我们邪恶的对手使用:</p><figure class="kx ky kz la fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff ll"><img src="../Images/5a4513b48c674730e9f184d938305600.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/0*oDe0O6FJkLRdANyr."/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek"><a class="ae jp" href="http://imgur.com/gallery/U0F0vK4" rel="noopener ugc nofollow" target="_blank">Photo credit</a></figcaption></figure><p id="cc77" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">他会找到最糟糕的情况！在这种情况下，当输入高度列表被排序时，我们的代码将不会如此高效！</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="5bfa" class="lf jr hu kw b fv lg lh l li lj">main :: IO ()<br/>main = do<br/>  [l1, l2, l3, l4, l5, l6] &lt;- mapM <br/>    randomList [1, 10, 100, 1000, 10000, 100000]<br/>  let l7 = sortedList<br/>  defaultMain<br/>    [ bgroup "fences tests" <br/>        ...<br/>       , bench "Size 100000 Test" $ whnf largestRectangle l6<br/>      , bench "Size 100000 Test (sorted)" $ whnf largestRectangle l7<br/>      ]<br/>    ]</span><span id="47b7" class="lf jr hu kw b fv lk lh l li lj">...</span><span id="6f21" class="lf jr hu kw b fv lk lh l li lj">sortedList :: FenceValues<br/>sortedList = FenceValues $ listArray (0, 99999) [1..100000]</span></pre><p id="dd7a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将再次发现，最后一种情况需要花费很长时间，并且我们将看到运行时间的大幅增加。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="d95b" class="lf jr hu kw b fv lg lh l li lj">&gt;&gt; stack bench --profile<br/>Running 1 benchmarks...<br/>Benchmark fences-benchmarks: RUNNING...</span><span id="eb2f" class="lf jr hu kw b fv lk lh l li lj">…</span><span id="f113" class="lf jr hu kw b fv lk lh l li lj">benchmarking fences tests/Size 100000 Test (sorted)<br/>time                 378.1 s    (355.0 s .. 388.3 s)<br/>                     1.000 R²   (0.999 R² .. 1.000 R²)<br/>mean                 384.5 s    (379.3 s .. 387.2 s)<br/>std dev              4.532 s    (0.0 s .. 4.670 s)<br/>variance introduced by outliers: 19% (moderately inflated)</span><span id="8bfb" class="lf jr hu kw b fv lk lh l li lj">Benchmark fences-benchmarks: FINISH</span></pre><p id="5bb8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">平均每例6分多钟！但是这一次，我们将看到分析输出发生了变化。它只调出<code class="eh kt ku kv kw b">minimumHeightIndexValue</code>的各个部分！我们不再花很多时间在<code class="eh kt ku kv kw b">valueAtIndex</code>上。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="2ddc" class="lf jr hu kw b fv lg lh l li lj">COST CENTRE                                          %time %alloc</span><span id="589f" class="lf jr hu kw b fv lk lh l li lj">minimumHeightIndexValue.valsInInterval               65.0   67.7<br/>minimumHeightIndexValue                              22.4    0.0<br/>minimumHeightIndexValue.valsInInterval.intervalRange 12.4   32.2</span></pre><p id="5983" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以现在我们必须通过改进最小值的计算来解决这个新问题。</p><h1 id="35f3" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">分割树</h1><p id="109c" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们当前的方法仍然需要我们查看区间中的每个元素。即使我们的一些间隔会很小，也会有很多这样的更小的调用，所以总时间仍然是<code class="eh kt ku kv kw b">O(n^2)</code>。我们需要一种方法在给定的时间间隔内找到最小的项目和值，而不需要求助于线性扫描。</p><p id="3ce3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个想法是从一开始就列出这个问题所有答案的详尽清单。我们可以从所有可能的区间映射到区间中的最小索引和值。但这最终对我们没有帮助。还有<code class="eh kt ku kv kw b">n^2</code>个可能的区间。所以创建这个数据结构仍然意味着我们的代码需要花费<code class="eh kt ku kv kw b">O(n^2)</code>时间。</p><p id="2a6b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是我们的想法是正确的，即提前做一些工作。我们将不得不使用一个数据结构，虽然它不是一个详尽的列表。输入细分树。</p><p id="f290" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">细分树的结构与二叉查找树相同。每个节点对应一个区间，而不是存储一个值。每个节点将存储其时间间隔、该时间间隔内的最小值以及该值的索引。</p><p id="f098" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">树上的顶部节点将指整个阵列的间隔。它将存储最小值和索引的对。那么它将有两个子节点。左边的将在树的前半部分有最小对，右边的将有后半部分。下一层将把它分成四份，以此类推。</p><p id="f6ba" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，让我们考虑如何确定从第一个四分之一点开始到第三个四分之一点结束的最小对。我们将使用递归来实现。首先，我们将向左子树请求从四分之一点到半点的区间上的最小对。然后，我们将查询从半点到四分之三点的最小对的右树。然后我们可以把最小的那个拿回来。我不会在这里深入所有的理论，但事实证明，即使在最坏的情况下，这个操作也需要<code class="eh kt ku kv kw b">O(log n)</code>时间。</p><h1 id="7897" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">设计我们的细分树</h1><p id="5453" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在<a class="ae jp" href="https://hackage.haskell.org/package/SegmentTree-0.3/docs/Data-SegmentTree.html" rel="noopener ugc nofollow" target="_blank"> hackage </a>上有一个叫<code class="eh kt ku kv kw b">Data.SegmentTree</code>的图书馆。但是我认为从头开始实现这个数据结构会很有趣。我们将从<code class="eh kt ku kv kw b">SegmentTreeNodes</code>开始构建我们的树。每个节点要么是空的，要么包含六个字段。前两个是指节点跨越的时间间隔。下一个将是最小值和该值在区间上的索引。然后这个节点的每个子节点都有字段:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="4909" class="lf jr hu kw b fv lg lh l li lj">data SegmentTreeNode = ValueNode<br/>  { fromIndex :: FenceIndex<br/>  , toIndex :: FenceIndex<br/>  , value :: Int<br/>  , minIndex :: FenceIndex<br/>  , leftChild :: SegmentTreeNode<br/>  , rightChild :: SegmentTreeNode<br/>  }<br/>  | EmptyNode</span></pre><p id="f61b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以使这种细分树类型更加通用，这样它就不会局限于我们的栅栏问题。我鼓励你把这段代码当作一个练习来尝试！</p><h1 id="2926" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">构建细分树</h1><p id="590a" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">现在，我们将添加预处理步骤，实际构建树本身。这将使用我们之前看到的相同的间隔/尾部模式。在基本情况下，间隔的跨度仅为1，因此我们创建一个包含该值的节点，其中包含空的子节点。我们还将添加一个返回<code class="eh kt ku kv kw b">EmptyNode</code>的catchall:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="1467" class="lf jr hu kw b fv lg lh l li lj">buildSegmentTree :: Array Int Int -&gt; SegmentTreeNode<br/>buildSegmentTree ints = buildSegmentTreeTail <br/>  ints <br/>  (FenceInterval ((FenceIndex 0), (FenceIndex (length (elems ints)))))</span><span id="75d7" class="lf jr hu kw b fv lk lh l li lj">buildSegmentTreeTail :: Array Int Int -&gt; FenceInterval -&gt; SegmentTreeNode<br/>buildSegmentTreeTail array<br/>  (FenceInterval (wrappedFromIndex@(FenceIndex fromIndex), wrappedToIndex@(FenceIndex toIndex)))<br/>  | fromIndex + 1 == toIndex = ValueNode <br/>      { fromIndex = wrappedFromIndex<br/>      , toIndex = wrappedToIndex<br/>      , value = array ! fromIndex<br/>      , minIndex = wrappedFromIndex<br/>      , leftChild = EmptyNode<br/>      , rightChild = EmptyNode<br/>      }<br/>  | … missing case<br/>  | otherwise = EmptyNode</span></pre><p id="6496" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们的中间案例将成为标准案例。首先，我们将把区间分成两半，进行两次递归调用。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="7fec" class="lf jr hu kw b fv lg lh l li lj">where <br/>  average = (fromIndex + toIndex) `quot` 2<br/>  -- Recursive Calls<br/>  leftChild = buildSegmentTreeTail <br/>    array (FenceInterval (wrappedFromIndex, (FenceIndex average)))<br/>  rightChild = buildSegmentTreeTail <br/>    array (FenceInterval ((FenceIndex average), wrappedToIndex))</span></pre><p id="97c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，我们将编写一个函数来提取最小值和索引，但处理空节点的情况:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="16f0" class="lf jr hu kw b fv lg lh l li lj">-- Get minimum val and index, but account for empty case.<br/>valFromNode :: SegmentTreeNode -&gt; (Int, FenceIndex)<br/>valFromNode EmptyNode = (maxBound :: Int, FenceIndex (-1))<br/>valFromNode n@ValueNode{} = (value n, minIndex n)</span></pre><p id="58f6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们将比较这三种情况的最小值。很可能是左边或右边的值。否则就是当前值。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="6861" class="lf jr hu kw b fv lg lh l li lj">leftCase = valFromNode leftChild<br/>rightCase = valFromNode rightChild<br/>currentCase = (array ! fromIndex, wrappedFromIndex)<br/>(newValue, newIndex) = min (min leftCase rightCase) currentCase</span></pre><p id="fc66" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我们将通过填充中间/正常情况下缺失的变量来完成我们的定义。下面是完整的功能:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="2f68" class="lf jr hu kw b fv lg lh l li lj">buildSegmentTreeTail :: Array Int Int -&gt; FenceInterval -&gt; SegmentTreeNode<br/>buildSegmentTreeTail array<br/>  (FenceInterval (wrappedFromIndex@(FenceIndex fromIndex), wrappedToIndex@(FenceIndex toIndex)))<br/>  | fromIndex + 1 == toIndex = ValueNode <br/>      { fromIndex = wrappedFromIndex<br/>      , toIndex = wrappedToIndex<br/>      , value = array ! fromIndex<br/>      , minIndex = wrappedFromIndex<br/>      , leftChild = EmptyNode<br/>      , rightChild = EmptyNode<br/>      }<br/>  | fromIndex &lt; toIndex = ValueNode <br/>    { fromIndex = wrappedFromIndex<br/>    , toIndex = wrappedToIndex<br/>    , value = newValue<br/>    , minIndex = newIndex<br/>    , leftChild = leftChild<br/>    , rightChild = rightChild<br/>    }<br/>  | otherwise = EmptyNode<br/>    where <br/>      average = (fromIndex + toIndex) `quot` 2<br/>      -- Recursive Calls<br/>      leftChild = buildSegmentTreeTail <br/>        array (FenceInterval (wrappedFromIndex, (FenceIndex average)))<br/>      rightChild = buildSegmentTreeTail <br/>        array (FenceInterval ((FenceIndex average), wrappedToIndex))</span><span id="ec17" class="lf jr hu kw b fv lk lh l li lj">      -- Get minimum val and index, but account for empty case.<br/>      valFromNode :: SegmentTreeNode -&gt; (Int, FenceIndex)<br/>      valFromNode EmptyNode = (maxBound :: Int, FenceIndex (-1))<br/>      valFromNode n@ValueNode{} = (value n, minIndex n)</span><span id="9c6b" class="lf jr hu kw b fv lk lh l li lj">      leftCase = valFromNode leftChild<br/>      rightCase = valFromNode rightChild<br/>      currentCase = (array ! fromIndex, wrappedFromIndex)<br/>      (newValue, newIndex) = min (min leftCase rightCase) currentCase</span></pre><h1 id="c75c" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">寻找最小值</h1><p id="5a5a" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">现在让我们写出在给定区间内求最小值的临界函数。我们将添加我们的树作为另一个参数。然后，我们将处理<code class="eh kt ku kv kw b">EmptyNode</code>案例，然后展开我们在完整案例中的值:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="51cb" class="lf jr hu kw b fv lg lh l li lj">minimumHeightIndexValue :: FenceValues -&gt; SegmentTreeNode -&gt; FenceInterval -&gt; (FenceIndex, Int)<br/>minimumHeightIndexValue values tree <br/>  originalInterval@(FenceInterval (FenceIndex left, FenceIndex right)) =<br/>  case tree of<br/>    EmptyNode -&gt; (maxBound :: Int, -1)<br/>    ValueNode<br/>      { fromIndex = FenceIndex nFromIndex<br/>      , toIndex = FenceIndex nToIndex<br/>      , value = nValue<br/>      , minIndex = nMinIndex<br/>      , leftChild = nLeftChild<br/>      , rightChild = nRightChild} -&gt;</span></pre><p id="e375" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，我们将处理基本情况，即我们位于正确的节点:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="b538" class="lf jr hu kw b fv lg lh l li lj">| left == nFromIndex &amp;&amp; right == nToIndex = (nValue, nMinIndex)</span></pre><p id="e5d5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，我们将观察只需要一次递归调用的两种情况。如果右边的索引低于中间点，我们递归调用左边的子节点。如果左边的指数高于中间点，我们将调用右边的指数(稍后我们将计算平均值)。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="974b" class="lf jr hu kw b fv lg lh l li lj">| otherwise = if right &lt; average <br/>  then minimumHeightIndexValue values nLeftChild originalInterval<br/>  else if left &gt;= average<br/>    then minimumHeightIndexValue values nRightChild originalInterval</span></pre><p id="4107" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我们有一个棘手的部分。如果区间越过了中间标记，我们将不得不把它分成两个子区间。然后我们将进行两个递归调用，并得到它们的解。最后，我们将比较这两种解决方案，选择较小的一个。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="0366" class="lf jr hu kw b fv lg lh l li lj">else minTuple leftResult rightResult<br/>  where<br/>    average = (nFromIndex + nToIndex) `quot` 2<br/>    leftResult = minimumHeightIndexValue values nLeftChild<br/>      (FenceInterval (FenceIndex left, FenceIndex average))<br/>    rightResult = minimumHeightIndexValue values nRightChild<br/>      (FenceInterval (FenceIndex average, FenceIndex right))<br/>    minTuple :: (FenceIndex, Int) -&gt; (FenceIndex, Int) -&gt; (FenceIndex, Int)<br/>    minTuple old@(_, heightOld) new@(_, heightNew) =<br/>      if heightNew &lt; heightOld then new else old</span></pre><p id="56bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了清楚起见，下面是完整的函数:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="0f93" class="lf jr hu kw b fv lg lh l li lj">minimumHeightIndexValue :: FenceValues -&gt; SegmentTreeNode -&gt; FenceInterval -&gt; (FenceIndex, Int)<br/>minimumHeightIndexValue values tree <br/>  originalInterval@(FenceInterval (FenceIndex left, FenceIndex right)) =<br/>  case tree of<br/>    EmptyNode -&gt; (maxBound :: Int, -1)<br/>    ValueNode<br/>      { fromIndex = FenceIndex nFromIndex<br/>      , toIndex = FenceIndex nToIndex<br/>      , value = nValue<br/>      , minIndex = nMinIndex<br/>      , leftChild = nLeftChild<br/>      , rightChild = nRightChild} -&gt;<br/>        | left == nFromIndex &amp;&amp; right == nToIndex = (nValue, nMinIndex)<br/>        | otherwise = if right &lt; average <br/>          then minimumHeightIndexValue values nLeftChild originalInterval<br/>          else if left &gt;= average<br/>            then minimumHeightIndexValue values nRightChild originalInterval<br/>            else minTuple leftResult rightResult<br/>          where<br/>            average = (nFromIndex + nToIndex) `quot` 2<br/>            leftResult = minimumHeightIndexValue values nLeftChild<br/>              (FenceInterval (FenceIndex left, FenceIndex average))<br/>            rightResult = minimumHeightIndexValue values nRightChild<br/>              (FenceInterval (FenceIndex average, FenceIndex right))<br/>          minTuple :: (FenceIndex, Int) -&gt; (FenceIndex, Int) -&gt; (FenceIndex, Int)<br/>          minTuple old@(_, heightOld) new@(_, heightNew) =<br/>            if heightNew &lt; heightOld then new else old</span></pre><h1 id="fd6b" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">润色其余部分</h1><p id="14e5" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">一旦我们完成了这个，剩下的就很简单了。首先，我们将在开始时构建分段树，并将其作为参数传递给我们的函数。然后我们将插入新的最小值函数来代替旧的函数。我们将确保把树添加到每个递归调用中。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="ce70" class="lf jr hu kw b fv lg lh l li lj">largestRectangle :: FenceValues -&gt; FenceSolution<br/>largestRectangle values = largestRectangleAtIndices values <br/>  (buildSegmentTree (unFenceValues values)<br/>  (FenceInterval (FenceIndex 0, FenceIndex (length (unFenceValues values))))</span><span id="d4f2" class="lf jr hu kw b fv lk lh l li lj">…<br/>-- Notice the extra parameter<br/>largestRectangleAtIndices :: FenceValues -&gt; SegmentTreeNode -&gt; FenceInterval -&gt; FenceSolution<br/>largestRectangleAtIndices<br/>  values<br/>  tree<br/>…<br/>      where<br/>      …<br/>      -- And down here add it to each call<br/>      (minIndex, minValue) = minimumHeightIndexValue values tree interval<br/>      leftCase = largestRectangleAtIndices values tree (FenceInterval (leftIndex, minIndex))<br/>      rightCase = if minIndex + 1 == rightIndex<br/>        then FenceSolution (maxBound :: Int)<br/>        else largestRectangleAtIndices values tree (FenceInterval (minIndex + 1, rightIndex))</span></pre><p id="3da2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们可以再次运行我们的基准了。这一次，我们将看到我们的代码在这两种大型情况下都运行得更快了！成功！</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="ae63" class="lf jr hu kw b fv lg lh l li lj">benchmarking fences tests/Size 100000 Test<br/>time                 179.1 ms   (173.5 ms .. 185.9 ms)<br/>                     0.999 R²   (0.998 R² .. 1.000 R²)<br/>mean                 184.1 ms   (182.7 ms .. 186.1 ms)<br/>std dev              2.218 ms   (1.197 ms .. 3.342 ms)<br/>variance introduced by outliers: 14% (moderately inflated)</span><span id="94a0" class="lf jr hu kw b fv lk lh l li lj">benchmarking fences tests/Size 100000 Test (sorted)<br/>time                 238.4 ms   (227.2 ms .. 265.1 ms)<br/>                     0.998 R²   (0.989 R² .. 1.000 R²)<br/>mean                 243.5 ms   (237.0 ms .. 251.8 ms)<br/>std dev              8.691 ms   (2.681 ms .. 11.83 ms)<br/>variance introduced by outliers: 16% (moderately inflated)</span></pre><h1 id="bada" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">结论</h1><p id="aeaa" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">所以在过去的两篇文章中，我们学到了很多。我们首先介绍了如何使用Cabal/Stack为我们的代码创建基准。当我们运行这些基准测试时，我们发现结果花费的时间比我们希望的要长。然后，我们使用概要分析来确定有问题的函数是什么。然后我们一头扎进一些数据结构知识。我们亲眼目睹了改变程序的底层数据结构如何提高我们的性能。我们还学习了数组，这在Haskell中被忽略了。然后，我们从头开始构建了一个细分树，并使用它的API来实现我们程序的改进。</p><p id="59ad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在下周的<a class="ae jp" href="https://www.mmhaskell.com/blog" rel="noopener ugc nofollow" target="_blank">周一早间Haskell博客</a>上，我们将通过学习图形来继续探索数据结构！我们将看看函数图形库，看看它如何使解决某些问题变得容易！</p><p id="b108" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个问题涉及到递归的许多不同用法。如果你想成为一名更好的函数式程序员，你最好学习递归。如果你想更好地掌握这个基本概念，你应该看看我们免费的<a class="ae jp" href="https://www.mmhaskell.com/workbook" rel="noopener ugc nofollow" target="_blank">递归练习册</a>。它有两章有用的信息以及10个练习题！</p><p id="8dac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您以前从未编写过Haskell，但对本文中看到的可能性很感兴趣，那么您应该尝试一下！下载我们的<a class="ae jp" href="https://www.mmhaskell.com/checklist" rel="noopener ugc nofollow" target="_blank">入门清单</a>！它将引导您完成语言的安装。它还会为您提供一些开始Haskell教育的很酷的资源。</p><p id="c113" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，请务必查看我们的<a class="ae jp" href="http://academy.mondaymorninghaskell/p/your-first-haskell-project" rel="noopener ugc nofollow" target="_blank">堆栈迷你课程</a>。一旦你掌握了Stack工具，你就可以像专业人士一样制作Haskell项目了！</p><blockquote class="lx ly lz"><p id="bce5" class="ir is ma it b iu iv iw ix iy iz ja jb mb jd je jf mc jh ji jj md jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is ma it b iu iv iw ix iy iz ja jb mb jd je jf mc jh ji jj md jl jm jn jo hn dt translated">要了解更多信息，<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">请阅读我们的“关于”页面</a> , <a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">喜欢/在脸书给我们发消息</a>，或者简单地，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank">发推文/DM @HackerNoon。</a></p><p id="708a" class="ir is ma it b iu iv iw ix iy iz ja jb mb jd je jf mc jh ji jj md jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>