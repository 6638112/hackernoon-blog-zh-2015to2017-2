<html>
<head>
<title>REST is just not for RPC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">REST不适合RPC</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/rest-is-just-not-for-rpc-d5d9507ff99a?source=collection_archive---------20-----------------------#2017-12-19">https://medium.com/hackernoon/rest-is-just-not-for-rpc-d5d9507ff99a?source=collection_archive---------20-----------------------#2017-12-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="53ea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我认为RPC协议和<a class="ae jp" href="https://hackernoon.com/tagged/rest" rel="noopener ugc nofollow" target="_blank"> REST </a>协议生活在非常不同的抽象层次上，不应该像替代品一样进行比较。这可能是我对当前REST批评浪潮的主要问题。如果我们只是接受没有人会乐意通过REST，一个为资源同步而设计的特定领域的API，来强制一种RPC类型的<a class="ae jp" href="https://hackernoon.com/tagged/api" rel="noopener ugc nofollow" target="_blank"> API </a>，讨论可能会更有成效。</p><p id="5ac1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于编程语言使用函数，而RPC是通过某种网络使用这些函数的一种方式，当然RPC APIs是实现这一点的最通用和透明的方式。我们现在有令人惊叹的技术，如gRPC、websockets、Cap'nProto、ProtocolBuffers、MessagePack等，HTTP可能是传统支持的一个很好的后备传输层，但原则上这些不需要HTTP层的任何东西，但通过纯websockets或纯UDP/TCP会好得多。</p><p id="0b7f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最好是看看两个极端，然后看看现实世界的混合用例如何才能被建模得最好:<br/> -纯RPC API:<br/>一切适合的东西，如消息传递、非常动态和多维查询、请求视图模型、触发事件、远程算法执行、发送突变。这些事情最好使用我上面提到的RPC技术来实现。这些概念通常甚至与“资源”的概念没有联系，所以它会碰到我们读到的所有其他问题。</p><p id="71ba" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">-纯资源API:<br/>任何应该同步或发布资源上一致的状态和状态变化，并需要访问完整资源以保持一致性，同时尽可能抽象实现细节的协议，最好在REST中建模。请注意，与上面的描述相比，这个应用程序是多么的狭窄。尽管如此，这仍然适用于许多系统，只要资源的概念在该系统的逻辑中有意义:<br/>对于REST的逻辑，我发现下面的定义最实用:资源是一个实体，它在理论上可以作为unix文件公开，并且它在某个时间的状态可以通过一个简单的散列函数来验证。这个类比也很有趣，因为它反映了plan9的发展(所有东西实际上都是一个文件/所有东西都应该有一个REST接口)正在转变为一个更真实的linux世界(有许多类似API的文件，但也有d-bus等。/会有许多REST API，但也有许多RPC协议)<br/>注意每个REST API都可以相对容易地用RPC风格的API建模(尽管可能会重新发明weel ),而不是反过来。<br/>当考虑REST apis的实际应用时，还有两个重要的技术需要记住，即使你在现实中使用了完全不同的技术，但是这些技术实现的纯洁性和有真实的资源来检查你的想法的事实是一个极大的帮助:<br/> couchDB和webDAV <br/> —这个API作为webDAV服务器公开在理论上有意义吗？这个api安装在文件浏览器中会有多可笑？与这个api的交互越荒谬，REST就越不可能是你的API的好模型。你发现越多令人讨厌/美好的用例会让这样的界面变得很棒，它就越适合REST。如果你比webDAV更了解couchDB，这是一样的，那么将这个API建模为一个包含文档和文档版本修订的couchdb数据库有多大意义呢？</p><p id="e81c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现实世界的API通常都有这两个方面。关键是找到API自然的主要思想，并识别和解决硬币的另一面作为边缘情况。如果你的API主要是RPC风格的，但是你有更强的需求来操作资源，这就是graphQL的用武之地，这也是为什么我认为graphQL通过web socket最有意义，我不认为它是REST的替代品，而是作为一个工具带来赋予RPC APIs更强的数据需求。如果你的API很大，并且可以被分割成两个领域，那么拥有两个清晰建模的独立API有时是有意义的。这乍一看似乎很奇怪，但如果Web应用程序有REST API，但也使用websockets来实现某些功能，这确实会发生。<br/> -如果你的API主要是一个完美的REST fit，但有一些RPC方面，那么当然仍然可以将RPC建模为REST，但要清楚这些端点是什么，并准备好替换它们，如果你遇到已知的问题，只是有意识地了解这一点已经很有帮助了。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="jv jw l"/></div></figure></div></div>    
</body>
</html>