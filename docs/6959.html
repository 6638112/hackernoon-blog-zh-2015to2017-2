<html>
<head>
<title>Receiving and Parsing Email in Rails 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Rails 5中接收和解析电子邮件</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/receiving-and-parsing-email-in-rails-5-c975c2766364?source=collection_archive---------17-----------------------#2017-10-11">https://medium.com/hackernoon/receiving-and-parsing-email-in-rails-5-c975c2766364?source=collection_archive---------17-----------------------#2017-10-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="5d4d" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">用煎锅和猎枪</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/d5bf3c36d75f4b0622cad8a818793512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qmu6OFx86thnPRrL6pPHbw.png"/></div></div></figure><p id="cbe7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">SaaS应用程序中电子邮件的另一个方面是接收邮件。虽然与发送相比，这种方式不太常见或不常用，但它是让最终用户更快回复电子邮件或行动项目的好方法。</p><p id="de27" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在高层次上，这有几个不同的层次。最顶层是电子邮件服务，这本书的案例是Mailgun。该服务处理发送出站电子邮件，以及将入站电子邮件路由到其接口中指定的地址/域名。电子邮件被路由后，将被重定向到应用程序中的路由和处理器文件。这个文件将负责解析传入的电子邮件地址，并使用逻辑来决定如何处理它。</p></div><div class="ab cl kr ks hc kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hn ho hp hq hr"><p id="26c7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">注意:这篇文章摘自我即将出版的书<a class="ae ky" href="https://buildasaasappinrails.com" rel="noopener ugc nofollow" target="_blank">中的一章，在Rails 6 </a>中构建一个SaaS应用。这本书指导你从卑微的开始，通过部署一个应用到生产。这本书现在已经开始预售了，你可以马上拿到免费的一章！</p><p id="4c05" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">此外，我的新项目<a class="ae ky" href="https://pullmanager.com" rel="noopener ugc nofollow" target="_blank">拉动式管理器</a>的测试版已经发布。如果您失去了对拉取请求的跟踪，让旧的请求留在身边，或者只是喜欢一个通过多个服务(Github、Gitlab和Bitbucket)聚集这些请求的仪表板，<a class="ae ky" href="https://pullmanager.com" rel="noopener ugc nofollow" target="_blank">查看一下</a>。</p></div><div class="ab cl kr ks hc kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hn ho hp hq hr"><p id="6dfb" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在我们正在构建的站立应用程序的情况下，我们可以有回复电子邮件提醒的指示，以根据他们的电子邮件回复创建一个新的站立！我们将使用的一些工具是Mailgun的电子邮件路由服务和ngrok，一种HTTP隧道服务。<code class="eh kz la lb lc b">ngrok</code>对于贯穿本书剩余部分的几个解决方案非常有用。它允许您拥有一个web可访问的URL，该URL通过隧道(连接)连接到本地机器中的端口。这意味着，你将有一个<code class="eh kz la lb lc b">http://somesubdomain.ngrok.com</code>将转发到你的电脑，和一个特定的端口指定当你启动<code class="eh kz la lb lc b">ngrok</code>。这样就可以用Mailgun、Stripe(后来)、Github(后来)等外部服务进行测试了！</p><p id="ea3f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">让我们从一些设置开始:</p><ul class=""><li id="0d96" class="ld le hu jx b jy jz kb kc ke lf ki lg km lh kq li lj lk ll dt translated">下载<a class="ae ky" href="https://ngrok.com/" rel="noopener ugc nofollow" target="_blank"> ngrok </a></li><li id="8e66" class="ld le hu jx b jy lm kb ln ke lo ki lp km lq kq li lj lk ll dt translated">解压并移动可执行文件到你想要的地方。</li><li id="025e" class="ld le hu jx b jy lm kb ln ke lo ki lp km lq kq li lj lk ll dt translated">在*nix OS中，用:<code class="eh kz la lb lc b">path/to/ngrok HTTP start 3000</code>打开ngrok。这取决于Rails服务器使用的端口。ngrok现在将使用随机生成的URL启动隧道服务。</li><li id="72f2" class="ld le hu jx b jy lm kb ln ke lo ki lp km lq kq li lj lk ll dt translated">可选地，如果你升级到<code class="eh kz la lb lc b">ngrok</code>的付费版本，你可以设置一个子域，这样你就不必在每次重启<code class="eh kz la lb lc b">ngrok</code>时都在别处更改你的设置。</li><li id="c71a" class="ld le hu jx b jy lm kb ln ke lo ki lp km lq kq li lj lk ll dt translated">在Mailgun中，转到Routes选项卡，创建将发送电子邮件的电子邮件路由(模仿像Rails这样的MVC路由)。输入以下设置:</li><li id="bd65" class="ld le hu jx b jy lm kb ln ke lo ki lp km lq kq li lj lk ll dt translated">选择了<code class="eh kz la lb lc b">Match Recipient</code></li><li id="1e8c" class="ld le hu jx b jy lm kb ln ke lo ki lp km lq kq li lj lk ll dt translated">在收件人字段输入<code class="eh kz la lb lc b">development.standup.*@app.yourdomain.com</code>。Mailgun路由允许通配符匹配，这将允许您在电子邮件的<code class="eh kz la lb lc b">reply-to</code>中输入额外的字符。也就是说，添加类似用户的<code class="eh kz la lb lc b">hash_id</code>的东西，以便从收到的电子邮件中获得可识别的信息。</li><li id="b962" class="ld le hu jx b jy lm kb ln ke lo ki lp km lq kq li lj lk ll dt translated">勾选<code class="eh kz la lb lc b">forward</code>并输入<code class="eh kz la lb lc b">http://yoursubdomain.ngrok.io/email_processor</code>作为该转发的目的地。</li><li id="9d41" class="ld le hu jx b jy lm kb ln ke lo ki lp km lq kq li lj lk ll dt translated">在按下<code class="eh kz la lb lc b">submit</code>按钮之前，您可以保留优先级并给路线命名。</li></ul><p id="7c5f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">至此，我们可以开始修改应用程序了。应用程序更改将包括三个主要部分。首先，将添加一个新的gem(和一个配套的适配器gem)。<code class="eh kz la lb lc b">griddler</code>是轻松处理来信的主库；<code class="eh kz la lb lc b">griddler-mailgun</code>是专用于Mailgun的适配器，它允许<code class="eh kz la lb lc b">griddler</code>功能与Mailgun一起用作接收邮件路由器。接下来，Griddler需要在应用程序范围内添加一些配置，以确保满足一些基本配置。最后，将添加一个电子邮件处理器文件来处理电子邮件的接收和解析。</p><p id="6e6c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">将Griddler添加到您当前的应用程序中最重要的一点是，如果您正在使用第3章中的Gemfile，那么您已经安装了它。如果没有，只需将<code class="eh kz la lb lc b">gem 'griddler'</code>和<code class="eh kz la lb lc b">gem 'griddler-mailgun'</code>添加到您的gem文件中，并运行一个<code class="eh kz la lb lc b">bundle install</code>。</p><p id="1aa9" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">接下来，在应用程序中配置和设置Griddler，您需要在初始化文件夹中添加一个新文件，设置一些配置值。然后，添加一个快捷行，将默认的Griddler路由添加到<code class="eh kz la lb lc b">routes.rb</code>文件中。</p><p id="f6cd" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">首先是煎锅配置:</p><pre class="jk jl jm jn fq lr lc ls lt aw lu dt"><span id="2804" class="lv lw hu lc b fv lx ly l lz ma">Griddler.configure do |config|<br/>  config.reply_delimiter = '-- REPLY ABOVE THIS LINE --'<br/>  config.email_service = :mailgun<br/>end</span></pre><p id="acea" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这将设置griddler库将在电子邮件中查找的文本，并告诉它将使用已安装的Mailgun适配器。</p><p id="0965" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">接下来，添加一行代码，将基于库的路线安装到您的应用程序中。在<code class="eh kz la lb lc b">root to:</code>上方增加一条线就可以了:</p><pre class="jk jl jm jn fq lr lc ls lt aw lu dt"><span id="f6b3" class="lv lw hu lc b fv lx ly l lz ma">Rails.application.routes.draw do<br/>  ...</span><span id="f39f" class="lv lw hu lc b fv mb ly l lz ma">  # mount using default path: /email_processor<br/>  mount_griddler</span><span id="1aba" class="lv lw hu lc b fv mb ly l lz ma">  root to: 'activity#mine'<br/>end</span></pre><p id="7293" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">通过使用该语法安装Griddler，它将自动向您的应用程序添加一个路由，该路由将从指定的端点路由到基于Griddler的控制器:</p><pre class="jk jl jm jn fq lr lc ls lt aw lu dt"><span id="308c" class="lv lw hu lc b fv lx ly l lz ma">email_processor POST /email_processor(.:format)      </span><span id="3b0b" class="lv lw hu lc b fv mb ly l lz ma">griddler/emails#create</span></pre><p id="a029" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Griddler的GitHub文档中有更改默认设置的设置，但除非您想在路由路径或电子邮件处理器类名方面有所创新，否则这可能是不必要的。</p><p id="cedc" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">默认设置期望类<code class="eh kz la lb lc b">EmailProcessor</code>存在，并使用方法<code class="eh kz la lb lc b">process</code>处理传入电子邮件的解析。然而，Griddler并不关心实际的文件放在哪里，而是关心类是否存在并被加载。就我个人而言，我发现电子邮件处理最符合服务的定义，可以放在那里。</p><p id="e07d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">为了允许Griddler及其文件从收到的回复中获取文本，需要做一些改动。</p><p id="d34d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">首先，我们将更新<code class="eh kz la lb lc b">EmailReminderMailer</code>以创建一个唯一的回复地址，并将该电子邮件地址作为外发电子邮件的一部分:</p><pre class="jk jl jm jn fq lr lc ls lt aw lu dt"><span id="4cc7" class="lv lw hu lc b fv lx ly l lz ma">class EmailReminderMailer &lt; ApplicationMailer<br/>  def reminder_email(user, team)<br/>    <a class="ae ky" href="http://twitter.com/user" rel="noopener ugc nofollow" target="_blank">@user</a> = user<br/>    <a class="ae ky" href="http://twitter.com/team" rel="noopener ugc nofollow" target="_blank">@team</a> = team<br/>    reply_to = "'Standup App' &lt;#{'development.' if Rails.env.development?}standup.#{<a class="ae ky" href="mailto:user.hash_id}&lt;a href=" rel="noopener ugc nofollow" target="_blank">@app</a>.yourdomain.com"&gt;user.hash_id}<a class="ae ky" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.yourdomain.com&gt;"<br/>    mail(<br/>      to: <a class="ae ky" href="http://twitter.com/user" rel="noopener ugc nofollow" target="_blank">@user</a>.email,<br/>      subject: "#{team.name} Standup Reminder!",<br/>      reply_to: reply_to<br/>    )<br/>  end<br/>end</span></pre><p id="e150" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这里，如果当前的Rails环境是您的本地Rails应用程序，我们将通过添加<code class="eh kz la lb lc b">development</code>来构建<code class="eh kz la lb lc b">reply_to</code>字符串。这样，为开发创建的单独的Mailgun路由可以不同于您将在部署应用程序之前添加的生产路由。</p><p id="0190" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">接下来，我们将更新邮件模板，添加<code class="eh kz la lb lc b">##- Please type your reply above this line -##</code>和一些文本，让邮件收件人知道他们可以通过回复来添加单口相声:</p><pre class="jk jl jm jn fq lr lc ls lt aw lu dt"><span id="6f34" class="lv lw hu lc b fv lx ly l lz ma">## app/views/email_reminder_mailer/reminder_email.html.slim<br/>doctype html<br/>html ae ky" href="http://www.w3.org/1999/xhtml" rel="noopener ugc nofollow" target="_blank"&gt;http://www.w3.org/1999/xhtml"<br/>  head<br/>    meta content="width=device-width" name="viewport" /<br/>    meta content=("text/html; charset=UTF-8") http-equiv="Content-Type" /<br/>    title= "#{<a class="ae ky" href="http://twitter.com/team" rel="noopener ugc nofollow" target="_blank">@team</a>.name} Reminder!"<br/>    css:<br/>      | *{margin:0;padding:0;font-family:"Open Sans",Helvetica,Helvetica,Arial,<br/>      sans-serif;box-sizing:border-box;font-size:14px}img{max-width:100%}body{-<br/>      webkit-font-smoothing:antialiased;-webkit-text-size-adjust:none;width:100<br/>      %!important;height:100%;line-height:1.6}table td{vertical-align:top}body{<br/>      background-color:#f6f6f6}.body-wrap{background-color:#f6f6f6;width:100%}.<br/>      container{display:block!important;max-width:800px!important;margin:0<br/>      auto!important;clear:both!important}.content{max-width:800px;margin:0<br/>      auto;display:block;padding:20px}.main{background:#fff;border:1px solid #e<br/>      9e9e9;border-radius:3px}.content-wrap{padding:20px}.content-block{padding<br/>      :0 0 20px}.header{width:100%;margin-bottom:20px}.footer{width:100%;clear:<br/>      both;color:#999;padding:20px}.footer a{color:#999}.footer a,.footer<br/>      p,.footer td,.footer unsubscribe{font-size:12px}h1,h2,h3,a,th,td{font-<br/>      family:"Open Sans",Helvetica,Arial,"Lucida Grande",sans-serif;color:#<br/>      000;margin:40px 0 0;line-height:1.2;font-weight:400}h1{font-size:32px;<br/>      font-weight:500}h2{font-size:24px}h3{font-size:18px}h4{font-size:14px;<br/>      font-weight:600}ol,p,ul{margin-bottom:10px;font-weight:400}ol li,p li,ul<br/>      li{margin-left:5px;list-style-position:inside}a{color:##3c8dbc;text-decor<br/>      ation:underline}.btn-primary{text-decoration:none;color:#<br/>      FFF;background-color:##3c8dbc;border:solid ##3c8dbc;border-width:5px 10px<br/>      ;line-height:2;font-weight:700;text-align:center;cursor:pointer;display:<br/>      inline-block;border-radius:5px;text-transform:capitalize}.last{margin-<br/>      bottom:0}.first{margin-top:0}.aligncenter{text-align:center}.alignright{<br/>      text-align:right}.alignleft{text-align:left}.clear{clear:both}.alert{font<br/>      -size:16px;color:#<br/>      fff;font-weight:500;padding:20px;text-align:center;border-radius:3px 3px<br/>      0 0}.alert a{color:#fff;text-decoration:none;font-weight:500;font-size:16<br/>      px}.alert.alert-warning{background:#f8ac59}.alert.alert-bad{background:#e<br/>      d5565}.alert.alert-good{background:##3c8dbc}.invoice{margin:40px<br/>      auto;text-align:left;width:80%}.invoice td{padding:5px 0}.invoice .<br/>      invoice-items{width:100%}.invoice .invoice-items td{border-top:#eee 1px<br/>      solid}.invoice .invoice-items .total td{border-top:2px solid #<br/>      333;border-bottom:2px solid #333;font-weight:700}<a class="ae ky" href="http://twitter.com/media" rel="noopener ugc nofollow" target="_blank">@media</a> only screen and (<br/>      max-width:640px){h1,h2,h3,h4{font-weight:600!important;margin:20px 0 5px!<br/>      important}h1{font-size:22px!important}h2{font-size:18px!important}h3{font<br/>      -size:16px!important}.container{width:100% !important}<br/>      .content,.content-wrap{padding:10px !important}.invoice{width:10<br/>      0% !important}<br/>  body<br/>    div style="color: #b5b5b5;text-align:center;"<br/>      | ##- Please type your reply above this line -##<br/>    table.body-wrap style="width:100%"<br/>      tr<br/>        td<br/>        td.container width="800"<br/>          .content<br/>            table.main cellpadding="0" cellspacing="0" width="100%"<br/>              tr<br/>                td.content-wrap<br/>                  table cellpadding="0" cellspacing="0" style="width:100%"<br/>                    tr<br/>                      td.aligncenter<br/>                        | Standup App<br/>                    tr<br/>                      td.content-block<br/>                        h3= "#{<a class="ae ky" href="http://twitter.com/team" rel="noopener ugc nofollow" target="_blank">@team</a>.name} Reminder!"<br/>                    tr<br/>                      td.content-block<br/>                        = "Just wanted to remind you to add your standup for \<br/>                        the team: #{<a class="ae ky" href="http://twitter.com/team" rel="noopener ugc nofollow" target="_blank">@team</a>.name}"<br/>                    tr<br/>                      td.content-block.aligncenter<br/>                        = link_to "Add Your Standup", new_standup_url(), \<br/>                        {class:"btn-primary", style: "width:95%"}<br/>                    tr<br/>                      td.content-block<br/>                        = "You can quickly submit your standup by replying to \<br/>                          this email in the format:"<br/>                        pre<br/>                          pre<br/>                          = "[d] This is a done item\n[t] This is a todo item\n\<br/>                          [b] This is a blocker"<br/>            .footer<br/>              table width="100%"<br/>                tr<br/>                  td.aligncenter.content-block<br/>        td</span></pre><p id="add0" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">最后，我们需要在<code class="eh kz la lb lc b">Standups</code>表中添加一个额外的列来跟踪来自Mailgun路由的电子邮件的<code class="eh kz la lb lc b">Message-ID</code>。由于您不能指望电子邮件服务提供“仅一次”递送，我们需要自己在站立台上跟踪这些唯一的id。</p><pre class="jk jl jm jn fq lr lc ls lt aw lu dt"><span id="45a8" class="lv lw hu lc b fv lx ly l lz ma">rails g migration AddMessageIdToStandups message_id</span></pre><p id="eb18" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">接下来，在新创建的迁移<code class="eh kz la lb lc b">change</code>方法结束之前，您将想要添加<code class="eh kz la lb lc b">add_index :standups, :message_id</code>。随着<code class="eh kz la lb lc b">Standups</code>表的增长，这个索引将允许快速查找。最后，迁移实际的变更:</p><pre class="jk jl jm jn fq lr lc ls lt aw lu dt"><span id="1a74" class="lv lw hu lc b fv lx ly l lz ma">bin/rails db:migrate</span></pre><p id="e18c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这些更改完成后，我们现在可以添加新的<code class="eh kz la lb lc b">EmailProcessor</code>类来解析传入的电子邮件:</p><pre class="jk jl jm jn fq lr lc ls lt aw lu dt"><span id="9fe9" class="lv lw hu lc b fv lx ly l lz ma">class EmailProcessor</span><span id="7fcf" class="lv lw hu lc b fv mb ly l lz ma">attr_reader :email</span><span id="e918" class="lv lw hu lc b fv mb ly l lz ma">def initialize(email)<br/>    <a class="ae ky" href="http://twitter.com/email" rel="noopener ugc nofollow" target="_blank">@email</a> = email<br/>  end</span><span id="4458" class="lv lw hu lc b fv mb ly l lz ma">TASK_TYPE_HASH = {<br/>    '[d]' =&gt; 'Did',<br/>    '[t]' =&gt; 'Todo',<br/>    '[b]' =&gt; 'Blocker'<br/>  }</span><span id="07fd" class="lv lw hu lc b fv mb ly l lz ma">def process<br/>    if Rails.env.development?<br/>      Rails.logger.info '-----------EMAIL-------------'<br/>      Rails.logger.info email.to.first[:token]<br/>      Rails.logger.info email.body<br/>      Rails.logger.info email.headers["Message-ID"]<br/>      Rails.logger.info '-----------EMAIL-------------'<br/>    end</span><span id="9c18" class="lv lw hu lc b fv mb ly l lz ma"># Get a user hash_id from reploy-to or bail<br/>    reply_user = email.to.first[:token]&amp;.split('&lt;')&amp;.last&amp;.split('@')&amp;.first&amp;.<br/>    split('.')&amp;.last<br/>    return if reply_user.blank?</span><span id="8cce" class="lv lw hu lc b fv mb ly l lz ma"># Find a user by the hash_id or bail<br/>    user = User.find_by(hash_id: reply_user)<br/>    return if user.nil?</span><span id="6c8f" class="lv lw hu lc b fv mb ly l lz ma"># Bail if standup with incoming message-id exists<br/>    return if Standup.exists?(message_id: email.headers["Message-ID"])</span><span id="b771" class="lv lw hu lc b fv mb ly l lz ma"># Bail if a standup for today exists<br/>    today = Date.today.iso8601<br/>    return if Standup.exists?(standup_date: today)</span><span id="bfd3" class="lv lw hu lc b fv mb ly l lz ma"># Get content or bail<br/>    tasks_from_body = email.body.scan(/(\[[dtb]{1}\].*)$/)<br/>    return if tasks_from_body.blank? || tasks_from_body.empty?</span><span id="d87f" class="lv lw hu lc b fv mb ly l lz ma">build_and_create_standup(<br/>      user: user,<br/>      tasks: tasks_from_body,<br/>      date: today,<br/>      message_id: email.headers["Message-ID"]<br/>    )<br/>  end</span><span id="5969" class="lv lw hu lc b fv mb ly l lz ma">private</span><span id="7fce" class="lv lw hu lc b fv mb ly l lz ma">def build_and_create_standup(user:, tasks:, date:, message_id:)<br/>    standup = Standup.new(<br/>      user_id: user.id,<br/>      standup_date: date,<br/>      message_id: message_id<br/>    )</span><span id="a916" class="lv lw hu lc b fv mb ly l lz ma">tasks.each do |task|<br/>      task_type, task_body = task.first.scan(/(\[[dtb]\])(.*)$/).flatten<br/>      standup.tasks &lt;&lt; Task.new(type: TASK_TYPE_HASH[task_type], title: task_body)<br/>    end</span><span id="5506" class="lv lw hu lc b fv mb ly l lz ma">standup.save<br/>  end<br/>end</span></pre><p id="9efa" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这个课程相对简单，但是让我们一节一节地复习一下:</p><pre class="jk jl jm jn fq lr lc ls lt aw lu dt"><span id="53c0" class="lv lw hu lc b fv lx ly l lz ma">class EmailProcessor</span><span id="2740" class="lv lw hu lc b fv mb ly l lz ma">attr_reader :email</span><span id="da3b" class="lv lw hu lc b fv mb ly l lz ma">def initialize(email)<br/>    <a class="ae ky" href="http://twitter.com/email" rel="noopener ugc nofollow" target="_blank">@email</a> = email<br/>  end</span><span id="3bdd" class="lv lw hu lc b fv mb ly l lz ma">TASK_TYPE_HASH = {<br/>    '[d]' =&gt; 'Did',<br/>    '[t]' =&gt; 'Todo',<br/>    '[b]' =&gt; 'Blocker'<br/>  }</span><span id="6415" class="lv lw hu lc b fv mb ly l lz ma">...</span></pre><p id="24d4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这里，当Griddler调用该类时，我们正在初始化对象，将email设置为一个本地email变量。此外，我们正在创建一个散列，以便稍后在文本内容到<code class="eh kz la lb lc b">Task</code>类型的转换中使用。</p><pre class="jk jl jm jn fq lr lc ls lt aw lu dt"><span id="9c70" class="lv lw hu lc b fv lx ly l lz ma">...</span><span id="dcde" class="lv lw hu lc b fv mb ly l lz ma">def process<br/>    if Rails.env.development?<br/>      Rails.logger.info '-----------EMAIL-------------'<br/>      Rails.logger.info email.to.first[:token]<br/>      Rails.logger.info email.body<br/>      Rails.logger.info email.headers["Message-ID"]<br/>      Rails.logger.info '-----------EMAIL-------------'<br/>    end</span><span id="9d00" class="lv lw hu lc b fv mb ly l lz ma">...</span></pre><p id="21ba" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果邮件是在本地开发环境中处理的，这只是增加了一些额外的日志记录。</p><pre class="jk jl jm jn fq lr lc ls lt aw lu dt"><span id="826c" class="lv lw hu lc b fv lx ly l lz ma">...</span><span id="9e11" class="lv lw hu lc b fv mb ly l lz ma"># Get a user hash_id from reply-to or bail<br/>    reply_user = email.to.first[:token]&amp;.split('&lt;')&amp;.last&amp;.split('@')&amp;.first&amp;.<br/>    split('.')&amp;.last<br/>    return if reply_user.blank?</span><span id="ae35" class="lv lw hu lc b fv mb ly l lz ma"># Find a user by the hash_id or bail<br/>    user = User.find_by(hash_id: reply_user)<br/>    return if user.nil?</span><span id="c355" class="lv lw hu lc b fv mb ly l lz ma"># Bail if standup with incoming message-id exists<br/>    return if Standup.exists?(message_id: email.headers["Message-ID"])</span><span id="de93" class="lv lw hu lc b fv mb ly l lz ma"># Bail if a standup for today exists<br/>    today = Date.today.iso8601<br/>    return if Standup.exists?(user_id: user.id, standup_date: today)</span><span id="545a" class="lv lw hu lc b fv mb ly l lz ma"># Get content or bail<br/>    safe_body = Rails::Html::WhiteListSanitizer.new.sanitize(email.body)<br/>    tasks_from_body = safe_body.scan(/(\[[dtb]{1}\].*)$/)<br/>    return if tasks_from_body.blank? || tasks_from_body.empty?</span><span id="f3c9" class="lv lw hu lc b fv mb ly l lz ma">...</span></pre><p id="0c4c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在这里，我们获取解析中使用的一些信息，如果收到的电子邮件不足以处理和创建<code class="eh kz la lb lc b">Standup</code>,也给了<code class="eh kz la lb lc b">process</code>方法提前退出的机会。在第一部分中，解析收到的电子邮件地址以找到用户的<code class="eh kz la lb lc b">hash_id</code>。然后，该字符串用于查找用户。如果没有用户，该方法返回时不添加站立。</p><p id="f7ac" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果已经有一个具有当前消息ID的站，下一行将提前退出该方法。同样，这是为了防止电子邮件提供商不保证“只发送一次”的服务。接下来，为当前日期生成一个变量，并确保当前用户和当前时间没有延迟。</p><p id="bc27" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">最后，用正则表达式解析实际的电子邮件内容。正则表达式是一种编程语言，它允许你对一个字符串进行模式匹配，甚至捕获部分模式匹配。这种特殊的模式(你可以在这里得到更全面的语法解释<a class="ae ky" href="https://regex101.com/r/Bg9EIy/2" rel="noopener ugc nofollow" target="_blank"/>)搜索以<code class="eh kz la lb lc b">[d]</code>、<code class="eh kz la lb lc b">[t]</code>或<code class="eh kz la lb lc b">[r]</code>开头的行。如果这些都存在，它会将内容捕获到行尾。内容主体上的<code class="eh kz la lb lc b">.scan</code>方法允许它捕捉上述模式的所有出现。如果扫描的输出为空，则<code class="eh kz la lb lc b">process</code>方法退出。</p><pre class="jk jl jm jn fq lr lc ls lt aw lu dt"><span id="d734" class="lv lw hu lc b fv lx ly l lz ma">build_and_create_standup(<br/>      user: user,<br/>      tasks: tasks_from_body,<br/>      date: today,<br/>      message_id: email.headers["Message-ID"]<br/>    )<br/>  end</span><span id="db58" class="lv lw hu lc b fv mb ly l lz ma">private</span><span id="017f" class="lv lw hu lc b fv mb ly l lz ma">def build_and_create_standup(user:, tasks:, date:, message_id:)<br/>    standup = Standup.new(<br/>      user_id: user.id,<br/>      standup_date: date,<br/>      message_id: message_id<br/>    )</span><span id="9dc7" class="lv lw hu lc b fv mb ly l lz ma">tasks.each do |task|<br/>      task_type, task_body = task.first.scan(/(\[[dtb]\])(.*)$/).flatten<br/>      standup.tasks &lt;&lt; Task.new(type: TASK_TYPE_HASH[task_type], title: task_body)<br/>    end</span><span id="6474" class="lv lw hu lc b fv mb ly l lz ma">standup.save<br/>  end<br/>end</span></pre><p id="80bb" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这里的最后一部分是到目前为止保存到新的<code class="eh kz la lb lc b">Standup</code>中的所有存储信息的顶点。<code class="eh kz la lb lc b">user</code>、<code class="eh kz la lb lc b">tasks_from_body</code>、<code class="eh kz la lb lc b">today</code>和<code class="eh kz la lb lc b">message_id</code>都被传递到一个方法中，该方法将进行实际的保存。<code class="eh kz la lb lc b">build_and_create_standup</code>方法用用户的ID、日期和<code class="eh kz la lb lc b">message_id</code>创建一个新的<code class="eh kz la lb lc b">Standup</code>。一旦创建了对象，tasks字符串就会被迭代以构建带有类型的<code class="eh kz la lb lc b">Task</code>,并被分配为带有<code class="eh kz la lb lc b">&lt;&lt;</code>语法的子对象。最后，带有子对象<code class="eh kz la lb lc b">Tasks</code>的新<code class="eh kz la lb lc b">Standup</code>对象将与<code class="eh kz la lb lc b">standup.save</code>一起保存</p><p id="685f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">最后，如果您回复一封电子邮件(通过Mailgun SMTP而不是letter_opener发送),您可以测试这一切是否正常:</p><pre class="jk jl jm jn fq lr lc ls lt aw lu dt"><span id="bc78" class="lv lw hu lc b fv lx ly l lz ma">[d] Did a thing<br/>[d] And Another<br/>[t] Something to do<br/>[b] Something in the way. Some really long line about something or another</span></pre><p id="4cd1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">测试这个将需要一个新的spec文件，其中有相当多的<code class="eh kz la lb lc b">it</code>块来测试<code class="eh kz la lb lc b">EmailProcessor</code>可能遇到的所有分支。</p><p id="e3cf" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">首先，如果我们创建一个能够快速生成在<code class="eh kz la lb lc b">EmailProcessor</code>的规范中使用的电子邮件的工厂，那将是最好的。这样，电子邮件可以有默认值，然后我们可以使用<code class="eh kz la lb lc b">FactoryGirl</code> <code class="eh kz la lb lc b">.build</code>命令创建一个新的电子邮件对象，当需要测试处理器时，可以使用任何不同的属性。</p><p id="e1e1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">工厂本身非常简单:</p><pre class="jk jl jm jn fq lr lc ls lt aw lu dt"><span id="6abf" class="lv lw hu lc b fv lx ly l lz ma">factory :email, class: OpenStruct do<br/>    # Assumes Griddler.configure.to is :hash (default)<br/>    to [<br/>      {<br/>        full: '<a class="ae ky" href="mailto:to_user@email.com" rel="noopener ugc nofollow" target="_blank">to_user@email.com</a>',<br/>        email: '<a class="ae ky" href="mailto:to_user@email.com" rel="noopener ugc nofollow" target="_blank">to_user@email.com</a>',<br/>        token: 'to_user',<br/>        host: 'email.com',<br/>        name: nil<br/>      }<br/>    ]<br/>    from(<br/>      token: 'from_user',<br/>      host: 'email.com',<br/>      email: '<a class="ae ky" href="mailto:from_email@email.com" rel="noopener ugc nofollow" target="_blank">from_email@email.com</a>',<br/>      full: 'From User &lt;<a class="ae ky" href="mailto:from_user@email.com" rel="noopener ugc nofollow" target="_blank">from_user@email.com</a>&gt;',<br/>      name: 'From User'<br/>    )<br/>    subject 'email subject'<br/>    body '[d] Did a thing\n[t] Doing a thing\n[b] Blocked by a thing'<br/>    headers {'Message-ID &lt;98984d@local.mail&gt;'}<br/>  end<br/>end</span></pre><p id="c0a1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在，有了一个可用的工厂，<code class="eh kz la lb lc b">email_processor_spec</code>将能够根据需要轻松地旋转新的电子邮件对象，并进行特定的更改来测试所有处理器的条件分支。</p><pre class="jk jl jm jn fq lr lc ls lt aw lu dt"><span id="7364" class="lv lw hu lc b fv lx ly l lz ma">require 'rails_helper'</span><span id="ea58" class="lv lw hu lc b fv mb ly l lz ma">describe EmailProcessor do<br/>  subject(:email_processor) { EmailProcessor }<br/>  let(:user) { FactoryGirl.create(:user) }<br/>  let(:email) do<br/>    FactoryGirl.build(:email,<br/>      to: [<br/>        {<br/>          email: "<a class="ae ky" href="mailto:standup.#{user.hash_id}&lt;a href=" rel="noopener ugc nofollow" target="_blank">@app</a>.buildasaasappinrails.com"&gt;standup.#{user.hash_id}<a class="ae ky" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.buildasaasappinrails.com",<br/>          token: "<a class="ae ky" href="mailto:standup.#{user.hash_id}&lt;a href=" rel="noopener ugc nofollow" target="_blank">@app</a>.buildasaasappinrails.com"&gt;standup.#{user.hash_id}<a class="ae ky" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.buildasaasappinrails.com"<br/>        }<br/>      ]<br/>    )<br/>  end</span><span id="e4d0" class="lv lw hu lc b fv mb ly l lz ma">describe 'processes incoming email' do</span><span id="4a10" class="lv lw hu lc b fv mb ly l lz ma">it 'works as intended' do<br/>      expect { email_processor.new(email).process }<br/>        .to change(Standup, :count).by(1)<br/>    end</span><span id="b85c" class="lv lw hu lc b fv mb ly l lz ma">it 'fails on bad to' do<br/>      bad_to = FactoryGirl.build(<br/>        :email,<br/>        to: [{ token: nil, email: '<a class="ae ky" href="mailto:standup@app.buildasaasappinrails.com" rel="noopener ugc nofollow" target="_blank">standup@app.buildasaasappinrails.com</a>' }]<br/>      )<br/>      expect { email_processor.new(bad_to).process }<br/>        .to change(Standup, :count).by(0)<br/>    end</span><span id="9b8f" class="lv lw hu lc b fv mb ly l lz ma">it 'fails on no user' do<br/>      bad_to = FactoryGirl.build(<br/>        :email,<br/>        to: [<br/>          {<br/>            token: '<a class="ae ky" href="mailto:standup.o8yhiukj@app.buildasaasappinrails.com" rel="noopener ugc nofollow" target="_blank">standup.o8yhiukj@app.buildasaasappinrails.com</a>',<br/>            email: '<a class="ae ky" href="mailto:standup.o8yhiukj@app.buildasaasappinrails.com" rel="noopener ugc nofollow" target="_blank">standup.o8yhiukj@app.buildasaasappinrails.com</a>'<br/>          }<br/>        ]<br/>      )<br/>      expect { email_processor.new(bad_to).process }<br/>        .to change(Standup, :count).by(0)<br/>    end</span><span id="d0ad" class="lv lw hu lc b fv mb ly l lz ma">it 'only saves one per message-id' do<br/>      expect do<br/>        email_processor.new(email).process<br/>        email_processor.new(email).process<br/>      end.to change(Standup, :count).by(1)<br/>    end</span><span id="aba4" class="lv lw hu lc b fv mb ly l lz ma">it 'only saves one per date' do<br/>      email2 = FactoryGirl.build(:email, headers: { 'message-id': '123' })<br/>      expect do<br/>        email_processor.new(email).process<br/>        email_processor.new(email2).process<br/>      end.to change(Standup, :count).by(1)<br/>    end</span><span id="963e" class="lv lw hu lc b fv mb ly l lz ma">it 'fails on empty or bad body' do<br/>      email = FactoryGirl.build(:email, body: '90ioqwhdk.qhdu')<br/>      email2 = FactoryGirl.build(:email, body: '')<br/>      expect do<br/>        email_processor.new(email).process<br/>        email_processor.new(email2).process<br/>      end.to change(Standup, :count).by(0)<br/>    end<br/>  end<br/>end</span></pre><p id="bfaf" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">虽然很长并且包含六个例子，但是这个规范实际上非常简单。它首先测试一切都已设置好并正常工作的幸福之路。然后按照这些路径出现在<code class="eh kz la lb lc b">EmailProcessor</code>的<code class="eh kz la lb lc b">.process</code>方法中的顺序，测试每一条没有创建站立的失败路径。</p><p id="5f6a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">整个rspec套件的快速运行应该显示没有失败的测试和近乎完美的测试/代码覆盖:</p><pre class="jk jl jm jn fq lr lc ls lt aw lu dt"><span id="1ac6" class="lv lw hu lc b fv lx ly l lz ma">rspec spec ........................................................................................................................................................</span><span id="ca0e" class="lv lw hu lc b fv mb ly l lz ma">Finished in 25.78 seconds (files took 10.16 seconds to load) 152 examples, 0 failures Coverage report generated for RSpec to standup_app/coverage. 428 / 431 LOC (99.3%) covered.</span></pre></div></div>    
</body>
</html>