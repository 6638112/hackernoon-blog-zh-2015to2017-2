<html>
<head>
<title>Solving Mastermind with Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用围棋解决智多星</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/solving-mastermind-with-go-a930004c22a0?source=collection_archive---------10-----------------------#2017-10-05">https://medium.com/hackernoon/solving-mastermind-with-go-a930004c22a0?source=collection_archive---------10-----------------------#2017-10-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="43d1" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">设计网页和提高围棋水平</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff jj"><img src="../Images/1992985a7c69ae6f2c8a8c6daafc6b6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:418/format:webp/1*p8KgIGG7Q0yLr4gydVyfDg.png"/></div></figure><p id="0019" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我最近发现了<a class="ae kn" href="https://github.com/gopherjs/gopherjs" rel="noopener ugc nofollow" target="_blank"> gopherjs </a>包，这是一个将Go转换成JavaScript的源代码到源代码的编译器。gopherjs为我们这些对web的通用语言JavaScript心存疑虑的人打开了另一条web开发的途径。出于对用熟悉的语言创建网页的可能性的好奇，我开始编写棋盘游戏<strong class="jt hv"> pure Go </strong>中的<a class="ae kn" href="https://en.wikipedia.org/wiki/Mastermind_(board_game)" rel="noopener ugc nofollow" target="_blank">主谋</a>的程序。结果如左图所示，可在线玩<a class="ae kn" href="https://ludi317.github.io/" rel="noopener ugc nofollow" target="_blank"/>。如果一个逻辑谜题听起来工作量太大，只需按下“5步或更少”按钮，让电脑来玩。</p><p id="4b64" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">摄魂师的目标是破解一个隐藏的代码，这是一个颜色序列。玩家用她对密码的猜测填写一行，并在该行的右边接收到黑白“钉”形式的<strong class="jt hv">反馈</strong>。黑色的钉子表示正确的颜色，正确的位置，白色的钉子表示正确的颜色，错误的位置。错误的颜色不会被扣分。利用她以前所有行动的反馈，玩家试图推断出解决方案。她要么赢了，得到四个黑色的钉子，要么输了，用完了棋盘上的行。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff ko"><img src="../Images/9ea501f1c1afb49e3b78ef80a6d590a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/format:webp/1*8ROz7OXcLIXFa53qcWWRkA.png"/></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">Win</figcaption></figure><p id="945f" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">在Go中编写前端需要呈现嵌套的<code class="eh kt ku kv kw b">*html.Node</code>结构，而不是在HTML中显式拼写标签。仅仅安排元素<em class="kx">和设置挑剔的样式属性是很麻烦的，但是随着实践，这变得不那么痛苦了。因为游戏显示在浏览器中，所以我可以通过检查颜色和数量来轻松检查程序是否正常工作。</em></p></div><div class="ab cl ky kz hc la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hn ho hp hq hr"><p id="5750" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">1976年，计算机科学家Donald Knuth发表了一篇论文<a class="ae kn" href="http://www.cs.uni.edu/~wallingf/teaching/cs3530/resources/knuth-mastermind.pdf" rel="noopener ugc nofollow" target="_blank"/>,其中的算法可以在五步或更少的步数内找到答案。该算法通过播放给出最多信息的代码来工作，其中信息被定义为解空间缩小了多少。</p><p id="4154" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">在每一轮中，它会针对它可以播放的每一个代码，扫描它可以接收到的每一个反馈，并计算剩余的可能解决方案的数量(如果针对该代码给出了反馈的话)。在所有反馈中最小化剩余可能性的最大数量的代码是播放的代码。打破平局的方法是优先选择本身是可能解的代码，然后是数字顺序。</p><p id="c580" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">有趣的是，该算法主要关注的是修剪可能的解决方案的代码集。它播放的代码可能是解决方案是一个次要问题，为了获得更多信息，它甚至播放不在解决方案空间中的代码。这是一个不同于我和其他人使用的策略，那就是把猜测限制在解空间。</p></div><div class="ab cl ky kz hc la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hn ho hp hq hr"><p id="3d9d" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我<a class="ae kn" href="https://github.com/ludi317/ludi317.github.io" rel="noopener ugc nofollow" target="_blank">在Go中编写了</a> Knuth的算法并编译了它，但是JavaScript太慢了，无法即时找到算法的下一步。我的解决方法是预先计算每个解决方案的移动顺序，并将它们存储在一个<a class="ae kn" href="https://en.wikipedia.org/wiki/Trie" rel="noopener ugc nofollow" target="_blank"> <strong class="jt hv"> trie </strong> </a>中。如图所示，trie根据反馈给出算法的下一步棋。它有一个共同的根和6⁴ = 1296叶(6种颜色和4列)。它的最大深度是五，验证了Knuth的五步棋解决游戏的说法。trie构建在Go中并编译成JavaScript，点击solve按钮就可以遍历它。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff lf"><img src="../Images/02ee584ea537518aafafd2a2fcbf78ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*-DmIyrHKBwVRaH0dgOT0_Q.png"/></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">Partial trie of codes played by Knuth algorithm</figcaption></figure><p id="de33" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">创建trie是计算密集型和CPU受限的。根据我的计算，时间复杂度是O(c⁶r^(3c+1，其中c是列数，r是颜色数。我在4核MacBook Pro上的初始实现花了45分钟，因此我应用了以下优化:</p><ul class=""><li id="0fd6" class="lg lh hu jt b ju jv jx jy ka li ke lj ki lk km ll lm ln lo dt translated">并发</li><li id="5bc2" class="lg lh hu jt b ju lp jx lq ka lr ke ls ki lt km ll lm ln lo dt translated">记忆化。我通过在构建trie时读取它来记忆trie生成器函数，有效地将它用作缓存。</li><li id="edd7" class="lg lh hu jt b ju lp jx lq ka lr ke ls ki lt km ll lm ln lo dt translated">跟踪无效解决方案的代码</li><li id="7c97" class="lg lh hu jt b ju lp jx lq ka lr ke ls ki lt km ll lm ln lo dt translated">打乱构建分支的顺序，以增加记忆步骤的“高速缓存”命中率</li><li id="9367" class="lg lh hu jt b ju lp jx lq ka lr ke ls ki lt km ll lm ln lo dt translated">重新排列循环以更有效地计算可能的解决方案</li></ul><p id="c44a" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">这些优化的累积效应在两秒钟内生成了trie，性能比初始实现提升了<strong class="jt hv">1350倍</strong>。令人欣慰的是，看到程序的输出闪电般地出现在屏幕上，一片模糊的绿色文本，矩阵风格。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="fe ff lu"><img src="../Images/522b7ffc04a47a60f733d923eb8b5809.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7-8b1zT-lLx1hyT8i0nzdg.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">Time taken to build the complete trie of moves made by the Knuth algorithm</figcaption></figure><p id="7471" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">一路走来，我找到了几种普遍适用的加速Go1.9代码的方法。一如既往，您的里程可能会有所不同。</p><ul class=""><li id="3a63" class="lg lh hu jt b ju jv jx jy ka li ke lj ki lk km ll lm ln lo dt translated">使用常量<code class="eh kt ku kv kw b">const</code>而不是变量<code class="eh kt ku kv kw b">var</code>。当我将<code class="eh kt ku kv kw b">numColors</code>和<code class="eh kt ku kv kw b">numCols</code>从常量改为变量时，计算时间增加了一倍。我很快就把它们换了回来。</li><li id="89ea" class="lg lh hu jt b ju lp jx lq ka lr ke ls ki lt km ll lm ln lo dt translated">让对象的默认值/零值成为有效的初始值。不要像<code class="eh kt ku kv kw b">up</code>那样在使用前将布尔值设置为真，而是将其更改为<code class="eh kt ku kv kw b">down</code>，这样它的值false就已经是正确的了，而无需进行设置。</li><li id="16f0" class="lg lh hu jt b ju lp jx lq ka lr ke ls ki lt km ll lm ln lo dt translated">在剥离受CPU限制的goroutines时，一个很好的启发是将它们的数量限制在可用的逻辑CPU的数量之内。</li></ul><p id="01ab" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">当然，所有这些优化对于传统版本的摄魂师来说都是多余的，它有四列和六种颜色。然而，它们对于生成具有更多颜色和列的游戏变体是必不可少的。下面的热图显示了解决此类变量需要多少步。随着复杂性的增加，我转向48-和64-CPU的机器，但是即使在拿出大枪之后，超过一定数量的颜色和列的计算也是不可行的。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="fe ff lz"><img src="../Images/3e4ca83e880fd3809a4cb5b4edd43925.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*owOwcv062dldFsna5kDyZg.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">Number of moves needed to win variants of Mastermind with Knuth’s algorithm. * Traditional game.</figcaption></figure><p id="9ad0" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">令人惊讶的是，移动的次数并不随颜色的数量而单调变化。例如，在五列时，三种颜色的游戏可以比两种颜色的游戏用更少的棋来解决。事实证明，Knuth的算法是次优的，因为它是一个贪婪的算法，只向前看一步，以减少解决方案的空间。此后，研究人员提出了平均用更少的步数就能找到答案的算法。</p><p id="6c43" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated"><em class="kx">感谢Mario Latendresse对算法的讨论和</em> <a class="ae kn" href="http://www.web-games-online.com/mastermind/" rel="noopener ugc nofollow" target="_blank"> <em class="kx">网页游戏</em> </a> <em class="kx">对彩色gif的讨论。</em></p></div></div>    
</body>
</html>