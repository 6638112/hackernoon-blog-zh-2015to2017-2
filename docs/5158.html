<html>
<head>
<title>Redux Patterns: Caching an API Response</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redux模式:缓存API响应</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/redux-patterns-caching-an-api-response-f85f8d8d73c6?source=collection_archive---------3-----------------------#2017-07-13">https://medium.com/hackernoon/redux-patterns-caching-an-api-response-f85f8d8d73c6?source=collection_archive---------3-----------------------#2017-07-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="5334" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">避免重复调用稳定的数据</h2></div><p id="c39d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我目前正在尝试将<a class="ae kf" href="https://www.contentful.com/" rel="noopener ugc nofollow" target="_blank"> Contentful </a>作为一项服务来提供可以编辑和更新的数据，而不会引发一个全新的测试/部署周期。因为我将Redux存储联合到本地存储，所以我试图找出一种模式，在这种模式下，我不会每隔[x]多次重新请求该数据，其中[x]可以是从毫秒到天的任何时间限制。</p><p id="2e88" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">出于这个例子的目的，我使用<a class="ae kf" href="https://github.com/gaearon/redux-thunk" rel="noopener ugc nofollow" target="_blank"> Redux-Thunk </a>来允许我做异步动作。</p></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><h1 id="27d4" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ja ky jb kz jd la je lb jg lc jh ld le dt translated">行动</h1><p id="78c5" class="pw-post-body-paragraph jj jk hu jl b jm lf iv jo jp lg iy jr js lh ju jv jw li jy jz ka lj kc kd ke hn dt translated">第一部分是我的reducer中允许的动作。</p><ul class=""><li id="8d51" class="lk ll hu jl b jm jn jp jq js lm jw ln ka lo ke lp lq lr ls dt translated"><strong class="jl hv">中止</strong>:如果缓存是“新”的，我们将运行的动作</li><li id="23d5" class="lk ll hu jl b jm lt jp lu js lv jw lw ka lx ke lp lq lr ls dt translated"><strong class="jl hv">错误</strong>:存储错误以备不时之需(这个动作可以是连接外部日志的钩子)</li><li id="b2b6" class="lk ll hu jl b jm lt jp lu js lv jw lw ka lx ke lp lq lr ls dt translated"><strong class="jl hv"> Start </strong>:将<code class="eh ly lz ma mb b">isFetching</code>设置为<code class="eh ly lz ma mb b">true</code>，用于异步进程的任何类型的用户通知。</li><li id="2a01" class="lk ll hu jl b jm lt jp lu js lv jw lw ka lx ke lp lq lr ls dt translated"><strong class="jl hv">更新</strong>:将返回的数据设置为值。</li></ul><figure class="mc md me mf fq mg"><div class="bz el l di"><div class="mh mi l"/></div></figure></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><h1 id="95ce" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ja ky jb kz jd la je lb jg lc jh ld le dt translated">同步动作创建者</h1><p id="d5a6" class="pw-post-body-paragraph jj jk hu jl b jm lf iv jo jp lg iy jr js lh ju jv jw li jy jz ka lj kc kd ke hn dt translated">动作创建者是将在异步动作的生命周期中被分派的函数。</p><figure class="mc md me mf fq mg"><div class="bz el l di"><div class="mh mi l"/></div></figure></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><h1 id="39a3" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ja ky jb kz jd la je lb jg lc jh ld le dt translated">异步操作创建者</h1><p id="7711" class="pw-post-body-paragraph jj jk hu jl b jm lf iv jo jp lg iy jr js lh ju jv jw li jy jz ka lj kc kd ke hn dt translated">这个函数将被导出到一个组件，并从一个生命周期挂钩中调用，无论何时需要启动获取。内部动作将在异步调用的生命周期中按顺序分派。</p><figure class="mc md me mf fq mg"><div class="bz el l di"><div class="mh mi l"/></div></figure></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><h1 id="381b" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ja ky jb kz jd la je lb jg lc jh ld le dt translated">减速器和初始状态</h1><p id="cbf6" class="pw-post-body-paragraph jj jk hu jl b jm lf iv jo jp lg iy jr js lh ju jv jw li jy jz ka lj kc kd ke hn dt translated">reducer处理异步函数生命周期中调度的所有同步动作，以及设置<code class="eh ly lz ma mb b">isFetching</code>和<code class="eh ly lz ma mb b">lastFetched</code>值。您可以很容易地将这一点逻辑转移到动作创建者，并避免在您的reducer(纯函数)中产生任何副作用。</p><figure class="mc md me mf fq mg"><div class="bz el l di"><div class="mh mi l"/></div></figure></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><h1 id="0b3f" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ja ky jb kz jd la je lb jg lc jh ld le dt translated">结论</h1><p id="af76" class="pw-post-body-paragraph jj jk hu jl b jm lf iv jo jp lg iy jr js lh ju jv jw li jy jz ka lj kc kd ke hn dt translated">这就是了。假设您正在将Redux存储联合到本地存储，如果您有更好的模式(或者知道一个更好地解决这个问题的库),您可以避免一堆不必要的API请求。</p><p id="ad55" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我知道事实上在要点之间有一两个错别字，但它们不会模糊逻辑。</p></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><h2 id="ce0e" class="mj ko hu bd kp mk ml mm kt mn mo mp kx js mq mr kz jw ms mt lb ka mu mv ld mw dt translated">相关职位</h2><div class="mx my fm fo mz na"><a rel="noopener follow" target="_blank" href="/@justintulk/redux-patterns-rethinking-byid-and-byhash-structures-854e8a0fa32d"><div class="nb ab ej"><div class="nc ab nd cl cj ne"><h2 class="bd hv fv z el nf eo ep ng er et ht dt translated">冗余模式:反思“byId”和“byHash”结构</h2><div class="nh l"><h3 class="bd b fv z el nf eo ep ng er et ek translated">迭代Object.keys()并删除byId</h3></div><div class="ni l"><p class="bd b gc z el nf eo ep ng er et ek translated">medium.com</p></div></div></div></a></div><div class="mx my fm fo mz na"><a rel="noopener follow" target="_blank" href="/@justintulk/redux-patterns-add-edit-remove-objects-in-an-array-6ee70cab2456"><div class="nb ab ej"><div class="nc ab nd cl cj ne"><h2 class="bd hv fv z el nf eo ep ng er et ht dt translated">Redux模式:添加/编辑/删除数组中的对象</h2><div class="nh l"><h3 class="bd b fv z el nf eo ep ng er et ek translated">前几天我写了一篇关于如何在单个React组件中实现Redux风格的存储和缩减器的帖子…</h3></div><div class="ni l"><p class="bd b gc z el nf eo ep ng er et ek translated">medium.com</p></div></div></div></a></div><div class="mx my fm fo mz na"><a rel="noopener follow" target="_blank" href="/@justintulk/implement-redux-as-vanilla-js-in-a-single-react-component-1492e9f06472"><div class="nb ab ej"><div class="nc ab nd cl cj ne"><h2 class="bd hv fv z el nf eo ep ng er et ht dt translated">在单个React组件中将Redux实现为普通JS</h2><div class="nh l"><h3 class="bd b fv z el nf eo ep ng er et ek translated">我目前正在做一个项目，将一些React组件一点一点地修补到现有的ASP.NET版本中…</h3></div><div class="ni l"><p class="bd b gc z el nf eo ep ng er et ek translated">medium.com</p></div></div></div></a></div></div></div>    
</body>
</html>