<html>
<head>
<title>How does Angular2 work? Part 2 — bootstrapModule()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular2是如何工作的？第2部分— bootstrapModule()</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-does-angular2-work-part-2-boostrapmodule-117deef25e62?source=collection_archive---------3-----------------------#2016-09-27">https://medium.com/hackernoon/how-does-angular2-work-part-2-boostrapmodule-117deef25e62?source=collection_archive---------3-----------------------#2016-09-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="beff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您错过了它，请查看本系列的第1部分！</p><p id="026e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://hackernoon.com/tagged/movin" rel="noopener ugc nofollow" target="_blank">继续前进！现在我们开始</a><a class="ae jp" href="https://hackernoon.com/tagged/bootstrapping" rel="noopener ugc nofollow" target="_blank">引导</a>一个应用程序。因为我们关注的是ng cli给出的基本模型，所以我们将看看application_ref.ts中包含的简单引导程序。</p><p id="8f06" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在ApplicationRef_中，bootstrapModule 的<a class="ae jp" href="https://github.com/angular/angular/blob/master/modules/%40angular/core/src/application_ref.ts#L296" rel="noopener ugc nofollow" target="_blank">实现实际上只包含一个对私有方法_bootstrapModuleWithZone的简单调用。如果您错过了我对区域的简要概述，您可以在这里找到它</a><a class="ae jp" rel="noopener" href="/@MertzAlertz/what-the-hell-is-zone-js-and-why-is-it-in-my-angular-2-6ff28bcf943e#.qvkrwa68c"/>，但是我也会在本系列的某个地方做一篇更深入的文章。</p><p id="98c1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，我们注意到现在我们实例化了一个编译器；</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="104f" class="jz ka hu jv b fv kb kc l kd ke">const compilerFactory: CompilerFactory =  <br/>  this.injector.get(CompilerFactory);<br/>const compiler = compilerFactory.createCompiler(        <br/>  Array.isArray(compilerOptions) ? <br/>    compilerOptions : [compilerOptions]<br/>);</span></pre><p id="265c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您还记得第1部分，dynamicBrowserPlatform附带的编译器是<a class="ae jp" href="https://github.com/angular/angular/blob/42a287fabf6b035d51e00cf3006c27fec00f054a/modules/%40angular/compiler/src/compiler.ts#L93" rel="noopener ugc nofollow" target="_blank"> RuntimeCompilerFactory </a>。查看createCompiler方法，代码生成一个注入器，它提供通过工厂的构造函数传入的配置，然后从注入器获取编译器。</p><p id="f77b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">编译器是什么样子的？嗯，虽然COMPILER_PROVIDERS明确地调用了许多编译器，但是<a class="ae jp" href="https://github.com/angular/angular/blob/42a287fabf6b035d51e00cf3006c27fec00f054a/modules/%40angular/compiler/src/compiler.ts#L82" rel="noopener ugc nofollow" target="_blank">这一行</a>指定了我们正在寻找的编译器。这里提供的编译器是<a class="ae jp" href="https://github.com/angular/angular/blob/42a287fabf6b035d51e00cf3006c27fec00f054a/modules/%40angular/compiler/src/runtime_compiler.ts" rel="noopener ugc nofollow" target="_blank"> RuntimeCompiler </a>，它是Angular2框架的一个内部类，可以动态编译模板和组件，以便在应用中使用。RuntimeCompiler是一个子类<a class="ae jp" href="https://github.com/angular/angular/blob/dd03bf12e1c035597d2fab252e393846efca5ea1/modules/%40angular/core/src/linker/compiler.ts#L57" rel="noopener ugc nofollow" target="_blank">编译器</a>。记住RuntimeCompiler，因为我们很快就会回到它。</p><p id="9dc5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">继续浏览<a class="ae jp" href="https://github.com/angular/angular/blob/master/modules/%40angular/core/src/application_ref.ts#L301" rel="noopener ugc nofollow" target="_blank"> _bootstrapModuleWithZone </a>，第三个参数是componentFactoryCallback。调用bootstrapmodulewithszone in _ bootstrapModule的方法是这样调用的；</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="85ae" class="jz ka hu jv b fv kb kc l kd ke">this._bootstrapModuleWithZone(moduleType, compilerOptions, null);</span></pre><p id="4d53" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">换句话说，没有回调。</p><p id="f4cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">相反，该方法返回一个对编译器的调用，<a class="ae jp" href="https://github.com/angular/angular/blob/42a287fabf6b035d51e00cf3006c27fec00f054a/modules/%40angular/compiler/src/runtime_compiler.ts#L55" rel="noopener ugc nofollow" target="_blank"> compileModuleAsync </a>，带有一个moduleType的参数，在我们的例子中是我们的AppModule。没错，我们实际提供的第一段代码已经进入了等式。</p><p id="c2ea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">compileModuleAsync又调用一个私有方法_compileModuleAndComponents，第一个参数是我们的AppModule，第二个参数是一个布尔值，它告诉编译器是否应该异步执行编译。</p><p id="5118" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该方法如下所示，</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="9e1e" class="jz ka hu jv b fv kb kc l kd ke">const componentPromise = this._compileComponents(<br/>  moduleType, <br/>  isSync<br/>);    <br/>const ngModuleFactory = this._compileModule(moduleType);</span><span id="0eae" class="jz ka hu jv b fv kf kc l kd ke">return new SyncAsyncResult(<br/>  ngModuleFactory, <br/>  componentPromise.then(() =&gt; ngModuleFactory)<br/>);</span></pre><p id="dbcc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">深入到<a class="ae jp" href="https://github.com/angular/angular/blob/42a287fabf6b035d51e00cf3006c27fec00f054a/modules/%40angular/compiler/src/runtime_compiler.ts#L132" rel="noopener ugc nofollow" target="_blank"> _compileComponents </a>方法，不是简单声明的第一行是这样的；</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="996a" class="jz ka hu jv b fv kb kc l kd ke">const ngModule = this._metadataResolver.getNgModuleMetadata(mainModule);</span></pre><p id="bbf0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">其中mainModule是ng-cli的样板文件提供的AppModule。</p><p id="919d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">_metadataResolver作为从编译器的构造函数注入的私有属性进入RuntimeCompiler。在<a class="ae jp" href="https://github.com/angular/angular/blob/42a287fabf6b035d51e00cf3006c27fec00f054a/modules/%40angular/compiler/src/metadata_resolver.ts#L27" rel="noopener ugc nofollow" target="_blank"> CompileMetadataResolver </a>中，让我们看看<a class="ae jp" href="https://github.com/angular/angular/blob/42a287fabf6b035d51e00cf3006c27fec00f054a/modules/%40angular/compiler/src/metadata_resolver.ts#L200" rel="noopener ugc nofollow" target="_blank">获取模块元数据</a>会发生什么，以及响应是什么样子的。</p><p id="f3a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先我们解决了eForwardRef，Angular2的开发者很好地给出了一个<a class="ae jp" href="http://plnkr.co/edit/GU72mJrk1fiodChcmiDR?p=preview" rel="noopener ugc nofollow" target="_blank"> plnkr的例子</a>。这种前向引用允许解析不必在CompileMetadataResolver之前内联的类。</p><p id="d60f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接着，代码检查moduleType是否已经编译过，并从缓存中检索它，</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="3488" class="jz ka hu jv b fv kb kc l kd ke">var compileMeta = this._ngModuleCache.get(moduleType);</span></pre><p id="eca7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于这是我们第一次执行代码，我们假设这是未定义的，并继续。然后，代码试图通过另一个注入的私有属性<a class="ae jp" href="https://github.com/angular/angular/blob/42a287fabf6b035d51e00cf3006c27fec00f054a/modules/%40angular/compiler/src/metadata_resolver.ts#L204" rel="noopener ugc nofollow" target="_blank">_ ngmodulesolver</a>解析模块的元数据。</p><p id="aa8a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/angular/angular/blob/42a287fabf6b035d51e00cf3006c27fec00f054a/modules/%40angular/compiler/src/ng_module_resolver.ts" rel="noopener ugc nofollow" target="_blank">ngmodulesolver</a>将我们带到一个实际上相对简单的类，简单到我可以在下面复制它；</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="3b58" class="jz ka hu jv b fv kb kc l kd ke">@Injectable()<br/>export class NgModuleResolver {<br/>  constructor(private _reflector: ReflectorReader = reflector) {}   </span><span id="ba94" class="jz ka hu jv b fv kf kc l kd ke">  resolve(type: Type&lt;any&gt;, throwIfNotFound = true): NgModule {<br/>    const ngModuleMeta: NgModule = <br/>      this._reflector.annotations(type).find(_isNgModuleMetadata);<br/>    if (isPresent(ngModuleMeta)) {<br/>      return ngModuleMeta;<br/>    } else {<br/>      if (throwIfNotFound) {<br/>        throw new Error(`No NgModule metadata found for '${stringify(type)}'.`);<br/>      }<br/>      return null;<br/>    }<br/>  }<br/>}</span></pre><p id="3f12" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，这要求<a class="ae jp" href="https://github.com/angular/angular/blob/42a287fabf6b035d51e00cf3006c27fec00f054a/modules/%40angular/core/src/reflection/reflector.ts#L33" rel="noopener ugc nofollow" target="_blank">反射器</a>提供关于我们模块的特定注释的信息。Reflector实际上是在我们的platform_core_providers中注入和实例化的(从第1部分开始)，reflection capabilities(reflection capabilities，Reflector从中提取)实际上只是这里的默认实现<a class="ae jp" href="https://github.com/angular/angular/blob/42a287fabf6b035d51e00cf3006c27fec00f054a/modules/%40angular/core/src/reflection/reflection_capabilities.ts" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="6fbc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们现在最好奇的是<a class="ae jp" href="https://github.com/angular/angular/blob/42a287fabf6b035d51e00cf3006c27fec00f054a/modules/%40angular/core/src/reflection/reflection_capabilities.ts#L91" rel="noopener ugc nofollow" target="_blank">注解</a>，所以让我们来看看。在看这段代码之前，看一下Paschal Precht关于注释与装饰者的文章可能会有所帮助。因此，我们的AppModule <em class="kg">实际上有一个注释，反射器将寻找。注释或。decorators并返回相关的NgModule注释。</em></p><p id="f842" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">退回到这段代码；</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="b431" class="jz ka hu jv b fv kb kc l kd ke">function _isNgModuleMetadata(obj: any): obj is NgModule {<br/>  return obj instanceof NgModule;<br/>}</span><span id="b838" class="jz ka hu jv b fv kf kc l kd ke">...</span><span id="781d" class="jz ka hu jv b fv kf kc l kd ke">const ngModuleMeta: NgModule = this._reflector.annotations(type).find(_isNgModuleMetadata);</span></pre><p id="6ad6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们发现特定的注释是NgModule的一个实例，对应于</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="8642" class="jz ka hu jv b fv kb kc l kd ke">@NgModule({<br/>  ...<br/>})<br/>export class AppModule {</span><span id="c514" class="jz ka hu jv b fv kf kc l kd ke">}</span></pre><p id="474c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">来自我们自己的代码。NgModule注释的内容现在被分配给<a class="ae jp" href="https://github.com/angular/angular/blob/42a287fabf6b035d51e00cf3006c27fec00f054a/modules/%40angular/compiler/src/ng_module_resolver.ts#L26" rel="noopener ugc nofollow" target="_blank"> ngModuleMeta </a>并从NgModuleResolver返回。</p><p id="364f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们现在回到<a class="ae jp" href="https://github.com/angular/angular/blob/42a287fabf6b035d51e00cf3006c27fec00f054a/modules/%40angular/compiler/src/metadata_resolver.ts#L204" rel="noopener ugc nofollow" target="_blank">这里</a>，成功解析了NgModule注释提供的元信息。我将把它留在这里，因为我认为这篇文章已经写得够长了。当我们深入研究NgModule元数据的解析时，请留意第3部分！</p><blockquote class="kh ki kj"><p id="2b8f" class="ir is kg it b iu iv iw ix iy iz ja jb kk jd je jf kl jh ji jj km jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is kg it b iu iv iw ix iy iz ja jb kk jd je jf kl jh ji jj km jl jm jn jo hn dt translated">要了解更多信息，<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">请阅读我们的“关于”页面</a>，<a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is kg it b iu iv iw ix iy iz ja jb kk jd je jf kl jh ji jj km jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jq jr js jt fq kn"><div class="bz el l di"><div class="ko kp l"/></div></figure></div></div>    
</body>
</html>