<html>
<head>
<title>A Front-End Component Is A Function 🔊</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">前端组件是一个函数🔊</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/this-is-how-to-get-the-best-out-of-front-end-components-52ee29dfb4ae?source=collection_archive---------10-----------------------#2017-10-26">https://medium.com/hackernoon/this-is-how-to-get-the-best-out-of-front-end-components-52ee29dfb4ae?source=collection_archive---------10-----------------------#2017-10-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="91f8" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">我们应用于函数的原理也可以应用于组件</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/31077214b413cc29c304bd8ba794ac24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lfcYhzK6SOajWPnoMQofSw.jpeg"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">A picture of <a class="ae jz" href="http://tagfinearts.blogspot.com.au/2012/08/world-by-susan-stockwell.html" rel="noopener ugc nofollow" target="_blank">“World”, by Susan Stockwell</a>. The work comprises of a world map made from discarded computer components.</figcaption></figure><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ka kb l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Listen to the audio version!</figcaption></figure></div><div class="ab cl kc kd hc ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hn ho hp hq hr"><p id="2cf4" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">一个<code class="eh lf lg lh li b">function</code>代表了定义一个操作的基本方法。它可以接受<code class="eh lf lg lh li b">arguments</code>并产生一个<code class="eh lf lg lh li b">result</code>。</p><pre class="jk jl jm jn fq lj li lk ll aw lm dt"><span id="fe31" class="ln lo hu li b fv lp lq l lr ls">result = function(arguments)</span></pre><p id="554f" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">你可以用函数的形式表达<a class="ae jz" href="https://youtu.be/3VQ382QG-y4?t=36m21s" rel="noopener ugc nofollow" target="_blank">一切</a>。这是一个心理模型。软件开发的<a class="ae jz" rel="noopener" href="/@fagnerbrack/you-cant-call-yourself-an-explorer-without-a-map-4e19ce51daa3">图</a>。</p><p id="d2d3" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">以下是一些例子:</p><p id="ea26" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">当通过HTTP加载web页面时，您可以将检索资源(URL)的命令视为函数，将查询字符串视为参数。返回的结果表示页面的状态(HTML输出):</p><pre class="jk jl jm jn fq lj li lk ll aw lm dt"><span id="68a4" class="ln lo hu li b fv lp lq l lr ls">state = getResource(queryString)</span></pre><p id="20d0" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">在Git中，树的当前状态表示包含一些更改的提交结果:</p><pre class="jk jl jm jn fq lj li lk ll aw lm dt"><span id="2d3c" class="ln lo hu li b fv lp lq l lr ls">currentState = commit(changes)</span></pre><p id="cecf" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">同样在Git中，存储库的最终状态(您所指向的最后一次提交)代表了从开始按时间顺序重放所有过去提交的所有更改的结果:</p><pre class="jk jl jm jn fq lj li lk ll aw lm dt"><span id="90ee" class="ln lo hu li b fv lp lq l lr ls">finalState = replayAll(pastCommitsInChronologicalOrder);</span></pre><p id="800d" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">对于前端组件，也有类似的模式:</p><pre class="jk jl jm jn fq lj li lk ll aw lm dt"><span id="1487" class="ln lo hu li b fv lp lq l lr ls">visualRepresentation = renderComponent(attributes)</span></pre><p id="ccd1" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">前端组件可以表示为一个<strong class="kl hv">呈现函数</strong>，它接受<strong class="kl hv">属性</strong>并向用户产生一个<strong class="kl hv">视觉表示</strong>。</p><blockquote class="lt"><p id="76c8" class="lu lv hu bd lw lx ly lz ma mb mc le ek translated">前端组件是页面的一个功能。</p></blockquote><p id="52c0" class="pw-post-body-paragraph kj kk hu kl b km md iv ko kp me iy kr ks mf ku kv kw mg ky kz la mh lc ld le hn dt translated">在HTML中，<strong class="kl hv">组件渲染</strong>是通过一个<strong class="kl hv"> HTML元素</strong>声明的，该元素使用浏览器向用户产生<strong class="kl hv">可视化表示</strong>。HTML元素可以包含<strong class="kl hv">属性</strong>。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mi kb l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><a class="ae jz" href="https://gist.github.com/FagnerMartinsBrack/c48dbcc84408a980a8aef1f4659dc74a" rel="noopener ugc nofollow" target="_blank">The HTML code</a> for an input element with the attributes "type" and "placeholder"</figcaption></figure><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mi kb l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><a class="ae jz" href="https://gist.github.com/FagnerMartinsBrack/0bdee5bdd15fff0a27a94ffd86ff0336" rel="noopener ugc nofollow" target="_blank">The pseudo-JavaScript code</a> for an "input" rendering function in which the result is assigned to a variable called "visual representation". The function is being called with an Object Literal containing the attributes "type" and "placeholder".</figcaption></figure><p id="cd01" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">在React中，使用<a class="ae jz" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"><strong class="kl hv"/></a>JavaScript声明<strong class="kl hv">组件渲染</strong>，JavaScript操纵DOM输出<strong class="kl hv"> HTML </strong>，这允许浏览器向用户提供最终的视觉表示。将<strong class="kl hv">属性</strong>命名为<strong class="kl hv">道具</strong>。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mi kb l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><a class="ae jz" href="https://gist.github.com/FagnerMartinsBrack/33bed13802b87410cbf240118fa38eaf" rel="noopener ugc nofollow" target="_blank">The React J.S.X. code</a> for an "auto-suggestion" element with the attributes "list of suggestions" that is an array and "disabled" that is a boolean.</figcaption></figure><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mi kb l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><a class="ae jz" href="https://gist.github.com/FagnerMartinsBrack/bed4222c429222e41e5c905f371ad285" rel="noopener ugc nofollow" target="_blank">The </a><a class="ae jz" href="https://gist.github.com/FagnerMartinsBrack/0bdee5bdd15fff0a27a94ffd86ff0336" rel="noopener ugc nofollow" target="_blank">pseudo-</a><a class="ae jz" href="https://gist.github.com/FagnerMartinsBrack/bed4222c429222e41e5c905f371ad285" rel="noopener ugc nofollow" target="_blank">JavaScript code</a> for an "auto-suggestion" rendering function in which the result is assigned to a variable called "HTML". The function is being called with an Object Literal containing the attributes “list of suggestions” and “disabled”.</figcaption></figure><p id="77d9" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">在Angular 1.4中，使用从<em class="mj">指令定义对象返回的<code class="eh lf lg lh li b">restrict: 'E'</code>属性，使用<strong class="kl hv">指令</strong>来声明<strong class="kl hv">组件渲染</strong>。</em><code class="eh lf lg lh li b">restrict: 'E'</code>定义强制将指令声明为标记中的HTML元素。输出是<strong class="kl hv"> HTML </strong>，允许浏览器向用户提供最终的可视化表示<strong class="kl hv"> </strong>。组件也有<strong class="kl hv">属性</strong>。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mi kb l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><a class="ae jz" href="https://gist.github.com/FagnerMartinsBrack/8b801e0483f869805b17e44c89daadf2" rel="noopener ugc nofollow" target="_blank">The Angular code</a> for a "progress bar" element with the attribute “title”.</figcaption></figure><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mi kb l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><a class="ae jz" href="https://gist.github.com/FagnerMartinsBrack/b45878f283d7277a84a7101ce537875d" rel="noopener ugc nofollow" target="_blank">The </a><a class="ae jz" href="https://gist.github.com/FagnerMartinsBrack/0bdee5bdd15fff0a27a94ffd86ff0336" rel="noopener ugc nofollow" target="_blank">pseudo-</a><a class="ae jz" href="https://gist.github.com/FagnerMartinsBrack/b45878f283d7277a84a7101ce537875d" rel="noopener ugc nofollow" target="_blank">JavaScript code</a> for a "progress bar" rendering function in which the result is assigned to a variable called "HTML". The function is being called with an Object Literal containing the attribute “title”.</figcaption></figure><p id="c3de" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">基本上，组件都是一样的。</p><p id="2d36" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">网络正走在软件工程多年前走过的同一条路上。它重新发明了构建抽象复杂逻辑的小组件的规则。一整套似乎已经失传的哲学体系。</p><p id="927a" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">今天，每个人都称它为<code class="eh lf lg lh li b">Components</code>。明天，可能会叫别的。</p><p id="4f72" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">最终，每个组件只是一个产生结果和接受参数的函数:</p><pre class="jk jl jm jn fq lj li lk ll aw lm dt"><span id="0887" class="ln lo hu li b fv lp lq l lr ls">result = function(arguments)</span></pre><blockquote class="lt"><p id="aa8d" class="lu lv hu bd lw lx mk ml mm mn mo le ek translated">我们应用于函数的许多原则也可以应用于组件。</p></blockquote><p id="d5c5" class="pw-post-body-paragraph kj kk hu kl b km md iv ko kp me iy kr ks mf ku kv kw mg ky kz la mh lc ld le hn dt translated">让我们以一个无限可滚动列表为例，说明将组件视为功能可以帮助您构建更好的软件。</p><p id="be49" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">在内部，组件向服务器发送请求，以便在用户每次向下滚动时检索它需要的部分内容:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mi kb l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><a class="ae jz" href="https://gist.github.com/FagnerMartinsBrack/4e2f1fdb8bd331a6aaa952dfa7847307" rel="noopener ugc nofollow" target="_blank">The pseudo declarative code</a> for a component called "infinite scrollable list" using no specific syntax or framework, just the opening, and closing tags. There are no attributes set for it.</figcaption></figure><p id="3f58" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">网络请求是一个副作用。您希望避免在组件内部处理副作用，就像在函数内部一样。相反，将其作为参数传递:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mi kb l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><a class="ae jz" href="https://gist.github.com/FagnerMartinsBrack/14901caeb99e7853f6a7e0706f1ce3eb" rel="noopener ugc nofollow" target="_blank">The pseudo declarative code</a> for a component called “infinite scrollable list” using no specific syntax or framework, just the opening, and closing tags. The element contains an attribute called "fetch" that make the request from the network and passes the result as a callback to the component.</figcaption></figure><p id="b5b5" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">如果组件本身不向服务器请求新数据，而是接受它作为一个属性，那么呈现组件进行测试将会更容易。如果组件的名字是正确的，并且封装得很好，它也将驱使你走向松耦合和高内聚的原则(参见<a class="ae jz" rel="noopener" href="/@fagnerbrack/why-do-you-need-to-know-package-coupling-fundamentals-8e0fa8e33e20">耦合</a>和<a class="ae jz" rel="noopener" href="/@fagnerbrack/why-do-you-need-to-know-package-cohesion-fundamentals-8a3510cba2c1">内聚</a>对于包意味着什么)。</p><blockquote class="lt"><p id="e2da" class="lu lv hu bd lw lx ly lz ma mb mc le ek translated">如果尽可能尝试构建纯函数是一个好的实践，那么对组件也是一个好的实践。</p></blockquote><p id="47ce" class="pw-post-body-paragraph kj kk hu kl b km md iv ko kp me iy kr ks mf ku kv kw mg ky kz la mh lc ld le hn dt translated">正如我去年提到的那样，网络有一种完全基于组件的趋势。我不确定谁会是赢家。可以是框架，可以是库，也可以是别的。有一点可以肯定的是，无论它是什么，它都必须实现这里介绍的同一种<a class="ae jz" href="https://codeburst.io/why-do-you-need-to-know-interface-fundamentals-a129ac6ab0c3" rel="noopener" target="_blank">接口</a>。</p><p id="6186" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">功能是基本的，组件遵循相同的模式。它们也可以遵循相同的原则，就像它们是页面上下文中的函数一样。</p><p id="cc3c" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">如果你为了理解如何构建更好的组件而参考简单的功能——为此，我不是指核心的功能性<a class="ae jz" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>——你将能够创建具有高内聚和松耦合的弹性web应用程序，能够经受住时间的考验。</p><p id="175c" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">应用程序不必完全重写，因为有一个新的组件框架在做和其他人一样的事情。</p></div><div class="ab cl kc kd hc ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hn ho hp hq hr"><p id="505e" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">感谢阅读。如果你有一些反馈，请在<a class="ae jz" href="https://twitter.com/FagnerBrack" rel="noopener ugc nofollow" target="_blank">推特</a>、<a class="ae jz" href="https://www.facebook.com/fagner.brack" rel="noopener ugc nofollow" target="_blank">脸书</a>或<a class="ae jz" href="http://github.com/FagnerMartinsBrack" rel="noopener ugc nofollow" target="_blank"> Github </a>上联系我。</p></div></div>    
</body>
</html>