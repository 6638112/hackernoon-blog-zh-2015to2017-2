<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://medium.com/hackernoon/mvp-android-architecture-components-aef55e15bfe3?source=collection_archive---------1-----------------------#2017-05-27">https://medium.com/hackernoon/mvp-android-architecture-components-aef55e15bfe3?source=collection_archive---------1-----------------------#2017-05-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><h2 id="8f32" class="hs ht hu bd hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq dt translated"><strong class="ak"> MVP + Android架构组件= ❤ </strong></h2><figure class="is it iu iv fq iw fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/fee2a1e4a99ce754ea973512a09697f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*QPOfsrqKjkdP-d1sqf6WCw.gif"/></div></figure><p id="86b6" class="pw-post-body-paragraph iz ja hu jb b jc jd je jf jg jh ji jj ie jk jl jm ii jn jo jp im jq jr js jt hn dt translated">前几天，Google I/O期间展示了<a class="ae ju" href="https://developer.android.com/topic/libraries/architecture/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jb jv"> Android架构组件</strong> </a>。我们决定将这些组件与MPV架构相结合。那么，让我们看看我们得到了什么结果。</p><p id="bcfc" class="pw-post-body-paragraph iz ja hu jb b jc jd je jf jg jh ji jj ie jk jl jm ii jn jo jp im jq jr js jt hn dt translated">使用MPV架构的一个常见问题是<strong class="jb jv">在改变屏幕方向时保持演示者的状态</strong>。对此有一些解决方案(Loaders、retainInstance、Mosby、<a class="ae ju" href="https://github.com/Arello-Mobile/Moxy" rel="noopener ugc nofollow" target="_blank"> Moxy </a>等等)。</p><p id="e680" class="pw-post-body-paragraph iz ja hu jb b jc jd je jf jg jh ji jj ie jk jl jm ii jn jo jp im jq jr js jt hn dt translated">在I/O期间出现的那些架构组件之一是一个<a class="ae ju" href="https://developer.android.com/topic/libraries/architecture/viewmodel.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jb jv">视图模型</strong> </a> <strong class="jb jv">。</strong></p><p id="3a43" class="pw-post-body-paragraph iz ja hu jb b jc jd je jf jg jh ji jj ie jk jl jm ii jn jo jp im jq jr js jt hn dt translated">"<em class="jw">ViewModel类被设计用于存储和管理与UI相关的数据，以便这些数据在配置更改(如屏幕旋转)后仍然存在。</em>”—来自官方文件。</p><p id="9025" class="pw-post-body-paragraph iz ja hu jb b jc jd je jf jg jh ji jj ie jk jl jm ii jn jo jp im jq jr js jt hn dt translated">它让我们有机会在屏幕方向改变时保存对象。</p><p id="1b2f" class="pw-post-body-paragraph iz ja hu jb b jc jd je jf jg jh ji jj ie jk jl jm ii jn jo jp im jq jr js jt hn dt translated">另一个组件是我们将使用的<a class="ae ju" href="https://developer.android.com/topic/libraries/architecture/lifecycle.html" rel="noopener ugc nofollow" target="_blank"><strong class="jb jv"/></a><strong class="jb jv">、</strong>。</p><p id="2af7" class="pw-post-body-paragraph iz ja hu jb b jc jd je jf jg jh ji jj ie jk jl jm ii jn jo jp im jq jr js jt hn dt translated">android.arch.lifecycle包提供了让您构建生命周期感知组件的类和接口，这些组件可以根据活动或片段的当前生命周期自动调整其行为。——来自官方文件。</p><p id="e2d3" class="pw-post-body-paragraph iz ja hu jb b jc jd je jf jg jh ji jj ie jk jl jm ii jn jo jp im jq jr js jt hn dt translated"><strong class="jb jv"> 1。方向改变前</strong></p><figure class="is it iu iv fq iw fe ff paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="fe ff jx"><img src="../Images/3230a77588b9adde3643097f7e94c912.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TVxbF08RjwtZHlqEW-ijIg.png"/></div></div></figure><p id="5ae3" class="pw-post-body-paragraph iz ja hu jb b jc jd je jf jg jh ji jj ie jk jl jm ii jn jo jp im jq jr js jt hn dt translated"><strong class="jb jv"> 2。方向改变后</strong></p><figure class="is it iu iv fq iw fe ff paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="fe ff jx"><img src="../Images/bfcdb3280e1c3e13c6176c0517e594dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8I7cAZwfslXHrV0VMd87sA.png"/></div></div></figure><p id="8223" class="pw-post-body-paragraph iz ja hu jb b jc jd je jf jg jh ji jj ie jk jl jm ii jn jo jp im jq jr js jt hn dt translated">让我们从头开始设计我们的<strong class="jb jv">展示者</strong>和<strong class="jb jv">视图</strong>。让我们创建一个<strong class="jb jv">契约接口。</strong></p><pre class="is it iu iv fq kc kd ke kf aw kg dt"><span id="5747" class="hs ht hu kd b fv kh ki l kj kk"><strong class="kd jv">public interface </strong>BaseContract {<br/><br/>    <strong class="kd jv">interface </strong>View {<br/><br/>    }<br/><br/>    <strong class="kd jv">interface </strong>Presenter&lt;V <strong class="kd jv">extends </strong>BaseContract.View&gt; {<br/>        <br/>        <strong class="kd jv">void </strong>attachLifecycle(Lifecycle lifecycle);<br/><br/>        <strong class="kd jv">void </strong>detachLifecycle(Lifecycle lifecycle);<br/><br/>        <strong class="kd jv">void </strong>attachView(V view);<br/><br/>        <strong class="kd jv">void </strong>detachView();<br/><br/>        V getView();<br/><br/>        <strong class="kd jv">boolean </strong>isViewAttached();<br/><br/>        <strong class="kd jv">void </strong>onPresenterDestroy();<br/>    }<br/>}</span></pre><p id="8cee" class="pw-post-body-paragraph iz ja hu jb b jc jd je jf jg jh ji jj ie jk jl jm ii jn jo jp im jq jr js jt hn dt translated">在这之后，我们需要创建实现我们的<strong class="jb jv">提交者契约</strong>的<strong class="jb jv">提交者</strong>。</p><pre class="is it iu iv fq kc kd ke kf aw kg dt"><span id="95ff" class="hs ht hu kd b fv kh ki l kj kk"><strong class="kd jv">public abstract class </strong>BasePresenter&lt;V <strong class="kd jv">extends </strong>BaseContract.View&gt; <strong class="kd jv">implements </strong>LifecycleObserver, BaseContract.Presenter&lt;V&gt; {<br/><br/>    <strong class="kd jv">private </strong>V <strong class="kd jv">view</strong>;<br/><br/>    @Override<br/>    <strong class="kd jv">final public </strong>V getView() {<br/>        <strong class="kd jv">return view</strong>;<br/>    }<br/><br/>    @Override<br/>    <strong class="kd jv">final public void </strong>attachLifecycle(Lifecycle lifecycle) {<br/>        lifecycle.addObserver(<strong class="kd jv">this</strong>);<br/>    }<br/><br/>    @Override<br/>    <strong class="kd jv">final public void </strong>detachLifecycle(Lifecycle lifecycle) {<br/>        lifecycle.removeObserver(<strong class="kd jv">this</strong>);<br/>    }<br/><br/>    @Override<br/>    <strong class="kd jv">final public void </strong>attachView(V view) {<br/>        <strong class="kd jv">this</strong>.<strong class="kd jv">view </strong>= view;<br/>    }<br/><br/>    @Override<br/>    <strong class="kd jv">final public void </strong>detachView() {<br/>        <strong class="kd jv">view </strong>= <strong class="kd jv">null</strong>;<br/>    }<br/><br/>    @Override<br/>    <strong class="kd jv">final public boolean </strong>isViewAttached() {<br/>        <strong class="kd jv">return view </strong>!= <strong class="kd jv">null</strong>;<br/>    }<br/>}</span></pre><p id="237e" class="pw-post-body-paragraph iz ja hu jb b jc jd je jf jg jh ji jj ie jk jl jm ii jn jo jp im jq jr js jt hn dt translated">因此，我们有一个<strong class="jb jv">呈现器</strong>，它附加和分离<strong class="jb jv">视图</strong>和<strong class="jb jv">生命周期观察者</strong>。</p><p id="3b4e" class="pw-post-body-paragraph iz ja hu jb b jc jd je jf jg jh ji jj ie jk jl jm ii jn jo jp im jq jr js jt hn dt translated">接下来，让我们创建我们的<strong class="jb jv">活动</strong>。这里我们有一个问题:演示者将在每次方向改变后重新创建。</p><figure class="is it iu iv fq iw fe ff paragraph-image"><div class="fe ff kl"><img src="../Images/6377e314594d3f5aae389eb97ae2117c.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*MHRIeHFc78iif3PA8MQXRg.png"/></div></figure></div><div class="ab cl km kn hc ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hn ho hp hq hr"><p id="267f" class="pw-post-body-paragraph iz ja hu jb b jc jd je jf jg jh ji jj ie jk jl jm ii jn jo jp im jq jr js jt hn dt translated">我们继续吧。</p><p id="b7d0" class="pw-post-body-paragraph iz ja hu jb b jc jd je jf jg jh ji jj ie jk jl jm ii jn jo jp im jq jr js jt hn dt translated"><a class="ae ju" href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jb jv"> ViewModel </strong> </a>会在配置更改期间自动保留，以便其保存的数据可立即用于下一个活动或片段实例。这将帮助我们不要每次都将<strong class="jb jv">初始化为</strong>Presenter。</p><p id="9c40" class="pw-post-body-paragraph iz ja hu jb b jc jd je jf jg jh ji jj ie jk jl jm ii jn jo jp im jq jr js jt hn dt translated">为此，我们将创建<strong class="jb jv">类</strong>，它从<strong class="jb jv"> ViewModel </strong>扩展而来。它将接收并返回演示者的对象。<strong class="jb jv"> ViewModel </strong>也有<strong class="jb jv">on cleed()。如果重新创建该活动，它将接收由前一个活动创建的相同<strong class="jb jv"> ViewModel </strong>实例。所有者活动完成后，框架调用<a class="ae ju" href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel.html" rel="noopener ugc nofollow" target="_blank"><strong class="jb jv">view model</strong></a><strong class="jb jv">的</strong><a class="ae ju" href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel.html#onCleared()" rel="noopener ugc nofollow" target="_blank"><strong class="jb jv">onclilead()。</strong></a></strong></p><pre class="is it iu iv fq kc kd ke kf aw kg dt"><span id="cd46" class="hs ht hu kd b fv kh ki l kj kk"><strong class="kd jv">public final class </strong>BaseViewModel&lt;V <strong class="kd jv">extends </strong>BaseContract.View, P <strong class="kd jv">extends </strong>BaseContract.Presenter&lt;V&gt;&gt; <strong class="kd jv">extends </strong>ViewModel {<br/><br/>    <strong class="kd jv">private </strong>P <strong class="kd jv">presenter</strong>;<br/><br/>    <strong class="kd jv">void </strong>setPresenter(P presenter) {<br/>        <strong class="kd jv">if </strong>(<strong class="kd jv">this</strong>.<strong class="kd jv">presenter </strong>== <strong class="kd jv">null</strong>) {<br/>            <strong class="kd jv">this</strong>.<strong class="kd jv">presenter </strong>= presenter;<br/>        }<br/>    }<br/><br/>    P getPresenter() {<br/>        <strong class="kd jv">return this</strong>.<strong class="kd jv">presenter</strong>;<br/>    }<br/><br/>    @Override<br/>    <strong class="kd jv">protected void </strong>onCleared() {<br/>        <strong class="kd jv">super</strong>.onCleared();<br/>        <strong class="kd jv">presenter</strong>.onPresenterDestroy();<br/>        <strong class="kd jv">presenter </strong>= <strong class="kd jv">null</strong>;<br/>    }<br/>}</span></pre><p id="7b23" class="pw-post-body-paragraph iz ja hu jb b jc jd je jf jg jh ji jj ie jk jl jm ii jn jo jp im jq jr js jt hn dt translated">在下一步中，我们将在Activity中创建<strong class="jb jv"> BaseViewModel </strong>实例。</p><p id="a638" class="pw-post-body-paragraph iz ja hu jb b jc jd je jf jg jh ji jj ie jk jl jm ii jn jo jp im jq jr js jt hn dt translated">此外，我们必须将<strong class="jb jv">生命周期</strong>交给<strong class="jb jv">演示者</strong>。所以我们需要生命周期注册。且该活动必须落实到<strong class="jb jv">life cycleeregistryowner。</strong></p><pre class="is it iu iv fq kc kd ke kf aw kg dt"><span id="b6bd" class="hs ht hu kd b fv kh ki l kj kk"><strong class="kd jv">public abstract class </strong>BaseActivity&lt;V <strong class="kd jv">extends </strong>BaseContract.View, P <strong class="kd jv">extends </strong>BaseContract.Presenter&lt;V&gt;&gt; <strong class="kd jv">extends </strong>AppCompatActivity <strong class="kd jv">implements </strong>BaseContract.View, LifecycleRegistryOwner {<br/><br/>    <strong class="kd jv">private final </strong>LifecycleRegistry <strong class="kd jv">lifecycleRegistry </strong>= <br/>             <strong class="kd jv">new </strong>LifecycleRegistry(<strong class="kd jv">this</strong>);<br/>    <strong class="kd jv">protected </strong>P <strong class="kd jv">presenter</strong>;<br/><br/>    @CallSuper<br/>    @Override<br/>    <strong class="kd jv">protected void </strong>onCreate(@Nullable Bundle savedInstanceState) {<br/>        <strong class="kd jv">super</strong>.onCreate(savedInstanceState);<br/>        BaseViewModel&lt;V, P&gt; viewModel = <br/>            ViewModelProviders.<em class="jw">of</em>(<strong class="kd jv">this</strong>).get(BaseViewModel.<strong class="kd jv">class</strong>);<br/>        <strong class="kd jv">if </strong>(viewModel.getPresenter() == <strong class="kd jv">null</strong>) {<br/>            viewModel.setPresenter(initPresenter());<br/>        }<br/>        <strong class="kd jv">presenter </strong>= viewModel.getPresenter();<br/>        <strong class="kd jv">presenter</strong>.attachLifecycle(getLifecycle());<br/>        <strong class="kd jv">presenter</strong>.attachView((V) <strong class="kd jv">this</strong>);<br/>    }<br/><br/>    @Override<br/>    <strong class="kd jv">public </strong>LifecycleRegistry getLifecycle() {<br/>        <strong class="kd jv">return lifecycleRegistry</strong>;<br/>    }<br/><br/>    @CallSuper<br/>    @Override<br/>    <strong class="kd jv">protected void </strong>onDestroy() {<br/>        <strong class="kd jv">super</strong>.onDestroy();<br/>        <strong class="kd jv">presenter</strong>.detachLifecycle(getLifecycle());<br/>        <strong class="kd jv">presenter</strong>.detachView();<br/>    }<br/><br/>    <strong class="kd jv">protected abstract </strong>P initPresenter();<br/>}</span></pre><p id="2d0d" class="pw-post-body-paragraph iz ja hu jb b jc jd je jf jg jh ji jj ie jk jl jm ii jn jo jp im jq jr js jt hn dt translated">在第一次创建活动时，我们必须创建一个Presenter并将其交给<strong class="jb jv"> ViewModel </strong>。下次重新创建活动时，我们只需从<strong class="jb jv"> ViewModel </strong>中重用我们的<strong class="jb jv"> Presenter </strong>。</p><p id="7ccb" class="pw-post-body-paragraph iz ja hu jb b jc jd je jf jg jh ji jj ie jk jl jm ii jn jo jp im jq jr js jt hn dt translated">首次创建Presenter时，必须附加<strong class="jb jv">生命周期</strong>和<strong class="jb jv">视图</strong>。为了避免内存泄漏，我们还需要在<strong class="jb jv"> onDestroy()中分离<strong class="jb jv">生命周期</strong>和<strong class="jb jv">视图</strong>。</strong></p><figure class="is it iu iv fq iw fe ff paragraph-image"><div class="fe ff kt"><img src="../Images/745ffabd5fb7299805dd1c77f47c73db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*ZT77cCGXeQiviyvB_AMIIg.jpeg"/></div></figure><p id="7406" class="pw-post-body-paragraph iz ja hu jb b jc jd je jf jg jh ji jj ie jk jl jm ii jn jo jp im jq jr js jt hn dt translated">此外，我们还有内部的<strong class="jb jv">活动生命周期</strong> <a class="ae ju" href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.Event.html#ON_ANY" rel="noopener ugc nofollow" target="_blank">事件</a>。</p><pre class="is it iu iv fq kc kd ke kf aw kg dt"><span id="d00b" class="hs ht hu kd b fv kh ki l kj kk">@OnLifecycleEvent(value = Lifecycle.Event.<strong class="kd jv"><em class="jw">ON_CREATE</em></strong>)<br/><strong class="kd jv">protected void </strong>onCreate() {<br/>    <br/>}</span></pre></div><div class="ab cl km kn hc ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hn ho hp hq hr"><p id="d602" class="pw-post-body-paragraph iz ja hu jb b jc jd je jf jg jh ji jj ie jk jl jm ii jn jo jp im jq jr js jt hn dt translated">就整个谜题而言，有些东西缺乏。这是一个<strong class="jb jv">视图</strong>的状态。</p><p id="eab7" class="pw-post-body-paragraph iz ja hu jb b jc jd je jf jg jh ji jj ie jk jl jm ii jn jo jp im jq jr js jt hn dt translated">为此，我们必须在我们的<strong class="jb jv"> BaseContract </strong>中有<strong class="jb jv"> Bundle getStateBundle() </strong>，在<strong class="jb jv"> Presenter </strong>中有<strong class="jb jv"> Bundle </strong> stateBundle，它们将保持并返回我们的<strong class="jb jv">视图</strong>状态。</p><p id="4b28" class="pw-post-body-paragraph iz ja hu jb b jc jd je jf jg jh ji jj ie jk jl jm ii jn jo jp im jq jr js jt hn dt translated">最后的陈述者是这样的:</p><pre class="is it iu iv fq kc kd ke kf aw kg dt"><span id="fb12" class="hs ht hu kd b fv kh ki l kj kk"><strong class="kd jv">public abstract class </strong>BasePresenter&lt;V <strong class="kd jv">extends </strong>BaseContract.View&gt; <strong class="kd jv">implements </strong>LifecycleObserver, BaseContract.Presenter&lt;V&gt; {<br/><br/>    <strong class="kd jv">private </strong>Bundle <strong class="kd jv">stateBundle</strong>;<br/>    <strong class="kd jv">private </strong>V <strong class="kd jv">view</strong>;<br/><br/>    @Override<br/>    <strong class="kd jv">final public </strong>V getView() {<br/>        <strong class="kd jv">return view</strong>;<br/>    }<br/><br/>    @Override<br/>    <strong class="kd jv">final public void </strong>attachLifecycle(Lifecycle lifecycle) {<br/>        lifecycle.addObserver(<strong class="kd jv">this</strong>);<br/>    }<br/><br/>    @Override<br/>    <strong class="kd jv">final public void </strong>detachLifecycle(Lifecycle lifecycle) {<br/>        lifecycle.removeObserver(<strong class="kd jv">this</strong>);<br/>    }<br/><br/>    @Override<br/>    <strong class="kd jv">final public void </strong>attachView(V view) {<br/>        <strong class="kd jv">this</strong>.<strong class="kd jv">view </strong>= view;<br/>    }<br/><br/>    @Override<br/>    <strong class="kd jv">final public void </strong>detachView() {<br/>        <strong class="kd jv">view </strong>= <strong class="kd jv">null</strong>;<br/>    }<br/><br/>    @Override<br/>    <strong class="kd jv">final public boolean </strong>isViewAttached() {<br/>        <strong class="kd jv">return view </strong>!= <strong class="kd jv">null</strong>;<br/>    }<br/><br/>    @Override<br/>    <strong class="kd jv">final public </strong>Bundle getStateBundle() {<br/>        <strong class="kd jv">return stateBundle </strong>== <strong class="kd jv">null </strong>? <br/>                <strong class="kd jv">stateBundle </strong>= <strong class="kd jv">new </strong>Bundle() : <strong class="kd jv">stateBundle</strong>;<br/>    }<br/><br/>    @CallSuper<br/>    @Override<br/>    <strong class="kd jv">public void </strong>onPresenterDestroy() {<br/>        <strong class="kd jv">if </strong>(<strong class="kd jv">stateBundle </strong>!= <strong class="kd jv">null </strong>&amp;&amp; !<strong class="kd jv">stateBundle</strong>.isEmpty()) {<br/>            <strong class="kd jv">stateBundle</strong>.clear();<br/>        }<br/>    }<br/>}</span></pre></div><div class="ab cl km kn hc ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hn ho hp hq hr"><p id="696f" class="pw-post-body-paragraph iz ja hu jb b jc jd je jf jg jh ji jj ie jk jl jm ii jn jo jp im jq jr js jt hn dt translated"><strong class="jb jv">感谢阅读本文。你可以在</strong>  <strong class="jb jv">那里找到完整的代码</strong> <a class="ae ju" href="https://github.com/armcha/MVP-Architecture-Components" rel="noopener ugc nofollow" target="_blank"> <strong class="jb jv">。</strong></a></p><p id="cdae" class="pw-post-body-paragraph iz ja hu jb b jc jd je jf jg jh ji jj ie jk jl jm ii jn jo jp im jq jr js jt hn dt translated"><strong class="jb jv">让我们在</strong><a class="ae ju" href="https://twitter.com/ArmanChatikyan" rel="noopener ugc nofollow" target="_blank"><strong class="jb jv">Twitter</strong></a><strong class="jb jv"/><a class="ae ju" href="https://github.com/armcha/" rel="noopener ugc nofollow" target="_blank"><strong class="jb jv">Github</strong></a><strong class="jb jv">和</strong> <a class="ae ju" href="https://web.facebook.com/chatikyana" rel="noopener ugc nofollow" target="_blank"> <strong class="jb jv">脸书</strong> </a> <strong class="jb jv">上成为朋友吧。如果你喜欢这些作品，那么请使用下面的❤之心来推荐这篇文章，这样其他人也可以看到它。</strong></p><p id="6877" class="pw-post-body-paragraph iz ja hu jb b jc jd je jf jg jh ji jj ie jk jl jm ii jn jo jp im jq jr js jt hn dt translated">我们也很乐意听到你的意见和建议:)</p><p id="517a" class="pw-post-body-paragraph iz ja hu jb b jc jd je jf jg jh ji jj ie jk jl jm ii jn jo jp im jq jr js jt hn dt translated"><strong class="jb jv">谢谢。</strong></p></div></div>    
</body>
</html>