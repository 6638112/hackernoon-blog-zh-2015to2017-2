<html>
<head>
<title>How I Manage My Passwords (Technical Version)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何管理我的密码(技术版)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-i-manage-my-passwords-technical-version-8549dc1bde1e?source=collection_archive---------6-----------------------#2017-10-10">https://medium.com/hackernoon/how-i-manage-my-passwords-technical-version-8549dc1bde1e?source=collection_archive---------6-----------------------#2017-10-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="79de" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">更新:</strong>我们发布了<a class="ae jp" rel="noopener" href="/@0x0ece/mempa-a-modern-deterministic-password-manager-2c0f28fa108b"> MemPa，一个现代的确定性密码管理器</a>，实现了本文中的想法。</p><p id="5aca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在过去的一年里，我改进了一种方法来处理我的密码，因为我与现有的经理有一个主要问题:有一些密码——谷歌、银行——我<strong class="it hv">从来不想存储</strong>，但我<strong class="it hv">总是想访问</strong>。</p><p id="8353" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我开始在一个亲密的群体中分享我的想法，邀请了一些朋友，现在我认为是时候打开它了，看看你怎么想。</p><p id="1238" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个为可用性而设计的确定性密码管理器。对于每一个<em class="jq">服务</em>(站点或应用)，我们从<em class="jq">密码短语</em>(需要<em class="jq">知道的事情</em>)中生成一个唯一的<em class="jq">秘密</em>(存储在服务中的密码)。我们只需要记住一个密码，或者很少一部分——我个人有一个默认密码，一个用于重要网站(谷歌、脸书等等)，一个用于银行。这是高级算法:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="3440" class="ka kb hu jw b fv kc kd l ke kf">secret = ...<strong class="jw hv">hash(</strong> ...passphrase, service...<strong class="jw hv"> )</strong></span></pre><p id="49d9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些是常见问题。</p><h2 id="e00e" class="ka kb hu bd kg kh ki kj kk kl km kn ko jc kp kq kr jg ks kt ku jk kv kw kx ky dt translated">问:你真的散列密码吗？！？！</h2><p id="980c" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">不。我们没有“散列密码来安全地存储它”，这将是错误的。Secret <em class="jq">就是</em>密码，而且:1。我们从不储存它，2。该服务将存储它的密码加密。(希望如此！)<br/>我们是“哈希生成随机位串”。</p><h2 id="e149" class="ka kb hu bd kg kh ki kj kk kl km kn ko jc kp kq kr jg ks kt ku jk kv kw kx ky dt translated">问:为什么不使用密钥派生函数？！？！</h2><p id="cc65" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">KDF需要盐，这是记不住的东西，这是一个交易破坏者。主要目标是能够只用我们能记住的信息重建任何秘密。</p><h1 id="e76f" class="le kb hu bd kg lf lg lh kk li lj lk ko ll lm ln kr lo lp lq ku lr ls lt kx lu dt translated">算法</h1><p id="4b79" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">具体算法是这样的:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="01d9" class="ka kb hu jw b fv kc kd l ke kf">secret = format(hash( username, passphrase, counter, service ))</span></pre><p id="8413" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">其中:</p><ul class=""><li id="45d0" class="lv lw hu it b iu iv iy iz jc lx jg ly jk lz jo ma mb mc md dt translated"><em class="jq">用户名</em>，用于登录的用户名或邮箱</li><li id="5be1" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo ma mb mc md dt translated"><em class="jq">密码</em>是组密码，即对于一组服务来说是相同的</li><li id="e125" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo ma mb mc md dt translated"><em class="jq">计数器</em>是一个能够在需要时生成新秘密的计数器，它几乎总是0</li><li id="1f89" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo ma mb mc md dt translated"><em class="jq">服务</em>是服务，按照惯例主机名去掉了“www”，比如pinterest.com——注意没有严格强制，我们甚至可以使用“pinterest.com”登录“pinterest.co.uk”</li><li id="6207" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo ma mb mc md dt translated">散列值是sha256，选择它是因为它在许多环境中都可用——我们将尽快用sha3替换它</li><li id="2477" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo ma mb mc md dt translated"><em class="jq"> format </em>是一个将hash的输出转换成“格式正确”的字符串的函数。我们决定使用base64，去掉所有非字母数字字符，截断为12个字符(60位)，并每3个字符添加一个破折号，例如“uBP-8Pe-5xM-mBe”(与Safari使用的格式相同)</li></ul><h1 id="3434" class="le kb hu bd kg lf lg lh kk li lj lk ko ll lm ln kr lo lp lq ku lr ls lt kx lu dt translated">履行</h1><p id="2e52" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">在Javascript中(如果你在Chrome上，打开开发控制台并粘贴):</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="5737" class="ka kb hu jw b fv kc kd l ke kf">document.head.appendChild(document.createElement('script')).src='<a class="ae jp" href="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/crypto-js.min.js" rel="noopener ugc nofollow" target="_blank">https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/crypto-js.min.js</a>';</span><span id="2dac" class="ka kb hu jw b fv mj kd l ke kf">CryptoJS.SHA256('user:passphrase:0:example.com').toString(CryptoJS.enc.Base64).replace(/[^0-9A-Za-z]/g, '').substring(0, 12).match(/.{3}/g).join('-');</span></pre><figure class="jr js jt ju fq ml fe ff paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="fe ff mk"><img src="../Images/0fd201689867da9d5ee5210e9cabd2d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*132I3DfhZOyJJ5IrW-Eufw.png"/></div></div></figure><p id="1c6d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Python 2/3中:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="98fe" class="ka kb hu jw b fv kc kd l ke kf">import base64, hashlib, re</span><span id="c18c" class="ka kb hu jw b fv mj kd l ke kf">h = hashlib.sha256(); h.update(b'user:passphrase:0:example.com');  '-'.join([re.sub(r'[^0-9A-Za-z]', '', base64.b64encode(h.digest()) .decode())[i:i+3] for i in range(0, 12, 3)])</span></pre><p id="18b5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">编辑:我朋友Paolo建了<a class="ae jp" href="https://github.com/psmiraglia/python-dpg" rel="noopener ugc nofollow" target="_blank">自己的Python app </a>！</p><p id="6d9d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在bash中:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="38f2" class="ka kb hu jw b fv kc kd l ke kf">echo -n 'user:passphrase:0:example.com' | openssl dgst -sha256 -binary | openssl base64 | sed -e 's/[^0-9A-Za-z]//g' | egrep -o '.{3}' | head -4 | paste -sd'-' -</span></pre><p id="09af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是我们想要的可用性。参数和核心算法很容易记住，加密函数(sha256，base64)也很容易获得。</p><p id="59cb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上面的一行程序只是花哨的附加程序，我个人不太记得它们，但是一旦我运行了sha256和base64(在示例中，getting:" uBP 8 PE 5 xmbbeeopleasg+ppkpbkbbmvorbaavofwis 0 = ")，我就可以很容易地手动导出格式化字符串" uBP-8Pe-5xM-mBe "。</p></div><div class="ab cl ms mt hc mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hn ho hp hq hr"><p id="08aa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我已经开始用几个密码做实验，现在我在我的大多数网站和应用程序中使用这种方法。</p><p id="349d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">很明显，它不适用于现有的秘密，也不适用于你必须频繁输入的密码，比如解锁我的笔记本电脑的密码。在实践中，我没有遇到其他“明显”的限制，例如，对于有特殊要求的站点，secret的格式很容易适应和记住。</p><p id="d774" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，我打算开发一个管理秘密的应用程序，让它更容易在手机上复制和粘贴。所有这些都保留了核心思想，即一些密码永远不应该被存储，但总是可以访问的。(即使没有app！)</p><p id="6249" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">是时候听听你的意见了:你怎么看？你喜欢这个算法吗？你看到自己在使用它吗？如果你有批评，这些批评是针对确定性密码管理器的，还是针对这个的？如果你很喜欢它，你会觉得少了什么吗？任何反馈都是非常受欢迎的，在下面的评论中，在黑客新闻上，或者在Twitter <a class="ae jp" href="https://twitter.com/0x0ece" rel="noopener ugc nofollow" target="_blank"> @0x0ece </a>上。</p><p id="4cf0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">更新:</strong>看看<a class="ae jp" rel="noopener" href="/@0x0ece/mempa-a-modern-deterministic-password-manager-2c0f28fa108b"> MemPa，一个现代的确定性密码管理器</a>，它实现了本文中的想法。</p></div></div>    
</body>
</html>