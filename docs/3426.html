<html>
<head>
<title>Comparing the performance of various serializers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比较各种序列化程序的性能</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/comparing-the-performance-of-various-serializers-8cc459a24c21?source=collection_archive---------2-----------------------#2017-04-01">https://medium.com/hackernoon/comparing-the-performance-of-various-serializers-8cc459a24c21?source=collection_archive---------2-----------------------#2017-04-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="3ddd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">已经有<a class="ae jp" href="https://maxondev.com/serialization-performance-comparison-c-net-formats-frameworks-xmldatacontractserializer-xmlserializer-binaryformatter-json-newtonsoft-servicestack-text/" rel="noopener ugc nofollow" target="_blank">串行化器</a>的<a class="ae jp" href="http://theburningmonk.com/2014/08/json-serializers-benchmarks-updated-2/" rel="noopener ugc nofollow" target="_blank">基准</a>上的<a class="ae jp" href="http://geekswithblogs.net/LeonidGaneline/archive/2015/05/06/serializers-in-.net.-v.2.aspx" rel="noopener ugc nofollow" target="_blank">各种</a> <a class="ae jp" href="https://www.hanselman.com/blog/ProperBenchmarkingToDiagnoseAndSolveANETSerializationBottleneck.aspx" rel="noopener ugc nofollow" target="_blank">文章</a>。甚至<a class="ae jp" href="https://github.com/sqfasd/node-serialization-benchmark" rel="noopener ugc nofollow" target="_blank">各种</a> <a class="ae jp" href="https://github.com/thekvs/cpp-serializers" rel="noopener ugc nofollow" target="_blank"> github </a> <a class="ae jp" href="https://github.com/aumcode/serbench" rel="noopener ugc nofollow" target="_blank">项目</a> <a class="ae jp" href="https://github.com/mtth/avsc/wiki/Benchmarks" rel="noopener ugc nofollow" target="_blank">都存在</a>没有附带文章。这适用于每一种语言，证明了性能对某些人有多重要。</p><p id="2bd8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，创建可重复的、一致的基准非常困难。这并不奇怪，正如Hanselman指出的，有许多因素需要控制:</p><ul class=""><li id="aec7" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">CPU关联性/进程优先级</li><li id="b264" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">测试机器上其他正在运行的进程</li><li id="5349" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">如果存在，处理垃圾收集而不扭曲结果</li><li id="d9d5" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">使用正确的时间测量通话</li><li id="72ca" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">正确使用测试中的框架/库</li><li id="3667" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">考虑结果异常值</li><li id="ed8a" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">以易于理解的方式显示结果</li></ul><p id="e9f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">可能还有其他一些我忽略的因素。毫不奇怪，许多现有的基准会因为缺少一点或多点而受到批评。让我们来看一些:</p><p id="9cdb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> GLD。SerializerBenchmark </strong></p><p id="ef58" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尽管它已经被<a class="ae jp" href="https://github.com/aumcode/serbench" rel="noopener ugc nofollow" target="_blank"> serbench，</a>取代，我还是想给它一些关注，因为它说明了很多疏漏，尽管乍一看它似乎是一个有价值的信息来源。</p><p id="1da5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你注意到GLD的第一件事。SerializerBenchmark是一个生成错误:</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff ke"><img src="../Images/5071e5f40a3285dbc259a53854c90f3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PLLZqtUto8Vd1HZ08k5wJQ.png"/></div></div></figure><p id="0d5e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这显然需要手动下载DLL，如代码中的<a class="ae jp" href="https://github.com/leo-gan/GLD.SerializerBenchmark/blob/2c8c6428684bf5ded1e16f6ee4289bf74a44322e/GLD.SerializerBenchmark/Serializers/ApJsonSerializer.cs#L2-L3" rel="noopener ugc nofollow" target="_blank">注释所述。解决这个问题，不要忘记输入“100”作为程序参数，正如在</a><a class="ae jp" href="http://geekswithblogs.net/LeonidGaneline/archive/2015/05/06/serializers-in-.net.-v.2.aspx" rel="noopener ugc nofollow" target="_blank">文章</a>中所述。这会产生以下输出:</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff kq"><img src="../Images/035cc5d10010d5271279d9863536bd7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZxVDwkpSMmdz-8zWqHGzDQ.png"/></div></div><figcaption class="kr ks fg fe ff kt ku bd b be z ek">Full output <a class="ae jp" href="https://gist.github.com/Oipo/9d9825d4df50a399497e747f03e933f0" rel="noopener ugc nofollow" target="_blank">here</a></figcaption></figure><p id="ca20" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如您所见，并非所有测试都成功运行。有大量的例外和检查是失败的，这使得其他基准之间的比较更加困难，甚至是它自己的基准。更不用说这篇文章没有给出完整的输出来进行比较。</p><p id="7e20" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了运行它的问题，我还注意到了几个测量问题:</p><ul class=""><li id="1fc4" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">它不设置CPU关联性，也不设置进程优先级</li><li id="5a9e" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">在<a class="ae jp" href="https://github.com/leo-gan/GLD.SerializerBenchmark/blob/2c8c6428684bf5ded1e16f6ee4289bf74a44322e/GLD.SerializerBenchmark/Serializers/JilSerializer.cs#L24-L26" rel="noopener ugc nofollow" target="_blank"> Jil序列化器</a>中，可以被默认的选项是done <a class="ae jp" href="https://github.com/Oipo/SerializerComparison/blob/7e8085e5bf290ff023f77dcf5fe86d42c5cbda80/SerializerComparison/Program.cs#L35" rel="noopener ugc nofollow" target="_blank">这里是</a>。</li><li id="c2d0" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">另外，在<a class="ae jp" href="https://github.com/leo-gan/GLD.SerializerBenchmark/blob/2c8c6428684bf5ded1e16f6ee4289bf74a44322e/GLD.SerializerBenchmark/Serializers/JilSerializer.cs#L22" rel="noopener ugc nofollow" target="_blank"> Jil序列化器中，</a>构造StreamWriter不是必需的，但是如果您需要它用于WebAPI之类的东西，它是受支持的</li><li id="b49f" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">尽管<a class="ae jp" href="https://github.com/leo-gan/GLD.SerializerBenchmark/blob/2c8c6428684bf5ded1e16f6ee4289bf74a44322e/GLD.SerializerBenchmark/ISerDeser.cs#L10" rel="noopener ugc nofollow" target="_blank">父类</a>包含一个可重写的初始化成员，但它实际上从未被重写，并且<a class="ae jp" href="https://github.com/leo-gan/GLD.SerializerBenchmark/blob/2c8c6428684bf5ded1e16f6ee4289bf74a44322e/GLD.SerializerBenchmark/Serializers/DataContractJsonSer.cs#L31" rel="noopener ugc nofollow" target="_blank">有时</a> <a class="ae jp" href="https://github.com/leo-gan/GLD.SerializerBenchmark/blob/2c8c6428684bf5ded1e16f6ee4289bf74a44322e/GLD.SerializerBenchmark/Serializers/DataContractSerializer.cs#L31" rel="noopener ugc nofollow" target="_blank">甚至</a> <a class="ae jp" href="https://github.com/leo-gan/GLD.SerializerBenchmark/blob/2c8c6428684bf5ded1e16f6ee4289bf74a44322e/GLD.SerializerBenchmark/Serializers/BondJsonSerializer.cs#L34" rel="noopener ugc nofollow" target="_blank">在序列化调用期间使用了</a>。Jil之类的序列化器使用大量反射，但只在第一次调用时使用，这使得initiliaze函数对于获得正确的结果至关重要。</li><li id="2d7f" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated"><a class="ae jp" href="https://github.com/leo-gan/GLD.SerializerBenchmark/blob/2c8c6428684bf5ded1e16f6ee4289bf74a44322e/GLD.SerializerBenchmark/Serializers/JsonNetSerializer.cs#L20" rel="noopener ugc nofollow" target="_blank"> NetJSON序列化程序</a>包含不必要的额外StringWriter</li><li id="68be" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">垃圾收集器<a class="ae jp" href="https://github.com/leo-gan/GLD.SerializerBenchmark/blob/2c8c6428684bf5ded1e16f6ee4289bf74a44322e/GLD.SerializerBenchmark/Tester.cs#L61-L72" rel="noopener ugc nofollow" target="_blank">没有在每次测试运行之间运行</a>，导致在关键代码执行期间可能的垃圾收集。</li><li id="fa0c" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">所有结果都是平均的，因此无法看出最小值和最大值是多少，也无法明显看出有多少测试落在某个范围内(即看有多少抖动)</li></ul><p id="5b95" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">中使用的序列化程序做了大量的工作。NET环境。但是我不相信这个基准能输出非常一致的测量结果。</p><p id="d374" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> Serbench </strong></p><p id="80c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">GLD。SerializerBenchmark的README指向了这个项目。然而，在撰写本文时，GLD项目的一些缺点似乎也存在于Serbench中。<a class="ae jp" href="https://github.com/aumcode/serbench/blob/4e7a0e7d64cd20c348bdfc4205691a63d61ddf76/Source/Serbench.Specimens/Serializers/JilSerializer.cs" rel="noopener ugc nofollow" target="_blank"> Jil序列化程序</a>包含相同的不必要的stringreader/writer，Jil仍未正确初始化，并且未设置CPU关联和进程优先级。</p><p id="f979" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它似乎在每次运行前收集垃圾，移除重复的StringWriter，在每次运行时给Jil一个新的Options对象，并添加Apolyton。FastJson引用直接放在存储库中。尽管如此，也没有提到已经进行了内存分析，以确定收集是专门诱导的还是在测试运行期间发生的。另外，serbench <a class="ae jp" href="https://github.com/aumcode/serbench/blob/4e7a0e7d64cd20c348bdfc4205691a63d61ddf76/Source/Serbench/TestingSystem.cs#L137" rel="noopener ugc nofollow" target="_blank">创建了一个额外的线程</a>来运行所有的测试，这让我觉得很奇怪。</p><p id="5f47" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，我无法让serbench工作。显然它需要一种叫做<a class="ae jp" href="https://github.com/aumcode/nfx" rel="noopener ugc nofollow" target="_blank"> NFX </a>的东西，这种东西能够将结果写入各种输出，比如RDBMS。看起来他们的目标是一个模拟并行运行的序列化程序的基准，应该比通常显示的合成基准更真实。虽然链式标杆管理肯定会很有趣，但我对他们试图证明什么持怀疑态度。将序列化器隔离在合成基准中使得它们很容易比较，但是一旦引入整个软件栈链，就必然会遇到每个人都有自己的组合的问题。很快，您将不得不创建一个包罗万象的基准测试套件，它可以在多个平台上运行，具有可插拔的框架和可插拔的序列化器。</p><p id="e43f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">诚然，我没有花太多的时间让它工作，但我希望能够打开项目，并按下开始，它应该工作。我希望他们将来会使它更容易使用。</p><p id="f53b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">简单速度测试</strong></p><p id="9e1c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然不是大量序列化程序的完整基准，但它提供了创建序列化程序的相对简单的设置。</p><p id="2ac5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/theburningmonk/SimpleSpeedTester/blob/develop/examples/JsonSerializersBenchmark/JsonSerializersSpeedTest.cs" rel="noopener ugc nofollow" target="_blank">其中一个例子</a>展示了如何使用它，在这个例子中，你可以看到它没有在GLD和塞尔本奇项目中发现的较小的疏漏。它只在必要的地方使用流，虽然不会比较有流和没有流的同一个库。它也做<a class="ae jp" href="https://github.com/theburningmonk/SimpleSpeedTester/blob/develop/src/SimpleSpeedTester/Core/Test.cs#L101" rel="noopener ugc nofollow" target="_blank">垃圾收集，</a>但是像GLD一样，它把所有的<a class="ae jp" href="https://github.com/theburningmonk/SimpleSpeedTester#getting-started" rel="noopener ugc nofollow" target="_blank">结果平均成一个数字</a>。</p><p id="cef5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然结果相当可信，但这里我也遗漏了CPU关联性和进程优先级。我可以看到这对于快速的一对一比较有效，但对于完整的基准测试套件无效。</p><p id="9195" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">更好的对比？</strong></p><p id="732d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我确信我还没有在。NET环境，我的时间毕竟有限。然而，我确实<a class="ae jp" href="https://github.com/Oipo/SerializerComparison" rel="noopener ugc nofollow" target="_blank">创建了一个项目</a>，它旨在以一种隔离的、合成的基准风格，为各种各样的序列化程序考虑尽可能多的因素。</p><p id="ae4a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">硬件&amp;软件</strong></p><p id="e1de" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在适当的基准测试中，为了最小化差异和增加可再现性，通常会陈述所使用的硬件和软件。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="fe ff kv"><img src="../Images/e86e3cde096e8d89c67ffd6afd64df4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*H4wlL2nUmZO68u77nKsouQ.png"/></div></figure><p id="cb18" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如你在这些截图中看到的，我在非超频的i5–4570上运行所有测试</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="fe ff kw"><img src="../Images/f2f431180465210b67bccc70c04122e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*uQAmlsg3djpT8EbnR305oA.png"/></div></figure><p id="ae5c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">具有8 GB的RAM，时钟/时序如下。</p><p id="df2e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">至于软件，我运行的是64位Windows 10 Professional，有最新的更新，关闭了除文件浏览器以外的所有应用程序，但禁用了自动更新和所有隐私敏感设置。我注意到，在后台下载和安装更新时，自动更新很容易占用您所有的磁盘I/O和一个完整的CPU内核。这对于基准测试来说是不可行的。</p><p id="b8e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我使用过Visual Studio 2017(不是更新版本)和。NET Framework 4.6.2来编译C#解决方案。</p><p id="1339" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有关C#中使用的库，请参见<a class="ae jp" href="https://github.com/Oipo/SerializerComparison/blob/7e8085e5bf290ff023f77dcf5fe86d42c5cbda80/SerializerComparison/packages.config" rel="noopener ugc nofollow" target="_blank"> packages.config </a>。</p><p id="a79a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于NodeJS，我使用的是7.7.4版本</p><p id="8304" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于C++我用的是Visual Studio 2017(不是更新版本)搭配麦片1.2.2(使用rapidjson和rapidxml)、protobuf 3.2.0(静态库可以在资源库上找到<a class="ae jp" href="https://github.com/Oipo/SerializerComparison/tree/7e8085e5bf290ff023f77dcf5fe86d42c5cbda80/CppSerializerComparison" rel="noopener ugc nofollow" target="_blank">)</a></p><p id="ef4a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">方法论</strong></p><p id="9ff3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">大多数其他基准测试所做的，是创建两个对象进行序列化和反序列化，连续运行多次，然后计算平均值。虽然这为您提供了所需总时间的表示，但它确实丢失了一些有价值的数据。</p><p id="d9b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于这个项目，我想创建一个中等大小的对象，分别测量序列化和反序列化，并将每次运行存储在一个测量列表中。这样我就可以创建一个<a class="ae jp" href="http://en.tradimo.com/tradipedia/ohlc-chart/" rel="noopener ugc nofollow" target="_blank"> OHLC图</a>。然而，我要改变各个点的定义。高和低将分别是测量的最高时间和最低时间，但开放点将是第20/100次测量，而关闭点将是第80/100次测量。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="fe ff kx"><img src="../Images/2c1a3e8d6ad93e97554ac7d38694e619.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*nw3_9PZEZI536iFnVbg2mA.png"/></div></figure><p id="e795" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在左边你可以看到一个重复250次的例子。最快的样本(L代表低电平)是2117 s，最慢的样本(H代表高电平)是2888 s。所有测量值都按从低到快的顺序排列。第20/100个测量值(O)是第50个测量值，即2117 s。第80/100个测量值(C)是第200个测量值，即2302 s。您可以看到大多数样本(其中的60%)都在2117–2302s范围内，只有几个异常值低于该范围，但有更多异常值高于该范围。</p><p id="ac11" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过这种方式，您可以了解库的抖动/一致性程度，并对库的性能有一个大致的了解。</p><p id="98c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，所有基准测试进程都将在CPU #0上运行(因此设置了CPU亲缘关系)，具有较高的进程优先级，并且将作为管理员运行，因此前两个设置可以由进程本身来完成。</p><p id="a155" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后一步，我将分析内存，看看垃圾收集是否严格地在我希望的时候发生，而不是在测试期间。</p><p id="a12f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的第一个测试将是在x86和x64上的各种设置中的Jil(正常、流、有和没有数据对象类的属性、有和没有选项)。</p><p id="0eab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的第二个测试是在x86和x64上用C#编写一些JSON序列化程序。</p><p id="a9db" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第三个测试是在x86和x64上用C#编写一些二进制序列化程序。</p><p id="9987" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的第三个测试将比较C#中的几个序列化器与C++和NodeJS中的序列化器。</p><p id="7c18" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">代码</strong></p><p id="f681" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了确保我做得正确，我想让你看一下我的一些代码。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="fe ff ky"><img src="../Images/b57ceebcf2bfc3451d26a14a61c6443f.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*R3c5Con_KvfAxcCgK6joBA.png"/></div></figure><p id="084d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">程序做的第一件事是设置亲和力和优先级。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="fe ff kz"><img src="../Images/de97d352a619da7f9c5fa27b56522e61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*YoKz-bEqrNPPYiG4LQMVgA.png"/></div><figcaption class="kr ks fg fe ff kt ku bd b be z ek">Full code <a class="ae jp" href="https://github.com/Oipo/SerializerComparison/blob/7e8085e5bf290ff023f77dcf5fe86d42c5cbda80/SerializerComparison/TestRunner.cs#L48-L62" rel="noopener ugc nofollow" target="_blank">here</a></figcaption></figure><p id="2683" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是用于运行单个测量的代码。。NET 4.6引入了GC。TryStartNoGCRegion函数，它允许您告诉垃圾收集器预分配内存，并告诉它在结束该区域之前不要运行垃圾收集。我尝试在调用动作前<a class="ae jp" href="https://github.com/Oipo/SerializerComparison/blob/7e8085e5bf290ff023f77dcf5fe86d42c5cbda80/SerializerComparison/TestRunner.cs#L23" rel="noopener ugc nofollow" target="_blank">分配1M </a>。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="fe ff la"><img src="../Images/68ca79d7a167afddea6a05893b8f90c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/1*cixEvljKMjINOrjK52jDIw.png"/></div><figcaption class="kr ks fg fe ff kt ku bd b be z ek">Full code <a class="ae jp" href="https://github.com/Oipo/SerializerComparison/blob/7e8085e5bf290ff023f77dcf5fe86d42c5cbda80/SerializerComparison/TestRunner.cs#L74-L84" rel="noopener ugc nofollow" target="_blank">here</a></figcaption></figure><p id="ce04" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每次测试都是预热，所以我们不测量冷启动时间。然后测试运行250次重复，这是<a class="ae jp" href="https://github.com/Oipo/SerializerComparison/blob/7e8085e5bf290ff023f77dcf5fe86d42c5cbda80/SerializerComparison/TestRunner.cs#L24" rel="noopener ugc nofollow" target="_blank">硬编码的</a>。从技术上讲，这是所有测试中唯一被抛弃的“度量”。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="fe ff lb"><img src="../Images/e0f02b0a7ea898c49e254ad78b3bdb78.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*napYMyoSTT8l0cEG6nOLiA.png"/></div><figcaption class="kr ks fg fe ff kt ku bd b be z ek">Full code <a class="ae jp" href="https://github.com/Oipo/SerializerComparison/blob/7e8085e5bf290ff023f77dcf5fe86d42c5cbda80/SerializerComparison/TestRunner.cs#L343-L369" rel="noopener ugc nofollow" target="_blank">here</a></figcaption></figure><p id="18a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于所有测试，我创建了一个包含1000个文档的对象。我试图给出一个代表性的对象，包含日期时间，UTF-8字符串和一个整数。我意识到更多的组合是可能的，但我不确定它们是否会增加很多。</p><p id="ac23" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然，具体的操作有一些变化，例如当需要流时，或者当在运行测试之前将预先加载了json/xml/binary内容的特定文件读入内存时，或者当库需要不同类型的人员/文档时，但是这是所有类型的基本结构。</p><p id="b4e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">结果—测试#1 </strong></p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff lc"><img src="../Images/aae0f0a8fa427d502bd9ba5ad0d50b0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gTaFj1zArsm66J5t7RoBhg.png"/></div></div><figcaption class="kr ks fg fe ff kt ku bd b be z ek">Click for bigger view. Ser = Serialization test, Des = Deserialization test, StrSer = Stream Serialization, StrDes = Stream Deserialization, x86 run, be aware of the Y-axis not starting at 0</figcaption></figure><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff ld"><img src="../Images/39e831db8fcfef2b649e5e5053d479e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*seyTVfvi-yWROSEil0QOpA.png"/></div></div><figcaption class="kr ks fg fe ff kt ku bd b be z ek">Click for bigger view. Ser = Serialization test, Des = Deserialization test, StrSer = Stream Serialization, StrDes = Stream Deserialization, x64 run, be aware of the Y-axis not starting at 0</figcaption></figure><p id="fbfe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我很抱歉没有让Y轴从0开始，我正在使用<a class="ae jp" href="https://lvcharts.net/" rel="noopener ugc nofollow" target="_blank">实时图表，</a>，我还没有找到如何改变这一点。如果你知道怎么做，请告诉我！</p><p id="6835" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您在这些图中看到的第一件事是Jil快速且一致，尤其是对于JSON序列化程序。大多数呼叫都在1毫秒以下。一致性可能是由于速度快，我们将在接下来的测试中看到。其次，流序列化减慢了它的速度，但stringwriter显然加快了它的速度。第三,“With Attributes”意味着数据对象是用类的DataContract和Serializable属性创建的。但是实际发生的情况是Jil无法识别一些DataContract属性，这导致datetimes没有被序列化/反序列化。所以你在图中看到的加速完全归因于此。最后，有流的反序列化比没有流的要慢得多，这是一个遗憾。将Jil与WebAPI一起使用时，使用流API而不是直接版本。</p><p id="f36f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个概要文件将在最后，因为所有的结果都来自于一次基准测试。</p><p id="1a7f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">结果—测试#2 </strong></p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff le"><img src="../Images/a1e43514457c9ce3d72926c69db8d8f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J3TPRn9LbYpgauvTLuV1ww.png"/></div></div><figcaption class="kr ks fg fe ff kt ku bd b be z ek">Click for bigger view. Ser = Serialization test, Des = Deserialization test, StrSer = Stream Serialization, StrDes = Stream Deserialization, x86 run, be aware of the Y-axis not starting at 0</figcaption></figure><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff le"><img src="../Images/9f09514e40f046a162d8d4af96d04350.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pEZT6RNFD8bfflpvOy9nSQ.png"/></div></div><figcaption class="kr ks fg fe ff kt ku bd b be z ek">Click for bigger view. Ser = Serialization test, Des = Deserialization test, StrSer = Stream Serialization, StrDes = Stream Deserialization, x64 run, be aware of the Y-axis not starting at 0</figcaption></figure><p id="07be" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是开始变得有趣的地方！GLD的发现之一。SerializerBenchmark是NetJSON比Jil快——但不是在这个基准中！除了x64序列化，Jil要快得多。即使在x64序列化的情况下，NetJSON也要快大约75秒，而在x64反序列化的情况下，NetJSON每次调用要慢374秒。</p><p id="7f63" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">纽顿软件。JSON比Jil和NetJSON慢2-3倍，但是真正慢的是DataContractJsonSerializer反序列化器，它带有。NET框架。它比Jil和NetJSON慢6-8倍，也是所有框架中最不一致的。我不知道为什么。</p><p id="f103" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">结果—测试#3 </strong></p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff lf"><img src="../Images/7b7f9000fcaf3506d3fbeb8c3bbf97c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mk5uF1lBn5tQmynNV9WgXg.png"/></div></div><figcaption class="kr ks fg fe ff kt ku bd b be z ek">Click for bigger view. Ser = Serialization test, Des = Deserialization test, StrSer = Stream Serialization, StrDes = Stream Deserialization, x86 run, be aware of the Y-axis not starting at 0</figcaption></figure><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff lg"><img src="../Images/c8dfda4e00dd11268601a789376efae2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VroCtB-kD1u-aL6cKW3ScA.png"/></div></div><figcaption class="kr ks fg fe ff kt ku bd b be z ek">Click for bigger view. Ser = Serialization test, Des = Deserialization test, StrSer = Stream Serialization, StrDes = Stream Deserialization, x64 run, be aware of the Y-axis not starting at 0</figcaption></figure><p id="ae91" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如我所料，二进制序列化程序甚至比JSON序列化程序更快。毕竟，他们不需要解析文本。但我真正感到惊讶的是，ZeroFormatter的速度如此之快。它在github上的大胆声明确实不是谎言。比Hyperion(Wire的继任者)和protobuf都快。</p><p id="08f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你将Hyperion或Protobuf与Jil或NetJSON进行比较，你不会发现太多的速度差异——至少在C#中是这样。MsgPack有点慢，但你真的想避开BinaryFormatter。</p><p id="79b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">结果—测试#4 </strong></p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff lh"><img src="../Images/49dc6004ee89c0b9a7431527b04a6346.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yt2pUywt4vy8-f4yTZH0Xg.png"/></div></div><figcaption class="kr ks fg fe ff kt ku bd b be z ek">Click for bigger view. Ser = Serialization test, Des = Deserialization test, StrSer = Stream Serialization, StrDes = Stream Deserialization, C++ x64 run, be aware of the Y-axis not starting at 0</figcaption></figure><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff li"><img src="../Images/01977ef39f74d32221012708c7a45136.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d_y3W3jlbsOLlaQePjBbUg.png"/></div></div><figcaption class="kr ks fg fe ff kt ku bd b be z ek">Click for bigger view. Ser = Serialization test, Des = Deserialization test, StrSer = Stream Serialization, StrDes = Stream Deserialization, c++ x64 run</figcaption></figure><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff lj"><img src="../Images/65399d7357d5eeaa0a1dfbd4b9a5623b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DeTeBvj-ZCcxtNmsFMRaKA.png"/></div></div><figcaption class="kr ks fg fe ff kt ku bd b be z ek">Click for bigger view. Ser = Serialization test, Des = Deserialization test, StrSer = Stream Serialization, StrDes = Stream Deserialization, nodejs x64 run, be aware of the Y-axis not starting at 0</figcaption></figure><p id="519a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这最后三张图是关于C++、C++和Node中的序列化器。JS分别。</p><p id="b400" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">关于第一幅图，有趣的是，我曾期望C++中的JSON和XML序列化比C#中的要快。但不知何故，谷类JSON序列化和DataContractJsonSerializer反序列化一样慢。不过，反序列化的速度非常快。我不确定我是发现了性能缺陷还是做错了什么。这就是为什么在第二张图中，我去掉了JSON和XML，我发现Protobuf在C++中确实更快。然而更重要的是，因为C++没有额外的垃圾收集指标，所以结果非常一致。第二张图可能看起来和C#一样不稳定，但实际上都在几百秒之内。</p><p id="2a4d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第三个也是最后一个图是一对节点的结果。JS序列化程序。当然是默认的一个和一对声称更快的情侣。不过，我想我可能会在js中处理一些获得准确时间的问题。节点。JS支持hrtime，应该是准确的，但还是我的结果到处都是。我不确定我是否能调用节点。JS基准准确。</p><p id="6c19" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">结果—分析</strong></p><p id="2800" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了确保我的C#基准测试不会受到垃圾收集的阻碍，我做了一个内存分析。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff lk"><img src="../Images/0391354a4b3adfab2adcfcca013f8021.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rgAYRR2kRFinZiECO4Z6FQ.png"/></div></div><figcaption class="kr ks fg fe ff kt ku bd b be z ek">Garbage Collection</figcaption></figure><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="fe ff ll"><img src="../Images/ca88220a9054e93b5f325f3cb6b55fdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*-szJIym3-uLeExWCAaRIvw.png"/></div><figcaption class="kr ks fg fe ff kt ku bd b be z ek">Garbage Collection</figcaption></figure><p id="41fa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如您所看到的，垃圾收集只发生在GC。调用Collect()。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff lm"><img src="../Images/aa87b345ffeab51ccdecb1ed2c0cc0ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zp95MTX_JriRk4cWpKsqTg.png"/></div></div><figcaption class="kr ks fg fe ff kt ku bd b be z ek">CPU Profile</figcaption></figure><p id="8672" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在CPU配置文件中，大部分时间花在一些P/Invoke上。我大胆猜测，这是我正在做的垃圾收集器的事情，因为一个GC。每4毫秒收集一次。否则，CPU时间将用于序列化库。</p><p id="7eba" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">原始测量可以在这里找到:<a class="ae jp" href="https://github.com/Oipo/SerializerComparison/blob/7e8085e5bf290ff023f77dcf5fe86d42c5cbda80/measurements-csharp-x86.txt" rel="noopener ugc nofollow" target="_blank"> C# x86 </a>、<a class="ae jp" href="https://github.com/Oipo/SerializerComparison/blob/7e8085e5bf290ff023f77dcf5fe86d42c5cbda80/measurements-csharp-x64.txt" rel="noopener ugc nofollow" target="_blank"> C# x64 </a>、<a class="ae jp" href="https://github.com/Oipo/SerializerComparison/blob/7e8085e5bf290ff023f77dcf5fe86d42c5cbda80/measurements-cpp.txt" rel="noopener ugc nofollow" target="_blank"> C++ </a>和<a class="ae jp" href="https://github.com/Oipo/SerializerComparison/blob/7e8085e5bf290ff023f77dcf5fe86d42c5cbda80/measurements-nodejs.txt" rel="noopener ugc nofollow" target="_blank">节点。JS </a>。</p><p id="80ea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">结论</strong></p><p id="bacd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这篇(相当长的)文章中，我已经展示了大多数基准在进行度量时会遗漏一些步骤，正确地进行度量是困难的，并且二进制序列化肯定比JSON序列化快。</p><p id="fd91" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">毫无疑问，我没有使用任何你将在软件中使用的数据对象进行测试，但我认为可以肯定地说，Jil和NetJSON是我为C#测试的最快的JSON序列化程序，而ZeroFormatter无疑是我测试的最快的二进制序列化程序。</p><p id="55fa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是如果你真的真的想要每盎司的性能，你仍然必须使用C++，或其他静态编译语言。</p><p id="7b77" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你已经坚持到现在——感谢你的阅读！我希望你和我做这个的时候一样开心。如果你有任何问题，不要犹豫问。</p><div class="kf kg kh ki fq ab cb"><figure class="ln kj lo lp lq lr ls paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="ln kj lo lp lq lr ls paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="ln kj lo lp lq lr ls paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="lt lu lv"><p id="f922" class="ir is lw it b iu iv iw ix iy iz ja jb lx jd je jf ly jh ji jj lz jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is lw it b iu iv iw ix iy iz ja jb lx jd je jf ly jh ji jj lz jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff ma"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>