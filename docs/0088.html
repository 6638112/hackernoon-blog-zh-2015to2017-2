<html>
<head>
<title>Implicit conversions in Scala for C# developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向C#开发人员的Scala隐式转换</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/implicit-conversions-in-scala-for-c-developers-92ea6c7902fa?source=collection_archive---------1-----------------------#2015-11-05">https://medium.com/hackernoon/implicit-conversions-in-scala-for-c-developers-92ea6c7902fa?source=collection_archive---------1-----------------------#2015-11-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="6a89" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我认识的许多学习Scala的人中，隐含性已经成为一个困扰的话题。来自<em class="jp">。NET </em>和<em class="jp"> C# </em>很难将这两种语言之间的<em class="jp">隐式</em>术语联系起来。</p><h1 id="8b5b" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">C#隐式转换</h1><p id="2851" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">正如<em class="jp">MSDN</em>T10】页所说</p><blockquote class="ku kv kw"><p id="5f15" class="ir is jp it b iu iv iw ix iy iz ja jb kx jd je jf ky jh ji jj kz jl jm jn jo hn dt translated"><em class="hu">implicit关键字用于声明隐式用户定义类型转换运算符。如果保证转换不会导致数据丢失，则使用它来启用用户定义类型和另一种类型之间的隐式转换。</em></p></blockquote><p id="8c9e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">基本上，我们将一种数据类型转换成另一种数据类型，保留信息，并且不使用<em class="jp">转换</em>。例如，下一个示例显示了这些转换是如何进行的。</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="fcfa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个特性提高了代码的可读性，因为自定义转换是以自然的方式发生的，我们避免了强制转换，同时保持代码足够干净。</p><h1 id="8e42" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">Scala隐式转换</h1><p id="71f5" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在Scala中，<em class="jp">隐式转换</em>与<em class="jp"> C# </em>基本相同，只是有一些语法差异。</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="0a78" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里我们看到了两种语言是如何解决相同的转换问题的，但是关于Scala <em class="jp">隐式</em>还有一些我们可以利用的东西，这也是让一些来自C#的开发人员感到困惑的地方。</p><h1 id="5761" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">类型扩展</h1><p id="148f" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在C#中，我们能够扩展类型，而无需创建新的派生类型。我们可以使用语言的<em class="jp">类型扩展</em>或<em class="jp">方法扩展</em>构造来避免原始类型的重新编译过程及其修改。</p><p id="077d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们看看这是如何在C#中实现的</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="812f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这里，我们扩展了类型<em class="jp"> int </em>并添加了方法<em class="jp"> plus </em>，这样我们就可以这样做:</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="00a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就可扩展性和灵活性而言，这个特性非常有用。有些<em class="jp">API</em>真的很难使用，因为它们原本不打算供其他人使用，而能够扩展它们的类型让我们能够控制第三方<em class="jp">程序集</em>。</p><p id="3aa1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Scala中，我们有同样的功能，但是正如前面提到的，一些来自C#世界的人理解起来有问题。我们可以在Scala中使用相同的<em class="jp">隐式</em>来解决C#中<em class="jp">方法扩展</em>解决的相同问题。</p><p id="375b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们假设我们想用与C#相同的方式从Scala中扩展Int类型。事情是这样的。</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="a494" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们明确一下，<em class="jp">加</em>方法有显式声明的返回类型，因为它是公共API方法，所以如果Scala中的<em class="jp">类型推理系统</em>发生变化，应该声明返回类型以避免冲突。</p><p id="631b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在最后一个例子中，我们做了与C#中相同的事情。我们基本上已经定义了扩展<em class="jp"> Int </em>类型的方法，但是为了使用它，我们需要<em class="jp">改变</em>类型。为了实现这一目标，我们:</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="22ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">重要的是要注意，当返回<em class="jp">扩展</em>类时，我们省略了<em class="jp"> new </em>关键字，因为<em class="jp">扩展</em>是一个<em class="jp"> case </em>类。</p><p id="7189" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们可以像在C#中一样使用这个扩展。</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="abec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Scala <em class="jp">隐式</em>的这种用法可能会导致很多你以前没有见过的问题。大概<em class="jp">改变类型</em>的常见用法是每个人都能理解的，但是在Scala中捕捉这个用例需要更深的语言知识，当来自其他语言时，比如C#。</p><h1 id="7b53" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">Scala中伴随对象的注释</h1><p id="def5" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">这超出了我们的主题，但是我认为谈论它是一个好主意，因为它在Scala语言中很重要。这将让每个人更好地理解我的上一个例子，我们在创建一个<em class="jp"> IntExtensions </em>实例时完全忽略了<em class="jp"> new </em>关键字。</p><p id="33a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Scala中有一个构造叫做<em class="jp">伴随对象</em>。它基本上定义了一种创建特定类型的新实例的便捷方式。</p><p id="7285" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们再次定义<em class="jp">扩展</em>类，但这次不是作为<em class="jp"> case </em>类。</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="102e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了<em class="jp"> case </em>关键字之外，这个定义看起来和上一个非常接近。现在，为了创建这个类的新实例，我们需要做</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="065f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每次都是。如果我们能做到</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="149c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">相反。有一种很容易实现的方法。让我们看看它是如何完成的。</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="cd47" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里我们声明了一个与<em class="jp">扩展</em>同名的<em class="jp">对象</em>，它有一个名为<em class="jp"> apply </em>的函数，并返回实际的<em class="jp">扩展</em>实例。这两个扩展<em class="jp">扩展</em>和它的伙伴<em class="jp">对象</em>需要一起定义才能工作。现在我们可以这样做。</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="0ccf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个定义和以前一样，但是记住<em class="jp"> IntExtensions </em>类不再是<em class="jp"> case </em>类，所以我们需要<em class="jp"> new </em>关键字来创建它的实例。正在发生的情况是，当请求一个实例时，来自<em class="jp">扩展</em>伴随对象的<em class="jp">应用</em>函数被调用。</p><p id="54e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个特性让我们可以在Scala中编写非常简洁的代码，尤其是在系统中使用通用类型的时候，比如创建列表。</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="3ff2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">而不是做</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="5d35" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尽管这看起来很愚蠢，但当代码变得复杂时，它确实很有帮助，Python编程语言就是一个例子。</p><p id="4917" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">C#语言还没有这个特性，但是为了赶上市场，微软编程语言中加入了大量的新特性。</p><p id="cb86" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我希望这个关于<em class="jp">隐式</em>的解释可以帮助其他来自微软世界的人像我一样享受其他编程语言。</p><blockquote class="ku kv kw"><p id="9f44" class="ir is jp it b iu iv iw ix iy iz ja jb kx jd je jf ky jh ji jj kz jl jm jn jo hn dt translated"><a class="ae kt" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kt" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kt" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae kt" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is jp it b iu iv iw ix iy iz ja jb kx jd je jf ky jh ji jj kz jl jm jn jo hn dt translated">要了解更多信息，<a class="ae kt" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">请阅读我们的“关于”页面</a>，<a class="ae kt" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae kt" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is jp it b iu iv iw ix iy iz ja jb kx jd je jf ky jh ji jj kz jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kt" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kt" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>