<html>
<head>
<title>Tutorial: Setting up Node.js with a database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">教程:使用数据库设置Node.js</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/setting-up-node-js-with-a-database-part-1-3f2461bdd77f?source=collection_archive---------0-----------------------#2017-05-07">https://medium.com/hackernoon/setting-up-node-js-with-a-database-part-1-3f2461bdd77f?source=collection_archive---------0-----------------------#2017-05-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="61e5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我本可以将本教程命名为“用MySQL设置Node.js ”,但是我想让这个名称更具包容性，因为我认为对于大多数应用程序来说，MySQL是Node.js的最佳选择</p><p id="d8a8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">MySQL已经存在了21年，所以在早期的Node.js应用中，它经常被一些新的闪亮的NoSQL选择所忽略，比如MongoDB。然而，事后看来，MongoDB更多的是炒作，而不是实质，并且因为一些主要的安全问题和性能问题而众所周知。不信的话，<a class="ae jp" href="https://hn.algolia.com/?query=mongodb&amp;sort=byPopularity&amp;prefix&amp;page=0&amp;dateRange=all&amp;type=story" rel="noopener ugc nofollow" target="_blank">搜索“MongoDB”</a>黑客新闻。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/74bddcc2cf0d70ff80a236f012901a92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S5rN4F-qhr1-x4FD9jSLqg.png"/></div></div></figure><p id="d473" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你想要一个数据库，<a class="ae jp" href="http://blog.wix.engineering/2015/12/10/scaling-to-100m-mysql-is-a-better-nosql/" rel="noopener ugc nofollow" target="_blank">甚至NoSQL </a>，MySQL是一个很好的选择。它有强大的支持，体面的性能，并有一些伟大的NPM模块接口。此外，几乎所有东西都有MySQL适配器。</p><p id="3afc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本教程中，我将展示如何使用<a class="ae jp" href="http://knexjs.org/" rel="noopener ugc nofollow" target="_blank"> Knex </a>设置MySQL和Node，以便创建一个用于创建和登录用户的粗糙应用程序。</p><p id="62cb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将</p><ul class=""><li id="b68f" class="kc kd hu it b iu iv iy iz jc ke jg kf jk kg jo kh ki kj kk dt translated">安装Node.js</li><li id="3f79" class="kc kd hu it b iu kl iy km jc kn jg ko jk kp jo kh ki kj kk dt translated">安装MySQL</li><li id="bbff" class="kc kd hu it b iu kl iy km jc kn jg ko jk kp jo kh ki kj kk dt translated">创建一个HTTP API来写入数据库</li><li id="4f74" class="kc kd hu it b iu kl iy km jc kn jg ko jk kp jo kh ki kj kk dt translated">创建一些HTML和JS来发布到API</li><li id="5521" class="kc kd hu it b iu kl iy km jc kn jg ko jk kp jo kh ki kj kk dt translated">使用Knex迁移来创建用户数据库模式(类似于Rails迁移的过程)</li><li id="933a" class="kc kd hu it b iu kl iy km jc kn jg ko jk kp jo kh ki kj kk dt translated">使用迁移来设置密码哈希</li><li id="83da" class="kc kd hu it b iu kl iy km jc kn jg ko jk kp jo kh ki kj kk dt translated">创建一个登录路由来检查哈希工作</li></ul><p id="069d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在下一个教程中，我们将为应用程序添加更多功能，并探索一些更复杂的查询。最终我们会在某个地方部署这个应用程序。</p><h1 id="53c3" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">安装Node.js</h1><p id="08ec" class="pw-post-body-paragraph ir is hu it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">如果您已经完成了前面的教程，您可能已经安装了Node，因此可以跳过这一节。</p><p id="3f73" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将使用NVM来管理节点，以便我们可以轻松地安装和切换不同的版本。</p><p id="7092" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在安装NVM之前，确保您的主目录中有一个<code class="eh lt lu lv lw b">.bashrc</code>文件(即使该文件是空的)。</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="dfd2" class="mb kr hu lw b fv mc md l me mf">touch ~/.bashrc</span></pre><p id="cfc4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要安装NVM，只需运行此命令(与NVM安装说明相同)。</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="8de6" class="mb kr hu lw b fv mc md l me mf">curl -o- <a class="ae jp" href="https://raw.githubusercontent.com/creationix/nvm/v0.32.1/install.sh" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/creationix/nvm/v0.32.1/install.sh</a> | bash</span></pre><p id="fb22" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个命令从远程URL下载一个脚本并运行它。</p><p id="6e8f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你现在有NVM了！但是如果你运行<code class="eh lt lu lv lw b">nvm ls</code>，你会发现它没有被找到。这是因为NVM给你的<code class="eh lt lu lv lw b">~/.bashrc</code>增加了一些代码。这个文件是一个特殊的文件，在您每次登录到您的实例时都会运行，因此要让NVM运行，您可以注销并再次登录。然而，您可以使用<code class="eh lt lu lv lw b">source</code>命令手动运行该文件。</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="1975" class="mb kr hu lw b fv mc md l me mf">source ~/.bashrc</span></pre><p id="1e8a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在运行<code class="eh lt lu lv lw b">nvm ls</code>工作了！但是没有安装任何节点版本！要获得最新版本，只需<code class="eh lt lu lv lw b">nvm install &lt;latest version number&gt;</code>。</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="1d7a" class="mb kr hu lw b fv mc md l me mf">nvm install 7</span></pre><p id="09f8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您已经安装了节点！通过查看版本来检查它是否存在</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="9cd6" class="mb kr hu lw b fv mc md l me mf">node --version</span></pre><h1 id="7f81" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">安装MySQL</h1><p id="c5fa" class="pw-post-body-paragraph ir is hu it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">如果你用的是Mac，应该用<a class="ae jp" href="http://brew.sh/" rel="noopener ugc nofollow" target="_blank">自制</a>安装MySQL。如果你使用的是另一个平台，只需谷歌一下类似“在我的平台上安装MySQL”的说明。</p><p id="7fb6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在mac上安装家酿软件，在终端上运行</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="5465" class="mb kr hu lw b fv mc md l me mf">/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span></pre><p id="531a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦安装，更新家酿和安装MySQL</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="26d8" class="mb kr hu lw b fv mc md l me mf">brew update<br/>brew install mysql</span></pre><p id="de51" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">运行MySQL守护进程</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="2a62" class="mb kr hu lw b fv mc md l me mf">brew services start mysql</span></pre><p id="f0aa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本地为MySQL设置一个基本的密码，没有必要担心安全性，因为它只能从您的机器上访问(我使用的是“密码”)。</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="b13a" class="mb kr hu lw b fv mc md l me mf">mysqladmin -u root password 'password'</span></pre><p id="2b70" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦安装并运行，MySQL就可以被本地运行的任何应用程序访问。</p><p id="d434" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本教程中，我们将使用<a class="ae jp" href="https://www.sequelpro.com/" rel="noopener ugc nofollow" target="_blank"> Sequel Pro </a>来管理我们的数据库。<a class="ae jp" href="https://sequelpro.com/download#auto-start" rel="noopener ugc nofollow" target="_blank">下载安装Sequel Pro </a>并打开。要连接的数据库位于本地主机上，因此将“主机”设置为“127.0.0.1”。用户名是“root ”,密码与上一步选择的相同，对我来说是“密码”。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/81da59b80427c5a36232080fa7ffae81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wSgaDmauCW4WSJ2ekJnpbw.png"/></div></div></figure><p id="2fb5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">连接，你会看到一个空的MySQL。如果连接不成功，请确保您在上一步中正确修改了密码，并且<code class="eh lt lu lv lw b">mysql</code>服务仍在运行。</p><p id="d449" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">成功连接后，点击数据库&gt;添加数据库并命名，我选择的名字是“tutorial _ node _ Database”(MySQL命名约定是snake_case)。</p><div class="jr js jt ju fq ab cb"><figure class="mg jv mh mi mj mk ml paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><img src="../Images/ea69e0bf40ef787edbbc0078814930d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*EBYxsLrginQkguoE7FRTjA.png"/></div></figure><figure class="mg jv mm mi mj mk ml paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><img src="../Images/037323f1cdd53ab91e68486e6c772f2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*jzV_YdeszInbgQl-Ht5U7Q.png"/></div></figure></div><p id="e0ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">太好了，MySQL已经准备好了！</p><h1 id="fce2" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">项目设置</h1><p id="6490" class="pw-post-body-paragraph ir is hu it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">我已经将整个项目添加到<a class="ae jp" href="https://github.com/roberttod/tutorial-node-database" rel="noopener ugc nofollow" target="_blank">一个公共的github repo </a>中，并且我已经将每个步骤分解为一个提交，所以应该很容易理解。这只是作为一种帮助，我们将从头开始创建项目，所以没有必要克隆代码。</p><p id="59c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们从一个新的目录开始，我将这个项目命名为<code class="eh lt lu lv lw b">tutorial-node-database</code>。运行以下命令创建文件结构。</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="194d" class="mb kr hu lw b fv mc md l me mf">mkdir tutorial-node-database<br/>cd tutorial-node-database</span><span id="8266" class="mb kr hu lw b fv mn md l me mf">touch knexfile.js<br/>touch index.js<br/>touch store.js</span><span id="2f0d" class="mb kr hu lw b fv mn md l me mf">mkdir public<br/>touch public/index.html<br/>touch public/app.js</span><span id="f6a9" class="mb kr hu lw b fv mn md l me mf"># choose all defaults when prompted<br/>npm init</span></pre><p id="3a60" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们正在使用Knex和MySQL，并使用express创建一个小API，所以你需要安装<code class="eh lt lu lv lw b">knex</code>和<code class="eh lt lu lv lw b">express</code>。我们还将使用<code class="eh lt lu lv lw b">body-parser</code>模块。</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="b62d" class="mb kr hu lw b fv mc md l me mf">npm i knex mysql express body-parser --save</span></pre><p id="121a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lt lu lv lw b">knex</code>也应该全球安装</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="4ce9" class="mb kr hu lw b fv mc md l me mf">npm i knex -g</span></pre><p id="0ecf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当创建一个新的项目，我喜欢添加一个最小的。gitignore file，这样我可以轻松地检查所有内容，而不包括MacOS喜欢创建的<code class="eh lt lu lv lw b">node_modules</code>文件夹或<code class="eh lt lu lv lw b">.DS_Store</code>文件。</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="7037" class="mb kr hu lw b fv mc md l me mf">printf "node_modules\n.DS_Store" &gt; .gitignore</span></pre><p id="d626" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您不理解上面的bash代码，也不用担心。它所做的就是将<code class="eh lt lu lv lw b">node_modules</code>后接换行符<code class="eh lt lu lv lw b">\n</code>后接<code class="eh lt lu lv lw b">.DS_Store</code>放入一个名为<code class="eh lt lu lv lw b">.gitignore</code>的文件中。如果对你来说更简单的话，使用编辑器来做这种事情是完全合理的。</p><h1 id="c7f5" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">HTTP API</h1><p id="b81b" class="pw-post-body-paragraph ir is hu it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">我们将从一个简单的express应用程序开始，服务于公共目录，用一个<code class="eh lt lu lv lw b">/createUser</code>端点将一些数据写入数据库。</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="760f" class="mb kr hu lw b fv mc md l me mf">const express = require('express')<br/>const bodyParser = require('body-parser')</span><span id="bc5c" class="mb kr hu lw b fv mn md l me mf">const store = require('./store')</span><span id="fe69" class="mb kr hu lw b fv mn md l me mf">const app = express()<br/>app.use(<!-- -->express.static('public')<!-- -->)<br/>app.use(bodyParser.json())<br/>app.post('/createUser', (req, res) =&gt; {<br/>  store<br/>    .createUser({<br/>      username: req.body.username,<br/>      password: req.body.password<br/>    })<br/>    .then(() =&gt; res.sendStatus(200))<br/>})</span><span id="d918" class="mb kr hu lw b fv mn md l me mf">app.listen(7555, () =&gt; {<br/>  console.log('Server running on <a class="ae jp" href="http://localhost:7555')" rel="noopener ugc nofollow" target="_blank">http://localhost:7555')</a><br/>})</span></pre><p id="e621" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">将此保存到<code class="eh lt lu lv lw b">index.js</code>。当我们运行这个文件时，服务器将在<a class="ae jp" href="http://localhost:7555')" rel="noopener ugc nofollow" target="_blank"> http://localhost:7555 </a>上监听对<code class="eh lt lu lv lw b">/createUser</code>的POST请求，并将这些请求传递给存储文件。然后，服务器将使用200状态代码进行响应(200是每个HTTP服务器用来表示请求成功的代码)。</p><p id="b259" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">目前，我们将模拟商店，以检查我们的API是否有效。</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="4cc5" class="mb kr hu lw b fv mc md l me mf">module.exports = {<br/>  createUser ({ username, password }) {<br/>    console.log(`Add user ${username} with password ${password}`)<br/>    return Promise.resolve()<br/>  }<br/>}</span></pre><p id="fd24" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">将此保存到<code class="eh lt lu lv lw b">store.js</code>。请注意，<code class="eh lt lu lv lw b">addLog</code>函数返回一个承诺，这样您就知道什么时候完成了。如果这里承诺的使用有点令人困惑，可能值得查看一些承诺教程，它们是现代Javascript中的一个基本概念。</p><p id="d834" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，让我们写一个简单的<code class="eh lt lu lv lw b">index.html</code>，包括<code class="eh lt lu lv lw b">app.js</code>。我们在HTML的底部添加了<code class="eh lt lu lv lw b">app.js</code>而不是<code class="eh lt lu lv lw b">head</code>，这样我们就可以轻松地查询脚本上面的元素，而不需要使用像<code class="eh lt lu lv lw b">jQuery.ready</code>或<code class="eh lt lu lv lw b">DOMContentLoaded</code>事件这样的东西来等待它们加载。</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="f421" class="mb kr hu lw b fv mc md l me mf">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;<br/>  &lt;title&gt;Node database tutorial&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>  &lt;form class="CreateUser"&gt;<br/>    &lt;h1&gt;Create a new user&lt;/h1&gt;<br/>    &lt;input type="text" class="username" placeholder="username"&gt;<br/>    &lt;input type="password" class="password" placeholder="password"&gt;<br/>    &lt;input type="submit" value="Create user"&gt;<br/>  &lt;/form&gt;<br/>  &lt;script src="/app.js"&gt;&lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="5b73" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lt lu lv lw b">app.js</code>脚本应该看起来像下面这样，并且将用于命中服务器的<code class="eh lt lu lv lw b">/createUser</code>端点。</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="3076" class="mb kr hu lw b fv mc md l me mf">const CreateUser = document.querySelector('.CreateUser')<br/>CreateUser.addEventListener('submit', (e) =&gt; {<br/>  e.preventDefault()<br/>  const username = CreateUser.querySelector('.username').value<br/>  const password = CreateUser.querySelector('.password').value<br/>  post('/createUser', { username, password })<br/>})</span><span id="2db0" class="mb kr hu lw b fv mn md l me mf">function post (path, data) {<br/>  return window.fetch(path, {<br/>    method: 'POST',<br/>    headers: {<br/>      'Accept': 'application/json',<br/>      'Content-Type': 'application/json'<br/>    },<br/>    body: JSON.stringify(data)<br/>  })<br/>}</span></pre><p id="0d66" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">将此保存到<code class="eh lt lu lv lw b">public/app.js</code>并启动您的服务器。</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="da65" class="mb kr hu lw b fv mc md l me mf">node .</span></pre><p id="9cbd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您的服务器应该在<a class="ae jp" href="http://localhost:7555/" rel="noopener ugc nofollow" target="_blank"> http://localhost:7555/ </a>上启动。转到此链接，当您单击“创建用户”时，您将能够在网络面板中看到创建用户请求。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mo"><img src="../Images/a32dd840c90b21c0f42f9eac54417f75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H4sJEHR_9AywUFbhcgF_UA.png"/></div></div></figure><p id="cc01" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">检查你的终端是否有来自<code class="eh lt lu lv lw b">store.js</code>的<code class="eh lt lu lv lw b">console.log</code>。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/f43eea55b1f659ad15e4444bf39604ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*JV49x8TQMPGDXEIAAEnvyA.png"/></div></figure><p id="45eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果使用git，这是提交代码的好时机。</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="4dd6" class="mb kr hu lw b fv mc md l me mf"># An empty first commit is nice<br/>git commit --allow-empty -m "( ͡° ͜ʖ ͡°)"</span><span id="9c6d" class="mb kr hu lw b fv mn md l me mf">git add .<br/>git commit -m "Setup server with mock store"</span></pre><h1 id="c837" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">设置knex</h1><p id="0312" class="pw-post-body-paragraph ir is hu it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">让我们设置<code class="eh lt lu lv lw b">knexfile.js</code>来连接数据库。</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="fbd2" class="mb kr hu lw b fv mc md l me mf">module.exports = {<br/>  client: 'mysql',<br/>  connection: {<br/>    user: 'root',<br/>    password: 'password',<br/>    database: 'tutorial_node_database'<br/>  }<br/>}</span></pre><p id="10ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我已经使用默认凭证本地连接到MySQL，如果您的凭证不同，您可能需要更改它。</p><p id="71d4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于本教程，我们需要一个带有用户名和密码的用户表。这些都需要在schema中定义。为了创建或修改模式，我们将使用Knex迁移。</p><p id="6c98" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">创建一个新的迁移，并将其命名为有意义的名称</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="44a2" class="mb kr hu lw b fv mc md l me mf">knex migrate:make create_user_table</span></pre><p id="b603" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将创建一个类似于<code class="eh lt lu lv lw b">migrations/20170504155313_create_user_table.js</code>的文件。文件名是当前日期时间，后跟您指定的名称。datetime使文件系统中的迁移文件保持有序，便于您按时间顺序阅读。</p><p id="1100" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每当我们需要添加、删除或修改一个表或列来改变数据的表示方式时，我们都会编写一个新的迁移文件。这使我们能够</p><ul class=""><li id="9e70" class="kc kd hu it b iu iv iy iz jc ke jg kf jk kg jo kh ki kj kk dt translated">以编程的方式进行模式更改，可以签入git并进行检查(比直接使用MySQL更新模式好得多)</li><li id="6d79" class="kc kd hu it b iu kl iy km jc kn jg ko jk kp jo kh ki kj kk dt translated">创建模式更新的历史记录</li><li id="16d1" class="kc kd hu it b iu kl iy km jc kn jg ko jk kp jo kh ki kj kk dt translated">使用JS而不是SQL来转换值(能够使用项目内部的NPM模块和函数)</li><li id="a243" class="kc kd hu it b iu kl iy km jc kn jg ko jk kp jo kh ki kj kk dt translated">让所有项目协作者的数据库模式保持最新，他们可以运行最新的迁移来获得最新的更改</li><li id="47a9" class="kc kd hu it b iu kl iy km jc kn jg ko jk kp jo kh ki kj kk dt translated">部署代码更改时更新临时数据库和生产数据库</li><li id="f35a" class="kc kd hu it b iu kl iy km jc kn jg ko jk kp jo kh ki kj kk dt translated">回滚架构更改</li></ul><p id="130f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">创建的文件包含导出一个<code class="eh lt lu lv lw b">up</code>方法和<code class="eh lt lu lv lw b">down</code>方法的代码。我们将在<code class="eh lt lu lv lw b">down</code>方法(迁移时使用)中创建我们的表模式，并在<code class="eh lt lu lv lw b">up</code>方法(回滚时)中删除它。</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="31e6" class="mb kr hu lw b fv mc md l me mf">exports.up = function (knex) {<br/>  return knex.schema.createTable('user', function (t) {<br/>    t.increments('id').primary()<br/>    t.string('username').notNullable()<br/>    t.string('password').notNullable()<br/>    t.timestamps(false, true)<br/>  })<br/>}</span><span id="e328" class="mb kr hu lw b fv mn md l me mf">exports.down = function (knex) {<br/>  return knex.schema.dropTableIfExists('user')<br/>}</span></pre><p id="9a61" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Knex的API非常简单，<a class="ae jp" href="http://knexjs.org/" rel="noopener ugc nofollow" target="_blank">文档也非常容易阅读</a>。认识到Knex实际上是从您发出的调用中构造SQL是很重要的。尽管您使用的是JavaScript API，但是许多查询都是在考虑底层SQL的情况下构建的，这对于查询性能和优化非常重要。</p><p id="9351" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意，我们在这里添加了一个会自动递增的<code class="eh lt lu lv lw b">id</code>字段，以及使用<code class="eh lt lu lv lw b">t.timestamps</code>方法的<code class="eh lt lu lv lw b">updated_at</code>和<code class="eh lt lu lv lw b">created_at</code>字段。</p><p id="5d98" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要运行此迁移</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="8290" class="mb kr hu lw b fv mc md l me mf">knex migrate:latest</span></pre><p id="1c30" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">检查SequelPro以查看具有指定模式的新表</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mq"><img src="../Images/86ecb3a6e577d18caa552b88f6c165ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rEmp2G3YHUBMQ3YFUZ6qcQ.png"/></div></div></figure><p id="047c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们有了一个表，我们可以编辑store.js，以便它将数据写入表中。</p><h1 id="579b" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">使用Knex.js写入数据</h1><p id="a95c" class="pw-post-body-paragraph ir is hu it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">我们需要我们的商店做的就是使用<code class="eh lt lu lv lw b">knexfile.js</code>配置加载knex，然后每当发出<code class="eh lt lu lv lw b">createUser</code>请求时将数据写入<code class="eh lt lu lv lw b">user</code>表。</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="ce87" class="mb kr hu lw b fv mc md l me mf">const knex = require('knex')(require('./knexfile'))</span><span id="a7b0" class="mb kr hu lw b fv mn md l me mf">module.exports = {<br/>  createUser ({ username, password }) {<br/>    console.log(`Add user ${username} with password ${password}`)<br/>    return knex('user').insert({<br/>      username,<br/>      password<br/>    })<br/>  }<br/>}</span></pre><p id="80d9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">重启你的服务器，浏览到<a class="ae jp" href="http://localhost:7555/" rel="noopener ugc nofollow" target="_blank"> http://localhost:7555/ </a>创建一个用户。如果你去Sequel Pro，你应该看到新用户出现在数据库中。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mr"><img src="../Images/2d17eb2ddf4bdfa4e804ee3a643c4bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IBtzF7kDmGMOnEfplM2tXw.png"/></div></div></figure><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="45bc" class="mb kr hu lw b fv mc md l me mf">git add .<br/>git commit -m "Setup knex"</span></pre><h1 id="e2f9" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">安全存储密码</h1><p id="f77f" class="pw-post-body-paragraph ir is hu it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">在继续下一步之前，让我们确保密码在数据库中是加密的。使用数据库迁移的灵活性非常方便。</p><p id="80a8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了安全地存储密码，您希望为每个新用户创建一个随机的salt，并使用crypto来加密密码(这是标准的做法，可以防止在数据库受损的情况下泄露用户的密码)。</p><p id="dcba" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在迁移之前，让我们将加密逻辑添加到store.js文件中</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="4f7e" class="mb kr hu lw b fv mc md l me mf">const crypto = require('crypto')<br/>const knex = require('knex')(require('./knexfile'))</span><span id="e2f5" class="mb kr hu lw b fv mn md l me mf">module.exports = {<br/>  saltHashPassword,<br/>  createUser ({ username, password }) {<br/>    console.log(`Add user ${username}`)<br/>    const { salt, hash } = saltHashPassword(password)<br/>    return knex('user').insert({<br/>      salt,<br/>      encrypted_password: hash,<br/>      username<br/>    })<br/>  }<br/>}</span><span id="da12" class="mb kr hu lw b fv mn md l me mf">function saltHashPassword (password) {<br/>  const salt = randomString()<br/>  const hash = crypto<br/>    .createHmac('sha512', salt)<br/>    .update(password)<br/>  return {<br/>    salt,<br/>    hash: hash.digest('hex')<br/>  }<br/>}</span><span id="0fed" class="mb kr hu lw b fv mn md l me mf">function randomString () {<br/>  return crypto.randomBytes(4).toString('hex')<br/>}</span></pre><p id="246a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意<code class="eh lt lu lv lw b">crypto</code>是一个本地节点模块，不需要使用<code class="eh lt lu lv lw b">npm</code>安装。</p><p id="40dd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们创建一个迁移文件</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="e475" class="mb kr hu lw b fv mc md l me mf">knex migrate:make encrypt_user_password</span></pre><p id="62c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于迁移，我们将添加<code class="eh lt lu lv lw b">encrypted_password</code>和<code class="eh lt lu lv lw b">salt</code>列，然后我们将借用从<code class="eh lt lu lv lw b">store.js</code>导出的<code class="eh lt lu lv lw b">saltHashPassword</code>方法来迁移数据库中已经存在的用户。最后，我们将删除<code class="eh lt lu lv lw b">password</code>列。</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="d02a" class="mb kr hu lw b fv mc md l me mf">const { saltHashPassword } = require('../store')</span><span id="d840" class="mb kr hu lw b fv mn md l me mf">exports.up = function up (knex) {<br/>  return knex.schema<br/>    .table('user', t =&gt; {<br/>      t.string('salt').notNullable()<br/>      t.string('encrypted_password').notNullable()<br/>    })<br/>    .then(() =&gt; knex('user'))<br/>    .then(users =&gt; Promise.all(users.map(convertPassword)))<br/>    .then(() =&gt; {<br/>      return knex.schema.table('user', t =&gt; {<br/>        t.dropColumn('password')<br/>      })<br/>    })</span><span id="c199" class="mb kr hu lw b fv mn md l me mf">  function convertPassword (user) {<br/>    const { salt, hash } = saltHashPassword(user.password)<br/>    return knex('user')<br/>      .where({ id: user.id })<br/>      .update({<br/>        salt,<br/>        encrypted_password: hash<br/>      })<br/>  }<br/>}</span><span id="8193" class="mb kr hu lw b fv mn md l me mf">exports.down = function down (knex) {<br/>  return knex.schema.table('user', t =&gt; {<br/>    t.dropColumn('salt')<br/>    t.dropColumn('encrypted_password')<br/>    t.string('password').notNullable()<br/>  })<br/>}</span></pre><p id="4191" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们无法在down函数中恢复原来的密码，因为它是加密的，因此我们只能尽最大努力将模式恢复原样。</p><p id="bce6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里使用了大量的承诺，这在编写迁移时很常见。使用async/await，我们可以大大简化这段代码。</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="6295" class="mb kr hu lw b fv mc md l me mf">const { saltHashPassword } = require('../store')</span><span id="467f" class="mb kr hu lw b fv mn md l me mf">exports.up = async function up (knex) {<br/>  await knex.schema.table('user', t =&gt; {<br/>    t.string('salt').notNullable()<br/>    t.string('encrypted_password').notNullable()<br/>  })<br/>  const users = await knex('user')<br/>  await Promise.all(users.map(convertPassword))<br/>  await knex.schema.table('user', t =&gt; {<br/>    t.dropColumn('password')<br/>  })</span><span id="293b" class="mb kr hu lw b fv mn md l me mf">  function convertPassword (user) {<br/>    const { salt, hash } = saltHashPassword(user.password)<br/>    return knex('user')<br/>      .where({ id: user.id })<br/>      .update({<br/>        salt,<br/>        encrypted_password: hash<br/>      })<br/>  }<br/>}</span><span id="420a" class="mb kr hu lw b fv mn md l me mf">exports.down = function down (knex) {<br/>  return knex.schema.table('user', t =&gt; {<br/>    t.dropColumn('salt')<br/>    t.dropColumn('encrypted_password')<br/>    t.string('password').notNullable()<br/>  })<br/>}</span></pre><p id="75ec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您想使用async await，请确保您拥有最新的节点版本(它最近才得到支持)</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="9087" class="mb kr hu lw b fv mc md l me mf">nvm i 7</span></pre><p id="5027" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">安装新的节点版本时，请注意需要重新安装全局软件包。</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="2f5b" class="mb kr hu lw b fv mc md l me mf">npm i knex -g</span></pre><p id="75de" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们运行迁移并检查它是否工作。</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="0ce4" class="mb kr hu lw b fv mc md l me mf">knex migrate:latest</span></pre><p id="c0d9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果一切顺利，你的密码应该已经加密了。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff ms"><img src="../Images/eaaef20d00573c6b7eac9de0498b710b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8aF3WdFdTt9Zi6PsSNLKLg.png"/></div></div></figure><p id="49c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">重新启动服务器和创建新用户应该加密密码。转到<a class="ae jp" href="http://localhost:7555/" rel="noopener ugc nofollow" target="_blank"> http://localhost:7555/ </a>并创建更多用户来检查它的工作情况。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mt"><img src="../Images/ab88d31fea964c92c6d5a20895f854f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9-B5maFSPM4zhVMtzdcPrw.png"/></div></div></figure><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="192f" class="mb kr hu lw b fv mc md l me mf">git add .<br/>git commit -m "Encrypt passwords"</span></pre><h1 id="ab2f" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">添加登录路径</h1><p id="22c1" class="pw-post-body-paragraph ir is hu it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">此时，让我们安装<code class="eh lt lu lv lw b">nodemon</code>以便在我们进行更改时自动重启服务器。</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="0128" class="mb kr hu lw b fv mc md l me mf">npm i -g nodemon</span></pre><p id="1e4d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在使用nodemon而不是node运行服务器</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="10ff" class="mb kr hu lw b fv mc md l me mf">nodemon .</span></pre><p id="3a77" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下次我们进行更改时，服务器将为我们重新启动。通常您会让它运行，然后在新的终端选项卡中运行bash操作。</p><p id="1335" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了对用户进行身份验证，我们创建了一个<code class="eh lt lu lv lw b">/login</code>路由，它使用用户名和密码调用商店的<code class="eh lt lu lv lw b">authenticate</code>方法。</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="b55e" class="mb kr hu lw b fv mc md l me mf">const express = require('express')<br/>const bodyParser = require('body-parser')<br/>const store = require('./store')<br/>const app = express()</span><span id="fdd5" class="mb kr hu lw b fv mn md l me mf">app.use(express.static('public'))<br/>app.use(bodyParser.json())</span><span id="0ff9" class="mb kr hu lw b fv mn md l me mf">app.post('/createUser', (req, res) =&gt; {<br/>  store<br/>    .createUser({<br/>      username: req.body.username,<br/>      password: req.body.password<br/>    })<br/>    .then(() =&gt; res.sendStatus(200))<br/>})<br/>app.post('/login', (req, res) =&gt; {<br/>  store<br/>    .authenticate({<br/>      username: req.body.username,<br/>      password: req.body.password<br/>    })<br/>    .then(({ success }) =&gt; {<br/>      if (success) res.sendStatus(200)<br/>      else res.sendStatus(401)<br/>    })<br/>})</span><span id="cfbc" class="mb kr hu lw b fv mn md l me mf">app.listen(7555, () =&gt; {<br/>  console.log('Server running on <a class="ae jp" href="http://localhost:7555'" rel="noopener ugc nofollow" target="_blank">http://localhost:7555'</a>)<br/>})</span></pre><p id="2ad0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果认证成功，我们用200响应，否则我们用401(未授权)响应。</p><p id="1929" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在商店中，我们需要获取用户的salt，用它来加密密码，然后对照数据库中的<code class="eh lt lu lv lw b">encrypted_password</code>进行检查。</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="ec96" class="mb kr hu lw b fv mc md l me mf">const crypto = require('crypto')<br/>const knex = require('knex')(require('./knexfile'))</span><span id="c56a" class="mb kr hu lw b fv mn md l me mf">module.exports = {<br/>  createUser ({ username, password }) {<br/>    console.log(`Add user ${username}`)<br/>    const { salt, hash } = saltHashPassword({ password })<br/>    return knex('user').insert({<br/>      salt,<br/>      encrypted_password: hash,<br/>      username<br/>    })<br/>  },<br/>  authenticate ({ username, password }) {<br/>    console.log(`Authenticating user ${username}`)<br/>    return knex('user').where({ username })<br/>      .then(([user]) =&gt; {<br/>        if (!user) return { success: false }<br/>        const { hash } = saltHashPassword({<br/>          password,<br/>          salt: user.salt<br/>        })<br/>        return { success: hash === user.encrypted_password }<br/>      })<br/>  }<br/>}</span><span id="6b75" class="mb kr hu lw b fv mn md l me mf">function saltHashPassword ({<br/>  password,<br/>  salt = randomString()<br/>}) {<br/>  const hash = crypto<br/>    .createHmac('sha512', salt)<br/>    .update(password)<br/>  return {<br/>    salt,<br/>    hash: hash.digest('hex')<br/>  }<br/>}</span><span id="9442" class="mb kr hu lw b fv mn md l me mf">function randomString () {<br/>  return crypto.randomBytes(4).toString('hex')<br/>}</span></pre><p id="263a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还修改了<code class="eh lt lu lv lw b">saltHashPassword</code>函数来接受salt，如果没有提供salt，就只生成一个。</p><p id="9dcd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，我们在这里更改了函数声明，因此第一个参数现在是一个对象。我们可以很容易地将hash作为第二个参数传入，但是传递options对象是一个很好的做法，因为这样可以更清楚地看到函数调用中发生了什么。</p><p id="5d73" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，考虑一下如果<code class="eh lt lu lv lw b">saltHashPassword</code>出现在文件的底部，或者被抽象到另一个文件中。哪个称呼更容易理解？</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="f308" class="mb kr hu lw b fv mc md l me mf">// using two arguments<br/>saltHashPassword('some password', '239ab09')</span><span id="8310" class="mb kr hu lw b fv mn md l me mf">// using an options argument<br/>saltHashPassword({<br/>  password: 'some password',<br/>  salt: '239ab09'<br/>})</span></pre><p id="ed4d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在调用中包含参数名称是很好的。</p><p id="677d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了调用<code class="eh lt lu lv lw b">/login</code>，让我们向<code class="eh lt lu lv lw b">index.html</code>文件添加一个登录表单。</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="5ef4" class="mb kr hu lw b fv mc md l me mf">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;<br/>  &lt;title&gt;Node database tutorial&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>  &lt;form class="Login"&gt;<br/>    &lt;h1&gt;Login&lt;/h1&gt;<br/>    &lt;input type="text" class="username" placeholder="username"&gt;<br/>    &lt;input type="password" class="password" placeholder="password"&gt;<br/>    &lt;input type="submit" value="Login"&gt;<br/>  &lt;/form&gt;<br/>  &lt;form class="CreateUser"&gt;<br/>    &lt;h1&gt;Create account&lt;/h1&gt;<br/>    &lt;input type="text" class="username" placeholder="username"&gt;<br/>    &lt;input type="password" class="password" placeholder="password"&gt;<br/>    &lt;input type="submit" value="Create"&gt;<br/>  &lt;/form&gt;<br/>  &lt;script src="/app.js"&gt;&lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="7cca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们向<code class="eh lt lu lv lw b">app.js</code>添加逻辑来调用登录端点</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="682e" class="mb kr hu lw b fv mc md l me mf">const CreateUser = document.querySelector('.CreateUser')<br/>CreateUser.addEventListener('submit', (e) =&gt; {<br/>  e.preventDefault()<br/>  const username = CreateUser.querySelector('.username').value<br/>  const password = CreateUser.querySelector('.password').value<br/>  post('/createUser', { username, password })<br/>})</span><span id="9316" class="mb kr hu lw b fv mn md l me mf">const Login = document.querySelector('.Login')<br/>Login.addEventListener('submit', (e) =&gt; {<br/>  e.preventDefault()<br/>  const username = Login.querySelector('.username').value<br/>  const password = Login.querySelector('.password').value<br/>  post('/login', { username, password })<br/>    .then(({ status }) =&gt; {<br/>      if (status === 200) alert('login success')<br/>      else alert('login failed')<br/>    })<br/>})</span><span id="4d52" class="mb kr hu lw b fv mn md l me mf">function post (path, data) {<br/>  return window.fetch(path, {<br/>    method: 'POST',<br/>    headers: {<br/>      'Accept': 'application/json',<br/>      'Content-Type': 'application/json'<br/>    },<br/>    body: JSON.stringify(data)<br/>  })<br/>}</span></pre><p id="2e28" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过检查状态，我们现在能够判断用户是否通过了身份验证。</p><div class="jr js jt ju fq ab cb"><figure class="mg jv mu mi mj mk ml paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><img src="../Images/08058b8ecffec5b56afefa765abe521e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*Z-B1dpszDlxgk2iu7KewZQ.png"/></div></figure><figure class="mg jv mv mi mj mk ml paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><img src="../Images/14bf3fd1f00f619256493debfd8e2186.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*ZuAVkCp8Mqxpk2U_K64F8w.png"/></div></figure></div><p id="8a06" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不错！</p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="9145" class="mb kr hu lw b fv mc md l me mf">git add .<br/>git commit -m "Login route"</span></pre><h1 id="31b9" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">检查SQL</h1><p id="69c6" class="pw-post-body-paragraph ir is hu it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">在结束之前，让我们先来看看一些正在运行的SQL查询。为了将Knex查询记录到控制台，只需在查询链中添加一个<code class="eh lt lu lv lw b">.debug()</code>。</p><p id="474d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，在<code class="eh lt lu lv lw b">store.js</code>中，您可以将它添加到<code class="eh lt lu lv lw b">createUser</code></p><pre class="jr js jt ju fq lx lw ly lz aw ma dt"><span id="7f6d" class="mb kr hu lw b fv mc md l me mf">knex('user').insert({<br/>  salt,<br/>  encrypted_password: hash,<br/>  username<br/>}).debug()</span></pre><p id="14ef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，当调用这个方法时，您将看到控制台的SQL输出。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mw"><img src="../Images/427e87b1600c1468d64ff596dbbc82f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aW1GcKeO3xd6GaI1tiSGRQ.png"/></div></div></figure><p id="81ea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过查看sql键并用bindings数组中的值替换<code class="eh lt lu lv lw b">?</code>值，您可以重建Knex为添加用户而运行的底层SQL查询。</p><h1 id="6a4d" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">结论</h1><p id="42bc" class="pw-post-body-paragraph ir is hu it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">在本教程中，我们创建了一个使用Node + Knex + MySQL创建和登录用户的粗糙应用程序。在下一个教程中，我们将为应用程序添加更多功能，并探索一些更复杂的查询。</p><p id="a4b1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我希望展示我们如何通过远程数据库将应用程序部署到EC2。</p><p id="d833" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你喜欢这个教程，那么你可能想看看我以前的几个教程</p><ul class=""><li id="ed03" class="kc kd hu it b iu iv iy iz jc ke jg kf jk kg jo kh ki kj kk dt translated"><a class="ae jp" href="https://hackernoon.com/tutorial-creating-and-managing-a-node-js-server-on-aws-part-1-d67367ac5171" rel="noopener ugc nofollow" target="_blank">https://hacker noon . com/tutorial-creating-and-managing-a-node-js-server-on-AWS-part-1-d 67367 AC 5171</a></li><li id="9a6e" class="kc kd hu it b iu kl iy km jc kn jg ko jk kp jo kh ki kj kk dt translated"><a class="ae jp" href="https://hackernoon.com/tutorial-creating-and-managing-a-node-js-server-on-aws-part-2-5fbdea95f8a1" rel="noopener ugc nofollow" target="_blank">https://hacker noon . com/tutorial-creating-and-managing-a-node-js-server-on-AWS-part-2-5 fbde a95 F8 a 1</a></li></ul><div class="jr js jt ju fq ab cb"><figure class="mg jv mx mi mj mk ml paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mg jv mx mi mj mk ml paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mg jv mx mi mj mk ml paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="my mz na"><p id="f922" class="ir is nb it b iu iv iw ix iy iz ja jb nc jd je jf nd jh ji jj ne jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is nb it b iu iv iw ix iy iz ja jb nc jd je jf nd jh ji jj ne jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff nf"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ng nh l"/></div></figure></div></div>    
</body>
</html>