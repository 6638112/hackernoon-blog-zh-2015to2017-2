<html>
<head>
<title>Testing PostgreSQL for Fun</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试PostgreSQL的乐趣</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/testing-postgresql-for-fun-af891047e5fc?source=collection_archive---------4-----------------------#2017-06-19">https://medium.com/hackernoon/testing-postgresql-for-fun-af891047e5fc?source=collection_archive---------4-----------------------#2017-06-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/9d60ae5909716f6c6e1cb988f6060ce8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CExBnxXIerv7o8OJl-1VsQ.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Image copyright Lucina Lubin</figcaption></figure><h1 id="2d16" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">当编程不好玩的时候</h1><p id="be67" class="pw-post-body-paragraph ke kf hu kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">当迭代循环很长时，编程会变得令人沮丧。</p><p id="df45" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">假设您必须更改一个缺乏直接测试方法的底层系统。为了测试新代码，您必须手动执行一系列复杂、耗时且繁琐的步骤。当出现问题时，您所知道的要么是您的代码被破坏(由于某种未知的原因)，要么是您暴露了依赖于您的更改的巨大系统中的现有问题。更糟糕的是，代码不能以可重复的方式进行测试，并且每次运行都会得到不同的行为。</p><p id="d55b" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">如果这还不够令人沮丧的话，想象一下您无法实现您设想的解决方案。您不能直接访问低级系统，因为一系列组件——旨在抽象、简化和创建低级系统的安全替代方案——挡道。这些组件很少实现它们的既定目标，但是会迫使你的最终设计比必要的更慢更复杂。</p><p id="b776" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">最后，您了解到您正在测试的开发环境在关键的、重要的方面与生产的行为不匹配。</p><p id="720b" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">这就是为许多网站编写<a class="ae lh" href="https://hackernoon.com/tagged/database" rel="noopener ugc nofollow" target="_blank">数据库</a>查询的感觉。一点都不好玩。让我们解决这个问题。</p><p id="9476" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">在这篇文章中，我将展示如何通过使用使测试变得容易的包来使数据库编程变得有趣。我将介绍一个用PostgreSQL构建持久队列的例子。</p><h1 id="57f3" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">隔离的临时数据库</h1><p id="90d6" class="pw-post-body-paragraph ke kf hu kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">为了让数据库编程变得有趣，我们需要一种快速迭代的方法。我们需要打开数据库的实例，在我的例子中是PostgreSQL，并直接测试我们正在编写的查询。</p><p id="b79b" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">一个极好的选择是<code class="eh li lj lk ll b"><a class="ae lh" href="http://ephemeralpg.org/" rel="noopener ugc nofollow" target="_blank">pg_tmp</a></code>。我将利用我编写的名为<code class="eh li lj lk ll b"><a class="ae lh" href="http://hackage.haskell.org/package/tmp-postgres" rel="noopener ugc nofollow" target="_blank">tmp-postgres</a></code>的Haskell模拟，以及基于它的测试助手:<code class="eh li lj lk ll b"><a class="ae lh" href="http://hackage.haskell.org/package/hspec-pg-transact" rel="noopener ugc nofollow" target="_blank">hspec-pg-transact</a></code>。</p><p id="476f" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated"><code class="eh li lj lk ll b"><a class="ae lh" href="http://hackage.haskell.org/package/hspec-pg-transact" rel="noopener ugc nofollow" target="_blank">hspec-pg-transact</a></code>提供了一个助手来设置一个测试套件，该套件创建一个临时的<code class="eh li lj lk ll b">postgres</code>流程。测试可以使用可选的<code class="eh li lj lk ll b"><a class="ae lh" href="https://hackage.haskell.org/package/hspec-pg-transact-0.1.0.0/docs/Test-Hspec-DB.html#v:itDB" rel="noopener ugc nofollow" target="_blank">itDB</a></code>，它添加一个测试并运行用于测试的db事务。</p><p id="b24b" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">下面是一个用临时数据库测试db查询的简单示例。</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="089f" class="lu jh hu ll b fv lv lw l lx ly">describeDB<!-- --> migrate "Query” $ <br/>  <!-- -->itDB<!-- --> "work" $ do<br/>    <a class="ae lh" href="https://hackage.haskell.org/package/pg-transact-0.1.0.1/docs/Database-PostgreSQL-Transact.html#v:execute_" rel="noopener ugc nofollow" target="_blank">execute_</a> [<a class="ae lh" href="https://hackage.haskell.org/package/postgresql-simple-0.5.0.0/candidate/docs/Database-PostgreSQL-Simple-SqlQQ.html" rel="noopener ugc nofollow" target="_blank">sql</a>| <br/>      INSERT INTO things <br/>      VALUES (‘me’) |]<br/>    <a class="ae lh" href="https://hackage.haskell.org/package/pg-transact-0.1.0.1/docs/Database-PostgreSQL-Transact.html#v:query_" rel="noopener ugc nofollow" target="_blank">query_</a> [sql| <br/>      SELECT name <br/>      FROM things |]<br/>      `<a class="ae lh" href="https://hackage.haskell.org/package/hspec-expectations-lifted-0.10.0/docs/Test-Hspec-Expectations-Lifted.html#v:shouldReturn" rel="noopener ugc nofollow" target="_blank">shouldReturn</a>` [Only "me"]</span></pre><p id="fc8f" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">(你需要确保<code class="eh li lj lk ll b">initdb</code>在<code class="eh li lj lk ll b">PATH</code>上。macOS上的<code class="eh li lj lk ll b">brew</code>就是这种情况，但是对于Ubuntu，你必须在<code class="eh li lj lk ll b">PATH</code>上加上<code class="eh li lj lk ll b">/usr/lib/postgresql/VERSION/bin</code></p><p id="4217" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">完整的代码，包括导入语句，在这里是<a class="ae lh" href="https://gist.github.com/jfischoff/15af9f2460e5a15d23e2eb1361535bb9" rel="noopener ugc nofollow" target="_blank"/>。让我们看一个更大的例子。</p><h1 id="f236" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">制作postgresql简单队列</h1><p id="f4d7" class="pw-post-body-paragraph ke kf hu kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">在我之前的一篇文章中，我讨论了一个用于发送电子邮件的内存队列。正如凯尔·吉巴德指出的，排队的问题在于它不耐用。然而，PostgreSQL是持久的，所以让我们像Cale那样使用它来创建队列。</p><p id="f4f2" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">我们将用<code class="eh li lj lk ll b">enqueueDB</code>添加新的有效载荷。<code class="eh li lj lk ll b">tryLockDB</code>会抓取最新的有效载荷给我们处理。一旦处理完成，我们将调用有效载荷上的<code class="eh li lj lk ll b">dequeueDB</code>:</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="336a" class="lu jh hu ll b fv lv lw l lx ly">data Payload = Payload<br/>  { pId         :: PayloadId<br/>  , pValue      :: Value<br/>  , pState      :: State<br/>  , pCreatedAt  :: UTCTime<br/>  , pModifiedAt :: UTCTime<br/>  } deriving (Show, Eq)</span><span id="8c5e" class="lu jh hu ll b fv lz lw l lx ly">enqueueDB :: Value -&gt; DB PayloadId<br/>enqueueDB value = do<br/>  pid &lt;- liftIO randomIO<br/>  execute <br/>    [sql| INSERT INTO payloads <br/>          (id, value) VALUES (?, ?)<br/>    |]<br/>    (pid, value)<br/>  return $ PayloadId pid</span><span id="c887" class="lu jh hu ll b fv lz lw l lx ly">tryLockDB :: DB (Maybe Payload)<br/>tryLockDB = listToMaybe &lt;$&gt; query_<br/>  [sql| UPDATE payloads<br/>        SET state='locked'<br/>        WHERE id in<br/>          ( SELECT id<br/>            FROM payloads<br/>            WHERE state='enqueued'<br/>            ORDER BY created_at ASC<br/>            LIMIT 1<br/>          )<br/>        RETURNING id, value, state, <br/>                  created_at, <br/>                  modified_at<br/>  |]</span><span id="02e6" class="lu jh hu ll b fv lz lw l lx ly">dequeueDB :: PayloadId -&gt; DB ()<br/>dequeueDB payloadId = void $ execute<br/>  [sql| UPDATE payloads<br/>        SET state='dequeued'<br/>        WHERE id=?<br/>  |]<br/>  payloadId</span></pre><p id="b076" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">所有操作都发生在一个<code class="eh li lj lk ll b"><a class="ae lh" href="http://hackage.haskell.org/package/pg-transact-0.1.0.0/docs/Database-PostgreSQL-Transact.html#t:DB" rel="noopener ugc nofollow" target="_blank">DB</a></code> monad中，因此我们可以将它们与其他db操作组合在一起，并让它们在同一个事务中运行。例如，我们可以使用这个库来<code class="eh li lj lk ll b">enqueueDB</code>并在单个事务中创建一个客户。</p><h1 id="6ddf" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">回到测试</h1><p id="cb08" class="pw-post-body-paragraph ke kf hu kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">我们可以利用<code class="eh li lj lk ll b"><a class="ae lh" href="http://hackage.haskell.org/package/hspec-pg-transact" rel="noopener ugc nofollow" target="_blank">hspec-pg-transact</a></code>来编写我们的测试:</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="3bd0" class="lu jh hu ll b fv lv lw l lx ly">main :: IO ()<br/>main = hspec spec</span><span id="4fa5" class="lu jh hu ll b fv lz lw l lx ly">spec :: Spec<br/>spec = describeDB init "Queue" $ do<br/>  itDB "empty gives nothing" $ do<br/>    tryLockDB <br/>      `shouldReturn` Nothing</span><span id="bea5" class="lu jh hu ll b fv lz lw l lx ly">  itDB "enqueue/lock/dequeue" $ do<br/>    theId &lt;- enqueueDB $ String "!"<br/>    Just Payload {..} &lt;- tryLockDB</span><span id="05f5" class="lu jh hu ll b fv lz lw l lx ly">    pId `shouldBe` theId<br/>    pValue `shouldBe` String "!"<br/>    tryLockDB <br/>      `shouldReturn` Nothing</span><span id="fac7" class="lu jh hu ll b fv lz lw l lx ly">    dequeueDB pId `shouldReturn` ()<br/>    tryLockDB <br/>      `shouldReturn` Nothing</span></pre><p id="57c2" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">我们可以加载我们的单个测试文件<code class="eh li lj lk ll b"><a class="ae lh" href="https://github.com/jfischoff/postgresql-queue/blob/master/test/Database/PostgreSQL/Simple/QueueSpec.hs" rel="noopener ugc nofollow" target="_blank">test/Database/QueueSpec.hs</a></code>，并单独运行它:</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="dc94" class="lu jh hu ll b fv lv lw l lx ly">&gt; :l test/Database/QueueSpec.hs<br/>&gt; :main --match=locks<br/>Database.Queue<br/>postgresql:///test?host=/tmp/tmp-postgres26345&amp;port=57473</span><span id="efaa" class="lu jh hu ll b fv lz lw l lx ly">empty locks nothing<br/>enqueue/lock/dequeue<br/>Shutting Down</span><span id="7ca5" class="lu jh hu ll b fv lz lw l lx ly">Finished in 1.8647 seconds<br/>2 examples, 0 failures</span></pre><p id="f138" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">在单元测试的世界里，两秒钟并不算多，但是对于数据库测试来说，我们做得很好。不仅测试速度快，而且我们还可以通过重新加载和重新运行单个文件来快速迭代，所有这些都在个位数秒内完成。</p><p id="79d9" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">这实际上很容易扩展。查询本身需要几毫秒；几乎所有的时间都用于临时数据库启动，我们只需要做一次。</p><h1 id="c227" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">压力测试</h1><p id="19da" class="pw-post-body-paragraph ke kf hu kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">简单的测试很容易，但是让我们编写一个更复杂的压力测试。与这个简单的测试不同，压力测试将需要运行多个事务，所以我们不能使用<code class="eh li lj lk ll b">itDB</code>测试助手。</p><p id="1098" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">在这个测试中，我们创建了从队列中读取数据的<code class="eh li lj lk ll b">10</code>消费者线程和发送<code class="eh li lj lk ll b">enqueue</code>消息的<code class="eh li lj lk ll b">1000</code>线程:</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="8d6b" class="lu jh hu ll b fv lv lw l lx ly">it "stress queue" $ \testDB -&gt; do<br/>  let withPool' = withPool testDB<br/>      elemCount = 1000 :: Int<br/>      expected = [0 .. elemCount-1]</span><span id="0185" class="lu jh hu ll b fv lz lw l lx ly">  ref &lt;- newIORef []</span><span id="95c1" class="lu jh hu ll b fv lz lw l lx ly">  -- Make 10 queue consumer threads<br/>  loopThreads &lt;- replicateM 10 <br/>               $ async <br/>               $ fix $ \next -&gt; do<br/>    mpayload &lt;- withPool' tryLock<br/>    case mpayload of<br/>      Nothing -&gt; next<br/>      Just Payload {..}  -&gt; do<br/>        last &lt;- <br/>          atomicModifyIORef ref $ <br/>            \xs -&gt; ( pValue : xs<br/>                   , length xs + 1<br/>                   )<br/>        withPool' $ \conn -&gt; <br/>          dequeue conn pId<br/>        when (last &lt; elemCount) <br/>             next</span><span id="bb9d" class="lu jh hu ll b fv lz lw l lx ly">  -- Fork a 1000 threads and <br/>  -- enqueue an index<br/>  forM_ [0 .. elementCount - 1] $ <br/>    \i -&gt; forkIO $ void $ <br/>      withPool' $ flip enqueue $ <br/>        toJSON i</span><span id="2f0b" class="lu jh hu ll b fv lz lw l lx ly">waitAnyCancel loopThreads<br/>  Just decoded &lt;- <br/>    mapM (decode . encode) <br/>      &lt;$&gt; readIORef ref<br/>  sort decoded <br/>    `shouldBe` sort expected</span></pre><p id="ddae" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">这个测试是有效的，但是很明显我们的设计有问题。我们必须不断地轮询数据库，看看是否有新的数据。</p><h1 id="e1a2" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">获得全额奖学金</h1><p id="acf9" class="pw-post-body-paragraph ke kf hu kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">幸运的是PostgreSQL为我们提供了一个解决方案，正如<a class="ae lh" href="https://www.reddit.com/r/haskell/comments/6fbqg3/assume_it_worked_and_fix_later_jonathan_fischoff/diiqy47/" rel="noopener ugc nofollow" target="_blank"> lpsimth指出的</a> : <code class="eh li lj lk ll b"><a class="ae lh" href="https://www.postgresql.org/docs/current/static/sql-notify.html" rel="noopener ugc nofollow" target="_blank">NOTIFY</a></code>和<code class="eh li lj lk ll b"><a class="ae lh" href="https://www.postgresql.org/docs/current/static/sql-listen.html" rel="noopener ugc nofollow" target="_blank">LISTEN</a></code>。我们创建了一个新函数<code class="eh li lj lk ll b">lock</code>，以利用PostgreSQL的pubsub特性:</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="71de" class="lu jh hu ll b fv lv lw l lx ly">notifyPayload :: Connection <br/>              -&gt; IO ()<br/>notifyPayload conn = do<br/>  Notification {..} &lt;- <br/>    getNotification conn<br/>  unless (notificationChannel<br/>         == "enqueue") $ <br/>         notifyPayload conn</span><span id="0f40" class="lu jh hu ll b fv lz lw l lx ly">lock :: Connection <br/>     -&gt; IO Payload<br/>lock conn = bracket_<br/>  (Simple.execute_ <br/>     conn "LISTEN enqueue")<br/>  (Simple.execute_ <br/>     conn "UNLISTEN enqueue")<br/>  $ fix $ \continue -&gt; do<br/>      m &lt;- tryLock conn<br/>      case m of<br/>        Nothing -&gt; do<br/>          notifyPayload conn<br/>          continue<br/>        Just x -&gt; return x</span></pre><p id="7286" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">我们将<code class="eh li lj lk ll b">enqueueDB</code>扩展到<code class="eh li lj lk ll b">NOTIFY</code>我们的<code class="eh li lj lk ll b">enqueue</code>通道，在它将一个有效载荷入队之后</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="0825" class="lu jh hu ll b fv lv lw l lx ly">enqueueDB :: Value -&gt; DB PayloadId<br/>enqueueDB value = do<br/>  pid &lt;- liftIO randomIO<br/>  execute <br/>    [sql| INSERT INTO payloads <br/>          (id, value) VALUES (?, ?)<br/>          NOTIFY enqueue;<br/>    |]<br/>    (pid, value)<br/>  return $ PayloadId pid</span></pre><p id="2f4f" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">我们可以为<code class="eh li lj lk ll b">lock</code>编写一个类似的测试，我们的循环变成:</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="c5a7" class="lu jh hu ll b fv lv lw l lx ly">loopThreads &lt;- replicateM 10 $ <br/>  async $ fix $ \next -&gt; do<br/>    -- blocks waiting for <br/>    -- new payload<br/>    x &lt;- withPool testDB lock <br/>    lastCount &lt;- <br/>      atomicModifyIORef ref $ <br/>        \xs -&gt; ( pValue x : xs<br/>               , length xs + 1<br/>               )<br/>    withPool testDB $ \conn -&gt; <br/>      dequeue conn (pId x)<br/>    when (last &lt; elemCount) <br/>         next</span></pre><p id="a99f" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">好得多(忽略移动格式的超小边距:p)。最终队列在<a class="ae lh" href="http://hackage.haskell.org/package/postgresql-simple-queue" rel="noopener ugc nofollow" target="_blank"> hackage </a>和<a class="ae lh" href="https://github.com/jfischoff/postgresql-queue" rel="noopener ugc nofollow" target="_blank"> github </a>上打包为<code class="eh li lj lk ll b">postgresql-simple-queue</code>。</p><h1 id="5722" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">有趣是很难写的</h1><p id="33ba" class="pw-post-body-paragraph ke kf hu kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">在我把它推向黑客时代之前，我们经历了许多中间状态。我从简单的东西开始，写了压力测试，幸好发现了bug，并添加了pubsub。最不可思议的是，这很有趣，而且不令人沮丧。</p><p id="fe7d" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">不要相信我的话:试试看。<code class="eh li lj lk ll b"><a class="ae lh" href="https://hackage.haskell.org/package/pg-transact" rel="noopener ugc nofollow" target="_blank">pg-transact</a></code>和<code class="eh li lj lk ll b"><a class="ae lh" href="https://hackage.haskell.org/package/hspec-pg-transact" rel="noopener ugc nofollow" target="_blank">hspec-pg-transact</a></code>正在打包/堆叠。</p><h1 id="387d" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">额外积分:电子邮件队列需要2分钟</h1><p id="9b8d" class="pw-post-body-paragraph ke kf hu kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">我们现在可以编写一个更好的电子邮件处理队列，在我的另一篇文章中讨论过。首先，我们需要一个处理循环:</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="58c8" class="lu jh hu ll b fv lv lw l lx ly">forever $ do<br/>  payload &lt;- withResource <br/>    connectionPool lock <br/>  sendEmail payload<br/>  withResource connectionPool $ <br/>    \conn -&gt; dequeue conn <br/>                     (pId payload)</span></pre><p id="c47d" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated"><code class="eh li lj lk ll b">postgres-simple-queue</code>的<code class="eh li lj lk ll b"><a class="ae lh" href="https://github.com/jfischoff/postgresql-queue/blob/master/src/Database/PostgreSQL/Simple/Queue/Main.hs#L133" rel="noopener ugc nofollow" target="_blank">defaultMain</a></code>为我们提供了这个消费者循环，并且还进行命令行参数处理。我们可以很容易地使队列消费者可执行，就像这样:</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="ab18" class="lu jh hu ll b fv lv lw l lx ly">main :: IO ()<br/>main = do<br/>  env &lt;- newEnv Discover<br/>  runResourceT $ runAWS env $ defaultMain "aws-email-queue-consumer" <br/>    $ \payload _ -&gt; do<br/>      case fromJSON $ pValue payload of<br/>        Success email -&gt; do<br/>          resp &lt;- AWS.send $ makeEmail email<br/>          logFailedRequest resp<br/>        Error x -&gt; throwIO $ userError<br/>                 $ "Failed to decode payload as an Email: " <br/>                 ++ show x</span></pre><p id="8f2e" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">完整的例子见<code class="eh li lj lk ll b"><a class="ae lh" href="https://github.com/jfischoff/postgresql-queue/blob/master/examples/EmailQueue.hs" rel="noopener ugc nofollow" target="_blank">EmailQueue</a></code>。</p><div class="lm ln lo lp fq ab cb"><figure class="ma iv mb mc md me mf paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="ma iv mb mc md me mf paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="ma iv mb mc md me mf paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mg mh mi"><p id="f922" class="ke kf mj kg b kh lc kj kk kl ld kn ko mk le kr ks ml lf kv kw mm lg kz la lb hn dt translated"><a class="ae lh" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客们下午的开始。我们是<a class="ae lh" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae lh" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae lh" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ke kf mj kg b kh lc kj kk kl ld kn ko mk le kr ks ml lf kv kw mm lg kz la lb hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lh" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lh" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lm ln lo lp fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mn"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="lm ln lo lp fq iv"><div class="bz el l di"><div class="mo mp l"/></div></figure></div></div>    
</body>
</html>