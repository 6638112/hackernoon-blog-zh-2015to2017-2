<html>
<head>
<title>Modelling common patterns with redux-saga</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用redux-saga建模常见模式</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/modelling-common-patterns-with-redux-saga-464a380a37ce?source=collection_archive---------3-----------------------#2017-07-23">https://medium.com/hackernoon/modelling-common-patterns-with-redux-saga-464a380a37ce?source=collection_archive---------3-----------------------#2017-07-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/90bbbd9aa166242548f67a6fa6b24e8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PyfQP4blF-d6IMZTD9p6tQ.png"/></div></div></figure><p id="c212" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">本帖假设基本熟悉</em><a class="ae kb" href="https://hackernoon.com/tagged/redux-saga" rel="noopener ugc nofollow" target="_blank"><em class="ka">redux-saga</em></a><em class="ka">。下面是入门</em> <a class="ae kb" href="https://redux-saga.js.org/docs/introduction/BeginnerTutorial.html" rel="noopener ugc nofollow" target="_blank"> <em class="ka">教程</em> </a> <em class="ka">。</em></p><p id="091c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这篇文章中，我将探讨如何使用<a class="ae kb" href="https://github.com/redux-saga/redux-saga" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> redux-saga </strong> </a>对应用程序控制流中的一些常见模式进行建模。</p><blockquote class="kc kd ke"><p id="b1a7" class="jc jd ka je b jf jg jh ji jj jk jl jm kf jo jp jq kg js jt ju kh jw jx jy jz hn dt translated"><a class="ae kb" href="https://github.com/redux-saga/redux-saga" rel="noopener ugc nofollow" target="_blank"> redux-saga </a>是一个库，旨在使React/Redux应用程序中的副作用(即异步的事情，如数据获取和不纯的事情，如访问浏览器缓存)变得更容易和更好。</p></blockquote></div><div class="ab cl ki kj hc kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hn ho hp hq hr"><h1 id="9214" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">这些当中的第一个</h1><p id="d5f5" class="pw-post-body-paragraph jc jd hu je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz hn dt translated">这是一个<a class="ae kb" href="https://hackernoon.com/tagged/pattern" rel="noopener ugc nofollow" target="_blank">模式</a>，应用程序只是简单地等待不同种类的动作。收到的第一个动作决定了应用程序如何进行。也就是说<em class="ka">应用程序不关心第一个动作</em>之后的任何动作。</p><p id="8ff7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如，假设我们正在编写一个关于创建和发送电子邮件的传奇故事。在这个故事中，我们在等待2个动作</p><ul class=""><li id="326d" class="lt lu hu je b jf jg jj jk jn lv jr lw jv lx jz ly lz ma mb dt translated"><code class="eh mc md me mf b">DISCARD_DRAFT</code>如果先收到这个动作，saga将丢弃当前草稿，清理编辑状态&amp;完成。</li><li id="bcb4" class="lt lu hu je b jf mg jj mh jn mi jr mj jv mk jz ly lz ma mb dt translated"><code class="eh mc md me mf b">SEND_EMAIL</code>如果首先收到此操作，则saga可能会进行一些验证(例如，有效的电子邮件地址等)。)，发送邮件，清理编辑状态&amp;然后完成。</li></ul><p id="a6ef" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个故事的流程是由哪个动作(<code class="eh mc md me mf b">DISCARD_DRAFT</code>或<code class="eh mc md me mf b">SEND_EMAIL</code>)最先被接收来控制的。这种情况可以通过简单地使用<code class="eh mc md me mf b"><a class="ae kb" href="https://redux-saga.js.org/docs/api/#takepattern" rel="noopener ugc nofollow" target="_blank">take</a></code>效果创建器来模拟。</p><pre class="ml mm mn mo fq mp mf mq mr aw ms dt"><span id="45b4" class="mt kq hu mf b fv mu mv l mw mx">function *emailSaga() {<br/>    ...<br/>    <br/>    const action = yield take([ // (A)<br/>        `<!-- -->DISCARD_DRAFT<!-- -->`,<br/>        `SEND_EMAIL`<br/>    ]);</span><span id="287d" class="mt kq hu mf b fv my mv l mw mx">    if (action.type === `<!-- -->DISCARD_DRAFT<!-- -->`) { // (B)<br/>        //discard the draft<br/>    } else {<br/>        //send the email<br/>    }<br/>}</span></pre><ul class=""><li id="25be" class="lt lu hu je b jf jg jj jk jn lv jr lw jv lx jz ly lz ma mb dt translated">(A)<code class="eh mc md me mf b">take</code>效果等待2个动作中的任何一个，传奇暂停，直到接收到其中一个。</li><li id="462e" class="lt lu hu je b jf mg jj mh jn mi jr mj jv mk jz ly lz ma mb dt translated">(saga检查接收到的动作&amp;的<code class="eh mc md me mf b">type</code>，然后相应地继续。</li></ul><p id="2a83" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">注意:<br/>这种情况也可以使用</em> <code class="eh mc md me mf b"><a class="ae kb" href="https://redux-saga.js.org/docs/api/#raceeffects" rel="noopener ugc nofollow" target="_blank"><em class="ka">race</em></a></code> <em class="ka">效果来模拟，如下图</em></p><pre class="ml mm mn mo fq mp mf mq mr aw ms dt"><span id="5e91" class="mt kq hu mf b fv mu mv l mw mx">function *emailSaga() {<br/>    const { discard, send } = yield race({ // (A)<br/>        discard: take(`DISCARD_DRAFT`),<br/>        send: take(`SEND_EMAIL`)<br/>    })</span><span id="63e7" class="mt kq hu mf b fv my mv l mw mx">    if (discard) {<br/>        //discard the draft<br/>    } else {<br/>        //send the email<br/>    }<br/>}</span></pre><ul class=""><li id="c580" class="lt lu hu je b jf jg jj jk jn lv jr lw jv lx jz ly lz ma mb dt translated">(A)我们在2个<code class="eh mc md me mf b">take</code>效果之间创建一个比赛，即当2个<code class="eh mc md me mf b">take</code>效果中的任何一个完成时，比赛结束。</li></ul><p id="4bf5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh mc md me mf b">take([...])</code>和<code class="eh mc md me mf b">race</code>之间重要的语义区别在于</p><ul class=""><li id="ad13" class="lt lu hu je b jf jg jj jk jn lv jr lw jv lx jz ly lz ma mb dt translated"><code class="eh mc md me mf b">take([...])</code>等待<em class="ka">第一个匹配动作到达</em>。</li><li id="f3fb" class="lt lu hu je b jf mg jj mh jn mi jr mj jv mk jz ly lz ma mb dt translated"><code class="eh mc md me mf b">race</code>等待<em class="ka">第一个竞速效果完成</em>。</li></ul></div><div class="ab cl ki kj hc kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hn ho hp hq hr"><h1 id="4586" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">一直做，直到</h1><p id="91f9" class="pw-post-body-paragraph jc jd hu je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz hn dt translated">这也是一种常见的模式，我们希望让任务一直运行，直到收到停止任务的特定操作。</p><p id="7520" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如，假设我们正在编写一个向播放列表添加歌曲的传奇故事。传奇应该让用户添加他们喜欢的歌曲。然而，当接收到特定的动作时，它应该停止该任务(如<code class="eh mc md me mf b">SAVE_PLAYLIST</code>)。</p><p id="2a52" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种情况可以建模如下</p><pre class="ml mm mn mo fq mp mf mq mr aw ms dt"><span id="0525" class="mt kq hu mf b fv mu mv l mw mx">function *addToPlaylist() {<br/>    while (true) { //(A)<br/>        const action = yield take([<br/>            `ADD_SONG`,<br/>            `SAVE_PLAYLIST`<br/>        ]);</span><span id="b2ce" class="mt kq hu mf b fv my mv l mw mx">        if (action.type === `ADD_SONG`) {<br/>            //add the song to the playlist<br/>        } else {<br/>            break; //(B)<br/>        }<br/>     }<br/>}</span></pre><ul class=""><li id="d42c" class="lt lu hu je b jf jg jj jk jn lv jr lw jv lx jz ly lz ma mb dt translated">(A)<code class="eh mc md me mf b">while</code>循环保持任务运行。</li><li id="a23b" class="lt lu hu je b jf mg jj mh jn mi jr mj jv mk jz ly lz ma mb dt translated">(B)一收到<code class="eh mc md me mf b">SAVE_PLAYLIST</code>，我们就中断循环，停止任务。</li></ul><p id="ceec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">注意:<br/>这种情况也可以使用如下</em>所示的 <code class="eh mc md me mf b"><a class="ae kb" href="https://redux-saga.js.org/docs/api/#takeeverypattern-saga-args" rel="noopener ugc nofollow" target="_blank"><em class="ka">takeEvery</em></a></code> <em class="ka">效果来模拟</em></p><pre class="ml mm mn mo fq mp mf mq mr aw ms dt"><span id="5bc0" class="mt kq hu mf b fv mu mv l mw mx">function *addToPlaylist() {<br/>    const addTask = yield takeEvery(`ADD_SONG`, function*() { // (A)<br/>        //add the song to the playlist<br/>    });</span><span id="af46" class="mt kq hu mf b fv my mv l mw mx">    yield take(`SAVE_PLAYLIST`); // (B)<br/>    yield cancel(addTask); // (C)<br/>}</span></pre><ul class=""><li id="f118" class="lt lu hu je b jf jg jj jk jn lv jr lw jv lx jz ly lz ma mb dt translated">(A)我们启动一个连续运行的任务<code class="eh mc md me mf b">addTask</code>(使用<code class="eh mc md me mf b">takeEvery</code>)，它接收每个<code class="eh mc md me mf b">ADD_SONG</code>动作&amp;并将其添加到播放列表中。</li><li id="77c1" class="lt lu hu je b jf mg jj mh jn mi jr mj jv mk jz ly lz ma mb dt translated">(B)传奇仍在继续&amp;现在等待<code class="eh mc md me mf b">SAVE_PLAYLIST</code>行动。</li><li id="255e" class="lt lu hu je b jf mg jj mh jn mi jr mj jv mk jz ly lz ma mb dt translated">(C)一旦接收到<code class="eh mc md me mf b">SAVE_PLAYLIST</code>,传奇<a class="ae kb" href="https://redux-saga.js.org/docs/api/#canceltask" rel="noopener ugc nofollow" target="_blank">取消</a><code class="eh mc md me mf b">addTask</code>,即停止监听<code class="eh mc md me mf b">ADD_SONG</code>动作。</li></ul><p id="e4a1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种模拟情况的方式更简洁，但是前一种方式的意图更明确。</p></div><div class="ab cl ki kj hc kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hn ho hp hq hr"><h1 id="03e7" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">按部就班的</h1><p id="fbbc" class="pw-post-body-paragraph jc jd hu je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz hn dt translated">这是一种常见的模式，其中业务流被分解成更小的步骤。这些步骤以有序的方式呈现给用户，但是用户可以随时返回。</p><p id="cab7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如，考虑预订航班的过程。它可以分为以下3个步骤</p><ul class=""><li id="c9b6" class="lt lu hu je b jf jg jj jk jn lv jr lw jv lx jz ly lz ma mb dt translated"><em class="ka">选择航班— </em>这一步负责让用户选择航班。</li><li id="1950" class="lt lu hu je b jf mg jj mh jn mi jr mj jv mk jz ly lz ma mb dt translated"><em class="ka">填写详细信息— </em>该步骤从用户处收集必要的详细信息。</li><li id="3fc1" class="lt lu hu je b jf mg jj mh jn mi jr mj jv mk jz ly lz ma mb dt translated"><em class="ka">付款— </em>该步骤负责从用户处收取付款。</li></ul><p id="c606" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些步骤按以下顺序显示给用户</p><pre class="ml mm mn mo fq mp mf mq mr aw ms dt"><span id="5a57" class="mt kq hu mf b fv mu mv l mw mx">Choose Flight ---&gt; Fill Details ---&gt; Payment</span></pre><p id="80e1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，用户也应该能够返回到上一步。</p><pre class="ml mm mn mo fq mp mf mq mr aw ms dt"><span id="054f" class="mt kq hu mf b fv mu mv l mw mx">              ---&gt;              ---&gt;<br/>Choose Flight      Fill Details      Payment<br/>              &lt;---              &lt;---</span></pre><p id="9a2c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这样的需求可以使用一个<em class="ka">父传奇</em>和多个<em class="ka">子传奇</em>对应每一步来建模。本质上，<em class="ka">父-传奇</em>控制进程的传播&amp;为当前步骤执行正确的<em class="ka">子-传奇</em>。</p><p id="824a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">考虑到我们正在为上面提到的预订航班的过程写一个传奇。</p><ul class=""><li id="52e7" class="lt lu hu je b jf jg jj jk jn lv jr lw jv lx jz ly lz ma mb dt translated">我们假设这三个步骤有以下<em class="ka">个儿童故事</em>。这些<em class="ka">儿童传奇</em>的内容与本次讨论无关。</li></ul><pre class="ml mm mn mo fq mp mf mq mr aw ms dt"><span id="4c68" class="mt kq hu mf b fv mu mv l mw mx">function *chooseFlight() { ... } // (A)<br/>function *fillDetails()  { ... } // (B)<br/>function *paymentSaga()  { ... } // (C)</span></pre><ul class=""><li id="a058" class="lt lu hu je b jf jg jj jk jn lv jr lw jv lx jz ly lz ma mb dt translated">我们假设一旦一个<em class="ka">儿童传奇</em>结束，我们会自动进入下一步。</li><li id="3ca8" class="lt lu hu je b jf mg jj mh jn mi jr mj jv mk jz ly lz ma mb dt translated">我们假设每次用户想回到上一步时，都会调度一个<code class="eh mc md me mf b">BACK</code>动作。</li><li id="5d04" class="lt lu hu je b jf mg jj mh jn mi jr mj jv mk jz ly lz ma mb dt translated">我们现在将创建一个<em class="ka">父传奇</em>来控制传播&amp;基于当前步骤执行正确的<em class="ka">子传奇</em>。</li></ul><pre class="ml mm mn mo fq mp mf mq mr aw ms dt"><span id="d065" class="mt kq hu mf b fv mu mv l mw mx">function *bookFlight() { // (A)<br/>    let breakLoop = false;<br/>    let step = 0; // (B)</span><span id="69f3" class="mt kq hu mf b fv my mv l mw mx">    const backTask = yield takeEvery(`BACK`, function*() { // (C)<br/>        if (step &gt; 0) {<br/>             step--;<br/>        }<br/>    })</span><span id="978f" class="mt kq hu mf b fv my mv l mw mx">    while (true) { // (D)<br/>        switch (step) { // (E)<br/>            case 0: {<br/>                yield call(selectFlight); // (F)<br/>                step++; // (G)<br/>                break;<br/>            }<br/>            case 1: {<br/>                yield call(fillDetails);<br/>                step++;<br/>                break;<br/>            }<br/>            case 2: {<br/>                yield call(paymentSaga);<br/>                step++;<br/>                break;<br/>            }<br/>            case 3: {<br/>                breakLoop = true; // (H)<br/>                yield cancel(backTask); // (I)<br/>                break;<br/>            }<br/>        }</span><span id="e2c1" class="mt kq hu mf b fv my mv l mw mx">        if (breakLoop) { // (J)<br/>            break;<br/>        }<br/>    }<br/>}</span></pre><ul class=""><li id="6e49" class="lt lu hu je b jf jg jj jk jn lv jr lw jv lx jz ly lz ma mb dt translated">(一)<em class="ka">亲子关系</em>称为<code class="eh mc md me mf b">bookFlight</code>。</li><li id="617f" class="lt lu hu je b jf mg jj mh jn mi jr mj jv mk jz ly lz ma mb dt translated">(B)将<code class="eh mc md me mf b">step</code>设置为<code class="eh mc md me mf b">0</code>，即从第一个<em class="ka">子故事</em> <code class="eh mc md me mf b">selectFlight</code> <em class="ka">开始。</em></li><li id="fa3e" class="lt lu hu je b jf mg jj mh jn mi jr mj jv mk jz ly lz ma mb dt translated">(C)启动一个任务来监听每个<code class="eh mc md me mf b">BACK</code>动作，并将<code class="eh mc md me mf b">step</code>递减<code class="eh mc md me mf b">1</code>。</li><li id="21b4" class="lt lu hu je b jf mg jj mh jn mi jr mj jv mk jz ly lz ma mb dt translated">(D)启动无限循环<code class="eh mc md me mf b">while</code>以保持<em class="ka">父系列</em>持续运行。</li><li id="377a" class="lt lu hu je b jf mg jj mh jn mi jr mj jv mk jz ly lz ma mb dt translated">(E)<code class="eh mc md me mf b">switch</code>语句评估当前<code class="eh mc md me mf b">step</code>并执行正确的<em class="ka">子事件。</em></li><li id="0184" class="lt lu hu je b jf mg jj mh jn mi jr mj jv mk jz ly lz ma mb dt translated">(F)为<code class="eh mc md me mf b">step 0</code>执行<code class="eh mc md me mf b">selectFlight</code> <em class="ka">子传奇</em>。</li><li id="a5de" class="lt lu hu je b jf mg jj mh jn mi jr mj jv mk jz ly lz ma mb dt translated">(G)将<code class="eh mc md me mf b">step</code>增加<code class="eh mc md me mf b">1</code>以进入下一步。</li><li id="5ace" class="lt lu hu je b jf mg jj mh jn mi jr mj jv mk jz ly lz ma mb dt translated">(H)如果<code class="eh mc md me mf b">step</code>的值为<code class="eh mc md me mf b">3</code>，即所有步骤都已完成，则<em class="ka">父-传奇</em>应该结束。</li><li id="30d2" class="lt lu hu je b jf mg jj mh jn mi jr mj jv mk jz ly lz ma mb dt translated">(I)取消任务以监听<code class="eh mc md me mf b">BACK</code>动作。</li><li id="76b5" class="lt lu hu je b jf mg jj mh jn mi jr mj jv mk jz ly lz ma mb dt translated">(J)评估<em class="ka">亲子传奇</em>是否应该结束或继续。</li></ul><p id="83d5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">注意:<br/>这是一个简单的例子，我们只支持单步传播。然而，在一个生产应用程序中，我们希望用户从一个步骤跳到另一个步骤(当然有一些检查)。</em></p><p id="f283" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">但是这种技术可以很容易地扩展来实现这样的需求(通过明确地为</em> <code class="eh mc md me mf b"><em class="ka">step</em></code> <em class="ka">变量提供下一个值，而不是增加或减少它)。</em></p><p id="cd60" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">事实上，这就是我们如何使用sagas构建有限状态机。</em></p></div><div class="ab cl ki kj hc kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hn ho hp hq hr"><p id="dba9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">redux-saga是一个有趣的控制流建模工具。我希望这些模式被证明是有用的。</p><figure class="ml mm mn mo fq iv"><div class="bz el l di"><div class="mz na l"/></div></figure></div></div>    
</body>
</html>