<html>
<head>
<title>afl-unicorn: Fuzzing Arbitrary Binary Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">afl-unicorn:模糊任意二进制代码</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/afl-unicorn-fuzzing-arbitrary-binary-code-563ca28936bf?source=collection_archive---------5-----------------------#2017-10-31">https://medium.com/hackernoon/afl-unicorn-fuzzing-arbitrary-binary-code-563ca28936bf?source=collection_archive---------5-----------------------#2017-10-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="d7ff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="http://lcamtuf.coredump.cx/afl/" rel="noopener ugc nofollow" target="_blank">美国模糊Lop (AFL) </a>牛逼。这无疑是对命令行应用程序快速进行尖端模糊分析的最佳选择。但是，在通过命令行访问您想要模糊的东西并不那么简单的情况下，该怎么办呢？很多时候你可以编写一个测试工具(或者使用<a class="ae jp" href="https://llvm.org/docs/LibFuzzer.html" rel="noopener ugc nofollow" target="_blank"> libFuzzer </a>代替)，但是如果你可以模拟你想要模糊的代码部分，并且仍然获得AFL的所有基于覆盖率的优势呢？例如，您可能想要模糊来自嵌入式系统的解析函数，该系统通过RF接收输入，并且不容易调试。也许你感兴趣的代码深埋在一个复杂、缓慢的<a class="ae jp" href="https://hackernoon.com/tagged/program" rel="noopener ugc nofollow" target="_blank">程序</a>中，你无法通过任何传统的<a class="ae jp" href="https://hackernoon.com/tagged/tools" rel="noopener ugc nofollow" target="_blank">工具</a>轻易模糊它。</p><p id="1bee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我为AFL创造了一个新的“独角兽模式”,让你可以做到这一点。如果你可以使用<a class="ae jp" href="https://github.com/unicorn-engine/unicorn" rel="noopener ugc nofollow" target="_blank"> Unicorn引擎</a>模拟你感兴趣的代码，你可以用afl-unicorn模糊它。所有的源代码(和一堆附加文档)都可以在<a class="ae jp" href="https://github.com/njv299/afl-unicorn" rel="noopener ugc nofollow" target="_blank"> afl-unicorn GitHub页面</a>获得。</p><h1 id="86c3" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">如何获得它</h1><p id="1f7a" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">将<a class="ae jp" href="https://github.com/njv299/afl-unicorn" rel="noopener ugc nofollow" target="_blank"> afl-unicorn git repo </a>从GitHub克隆或下载到Linux系统(我只在Ubuntu 16.04 LTS上测试过)。之后，像往常一样构建并安装AFL，然后进入' unicorn_mode '文件夹，以root身份运行' build_unicorn_support.sh '脚本。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="668d" class="lc jr hu ky b fv ld le l lf lg">cd /path/to/afl-unicorn<br/>make<br/>sudo make install<br/>cd unicorn_mode<br/>sudo ./build_unicorn_support.sh</span></pre><h1 id="f47c" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">它是如何工作的</h1><p id="44c5" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">Unicorn模式通过实现块边缘检测来工作，AFL的QEMU模式通常会在Unicorn引擎中这样做。基本上，AFL将使用来自任何仿真代码片段的块覆盖信息来驱动其输入生成。整个想法围绕着正确构建基于Unicorn的测试工具，如下图所示:</p><figure class="kt ku kv kw fq li fe ff paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="fe ff lh"><img src="../Images/5d25f2b6c225b40f520a0a46f98a91b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fk1INIYI8_d0L4NILOqYXw.png"/></div></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek">The only addition to normal AFL use is the Unicorn-based test harness</figcaption></figure><p id="c30f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">基于Unicorn的测试工具加载目标代码，设置初始状态，并从磁盘加载AFL变异的数据。然后，测试工具模拟目标二进制代码，如果检测到发生了崩溃或错误，就会抛出一个信号。AFL会做所有正常的事情，但它实际上是模糊的模拟目标二进制代码！</p><p id="3081" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">unicorn模式应该可以像预期的那样使用Unicorn脚本或任何标准Unicorn绑定(C/Python/Go/Whatever)编写的应用程序，只要最终测试工具使用从afl-unicorn创建的打补丁的Unicorn引擎源代码编译的libunicorn.so。到目前为止，我只测试了Python，所以如果你测试了这个，请向回购提供反馈和/或补丁。</p><p id="5eba" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，构建afl-unicorn将在您的本地系统上编译并安装Unicorn Engine v1.0.1的修补版本。在构建afl-unicorn之前，您必须卸载任何现有的Unicorn二进制文件。和现成的AFL一样，afl-unicorn只支持Linux。我只在Ubuntu 16.04 LTS上测试过，但它应该可以在任何能够运行AFL和Unicorn的操作系统上流畅运行。</p><ul class=""><li id="9ab7" class="lt lu hu it b iu iv iy iz jc lv jg lw jk lx jo ly lz ma mb dt translated"><strong class="it hv"> <em class="mc">注</em> </strong>:加载模糊输入数据前，至少要仿真1条指令。这是AFL的fork服务器如何在QEMU模式下启动的一个神器。可能需要做更多的工作来解决这个问题，但是现在只要模拟至少一个例子中的指令就可以了，不要担心这个问题。下面的示例演示了如何轻松解决这一限制。</li></ul><h1 id="1df0" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">示例使用</h1><p id="08ab" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated"><strong class="it hv"> <em class="mc">注:这与回购中包含的‘简单例子’相同。请在您自己的系统上使用它，看看它的运行情况。repo包含一个预先构建的main()的MIPS二进制文件，这里演示了它。</em> </strong></p><p id="d8b7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，让我们看看我们将模糊的代码。这只是一个虚构的玩具示例，很容易以几种不同的方式崩溃，但我已经将它扩展到现实世界的用例中，它完全按照预期工作。</p><figure class="kt ku kv kw fq li"><div class="bz el l di"><div class="md me l"/></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek">Contrived crashing example code used to test basic afl-unicorn functionality</figcaption></figure><p id="4e00" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，这段代码本身完全是伪造的。它假设‘data _ buf’的数据将神奇地位于地址0x00300000。虽然这看起来很奇怪，但这类似于许多解析函数，它们假设将在固定地址的缓冲区中找到数据。</p><p id="4662" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在现实世界中，您需要对目标二进制文件进行逆向工程，以找到并确定您想要模拟和模糊的确切功能。在接下来的博文中，我将展示一些工具来简化流程状态的提取和加载，但是现在你需要做的是在Unicorn中安装并运行所有必需的组件。</p><p id="083f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您的测试工具必须通过命令行上指定的文件接受输入进行变异。这是允许AFL通过正常接口改变输入的粘合剂。如果测试工具在模拟过程中检测到崩溃的情况，比如emu_start()抛出一个异常，它也必须强制自己崩溃。下面是一个实现这两种功能的测试工具示例:</p><figure class="kt ku kv kw fq li"><div class="bz el l di"><div class="md me l"/></div></figure><p id="0c36" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">创建一些测试输入，并单独运行您的测试工具，以验证它是否像预期的那样模拟代码(并崩溃)。</p><p id="b57f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在测试工具已经启动并运行，创建一些样本输入并在afl-fuzz下运行它，如下所示。确保添加了'-U '参数来指定Unicorn模式，我建议将内存限制参数('-m ')设置为' none '，因为运行Unicorn脚本会占用相当多的RAM。遵循正常的AFL惯例，用' @@ '替换包含要模糊的文件路径的参数(更多信息请参见AFL的自述文件)</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="4b46" class="lc jr hu ky b fv ld le l lf lg">afl-fuzz -U -m none -i /path/to/sample/inputs -o /path/to/results <br/>    -- python simple_test_harness.py @@</span></pre><p id="1e6c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果一切按计划进行，AFL将启动并很快发现一些崩溃。</p><figure class="kt ku kv kw fq li fe ff paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="fe ff mf"><img src="../Images/f18e05bc6b50808d428a5c43e3a8cec6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nju41ImcIfatUzDGjEdqbA.png"/></div></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek">AFL found crashes in the sample in just few seconds!</figcaption></figure><p id="23a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，您可以通过测试工具手动运行崩溃输入(在results/crashes/目录中找到),以了解关于它们崩溃原因的更多信息。我建议保留您的Unicorn测试工具的第二个副本，并根据需要进行修改，以便在仿真中调试崩溃。例如，您可以打开指令跟踪，使用<a class="ae jp" href="http://www.capstone-engine.org" rel="noopener ugc nofollow" target="_blank">顶点</a>沿途反汇编，在关键点转储寄存器等。</p><p id="bfc6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦你认为你有一个有效的崩溃，你就需要找出一种方法把它传递给仿真之外的实际程序，并验证这个崩溃在物理系统上起作用。</p><p id="c4cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">值得注意的是，总体模糊化速度和性能将在很大程度上取决于测试工具的速度。一个庞大、复杂的基于Python的测试工具运行起来要比一个紧凑、优化的基于C的工具慢得多。如果您计划运行大量的、长时间运行的fuzzers，请务必考虑这一点。作为一个粗略的参考，我发现一个基于C的工具比一个类似的Python工具每秒多执行5-10倍。</p><h1 id="fff9" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">从这里去哪里</h1><p id="840f" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">虽然我最初创建这个是为了找到嵌入式系统中的漏洞(像那些由<a class="ae jp" href="https://googleprojectzero.blogspot.com/2017/04/over-air-exploiting-broadcoms-wi-fi_4.html" rel="noopener ugc nofollow" target="_blank"> Project Zero </a>和<a class="ae jp" href="https://comsecuris.com/blog/posts/luaqemu_bcm_wifi/" rel="noopener ugc nofollow" target="_blank"> Comsecuris </a>在Broadcom WiFi芯片组中发现的漏洞)，但在我的<a class="ae jp" href="https://hackernoon.com/afl-unicorn-part-2-fuzzing-the-unfuzzable-bea8de3540a5" rel="noopener ugc nofollow" target="_blank">后续博客文章</a>中，我将发布工具并描述一种使用afl-unicorn模糊Windows、Linux和Android进程中的仿真功能的方法。</p><p id="384e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Afl-unicorn不仅可以用来查找崩溃，还可以用来进行基本的路径查找。在您的测试工具中，如果执行了特定的指令(或者您选择的任何其他条件)，您可以强制崩溃。AFL将捕捉这些“崩溃”,并存储导致满足该条件的输入。这可以作为穷人对符号分析的替代，以发现深入解析逻辑树的输入。</p><p id="50ff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Unicorn和Capstone的制造商最近一直在<a class="ae jp" href="https://twitter.com/capstone_engine/status/925327798566129664" rel="noopener ugc nofollow" target="_blank">推特上发布</a> <a class="ae jp" href="https://twitter.com/capstone_engine/status/899990577147633665" rel="noopener ugc nofollow" target="_blank">图片</a>，暗示AFL支持可能很快就会到来……看看他们创造了什么功能，以及是否有任何合作机会来优化我们的工具，这将是很有趣的。</p><h1 id="1019" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">信用</h1><p id="6332" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我在俄亥俄州哥伦布市的<a class="ae jp" href="https://www.battelle.org/cyber" rel="noopener ugc nofollow" target="_blank">巴特尔</a>公司担任网络安全研究员时，开发了afl-unicorn作为内部研究项目。巴特尔是一个令人敬畏的工作场所，afl-unicorn只是在那里进行的许多新颖的网络安全研究的例子之一。更多巴特尔赞助的项目，请查看<a class="ae jp" href="https://github.com/xoreaxeaxeax" rel="noopener ugc nofollow" target="_blank">克里斯·多玛斯</a>和<a class="ae jp" href="https://github.com/cetfor" rel="noopener ugc nofollow" target="_blank">约翰·托特希</a>之前的作品。有关巴特尔职业的信息，请查看他们的<a class="ae jp" href="https://www.battelle.org/cyber-careers" rel="noopener ugc nofollow" target="_blank">职业页面</a>。</p><p id="31f2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然，如果没有<a class="ae jp" href="http://lcamtuf.coredump.cx/afl/" rel="noopener ugc nofollow" target="_blank"> AFL </a>和<a class="ae jp" href="http://www.unicorn-engine.org/" rel="noopener ugc nofollow" target="_blank">独角兽引擎</a>，这一切都是不可能的。许多额外的灵感来自亚历克斯·胡德为IDA开发的令人敬畏的uEmu插件，许多一般概念借鉴自NCC集团的AFLTriforce项目。</p><p id="41e0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要继续，请查看<a class="ae jp" href="https://hackernoon.com/afl-unicorn-part-2-fuzzing-the-unfuzzable-bea8de3540a5" rel="noopener ugc nofollow" target="_blank"><strong class="it hv"><em class="mc">AFL-unicorn:Part 2-模糊化‘不可模糊的’</em></strong></a></p><figure class="kt ku kv kw fq li"><div class="bz el l di"><div class="mg me l"/></div></figure></div></div>    
</body>
</html>