<html>
<head>
<title>Performance Monitoring for the Frontend — An introduction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">前端性能监控—简介</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/performance-monitoring-for-the-frontend-an-introduction-e0ab422f131c?source=collection_archive---------14-----------------------#2017-12-09">https://medium.com/hackernoon/performance-monitoring-for-the-frontend-an-introduction-e0ab422f131c?source=collection_archive---------14-----------------------#2017-12-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="f8ce" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这一年中，我在全球各地的不同会议上看到了许多演讲。他们中有不少人关注的是<a class="ae jp" href="https://hackernoon.com/tagged/performance" rel="noopener ugc nofollow" target="_blank">的表现</a>，涉及各种话题:</p><ul class=""><li id="3ef2" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">从您的应用程序中删除jank</li><li id="1669" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">拥有更快的屏幕或互动时间</li><li id="304d" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">通过GraphQL + Apollo或Relay，在需要的时候只加载需要的数据</li><li id="9907" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">优化您的redux-thunk或redux-saga以更快地加载数据或预取特定资源</li></ul><figure class="ke kf kg kh fq ki"><div class="bz el l di"><div class="kj kk l"/></div><figcaption class="kl km fg fe ff kn ko bd b be z ek">A loading screen in its natural habitat</figcaption></figure><p id="f131" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这一系列的博客文章是关于网络相关的性能问题。<br/>我们的目标是为您提供一套工具，帮助您了解如何向客户交付更少、更短的装货屏幕。因为还有什么比等待一个页面或者一个屏幕加载更烦人的呢？</p><p id="4711" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我想从我使用的关于性能监控的第一个工具开始:<a class="ae jp" href="https://zipkin.io/" rel="noopener ugc nofollow" target="_blank">Zipkin</a><br/>“Zipkin是一个分布式跟踪系统。”陈述<a class="ae jp" href="https://zipkin.io/" rel="noopener ugc nofollow" target="_blank">网站</a>。Zipkin库由收集跟踪信息的服务器和向服务器发送跟踪信息的客户端组成。有很多各种语言的Zipkin客户端，比如<a class="ae jp" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> Javascript </a>，C#，Go，Java，Ruby，Python。还有为库预先准备的工具，例如express、fetch、Postgres和Redis。</p><figure class="ke kf kg kh fq ki fe ff paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="fe ff kp"><img src="../Images/20a461f9c6efe60fc7ee545713d161fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H7kl2KslgUj6hiF-PfXmVw.png"/></div></div><figcaption class="kl km fg fe ff kn ko bd b be z ek">A screenshot from Zipkin</figcaption></figure><h1 id="5938" class="kw kx hu bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">术语</h1><p id="4e86" class="pw-post-body-paragraph ir is hu it b iu lu iw ix iy lv ja jb jc lw je jf jg lx ji jj jk ly jm jn jo hn dt translated">为了让您开始跟踪上下文，我们需要定义我们谈论的内容。幸运的是，已经有了一些术语，所以让我们一起来复习一下:</p><h2 id="40ae" class="lz kx hu bd ky ma mb mc lc md me mf lg jc mg mh lk jg mi mj lo jk mk ml ls mm dt translated">使用仪器</h2><p id="3c1d" class="pw-post-body-paragraph ir is hu it b iu lu iw ix iy lv ja jb jc lw je jf jg lx ji jj jk ly jm jn jo hn dt translated">某个东西的一个仪表化版本，比如说一个API客户端是一个通过添加跟踪来扩展原始版本的版本。在我们的例子中，这可能是一个fetch API，它不仅发送有效负载本身，还发送带有跟踪信息的对Zipkin服务器的更新。</p><h2 id="6619" class="lz kx hu bd ky ma mb mc lc md me mf lg jc mg mh lk jg mi mj lo jk mk ml ls mm dt translated">找到；查出</h2><p id="0021" class="pw-post-body-paragraph ir is hu it b iu lu iw ix iy lv ja jb jc lw je jf jg lx ji jj jk ly jm jn jo hn dt translated">一个跟踪(见下图)描述了一个交互(例如，一个用户交互或一个API调用),特别关注执行时间。它由*Spans*和它们之间的依赖关系组成。最顶端和最早的跨度称为*根跨度*，它通常是触发工作负载的交互，位于系统的外部边缘。每个span都可以是另一个Span的父Span，类似于一个函数能够调用其他Span。如果存在这样的子关系，Zipkin会自动命令跨度在彼此之下更深。</p><h2 id="a6a6" class="lz kx hu bd ky ma mb mc lc md me mf lg jc mg mh lk jg mi mj lo jk mk ml ls mm dt translated">服务</h2><p id="ed87" class="pw-post-body-paragraph ir is hu it b iu lu iw ix iy lv ja jb jc lw je jf jg lx ji jj jk ly jm jn jo hn dt translated">你注意到下图最左边的蓝色标签了吗？这些被称为服务，它们是在构建跟踪器时配置的。将它们视为应用程序的不同层。您可以根据您的特定需求对它们进行裁剪:如果您有一个express API，那么它可能是您想要分离成服务的各种中间件。如果你有一个微服务架构，每个服务可能有它自己的层。</p><h2 id="37f5" class="lz kx hu bd ky ma mb mc lc md me mf lg jc mg mh lk jg mi mj lo jk mk ml ls mm dt translated">日志和标签</h2><p id="a590" class="pw-post-body-paragraph ir is hu it b iu lu iw ix iy lv ja jb jc lw je jf jg lx ji jj jk ly jm jn jo hn dt translated">如果没有日志和标记，搜索具有特定属性的特定范围将会很乏味。它们将字符串键映射到值，并允许在用户界面中进行平滑的搜索。标记和日志之间的区别在于，标记可以被认为是每个span的注释，而日志有一个时间组件。据我所知，Zipkin并不尊重这种差异，但知道社区在谈论什么还是很好的。</p><p id="3cf9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你想了解更多的术语，请查看<a class="ae jp" href="https://github.com/opentracing/specification/blob/master/specification.md" rel="noopener ugc nofollow" target="_blank"> opentracing规范</a>。</p><p id="ca78" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你读到这里，所以看起来你对这个话题很感兴趣。我有一篇后续文章，您可以在其中看到这些术语的实际应用。我们将学习如何通过Zipkin: <a class="ae jp" rel="noopener" href="/@dschmidt1992/performance-monitoring-for-the-frontend-using-zipkin-bf3aa4a715e5"> <strong class="it hv">为您的应用程序添加监控功能——使用Zipkin </strong> </a>进行前端性能监控</p><p id="7695" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="mn">想从我这里听到更多信息吗？欢迎订阅我的时事通讯，我大概一个月发一次新闻。</em></p><figure class="ke kf kg kh fq ki"><div class="bz el l di"><div class="mo kk l"/></div></figure><figure class="ke kf kg kh fq ki"><div class="bz el l di"><div class="mp kk l"/></div></figure></div></div>    
</body>
</html>