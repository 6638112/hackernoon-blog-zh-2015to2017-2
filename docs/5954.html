<html>
<head>
<title>Yet Another Event Promised Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">另一个事件承诺服务器</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/yet-another-event-promised-server-ee1b06506add?source=collection_archive---------10-----------------------#2017-08-25">https://medium.com/hackernoon/yet-another-event-promised-server-ee1b06506add?source=collection_archive---------10-----------------------#2017-08-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="af7a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们很多人在工作或自己的项目中使用<a class="ae jp" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> node.js </a>和<a class="ae jp" href="http://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> express </a>。但是现在我们可以使用async/await这样有趣的特性。我们可以使用<a class="ae jp" href="http://koajs.com/" rel="noopener ugc nofollow" target="_blank"> koa </a>或者为express制作错误处理器包装器。但这并不酷。</p><p id="b721" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Express和koa使用内核中的中间件作为主要模式。它是从Ruby framework <a class="ae jp" href="http://www.sinatrarb.com/" rel="noopener ugc nofollow" target="_blank"> sinatra </a>复制过来的，并且不是异步的。你可以把它和loop进行比较——不是声明性的，也不是异步的。</p><p id="99f3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你看看node.js <a class="ae jp" href="https://nodejs.org/api/http.html#http_class_http_server" rel="noopener ugc nofollow" target="_blank"> server </a>是如何工作的，你可以看到带有“请求”事件的单个进程。</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="4a15" class="jz ka hu jv b fv kb kc l kd ke">const http = require('http');<br/><br/>const server = http.createServer( (req, res) =&gt; {<br/>  ctx.res.statusCode = 200;<br/>  res.end('okay');<br/>});</span></pre><p id="aedc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">并承诺:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="3081" class="jz ka hu jv b fv kb kc l kd ke">const http = require('http');<br/><br/>const server = http.createServer( (req, res) =&gt; {<br/>  Promise.resolve({ req, res })<br/>    .then(ctx =&gt; {<br/><br/>        ctx.res.statusCode = 200;<br/>        ctx.res.end('okay');<br/><br/>        return ctx;<br/>    });<br/>});</span></pre><p id="164b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，如果你使用循环或中间件或任何非异步代码，所有其他请求将等待。node.js和javascript的主要思想是使用非阻塞动作。这就是为什么我们有回调，承诺和异步/等待。</p><p id="d5c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以经过研究，我决定创建一个新的框架。让我们来认识一下<a class="ae jp" href="https://yeps.info/" rel="noopener ugc nofollow" target="_blank"> YEPS </a>。</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="e0aa" class="jz ka hu jv b fv kb kc l kd ke">npm i -S yeps</span></pre><h2 id="afd7" class="jz ka hu bd kf kg kh ki kj kk kl km kn jc ko kp kq jg kr ks kt jk ku kv kw kx dt translated">app.js</h2><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="3b44" class="jz ka hu jv b fv kb kc l kd ke">const App = require('yeps');<br/><br/>const app = module.exports = new App();<br/><br/>app.then(async ctx =&gt; {<br/>  ctx.res.statusCode = 200;<br/>  ctx.res.end('Ok');<br/>});<br/><br/>app.catch(async (err, ctx) =&gt; {<br/>  ctx.res.statusCode = 500;<br/>  ctx.res.end(err.message);<br/>});</span></pre><h2 id="a180" class="jz ka hu bd kf kg kh ki kj kk kl km kn jc ko kp kq jg kr ks kt jk ku kv kw kx dt translated">bin/www</h2><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="a896" class="jz ka hu jv b fv kb kc l kd ke">#!/usr/bin/env node<br/><br/>const http = require('http');<br/>const app = require('../app');<br/><br/>http<br/>    .createServer(app.resolve())<br/>    .listen(parseInt(process.env.PORT || '3000', 10));</span></pre><h2 id="8260" class="jz ka hu bd kf kg kh ki kj kk kl km kn jc ko kp kq jg kr ks kt jk ku kv kw kx dt translated">package.json</h2><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="173e" class="jz ka hu jv b fv kb kc l kd ke">"scripts": {<br/>  "start": "node bin/www"<br/>}</span></pre><p id="b659" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，它是100%基于承诺的框架——内核中没有阻塞动作。</p><h2 id="c177" class="jz ka hu bd kf kg kh ki kj kk kl km kn jc ko kp kq jg kr ks kt jk ku kv kw kx dt translated">像中间件一样的承诺</h2><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="8fc2" class="jz ka hu jv b fv kb kc l kd ke">app.then(async ctx =&gt; {<br/><br/>  ctx.res.end('test');<br/><br/>  return app.reject(); // the same as Promise.reject()<br/><br/>}).then(async () =&gt; {<br/><br/>  // it wont work<br/><br/>}).catch(async () =&gt; {<br/><br/>  // it wont work<br/><br/>});</span></pre><p id="a7c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以自己查看一下<a class="ae jp" href="https://github.com/evheniy/yeps-benchmark" rel="noopener ugc nofollow" target="_blank">基准测试结果</a>。我用<a class="ae jp" href="https://raw.githubusercontent.com/evheniy/yeps-benchmark/master/reports/koa2_middleware.txt" rel="noopener ugc nofollow" target="_blank"> koa </a>和<a class="ae jp" href="https://raw.githubusercontent.com/evheniy/yeps-benchmark/master/reports/express_middleware.txt" rel="noopener ugc nofollow" target="_blank"> express </a>测试了<a class="ae jp" href="https://raw.githubusercontent.com/evheniy/yeps-benchmark/master/reports/yeps_middleware.txt" rel="noopener ugc nofollow" target="_blank"> YEPS </a>。</p><p id="01f5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">YEPS提供了使用Promise.all()以并行模式执行模块的可能性。</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="0272" class="jz ka hu jv b fv kb kc l kd ke">const App = require('yeps');<br/>const app = new App();<br/>const error = require('yeps-error');<br/>const logger = require('yeps-logger');<br/><br/>app.all([<br/>    logger(),<br/>    error()<br/>]);<br/><br/>app.then(async ctx =&gt; {<br/>    ctx.res.writeHead(200, {'Content-Type': 'text/plain'});<br/>    ctx.res.end('Ok');<br/>});<br/><br/>app.catch(async (err, ctx) =&gt; {<br/>    ctx.res.writeHead(500);<br/>    ctx.res.end(err.message);<br/>});</span></pre><p id="65c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="0663" class="jz ka hu jv b fv kb kc l kd ke">app.all([<br/>    logger(),<br/>    error()<br/>]).then(async ctx =&gt; {<br/>    ctx.res.writeHead(200, {'Content-Type': 'text/plain'});<br/>    ctx.res.end('Ok');<br/>}).catch(async (err, ctx) =&gt; {<br/>    ctx.res.writeHead(500);<br/>    ctx.res.end(err.message);<br/>});</span></pre><p id="8276" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你需要连接到数据库，做一些其他的东西，比如注册日志系统，错误处理程序等等，这是很有用的</p><p id="3d01" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样的想法我们可以用于路由。你不需要像对于express一样，去想哪个路由器最受欢迎，放得更高。我们可以同时开始检查所有路由器，如果找到了就拒绝检查。</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="5e83" class="jz ka hu jv b fv kb kc l kd ke">const Router = require('yeps-router');<br/>const router = new Router();<br/><br/>router.catch({ method: 'GET', url: '/' }).then(async ctx =&gt; {<br/>    ctx.res.writeHead(200);<br/>    ctx.res.end('homepage');     <br/>});<br/><br/>router.get('/test').then(async ctx =&gt; {<br/>    ctx.res.writeHead(200);<br/>    ctx.res.end('test');     <br/>}).post('/test/:id').then(async ctx =&gt; {<br/>    ctx.res.writeHead(200);<br/>    ctx.res.end(ctx.request.params.id);<br/>});<br/><br/>app.then(router.resolve());</span></pre><p id="52cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后但同样重要的是，如果你已经有了一些express中间件，你可以使用<a class="ae jp" href="https://github.com/evheniy/yeps-express-wrapper" rel="noopener ugc nofollow" target="_blank"> express wrapper </a>，这很容易移植，只需查看<a class="ae jp" href="https://www.npmjs.com/search?q=yeps" rel="noopener ugc nofollow" target="_blank"> YEPS模块</a>。</p><p id="2e3d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还有一些例子:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="2134" class="jz ka hu jv b fv kb kc l kd ke">const App = require('yeps');<br/>const server = require('yeps-server');<br/>const app = new App();<br/>const error = require('yeps-error');<br/>const Router = require('yeps-router');<br/>const router = new Router();<br/>const wrapper = require('yeps-express-wrapper');<br/>const path = require('path');</span><span id="9c93" class="jz ka hu jv b fv ky kc l kd ke">// express middleware<br/>const bodyParser = require('body-parser');<br/>const favicon = require('serve-favicon');<br/><br/>app.then(wrapper(favicon(path.join(__dirname, 'public', 'favicon.ico'))));</span><span id="c223" class="jz ka hu jv b fv ky kc l kd ke">app.all([<br/>    error(),<br/>    wrapper(bodyParser.json()),<br/>]);<br/><br/>router.get('/').then(async ctx =&gt; {<br/>    console.log(ctx.req.body);<br/>    ctx.res.writeHead(200);<br/>    ctx.res.end('test');<br/>});<br/><br/>app.then(router.resolve());<br/><br/>server.createHttpServer(app);</span></pre><p id="0901" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们从node.js中获得乐趣。</p></div></div>    
</body>
</html>