<html>
<head>
<title>Building Reactive Terminal Interfaces in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用C++构建反应式终端接口</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/building-reactive-terminal-interfaces-in-c-d392ce34e649?source=collection_archive---------4-----------------------#2017-08-21">https://medium.com/hackernoon/building-reactive-terminal-interfaces-in-c-d392ce34e649?source=collection_archive---------4-----------------------#2017-08-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="1d5d" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">TL；速度三角形定位法(dead reckoning)</h2></div><p id="c61b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">使用函数式编程技术，我们可以很容易地用C++中的动态组件构建漂亮的终端。RxTerm 是一个C++库，为实现这个概念提供了一些必要的构建模块。</p><p id="7b52" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们在《T4》中应用了同样的想法。这是结果:</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff kg"><img src="../Images/604031d144fcce7af8b13bb125f99d41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*G897-DuUI_0q6W9VKcIjZg.gif"/></div></div></figure><h1 id="93cb" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">动机</h1><p id="9512" class="pw-post-body-paragraph jj jk hu jl b jm lk iv jo jp ll iy jr js lm ju jv jw ln jy jz ka lo kc kd ke hn dt translated">假设我们想要构建一个基于文本的应用程序，当控制台的状态改变时，它会更新控制台。Curl就是一个很好的例子，它提供了一个实时的下载进度条。在你的终端上试试这个:</p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="lp lq l"/></div></figure><p id="ef06" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这些接口是使用<a class="ae kf" href="https://en.wikipedia.org/wiki/ANSI_escape_code" rel="noopener ugc nofollow" target="_blank"> ANSI转义码</a>实现的。这些是有副作用的不可见字符，例如擦除字符和移动光标。</p><p id="5a87" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以使用这些转义码来创建实时文本界面。一个简单的实现可能会像这样更新进度条:</p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="lp lq l"/></div></figure><p id="fa72" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">到目前为止还不错，但如果我们有更复杂的情况呢？理想情况下，我们会利用一个为我们解决这些问题的库。我们应该只需要指定终端输出应该是什么样子，库函数会计算出要打印的字符。</p><p id="7b05" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，在高层次上，我们需要三样东西:</p><p id="e047" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">1.跟踪控制台<br/> 2先前状态的变量。用于呈现当前应用状态的功能<br/> 3。将控制台从前一状态转换到下一状态的功能</p><p id="118d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">开发人员将会熟悉这种模式。这是一个聪明的策略，实际上可以应用于任何I/O设备！</p><p id="033b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">此外，我们希望能够将可重用的UI组件用于进度条、列表等等。类似HTML的东西，但是更简单，将是理想的。组件可以是能够呈现到控制台输出的任何对象。</p><h1 id="97be" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">简单的API示例</h1><p id="927d" class="pw-post-body-paragraph jj jk hu jl b jm lk iv jo jp ll iy jr js lm ju jv jw ln jy jz ka lo kc kd ke hn dt translated">为了了解我们要去哪里，让我们看一下<a class="ae kf" href="https://github.com/LoopPerfect/rxterm" rel="noopener ugc nofollow" target="_blank"> RxTerm </a>中的一个例子。通过RxTerm，我们可以使用组合将基本的终端组件变成更复杂的组件。如果应用程序状态改变，那么我们为终端计算一个新的视图，并替换当前可见的输出。</p><p id="8fe4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个例子展示了我们如何设计一个名为<code class="eh lr ls lt lu b">fancyCounter</code>的新组件，它像这样打印帧:</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div class="fe ff lv"><img src="../Images/c8f62713878b1524838d4cc44c9da868.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*SI86FEWso3OOTMRMRq0mBQ.png"/></div></figure><p id="7af5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">代码如下:</p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="lp lq l"/></div></figure><p id="4f10" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如你所见，界面非常高级。</p><h1 id="9e7f" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">ANSI转义码</h1><p id="5a18" class="pw-post-body-paragraph jj jk hu jl b jm lk iv jo jp ll iy jr js lm ju jv jw ln jy jz ka lo kc kd ke hn dt translated">让我们从基础开始。我们如何使用ANSI转义码来改变颜色和删除一行？</p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="lp lq l"/></div></figure><p id="f339" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">该功能以红色打印<code class="eh lr ls lt lu b">Hello</code>,然后以默认颜色打印<code class="eh lr ls lt lu b">World</code>。神奇的转义序列(<code class="eh lr ls lt lu b">\e[31m</code>和<code class="eh lr ls lt lu b">\e[0m</code>)修改终端显示字符的方式。</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div class="fe ff lw"><img src="../Images/239586d29a7872038b2cea9be500df66.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*oHYqblbx2XK2G_CjqQz4Pw.png"/></div></figure><p id="993e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">转义序列以<code class="eh lr ls lt lu b">\e[</code>开始，后跟分号分隔的修饰符列表，以<code class="eh lr ls lt lu b">m</code>结束。例如，<code class="eh lr ls lt lu b">\e[3;31;42mTEXT</code>会在蓝色背景上用红色斜体打印<code class="eh lr ls lt lu b">TEXT</code>。</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div class="fe ff lx"><img src="../Images/29f6b5bfef5fab1c3c68f35806f6ff07.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/1*tgh0Zel2v4ZMYqXAy7S0sQ.png"/></div></figure><p id="c7c9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们也可以打印<code class="eh lr ls lt lu b">\e[0m</code>将终端重置回默认状态。</p><p id="2e3b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可以在bash-hackers.org找到一份完整的清单。</p><h1 id="f392" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">抽象终端状态</h1><p id="0c38" class="pw-post-body-paragraph jj jk hu jl b jm lk iv jo jp ll iy jr js lm ju jv jw ln jy jz ka lo kc kd ke hn dt translated">为了能够组合组件，我们需要控制台状态的高级表示。因为我们想要支持颜色，所以直观的表示是从坐标到像素的映射:</p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="lp lq l"/></div></figure><p id="03ec" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一旦我们有了组件的基本抽象，<br/>我们就可以利用类型删除来维护值语义，并使继承成为实现细节:</p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="lp lq l"/></div></figure><p id="dad5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，我们可以构建更高阶的组件，如<code class="eh lr ls lt lu b">Text</code>对象:</p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="lp lq l"/></div></figure><p id="987a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可以在这里找到实际的实现<a class="ae kf" href="https://github.com/LoopPerfect/rxterm/blob/master/rxterm/include/components/text.hpp" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="5ea6" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">执行状态转换</h1><p id="968f" class="pw-post-body-paragraph jj jk hu jl b jm lk iv jo jp ll iy jr js lm ju jv jw ln jy jz ka lo kc kd ke hn dt translated">想象一下，我们想从这里开始过渡:</p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="lp lq l"/></div></figure><p id="bee8" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">…对此:</p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="lp lq l"/></div></figure><p id="288e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最简单的方法是删除最近的3行并打印新行。我们可以通过打印<code class="eh lr ls lt lu b">\e[2K\r\e[1A</code> ( <code class="eh lr ls lt lu b">delete line</code>)来删除最新的一行；<code class="eh lr ls lt lu b">move cursor to the start of the line</code>；<code class="eh lr ls lt lu b">move cursor up one line</code>)。</p><p id="93fa" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">更复杂的方法是计算差值并移动到目标位置，只编辑发生变化的终端像素。为了简单起见，我们将坚持第一种方法，并将移动部分合并到一个类中:</p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="lp lq l"/></div></figure><p id="aec9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><a class="ae kf" href="https://github.com/LoopPerfect/rxterm/blob/master/rxterm/include/terminal.hpp" rel="noopener ugc nofollow" target="_blank">的实际实现托管在GitHub </a>上。</p><h1 id="4efe" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">裁决</h1><p id="6cbd" class="pw-post-body-paragraph jj jk hu jl b jm lk iv jo jp ll iy jr js lm ju jv jw ln jy jz ka lo kc kd ke hn dt translated">我们看到了编写一个反应式终端框架和管理状态转换是多么容易，而且没有太多麻烦！</p><p id="10b4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可以在我们在GitHub 上的<a class="ae kf" href="https://github.com/loopperfect/rxterm" rel="noopener ugc nofollow" target="_blank"> repo中找到一些基本组件的实现。我们希望看到更多的人做漂亮的终端界面！</a></p><h2 id="07ce" class="ly kt hu bd ku lz ma mb ky mc md me lc js mf mg le jw mh mi lg ka mj mk li ml dt translated">预告:带RxCpp的FRP样式组件</h2><p id="2885" class="pw-post-body-paragraph jj jk hu jl b jm lk iv jo jp ll iy jr js lm ju jv jw ln jy jz ka lo kc kd ke hn dt translated">我们的下一篇文章将讨论如何利用<a class="ae kf" href="https://github.com/Reactive-Extensions/RxCpp" rel="noopener ugc nofollow" target="_blank"> RxCpp </a>来编写具有复杂状态管理的高度并发的应用程序。</p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="lp lq l"/></div></figure><h1 id="4878" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">关于牛仔的更多信息</h1><p id="0ba6" class="pw-post-body-paragraph jj jk hu jl b jm lk iv jo jp ll iy jr js lm ju jv jw ln jy jz ka lo kc kd ke hn dt translated">我们创造了<a class="ae kf" href="https://buckaroo.pm" rel="noopener ugc nofollow" target="_blank"> Buckaroo </a>来使C++代码重用更容易。在媒体上阅读更多关于<a class="ae kf" rel="noopener" href="/@buckaroo.pm/">的信息:</a></p><div class="mm mn fm fo mo mp"><a href="https://hackernoon.com/7-reasons-to-use-buck-build-5b44d7413585" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab ej"><div class="mr ab ms cl cj mt"><h2 class="bd hv fv z el mu eo ep mv er et ht dt translated">使用降压构建的7个理由</h2><div class="mw l"><h3 class="bd b fv z el mu eo ep mv er et ek translated">Buck是一个跨平台、跨语言构建系统，在脸书为大规模编译而设计。所有牛仔…</h3></div><div class="mx l"><p class="bd b gc z el mu eo ep mv er et ek translated">hackernoon.com</p></div></div></div></a></div><div class="mm mn fm fo mo mp"><a href="https://hackernoon.com/approaches-to-c-dependency-management-or-why-we-built-buckaroo-26049d4646e7" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab ej"><div class="mr ab ms cl cj mt"><h2 class="bd hv fv z el mu eo ep mv er et ht dt translated">C++依赖管理的方法，或者我们为什么要建立Buckaroo</h2><div class="mw l"><h3 class="bd b fv z el mu eo ep mv er et ek translated">C++是一种不寻常的语言，因为它还没有一个占主导地位的包管理器(我们正在努力！).结果是…</h3></div><div class="mx l"><p class="bd b gc z el mu eo ep mv er et ek translated">hackernoon.com</p></div></div><div class="my l"><div class="mz l na nb nc my nd kq mp"/></div></div></a></div><div class="mm mn fm fo mo mp"><a href="https://hackernoon.com/6-reasons-why-we-distribute-c-libraries-as-source-code-2dc614d5ef1e" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab ej"><div class="mr ab ms cl cj mt"><h2 class="bd hv fv z el mu eo ep mv er et ht dt translated">我们将C++库作为源代码发布的6个原因</h2><div class="mw l"><h3 class="bd b fv z el mu eo ep mv er et ek translated">编写C++应用程序时，不可避免地会用到外部库。这是好事！代码重用…</h3></div><div class="mx l"><p class="bd b gc z el mu eo ep mv er et ek translated">hackernoon.com</p></div></div><div class="my l"><div class="ne l na nb nc my nd kq mp"/></div></div></a></div></div></div>    
</body>
</html>