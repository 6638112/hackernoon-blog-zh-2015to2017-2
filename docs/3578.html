<html>
<head>
<title>Crafting perfect Java Docker build flow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打造完美的Java Docker构建流程</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/crafting-perfect-java-docker-build-flow-740f71638d63?source=collection_archive---------3-----------------------#2017-04-10">https://medium.com/hackernoon/crafting-perfect-java-docker-build-flow-740f71638d63?source=collection_archive---------3-----------------------#2017-04-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir is it"><p id="0554" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">在Docker容器中，你至少需要<strong class="ix hv">构建</strong>、<strong class="ix hv">测试</strong>和<strong class="ix hv">运行</strong>我的Java应用程序？</p><p id="79d8" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><strong class="ix hv"> <em class="hu">菜谱:</em> </strong> <em class="hu">为每个步骤创建一个单独的Docker映像，并优化您运行它的方式。</em></p></blockquote><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff jt"><img src="../Images/845b6613490b9f782aaf61165ad12934.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9lNH1CDamn_cbI5D.png"/></div></div></figure><h1 id="30d7" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">介绍</h1><p id="ea78" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf lf lg ji jj lh li jm jn lj lk jq jr js hn dt translated">我在1998年开始使用<a class="ae ll" href="https://hackernoon.com/tagged/java" rel="noopener ugc nofollow" target="_blank"> Java </a>，在很长一段时间里，它是我主要的<a class="ae ll" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>语言。这是一段漫长的又爱又恨的关系。</p><p id="4b28" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">在我的工作生涯中，我用Java写了很多代码。尽管如此，我不认为Java通常是编写运行在Docker容器中的微服务的正确选择。</p><p id="d879" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">但是，有时你必须使用Java。也许Java是您最喜欢的语言，但您不想学习新的语言，或者您有需要维护的遗留代码，或者您的公司决定使用Java，而您没有其他选择。</p><p id="612d" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">不管你有什么理由<strong class="ix hv"> <em class="iw">要和码头工人</em> </strong>结婚，你最好<strong class="ix hv"> <em class="iw">做好</em> </strong>。</p><p id="d21c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">在这篇文章中，我将向您展示如何创建一个有效的Java-Docker构建管道来一致地生成小型、高效和安全的Docker映像。</p><h1 id="525d" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">当心</h1><p id="b62e" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf lf lg ji jj lh li jm jn lj lk jq jr js hn dt translated">有很多<em class="iw">“Docker for Java developers”</em>教程，无意中鼓励了一些Docker的坏习惯。</p><p id="66d5" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated"><em class="iw">例如:</em></p><ul class=""><li id="0fb8" class="lm ln hu ix b iy iz jc jd lf lo lh lp lj lq js lr ls lt lu dt translated"><a class="ae ll" href="https://sparktutorials.github.io/2015/04/14/getting-started-with-spark-and-docker.html" rel="noopener ugc nofollow" target="_blank"> Spark和Docker教程</a></li><li id="80e6" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated"><a class="ae ll" href="https://examples.javacodegeeks.com/devops/docker/introduction-docker-java-developers/" rel="noopener ugc nofollow" target="_blank">面向Java开发人员的Docker简介</a></li><li id="f3b4" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated"><a class="ae ll" href="http://www.developer.com/java/data/using-java-with-docker-engine.html" rel="noopener ugc nofollow" target="_blank">通过Docker引擎使用Java</a></li><li id="d30c" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated">还有其他人…</li></ul><p id="b3d5" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">对于当前的演示项目，前两个教程花了大约15分钟来构建(第一次构建)，并生成了每个大小为<strong class="ix hv"> 1.3GB </strong>的图像。</p><blockquote class="ir is it"><p id="bf56" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">帮自己一个忙，不要跟着这些教程走！</em></p></blockquote><h1 id="b907" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">关于Docker你应该知道什么？</h1><p id="05e9" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf lf lg ji jj lh li jm jn lj lk jq jr js hn dt translated">不熟悉Docker的开发人员通常会认为它只是另一个VM。而是把Docker想象成一个“子进程”。整个VM所需的文件和包不同于运行dev机器的另一个进程所需的文件和包。Docker甚至比子进程更好，因为它允许更好的隔离和环境控制。</p><p id="d50a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">如果你是Docker的新手，我建议你阅读这篇<a class="ae ll" href="https://docs.docker.com/engine/understanding-docker/" rel="noopener ugc nofollow" target="_blank">了解Docker </a>的文章。Docker并不复杂，任何开发人员都不应该理解它是如何工作的。</p><h1 id="c2f0" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">Dockerizing Java应用程序</h1><h2 id="b2d4" class="ma kg hu bd kh mb mc md kl me mf mg kp lf mh mi kt lh mj mk kx lj ml mm lb mn dt translated">Java应用程序的Docker映像中需要包含哪些文件？</h2><p id="cbf8" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf lf lg ji jj lh li jm jn lj lk jq jr js hn dt translated">因为Docker容器只是独立的进程，所以Java Docker映像应该只包含运行应用程序所需的文件。</p><p id="73f1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated"><em class="iw">这些文件是什么？</em></p><p id="fe61" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">它始于一个Java运行时环境(<strong class="ix hv"> JRE </strong>)。JRE是一个软件包，拥有运行Java程序所需的一切。它包括Java虚拟机(<strong class="ix hv"> JVM </strong>)的实现和<em class="iw"> Java类库</em>的实现。</p><p id="075d" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">我推荐使用<a class="ae ll" href="http://openjdk.java.net/" rel="noopener ugc nofollow" target="_blank"> OpenJDK </a> JRE。OpenJDK是在<a class="ae ll" href="https://en.wikipedia.org/wiki/GNU_General_Public_License" rel="noopener ugc nofollow" target="_blank"> GPL </a>下授权的，带有<a class="ae ll" href="http://www.gnu.org/software/classpath/license.html" rel="noopener ugc nofollow" target="_blank">类路径异常</a>。<em class="iw">类路径异常</em>部分很重要。这个许可证允许OpenJDK与任何许可证的任何软件一起使用，而不仅仅是GPL。特别是，您可以在专有软件中使用OpenJDK，而无需公开您的代码。</p><p id="f145" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">在使用甲骨文的JDK/JRE之前，请先阅读以下帖子:<a class="ae ll" href="http://blog.takipi.com/running-java-on-docker-youre-breaking-the-law/" rel="noopener ugc nofollow" target="_blank">《在Docker上运行Java？你违反了法律。”</a></p><p id="c099" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">因为很少使用标准库来开发Java应用程序，所以很可能还需要添加第三方Java库。然后将应用程序编译的字节码作为普通的<em class="iw"> Java类</em>文件或者打包到<em class="iw"> JAR </em>档案中。而且，如果您使用本机代码，您也需要添加相应的本机库/包。</p><h1 id="d851" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">为Java应用程序选择基本Docker映像</h1><p id="e555" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf lf lg ji jj lh li jm jn lj lk jq jr js hn dt translated">为了选择基本Docker图像，您需要回答以下问题:</p><ul class=""><li id="875c" class="lm ln hu ix b iy iz jc jd lf lo lh lp lj lq js lr ls lt lu dt translated">你的Java应用需要哪些原生包？</li><li id="3154" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated">你应该选择Ubuntu还是Debian作为你的基本映像？</li><li id="94e9" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated"><em class="iw">您修补安全漏洞的策略是什么，包括您根本不使用的软件包？</em></li><li id="2e66" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated">你介意为网络流量和未使用文件的存储支付额外费用(金钱和时间)吗？</li></ul><p id="49ff" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">有些人可能会说:<em class="iw">“但是，如果你所有的图像共享相同的Docker层，你只需下载一次，对吗？”</em></p><p id="4352" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">理论上是<em class="iw">真的</em>，但现实中往往大相径庭。</p><p id="85cd" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">通常，你有许多不同的图像:一些是你最近创建的，另一些是很久以前的，还有一些是你从DockerHub上下载的。所有这些映像不共享相同的基础映像或版本。您需要投入大量时间来对齐这些图像以共享相同的基础图像，然后保持这些图像是最新的。</p><p id="fb7c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">也许有人会说:<em class="iw">“但是，谁在乎图像大小呢？我们只需下载一次，就可以永远运行。</em></p><p id="7f6d" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">Docker图像大小其实很重要。</p><p id="cd52" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">尺寸对…有影响</p><ul class=""><li id="3169" class="lm ln hu ix b iy iz jc jd lf lo lh lp lj lq js lr ls lt lu dt translated"><strong class="ix hv">网络延迟</strong> —需要通过网络传输Docker图像</li><li id="c744" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated"><strong class="ix hv">存储</strong> —需要将所有这些位存储在某个地方</li><li id="c644" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated"><strong class="ix hv">服务可用性和弹性</strong> —使用Docker调度程序时，如Kubernetes、Swarm、DC/OS或其他(调度程序可以在主机之间移动容器)</li><li id="8c66" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated"><strong class="ix hv">安全性</strong>——我的意思是，您真的需要libpng包及其所有的<a class="ae ll" href="https://www.cvedetails.com/vulnerability-list/vendor_id-7294/Libpng.html" rel="noopener ugc nofollow" target="_blank"> CVE漏洞</a>用于您的Java应用程序吗？</li><li id="b885" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated"><strong class="ix hv">开发灵活性</strong> —小型Docker映像==更快的构建时间和更快的部署</li></ul><p id="08e8" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">如果不小心的话，Java Docker图像会变得非常大。我见过3GB的Java映像，其中真正的代码和所需的JAR库只占用大约150MB。</p><p id="7376" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">考虑使用<a class="ae ll" href="https://hub.docker.com/_/alpine/" rel="noopener ugc nofollow" target="_blank"> Alpine Linux映像</a>，它只是一个5mb的映像，作为基本Docker映像。许多“官方码头工人图像”都带有阿尔卑斯山的味道。</p><p id="18d6" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated"><strong class="ix hv">注意</strong>:很多但不是所有的Linux包都有用<code class="eh mo mp mq mr b">musl libc</code> C运行时库编译的版本。有时候你想用一个用<code class="eh mo mp mq mr b">glibc</code> (GNU C运行时库)编译的包。<a class="ae ll" href="https://hub.docker.com/r/frolvlad/alpine-glibc/" rel="noopener ugc nofollow" target="_blank"> frolvlad/alpine-glibc </a>镜像基于alpine Linux镜像，包含<code class="eh mo mp mq mr b">glibc</code>以启用专有项目，针对<code class="eh mo mp mq mr b">glibc</code>编译(例如OracleJDK、Anaconda)，在Alpine上工作。</p><h1 id="5335" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">选择正确的Java应用服务器</h1><p id="042b" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf lf lg ji jj lh li jm jn lj lk jq jr js hn dt translated">通常，您还需要公开某种接口来访问运行在Docker容器中的Java应用程序。</p><p id="39be" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">当您使用Docker容器部署Java应用程序时，默认的Java部署模型会发生变化。</p><p id="85a5" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">最初，Java服务器端部署假设您已经预先配置了一个Java Web服务器(Tomcat、WebLogic、JBoss或其他)，并且您正在将一个应用程序<strong class="ix hv"> WAR </strong> (Web Archive)打包的Java应用程序部署到此服务器上，并将其与其他应用程序一起运行，部署在同一服务器上。</p><p id="bcfb" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">围绕这个概念开发了许多工具，允许您在不停止Java Application服务器的情况下更新正在运行的应用程序、将流量路由到新应用程序、解决可能的类加载冲突等等。</p><p id="bf51" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">通过基于Docker的部署，您不再需要这些工具，甚至不需要庞大的“企业就绪”Java Application服务器。唯一需要的是一个稳定且可扩展的网络服务器，它可以通过HTTP/TCP或您选择的其他协议为您的API提供服务。在谷歌上搜索<a class="ae ll" href="https://www.google.com/search?q=" rel="noopener ugc nofollow" target="_blank">“嵌入式Java服务器”</a>，然后选一台你最喜欢的。</p><p id="77e0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">在这个演示中，我分叉了<a class="ae ll" href="https://github.com/khoubyari/spring-boot-rest-example" rel="noopener ugc nofollow" target="_blank"> Spring Boot的REST示例</a>，并对其进行了一些修改。演示使用的是带有嵌入式Tomcat服务器的<a class="ae ll" href="https://projects.spring.io/spring-boot/" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a>。这是我在GitHub存储库(<code class="eh mo mp mq mr b">blog</code>分支)上的<a class="ae ll" href="https://github.com/alexei-led/spring-boot-rest-example" rel="noopener ugc nofollow" target="_blank">分叉</a>。</p><h1 id="58a5" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">构建Java应用程序Docker映像</h1><p id="cd57" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf lf lg ji jj lh li jm jn lj lk jq jr js hn dt translated">为了运行这个演示，我需要用JRE、编译和打包的Java应用程序以及所有第三方库创建一个Docker映像。</p><p id="e141" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">这是我用来塑造码头工人形象的“T1”。这个演示Docker映像基于带有OpenJDK JRE的slim Alpine Linux，并且包含应用程序WAR文件及其嵌入的所有依赖项。这只是运行演示应用程序所需的最低要求。</p><pre class="ju jv jw jx fq ms mr mt mu aw mv dt"><span id="9b70" class="ma kg hu mr b fv mw mx l my mz"># Base Alpine Linux based image with OpenJDK JRE only <br/>FROM openjdk:8-jre-alpine </span><span id="f241" class="ma kg hu mr b fv na mx l my mz"># copy application WAR (with libraries inside) <br/>COPY target/spring-boot-*.war /app.war </span><span id="ab37" class="ma kg hu mr b fv na mx l my mz"># specify default command <br/>CMD ["/usr/bin/java", "-jar", "-Dspring.profiles.active=test", "/app.war"]</span></pre><p id="2d5f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">要生成Docker映像，请运行以下命令:</p><pre class="ju jv jw jx fq ms mr mt mu aw mv dt"><span id="ea4d" class="ma kg hu mr b fv mw mx l my mz">$ docker build -t blog/sbdemo:latest .</span></pre><p id="99c0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">对已创建的Docker图像运行<code class="eh mo mp mq mr b">docker history</code>命令将允许您查看构成该图像的所有层:</p><ul class=""><li id="1e7b" class="lm ln hu ix b iy iz jc jd lf lo lh lp lj lq js lr ls lt lu dt translated"><strong class="ix hv"> 4.8MB </strong> Alpine Linux层</li><li id="3e7c" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated"><strong class="ix hv"> 103MB </strong> OpenJDK JRE层</li><li id="1534" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated"><strong class="ix hv"> 61.8MB </strong>应用WAR文件</li></ul><pre class="ju jv jw jx fq ms mr mt mu aw mv dt"><span id="b7a7" class="ma kg hu mr b fv mw mx l my mz">$ docker history blog/sbdemo:latest <br/>IMAGE CREATED CREATED BY SIZE COMMENT <br/>16d5236aa7c8 About an hour ago /bin/sh -c #(nop) CMD ["/usr/bin/java" "-... 0 B <br/>e1bbd125efc4 About an hour ago /bin/sh -c #(nop) COPY file:1af38329f6f390... 61.8 MB <br/>d85b17c6762e 2 months ago /bin/sh -c set -x &amp;&amp; apk add --no-cache ... 103 MB <br/>&lt;missing&gt; 2 months ago /bin/sh -c #(nop) ENV JAVA_ALPINE_VERSION... 0 B <br/>&lt;missing&gt; 2 months ago /bin/sh -c #(nop) ENV JAVA_VERSION=8u111 0 B <br/>&lt;missing&gt; 2 months ago /bin/sh -c #(nop) ENV PATH=/usr/local/sbi... 0 B <br/>&lt;missing&gt; 2 months ago /bin/sh -c #(nop) ENV JAVA_HOME=/usr/lib/... 0 B <br/>&lt;missing&gt; 2 months ago /bin/sh -c { echo '#!/bin/sh'; echo 's... 87 B <br/>&lt;missing&gt; 2 months ago /bin/sh -c #(nop) ENV LANG=C.UTF-8 0 B <br/>&lt;missing&gt; 2 months ago /bin/sh -c #(nop) ADD file:eeed5f514a35d18... 4.8 MB</span></pre><h1 id="d252" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">运行Java应用程序Docker容器</h1><p id="0206" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf lf lg ji jj lh li jm jn lj lk jq jr js hn dt translated">要运行演示应用程序，请运行以下命令:</p><pre class="ju jv jw jx fq ms mr mt mu aw mv dt"><span id="68f2" class="ma kg hu mr b fv mw mx l my mz">$ docker run -d --name demo-default -p 8090:8090 -p 8091:8091 blog/sbdemo:latest</span></pre><p id="dd7f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">让我们检查一下，该应用程序是否已启动并正在运行(这里我使用的是<code class="eh mo mp mq mr b">httpie</code>工具):</p><pre class="ju jv jw jx fq ms mr mt mu aw mv dt"><span id="2ee1" class="ma kg hu mr b fv mw mx l my mz">$ http http://localhost:8091/info <br/>HTTP/1.1 200 OK <br/>Content-Type: application/json <br/>Date: Thu, 09 Mar 2017 14:43:28 GMT <br/>Server: Apache-Coyote/1.1 <br/>Transfer-Encoding: chunked <br/>{ <br/>  "build": { <br/>    "artifact": "${project.artifactId}", <br/>    "description": "boot-example default description", "name": "spring-boot-rest-example", <br/>    "version": "0.1" <br/>  } <br/>}</span></pre><h2 id="ea76" class="ma kg hu bd kh mb mc md kl me mf mg kp lf mh mi kt lh mj mk kx lj ml mm lb mn dt translated">设置Docker容器内存限制</h2><p id="d7a4" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf lf lg ji jj lh li jm jn lj lk jq jr js hn dt translated">关于Java进程内存分配，您需要知道的一件事是，实际上它消耗的物理内存比用<code class="eh mo mp mq mr b">-Xmx</code> JVM选项指定的要多。<code class="eh mo mp mq mr b">-Xmx</code>选项只指定最大Java堆大小。但是Java进程是一个普通的Linux进程，有趣的是这个进程消耗了多少实际的物理内存。</p><p id="c57b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">或者换句话说— <em class="iw">运行一个Java进程的</em> <strong class="ix hv"> <em class="iw">常驻集大小</em></strong><em class="iw">(</em><strong class="ix hv"><em class="iw">RSS</em></strong><em class="iw">)值是多少？</em></p><p id="47ee" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">理论上，在Java应用程序的情况下，所需的RSS大小可以通过下式计算:</p><pre class="ju jv jw jx fq ms mr mt mu aw mv dt"><span id="2f97" class="ma kg hu mr b fv mw mx l my mz"><strong class="mr hv">RSS</strong> = Heap size + MetaSpace + OffHeap size</span></pre><p id="38fd" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">其中<em class="iw">堆外</em>由线程堆栈、直接缓冲区、映射文件(库和jar)和JVM代码本身组成。</p><p id="c710" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">关于这个话题有一个非常好的帖子:<a class="ae ll" href="http://trustmeiamadeveloper.com/2016/03/18/where-is-my-memory-java/" rel="noopener ugc nofollow" target="_blank">Mikhail Krestjaninoff的《在Docker容器中分析java内存使用情况</a>。</p><p id="2ea6" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">使用<code class="eh mo mp mq mr b">docker run</code>中的<code class="eh mo mp mq mr b">--memory</code>选项时，确保限制大于(至少两倍于)您为<code class="eh mo mp mq mr b">-Xmx</code>指定的值。</p><h2 id="418d" class="ma kg hu bd kh mb mc md kl me mf mg kp lf mh mi kt lh mj mk kx lj ml mm lb mn dt translated">题外话:使用OOM黑仔代替GC</h2><p id="e035" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf lf lg ji jj lh li jm jn lj lk jq jr js hn dt translated">有一个有趣的<strong class="ix hv">阿列克谢·希皮列夫的JDK增强提案(JEP) </strong>:【艾司隆GC】(<a class="ae ll" href="http://openjdk.java.net/jeps/8174901" rel="noopener ugc nofollow" target="_blank">http://openjdk.java.net/jeps/8174901</a>)。这个JEP提议开发一个只处理内存分配的GC，但是不实现任何实际的内存回收机制。</p><p id="374b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">这个GC，结合<code class="eh mo mp mq mr b">--restart</code> (Docker重启策略)理论上应该允许支持用Java实现的“极短命的作业”。</p><p id="2737" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">对于对性能极其敏感的应用程序，开发人员会注意内存分配，或者希望创建完全无垃圾的应用程序——GC cycle可能会被认为是一个实现错误，会无缘无故地浪费周期。在这种用例中，最好允许<strong class="ix hv"> OOM黑仔</strong>(内存不足)终止进程，并使用Docker重启策略来重启进程。</p><p id="68b1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">反正<strong class="ix hv"> Epsilon GC </strong>还不可用，暂时只是一个有趣的理论用例。</p><h1 id="db2c" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">用构建器容器构建Java应用程序</h1><p id="f9dc" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf lf lg ji jj lh li jm jn lj lk jq jr js hn dt translated">正如您可能看到的，在上一步中，我没有解释如何创建应用程序WAR文件。</p><p id="a168" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">当然，还有一个Maven项目文件<code class="eh mo mp mq mr b">pom.xml</code>，大多数Java开发人员应该都很熟悉。但是，为了实际构建，你需要在每台机器上安装<em class="iw">相同的Java构建工具</em> (JDK和Maven)<em class="iw">，在那里你构建应用程序。您需要拥有相同的版本，使用相同的存储库并共享相同的配置。虽然这是tt的可能，但是管理依赖于不同工具、版本、配置和开发环境的不同项目很快就会变成一场噩梦。</em></p><p id="453b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">如果您还想在没有安装Java或Maven的干净机器上运行构建，该怎么办？<em class="iw">你该怎么办？</em></p><h1 id="c8c3" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">Java构建器容器</h1><p id="75c5" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf lf lg ji jj lh li jm jn lj lk jq jr js hn dt translated">码头工人也可以在这里帮忙。使用Docker，您可以创建和共享可移植的开发和构建环境。这个想法是创建一个特殊的<strong class="ix hv">构建器</strong> Docker镜像，它包含了你正确构建Java应用程序所需的所有工具，例如:JDK、Ant、Maven、Gradle、SBT等等。</p><p id="1e07" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">要创建一个真正有用的<strong class="ix hv"> Builder </strong> Docker映像，您需要很好地了解Java构建工具是如何工作的，以及<code class="eh mo mp mq mr b">docker build</code>如何使构建缓存失效。没有适当的设计，您将会以低效和缓慢的构建而告终。</p><h1 id="cc3d" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">在Docker中运行Maven</h1><p id="cb2b" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf lf lg ji jj lh li jm jn lj lk jq jr js hn dt translated">虽然这些工具中的大部分是在近一代人之前创建的，但它们仍然非常流行，并被Java开发人员广泛使用。</p><p id="6c55" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">如果没有一些额外的构建工具，Java开发生活是难以想象的。有多种Java构建工具，但大多数都有相似的概念并服务于相同的目标——解决繁琐的包依赖性，并运行不同的构建任务，例如，<strong class="ix hv">编译、lint、测试、打包和部署</strong>。</p><p id="b650" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">在这篇文章中，我将使用<a class="ae ll" href="https://maven.apache.org/" rel="noopener ugc nofollow" target="_blank"> Maven </a>，但是同样的方法也可以应用于<a class="ae ll" href="https://gradle.org/" rel="noopener ugc nofollow" target="_blank"> Gradle </a>、<a class="ae ll" href="http://www.scala-sbt.org/" rel="noopener ugc nofollow" target="_blank"> SBT </a>以及其他不太流行的Java构建工具。</p><p id="6cfd" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">了解Java构建工具的工作原理以及如何对其进行调优非常重要。当创建一个<strong class="ix hv"> Builder </strong> Docker映像以及运行一个<strong class="ix hv"> Builder </strong> Docker容器时，应用这些知识。</p><p id="a755" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">Maven使用项目级的<code class="eh mo mp mq mr b">pom.xml</code>文件来解析项目依赖关系。它从私有和公共Maven仓库下载丢失的<code class="eh mo mp mq mr b">JAR</code>文件，并且<em class="iw">缓存</em>这些文件用于将来的构建。因此，下次运行您的构建时，如果您的依赖关系没有被更改，它不会下载任何东西。</p><h2 id="8f0a" class="ma kg hu bd kh mb mc md kl me mf mg kp lf mh mi kt lh mj mk kx lj ml mm lb mn dt translated">官方Maven Docker图片:该不该用？</h2><p id="f3a6" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf lf lg ji jj lh li jm jn lj lk jq jr js hn dt translated">Maven团队提供了官方<a class="ae ll" href="https://hub.docker.com/r/_/maven/" rel="noopener ugc nofollow" target="_blank"> Docker图片</a>。有多个图片(在不同的标签下)允许您选择一个可以满足您需求的图片。在选择要使用的Maven映像时，深入查看一下<code class="eh mo mp mq mr b">Dockerfile</code>文件和<code class="eh mo mp mq mr b">mvn-entrypoint.sh</code> shell脚本。</p><p id="f608" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">有两种官方的Maven Docker映像:普通映像(JDK版本、Maven版本和Linux发行版)和<code class="eh mo mp mq mr b">onbuild</code>映像。</p><p id="dd4e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">官方的Maven镜像有什么用？</p><p id="c94e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">官方的Maven映像在容器化Maven工具本身方面做得很好。该图像包含一些JDK和Maven版本。使用这样的映像，您可以在任何机器上运行Maven build，而无需安装JDK和Maven。</p><p id="1882" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated"><strong class="ix hv">示例:</strong>在本地文件夹上运行<code class="eh mo mp mq mr b">mvn clean install</code></p><pre class="ju jv jw jx fq ms mr mt mu aw mv dt"><span id="8ce0" class="ma kg hu mr b fv mw mx l my mz">$ docker run -it --rm --name my-maven-project \<br/>    -v "$PWD":/usr/src/app -w /usr/src/app \<br/>    maven:3.2-jdk-7 mvn clean install</span></pre><p id="1879" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">用于官方Maven图像的Maven本地存储库位于Docker <em class="iw">数据卷</em>中。这意味着，一旦Maven容器被销毁，所有下载的依赖关系<strong class="ix hv">都不是映像</strong>的一部分，而<strong class="ix hv">也将消失</strong>。如果您不想下载每个构建的依赖项，请将Maven repository Docker卷挂载到某个持久存储上(至少是Docker主机上的本地文件夹)。</p><p id="dbd0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated"><strong class="ix hv">示例:</strong>在本地文件夹上运行<code class="eh mo mp mq mr b">mvn clean install</code>，并正确挂载Maven本地存储库</p><pre class="ju jv jw jx fq ms mr mt mu aw mv dt"><span id="542b" class="ma kg hu mr b fv mw mx l my mz">$ docker run -it --rm --name my-maven-project \<br/>    -v "$PWD":/usr/src/app -v "$HOME"/.m2:/root/.m2 \<br/>    -w /usr/src/app maven:3.2-jdk-7 mvn clean install</span></pre><p id="ad92" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">现在，让我们看看onbuild Maven Docker图像。</p><p id="ccd0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">什么是Maven <code class="eh mo mp mq mr b">onbuild</code>形象？</p><p id="df31" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">Maven <code class="eh mo mp mq mr b">onbuild</code> Docker镜像的存在是为了<em class="iw"/>简化开发者的生活，允许他/她跳过写一个<code class="eh mo mp mq mr b">Dockerfile</code>。实际上，开发人员应该编写一个<code class="eh mo mp mq mr b">Dockerfile</code>，但是通常只需要一行代码就足够了:</p><pre class="ju jv jw jx fq ms mr mt mu aw mv dt"><span id="a767" class="ma kg hu mr b fv mw mx l my mz">FROM maven:&lt;versions&gt;-onbuild</span></pre><p id="0712" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">查看GitHub存储库上的onbuild Dockerfile</p><pre class="ju jv jw jx fq ms mr mt mu aw mv dt"><span id="3539" class="ma kg hu mr b fv mw mx l my mz">FROM maven:&lt;version&gt; <br/>RUN mkdir -p /usr/src/app <br/>WORKDIR /usr/src/app <br/>ONBUILD ADD . /usr/src/app <br/>ONBUILD RUN mvn install</span></pre><p id="27e9" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">…您可以看到几个带有ONBUILD前缀的<code class="eh mo mp mq mr b">Dockerfile</code>命令。<code class="eh mo mp mq mr b">ONBUILD</code>告诉Docker推迟这些构建命令的执行，直到构建一个从当前映像继承的新映像。</p><p id="9ae0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">在我们的示例中，当您构建由<code class="eh mo mp mq mr b">FROM: maven:&lt;version&gt;-onbuild</code>创建的应用程序<code class="eh mo mp mq mr b">Dockerfile</code>时，将执行两个构建命令:</p><ul class=""><li id="a851" class="lm ln hu ix b iy iz jc jd lf lo lh lp lj lq js lr ls lt lu dt translated">将当前文件夹(所有文件，如果您没有使用<code class="eh mo mp mq mr b">.dockerignore</code>)添加到新的Docker图像</li><li id="9e03" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated">运行<code class="eh mo mp mq mr b">mvn install</code> Maven目标</li></ul><p id="171c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated"><code class="eh mo mp mq mr b">onbuild</code> Maven Docker图像没有之前的图像有用。</p><p id="26cd" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">首先，它从当前存储库中复制所有内容，所以如果没有正确配置的<code class="eh mo mp mq mr b">.dockerignore</code>文件，就不要使用它。</p><p id="d251" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">然后，思考:<em class="iw">你在努力塑造什么样的形象？</em></p><p id="698c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">从<code class="eh mo mp mq mr b">onbuild</code> Maven Docker映像创建的新映像包括JDK、Maven、应用程序代码(可能还有来自当前目录的<strong class="ix hv">所有文件</strong>)和<strong class="ix hv">Maven<code class="eh mo mp mq mr b">install</code>阶段产生的所有文件</strong>(编译、测试和打包的app加上许多您并不真正需要的构建垃圾文件)。</p><p id="bb36" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">因此，这个Docker映像包含了所有内容，但是，出于某种奇怪的原因，它不包含本地Maven存储库。我不知道为什么Maven团队创建了这个图像。</p><blockquote class="ir is it"><p id="6ca2" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><strong class="ix hv"> <em class="hu">推荐:</em> </strong> <em class="hu">不要使用Maven</em><strong class="ix hv"><em class="hu">onbuild</em></strong><em class="hu">图片！</em></p></blockquote><p id="8380" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">如果只是想用Maven工具，就用非onbuild镜像。</p><p id="7233" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">如果你想创建一个合适的生成器图像，我会在这篇文章的后面告诉你怎么做。</p><h2 id="e18b" class="ma kg hu bd kh mb mc md kl me mf mg kp lf mh mi kt lh mj mk kx lj ml mm lb mn dt translated">Maven缓存放在哪里？</h2><p id="95cb" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf lf lg ji jj lh li jm jn lj lk jq jr js hn dt translated">官方的Maven Docker映像选择将Maven缓存文件夹放在容器之外，使用<code class="eh mo mp mq mr b">Dockerfile</code>中的<code class="eh mo mp mq mr b">VOLUME root/.m2</code>命令将其暴露为Docker <em class="iw">数据卷</em>。Docker数据卷是一个或多个容器中的目录，它绕过了Docker Union文件系统，简而言之:它不是Docker映像的一部分。</p><p id="eaf1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">关于Docker <em class="iw">数据卷</em>你应该知道的:</p><ul class=""><li id="8499" class="lm ln hu ix b iy iz jc jd lf lo lh lp lj lq js lr ls lt lu dt translated">创建容器时会初始化卷。</li><li id="9b47" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated">数据卷可以在容器之间共享和重用。</li><li id="f76c" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated">对数据卷的更改直接在装载的端点上进行(通常是主机上的某个目录，但也可以是某个存储设备)</li><li id="7dca" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated">更新映像或保存Docker容器时，不会包括对数据卷的更改。</li><li id="e77a" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated">即使容器本身被删除，数据卷仍然存在。</li></ul><p id="3f79" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">因此，为了在不同的构建之间重用Maven缓存，将Maven缓存数据卷挂载到持久存储中(例如，Docker主机上的本地目录)。</p><pre class="ju jv jw jx fq ms mr mt mu aw mv dt"><span id="fe8f" class="ma kg hu mr b fv mw mx l my mz">$ docker run -it --rm --volume "$PWD"/pom.xml:/usr/src/app/pom.xml \<br/>     --volume "$HOME"/.m2:/root/.m2 maven:3-jdk-8-alpine mvn install</span></pre><p id="c8ef" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">上面的命令运行官方的Maven Docker映像(Maven 3和OpenJDK 8)，将项目<code class="eh mo mp mq mr b">pom.xml</code>文件挂载到Maven <em class="iw">缓存数据卷</em>的工作目录和<code class="eh mo mp mq mr b">$HOME"/.m2</code>文件夹中。在这个Docker容器中运行的Maven会将所有需要的JAR文件下载到主机的本地</p><p id="f3d0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">在这个Docker容器中运行的Maven会将所有需要的<code class="eh mo mp mq mr b">JAR</code>文件下载到主机的本地文件夹<code class="eh mo mp mq mr b">$HOME/.m2</code>中。下次您为相同的<code class="eh mo mp mq mr b">pom.xml</code>文件和相同的<em class="iw">缓存</em>挂载创建新的Maven Docker容器时，Maven将重用<em class="iw">缓存</em>，并将只下载缺失或更新的<code class="eh mo mp mq mr b">JAR</code>文件。</p><h2 id="12bf" class="ma kg hu bd kh mb mc md kl me mf mg kp lf mh mi kt lh mj mk kx lj ml mm lb mn dt translated">Maven Builder Docker图像</h2><p id="9577" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf lf lg ji jj lh li jm jn lj lk jq jr js hn dt translated">先来试着公式化<em class="iw">什么是</em> <strong class="ix hv"> <em class="iw">建设者</em> </strong> <em class="iw">码头工人形象，它应该包含什么？</em></p><blockquote class="ir is it"><p id="639a" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><strong class="ix hv"> <em class="hu"> Builder </em> </strong> <em class="hu">是一个Docker映像，它包含了</em> <strong class="ix hv"> <em class="hu">的所有内容</em> </strong> <em class="hu">，允许您在任何机器上、任何时间点创建可重现的构建。</em></p></blockquote><p id="d0ad" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">那么，<em class="iw">它应该包含什么呢？</em></p><ul class=""><li id="eebe" class="lm ln hu ix b iy iz jc jd lf lo lh lp lj lq js lr ls lt lu dt translated"><em class="iw"> Linux shell和一些工具</em> —我更喜欢Alpine Linux</li><li id="b56e" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated"><em class="iw"> JDK(版本)</em>—<code class="eh mo mp mq mr b">javac</code>编译器</li><li id="fa96" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated"><em class="iw"> Maven(版本)</em> — Java构建工具</li><li id="a88c" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated"><em class="iw">应用源代码</em>和<code class="eh mo mp mq mr b">pom.xml</code>文件/秒——是特定时间点的应用代码<code class="eh mo mp mq mr b">SNAPSHOT</code>；只是代码，不需要包含一个<code class="eh mo mp mq mr b">.git</code>库或其他文件</li><li id="0c0f" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated"><em class="iw">项目依赖关系(Maven本地存储库)</em> —您需要构建和测试Java应用程序的所有<code class="eh mo mp mq mr b">POM</code>和<code class="eh mo mp mq mr b">JAR</code>文件，在任何时候，即使离线，即使库从网络上消失</li></ul><p id="7910" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated"><strong class="ix hv">构建器</strong>映像在特定时间点捕获代码、依赖项和工具，并将它们存储在Docker映像中。<strong class="ix hv">构建器</strong>容器可用于在任何时间、任何机器上创建应用程序“二进制文件”,甚至在没有互联网连接(或连接不良)的情况下。</p><p id="3b36" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">这是我的演示<strong class="ix hv">构建器</strong>的样本<code class="eh mo mp mq mr b">Dockerfile</code>:</p><pre class="ju jv jw jx fq ms mr mt mu aw mv dt"><span id="cfbf" class="ma kg hu mr b fv mw mx l my mz">FROM openjdk:8-jdk-alpine <br/># ---- <br/># Install Maven <br/>RUN apk add --no-cache curl tar bash </span><span id="31f7" class="ma kg hu mr b fv na mx l my mz">ARG MAVEN_VERSION=3.3.9 <br/>ARG USER_HOME_DIR="/root" </span><span id="8230" class="ma kg hu mr b fv na mx l my mz">RUN mkdir -p /usr/share/maven &amp;&amp; \ <br/>    curl -fsSL http://apache.osuosl.org/maven/maven-3/$MAVEN_VERSION/binaries/apache-maven-$MAVEN_VERSION-bin.tar.gz | tar -xzC /usr/share/maven --strip-components=1 &amp;&amp; \ <br/>    ln -s /usr/share/maven/bin/mvn /usr/bin/mvn </span><span id="712c" class="ma kg hu mr b fv na mx l my mz">ENV MAVEN_HOME /usr/share/maven <br/>ENV MAVEN_CONFIG "$USER_HOME_DIR/.m2" </span><span id="c57c" class="ma kg hu mr b fv na mx l my mz"># speed up Maven JVM a bit <br/>ENV MAVEN_OPTS="-XX:+TieredCompilation -XX:TieredStopAtLevel=1" </span><span id="238b" class="ma kg hu mr b fv na mx l my mz">ENTRYPOINT ["/usr/bin/mvn"] </span><span id="d151" class="ma kg hu mr b fv na mx l my mz"># ---- <br/># Install project dependencies and keep sources <br/># make source folder <br/>RUN mkdir -p /usr/src/app <br/>WORKDIR /usr/src/app </span><span id="9ea7" class="ma kg hu mr b fv na mx l my mz"># install maven dependency packages (keep in image) <br/>COPY pom.xml /usr/src/app <br/>RUN mvn -T 1C install &amp;&amp; rm -rf target </span><span id="086c" class="ma kg hu mr b fv na mx l my mz"># copy other source files (keep in image) <br/>COPY src /usr/src/app/src</span></pre><p id="6b5e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">让我们回顾一下这个<code class="eh mo mp mq mr b">Dockerfile</code>，我会试着解释每个命令背后的原因。</p><ul class=""><li id="dd94" class="lm ln hu ix b iy iz jc jd lf lo lh lp lj lq js lr ls lt lu dt translated"><code class="eh mo mp mq mr b">FROM: openjdk:8-jdk-alpine</code> -选择并冻结JDK版本:OpenJDK 8和Linux Alpine</li><li id="f39a" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated">安装Maven</li><li id="6f6a" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated"><code class="eh mo mp mq mr b">ARG ...</code>——使用构建参数允许用<code class="eh mo mp mq mr b">docker build --build-arg ...</code>覆盖Maven版本和本地存储库位置(<code class="eh mo mp mq mr b">MAVEN_VERSION</code>和<code class="eh mo mp mq mr b">USER_HOME_DIR</code>)</li><li id="b381" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated"><code class="eh mo mp mq mr b">RUN mkdir -p ... curl ... tar ...</code> -下载并安装(<code class="eh mo mp mq mr b">untar</code>和<code class="eh mo mp mq mr b">ln -s</code> ) Apache Maven</li><li id="08cc" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated">把Maven JVM加速一点:<code class="eh mo mp mq mr b">MAVEN_OPTS="-XX:+TieredCompilation -XX:TieredStopAtLevel=1"</code>，看下面的<a class="ae ll" href="https://zeroturnaround.com/rebellabs/your-maven-build-is-slow-speed-it-up/" rel="noopener ugc nofollow" target="_blank">帖子</a></li><li id="c019" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated"><code class="eh mo mp mq mr b">RUN mvn -T 1C install &amp;&amp; rm -rf target</code>下载项目依赖关系:</li><li id="2444" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated">复制项目<code class="eh mo mp mq mr b">pom.xml</code>文件并运行<code class="eh mo mp mq mr b">mvn install</code>命令并移除构建工件据我所知，没有哪个Maven命令会让你不安装就下载)</li><li id="2fb0" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated">只有当项目的<code class="eh mo mp mq mr b">pom.xml</code>文件改变时，才会重新构建这个Docker图像层</li><li id="e593" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated"><code class="eh mo mp mq mr b">COPY src /usr/src/app/src</code> -复制项目源文件(源代码、测试和资源)</li></ul><p id="a989" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated"><strong class="ix hv">注意:</strong>如果你正在使用<a class="ae ll" href="http://maven.apache.org/surefire/maven-surefire-plugin" rel="noopener ugc nofollow" target="_blank"> Maven Surefire插件</a>并且想要拥有离线构建的所有依赖项，确保<a class="ae ll" href="http://maven.apache.org/surefire/maven-surefire-plugin/examples/providers.html" rel="noopener ugc nofollow" target="_blank">锁定Surefire测试提供者</a>。</p><p id="7896" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">当你构建一个新的<strong class="ix hv">构建器</strong>版本时，我建议你使用一个<code class="eh mo mp mq mr b">--cache-from</code>选项传递先前的构建器图像给它。这将允许你重用任何未修改的Docker层，并在大多数时候避免过时的下载(如果<code class="eh mo mp mq mr b">pom.xml</code>没有改变或者你没有决定升级Maven或JDK)。</p><pre class="ju jv jw jx fq ms mr mt mu aw mv dt"><span id="75de" class="ma kg hu mr b fv mw mx l my mz">$ # pull latest (or specific version) builder image <br/>$ docker pull myrep/mvn-builder:latest </span><span id="a36a" class="ma kg hu mr b fv na mx l my mz">$ # build new builder <br/>$ docker build -t myrep/mvn-builder:latest --cache-from myrep/mvn-builder:latest .</span></pre><p id="0caf" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">使用生成器容器运行测试</p><pre class="ju jv jw jx fq ms mr mt mu aw mv dt"><span id="5c81" class="ma kg hu mr b fv mw mx l my mz">$ # run tests - test results are saved into $PWD/target/surefire-reports <br/>$ docker run -it --rm -v "$PWD"/target:/usr/src/app/target myrep/mvn-builder -T 1C -o test</span></pre><p id="68ac" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">使用生成器容器创建应用程序WAR</p><pre class="ju jv jw jx fq ms mr mt mu aw mv dt"><span id="b33b" class="ma kg hu mr b fv mw mx l my mz">$ # create application WAR file (skip tests)<br/>$ docker run -it --rm -v $(shell pwd)/target:/usr/src/app/target myrep/mvn-builder package -T 1C -o -Dmaven.test.skip=true</span></pre><p id="8b2d" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">看看下面的图片:</p><pre class="ju jv jw jx fq ms mr mt mu aw mv dt"><span id="ec52" class="ma kg hu mr b fv mw mx l my mz">REPOSITORY TAG IMAGE ID CREATED SIZE <br/>sbdemo/run latest 6f432638aa60 7 minutes ago 143 MB <br/>sbdemo/tutorial 1 669333d13d71 12 minutes ago 1.28 GB <br/>sbdemo/tutorial 2 38634e4d9d5e 3 hours ago 1.26 GB <br/>sbdemo/builder mvn 2d325a403c5f 5 days ago 263 MB</span></pre><ul class=""><li id="eb42" class="lm ln hu ix b iy iz jc jd lf lo lh lp lj lq js lr ls lt lu dt translated"><code class="eh mo mp mq mr b">sbdemo/run:latest</code> -演示运行时的Docker映像:Alpine，仅OpenJDK JRE，演示WAR</li><li id="c56c" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated"><code class="eh mo mp mq mr b">sbdemo/builder:mvn</code> - <strong class="ix hv">构建器</strong> Docker镜像:Alpine，OpenJDK 8，Maven 3，代码，依赖</li><li id="b827" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated"><code class="eh mo mp mq mr b">sbdemo/tutorial:1</code> -根据第一个教程创建的Docker图像(仅供参考)</li><li id="9415" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated"><code class="eh mo mp mq mr b">sbdemo/tutorial:2</code> -根据第二个教程创建的Docker图像(仅供参考)</li></ul><h1 id="b996" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">好处:构建流程自动化</h1><p id="7fbc" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf lf lg ji jj lh li jm jn lj lk jq jr js hn dt translated">在这一节中，我将展示如何使用Docker构建流程自动化服务来自动化和编排本文中的所有步骤。</p><h1 id="3ec6" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">构建管道步骤</h1><p id="b63d" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf lf lg ji jj lh li jm jn lj lk jq jr js hn dt translated">我将使用<a class="ae ll" href="https://codefresh.io/" rel="noopener ugc nofollow" target="_blank">code fresh . io</a>Docker CI/CD服务(我工作的公司)为Maven创建一个<strong class="ix hv"> Builder </strong> Docker映像，运行测试，创建应用程序WAR，为应用程序构建Docker映像并部署到DockerHub。</p><p id="073d" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">Codefresh自动化流程<code class="eh mo mp mq mr b">YAML</code>(也称为<em class="iw">管道</em>)非常简单:</p><ul class=""><li id="05a0" class="lm ln hu ix b iy iz jc jd lf lo lh lp lj lq js lr ls lt lu dt translated">它包含有序的步骤列表</li><li id="256f" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated">每个步骤可以是以下类型:</li><li id="d819" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated">- <code class="eh mo mp mq mr b">build</code> -为<code class="eh mo mp mq mr b">docker build</code>命令</li><li id="d8fd" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated">- <code class="eh mo mp mq mr b">push</code> -为<code class="eh mo mp mq mr b">docker push</code></li><li id="9f69" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated">- <code class="eh mo mp mq mr b">composition</code> -用于创建环境，用<code class="eh mo mp mq mr b">docker-compose</code>指定</li><li id="fb7e" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated">- <code class="eh mo mp mq mr b">freestyle</code>(如果未指定，则默认)-用于<code class="eh mo mp mq mr b">docker run</code>命令</li><li id="a2a1" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated"><code class="eh mo mp mq mr b">/codefresh/volume/</code> <em class="iw">数据量</em> ( <code class="eh mo mp mq mr b">git clone</code>和步骤生成的文件)被装入每个步骤</li><li id="5fce" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js lr ls lt lu dt translated">每一步的当前工作目录默认设置为<code class="eh mo mp mq mr b">/codefresh/volume/</code>(可以更改)</li></ul><p id="6c13" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">有关详细描述和其他示例，请查看<a class="ae ll" href="https://docs.codefresh.io/docs/steps" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="e252" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">对于我的演示流程，我创建了以下自动化步骤:</p><ol class=""><li id="0d89" class="lm ln hu ix b iy iz jc jd lf lo lh lp lj lq js nb ls lt lu dt translated"><code class="eh mo mp mq mr b">mvn_builder</code> -创建Maven <strong class="ix hv">构建器</strong> Docker映像</li><li id="5449" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js nb ls lt lu dt translated"><code class="eh mo mp mq mr b">mv_test</code> -在<strong class="ix hv">构建器</strong>容器中执行测试，将测试结果放入<code class="eh mo mp mq mr b">/codefresh/volume/target/surefire-reports/</code> <em class="iw">数据卷</em>文件夹中</li><li id="b638" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js nb ls lt lu dt translated"><code class="eh mo mp mq mr b">mv_package</code> -创建应用<code class="eh mo mp mq mr b">WAR</code>文件，将创建的文件放入<code class="eh mo mp mq mr b">/codefresh/volume/target/</code>数据卷<em class="iw">文件夹</em></li><li id="6fc9" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js nb ls lt lu dt translated"><code class="eh mo mp mq mr b">build_image</code> -使用JRE和应用程序<code class="eh mo mp mq mr b">WAR</code>文件构建应用程序Docker映像</li><li id="88ec" class="lm ln hu ix b iy lv jc lw lf lx lh ly lj lz js nb ls lt lu dt translated"><code class="eh mo mp mq mr b">push_image</code> -标记应用程序Docker映像并将其推送到DockerHub</li></ol><p id="b43a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">下面是完整的代码更新<code class="eh mo mp mq mr b">YAML</code>:</p><pre class="ju jv jw jx fq ms mr mt mu aw mv dt"><span id="c8fc" class="ma kg hu mr b fv mw mx l my mz">version: '1.0' </span><span id="571f" class="ma kg hu mr b fv na mx l my mz">steps: <br/>  mvn_builder: <br/>    type: build <br/>    description: create Maven builder image <br/>    dockerfile: Dockerfile.build <br/>    image_name: &lt;put_you_repo_here&gt;/mvn-builder </span><span id="80d6" class="ma kg hu mr b fv na mx l my mz">  mvn_test: <br/>    description: run unit tests <br/>    image: ${{mvn_builder}} <br/>    commands: - mvn -T 1C -o test </span><span id="5f77" class="ma kg hu mr b fv na mx l my mz">  mvn_package: <br/>    description: package application and dependencies into WAR <br/>    image: ${{mvn_builder}} <br/>    commands: - mvn package -T 1C -o -Dmaven.test.skip=true </span><span id="6c35" class="ma kg hu mr b fv na mx l my mz">  build_image: <br/>    type: build <br/>    description: create Docker image with application WAR <br/>    dockerfile: Dockerfile <br/>    working_directory: ${{main_clone}}/target <br/>    image_name: &lt;put_you_repo_here&gt;/sbdemo </span><span id="ae50" class="ma kg hu mr b fv na mx l my mz">  push_image: <br/>    type: push <br/>    description: push application image to DockerHub <br/>    candidate: '${{build_image}}' <br/>    tag: '${{CF_BRANCH}}' <br/>    credentials: <br/>      # set docker registry credentials in project configuration <br/>      username: '${{DOCKER_USER}}' <br/>      password: '${{DOCKER_PASS}}'</span></pre><p id="899b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated">希望，你觉得这篇帖子有用。我期待您的评论和任何问题。</p></div><div class="ab cl nc nd hc ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="hn ho hp hq hr"><p id="043c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf lf jh ji jj lh jl jm jn lj jp jq jr js hn dt translated"><em class="iw">原载于</em>【codefresh.io/blog/java_docker_pipeline】<em class="iw"/><em class="iw">。</em></p><div class="ju jv jw jx fq ab cb"><figure class="nj jy nk nl nm nn no paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nj jy nk nl nm nn no paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nj jy nk nl nm nn no paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ir is it"><p id="f922" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><a class="ae ll" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ll" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ll" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae ll" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ll" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ll" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff np"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="nq nr l"/></div></figure></div></div>    
</body>
</html>