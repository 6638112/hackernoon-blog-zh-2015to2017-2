<html>
<head>
<title>Angular Tutorial: Separation of Concerns using ES7 Decorators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular教程:使用ES7装饰器分离关注点</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/angular-tutorial-separation-of-concerns-using-es7-decorators-ed6c9756265?source=collection_archive---------16-----------------------#2017-09-18">https://medium.com/hackernoon/angular-tutorial-separation-of-concerns-using-es7-decorators-ed6c9756265?source=collection_archive---------16-----------------------#2017-09-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="3f36" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本<a class="ae jp" href="https://hackernoon.com/tagged/tutorial" rel="noopener ugc nofollow" target="_blank">教程</a>旨在创建一个简单的<a class="ae jp" href="https://hackernoon.com/tagged/angular" rel="noopener ugc nofollow" target="_blank"> Angular </a>应用程序，该应用程序驱动一个“OOP范例中的常见问题”,即现实世界中常见的代码重复和隐藏模式，这些问题可以使用控制反转技术来解决，并允许我们执行<em class="jq">声明式编程</em>。</p><h2 id="47be" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">资源(这篇文章是关于什么的):</h2><ul class=""><li id="edbe" class="km kn hu it b iu ko iy kp jc kq jg kr jk ks jo kt ku kv kw dt translated"><a class="ae jp" href="https://github.com/k1r0s/angular2-srp-showcase/tree/master" rel="noopener ugc nofollow" target="_blank">https://github.com/k1r0s/angular2-srp-showcase/tree/master</a></li><li id="7fac" class="km kn hu it b iu kx iy ky jc kz jg la jk lb jo kt ku kv kw dt translated"><a class="ae jp" href="https://github.com/k1r0s/angular2-srp-showcase/tree/normal-oop" rel="noopener ugc nofollow" target="_blank">https://github . com/k1r0s/angular 2-SRP-showcase/tree/normal-OOP</a></li></ul><h1 id="74c0" class="lc js hu bd jt ld le lf jx lg lh li kb lj lk ll ke lm ln lo kh lp lq lr kk ls dt translated">该应用程序</h1><ul class=""><li id="dc0e" class="km kn hu it b iu ko iy kp jc kq jg kr jk ks jo kt ku kv kw dt translated">该应用程序应该在其主页中加载一个用户列表。</li><li id="5e3e" class="km kn hu it b iu kx iy ky jc kz jg la jk lb jo kt ku kv kw dt translated">如果一个列表元素被点击，将会出现一个对话框</li><li id="f180" class="km kn hu it b iu kx iy ky jc kz jg la jk lb jo kt ku kv kw dt translated">这个对话框应该有一个关于所选用户的简介和两个按钮</li><li id="0225" class="km kn hu it b iu kx iy ky jc kz jg la jk lb jo kt ku kv kw dt translated">一个按钮应该可以关闭对话框</li><li id="15b3" class="km kn hu it b iu kx iy ky jc kz jg la jk lb jo kt ku kv kw dt translated">其他按钮应加载用户特定的“帖子页”</li><li id="2fa1" class="km kn hu it b iu kx iy ky jc kz jg la jk lb jo kt ku kv kw dt translated">点击来自“南猫王”的用户将会触发一个随机异常</li><li id="5980" class="km kn hu it b iu kx iy ky jc kz jg la jk lb jo kt ku kv kw dt translated">应缓存异常，应显示错误对话框[2]</li><li id="f51c" class="km kn hu it b iu kx iy ky jc kz jg la jk lb jo kt ku kv kw dt translated">帖子页面应呈现所选用户的特定<strong class="it hv">帖子</strong></li></ul><p id="1e4d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">[1]用户对话格式/内容不属于本教程的范围</p><p id="ae59" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">[2]错误对话框格式/内容不属于教程的范围</p><p id="4685" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">规则</p><ul class=""><li id="dca0" class="km kn hu it b iu iv iy iz jc lt jg lu jk lv jo kt ku kv kw dt translated">每次我们执行一个ajax请求时，我们必须显示一个加载对话框</li><li id="cce3" class="km kn hu it b iu kx iy ky jc kz jg la jk lb jo kt ku kv kw dt translated">出于缓存目的，所有ajax请求都应该被存储</li></ul><p id="4a1e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">技术细节</p><p id="cdb8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">用户(作家)资源放在这里:<a class="ae jp" href="https://jsonplaceholder.typicode.com/users" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/<strong class="it hv">用户</strong>T22】</a></p><p id="0b5f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">帖子资源放在这里:<a class="ae jp" href="https://jsonplaceholder.typicode.com/posts" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/<strong class="it hv">帖子</strong> </a></p><h1 id="0ae3" class="lc js hu bd jt ld le lf jx lg lh li kb lj lk ll ke lm ln lo kh lp lq lr kk ls dt translated">我们开始吧</h1><p id="152f" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc lw je jf jg lx ji jj jk ly jm jn jo hn dt translated">你可以按照这些指示，一步一步来。</p><p id="9179" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">准备好你的工作空间</strong></p><ul class=""><li id="b262" class="km kn hu it b iu iv iy iz jc lt jg lu jk lv jo kt ku kv kw dt translated"><code class="eh lz ma mb mc b">$ git clone https://github.com/k1r0s/angular2-srp-showcase.git</code></li><li id="6289" class="km kn hu it b iu kx iy ky jc kz jg la jk lb jo kt ku kv kw dt translated"><code class="eh lz ma mb mc b">$ git checkout normal-oop</code></li><li id="4e4b" class="km kn hu it b iu kx iy ky jc kz jg la jk lb jo kt ku kv kw dt translated"><code class="eh lz ma mb mc b">$ npm install</code></li></ul><p id="93da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">运行代码</strong></p><ul class=""><li id="6f35" class="km kn hu it b iu iv iy iz jc lt jg lu jk lv jo kt ku kv kw dt translated"><code class="eh lz ma mb mc b">$ npm start</code></li><li id="b95a" class="km kn hu it b iu kx iy ky jc kz jg la jk lb jo kt ku kv kw dt translated">浏览本地主机:4200</li></ul><p id="3726" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">读取代码</strong></p><p id="34f4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好的，让我们从打开<code class="eh lz ma mb mc b">src/app/components/writers/writers.component.ts</code>开始。该部分具有以下职责:</p><ul class=""><li id="1169" class="km kn hu it b iu iv iy iz jc lt jg lu jk lv jo kt ku kv kw dt translated">调用服务来获取用户</li><li id="d339" class="km kn hu it b iu kx iy ky jc kz jg la jk lb jo kt ku kv kw dt translated">呈现用户列表</li><li id="7b66" class="km kn hu it b iu kx iy ky jc kz jg la jk lb jo kt ku kv kw dt translated">监听用户列表上的点击</li><li id="3024" class="km kn hu it b iu kx iy ky jc kz jg la jk lb jo kt ku kv kw dt translated">调用一个服务来存储用户请求结果和要加载到“帖子屏幕”上的选定用户</li><li id="f23f" class="km kn hu it b iu kx iy ky jc kz jg la jk lb jo kt ku kv kw dt translated">调用服务以构建一个对话框来呈现所选用户</li><li id="64e8" class="km kn hu it b iu kx iy ky jc kz jg la jk lb jo kt ku kv kw dt translated">如果所选用户来自“南猫王”，则处理异常</li></ul><p id="9ccf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们来看看<code class="eh lz ma mb mc b">src/app/components/user-posts/user-posts.component.ts</code>。这个人有以下责任:</p><ul class=""><li id="deec" class="km kn hu it b iu iv iy iz jc lt jg lu jk lv jo kt ku kv kw dt translated">从缓存中抓取选定的用户</li><li id="35c3" class="km kn hu it b iu kx iy ky jc kz jg la jk lb jo kt ku kv kw dt translated">调用服务来获取用户的特定帖子</li><li id="573e" class="km kn hu it b iu kx iy ky jc kz jg la jk lb jo kt ku kv kw dt translated">呈现帖子列表</li><li id="0c1b" class="km kn hu it b iu kx iy ky jc kz jg la jk lb jo kt ku kv kw dt translated">调用服务来存储特定用户帖子请求结果</li></ul><h2 id="8d19" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">常见的OOP驱动重复:</h2><figure class="md me mf mg fq mh"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="dde8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们来看看<a class="ae jp" href="https://github.com/k1r0s/angular2-aop-showcase/blob/normal-oop/src/app/components/writers/writers.component.ts#L41" rel="noopener ugc nofollow" target="_blank">https://github . com/k1r0s/angular 2-SRP-showcase/blob/normal-OOP/src/app/components/writers/writers . component . ts # L41</a>的代码</p><figure class="md me mf mg fq mh"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="65bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">大多数情况下，应该描述业务操作的方法体与根本没有描述该操作的代码纠缠在一起。比如打开一个对话框，捕捉异常，订阅关闭事件等等。</p><figure class="md me mf mg fq mh"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="e1f8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在OOP中，我们试图通过声明实体(类)来分离关注点，这些实体(类)将描述<strong class="it hv">什么业务想要发生以及在哪里发生(域说话)</strong>的动作(方法)分组。方法描述事情应该如何完成。</p><p id="50e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">OOP范例中的一个常见问题是，为了复制一个行为，代码也必须被复制。有时类扩展是不够的，因为你的行为并不总是发生在同一个地方，或者你根本没有足够的时间来改变整个应用程序架构。例如，必须在一些方法调用结束时调用日志服务，打印方法的参数和结果，但就域问题而言，实现并不重要<strong class="it hv">，这意味着代码正在污染你的应用</strong>。你能用类扩展处理日志调用吗？没有。</p><p id="cb7e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">12个开发人员用不同的实现编写相同行为的项目怎么样？那是隐藏的图案。例如，当一个开发人员习惯于添加一个与以前的功能相似或相同的功能时，他们中的大多数人会在代码基础上寻找以前的实现，以查看“如何处理相同的问题”,或者简单地将代码粘贴到他们的功能中，改变与特定屏幕或功能的上下文相关的一些变量，而一些开发人员会实现他们自己的代码来解决相同的问题。我们不关心哪个实现是最好的。同一个问题的不同实现会产生bug，代码更难维护，等等。解决这个问题的一个简单方法是所有开发者都必须同意的接口定义。但是重复仍然在蔓延。</p><p id="7ed7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">身份验证、Ajax解析、UX动作调用、异常处理……几乎任何与业务逻辑无关的东西都可能在几个地方被调用，而这些实现可能会污染您的领域逻辑。</p><h1 id="5b93" class="lc js hu bd jt ld le lf jx lg lh li kb lj lk ll ke lm ln lo kh lp lq lr kk ls dt translated">例子</h1><p id="5317" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc lw je jf jg lx ji jj jk ly jm jn jo hn dt translated">让我们回到作者组件</p><p id="8e9e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<em class="jq">设置</em>时<code class="eh lz ma mb mc b">writers.component.ts</code>到底在做什么？</p><p id="3572" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/k1r0s/angular2-aop-showcase/blob/normal-oop/src/app/components/writers/writers.component.ts#L78" rel="noopener ugc nofollow" target="_blank">阅读代码我们可以得出结论:</a></p><ul class=""><li id="02f3" class="km kn hu it b iu iv iy iz jc lt jg lu jk lv jo kt ku kv kw dt translated">如果资源已经完成(如果列表已分配)，则从缓存中读取，并跳过下面的所有步骤</li><li id="adbd" class="km kn hu it b iu kx iy ky jc kz jg la jk lb jo kt ku kv kw dt translated">如果缓存为空:我们必须显示一个加载对话框[2]并获取用户资源</li><li id="014e" class="km kn hu it b iu kx iy ky jc kz jg la jk lb jo kt ku kv kw dt translated">然后，我们应该通过调用服务将资源存储在缓存中</li><li id="bad7" class="km kn hu it b iu kx iy ky jc kz jg la jk lb jo kt ku kv kw dt translated">然后我们应该隐藏加载对话框</li><li id="a30a" class="km kn hu it b iu kx iy ky jc kz jg la jk lb jo kt ku kv kw dt translated">然后我们应该指定组件要呈现的列表</li></ul><p id="b635" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">随着代码的执行，会出现许多问题。就域而言，这只是简单的<strong class="it hv">获取和呈现用户列表</strong>。有几个域规则适用于此，<strong class="it hv">捕捉资源，在请求资源时显示加载对话框</strong> …</p><p id="a5fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种行为也会在<code class="eh lz ma mb mc b">user-posts.component.ts</code>上复制。但是在这种情况下，之前有一个域问题:<em class="jq">从缓存中获取选择的用户</em>。</p><p id="8c63" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有一种方法可以将我们从组件特定领域中抽象出来并编码实现吗？是啊！</p><p id="1b11" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们已经定义了一些<code class="eh lz ma mb mc b">writers.component.ts</code>和<code class="eh lz ma mb mc b">user-posts.component.ts</code>共享的接口:<code class="eh lz ma mb mc b">LoadingDialog, ResourceContainer&lt;T&gt;, LoadingDialog, CacheContainer</code>。我们也保证没有隐藏的模式。</p><ul class=""><li id="9f5e" class="km kn hu it b iu iv iy iz jc lt jg lu jk lv jo kt ku kv kw dt translated">这两个组件在创建时都必须获取一些资源</li><li id="8750" class="km kn hu it b iu kx iy ky jc kz jg la jk lb jo kt ku kv kw dt translated">两个组件都必须随时显示加载对话框</li><li id="2257" class="km kn hu it b iu kx iy ky jc kz jg la jk lb jo kt ku kv kw dt translated">两者都必须从缓存中写/读一些东西</li></ul><p id="1ad9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，我们可以在两个组件上实现这一点:</p><figure class="md me mf mg fq mh fe ff paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="fe ff mk"><img src="../Images/078f6a9962affda21d0dc1c3c2de256d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CI1uqNuWpcd5HIzPFX0m4Q.png"/></div></div></figure><p id="05b8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，相同的行为需要在不同的位置和不同的上下文/参数中调用。</p><p id="f3b2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/k1r0s/angular2-aop-showcase/blob/master/src/app/components/writers/writers.component.ts" rel="noopener ugc nofollow" target="_blank"> writers.component.ts(代码)</a></p><p id="b0e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/k1r0s/angular2-aop-showcase/blob/master/src/app/components/user-posts/user-posts.component.ts" rel="noopener ugc nofollow" target="_blank">user-post . component . ts(代码)</a></p><p id="dfa0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">而且这个管用，相信我<a class="ae jp" href="https://angular2-kaop.firebaseapp.com" rel="noopener ugc nofollow" target="_blank">(跑分例子)</a>。</p><p id="1f4d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jq">提示&gt; </em> <code class="eh lz ma mb mc b">argsDriverIndex</code> <em class="jq"> param为</em> <code class="eh lz ma mb mc b">@ArgsCacheReader</code> <em class="jq">其只是一个规范，其中方法</em> <strong class="it hv"> <em class="jq">参数</em> </strong> <em class="jq">索引将作为</em> <strong class="it hv"> <em class="jq">序列化键</em> </strong> <em class="jq">从缓存中读取/写入。这意味着</em> <code class="eh lz ma mb mc b">user-posts.component.ts</code> <em class="jq">将先访问缓存中的</em> <code class="eh lz ma mb mc b">fetchPosts</code> <em class="jq">自变量。因此，它不会两次调用同一个资源。</em></p><p id="a8a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">重要的是要知道这些装饰器可以被导入到任何地方，并且是完全独立的(这取决于你)。这意味着你可以在不弄乱调用栈<strong class="it hv">的情况下移除其中一些，而在普通的OOP实现中你会面临副作用</strong>。</p><h1 id="8125" class="lc js hu bd jt ld le lf jx lg lh li kb lj lk ll ke lm ln lo kh lp lq lr kk ls dt translated">结论</h1><p id="a0c7" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc lw je jf jg lx ji jj jk ly jm jn jo hn dt translated">方法和类装饰器是防止重复的强大工具，它还提供了现代应用程序所需的抽象层。我们已经通过使用声明性编程从组件中清除了基础设施代码，声明性编程的目标是:</p><p id="50e2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jq">“通过描述</em><strong class="it hv"><em class="jq">程序在</em> </strong> <a class="ae jp" href="https://en.wikipedia.org/wiki/Problem_domain" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> <em class="jq">问题域</em> </strong> </a> <em class="jq">方面必须完成什么来消除副作用，而不是描述</em><em class="jq">如何作为编程语言</em> <a class="ae jp" href="https://en.wikipedia.org/wiki/Language_primitive" rel="noopener ugc nofollow" target="_blank"> <em class="jq">原语</em> </a> <em class="jq">的序列来完成它”。</em></p><p id="0461" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的代码一清二楚，易于维护。</p><p id="ce32" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们必须明白<strong class="it hv">我们已经与两个组件</strong>建立了紧密的联系，这两个组件在不久的将来会变得非常不同。因此，如果我们的抽象由于某种原因被否决了，我们必须从不再匹配模式(接口)的组件中移除这个装饰器，粘贴它的实现并编码差异。</p><h1 id="6b19" class="lc js hu bd jt ld le lf jx lg lh li kb lj lk ll ke lm ln lo kh lp lq lr kk ls dt translated">奖金</h1><h2 id="3808" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">为什么是装修工？</h2><p id="b2f8" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc lw je jf jg lx ji jj jk ly jm jn jo hn dt translated">装饰器是现代库中的面包和黄油，比如Angular、<a class="ae jp" href="https://github.com/vuejs/vue-class-component" rel="noopener ugc nofollow" target="_blank"> Vue (addon) </a>，同样在后端，例如<a class="ae jp" href="https://github.com/nestjs/nest" rel="noopener ugc nofollow" target="_blank"> Nest framework </a>提供了许多内置的装饰器来增强你的开发体验，提高可读性，分离关注点..等等。</p><p id="d5a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Decorators很好，因为它为您提供了一种语言特性，允许您添加/删除/管理丰富的实现，而不会弄乱语言原语。</p><p id="a50c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也许在不久的将来，decorators将被用作“独立插件”，可以下载并插入到你的代码中，提供特性(<a class="ae jp" href="https://www.npmjs.com/package/decorator-log" rel="noopener ugc nofollow" target="_blank">例子</a>)。</p><p id="ed1e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，angular的<code class="eh lz ma mb mc b">@Component</code> decorator是一种将您的类作为web组件注册到Angular样板文件中的好方法。那么，为什么你不为自己的需要定义一些呢？</p><h2 id="abc9" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">如何在Typescript/Babel中@？</h2><p id="da3b" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc lw je jf jg lx ji jj jk ly jm jn jo hn dt translated"><em class="jq"> Babel不支持接口处理</em> <strong class="it hv"> <em class="jq">隐藏模式</em> </strong> <em class="jq">，但是</em> <a class="ae jp" href="http://babeljs.io/docs/plugins/transform-decorators/" rel="noopener ugc nofollow" target="_blank"> <em class="jq">它支持方法和类装饰器</em> </a> <em class="jq">。</em></p><p id="8274" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">目前<strong class="it hv">如果你需要写一个需要在某些类的特定构造函数之前被调用的函数</strong>你需要处理<a class="ae jp" href="https://github.com/wycats/javascript-decorators" rel="noopener ugc nofollow" target="_blank"> ES7 decorators API </a>这在<a class="ae jp" href="https://www.typescriptlang.org/docs/handbook/decorators.html" rel="noopener ugc nofollow" target="_blank"> TS文档</a>中有很好的解释。</p><p id="3407" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我创建了一个<a class="ae jp" href="https://github.com/k1r0s/kaop-ts/" rel="noopener ugc nofollow" target="_blank">库</a>,使得定义你自己的方法/类装饰器变得非常容易。它将允许你非侵入性地改变、扩展、修改方法和构造函数的行为。当然，本教程示例是使用该库制作的。</p><p id="f724" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">试试吧！</p><figure class="md me mf mg fq mh"><div class="bz el l di"><div class="mr mj l"/></div></figure></div></div>    
</body>
</html>