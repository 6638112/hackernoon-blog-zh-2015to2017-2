<html>
<head>
<title>How the Creators of Git Do Branching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git的创建者是如何分支的</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-the-creators-of-git-do-branches-e6fcc57270fb?source=collection_archive---------1-----------------------#2017-05-11">https://medium.com/hackernoon/how-the-creators-of-git-do-branches-e6fcc57270fb?source=collection_archive---------1-----------------------#2017-05-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/f5869f729b60d6d3e7bf9c0ab39d7eb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BCZkmZR1_YzDZy22Vn4uUw.png"/></div></div></figure><div class=""/><p id="4e12" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在大型团队和项目中，使用Git进行分布式开发有一些常见的分支和过程模型。</p><p id="46f8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Vincent Drieesen创建的GitFlow 就是这样一个常见的分支模型。GitFlow相对容易理解，由Vincent出色地呈现并由作了<a class="ae ka" href="http://nvie.com/posts/a-successful-git-branching-model/" rel="noopener ugc nofollow" target="_blank">图示，并且似乎恰当地利用了Git出色的分支和合并能力。亚当·岸本瑠可写了一篇名为</a><a class="ae ka" href="http://endoflineblog.com/gitflow-considered-harmful" rel="noopener ugc nofollow" target="_blank"> GitFlow被认为是有害的</a>的流行辩论，并提出了他自己常用的模型。</p><p id="c28a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我提交了另一种用于大型团队和定期发布的复杂项目的方法供您考虑:由<a class="ae ka" href="mailto:git@vger.kernel.org" rel="noopener ugc nofollow" target="_blank"> git.git </a>项目使用的<a class="ae ka" href="https://git-scm.com/docs/gitworkflows#_managing_branches" rel="noopener ugc nofollow" target="_blank"> dogfood工作流</a>——开发和维护git本身的开源项目。这个工作流并不新鲜——我在2009年为上面的<em class="kb"> gitworkflows(7) </em>手册页贡献了,它是由Thomas Rast在2008年首次创建的。但是在git.git项目本身之外，它还没有得到很多采用。我认为主要原因是:a)它没有一个像“GitFlow”这样易于搜索和记忆的名字，b)它创建了一个看起来非常疯狂的历史图表，c)它更难搜索，尤其是当你来自一个更喜欢subversion这样的线性历史工具的背景时。让我们依次解决每一个问题。</p><p id="958f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了给它一个名字，让我们称它为“<strong class="je ig"> gitworkflow </strong>”，以尊重它的创建者和描述它的手册页。<em class="kb">快速声明:我不是一个定期的git.git贡献者——git.git项目不以任何方式认可这一点(尽管git . git邮件列表中的一些好人确实审阅了一份草稿),本文中的任何错误、不准确或误解都是我个人的。</em></p></div><div class="ab cl kc kd hc ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hn ho hp hq hr"><p id="27e7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">关于第二点:在Adam的文章中，他展示了两个截图，一个展示了一个以GitFlow为例的非线性历史(关键点与使用<code class="eh kj kk kl km b">--no-ff</code> merges创建空合并提交相关):</p><figure class="ko kp kq kr fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff kn"><img src="../Images/87f454602599a43005109a13e5b0e169.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-aqUl3YSf8wi6uYD_qh0Tw.png"/></div></div><figcaption class="ks kt fg fe ff ku kv bd b be z ek">A non-linear GitFlow history</figcaption></figure><p id="b26d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一个展示了同一个项目的线性历史，它使用了Adam推荐的快进合并:</p><figure class="ko kp kq kr fq hw fe ff paragraph-image"><div class="fe ff kw"><img src="../Images/4ace87f37a65ea083d8bd0a429246011.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*6FAa9159jno4rpNzg7jC-w.png"/></div></figure><p id="269c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">并问道:</p><blockquote class="kx ky kz"><p id="75b7" class="jc jd kb je b jf jg jh ji jj jk jl jm la jo jp jq lb js jt ju lc jw jx jy jz hn dt translated">在调查这个问题的时候，你更愿意面对哪一段历史？</p></blockquote><p id="4e78" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">后一个历史图表很容易被发现，但是……在合并提交的历史下提供了更多的价值。它将相关的工作放在一起，而线性历史将相关的工作分散在几个不连续的提交中，识别这些关系的唯一方法是提交日志中的问题id。线性历史<strong class="je ig">易于查看</strong>，但<strong class="je ig">难以使用</strong>——用里奇·希基的话说，它“容易”但不“简单”，因为它<a class="ae ka" href="https://www.infoq.com/presentations/Simple-Made-Easy" rel="noopener ugc nofollow" target="_blank">引入了意外的复杂性</a>。</p><p id="35a7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，事实上，第一个历史图表亚当说明<strong class="je ig"> <em class="kb">是</em> </strong> <em class="kb"> </em> <strong class="je ig"> <em class="kb">实际上很难理解</em> </strong>是真实的，需要加以解决。在这里，Git的功能可以提供帮助。想要查看一个分支的所有合并，而不查看单个提交的细节吗？使用<code class="eh kj kk kl km b">--first-parent</code>(正如亚当帖子上最流行的评论所指出的)。下面是git.git关于没有旗帜的<em class="kb">主</em>分支的历史(yikes):</p><figure class="ko kp kq kr fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ld"><img src="../Images/98be8704ccf7876f7c94ab9897f88777.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rdXMoBT-Ta1Uo0LGPZ7-XA.png"/></div></div><figcaption class="ks kt fg fe ff ku kv bd b be z ek">git.git log master</figcaption></figure><p id="5e78" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是有了<code class="eh kj kk kl km b">--first-parent</code>:</p><figure class="ko kp kq kr fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ld"><img src="../Images/0f0028b918fe13ade75644bb4ae45470.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s0APFMSaU1m62HJkpY3BKQ.png"/></div></div><figcaption class="ks kt fg fe ff ku kv bd b be z ek">git.git log master with <code class="eh kj kk kl km b">--first-parent</code></figcaption></figure><p id="6f97" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不错！现在将第二个截图与亚当的线性历史进行比较，并再次询问他的问题。使用这种方法，所处理的每个单独的主题被一致地列出，每个主题的细节被省略，并且历史被线性地呈现。但同时，每个主题分支的详细历史仍在幕后。例如，让我们看看被合并的分支<code class="eh kj kk kl km b">jk/snprintf-cleanups</code>的历史，使用的别名叫做<code class="eh kj kk kl km b"><a class="ae ka" href="https://gist.github.com/rocketraman/1fdc93feb30aa00f6f3a9d7d732102a9#file-gitconfig-L41" rel="noopener ugc nofollow" target="_blank">mergedtopiclg</a></code>:</p><figure class="ko kp kq kr fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ld"><img src="../Images/65a29109a8ecdb7174cd77cc14f9d5cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-IqWq0UYuJgBywt7yIjobA.png"/></div></div></figure><p id="1c0b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们看到所有与特定合并的<strong class="je ig">相关的提交，再次是线性的，没有无关的提交穿插。</strong></p></div><div class="ab cl kc kd hc ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hn ho hp hq hr"><p id="3566" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，最后也是最重要的，gitworkflow没有被广泛采用的原因:很难理解它，或者至少对我来说是这样。亚当指出:</p><blockquote class="kx ky kz"><p id="6887" class="jc jd kb je b jf jg jh ji jj jk jl jm la jo jp jq lb js jt ju lc jw jx jy jz hn dt translated">GitFlow提倡有两个永恒的分支——掌握和开发。为什么是两个，当一个是传统的标准？</p></blockquote><p id="4022" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">相比之下，Gitworkflows实际上有<em class="kb">四个</em>这样的“重要”分支，尽管这四个分支中当然只有一个是“永恒的”:<em class="kb"> maint </em>、<em class="kb"> master </em>、<em class="kb"> next </em>和<em class="kb"> pu。E </em>确切地说<em class="kb">为什么</em>我需要所有这些分支，f*k是什么<em class="kb"> pu </em>？<a class="ae ka" href="https://git-scm.com/docs/gitworkflows" rel="noopener ugc nofollow" target="_blank"> gitworkflows(7) </a>手册页的“管理分支”部分，以及<a class="ae ka" href="https://github.com/git/git/blob/efc912b23335434674bcfda8199077f8dfa5d6f0/MaintNotes#L144" rel="noopener ugc nofollow" target="_blank"> MaintNotes </a>和<a class="ae ka" href="https://github.com/git/git/blob/v2.13.0/Documentation/howto/maintain-git.txt#L35" rel="noopener ugc nofollow" target="_blank"> maintain-git.txt </a>的这些部分，都值得再读一遍。再说一遍(在完成这篇文章后，他们可能会更有意义)。</p><p id="787c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">考虑到这一点，如果我们维护一个项目的发布，我们可能会有不同稳定级别的不同“版本”。一个稳定的“发布”(或“生产”)版本，一个为雄心勃勃的用户和测试人员准备的测试(或“测试”)版本，这个版本有些稳定，还有一个包含所有最新好东西的alpha(或“开发”)版本，但其中可能也有一些不完整的东西。</p><p id="06c8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">并非巧合的是，我们的gitworkflow分支<em class="kb"> master </em>、<em class="kb"> next </em>、以及<em class="kb"> pu </em>(建议更新)<em class="kb"> </em>分别对应<strong class="je ig"> </strong>这些版本/beta/alpha的稳定性级别。剩下的分支<em class="kb"> maint </em>是在发布点从<em class="kb"> master </em>分出来的，仅仅包含已经发布的代码的热修复。</p><p id="817a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">既然我们理解了每个“集成分支”在稳定性方面的目的，我们就将它与“主题分支”的概念结合起来。主题分支本身是没有争议的GitFlow和Adam都推荐使用它们。主题分支是所有当前工作正在进行的地方——每个问题、bug或特性一个分支，并且可以同时进行许多主题分支的开发。然而，在gitworkflow中，主题分支实际上是流程的基础，而不仅仅是独立开发代码的临时场所。</p><p id="58a5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">主题分支总是从<em class="kb">维护</em>或<em class="kb">主控开始。如果主题最终需要合并到由<em class="kb"> maint </em>表示的当前版本，则从<em class="kb"> maint </em>分支</em>，或者如果主题打算用于未来版本(不一定是下一个版本)，则从<em class="kb"> master </em>分支。注意一个警告:如果一个新的主题<em class="kb"> topic-b </em>依赖于在更早的主题<em class="kb"> topic-a </em>上编写的代码，那么<em class="kb"> topic-b </em>仍然应该从<em class="kb"> maint </em>或<em class="kb"> master </em>分支，但是<em class="kb"> topic-a </em>应该合并到<em class="kb"> topic-b </em>中。这使得<em class="kb">主题-b </em>在逻辑上与<em class="kb">主题-a </em>分离，但是使依赖关系显式化。</p><p id="0f6f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于主题从<em class="kb">维护</em>或<em class="kb">主</em>分支，它们也可以毫无争议地合并到<em class="kb">下一个</em>和<em class="kb">pu</em>——因为这两个分支以在<em class="kb">主</em>上提交(或<em class="kb">维护</em>，其中<em class="kb">主</em>总是包含)的形式与主题共享一个共同的祖先。大多数分支策略错误地认为只能合并到同一个分支，但是Git比这更聪明、更灵活。</p><p id="45db" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">主题分支从不稳定的状态开始，可能包含错误和未完成的工作。然而，这不应该阻止我们将我们的工作与其他正在进行的工作集成，看看在合并时和运行时会发生什么——这个过程由我们在<em class="kb"> pu </em>或建议更新分支中的alpha状态代码表示。周期性地<em class="kb"> pu </em>被重置为当前的<em class="kb">主</em>，然后所有的主题分支被合并到其中，以识别合并问题，运行测试，并产生alpha状态构建工件。注意合并的顺序并不重要，但是可以根据项目或具体情况来定义。以一致的顺序执行合并将最好地允许像<code class="eh kj kk kl km b"><a class="ae ka" href="https://git-scm.com/docs/git-rerere" rel="noopener ugc nofollow" target="_blank">git rerere</a></code>这样有用的工具正确工作，并且可以通过脚本实现半自动。</p><p id="0a8b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">合并到<em class="kb"> pu </em>对于产品所有者、功能测试人员和热心用户对开发工作的最初反馈非常有用。GitFlow没有提供任何内在的方法来做到这一点——CI已经成为自动运行单个主题分支上的测试的简写，但在其核心，<strong class="je ig">它是合并和测试<em class="kb">所有</em>当前正在进行的工作的能力，这是真正的CI，gitworkflow启用了</strong>。</p><p id="3731" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，请注意gitworkflow的另一个有用的属性:<em class="kb"> pu </em>被认为是一个可丢弃的分支，可以在任何时候被重置，因此任何提交通常都不应该基于它。因此，尽管过去合并到了<em class="kb"> pu </em>中，主题仍然可以根据需要进行交互式的重定基础，以产生一系列伟大的、容易审查的、可理解的提交，而不用担心其他人不得不"<a class="ae ka" href="https://git-scm.com/docs/git-rebase#_recovering_from_upstream_rebase" rel="noopener ugc nofollow" target="_blank">从上游重定基础</a>中恢复"(这是一个简单的过程，但不是经常需要的)。</p><p id="8bac" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在一个主题分支经历了几个周期的细化、代码审查和测试之后，它可能会达到(根据某人的判断)足以发布到beta(或用户验收测试)环境的程度。至此，在gitworkflow中，话题“毕业生”到了下一个分支<em class="kb">。毕业只是将主题合并到下一个</em>的<em class="kb">和<code class="eh kj kk kl km b">--no-ff</code>。</em></p><p id="dfd9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">既然这个主题已经升级到下一个的<em class="kb">了，那么它可以成为测试版或者验收版的一部分。因此，下一个</em>的<em class="kb">中的每个主题现在都可以进行第二轮稳定化，这正是beta发布/验收测试环境的目的。但是，请注意，对于gitworkflow，我们仍然没有提交(没有双关语！)将这个主题作为我们下一个生产版本的一部分——它仍然没有被合并到<em class="kb"> master </em>中。这在概念上类似于GitFlow的<em class="kb">发布</em>分支，但是更加灵活和强大，因为<em class="kb">主</em>无论如何都不依赖于<em class="kb">下一个</em>，也不会<em class="kb">下一个</em>被大规模合并到<em class="kb">主</em>(不像相应的GitFlow分支<em class="kb">开发</em>和<em class="kb">发布</em>)。</em></p><p id="8ed7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果主题分支在接下来的<em class="kb">上进行合并和测试后，继续随着新的提交而发展，会怎么样？</em>如有必要，该分支被简单地合并到下一个<em class="kb">和</em>。可选地，这些进一步的变化也可以通过首先将它们合并到<em class="kb"> pu </em>而经历额外的稳定期。由于<em class="kb">下一个</em>是一个具有有限生命周期的集成分支，主题的重复合并确实会使它的历史复杂化，但只会持续到下一个<em class="kb">下一个</em>的下一次重建(这可能发生在下一个版本中，但gitworkflow在这里是灵活的)。在这里无关紧要和令人分心的历史，在<em class="kb">溥</em>身上，最终被丢弃和遗忘。</p><p id="3fbb" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，一旦一个主题被判断为足够稳定可以发布，该主题再次毕业并被合并到<em class="kb">主</em>(或者<em class="kb">维护</em>)，再次与<code class="eh kj kk kl km b">--no-ff</code>一起保存该主题分支的完整历史。</p><p id="a959" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">几个主题分支合并到下一个的<em class="kb">，在那里作为beta版进行测试，然后最终升级到<em class="kb"> master </em>进行发布，看起来可能是这样的:</em></p><figure class="ko kp kq kr fq hw fe ff paragraph-image"><div class="fe ff le"><img src="../Images/bd3a2d439d9ec05eab2990286ddb94b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rEsb9OTh3FlVWdDBe_ZGuA.png"/></div><figcaption class="ks kt fg fe ff ku kv bd b be z ek">Source: <a class="ae ka" href="http://jsfiddle.net/jtooun5q/5/" rel="noopener ugc nofollow" target="_blank">http://jsfiddle.net/jtooun5q/5/</a></figcaption></figure><p id="19d9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，在gitworkflow中，不稳定和稳定的开发工作<strong class="je ig">永远不会</strong>混合在同一个分支上。相比之下，使用GitFlow我有两个选择:1)我可以在自己的分支上单独测试我的主题，或者2)我可以将它合并到<em class="kb"> develop </em>中进行测试。两种选择都没有吸引力。前者在与其他正在进行的工作一起部署时不提供对主题稳定性的真正测试，而后者将主题提交给<em class="kb">开发</em>可能在它稳定之前。</p><p id="e7f6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">出于同样的原因，GitFlow没有过程辅助的方法来提前识别哪些主题可能会导致与其他正在进行的工作的冲突，以便有问题的开发人员可以在他们的主题最终合并到<em class="kb">开发</em>之前协调工作。简而言之，在GitFlow <strong class="je ig">中，在保持开发工作在一个主题分支上的干净和隔离的愿望与通过将主题分支合并到<em class="kb">开发</em>以使它们可见和可测试并检查冲突来将主题分支与其他工作</strong>集成起来的愿望之间，总是存在无法解决的矛盾。Gitworkflow允许在不牺牲一个目标的情况下实现两个目标。</p></div><div class="ab cl kc kd hc ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hn ho hp hq hr"><p id="c90f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">关于gitworkflow，除了我在这里介绍的之外，还有更多功能需要学习。也许我或其他人的一些后续帖子可以涵盖这一领域。此外，围绕gitworkflow的开源工具集将有助于重建<em class="kb"> pu </em>和<em class="kb"> next </em>，并跟踪主题的毕业状态——git.git有用于此目的的“烹饪”工具，但不太特定于git . git的工具会更好。作为开始，我创造了<a class="ae ka" href="https://gist.github.com/rocketraman/1fdc93feb30aa00f6f3a9d7d732102a9" rel="noopener ugc nofollow" target="_blank">几个有用的别名</a>【1】。<em class="kb">2018年4月8日更新</em>:我还在GitHub上创建了一个<a class="ae ka" href="https://github.com/rocketraman/gitworkflows" rel="noopener ugc nofollow" target="_blank">知识库</a>，里面有额外的文档，包括一个<a class="ae ka" href="https://github.com/rocketraman/gitworkflows/blob/master/docs/task-oriented-primer.adoc" rel="noopener ugc nofollow" target="_blank">面向任务的入门</a>。</p><p id="6a32" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但简而言之，gitworkflow对于许多用例来说是一个优秀的Git分支模型/工作流，值得比现在更受欢迎。这确实需要对高级Git特性和概念有深刻的理解，但是这种努力是值得的。</p><p id="7ce0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">[1]特别参见别名<code class="eh kj kk kl km b">lgp</code>、<code class="eh kj kk kl km b">topics</code>、<code class="eh kj kk kl km b">topiclg</code>、<code class="eh kj kk kl km b">mergedtopiclg</code>、<code class="eh kj kk kl km b">branchnote</code>和<code class="eh kj kk kl km b">where</code></p></div><div class="ab cl kc kd hc ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hn ho hp hq hr"><p id="131f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Raman Gupta是reDock Inc. 的工程副总裁，喜欢教授Git的奇妙之处。顺便说一句，<a class="ae ka" href="https://www.redock.com" rel="noopener ugc nofollow" target="_blank"> reDock </a>正在招人！在Twitter上关注我们<a class="ae ka" href="https://twitter.com/reDockAI" rel="noopener ugc nofollow" target="_blank"> @reDockAI </a>。</p><div class="ko kp kq kr fq ab cb"><figure class="lf hw lg lh li lj lk paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="lf hw lg lh li lj lk paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="lf hw lg lh li lj lk paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="kx ky kz"><p id="f922" class="jc jd kb je b jf jg jh ji jj jk jl jm la jo jp jq lb js jt ju lc jw jx jy jz hn dt translated"><a class="ae ka" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是AMI家庭的一员。我们现在<a class="ae ka" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ka" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd kb je b jf jg jh ji jj jk jl jm la jo jp jq lb js jt ju lc jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ka" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ka" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ko kp kq kr fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ll"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>