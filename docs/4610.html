<html>
<head>
<title>Creating a form forwarding service for AWS Lambda</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为AWS Lambda创建表单转发服务</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/creating-a-form-forwarding-service-for-aws-lambda-aec07af9f951?source=collection_archive---------5-----------------------#2017-06-10">https://medium.com/hackernoon/creating-a-form-forwarding-service-for-aws-lambda-aec07af9f951?source=collection_archive---------5-----------------------#2017-06-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/8c258d072c8926cb5d28de137e6a492f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JhC99tlprjv8fmZFIHT35A.png"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Using graphics from <a class="ae ih" href="https://experience.sap.com/designservices/approach/scenes" rel="noopener ugc nofollow" target="_blank">SAP Scenes Pack</a></figcaption></figure><div class=""/><p id="5c74" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">自从最初发表这篇博文以来，我已经写了一篇更新的文章。我建议你去读它，而不是继续读下去，因为下面的一些内容现在已经过时了<strong class="jj il"> e </strong>。</p><div class="ht hu fm fo hv kf"><a href="https://hackernoon.com/introducing-formplug-v1-a-form-forwarding-service-for-aws-lambda-2c125dfe608e" rel="noopener  ugc nofollow" target="_blank"><div class="kg ab ej"><div class="kh ab ki cl cj kj"><h2 class="bd il fv z el kk eo ep kl er et ij dt translated">介绍Formplug v1，这是一种用于AWS Lambda的表单转发服务</h2><div class="km l"><h3 class="bd b fv z el kk eo ep kl er et ek translated">据估计，每天大约有2690亿封电子邮件被发送出去。当你阅读的时候，已经有超过1000万封被寄出…</h3></div><div class="kn l"><p class="bd b gc z el kk eo ep kl er et ek translated">hackernoon.com</p></div></div><div class="ko l"><div class="kp l kq kr ks ko kt ib kf"/></div></div></a></div><p id="ead2" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这篇文章中，我将介绍一个我创建的服务，它可以让设置邮件转发变得简单。它使用Node.js和无服务器框架构建在<a class="ae ih" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> Javascript </a>中。它部署到AWS Lambda，并使用亚马逊简单电子邮件服务发送电子邮件。要查看代码，请参见下面的Github资源库。请继续阅读问题的解释和技术解决方案的演示。</p><div class="ht hu fm fo hv kf"><a href="https://github.com/danielireson/formplug-serverless" rel="noopener  ugc nofollow" target="_blank"><div class="kg ab ej"><div class="kh ab ki cl cj kj"><h2 class="bd il fv z el kk eo ep kl er et ij dt translated">Daniel reson/form plug-无服务器</h2><div class="km l"><h3 class="bd b fv z el kk eo ep kl er et ek translated">用于AWS Lambda的表单插件-无服务器表单转发服务</h3></div><div class="kn l"><p class="bd b gc z el kk eo ep kl er et ek translated">github.com</p></div></div><div class="ko l"><div class="ku l kq kr ks ko kt ib kf"/></div></div></a></div><h1 id="1576" class="kv kw ik bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">问题</h1><p id="cc5d" class="pw-post-body-paragraph jh ji ik jj b jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka lx kc kd ke hn dt translated">最近，我发现自己对我的副业项目倾向于静态网站托管。Github Pages工作得很好，因为像大多数人一样，我使用Github来托管我的git库。部署一个网站就像<code class="eh ly lz ma mb b">git push</code>到<em class="mc"> gh-pages </em>分支一样简单，几分钟后网站就会上线。在许多情况下，静态托管是非常好的，但现在有几次，我很难建立一个简单的基于电子邮件的联系表单——这通常不会被认为是太有挑战性的任务。有几种方法可以解决这个问题。</p><h2 id="c23e" class="md kw ik bd kx me mf mg lb mh mi mj lf js mk ml lj jw mm mn ln ka mo mp lr mq dt translated">选项1:无联系表格</h2><p id="d655" class="pw-post-body-paragraph jh ji ik jj b jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka lx kc kd ke hn dt translated">显而易见的第一个选择是完全避免联系表单，而只显示电子邮件地址。这是我在很多场合选择的方法，因为它最简单，但也有一些缺点。它把额外的工作推给了用户——他们必须离开网站，打开他们的电子邮件客户端。当访问者第一次联系你时，也很难指定需要什么信息，例如，你可能需要报价的资格信息。你可以给用户发一条信息询问具体的信息，但是没有验证可以确认人们是否遵守了这个请求。</p><h2 id="18a7" class="md kw ik bd kx me mf mg lb mh mi mj lf js mk ml lj jw mm mn ln ka mo mp lr mq dt translated"><em class="mr">选项2: mailto链接</em></h2><p id="99f8" class="pw-post-body-paragraph jh ji ik jj b jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka lx kc kd ke hn dt translated">通过电子邮件发送表单的一个解决方案是将表单的action属性设置为一个电子邮件地址的<em class="mc"> mailto </em>链接。当用户提交表单时，它打开默认的电子邮件客户端，表单数据作为主体，如下面的屏幕截图所示。结果不是很好的用户体验。并非所有用户都有默认的电子邮件客户端设置，即使他们有，也会收到一封草稿邮件。目前还不清楚该表格是否已经提交，以及他们需要采取什么行动。</p><figure class="mt mu mv mw fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ms"><img src="../Images/e1a38f93805bd6bd108616a13a2830c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*If7g5Iiu96xMdOx6mfJaaA.png"/></div></div></figure><h2 id="51e8" class="md kw ik bd kx me mf mg lb mh mi mj lf js mk ml lj jw mm mn ln ka mo mp lr mq dt translated">选项3:使用服务器端代码</h2><p id="3209" class="pw-post-body-paragraph jh ji ik jj b jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka lx kc kd ke hn dt translated">作为一项安全功能，您不能在浏览器中发送电子邮件客户端。如果这是可能的，网站访问者将非常容易受到代表他们发送电子邮件的恶意代码的影响。如果你已经在一个服务器上托管了你的应用程序，那么设置一个联系表单是很容易的。像PHP、Java或ASP这样的服务器端脚本语言具有使发送电子邮件变得容易的能力。例如在PHP中，它可以通过两行代码实现。</p><pre class="mt mu mv mw fq mx mb my mz aw na dt"><span id="b47a" class="md kw ik mb b fv nb nc l nd ne">$message = $_POST['message'];<br/>mail('johndoe@example.com', 'Form submission', $message);</span></pre><p id="377e" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然而，如果你还没有一个服务器，只为一个联系表单维护一个服务器似乎有点浪费。维护它需要时间和财务成本，而且它还引入了关于可伸缩性和安全性的其他考虑因素。</p><h2 id="6efd" class="md kw ik bd kx me mf mg lb mh mi mj lf js mk ml lj jw mm mn ln ka mo mp lr mq dt translated">选项4:使用第三方服务</h2><p id="22cf" class="pw-post-body-paragraph jh ji ik jj b jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka lx kc kd ke hn dt translated">托管表单后端服务的功能和范围各不相同。<a class="ae ih" href="https://formkeep.com/" rel="noopener ugc nofollow" target="_blank"> FormKeep </a>举例来说，它可以很容易地将表单集成到Trello、Slack或Google Sheets等服务中，但对于一个简单的联系人表单来说，每月59美元起的计划可能会很昂贵。使用第三方服务也总是存在风险；它可以随时离线，你无法控制它。如果服务被关闭，将不会有任何通知，联系方式将会突然停止工作。</p><h1 id="3116" class="kv kw ik bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">解决办法</h1><p id="3bd6" class="pw-post-body-paragraph jh ji ik jj b jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka lx kc kd ke hn dt translated">在我看来，自托管表单转发服务是最佳解决方案。您将获得控制的优势，并且不会降低最终用户体验。选择为AWS Lambda开发后端进一步减少了自托管的许多缺点。</p><blockquote class="nf ng nh"><p id="8b9e" class="jh ji mc jj b jk jl jm jn jo jp jq jr ni jt ju jv nj jx jy jz nk kb kc kd ke hn dt translated">AWS Lambda允许您在不提供或管理服务器的情况下运行代码。您只需为您消耗的计算时间付费，当您的代码不运行时，则不收费。有了Lambda，你可以为几乎任何类型的应用程序或后端服务运行代码——所有这些都无需管理。只需上传你的代码，Lambda就会为你的代码提供高可用性的运行和扩展。</p></blockquote><p id="dae0" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在AWS Lambda上构建应用程序有多种方法。对于简单的服务，您可以使用AWS管理控制台来创建函数和设置触发器。对于更复杂的服务，最好在本地开发，然后部署到AWS，在那里您可以享受您最喜欢的代码编辑器带来的便利。最初建立项目结构可能具有挑战性，因为有许多事情需要考虑。服务将部署到哪个AWS区域？如何提供AWS服务？如何管理环境变量？如何管理安全性？出于这些考虑，当使用AWS Lambda时，我喜欢使用一个自以为是的框架，称为无服务器框架。它提供了合理的默认值，并允许我们在更高、更容易理解的抽象层次上提供服务。使用CLI，部署和更新服务就像运行<code class="eh ly lz ma mb b">serverless deploy</code>一样简单。</p><p id="dab5" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你想了解更多关于无服务器框架的知识，我推荐你看下面这个视频，它的创作者是奥斯丁·柯林斯。这个视频已经有几年的历史了，但是它很好地介绍了一些核心概念。我还建议浏览一下<a class="ae ih" href="https://serverless.com/framework/docs/" rel="noopener ugc nofollow" target="_blank">的无服务器文档</a>。</p><figure class="mt mu mv mw fq hw"><div class="bz el l di"><div class="nl nm l"/></div></figure><h1 id="98a7" class="kv kw ik bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">架构概述</h1><p id="cc60" class="pw-post-body-paragraph jh ji ik jj b jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka lx kc kd ke hn dt translated">表单转发服务由三个lambda函数组成:加密、接收、发送。加密和接收功能分别通过亚马逊API网关路由<em class="mc">/加密</em>和<em class="mc">/到</em>触发。(API网关路由本质上是一个公共URL。)<em class="mc"> </em>发送lambda函数仅由接收lambda函数调用。receive lambda负责处理表单提交，并调用send lambda发送电子邮件。encrypt lambda可以选择性地用于获取电子邮件地址的加密表示，以便在接收端点URL中使用。稍后将对此进行更详细的解释。</p><figure class="mt mu mv mw fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nn"><img src="../Images/41e1801b1117b46b4bb5d28b4cc96c86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K4ZuaZKkmcN3K4v2--6k8Q.png"/></div></div></figure><h1 id="314d" class="kv kw ik bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">接收λ</h1><p id="2e2b" class="pw-post-body-paragraph jh ji ik jj b jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka lx kc kd ke hn dt translated">接收处理程序由<em class="mc"> /to </em>路由触发，该路由接受一个参数，即转发表单的电子邮件地址。端点在初始的<code class="eh ly lz ma mb b">serverless deploy</code>上生成，并在终端窗口中返回。它采用以下结构。</p><pre class="mt mu mv mw fq mx mb my mz aw na dt"><span id="5392" class="md kw ik mb b fv nb nc l nd ne">https://apigatewayurl/to/johndoe@example.com</span></pre><p id="1721" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">HTML表单应该发送到此端点。这将触发接收lambda(如下所示)。它负责验证请求，获取表单数据并调用send lambda。</p><pre class="mt mu mv mw fq mx mb my mz aw na dt"><span id="d836" class="md kw ik mb b fv nb nc l nd ne">module.exports.handle = (event, context, callback) =&gt; {<br/>  let data = receiveRequest.getParams(event)<br/>  if (receiveRequest.validate(data, callback)) {<br/>    eventInvoker.send(data)<br/>      .then(function () {<br/>        httpRoute.render('receive-success', data, callback)<br/>      })<br/>      .catch(function (error) {<br/>        httpRoute.render('receive-error', data, callback)<br/>      })<br/>  }<br/>}</span></pre><h2 id="bce2" class="md kw ik bd kx me mf mg lb mh mi mj lf js mk ml lj jw mm mn ln ka mo mp lr mq dt translated">获取表单数据</h2><p id="1952" class="pw-post-body-paragraph jh ji ik jj b jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka lx kc kd ke hn dt translated">表单的POST请求将生成一个API Gateway事件，该事件将作为第一个参数自动传递给处理程序。下面显示了一个事件示例(删除了敏感字段)。</p><pre class="mt mu mv mw fq mx mb my mz aw na dt"><span id="e7d4" class="md kw ik mb b fv nb nc l nd ne">{  <br/>   resource:'/to/{_to}',<br/>   path:'/to/johndoe@example.com',<br/>   httpMethod:'POST',<br/>   headers: {<br/>      Accept:'*/*',<br/>      'Accept-Encoding':'gzip, deflate',<br/>      'cache-control':'no-cache',<br/>      'CloudFront-Forwarded-Proto':'https',<br/>      'CloudFront-Is-Desktop-Viewer':'true',<br/>      'CloudFront-Is-Mobile-Viewer':'false',<br/>      'CloudFront-Is-SmartTV-Viewer':'false',<br/>      'CloudFront-Is-Tablet-Viewer':'false',<br/>      'CloudFront-Viewer-Country':'GB',<br/>      'content-type':'application/x-www-form-urlencoded',<br/>      Host:'',<br/>      'User-Agent':'',<br/>      'X-Amz-Cf-Id':'',<br/>      'X-Amzn-Trace-Id':'',<br/>      'X-Forwarded-For':'',<br/>      'X-Forwarded-Port':'443',<br/>      'X-Forwarded-Proto':'https'<br/>   },<br/>   queryStringParameters:null,<br/>   pathParameters: {<br/>      _to:'johndoe@example.com'<br/>   },<br/>   stageVariables:null,<br/>   requestContext: {  <br/>      path:'/dev/to/johndoe@example.com',<br/>      accountId:'',<br/>      resourceId:'',<br/>      stage:'dev',<br/>      requestId:'',<br/>      identity:{  <br/>         cognitoIdentityPoolId:null,<br/>         accountId:null,<br/>         cognitoIdentityId:null,<br/>         caller:null,<br/>         apiKey:'',<br/>         sourceIp:'',<br/>         accessKey:null,<br/>         cognitoAuthenticationType:null,<br/>         cognitoAuthenticationProvider:null,<br/>         userArn:null,<br/>         userAgent:'',<br/>         user:null<br/>      },<br/>      resourcePath:'/to/{_to}',<br/>      httpMethod:'POST',<br/>      apiId:''<br/>   },<br/>   body:'first=test&amp;second=test&amp;third=test',<br/>   isBase64Encoded:false<br/>}</span></pre><p id="accf" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们只对一些事件数据感兴趣，所以我们通过<em class="mc"> getParams </em>函数提取这些数据。具体来说，我们感兴趣的是从<em class="mc"> event.body、</em>event . path parameters获取表单数据，从<em class="mc">event . query string parameters</em>获取查询字符串。</p><pre class="mt mu mv mw fq mx mb my mz aw na dt"><span id="084b" class="md kw ik mb b fv nb nc l nd ne">module.exports.getParams = function (event) {<br/>  let data = Object.assign({}, querystring.parse(event.body), event.pathParameters, event.queryStringParameters)<br/>  return data<br/>}</span></pre><p id="56e6" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">节点querystring模块用于解析来自请求主体的POST表单数据。这将获取字符串<em class="mc">first = test&amp;second = test&amp;third = test</em>，并将其转换为一个JavaScript对象。</p><h2 id="4da2" class="md kw ik bd kx me mf mg lb mh mi mj lf js mk ml lj jw mm mn ln ka mo mp lr mq dt translated">验证请求</h2><p id="465f" class="pw-post-body-paragraph jh ji ik jj b jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka lx kc kd ke hn dt translated">然后，数据经过一个验证函数，该函数检查电子邮件是否有效，蜜罐字段是否没有填写。</p><pre class="mt mu mv mw fq mx mb my mz aw na dt"><span id="2700" class="md kw ik mb b fv nb nc l nd ne">module.exports.validate = function (data, callback) {<br/>  return hasValidEmail(data, callback) &amp;&amp; hasNoHoneypot(data, callback)<br/>}</span><span id="bd6f" class="md kw ik mb b fv no nc l nd ne">function hasValidEmail (data, callback) {<br/>  if (!('_to' in data)) {<br/>    httpRoute.render('receive-no-email', data, callback)<br/>    return false<br/>  }<br/>  if ('_to' in data &amp;&amp; !httpValidation.isEmail(data['_to'])) {<br/>    httpRoute.render('receive-bad-email', data, callback)<br/>    return false<br/>  }<br/>  return true<br/>}</span><span id="be32" class="md kw ik mb b fv no nc l nd ne">function hasNoHoneypot (data, callback) {<br/>  if ('_honeypot' in data &amp;&amp; data['_honeypot'] !== '') {<br/>    httpRoute.render('receive-honeypot', data, callback)<br/>    return false<br/>  }<br/>  return true<br/>}</span></pre><p id="26ad" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">蜜罐字段是可选的垃圾邮件防御功能。用户可以将该字段添加到表单中，并对访问者隐藏。</p><pre class="mt mu mv mw fq mx mb my mz aw na dt"><span id="4034" class="md kw ik mb b fv nb nc l nd ne">&lt;input type="text" name="_honeypot" style="display:none"&gt;</span></pre><p id="1027" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果表单被提交并且蜜罐字段不为空，请求将被忽略(因为垃圾邮件机器人试图在那里输入值)。</p><h2 id="e24b" class="md kw ik bd kx me mf mg lb mh mi mj lf js mk ml lj jw mm mn ln ka mo mp lr mq dt translated">调用发送lambda</h2><p id="bc6d" class="pw-post-body-paragraph jh ji ik jj b jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka lx kc kd ke hn dt translated">验证后，使用AWS-SDK npm包异步调用send lambda和数据负载。</p><pre class="mt mu mv mw fq mx mb my mz aw na dt"><span id="c3f0" class="md kw ik mb b fv nb nc l nd ne">module.exports.send = function (data) {<br/>  let event = {<br/>    FunctionName: `formplug-${config.STAGE}-send`,<br/>    InvocationType: 'Event',<br/>    Payload: JSON.stringify(data)<br/>  }<br/>  return lambda.invoke(event).promise()<br/>}</span></pre><p id="c086" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">它异步调用它，因为我们不希望访问者在提交表单后等待亚马逊发送电子邮件。以这种方式调用它也意味着如果失败了，AWS将自动重试。</p><h2 id="b360" class="md kw ik bd kx me mf mg lb mh mi mj lf js mk ml lj jw mm mn ln ka mo mp lr mq dt translated">生成HTTP响应</h2><p id="9e18" class="pw-post-body-paragraph jh ji ik jj b jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka lx kc kd ke hn dt translated">HTTP响应是通过处理程序的<em class="mc">回调</em>函数做出的。这是由无服务器框架提供的。为了获得成功的响应，回调函数应该使用第一个参数作为null，第二个参数作为响应对象。例如，要生成一个成功的纯文本HTTP响应，我们可以这样做。</p><pre class="mt mu mv mw fq mx mb my mz aw na dt"><span id="9867" class="md kw ik mb b fv nb nc l nd ne">callback(null, {<br/>  statusCode: 200,<br/>  headers: {<br/>    'Content-Type': 'text/plain'<br/>  },<br/>  body: 'Form submission successfully made'<br/>})</span></pre><p id="e0eb" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是我们想要的不是纯文本响应，而是HTML、JSON或URL重定向响应(取决于用户的请求)。应用程序默认为HTML响应。</p><figure class="mt mu mv mw fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff np"><img src="../Images/2f8e93d3064ab63b8807d9623973e797.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U0AqbOWXYod4FGF7UGchLQ.png"/></div></div></figure><p id="909e" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">HTML响应是通过加载本地模板文件并用适当的消息替换<em class="mc"> {{ message }} </em>变量来生成的。</p><pre class="mt mu mv mw fq mx mb my mz aw na dt"><span id="4255" class="md kw ik mb b fv nb nc l nd ne">function buildHtmlResponse (statusCode, message, data) {<br/>  let response = {<br/>    statusCode: statusCode,<br/>    headers: {<br/>      'Content-Type': 'text/html'<br/>    },<br/>    body: generateView(message)<br/>  }<br/>  if (statusCode === 302) {<br/>    response.headers.Location = data['_redirect']<br/>  }<br/>  return response<br/>}</span><span id="5c70" class="md kw ik mb b fv no nc l nd ne">function generateView (message) {<br/>  try {<br/>    let template = fs.readFileSync(path.resolve(__dirname, 'template.html')).toString()<br/>    message = template.replace('{{ message }}', message)<br/>  } catch (error) {<br/>    utilityLog.error(error.message)<br/>  }<br/>  return message<br/>}</span></pre><p id="2fb6" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">用户还可以在表单提交后请求URL重定向。这个URL应该作为表单本身的隐藏输入提供。</p><pre class="mt mu mv mw fq mx mb my mz aw na dt"><span id="7fe7" class="md kw ik mb b fv nb nc l nd ne">&lt;input type="hidden" name="_redirect" value="http://google.com"&gt;</span></pre><p id="4cb0" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果提供了<em class="mc"> _redirect </em>字段，那么应用程序将设置302 HTTP状态代码和<a class="ae ih" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Location" rel="noopener ugc nofollow" target="_blank"> <em class="mc">位置</em> HTTP头</a>。访问者的网络浏览器将获取这些信息并处理重定向。</p><p id="98ff" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">非重定向响应消息在路由文件中定义。用户可以在配置中定义自定义消息，或者使用服务默认值。这些都是通过一个路由<em class="mc">渲染</em>函数调用的。</p><pre class="mt mu mv mw fq mx mb my mz aw na dt"><span id="32da" class="md kw ik mb b fv nb nc l nd ne">module.exports.render = function (type, data, callback) {<br/>  let routeDetails = module.exports.getRouteDetails(type, data)<br/>  callback(null, httpResponse.build(routeDetails.statusCode, routeDetails.message, data))<br/>}</span><span id="0651" class="md kw ik mb b fv no nc l nd ne">module.exports.getRouteDetails = function (type, data) {<br/>  let statusCode, message<br/>  switch (type) {<br/>    case 'encrypt-no-email':<br/>      statusCode = 422<br/>      message = config.MSG_ENCRYPT_NO_EMAIL || 'You need to provide an email address to encrypt.'<br/>      break<br/>    case 'encrypt-bad-email':<br/>      statusCode = 422<br/>      message = config.MSG_ENCRYPT_BAD_EMAIL || 'The supplied email address is not valid.'<br/>      break<br/>    case 'encrypt-success':<br/>      statusCode = 200<br/>      message = data['_encrypted']<br/>      break<br/>    case 'receive-honeypot':<br/>      statusCode = 422<br/>      message = config.MSG_RECEIVE_HONEYPOT || 'You shall not pass.'<br/>      break<br/>    case 'receive-no-email':<br/>      statusCode = 422<br/>      message = config.MSG_RECEIVE_NO_EMAIL || 'Form not sent, the admin has not set up a forwarding email address.'<br/>      break<br/>    case 'receive-bad-email':<br/>      statusCode = 422<br/>      message = config.MSG_RECEIVE_BAD_EMAIL || 'Form not sent, the admin email address is not valid.'<br/>      break<br/>    case 'receive-error':<br/>      statusCode = 500<br/>      message = config.MSG_RECEIVE_ERROR || 'Form not sent, an error occurred while sending.'<br/>      break<br/>    case 'receive-success':<br/>      statusCode = httpValidation.hasRedirect(data) ? 302 : 200<br/>      message = config.MSG_RECEIVE_SUCCESS || 'Form submission successfully made.'<br/>      break<br/>    default:<br/>      statusCode = 500<br/>      message = 'An error has occurred.'<br/>  }<br/>  return {statusCode, message}<br/>}</span></pre><p id="89e5" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">经常会用JavaScript调用表单转发服务，在这种情况下，应该请求JSON响应。这是通过将<em class="mc"> _format=json </em>附加到接收端点URL查询字符串(下划线用于遵守与其他私有字段相同的命名约定)来实现的。</p><pre class="mt mu mv mw fq mx mb my mz aw na dt"><span id="096f" class="md kw ik mb b fv nb nc l nd ne">https://apigatewayurl/to/johndoe@example.com?_format=json</span></pre><p id="84be" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这将返回一个带有<em class="mc">访问控制允许来源</em>报头的响应，该报头设置为<em class="mc"> *、</em>以表示所有域。这个<a class="ae ih" href="https://developer.mozilla.org/en/docs/Web/HTTP/Access_control_CORS" rel="noopener ugc nofollow" target="_blank"> CORS头</a>是跨域JavaScript调用所需的安全特性。</p><pre class="mt mu mv mw fq mx mb my mz aw na dt"><span id="d0c2" class="md kw ik mb b fv nb nc l nd ne">function buildJsonResponse (statusCode, message, data) {<br/>  let response = {<br/>    statusCode: statusCode,<br/>    headers: {<br/>      'Access-Control-Allow-Origin': '*',<br/>      'Content-Type': 'application/json'<br/>    },<br/>    body: JSON.stringify({<br/>      statusCode: statusCode,<br/>      message: message<br/>    })<br/>  }<br/>  return response<br/>}</span></pre><h1 id="2ba6" class="kv kw ik bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">发送λ</h1><p id="b890" class="pw-post-body-paragraph jh ji ik jj b jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka lx kc kd ke hn dt translated">AWS将在收到从接收lambda调用的事件后触发发送lambda处理程序。</p><pre class="mt mu mv mw fq mx mb my mz aw na dt"><span id="6bbf" class="md kw ik mb b fv nb nc l nd ne">module.exports.handle = (event, context, callback) =&gt; {<br/>  let email = mailBuilder.build(event)<br/>  mailService.send(email)<br/>    .then(function () {<br/>      utilityLog.success('Successfully sent email')<br/>    })<br/>    .catch(function (error) {<br/>      utilityLog.error(['Error sending email', event, error], callback)<br/>    })<br/>}</span></pre><p id="8de9" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">电子邮件正文是通过循环包含所有用户表单字段的事件数据构建的。</p><pre class="mt mu mv mw fq mx mb my mz aw na dt"><span id="7ad8" class="md kw ik mb b fv nb nc l nd ne">function buildMessage (data) {<br/>  let message = ''<br/>  for (let field in data) {<br/>    // Don't send private variables prefixed with an underscore<br/>    if (field.slice(0, 1) !== '_') {<br/>      message += field.toUpperCase() + ': ' + data[field] + '\r\n'<br/>    }<br/>  }<br/>  message += '---' + '\r\n'<br/>  message += 'Sent with Formplug'<br/>  return message<br/>}</span></pre><p id="cfee" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">上面的<em class="mc"> buildMessage </em>函数在导出的<em class="mc"> build </em>函数中被调用，该函数为send lambda处理程序组合完整的电子邮件对象。</p><pre class="mt mu mv mw fq mx mb my mz aw na dt"><span id="fbcb" class="md kw ik mb b fv nb nc l nd ne">module.exports.build = function (data) {<br/>  return {<br/>    Source: buildSource(),<br/>    Destination: {<br/>      ToAddresses: [<br/>        data['_to']<br/>      ]<br/>    },<br/>    Message: {<br/>      Subject: {<br/>        Data: 'You have a form submission'<br/>      },<br/>      Body: {<br/>        Text: {<br/>          Data: buildMessage(data)<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="bb8e" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">email对象是通过Amazon Simple Email Service发送的，它被封装在一个单独的函数中(这使得它在测试期间<a class="ae ih" href="https://github.com/danielireson/formplug-serverless/blob/master/test/index.js" rel="noopener ugc nofollow" target="_blank">很容易被存根化)。这个函数是从send lambda处理程序调用的。</a></p><pre class="mt mu mv mw fq mx mb my mz aw na dt"><span id="8575" class="md kw ik mb b fv nb nc l nd ne">const aws = require('aws-sdk')<br/>const sesClient = new aws.SES()<br/><br/>module.exports.send = function (email) {<br/>  return sesClient.sendEmail(email).promise()<br/>}</span></pre><h1 id="9f71" class="kv kw ik bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">加密lambda</h1><p id="6fe8" class="pw-post-body-paragraph jh ji ik jj b jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka lx kc kd ke hn dt translated">加密的使用是可选的；没有它也可以使用该服务。它让用户有机会在接收端点加密他们的电子邮件地址。</p><pre class="mt mu mv mw fq mx mb my mz aw na dt"><span id="dadf" class="md kw ik mb b fv nb nc l nd ne">https://apigatewayurl/to/1974d0cc894607de62f0581ec1334997</span></pre><p id="283a" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">加密处理程序从URL中获取电子邮件地址，验证它并将其传递给加密函数。</p><pre class="mt mu mv mw fq mx mb my mz aw na dt"><span id="426b" class="md kw ik mb b fv nb nc l nd ne">module.exports.handle = (event, context, callback) =&gt; {<br/>  let data = encryptRequest.getParams(event)<br/>  if (encryptRequest.validate(data, callback)) {<br/>    data['_encrypted'] = httpEncryption.encrypt(data['_email'])<br/>    httpRoute.render('encrypt-success', data, callback)<br/>  }<br/>}</span></pre><p id="b503" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">加密是通过节点的内置<em class="mc"> crypto </em>模块完成的，它使用一个由自定义加密密钥环境变量创建的密码。</p><pre class="mt mu mv mw fq mx mb my mz aw na dt"><span id="7fad" class="md kw ik mb b fv nb nc l nd ne">const crypto = require('crypto')<br/><br/>const config = require('../../config.json')<br/><br/>module.exports.encrypt = function (str) {<br/>  let cipher = crypto.createCipher('aes-256-ctr', config.ENCRYPTION_KEY)<br/>  let crypted = cipher.update(str, 'utf8', 'hex')<br/>  crypted += cipher.final('hex')<br/>  return crypted<br/>}<br/><br/>module.exports.decrypt = function (str) {<br/>  let decipher = crypto.createDecipher('aes-256-ctr', config.ENCRYPTION_KEY)<br/>  let text = decipher.update(str, 'hex', 'utf8')<br/>  text += decipher.final('utf8')<br/>  return text<br/>}</span></pre><p id="9e47" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">加密的电子邮件地址通过生成HTTP响应的<em class="mc"> encrypt-success </em>路由返回给用户。</p><h1 id="27d1" class="kv kw ik bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">总结</h1><p id="ff3e" class="pw-post-body-paragraph jh ji ik jj b jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka lx kc kd ke hn dt translated">在这篇文章中，我们介绍了表单转发服务的创建过程，该服务可用于处理静态和动态网站的联系表单提交。在继续描述我的解决方案的技术架构之前，我浏览了可能的备选解决方案。该服务使用无服务器框架来部署到AWS Lambda，这允许它实现自托管的许多好处，但降低了复杂性。</p><p id="8537" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有关完整的项目代码和安装说明，请查看Github上的资源库。</p><div class="ht hu fm fo hv kf"><a href="https://github.com/danielireson/formplug-serverless" rel="noopener  ugc nofollow" target="_blank"><div class="kg ab ej"><div class="kh ab ki cl cj kj"><h2 class="bd il fv z el kk eo ep kl er et ij dt translated">Daniel reson/form plug-无服务器</h2><div class="km l"><h3 class="bd b fv z el kk eo ep kl er et ek translated">form plug-server less——form plug是AWS Lambda的无服务器表单后端</h3></div><div class="kn l"><p class="bd b gc z el kk eo ep kl er et ek translated">github.com</p></div></div><div class="ko l"><div class="nq l kq kr ks ko kt ib kf"/></div></div></a></div><p id="22f3" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你觉得这篇文章很有趣，你可能会喜欢<a class="ae ih" href="https://hackernoon.com/i-created-a-word-count-webhook-for-github-45c69ba0e22" rel="noopener ugc nofollow" target="_blank">我几周前写的一篇文章</a>，在这篇文章中，我经历了另一个无服务器项目。我用无服务器框架为Github创建了一个字数webhook。</p><div class="ht hu fm fo hv kf"><a href="https://hackernoon.com/i-created-a-word-count-webhook-for-github-45c69ba0e22" rel="noopener  ugc nofollow" target="_blank"><div class="kg ab ej"><div class="kh ab ki cl cj kj"><h2 class="bd il fv z el kk eo ep kl er et ij dt translated">为GitHub创建字数统计webhook</h2><div class="km l"><h3 class="bd b fv z el kk eo ep kl er et ek translated">虽然听起来像个人武器，但网钩不是个人武器。所以如果你想学习如何造成伤害…</h3></div><div class="kn l"><p class="bd b gc z el kk eo ep kl er et ek translated">hackernoon.com</p></div></div><div class="ko l"><div class="nr l kq kr ks ko kt ib kf"/></div></div></a></div><div class="mt mu mv mw fq ab cb"><figure class="ns hw nt nu nv nw nx paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="ns hw nt nu nv nw nx paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="ns hw nt nu nv nw nx paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="nf ng nh"><p id="f922" class="jh ji mc jj b jk jl jm jn jo jp jq jr ni jt ju jv nj jx jy jz nk kb kc kd ke hn dt translated"><a class="ae ih" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ih" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ih" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ih" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jh ji mc jj b jk jl jm jn jo jp jq jr ni jt ju jv nj jx jy jz nk kb kc kd ke hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ih" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ih" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="mt mu mv mw fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ny"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="mt mu mv mw fq hw"><div class="bz el l di"><div class="nz nm l"/></div></figure></div></div>    
</body>
</html>