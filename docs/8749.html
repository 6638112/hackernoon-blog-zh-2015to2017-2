<html>
<head>
<title>Javascript and Functional Programming — Pt. 3: Pure Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript和函数式编程。3:纯函数</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/javascript-and-functional-programming-pt-3-pure-functions-d572bb52e21c?source=collection_archive---------2-----------------------#2017-12-13">https://medium.com/hackernoon/javascript-and-functional-programming-pt-3-pure-functions-d572bb52e21c?source=collection_archive---------2-----------------------#2017-12-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="57e3" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">纯洁</h2></div><blockquote class="jj jk jl"><p id="ca4a" class="jm jn jo jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">注意:这是“Javascript和函数式<a class="ae kj" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>”系列中关于<a class="ae kj" href="https://hackernoon.com/tagged/learning" rel="noopener ugc nofollow" target="_blank">学习JavaScript ES6+中的</a>函数式编程技术的一部分。<a class="ae kj" href="https://hackernoon.com/javascript-and-functional-programming-currying-pt-4-96e3230782ab" rel="noopener ugc nofollow" target="_blank">点击这里查看JS中关于currying函数的第4部分。</a>从头开始检查出<a class="ae kj" href="https://hackernoon.com/javascript-and-functional-programming-an-introduction-286aa625e26d" rel="noopener ugc nofollow" target="_blank"> &lt;第1部分&gt; </a></p></blockquote><figure class="kl km kn ko fq kp fe ff paragraph-image"><div class="fe ff kk"><img src="../Images/26ab2673d812511013cdaa35633c4896.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/1*GikIcjG3t1qsAiWaQeBrog.png"/></div><figcaption class="ks kt fg fe ff ku kv bd b be z ek">Damn, this feels good</figcaption></figure><p id="9651" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kw jx jy jz kx kb kc kd ky kf kg kh ki hn dt translated"><strong class="jp hv">动机</strong></p><p id="b2c2" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kw jx jy jz kx kb kc kd ky kf kg kh ki hn dt translated">我们的许多错误都源于IO相关的、数据突变的、带有副作用的代码。这些问题遍布我们的代码库——从接受用户输入、通过http调用接收意外响应，到写入文件系统。不幸的是，这是一个严酷的现实，我们应该习惯于面对它。或者是？</p><p id="5629" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kw jx jy jz kx kb kc kd ky kf kg kh ki hn dt translated">如果我告诉你，我们可以最小化执行程序关键/易变部分的代码，会怎么样？我们可以强制(按照惯例)我们代码库的大部分都是<em class="jo">纯的，并且将与IO相关的</em> / <em class="jo">副作用</em>代码限制在我们代码库的特定部分。这将使我们的调试过程更容易，更连贯，更容易推理。</p><p id="7b99" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kw jx jy jz kx kb kc kd ky kf kg kh ki hn dt translated">那么，这个神话般的纯函数是什么呢？一个纯函数有两个主要特征:</p><h1 id="5026" class="kz la hu bd lb lc ld le lf lg lh li lj ja lk jb ll jd lm je ln jg lo jh lp lq dt translated"><strong class="ak"> 1。纯函数是确定性的</strong>。这意味着，给定相同的输入，函数将总是返回相同的输出。用数学术语来说明这个函数(这个会很快！)这是一个定义明确的函数。每次，每个输入都返回一个输出。</h1><figure class="kl km kn ko fq kp fe ff paragraph-image"><div class="fe ff lr"><img src="../Images/f281d89d0118bbc261e67099635de019.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*XIszYg4NZZF1nKZtgyAxCw.png"/></div><figcaption class="ks kt fg fe ff ku kv bd b be z ek">A pure function, in the wild!</figcaption></figure><h2 id="ad87" class="ls la hu bd lb lt lu lv lf lw lx ly lj kw lz ma ll kx mb mc ln ky md me lp mf dt translated">纯函数</h2><pre class="kl km kn ko fq mg mh mi mj aw mk dt"><span id="8fc9" class="ls la hu mh b fv ml mm l mn mo">const add = (x, y) =&gt; x + y // A pure function</span></pre><p id="e0e0" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kw jx jy jz kx kb kc kd ky kf kg kh ki hn dt translated"><em class="jo"> add </em>是一个纯函数，因为它的输出完全依赖于它接收的参数。因此，给定相同的值，它将总是产生相同的输出。</p><p id="d754" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kw jx jy jz kx kb kc kd ky kf kg kh ki hn dt translated">这个怎么样？</p><pre class="kl km kn ko fq mg mh mi mj aw mk dt"><span id="d70d" class="ls la hu mh b fv ml mm l mn mo">const magicLetter = '*'<br/>const createMagicPhrase = (phrase) =&gt; `${magicLetter}abra${phrase}`</span></pre><p id="90c5" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kw jx jy jz kx kb kc kd ky kf kg kh ki hn dt translated">这个有点可疑…createMagicPhrase函数依赖于其范围之外的值。所以，不纯粹！</p><h2 id="6d6c" class="ls la hu bd lb lt lu lv lf lw lx ly lj kw lz ma ll kx mb mc ln ky md me lp mf dt translated">不纯的函数</h2><pre class="kl km kn ko fq mg mh mi mj aw mk dt"><span id="de68" class="ls la hu mh b fv ml mm l mn mo">const fetchLoginToken = externalAPI.getUserToken</span></pre><p id="6a30" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kw jx jy jz kx kb kc kd ky kf kg kh ki hn dt translated">fetchLoginToken是纯函数吗？它每次都返回相同的值吗？绝对不行！有时它会工作——有时服务器会关闭，我们会得到一个500错误——在将来的某个时候，API可能会改变，这样这个调用就不再有效了！所以，因为函数是非确定的，我们可以有把握地说它是一个不纯的函数。</p><h1 id="6813" class="kz la hu bd lb lc ld le lf lg lh li lj ja lk jb ll jd lm je ln jg lo jh lp lq dt translated"><strong class="ak"> 2。单纯的功能不会造成副作用</strong>。副作用是系统中任何对外界来说<em class="mp">可见的</em>变化。</h1><pre class="kl km kn ko fq mg mh mi mj aw mk dt"><span id="c979" class="ls la hu mh b fv ml mm l mn mo">const calculateBill = (sumOfCart, tax) =&gt; sumOfCart * tax</span></pre><p id="9294" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kw jx jy jz kx kb kc kd ky kf kg kh ki hn dt translated"><em class="jo">算账单</em>纯吗？肯定:)它展示了两个必要的特征:</p><ul class=""><li id="34a5" class="mq mr hu jp b jq jr jt ju kw ms kx mt ky mu ki mv mw mx my dt translated">该函数只依赖于它的参数来产生结果</li><li id="055a" class="mq mr hu jp b jq mz jt na kw nb kx nc ky nd ki mv mw mx my dt translated">该功能不会产生任何副作用</li></ul><p id="65c4" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kw jx jy jz kx kb kc kd ky kf kg kh ki hn dt translated"><a class="ae kj" href="https://drboolean.gitbooks.io/mostly-adequate-guide/" rel="noopener ugc nofollow" target="_blank">最充分指南</a>指出副作用包括但不限于:</p><ul class=""><li id="bdd7" class="mq mr hu jp b jq jr jt ju kw ms kx mt ky mu ki mv mw mx my dt translated">更改文件系统</li><li id="edcf" class="mq mr hu jp b jq mz jt na kw nb kx nc ky nd ki mv mw mx my dt translated">将记录插入数据库</li><li id="7640" class="mq mr hu jp b jq mz jt na kw nb kx nc ky nd ki mv mw mx my dt translated">进行http调用</li><li id="e7eb" class="mq mr hu jp b jq mz jt na kw nb kx nc ky nd ki mv mw mx my dt translated">突变</li><li id="cc5b" class="mq mr hu jp b jq mz jt na kw nb kx nc ky nd ki mv mw mx my dt translated">打印到屏幕/记录</li><li id="1af5" class="mq mr hu jp b jq mz jt na kw nb kx nc ky nd ki mv mw mx my dt translated">获取用户输入</li><li id="3a38" class="mq mr hu jp b jq mz jt na kw nb kx nc ky nd ki mv mw mx my dt translated">查询DOM</li><li id="0894" class="mq mr hu jp b jq mz jt na kw nb kx nc ky nd ki mv mw mx my dt translated">访问系统状态</li></ul><h2 id="de1e" class="ls la hu bd lb lt lu lv lf lw lx ly lj kw lz ma ll kx mb mc ln ky md me lp mf dt translated">为什么我们的功能应该是纯粹的？</h2><figure class="kl km kn ko fq kp fe ff paragraph-image"><div class="fe ff ne"><img src="../Images/3ed5fec8d69bb0ff3c09416f26971e4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/1*bGt389cieRlBmqWLvJhqpw.gif"/></div><figcaption class="ks kt fg fe ff ku kv bd b be z ek">Aside from just being awesome</figcaption></figure><p id="2c89" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kw jx jy jz kx kb kc kd ky kf kg kh ki hn dt translated"><strong class="jp hv"> <em class="jo">可读性- &gt; </em> </strong>副作用让我们的代码更难阅读。由于非纯函数是不确定的，它可能会为给定的输入返回几个不同的值。我们最终会编写需要考虑不同可能性的代码。让我们看另一个基于http的例子:</p><figure class="kl km kn ko fq kp"><div class="bz el l di"><div class="nf ng l"/></div></figure><p id="9ba7" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kw jx jy jz kx kb kc kd ky kf kg kh ki hn dt translated">这个代码片段可能以多种不同的方式失败。如果传递给<em class="jo"> getTokenFromServer </em>的<em class="jo"> id </em>无效怎么办？如果服务器崩溃并返回一个错误，而不是预期的令牌，该怎么办？有很多突发事件需要计划，忘记一个(或几个！)对他们来说是非常容易的。</p><p id="d710" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kw jx jy jz kx kb kc kd ky kf kg kh ki hn dt translated">此外，一个纯函数更容易阅读，因为它不需要上下文。它预先接收所有需要的参数，并且不谈论/篡改应用程序的状态。</p><p id="8df7" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kw jx jy jz kx kb kc kd ky kf kg kh ki hn dt translated"><strong class="jp hv"> <em class="jo">可测性</em> - &gt; </strong>因为纯函数本质上是确定性的，所以为它们编写单元测试要简单得多。你的功能要么有效，要么无效😁</p><p id="acd4" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kw jx jy jz kx kb kc kd ky kf kg kh ki hn dt translated"><strong class="jp hv"> <em class="jo">并行代码</em> - &gt; </strong>由于纯函数只依赖于它们的输入，不会产生副作用，所以对于并行线程运行和使用共享内存的场景来说非常棒。</p><p id="e930" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kw jx jy jz kx kb kc kd ky kf kg kh ki hn dt translated"><strong class="jp hv"> <em class="jo">模块化和可重用性</em> - &gt; </strong>把纯功能想成逻辑的小单元。因为它们只依赖于您提供给它们的输入，所以您可以轻松地在代码库的不同部分或不同项目之间重用函数。</p><p id="093f" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kw jx jy jz kx kb kc kd ky kf kg kh ki hn dt translated"><strong class="jp hv"> <em class="jo">参照透明- &gt; </em> </strong>这个<em class="jo">听起来好复杂</em>🙄🙄当我第一次读到标题时，我想喝杯咖啡休息一下！简单地说，引用透明性意味着函数调用可以被它的输出值代替，而不改变程序的整体行为。这是创建纯函数时最有用的思维框架。</p><h2 id="d38f" class="ls la hu bd lb lt lu lv lf lw lx ly lj kw lz ma ll kx mb mc ln ky md me lp mf dt translated">它是纯洁的，而且…但是它有什么作用吗？</h2><p id="4892" class="pw-post-body-paragraph jm jn hu jp b jq nh iv js jt ni iy jv kw nj jy jz kx nk kc kd ky nl kg kh ki hn dt translated">值得注意的是，尽管纯函数提供了大量的好处，但是在我们的应用中只使用纯函数是不现实的。毕竟，如果我们这样做了，我们的应用程序将没有副作用，因此不会对外界产生任何可观察到的影响。那会很无聊😥😥😥。相反，我们将尝试将所有副作用封装到代码库的特定部分。这样，假设我们已经为我们的纯函数编写了单元测试，并且知道它们正在工作，如果我们的应用程序中出现了问题，跟踪起来会容易得多。</p><h2 id="3386" class="ls la hu bd lb lt lu lv lf lw lx ly lj kw lz ma ll kx mb mc ln ky md me lp mf dt translated">让我们变得纯洁</h2><p id="3f4f" class="pw-post-body-paragraph jm jn hu jp b jq nh iv js jt ni iy jv kw nj jy jz kx nk kc kd ky nl kg kh ki hn dt translated">让我们通过把下面的非纯函数转换成纯函数来结束我们的讨论。这是一个虚构的例子，但是演示了我们如何轻松地将unpure代码重构为pure。</p><figure class="kl km kn ko fq kp"><div class="bz el l di"><div class="nf ng l"/></div></figure><p id="affd" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kw jx jy jz kx kb kc kd ky kf kg kh ki hn dt translated">我们先来回顾一下为什么这个函数是不纯的。我们的函数是<em class="jo"> unpure </em>，因为它依赖于a和b，这在它的作用域之外。此外，它还直接改变了变量的值。重构这个函数的最快方法是</p><ul class=""><li id="1dd8" class="mq mr hu jp b jq jr jt ju kw ms kx mt ky mu ki mv mw mx my dt translated">首先确保函数依赖的所有变量都作为参数传递</li><li id="b274" class="mq mr hu jp b jq mz jt na kw nb kx nc ky nd ki mv mw mx my dt translated">我们可以返回反映新值的新值，而不是改变(操作)b和c。</li></ul><figure class="kl km kn ko fq kp"><div class="bz el l di"><div class="nf ng l"/></div></figure><h2 id="41c8" class="ls la hu bd lb lt lu lv lf lw lx ly lj kw lz ma ll kx mb mc ln ky md me lp mf dt translated">摘要</h2><p id="dfa7" class="pw-post-body-paragraph jm jn hu jp b jq nh iv js jt ni iy jv kw nj jy jz kx nk kc kd ky nl kg kh ki hn dt translated">我们已经介绍了转换我们的代码库以包含更多纯函数的许多好处。这使得我们的代码更容易推理、测试，最重要的是<strong class="jp hv"> <em class="jo">更容易预测。</em> </strong>记住，纯粹的函数并不意味着完全消除我们的代码库的<em class="jo">副作用。而是将他们限制在一个确定的位置，并尽可能多地消除他们。当你的程序开始变得越来越大，越来越复杂的时候，这种方法会被证明是正确的。</em></p><p id="6665" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kw jx jy jz kx kb kc kd ky kf kg kh ki hn dt translated"><a class="ae kj" href="https://hackernoon.com/javascript-and-functional-programming-currying-pt-4-96e3230782ab" rel="noopener ugc nofollow" target="_blank"> <strong class="jp hv">点击这里查看下一篇文章</strong> </a> <strong class="jp hv">，在这里我们将讨论JS中的函数组合，为什么它们会让你的代码更具可读性，以及你如何立即开始利用它们。</strong></p><h2 id="cff6" class="ls la hu bd lb lt lu lv lf lw lx ly lj kw lz ma ll kx mb mc ln ky md me lp mf dt translated">如果这篇文章有帮助，请点击拍手👏按钮以示支持！⬇⬇</h2><p id="7f78" class="pw-post-body-paragraph jm jn hu jp b jq nh iv js jt ni iy jv kw nj jy jz kx nk kc kd ky nl kg kh ki hn dt translated">你可以在<a class="ae kj" href="https://www.instagram.com/omeragoldberg/" rel="noopener ugc nofollow" target="_blank"> Instagram </a>、<a class="ae kj" href="https://www.linkedin.com/in/omer-goldberg-680b40100/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>和<a class="ae kj" rel="noopener" href="/@omergoldberg"> Medium </a>上关注我。</p><figure class="kl km kn ko fq kp"><div class="bz el l di"><div class="nm ng l"/></div></figure></div></div>    
</body>
</html>