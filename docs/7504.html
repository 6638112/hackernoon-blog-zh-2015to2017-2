<html>
<head>
<title>Reducing ETH Gas by making an Asynchronous Tx with Oraclize</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过使用Oraclize进行异步Tx来减少ETH气体</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/reducing-eth-gas-by-making-an-asynchronous-tx-with-oraclize-32a5d10236c8?source=collection_archive---------13-----------------------#2017-10-30">https://medium.com/hackernoon/reducing-eth-gas-by-making-an-asynchronous-tx-with-oraclize-32a5d10236c8?source=collection_archive---------13-----------------------#2017-10-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/96611348e3ab377d748aca20784d9b0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*ocWKIupyncl7nG1VwsFQKQ.jpeg"/></div></figure><p id="72aa" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在前一篇<a class="ae jw" rel="noopener" href="/@billyrennekamp/reducing-eth-gas-23x-by-converting-arrays-to-bytes-ccf3b46daea5">文章中(🤑)</a>通过将数组转换成字节串，我能够将一个<a class="ae jw" href="https://hackernoon.com/tagged/ethereum" rel="noopener ugc nofollow" target="_blank">以太坊</a>花费9500万(MM) gas的事务减少到4.1MM。这是建造<a class="ae jw" href="https://clovers.network" rel="noopener ugc nofollow" target="_blank">三叶草网络</a>过程中的一大步，但是4.1毫米的气体仍然是不可接受的。通过利用Oracle卸载大部分工作并只保存结果，我能够将它再次减少到1.5毫米——基本上是在以太坊虚拟机(EVM)上进行异步调用。</p><p id="3014" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">正在讨论的事务包含一个使用用户提供的走法玩黑白棋游戏的函数。如果游戏是有效的，并且之前没有注册过，用户就成为了那个棋盘的主人，并且可以把它作为三叶草出售(✤).此外，如果棋盘是对称的，那么相对于对称的稀有程度，用户将获得一个ERC20 ClubToken (︎♣︎)的采矿奖励。虽然这个游戏在EVM上编程相当简单，但复杂程度仍然非常昂贵。那是因为检查游戏过程中的每一步都是和那个游戏的结果一起保存的。这对于证明验证的方法很重要，但是还有另外一种不用花钱就能证明验证的方法:询问先知🔮。</p><p id="7b02" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">一个神谕提供了一个通往EVM之外世界的入口。如果你想知道当前乙醚的美元、欧元或英镑价格，去问先知吧。如果你想知道天气🌤在芝加哥，谁赢了小熊队🐻游戏或者你从✈️到奥德的航班是否会延迟——去问神谕吧。你还可以用神谕做一些在EVM上不可能做的事情，比如生成随机数。</p><p id="943e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">有一些关于这些功能是否属于以太坊<a class="ae jw" href="https://hackernoon.com/tagged/blockchain" rel="noopener ugc nofollow" target="_blank">区块链</a>的争论，因为理论上所有的交易都应该是可验证和可重复的——一个特定时刻的URL请求怎么可能是可重复的？(关于辩论和预言更多信息，请查看<a class="ae jw" href="https://blog.ethereum.org/2014/07/22/ethereum-and-oracles/" rel="noopener ugc nofollow" target="_blank">这里</a>，这里<a class="ae jw" href="https://blog.oraclize.it/understanding-oracles-99055c9c9f7b" rel="noopener ugc nofollow" target="_blank">这里</a>，这里<a class="ae jw" href="https://ethereum.stackexchange.com/questions/11589/how-do-oracle-services-work-under-the-hood" rel="noopener ugc nofollow" target="_blank">这里</a>。幸运的是，我想要一个oracle来调用已经在EVM上的函数。这样，验证的方法仍然是可验证的，但我不必花时间记录产生结果的所有步骤。</p></div><div class="ab cl jx jy hc jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hn ho hp hq hr"><h2 id="28ef" class="ke kf hu bd kg kh ki kj kk kl km kn ko jj kp kq kr jn ks kt ku jr kv kw kx ky dt translated">他说她说…</h2><figure class="la lb lc ld fq iv fe ff paragraph-image"><div class="fe ff kz"><img src="../Images/f67cccb875c20e593711605ccd8d3baf.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*ycCwcd8bE5tQhxojpKIrBA.png"/></div></figure><p id="1944" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Oraclize是一个oracle，它提供了大量的数据源，包括Wolfram Alpha、IPFS和任何可公开访问的URL。他们还提供了查询各种区块链的基本信息的能力，如区块数和开采难度。我需要使用<code class="eh le lf lg lh b">eth_call</code>在以太坊区块链上运行一个非事务性(常量)函数，但是Oraclize目前还没有提供。相反，我将使用<a class="ae jw" href="https://infura.io" rel="noopener ugc nofollow" target="_blank"> Infura的</a>公开可用的以太坊节点来进行JSON RPC事务(与<a class="ae jw" href="https://metamask.io" rel="noopener ugc nofollow" target="_blank"> Metamask </a>的方式相同)。在开始构建JSON RPC POST请求之前，我们先来看看目前为止的契约:</p><pre class="la lb lc ld fq li lh lj lk aw ll dt"><span id="24f8" class="ke kf hu lh b fv lm ln l lo lp">function claimGame(bytes28 firstMoves, bytes28 lastMoves) {<br/>  if (isReal(firstMoves, lastMoves)) {<br/>    saveGame(firstMoves, lastMoves);<br/>  }<br/>}</span><span id="52b5" class="ke kf hu lh b fv lq ln l lo lp">function isReal(bytes28 p1, bytes28 p2) constant returns(bool) {<br/>  // play the game and check for completeness and errors<br/>  ...<br/>}</span><span id="dd1b" class="ke kf hu lh b fv lq ln l lo lp">function saveGame(bytes28 p1, bytes28 p2) {<br/>  // finally save the game<br/>  ...<br/>}</span></pre><p id="ce20" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这里的<code class="eh le lf lg lh b">checkGame()</code>是一个以游戏棋步为参数的函数——在这种情况下，棋步以字节28格式存储(关于以字节存储数据的类似技术，请查看我前面提到的<a class="ae jw" rel="noopener" href="/@billyrennekamp/reducing-eth-gas-23x-by-converting-arrays-to-bytes-ccf3b46daea5">arrays to bytes文章</a>)。<code class="eh le lf lg lh b">checkGame()</code>做的第一件事是通过使用<code class="eh le lf lg lh b">isReal()</code>检查移动是否在玩一个真实的游戏。这是我试图避免的合同中昂贵的部分。但是，您会注意到它是一个常量函数，这意味着它不会改变区块链上的任何内容。这就是为什么有神谕可以召唤它，而神谕不需要支付任何汽油。之后，oracle可以将结果发送回合同，以便以较低的成本保存。</p></div><div class="ab cl jx jy hc jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hn ho hp hq hr"><h2 id="967f" class="ke kf hu bd kg kh ki kj kk kl km kn ko jj kp kq kr jn ks kt ku jr kv kw kx ky dt translated">添加Oraclize</h2><figure class="la lb lc ld fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="fe ff lr"><img src="../Images/595ebe774f29e4c2239ae10e8fc4d907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7FTd3gFGwh67r_AikCRUMw.jpeg"/></div></div></figure><p id="9906" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">利用Oraclize的第一步是将他们的合同添加到您的合同中。你可以从他们的<a class="ae jw" href="https://github.com/oraclize/ethereum-api" rel="noopener ugc nofollow" target="_blank"> github </a>下载oraclizeAPI.sol的副本。把它添加到你的契约的顶部，让你的契约继承这些函数。在这种情况下，我称我的合同为CheapTrick。</p><pre class="la lb lc ld fq li lh lj lk aw ll dt"><span id="7d6d" class="ke kf hu lh b fv lm ln l lo lp">pragma solidity ^0.4.13;</span><span id="9bfc" class="ke kf hu lh b fv lq ln l lo lp">import "./oraclizeAPI.sol";<br/>contract CheapTrick is usingOraclize {<br/>  ...<br/>}</span></pre><p id="c09f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">下一步是用指定的URL数据源触发Oracle。契约继承了函数<code class="eh le lf lg lh b">oraclize_query</code>,该函数根据您的需要采用各种不同的参数。我们将使用这样的格式，第一个参数作为数据源，第二个参数作为URL端点，第三个参数作为POST对象随请求一起发送。或者，您可以添加一个整数，表示在触发请求之前等待的秒数，以及回调中使用的gas的明确数量。</p><pre class="la lb lc ld fq li lh lj lk aw ll dt"><span id="e39c" class="ke kf hu lh b fv lm ln l lo lp">function claimGame(bytes28 firstMoves, bytes28 lastMoves) {<br/>  oraclize_query('URL', 'https://infura.io', '{...}');<br/>}</span></pre><p id="2cb1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">最后一步是调用继承的<code class="eh le lf lg lh b">__callback()</code>函数来处理URL数据源查询的结果。</p><pre class="la lb lc ld fq li lh lj lk aw ll dt"><span id="6def" class="ke kf hu lh b fv lm ln l lo lp">function __callback(bytes32 queryId, string results) {<br/>  if (results == 'true') saveGame(???, ???);<br/>}</span></pre><p id="f426" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">你会注意到，在这个回调中，你已经丢失了对正在进行的移动的引用。Oraclize提供了一个查询ID来帮助完成这个过程。为了跟踪哪一个回调属于哪一个查询，您可以使用如下的映射和结构来跟踪它们:</p><pre class="la lb lc ld fq li lh lj lk aw ll dt"><span id="35a4" class="ke kf hu lh b fv lm ln l lo lp">pragma solidity ^0.4.13;</span><span id="443e" class="ke kf hu lh b fv lq ln l lo lp">import "./oraclizeAPI.sol";<br/>contract CheapTrick is usingOraclize {</span><span id="cc3a" class="ke kf hu lh b fv lq ln l lo lp">  struct Moves {<br/>    bytes28 firstMoves;<br/>    bytes28 lastMoves;<br/>  }</span><span id="0e73" class="ke kf hu lh b fv lq ln l lo lp">  mapping (bytes32 =&gt; Moves) validIds;<br/><br/>  // oraclize_query returns the query ID that is used in the mapping<br/>  function claimGame(bytes28 firstMoves, bytes28 lastMoves) {<br/>    bytes32 q = oraclize_query('URL', 'https://infura.io', '{...}');<br/>    validIds[q].firstMoves = firstMoves;<br/>    validIds[q].lastMoves = lastMoves;<br/>  }</span><span id="d733" class="ke kf hu lh b fv lq ln l lo lp">  function __callback(bytes32 q, string result) {<br/>    if (bytes(result)[65] == 0x31) {<br/>      saveGame(validIds[q].firstMoves, validIds[q].lastMoves);<br/>    }<br/>  }</span><span id="777f" class="ke kf hu lh b fv lq ln l lo lp">  ...</span><span id="2bca" class="ke kf hu lh b fv lq ln l lo lp">}</span></pre><p id="e5eb" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在这种情况下，使用查询ID作为键，将查询ID保存在结构的映射中。当回调被触发时，可以使用相同的查询ID再次提取移动。</p></div><div class="ab cl jx jy hc jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hn ho hp hq hr"><h2 id="7e13" class="ke kf hu bd kg kh ki kj kk kl km kn ko jj kp kq kr jn ks kt ku jr kv kw kx ky dt translated">弦理论</h2><figure class="la lb lc ld fq iv fe ff paragraph-image"><div class="fe ff lw"><img src="../Images/1d1a5667e38a4154926dcac3ee2b927a.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*uJZ7e_YUxNOtEbvtL-s83Q.png"/></div></figure><p id="eaaa" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">你可能也注意到了<code class="eh le lf lg lh b">if(bytes(result)[65] == 0x31)</code>这句台词，或者被它搞糊涂了。这才是之前被错误使用的<code class="eh le lf lg lh b">if (results == ‘true’)</code>的真实执行方式。<code class="eh le lf lg lh b">oraclize_query()</code>点击了一个JSON RPC端点，该端点将依次调用之前看到的<code class="eh le lf lg lh b">isReal()</code>函数。此函数返回一个布尔值，但是由于以太坊以字节32为增量工作，所以布尔值返回为字节32。它不返回字符串“true ”,而是返回十六进制值1。</p><pre class="la lb lc ld fq li lh lj lk aw ll dt"><span id="df72" class="ke kf hu lh b fv lm ln l lo lp">true<!-- -->  = <!-- -->0x0000000000000000000000000000000000000000000000000000000000000001</span><span id="f4ed" class="ke kf hu lh b fv lq ln l lo lp">false<!-- --> = <!-- -->0x0000000000000000000000000000000000000000000000000000000000000000</span></pre><p id="1f6a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">由于<code class="eh le lf lg lh b">__callback()</code>中的结果实际上是一个字符串，这变得更加复杂。所以它不是返回<code class="eh le lf lg lh b">bytes32</code>，而是由<code class="eh le lf lg lh b">string</code>表示的<code class="eh le lf lg lh b">bytes32</code>。</p><pre class="la lb lc ld fq li lh lj lk aw ll dt"><span id="c279" class="ke kf hu lh b fv lm ln l lo lp">true<!-- -->  = "<!-- -->0x0000000000000000000000000000000000000000000000000000000000000001"<br/><br/>false<!-- --> = "<!-- -->0x0000000000000000000000000000000000000000000000000000000000000000"</span></pre><p id="9f8d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了检测游戏是否有效，我们需要查看字符串中的最后一个值，并检测它是<code class="eh le lf lg lh b">1</code>还是<code class="eh le lf lg lh b">0</code>。在Solidity中处理字符串时，重要的是要记住它们是作为UTF8字符的字节数组(<code class="eh le lf lg lh b">bytes[]</code>)存储的。根据w3schools.com的说法，我们字符串中的UTF8控制字符如下所示:</p><pre class="la lb lc ld fq li lh lj lk aw ll dt"><span id="5d1d" class="ke kf hu lh b fv lm ln l lo lp">string 0 = decimal 48  = hex 0x30<br/>string 1 = decimal 49  = hex 0x31<br/>string x = decimal 120 = hex 0x78</span></pre><p id="0e29" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在可靠性方面，我们的字符串如<code class="eh le lf lg lh b">bytes[]</code>所示，看起来像这样:</p><pre class="la lb lc ld fq li lh lj lk aw ll dt"><span id="bcb5" class="ke kf hu lh b fv lm ln l lo lp">string = "<!-- -->0x0000000000000000000000000000000000000000000000000000000000000001"</span><span id="00fc" class="ke kf hu lh b fv lq ln l lo lp">string[] = ["0", "x", "0", "0", ..., "1"];<br/>bytes[] = [0x30, 0x78, 0x30, 0x30, ..., 0x31];</span></pre><p id="e103" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们需要检查数组中的最后一个元素，所以我们使用上面契约中的相同代码片段:<code class="eh le lf lg lh b">bytes(result)[65] == 0x31</code>(记住由于<code class="eh le lf lg lh b">0x</code>前言，数组的长度为<code class="eh le lf lg lh b">66</code>)然后<strong class="ja hv">瞧</strong>我们检测结果是真还是假。</p><figure class="la lb lc ld fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="fe ff lx"><img src="../Images/17c86b9f2ab912fbd5e0cc6d4c76fe73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7LOVqho8FA6nNhrkOQMRsg.png"/></div></div></figure><p id="f4ef" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在这一点上，需要指出的是，Oraclize还提供了通过docker配置向IPFS上传一段定制代码的能力，这将允许它在Amazon micro服务器上部署足够长的时间，以返回结果而不是URL数据源。如果这样做了，返回的字符串可能比我们从RPC端点得到的字符串更有效。然而，一个URL数据源每个查询要花费合同所有者大约0.01美元，而微服务器每个请求要花费大约0.50美元。(如果你还在读这篇文章，你现在应该知道我一直在寻找这些交易🤑)</p></div><div class="ab cl jx jy hc jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hn ho hp hq hr"><h2 id="c6ea" class="ke kf hu bd kg kh ki kj kk kl km kn ko jj kp kq kr jn ks kt ku jr kv kw kx ky dt translated">JSON RPC POST</h2><figure class="la lb lc ld fq iv fe ff paragraph-image"><div class="fe ff ly"><img src="../Images/043bda339ba0290f02ce16c77f913759.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*XRbQ-Akcnp6ebbI6XiYP7w.jpeg"/></div></figure><p id="a4d6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">对于最后一部分，重要的是要了解发送到Infura端点的JSON RPC POST对象内部的实际内容，这个端点之前由邪恶的<code class="eh le lf lg lh b">{…}</code>表示。这意味着我们需要根据这里的 中的<strong class="ja hv"> JSON-RPC规范</strong> <a class="ae jw" href="https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_call" rel="noopener ugc nofollow" target="_blank"> <strong class="ja hv">手工创建我们的事务，并根据这里的</strong> </a>中的<strong class="ja hv">以太坊契约ABI规范</strong> <a class="ae jw" href="https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI" rel="noopener ugc nofollow" target="_blank">创建数据对象。我们的基本<code class="eh le lf lg lh b">eth_call</code>函数遵循以下格式:</a></p><pre class="la lb lc ld fq li lh lj lk aw ll dt"><span id="4c14" class="ke kf hu lh b fv lm ln l lo lp">// Request<br/>curl -X POST --data '{"jsonrpc":"2.0","method":"eth_call","params":[{coming soon}],"id":1}'<br/><br/>// Result<br/>{<br/>  "id":1,<br/>  "jsonrpc": "2.0",<br/>  "result": "0x"<br/>}</span></pre><p id="a418" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">params数组由一个对象组成，该对象包含协定地址和正在发送的数据，以及所需的块号:</p><pre class="la lb lc ld fq li lh lj lk aw ll dt"><span id="5092" class="ke kf hu lh b fv lm ln l lo lp">{"jsonrpc": "2.0", "method": "eth_call", "params": [<strong class="lh hv">{to:"0xFAK3W4LL374DDR355", data:"...."}, "latest"]</strong>}</span></pre><p id="e3c9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">数据值将是所需函数名和随其一起发送的参数的十六进制表示。根据规范，函数名由 <strong class="ja hv">散列</strong><strong class="ja hv">字符串</strong><em class="lz"/><strong class="ja hv">名称</strong><em class="lz"/><strong class="ja hv">函数</strong>的<strong class="ja hv">前4个字节</strong> <em class="lz">表示(包括任何参数😳<strong class="ja hv"> ) </strong>。在我们使用<a class="ae jw" href="https://github.com/ethereum/web3.js/tree/1.0/packages/web3-utils" rel="noopener ugc nofollow" target="_blank"> web3.js实用程序</a>帮助的例子中，它看起来如下:</em></p><pre class="la lb lc ld fq li lh lj lk aw ll dt"><span id="05b2" class="ke kf hu lh b fv lm ln l lo lp">var utils = require('web3-utils')</span><span id="4d1e" class="ke kf hu lh b fv lq ln l lo lp">let functionName = "<strong class="lh hv">isReal(bytes28,bytes28)</strong>"</span><span id="d381" class="ke kf hu lh b fv lq ln l lo lp">functionName = utils.sha3(functionName)<br/>//<strong class="lh hv">0x6b3bd7986bb57b171ccf6056a91eae803767c4600238e08445ece9b98c39ca21</strong></span><span id="ddff" class="ke kf hu lh b fv lq ln l lo lp">functionName = utils.hexToBytes(functionName)<br/>// <strong class="lh hv">[107, 59, 215, 152, 107, 181, 123, 23, 28, 207, 96, 86, 169, 30, 174, 128, 55, 103, 196, 96, 2, 56, 224, 132, 69, 236, 233, 185, 140, 57, 202, 33]</strong></span><span id="0462" class="ke kf hu lh b fv lq ln l lo lp">functionName = functionName.slice(0, 4)<br/>// <strong class="lh hv">[107, 59, 215, 152]</strong></span><span id="64c8" class="ke kf hu lh b fv lq ln l lo lp">functionName = utils.bytesToHex(functionName)<br/>// <strong class="lh hv">0x6b3bd798</strong></span></pre><p id="f490" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">结果我们的函数名看起来像<code class="eh le lf lg lh b">0x6b3bd798</code>。下一部分是用字节表示参数。由于我们的移动已经是十六进制格式，我们只需要通过填充它们并删除0x前缀，将它们从28字节调整为32字节:</p><pre class="la lb lc ld fq li lh lj lk aw ll dt"><span id="5ebf" class="ke kf hu lh b fv lm ln l lo lp">var utils = require('web3-utils')</span><span id="5e07" class="ke kf hu lh b fv lq ln l lo lp">let firstMoves = "0xd9b7774f9af573c5d69d4996a971f147dfac39f7e9f37785891dfee5"</span><span id="f4d2" class="ke kf hu lh b fv lq ln l lo lp">first32Moves = utils.padRight(first32Moves.slice(2), (32 * 2))<br/>// <strong class="lh hv">d9b7774f9af573c5d69d4996a971f147dfac39f7e9f37785891dfee500000000</strong></span><span id="4a63" class="ke kf hu lh b fv lq ln l lo lp">let lastMoves = "0xbd9bb7ed12e559bfcaad69b5f04fa1061438927fc681167470000000"</span><span id="794a" class="ke kf hu lh b fv lq ln l lo lp">lastMoves = utils.padRight(lastMoves.slice(2), (32 * 2))<br/>// <strong class="lh hv">bd9bb7ed12e559bfcaad69b5f04fa1061438927fc68116747000000000000000</strong></span></pre><p id="e226" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">把它们放在一起，我们就得到了数据🎉</p><pre class="la lb lc ld fq li lh lj lk aw ll dt"><span id="b760" class="ke kf hu lh b fv lm ln l lo lp">{"jsonrpc": "2.0", "method": "eth_call", "params": [{to:"0xFAK3C0N7R4C7W411374DDR355", data:"<strong class="lh hv">6b3bd798</strong><strong class="lh hv">d9b7774f9af573c5d69d4996a971f147dfac39f7e9f37785891dfee500000000bd9bb7ed12e559bfcaad69b5f04fa1061438927fc68116747000000000000000</strong>"}, "latest"]}</span></pre><p id="9886" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">你可以使用Oraclize强大的查询测试器<a class="ae jw" href="http://app.oraclize.it/home/test_query#VVJMKFBPU1Qp:anNvbihodHRwczovL21haW5uZXQuaW5mdXJhLmlvLykucmVzdWx0:IHsianNvbnJwYyI6IjIuMCIsImlkIjoxLCJtZXRob2QiOiJldGhfYmxvY2tOdW1iZXIiLCJwYXJhbXMiOltdfQ==" rel="noopener ugc nofollow" target="_blank">在这里</a>测试结果。这个示例代码并不对应于一个已部署的契约，所以实际上不会工作。但是，如果您点击链接，您将看到一个请求当前块号的工作示例。<strong class="ja hv">非常重要:不要忘记在POST有效负载的开头或结尾添加一个空格字符。这告诉Oraclize数据实际上是一个POST对象。在Oraclize团队有人回答我的github问题之前，我遇到了很多麻烦🙏</strong></p></div><div class="ab cl jx jy hc jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hn ho hp hq hr"><h2 id="04bd" class="ke kf hu bd kg kh ki kj kk kl km kn ko jj kp kq kr jn ks kt ku jr kv kw kx ky dt translated">最后</h2><figure class="la lb lc ld fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="fe ff ma"><img src="../Images/280495d242c334d7e3ea0c37538b9f0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cgTFqerihDqpPek4T4jWxA.png"/></div></div></figure><p id="4e50" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们总共涵盖了:</p><ul class=""><li id="0769" class="mb mc hu ja b jb jc jf jg jj md jn me jr mf jv mg mh mi mj dt translated">什么是神谕</li><li id="5f82" class="mb mc hu ja b jb mk jf ml jj mm jn mn jr mo jv mg mh mi mj dt translated">如何导入和使用Oraclize的API契约</li><li id="0fc9" class="mb mc hu ja b jb mk jf ml jj mm jn mn jr mo jv mg mh mi mj dt translated">如何跟踪查询和回调</li><li id="9113" class="mb mc hu ja b jb mk jf ml jj mm jn mn jr mo jv mg mh mi mj dt translated">如何在Solidity中使用字符串</li><li id="8ffb" class="mb mc hu ja b jb mk jf ml jj mm jn mn jr mo jv mg mh mi mj dt translated">如何创建对Infura端点的JSON RPC eth_call</li></ul><figure class="la lb lc ld fq iv"><div class="bz el l di"><div class="mp mq l"/></div></figure></div></div>    
</body>
</html>