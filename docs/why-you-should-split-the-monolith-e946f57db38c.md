# 为什么你应该分开整块石头

> 原文：<https://medium.com/hackernoon/why-you-should-split-the-monolith-e946f57db38c>

这是定义正确的服务边界系列的第一部分。

如今，任何组织的主要特征都可能是商业灵活性。业务敏捷性是一个衡量指标，表明您的组织对市场变化，或者更广泛地说，对环境变化的反应速度，以及引入新的解决方案的速度。因此，如果缺乏业务敏捷性，任何企业都注定会失败，这是迟早的事。它只会变得毫无竞争力。

因此，作为任何企业的一部分，it 部门的主要特征也是业务敏捷性。

让我们看得更深入一点。作为一名开发人员，当我面对一个新的业务需求时，无论是全新的业务功能还是对现有功能的一些更改，都应该快速完成该需求，并且不破坏任何现有功能。如果开发速度不会随着代码库变大而变慢，那就太好了。这就是我所说的 IT 部门的敏捷性。这也可能是该部门的主要特点。

唯一阻碍我实现这一崇高目标的是系统的复杂性，纠缠。是的，我说的是 codebase。但是复杂性并不是任何软件的固有特征。世界上还没有任何软件从一开始就是复杂的。复杂性是后天获得的特征。所以，我的目标是打败它。

任何软件复杂性的根源是什么？在回答之前，请回忆一下您必须修复一些代码的频率，并猜测哪些功能会受到影响？有多少次你没猜到？经常，你呢？这是紧耦合的一种表现。这也是阻碍我们又好又快地完成工作的原因。

[巨石](https://www.thoughtworks.com/insights/blog/monoliths-are-bad-design-and-you-know-it)天生沉湎于紧耦合。使用任何模块的类都很容易！好吧，只有这一次，只有在这里，因为我没有时间让它正确的方式，我正在创建一个技术债务的任务！面对现实吧，这次不仅仅是*。所以不仅仅是这里的*。和业务-家伙不给予一个该死的技术债务任务。因此，在我们的代码中实现的业务流程以无数不可预测和完全不可能理解的方式交织在一起。出现了许多隐含的依赖性。代码变得越来越难阅读和更改，通过在一个地方修复一些东西，我们会在另一个地方得到更多的错误。**

**所以我们都得出了一个结论，我们需要逻辑上分离的部分，而不是一个整体。如何正确界定这些部分的界限？这些部分应该如何相互通信？**

**现在我想把我的定义说清楚。作为 monolith 分割结果的部分可以包含任意数量的物理服务器，这些服务器可以包含后端代码和 UI 数据。这些部分中可以有任意数量的数据库。它们都可以有不同的模式。也可能没有。这些数据库可以位于一台物理服务器上。或者在不止一个上。从现在开始，我将称这些逻辑部分为*服务*。**

**在[的下一篇文章](/@wrong.about/wrong-ways-of-defining-service-boundaries-d9e313007bcc)中，我将谈论我在野外看到的定义服务边界的方法，这些方法存在不同严重程度的缺陷。**