<html>
<head>
<title>A Monad Writer for F#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">F#的单子作者</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-monad-writer-for-f-26aa987e4a3a?source=collection_archive---------10-----------------------#2017-10-16">https://medium.com/hackernoon/a-monad-writer-for-f-26aa987e4a3a?source=collection_archive---------10-----------------------#2017-10-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/7bc6fc5cd0e420b68d99b09b7862ec60.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*1O9n7htSTUxyRVpfWnL1Hw.png"/></div></figure><p id="258a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">几年前开始学<strong class="ja hv"> F# </strong>。这让我走上了只用纯函数方法在F# 中为纯函数语言构建完整编译器的道路。</p><p id="a0a9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">从那以后，我转到了Scala，再也没有回到。NET框架。但是，有时候我很怀念<strong class="ja hv"> F# </strong>的简洁和表现力。我在之前写的一些帖子里已经演示过了比如Scala中的(<a class="ae jw" href="https://hackernoon.com/operator-in-scala-cbca7b939fc0" rel="noopener ugc nofollow" target="_blank"> <strong class="ja hv"> <em class="jx"> | &gt;运算符</em> </strong> </a> <strong class="ja hv"> <em class="jx">，</em> </strong> <a class="ae jw" href="https://hackernoon.com/higher-order-functions-what-are-they-be74111659e8" rel="noopener ugc nofollow" target="_blank"> <strong class="ja hv"> <em class="jx">高阶函数，它们是什么？</em></strong></a><strong class="ja hv"><em class="jx"/></strong><a class="ae jw" rel="noopener" href="/@anicolaspp/what-comes-next-to-higher-order-functions-2279d07b4efc"><strong class="ja hv"><em class="jx">下一个高阶函数</em> </strong> </a>)。</p><p id="46e3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">回到今天的F# 只是为了怀念一些我经常使用的Scala构造，即<em class="jx">单子作者</em>。</p><p id="de9c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">日志记录是我们应用程序的重要组成部分。然而，我们很少做纯功能日志。我不打算解释为什么或者为什么不进行函数式日志记录，但是我们将看到通过使用<em class="jx">单子编写器</em>在<strong class="ja hv"> F# </strong>中编写和使用纯函数式日志记录是多么简单。</p><p id="7115" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们需要做的第一件事，是创建一个<em class="jx"> Writer </em>的方法。具体来说，我们希望能够访问我们将在下一步操作中使用的初始编写器。</p><p id="c5c1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这应该像下面这样简单:</p><pre class="jy jz ka kb fq kc kd ke kf aw kg dt"><span id="df94" class="kh ki hu kd b fv kj kk l kl km">let writer = bind 5 "starting"</span></pre><p id="5fc9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><code class="eh kn ko kp kd b">bind</code>操作应该返回一个<em class="jx">写入器</em>，其初始值为<code class="eh kn ko kp kd b">5</code>，要记录的初始值为<code class="eh kn ko kp kd b">starting</code>。</p><p id="34d3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了做到这一点，我们需要定义一个<em class="jx">编写器</em>的样子。</p><pre class="jy jz ka kb fq kc kd ke kf aw kg dt"><span id="0616" class="kh ki hu kd b fv kj kk l kl km">type Writer&lt;'a, 'L&gt; = AWriter of 'a * List&lt;'L&gt;</span></pre><p id="7646" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">一个简单的区别对待的联盟就足够了。我们需要一个通用类型<code class="eh kn ko kp kd b">‘a</code>和通用<code class="eh kn ko kp kd b">‘L</code>，这是我们的日志。当然，我们并不局限于只记录<code class="eh kn ko kp kd b">string</code>。事实上，日志的元素可以是任何类型的。为了方便和简单，我们大部分时间都将使用<code class="eh kn ko kp kd b">string</code>,但是我们可以使用任何其他类型作为日志的一部分。</p><p id="42ea" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">此时，我们只需要<code class="eh kn ko kp kd b">bind</code>函数，这样它就创建了所需的<em class="jx">编写器</em>。</p><pre class="jy jz ka kb fq kc kd ke kf aw kg dt"><span id="047c" class="kh ki hu kd b fv kj kk l kl km">let bind = function <br/>         | (v, itemLog) -&gt; AWriter(v, [itemLog])</span></pre><p id="cb48" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><code class="eh kn ko kp kd b">bind</code>是一个接收两个参数的函数，一个通用值<code class="eh kn ko kp kd b">v</code>和第一个要记录的项目<code class="eh kn ko kp kd b">itemLog</code>，然后它返回我们最初的<em class="jx">作者</em>。</p><p id="4e74" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，我们需要一种方法来映射<em class="jx">写入器</em>的值，这样我们就可以在不影响日志的情况下改变装箱值的类型。让我们看看如何写<code class="eh kn ko kp kd b">map</code></p><pre class="jy jz ka kb fq kc kd ke kf aw kg dt"><span id="627b" class="kh ki hu kd b fv kj kk l kl km">let map fx = function<br/>         | AWriter(a, log) -&gt; AWriter(fx a, log)</span></pre><p id="8424" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在这里，<code class="eh kn ko kp kd b">map</code>使用另一个函数<code class="eh kn ko kp kd b">fx</code>，通过创建一个新的<em class="jx">写入器</em>来应用于<em class="jx">写入器</em>值<code class="eh kn ko kp kd b">a</code>。请注意，我们从不改变一个作者，我们只是创造新的<em class="jx">作者</em>。</p><p id="4be4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">只有这两个，我们可以开始定义其他函数，这些函数在保持引用透明的同时返回<em class="jx"> Writers </em>(做日志记录)。</p><p id="cfef" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们定义一些可以在程序中使用的函数。</p><pre class="jy jz ka kb fq kc kd ke kf aw kg dt"><span id="3198" class="kh ki hu kd b fv kj kk l kl km">let sum x y = bind (x + y, "sum")<br/>let mul x y = bind (x * y, "mul")<br/>let mod1 x y = bind (x % y, "mod")<br/>let minus x y = bind (x - y, "minus")</span></pre><p id="1cc9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">请注意，所有这些函数只有一个单一的职责，求和、乘法、求模和计算差。他们不了解全局记录器，也不向共享状态添加任何内容。它们非常小，测试起来非常简单；它们是纯函数。</p><p id="a829" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们可以看到，它们都通过函数<code class="eh kn ko kp kd b">bind</code>返回一个<em class="jx">编写器</em>。由于先进的<strong class="ja hv"> F# </strong>类型系统和类型推断，像这样定义函数是一件非常容易的事情。</p><p id="5792" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">通过使用<code class="eh kn ko kp kd b">map</code>，我们可以进行如下转换。</p><pre class="jy jz ka kb fq kc kd ke kf aw kg dt"><span id="322b" class="kh ki hu kd b fv kj kk l kl km">let str a = a.ToString()</span><span id="1a96" class="kh ki hu kd b fv kq kk l kl km">let to_string a = a |&gt; map str</span><span id="7417" class="kh ki hu kd b fv kq kk l kl km">sum 5 5 |&gt; to_string</span></pre><p id="43f4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们仔细看看这部分。</p><p id="d918" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">首先，我们创建了一个具有值<code class="eh kn ko kp kd b">5 + 5 = 10</code>和日志<code class="eh kn ko kp kd b">["sum"]</code>的<em class="jx">写入器</em>，然后我们调用<code class="eh kn ko kp kd b">to_string</code>，它基本上调用<code class="eh kn ko kp kd b">map</code>，因此结果是一个具有值<code class="eh kn ko kp kd b">"10"</code>和相同日志<code class="eh kn ko kp kd b">["sum"]</code>的<em class="jx">写入器</em>。我们已经通过<code class="eh kn ko kp kd b">map</code>修改了<em class="jx">写入器</em>的值，而没有触及日志。</p><p id="8105" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">从<em class="jx">作家</em>那里得到的东西呢？</p><p id="e03b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们定义一个简单的方法来提取当前值和我们到目前为止一直在构建的日志。</p><pre class="jy jz ka kb fq kc kd ke kf aw kg dt"><span id="5962" class="kh ki hu kd b fv kj kk l kl km">let run = function<br/>         | AWriter(a, log) -&gt; (a, log)</span></pre><p id="86ca" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><code class="eh kn ko kp kd b">run</code>是接收<em class="jx">写入器</em>并以元组形式返回值和日志的函数。现在我们可以看看<em class="jx">作者</em>的内容了。</p><pre class="jy jz ka kb fq kc kd ke kf aw kg dt"><span id="c3e4" class="kh ki hu kd b fv kj kk l kl km">let (v, log) = run (sum 5 5)</span></pre><p id="3682" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">或者用更惯用的<strong class="ja hv"> F# </strong></p><pre class="jy jz ka kb fq kc kd ke kf aw kg dt"><span id="b016" class="kh ki hu kd b fv kj kk l kl km">let (v, log) = sum 5 5 |&gt; run</span></pre><p id="83a5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在这里，<code class="eh kn ko kp kd b">v</code>是数值<code class="eh kn ko kp kd b">10</code>，<code class="eh kn ko kp kd b">log</code>是<code class="eh kn ko kp kd b">["sum"]</code>。</p><p id="6b23" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">之前，我们已经定义了不同的函数，其中所有的函数都返回<em class="jx"> Writers </em> ( <em class="jx"> sum，mul，mod1，minus </em>)，但是我们没有办法将定义的操作组合起来，以便将每个操作的结果聚合到一个日志中。</p><p id="a3d1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">缺少的操作是<code class="eh kn ko kp kd b">flatMap</code>。</p><pre class="jy jz ka kb fq kc kd ke kf aw kg dt"><span id="3f4e" class="kh ki hu kd b fv kj kk l kl km">let flatMap fx = function<br/>         | AWriter(a, log) -&gt; <br/>             let (v, new_log) = fx a |&gt; run<br/>             AWriter(v, List.append log new_log)</span></pre><p id="0435" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><code class="eh kn ko kp kd b">flatMap</code>接收一个类型为<code class="eh kn ko kp kd b">'a -&gt; Writer(b, List&lt;`L&gt;</code>的函数并返回一个新的<em class="jx">编写器</em>。如果我们仔细观察一下，<code class="eh kn ko kp kd b">flatMap</code>负责聚合来自多个编写器的日志。</p><p id="033e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们看一个可能更有启发性的例子。</p><pre class="jy jz ka kb fq kc kd ke kf aw kg dt"><span id="48d8" class="kh ki hu kd b fv kj kk l kl km">let result = <br/>         sum 5 5 <br/>         |&gt; flatMap (mul 2) <br/>         |&gt; flatMap (mod1 25) <br/>         |&gt; flatMap (minus 10)</span></pre><p id="09d6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">最后一个值<code class="eh kn ko kp kd b">result</code>，是一个<em class="jx">写入器</em>，我们可以在这里调用<code class="eh kn ko kp kd b">run</code>。</p><pre class="jy jz ka kb fq kc kd ke kf aw kg dt"><span id="e366" class="kh ki hu kd b fv kj kk l kl km">let (v, log) = run result</span><span id="2dd7" class="kh ki hu kd b fv kq kk l kl km">System.Console.WriteLine v</span><span id="bfe3" class="kh ki hu kd b fv kq kk l kl km">for i in log do<br/>    System.Console.WriteLine i</span></pre><p id="8fc5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这将打印出:</p><pre class="jy jz ka kb fq kc kd ke kf aw kg dt"><span id="6b48" class="kh ki hu kd b fv kj kk l kl km">5<br/>sum<br/>mul<br/>mod<br/>minus</span></pre><p id="bf53" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">其中<code class="eh kn ko kp kd b">5</code>是<code class="eh kn ko kp kd b">5 + 5 = 10 * 2 = 20; 25 % 20 = 5; 10 — 5 = 5</code>的结果，并且执行了订单操作中的日志。</p><p id="953b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">至此，我们已经用最简单的方式在<strong class="ja hv"> F# </strong>中完整定义了一个<em class="jx">单子作者</em>。我们实际上可以向它添加更多的功能，但是在这个练习中让它尽可能简单。</p><p id="a72f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><em class="jx">作者</em>的整个代码看起来像这样</p><pre class="jy jz ka kb fq kc kd ke kf aw kg dt"><span id="089d" class="kh ki hu kd b fv kj kk l kl km">module MonadWriter = <br/> <br/>     type Writer&lt;'a, 'L&gt; = AWriter of 'a * List&lt;'L&gt;<br/> <br/>     let bind = function <br/>         | (v, itemLog) -&gt; AWriter(v, [itemLog])<br/> <br/>     let run = function<br/>         | AWriter(a, log) -&gt; (a, log)<br/> <br/>     let map fx = function<br/>         | AWriter(a, log) -&gt; AWriter(fx a, log)<br/> <br/>     let flatMap fx = function<br/>         | AWriter(a, log) -&gt; <br/>             let (v, new_log) = run (fx a)<br/>             AWriter(v, List.append log new_log)</span></pre><h2 id="3a49" class="kh ki hu bd kr ks kt ku kv kw kx ky kz jj la lb lc jn ld le lf jr lg lh li lj dt translated">结论</h2><p id="02db" class="pw-post-body-paragraph iy iz hu ja b jb lk jd je jf ll jh ji jj lm jl jm jn ln jp jq jr lo jt ju jv hn dt translated">Monad Writer 是一种非常优雅的方式，可以让你的函数保持纯净，同时它们有一个单一的职责，比如做像<code class="eh kn ko kp kd b">a + b</code>这样的小操作。此外，通过遵循这种模式，我们避免了在我们的代码中注入日志程序，或者更糟的是，避免了访问全局日志程序，这在多线程/并行执行环境中是非常危险的。</p><p id="759e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们大多数人在使用面向对象语言时都使用过糟糕的记录器，但是这只会在代码中产生更深的依赖性，同时破坏了单一责任原则。</p><p id="3d3d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">尤其是在分布式系统中，这是或者仅仅是转向功能性日志记录方式的决定。你可以通过阅读<a class="ae jw" href="https://hackernoon.com/how-to-log-in-apache-spark-a-functional-approach-e48ffbbd935b" rel="noopener ugc nofollow" target="_blank"> <strong class="ja hv"> <em class="jx">如何登录Apache Spark，一个函数式的方法</em> </strong> </a>来看看在Apache Spark中是怎么做的。</p><blockquote class="lp lq lr"><p id="9967" class="iy iz jx ja b jb jc jd je jf jg jh ji ls jk jl jm lt jo jp jq lu js jt ju jv hn dt translated">日志安全，功能正常。</p></blockquote></div></div>    
</body>
</html>