<html>
<head>
<title>HTMLCollection, NodeList and array of objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">html集合、节点列表和对象数组</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/htmlcollection-nodelist-and-array-of-objects-da42737181f9?source=collection_archive---------1-----------------------#2017-01-28">https://medium.com/hackernoon/htmlcollection-nodelist-and-array-of-objects-da42737181f9?source=collection_archive---------1-----------------------#2017-01-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/46bbffe47ec5d354384a990bfd9f84e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HhvoE050w6CLFIEu4cwNlA.png"/></div></div></figure><p id="e5f7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设DOM如下面的代码片段所述，我的要求是获取一个包含所有<code class="eh ka kb kc kd b">container</code> div子节点的javascript数组。</p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="a0d7" class="km kn hu kd b fv ko kp l kq kr">&lt;div id=”container”&gt;<br/> &lt;div class="divy"&gt;...&lt;/div&gt;<br/> &lt;div class="divy"&gt;...&lt;/div&gt;<br/> &lt;div class="divy"&gt;...&lt;/div&gt;<br/> &lt;div class="divy"&gt;...&lt;/div&gt;<br/>&lt;/div&gt; </span></pre><p id="25c4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在好的jQuery时代，你可以只做<code class="eh ka kb kc kd b">$('.divy')</code>或<code class="eh ka kb kc kd b">$('#container').children()</code></p><p id="e186" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我试图使用原生DOM选择器API做同样的事情，结果大吃一惊</p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="e56b" class="km kn hu kd b fv ko kp l kq kr">const childDivs = document.querySelectorAll('.divy')</span><span id="80af" class="km kn hu kd b fv ks kp l kq kr">Array.isArray(childDivs) //=&gt; false<br/>childDivs.constructor.name //=&gt; NodeList</span></pre><p id="c8e7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">好的，让我们试试<code class="eh ka kb kc kd b">getElementBy%</code>方法之一，看看返回的是什么</p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="c0c6" class="km kn hu kd b fv ko kp l kq kr">const childDivsAgain = document.getElementsByClassName('divy')</span><span id="4388" class="km kn hu kd b fv ks kp l kq kr">Array.isArray(childDivs) //=&gt; false<br/>childDivs.constructor.name //=&gt; HTMLCollection</span></pre><p id="5318" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那么什么是<code class="eh ka kb kc kd b">NodeList</code>和<code class="eh ka kb kc kd b">HTMLCollection</code>对象，为什么我们不能从这些方法中得到普通的javascript数组呢？</p><p id="9b4e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们先试着理解HTMLCollection和NodeList的区别。</p><blockquote class="kt"><p id="de44" class="ku kv hu bd kw kx ky kz la lb lc jz ek translated">HTMLCollection是节点列表。单个节点可以通过序号索引或节点的名称或id属性来访问。</p><p id="5cf0" class="ku kv hu bd kw kx ky kz la lb lc jz ek translated">HTML DOM中的集合被假定为活动的，这意味着当底层文档发生变化时，它们会自动更新。</p></blockquote><p id="c65a" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">HTML集合总是<em class="li"/>“在DOM中”，而节点列表是一个更通用的结构，可能在也可能不在DOM中。</p><blockquote class="kt"><p id="4bfa" class="ku kv hu bd kw kx ky kz la lb lc jz ek translated">NodeList对象是节点的集合。NodeList接口提供了有序节点集合的抽象，而没有定义或约束如何实现这个集合。DOM中的NodeList对象是活动的还是静态的取决于用来检索它们的接口</p></blockquote><p id="b36d" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">让我们用相关代码来测试规范，以了解更多信息</p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="daa7" class="km kn hu kd b fv ko kp l kq kr">let parentDiv = document.getElementById('container')</span><span id="ea78" class="km kn hu kd b fv ks kp l kq kr">let nodeListDivs = document.querySelectorAll('.divy')<br/>let htmlCollectionDivs = document.getElementsByClassName('divy')</span><span id="9dde" class="km kn hu kd b fv ks kp l kq kr">nodeListDivs.length //=&gt; 4<br/>htmlCollectionDivs.length //=&gt; 4</span><span id="4b05" class="km kn hu kd b fv ks kp l kq kr">//append new child to container<br/>var newDiv = document.createElement('div');<br/>newDiv.className = 'divy'<br/>parentDiv.appendChild(newDiv)</span><span id="ac1d" class="km kn hu kd b fv ks kp l kq kr">nodeListDivs.length //=&gt; 4<br/>htmlCollectionDivs.length //=&gt; 5</span></pre><p id="ce7f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以看到HTMLCollection实际上是活动的，在这种意义上，对DOM的任何更改都会自动更新并在集合中可用。</p><p id="3058" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">并非所有的NodeList对象都是静态的。例如，<code class="eh ka kb kc kd b">document.getElementByName</code>将返回一个活动节点列表。</p><p id="f6b5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是记住<code class="eh ka kb kc kd b">HTMLCollection</code>和<code class="eh ka kb kc kd b">NodeList</code>都不支持像<code class="eh ka kb kc kd b">push</code> <code class="eh ka kb kc kd b">pop</code>或<code class="eh ka kb kc kd b">splice</code>这样的数组原型方法。像<code class="eh ka kb kc kd b">forEach</code>这样的迭代器方法是最近才加入的，最新的浏览器可能会支持它们。</p><p id="cc44" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我试图使用<a class="ae lj" href="https://github.com/bevacqua/react-dragula" rel="noopener ugc nofollow" target="_blank"> dragula drag-n-drop </a>库将选定的组件添加到库中时，我开始了解到这个区别</p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="523b" class="km kn hu kd b fv ko kp l kq kr">let draggableLists = document.querySelectorAll('div.draggable')<br/>dragula(draggableLists); //will not work</span></pre><p id="1eb8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这不会像预期的那样工作，因为<code class="eh ka kb kc kd b">dragula()</code>构造函数需要一个javascript数组，而我们正在向它传递一个NodeList。</p><p id="42a9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要将NodeList或HTMLCollection对象转换为javascript数组，可以执行下列操作之一:</p><h2 id="e13b" class="km kn hu bd lk ll lm ln lo lp lq lr ls jn lt lu lv jr lw lx ly jv lz ma mb mc dt translated">使用Array.from方法</h2><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="4190" class="km kn hu kd b fv ko kp l kq kr">const nodelist = document.querySelectorAll(‘.divy’)<br/>const divyArray = Array.from(nodelist)</span></pre><h2 id="4322" class="km kn hu bd lk ll lm ln lo lp lq lr ls jn lt lu lv jr lw lx ly jv lz ma mb mc dt translated">使用Array.prototype.slice</h2><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="a680" class="km kn hu kd b fv ko kp l kq kr">const nodelist = document.querySelectorAll(‘.divy’)<br/>const divyArray = Array.prototype.slice.call(nodelist)</span></pre><h2 id="2c07" class="km kn hu bd lk ll lm ln lo lp lq lr ls jn lt lu lv jr lw lx ly jv lz ma mb mc dt translated">ES6方式</h2><p id="2850" class="pw-post-body-paragraph jc jd hu je b jf md jh ji jj me jl jm jn mf jp jq jr mg jt ju jv mh jx jy jz hn dt translated">我喜欢这个。如果您使用ES6，您可以只使用扩展操作符</p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="0712" class="km kn hu kd b fv ko kp l kq kr">const divyArray = […document.querySelectorAll(‘.divy’)]</span></pre><p id="4850" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，让我们把它应用到dragula api中，让它工作起来</p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="dfd2" class="km kn hu kd b fv ko kp l kq kr">dragula([...document.querySelectorAll('div.draggable')])</span></pre><p id="b0a1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那么什么时候真正把NodeList转换成数组呢？这取决于你的用例。如果你真的想要一个迭代器一直指向最新更新的DOM，你应该直接使用<code class="eh ka kb kc kd b">NodeList</code>或者<code class="eh ka kb kc kd b">HTMLCollection</code>而不要把它转换成数组。</p><p id="ad30" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="li">如果你喜欢这篇文章，请关注我的</em> <a class="ae lj" href="https://twitter.com/rcdexta" rel="noopener ugc nofollow" target="_blank"> <em class="li">推特</em> </a> <em class="li">获取更多更新..</em></p><div class="ke kf kg kh fq ab cb"><figure class="mi iv mj mk ml mm mn paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mi iv mj mk ml mm mn paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mi iv mj mk ml mm mn paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mo mp mq"><p id="f922" class="jc jd li je b jf jg jh ji jj jk jl jm mr jo jp jq ms js jt ju mt jw jx jy jz hn dt translated"><a class="ae lj" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是阿妹家庭的一员。我们现在<a class="ae lj" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae lj" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd li je b jf jg jh ji jj jk jl jm mr jo jp jq ms js jt ju mt jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lj" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lj" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ke kf kg kh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mu"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="ke kf kg kh fq iv"><div class="bz el l di"><div class="mv mw l"/></div></figure></div></div>    
</body>
</html>