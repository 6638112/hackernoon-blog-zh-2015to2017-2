<html>
<head>
<title>Automatically Running PHPUnit With Watchman</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Watchman自动运行PHPUnit</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/automatically-running-phpunit-with-watchman-e02757e733e7?source=collection_archive---------9-----------------------#2017-04-12">https://medium.com/hackernoon/automatically-running-phpunit-with-watchman-e02757e733e7?source=collection_archive---------9-----------------------#2017-04-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="b15c" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">一个小的bash脚本，用于在文件被更改时运行测试</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/d46afc8cbeedc7ba10bb95b5973851b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*P6G0iLp_UhsygFqMpmNfpg.gif"/></div></div></figure></div><div class="ab cl jv jw hc jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hn ho hp hq hr"><p id="141d" class="pw-post-body-paragraph kc kd hu ke b kf kg iv kh ki kj iy kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">如果你只是想要一个<em class="ky"> tl:dr </em>，这里有一个脚本，你可以把它放入你正在使用的任何<code class="eh kz la lb lc b">.bashrc</code>文件中——解释如下。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ld le l"/></div></figure><p id="915e" class="pw-post-body-paragraph kc kd hu ke b kf kg iv kh ki kj iy kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated"><code class="eh kz la lb lc b">pw</code>函数通过调用<code class="eh kz la lb lc b">phpunit tests</code>运行一次测试，监视<code class="eh kz la lb lc b">src</code>和<code class="eh kz la lb lc b">tests</code>中的每个<a class="ae lf" href="https://hackernoon.com/tagged/php" rel="noopener ugc nofollow" target="_blank"> php </a>文件，并在被监视的文件发生变化时再次运行测试。</p><p id="a91c" class="pw-post-body-paragraph kc kd hu ke b kf kg iv kh ki kj iy kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">您可以在<code class="eh kz la lb lc b">pw</code>后指定任何<a class="ae lf" href="https://hackernoon.com/tagged/phpunit" rel="noopener ugc nofollow" target="_blank"> PHPUnit </a>参数，例如<code class="eh kz la lb lc b">pw ./tests/Unit/FooTest.php</code>或<code class="eh kz la lb lc b">pw --filter test_true_is_true</code>。</p><p id="2eeb" class="pw-post-body-paragraph kc kd hu ke b kf kg iv kh ki kj iy kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">这个脚本使用了脸书的<a class="ae lf" href="https://facebook.github.io/watchman/" rel="noopener ugc nofollow" target="_blank"> Watchman </a>库，在OSX，可以通过<a class="ae lf" href="https://brew.sh/" rel="noopener ugc nofollow" target="_blank">自制软件</a>安装。</p><pre class="jk jl jm jn fq lg lc lh li aw lj dt"><span id="64bd" class="lk ll hu lc b fv lm ln l lo lp">brew install watchman</span></pre><p id="f078" class="pw-post-body-paragraph kc kd hu ke b kf kg iv kh ki kj iy kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">Watchman监视文件，并在文件发生变化时触发操作。选择Watchman的理由是:它易于安装，配置简单，并且可靠。</p><p id="5d35" class="pw-post-body-paragraph kc kd hu ke b kf kg iv kh ki kj iy kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">Watchman附带的<code class="eh kz la lb lc b">watchman-make</code>命令是Watchman调用构建工具来响应文件更改的专用接口，这正是我们所需要的！</p><p id="134d" class="pw-post-body-paragraph kc kd hu ke b kf kg iv kh ki kj iy kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">让我们一行一行地回顾一下我们的手表功能。</p><pre class="jk jl jm jn fq lg lc lh li aw lj dt"><span id="e25c" class="lk ll hu lc b fv lm ln l lo lp">function pw { }</span></pre><p id="df51" class="pw-post-body-paragraph kc kd hu ke b kf kg iv kh ki kj iy kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">函数名决定命令名。我喜欢简短的命令——PHPUnit在我的机器上别名为<code class="eh kz la lb lc b">p</code>——所以一个缩写版本的<code class="eh kz la lb lc b">phpunit-watch</code>似乎很合适。</p><pre class="jk jl jm jn fq lg lc lh li aw lj dt"><span id="239d" class="lk ll hu lc b fv lm ln l lo lp">run="clear &amp;&amp; printf '\e[3J' &amp;&amp; vendor/bin/phpunit"</span></pre><p id="eefb" class="pw-post-body-paragraph kc kd hu ke b kf kg iv kh ki kj iy kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">因为我们将需要实际的“运行”命令两次，所以让我们将它存储在一个变量中。为了进一步分解它，<code class="eh kz la lb lc b">clear &amp;&amp; printf ‘\e[3J’</code>清除终端(以防止之前的测试运行扰乱它)，然后<code class="eh kz la lb lc b">vendor/bin/phpunit</code>运行测试。</p><pre class="jk jl jm jn fq lg lc lh li aw lj dt"><span id="1fb3" class="lk ll hu lc b fv lm ln l lo lp">[[ -n $@ ]] &amp;&amp; args=$@ || args="tests"</span></pre><p id="193e" class="pw-post-body-paragraph kc kd hu ke b kf kg iv kh ki kj iy kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated"><code class="eh kz la lb lc b">watchman-make</code> <strong class="ke hv">需要</strong>参数才能工作。(我很想在这里被证明是错的，这样我就可以清理这个部分了！)我们将默认tests的参数，这意味着我们将运行的实际命令是<code class="eh kz la lb lc b">vendor/bin/phpunit tests</code>。如果我们给<code class="eh kz la lb lc b">pw</code>提供任何参数，它们将替换<code class="eh kz la lb lc b">test</code>，例如<code class="eh kz la lb lc b">pw —-stop-on-failure</code>将运行<code class="eh kz la lb lc b">vendor/bin/phpunit —-stop-on-failure</code>。</p><p id="a60d" class="pw-post-body-paragraph kc kd hu ke b kf kg iv kh ki kj iy kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">接下来的两个命令将所有内容集合在一起。</p><pre class="jk jl jm jn fq lg lc lh li aw lj dt"><span id="242c" class="lk ll hu lc b fv lm ln l lo lp">eval "$run $args"</span></pre><p id="65b7" class="pw-post-body-paragraph kc kd hu ke b kf kg iv kh ki kj iy kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">观看前手动触发一次命令。这样我们可以立即看到测试结果，而不必先改变文件。</p><pre class="jk jl jm jn fq lg lc lh li aw lj dt"><span id="3170" class="lk ll hu lc b fv lm ln l lo lp">watchman-make \<br/>    -p 'src/**/*.php' 'tests/**/*.php' \<br/>    --make=$run \<br/>    -t "$args"</span></pre><p id="3de0" class="pw-post-body-paragraph kc kd hu ke b kf kg iv kh ki kj iy kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">最后，守夜人的时间到了！<code class="eh kz la lb lc b">-p</code>参数指定了我们想要监视的文件夹。我个人建立了更多像<code class="eh kz la lb lc b">app/**/*.php</code>和<code class="eh kz la lb lc b">database/**/*.php</code>这样的globs，因为我主要是和Laravel一起工作。<code class="eh kz la lb lc b">--make</code>指定我们将在变更时运行哪个命令，<code class="eh kz la lb lc b">-t</code>将传递额外的参数给<code class="eh kz la lb lc b">--make</code>命令(记住，我们默认的变量是<code class="eh kz la lb lc b">tests</code>)。</p><p id="c84d" class="pw-post-body-paragraph kc kd hu ke b kf kg iv kh ki kj iy kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">我仍然梦想着为PHPUnit开发一个类似于<a class="ae lf" href="https://facebook.github.io/jest/" rel="noopener ugc nofollow" target="_blank"> Jest </a>的CLI工具，它还允许您过滤和重新运行特定的测试，而无需中断监视功能，但是能够在变化时运行测试已经是一个巨大的工作流程提升。</p><p id="1665" class="pw-post-body-paragraph kc kd hu ke b kf kg iv kh ki kj iy kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">总结一下，下面是完整的<code class="eh kz la lb lc b">pw</code>函数:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ld le l"/></div></figure></div><div class="ab cl jv jw hc jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hn ho hp hq hr"><p id="8b15" class="pw-post-body-paragraph kc kd hu ke b kf kg iv kh ki kj iy kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated"><em class="ky">这篇文章基于乔纳森·纳普的</em> <a class="ae lf" href="http://blog.coffeeandcode.com/running-tests-automatically-with-watchman/" rel="noopener ugc nofollow" target="_blank"> <em class="ky">一篇咖啡和代码文章</em> </a> <em class="ky">。</em></p><div class="jk jl jm jn fq ab cb"><figure class="lq jo lr ls lt lu lv paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="lq jo lr ls lt lu lv paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="lq jo lr ls lt lu lv paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="lw lx ly"><p id="f922" class="kc kd ky ke b kf kg iv kh ki kj iy kk lz km kn ko ma kq kr ks mb ku kv kw kx hn dt translated"><a class="ae lf" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是T21家庭的一员。我们现在<a class="ae lf" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae lf" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="kc kd ky ke b kf kg iv kh ki kj iy kk lz km kn ko ma kq kr ks mb ku kv kw kx hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lf" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lf" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mc"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="md le l"/></div></figure></div></div>    
</body>
</html>