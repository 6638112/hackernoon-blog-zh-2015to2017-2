<html>
<head>
<title>JS: Let’s try the future today (extra bonus)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们今天试试未来(额外奖励)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/js-lets-try-the-future-today-extra-bonus-43e9e1a8480a?source=collection_archive---------23-----------------------#2017-10-21">https://medium.com/hackernoon/js-lets-try-the-future-today-extra-bonus-43e9e1a8480a?source=collection_archive---------23-----------------------#2017-10-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/d7e4772f0b4a5ece9d9ec71e70d64131.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x4_wH2ZGei2YbqmNpv7oHg.jpeg"/></div></div></figure><p id="0e63" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在之前的一篇文章 中，我展示了一种实现基本而简单的应用程序的方法，没有第三方依赖或构建工具，只使用所有新的好东西和最新的浏览器已经实现的东西。</p><p id="fe65" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有一个额外的功能，我们可以毫不费力地添加到应用程序中，但目前它只在Safari中工作，因为它是唯一一个实现了<a class="ae ka" href="https://github.com/tc39/proposal-dynamic-import" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">动态导入</strong> </a> API的浏览器。</p><p id="d752" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有了这个API，我们可以推迟部分应用程序代码的加载，这样浏览器就不会提前下载了。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><p id="ae2d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我现在想要实现的是应用程序在页面加载时只下载核心代码和当前视图代码的能力，因此，如果我们加载<em class="ki"> home </em>视图(带有播客列表的视图)，浏览器不会提取播客详细视图或剧集详细视图的代码。</p><p id="f287" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，我们只需在应用程序中更改两个文件就可以实现这个新特性。</p><p id="032e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">(<em class="ki">记得哟这里可以看到应用</em><a class="ae ka" href="https://github.com/PaquitoSoft/podcaster-vanilla-components" rel="noopener ugc nofollow" target="_blank"><strong class="je hv"><em class="ki"/></strong></a><strong class="je hv"><em class="ki">的完整代码。</em> </strong> <em class="ki">资源库中有一个分支叫做</em><strong class="je hv"><em class="ki">async-routing</em></strong><em class="ki">用这个特性实现了</em>。</p><p id="b92e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">策略是在路由器导航功能中添加一个新步骤，以便在呈现新页面之前，获取需要呈现的页面级组件。</p><p id="82e8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我首先需要更改路由配置文件，这样它就不会直接导入页面级组件。相反，我只是设置了组件的相对路径(在本例中，相对于<strong class="je hv">组件</strong>文件夹):</p><figure class="kk kl km kn fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kj"><img src="../Images/fa083e6eb4bcd224f0a94f548ad6f95a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Khr9PZAK9mPRMhmSGWE4PA.png"/></div></div><figcaption class="ko kp fg fe ff kq kr bd b be z ek">Changes to routing configuration file</figcaption></figure><p id="2449" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我必须更改的另一件事是路由器组件，以便它在尝试导航之前获取相应的文件。<br/>这里是这个文件的<em class="ki">差异</em>:</p><figure class="kk kl km kn fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kj"><img src="../Images/2c86a903e0dbfd2e07adf4f56a51c596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lf7QCj_GVz9fgsKnAFViTw.png"/></div></div><figcaption class="ko kp fg fe ff kq kr bd b be z ek">Changes to router component file</figcaption></figure><p id="f04f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以，重要的一行是带有<strong class="je hv">导入</strong>调用的那一行。这将告诉浏览器获取我们在路由配置中配置的文件(它只会做一次)。<br/>导入函数返回一个<a class="ae ka" href="http://devdocs.io/javascript/global_objects/promise" rel="noopener ugc nofollow" target="_blank">承诺</a>，当浏览器加载了所需的模块文件(及其所有依赖项)时，该承诺被解析。</p><p id="e037" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">而且，就是这样。<br/>再多几行代码，我们就已经在应用程序中实现了<strong class="je hv">代码分割</strong>。</p><p id="795f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请记住，目前只有Safari支持动态导入(Chrome将在其下一个版本v63中支持)。更多状态信息:<a class="ae ka" href="https://www.chromestatus.com/features/5684934484164608" rel="noopener ugc nofollow" target="_blank">https://www.chromestatus.com/features/5684934484164608</a></p></div></div>    
</body>
</html>