<html>
<head>
<title>Replacing the angular 1 router with Elm — Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Elm替换angular 1路由器—第3部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/replacing-the-angular-1-router-with-elm-part-3-d56e40bf251?source=collection_archive---------14-----------------------#2017-01-12">https://medium.com/hackernoon/replacing-the-angular-1-router-with-elm-part-3-d56e40bf251?source=collection_archive---------14-----------------------#2017-01-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="a823" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是系列文章的第三部分。你也应该读读<a class="ae jp" rel="noopener" href="/@julianjelfs_61852/replacing-the-angular-1-router-with-elm-d71753e74e32#.q661pucta">第一部分</a>和<a class="ae jp" rel="noopener" href="/@julianjelfs_61852/replacing-the-angular-1-router-with-elm-part-2-bf9c84934abf#.kdib3ce9i">第二部分</a>。</p><p id="031a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">总的来说，我们有一个看起来可行的解决方案，但是我们有两个竞争的运行时试图控制我们的位置，这导致了两个严重的问题。首先，当<em class="jq"> angular </em>触发导航时，我们在历史队列中有两个条目，打乱了后退按钮。第二，当<em class="jq"> Elm </em>触发导航时，angular的$location服务会失去对我们所在页面的跟踪，所以如果你的angular代码调用类似$location.path()的东西，它可能会得到错误的答案。我想要一个解决方案，不打破我的角度代码，所以这是不行的。</p><p id="ffee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是它变得有点(好吧，很多)古怪的地方:(让我们一个一个地考虑这些问题。当angular通过调用$location service方法或单击angular组件中的锚标记来触发导航时，它将更新浏览器url和调用history.pushState(以及其他内容)。我们的问题是，然后我们监听$locationChange事件，并指示Elm更改路由，这将触发另一个对history.pushState的调用。</p><p id="49ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以其中一个电话必须被阻止。我最初的直觉是防止angular插入pushState。但是如果我们这样做，angular就会陷入一个无限的摘要循环，因为它会不断地尝试解决$browser告诉它的内容和$location告诉它的内容之间的差异。因此，最好让angular去做它的事情，毕竟angular在这个导航中运行着。在这种情况下，我们必须防止Elm随后添加第二个条目。</p><p id="ef31" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以通过订阅$ locationChangeSuccess而不是$locationChangeStart来做到这一点。当success事件触发时，我们知道angular已经添加了它的历史条目，并且我们知道Elm将触发下一个条目。因此，在这一点上，我们设置了一个标志来指示应该忽略对pushState的下一个<em class="jq">调用。</em></p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="48fe" class="ka kb hu jw b fv kc kd l ke kf">$rootScope.$on('$locationChangeSuccess', function(e, newUrl, oldUrl){<br/>    if(!listenForRouteChanges) {<br/>        return;<br/>    }<br/>    app.ports.newUrl.send(newUrl);<br/>    <strong class="jw hv">//at this point angular will have added a history state<br/>    //already so we should ignore the next one<br/>    ignoreNextPushState = true;</strong><br/>});</span></pre><p id="0f3a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了实际丢弃对pushState的下一个调用，我们必须如下截取/修饰历史api:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="04c9" class="ka kb hu jw b fv kc kd l ke kf">var ps = window.history.pushState;<br/>window.history.pushState = function() {<br/>    <strong class="jw hv">if(ignoreNextPushState) {<br/>        ignoreNextPushState = false;<br/>        return;<br/>    }</strong><br/>    ps.apply(window.history, arguments);<br/>}</span></pre><p id="4b61" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我警告过你这是hacky！但是它解决了我们的第一个新问题。但是我们仍然面临第二个问题，即当Elm启动导航时，angular会失去对位置的跟踪。恐怕要解决这个问题需要更多的黑客。</p><p id="3290" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们的突变观察器告诉我们需要编译根节点时，我们知道我们正处于Elm发起的路由更改中，因此angular的$location服务将被置于不同步状态。为了避免这种情况，我发现我们可以使用一个私有的angular api来使它与真实的url同步，就像这样:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="aea2" class="ka kb hu jw b fv kc kd l ke kf">$location.$$parseLinkUrl(window.location.href);</span></pre><p id="2429" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">很明显，我对此感觉不太好，事情变得比最初看起来要复杂一些。但是它工作了，重要的是我没有在Elm代码或现有的angular代码中做任何奇怪的事情。黑客是自我包含在一个地方，当时间到了，它可以简单地被删除。</p><h1 id="a1e0" class="kg kb hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">但是有一个严重的问题！</h1><p id="895f" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">我们允许Elm从DOM中删除代表角度分量的元素。这意味着angular没有做任何正常的清理工作，这意味着内存泄漏！在第四部中，我会看看我们是否能处理好这个问题。</p><p id="7a1b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">和以前一样，这个概念证明的完整来源可以在<a class="ae jp" href="https://github.com/travelrepublic/elm-angular-router" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div></div>    
</body>
</html>