<html>
<head>
<title>Getting to Grips with ES6: Variables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握ES6:变量</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/getting-to-grips-with-es6-variables-f27b72798bf3?source=collection_archive---------2-----------------------#2016-11-01">https://medium.com/hackernoon/getting-to-grips-with-es6-variables-f27b72798bf3?source=collection_archive---------2-----------------------#2016-11-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/79ee1ea95cb0b783f134895fe4a11d8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lXLRO_GTTNzbr3N5TTJFxg.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="f689" class="pw-subtitle-paragraph jc ie if bd b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ek translated">第一部分:理解var，let，const和scope</h2></div><p id="9195" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated"><a class="ae kq" rel="noopener" href="/@andrewjrhill/getting-to-grips-with-es6-arrow-functions-ebfa62c5c5d6#.3x4gbza5l"> <em class="kr">点击此处查看第二部分:了解胖箭头功能</em> </a></p><h2 id="d2b8" class="ks kt if bd ku kv kw kx ky kz la lb lc kd ld le lf kh lg lh li kl lj lk ll lm dt translated"><strong class="ak">前言</strong></h2><p id="1af0" class="pw-post-body-paragraph ju jv if jw b jx ln jg jz ka lo jj kc kd lp kf kg kh lq kj kk kl lr kn ko kp hn dt translated">这篇文章是为希望更好地理解<a class="ae kq" href="https://hackernoon.com/tagged/es6" rel="noopener ugc nofollow" target="_blank"> ES6 </a>变量的初级到中级开发人员设计的“入门”读物。</p><p id="9483" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">作为我的“掌握ES6”系列的一部分，我的目标是创建一个参考，其中包含简单明了的解释，以帮助我们理解这些概念，并将它们直接应用到我们当前的开发过程中。</p><p id="8958" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">作者:安德鲁·希尔。<br/>你可以在<a class="ae kq" href="http://www.linkedin.com/in/andrewjrhill" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>、<a class="ae kq" href="https://twitter.com/andrewjrhill" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae kq" href="https://www.instagram.com/andrewshills/" rel="noopener ugc nofollow" target="_blank"> Instagram </a>和<a class="ae kq" href="https://github.com/Sntax/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到我。</p></div><div class="ab cl ls lt hc lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hn ho hp hq hr"><h1 id="4ebc" class="lz kt if bd ku ma mb mc ky md me mf lc jl mg jm lf jo mh jp li jr mi js ll mj dt translated">“var”语句</h1><p id="2716" class="pw-post-body-paragraph ju jv if jw b jx ln jg jz ka lo jj kc kd lp kf kg kh lq kj kk kl lr kn ko kp hn dt translated">虽然<code class="eh mk ml mm mn b">var</code>语句对ES6来说并不陌生，但我强烈建议通读这篇复习资料，以帮助我们更好地理解<code class="eh mk ml mm mn b">const</code>和<code class="eh mk ml mm mn b">let</code>语句引入的概念。</p><p id="9189" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">在其核心，<code class="eh mk ml mm mn b">var</code>语句允许我们定义、更新和重定义变量。用<code class="eh mk ml mm mn b">var</code>声明的变量被认为是<em class="kr">函数作用域。</em></p><h2 id="20a5" class="ks kt if bd ku kv kw kx ky kz la lb lc kd ld le lf kh lg lh li kl lj lk ll lm dt translated"><strong class="ak">定义并更新</strong></h2><p id="4102" class="pw-post-body-paragraph ju jv if jw b jx ln jg jz ka lo jj kc kd lp kf kg kh lq kj kk kl lr kn ko kp hn dt translated">我们可以定义和更新用<code class="eh mk ml mm mn b">var</code>声明的变量，而不会有任何错误。</p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="51b2" class="ks kt if mn b fv mw mx l my mz">var test = 100;</span><span id="b778" class="ks kt if mn b fv na mx l my mz">console.log(test);<br/>// Output: 100</span><span id="7773" class="ks kt if mn b fv na mx l my mz">test = 200;</span><span id="8f29" class="ks kt if mn b fv na mx l my mz">console.log(test);<br/>// Output: 200</span></pre><h2 id="a1f9" class="ks kt if bd ku kv kw kx ky kz la lb lc kd ld le lf kh lg lh li kl lj lk ll lm dt translated"><strong class="ak">重定义(允许)</strong></h2><p id="5094" class="pw-post-body-paragraph ju jv if jw b jx ln jg jz ka lo jj kc kd lp kf kg kh lq kj kk kl lr kn ko kp hn dt translated">我们还可以定义一个同名的全新变量来覆盖之前的变量，而不会出错。</p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="4146" class="ks kt if mn b fv mw mx l my mz">var test = 100;</span><span id="0709" class="ks kt if mn b fv na mx l my mz">console.log(test);<br/>// Output: 100</span><span id="8c0f" class="ks kt if mn b fv na mx l my mz">var test = 200;</span><span id="6869" class="ks kt if mn b fv na mx l my mz">console.log(test);<br/>// Output: 200</span></pre><h2 id="a197" class="ks kt if bd ku kv kw kx ky kz la lb lc kd ld le lf kh lg lh li kl lj lk ll lm dt translated"><strong class="ak">范围</strong></h2><p id="0408" class="pw-post-body-paragraph ju jv if jw b jx ln jg jz ka lo jj kc kd lp kf kg kh lq kj kk kl lr kn ko kp hn dt translated">使用<code class="eh mk ml mm mn b">var</code>定义的变量范围如下:</p><ul class=""><li id="63e3" class="nb nc if jw b jx jy ka kb kd nd kh ne kl nf kp ng nh ni nj dt translated"><em class="kr">函数作用域</em>如果它们被定义在一个函数内，使得它们只能在定义它们的函数内被访问。</li><li id="5c6b" class="nb nc if jw b jx nk ka nl kd nm kh nn kl no kp ng nh ni nj dt translated"><em class="kr">全局作用域</em>如果它们没有被定义在一个函数中，使得它们在任何地方都可以被访问。</li></ul><p id="dc14" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">考虑下面的例子:</p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="3b6d" class="ks kt if mn b fv mw mx l my mz">function scopeTest() {<br/>  var test = 100;<br/>  console.log(test);<br/>}</span><span id="7e69" class="ks kt if mn b fv na mx l my mz">scopeTest();<br/>// Output: 100</span></pre><p id="08c5" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated"><code class="eh mk ml mm mn b">test</code>变量被认为是一个局部变量，函数作用于<code class="eh mk ml mm mn b">scopeTest()</code>函数。我们能够访问存储在变量<code class="eh mk ml mm mn b">test</code>中的值，因为变量声明和<code class="eh mk ml mm mn b">console.log()</code>存在于同一个<code class="eh mk ml mm mn b">scopeTest()</code>函数中。</p><p id="93dc" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">使用此示例的修改版本，我们可以说明此变量在它所作用的函数之外是如何不可访问的:</p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="0dbb" class="ks kt if mn b fv mw mx l my mz">function scopeTest() {<br/>  var test = 100;<br/>}</span><span id="66ef" class="ks kt if mn b fv na mx l my mz">scopeTest();</span><span id="fce3" class="ks kt if mn b fv na mx l my mz">console.log(test);<br/>// Output: [Error] 'test' is not defined.</span></pre><p id="06c5" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">我们还可以在更高的范围内更新变量，以获取函数外部的值。由于超出本文<em class="kr">范围</em>的原因，这通常被认为是不好的做法，除非绝对必要，否则应该避免。</p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="9b43" class="ks kt if mn b fv mw mx l my mz">var test;</span><span id="bcbb" class="ks kt if mn b fv na mx l my mz">function scopeTest() {<br/>  test = 100;<br/>}</span><span id="0485" class="ks kt if mn b fv na mx l my mz">scopeTest();</span><span id="d9e7" class="ks kt if mn b fv na mx l my mz">console.log(test);<br/>// Output: 100</span></pre><h2 id="ca35" class="ks kt if bd ku kv kw kx ky kz la lb lc kd ld le lf kh lg lh li kl lj lk ll lm dt translated"><strong class="ak">var的“坏”侧</strong></h2><p id="17fc" class="pw-post-body-paragraph ju jv if jw b jx ln jg jz ka lo jj kc kd lp kf kg kh lq kj kk kl lr kn ko kp hn dt translated">那么为什么要在ES6中引入新的<code class="eh mk ml mm mn b">const</code>和<code class="eh mk ml mm mn b">let</code>语句呢？<em class="kr">因为任何使用</em> <code class="eh mk ml mm mn b"><em class="kr">var</em></code> <em class="kr">在函数外部定义的变量都是全局范围的。</em></p><p id="8b13" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">全球范围界定是<strong class="jw ig">不好的</strong>，因为它介绍了:</p><ul class=""><li id="fea0" class="nb nc if jw b jx jy ka kb kd nd kh ne kl nf kp ng nh ni nj dt translated"><em class="kr">命名冲突</em>——当你或你的团队无法跟踪变量名时，变量会被无意中重新定义，从而被覆盖。</li><li id="34e8" class="nb nc if jw b jx nk ka nl kd nm kh nn kl no kp ng nh ni nj dt translated"><em class="kr">安全性减弱</em>——特别是在网络上，每个用户天生就可以访问全球范围。对此的访问允许用户查看和修改您的变量。</li><li id="7ea0" class="nb nc if jw b jx nk ka nl kd nm kh nn kl no kp ng nh ni nj dt translated"><em class="kr">性能差</em>——尽管可以忽略不计，但是如果在当前被调用的地方找不到变量，JavaScript 引擎会在更高的范围内寻找变量。如果您的变量都是全局范围的，引擎将始终需要找到全局窗口对象，以便找到它正在寻找的值。</li></ul></div><div class="ab cl ls lt hc lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hn ho hp hq hr"><h1 id="afc1" class="lz kt if bd ku ma mb mc ky md me mf lc jl mg jm lf jo mh jp li jr mi js ll mj dt translated">“let”语句</h1><p id="741f" class="pw-post-body-paragraph ju jv if jw b jx ln jg jz ka lo jj kc kd lp kf kg kh lq kj kk kl lr kn ko kp hn dt translated"><code class="eh mk ml mm mn b">let</code>语句允许我们像<code class="eh mk ml mm mn b">var</code>语句一样定义和更新变量，但是它不允许我们重新定义已经在相同范围内定义的变量。用<code class="eh mk ml mm mn b">let</code>定义的变量也被认为是<em class="kr">块范围的。</em></p><h2 id="40f4" class="ks kt if bd ku kv kw kx ky kz la lb lc kd ld le lf kh lg lh li kl lj lk ll lm dt translated"><strong class="ak">定义并更新</strong></h2><p id="b94c" class="pw-post-body-paragraph ju jv if jw b jx ln jg jz ka lo jj kc kd lp kf kg kh lq kj kk kl lr kn ko kp hn dt translated">我们可以定义和更新用<code class="eh mk ml mm mn b">let</code>声明的变量，而不会有任何错误。</p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="1ce0" class="ks kt if mn b fv mw mx l my mz">let test = 100;</span><span id="8c2c" class="ks kt if mn b fv na mx l my mz">console.log(test);<br/>// Output: 100</span><span id="67b7" class="ks kt if mn b fv na mx l my mz">test = 200;</span><span id="d34d" class="ks kt if mn b fv na mx l my mz">console.log(test);<br/>// Output: 200</span></pre><h2 id="7707" class="ks kt if bd ku kv kw kx ky kz la lb lc kd ld le lf kh lg lh li kl lj lk ll lm dt translated"><strong class="ak">重定义(不允许)</strong></h2><p id="6c1e" class="pw-post-body-paragraph ju jv if jw b jx ln jg jz ka lo jj kc kd lp kf kg kh lq kj kk kl lr kn ko kp hn dt translated">禁止尝试定义一个与我们之前定义的<code class="eh mk ml mm mn b">let</code>变量同名的新变量，这会导致错误。</p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="2795" class="ks kt if mn b fv mw mx l my mz">let test = 100;</span><span id="e4d4" class="ks kt if mn b fv na mx l my mz">console.log(test);<br/>// Output: 100</span><span id="e3eb" class="ks kt if mn b fv na mx l my mz">let test = 200;<br/>// Output: [Error] Identifier 'test' has already been declared.</span><span id="7222" class="ks kt if mn b fv na mx l my mz">console.log(test);<br/>// Output: 100</span></pre></div><div class="ab cl ls lt hc lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hn ho hp hq hr"><h1 id="c999" class="lz kt if bd ku ma mb mc ky md me mf lc jl mg jm lf jo mh jp li jr mi js ll mj dt translated">“常量”语句</h1><p id="019c" class="pw-post-body-paragraph ju jv if jw b jx ln jg jz ka lo jj kc kd lp kf kg kh lq kj kk kl lr kn ko kp hn dt translated"><code class="eh mk ml mm mn b">const</code>语句只允许我们定义变量。与被更新的<code class="eh mk ml mm mn b">let</code>不同，<code class="eh mk ml mm mn b">const</code>完全禁止更新变量。此外，像<code class="eh mk ml mm mn b">let</code>，<code class="eh mk ml mm mn b">const</code>一样，禁止重新定义已经在同一个作用域中定义的变量。用<code class="eh mk ml mm mn b">const</code>定义的变量被认为是<em class="kr">块范围的。</em></p><h2 id="b5b9" class="ks kt if bd ku kv kw kx ky kz la lb lc kd ld le lf kh lg lh li kl lj lk ll lm dt translated"><strong class="ak">定义(允许)和更新(不允许)</strong></h2><p id="bcb2" class="pw-post-body-paragraph ju jv if jw b jx ln jg jz ka lo jj kc kd lp kf kg kh lq kj kk kl lr kn ko kp hn dt translated">我们可以定义<code class="eh mk ml mm mn b">const</code>变量，但禁止更新分配给变量的值。试图更新常量变量将导致错误。</p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="ad68" class="ks kt if mn b fv mw mx l my mz">const test = 100;</span><span id="a003" class="ks kt if mn b fv na mx l my mz">console.log(test);<br/>// Output: 100</span><span id="066c" class="ks kt if mn b fv na mx l my mz">test = 200;<br/>// Output: [Error] Assignment to constant variable.</span><span id="4cb2" class="ks kt if mn b fv na mx l my mz">console.log(test);<br/>// Output: 100</span></pre><h2 id="6191" class="ks kt if bd ku kv kw kx ky kz la lb lc kd ld le lf kh lg lh li kl lj lk ll lm dt translated"><strong class="ak">重定义(不允许)</strong></h2><p id="6040" class="pw-post-body-paragraph ju jv if jw b jx ln jg jz ka lo jj kc kd lp kf kg kh lq kj kk kl lr kn ko kp hn dt translated">试图定义一个与我们之前定义的<code class="eh mk ml mm mn b">const</code>变量同名的新变量是被禁止的，这会导致错误。</p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="1496" class="ks kt if mn b fv mw mx l my mz">const test = 100;</span><span id="4ae6" class="ks kt if mn b fv na mx l my mz">console.log(test);<br/>// Output: 100</span><span id="b41f" class="ks kt if mn b fv na mx l my mz">const test = 200;<br/>// Output: [Error] Identifier 'test' has already been declared.</span><span id="e78a" class="ks kt if mn b fv na mx l my mz">console.log(test);<br/>// Output: 100</span></pre><h2 id="9aa7" class="ks kt if bd ku kv kw kx ky kz la lb lc kd ld le lf kh lg lh li kl lj lk ll lm dt translated"><strong class="ak">可变性</strong></h2><p id="9c1a" class="pw-post-body-paragraph ju jv if jw b jx ln jg jz ka lo jj kc kd lp kf kg kh lq kj kk kl lr kn ko kp hn dt translated">有一种越来越多的误解认为<code class="eh mk ml mm mn b">const</code>是完全不可变的，这意味着一旦将对象属性赋给了<code class="eh mk ml mm mn b">const</code>变量，就永远无法更新它。当涉及到对象和<code class="eh mk ml mm mn b">const</code>时，你不能重新定义<code class="eh mk ml mm mn b">const</code>变量，但是你<strong class="jw ig">可以</strong>更新对象的属性。</p><p id="fc69" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">在下面的例子中，我们试图给变量<code class="eh mk ml mm mn b">test</code>分配一个新的对象。如前所述，这是不允许的，我们会遇到错误。</p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="67d9" class="ks kt if mn b fv mw mx l my mz">const test = {<br/>  milliseconds: 1862,<br/>  createdBy: 'Andrew Hill',<br/>}</span><span id="6a40" class="ks kt if mn b fv na mx l my mz">test = {<br/>  milliseconds: 1862,<br/>  createdBy: 'Jane Doe',<br/>} </span><span id="a503" class="ks kt if mn b fv na mx l my mz">// Output: [Error] Assignment to constant variable.</span><span id="42a1" class="ks kt if mn b fv na mx l my mz">console.log(test);<br/>// Output: Object { milliseconds: 1862, createdBy: 'Andrew Hill' }</span></pre><p id="0ab6" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">然而，在这个例子中，我们能够毫无问题地更新<code class="eh mk ml mm mn b">test</code>变量的属性。</p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="c485" class="ks kt if mn b fv mw mx l my mz">const test = {<br/>  milliseconds: 1862,<br/>  createdBy: 'Andrew Hill',<br/>}</span><span id="b959" class="ks kt if mn b fv na mx l my mz">test.createdBy = 'Jane Doe';</span><span id="5e2d" class="ks kt if mn b fv na mx l my mz">console.log(test);<br/>// Output: Object { milliseconds: 1862, createdBy: 'Jane Doe' }</span></pre><p id="6967" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">如果您正在寻找<em class="kr">【真正】</em>不可变的对象，看一看<code class="eh mk ml mm mn b"><a class="ae kq" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" rel="noopener ugc nofollow" target="_blank">Object.freeze()</a></code>方法，它防止添加新的属性，现有的属性被删除，并且防止现有的属性、它们的可枚举性、可配置性和可写性被改变。</p></div><div class="ab cl ls lt hc lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hn ho hp hq hr"><h1 id="f75b" class="lz kt if bd ku ma mb mc ky md me mf lc jl mg jm lf jo mh jp li jr mi js ll mj dt translated">范围:<strong class="ak">常量和let </strong></h1><p id="70a9" class="pw-post-body-paragraph ju jv if jw b jx ln jg jz ka lo jj kc kd lp kf kg kh lq kj kk kl lr kn ko kp hn dt translated">使用<code class="eh mk ml mm mn b">const</code>和<code class="eh mk ml mm mn b">let</code>定义的变量被认为是块范围的，这意味着它们在定义它们的代码块中是可用的。JavaScript代码块是花括号内的任何东西<code class="eh mk ml mm mn b">{}</code>。对象和函数都包含块，让块独立存在是完全正确的。</p><p id="5ec4" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">考虑下面的例子。注意，我们在下面的例子中使用了<code class="eh mk ml mm mn b">let</code>，但是同样的规则也适用于<code class="eh mk ml mm mn b">const</code>的作用域:</p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="8470" class="ks kt if mn b fv mw mx l my mz">function scopeTest() {<br/>  let test = 100;<br/>  console.log(test);<br/>}</span><span id="8ab0" class="ks kt if mn b fv na mx l my mz">scopeTest();<br/>// Output: 100</span></pre><p id="200a" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">在这个例子中，<code class="eh mk ml mm mn b">test</code>变量被认为是一个局部变量，其作用域是由<code class="eh mk ml mm mn b">scopeTest()</code>函数创建的块。我们能够访问存储在变量<code class="eh mk ml mm mn b">test</code>中的值，因为变量声明和<code class="eh mk ml mm mn b">console.log()</code>存在于同一个<code class="eh mk ml mm mn b">scopeTest()</code>功能块中。</p><p id="69ea" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">使用这个例子的修改版本，我们可以说明这个变量在它所作用的功能块之外是如何不可访问的。</p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="0b88" class="ks kt if mn b fv mw mx l my mz">function scopeTest() {<br/>  let test = 100;<br/>}</span><span id="2539" class="ks kt if mn b fv na mx l my mz">scopeTest();</span><span id="4416" class="ks kt if mn b fv na mx l my mz">console.log(test);<br/>// Output: [Error] test is not defined.</span></pre><p id="6c52" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">使用<code class="eh mk ml mm mn b">const</code>和<code class="eh mk ml mm mn b">let </code>可以用相同的名称定义多个变量，只要它们不在同一个块中。这样做将导致两个完全不同的变量在不同的范围内存在相同的名称。</p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="a4dc" class="ks kt if mn b fv mw mx l my mz">let test = 100;</span><span id="6288" class="ks kt if mn b fv na mx l my mz">console.log(test);<br/>// Output: 100</span><span id="6727" class="ks kt if mn b fv na mx l my mz">function scopeTest() {<br/>  let test = 200;</span><span id="78e1" class="ks kt if mn b fv na mx l my mz">console.log(test);<br/>  // Output: 200<br/>}</span><span id="88cd" class="ks kt if mn b fv na mx l my mz">console.log(test);<br/>// Output: 100</span></pre></div><div class="ab cl ls lt hc lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hn ho hp hq hr"><h1 id="24b8" class="lz kt if bd ku ma mb mc ky md me mf lc jl mg jm lf jo mh jp li jr mi js ll mj dt translated">最后的想法</h1><p id="538e" class="pw-post-body-paragraph ju jv if jw b jx ln jg jz ka lo jj kc kd lp kf kg kh lq kj kk kl lr kn ko kp hn dt translated">那么什么时候应该用什么呢？在这个问题上有一些不同的观点，你可以在谷歌上快速搜索一下。最终，我选择以Mathias Bynens在他的文章中描述的方式使用它们:</p><ul class=""><li id="1d89" class="nb nc if jw b jx jy ka kb kd nd kh ne kl nf kp ng nh ni nj dt translated">默认情况下，对所有变量声明使用<code class="eh mk ml mm mn b">const</code>。</li><li id="13ac" class="nb nc if jw b jx nk ka nl kd nm kh nn kl no kp ng nh ni nj dt translated">仅在需要重新绑定时使用<code class="eh mk ml mm mn b">let</code>。</li><li id="02f0" class="nb nc if jw b jx nk ka nl kd nm kh nn kl no kp ng nh ni nj dt translated"><code class="eh mk ml mm mn b">var</code>不应在ES6中使用</li></ul><p id="03c4" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">感谢阅读。如果您喜欢这篇文章，请考虑推荐它来支持本系列的未来安装。👏</p><p id="ce41" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated"><a class="ae kq" rel="noopener" href="/@andrewjrhill/getting-to-grips-with-es6-arrow-functions-ebfa62c5c5d6#.3x4gbza5l"> <em class="kr">点击此处查看第二部分:了解胖箭头功能</em> </a></p><figure class="mo mp mq mr fq hw"><div class="bz el l di"><div class="np nq l"/></div></figure></div></div>    
</body>
</html>