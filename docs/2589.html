<html>
<head>
<title>Using Optimizely with React/Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与React/Redux一起优化使用</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/using-optimizely-with-react-redux-99bd510c790f?source=collection_archive---------3-----------------------#2017-02-06">https://medium.com/hackernoon/using-optimizely-with-react-redux-99bd510c790f?source=collection_archive---------3-----------------------#2017-02-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/5eeed4c13681e918d4473f48154a9129.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NMs1Tb8NGs5i4XDNOE7SXA.jpeg"/></div></div></figure><div class=""/><p id="a4f2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Optimizely 是一个让你执行AB测试的工具。像所有或大多数其他客户端AB测试<a class="ae kc" href="https://hackernoon.com/tagged/tools" rel="noopener ugc nofollow" target="_blank">工具</a>一样，它使用以下机制:</p><ul class=""><li id="789b" class="kd ke if je b jf jg jj jk jn kf jr kg jv kh jz ki kj kk kl dt translated">您的页面上包含一个脚本标记，它可以在加载时为不同的用户群改变它</li><li id="66a2" class="kd ke if je b jf km jj kn jn ko jr kp jv kq jz ki kj kk kl dt translated">将该变化与未改变的对照组进行比较，以了解其表现如何</li></ul><p id="a5bf" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对我们团队来说，这个模型的主要卖点很简单:运行测试不需要修改代码。这使得产品和营销团队可以在没有工程师参与的情况下更快地启动生产测试。</p><p id="28e0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，有一个问题:React应用程序的优化使用存在固有的问题。每次状态或存储发生变化时，React都会重新呈现组件。因此，优化更改不会持续，它们会在重新渲染时被React diffing机制移除。</p></div><div class="ab cl kr ks hc kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hn ho hp hq hr"><h2 id="64fc" class="ky kz if bd la lb lc ld le lf lg lh li jn lj lk ll jr lm ln lo jv lp lq lr ls dt translated">外面已经有什么了？</h2><p id="321d" class="pw-post-body-paragraph jc jd if je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">最近有许多文章介绍了React+优化使用的不同解决方案。</p><p id="d9e0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">【更新:Tilt博客似乎已经被撤下】</strong> <a class="ka kb gr" href="https://medium.com/u/4396b53c7d20?source=post_page-----99bd510c790f--------------------------------" rel="noopener" target="_blank"> Tilt </a>工程团队设计了<a class="ae kc" href="http://engineering.tilt.com/roll-your-own-ab-tests-with-optimizely-and-react/" rel="noopener ugc nofollow" target="_blank">一个非常复杂的系统</a>使用存储来保存实验信息。看起来像是一个结构良好的客户端渲染方法，需要进行大的修改(比如删除/添加组件)。</p><p id="875e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ka kb gr" href="https://medium.com/u/6c7e5d2a3e2d?source=post_page-----99bd510c790f--------------------------------" rel="noopener" target="_blank"> Shesh </a>的想法不太复杂，更容易实现，是直接查询Optimizely的全局可用数据对象来获得主动实验。在这里阅读<a class="ae kc" href="http://www.sheshbabu.com/posts/using-optimizely-with-react/" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="0bf4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ka kb gr" href="https://medium.com/u/1978e73ad70?source=post_page-----99bd510c790f--------------------------------" rel="noopener" target="_blank"> Milan </a>谈到了这个问题的另一个角度——<a class="ae kc" rel="noopener" href="/@korsosm/ab-testing-with-optimizely-and-server-side-rendering-react-e6d104f7befb#.vsiciejgu">服务器端渲染应用，使用Optimizely REST API在服务器上获取实验信息</a>。不仅仅是反应，任何服务器端AB测试都需要部署。但是对我来说，这种方法似乎没有充分利用——我宁愿使用它的GUI进行客户端AB测试，或者根本不使用它。</p><p id="2b2a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里有很多好主意。然而，令我非常困扰的是，上述所有解决方案都要求对每个新的AB测试进行部署。</p></div><div class="ab cl kr ks hc kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hn ho hp hq hr"><h1 id="08bc" class="ly kz if bd la lz ma mb le mc md me li mf mg mh ll mi mj mk lo ml mm mn lr mo dt translated">无需部署或代码更改即可优化反应/还原</h1><p id="a4a0" class="pw-post-body-paragraph jc jd if je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">这里有一个轻量级的方法。需要注意的事项:</p><ul class=""><li id="18a9" class="kd ke if je b jf jg jj jk jn kf jr kg jv kh jz ki kj kk kl dt translated">这是为中小型UX调整。如果你的AB测试是大规模的，那么代码变更可能是一个更好的途径。</li><li id="925d" class="kd ke if je b jf km jj kn jn ko jr kp jv kq jz ki kj kk kl dt translated">该方法在您的代码库中的成功取决于您特定的React实现。这与我们的React/Redux应用程序配合得很好，因为它在主要使用道具和动作(而不是本地状态)的每次更改时都重新呈现顶级组件。</li></ul><h2 id="3d18" class="ky kz if bd la lb lc ld le lf lg lh li jn lj lk ll jr lm ln lo jv lp lq lr ls dt translated">第一步</h2><p id="9ba5" class="pw-post-body-paragraph jc jd if je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">当状态或存储改变时，React重新渲染组件。如果你使用React，你肯定熟悉生命周期方法<a class="ae kc" href="https://facebook.github.io/react/docs/react-component.html" rel="noopener ugc nofollow" target="_blank"/>。您可以使用这些方法中的几个来调用一个全局函数，该函数就像一个钩子一样触发<a class="ae kc" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>进行所需的DOM修改。</p><p id="b6d0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这看起来像什么:</p><p id="0f7f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh mp mq mr ms b">window.optimizelyHook</code>将是一个全局函数，在组件装载到页面上后立即被调用。利用你的顶层组件的<code class="eh mp mq mr ms b">componentDidMount</code>和<code class="eh mp mq mr ms b">componentDidUpdate</code>生命周期方法，就像这样:</p><figure class="mt mu mv mw fq hw"><div class="bz el l di"><div class="mx my l"/></div></figure><h2 id="3ec6" class="ky kz if bd la lb lc ld le lf lg lh li jn lj lk ll jr lm ln lo jv lp lq lr ls dt translated">第二步</h2><p id="476d" class="pw-post-body-paragraph jc jd if je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">在Optimizely的变体JavaScript中，定义<code class="eh mp mq mr ms b">optimizelyHook()</code>函数。然后，在这个函数中执行所有DOM修改。</p><figure class="mt mu mv mw fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mz"><img src="../Images/8413f005f59de953c5a757b321438a1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2wQZDSqu-3187NesxiRN7A.png"/></div></div></figure><p id="baa4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh mp mq mr ms b">componentDidMount</code>在初始坐骑上被调用一次<br/> <code class="eh mp mq mr ms b">componentDidUpdate</code>在每次连续更新的道具上被调用</p><h2 id="f636" class="ky kz if bd la lb lc ld le lf lg lh li jn lj lk ll jr lm ln lo jv lp lq lr ls dt translated">结果呢</h2><p id="f8fd" class="pw-post-body-paragraph jc jd if je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">将在每次道具更新时运行，导致实验通过Redux动作触发的重新渲染而持续。</p><p id="aa87" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">部署一次，在多个AB测试中使用多次。🎉</p></div><div class="ab cl kr ks hc kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hn ho hp hq hr"><h2 id="51f9" class="ky kz if bd la lb lc ld le lf lg lh li jn lj lk ll jr lm ln lo jv lp lq lr ls dt translated">资源</h2><p id="4675" class="pw-post-body-paragraph jc jd if je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated"><a class="ae kc" href="https://conversionxl.com/server-side-vs-client-side-ab-testing-tools-whats-the-difference/" rel="noopener ugc nofollow" target="_blank">了解服务器端与客户端AB测试</a></p><p id="e572" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae kc" href="https://facebook.github.io/react/docs/react-component.html" rel="noopener ugc nofollow" target="_blank"> React生命周期方法</a></p><div class="mt mu mv mw fq ab cb"><figure class="na hw nb nc nd ne nf paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="na hw nb nc nd ne nf paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="na hw nb nc nd ne nf paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ng nh ni"><p id="f922" class="jc jd nj je b jf jg jh ji jj jk jl jm nk jo jp jq nl js jt ju nm jw jx jy jz hn dt translated"><a class="ae kc" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kc" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kc" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae kc" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd nj je b jf jg jh ji jj jk jl jm nk jo jp jq nl js jt ju nm jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kc" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kc" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="mt mu mv mw fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nn"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="mt mu mv mw fq hw"><div class="bz el l di"><div class="no my l"/></div></figure></div></div>    
</body>
</html>