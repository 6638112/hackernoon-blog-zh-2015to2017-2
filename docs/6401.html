<html>
<head>
<title>Using Protocol Buffers with API Gateway and AWS Lambda</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过API网关和AWS Lambda使用协议缓冲区</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/using-protocol-buffers-with-api-gateway-and-aws-lambda-22c3804f3e76?source=collection_archive---------1-----------------------#2017-09-16">https://medium.com/hackernoon/using-protocol-buffers-with-api-gateway-and-aws-lambda-22c3804f3e76?source=collection_archive---------1-----------------------#2017-09-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="7f9a" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">与JSON相比，Protocol Buffers和Thrift等二进制格式可以产生明显更小的有效负载，这可以在大规模网络带宽成本方面产生很大的影响，并改善受限环境中的用户体验。</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/d0a375e9cf97d9ef6eeb33e62e9dce33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lpbb5TlG8adbbtTYQW0LyA.png"/></div></div></figure><p id="8f49" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">AWS在2016年末宣布了对API网关的<a class="ae kr" href="https://aws.amazon.com/about-aws/whats-new/2016/11/binary-data-now-supported-by-api-gateway/" rel="noopener ugc nofollow" target="_blank">二进制支持，这为你使用更高效的二进制格式打开了大门，比如谷歌的</a><a class="ae kr" href="https://developers.google.com/protocol-buffers/" rel="noopener ugc nofollow" target="_blank">协议缓冲区</a>和<a class="ae kr" href="https://thrift.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Thrift </a>。</p><h1 id="4f73" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">为什么？</h1><p id="aac9" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">与JSON——它是用API Gateway和Lambda构建的API的基础——相比，这些二进制格式产生的有效负载要小得多。</p><p id="de89" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在<em class="lp">规模</em>下，它们会对您的带宽成本产生很大影响。</p><p id="5479" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在<em class="lp">受限的</em>环境中，如低端设备或移动连接不良的国家，发送较小的有效负载也可以通过改善<strong class="jx hv">端到端网络延迟</strong>以及设备上可能的<a class="ae kr" href="http://theburningmonk.com/benchmarks/" rel="noopener ugc nofollow" target="_blank">处理时间</a>来改善您的用户体验。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff lq"><img src="../Images/0339244441311158d2ba45c6872302d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*ml5fAz1Eu6-uINz-XMsf7A.png"/></div><figcaption class="lr ls fg fe ff lt lu bd b be z ek">Comparison of serializer performance between Proto Buffers and JSON in .Net</figcaption></figure><h1 id="84b6" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated"><strong class="ak">如何</strong></h1><p id="6c61" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">遵循这三个简单的步骤(假设您使用的是无服务器框架):</p><ol class=""><li id="0e03" class="lv lw hu jx b jy jz kb kc ke lx ki ly km lz kq ma mb mc md dt translated">安装令人敬畏的<a class="ae kr" href="https://www.npmjs.com/package/serverless-apigw-binary" rel="noopener ugc nofollow" target="_blank">无服务器apigw-binary </a>插件</li><li id="f465" class="lv lw hu jx b jy me kb mf ke mg ki mh km mi kq ma mb mc md dt translated">将<code class="eh mj mk ml mm b">application/x-protobuf</code>添加到二进制媒体类型(见下面的截图)</li><li id="1e36" class="lv lw hu jx b jy me kb mf ke mg ki mh km mi kq ma mb mc md dt translated">添加将协议缓冲区作为base64编码响应返回的函数</li></ol><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mn"><img src="../Images/571c575a4d991dbca66d42f1e573081d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1KwyBsxScwVKoZKVS80I9Q.png"/></div></div><figcaption class="lr ls fg fe ff lt lu bd b be z ek">The serverless-apigw-binary plugin has made it really easy to add binary support to API Gateway</figcaption></figure><p id="3fe2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">要对Nodejs中的协议缓冲区有效载荷进行编码和解码，可以使用NPM的<a class="ae kr" href="https://www.npmjs.com/package/protobufjs" rel="noopener ugc nofollow" target="_blank"> protobufjs </a>包。</p><div class="mo mp fm fo mq mr"><a href="https://github.com/dcodeIO/protobuf.js" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab ej"><div class="mt ab mu cl cj mv"><h2 class="bd hv fv z el mw eo ep mx er et ht dt translated">dcodeIO/protobuf.js</h2><div class="my l"><h3 class="bd b fv z el mw eo ep mx er et ek translated">js-JavaScript(&amp; TypeScript)的协议缓冲区。</h3></div><div class="mz l"><p class="bd b gc z el mw eo ep mx er et ek translated">github.com</p></div></div><div class="na l"><div class="nb l nc nd ne na nf jt mr"/></div></div></a></div><p id="464e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">它允许您使用现有的<code class="eh mj mk ml mm b">.proto</code>文件，或者您可以使用JSON描述符。阅读一下这些文件，看看你如何开始。</p><p id="910b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在演示项目中(本文底部的链接)，你会发现一个Lambda函数，它总是在协议缓冲区中返回一个响应。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ng nh l"/></div></figure><p id="f957" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这个函数需要注意几件事:</p><ul class=""><li id="f7ad" class="lv lw hu jx b jy jz kb kc ke lx ki ly km lz kq ni mb mc md dt translated">我们将<code class="eh mj mk ml mm b">Content-Type</code>标题设置为<code class="eh mj mk ml mm b">application/x-protobuf</code></li><li id="84ae" class="lv lw hu jx b jy me kb mf ke mg ki mh km mi kq ni mb mc md dt translated"><code class="eh mj mk ml mm b">body</code>是协议缓冲区有效负载的base64编码表示</li><li id="779b" class="lv lw hu jx b jy me kb mf ke mg ki mh km mi kq ni mb mc md dt translated"><code class="eh mj mk ml mm b">isBase64Encoded</code>被设置为<code class="eh mj mk ml mm b">true</code></li></ul><p id="7725" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">您需要做<strong class="jx hv">所有这3件事</strong>来让API Gateway以二进制数据的形式返回响应。</p><p id="82f8" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">把它们看作是让API Gateway返回二进制数据的魔咒，并且，<strong class="jx hv">调用者还必须将</strong> <code class="eh mj mk ml mm b">Accept</code> <strong class="jx hv">头设置为</strong> <code class="eh mj mk ml mm b">application/x-protobuf</code>。</p><p id="9f63" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在同一个项目中，还有一个JSON端点，它返回与comparison相同的有效载荷。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nj"><img src="../Images/3b0316a357769217fe2547c75ccce7d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-SKU3a6BmUVdGg42Vs8sTA.png"/></div></div></figure><p id="c400" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">来自这个JSON端点的响应如下所示:</p><pre class="jk jl jm jn fq nk mm nl nm aw nn dt"><span id="e05c" class="no kt hu mm b fv np nq l nr ns">{"players":[{"id":"eb66db14992e06b36282d607cf0134ce4fe45f50","name":"Calvin Ortiz","scores":[57,12,100,56,47,78,20,37,32,48]},{"id":"7b9b38e535453d120e706ff57fef41f6fee991cb","name":"Marcus Cummings","scores":[40,57,24,15,45,54,25,67,59,23]},{"id":"db34a2a5f4d16e77a6d3d6154a8b8bb6760b3b99","name":"Harry James","scores":[61,85,14,70,8,80,14,22,76,87]},{"id":"e21018c4f43eef10771e0fa71bc54156b00a64dd","name":"Gregory Bishop","scores":[51,31,27,47,72,75,61,28,100,41]},{"id":"b3ee29ee49b640ce15be1737d0dca60e48108ee1","name":"Ann Evans","scores":[69,17,48,99,85,8,75,55,78,46]},{"id":"9c1e6d4d46bb0c0d2c92bab11e5dbd5f4ab0c619","name":"Juan Perez","scores":[71,34,60,84,21,98,60,8,91,92]},{"id":"d8de89222633c61393931457c1e72558eba48639","name":"Loretta Harvey","scores":[15,40,73,92,42,65,58,30,26,84]},{"id":"141dad672ec559431f808964391d128d2c3274bf","name":"Ian Powell","scores":[17,21,14,84,64,14,22,22,34,92]},{"id":"8a97e85e2e5385c45fc31f24bfe781c26f78c0b7","name":"Steve Gibson","scores":[33,97,6,1,20,1,78,3,77,19]},{"id":"6b3ca6924e17cd5fd9d91b36d49b36a5d542c9ea","name":"Harold Ferguson","scores":[31,32,4,10,37,85,46,86,39,17]}]}</span></pre><p id="62e7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如您所见，它只是一堆随机生成的名称、GUIDs和整数。<strong class="jx hv">协议缓冲区中的相同响应比</strong> <strong class="jx hv">小近40%</strong>。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nt"><img src="../Images/501f8e6c7be18a9646d15c7988097f79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ls8TwtBVNNt6AfVHbbf_EA.png"/></div></div></figure><h2 id="64b0" class="no kt hu bd ku nu nv nw ky nx ny nz lc ke oa ob le ki oc od lg km oe of li og dt translated">protobufjs包的问题</h2><p id="4f2a" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">在我们继续之前，有一个关于在Lambda函数中使用<a class="ae kr" href="https://www.npmjs.com/package/protobufjs" rel="noopener ugc nofollow" target="_blank"> protobufjs </a>包的重要细节— <strong class="jx hv">你需要在Linux系统上</strong>使用 <code class="eh mj mk ml mm b">npm install</code> <strong class="jx hv">包。</strong></p><p id="4e94" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这是因为它有一个作为本机二进制文件分发的依赖项，所以如果您在OSX上安装了打包的，那么打包并部署到Lambda的二进制文件将不会在<a class="ae kr" href="http://docs.aws.amazon.com/lambda/latest/dg/current-supported-versions.html" rel="noopener ugc nofollow" target="_blank"> Lambda执行环境</a>上运行。</p><p id="269d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我过去在其他谷歌图书馆也遇到过类似的问题。我发现处理这个问题的最好方法是借鉴<a class="ae kr" href="https://github.com/eawsy/aws-lambda-go-shim" rel="noopener ugc nofollow" target="_blank"> aws-serverless-go-shim </a>的方法，将代码部署在Docker容器中。</p><p id="e202" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">通过这种方式，你可以在本地为你的操作系统安装一个兼容版本的本地二进制文件，这样你就可以继续使用<code class="eh mj mk ml mm b">sls invoke local</code>运行和调试你的函数(详见<a class="ae kr" href="https://hackernoon.com/running-and-debugging-aws-lambda-functions-locally-with-the-serverless-framework-and-vs-code-a254e2011010" rel="noopener ugc nofollow" target="_blank">这篇文章</a>)。</p><p id="f9a5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">但是，在部署期间，脚本将在运行兼容Linux发行版的Docker容器中运行<code class="eh mj mk ml mm b">npm install --force</code>。这将安装一个可以在Lambda执行环境中执行的本地二进制版本。然后，该脚本将使用<code class="eh mj mk ml mm b">sls deploy</code>来部署该功能。</p><p id="ae4c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">部署脚本可能很简单，如下所示:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ng nh l"/></div></figure><p id="4345" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在演示项目中，我还有一个<code class="eh mj mk ml mm b">docker-compose.yml</code>文件:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ng nh l"/></div></figure><p id="9116" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">无服务器框架需要我的AWS凭证，因此我将<code class="eh mj mk ml mm b">$HOME/.aws</code>目录附加到容器中，以便AWSSDK在运行时查找。</p><p id="a658" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">要进行部署，运行<code class="eh mj mk ml mm b">docker-compose up</code>。</p><h1 id="fccf" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">使用HTTP内容协商</h1><p id="e915" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">虽然二进制格式在有效载荷大小方面更有效，但它们确实有一个主要问题:<strong class="jx hv">它们很难调试</strong>。</p><p id="64d7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">想象一下这个场景——你观察到了一个bug，但是你不确定问题出在客户端应用还是服务器。但是，让我们用一个HTTP代理(比如Charles或Fiddler)来观察HTTP对话。</p><p id="e5bc" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这种工作流程对于JSON来说非常有效，但是对于二进制格式(比如协议缓冲区)来说就不行了，因为<em class="lp">的有效负载不是人类可读的</em>。</p><p id="b9cf" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">正如我们在本文中所讨论的，JSON的可读性是以占用大量带宽为代价的。对于大多数网络通信来说，无论是服务对服务，还是服务对客户端，除非有人主动“阅读”有效载荷，否则不值得为此付出代价。但是当一个人<em class="lp">试图阅读它的时候，这种可读性是非常有价值的。</em></p><p id="4719" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">幸运的是，HTTP的内容协商机制意味着我们可以两全其美。</p><p id="dd80" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在演示项目中，有一个<code class="eh mj mk ml mm b">contentNegotiated</code>函数，它根据<code class="eh mj mk ml mm b">Accept</code>头返回JSON或Protocol Buffers有效载荷。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ng nh l"/></div></figure><p id="d8db" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">默认情况下，您应该为所有网络通信使用协议缓冲区，以最大限度地减少带宽使用。</p><p id="7512" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">但是，当您需要观察通信时，您应该构建一种机制来切换到JSON的通信。这可能意味着:</p><ul class=""><li id="fb54" class="lv lw hu jx b jy jz kb kc ke lx ki ly km lz kq ni mb mc md dt translated">对于你的移动应用程序的调试版本，允许超级用户(开发人员，质量保证等。)开启<code class="eh mj mk ml mm b">debug</code>模式的能力，这将切换网络层以发送接受报头作为<code class="eh mj mk ml mm b">application/json</code></li><li id="8ff9" class="lv lw hu jx b jy me kb mf ke mg ki mh km mi kq ni mb mc md dt translated">对于服务，包括一个打开<code class="eh mj mk ml mm b">debug</code>模式的配置选项(参见<a class="ae kr" href="https://hackernoon.com/you-should-use-ssm-parameter-store-over-lambda-env-variables-5197fc6ea45b" rel="noopener ugc nofollow" target="_blank">这篇文章</a>关于配置带有SSM参数的函数和用于热插拔的缓存客户端),使服务到服务的调用也使用JSON，这样您可以更容易地捕获和分析请求和响应</li></ul><p id="22bb" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">像往常一样，你可以自己尝试演示代码，回购可在<a class="ae kr" href="https://github.com/theburningmonk/lambda-protobuf-demo" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><div class="mo mp fm fo mq mr"><a href="https://github.com/theburningmonk/lambda-protobuf-demo" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab ej"><div class="mt ab mu cl cj mv"><h2 class="bd hv fv z el mw eo ep mx er et ht dt translated">burning monk/lambda-proto buf-demo</h2><div class="my l"><h3 class="bd b fv z el mw eo ep mx er et ek translated">使用API网关和带有协议缓冲区的lambda</h3></div><div class="mz l"><p class="bd b gc z el mw eo ep mx er et ek translated">github.com</p></div></div><div class="na l"><div class="oh l nc nd ne na nf jt mr"/></div></div></a></div></div><div class="ab cl oi oj hc ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="hn ho hp hq hr"><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="ab fr cl op"><img src="../Images/8b4e4721bb1973db389b5b533d727ad1.png" data-original-src="https://miro.medium.com/v2/format:webp/0*b_1R345KzKSaI8sg.png"/></div></figure><p id="f870" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">嗨，我的名字是<strong class="jx hv">崔琰</strong>。我是一个<a class="ae kr" href="https://aws.amazon.com/developer/community/heroes/yan-cui/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx hv"> AWS无服务器英雄</strong> </a>和<a class="ae kr" href="https://bit.ly/production-ready-serverless" rel="noopener ugc nofollow" target="_blank"> <strong class="jx hv">量产无服务器</strong> </a>的作者。我已经在AWS中运行了近10年的大规模生产工作负载，我是一名架构师或首席工程师，涉足从银行、电子商务、体育流媒体到移动游戏等多个行业。我目前是一名专注于AWS和无服务器的独立顾问。</p><p id="c37e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">你可以通过<a class="ae kr" href="mailto:theburningmonk.com" rel="noopener ugc nofollow" target="_blank">邮箱</a>、<a class="ae kr" href="https://twitter.com/theburningmonk" rel="noopener ugc nofollow" target="_blank"> Twitter </a>和<a class="ae kr" href="https://www.linkedin.com/in/theburningmonk/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我。</p></div><div class="ab cl oi oj hc ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="hn ho hp hq hr"><p id="404d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">查看我的新课程，<a class="ae kr" href="https://theburningmonk.thinkific.com/courses/complete-guide-to-aws-step-functions" rel="noopener ugc nofollow" target="_blank"><strong class="jx hv">AWS步骤功能完整指南</strong> </a>。</p><p id="a329" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在本课程中，我们将介绍有效使用AWS Step Functions服务所需了解的一切。包括基本概念、HTTP和事件触发器、活动、设计模式和最佳实践。</p><p id="cd40" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在这里拿到你的副本。</p></div><div class="ab cl oi oj hc ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="hn ho hp hq hr"><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mn"><img src="../Images/2faf40b47320300fed81b3e09483ffb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZYcHhOOzUf5VB-Ri.png"/></div></div></figure><p id="ee8c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">来了解AWS Lambda: CI/CD的操作性<strong class="jx hv">最佳实践</strong>，本地测试&amp;调试功能、日志记录、监控、分布式跟踪、canary部署、配置管理、认证&amp;授权、VPC、安全性、错误处理等等。</p><p id="8bb5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">还可以用代码<strong class="jx hv"> ytcui </strong>获得<strong class="jx hv">票面价格6折</strong>。</p><p id="2e68" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">点击此处获取您的副本<a class="ae kr" href="https://bit.ly/production-ready-serverless" rel="noopener ugc nofollow" target="_blank"/>。</p></div></div>    
</body>
</html>