<html>
<head>
<title>Writing fluent functional code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写流畅的功能代码</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/writing-fluent-functional-code-384111431895?source=collection_archive---------14-----------------------#2017-06-07">https://medium.com/hackernoon/writing-fluent-functional-code-384111431895?source=collection_archive---------14-----------------------#2017-06-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/bf51966106c7363db7154b0319a962a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kJ7w72YPaawW4vKAoHVYZQ.png"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Fluent code should make you feel happy, like this image does.</figcaption></figure><div class=""/><p id="c6d4" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><a class="ae ke" href="https://www.martinfowler.com/bliki/FluentInterface.html" rel="noopener ugc nofollow" target="_blank">流畅Api </a>是读起来像一句话的代码。如果您曾经编写过测试代码，您可能知道这一点，它读起来像一个句子:</p><figure class="kf kg kh ki fq hw"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="aedf" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果您使用过表达式生成器，您可能会注意到它非常容易阅读:</p><figure class="kf kg kh ki fq hw"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="baf7" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">要启用这个API，您可以使用一个从它的每个方法返回<code class="eh kl km kn ko b">this</code>的<code class="eh kl km kn ko b">class</code>:</p><figure class="kf kg kh ki fq hw"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="ee17" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">非常简单，实际上很容易实现，但是它也有缺点——必须从每个方法返回<code class="eh kl km kn ko b">this</code>有点烦人。</p><p id="99ad" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果你像我一样，不喜欢使用<code class="eh kl km kn ko b">this</code>，你可能已经尝试过寻找替代品。</p><p id="3640" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">最直接的函数式方法，也是我认为最好的方法，是对无状态setters使用“pipe()”。我用拉姆达来介绍一下:</p><figure class="kf kg kh ki fq hw"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="6512" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这里的想法是，<code class="eh kl km kn ko b">set(lens, value, src)</code>是一个接受</p><ul class=""><li id="cbe3" class="kp kq ij ji b jj jk jn jo jr kr jv ks jz kt kd ku kv kw kx dt translated"><code class="eh kl km kn ko b">lens</code>(基本上是一种定义路径的方式)，我会在下一段中稍微解释一下。</li><li id="0d98" class="kp kq ij ji b jj ky jn kz jr la jv lb jz lc kd ku kv kw kx dt translated"><code class="eh kl km kn ko b">value</code>:写入镜头定义路径的值</li><li id="13ad" class="kp kq ij ji b jj ky jn kz jr la jv lb jz lc kd ku kv kw kx dt translated"><code class="eh kl km kn ko b">src</code> : set会根据源对象返回一个新的对象(永不变异)，带有新的属性和值。</li></ul><p id="a492" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">最后，这与类构建器的结果相同，但是更加简洁，不需要处理多余的<code class="eh kl km kn ko b">this</code>。</p><p id="29f4" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">关于这种方法的几点注意事项:</p><ol class=""><li id="3eda" class="kp kq ij ji b jj jk jn jo jr kr jv ks jz kt kd ld kv kw kx dt translated">现在对Typescript来说没有什么用，因为curried函数需要使用<a class="ae ke" href="https://github.com/Microsoft/TypeScript/issues/5453" rel="noopener ugc nofollow" target="_blank">变量类型</a>，而Typescript目前还不支持它。尽管它在<a class="ae ke" href="https://github.com/Microsoft/TypeScript/wiki/Roadmap" rel="noopener ugc nofollow" target="_blank">路线图</a>上。你可以在这里<a class="ae ke" href="https://gist.github.com/donnut/fd56232da58d25ceecf1" rel="noopener ugc nofollow" target="_blank">阅读</a>了解问题。</li><li id="bb86" class="kp kq ij ji b jj ky jn kz jr la jv lb jz lc kd ld kv kw kx dt translated">如果您需要写入一个比单个级别更深的路径，对于(一个虚构的)示例<code class="eh kl km kn ko b">site.services.securityEnabled</code>，您应该使用<code class="eh kl km kn ko b">lensPath</code>:</li></ol><figure class="kf kg kh ki fq hw"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="2643" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">好的，如果你正在阅读这篇文章，你可能已经注意到，虽然它看起来很棒，但这种模式不允许你链接，虽然我建议流利的定义应该扩展或放在更广泛的上下文中，但我们中的一些人需要链接才能在阅读代码时感到舒服。</p><p id="6cf7" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们看看如何在允许链接的同时保留表达式生成器的功能。</p><p id="d115" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这是一个基于泛函的表达式生成器的简单例子:</p><figure class="kf kg kh ki fq hw"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="c538" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">它仍然易于阅读，开始看起来类似于类版本，但是不需要从每个方法返回<code class="eh kl km kn ko b">this</code>。</p><p id="2aa1" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">仍然有一些重复，但是我们可以通过一些简单的重构来消除它:</p><figure class="kf kg kh ki fq hw"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="c08f" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">它有它的优点和缺点，我相信它可以做得更好看。(随意建议)</p><p id="24f7" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">但底线是——它是一个无状态的、功能性的、流畅的、表达构建器。</p><p id="6147" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">WDYT？</p></div></div>    
</body>
</html>