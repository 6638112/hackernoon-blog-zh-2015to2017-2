<html>
<head>
<title>JavaScript: Do you like games? (part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:你喜欢游戏吗？(第三部分)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/javascript-do-you-like-games-part-3-6225ec264902?source=collection_archive---------5-----------------------#2016-11-07">https://medium.com/hackernoon/javascript-do-you-like-games-part-3-6225ec264902?source=collection_archive---------5-----------------------#2016-11-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="9fab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">关于这个话题:<a class="ae jp" href="https://blog.hellojs.org/javascript-do-you-like-games-part-1-c1320c2c52ec" rel="noopener ugc nofollow" target="_blank">第1部分</a> | <a class="ae jp" href="https://blog.hellojs.org/javascript-do-you-like-games-part-2-9d4141ca2493" rel="noopener ugc nofollow" target="_blank">第2部分</a> |第3部分| <a class="ae jp" rel="noopener" href="/@radu.bogdan.gaspar/javascript-do-you-like-games-part-4-9d6e8adb5626">第4部分</a> | <a class="ae jp" rel="noopener" href="/@radu.bogdan.gaspar/javascript-do-you-like-games-part-5-a79bb69ad9e1">第5部分</a> | <a class="ae jp" rel="noopener" href="/@radu.bogdan.gaspar/javascript-do-you-like-games-part-6-7bff0b8ce05e">第6部分</a></p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/e0ca8667cb4037a29bca5fc0730ddfe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VUJsiIjFDp0UxHCI5uchlA.png"/></div></div></figure><p id="b73d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上一篇<a class="ae jp" href="https://blog.hellojs.org/javascript-do-you-like-games-part-2-9d4141ca2493" rel="noopener ugc nofollow" target="_blank">文章</a>有点长，所以我们将以较小的增量前进。</p><p id="0e83" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">先来讨论一下<a class="ae jp" href="https://hackernoon.com/tagged/movement" rel="noopener ugc nofollow" target="_blank">运动</a>在游戏中的工作原理。18世纪的瑞士数学家、物理学家、天文学家、逻辑学家和工程师莱昂哈德·欧拉设计了一种方法，让我们根据两件事来预测一个物体的位置:它的当前位置和速度。我们实际上在我们的<a class="ae jp" href="https://blog.hellojs.org/javascript-do-you-like-games-part-2-9d4141ca2493" rel="noopener ugc nofollow" target="_blank">上一篇文章</a>中使用了我们的<strong class="it hv"> Square </strong>类的<strong class="it hv"> <em class="kc"> update() </em> </strong>方法:</p><pre class="jr js jt ju fq kd ke kf kg aw kh dt"><span id="4e55" class="ki kj hu ke b fv kk kl l km kn">this.x += 1 * movementMultiplier;<br/>this.y += 1.5 * movementMultiplier;</span></pre><p id="35cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">欧拉积分在速度恒定的游戏中创造了奇迹，在处理器上也非常容易；不幸的是，你会很快发现，如果你计划建立一个物理引擎，这是不够的…它变得非常不准确。让我们想象一下:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff ko"><img src="../Images/17b843ea6eb3203383fec04143b77721.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VBwv772nqrDXKnV_BowYKQ.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">Euler integration</figcaption></figure><p id="7f26" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在上图中，网格上两个峰值之间的距离约为30px，我们的球的速度为每帧60px，我们运行10帧(60fps，即1/6秒)。这似乎很好…运动是恒定的，所以应该很容易处理，对不对？…嗯，不完全是；让我们在那里加一面墙:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff ko"><img src="../Images/9e0f9f33d9921a7043a7d65ff1724861.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A2EXhdBvLIlywJoYCQh9CQ.png"/></div></div></figure><p id="1630" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在第5帧和第6帧之间，你可以看到一面令人印象深刻的墙；更令人印象深刻的是，按照现在的逻辑，那个球会像不存在一样穿过墙。如果你想实现心灵运输，这可能会很酷，但如果你想碰撞，就没那么酷了。</p><p id="2bc3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在游戏中，检测多个物体的碰撞是必要的，如果你考虑到每个物体都有它自己的轨迹，速度和外力作用在它身上…欧拉积分证明是不够的。</p><p id="26da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一种方法是使用龙格-库塔方法中的一种，但是它们会给处理器带来压力；对于精确的物理计算来说，这是完美的，但是对于我们的目的来说，这可能有点过了。</p><p id="20d8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">大多数游戏中的go to方法将使用法国物理学家Loup Verlet的方程，特别是<a class="ae jp" href="https://en.wikipedia.org/wiki/Verlet_integration" rel="noopener ugc nofollow" target="_blank"> Verlet积分</a>。主要的区别在于，使用Verlet积分，您计算的是对象的速度，而不是它在下一帧中的位置。您可以通过从当前位置中减去前一个位置来完成此操作。</p><p id="669d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我一直在说速度，所以我要纠正我自己；<strong class="it hv">我们实际上在计算速度</strong>。速度和速率的区别对我们很重要，因为速度不知道方向，而速率是一个矢量，它知道方向；这是一个非常小却非常重要的区别。</p><pre class="jr js jt ju fq kd ke kf kg aw kh dt"><span id="468b" class="ki kj hu ke b fv kk kl l km kn">let velocity = currentPosition - previousPosition;<br/>position += velocity;</span></pre><p id="6e06" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是否意味着我们的碰撞问题消失了？不完全是这样，但是这样更容易纠正；我们可以根据当前和以前的状态计算下一个状态，使我们能够在渲染之前解决任何冲突。</p><p id="b3c1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将在游戏引擎中创建一个<strong class="it hv"> VerletModel </strong>，这将允许其他对象在需要时使用它；就目前而言，它应该:</p><ul class=""><li id="83a9" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">暴露x和y速度的getters和setters</li><li id="cc47" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">公开x和y位置值的getters和setters</li></ul><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lh li l"/></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">engine/models/VerletModel.js</figcaption></figure><p id="e983" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个模型可以潜在地保存其他事物的变量，比如:<em class="kc">重力</em>、<em class="kc">摩擦力</em>、<em class="kc">旋转</em>等等，或者它可以通过添加这些特性的另一个类来扩展。这背后的原因很简单:所有的游戏都有运动，但不是所有的游戏都需要复杂的物理。</p><p id="167d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们来看一个例子；我们将创建另一个如上所述移动的正方形，并为我们的模型添加一点加速度和摩擦逻辑。一个经典的MVC方法应该可以解决这个问题:</p><ul class=""><li id="ac98" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated"><strong class="it hv"> SquareModel </strong>类，它将扩展<strong class="it hv"> VerletModel </strong>:它将存储与我们的square相关的所有数据，以及一个<strong class="it hv"> <em class="kc"> update() </em> </strong>方法，该方法将覆盖<strong class="it hv"> VerletModel </strong>中的默认方法。</li></ul><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lh li l"/></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">verletSquare/square/SquareModel.js</figcaption></figure><p id="2a0a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以看到我们使用<strong class="it hv"> <em class="kc"> x </em> </strong>，<strong class="it hv"> <em class="kc"> y </em> </strong>，<strong class="it hv"> <em class="kc"> vx </em> </strong>和<em class="kc"><em class="kc">vy</em>设置器和<strong class="it hv"> VerletModel </strong>的获取器来计算摩擦力，然后将摩擦力加到加速度上。</em></p><ul class=""><li id="0682" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated"><strong class="it hv"> SquareView </strong>类，它将扩展<strong class="it hv">场景(目前为</strong>；因为这应该扩展<strong class="it hv">显示对象</strong>，我们还没有)</li></ul><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lh li l"/></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">verletSquare/square/SquareView.js</figcaption></figure><p id="617f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> SquareView </strong>接收一个<strong class="it hv"> SquareModel </strong>和<strong class="it hv"> SquareCtrl </strong>的实例，并在自己的<strong class="it hv"> <em class="kc"> update() </em> </strong>方法中对其进行更新。您还会看到，我们在模型上存储了一个场景引用，因为这是将正方形正确包装到其父场景所必需的。这很烦人，应该是自动完成的，但是我们还不担心这个。</p><ul class=""><li id="eb7a" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated"><strong class="it hv"> SquareCtrl </strong>类，它将扩展<strong class="it hv">键盘</strong></li></ul><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lh li l"/></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">verletSquare/square/SquareCtrl.js</figcaption></figure><p id="99a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> SquareCtrl </strong>只有一个作用:根据当前按下的键改变加速度。当我们释放一个键时，摩擦力设置为0.94。这个值将与我们的速度相乘，结果加到我们的加速度上。</p><p id="1ba5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后我们会得到一个摩擦效果，它会让物体在每一帧中减速。</p><p id="ec27" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们按住键，每一帧的加速度增加0.5。在我们的<strong class="it hv"> <em class="kc"> update() </em> </strong>方法中，我们确实有一点代码重复，但是对于这个演示来说这没什么问题。</p><p id="d2ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们把所有东西放在一起:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lh li l"/></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">verletSquare/index.js</figcaption></figure><p id="c02c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个实际操作的演示(使用箭头键):</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lj li l"/></div></figure><p id="24b1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">源代码:</p><div class="lk ll fm fo lm ln"><a href="https://github.com/raduGaspar/game-physx/tree/0c8966fc40832b9a5540c5b5301e00237a699358" rel="noopener  ugc nofollow" target="_blank"><div class="lo ab ej"><div class="lp ab lq cl cj lr"><h2 class="bd hv fv z el ls eo ep lt er et ht dt translated">红景天/游戏-physx</h2><div class="lu l"><h3 class="bd b fv z el ls eo ep lt er et ek translated">一个用于JavaScript游戏制作的小工具</h3></div><div class="lv l"><p class="bd b gc z el ls eo ep lt er et ek translated">github.com</p></div></div><div class="lw l"><div class="lx l ly lz ma lw mb ka ln"/></div></div></a></div><p id="2997" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此时你可能会想:<em class="kc">难道我们没有给代码增加更多的复杂性吗？是的，复杂性正在增加；有些是无法避免的，有些是由于我们的MVC方法。</em></p><p id="f4e3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一如既往，这里需要改进；首先，在模型上添加场景引用的方式是次优的，我们在控制器中也有代码复制，在MVC中有相当多的逻辑。</p><p id="ec04" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">随着这些文章的进展，我们将慢慢地从MVC转向一个流动的架构，但是总的来说，我们确实学到了更多关于游戏中运动是如何工作的。</p><p id="faf8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下一次我们将创建一个<strong class="it hv"> DisplayObject </strong>类并覆盖:精灵表、精灵、动画精灵和帧率控制。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mc li l"/></div></figure></div></div>    
</body>
</html>