<html>
<head>
<title>Generics on Go’s stdlib</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go标准库中的泛型</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/generics-on-gos-stdlib-10de52fe824d?source=collection_archive---------3-----------------------#2017-07-29">https://medium.com/hackernoon/generics-on-gos-stdlib-10de52fe824d?source=collection_archive---------3-----------------------#2017-07-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="1505" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以最近<a class="ae jp" href="https://twitter.com/_rsc?lang=en" rel="noopener ugc nofollow" target="_blank"> Russ Cox </a>在<a class="ae jp" href="https://www.youtube.com/playlist?list=PL2ntRZ1ySWBdD9bru6IR-_WXUgJqvrtx9" rel="noopener ugc nofollow" target="_blank"> Gophercon </a>做了一个关于<em class="jq"> " </em> <a class="ae jp" href="https://www.youtube.com/watch?v=0Zbh_vmAKvk&amp;index=4&amp;list=PL2ntRZ1ySWBdD9bru6IR-_WXUgJqvrtx9" rel="noopener ugc nofollow" target="_blank"> <em class="jq">围棋的未来</em> </a> <em class="jq">"，</em>的演讲，他提到为了在围棋中获得<strong class="it hv"> X </strong>的特性，我们必须首先展示足够多的<em class="jq">例子</em>来说明为什么<em class="jq"> </em> <strong class="it hv"> Y </strong>是一个问题，这样才能引起围棋团队的注意，帮助他们理解我们的 我们需要让他们相信Y<strong class="it hv">Y</strong>是一个真实的问题，X 可能是最好的解决方案。</p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div class="fe ff jr"><img src="../Images/35415ccacd5e3f43cb7d13aa55d78500.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*fE2_Yx5OzvQ6JrSvb5XhQA.gif"/></div><figcaption class="jz ka fg fe ff kb kc bd b be z ek">So . . . now what??</figcaption></figure><p id="1355" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了实现这一点，我们需要创建所谓的<a class="ae jp" href="https://github.com/golang/go/wiki/ExperienceReports" rel="noopener ugc nofollow" target="_blank">体验报告</a>，基本上是关于上述内容的帖子。所以我们在这里。</p><p id="aa1b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，我想指出的是，这篇文章并没有<strong class="it hv">而不是</strong>涵盖任何具体的实现示例，而是简单地看了一下<a class="ae jp" href="https://hackernoon.com/tagged/stdlib" rel="noopener ugc nofollow" target="_blank"> stdlib </a>的一些pkg如果实现了类似泛型的东西可能会是什么样子。</p></div><div class="ab cl kd ke hc kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hn ho hp hq hr"><h1 id="80aa" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">问题是</h1><p id="7187" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">我喜欢把这个问题描述为:</p><p id="25a2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在保持类型安全的同时声明动态行为的泛型/方法的缺乏，迫使用户通过以下任一方式来增加他们的代码库:</p><ul class=""><li id="8f0f" class="ln lo hu it b iu iv iy iz jc lp jg lq jk lr jo ls lt lu lv dt translated">代码生成<a class="ae jp" href="https://hackernoon.com/tagged/tools" rel="noopener ugc nofollow" target="_blank">工具</a>的使用只会让最终用户更加难以阅读代码，并且由于各种函数的名称相似而不是只有一个，会造成混淆。—为了类型安全而牺牲代码可读性和API复杂性—</li><li id="5c02" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo ls lt lu lv dt translated">使用<strong class="it hv">接口{} </strong> <em class="jq">(空接口)</em>来避免大量名称相似但几乎处处以类型转换/断言为代价的函数。—为了可读性和减少用户API而牺牲类型安全—</li></ul><p id="fee6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这两种情况下，我们使用的代码实际上并不属于应用程序的核心逻辑，而是像胶水一样，几乎每个项目都需要它。</p></div><div class="ab cl kd ke hc kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hn ho hp hq hr"><h2 id="5514" class="mb kl hu bd km mc md me kq mf mg mh ku jc mi mj ky jg mk ml lc jk mm mn lg mo dt translated">一个小例子</h2><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="5937" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我知道你在想什么，<em class="jq">“这不是来自stdlib……”</em>等一下，这是来自<a class="ae jp" href="https://github.com/bwmarrin/discordgo" rel="noopener ugc nofollow" target="_blank"> discordgo </a> pkg，它是上面第二个<em class="jq">案例</em>的完美例子。如果我们深入研究处理那个<strong class="it hv">处理程序</strong>变量的代码，我们会遇到类似这样的情况…</p><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="5da0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不太漂亮，对吧？还有<strong class="it hv"> 37 </strong> <strong class="it hv">更多的情况</strong>到<em class="jq">仅仅是</em>处理一个<strong class="it hv">单变量</strong>，而且仅仅是为了记住，这里pkg维护者决定公开1个函数，并把类型检查的<em class="jq">艰苦工作</em>留给他们自己，而不是向用户公开<strong class="it hv"> 44个具有相似名称</strong>的不同函数。所有这些都是为了添加一个简单的处理程序。</p></div><div class="ab cl kd ke hc kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hn ho hp hq hr"><h1 id="0b68" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">标准库</h1><p id="e61b" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">在stdlib中，你可以找到一些pkg，当且仅当存在类似于Go的泛型时，它们可以极大地减少它们的API，例如:</p><h2 id="c5fc" class="mb kl hu bd km mc md me kq mf mg mh ku jc mi mj ky jg mk ml lc jk mm mn lg mo dt translated"><a class="ae jp" href="https://golang.org/pkg/sync/atomic/" rel="noopener ugc nofollow" target="_blank">同步/原子</a></h2><p id="bc70" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">包含29个名为<em class="jq">Add</em><strong class="it hv"><em class="jq">T</em></strong>，<em class="jq">CompareAndSwap</em><strong class="it hv"><em class="jq">T</em></strong>的pkg函数，其中<strong class="it hv"> T </strong>可以是<em class="jq"> Int32 </em>，<em class="jq"> Int64 </em>，<em class="jq"> Uint32 </em>，<em class="jq"> Uint64 </em>等等。。。</p><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="f4ce" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">几乎可以说整个pkg API应该是:</p><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="6a9f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">刚刚从29个名字较大的函数<strong class="it hv">变成了5个名字较短的函数</strong>。</p><h2 id="19c3" class="mb kl hu bd km mc md me kq mf mg mh ku jc mi mj ky jg mk ml lc jk mm mn lg mo dt translated"><a class="ae jp" href="https://godoc.org/golang.org/x/sync/syncmap" rel="noopener ugc nofollow" target="_blank">同步。地图(Go 1.9+) </a></h2><p id="e329" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">是的，这个令人敬畏的并发地图即将到来！到处都有<strong class="it hv">接口{ T53 }。。。</strong></p><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="58eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这种情况下，<em class="jq">唯一的</em>好处是类型安全，因为API足够简单。</p><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="mp mq l"/></div></figure><h2 id="798a" class="mb kl hu bd km mc md me kq mf mg mh ku jc mi mj ky jg mk ml lc jk mm mn lg mo dt translated"><a class="ae jp" href="https://golang.org/pkg/math/rand/" rel="noopener ugc nofollow" target="_blank">数学/随机</a></h2><p id="aec4" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">非常类似于<em class="jq">同步/原子</em>的情况，而不是<em class="jq"> Int，Intn，Int31，Int31n </em>呢:</p><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="fec8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样的待遇也适用于<a class="ae jp" href="https://golang.org/pkg/math/rand/#Rand" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">兰特。兰德</strong>型</a>型。</p><h2 id="918c" class="mb kl hu bd km mc md me kq mf mg mh ku jc mi mj ky jg mk ml lc jk mm mn lg mo dt translated"><a class="ae jp" href="https://golang.org/pkg/math/big/" rel="noopener ugc nofollow" target="_blank">数学/大</a></h2><p id="c4bb" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">也许可以将<strong class="it hv"> Float </strong>、<strong class="it hv"> Int </strong>和<strong class="it hv"> Rat </strong>类型转换为通用<strong class="it hv"> Number </strong>类型，并根据泛型计算运算。</p><p id="ee2e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">其他一些适用的情况有:</p><ul class=""><li id="6662" class="ln lo hu it b iu iv iy iz jc lp jg lq jk lr jo ls lt lu lv dt translated"><a class="ae jp" href="https://golang.org/pkg/container/list/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">集装箱/清单</strong> </a></li><li id="e514" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo ls lt lu lv dt translated"><a class="ae jp" href="https://golang.org/pkg/container/heap/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">容器/堆</strong> </a></li><li id="1ba3" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo ls lt lu lv dt translated"><a class="ae jp" href="https://golang.org/pkg/container/ring/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">容器/环</strong> </a></li><li id="0fd6" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo ls lt lu lv dt translated">可能更多，只是还没有做足够的研究</li></ul><p id="2882" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我还认为，比如说，我们有一段非常普通的代码:</p><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="9b8e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我相信如果有泛型，这种操作可以在编译时得到改进/优化，因为编译器<em class="jq">知道</em>数据的格式是什么样子。下面的例子。</p><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="0388" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样适用于所有编码/解码内容，例如<a class="ae jp" href="https://golang.org/pkg/encoding/xml/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">编码/xml </strong> </a>，<a class="ae jp" href="https://golang.org/pkg/encoding/csv/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">编码/csv </strong> </a>不包括在内，因为所有记录总是在<strong class="it hv">[][][]字符串</strong>中返回，这意味着根本没有反射/类型断言。</p></div><div class="ab cl kd ke hc kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hn ho hp hq hr"><p id="5401" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我想说的是，在泛型的帮助下，stdlib <strong class="it hv">可以</strong>在许多地方被缩减和简化，当然第三方pkg也是如此。我希望这篇文章至少可以作为一个清晰的例子来说明泛型可以做些什么。</p><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="mr mq l"/></div></figure></div></div>    
</body>
</html>