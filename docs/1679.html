<html>
<head>
<title>What’s new in Git 2.11?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git 2.11有什么新特性？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/whats-new-in-git-2-11-64860aea6c4f?source=collection_archive---------0-----------------------#2016-11-29">https://medium.com/hackernoon/whats-new-in-git-2-11-64860aea6c4f?source=collection_archive---------0-----------------------#2016-11-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="ff94" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">事实证明，很多！Git 2.11已经发布了一系列的新特性和可用性改进，特别是对于那些从事具有深层历史、大文件或子模块的项目的人。以下是激起我们对Bitbucket团队兴趣的精彩内容:</p><ul class=""><li id="a489" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated"><a class="ae jp" href="#bac5" rel="noopener ugc nofollow">自动调整大小的SHA-1缩写</a></li><li id="76ac" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated"><a class="ae jp" href="#a3a3" rel="noopener ugc nofollow">子模块的替换</a></li><li id="c6b8" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated"><a class="ae jp" href="#4229" rel="noopener ugc nofollow">子模块差异</a></li><li id="0fc3" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated"><a class="ae jp" href="#42f1" rel="noopener ugc nofollow"> git ls文件递归子模块</a></li><li id="2e9c" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated"><a class="ae jp" href="#892c" rel="noopener ugc nofollow">实验差异改进</a></li><li id="7103" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated"><a class="ae jp" href="#03fe" rel="noopener ugc nofollow">更简单的藏匿id</a></li><li id="1433" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated"><a class="ae jp" href="#ae8d" rel="noopener ugc nofollow">长时间运行的过滤程序</a></li><li id="00a3" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated"><a class="ae jp" href="#470c" rel="noopener ugc nofollow"> git目录文件过滤器</a></li><li id="e465" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated"><a class="ae jp" href="#367e" rel="noopener ugc nofollow"> receive.maxInputSize </a></li><li id="7526" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated"><a class="ae jp" href="#5104" rel="noopener ugc nofollow">合并比较速记</a></li></ul><h1 id="bac5" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">自动调整大小的SHA-1缩写</h1><p id="cc2d" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">Git使用SHA-1散列，通常显示为丑陋的大十六进制字符串，来唯一地标识提交和其他对象。当开发人员从<em class="lh">集中式</em>版本控制(单调递增的id很容易，因为它们是集中生成的)切换到<em class="lh">分布式</em>版本控制(每个贡献者生成他们自己的id)时,“如果两个不同的对象创建相同的散列，会发生什么？!"有时会出现。幸运的是，阿沙1号相撞的可能性微乎其微。《Pro Git》一书的作者斯科特·沙孔说得好:</p><blockquote class="li"><p id="b547" class="lj lk hu bd ll lm ln lo lp lq lr jo ek translated"><em class="ls">如果地球上所有65亿人都在</em> <a class="ae jp" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank"> <em class="ls">编程</em> </a> <em class="ls">，并且每一秒钟，每个人都在产生相当于整个Linux内核历史(360万个g it对象)的代码，并将其推入一个巨大的Git存储库，那么大约需要2年时间，该存储库才会包含足够多的对象，以使单个SHA-1对象发生冲突的概率达到50%。你的编程团队的每一个成员在同一个晚上被狼袭击并杀死的可能性更高。</em></p></blockquote><p id="be15" class="pw-post-body-paragraph ir is hu it b iu lt iw ix iy lu ja jb jc lv je jf jg lw ji jj jk lx jm jn jo hn dt translated">然而，为了节省终端空间，在Git 2.10之前，许多常见命令都将sha缩写为hash的前7个六位数。</p><figure class="lz ma mb mc fq md fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff ly"><img src="../Images/2e995c8d5ba0c1d38fff8f996db32458.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*edT_J5WHiYaMAMCQBGU-hA.png"/></div></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">Abbreviated SHAs</figcaption></figure><p id="d080" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这可能是一个问题，因为缩写的sha太短，最终可能会失去它们的唯一性。我说<em class="lh">最终</em>是因为Git将总是输出足够的字符，以确保缩写的SHA在命令运行时是唯一的。但是，如果您在提交消息、电子邮件或另一个外部系统中记录了一个简短的SHA，那么当您在将来某个时候将它复制并粘贴回针对存储库运行的Git命令时，它可能不再是惟一的。</p><p id="6c5f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">将40个十六进制数缩写为7会将可能sha的数量从难以想象的大<strong class="it hv"> 1.46 x 10⁴⁸ </strong>减少到仍然相当大的<strong class="it hv"> 268，435，456 </strong>。然而，Git创建了一个<em class="lh"> lot </em>对象，每个对象都需要自己的SHA-1:每个提交和带注释的标签一个，每个文件的每个版本一个，每个树对象一个(每次创建目录或目录内容改变时都会创建一个)。更糟糕的是,<a class="ae jp" href="https://betterexplained.com/articles/understanding-the-birthday-paradox/" rel="noopener ugc nofollow" target="_blank">生日悖论</a>意味着你只需要相对较少数量的物品——实际上只有<strong class="it hv"> 19，290个】—就有50%的机会让其中两个拥有相同的前7位六位数。</strong></p><p id="9a4d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Git 2.11引入了一个新特性，SHA缩写长度是根据对存储库中对象数量的估计来计算的。Linux内核刚刚在其Git存储库中传递了500万个对象，在Git 2.11下默认为12个十六进制数字:</p><figure class="lz ma mb mc fq md fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff mo"><img src="../Images/9d81291e29a82d7db50c1e483d787a6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*si1iN2vS4mtqCk1V9P3BNQ.png"/></div></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">linux.git</figcaption></figure><p id="3425" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Git自己的存储库有220，000多个对象，默认为9个十六进制数字:</p><figure class="lz ma mb mc fq md fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff mo"><img src="../Images/53dfa7557970b422e7532ecc03c4f5e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gk2I1tVsCTqeVLpm-QnXQQ.png"/></div></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">git.git</figcaption></figure><p id="9d56" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您习惯为自己的项目记录简短的SHA，您可能希望通过手动覆盖SHA缩写长度来证明自己:</p><pre class="lz ma mb mc fq mp mq mr ms aw mt dt"><span id="9405" class="mu kf hu mq b fv mv mw l mx my">$ git config --global core.abbrev 12</span></pre><p id="0703" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另外，Git 2.11还学会了列出由缩写的SHA引用的冲突对象:</p><figure class="lz ma mb mc fq md fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff mo"><img src="../Images/7caa73746ef12a51d442e531971414b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mNbX3ind_JBYwavKYxqFPw.png"/></div></div></figure><p id="3545" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，如果您不幸遇到含糊不清的缩写SHA-1，Git现在会为您提供足够的信息，让您自己解决这个歧义。</p><h1 id="a64a" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">子模块，子模块，子模块</h1><p id="998a" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">Git子模块在最近的Git版本中得到了大量的改进:</p><ul class=""><li id="ce9d" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">Git 2.8中的并行获取</li><li id="f2f4" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">在Git 2.9中</li><li id="9ef2" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated"><code class="eh mz na nb mq b">.gitmodules</code>2.10中的“浅”标志</li></ul><p id="0291" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我仍然建议将子模块作为最后的手段，因为依赖管理系统对于组合项目通常更有效。然而，Git 2.11确实有三个显著的改进，如果您确实需要子模块，它们会变得更容易使用。如果您对子模块不感兴趣，请随意跳到关于 <code class="eh mz na nb mq b"><a class="ae jp" href="#892c" rel="noopener ugc nofollow">git diff</a></code> <a class="ae jp" href="#892c" rel="noopener ugc nofollow">改进</a>的<a class="ae jp" href="#892c" rel="noopener ugc nofollow">部分。</a></p><h2 id="a3a3" class="mu kf hu bd kg nc nd ne kk nf ng nh ko jc ni nj ks jg nk nl kw jk nm nn la no dt translated">子模块的替代</h2><p id="3622" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated"><code class="eh mz na nb mq b">--reference</code>选项可以与<code class="eh mz na nb mq b">git clone</code>一起使用，指定另一个本地存储库作为“备用”对象存储，以保存通过网络重新复制的对象，而这些对象是您已经在本地拥有的。语法是:</p><pre class="lz ma mb mc fq mp mq mr ms aw mt dt"><span id="cfad" class="mu kf hu mq b fv mv mw l mx my">$ git clone --reference &lt;local repo&gt; &lt;url&gt;</span></pre><p id="6c47" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从Git 2.11开始，您可以结合使用<code class="eh mz na nb mq b">--reference</code>和<code class="eh mz na nb mq b">--recurse-submodules</code>来设置<em class="lh">子模块</em>替换，指向另一个本地存储库中的子模块。语法是:</p><pre class="lz ma mb mc fq mp mq mr ms aw mt dt"><span id="33bf" class="mu kf hu mq b fv mv mw l mx my">$ git clone --recurse-submodules --reference &lt;local repo&gt; &lt;url&gt;</span></pre><p id="1f67" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这可能会节省大量的带宽和本地磁盘，但是如果引用的本地存储库没有您要从中克隆的远程存储库的所有必需的子模块，这将会失败。</p><p id="e28c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">幸运的是，方便的<code class="eh mz na nb mq b">--reference-if-able</code>选项会优雅地失败，并且对于引用的本地存储库中缺失的任何子模块，会退回到正常的克隆:</p><pre class="lz ma mb mc fq mp mq mr ms aw mt dt"><span id="0a26" class="mu kf hu mq b fv mv mw l mx my">$ git clone --recurse-submodules --reference-if-able &lt;local repo&gt; &lt;url&gt;</span></pre><h2 id="4229" class="mu kf hu bd kg nc nd ne kk nf ng nh ko jc ni nj ks jg nk nl kw jk nm nn la no dt translated">子模块差异</h2><p id="5bd7" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">以前，Git有两种模式来显示更新存储库子模块的提交差异:</p><ul class=""><li id="55ce" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated"><code class="eh mz na nb mq b">git diff --submodule=short</code>显示您的项目所引用的子模块中的旧提交和新提交(如果您完全省略了<code class="eh mz na nb mq b">--submodule</code>选项，这也是默认设置):</li></ul><figure class="lz ma mb mc fq md fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff mo"><img src="../Images/36e5daeec6b59134f13111b1d45bb7f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uo87yhai505Ku3IG53q11A.png"/></div></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">git diff --submodule=short</figcaption></figure><ul class=""><li id="2ce8" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated"><code class="eh mz na nb mq b">git diff --submodule=log</code>更有用一些，它在更新的子模块中显示任何新的或删除的提交的提交消息的摘要行:</li></ul><figure class="lz ma mb mc fq md fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff mo"><img src="../Images/4fd62b584a961218ab88028db8a46aba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XyJBKsVutjFJM_qiYHqdgw.png"/></div></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">git diff --submodule=log</figcaption></figure><ul class=""><li id="e355" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">Git 2.11引入了第三个选项:<code class="eh mz na nb mq b">--submodule=diff</code>。这将显示更新的子模块中所有更改的完整差异:</li></ul><figure class="lz ma mb mc fq md fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff mo"><img src="../Images/30ec3684b11cf0b27ca851f5acba406f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JN5UFgKg8L47k3HNz54Ifg.png"/></div></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">git diff --submodule=diff</figcaption></figure><h2 id="42f1" class="mu kf hu bd kg nc nd ne kk nf ng nh ko jc ni nj ks jg nk nl kw jk nm nn la no dt translated">git ls-文件-递归-子模块</h2><p id="3634" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated"><code class="eh mz na nb mq b">git ls-files</code>学习了<code class="eh mz na nb mq b">--recurse-submodules</code>选项。传统上<code class="eh mz na nb mq b">git ls-files</code>会列出存储库中被跟踪的文件，从Git 2.11开始，也可以列出子模块跟踪的文件:</p><figure class="lz ma mb mc fq md fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff mo"><img src="../Images/89e503f6e021699828bfda8dc5c6a88d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0DVzQGCkRsX5bbPLl5Q-WA.png"/></div></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">git ls-file --recurse-submodules</figcaption></figure><p id="040c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这可能不是您每天都要运行的命令，但是如果您想要编写一个脚本来遍历您的存储库<em class="lh">及其子模块</em>中的每个文件，这是很方便的。</p><h1 id="892c" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">实验差异改进</h1><p id="bf0d" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated"><code class="eh mz na nb mq b">git diff</code>当修改部分前后的行相同时，可能会产生一些稍微令人困惑的输出。当一个文件中有两个或更多结构相似的函数时，就会发生这种情况。对于一个稍显做作的例子，假设我们有一个包含单一函数的简单文件:</p><pre class="lz ma mb mc fq mp mq mr ms aw mt dt"><span id="ddaa" class="mu kf hu mq b fv mv mw l mx my">/* @return {string} "Bitbucket" */<br/>function productName() {<br/>	return "Bitbucket";<br/>}</span></pre><p id="83df" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，假设我们已经提交了一个变更，在<em class="lh">前添加了另一个</em>函数，该函数具有类似的功能:</p><pre class="lz ma mb mc fq mp mq mr ms aw mt dt"><span id="7d55" class="mu kf hu mq b fv mv mw l mx my">/* @return {string} "Bitbucket" */<br/>function productId() {<br/>	return "Bitbucket";<br/>}</span><span id="ed8a" class="mu kf hu mq b fv np mw l mx my">/* @return {string} "Bitbucket" */<br/>function productName() {<br/>	return "Bitbucket";<br/>}</span></pre><p id="d1d1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可能希望<code class="eh mz na nb mq b">git diff</code>显示添加的前五行，但是它实际上错误地将第一行归于原始提交:</p><figure class="lz ma mb mc fq md fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff mo"><img src="../Images/87ec23c75410024aad135d09ee6eef06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BxSK_m_UIPxxuWoFk0fDwA.png"/></div></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">The wrong comment is included in the diff.</figcaption></figure><p id="b37d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不是世界末日，而是来自<em class="lh"> whaaat的几秒认知开销？</em>每次发生这种情况都会累加起来。</p><p id="e7a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Git 2.11引入了一个新的实验性差异选项<code class="eh mz na nb mq b">--indent-heuristic</code>，试图产生更具美感的差异:</p><figure class="lz ma mb mc fq md fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff mo"><img src="../Images/6c24584abc297aa967c7d20a085ef639.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yzbMGJpcKdpzWCrTLehWjA.png"/></div></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">git diff --indent-heuristic</figcaption></figure><p id="c3d5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在引擎盖下，<code class="eh mz na nb mq b">--indent-heuristic</code>循环遍历每个变更的可能差异，并给每个差异分配一个“坏”分数。这是基于试探法的，比如diff块是否以不同级别的缩进开始和结束(这在美学上是不好的)，以及diff块是否有前导和尾随空行(这在美学上是令人愉快的)。则输出具有最低不良分数的块。</p><p id="d821" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个特性是实验性的，但是您可以通过将<code class="eh mz na nb mq b">--indent-heuristic</code>选项应用到任何<code class="eh mz na nb mq b">git diff</code>命令来测试它。或者，如果您喜欢生活在危险边缘，您可以通过以下方式在您的系统中启用它:</p><pre class="lz ma mb mc fq mp mq mr ms aw mt dt"><span id="f95c" class="mu kf hu mq b fv mv mw l mx my">$ git config --global diff.indentHeuristic true</span></pre><h1 id="03fe" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">更简单的隐藏id</h1><p id="ffef" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated"><code class="eh mz na nb mq b"><a class="ae jp" href="https://www.atlassian.com/git/tutorials/git-stash/" rel="noopener ugc nofollow" target="_blank">git stash</a></code>命令是一个漂亮的小工具，可以在你做其他事情的时候暂时搁置变更。如果你是一个粉丝，你可能知道你可以搁置多个变更，用<code class="eh mz na nb mq b">git stash list</code>查看它们:</p><figure class="lz ma mb mc fq md fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff mo"><img src="../Images/c6d8261075c79d4504ebab9216f203bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gCbJCzaTsR1REM-JgTp86g.png"/></div></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">git stash list</figcaption></figure><p id="eb3f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，您可能不知道为什么Git的存储库有如此笨拙的标识符— <code class="eh mz na nb mq b">stash@{1}</code>、<code class="eh mz na nb mq b">stash@{2}</code>等等。——可能已经把它们当作“Git的一种癖好”而一笔勾销了。事实证明，像许多Git特性一样，这些奇怪的id实际上是Git数据模型的一种非常巧妙的使用(或滥用)的症状。</p><p id="dbb6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在幕后，<code class="eh mz na nb mq b">git stash</code>命令实际上创建了一组特殊的提交对象，这些对象对您隐藏的更改进行编码，并维护一个<a class="ae jp" href="https://www.atlassian.com/git/tutorials/refs-and-the-reflog/" rel="noopener ugc nofollow" target="_blank"> reflog </a>来保存对这些特殊提交的引用。这就是为什么<code class="eh mz na nb mq b">git stash list</code>的输出看起来很像<code class="eh mz na nb mq b">git reflog</code>命令的输出。当您运行<code class="eh mz na nb mq b">git stash apply stash@{1}</code>时，您实际上是在说“从stash reflog在位置1应用提交”。</p><p id="6d47" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从Git 2.11开始，您不再需要使用完整的<code class="eh mz na nb mq b">git stash@{n}</code>语法。相反，您可以用一个简单的整数来引用stash，该整数表示它们在stash reflog中的位置:</p><pre class="lz ma mb mc fq mp mq mr ms aw mt dt"><span id="7dfc" class="mu kf hu mq b fv mv mw l mx my">$ git stash show 1<br/>$ git stash apply 1<br/>$ git stash pop 1</span></pre><p id="a39b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">诸如此类。如果你想了解更多关于stash是如何存储的，我在<a class="ae jp" href="https://www.atlassian.com/git/tutorials/git-stash/#how-git-stash-works" rel="noopener ugc nofollow" target="_blank">git stash如何工作</a>中写了一点。</p><h1 id="ae8d" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">长时间运行的过滤过程</h1><p id="0d71" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">Bitbucket支持流行的<a class="ae jp" href="https://www.atlassian.com/git/tutorials/git-lfs/" rel="noopener ugc nofollow" target="_blank"> Git LFS(大文件存储)</a>扩展，以帮助需要有效跟踪其存储库中大型二进制文件的用户。Git 2.11带来了一些改进，使得Git LFS变得更快更好用。最重要的变化是Git现在支持长时间运行的清洁和涂抹过滤过程来转换LFS指针，而不是每次都必须调用一个新的过程。</p><p id="564b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当您<code class="eh mz na nb mq b">git add</code>一个文件时，<em class="lh"> clean filters </em>可用于在将文件内容写入Git对象存储之前转换(或<em class="lh"> clean </em>)文件内容。Git LFS通过使用一个干净的过滤器将大文件内容存放在LFS缓存中，并向Git对象存储中添加一个微小的“指针”文件，从而减小了存储库的大小。</p><figure class="lz ma mb mc fq md fe ff paragraph-image"><div class="fe ff nq"><img src="../Images/94a82fbc9e74431f16c1b0f3568988ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*8TnaRfwAaular_r2fJfJ6A.png"/></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">The Git LFS <em class="ls">clean</em> filter converts large files into tiny pointer files.</figcaption></figure><p id="fd35" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="lh">涂抹滤镜</em>与清洁滤镜相反——因此得名。当在<code class="eh mz na nb mq b">git checkout</code>期间从Git对象存储中读取文件内容时，涂抹过滤器有机会在它被写入用户的工作副本之前转换它。Git LFS涂抹滤镜通过将指针文件替换为相应的大文件来转换指针文件，这些大文件可以来自LFS缓存，也可以直接读取到Bitbucket上的Git LFS存储中。</p><figure class="lz ma mb mc fq md fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff nr"><img src="../Images/7d67084fd5d826ef0e655350304330de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*coJEDZaEa3p9-ZElDZ7UUA.png"/></div></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">The Git LFS <em class="ls">smudge</em> filter converts pointer files back into the large file content.</figcaption></figure><p id="031e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">传统上，对于正在添加或签出的每个文件,涂抹和清洁过滤过程被调用一次<em class="lh">。因此，一个用Git LFS跟踪了1000个文件的项目调用了1000次<code class="eh mz na nb mq b">git-lfs-smudge</code>命令来进行新的签出！虽然每个操作相对较快，但旋转1000个单独的涂抹过程的开销是昂贵的。</em></p><p id="4ca1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从Git 2.11开始，涂抹和清理过滤器可以定义为长时间运行的进程，对第一个过滤的文件调用一次，然后馈送需要涂抹或清理的后续文件，直到父Git操作退出。为Git贡献了长期运行过滤器的Lars Schneider很好地总结了这种变化对Git LFS性能的影响:</p><blockquote class="ns nt nu"><p id="cfd0" class="ir is lh it b iu iv iw ix iy iz ja jb nv jd je jf nw jh ji jj nx jl jm jn jo hn dt translated"><em class="hu">过滤过程是💥</em> <strong class="it hv"> <em class="hu">快80倍</em> </strong> <em class="hu">💥</em> <strong class="it hv"> <em class="hu">在macOS上</em> </strong> <em class="hu">和💥</em> <strong class="it hv"> <em class="hu">快58x</em></strong><em class="hu">💥</em><strong class="it hv"><em class="hu">Windows上的</em> </strong> <em class="hu">为测试回购用12k文件。在Windows上，这意味着测试运行在</em> <strong class="it hv"> <em class="hu"> 57秒，而不是55分钟</em> </strong> <em class="hu">！</em></p></blockquote><p id="6509" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个令人印象深刻的性能提升！注意，你需要升级到Git 2.11 <strong class="it hv">和</strong> Git LFS 1.5来利用这些速度的提升。</p><h1 id="470c" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">git目录文件过滤器</h1><p id="4bec" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">对于Git LFS和其他基于过滤器的扩展的用户来说，另一个小的改进是针对<code class="eh mz na nb mq b">git cat-file</code>命令的新的<code class="eh mz na nb mq b">--filters</code>选项。<code class="eh mz na nb mq b">git cat-file -p</code>让您检查您的Git对象存储中的对象(<code class="eh mz na nb mq b">-p</code>表示“漂亮的打印”)。例如，我可以用以下命令查看分支<code class="eh mz na nb mq b">v2</code>上的文件<code class="eh mz na nb mq b">images/bitbucket.png</code>的内容:</p><figure class="lz ma mb mc fq md fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff mo"><img src="../Images/2740ac75bf3aa43c765bfa2b24ca3b14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xf6rdPHJxaugH8AjSoWYkQ.png"/></div></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">The contents of a Git LFS pointer file, courtesy of git cat-file -p</figcaption></figure><p id="3ebe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，<code class="eh mz na nb mq b">bitbucket.png</code>碰巧被Git LFS跟踪，而<code class="eh mz na nb mq b">git cat-file</code>跳过了Git LFS涂抹滤镜(以及我们定义的任何其他滤镜)，所以我们没有得到我们的图像，而是得到了Git LFS指针文件的内容。</p><p id="1afb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从Git 2.11开始，您可以确保使用<code class="eh mz na nb mq b">--filters</code>选项应用适当的过滤器。对于Git LFS文件，这将取消对指针的引用并查找实际内容，通常会在您的终端上打印出大量的二进制垃圾:</p><figure class="lz ma mb mc fq md fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff mo"><img src="../Images/8e4e57beca3c1292689dceaa28035747.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V7BB0rv1B1nE14PPeOfJGA.png"/></div></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">The actual LFS file content, courtesy of git cat-file --filters</figcaption></figure><p id="6c77" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于二进制内容，通常最好将内容通过管道传输到一个临时文件，而不是您的终端。或者，如果你在macOS上，你可以用<code class="eh mz na nb mq b">open -a &lt;app&gt; -f:</code>一步到位直接把它传送到一个合适的编辑器</p><figure class="lz ma mb mc fq md fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff mo"><img src="../Images/d975dcd34d35ff3279c4439a84c85864.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SdbzauOiSQai2lA6VYtjBg.png"/></div></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">git cat-file --filters &lt;commit-ish&gt;:&lt;path&gt; | open -a Preview.app -f</figcaption></figure><p id="6466" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者，Atlassian的免费Git客户端<a class="ae jp" href="https://www.sourcetreeapp.com/" rel="noopener ugc nofollow" target="_blank"> SourceTree </a>对Git LFS有极好的支持，包括LFS追踪内容的二进制预览。我不会轻易使用术语<em class="lh">卓越</em>:source tree的创始开发者Steve“Sinbad”Streeting也碰巧为Git LFS项目贡献了31 KLOC。</p><h1 id="367e" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">receive.maxInputSize</h1><p id="2ee9" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">Git 2.11还引入了一个服务器端设置，用于限制单次推送可以传输的字节数。这对于想要防止用户意外将大型二进制文件(使用Git LFS可以更好地跟踪)推送到上游存储库的回购管理员来说非常方便。如果您正在运行自己开发的Git服务器或者手动管理您的服务器配置，那么<code class="eh mz na nb mq b">receive.maxInputSize</code>设置非常有用。在您的Git服务器<em class="lh"> </em> 上运行以下命令<strong class="it hv">会将推送大小限制为10mb:</strong></p><pre class="lz ma mb mc fq mp mq mr ms aw mt dt"><span id="d665" class="mu kf hu mq b fv mv mw l mx my">$ git config --global receive.maxInputSize 10485760</span></pre><p id="5853" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你正在使用Bitbucket Server，我建议你使用一个类似于<a class="ae jp" href="https://scriptrunner.adaptavist.com/4.3.0/bitbucket/PreReceiveHooks.html#_restrict_file_size" rel="noopener ugc nofollow" target="_blank"> ScriptRunner </a>的预接收挂钩插件来约束推送。<a class="ae jp" href="https://confluence.atlassian.com/bitbucketserver/using-repository-hooks-776639836.html" rel="noopener ugc nofollow" target="_blank"> Bitbucket hook API </a>在文件大小和类型、命名约定和强制提交来源等方面为您提供了更大的灵活性，而不仅仅是限制推送的总字节数。</p><h1 id="5104" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">合并比较速记</h1><p id="e77d" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">Git有一堆遍历提交历史的简洁简写。显示合并提交中合并的变更的一个常用命令是:</p><pre class="lz ma mb mc fq mp mq mr ms aw mt dt"><span id="7ee6" class="mu kf hu mq b fv mv mw l mx my">$ git log &lt;merge commit&gt;^..&lt;merge commit&gt;</span></pre><p id="46c9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">大致意思是:</p><blockquote class="ns nt nu"><p id="cf84" class="ir is lh it b iu iv iw ix iy iz ja jb nv jd je jf nw jh ji jj nx jl jm jn jo hn dt translated"><em class="hu">显示所有与</em> <code class="eh mz na nb mq b"><em class="hu">&lt;merge commit&gt;</em></code> <em class="hu">合并的新提交！</em></p></blockquote><p id="b3d9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">命令中的<code class="eh mz na nb mq b">^</code>表示“的父”,双点语法指定我们感兴趣的是合并提交可到达的提交，而不是第一个父级可到达的<em class="lh">。(合并的第一个父级是执行合并时位于签出分支末端的提交。)</em></p><figure class="lz ma mb mc fq md fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff ny"><img src="../Images/e7cc62135d213eaaf4624e5cad30e4c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BF3xW_uvBLhwr_B985Aanw.png"/></div></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">git log &lt;merge&gt;^..&lt;merge&gt; shows the commits merged into the target branch by &lt;merge&gt;</figcaption></figure><p id="e7dd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Git 2.11引入了这种语法的简写:</p><pre class="lz ma mb mc fq mp mq mr ms aw mt dt"><span id="53bf" class="mu kf hu mq b fv mv mw l mx my">$ git log &lt;merge commit&gt;^-1</span></pre><p id="94f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您还可以用<code class="eh mz na nb mq b">^-2</code>替换<code class="eh mz na nb mq b">^-1</code>，将合并提交与其第二个父提交进行比较，以查看不在合并分支上的提交。</p><figure class="lz ma mb mc fq md fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff nz"><img src="../Images/3bca9fe864251da1633169dc4605f3cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WAGWorBTaIUJrMYSI98j9w.png"/></div></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">git log &lt;merge&gt;^-n shows commits from all branches that aren’t the nth parent of &lt;merge&gt;</figcaption></figure><p id="feeb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者，如果您喜欢octopus合并(涉及两个以上父代的合并)，您可以使用<code class="eh mz na nb mq b">^-n</code>与第n个<em class="lh">父代</em>进行比较。</p><p id="b7a2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个新表单可以在任何你可以指定修改范围的地方工作！例如，您可以使用:</p><pre class="lz ma mb mc fq mp mq mr ms aw mt dt"><span id="3649" class="mu kf hu mq b fv mv mw l mx my">$ git diff &lt;merge commit&gt;^-1</span></pre><p id="186b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">生成由合并提交引入的所有更改的差异。</p><h1 id="c4d7" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated"/><p id="8d97" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">你做到了，感谢阅读！这是一篇很长的帖子，但是我们只设法看完了2.11版本中Junio和他的Git向导们发布的100多个特性、修复和性能改进中的10个。查看<a class="ae jp" href="https://git.kernel.org/cgit/git/git.git/tree/Documentation/RelNotes/2.11.0.txt" rel="noopener ugc nofollow" target="_blank">完整的发布说明</a>，然后<a class="ae jp" href="https://www.atlassian.com/git/tutorials/install-git/" rel="noopener ugc nofollow" target="_blank">安装最新版本的Git </a>(或者使用你喜欢的包管理器升级)。</p><p id="466b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你想聊Git或<a class="ae jp" href="https://bitbucket.org" rel="noopener ugc nofollow" target="_blank"> Bitbucket </a>，在Twitter上找我:我是<a class="ae jp" href="https://twitter.com/kannonboy" rel="noopener ugc nofollow" target="_blank"> @kannonboy </a>。</p><div class="lz ma mb mc fq ab cb"><figure class="oa md ob oc od oe of paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="oa md ob oc od oe of paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="oa md ob oc od oe of paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ns nt nu"><p id="f922" class="ir is lh it b iu iv iw ix iy iz ja jb nv jd je jf nw jh ji jj nx jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是阿妹家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is lh it b iu iv iw ix iy iz ja jb nv jd je jf nw jh ji jj nx jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lz ma mb mc fq md fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff og"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="lz ma mb mc fq md"><div class="bz el l di"><div class="oh oi l"/></div></figure></div></div>    
</body>
</html>