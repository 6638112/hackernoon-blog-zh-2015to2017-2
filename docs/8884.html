<html>
<head>
<title>Laravel on AWS: a reference architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS上的Laravel:参考架构</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/laravel-on-aws-a-reference-architecture-a680755130d0?source=collection_archive---------3-----------------------#2017-12-19">https://medium.com/hackernoon/laravel-on-aws-a-reference-architecture-a680755130d0?source=collection_archive---------3-----------------------#2017-12-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="e23f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">网络、安全、自动扩展和高可用性指南</strong></p><p id="25e1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为您的web应用程序建立持久的<a class="ae jp" href="https://hackernoon.com/tagged/architecture" rel="noopener ugc nofollow" target="_blank">架构</a>并不是一件容易的事情。如果你尝试一边做一边构建，你很快就会厌倦点击AWS控制台。如果您有一个适用于所有项目的架构和可重复的流程，同时确保最大的<a class="ae jp" href="https://hackernoon.com/tagged/security" rel="noopener ugc nofollow" target="_blank">安全性</a>，性能和可用性，会怎么样？下面是您应该如何在AWS上部署Laravel应用程序。</p></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><p id="754f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">莱昂内尔是总部位于伦敦的初创公司Wi5的首席技术官，也是面向未来的工程文化课程  <em class="jx">的作者。你可以在</em><a class="ae jp" href="https://getlionel.com" rel="noopener ugc nofollow" target="_blank"><em class="jx">https://getlionel.com</em></a>上联系他</p></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><p id="2ae2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">我们将如何实施安全性:</strong> <br/> —创建<em class="jx"> VPC子网</em>来部署我们的应用程序。VPC是AWS中您自己的虚拟网络，它允许您设计私有子网，在这些子网中，不能从VPC外部直接访问实例。这是我们将部署web和数据库实例的地方。<br/> —使用临时<em class="jx">堡垒</em>(也称为跳转箱)，当我们需要连接到web和数据库实例时，我们将在我们的公共子网中部署这些堡垒，从而减少攻击面<br/> —使用<em class="jx"> VPC安全组(SGs) </em>，通过将哪些服务器可以相互通信列入白名单来实施防火墙规则。SG是在实例级应用的默认拒绝状态防火墙。<br/> —尽可能避免密码，转而指定<em class="jx"> IAM角色</em>来控制对我们资源的访问，从而简化机密管理。使用EC2的IAM角色消除了在配置文件中存储AWS凭证的需要。角色使用AWS负责轮换的临时安全令牌，因此我们不必担心更新密码。</p><p id="a6d5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">我们将如何实施高可用性:</strong> <br/> —将我们的应用程序实例跨越可用性区域(下面的AZs)。AZ是一个区域内的一个或多个数据中心，它们被设计为与其他AZ中的故障相隔离。通过将资源放置在独立的az中，组织可以保护其应用免受影响单个位置的服务中断<br/> —从弹性负载平衡器为我们的应用提供服务。ELB是一种高度可用的(分布式)服务，它在一个或多个az中的一组EC2实例之间分发流量。ELB支持<em class="jx">健康检查</em>，以确保流量不会被路由到不健康或失败的实例<br/> —在ECS上托管我们的应用，通过<em class="jx"> ECS服务</em>描述在任何给定时间运行的健康应用容器的最小数量。如果一个容器崩溃，ECS服务将启动新的容器。<br/> —将我们的数据库作为一个集群分布在多个az上。RDS允许您将数据库的辅助副本放在另一个AZ中，用于灾难恢复目的。您被分配了一个DNS名称形式的数据库端点，AWS负责将其解析为特定的IP地址。RDS将自动故障转移到备用实例，无需用户干预。<br/>我们最好使用Amazon Aurora，它将在单独的AZ中维护我们数据库的读取副本，如果我们的主实例(或其AZ)失败，Amazon将提升它为主实例。<br/> —最后，我们依靠尽可能多的<em class="jx">分布式服务</em>将故障管理委托给AWS:像S3、SQS、ELB/ALB、ECR和CloudWatch这样的服务旨在实现最大的弹性，而我们不必关心它们运行的实例。</p><figure class="jz ka kb kc fq kd fe ff paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="fe ff jy"><img src="../Images/b7b3ea8674eee54d946e34cb29e1d571.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3auhulC03OvLnVSPeY7tsw.png"/></div></div><figcaption class="kk kl fg fe ff km kn bd b be z ek">Laravel, made highly available with almost a one-click deploy!</figcaption></figure><p id="98d7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">我们将如何为自己构建一个可重复的流程:</strong> <br/>我们将使用Docker、CloudFormation和AWS CLI在新域名上部署一个空的Laravel应用程序。CloudFormation定义了一种模板语言，可用于描述工作负载所需的所有AWS资源。模板被提交给CloudFormation，服务将按照适当的顺序提供和配置这些资源。<br/> Docker容器映像是一个软件的独立的、可执行的包，包括运行它所需的一切。使用AWS CLI，您可以从命令行控制所有服务，并通过脚本实现自动化。<br/>通过将这三者结合起来，我们的基础设施和应用程序配置都可以写成代码，这样就可以进行版本化、分支和文档化。</p><p id="a5a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是我用来在AWS上部署客户的Laravel应用程序的过程。希望这能对你的部署有所帮助。如果您的用例更复杂，我会提供持续的支持包，从指导您的开发人员到亲手在AWS上构建应用程序。在hi@getlionel.com给我打电话</p><p id="73df" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">一步一步来:<br/> 1。设置您的AWS凭证<br/> </strong>从认证您的命令行开始，在您的AWS控制台的IAM部分为新用户下载API密钥和密码。该用户需要拥有为我们将在下面使用的所有服务创建资源的权限。按照以下提示操作:</p><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div><figcaption class="kk kl fg fe ff km kn bd b be z ek">Use the profile option to save different credentials for different projects</figcaption></figure><p id="b48e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 2。订购SSL证书<br/> </strong>我们需要两个证书:一个用于我们的web应用程序本身，另一个用于我们在CloudFront上的自定义域。web应用程序的证书需要在您希望部署应用程序的AWS区域中创建，而CloudFront只接受在区域<em class="jx"> us-east-1 </em>中生成的证书。<br/> AWS SSL/TLS证书是免费的，自动提供和更新，即使您没有在Route53中购买域名。它们与AWS负载平衡器、CloudFront发行版和API网关端点无缝集成，因此您只需设置它们就可以忘记它们。</p><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="9144" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 3。创建一个供EC2实例使用的密钥对<br/> </strong>建议为这个新项目的所有EC2实例创建一个新的SSH密钥对，仍然使用CLI:</p><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="3123" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请记住，AWS不会为您存储SSH密钥，您有责任安全地存储和共享它们。</p><p id="d236" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 4。启动我们的云构建堆栈<br/> </strong>基础设施即代码来了！我们的整个部署将在一个主YAML模板中描述，该模板本身引用了<em class="jx">嵌套栈</em> YAML模板，以使其更具可读性和可重用性。<br/>这是我们模板的目录结构:</p><pre class="jz ka kb kc fq kq kr ks kt aw ku dt"><span id="e465" class="kv kw hu kr b fv kx ky l kz la">├── master.yaml                <em class="jx"># the root template</em><br/>├── infrastructure<br/>  ├── vpc.yaml                 <em class="jx"># our VPC and security groups<br/></em>  ├── storage.yaml             <em class="jx"># our database cluster and S3 bucket<br/>  </em>├── web.yaml                 <em class="jx"># our ECS cluster<br/>  </em>└── services.yaml            <em class="jx"># our ECS Tasks Definitions &amp; Services</em></span></pre><p id="3c54" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">完整的代码可以从GitHub这里下载:</p><div class="lb lc fm fo ld le"><a href="https://github.com/li0nel/laravelaws" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab ej"><div class="lg ab lh cl cj li"><h2 class="bd hv fv z el lj eo ep lk er et ht dt translated">里昂内尔/拉拉夫劳斯</h2><div class="ll l"><h3 class="bd b fv z el lj eo ep lk er et ek translated">laravelaws——使用CloudFormation在高可用性ECS集群上部署Laravel的参考架构</h3></div><div class="lm l"><p class="bd b gc z el lj eo ep lk er et ek translated">github.com</p></div></div><div class="ln l"><div class="lo l lp lq lr ln ls ki le"/></div></div></a></div><p id="b294" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jx"> vpc.yaml </em>模板定义了我们的<em class="jx"> VPC子网</em>和<em class="jx">路由表</em>:</p><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="787a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这相当冗长，是设置跨越两个az的公共和私有子网所需要的一切。您可以明白为什么您不想在AWS控制台中实现它了！</p><p id="88a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还需要三个SG。第一个是保护我们的EC2实例，只允许来自负载均衡器的入站流量和任何SSH入站流量(请记住，我们的实例将位于私有子网中，无论如何都不能接收来自互联网的流量):</p><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="6637" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">负载平衡器的SG将允许来自互联网的任何流量(同时仅响应HTTP和HTTPS):</p><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="5fba" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，数据库SG只允许MySQL端口上来自EC2实例的入站流量，不允许来自互联网的流量。我们的数据库也将托管在我们的私有子网内，因此它不能接收来自VPC以外的任何流量。</p><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="46b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们启动我们的<em class="jx"> storage.yaml </em>堆栈:</p><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="8bf2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">外加一个公众阅读的S3桶:</p><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="5c64" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jx"> web.yaml </em>堆栈由一个ECS集群和一个实例启动配置组成。LC定义启动时在每个新实例上执行的引导代码，这称为用户数据。我们在这里使用一个第三方Docker凭证助手，它通过将实例的IAM角色转换为安全令牌，向ECR注册中心认证Docker客户机。</p><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div></figure><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div></figure><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div></figure><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="95b5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在更复杂的设置中，我们可以让我们新创建的负载均衡器向Route53注册，这样您的服务在同一个DNS地址总是可用的。这种设计模式被称为<em class="jx">服务发现</em>，在CloudFormation中不可能开箱即用。相反，在下面的步骤7中，我们将手动将域名指向Route53上的负载平衡器。</p><p id="35dd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">与此同时，我们的负载平衡器响应一个HTTP 503错误，因为它在集群池中找不到一个返回正确HTTP状态代码的健康实例。当然，一旦我们在集群中部署了应用程序，这种情况就会改变。</p><figure class="jz ka kb kc fq kd fe ff paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="fe ff lt"><img src="../Images/84c23057f1e5988fe735c88e373aca3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eyATQ9VtJw95F3J-3WS1mg.png"/></div></div><figcaption class="kk kl fg fe ff km kn bd b be z ek">Our load balancer responding but with no healthy container instances behind it</figcaption></figure><p id="e8e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 5。建立并推广您的Laravel Docker形象</strong></p><p id="7b18" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在前面的步骤中，我们创建了一个ECR注册表来存储Laravel应用程序的Docker映像和Nginx服务器的映像。ECR是标准的Docker注册中心，您可以使用AWS CLI为我们生成的令牌对其进行身份验证:</p><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="9b7d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是我们用来构建Docker映像的两个Docker文件:</p><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div><figcaption class="kk kl fg fe ff km kn bd b be z ek">We install <em class="lu">cron</em> here so we can reuse the same image for our Laravel scheduled tasks and our Laravel workers</figcaption></figure><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div><figcaption class="kk kl fg fe ff km kn bd b be z ek">Here we simply add our custom Nginx config and the public assets from the Laravel public directory into the Docker image. Each time you rebuild your front-end assets, you will need to re-build both the Laravel and Nginx images</figcaption></figure><p id="013a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以及构建它们的命令:</p><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="883b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我们用ECS发布了我们的web服务。<br/>在核心层，任务定义描述了应该使用哪些Docker映像来创建容器，应该如何将容器链接在一起，以及使用哪些环境变量来运行它们。在更高的层次上，ECS服务在ECS集群中同时维护指定数量的任务定义实例。集群是EC2实例的池，即托管任务的基础设施。</p><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="fa6b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的实例需要几秒钟时间才能被ELB视为正常，因此它开始将流量定向到这些实例，然后我们会看到:</p><figure class="jz ka kb kc fq kd fe ff paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="fe ff lv"><img src="../Images/21f5467ece631d43a0985f32cc3b8f1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ALL2g4S9n6CVu9c1WcUqGw.png"/></div></div></figure><p id="1b25" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">至少这是一个Laravel页面，虽然显示了默认的HTTP 500错误消息。通过检查传输到CloudWatch的Laravel日志，我们看到我们在DB中缺少会话表。那么，我们现在如何通过互联网连接到私有子网中的一个实例来运行我们的数据库迁移呢？</p><p id="a66a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 6。启动堡垒&amp;运行数据库迁移</strong></p><p id="ce87" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">bastion(也称为jump box)是一个临时EC2实例，我们将把它放在VPC的公共子网中。这将使我们能够从VPC外部通过SSH访问它，并且仍然能够从那里访问私有子网中的实例(包括数据库实例)。创建堡垒时，确保将允许访问数据库的SG与堡垒相关联。</p><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div><figcaption class="kk kl fg fe ff km kn bd b be z ek">Launch one bastion, to be deleted once we’re done.</figcaption></figure><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div><figcaption class="kk kl fg fe ff km kn bd b be z ek">You’re now connected to an instance inside your VPC private subnets without copying keys around</figcaption></figure><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="3774" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">bastion还可以作为我们的机器和公共子网之间的SSH隧道的主机，这样我们就可以将本地mysql/pgsql客户机连接到我们的远程数据库。以下是PostgreSQL的一个示例:</p><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="a9ee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">回到我们刚刚运行的数据库迁移。下面是连接到负载平衡器时的样子:</p><figure class="jz ka kb kc fq kd fe ff paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="fe ff lv"><img src="../Images/0137260ed7a3e9f685fb18e8b8af447a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nH167XpL0S7DY15ZoiTAqA.png"/></div></div><figcaption class="kk kl fg fe ff km kn bd b be z ek">Laravel served through our load balancer URL</figcaption></figure><p id="cbaa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">耶！我们的应用程序现在通过我们的负载平衡器提供服务，我们的EC2和数据库实例从安全的私有子网运行。下一步是将我们的域名指向我们的负载平衡器。</p><p id="6249" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">7 .<strong class="it hv">。将DNS服务迁移到AWS Route53 <br/> </strong>如果您在AWS之外购买了域名，通常不需要将注册或DNS服务迁移到您的AWS帐户。<br/>如果您希望您的根域(也称为APEX)指向您的负载均衡器，则存在一种边缘情况。这需要一个CNAME记录，这对于APEXs是不允许的，但AWS Route53提供了一种特殊类型的别名记录，让您可以这样做。</p><p id="bb2e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，我们将把您的DNS服务迁移到AWS:</p><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="6bf5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦Route53接受了DNS服务，我们就可以为我们的ELB URL创建一个别名记录。</p><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="7868" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">全部完成！</p><figure class="jz ka kb kc fq kd fe ff paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="fe ff lv"><img src="../Images/da1d0de355df5c777802dc71319ee9e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U0VhalpRfmLEMPlCEAlnlw.png"/></div></div><figcaption class="kk kl fg fe ff km kn bd b be z ek">Domain name pointing to the load balancer, SSL certificate working</figcaption></figure><p id="0f5c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此时您可能已经完成了。您还可以通过以下步骤来改进您的堆栈和部署系统。</p><p id="02d9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 8。使用CloudFront </strong>加速您的应用程序</p><p id="211f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在您的CloudFormation模板中添加一个CloudFront发行版并更新您的堆栈:</p><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="5f28" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您需要预先创建一个CloudFront Origin访问身份，这是一个特殊的CloudFront用户，他将能够查询您的S3存储桶中的对象:</p><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="cb59" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">创建一个别名记录，将<em class="jx">files.yourdomain.com</em>指向您的CF发行版:</p><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="7f1b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">添加一个<em class="jx"> sub_filter </em> Nginx指令，将所有指向S3桶的URL重写为指向CF发行版的链接。</p><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="87d0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 9。(可选)发布您的Laravel workers和crons <br/> </strong>干得好！我们的Laravel应用程序现在在云中高度可用。这一步将展示我们如何重用完全相同的Laravel Docker映像来部署我们的调度任务和工作人员。它们将在自己的容器中运行，并由另一个ECS服务管理，因此我们可以独立地将它们扩展到<em class="jx"> php-fpm </em>容器。我们还确保只有一个cron实例在运行，即使我们有多个前端容器。</p><p id="e498" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于工人作业，我们使用CloudFormation创建一个SQS队列，以便前端在后台向我们的工人分派作业:</p><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="295d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我们从相同的Laravel Docker映像、相同的环境变量开始，在CloudFormation中创建了另外两个任务定义，但只是覆盖了Docker CMD(即容器启动时Docker执行的命令):</p><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="f1c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们用来调用artisan调度程序的crontab文件在cron控制台会话中加载容器的环境变量。如果不这样做，当从cron调用时，Laravel将看不到容器的env变量。</p><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="04a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就是这样！我们的集群中现在混合了Laravel前端容器(<em class="jx"> php-fpm </em>和Nginx作为反向代理)、Laravel workers和一个cron。</p><p id="12be" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 10。(可选)添加一个ElasticSearch域<br/> </strong>大多数网络应用程序都需要一个像ElasticSearch这样的搜索引擎。这就是使用CloudFormation创建托管ES集群的方法。</p><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div><figcaption class="kk kl fg fe ff km kn bd b be z ek">Note that we only allow ingress traffic from both our NAT gateway IPs, ie only instances from our private subnets</figcaption></figure><p id="e03c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 11。(可选)存储层的高可用性<br/> </strong>正如我们之前所讨论的，我们只有一个数据库实例，在单独的AZ中没有读取副本。您可以使用以下模板在CloudFormation中添加副本:</p><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div><figcaption class="kk kl fg fe ff km kn bd b be z ek">Use the DependsOn directive to avoid your replica to be instantiated before and be promoted as the primary instance by Aurora</figcaption></figure><p id="5fdd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，Aurora只支持从db.r4.large size开始的PostgreSQL实例，而Aurora MySQL确实从db.t2.small实例开始。</p><p id="c4c8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 12。CloudWatch警报</strong></p><p id="8899" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面我们为数据库设置了CPU、内存和复制警报:</p><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="45e0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于ECS实例:</p><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="cf75" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 13。(可选)手动更新堆栈—垂直缩放或手动水平缩放</strong></p><p id="79c8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要首次创建CloudFormation堆栈，请使用以下命令:</p><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="b9a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您稍后想要修改集群中实例的数量或大小，请在命令行中更新参数<em class="jx"> ECSInstanceType </em>和<em class="jx"> ECSDesiredCount </em>并调用<em class="jx"> update-stack </em>命令。CloudFormation将取消供应您以前的实例，并启动新的实例，无需您的进一步干预。</p><p id="474c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 14。(可选)自动缩放</strong></p><p id="7e98" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里，我们将使用<em class="jx"> CloudWatch </em>警报、<em class="jx"> ScalableTargets </em>和<em class="jx"> ScalingPolicies </em>的组合来触发ECS集群大小和ECS中所需容器实例数量的扩展。扩展是双向的，所以我们的基础设施通常会在晚上尽可能的轻便，然后在高峰时间扩展！</p><p id="df24" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jx">即将推出</em></p><p id="b18c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">15。(可选)使用代码管道设置连续部署</p><p id="ab0e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是我们从GitHub存储库中自动构建图像的地方。一旦构建并测试了映像(使用内置的Laravel单元和集成测试)，它们将被部署到生产环境中，无需进一步点击。<br/>容器将使用名为蓝绿色部署的部署模式按顺序替换，因此我们绝对不会停机。</p><p id="e603" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jx">我在这里</em>  <em class="jx">写过如何为Laravel </em> <a class="ae jp" rel="noopener" href="/@getlionel/how-to-continuously-deploy-your-laravel-application-on-aws-7fc0f39c558e"> <em class="jx">设置代码管道！</em></a></p><p id="3ad1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">16。(可选)设置SES和邮件服务器</p><p id="c4be" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你从Route53而不是另一个域名注册商那里购买了你的域名，你就没有邮件服务，也就是说你不能用你的新域名接收电子邮件。除了让你在EC2实例上托管一个邮件服务器并让你的MX记录指向它，或者设置一个自定义的Lambda函数将你收到的电子邮件重定向到GMail，AWS没有其他解决方案。</p><p id="ae6d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jx">即将推出</em></p><p id="5914" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 17。成本控制</strong></p><p id="af93" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您正在大规模运行这个架构，有几种方法可以控制您的AWS账单。首先，您可以将您的应用程序指向用于只读查询的Aurora读取副本，以卸载您的主实例并避免纵向扩展过多。</p><p id="8aa6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，您可以提交EC2保留的实例，并预先支付一些实例成本。这样做可以减少多达75%的EC2账单。如果您的流量在一天中波动很大，您可以保留连续运行的实例，并在高峰时间按需扩展实例。</p><p id="6554" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，一个更复杂的方法是使用EC2 Spot实例进行扩展，但是只推荐您的后台工作负载使用，因为Spot实例可以由AWS在短时间内终止。</p><p id="610e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 18。(可选)删除堆栈并释放资源</strong></p><p id="dc83" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦你完成了实验，你可以用一个简单的命令关闭你通过CloudFormation创建的所有资源。现在，您可以确信您没有忘记某个地方的实例或NAT网关悄悄添加到您的AWS账单中。</p><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="5f4a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我希望这对您有所帮助，并让您采用基础设施即代码。如果有所帮助，请评论、鼓掌或分享！</p><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="lw kp l"/></div></figure><p id="22e0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">莱昂内尔是总部位于伦敦的初创公司Wi5的首席技术官，也是面向未来的工程文化课程  <em class="jx">的作者。你可以在</em><a class="ae jp" href="https://getlionel.com" rel="noopener ugc nofollow" target="_blank"><em class="jx">https://getlionel.com</em></a>上联系他</p><figure class="jz ka kb kc fq kd"><div class="bz el l di"><div class="lw kp l"/></div></figure></div></div>    
</body>
</html>