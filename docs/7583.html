<html>
<head>
<title>How to Avoid Anemic Domain Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何避免贫血的领域模型</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-avoid-anemic-domain-model-5e1c3e6fe4d0?source=collection_archive---------8-----------------------#2017-11-01">https://medium.com/hackernoon/how-to-avoid-anemic-domain-model-5e1c3e6fe4d0?source=collection_archive---------8-----------------------#2017-11-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="2859" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">以用户注册为例</h2></div><p id="0bf3" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我有意选择了一个广为流传且简单的领域，我猜每个人都很熟悉。我想展示如何用不同的观点看待它，用对象思维来思考。这篇文章可以看作是我在对某个领域建模时采取的一系列步骤。</p><h2 id="2f98" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">首先，我们来谈谈表格</h2><p id="bcb4" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">如今，表单被用作数据验证的工具，目的是让这些数据变得有用。我经常看到验证脱离了业务逻辑。在这种情况下，数据被视为被动的:首先，验证它，然后做这个，然后做那个。嗯，很棒，叫<a class="ae lf" href="https://en.wikipedia.org/wiki/Procedural_programming" rel="noopener ugc nofollow" target="_blank">过程化编程</a>。下一步是将验证逻辑，域概念固有的<em class="lg"/>，转移到那些<a class="ae lf" href="http://gorodinski.com/blog/2012/05/19/validation-in-domain-driven-design-ddd/" rel="noopener ugc nofollow" target="_blank">值对象和实体</a>。这就是DDD教我们做的。在这种情况下，表单只是让用户修改一些数据的工具。但是在某些情况下，表单是一个成熟的领域概念，只是在某些方面看起来像web表单。</p><h2 id="b152" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">我的领域</h2><p id="98bb" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated"><strong class="jl hv">在这里。</strong></p><p id="c6ad" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我的域名是一个注册用户。他们打开一个页面，看到一个注册表，填写它，然后提交。然后，通过填写表格时显示的电子邮件地址发送确认电子邮件。它包含一个带有秘密令牌的确认链接，因此如果用户遵循这个链接，就意味着他填写了一封真正属于他的电子邮件。所以点击这个链接就完成了注册过程:一个新用户出现在系统中。</p><p id="546f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不过，我并没有试图对这个领域的整体进行建模。只是个素描。</p><p id="df9b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> <em class="lg">语义网</em> </strong> <br/>我用语义网开始分解。它帮助我发现基本物体。此外，它直观地表现了正在发生的事情以及事物之间的联系。在这个例子中，这是相当琐碎的。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lh"><img src="../Images/75f502f8d5ca2b44e74d69b6f2118616.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xoEUCHNCfbhXUOXHaQRlFA.png"/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek">Simple semantic net of user registration domain</figcaption></figure><p id="37ce" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> <em class="lg">只有名词，没有“服务”</em> </strong> <br/>在画素描时，我牢记<a class="ae lf" rel="noopener" href="/@wrong.about/on-good-domain-decomposition-385ee8ce5a3">物体隐喻</a>。实际上，这主要导致缺少<a class="ae lf" rel="noopener" href="/@wrong.about/you-dont-need-a-domain-service-class-in-ddd-9ecd3140782">服务类别</a>。为什么？因为一个<a class="ae lf" href="https://www.amazon.com/Object-Thinking-Developer-Reference-David/dp/0735619654" rel="noopener ugc nofollow" target="_blank">大卫·韦斯特</a>的人性比喻。或者是<a class="ae lf" href="https://en.wikipedia.org/wiki/Alan_Kay" rel="noopener ugc nofollow" target="_blank">艾伦凯</a>的<a class="ae lf" href="https://news.ycombinator.com/item?id=11966570" rel="noopener ugc nofollow" target="_blank">细胞隐喻</a>。因为对象在OOP中的意义。对象就像聪明而独立的成年人，他们不需要被告知如何做他们应该做的事情。</p><p id="4037" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> <em class="lg">理解领域规则<br/> </em> </strong>就像在<a class="ae lf" rel="noopener" href="/@wrong.about/service-boundaries-identification-example-in-e-commerce-a2c01a1b8ee9">识别服务边界</a>中一样，我使用相同的技术。我一头扎进过去，看看某个特定领域当时是什么样子。</p><p id="f7ca" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以我们来考虑一些纸质形式。可能是申请表或登记表，随便什么都行。在某个地方注册是什么感觉？你拿走了表格。它是用打字机打印的。你拿了一支笔。装满了。然后你把它还给一个秘书。他或她看了一下，可能马上就注意到了一些打字错误或其他错误，检查了你的护照，以确保你是你所说的那个人，然后把它留下来做进一步的验证，这可能需要几天的时间。然后你可以几天后回来看看你的状态如何。或者你可以收到一封有结果的信。</p><h2 id="d7d2" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">如何对一个领域建模</h2><p id="4ce6" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated"><strong class="jl hv"> <em class="lg">几句如何建模领域规则<br/> </em> </strong>现在有什么不同，没有打字机，没有秘书的时候？表单仍然需要显示和验证。谁应该做那件事？长话短说，对象思维意味着一个形式本身应该。现在，我们正在对注册过程中固有的行为进行建模。它与打印机、任何验证器、<a class="ae lf" href="http://www.yegor256.com/2015/03/09/objects-end-with-er.html" rel="noopener ugc nofollow" target="_blank">其他“er”或“or”或“s </a>无关，现在它只是一个注册表、一个令牌和一封电子邮件。好的，还有一个带用户的访问者，只是碰巧以“or”和“er”结尾。但是，没有什么可以阻止这些类利用它们所需要的一切来实现它们的职责。此外，鼓励对象拥有所有必要的资源:数据库连接、外部资源、缓存资源。如果对一个班级来说太多了——没问题，装饰者是一个不错的选择。这个概念的一个例子是一个<a class="ae lf" rel="noopener" href="/@wrong.about/you-dont-need-an-orm-7ef83bd1b37d"> ORM </a>:你的对象不再被操纵，它们自己决定做什么。同样的情况到处都是。服务是反向的。他们不再对物体进行操作了。<br/>因此，我们实体的职责可能如下所示。注册表单负责显示自身、验证和保存自身。邮件负责自己发送。为了全面了解情况，我们应该想出并阐述一组<a class="ae lf" href="https://www.amazon.com/User-Stories-Applied-Software-Development/dp/0321205685" rel="noopener ugc nofollow" target="_blank">用户故事</a>。</p><p id="266b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> <em class="lg">用户故事<br/> </em> </strong>哪些用户故事构成了注册的流程？以下情况如何:</p><blockquote class="lx ly lz"><p id="d7c9" class="jj jk lg jl b jm jn iv jo jp jq iy jr ma jt ju jv mb jx jy jz mc kb kc kd ke hn dt translated">一个访问者请求一个表格并填写它。</p></blockquote><p id="8581" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我可以从这个故事中得出结论，一个形式应该有责任展示自己。</p><blockquote class="lx ly lz"><p id="21b8" class="jj jk lg jl b jm jn iv jo jp jq iy jr ma jt ju jv mb jx jy jz mc kb kc kd ke hn dt translated">表单确保所有字段都有效。</p></blockquote><p id="e007" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">验证过程需要更多的细节。还记得五十年前我写的关于注册是如何工作的吗？验证的过程包括一个秘书需要检查你是不是你所说的那个人，所以你向他或她出示了你的护照。如今，电子邮件就像护照一样。我们在电子邮件上发送一封信，访问者填写了该表格，他或她应该确认它，这个过程包括在一个术语“验证”中。因此，任何注册都不可避免地包含异步部分。那么尝试同步验证一切是没有意义的。我在同步验证中留下的是一些轻量级的检查，当违反这些检查时，永远不会让注册成功。这些支票是什么？例如，出生日期比今天或一年前要早。出生日期应该是真实的。或者电子邮件符合<a class="ae lf" href="https://tools.ietf.org/html/rfc822" rel="noopener ugc nofollow" target="_blank"> RFC822 </a>。因此，如果所有这些检查都成功通过，我说表单可以被<em class="lg">接受</em>。<br/>有些异步检查可能是并行的，有些应该是顺序的。展望未来，我可以说这样的检查可以作为<a class="ae lf" href="http://vasters.com/archive/Sagas.html" rel="noopener ugc nofollow" target="_blank">传奇</a>来实现。每一个都需要自己的用户故事。这就是整个过程的图示:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff md"><img src="../Images/4fc79d1be6cc2633dbbee3a23bee9dd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6qVeG0wcCgR7-v1xpvs64w.png"/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek">Form validation ending with registration of a user</figcaption></figure><blockquote class="lx ly lz"><p id="3c9f" class="jj jk lg jl b jm jn iv jo jp jq iy jr ma jt ju jv mb jx jy jz mc kb kc kd ke hn dt translated">如果一个表单有效，它注册一个访问者(记住对象是活动的！)，所以就成了用户。</p></blockquote><p id="8300" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以这个故事卡揭示了另一个表单的责任:用户注册。</p><p id="7420" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">下一个详细的验证用户故事可以开始了。我不想在这里深究，只把自己局限在那些关于电子邮件确认的问题上。他们在这里:</p><blockquote class="lx ly lz"><p id="cb27" class="jj jk lg jl b jm jn iv jo jp jq iy jr ma jt ju jv mb jx jy jz mc kb kc kd ke hn dt translated">如果同步验证可以，编写一封确认电子邮件并发送给访问者。</p></blockquote><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff md"><img src="../Images/7d84dd8785d4976ad135447a18a15b1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tGNU0YVhVOwrkKhXL-RaGw.png"/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek"><em class="me">A interaction diagram for composing and sending a confirmation email</em></figcaption></figure><p id="73dd" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">显然，一封电子邮件应该在表格的帮助下撰写，毕竟它是一个信息专家。但是一封电子邮件应该拥有能够自己发送的所有资源。</p><blockquote class="lx ly lz"><p id="cda1" class="jj jk lg jl b jm jn iv jo jp jq iy jr ma jt ju jv mb jx jy jz mc kb kc kd ke hn dt translated">访问者通过电子邮件中的确认链接成为用户。</p></blockquote><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff md"><img src="../Images/707cdee21998d0fb3fab4a139993855d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n29qXOs73SLrxoCEjcJjSg.png"/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek">A interaction diagram for confirming an email address</figcaption></figure><p id="0d76" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这里，表单将确认委托给令牌，因为它更清楚如何确认输入的令牌字符串。如果没问题，那么表单注册一个新用户。这是一个常见的流程，反映了从面向对象的角度来看的一个领域:一个实体创建另一个实体，等等。<a class="ae lf" href="http://udidahan.com/2009/06/29/dont-create-aggregate-roots/" rel="noopener ugc nofollow" target="_blank">实体(即集合体)不会自己弹出</a>。</p><p id="22f1" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> <em class="lg"> CRC卡</em> </strong> <br/>随着用户故事的发现，我可以制作<a class="ae lf" href="https://en.wikipedia.org/wiki/Class-responsibility-collaboration_card" rel="noopener ugc nofollow" target="_blank"> CRC卡</a>。就算说CRC正方体(一个源于CRC卡的概念，我第一次遇到是在大卫·韦斯特的《客体思维》里)，对我最管用的那一面，也是有责任的那一面。所以我遍历了所有涉及特定对象的用户故事，并收集了它的职责。它们表示我的对象可以提供的服务，并且它们形成了对象的契约。我不会深入研究CRC立方体的形式表示，让我们直接看代码。</p><h2 id="0056" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">密码</h2><p id="3dd5" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">好的，我看了一下我的职责，发现我的表单应该能够:</p><ul class=""><li id="4cdb" class="mf mg hu jl b jm jn jp jq js mh jw mi ka mj ke mk ml mm mn dt translated">展示自己；</li><li id="68ab" class="mf mg hu jl b jm mo jp mp js mq jw mr ka ms ke mk ml mm mn dt translated">验证自身；</li><li id="e7a2" class="mf mg hu jl b jm mo jp mp js mq jw mr ka ms ke mk ml mm mn dt translated">撰写确认电子邮件，作为验证的一部分；</li><li id="c7e1" class="mf mg hu jl b jm mo jp mp js mq jw mr ka ms ke mk ml mm mn dt translated">确认电子邮件，也是验证的一部分；</li><li id="2455" class="mf mg hu jl b jm mo jp mp js mq jw mr ka ms ke mk ml mm mn dt translated">注册用户。</li></ul><p id="3a04" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以这些是形成一个对象契约的候选者。</p><p id="2061" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">请记住，下面的代码只是上面提出的想法和原则的代表。它比伪代码多，但比生产代码少。</p><p id="2b00" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> <em class="lg">显示表单<br/> </em> </strong>我希望我的注册表单只负责显示数据，把装饰留给其他人。我不认为让表单知道每一个表示细节是一个好主意，所以我希望来自特定类的协作。它可能如下所示:</p><pre class="li lj lk ll fq mt mu mv mw aw mx dt"><span id="9216" class="kf kg hu mu b fv my mz l na nb"><em class="lg">// an entry point. It might also be a controller action.<br/></em><strong class="mu hv">public function </strong>display()<br/>{<br/>    (<strong class="mu hv">new </strong>RegistrationForm(<br/>        <strong class="mu hv">new </strong>UUID(),<br/>        <strong class="mu hv">new </strong>RegistrationFormDataStorage()<br/>    ))<br/>        -&gt;display()<br/>    ;<br/>}</span></pre><p id="ae29" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">和表单方法本身。这种精神可以在<a class="ae lf" href="http://www.yegor256.com/2015/03/26/jaxb-vs-xembly.html" rel="noopener ugc nofollow" target="_blank">中实现</a>。</p><pre class="li lj lk ll fq mt mu mv mw aw mx dt"><span id="af3b" class="kf kg hu mu b fv my mz l na nb"><strong class="mu hv">class </strong>RegistrationForm<br/>{<br/>    <em class="lg">/**<br/>     * </em><strong class="mu hv"><em class="lg">@var </em></strong><em class="lg">$id UUID<br/>     */<br/>    </em><strong class="mu hv">private $id</strong>;<br/><br/>    <em class="lg">/**<br/>     * </em><strong class="mu hv"><em class="lg">@var </em></strong><em class="lg">$storage DataStorage<br/>     */<br/>    </em><strong class="mu hv">private $storage</strong>;<br/><br/>    <strong class="mu hv">public function </strong>__construct(UUID $id, DataStorage $storage)<br/>    {<br/>        $this-&gt;<strong class="mu hv">id </strong>= $id;<br/>        $this-&gt;<strong class="mu hv">storage </strong>= $storage;<br/>    }<br/><br/>    <strong class="mu hv">public function </strong>display()<br/>    {<br/>        (<strong class="mu hv">new </strong>RegistrationWebForm(<br/>            <strong class="mu hv">new </strong>HiddenElement(<br/>                $this-&gt;<strong class="mu hv">id</strong>-&gt;value()<br/>            ),<br/>            <strong class="mu hv">new </strong>NameElement(),<br/>            <strong class="mu hv">new </strong>PassportElement(),<br/>            <strong class="mu hv">new </strong>EmailElement()<br/>        ))<br/>            -&gt;display();<br/>    }<br/>}</span></pre><p id="e227" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> <em class="lg">受理表单</em> </strong></p><pre class="li lj lk ll fq mt mu mv mw aw mx dt"><span id="dd25" class="kf kg hu mu b fv my mz l na nb"><strong class="mu hv">public function </strong>accept(<strong class="mu hv">array </strong>$data)<br/>{<br/>    <strong class="mu hv">try </strong>{<br/>        (<strong class="mu hv">new </strong>RegistrationForm(<br/>            <strong class="mu hv">new </strong>FixedUUID($data[<strong class="mu hv">'id'</strong>]),<br/>            <strong class="mu hv">new </strong>RegistrationFormDataStorage()<br/>        ))<br/>            -&gt;accept(<br/>                <strong class="mu hv">new </strong>Name($data[<strong class="mu hv">'name'</strong>]),<br/>                <strong class="mu hv">new </strong>Passport(<br/>                    <strong class="mu hv">new </strong>PassportNumber($data[<strong class="mu hv">'passport_number'</strong>]),<br/>                    <strong class="mu hv">new </strong>PassportIssuedAt($data[<strong class="mu hv">'passport_issued_at'</strong>]),<br/>                    <strong class="mu hv">new </strong>PassportIssuedWhere($data[<strong class="mu hv">'passport_issued_where'</strong>])<br/>                ),<br/>                <strong class="mu hv">new </strong>Email($data[<strong class="mu hv">'email'</strong>])<br/>            )<br/>        ;<br/>    } <strong class="mu hv">catch </strong>(Exception $e) {<br/>        (<strong class="mu hv">new </strong>ErrorPage())-&gt;display();<br/>    }<br/><br/>    (<strong class="mu hv">new </strong>RegistrationAcceptedPage())-&gt;display();<br/>}</span></pre><p id="5620" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">同样，这也是入口点的样子。下面是<em class="lg">registration form-&gt;accept()</em>方法的实现:</p><pre class="li lj lk ll fq mt mu mv mw aw mx dt"><span id="9b09" class="kf kg hu mu b fv my mz l na nb"><strong class="mu hv">public function </strong>accept(<br/>    IValidatableElement $name,<br/>    IValidatableElement $passport,<br/>    IValidatableElement $email<br/>)<br/>{<br/>    $this-&gt;<strong class="mu hv">storage<br/>        </strong>-&gt;transactionally(<br/>            <strong class="mu hv">function </strong>() <strong class="mu hv">use </strong>($name, $passport, $email) {<br/>                $id =<br/>                    $this-&gt;<strong class="mu hv">storage<br/>                        </strong>-&gt;save(<br/>                            [<br/>                                <strong class="mu hv">'name' </strong>=&gt; $name-&gt;value(),<br/>                                <strong class="mu hv">'passport' </strong>=&gt; $passport-&gt;value(),<br/>                                <strong class="mu hv">'email' </strong>=&gt; $email-&gt;value(),<br/>                            ]<br/>                        )<br/>                ;<br/>                $this-&gt;<strong class="mu hv">storage</strong>-&gt;appendFormAcceptedEvent($id);<br/>            }<br/>        );<br/>}</span></pre><p id="6d7c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">注意数据库中事务性存储的<em class="lg">表单接受的</em>事件。我不想在一次运行中执行所有的逻辑，因为我不想滥用DDD的“一个集合—一个事务”的经验法则。我有一个单独的处理程序来处理那个事件；它构成了一封确认电子邮件。</p><p id="dd97" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> <em class="lg">撰写确认邮件</em> </strong></p><pre class="li lj lk ll fq mt mu mv mw aw mx dt"><span id="805f" class="kf kg hu mu b fv my mz l na nb"><strong class="mu hv">public function </strong>composeConfirmationEmail(UUID $formId)<br/>{<br/>    (<strong class="mu hv">new </strong>RegistrationForm(<br/>        $formId,<br/>        <strong class="mu hv">new </strong>RegistrationFormDataStorage()<br/>    ))<br/>        -&gt;composeConfirmationEmail(<br/>            <strong class="mu hv">new </strong>SmtpClient(),<br/>            <strong class="mu hv">new </strong>EmailConfirmationEmailHeader(),<br/>            <strong class="mu hv">new </strong>EmailConfirmationEmailBody(),<br/>            (<strong class="mu hv">new </strong>ConfirmationTokens(<br/>                <strong class="mu hv">new </strong>TokenStorage()<br/>            ))<br/>                -&gt;add(<br/>                    <strong class="mu hv">new </strong>ConfirmationToken(<br/>                        <strong class="mu hv">new </strong>UUID(),<br/>                        <strong class="mu hv">new </strong>TokenStorage(),<br/>                        <strong class="mu hv">new </strong>UUID() // it's a token string<br/>                    )<br/>                )<br/>        )<br/>            -&gt;send();<br/>}</span></pre><p id="9a98" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">下面是一个对象持久化的变体。我使用了一个类似集合的类<em class="lg"> ConfirmationTokens </em>，它可以用于添加和搜索令牌。这里有一个非常简单的<br/><em class="lg">registration form-&gt;composeConfirmationEmail()</em>实现:</p><pre class="li lj lk ll fq mt mu mv mw aw mx dt"><span id="b494" class="kf kg hu mu b fv my mz l na nb"><strong class="mu hv">public function </strong>composeConfirmationEmail(<br/>    ICanSendEmails $transport,<br/>    EmailHeader $subject,<br/>    EmailBody $body,<br/>    ConfirmationToken $token<br/>)<br/>{<br/>    <strong class="mu hv">return<br/>        </strong>(<strong class="mu hv">new </strong>ConfirmationEmail(<br/>            $transport,<br/>            $this-&gt;<strong class="mu hv">storage</strong>-&gt;getById($this-&gt;<strong class="mu hv">id</strong>)[<strong class="mu hv">'email_address'</strong>],<br/>            $subject,<br/>            $body,<br/>            $token<br/>        ))<br/>            -&gt;save();<br/>}</span></pre><p id="8d2b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最后，这是用户确认电子邮件的入口点:</p><pre class="li lj lk ll fq mt mu mv mw aw mx dt"><span id="1e2b" class="kf kg hu mu b fv my mz l na nb"><strong class="mu hv">public function </strong>confirmEmail(UUID $formId, UUID $tokenValue)<br/>{<br/>    (<strong class="mu hv">new </strong>RegistrationForm(<br/>        $formId,<br/>        <strong class="mu hv">new </strong>RegistrationFormDataStorage()<br/>    ))<br/>        -&gt;confirmEmail(<br/>            (<strong class="mu hv">new </strong>ConfirmationTokens(<br/>                <strong class="mu hv">new </strong>TokenStorage()<br/>            ))<br/>                -&gt;byValue($tokenValue)<br/>        );<br/>}</span></pre><p id="473c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">成功的确认导致新的正式用户的注册:</p><pre class="li lj lk ll fq mt mu mv mw aw mx dt"><span id="bdb7" class="kf kg hu mu b fv my mz l na nb"><strong class="mu hv">public function </strong>confirmEmail(ConfirmationToken $token)<br/>{<br/>    <strong class="mu hv">if </strong>($this-&gt;generatedToken()-&gt;confirm($token)) {<br/>        $data = $this-&gt;<strong class="mu hv">storage</strong>-&gt;getById($this-&gt;<strong class="mu hv">id</strong>);<br/><br/>        (<strong class="mu hv">new </strong>User(<br/>            <strong class="mu hv">new </strong>UUID(),<br/>            <strong class="mu hv">new </strong>UserDataStorage()<br/>        ))<br/>            -&gt;register(<br/>                <strong class="mu hv">new </strong>Name($data[<strong class="mu hv">'name'</strong>]),<br/>                <strong class="mu hv">new </strong>Passport(<br/>                    <strong class="mu hv">new </strong>PassportNumber($data[<strong class="mu hv">'passport_number'</strong>]),<br/>                    <strong class="mu hv">new </strong>PassportIssuedAt($data[<strong class="mu hv">'passport_issued_at'</strong>]),<br/>                    <strong class="mu hv">new </strong>PassportIssuedWhere($data[<strong class="mu hv">'passport_issued_where'</strong>])<br/>                ),<br/>                <strong class="mu hv">new </strong>Email($data[<strong class="mu hv">'email'</strong>])<br/>            );<br/>    }<br/>}</span></pre><h2 id="d004" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">包装它</h2><p id="f167" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">因此，通过完全抛弃数据模型和对象应该持久化的方式，并专注于行为，我可以提出一个下降模型。</p></div></div>    
</body>
</html>