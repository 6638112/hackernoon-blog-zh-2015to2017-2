<html>
<head>
<title>How to use JavaScript closures with confidence</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何放心地使用JavaScript闭包</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-use-javascript-closures-with-confidence-85cd1f841a6b?source=collection_archive---------4-----------------------#2017-05-18">https://medium.com/hackernoon/how-to-use-javascript-closures-with-confidence-85cd1f841a6b?source=collection_archive---------4-----------------------#2017-05-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="a9f5" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">使用闭包将是小菜一碟</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/626ee91c14a4861676c17a9b427042d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SJ6YpCYam_N_o_wJhyomog.jpeg"/></div></div></figure><p id="958f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">从凯尔·辛普森的话来看，</p><blockquote class="ks kt ku"><p id="eddd" class="jv jw kv jx b jy jz iv ka kb kc iy kd kw kf kg kh kx kj kk kl ky kn ko kp kq hn dt translated">"在JavaScript中，闭包就在你周围，你只需要认识并接受它."</p></blockquote><p id="6782" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">当你用<a class="ae kr" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>写的时候，闭包就这么发生了……不管你是否意识到了。理解闭包以有意地创建它们并利用它们的能力是每个JavaScript开发人员都必须解决的挑战；下面就用这篇文章来试试吧。</p></div><div class="ab cl kz la hc lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hn ho hp hq hr"><p id="c31d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这里有一个有点学术性的定义，当你看到一个闭包时，它将帮助你理解并识别它:<strong class="jx hv">闭包是指一个函数能够记住并访问外部(封闭)函数的变量，即使该函数在其作用域之外执行。</strong></p><blockquote class="lg"><p id="dd27" class="lh li hu bd lj lk ll lm ln lo lp kq ek translated"><em class="lq">封闭是指函数能够记住并访问外部(封闭)函数的变量，即使该函数在其作用域之外执行。</em></p></blockquote><p id="49c6" class="pw-post-body-paragraph jv jw hu jx b jy lr iv ka kb ls iy kd ke lt kg kh ki lu kk kl km lv ko kp kq hn dt translated">我们稍后再回到<a class="ae kr" href="https://hackernoon.com/understand-javascript-variable-scope-with-ease-221a6d41dc43" rel="noopener ugc nofollow" target="_blank"> <em class="kv">范围</em> </a>概念。现在只需要知道，根据变量在代码中的位置，有些函数可以访问它，有些不能。</p><p id="ce92" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在说说<em class="kv">变量</em>；您可能已经知道，变量有两个组成部分:名称和值。“变量”这个名字非常清楚地说明了这一点:它的值可以从一个时刻到下一个时刻<em class="kv">变化。但有时，我们需要保留某个时间点的值，以便以后使用。</em></p><p id="b7c1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在JavaScript中，这种情况经常在使用像<code class="eh lw lx ly lz b">setTimeout()</code>和<code class="eh lw lx ly lz b">setInterval()</code>这样的函数时遇到。</p><h1 id="da40" class="ma mb hu bd mc md me mf mg mh mi mj mk ja ml jb mm jd mn je mo jg mp jh mq mr dt translated"><code class="eh lw lx ly lz b">for</code>循环的例子</h1><p id="6b24" class="pw-post-body-paragraph jv jw hu jx b jy ms iv ka kb mt iy kd ke mu kg kh ki mv kk kl km mw ko kp kq hn dt translated">让我们以一个用于显示计数器的<code class="eh lw lx ly lz b">for</code>循环和一个用于延迟函数执行的<code class="eh lw lx ly lz b">setTimout()</code>函数为例。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="0b7d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">查看这个代码片段，您通常会认为它会每秒打印一个数字0到9。事实上，如果您运行这段代码，您会以1秒的间隔将10打印10次:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mz"><img src="../Images/537c93723d261bfe1e16da35de5ab82e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pt--96YkrtjAM0Vu.gif"/></div></div></figure><p id="21c4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">为什么会出现这种情况？</p><p id="ee27" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">当for循环运行并且<code class="eh lw lx ly lz b">setTimeout()</code>在未来的某个时间被调用时(在这种情况下，在未来的一秒钟后)，变量<code class="eh lw lx ly lz b">i</code>的值已经被for循环递增到其范围的末端。</p><p id="b1f5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在这种情况下，我们需要在给定时间存储和访问变量值，然后再修改它。在每次迭代循环中，我们需要“捕获”相应的<code class="eh lw lx ly lz b">i</code>副本，并存储起来以备后用。好消息是闭包将帮助我们做到这一点:<strong class="jx hv">在循环的每次迭代中创建一个新的闭包作用域</strong>。</p><p id="7d7e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们将回到这个例子，看看如何给我们的循环添加一个闭包。但是在深入探讨闭包的工作原理之前，让我们绕一小段路，回顾一下为了完全掌握闭包我们需要很好理解的一些重要概念。</p><h2 id="9155" class="na mb hu bd mc nb nc nd mg ne nf ng mk ke nh ni mm ki nj nk mo km nl nm mq nn dt translated">函数也是变量</h2><p id="56d9" class="pw-post-body-paragraph jv jw hu jx b jy ms iv ka kb mt iy kd ke mu kg kh ki mv kk kl km mw ko kp kq hn dt translated">函数是一个特殊的变量:您可以给它重新赋值，并将其作为参数传递给另一个函数(这在编写作为回调参数传递的异步函数时很有用)。</p><h2 id="905b" class="na mb hu bd mc nb nc nd mg ne nf ng mk ke nh ni mm ki nj nk mo km nl nm mq nn dt translated">变量的范围</h2><p id="a8af" class="pw-post-body-paragraph jv jw hu jx b jy ms iv ka kb mt iy kd ke mu kg kh ki mv kk kl km mw ko kp kq hn dt translated">在函数外部定义的变量可以被该函数访问。它们可以在函数外部修改，也可以由函数本身修改。</p><p id="a6ca" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在函数内部定义的变量以及传递给函数的参数只能在函数内部访问。</p><p id="6eae" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><em class="kv">(欲了解更多范围，请参考</em><a class="ae kr" href="https://hackernoon.com/understand-javascript-variable-scope-with-ease-221a6d41dc43" rel="noopener ugc nofollow" target="_blank"><em class="kv"/></a><em class="kv">)</em></p><h2 id="78f0" class="na mb hu bd mc nb nc nd mg ne nf ng mk ke nh ni mm ki nj nk mo km nl nm mq nn dt translated">将变量传递给函数</h2><p id="fb84" class="pw-post-body-paragraph jv jw hu jx b jy ms iv ka kb mt iy kd ke mu kg kh ki mv kk kl km mw ko kp kq hn dt translated">当变量作为参数传递给函数时，变量的<em class="kv">值</em>被复制到参数中。</p><h1 id="b022" class="ma mb hu bd mc md me mf mg mh mi mj mk ja ml jb mm jd mn je mo jg mp jh mq mr dt translated">采取关闭风暴</h1><p id="3299" class="pw-post-body-paragraph jv jw hu jx b jy ms iv ka kb mt iy kd ke mu kg kh ki mv kk kl km mw ko kp kq hn dt translated">既然我们完成了绕行并回来了，我们准备解决关闭问题。</p><p id="5725" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">让我们考虑下面的代码:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="7636" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">让我们更深入地研究一下这个函数:这里发生了什么？</p><p id="3329" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们定义一个参数<code class="eh lw lx ly lz b">number1</code>,它将接受传递给函数的变量值。</p><p id="ecee" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们在函数 <code class="eh lw lx ly lz b">myFunction</code>内部定义了一个<em class="kv">函数。在这个嵌套函数中，变量<code class="eh lw lx ly lz b">number1</code>是可访问的，因为它是在<code class="eh lw lx ly lz b">add</code>函数之外的父函数<code class="eh lw lx ly lz b">myFunction</code>中定义的。</em></p><p id="1347" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们返回了<code class="eh lw lx ly lz b">add</code>函数，但是我们没有<em class="kv">调用</em>它。这是什么意思？</p><p id="0010" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><code class="eh lw lx ly lz b">myFunction</code>函数<em class="kv">返回一个函数</em>:函数<code class="eh lw lx ly lz b">add</code>。当我将<code class="eh lw lx ly lz b">myFunction</code>打印到控制台时，会显示该函数的返回结果，该函数是<em class="kv">另一个函数</em>(<code class="eh lw lx ly lz b">add</code>函数) :</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="775e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">为什么这很重要？因为这意味着我可以给<code class="eh lw lx ly lz b">number1</code>赋一个值，传递给<code class="eh lw lx ly lz b">myFunction</code>，这个新的<code class="eh lw lx ly lz b">number1</code>的值会被存储起来以备后用，那时我就准备好完成作业，调用add函数了。</p><p id="72fd" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">闭包最棒的地方在于:<strong class="jx hv">您可以编写具有中间状态的函数，它可以在某个特定的时刻从您的应用程序中捕获数据，然后您可以在另一个更晚的时刻使用这些数据</strong>。使用闭包就像在函数中添加一个“暂停”按钮。当您的应用程序发生变化时(例如，用户的点击事件)，您可以稍后返回，并且仍然能够检索应用程序发生变化之前的数据值。</p><p id="da0c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果没有闭包，JavaScript将简单地运行所有代码并返回数据的最后一个已知值，没有办法返回到数据具有您现在想要使用的值的时刻。</p><p id="646f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这就是在我们的第一个<code class="eh lw lx ly lz b">for</code>循环例子中发生的事情:<code class="eh lw lx ly lz b">setTimeout</code>函数在战争中姗姗来迟。<code class="eh lw lx ly lz b">for</code>循环的战斗已经结束，当<code class="eh lw lx ly lz b">setTimeout</code>骑兵到达时，<code class="eh lw lx ly lz b">i</code>变量早已被赋予10，这是循环中的最新值，并一直保持到<code class="eh lw lx ly lz b">setTimeout</code>到达。</p><p id="b9df" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">仍然不相信或不确定何时使用闭包？让我们举个例子，通过烤蛋糕来解释闭包是如何工作的。</p><h1 id="ae17" class="ma mb hu bd mc md me mf mg mh mi mj mk ja ml jb mm jd mn je mo jg mp jh mq mr dt translated">烤一个有封口的蛋糕</h1><p id="4104" class="pw-post-body-paragraph jv jw hu jx b jy ms iv ka kb mt iy kd ke mu kg kh ki mv kk kl km mw ko kp kq hn dt translated">我们将使用此代码，它使用一个函数来烘焙具有不同配料和烹饪温度的蛋糕:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="997c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><code class="eh lw lx ly lz b">ovenTemperature()</code>函数是<strong class="jx hv">闭包，是函数</strong>内部的一个函数，在<code class="eh lw lx ly lz b">bakeCake()</code>函数被调用后的任何时间点都可以被调用。</p><p id="3be2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">请注意，我们必须采取两个步骤才能在控制台中获得整个日志。如果您运行这段代码并且从不调用<code class="eh lw lx ly lz b">chocolateCake()</code>或<code class="eh lw lx ly lz b">carrotCake()</code>，控制台将只打印:</p><pre class="jk jl jm jn fq no lz np nq aw nr dt"><span id="ddbc" class="na mb hu lz b fv ns nt l nu nv">"chocolate cake : add chocolate to the batter"<br/>"carrot cake : add carrot to the batter"</span></pre><p id="7461" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">您不会得到任何错误，但是函数内部的函数，即闭包，不会运行，也不会完成烘焙蛋糕。</p><p id="b19d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">还要注意，我可以使用我的<code class="eh lw lx ly lz b">bakeCake()</code>函数来烤两个非常不同的蛋糕，每一个都是<code class="eh lw lx ly lz b">bakeCake()</code>的一个单独实例，它会记住自己的<code class="eh lw lx ly lz b">ingredient</code>参数供以后使用。</p><p id="fffc" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">就像在一个真正的食谱中，仅仅把<code class="eh lw lx ly lz b">ingredient</code>加入面糊是不够的，你还必须设置正确的<code class="eh lw lx ly lz b">temperature</code>和烘焙<code class="eh lw lx ly lz b">time</code>才能得到一个完美的蛋糕。为此，你必须在函数内部调用另一个函数。正如我们在前面使用<code class="eh lw lx ly lz b">add()</code>函数的例子中看到的，如果这个内部函数没有被调用，外部函数的返回只是另一个函数，等待它被调用的时间，而不是结果值(还没有)。</p><p id="93f3" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这里，<code class="eh lw lx ly lz b">bakeCake()</code>函数不会返回“准备烘烤”行，直到你也用两个参数调用了<code class="eh lw lx ly lz b">ovenTemperature()</code>函数:它被挂起，直到被正确调用。</p><p id="8486" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">你可以将巧克力放入面糊中，让面糊静置，然后花时间查看你的食谱，确定合适的温度和烘焙时间。可以是一个小时后，你可能要打电话给你妈妈征求意见了，加巧克力的面糊还会在这里，等你下最后的指令。换句话说，任何时候你调用<code class="eh lw lx ly lz b">chocolateCake()</code>，参数<code class="eh lw lx ly lz b">ingredient</code>，巧克力，仍然会被包含。</p><p id="d563" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">那么当我准备好了，我该如何调用这个内部函数呢？我已经打电话给我妈妈，在网上查了每一个食谱，现在让我们一劳永逸地吃完这些蛋糕吧。</p><p id="f5a3" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我已经创建了<code class="eh lw lx ly lz b">bakeCake()</code>函数的两个实例，并将它们分配给两个不同的变量:<code class="eh lw lx ly lz b">chocolateCake</code>和<code class="eh lw lx ly lz b">carrotCake</code>。</p><p id="ab19" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">让我们专注于巧克力蛋糕。<code class="eh lw lx ly lz b">chocolateCake</code>是一个函数，是<code class="eh lw lx ly lz b">bakeCake</code>的一个实例，带有一个<code class="eh lw lx ly lz b">chocolate</code>参数。为了让<code class="eh lw lx ly lz b">chocolateCake</code>返回“准备烘烤”语句，我只需调用它并传递<code class="eh lw lx ly lz b">ovenTemperature()</code>函数所需的参数。</p><p id="fe22" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这意味着在我们为要触发的闭包传递第二组参数之前，不会实现<code class="eh lw lx ly lz b">chocolateCake</code>。</p><p id="ad5c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这里为了便于理解，我们首先将<code class="eh lw lx ly lz b">bakeCake("chocolate")</code>赋给一个变量(<code class="eh lw lx ly lz b">chocolateCake</code>)，然后将第二个参数传递给这个变量，它也是一个函数。但是如果我们已经知道了食谱的所有要求，我们可以直接去做:</p><pre class="jk jl jm jn fq no lz np nq aw nr dt"><span id="fec0" class="na mb hu lz b fv ns nt l nu nv">bakeCake("chocolate")(250, 60);</span></pre><p id="5d9c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">用道格拉斯·克洛克福特的话来说，这个实验的最终结果是:</p><blockquote class="ks kt ku"><p id="67bc" class="jv jw kv jx b jy jz iv ka kb kc iy kd kw kf kg kh kx kj kk kl ky kn ko kp kq hn dt translated">内部函数始终可以访问其外部函数的变量和参数，即使在外部函数返回后也是如此</p></blockquote><h1 id="859d" class="ma mb hu bd mc md me mf mg mh mi mj mk ja ml jb mm jd mn je mo jg mp jh mq mr dt translated">回到<code class="eh lw lx ly lz b">for</code>循环示例中的<code class="eh lw lx ly lz b">setTimeout()</code></h1><p id="7dc4" class="pw-post-body-paragraph jv jw hu jx b jy ms iv ka kb mt iy kd ke mu kg kh ki mv kk kl km mw ko kp kq hn dt translated">现在，我们已经从<code class="eh lw lx ly lz b">bakeCake()</code>的例子中知道了一切，我们如何修改第一个例子中的代码来添加一个闭包，并让函数打印从0到9的数字，而不是打印数字10十次？(记住10是<code class="eh lw lx ly lz b">i</code>的最后一个已知值:在循环的最后一次迭代中，该函数在控制台中记录9，然后将这个数字增加1。</p><p id="bd9f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">让我们实时看看这个函数:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mz"><img src="../Images/f92922884907691fd2602c5b7b24972a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*so9wE7298vm_3cV0.gif"/></div></div></figure><p id="402a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">下面是我们函数的代码:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="4c60" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">出于比较的目的，我们在循环的每次迭代中为<code class="eh lw lx ly lz b">i</code>计数器添加了一个简单的<code class="eh lw lx ly lz b">console.log()</code>，以及一个应该做同样事情的<code class="eh lw lx ly lz b">setTimeout()</code>函数，这次间隔为1秒。</p><p id="30eb" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">从上图中我们可以很容易地看到，<code class="eh lw lx ly lz b">setTimeout()</code>函数确实以一秒的间隔打印结果，但是<code class="eh lw lx ly lz b">i</code>的增量已经发生，当<code class="eh lw lx ly lz b">setTimeout()</code>开始运行时，<code class="eh lw lx ly lz b">i</code>在循环的每次延迟迭代中都有一个不变的值10。</p><p id="0482" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><em class="kv">我们如何摆脱困境？</em></p><p id="bddd" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">让我们应用到目前为止我们从使用闭包中学到的知识，编写一个<code class="eh lw lx ly lz b">timer()</code>函数作为<code class="eh lw lx ly lz b">setTimeout()</code>的外部函数，从这个函数中<code class="eh lw lx ly lz b">setTimeout()</code>将能够访问<code class="eh lw lx ly lz b">i</code>的值:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mx my l"/></div></figure><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mz"><img src="../Images/db11267bbe282ca6529075d76a9ac9ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D_5l2XUsSVsANrxW.gif"/></div></div></figure><p id="6cd7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">而且……它起作用了！</p><p id="0a54" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这里我们声明了一个<code class="eh lw lx ly lz b">timer()</code>函数，并将<code class="eh lw lx ly lz b">setTimeout()</code>函数包装在其中。然后，我们在循环的每次迭代中向其传递计数器的确切值，因此在每次迭代中<strong class="jx hv">“关闭】函数内</strong> <code class="eh lw lx ly lz b"><strong class="jx hv">i</strong></code> <strong class="jx hv">的值。</strong></p><p id="a668" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们也可以写:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="77f8" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在这里，我们声明一个匿名的自调用函数，并在循环的每次迭代中向它传递参数<code class="eh lw lx ly lz b">i</code>。</p><p id="cf6b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">感谢我们创建的闭包:<strong class="jx hv">我们在给定的循环迭代中捕获了</strong> <code class="eh lw lx ly lz b"><strong class="jx hv">i</strong></code> <strong class="jx hv">的值，我们<em class="kv">在函数中关闭了</em>，将值传递给</strong> <code class="eh lw lx ly lz b"><strong class="jx hv">setTimeout()</strong></code> <strong class="jx hv">，然后调用函数</strong>。</p><h1 id="3c86" class="ma mb hu bd mc md me mf mg mh mi mj mk ja ml jb mm jd mn je mo jg mp jh mq mr dt translated">结束语</h1><p id="7939" class="pw-post-body-paragraph jv jw hu jx b jy ms iv ka kb mt iy kd ke mu kg kh ki mv kk kl km mw ko kp kq hn dt translated">前端的闭包可以帮助我们实现很多事情，比如<a class="ae kr" href="http://stackoverflow.com/questions/3495679/passing-parameters-in-javascript-onclick-event" rel="noopener ugc nofollow" target="_blank">传递用户点击事件的参数</a>或者<a class="ae kr" rel="noopener" href="/@lenafaure/how-i-sort-of-got-around-the-google-maps-api-results-limit-1c673e66ef36">克服google maps API结果限制</a>。</p><p id="26c5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在您成为中级或高级JavaScript开发人员的过程中，您将会遇到闭包，现在能够发现它们，有希望使用它们，并理解一些否则没有意义的错误。</p></div><div class="ab cl kz la hc lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hn ho hp hq hr"><p id="860d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">想了解更多？查看我关于JavaScript基础的其他文章:</p><ul class=""><li id="1dcd" class="nw nx hu jx b jy jz kb kc ke ny ki nz km oa kq ob oc od oe dt translated"><a class="ae kr" href="https://hackernoon.com/hoisting-in-javascript-a-quick-guide-cc4d9597bbd7" rel="noopener ugc nofollow" target="_blank"><strong class="jx hv">JavaScript中的提升:快速指南</strong> </a></li><li id="f056" class="nw nx hu jx b jy of kb og ke oh ki oi km oj kq ob oc od oe dt translated"><a class="ae kr" href="https://hackernoon.com/understand-javascript-variable-scope-with-ease-221a6d41dc43" rel="noopener ugc nofollow" target="_blank"> <strong class="jx hv">轻松理解JavaScript变量作用域</strong> </a></li><li id="b837" class="nw nx hu jx b jy of kb og ke oh ki oi km oj kq ob oc od oe dt translated"><a class="ae kr" href="https://hackernoon.com/get-your-head-around-this-73c23653b102" rel="noopener ugc nofollow" target="_blank"><strong class="jx hv"/></a>搞清楚“这个”</li><li id="facd" class="nw nx hu jx b jy of kb og ke oh ki oi km oj kq ob oc od oe dt translated"><a class="ae kr" href="https://hackernoon.com/grasp-by-value-and-by-reference-in-javascript-7ed75efa1293" rel="noopener ugc nofollow" target="_blank"> <strong class="jx hv">掌握JavaScript </strong> </a>中的“按值”和“按引用”</li><li id="c4f4" class="nw nx hu jx b jy of kb og ke oh ki oi km oj kq ob oc od oe dt translated"><a class="ae kr" href="https://hackernoon.com/a-quick-handbook-for-dates-in-javascript-7b71d0ef8e53" rel="noopener ugc nofollow" target="_blank"><strong class="jx hv">JavaScript中的日期快速手册</strong> </a></li><li id="2784" class="nw nx hu jx b jy of kb og ke oh ki oi km oj kq ob oc od oe dt translated"><a class="ae kr" rel="noopener" href="/@lenafaure/work-with-javascript-arrays-like-a-boss-97207a042e42"> <strong class="jx hv">像老板一样使用JavaScript数组</strong> </a></li></ul></div><div class="ab cl kz la hc lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hn ho hp hq hr"><p id="4729" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我希望您喜欢这篇JavaScript闭包的介绍。</p><p id="26f2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">请随意评论并喜欢这篇文章，以便其他人可以在Medium上轻松找到它！</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><a href="http://eepurl.com/dvio9L"><div class="fe ff ok"><img src="../Images/3183c9cfe7a8644bc0a59d2e3e57fa27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*td_Zl-oX7vl2kIsoldqcLA.png"/></div></a></figure><div class="jk jl jm jn fq ab cb"><figure class="ol jo om on oo op oq paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="ol jo om on oo op oq paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="ol jo om on oo op oq paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ks kt ku"><p id="f922" class="jv jw kv jx b jy jz iv ka kb kc iy kd kw kf kg kh kx kj kk kl ky kn ko kp kq hn dt translated"><a class="ae kr" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kr" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kr" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae kr" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jv jw kv jx b jy jz iv ka kb kc iy kd kw kf kg kh kx kj kk kl ky kn ko kp kq hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kr" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kr" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff or"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="os my l"/></div></figure></div></div>    
</body>
</html>