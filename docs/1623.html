<html>
<head>
<title>A lighter pull request workflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更简单的拉式请求工作流</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-lighter-pull-request-workflow-972301e30c5?source=collection_archive---------3-----------------------#2016-11-22">https://medium.com/hackernoon/a-lighter-pull-request-workflow-972301e30c5?source=collection_archive---------3-----------------------#2016-11-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="526a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">开发团队需要优化速度。代码需要快速发送以验证想法，并且需要在反馈到来时立即投入使用。完美的代码解决了错误的问题或者发布得太晚，对公司来说是没有用的。</p><p id="e98f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是速度需要与质量相平衡，确保质量(以及共享知识和协调)的最有效工具之一是<a class="ae jp" href="http://goodmath.scientopia.org/2011/07/06/things-everyone-should-do-code-review/" rel="noopener ugc nofollow" target="_blank">代码审查</a>。</p><p id="da4b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">可悲的是，大多数现有的代码审查解决方案都过度牺牲了速度。但在过去几年尝试了各种工作流程后，我有了一些感觉非常好的东西。通过在<a class="ae jp" href="https://hackernoon.com/tagged/github" rel="noopener ugc nofollow" target="_blank"> GitHub </a>和Reviewable之上添加一些脚本，可以平衡代码审查和速度。</p><h1 id="fe34" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">拉取请求非常多</h1><p id="8254" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">拉式请求对于大型开源项目来说是一个很好的主意，在这些项目中，提交者要么接受要么拒绝整个概念，速度没有质量重要。不幸的是，GitHub的主导地位也使它们成为商业软件开发的默认工作流程，尽管它会减慢速度。拉取请求太重了。</p><ul class=""><li id="4eff" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">创建分支、保持分支同步以及分配分支以供审查的步骤太多</li><li id="103b" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">权重阻止频繁的提交，并鼓励长寿的分支</li><li id="5828" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">通知和评论界面又吵又笨重</li></ul><h1 id="50eb" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">北极星</h1><p id="3b1b" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在谷歌，我喜欢的事情之一是我们如何在master中工作，在<a class="ae jp" href="http://cacm.acm.org/magazines/2016/7/204032-why-google-stores-billions-of-lines-of-code-in-a-single-repository/fulltext" rel="noopener ugc nofollow" target="_blank"> one repo </a>中，几乎没有分支，非常频繁的提交，以及由功能标志保护的新功能。Aaron在Chromium的背景下做了很好的工作。频繁提交到master(有时称为<a class="ae jp" href="https://www.thoughtworks.com/insights/blog/enabling-trunk-based-development-deployment-pipelines" rel="noopener ugc nofollow" target="_blank">基于主干的开发</a>)有很多好处，也有一些缺点。</p><ul class=""><li id="39d5" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">避免容易出错的大型合并、嘈杂的合并提交和繁重的代码审查</li><li id="ce13" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">阻止开发人员走上任何不好的道路</li><li id="6bd7" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">鼓励团队内部和团队之间更紧密的合作</li><li id="9793" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">更有利于重构和共享所有权</li><li id="d036" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">通常允许团队更快地移动</li></ul><p id="8220" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，Google依靠定制的工具来完成这项工作，那么人们该怎么做呢？</p><h1 id="765d" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">很接近，但是没有雪茄</h1><p id="ff9a" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在Foursquare，我们使用了脸书的代码审查工具<a class="ae jp" href="https://www.phacility.com/" rel="noopener ugc nofollow" target="_blank"> Phabricator </a>。Phab表面上提供了Google风格的敏捷工作流的所有好处——审查针对master编写的代码，并在准备好的时候提交给master。但实际上，这并不令人满意。</p><ul class=""><li id="9769" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">如果你使用GitHub或其他工具做其他事情，会感觉有点混乱</li><li id="bfc7" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">配置繁琐，性能下降</li><li id="a234" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">很难将arc.sh或提交挂钩应用到您的工作流中</li><li id="bb9c" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">很难确保代码真正得到审查</li><li id="899b" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">许多现有的SaaS CI和代码质量工具只插入拉式请求</li></ul><h1 id="6749" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">中间立场</h1><p id="93c4" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">鉴于这一切，我决定在<a class="ae jp" href="https://scroll.com" rel="noopener ugc nofollow" target="_blank">卷轴</a>为我们的新工程团队找到一个中间地带。我们的解决方案使用一个shell脚本、一个Heroku上的小型go服务器和<a class="ae jp" href="https://reviewable.io" rel="noopener ugc nofollow" target="_blank"> Reviewable </a>来做一些事情。</p><ol class=""><li id="37d4" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo lh kz la lb dt translated">只有在审查代码的时候才分支，而不是在之前。(这有助于确保，在其他事情中，您通过之前使用rebase的pull与master非常接近。)</li><li id="d2b6" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo lh kz la lb dt translated">自动生成和分配拉请求，因此它是一个单一的命令行。(分配评审是确保它发生并快速发生的关键，这与简单的单一命令一起为较小的代码评审创建了一个积极的反馈循环，并提高了团队的整体速度。)</li><li id="7f38" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo lh kz la lb dt translated">确保轮到编码人员和评审人员时，他们会立即得到通知。(同样，保持高速度以保持飞轮转动。)</li></ol><h1 id="6214" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">尝试一下</h1><ul class=""><li id="96dc" class="kt ku hu it b iu ko iy kp jc li jg lj jk lk jo ky kz la lb dt translated">步骤1和2被<a class="ae jp" href="https://gist.github.com/kushal/656331109dcce1849fd7a18d52ae8ee5" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> shell脚本</strong> </a>覆盖。它假设您<a class="ae jp" href="https://github.com/settings/tokens" rel="noopener ugc nofollow" target="_blank">生成一个具有repo权限的GitHub个人令牌</a>并将其放入~/.ghtoken中。通过这种设置，开发人员在master中编写代码，当他们准备好进行代码审查时，他们就会运行。/review.sh [reviewer]，脚本与master同步，创建分支，提交任何未提交的代码，推它，生成pull请求，并分配它。</li><li id="5b22" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">没有严格要求，但我是代码评审的<a class="ae jp" href="https://reviewable.io" rel="noopener ugc nofollow" target="_blank"> Reviewable </a>的忠实粉丝，它填补了GitHub代码评审工作流程中的所有漏洞。(<a class="ae jp" href="https://twitter.com/mihai" rel="noopener ugc nofollow" target="_blank">米哈伊</a>在注意到<a class="ae jp" href="https://github.com/cockroachdb/cockroach" rel="noopener ugc nofollow" target="_blank">蟑螂</a>使用它后把这个放到了我的雷达上。)</li><li id="5e56" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">可悲的是，Reviewable缺乏Slack集成，GitHub的通知也不充分。所以步骤3被简单的<a class="ae jp" href="https://github.com/kushal/slackgitreviews" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> go程序</strong> </a>所覆盖。它使用两个环境变量进行配置:SLACKURL是您使用<a class="ae jp" href="https://api.slack.com/custom-integrations" rel="noopener ugc nofollow" target="_blank">https://api.slack.com/custom-integrations</a>上的按钮创建的webhook URL，USERMAP是一个；githublogin、slacklogin对的分隔列表，例如johnny24、johnny鲍勃，懒汉鲍勃。创建Heroku实例后，在Github中将它的URL作为webhook添加，用于发布评论和请求事件。当一个拉取请求被创建或检查时，这个脚本会得到通知，并向Slack中的正确人员发送一条直接消息。</li></ul><h1 id="f5d4" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">到目前为止，一切顺利</h1><p id="12c2" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们刚刚从这个代码工作流开始，但是到目前为止，一切都很好。我们可以审查代码，从围绕拉请求构建的所有工具中受益，并且仍然以几乎与直接提交给master相同的敏捷性前进。它并不完美，听听其他人在做什么或者这个解决方案如何为你工作会很有趣。在下面回复你的想法，在<a class="ae jp" href="https://news.ycombinator.com/item?id=13015919" rel="noopener ugc nofollow" target="_blank"> HN </a>上，或者在推特上回复<a class="ae jp" href="https://twitter.com/krave" rel="noopener ugc nofollow" target="_blank"> @krave </a>。</p><blockquote class="ll lm ln"><p id="ed98" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是AMI家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated">要了解更多信息，请阅读我们的“关于”页面、<a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">喜欢/在脸书上给我们发消息</a>，或者简单地发送<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ls lt lu lv fq lw"><div class="bz el l di"><div class="lx ly l"/></div></figure></div></div>    
</body>
</html>