<html>
<head>
<title>Squeezing Performance from SQLite: Insertions (with Room)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQLite的挤压性能:插入(带空间)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/squeezing-performance-from-sqlite-insertions-with-room-d769512f8330?source=collection_archive---------0-----------------------#2017-05-21">https://medium.com/hackernoon/squeezing-performance-from-sqlite-insertions-with-room-d769512f8330?source=collection_archive---------0-----------------------#2017-05-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="f522" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在上周的I/O大会上，谷歌宣布推出一款名为Room的新工具，它使得使用SQLite数据库变得更加容易，但它回避了一个问题:它的性能有多好？</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/9792a174b8d5bcee1e5ebbe7935dac55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F2BWPAOFRj58cfZS924lOw.jpeg"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">This Room looks nice. Let’s go in and explore a bit.</figcaption></figure><p id="2261" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是我的<a class="ae jp" rel="noopener" href="/@JasonWyatt/squeezing-performance-from-sqlite-insertions-971aff98eef2">早期插入实验结果</a>的后续。首先，我们来看几个实验的结果，这些实验将Room的相对性能与前一篇文章中讨论的实践进行了比较。然后，我将向从事这项工作的谷歌员工提供一些我自己的建议。</p><h1 id="fbe3" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">方法学</h1><p id="2d35" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">与最初的帖子一样，每个实验都涉及到比较将1000、10，000和100，000条随机生成的记录插入到两种不同类型的表中的两种或多种方法:</p><ul class=""><li id="df0b" class="lj lk hu it b iu iv iy iz jc ll jg lm jk ln jo lo lp lq lr dt translated">一个非常简单的表(<code class="eh ls lt lu lv b">simple</code>)，由一个整数列组成，并且</li><li id="f86d" class="lj lk hu it b iu lw iy lx jc ly jg lz jk ma jo lo lp lq lr dt translated">一个更真实的表格(<code class="eh ls lt lu lv b">tracks</code>)，描述了一个音乐曲目集合，每个曲目包含一个id、标题、持续时间、歌词等。<code class="eh ls lt lu lv b">id</code>列是该表的<code class="eh ls lt lu lv b">PRIMARY KEY</code>。</li></ul><p id="61d1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我还在我的16GB Nexus 5X上进行了所有测试，运行API level 25(牛轧糖)。</p><p id="ed8c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">结果是通过跟踪当前大小迭代的所有插入都在运行时所经过的时间来计算的。每次迭代之前连接到<a class="ae jp" href="https://hackernoon.com/tagged/database" rel="noopener ugc nofollow" target="_blank">数据库</a>和之后擦除表格所花费的时间从结果中排除。</p><p id="bc5f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我已经用新的测试场景使用Room更新了原始帖子中的GitHub项目。</p><h1 id="f47e" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">重要注意事项</h1><p id="572e" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">这些实验中使用的房间版本是<code class="eh ls lt lu lv b">1.0.0-alpha1</code>。</p><p id="2865" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Room要求所有的<code class="eh ls lt lu lv b">@Entity</code>类定义一个<code class="eh ls lt lu lv b">@PrimaryKey</code>值，并且不允许您退回到SQLite的默认<code class="eh ls lt lu lv b">rowid</code>主键。这意味着基于房间的<code class="eh ls lt lu lv b">simple</code>表实际上有两列:自动生成的id和实际值。</p><h2 id="7614" class="mb kh hu bd ki mc md me km mf mg mh kq jc mi mj ku jg mk ml ky jk mm mn lc mo dt translated">警告:内存问题</h2><p id="a96b" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">Room的文档建议使用<code class="eh ls lt lu lv b">@Dao</code>模式批量插入以下方法:</p><pre class="jr js jt ju fq mp lv mq mr aw ms dt"><span id="5725" class="mb kh hu lv b fv mt mu l mv mw">@Dao<br/>public interface MyDao {<br/>    @Insert<br/>    void insertAll(MyItem... items);<br/>}</span></pre><p id="7e43" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个很好的技巧，可以使向数据库中插入一堆条目变得容易，但是它确实需要为将要插入的每个条目实例化对象。</p><p id="682e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我试图创建我的<code class="eh ls lt lu lv b">TrackInfo</code>实体类的100，000个实例时，我很快耗尽了内存。为了让我的性能测试至少运行<em class="mx">次</em>，我不得不通过使用更小的<code class="eh ls lt lu lv b">TrackInfo</code>对象集合多次调用<code class="eh ls lt lu lv b">insertAll</code>来进行一些清理，这样垃圾收集器就有机会在运行之间进行清理。</p><p id="57b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">记住这一点，让我们来看看数字。</p><h1 id="e0bd" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">实验</h1><p id="b5e8" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">在检查了由Room生成的代码之后，很明显，从事这项工作的Googlers人员知道通过在事务中包装多个插入/更新/删除可以获得巨大的性能提升，所以我们将省略Room与我在最初的帖子中讨论的简单情况的比较。</p><p id="ca7e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另外:在最初的帖子中，我们发现直接使用<code class="eh ls lt lu lv b">SQLiteStatement</code>比使用<code class="eh ls lt lu lv b">db.execSQL()</code>稍微快一点，因为Room生成的插入代码使用了<code class="eh ls lt lu lv b">SQLiteStatement</code>，所以让我们比较一下苹果和苹果。</p><h2 id="2dcf" class="mb kh hu bd ki mc md me km mf mg mh kq jc mi mj ku jg mk ml ky jk mm mn lc mo dt translated">SQLiteStatement与DAO insertAll</h2><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff my"><img src="../Images/5d287b25ccc4d1f85e51b21879dd8805.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J2J8BSmNeKaJW4nhFWnoNA.png"/></div></div></figure><p id="38dd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于<code class="eh ls lt lu lv b">simple</code>的情况，Room似乎比手动使用SQLiteStatement要慢一些。然而，这可能是因为除了值之外，房间实验的简单表还需要有一个<code class="eh ls lt lu lv b">@PrimaryKey</code>字段。</p><p id="998b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，看起来Room很聪明，在多次插入中重用了SQLiteStatement对象。我在<code class="eh ls lt lu lv b">EntityInsertionAdapter.java</code>的源代码中找到了这段代码:</p><pre class="jr js jt ju fq mp lv mq mr aw ms dt"><span id="4a96" class="mb kh hu lv b fv mt mu l mv mw"><em class="mx">/**<br/> * Inserts the given entities into the database.<br/> *<br/> * </em><strong class="lv hv"><em class="mx">@param </em></strong><em class="mx">entities Entities to insert<br/> */<br/></em>public final void insert(T[] entities) {<br/>    final SupportSQLiteStatement stmt = acquire();<br/>    try {<br/>        for (T entity : entities) {<br/>            bind(stmt, entity);<br/>            stmt.executeInsert();<br/>        }<br/>    } finally {<br/>        release(stmt);<br/>    }<br/>}</span></pre><p id="5b17" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这一点点重用在插入过程中产生了很好的效果，而我最初的SQLiteStatement插入实现没有做到这一点。这使得Room插入<code class="eh ls lt lu lv b">tracks</code>记录的速度更快。</p><p id="1451" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我认为上面关于需要多次调用<code class="eh ls lt lu lv b">insertAll</code>的警告是对100，000个项目的大案例的损害。</p><h2 id="a0d7" class="mb kh hu bd ki mc md me km mf mg mh kq jc mi mj ku jg mk ml ky jk mm mn lc mo dt translated">批量SQLiteStatement vs DAO insertAll</h2><p id="27c4" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">当您将批量插入的SQLiteStatement与Room的<code class="eh ls lt lu lv b">insertAll</code>模式进行比较时会发生什么？</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff my"><img src="../Images/7f6af3075454c3f527cfad99057571da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8S1YzF84dRw_vWjZv-iwEw.png"/></div></div></figure><h1 id="4bf0" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">结论:改进的余地</h1><p id="3521" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">双关语。#抱歉抱歉</p><p id="4460" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我喜欢Room，我认为它有潜力成为一个非常强大和有用的库。在Android应用程序中使用<a class="ae jp" href="https://hackernoon.com/tagged/sqlite" rel="noopener ugc nofollow" target="_blank"> SQLite </a>将会去掉许多讨厌的样板文件，并大大加快开发速度。</p><p id="3963" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也就是说，我认为如果谷歌想要为开发者需要使用Room将大量数据插入SQLite数据库的情况提供良好的支持，他们还有一些工作要做。以下是一些建议:</p><h2 id="83a0" class="mb kh hu bd ki mc md me km mf mg mh kq jc mi mj ku jg mk ml ky jk mm mn lc mo dt translated">让@Insert DAO方法接受一个生成器</h2><p id="23ac" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">用varargs方法批量插入<code class="eh ls lt lu lv b">@Dao</code>很好，但是对于大量的对象来说还不够。我建议允许<code class="eh ls lt lu lv b">@Insert</code>带注释的方法接受迭代器或iterable，在每次插入之前调用它们来提供下一个对象。类似于以下内容:</p><pre class="jr js jt ju fq mp lv mq mr aw ms dt"><span id="6e72" class="mb kh hu lv b fv mt mu l mv mw">@Dao<br/>public interface MyDao {<br/>    @Insert<br/>    void insertAll(Iterator&lt;MyItem&gt; itemIterator);<br/>}</span></pre><p id="0de7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您从服务器上的JSON端点插入项目，通过这种方法，您可以使用一个<code class="eh ls lt lu lv b">Iterator</code>和您选择的流JSON解析器，而不必让JVM堆过载过多的对象。</p><h2 id="7fa1" class="mb kh hu bd ki mc md me km mf mg mh kq jc mi mj ku jg mk ml ky jk mm mn lc mo dt translated">实现批量插入</h2><p id="8f80" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">Google还可以通过智能地实现批量插入来大大加快批量插入的速度，在批量插入中他们会创建一个<code class="eh ls lt lu lv b">SQLiteStatement</code>。大概是这样的:</p><pre class="jr js jt ju fq mp lv mq mr aw ms dt"><span id="e450" class="mb kh hu lv b fv mt mu l mv mw">INSERT INTO my_items (...) VALUES (...), (...), ...;</span></pre><p id="268e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这可能需要一点聪明的代码生成来确定如何避免遇到SQLite允许的最大变量数的情况，以及支持SQLite的早期版本，以便应用程序不会因为您不能一次插入超过500个值而崩溃。</p><p id="2ccb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我认为这是完全可行的。</p><h2 id="7546" class="mb kh hu bd ki mc md me km mf mg mh kq jc mi mj ku jg mk ml ky jk mm mn lc mo dt translated">允许对表使用SQLite的ROWID</h2><p id="4053" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">当没有为表定义显式主键时，SQLite在内部使用<code class="eh ls lt lu lv b">ROWID</code>。目前，Room不允许您拥有没有显式主键的表。对于大多数情况来说，这可能是一件好事，但有时只使用<code class="eh ls lt lu lv b">ROWID</code>也是有意义的。</p><p id="01c1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果<code class="eh ls lt lu lv b">@Entity</code>注释有一个可以设置为不需要指定<code class="eh ls lt lu lv b">@PrimaryKey</code>的标志就好了。</p><h1 id="d06c" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">本系列的其他文章</h1><ul class=""><li id="eafd" class="lj lk hu it b iu le iy lf jc mz jg na jk nb jo lo lp lq lr dt translated"><a class="ae jp" rel="noopener" href="/@JasonWyatt/squeezing-performance-from-sqlite-insertions-971aff98eef2">插入内容</a></li><li id="1879" class="lj lk hu it b iu lw iy lx jc ly jg lz jk ma jo lo lp lq lr dt translated"><a class="ae jp" href="https://hackernoon.com/squeezing-performance-from-sqlite-explaining-the-virtual-machine-2550ef6c5db" rel="noopener ugc nofollow" target="_blank">解释虚拟机</a></li></ul><div class="jr js jt ju fq ab cb"><figure class="nc jv nd ne nf ng nh paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nc jv nd ne nf ng nh paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nc jv nd ne nf ng nh paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ni nj nk"><p id="f922" class="ir is mx it b iu iv iw ix iy iz ja jb nl jd je jf nm jh ji jj nn jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是AMI家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is mx it b iu iv iw ix iy iz ja jb nl jd je jf nm jh ji jj nn jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff no"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="np nq l"/></div></figure></div></div>    
</body>
</html>