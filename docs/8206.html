<html>
<head>
<title>Analyzing Ethereum smart contracts for vulnerabilities</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分析以太坊智能合约的漏洞</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/scanning-ethereum-smart-contracts-for-vulnerabilities-b5caefd995df?source=collection_archive---------5-----------------------#2017-11-23">https://medium.com/hackernoon/scanning-ethereum-smart-contracts-for-vulnerabilities-b5caefd995df?source=collection_archive---------5-----------------------#2017-11-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="2721" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp"/><a class="ae jq" href="https://mythx.io" rel="noopener ugc nofollow" target="_blank"><em class="jp">MythX</em></a><em class="jp">的创造者伯恩哈德·穆勒(Bernhard Mueller)展示了如何检测以太坊智能合约中的漏洞。</em></p><p id="b27f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面，我们将运行<a class="ae jq" href="https://github.com/ConsenSys/mythril-classic/" rel="noopener ugc nofollow" target="_blank"> Mythril </a>一些来自<a class="ae jq" href="https://ethernaut.zeppelin.solutions/" rel="noopener ugc nofollow" target="_blank"> Ethernaut wargame </a>的故意易受攻击的合同(感谢<a class="ae jq" href="https://zeppelin.solutions" rel="noopener ugc nofollow" target="_blank"> Zeppelin solutions </a>的家伙给我许可！).如果你没有亲自尝试过wargame，请注意前方有剧透！如果你还没有尝试过，我建议你自己先尝试一下。</p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="fe ff jr"><img src="../Images/10bdb8f0b86699b270b204f55faf0378.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SZQT3hS2BBKqjnDA8J0xOA.jpeg"/></div></div></figure><h1 id="dd9c" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">代币</h1><p id="2eaa" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">以太网的第三级的目标是破解一个名为<code class="eh lg lh li lj b">Token</code>的基本令牌契约。检查<a class="ae jq" href="https://ethernaut.zeppelin.solutions/level/0x220beee334f1c1f8078352d88bcc4e6165b792f6" rel="noopener ugc nofollow" target="_blank">代码</a>，看看你是否能发现这个错误。</p><p id="d0a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用Mythril分析智能合约时，您可以从三个输入选项中进行选择:</p><ol class=""><li id="0bbd" class="lk ll hu it b iu iv iy iz jc lm jg ln jk lo jo lp lq lr ls dt translated">坚固性代码文件:这只有在安装了<a class="ae jq" href="http://solidity.readthedocs.io/en/develop/using-the-compiler.html" rel="noopener ugc nofollow" target="_blank"> solc命令行编译器</a>的情况下才有效。</li><li id="12d9" class="lk ll hu it b iu lt iy lu jc lv jg lw jk lx jo lp lq lr ls dt translated">Solidity字节码:如果没有solc，可以用<a class="ae jq" href="http://remix.ethereum.org/" rel="noopener ugc nofollow" target="_blank"> Remix </a>编译代码，并通过<code class="eh lg lh li lj b">-c</code>参数将运行时二进制代码传递给Mythril。</li><li id="5f5b" class="lk ll hu it b iu lt iy lu jc lv jg lw jk lx jo lp lq lr ls dt translated">合同地址:要扫描区块链上的合同实例，请使用<code class="eh lg lh li lj b">-a ADDRESS</code>选项。</li></ol><p id="2211" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我将使用下面的选项1——有关其他输入选项的详细说明，请查看<a class="ae jq" href="https://github.com/b-mueller/mythril/blob/master/README.md" rel="noopener ugc nofollow" target="_blank">自述文件</a>。</p><p id="d5f0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">将代码复制/粘贴到文本文件中，保存为<code class="eh lg lh li lj b">ethernaut-token.sol</code>，然后运行<code class="eh lg lh li lj b">myth analyze</code>命令。Mythril在控制台上输出检测到的问题:</p><pre class="js jt ju jv fq ly lj lz ma aw mb dt"><span id="060e" class="mc ke hu lj b fv md me l mf mg">$ myth analyze token.sol <br/>==== Integer Underflow ====<br/>SWC ID: 101<br/>Severity: High<br/>Contract: Token<br/>Function name: transfer(address,uint256)<br/>PC address: 436<br/>Estimated Gas Usage: 11935 - 52881<br/>The binary subtraction can underflow.<br/>The operands of the subtraction operation are not sufficiently constrained. The subtraction could therefore result in an integer underflow. Prevent the underflow by checking inputs or ensure sure that the underflow is caught by an assertion.<br/>--------------------<br/>In file: token.sol:13</span><span id="0ebc" class="mc ke hu lj b fv mh me l mf mg">balances[msg.sender] - _value</span><span id="dbae" class="mc ke hu lj b fv mh me l mf mg">--------------------<br/>(etc...)</span></pre><p id="dcfe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这种情况下，Mythril在函数<code class="eh lg lh li lj b">transfer</code>中检测到一个整数溢出和两个整数下溢问题。让我们看一下代码，看看发生了什么:</p><pre class="js jt ju jv fq ly lj lz ma aw mb dt"><span id="fcb5" class="mc ke hu lj b fv md me l mf mg">function transfer(address _to, uint _value) public returns (bool) {<br/>  require(balances[msg.sender] — _value &gt;= 0);<br/>  balances[msg.sender] -= _value;<br/>  balances[_to] += _value;<br/>  return true;<br/>}</span></pre><p id="10b8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以看到，如果<code class="eh lg lh li lj b">_value</code>大于<code class="eh lg lh li lj b">balances[msg.sender]</code>，那么<code class="eh lg lh li lj b">balances[msg.sender] — _value</code>确实会换行。在这种情况下，发送者将会得到天文数字的代币！</p><h1 id="7939" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">余波</h1><p id="964f" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">这是以太挑战的第二关。先看看代码——问题并不难发现！</p><p id="4c01" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是Mythril对此的看法:</p><pre class="js jt ju jv fq ly lj lz ma aw mb dt"><span id="6a50" class="mc ke hu lj b fv md me l mf mg">$ myth analyze fallout.sol<br/>==== Unprotected Ether Withdrawal ====<br/>SWC ID: 105<br/>Severity: High<br/>Contract: Fallout<br/>Function name: collectAllocations()<br/>PC address: 934<br/>Estimated Gas Usage: 1880 - 36491<br/>Anyone can withdraw ETH from the contract account.</span><span id="4e6a" class="mc ke hu lj b fv mh me l mf mg">Arbitrary senders other than the contract creator can withdraw ETH from the contract account without previously having sent an equivalent amount of ETH to it. This is likely to be a vulnerability.<br/>--------------------<br/>In file: fallout.sol:159</span><span id="52d4" class="mc ke hu lj b fv mh me l mf mg">msg.sender.transfer(address(this).balance)<br/>--------------------</span><span id="32da" class="mc ke hu lj b fv mh me l mf mg">Initial State:</span><span id="800a" class="mc ke hu lj b fv mh me l mf mg">Account: [CREATOR], balance: 0x1000001328abc1e, nonce:0, storage:{}<br/>Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}<br/>Account: [SOMEGUY], balance: 0x500d18006a4060402, nonce:0, storage:{}</span><span id="d2af" class="mc ke hu lj b fv mh me l mf mg">Transaction Sequence:</span><span id="1012" class="mc ke hu lj b fv mh me l mf mg">Caller: [CREATOR], calldata: , value: 0x0<br/>Caller: [ATTACKER], function: Fal1out(), txdata: 0x6fab5ddf, value: 0x0<br/>Caller: [ATTACKER], function: collectAllocations(), txdata: 0x8aa96f38, value: 0x0</span></pre><p id="aac1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Mythril声称可以使用函数<code class="eh lg lh li lj b">collectAllocations()</code>从合同中撤销ETH。但是这个功能不是被<code class="eh lg lh li lj b">onlyOwner</code>修饰符保护着吗？注意<em class="jp">两个</em>交易显示在“交易顺序”部分。这些是触发漏洞的函数调用序列。第一个事务调用名为<code class="eh lg lh li lj b">Fal1out()</code>的函数，第二个事务调用<code class="eh lg lh li lj b">collectAllocations()</code>。</p><p id="767f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">记住这一点，再仔细看看源代码。您可能会注意到构造函数名称与契约名称略有不同，因此编译成一个常规的公共函数，任何人都可以调用它来设置新的所有者！这类似于<a class="ae jq" href="https://blog.ethereum.org/2016/06/19/thinking-smart-contract-security/" rel="noopener ugc nofollow" target="_blank"> Rubixi漏洞</a>。</p><h2 id="90c5" class="mc ke hu bd kf mi mj mk kj ml mm mn kn jc mo mp kr jg mq mr kv jk ms mt kz mu dt translated">委托</h2><p id="cabc" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">以太网的第4级是一个多合同场景。幸运的是，Mythril可以处理多个契约，并理解契约之间各种类型的消息调用。当您在区块链上分析合同时，Mythril可以在运行时自动检测并下载依赖项。</p><p id="6b70" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了进行测试，我在本地<a class="ae jq" href="https://truffleframework.com/ganache" rel="noopener ugc nofollow" target="_blank"> Ganache </a>实例上部署了<code class="eh lg lh li lj b">Delegate</code>和<code class="eh lg lh li lj b">Delegation</code>契约。链接是通过将<code class="eh lg lh li lj b">Delegation</code>实例的地址传递给<code class="eh lg lh li lj b">Delegate</code>的构造函数来完成的。</p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="fe ff mv"><img src="../Images/3328c8b13615509eb1295666941f78db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7tnO0JWknbUPZzNAqhF4ow.jpeg"/></div></div></figure><p id="f486" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用<code class="eh lg lh li lj b">-a ADDRESS</code>参数启动链上分析。下面显示的命令还包括三个附加标志:</p><ul class=""><li id="31ca" class="lk ll hu it b iu iv iy iz jc lm jg ln jk lo jo mw lq lr ls dt translated"><code class="eh lg lh li lj b">--rpc ganache</code>激活Ganache RPC预置；</li><li id="4c90" class="lk ll hu it b iu lt iy lu jc lv jg lw jk lx jo mw lq lr ls dt translated"><code class="eh lg lh li lj b">-l</code>激活动态加载器。这告诉Mythril还要检索和扫描任何附加的引用合同；</li><li id="bdc7" class="lk ll hu it b iu lt iy lu jc lv jg lw jk lx jo mw lq lr ls dt translated"><code class="eh lg lh li lj b">-v4</code>激活信息调试输出。这将让我们对加载程序正在做什么有一些了解。</li></ul><pre class="js jt ju jv fq ly lj lz ma aw mb dt"><span id="e0fd" class="mc ke hu lj b fv md me l mf mg">$ myth -v4 --rpc ganache analye -la 0x64e1b27e8dbd44769dc8f43cb78447760b1bc1f0</span><span id="a941" class="mc ke hu lj b fv mh me l mf mg">INFO:root:SVM initialized with dynamic loader: &lt;mythril.support.loader.DynLoader object at 0x102329ef0&gt;<br/>INFO:root:Dynld at contract 0x64e1b27e8dbd44769dc8f43cb78447760b1bc1f0: Concat(0, Extract(167, 8, storage_1))<br/><strong class="lj hv">INFO:root:Dynamic contract address at storage index 1</strong><br/>INFO:root:Dependency address: 0x28241019d1b3b2b3763a9d4c7f37fca8ab02e449<br/><strong class="lj hv">INFO:root:DELEGATECALL to: 0x28241019d1b3b2b3763a9d4c7f37fca8ab02e449</strong><br/>INFO:root:Unsupported symbolic calldata offset<br/><strong class="lj hv">INFO:root:- Entering function 0x28241019d1b3b2b3763a9d4c7f37fca8ab02e449:owner()<br/></strong><br/>(...)</span><span id="1c61" class="mc ke hu lj b fv mh me l mf mg">INFO:root:Execution complete, saved 374 states<br/>INFO:root:38 nodes, 37 edges<br/>INFO:root:Resolving paths<br/>INFO:root:Analyzing storage operations...</span><span id="3335" class="mc ke hu lj b fv mh me l mf mg">==== Unchecked CALL return value ====<br/>Type: Informational<br/>Contract: 0x64e1b27e8dbd44769dc8f43cb78447760b1bc1f0<br/>Function name: main<br/>PC address: 171</span><span id="f7c7" class="mc ke hu lj b fv mh me l mf mg">The function main contains a call to an address obtained from storage.</span><span id="5d5e" class="mc ke hu lj b fv mh me l mf mg">The return value of this call is not checked. Note that the function will continue to execute with a return value of '0' if the called contract throws.</span><span id="cd79" class="mc ke hu lj b fv mh me l mf mg">--------------------</span><span id="fc3f" class="mc ke hu lj b fv mh me l mf mg">==== CALLDATA forwarded with delegatecall() ====<br/>Type: Informational<br/>Contract: 0x64e1b27e8dbd44769dc8f43cb78447760b1bc1f0<br/>Function name: main<br/>PC address: 171</span><span id="e760" class="mc ke hu lj b fv mh me l mf mg">This contract forwards its calldata via DELEGATECALL in its fallback function. This means that any function in the called contract can be executed. Note that the callee contract will have access to the storage of the calling contract.</span><span id="e468" class="mc ke hu lj b fv mh me l mf mg">DELEGATECALL target: Concat(0, Extract(167, 8, storage_1))</span><span id="47ab" class="mc ke hu lj b fv mh me l mf mg">--------------------</span></pre><p id="47fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里发现了两个问题:</p><ul class=""><li id="217b" class="lk ll hu it b iu iv iy iz jc lm jg ln jk lo jo mw lq lr ls dt translated">在<code class="eh lg lh li lj b">main</code> (fallback)函数中未检查的<code class="eh lg lh li lj b">CALL</code>返回值。这看起来很奇怪，因为我们可以清楚地看到回退函数中的<code class="eh lg lh li lj b">delegatecall()</code>被包装在一个<code class="eh lg lh li lj b">if</code>语句中。然而，如果你检查反汇编，你会发现编译器优化了这一点。</li><li id="35e1" class="lk ll hu it b iu lt iy lu jc lv jg lw jk lx jo mw lq lr ls dt translated"><code class="eh lg lh li lj b">CALLDATA</code>用<code class="eh lg lh li lj b">delegatecall()</code>转发:Mythril还警告要通过<code class="eh lg lh li lj b">DELEGATECALL</code>转发<code class="eh lg lh li lj b">msg.data</code>，并指出可以执行被调用契约中的任意函数。</li></ul><p id="d0d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Mythril似乎忽略了一个事实，即通过调用<code class="eh lg lh li lj b">pwn()</code>函数可以覆盖<code class="eh lg lh li lj b">_owner</code>状态变量。这是为什么呢？如果您考虑这两个契约的整体逻辑，您会注意到，即使更改名为<code class="eh lg lh li lj b">_owner</code>的状态变量看起来很关键，但它没有任何进一步的含义(即，它不允许您做任何您本来不可能做的事情)，因此Mythril不认为这是一个漏洞。</p><h1 id="3a5b" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">关于Mythril和MythX</h1><p id="621b" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">Mythril 是一款免费的开源智能合同安全分析器。它使用符号执行来检测各种安全漏洞。</p><p id="405d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jq" href="https://mythx.io" rel="noopener ugc nofollow" target="_blank"> MythX </a>是一种基于云的智能合约安全服务，可以无缝集成到智能合约开发环境中并构建管道。它将多个领先的安全分析流程捆绑到一个易于使用的API中，允许任何人创建专门构建的智能合同安全工具。MythX兼容以太坊、Tron、Vechain、Quorum、Roostock和其他基于EVM的平台。</p></div></div>    
</body>
</html>