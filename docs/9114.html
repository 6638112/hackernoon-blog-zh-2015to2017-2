<html>
<head>
<title>My process became PID 1 and now signals behave strangely</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我的进程变成PID 1，现在信号表现奇怪</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/my-process-became-pid-1-and-now-signals-behave-strangely-b05c52cc551c?source=collection_archive---------5-----------------------#2017-12-27">https://medium.com/hackernoon/my-process-became-pid-1-and-now-signals-behave-strangely-b05c52cc551c?source=collection_archive---------5-----------------------#2017-12-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="c884" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者让我们编写自己的初始化进程</p><p id="eab4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当您的流程在Docker容器中作为<a class="ae jp" href="https://hackernoon.com/tagged/pid" rel="noopener ugc nofollow" target="_blank"> PID </a> 1运行时，信号处理的行为可能与您预期的不同。</p><p id="4991" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先让我们检查当一个进程在“正常”系统上不是PID 1时会发生什么。</p><p id="4734" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个简单的<a class="ae jp" href="https://hackernoon.com/tagged/python" rel="noopener ugc nofollow" target="_blank"> Python </a>进程只是休眠</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="3a5a" class="jz ka hu jv b fv kb kc l kd ke">Aarons-iMac:bin aaronkalair$ cat mypy.py<br/>import subprocess</span><span id="eafd" class="jz ka hu jv b fv kf kc l kd ke">subprocess.call(["sleep", "100"])</span></pre><p id="a43c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们运行它并发送<code class="eh kg kh ki jv b">SIGTERM</code></p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="1105" class="jz ka hu jv b fv kb kc l kd ke">Aarons-iMac:init-proc aaronkalair$ ps -ef | grep python<br/>  501 <strong class="jv hv">14013</strong>  6588   0  2:08pm ttys004    0:00.02 <strong class="jv hv">python mypy.py</strong></span><span id="f4d9" class="jz ka hu jv b fv kf kc l kd ke">Aarons-iMac:bin aaronkalair$ <strong class="jv hv">kill 14013</strong><br/><strong class="jv hv">Terminated: 15</strong></span></pre><p id="72dc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它被终止了，这没什么奇怪的</p><p id="c999" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们在Docker容器中将它作为PID 1运行</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="d211" class="jz ka hu jv b fv kb kc l kd ke">Aarons-iMac:bin aaronkalair$ cat Dockerfile<br/>from ubuntu:16.04</span><span id="60c8" class="jz ka hu jv b fv kf kc l kd ke">RUN apt-get update<br/>RUN apt-get install -y python<br/>COPY mypy.py /srv/</span><span id="57a8" class="jz ka hu jv b fv kf kc l kd ke">CMD ["python", "/srv/mypy.py"]</span></pre><p id="f995" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">运行这个容器，执行，然后发送相同的信号</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="b6a6" class="jz ka hu jv b fv kb kc l kd ke">Aarons-iMac:init-proc aaronkalair$ docker exec -it 0229aa205b48 bash</span><span id="6833" class="jz ka hu jv b fv kf kc l kd ke">root@0229aa205b48:/# ps -ef<br/>UID        PID  PPID  C STIME TTY          TIME CMD<br/>root         <strong class="jv hv">1</strong>     0  0 14:15 ?        00:00:00 <strong class="jv hv">python /srv/mypy.py</strong><br/>root         7     1  0 14:15 ?        00:00:00 sleep 100</span><span id="4eb4" class="jz ka hu jv b fv kf kc l kd ke">root@0229aa205b48:/# <strong class="jv hv">kill 1</strong></span><span id="2d45" class="jz ka hu jv b fv kf kc l kd ke">root@0229aa205b48:/# ps -ef<br/>UID        PID  PPID  C STIME TTY          TIME CMD<br/>root         <strong class="jv hv">1</strong>     0  0 14:15 ?        00:00:00 <strong class="jv hv">python /srv/mypy.py</strong><br/>root         7     1  0 14:15 ?        00:00:00 sleep 100</span></pre><p id="aed6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在什么都没发生！</p><p id="fb87" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们用一个类似的Go流程来尝试一下</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="703c" class="jz ka hu jv b fv kb kc l kd ke">package main</span><span id="b10e" class="jz ka hu jv b fv kf kc l kd ke">import (<br/>    "time"<br/>)</span><span id="9621" class="jz ka hu jv b fv kf kc l kd ke">func main() {<br/>    time.Sleep(time.Duration(100000) * time.Millisecond)<br/>}</span></pre><p id="b428" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">将它放入Docker容器，运行它，执行并发送它<code class="eh kg kh ki jv b">SIGTERM</code></p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="50d4" class="jz ka hu jv b fv kb kc l kd ke">Aarons-iMac:init-proc aaronkalair$ docker exec -it e6ccf11be060 bash</span><span id="a7aa" class="jz ka hu jv b fv kf kc l kd ke">root@e6ccf11be060:/# ps -ef<br/>UID        PID  PPID  C STIME TTY          TIME CMD<br/>root         <strong class="jv hv">1</strong>     0  0 14:28 ?        00:00:00 <strong class="jv hv">./srv/sleep-spawner</strong></span><span id="1043" class="jz ka hu jv b fv kf kc l kd ke">root@e6ccf11be060:/# <strong class="jv hv">kill 1</strong></span><span id="fb2b" class="jz ka hu jv b fv kf kc l kd ke">root@e6ccf11be060:/# <strong class="jv hv">Aarons-iMac:init-proc aaronkalair$</strong></span></pre><p id="7513" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它被杀死了，就像它没有作为PID 1运行时一样</p><p id="71d0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么这到底是怎么回事？</p><p id="78b5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">PID 1在Linux中很特殊，除了别的以外，它忽略任何信号，除非明确声明了该信号的处理程序。来自Docker docs—<a class="ae jp" href="https://docs.docker.com/engine/reference/run/#foreground" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/engine/reference/run/#foreground</a></p><blockquote class="kj kk kl"><p id="7e58" class="ir is km it b iu iv iw ix iy iz ja jb kn jd je jf ko jh ji jj kp jl jm jn jo hn dt translated"><strong class="it hv"> <em class="hu">注意</em></strong><em class="hu">:Linux对容器内运行为PID 1的进程进行了特殊处理:它会忽略任何带有默认动作的信号。因此，进程不会在</em> <code class="eh kg kh ki jv b"><em class="hu">SIGINT</em></code> <em class="hu">或</em> <code class="eh kg kh ki jv b"><em class="hu">SIGTERM</em></code> <em class="hu">上终止，除非它被编码为这样做。</em></p></blockquote><p id="886d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以在我们想要在Docker容器中运行的每个进程中为这些信号定义处理程序，但是这需要大量的工作，而且我们可能没有源代码来完成。此外，PID 1还有其他职责，我们将在后面探讨。</p><p id="86bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，我们可以运行一个不同的进程作为PID 1，并让它向我们想要运行的实际进程发送代理信号，并执行标准init进程的其他任务</p><p id="444a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有许多解决方案可以做到这一点，例如</p><p id="f072" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">https://github.com/Yelp/dumb-init的叫声<code class="eh kg kh ki jv b">dumb-init</code></p><p id="1fa9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kg kh ki jv b">Tini</code>随Docker—<a class="ae jp" href="https://docs.docker.com/engine/reference/run/#specify-an-init-process" rel="noopener ugc nofollow" target="_blank">https://docs . Docker . com/engine/reference/run/# specify-an-init-process</a></p><p id="e893" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以通过搜索找到更多。</p><p id="43ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是我要写我自己的…</p><p id="0d5d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们从基础开始，我需要一个程序，用另一个进程的名字来执行它</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="89c6" class="jz ka hu jv b fv kb kc l kd ke">func main() {<br/>    cmd := exec.Command(os.Args[1], os.Args[2:]...)<br/>    err := cmd.Start()<br/>    if err != nil {<br/>        panic(err)<br/>    }<br/>    err = cmd.Wait()<br/>    if err != nil {<br/>        panic(err)<br/>    }<br/>}</span></pre><p id="8750" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">关于我们如何做到这一点，需要注意一些重要的事情，因为这在以后会很重要。</p><p id="37e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们<code class="eh kg kh ki jv b">Start()</code>我们称之为<code class="eh kg kh ki jv b">Wait()</code>的新进程之后，这很重要，它将一直阻塞，直到命令退出，并且一旦它退出，就清理与之相关的任何资源。</p><p id="1241" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">无法在您生成的进程上<code class="eh kg kh ki jv b">wait</code>会导致僵尸进程，一旦它们执行完消耗了一些资源，就会停滞不前。</p><p id="ee58" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">来自手册页—<a class="ae jp" href="http://man7.org/linux/man-pages/man2/waitpid.2.html#NOTES" rel="noopener ugc nofollow" target="_blank">http://man7.org/linux/man-pages/man2/waitpid.2.html#NOTES</a></p><blockquote class="kj kk kl"><p id="28fa" class="ir is km it b iu iv iw ix iy iz ja jb kn jd je jf ko jh ji jj kp jl jm jn jo hn dt translated">一个终止了，却没有被等待的孩子，就变成了“僵尸”。内核维护关于僵尸进程的最小信息集(PID、终止状态、资源使用信息),以便允许父进程稍后执行等待以获得关于子进程的信息。只要僵尸没有通过等待从系统中移除，它就会消耗内核进程表中的一个槽，如果这个表填满了，就不可能创建进一步的进程。</p></blockquote><p id="2558" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，让我们尝试一下我们的新信号代理，如果我们在容器中运行它…</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="1028" class="jz ka hu jv b fv kb kc l kd ke">CMD ["./srv/init-proc", "/srv/sleep-spawner", "1"]</span></pre><p id="680e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以看到我们的代理进程现在是PID 1，并产生了睡眠产卵器</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="b8a3" class="jz ka hu jv b fv kb kc l kd ke">root@36c4892039db:/# ps -ef<br/>UID        PID  PPID  C STIME TTY          TIME CMD<br/>root         <strong class="jv hv">1</strong>     0  0 17:45 ?        00:00:00 <strong class="jv hv">./srv/init-proc /srv/sleep-spawner 1</strong><br/>root        <strong class="jv hv">11</strong>     1  0 17:45 ?        00:00:00 <strong class="jv hv">/srv/sleep-spawner 1</strong></span></pre><p id="2246" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好的，下一步是注册我们对所有可能的信号感兴趣</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="bb17" class="jz ka hu jv b fv kb kc l kd ke">func main() {<br/>    signalChannel := make(chan os.Signal, 2)<br/>    signal.Notify(signalChannel)<br/>    pid := -1</span><span id="e1e9" class="jz ka hu jv b fv kf kc l kd ke">    go sigHandler(&amp;pid, signalChannel)</span><span id="c4ed" class="jz ka hu jv b fv kf kc l kd ke">    cmd := exec.Command(os.Args[1], os.Args[2:]...)<br/>    err := cmd.Start()<br/>    pid = cmd.Process.Pid</span><span id="6f4a" class="jz ka hu jv b fv kf kc l kd ke">    if err != nil {<br/>        panic(err)<br/>    }<br/>    err = cmd.Wait()<br/>    if err != nil {<br/>        panic(err)<br/>    }<br/>}</span></pre><p id="bc87" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">用<code class="eh kg kh ki jv b">sigHandler</code>定义为:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="15e1" class="jz ka hu jv b fv kb kc l kd ke">func sigHandler(pid *int, signalChannel chan os.Signal) {<br/>    var sigToSend syscall.Signal = syscall.SIGHUP<br/>    for {<br/>        sig := &lt;-signalChannel<br/>        switch sig {<br/>            // #1 - Sent went the controlling terminal is closed,          typically used by daemonised processes to reload config<br/>            case syscall.SIGHUP:<br/>                sigToSend = syscall.SIGHUP<br/>            // #2 - Like pressing CTRL+C<br/>            case syscall.SIGINT:<br/>                sigToSend = syscall.SIGINT<br/>            ..... <br/>                repeat for all signals<br/>        }<br/>        <strong class="jv hv">syscall.Kill(*pid, sigToSend)</strong><br/>    }<br/>}</span></pre><p id="335b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它只是打开Go支持的所有信号—<a class="ae jp" href="https://golang.org/pkg/syscall/#pkg-constants" rel="noopener ugc nofollow" target="_blank">https://golang.org/pkg/syscall/#pkg-constants</a></p><p id="f9e0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后使用<code class="eh kg kh ki jv b">kill</code>系统调用将信号发送给正在运行的进程。</p><p id="02c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们用它来运行我们的Python程序，看看它是否正确地处理了SIGTERM。</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="a008" class="jz ka hu jv b fv kb kc l kd ke">Aarons-iMac:init-proc aaronkalair$ docker exec -it 579ef1d3ce77 bash</span><span id="6a2f" class="jz ka hu jv b fv kf kc l kd ke">root@579ef1d3ce77:/# ps -ef<br/>UID        PID  PPID  C STIME TTY          TIME CMD<br/>root         <strong class="jv hv">1</strong>     0  0 18:33 ?        00:00:00 <strong class="jv hv">./srv/init-proc </strong>python /srv/mypy.py<br/>root        <strong class="jv hv">13</strong>     1  0 18:33 ?        00:00:00 <strong class="jv hv">python /srv/mypy.py</strong><br/>root        14    13  0 18:33 ?        00:00:00 sleep 100</span><span id="c34d" class="jz ka hu jv b fv kf kc l kd ke">root@579ef1d3ce77:/# <strong class="jv hv">kill 1</strong></span><span id="0a1e" class="jz ka hu jv b fv kf kc l kd ke">root@579ef1d3ce77:/# <strong class="jv hv">Aarons-iMac:init-proc aaronkalair$</strong></span></pre><p id="73bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">而且很管用！</p><p id="1ed3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们来关注PID 1负责的另一件事，清理僵尸进程。</p><p id="f805" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">想象一下这个场景</p><p id="351e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">A —产卵-&gt; B —产卵-&gt; C</p><p id="82de" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在如果B在C之前死亡或退出，C就成了孤儿进程，那么C现在的父进程是谁？</p><p id="d6f0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">操作系统负责将孤立进程重命名为PID 1，所以现在看起来像这样</p><p id="44bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">A —是-&gt; C的父级</p><p id="6632" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在当C退出时，A将接收到<code class="eh kg kh ki jv b">SIGCHILD</code>信号，并负责调用C上的<code class="eh kg kh ki jv b">wait</code>来清理这个僵尸进程。</p><p id="0aa7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，让我们将这个逻辑添加到SIGCHILD案例中:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="e11b" class="jz ka hu jv b fv kb kc l kd ke">case syscall.SIGCHLD:<br/>    var status syscall.WaitStatus<br/>    var rusage syscall.Rusage<br/><strong class="jv hv">    syscall.Wait4(-1, &amp;status, syscall.WNOHANG, &amp;rusage)<br/></strong>    sigToSend = syscall.SIGCHLD</span></pre><p id="45f0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kg kh ki jv b">-1</code>意味着等待任何一个子进程改变状态，而不是等待一个特定的子进程改变状态，因为我们不知道收到信号时已经退出的进程的ID</p><p id="d57c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kg kh ki jv b">WNOHANG</code>表示如果没有子进程改变了状态，不要阻塞等待，立即返回</p><p id="87fc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对终止的子进程执行<code class="eh kg kh ki jv b">wait</code>会清理它的资源，防止它成为僵尸进程</p><p id="0826" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">来自<code class="eh kg kh ki jv b">wait</code>联机帮助页—<a class="ae jp" href="http://man7.org/linux/man-pages/man2/waitpid.2.html" rel="noopener ugc nofollow" target="_blank">http://man7.org/linux/man-pages/man2/waitpid.2.html</a></p><blockquote class="kj kk kl"><p id="8e71" class="ir is km it b iu iv iw ix iy iz ja jb kn jd je jf ko jh ji jj kp jl jm jn jo hn dt translated">在终止孩子的情况下，执行等待允许系统释放与孩子相关联的资源；如果不执行等待，那么被终止的子进程将保持“僵死”状态</p></blockquote><p id="dcbd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在只剩下一个案子要处理了想象一下:</p><p id="1e1f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">A —产卵-&gt; B —产卵-&gt; C</p><p id="caec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在C退出了，但是B没有调用wait on</p><p id="a25d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">a-父-&gt; B-父-&gt; C(已失效的僵停进程)</p><p id="4e6c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kg kh ki jv b">wait</code>只作用于子进程，所以不管我们的初始化进程A调用<code class="eh kg kh ki jv b">wait</code>多少次，它都不会清理C正在使用的资源。(请注意，<code class="eh kg kh ki jv b">SIGCHILD</code>只会被发送到B，所以A甚至不会意识到C的退出)</p><p id="46b2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在B退出，A接收到<code class="eh kg kh ki jv b">SIGCHILD</code>调用<code class="eh kg kh ki jv b">wait</code>，B被很好地清理。</p><p id="8301" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">c现在是一个孤儿，被重配置为A，所以我们有</p><p id="75ce" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">A —是-&gt; C(已失效的僵尸进程)的父进程</p><p id="41af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以看到上面的动作，对我们的睡眠程序做了一些修改，产生了父母在孩子之前退出并且不调用<code class="eh kg kh ki jv b">wait</code>的过程</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="0e74" class="jz ka hu jv b fv kb kc l kd ke">func main() {<br/>    MAX_LEVEL := 4</span><span id="bc00" class="jz ka hu jv b fv kf kc l kd ke">level, err := strconv.Atoi(os.Args[1])<br/>    if err != nil {<br/>        panic(err)<br/>    }</span><span id="e650" class="jz ka hu jv b fv kf kc l kd ke">// We'll have a bunch of processes that immediately exit at the max level<br/>    if level == MAX_LEVEL {<br/>        return<br/>    }</span><span id="ec4c" class="jz ka hu jv b fv kf kc l kd ke">// Need the top level to outlive the others, otherwise the container would exit and you wouldn't be able to inspect the process tree<br/>    sleepTime := 0<br/>    if level == 1 {<br/>        sleepTime = 20000000<br/>    } else {<br/>    // Generate proceses where children sleep for longer than there parents so parents exit first without waiting on the children showing what happens to orphan / zombie processes<br/>        sleepTime = level * 1000<br/>    }</span><span id="c1a3" class="jz ka hu jv b fv kf kc l kd ke">level += 1<br/>    for i := 0; i &lt; 2; i++ {<br/>        // Spawn a command and intentionally dont wait on it<br/>        err := exec.Command("/srv/sleep-spawner", strconv.Itoa(level)).Start()<br/>        if err != nil {<br/>            panic(err)<br/>        }<br/>    }<br/>    time.Sleep(time.Duration(sleepTime) * time.Millisecond)<br/>}</span></pre><p id="29c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Github上可以找到，这里是<a class="ae jp" href="https://github.com/AaronKalair/sleep-spawner" rel="noopener ugc nofollow" target="_blank">https://github.com/AaronKalair/sleep-spawner</a></p><p id="22a6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们运行它，我们可以看到流程树的样子:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="5097" class="jz ka hu jv b fv kb kc l kd ke">Aarons-iMac:init-proc aaronkalair$ docker exec -it 854a232d4b89 bash<br/>root@854a232d4b89:/# ps -ef<br/>UID        PID  PPID  C STIME TTY          TIME CMD<br/>root         1     0  0 22:13 ?        00:00:00 ./srv/init-proc /srv/sleep-spawner 1<br/>root        12     1  0 22:13 ?        00:00:00 /srv/sleep-spawner 1<br/>root        17    12  0 22:13 ?        00:00:00 <strong class="jv hv">[sleep-spawner] &lt;defunct&gt;</strong><br/>root        22    12  0 22:13 ?        00:00:00 <strong class="jv hv">[sleep-spawner] &lt;defunct&gt;</strong><br/>root        32     1  0 22:13 ?        00:00:00 <strong class="jv hv">[sleep-spawner] &lt;defunct&gt;</strong></span></pre><p id="ecc6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们当前的实现中，这种情况将永远存在，因此我们需要对其稍加修改，以处理如下情况:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="e6ee" class="jz ka hu jv b fv kb kc l kd ke">case syscall.SIGCHLD:<br/>    var status syscall.WaitStatus<br/>    var rusage syscall.Rusage<br/>    for {<br/>        retValue, err := syscall.Wait4(-1, &amp;status, syscall.WNOHANG, &amp;rusage)<br/>        if err != nil {<br/>            panic(err)<br/>        }<br/>        if retValue &lt;= 0 {<br/>            break<br/>        }<br/>   }<br/>   sigToSend = syscall.SIGCHLD</span></pre><p id="3254" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当与<code class="eh kg kh ki jv b">WNOHANG</code>结合使用时，我们利用<code class="eh kg kh ki jv b">wait4</code>的返回值在每次得到<code class="eh kg kh ki jv b">SIGCHILD</code>信号时循环调用它。</p><p id="bf6b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样来自手册页(wait4的返回值符合wait PID—<a class="ae jp" href="http://man7.org/linux/man-pages/man2/waitpid.2.html" rel="noopener ugc nofollow" target="_blank">http://man7.org/linux/man-pages/man2/waitpid.2.html</a>)</p><blockquote class="kj kk kl"><p id="5dcb" class="ir is km it b iu iv iw ix iy iz ja jb kn jd je jf ko jh ji jj kp jl jm jn jo hn dt translated">成功时，返回状态已更改的子进程的进程ID；如果指定了<strong class="it hv"> WNOHANG </strong>并且存在由<em class="hu"> pid </em>指定的一个或多个子(ren ),但是还没有改变状态，则返回0。出错时，返回-1。</p></blockquote><p id="ac45" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以我们可以一直调用<code class="eh kg kh ki jv b">Wait4</code>，直到我们得到一个小于或等于0的返回值，知道它正在清理已退出的进程。</p><p id="db39" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，如果我们在容器内部运行这个exec并使用<code class="eh kg kh ki jv b">ps</code>进行检查</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="3d7c" class="jz ka hu jv b fv kb kc l kd ke">Aarons-iMac:init-proc aaronkalair$ docker exec -it 30f13d4e53bd bash<br/>root@30f13d4e53bd:/# ps -ef<br/>UID        PID  PPID  C STIME TTY          TIME CMD<br/>root         1     0  0 22:05 ?        00:00:00 ./srv/init-proc /srv/sleep-spawner 1<br/>root        12     1  0 22:05 ?        00:00:00 /srv/sleep-spawner 1<br/>root        17    12  0 22:05 ?        00:00:00 [sleep-spawner] &lt;defunct&gt;<br/>root        18    12  0 22:05 ?        00:00:00 [sleep-spawner] &lt;defunct&gt;<br/></span></pre><p id="2ac1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以看到PID 1的僵尸已经被清理了！</p><p id="27f3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们有了它，我们创建了一个基本的init进程，它允许我们向运行在Docker容器中的进程发送信号，让它们像在容器外一样工作，并且能够清理僵尸进程！</p><p id="d7b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">点击这里查看完整源代码—<a class="ae jp" href="https://github.com/AaronKalair/init-proc" rel="noopener ugc nofollow" target="_blank">https://github.com/AaronKalair/init-proc</a></p><p id="42a3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="http://twitter.com/aaronkalair" rel="noopener ugc nofollow" target="_blank">在推特@AaronKalair上关注我</a></p><figure class="jq jr js jt fq kq"><div class="bz el l di"><div class="kr ks l"/></div></figure></div></div>    
</body>
</html>