<html>
<head>
<title>Using Create React App with Relay Modern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Relay Modern创建React应用程序</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/using-create-react-app-with-relay-modern-989c078fa892?source=collection_archive---------2-----------------------#2017-08-11">https://medium.com/hackernoon/using-create-react-app-with-relay-modern-989c078fa892?source=collection_archive---------2-----------------------#2017-08-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/e7d9623883da240f62151792a3fbe540.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*RcYDsN-kfb_pJ3L29p7MYQ.png"/></div></figure><p id="f5dc" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">本教程假设你已经熟悉<a class="ae jw" href="https://github.com/facebookincubator/create-react-app" rel="noopener ugc nofollow" target="_blank"><strong class="ja hv">Create React App</strong></a>(CRA)和一点点<a class="ae jw" href="http://facebook.github.io/relay/docs/relay-modern.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ja hv"> Relay </strong> </a>，只是在寻找一些如何一起使用它们的例子。在这里，您将了解到:</p><ul class=""><li id="53b2" class="jx jy hu ja b jb jc jf jg jj jz jn ka jr kb jv kc kd ke kf dt translated">如何修改Create <a class="ae jw" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank"> React </a>应用程序设置以在其配置中使用“巴别塔插件中继”</li><li id="0270" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">如何配置中继编译器</li><li id="9b94" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">如何使用继电器的<code class="eh kl km kn ko b">&lt;QueryRenderer /&gt;</code>组件</li><li id="d0fe" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">当用户浏览站点时，如何用Relay获取数据</li></ul><p id="e97a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">注意，网上很多教程都是覆盖Relay以前版本的(又名Relay Classic)。它与Relay Modern有很大的不同，所以最好忽略那些不要混淆自己。</p><p id="4b51" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">TL；DR </strong> —访问GitHub上的<code class="eh kl km kn ko b"><a class="ae jw" href="https://github.com/kriasoft" rel="noopener ugc nofollow" target="_blank"><strong class="ja hv">kriasoft</strong></a>/<a class="ae jw" href="https://github.com/kriasoft/react-static-boilerplate" rel="noopener ugc nofollow" target="_blank"><strong class="ja hv">react-static-boilerplate</strong></a></code>资源库，获得完整的Create React App + Relay Modern示例。</p><h1 id="cd36" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">向CRA注入“巴别塔插件中继”</h1><p id="7a6b" class="pw-post-body-paragraph iy iz hu ja b jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv hn dt translated">你可能知道，Create React App的可扩展性不是很好。基本上，在定制Babel/Webpack配置时，您只剩下以下几个主要选项:</p><p id="e3f1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">选项1 </strong>:运行<code class="eh kl km kn ko b">yarn eject</code>，调整Babel/Webpack/PostCSS等。在项目中就地配置。但是在这种情况下，您将无法轻松地将您的应用程序升级到React相关工具的新版本。这首先违背了使用Create React App的目的，而不是使用一些流行的样板文件，如<a class="ae jw" href="https://github.com/kriasoft/react-starter-kit" rel="noopener ugc nofollow" target="_blank"> React Starter Kit </a> (RSK)，您可以克隆这些文件，但仍然能够将更新拉回到您的项目中。</p><p id="fda5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">选项2 </strong>:派生<code class="eh kl km kn ko b">create-react-app</code>存储库，并使用“react-scripts”的补丁版本。注意，更新你的餐叉会消耗你的一些空闲时间，你可以把这些时间用在更有用的事情上。参见<a class="ae jw" href="https://github.com/kriasoft/react-app" rel="noopener ugc nofollow" target="_blank"> React App SDK </a>作为一个例子，它允许使用自定义配置覆盖扩展CRA，并带有服务器端代码支持。</p><p id="a961" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">选项3 </strong>:创建一个脚本，每当您运行<code class="eh kl km kn ko b">yarn build</code>或<code class="eh kl km kn ko b">yarn start</code>时，该脚本将自动修补您的“react-scripts”NPM模块。我个人认为这个选项更实用，因为它帮助我在初始设置期间更快地完成工作，并且在未来<a class="ae jw" href="https://hackernoon.com/tagged/future" rel="noopener ugc nofollow" target="_blank">的</a>中以更少的工作量保持我的项目最新。</p></div><div class="ab cl ls lt hc lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hn ho hp hq hr"><p id="37a0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在引导一个新项目之后(通过运行<code class="eh kl km kn ko b">yarn create react-app</code>，您将需要安装Relay的运行时和开发依赖项:</p><pre class="lz ma mb mc fq md ko me mf aw mg dt"><span id="d536" class="mh kq hu ko b fv mi mj l mk ml">$ yarn add relay-runtime react-relay<br/>$ yarn add relay-compiler babel-plugin-relay --dev</span></pre><p id="d17d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">接下来，在项目的根目录下创建“setup.js”文件，内容如下:</p><pre class="lz ma mb mc fq md ko me mf aw mg dt"><span id="8f1e" class="mh kq hu ko b fv mi mj l mk ml">const fs = require('fs');<br/>const path = require('path');<br/><br/>const file = path.resolve('./node_modules/babel-preset-react-app/index.js');<br/>const text = fs.readFileSync(file, 'utf8');<br/><br/>if (!text.includes('babel-plugin-relay')) {<br/>  if (text.includes('const plugins = [')) {<br/>    text = text.replace(<br/>      'const plugins = [',<br/>      "const plugins = [\n  require.resolve('babel-plugin-relay'),",<br/>    );<br/>    fs.writeFileSync(file, text, 'utf8');<br/>  } else {<br/>    throw new Error(`Failed to inject babel-plugin-relay.`);<br/>  }<br/>}</span></pre><p id="5568" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">最后，更新<code class="eh kl km kn ko b">package.json</code>文件中的“脚本”部分，以便在<code class="eh kl km kn ko b">react-scripts &lt;command&gt;</code>之前运行该脚本:</p><pre class="lz ma mb mc fq md ko me mf aw mg dt"><span id="8294" class="mh kq hu ko b fv mi mj l mk ml">"scripts": {<br/>  "build": "node ./setup &amp;&amp; react-scripts build",<br/>  "test": "node ./setup &amp;&amp; react-scripts test --env=jsdom",<br/>  "start": "node ./setup &amp;&amp; react-scripts start"<br/>}</span></pre><p id="2074" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，每当你运行<code class="eh kl km kn ko b">yarn build</code>、<code class="eh kl km kn ko b">yarn test</code>或<code class="eh kl km kn ko b">yarn start</code>时，巴别塔编译器将按照Relay Modern的要求使用“巴别塔插件中继”。</p><h1 id="4cc3" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">配置中继编译器</h1><p id="f0d5" class="pw-post-body-paragraph iy iz hu ja b jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv hn dt translated">下一步是配置Relay编译器，其目的是找到您代码中的所有<code class="eh kl km kn ko b">graphql`…`</code>查询，预编译它们并保存到上一步“babel-plugin-relay”所消耗的<code class="eh kl km kn ko b">__generated__/*.graphq.js</code>文件中。</p><p id="2c94" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了做到这一点，首先，您需要将GraphQL模式的基于文本的表示保存到项目内部的一个文件中，假设您的React应用程序打算与一些外部GraphQL API一起工作。然后在将运行<code class="eh kl km kn ko b">relay-compiler</code>的<code class="eh kl km kn ko b">package.json</code>中再添加一个<em class="mm"> npm脚本</em>。它可能看起来像这样:</p><pre class="lz ma mb mc fq md ko me mf aw mg dt"><span id="cf5a" class="mh kq hu ko b fv mi mj l mk ml">"scripts": {<br/>  ...<br/>  "relay": "curl <a class="ae jw" href="https://graphql-demo.kriasoft.com/schema" rel="noopener ugc nofollow" target="_blank">https://graphql-demo.kriasoft.com/schema</a> -o ./src/graphql.schema &amp;&amp; relay-compiler --src ./src --schema ./src/graphql.schema<br/>}</span></pre><p id="0d79" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在这个练习中，我们将使用位于<a class="ae jw" href="https://graphql-demo.kriasoft.com" rel="noopener ugc nofollow" target="_blank">https://graphql-demo.kriasoft.com</a>(<a class="ae jw" href="https://github.com/kriasoft/nodejs-api-starter" rel="noopener ugc nofollow" target="_blank">源代码</a>)的现有GraphQL演示API。</p><p id="334a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在运行<code class="eh kl km kn ko b">yarn relay</code>之前，确保您的开发机器上安装了脸书的<a class="ae jw" href="https://facebook.github.io/watchman/" rel="noopener ugc nofollow" target="_blank"> Watchman </a>工具。</p><p id="a69c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，每当您在代码中更改一些GraphQL/Relay查询时，您将需要再次运行<code class="eh kl km kn ko b">yarn relay</code>,或者通过运行<code class="eh kl km kn ko b">yarn relay -- --watch</code>让它在一个单独的shell窗口中以监视模式运行。</p><blockquote class="mn mo mp"><p id="6c84" class="iy iz mm ja b jb jc jd je jf jg jh ji mq jk jl jm mr jo jp jq ms js jt ju jv hn dt translated"><strong class="ja hv"> <em class="hu">问</em> </strong>:我是否需要通过在<code class="eh kl km kn ko b">.gitignore</code>后面追加<code class="eh kl km kn ko b"> __generate__/**</code>来从我的源代码控制中排除中继编译文件生成的文件？<br/> <strong class="ja hv"> <em class="hu"> A </em> </strong>:好问题:)是的，根据经验，你不希望你的源代码库中有任何自动生成的文件。</p></blockquote><p id="6963" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">尝试将下面这段代码放入您的任何源文件中(例如放入<code class="eh kl km kn ko b">src/index.js</code>)并运行<code class="eh kl km kn ko b">yarn relay &amp;&amp; yarn build</code>:</p><pre class="lz ma mb mc fq md ko me mf aw mg dt"><span id="147d" class="mh kq hu ko b fv mi mj l mk ml">import { graphql } from 'relay-runtime';</span><span id="4381" class="mh kq hu ko b fv mt mj l mk ml">graphql`query { me { displayName } }`;</span></pre><p id="763f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果您可以构建没有任何错误的项目，很可能前面的两个步骤都是正确的。</p><h1 id="648a" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">如何初始化中继客户端(环境)？</h1><p id="3de9" class="pw-post-body-paragraph iy iz hu ja b jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv hn dt translated">这部分很简单，按照官方文件做就行了。您的中继客户端(环境)将看起来像这样(<code class="eh kl km kn ko b">src/relay.js</code>):</p><figure class="lz ma mb mc fq iv"><div class="bz el l di"><div class="mu mv l"/></div></figure><p id="56a4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果你想的话，你甚至可以直接使用它而不用“反应-中继”包。这里有一个例子:</p><pre class="lz ma mb mc fq md ko me mf aw mg dt"><span id="4e8f" class="mh kq hu ko b fv mi mj l mk ml">import { graphql, fetchQuery } from 'relay-runtime';<br/>import relay from './relay';</span><span id="48ac" class="mh kq hu ko b fv mt mj l mk ml">fetchQuery(<br/>  relay,<br/>  graphql`query { me { displayName } }`<br/>).then(...);</span></pre><p id="6b11" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在现实世界的项目中，您需要将上面代码示例中的硬编码API URL替换为如下内容:</p><pre class="lz ma mb mc fq md ko me mf aw mg dt"><span id="f4a2" class="mh kq hu ko b fv mi mj l mk ml">fetch(process.env.REACT_APP_API || 'http://localhost:8080', ...)</span></pre><p id="bdc0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">..因此，您可以在开发/测试/生产环境中轻松运行您的应用程序。有关将环境变量注入应用程序的更多信息，请参考《创建React应用程序用户指南》。</p><h1 id="31fa" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">如何使用<QueryRenderer/>组件</h1><p id="1b40" class="pw-post-body-paragraph iy iz hu ja b jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv hn dt translated">Relay Modern带有一个方便的<code class="eh kl km kn ko b">&lt;QueryRenderer /&gt;</code>组件，你可以在应用程序的顶层使用，有点类似于Redux的<code class="eh kl km kn ko b">&lt;Provider&gt;</code>组件。它将通过<em class="mm">上下文</em>将Relay的环境(包括Relay store和HTTP client)传递给所有的React子组件。此外，它将为您处理更新，因此您不需要在运行突变后手动重新渲染您的组件。</p><p id="6feb" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">逻辑看起来是这样的——每当用户打开您的站点，或者从一个页面/屏幕导航到另一个页面/屏幕，您找到相应的GraphQL查询和该页面的参数(变量)列表，将其传递给<queryrenderer>并让它完成工作(它将获取丢失的数据并重新呈现受影响的子组件)。</queryrenderer></p><p id="384a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">您的顶级React组件(<code class="eh kl km kn ko b">src/App</code>)将如下所示:</p><figure class="lz ma mb mc fq iv"><div class="bz el l di"><div class="mu mv l"/></div></figure><p id="3927" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">上面的代码示例使用“history”NPM模块进行导航，使用“universal-router”将URL路径解析为路由。<code class="eh kl km kn ko b">src/history.js</code>的内容如下:</p><pre class="lz ma mb mc fq md ko me mf aw mg dt"><span id="da39" class="mh kq hu ko b fv mi mj l mk ml">import createHistory from 'history/createBrowserHistory';<br/>export default createHistory();</span></pre><p id="1fa1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">它是围绕HTML5历史API的跨浏览器包装器，允许你对客户端发起的<code class="eh kl km kn ko b">window.location</code>中的变化引起的任何变化做出响应，并修改该状态，例如通过调用<code class="eh kl km kn ko b">history.push(..)</code>。</p><p id="5989" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><code class="eh kl km kn ko b">src/router.js</code>的内容更有趣一点。给定应用程序路由列表和一个全局路由器处理函数，它初始化并导出一个<code class="eh kl km kn ko b">universal-router</code>类的实例。</p><p id="a1e3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">顺便说一句，在使用GraphQL/Relay的情况下，使用声明式路由方法是有意义的(与命令式路由相反)，这意味着所有的路由都只包含元数据，不包含处理程序。至少，每个路由都可以包含URL路径字符串(模式)、GraphQL查询和要呈现组件，例如:</p><pre class="lz ma mb mc fq md ko me mf aw mg dt"><span id="a51e" class="mh kq hu ko b fv mi mj l mk ml">const routes = [<br/>  {<br/>    path: '/posts/:id',<br/>    query: graphql`query routeStoryQuery($id: ID!) {<br/>      post: node(id: $id) { ...Post_post }<br/>    }`,<br/>    component: () =&gt;<br/>      import(/* webpackChunkName: 'post' */, './Post')<br/>  },<br/>  ...<br/>]</span></pre><p id="d000" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，您可以通过提供路由列表和一个全局路由器处理程序(解析器)函数来初始化路由器，如下所示:</p><pre class="lz ma mb mc fq md ko me mf aw mg dt"><span id="82ce" class="mh kq hu ko b fv mi mj l mk ml">import Router from 'universal-router';<br/>import { graphql } from 'relay-runtime';</span><span id="1001" class="mh kq hu ko b fv mt mj l mk ml">const routes = [ ... ]; // see above</span><span id="1027" class="mh kq hu ko b fv mt mj l mk ml">export default new Router(routes, {<br/>  resolveRoute({ route, next }, params) {<br/>    if (!route.component) next();<br/>    return {<br/>      query: route.query,<br/>      component: route.component(),<br/>      variables: params,<br/>    };<br/>  }<br/>});</span></pre><p id="aea5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">您需要稍微调整一下这个例子，以涵盖更多的用例。想法是，当找到相应的路由(URL匹配)时，它应该开始下载该页面/屏幕的JavaScript块，同时将查询和变量传递给<code class="eh kl km kn ko b">QueryRenderer</code>(参见上面的<code class="eh kl km kn ko b">src/App</code>示例)，有效地触发该路由的数据获取。唯一的问题是，当QueryRenderer完成获取数据时，您需要确保异步块加载也完成了它的工作(promise resolve ),然后才能呈现页面，为此您使用了一个中间(AppRenderer)组件。</p><p id="f215" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">您可以在路径中放置或多或少的元数据来适应您的应用程序，例如，您可以放置如下身份验证规则:</p><pre class="lz ma mb mc fq md ko me mf aw mg dt"><span id="3ab7" class="mh kq hu ko b fv mi mj l mk ml">{<br/>  path: '/admin/users',<br/>  query: graphql`...`,<br/>  component: () =&gt; ...,<br/>  authorize: { roles: ['admin'] } // or, "authorize: true" etc.<br/>}</span></pre><p id="c980" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">使用GraphQL / Relay，您可能希望一次为特定页面/屏幕上的所有组件获取数据(而不是为每个嵌套级别的组件单独获取数据)，否则会稍微降低GraphQL的价值。</p></div><div class="ab cl ls lt hc lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hn ho hp hq hr"><p id="925d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">有关使用Relay Modern创建React应用程序的完整示例，请访问<code class="eh kl km kn ko b"><a class="ae jw" href="https://github.com/kriasoft" rel="noopener ugc nofollow" target="_blank"><strong class="ja hv">kriasoft</strong></a>/<a class="ae jw" href="https://github.com/kriasoft/react-static-boilerplate" rel="noopener ugc nofollow" target="_blank"><strong class="ja hv">react-static-boilerplate</strong></a></code> —这是一个在React/Relay堆栈上创建单页应用程序的流行样板，如管理面板、仪表板等。不需要服务器端渲染的地方。您不仅可以将它用作示例，还可以将其作为React项目的种子，从而节省大量从头配置一切的时间。请随时在<a class="ae jw" href="https://gitter.im/kriasoft/react-static-boilerlpate" rel="noopener ugc nofollow" target="_blank"> Gitter </a>或<a class="ae jw" href="https://twitter.com/koistya" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上ping我，如果你遇到任何问题，我很乐意帮忙。</p><p id="2ce7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">附注</strong>:这个项目有一个<a class="ae jw" href="https://opencollective.com/react-static-boilerplate" rel="noopener ugc nofollow" target="_blank"> OpenCollective页面</a>:)非常欢迎您的支持！</p><figure class="lz ma mb mc fq iv"><div class="bz el l di"><div class="mw mv l"/></div></figure></div></div>    
</body>
</html>