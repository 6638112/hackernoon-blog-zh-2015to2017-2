<html>
<head>
<title>Lazy Evaluation in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript中的惰性求值</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/lazy-evaluation-in-javascript-84f7072631b7?source=collection_archive---------3-----------------------#2016-12-20">https://medium.com/hackernoon/lazy-evaluation-in-javascript-84f7072631b7?source=collection_archive---------3-----------------------#2016-12-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir is it"><p id="5741" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">TD；用Object.defineProperty()可以很容易地执行Javascript对象属性中的DR、Lazy求值。</p></blockquote><p id="428f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">前一段时间，我在<strong class="ix hv"> node.js </strong>中寻找一种达到某种<strong class="ix hv">懒惰评估</strong>的方法。</p><p id="ae4f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我正在构建一个对象，它必须有一个包含同类实例的属性(递归地)。这可以通过函数而不是属性来实现，但是这是一个非常特殊的场景。</p><p id="4a12" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">所以我真正需要的是只有在调用object属性时才运行这个实例化的方法，而不是在对象构造期间。</p><p id="9200" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">尽管如此，我还是在<em class="iw"> stackoverflow </em>上找到了一些关于<em class="iw">按名称调用或按需求调用</em>策略的Javascript文章，但没有一篇文章对我想要做的事情有效。</p><p id="cc5b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我遇到的大多数文章、代码和库都是通过一个<a class="ae jw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" rel="noopener ugc nofollow" target="_blank">代理</a>来实现<strong class="ix hv">惰性评估</strong>。但是这种对象在旧版本的<a class="ae jw" href="https://hackernoon.com/tagged/nodejs" rel="noopener ugc nofollow" target="_blank"> node.js </a>中是没有的，我的情况就是这样。</p><p id="9709" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">简而言之，惰性评估，也称为按需调用，定义为:</p><blockquote class="jx"><p id="4f95" class="jy jz hu bd ka kb kc kd ke kf kg js ek translated"><em class="kh">按需要调用</em>是按名字调用的<a class="ae jw" href="https://en.wikipedia.org/wiki/Memoization" rel="noopener ugc nofollow" target="_blank">记忆</a>版本。</p></blockquote><p id="6127" class="pw-post-body-paragraph iu iv hu ix b iy ki ja jb jc kj je jf jt kk ji jj ju kl jm jn jv km jq jr js hn dt translated">但是什么是点名呢？那记忆化呢？</p><h2 id="8ffb" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jt ky kz la ju lb lc ld jv le lf lg lh dt translated">按名称调用和按值调用</h2><p id="19ab" class="pw-post-body-paragraph iu iv hu ix b iy li ja jb jc lj je jf jt lk ji jj ju ll jm jn jv lm jq jr js hn dt translated">首先，让我们检查这两个函数:</p><pre class="ln lo lp lq fq lr ls lt lu aw lv dt"><span id="4b78" class="kn ko hu ls b fv lw lx l ly lz">// Evaluates with call-by-name strategy<br/>1 function callByName (a, b) {<br/>2  if (a === 1) {<br/>3    return 10<br/>4  }<br/>5  return a + b<br/>6 }</span><span id="d6b4" class="kn ko hu ls b fv ma lx l ly lz">// Evaluates with call-by-value strategy<br/>1 function callByValue (a, b) {<br/>2  if (a === 1) {<br/>3    return 10<br/>4  }<br/>5  return a + b<br/>6 }</span></pre><p id="736b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">请记住，这不是Javascript。第一个函数通过按名称调用来计算，第二个函数通过按值调用来计算。</p><p id="48a5" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">为了理解这两种类型的评估策略之间的区别，我们可以逐行查看一些关于如何执行的伪代码。</p><pre class="ln lo lp lq fq lr ls lt lu aw lv dt"><span id="46d1" class="kn ko hu ls b fv lw lx l ly lz">1 &gt; callByName (1, 2 + 3)<br/>2 &gt; a === 1<br/>3 &gt; return 10</span><span id="f82e" class="kn ko hu ls b fv ma lx l ly lz">1 &gt; callByValue(1, 2 + 3)<br/>1 &gt; callByValue(1, 5)<br/>2 &gt; a === 1<br/>3 &gt; return 10</span></pre><p id="8398" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">你可能对第二个很熟悉。这是因为Javascript只将参数作为值传递(如果是对象，则通过引用传递)。</p><p id="b224" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在<strong class="ix hv">按值调用</strong>函数(或<em class="iw">急切求值</em>)中，数字2和3首先相加，然后作为函数参数传递，值为5。</p><p id="9186" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">另一方面，在示例中所示的<strong class="ix hv">按名称调用</strong>函数(或<em class="iw">惰性评估</em>)中，由于在函数使用<strong class="ix hv"> b </strong>之前函数返回10，所以第二个参数<strong class="ix hv"> b </strong>甚至没有被评估。</p><h2 id="7515" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jt ky kz la ju lb lc ld jv le lf lg lh dt translated">记忆化</h2><p id="fff3" class="pw-post-body-paragraph iu iv hu ix b iy li ja jb jc lj je jf jt lk ji jj ju ll jm jn jv lm jq jr js hn dt translated">简而言之，<em class="iw">记忆化</em>是一种存储预计算结果(缓存)的优化技术，以避免对相同的输入进行重新计算。</p><p id="b82c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">以更正式的方式，这意味着如果一个幂等函数</p><pre class="ln lo lp lq fq lr ls lt lu aw lv dt"><span id="2a36" class="kn ko hu ls b fv lw lx l ly lz"><strong class="ls hv">f(x) = g(x) + 1</strong></span></pre><p id="1653" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">会不会<strong class="ix hv"> </strong>在接收到一个输入<strong class="ix hv"> v </strong>时总是输出某个值<strong class="ix hv"> y </strong>，那么<strong class="ix hv"> f(v) = y </strong>。</p><p id="956c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">因此，如果<strong class="ix hv"> g(v) </strong>在时间或机器资源方面非常<em class="iw">昂贵</em>，我们可以将结果<strong class="ix hv"> y </strong>存储在缓存中，当<strong class="ix hv"> v </strong>是输入时返回，这样我们就不必再次重新计算<strong class="ix hv"> g(v) </strong>。</p><pre class="ln lo lp lq fq lr ls lt lu aw lv dt"><span id="59ee" class="kn ko hu ls b fv lw lx l ly lz"><strong class="ls hv">cache = {}</strong></span><span id="3c61" class="kn ko hu ls b fv ma lx l ly lz"><strong class="ls hv">cache[v] = y</strong></span></pre><h2 id="61c9" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jt ky kz la ju lb lc ld jv le lf lg lh dt translated">无限递归问题</h2><p id="c4f9" class="pw-post-body-paragraph iu iv hu ix b iy li ja jb jc lj je jf jt lk ji jj ju ll jm jn jv lm jq jr js hn dt translated">现在我们将浏览一些非常简单的递归对象的代码，它进行惰性求值以避免无限递归。</p><p id="ae1b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们将分析一种称为Stream的无限数据结构，这在函数式编程语言中非常常见。</p><p id="09af" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">如果我们尝试运行这段代码会发生什么？</p><figure class="ln lo lp lq fq mb"><div class="bz el l di"><div class="mc md l"/></div></figure><pre class="ln lo lp lq fq lr ls lt lu aw lv dt"><span id="7fe3" class="kn ko hu ls b fv lw lx l ly lz">var stream = new Stream(10);</span><span id="a222" class="kn ko hu ls b fv ma lx l ly lz">&gt; RangeError: Maximum call stack size exceeded</span></pre><p id="2667" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">不出所料，它会以<strong class="ix hv">范围错误</strong>失败。</p><p id="731e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">问题出在下面的代码行，我们正在做一个<em class="iw">急切加载<strong class="ix hv">下一个</strong>属性<strong class="ix hv">的</strong></em>。</p><pre class="ln lo lp lq fq lr ls lt lu aw lv dt"><span id="bbb3" class="kn ko hu ls b fv lw lx l ly lz">this.next = new Stream(value + 1);</span></pre><p id="0ef0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们把流改成<em class="iw">懒</em>吧。</p><figure class="ln lo lp lq fq mb"><div class="bz el l di"><div class="mc md l"/></div></figure><p id="1c55" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">注意，我还在流中添加了一个<strong class="ix hv"> takeUntil </strong>方法。让我们继续，尝试运行这段代码。</p><pre class="ln lo lp lq fq lr ls lt lu aw lv dt"><span id="bf54" class="kn ko hu ls b fv lw lx l ly lz">var stream = new Stream(10);</span><span id="7f56" class="kn ko hu ls b fv ma lx l ly lz">console.log(stream.takeUntil(20))</span><span id="f1ed" class="kn ko hu ls b fv ma lx l ly lz">&gt; [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</span></pre><p id="e4da" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">现在，我们不仅可以构建流，而且还可以用这个实现运行<em class="iw">无限</em>算法，比如<strong class="ix hv"> takeUntil </strong>。</p><p id="b22c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">你可能会想:为什么我们在这里没有使用<em class="iw">记忆</em>？</p><p id="9df4" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">嗯，我们可以，但是这个<em class="iw">优化</em>是没有价值的，因为我们只是在做一个基本的数学运算，将两个操作数相加。这在计算上并不昂贵，例如，计算<strong class="ix hv">值</strong>是否是质数。</p></div><div class="ab cl me mf hc mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hn ho hp hq hr"><p id="b5ef" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">参考资料:</p><ul class=""><li id="60a4" class="ml mm hu ix b iy iz jc jd jt mn ju mo jv mp js mq mr ms mt dt translated"><a class="ae jw" href="http://stackoverflow.com/questions/6605640/javascript-by-reference-vs-by-value#6605700" rel="noopener ugc nofollow" target="_blank">http://stack overflow . com/questions/6605640/JavaScript-by-reference-vs-by-value # 6605700</a></li><li id="4e92" class="ml mm hu ix b iy mu jc mv jt mw ju mx jv my js mq mr ms mt dt translated"><a class="ae jw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/Object/define property</a></li><li id="3358" class="ml mm hu ix b iy mu jc mv jt mw ju mx jv my js mq mr ms mt dt translated"><a class="ae jw" href="https://en.wikipedia.org/wiki/Evaluation_strategy" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Evaluation_strategy</a></li><li id="d64b" class="ml mm hu ix b iy mu jc mv jt mw ju mx jv my js mq mr ms mt dt translated"><a class="ae jw" href="https://en.wikipedia.org/wiki/Memoization" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Memoization</a></li></ul><blockquote class="ir is it"><p id="76f5" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><a class="ae jw" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jw" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jw" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae jw" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">要了解更多信息，请<a class="ae jw" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae jw" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae jw" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jw" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jw" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ln lo lp lq fq mb"><div class="bz el l di"><div class="mz md l"/></div></figure></div></div>    
</body>
</html>