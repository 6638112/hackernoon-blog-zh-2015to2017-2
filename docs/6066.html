<html>
<head>
<title>Basic Concepts and Applications for Event Listeners in React.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React.js中事件侦听器的基本概念和应用</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/basic-concepts-and-applications-for-event-listeners-in-react-js-e616fbd22827?source=collection_archive---------4-----------------------#2017-09-01">https://medium.com/hackernoon/basic-concepts-and-applications-for-event-listeners-in-react-js-e616fbd22827?source=collection_archive---------4-----------------------#2017-09-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/b1cb504089ff2d973eb019c0d5615c93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*6EZ794JnpfJBACRNWDUCsw.jpeg"/></div></figure><p id="5e0d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">从<a class="ae jw" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>转移到<a class="ae jw" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank"> React </a>有些令人生畏，因为人们很容易忘记React只是JavaScript。语法、JSX以及文件之间共享信息和组件之间传递信息的方式的差异可能会非常令人困惑，因此在这篇博客中，我打算简要概述一下React中的事件侦听器是什么样子的，以及需要记住的一些事情。</p><h2 id="a653" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr dt translated">首先，我们应该试着记住JavaScript中的事件监听器。</h2><p id="afc1" class="pw-post-body-paragraph iy iz hu ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hn dt translated">一个<strong class="ja hv"> <em class="kx">事件监听器</em> </strong>是一个<strong class="ja hv">回调函数</strong>，它监听(或被调用)一个<strong class="ja hv">事件对象</strong>的<strong class="ja hv">创建</strong>。</p><p id="bb92" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们来分解一下:</p><p id="ad60" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">JavaScript最强大的特性之一是它可以接受一个函数作为参数。回调函数是这样做的函数的名称，它接受另一个函数作为参数。当我第一次接触回调函数时，我把它们和闭包混为一谈，虽然有一些重要的概念与它们都相关(特别是当我们考虑范围时)，但它们也是不同的！在这里，我将重点讨论事件上下文中的回调。为什么回调很棒？</p><ul class=""><li id="e5c5" class="ky kz hu ja b jb jc jf jg jj la jn lb jr lc jv ld le lf lg dt translated">它允许我们编写我们可能并不马上需要的函数——例如(正如我们将在这里看到的),当我们等待用户输入时。</li><li id="1221" class="ky kz hu ja b jb lh jf li jj lj jn lk jr ll jv ld le lf lg dt translated">它允许职责分离，并有助于将代码分解成更小的部分</li><li id="4d3d" class="ky kz hu ja b jb lh jf li jj lj jn lk jr ll jv ld le lf lg dt translated">希望我们也能利用这些优势，让我们的代码对我们自己或其他从事该项目的开发人员来说更具可读性。</li></ul><p id="9093" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">当我们将一个参数作为函数传递时，我们需要记住在我们准备使用它之前不要调用它！否则，我们的代码可能会中断，或者至少不会像预期的那样工作。</p><p id="28aa" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">浏览器一直在监听用户输入或交互。这可能意味着击键、点击按钮或提交表单。在这种交互作用下，比如说点击一下，一个新的事件对象就会基于具有某些属性的特定交互作用而被创建。这些属性包括诸如，点击了什么，鼠标的位置之类的东西，这些属性非常有用，因为新的事件对象封装了特定的交互，允许我们以后引用它。</p><h2 id="1907" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr dt translated">那么JavaScript和react中的回调函数如何比较呢？</h2><p id="4026" class="pw-post-body-paragraph iy iz hu ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hn dt translated">所有的概念都是一样的，因为React是JavaScript！下面是比较的语法。</p><pre class="lm ln lo lp fq lq lr ls lt aw lu dt"><span id="65d6" class="jx jy hu lr b fv lv lw l lx ly">//JavaScript </span><span id="7b59" class="jx jy hu lr b fv lz lw l lx ly">button.addEventListener("onclick", sayHi)</span><span id="97c4" class="jx jy hu lr b fv lz lw l lx ly">sayHi() {<br/>console.log("Hello World!)<br/>}</span></pre><p id="7002" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所以，在上面的例子中，我们有</p><ol class=""><li id="dcd2" class="ky kz hu ja b jb jc jf jg jj la jn lb jr lc jv ma le lf lg dt translated">向特定按钮添加了一个事件侦听器</li><li id="5e4d" class="ky kz hu ja b jb lh jf li jj lj jn lk jr ll jv ma le lf lg dt translated">表示我们正在等待按钮被点击</li><li id="4bd1" class="ky kz hu ja b jb lh jf li jj lj jn lk jr ll jv ma le lf lg dt translated">告诉程序当特定的按钮被点击时(更确切地说，当一个事件对象被创建用于特定的点击时)，我们应该调用函数sayHi</li><li id="5b6a" class="ky kz hu ja b jb lh jf li jj lj jn lk jr ll jv ma le lf lg dt translated">sayHi然后将字符串“Hello World”打印到控制台</li></ol><pre class="lm ln lo lp fq lq lr ls lt aw lu dt"><span id="773b" class="jx jy hu lr b fv lv lw l lx ly">//React </span><span id="1a9e" class="jx jy hu lr b fv lz lw l lx ly">&lt;Button onClick={this.sayHi}/&gt;</span></pre><p id="f192" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在这个例子中，</p><ol class=""><li id="2b69" class="ky kz hu ja b jb jc jf jg jj la jn lb jr lc jv ma le lf lg dt translated">按钮组件有一个用于点击事件的合成事件监听器</li><li id="c25e" class="ky kz hu ja b jb lh jf li jj lj jn lk jr ll jv ma le lf lg dt translated">当在该按钮上创建一个事件对象时，将调用函数sayHi</li><li id="6269" class="ky kz hu ja b jb lh jf li jj lj jn lk jr ll jv ma le lf lg dt translated">这个。表示这个函数已经在同一个组件上定义了，并且作为一个参数被传入(这是一个回调)</li></ol><p id="53fd" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">不算太差吧！</p><h1 id="8053" class="mb jy hu bd jz mc md me kd mf mg mh kh mi mj mk kk ml mm mn kn mo mp mq kq mr dt translated">抓到你了(嗯，抓到我了)</h1><h2 id="8ffb" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr dt translated">事件监听器需要像回调一样设置</h2><p id="d258" class="pw-post-body-paragraph iy iz hu ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hn dt translated">这似乎是显而易见的，但是监听点击的组件实际上必须有一个事件监听器，它接受对另一个函数的引用作为参数。我们刚刚看了几段，所以你认为我会马上理解。然而……由于react中的命名约定和回调函数的性质，显然有两个相关的函数需要协同工作来实现事件监听器。</p><p id="efb2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们经常看到这样的代码</p><figure class="lm ln lo lp fq iv fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/b0aded7bc938011d6a4611ecaaf049d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*u-tLXWl12uMlUfOP0-JKiA.png"/></div><figcaption class="mt mu fg fe ff mv mw bd b be z ek">Content from Learn.co curriculum</figcaption></figure><p id="29ca" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在我惊慌失措的反应中，我辛辛苦苦在JavaScript中学习的所有逻辑都飞出了窗外，我脑子里唯一的想法是“但是为什么我不能只使用HANDLE CLICK ALONEEEEE”</p><figure class="lm ln lo lp fq iv fe ff paragraph-image"><div class="fe ff mx"><img src="../Images/8961072a318062ca08927da0fb3184b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*0hVzYc7NMsT0i4CKRpjyFg.png"/></div><figcaption class="mt mu fg fe ff mv mw bd b be z ek"><strong class="bd my">Past Self: WHY CAN’T I JUST SAY “HANDLE CLICK” WHENEVER I WANT!?!?!?!?!? Current Self: UMM CHILL OUT. You know that is not how event listeners or callbacks work…..</strong></figcaption></figure><p id="481a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我真的想写这样的代码:</p><pre class="lm ln lo lp fq lq lr ls lt aw lu dt"><span id="8fd8" class="jx jy hu lr b fv lv lw l lx ly">import React, {Component} from 'react';</span><span id="d580" class="jx jy hu lr b fv lz lw l lx ly">class CoordinatesButton extends Component {</span><span id="ad0f" class="jx jy hu lr b fv lz lw l lx ly">handleClick = (event) =&gt; {<br/>    this.props.onReceiveCoordinates([event.pageX, event.pageY])<br/>}</span><span id="cf73" class="jx jy hu lr b fv lz lw l lx ly">render() {<br/>    return (<br/>        &lt;div&gt;<br/>          &lt;button <strong class="lr hv">handleClick={this.handleClick}</strong>&gt;Button&lt;/button&gt;<br/>        &lt;/div&gt;</span><span id="92a6" class="jx jy hu lr b fv lz lw l lx ly">);<br/>    }<br/>};</span><span id="e4dd" class="jx jy hu lr b fv lz lw l lx ly">export default CoordinatesButton;</span></pre><p id="12a0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这不是我最好的主意。onClick很特别！它是一个事件监听器！handleClick不是。它可以被命名为reactIsTrickySometimes，并且仍然有效！</p><p id="2b9b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">实际上，正在发生的事情就像在普通的JavaScript中一样，我们编写一个函数来决定我们想要在点击之后发生什么。然后，我们传入click事件的函数引用。基本上都是一样的东西。</p><h2 id="b411" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr dt translated">有时功能(尤其是与事件相关的)需要作为道具传递</h2><p id="3120" class="pw-post-body-paragraph iy iz hu ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hn dt translated">那是什么意思！？！</p><figure class="lm ln lo lp fq iv fe ff paragraph-image"><div class="fe ff mz"><img src="../Images/35e11a56562087f3e1313fca17a74dfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/1*juchzzpVwgTFbV_HHGCsKg.gif"/></div></figure><p id="7436" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">有时，您可能在一个组件中编写一个函数，但是实际的单击可能需要监听一个子组件。</p><pre class="lm ln lo lp fq lq lr ls lt aw lu dt"><span id="f960" class="jx jy hu lr b fv lv lw l lx ly">//PuppyList.js</span><span id="b6af" class="jx jy hu lr b fv lz lw l lx ly">render() {</span><span id="994a" class="jx jy hu lr b fv lz lw l lx ly">const puppies = this.props.puppies.map((puppy, index) =&gt; &lt;Puppy name={puppy.name} showDescription={puppy.showDescription} key={index} clickFunction={this.handleClick}/&gt;);<br/>    <br/>    return &lt;div&gt; {puppies} &lt;/div&gt;<br/>  }</span><span id="df34" class="jx jy hu lr b fv lz lw l lx ly"><br/>handleClick = (event) =&gt; {<br/>    this.props.puppies.map((hog) =&gt; {<br/>      if (puppy.name === event.target.name &amp;&amp; puppy.showDescription === false) {<br/>        return puppy.showDescription = true<br/>      } else if (puppy.name === event.target.value &amp;&amp; pupp.showDescription === true){<br/>        return puppy.showDescription = false<br/>      }<br/>    })</span><span id="d5bd" class="jx jy hu lr b fv lz lw l lx ly">//Puppy.js</span><span id="fdc5" class="jx jy hu lr b fv lz lw l lx ly">const Puppy = (props) =&gt; {</span><span id="6721" class="jx jy hu lr b fv lz lw l lx ly">if (props.showDescription === true) {<br/>    return (&lt;div className="puppyCard" onClick={props.clickFunction} &gt;&lt;h3&gt;{props.name}&lt;/h3&gt;&lt;/div&gt;)<br/>  } else {<br/>    return (&lt;div className="puppyCard" &gt;&lt;h3&gt;{props.name}&lt;/h3&gt;&lt;img src={url} name={props.name} alt="" onClick={props.clickFunction}/&gt;&lt;/div&gt;)<br/>  }<br/>}</span></pre><p id="b219" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">看起来超级恐怖和混乱。这也是很多行代码的一个例子。这怎么可能行得通呢？发生了什么事？</p><p id="8945" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们一行一行地走一遍</p><figure class="lm ln lo lp fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="fe ff na"><img src="../Images/b3ab8e34a2d4bdb2dea6dda7ad01c980.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vvmfDwtLuobo8Zf65D_1-Q.png"/></div></div><figcaption class="mt mu fg fe ff mv mw bd b be z ek">V. high tech wireframe</figcaption></figure><p id="e76a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">PuppyList是Puppy的<strong class="ja hv">父</strong>组件。现在，它有两项工作，通过功能来完成:</p><ol class=""><li id="4718" class="ky kz hu ja b jb jc jf jg jj la jn lb jr lc jv ma le lf lg dt translated">render()具有a)设置一个常量幼犬，并使用map函数遍历列表，并使用我们已经决定的道具构建每个<Puppy/>组件(包括<strong class="ja hv">click function = { this . handleclick }</strong>(这很重要，我们将很快返回),然后b)返回带有这些{幼犬}的&lt; div &gt; &lt; /div &gt;</li><li id="171a" class="ky kz hu ja b jb lh jf li jj lj jn lk jr ll jv ma le lf lg dt translated">handleClick，我们现在声名狼藉但实际上并不混乱的事件处理程序，它只是告诉我们的程序当Click发生时该做什么</li></ol><p id="6f4d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">小狗是<strong class="ja hv">孩子</strong>的组成部分。我们给它传递了一些道具，特别是在这里，我们正在用PuppyList构建它</p><pre class="lm ln lo lp fq lq lr ls lt aw lu dt"><span id="f645" class="jx jy hu lr b fv lv lw l lx ly">//PuppyList.js </span><span id="6293" class="jx jy hu lr b fv lz lw l lx ly">...</span><span id="2ba6" class="jx jy hu lr b fv lz lw l lx ly">&lt;Puppy name={puppy.name} showDescription={puppy.showDescription} key={index} clickFunction={this.handleClick}/&gt;</span><span id="3056" class="jx jy hu lr b fv lz lw l lx ly">...</span></pre><p id="b56c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">但是，等一下，现在在小狗我们有</p><pre class="lm ln lo lp fq lq lr ls lt aw lu dt"><span id="86c3" class="jx jy hu lr b fv lv lw l lx ly">&lt;div className="puppyCard" onClick={props.clickFunction} &gt;&lt;h3&gt;{props.name}&lt;/h3&gt;&lt;/div&gt;</span></pre><p id="6f3a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">onClick={props.clickFunction}</p><p id="23c6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">！== </strong></p><p id="d061" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">click function = { this . handleclick }</p><p id="2c66" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">发生了什么事？？很简单。</p><p id="de2d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">clickFunction是一个<em class="kx">道具</em>！！！).在程序列表中，我们将clickFunction设置为等于这个。handleClick。通过将它作为一个道具传递下去，我们可以说，“嘿，当用户点击你的时候，去找你的道具“Click Function”——这个道具告诉我们它实际上是这个的引用。handleClick。</p><p id="cca5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">同样，这只是我们回调函数的基本原则。</p><p id="9231" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">但是，因为这段代码现在还存在，所以它还没有完全生效。</p><p id="f4a3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们必须把它绑起来，以免丢失。</p><figure class="lm ln lo lp fq iv fe ff paragraph-image"><div class="fe ff nf"><img src="../Images/935b4b2391ed1d0755b245e319cc6043.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*ZBhRBd2Tw97KR2Pv8KjQuw.gif"/></div><figcaption class="mt mu fg fe ff mv mw bd b be z ek">“This” is lost. I am a lost. Everyone is lost!</figcaption></figure><h2 id="0054" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr dt translated">$@#*@是怎么回事。在反应中结合(这)</h2><p id="d703" class="pw-post-body-paragraph iy iz hu ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hn dt translated">当我们绑定它的时候，我们正在使用对于理解回调函数如何工作很重要的概念。</p><p id="aa08" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">最初，当我们在pupylist中编写handleClick()时，<em class="kx">这个</em>指的是pupylist。有道理！</p><p id="3691" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">但是现在，我们将引用发送给handleClick。回想一下常规的JavaScript。因为该函数现在“嵌套”在另一个函数中，所以作用域从原来的作用域改变为它所调用的函数的作用域。“handleClick()”生活在“clickFunction”中，不知道“this”是什么意思。</p><p id="3568" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">嗯……一定有更有趣的方式来思考这个问题。</p><figure class="lm ln lo lp fq iv fe ff paragraph-image"><div class="fe ff ng"><img src="../Images/e55873e5790d9aba7dfb148bc6191f79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*-GniSvIv4-f1_j2Us8-REQ.jpeg"/></div></figure><p id="da00" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这里是坦克里的一只蜥蜴。最初，我想把蜥蜴放在水箱里，就像放在玻璃容器里一样，但是1。这是词汇精确性和第二课。这更有趣，也许更好地证明了这一点。</p><p id="4719" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，我们的蜥蜴在水箱里，这让它很安全。当蜥蜴在坦克里时，它不会被压扁或折断。耶！让我们假设坦克实际上并不驱动，但必须挂在蜥蜴的栖息地，如果他离开去冒险，他将不得不冒险没有任何保护。这不太好！这不安全！当我们的<em class="kx">这个</em>失去上下文时，它是不安全的——它是孤独和混乱的。我们不希望这种事情发生。</p><figure class="lm ln lo lp fq iv fe ff paragraph-image"><div class="fe ff nh"><img src="../Images/2a87cb16f4d231f844e179c9dfc9aac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*1oqZXQ_j9oARFePuec8cBQ.jpeg"/></div></figure><p id="c79b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这是一只超级快乐的乌龟。这只乌龟为什么这么开心？因为无论她去哪里，她都带着她的装甲坦克。她很安全，受到保护，而且比那只蜥蜴要危险得多。</p><p id="ddab" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这就是我们。装订(这个)。我们希望我们的函数携带它们的上下文，这样它们就不会中断！</p><p id="f87c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">好吧，也许，现在我们应该看看实际情况。</p><pre class="lm ln lo lp fq lq lr ls lt aw lu dt"><span id="75ce" class="jx jy hu lr b fv lv lw l lx ly">class PuppyList extends React.Component {<br/>  <strong class="lr hv">constructor(props) {<br/>    super(props);<br/>    this.handleClick = this.handleClick.bind(this);</strong><br/>  }</span><span id="322c" class="jx jy hu lr b fv lz lw l lx ly">render() {</span><span id="b6a4" class="jx jy hu lr b fv lz lw l lx ly">const puppies = this.props.puppies.map((puppy, index) =&gt; &lt;Puppy name={puppy.name} showDescription={puppy.showDescription} key={index} clickFunction={this.handleClick}/&gt;);<br/>    <br/>    return &lt;div&gt; {puppies} &lt;/div&gt;<br/>  }</span><span id="dacf" class="jx jy hu lr b fv lz lw l lx ly">handleClick = (event) =&gt; {<br/>    this.props.puppies.map((hog) =&gt; {<br/>      if (puppy.name === event.target.name &amp;&amp; puppy.showDescription === false) {<br/>        return puppy.showDescription = true<br/>      } else if (puppy.name === event.target.value &amp;&amp; pupp.showDescription === true){<br/>        return puppy.showDescription = false<br/>      }<br/>    })<br/>}</span></pre><p id="3738" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">第2-4行传递props，并将this.handleClick函数的值重新分配给一个带有<em class="kx"> this </em>的版本。</p><p id="fd1b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">写海龟代码！不要写蜥蜴代码！</strong></p><h1 id="1d62" class="mb jy hu bd jz mc md me kd mf mg mh kh mi mj mk kk ml mm mn kn mo mp mq kq mr dt translated">结论</h1><p id="75a4" class="pw-post-body-paragraph iy iz hu ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hn dt translated">Reacts有时肯定会令人困惑，但归根结底，它只是带有一些怪异魔力的JavaScript。不要太担心魔法。从常规JavaScript逻辑的角度考虑问题。如果你不知道到底发生了什么，或者这是如何发生在JavaScript上的，查看一下文档，也许有些事情有点复杂，但是你可能会弄明白。</p><h2 id="2218" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr dt translated">资源</h2><div class="ni nj fm fo nk nl"><a href="https://facebook.github.io/react/docs/handling-events.html" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab ej"><div class="nn ab no cl cj np"><h2 class="bd hv fv z el nq eo ep nr er et ht dt translated">处理事件-反应</h2><div class="ns l"><h3 class="bd b fv z el nq eo ep nr er et ek translated">用于构建用户界面的JavaScript库</h3></div><div class="nt l"><p class="bd b gc z el nq eo ep nr er et ek translated">facebook.github.io</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz iw nl"/></div></div></a></div><div class="ni nj fm fo nk nl"><a href="https://facebook.github.io/react/docs/components-and-props.html" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab ej"><div class="nn ab no cl cj np"><h2 class="bd hv fv z el nq eo ep nr er et ht dt translated">组件和道具-反应</h2><div class="ns l"><h3 class="bd b fv z el nq eo ep nr er et ek translated">用于构建用户界面的JavaScript库</h3></div><div class="nt l"><p class="bd b gc z el nq eo ep nr er et ek translated">facebook.github.io</p></div></div><div class="nu l"><div class="oa l nw nx ny nu nz iw nl"/></div></div></a></div><div class="ni nj fm fo nk nl"><a href="https://facebook.github.io/react/docs/events.html" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab ej"><div class="nn ab no cl cj np"><h2 class="bd hv fv z el nq eo ep nr er et ht dt translated">合成事件-反应</h2><div class="ns l"><h3 class="bd b fv z el nq eo ep nr er et ek translated">用于构建用户界面的JavaScript库</h3></div><div class="nt l"><p class="bd b gc z el nq eo ep nr er et ek translated">facebook.github.io</p></div></div><div class="nu l"><div class="ob l nw nx ny nu nz iw nl"/></div></div></a></div><figure class="lm ln lo lp fq iv"><div class="bz el l di"><div class="oc od l"/></div></figure></div></div>    
</body>
</html>