# 测试 F.I.R.S.T

> 原文：<https://medium.com/hackernoon/test-f-i-r-s-t-65e42f3adc17>

测试是少数几个真正改变了我对软件的看法的想法之一。它已经成为我日常编程的一部分，一旦你学会使用它，它就会影响你写软件的方式。

开发一个软件而不进行测试就等同于开发一个没有版本控制系统的软件，或者在生产环境中有一个没有备份的数据库。真的很吓人！

创建好的测试是程序员的责任。测试是生产代码。对我个人来说，有好的测试比好的代码更重要。如果我有一个我信任的好的测试套件，我总是可以重构糟糕的代码。当你有一个好的测试套件时，重构是廉价的。

测试有许多特性，但今天我只谈第一原则。

*   快的
*   孤立/独立
*   可重复的
*   自我验证
*   彻底/及时

# 快的

我需要我的测试非常快！我想要一个快速反馈回路。我希望能够在我写的每一行代码上运行测试。我想知道我写的最后一行是否破坏了程序的行为。这样我可以很容易地识别出行不通的代码。

我希望我的测试像我的 IDE 一样。

当我犯语法错误时，IDE 会立即突出显示有语法错误的那一行。想象一下，当出现语法错误时，IDE 花了 5 分钟才给你反馈。你会等 5 分钟再写下一行吗？还是先写代码，然后“修复”错误？如果你的测试不够快，你就不会经常运行它们。如果你不经常运行它们，那么你就不会关注它们。如果你不注意你的测试，那么你就没有关于你进步的反馈回路。您希望 IDE 在 5 分钟后告诉您语法错误吗？

# 孤立/独立

我遵循 3A 法则。安排，行动，断言。

## 安排

这一步为您的测试用例构建必要的状态。我通常花时间为构建状态的变量和辅助函数想好名字。它们有助于更好地理解测试用例描述的情况。

## 行动

仅调用测试中的方法。

## 维护

断言合乎逻辑的结果/期望。逻辑断言可以有多个物理断言语句。我通常会考虑创建一些函数来描述单个或一组物理断言在测试用例的上下文中意味着什么。

# 可重复的

测试必须有确定的结果。假设我在被测试的方法被调用时提供了一个输入 X，那么结果应该总是 y。测试不应该受到它们被调用的顺序或者我运行它们的方式的影响。

每个测试都应该拥有和安排自己的数据。如果我与其他测试用例有共同的数据结构，那么我创建一个助手函数。助手函数名应该对两个测试用例都有意义。如果助手函数的名字对两个测试用例都没有意义，或者如果我找不到一个好名字来满足两个测试用例，那么我更喜欢用相同的代码有两个好名字的函数。我把这样的功能看作是偶然的复制。

# 自我验证

没有手动检查来检查测试是否通过。

# 彻底/及时

## 彻底的

我写测试的主要目标不是 100%的代码覆盖率。我的目标是拥有一个我可以信任的好的测试套件。但是信任到底意味着什么呢？对我来说，信任测试套件就是问下面这个问题:“我有信心将这些代码推向生产吗？”。如果答案是肯定的，那么我有一个可以信任的测试套件。我投入时间和精力来构建测试套件。

## 及时的

我实践 TDD，我在写代码之前写测试。这样我可以描述一个好的测试用例，然后去实现它。这意味着我让测试驱动设计。我让我想要实现的用例成为我的测试用例。我让测试用例描述行为/意图，我去实现行为。

通过首先编写测试，我被迫在我的测试用例中描述行为而不是实现，因为我还没有实现。这是一个很好的把戏！如果我决定重构，这意味着“改变实现而不改变行为”，那么我需要做的就是保持测试绿色。如果测试是绿色的，因为 TDD，行为是相同的。

## 进一步阅读

[http://agileinaflash.blogspot.gr/2009/02/first.html](http://agileinaflash.blogspot.gr/2009/02/first.html)