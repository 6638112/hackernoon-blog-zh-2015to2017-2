<html>
<head>
<title>Untangling Haskell’s Strings</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解开哈斯克尔的弦</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/untangling-haskells-strings-d47d2170cc4?source=collection_archive---------15-----------------------#2017-05-15">https://medium.com/hackernoon/untangling-haskells-strings-d47d2170cc4?source=collection_archive---------15-----------------------#2017-05-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="4ae0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Haskell也不是没有缺点。即使对于专业人士来说，最普遍承认的烦恼之一是跟踪不同的字符串类型。Haskell中总共有五种不同的字符串类型。记住Haskell是强类型的。所以如果我们想用不同的方式来表示字符串，我们必须有不同的类型。这激发了对这五种类型的需求，它们的用例略有不同。当你使用它们中的任何一个的时候，它都不是那么糟糕。但是当你不断地在它们之间转换时，这可能是一个大麻烦。在本文中，我们将讨论这五种不同的类型。我们将研究它们不同的用例，并观察如何在它们之间转换。</p><h1 id="423f" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">用线串</h1><p id="3943" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated"><code class="eh ks kt ku kv b">String</code>类型是Haskell中表示字符串的最基本形式。它是unicode字符列表<strong class="it hv">的简单类型同义词</strong>(<code class="eh ks kt ku kv b">Char</code>类型)。所以每当你在编译错误中看到<code class="eh ks kt ku kv b">[Char]</code>，要知道这是指基本的<code class="eh ks kt ku kv b">String</code>类型。默认情况下，当您在Haskell代码中输入一个字符串文字时，编译器会将其推断为一个<code class="eh ks kt ku kv b">String</code>。</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="65b9" class="le jq hu kv b fv lf lg l lh li">myFirstString :: String<br/>myFirstString = “Hello”</span></pre><p id="b80f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">字符串的列表表示给了我们一些有用的行为。因为字符串实际上是一个列表，所以我们可以使用Data.List中所有我们熟悉的函数。</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="c2ee" class="le jq hu kv b fv lf lg l lh li">&gt;&gt; let a = “Hello”<br/>&gt;&gt; map Data.Char.toUpper a<br/>“HELLO”<br/>&gt;&gt; ‘x’ : a<br/>“xHello”<br/>&gt;&gt; a ++ “ Person!”<br/>“Hello Person!”<br/>&gt;&gt; Data.List.sort “dbca”<br/>“abcd”</span></pre><p id="36a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">普通字符串类型的主要缺点是效率低下。这是不变性的结果。例如，假设我们有:</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="ee69" class="le jq hu kv b fv lf lg l lh li">myFirstString :: String<br/>myFirstString = “Hello”</span><span id="8d28" class="le jq hu kv b fv lj lg l lh li">myModifiedString :: String<br/>myModifiedString = map toLower (sort (myFirstString ++ “ Person!”))</span></pre><p id="c991" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将总共分配4个字符串。首先是<code class="eh ks kt ku kv b">myFirstString</code>。第二是“人！”字面意思。然后，我们可以追加这些内容，而无需创建另一个字符串。但是排序后的版本将是第三个分配，第四个将是小写版本。这种持续的分配会使我们的代码无法执行，并且<strong class="it hv">不适合重载操作</strong>。</p><h1 id="548d" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">文本</h1><p id="136b" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">字符串类型的<code class="eh ks kt ku kv b">Text</code>家族解决了这个难题。有两种<code class="eh ks kt ku kv b">Text</code>类型:严格型和懒惰型。大多数情况下，您会使用严格形式。然而，在你知道不需要完整字符串的某些情况下，惰性形式是有用的。</p><p id="673e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ks kt ku kv b">Text</code>的主要优势在于其功能受到“融合”。这意味着编译器实际上可以<strong class="it hv">防止我们在上一个例子中看到的多重分配的问题</strong>。例如，如果我们看这个:</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="e286" class="le jq hu kv b fv lf lg l lh li">import qualified Data.Char as C<br/>import qualified Data.Text as T<br/>optimizedTextVersion :: T.Text<br/>optimizedTextVersion = T.cons ‘c’ (T.map C.toLower (T.append (T.Text “Hello “) (T.Text “ Person!”)))</span></pre><p id="196e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这实际上只会在运行时分配一个<code class="eh ks kt ku kv b">Text</code>对象。这将使它<strong class="it hv">比<code class="eh ks kt ku kv b">String</code>版本</strong>更有效。所以对于大量文本处理的工业应用，你最好使用<code class="eh ks kt ku kv b">Text</code>类型而不是<code class="eh ks kt ku kv b">String</code>类型。</p><h1 id="3be2" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">字节字符串</h1><p id="542c" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">第三种类型属于<code class="eh ks kt ku kv b">ByteString</code>类别。和<code class="eh ks kt ku kv b">Text</code>一样，字节串也有严格和懒惰的变种。不过，惰性字节字符串比惰性文本值更常见一些。字节串是字符的<strong class="it hv">最低级别表示</strong>。这是你能得到的最接近真实机器水平的解释。字节串的核心是一系列<code class="eh ks kt ku kv b">Word8</code>对象。<code class="eh ks kt ku kv b">Word8</code>只是一个代表unicode字符的8位数字。</p><p id="661a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">大多数网络库将使用字节串，因为它们对<strong class="it hv">序列化</strong>最有意义。当您跨平台发送信息时，您无法确定另一端的编码。如果您将信息存储在数据库中，您通常也会希望使用字节字符串。像<code class="eh ks kt ku kv b">Text</code>类型一样，它们通常比字符串更有效。</p><h1 id="8f8f" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">转换</h1><p id="b6ff" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">因此，所有这些类型都存在，真正的问题是它们之间的转换。当你想写一些基本的代码，但你有一个不同的字符串类型时，这可能是非常令人沮丧的。如果你不记得的话，你将不得不查找转换，这可能很烦人。我们的第一个例子是<code class="eh ks kt ku kv b">String</code>和<code class="eh ks kt ku kv b">Text</code>。这很简单。<code class="eh ks kt ku kv b">Data.Text</code>包导出了这两个函数，它们正是您想要的:</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="5869" class="le jq hu kv b fv lf lg l lh li">pack :: String -&gt; Text<br/>unpack :: Text -&gt; String</span></pre><p id="13cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ks kt ku kv b">Data.Text.Lazy</code>中有对等物。我们将在<code class="eh ks kt ku kv b">ByteStrings</code>和<code class="eh ks kt ku kv b">Strings</code>之间找到相似的函数。它们存在于<code class="eh ks kt ku kv b">Data.ByteString.Char8</code>包中:</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="59b7" class="le jq hu kv b fv lf lg l lh li">pack :: String -&gt; ByteString<br/>unpack :: ByteString -&gt; String</span></pre><p id="268a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，这些仅适用于严格的<code class="eh ks kt ku kv b">ByteStrings</code>。要在严格和懒惰之间转换，您需要来自文本类型的<code class="eh ks kt ku kv b">.Lazy</code>版本的函数。例如，<code class="eh ks kt ku kv b">Data.Text.Lazy</code>出口:</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="fa07" class="le jq hu kv b fv lf lg l lh li">toStrict :: Data.Text.Lazy.Text -&gt; Data.Text.Text -- (Lazy to strict)<br/>fromStrict :: Data.Text.Text -&gt; Data.Text.Lazy.Text -- (Strict to lazy)</span></pre><p id="1b0a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ks kt ku kv b">Data.ByteString.Lazy</code>中有对等词。我们要讨论的最后一个转换是在<code class="eh ks kt ku kv b">Text</code>和<code class="eh ks kt ku kv b">ByteString</code>之间。您可以使用<code class="eh ks kt ku kv b">String</code>作为具有上述功能的中间类型。但是这需要对编码做一定的假设，并且容易失败。从<code class="eh ks kt ku kv b">Text</code>到<code class="eh ks kt ku kv b">ByteString</code>很简单，假设<strong class="it hv">你知道你的数据格式</strong>。以下功能存在于<code class="eh ks kt ku kv b">Data.Text.Encoding</code>中:</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="398b" class="le jq hu kv b fv lf lg l lh li">encodeUtf8 :: Text -&gt; ByteString</span><span id="3842" class="le jq hu kv b fv lj lg l lh li">-- LE = Little Endian format, BE = Big Endian</span><span id="3ddf" class="le jq hu kv b fv lj lg l lh li">encodeUtf16LE :: Text -&gt; ByteString<br/>encodeUtf16BE :: Text -&gt; ByteString<br/>encodeUtf32LE :: Text -&gt; ByteString<br/>encodeUtf32BE :: Text -&gt; ByteString</span></pre><p id="2599" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一般来说，您将使用UTF8编码的文本，因此<code class="eh ks kt ku kv b">encodeUtf8</code>。解码稍微复杂一点。这个库中有简单的函数:</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="e4bd" class="le jq hu kv b fv lf lg l lh li">decodeUtf8 :: ByteString -&gt; Text<br/>decodeUtf16LE :: ByteString -&gt; Text<br/>decodeUtf16BE :: ByteString -&gt; Text<br/>decodeUtf32LE :: ByteString -&gt; Text<br/>decodeUtf32BE :: ByteString -&gt; Text</span></pre><p id="bdd5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是如果您的字节字符串与格式不匹配，这些会抛出错误。运行时异常是不好的，所以对于UTF8，我们有这个函数:</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="7ce0" class="le jq hu kv b fv lf lg l lh li">decodeUtf8’ :: ByteString -&gt; Either UnicodeException Text</span></pre><p id="88fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这让我们将它包装在一个<code class="eh ks kt ku kv b">Either</code>中，并处理可能的错误。对于其他格式，我们必须依赖如下函数:</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="6c82" class="le jq hu kv b fv lf lg l lh li">decodeUtf16LEWith :: OnDecodeError -&gt; ByteString -&gt; Text</span></pre><p id="d1b0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">其中<code class="eh ks kt ku kv b">OnDecodeError</code>是特定类型的处理器。这些功能可能特别麻烦和难以处理。幸运的是，您将最经常使用UTF8。</p><h1 id="68c4" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">过载字符串</h1><p id="d616" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">因此，在我的文章中，我们还没有过多地涉及语言扩展。但这是我们第一个真实的例子。它旨在向您展示<strong class="it hv">语言扩展并不特别可怕</strong>！正如我们前面看到的，Haskell通常会将代码中的字符串解释为<code class="eh ks kt ku kv b">String</code>类型。这意味着您不能拥有以下代码:</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="22e2" class="le jq hu kv b fv lf lg l lh li">-- Fails<br/>myText :: Text<br/>myText = “Hello”</span><span id="45cf" class="le jq hu kv b fv lj lg l lh li">myBytestring :: ByteString<br/>myBytestring = “Hello”</span></pre><p id="1426" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">编译器希望这两个值都是<code class="eh ks kt ku kv b">String</code>类型，而不是您给定的类型。所以这通常会抛出编译器错误。然而，使用<code class="eh ks kt ku kv b">OverloadedStrings</code>扩展，您可以修复这个问题！扩展使用类似<code class="eh ks kt ku kv b">{-# LANGUAGE … #-}</code>的标签。它们通常被添加到源文件的顶部。</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="1842" class="le jq hu kv b fv lf lg l lh li">{-# LANGUAGE OverloadedStrings #-}<br/>-- This works!<br/>myText :: Text<br/>myText = “Hello”</span><span id="96c6" class="le jq hu kv b fv lj lg l lh li">myBytestring :: ByteString<br/>myBytestring = “Hello”</span></pre><p id="9705" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">事实上，对于您创建的任何类型，您都可以创建一个<code class="eh ks kt ku kv b">IsString</code> typeclass的实例。这将允许您使用字符串来表示它。</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="466a" class="le jq hu kv b fv lf lg l lh li">{-# LANGUAGE OverloadedStrings #-}</span><span id="fc0f" class="le jq hu kv b fv lj lg l lh li">import qualified Data.String (IsString(..))</span><span id="3b26" class="le jq hu kv b fv lj lg l lh li">data MyType = MyType String</span><span id="c5b3" class="le jq hu kv b fv lj lg l lh li">instance IsString MyType where<br/>  fromString s = MyType s</span><span id="0374" class="le jq hu kv b fv lj lg l lh li">myTypeAsString :: MyType<br/>myTypeAsString = “Hello”</span></pre><p id="6ebc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您也可以在GHCI中启用此扩展。你需要使用命令<code class="eh ks kt ku kv b">:set -XOverloadedStrings</code>。</p><h1 id="4a6c" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">摘要</h1><p id="7bb3" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">Haskell使用5种不同的类型来表示字符串。其中两个是懒惰版本。<code class="eh ks kt ku kv b">String</code>类型是字符列表的类型同义词，通常效率很低。<code class="eh ks kt ku kv b">Text</code>以稍微不同的方式表示字符串，并且可以将操作融合在一起以提高效率。<code class="eh ks kt ku kv b">ByteString</code>是最适合序列化的低级表示。类型之间的转换方式有很多，很难保持直线。最后，<code class="eh ks kt ku kv b">OverloadedStrings</code>编译器可以让你的生活更轻松。它允许你用一个字符串来引用你的任何不同的字符串类型。</p><p id="2ff2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你还没有机会开始使用Haskell，你应该看看我们的<a class="ae lk" href="https://mmhaskell.com/checklist" rel="noopener ugc nofollow" target="_blank">入门清单</a>。它将指导您完成安装和一些基础知识！</p><p id="0134" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下周一定要回来看看！现在我们已经理解了字符串，我们将分成不同类型的另一个潜在棘手的系统。我们将研究不同的数字类型以及可以在它们之间运行的简单转换。</p><blockquote class="ll lm ln"><p id="99d3" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated"><a class="ae lk" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae lk" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae lk" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae lk" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae lk" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae lk" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上给我们点赞/发消息</a>，或者简单地说，<a class="ae lk" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lk" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lk" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>