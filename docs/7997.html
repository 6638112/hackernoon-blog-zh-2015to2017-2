<html>
<head>
<title>A JavaScript Interview Question and a Digression into XOR</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个JavaScript面试问题和XOR的题外话</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-javascript-interview-question-and-a-digression-into-xor-3f88bb5ab3be?source=collection_archive---------13-----------------------#2017-11-15">https://medium.com/hackernoon/a-javascript-interview-question-and-a-digression-into-xor-3f88bb5ab3be?source=collection_archive---------13-----------------------#2017-11-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/ebbf6424128f3e9da1b014961e16e3e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yLddjqhFTmNgIDbctWdA6w.png"/></div></div></figure><div class=""/><p id="5561" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是我从一位同事那里学到的一个问题。我在进行JavaScript采访时曾问过这个问题，但它实际上是一个与语言无关的脑筋急转弯:</p><blockquote class="ka kb kc"><p id="e80a" class="jc jd kd je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated">假设有一个由0到99(包括0和99)的整数组成的100项数组。从数组中随机取出一个项目。如果只给你一个由99个元素组成的数组，你如何找到被去掉的那个数字？假设数组<strong class="je ig">没有排序</strong> <em class="if">。</em></p></blockquote><p id="219a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">也许是由于“未排序”这一限定符起到了转移注意力的作用，大多数受访者急于得到一个答案，其中第一步就是对阵列进行排序:</p><blockquote class="ka kb kc"><p id="3d10" class="jc jd kd je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated">我将首先对数组进行排序，然后遍历一次，查看后续项之间的差异。缺失的数字可以在差值不为1时找到。</p></blockquote><p id="6922" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是一个有效的算法，但是由于涉及到排序，计算量会很大。然后我问他们是否能想出一个只需要遍历一次数组的解决方案。有很多方法可以解决这个问题，我喜欢把它作为面试问题的原因是，它展示了对机器在幕后做什么的更深入的理解(即<code class="eh kh ki kj kk b">Array.prototype.sort</code>不只是免费地神奇地对数组进行排序。)</p><p id="a94c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以下只是几个最优答案中的一个。之后，我将展示一个替代的、更“古怪”的答案——正是这个<em class="kd">答案促使我写这篇短文。</em></p></div><div class="ab cl kl km hc kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hn ho hp hq hr"><p id="0069" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果将99项数组中的所有项相加，并且知道0到99之间所有整数的期望和，则可以通过从该期望和中减去数组中各项的和来找到缺少的数字。</p><p id="85c0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">整数之和[0..n]可以使用下面的公式计算:</p><pre class="kt ku kv kw fq kx kk ky kz aw la dt"><span id="5dda" class="lb lc if kk b fv ld le l lf lg">n * (n + 1) / 2</span></pre><p id="84cd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以，对于整数[0..99]我们知道总和是:</p><pre class="kt ku kv kw fq kx kk ky kz aw la dt"><span id="c42e" class="lb lc if kk b fv ld le l lf lg">99 * (99 + 1) / 2 === 4950</span></pre><p id="1a82" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">顺便说一下，下面是如何准备一个缺少数字的数组(不是问题或答案的一部分，但您可以使用此设置来测试不同的答案):</p><pre class="kt ku kv kw fq kx kk ky kz aw la dt"><span id="37f2" class="lb lc if kk b fv ld le l lf lg">const n = 99;</span><span id="1043" class="lb lc if kk b fv lh le l lf lg">// Will hold all numbers [0..99]<br/>const all = [];</span><span id="9d30" class="lb lc if kk b fv lh le l lf lg">for (let i = 0; i &lt;= n; i++) {<br/>  all.push(i);<br/>}</span><span id="1e36" class="lb lc if kk b fv lh le l lf lg">// Shuffle array by "sorting" by random comparison results<br/>all.sort(() =&gt; Math.random() - 0.5);</span><span id="36ff" class="lb lc if kk b fv lh le l lf lg">// Get a clone not to mess with the original array<br/>const partial = all.slice(0);</span><span id="3342" class="lb lc if kk b fv lh le l lf lg">// Remove a random item<br/>partial.splice(partial.length * Math.random() | 0, 1);</span></pre><p id="29c3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那么，我们答案的一个常规实现将是:</p><pre class="kt ku kv kw fq kx kk ky kz aw la dt"><span id="09fb" class="lb lc if kk b fv ld le l lf lg">const expectedSum = 99 * (99 + 1) / 2;</span><span id="b51e" class="lb lc if kk b fv lh le l lf lg">let partialSum = 0;</span><span id="ad04" class="lb lc if kk b fv lh le l lf lg">for (let i = 0; i &lt; partial.length; i++) {<br/>  partialSum += partial[i];<br/>}</span><span id="c634" class="lb lc if kk b fv lh le l lf lg">const missingNumber = expectedSum - partialSum; // Done!</span></pre><p id="5a95" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">或者，使用<code class="eh kh ki kj kk b"><a class="ae ks" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" rel="noopener ugc nofollow" target="_blank">Array.protoype.reduce()</a></code>和箭头功能:</p><pre class="kt ku kv kw fq kx kk ky kz aw la dt"><span id="0baf" class="lb lc if kk b fv ld le l lf lg">const expectedSum = 99 * (99 + 1) / 2;<br/>const missingNumber = expectedSum - partial.reduce((s, n) =&gt; s + n);</span></pre><p id="b30e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们只是对已知的和进行硬编码，我们会得到这个简洁的一行程序，它直接计算出缺失的数字:</p><pre class="kt ku kv kw fq kx kk ky kz aw la dt"><span id="2d1b" class="lb lc if kk b fv ld le l lf lg">const missingNumber = 4950 - partial.reduce((s, n) =&gt; s + n);</span></pre><p id="87ec" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们现在在<code class="eh kh ki kj kk b">missingNumber</code>找到了答案。对于所有的意图和目的，这是一个正确的答案，我们完成了。</p><p id="b2e2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在上面的回答中，我们使用了求和的方法，通过从期望和中减去部分和来直接找到缺失的数字。我们实际上是使用一个已知的校验和来查找一组值中的差异(例如，缺失的项目)。</p></div><div class="ab cl kl km hc kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hn ho hp hq hr"><p id="a95a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">求和并不是计算校验和时唯一起作用的操作。在校验和计算以及加密中出现的一个有用的运算符是XOR ( <a class="ae ks" href="https://en.wikipedia.org/wiki/Exclusive_or" rel="noopener ugc nofollow" target="_blank">异或</a>)。)</p><p id="fad7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以直接找到丢失数字的另一种方法是通过将部分数组中所有项的异或与所有整数的已知异或[0..99].最终的实现看起来更有趣。我们一会儿就会谈到它。</p><p id="8f50" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，快速回顾一下XOR ( <code class="eh kh ki kj kk b">^</code>)的作用。在位一级:</p><pre class="kt ku kv kw fq kx kk ky kz aw la dt"><span id="2bc8" class="lb lc if kk b fv ld le l lf lg">0 ^ 0 === 0<br/>0 ^ 1 === 1<br/>1 ^ 0 === 1<br/>1 ^ 1 === 0</span></pre><p id="6153" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">除了单个位之外，对任意两个数进行异或运算意味着按最低有效位对齐它们的位，并对每个对齐的位对进行异或运算。我们以<code class="eh kh ki kj kk b">3 ^ 5</code>为例。<code class="eh kh ki kj kk b">3</code>在二进制中是<code class="eh kh ki kj kk b">011</code>，而<code class="eh kh ki kj kk b">5</code>在二进制中是<code class="eh kh ki kj kk b">101</code>:</p><pre class="kt ku kv kw fq kx kk ky kz aw la dt"><span id="565c" class="lb lc if kk b fv ld le l lf lg">  011<br/>^ 101<br/>-----<br/>  110</span></pre><p id="3f6f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以二进制的<code class="eh kh ki kj kk b">3 ^ 5</code>结果是<code class="eh kh ki kj kk b">110</code>。或者用十进制，<code class="eh kh ki kj kk b">6</code>。</p><p id="d835" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">XOR有以下我们感兴趣的性质:</p><ul class=""><li id="cf3a" class="li lj if je b jf jg jj jk jn lk jr ll jv lm jz ln lo lp lq dt translated"><code class="eh kh ki kj kk b">0</code>是<a class="ae ks" href="https://en.wikipedia.org/wiki/Identity_element" rel="noopener ugc nofollow" target="_blank">标识元素</a> : <code class="eh kh ki kj kk b">a ^ 0 === a</code></li><li id="38d5" class="li lj if je b jf lr jj ls jn lt jr lu jv lv jz ln lo lp lq dt translated">每个数字都是它自己的<a class="ae ks" href="https://en.wikipedia.org/wiki/Inverse_element" rel="noopener ugc nofollow" target="_blank">逆元素</a> : <code class="eh kh ki kj kk b">a ^ a === 0</code></li><li id="d6ab" class="li lj if je b jf lr jj ls jn lt jr lu jv lv jz ln lo lp lq dt translated"><a class="ae ks" href="https://en.wikipedia.org/wiki/Associative_property" rel="noopener ugc nofollow" target="_blank">关联性</a> : <code class="eh kh ki kj kk b">(a ^ b) ^ c === a ^ (b ^ c)</code></li></ul><p id="8c1a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从上面可以看出，您可以通过将一个数字<code class="eh kh ki kj kk b">a</code>与任意一个数字<code class="eh kh ki kj kk b">b</code>进行两次异或运算来恢复该数字的值。假设<code class="eh kh ki kj kk b">c</code>由下式获得:</p><pre class="kt ku kv kw fq kx kk ky kz aw la dt"><span id="9281" class="lb lc if kk b fv ld le l lf lg">c = a ^ b;</span></pre><p id="fcce" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那么<code class="eh kh ki kj kk b">c</code>再次与<code class="eh kh ki kj kk b">b</code>异或的结果是什么？分4步进行:</p><ol class=""><li id="6402" class="li lj if je b jf jg jj jk jn lk jr ll jv lm jz lw lo lp lq dt translated">替换:<code class="eh kh ki kj kk b">c ^ b === (a ^ b) ^ b</code></li><li id="0982" class="li lj if je b jf lr jj ls jn lt jr lu jv lv jz lw lo lp lq dt translated">关联性:<code class="eh kh ki kj kk b">c ^ b === a ^ (b ^ b)</code></li><li id="4bd9" class="li lj if je b jf lr jj ls jn lt jr lu jv lv jz lw lo lp lq dt translated">逆元素:<code class="eh kh ki kj kk b">c ^ b === a ^ 0</code></li><li id="ceb1" class="li lj if je b jf lr jj ls jn lt jr lu jv lv jz lw lo lp lq dt translated">身份:<code class="eh kh ki kj kk b">c ^ b === a</code></li></ol><p id="edb1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们得到原始值，<code class="eh kh ki kj kk b">a</code>。</p><p id="9c21" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由此我们可以直观地得出以下结论:给定一个数字<code class="eh kh ki kj kk b">a</code>，如果我们首先将它与99个其他数字进行异或运算，然后将结果与同样的99个数字进行异或运算，我们应该会得到<code class="eh kh ki kj kk b">a</code>。</p><p id="0610" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，我们可以通过以下方式找到问题中缺少的数字:</p><ol class=""><li id="034c" class="li lj if je b jf jg jj jk jn lk jr ll jv lm jz lw lo lp lq dt translated">计算或硬编码所有100个数字的异或[0..99]</li><li id="4e64" class="li lj if je b jf lr jj ls jn lt jr lu jv lv jz lw lo lp lq dt translated">计算部分数组中给定的所有99个数的异或</li><li id="6bdc" class="li lj if je b jf lr jj ls jn lt jr lu jv lv jz lw lo lp lq dt translated">将上面的两个结果进行异或运算，直接找到缺失的数字</li></ol><p id="0150" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以，让我们计算所有数字[0..99]以便在我们的回答中硬编码。但是让我们一边看<code class="eh kh ki kj kk b">xor</code>的中间值一边做这件事:</p><pre class="kt ku kv kw fq kx kk ky kz aw la dt"><span id="6807" class="lb lc if kk b fv ld le l lf lg">let xor = 0; // 0 is the identity for XOR</span><span id="ee66" class="lb lc if kk b fv lh le l lf lg">for (var n = 0; n &lt;= 99; n++) {<br/>  xor ^= n;<br/>  console.log(xor);<br/>}</span></pre><p id="797d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面的输出将是:</p><pre class="kt ku kv kw fq kx kk ky kz aw la dt"><span id="32e0" class="lb lc if kk b fv ld le l lf lg">0<br/>1<br/>3<br/>0<br/>4<br/>1<br/>7<br/>0<br/>8<br/>1<br/>11<br/>0<br/>…<br/>0<br/>88<br/>1<br/>91<br/>0<br/>92<br/>1<br/>95<br/>0<br/>96<br/>1<br/>99<br/>0</span></pre><p id="cbd7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为我们本质上是将位混合在一起，所以滚动XOR不会单调增加。有许多下降会回到0。因此，与这些相同数字的总和不同，我们不会得出像4950这样的大数字。以及所有数字[0..99]才原来是0！(原因的简短版本是偶数比特的XOR将总是以0结束。)</p><pre class="kt ku kv kw fq kx kk ky kz aw la dt"><span id="95bb" class="lb lc if kk b fv ld le l lf lg">const expectedXor = 0; // Assume we know this for [0..99] already</span><span id="cdb4" class="lb lc if kk b fv lh le l lf lg">let partialXor = 0;</span><span id="3355" class="lb lc if kk b fv lh le l lf lg">for (let i = 0; i &lt; partial.length; i++) {<br/>  partialXor ^= partial[i];<br/>}</span><span id="8dd0" class="lb lc if kk b fv lh le l lf lg">const missingNumber = expectedXor ^ partialXor; // Done!</span></pre><p id="3e37" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">应用我们在前面的回答中使用的同样简洁的语法，并且知道0是XOR的单位元素，下面直接给出了缺少的数字:</p><pre class="kt ku kv kw fq kx kk ky kz aw la dt"><span id="fa09" class="lb lc if kk b fv ld le l lf lg">const missingNumber = partial.reduce((x, n) =&gt; x ^ n);</span></pre><p id="6e91" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这个上下文中使用XOR在技术上没有什么突破性的。只是偶然发现数字的异或[0..99]原来是0，这让第二个答案看起来有趣了很多，也制造了一个很好的借口，把题外话写成这样的XOR。</p><h1 id="79d7" class="lx lc if bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt dt translated">奖金</h1><p id="2bd0" class="pw-post-body-paragraph jc jd if je b jf mu jh ji jj mv jl jm jn mw jp jq jr mx jt ju jv my jx jy jz hn dt translated">我涉足JavaScript <a class="ae ks" href="https://en.wikipedia.org/wiki/Code_golf" rel="noopener ugc nofollow" target="_blank">代码高尔夫</a>并在<a class="ae ks" href="http://register.jsgolf.club" rel="noopener ugc nofollow" target="_blank"> jsgolf </a> Slack团队闲逛。我在那里问这个问题，是想看看高尔夫社区会把已经非常简洁的<code class="eh kh ki kj kk b">a.reduce((x,n)=&gt;x^n)</code>(称为数组<code class="eh kh ki kj kk b">a</code>，去掉了空格)答案发挥到什么程度。</p><p id="22f8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">结果如下:</p><pre class="kt ku kv kw fq kx kk ky kz aw la dt"><span id="f78b" class="lb lc if kk b fv ld le l lf lg">eval(a.join`^`)</span></pre><p id="6619" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以上答案的功劳归于<a class="ae ks" href="https://github.com/veu" rel="noopener ugc nofollow" target="_blank"> veubeke </a>和<a class="ae ks" href="https://twitter.com/justecorruptio" rel="noopener ugc nofollow" target="_blank"> corruptio </a>。</p><p id="ff93" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">附:感谢Leigh Bryant对本文早期版本的编辑。</p></div></div>    
</body>
</html>