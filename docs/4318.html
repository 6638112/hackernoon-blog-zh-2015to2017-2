<html>
<head>
<title>Moving API requests in React to Redux-Saga’s</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将React中的API请求移动到Redux-Saga的</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/moving-api-requests-to-redux-saga-21780f49cbc8?source=collection_archive---------1-----------------------#2017-05-25">https://medium.com/hackernoon/moving-api-requests-to-redux-saga-21780f49cbc8?source=collection_archive---------1-----------------------#2017-05-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/86f4faf230bc3024f8595473202cfaba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q9CRTmO258jWLsMZAd5JLw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">This image is a nice representation of how modern web-applications work. I found it on this article about <a class="ae jg" href="http://www.robert-drummond.com/2013/05/08/how-to-build-a-restful-web-api-on-a-raspberry-pi-in-javascript-2/" rel="noopener ugc nofollow" target="_blank">Web API’s on a Raspberry Pi</a></figcaption></figure><p id="2a97" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">去年，我们在<a class="ae jg" href="http://www.greenhousegroup.com" rel="noopener ugc nofollow" target="_blank">温室集团</a>开发了几个基于React的应用程序。</p><p id="b8b0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我最近在做的一个项目是一个内部工具，用来监控我们公司营销人员的营销费用。<br/>我的职责是根据我们获得的经验和团队建立的概念验证来设置这个新工具。</p><p id="4817" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我想和你分享一下我们如何创建这个应用程序的故事。我们使用了什么工具，我们在哪里偏离了传统的道路。</p><h2 id="6579" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">我们的工具包</h2><p id="c56a" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">为了让你对我们使用的工具有个概念，这里列出了我们日常使用的工具:</p><p id="49f7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们使用<a class="ae jg" href="https://babeljs.io" rel="noopener ugc nofollow" target="_blank"> Babel 6 </a>来传输我们的ES6编写的代码，以准备生产。Webpack作为我们的开发服务器运行，是为验收和生产环境构建和编译代码的引擎。对林挺来说，我们依赖于<a class="ae jg" href="http://eslint.org" rel="noopener ugc nofollow" target="_blank"> ESLint </a>(带有一些定制的<a class="ae jg" href="https://www.npmjs.com/package/eslint-config-airbnb" rel="noopener ugc nofollow" target="_blank"> AirBnB预置</a>，我们使用<a class="ae jg" href="https://facebook.github.io/jest/" rel="noopener ugc nofollow" target="_blank"> Jest </a>来测试我们的代码。</p><p id="e84a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当我们最初开始时，我们知道我们必须实现某种状态管理，我们可以在应用程序范围内存储数据，而不仅仅是每个组件，以便在用户在视图之间切换时更加持久。从我们开始React开发的那一刻起，我们就接受了Redux，并一直使用它。尽管它可能有缺陷，并且不像Mobx那样广泛，但是它服务于我们的目的，并且直到今天还没有给我们带来任何实现问题。</p><h2 id="c6a4" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">添加API请求以做出反应</h2><p id="9cc4" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">当你创建一个网络应用程序时，仅仅有一个静态前端是不够的。我们需要来自API的数据，在Javascript中，传统的获取方式是通过<a class="ae jg" href="https://developer.mozilla.org/nl/docs/Web/API/XMLHttpRequest" rel="noopener ugc nofollow" target="_blank"> XMLHttpRequests </a>。由于我们正在构建内部应用程序(其中一个甚至是电子应用程序)，我们不必太担心浏览器的覆盖范围。我们只需要支持Google Chrome，所以甚至在我们用XMLHttpRequest实现API调用之前，我们就决定尝试一下新的<a class="ae jg" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank"> Fetch API </a>。</p><p id="a8a6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">那么接下来的问题就来了，如何用React发出API请求？最常见的答案是在那个时候(2016年初)在<code class="eh lf lg lh li b">ComponentDidMount</code>做。您从请求中得到的响应将存储在组件的本地状态中，并且您能够呈现获取的数据。</p><blockquote class="lj"><p id="0fec" class="lk ll hu bd lm ln lo lp lq lr ls ke ek translated">但是对于一个组件中的数据，如何将相同的数据传递给兄弟组件呢？</p></blockquote><h2 id="5712" class="kf kg hu bd kh ki lt kk kl km lu ko kp js lv kr ks jw lw ku kv ka lx kx ky kz dt translated">将API请求从组件中移出</h2><p id="4559" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">我们应该将请求转移到父节点吗？但是，如果我们将“组件状态”与Redux同步，并使其在应用程序范围的状态下可用，会怎么样呢？</p><p id="33af" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一种选择是将请求转移到国家行动。但是动作可能不会被阻塞，而获取请求会被阻塞。所以下一步是找出<a class="ae jg" href="https://github.com/gaearon/redux-thunk" rel="noopener ugc nofollow" target="_blank"> Redux-Thunk </a>。有了Redux-Thunk，你将得到一个中间件，它对Redux动作作出反应，做它的事情，然后再次分派其他动作。</p><p id="c39f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们摆弄了一段时间thunks，但是我们最终得到了相当多的副作用，这些副作用给测试带来了问题，并且不容易阅读。有了thunks，你可以调度一个动作，然后这个动作完成它的工作并调度另一个动作。这可能是我们的方法有点偏离，或者它还不够成熟，但我们正在寻找一种方法，在这种方法中，我们可以更容易地跟踪我们在这个状态中的行为的副作用。</p><h2 id="e0f7" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">然后Redux-Saga进来了</h2><p id="6e87" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">2016年10月，我们遇到了<a class="ae jg" href="https://redux-saga.js.org" rel="noopener ugc nofollow" target="_blank"> Redux-Saga </a>，很快我们就发现它可以解决我们的问题。在一些概念之后，不到一个月后，我们将我们的第一个传奇集成到我们的一个应用程序中。Thunks和Saga的主要区别在于，Thunks是基于被调度的动作来控制的，而Saga则独立地监听动作，更像是reducers，并据此行动。</p><p id="51cd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在传奇中，要求一个特定的任务并不复杂，根据传奇中特定步骤的有效载荷和结果，结果将开始。</p><h2 id="87fa" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">用实际代码解释</h2><p id="8fcf" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">我想给你一个例子，说明我们如何在代码中进行API请求，这可能会澄清这个复杂的问题；</p><p id="16ad" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们的大多数组件都用Redux' connect包装，我们称之为连接器。最简单的连接器可能如下所示:</p><pre class="ly lz ma mb fq mc li md me aw mf dt"><span id="21fb" class="kf kg hu li b fv mg mh l mi mj">import { connect } from 'react-redux';<br/><br/>import App from 'components/app';<br/><br/>export default connect()(App);</span></pre><p id="4f59" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一旦一个组件被挂载，我们希望获取数据，这样它就可以显示在组件的渲染中。</p><p id="8547" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是其中的一个组成部分:</p><pre class="ly lz ma mb fq mc li md me aw mf dt"><span id="1aa9" class="kf kg hu li b fv mg mh l mi mj">import React from 'react';<br/><br/>export default class App extends Component {<br/>    componentDidMount() {<br/>        this.props.fetchRecords();<br/>    }<br/>    <br/>    render() {<br/>        const { records } = this.props;<br/>        <br/>        return (<br/>            &lt;div className="app"&gt;<br/>                {records.map(record =&gt; (<br/>                    &lt;div className="record" key={record.id}&gt;{record.name}&lt;/div&gt;<br/>                ))}<br/>            &lt;/div&gt;<br/>        );<br/>    }<br/>}</span></pre><p id="ad4d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="mk">(为了保持我的代码块小，我没有在示例中添加PropTypes)</em></p><p id="e578" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">正如你所看到的，我使用了两个没有包含在初始连接器中的道具。所以我必须编辑那个文件。我将向Redux connect添加一个dispatchToProps和一个stateToProps。一旦被调用，第一个将向商店发送一个动作。stateToProps将数据直接从记录缩减器传递到组件。</p><blockquote class="ml mm mn"><p id="cfcc" class="jh ji mk jj b jk jl jm jn jo jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd ke hn dt translated">在我的例子中，我将直接从state加载数据，但是在内部，我们使用选择器(通常与<a class="ae jg" href="https://github.com/reactjs/reselect" rel="noopener ugc nofollow" target="_blank"> Reselect </a>结合使用)来更容易地重用状态选择器，并在reducers的引用改变时优化呈现，但是数据本身没有改变。</p></blockquote><pre class="ly lz ma mb fq mc li md me aw mf dt"><span id="eaaf" class="kf kg hu li b fv mg mh l mi mj">import { connect } from 'react-redux';<br/><br/>import App from 'components/app';<br/>import fetchRecords from 'actions/fetch-records';<br/><br/>const stateToProps = state =&gt; ({<br/>    records: state.records.data<br/>});<br/><br/>const dispatchToProps = {<br/>    fetchRecords<br/>};<br/><br/>export default connect()(App);</span></pre><p id="2d89" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，一旦组件被安装，它将调用<code class="eh lf lg lh li b">fetchRecords</code>，这是由于Redux Connect函数将把动作<code class="eh lf lg lh li b">fetchRecords</code>分派给商店。</p><p id="8a88" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我必须添加下面的代码来添加一个监听<code class="eh lf lg lh li b">fetchRecords</code>的传奇。由于我不会在本文中详细解释Redux-Saga，假设我有一个rootSaga，它将<code class="eh lf lg lh li b">spawn</code>我新创建的Saga。</p><pre class="ly lz ma mb fq mc li md me aw mf dt"><span id="50c3" class="kf kg hu li b fv mg mh l mi mj">import { takeLatest, put, call } from 'redux-saga/effects';<br/><br/>import fetchFailed from 'actions/fetch-failed';<br/>import setRecords from 'actions/set-records';<br/><br/>export default function* onFetchRecords() {<br/>  yield takeLatest('RECORDS/FETCH', function fetchRecords() {<br/><br/>    try {<br/>        const response = yield call(fetch, 'https://api.service.com/endpoint');<br/>        const responseBody = response.json();<br/>    } catch (e) {<br/>        yield put(fetchFailed(e));<br/>        return;<br/>    }<br/><br/>    yield put(setRecords(responseBody.records));<br/>  });<br/>}</span></pre><p id="f42c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在上面的例子中，你可以看到它会监听<code class="eh lf lg lh li b">RECORDS/FETCH</code>，一旦那个动作出现，它就会发出一个获取请求。当获取失败时，它将抛出一个异常。在这种情况下，我们将调度<code class="eh lf lg lh li b">fetchFailed</code>动作。当请求成功时，它将分派<code class="eh lf lg lh li b">setRecords</code>并传递我们从服务器获得的记录。</p><p id="2c65" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这里，您可以看到我们的减速器如何处理这些动作以及我们的传奇故事；</p><pre class="ly lz ma mb fq mc li md me aw mf dt"><span id="8b4f" class="kf kg hu li b fv mg mh l mi mj">export default (state = {data: [], loading: false}, action = {}) =&gt; {<br/>  switch (action.type) {<br/>    case 'RECORDS/FETCH':<br/>    case 'RECORDS/FETCH_FAILED':<br/>      return {<br/>          ...state,<br/>          loading: true,<br/>          data: []<br/>      };<br/>    case 'RECORDS/SET':<br/>      return {<br/>          ...state,<br/>          loading: false,<br/>          data: action.payload<br/>      };<br/>    default:<br/>      return state;<br/>  }<br/>};</span></pre><p id="9d80" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通过这些小段代码，我向您展示了如何将API调用从ComponentDidMount转移到Redux Saga，并在Reducers中轻松获得数据，而不仅仅是组件状态。</p><p id="a140" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对这个话题更感兴趣，或者这听起来比你在日常工作中做的更酷？让我知道！</p><div class="ly lz ma mb fq ab cb"><figure class="mr iv ms mt mu mv mw paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mr iv ms mt mu mv mw paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mr iv ms mt mu mv mw paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ml mm mn"><p id="f922" class="jh ji mk jj b jk jl jm jn jo jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd ke hn dt translated"><a class="ae jg" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是阿妹家庭的一员。我们现在<a class="ae jg" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jg" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jh ji mk jj b jk jl jm jn jo jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd ke hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jg" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jg" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ly lz ma mb fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mx"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="ly lz ma mb fq iv"><div class="bz el l di"><div class="my mz l"/></div></figure></div></div>    
</body>
</html>