<html>
<head>
<title>Comparing the Compilation Times of C++ Templates and Macros</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比较C++模板和宏的编译时间</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/comparing-the-compilation-times-of-templates-and-macros-d0a1b7264a17?source=collection_archive---------2-----------------------#2017-06-02">https://medium.com/hackernoon/comparing-the-compilation-times-of-templates-and-macros-d0a1b7264a17?source=collection_archive---------2-----------------------#2017-06-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="6390" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">TL；速度三角形定位法(dead reckoning)</h1><p id="186b" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">对于我们的例子，模板比生成的代码编译得更快。通过一些技巧，它们对于增量构建也更快。</p><figure class="ko kp kq kr fq ks fe ff paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="fe ff kn"><img src="../Images/e9528ba71b393fec00b452ced1c201c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HfFphhfeiC_plxNrB1lmDw.jpeg"/></div></div></figure><h1 id="ff1a" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">介绍</h1><p id="0b64" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">模板是C++的一个极端特征。一方面，人们喜欢挤出额外的性能并给他们的项目添加语法糖的能力。另一方面，一些人认为它们编译缓慢，二进制文件膨胀，给出难以理解的错误信息。</p><p id="ff00" class="pw-post-body-paragraph jp jq hu jr b js kz ju jv jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km hn dt translated">本文将着眼于模板的一个常见用例，并确定使用代码生成而不是模板是否可以提高编译时间。</p><h1 id="d43a" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">简单向量类</h1><p id="b074" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我们将看一个简单的vector类，它的大小是在编译时确定的。该类的用法可能如下所示:</p><figure class="ko kp kq kr fq ks"><div class="bz el l di"><div class="le lf l"/></div></figure><p id="518f" class="pw-post-body-paragraph jp jq hu jr b js kz ju jv jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km hn dt translated">实现非常简单:我们有一个常规的C++ <code class="eh lg lh li lj b">struct</code>,其中一个类型参数表示向量的长度:</p><figure class="ko kp kq kr fq ks"><div class="bz el l di"><div class="le lf l"/></div></figure><p id="2125" class="pw-post-body-paragraph jp jq hu jr b js kz ju jv jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km hn dt translated">然而，我们也可以使用预处理器来实现这个类！</p><figure class="ko kp kq kr fq ks"><div class="bz el l di"><div class="le lf l"/></div></figure><p id="33bb" class="pw-post-body-paragraph jp jq hu jr b js kz ju jv jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km hn dt translated">这两种实现为我们提供了等效的功能。然而，对于给定的大小<code class="eh lg lh li lj b">N</code>，第一个使用模板生成一个vector类，第二个使用宏。</p><p id="6721" class="pw-post-body-paragraph jp jq hu jr b js kz ju jv jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km hn dt translated"><strong class="jr hv">问题是:哪个编译得更快？</strong></p><p id="2769" class="pw-post-body-paragraph jp jq hu jr b js kz ju jv jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km hn dt translated">为了比较这两种方法，我们编写了一小段代码，使用长度从0到256的向量类。我们还测试了另一种方法，我们采用了宏实现，但是在测试之前运行了预处理器。这就相当于每节课都是手写的！</p><p id="f0f2" class="pw-post-body-paragraph jp jq hu jr b js kz ju jv jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km hn dt translated">我们将每个版本编译了100次，并测量了花费的时间。结果如下:</p><figure class="ko kp kq kr fq ks"><div class="bz el l di"><div class="le lf l"/></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">(<a class="ae lp" href="https://github.com/nikhedonia/template-instatiation-benchmark" rel="noopener ugc nofollow" target="_blank">source-code</a>)</figcaption></figure><h2 id="c5ef" class="lq is hu bd it lr ls lt ix lu lv lw jb ka lx ly jf ke lz ma jj ki mb mc jn md dt translated">结论</h2><p id="cd0b" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">结果表明，对于这个例子，<em class="lk">编译模板比等效的宏版本</em>更快！最重要的是，模板更容易维护，因为代码不会重复，编译器可以给出更好的错误消息。</p><p id="b12f" class="pw-post-body-paragraph jp jq hu jr b js kz ju jv jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km hn dt translated">如果你考虑模板是如何工作的，那么这是很有意义的。实例化一个模板只是用具体的值或类型替换它的模板参数。对于代码生成，我们必须解析C++并为每个宏结果从头开始构建AST。</p><p id="5fd8" class="pw-post-body-paragraph jp jq hu jr b js kz ju jv jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km hn dt translated"><strong class="jr hv">但是增量构建呢？</strong></p><p id="2073" class="pw-post-body-paragraph jp jq hu jr b js kz ju jv jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km hn dt translated">这个测试忽略了增量构建。使用代码生成的一个好处(据说！)的一个优点是，每个vector类的实现都可以放在自己的翻译单元中，这意味着每次使用它时都不必重新编译。</p><p id="09f9" class="pw-post-body-paragraph jp jq hu jr b js kz ju jv jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km hn dt translated">但是，我们可以使用模板达到同样的效果！C++ 11引入了<code class="eh lg lh li lj b">extern template</code>结构，它告诉编译器模板是在另一个翻译单元中编译的:</p><figure class="ko kp kq kr fq ks"><div class="bz el l di"><div class="le lf l"/></div></figure><p id="34f9" class="pw-post-body-paragraph jp jq hu jr b js kz ju jv jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km hn dt translated"><code class="eh lg lh li lj b">extern template</code>类似于模板的前向声明。</p><p id="a78a" class="pw-post-body-paragraph jp jq hu jr b js kz ju jv jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km hn dt translated">我们可以使用这种结构将最常见的模板实例化放到它们自己的翻译单元中，从而显著减少增量构建时间。</p><figure class="ko kp kq kr fq ks"><div class="bz el l di"><div class="le lf l"/></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">vector.cpp</figcaption></figure><p id="3f47" class="pw-post-body-paragraph jp jq hu jr b js kz ju jv jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km hn dt translated">我们<code class="eh lg lh li lj b">extern template</code>在vector头中的常见情况，以防止消费者编译他们自己的版本。</p><figure class="ko kp kq kr fq ks"><div class="bz el l di"><div class="le lf l"/></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">vector.hpp</figcaption></figure><p id="89fb" class="pw-post-body-paragraph jp jq hu jr b js kz ju jv jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km hn dt translated">然后我们运行增量构建(<code class="eh lg lh li lj b">vector.cpp</code>已经编译)。结果不言自明:</p><figure class="ko kp kq kr fq ks"><div class="bz el l di"><div class="le lf l"/></div></figure><p id="bc1a" class="pw-post-body-paragraph jp jq hu jr b js kz ju jv jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km hn dt translated">下一次当你试图提高你的增量构建时间的时候，考虑向前声明你的模板！</p><div class="ko kp kq kr fq ab cb"><figure class="me ks mf mg mh mi mj paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="me ks mf mg mh mi mj paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="me ks mf mg mh mi mj paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mk ml mm"><p id="f922" class="jp jq lk jr b js kz ju jv jw la jy jz mn lb kc kd mo lc kg kh mp ld kk kl km hn dt translated"><a class="ae lp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae lp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae lp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae lp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jp jq lk jr b js kz ju jv jw la jy jz mn lb kc kd mo lc kg kh mp ld kk kl km hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ko kp kq kr fq ks fe ff paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="fe ff mq"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>