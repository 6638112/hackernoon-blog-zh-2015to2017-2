<html>
<head>
<title>Recursion in JavaScript with ES6, destructuring and rest/spread</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES6 JavaScript中的递归、析构和rest/spread</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/recursion-in-javascript-with-es6-destructuring-and-rest-spread-4b22ae5998fa?source=collection_archive---------0-----------------------#2016-10-10">https://medium.com/hackernoon/recursion-in-javascript-with-es6-destructuring-and-rest-spread-4b22ae5998fa?source=collection_archive---------0-----------------------#2016-10-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="6315" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">JavaScript<a class="ae jp" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"/>(ECMAScript 6)的最新ECMA标准通过使用函数构造和新操作符鼓励更具声明性的风格，使JavaScript更具可读性。</p><h1 id="2db3" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">解构</h1><p id="fd09" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我最喜欢的ES6特性之一是<strong class="it hv">析构</strong>。它允许您通过使用<strong class="it hv">结构</strong>将数据从一个变量提取到另一个变量。例如，对于数组，这意味着:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="98df" class="lc jr hu ky b fv ld le l lf lg">var [ first, second ] = [ 1, 2, 3, 4 ];<br/>// first: 1<br/>// second: 2</span></pre><p id="41ca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你还可以做更多的事情，比如跳过运算右边数组的一些成员。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="ced1" class="lc jr hu ky b fv ld le l lf lg">var [ first, , third, fourth ] = [ 1, 2, 3, 4 ];<br/>// first: 1<br/>// third: 3<br/>// fourth: 4</span></pre><p id="657c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这实际上很容易移植到等效的ES5中</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="c06d" class="lc jr hu ky b fv ld le l lf lg">var arr = [ 1, 2, 3, 4 ];<br/>var first = arr[0];<br/>var second = arr[1];<br/>// etc ...</span></pre><h1 id="4654" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">休息</h1><p id="5302" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">这就是ES6特性变得更有趣的地方。通过析构，我们还可以分配数组的剩余部分<strong class="it hv">。我们用<code class="eh lh li lj ky b">...</code>符号表示<strong class="it hv">休止符</strong>。</strong></p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="846f" class="lc jr hu ky b fv ld le l lf lg">var [ first, ...notFirst ] = [ 1, 2, 3, 4 ];<br/>// first: 1<br/>// notFirst: [ 2, 3, 4 ]</span></pre><p id="8744" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">命名约定产生的代码更类似于以下代码:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="c414" class="lc jr hu ky b fv ld le l lf lg">var [ first, second, ...rest ] = [ 1, 2, 3, 4 ]<br/>// first: 1<br/>// second: 2<br/>// rest: [ 3, 4 ]</span></pre><p id="3005" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lh li lj ky b">rest</code>操作符有一些有趣的属性:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="ccb7" class="lc jr hu ky b fv ld le l lf lg">var [ first, ...rest ] = [ 1 ]<br/>// first: 1<br/>// rest: []</span></pre><p id="28a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它总是返回一个数组。这意味着即使在防御性的JavaScript领域，也可以在没有守卫的情况下做类似检查<code class="eh lh li lj ky b">rest</code>的<code class="eh lh li lj ky b">.length</code>这样的事情。</p><p id="a16e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">ES5(及以下)中的等价方法是使用<code class="eh lh li lj ky b">Array.slice</code>函数。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="ec67" class="lc jr hu ky b fv ld le l lf lg">var arr = [ 1, 2, 3, 4 ];<br/>var first = arr[0];<br/>var rest = arr.slice(1);<br/>// first: 1<br/>// rest: [ 2, 3, 4 ]</span></pre><p id="b865" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里要注意两件事:</p><ul class=""><li id="074a" class="lk ll hu it b iu iv iy iz jc lm jg ln jk lo jo lp lq lr ls dt translated">ES5版本更加冗长</li><li id="b0e0" class="lk ll hu it b iu lt iy lu jc lv jg lw jk lx jo lp lq lr ls dt translated">ES5版本更具命令性，我们告诉JavaScript <strong class="it hv">如何</strong>做某事，而不是告诉它<strong class="it hv">我们想要什么</strong>。</li></ul><p id="50fa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我也觉得结构匹配版(带rest)可读性更强。</p><h1 id="94d5" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">参数析构</h1><p id="3dd9" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们可以在函数定义的参数上使用析构:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="a3ae" class="lc jr hu ky b fv ld le l lf lg">function something([ first, ...rest ]) {<br/>  return {<br/>    first: first,<br/>    rest: rest<br/>  };<br/>}<br/>var result = something([1, 2, 3]);<br/>// result: { first: 1, rest: [ 2,3 ] }</span></pre><p id="8331" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">等效ES5:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="c01e" class="lc jr hu ky b fv ld le l lf lg">function something(arr){<br/>  var first = arr[0];<br/>  var rest = arr.slice(1);<br/>  return {<br/>    first: first,<br/>    rest: rest<br/>  };<br/>}</span></pre><p id="6d26" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样，它更冗长，也更有命令性。</p><h1 id="aaa0" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">传播</h1><p id="a52a" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">Spread使用与rest相同的符号:<code class="eh lh li lj ky b">...</code>。它的功能完全不同。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="c878" class="lc jr hu ky b fv ld le l lf lg">var arr = [ 1, 2, 3 ];<br/>var newArr = [ ...arr ];<br/>// newArr: [ 1, 2, 3]</span></pre><p id="92ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">ES5当量:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="3641" class="lc jr hu ky b fv ld le l lf lg">var arr = [ 1, 2, 3 ];<br/>var newArr = [].concat(arr);</span></pre><p id="9094" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">需要注意的是，数组的内容是<strong class="it hv">复制的</strong>。所以<code class="eh lh li lj ky b">newArr</code>不是对<code class="eh lh li lj ky b">arr</code>的引用。</p><p id="292b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还可以做一些事情，比如追加或者预先放置一个数组。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="ea78" class="lc jr hu ky b fv ld le l lf lg">var arr = [ 1, 2, 3] ;</span><span id="0710" class="lc jr hu ky b fv ly le l lf lg">var withPrepend = [ ...arr, 3, 2, 1];<br/>var withAppend = [ 3, 2, 1, ...arr ];<br/>// withPrepend: [ 1, 2, 3, 3, 2, 1]<br/>// withAppend: [ 3, 2, 1, 1, 2, 3 ]</span></pre><h1 id="53d6" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">函数式编程:列表和递归</h1><p id="3659" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在函数式编程中，当我们在列表上递归运行函数时，我们喜欢将列表建模为头部和尾部。</p><p id="0af1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">头部是列表的第一个元素，尾部是列表减去头部后的列表。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="b921" class="lc jr hu ky b fv ld le l lf lg">arr = [ 1, 2, 3 ]<br/>// head(arr): 1<br/>// tail(arr): [ 2, 3 ]</span></pre><p id="61c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在ES6中，我们可以通过用<strong class="it hv">析构</strong>和<strong class="it hv"> rest: </strong>适当地命名变量来做到这一点</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="2706" class="lc jr hu ky b fv ld le l lf lg">var [ head, ...tail ] = [ 1, 2, 3 ];<br/>// head: 1<br/>// tail: [ 2, 3 ]</span></pre><p id="9fd8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们也可以使用ES6轻松实现<code class="eh lh li lj ky b">head</code>和<code class="eh lh li lj ky b">tail</code>函数:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="f0cb" class="lc jr hu ky b fv ld le l lf lg">function head([ head, ...tail ]) { <br/>  return head;<br/>}<br/>function tail([ head, ...tail ]) {<br/>  return tail;<br/>}<br/>// or with arrow function syntax<br/>var head = ([ head, ...tail ]) =&gt; head;<br/>var tail = ([ head, ...tail ]) =&gt; tail;</span></pre><h2 id="aeb2" class="lc jr hu bd js lz ma mb jw mc md me ka jc mf mg ke jg mh mi ki jk mj mk km ml dt translated">(尾)递归</h2><p id="0b05" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们可以使用<strong class="it hv">参数析构</strong> <em class="mm"> </em>和<strong class="it hv">递归</strong>来实现操作数组(或列表，因为它们在函数式编程中更倾向于被调用)的函数。</p><p id="f729" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，map可以通过以下方式实现:</p><p id="2ece" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="mm"> Map是一个函数，它接受一个列表和一个函数，并返回一个列表，该列表包含函数应用于列表中每个元素的结果。</em></p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="2c51" class="lc jr hu ky b fv ld le l lf lg">function map([ head, ...tail ], fn) {<br/>  if(head === undefined &amp;&amp; !tail.length) return [];<br/>  if(tail.length === 0){<br/>    return [ fn(head) ];<br/>  }<br/>  return [ fn(head) ].concat(map(tail, fn));<br/>}</span></pre><p id="17f2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lh li lj ky b">tail.length === 0</code>检查是否还有一个尾部可以递归。否则，递归在此停止。</p><p id="352e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就内存使用和速度而言，这不一定是最有效的map版本，但它是ES6的一个很好的例子。</p><p id="e78a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以通过用<code class="eh lh li lj ky b">spread</code>操作符替换<code class="eh lh li lj ky b">concat</code>并使用带有三元操作符的单一返回语句来进一步简化它。</p><h2 id="aabc" class="lc jr hu bd js lz ma mb jw mc md me ka jc mf mg ke jg mh mi ki jk mj mk km ml dt translated">非常ES6地图</h2><p id="3e49" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们的ES6递归/析构映射可以简化为:</p><figure class="kt ku kv kw fq mn"><div class="bz el l di"><div class="mo mp l"/></div><figcaption class="mq mr fg fe ff ms mt bd b be z ek">Map implementation using ES6, destructuring and recursion</figcaption></figure><p id="eed7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者如果我们想滥用ES6，让自己忘记我们实际上是在做JavaScript:</p><figure class="kt ku kv kw fq mn"><div class="bz el l di"><div class="mo mp l"/></div><figcaption class="mq mr fg fe ff ms mt bd b be z ek">Map implementation using ES6, arrow function, destructuring and recursion</figcaption></figure><p id="8ddc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">ES5当量</p><figure class="kt ku kv kw fq mn"><div class="bz el l di"><div class="mo mp l"/></div><figcaption class="mq mr fg fe ff ms mt bd b be z ek">Map implementation using ES5 and recursion</figcaption></figure><p id="a16a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所有的特性加起来，虽然ES6中的递归映射本质上是一行程序，但在ES5中，它是一个笨重、冗长、难以阅读的函数。</p><h2 id="f41f" class="lc jr hu bd js lz ma mb jw mc md me ka jc mf mg ke jg mh mi ki jk mj mk km ml dt translated">重新实现列表操作函数</h2><p id="8276" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">现在你可以使用上面的技术重新实现<code class="eh lh li lj ky b">filter</code>、<code class="eh lh li lj ky b">reduce</code>和<code class="eh lh li lj ky b">join</code>。</p><p id="724c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">折下解:)。</p><p id="c5e7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">ES6允许我们用函数式风格更简洁有效地编写代码。</p><p id="a1f5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="mm">给一些💚如果你喜欢这篇文章，请点击</em> <strong class="it hv"> <em class="mm">关注</em> </strong> <em class="mm">了解更多与JavaScript相关的内容。</em></p><p id="7f8d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="mm">你可以在Twitter上找到我</em><a class="ae jp" href="https://twitter.com/hugo__df" rel="noopener ugc nofollow" target="_blank"><em class="mm">(at)Hugo _ _ df</em></a><em class="mm">，在GitHub上为</em><a class="ae jp" href="https://github.com/HugoDF" rel="noopener ugc nofollow" target="_blank"><em class="mm">HugoDF</em></a><em class="mm">，这里还有更多JavaScript gists</em><a class="ae jp" href="https://gist.github.com/HugoDF" rel="noopener ugc nofollow" target="_blank"><em class="mm"/></a><em class="mm">。</em></p><h2 id="6054" class="lc jr hu bd js lz ma mb jw mc md me ka jc mf mg ke jg mh mi ki jk mj mk km ml dt translated">ES6中带有rest/spread和析构的递归列表操作</h2><figure class="kt ku kv kw fq mn"><div class="bz el l di"><div class="mo mp l"/></div><figcaption class="mq mr fg fe ff ms mt bd b be z ek">Filter implementation using ES6, destructuring and recursion</figcaption></figure><figure class="kt ku kv kw fq mn"><div class="bz el l di"><div class="mo mp l"/></div><figcaption class="mq mr fg fe ff ms mt bd b be z ek">Reduce implementation using ES6, destructuring and recursion</figcaption></figure><figure class="kt ku kv kw fq mn"><div class="bz el l di"><div class="mo mp l"/></div><figcaption class="mq mr fg fe ff ms mt bd b be z ek">Join implementation using ES6, destructuring and recursion</figcaption></figure><blockquote class="mu mv mw"><p id="2192" class="ir is mm it b iu iv iw ix iy iz ja jb mx jd je jf my jh ji jj mz jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is mm it b iu iv iw ix iy iz ja jb mx jd je jf my jh ji jj mz jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is mm it b iu iv iw ix iy iz ja jb mx jd je jf my jh ji jj mz jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kt ku kv kw fq mn"><div class="bz el l di"><div class="na mp l"/></div></figure></div></div>    
</body>
</html>