<html>
<head>
<title>Reselect’s Memoization in 3 Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在3个函数中重新选择记忆</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/reselect-style-memoization-in-3-functions-aff30f8cba11?source=collection_archive---------18-----------------------#2017-12-27">https://medium.com/hackernoon/reselect-style-memoization-in-3-functions-aff30f8cba11?source=collection_archive---------18-----------------------#2017-12-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="406e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我一直在通读Reselect的<a class="ae jp" href="https://github.com/reactjs/reselect/blob/master/src/index.js" rel="noopener ugc nofollow" target="_blank">源代码</a>(只有107行未被统一)，认为在一篇博客文章中解开一些概念可能是值得的。</p><h2 id="b1cd" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">概念1:记忆化</h2><blockquote class="kl km kn"><p id="e792" class="ir is ko it b iu iv iw ix iy iz ja jb kp jd je jf kq jh ji jj kr jl jm jn jo hn dt translated">在计算中，记忆化是一种优化技术，主要用于通过存储昂贵的函数调用的结果并在相同的输入再次出现时返回缓存的结果来加速计算机程序。(<a class="ae jp" href="https://en.wikipedia.org/wiki/Memoization" rel="noopener ugc nofollow" target="_blank">来源</a>)</p></blockquote><p id="21ff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">换句话说，如果你有一个运行时占用资源的纯函数<code class="eh ks kt ku kv b">doResourceHoggingThing</code>(例如<code class="eh ks kt ku kv b">doResourceHoggingThing(argument)</code>)，记忆化是一个捷径，这样如果你一遍又一遍地运行它而不改变<code class="eh ks kt ku kv b">argument</code>，那么这个函数只在第一次运行。之后，它只保留结果的一个副本，并在提供相同的<code class="eh ks kt ku kv b">argument</code>时将其吐出，这样您就不必浪费资源一遍又一遍地计算相同的值。</p><p id="7cbc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于Reselect在React渲染周期内运行，所以它主要关心的不是保存<em class="ko">之前函数执行的所有结果</em>，而是只保存<em class="ko">最后的结果</em>，这样，如果它要输出一致的值，就可以跳过(可能很昂贵的)更新周期。</p><p id="c64e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Javascript中使用闭包很容易实现简单的记忆化(存储带有单个参数的函数的最后结果)。</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="6879" class="jq jr hu kv b fv le lf l lg lh">const memoizeFunc = func =&gt; {<br/>  // these variables inside the closure keep track of<br/>  // the previous data to do the comparison<br/>  let lastArg = null;<br/>  let lastResult = null;</span><span id="7f4b" class="jq jr hu kv b fv li lf l lg lh">  return function (newArg) {<br/>    // if the arguments don't match<br/>    // calculate the result and return it<br/>    if (newArg !== lastArg) {<br/>      console.log('new', lastResult)<br/>      lastResult = func(newArg)<br/>    }</span><span id="6e88" class="jq jr hu kv b fv li lf l lg lh">    // otherwise just return the old result<br/>    lastArg = newArg;<br/>    console.log('cached', lastResult)<br/>    return lastResult;<br/>  }<br/>}</span><span id="8ed9" class="jq jr hu kv b fv li lf l lg lh">const identity = x =&gt; x;<br/>const memedFunc = memoizeFunc(identity);</span><span id="b1c7" class="jq jr hu kv b fv li lf l lg lh">memedFunc(4) // 'new', 4<br/>memedFunc(5) // 'new', 5<br/>memedFunc(5) // 'cached', 4</span></pre><p id="1abb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，对任意数量的参数进行记忆要稍微复杂一些。</p><h2 id="132d" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">复习1:通过引用进行相等检查</h2><p id="bbb6" class="pw-post-body-paragraph ir is hu it b iu lj iw ix iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo hn dt translated">一个记忆化的函数需要做的主要决定是“自从上次我被调用以来，我的参数改变了吗？”，所以Reselect中的第一个函数是一个简单的相等检查，用于确定传递给函数的参数是否相等:</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="02c2" class="jq jr hu kv b fv le lf l lg lh">// Reselect Function #1<br/>function defaultEqualityCheck(a, b) {<br/>  return a === b<br/>}</span></pre><p id="a71e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里值得理解的是，这是通过<em class="ko">引用</em>而不是通过值来比较两个值的。由于内存化的函数经常将Javascript对象(任何非原始数据类型，如T4或T5)作为参数，并且由于相等性检查对象本身可能是资源密集型的，所以Reselect跳过对象值的深度比较，并使用它们的底层引用作为相等性的代理。</p><p id="415a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种快捷方式是安全的，因为虽然对于两个值相等但引用不同的对象，让这个检查返回<code class="eh ks kt ku kv b">false</code>相对容易，但我想不出两个对象可以共享一个引用而值不同的场景。</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="1630" class="jq jr hu kv b fv le lf l lg lh">const opt0 = {value: 0};<br/>const opt1 = {value: 1};<br/>const opt2 = {value: 1};<br/>const opt3 = opt1;</span><span id="d124" class="jq jr hu kv b fv li lf l lg lh">const arr = [<br/>  opt0, opt1, opt2, opt3<br/>]</span><span id="38a6" class="jq jr hu kv b fv li lf l lg lh">// Both values and reference match<br/>defaultEqualityCheck(arr[0], arr[0]) // true</span><span id="db37" class="jq jr hu kv b fv li lf l lg lh">// Neither value nor reference matches<br/>defaultEqualityCheck(arr[0], arr[1]) // false</span><span id="ac71" class="jq jr hu kv b fv li lf l lg lh">// value matches, but reference doesn't<br/>defaultEqualityCheck(arr[1], arr[2]) // false</span><span id="6ebb" class="jq jr hu kv b fv li lf l lg lh">// reference matches<br/>defaultEqualityCheck(arr[1], arr[3]) // true</span></pre><p id="bf5e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是React应用程序中容易出错的地方，因为这种边缘情况(如果发生的话)会导致冗余的渲染周期，而不是在底层数据更改时导致更新失败。</p><h2 id="c238" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">复习2:参数对象</h2><p id="e959" class="pw-post-body-paragraph ir is hu it b iu lj iw ix iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo hn dt translated"><code class="eh ks kt ku kv b">arguments</code>对象是所有(非箭头)函数中可用的局部变量。你可以通过使用<code class="eh ks kt ku kv b">arguments</code>对象在函数中引用函数的参数。该对象为传递给函数的每个参数包含一个条目，第一个条目的索引从0开始。(<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments" rel="noopener ugc nofollow" target="_blank">来源</a>)</p><p id="f17e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们可以直接在<code class="eh ks kt ku kv b">arguments</code>的两个实例上运行等式检查就好了，但是它们永远不会共享相同的底层引用，所以这是行不通的。我们必须更深入地挖掘，这将我们带到下一个重新选择函数。</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="5ae8" class="jq jr hu kv b fv le lf l lg lh">// Reselect Function #2<br/>function areArgumentsShallowlyEqual(equalityCheck, prev, next) {<br/>  if (<br/>    prev === null || <br/>    next === null || <br/>    prev.length !== next.length<br/>  ) {<br/>    return false<br/>  }<br/><br/>  // Do this in a for loop (and not a `forEach` or an `every`)<br/>  // so we can determine equality as fast as possible.<br/>  const length = prev.length<br/>  for (let i = 0; i &lt; length; i++) {<br/>    if (!equalityCheck(prev[i], next[i])) {<br/>      return false<br/>    }<br/>  }<br/><br/>  return true<br/>}</span></pre><p id="db99" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这只是迭代两个<code class="eh ks kt ku kv b">arguments</code>对象中的属性，并使用传入的相等检查对它们进行简单的比较。由于<code class="eh ks kt ku kv b">arguments</code>对象是一个类似数组的对象，它有一个内置属性<code class="eh ks kt ku kv b">length</code>，允许在循环之前进行一些快速测试来加速。</p><h2 id="99f6" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">概念3:记忆功能</h2><p id="6f85" class="pw-post-body-paragraph ir is hu it b iu lj iw ix iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo hn dt translated">既然已经理解了所有的构建模块，那么在重选中使用的默认记忆功能就是它们的组合。</p><pre class="kw kx ky kz fq la kv lb lc aw ld dt"><span id="185e" class="jq jr hu kv b fv le lf l lg lh">// Reselect Function #3<br/>export function defaultMemoize(func, equalityCheck = defaultEqualityCheck) {<br/>  let lastArgs = null<br/>  let lastResult = null<br/>  // we reference arguments instead of spreading them for performance reasons<br/>  return function () {<br/>    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {<br/>      // apply arguments instead of spreading for performance.<br/>      lastResult = func.apply(null, arguments)<br/>    }<br/><br/>    lastArgs = arguments<br/>    return lastResult<br/>  }<br/>}</span></pre><p id="7ff0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我不是100%确定通过使用<code class="eh ks kt ku kv b">func.apply</code>增加的增强的粒度细节，但它看起来像是引擎盖下的巴别塔transpiles <code class="eh ks kt ku kv b">func(...arguments)</code>。</p><figure class="kw kx ky kz fq lp fe ff paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="fe ff lo"><img src="../Images/f5d02034baf80916ac35ca27dc9d8381.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dHF9dbA2M-7GLeTiHtACTg.png"/></div></div></figure><h1 id="f801" class="lw jr hu bd js lx ly lz jw ma mb mc ka md me mf kd mg mh mi kg mj mk ml kj mm dt translated">结论</h1><p id="6a61" class="pw-post-body-paragraph ir is hu it b iu lj iw ix iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo hn dt translated">就是这样。三个函数中的重选基础。源代码中还有更多的内容，所以我可能会在不久的将来添加第2部分。</p></div></div>    
</body>
</html>