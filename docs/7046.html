<html>
<head>
<title>Multi-tenant Application with Laravel and Postgres</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有Laravel和Postgres的多租户应用程序</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/multi-tenant-application-with-laravel-and-postgres-abbb137bdbc8?source=collection_archive---------8-----------------------#2017-10-15">https://medium.com/hackernoon/multi-tenant-application-with-laravel-and-postgres-abbb137bdbc8?source=collection_archive---------8-----------------------#2017-10-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/4d3079c8a7650e3b7c97b7ee50bdc94d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FuG2iHJj41EDdIs5kDWOUQ.jpeg"/></div></div></figure><p id="5cf5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">比方说，我们有一个web应用程序，由<a class="ae ka" href="https://hackernoon.com/tagged/laravel" rel="noopener ugc nofollow" target="_blank"> Laravel </a>和<a class="ae ka" href="https://hackernoon.com/tagged/postgres" rel="noopener ugc nofollow" target="_blank"> Postgres </a>提供支持，在东南亚的不同国家运行。每个企业都有自己的用户、产品、类别等。因此，为了使它更易于管理，我们希望每个企业都有一个单独的数据库。但是由于我们使用Postgres，我们可以利用模式，我将很快描述。</p><blockquote class="kb kc kd"><p id="7cba" class="jc jd ke je b jf jg jh ji jj jk jl jm kf jo jp jq kg js jt ju kh jw jx jy jz hn dt translated">我使用Laravel 5.5和PostgreSQL 9.5进行设置。你会发现我会交替使用<code class="eh ki kj kk kl b">Tenant</code>或<code class="eh ki kj kk kl b">Venture</code>来代表这个国家。</p></blockquote><h1 id="ca47" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">首要任务—租户识别</h1><p id="570c" class="pw-post-body-paragraph jc jd hu je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">在我们的多租户web应用程序中，我们要做的第一件事是识别发出请求的企业/租户。</p><p id="e2e3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<code class="eh ki kj kk kl b">config</code>文件夹中创建一个名为<code class="eh ki kj kk kl b">ventures.php</code>的文件，并为你的冒险添加一个映射。左边是域名，右边是各个域的模式。</p><figure class="lp lq lr ls fq iv"><div class="bz el l di"><div class="lt lu l"/></div></figure><p id="dc4c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，在<code class="eh ki kj kk kl b">app/Library</code>文件夹中创建一个名为<code class="eh ki kj kk kl b">Venture.php</code>的文件(或者你可以使用任何你喜欢的文件夹；根据需要调整名称空间)。这个类将有一个所有可用的venture和helper方法的列表，用于从请求URL &amp;解析venture以加载venture配置。</p><figure class="lp lq lr ls fq iv"><div class="bz el l di"><div class="lt lu l"/></div></figure><p id="7214" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面这段代码中的方法从请求URL中解析风险。该方法的第一行获取没有协议的请求URL(<a class="ae ka" href="http://example.com/" rel="noopener ugc nofollow" target="_blank">example.com</a>而不是<a class="ae ka" href="http://example.com/" rel="noopener ugc nofollow" target="_blank">https://example.com</a>)。然后我们得到所有我们之前添加的有效的风险投资领域来进行比较。最后，如果数据库模式可用，我们返回它，否则，我们默认切换到<code class="eh ki kj kk kl b">public</code>(或者在<code class="eh ki kj kk kl b">.env</code>中定义的任何其他值)。</p><p id="5473" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">方法加载或替换特定于venture的配置。我们将把所有特定于venture的配置放在根级别的一个名为<code class="eh ki kj kk kl b">venture_configs</code>的文件夹中。<em class="ke"> loadVentureConfigs </em>方法将检查配置文件是否可用于给定的风险，并加载它。我们使用第二个参数<code class="eh ki kj kk kl b">Repository $config</code>，因为我们不想覆盖全局配置库对象。如果提供了第二个参数，我们将设置各自的配置对象，而不是全局对象。这将帮助我们<em class="ke">获得</em>和<em class="ke">设置</em>风险特定配置。</p><blockquote class="kb kc kd"><p id="3b70" class="jc jd ke je b jf jg jh ji jj jk jl jm kf jo jp jq kg js jt ju kh jw jx jy jz hn dt translated">按照我们的设计，全球配置存储库将始终保存来自当前企业的配置。</p></blockquote><figure class="lp lq lr ls fq iv fe ff paragraph-image"><div class="fe ff lv"><img src="../Images/db7c31778c38b03a94d66da02344abb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*hSJbk77awvLlG8ybMbJ8iA.png"/></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">Venture specific configurations</figcaption></figure><p id="3c88" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这些文件中，我们将使用Laravel提供的点符号来覆盖配置值。您的venture特定配置文件中的条目如下所示:</p><figure class="lp lq lr ls fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ma"><img src="../Images/80fcbf849ad7b98551a366e506ab4cdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SVyocbHU96SqIS_f286Ecw.png"/></div></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">venture_configs/ph.php</figcaption></figure><blockquote class="kb kc kd"><p id="076e" class="jc jd ke je b jf jg jh ji jj jk jl jm kf jo jp jq kg js jt ju kh jw jx jy jz hn dt translated">注意:您也可以使用venture name作为前缀来分隔同一个文件中的配置。我更喜欢把它分开。</p></blockquote><h1 id="5f75" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">配置加载程序</h1><p id="5437" class="pw-post-body-paragraph jc jd hu je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">接下来我们需要的是配置加载器。当Laravel第一次加载配置时，我们需要告诉它加载当前风险的配置。我们可以通过覆盖负责加载配置文件的<code class="eh ki kj kk kl b">Illuminate\Foundation\Bootstrap\LoadConfiguration</code>类来做到这一点。</p><p id="dda1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<code class="eh ki kj kk kl b">app/Bootstrap</code>目录下创建一个名为<code class="eh ki kj kk kl b">ConfigLoader.php</code>的文件，并添加以下代码。</p><figure class="lp lq lr ls fq iv"><div class="bz el l di"><div class="lt lu l"/></div></figure><p id="0aa8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里我们扩展了<code class="eh ki kj kk kl b">Illuminate\Foundation\Bootstrap\LoadConfiguration</code>类来覆盖<code class="eh ki kj kk kl b">loadConfigurationFiles</code>方法。注意第19行，它通过调用我们之前添加的<code class="eh ki kj kk kl b">loadVentureConfigs</code>方法来加载特定于venture的配置。</p><p id="b83a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">困惑<code class="eh ki kj kk kl b">$app['venture']</code>在这里是怎么工作的？嗯，我只是在<code class="eh ki kj kk kl b">bootstrap/app.php</code>中添加了一个别名，使其可读性更好。</p><pre class="lp lq lr ls fq mb kl mc md aw me dt"><span id="ab86" class="mf kn hu kl b fv mg mh l mi mj">$app<strong class="kl hv">-&gt;</strong>alias(\App\Library\Venture<strong class="kl hv">::class</strong>, 'venture');</span></pre><p id="1f6e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后剩下的事情是告诉Laravel使用我们的<em class="ke"> ConfigLoader </em>类，而不是<em class="ke">Illuminate \ Foundation \ Bootstrap \ load configuration</em>。我们可以通过使用<em class="ke"> ServiceProvider </em>来做到这一点。不，不是真的！如果您深入研究Laravel的代码，您会注意到配置是在服务提供者之前加载的。</p><figure class="lp lq lr ls fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mk"><img src="../Images/73c5fa4d467eefe2a1e37fac8a5890f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mk5Fqpd2I71wGWYRy7mmYg.png"/></div></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">Illuminate\Foundation\Http\Kernel.php</figcaption></figure><p id="0a2c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，为了覆盖<em class="ke"> LoadConfiguration </em>类，我们需要使用应用引导程序(<code class="eh ki kj kk kl b">bootstrap/app.php</code>)，它在应用引导过程的最开始就被加载。</p><figure class="lp lq lr ls fq iv"><div class="bz el l di"><div class="lt lu l"/></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">bootstrap/app.php</figcaption></figure><p id="ef8c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上述语句出现在<code class="eh ki kj kk kl b">bootstrap/app.php</code>文件中的<code class="eh ki kj kk kl b">return $app;</code>语句之前。</p><h1 id="f207" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">数据库隔离</h1><p id="de7c" class="pw-post-body-paragraph jc jd hu je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">由于我们现在可以识别租户和特定租户的负载配置，剩下的唯一事情就是数据库隔离。对于多租户应用程序，有不同的方法来隔离数据。我们可以为每个租户使用不同的数据库，或者在每个表中使用键值对来表示租户，或者使用不同的模式。每种方法都有自己的优点和缺点，我不会在本教程中详细介绍。</p><p id="18f8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为我们使用Postgres，所以我们可以利用Postgres模式。模式就像文件夹一样，可以保存表、视图、函数、序列和其他关系。通过利用模式，我们将在保持性能和数据安全性的同时限制成本和复杂性。因此，我们可以为所有运行该应用程序的企业创建一个数据库和不同的模式，而不是创建多个数据库。</p><p id="b46f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">创建<code class="eh ki kj kk kl b">VentureServiceProvider</code>并在<code class="eh ki kj kk kl b">config/app.php</code>中注册。</p><figure class="lp lq lr ls fq iv"><div class="bz el l di"><div class="lt lu l"/></div></figure><p id="2b0e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<code class="eh ki kj kk kl b">register</code>方法中，我们将识别风险并根据需要创建数据库实例。在第一行(第18行),我们扩展了数据库对象以使用我们提供的自定义数据库对象。第二行将<code class="eh ki kj kk kl b">pgsql</code>模式配置更改为我们基于URL解决的风险。最后，我们创建并返回一个新的<em class="ke"> DatabaseManager </em>对象，它指向当前风险的模式。</p><blockquote class="kb kc kd"><p id="4108" class="jc jd ke je b jf jg jh ji jj jk jl jm kf jo jp jq kg js jt ju kh jw jx jy jz hn dt translated">db <em class="hu">别名指向</em> <code class="eh ki kj kk kl b"><em class="hu">Illuminate\Database\DatabaseManager</em></code> <em class="hu">对象。所以覆盖</em> db <em class="hu">也将覆盖</em> DatabaseManager <em class="hu">。</em></p></blockquote><p id="ebeb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此时，当您使用带有<code class="eh ki kj kk kl b">app('db')</code>或<code class="eh ki kj kk kl b">DB::</code>facade的数据库对象或Laravel提供的任何其他方法时，您将始终获得当前租户或企业的连接。</p><h1 id="0346" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">风险特定数据库和配置</h1><p id="82d7" class="pw-post-body-paragraph jc jd hu je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">那么，我们如何访问特定于风险的数据库模式呢？比方说，当我们连接到<code class="eh ki kj kk kl b">vn</code>模式时，我们需要在<code class="eh ki kj kk kl b">th</code>模式中执行一些操作？或者我们需要使用命令行运行一些作业？</p><p id="44fb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<code class="eh ki kj kk kl b">VentureServiceProvider</code>中，我们可以为所有模式创建一个数据库对象，并将其推入一个服务容器。我们也可以对配置进行同样的操作。</p><figure class="lp lq lr ls fq iv"><div class="bz el l di"><div class="lt lu l"/></div></figure><p id="9f40" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可能会认为，在上面的实现中，我们应该在切换第9行之后的数据库时也更改venture的配置，而不是将其设置在一个新的键中。举个例子，</p><figure class="lp lq lr ls fq iv"><div class="bz el l di"><div class="lt lu l"/></div></figure><p id="e7e4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，当我们做<code class="eh ki kj kk kl b">app('db.th')</code>时，它也将切换到各自企业的配置。但是不，我们不能这样做，因为它会改变你的应用程序的状态，甚至没有意识到这会导致错误。此外，每次我们在另一个合资企业上做一些数据库操作时，我们都需要重置合资企业的配置。</p><blockquote class="kb kc kd"><p id="3a34" class="jc jd ke je b jf jg jh ji jj jk jl jm kf jo jp jq kg js jt ju kh jw jx jy jz hn dt translated">在任何给定的执行点，应用程序的状态应该是可预测的。</p></blockquote><p id="e1e1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">继续我们的第一个实现，我们可以获得全局或风险特定的数据库和/或配置，如下面的代码片段所述。</p><figure class="lp lq lr ls fq iv"><div class="bz el l di"><div class="lt lu l"/></div></figure><p id="6087" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，在这一点上，我们只能使用Laravel提供的<code class="eh ki kj kk kl b">config()</code>助手或<code class="eh ki kj kk kl b">app('config')</code>来获取当前企业的配置。</p><p id="576b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这使我们的应用程序处于更可预测的状态。</p></div><div class="ab cl ml mm hc mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hn ho hp hq hr"><h1 id="a8a4" class="km kn hu bd ko kp ms kr ks kt mt kv kw kx mu kz la lb mv ld le lf mw lh li lj dt translated">测试我们的多租户应用</h1><p id="20c8" class="pw-post-body-paragraph jc jd hu je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">我有一个数据库与所有6家企业的模式。我创建了一个名为<code class="eh ki kj kk kl b">search_path</code>的表，表中有一列<code class="eh ki kj kk kl b">path</code>用于所有的风险投资。路径列将具有代表国家的风险值。例如，<code class="eh ki kj kk kl b">th</code>模式将在<code class="eh ki kj kk kl b">path</code>列中有值<code class="eh ki kj kk kl b">Thailand</code>。</p><figure class="lp lq lr ls fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mx"><img src="../Images/cb414f020afae9ae5498bd1b6c521375.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N-mFl_m2xqqiA4NpgBMMAg.png"/></div></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">routes/web.php</figcaption></figure><p id="2b22" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里，我们使用Laravel的默认<code class="eh ki kj kk kl b">welcome.blade.php</code>文件作为视图。唯一改变的是，我们已经为我们在路线中获得的风险增加了价值。并增加了各自企业的时区配置。</p><figure class="lp lq lr ls fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff my"><img src="../Images/440088e44aa671711f20deef84069c18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DWcmsedD5KwE7JSxVHDY1A.png"/></div></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">welcome.blade.php</figcaption></figure><p id="e778" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们打开<code class="eh ki kj kk kl b">mt.local.th</code>，这是我们为<em class="ke">泰国</em>投资的本地域名。我们应该从数据库中获得正确的风险名称，并从配置中获得正确的时区。</p><figure class="lp lq lr ls fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mz"><img src="../Images/164925794ee3f1e7f7f4ec0882bdc5fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PPbbrmFeSkFFhzM1Il7QKA.png"/></div></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">mt.local.th</figcaption></figure><p id="9178" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，让我们尝试使用另一个域<code class="eh ki kj kk kl b">mt.local.ph</code>，它是<em class="ke">菲律宾</em>的本地域。注意风险企业的名称和时区。</p><figure class="lp lq lr ls fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mz"><img src="../Images/3d1f9d2a739b5e8cf487527fdb607371.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sAqQdj8zaZXvg1QFlaJyqA.png"/></div></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">mt.local.ph</figcaption></figure><p id="49f2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就是这样！您已经使用Laravel和PostgreSQL成功创建了一个多租户应用程序。它可能还没有做很多事情，但是它为您的多租户应用程序创建了一个强大的基础。编码快乐！</p><blockquote class="kb kc kd"><p id="fefb" class="jc jd ke je b jf jg jh ji jj jk jl jm kf jo jp jq kg js jt ju kh jw jx jy jz hn dt translated">在<a class="ae ka" rel="noopener" href="/@ankitpokhrel/extending-laravels-migration-command-to-add-new-options-90b5a0fc4ef4">下一部分</a>中，我们将看到如何扩展Laravel的迁移实现，以优雅地处理我们的多租户应用程序的所有模式的迁移。</p></blockquote><figure class="lp lq lr ls fq iv"><div class="bz el l di"><div class="na lu l"/></div></figure></div></div>    
</body>
</html>