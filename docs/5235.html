<html>
<head>
<title>Alternatives to Server Side Rendered (SSR) React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">服务器端渲染(SSR)的替代方法React</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/leaner-alternatives-to-server-side-rendered-ssr-react-c5492a6cb212?source=collection_archive---------13-----------------------#2017-07-17">https://medium.com/hackernoon/leaner-alternatives-to-server-side-rendered-ssr-react-c5492a6cb212?source=collection_archive---------13-----------------------#2017-07-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="a1bf" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated"><strong class="ak">更新:</strong></h1><p id="df44" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我从<a class="ae kn" href="https://hackernoon.com/tagged/google" rel="noopener ugc nofollow" target="_blank">谷歌</a>找到了这个<a class="ae kn" href="https://hackernoon.com/tagged/tool" rel="noopener ugc nofollow" target="_blank">工具</a>来帮助我们进行搜索引擎优化测试:</p><p id="a1f8" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated"><a class="ae kn" href="https://support.google.com/webmasters/answer/6066468?visit_id=1-636360191230083689-3793429009&amp;rd=2" rel="noopener ugc nofollow" target="_blank">https://support.google.com/webmasters/answer/6066468?visit _ id = 1-636360191230083689-3793429009&amp;rd = 2</a></p><p id="ea58" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated"><em class="kt">“抓取为谷歌工具使您能够测试谷歌如何抓取或呈现您的网站上的网址。您可以使用Fetch as Google来查看Googlebot是否可以访问您网站上的页面，它如何呈现页面，以及是否有任何页面资源(如图像或脚本)被Googlebot阻止(通过robots.txt)。此工具</em> <a class="ae kn" href="http://www.google.com/insidesearch/howsearchworks/crawling-indexing.html" rel="noopener ugc nofollow" target="_blank"> <em class="kt">模拟爬网</em> </a> <em class="kt">并在Google的正常爬网和呈现过程中呈现执行，对于调试您网站上的爬网问题非常有用。</em></p><p id="9e6b" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">我在这里建议的流程是<strong class="jr hv">在</strong>进入解决方案模式之前，我们必须首先了解谷歌如何抓取客户端渲染的SPA(没有同构或服务器端模板，只是一个纯客户端应用程序)，如果谷歌无法抓取它(谷歌自2009年以来一直投资于他们抓取SPA的能力，到2014年，他们宣布他们能够抓取几乎任何SPA)，那么我们将使用Headless Chrome方法。</p><h1 id="0934" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated"><strong class="ak">更新帖子:</strong></h1><p id="ea1b" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">首先，我想澄清一下，这篇文章并不是关于静态(构建时)服务器端渲染(SSR)的，在SSR中，服务器是一个独占的资源，正如像<a class="ae kn" href="https://github.com/gatsbyjs/gatsby" rel="noopener ugc nofollow" target="_blank"> Gatsby这样的框架所提倡的那样。JS </a>。它是关于动态(运行时)SSR的，其中“服务器”是一种共享资源，就像像<a class="ae kn" href="https://github.com/zeit/next.js/" rel="noopener ugc nofollow" target="_blank"> Next这样的框架所提倡的那样。JS </a>(但不包括接下来的<a class="ae kn" href="https://leo.im/2017/electron-next" rel="noopener ugc nofollow" target="_blank">的组合。JS和electronic</a>服务器再次成为独占资源。)</p><p id="ee50" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">让我们从我的简单用例开始。我有一个反应应用程序，我希望暴露给搜索机器人(搜索引擎优化)，并加快它的初始渲染。我不相信使用SSR，因为它否定了我们通过单页面应用程序(SPAs)获得的可伸缩性，在单页面应用程序中，我们在客户端上完成渲染页面的所有CPU受限工作，而不是在共享服务器上完成，在共享服务器上，最常见的场景涉及作为服务器的NodeJS，这是一个单线程、协作的多任务环境，专为I/O受限工作而设计。</p><p id="29a2" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">我考虑过的一个选择如下:</p><p id="84c7" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">在接收到对给定URL的请求时，服务器将index.html文件加载到字符串中，并注入到初始请求路由的数据中(必须在URL参数中设置(由用户和SPA ),因为浏览器不会转发散列片段，并且包括任何查询参数),如下所示:</p><ol class=""><li id="8193" class="ku kv hu jr b js ko jw kp ka kw ke kx ki ky km kz la lb lc dt translated">所有JSON数据和文本都作为JS var声明注入到脚本标签中，例如<script>窗口。__preloadedData = {…} </script>，它可以被位于服务器修改的index.html底部的index.js脚本(SPA)访问。</li><li id="483f" class="ku kv hu jr b js ld jw le ka lf ke lg ki lh km kz la lb lc dt translated">相应的HTML元标签被注入头部。</li></ol><p id="9f63" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">通过这种方式，当浏览器加载SPA时，初始路径将已经具有它需要的数据，并且将在客户端上开始渲染，而不必等待数据，因此初始渲染将感觉很快，因为浏览器不会打开空白页，然后等待再渲染。相反，它会打开一个空白页，然后立刻呈现所有内容，所以用户甚至看不到以零零碎碎的方式组合起来的空白页。在最初请求的路由被提供后，SPA接管并可以确保后续路由仅在它们的数据依赖项被获取后才被呈现，从而达到相同的效果。</p><p id="2682" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">至于我们将如何在服务器上预取数据，我们将使用GraphQL作为数据层，这允许我们使用相同的GraphQL模式和解析器来执行每个路由的单个查询，而不必仅为了数据预加载而为每个路由构建命令性reducer逻辑。</p><p id="b99f" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">说到SEO(见本文顶部的更新),我见过的最好的方法是Google Chrome团队的Sam Li。山姆的<a class="ae kn" rel="noopener" href="/dev-channel/solving-seo-with-headless-chrome-for-your-client-side-framework-288e66fdd2b7">方法</a>是检测用户代理，如果它是一个机器人，然后将请求排队到一个无头Chrome实例池，它将像任何用户浏览器一样加载SPA，运行它并返回HTML。优点是我的React应用程序设置仍然非常简单，没有任何SSR包袱。</p><p id="2f1b" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">加速初始渲染的另一种方法:</p><p id="80bd" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">至于反作用应用程序膨胀问题，即开发人员堆积NPM模块的负载，并且不使用死代码消除或树抖动(学习两者之间的<a class="ae kn" rel="noopener" href="/@Rich_Harris/tree-shaking-versus-dead-code-elimination-d3765df85c80">差异</a>)，一个解决方案，正如服务工作器和代码拆分中的<a class="ae kn" href="https://twitter.com/kylemathews" rel="noopener ugc nofollow" target="_blank">Kayle Mathews</a>创建者所建议的，是使用缓存功能(因为在本文写作时，我们还没有完全工作的<a class="ae kn" href="https://bugs.chromium.org/p/v8/issues/detail?id=5785" rel="noopener ugc nofollow" target="_blank">动态导入</a>)来缓存我们的代码所依赖的所有供应商模块，并单独加载它们，这样我们就不会下载兆字节的依赖项</p><p id="3d2d" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated"><strong class="jr hv">加速初始页面渲染的另一种方式</strong>(在专家系统提议阶段，所以它可能会实现，也可能不会实现)是这个关于JS无线格式的提议，作为抽象语法树的二进制编码:</p><div class="li lj fm fo lk ll"><a href="https://github.com/syg/ecmascript-binary-ast/" rel="noopener  ugc nofollow" target="_blank"><div class="lm ab ej"><div class="ln ab lo cl cj lp"><h2 class="bd hv fv z el lq eo ep lr er et ht dt translated">tc39/建议书-二进制-ast</h2><div class="ls l"><h3 class="bd b fv z el lq eo ep lr er et ek translated">ECMAScript的二进制AST提案。通过在…上创建帐户，为tc39/建议书-二进制-ast开发做出贡献</h3></div><div class="lt l"><p class="bd b gc z el lq eo ep lr er et ek translated">github.com</p></div></div><div class="lu l"><div class="lv l lw lx ly lu lz ma ll"/></div></div></a></div><figure class="mb mc md me fq mf"><div class="bz el l di"><div class="mg mh l"/></div></figure></div></div>    
</body>
</html>