<html>
<head>
<title>MongoDB for node.js developers jumpstart</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MongoDB for node.js开发者jumpstart</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/mongodb-for-node-js-developers-jumpstart-a1520182850e?source=collection_archive---------4-----------------------#2016-09-09">https://medium.com/hackernoon/mongodb-for-node-js-developers-jumpstart-a1520182850e?source=collection_archive---------4-----------------------#2016-09-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/6dc2810541bc26fc5a523bfa7f23067a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-V4gmtagsFnWA-tYomhuRQ.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">credit:<a class="ae jg" rel="noopener" href="/@joelrodrigues/how-to-access-mongodb-from-node-js-e37c587f226a">https://medium.com/@joelrodrigues/how-to-access-mongodb-from-node-js-e37c587f226a</a></figcaption></figure><p id="3a84" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">什么是MongoDB？</strong></p><p id="226b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><a class="ae jg" href="https://hackernoon.com/tagged/mongodb" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>是一个保存JSON格式数据的文档<a class="ae jg" href="https://hackernoon.com/tagged/database" rel="noopener ugc nofollow" target="_blank">数据库</a>。因为它不是基于连接，所以通过它的分片特性可以很容易地在服务器之间分发数据。</p><p id="9574" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">开发人员可以开发与部署无关的应用程序。MongoDB支持横向扩展，而RDBMS支持纵向扩展。Mongo shell是使用C++ V8编写的，用于管理MongoDB。</p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div class="fe ff kf"><img src="../Images/005df23cc0a8974bea853ca484baacfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*N-LGjmRMciKh3DZl.jpg"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">credit: <a class="ae jg" href="http://coenraets.org/blog/2012/10/creating-a-rest-api-using-node-js-express-and-mongodb/" rel="noopener ugc nofollow" target="_blank">http://coenraets.org/blog/2012/10/creating-a-rest-api-using-node-js-express-and-mongodb/</a></figcaption></figure><h1 id="40fd" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">什么是node.js</h1><blockquote class="li lj lk"><p id="2fea" class="jh ji ll jj b jk jl jm jn jo jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd ke hn dt translated"><code class="eh lp lq lr ls b"><em class="hu">node.js</em></code> <em class="hu">基本上就是一个</em> <code class="eh lp lq lr ls b"><em class="hu">C++</em></code> <em class="hu">的程序，你用</em> <code class="eh lp lq lr ls b"><em class="hu">V8 javascript</em></code> <em class="hu">来控制。因此，你用</em> <code class="eh lp lq lr ls b"><em class="hu">node.js</em></code> <em class="hu">编写的任何应用程序都将在</em> <code class="eh lp lq lr ls b"><em class="hu">javascript</em></code> <em class="hu">中编写，它将控制这个</em> <code class="eh lp lq lr ls b"><em class="hu">C++</em></code> <em class="hu">应用程序(</em> <code class="eh lp lq lr ls b"><em class="hu">node.js</em></code> <em class="hu">)，你可以说他们请求了这个资源，而你的应用程序实际上在</em> <code class="eh lp lq lr ls b"><em class="hu">javascript</em></code> <em class="hu">中会说:好的，他们请求了这个资源，我不需要响应。现在做出相应的反应。</em></p></blockquote><p id="3e01" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh lp lq lr ls b">Node.js</code>使用驱动程序连接到<code class="eh lp lq lr ls b">MongoDB</code>。应避免安装<code class="eh lp lq lr ls b">32</code>位释放，因为它限制了使用默认存储引擎的数据的可寻址大小。</p><h1 id="032f" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">JSON是什么？</h1><p id="549c" class="pw-post-body-paragraph jh ji hu jj b jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka lx kc kd ke hn dt translated">对于外行人来说，<code class="eh lp lq lr ls b"><a class="ae jg" href="http://json.org/" rel="noopener ugc nofollow" target="_blank">JSON</a></code>只是一个字符串。<code class="eh lp lq lr ls b">JSON</code>对象由<em class="ll">键值</em>对组成。键必须是字符串，键和值必须用分号分隔。<code class="eh lp lq lr ls b">JSON</code>对象内的字段用逗号分隔。<code class="eh lp lq lr ls b">JSON</code>使用花括号打开和关闭对象:</p><pre class="kg kh ki kj fq ly ls lz ma aw mb dt"><span id="f1da" class="mc kl hu ls b fv md me l mf mg">{<br/>  "string" : "sting value goes here",<br/>  "date" : "2015-10-27T22:35:21.908Z",<br/>  "number" : 123,<br/>  "object" : {<br/>    "key1" : "value1",<br/>    "key2" : "value2"<br/>  },<br/>  "boolean" : true,<br/>  "array" : [ <br/>    "test", <br/>    { "key1" : "a", "key2" : "b" },<br/>    [ "abc", "xyz" ]<br/>  ]<br/>}</span></pre><p id="76ac" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">上面的例子显示了<code class="eh lp lq lr ls b">JSON</code>支持多种数据类型。<code class="eh lp lq lr ls b">object</code>字段显示了嵌套值的示例。正如我们所见，<code class="eh lp lq lr ls b">object</code>和<code class="eh lp lq lr ls b">array</code> - <code class="eh lp lq lr ls b">MongoDB</code>数据模型通常使用嵌套，甚至我们可以称之为<strong class="jj hv">深度嵌套</strong>。<code class="eh lp lq lr ls b">JSON</code>提供的灵活性使得实现不同的数据访问模式变得很简单，方法是创建包含呈现一个内容丰富的网页所需的所有数据的对象，或者为请求很少的用户提供另一种类型的数据视图。</p><h1 id="5701" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">什么是BSON？</h1><p id="39dc" class="pw-post-body-paragraph jh ji hu jj b jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka lx kc kd ke hn dt translated"><code class="eh lp lq lr ls b">MongoDB</code>将数据存储为<code class="eh lp lq lr ls b"><a class="ae jg" href="http://bsonspec.org/" rel="noopener ugc nofollow" target="_blank">BSON</a></code>(二进制<code class="eh lp lq lr ls b">JSON</code>)。下面是对比:</p><pre class="kg kh ki kj fq ly ls lz ma aw mb dt"><span id="733a" class="mc kl hu ls b fv md me l mf mg">// JSON<br/>{<br/> "hello": "world"<br/>}</span><span id="f348" class="mc kl hu ls b fv mh me l mf mg">// BSON<br/>"\x16\x00\x00\x00\x02hello\x00 \<br/>x06\ x00\ x00\ x00world\ x00\ x00 "</span></pre><p id="5884" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh lp lq lr ls b">MongoDB</code>驱动程序以<code class="eh lp lq lr ls b">BSON</code>格式发送和接收数据，当数据被写入<code class="eh lp lq lr ls b">MongoDB</code>时，它被存储在<code class="eh lp lq lr ls b">BSON</code>中。</p><p id="c17c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在应用程序端，驱动程序将<code class="eh lp lq lr ls b">BSON</code>映射到最合适的本地数据类型。它是</p><ul class=""><li id="dbbc" class="mi mj hu jj b jk jl jo jp js mk jw ml ka mm ke mn mo mp mq dt translated">轻量级选手</li><li id="c53f" class="mi mj hu jj b jk mr jo ms js mt jw mu ka mv ke mn mo mp mq dt translated">可移动，支持编写、读取和索引<code class="eh lp lq lr ls b">MongoDB</code>文档所需的各种操作</li><li id="39c4" class="mi mj hu jj b jk mr jo ms js mt jw mu ka mv ke mn mo mp mq dt translated">高效，这意味着可以非常快速地执行驱动程序所需的与BSON之间的数据编码/解码。</li></ul><p id="3c1e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh lp lq lr ls b">JSON</code>不区分<code class="eh lp lq lr ls b">integer</code>和<code class="eh lp lq lr ls b">float</code> s。不支持<code class="eh lp lq lr ls b">date</code>s。<code class="eh lp lq lr ls b">BSON</code>扩展JSON值类型以包括<code class="eh lp lq lr ls b">integer</code> s、<code class="eh lp lq lr ls b">double</code> s、<code class="eh lp lq lr ls b">date</code> s和二进制数据，以支持图像和许多其他类型的数据。</p><h1 id="7c0f" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">Windows安装</h1><p id="50e4" class="pw-post-body-paragraph jh ji hu jj b jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka lx kc kd ke hn dt translated">要直接从shell访问<code class="eh lp lq lr ls b">mongo</code>和<code class="eh lp lq lr ls b">mongod</code>，请更改MongoDB的路径:</p><ul class=""><li id="6f0b" class="mi mj hu jj b jk jl jo jp js mk jw ml ka mm ke mn mo mp mq dt translated">转到<code class="eh lp lq lr ls b">System Properties</code></li><li id="d742" class="mi mj hu jj b jk mr jo ms js mt jw mu ka mv ke mn mo mp mq dt translated">转到<code class="eh lp lq lr ls b">Advanced settings</code></li><li id="f5da" class="mi mj hu jj b jk mr jo ms js mt jw mu ka mv ke mn mo mp mq dt translated">点击<code class="eh lp lq lr ls b">Environment variables</code></li><li id="3625" class="mi mj hu jj b jk mr jo ms js mt jw mu ka mv ke mn mo mp mq dt translated">转到<code class="eh lp lq lr ls b">System variables</code></li><li id="7124" class="mi mj hu jj b jk mr jo ms js mt jw mu ka mv ke mn mo mp mq dt translated">转到<code class="eh lp lq lr ls b">Path</code>(这是Windows寻找可执行文件的地方)</li><li id="c23c" class="mi mj hu jj b jk mr jo ms js mt jw mu ka mv ke mn mo mp mq dt translated">添加<code class="eh lp lq lr ls b">MongoDB</code>的启动位置(例如:<code class="eh lp lq lr ls b">C:\Program Files\MongoDB\Server\3.2\bin</code>)</li></ul><p id="67af" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有时，你可能需要刷新系统来查看这些快捷键的工作情况</p><p id="f170" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是，在从终端使用<code class="eh lp lq lr ls b">mongodb</code>之前，按照以下命令为<code class="eh lp lq lr ls b">MongoDB</code>创建<code class="eh lp lq lr ls b">C:\data\db</code>目录，以便<strong class="jj hv">存储</strong>数据:</p><p id="4ba4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh lp lq lr ls b">md \data\db</code></p><p id="53aa" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">注意，<code class="eh lp lq lr ls b">data\db</code>前的<code class="eh lp lq lr ls b">\</code>——这确保了目录仅创建在根目录中(在本例中为<code class="eh lp lq lr ls b">C:\</code>)。</p><p id="60f1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，如果你输入<code class="eh lp lq lr ls b">mongod</code>并按回车键，它就会开始运行。如果你阅读终端上打印的日志，它说<code class="eh lp lq lr ls b">MongoDB</code>正在监听<code class="eh lp lq lr ls b">port=27017</code>和<code class="eh lp lq lr ls b">dbpath=C:\data\db</code>，即默认路径——这是我们最近创建的。</p><p id="dbbf" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，一旦<code class="eh lp lq lr ls b">mongod</code>开始运行，我们就可以启动<code class="eh lp lq lr ls b">mongo</code>来连接端口<code class="eh lp lq lr ls b">27017</code>。</p><h1 id="d196" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">做一些脏东西</h1><p id="2716" class="pw-post-body-paragraph jh ji hu jj b jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka lx kc kd ke hn dt translated">为了测试这个安装，我们将使用下面的代码做一个简单的文档<code class="eh lp lq lr ls b">insert</code>:</p><p id="f55b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">使用以下命令的<code class="eh lp lq lr ls b">db.names.insert({name:'testing'})</code>和<code class="eh lp lq lr ls b">find</code>(或相关术语中的<code class="eh lp lq lr ls b">select</code>):</p><p id="0701" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh lp lq lr ls b">db.names.find()</code></p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div class="fe ff mw"><img src="../Images/4640d9d927665dd1fc00fb62b503a8e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/0*JmOSIUYiHNIMFUf-."/></div></figure><p id="f14a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">其中<code class="eh lp lq lr ls b">{name:'testing'}</code>是文档的一个例子。此外，为了使<code class="eh lp lq lr ls b">.find()</code>的结果更具可读性，我们可以链接<code class="eh lp lq lr ls b">.pretty()</code>命令。</p><p id="ff91" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们也可以将<code class="eh lp lq lr ls b">MongoDB</code>作为<a class="ae jg" href="http://stackoverflow.com/a/2438758/2404470" rel="noopener ugc nofollow" target="_blank">服务</a>来运行。</p><p id="56b5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在<code class="eh lp lq lr ls b">MongoDB</code>中，文档存储在组织成数据库的集合中。要查看出现在<code class="eh lp lq lr ls b">MongoDB</code>中的数据库，运行<code class="eh lp lq lr ls b">show dbs</code></p><p id="d6b7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">要将文档插入到集合中，我们首先需要知道如何在命令中指定该集合。包含它的集合和数据库形成了一个名称空间<strong class="jj hv"/>。在做<code class="eh lp lq lr ls b">CRUD</code>操作时，我们引用全局变量<code class="eh lp lq lr ls b">db</code>。这个变量保存了对我们当前使用的数据库的引用。切换到数据库名称<strong class="jj hv">测试</strong>类型<a class="ae jg" href="http://stackoverflow.com/a/5287027" rel="noopener ugc nofollow" target="_blank"> MySQL类命令</a>T2。</p><p id="6368" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">插入操作也返回一个文档，其中<code class="eh lp lq lr ls b">acknowledged</code>设置为true表示记录(或者更好地说，文档)被成功插入。所有文件必须有一个<strong class="jj hv">下划线</strong> _id字段。集合中的每个文档都必须有唯一的文档id。<code class="eh lp lq lr ls b">MongoDB</code>的查询语言的核心是通过例子查询的策略。我们可以传递一个空白对象<code class="eh lp lq lr ls b">{}</code>，键值对<code class="eh lp lq lr ls b">{name: "Uber"}</code>。<code class="eh lp lq lr ls b">find()</code>命令的结果不仅仅是一个文档数组，而是一个<code class="eh lp lq lr ls b">cursor object</code>。我们可以看到这一点:</p><pre class="kg kh ki kj fq ly ls lz ma aw mb dt"><span id="12da" class="mc kl hu ls b fv md me l mf mg">var c = db.names.find();<br/>c.hasNext() //returns true, meaning there is a document yet to be visited by this cursor <br/>c.next() //grabs that document</span></pre><h1 id="5b84" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">使用节点构建</h1><p id="ad30" class="pw-post-body-paragraph jh ji hu jj b jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka lx kc kd ke hn dt translated">要使用<a class="ae jg" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> node.js </a>构建应用程序，我们首先需要<a class="ae jg" href="http://xameeramir.github.io/install-node/" rel="noopener ugc nofollow" target="_blank">安装它</a>。</p><p id="3d2b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们创建一个简单的<code class="eh lp lq lr ls b">http</code>服务器:</p><pre class="kg kh ki kj fq ly ls lz ma aw mb dt"><span id="f79a" class="mc kl hu ls b fv md me l mf mg">// Source: howtonode.org/hello-node</span><span id="00a8" class="mc kl hu ls b fv mh me l mf mg">// Load the http module to create an http server.<br/>var http = require('http');</span><span id="a64e" class="mc kl hu ls b fv mh me l mf mg">// Configure our HTTP server to respond with Hello World to all requests.<br/>var server = http.createServer(function (request, response) {<br/>  response.writeHead(200, {"Content-Type": "text/plain"});<br/>  response.end("Hello World\n");<br/>});</span><span id="eb1f" class="mc kl hu ls b fv mh me l mf mg">// Listen on port 8000, IP defaults to 127.0.0.1<br/>server.listen(8000);</span><span id="6e4d" class="mc kl hu ls b fv mh me l mf mg">// Put a friendly message on the terminal<br/>console.log("Server running at <a class="ae jg" href="http://127.0.0.1:8000/" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8000/</a>");</span></pre><p id="9f0e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">将上面的代码存储在一个<code class="eh lp lq lr ls b">.js</code>文件中，比如说<code class="eh lp lq lr ls b">app.js</code></p><blockquote class="li lj lk"><p id="bfcc" class="jh ji ll jj b jk jl jm jn jo jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd ke hn dt translated">我们如何开始呢？</p></blockquote><p id="f0ac" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在终端中，转到文件的位置并键入<code class="eh lp lq lr ls b">node app.js</code>。要验证它是否正在运行，请访问<a class="ae jg" href="http://localhost:8000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:8000 </a>。注意端口<code class="eh lp lq lr ls b">8000</code>，我们已经在上面的代码中指定了这个端口<strong class="jj hv">。</strong></p><h1 id="5910" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">什么是NPM</h1><pre class="kg kh ki kj fq ly ls lz ma aw mb dt"><span id="5a10" class="mc kl hu ls b fv md me l mf mg">var express = require('express'), cons = require('consolidate'), mongodb = require('mongodb');</span></pre><p id="bc62" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh lp lq lr ls b">require()</code>是我们如何在<code class="eh lp lq lr ls b">node.js</code>应用中添加外部库。如果我们通过<code class="eh lp lq lr ls b">node</code>终端运行这段代码，我们会得到下面的错误:</p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div class="fe ff mw"><img src="../Images/3784a79420e6b3ffc1eed4603f9a92e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/0*5eNmG3SA_47_ihdp."/></div></figure><p id="c7fe" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">要将这个缺失的<code class="eh lp lq lr ls b">express</code>东西作为<code class="eh lp lq lr ls b">node</code>包，我们可以使用<code class="eh lp lq lr ls b">node</code>命令行<code class="eh lp lq lr ls b">npm install express</code>。在真实的项目中，会有一堆包依赖。一个一个地安装它们将是一个巨大的痛苦。为了解决这个问题，出台了<code class="eh lp lq lr ls b">package.json</code>文件。此文件包含关于依赖关系的元数据:</p><pre class="kg kh ki kj fq ly ls lz ma aw mb dt"><span id="9ddd" class="mc kl hu ls b fv md me l mf mg">{<br/>  "name": "project name goes here",<br/>  "version": "0.1.2",<br/>  "description": "npm introduction",<br/>  "main": "app.js",<br/>  "dependencies": {<br/>        "consolidate": "~0.13.1",<br/>        "express": "~4.13.3",<br/>        "mongodb": "~2.1.3"<br/>  },<br/>  "author": "ABC",<br/>  "license": "MIT"<br/>}</span></pre><p id="3516" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在<strong class="jj hv">位置</strong>有了这个文件，简单地运行<code class="eh lp lq lr ls b">npm install</code>就会为我们获得<strong class="jj hv">项目的本地</strong> <code class="eh lp lq lr ls b">node_modules</code>目录下的所有包。还有一种全局安装包的方法。</p><h1 id="bfe3" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">什么是Node.js驱动程序</h1><p id="9d08" class="pw-post-body-paragraph jh ji hu jj b jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka lx kc kd ke hn dt translated">驱动程序使用有线协议与<code class="eh lp lq lr ls b">MongoDB</code>服务器通信。它处理诸如打开套接字、检测错误和管理到副本集的连接之类的事情。要在应用程序中包含驱动程序，使用代码<code class="eh lp lq lr ls b">var mongodb = require('mongodb');</code>并使用<code class="eh lp lq lr ls b">npm install mongodb</code>进行安装。正如我们所看到的，它只是一个节点包。尝试使用此包连接到<code class="eh lp lq lr ls b">MongoDB</code>:</p><pre class="kg kh ki kj fq ly ls lz ma aw mb dt"><span id="ac64" class="mc kl hu ls b fv md me l mf mg">var MongoClient = require('mongodb').MongoClient,<br/>    assert = require('assert');</span><span id="62a1" class="mc kl hu ls b fv mh me l mf mg">var url = 'mongodb://localhost:27017/startup';</span><span id="5441" class="mc kl hu ls b fv mh me l mf mg">MongoClient.connect(url, function(err, db) {</span><span id="5f52" class="mc kl hu ls b fv mh me l mf mg">assert.equal(null, err);<br/>    console.log("Successfully connected to server");</span><span id="22d8" class="mc kl hu ls b fv mh me l mf mg">// Find some documents in our collection<br/>    db.collection('startup').find({}).toArray(function(err, docs) {</span><span id="3b7f" class="mc kl hu ls b fv mh me l mf mg">// Print the documents returned<br/>        docs.forEach(function(doc) {<br/>            console.log(doc.name);<br/>        });</span><span id="c8d5" class="mc kl hu ls b fv mh me l mf mg">// Close the DB<br/>        db.close();<br/>    });</span><span id="9c8f" class="mc kl hu ls b fv mh me l mf mg">// Declare success<br/>    console.log("Last call");<br/>});</span></pre><p id="c554" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了使用<code class="eh lp lq lr ls b">MongoDB Node.js driver</code>，对<code class="eh lp lq lr ls b">javascript</code>中<code class="eh lp lq lr ls b">IO</code>的<strong class="jj hv">异步</strong>本质有一个坚实的理解是很重要的，包括数据库请求。</p><blockquote class="li lj lk"><p id="153c" class="jh ji ll jj b jk jl jm jn jo jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd ke hn dt translated"><em class="hu"/><code class="eh lp lq lr ls b"><em class="hu">mongo</em></code><em class="hu">shell是同步的，这意味着当您发出find命令时，它会阻塞等待命令返回，然后再继续。</em> <code class="eh lp lq lr ls b"><em class="hu">Node.js</em></code> <em class="hu">驱动就不是这样了。无论您是在进行查询，就像我们在这里定义的调用一样，还是仅仅建立到数据库的连接。正如在</em> <code class="eh lp lq lr ls b"><em class="hu">Javascript</em></code> <em class="hu">应用程序中常见的，我们将要使用的</em> <code class="eh lp lq lr ls b"><em class="hu">Node.js</em></code> <em class="hu">驱动程序被设计成它的方法异步运行。这意味着我们不是等待我们调用的任何方法的返回值，而是传入一个回调函数。</em></p></blockquote><p id="6a57" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">上述<code class="eh lp lq lr ls b">MongoClient.connect</code>调用中的第二个参数是一个回调函数。并将处理这个连接操作的结果。由于<code class="eh lp lq lr ls b">node.js</code>的<strong class="jj hv">任意非同步</strong>性质，以下消息在任何数据库值之前打印:</p><blockquote class="li lj lk"><p id="a4da" class="jh ji ll jj b jk jl jm jn jo jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd ke hn dt translated"><code class="eh lp lq lr ls b"><em class="hu">Last call</em></code></p></blockquote><h1 id="9af5" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">什么是快递</h1><p id="9919" class="pw-post-body-paragraph jh ji hu jj b jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka lx kc kd ke hn dt translated"><code class="eh lp lq lr ls b">Express</code>是一个<code class="eh lp lq lr ls b">node.js</code>模块，处理<code class="eh lp lq lr ls b">HTTP</code>请求的路由、请求参数和其他细节。</p><p id="95ab" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">下面是一个设置基本<code class="eh lp lq lr ls b">Express</code>服务器的基本示例:</p><pre class="kg kh ki kj fq ly ls lz ma aw mb dt"><span id="c686" class="mc kl hu ls b fv md me l mf mg">var express = require('express'),<br/>    app = express();</span><span id="6dbb" class="mc kl hu ls b fv mh me l mf mg">app.get('/', function(req, res){<br/>    res.send('Hello World');<br/>});</span><span id="60db" class="mc kl hu ls b fv mh me l mf mg">app.use(function(req, res){<br/>    res.sendStatus(404); <br/>});</span><span id="4b9d" class="mc kl hu ls b fv mh me l mf mg">var server = app.listen(3000, function() {<br/>    var port = server.address().port;<br/>    console.log('Express server listening on port %s', port);<br/>});</span></pre><h1 id="f483" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">实现HTML模板</h1><p id="709b" class="pw-post-body-paragraph jh ji hu jj b jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka lx kc kd ke hn dt translated">下面的例子展示了<strong class="jj hv">如何实现</strong>一个<code class="eh lp lq lr ls b">HTML</code>模板:</p><pre class="kg kh ki kj fq ly ls lz ma aw mb dt"><span id="a733" class="mc kl hu ls b fv md me l mf mg">//file: app.js<br/>var express = require('express'), //set up the Express server<br/>    app = express(), //use it to create an Express app<br/>    engines = require('consolidate'); //use the wrapper library</span><span id="8087" class="mc kl hu ls b fv mh me l mf mg">app.engine('html', engines.nunjucks); //register nunjucks template engine</span><span id="7760" class="mc kl hu ls b fv mh me l mf mg">app.set('view engine', 'html'); //as being associated with the html extension, set the view engine app setting</span><span id="1d43" class="mc kl hu ls b fv mh me l mf mg">app.set('views', __dirname + '/views'); //specify template location</span><span id="0c9a" class="mc kl hu ls b fv mh me l mf mg">app.get('/', function(req, res) {<br/>    res.render('hello', { name : 'Templates' });<br/>});</span><span id="691b" class="mc kl hu ls b fv mh me l mf mg">app.use(function(req, res){<br/>    res.sendStatus(404); <br/>});</span><span id="f925" class="mc kl hu ls b fv mh me l mf mg">var server = app.listen(3000, function() {<br/>    var port = server.address().port;<br/>    console.log('Express server listening on port %s', port);<br/>});</span></pre><p id="f0b8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">和html</p><pre class="kg kh ki kj fq ly ls lz ma aw mb dt"><span id="2a54" class="mc kl hu ls b fv md me l mf mg">//file: views/hello.html</span><span id="c4f0" class="mc kl hu ls b fv mh me l mf mg">&lt;h1&gt;Hello, {{name}}!&lt;/h1&gt;</span></pre><p id="ad1d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在上面的代码中，<code class="eh lp lq lr ls b">consolidate</code>基本上是一组用于<code class="eh lp lq lr ls b">Express</code>的模板引擎的包装器。<code class="eh lp lq lr ls b">Express</code>要求特定的库有特定的接口，而<code class="eh lp lq lr ls b">consolidate</code>为我们处理这些。<code class="eh lp lq lr ls b">__dirname</code>是一个<code class="eh lp lq lr ls b">node.js</code>变量，它允许我们访问应用文件(在我们的例子中是<code class="eh lp lq lr ls b">app.js</code>)所在的目录。因为，我们已经通过了<code class="eh lp lq lr ls b">name : 'Templates'</code> -我们将看到下面的输出:</p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div class="fe ff mx"><img src="../Images/464a7f856640e904bf7a97ca67bfeed5.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/0*WgYsnfiEZhENKDw0."/></div></figure><p id="4768" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里有一个更高级的版本，它也连接到数据库:</p><pre class="kg kh ki kj fq ly ls lz ma aw mb dt"><span id="66d7" class="mc kl hu ls b fv md me l mf mg">//file: app.js</span><span id="85c1" class="mc kl hu ls b fv mh me l mf mg">var express = require('express'),<br/>    app = express(),<br/>    engines = require('consolidate'),<br/>    MongoClient = require('mongodb').MongoClient,<br/>    assert = require('assert');</span><span id="cae3" class="mc kl hu ls b fv mh me l mf mg">app.engine('html', engines.nunjucks);<br/>app.set('view engine', 'html');<br/>app.set('views', __dirname + '/views');</span><span id="8302" class="mc kl hu ls b fv mh me l mf mg">MongoClient.connect('mongodb://localhost:27017/startup', function(err, db) {</span><span id="78ea" class="mc kl hu ls b fv mh me l mf mg">assert.equal(null, err);<br/>    console.log("Successfully connected to MongoDB.");</span><span id="c5e9" class="mc kl hu ls b fv mh me l mf mg">app.get('/', function(req, res){</span><span id="f1b0" class="mc kl hu ls b fv mh me l mf mg">db.collection('startup').find({}).toArray(function(err, docs) {<br/>            res.render('startup', { 'name': docs } );<br/>        });</span><span id="0add" class="mc kl hu ls b fv mh me l mf mg">});</span><span id="0a89" class="mc kl hu ls b fv mh me l mf mg">app.use(function(req, res){<br/>        res.sendStatus(404);<br/>    });<br/>    <br/>    var server = app.listen(3000, function() {<br/>        var port = server.address().port;<br/>        console.log('Express server listening on port %s.', port);<br/>    });</span><span id="f28e" class="mc kl hu ls b fv mh me l mf mg">});</span></pre><p id="911a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">和html</p><pre class="kg kh ki kj fq ly ls lz ma aw mb dt"><span id="d865" class="mc kl hu ls b fv md me l mf mg">//file: views/startup.html <br/>&lt;h1&gt;Hello, {{name}}!&lt;/h1&gt;</span></pre><h1 id="210d" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">使用Express处理GET请求</h1><pre class="kg kh ki kj fq ly ls lz ma aw mb dt"><span id="bfc5" class="mc kl hu ls b fv md me l mf mg">var express = require('express'),<br/>    app = express(),<br/>    engines = require('consolidate');</span><span id="02a6" class="mc kl hu ls b fv mh me l mf mg">app.engine('html', engines.nunjucks);<br/>app.set('view engine', 'html');<br/>app.set('views', __dirname + '/views');</span><span id="84ea" class="mc kl hu ls b fv mh me l mf mg">// Handler for internal server errors<br/>function errorHandler(err, req, res, next) {<br/>    console.error(err.message);<br/>    console.error(err.stack);<br/>    res.status(500).render('error_template', { error: err });<br/>}</span><span id="c958" class="mc kl hu ls b fv mh me l mf mg">app.get('/:name', function(req, res, next) {<br/>    var name = req.params.name;<br/>    var getvar1 = req.query.getvar1;<br/>    var getvar2 = req.query.getvar2;<br/>    res.render('hello', { name : name, getvar1 : getvar1, getvar2 : getvar2 });<br/>});</span><span id="5959" class="mc kl hu ls b fv mh me l mf mg">app.use(errorHandler);</span><span id="28bb" class="mc kl hu ls b fv mh me l mf mg">var server = app.listen(3000, function() {<br/>    var port = server.address().port;<br/>    console.log('Express server listening on port %s.', port);<br/>});</span></pre><p id="ffaf" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh lp lq lr ls b">hello</code>模板是:</p><pre class="kg kh ki kj fq ly ls lz ma aw mb dt"><span id="0a15" class="mc kl hu ls b fv md me l mf mg">&lt;h1&gt;Hello, {{name}}, here are your GET variables:&lt;/h1&gt;<br/>&lt;ul&gt;<br/>    &lt;li&gt;{{getvar1}}&lt;/li&gt;<br/>    &lt;li&gt;{{getvar2}}&lt;/li&gt;<br/>&lt;/ul&gt;</span></pre><p id="d8c5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里是<code class="eh lp lq lr ls b">error</code>模板:</p><pre class="kg kh ki kj fq ly ls lz ma aw mb dt"><span id="084b" class="mc kl hu ls b fv md me l mf mg">&lt;h1&gt;Error: {{error}}&lt;/h1&gt;</span></pre><p id="91f6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在上面的应用程序中，我们只注册了一条路线，即<code class="eh lp lq lr ls b">/:name</code>。冒号表示获取URL的这一部分，并存储在一个名为<code class="eh lp lq lr ls b">name</code>的变量中。</p><p id="544e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">下周将分享进一步的笔记。</p><p id="af9e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><a class="ae jg" href="https://goo.gl/photos/Yuigw4S9mLXDpSZN6" rel="noopener ugc nofollow" target="_blank">照片</a></p></div><div class="ab cl my mz hc na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="hn ho hp hq hr"><p id="a7ed" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="ll">原载于</em><a class="ae jg" href="http://xameeramir.github.io/mongodb-for-nodejs/" rel="noopener ugc nofollow" target="_blank"><em class="ll">xameeramir . github . io</em></a><em class="ll">。</em></p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="nf ng l"/></div></figure></div></div>    
</body>
</html>