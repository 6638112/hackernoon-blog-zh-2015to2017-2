<html>
<head>
<title>How I made a validation library using ES6 Proxy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何使用ES6代理创建一个验证库</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-i-made-a-validation-library-using-es6-proxy-59df82c1a4c0?source=collection_archive---------12-----------------------#2017-12-29">https://medium.com/hackernoon/how-i-made-a-validation-library-using-es6-proxy-59df82c1a4c0?source=collection_archive---------12-----------------------#2017-12-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/fd32aae445a39e4599c4c66b5ee4199d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3UMwIB0Xf5WHBzQaFytTEw.jpeg"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Photo taken by me @ San Juan de Gaztelugatxe. (CC BY-NC-SA 3.0)</figcaption></figure><div class=""/><p id="b42e" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">主流浏览器中的代理支持已经出现，是时候释放它带来的所有力量了。</p><p id="840f" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji ik">TLDR；如果你只是想检查代码，你可以在下面的github链接上找到它。如果你只是想看看验证器的运行情况，那就走到最后。</strong></p><div class="ht hu fm fo hv ke"><a href="https://github.com/sorodrigo/proxy-validator" rel="noopener  ugc nofollow" target="_blank"><div class="kf ab ej"><div class="kg ab kh cl cj ki"><h2 class="bd ik fv z el kj eo ep kk er et ii dt translated">Soro drigo/代理验证器</h2><div class="kl l"><h3 class="bd b fv z el kj eo ep kk er et ek translated">代理验证器——利用ES6代理的能力来验证和清理对象的小软件包。</h3></div><div class="km l"><p class="bd b gc z el kj eo ep kk er et ek translated">github.com</p></div></div><div class="kn l"><div class="ko l kp kq kr kn ks ib ke"/></div></div></a></div><blockquote class="kt ku kv"><p id="5d77" class="jg jh kw ji b jj jk jl jm jn jo jp jq kx js jt ju ky jw jx jy kz ka kb kc kd hn dt translated"><strong class="ji ik">完全披露:</strong>我在8月28日开始写这篇博客，然后我被一些事情缠住了，没有完成。现在我回来完成我开始的事情。</p></blockquote><p id="a40c" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我已经想了一会儿，我在<a class="ae la" href="https://developer.mozilla.org/en-US/" rel="noopener ugc nofollow" target="_blank"> MDN </a>上偶然发现的这个<a class="ae la" href="https://hackernoon.com/tagged/proxy" rel="noopener ugc nofollow" target="_blank">代理</a>是什么东西。我看了很多遍描述和API。然而，我不太清楚我可以利用它的用例是什么。</p><p id="2868" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">不管怎样，一个周末我花了一些时间去深入研究它，读了一些博客文章，并决定尝试一下。</p><h2 id="6c99" class="lb lc ij bd ld le lf lg lh li lj lk ll jr lm ln lo jv lp lq lr jz ls lt lu lv dt translated">那么什么是代理呢？</h2><p id="54b9" class="pw-post-body-paragraph jg jh ij ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd hn dt translated">如果你问Mozilla用户，他们可能会说:</p><blockquote class="kt ku kv"><p id="677f" class="jg jh kw ji b jj jk jl jm jn jo jp jq kx js jt ju ky jw jx jy kz ka kb kc kd hn dt translated"><strong class="ji ik">代理</strong>对象用于定义基本操作的自定义行为(如属性查找、赋值、枚举、函数调用等)。</p></blockquote><p id="2536" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">换句话说，当与一个对象发生交互时，你可以让事情发生。多亏了陷阱，这才成为可能，不过我们稍后会详细讨论这个问题。</p><p id="86d5" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">要创建新的代理，必须提供一个目标和一个处理程序。正如MDN所说，目标可以是任何类型的对象(即对象、数组、函数或代理)。这是将遭受与代理交互的最终副作用(如果有的话)的一方。</p><p id="ec4e" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">处理程序是另一个定义陷阱的对象。陷阱是函数，设置为在代理上执行操作时动作。根据操作的不同，会调用这样或那样的陷阱。我喜欢把陷阱看作某种生命周期挂钩。如果你使用过前端框架(比如React)，这就不是什么新鲜事了。对其他人来说——真的吗？—生命周期挂钩是在…aaaa组件生命周期的某一点调用的回调？什么东西？不管怎样。</p><p id="393d" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我说到哪了？当然是代理陷阱。例如，如果你想在组件挂载时执行一些代码，你需要实现<em class="kw">componentdimount</em>钩子，对吗？对吗？嗯，有了代理，你可以做(几乎)同样的事情！</p><p id="9f10" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在处理程序中实现<em class="kw">构造</em>陷阱，每次创建代理对象的新实例时，您的代码都会执行！</p><figure class="mb mc md me fq hw"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="709f" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">假设您想要添加一个钩子，当目标的一个属性是:</p><ul class=""><li id="ceaf" class="mh mi ij ji b jj jk jn jo jr mj jv mk jz ml kd mm mn mo mp dt translated">分配？使用<em class="kw">设置</em>陷阱。</li><li id="899d" class="mh mi ij ji b jj mq jn mr jr ms jv mt jz mu kd mm mn mo mp dt translated">读书？使用<em class="kw">获取</em>陷阱。</li><li id="5d8d" class="mh mi ij ji b jj mq jn mr jr ms jv mt jz mu kd mm mn mo mp dt translated">移除？使用<em class="kw">删除属性</em>陷阱。</li><li id="3481" class="mh mi ij ji b jj mq jn mr jr ms jv mt jz mu kd mm mn mo mp dt translated">结婚了？我不认为有一个，但是嘿！<a class="ae la" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Proxy" rel="noopener ugc nofollow" target="_blank">谁知道</a>！</li></ul><h2 id="6bcb" class="lb lc ij bd ld le lf lg lh li lj lk ll jr lm ln lo jv lp lq lr jz ls lt lu lv dt translated">用代理验证对象</h2><p id="ab77" class="pw-post-body-paragraph jg jh ij ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd hn dt translated">当我在记录代理和它们的用法时，我偶然发现了一个使用代理进行验证的例子。实现看起来非常简单，我认为它可以成为一个非常常见的用例——所以管它呢——我开始编写一个小型库。</p><p id="8f2e" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">因为我不想重新发明轮子，所以我决定使用现有的库进行所有的验证。这让我可以专注于<a class="ae la" href="https://hackernoon.com/tagged/es6" rel="noopener ugc nofollow" target="_blank"> ES6 </a>代理部分，也有一个<em class="kw">更广泛、更好、测试更好和维护更好的</em>验证。全拜<strong class="ji ik"> validator.js </strong>所赐；如果你使用JS验证库，你很可能正在使用它。如果你不是，去看看这里的<a class="ae la" href="https://github.com/chriso/validator.js" rel="noopener ugc nofollow" target="_blank"/>。</p><h2 id="bf47" class="lb lc ij bd ld le lf lg lh li lj lk ll jr lm ln lo jv lp lq lr jz ls lt lu lv dt translated">构建流程</h2><p id="32ad" class="pw-post-body-paragraph jg jh ij ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd hn dt translated">像往常一样，我的第一步是设置构建过程。为此我选择了<a class="ae la" href="https://rollupjs.org/" rel="noopener ugc nofollow" target="_blank"> Rollup.js </a>。这个配置非常简单，而且是专门为构建发行版代码而设计的。</p><h2 id="f34c" class="lb lc ij bd ld le lf lg lh li lj lk ll jr lm ln lo jv lp lq lr jz ls lt lu lv dt translated">设计决策</h2><p id="cd26" class="pw-post-body-paragraph jg jh ij ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd hn dt translated">正如我们之前看到的，要创建一个代理，我们需要两样东西:一个处理程序和一个目标。这很酷，但是验证呢？如果我们要验证一个对象内部的属性，我们需要一个验证模式。这个验证模式应该将每个属性映射到一组分配的值应该遵循的规则。</p><p id="692b" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">目前我们知道些什么？我们需要一个处理程序、一个目标和一个验证模式。</p><p id="c229" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">但是你猜怎么着！？我们选择了这个很棒的库来处理验证，它也支持消毒。那么为什么不把它加入到组合中呢？这可以用与验证相同的方式来处理，但是我们需要提供一个单独的模式，一个净化模式。</p><figure class="mb mc md me fq hw fe ff paragraph-image"><div class="fe ff mv"><img src="../Images/bf78ec52c67cfdc66d39729bf3f5127b.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*A5C14gpcE66XlnRfMI9FxQ.gif"/></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Two schemas, the handler and the target.</figcaption></figure><h2 id="4f1f" class="lb lc ij bd ld le lf lg lh li lj lk ll jr lm ln lo jv lp lq lr jz ls lt lu lv dt translated">validator.js包装器</h2><p id="26ef" class="pw-post-body-paragraph jg jh ij ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd hn dt translated">我不太记得我为什么先开始写这部分代码，但我怀疑是因为它更熟悉。</p><p id="f04a" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">知道我有一套规则来测试一个赋值；我的第一步是创建一个执行测试并返回结果的函数。测试可能成功，也可能失败。仅仅返回测试是否通过是不够的。正确的验证需要告诉用户哪里出错了，这意味着还应该返回一个错误对象。<br/>从这个意义上说，净化要简单得多，我只需要将净化规则应用到输入中，并返回最终结果。</p><h2 id="7f44" class="lb lc ij bd ld le lf lg lh li lj lk ll jr lm ln lo jv lp lq lr jz ls lt lu lv dt translated">弄脏我的手</h2><p id="4ce3" class="pw-post-body-paragraph jg jh ij ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd hn dt translated">好了，验证已经设置好并运行了，让我们代理一下。</p><p id="73bc" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们需要的是一个接收验证模式、可选的净化模式和目标的函数。然后返回一个代理对象。</p><p id="9365" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这意味着用户每次想要创建一个经过验证的对象时，都需要传递模式。这会很快变得很尴尬。那么为什么不分成两步呢？</p><p id="ee7d" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们将创建一个创建处理程序对象的工厂函数，然后返回另一个创建代理对象的工厂函数。</p><p id="41a3" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">工厂异常</p><p id="b3ad" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">换句话说，我们有一个创建验证器的函数，每个验证器创建一个验证代理对象。</p><figure class="mb mc md me fq hw"><div class="bz el l di"><div class="mf mg l"/></div><figcaption class="id ie fg fe ff if ig bd b be z ek">As you can see the actual implementation of the proxy is very small.</figcaption></figure><h2 id="182a" class="lb lc ij bd ld le lf lg lh li lj lk ll jr lm ln lo jv lp lq lr jz ls lt lu lv dt translated">使用代理验证器</h2><p id="80d4" class="pw-post-body-paragraph jg jh ij ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd hn dt translated">假设我们正在创建一个联系人列表，我们想验证一些字段，我们该怎么做呢？很简单，我们定义相应的ContactValidator模式并创建我们的withValidation代理。</p><figure class="mb mc md me fq hw"><div class="bz el l di"><div class="mf mg l"/></div></figure><h2 id="f44d" class="lb lc ij bd ld le lf lg lh li lj lk ll jr lm ln lo jv lp lq lr jz ls lt lu lv dt translated">关于代理的更多信息</h2><p id="9679" class="pw-post-body-paragraph jg jh ij ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd hn dt translated">Sindresorhus最近发布了一个很酷的代理观察者:</p><div class="ht hu fm fo hv ke"><a href="https://github.com/sindresorhus/on-change" rel="noopener  ugc nofollow" target="_blank"><div class="kf ab ej"><div class="kg ab kh cl cj ki"><h2 class="bd ik fv z el kj eo ep kk er et ii dt translated">sindresorhus/变化中</h2><div class="kl l"><h3 class="bd b fv z el kj eo ep kk er et ek translated">on-change -观察对象或数组的变化</h3></div><div class="km l"><p class="bd b gc z el kj eo ep kk er et ek translated">github.com</p></div></div><div class="kn l"><div class="mw l kp kq kr kn ks ib ke"/></div></div></a></div><p id="8061" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">您可以在以下帖子中找到更多关于ES6代理的信息:</p><div class="ht hu fm fo hv ke"><a href="https://ponyfoo.com/articles/es6-proxies-in-depth" rel="noopener  ugc nofollow" target="_blank"><div class="kf ab ej"><div class="kg ab kh cl cj ki"><h2 class="bd ik fv z el kj eo ep kk er et ii dt translated">ES6深度代理</h2><div class="kl l"><h3 class="bd b fv z el kj eo ep kk er et ek translated">代理是ES6中一个非常有趣的特性。简而言之，您可以使用代理来决定行为…</h3></div><div class="km l"><p class="bd b gc z el kj eo ep kk er et ek translated">ponyfoo.com</p></div></div><div class="kn l"><div class="mx l kp kq kr kn ks ib ke"/></div></div></a></div><div class="ht hu fm fo hv ke"><a href="http://dealwithjs.io/es6-features-10-use-cases-for-proxy/" rel="noopener  ugc nofollow" target="_blank"><div class="kf ab ej"><div class="kg ab kh cl cj ki"><h2 class="bd ik fv z el kj eo ep kk er et ii dt translated">ES6功能-代理的10种使用情形</h2><div class="kl l"><h3 class="bd b fv z el kj eo ep kk er et ek translated">今天我们来看看代理的可能用例，这是ES6的特性之一。源代码可以在GitHub上找到，在…</h3></div><div class="km l"><p class="bd b gc z el kj eo ep kk er et ek translated">dealwithjs.io</p></div></div><div class="kn l"><div class="my l kp kq kr kn ks ib ke"/></div></div></a></div><figure class="mb mc md me fq hw"><div class="bz el l di"><div class="mz mg l"/></div></figure></div></div>    
</body>
</html>