# 使用王乐编写现代 C++服务器。

> 原文：<https://medium.com/hackernoon/writing-high-performance-servers-in-modern-c-7cd00926828>

首先，感谢所有来自我的第一篇帖子的反馈——用 C++ 创业。

> **TL；我展示了如何构建一个现代的 C++高性能异步 echo 服务器，它只用 48 行代码就可以编写完成。**

我在之前的帖子中提到，我能够在一天之内使用脸书的[王乐](https://github.com/facebook/wangle)构建一个原型数据库引擎，所以这篇帖子解释了我是如何做到这一点的。在这篇文章结束时，你将能够使用王乐编写一个高性能的 C++服务器。这篇文章也作为一个教程，将被合并到王乐的 *README.md.*

我将展示如何用现代 C++编写 echo 服务器——这是分布式系统的“hello world”的等价物。服务器将通过直接发回相同的消息来响应每条消息。我们还将编写一个客户机，向我们的 echo 服务器发送消息。你可以在这里找到例子[的源代码。](https://github.com/facebook/wangle/tree/master/wangle/example/echo)

王乐是一个客户端/服务器应用程序框架，用于构建异步、事件驱动的现代 C++服务。它对王乐的基本抽象是管道。一旦你完全理解了这种抽象，你将能够编写各种复杂的现代 C++服务。另一个重要的抽象是*服务，*它是管道的高级版本，但超出了本文的范围。

## 管道

管道是王乐最重要和最强大的抽象。它提供了极大的灵活性来定制服务处理请求和响应的方式。

管道是一系列请求/响应处理程序。我在想一个类似管道的真实世界，我唯一能想到的是工厂里的生产线。生产线是按顺序工作的，每个工人收到一件物品，只用它完成一项功能，然后把它传递给下一个工人，直到产品完全制造出来。这不是一个很好的类比，因为它只能上游而不能下游，因为管道也可以以相反的方式处理下游，从制成品到原材料。

王乐处理程序处理下游(处理响应)和上游(处理请求)事件。一旦您将处理程序链接在一起，它就提供了一种灵活的方法来将原始数据流转换为所需的消息类型(类),以及将相反的消息类型转换为原始数据流。

例如，在 echo 服务的管道中，我们将创建一个管道，大约*到*有以下处理程序。

1.  **处理器 1**

*上游*:从一个套接字接收一个原始二进制流，并将其读入一个零拷贝字节缓冲区，然后将其发送到处理程序 2。

*下游*:接收一个零拷贝字节缓冲区，并将其内容写入套接字。

2.**处理器 2**

*上游:*从处理程序 1 接收一个零拷贝字节缓冲区，将字节缓冲区解码成一个字符串，并将该字符串向上发送到处理程序 3。

*下游:*从处理程序 3 接收一个字符串，将 std::string 编码到一个零拷贝字节缓冲区中，并将其发送到处理程序 1。

3.**处理器 3**

*上游:*从处理程序 2 接收一个字符串，然后将它发送回管道写回客户端。它将字符串发送回处理程序 2。

*下游:*从上游接收一个 std::string，并将其向下传递给处理程序 2。

非常重要的一点是，一个处理程序应该只做一件事，而且只做一件事。如果有一个处理程序执行不止一个功能——比如直接从原始字节流中解码一个字符串——那么就需要把它分成几个处理程序。这对于最大化可维护性和灵活性非常重要。

哦，对了，处理程序不是线程安全的，所以不要添加任何没有互斥、原子锁等保护的共享状态。如果你想使用一个线程安全的容器，那么我真的推荐 Folly 的无锁数据结构，你可以很容易地导入它，因为它们是王乐的一个依赖项，速度非常快。

如果这还没有太多意义，不要担心——当您看到实际的代码时，应该会更清楚。

## 回声服务器

我将开始展示用王乐构建您的第一个 C++ echo 服务器的代码。我想你已经安装了王乐。我必须警告，不幸的是，它还没有建立在马克斯 OS X 上，所以我建议虚拟化 Ubuntu 14.04 来安装它。

这里是 echo 处理程序:它接收一个字符串，将其打印到 stdout，然后在管道中将其发送回下游。添加行分隔符非常重要，因为我们的管道将使用行解码器——将一个字节缓冲区拆分为行分隔的字节缓冲区。

这需要是管道中的最后一个处理程序。现在我们需要创建一个 *PipelineFactory* ，在这里我们定义管道来处理请求和响应。

非常重要的一点是，你必须严格控制插入的顺序，因为它们是按插入顺序排列的。这个管道有 4 个处理程序:

1.  **AsyncSocketHandler:**

*上游:*从套接字读取原始数据流，并将其转换成零拷贝字节缓冲区。

*下游:*将零拷贝字节缓冲区的内容写入底层套接字。

2. **LineBasedFrameDecoder:**

*上游:*接收一个零拷贝字节缓冲区，并在行尾拆分

*下游:*只是将字节缓冲传递给 *AsyncSocketHandler*

3.**字符串编码:**

*上游:* 接收一个字节缓冲区，将其解码成 std::string，并向上传递给 EchoHandler。

*下游:* 接收一个 std::string，将其编码到一个字节缓冲区，并向下传递到 LineBasedFrameDecoder。

4. **EchoHandler:**

上游:接收一个 std::string 并将其写入管道，管道会将消息发送到下游。

下游:接收一个 std::string 并将其转发给 StringCodec。

现在需要做的就是将管道工厂插入到一个 *ServerBootstrap* 中，这就差不多了。绑定一个端口并等待它停止。

我们已经在 48 LOC 下编写了一个高性能的异步 C++服务器。

## 回显客户端

echo 客户机的代码与 Echo 服务器非常相似。

注意，我们覆盖了其他方法— *readException* 和*read of。很少有其他方法可以克服。如果需要处理特定的事件，只需重写相应的虚方法。*

这是客户的管道工厂。除了 *EventBaseHandler* 之外，它与服务器的管道工厂完全相同，后者处理从事件循环线程写入的数据。

这是当它完全为客户端放置时的样子。

它在一个循环中从 stdin 读取输入，并将其写入管道，然后阻塞，直到处理完响应。它通过调用来阻止。从返回的未来中获取()。

## 摘要

我已经展示了如何使用王乐用现代 C++快速编写一个基本的高性能服务器。你现在应该知道了王乐的基础知识，它应该给你用 C++编写自己的服务的信心。我强烈建议理解*服务抽象*，因为你可以用它来构建真正复杂的服务器。

> [黑客中午](http://bit.ly/Hackernoon)是黑客如何开始他们的下午。我们是 [@AMI](http://bit.ly/atAMIatAMI) 家庭的一员。我们现在[接受投稿](http://bit.ly/hackernoonsubmission)并乐意[讨论广告&赞助](mailto:partners@amipublications.com)机会。
> 
> 要了解更多信息，[请阅读我们的“关于”页面](https://goo.gl/4ofytp) , [喜欢/在脸书给我们发消息](http://bit.ly/HackernoonFB)，或者简单地，[发推文/DM @HackerNoon。](https://goo.gl/k7XYbx)
> 
> 如果你喜欢这个故事，我们推荐你阅读我们的[最新科技故事](http://bit.ly/hackernoonlatestt)和[趋势科技故事](https://hackernoon.com/trending)。直到下一次，不要把世界的现实想当然！