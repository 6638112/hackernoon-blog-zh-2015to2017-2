<html>
<head>
<title>A functional approach to dependency injection in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中依赖注入的函数式方法</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/superkleisliisfantasticframeworksareatrocious-a-functional-approach-to-dependency-injection-in-e7bc8c4993fa?source=collection_archive---------5-----------------------#2017-08-14">https://medium.com/hackernoon/superkleisliisfantasticframeworksareatrocious-a-functional-approach-to-dependency-injection-in-e7bc8c4993fa?source=collection_archive---------5-----------------------#2017-08-14</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><h2 id="dab3" class="hs ht hu bd b gc hv hw hx hy hz ia ek ib translated" aria-label="kicker paragraph">superkleisliisfantiaticframeworksareatrocious</h2><div class=""/><p id="bcb2" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">通常在<a class="ae jy" href="https://hackernoon.com/tagged/java" rel="noopener ugc nofollow" target="_blank"> Java </a>中，我们使用在运行时解决依赖关系的框架，这通常会导致很难跟踪部署中的错误。一个功能性更强的替代方法是稍微改变我们程序的结构，这样就可以以一种类型安全的方式惰性地注入依赖项。编译器而不是运行时将为我们识别和捕捉错误。让我们从一个问题开始:</p><h1 id="2144" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">我们如何转换方法的签名，以便将输入参数转移到返回类型？</h1><figure class="ky kz la lb fq lc fe ff paragraph-image"><div class="fe ff kx"><img src="../Images/5cf99f24b8c5a784ef92043d39cc5076.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*nSlX1ApgxPVgrjkYrMv8fQ.png"/></div></figure><p id="6ea2" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">给定下面的Java方法签名，我们是否可以重构代码，使DAO成为返回类型的一部分，而不是方法参数？</p><pre class="ky kz la lb fq lf lg lh li aw lj dt"><span id="ff21" class="lk ka hu lg b fv ll lm l ln lo"><strong class="lg ie">public </strong>String loadName(DAO dao, long id);</span></pre><p id="eecd" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">想象一下，如果我们的loadName方法实现如下</p><pre class="ky kz la lb fq lf lg lh li aw lj dt"><span id="76b2" class="lk ka hu lg b fv ll lm l ln lo"><strong class="lg ie">public </strong>String loadName(DAO dao, long id){<br/>   return  dao.loadRecord(id)<br/>              .getName();</span><span id="1c0d" class="lk ka hu lg b fv lp lm l ln lo">} </span></pre><h2 id="eede" class="lk ka hu bd kb lq lr ls kf lt lu lv kj jl lw lx kn jp ly lz kr jt ma mb kv ia dt translated">一种解决方案是返回一个函数。</h2><figure class="ky kz la lb fq lc fe ff paragraph-image"><div class="fe ff mc"><img src="../Images/a341840f8fe63b37509045594bcd92c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*hWsPNbj1meVnUI26oZNW2g.png"/></div></figure><p id="d7e9" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">如果我们要返回一个函数而不是一个字符串，我们可以将道安输入到该函数中，并将其作为方法参数移除。</p><pre class="ky kz la lb fq lf lg lh li aw lj dt"><span id="8a86" class="lk ka hu lg b fv ll lm l ln lo"><strong class="lg ie">public </strong>Function&lt;DAO,String&gt; loadName(long id);</span></pre><p id="0e34" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">现在我们将急切的实现切换到懒惰的实现。</p><pre class="ky kz la lb fq lf lg lh li aw lj dt"><span id="8a2d" class="lk ka hu lg b fv ll lm l ln lo"><strong class="lg ie">public </strong>Function&lt;DAO,String&gt; loadName(long id){ <br/>    return dao -&gt;  dao.loadRecord(id)<br/>                      .getName();<br/>}</span></pre><p id="63cb" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">为了实际加载用户名，我们需要传入一个DAO实例。</p><pre class="ky kz la lb fq lf lg lh li aw lj dt"><span id="685b" class="lk ka hu lg b fv ll lm l ln lo">String name = loadName(10l).apply(dao);</span></pre><h2 id="c134" class="lk ka hu bd kb lq lr ls kf lt lu lv kj jl lw lx kn jp ly lz kr jt ma mb kv ia dt translated">惰性依赖注入</h2><p id="1761" class="pw-post-body-paragraph ja jb hu jc b jd md jf jg jh me jj jk jl mf jn jo jp mg jr js jt mh jv jw jx hn dt translated">在上面的例子中，当调用loadName时，我们已经移除了对拥有DAO的硬性依赖。正如我们将在本文的其余部分看到的，可以将函数调用链接在一起，使用加载的名称，并且只在代码中我们手头有依赖项的地方提供依赖项(DAO)。</p><p id="3b1a" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">正如我们可以延迟解决方法调用中注入的依赖关系一样，我们可以使用函数来延迟我们可能存储为字段的对象的注入。</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div class="fe ff mi"><img src="../Images/31b7a4277316d63d6364a325389a2bfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*523xlPCcA8swBjcrcO670A.png"/></div></figure><p id="5684" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">转换上面的对象以返回注入FieldType的函数，看起来与前面执行的方法级重构非常相似。</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div class="fe ff mc"><img src="../Images/db6bb272d508924e3705e5597faa5140.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*EQWNWhZa_Q2y29Tusgy10Q.png"/></div></figure><h1 id="8278" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">构成函数</h1><p id="05fe" class="pw-post-body-paragraph ja jb hu jc b jd md jf jg jh me jj jk jl mf jn jo jp mg jr js jt mh jv jw jx hn dt translated">到目前为止，我们已经定义了一种方法，通过这种方法，我们可以在一个方法调用深度中惰性地注入一个依赖项。当我们调用loadName时，我们接收到一个函数，通过执行这个函数，我们可以访问这个名字。</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="fe ff mj"><img src="../Images/deb58f5ada950c889850790a641bf1da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5JniCu2s2Pp5qGJjjoXj2Q.jpeg"/></div></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">Photo by <a class="ae jy" href="https://unsplash.com/photos/n5wwck8ES4w?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Jakob Owens</a> on <a class="ae jy" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d311" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">不执行函数而处理返回的名字是可能的，但是有点复杂。我们可以对返回的函数进行链式操作。</p><p id="34e2" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">要使用该方法的早期版本构建包含用户名的字符串，我们可以编写</p><pre class="ky kz la lb fq lf lg lh li aw lj dt"><span id="5a67" class="lk ka hu lg b fv ll lm l ln lo">public<strong class="lg ie"> </strong>String loadName(DAO dao, long id);</span><span id="6d7c" class="lk ka hu lg b fv lp lm l ln lo">String userData = "User's name is " + <strong class="lg ie">loadName</strong>(dao,10l);</span></pre><p id="b38d" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">但是对于懒惰版本，我们需要使用函数的<strong class="jc ie">和</strong>方法</p><pre class="ky kz la lb fq lf lg lh li aw lj dt"><span id="46d0" class="lk ka hu lg b fv ll lm l ln lo">public<strong class="lg ie"> </strong>Function&lt;DAO,String&gt; loadName(long id);</span><span id="b19d" class="lk ka hu lg b fv lp lm l ln lo"><strong class="lg ie">loadName</strong>(10l).<strong class="lg ie">andThen</strong>(name-&gt;"User's name is "+ name);</span><span id="b574" class="lk ka hu lg b fv lp lm l ln lo">Function&lt;DAO,String&gt; sentence = <strong class="lg ie">loadName</strong>(10l).<strong class="lg ie">andThen</strong>(name-&gt;"User's name is "+ name);</span><span id="1a58" class="lk ka hu lg b fv lp lm l ln lo">System.out.println(sentence.apply(dao));</span></pre><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="fe ff ms"><img src="../Images/92648ef6f4de21ee07d119c23bd34aac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qG6dbAH-IA5BXLUgk_j0LA.png"/></div></div></figure><p id="08e0" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">当一个函数的输出类型与另一个函数的输入类型匹配时，我们可以使用and将它们链接在一起。</p><h2 id="de82" class="lk ka hu bd kb lq lr ls kf lt lu lv kj jl lw lx kn jp ly lz kr jt ma mb kv ia dt translated">链接方法调用</h2><p id="406f" class="pw-post-body-paragraph ja jb hu jc b jd md jf jg jh me jj jk jl mf jn jo jp mg jr js jt mh jv jw jx hn dt translated">然后允许我们将函数调用链接在一起，但是要链接返回函数的方法，我们需要更强大的东西。</p><pre class="ky kz la lb fq lf lg lh li aw lj dt"><span id="2e7a" class="lk ka hu lg b fv ll lm l ln lo">public<strong class="lg ie"> </strong>Function&lt;DAO,String&gt; loadName(long id);<br/>public<strong class="lg ie"> </strong>Function&lt;DAO,Boolean&gt; updateName(long id, String name);</span></pre><p id="d230" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">使用and，我们将得到一个嵌套的数据结构(返回函数的函数)。</p><pre class="ky kz la lb fq lf lg lh li aw lj dt"><span id="7e8e" class="lk ka hu lg b fv ll lm l ln lo"><strong class="lg ie">Function</strong>&lt;DAO,<strong class="lg ie">Function</strong>&lt;DAO,Boolean&gt;&gt; fn = loadName(10).andThen(s-&gt;updateName(10,+” -suffix”));</span></pre><p id="bbde" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">为了调用我们的函数，我们需要应用我们的DAO两次</p><pre class="ky kz la lb fq lf lg lh li aw lj dt"><span id="b0e1" class="lk ka hu lg b fv ll lm l ln lo">System.out.println(fn.apply(dao).apply(dao));</span></pre><h2 id="03cb" class="lk ka hu bd kb lq lr ls kf lt lu lv kj jl lw lx kn jp ly lz kr jt ma mb kv ia dt translated">Reader Monad:嵌套数据结构的一种有用模式</h2><p id="a01f" class="pw-post-body-paragraph ja jb hu jc b jd md jf jg jh me jj jk jl mf jn jo jp mg jr js jt mh jv jw jx hn dt translated">单子是函数式<a class="ae jy" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>中处理嵌套数据结构的一种非常有用的模式。这是他们擅长的事情。例如，我们可以在Optional的操作链中合并对返回Optional的方法的调用，结果仍然有一个很好的未嵌套的单个Optional。flatMap运算符将嵌套的选项展平成一个可选的。</p><figure class="ky kz la lb fq lc"><div class="bz el l di"><div class="mt mu l"/></div></figure><p id="436f" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">虽然我们可以手动展开函数调用，这样它们就不会嵌套，但是函数有一个单子——读取器单子。</p><pre class="ky kz la lb fq lf lg lh li aw lj dt"><span id="05cc" class="lk ka hu lg b fv ll lm l ln lo"><strong class="lg ie">Function</strong>&lt;DAO,Boolean&gt; fn = dao-&gt;updateName(10,loadName(dao)+" -suffix"));</span></pre><p id="8595" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">Reader Monad允许我们使用flatMap和Map(就像Streams和Optional一样)来代替。要从使用函数切换到读取器，只需将函数替换为读取器作为返回类型。(<a class="ae jy" href="https://static.javadoc.io/com.aol.simplereact/cyclops-react/2.1.0/cyclops/control/Reader.html" rel="noopener ugc nofollow" target="_blank">阅读器</a>通常被实现为扩展功能)</p><pre class="ky kz la lb fq lf lg lh li aw lj dt"><span id="6bc0" class="lk ka hu lg b fv ll lm l ln lo">public<strong class="lg ie"> Reader</strong>&lt;<strong class="lg ie">DAO</strong>,String&gt; loadName(long id);<br/>public<strong class="lg ie"> Reader</strong>&lt;<strong class="lg ie">DAO</strong>,Boolean&gt; updateName(long id, String name);</span><span id="1807" class="lk ka hu lg b fv lp lm l ln lo">Reader&lt;<strong class="lg ie">DAO</strong>,Boolean&gt;  r= loadName(10).flatMap(s-&gt;updateName(10,s));</span></pre><p id="badf" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">当直接构造函数时，输出类型应该映射到输入类型，当使用读取器单子构造方法调用时，更重要的是返回的读取器的输入类型是相同的。在平面映射/映射操作期间，输出类型作为参数提供。</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="fe ff mv"><img src="../Images/dd482e41c48de18b4952f1a55edea7dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yxA2b6wRlCqtZsHwSpMEAg.png"/></div></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">composition of returned Readers all accept DAO</figcaption></figure><h2 id="2c12" class="lk ka hu bd kb lq lr ls kf lt lu lv kj jl lw lx kn jp ly lz kr jt ma mb kv ia dt translated">为了理解</h2><p id="c9fa" class="pw-post-body-paragraph ja jb hu jc b jd md jf jg jh me jj jk jl mf jn jo jp mg jr js jt mh jv jw jx hn dt translated">一旦我们开始将许多方法调用链接在一起，嵌套的平面图和映射会变得有点笨拙。为了便于理解，使用a来构造我们的调用可以帮助我们保持代码更加整洁。让我们介绍一种记录成功和失败的新方法</p><pre class="ky kz la lb fq lf lg lh li aw lj dt"><span id="c83a" class="lk ka hu lg b fv ll lm l ln lo">public<strong class="lg ie"> </strong>boolean<strong class="lg ie"> </strong>logIfFail(long<strong class="lg ie"> </strong>id, String name, boolean<strong class="lg ie"> </strong>success);</span></pre><p id="daaf" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">将调用链接到此方法会导致更复杂的表达式</p><pre class="ky kz la lb fq lf lg lh li aw lj dt"><span id="0882" class="lk ka hu lg b fv ll lm l ln lo"><br/>Reader&lt;DAO,Boolean&gt;  r= loadName(10).<strong class="lg ie">flatMap</strong>(s-&gt;updateName(10,s)<br/>                                                <br/>                            .map(success-&gt;logIfFail(10,s,success));</span></pre><p id="2e5e" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">为了便于理解，我们可以用a来简化事情</p><figure class="ky kz la lb fq lc"><div class="bz el l di"><div class="mt mu l"/></div></figure><p id="d77b" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">当在链的更上游引入另一个方法调用时，我们可以看到for comprehensions的真正好处，没有for comprehensions，事情会变得非常混乱。</p><pre class="ky kz la lb fq lf lg lh li aw lj dt"><span id="c794" class="lk ka hu lg b fv ll lm l ln lo">public Reader&lt;DAO,Long&gt; findNextId();</span></pre><p id="91ce" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">我们的调用序列可能会变成</p><pre class="ky kz la lb fq lf lg lh li aw lj dt"><span id="dca5" class="lk ka hu lg b fv ll lm l ln lo">Reader&lt;DAO,Boolean&gt;  r= findNextId().flatMap(id-&gt;loadName(id).flatMap(s-&gt;updateName(10,s)<br/>                                                <br/>.map(success-&gt;logIfFail(10,s,success)));</span></pre><p id="94bc" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">当为了理解而表达时，看起来更清晰</p><figure class="ky kz la lb fq lc"><div class="bz el l di"><div class="mt mu l"/></div></figure><p id="cccf" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">太棒了，所以现在我们可以延迟像DAO这样的关键依赖项的注入，让我们的方法返回Reader Monads，它将懒洋洋地接受我们的DAO，并使用for comprehensions将它们链接在一起。为了执行我们的函数链，我们可以将DAO传递给我们的读者，我们链接在一起的所有方法都将执行。</p><pre class="ky kz la lb fq lf lg lh li aw lj dt"><span id="1529" class="lk ka hu lg b fv ll lm l ln lo">boolean success = updateName.apply(dao);</span></pre><h2 id="d205" class="lk ka hu bd kb lq lr ls kf lt lu lv kj jl lw lx kn jp ly lz kr jt ma mb kv ia dt translated">异步读取器=复杂类型签名！</h2><p id="28ac" class="pw-post-body-paragraph ja jb hu jc b jd md jf jg jh me jj jk jl mf jn jo jp mg jr js jt mh jv jw jx hn dt translated">但是当我们有返回其他单子类型的方法时会发生什么呢？读写远程存储是IO绑定的操作，也许我们的方法应该利用未来？我们的类型签名要变得混乱了！</p><pre class="ky kz la lb fq lf lg lh li aw lj dt"><span id="8a02" class="lk ka hu lg b fv ll lm l ln lo">public <strong class="lg ie">Reader</strong>&lt;DAO,<strong class="lg ie">Future</strong>&lt;Long&gt;&gt; findNextId();<br/>public<strong class="lg ie"> Reader</strong>&lt;DAO,<strong class="lg ie">Future</strong>&lt;String&gt;&gt; loadName(long id);<br/>public<strong class="lg ie"> Reader</strong>&lt;DAO,<strong class="lg ie">Future</strong>&lt;Boolean&gt;&gt; updateName(long id, String name);<br/>public<strong class="lg ie"> Reader&lt;Future&lt;</strong>Boolean<strong class="lg ie">&gt;&gt; </strong>logIfFail(long<strong class="lg ie"> </strong>id, String name, boolean<strong class="lg ie"> </strong>success);</span></pre><p id="a33b" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">即使对于将loadName、updateName和logIfFail链接在一起的稍微简单的用例，我们的for理解也变得非常复杂！</p><figure class="ky kz la lb fq lc"><div class="bz el l di"><div class="mt mu l"/></div></figure><h1 id="22fe" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">克莱斯利来救援了</h1><p id="d8ad" class="pw-post-body-paragraph ja jb hu jc b jd md jf jg jh me jj jk jl mf jn jo jp mg jr js jt mh jv jw jx hn dt translated">Kleisli是一个返回一元类型的函数。它一般可以表示一个函数，返回一个未来的、流的、可选的或任何其他的Java中的单子类型。与Reader非常相似，我们也可以为它定义map和flatMap方法。神奇的是，尽管下面两种类型是等价的，但使用kleisli比使用reader要简单得多。</p><pre class="ky kz la lb fq lf lg lh li aw lj dt"><span id="be81" class="lk ka hu lg b fv ll lm l ln lo"><strong class="lg ie">Reader</strong>&lt;DAO,Future&lt;Long&gt;&gt; reader;<br/><strong class="lg ie">Kleisli</strong>&lt;future,DAO,Long&gt; kleisli;</span></pre><p id="9ddc" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">让我们重写我们的方法来返回Kleisli</p><pre class="ky kz la lb fq lf lg lh li aw lj dt"><span id="bd2b" class="lk ka hu lg b fv ll lm l ln lo">public <strong class="lg ie">Kleisli</strong>&lt;<strong class="lg ie">future</strong>,DAO,Long&gt; findNextId();<br/>public<strong class="lg ie"> Kleisli</strong>&lt;<strong class="lg ie">future</strong>,DAO,String&gt; loadName(long id);<br/>public<strong class="lg ie"> Kleisli</strong>&lt;<strong class="lg ie">future</strong>,DAO,Boolean&gt; updateName(long id, String name);<br/>public<strong class="lg ie"> Future&lt;</strong>Boolean<strong class="lg ie">&gt; </strong>logIfFail(long<strong class="lg ie"> </strong>id, String name, boolean<strong class="lg ie"> </strong>success);</span></pre><p id="d469" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">我们可以使用flatMap和Map通过Kleisli将方法调用链接在一起，但是与我们之前的例子不同的是，我们现在有了依赖项的延迟注入和异步执行。</p><pre class="ky kz la lb fq lf lg lh li aw lj dt"><span id="9b30" class="lk ka hu lg b fv ll lm l ln lo"><strong class="lg ie">Kleisli</strong>&lt;<strong class="lg ie">future</strong>,DAO,Boolean&gt;  k= loadName(10).flatMapK(s-&gt;updateName(10,s));</span></pre><p id="bff7" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">当编写返回读取器实例的方法调用时，我们必须保持输入类型(注入的依赖)不变。当组合返回Kleisli实例的方法调用时，我们需要保持monad类型和输入类型相同。</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="fe ff mv"><img src="../Images/68ed18a648199ae3104da259c4af429f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lxa3LZKWNFxQPDAl_94Jxw.png"/></div></div></figure><h2 id="5e0e" class="lk ka hu bd kb lq lr ls kf lt lu lv kj jl lw lx kn jp ly lz kr jt ma mb kv ia dt translated">链接加载和保存操作</h2><p id="4bfa" class="pw-post-body-paragraph ja jb hu jc b jd md jf jg jh me jj jk jl mf jn jo jp mg jr js jt mh jv jw jx hn dt translated">在Debashish Gosh令人敬畏的<a class="ae jy" href="https://www.manning.com/books/functional-and-reactive-domain-modeling" rel="noopener ugc nofollow" target="_blank">功能和反应域建模</a>中，他展示了如何使用Kleisli在Scala的一个方法中链接异步调用来贷记和借记一个帐户。我们可以在Java中使用同样的技术。</p><p id="def9" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">如果我们根据Kleisli定义异步加载和保存方法</p><figure class="ky kz la lb fq lc"><div class="bz el l di"><div class="mt mu l"/></div></figure><p id="031f" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">一个处理方法可以通过平面映射Kleisli调用来利用这些来加载、转换和保存数据。</p><figure class="ky kz la lb fq lc"><div class="bz el l di"><div class="mt mu l"/></div></figure><p id="4fde" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">调用process会产生一个Kleisli实例，它负责加载、转换和保存，但不执行它。我们通过调用apply(并传入一个DAO实现)来执行方法链，当我们这样做时，我们的代码将异步执行。</p><figure class="ky kz la lb fq lc"><div class="bz el l di"><div class="mt mu l"/></div></figure><h2 id="52f2" class="lk ka hu bd kb lq lr ls kf lt lu lv kj jl lw lx kn jp ly lz kr jt ma mb kv ia dt translated">更干净的代码</h2><p id="c8a7" class="pw-post-body-paragraph ja jb hu jc b jd md jf jg jh me jj jk jl mf jn jo jp mg jr js jt mh jv jw jx hn dt translated">有了Kleisli，我们可以回过头来重构我们的代码，搜索下一个用户Id，修改和更新用户名以使用Kleisli进行理解(在cyclops-react 2.2.0中)</p><figure class="ky kz la lb fq lc"><div class="bz el l di"><div class="mt mu l"/></div></figure><h2 id="e38d" class="lk ka hu bd kb lq lr ls kf lt lu lv kj jl lw lx kn jp ly lz kr jt ma mb kv ia dt translated">许多受支持的Java Monad类型</h2><blockquote class="mw"><p id="3257" class="mx my hu bd mz na nb nc nd ne nf jx ek translated">创作所有的东西</p></blockquote><p id="1ef4" class="pw-post-body-paragraph ja jb hu jc b jd ng jf jg jh nh jj jk jl ni jn jo jp nj jr js jt nk jv jw jx hn dt translated">cyclops集成模块为<a class="ae jy" href="https://github.com/aol/cyclops/tree/master/cyclops-vavr" rel="noopener ugc nofollow" target="_blank"> Vavr </a>、<a class="ae jy" href="https://github.com/aol/cyclops/tree/master/cyclops-functionaljava" rel="noopener ugc nofollow" target="_blank"> Functional Java </a>、<a class="ae jy" href="https://github.com/aol/cyclops/tree/master/cyclops-rx" rel="noopener ugc nofollow" target="_blank"> RxJava </a>、<a class="ae jy" href="https://github.com/aol/cyclops/tree/master/cyclops-rxjava2" rel="noopener ugc nofollow" target="_blank"> RxJava 2 </a>、<a class="ae jy" href="https://github.com/aol/cyclops/tree/master/cyclops-reactor" rel="noopener ugc nofollow" target="_blank"> Reactor </a>、<a class="ae jy" href="https://github.com/aol/cyclops-react" rel="noopener ugc nofollow" target="_blank"> JDK /cyclops-react </a>甚至<a class="ae jy" href="https://github.com/aol/cyclops/tree/master/cyclops-guava" rel="noopener ugc nofollow" target="_blank">番石榴</a>类型提供了更高级的编码。</p><p id="ed08" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">下面显示了受支持类型的一个小示例</p><figure class="ky kz la lb fq lc"><div class="bz el l di"><div class="mt mu l"/></div></figure><h2 id="a7ef" class="lk ka hu bd kb lq lr ls kf lt lu lv kj jl lw lx kn jp ly lz kr jt ma mb kv ia dt translated">基于AnyM的等价</h2><p id="0d06" class="pw-post-body-paragraph ja jb hu jc b jd md jf jg jh me jj jk jl mf jn jo jp mg jr js jt mh jv jw jx hn dt translated"><a class="ae jy" rel="noopener" href="/@johnmcclean/a-type-safe-java-monad-api-part-i-with-vavrs-future-and-try-7beaea28d351"> cyclops-react提供了一个强大的抽象AnyM </a>来处理常见的monad类型，并提供了KleisliM，它是通过AnyM处理monad时的Kleisli等价物。</p><h2 id="97ad" class="lk ka hu bd kb lq lr ls kf lt lu lv kj jl lw lx kn jp ly lz kr jt ma mb kv ia dt translated">类型安全惰性依赖注入和异步执行</h2><figure class="ky kz la lb fq lc fe ff paragraph-image"><div class="fe ff nl"><img src="../Images/414559638eb8ea92c4e89185c59502df.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*T42jjTBG5xjhJMgsLWq7Fg.png"/></div></figure><p id="8735" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">Kleisli为类型安全依赖注入提供了一个非常强大的机制。与传统的Java依赖注入技术不同，我们不会因为未实现的依赖关系(或循环定义的依赖)而出现运行时错误。更重要的是，我们能够在不依赖于运行时AOP或代理对象的情况下将懒惰的异步效果链接在一起，更多种类的错误将由编译器而不是运行时来检测。</p><figure class="ky kz la lb fq lc"><div class="bz el l di"><div class="nm mu l"/></div></figure></div></div>    
</body>
</html>