<html>
<head>
<title>Taking A Step Back From JavaScript Hype To Understand Scope Resolution in ES6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从JavaScript炒作中退一步来理解ES6中的范围解析</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-beautiful-example-to-master-es6-scope-resolution-7f948619fe95?source=collection_archive---------9-----------------------#2017-06-11">https://medium.com/hackernoon/a-beautiful-example-to-master-es6-scope-resolution-7f948619fe95?source=collection_archive---------9-----------------------#2017-06-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="5607" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">解释ES6中的JavaScript范围解析。</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/fec6522cd226e2d5478b4f0afad44cbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L0qJKz04JCjRJtpsECq7Og.jpeg"/></div></div></figure><p id="2a14" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">JavaScript炒作是真的！这种语言本身、它的社区以及它的生态系统正在飞速发展。此外，如此多不同知识来源的存在使得语言反映了网络的无政府状态。在这种情况下，人们可能会花费数年的时间用JavaScript编码和构建项目，而没有真正理解该语言的关键概念，例如范围解析。</p><p id="4e46" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">让我们来看看这个例子:</p><pre class="jk jl jm jn fq kr ks kt ku aw kv dt"><span id="ccd3" class="kw kx hu ks b fv ky kz l la lb">for(var i=0; i&lt;3; i++){<br/>      setTimeout( function foo() { console.log(i) }, 100);<br/>}</span></pre><p id="6e34" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">你认为输出是多少？</p><p id="ea48" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果这是你第一次看到这样的例子，你的答案是</p><pre class="jk jl jm jn fq kr ks kt ku aw kv dt"><span id="d8e3" class="kw kx hu ks b fv ky kz l la lb">0<br/>1<br/>2</span></pre><p id="d483" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">那么您可能想看看这篇文章，了解更多关于JavaScript范围解析和ES6引入的新的很酷的变化。</p><h1 id="b97a" class="lc kx hu bd ld le lf lg lh li lj lk ll ja lm jb ln jd lo je lp jg lq jh lr ls dt translated">什么是范围？</h1><p id="37d9" class="pw-post-body-paragraph jv jw hu jx b jy lt iv ka kb lu iy kd ke lv kg kh ki lw kk kl km lx ko kp kq hn dt translated">范围是代码中与变量相关的空间。我们可以把变量和函数看作有生命的生物，把作用域看作它们的栖息地。</p><h1 id="99d8" class="lc kx hu bd ld le lf lg lh li lj lk ll ja lm jb ln jd lo je lp jg lq jh lr ls dt translated">ES6之前的JavaScript范围</h1><p id="5948" class="pw-post-body-paragraph jv jw hu jx b jy lt iv ka kb lu iy kd ke lv kg kh ki lw kk kl km lx ko kp kq hn dt translated">在ES6之前，变量的最小作用域单位是函数。换句话说，变量的范围可以是最近的包含函数，也可以是全局范围。</p><p id="c2b5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">使用<em class="ly">变量</em>的示例:</p><pre class="jk jl jm jn fq kr ks kt ku aw kv dt"><span id="8765" class="kw kx hu ks b fv ky kz l la lb">var x = "hello world"; // scope of x: global<br/>function foo() {<br/>  var a = 1;  // scope of a: foo<br/>  if(a &gt; 0) {<br/>    var b = 3; // scope of b: foo<br/>  }<br/>  {<br/>    var e = 10; // scope of e: foo<br/>  }<br/>  while(a &lt; 2) {<br/>    var d = 5; // scope of d: foo<br/>  }<br/>}</span></pre><h1 id="5a45" class="lc kx hu bd ld le lf lg lh li lj lk ll ja lm jb ln jd lo je lp jg lq jh lr ls dt translated">const和let关键字以及块范围的引入</h1><p id="3b83" class="pw-post-body-paragraph jv jw hu jx b jy lt iv ka kb lu iy kd ke lv kg kh ki lw kk kl km lx ko kp kq hn dt translated">自从引入了<em class="ly"> const </em>和<em class="ly"> let </em>关键字后，变量可以拥有的最小范围单位现在是<em class="ly">块范围。</em>事实上，<em class="ly"> const </em>和<em class="ly"> let </em>在作用域上的行为完全相同:如果变量是用<em class="ly"> const </em>或<em class="ly"> let </em>声明的，那么变量可以存在的最小作用域单位就是一个由花括号{}包围的代码块。</p><p id="6a37" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">前一个带有<em class="ly">的例子让:</em></p><pre class="jk jl jm jn fq kr ks kt ku aw kv dt"><span id="6cce" class="kw kx hu ks b fv ky kz l la lb">let x = "hello world"; // scope of x: global<br/>function foo() {<br/>  let a = 1;  // scope of a: foo<br/>  if(a &gt; 0) {<br/>    let b = 3; // scope of b: if statement<br/>  }<br/>  {<br/>    let e = 10; // scope of e: surrounding block<br/>  }<br/>  while(a &lt; 2) {<br/>    let d = 5; // scope of d: while loop<br/>  }<br/>}</span></pre><p id="9814" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">使用<em class="ly">常量</em>:</p><pre class="jk jl jm jn fq kr ks kt ku aw kv dt"><span id="557e" class="kw kx hu ks b fv ky kz l la lb">const x = "hello world"; // scope of x: global<br/>function foo() {<br/>  const a = 1;  // scope of a: foo<br/>  if(a &gt; 0) {<br/>    const b = 3; // scope of b: if statement<br/>  }<br/>  {<br/>    const e = 10; // scope of e: surrounding block<br/>  }<br/>  while(a &lt; 2) {<br/>    const d = 5; // scope of d: while loop<br/>  }<br/>}</span></pre><h1 id="d220" class="lc kx hu bd ld le lf lg lh li lj lk ll ja lm jb ln jd lo je lp jg lq jh lr ls dt translated">一个美丽的例子</h1><h2 id="14a6" class="kw kx hu bd ld lz ma mb lh mc md me ll ke mf mg ln ki mh mi lp km mj mk lr ml dt translated">带var</h2><pre class="jk jl jm jn fq kr ks kt ku aw kv dt"><span id="2c27" class="kw kx hu ks b fv ky kz l la lb">for(var i=0; i&lt;3; i++){<br/>      setTimeout( function foo() { console.log(i) }, 100);<br/>}</span></pre><p id="40b7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这是一个for循环，变量<em class="ly"> i </em>从0迭代到2。在每次迭代中，用回调函数调用setTimeout，该函数在100毫秒后输出<em class="ly"> i </em>的值。</p><p id="c1fe" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">虽然我们很自然地期望这个输出:</p><pre class="jk jl jm jn fq kr ks kt ku aw kv dt"><span id="3f87" class="kw kx hu ks b fv ky kz l la lb">0<br/>1<br/>2</span></pre><p id="0133" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">，运行这段代码会奇怪地输出:</p><pre class="jk jl jm jn fq kr ks kt ku aw kv dt"><span id="9e9c" class="kw kx hu ks b fv ky kz l la lb">3<br/>3<br/>3</span></pre><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mm mn l"/></div></figure><h2 id="4dc3" class="kw kx hu bd ld lz ma mb lh mc md me ll ke mf mg ln ki mh mi lp km mj mk lr ml dt translated">刚刚发生了什么？</h2><p id="07b0" class="pw-post-body-paragraph jv jw hu jx b jy lt iv ka kb lu iy kd ke lv kg kh ki lw kk kl km lx ko kp kq hn dt translated">为了理解刚才发生了什么，我们可以分别表示循环的每一次迭代，并在执行迭代之前标记<em class="ly"> i </em>的值:</p><p id="f931" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">迭代#1</p><pre class="jk jl jm jn fq kr ks kt ku aw kv dt"><span id="643b" class="kw kx hu ks b fv ky kz l la lb">{ // i = 0<br/> <br/>      setTimeout( function foo() { console.log(i) }, 100); <br/>}</span></pre><p id="11df" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">步骤1-100毫秒后，引擎已经完成了循环的执行，现在全局作用域中的<em class="ly"> i </em>是3。然后，引擎继续执行回调函数foo中的代码。</p><p id="2905" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">步骤2-引擎查看是否在函数foo中声明了<em class="ly"> i </em>,但没有找到。</p><p id="92c3" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">步骤3-引擎进行查找，查看是否在迭代的包含块中声明了<em class="ly">I</em>with<strong class="jx hv">let</strong>或<strong class="jx hv"> const </strong>，但没有找到。</p><p id="9b3d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">步骤4-引擎进行查找，看看<em class="ly"> i </em>是否在全局范围内声明，并发现它是3。</p><p id="c147" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">步骤5-因此输出将是3</p><p id="be05" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">迭代#2</p><pre class="jk jl jm jn fq kr ks kt ku aw kv dt"><span id="bc46" class="kw kx hu ks b fv ky kz l la lb">{ // i = 1<br/> <br/>      setTimeout( function foo() { console.log(i) }, 100); <br/>}</span></pre><p id="c0f3" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">引擎重复上一次迭代中解释的5个步骤，输出为3。</p><p id="eecb" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">迭代#3</p><pre class="jk jl jm jn fq kr ks kt ku aw kv dt"><span id="1472" class="kw kx hu ks b fv ky kz l la lb">{ // i = 2<br/> <br/>      setTimeout( function foo() { console.log(i) }, 100); <br/>}</span></pre><p id="3f25" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">引擎重复前面迭代中解释的5个步骤，输出为3。</p><h2 id="8634" class="kw kx hu bd ld lz ma mb lh mc md me ll ke mf mg ln ki mh mi lp km mj mk lr ml dt translated">同样的例子有<em class="mo">让</em></h2><p id="8134" class="pw-post-body-paragraph jv jw hu jx b jy lt iv ka kb lu iy kd ke lv kg kh ki lw kk kl km lx ko kp kq hn dt translated">现在让我们看一个同样的例子，用<em class="ly">让</em>关键字。</p><pre class="jk jl jm jn fq kr ks kt ku aw kv dt"><span id="d03b" class="kw kx hu ks b fv ky kz l la lb">for(let i=0; i&lt;3; i++){<br/>      setTimeout( function foo() { console.log(i) }, 100);<br/>}</span></pre><p id="3790" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">执行此代码会产生以下输出:</p><pre class="jk jl jm jn fq kr ks kt ku aw kv dt"><span id="cfa3" class="kw kx hu ks b fv ky kz l la lb">0<br/>1<br/>2</span></pre><p id="9022" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">为了理解为什么，让我们以同样的方式跟踪执行:</p><p id="82b3" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">迭代#1</p><pre class="jk jl jm jn fq kr ks kt ku aw kv dt"><span id="f1d6" class="kw kx hu ks b fv ky kz l la lb">{ // i = 0<br/> <br/>      setTimeout( function foo() { console.log(i) }, 100); <br/>}</span></pre><p id="2a12" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">步骤1-100毫秒后，引擎已经完成了循环的执行，现在全局范围内的<em class="ly"> i </em>是3。然后，引擎继续执行回调函数foo中的代码。</p><p id="8f6c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">步骤2-引擎查看是否在函数foo中声明了<em class="ly"> i </em>，但没有找到。</p><p id="8356" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">步骤3-引擎进行查找，查看是否在迭代的包含块内声明了<em class="ly"> i </em>和<strong class="jx hv"> let </strong>或<strong class="jx hv"> const </strong>，并且发现它等于0。</p><p id="02e4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">步骤4-因此输出将为0。</p><p id="ab72" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">迭代#2</p><pre class="jk jl jm jn fq kr ks kt ku aw kv dt"><span id="151b" class="kw kx hu ks b fv ky kz l la lb">{ // i = 1<br/> <br/>      setTimeout( function foo() { console.log(i) }, 100); <br/>}</span></pre><p id="e9b9" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">引擎重复前一次迭代中的4个步骤，输出为1。</p><p id="03ea" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">迭代#3</p><pre class="jk jl jm jn fq kr ks kt ku aw kv dt"><span id="84e7" class="kw kx hu ks b fv ky kz l la lb">{ // i = 2<br/> <br/>      setTimeout( function foo() { console.log(i) }, 100); <br/>}</span></pre><p id="e52b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">引擎重复前面迭代中的4个步骤，输出为2。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mp mn l"/></div></figure><h1 id="23c8" class="lc kx hu bd ld le lf lg lh li lj lk ll ja lm jb ln jd lo je lp jg lq jh lr ls dt translated">最后的想法</h1><p id="add1" class="pw-post-body-paragraph jv jw hu jx b jy lt iv ka kb lu iy kd ke lv kg kh ki lw kk kl km lx ko kp kq hn dt translated">在学习任何新的编程语言时，范围解析无疑是一个需要掌握的概念。尽管人们看不到它的直接用途，但理解范围解析和ES6带来的变化在以下方面非常有帮助:</p><ul class=""><li id="78ac" class="mq mr hu jx b jy jz kb kc ke ms ki mt km mu kq mv mw mx my dt translated">通过避免由于不理解范围而导致的不必要的错误来提高效率。</li><li id="13ed" class="mq mr hu jx b jy mz kb na ke nb ki nc km nd kq mv mw mx my dt translated">更快地调试代码，并准确地知道在哪里进行调查。</li><li id="6470" class="mq mr hu jx b jy mz kb na ke nb ki nc km nd kq mv mw mx my dt translated">提高代码质量。</li></ul></div></div>    
</body>
</html>