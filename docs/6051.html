<html>
<head>
<title>How to better build your first chatbot, in under 12 minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在12分钟内更好地构建你的第一个聊天机器人</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-better-build-your-first-chatbot-in-under-7-minutes-b18a1c6891fd?source=collection_archive---------7-----------------------#2017-08-31">https://medium.com/hackernoon/how-to-better-build-your-first-chatbot-in-under-7-minutes-b18a1c6891fd?source=collection_archive---------7-----------------------#2017-08-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/0a5e69e7f892a7da796948227fd51865.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5zQ_G4mZhB-4q-V9PhI0xQ.jpeg"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Building a chatbot is actually building a conversation between two or more people</figcaption></figure><div class=""/><p id="a6ce" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji ik">跳过教程，随意从我的</strong> <a class="ae ke" href="https://github.com/assafelovic/facebook_messenger_bot" rel="noopener ugc nofollow" target="_blank"> <strong class="ji ik"> Github repo这里</strong> </a> <strong class="ji ik">下载源代码。</strong></p><p id="dabe" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">关于如何构建一个基本的聊天机器人，有很多很棒的教程供初学者使用。然而，这些教程中的大部分描述了无状态聊天机器人的实现。</p><p id="5136" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这意味着，在正在进行的对话中，不会保存关于用户状态的信息。例如，如果机器人问“你在哪里？”而用户回复“旧金山”，机器人就没有办法把问题和用户的回复联系起来。</p><p id="0025" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">因为你正在构建一个聊天机器人，你实际上构建的是两个或更多人之间的对话。其中一个恰好是你的机器人。就像在任何对话中一样，你的机器人应该知道如何回复信息，并理解什么时候有人回复他的信息。为此，您必须保存过去消息的历史记录和已定义的对话用户状态。</p><p id="4587" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在我看来，保存用户在对话中的状态对于任何基本的聊天机器人来说都是至关重要的。它允许聊天机器人以自然的流程与用户交流，并获得基本到高级功能的必要信息，否则这是不可能的。</p><p id="57d6" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这就是为什么我决定写这篇教程，它解释了如何构建一个基本的有状态Facebook Messenger bot，它不需要任何先前的chatbot开发经验。</p><h1 id="3c9a" class="kf kg ij bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">入门指南</h1><p id="1239" class="pw-post-body-paragraph jg jh ij ji b jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz lh kb kc kd hn dt translated">首先，你需要一个脸书开发者账户，可以在这里找到。</p><p id="6545" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">其次，按照创建脸书页面的流程开始，通过点击<a class="ae ke" href="https://developers.facebook.com/docs/messenger-platform/quickstart" rel="noopener ugc nofollow" target="_blank">此处设置一个“网页挂钩”(直到第5步)。</a>注意:你应该写下你在教程中提供给网络钩子的验证码。最后，一旦您建立并运行了一个脸书页面，查找页面令牌，并发送一个POST请求，内容如下:</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="1c04" class="lr kg ij ln b fv ls lt l lu lv">https://graph.facebook.com/v2.6/me/subscribed_apps?access_token=&lt;TOKEN_GOES_HERE&gt;</span></pre><p id="d98c" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">您应该得到一个响应“真”,这意味着您已经用提供的API同步了您的脸书页面。</p><p id="b0fb" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">最后，请熟悉一下<a class="ae ke" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>和<a class="ae ke" href="https://docs.mongodb.com/manual/installation/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>的基础知识。另外，你要了解ES6的写作基础。</p><p id="e94f" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在让我们为您创建第一个脸书信使聊天机器人！</p><h1 id="a922" class="kf kg ij bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">脸书API结构化消息</h1><p id="8dd9" class="pw-post-body-paragraph jg jh ij ji b jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz lh kb kc kd hn dt translated">重要的事情先来。了解并学习脸书API的基本概念— <a class="ae ke" href="https://developers.facebook.com/docs/messenger-platform/send-api-reference" rel="noopener ugc nofollow" target="_blank">点击此处</a>。让我们看一个例子:</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="f7bd" class="lr kg ij ln b fv ls lt l lu lv">welcome_message: {<br/>   attachment: {<br/>      type: "template",<br/>      payload: {<br/>         template_type: "button",<br/>         text: "Hello and welcome to your first bot. Would you like to get see our products?",<br/>         buttons: [<br/>            {<br/>               type: "postback",<br/>               title: "Yes",<br/>               payload: "get_options"<br/>            },<br/>            {<br/>               type: "postback",<br/>               title: "No",<br/>               payload: "no_options"<br/>            }<br/>         ]<br/>      }<br/>   }<br/>}</span></pre><p id="8a6a" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在上面的例子中，您可以看到，对于发送到脸书的每条消息，我们需要声明消息的类型，在本例中，它是一个模板(对于基本文本，文本就足够了)。此外，我们声明模板的类型(在本例中是按钮)和按钮本身。对于每个按钮，我们需要声明按钮标题、类型和有效载荷。按钮类型是，因此我们将知道如何处理按钮点击，有效负载是，因此我们可以识别用户点击了哪个按钮(源代码中描述了进一步的示例)。</p><h1 id="595f" class="kf kg ij bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">服务器端</h1><p id="6412" class="pw-post-body-paragraph jg jh ij ji b jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz lh kb kc kd hn dt translated">服务器端的基本和必需实现是为Messenger webhook设置一个GET和POST处理程序。GET处理程序用于在应用url webhook时进行脸书验证，应该如下所示:</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="13c9" class="lr kg ij ln b fv ls lt l lu lv"><strong class="ln ik">function </strong>facebookVerification(req, res) {<br/>    res.send(req.query['hub.challenge']);<br/>}</span></pre><p id="fc4e" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">注意:上面的WEBHOOK_TOKEN将被设置为您在初始化WEBHOOK时声明的那样。脸书以‘我的声音是我的密码验证我’为例。您可以保持原样并更新源代码。</p><p id="7e78" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">第二个也是最重要的方法是帖子。Facebook Messenger将发送到您的bot页面的每个ICM(传入消息)通过POST发送到您在开发者门户中声明的url。该方法应该处理所有ICM，无论是通过用户点击还是通过自由文本到达的ICM。请注意，你可以添加更多的<a class="ae ke" href="https://developers.facebook.com/docs/messenger-platform/send-api-reference/templates" rel="noopener ugc nofollow" target="_blank">模板</a>。我将描述在这种情况下使用的三种方法:</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="fc0d" class="lr kg ij ln b fv ls lt l lu lv">// 0<br/>app.post('/webhook/', messengerListener);</span><span id="ede6" class="lr kg ij ln b fv lw lt l lu lv">// 1<br/><strong class="ln ik">function </strong>messengerListener(req, res) {<br/>    <strong class="ln ik">let </strong>messaging_events = req.body.entry[0].messaging;<br/>    <strong class="ln ik">for </strong>(<strong class="ln ik">let </strong>messagingItem <strong class="ln ik">of </strong>messaging_events) {<br/>        <strong class="ln ik">let </strong>user_id = messagingItem.sender.id;<br/>        getUser(user_id, messagingItem, parseICM);<br/>    }<br/>    res.sendStatus(200);<br/>}</span><span id="ed3b" class="lr kg ij ln b fv lw lt l lu lv">// 2<strong class="ln ik"><br/>function </strong>getUser(user_id, incoming_message, callback) {<br/>    User.findById(user_id, <strong class="ln ik">function </strong>(err, user_object) {<br/>        callback(user_id, incoming_message, user_object);<br/>    });<br/>}</span><span id="4a52" class="lr kg ij ln b fv lw lt l lu lv">// 3<br/><strong class="ln ik">function </strong>parseICM(user_id, message_item, user_object) {<br/>   <strong class="ln ik">var </strong>current_state = "welcome_message";<br/>   <strong class="ln ik">if </strong>(message_item.message &amp;&amp; message_item.message.text) {<br/>      fb_api.sendFacebookGenericMsg(user_id, message_templates.templates[current_state]);<br/>   }<br/>   user_models.set(user_id, {current_state: ""});<br/>}</span></pre><p id="ca17" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">第一步(注释)是监听POST请求，并将它们转发给一个名为<strong class="ji ik"> messengerListener </strong>的方法(方法1)。然后，这个方法从POST主体中提取相关信息，比如消息项(由用户惟一id、消息文本等组成)，并将内容转发给一个名为<strong class="ji ik"> getUser </strong>的方法(方法2)。</p><p id="178c" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">方法<strong class="ji ik"> getUser </strong>(方法2)尝试从DB中检索具有给定惟一id的用户。如果找不到用户，则返回null。最后，用户查询结果被传递给一个回调函数，在我们的例子中是parseICM(方法3)。</p><p id="432c" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji ik"> parseICM </strong>方法负责根据用户的ICM(传入消息)和当前状态发送OGM(传出消息)。在上面的例子中，默认状态是“welcome_message”。该方法首先对ICM类型进行分类，它可以是文本消息，也可以是点击消息(当用户点击bot提供的按钮时)。根据ICM和用户的状态，发送回相关的响应消息。上面的代码中声明了一些额外的方法，我就不解释了，因为它们基本上是不言自明的，可以在这篇文章顶部(或结尾)提供的源代码中找到它们的完整内容。请随意问我关于服务器端的任何方法和一般流程的任何问题。</p><p id="5347" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">最后，为了向最终用户发回一个响应，您需要发送一个POST请求，该请求带有如上所述的消息模板，并且具有以下结构:</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="d8af" class="lr kg ij ln b fv ls lt l lu lv"><strong class="ln ik">function </strong>sendFacebookGenericMsg(user_id, message_template) {<br/>    request({<br/>        url: 'https://graph.facebook.com/v2.6/me/messages',<br/>        qs: {access_token: FB_TOKEN},<br/>        method: 'POST',<br/>        json: {<br/>            recipient: { id: user_id },<br/>            message: message_template<br/>        }<br/>    }, facebookCallbackResponse);<br/>}</span></pre><p id="a70c" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">上面显示的FB_TOKEN是您通过脸书开发者门户页面收到的页面令牌。</p><p id="41fe" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">恭喜你！你已经完成了你的第一个Facebook Messenger机器人。源代码是以这样一种方式构建的，你可以很容易地将其扩展为一个功能齐全的聊天机器人。</p><p id="1109" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">从这里开始，我强烈推荐阅读我写的一篇文章，关于如何通过三个简单的步骤<a class="ae ke" href="https://chatbotsmagazine.com/how-to-improve-your-chatbot-in-3-simple-steps-36f9d26d7f2f" rel="noopener ugc nofollow" target="_blank"><strong class="ji ik"/></a>来提高你的聊天机器人。本文包括如何实现自然语言理解和对话流架构设计的简单方法。</p><p id="0152" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">要查看完整的项目源代码，<a class="ae ke" href="https://github.com/assafelovic/facebook_messenger_bot" rel="noopener ugc nofollow" target="_blank"> <strong class="ji ik">点击这里</strong> </a> <strong class="ji ik">！请随意提问，我会尽快回答你。</strong></p></div></div>    
</body>
</html>