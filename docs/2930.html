<html>
<head>
<title>SwiftyWebRTC — RTCClient using WebRTC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftyWebRTC —使用WebRTC的RTC客户端</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/swiftywebrtc-789936b0e39b?source=collection_archive---------3-----------------------#2017-03-01">https://medium.com/hackernoon/swiftywebrtc-789936b0e39b?source=collection_archive---------3-----------------------#2017-03-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="4c00" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">如何使用WebRTC框架进行视频/音频通话</h2></div><p id="df90" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最近我要求在一个ios应用程序中启用视频通话，现在很多应用程序都这样做了，对吧。<br/>我们都在iOS应用中使用WebRTC进行客户端到客户端的视频对话。WebRTC是一个开源项目(libjingle_peerConnection ),由<a class="ae kf" href="https://hackernoon.com/tagged/google" rel="noopener ugc nofollow" target="_blank">谷歌</a>维护，为iOS和Android提供高级API实现。框架可以像这里的<a class="ae kf" href="https://webrtc.org/native-code/ios/" rel="noopener ugc nofollow" target="_blank">所描述的那样构建，或者你可以下载许多开源项目提供的预构建的二进制文件。</a></p><p id="016a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在开始学习本教程之前，我们假设您已经了解了WebRTC的概念和API。如果没有，可以在这里  <em class="kg">勾选</em> <a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API" rel="noopener ugc nofollow" target="_blank"> <em class="kg">。</em></a></p><p id="7710" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个博客基本上是让<a class="ae kf" href="https://hackernoon.com/tagged/webrtc" rel="noopener ugc nofollow" target="_blank"> WebRTC </a>在我们基于swift的应用中工作。在ios项目中，有许多带有预构建库和包装器的开源库。但是找不到一个用swift编写的、与swift3项目兼容的、有适当文档的好版本。它们要么与carthage和swift不兼容，要么没有更新以使用新的WebRTC api。所以我决定做一个我自己的，用更少的文档，这不是那么直接的过程..<br/>将一步一步地解释实现这一点的过程。</p><p id="706c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于我的工作，我已经构建了WebRTC框架，如这里的<a class="ae kf" href="https://webrtc.org/native-code/ios/" rel="noopener ugc nofollow" target="_blank">中所解释的</a>。<br/>现在，这项工作需要我们制作一个包装器来设置RTCClient并与我们的项目代码集成。</p><p id="c879" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们要做的总结如下:</p><blockquote class="kh ki kj"><p id="834b" class="jj jk kg jl b jm jn iv jo jp jq iy jr kk jt ju jv kl jx jy jz km kb kc kd ke hn dt translated">简言之:将成为连接发起者的对等体A将创建提议。然后，他们将使用所选的信号信道将该提议发送给对等体B。对等体B将从信号通道接收提议，并创建一个答案。然后，它们会沿着信号通道将此发送回对等体A。</p></blockquote><p id="854a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">很简单，对吧！</p><p id="ad70" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">现在一步一步地打破这个过程，然后用相关的代码执行每一步。</strong></p><ol class=""><li id="704e" class="kn ko hu jl b jm jn jp jq js kp jw kq ka kr ke ks kt ku kv dt translated">首先，我们将启动“RTCPeerConnectionFactory”</li></ol><pre class="kw kx ky kz fq la lb lc ld aw le dt"><span id="a8d5" class="lf lg hu lb b fv lh li l lj lk">RTCPeerConnectionFactory.initialize()</span><span id="e369" class="lf lg hu lb b fv ll li l lj lk">self.connectionFactory = RTCPeerConnectionFactory() // save the instance for further uses</span></pre><p id="2f54" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">2.使用它创建一个“RTCPeerConnection”。</p><figure class="kw kx ky kz fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff lm"><img src="../Images/a68297b0c578b9eee4b7be15df6b20b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J_FS2V7m1lV17xWwPLHHAA.png"/></div></div></figure><p id="88ad" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh lu lv lw lb b">`iceServers</code>`是您提供的眩晕和回合服务器列表。要生成iceServer，您需要在RTCIceServer init方法中发送用户名、密码和url。</p><p id="306f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果您省略它，您将只生成内部网络主机候选，只要您在同一个网络上测试，这是没问题的。</p><p id="215a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">3.现在我们已经配置了连接，让我们通过添加一个本地流来启动连接。</p><figure class="kw kx ky kz fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff lx"><img src="../Images/f8f57d7585629ccb3ffcd28ec854d252.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GrUVFF6RBH46fvPneaKtow.png"/></div></div><figcaption class="ly lz fg fe ff ma mb bd b be z ek">Start Connection</figcaption></figure><p id="1af1" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一次又一次地添加videoTrack会增加延迟，所以技巧是让它成为一个静态变量，只在连接开始或结束时添加和删除它。</p><figure class="kw kx ky kz fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff mc"><img src="../Images/f7b43a035597002b8e0e1c63f4cda305.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dxdXy0vBXxPnnuVv1Vq2Aw.png"/></div></div></figure><p id="71cd" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">4.建立连接和本地流后，开始通话的时间到了。对等方A将通过创建报价来开始通话。</p><figure class="kw kx ky kz fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff md"><img src="../Images/29ba35ebb6741536694e128181b19bab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QaA5Q8K6XDdChhbt-JEgEw.png"/></div></div></figure><blockquote class="kh ki kj"><p id="6d96" class="jj jk kg jl b jm jn iv jo jp jq iy jr kk jt ju jv kl jx jy jz km kb kc kd ke hn dt translated">以下是我们将使用的不同约束</p></blockquote><figure class="kw kx ky kz fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff me"><img src="../Images/15ee7245bab7a7369499f2a8a8e3423f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jR4p4ACslN1inMwxwCbRpw.png"/></div></div></figure><p id="5caa" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">5.对等体A应该将该提议设置为<em class="kg">本地描述</em>(即连接的本地端的描述)，并使用信令服务器将该提议发送给呼叫的预期接收者。</p><figure class="kw kx ky kz fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff mf"><img src="../Images/4338034bf16a9d125e91679ea18c72de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d1f5-saCnBpRIgNDUrZj4Q.png"/></div></div></figure><p id="918f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">6.对等体B将从信令服务器接收该提议，并将其<em class="kg">远程描述设置为提议</em>(连接另一端的描述)。对等体B然后创建一个答案，并通过信令服务器再次发送它。</p><figure class="kw kx ky kz fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff mg"><img src="../Images/bb41fa00b825fbf54fbb3db338bbc7b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*De1zosl908bMiloSmsMV5A.png"/></div></div></figure><p id="5df6" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">7.对等体B将设置sdp generated作为其本地描述。对等体B现在知道了连接两端的配置。生成的Sdp被发送到信令服务器，作为对呼叫者的回答。</p><p id="5d7c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">8.对等体A接收到应答，将其设置为remoteDescription。它现在知道了双方的配置。媒体开始按配置流动。</p><figure class="kw kx ky kz fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff mg"><img src="../Images/a8d88980fbc6501e950be107d46fd353.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DvH9rKOkanoWNJrAelUrew.png"/></div></div></figure><p id="4ad2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您可能想知道我们在哪里将remoteStream设置为“remoteVideoTrack”来呈现媒体。</p><p id="0068" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">9.从添加的流中获取RemoteVideoTrack以呈现远程媒体。</p><figure class="kw kx ky kz fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff mh"><img src="../Images/93675575ceb00a5d96f48be6ba4e41e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nQhnnGx-cBLSOqAo9Ja5sA.png"/></div></div></figure><p id="521c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，我们已经为两个对等体设置了两个sdp..还有一件更重要的事情我们还没有处理，即<strong class="jl hv"> IceCandidate </strong></p><p id="5d0c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">10.可以使用“RTCPeerConnectionDelegate”接收生成的iceCandidate，需要将它发送到其他对等方以保持数据流。</p><figure class="kw kx ky kz fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff mi"><img src="../Images/2e0e6612b2746583edd3c9fc45c9a545.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dwwd5Fafj-VyY26P0GGMmA.png"/></div></div></figure><p id="d392" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">11.信令服务器用于发送/接收iceCandidate信息。<br/>接收到的候选项被添加到对等连接，如下所示。</p><figure class="kw kx ky kz fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff mj"><img src="../Images/9fc1d8531c4d24f36f63596ef4ebf265.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q96eazLvlVIaE34_OLh0yQ.png"/></div></div></figure><figure class="kw kx ky kz fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff mk"><img src="../Images/00cd89a84f4f42d01167451438ca2660.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_ocDIttyfiCVOQv8N8rnLg.png"/></div></div></figure><p id="8c4e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">就这样，我们完成了处理webRTC api的工作，以便在我们支持swift的应用程序中实现视频通话。</p><p id="5b8d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">包装器(“RTCClient”)和WebRTC构建的框架可以在“<a class="ae kf" href="https://github.com/Ankit-Aggarwal/SwiftyWebRTC" rel="noopener ugc nofollow" target="_blank">https://github.com/Ankit-Aggarwal/SwiftyWebRTC</a>”的我的报告中找到</p><p id="a71f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">可以使用carthage进行添加，如下所示:</p><pre class="kw kx ky kz fq la lb lc ld aw le dt"><span id="cecb" class="lf lg hu lb b fv lh li l lj lk">github "Ankit-Aggarwal/SwiftyWebRTC"</span></pre><p id="d265" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果您有任何问题，或者想要对代码进行一些添加/修改，或者您有任何反馈，请在下面的评论中提出。</p><p id="acea" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">感谢阅读！</strong></p><figure class="kw kx ky kz fq ln"><div class="bz el l di"><div class="ml mm l"/></div></figure></div></div>    
</body>
</html>