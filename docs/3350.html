<html>
<head>
<title>Server-side Rendering of Deep Links with React and .NET Core</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React和的深层链接的服务器端呈现。网络核心</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/server-side-rendering-of-deep-links-with-react-and-net-core-882830ca663?source=collection_archive---------6-----------------------#2017-03-28">https://medium.com/hackernoon/server-side-rendering-of-deep-links-with-react-and-net-core-882830ca663?source=collection_archive---------6-----------------------#2017-03-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="e497" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">关于使用dotNetify-React做React app跨平台通用/同构路由。NET Core后端——没什么大惊小怪的。</em></p><blockquote class="jq jr js"><p id="d183" class="ir is jp it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt translated"><strong class="it hv">(2020年5月24日):自最初发布以来，技术和代码已经进行了重大更新。</strong> <a class="ae jw" href="https://github.com/dsuryd/dotNetify/tree/master/Demo/React/LazyLoadRouting" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">最新最棒的</strong> </a> <strong class="it hv">请看这个github回购。</strong></p></blockquote><p id="ff89" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">几周前，我发布了dotNetify-React 的<a class="ae jw" href="https://hackernoon.com/react-net-core-signalr-amazing-ea0a83e4357e" rel="noopener ugc nofollow" target="_blank">测试版，这是一个开源项目，它使得在. NET核心后端开发</a><a class="ae jw" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank"> React </a>应用变得非常简单。它附带了一个可选特性，即在后端的C#视图模型中声明SPA路由，这是为了那些希望保持其客户端组件没有路由问题的人。</p><p id="0c8f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">只要您将服务器设置为对于任何页面请求总是返回首页，这个客户端路由器就可以很好地处理深层链接。路由器将遍历路径以动态加载组件并解析嵌套路由，直到路径被完全路由。</p><p id="56c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，正如许多人指出的那样，客户端路由有一些缺点，比如更长的初始加载时间，没有内容的闪烁，以及对SEO不友好。然而，有了React，通用渲染有望消除这些问题，所以我急切地想知道它是否可以集成到这个路由器中，并且仍然保持简单易用。</p><p id="7c61" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是首先，让我先来概述一下客户端路由器是如何工作的。</p><h1 id="f3d2" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">客户端路由</h1><p id="033c" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">在dotNetify中，React根组件与用普通C#编写的后端视图模型配对。如果我们从一个有到组件<code class="eh la lb lc ld b">Page1</code>的路由的<code class="eh la lb lc ld b">Index</code>组件和一个普通的HTML文件<code class="eh la lb lc ld b">Page2</code>开始，下面是这些路由在视图模型中的定义:</p><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="8f45" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">路由API在<a class="ae jw" href="http://dotnetify.net/react/routing" rel="noopener ugc nofollow" target="_blank">项目的网站</a>中有记录，所以我不会在这里详述，但本质上路由信息是在类实例化期间构建的，被序列化，并作为React组件初始状态的一部分发送到客户端。下面是<code class="eh la lb lc ld b">Index</code>组件的样子:</p><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="c8b1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">React组件连接到后端后，路由状态将成为组件状态的一部分，并用于呈现<code class="eh la lb lc ld b">RouteLink</code>组件，这些组件只是锚标签的薄包装。当用户通过单击链接进行导航时，路由器在后台工作，从服务器加载组件(如果尚未捆绑)或HTML文件，将其挂载到目标DOM节点，并更新浏览器历史状态，以便浏览器的后退和前进按钮也能工作。</p><p id="9cb8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以继续在与<code class="eh la lb lc ld b">Page1</code>相关联的视图模型中定义嵌套路由。路由器支持像<code class="eh la lb lc ld b">/Page1(/:itemId)</code>这样的模式，并且有机制将匹配的URL传递给视图模型，这样它就可以生成正确的视图。如前所述，只要服务器为每个页面请求返回首页<code class="eh la lb lc ld b">index.html</code>，路由器就可以处理这些嵌套路由形成的深层链接。</p><p id="d2f3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们来看看如何将服务器端路由添加到这个组合中。</p><h1 id="5847" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">服务器端路由</h1><p id="89f9" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">假设客户端路由必须从根开始，一路向下呈现深层链接，那么从初始页面交付到最终页面呈现给用户之间总会有一个时间差。因此，主要目标是通过将初始页面作为最终页面来消除延迟，完全由服务器呈现并随客户端脚本一起发送，然后客户端脚本将无缝地接管使用客户端路由进行其余的交互。</p><p id="e438" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一个目标是使它对代码库的干扰最小化；我们不需要对React组件进行大量的修改，也不需要对它们施加太多的限制，就能让它们支持服务器渲染。因为否则，它很可能会挫败<a class="ae jw" rel="noopener" href="/capital-one-developers/why-everyone-is-talking-about-isomorphic-universal-javascript-and-why-it-matters-38c07c87905">通用/同构渲染</a>的目的。</p><p id="13fd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">立即出现了几个问题:</p><ul class=""><li id="65f6" class="ll lm hu it b iu iv iy iz jc ln jg lo jk lp jo lq lr ls lt dt translated">如何在ASP.NET核心服务器上渲染我们的React应用？</li><li id="f139" class="ll lm hu it b iu lu iy lv jc lw jg lx jk ly jo lq lr ls lt dt translated">如何获取渲染app所必需的初始状态？</li><li id="2d2e" class="ll lm hu it b iu lu iy lv jc lw jg lx jk ly jo lq lr ls lt dt translated">如何设置服务器匹配客户端渲染环境？</li><li id="597c" class="ll lm hu it b iu lu iy lv jc lw jg lx jk ly jo lq lr ls lt dt translated">如何包含通常由客户端路由器异步加载的嵌套组件？</li><li id="82e7" class="ll lm hu it b iu lu iy lv jc lw jg lx jk ly jo lq lr ls lt dt translated">如何向组件提供初始状态？</li><li id="d391" class="ll lm hu it b iu lu iy lv jc lw jg lx jk ly jo lq lr ls lt dt translated">如何防止React在客户端再次渲染所有内容？</li></ul><h2 id="ce7d" class="lz jy hu bd jz ma mb mc kd md me mf kh jc mg mh kl jg mi mj kp jk mk ml kt mm dt translated">ASP.NET核心上的Javascript渲染</h2><p id="aecb" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">如果不是微软今年早些时候发布的一组名为<a class="ae jw" href="https://blogs.msdn.microsoft.com/webdev/2017/02/14/building-single-page-applications-on-asp-net-core-with-javascriptservices/" rel="noopener ugc nofollow" target="_blank"> JavascriptServices </a>的库，找到一种在. NET服务器上呈现<a class="ae jw" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> Javascript </a>的方法将会是一个大问题。其中一个名为<code class="eh la lb lc ld b">NodeServices</code>的库为任何。NET代码在Node.js实例上运行任意Javascript。正是我们需要的！</p><p id="863d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有了适当的方法，我们可以创建一个Javascript文件，命名为<code class="eh la lb lc ld b">app.server.js,</code>，它获取主页面<code class="eh la lb lc ld b">index.html</code>，并在其上呈现React根组件。收到页面请求后，我们的。NET代码会将请求URL路径和组件的初始状态传递给文件中的函数，并获取响应的HTML字符串:</p><pre class="le lf lg lh fq mn ld mo mp aw mq dt"><span id="d46e" class="lz jy hu ld b fv mr ms l mt mu">app.Run(async (context) =&gt;<br/>{<br/>   ...<br/>   var result = await <strong class="ld hv">nodeServices.InvokeAsync</strong>&lt;string&gt;(<br/>      "./app.server.js", requestPath, initialStates );<br/>   await context.Response.WriteAsync(result);<br/>}</span></pre><h2 id="c5eb" class="lz jy hu bd jz ma mb mc kd md me mf kh jc mg mh kl jg mi mj kp jk mk ml kt mm dt translated">获取初始状态</h2><p id="c6f0" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">如果没有遍历链接路径并收集组件呈现最终页面所需的所有状态的能力，深度链接的服务器呈现就不会工作。幸运的是，dotNetify将所有路由信息和组件状态保存在后端的方法很好地解决了这个问题。</p><p id="689e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过使用提供的API，我们可以编写。NET代码跟踪路径，解析路径中的所有组件，最后将所有状态作为序列化的JSON对象返回，准备作为参数传递给上面的服务器端呈现函数。</p><h2 id="2fc6" class="lz jy hu bd jz ma mb mc kd md me mf kh jc mg mh kl jg mi mj kp jk mk ml kt mm dt translated">服务器端执行上下文</h2><p id="5314" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">下一个要解决的问题是在Node.js中设置执行上下文，以便React应用程序能够以与客户端相同的方式呈现。最明显的区别是Node中没有DOM，因此任何依赖于<code class="eh la lb lc ld b">window</code>或<code class="eh la lb lc ld b">document</code>的脚本都无法运行。</p><p id="ec0c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尽管React组件避免直接引用DOM是一个很好的做法，但实际上这可能过于严格。用假对象模仿或添加<code class="eh la lb lc ld b">undefined</code>类型检查是另一种选择，但会遇到问题，特别是当应用程序本身或它使用的任何第三方库将对它们做一些不平凡的事情时。</p><p id="f713" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我看来，最简单、侵入性最小的解决方案是使用模拟DOM的无头浏览器库。这种方法在自动化测试中已经很常见了。为此，我使用了一个流行的库jsDOM。警告是，模拟可能不会完美，在某些情况下我们仍然需要进行修改，性能可能是一个问题，这取决于库的优化程度。</p><h2 id="8c17" class="lz jy hu bd jz ma mb mc kd md me mf kh jc mg mh kl jg mi mj kp jk mk ml kt mm dt translated">服务器端模块</h2><p id="fba8" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">下一个挑战是确保所有导入的库模块在服务器上下文中都是可用的。使用客户端路由，所有需要的库都与WebPack捆绑到一个名为<code class="eh la lb lc ld b">bundle.js</code>的文件中，并使用脚本标签附加到HTML中。但是要记住，Node.js还不支持ES6模块，所以WebPack用来构建这个包的任何<code class="eh la lb lc ld b">import</code>都不能在那里工作。</p><p id="2eeb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了克服这一点，而不必用<code class="eh la lb lc ld b">require</code>替换所有的<code class="eh la lb lc ld b">import</code>调用，我更新了我的WebPack配置，将包输出到<code class="eh la lb lc ld b">window</code>范围内的一个全局变量中。这个变量将包含所有导入的模块，所以在Node.js中，我将<code class="eh la lb lc ld b">bundle.js</code>包含在jsDOM中作为要执行的脚本，然后将变量中的对象复制到<code class="eh la lb lc ld b">global</code>范围，连同<code class="eh la lb lc ld b">window</code>和<code class="eh la lb lc ld b">document</code>变量本身。</p><pre class="le lf lg lh fq mn ld mo mp aw mq dt"><span id="f149" class="lz jy hu ld b fv mr ms l mt mu">Object.assign(global, window.bundle);<br/>global.window = window;<br/>global.document = document;</span></pre><p id="7ad2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这确保了组件和任何其他Javascript都可以像在客户端一样访问对象。</p><h2 id="7098" class="lz jy hu bd jz ma mb mc kd md me mf kh jc mg mh kl jg mi mj kp jk mk ml kt mm dt translated">异步路由覆盖</h2><p id="5d53" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">如前所述，当客户端路由器遍历URL路径时，它检查当前组件的路由状态以寻找下一个要加载的组件，然后从服务器执行异步加载。这种行为显然必须在服务器端渲染中被覆盖，因此dotNetify提供了一个API钩子来拦截组件的URL，为Node.js更正其路径，并使用<code class="eh la lb lc ld b">require</code>将组件加载到<code class="eh la lb lc ld b">window</code>范围中。</p><pre class="le lf lg lh fq mn ld mo mp aw mq dt"><span id="3e44" class="lz jy hu ld b fv mr ms l mt mu">function(url) {<br/>   if (url.endsWith('.js')) {<br/>      url = "../wwwroot" + url;<br/>      Object.assign(window, require(url));<br/>   }<br/>}</span></pre><p id="38ee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这同样适用于加载普通的HTML文件。一旦深度链接被完全路由，一个内部事件将被引发，通过API钩子，我们提供一个回调来将<code class="eh la lb lc ld b">document.documentElement.innerHTML</code>返回到。NET代码作为对初始页面请求的响应。</p><h2 id="ce2a" class="lz jy hu bd jz ma mb mc kd md me mf kh jc mg mh kl jg mi mj kp jk mk ml kt mm dt translated">将初始状态传递给组件</h2><p id="fcc5" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">由传递的初始状态。NET代码到服务器函数被做成一个对象并添加到<code class="eh la lb lc ld b">window</code>作用域中。我们必须对使用这些状态的组件做一点小小的改动，以便它们在返回默认状态之前先找到自己的状态:</p><pre class="le lf lg lh fq mn ld mo mp aw mq dt"><span id="bf90" class="lz jy hu ld b fv mr ms l mt mu">var Index = React.createClass({<br/>   getInitialState() {<br/>      this.vm = dotnetify.react.connect("Index", this);<br/>      ...<br/><strong class="ld hv">      return dotnetify.react.router.ssrState("Index") || {};</strong>   <br/>},</span></pre><p id="09c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh la lb lc ld b">ssrState</code> API将试图通过已建立的命名约定找到初始状态，并防止在用户导航期间组件被重复安装时重复使用这些状态。</p><h2 id="274c" class="lz jy hu bd jz ma mb mc kd md me mf kh jc mg mh kl jg mi mj kp jk mk ml kt mm dt translated">防止客户端重新呈现</h2><p id="dae3" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">最后一个问题是如何防止React在浏览器上再次渲染所有内容。通常情况下，这已经由React在内部处理了，只有当DOM节点发生变化时，React才会进行自己的检查来更新DOM节点。不幸的是，当客户端路由器异步加载时，这种方式并不好用。目标DOM节点(将安装嵌套组件的地方)最初总是空的，因此React将清除服务器呈现的内容。</p><p id="386c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我已经查看了React APIs，但是没有什么会阻止初始呈现，所以我想到的解决方案是让呈现目标DOM节点的组件在呈现之前用服务器呈现的内容预先填充它。</p><p id="3821" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了简单起见，dotNetify提供了一个名为<code class="eh la lb lc ld b">RouteTarget</code>的组件来代替目标DOM节点。在安装之前，该组件将找到相同ID的现有DOM节点，将内部HTML抓取到其本地状态，并使用它来呈现自身，以便输出不会有所不同。</p><pre class="le lf lg lh fq mn ld mo mp aw mq dt"><span id="40a2" class="lz jy hu ld b fv mr ms l mt mu">render() {<br/>   return (<br/>      &lt;div&gt;<br/>         &lt;RouteLink ...&gt;Page 1&lt;/RouteLink&gt;<br/>         &lt;RouteLink ...&gt;Page 2&lt;/RouteLink&gt;<br/><strong class="ld hv">         &lt;RouteTarget id="Content" /&gt;</strong><br/>      &lt;/div&gt;<br/>   );<br/>}</span></pre><h1 id="6d6d" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">工作演示</h1><p id="d39e" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">尘埃落定后，这里是<code class="eh la lb lc ld b">app.server.js</code>的样子:</p><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="b899" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">ASP.NET核心代码称之为:</p><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="f496" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以从这个<a class="ae jw" href="https://github.com/dsuryd/dotNetify-react-template/tree/master/_archive/Routing" rel="noopener ugc nofollow" target="_blank"> github地址</a>克隆运行在Visual Studio 2017上的演示。为了与纯客户端渲染进行比较，在URL后面添加<code class="eh la lb lc ld b">?ssr-false</code>。</p><figure class="le lf lg lh fq li fe ff paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="fe ff mv"><img src="../Images/cdbaaad5d7c17743473b6fb755831a8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*twzk8Geqmw3n-ymiCc6m7w.gif"/></div></div></figure><p id="c4ec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个路由器库是npm上dotNetify-React分发包的一部分。请访问<a class="ae jw" href="http://dotnetify.net/react" rel="noopener ugc nofollow" target="_blank">项目的网站</a>了解安装、更多详情和其他现场演示。源代码在<a class="ae jw" href="https://github.com/dsuryd/dotNetify" rel="noopener ugc nofollow" target="_blank">项目的Github网站</a>上。</p><p id="1217" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它绝不是完美的，并且可能有一些它没有涵盖的用例。但希望这是一个好的开始；我愿意接受请求，即使你不使用它，你也可以从这篇文章中获得一些教育价值。下次见！</p><div class="le lf lg lh fq ab cb"><figure class="nc li nd ne nf ng nh paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nc li nd ne nf ng nh paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nc li nd ne nf ng nh paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="jq jr js"><p id="f922" class="ir is jp it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt translated"><a class="ae jw" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客们下午的开始。我们是这个家庭的一员。我们现在<a class="ae jw" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jw" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is jp it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jw" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jw" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="le lf lg lh fq li fe ff paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="fe ff ni"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="nj lk l"/></div></figure></div></div>    
</body>
</html>