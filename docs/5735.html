<html>
<head>
<title>Refs in React : All you need to know !</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的引用:您需要知道的一切！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/refs-in-react-all-you-need-to-know-fb9c9e2aeb81?source=collection_archive---------1-----------------------#2017-08-14">https://medium.com/hackernoon/refs-in-react-all-you-need-to-know-fb9c9e2aeb81?source=collection_archive---------1-----------------------#2017-08-14</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/1a0133bc8680a8a97ca24be84c355883.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sby1Jwafc8jkPSbCfAgTnw.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">borrowed from <a class="ae jg" href="https://i.ytimg.com/vi/TWzA2Ir1ZJc/maxresdefault.jpg" rel="noopener ugc nofollow" target="_blank">https://i.ytimg.com/vi/TWzA2Ir1ZJc/maxresdefault.jpg</a></figcaption></figure><p id="94d2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">昨天晚上，当我浏览一个流行的react库时，我发现了“refs ”,即使我知道它是如何工作的，我也不太相信我的理解，所以我决定更深入地研究它，并最终与你们分享我的想法。</p><p id="3226" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">根据react文档，引用用于获取对DOM(文档对象模型)节点或React应用程序中组件实例的引用，即引用将返回我们所引用的节点。让我们看一个例子。</p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kf"><img src="../Images/dfa6e26ab1cb06da80c92282ba4e9ca6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YESBXsE4q3_jZG8mYxueXg.png"/></div></div></figure><p id="0880" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在上面的例子中，为了获得bob所说的值，我使用了事件e的目标值。使用refs可以这样做</p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kk"><img src="../Images/e2424300b7b02d1b91d3841bcae1cc5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7klILKdvEazW6zvqCOBEWw.png"/></div></div></figure><p id="4f8c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">此外，我们可以在refs中传递一个回调函数，它可以用来做其他很酷的事情。在job上面使用带有回调的refs可以通过这种方式完成</p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kl"><img src="../Images/96eb6546e7df653c4903afaa36d25a3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFfiMvrTv4bNDf5fqbbP7A.png"/></div></div></figure><h1 id="8bc4" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">当你需要裁判而不是身份证的时候。</h1><p id="69a7" class="pw-post-body-paragraph jh ji hu jj b jk lk jm jn jo ll jq jr js lm ju jv jw ln jy jz ka lo kc kd ke hn dt translated">众所周知，ID对整个DOM树中的单个元素起作用，因此我们想改变焦点的背景色。有了身份证就会这样</p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lp"><img src="../Images/48a62760b8018b98e82dd512901801d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rSDtSpeDeWhVaj6QZrU3mw.png"/></div></div></figure><p id="c8a5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因为Bob在Tim之前，并且两者都有相同的ID，在其上运行后台操作代码，但是只有Bob对focus而不是Tim生气。如果我们使用引用，我们可以用一个特定的引用名替换id，我们应该做得很好。但是我建议使用这种用例的类，因为它更好，而且refs有它的警告，我们很快就会看到。</p><h1 id="85d7" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">当它返回一个DOM节点或组件的实例时。</h1><p id="b92e" class="pw-post-body-paragraph jh ji hu jj b jk lk jm jn jo ll jq jr js lm ju jv jw ln jy jz ka lo kc kd ke hn dt translated">如果ref指向一个标准组件(DOM节点，如<code class="eh lq lr ls lt b">input</code>、<code class="eh lq lr ls lt b">select</code>、<code class="eh lq lr ls lt b">div</code>等)，则检索该元素；你只需要叫<code class="eh lq lr ls lt b">this.refs.ref.</code></p><p id="17e4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果引用指向一个复合组件(一个你自己创建的定制组件)，你需要使用新的<code class="eh lq lr ls lt b">ReactDOM</code>模块，就像这样<code class="eh lq lr ls lt b">ReactDOM.findDOMNode(this.refs.ref).</code></p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lu"><img src="../Images/fb6a5e684b32cce054cb1eb0a4cf7172.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ZwLiwdEZiM4G6dVpT_PZg.png"/></div></div></figure><h1 id="ee8f" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">第一次设置<code class="eh lq lr ls lt b">ref</code>值是什么时候？</h1><p id="f7ea" class="pw-post-body-paragraph jh ji hu jj b jk lk jm jn jo ll jq jr js lm ju jv jw ln jy jz ka lo kc kd ke hn dt translated">随着<strong class="jj hv"> render() </strong>中的<strong class="jj hv"> </strong> react，生命周期方法也像</p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ca"><img src="../Images/dde341547ee58a7174f03bf3fea08893.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EsgBxOFlLpqekUAeoSBKBQ.png"/></div></div></figure><p id="b410" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，ref首先在第一个<code class="eh lq lr ls lt b">render()</code>之后，但在<code class="eh lq lr ls lt b">componentDidMount()</code>之前设置。</p><h1 id="7c3b" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">只有在必须的情况下才使用“ref ”,否则不使用……为什么？</h1><ul class=""><li id="7e56" class="lv lw hu jj b jk lk jo ll js lx jw ly ka lz ke ma mb mc md dt translated">它阻碍了Babel内嵌插件的优化工作。</li><li id="dd36" class="lv lw hu jj b jk me jo mf js mg jw mh ka mi ke ma mb mc md dt translated">使用refs有点偏离react的思维方式，即一旦状态改变，你就重新呈现依赖于该状态的所有UI组件。React将负责确保只更新DOM中正确的部分，使整个事情变得高效。您最终可能会以Jquery的方式使用refs，但这并不是我们的目标。</li></ul><h1 id="ebc1" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">何时使用参考文献？</h1><p id="ea95" class="pw-post-body-paragraph jh ji hu jj b jk lk jm jn jo ll jq jr js lm ju jv jw ln jy jz ka lo kc kd ke hn dt translated">根据react官方文件，</p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mj"><img src="../Images/dda4f91c875a32630e9ce751c106481a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9GHQFPbead2QCbRJgVysXA.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Official React Docs</figcaption></figure><h1 id="4b4f" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">最后，引用时的银弹！</h1><ul class=""><li id="6208" class="lv lw hu jj b jk lk jo ll js lx jw ly ka lz ke ma mb mc md dt translated">不要内联refs回调:我使用内联回调向您展示了为什么这样做不好</li></ul><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mk"><img src="../Images/5a2c6da8e42bdedc7e80536dd5570134.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*thw1ZzXF4VTRXO4WiY9umA.png"/></div></div></figure><p id="1c55" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">箭头和<code class="eh lq lr ls lt b">render()</code>中的<code class="eh lq lr ls lt b">bind</code>函数通过在每次重新渲染时在<strong class="jj hv">上创建一个新函数来提高性能。应该是这样做的</strong></p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ml"><img src="../Images/77294f775193d2f9fb161d6ae07edb94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FTkw-GSgPosbyguLBRD3yg.png"/></div></div></figure><p id="d672" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">此外，如果将<code class="eh lq lr ls lt b">ref</code>回调函数定义为内联函数，它将在更新过程中被调用两次，第一次是用<code class="eh lq lr ls lt b">null</code>，第二次是用DOM元素。React这样做是为了“清理”旧的ref并“设置”新的ref，以防上一个和下一个回调成为真正不同的函数。为了避免过时的引用(和内存泄漏)，清理是必要的。</p><ul class=""><li id="41f4" class="lv lw hu jj b jk jl jo jp js mm jw mn ka mo ke ma mb mc md dt translated">我还故意使用了<strong class="jj hv">字符串引用</strong>，这也不是一个好的做法。</li></ul><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/4cf769fee0897828f514c3b4ccea884d.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*zuk5dDNp3WrleKSZHcRJ-Q.png"/></div></figure><p id="11ae" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="mq">根据react官方文档，虽然字符串引用没有被弃用，但它们被认为是遗留的，并且很可能在将来的某个时候被弃用。回调引用是首选。</em></p><ul class=""><li id="7815" class="lv lw hu jj b jk jl jo jp js mm jw mn ka mo ke ma mb mc md dt translated">引用不应该用在功能组件上，因为它们没有实例。例子</li></ul><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mr"><img src="../Images/75c43e43dc0e3387e94b848d2cce03a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*me1ub80xs1y6FTGiw0nIQg.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">React Official Docs</figcaption></figure><p id="1026" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">由于MyFunctionalComponent没有实例，所以上面的代码不会像预期的那样工作。</p><p id="0811" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">但是</strong> <code class="eh lq lr ls lt b"><strong class="jj hv">ref</strong></code> <strong class="jj hv">属性将在函数组件</strong>内部工作，只要你引用一个DOM元素或者一个类组件:</p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ms"><img src="../Images/d36fbad71ab52b7b598c42a35cf99956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_k1Dj-n1dSJmG5CH_xJBtA.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">React Official Docs</figcaption></figure><p id="35f0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">希望你现在已经很好地理解了<strong class="jj hv"> refs </strong>以及它的使用案例和注意事项。如果你发现它有用，请与你周围的人分享。</p><p id="9d21" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">谢谢</p><p id="b731" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们继续在<a class="ae jg" href="https://twitter.com/solodynamo" rel="noopener ugc nofollow" target="_blank">推特</a> <strong class="jj hv">上的对话。</strong></p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="mt mu l"/></div></figure></div></div>    
</body>
</html>