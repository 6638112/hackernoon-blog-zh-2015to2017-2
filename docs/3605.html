<html>
<head>
<title>Front-end (React) Snapshot Testing with Jest: What is it for?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Jest进行前端(反应)快照测试:是为了什么？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/front-end-react-snapshot-testing-with-jest-what-is-it-for-7788f7bd5a2e?source=collection_archive---------3-----------------------#2017-04-11">https://medium.com/hackernoon/front-end-react-snapshot-testing-with-jest-what-is-it-for-7788f7bd5a2e?source=collection_archive---------3-----------------------#2017-04-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="ca80" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从14.0版本开始，Jest增加了一个新的<a class="ae jp" href="https://hackernoon.com/tagged/snapshot" rel="noopener ugc nofollow" target="_blank">快照</a>特性。有一篇博客文章宣布了这一特性，并解释了脸书实施这一特性的<a class="ae jp" href="https://facebook.github.io/jest/blog/2016/07/27/jest-14.html#why-snapshot-testing" rel="noopener ugc nofollow" target="_blank">原因</a>。但我觉得还是根据自己的经历去探索比较好。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/fbd92b9e35559f6dbea4ceef7a204c79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qLltbNe4GU6gztDQPu8R1w.jpeg"/></div></div></figure><p id="4f39" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，重要的是要强调每种类型的测试都是不同的，都有特定的目的。<strong class="it hv">例如，单元测试</strong>验证软件的每个单元都按照预期执行。集成测试确保这些单元能够很好地协同工作。<strong class="it hv">用户界面测试(端到端测试)</strong>从用户角度测试应用程序界面。</p><p id="e1b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还有一些技术，像<strong class="it hv">测试驱动开发</strong> (TDD)定义了“何时应该测试”(或者在编码前编写测试)，以及<strong class="it hv">行为驱动开发</strong> (BDD)接近“你为什么编码”(或者编码前的行为和规格)。</p><h1 id="7a0c" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated"><strong class="ak">回归测试</strong></h1><p id="443c" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated"><strong class="it hv">快照测试</strong>与之前的测试类型和技术无关。快照有助于确保某事物的<em class="lf">状态在未来不会改变。所以，不可能用快照测试来进行TDD或BDD，因为你应该先写代码，后测试。</em></p><p id="a08d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">快照测试是<strong class="it hv">回归测试</strong>的一种，旨在验证之前开发和测试的软件在更改后是否正确运行。</p><h1 id="476d" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated"><strong class="ak">测试声明性接口和集成</strong></h1><p id="6c1f" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">下面的<em class="lf">购物车物品</em>组件示例经常被测试覆盖。让我们考虑一下。但是首先，请确保您意识到代码是声明性的，没有任何类型的逻辑。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lg lh l"/></div></figure><p id="4196" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">考虑和证明声明性代码的测试是困难的。正如本文所指出的，测试声明性代码的任务以测试声明本身的功能而告终。但是可读性和意图较差。的确，<strong class="it hv">声明性代码实际上是形式规格说明</strong>。</p><p id="09d2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">BDD测试用例确保<em class="lf">数量</em>和<em class="lf">图像</em>出现在界面上是公平的。这两个资产是特性规范的一部分:<em class="lf">购物车条目</em>应该有图像和数量。</p><p id="ac6d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，用快照测试来覆盖这些是没有意义的。当你在将来改变它的时候，你故意这样做。但另一方面，<em class="lf">购物车</em>(或其他组件)可以<strong class="it hv">快照其与<em class="lf">购物车项目</em>的集成。可能是改了<em class="lf">购物车物品</em>的开发者不知道<em class="lf">购物车</em>用的。</strong></p><h1 id="b9ad" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">遗留的和测试不良的代码</h1><p id="e09c" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">依我拙见，一个具有遗留代码库的项目应该是最适合快照测试的。使用这种类型的测试，很容易创建最小的测试代码覆盖率，而不会浪费单元测试的时间。</p><p id="f92d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">看一看<a class="ae jp" href="https://github.com/jcemer/minimalistic-shop/commit/78679a5220b90de82b4ae30eb228aa1360c04352" rel="noopener ugc nofollow" target="_blank">一个对使用<a class="ae jp" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank">反应</a>和<a class="ae jp" href="https://github.com/airbnb/enzyme" rel="noopener ugc nofollow" target="_blank">酶</a>的应用程序进行快照测试</a>的例子。注意，我使用了<code class="eh li lj lk ll b">render</code>酶法，而不是<code class="eh li lj lk ll b">shallow</code>或<code class="eh li lj lk ll b">mount</code>，因为我打算测试最终的HTML结果。</p><p id="7da9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你正在做这样的项目，我祝你好运，也建议你看看类似于<a class="ae jp" href="https://github.com/Huddle/PhantomCSS" rel="noopener ugc nofollow" target="_blank"> PhantomCSS </a>的自动化<strong class="it hv">可视化回归测试</strong>的工具。</p><div class="jr js jt ju fq ab cb"><figure class="lm jv ln lo lp lq lr paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="lm jv ln lo lp lq lr paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="lm jv ln lo lp lq lr paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ls lt lu"><p id="f922" class="ir is lf it b iu iv iw ix iy iz ja jb lv jd je jf lw jh ji jj lx jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客们下午的开始。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is lf it b iu iv iw ix iy iz ja jb lv jd je jf lw jh ji jj lx jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff ly"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lz lh l"/></div></figure></div></div>    
</body>
</html>