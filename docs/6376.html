<html>
<head>
<title>A brief overview and history of systemd — the Linux process manager</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">systemd——Linux进程管理器的简要概述和历史</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-brief-overview-and-history-of-systemd-the-linux-process-manager-ca508bee4a33?source=collection_archive---------1-----------------------#2017-09-15">https://medium.com/hackernoon/a-brief-overview-and-history-of-systemd-the-linux-process-manager-ca508bee4a33?source=collection_archive---------1-----------------------#2017-09-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="14bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">本文改编自我的</em> <a class="ae jq" href="https://www.manning.com/books/linux-in-action?a_aid=bootstrap-it&amp;a_bid=4ca15fc9" rel="noopener ugc nofollow" target="_blank"> <em class="jp">曼宁《Linux in Action》一书</em> </a> <em class="jp">的第三章(远程连接:安全访问联网机器)。这还有更多的乐趣——包括Pluralsight </em>  <em class="jp">上的</em> <a class="ae jq" href="http://pluralsight.pxf.io/c/1191769/424552/7490?subId1=solving&amp;u=https%3A%2F%2Fapp.pluralsight.com%2Fprofile%2Fauthor%2Fdavid-clinton" rel="noopener ugc nofollow" target="_blank"> <em class="jp"> Linux和Docker管理课程，以及一个名为</em></a><a class="ae jq" href="https://www.manning.com/livevideo/linux-in-motion?a_aid=bootstrap-it&amp;a_bid=0c56986f&amp;chan=motion1" rel="noopener ugc nofollow" target="_blank"><em class="jp">Linux in Motion</em></a><em class="jp">的混合课程，该课程由两个多小时的视频和大约40%的Linux操作文本组成。</em></p><p id="d54e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">智能地运行Linux服务包括知道如何测试它们的状态，这反过来要求理解现代Linux发行版如何管理进程。这篇文章——摘自我的新书《Linux in Action》(使用代码<strong class="it hv"> fcclinton3 </strong>以37%的价格出售)的早期访问版(MEAP ),将简要探讨systemd的功能和历史——这个似乎让人又爱又怕又恨的进程管理器。</p><p id="aa42" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你的Linux机器上的某些东西没有运行？故障排除是你的朋友。但是，在到达目的地之前，难道不应该确保底层服务正在运行吗？有时配置文件默认设置为非活动状态。</p><p id="0955" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以使用<em class="jp"> systemctl status </em>来查明您的机器上是否正在运行一个服务——本例中是OpenSSH:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="e1f3" class="ka kb hu jw b fv kc kd l ke kf">$ systemctl status ssh<br/>● ssh.service - OpenBSD Secure Shell server<br/>   Loaded: loaded (/lib/systemd/system/ssh.service; enabled; vendor preset: enabled)<br/>   Active: active (running) since Mon 2017-05-15 12:37:18 UTC; 4h 47min ago  <br/> Main PID: 280 (sshd)   &lt;2&gt;<br/>    Tasks: 8<br/>   Memory: 10.1M<br/>      CPU: 1.322s<br/>   CGroup: /system.slice/ssh.service<br/>           ├─ 280 /usr/sbin/sshd -D<br/>           ├─ 894 sshd: ubuntu [priv] <br/>           ├─ 903 sshd: ubuntu@pts/4  <br/>           ├─ 904 -bash<br/>           ├─1612 bash<br/>           ├─1628 sudo systemctl status ssh<br/>           └─1629 systemctl status ssh<br/>[...]</span></pre><p id="7da1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这种情况下，正如您从输出的活动行中看到的，一切都很好。如果你不得不自己启动它，你可以再次使用systemctl，但是这次用<em class="jp"> start </em>代替<em class="jp"> status </em>。厌倦了你的新玩具？<em class="jp"> systemctl stop </em>会帮你收好。</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="6745" class="ka kb hu jw b fv kc kd l ke kf"># systemctl stop ssh</span></pre><p id="5f25" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那个系统公司的家伙看起来不错，但我们几乎没有机会见到他。让我们深入挖掘一下。</p><h2 id="2e05" class="ka kb hu bd kg kh ki kj kk kl km kn ko jc kp kq kr jg ks kt ku jk kv kw kx ky dt translated">Linux进程管理</h2><p id="892d" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">首先，什么是systemctl，它实际上在做什么？为了正确回答这个问题，您必须考虑一下Linux一般是如何管理系统进程的。由于认识新朋友总是令人愉快的，您还将了解一些过程跟踪工具，以便更容易理解事情的工作方式。</p><p id="c911" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我相信你已经知道，软件是包含指令的程序代码，代表人类用户控制计算机硬件。操作系统是一种工具，用于组织和管理软件包，以便它们可以有效地利用计算机的硬件资源。为复杂的多流程和多用户操作环境组织和管理流程不是一件简单的任务。为了让它工作，你需要某种交通警察来严密控制许多移动的部分。我给你介绍一下systemctl，Linux警察局交通科的一个勤快的警官。</p><figure class="jr js jt ju fq lf fe ff paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="fe ff le"><img src="../Images/457b1be93aefbead38d5e6a329100fbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OD9MOvg4XlBFYezYqwUSMA.png"/></div></div><figcaption class="lm ln fg fe ff lo lp bd b be z ek">The availability and responsiveness of many system services are managed by systemd’s systemctl process manager</figcaption></figure><h2 id="b678" class="ka kb hu bd kg kh ki kj kk kl km kn ko jc kp kq kr jg ks kt ku jk kv kw kx ky dt translated">使用ps命令查看进程</h2><p id="dcf2" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">让我们拿出一个电子显微镜，看看我们能否在它的自然栖息地发现一个真实的过程。当一台Linux计算机启动时，第一个被唤醒并使其他一切正常运行的进程叫做init(尽管我们很快就会发现，这个名字可能会引起误解)。您可以自己看到，init首先是按照这里打印的方式运行下面的ps命令——我马上会解释细节。</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="8251" class="ka kb hu jw b fv kc kd l ke kf">$ ps -ef | grep init <br/>root         1     0  0 12:36 ?        00:00:00 /sbin/init <br/>ubuntu    1406   904  0 16:26 pts/4    00:00:00 grep --color=auto init</span></pre><p id="96f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">输出最右边的一列(第一行的/sbin/init)表示进程本身后面的文件的位置和名称。在本例中，它是一个名为“init”的文件，位于/sbin目录中。第一行最左边的一列包含单词<em class="jp"> root </em>，告诉我们这个流程的所有者是root用户。我们现在唯一感兴趣的另一条信息是数字1，它是init进程的进程ID (PID)。获得PID 1的唯一方法是比任何人都先到。</p><p id="506c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">顺便说一下，ps命令显示的第二行是分配给grep命令本身的进程。注意它的主人是ubuntu(我的用户名)，它的PID远远高于1。</p><p id="e664" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在继续之前，花点时间和ps在一起是值得的。正如您所看到的，ps显示关于活动进程的信息。访问与流程相关的信息通常很重要，这样我们就可以正确规划系统行为并对其进行故障排除。你可以期待早日和经常使用ps。</p><p id="523a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您只键入ps并运行它，您可能只会得到两个结果:第一个是一个名为bash的进程，它表示当前shell会话正在使用的Bash命令解释器，另一个是最近的命令(当然是ps)。但是通过查看分配给Bash的PID(在本例中为7447)，您就会知道在您的系统中还有很多其他进程正在努力工作。这些将由父shells产生，一直追溯到init进程本身。</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="d1e9" class="ka kb hu jw b fv kc kd l ke kf">$ ps<br/> PID TTY          TIME CMD<br/>7447 pts/3    00:00:00 bash<br/>8041 pts/3    00:00:00 ps</span></pre><p id="55ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如上所述，向ps添加-e参数不仅会返回当前子shell中运行的进程，还会将所有父shell中的所有进程返回到init。</p><p id="dbbd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">父外壳是一个外壳环境，新的(子)外壳随后可以从其中启动，程序也可以通过它运行。你可以把你的GUI桌面会话想象成一个shell，而你打开来获取命令行的终端就是它的孩子。顶层外壳(祖父母？)是Linux启动时首先运行的。</p><p id="d556" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您想要可视化父和子shells进程，您可以使用pstree命令(添加-p参数来显示每个进程的PID号)。请注意第一个进程(分配了PID 1)是如何<em class="jp"> systemd </em>的。在旧版本的Linux上，这应该被称为<em class="jp"> init </em>。</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="5684" class="ka kb hu jw b fv kc kd l ke kf">$ pstree -p<br/>systemd(1)─┬─agetty(264) <br/>           ├─agetty(266)<br/>           ├─agetty(267)<br/>           ├─agetty(268)<br/>           ├─agetty(269)<br/>           ├─apache2(320)─┬─apache2(351)<br/>           │              ├─apache2(352)<br/>           │              ├─apache2(353)<br/>           │              ├─apache2(354)<br/>           │              └─apache2(355)<br/>           ├─cron(118)<br/>           ├─dbus-daemon(109)<br/>           ├─dhclient(204)<br/>           ├─dockerd(236)─┬─docker-containe(390)─┬─{docker-containe}(392)<br/>           │              │                      └─{docker-containe}(404)<br/>           │              ├─{dockerd}(306)<br/>           │              └─{dockerd}(409)<br/>           ├─mysqld(280)─┬─{mysqld}(325)<br/>           │             ├─{mysqld}(326)<br/>           │             └─{mysqld}(399)<br/>           ├─nmbd(294)<br/>           ├─rsyslogd(116)─┬─{in:imklog}(166)<br/>           │               ├─{in:imuxsock}(165)<br/>           │               └─{rs:main Q:Reg}(167)<br/>           ├─smbd(174)─┬─smbd(203)<br/>           │           └─smbd(313)<br/>           ├─sshd(239)───sshd(840)───sshd(849)───bash(850)───pstree(15328)<br/>           ├─systemd-journal(42)<br/>           └─systemd-logind(108)</span></pre><p id="97dd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">继续在您自己的机器上尝试所有这些命令。即使在安静的系统上，您也可能会看到几十个进程；一台繁忙的台式PC或服务器可以轻松拥有数千台。</p><h2 id="60fb" class="ka kb hu bd kg kh ki kj kk kl km kn ko jc kp kq kr jg ks kt ku jk kv kw kx ky dt translated">使用systemd</h2><p id="564d" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">我们刚刚看到的/sbin/init文件有些有趣的地方。“文件”是一个古老的Unix程序，它给你一个文件的内部信息。如果您使用/sbin/init作为参数运行<em class="jp">文件</em>，您将会看到init文件实际上并不是一个程序，而只是一个名为systemd的程序的符号链接。</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="75a2" class="ka kb hu jw b fv kc kd l ke kf">$ file /sbin/init<br/>/sbin/init: symbolic link to /lib/systemd/systemd</span></pre><p id="78a6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">经过多年的分裂和激烈的政治斗争，现在几乎所有的Linux发行版都使用同一个进程管理器:systemd。systemd是init进程的替代产品。我所说的“替代”是指，即使它完成事情的方式可能非常不同，对于不经意的观察者来说，systemd的功能就像init一直做的那样。这就是为什么/sbin/init文件现在实际上只不过是systemd程序的一个链接。</p><p id="68aa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这都有点理论性，因为您可能永远不会真正通过名称调用systemd程序本身——无论是直接调用还是通过它的/sbin/init前端调用。正如您已经看到的，这是因为关键的管理任务是由systemctl代表systemd处理的。</p><p id="11c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从技术上讲，systemd的主要工作是控制单个进程的诞生、生存和死亡方式。我们上面使用的systemctl命令是这些任务的首选工具。但是——有些争议systemd开发人员扩展了功能，使其远远超出了传统的进程管理角色，可以控制各种系统服务。在新的systemd保护伞下包括了日志管理器(journald)、网络管理器(networkd)和设备管理器(你猜对了:udevd)等工具。好奇？“d”代表守护进程；一个后台系统进程。</p><figure class="jr js jt ju fq lf fe ff paragraph-image"><div class="fe ff lq"><img src="../Images/068c15960b9a538f0657f8dd4e955631.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/0*ufSpWkBfRakYB-Ex.jpg"/></div></figure><p id="7bb1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">本文改编自我的</em> <a class="ae jq" href="https://www.manning.com/books/linux-in-action?a_aid=bootstrap-it&amp;a_bid=4ca15fc9" rel="noopener ugc nofollow" target="_blank"> <em class="jp">曼宁《Linux in Action》一书</em> </a> <em class="jp">的第三章(远程连接:安全访问联网机器)。这还有更多的乐趣——包括Pluralsight </em>  <em class="jp">上的</em> <a class="ae jq" href="http://pluralsight.pxf.io/c/1191769/424552/7490?subId1=solving&amp;u=https%3A%2F%2Fapp.pluralsight.com%2Fprofile%2Fauthor%2Fdavid-clinton" rel="noopener ugc nofollow" target="_blank"> <em class="jp"> Linux和Docker管理课程，以及一个名为</em></a><a class="ae jq" href="https://www.manning.com/livevideo/linux-in-motion?a_aid=bootstrap-it&amp;a_bid=0c56986f&amp;chan=motion1" rel="noopener ugc nofollow" target="_blank"><em class="jp">Linux in Motion</em></a><em class="jp">的混合课程，该课程由两个多小时的视频和大约40%的Linux操作文本组成。谁知道呢……你可能也会喜欢我最近出版的</em> <a class="ae jq" href="https://www.manning.com/books/learn-amazon-web-services-in-a-month-of-lunches?a_aid=bootstrap-it&amp;amp;a_bid=1c1b5e27" rel="noopener ugc nofollow" target="_blank"> <em class="jp">一个月的午餐</em> </a> <em class="jp">学习亚马逊网络服务。</em></p></div></div>    
</body>
</html>