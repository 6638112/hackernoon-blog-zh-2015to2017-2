<html>
<head>
<title>What’s New With Server-Side Rendering in React 16</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 16中服务器端渲染的新特性</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/whats-new-with-server-side-rendering-in-react-16-9b0d78585d67?source=collection_archive---------2-----------------------#2017-09-25">https://medium.com/hackernoon/whats-new-with-server-side-rendering-in-react-16-9b0d78585d67?source=collection_archive---------2-----------------------#2017-09-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="8d60" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">快速介绍React 16 SSR中的新功能，包括阵列、性能、流等。</h2></div><p id="049a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">React 16来了！🎉🎉🎉</p><p id="d179" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有许多令人兴奋的新内容(最明显的是纤程重写)，但就个人而言，我最兴奋的是React 16对服务器端渲染的许多改进。</p><p id="b0c8" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们深入了解一下React 16中SSR的新功能和不同之处，我希望您最终会和我一样兴奋！</p><h2 id="b95e" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">SSR在React 15中如何工作</h2><p id="a311" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">首先，让我们回顾一下React 15中的服务器端渲染。要进行SSR，通常需要运行基于节点的web服务器，如Express、哈比神或Koa，并调用<code class="eh lf lg lh li b">renderToString</code>将根组件呈现为字符串，然后将字符串写入响应:</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="39f2" class="kf kg hu li b fv lr ls l lt lu">// using Express<br/>import { <strong class="li hv">renderToString</strong> } from "react-dom/server"<br/>import MyPage from "./MyPage"</span><span id="b161" class="kf kg hu li b fv lv ls l lt lu">app.get("/", (req, res) =&gt; {<br/>  res.write("&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;My Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;");<br/>  res.write("&lt;div id='content'&gt;");  <br/>  <strong class="li hv">res.write(renderToString(&lt;MyPage/&gt;));</strong><br/>  res.write("&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;");<br/>  res.end();<br/>});</span></pre><p id="61f1" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后，在您的客户端引导代码中，您告诉客户端呈现器使用<code class="eh lf lg lh li b">render()</code>对服务器生成的HTML进行“再水合”，这与您在客户端呈现的应用程序中使用的方法相同:</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="c9f6" class="kf kg hu li b fv lr ls l lt lu">import { render } from "react-dom"<br/>import MyPage from "./MyPage"</span><span id="148f" class="kf kg hu li b fv lv ls l lt lu">render(&lt;MyPage/&gt;, document.getElementById("content"));</span></pre><p id="575c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果您正确地做到了这一点，客户端呈现器就可以使用现有的服务器生成的HTML，而无需更新DOM。</p><p id="9d8f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">那么，React 16中的SSR是什么样子的呢？</p><h2 id="a2c0" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">React 16是向后兼容的</h2><p id="c313" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">React团队对向后兼容性表现出了强烈的承诺，因此如果您能够在React 15中运行您的代码而没有任何反对警告，它应该在React 16中“正常工作”。例如，上一节中的代码在React 15和React 16中都运行良好。</p><p id="ab21" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你偶然将React 16放入你的应用程序并发现了错误，请<a class="ae lw" href="https://github.com/facebook/react/issues" rel="noopener ugc nofollow" target="_blank">将它们归档</a>！这将有助于核心团队清除16版本中的任何错误。</p><h2 id="8f0e" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">render()变成水合物()</h2><p id="45ab" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">但是，当您将SSR代码从React 15升级到React 16时，您可能会在浏览器中遇到以下警告:</p><figure class="lj lk ll lm fq ly fe ff paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="fe ff lx"><img src="../Images/de3d2a6a20f68c3d3ee62349c8e1e022.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mylke5-zzZpfoBf2hPsAeA.png"/></div></div><figcaption class="mf mg fg fe ff mh mi bd b be z ek">Yet another helpful React warning. render() is now hydrate()!</figcaption></figure><p id="45d4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">原来，在React 16中，现在有两种不同的客户端呈现方法:<code class="eh lf lg lh li b">render()</code>用于在客户端单独呈现内容，而<code class="eh lf lg lh li b">hydrate()</code>用于在服务器端呈现的标记上呈现内容。因为React是向后兼容的，所以在React 16中，当在服务器生成的标记之上进行渲染时，<code class="eh lf lg lh li b">render()</code>将继续工作，但是您应该将这些调用更改为<code class="eh lf lg lh li b">hydrate()</code>以消除警告，并为React 17准备您的代码。我们上面展示的代码片段将变成:</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="0b90" class="kf kg hu li b fv lr ls l lt lu">import { <strong class="li hv">hydrate</strong> } from "react-dom"<br/>import MyPage from "./MyPage"</span><span id="245a" class="kf kg hu li b fv lv ls l lt lu"><strong class="li hv">hydrate</strong>(&lt;MyPage/&gt;, document.getElementById("content"));</span></pre><h2 id="70be" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">React 16可以处理数组、字符串和数字</h2><p id="2e69" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">在React 15中，组件的<code class="eh lf lg lh li b">render</code>方法必须总是返回单个React元素。然而，在React 16中，客户端渲染器允许组件从<code class="eh lf lg lh li b">render</code>方法返回字符串、数字或元素数组。自然，React 16的服务器端渲染也支持这个特性。</p><p id="fdc9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，您现在可以服务器呈现如下所示的组件:</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="3503" class="kf kg hu li b fv lr ls l lt lu">class MyArrayComponent extends React.Component {<br/>  render() {<br/>    return [<br/>      &lt;div key="1"&gt;first element&lt;/div&gt;, <br/>      &lt;div key="2"&gt;second element&lt;/div&gt;<br/>    ];<br/>  }<br/>}</span><span id="594e" class="kf kg hu li b fv lv ls l lt lu">class MyStringComponent extends React.Component {<br/>  render() {<br/>    return "hey there";<br/>  }<br/>}</span><span id="180c" class="kf kg hu li b fv lv ls l lt lu">class MyNumberComponent extends React.Component {<br/>  render() {<br/>    return 2;<br/>  }<br/>}</span></pre><p id="8215" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您甚至可以将一个字符串、一个数字或一个组件数组传递给顶级的<code class="eh lf lg lh li b">renderToString</code>方法:</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="74dd" class="kf kg hu li b fv lr ls l lt lu">res.write(renderToString([<br/>      &lt;div key="1"&gt;first element&lt;/div&gt;, <br/>      &lt;div key="2"&gt;second element&lt;/div&gt;<br/>    ]));</span><span id="5651" class="kf kg hu li b fv lv ls l lt lu">// it’s not entirely clear why you would do this, but it works!<br/>res.write(renderToString("hey there"));<br/>res.write(renderToString(2));</span></pre><p id="93a5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这应该可以让您消除刚刚添加到React组件树中的任何<code class="eh lf lg lh li b">div</code>和<code class="eh lf lg lh li b">span</code>，从而减小HTML文档的整体大小。</p><h2 id="54e0" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">React 16生成更高效的HTML</h2><p id="752e" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">说到更小的HTML文档大小，React 16还从根本上减少了生成的HTML中的SSR开销。在React 15中，SSR文档中的每个HTML元素都有一个<code class="eh lf lg lh li b">data-reactid</code>属性，其值由一个单调递增的ID组成，文本节点有时会被带有<code class="eh lf lg lh li b">react-text</code>和一个ID的注释包围。要查看这是什么样子，请参考下面的代码片段:</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="b28f" class="kf kg hu li b fv lr ls l lt lu">renderToString(<br/>  &lt;div&gt;<br/>    This is some &lt;span&gt;server-generated&lt;/span&gt; &lt;span&gt;HTML.&lt;/span&gt;<br/>  &lt;/div&gt;<br/>);</span></pre><p id="e088" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在React 15中，这个代码片段生成如下所示的HTML(为了可读性，添加了换行符):</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="8947" class="kf kg hu li b fv lr ls l lt lu">&lt;div data-reactroot="" data-reactid="1" <br/>    data-react-checksum="122239856"&gt;<br/>  &lt;!-- react-text: 2 --&gt;This is some &lt;!-- /react-text --&gt;<br/>  &lt;span data-reactid="3"&gt;server-generated&lt;/span&gt;<br/>  &lt;!-- react-text: 4--&gt; &lt;!-- /react-text --&gt;<br/>  &lt;span data-reactid="5"&gt;HTML.&lt;/span&gt;<br/>&lt;/div&gt;</span></pre><p id="f1ed" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然而，在React 16中，所有的id都被从标记中删除了，所以相同代码片段的HTML要简单得多:</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="9bcc" class="kf kg hu li b fv lr ls l lt lu">&lt;div data-reactroot=""&gt;<br/>  This is some &lt;span&gt;server-generated&lt;/span&gt; &lt;span&gt;HTML.&lt;/span&gt;<br/>&lt;/div&gt;</span></pre><p id="19bc" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这不仅读起来更清晰，还可以大大减小HTML文档的大小。耶！</p><h2 id="cfe6" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">React 16允许非标准的DOM属性</h2><p id="29fb" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">在React 15中，DOM呈现器对HTML元素的属性要求相当严格，它剔除了所有非标准的HTML属性。但是，在React 16中，客户机和服务器呈现器现在都可以传递您添加到HTML元素中的任何非标准属性。要了解更多关于这一特性的信息，请阅读<a class="ae lw" href="https://facebook.github.io/react/blog/2017/09/08/dom-attributes-in-react-16.html" rel="noopener ugc nofollow" target="_blank">丹·阿布拉莫夫在React博客</a>上关于这一变化的帖子。</p><h2 id="d41d" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">React 16 SSR不支持错误边界或门户</h2><p id="8e7e" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">React 16客户端渲染器中有两个服务器端渲染器不支持的新特性:错误边界和门户。如果你想了解更多关于错误边界的知识，可以看看Dan Abramov在React博客上的<a class="ae lw" href="https://facebook.github.io/react/blog/2017/07/26/error-handling-in-react-16.html" rel="noopener ugc nofollow" target="_blank">精彩文章，但是要知道(至少现在)错误边界并不能捕捉服务器上的错误。据我所知，门户还没有解释性的博客文章，但是门户API需要一个DOM节点，所以它不能在服务器上使用。</a></p><h2 id="4e11" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">React 16执行不太严格的客户端检查</h2><p id="97ca" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">当您在React 15中的客户端重新合并标记时，<code class="eh lf lg lh li b">ReactDOM.render()</code>会与服务器生成的标记进行逐字符比较。如果由于任何原因出现不匹配，React会在开发模式下发出警告，并用客户机上生成的HTML替换服务器生成的整个标记树。</p><p id="b15b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是，在React 16中，客户端呈现器使用不同的算法来检查服务器生成的标记是否正确。比React 15宽松一点；例如，它不要求服务器生成的标记的属性顺序与它们在客户端的顺序相同。当React 16中的客户端渲染器检测到标记不匹配时，它只会尝试更改不匹配的HTML子树，而不是整个HTML树。</p><p id="0276" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一般来说，这种变化对最终用户应该不会有太大影响，除了一个事实:<strong class="jl hv"> React 16在调用</strong> <code class="eh lf lg lh li b"><strong class="jl hv">ReactDOM.render()/hydrate()</strong></code>时不会修复不匹配的SSR生成的HTML属性。这种性能优化意味着你需要额外确保修复你在<code class="eh lf lg lh li b">development</code>模式下看到的任何标记不匹配警告。</p><h2 id="bfc7" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">React 16不需要编译就能获得最佳性能</h2><p id="cb00" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">在React 15中，如果您直接使用SSR，即使在<code class="eh lf lg lh li b">production</code>模式下，性能也不会达到最佳。这是因为React中有许多优秀的开发人员警告和提示，每个警告看起来都像这样:</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="ced5" class="kf kg hu li b fv lr ls l lt lu">if (process.env.NODE_ENV !== "production") {<br/>  // check some stuff and output great developer<br/>  // warnings here.<br/>}</span></pre><p id="d14d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">遗憾的是，<a class="ae lw" href="https://github.com/facebook/react/issues/812" rel="noopener ugc nofollow" target="_blank">原来</a> <code class="eh lf lg lh li b"><a class="ae lw" href="https://github.com/facebook/react/issues/812" rel="noopener ugc nofollow" target="_blank">process.env</a></code> <a class="ae lw" href="https://github.com/facebook/react/issues/812" rel="noopener ugc nofollow" target="_blank">并不是一个普通的JavaScript对象</a>，从中获取一个值的代价相当大。因此，即使当<code class="eh lf lg lh li b">NODE_ENV</code>的值被设置为<code class="eh lf lg lh li b">production</code>时，仅仅<em class="mj">如此频繁地检查</em>环境变量也会给服务器渲染增加大量时间。</p><p id="f454" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了在React 15中解决这个问题，你必须编译你的SSR代码来删除对<code class="eh lf lg lh li b">process.env</code>的引用，使用类似Webpack的<a class="ae lw" href="https://webpack.js.org/plugins/environment-plugin/" rel="noopener ugc nofollow" target="_blank">环境插件</a>，或者Babel的<a class="ae lw" href="https://www.npmjs.com/package/babel-plugin-transform-inline-environment-variables" rel="noopener ugc nofollow" target="_blank">转换-内联-环境-变量</a>插件。然而，以我的经验来看，许多人<em class="mj">不</em>编译他们的服务器端代码，结果他们得到了明显更差的SSR性能。</p><p id="e0a6" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在React 16中，这个问题已经解决了。在React 16的最开始只有一个检查<code class="eh lf lg lh li b">process.env.NODE_ENV</code>的调用，所以没有必要为了获得最佳性能而编译你的SSR代码。开箱即可获得最佳性能。</p><h2 id="44bb" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">React 16也更快</h2><p id="ed26" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">说到性能，在生产中使用React服务器端渲染的人们经常抱怨大型文档渲染缓慢，即使有了所有的最佳实践*。</p><p id="f528" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，我非常高兴地报告，我所做的一些<a class="ae lw" href="https://github.com/aickin/react-16-ssr-perf" rel="noopener ugc nofollow" target="_blank">初步测试</a>显示了React 16中服务器端渲染的显著速度提升，跨多个不同版本的Node:</p><figure class="lj lk ll lm fq ly fe ff paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="fe ff mk"><img src="../Images/57be4027efd7aeb3fb6c7f8749689b2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E5Pmh6HSeybcF7C686B9pA.png"/></div></div><figcaption class="mf mg fg fe ff mh mi bd b be z ek">React 16 renders on the server faster than React 15</figcaption></figure><p id="0f92" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当与编译了<code class="eh lf lg lh li b">process.env</code>的React 15进行比较时，节点4的性能提高了约2.4倍，节点6的性能提高了约3倍，新的节点8.4版本的性能提高了整整3.8倍。而如果和没有编译的React 15对比，React 16在Node最新版本的SSR上有整整一个数量级的增益！</p><p id="3a20" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为什么React 16 SSR比React 15快那么多？在React 15中，服务器和客户端渲染路径差不多是相同的代码。这意味着维护一个虚拟DOM所需的所有数据结构在服务器渲染时就已经建立起来了，即使这个vDOM在调用<code class="eh lf lg lh li b">renderToString</code>一返回就被丢弃了。这意味着在服务器渲染路径上有很多浪费的工作。</p><p id="7189" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然而，在React 16中，核心团队从头开始重写了服务器渲染器，它根本不做任何vDOM工作。这意味着它可以快得多。</p><p id="9133" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，有一个警告:我做的测试只是用一个非常简单的递归React组件生成了一棵巨大的<code class="eh lf lg lh li b">&lt;span&gt;</code>树。这意味着它是一个非常合成的基准，几乎肯定不能反映真实世界的使用。例如，如果你的组件中有一堆复杂的<code class="eh lf lg lh li b">render</code>方法，它们占用了大量的CPU周期，那么React 16对此无能为力。因此，虽然我绝对希望看到React SSR时间随着迁移到16而显著改善，但我不希望你在现实世界的应用程序中看到3倍的改善。有趣的是，我从一些早期采用者那里听说他们看到了1.3倍的加速比<a class="ae lw" href="https://github.com/facebook/react/issues/10294#issuecomment-319220586" rel="noopener ugc nofollow" target="_blank">。在你的应用中找到答案的最好方法就是测试一下，看看！</a></p><h2 id="ee91" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">React 16支持流媒体</h2><p id="d4a2" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">最后，React 16现在支持直接渲染到节点流。</p><p id="56a1" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">呈现到流可以减少内容的第一字节时间(TTFB ),在生成文档的下一部分之前就将文档的开头发送到浏览器。当内容以这种方式从服务器流出时，所有主流浏览器都会更早地开始解析和呈现文档。</p><p id="f6fc" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">渲染到流的另一个好处是能够响应<strong class="jl hv">背压</strong>。实际上，这意味着如果网络阻塞，无法接受更多的字节，渲染器会收到信号并暂停渲染，直到阻塞被清除。这意味着您的服务器使用的内存更少，对I/O条件的响应更快，这两者都有助于您的服务器在充满挑战的条件下保持运行。</p><p id="a583" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">要使用React 16的render to stream，需要在<code class="eh lf lg lh li b">react-dom/server</code> : <code class="eh lf lg lh li b">renderToNodeStream</code>或者<code class="eh lf lg lh li b">renderToStaticNodeStream</code>上调用两个新方法中的一个，分别对应<code class="eh lf lg lh li b">renderToString</code>和<code class="eh lf lg lh li b">renderToStaticMarkup</code>。这些新方法不返回字符串，而是返回一个<code class="eh lf lg lh li b"><a class="ae lw" href="https://nodejs.org/api/stream.html#stream_readable_streams" rel="noopener ugc nofollow" target="_blank">Readable</a></code>，用于发出字节流的对象的节点流类。</p><p id="cfea" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当你接收到从<code class="eh lf lg lh li b">renderTo(Static)NodeStream</code>返回的<code class="eh lf lg lh li b">Readable</code>流时，它处于暂停模式，还没有进行渲染。只有当你调用<code class="eh lf lg lh li b"><a class="ae lw" href="https://nodejs.org/api/stream.html#stream_readable_read_size" rel="noopener ugc nofollow" target="_blank">read</a></code>或者更可能的是<code class="eh lf lg lh li b"><a class="ae lw" href="https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options" rel="noopener ugc nofollow" target="_blank">pipe</a></code><code class="eh lf lg lh li b">Readable</code>到<code class="eh lf lg lh li b"><a class="ae lw" href="https://nodejs.org/api/stream.html#stream_writable_streams" rel="noopener ugc nofollow" target="_blank">Writable</a></code>流时，渲染才会开始。大多数节点web框架都有一个继承自<code class="eh lf lg lh li b">Writable</code>的响应对象，所以您通常可以通过管道将<code class="eh lf lg lh li b">Readable</code>传递给响应。</p><p id="4ea6" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">作为一个例子，上面的Express示例可以重写为如下的流:</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="8310" class="kf kg hu li b fv lr ls l lt lu">// using Express<br/>import { <strong class="li hv">renderToNodeStream</strong> } from "react-dom/server"<br/>import MyPage from "./MyPage"</span><span id="e2d5" class="kf kg hu li b fv lv ls l lt lu">app.get("/", (req, res) =&gt; {<br/>  res.write("&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;My Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;");<br/>  res.write("&lt;div id='content'&gt;");<strong class="li hv"> <br/>  const stream = renderToNodeStream(&lt;MyPage/&gt;);<br/>  stream.pipe(res, { end: false });<br/>  stream.on('end', () =&gt; {</strong><br/>    res.write("&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;");<br/>    res.end();<br/>  <strong class="li hv">});</strong><br/>});</span></pre><p id="6797" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">注意，当我们通过管道连接到响应对象时，我们必须包含可选参数<code class="eh lf lg lh li b">{ end: false }</code>来告诉流不要在渲染器完成时自动结束响应。这允许我们完成HTML主体，并在流完全写入响应后自己结束响应。</p><h2 id="340f" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">流媒体有一些问题</h2><p id="a325" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">虽然渲染到流在大多数情况下应该是一种升级，但目前有一些SSR模式并不适合流。</p><p id="68ce" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一般来说，任何使用服务器渲染过程来生成标记的模式都需要在SSR-ed块之前添加到文档中。这方面的一些例子是动态确定将哪个CSS添加到前面的<code class="eh lf lg lh li b">&lt;style&gt;</code>标签中的框架，或者在呈现时将元素添加到文档<code class="eh lf lg lh li b">&lt;head&gt;</code>中的框架。如果您使用这些类型的框架，您可能必须坚持使用字符串呈现。</p><p id="da15" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">另一个在React 16中还不能工作的模式是将对<code class="eh lf lg lh li b">renderToNodeStream</code>的调用嵌入到组件树中。在React 15中，通常使用<code class="eh lf lg lh li b">renderToStaticMarkup</code>来生成页面模板，并嵌入对<code class="eh lf lg lh li b">renderToString</code>的调用来生成动态内容，如下所示:</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="8ba4" class="kf kg hu li b fv lr ls l lt lu">res.write("&lt;!DOCTYPE html&gt;");<br/>res.write(renderToStaticMarkup(<br/>  &lt;html&gt;<br/>    &lt;head&gt;<br/>      &lt;title&gt;My Page&lt;/title&gt;<br/>    &lt;/head&gt;<br/>    &lt;body&gt;<br/>      &lt;div id="content"&gt;<br/>        { renderToString(&lt;MyPage/&gt;) }<br/>      &lt;/div&gt;<br/>    &lt;/body&gt;<br/>  &lt;/html&gt;);</span></pre><p id="836b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是，如果将这些呈现调用替换为它们的流调用，这段代码将停止工作，因为还不可能将<code class="eh lf lg lh li b">Readable</code>流(从<code class="eh lf lg lh li b">renderToNodeStream</code>返回)作为元素嵌入到组件中。不过，我希望这一点能在以后添加进去！</p><h2 id="1d71" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">就是这样！</h2><p id="f504" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">这些就是React 16中主要的SSR变化；我希望你和我一样对它们感到兴奋。</p><p id="19e4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在我结束之前，我想衷心感谢React核心团队的所有成员，他们致力于使服务器端渲染成为React生态系统的一流部分。这组人包括(但绝不限于)<a class="ae lw" href="http://www.jimsproch.com" rel="noopener ugc nofollow" target="_blank">吉姆·斯普洛克</a>、<a class="ae lw" href="https://twitter.com/sophiebits" rel="noopener ugc nofollow" target="_blank">索菲·阿尔珀特</a>、<a class="ae lw" href="https://twitter.com/tomocchino" rel="noopener ugc nofollow" target="_blank">汤姆·奥奇诺</a>、<a class="ae lw" href="https://twitter.com/sebmarkbage" rel="noopener ugc nofollow" target="_blank">塞巴斯蒂安·马克贝格</a>、<a class="ae lw" href="https://twitter.com/dan_abramov" rel="noopener ugc nofollow" target="_blank">丹·阿布拉莫夫</a>和<a class="ae lw" href="https://twitter.com/trueadm" rel="noopener ugc nofollow" target="_blank">多米尼克·甘那韦</a>。谢谢，谢谢，谢谢！</p><p id="b796" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在:让我们出去，服务器渲染一些HTML！</p><p id="39c8" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="mj">拜</em> <a class="ae lw" href="https://twitter.com/threepointone" rel="noopener ugc nofollow" target="_blank"> <em class="mj">苏尼尔帕</em></a><em class="mj"/><a class="ae lw" href="https://twitter.com/dan_abramov" rel="noopener ugc nofollow" target="_blank"><em class="mj">丹阿布拉莫夫</em></a><em class="mj"/><a class="ae lw" href="https://twitter.com/alecf" rel="noopener ugc nofollow" target="_blank"><em class="mj">亚历克弗莱特</em></a><em class="mj"/><a class="ae lw" href="https://twitter.com/@swazza85" rel="noopener ugc nofollow" target="_blank"><em class="mj">斯瓦普·卡拉瓦迪</em><em class="mj"/></a><a class="ae lw" href="https://twitter.com/helenaut" rel="noopener ugc nofollow" target="_blank"><em class="mj">海伦翁</em> </a> <em class="mj"/></p></div><div class="ab cl ml mm hc mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hn ho hp hq hr"><p id="c4e1" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="mj">另外，我在9月23日的</em><a class="ae lw" href="http://www.reactboston.com" rel="noopener ugc nofollow" target="_blank"><em class="mj">React Boston</em></a><em class="mj">演讲中谈到了这些话题，以及一些关于React 16后服务器端渲染下一步我们该何去何从的思考。如果你想看那个演讲，就在存档的活动直播</em> <a class="ae lw" href="https://www.youtube.com/watch?v=2iPE5l3cl_s#t=57m10s" rel="noopener ugc nofollow" target="_blank"> <em class="mj">这里</em> </a> <em class="mj">。如果您想跳过本文中的内容，只观看SSR未来的想法，请单击此处的</em><a class="ae lw" href="https://www.youtube.com/watch?v=2iPE5l3cl_s#t=1h28m16s" rel="noopener ugc nofollow" target="_blank"><em class="mj"/></a><em class="mj">。</em></p></div><div class="ab cl ml mm hc mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hn ho hp hq hr"><p id="e60c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">*说到这里:拜托，拜托，请确保在生产中使用React SSR时，始终将<code class="eh lf lg lh li b">NODE_ENV</code>设置为<code class="eh lf lg lh li b">production</code>！</p></div></div>    
</body>
</html>