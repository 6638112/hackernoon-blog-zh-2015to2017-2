<html>
<head>
<title>Centralised logging for AWS Lambda</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS Lambda的集中日志记录</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/centralised-logging-for-aws-lambda-b765b7ca9152?source=collection_archive---------3-----------------------#2017-08-28">https://medium.com/hackernoon/centralised-logging-for-aws-lambda-b765b7ca9152?source=collection_archive---------3-----------------------#2017-08-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="5eb6" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">CloudWatch Logs很难满足您所有的日志记录需求，幸运的是，您可以使用AWS Lambda函数轻松地将日志流式传输到您首选的日志聚合服务。</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/9d43816cff4856cc1814138ecf516f4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ohWUB5snJRaMe-vJ8HaoiA.png"/></div></div></figure><p id="ce26" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这是关于管理AWS Lambda日志的3部分迷你系列的第一部分。在第1部分中，我们将了解如何从CloudWatch中获取所有日志。</p><p id="227d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">第2部分将帮助您更好地理解日志记录和监控的不同方法之间的权衡，以及我遇到的一些有用的提示和技巧。</p><p id="41f3" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">第3部分将演示如何通过各种事件源捕获和转发关联IDs例如API Gateway、SNS和Kinesis。</p><p id="94cc" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">第二部</strong>T3:T5】小窍门</p><p id="2887" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">第三部分:</strong> <a class="ae kr" rel="noopener" href="/@theburningmonk/capture-and-forward-correlation-ids-through-different-lambda-event-sources-220c227c65f5">跟踪关联id</a></p><h1 id="9511" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">AWS Lambda日志记录基础</h1><p id="cebd" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">在Lambda函数的执行过程中，您写入stdout的任何内容(例如，在Node.js中使用<code class="eh lp lq lr ls b">console.log</code>)都将被Lambda捕获，并在后台异步发送到CloudWatch日志，而不会增加函数执行时间的任何开销。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff lt"><img src="../Images/8c6f0a1fc21fc30780b3b56e9063ce70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1tTYm05RtD1TRmuyTOflig.png"/></div></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">You can find all the logs for your Lambda functions in CloudWatch Logs, organised into log groups (one log group per function) and then log streams (one log stream per container instance).</figcaption></figure><p id="d042" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">当然，您可以通过<a class="ae kr" href="http://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutLogEvents.html" rel="noopener ugc nofollow" target="_blank"> PutLogEvents </a>操作将这些日志发送到CloudWatch Logs，或者发送到您喜欢的日志聚合服务，如Splunk或Elasticsearch。但是，记住<strong class="jx hv">一切都必须在函数调用</strong>期间完成。如果您在调用期间进行额外的网络调用，那么您将为这些额外的执行时间付费，并且您的用户将不得不等待更长的时间来等待API响应。</p><p id="aefc" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">所以，不要那么做！</p><p id="2699" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">相反，应该在事后处理CloudWatch日志中的日志。</p><h1 id="d43a" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">流式CloudWatch日志</h1><p id="295e" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">在CloudWatch日志控制台中，您可以选择一个日志组(每个Lambda函数一个)，并选择将数据直接传输到Amazon托管的Elasticsearch服务。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ly"><img src="../Images/dfcef3c907d500df4083c36b552c353a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/1*YnLkV-9S7mPgrwAKGZtT7w.png"/></div></div></figure><p id="0902" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果你已经在使用托管的Elasticsearch服务，这是非常有用的。但是如果你还在评估你的选择，那么在你决定选择AWS主办的Elasticsearch之前，读一读这篇文章。</p><div class="lz ma fm fo mb mc"><a href="https://read.acloud.guru/things-you-should-know-before-using-awss-elasticsearch-service-7cd70c9afb4f" rel="noopener  ugc nofollow" target="_blank"><div class="md ab ej"><div class="me ab mf cl cj mg"><h2 class="bd hv fv z el mh eo ep mi er et ht dt translated">在AWS上使用亚马逊的Elasticsearch服务之前，你应该知道一些事情</h2><div class="mj l"><h3 class="bd b fv z el mh eo ep mi er et ek translated">Elasticsearch是一个强大但脆弱的基础设施，它有很多可能导致AWS服务…</h3></div><div class="mk l"><p class="bd b gc z el mh eo ep mi er et ek translated">read.acloud.guru</p></div></div><div class="ml l"><div class="mm l mn mo mp ml mq jt mc"/></div></div></a></div><p id="17a5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">正如您从上面的截图中看到的，您也可以选择将日志流式传输到Lambda函数。事实上，当您从Lambda控制台创建一个新功能时，已经有很多将CloudWatch日志推送到其他日志聚合服务的蓝图了。</p><p id="f75d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">显然，这是许多AWS客户所要求的。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mr"><img src="../Images/a20c16da3bfbffb622b1a32c9cc6e28f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ykLQaWz4TJUwg4WY0-9JBQ.png"/></div></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">You can find blueprints for shipping CloudWatch Logs to Sumologic, Splunk and Loggly out of the box.</figcaption></figure><p id="dbff" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这很好，现在您可以使用这些蓝图来帮助您编写一个Lambda函数，该函数将CloudWatch日志发送到您首选的日志聚合服务。但是有一些事情要记住。</p><h2 id="7dd0" class="ms kt hu bd ku mt mu mv ky mw mx my lc ke mz na le ki nb nc lg km nd ne li nf dt translated">自动订阅新日志组</h2><p id="e688" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">每当你创建一个新的Lambda函数，它就会在CloudWatch日志中创建一个新的日志组。您希望避免为上面的<code class="eh lp lq lr ls b">ship-logs</code>函数订阅日志组的手动过程。</p><p id="1cc8" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">相反，启用CloudTrail，然后在CloudWatch事件中设置一个事件模式，以便在创建日志组时调用另一个Lambda函数。</p><p id="25b1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">您可以在CloudWatch控制台中手动完成这一一次性设置。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ng"><img src="../Images/ca2957deee62e00c9cfd27b80d692463.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4udOn5bQM8-QAxJFZ2Bb_w.png"/></div></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">Match the CreateLogGroup API call in CloudWatch Logs and trigger a subscribe-log-group Lambda function to subscribe the newly created log group to the ship-logs function you created earlier.</figcaption></figure><p id="163a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果您使用多个AWS帐户，那么您应该避免手动设置。使用无服务器框架，您可以在<code class="eh lp lq lr ls b">serverless.yml</code>文件中为这个<code class="eh lp lq lr ls b">subscribe-log-group</code>函数设置事件源。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nh"><img src="../Images/5f484974653401e395aba8d0d1c4d8c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LKSFD6CgiwyZa4jhEJVp5w.png"/></div></div></figure><p id="cd6a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">另一件要记住的事情是，<strong class="jx hv">你需要避免为</strong> <code class="eh lp lq lr ls b">ship-logs</code> <strong class="jx hv">函数本身订阅日志组——这会创建一个无限的调用循环</strong>,这是你想要避免的痛苦教训。</p><div class="lz ma fm fo mb mc"><a href="https://sourcebox.be/blog/2017/08/07/serverless-a-lesson-learned-the-hard-way/" rel="noopener  ugc nofollow" target="_blank"><div class="md ab ej"><div class="me ab mf cl cj mg"><h2 class="bd hv fv z el mh eo ep mi er et ht dt translated">无服务器:一个教训。艰难的方式。</h2><div class="mj l"><h3 class="bd b fv z el mh eo ep mi er et ek translated">我最近写了一篇关于我如何将我的静态网站从VPS迁移到无服务器堆栈的文章，非常成功..直到…</h3></div><div class="mk l"><p class="bd b gc z el mh eo ep mi er et ek translated">sourcebox.be</p></div></div><div class="ml l"><div class="ni l mn mo mp ml mq jt mc"/></div></div></a></div><h2 id="1bd6" class="ms kt hu bd ku mt mu mv ky mw mx my lc ke mz na le ki nb nc lg km nd ne li nf dt translated">自动设置日志保留策略</h2><p id="523f" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">默认情况下，当Lambda为您的函数创建一个新的日志组时，保留策略是永远保留它们。可以理解，这是多余的，存储所有这些日志的成本会随着时间的推移而增加。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nj"><img src="../Images/81c94351912d9caa89aa9c5b53facb02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O4eoviNdkLRGVpTQujpkwA.png"/></div></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">By default, logs for your Lambda functions are kept forever</figcaption></figure><p id="1e74" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">幸运的是，使用上面的相同技术，我们可以添加另一个Lambda函数来自动更新保留策略，使其更合理。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nk"><img src="../Images/9b02838a864105b0bfcf37dc97fab8e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0rxPRC0tRDWptKPKuC_cOg.png"/></div></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">Here’s a Lambda function for auto-updating the log retention policy to 30 days.</figcaption></figure><h2 id="ceae" class="ms kt hu bd ku mt mu mv ky mw mx my lc ke mz na le ki nb nc lg km nd ne li nf dt translated">管理现有的日志组</h2><p id="e491" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">如果您已经有许多现有的日志组，那么可以考虑将自动订阅日志组和自动更新日志保留策略的演示代码(如下所示)封装到一个一次性脚本中，以便对它们进行更新。</p><p id="cf97" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">您可以通过使用<a class="ae kr" href="http://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeLogGroups.html" rel="noopener ugc nofollow" target="_blank"> DescribeLogGroups </a> API调用遍历所有日志组来实现这一点，然后为每个日志组调用相应的函数。</p><h2 id="7984" class="ms kt hu bd ku mt mu mv ky mw mx my lc ke mz na le ki nb nc lg km nd ne li nf dt translated">查看演示代码</h2><p id="ecd1" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">您可以在这个<a class="ae kr" href="https://github.com/theburningmonk/lambda-logging-demo" rel="noopener ugc nofollow" target="_blank"> repo </a>中找到示例代码。</p><div class="lz ma fm fo mb mc"><a href="https://github.com/theburningmonk/lambda-logging-demo" rel="noopener  ugc nofollow" target="_blank"><div class="md ab ej"><div class="me ab mf cl cj mg"><h2 class="bd hv fv z el mh eo ep mi er et ht dt translated">burning monk/lambda-记录-演示</h2><div class="mj l"><h3 class="bd b fv z el mh eo ep mi er et ek translated">这个演示程序可以将日志发送到ELK堆栈，并自动订阅新的日志组</h3></div><div class="mk l"><p class="bd b gc z el mh eo ep mi er et ek translated">github.com</p></div></div><div class="ml l"><div class="nl l mn mo mp ml mq jt mc"/></div></div></a></div></div><div class="ab cl nm nn hc no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="hn ho hp hq hr"><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="ab fr cl nt"><img src="../Images/8b4e4721bb1973db389b5b533d727ad1.png" data-original-src="https://miro.medium.com/v2/format:webp/0*b_1R345KzKSaI8sg.png"/></div></figure><p id="f870" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">嗨，我的名字是<strong class="jx hv">崔琰</strong>。我是一个<a class="ae kr" href="https://aws.amazon.com/developer/community/heroes/yan-cui/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx hv"> AWS无服务器英雄</strong> </a>和<a class="ae kr" href="https://bit.ly/production-ready-serverless" rel="noopener ugc nofollow" target="_blank"> <strong class="jx hv">量产无服务器</strong> </a>的作者。我已经在AWS中运行了近10年的大规模生产工作负载，我是一名架构师或首席工程师，涉足从银行、电子商务、体育流媒体到移动游戏等多个行业。我目前是一名专注于AWS和无服务器的独立顾问。</p><p id="c37e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">你可以通过<a class="ae kr" href="mailto:theburningmonk.com" rel="noopener ugc nofollow" target="_blank">邮箱</a>、<a class="ae kr" href="https://twitter.com/theburningmonk" rel="noopener ugc nofollow" target="_blank"> Twitter </a>和<a class="ae kr" href="https://www.linkedin.com/in/theburningmonk/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我。</p></div><div class="ab cl nm nn hc no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="hn ho hp hq hr"><p id="404d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">查看我的新课程，<a class="ae kr" href="https://theburningmonk.thinkific.com/courses/complete-guide-to-aws-step-functions" rel="noopener ugc nofollow" target="_blank"><strong class="jx hv">AWS步骤功能完整指南</strong> </a>。</p><p id="a329" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在本课程中，我们将介绍有效使用AWS Step Functions服务所需了解的一切。包括基本概念、HTTP和事件触发器、活动、设计模式和最佳实践。</p><p id="cd40" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在这里拿到你的副本。</p></div><div class="ab cl nm nn hc no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="hn ho hp hq hr"><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nu"><img src="../Images/2faf40b47320300fed81b3e09483ffb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZYcHhOOzUf5VB-Ri.png"/></div></div></figure><p id="ee8c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">来了解AWS Lambda: CI/CD的操作性<strong class="jx hv">最佳实践</strong>，本地测试&amp;调试功能、日志记录、监控、分布式跟踪、canary部署、配置管理、认证&amp;授权、VPC、安全性、错误处理等等。</p><p id="8bb5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">还可以用代码<strong class="jx hv"> ytcui </strong>获得<strong class="jx hv">票面价格6折</strong>。</p><p id="f62a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">点击获取您的副本<a class="ae kr" href="https://bit.ly/production-ready-serverless" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>