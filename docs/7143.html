<html>
<head>
<title>Generated Include Guards: An Alternative to pragma once</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生成包括守卫:一次pragma的替代</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/generated-include-guards-an-alternative-to-pragma-once-31cc3dee6ce?source=collection_archive---------10-----------------------#2017-10-18">https://medium.com/hackernoon/generated-include-guards-an-alternative-to-pragma-once-31cc3dee6ce?source=collection_archive---------10-----------------------#2017-10-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/470a332a6acbe537bb926dd76f4d8edf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Zb883OUY3VwiwhPpJB2TA.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/PxM8hw4j3ZY?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Toa Heftiba</a> on <a class="ae jg" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="3418" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">介绍</h1><p id="e9c2" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">在C++中，没有什么能阻止程序员多次包含头文件。这可能会导致定义重复，这是一个错误。由于很难确保头文件只包含一次，一个常见的策略是只进行第一次包含计数。这可以使用“include guard”来完成，这是一小段预处理器逻辑，如下所示:</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="lh li l"/></div></figure><h2 id="caff" class="lj ji hu bd jj lk ll lm jn ln lo lp jr kq lq lr jv ku ls lt jz ky lu lv kd lw dt translated">它是如何工作的？</h2><p id="4ec2" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">关于第一个包含，由于<code class="eh lx ly lz ma b">HEADER_HAS_BEEN_INCLUDED</code>没有定义，所以我们定义了<code class="eh lx ly lz ma b">foo</code>。在后续的收录中，<code class="eh lx ly lz ma b">HEADER_HAS_BEEN_INCLUDED</code>已经被定义了，所以我们就略过内容。</p><p id="7954" class="pw-post-body-paragraph kf kg hu kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc hn dt translated">例如，如果我们有这个C++文件:</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="lh li l"/></div></figure><p id="83e8" class="pw-post-body-paragraph kf kg hu kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc hn dt translated">然后，它将扩展到以下内容:</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="lh li l"/></div></figure><p id="9393" class="pw-post-body-paragraph kf kg hu kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc hn dt translated">预处理器完成后，我们会看到:</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="lh li l"/></div></figure><p id="60b0" class="pw-post-body-paragraph kf kg hu kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc hn dt translated">这是惯用的方法，但它有一些局限性:</p><ol class=""><li id="396a" class="mg mh hu kh b ki mb km mc kq mi ku mj ky mk lc ml mm mn mo dt translated">需要三行锅炉板代码</li><li id="5c19" class="mg mh hu kh b ki mp km mq kq mr ku ms ky mt lc ml mm mn mo dt translated">第1行和第2行的变量名必须与<em class="mu">完全匹配</em></li><li id="15e4" class="mg mh hu kh b ki mp km mq kq mr ku ms ky mt lc ml mm mn mo dt translated">多个文件中不得使用相同的变量名</li><li id="1b80" class="mg mh hu kh b ki mp km mq kq mr ku ms ky mt lc ml mm mn mo dt translated">我们要记住<code class="eh lx ly lz ma b">#endif</code>，它位于<code class="eh lx ly lz ma b">#ifndef</code>文件的另一端</li></ol><h2 id="b079" class="lj ji hu bd jj lk ll lm jn ln lo lp jr kq lq lr jv ku ls lt jz ky lu lv kd lw dt translated">祈祷文怎么样？</h2><p id="c62a" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated"><code class="eh lx ly lz ma b">#pragma once</code>旨在克服这些问题。这是C++编译器的一个非标准但被广泛支持的特性。概念很简单:任何包含<code class="eh lx ly lz ma b">#pragma once</code>的文件实际上只包含<em class="mu"/>一次，即使程序员多次包含它。</p><p id="d86a" class="pw-post-body-paragraph kf kg hu kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc hn dt translated">使用<code class="eh lx ly lz ma b">#pragma once</code>，我们的示例变成:</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="lh li l"/></div></figure><p id="5023" class="pw-post-body-paragraph kf kg hu kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc hn dt translated">看起来不错，对吧？可悲的是<code class="eh lx ly lz ma b">#pragma once</code>带来了许多问题。</p><p id="cefd" class="pw-post-body-paragraph kf kg hu kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc hn dt translated">根本原因是<code class="eh lx ly lz ma b">#pragma once</code>关心的是<em class="mu">(有些代码在</em>处)而不是它的<em class="mu">内容</em>。如果您可以通过多个路径访问同一文件的两个副本，那么它将被包含两次。而且，如果您有两条路径<em class="mu">看起来</em>不同，但实际上是相同的，那么编译器可能不会发现这一点。更重要的是，它不是标准的，所以编译器实现不必尊重它的语义。</p><h1 id="5266" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">一种可能的解决方法</h1><p id="a4ef" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated"><code class="eh lx ly lz ma b">#pragma once</code>的问题源于这样一个事实，即它在文件的位置工作，而不是它的内容。如果我们只使用内容呢？<em class="mu">(当然，记录每个标题的所有内容会很慢，但是我们可以通过记录内容的散列来优化)。</em></p><p id="651f" class="pw-post-body-paragraph kf kg hu kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc hn dt translated">这个过程将是:</p><p id="fc1c" class="pw-post-body-paragraph kf kg hu kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc hn dt translated">1.当包含头文件时，对其进行哈希处理<br/> 2。如果以前见过哈希，则忽略include <br/> 3。否则，按正常方式包括标题</p><p id="6616" class="pw-post-body-paragraph kf kg hu kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc hn dt translated">这将是一个健壮的解决方案，因为它根本不关心找到文件的路径，只关心它的内容。</p><h1 id="fffa" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">实施变通办法</h1><p id="f039" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">向C++标准中添加一个新命令会花费相当多的时间，但幸运的是，我们可以使用脚本和预处理器来实现这个逻辑。</p><p id="b40f" class="pw-post-body-paragraph kf kg hu kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc hn dt translated">基本想法是这样的:</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="lh li l"/></div></figure><p id="4e8a" class="pw-post-body-paragraph kf kg hu kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc hn dt translated">例如这个标题:</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="lh li l"/></div></figure><p id="722c" class="pw-post-body-paragraph kf kg hu kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc hn dt translated">具有阿沙-256哈希:</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="lh li l"/></div></figure><p id="edce" class="pw-post-body-paragraph kf kg hu kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc hn dt translated">所以生成的头可能是:</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="lh li l"/></div></figure><p id="bd74" class="pw-post-body-paragraph kf kg hu kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc hn dt translated">虽然单个文件的转换很简单(<a class="ae jg" href="https://github.com/njlr/buck-include-guards/blob/84c3a67dcb5eb6d9924cacc4f2c33723beb6245a/scripts/add-include-guard.py" rel="noopener ugc nofollow" target="_blank"> Python脚本</a>)，但是我们仍然需要管理转换过程。我们需要确保:</p><ul class=""><li id="a7bf" class="mg mh hu kh b ki mb km mc kq mi ku mj ky mk lc mv mm mn mo dt translated">为每个文件运行转换</li><li id="0a9b" class="mg mh hu kh b ki mp km mq kq mr ku ms ky mt lc mv mm mn mo dt translated">新文件会自动转换</li><li id="fe97" class="mg mh hu kh b ki mp km mq kq mr ku ms ky mt lc mv mm mn mo dt translated">已删除文件的转换会自动移除</li><li id="d0da" class="mg mh hu kh b ki mp km mq kq mr ku ms ky mt lc mv mm mn mo dt translated">只有当文件发生变化时，转换才会重新运行</li><li id="b4e1" class="mg mh hu kh b ki mp km mq kq mr ku ms ky mt lc mv mm mn mo dt translated"><em class="mu">好处:转换可以安全地放入共享的网络缓存中</em></li></ul><p id="30d8" class="pw-post-body-paragraph kf kg hu kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc hn dt translated">使用<a class="ae jg" href="https://buckbuild.com/" rel="noopener ugc nofollow" target="_blank"> Buck build </a>，我们可以很容易地将这个逻辑编码到项目的构建脚本中。</p><p id="233c" class="pw-post-body-paragraph kf kg hu kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc hn dt translated">让我们从单个文件的构建规则开始，然后进行归纳:</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="lh li l"/></div></figure><p id="d355" class="pw-post-body-paragraph kf kg hu kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc hn dt translated">巴克中的一个<code class="eh lx ly lz ma b">genrule</code>很像马克中的一个目标。我们定义输入文件、输出文件名和要执行的命令。这个目标使用我们的Python脚本来生成include guard，并在<code class="eh lx ly lz ma b">add.hpp</code>上运行它。与Make不同，Buck将隔离并缓存进程的输入散列。</p><p id="20a3" class="pw-post-body-paragraph kf kg hu kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc hn dt translated">现在我们有了一个工作的文件，我们可以把这个过程推广到<code class="eh lx ly lz ma b">n</code>文件。为此，我们创建一个Python函数，为给定的文件创建一个<code class="eh lx ly lz ma b">genrule</code>:</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="lh li l"/></div></figure><p id="f7cb" class="pw-post-body-paragraph kf kg hu kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc hn dt translated">为了获得头文件集，我们运行一个glob表达式。例如:</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="lh li l"/></div></figure><p id="3c0a" class="pw-post-body-paragraph kf kg hu kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc hn dt translated">把这一切结合在一起:</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="lh li l"/></div></figure><p id="47e1" class="pw-post-body-paragraph kf kg hu kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc hn dt translated">你可以在GitHub 上找到完整的<a class="ae jg" href="https://github.com/njlr/buck-include-guards" rel="noopener ugc nofollow" target="_blank">工作示例。</a></p><p id="231f" class="pw-post-body-paragraph kf kg hu kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc hn dt translated">现在，我们的头文件可以在不包含守卫或<code class="eh lx ly lz ma b">#pragma once</code>的情况下编写:</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="lh li l"/></div></figure><p id="24bb" class="pw-post-body-paragraph kf kg hu kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc hn dt translated">Buck中的这个设置非常适合使用:</p><ul class=""><li id="e9c1" class="mg mh hu kh b ki mb km mc kq mi ku mj ky mk lc mv mm mn mo dt translated">头文件中的零锅炉板</li><li id="4cbb" class="mg mh hu kh b ki mp km mq kq mr ku ms ky mt lc mv mm mn mo dt translated">Buck会自动检查新的头文件，因此构建总是最新的</li><li id="f3ec" class="mg mh hu kh b ki mp km mq kq mr ku ms ky mt lc mv mm mn mo dt translated">Buck将删除过时生成的报头</li><li id="b16d" class="mg mh hu kh b ki mp km mq kq mr ku ms ky mt lc mv mm mn mo dt translated">因为它理解目标图，Buck将并行地生成头</li><li id="2087" class="mg mh hu kh b ki mp km mq kq mr ku ms ky mt lc mv mm mn mo dt translated">Buck将缓存生成的头，以便只在需要时才计算它们</li><li id="b7a8" class="mg mh hu kh b ki mp km mq kq mr ku ms ky mt lc mv mm mn mo dt translated">我们不再依赖于人的准确性(包括警卫)或非标准特征(<code class="eh lx ly lz ma b">#pragma once</code>)</li></ul><h1 id="c9c5" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">既然你在这里…</h1><p id="6d0b" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">我们创建了<a class="ae jg" href="https://github.com/LoopPerfect/buckaroo" rel="noopener ugc nofollow" target="_blank"> Buckaroo </a>来使集成C++库变得更容易。如果你想尝试一下，最好从<a class="ae jg" href="https://buckaroo.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">文档</a>开始。你可以在<a class="ae jg" href="https://www.buckaroo.pm/" rel="noopener ugc nofollow" target="_blank"> Buckaroo.pm </a>上浏览现有套餐，或者在<a class="ae jg" href="https://github.com/LoopPerfect/buckaroo-wishlist" rel="noopener ugc nofollow" target="_blank">愿望清单</a>上申请更多套餐。</p><div class="mw mx fm fo my mz"><a href="https://hackernoon.com/approaches-to-c-dependency-management-or-why-we-built-buckaroo-26049d4646e7" rel="noopener  ugc nofollow" target="_blank"><div class="na ab ej"><div class="nb ab nc cl cj nd"><h2 class="bd hv fv z el ne eo ep nf er et ht dt translated">C++依赖管理的方法，或者我们为什么要建立Buckaroo</h2><div class="ng l"><h3 class="bd b fv z el ne eo ep nf er et ek translated">C++是一种不寻常的语言，因为它还没有一个占主导地位的包管理器(我们正在努力！).结果是…</h3></div><div class="nh l"><p class="bd b gc z el ne eo ep nf er et ek translated">hackernoon.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn ja mz"/></div></div></a></div></div></div>    
</body>
</html>