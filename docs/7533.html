<html>
<head>
<title>Testing Stripe with Rails and RSpec</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用导轨和RSpec测试条带</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/testing-stripe-with-rails-and-rspec-de79e1206839?source=collection_archive---------10-----------------------#2017-10-31">https://medium.com/hackernoon/testing-stripe-with-rails-and-rspec-de79e1206839?source=collection_archive---------10-----------------------#2017-10-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/22334c37e9ea80c85411f3b4e0de9e31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4nckzHj32Zaum7Qop2RlOg.png"/></div></div></figure><p id="60d6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然Stripe可能不是到处都有，或者可能不是每个人最具成本效益的卡处理器，但我一次又一次地发现，他们的API和仪表板是经过深思熟虑的，“只是工作”。</p><p id="f7e0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">测试Stripe将比您在应用程序中进行的大多数其他测试更复杂一些。您不仅要负责测试应用程序的行为，还要跟踪第三方API(Stripe)上的远程对象和响应。我将省略一些关于获取Stripe并在您的应用程序中运行的细节，因为它似乎在很多地方都有涉及，并重点关注一些使用RSpec在您的Rails应用程序中测试Stripe的高级技术。</p></div><div class="ab cl ka kb hc kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hn ho hp hq hr"><p id="1082" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果这是你喜欢的内容，那么你将能够从我即将出版的书<a class="ae kh" href="https://buildasaasappinrails.com" rel="noopener ugc nofollow" target="_blank">中看到一个完整的实现(包括一个全面的测试套件)，在Rails 6 </a>中构建一个SaaS应用。这本书指导你从卑微的开始，通过部署一个应用到生产。这本书现在已经开始预售了，你可以马上拿到免费的一章！</p><p id="fe3d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此外，我的新项目<a class="ae kh" href="https://pullmanager.com" rel="noopener ugc nofollow" target="_blank">拉动式管理器</a>的测试版已经发布。如果您失去了对拉取请求的跟踪，让旧的请求留在身边，或者只是喜欢一个通过多个服务(Github、Gitlab和Bitbucket)聚集这些请求的仪表板，<a class="ae kh" href="https://pullmanager.com" rel="noopener ugc nofollow" target="_blank">查看一下</a>。</p></div><div class="ab cl ka kb hc kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hn ho hp hq hr"><h1 id="470f" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">条纹红宝石色</h1><p id="ddec" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated"><a class="ae kh" href="https://github.com/rebelidealist/stripe-ruby-mock" rel="noopener ugc nofollow" target="_blank"> stripe-ruby-mock </a>是一个gem，它允许您在不实际访问外部stripe API服务器的情况下对Stripe进行测试(除非您想要并且能够明确地这样做)。这将使您不必担心外部连接，清理测试数据，并完全控制任何模拟数据。</p><p id="ebd1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于Rails应用程序来说，安装是非常标准的:</p><p id="11a4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">添加<code class="eh ll lm ln lo b">gem 'stripe-ruby-mock', '~&gt; 2.5.0', :require =&gt; 'stripe_mock'</code>，然后再添加一个<code class="eh ll lm ln lo b">bundle install</code>。然后，要开始，您可以将以下内容添加到您的<code class="eh ll lm ln lo b">spec_helper.rb</code>:</p><pre class="lp lq lr ls fq lt lo lu lv aw lw dt"><span id="d173" class="lx kj hu lo b fv ly lz l ma mb">config.before(:each) do<br/>    @stripe_test_helper = StripeMock.create_test_helper<br/>    StripeMock.start<br/>  end</span><span id="c1f2" class="lx kj hu lo b fv mc lz l ma mb">config.after(:each) do<br/>    StripeMock.stop<br/>  end</span></pre><p id="82aa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这将启动模拟服务器并生成一些助手方法(比如在Stripe中创建一个计划或用户)</p><p id="d093" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">安装完成后，您可以遵循这个假设的控制器规范:</p><pre class="lp lq lr ls fq lt lo lu lv aw lw dt"><span id="0b1a" class="lx kj hu lo b fv ly lz l ma mb">RSpec.describe PlansController, type: :controller do<br/>  login_admin</span><span id="ad65" class="lx kj hu lo b fv mc lz l ma mb">describe 'GET #index' do<br/>    it 'returns http success' do<br/>      get :index<br/>      expect(response).to have_http_status(:success)<br/>      expect(assigns(:plans).count).to eq(3)<br/>    end<br/>  end</span><span id="153e" class="lx kj hu lo b fv mc lz l ma mb">describe 'GET #show' do<br/>    let(:plan) { @stripe_test_helper.create_plan(id: 'free', amount: 0) }<br/>    before(:each) do<br/>      PaymentServices::Stripe::Subscription::CreationService.(<br/>        user: @admin,<br/>        account: @admin.account,<br/>        plan: plan.id<br/>      )<br/>      @admin.reload<br/>    end</span><span id="d146" class="lx kj hu lo b fv mc lz l ma mb">it 'returns http success starter token' do<br/>      @stripe_test_helper.create_plan(id: 'starter', amount: 10)<br/>      cus =<br/>        Stripe::Customer<br/>        .retrieve(@admin.account.subscription.stripe_customer_id)<br/>      card = cus.sources.create(source: @stripe_test_helper.generate_card_token)<br/>      @admin.account.subscription.update(stripe_token: card.id)<br/>      get :show, params: {id: 'starter'}<br/>      expect(response).to have_http_status(:redirect)<br/>      expect(flash[:notice]).to eq 'Plan was updated successfully.'<br/>    end</span></pre><p id="7db5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这个控制器规范中(为了示例的简洁，它是部分的)，有一个规范确保<code class="eh ll lm ln lo b">index</code>动作根据您使用的本地或远程计划检索方法显示正确的计划数量。</p><p id="257c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="md">就我个人而言，我喜欢使用本地的yml文件，按需同步计划。</em></p><p id="6247" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，好东西。<code class="eh ll lm ln lo b">let</code>定义允许我们在模拟的Stripe服务器中建立计划，以及创建订阅(这里基于处理Stripe客户和Stripe订阅创建的服务对象)。在特定的<code class="eh ll lm ln lo b">show</code>规范中，创建了另一个计划(需要一个源/卡),并通过Stripe Ruby gem的接口添加了一个新的源/卡。在这种情况下，Stripe希望您获取客户对象，然后通过该客户对源进行更新。完成后，它将被保存到本地订阅记录中。最后，<code class="eh ll lm ln lo b">show</code>动作现在将使用已经连接到规范中本地用户的Stripe客户、订阅和卡来完成它的工作。</p><p id="72bb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这只是如何编写与Stripe接口的控制器操作的一个小示例。接下来，让我们来看一个影响注册工作流的特性规范，它现在支持一些<code class="eh ll lm ln lo b">Plans</code>和Stripe API交互。</p><pre class="lp lq lr ls fq lt lo lu lv aw lw dt"><span id="d9ec" class="lx kj hu lo b fv ly lz l ma mb">require 'rails_helper'<br/>include ActiveJob::TestHelper<br/>ActiveJob::Base.queue_adapter = :test</span><span id="4b63" class="lx kj hu lo b fv mc lz l ma mb">RSpec.feature "SignUpProcesses", type: :feature do<br/>  it "should require the user to sign up and successfully sign up" do</span><span id="daea" class="lx kj hu lo b fv mc lz l ma mb">visit root_path</span><span id="196a" class="lx kj hu lo b fv mc lz l ma mb">click_on 'Sign up'</span><span id="b400" class="lx kj hu lo b fv mc lz l ma mb">find(:xpath, "//a[<a class="ae kh" href="http://twitter.com/href" rel="noopener ugc nofollow" target="_blank">@href</a>='/account/plans/free']").click</span><span id="5e07" class="lx kj hu lo b fv mc lz l ma mb">within "#new_user" do<br/>      fill_in "user_name", with: 'Test'<br/>      fill_in "user_email", with: '<a class="ae kh" href="mailto:test@test.com" rel="noopener ugc nofollow" target="_blank">test@test.com</a>'<br/>      fill_in "user_password", with: 'password123'<br/>      fill_in "user_password_confirmation", with: 'password123'<br/>    end</span><span id="0e94" class="lx kj hu lo b fv mc lz l ma mb">click_button "Sign Up"</span><span id="dbab" class="lx kj hu lo b fv mc lz l ma mb">expect(current_path).to eql(new_accounts_path)</span><span id="5ac8" class="lx kj hu lo b fv mc lz l ma mb">within "#new_account" do<br/>      fill_in "account_name", with: "Test Co"<br/>    end</span><span id="0bb6" class="lx kj hu lo b fv mc lz l ma mb">expect do<br/>      click_button "Save"<br/>      expect(ActionMailer::Base.deliveries.last.to).to eq ["<a class="ae kh" href="mailto:test@test.com" rel="noopener ugc nofollow" target="_blank">test@test.com</a>"]<br/>      expect(current_path).to eql(root_path)<br/>    end<br/>  end</span></pre><p id="7d32" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然这没有直接使用StripeMock的助手或服务器，但它实际上会将所有客户和订阅更改保存到本地StripeMock实例中(顺便说一下，该实例会在每次测试之间重置)。</p><p id="8745" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">无论如何，点击<code class="eh ll lm ln lo b">Sign Up</code>会把你带到一个<code class="eh ll lm ln lo b">plans#index</code>页面。在该页面上，您可以点击一个链接，选择开始试用的计划。一旦完成，该计划将通过注册过程的继续，最终在一个服务对象中使用，该服务对象将条带创建委托给之前的同一个<code class="eh ll lm ln lo b">CreationService</code>类。</p><p id="d3ec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果条带订阅有任何问题，工作流不会在<code class="eh ll lm ln lo b">root_path</code>结束，也不会失败测试。您甚至可以更进一步，让该功能访问您的应用程序的计费部分，并确保选择的计划是显示为<code class="eh ll lm ln lo b">current</code>的计划。</p><h1 id="6e09" class="ki kj hu bd kk kl me kn ko kp mf kr ks kt mg kv kw kx mh kz la lb mi ld le lf dt translated">Webhooks！</h1><p id="3952" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">没有提到Webhooks，关于条带的讨论是不完整的。如果您从未听说过Webhooks，这意味着当第三方服务做出的更改不是来自API调用的直接结果时，它会向应用程序发送一个HTTP请求来处理这样的事件。举一个更具体的例子，假设几天后有一笔付款。Stripe将创建一个事件invoice.upcoming，并向Rails应用程序指定用于接收此类事件的端点广播一个HTTP请求。然后，由您的应用程序来处理事件。</p><p id="3491" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在进入条纹网钩的规范之前。让我继续为<a class="ae kh" href="https://github.com/integrallis/stripe_event" rel="noopener ugc nofollow" target="_blank">条纹事件</a>宝石欢呼吧。作为一名优秀的软件维护者，我喜欢确保gem安装是值得的。Stripe_event是一个设置WebhooksController的小型gem，以及一个添加了一点元编程的小型类文件集。它使用ActiveSupport::Notifications将事件传递给处理代码的您(您可以在块之间进行选择，或者向您选择的类发送. call)。</p><p id="de6c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">也就是说，通过StripeMock测试webhook是另一个快速的设置。</p><pre class="lp lq lr ls fq lt lo lu lv aw lw dt"><span id="2f62" class="lx kj hu lo b fv ly lz l ma mb">require 'rails_helper'<br/>include ActiveJob::TestHelper</span><span id="1c2e" class="lx kj hu lo b fv mc lz l ma mb">RSpec.describe Payments::InvoicePaymentSucceeded, type: :mailer do<br/>  let(:plan) { @stripe_test_helper.create_plan(id: 'free', amount: 0) }</span><span id="c13c" class="lx kj hu lo b fv mc lz l ma mb">before(:each) do<br/>    @admin = FactoryGirl.create(:user, email: '<a class="ae kh" href="mailto:awesome@dabomb.com" rel="noopener ugc nofollow" target="_blank">awesome@dabomb.com</a>')<br/>    PaymentServices::Stripe::Subscription::CreationService.(<br/>      user: @admin,<br/>      account: @admin.account,<br/>      plan: plan.id<br/>    )<br/>    @event = StripeMock.mock_webhook_event(<br/>      'invoice.payment_succeeded',<br/>      customer: @admin.account.subscription.stripe_customer_id,<br/>      subscription: @admin.account.subscription.stripe_subscription_id<br/>    )<br/>  end</span><span id="853f" class="lx kj hu lo b fv mc lz l ma mb">it 'job is created' do<br/>    ActiveJob::Base.queue_adapter = :test<br/>    expect do<br/>      Payments::InvoicePaymentSucceeded.email(@event.id).deliver_later<br/>    end.to have_enqueued_job.on_queue('mailers')<br/>  end</span><span id="7672" class="lx kj hu lo b fv mc lz l ma mb">it 'email is sent' do<br/>    expect do<br/>      perform_enqueued_jobs do<br/>        Payments::InvoicePaymentSucceeded.email(@event.id).deliver_later<br/>      end<br/>    end.to change { ActionMailer::Base.deliveries.size }.by(1)<br/>  end</span></pre><p id="2188" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">设置看起来非常相似。通过StripeMock帮助器添加计划。然后，在每个规范之前，FactoryGirl/FactoryBot会创建一个<code class="eh ll lm ln lo b">@admin</code>用户。创建后，将设置客户和订阅。最后，创建一个模拟webhook事件。这是这里的重要部分，因为StripeEvent或您自己的Webhook处理代码将从Stripe中检索事件。因此，我们的测试需要一个模拟版本。</p><p id="cf44" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">默认情况下，StripeMock实际上在gem结构内的JSON fixtures中保留了大多数webhook事件的副本。但是，对于每种类型的事件，您可以覆盖特定的属性。这里，为了确保事件为正确的客户带来订阅，在创建模拟事件的第二个参数中覆盖了它们。</p><p id="a883" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦解决了这个问题，一切就都正常了。在规范开始的情况下，在将一个事件传递给邮件程序时，它确保邮件程序“完成了它的工作”,并将邮件排队到正确的队列中。</p><p id="8b73" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">StripeMock的另一个很酷的地方是能够让特定的请求抛出一个错误，从而允许您测试您的错误处理逻辑。语法非常简单，但是需要您查找特定请求类型/端点的符号定义:</p><pre class="lp lq lr ls fq lt lo lu lv aw lw dt"><span id="17a2" class="lx kj hu lo b fv ly lz l ma mb">StripeMock.prepare_error(<br/>        Stripe::InvalidRequestError.new('s', {}),<br/>        :get_charges<br/> )</span></pre><p id="1790" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里，我们指定下次调用<code class="eh ll lm ln lo b">Stripe::Charge.list</code>时要引发的<code class="eh ll lm ln lo b">Stripe::InvalidRequestError</code>。</p><h1 id="5c62" class="ki kj hu bd kk kl me kn ko kp mf kr ks kt mg kv kw kx mh kz la lb mi ld le lf dt translated">你用什么？</h1><p id="73ee" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">那是一个在几个不同的地方进行高水平测试的条纹。以及一些有助于条带实现(和测试)的工具。</p><p id="162c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在利用Stripe时，您使用或实施了什么(并按照您应该的方式进行测试)？</p></div></div>    
</body>
</html>