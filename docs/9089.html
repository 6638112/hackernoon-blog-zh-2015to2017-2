<html>
<head>
<title>A (mostly) automated release process</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">(大部分)自动化的发布过程</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-mostly-automated-release-process-63bb9516985a?source=collection_archive---------7-----------------------#2017-12-26">https://medium.com/hackernoon/a-mostly-automated-release-process-63bb9516985a?source=collection_archive---------7-----------------------#2017-12-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="120e" class="pw-subtitle-paragraph is ht hu bd b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj ek translated">自动化你能自动化的事情，并分担剩余任务的责任</h2></div><p id="3bb0" class="pw-post-body-paragraph jk jl hu jm b jn jo iw jp jq jr iz js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">访问https://www.mikenikles.com的<a class="ae kg" href="https://www.mikenikles.com" rel="noopener ugc nofollow" target="_blank"><strong class="jm hv"/></a><strong class="jm hv">获取我的最新博文。</strong></p><p id="adc3" class="pw-post-body-paragraph jk jl hu jm b jn jo iw jp jq jr iz js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated"><em class="kh">这篇博文是我分享我们从部署在AWS上的单片应用程序(每个都有自己的源代码库)迁移到部署在Google云平台上的分布式服务架构(所有源代码都托管在monorepo中)的系列文章的一部分。</em></p><ul class=""><li id="825f" class="ki kj hu jm b jn jo jq jr jt kk jx kl kb km kf kn ko kp kq dt translated"><em class="kh">第一部分:</em> <a class="ae kg" href="https://hackernoon.com/a-monorepo-github-flow-and-automation-ftw-c41a2d9c48bb" rel="noopener ugc nofollow" target="_blank"> <em class="kh">一个monorepo，GitHub流和自动化FTW</em></a><em class="kh"/></li><li id="c092" class="ki kj hu jm b jn kr jq ks jt kt jx ku kb kv kf kn ko kp kq dt translated"><em class="kh">第2部分:“</em> <a class="ae kg" rel="noopener" href="/@mikenikles/one-vs-many-why-we-moved-from-multiple-git-repos-to-a-monorepo-and-how-we-set-it-up-f4abb0cfe469"> <em class="kh">一对多——为什么我们从多个git回购转移到单一回购，以及我们如何设置它</em></a><em class="kh">”</em></li><li id="8df2" class="ki kj hu jm b jn kr jq ks jt kt jx ku kb kv kf kn ko kp kq dt translated"><em class="kh">第三部分(这篇文章):“一个(大部分)自动化的发布过程”</em></li><li id="91bd" class="ki kj hu jm b jn kr jq ks jt kt jx ku kb kv kf kn ko kp kq dt translated"><em class="kh">第四部分:</em> <a class="ae kg" rel="noopener" href="/@mikenikles/our-approach-to-software-development-consistency-d101995bb843">我们对软件开发一致性的方法</a><em class="kh"/></li><li id="8fc7" class="ki kj hu jm b jn kr jq ks jt kt jx ku kb kv kf kn ko kp kq dt translated"><em class="kh">第5部分(即将推出):“本地调试微服务”</em></li></ul><h1 id="6a81" class="kw kx hu bd ky kz la lb lc ld le lf lg jb lh jc li je lj jf lk jh ll ji lm ln dt translated">什么是“发布过程”？</h1><blockquote class="lo lp lq"><p id="f056" class="jk jl kh jm b jn jo iw jp jq jr iz js lr ju jv jw ls jy jz ka lt kc kd ke kf hn dt translated">发布管理是通过不同的阶段和环境管理、计划、调度和控制软件构建的过程；包括测试和部署软件版本。<br/>来源:<a class="ae kg" href="https://en.wikipedia.org/wiki/Release_management" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="c264" class="pw-post-body-paragraph jk jl hu jm b jn jo iw jp jq jr iz js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">哇…这是一个很长的句子，它让我想起了我在🇨🇭.长大时写的德语句子</p><p id="68cd" class="pw-post-body-paragraph jk jl hu jm b jn jo iw jp jq jr iz js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">一种稍微不那么冗长的说法是:</p><blockquote class="lo lp lq"><p id="6600" class="jk jl kh jm b jn jo iw jp jq jr iz js lr ju jv jw ls jy jz ka lt kc kd ke kf hn dt translated">“如何将代码从我的笔记本电脑转移到生产中。”<br/>来源:<a class="ae kg" href="https://twitter.com/mikenikles" rel="noopener ugc nofollow" target="_blank">我</a></p></blockquote><p id="6f44" class="pw-post-body-paragraph jk jl hu jm b jn jo iw jp jq jr iz js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">最终，一切都与代码有关，在这个过程中，我们希望对代码做某些事情。比如:</p><ul class=""><li id="15a8" class="ki kj hu jm b jn jo jq jr jt kk jx kl kb km kf kn ko kp kq dt translated"><a class="ae kg" href="https://en.wikipedia.org/wiki/KISS_principle" rel="noopener ugc nofollow" target="_blank">吻</a>；像<a class="ae kg" href="https://eslint.org/docs/about/" rel="noopener ugc nofollow" target="_blank"> ESLint </a>这样的工具可以帮上忙。</li><li id="b60f" class="ki kj hu jm b jn kr jq ks jt kt jx ku kb kv kf kn ko kp kq dt translated">保持格式一致。<a class="ae kg" href="https://prettier.io/" rel="noopener ugc nofollow" target="_blank">更漂亮</a>是你在这里的必备工具。</li><li id="b7be" class="ki kj hu jm b jn kr jq ks jt kt jx ku kb kv kf kn ko kp kq dt translated">运行测试。</li><li id="3fb0" class="ki kj hu jm b jn kr jq ks jt kt jx ku kb kv kf kn ko kp kq dt translated">将可重用的代码打包成包，并部署到NPM。</li><li id="5b06" class="ki kj hu jm b jn kr jq ks jt kt jx ku kb kv kf kn ko kp kq dt translated">构建利用上述包的服务。</li><li id="4230" class="ki kj hu jm b jn kr jq ks jt kt jx ku kb kv kf kn ko kp kq dt translated">给涉众一个在或多或少安全的环境中评审代码的机会，通常被称为“阶段化”。</li><li id="21b6" class="ki kj hu jm b jn kr jq ks jt kt jx ku kb kv kf kn ko kp kq dt translated">将经过评审的代码部署到真正重要的地方:🥁……<br/>生产环境🎉</li></ul><h1 id="af2e" class="kw kx hu bd ky kz la lb lc ld le lf lg jb lh jc li je lj jf lk jh ll ji lm ln dt translated">为什么是“自动化”？</h1><p id="c828" class="pw-post-body-paragraph jk jl hu jm b jn lu iw jp jq lv iz js jt lw jv jw jx lx jz ka kb ly kd ke kf hn dt translated">很好的问题，很高兴你问了。主要是因为我们可以。然而更重要的是，我认识的大多数开发人员日复一日地写代码，因为当他们发布帮助他人的软件时，他们感觉很好(你的里程数可能会有所不同)。很少(从来没有？)我是否遇到过热情的开发人员，他们会说，“你知道，我就是喜欢手动将ssh导入我的虚拟机，运行<code class="eh lz ma mb mc b">git pull</code>，然后运行<code class="eh lz ma mb mc b">sh ./scripts/release-carefully.sh --production=true</code>，然后抱最好的希望🤞".</p><p id="c461" class="pw-post-body-paragraph jk jl hu jm b jn jo iw jp jq jr iz js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">根据经验法则，</p><blockquote class="lo lp lq"><p id="d656" class="jk jl kh jm b jn jo iw jp jq jr iz js lr ju jv jw ls jy jz ka lt kc kd ke kf hn dt translated">如果一项任务可以在手工执行的时间内自动完成，那么就自动完成它。现在。</p></blockquote><p id="d288" class="pw-post-body-paragraph jk jl hu jm b jn jo iw jp jq jr iz js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">原因如下:热情的软件工程师希望把时间花在处理更重要的事情上。对于软件行业的任何人来说，自动化日常任务应该是优先考虑的事情。让我们计算一下，看看为什么:</p><ul class=""><li id="406b" class="ki kj hu jm b jn jo jq jr jt kk jx kl kb km kf kn ko kp kq dt translated">将一项新功能手动部署到您的试运行环境大约需要21分钟。</li><li id="1c7c" class="ki kj hu jm b jn kr jq ks jt kt jx ku kb kv kf kn ko kp kq dt translated">你一天做一次，一周五天。</li><li id="8208" class="ki kj hu jm b jn kr jq ks jt kt jx ku kb kv kf kn ko kp kq dt translated">数学是这样的:21分钟x每周5天=每周105分钟x 4周=每月420分钟。</li></ul><figure class="me mf mg mh fq mi fe ff paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="fe ff md"><img src="../Images/627d4727b6a65f7a5cf458e6b78ea17d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I2UEJj2yLfpeH734V8oT0A.png"/></div></div><figcaption class="mp mq fg fe ff mr ms bd b be z ek">Source: <a class="ae kg" href="https://www.google.ca/search?ei=5j4_Wv2MOpiajwOvjLz4CQ&amp;q=400+minutes+to+hours&amp;oq=400+minutes+to+hours&amp;gs_l=psy-ab.3..0j0i5i10i30k1j0i5i30k1j0i8i30k1l2.126360.126360.0.126726.1.1.0.0.0.0.176.176.0j1.1.0....0...1.1.64.psy-ab..0.1.175....0.Tsb9aXPHVHE" rel="noopener ugc nofollow" target="_blank">Google</a></figcaption></figure><p id="4fa2" class="pw-post-body-paragraph jk jl hu jm b jn jo iw jp jq jr iz js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">每月七小时是<strong class="jm hv"> 1个完整工作日</strong>。作为读者的一个练习，您可以添加部署到生产环境所需的时间，以及处理潜在的修补程序部署。</p><p id="b59a" class="pw-post-body-paragraph jk jl hu jm b jn jo iw jp jq jr iz js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">比方说，你最终得到2到3个工作日的总数。与其月复一月地花费时间，不如投入到编写自动化脚本中。在第二个月，你将有2到3个额外的工作日，在那里你可以指导一个更初级的团队成员或者组织一次午餐&amp;学习与你所在城市的社区分享你的发布自动化脚本的细节🙌。</p><h1 id="6516" class="kw kx hu bd ky kz la lb lc ld le lf lg jb lh jc li je lj jf lk jh ll ji lm ln dt translated">为什么是“大部分”？</h1><p id="c128" class="pw-post-body-paragraph jk jl hu jm b jn lu iw jp jq lv iz js jt lw jv jw jx lx jz ka kb ly kd ke kf hn dt translated">我还没有遇到过一个软件应用程序100%自动化的发布过程。虽然这对于库、框架等来说肯定是可以实现的。对于一个应用程序来说，它是一个不同的怪兽。</p><p id="9075" class="pw-post-body-paragraph jk jl hu jm b jn jo iw jp jq jr iz js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">至少，在我们开始自动化发布过程之前，这就是我们的工作目标，自动化发布需要两个人工批准:</p><ol class=""><li id="4cf3" class="ki kj hu jm b jn jo jq jr jt kk jx kl kb km kf mt ko kp kq dt translated">部署到暂存区。</li><li id="1b34" class="ki kj hu jm b jn kr jq ks jt kt jx ku kb kv kf mt ko kp kq dt translated">部署到生产中。</li></ol><h1 id="ea82" class="kw kx hu bd ky kz la lb lc ld le lf lg jb lh jc li je lj jf lk jh ll ji lm ln dt translated">所以…这是我们发布服务的方式</h1><p id="22a1" class="pw-post-body-paragraph jk jl hu jm b jn lu iw jp jq lv iz js jt lw jv jw jx lx jz ka kb ly kd ke kf hn dt translated">记住上面的内容，下面的图表，我在本系列的第一篇博客文章中简要提到过，概述了我们的(大部分)自动化发布过程:</p><figure class="me mf mg mh fq mi fe ff paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="fe ff mu"><img src="../Images/58bf9b1057955392362e2c11ef78e853.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i8ySffq8oMkVGng82RkDlw.png"/></div></div></figure><p id="fef0" class="pw-post-body-paragraph jk jl hu jm b jn jo iw jp jq jr iz js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">如你所见，我们使用<a class="ae kg" href="https://circleci.com/" rel="noopener ugc nofollow" target="_blank"> CircleCI </a>。使用CircleCI 2.0和<a class="ae kg" href="https://circleci.com/docs/2.0/workflows/" rel="noopener ugc nofollow" target="_blank">工作流</a>，上述内容会转化为以下<code class="eh lz ma mb mc b"><a class="ae kg" href="https://circleci.com/docs/2.0/configuration-reference/" rel="noopener ugc nofollow" target="_blank">.circleci/config.yml</a></code>文件:</p><figure class="me mf mg mh fq mi"><div class="bz el l di"><div class="mv mw l"/></div></figure><p id="ac9c" class="pw-post-body-paragraph jk jl hu jm b jn jo iw jp jq jr iz js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">您会注意到7个已配置的工作流作业，它们对应于上图中的7个矩形。</p><p id="8e25" class="pw-post-body-paragraph jk jl hu jm b jn jo iw jp jq jr iz js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">我们在部署工作中调用的<code class="eh lz ma mb mc b">yarn deploy:*</code>脚本是围绕谷歌云平台<code class="eh lz ma mb mc b">gcloud</code> CLI的瘦包装器。脚本运行一些验证和一些逻辑来处理试运行和生产的情况。</p><p id="1498" class="pw-post-body-paragraph jk jl hu jm b jn jo iw jp jq jr iz js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">这对我们来说是全新的。它工作得很好，但是我们总是在寻找加速或者简化过程的方法。下一个主要步骤是集成一种为每个包/服务自动创建<code class="eh lz ma mb mc b">CHANGELOG.md</code>文件的方法，并让系统在发布到NPM时确定合适的<a class="ae kg" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank"> semver </a>版本。类似于https://conventionalcommits.org/的东西看起来很有趣🤔。</p><h1 id="aa2b" class="kw kx hu bd ky kz la lb lc ld le lf lg jb lh jc li je lj jf lk jh ll ji lm ln dt translated">结论</h1><p id="ea34" class="pw-post-body-paragraph jk jl hu jm b jn lu iw jp jq lv iz js jt lw jv jw jx lx jz ka kb ly kd ke kf hn dt translated">这是一个有起有落的伟大旅程，但最终的结果是让我们的日常生活变得简单。</p><p id="9722" class="pw-post-body-paragraph jk jl hu jm b jn jo iw jp jq jr iz js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">从2018年开始，每个微服务都将有所有者，一个至少由两名开发者组成的团队。作为服务所有者，遵循“您构建它，您运行它”的原则。通过这篇博文中描述的发布过程，每个拉请求在被合并到<code class="eh lz ma mb mc b">master</code>之前都被部署到生产中。所有者不仅要负责开发，还要负责服务的部署、监控和支持。如果有bug，公司的任何人都可以在他们不拥有的服务中打开PRs。尽管<a class="ae kg" href="https://help.github.com/articles/about-codeowners/" rel="noopener ugc nofollow" target="_blank">服务所有者将拥有批准PRs </a>的最终决定权。</p><p id="91d5" class="pw-post-body-paragraph jk jl hu jm b jn jo iw jp jq jr iz js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">如果您对上述方法有任何问题、想法、建议等，请告诉我。我很乐意讨论和学习其他人如何部署到生产中。</p></div></div>    
</body>
</html>