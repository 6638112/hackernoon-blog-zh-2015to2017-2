<html>
<head>
<title>Serverless Applications: continuous delivery with AWS Lambda and API Gateway — Part 2: Deploying Lambda</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器应用程序:使用AWS Lambda和API网关的连续交付—第2部分:部署Lambda</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/serverless-applications-continuous-delivery-with-aws-lambda-and-api-gateway-part-2-deploying-87e3a95236f8?source=collection_archive---------0-----------------------#2016-08-30">https://medium.com/hackernoon/serverless-applications-continuous-delivery-with-aws-lambda-and-api-gateway-part-2-deploying-87e3a95236f8?source=collection_archive---------0-----------------------#2016-08-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/0ed31b867a8cd42ddd5f6c58dda0ace6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XySU6apSrqR6rkFC_zBTTw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">We built a serverless microservice to manage our customers’ pipeline configuration in <a class="ae jg" href="https://ironsrc.com/atom" rel="noopener ugc nofollow" target="_blank">ironSource atom</a></figcaption></figure><h2 id="6708" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">概述</h2><p id="7b3c" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz hn dt translated">在本系列的<a class="ae jg" rel="noopener" href="/@rotemtam/serverless-applications-continuous-delivery-with-aws-lambda-and-api-gateway-part-1-unit-tests-e517aa1cd09e#.3ozw2q6nd">前一部分</a>中，我们开始讲述我们在<a class="ae jg" href="http://ironsrc.com/atom" rel="noopener ugc nofollow" target="_blank"> ironSource atom </a>中创建的无服务器微服务的故事，以帮助我们管理客户大数据管道的配置。我们讨论了我们从与<a class="ae jg" href="https://hackernoon.com/tagged/aws" rel="noopener ugc nofollow" target="_blank"> AWS </a> Lambda和API Gateway的合作中获得的巨大收益，以及在我们的生产环境中的普遍安心。但是我们也回顾了开发过程中的一些痛点。这些痛点让我们踏上了构建部署无服务器微服务的自动化流程的道路。</p><p id="4447" class="pw-post-body-paragraph kf kg hu kh b ki la kk kl km lb ko kp js lc kr ks jw ld ku kv ka le kx ky kz hn dt translated">在这个三部曲的第一部分(你现在正在阅读“帝国反击战”)中，我们讨论了在Node.js中为我们的Lambda函数设置适当的单元测试，因此我们可以在自己的机器上愉快地开发。</p><p id="1f4f" class="pw-post-body-paragraph kf kg hu kh b ki la kk kl km lb ko kp js lc kr ks jw ld ku kv ka le kx ky kz hn dt translated">在这一部分中，我们将描述一些我们采用的工具和我们开发的与AWS Lambda实际交互的实践，因为直接使用Amazon的UI会很麻烦并且容易出错。</p><h2 id="b6a3" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">引入Apex</h2><p id="05b2" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz hn dt translated">首先，目前市场上有几种工具可以帮助简化Lambda的工作流程，从小型实用程序库到成熟的解决方案，如“<a class="ae jg" href="http://serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器</a>”(现在处于测试阶段)。评估不同的解决方案时，我们选择了<a class="ae jg" href="http://apex.run" rel="noopener ugc nofollow" target="_blank"> Apex </a>。它的简约方式吸引了我们，它有很好的文档记录，并且似乎有一个相当规模的开发者社区(目前GitHub上有超过3.5k颗星)。</p><p id="b1d7" class="pw-post-body-paragraph kf kg hu kh b ki la kk kl km lb ko kp js lc kr ks jw ld ku kv ka le kx ky kz hn dt translated">Apex易于使用，并且有良好的文档记录，因此我不会在这里详细介绍如何设置或开始使用它。相反，我更愿意回顾一下我们在团队中是如何使用它的。Apex依赖于一些非常简单的JSON文件来描述配置，并依赖于项目的预定义结构。在本帖中，我们将致力于一个假设的微服务，它允许其他人在GitHub中搜索存储库。该服务将公开一个端点:<em class="lf">“GET/repos”</em>并接收查询字符串中的输入，如<em class="lf">“/repos？q=rotemtam" </em>。使用Apex，我们的示例项目结构如下所示:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lk ll l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Apex sample project structure (view the source <a class="ae jg" href="https://github.com/rotemtam/serverless-ci-example" rel="noopener ugc nofollow" target="_blank">here</a>)</figcaption></figure><ul class=""><li id="39c3" class="lm ln hu kh b ki la km lb js lo jw lp ka lq kz lr ls lt lu dt translated">在我们项目的<em class="lf"> "src/" </em>目录中，我们有一个<em class="lf"> project.json </em>文件，它向Apex描述了项目的一般情况</li><li id="acc3" class="lm ln hu kh b ki lv km lw js lx jw ly ka lz kz lr ls lt lu dt translated">我们有一个<em class="lf">函数</em>目录，每个Lambda函数都有一个单独的目录。</li><li id="ed68" class="lm ln hu kh b ki lv km lw js lx jw ly ka lz kz lr ls lt lu dt translated">在每个函数的目录中，我们有一个<em class="lf"> function.json </em>文件来描述这个特定函数的配置。</li><li id="574f" class="lm ln hu kh b ki lv km lw js lx jw ly ka lz kz lr ls lt lu dt translated">我们稍后将进入Dockerfile和"<em class="lf"> infra/" </em>目录。</li></ul><p id="2b06" class="pw-post-body-paragraph kf kg hu kh b ki la kk kl km lb ko kp js lc kr ks jw ld ku kv ka le kx ky kz hn dt translated">当我们运行<em class="lf"> "apex deploy" </em>时，apex将在我们的AWS帐户中创建新版本的功能并更新配置。</p><h2 id="cfe7" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">共享函数间的依赖关系</h2><p id="27d1" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz hn dt translated">TJ Holowaychuk(Apex的创建者之一)最近发表了一篇关于Medium的文章，里面有一些“<a class="ae jg" rel="noopener" href="/@tjholowaychuk/dos-and-don-ts-of-aws-lambda-7dfcab7ad115#.wd4iyh5nz">AWS Lambda</a>的该做和不该做的事情”，其中一条与我们的话题非常相关:“不要用编写好的库来代替FaaS”，这基本上意味着你实际的Lambda函数应该非常小。您应该利用您的语言中的包/模块系统，将您需要的任何逻辑封装在普通模块中并使用它。一般的经验法则是:在Lambda函数中处理输入和高级流控制，剩下的交给你的库。这样，您可以在其他上下文中轻松地重用它们。</p><p id="5c48" class="pw-post-body-paragraph kf kg hu kh b ki la kk kl km lb ko kp js lc kr ks jw ld ku kv ka le kx ky kz hn dt translated">还记得我们假设的搜索GitHub的微服务吗？好吧，假设它包含一个Lambda函数，该函数接受一个字符串<em class="lf"> q </em>作为输入，并使用它在GitHub中搜索名称中包含该字符串的存储库。没有理由在我们的Lambda函数中包含对GitHub API的调用。相反，我们可以这样做:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="2739" class="pw-post-body-paragraph kf kg hu kh b ki la kk kl km lb ko kp js lc kr ks jw ld ku kv ka le kx ky kz hn dt translated">它依赖于这样一个“存储库”模块:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="c1c3" class="pw-post-body-paragraph kf kg hu kh b ki la kk kl km lb ko kp js lc kr ks jw ld ku kv ka le kx ky kz hn dt translated">默认情况下，Apex将获取函数目录中的任何内容，将其放入zip文件并上传到Lambda。所以基本上，如果你想包括你写的任何模块或来自NPM的第三方的东西，你需要把它放在那里。这对于只有一个函数的项目来说很好，但是如果有几个共享模块的函数呢？你会为每个函数创建一个Node.js <em class="lf"> package.json文件</em>并管理每个函数的依赖关系吗？将您的自定义模块复制并粘贴到每个文件夹中？</p><h2 id="67b1" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">使用Webpack和Apex挂钩创建可部署的工件</h2><p id="0b68" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz hn dt translated">幸运的是，Apex允许您通过指定生命周期挂钩来自定义您的构建过程，即自定义<em class="lf">“构建”</em>和<em class="lf">“清理”</em>命令。我们利用这一点来利用<a class="ae jg" href="https://webpack.github.io/" rel="noopener ugc nofollow" target="_blank"> Webpack </a>来创建我们可部署的工件。在构建时，webpack将智能地创建一个Javascript文件，apex将压缩并部署该文件。这里有一个Apex <em class="lf"> project.json </em>文件的示例，取自我们的<a class="ae jg" href="https://github.com/rotemtam/serverless-ci-example" rel="noopener ugc nofollow" target="_blank">示例回购</a>:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="7602" class="pw-post-body-paragraph kf kg hu kh b ki la kk kl km lb ko kp js lc kr ks jw ld ku kv ka le kx ky kz hn dt translated">这种方法的唯一警告是官方的AWS Javascript SDK与Webpack不兼容。查看<a class="ae jg" href="https://github.com/apex/apex/issues/217#issuecomment-194240278" rel="noopener ugc nofollow" target="_blank">该讨论</a>以了解更多信息。对我们来说幸运的是，原来SDK是预先捆绑在Lambda上下文中的(非常感谢<a class="ae jg" href="https://github.com/vdel26" rel="noopener ugc nofollow" target="_blank">维克托·德尔加多</a>指出了这一点)，所以我们基本上可以告诉webpack在我们的webpack配置中忽略它:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lk ll l"/></div></figure><h2 id="60a9" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">将事物连接到CI/CD服务</h2><p id="5228" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz hn dt translated">我们流程的下一部分是将它连接到CI/CD服务。我们目前使用<a class="ae jg" href="https://jenkins.io/" rel="noopener ugc nofollow" target="_blank"> Jenkins </a>和<a class="ae jg" href="https://codefresh.io/" rel="noopener ugc nofollow" target="_blank"> Codefresh </a>来构建我们的版本，但这可以很容易地用任何其他服务来完成。让我们列出微服务构建工作的要求:</p><ul class=""><li id="4d46" class="lm ln hu kh b ki la km lb js lo jw lp ka lq kz lr ls lt lu dt translated">安装所有必需的软件包，安装Apex。</li><li id="d45e" class="lm ln hu kh b ki lv km lw js lx jw ly ka lz kz lr ls lt lu dt translated">运行单元测试，如果失败就退出。</li><li id="4bcf" class="lm ln hu kh b ki lv km lw js lx jw ly ka lz kz lr ls lt lu dt translated">运行“apex deploy”将我们的Lambda函数推向生产。</li><li id="d7e3" class="lm ln hu kh b ki lv km lw js lx jw ly ka lz kz lr ls lt lu dt translated">(构建一个描述我们的API网关的Swagger文件)——我们将在下一篇文章中讨论这个问题</li><li id="3e3b" class="lm ln hu kh b ki lv km lw js lx jw ly ka lz kz lr ls lt lu dt translated">(重新部署我们的API网关)—即将推出！</li></ul><h2 id="f898" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">在Docker容器中构建</h2><p id="4651" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz hn dt translated">如果不在某个地方使用Docker，没有一个真正的hip部署过程是完整的，对吗？不过说真的，在构建过程中使用Docker有很多好处。</p><p id="fdb6" class="pw-post-body-paragraph kf kg hu kh b ki la kk kl km lb ko kp js lc kr ks jw ld ku kv ka le kx ky kz hn dt translated">人们通常认为Docker容器用于运行生产任务。Docker容器确实是完全控制代码运行环境的好方法。使用Docker，您可以拥有生产环境的精确副本。但是同样的好处也适用于任何其他类型的任务，真的。通过在Docker中运行CI/CD任务，您可以完全控制事情发生的方式，并且可以使用任何您喜欢的工具。我通常发现在Docker容器中运行我的构建更容易(也更快)。这里有一个docker文件，我会用它来完成我们上面描述的任务:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lk ll l"/></div></figure><h2 id="c01b" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">我们最终的构建脚本</h2><p id="86d9" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz hn dt translated">我们的构建脚本可能如下所示:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="c6bb" class="pw-post-body-paragraph kf kg hu kh b ki la kk kl km lb ko kp js lc kr ks jw ld ku kv ka le kx ky kz hn dt translated">让我们来分解一下:</p><ul class=""><li id="2581" class="lm ln hu kh b ki la km lb js lo jw lp ka lq kz lr ls lt lu dt translated">根据构建作业运行的位置，您可能需要设置AWS环境变量。例如，如果您从一个EC2实例运行，该实例有一个允许它与Lambda交互的角色，那么您就不需要它。</li><li id="8db7" class="lm ln hu kh b ki lv km lw js lx jw ly ka lz kz lr ls lt lu dt translated">Apex需要知道它将部署到哪个区域，这是我们使用<em class="lf"> $AWS_REGION </em>环境变量设置的</li><li id="e020" class="lm ln hu kh b ki lv km lw js lx jw ly ka lz kz lr ls lt lu dt translated">我们首先在我们的容器中运行<em class="lf">“NPM测试”</em>，如果所有单元测试都通过了，我们继续。</li><li id="41f8" class="lm ln hu kh b ki lv km lw js lx jw ly ka lz kz lr ls lt lu dt translated">如果一切正常，我们继续在我们的容器中运行<em class="lf">“apex build”</em>。</li></ul><p id="7d5f" class="pw-post-body-paragraph kf kg hu kh b ki la kk kl km lb ko kp js lc kr ks jw ld ku kv ka le kx ky kz hn dt translated">我们把这个构建脚本插入到我们用来构建代码的任何系统中，然后砰！我们有一个自动化的CI/CD流程来处理AWS Lambda！</p><h2 id="1f9a" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">包扎</h2><ul class=""><li id="7035" class="lm ln hu kh b ki kj km kn js ma jw mb ka mc kz lr ls lt lu dt translated">在本系列的前一篇文章中，我们讨论了如何为Lambda函数设置单元测试。</li><li id="1c8c" class="lm ln hu kh b ki lv km lw js lx jw ly ka lz kz lr ls lt lu dt translated">在这篇文章中，我们概述了如何创建一个自动化的工作流来将Lambda函数部署到生产环境中。</li><li id="117b" class="lm ln hu kh b ki lv km lw js lx jw ly ka lz kz lr ls lt lu dt translated">在这个三部曲的第三部也是最后一部(《绝地归来》)中，我们将回顾我们如何设置API Gateway来使我们的服务作为RESTful Web API可用，以及我们如何用我们编写的一个很酷的工具来自动化持续部署它的繁重工作。</li></ul><p id="f178" class="pw-post-body-paragraph kf kg hu kh b ki la kk kl km lb ko kp js lc kr ks jw ld ku kv ka le kx ky kz hn dt translated">回头见！</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="md ll l"/></div></figure></div></div>    
</body>
</html>