<html>
<head>
<title>What You Should Know About ES6 Maps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于ES6地图你应该知道什么</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/what-you-should-know-about-es6-maps-dc66af6b9a1e?source=collection_archive---------0-----------------------#2017-02-16">https://medium.com/hackernoon/what-you-should-know-about-es6-maps-dc66af6b9a1e?source=collection_archive---------0-----------------------#2017-02-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/3a68e79a94a5d2ab9d0e8fce4602d358.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pZ1iJwqgTEfv-gR25JRrGw.jpeg"/></div></div></figure><p id="8def" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a> ES6引入了新的<a class="ae ka" href="https://hackernoon.com/tagged/data-structure" rel="noopener ugc nofollow" target="_blank">数据结构</a>，叫做<em class="kb">地图</em>。map<em class="kb"/>是<em class="kb"> </em>的设计，作为使用对象文字来存储需要唯一键的键/值对的替代方法，并提供非常有用的迭代方法。</p><h1 id="8ad9" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">作为“映射”的对象文字</h1><p id="37d5" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">在JavaScript中，没有什么比对象文字更基础的了。创建排序映射就像用代码声明它一样简单。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="1c4e" class="lo kd hu lk b fv lp lq l lr ls">var map = {<br/>  "key1":"value1",<br/>  "key2":"value2"<br/>}<br/>map.key1; // == "value1"</span></pre><p id="599f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这在许多情况下都行得通，但是使用对象文字作为映射会有问题。我们可能有破坏对象原型方法的键。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="873d" class="lo kd hu lk b fv lp lq l lr ls">var map = {<br/>  "key1":"value1",<br/>  "key2":"value2"<br/>}<br/>map.toString() == "[object Object]"  // Correct<br/>map.toString = "value3"<br/>map.toString(); // Uncaught TypeError: map.toString is not a function</span></pre><p id="efe1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用对象文字的另一个缺点是所有的键只能是字符串。这在许多情况下都有效，但是当试图使用一个原始值作为一个字符串时，系统会在后台将其转换为一个字符串。</p><p id="9981" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种在没有通知用户的情况下发生的魔术可能会导致意想不到的结果，例如，如果提供的键是一个数组。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="1c58" class="lo kd hu lk b fv lp lq l lr ls">map[[1,2,3]] = "value4" // the provided key is an array<br/>map['1,2,3'] = "value4" // the system has made the key a string</span></pre><p id="6592" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用对象文字(ES6之前)的另一个问题是不能保证属性/键的顺序。仅仅因为您已经按照一定的顺序添加了键，并不意味着当您遍历这些键时，它们将保持该顺序。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="5517" class="lo kd hu lk b fv lp lq l lr ls">var o = {}<br/>o.a = 1<br/>o.b = 2<br/>o.c = 3</span><span id="9cf3" class="lo kd hu lk b fv lt lq l lr ls">for(key in o) console.log(key); <br/>// expected a,b,c - but not guaranteed to be in that order</span></pre><p id="14f1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对象也缺少forEach方法。如果您习惯于使用。forEach()对象不能以这种方式迭代。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="6aa9" class="lo kd hu lk b fv lp lq l lr ls">o.forEach // undefined</span></pre><h1 id="9c76" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">ES6中的地图</h1><p id="c59e" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">ES6地图为此提供了一个新的对象。您可以通过调用<strong class="je hv"> new Map([iterable]) </strong>来创建一个新地图。Iterable可以是数组或任何元素是键/值对的iterable对象。提供的键/值对被添加到新映射中。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="c07c" class="lo kd hu lk b fv lp lq l lr ls">var m = new Map()<br/>m.set('a', 1)<br/>m.set('b', 2)<br/>// {"a" =&gt; 1, "b" =&gt; 2}</span></pre><h1 id="22c2" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">地图属性和方法</h1><p id="f0bb" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated"><strong class="je hv">地图提供了一个非常方便的地方。size </strong>属性来获取地图的大小。大小也非常方便地显示在Chrome Dev控制台中，以及地图的内容。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="dced" class="lo kd hu lk b fv lp lq l lr ls">var m = new Map()<br/>m.set('a', 1)<br/>m.set('b', 2)<br/>m.size; // 2  Make sure to use .set so that size updates correctly</span><span id="1f4e" class="lo kd hu lk b fv lt lq l lr ls">m; // Map(2) {"a" =&gt; 1, "b" =&gt; 2}</span></pre><h1 id="ae86" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">map.clear()</h1><p id="4f41" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">清除所有条目的映射。</p><h1 id="dd0d" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">map.delete(键)</h1><p id="52de" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">删除一个键，如果删除成功，则返回。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="6274" class="lo kd hu lk b fv lp lq l lr ls">var m = new Map()<br/>m.set('a', 1)<br/>m.set('b', 2)<br/>m.delete('a'); // true<br/>m.delete('c'); // false (key was not there to delete)</span></pre><h1 id="9a4a" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">map.get(key)，map.has(key)</h1><p id="1a7f" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">获取密钥，并查找密钥是否存在。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="1a30" class="lo kd hu lk b fv lp lq l lr ls">m.get('a'); // 1<br/>m.has('a'); // true<br/>m.has('z'); // false</span></pre><h1 id="1aa4" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">map.forEach(fn)</h1><p id="c5dd" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">提供了一种迭代地图的便捷方法。您可以非常容易地获得键、值和地图本身。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="0c7f" class="lo kd hu lk b fv lp lq l lr ls">var m = new Map()<br/>m.set('a', 1)<br/>m.set('b', 2)<br/>m.forEach((k, v, m) =&gt; console.log(`key:${k} value:${v} map:${m}`))</span><span id="bac1" class="lo kd hu lk b fv lt lq l lr ls">// key:1 value:a map:[object Map]<br/>// key:2 value:b map:[object Map]</span></pre><h1 id="5992" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">为..关于</h1><p id="43f9" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">迭代地图的另一个选项是使用<strong class="je hv">来..的语法，它可以很容易地提供对映射的键和值的访问。</strong></p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="4b6d" class="lo kd hu lk b fv lp lq l lr ls">for([key,value] of m) <br/>  console.log(key + '=' + value)<br/>// a=1<br/>// b=2</span></pre><h1 id="ceb3" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">m.keys()</h1><p id="b65e" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">返回一个完整的迭代器，因此您可以根据需要使用。下一个()</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="bcae" class="lo kd hu lk b fv lp lq l lr ls">var m = new Map()<br/>m.set('a', 1)<br/>m.set('b', 2)</span><span id="0b46" class="lo kd hu lk b fv lt lq l lr ls">var iter = m.keys()<br/>iter.next(); // Object {value: "a", done: false}<br/>iter.next(); // Object {value: "b", done: false}<br/>iter.next(); // Object {value: <em class="kb">undefined</em>, done: true}</span></pre><h1 id="746f" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">m.values()，m.entries()</h1><p id="1275" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">映射值和条目可以用同样的方式迭代。条目会给你一个[key，value]类型的数组。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="d146" class="lo kd hu lk b fv lp lq l lr ls">var iter = m.values()<br/>iter.next(); // Object {value: 1, done: false}<br/>iter.next(); // Object {value: 2, done: false}<br/>iter.next(); // Object {value: <em class="kb">undefined</em>, done: true}</span><span id="0c87" class="lo kd hu lk b fv lt lq l lr ls">var iter = m.entries()<br/>iter.next(); // Object {value: ["a", 1], done: false}<br/>iter.next(); // Object {value: ["b", 2], done: false}<br/>iter.next(); // Object {value: <em class="kb">undefined</em>, done: true}</span></pre><p id="94f0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">映射为您提供了对需要在键、值或条目上执行的操作的大量控制。</p><h1 id="cb08" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">2d阵列到地图</h1><p id="e2a2" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">映射可以在构造函数中采用2d数组。每个数组条目的格式都应该是[key，value]。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="efaa" class="lo kd hu lk b fv lp lq l lr ls">var arr = [['a', 1], ['b', 2]]<br/>var m = new Map(arr)</span><span id="ff59" class="lo kd hu lk b fv lt lq l lr ls">m; // Map(2) {"a" =&gt; 1, "b" =&gt; 2}</span></pre><h1 id="cc5a" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">非字符串作为键</h1><p id="f819" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">您可以使用各种对象作为映射键。系统不会像对对象文字那样自动将键转换成字符串。这为使用地图做有趣的事情提供了广泛的机会。例如，将文档对象设置为键。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="312b" class="lo kd hu lk b fv lp lq l lr ls">var m = new Map()</span><span id="f048" class="lo kd hu lk b fv lt lq l lr ls">m.set(document, true) // uses the document object as a key<br/>// Map(1) {#document {} =&gt; true}</span><span id="2e02" class="lo kd hu lk b fv lt lq l lr ls">m.get(document) <br/>// true</span></pre><p id="6670" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">映射是ES6的一个重要的新特性，可以在多种用例中用于存储键/值对。</p><div class="lf lg lh li fq ab cb"><figure class="lu iv lv lw lx ly lz paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="lu iv lv lw lx ly lz paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="lu iv lv lw lx ly lz paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ma mb mc"><p id="f922" class="jc jd kb je b jf jg jh ji jj jk jl jm md jo jp jq me js jt ju mf jw jx jy jz hn dt translated"><a class="ae ka" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ka" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ka" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae ka" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd kb je b jf jg jh ji jj jk jl jm md jo jp jq me js jt ju mf jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ka" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ka" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mg"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="mh mi l"/></div></figure></div></div>    
</body>
</html>