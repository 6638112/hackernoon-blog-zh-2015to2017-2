<html>
<head>
<title>When logic programming meets CQRS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当逻辑编程遇到CQRS</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/when-logic-programming-meets-cqrs-1137ab2a5f86?source=collection_archive---------0-----------------------#2016-11-24">https://medium.com/hackernoon/when-logic-programming-meets-cqrs-1137ab2a5f86?source=collection_archive---------0-----------------------#2016-11-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="62bc" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">Eve将把一个有抱负的设计模式变成现实</h2></div><p id="4b0d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">欢迎来到我的关于Eve的系列文章的第二部分，这是一种令人兴奋和着迷的新编程语言。</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div class="fe ff kg"><img src="../Images/5d00ee5f811d19fdacd64945cf7dc021.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*c42MkKUBa0HE3th2MG8pDw.png"/></div></figure><ul class=""><li id="4c89" class="ko kp hu jl b jm jn jp jq js kq jw kr ka ks ke kt ku kv kw dt translated"><a class="ae kf" href="https://hackernoon.com/how-eve-unifies-your-entire-programming-stack-900ca80c58a7" rel="noopener ugc nofollow" target="_blank"><em class="kx">I .</em>Eve如何统一你的整个编程栈</a></li><li id="96c2" class="ko kp hu jl b jm ky jp kz js la jw lb ka lc ke kt ku kv kw dt translated"><strong class="jl hv"> <em class="kx">二世。</em>当逻辑编程遇上CQRS </strong></li><li id="f94d" class="ko kp hu jl b jm ky jp kz js la jw lb ka lc ke kt ku kv kw dt translated"><a class="ae kf" href="https://hackernoon.com/throwing-off-our-scope-chains-7567beb2d0b6" rel="noopener ugc nofollow" target="_blank"> <em class="kx">三世。</em>挣脱我们的镜链</a></li><li id="69e4" class="ko kp hu jl b jm ky jp kz js la jw lb ka lc ke kt ku kv kw dt translated"><a class="ae kf" href="https://hackernoon.com/smalltalk-and-protein-programming-4da245ac93e2" rel="noopener ugc nofollow" target="_blank"> <em class="kx">四世。</em> Smalltalk和蛋白质编程</a></li><li id="f2b6" class="ko kp hu jl b jm ky jp kz js la jw lb ka lc ke kt ku kv kw dt translated"><a class="ae kf" href="https://hackernoon.com/the-rock-solid-foundation-for-eves-big-vision-225b80b91e11" rel="noopener ugc nofollow" target="_blank"> <em class="kx">五、</em>夏娃远大理想的坚实基础</a></li><li id="a91e" class="ko kp hu jl b jm ky jp kz js la jw lb ka lc ke kt ku kv kw dt translated"><a class="ae kf" href="https://hackernoon.com/why-eve-will-be-perfect-for-realtime-apps-92b965b80ad" rel="noopener ugc nofollow" target="_blank"> <em class="kx">六。</em>为什么Eve是实时应用的完美选择</a></li></ul><h1 id="227a" class="ld le hu bd lf lg lh li lj lk ll lm ln ja lo jb lp jd lq je lr jg ls jh lt lu dt translated">逻辑编程</h1><p id="d663" class="pw-post-body-paragraph jj jk hu jl b jm lv iv jo jp lw iy jr js lx ju jv jw ly jy jz ka lz kc kd ke hn dt translated">你知道Eve是一种逻辑编程语言吗？Eve基于<a class="ae kf" href="https://databeta.wordpress.com/2010/01/05/introducing-dedalus/" rel="noopener ugc nofollow" target="_blank"> Dedalus </a>，是<a class="ae kf" href="https://en.wikipedia.org/wiki/Datalog" rel="noopener ugc nofollow" target="_blank"> Datalog </a>的扩展，是基于<a class="ae kf" href="https://en.wikipedia.org/wiki/Prolog" rel="noopener ugc nofollow" target="_blank"> Prolog </a>的逻辑编程语言。</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div class="fe ff ma"><img src="../Images/fc3bf17b61d3854f11732a1033ab41af.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*zECrFsEglRzLZ68cjouVPg.png"/></div></figure><p id="8e5e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">逻辑编程的工作方式是:你写下一堆事实，然后你立即开始查询一个世界，在这个世界中，这些事实及其所有逻辑含义都是真实的。如果那没有意义，检查这个<a class="ae kf" href="https://bernardopires.com/2013/10/try-logic-programming-a-gentle-introduction-to-prolog/" rel="noopener ugc nofollow" target="_blank">序言</a>的温和介绍。</p><p id="4699" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Datalog从20世纪70年代就已经存在了。那么如果逻辑编程这么伟大，为什么它还没有成为主流呢？也许是因为它不如过程式和函数式编程风格直观？</p><p id="72b0" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不，我认为逻辑编程只是到现在还没有完全成熟。迪达勒斯的<a class="ae kf" href="https://www2.eecs.berkeley.edu/Pubs/TechRpts/2009/EECS-2009-173.pdf" rel="noopener ugc nofollow" target="_blank">研究论文</a>在2009年才发表，在我看来这是一个重大的理论进步。与传统的逻辑编程不同，Dedalus明确地对随着时间的推移以及通过不可靠的异步通信通道发生的事实更新进行建模。《迪达勒斯》的合著者之一约瑟夫·m·赫勒斯坦这样描述:</p><blockquote class="mb"><p id="a4b5" class="mc md hu bd me mf mg mh mi mj mk ke ek translated">一些人可能会感到惊讶，Datalog是数据库理论的首选语言，却无法对更新和删除进行建模。通过将时间整合到Dedalus逻辑中，更新和删除可以被捕获为逻辑时间戳(版本)数据的演绎。</p></blockquote><p id="3c43" class="pw-post-body-paragraph jj jk hu jl b jm ml iv jo jp mm iy jr js mn ju jv jw mo jy jz ka mp kc kd ke hn dt translated">当然，伊芙现在才出来。所以我们才刚刚开始看到逻辑编程的潜力。</p><h1 id="d5bb" class="ld le hu bd lf lg lh li lj lk ll lm ln ja lo jb lp jd lq je lr jg ls jh lt lu dt translated">CQRS</h1><p id="281e" class="pw-post-body-paragraph jj jk hu jl b jm lv iv jo jp lw iy jr js lx ju jv jw ly jy jz ka lz kc kd ke hn dt translated">我想我们会看到，逻辑编程能做的最令人兴奋的事情之一就是实现CQRS模式。</p><h2 id="2b89" class="mq le hu bd lf mr ms mt lj mu mv mw ln js mx my lp jw mz na lr ka nb nc lt nd dt translated">这是什么？</h2><p id="977c" class="pw-post-body-paragraph jj jk hu jl b jm lv iv jo jp lw iy jr js lx ju jv jw ly jy jz ka lz kc kd ke hn dt translated"><a class="ae kf" href="https://msdn.microsoft.com/en-us/library/jj591573.aspx" rel="noopener ugc nofollow" target="_blank">命令查询责任分离(CQRS) </a>是一个冗长的术语，但它仅仅意味着将你的读模型和写模型分开。</p><p id="112c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">例如，在一个称为<a class="ae kf" href="https://msdn.microsoft.com/en-us/library/dn589792.aspx" rel="noopener ugc nofollow" target="_blank">事件源</a>的CQRS特例中，您决定您的应用程序的写模型是一个单一的仅附加事件对象序列，如:</p><ul class=""><li id="b6b6" class="ko kp hu jl b jm jn jp jq js kq jw kr ka ks ke kt ku kv kw dt translated"><code class="eh ne nf ng nh b">{event: “deposited", accountId: 123, amount: 100}</code></li><li id="ae3c" class="ko kp hu jl b jm ky jp kz js la jw lb ka lc ke kt ku kv kw dt translated"><code class="eh ne nf ng nh b">{event: “deposited", accountId: 456, amount: 100}</code></li><li id="2c83" class="ko kp hu jl b jm ky jp kz js la jw lb ka lc ke kt ku kv kw dt translated"><code class="eh ne nf ng nh b">{event: “withdrew", accountId: 123, amount: 30}</code></li></ul><p id="6048" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您的应用程序的读取模型看起来更像:</p><ul class=""><li id="8ad4" class="ko kp hu jl b jm jn jp jq js kq jw kr ka ks ke kt ku kv kw dt translated"><code class="eh ne nf ng nh b">{accountId: 123, balance: 70}</code></li><li id="373b" class="ko kp hu jl b jm ky jp kz js la jw lb ka lc ke kt ku kv kw dt translated"><code class="eh ne nf ng nh b">{accountId: 456, balance: 100}</code></li></ul><p id="1311" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当您的应用程序接收到一个事件(如存款)时，它会发出一个对写模型的更新。当您的应用程序需要数据时，例如获取帐户的当前余额，它会查询读取模型。同时，您告诉您的数据库层如何始终保持读模型与写模型同步。</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="fe ff ni"><img src="../Images/7a54572b106ed3f6dbce863461c14b43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rMQ9hIocFDe9mFeU-flvIg.png"/></div></div></figure><h2 id="46df" class="mq le hu bd lf mr ms mt lj mu mv mw ln js mx my lp jw mz na lr ka nb nc lt nd dt translated">为什么好？</h2><p id="7dbc" class="pw-post-body-paragraph jj jk hu jl b jm lv iv jo jp lw iy jr js lx ju jv jw ly jy jz ka lz kc kd ke hn dt translated">对于高可伸缩性、高可靠性和高可靠性的应用程序来说，事件源已经是一种流行的模式。格雷格·杨的这个演讲很好地解释了它的优点。</p><p id="4ac8" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">即使你不关心事件源，你也可能关心<a class="ae kf" href="https://en.wikipedia.org/wiki/Denormalization" rel="noopener ugc nofollow" target="_blank">数据反规范化</a>。好吧，任何时候你认为你只是在“反规范化数据”，你实际上是在“预计算CQRS的阅读模型”。</p><p id="8a9a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">嘿，我告诉过你CQRS是一个免费的长流行语，因为它很简单。但是你可以看到命名和关心是一个重要的概念。</p><h1 id="5699" class="ld le hu bd lf lg lh li lj lk ll lm ln ja lo jb lp jd lq je lr jg ls jh lt lu dt translated">问题:CQRS现在有点不太可能</h1><p id="b1cc" class="pw-post-body-paragraph jj jk hu jl b jm lv iv jo jp lw iy jr js lx ju jv jw ly jy jz ka lz kc kd ke hn dt translated">CQRS的问题是，从来没有一个好的方法来“告诉你的数据库层如何总是保持读模型与写模型同步”。如果你放大上面的CQRS图，标有“变化”的箭头实际上是一座摇摇晃晃的桥:</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="fe ff nn"><img src="../Images/b5b2fe657ac6dab505e29526ced21265.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1c3fmInxhSm7Tt_xUDhmLQ.png"/></div></div></figure><p id="be1a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">理论上，CQRS是伟大的。但是在实践中，这并不是你能真正做到的事情，至少不能优雅而有力地做到。</p><p id="e314" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">声称帮助实现CQRS的系统通常是<a class="ae kf" href="https://martin.kleppmann.com/2016/01/29/event-sourcing-stream-processing-at-ddd-europe.html" rel="noopener ugc nofollow" target="_blank">流处理</a>系统，例如:</p><ul class=""><li id="6a28" class="ko kp hu jl b jm jn jp jq js kq jw kr ka ks ke kt ku kv kw dt translated"><a class="ae kf" href="https://geteventstore.com/" rel="noopener ugc nofollow" target="_blank">事件存储</a></li><li id="a837" class="ko kp hu jl b jm ky jp kz js la jw lb ka lc ke kt ku kv kw dt translated">基于Apache <a class="ae kf" href="http://samza.apache.org/" rel="noopener ugc nofollow" target="_blank"> Samza </a>和<a class="ae kf" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank"> Kafka </a>的<a class="ae kf" href="https://www.confluent.io/blog/introducing-kafka-streams-stream-processing-made-simple/" rel="noopener ugc nofollow" target="_blank">解决方案</a></li></ul><p id="602b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您还可以使用SQL数据库来实现CQRS:只需将您的写模型放入一个或多个表中，然后使用<a class="ae kf" href="https://en.wikipedia.org/wiki/Database_trigger" rel="noopener ugc nofollow" target="_blank">触发器</a>对更改做出反应，并发出正确的<code class="eh ne nf ng nh b">INSERT</code> / <code class="eh ne nf ng nh b">UPDATE</code> / <code class="eh ne nf ng nh b">DELETE</code>操作来同步您的读模型。</p><p id="e525" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不幸的是，无论您选择上面的哪一个，您都必须使用自己混乱的过程逻辑来对传入的写操作做出反应。也就是说，你必须告诉数据库<em class="kx">如何</em>保持两个模型同步。你不能仅仅宣布<em class="kx">这两种模式之间的关系总是需要什么。</em></p><p id="5d36" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">此外，一致性保证也不确定。当您的写模型改变时，您不能保证您的整个读模型相应地从一个一致的快照跳到下一个。</p><h2 id="2996" class="mq le hu bd lf mr ms mt lj mu mv mw ln js mx my lp jw mz na lr ka nb nc lt nd dt translated">物化视图模式</h2><p id="5d52" class="pw-post-body-paragraph jj jk hu jl b jm lv iv jo jp lw iy jr js lx ju jv jw ly jy jz ka lz kc kd ke hn dt translated">好吧，那么……用一个<a class="ae kf" href="https://msdn.microsoft.com/en-us/library/dn589782.aspx" rel="noopener ugc nofollow" target="_blank">物化视图模式</a>来实现CQRS怎么样？</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="fe ff no"><img src="../Images/f5014eb8b9057435248154742dee397c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GASJOeskp91ORBVOULAGMg.png"/></div></div></figure><p id="1d05" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">理论上，物化视图模式很棒。但是实际上——尽管它有自己的MSDN页面——它缺少一个令人满意的实现！如果你放大图表，那个小的水平箭头实际上是一个泄漏的管道:</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="fe ff np"><img src="../Images/d3b8f1920d87fea1803ecb8090263648.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HQ43YCDb5vMcroRQeMJPlA.png"/></div></div></figure><p id="3b67" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">物化视图只适用于基本的数据转换。它们不够聪明，无法针对写模型操作进行增量更新。另外，它们的一致性保证也很弱。</p><p id="7827" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我之前在“<a class="ae kf" href="https://hackernoon.com/data-denormalization-is-broken-7b697352f405" rel="noopener ugc nofollow" target="_blank">数据反规范化被打破</a>”中指出了物化视图的局限性。当我渴望一个“反规范化引擎”时，我基本上指的是优雅且健壮地实现物化视图模式的任何东西。</p></div><div class="ab cl nq nr hc ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="hn ho hp hq hr"><p id="1270" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在我看来，CQRS似乎是一个我们都应该用于数据层的关键模式——然而，目前很少看到具有优雅的CQRS架构的生产系统，甚至很少听到在对话中提到“CQRS”。可悲的是，我认为我们懒得讨论它，因为没有工具让我们建立它。</p><h1 id="1213" class="ld le hu bd lf lg lh li lj lk ll lm ln ja lo jb lp jd lq je lr jg ls jh lt lu dt translated">逻辑编程遇见CQRS</h1><p id="3994" class="pw-post-body-paragraph jj jk hu jl b jm lv iv jo jp lw iy jr js lx ju jv jw ly jy jz ka lz kc kd ke hn dt translated">很快，我们将不再需要物化视图模式、SQL触发器或流处理——因为我们将拥有Eve。</p><p id="091a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Eve的最新版本，0.2，只是一个内存演示；它还不够像数据库。但我敢说，它已经走上了成为CQRS的最佳实现的轨道。</p><p id="0048" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在Eve中，用<code class="eh ne nf ng nh b">search</code>和<code class="eh ne nf ng nh b">bind</code>编写一个块有点像定义一个物化视图。这里有一个小小的单记录物化视图/ CQRS:</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div class="fe ff nx"><img src="../Images/ba29d691a63123f0e2bd904187020293.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*-9XNll-dVHfxUX190xjV0A.png"/></div></figure><p id="055a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我将<code class="eh ne nf ng nh b">c</code>绑定为总是等于<code class="eh ne nf ng nh b">a + b</code>。现在<code class="eh ne nf ng nh b">a</code>是<code class="eh ne nf ng nh b">5</code>，<code class="eh ne nf ng nh b">b</code>是<code class="eh ne nf ng nh b">6</code>，<code class="eh ne nf ng nh b">c</code>是<code class="eh ne nf ng nh b">11</code>。如果我将<code class="eh ne nf ng nh b">b</code>增加到<code class="eh ne nf ng nh b">7</code>，那么我会自动看到<code class="eh ne nf ng nh b">c</code>的值为<code class="eh ne nf ng nh b">12</code>。</p><p id="f249" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">看，这是CQRS！我的写模式是<code class="eh ne nf ng nh b">a</code>和<code class="eh ne nf ng nh b">b</code>，我的读模式是<code class="eh ne nf ng nh b">c</code>。这是一个微不足道的例子，但它阐明了核心概念。我将在<a class="ae kf" href="https://hackernoon.com/why-eve-will-be-perfect-for-realtime-apps-92b965b80ad" rel="noopener ugc nofollow" target="_blank">第六部</a>中展示一个更详细的<code class="eh ne nf ng nh b">bind</code>的例子。</p><p id="4c21" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有了Eve的<code class="eh ne nf ng nh b">bind</code>操作，你可以同步你的读模型和写模型，让CQRS模式成为现实。现在请看“改变”箭头:</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="fe ff ny"><img src="../Images/0ada36ceae919f4a81ee33ac16b68615.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WiN3_eDZN6mcUcsUm5V1Ow.png"/></div></div></figure><p id="eecb" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">既然我们已经看到了逻辑编程是使CQRS成为现实的一种有前途的方法，我还应该提到<a class="ae kf" href="http://www.datomic.com/" rel="noopener ugc nofollow" target="_blank"> Datomic </a>，它可能是当今市场上最知名的逻辑编程数据库。<a class="ae kf" href="http://yuppiechef.github.io/cqrs-server/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>和<a class="ae kf" href="https://www.youtube.com/watch?v=qDNPQo9UmJA" rel="noopener ugc nofollow" target="_blank">这篇演讲</a>展示了建立在Datomic基础上的CQRS建筑。两者都不“纯”；它们都需要其他系统的定制组合来完成一些工作。尽管如此，他们还是朝着CQRS独立的方向取得了可喜的进展。</p></div><div class="ab cl nq nr hc ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="hn ho hp hq hr"><p id="427a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">下篇:<br/> </strong> <a class="ae kf" href="https://hackernoon.com/throwing-off-our-scope-chains-7567beb2d0b6" rel="noopener ugc nofollow" target="_blank"> <em class="kx">三。</em>挣脱我们的镜链</a></p><div class="kh ki kj kk fq ab cb"><figure class="nz kl oa ob oc od oe paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nz kl oa ob oc od oe paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nz kl oa ob oc od oe paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="of og oh"><p id="f922" class="jj jk kx jl b jm jn iv jo jp jq iy jr oi jt ju jv oj jx jy jz ok kb kc kd ke hn dt translated"><a class="ae kf" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是AMI家庭的一员。我们现在<a class="ae kf" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae kf" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jj jk kx jl b jm jn iv jo jp jq iy jr oi jt ju jv oj jx jy jz ok kb kc kd ke hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kf" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kf" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="fe ff ol"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>