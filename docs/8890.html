<html>
<head>
<title>Javascript and Functional Programming: Currying (Pt.4)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript和函数式编程:Currying(第4部分)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/javascript-and-functional-programming-currying-pt-4-96e3230782ab?source=collection_archive---------9-----------------------#2017-12-19">https://medium.com/hackernoon/javascript-and-functional-programming-currying-pt-4-96e3230782ab?source=collection_archive---------9-----------------------#2017-12-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir is it"><p id="37f4" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">注意:这是“<a class="ae jt" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> Javascript </a>和函数式编程”系列中关于<a class="ae jt" href="https://hackernoon.com/tagged/learning" rel="noopener ugc nofollow" target="_blank">学习JavaScript ES6+中的</a>函数式编程技术的一部分。从头开始检查出<a class="ae jt" href="https://hackernoon.com/javascript-and-functional-programming-an-introduction-286aa625e26d" rel="noopener ugc nofollow" target="_blank"> &lt;第1部分&gt; </a></p></blockquote><figure class="jv jw jx jy fq jz fe ff paragraph-image"><div class="fe ff ju"><img src="../Images/87aebed7fda4d9c06b695e2ad37d9fb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*0e3zOemCl026ujZZFh-KiA.jpeg"/></div></figure><p id="4290" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kc jh ji jj kd jl jm jn ke jp jq jr js hn dt translated">Currying是指我们调用的函数的参数比预期的少。反过来，被调用的函数返回一个接受剩余参数的函数。</p><pre class="jv jw jx jy fq kf kg kh ki aw kj dt"><span id="5f67" class="kk kl hu kg b fv km kn l ko kp">const magicPhrase = <br/> (magicWord) =&gt; <br/>  (muggleWord) =&gt; <br/>    magicWord + muggleWord<br/></span></pre><p id="5a54" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kc jh ji jj kd jl jm jn ke jp jq jr js hn dt translated">然后我们可以用下面的模式调用这个函数</p><figure class="jv jw jx jy fq jz fe ff paragraph-image"><div class="fe ff kq"><img src="../Images/499ef99e079db838e2d2883b7e6a5677.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*PdMGq8oovylfrpQWULwqvw.png"/></div><figcaption class="kr ks fg fe ff kt ku bd b be z ek">Call it maaagic</figcaption></figure><p id="f8d5" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kc jh ji jj kd jl jm jn ke jp jq jr js hn dt translated">编写返回函数的函数，这些函数又返回一些输出(可能是另一个函数！)会变得相当麻烦。幸运的是，我们有像Ramda和lodash这样的功能性JS助手库，它们为我们提供了像curry这样的实用方法。curry实用程序包装通常声明的函数，并将它们转换成一系列单参数函数。因此，我们可以将前面的代码转换为:</p><pre class="jv jw jx jy fq kf kg kh ki aw kj dt"><span id="bac0" class="kk kl hu kg b fv km kn l ko kp">import _ from "lodash"</span><span id="4df9" class="kk kl hu kg b fv kv kn l ko kp">const magicPhrase = _.curry((magicWord, muggleWord) =&gt; magicWord + muggleWord)</span><span id="01ab" class="kk kl hu kg b fv kv kn l ko kp">const muggleWordAccepter = magicPhrase("Abra kedabra ")</span><span id="12ce" class="kk kl hu kg b fv kv kn l ko kp">muggleWordAccepter("dishwasher")</span></pre><p id="6470" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kc jh ji jj kd jl jm jn ke jp jq jr js hn dt translated">另一个例子是我们最喜欢的add函数的改进实现</p><pre class="jv jw jx jy fq kf kg kh ki aw kj dt"><span id="57cf" class="kk kl hu kg b fv km kn l ko kp">import _ from "lodash"</span><span id="9960" class="kk kl hu kg b fv kv kn l ko kp">const addFunction = _.curry((a, b) =&gt; a + b)</span><span id="c5b8" class="kk kl hu kg b fv kv kn l ko kp">const addOne = add(1)</span><span id="67c8" class="kk kl hu kg b fv kv kn l ko kp">addTen(1)</span></pre><p id="5e52" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kc jh ji jj kd jl jm jn ke jp jq jr js hn dt translated">所以我们实际上是用第一个变量“预加载”了add函数。由于JS闭包，我们的函数能够记住传递的第一个值。</p><h2 id="592d" class="kk kl hu bd kw kx ky kz la lb lc ld le kc lf lg lh kd li lj lk ke ll lm ln lo dt translated">为什么你应该关心奉承</h2><ol class=""><li id="b729" class="lp lq hu ix b iy lr jc ls kc lt kd lu ke lv js lw lx ly lz dt translated">Currying让我们有能力编写简洁、明了和可重用的函数。</li></ol><p id="2dfb" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kc jh ji jj kd jl jm jn ke jp jq jr js hn dt translated">2.我们使用这些函数作为清晰的、可测试的逻辑单元来组成程序中逻辑上更复杂的部分。</p><p id="2eee" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kc jh ji jj kd jl jm jn ke jp jq jr js hn dt translated">3.使用currying，任何对单个元素起作用的函数都可以转换成对数组(列表)起作用的函数，只需用<em class="iw"> map </em>包装它。</p><pre class="jv jw jx jy fq kf kg kh ki aw kj dt"><span id="e1f6" class="kk kl hu kg b fv km kn l ko kp">const getObjectId = (obj) =&gt; obj.id // works on single object</span><span id="d365" class="kk kl hu kg b fv kv kn l ko kp">const arrayOfObjects = [{id: 1}, {id: 2}, {id: 3}, {id: 4}]</span><span id="d8aa" class="kk kl hu kg b fv kv kn l ko kp">const arrayOfIDs = arrayOfObjects.map(getObjectId)</span></pre><figure class="jv jw jx jy fq jz fe ff paragraph-image"><div class="fe ff ma"><img src="../Images/ead460f4310c3d6c11ce7cd794a998aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*o1vQuXVYH0JVSfxKDTwluQ.png"/></div><figcaption class="kr ks fg fe ff kt ku bd b be z ek">BAM! Our function that worked on single elements can work on arrays!</figcaption></figure><h2 id="eae3" class="kk kl hu bd kw kx ky kz la lb lc ld le kc lf lg lh kd li lj lk ke ll lm ln lo dt translated">例子</h2><p id="3480" class="pw-post-body-paragraph iu iv hu ix b iy lr ja jb jc ls je jf kc mb ji jj kd mc jm jn ke md jq jr js hn dt translated">真正熟悉这些概念的唯一方法就是实践:)言归正传。我们将从另一个例子开始，将一个操作单个元素的函数转换成一个操作数组的函数。</p><pre class="jv jw jx jy fq kf kg kh ki aw kj dt"><span id="c049" class="kk kl hu kg b fv km kn l ko kp">const getFirstTwoLettersOfWord = (word) =&gt; word.substring(0,2)</span><span id="54e9" class="kk kl hu kg b fv kv kn l ko kp">// We can convert it, by wrapping it in the map method</span><span id="911a" class="kk kl hu kg b fv kv kn l ko kp">["aabb", "bbcc", "ccdd", "ddee"].map(getFirstTwoLettersOfWord)</span></pre><figure class="jv jw jx jy fq jz fe ff paragraph-image"><div class="fe ff me"><img src="../Images/4330cf38afbfa62ebdf1ede133f70509.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*2vrdwE1jHeOidWZBq6Lpog.png"/></div></figure><p id="015b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kc jh ji jj kd jl jm jn ke jp jq jr js hn dt translated">下一个例子来自令人惊奇的《基本足够指南》，带有一个小的ES6重构:)</p><p id="53cc" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kc jh ji jj kd jl jm jn ke jp jq jr js hn dt translated">让我们重构max函数，这样它就不会引用任何参数。</p><pre class="jv jw jx jy fq kf kg kh ki aw kj dt"><span id="3fab" class="kk kl hu kg b fv km kn l ko kp">arr = [2,4,6,8,9]</span><span id="8259" class="kk kl hu kg b fv kv kn l ko kp">// LEAVE BE:<br/>const getMax = (x, y) =&gt; {<br/>  return x &gt;= y ? x : y;<br/>};<br/><br/>// REFACTOR THIS ONE:<br/>const max = (arr) =&gt; {<br/>  return arr.reduce((acc, x) =&gt; {<br/>    return getMax(acc, x);<br/>  }, -Infinity);<br/>};</span><span id="8174" class="kk kl hu kg b fv kv kn l ko kp">const max = arr.reduce(getMax, -Infinity)</span></pre><p id="cffd" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kc jh ji jj kd jl jm jn ke jp jq jr js hn dt translated">让我们包装原生JS <em class="iw">切片方法</em>，使其功能化和可定制化。</p><pre class="jv jw jx jy fq kf kg kh ki aw kj dt"><span id="1441" class="kk kl hu kg b fv km kn l ko kp">import _ from "lodash"</span><span id="73bf" class="kk kl hu kg b fv kv kn l ko kp">const arr = ["barney", "fred", "dave"]</span><span id="19fb" class="kk kl hu kg b fv kv kn l ko kp">arr.slice(0, 2) // ["barney", "fred"]</span><span id="2c51" class="kk kl hu kg b fv kv kn l ko kp">const slice = _.curry((start, end, arr) =&gt; arr.slice(start, end));<br/>const sliceWithSetIndexes = slice(0,2)<br/><br/>sliceWithSetIndexes(arr) // <!-- -->["barney", "fred"]</span></pre><h2 id="ad4e" class="kk kl hu bd kw kx ky kz la lb lc ld le kc lf lg lh kd li lj lk ke ll lm ln lo dt translated">摘要</h2><p id="8cec" class="pw-post-body-paragraph iu iv hu ix b iy lr ja jb jc ls je jf kc mb ji jj kd mc jm jn ke md jq jr js hn dt translated">我们已经看到了几个使用JS函数的例子。Currying是指将具有多个实参(接受实参)的函数转换为实参较少的同一个函数的过程。它利用JS闭包来记住之前调用中使用的参数。Currying扭转功能，使他们可以更自然地一起工作。它最大的优点是它很容易允许函数组合，我们将在下一篇文章中深入探讨！</p><h2 id="5fbd" class="kk kl hu bd kw kx ky kz la lb lc ld le kc lf lg lh kd li lj lk ke ll lm ln lo dt translated">如果这篇文章有帮助，请点击拍手👏按钮以示支持！⬇⬇</h2><p id="7f78" class="pw-post-body-paragraph iu iv hu ix b iy lr ja jb jc ls je jf kc mb ji jj kd mc jm jn ke md jq jr js hn dt translated">你可以在<a class="ae jt" href="https://www.instagram.com/omeragoldberg/" rel="noopener ugc nofollow" target="_blank"> Instagram </a>、<a class="ae jt" href="https://www.linkedin.com/in/omer-goldberg-680b40100/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>和<a class="ae jt" rel="noopener" href="/@omergoldberg"> Medium </a>上关注我。</p><figure class="jv jw jx jy fq jz"><div class="bz el l di"><div class="mf mg l"/></div></figure></div></div>    
</body>
</html>