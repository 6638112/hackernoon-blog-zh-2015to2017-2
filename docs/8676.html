<html>
<head>
<title>JavaScript’s journey with ECMA: ES 2017</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript与ECMA的旅程:ES 2017</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/javascripts-journey-with-ecma-es-2017-2ad36a7f9538?source=collection_archive---------14-----------------------#2017-12-10">https://medium.com/hackernoon/javascripts-journey-with-ecma-es-2017-2ad36a7f9538?source=collection_archive---------14-----------------------#2017-12-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="ef2c" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">Javascript简史</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/f54e19db96fc92304b295a159e5f38df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*agWOjJDwtcnC158Zwzi39g.jpeg"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Photo by <a class="ae jz" href="https://unsplash.com/photos/Yhc7YGZlz3g?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Steve Halama</a> on <a class="ae jz" href="https://unsplash.com/search/photos/travel-and-code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c44c" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">JavaScript是由Brendan Eich开发的。他被要求为Netscape通信公司开发一种新的语言，这种语言可以在他们的浏览器上运行，并且在语法上类似于Java，这样他们的开发人员可以不费吹灰之力就能学会。它在1995年9月的某个时候以名称<strong class="kc hv"> JavaScript </strong>推出，回顾这些年，有些人甚至称之为营销噱头。</p></div><div class="ab cl kw kx hc ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hn ho hp hq hr"><h2 id="1333" class="ld le hu bd lf lg lh li lj lk ll lm ln kj lo lp lq kn lr ls lt kr lu lv lw lx dt translated">JavaScript对标准的需求:</h2><p id="309c" class="pw-post-body-paragraph ka kb hu kc b kd ly iv kf kg lz iy ki kj ma kl km kn mb kp kq kr mc kt ku kv hn dt translated">微软希望凭借<strong class="kc hv">的ie浏览器</strong>占领浏览器市场，赶走所有竞争对手，实现他们自己的JavaScript版本。</p><p id="1677" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">JavaScript的创造者总结出标准的必要性，以抑制JavaScript的个别版本，如果没有合适的标准，这将成为开发人员的噩梦，该标准后来被称为ECMA标准，由一个名为ECMA International的组织维护。</p><h2 id="0d76" class="ld le hu bd lf lg lh li lj lk ll lm ln kj lo lp lq kn lr ls lt kr lu lv lw lx dt translated"><strong class="ak"> ECMAScript诞生:</strong></h2><p id="4145" class="pw-post-body-paragraph ka kb hu kc b kd ly iv kf kg lz iy ki kj ma kl km kn mb kp kq kr mc kt ku kv hn dt translated">1997年<strong class="kc hv"/><strong class="kc hv">ECMAScript</strong>或<strong class="kc hv"> ES 1 </strong>问世，决定<strong class="kc hv"> JavaScript将是实现ECMAScript </strong>的语言。<strong class="kc hv">1998年出了ES 2，1999年出了ES 3，2009年出了ES 5，2015年出了ES 6或者官方叫ES 2015</strong>。从2015年开始，我们决定每年推出一个新的ECMAScript标准，如果到那时还没有实现某个功能，它将不会包含在该版本中。</p></div><div class="ab cl kw kx hc ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hn ho hp hq hr"><h2 id="2a17" class="ld le hu bd lf lg lh li lj lk ll lm ln kj lo lp lq kn lr ls lt kr lu lv lw lx dt translated">ECMAScript版本生命周期:</h2><p id="1b9c" class="pw-post-body-paragraph ka kb hu kc b kd ly iv kf kg lz iy ki kj ma kl km kn mb kp kq kr mc kt ku kv hn dt translated">ECMA遵循一个<a class="ae jz" href="http://www.ecma-international.org/memento/TC39.htm" rel="noopener ugc nofollow" target="_blank"> TC39 </a>流程，其中有5个主要流程:</p><ol class=""><li id="1972" class="md me hu kc b kd ke kg kh kj mf kn mg kr mh kv mi mj mk ml dt translated"><strong class="kc hv"> Strawman或阶段0: </strong>这种情况下，提案不是正式提案，而是由TC39成员或贡献者提出的建议或想法，需要进行集体讨论。</li><li id="64e4" class="md me hu kc b kd mm kg mn kj mo kn mp kr mq kv mi mj mk ml dt translated"><strong class="kc hv">提案或阶段1 </strong>:这是提案变得正式的时候，特性开始包含在发布中。“冠军”负责一项提案。TC39委员会积极参与讨论这些冲突，并对特性提出改进建议。</li><li id="2a9e" class="md me hu kc b kd mm kg mn kj mo kn mp kr mq kv mi mj mk ml dt translated"><strong class="kc hv">草案或第二阶段:</strong>如果一个提案已经发展到这一步，它很可能成为以后标准的一部分，如果它错过了当前的周期，它可能不是这个版本，而是下一个版本。需要实现两个实验示例，并根据成员的反馈记录其增量变化。</li><li id="0c83" class="md me hu kc b kd mm kg mn kj mo kn mp kr mq kv mi mj mk ml dt translated"><strong class="kc hv">候选或阶段3: </strong>这是考虑外界反馈的阶段。指定的审阅者在提案上签字。在这一阶段，只有在出现关键问题时，才能对提案进行修改。</li><li id="b9ee" class="md me hu kc b kd mm kg mn kj mo kn mp kr mq kv mi mj mk ml dt translated"><strong class="kc hv">完成或第4阶段:</strong>功能将包含在下一个版本中，在此阶段将进行严格的单元测试。</li></ol><p id="939c" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">你可以在ECMA的这个<a class="ae jz" href="https://github.com/tc39/ecma262" rel="noopener ugc nofollow" target="_blank"> github仓库</a>中查看所有的提议及其状态。</p></div><div class="ab cl kw kx hc ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hn ho hp hq hr"><h2 id="4989" class="ld le hu bd lf lg lh li lj lk ll lm ln kj lo lp lq kn lr ls lt kr lu lv lw lx dt translated">ES 2017:</h2><p id="5eae" class="pw-post-body-paragraph ka kb hu kc b kd ly iv kf kg lz iy ki kj ma kl km kn mb kp kq kr mc kt ku kv hn dt translated">这是JavaScript ECMA标准的最新版本。让我们看看它的一些新特性。</p><ol class=""><li id="71fe" class="md me hu kc b kd ke kg kh kj mf kn mg kr mh kv mi mj mk ml dt translated"><strong class="kc hv"> async and await: </strong>如果你有使用。像我这样的网络世界，你会觉得这极其熟悉。虽然可能会有一些变化，但如果你已经有一些C#的经验，理解起来会容易得多。<strong class="kc hv">不要误解我的意思，这并不意味着没有C#经验的人不会理解这一点，只是有C#经验的人会比其他人感觉离家更近。</strong></li></ol><p id="b0c6" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">直到ES 2016，我们都是这样使用promises进行异步调用的。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mr"><img src="../Images/b2534565b628e6f4be78c9a04cabc526.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x0qK5zP2DWRaFqoRwMSUaA.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Example in ES 2015</figcaption></figure><p id="cf95" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">如果你不熟悉arrow函数和ES 2015，<strong class="kc hv">不必担心</strong>，因为我已经在下面给出了使用ES 5的相同实现，尽管你需要有一些承诺的背景。如果你对上面的图片感到满意，你可以跳过下面的图片。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ms"><img src="../Images/33267187c13d1c720bedbdde8334395c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L8qoYhghWWG7dYc93OpNZw.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Example with ES 5 functions.</figcaption></figure><p id="76e3" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">如果我在ES 2017中使用新的<strong class="kc hv"> async和await </strong>关键字进行相同的实现，它看起来会像这样。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mt"><img src="../Images/1776d5d306c4c340bdad12cf407c2e3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e2IY_cBsojRBlabAZWq-hA.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">using async and await in ES 2017</figcaption></figure><p id="00fc" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><em class="mu">你可以在这里看到实际的笔</em><a class="ae jz" href="https://codepen.io/saurabhpati/pen/jagdWr" rel="noopener ugc nofollow" target="_blank"><em class="mu"/></a></p><p id="6a3c" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">这就是你如何进行异步调用，而不必通过向<strong class="kc hv"> github api </strong>发出<strong class="kc hv">xhr</strong>’<strong class="kc hv">GET</strong>请求来下载任何外部库。</p><p id="2f77" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">只需创建一个引用您的JavaScript文件的html文件。这是必要的，因为如果您只使用node，<strong class="kc hv">运行您的JavaScript文件，您将会违反内容安全策略，因为它将被视为攻击，因为您的JavaScript不在浏览器上执行。所以继续创建一个类似这样的html文件</strong></p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mv"><img src="../Images/a598196e33a96d8750445ddbfa0a1dc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*NJsCRfcB_qyO2HjkAeWZ7w.png"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">just a simple html file with a reference to your JavaScript file.</figcaption></figure><p id="a94f" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">在我的例子中，<em class="mu"> asynchrony.js </em>就是这个文件。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mw"><img src="../Images/9af1ae8b7632b951656460bcf72f9c0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CZNxOJENvz0TD_GDLemrMA.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">asynchrony.js</figcaption></figure><p id="5675" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">简单地浏览一下代码，这里我们刚刚创建了一个名为'<strong class="kc hv"> asyncFn </strong>'的函数，该函数向github api的用户资源发出GET请求以获取我的详细信息，响应作为json对象返回到'<strong class="kc hv"> getMe </strong>'函数内部，并记录到控制台。</p><p id="f652" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">现在，如果我们删除<strong class="kc hv">第30行</strong>中的<strong class="kc hv"> await </strong>关键字，‘<strong class="kc hv">async fn’</strong>将简单地返回一个承诺，通过分别使用“<strong class="kc hv">”和“</strong>”和“<strong class="kc hv"> catch </strong>”处理程序，可以将一个resolve和一个reject处理程序附加到该承诺上，因此您的“<strong class="kc hv"> getMe </strong>”函数就变成这样</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mx"><img src="../Images/e076652bf3717359c81055179060dded.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*sYULKfgU050dkR9Ip1pDYA.png"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">without await</figcaption></figure><p id="376b" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">因此，使用<strong class="kc hv"> await </strong>将您的承诺解析为适当的响应对象，解析后可能是正确的响应，被“<strong class="kc hv"> asyncFn </strong>”拒绝时可能是错误的响应。</p><p id="39e9" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv">注意事项:</strong></p><p id="4b6c" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">a)你不能在一个函数中使用<strong class="kc hv"> await </strong>，除非这个函数用<strong class="kc hv"> async </strong>关键字标记。</p><p id="caeb" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">b)如果您正在运行visual studio代码启动器，您需要安装<strong class="kc hv"> babel </strong>或其他合适的工具，该工具将<strong class="kc hv"> transpile </strong>并向代码添加合适的<strong class="kc hv">polyfill</strong>，以便您的代码可以在启动器中运行。否则，您需要在现代浏览器上执行您的ES 2017代码，大多数现代浏览器都可以执行ES 2017 JavaScript代码。</p></div><div class="ab cl kw kx hc ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hn ho hp hq hr"><p id="0395" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv"> 2。网络工作者:</strong>这是一个相当有趣的概念。我想用一个类比来解释一下。当我在大学的时候，我在第一学期上了<strong class="kc hv">物理</strong>课，教授是<strong class="kc hv">原子物理</strong>方面的专家，但<strong class="kc hv">不是</strong>核物理方面的专家。所以他让他的一个主修核物理的学生来代替他。所以换句话说，<strong class="kc hv">主线程(教授)指派了一个工人线程(他的学生)为他做一项工作，而主线程(教授)</strong>可怕地准备了一个测试，让我们在等待<strong class="kc hv">他的学生(工人线程)</strong>完成他的工作时进行(纯粹的邪恶)测试。</p><p id="82b1" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">web worker作为一个不同于调用worker的主线程的线程执行，并且为worker线程执行一个不同的JavaScript文件，它是独立执行的，尽管我们可以附加侦听器来共享数据。</p><p id="33ec" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">数据共享是通过为工作线程创建一个复制数据来实现的，这样它就可以独立地处理数据，然后将结果发送回主线程。</p><p id="a624" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">在我们开始用代码探索它之前，<strong class="kc hv">让我先告诉你，如果你没有在服务器中托管你的应用程序就运行它，它不会工作，因为没有服务器，JavaScript </strong> <strong class="kc hv">本质上是一个单线程语言，没有服务器的动态性，它将无法启动一个不同的线程。</strong></p><p id="ddc9" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">使用任何web服务器托管您的应用程序，您可以使用<strong class="kc hv"> <em class="mu"> Express </em> </strong> <em class="mu"> </em>或使用<strong class="kc hv"> http </strong>节点模块在node中创建一个http服务器。既然学习如何在node中创建http服务器不是我们这里的目标，您可以将该任务留给<a class="ae jz" href="https://www.npmjs.com/package/http-server" rel="noopener ugc nofollow" target="_blank"><strong class="kc hv"><em class="mu">http-server</em></strong></a><strong class="kc hv"><em class="mu"/></strong>节点模块。只需使用<em class="mu"> </em> <strong class="kc hv"> <em class="mu"> npm安装http-server-g</em></strong><em class="mu"/>并运行命令<em class="mu"> </em> <strong class="kc hv"> <em class="mu"> http-server启动您的服务器。</em> </strong>它将在<em class="mu"> http://localhost:8080(默认端口)上托管您的完整文件系统。</em>如果您不想创建应用程序，请克隆我的git存储库<em class="mu"/><a class="ae jz" href="https://gitlab.com/saurabhpati/es2017.git" rel="noopener ugc nofollow" target="_blank"><strong class="kc hv"><em class="mu">https://gitlab.com/saurabhpati/es2017.git</em></strong></a><em class="mu"/>，一旦您安装了http-server节点模块，只需运行命令<em class="mu">'</em><strong class="kc hv"><em class="mu">http-server</em></strong><em class="mu">'。</em></p><p id="9c37" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">现在，创建两个javascript文件，一个作为<strong class="kc hv">主工作线程</strong>，另一个作为<strong class="kc hv"> web工作线程</strong>。我将尽可能保持它的简约和简单。</p><p id="53ca" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">我已经给出了我的html文件的快照，参考了两个脚本，以及我如何运行服务器和在服务器上托管html。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff my"><img src="../Images/9f06a63f6feaa32cb2fc988bcebc532e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NiSiTn97uVKcL9_-Kqk3KA.png"/></div></div></figure><p id="8b17" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">现在我们要做的就是编写<strong class="kc hv"><em class="mu">my worker . js</em></strong><em class="mu"/>和<strong class="kc hv"><em class="mu">main worker . js</em></strong>的代码</p><p id="c70c" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv"><em class="mu">main worker . js:</em></strong></p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mz"><img src="../Images/03f794528d43e1b7714c899c5367aa57.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*l9pVLfMJLrsSnoYDj5asDA.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">main worker code</figcaption></figure><p id="bebd" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">这段代码只是创建一个web worker，<strong class="kc hv">向worker线程</strong>发送一些数据，而<strong class="kc hv"><em class="mu">on message</em></strong><em class="mu"/>处理程序是一个回调函数，在worker完成其工作时执行。</p><p id="b7d1" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv"> <em class="mu"> myWorker.js: </em> </strong></p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff na"><img src="../Images/93a394f2981f6caae60986e6696821a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*79EK5B2ISmTfhHfmNn9p2A.png"/></div></figure><p id="2367" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">不要被<strong class="kc hv">‘self’，</strong>我在这里没有使用任何<strong class="kc hv">‘this’</strong>绑定，它是一个<strong class="kc hv">专用的worker全局作用域</strong>，当worker被执行时，服务器理解它。我在下面附上了结果截图。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nb"><img src="../Images/5ce6d2a9efecb511470214df77cd7e07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Ilwr1OIFKo-xOoP5i65-w.png"/></div></div></figure></div><div class="ab cl kw kx hc ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hn ho hp hq hr"><p id="d9c4" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv"> <em class="mu"> 3。Object.entries: </em> </strong></p><p id="1b60" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv"> <em class="mu"> Object.keys </em> </strong> <em class="mu">，<strong class="kc hv"> ES 5 </strong>中介绍的</em>获取对象键数组，<strong class="kc hv"> <em class="mu"> Object.values </em>，<strong class="kc hv"> ECMA 2015 </strong>中介绍的</strong>获取对象值数组<strong class="kc hv">。</strong> ES 2017引入了一个<strong class="kc hv"><em class="mu">object . entries</em></strong>函数，它返回一个包含键和值的数组的数组，类似这样。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff nc"><img src="../Images/755150ffdb36830256b7cf9e6ee37cc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*_nhvToTOLbbGFJXPQWjG3A.png"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">using Object.entries</figcaption></figure><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nd"><img src="../Images/2e0abf43671598205a50c8724def9b62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6nkHPFu4ScxX-70Tm5vC4A.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">result of Object.entries</figcaption></figure></div><div class="ab cl kw kx hc ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hn ho hp hq hr"><p id="a895" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv"> <em class="mu"> 4。object . getownpropertydescriptor/object . getownpropertydescriptor</em></strong></p><p id="d3d7" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">现在我们可以使用getOwnPropertyDescriptors方法来获取对象描述符。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff ne"><img src="../Images/ff942a7ee82f1d56c1ba0ed3580c1c7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*wIqENybtxIife4d_eHnhWA.png"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">code for getOwnPropertyDescriptors</figcaption></figure><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff nf"><img src="../Images/5f2b44be6b7be0060b928163cc45f83a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*GXJb6uBG_fUbfq4irs5zJQ.png"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">result</figcaption></figure><p id="ed91" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">您还可以使用object . getownpropertydescriptor(person，' age ')只获取年龄描述符。</p></div><div class="ab cl kw kx hc ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hn ho hp hq hr"><p id="1c57" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv"> <em class="mu"> 5。padStart和padEnd: </em>和</strong></p><p id="7c09" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">我的名字“Saurabh Pati”是12个字符，所以如果需要开始和结束填充，我们现在可以使用ES 2017轻松完成，因为开始填充是由下面代码中的<strong class="kc hv"> #* </strong>字符完成的，直到总长度达到16个字符。padEnd函数的工作方式类似，并在字符串末尾追加<strong class="kc hv"> '%$' </strong>，直到总长度达到16。如果您使用12个字符的填充，其长度与我的名字相同，<strong class="kc hv">则不应用填充</strong>。我已经给出了这些方法的使用和结果的快照。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff ng"><img src="../Images/4c759a4a7dce5e3aa5afabb9c88b578b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*5s5gG1Zu8I1aqHQIm-wsZw.png"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">use of padEnd and padStart</figcaption></figure><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nh"><img src="../Images/43127e940fed908465ee534c063da86e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*PlEjyumNg1hDa25GrAZEPA.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">result of padStart and padEnd</figcaption></figure><p id="8967" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">如果您已经阅读到这里，我想感谢您的阅读，如果您有任何建议，请将它们张贴出来，我会确保对提供的每一个建议进行处理，以便在未来改进我自己和我的内容。</p></div></div>    
</body>
</html>