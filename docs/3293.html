<html>
<head>
<title>Wrap any jQuery plugin with Angular 2 component — case study.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Angular 2组件包装任何jQuery插件—案例研究。</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/wrap-any-jquery-plugin-with-angular-2-component-case-study-8b00eacec998?source=collection_archive---------1-----------------------#2017-03-25">https://medium.com/hackernoon/wrap-any-jquery-plugin-with-angular-2-component-case-study-8b00eacec998?source=collection_archive---------1-----------------------#2017-03-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="7125" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Angular像当今大多数前端框架一样，在比普通JavaScript更高的抽象层次上工作。因此，在某个时候，你会发现自己处于这样一种情况，你需要将一些jQuery或普通的JavaScript库转移到Angular world中。这样做有很多原因:</p><ul class=""><li id="8ef7" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx dt translated"><strong class="it hv">表现</strong></li></ul><p id="5d94" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当你的lib主动使用像mousemove这样的事件时，你可能会遇到麻烦——我们稍后会谈到这一点。</p><ul class=""><li id="f6e6" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx dt translated"><strong class="it hv">门面格局</strong></li></ul><p id="3490" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你隐藏了jQuery插件的一些讨厌的配置细节，并向外界暴露了漂亮优雅的组件。</p><ul class=""><li id="84e2" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx dt translated"><strong class="it hv">可重用性</strong></li><li id="a881" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated"><strong class="it hv">更好的架构</strong></li></ul><p id="cb74" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你将你的库包装成所谓的“虚拟组件”,你将从单向数据流编程中获益良多。</p><h1 id="debf" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated"><strong class="ak">那么让我们开始一些编码</strong></h1><p id="2d2d" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">我们将把s <a class="ae lg" href="http://kenwheeler.github.io/slick/" rel="noopener ugc nofollow" target="_blank">点击传送带</a>包装成角形组件。Slick carousel是许多slider实现中的一个，也是我最喜欢的一个。如果你还不知道，我强烈推荐你试一试。</p><p id="eb91" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第一件事，我们应该开始定义，什么是我们想象的组件的API。我认为下面的东西将是一个很好的起点。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="c454" class="lq ke hu lm b fv lr ls l lt lu">&lt;slick-carousel class="carousel"&gt;<br/>  &lt;div  *ngFor="let slide of slides" class="slide"&gt;{{slide.caption}}&lt;/div&gt;<br/>&lt;/slick-carousel&gt;</span></pre><p id="d757" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么我们的实现看起来就像下面的代码片段。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="9b23" class="lq ke hu lm b fv lr ls l lt lu"><strong class="lm hv">import </strong>{ Component, ElementRef} from <em class="lv">'@angular/core'</em>;<br/><strong class="lm hv">import </strong>$ from <em class="lv">"jquery"</em>;<br/>require(<em class="lv">'slick-carousel'</em>);<br/><br/>@Component({<br/>  selector<strong class="lm hv">: </strong><em class="lv">'slick-carousel'</em>,<br/>  template<strong class="lm hv">: </strong><em class="lv">`&lt;ng-content&gt;&lt;/ng-content&gt;`<br/></em>})<br/><strong class="lm hv">export class </strong>SlickCarouselComponent {<br/>  <strong class="lm hv">constructor</strong>(<strong class="lm hv">private </strong>el<strong class="lm hv">: </strong>ElementRef) {<br/>  }<br/><br/>  $carousel<strong class="lm hv">: </strong>JQuery <strong class="lm hv">| </strong>any;<br/><br/>  <em class="lv">ngAfterViewInit</em>() {<br/>    <strong class="lm hv">this</strong>.$carousel <strong class="lm hv">= </strong>$(<strong class="lm hv">this</strong>.el.nativeElement).slick({});<br/>  }<br/>}</span></pre><p id="53d9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的组件模板将只包含一个ng-content元素。所有幻灯片都将被注入到这个元素中。我们正在等待Angular渲染组件，然后使用ngAfterViewInit()生命周期钩子，我们只是简单地初始化我们的插件。差不多就是这样。但是我们可以做得更好一点。</p><h1 id="a40f" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated"><strong class="ak">性能</strong></h1><p id="1891" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">我们可以改进的一点是该解决方案的性能。我们的代码订阅的每个事件都会触发角度变化检测机制。在我们的例子中，我们使用的是JQuery插件，当我们滑动幻灯片时，它会主动监听每个mousemove事件。这导致多次调用变更检测，正如您在下面的屏幕上看到的。</p><figure class="lh li lj lk fq lx fe ff paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="fe ff lw"><img src="../Images/5f99d7e5baee8eba154cb46a31a516e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7CnrvIvW_12h6A5Ownqh3w.png"/></div></div></figure><p id="ad1c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果在我们的组件中有这样的代码<code class="eh me mf mg lm b">&lt;footer [class]="getClass()"&gt;&lt;/footer&gt;</code>，那么当我们在carousel中浏览元素时，getClass()方法将被调用几十次。这也是为什么我们应该避免绑定到方法，而是在ngOnChanges的life hook中映射到ViewModel一次，但这是另一回事了。为了忽略这个问题，我们可以使用angular中的NgZone类，并将slick carousel移到angular世界之外。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="d101" class="lq ke hu lm b fv lr ls l lt lu"><em class="lv">ngAfterViewInit</em>() {<br/>  <strong class="lm hv">this</strong>.zone.<em class="lv">runOutsideAngular</em>(()<strong class="lm hv">=&gt;</strong>{<br/>    <strong class="lm hv">this</strong>.$carousel <strong class="lm hv">= </strong>$(<strong class="lm hv">this</strong>.el.nativeElement).slick({});<br/>  });<br/>}</span></pre><p id="2efb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们用runOutsideAngular块包装一些代码时，Angular将停止监听来自该代码的事件。如果我们想让Angular对鼠标移动事件充耳不闻，但是我们想对滑动事件做出反应，我们可以通过<code class="eh me mf mg lm b">this.zone.run(()=&gt;),</code>返回到angular zone，如下例所示。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="d080" class="lq ke hu lm b fv lr ls l lt lu"><em class="lv">ngAfterViewInit</em>() {<br/>  <strong class="lm hv">this</strong>.zone.<em class="lv">runOutsideAngular</em>(() <strong class="lm hv">=&gt; </strong>{<br/>    <strong class="lm hv">this</strong>.$carousel <strong class="lm hv">= </strong>$(<strong class="lm hv">this</strong>.el.nativeElement).slick({});<br/>    <strong class="lm hv">this</strong>.$carousel.on(<em class="lv">'swipe'</em>, (event, slick, direction) <strong class="lm hv">=&gt; </strong>{<br/>      <strong class="lm hv">this</strong>.zone.<em class="lv">run</em>(() <strong class="lm hv">=&gt; ++this</strong>.counter);<br/>    });<br/>  });<br/>}</span></pre><h1 id="f95a" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">内容更改</h1><p id="b119" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">到目前为止，我们还没有讨论转盘幻灯片动态变化的可能性。在我们的实现中，我们只初始化carousel一次。当我们更新幻灯片列表时，我们的carousel组件对此一无所知，slick carousel也不会添加新创建的幻灯片。这是因为在我们的例子中*ngFor是负责创建幻灯片的指令，它不与<code class="eh me mf mg lm b">&lt;slick-carousel&gt;</code>通信。有许多技术，如何通知父组件关于其内容组件的变化。一种选择是使用依赖注入，用<code class="eh me mf mg lm b">@Host()</code>装饰器在子组件构造函数中获得父组件。另一种选择是实现您自己的*ngFor逻辑，并基于组件用户提供的模板动态创建子组件。另一种选择是在父母控制器中安装<code class="eh me mf mg lm b">@ContentChildren()</code>，从那里监控你的孩子。我们将和<code class="eh me mf mg lm b">@Host()</code>装饰者讨论今天的选项。</p><p id="319e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，我们需要开始为每张幻灯片创建指令。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="dca8" class="lq ke hu lm b fv lr ls l lt lu">@Directive({<br/>  selector<strong class="lm hv">: </strong><em class="lv">'[slick-carousel-item]'</em>,<br/>})<br/><strong class="lm hv">export class </strong>SlickCarouselItem {<br/>  <strong class="lm hv">constructor</strong>(<strong class="lm hv">private </strong>el<strong class="lm hv">: </strong>ElementRef, @Host() <strong class="lm hv">private </strong>carousel<strong class="lm hv">: </strong>SlickCarouselComponent) {<br/>  }<br/>  <em class="lv">ngAfterViewInit</em>() {<br/>    <strong class="lm hv">this</strong>.carousel.<em class="lv">addSlide</em>(<strong class="lm hv">this</strong>);<br/>  }<br/>  <em class="lv">ngOnDestroy</em>() {<br/>    <strong class="lm hv">this</strong>.carousel.<em class="lv">removeSlide</em>(<strong class="lm hv">this</strong>);<br/>  }<br/>}</span></pre><p id="a218" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个指令中，我们通过<code class="eh me mf mg lm b">@Host()</code>装饰器注入父组件。当指令被初始化时，我们通知父组件关于新的项目，并且当ngOnDestroy发生时，我们从父组件移除。我们的Carousel实现现在看起来如下。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="e202" class="lq ke hu lm b fv lr ls l lt lu">@Component({<br/>  selector<strong class="lm hv">: </strong><em class="lv">'slick-carousel'</em>,<br/>  template<strong class="lm hv">: </strong><em class="lv">`&lt;ng-content&gt;&lt;/ng-content&gt;`<br/></em>})<br/><strong class="lm hv">export class </strong>SlickCarouselComponent {<br/>  <strong class="lm hv">constructor</strong>(<strong class="lm hv">private </strong>el<strong class="lm hv">: </strong>ElementRef, <strong class="lm hv">private </strong>zone<strong class="lm hv">: </strong>NgZone) {<br/>  }<br/><br/>  $carousel<strong class="lm hv">: </strong>JQuery <strong class="lm hv">| </strong>any;<br/><br/>  initialized <strong class="lm hv">= false</strong>;<br/><br/>  <em class="lv">initCarousel</em>() {<br/>    <strong class="lm hv">this</strong>.zone.<em class="lv">runOutsideAngular</em>(() <strong class="lm hv">=&gt; </strong>{<br/>      <strong class="lm hv">this</strong>.$carousel <strong class="lm hv">= </strong>$(<strong class="lm hv">this</strong>.el.nativeElement).slick({});<br/>    });<br/>    <strong class="lm hv">this</strong>.initialized <strong class="lm hv">= true</strong>;<br/>  }<br/><br/>  slides <strong class="lm hv">= </strong>[];<br/><br/>  <em class="lv">addSlide</em>(slide) {<br/>    <strong class="lm hv">!this</strong>.initialized <strong class="lm hv">&amp;&amp; this</strong>.<em class="lv">initCarousel</em>();<br/>    <strong class="lm hv">this</strong>.slides.<em class="lv">push</em>(slide);<br/>    <strong class="lm hv">this</strong>.$carousel.slick(<em class="lv">'slickAdd'</em>, slide.el.nativeElement);<br/>  }<br/><br/>  <em class="lv">removeSlide</em>(slide) {<br/>    <strong class="lm hv">const </strong>idx <strong class="lm hv">= this</strong>.slides.<em class="lv">indexOf</em>(slide);<br/>    <strong class="lm hv">this</strong>.$carousel.slick(<em class="lv">'slickRemove'</em>, idx);<br/>    <strong class="lm hv">this</strong>.slides <strong class="lm hv">= this</strong>.slides.<em class="lv">filter</em>(s <strong class="lm hv">=&gt; </strong>s <strong class="lm hv">!= </strong>slide);<br/>  }<br/>}</span></pre><p id="e2cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们现在有了使用JQuery插件的angular组件。我们可以动态地添加和删除幻灯片，我们的组件不会降低角度变化检测的速度。</p><p id="9af2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以在这里找到工作代码的plunker:<a class="ae lg" href="http://plnkr.co/edit/5lF3QCfzYp3owRRlOpk5?p=preview" rel="noopener ugc nofollow" target="_blank">http://plnkr.co/edit/5lF3QCfzYp3owRRlOpk5?p=preview</a></p><div class="lh li lj lk fq ab cb"><figure class="mh lx mi mj mk ml mm paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mh lx mi mj mk ml mm paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mh lx mi mj mk ml mm paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mn mo mp"><p id="f922" class="ir is lv it b iu iv iw ix iy iz ja jb mq jd je jf mr jh ji jj ms jl jm jn jo hn dt translated"><a class="ae lg" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae lg" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae lg" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae lg" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is lv it b iu iv iw ix iy iz ja jb mq jd je jf mr jh ji jj ms jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lg" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lg" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lh li lj lk fq lx fe ff paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="fe ff mt"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>