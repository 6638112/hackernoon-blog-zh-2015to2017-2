<html>
<head>
<title>MongoDB Indexes and Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MongoDB索引和性能</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/mongodb-indexes-and-performance-2e8f94b23c0a?source=collection_archive---------2-----------------------#2016-08-06">https://medium.com/hackernoon/mongodb-indexes-and-performance-2e8f94b23c0a?source=collection_archive---------2-----------------------#2016-08-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/64d066c121da1059a343bcd483676da4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cmo4wKJ1yPcUDe92jfqfIQ.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="https://en.wikipedia.org/wiki/Speedometer" rel="noopener ugc nofollow" target="_blank">credit</a></figcaption></figure><h1 id="3005" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">存储引擎:简介</h1><p id="dbfd" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">好吧，让我们来谈谈切分。分片是将数据库查询分布在多个服务器上。在此之前，让我们先了解一下存储引擎的概念。3.0的新特性是他们提供了可插拔的存储引擎。存储引擎是持久存储和数据库本身之间的接口，持久存储将调用可能是固态磁盘的磁盘。</p><figure class="li lj lk ll fq iv fe ff paragraph-image"><div class="fe ff lh"><img src="../Images/5cca21ee7c0011b17f2985184f024f53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/0*-Rhw5OkfvMA3529_."/></div></figure><p id="7c5f" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">因此，数据库通过存储引擎与持久存储进行对话。现在，可能是存储引擎本身决定使用内存来优化进程。换句话说，磁盘速度非常慢。因为数据库的想法是持久地存储东西，所以存储引擎控制了计算机上的内存。它可以决定将什么放入内存，从内存中取出什么，以及什么时候将什么保存到磁盘。因此，数据库服务器本身将对服务器上的内存以及磁盘本身的处理委托给存储引擎。<code class="eh ld le lf lg b">MongoDB</code>提供可插拔的存储引擎，我们可以使用多个。使用不同的存储引擎，我们会得到不同的性能特征。对于<code class="eh ld le lf lg b">MongoDB</code>，提供了2个存储引擎:</p><p id="f9c8" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated"><strong class="kh hv">什么不是存储引擎？</strong></p><p id="c191" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">如果我们有一堆<code class="eh ld le lf lg b">MongoDB</code>服务器都在集群中运行，存储引擎不会影响这些不同的<code class="eh ld le lf lg b">MongoDB</code>服务器之间的通信。存储引擎不影响数据库呈现给程序员的API。存储引擎直接决定数据文件格式和索引格式</p><h1 id="db62" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">存储引擎:MMAPv1</h1><p id="38f7" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">我们称它为MMA pv1——最初的<code class="eh ld le lf lg b">MongoDB</code>存储引擎，因为它在内部使用<code class="eh ld le lf lg b">mmap</code>调用来实现存储管理。让我们看看<a class="ae jg" href="http://www.tutorialspoint.com/unix_system_calls/mmap.htm" rel="noopener ugc nofollow" target="_blank"> MMAP </a>系统调用是什么样子的。在Linux上，它讨论内存分配，或者将文件或设备映射到内存中。使页面从文件描述符所描述的对象开始，以一个偏移量映射到起始地址，最大长度为字节。那么，这实际上意味着什么呢？</p><p id="4940" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">嗯，实际上需要一个放文件的地方。它将文档放入文件中。为了做到这一点，它首先分配一个大文件。假设它在磁盘上分配了一个100GB的文件。因此，我们最终在磁盘上获得了100GB的文件。在实际磁盘上，磁盘可能是物理上连续的，也可能不是，因为在该层下有一些算法控制磁盘上的实际空间分配。但是从我们的角度来看，它是一个100GB的连续文件。如果<code class="eh ld le lf lg b">MongoDB</code>调用<code class="eh ld le lf lg b">mmap</code>系统调用，它可以将这个100GB的文件映射到100GB的虚拟内存中。要获得这么大的虚拟内存，我们需要在x64机器上。而这些都是<a class="ae jg" href="http://www.computerhope.com/jargon/p/pagesize.htm" rel="noopener ugc nofollow" target="_blank">页大小的</a>。因此，操作系统上的页面大小可以是4k或16k。所以，在100GB的虚拟内存中有很多这样的内存。操作系统将决定什么可以放入内存。假设机器的实际物理内存是32GB，那么如果我们访问这个内存空间中的一个页面，它可能在任何给定的时间都不在内存中。操作系统决定这些页面中的哪些将在内存中。我们将内存中可用的显示为绿色。所以，当我们去读文档时，如果它碰到了内存中的某一页，那么我们就得到它。如果它碰到了不在内存中的页面(白色的)，操作系统必须从磁盘中取出它。</p><figure class="li lj lk ll fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lr"><img src="../Images/d4ef3088a9354e3a939e44fb8c4e3c84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yTDbF8X9r2-48j7D."/></div></div></figure><p id="2258" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated"><a class="ae jg" href="https://www.youtube.com/watch?v=os3591KviNM" rel="noopener ugc nofollow" target="_blank">来源</a></p><p id="5948" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">MMAPv1存储引擎提供</p><ol class=""><li id="0d83" class="ls lt hu kh b ki lm km ln kq lu ku lv ky lw lc lx ly lz ma dt translated"><strong class="kh hv">集合级并发(加锁)</strong>。<code class="eh ld le lf lg b">MongoDB</code>里面的每个收藏都是它自己的文件(可以在<code class="eh ld le lf lg b">~\data\db</code>里看到)。如果对同一个集合触发了多个<code class="eh ld le lf lg b">write</code>，其中一个必须等待另一个完成。这是一个多重阅读器。一次只能对特定集合进行一次写入。</li><li id="e4c8" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc lx ly lz ma dt translated"><strong class="kh hv">允许就地更新</strong>。因此，如果一个文档位于其中一个可用(绿色)页面中，我们对它进行更新，那么我们将尝试就地更新它。如果我们不能更新它，那么我们要做的就是将它标记为一个整体，然后我们将它移动到其他有空间的地方。最后我们会在那里更新它。为了能够在不移动文档的情况下更新文档，我们使用了</li><li id="3298" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc lx ly lz ma dt translated"><strong class="kh hv">当我们为一个文档分配初始存储时，2的幂的大小</strong>。因此，如果我们试图创建一个3字节的文档，我们将得到4字节。8个字节，如果我们创建7个字节。创建19字节文档时为32字节。通过这种方式，可以使文档增长一点。打开的空间，我们可以更容易地重复利用。</li></ol><p id="1e0e" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">另外，请注意，由于操作系统决定什么在内存中，什么在磁盘上，我们对此无能为力。该操作系统在内存管理方面足够智能。</p><h1 id="c6d6" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">存储引擎:WiredTiger</h1><p id="95aa" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">对于许多工作负载，速度更快。它提供了</p><ol class=""><li id="3f1e" class="ls lt hu kh b ki lm km ln kq lu ku lv ky lw lc lx ly lz ma dt translated"><strong class="kh hv">文档级并发</strong>。我们不称之为文档级锁定，因为它是一种无锁实施，具有乐观并发模型，其中存储假设两次写入不会是同一个文档，如果它们是针对同一个文档，则其中一个会被解除，必须重试，并且对应用程序不可见。但是我们确实在MMAP存储引擎中实现了文档级并发而不是集合级并发，这是一个巨大的胜利。</li><li id="a10b" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc lx ly lz ma dt translated"><strong class="kh hv">支持索引和数据的压缩</strong>。因为WiredTiger在想象它自己的存储空间。</li><li id="6f06" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc lx ly lz ma dt translated"><strong class="kh hv">不就地更新</strong> —如果我们更新，它被标记为<strong class="kh hv"> <em class="mg">不再使用</em> </strong>并且在磁盘上完成新的空间分配并写入其中。最终，空闲的空间被回收。为了调用WiredTiger存储引擎，我们将使用<code class="eh ld le lf lg b">mongod --storageEngine wiredTiger</code>。</li></ol><h1 id="0bcf" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">指数</h1><h1 id="3159" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">索引是有序的事物集合。数据库中的索引包含有序列及其引用(_ ids或内存位置)。有序的东西搜索起来更快。这被称为b树索引。索引从最左侧开始工作。让我们假设索引在3列上:<code class="eh ld le lf lg b">A</code>、<code class="eh ld le lf lg b">B</code>、<code class="eh ld le lf lg b">C</code>。我们可以从左侧快速搜索到</h1><ul class=""><li id="c867" class="ls lt hu kh b ki kj km kn kq mh ku mi ky mj lc mk ly lz ma dt translated"><code class="eh ld le lf lg b">A</code>、<code class="eh ld le lf lg b">B</code>、<code class="eh ld le lf lg b">C</code></li><li id="3e5e" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc mk ly lz ma dt translated"><code class="eh ld le lf lg b">A</code>，<code class="eh ld le lf lg b">B</code></li><li id="96f9" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc mk ly lz ma dt translated"><code class="eh ld le lf lg b">A</code></li></ul><p id="b538" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">但是索引不支持从右侧搜索。以下内容不会被加速:</p><ul class=""><li id="4bdc" class="ls lt hu kh b ki lm km ln kq lu ku lv ky lw lc mk ly lz ma dt translated"><code class="eh ld le lf lg b">C</code></li><li id="def2" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc mk ly lz ma dt translated"><code class="eh ld le lf lg b">B</code></li><li id="7263" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc mk ly lz ma dt translated">埃切特拉</li></ul><figure class="li lj lk ll fq iv fe ff paragraph-image"><div class="fe ff ml"><img src="../Images/500205e55c48d7e94815d3c86588cffd.png" data-original-src="https://miro.medium.com/v2/resize:fit:296/format:webp/1*DaBw37yPFaoYjO3B1tNr-g.png"/></div></figure><p id="f0af" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">索引不是免费的，因为每当我们改变文档中影响索引的任何内容时，我们都必须更新索引。需要写到内存上，最后写到磁盘上。此外，很高兴知道索引会降低写入速度。是的，读起来更快。即使在高速计算机上，创建索引也需要时间，因为我们必须扫描整个集合。创建新的数据结构并将它们全部写入磁盘。</p><p id="e4bc" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">使用命令<code class="eh ld le lf lg b">db.collectionName.createIndex({A: 1, B: -1})</code>创建复合索引。其中<code class="eh ld le lf lg b">1</code>表示上升，-1表示下降。要删除索引，请使用<code class="eh ld le lf lg b">db.collectionName.dropIndex({A: 1, B: -1})</code>。复合索引不能同时包含数组类型的列。如果我们尝试这样做，<code class="eh ld le lf lg b">MongoDB</code>将告诉我们它不能索引并行数组，原因是创建它的索引点激增，因为它必须为数组中各项的笛卡尔乘积创建索引点，而这是不允许的。当我们在索引键的文档中有数组时，就应用多键索引。要获取当前可用的索引，使用命令<code class="eh ld le lf lg b">db.collectionName.getIndexes()</code>。嵌套的键也可以被索引，例如:<code class="eh ld le lf lg b">db.collectionName.createIndex({'A.aa': 1})</code>。其中，<code class="eh ld le lf lg b">aa</code>是<code class="eh ld le lf lg b">A</code>中的子键。</p><h1 id="d132" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">索引创建选项，唯一</h1><p id="0b21" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">让我们创建一个包含重复条目的集合:</p><pre class="li lj lk ll fq mm lg mn mo aw mp dt"><span id="a199" class="mq ji hu lg b fv mr ms l mt mu">db.collectionName.insertOne(thing: 'apple'); db.collectionName.insertOne(thing: 'pear'); db.collectionName.insertOne(thing: 'apple');</span></pre><p id="edf7" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">为了确保条目是惟一的，我们可以应用惟一索引。要创建唯一索引，请使用<code class="eh ld le lf lg b">db.collectionName.createIndex({thing:1}, {unique:true})</code>。这个命令会给出一个错误，因为在<code class="eh ld le lf lg b">collectionName</code>中有多个苹果。要移除一个，使用命令<code class="eh ld le lf lg b">db.collectionName.remove( {thing:'apple'}, {justOne: true} )</code>。</p><p id="0ac8" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">该索引就位后，任何重复插入的尝试都将导致<code class="eh ld le lf lg b">duplicate key error</code>。要查看是否确实创建了索引，使用命令<code class="eh ld le lf lg b">db.collectionName.getIndexes()</code>。值得注意的一件有趣的事情是，<code class="eh ld le lf lg b">_id</code>上的索引显示为<strong class="kh hv">唯一的</strong>，尽管它是。</p><h1 id="8770" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">索引创建，稀疏</h1><pre class="li lj lk ll fq mm lg mn mo aw mp dt"><span id="ad2e" class="mq ji hu lg b fv mr ms l mt mu">{a:1, b:5, c:2} <br/>{a:8, b:15, c:7} <br/>{a:4, b:7} <br/>{a:3, b:10}</span></pre><p id="ac66" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">让我们假设我们希望在上述文档上创建一个索引。在<code class="eh ld le lf lg b">a</code> &amp; <code class="eh ld le lf lg b">b</code>上创建索引不会有问题。但是如果我们需要在<code class="eh ld le lf lg b">c</code>上创建一个索引呢？唯一约束对<code class="eh ld le lf lg b">c</code>键无效，因为<strong class="kh hv">空值对两个文档重复</strong>。这种情况下的解决方案是使用<code class="eh ld le lf lg b">sparse</code>选项。该选项告诉数据库不要包括缺少键的文档。相关的命令是<code class="eh ld le lf lg b">db.collectionName.createIndex({thing:1}, {unique:true, sparse:true})</code>。稀疏索引也让我们使用更少的空间。</p><blockquote class="mv mw mx"><p id="6787" class="kf kg mg kh b ki lm kk kl km ln ko kp my lo ks kt mz lp kw kx na lq la lb lc hn dt translated"><em class="hu">注意，即使我们有一个</em> <code class="eh ld le lf lg b"><em class="hu">sparse</em></code> <em class="hu">索引，数据库也会执行所有文档扫描，尤其是在进行排序时。这可以从</em> <strong class="kh hv"> <em class="hu">获胜计划</em> </strong> <em class="hu">部分的</em> <code class="eh ld le lf lg b"><em class="hu">explain</em></code> <em class="hu">中看出结果。</em></p></blockquote><h1 id="d171" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">索引创建，背景</h1><p id="00e5" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">有多个索引选项—前台(默认)和后台。前台相对较快，它阻止所有的作者和读者。我们还能找到其他数据库。这不应该在生产环境中进行。</p><p id="5b4b" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">后台索引创建有点慢，他们不会阻止读者和作者。使用<code class="eh ld le lf lg b">MongoDB</code> 2.4和更高版本，您甚至可以在同一个数据库上并行创建多个后台索引。</p><p id="055e" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">从<code class="eh ld le lf lg b">MongoDB</code> 2.6开始，在主节点的后台创建索引也会导致在辅助节点的后台创建索引。当主节点完成索引构建时，辅助节点将开始创建索引。</p><p id="d956" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">还有另一种方法可以在生产系统中非常有效地创建索引。也就是在用于服务大多数查询的不同服务器上创建索引。比方说，在多个数据库服务器协同工作的副本集中，可以去掉一个服务器，然后将请求路由到可用的服务器。前台索引创建可以在单独的服务器上完成。创建成功后，可以将其带回集群。</p><h1 id="7ce5" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">使用解释</h1><p id="df88" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated"><code class="eh ld le lf lg b">explain</code>命令显示了数据库在执行查询时采取的动作。它返回一个可解释的对象。它使用什么索引，扫描了多少文档。它几乎做了与实际查询类似的所有事情，但它不是查询的完整模拟。这个命令既可以在shell中使用，也可以在驱动程序中使用。它可用于多种情况:</p><ul class=""><li id="538a" class="ls lt hu kh b ki lm km ln kq lu ku lv ky lw lc mk ly lz ma dt translated"><code class="eh ld le lf lg b">db.collectionName.explain().find()</code></li><li id="d291" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc mk ly lz ma dt translated"><code class="eh ld le lf lg b">db.collectionName.explain().update()</code></li><li id="19e4" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc mk ly lz ma dt translated"><code class="eh ld le lf lg b">db.collectionName.explain().remove()</code></li><li id="429c" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc mk ly lz ma dt translated"><code class="eh ld le lf lg b">db.collectionName.explain().aggregate()</code></li></ul><p id="0f86" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">但以下情况是不允许的:</p><ul class=""><li id="01b7" class="ls lt hu kh b ki lm km ln kq lu ku lv ky lw lc mk ly lz ma dt translated"><code class="eh ld le lf lg b">db.collectionName.explain().insert()</code></li><li id="68c9" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc mk ly lz ma dt translated"><code class="eh ld le lf lg b">db.collectionName.remove({a:1, b:2}).exlain()</code></li></ul><p id="f8cc" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">要了解哪些功能可以与<code class="eh ld le lf lg b">explain</code>结合使用，请使用<code class="eh ld le lf lg b">db.collectionName.explain().help()</code>。在以前的版本中，可以将这个命令添加到一个光标上(记住<code class="eh ld le lf lg b">find()</code>返回一个光标)。例如:<code class="eh ld le lf lg b">db.collectionName.find().explain()</code>。这被改变为由一个可解释的对象的函数预先挂起。原因是不是所有的方法都返回一个游标。例如:<code class="eh ld le lf lg b">count()</code>会返回一个标量。</p><h1 id="445c" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">解释:冗长</h1><p id="d2f2" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated"><code class="eh ld le lf lg b">explain</code>命令可以在3种模式下运行:</p><ul class=""><li id="4da3" class="ls lt hu kh b ki lm km ln kq lu ku lv ky lw lc mk ly lz ma dt translated"><code class="eh ld le lf lg b">queryPlanner</code> -主要告诉数据库在索引方面会使用什么</li><li id="a83d" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc mk ly lz ma dt translated"><code class="eh ld le lf lg b">executionStats</code> -包括<code class="eh ld le lf lg b">queryPlanner</code>模式，也包括使用索引的结果</li><li id="0211" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc mk ly lz ma dt translated"><code class="eh ld le lf lg b">allPlansExecution</code> -包括<code class="eh ld le lf lg b">queryPlanner</code> &amp; <code class="eh ld le lf lg b">executionStats</code>模式。它执行查询优化器定期执行的操作，即运行所有可能用于特定查询形式的索引，并并行运行这些索引。然后决定哪一个最快。</li></ul><pre class="li lj lk ll fq mm lg mn mo aw mp dt"><span id="d7c4" class="mq ji hu lg b fv mr ms l mt mu">var exp = db.collectionName.explain("executionStats"); <br/>exp.find();</span></pre><p id="3cc9" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">在研究性能统计时，需要理解的一件事是查看返回的文档数量(<code class="eh ld le lf lg b">nReturned</code>)和检查的文档数量(<code class="eh ld le lf lg b">docsExamined</code>)。下面的数据表明查询扫描了999，999个文档，在619毫秒内返回10，000个。</p><pre class="li lj lk ll fq mm lg mn mo aw mp dt"><span id="6f24" class="mq ji hu lg b fv mr ms l mt mu">&gt; exp = db.example.explain("executionStats")<br/>Explainable(test.example)<br/>&gt; exp.find( { a : 7 } )<br/>{<br/>    "queryPlanner" : {<br/>        "plannerVersion" : 1,<br/>        "namespace" : "test.example",<br/>        "indexFilterSet" : false,<br/>        "parsedQuery" : {<br/>            "a" : {<br/>                "$eq" : 7<br/>            }<br/>        },<br/>        "winningPlan" : {<br/>            "stage" : "COLLSCAN",<br/>            "filter" : {<br/>                "a" : {<br/>                    "$eq" : 7<br/>                }<br/>            },<br/>            "direction" : "forward"<br/>        },<br/>        "rejectedPlans" : [ ]<br/>    },<br/>    "executionStats" : {<br/>        "executionSuccess" : true,<br/>        "nReturned" : 10000,<br/>        "executionTimeMillis" : 619,<br/>        "totalKeysExamined" : 0,<br/>        "totalDocsExamined" : 999999,<br/>        "executionStages" : {<br/>            "stage" : "COLLSCAN",<br/>            "filter" : {<br/>                "a" : {<br/>                    "$eq" : 7<br/>                }<br/>            },<br/>            "nReturned" : 10000,<br/>            "executionTimeMillisEstimate" : 520,<br/>            "works" : 1000001,<br/>            "advanced" : 10000,<br/>            "needTime" : 990000,<br/>            "needFetch" : 0,<br/>            "saveState" : 7812,<br/>            "restoreState" : 7812,<br/>            "isEOF" : 1,<br/>            "invalidates" : 0,<br/>            "direction" : "forward",<br/>            "docsExamined" : 999999<br/>        }<br/>    },<br/>    "serverInfo" : {<br/>        "host" : "cross-mb-air.local",<br/>        "port" : 27017,<br/>        "version" : "3.0.1",<br/>        "gitVersion" : "534b5a3f9d10f00cd27737fbcd951032248b5952"<br/>    },<br/>    "ok" : 1<br/>}</span></pre><h1 id="d7a6" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">涵盖的查询</h1><p id="ab04" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">覆盖查询是一种完全可以由索引满足的查询。因此，<strong class="kh hv">零个文档需要被检查</strong>以满足查询。这使得查询速度大大加快。所有的投影键都需要被索引。</p><h1 id="82f8" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">指数有多大？</h1><p id="f9c4" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">像任何其他数据库一样，将<strong class="kh hv">“工作集”</strong>保存在<strong class="kh hv">内存</strong>中是很重要的。工作集是客户端经常访问的数据。对于索引来说尤其如此。如果索引在磁盘中，那么每次查询都要从磁盘中获取索引，这是非常昂贵的。估计我们进行<code class="eh ld le lf lg b">MongoDB</code>部署所需的内存量。这可以通过使用命令<code class="eh ld le lf lg b">db.collectionName.stats()</code>找到，下面是相关的输出:</p><figure class="li lj lk ll fq iv fe ff paragraph-image"><div class="fe ff nb"><img src="../Images/4005bedcef6a9042f03dcafed394e335.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*c9I62Fl6vV9oGw4UmAjgsw.png"/></div></figure><p id="1a00" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">此输出随数据库引擎的不同而不同。还有一个快捷方式<code class="eh ld le lf lg b">db.collectionName.totalIndexSize()</code>给出了所需的尺寸细节。使用WiredTiger存储引擎，索引的大小要小得多，因为它支持一种称为前缀压缩的技术。但是这种压缩是以牺牲CPU为代价的。这个故事的寓意是，我们需要始终确保索引适合工作集，而工作集又需要适合内存。</p><figure class="li lj lk ll fq iv fe ff paragraph-image"><div class="fe ff nc"><img src="../Images/996f6b0a90e8775f6be064f414c0ef01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*ecl0MxoZtrnMA3W6kCFSog.png"/></div></figure><h1 id="8d07" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">索引条目的数量</h1><figure class="li lj lk ll fq iv fe ff paragraph-image"><div class="fe ff nd"><img src="../Images/2582d13be88a0a6e96f8baab21d3468d.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*9nJtbUgHcKbAITBySd3g6g.png"/></div></figure><p id="6cf9" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated"><strong class="kh hv">索引基数:</strong>指<code class="eh ld le lf lg b">MongoDB</code>支持的每种不同类型索引的索引点数。</p><ol class=""><li id="9f56" class="ls lt hu kh b ki lm km ln kq lu ku lv ky lw lc lx ly lz ma dt translated">regular——对于我们放入索引的每个键，肯定会有一个索引点。另外，如果没有键，那么在空条目下会有一个索引点。就索引基数而言，我们得到了相对于集合中文档数量的1:1。这使得索引具有一定的大小。就指向文档的结束指针而言，它与集合大小成比例</li><li id="496f" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc lx ly lz ma dt translated">稀疏—当文档缺少被索引的键时，它不在索引中，因为它是空的，并且我们不在稀疏索引的索引中保留空值。我们将拥有可能小于或等于文档数量的索引点。</li><li id="e5c9" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc lx ly lz ma dt translated">多键—这是数组值的索引。每个文档将有多个索引点(对于数组的每个元素)。所以，它将大于文档的数量。</li></ol><p id="017a" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">假设您用一个名为tags的键更新了一个文档，这个更新导致文档需要在磁盘上移动。假设您正在使用MMAPv1存储引擎。如果文档中有100个标记，并且标记数组是用多键索引来索引的，那么索引中需要更新100个索引点来适应这种移动。</p><h1 id="fa3d" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">地理空间索引</h1><p id="e08e" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">这些索引允许我们根据位置来查找东西。我们有两个选项:<strong class="kh hv"> 2D </strong> &amp; <strong class="kh hv"> 3D </strong>在2D中，我们有一个带有<code class="eh ld le lf lg b">x</code> &amp; <code class="eh ld le lf lg b">y</code>坐标的笛卡尔平面和一堆不同的物体。</p><figure class="li lj lk ll fq iv fe ff paragraph-image"><div class="fe ff lh"><img src="../Images/8073f43c109a26390c5f360b2b1dedf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*eZ-P6tAvCnmZwVkpkTeQHg.png"/></div></figure><p id="76c2" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">该文档需要用<code class="eh ld le lf lg b">createIndex({'location':'2d', 'type':1})</code>存储某种<code class="eh ld le lf lg b">x</code>、<code class="eh ld le lf lg b">y</code>位置。类型选项指定索引的方向，即升序或降序(这是可选的)。它可以是复合指数。使用命令<code class="eh ld le lf lg b">db.collectionName.find({location: {$near:[x,y]}})</code>查找附近位置。实际上，通常使用的方式是通过一个<code class="eh ld le lf lg b">limit</code>。为了将结果限制为20个，追加<code class="eh ld le lf lg b">.limit(20)</code>。</p><h1 id="a25d" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">地理空间球形</h1><p id="ad41" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">地球上的位置用经度和纬度来表示。纬度是指离赤道有多远。赤道在纬度零度。我们可以从<strong class="kh hv"> -90 </strong>到<strong class="kh hv"> 90 </strong>。一种称为2d球体的特殊索引类型。为了指定事物的位置，我们使用GeoJSON。可以使用点或多边形来描述位置。<code class="eh ld le lf lg b">type</code> &amp; <code class="eh ld le lf lg b">coordinates</code>是保留字。<code class="eh ld le lf lg b">type</code>的值是保留字。对于这种类型的数据，将使用<code class="eh ld le lf lg b">createIndex({'location':'2dsphere', 'type':1})</code>进行索引</p><p id="3526" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">对于名为“stores”的集合，返回位置纬度=39，经度=-130，1，000，000米范围内的商店。假设stores集合在“loc”上有一个2dsphere索引。每个商店记录如下所示:</p><pre class="li lj lk ll fq mm lg mn mo aw mp dt"><span id="a2d2" class="mq ji hu lg b fv mr ms l mt mu">{<br/>    "_id":{<br/>        "$oid":"535471aaf28b4d8ee1e1c86f"<br/>    },<br/>    "store_id":8,<br/>    "loc":{<br/>        "type":"Point",<br/>        "coordinates":[<br/>            -37.47891236119904,<br/>            4.488667018711567<br/>        ]<br/>    }<br/>}</span></pre><p id="f4c6" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">查询将会是<code class="eh ld le lf lg b">db.stores.find({ loc:{ $near: { $geometry: { type: "Point", coordinates: [-130, 39]}, $maxDistance:1000000 } } })</code>。</p><h1 id="19ed" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">文本索引</h1><p id="26f2" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">要在键上创建基于文本的索引，使用命令<code class="eh ld le lf lg b">db.collectionName.ensureIndex({'textColumnName': 'text'})</code>。应用该索引后，使用搜索命令搜索一个单词，即<code class="eh ld le lf lg b">db.collectionName.find({$text: {$search:'your text here'}})</code>。有一个文本分数，根据它对结果进行排名，看看它在score键中的投影，就像这样:<code class="eh ld le lf lg b">db.collectionName.find({$text: {$search:'your text here'}}, {score: {$meta: 'textScore'}}).sort({score: {$meta: 'textScore'}})</code>。</p><p id="2cc7" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">如果我们在<code class="eh ld le lf lg b">movies</code>集合的<code class="eh ld le lf lg b">title</code>字段上创建一个文本索引，然后执行文本搜索<code class="eh ld le lf lg b">db.movies.find( { $text : { $search : "Big Lebowski" } } )</code>。将返回以下文档，假设它们在电影收藏中:</p><ul class=""><li id="3d5a" class="ls lt hu kh b ki lm km ln kq lu ku lv ky lw lc mk ly lz ma dt translated"><code class="eh ld le lf lg b">{ "title" : "The Big Lebowski" , star: "Jeff Bridges" }</code></li><li id="5107" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc mk ly lz ma dt translated"><code class="eh ld le lf lg b">{ "title" : "Big" , star : "Tom Hanks" }</code></li><li id="f94d" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc mk ly lz ma dt translated"><code class="eh ld le lf lg b">{ "title" : "Big Fish" , star: "Ewan McGregor" }</code></li></ul><p id="af55" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">这是因为，在<code class="eh ld le lf lg b">Big</code> &amp; <code class="eh ld le lf lg b">Lebowski</code>上会有一个<strong class="kh hv"> <em class="mg">逻辑或</em> </strong> ing。</p><h1 id="da77" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">什么时候使用索引？</h1><p id="a77a" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">比方说，<code class="eh ld le lf lg b">MongoDB</code>在。假设它有以下索引:</p><ol class=""><li id="414f" class="ls lt hu kh b ki lm km ln kq lu ku lv ky lw lc lx ly lz ma dt translated"><code class="eh ld le lf lg b">b</code>，<code class="eh ld le lf lg b">c</code></li><li id="a21c" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc lx ly lz ma dt translated"><code class="eh ld le lf lg b">c</code>，<code class="eh ld le lf lg b">b</code></li><li id="7c56" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc lx ly lz ma dt translated"><code class="eh ld le lf lg b">d</code>，<code class="eh ld le lf lg b">e</code></li><li id="34d8" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc lx ly lz ma dt translated"><code class="eh ld le lf lg b">e</code>，<code class="eh ld le lf lg b">f</code></li><li id="60a4" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc lx ly lz ma dt translated"><code class="eh ld le lf lg b">a</code>、<code class="eh ld le lf lg b">b</code>、<code class="eh ld le lf lg b">c2</code></li></ol><p id="c865" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated"><code class="eh ld le lf lg b">MongoDB</code>基于查询的形状，决定用于执行查询的索引选择。假设选择了<strong class="kh hv"> 1 </strong>、<strong class="kh hv"> 2 </strong> &amp; <strong class="kh hv"> 5 </strong>。然后，并行执行执行计划，索引如下:</p><figure class="li lj lk ll fq iv fe ff paragraph-image"><div class="fe ff ne"><img src="../Images/6de9d275eea2b11d87c6e2242ee583a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*1GWcDnjVCUnbUKZSQiIm0g.png"/></div></figure><p id="8959" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">对所有计划或分类阈值结果最快的人获胜。这个索引被缓存起来，供将来类似的查询使用。当集合上发生阈值写入时，该缓存的索引将从缓存中删除，截至此次写入时，该阈值写入为1000次。如果重新构建索引，那么也要重新构建缓存。或者，如果<code class="eh ld le lf lg b">mongod</code>进程重新启动，该索引信息将从缓存中删除。</p><h1 id="0c93" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">设计/使用索引</h1><p id="ff80" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">像做任何更伟大的事情一样，设计索引需要一些前瞻性的思考。目标是:</p><ul class=""><li id="0643" class="ls lt hu kh b ki lm km ln kq lu ku lv ky lw lc mk ly lz ma dt translated">效率—快速读/写操作</li><li id="57b5" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc mk ly lz ma dt translated">选择性—最小化记录扫描</li><li id="8652" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc mk ly lz ma dt translated">其他要求—例如，如何处理排序？</li></ul><p id="2e9d" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">选择性是决定索引使用效率的主要因素。理想情况下，索引使我们能够只选择完成结果集所需的那些记录，而不需要扫描大量的索引键(或文档)来完成查询。选择性决定了任何后续操作必须处理多少条记录。更少的记录意味着更少的执行时间。</p><p id="8341" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">考虑应用程序最常使用的查询。使用<code class="eh ld le lf lg b">explain</code>命令，具体参见<code class="eh ld le lf lg b">executionStats</code>:</p><ul class=""><li id="b2fb" class="ls lt hu kh b ki lm km ln kq lu ku lv ky lw lc mk ly lz ma dt translated"><code class="eh ld le lf lg b">nReturned</code></li><li id="35fb" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc mk ly lz ma dt translated"><code class="eh ld le lf lg b">totalKeysExamined</code> -如果检查的钥匙数量比返回的文件数量多？我们需要一些指数来减少它。</li></ul><p id="46a6" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">看<code class="eh ld le lf lg b">queryPlanner</code>，<code class="eh ld le lf lg b">rejectedPlans</code>。查看<code class="eh ld le lf lg b">winningPlan</code>,它显示了<code class="eh ld le lf lg b">keyPattern</code>,它显示了需要索引的键。每当我们看到<code class="eh ld le lf lg b">stage:SORT</code>，这意味着排序的键不是索引的一部分，或者数据库不能根据数据库中指定的排序顺序对文档进行排序。并且需要执行内存排序。如果我们添加排序所基于的键，我们将看到<code class="eh ld le lf lg b">winningPlan</code>的'<code class="eh ld le lf lg b">stage</code>从<code class="eh ld le lf lg b">SORT</code>变为<code class="eh ld le lf lg b">FETCH</code>。索引中的键需要根据它们的数据范围来指定。例如:<strong class="kh hv">班</strong>比<strong class="kh hv">学生</strong>的音量小。这样做需要我们有所取舍。虽然<code class="eh ld le lf lg b">executionTimeMillis</code>会很小，但是<code class="eh ld le lf lg b">docsExamined</code>和<code class="eh ld le lf lg b">keysExamined</code>会相对<strong class="kh hv">小</strong>大。但这种取舍是值得的。</p><p id="df61" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">还有一种方法可以强制查询使用特定的索引，但是不建议将这种方法作为部署的一部分。相关的命令是<code class="eh ld le lf lg b">.hint()</code>，它可以链接在<code class="eh ld le lf lg b">find</code>或<code class="eh ld le lf lg b">sort</code>之后，用于分类等。它需要实际的索引名或索引的形状。</p><p id="9c5c" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">通常，在为以下对象构建复合索引时:</p><ul class=""><li id="d93b" class="ls lt hu kh b ki lm km ln kq lu ku lv ky lw lc mk ly lz ma dt translated"><strong class="kh hv">相等字段</strong>:查询将执行相等测试的字段</li><li id="ab58" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc mk ly lz ma dt translated"><strong class="kh hv">排序字段</strong>:查询将指定排序的字段</li><li id="15f9" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc mk ly lz ma dt translated"><strong class="kh hv">范围字段</strong>:查询进行范围测试的字段</li></ul><p id="9b0b" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">我们应该牢记以下经验法则:</p><ul class=""><li id="490d" class="ls lt hu kh b ki lm km ln kq lu ku lv ky lw lc mk ly lz ma dt translated">范围字段之前的相等字段</li><li id="ed5e" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc mk ly lz ma dt translated">在范围字段之前排序字段</li><li id="70ac" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc mk ly lz ma dt translated">排序字段之前的相等字段</li></ul><p id="41b2" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated"><code class="eh ld le lf lg b">MongoDB</code>自动记录执行时间超过100毫秒的慢速查询。</p><h1 id="9934" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">压型</h1><p id="31a6" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated"><code class="eh ld le lf lg b">MongoDB</code>具有复杂的剖析功能。记录发生在<code class="eh ld le lf lg b">system.profile</code>集合中。从<code class="eh ld le lf lg b">db.system.profile.find()</code>可以看到日志。有3个日志记录级别:</p><ul class=""><li id="4439" class="ls lt hu kh b ki lm km ln kq lu ku lv ky lw lc mk ly lz ma dt translated">级别0 —无日志记录</li><li id="8de8" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc mk ly lz ma dt translated">级别1 —记录慢速查询</li><li id="f7db" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc mk ly lz ma dt translated">级别2 —记录所有查询，这是一个调试功能，而不是性能调试选项</li></ul><p id="115c" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">要查看数据库运行在哪个分析级别，使用<code class="eh ld le lf lg b">db.getProfilingLevel()</code>并查看状态<code class="eh ld le lf lg b">db.getProfilingStatus()</code>。要更改分析状态，使用命令<code class="eh ld le lf lg b">db.setProfilingLevel(level, milliseconds)</code>——其中<code class="eh ld le lf lg b">level</code>是指分析级别，而<code class="eh ld le lf lg b">milliseconds</code>是需要记录查询持续时间的毫秒数。要关闭记录，使用<code class="eh ld le lf lg b">db.setProfilingLevel(0)</code>。</p><p id="5596" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">在系统配置文件集合中查找所有耗时超过一秒的查询的查询(按时间戳降序排序)将是<code class="eh ld le lf lg b">db.system.profile.find( { millis : { $gt:1000 } } ).sort( { ts : -1 } )</code>。</p><h1 id="586f" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">蒙古顶</h1><p id="2460" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">对于性能调优，我们已经看到了<code class="eh ld le lf lg b">explain</code>、<code class="eh ld le lf lg b">hint</code>和<code class="eh ld le lf lg b">profile</code>选项。但是如果我们想看看一个程序的高层，想知道它把时间花在了哪里，我们该怎么做呢？我们有<code class="eh ld le lf lg b">Mongotop</code>，以<code class="eh ld le lf lg b">Unix</code>命令<code class="eh ld le lf lg b">top</code>命名。要在shell上查看日志，使用命令<code class="eh ld le lf lg b">mongotop seconds</code> -其中<code class="eh ld le lf lg b">seconds</code>是秒数，在此之后将打印下一个日志条目。</p><p id="1d4a" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">例如:<code class="eh ld le lf lg b">mongotop 3</code></p><h1 id="222a" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">蒙古统计局</h1><p id="18ac" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated"><code class="eh ld le lf lg b">Mongostat</code>类似于<code class="eh ld le lf lg b">Unix</code>发出的<code class="eh ld le lf lg b">iostat</code>命令。它以1秒的间隔给出数据库统计信息。它显示了在那1秒钟内发生了什么操作。根据所使用的存储引擎，输出可能会有所不同。它的结果也显示了<code class="eh ld le lf lg b">getmore</code>是我们每秒钟运行的<code class="eh ld le lf lg b">getmore</code>命令的数量。这是我们从游标中获得更多信息的方式，如果我们正在做一个有大量结果的查询。getmore列关注每个时间间隔内从游标获取附加数据的请求数。<code class="eh ld le lf lg b">command</code>显示每秒运行的命令数。<code class="eh ld le lf lg b">flushes</code>指磁盘每秒被刷新的次数。<code class="eh ld le lf lg b">mapped</code>是映射内存的数量。<code class="eh ld le lf lg b">res</code>指常驻内存。<code class="eh ld le lf lg b">faults</code>指的是我们每秒钟导致的页面错误的数量。这是一个重要的数字，因为页面错误意味着我们获得了更多的I/O，而更多的I/O意味着更慢的数据库。<code class="eh ld le lf lg b">qr</code>和<code class="eh ld le lf lg b">qw</code>是请求或等待读写的套接字数量的队列长度。<code class="eh ld le lf lg b">ar</code>和<code class="eh ld le lf lg b">aw</code>是活跃读者和作家的数量。<code class="eh ld le lf lg b">netIn</code> &amp; <code class="eh ld le lf lg b">netOut</code>是指在此时间段内发送到数据库和从数据库发出的数量。<code class="eh ld le lf lg b">dirty</code>指存储引擎已经写入并需要写回磁盘的缓存量<code class="eh ld le lf lg b">WiredTiger</code>。<code class="eh ld le lf lg b">used</code>是我们正在使用的总缓存大小。</p><h1 id="b983" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">分片</h1><p id="3e0e" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">分片是一种在多个服务器之间分割大量集合的技术。当我们分片时，我们部署多个<code class="eh ld le lf lg b">mongod</code>服务器。而在前面，<code class="eh ld le lf lg b">mongos</code>也就是路由器。应用程序与该路由器对话。然后，这个路由器与各种服务器(T2)对话。应用程序和T3通常位于同一台服务器上。我们可以在同一台机器上运行多个<code class="eh ld le lf lg b">mongos</code>服务。还建议在每个服务器上保留多个<code class="eh ld le lf lg b">mongod</code>的副本集(统称为<strong class="kh hv">副本集</strong>，而不是一个<code class="eh ld le lf lg b">mongod</code>。副本集在几个不同的实例之间保持数据同步，这样，如果其中一个出现故障，我们就不会丢失任何数据。从逻辑上讲，每个副本集可以被看作是一个<strong class="kh hv">碎片</strong>。这对应用程序是透明的，<code class="eh ld le lf lg b">MongoDB</code>选择分片的方式是我们选择一个<strong class="kh hv">分片密钥</strong>。</p><figure class="li lj lk ll fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nf"><img src="../Images/93c9cf2255263c78309e0d61dc1195ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0HdjN4yKAMnph8s8CEwFXQ.png"/></div></div></figure><p id="6f50" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated">假设对于<code class="eh ld le lf lg b">student</code>集合，我们将<code class="eh ld le lf lg b">stdt_id</code>作为分片键，或者它可以是一个复合键。而<code class="eh ld le lf lg b">mongos</code>服务器，是一个基于范围的系统。因此，基于我们作为碎片键发送的<code class="eh ld le lf lg b">stdt_id</code>，它会将请求发送到正确的<code class="eh ld le lf lg b">mongod</code>实例。</p><p id="7931" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated"><strong class="kh hv">那么，作为开发者，我们需要真正了解什么呢？</strong></p><ul class=""><li id="0b76" class="ls lt hu kh b ki lm km ln kq lu ku lv ky lw lc mk ly lz ma dt translated"><code class="eh ld le lf lg b">insert</code>必须包含一个分片密钥，所以如果它是一个多部分分片密钥，我们必须包含整个分片密钥</li><li id="7847" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc mk ly lz ma dt translated">我们必须了解集合本身的碎片键是什么</li><li id="9d81" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc mk ly lz ma dt translated">对于一个<code class="eh ld le lf lg b">update</code>、<code class="eh ld le lf lg b">remove</code>、<code class="eh ld le lf lg b">find</code>——如果<code class="eh ld le lf lg b">mongos</code>没有给出一个分片密钥——那么它将不得不把请求广播给覆盖集合的所有不同分片。</li><li id="ff13" class="ls lt hu kh b ki mb km mc kq md ku me ky mf lc mk ly lz ma dt translated">对于一个<code class="eh ld le lf lg b">update</code> -如果我们不指定整个碎片密钥，我们必须使它多次更新，以便它知道它需要广播它</li></ul><p id="0f65" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated"><a class="ae jg" href="https://goo.gl/photos/Zap9QDfK48bqssgd6" rel="noopener ugc nofollow" target="_blank">照片</a></p></div><div class="ab cl ng nh hc ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="hn ho hp hq hr"><p id="e204" class="pw-post-body-paragraph kf kg hu kh b ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky lq la lb lc hn dt translated"><em class="mg">最初发布于</em><a class="ae jg" href="http://xameeramir.github.io/mongodb-indexes-and-performance/" rel="noopener ugc nofollow" target="_blank"><em class="mg">xameeramir . github . io</em></a><em class="mg">。</em></p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="nn no l"/></div></figure></div></div>    
</body>
</html>