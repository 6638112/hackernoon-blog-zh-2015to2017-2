<html>
<head>
<title>Creating Awesome SPAs With React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React创建超棒的水疗中心</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/creating-awesome-spas-with-react-66b4e2043621?source=collection_archive---------1-----------------------#2017-09-09">https://medium.com/hackernoon/creating-awesome-spas-with-react-66b4e2043621?source=collection_archive---------1-----------------------#2017-09-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/2788eca8b4c47a31421e58c31a72a916.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XafoksoFrMIYBIxos6rutQ.jpeg"/></div></div></figure><p id="f1c7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我记得当我开始构建webapps时，我曾经严重依赖后端框架来满足我的大部分模板需求。(一开始)简单地用Jinja或blade脚本填充我的页面来创建一个功能性的用户界面是非常诱人的。因为那时我对MVC的理解非常有限，这让我付出了可维护代码的代价。</p><p id="8c91" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我偶然看到一本非常有趣的书，讨论了创建单页应用程序的最佳实践，你可以在这里找到它。我认为视图层仅仅是我的核心逻辑的副产品，它需要更多，它自己的MVC！规则都差不多。但是必须记住，模型、视图和控制器的复杂性取决于需求。对于像GitHub这样的每页操作数相对低于Gmail或Canva的界面，管理对服务器的调用对于交互性低的应用程序与那些ui丰富的应用程序是不同的。因此，事先熟悉设计是很重要的，这种理念有利于在<a class="ae ka" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank"> react </a>中开发，因为react鼓励你将DOM元素视为独立的组件。</p><p id="5c04" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">事不宜迟，让我们讨论一下如何在我们的应用程序中安排文件。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><h1 id="3828" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">成分</h1><p id="328f" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">让我们讨论SPA的不同方面，并对它们进行分解。让我们先看看它们是什么，我们将在下一节中连接它们。</p><h2 id="d050" class="ll kj hu bd kk lm ln lo ko lp lq lr ks jn ls lt kw jr lu lv la jv lw lx le ly dt translated">数据层</h2><p id="6560" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">SPA中的模型，像其他应用程序一样处理项目的数据层，它负责进行获取数据的API调用，并使用<a class="ae ka" href="https://hackernoon.com/tagged/json" rel="noopener ugc nofollow" target="_blank"> JSON </a>响应来填充模型，因为react没有任何定义模型的官方方法，所以我选择使用<a class="ae ka" href="http://backbonejs.org/#" rel="noopener ugc nofollow" target="_blank"> backboneJS </a>来实现这一点。这也免去了我定义自己的<a class="ae ka" href="http://singlepageappbook.com/detail2.html#data-source" rel="noopener ugc nofollow" target="_blank">数据源</a>的麻烦。</p><p id="0c1b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">backboneJS中有两个类可以有效地管理数据，即模型和集合类。</p><p id="8c94" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">型号</strong></p><p id="7538" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">模型是主干网中数据的绝对表示。下面是一个基本模型的片段。</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="5402" class="ll kj hu me b fv mi mj l mk ml">import Backbone from 'backbone';<br/></span><span id="3ac0" class="ll kj hu me b fv mm mj l mk ml">const Property = Backbone.Model.extend({</span><span id="04de" class="ll kj hu me b fv mm mj l mk ml">    urlRoot : Constants.api_url+'/api/property'</span><span id="0def" class="ll kj hu me b fv mm mj l mk ml">});</span><span id="2aae" class="ll kj hu me b fv mm mj l mk ml">export default Property;</span></pre><p id="06d7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是<strong class="je hv"> Property.js </strong>文件中的代码，它是一个主干<a class="ae ka" href="http://backbonejs.org/#Model" rel="noopener ugc nofollow" target="_blank">模型</a>，我们可以调整它的属性来设置验证器、设置默认值等。但最重要的是，我们将使用它从我们的API获取数据。我们的模型将通过jqXHR请求获取数据，我们所要做的就是指定一个有效的API URL。</p><p id="df92" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">收藏</strong></p><p id="83f6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">集合用于管理模型集。一个模型仅仅代表了该数据类型的一个实体，如果你的API返回一个属性列表呢？</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="933a" class="ll kj hu me b fv mi mj l mk ml">import Backbone from 'backbone';</span><span id="a62b" class="ll kj hu me b fv mm mj l mk ml">import Property from '../models/Property';</span><span id="5944" class="ll kj hu me b fv mm mj l mk ml">var PropertyCollection = Backbone.Collection.extend({</span><span id="3b01" class="ll kj hu me b fv mm mj l mk ml">    model: Property,</span><span id="ed69" class="ll kj hu me b fv mm mj l mk ml">    initialize: function(models, options) {</span><span id="9d03" class="ll kj hu me b fv mm mj l mk ml">        this.data = options.data;</span><span id="0d29" class="ll kj hu me b fv mm mj l mk ml">    },</span><span id="6982" class="ll kj hu me b fv mm mj l mk ml">    url: function(){</span><span id="0867" class="ll kj hu me b fv mm mj l mk ml">        return Constants.api_url;</span><span id="a997" class="ll kj hu me b fv mm mj l mk ml">    },</span><span id="1318" class="ll kj hu me b fv mm mj l mk ml">    parse: function(data) {</span><span id="b489" class="ll kj hu me b fv mm mj l mk ml">        return data;</span><span id="b409" class="ll kj hu me b fv mm mj l mk ml">    }</span><span id="5dd3" class="ll kj hu me b fv mm mj l mk ml">});</span><span id="0383" class="ll kj hu me b fv mm mj l mk ml">export default PropertyCollection;</span></pre><p id="ed5f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面的代码驻留在PropertyCollection.js中，如你所见，我们用之前声明的<strong class="je hv">属性</strong>模型初始化了‘model’属性。如果您的REST API遵循适当的约定，它会自动<a class="ae ka" href="http://backbonejs.org/#API-integration" rel="noopener ugc nofollow" target="_blank">配置</a>凝乳请求，您可以简单地使用。创建()。fetch()和。destroy()方法。</p><h2 id="1226" class="ll kj hu bd kk lm ln lo ko lp lq lr ks jn ls lt kw jr lu lv la jv lw lx le ly dt translated">视图+控制器</h2><p id="d7b2" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">对于那些想知道我为什么把这两个混在一起的人，我有一个问题。水疗的最终目的是什么？来交付UI！它毕竟只是一个更复杂的视图层。如果您正在进行一些繁重的客户端计算，那么拥有单独的控制器是有意义的。但是对于大多数应用程序来说，唯一关心的是提供一个无缝的界面，为了达到这个目的，视图是最重要的！有意识地读一下<a class="ae ka" href="http://singlepageappbook.com/goal.html#controllers-must-die" rel="noopener ugc nofollow" target="_blank">这首</a>。</p><p id="135c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，在react的情况下，消除控制器更有意义，因为每个组件都有自己的渲染和生命周期方法。这几乎涵盖了你需要的所有计算。</p><p id="aa8d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在你开始写你的观点之前，你必须分析你的终端用户应用的设计。仔细看看你要服务的页面的设计，仔细观察层次结构。例如，看看这个例子。</p><figure class="lz ma mb mc fq iv fe ff paragraph-image"><div class="fe ff mn"><img src="../Images/967c66d41d388bf87b62abd24d5919f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*L12uTwpsIZ0E_nA8I5OHXQ.png"/></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">Wireframe for a hypothetical APP</figcaption></figure><p id="99d7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设这是您正在尝试构建的应用程序的页面。在顶层有<strong class="je hv"> Body </strong>，它封装了你想要显示的所有内容。这将是您的第一个react组件。然后在单独的文件中逐个创建子组件。</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="6b20" class="ll kj hu me b fv mi mj l mk ml">import React from 'react';</span><span id="38c3" class="ll kj hu me b fv mm mj l mk ml">import Header from '../widgets/Header';</span><span id="5663" class="ll kj hu me b fv mm mj l mk ml">import Title from '../widgets/Title';</span><span id="63c4" class="ll kj hu me b fv mm mj l mk ml">import Footer from '../widgets/Footer';</span><span id="6741" class="ll kj hu me b fv mm mj l mk ml">import PropertyDetail from '../widgets/PropertyDetail'</span><span id="4e96" class="ll kj hu me b fv mm mj l mk ml">const SinglePage = ({match}) =&gt; {</span><span id="e9da" class="ll kj hu me b fv mm mj l mk ml">    return(</span><span id="20af" class="ll kj hu me b fv mm mj l mk ml">    &lt;div id="wrapper" className="clearfix"&gt;</span><span id="bbbc" class="ll kj hu me b fv mm mj l mk ml">    &lt;Header&gt;&lt;/Header&gt;</span><span id="23fe" class="ll kj hu me b fv mm mj l mk ml">    &lt;Title&gt;&lt;/Title&gt;</span><span id="edbd" class="ll kj hu me b fv mm mj l mk ml">    &lt;PropertyDetail property_id={match.params.id}&gt;&lt;/PropertyDetail&gt;</span><span id="d8d4" class="ll kj hu me b fv mm mj l mk ml">    &lt;Footer&gt;&lt;/Footer&gt;</span><span id="80dd" class="ll kj hu me b fv mm mj l mk ml">     &lt;/div&gt;</span><span id="7471" class="ll kj hu me b fv mm mj l mk ml">    )</span><span id="ef3c" class="ll kj hu me b fv mm mj l mk ml">}</span><span id="8d99" class="ll kj hu me b fv mm mj l mk ml">export default SinglePage;</span></pre><p id="3487" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是一个顶级组件，就像我制作的应用程序中的线框的<strong class="je hv">主体</strong>，<strong class="je hv">标题</strong>，<strong class="je hv">标题</strong>，<strong class="je hv">属性细节</strong>和<strong class="je hv">页脚</strong>都是顶级包装器的子级。甚至<strong class="je hv"> PropertyDetail </strong>也有自己的孩子等等。</p><blockquote class="ms mt mu"><p id="9a77" class="jc jd mv je b jf jg jh ji jj jk jl jm mw jo jp jq mx js jt ju my jw jx jy jz hn dt translated">所有顶级组件后来都作为应用程序的独立页面</p></blockquote><p id="f178" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在让我们谈一点线框。虽然我们知道<strong class="je hv">正文</strong>可以是我们应用程序的页面，但同样不能说<strong class="je hv">特色内容</strong>或<strong class="je hv">帖子、</strong>它们将会是我们应用程序的小部件，在大多数情况下，这些小部件将会利用我们之前讨论过的模型。</p><h2 id="a014" class="ll kj hu bd kk lm ln lo ko lp lq lr ks jn ls lt kw jr lu lv la jv lw lx le ly dt translated">路线</h2><p id="a2f5" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">现在，对于路由，我们将使用react路由器，你们大多数人肯定听说过它。但在此之前，让我们讨论一下URL。SPA中的URL是应用的特定状态的表示，即，与路线和参数一起，应用可以在期望的状态下被加载。在交互式SPA中，每页有多个状态是很正常的，你会希望通过URL访问尽可能多的应用程序状态，但这将意味着混乱的URL方案，所以最好平衡两者。</p><p id="097a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了创建干净的URL，我决定将它们保存在一个单独的文件中(并且不使用<a class="ae ka" href="https://reacttraining.com/react-router/core/guides/philosophy/dynamic-routing" rel="noopener ugc nofollow" target="_blank">动态URL</a>😄)来获得熟悉的MVC感觉。使用React路由器定义的路由只是JSX标签，组件作为道具传递给它们。</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="69c5" class="ll kj hu me b fv mi mj l mk ml">&lt;Router&gt;</span><span id="ed15" class="ll kj hu me b fv mm mj l mk ml">&lt;div&gt;</span><span id="5b6e" class="ll kj hu me b fv mm mj l mk ml">&lt;Route exact path="/search/:keyword" component={ListPage}/&gt;</span><span id="e08d" class="ll kj hu me b fv mm mj l mk ml">&lt;Route exact path="/property/:id" component={SinglePage}/&gt;</span><span id="463b" class="ll kj hu me b fv mm mj l mk ml">&lt;/div&gt;</span><span id="1914" class="ll kj hu me b fv mm mj l mk ml">&lt;/Router&gt;</span></pre><p id="27a4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里的<strong class="je hv">列表页</strong>和<strong class="je hv">单页</strong>是我的顶级react组件。还要注意，你必须用<em class="mv"> &lt; div &gt; </em>标签包装多个URL。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><h1 id="ef5f" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">布线</h1><p id="68cd" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">好了，我们知道什么是一个令人敬畏的温泉，是时候把这些碎片放在一起了。首先使用在脸书孵化器知识库中找到的<a class="ae ka" href="https://github.com/facebookincubator/create-react-app" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>生成一个项目，它对设置初始项目非常有帮助，并且所有现代web开发工具都为您管理，因此您可以专注于编写应用程序而不是配置webpack(顺便说一下，这值得单独一篇文章来解释)。由于您将编写模块化代码，编写测试会容易得多，create-react-app使用<a class="ae ka" href="https://facebook.github.io/jest/" rel="noopener ugc nofollow" target="_blank"> Jest </a>来运行测试。</p><p id="0195" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">生成应用程序后，你的文件夹结构将如下所示。</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="4d43" class="ll kj hu me b fv mi mj l mk ml">my-app/<br/>├── package.json<br/>├── package-lock.json<br/>├── public<br/>│   ├── favicon.ico<br/>│   ├── index.html<br/>│   └── manifest.json<br/>├── README.md<br/>└── src<br/>    ├── App.css<br/>    ├── App.js<br/>    ├── App.test.js<br/>    ├── index.css<br/>    ├── index.js<br/>    ├── logo.svg<br/>    └── registerServiceWorker.js</span></pre><p id="5551" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">尝试运行<code class="eh mz na nb me b">npm start</code>，如果一切正常，你的应用程序应该可以在3000端口上访问。还要记住将所有代码放在<strong class="je hv"> src </strong>目录中，该文件夹之外的任何内容都是不可访问的，这是create-react-app generator强加的限制。</p><h2 id="76e7" class="ll kj hu bd kk lm ln lo ko lp lq lr ks jn ls lt kw jr lu lv la jv lw lx le ly dt translated">重新整理东西</h2><p id="c429" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">让我们面对现实吧，在当前的工作目录状态下，创建SPA的梦想都不会实现。除了<strong class="je hv"> index.js </strong>和<strong class="je hv">registerserviceworker . js</strong>之外，我们将把所有东西都移动到一个新目录。在接触任何东西之前，创建这个目录结构。让脚本留在原处。</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="216c" class="ll kj hu me b fv mi mj l mk ml">my-app/<br/>├── package.json<br/>├── package-lock.json<br/>├── public<br/>│   ├── favicon.ico<br/>│   ├── index.html<br/>│   ├── js<br/>│   └── manifest.json<br/>├── README.md<br/>└── src<br/>    ├── assets #All the media/styles/fonts/helper_functions:p<br/>    │   ├── objects<br/>    │   └── styles<br/>    ├── components #controller+view Layer<br/>    │   ├── pages #top-level pages<br/>    │   └── widgets #children<br/>    ├── data #Data Layer<br/>    │   ├── collections #Backbone.Collection<br/>    │   └── models #Backbone.Model<br/>    ├── routes #React router routes<br/>    ├── App.css #unruly mess<br/>    ├── App.js<br/>    ├── App.test.js<br/>    ├── index.css<br/>    ├── index.js<br/>    ├── logo.svg<br/>    └── registerServiceWorker.js #end unruly mess </span></pre><figure class="lz ma mb mc fq iv fe ff paragraph-image"><div class="fe ff nc"><img src="../Images/3feaf2a30461a9d5838ba0c5463cbe70.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*KNXDRCcd7ObIpVWq-sZuEQ.jpeg"/></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">AppFlowChart.sucks</figcaption></figure><p id="5920" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先的事情首先创造这些(不一定按照这个顺序)</p><ul class=""><li id="ae01" class="nd ne hu je b jf jg jj jk jn nf jr ng jv nh jz ni nj nk nl dt translated">在<code class="eh mz na nb me b">/src/components/pages</code>中创建一个简单的react组件，称之为<strong class="je hv"> Home.js </strong></li><li id="fb71" class="nd ne hu je b jf nm jj nn jn no jr np jv nq jz ni nj nk nl dt translated">在<em class="mv"> </em> <code class="eh mz na nb me b">/src/Urls</code>中创建<strong class="je hv"> Urls.js </strong>并创建一条指向Home对象<code class="eh mz na nb me b">&lt;Route exact path=”/” component={Home}/&gt;</code>的路线。这将在您访问域根时呈现<strong class="je hv"> Home.js </strong>的内容。</li><li id="13ab" class="nd ne hu je b jf nm jj nn jn no jr np jv nq jz ni nj nk nl dt translated">将<strong class="je hv"> index.js </strong>中的渲染行改为<code class="eh mz na nb me b">ReactDOM.render(&lt;Urls/&gt;, document.getElementById(‘root’));</code></li></ul><blockquote class="nr"><p id="b493" class="ns nt hu bd nu nv nw nx ny nz oa jz ek translated">这样做时，要确保每个JavaScript文件只导出一个东西，并确保正确使用import语句。</p></blockquote><p id="85be" class="pw-post-body-paragraph jc jd hu je b jf ob jh ji jj oc jl jm jn od jp jq jr oe jt ju jv of jx jy jz hn dt translated">这里要注意的另一件事是，顶级react页面不能是react类，因为React路由器在URL中传递参数，这些参数是作为参数而不是属性传递的！</p><p id="376c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然我们鼓励将您的小部件作为扩展React.component的类，但是您现在可以使用您的模型向小部件传递数据或者初始化它们的状态。</p><p id="2483" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，当您准备好部署应用程序时，运行<code class="eh mz na nb me b">npm run build</code>，这将捆绑您的所有资产，将react设置为生产模式，并保存打包的项目以构建项目目录。您现在可以部署您的应用程序了！</p><p id="ea5a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作为临别赠言，我想说我喜欢分享我对水疗的看法，这也帮助我组织我自己对这个话题的想法。</p><h1 id="e502" class="ki kj hu bd kk kl og kn ko kp oh kr ks kt oi kv kw kx oj kz la lb ok ld le lf dt translated">如果你喜欢这篇文章，请随意点击下面的按钮👏去帮助别人找到它！</h1><figure class="lz ma mb mc fq iv"><div class="bz el l di"><div class="ol om l"/></div></figure></div></div>    
</body>
</html>