<html>
<head>
<title>Writing a Blog Engine in Phoenix and Elixir: Part 4, Adding Roles to our Controllers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Phoenix和Elixir编写博客引擎:第4部分，向控制器添加角色</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/writing-a-blog-engine-in-phoenix-and-elixir-part-4-adding-roles-to-our-controllers-9f4678b48468?source=collection_archive---------0-----------------------#2015-10-26">https://medium.com/hackernoon/writing-a-blog-engine-in-phoenix-and-elixir-part-4-adding-roles-to-our-controllers-9f4678b48468?source=collection_archive---------0-----------------------#2015-10-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="8a95" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">最新更新:</strong>2016年8月17日</p><h2 id="d3bd" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">本系列的前一篇文章</h2><div class="kk kl fm fo km kn"><a rel="noopener follow" target="_blank" href="/@diamondgfx/writing-a-blog-engine-in-phoenix-and-elixir-part-3-adding-roles-to-our-models-3be45a4afe4b"><div class="ko ab ej"><div class="kp ab kq cl cj kr"><h2 class="bd hv fv z el ks eo ep kt er et ht dt translated">用Phoenix和Elixir编写博客引擎:第3部分，向模型添加角色</h2><div class="ku l"><h3 class="bd b fv z el ks eo ep kt er et ek translated">最新更新:2016年7月21日</h3></div><div class="kv l"><p class="bd b gc z el ks eo ep kt er et ek translated">medium.com</p></div></div></div></a></div><h2 id="6fc3" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">当前版本</h2><p id="5ffb" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">在撰写本文时，我们应用程序的当前版本是:</p><ul class=""><li id="fe99" class="lb lc hu it b iu iv iy iz jc ld jg le jk lf jo lg lh li lj dt translated"><strong class="it hv">仙丹</strong> : v1.3.1</li><li id="4a40" class="lb lc hu it b iu lk iy ll jc lm jg ln jk lo jo lg lh li lj dt translated"><strong class="it hv">凤凰:</strong> v1.2.0</li><li id="9475" class="lb lc hu it b iu lk iy ll jc lm jg ln jk lo jo lg lh li lj dt translated"><strong class="it hv"> Ecto: </strong> v2.0.2</li><li id="dcb3" class="lb lc hu it b iu lk iy ll jc lm jg ln jk lo jo lg lh li lj dt translated"><strong class="it hv">康美宁:</strong> v2.5.2</li></ul><p id="c085" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你正在读这篇文章，而这些不是最新的，请告诉我，我会相应地更新这篇教程。</p><h2 id="8b97" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">我们离开的地方</h2><p id="79d9" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">当我们停止时，我们刚刚完成了在模型中实现角色的概念，并创建了一些测试助手来简化我们的工作，但是现在我们需要进入在控制器中实现基于角色的限制的棘手部分。我们将首先创建一个助手，为我们提供一个在每个控制器中使用的函数。</p></div><div class="ab cl lp lq hc lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hn ho hp hq hr"><h2 id="e121" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">创建角色检查器助手</h2><p id="e803" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">我们需要做的下一件事是创建一个简单的方法来验证创建其他用户的用户是否确实是管理员。创建<strong class="it hv">web/models/role _ checker . ex</strong>，我们将用以下模块填充它:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="62db" class="jp jq hu mb b fv mf mg l mh mi">defmodule Pxblog.RoleChecker do<br/>  alias Pxblog.Repo<br/>  alias Pxblog.Role<br/><br/>  def is_admin?(user) do<br/>    (role = Repo.get(Role, user.role_id)) &amp;&amp; role.admin<br/>  end<br/>end</span></pre><p id="99a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还将编写一些测试来涵盖这一功能。打开<strong class="it hv">测试/模型/角色_检查器_测试. exs </strong>:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="2461" class="jp jq hu mb b fv mf mg l mh mi">defmodule Pxblog.RoleCheckerTest do<br/>  use Pxblog.ModelCase<br/>  alias Pxblog.TestHelper<br/>  alias Pxblog.RoleChecker<br/><br/>  test "is_admin? is true when user has an admin role" do<br/>    {:ok, role} = TestHelper.create_role(%{name: "Admin", admin: true})<br/>    {:ok, user} = TestHelper.create_user(role, %{email: "test@test.com", username: "user", password: "test", password_confirmation: "test"})<br/>    assert RoleChecker.is_admin?(user)<br/>  end<br/><br/>  test "is_admin? is false when user does not have an admin role" do<br/>    {:ok, role} = TestHelper.create_role(%{name: "User", admin: false})<br/>    {:ok, user} = TestHelper.create_user(role, %{email: "test@test.com", username: "user", password: "test", password_confirmation: "test"})<br/>    refute RoleChecker.is_admin?(user)<br/>  end<br/>end</span></pre><p id="0b85" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这两个测试中，我们都创建了一个角色和一个用户；在一个示例中，我们创建了一个管理员角色，而在下一个示例中，我们没有创建。最后，我们断言is_admin？函数为管理员用户返回true，为非管理员用户返回false。因为角色检查器的<strong class="it hv">是_admin？</strong>功能要求你供给用户，我们可以编写非常简单的测试来保证我们的功能。这是我们可以放心的代码！运行这些测试，并验证您的测试套件仍然是绿色的。</p><h2 id="14ba" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">将用户创建限制为管理员</h2><p id="c717" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">在我们的用户控制器中，我们从未编写任何authorize_user插件来限制这一点，所以我们现在要添加它们。我们将很快设计出来，以确保我们正在执行的行动是有意义的。我们将允许用户编辑、更新和删除他们自己的帐户，但我们只允许管理员查看新用户表单或创建新帐户。</p><p id="db95" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<strong class="it hv">web/controllers/user _ controller . ex</strong>中的<strong class="it hv"> scrub_params </strong>行下面，添加以下内容:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="4ecc" class="jp jq hu mb b fv mf mg l mh mi">plug :authorize_admin when action in [:new, :create]<br/>plug :authorize_user when action in [:edit, :update, :delete]</span></pre><p id="99a2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在底部，我们将添加一些私有函数来处理授权用户和授权管理员。</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="abb7" class="jp jq hu mb b fv mf mg l mh mi">defp authorize_user(conn, _) do<br/>  user = get_session(conn, :current_user)<br/>  if user &amp;&amp; (Integer.to_string(user.id) == conn.params["id"] || Pxblog.RoleChecker.is_admin?(user)) do<br/>    conn<br/>  else<br/>    conn<br/>    |&gt; put_flash(:error, "You are not authorized to modify that user!")<br/>    |&gt; redirect(to: page_path(conn, :index))<br/>    |&gt; halt()<br/>  end<br/>end<br/><br/>defp authorize_admin(conn, _) do<br/>  user = get_session(conn, :current_user)<br/>  if user &amp;&amp; Pxblog.RoleChecker.is_admin?(user) do<br/>    conn<br/>  else<br/>    conn<br/>    |&gt; put_flash(:error, "You are not authorized to create new users!")<br/>    |&gt; redirect(to: page_path(conn, :index))<br/>    |&gt; halt()<br/>  end<br/>end</span></pre><p id="fce6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个<strong class="it hv"> authorize_user </strong>调用基本上与我们的Post控制器相同，除了上面的if语句也检查我们新的<strong class="it hv"> RoleChecker.is_admin？</strong>呼。</p><p id="be11" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> authorize_admin </strong>更简单；我们只是检查当前用户是否是管理员。</p><p id="96e1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了验证这一切工作正常，我们将返回到我们的<strong class="it hv">test/controllers/user _ controller _ test . exs</strong>文件，并修改我们的测试，使其能够针对这些新的假设工作。</p><p id="8ef8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，我们必须改变我们的安装程序块，以适应这些新规则。</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="6812" class="jp jq hu mb b fv mf mg l mh mi">setup do<br/>  {:ok, user_role}     = TestHelper.create_role(%{name: "user", admin: false})<br/>  {:ok, nonadmin_user} = TestHelper.create_user(user_role, %{email: "nonadmin@test.com", username: "nonadmin", password: "test", password_confirmation: "test"})<br/><br/>  {:ok, admin_role}    = TestHelper.create_role(%{name: "admin", admin: true})<br/>  {:ok, admin_user}    = TestHelper.create_user(admin_role, %{email: "admin@test.com", username: "admin", password: "test", password_confirmation: "test"})<br/><br/>  {:ok, conn: build_conn(), admin_role: admin_role, user_role: user_role, nonadmin_user: nonadmin_user, admin_user: admin_user}<br/>end</span></pre><p id="cb11" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们创建一个用户角色、一个管理员角色、一个非管理员用户和一个管理员用户，然后将所有这些返回到我们的测试中，以便在模式匹配中使用。我们还需要一个助手函数来登录一个用户，所以我们将从我们的Post控制器中复制login_user函数。</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="03f0" class="jp jq hu mb b fv mf mg l mh mi">defp login_user(conn, user) do<br/>  post conn, session_path(conn, :create), user: %{username: user.username, password: user.password}<br/>end</span></pre><p id="4290" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们没有对index附加任何限制，所以我们可以跳过这个测试。下一个测试是我们的“为新资源呈现表单”，这是我们的新动作，有一个限制(必须是管理员)。</p><p id="faf4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">将该测试更改为以下代码:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="e595" class="jp jq hu mb b fv mf mg l mh mi">@tag admin: true<br/>test "renders form for new resources", %{conn: conn, admin_user: admin_user} do<br/>  conn = conn<br/>    |&gt; login_user(admin_user)<br/>    |&gt; get(user_path(conn, :new))<br/>  assert html_response(conn, 200) =~ "New user"<br/>end</span></pre><p id="a910" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们在测试上方添加了一个“@tag admin: true”行，将其标记为“admin”测试，这样我们就可以运行所有的admin测试，而不是整个套件。我们将使用以下命令运行这个测试:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="4409" class="jp jq hu mb b fv mf mg l mh mi">mix test --only admin</span></pre><p id="e061" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们的输出中，我们应该看到GRE-啊哦！我们失败了:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="0266" class="jp jq hu mb b fv mf mg l mh mi">1) test renders form for new resources (Pxblog.UserControllerTest)<br/> test/controllers/user_controller_test.exs:26<br/> ** (KeyError) key :role_id not found in: %{id: 348, username: “admin”}<br/> stacktrace:<br/> (pxblog) web/models/role_checker.ex:6: Pxblog.RoleChecker.is_admin?/1<br/> (pxblog) web/controllers/user_controller.ex:84: Pxblog.UserController.authorize_admin/2<br/> (pxblog) web/controllers/user_controller.ex:1: Pxblog.UserController.phoenix_controller_pipeline/2<br/> (pxblog) lib/phoenix/router.ex:255: Pxblog.Router.dispatch/2<br/> (pxblog) web/router.ex:1: Pxblog.Router.do_call/2<br/> (pxblog) lib/pxblog/endpoint.ex:1: Pxblog.Endpoint.phoenix_pipeline/1<br/> (pxblog) lib/phoenix/endpoint/render_errors.ex:34: Pxblog.Endpoint.call/2<br/> (phoenix) lib/phoenix/test/conn_test.ex:193: Phoenix.ConnTest.dispatch/5<br/> test/controllers/user_controller_test.exs:28</span></pre><p id="e320" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里的问题是我们没有将一个完整的用户模型传递给<strong class="it hv"> RoleChecker.is_admin？</strong>；相反，我们通过会话控制器的sign_in函数传递存储在current_user中的一小部分数据。我们将对其进行更新，以包含role_id。我在下面的<strong class="it hv">web/controllers/session _ controller . ex</strong>中添加了修改:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="9ed6" class="jp jq hu mb b fv mf mg l mh mi">defp sign_in(user, password, conn) do<br/>  if checkpw(password, user.password_digest) do<br/>    conn<br/>    |&gt; put_session(:current_user, %{id: user.id, username: user.username, role_id: user.role_id})<br/>    |&gt; put_flash(:info, "Sign in successful!")<br/>    |&gt; redirect(to: page_path(conn, :index))<br/>  else<br/>    failed_login(conn)<br/>  end<br/>end</span></pre><p id="0271" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们将运行我们的混合测试命令，只针对管理员标记的测试。</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="d7d2" class="jp jq hu mb b fv mf mg l mh mi">$ mix test --only admin</span></pre><p id="6f55" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">又变绿了！现在，我们需要创建一个否定测试，用于测试用户不是管理员，但试图访问用户的“新建”操作。回到<strong class="it hv">test/controllers/user _ controller _ test . exs</strong>:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="4fe6" class="jp jq hu mb b fv mf mg l mh mi">@tag admin: true<br/>test "redirects from new form when not admin", %{conn: conn, nonadmin_user: nonadmin_user} do<br/>  conn = login_user(conn, nonadmin_user)<br/>  conn = get conn, user_path(conn, :new)<br/>  assert get_flash(conn, :error) == "You are not authorized to create new users!"<br/>  assert redirected_to(conn) == page_path(conn, :index)<br/>  assert conn.halted<br/>end</span></pre><p id="5775" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将对创建操作进行同样的操作；创建一个有效测试和一个无效测试。</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="a841" class="jp jq hu mb b fv mf mg l mh mi">@tag admin: true<br/>test "creates resource and redirects when data is valid", %{conn: conn, user_role: user_role, admin_user: admin_user} do<br/>  conn = login_user(conn, admin_user)<br/>  conn = post conn, user_path(conn, :create), user: valid_create_attrs(user_role)<br/>  assert redirected_to(conn) == user_path(conn, :index)<br/>  assert Repo.get_by(User, @valid_attrs)<br/>end<br/><br/>@tag admin: true<br/>test "redirects from creating user when not admin", %{conn: conn, user_role: user_role, nonadmin_user: nonadmin_user} do<br/>  conn = login_user(conn, nonadmin_user)<br/>  conn = post conn, user_path(conn, :create), user: valid_create_attrs(user_role)<br/>  assert get_flash(conn, :error) == "You are not authorized to create new users!"<br/>  assert redirected_to(conn) == page_path(conn, :index)<br/>  assert conn.halted<br/>end<br/><br/>@tag admin: true<br/>test "does not create resource and renders errors when data is invalid", %{conn: conn, admin_user: admin_user} do<br/>  conn = login_user(conn, admin_user)<br/>  conn = post conn, user_path(conn, :create), user: @invalid_attrs<br/>  assert html_response(conn, 200) =~ "New user"<br/>end</span></pre><p id="29fd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以跳过节目，因为我们没有附加任何新的条件。我们将反复遵循这种模式，直到我们完成的<strong class="it hv">user _ controller<em class="mj">_</em>test . exs</strong>文件看起来像这样:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="6700" class="jp jq hu mb b fv mf mg l mh mi">defmodule Pxblog.UserControllerTest do<br/>  use Pxblog.ConnCase<br/>  alias Pxblog.User<br/>  alias Pxblog.TestHelper<br/><br/>  @valid_create_attrs %{email: "test@test.com", username: "test", password: "test", password_confirmation: "test"}<br/>  @valid_attrs %{email: "test@test.com", username: "test"}<br/>  @invalid_attrs %{}<br/><br/>  setup do<br/>    {:ok, user_role}     = TestHelper.create_role(%{name: "user", admin: false})<br/>    {:ok, nonadmin_user} = TestHelper.create_user(user_role, %{email: "nonadmin@test.com", username: "nonadmin", password: "test", password_confirmation: "test"})<br/><br/>{:ok, admin_role}    = TestHelper.create_role(%{name: "admin", admin: true})<br/>    {:ok, admin_user}    = TestHelper.create_user(admin_role, %{email: "admin@test.com", username: "admin", password: "test", password_confirmation: "test"})<br/><br/>    {:ok, conn: build_conn(), admin_role: admin_role, user_role: user_role, nonadmin_user: nonadmin_user, admin_user: admin_user}<br/>  end<br/><br/>  defp valid_create_attrs(role) do<br/>    Map.put(@valid_create_attrs, :role_id, role.id)<br/>  end<br/><br/>  defp login_user(conn, user) do<br/>    post conn, session_path(conn, :create), user: %{username: user.username, password: user.password}<br/>  end<br/><br/>  test "lists all entries on index", %{conn: conn} do<br/>    conn = get conn, user_path(conn, :index)<br/>    assert html_response(conn, 200) =~ "Listing users"<br/>  end<br/><br/>  @tag admin: true<br/>  test "renders form for new resources", %{conn: conn, admin_user: admin_user} do<br/>    conn = login_user(conn, admin_user)<br/>    conn = get conn, user_path(conn, :new)<br/>    assert html_response(conn, 200) =~ "New user"<br/>  end<br/><br/>  @tag admin: true<br/>  test "redirects from new form when not admin", %{conn: conn, nonadmin_user: nonadmin_user} do<br/>    conn = login_user(conn, nonadmin_user)<br/>    conn = get conn, user_path(conn, :new)<br/>    assert get_flash(conn, :error) == "You are not authorized to create new users!"<br/>    assert redirected_to(conn) == page_path(conn, :index)<br/>    assert conn.halted<br/>  end<br/><br/>  @tag admin: true<br/>  test "creates resource and redirects when data is valid", %{conn: conn, user_role: user_role, admin_user: admin_user} do<br/>    conn = login_user(conn, admin_user)<br/>    conn = post conn, user_path(conn, :create), user: valid_create_attrs(user_role)<br/>    assert redirected_to(conn) == user_path(conn, :index)<br/>    assert Repo.get_by(User, @valid_attrs)<br/>  end<br/><br/>  @tag admin: true<br/>  test "redirects from creating user when not admin", %{conn: conn, user_role: user_role, nonadmin_user: nonadmin_user} do<br/>    conn = login_user(conn, nonadmin_user)<br/>    conn = post conn, user_path(conn, :create), user: valid_create_attrs(user_role)<br/>    assert get_flash(conn, :error) == "You are not authorized to create new users!"<br/>    assert redirected_to(conn) == page_path(conn, :index)<br/>    assert conn.halted<br/>  end<br/><br/>  @tag admin: true<br/>  test "does not create resource and renders errors when data is invalid", %{conn: conn, admin_user: admin_user} do<br/>    conn = login_user(conn, admin_user)<br/>    conn = post conn, user_path(conn, :create), user: @invalid_attrs<br/>    assert html_response(conn, 200) =~ "New user"<br/>  end<br/><br/>  test "shows chosen resource", %{conn: conn} do<br/>    user = Repo.insert! %User{}<br/>    conn = get conn, user_path(conn, :show, user)<br/>    assert html_response(conn, 200) =~ "Show user"<br/>  end<br/><br/>  test "renders page not found when id is nonexistent", %{conn: conn} do<br/>    assert_error_sent 404, fn -&gt;<br/>      get conn, user_path(conn, :show, -1)<br/>    end<br/>  end<br/><br/>  @tag admin: true<br/>  test "renders form for editing chosen resource when logged in as that user", %{conn: conn, nonadmin_user: nonadmin_user} do<br/>    conn = login_user(conn, nonadmin_user)<br/>    conn = get conn, user_path(conn, :edit, nonadmin_user)<br/>    assert html_response(conn, 200) =~ "Edit user"<br/>  end<br/><br/>  @tag admin: true<br/>  test "renders form for editing chosen resource when logged in as an admin", %{conn: conn, admin_user: admin_user, nonadmin_user: nonadmin_user} do<br/>    conn = login_user(conn, admin_user)<br/>    conn = get conn, user_path(conn, :edit, nonadmin_user)<br/>    assert html_response(conn, 200) =~ "Edit user"<br/>  end<br/><br/>  @tag admin: true<br/>  test "redirects away from editing when logged in as a different user", %{conn: conn, nonadmin_user: nonadmin_user, admin_user: admin_user} do<br/>    conn = login_user(conn, nonadmin_user)<br/>    conn = get conn, user_path(conn, :edit, admin_user)<br/>    assert get_flash(conn, :error) == "You are not authorized to modify that user!"<br/>    assert redirected_to(conn) == page_path(conn, :index)<br/>    assert conn.halted<br/>  end<br/><br/>  @tag admin: true<br/>  test "updates chosen resource and redirects when data is valid when logged in as that user", %{conn: conn, nonadmin_user: nonadmin_user} do<br/>    conn = login_user(conn, nonadmin_user)<br/>    conn = put conn, user_path(conn, :update, nonadmin_user), user: @valid_create_attrs<br/>    assert redirected_to(conn) == user_path(conn, :show, nonadmin_user)<br/>    assert Repo.get_by(User, @valid_attrs)<br/>  end<br/><br/>  @tag admin: true<br/>  test "updates chosen resource and redirects when data is valid when logged in as an admin", %{conn: conn, admin_user: admin_user} do<br/>    conn = login_user(conn, admin_user)<br/>    conn = put conn, user_path(conn, :update, admin_user), user: @valid_create_attrs<br/>    assert redirected_to(conn) == user_path(conn, :show, admin_user)<br/>    assert Repo.get_by(User, @valid_attrs)<br/>  end<br/><br/>  @tag admin: true<br/>  test "does not update chosen resource when logged in as different user", %{conn: conn, nonadmin_user: nonadmin_user, admin_user: admin_user} do<br/>    conn = login_user(conn, nonadmin_user)<br/>    conn = put conn, user_path(conn, :update, admin_user), user: @valid_create_attrs<br/>    assert get_flash(conn, :error) == "You are not authorized to modify that user!"<br/>    assert redirected_to(conn) == page_path(conn, :index)<br/>    assert conn.halted<br/>  end<br/><br/>  @tag admin: true<br/>  test "does not update chosen resource and renders errors when data is invalid", %{conn: conn, nonadmin_user: nonadmin_user} do<br/>    conn = login_user(conn, nonadmin_user)<br/>    conn = put conn, user_path(conn, :update, nonadmin_user), user: @invalid_attrs<br/>    assert html_response(conn, 200) =~ "Edit user"<br/>  end<br/><br/>  @tag admin: true<br/>  test "deletes chosen resource when logged in as that user", %{conn: conn, user_role: user_role} do<br/>    {:ok, user} = TestHelper.create_user(user_role, @valid_create_attrs)<br/>    conn =<br/>      login_user(conn, user)<br/>      |&gt; delete(user_path(conn, :delete, user))<br/>    assert redirected_to(conn) == user_path(conn, :index)<br/>    refute Repo.get(User, user.id)<br/>  end<br/><br/>  @tag admin: true<br/>  test "deletes chosen resource when logged in as an admin", %{conn: conn, user_role: user_role, admin_user: admin_user} do<br/>    {:ok, user} = TestHelper.create_user(user_role, @valid_create_attrs)<br/>    conn =<br/>      login_user(conn, admin_user)<br/>      |&gt; delete(user_path(conn, :delete, user))<br/>    assert redirected_to(conn) == user_path(conn, :index)<br/>    refute Repo.get(User, user.id)<br/>  end<br/><br/>  @tag admin: true<br/>  test "redirects away from deleting chosen resource when logged in as a different user", %{conn: conn, user_role: user_role, nonadmin_user: nonadmin_user} do<br/>    {:ok, user} = TestHelper.create_user(user_role, @valid_create_attrs)<br/>    conn =<br/>      login_user(conn, nonadmin_user)<br/>      |&gt; delete(user_path(conn, :delete, user))<br/>    assert get_flash(conn, :error) == "You are not authorized to modify that user!"<br/>    assert redirected_to(conn) == page_path(conn, :index)<br/>    assert conn.halted<br/>  end<br/>end</span></pre><p id="4d8d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们运行我们的完整测试套件，我们都回到绿色！</p><h2 id="fcec" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">允许管理员修改所有帖子</h2><p id="4abd" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">令人欣慰的是，我们已经做了几乎所有的工作，使这最后一块管理功能的工作符合预期。我们将打开<strong class="it hv">web/controllers/post _ controller . ex</strong>并修改<strong class="it hv"> authorize_user </strong>函数以使用我们的<strong class="it hv"> RoleChecker.is_admin？</strong>帮助功能，查看用户是否是管理员。如果是的话，我们将给予他们修改任何用户帖子的完全控制权。</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="10cb" class="jp jq hu mb b fv mf mg l mh mi">defp authorize_user(conn, _) do<br/>  user = get_session(conn, :current_user)<br/>  if user &amp;&amp; (Integer.to_string(user.id) == conn.params["user_id"] || Pxblog.RoleChecker.is_admin?(user)) do<br/>    conn<br/>  else<br/>    conn<br/>    |&gt; put_flash(:error, "You are not authorized to modify that post!")<br/>    |&gt; redirect(to: page_path(conn, :index))<br/>    |&gt; halt()<br/>  end<br/>end</span></pre><p id="cdca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我们将打开<strong class="it hv">test/controllers/post _ controller _ test . exs</strong>，并在底部添加更多测试，涵盖我们的授权规则:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="ad6a" class="jp jq hu mb b fv mf mg l mh mi">test "redirects when trying to delete a post for a different user", %{conn: conn, role: role, post: post} do<br/>  {:ok, other_user} = TestHelper.create_user(role, %{email: "test2@test.com", username: "test2", password: "test", password_confirmation: "test"})<br/>  conn = delete conn, user_post_path(conn, :delete, other_user, post)<br/>  assert get_flash(conn, :error) == "You are not authorized to modify that post!"<br/>  assert redirected_to(conn) == page_path(conn, :index)<br/>  assert conn.halted<br/>end<br/><br/>test "renders form for editing chosen resource when logged in as admin", %{conn: conn, user: user, post: post} do<br/>  {:ok, role}  = TestHelper.create_role(%{name: "Admin", admin: true})<br/>  {:ok, admin} = TestHelper.create_user(role, %{username: "admin", email: "admin@test.com", password: "test", password_confirmation: "test"})<br/>  conn =<br/>    login_user(conn, admin)<br/>    |&gt; get(user_post_path(conn, :edit, user, post))<br/>  assert html_response(conn, 200) =~ "Edit post"<br/>end<br/><br/>test "updates chosen resource and redirects when data is valid when logged in as admin", %{conn: conn, user: user, post: post} do<br/>  {:ok, role}  = TestHelper.create_role(%{name: "Admin", admin: true})<br/>  {:ok, admin} = TestHelper.create_user(role, %{username: "admin", email: "admin@test.com", password: "test", password_confirmation: "test"})<br/>  conn =<br/>    login_user(conn, admin)<br/>    |&gt; put(user_post_path(conn, :update, user, post), post: @valid_attrs)<br/>  assert redirected_to(conn) == user_post_path(conn, :show, user, post)<br/>  assert Repo.get_by(Post, @valid_attrs)<br/>end<br/><br/>test "does not update chosen resource and renders errors when data is invalid when logged in as admin", %{conn: conn, user: user, post: post} do<br/>  {:ok, role}  = TestHelper.create_role(%{name: "Admin", admin: true})<br/>  {:ok, admin} = TestHelper.create_user(role, %{username: "admin", email: "admin@test.com", password: "test", password_confirmation: "test"})<br/>  conn =<br/>    login_user(conn, admin)<br/>    |&gt; put(user_post_path(conn, :update, user, post), post: %{"body" =&gt; nil})<br/>  assert html_response(conn, 200) =~ "Edit post"<br/>end<br/><br/>test "deletes chosen resource when logged in as admin", %{conn: conn, user: user, post: post} do<br/>  {:ok, role}  = TestHelper.create_role(%{name: "Admin", admin: true})<br/>  {:ok, admin} = TestHelper.create_user(role, %{username: "admin", email: "admin@test.com", password: "test", password_confirmation: "test"})<br/>  conn =<br/>    login_user(conn, admin)<br/>    |&gt; delete(user_post_path(conn, :delete, user, post))<br/>  assert redirected_to(conn) == user_post_path(conn, :index, user)<br/>  refute Repo.get(Post, post.id)<br/>end</span></pre><p id="4df1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们的博客引擎正在嗡嗡作响，但还是有一些bug，不管是由于遗漏还是我一路上错过的东西，所以让我们确定并解决一些bug。我们还将升级依赖关系的版本，以确保这是运行在最新和最好的一切，它可以！</p><h2 id="7339" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">添加新用户会引发关于缺少角色的错误</h2><p id="b2a0" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">这是由<a class="ml mm gr" href="https://medium.com/u/3c497d21a78?source=post_page-----9f4678b48468--------------------------------" rel="noopener" target="_blank">诺洛特斯</a>在Pxblog github页面(<a class="ae mk" href="https://github.com/Diamond/pxblog" rel="noopener ugc nofollow" target="_blank">https://github.com/Diamond/pxblog</a>)上向我指出的一个问题(谢谢！).从part_3分支开始，如果您尝试创建一个新用户，将会由于缺少指定的角色而失败(因为我们确实为新用户创建了必需的role_id)。让我们首先探索这个问题，然后我们将开始实施一个修复方案。当我们以管理员身份登录并转到/users/new时，在填写完所有内容后，我们会看到以下错误:</p><figure class="lw lx ly lz fq mo fe ff paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="fe ff mn"><img src="../Images/6f726db51ba6e61642ceef7bdd2194d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lsHQOqW3NRwE_77NrA1TBw.png"/></div></div><figcaption class="mv mw fg fe ff mx my bd b be z ek">Our failing user creation error message</figcaption></figure><p id="aa96" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这很有道理。我们要求用户输入用户名、电子邮件、密码和password_confirmation，但不输入任何角色信息。知道了这一点，我们将开始把可供选择的角色列表传递给我们的控制器。</p><p id="9fe0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将首先向每个需要能够选择它们的动作传递一个角色列表，在我们的例子中，这意味着<strong class="it hv">新建、创建、编辑和更新</strong>动作。先扔个<strong class="it hv">别名Pxblog。Role </strong>添加到用户控制器(<strong class="it hv">web/controllers/User _ Controller . ex</strong>)的顶部，如果它还不在那里的话。然后，我们将修改<strong class="it hv">新建</strong>、<strong class="it hv">编辑</strong>、<strong class="it hv">创建</strong>和<strong class="it hv">更新</strong>动作:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="3532" class="jp jq hu mb b fv mf mg l mh mi">def new(conn, _params) do<br/>  roles = Repo.all(Role)<br/>  changeset = User.changeset(%User{})<br/>  render(conn, "new.html", changeset: changeset, roles: roles)<br/>end</span><span id="fff5" class="jp jq hu mb b fv mz mg l mh mi">def edit(conn, %{"id" =&gt; id}) do<br/>  roles = Repo.all(Role)<br/>  user = Repo.get!(User, id)<br/>  changeset = User.changeset(user)<br/>  render(conn, "edit.html", user: user, changeset: changeset, roles: roles)<br/>end</span><span id="03f4" class="jp jq hu mb b fv mz mg l mh mi">def create(conn, %{"user" =&gt; user_params}) do<br/>  roles = Repo.all(Role)<br/>  changeset = User.changeset(%User{}, user_params)<br/><br/>  case Repo.insert(changeset) do<br/>    {:ok, _user} -&gt;<br/>      conn<br/>      |&gt; put_flash(:info, "User created successfully.")<br/>      |&gt; redirect(to: user_path(conn, :index))<br/>    {:error, changeset} -&gt;<br/>      render(conn, "new.html", changeset: changeset, roles: roles)<br/>  end<br/>end</span><span id="8723" class="jp jq hu mb b fv mz mg l mh mi">def update(conn, %{"id" =&gt; id, "user" =&gt; user_params}) do<br/>  roles = Repo.all(Role)<br/>  user = Repo.get!(User, id)<br/>  changeset = User.changeset(user, user_params)<br/><br/>  case Repo.update(changeset) do<br/>    {:ok, user} -&gt;<br/>      conn<br/>      |&gt; put_flash(:info, "User updated successfully.")<br/>      |&gt; redirect(to: user_path(conn, :show, user))<br/>    {:error, changeset} -&gt;<br/>      render(conn, "edit.html", user: user, changeset: changeset, roles: roles)<br/>  end<br/>end</span></pre><p id="5498" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，对于所有这些角色，通过<strong class="it hv"> Repo.all(Role) </strong>选择所有角色，并将它们添加到我们发送给视图的赋值列表中(包括在错误情况下的render语句中)。</p><p id="0ebc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还需要实现一个选择框，所以让我们看看使用Phoenix.Html表单帮助器进行选择的文档(摘自<a class="ae mk" href="https://hexdocs.pm/phoenix_html/Phoenix.HTML.Form.html#select/4" rel="noopener ugc nofollow" target="_blank">https://hexdocs.pm/phoenix_html/Phoenix.HTML.Form.html#select/4 </a>):</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="4e5a" class="jp jq hu mb b fv mf mg l mh mi">select(form, field, values, opts \\ [])<br/>  Generates a select tag with the given values.</span></pre><p id="ad7b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于<strong class="it hv">值</strong>参数，选择框需要列表或关键字列表，其形式为<em class="mj">[值，值，值] </em>或<em class="mj">[显示:值，显示:值] </em>。在我们的例子中，我们希望显示角色名，但是让它在表单submit中携带id值。我们不能盲目地将@roles放入其中，因为它不符合任何一种格式，所以让我们在我们的视图中编写一个函数来简化它:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="08f4" class="jp jq hu mb b fv mf mg l mh mi">defmodule Pxblog.UserView do<br/>  use Pxblog.Web, :view<br/><br/>  def roles_for_select(roles) do<br/>    roles<br/>    |&gt; Enum.map(&amp;["#{&amp;1.name}": &amp;1.id])<br/>    |&gt; List.flatten<br/>  end<br/>end</span></pre><p id="b9a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们添加了一个<strong class="it hv"> roles_for_select </strong>函数，它只接受一组角色。让我们一行一行地探索这个函数的作用。我们从我们的系列开始，然后将它输送到下一个系列:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="3b85" class="jp jq hu mb b fv mf mg l mh mi">Enum.map(&amp;["#{&amp;1.name}": &amp;1.id])</span></pre><p id="0ff4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样，记住&amp;/&amp;1是匿名函数的简写语法，所以如果我们放弃管道操作和简写，我们会看到这个函数被重写为:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="7bf2" class="jp jq hu mb b fv mf mg l mh mi">Enum.map(roles, fn role -&gt; ["#{role.name}": role.id] end)</span></pre><p id="9a5c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们运行map操作来返回一个较小的关键字列表，其中角色的名称是键，角色的id是值。</p><p id="a428" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">给定以下角色的特定起始值:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="18ec" class="jp jq hu mb b fv mf mg l mh mi">roles = [%Role{name: "Admin Role", id: 1}, %Role{name: "User Role", id: 2}]</span></pre><p id="82d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个map调用将返回:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="0335" class="jp jq hu mb b fv mf mg l mh mi">[["Admin Role": 1], ["User Role": 2]]</span></pre><p id="b5c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我们把它放到最后一个调用中，<strong class="it hv"> List.flatten </strong>把它压缩成一个方便的列表，而不是一个列表列表。所以我们的最终结果是:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="56dc" class="jp jq hu mb b fv mf mg l mh mi">["Admin Role": 1, "User Role": 2]</span></pre><p id="69d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这恰好是选择表单助手所期望的格式！我们还不能沾沾自喜；我们还需要修改<strong class="it hv">网页/模板/用户/new.html.eex: </strong>的模板</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="7afa" class="jp jq hu mb b fv mf mg l mh mi">&lt;h2&gt;New user&lt;/h2&gt;<br/><br/>&lt;%= render "form.html", changeset: @changeset,<br/>                        action: user_path(@conn, :create),<br/>                        roles: @roles %&gt;<br/><br/>&lt;%= link "Back", to: user_path(@conn, :index) %&gt;</span></pre><p id="be08" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以及<strong class="it hv">web/templates/user/edit . html . eex</strong>:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="9d9e" class="jp jq hu mb b fv mf mg l mh mi">&lt;h2&gt;Edit user&lt;/h2&gt;</span><span id="1d38" class="jp jq hu mb b fv mz mg l mh mi">&lt;%= render "form.html", changeset: @changeset,<br/>                        action: user_path(@conn, :update, @user),<br/>                        roles: @roles %&gt;</span><span id="c287" class="jp jq hu mb b fv mz mg l mh mi">&lt;%= link "Back", to: user_path(@conn, :index) %&gt;</span></pre><p id="d20a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，在<strong class="it hv">web/templates/user/form . html . eex</strong>中，您将希望使用我们的助手和角色分配添加到我们的新选择框中。我们希望添加一个选择框，包含用户可以进入的每个角色。在提交按钮前添加以下内容:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="5200" class="jp jq hu mb b fv mf mg l mh mi">&lt;div class="form-group"&gt;<br/>  &lt;%= label f, :role_id, "Role", class: "control-label" %&gt;<br/>  &lt;%= select f, :role_id, roles_for_select(@roles), class: "form-control" %&gt;<br/>  &lt;%= error_tag f, :role_id %&gt;<br/>&lt;/div&gt;</span></pre><p id="103e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，如果您尝试添加新用户或编辑现有用户，您将能够为该用户分配一个角色！我们的清单上少了一个bug！</p><h2 id="2af0" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">多次运行我们的种子会复制数据</h2><p id="2985" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">现在，如果我们多次运行我们的种子，我们最终会错误地复制数据，这是不好的。让我们实现几个助手<strong class="it hv"> find_or_create </strong>匿名函数:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="645f" class="jp jq hu mb b fv mf mg l mh mi">alias Pxblog.Repo<br/>alias Pxblog.Role<br/>alias Pxblog.User<br/>import Ecto.Query, only: [from: 2]<br/><br/>find_or_create_role = fn role_name, admin -&gt;<br/>  case Repo.all(from r in Role, where: r.name == ^role_name and r.admin == ^admin) do<br/>    [] -&gt;<br/>      %Role{}<br/>      |&gt; Role.changeset(%{name: role_name, admin: admin})<br/>      |&gt; Repo.insert!()<br/>    _ -&gt;<br/>      IO.puts "Role: #{role_name} already exists, skipping"<br/>  end<br/>end<br/><br/>find_or_create_user = fn username, email, role -&gt;<br/>  case Repo.all(from u in User, where: u.username == ^username and u.email == ^email) do<br/>    [] -&gt;<br/>      %User{}<br/>      |&gt; User.changeset(%{username: username, email: email, password: "test", password_confirmation: "test", role_id: role.id})<br/>      |&gt; Repo.insert!()<br/>    _ -&gt;<br/>      IO.puts "User: #{username} already exists, skipping"<br/>  end<br/>end<br/><br/>_user_role  = find_or_create_role.("User Role", false)<br/>admin_role  = find_or_create_role.("Admin Role", true)<br/>_admin_user = find_or_create_user.("admin", "admin@test.com", admin_role)</span></pre><p id="fa11" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先要注意的是，我们混淆了我们的Repo、Role和User，并且我们还从Ecto的函数中导入了<strong class="it hv">。查询以使用linq样式的查询语法。接下来，我们将看看<strong class="it hv"> find_or_create_role </strong>匿名函数。该函数本身只接受一个角色名和一个管理标志作为其参数。在此基础上，我们使用Repo.all查询这些标准(注意where子句中每个变量旁边的^；我们不想在这里做任何模式匹配或任何事情)并将其放入case语句中。如果我们用Repo.all找不到任何东西，我们将得到一个空列表，因此如果我们得到一个空列表，我们将插入角色。否则，我们假设我们已经获得了一些匹配条件，我们将承认它已经存在，并继续处理种子文件的其余部分。<strong class="it hv"> find_or_create_user </strong>执行相同的操作，但只是寻找不同的标准。</strong></p><p id="ede3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我们调用这些函数中的每一个(注意。在函数名和参数之间；这是匿名函数调用所必需的！).我们需要重用admin角色来创建admin用户，所以我们没有在admin_role前面加下划线。我们以后可能会决定为以后的种子保留user_role或admin用户，所以我将保留这些代码，但在它们前面加上下划线。它使种子文件看起来又好又干净。现在已经完成了，我们准备运行我们的种子:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="481b" class="jp jq hu mb b fv mf mg l mh mi">$ mix run priv/repo/seeds.exs<br/>[debug] SELECT r0.”id”, r0.”name”, r0.”admin”, r0.”inserted_at”, r0.”updated_at” FROM “roles” AS r0 WHERE ((r0.”name” = $1) AND (r0.”admin” = $2)) [“User Role”, false] OK query=81.7ms queue=2.8ms<br/>[debug] BEGIN [] OK query=0.2ms<br/>[debug] INSERT INTO “roles” (“admin”, “inserted_at”, “name”, “updated_at”) VALUES ($1, $2, $3, $4) RETURNING “id” [false, {{2015, 11, 6}, {19, 35, 49, 0}}, “User Role”, {{2015, 11, 6}, {19, 35, 49, 0}}] OK query=0.8ms<br/>[debug] COMMIT [] OK query=0.4ms<br/>[debug] SELECT r0.”id”, r0.”name”, r0.”admin”, r0.”inserted_at”, r0.”updated_at” FROM “roles” AS r0 WHERE ((r0.”name” = $1) AND (r0.”admin” = $2)) [“Admin Role”, true] OK query=0.4ms<br/>[debug] BEGIN [] OK query=0.2ms<br/>[debug] INSERT INTO “roles” (“admin”, “inserted_at”, “name”, “updated_at”) VALUES ($1, $2, $3, $4) RETURNING “id” [true, {{2015, 11, 6}, {19, 35, 49, 0}}, “Admin Role”, {{2015, 11, 6}, {19, 35, 49, 0}}] OK query=0.4ms<br/>[debug] COMMIT [] OK query=0.3ms<br/>[debug] SELECT u0.”id”, u0.”username”, u0.”email”, u0.”password_digest”, u0.”role_id”, u0.”inserted_at”, u0.”updated_at” FROM “users” AS u0 WHERE ((u0.”username” = $1) AND (u0.”email” = $2)) [“admin”, “<a class="ae mk" href="mailto:admin@test.com" rel="noopener ugc nofollow" target="_blank">admin@test.com</a>”] OK query=0.7ms<br/>[debug] BEGIN [] OK query=0.3ms<br/>[debug] INSERT INTO “users” (“email”, “inserted_at”, “password_digest”, “role_id”, “updated_at”, “username”) VALUES ($1, $2, $3, $4, $5, $6) RETURNING “id” [“<a class="ae mk" href="mailto:admin@test.com" rel="noopener ugc nofollow" target="_blank">admin@test.com</a>”, {{2015, 11, 6}, {19, 35, 49, 0}}, “$2b$12$.MuPBUVe/7/9HSOsccJYUOAD5IKEB77Pgz2oTJ/UvTvWYwAGn/L.i”, 2, {{2015, 11, 6}, {19, 35, 49, 0}}, “admin”] OK query=1.2ms<br/>[debug] COMMIT [] OK query=1.1ms</span></pre><p id="e9ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们第一次运行它时，看到一堆insert语句！太棒了。为了确保一切正常，让我们再运行一次，验证我们没有看到任何插入:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="6810" class="jp jq hu mb b fv mf mg l mh mi">$ mix run priv/repo/seeds.exs<br/>Role: User Role already exists, skipping<br/>[debug] SELECT r0.”id”, r0.”name”, r0.”admin”, r0.”inserted_at”, r0.”updated_at” FROM “roles” AS r0 WHERE ((r0.”name” = $1) AND (r0.”admin” = $2)) [“User Role”, false] OK query=104.8ms queue=3.6ms<br/>Role: Admin Role already exists, skipping<br/>[debug] SELECT r0.”id”, r0.”name”, r0.”admin”, r0.”inserted_at”, r0.”updated_at” FROM “roles” AS r0 WHERE ((r0.”name” = $1) AND (r0.”admin” = $2)) [“Admin Role”, true] OK query=0.6ms<br/>User: admin already exists, skipping<br/>[debug] SELECT u0.”id”, u0.”username”, u0.”email”, u0.”password_digest”, u0.”role_id”, u0.”inserted_at”, u0.”updated_at” FROM “users” AS u0 WHERE ((u0.”username” = $1) AND (u0.”email” = $2)) [“admin”, “<a class="ae mk" href="mailto:admin@test.com" rel="noopener ugc nofollow" target="_blank">admin@test.com</a>”] OK query=0.8ms</span></pre><p id="6e96" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">太好了！一切正常，安全多了！此外，我们还可以为Ecto编写自己的实用函数，从中获得一些乐趣！</p><h2 id="cf97" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">关于测试中重复管理用户的错误</h2><p id="4b80" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">因为我们修改了种子来创建一个新用户，所以如果您在任何时候重置您的测试数据库，您将开始遇到问题，因为您不能创建一个已经存在的用户。有一个简单的(暂时的)方法可以解决这个问题。打开<strong class="it hv">test/support/test _ helper . ex</strong>，修改<strong class="it hv"> create_user </strong>函数:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="8798" class="jp jq hu mb b fv mf mg l mh mi">def create_user(role, %{email: email, username: username, password: password, password_confirmation: password_confirmation}) do<br/>  if user = Repo.get_by(User, username: username) do<br/>    Repo.delete(user)<br/>  end<br/>  role<br/>  |&gt; build_assoc(:users)<br/>  |&gt; User.changeset(%{email: email, username: username, password: password, password_confirmation: password_confirmation})<br/>  |&gt; Repo.insert<br/>end</span></pre><h2 id="8752" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">我们现在在哪里？</h2><p id="c6ab" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">现在，我们有了绿色规范，我们有了用户、帖子和角色。我们实现了限制用户注册、修改用户和帖子的sane功能，并实现了一些助手，使我们编写代码时的生活更加轻松。在接下来的几篇文章中，我们将花些时间为我们的博客引擎添加一些很酷的新功能！</p><h2 id="2bb9" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">本系列的下一篇文章</h2><div class="kk kl fm fo km kn"><a rel="noopener follow" target="_blank" href="/@diamondgfx/mixology-exmachina-92a08dc3e954"><div class="ko ab ej"><div class="kp ab kq cl cj kr"><h2 class="bd hv fv z el ks eo ep kt er et ht dt translated">用Phoenix和Elixir编写博客引擎:第5部分，添加ExMachina</h2><div class="ku l"><h3 class="bd b fv z el ks eo ep kt er et ek translated">最新更新:2016年1月26日</h3></div><div class="kv l"><p class="bd b gc z el ks eo ep kt er et ek translated">medium.com</p></div></div></div></a></div><h1 id="be89" class="na jq hu bd jr nb nc nd jv ne nf ng jz nh ni nj kc nk nl nm kf nn no np ki nq dt translated">看看我的新书！</h1><p id="8477" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">嘿大家好！如果你喜欢你在这里读到的东西，并且想和我一起学习更多，可以看看我的新书《长生不老药和凤凰网开发》:</p><div class="kk kl fm fo km kn"><a href="https://www.packtpub.com/web-development/phoenix-web-development" rel="noopener  ugc nofollow" target="_blank"><div class="ko ab ej"><div class="kp ab kq cl cj kr"><h2 class="bd hv fv z el ks eo ep kt er et ht dt translated">凤凰网开发| PACKT图书</h2><div class="ku l"><h3 class="bd b fv z el ks eo ep kt er et ek translated">学习使用Elixir和……从头开始构建投票web应用程序的高性能功能原型</h3></div><div class="kv l"><p class="bd b gc z el ks eo ep kt er et ek translated">www.packtpub.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw mt kn"/></div></div></a></div><p id="1687" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我真的很兴奋终于可以把这个项目推向世界了！它的写作风格与我的其他教程一样，我们将从头到尾构建一个完整项目的框架，甚至涵盖一些更棘手的主题，如文件上传、Twitter/Google OAuth登录和API！</p><div class="lw lx ly lz fq ab cb"><figure class="nx mo ny nz oa ob oc paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nx mo ny nz oa ob oc paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nx mo ny nz oa ob oc paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="od oe of"><p id="f922" class="ir is mj it b iu iv iw ix iy iz ja jb og jd je jf oh jh ji jj oi jl jm jn jo hn dt translated"><a class="ae mk" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae mk" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae mk" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae mk" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is mj it b iu iv iw ix iy iz ja jb og jd je jf oh jh ji jj oi jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae mk" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae mk" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lw lx ly lz fq mo fe ff paragraph-image"><a href="https://goo.gl/Ahtev1"><div class="fe ff oj"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></a></figure></div></div>    
</body>
</html>