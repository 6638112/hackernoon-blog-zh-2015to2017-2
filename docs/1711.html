<html>
<head>
<title>How to Handle Github Pull Requests Like A Boss</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何像老板一样处理Github拉取请求</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-handle-github-pull-requests-like-a-boss-8693f4c57974?source=collection_archive---------3-----------------------#2016-12-01">https://medium.com/hackernoon/how-to-handle-github-pull-requests-like-a-boss-8693f4c57974?source=collection_archive---------3-----------------------#2016-12-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="a5f5" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">从Github轻松获取Pull请求的“古老而珍贵”的技巧</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/313ee310bb3e61e9b27f0d054d38280b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wzEf4qVNT7mUeMIeQWTJbg.jpeg"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">A dark wallpaper with the Github logo's silhouette in the center</figcaption></figure><p id="0c2d" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在<a class="ae kv" href="https://hackernoon.com/tagged/github" rel="noopener ugc nofollow" target="_blank"> Github </a>上托管的受欢迎的<a class="ae kv" href="https://hackernoon.com/tagged/open-source" rel="noopener ugc nofollow" target="_blank">开源</a>项目中，有一个广泛使用的实践来有效地接收贡献。贡献者创建一个代表单个特性的小分支，当这个分支被推到贡献者的分支时，他们创建一个拉请求。在之前的一篇名为<a class="ae kv" rel="noopener" href="/@fagnerbrack/one-pull-request-one-concern-e84a27dfe9f1"> One Pull Request的文章中，我已经详细阐述了如何做到这一点的最佳实践。一个问题。</a></p><p id="4d4c" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">从撰写本文时起，jQuery在其贡献者中广泛使用这种模型。他们在他们的<a class="ae kv" href="https://contribute.jquery.org/commits-and-pull-requests/" rel="noopener ugc nofollow" target="_blank">提交和拉取请求</a>指南中记录模型，并将其作为新贡献的需求。他们已经用了好几年了。</p><blockquote class="kw"><p id="6f18" class="kx ky hu bd kz la lb lc ld le lf ku ek translated">开源项目中的一个常见做法是请求贡献者派生项目，创建一个临时分支，并从该分支创建一个代表<a class="ae kv" rel="noopener" href="/@fagnerbrack/one-pull-request-one-concern-e84a27dfe9f1">单个关注点</a>的拉请求。</p></blockquote><p id="805a" class="pw-post-body-paragraph jz ka hu kb b kc lg iv ke kf lh iy kh ki li kk kl km lj ko kp kq lk ks kt ku hn dt translated">有些公司也使用这种模式来管理他们的发展。拉请求允许开发人员频繁地集成他们的更改，这减少了代码冲突的机会，并使及早发现bug成为可能。这是早期反馈，是<a class="ae kv" href="https://www.thoughtworks.com/pt/continuous-integration" rel="noopener ugc nofollow" target="_blank">持续集成</a>的核心原则之一。</p><p id="e65b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">不过，我们可以用一个技巧来管理拉请求。</p><p id="7547" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">当使用Github时，有权合并主分支请求的每个人都有两种选择:</p><ol class=""><li id="2253" class="ll lm hu kb b kc kd kf kg ki ln km lo kq lp ku lq lr ls lt dt translated">使用<a class="ae kv" href="https://help.github.com/articles/merging-a-pull-request/" rel="noopener ugc nofollow" target="_blank"> Github Pull请求UI将提交合并到</a>主分支。</li><li id="aa7a" class="ll lm hu kb b kc lu kf lv ki lw km lx kq ly ku lq lr ls lt dt translated">在命令行中使用<a class="ae kv" href="https://git-scm.com/" rel="noopener ugc nofollow" target="_blank"> git </a>添加对拉请求分支的引用，作为本地的远程请求(<code class="eh lz ma mb mc b">git remote add &lt;contributor's fork url&gt;</code>)，从该远程请求获取拉请求分支，然后将提交合并到主分支。</li></ol><p id="6b72" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><strong class="kb hv">第一个选项</strong>是最常见也是最简单的一个。任何有权限的人都可以到Github上的Pull请求页面，点击“合并”按钮。</p><p id="c388" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><strong class="kb hv">第二个选项</strong>最常用于合并拉请求的人想要完全控制主服务器上的提交。这是为什么呢？嗯，有些工作流可能需要在master上提交git信息，Github不会通过它们的Pull Request Web UI来设置这些信息。Linus <a class="ae kv" href="https://github.com/torvalds/linux/pull/17#issuecomment-5654674" rel="noopener ugc nofollow" target="_blank">过去抱怨过这个问题</a>，这就是为什么他甚至不接受Linux内核中的Github Pull请求。</p><p id="ed87" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">第二个选项的问题是，您需要为每个Pull请求添加一个remote，以便在master上提交。许多拉请求可以有不同的贡献者和不同的分支。添加它们会变得很麻烦，因为你最终会在项目的本地副本中拥有大量的遥控器。</p><p id="3b9e" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><a class="ae kv" href="https://github.com/piscisaureus" rel="noopener ugc nofollow" target="_blank">Bert Belder</a>4年前发表了一个<a class="ae kv" href="https://gist.github.com/piscisaureus/3342247" rel="noopener ugc nofollow" target="_blank">有趣的技巧</a>，允许某人用一个<code class="eh lz ma mb mc b">git fetch</code>命令从本地的一个存储库中下载所有的拉请求。</p><p id="121c" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">诀窍是将下面一行添加到位于您想要更改的项目的根目录下的<code class="eh lz ma mb mc b">.git/config</code>文件中:</p><pre class="jk jl jm jn fq md mc me mf aw mg dt"><span id="5be6" class="mh mi hu mc b fv mj mk l ml mm">fetch = +refs/pull/*/head:refs/remotes/origin/pr/*</span></pre><p id="19f7" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">写着<code class="eh lz ma mb mc b">origin</code>的部分可以不同。它只是表示远程的名称，该远程具有对您想要从中获取拉请求的存储库的引用。当我们使用命令<code class="eh lz ma mb mc b">git clone &lt;path to the repository&gt;</code>时，它是git创建的遥控器的默认名称。</p><p id="c17f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">当使用这个技巧运行<code class="eh lz ma mb mc b">git fetch</code>命令时，git将获取所有针对该遥控器打开的Pull请求:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mn"><img src="../Images/e0e73b49d407672abe12d480c13f3d1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NuKXgiy2o91c11Q6MPuWmw.jpeg"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">The output of the "git fetch" command when the Pull Request fetching technique is applied. It's fetching the refs from a copy of the <a class="ae kv" href="http://github.com/js-cookie/js-cookie" rel="noopener ugc nofollow" target="_blank">js-cookie</a> project.</figcaption></figure><p id="fd10" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">注意<code class="eh lz ma mb mc b">[new ref] refs/pull/280/head -&gt; origin/pr/280</code>部分，这是从遥控器获取拉请求的时候。使用<code class="eh lz ma mb mc b">git checkout origin/pr/280</code>可以检查它们。</p><p id="f7bd" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">好了，现在可以使用相同的命令行技巧将更改推送到拉请求了吗？</p><p id="4885" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">根据<a class="ae kv" href="https://help.github.com/articles/checking-out-pull-requests-locally/" rel="noopener ugc nofollow" target="_blank"> Github文档</a>不能。Github不允许推送到隐藏的ref:</p><blockquote class="mo mp mq"><p id="cec6" class="jz ka mr kb b kc kd iv ke kf kg iy kh ms kj kk kl mt kn ko kp mu kr ks kt ku hn dt translated">远程<code class="eh lz ma mb mc b">refs/pull/</code>名称空间是<em class="hu">只读的</em></p><p id="5806" class="jz ka mr kb b kc kd iv ke kf kg iy kh ms kj kk kl mt kn ko kp mu kr ks kt ku hn dt translated">——Github的“<a class="ae kv" href="https://help.github.com/articles/checking-out-pull-requests-locally/" rel="noopener ugc nofollow" target="_blank">在本地检查拉取请求</a>”文档</p></blockquote><p id="574e" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">任何推至ref的尝试都会出现以下错误:</p><pre class="jk jl jm jn fq md mc me mf aw mg dt"><span id="595f" class="mh mi hu mc b fv mj mk l ml mm">! [remote rejected] HEAD -&gt; refs/pull/1/head (deny updating a hidden ref)</span></pre><p id="62e9" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">更新Pull请求的唯一方法是添加一个新的remote，该remote引用创建它的contributor的fork。如果您有权限在他们的分支中进行写操作，那么您可以将任何更改推送到远程的Pull Request分支，它将在Github Pull Request Web UI上自动更新。</p><blockquote class="kw"><p id="12eb" class="kx ky hu bd kz la lb lc ld le lf ku ek translated">使用多拉请求获取技巧来改变拉请求是不可能的，因为Github将隐藏的引用设为只读</p></blockquote><p id="41e8" class="pw-post-body-paragraph jz ka hu kb b kc lg iv ke kf lh iy kh ki li kk kl km lj ko kp kq lk ks kt ku hn dt translated">当处理拉请求时，这个拉请求获取技巧将使您的工作流更加方便。这是非常简单的事情之一，但仍然会根据您的工作流程带来很多好处。</p><p id="2b37" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我已经在使用第二个选项的项目中使用了很长时间。</p><p id="b947" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">你呢？</p></div><div class="ab cl mv mw hc mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="hn ho hp hq hr"><p id="bd8a" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">感谢阅读。如果您有任何反馈，请通过<a class="ae kv" href="https://twitter.com/FagnerBrack" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae kv" href="https://www.facebook.com/fagner.brack" rel="noopener ugc nofollow" target="_blank">脸书</a>或<a class="ae kv" href="http://github.com/FagnerMartinsBrack" rel="noopener ugc nofollow" target="_blank"> Github </a>联系我。</p></div></div>    
</body>
</html>