<html>
<head>
<title>Simulating user location and navigation route on iPhone without Xcode.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在没有Xcode的iPhone上模拟用户位置和导航路线。</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/simulating-user-location-and-navigation-route-on-iphone-without-xcode-761f06905f1c?source=collection_archive---------7-----------------------#2017-12-06">https://medium.com/hackernoon/simulating-user-location-and-navigation-route-on-iphone-without-xcode-761f06905f1c?source=collection_archive---------7-----------------------#2017-12-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="289f" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated"><strong class="ak">问题陈述:</strong></h1><p id="ce75" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">最近，作为围绕用户位置的某些个性化界面的概念验证的一部分，我们意识到展示该功能的最佳方式是模拟用户的旅程。在iPhone上。没有任何电缆连接到一个<a class="ae kn" href="https://hackernoon.com/tagged/xcode" rel="noopener ugc nofollow" target="_blank"> Xcode </a>实例。<em class="ko">因此，我们着手弄清楚</em> <strong class="jr hv"> <em class="ko">模拟</em> </strong> <em class="ko">用户位置和</em> <strong class="jr hv"> <em class="ko">用户从A点到B点的旅程需要什么，在实际设备上按需进行，而不使用Xcode来模拟位置</em> </strong> <em class="ko">。</em></p><h1 id="83e7" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">第一步:GPX档案</h1><p id="56df" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">合理的步骤是首先设置要模拟的路线。最简单的方法<a class="ae kn" href="https://mapstogpx.com/" rel="noopener ugc nofollow" target="_blank">是在谷歌地图上获取方向，然后在这里将其转换为. gpx文件</a>。如果您正在模拟导航路线，请确保您选择了跟踪点选项。</p><p id="cec1" class="pw-post-body-paragraph jp jq hu jr b js kp ju jv jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km hn dt translated">创建的gpx文件如下所示:</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="fe ff ku"><img src="../Images/8feb38d47a9aa8f8ae323383d9d78e5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oo5g6eo1ZHkjHmvr-1iYoA.png"/></div></div><figcaption class="lg lh fg fe ff li lj bd b be z ek">a sample gpx file showing trackpoints!</figcaption></figure><p id="ea83" class="pw-post-body-paragraph jp jq hu jr b js kp ju jv jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km hn dt translated">将这个gpx文件保存到您的XCode项目中，供以后使用。</p><h1 id="49c3" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">第二步:GPX解析器</h1><p id="e726" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">下一步是能够将这个gpx文件解析为CLLocation结构的集合，然后可以对其进行模拟。以下要点说明了如何做到这一点。</p><p id="7b3d" class="pw-post-body-paragraph jp jq hu jr b js kp ju jv jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km hn dt translated">负责调用GpxParser的类也符合GpxParsing协议，该协议允许它在解析完成后继续进行。这个解析的输出是一个队列<cllocation>。实现一个<a class="ae kn" href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type)" rel="noopener ugc nofollow" target="_blank">队列</a>应该很简单(或者说是一个很好的练习:)。</cllocation></p><figure class="kv kw kx ky fq kz"><div class="bz el l di"><div class="lk ll l"/></div><figcaption class="lg lh fg fe ff li lj bd b be z ek">a gpx parser implementation</figcaption></figure><h1 id="68e9" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">3.MockCLLocationManager</h1><p id="fcb6" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated"><em class="ko"> CLLocationManager </em>(来自<em class="ko"> CoreLocation </em>模块)是一个主类，它为一个<a class="ae kn" href="https://hackernoon.com/tagged/ios" rel="noopener ugc nofollow" target="_blank"> iOS </a>应用程序提供所有位置特定的功能。如果您正在编写一个位置感知应用程序，您将实现一个CLLocationManager。如果您使用MKMapView来显示地图，MKMapView将在内部依赖CLLocationManager来提供位置细节。因此，对于我们来说，使用解析的gpx文件位置创建一个MockCLLocationManager和模仿CLLocationManager并每隔一段时间服务它们是有意义的。</p><figure class="kv kw kx ky fq kz"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="0cf2" class="pw-post-body-paragraph jp jq hu jr b js kp ju jv jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km hn dt translated">MockCLLocationManager提供了一些sugar方法，比如使用gpx文件名的startMocks，或者停止它。</p><h1 id="6b55" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">4.好吧，那现在有什么计划？</h1><p id="a302" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">概括地说，我们现在有能力将路由表示为CLLocation结构的队列。我们也有能力模仿CLLocationManager和模仿位置的变化。我们现在需要做的就是将所有对CLLocationManager的请求重定向到这个MockCLLocationManager。</p><p id="134b" class="pw-post-body-paragraph jp jq hu jr b js kp ju jv jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km hn dt translated">听起来很简单。但是怎么做呢？</p><p id="a681" class="pw-post-body-paragraph jp jq hu jr b js kp ju jv jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km hn dt translated">一个字:<strong class="jr hv"> Swizzling </strong>！</p><p id="2b82" class="pw-post-body-paragraph jp jq hu jr b js kp ju jv jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km hn dt translated">NSHipster有一个<a class="ae kn" href="http://nshipster.com/method-swizzling/" rel="noopener ugc nofollow" target="_blank">优秀的博客</a>解释swizzling。简单地说，它是一种在运行时改变类(特别是它的方法)行为的方法。想法是，每当运行时试图访问CLLocationManager时，我们的方法(我们已经“swizzled ”)在MockCLLocationManager上执行相同的操作，并调用适当的委托，以便调用者获得所请求的位置。</p><p id="c6dc" class="pw-post-body-paragraph jp jq hu jr b js kp ju jv jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km hn dt translated">在DLAppDelegate中，通过调用CLLocationManager.classInit来完成重组(这是您将检查调试或生产版本的地方)。</p><p id="7e1e" class="pw-post-body-paragraph jp jq hu jr b js kp ju jv jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km hn dt translated">说够了。要点如下:</p><figure class="kv kw kx ky fq kz"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="b770" class="pw-post-body-paragraph jp jq hu jr b js kp ju jv jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km hn dt translated"><em class="ko">有人可能会争辩说，为什么Swizzle不只是使用MockCLLocationManager实例呢？</em>。这种方法有两个问题。它不会帮助在MKMapView上模拟位置更新，因为它使用CLLocationManager的内部实例(谢谢苹果！:| ).其次，我们只有一个位置来切换这种行为。老实说，你甚至不想意外地将这些代码发布到产品中！</p><h1 id="64b3" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">我猜你已经搞定了。</h1><p id="8682" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">词。</p><p id="da4c" class="pw-post-body-paragraph jp jq hu jr b js kp ju jv jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km hn dt translated">下面是视图控制器的要点。你会发现没有任何嘲笑的痕迹。</p><figure class="kv kw kx ky fq kz"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="6790" class="pw-post-body-paragraph jp jq hu jr b js kp ju jv jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km hn dt translated">下面是实际运行的代码！</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div class="fe ff lm"><img src="../Images/e37ea93d1b25e0aea6f6104bb3665033.png" data-original-src="https://miro.medium.com/v2/resize:fit:428/1*smKz8LhOGw3_0YNHcYKgkw.gif"/></div></figure><h2 id="91a3" class="ln is hu bd it lo lp lq ix lr ls lt jb ka lu lv jf ke lw lx jj ki ly lz jn ma dt translated">感谢您的阅读！如果你喜欢这篇文章，请分享/推荐。如果没有，请评论/批评，这样我可以改进和学习更多！:)</h2><figure class="kv kw kx ky fq kz"><div class="bz el l di"><div class="mb ll l"/></div></figure></div></div>    
</body>
</html>