<html>
<head>
<title>Creating a word count webhook for GitHub</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为GitHub创建字数统计webhook</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/i-created-a-word-count-webhook-for-github-45c69ba0e22?source=collection_archive---------13-----------------------#2017-05-25">https://medium.com/hackernoon/i-created-a-word-count-webhook-for-github-45c69ba0e22?source=collection_archive---------13-----------------------#2017-05-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/fcd22d7d618d1507bb6cb6e0b71bcbe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eZXd4IQTzEoVqQhjv9QcuA.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Using graphics from <a class="ae jg" href="https://experience.sap.com/designservices/approach/scenes" rel="noopener ugc nofollow" target="_blank">SAP Scenes Pack</a></figcaption></figure><p id="16cd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">虽然听起来像个人武器，但网钩不是个人武器。因此，如果你想学习如何对某人造成伤害，这不是你的博客文章。Webhooks实际上是“web回调”，允许开发人员构建应用程序来响应事件。在这篇博文中，我将介绍一个我最近为Github 创建的webhook，它计算git提交中单词变化的数量。</p><p id="9d0a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">该服务使用<a class="ae jg" href="https://serverless.com" rel="noopener ugc nofollow" target="_blank">无服务器框架</a>构建在Node.js上，并部署到<a class="ae jg" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>(亚马逊网络服务)。我不会在这篇博文中解释如何使用它们，相反，我将介绍字数是如何计算的，并给出架构的一个高层次概述。</p><p id="7342" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">要查看代码，请查看下面的Github库。</p><div class="kf kg fm fo kh ki"><a href="https://github.com/danielireson/github-wc-webhook" rel="noopener  ugc nofollow" target="_blank"><div class="kj ab ej"><div class="kk ab kl cl cj km"><h2 class="bd hv fv z el kn eo ep ko er et ht dt translated">danielireson/github-wc-webhook</h2><div class="kp l"><h3 class="bd b fv z el kn eo ep ko er et ek translated">github字数统计webhook for AWS Lambda</h3></div><div class="kq l"><p class="bd b gc z el kn eo ep ko er et ek translated">github.com</p></div></div><div class="kr l"><div class="ks l kt ku kv kr kw ja ki"/></div></div></a></div><h1 id="38f9" class="kx ky hu bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">要求</h1><p id="e0a9" class="pw-post-body-paragraph jh ji hu jj b jk lv jm jn jo lw jq jr js lx ju jv jw ly jy jz ka lz kc kd ke hn dt translated">GitHub有26个不同的事件，你可以订阅。在订阅事件时，您要求GitHub在每次事件发生时向特定的处理程序发送一个POST请求，该请求带有一个包含事件细节的JSON有效负载。这个处理程序只是一个web服务，可以在互联网上公开获得。选择何种技术来创建处理程序并不重要，只要它能够接收HTTP请求并进行处理。唯一的要求是处理程序必须具有高可用性(它不应该离线)。如果服务脱机，事件通常会丢失。这使得AWS成为托管webhook处理程序的绝佳平台选择。使用AWS Lambda，您可以创建和部署服务，而不必担心服务器的设置、维护或扩展。AWS会为您处理这个问题，并且只在每次调用服务时向您收费。这与典型的服务器设置形成对比，在典型的服务器设置中，无论服务器是否被使用，您都需要支付一笔经常性费用。查看以下3分钟的宣传视频，快速介绍AWS Lambda服务。</p><figure class="ma mb mc md fq iv"><div class="bz el l di"><div class="me mf l"/></div></figure><h1 id="e6f5" class="kx ky hu bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">架构概述</h1><p id="cbee" class="pw-post-body-paragraph jh ji hu jj b jk lv jm jn jo lw jq jr js lx ju jv jw ly jy jz ka lz kc kd ke hn dt translated">字数统计服务有两个端点，一个<em class="mg">/提交</em>端点和一个<em class="mg"> /webhook </em>端点。webhook端点负责处理Github push事件，对单词变化进行计数，并将计数保存到数据库中。提交端点允许用户从数据库返回计数。Amazon API Gateway用于创建端点和触发Lambda函数。DynamoDB用于计数数据库。</p><figure class="ma mb mc md fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mh"><img src="../Images/1876752778f2f485d5e10c0c86406ca9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DqOOM092UKdOC3czi90b1g.png"/></div></div></figure><h1 id="a7c1" class="kx ky hu bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">计算单词变化</h1><p id="2e82" class="pw-post-body-paragraph jh ji hu jj b jk lv jm jn jo lw jq jr js lx ju jv jw ly jy jz ka lz kc kd ke hn dt translated"><em class="mg"> /webhook </em>端点订阅了Github推送事件。该事件包含该推送中每个提交的元信息。包含在推送事件中的提交信息的示例如下所示。</p><pre class="ma mb mc md fq mi mj mk ml aw mm dt"><span id="58c8" class="mn ky hu mj b fv mo mp l mq mr">{<br/>  "commits": [<br/>    {<br/>      "id": "0d1a26e67d8f5eaf1f6ba5c57fc3c7d91ac0fd1c",<br/>      "tree_id": "f9d2a07e9488b91af2641b26b9407fe22a451433",<br/>      "distinct": <strong class="mj hv">true</strong>,<br/>      "message": "Update README.md",<br/>      "timestamp": "2015-05-05T19:40:15-04:00",<br/>      "url": "https://github.com/baxterthehacker/public-repo/commit/0d1a26e67d8f5eaf1f6ba5c57fc3c7d91ac0fd1c",<br/>      "author": {<br/>        "name": "baxterthehacker",<br/>        "email": "baxterthehacker@users.noreply.github.com",<br/>        "username": "baxterthehacker"<br/>      },<br/>      "committer": {<br/>        "name": "baxterthehacker",<br/>        "email": "baxterthehacker@users.noreply.github.com",<br/>        "username": "baxterthehacker"<br/>      },<br/>      "added": [<br/><br/>      ],<br/>      "removed": [<br/><br/>      ],<br/>      "modified": [<br/>        "README.md"<br/>      ]<br/>    }<br/>  ]<br/>}</span></pre><p id="58cb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">只能看到添加、删除或更改的文件的文件名，而不能看到对这些文件所做的具体更改。为了获得更改，我们需要每个文件的git补丁，这可以通过对Github API上的<code class="eh ms mt mu mj b"><a class="ae jg" href="https://api.github.com/repos/${path}/commits/${sha" rel="noopener ugc nofollow" target="_blank">/repos/${path}/commits/${sha</a>}</code>的get请求来获得，其中<code class="eh ms mt mu mj b">${path}</code>是存储库路径(对于个人存储库，它由用户名和存储库名称组成，用正斜杠分隔)和<code class="eh ms mt mu mj b">${sha}</code>作为要查找的提交ID。</p><p id="abbe" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在Github上查看最近提交的<a class="ae jg" href="https://github.com/danielireson/formplug-serverless/commit/458a6d182f4b3a68e7be6db4193227f3de301c3f" rel="noopener ugc nofollow" target="_blank">,我在自述文件中修正了一个拼写错误。这个API请求的URL如下所示。打开一个新的选项卡，在浏览器中加载它，您应该会得到一个JSON响应。</a></p><pre class="ma mb mc md fq mi mj mk ml aw mm dt"><span id="9784" class="mn ky hu mj b fv mo mp l mq mr">https://api.github.com/repos/danielireson/formplug-serverless/commits/458a6d182f4b3a68e7be6db4193227f3de301c3f</span></pre><p id="ed5d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">可以分析git文件补丁来计算单词变化。上面的提交具有以下针对自述文件的git补丁。</p><pre class="ma mb mc md fq mi mj mk ml aw mm dt"><span id="2c99" class="mn ky hu mj b fv mo mp l mq mr">@@ -30,7 +30,7 @@ <a class="ae jg" href="https://apigatewayurl.com/to/1974d0cc894607de62f0581ec1334997\n" rel="noopener ugc nofollow" target="_blank">https://apigatewayurl.com/to/1974d0cc894607de62f0581ec1334997\n</a> ```\n \n ### AJAX\n-Append *_format=json* to the query string of the Formplug URL to get responses back in JSON with a CORS allow all origin header. This makes it easy to interact with Formplug using Javscript.\n+Append *_format=json* to the query string of the Formplug URL to get responses back in JSON with a CORS allow all origin header. This makes it easy to interact with Formplug using Javascript.\n ``` html\n <a class="ae jg" href="https://apigatewayurl.com/to/johndoe@example.com?_format=json\n" rel="noopener ugc nofollow" target="_blank">https://apigatewayurl.com/to/johndoe@example.com?_format=json\n</a> ```</span></pre><p id="02f4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">沿着<code class="eh ms mt mu mj b">\n</code>将它分成一个数组，显示文件的每一行。</p><pre class="ma mb mc md fq mi mj mk ml aw mm dt"><span id="0920" class="mn ky hu mj b fv mo mp l mq mr">[ <br/>  '@@ -30,7 +30,7 @@ <a class="ae jg" href="https://apigatewayurl.com/to/1974d0cc894607de62f0581ec1334997'" rel="noopener ugc nofollow" target="_blank">https://apigatewayurl.com/to/1974d0cc894607de62f0581ec1334997'</a>,<br/>  ' ```',<br/>  ' ',<br/>  ' ### AJAX',<br/>  '-Append *_format=json* to the query string of the Formplug URL to get responses back in JSON with a CORS allow all origin header. This makes it easy to interact with Formplug using Javscript.',<br/>  '+Append *_format=json* to the query string of the Formplug URL to get responses back in JSON with a CORS allow all origin header. This makes it easy to interact with Formplug using Javascript.',<br/>  ' ``` html',<br/>  ' <a class="ae jg" href="https://apigatewayurl.com/to/johndoe@example.com?_format=json'" rel="noopener ugc nofollow" target="_blank">https://apigatewayurl.com/to/johndoe@example.com?_format=json'</a>,<br/>  ' ```' <br/>]</span></pre><p id="4a17" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">删除了以<code class="eh ms mt mu mj b">-</code>开头的行，添加了以<code class="eh ms mt mu mj b">+</code>开头的行。在上面的例子中，你可以看到第五个数组项被删除，第六个数组项被添加。我们可以使用正则表达式从字符串中提取单词。</p><pre class="ma mb mc md fq mi mj mk ml aw mm dt"><span id="4e4e" class="mn ky hu mj b fv mo mp l mq mr">function getWordsInString (str) {<br/>  let regex = /[a-zA-Z0-9_\u0392-\u03c9\u0400-\u04FF]+|[\u4E00-\u9FFF\u3400-\u4dbf\uf900-\ufaff\u3040-\u309f\uac00-\ud7af\u0400-\u04FF]+|[\u00E4\u00C4\u00E5\u00C5\u00F6\u00D6]+|\w+/g<br/>  return str.match(regex) || []<br/>}</span></pre><p id="377a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">上面的函数返回行中单词的数组。从这个数组中，我们可以计算每个单词在每行中出现的次数。</p><pre class="ma mb mc md fq mi mj mk ml aw mm dt"><span id="8705" class="mn ky hu mj b fv mo mp l mq mr">function getWordCount (arr) {<br/>  return arr.reduce(function (obj, word) {<br/>    if (word in obj) {<br/>      obj[word]++<br/>    } else {<br/>      obj[word] = 1<br/>    }<br/>    return obj<br/>  }, {})<br/>}</span></pre><p id="93ae" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">从这个单词计数对象中，我们可以估计哪些单词被删除，哪些被添加。请注意，这只是一个估计，因为单词计数器只查看出现次数，而不一定是单词使用的位置。如果你在句首删去一个the，而在中间加上一个the，它们就会相互抵消。</p><p id="a05a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">继续上面的补丁示例，可以比较被删除行和被添加行的单词出现。</p><pre class="ma mb mc md fq mi mj mk ml aw mm dt"><span id="60e6" class="mn ky hu mj b fv mo mp l mq mr">// Deleted<br/>{  Append: 1, _format: 1, json: 1, to: 3, the: 2, query: 1, string: 1, of: 1, Formplug: 2, URL: 1, get: 1, responses: 1, back: 1, in: 1, JSON: 1, with: 2, a: 1, CORS: 1, allow: 1, all: 1, origin: 1, header: 1, This: 1, makes: 1, it: 1, easy: 1, interact: 1, using: 1, Javscript: 1 }</span><span id="7d11" class="mn ky hu mj b fv mv mp l mq mr">// Added<br/>{ Append: 1, _format: 1, json: 1, to: 3, the: 2, query: 1, string: 1, of: 1, Formplug: 2, URL: 1, get: 1, responses: 1, back: 1, in: 1, JSON: 1, with: 2, a: 1, CORS: 1, allow: 1, all: 1, origin: 1, header: 1, This: 1, makes: 1, it: 1, easy: 1, interact: 1, using: 1, Javascript: 1 }</span></pre><p id="d57a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">实际上只做了一处更改，通过查看两个对象的最后一个属性可以看出这一点——注意“Javascript”是如何变为“Javascript”的。这应该表示为一个单词计数删除和一个添加。我们可以通过将这两个对象传递给一个比较它们的函数，以编程方式计算单词的变化。</p><pre class="ma mb mc md fq mi mj mk ml aw mm dt"><span id="f120" class="mn ky hu mj b fv mo mp l mq mr">function countChange (wordCountObjOne, wordCountObjTwo) {<br/>  let count = 0<br/>  for (let word in wordCountObjTwo) {<br/>    if (word in wordCountObjOne) {<br/>      let change = wordCountObjTwo[word] - wordCountObjOne[word]<br/>      count += change &gt; 0 ? change : 0<br/>    } else {<br/>      count += wordCountObjTwo[word]<br/>    }<br/>  }<br/>  return count<br/>}</span></pre><p id="83fc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个函数应该被调用两次，以获得添加和删除单词的总数。</p><pre class="ma mb mc md fq mi mj mk ml aw mm dt"><span id="0494" class="mn ky hu mj b fv mo mp l mq mr">function getWordChanges (deletedWords, addedWords) {<br/>  let deletedWordCount = getWordCount(deletedWords)<br/>  let addedWordCount = getWordCount(addedWords)<br/>  return {<br/>    deleted: countChange(addedWordCount, deletedWordCount),<br/>    added: countChange(deletedWordCount, addedWordCount)<br/>  }<br/>}</span></pre><p id="a146" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这给出了git补丁中每个删除(-)和添加(+)对被删除和添加的单词数。一个git补丁可以包含多个删除/添加，一个commit可以包含多个文件补丁。使用上面提到的函数，我们感兴趣的是将这些计数减少到每次git提交的一个总计数。</p><pre class="ma mb mc md fq mi mj mk ml aw mm dt"><span id="fc3b" class="mn ky hu mj b fv mo mp l mq mr">function countWordChangesInCommit (files) {<br/>  return files.reduce(function (wordCount, file) {<br/>    if ('patch' in file) {<br/>      let fileChangeCount = countWordChangesInFilePatch(file.patch)<br/>      wordCount.deleted += fileChangeCount.deleted<br/>      wordCount.added += fileChangeCount.added<br/>      wordCount.net += fileChangeCount.added - fileChangeCount.deleted<br/>    }<br/>    return wordCount<br/>  }, {deleted: 0, added: 0, net: 0})<br/>}</span><span id="d417" class="mn ky hu mj b fv mv mp l mq mr">function countWordChangesInFilePatch (patch) {<br/>  let deletedWords = []<br/>  let addedWords = []<br/>  return patch.split('\n').reduce(function (wordCount, line) {<br/>    switch (line.charAt(0)) {<br/>      case '-':<br/>        deletedWords = deletedWords.concat(getWordsInString(line))<br/>        break<br/>      case '+':<br/>        addedWords = addedWords.concat(getWordsInString(line))<br/>        let countResult = getWordChanges(deletedWords, addedWords)<br/>        wordCount.deleted += countResult.deleted<br/>        wordCount.added += countResult.added<br/>        wordCount.net += countResult.added - countResult.deleted<br/>        break<br/>    }<br/>    if (line.charAt(0) !== '-') {<br/>      deletedWords = []<br/>      addedWords = []<br/>    }<br/>    return wordCount<br/>  }, {deleted: 0, added: 0, net: 0})<br/>}</span></pre><h1 id="24cc" class="kx ky hu bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">webhook端点</h1><p id="908c" class="pw-post-body-paragraph jh ji hu jj b jk lv jm jn jo lw jq jr js lx ju jv jw ly jy jz ka lz kc kd ke hn dt translated">我们现在知道了如何计算提交中的字变化，那么这如何适应更大的架构呢？当点击API网关上的<em class="mg"> /webhook </em>端点时，将触发一个处理程序，该处理程序采用以下形式。</p><pre class="ma mb mc md fq mi mj mk ml aw mm dt"><span id="e99a" class="mn ky hu mj b fv mo mp l mq mr">module.exports.handle = (event, context, callback) =&gt; {<br/>  authenticate(event)<br/>    .then(function () {<br/>      // get the commits in the push event<br/>      // call Github API for each commit<br/>    })<br/>    .then(function (responses) {<br/>      // count word changes for each commit<br/>    })<br/>    .then(function (payloads) {<br/>      // save payload for each commit to database<br/>    })<br/>    .then(function () {<br/>      // send http success response<br/>    })<br/>    .catch(function (error) {<br/>      // send http error response<br/>    })<br/>}</span></pre><p id="b284" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了简单起见，promise‘then’函数已经被注释所取代，并且有助于解释(查看Github 上的<a class="ae jg" href="https://github.com/danielireson/github-wc-webhook" rel="noopener ugc nofollow" target="_blank">库以获得完整代码)。它首先通过检查是否发送了正确的HTTP auth头来验证请求(您可以设置Github webhooks使用API键)。然后，它为每个提交调用Github API来获取该提交的文件补丁。使用git补丁计算字数。并且根据字计数，创建具有数据库的正确格式的计数信息的有效载荷。如果这一切都成功发生，处理程序应该返回一个HTTP 200成功响应，如果没有，它应该抛出一个错误和适当的HTTP代码。</a></p><figure class="ma mb mc md fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mw"><img src="../Images/9917a878fd89985818d20a68ca06bf77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aKiaDJu4RXKZWK9wp-GvoQ.png"/></div></div></figure><h1 id="101d" class="kx ky hu bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">提交端点</h1><p id="db29" class="pw-post-body-paragraph jh ji hu jj b jk lv jm jn jo lw jq jr js lx ju jv jw ly jy jz ka lz kc kd ke hn dt translated">为了从数据库中获取计数结果，用户应该向<em class="mg">/提交</em> API网关端点发出get请求。提交处理程序比webhook处理程序简单。在对用户进行身份验证之后，它会解析URL以检查自定义搜索选项(比如对返回结果数量的限制)，使用AWS SDK npm库进行数据库查询，并返回结果。</p><pre class="ma mb mc md fq mi mj mk ml aw mm dt"><span id="6d96" class="mn ky hu mj b fv mo mp l mq mr">module.exports.handle = (event, context, callback) =&gt; {<br/>  authenticate(event)<br/>    .then(function () {<br/>      // check for url parameters<br/>      // search database<br/>    })<br/>    .then(function (res) {<br/>      // send results as http response<br/>    })<br/>    .catch(function (error) {<br/>      // send http error response<br/>    })<br/>}</span></pre><h1 id="62f3" class="kx ky hu bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">总结</h1><p id="0056" class="pw-post-body-paragraph jh ji hu jj b jk lv jm jn jo lw jq jr js lx ju jv jw ly jy jz ka lz kc kd ke hn dt translated">Webhooks是扩展您已经使用的第三方服务功能的一种简单而有效的方式——它们也是一个很好的AWS Lambda用例。有关完整的项目代码，请参见下面链接的Github资源库。</p><div class="kf kg fm fo kh ki"><a href="https://github.com/danielireson/github-wc-webhook" rel="noopener  ugc nofollow" target="_blank"><div class="kj ab ej"><div class="kk ab kl cl cj km"><h2 class="bd hv fv z el kn eo ep ko er et ht dt translated">danielireson/github-wc-webhook</h2><div class="kp l"><h3 class="bd b fv z el kn eo ep ko er et ek translated">github字数统计webhook for AWS Lambda</h3></div><div class="kq l"><p class="bd b gc z el kn eo ep ko er et ek translated">github.com</p></div></div><div class="kr l"><div class="mx l kt ku kv kr kw ja ki"/></div></div></a></div><div class="ma mb mc md fq ab cb"><figure class="my iv mz na nb nc nd paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="my iv mz na nb nc nd paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="my iv mz na nb nc nd paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ne nf ng"><p id="f922" class="jh ji mg jj b jk jl jm jn jo jp jq jr nh jt ju jv ni jx jy jz nj kb kc kd ke hn dt translated"><a class="ae jg" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jg" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jg" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jg" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jh ji mg jj b jk jl jm jn jo jp jq jr nh jt ju jv ni jx jy jz nj kb kc kd ke hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jg" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jg" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ma mb mc md fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nk"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="ma mb mc md fq iv"><div class="bz el l di"><div class="nl mf l"/></div></figure></div></div>    
</body>
</html>