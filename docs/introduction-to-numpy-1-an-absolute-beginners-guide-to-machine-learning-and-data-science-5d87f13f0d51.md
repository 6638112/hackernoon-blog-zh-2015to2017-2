# Numpy -1 介绍:机器学习和数据科学的绝对初学者指南。

> 原文：<https://medium.com/hackernoon/introduction-to-numpy-1-an-absolute-beginners-guide-to-machine-learning-and-data-science-5d87f13f0d51>

![](img/cd75f74afc29d03f4d3b268b401a7e91.png)

让我们快点开始吧。Numpy 是 python 的数学库。它使我们能够高效和有效地进行计算。它比普通的 python 更好，因为它有惊人的能力。

在本文中，我将向您介绍机器学习和数据科学最需要的基础知识。我不打算介绍 numpy 库的所有功能。这是 numpy 教程系列的第一部分。

首先我要介绍给你的是你导入的方式。

```
import numpy as np
```

好的，现在我们告诉 python“NP”是 numpy 的官方名称。

让我们创建 python 数组和 np 数组。

```
# python array
a = [1,2,3,4,5,6,7,8,9]# numpy array
A = np.array([1,2,3,4,5,6,7,8,9])
```

如果我把它们印出来，我看不出有什么不同。

```
print(a)
print(A)
====================================================================[1, 2, 3, 4, 5, 6, 7, 8, 9]
[1 2 3 4 5 6 7 8 9]
```

好的，但是为什么我必须使用 np 数组而不是常规数组呢？

答案是 np 阵列更好，因为计算更快，操作更容易。

如果您感兴趣，请点击此处了解更多详情:

[](https://stackoverflow.com/a/994010) [## 为什么是 NumPy 而不是 Python 列表？

### 值得我学习 NumPy 吗？我有大约 100 个金融市场系列，我将创建一个立方体数组…

stackoverflow.com](https://stackoverflow.com/a/994010) 

让我们继续更酷的东西。等等，我们还没看到什么酷的东西呢！好吧，有件事:

# np.arange()

```
np.arange(0,10,2)
====================================================================array([0, 2, 4, 6, 8])
```

arange([start]，stop，[step])所做的是从开始到停止，以 step 的步长排列数字。下面是它对 np.arange(0，10，2)的意义:

返回一个 np 列表，从 0 一直到 10，但不要包括 10，并且每次增加 2。

所以，这就是我们得到的:

```
array([0, 2, 4, 6, 8])
```

这里要记住的重要一点是，停车号码不会包含在列表中。

另一个例子:

```
np.arange(2,29,5)
====================================================================
array([ 2,  7, 12, 17, 22, 27])
```

在我继续之前，我必须警告你，这个“数组”可以互换地称为“矩阵”或“向量”。所以当我举例说“矩阵的形状是 2 X 3”时，不要惊慌失措。它的意思是数组看起来像这样:

```
array([ 2,  7, 12,], 
      [17, 22, 27])
```

现在，让我们来讨论一下默认 np 数组的形状。

形状是 np 数组的一个属性。当使用 shape 调用一个默认数组(比如 A)时，它看起来是这样的。

```
A = [1, 2, 3, 4, 5, 6, 7, 8, 9] 
A.shape
====================================================================
(9,)
```

这是一个秩为 1 的矩阵(数组)，其中一行只有 9 个元素。理想情况下，它应该是一个 1 X 9 的矩阵，对吗？

我同意你的观点，所以这就是 shape()发挥作用的地方。这是一种将原始矩阵的维度转换成你想要的维度的方法。

让我们来看看重塑行动。只要重塑的矩阵和原始矩阵具有相同数量的元素，就可以传递任意维度的元组。

```
A = [1, 2, 3, 4, 5, 6, 7, 8, 9]
A.reshape(1,9)
====================================================================
array([[1, 2, 3, 4, 5, 6, 7, 8, 9]])
```

请注意，整形返回一个多维矩阵。开头的两个方括号表示。[[1，2，3，4，5，6，7，8，9]]是一个潜在的多维矩阵，与[1，2，3，4，5，6，7，8，9]相反。

另一个例子:

```
B = [1, 2, 3, 4, 5, 6, 7, 8, 9] 
B.reshape(3,3)
====================================================================
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
```

如果我看 B 的形状，它会是(3，3):

```
B.shape
====================================================================
(3,3)
```

# 完美。让我们继续讨论 np.zeros()。

这一次，你的任务是告诉我查看这段代码会发生什么:

```
np.zeros((4,3))
====================================================================
???????????
```

很好，如果你认为它会打印一个填充有零的 4 X 3 矩阵。以下是输出结果:

```
np.zeros((4,3))
====================================================================
array([[ 0.,  0.,  0.],
       [ 0.,  0.,  0.],
       [ 0.,  0.,  0.],
       [ 0.,  0.,  0.]])
```

np.zeros((n，m))返回一个包含零的 **n x m** 矩阵。就这么简单。

# 这里再猜一次:np.eye()是做什么的？

提示:眼睛()代表身份。

```
np.eye(5)
====================================================================
array([[ 1.,  0.,  0.,  0.,  0.],
       [ 0.,  1.,  0.,  0.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  0.,  0.,  1.,  0.],
       [ 0.,  0.,  0.,  0.,  1.]])
```

np.eye()返回指定维数的单位矩阵。

# 如果我们必须将两个矩阵相乘呢？

没问题，我们有 np.dot()。

np.dot()执行矩阵乘法，前提是两个矩阵都是“可乘的”。这只是意味着第一个矩阵的列数必须与第二个矩阵的行数相匹配。

例:A = (2，3) & B=(3，2)。这里 A 中的列数= 3。B 中的行数= 3。因为它们匹配，所以乘法是可能的。

让我们通过 np 代码来说明乘法:

```
# generate an identity matrix of (3 x 3)
I = np.eye(3)
I
====================================================================
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])# generate another (3 x 3) matrix to be multiplied.
D = np.arange(1,10).reshape(3,3)
D
====================================================================
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
```

我们现在准备两个矩阵相乘。让我们看看他们的行动。

```
# perform actual dot product.
M = np.dot(D,I)
M
====================================================================
array([[ 1.,  2.,  3.],
       [ 4.,  5.,  6.],
       [ 7.,  8.,  9.]])
```

太好了！现在你知道矩阵相乘是多么容易和可能！另外，请注意，整个数组现在都是浮点型的。

# 增加矩阵的元素怎么样？

```
# add all the elements of matrix.
sum_val = np.sum(M)
sum_val
====================================================================
45.0
```

np.sum()将矩阵的所有元素相加。

然而有 2 个变种。

## 1.沿着行求和。

```
# sum along the rows
np.sum(M,axis=1)
====================================================================
array([  6.,  15.,  24.])
```

6 是第一行(1，2，3)的总和。

15 是第二行(4，5，6)的总和。

24 是第三行(7，8，9)的和。

## 2.沿列求和。

```
# sum along the cols
np.sum(M,axis=0)
====================================================================
array([ 12.,  15.,  18.])
```

12 是第一栏(1，4，7)的总和。

15 是第二列(2，5，8)的和。

18 是第三栏(3，6，9)的总和。

[这是后续教程——第二部分](/@rakshithvasudev/introduction-to-numpy-2-an-absolute-beginners-guide-to-machine-learning-and-data-science-967b21e3542a)。就这样了。

这里有一个视频教程，解释了我所做的一切，如果你有兴趣通过视频消费。

如果你有兴趣学习熊猫，我在这里写了一篇教程文章。它叫做[熊猫简介:-1:机器学习和数据科学的绝对初学者指南](/@rakshithvasudev/intro-to-pandas-1-an-absolute-beginners-guide-to-machine-learning-and-data-science-a1fed3a6f0f3)

# 如果你喜欢这篇文章，请鼓掌/推荐。它帮助我写更多这样的文章。