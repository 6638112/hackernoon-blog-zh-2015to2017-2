<html>
<head>
<title>Let’s Compose Promises!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们写下承诺！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/lets-compose-promises-309a63225f8a?source=collection_archive---------10-----------------------#2017-11-13">https://medium.com/hackernoon/lets-compose-promises-309a63225f8a?source=collection_archive---------10-----------------------#2017-11-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="2960" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">今天我们将结合JavaScript开发人员工具箱中最有用的两个工具。<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">承诺</a>和<a class="ae jp" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-is-function-composition-20dfb109a1a0">功能组成</a>。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff jq"><img src="../Images/314dbf0224478626aa9b5ecb6553cb13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*IhaDj8f_Orwoh4HVb6xZKQ.jpeg"/></div><figcaption class="jy jz fg fe ff ka kb bd b be z ek">Please enjoy this barely related comic about Functional Programming :)</figcaption></figure><h2 id="167c" class="kc kd hu bd ke kf kg kh ki kj kk kl km jc kn ko kp jg kq kr ks jk kt ku kv kw dt translated">承诺</h2><p id="229f" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated"><a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank"> Promise API </a>是一种简单但强大的处理异步操作的方式。要创建一个承诺，你可以输入<code class="eh lc ld le lf b">new Promise()</code>，唯一的参数是一个回调函数。</p><p id="cfa9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">回调函数接受两个参数:<code class="eh lc ld le lf b">resolve</code>和<code class="eh lc ld le lf b">reject</code>。当异步函数完成时，调用resolve并给出结果。如果你的异步函数抛出一个错误，你可以用这个错误调用<code class="eh lc ld le lf b">reject</code>。看起来是这样的:</p><pre class="jr js jt ju fq lg lf lh li aw lj dt"><span id="bd9a" class="kc kd hu lf b fv lk ll l lm ln">const myPromise = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; {<br/>    resolve('Hello World');<br/>  }, 2000);<br/>});</span><span id="4d55" class="kc kd hu lf b fv lo ll l lm ln">myPromise.then(res =&gt; console.log(res)); // 'Hello World' is shown after 2 seconds.</span></pre><p id="5253" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们能够通过调用<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" rel="noopener ugc nofollow" target="_blank"> Promise.prototype.then </a>来访问<code class="eh lc ld le lf b">resolve</code>的结果，该函数接收一个回调函数，该函数将您调用的<code class="eh lc ld le lf b">resolve</code>作为其参数。</p><p id="e9b7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有时候一个承诺会抛出一个错误。在这个场景中，我们不能使用传统的<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch" rel="noopener ugc nofollow" target="_blank"> try/catch </a>块，因为错误可能会在稍后被抛出。相反我们使用<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch" rel="noopener ugc nofollow" target="_blank">promise . prototype . catch</a>。就像<code class="eh lc ld le lf b">.then()</code>它接收一个回调函数。不同之处在于，它将接收您传递给<code class="eh lc ld le lf b">reject</code>参数的任何内容。</p><p id="03e6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我们可能要做一些清理工作。我们用什么？你猜对了:<a class="ae jp" href="https://developers.google.com/web/updates/2017/10/promise-finally" rel="noopener ugc nofollow" target="_blank">promise . prototype . finally</a>。最终接受一个回调函数，但是这个回调函数不接受任何参数。您可以指望这个函数在您的承诺链执行完毕后被调用。在撰写本文时,<code class="eh lc ld le lf b">finally</code>并不是到处都有。你可以在最新版本的Chrome或者<a class="ae jp" href="http://bluebirdjs.com/docs/api/finally.html" rel="noopener ugc nofollow" target="_blank">蓝鸟</a>中使用。</p><h2 id="e40f" class="kc kd hu bd ke kf kg kh ki kj kk kl km jc kn ko kp jg kq kr ks jk kt ku kv kw dt translated">连锁承诺</h2><p id="59d0" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">当处理承诺时，你可以把它们锁住。这意味着当一行中有多个异步选项时，可以一个接一个地执行。它看起来像这样:</p><pre class="jr js jt ju fq lg lf lh li aw lj dt"><span id="9665" class="kc kd hu lf b fv lk ll l lm ln">// In this example Promise.resolve represents any async action that returns a promise.<br/>new Promise(resolve =&gt; setTimeout(() =&gt; resolve(10), 3000))<br/>  .then(res =&gt; Promise.resolve(res + 10))<br/>  .then(res =&gt; Promise.resolve(res + 10))<br/>  .then(console.log)<br/>  .catch(console.error)  <br/>  .finally(() =&gt; console.log('All done!');<br/>// After 3 seconds logs 30 <br/>// Then it logs 'All done!'</span></pre><p id="5384" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如您所看到的，承诺可以被链接起来，这样异步操作就可以像同步操作一样发生。</p><p id="60f2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们使用<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve" rel="noopener ugc nofollow" target="_blank"> Promise.resolve </a>来表示一个返回承诺的函数。<code class="eh lc ld le lf b">Promise.resolve</code>在承诺中包装一个值。</p><p id="a933" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一种不错的承诺方式，但我认为我们可以做得更好。</p><h2 id="7d4b" class="kc kd hu bd ke kf kg kh ki kj kk kl km jc kn ko kp jg kq kr ks jk kt ku kv kw dt translated">作文</h2><p id="d420" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">函数组合很简单，但是一开始可能很难理解。组合的全部意义在于允许你将函数串在一起。如果我们看一下上一个例子，但是使用同步函数，它看起来会像这样:</p><pre class="jr js jt ju fq lg lf lh li aw lj dt"><span id="9625" class="kc kd hu lf b fv lk ll l lm ln">const result = compose(<br/>  res =&gt; res + 10,<br/>  res =&gt; res + 10,<br/>)(10);<br/>console.log(result); // 10</span></pre><p id="7c0b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们取每个函数的结果，传递给下一个函数，这就是整个组合函数的结果。</p><p id="1908" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那个<code class="eh lc ld le lf b">compose</code>函数不像<code class="eh lc ld le lf b">Promise</code>或<code class="eh lc ld le lf b">Promise.resolve</code>那样被假定为全局函数。我们必须给它下定义。要定义compose，我们需要这样的东西:</p><pre class="jr js jt ju fq lg lf lh li aw lj dt"><span id="26de" class="kc kd hu lf b fv lk ll l lm ln">const compose = (...functions) =&gt; <br/>  initialValue =&gt;<br/>    functions.reduceRight(<br/>      (sum, fn) =&gt; fn(sum),<br/>      initialValue,<br/>    );</span></pre><p id="2e6f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此..这到底是怎么回事？让我一步一步地走你想过的路。这可能会令人困惑，尤其是如果你不熟悉JavaScript的最新更新版本<a class="ae jp" href="http://es6-features.org" rel="noopener ugc nofollow" target="_blank"> ES6 </a>。</p><p id="28fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，我们接受任意数量的函数。然后我们使用<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator" rel="noopener ugc nofollow" target="_blank">扩展操作符</a>将所有这些函数聚集到一个数组中。</p><p id="2cb8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，我们接受我们的compose函数将使用的初始值作为它的初始参数。</p><p id="7fc1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦我们有了初始值，我们开始从右到左(或者从下到上，如果你看上面的例子)调用每个函数。我们使用<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight" rel="noopener ugc nofollow" target="_blank">array . prototype . reduce right</a>来确保这些函数按照这个顺序被调用。如果你熟悉<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" rel="noopener ugc nofollow" target="_blank"> Array.prototype.reduce </a>的工作方式，那么你已经熟悉reduceRight，只是你可能不知道而已！<code class="eh lc ld le lf b">reduceRight</code>是reduce，但它反向工作。</p><p id="0691" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Array reduce和reduceRight方法遍历一个数组，在数组中的每个索引处调用一个回调。该回调接收两个参数。求和，以及数组当前索引处的值。</p><p id="bbeb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们的例子中，当前索引的值是一个函数。总和是数组中第一个函数的<code class="eh lc ld le lf b">initialValue</code>。在那之后，求和是前一个函数的结果，这个函数是用它之前的函数的结果调用的。</p><p id="925c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以现在我们希望看到承诺的力量，写作的方便和清晰。当我们把它们放在一起时会发生什么？</p><h2 id="5e9d" class="kc kd hu bd ke kf kg kh ki kj kk kl km jc kn ko kp jg kq kr ks jk kt ku kv kw dt translated">许下承诺</h2><p id="36f8" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">你可能想知道为什么我们不能用我们刚刚创建的<code class="eh lc ld le lf b">compose</code>函数来撰写承诺。问题是我们通过<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" rel="noopener ugc nofollow" target="_blank"> Promise.then </a>访问那个值。所以除非我们的每个函数都解开了它的参数，比如:</p><pre class="jr js jt ju fq lg lf lh li aw lj dt"><span id="94c5" class="kc kd hu lf b fv lk ll l lm ln">function myComposedFunction(argument) {<br/>  argument.then(() =&gt; {<br/>    // actual content of myComposedFunction goes here<br/>  });<br/>}</span></pre><p id="8c03" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么函数的参数就不会是它所期望的。另外还有一个问题。现在<code class="eh lc ld le lf b">myComposedFunction</code>只会用承诺来工作！我们可以相当简单地解决那个问题。</p><pre class="jr js jt ju fq lg lf lh li aw lj dt"><span id="dedf" class="kc kd hu lf b fv lk ll l lm ln">function myComposedFunction(argument) {<br/>  Promise.resolve(argument).then(() =&gt; {<br/>    // actual content of myComposedFunction goes here<br/>  });<br/>}</span></pre><p id="0110" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是这看起来像是一大堆样板文件。特别是如果这是一个简单的函数。也许确实如此:<code class="eh lc ld le lf b">return argument + 10;</code>我们刚刚把一个非常简单的函数变成了一个非常复杂的函数。</p><p id="85c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">更好的方法是在<code class="eh lc ld le lf b">compose</code>函数本身中处理这个问题。</p><pre class="jr js jt ju fq lg lf lh li aw lj dt"><span id="69aa" class="kc kd hu lf b fv lk ll l lm ln">const composePromise = (...functions) =&gt;<br/>  initialValue =&gt;<br/>    functions.reduceRight(<br/>      (sum, fn) =&gt; Promise.resolve(sum).then(fn),<br/>      initialValue<br/>    );</span></pre><p id="0675" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个<code class="eh lc ld le lf b">composePromise</code>函数与前面的<code class="eh lc ld le lf b">compose</code>函数完全一样，只有一个主要区别。它接受承诺，并返回承诺。你可以这样使用它:</p><pre class="jr js jt ju fq lg lf lh li aw lj dt"><span id="cd4c" class="kc kd hu lf b fv lk ll l lm ln">const add100ToNumberString = composePromise(<br/>  console.log,<br/>  res =&gt; res.toString(),<br/>  res =&gt; Promise.resolve(res + 100),<br/>  res =&gt; Promise.resolve(Number(res)),<br/>);</span><span id="a56d" class="kc kd hu lf b fv lo ll l lm ln">add100ToNumberString(new Promise(resolve =&gt; {<br/>  setTimeout(() =&gt; {<br/>    resolve('400');<br/>  }, 2000);<br/>})); <br/>// Eventually prints out '500' after 2 seconds</span></pre><p id="2725" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">可以继续链，因为<code class="eh lc ld le lf b">add100ToNumberString</code>的结果是一个承诺。如果需要，你也可以使用<code class="eh lc ld le lf b">.catch()</code>和<code class="eh lc ld le lf b">.finally()</code>！</p><h2 id="4f31" class="kc kd hu bd ke kf kg kh ki kj kk kl km jc kn ko kp jg kq kr ks jk kt ku kv kw dt translated">你自己试试！</h2><p id="5117" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">下面我嵌入了一个<a class="ae jp" href="https://codepen.io/" rel="noopener ugc nofollow" target="_blank"> CodePen </a>游乐场，里面有所有这些代码，你可以自己尝试一下！打开控制台查看结果。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lp lq l"/></div></figure></div><div class="ab cl lr ls hc lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hn ho hp hq hr"><p id="f753" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">嗨，我是贾斯汀·富勒。很高兴你看了我的帖子！我需要让你知道，我在这里写的一切都是我自己的观点，并不代表我的雇主。所有代码样本都是我自己的，与美国银行的代码完全无关。</p><p id="5c8a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我也很乐意收到您的来信，请随时通过<a class="ae jp" href="https://www.linkedin.com/in/justin-fuller-8726b2b1/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>、<a class="ae jp" href="https://github.com/justindfuller" rel="noopener ugc nofollow" target="_blank"> Github </a>或<a class="ae jp" rel="noopener" href="/@justindanielfuller"> Medium </a>与我联系。再次感谢阅读！</p></div></div>    
</body>
</html>