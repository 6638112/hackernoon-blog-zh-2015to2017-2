<html>
<head>
<title>Creating a self-contained Kotlin program using Avian</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Avian创建自包含的Kotlin程序</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/creating-a-self-contained-kotlin-app-using-avian-ca7f2987fdd5?source=collection_archive---------7-----------------------#2017-02-09">https://medium.com/hackernoon/creating-a-self-contained-kotlin-app-using-avian-ca7f2987fdd5?source=collection_archive---------7-----------------------#2017-02-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="a909" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Avian是一个轻量级的JVM，它允许你创建独立的应用程序。这意味着你可以在不强迫用户安装任何JRE的情况下发布你的应用。在这里，我们将遵循简单的步骤，允许我们使用Kotlin创建一个独立的hello-world应用程序。</p><h1 id="8cfb" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">为什么是科特林？</h1><p id="29ac" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">Kotlin是一种很有潜力的伟大语言。我不打算介绍它的所有优点，因为在我之前已经有很多人做过了。所以我们将把它留在那里，这是一门很有潜力的伟大语言。如果你想知道为什么，网上有很多信息。</p><h1 id="fc95" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">为什么是禽类？</h1><p id="c197" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">Java面临的最大挑战之一是它需要一个Java运行时环境。这意味着，如果我编写一个Java程序，我的每个用户都需要下载、安装，甚至配置JRE，然后才能启动我的程序。在某些情况下，如果他们还没有JRE(或者如果他们有JRE的不兼容版本),人们会选择不安装某些软件来避免麻烦。)</p></div><div class="ab cl kt ku hc kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hn ho hp hq hr"><h1 id="ca2a" class="jq jr hu bd js jt la jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj le kl km kn dt translated">结果呢</h1><p id="d92f" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们要完成的是一个用于macOS的1.9MB二进制文件或用于Linux的2.2MB二进制文件(做了一些小的修改，它应该可以在其他支持的平台上工作，见<a class="ae jp" href="https://github.com/ReadyTalk/avian/blob/master/README.md" rel="noopener ugc nofollow" target="_blank">这里</a>，一旦执行，它将问候用户并打印它收到的所有参数。像这样:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="c37c" class="lo jr hu lk b fv lp lq l lr ls">$ ./hello Miguel Castiblanco<br/>Hello from Kotlin and Avian<br/>args:<br/>-Miguel<br/>-Castiblanco</span></pre></div><div class="ab cl kt ku hc kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hn ho hp hq hr"><h1 id="c55d" class="jq jr hu bd js jt la jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj le kl km kn dt translated">1.开始之前</h1><ul class=""><li id="df30" class="lt lu hu it b iu ko iy kp jc lv jg lw jk lx jo ly lz ma mb dt translated">$JAVA_HOME必须指向正确的位置</li><li id="e50d" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo ly lz ma mb dt translated">必须安装Kotlin，kotlinc (Kotlin编译器)必须在$PATH中</li><li id="19cb" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo ly lz ma mb dt translated">下面的命令是为在macOS上工作而编写的。除非另有说明，否则通过将macosx更改为linux，以及架构(如果需要的话),该命令应该可以在Linux中工作。)例如<em class="mh"> macosx-x86_64 </em>会变成<em class="mh"> linux-i386 </em>或<em class="mh"> linux-x86_64 </em></li><li id="985b" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo ly lz ma mb dt translated">本教程基于Avian的<a class="ae jp" href="https://github.com/ReadyTalk/avian/blob/master/README.md" rel="noopener ugc nofollow" target="_blank">自述</a>。我的大部分工作是让它与Kotlin而不是Java一起工作，并把它放在对Avian新手有意义的指令组中，同时解释我们在做什么。</li></ul><h1 id="0944" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">2.获取和构建Avian</h1><p id="e2b8" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">让我们从获取最新版本的Avian开始:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="f5fc" class="lo jr hu lk b fv lp lq l lr ls">$ git clone <a class="ae jp" href="https://github.com/ReadyTalk/avian.git" rel="noopener ugc nofollow" target="_blank">https://github.com/ReadyTalk/avian.git</a></span></pre><p id="089c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后用默认配置构建它，并测试它是否工作</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="f878" class="lo jr hu lk b fv lp lq l lr ls">$ cd avian<br/>$ make<br/>$ build/macosx-x86_64/avian -cp build/macosx-x86_64/test Hello</span></pre><p id="b623" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后一个命令应该显示“hello，world！”如果一切正确的话。</p><h1 id="6a53" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">3.编写我们简单的Kotlin程序，并打包</h1><p id="0771" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">让我们创建一个文件夹，将我们的小Kotlin脚本放在那里，并将其打包到一个jar中。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="222b" class="lo jr hu lk b fv lp lq l lr ls">$ cd ../<br/>$ mkdir helloKotlin &amp;&amp; cd helloKotlin<br/>$ cat &gt;Hello.kt &lt;&lt;EOF<br/>fun main(args: Array&lt;String&gt;) {<br/>   println("Hello from Kotlin and Avian")<br/>   println("args: ")<br/>   args.forEach {<br/>      println("-\$it")<br/>   }<br/>}<br/>EOF<br/>$ kotlinc Hello.kt -include-runtime -d boot.jar</span></pre><p id="3391" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意，我们正在编译Kotlin的运行时，这意味着如果你运行un <em class="mh"> zip -l boot.jar </em>你会看到所有Kotlin的类。这很重要，因为我们需要一个独立的应用程序。</p><h1 id="0fac" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">4.准备将Avian的运行时与Kotlin的合并</h1><p id="5909" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们将获得Avian的运行时并提取它，还将获得用Avian创建二进制文件所需的文件。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="e7ee" class="lo jr hu lk b fv lp lq l lr ls">$ ar x ../avian/build/macosx-x86_64/libavian.a<br/>$ mkdir avian-cp<br/>$ cp ../avian/build/macosx-x86_64/classpath.jar avian-cp/avian-cp.jar<br/>$ cd avian-cp/<br/>$ unzip avian-cp.jar &amp;&amp; rm -rf avian-cp.jar</span></pre><h1 id="0cb0" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">5.将Avian、Kotlin和我们的应用程序合并在一个jar中</h1><p id="a72f" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">这里我们创建了一个jar，它包含了Avian的运行时、Kotlin的运行时和我们的小应用程序。我们将把之前从<em class="mh"> avian-cp.jar </em>中提取的所有内容合并到<em class="mh"> boot.jar </em>(其中已经有了Kotlin和我们的代码。)</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="1088" class="lo jr hu lk b fv lp lq l lr ls">$ mv ../boot.jar .<br/>$ zip -r boot.jar META-INF avian dalvik java libcore sun<br/>$ mv boot.jar ../ &amp;&amp; cd ../</span></pre><p id="993e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你现在运行un <em class="mh"> zip -l boot.jar </em>，你会看到所有的类现在都在一起很开心。</p><h1 id="67ab" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">6.创建二进制文件</h1><p id="5f39" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">现在我们有了一个独立的罐子。剩下的只是使用Avian创建一个二进制文件。首先，我们从jar中创建一个对象。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="0949" class="lo jr hu lk b fv lp lq l lr ls">$ ../avian/build/macosx-x86_64/binaryToObject/binaryToObject boot.jar \boot-jar.o _binary_boot_jar_start _binary_boot_jar_end macosx x86_64</span></pre><p id="1f17" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面的命令将为我们的二进制文件创建c++主类。请注意，<em class="mh"> FindClass </em>正在寻找<strong class="it hv"> HelloKt </strong>，因为用<em class="mh"> kotlinc </em>编译的类会有一个<em class="mh"> Kt </em>后缀(<em class="mh"> javac </em>将<em class="mh">Hello.java</em>编译成<em class="mh"> Hello.class </em>，而<em class="mh"> kotlinc </em>将<em class="mh"> Hello.kt </em>编译成<em class="mh"> HelloKt.class</em></p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="d2c1" class="lo jr hu lk b fv lp lq l lr ls">$ cat &gt;embedded-jar-main.cpp &lt;&lt;EOF<br/>#include "stdint.h"<br/>#include "jni.h"<br/>#include "stdlib.h"</span><span id="b151" class="lo jr hu lk b fv mi lq l lr ls">#if (defined __MINGW32__) || (defined _MSC_VER)<br/>#  define EXPORT __declspec(dllexport)<br/>#else<br/>#  define EXPORT __attribute__ ((visibility("default"))) \<br/>  __attribute__ ((used))<br/>#endif</span><span id="32db" class="lo jr hu lk b fv mi lq l lr ls">#if (! defined __x86_64__) &amp;&amp; ((defined __MINGW32__) || (defined _MSC_VER))<br/>#  define SYMBOL(x) binary_boot_jar_##x<br/>#else<br/>#  define SYMBOL(x) _binary_boot_jar_##x<br/>#endif</span><span id="7e23" class="lo jr hu lk b fv mi lq l lr ls">extern "C" {</span><span id="d435" class="lo jr hu lk b fv mi lq l lr ls">extern const uint8_t SYMBOL(start)[];<br/>  extern const uint8_t SYMBOL(end)[];</span><span id="f050" class="lo jr hu lk b fv mi lq l lr ls">EXPORT const uint8_t*<br/>  bootJar(size_t* size)<br/>  {<br/>    *size = SYMBOL(end) - SYMBOL(start);<br/>    return SYMBOL(start);<br/>  }</span><span id="24df" class="lo jr hu lk b fv mi lq l lr ls">} // extern "C"</span><span id="99fc" class="lo jr hu lk b fv mi lq l lr ls">extern "C" void __cxa_pure_virtual(void) { abort(); }</span><span id="aa27" class="lo jr hu lk b fv mi lq l lr ls">int<br/>main(int ac, const char** av)<br/>{<br/>  JavaVMInitArgs vmArgs;<br/>  vmArgs.version = JNI_VERSION_1_2;<br/>  vmArgs.nOptions = 1;<br/>  vmArgs.ignoreUnrecognized = JNI_TRUE;</span><span id="f9cb" class="lo jr hu lk b fv mi lq l lr ls">JavaVMOption options[vmArgs.nOptions];<br/>  vmArgs.options = options;</span><span id="3a13" class="lo jr hu lk b fv mi lq l lr ls">options[0].optionString = const_cast&lt;char*&gt;("-Xbootclasspath:[bootJar]");</span><span id="9851" class="lo jr hu lk b fv mi lq l lr ls">JavaVM* vm;<br/>  void* env;<br/>  JNI_CreateJavaVM(&amp;vm, &amp;env, &amp;vmArgs);<br/>  JNIEnv* e = static_cast&lt;JNIEnv*&gt;(env);</span><span id="15d4" class="lo jr hu lk b fv mi lq l lr ls">jclass c = e-&gt;FindClass("HelloKt");<br/>  if (not e-&gt;ExceptionCheck()) {<br/>    jmethodID m = e-&gt;GetStaticMethodID(c, "main", "([Ljava/lang/String;)V");<br/>    if (not e-&gt;ExceptionCheck()) {<br/>      jclass stringClass = e-&gt;FindClass("java/lang/String");<br/>      if (not e-&gt;ExceptionCheck()) {<br/>        jobjectArray a = e-&gt;NewObjectArray(ac-1, stringClass, 0);<br/>        if (not e-&gt;ExceptionCheck()) {<br/>          for (int i = 1; i &lt; ac; ++i) {<br/>            e-&gt;SetObjectArrayElement(a, i-1, e-&gt;NewStringUTF(av[i]));<br/>          }</span><span id="edb8" class="lo jr hu lk b fv mi lq l lr ls">e-&gt;CallStaticVoidMethod(c, m, a);<br/>        }<br/>      }<br/>    }<br/>  }</span><span id="be2d" class="lo jr hu lk b fv mi lq l lr ls">int exitCode = 0;<br/>  if (e-&gt;ExceptionCheck()) {<br/>    exitCode = -1;<br/>    e-&gt;ExceptionDescribe();<br/>  }</span><span id="803a" class="lo jr hu lk b fv mi lq l lr ls">vm-&gt;DestroyJavaVM();</span><span id="b1ed" class="lo jr hu lk b fv mi lq l lr ls">return exitCode;<br/>}<br/>EOF</span></pre><p id="3acd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们将把C++类编译成一个对象，并链接所有的对象(注意，在第4步中，我们将一堆Avian的对象复制到当前文件夹中)以最终创建我们的二进制文件，它将被称为<em class="mh"> hello </em>。</p><p id="1994" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">对于macOS: </strong></p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="662a" class="lo jr hu lk b fv lp lq l lr ls">$ g++ -I$JAVA_HOME/include -I$JAVA_HOME/include/darwin \<br/>     -D_JNI_IMPLEMENTATION_ -c embedded-jar-main.cpp -o main.o<br/>$ g++ -rdynamic *.o -ldl -lpthread -lz -o hello -framework CoreFoundation<br/>$ strip -S -x hello</span></pre><p id="34c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">对于Linux: </strong></p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="5574" class="lo jr hu lk b fv lp lq l lr ls">$ g++ -I$JAVA_HOME/include -I$JAVA_HOME/include/linux \<br/>     -D_JNI_IMPLEMENTATION_ -c embedded-jar-main.cpp -o main.o<br/>$ g++ -rdynamic *.o -ldl -lpthread -lz -o hello<br/>$ strip --strip-all hello</span></pre><h1 id="94f6" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">7.运行它</h1><p id="d826" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">现在我们终于可以运行它，看看它是如何工作的</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="6977" class="lo jr hu lk b fv lp lq l lr ls">$ ./hello Kotlin Avian<br/>Hello from Kotlin and Avian<br/>args:<br/>-Kotlin<br/>-Avian<br/>$ ls -lha hello<br/>-rwxr-xr-x 1 starcarr starcarr 2.0M Feb  8 17:03 hello</span></pre></div><div class="ab cl kt ku hc kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hn ho hp hq hr"><h1 id="4787" class="jq jr hu bd js jt la jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj le kl km kn dt translated">结论</h1><ul class=""><li id="0488" class="lt lu hu it b iu ko iy kp jc lv jg lw jk lx jo ly lz ma mb dt translated">这个过程是漫长的，当然，它有可能被转换成一个脚本，为我们做所有的工作。也就是说，至少花时间这样做一次是很重要的，这样才能理解Avian是如何工作的，这样我们就可以在出现问题时进行故障排除</li><li id="e01c" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo ly lz ma mb dt translated">Avian正在向独立的Kotlin和Java应用程序敞开大门，这将允许我们创建脚本或实用程序，这些程序可以很容易地在无JRE的机器上分发</li><li id="c8a9" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo ly lz ma mb dt translated">应用程序的总大小是1.9MB(在Linux中是2.2MB)，这表明Avian是轻量级的</li></ul><blockquote class="mj mk ml"><p id="81c9" class="ir is mh it b iu iv iw ix iy iz ja jb mm jd je jf mn jh ji jj mo jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is mh it b iu iv iw ix iy iz ja jb mm jd je jf mn jh ji jj mo jl jm jn jo hn dt translated">要了解更多信息，<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">请阅读我们的“关于”页面</a> , <a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">喜欢/在脸书给我们发消息</a>，或者简单地，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank">发推文/DM @HackerNoon。</a></p><p id="708a" class="ir is mh it b iu iv iw ix iy iz ja jb mm jd je jf mn jh ji jj mo jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>