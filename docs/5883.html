<html>
<head>
<title>Why Parameter Sniffing Hurts Your SQL Query Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么参数嗅探会损害SQL查询性能</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/why-parameter-sniffing-hurts-your-sql-query-performance-d73c0da71fbc?source=collection_archive---------2-----------------------#2017-08-22">https://medium.com/hackernoon/why-parameter-sniffing-hurts-your-sql-query-performance-d73c0da71fbc?source=collection_archive---------2-----------------------#2017-08-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="1a04" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">意外的SQL Server性能杀手#2</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/d1f3616f100c5df75e968bb5af1e1310.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W4tMPnro22CSaHYCRb9Iug.jpeg"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Photo by <a class="ae kf" href="https://unsplash.com/photos/h8T1Wa4u7oU?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Jakob Owens</a> on <a class="ae kf" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="24fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本系列中，我将探索损害<a class="ae kf" href="https://hackernoon.com/tagged/sql-server" rel="noopener ugc nofollow" target="_blank"><em class="kg">SQL Server</em></a><em class="kg">性能的场景，并向您展示如何避免它们。从我收集的“多年来我不知道自己做错的事情”中抽出来的。</em></p></div><div class="ab cl kh ki hc kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hn ho hp hq hr"><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="206c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="kg">更喜欢视频？</em> <a class="ae kf" href="https://www.youtube.com/watch?v=qo9iWKYqJDA&amp;feature=youtu.be" rel="noopener ugc nofollow" target="_blank"> <em class="kg">在YouTube上看这个帖子。</em>T13】</a></p><p id="46c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上周我们讨论了<a class="ae kf" href="https://blog.bertwagner.com/are-your-indexes-being-thwarted-by-mismatched-datatypes-d3985375e528" rel="noopener ugc nofollow" target="_blank">隐式转换如何成为你精心设计的索引没有被使用的一个原因</a>。</p><p id="6ef0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">今天我们来看另一个原因:<a class="ae kf" href="https://hackernoon.com/tagged/parameter" rel="noopener ugc nofollow" target="_blank">参数</a>嗅探。</p><p id="cd8a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">关键在于:<strong class="it hv">参数嗅探并不总是一件坏事。</strong></p><p id="b920" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">大多数情况下这是好的:这意味着SQL Server正在缓存和重用查询计划，以使您的查询运行得更快。</p><p id="113c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">只有当缓存的计划与给定输入参数的最优计划相差甚远时，参数嗅探才会成为一个问题。</p><h1 id="54ca" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">那么什么是参数嗅探呢？</h1><p id="85ca" class="pw-post-body-paragraph ir is hu it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">让我们从我们的表dbo开始。你可以从Github 获得咖啡库存。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff lt"><img src="../Images/1681dae528513db12cfd571c18abe080.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7uYfuAA5zZf_h5Civ9ww4w.png"/></div></div></figure><p id="3116" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">关于此表，需要了解的关键事项是:</p><ol class=""><li id="cf4d" class="lu lv hu it b iu iv iy iz jc lw jg lx jk ly jo lz ma mb mc dt translated">我们在名称列上有一个非聚集索引。</li><li id="c5bb" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo lz ma mb mc dt translated">数据分布不均匀(我们马上会看到这一点)</li></ol><p id="02ef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，让我们编写一个存储过程，根据国家返回表中经过过滤的咖啡列表。由于没有特定的国家列，我们将编写它，以便它在名称列上过滤:</p><pre class="jq jr js jt fq mi mj mk ml aw mm dt"><span id="d8d4" class="mn kr hu mj b fv mo mp l mq mr">DROP PROCEDURE IF EXISTS dbo.FilterCoffee<br/>GO<br/>CREATE PROCEDURE dbo.FilterCoffee<br/> <a class="ae kf" href="http://twitter.com/ParmCountry" rel="noopener ugc nofollow" target="_blank">@ParmCountry</a> varchar(30)<br/>AS<br/>BEGIN<br/> SELECT Name, Price, Description <br/> FROM Sandbox.dbo.CoffeeInventory<br/> WHERE Name LIKE <a class="ae kf" href="http://twitter.com/ParmCountry" rel="noopener ugc nofollow" target="_blank">@ParmCountry</a> + '%'<br/>END<br/>GO</span></pre><p id="5846" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们来看看参数嗅探的实际应用，然后我们来看看它为什么会发生以及如何解决。</p><pre class="jq jr js jt fq mi mj mk ml aw mm dt"><span id="89da" class="mn kr hu mj b fv mo mp l mq mr">EXEC dbo.FilterCoffee @ParmCountry = 'Costa Rica'<br/>EXEC dbo.FilterCoffee @ParmCountry = 'Ethiopia'</span></pre><p id="2d46" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">运行上面的语句，我们可以使用表扫描得到相同的执行计划:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff ms"><img src="../Images/81a1db02ff10ffe000685e5b68166060.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*txha3f40Q6XsLP0UUQajhw.png"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">In this case we explicitly specified the parameter @ParmCountry. Sometimes SQL will parameterize simple queries on its own.</figcaption></figure><p id="2262" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="kg">真是奇怪</em>。我们有两个查询执行，它们使用相同的计划，并且没有一个计划在名称上使用我们的非聚集索引！</p><p id="d347" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们退后一步，再试一次。首先，清除此存储过程的查询计划缓存:</p><pre class="jq jr js jt fq mi mj mk ml aw mm dt"><span id="b4e5" class="mn kr hu mj b fv mo mp l mq mr">DECLARE <a class="ae kf" href="http://twitter.com/cache_plan_handle" rel="noopener ugc nofollow" target="_blank">@cache_plan_handle</a> varbinary(44)<br/>SELECT <a class="ae kf" href="http://twitter.com/cache_plan_handle" rel="noopener ugc nofollow" target="_blank">@cache_plan_handle</a> = c.plan_handle<br/>FROM <br/> sys.dm_exec_cached_plans c<br/> CROSS APPLY sys.dm_exec_sql_text(c.plan_handle) t<br/>WHERE <br/> text like 'CREATE%CoffeeInventory%' <br/>-- Never run DBCC FREEPROCCACHE without a parameter in production unless you want to lose all of your cached plans...<br/>DBCC FREEPROCCACHE(<a class="ae kf" href="http://twitter.com/cache_plan_handle" rel="noopener ugc nofollow" target="_blank">@cache_plan_handle</a>)</span></pre><p id="f6ad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，使用相同的参数值执行相同的存储过程，但这次首先使用“埃塞俄比亚”参数值。查看执行计划:</p><pre class="jq jr js jt fq mi mj mk ml aw mm dt"><span id="e6f4" class="mn kr hu mj b fv mo mp l mq mr">EXEC dbo.FilterCoffee @ParmCountry = 'Ethiopia'<br/>EXEC dbo.FilterCoffee @ParmCountry = 'Costa Rica'</span></pre><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mt"><img src="../Images/99a6d19773f8e44da04a8dab749a4df1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EN_loooe8AOjXr0JONOhZg.png"/></div></div></figure><p id="4684" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们的Name非聚集索引正在被使用。两个查询仍然接收相同(尽管不同)的计划。</p><p id="f361" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们没有对存储过程代码做任何修改，只是改变了使用不同参数执行查询的顺序。</p><h1 id="1024" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">这到底是怎么回事！？</h1><p id="465e" class="pw-post-body-paragraph ir is hu it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">这是一个参数嗅探的例子。第一次在SQL server上运行存储过程(或查询)时，SQL将为其生成一个执行计划，并将该计划存储在查询计划缓存中:</p><pre class="jq jr js jt fq mi mj mk ml aw mm dt"><span id="6588" class="mn kr hu mj b fv mo mp l mq mr">SELECT<br/> c.usecounts,<br/> c.cacheobjtype,<br/> c.objtype,<br/> c.plan_handle,<br/> c.size_in_bytes,<br/> d.name,<br/> t.text,<br/> p.query_plan<br/>FROM <br/> sys.dm_exec_cached_plans c<br/> CROSS APPLY sys.dm_exec_sql_text(c.plan_handle) t<br/> CROSS APPLY sys.dm_exec_query_plan(c.plan_handle) p<br/> INNER JOIN sys.databases d<br/> ON t.dbid = d.database_id<br/>WHERE <br/> text like 'CREATE%CoffeeInventory%'</span></pre><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mu"><img src="../Images/628b31d642535b13ff43155b27d60093.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w8c6qVSh_CA3JUMIXDBnJw.png"/></div></div></figure><p id="0926" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同一查询的所有后续执行都将进入查询缓存，以重用同一初始查询计划，这样可以节省SQL Server重新生成新查询计划的时间。</p><p id="4804" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="kg">注意:在SQL Server看来，不同值作为参数传递的查询仍然算作“相同的查询”。</em></p><p id="962c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在上面的例子中，第一次执行查询时使用的参数是“哥斯达黎加”。还记得我说过这个数据集严重倾斜吗？让我们来看看一些计数:</p><pre class="jq jr js jt fq mi mj mk ml aw mm dt"><span id="691b" class="mn kr hu mj b fv mo mp l mq mr">SELECT <br/>  LEFT(Name,CHARINDEX(' ',Name)) AS Country, <br/>  COUNT(*) AS CountryCount <br/>FROM dbo.CoffeeInventory <br/>GROUP BY <br/>  LEFT(Name,CHARINDEX(' ',Name))</span></pre><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff mv"><img src="../Images/1171a2677135fc994b651486197ae908.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/1*RdZLVZj99CCXpni3mwJNAw.png"/></div></figure><p id="ed79" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">“哥斯达黎加”在这个表中有10，000多行，而所有其他国家的名称都是个位数。</p><p id="6536" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这意味着，当我们第一次执行存储过程时，SQL Server生成了一个使用表扫描的执行计划，因为它认为这是检索10，052行中的10，003行的最有效方法。</p><p id="7faf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个表扫描查询计划只适合哥斯达黎加。将任何其他国家的名称传入存储过程将只返回少量记录，这使得SQL Server使用我们的非聚集索引更加有效。</p><p id="bdfe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">然而</strong>，由于Costa Rica计划是第一个运行的计划，因此被添加到查询计划缓存中，所有其他的执行都使用相同的表扫描执行计划。</p><p id="b613" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用<code class="eh mw mx my mj b">DBCC FREEPROCCACHE</code>清除缓存的执行计划后，我们再次执行存储过程，但是使用‘Ethiopia’作为参数。SQL Server确定带有索引查找的计划对于仅检索表中10，052行中的6行是最佳的。然后，它缓存该索引查找计划，这就是为什么第二次“哥斯达黎加”参数接收到带有索引查找的执行计划。</p><h1 id="9169" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">好的，那么我如何防止参数嗅探呢？</h1><p id="765b" class="pw-post-body-paragraph ir is hu it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">这个问题实际上应该重新表述为“如何防止SQL Server使用查询计划缓存中的次优计划？”</p><p id="ab94" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们来看看其中的一些技巧。</p><h2 id="1406" class="mn kr hu bd ks mz na nb kw nc nd ne la jc nf ng le jg nh ni li jk nj nk lm nl dt translated">1.与RECOMPILE或OPTION (RECOMPILE)一起使用</h2><p id="083c" class="pw-post-body-paragraph ir is hu it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">我们可以简单地将这些查询提示添加到我们的EXEC语句中:</p><pre class="jq jr js jt fq mi mj mk ml aw mm dt"><span id="1e74" class="mn kr hu mj b fv mo mp l mq mr">EXEC dbo.FilterCoffee @ParmCountry = 'Ethiopia' WITH RECOMPILE<br/>EXEC dbo.FilterCoffee @ParmCountry = 'Costa Rica' WITH RECOMPILE</span></pre><p id="7571" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者我们的存储过程本身:</p><pre class="jq jr js jt fq mi mj mk ml aw mm dt"><span id="191e" class="mn kr hu mj b fv mo mp l mq mr">DROP PROCEDURE IF EXISTS dbo.FilterCoffee<br/>GO<br/>CREATE PROCEDURE dbo.FilterCoffee<br/> <a class="ae kf" href="http://twitter.com/ParmCountry" rel="noopener ugc nofollow" target="_blank">@ParmCountry</a> varchar(30)<br/>AS<br/>BEGIN<br/> SELECT Name, Price, Description <br/> FROM Sandbox.dbo.CoffeeInventory <br/> WHERE Name LIKE <a class="ae kf" href="http://twitter.com/ParmCountry" rel="noopener ugc nofollow" target="_blank">@ParmCountry</a> + '%'<br/> <br/> OPTION (RECOMPILE)</span><span id="2e14" class="mn kr hu mj b fv nm mp l mq mr">END<br/>GO</span></pre><p id="0f88" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">RECOMPILE提示的作用是强制SQL Server在每次运行这些查询时生成一个新的执行计划。</p><p id="524b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用RECOMPILE消除了我们的参数嗅探问题，因为SQL Server将在我们每次执行查询时重新生成查询计划。</p><p id="f43f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里的缺点是，我们失去了SQL Server通过缓存执行计划来节省CPU周期的所有好处。</p><p id="a918" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您的参数嗅探查询经常运行，RECOMPILE可能是一个坏主意，因为您将会遇到许多定期生成查询计划的情况。</p><p id="242c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您的参数嗅探查询不经常运行，或者如果查询不经常运行以至于留在查询计划缓存中，那么RECOMPILE是一个好的解决方案。</p><h2 id="ec8d" class="mn kr hu bd ks mz na nb kw nc nd ne la jc nf ng le jg nh ni li jk nj nk lm nl dt translated">2.使用OPTIMIZE FOR查询提示</h2><p id="90d4" class="pw-post-body-paragraph ir is hu it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">我们的另一个选择是在我们的查询中添加以下提示之一。其中一个将被添加到与上述存储过程中的OPTION (RECOMPILE)相同的位置:</p><pre class="jq jr js jt fq mi mj mk ml aw mm dt"><span id="930f" class="mn kr hu mj b fv mo mp l mq mr">OPTION (OPTIMIZE FOR (@ParmCountry UNKNOWN))</span></pre><p id="bfc1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者</p><pre class="jq jr js jt fq mi mj mk ml aw mm dt"><span id="6f88" class="mn kr hu mj b fv mo mp l mq mr">OPTION (OPTIMIZE FOR (@ParmCountry = 'Ethiopia'))</span></pre><p id="6c0c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">OPTIMIZE FOR UNKNOWN将使用根据该列/索引的平均分布统计信息生成的查询计划。通常它会导致一个普通的或者糟糕的执行计划，所以我不喜欢使用它。</p><p id="b85e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">优化值使用指定的任何参数值创建计划。如果您知道您的查询将检索针对您大部分时间指定的值而优化的数据，这是非常好的。</p><p id="6e4b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在上面的例子中，如果我们知道值“哥斯达黎加”很少被查询，我们可能会优化索引搜索。然后，大多数查询将运行最佳缓存查询计划，我们将只在查询“哥斯达黎加”时进行点击。</p><h2 id="ba65" class="mn kr hu bd ks mz na nb kw nc nd ne la jc nf ng le jg nh ni li jk nj nk lm nl dt translated">3.IF/ELSE</h2><p id="bca6" class="pw-post-body-paragraph ir is hu it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">这种解决方案提供了极大的灵活性。基本上，您可以创建针对不同值进行优化的不同存储过程。这些存储过程将它们的计划缓存起来，然后由IF/ELSE语句确定为传入的参数运行哪个过程:</p><pre class="jq jr js jt fq mi mj mk ml aw mm dt"><span id="9535" class="mn kr hu mj b fv mo mp l mq mr">DROP PROCEDURE IF EXISTS dbo.FilterCoffee<br/>GO<br/>CREATE PROCEDURE dbo.FilterCoffee<br/> <a class="ae kf" href="http://twitter.com/ParmCountry" rel="noopener ugc nofollow" target="_blank">@ParmCountry</a> varchar(30)<br/>AS<br/>BEGIN<br/> IF <a class="ae kf" href="http://twitter.com/ParmCoutnry" rel="noopener ugc nofollow" target="_blank">@ParmCountry</a> = 'Costa Rica'<br/> BEGIN<br/>  EXEC dbo.ScanningStoredProcedure @ParmCountry<br/> END<br/> ELSE<br/> BEGIN<br/>  EXEC dbo.SeekingStoredProcedure @ParmCountry<br/> END<br/>END<br/>GO</span></pre><p id="c4c1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个选项需要做更多的工作(如何确定IF条件应该是什么？随着时间的推移，越来越多的数据被添加到表中，并且数据的分布发生了变化，会发生什么情况？)但是，如果您希望缓存您的计划，并且希望计划对于传入的数据来说是最佳的，那么它将为您提供最佳性能。</p><h1 id="f887" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">结论</h1><ol class=""><li id="f9d6" class="lu lv hu it b iu lo iy lp jc nn jg no jk np jo lz ma mb mc dt translated">只有当数据值分布不均匀，并且缓存的查询计划不是对所有值都最佳时，参数嗅探才是糟糕的。</li><li id="e093" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo lz ma mb mc dt translated">SQL Server缓存第一次运行查询/存储过程时生成的查询计划，并使用第一次运行时使用的任何参数值。</li><li id="5d9d" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo lz ma mb mc dt translated">当您的查询不经常运行或者大部分时间都不在查询缓存中时，使用RECOMPILE提示是一个好的解决方案。</li><li id="2a34" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo lz ma mb mc dt translated">当您可以指定一个值来生成对大多数参数值都有效的查询计划，并且可以在不经常查询的值上使用次优计划时，可以使用OPTIMIZE FOR提示。</li><li id="fe87" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo lz ma mb mc dt translated">使用复杂的逻辑(比如IF/ELSE)将会给你带来极大的灵活性和性能，但是对于长期维护来说也是最糟糕的。</li></ol><p id="ad3e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="kg">还在读书？你可能会喜欢在推特上关注我的</em><a class="ae kf" href="https://twitter.com/bertwagner" rel="noopener ugc nofollow" target="_blank"><em class="kg"/></a><em class="kg">r</em></p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="nq kp l"/></div></figure><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="nq kp l"/></div></figure></div></div>    
</body>
</html>