<html>
<head>
<title>Should I Learn Elm If I Am a JavaScript Developer?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如果我是JavaScript开发人员，应该学习Elm吗？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/should-i-learn-elm-if-i-am-a-javascript-developer-fba282cef6a0?source=collection_archive---------7-----------------------#2017-06-30">https://medium.com/hackernoon/should-i-learn-elm-if-i-am-a-javascript-developer-fba282cef6a0?source=collection_archive---------7-----------------------#2017-06-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="964f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的一个好朋友说我应该学榆树。</p><p id="3ee3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">——“你会从中学到很多，用不用都没关系。”</p><p id="6ea2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这正是那种无论他说什么都让人信服的朋友。可能是因为他的白胡子和蓝眼睛。或者可能是因为他实际上几乎总是对的。</p><p id="679a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Elm是一个4岁的成年人，它将文件转换成javascript，并且没有选择“正确”框架的js疲劳，因为它实际上是一个框架。它功能齐全，是redux之父:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/80115eb821692789fda124896486e55f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dldDEgCpRm4OLF4RcFD8Xg.png"/></div></div></figure><p id="a3b0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以我牺牲了几个有希望变好的周末来获得一些见解，现在很乐意与你分享:</p><h1 id="f02e" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">1.没有运行时错误</h1><p id="c2f2" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">我将直接从核心概念开始。</p><p id="fc87" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以忘记Elm中恼人的错误消息“NaN”、“未捕获类型错误”或“foo is undefined ”,因为它支持<em class="le">静态类型检查</em>,这意味着在编译时它会检查您的所有代码，以确保所有变量以及函数的输入和输出匹配。这意味着如果你的函数只接受字符串，你就无法传递其他任何东西。</p><p id="7b25" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然建议将类型声明为:</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="bbac" class="lk kc hu lg b fv ll lm l ln lo">reps : String -&gt; Int</span></pre><p id="9461" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(reps是函数名，String是输入类型，Int是输出类型)，这不是必需的，因为Elm可以自动地自己算出所有的类型(这叫做<em class="le">类型推断)</em>并在编译完成后向您显示适当的错误或成功消息。</p><h1 id="172f" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">2.工会类型</h1><p id="8065" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">Elm中常用的一个好技巧是Union type，它允许您为怪异或复杂的类型定义可能的值。假设我们有一个练习类型，它可以是以下字符串之一:<code class="eh lp lq lr lg b">Pull-up</code>或<code class="eh lp lq lr lg b">Push-up</code></p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="1015" class="lk kc hu lg b fv ll lm l ln lo">type Exercise = Pull-up | Push-up</span></pre><p id="ff9f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我想创建一个函数<code class="eh lp lq lr lg b">reps</code>，它根据练习返回重复次数:</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="81ea" class="lk kc hu lg b fv ll lm l ln lo">reps : Exercise -&gt; Int<br/>reps exercise =<br/>  case exercise of<br/>    Pull-up -&gt;<br/>      10</span><span id="154d" class="lk kc hu lg b fv ls lm l ln lo">    Push-up -&gt;<br/>      15</span></pre><p id="3816" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里重要的是，每当我们传递一个联合变量作为参数(在这个例子中是<code class="eh lp lq lr lg b">exercise</code>)时，我们被迫使用<code class="eh lp lq lr lg b">case</code>表达式。更重要的是，编译器检查了那个<code class="eh lp lq lr lg b">case</code>表达式的所有分支。这意味着:</p><ul class=""><li id="c4fd" class="lt lu hu it b iu iv iy iz jc lv jg lw jk lx jo ly lz ma mb dt translated">如果您忘记处理一个案例(比如有8个reps的<code class="eh lp lq lr lg b">Muscle-up</code>),那么您会在编译时得到一个错误。</li><li id="2d8d" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo ly lz ma mb dt translated">如果你不小心打错了任何一个case(比如说<code class="eh lp lq lr lg b">Psuh-up</code>)，你会在编译时得到一个错误。不错吧。</li></ul><h1 id="0343" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">3.边缘案例</h1><p id="da70" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">我们还没有完成类型。</p><p id="52ad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">即使对我这样一个在多年编写需求规范后来到开发人员世界的人来说，也理解边缘案例的重要性，有时很难不在代码中忘记它们。value为<code class="eh lp lq lr lg b">undefined</code>或者json格式不正确或者http请求超时怎么办？</p><p id="6605" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Elm通过引入Maybe、Result和Task类型来解决这个问题，这些类型是我们已经熟悉的Union类型的特例。</p><p id="a29b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您有可选字段，您可能会使用Maybe:</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="af8c" class="lk kc hu lg b fv ll lm l ln lo">type alias Sportsman =<br/>  { name : String<br/>  , age : Maybe Int<br/>  }</span></pre><p id="0c0b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这意味着<code class="eh lp lq lr lg b">age</code>字段可以表示两个值之一:<code class="eh lp lq lr lg b">Nothing</code>或<code class="eh lp lq lr lg b">Just Int</code>—第一个为空，第二个为非空值。因为它是联合类型，任何时候你将这个变量作为参数传递，你都被迫使用<code class="eh lp lq lr lg b">case</code>表达式并处理所有的变化，所以你不能避免处理空/未定义的情况:</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="67ae" class="lk kc hu lg b fv ll lm l ln lo">getReps : Sportsman -&gt; Maybe Int<br/>getReps sportsman =<br/>  case sportsman.age of<br/>    Nothing -&gt;<br/>      Nothing<br/><br/>    Just age -&gt;<br/>      Just 12</span></pre><p id="36e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">相同的方法用于<code class="eh lp lq lr lg b">Result</code>和<code class="eh lp lq lr lg b">Task</code>类型，但是<code class="eh lp lq lr lg b">Task</code>用于同步操作，如解析json，而<code class="eh lp lq lr lg b">Result</code>用于异步操作，如html请求。它们都可以以下列值之一结束:<code class="eh lp lq lr lg b">Success</code>表示成功的情况，<code class="eh lp lq lr lg b">Failure</code>表示错误的情况，和<code class="eh lp lq lr lg b">Maybe</code>一样，我们总是被迫处理这两种情况。</p><h1 id="6d04" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">4.包装分发</h1><p id="ac5c" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">静态类型的另一个结果是自动强制版本控制。</p><p id="790a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这意味着，如果我们创建了一个库，并希望与他人共享，我们不必每次更新我们的包时都考虑它的版本号。榆树会帮我们做的。</p><p id="326b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从最初的版本1.0.0开始，它将比较我们的软件包的每个后续版本的代码变化，并创建新的版本号，该版本号最准确地反映了我们所做的更改。🌟</p><h1 id="de48" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">5.Redux</h1><p id="8fb6" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">Redux是当今Javascript中一个众所周知的模式，起源于Elm。你可以在<a class="ae mh" href="https://github.com/reactjs/redux" rel="noopener ugc nofollow" target="_blank"> React </a>和<a class="ae mh" href="https://github.com/ngrx/store" rel="noopener ugc nofollow" target="_blank"> Angular </a>中找到它，最近我甚至在一个没有任何现代MV*框架的jQuery项目中使用了它。</p><p id="03c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个想法是你有一个单一的信任点，称为<code class="eh lp lq lr lg b">Model</code> (Elm)或状态(React)或存储(Angular)，你有一个接口来更新它。在Elm中我们称这个接口为<code class="eh lp lq lr lg b">Update</code>(在Javascript世界中是Reducer)。</p><p id="8585" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以每次我们想改变<code class="eh lp lq lr lg b">Model</code>时，我们就调用<code class="eh lp lq lr lg b">Update</code>函数。</p><p id="cd60" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">更新函数获取当前的<code class="eh lp lq lr lg b">Model</code>和<code class="eh lp lq lr lg b">Msg</code>(动作)作为参数，并返回新的<code class="eh lp lq lr lg b">Model</code>。</p><p id="c3d2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最近我们使用<code class="eh lp lq lr lg b">Model</code>来更新我们的视图，如果我们谈论网站的话，简单来说就是<code class="eh lp lq lr lg b">Html</code>，我们通过调用以自己命名的函数<code class="eh lp lq lr lg b">View</code>来完成。</p><p id="ab8e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">看起来是这样的:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff mi"><img src="../Images/e278dcdaffc402b27e1913499e4b1ee9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*3khpxkrbSfQD-R9j-xu1vQ.png"/></div><figcaption class="mj mk fg fe ff ml mm bd b be z ek">Elm architecture</figcaption></figure><p id="926d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为什么它很酷？</p><h1 id="ddc7" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">6.质量保证和支持</h1><p id="2ae4" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">首先，问答变得简单多了。</p><p id="524d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们已经知道Elm是一种函数式语言，这意味着它为我们提供了两种功能保证:</p><ul class=""><li id="62fe" class="lt lu hu it b iu iv iy iz jc lv jg lw jk lx jo ly lz ma mb dt translated">给定相同的参数值，所有函数总是返回相同的结果</li><li id="c541" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo ly lz ma mb dt translated">所有的函数都不会产生副作用，也就是说，不会改变它们自身范围之外的任何东西</li></ul><p id="c01a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">基本上这意味着有了一个<code class="eh lp lq lr lg b">Update</code>函数调用的列表，我们总是可以重新运行它们，并且作为重新运行的结果，将总是得到相同的<code class="eh lp lq lr lg b">Model</code>。为什么？因为没有人能从外面改变我们的<code class="eh lp lq lr lg b">Model</code>(记得吗？没有副作用)并且因为如果用相同的参数调用我们的<code class="eh lp lq lr lg b">Update</code>函数，它总是返回相同的结果。</p><p id="795d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这意味着，任何时候你的QA工程师发现一个bug，她都会把<code class="eh lp lq lr lg b">Update</code>函数调用的日志发送给你(它被无声地记录下来),而不需要手工记录所有的步骤。您无需手动重现所有步骤，只需将其导入您的应用程序，就可以立即在屏幕上看到错误，并可以在操作历史中来回移动，以查看是哪一系列用户操作导致了错误。🌟🌟</p><h1 id="d2d0" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">6.惰性装载</h1><p id="e410" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">使用redux的第二个结果是延迟加载。</p><p id="256e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">与jQuery相比，我喜欢现代javascript框架的一点是它们是声明性的。你没有在程序中说明如何操作DOM——添加、删除、隐藏等等。您只需描述html的初始和最终状态——它在不同情况下应该是什么样子，框架会处理(通常使用虚拟DOM)更新页面所需的一切，使它看起来像您希望的那样。</p><p id="98c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">榆树也一样。您只需定义<code class="eh lp lq lr lg b">View</code>函数，描述如何根据当前的<code class="eh lp lq lr lg b">Model</code>渲染html。然后当<code class="eh lp lq lr lg b">Model</code>改变时，你的<code class="eh lp lq lr lg b">View</code>函数相应地更新DOM，比较当前和以前的状态，并进行相应的DOM操作。</p><p id="db38" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在有趣的事情是:如果只有一小部分<code class="eh lp lq lr lg b">Model</code>被更新，而其余部分保持不变会怎样？重新计算和比较整个DOM有意义吗？肯定不会。</p><p id="e307" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们将视图函数分成几个部分，一个函数呈现页眉，另一个呈现页脚，等等，那么由于第一个函数保证(给定相同的参数值，总是返回相同的结果)，我们可以跳过输入没有改变的函数。</p><p id="19ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们只是在函数前面放了<code class="eh lp lq lr lg b">lazy</code>关键字:</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="c435" class="lk kc hu lg b fv ll lm l ln lo">viewHeader: String -&gt; <!-- -->Html Msg<br/>viewHeader name =<br/>    ...some code</span><span id="3792" class="lk kc hu lg b fv ls lm l ln lo">view : Model -&gt; Html Msg<br/>view model = <br/>    <strong class="lg hv">lazy</strong> viewHeader model.loggedUser.name<br/>    ...other code</span></pre><p id="a57e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里我们有一个显示登录用户名的标题。一旦模型中的某些东西改变了(用户向下滚动，新的内容被加载)，我们不希望重新计算DOM的头部分，因为它基本上和以前一样。但是我们想更新内容部分，因为用户滚动了它。这就是<code class="eh lp lq lr lg b">lazy</code>为我们做的——Elm将检查viewHeader输入是否被更改，并完全跳过这一部分，但将呈现其余部分。这为我们节省了一些CPU资源，并使渲染速度更快。</p><h1 id="dbd0" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">7.不变</h1><p id="2c72" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">这引出了Elm的另一个重要概念，即<em class="le">不变性</em>。在前面的例子中，我们将<code class="eh lp lq lr lg b">String</code>作为头函数的输入，但是如果我们有更复杂的东西——<code class="eh lp lq lr lg b">Object</code>呢？</p><p id="dab7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们想比较两个输入对象(新的和旧的)该怎么办？然后，我们必须深入他们的字段层次结构，并逐个比较字段。这耗费时间和资源。</p><p id="1dfd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一方面，<em class="le">不变性</em>要求我们每次修改对象时都要创建新的对象，比较就像比较两个引用一样简单，速度快得惊人。因为如果引用指向同一个对象，那么它就是同一个对象，如果不是，那么这就是两个不同的对象。酷毙了。现在，延迟加载更有意义了。</p><h1 id="8676" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">8.甚至更快</h1><p id="aa00" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">但是我们可以做得更快。</p><p id="0cc1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们都知道，典型的浏览器每秒执行60次重画，因为这是我们的眼睛感知视觉信息的方式。没有必要经常重画，因为我们不会改善任何网站的外观和感觉，而是浪费设备资源。</p><p id="ea7c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同时，我们希望除了重画之外的其他操作能够在正常模式下工作，无论是http请求还是后台的一些复杂计算。</p><p id="2423" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么我们如何在Elm中实现这一点呢？</p><p id="9851" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">实际上我们什么都不用做。它是内置的。Elm使用<code class="eh lp lq lr lg b">requestAnimationFrame</code>来同步视图计算和浏览器重画。这意味着呈现html的视图函数将不会被调用超过每秒60次，并且它节省了时间、CPU资源和移动设备电池。</p><p id="bd3f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以在Elm中这样做的主要原因是应用于<code class="eh lp lq lr lg b">View</code>函数的第二个函数保证——它没有任何副作用，所以它唯一改变的是html。这意味着它不能更新<code class="eh lp lq lr lg b">Model</code>。虽然我们每秒钟只调用<code class="eh lp lq lr lg b">View</code>函数60次，但我们的<code class="eh lp lq lr lg b">Model</code>仍然可以实时更新，没有任何延迟。这就是纯函数的纯粹性。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mn"><img src="../Images/8296d68a50bf32d84338389b734852c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3CT1cdoZFvt1iJJ2raHzMw.png"/></div></div></figure><h1 id="bad5" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">9.模糊测试</h1><p id="1d6f" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">正如我们已经看到的，Elm花费了大量的精力来防止我们的应用程序出错，所以它所使用的测试框架也相当复杂。</p><p id="acfc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我很兴奋的一个特性是<em class="le">模糊测试</em>，它将很快出现在<a class="ae mh" href="https://www.npmjs.com/package/mocha-testcase#fuzzcount-coming-soon" rel="noopener ugc nofollow" target="_blank">摩卡</a>中。</p><p id="97bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">背后的想法是用随机生成的输入多次运行测试用例。酷的部分是所有的边缘情况，如零，空值或负值，保证至少检查一次，您也可以设置一些范围及其概率，以确保最重要的情况比其他情况更频繁地测试。</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="ba82" class="lk kc hu lg b fv ll lm l ln lo">Fuzz.frequency<br/>[ ( 1, Fuzz.intRange -100 -1 )<br/>, ( 3, Fuzz.intRange 1 100 )<br/>]</span></pre><p id="e9d4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这可以节省大量的手动测试编写时间，但是有一个警告，测试执行时间可能会明显增加。</p><h1 id="e9e8" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">结论</h1><p id="5ac2" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">那么一旦我们知道了所有这些很酷的东西，我们如何在我们正常的Javascript生活中使用它们呢？</p><p id="5415" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，使用静态类型——Typescript或Flow可能是很好的解决方案。Typescript允许您在同一个代码库中将它与javascript混合，这意味着您可以在不破坏遗留代码的情况下逐渐将项目转换为静态类型。它还结合VSCode提供了强大的智能感知支持。</p><p id="0c4a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第二，在适当的情况下使用功能方法(状态管理、渲染等)。Redux库就是一个很好的例子。</p><p id="d8bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第三，借助像<a class="ae mh" href="https://github.com/swannodette/mori" rel="noopener ugc nofollow" target="_blank"> Mori </a>或<a class="ae mh" href="https://github.com/facebook/immutable-js/" rel="noopener ugc nofollow" target="_blank"> immutable.js </a>这样的现成库，使用不变性来改进变更检测并提高应用程序性能。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff mo"><img src="../Images/85cd6c1181d33e9bb22f509dd122e951.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*HG3lpSgXeVL80hi_nPgv5w.png"/></div></figure><div class="jq jr js jt fq ab cb"><figure class="mp ju mq mr ms mt mu paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mp ju mq mr ms mt mu paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mp ju mq mr ms mt mu paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mv mw mx"><p id="f922" class="ir is le it b iu iv iw ix iy iz ja jb my jd je jf mz jh ji jj na jl jm jn jo hn dt translated"><a class="ae mh" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae mh" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae mh" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae mh" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is le it b iu iv iw ix iy iz ja jb my jd je jf mz jh ji jj na jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae mh" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae mh" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff nb"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>