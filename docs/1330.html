<html>
<head>
<title>Asynchronous Server side rendering with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React的异步服务器端渲染</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/asynchronous-server-side-rendering-with-react-3860c05f8a5e?source=collection_archive---------1-----------------------#2016-10-13">https://medium.com/hackernoon/asynchronous-server-side-rendering-with-react-3860c05f8a5e?source=collection_archive---------1-----------------------#2016-10-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir is it"><p id="7084" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">我会尽量简短:这篇文章将介绍React应用程序中异步服务器端呈现的实现。我将使用React-Router、Mobx和Koa。应用程序代码过于简化，应该是最小的——这只是一个演示。</p></blockquote><h2 id="7d14" class="jt ju hu bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dt translated">为什么这是一件事？</h2><p id="3a86" class="pw-post-body-paragraph iu iv hu ix b iy kr ja jb jc ks je jf ke kt ji jj ki ku jm jn km kv jq jr js hn dt translated">React和React-路由器自带开箱即用的服务器端渲染。不幸的是，它们不支持异步渲染。这意味着您的路径将在服务器上处理，并且您的视图将被渲染，但是如果您需要加载任何不在服务器上的数据(例如，来自数据库)，则在服务器进行渲染时这些数据将不可用。</p><h2 id="6a5f" class="jt ju hu bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dt translated">什么时候需要这个？</h2><p id="7b1f" class="pw-post-body-paragraph iu iv hu ix b iy kr ja jb jc ks je jf ke kt ji jj ki ku jm jn km kv jq jr js hn dt translated">每当您的应用程序在页面最初加载之前需要一些动态内容(例如来自API的数据)时。在我们的例子中，我们将有一个显示漫画人物信息的页面。这些信息来自维基百科的API。如果该页面是在脸书上共享的，脸书爬虫会期望关于该角色的数据出现在它从服务器得到的初始响应中。如果动态数据只呈现在客户端——它将从我们的脸书邮报中消失。</p><figure class="kx ky kz la fq lb fe ff paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="fe ff kw"><img src="../Images/fe8dca83b2b2a93f9a1b4403a7d3fab7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ptugCpo9cwiNyCoqRBjEgw.jpeg"/></div></div><figcaption class="li lj fg fe ff lk ll bd b be z ek">Synchronous Rendering ;)</figcaption></figure><h1 id="bff5" class="lm ju hu bd jv ln lo lp jz lq lr ls kd lt lu lv kh lw lx ly kl lz ma mb kp mc dt translated">让我们开始吧</h1><blockquote class="ir is it"><p id="062e" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">你可以在<a class="ae md" href="https://github.com/avnersorek/react-async-server-side-rendering" rel="noopener ugc nofollow" target="_blank">https://github . com/avnersorek/react-async-server-side-rendering</a>中找到所有这些代码。我将包含一些代码片段，但是我建议使用到存储库的链接来获得更好的视图。</p></blockquote><p id="2ec3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ke jh ji jj ki jl jm jn km jp jq jr js hn dt translated">我们的示例应用程序将有两个视图——根视图('/')显示斯坦·李创作的漫画人物列表，另一个视图('/characters/:id ')显示单个人物的维基百科摘要。让我们看看当我们请求一个特定的字符时会发生什么:</p><h2 id="37d7" class="jt ju hu bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dt translated">第一站:React-路由器</h2><p id="d1e7" class="pw-post-body-paragraph iu iv hu ix b iy kr ja jb jc ks je jf ke kt ji jj ki ku jm jn km kv jq jr js hn dt translated">我们在流程中遇到的第一个地方是<a class="ae md" href="https://github.com/avnersorek/react-async-server-side-rendering/blob/master/src/app.server.js#L10" rel="noopener ugc nofollow" target="_blank">src/app . server . js # render app</a>。我们称<em class="iw"> matchRoutes — </em>只是React-Router的<em class="iw"> match </em>方法包装在一个承诺中(回调是<em class="iw"> so </em> 2014)。我们让React-Router施展它的魔法——它会根据路线找到需要渲染的组件。我们将获得一个<em class="iw"> props </em>对象，其中包含将要呈现的内容的信息。</p><h2 id="4b8c" class="jt ju hu bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dt translated">在服务器上设置应用程序</h2><p id="2ca2" class="pw-post-body-paragraph iu iv hu ix b iy kr ja jb jc ks je jf ke kt ji jj ki ku jm jn km kv jq jr js hn dt translated">props对象转到<a class="ae md" href="https://github.com/avnersorek/react-async-server-side-rendering/blob/master/src/app.server.js#L34" rel="noopener ugc nofollow" target="_blank"> initAndRender </a>方法。让我们来分解一下:</p><pre class="kx ky kz la fq me mf mg mh aw mi dt"><span id="232f" class="jt ju hu mf b fv mj mk l ml mm">function* initAndRender(props) {  <br/>  const appStore = yield initStore(props);<br/>  const initialState = serializeStore(appStore);<br/>  const app = shared.injectStores(&lt;RouterContext {...props} /&gt;, appStore);<br/>  const componentHTML = renderToString(app);<br/>  return renderIndex(componentHTML, initialState);<br/>}</span></pre><h2 id="f1fa" class="jt ju hu bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dt translated">initStore(道具)</h2><pre class="kx ky kz la fq me mf mg mh aw mi dt"><span id="adc2" class="jt ju hu mf b fv mj mk l ml mm">function* initStore(props) {<br/>  const appStore = new AppStore();</span><span id="2a49" class="jt ju hu mf b fv mn mk l ml mm">  yield props.components<br/>    .filter(Boolean)<br/>    .map(component =&gt; component.wrappedComponent || component)<br/>    .filter(component =&gt; component.preServerRender)<br/>    .map(component =&gt; component.preServerRender(appStore, props.params));</span><span id="954f" class="jt ju hu mf b fv mn mk l ml mm">  return appStore;<br/>}</span></pre><p id="c0ad" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ke jh ji jj ki jl jm jn km jp jq jr js hn dt translated">这被称为<em class="iw"> yield </em>,因为——正如这个帖子的名字所暗示的——这将是一个异步操作。这将创建一个新的<em class="iw">应用商店</em>对象——商店在这个阶段是空的。然后我们将检查道具对象中的组件。这些是React-Router发现需要渲染的组件(<em class="iw">它们是组件的类而不是实例</em>)。我们将在每个组件上调用静态方法<em class="iw">preserver render</em>(<em class="iw">这是我编的——不是内置的React组件生命周期方法</em>)。这是每个组件在服务器上呈现之前说明它需要什么的地方。我们在<a class="ae md" href="https://github.com/avnersorek/react-async-server-side-rendering/blob/master/src/components/Character.jsx#L7" rel="noopener ugc nofollow" target="_blank">人物组件</a>上看一下:</p><pre class="kx ky kz la fq me mf mg mh aw mi dt"><span id="a17e" class="jt ju hu mf b fv mj mk l ml mm">static preServerRender(appStore, params) {<br/>  return appStore.loadCharacter(params.pageId);  <br/>}</span></pre><p id="0cf4" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ke jh ji jj ki jl jm jn km jp jq jr js hn dt translated">因此，角色组件需要我们的<em class="iw"> appStore </em>在渲染之前加载角色。我们还得到路线参数，所以我们知道使用哪个字符ID。这个方法需要返回一个承诺，所以我们会知道它什么时候完成加载资源。在幕后，这将对维基百科的API执行一个GET请求。</p><h1 id="ec5f" class="lm ju hu bd jv ln lo lp jz lq lr ls kd lt lu lv kh lw lx ly kl lz ma mb kp mc dt translated">从现在开始同步</h1><p id="c3ba" class="pw-post-body-paragraph iu iv hu ix b iy kr ja jb jc ks je jf ke kt ji jj ki ku jm jn km kv jq jr js hn dt translated">就是这样！这是整个异步的东西。我将很快介绍其余部分，但这是“标准”的React服务器端渲染:</p><pre class="kx ky kz la fq me mf mg mh aw mi dt"><span id="9593" class="jt ju hu mf b fv mj mk l ml mm">const initialState = serializeStore(appStore);</span></pre><p id="3ad7" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ke jh ji jj ki jl jm jn km jp jq jr js hn dt translated">将序列化状态。为了让我们的客户端应用程序以服务器结束时的状态开始，它需要被序列化为JSON并植入到服务器发送的响应中。那个<a class="ae md" href="https://github.com/avnersorek/react-async-server-side-rendering/blob/master/src/app.server.js#L67" rel="noopener ugc nofollow" target="_blank">发生在这里</a>。接下来，我们渲染视图:</p><pre class="kx ky kz la fq me mf mg mh aw mi dt"><span id="3863" class="jt ju hu mf b fv mj mk l ml mm">const app = shared.injectStores(&lt;RouterContext {...props} /&gt;, appStore);<br/>const componentHTML = renderToString(app);</span></pre><p id="f7bf" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ke jh ji jj ki jl jm jn km jp jq jr js hn dt translated">将状态发送到客户端应用程序是不够的。我们还希望我们的初始视图(HTML)根据这种状态呈现。<a class="ae md" href="https://github.com/avnersorek/react-async-server-side-rendering/blob/master/src/app.shared.js#L5" rel="noopener ugc nofollow" target="_blank">s<em class="iw">hared . injectstores</em></a><em class="iw"/>只是客户端和服务器端共享的一些代码，利用Mobx的提供者将appStore注入到我们的组件实例中。renderToString 只是React-DOM做它该做的事情。</p><pre class="kx ky kz la fq me mf mg mh aw mi dt"><span id="1b14" class="jt ju hu mf b fv mj mk l ml mm">return renderIndex(componentHTML, initialState);</span></pre><p id="fa76" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ke jh ji jj ki jl jm jn km jp jq jr js hn dt translated">现在，我们获取渲染视图(HTML)和序列化状态(JSON)，并将它们注入我们的index.html(T25)。如果你有一个更大的index.html文件，我推荐使用ejs或jade来完成这一部分。</p></div><div class="ab cl mo mp hc mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hn ho hp hq hr"><h1 id="34fa" class="lm ju hu bd jv ln mv lp jz lq mw ls kd lt mx lv kh lw my ly kl lz mz mb kp mc dt translated">别忘了客户</h1><p id="0a92" class="pw-post-body-paragraph iu iv hu ix b iy kr ja jb jc ks je jf ke kt ji jj ki ku jm jn km kv jq jr js hn dt translated">在我们的初始渲染之后，客户端应用程序接管。我们需要在客户端用初始状态初始化我们的<em class="iw">app store</em>—<a class="ae md" href="https://github.com/avnersorek/react-async-server-side-rendering/blob/master/src/app.client.js#L9" rel="noopener ugc nofollow" target="_blank">这发生在src/app.client.js </a>中:</p><pre class="kx ky kz la fq me mf mg mh aw mi dt"><span id="2a93" class="jt ju hu mf b fv mj mk l ml mm">const initialState = global.window.__INITIAL_STATE__;<br/>const appStore = new AppStore(initialState);</span></pre><p id="4691" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ke jh ji jj ki jl jm jn km jp jq jr js hn dt translated">React会知道从那里拿(那其实很神奇)。如果您从服务器获得的状态和HTML不一致，您甚至会在控制台中得到警告。</p><h2 id="cb5c" class="jt ju hu bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dt translated">从现在开始的客户</h2><p id="571e" class="pw-post-body-paragraph iu iv hu ix b iy kr ja jb jc ks je jf ke kt ji jj ki ku jm jn km kv jq jr js hn dt translated">用户与应用程序的其余交互将在客户端完成。<a class="ae md" href="https://github.com/avnersorek/react-async-server-side-rendering/blob/master/src/components/Character.jsx#L11" rel="noopener ugc nofollow" target="_blank">角色组件将使用componentidmount</a>React生命周期挂钩来获取下一个角色:</p><pre class="kx ky kz la fq me mf mg mh aw mi dt"><span id="334b" class="jt ju hu mf b fv mj mk l ml mm">componentDidMount() {<br/>  const { appStore, params } = this.props;<br/>  appStore.loadCharacter(params.pageId);<br/>}</span></pre><p id="c558" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ke jh ji jj ki jl jm jn km jp jq jr js hn dt translated">这与渲染并行发生，所以不要忘记<a class="ae md" href="https://github.com/avnersorek/react-async-server-side-rendering/blob/master/src/components/Character.jsx#L29" rel="noopener ugc nofollow" target="_blank">支持组件中的加载状态</a>。</p></div><div class="ab cl mo mp hc mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hn ho hp hq hr"><blockquote class="na"><p id="1144" class="nb nc hu bd nd ne nf ng nh ni nj js ek translated">就是这样。我真的没有深究，我试着让这篇文章简短。因此，如果你有任何问题，请在这里发表评论。谢谢！</p></blockquote></div><div class="ab cl mo mp hc mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hn ho hp hq hr"><blockquote class="ir is it"><p id="e370" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">编辑:<br/> <em class="hu">这适用于嵌套路线，但不适用于嵌套在组件内的组件。这是因为只有当调用</em> Component.render <em class="hu">时，这些才会发挥作用。这可以通过两次渲染来处理，如</em><a class="ae md" href="https://www.npmjs.com/package/react-async-render" rel="noopener ugc nofollow" target="_blank"><em class="hu">react-async-render</em></a><em class="hu">中所述。</em></p></blockquote><div class="kx ky kz la fq ab cb"><figure class="nk lb nl nm nn no np paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nk lb nl nm nn no np paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nk lb nl nm nn no np paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ir is it"><p id="f922" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><a class="ae md" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae md" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae md" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae md" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae md" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae md" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kx ky kz la fq lb fe ff paragraph-image"><a href="https://goo.gl/Ahtev1"><div class="fe ff nq"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></a></figure></div></div>    
</body>
</html>