<html>
<head>
<title>IPython Or Jupyter?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">IPython还是Jupyter？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/ipython-or-jupyter-10a9fb82682b?source=collection_archive---------6-----------------------#2017-03-06">https://medium.com/hackernoon/ipython-or-jupyter-10a9fb82682b?source=collection_archive---------6-----------------------#2017-03-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="14af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">原贴于:</em><a class="ae jq" href="https://www.datacamp.com/community/blog/ipython-jupyter" rel="noopener ugc nofollow" target="_blank"><em class="jp">【https://www.datacamp.com/community/blog/ipython-jupyter】</em></a></p><p id="e1cf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于学习者和更高级的数据科学家来说，Jupyter笔记本是最受欢迎的<a class="ae jq" href="https://hackernoon.com/tagged/data-science" rel="noopener ugc nofollow" target="_blank">数据科学</a> <a class="ae jq" href="https://hackernoon.com/tagged/tools" rel="noopener ugc nofollow" target="_blank">工具</a>之一:交互式环境不仅是教和学以及与同行分享您的工作的理想选择，还能确保可重复的研究。然而，当您发现如何使用这款笔记本时，您会经常碰到IPython。</p><p id="af20" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在某些情况下，这两者似乎是同义词，你会同意我说的，当你想深入挖掘时，这是非常令人困惑的:magics是Jupyter还是IPython的一部分？保存和加载笔记本是IPython还是Jupyter的功能？</p><p id="8592" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以继续提问。</p><p id="f976" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">今天的博客文章旨在更明确地说明两者之间的一些核心差异，不仅从两者的起源出发来解释两者之间的关系，而且还涵盖了两者之间的一些特定特征，以便您更容易区分两者！</p><p id="d7ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还可以考虑阅读DataCamp的<a class="ae jq" href="https://www.datacamp.com/community/tutorials/tutorial-jupyter-notebook" rel="noopener ugc nofollow" target="_blank">Jupyter笔记本权威指南</a>以获得提示和技巧、最佳实践、示例等等。</p><h1 id="aeac" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated">IPython &amp; Jupyter笔记本的起源</h1><p id="ebf7" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">为了充分理解Jupyter笔记本是什么以及它与IPython有何不同，首先阅读一下这两者如何融入计算笔记本的历史和未来可能会很有意思。</p><h2 id="9c04" class="ku js hu bd jt kv kw kx jx ky kz la kb jc lb lc kf jg ld le kj jk lf lg kn lh dt translated">计算笔记本的开始:MATLAB、Mathematica和Maple</h2><p id="774a" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">在20世纪80年代中期，MATLAB由Jack Little、Steve Bangert和Cleve Moler创建的MathWorks发布。</p><p id="2e59" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们回到20世纪80年代末，确切地说是1987年。西奥多·格雷开始开发Mathematica笔记本前端，一年后，它向公众发布。GUI允许交互式创建和编辑笔记本文档，这些文档包含印刷精美的程序代码、格式化文本和一大堆其他内容，如排版数学、图形、GUI组件、表格和声音。标准的文字处理功能已经具备，比如实时多语言拼写检查。您可以在幻灯片放映环境中输出文档进行演示。</p><p id="0538" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当你观察这些笔记本的结构时，你会立刻注意到它们依赖于单元格的层次结构，这些单元格允许对文档进行概述和分段，这也是你现在在Jupyter笔记本中可以找到的。</p><p id="971e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样在20世纪80年代末，1989年，Maple推出了他们的第一款笔记本风格的GUI。它包含在Macintosh 4.3版中。X11和Windows的新界面版本出现在1990年。</p><p id="9184" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些笔记本都将成为其他人开发“数据科学笔记本”的灵感。</p><h2 id="28b8" class="ku js hu bd jt kv kw kx jx ky kz la kb jc lb lc kf jg ld le kj jk lf lg kn lh dt translated">数据科学笔记本的兴起</h2><p id="1d21" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">在现在广为人知的交互式数据科学之间有许多计算笔记本。本节将重点介绍在数据科学笔记本电脑的崛起中做出最显著贡献的笔记本电脑。</p><p id="6987" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">圣人笔记本</strong></p><p id="e269" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">作为一个基于浏览器的系统，Sage notebook最初是在2000年代中期发布的，然后在2007年，发布了一个更强大的新版本，有用户帐户，可以用来公开文件。它类似于谷歌文档的用户界面设计，因为Sage笔记本的布局是基于谷歌笔记本的布局。</p><p id="7167" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Sage笔记本的创建者已经证实他们是Mathematica笔记本和Maple工作表的狂热用户。当您考虑Sage笔记本的开发时，其他重要的动机或驱动因素是这样的事实:开发人员与IPython背后的团队有着密切的联系，他们经历了IPython GUI的失败尝试，以及“AJAX”= web应用程序的兴起，这种应用程序不需要用户每次做某件事情时都刷新整个页面。</p><p id="ce16" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">伊普森&amp;朱庇特</strong></p><p id="a6ce" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2001年末，也就是吉多·范·罗苏姆在荷兰国家数学和计算机科学研究所开始研究Python二十年后，费尔南多·佩雷斯开始开发IPython。该项目深受Mathematica笔记本和Maple工作表的影响，就像Sage笔记本和随后的许多其他项目一样。</p><p id="5bda" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2005年，罗伯特·克恩和费尔南多·佩雷斯都试图建立一个笔记本电脑系统。不幸的是，原型从来没有变得完全可用。</p><p id="5bed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一晃两年过去了:团队一直在工作，在2007年，他们制定了另一个实现笔记本型系统的尝试。到2010年10月，有了一个网络笔记本的原型，在2011年夏天，这个原型被合并，并在2011年12月21日发布了0.12。在随后的几年中，该团队获得了奖项，如2013年3月23日的费尔南多·佩雷斯自由软件进步奖和Jolt生产力奖，以及来自阿尔弗雷德·P·斯隆基金会的资助等。</p><p id="bfa7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，在2014年，Project Jupyter作为IPython的一个衍生项目启动。</p><p id="1f84" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">拆分前IPython的最后一个版本包含了交互shell、笔记本服务器、Qt控制台等。这个项目很大，工具越来越成为越来越多不同的项目，而这些项目恰好属于同一个项目。Jupyter项目启动后，IPython项目的语言无关部分，比如笔记本格式、消息协议、Qt控制台、笔记本web应用等。被投入到朱庇特项目中。</p><p id="4eca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是所谓的<a class="ae jq" href="http://blog.jupyter.org/2015/04/15/the-big-split/" rel="noopener ugc nofollow" target="_blank">大分裂</a>。</p><p id="0198" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">IPython现在只有两个角色要完成:作为Jupyter笔记本的Python后端，也称为内核，以及一个交互式Python shell。但这还不是全部:在IPython生态系统中，您还会发现一个并行计算框架。稍后您将会读到更多相关内容！</p><p id="43e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就像IPython一样，Project Jupyter实际上是一系列项目的名称:它包含的三个应用程序是笔记本本身，一个控制台和一个Qt控制台，但也有一些子项目，如支持笔记本部署的Jupyterhub，<code class="eh li lj lk ll b">nbgrader</code>用于教育目的，等等。你可以在这里看到Jupyter建筑的概述<a class="ae jq" href="https://jupyter.readthedocs.io/en/latest/architecture/visual_overview.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="040e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，正是这个项目的发展解释了许多Pythonistas在谈到IPython和Jupyter时的困惑:由于一个来自另一个(最近)，有些人仍然难以为概念采用正确的名称。但是更复杂的因素可能是进化:由于一个来自另一个，IPython和Jupyter笔记本功能之间有相当多的重叠，有时很难区分！</p><p id="ee0b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如何区分这两者将在本文的下一部分变得清晰。</p><p id="5fa0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你想知道更多关于IPython发展的细节，看看<a class="ae jq" href="http://blog.fperez.org/2012/01/ipython-notebook-historical.html" rel="noopener ugc nofollow" target="_blank">费尔南多·佩雷斯</a>和<a class="ae jq" href="http://wstein.org/talks/2016-06-sage-bp/bp.pdf" rel="noopener ugc nofollow" target="_blank">威廉·斯坦</a>关于他们笔记本历史的个人描述。</p><p id="9a89" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> R笔记本</strong></p><p id="9d30" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">R Markdown和Jupyter笔记本共享可复制工作流的交付，将代码、输出和文本编织在一个文档中，支持交互式小部件和多种格式的输出。</p><p id="89f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，两者也有所不同:前者侧重于可再现的批处理执行、纯文本表示、版本控制、产品输出，并提供与R脚本相同的编辑器和工具。后者侧重于代码内联输出、跨会话缓存输出、共享代码和在单个文件中输出。笔记本强调交互式执行模式。它们不使用纯文本表示，而是使用结构化数据表示，比如JSON。</p><p id="7ca9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这一切解释了RStudio笔记本应用程序的目的:它结合了R Markdown的所有优点和计算笔记本必须提供的好东西。</p><p id="f21d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要了解更多关于如何使用R笔记本以及Jupyter和R Markdown笔记本在笔记本共享、项目管理、版本控制等方面的确切区别，请查看DataCamp的<a class="ae jq" href="https://www.datacamp.com/community/blog/jupyter-notebook-r" rel="noopener ugc nofollow" target="_blank"> Jupyter和R: Notebooks with R </a>帖子。</p><p id="12e2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然，当你进入数据科学领域时，你可以考虑更多的笔记本电脑。近年来，数据科学家和数据科学爱好者找到了许多新的替代品:不仅仅是Beaker Notebook、Apache Zeppelin、Spark Notebook、DataBricks Cloud等。，还包括Rodeo IDE等其他工具，这些工具也使您的数据科学分析具有交互性和可重复性。</p><p id="cb52" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">数据科学笔记本的未来</strong></p><p id="763d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">笔记本电脑似乎会一直存在下去。最近，新一代Jupyter笔记本已经引入社区:JupyterLab。Notebook应用程序不仅支持笔记本，还支持文件管理器、文本编辑器、终端仿真器、运行Jupyter进程的监视器、IPython集群管理器和显示帮助的寻呼机。</p><p id="8e7f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Jupyter Notebook丰富的工具集已经有机地发展起来，并由我们的用户和开发人员的需求所驱动。JupyterLab是支持所有这些工具的下一代架构，但是具有灵活且响应迅速的UI，提供了可以将工具结合在一起的用户控制的布局。</p><p id="b7bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">点击阅读更多关于<a class="ae jq" href="http://blog.jupyter.org/2016/07/14/jupyter-lab-alpha/" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><figure class="ln lo lp lq fq lr fe ff paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="fe ff lm"><img src="../Images/ad3e5dd0897c01fbab1fe3e1f1b194fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iReGY8nxPyihAISD.png"/></div></div></figure><h1 id="2e18" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated">IPython还是Jupyter？</h1><p id="08a3" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">项目的发展和随之而来的“大分裂”是理解两者之间真正差异的基础。但是，由于这两者有着内在的联系，你有时会怀疑什么是什么的一部分。</p><p id="cca3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下一节将介绍IPython生态系统或Jupyter项目的一些特性。</p><p id="dd55" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由您选择正确的答案，并了解每项功能的更多信息！</p><h2 id="0e52" class="ku js hu bd jt kv kw kx jx ky kz la kb jc lb lc kf jg ld le kj jk lf lg kn lh dt translated">核</h2><p id="570d" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">内核是Jupyter笔记本应用程序的一个特性。内核是一个运行和自省用户代码的程序:它提供计算和与前端接口的通信，比如笔记本。Jupyter Notebook应用程序有三个主要内核:IPython、IRkernel和IJulia内核。</p><p id="a7bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为“Jupyter”这个名字实际上是“Julia，Python和R”的简称，所以这并不令人感到意外。作为项目发展的结果，IPython内核由Jupyter团队维护。</p><p id="c169" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，你也可以在Jupyter Notebook应用中运行很多其他语言，比如Scala、JavaScript、Haskell、Ruby等等。那些是社区维护的内核。</p><h2 id="073b" class="ku js hu bd jt kv kw kx jx ky kz la kb jc lb lc kf jg ld le kj jk lf lg kn lh dt translated"><strong class="ak">部署</strong></h2><p id="ff18" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">部署笔记本是您在使用Jupyter笔记本时通常会发现或研究的内容。有相当多的软件包可以帮助您部署笔记本电脑，它们是Jupyter生态系统的一部分。</p><p id="26d0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是其中的一些:</p><ul class=""><li id="a38d" class="ly lz hu it b iu iv iy iz jc ma jg mb jk mc jo md me mf mg dt translated">当你需要一堆Jupyter应用程序和内核作为Docker容器时，将会派上用场。</li><li id="f712" class="ly lz hu it b iu mh iy mi jc mj jg mk jk ml jo md me mf mg dt translated"><code class="eh li lj lk ll b"><a class="ae jq" href="https://ipywidgets.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">ipywidgets</a></code>提供交互式HTML &amp; JavaScript小部件(如滑块、复选框、文本框、图表等。)用于Jupyter架构，该架构将前端控制结合到Jupyter内核。</li><li id="f6c4" class="ly lz hu it b iu mh iy mi jc mj jg mk jk ml jo md me mf mg dt translated"><code class="eh li lj lk ll b"><a class="ae jq" href="https://github.com/jupyter/jupyter-drive" rel="noopener ugc nofollow" target="_blank">jupyter-drive</a></code>允许IPython使用Google Drive进行文件管理。</li><li id="e794" class="ly lz hu it b iu mh iy mi jc mj jg mk jk ml jo md me mf mg dt translated"><code class="eh li lj lk ll b"><a class="ae jq" href="https://github.com/jupyter/jupyter-sphinx-theme" rel="noopener ugc nofollow" target="_blank">jupyter-sphinx-theme</a></code>将Jupyter Sphinx主题添加到您的笔记本中。这将使创建智能和漂亮的文档变得更加容易。</li><li id="3081" class="ly lz hu it b iu mh iy mi jc mj jg mk jk ml jo md me mf mg dt translated"><code class="eh li lj lk ll b">kernel_gateway</code>是一个web服务器，支持不同的机制来生成Jupyter内核并与之通信。查看<a class="ae jq" href="http://jupyter-kernel-gateway.readthedocs.io/en/latest/uses.html" rel="noopener ugc nofollow" target="_blank">这里的</a>来看看这个包可以派上用场的一些用例。</li><li id="3a7b" class="ly lz hu it b iu mh iy mi jc mj jg mk jk ml jo md me mf mg dt translated"><code class="eh li lj lk ll b">nbviewer</code>分享您的笔记本。点击查看画廊<a class="ae jq" href="http://nbviewer.jupyter.org/" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="172c" class="ly lz hu it b iu mh iy mi jc mj jg mk jk ml jo md me mf mg dt translated">使用Docker容器创建临时Jupyter笔记本服务器。在这里亲自尝试一下<a class="ae jq" href="https://try.jupyter.org/" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="7ddd" class="ly lz hu it b iu mh iy mi jc mj jg mk jk ml jo md me mf mg dt translated"><code class="eh li lj lk ll b"><a class="ae jq" href="https://github.com/ipython/traitlets" rel="noopener ugc nofollow" target="_blank">traitlets</a></code>是一个框架，它允许Python类具有带类型检查的属性、动态计算的默认值和‘on change’回调。您还可以将该包用于配置目的，从文件或命令行参数加载值。<code class="eh li lj lk ll b">traitlets</code>为IPython和Jupyter的配置系统以及IPython交互小部件的声明式API提供支持。</li></ul><h2 id="de48" class="ku js hu bd jt kv kw kx jx ky kz la kb jc lb lc kf jg ld le kj jk lf lg kn lh dt translated">系统外壳用法</h2><p id="b98f" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">使用<strong class="it hv">魔法</strong>可以使IPython适应系统外壳的使用:以<code class="eh li lj lk ll b">!</code>开头的行被直接传递给系统外壳。比如<code class="eh li lj lk ll b">!ls</code>会在当前目录下运行<code class="eh li lj lk ll b">ls</code>。您可以使用语法<code class="eh li lj lk ll b">myfiles=!ls</code>将系统命令的结果分配给Python变量。</p><p id="7438" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，如果您想将<code class="eh li lj lk ll b">ls</code>函数的结果明确地打印成一个带有字符串的列表，而不将其赋给变量，请使用两个感叹号(<code class="eh li lj lk ll b">!!ls</code>)或不带赋值的<code class="eh li lj lk ll b">%sx</code> magic命令。</p><pre class="ln lo lp lq fq mm ll mn mo aw mp dt"><span id="0e8c" class="ku js hu ll b fv mq mr l ms mt"># Assign the result to `ls` <br/>ls = !ls </span><span id="9f30" class="ku js hu ll b fv mu mr l ms mt"># Explicit `ls` <br/>!!ls<br/> <br/># Or with magics <br/>%sx </span><span id="ac31" class="ku js hu ll b fv mu mr l ms mt"># Assign magics result <br/>ls = %sx</span></pre><p id="0569" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意<code class="eh li lj lk ll b">!!</code>命令不能赋给变量，但是魔术的结果(只要它返回值)可以赋给变量。</p><p id="a0bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">IPython还允许您在进行系统调用时扩展Python变量的值:只需用大括号(<code class="eh li lj lk ll b">{}</code>)将变量或表达式括起来。同样，在带有<code class="eh li lj lk ll b">!</code>或<code class="eh li lj lk ll b">!!</code>的shell命令中，任何带有<code class="eh li lj lk ll b">$</code>前缀的Python变量都会被扩展。在下面的代码块中，您将看到您回显了<code class="eh li lj lk ll b">sys</code>变量的<code class="eh li lj lk ll b">argv</code>属性。请注意，您还可以使用<code class="eh li lj lk ll b">$</code> / <code class="eh li lj lk ll b">$$</code>语法来处理来自系统输出的Python变量，稍后您可以使用这些变量来编写进一步的脚本。</p><p id="6d45" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要将文本<code class="eh li lj lk ll b">$</code>传递给shell，请使用双精度<code class="eh li lj lk ll b">$$</code>。如果您想访问shell和环境变量，如<code class="eh li lj lk ll b">$PATH</code>，您将需要这个文字<code class="eh li lj lk ll b">$</code>:</p><pre class="ln lo lp lq fq mm ll mn mo aw mp dt"><span id="ed73" class="ku js hu ll b fv mq mr l ms mt"># Import and initialize <br/>import math <br/>x = 4 </span><span id="1d02" class="ku js hu ll b fv mu mr l ms mt"># System call with variable <br/>!echo {math.factorial(x)} </span><span id="dde2" class="ku js hu ll b fv mu mr l ms mt"># Expand a variable <br/>!echo $sys.argv </span><span id="0a80" class="ku js hu ll b fv mu mr l ms mt"># Use $$ for a literal $ <br/>!echo "A system variable: $$HOME"</span></pre><p id="06c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">点击阅读更多<a class="ae jq" href="http://ipython.readthedocs.io/en/stable/interactive/shell.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="a4c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，除了IPython之外，还有其他内核具有魔力来确保代码行作为shell命令执行！</p><p id="50d4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，您可以为系统命令定义<strong class="it hv">别名</strong>。这些别名基本上是bash命令的快捷方式。一个别名是一个元组:(“showTheDirectory”，“ls”)。运行<code class="eh li lj lk ll b">%alias?</code>获取更多信息！提示:使用<code class="eh li lj lk ll b">%rehashx</code>加载所有的$PATH作为IPython别名。</p><h2 id="5c92" class="ku js hu bd jt kv kw kx jx ky kz la kb jc lb lc kf jg ld le kj jk lf lg kn lh dt translated">魔法？</h2><p id="129d" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">如果你读过DataCamp的<a class="ae jq" href="https://www.datacamp.com/community/tutorials/tutorial-jupyter-notebook" rel="noopener ugc nofollow" target="_blank">Jupyter笔记本权威指南</a>或者你已经和Jupyter合作过，你可能已经知道所谓的“魔法命令”。魔术通常由在底层语言中无效的语法元素和暗示命令的某种单词组成。在幕后，magics函数实际上是Python函数。</p><p id="4467" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可能已经知道，IPython内核使用了<code class="eh li lj lk ll b">%</code>语法元素，因为它在Python中不是有效的一元运算符。然而，以<code class="eh li lj lk ll b">%%</code>开头的行显示了一种单元魔力:在当前执行块中，它们不仅将当前行的其余部分作为参数，还将它们下面的所有行作为参数。细胞魔术实际上可以对它们接收的输入进行任意修改，甚至根本不需要有效的Python代码。它们将整个块作为单个字符串接收。</p><p id="e2d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">魔术是特定于内核的，由内核提供，旨在使您在Jupyter Notebook中的工作和体验更具互动性。魔法命令在特定内核中是否可用取决于内核开发人员和每个内核的内核。你已经看到了:魔法是一个内核特性。</p><p id="0f9d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当您使用Jupyter笔记本IPython(也称为内核)的Python后端时，您可能希望利用以下技巧来获得使您的编程更快、更容易和更具交互性的功能。请注意，列出的这些并不意味着详尽无遗。查看<a class="ae jq" href="http://ipython.readthedocs.io/en/stable/interactive/magics.html" rel="noopener ugc nofollow" target="_blank">这个内置魔法命令列表</a>以获得完整的概述。</p><p id="e404" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">带兵？</strong></p><p id="55bb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">IPython内核的一个主要特性是能够显示作为运行代码单元输出的图形。内核被设计为与<code class="eh li lj lk ll b">matplotlib</code>数据可视化库无缝协作来提供这一功能。要使用它，请使用魔法命令<code class="eh li lj lk ll b">%matplotlib</code>。</p><p id="4135" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，默认情况下，您的图将显示在单独的窗口中。此外，您还可以指定一个后端，如<code class="eh li lj lk ll b">inline</code>或<code class="eh li lj lk ll b">qt</code>，绘图命令的输出将内联显示或通过不同的GUI后端显示。你可以在这里阅读更多信息<a class="ae jq" href="http://ipython.readthedocs.io/en/stable/interactive/plotting.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="802f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">调试？</strong></p><p id="49ff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，每次出现未捕获的异常时，您还可以使用magics调用Python调试器<code class="eh li lj lk ll b">%pdb</code>。这将引导您浏览触发异常的代码部分，从而有可能快速找到bug的来源。</p><p id="7bcc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您还可以使用带有-d选项的<code class="eh li lj lk ll b">%run</code> magic命令在Python调试器的控制下运行脚本。它会自动为您设置初始断点。最后，您还可以使用<code class="eh li lj lk ll b">%debug</code>魔法来更容易地访问调试器。</p><p id="61e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">扩展？</strong></p><p id="3ac4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以使用<code class="eh li lj lk ll b">%load_ext</code>魔法通过模块名加载IPython扩展。IPython扩展是修改外壳行为的Python模块:扩展可以注册魔法、定义变量，并且通常修改用户名称空间以提供在代码单元中使用的新特性。</p><p id="bc09" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是一些例子:</p><ul class=""><li id="9f11" class="ly lz hu it b iu iv iy iz jc ma jg mb jk mc jo md me mf mg dt translated">使用<code class="eh li lj lk ll b">%load_ext oct2py.ipython</code>从Python无缝调用M-files和Octave函数，</li><li id="fbce" class="ly lz hu it b iu mh iy mi jc mj jg mk jk ml jo md me mf mg dt translated">使用<code class="eh li lj lk ll b">%load_ext rpy2.ipython</code>使用一个接口来运行嵌入在Python进程中的R，</li><li id="1044" class="ly lz hu it b iu mh iy mi jc mj jg mk jk ml jo md me mf mg dt translated">使用<code class="eh li lj lk ll b">%load_ext Cython</code>使用Python转C编译器，</li><li id="88e2" class="ly lz hu it b iu mh iy mi jc mj jg mk jk ml jo md me mf mg dt translated">使用<code class="eh li lj lk ll b">sympy.init_printing()</code>自动打印基本对象，以及</li><li id="45ab" class="ly lz hu it b iu mh iy mi jc mj jg mk jk ml jo md me mf mg dt translated">要在交互式会话中使用Fortran，可以使用<code class="eh li lj lk ll b">%load_ext fortranmagic</code>。</li><li id="6459" class="ly lz hu it b iu mh iy mi jc mj jg mk jk ml jo md me mf mg dt translated">…还有很多！您可以创建一个register your own IPython extensions，并在PyPi上注册它们:这也意味着还有许多其他用户定义的扩展和魔术！一个例子是<code class="eh li lj lk ll b"><a class="ae jq" href="https://pypi.org/project/ipython_unittest/" rel="noopener ugc nofollow" target="_blank">ipython_unittest</a></code>，但是也检查这个<a class="ae jq" href="https://github.com/ipython/ipython/wiki/Extensions-Index" rel="noopener ugc nofollow" target="_blank">扩展索引</a>。</li></ul><p id="2273" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您应该关注的另一个扩展是<code class="eh li lj lk ll b"><strong class="it hv">sparkmagic</strong></code>，这是一组通过Livy(Jupyter笔记本中的一个Spark REST服务器)与远程Spark集群交互工作的工具。<code class="eh li lj lk ll b">sparkmagic</code>库提供了一个<code class="eh li lj lk ll b">%%spark</code>魔法，您可以使用它从普通的IPython笔记本上轻松地运行远程Spark集群的代码。</p><pre class="ln lo lp lq fq mm ll mn mo aw mp dt"><span id="2843" class="ku js hu ll b fv mq mr l ms mt"># Load in sparkmagic <br/>%load_ext sparkmagic.magics </span><span id="b2ba" class="ku js hu ll b fv mu mr l ms mt"># Set the endpoint <br/>%manage_spark </span><span id="f67b" class="ku js hu ll b fv mu mr l ms mt"># Ask for help <br/>%spark?</span></pre><p id="fb3c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">点击<a class="ae jq" href="https://github.com/jupyter-incubator/sparkmagic/blob/master/examples/Magics%20in%20IPython%20Kernel.ipynb" rel="noopener ugc nofollow" target="_blank">此处</a>获取更多关于如何利用这些魔法与Spark cluster交互工作的示例。</p><p id="6b58" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，除了<code class="eh li lj lk ll b">%load_ext</code>之外，IPython还有另外两个魔法可以让您在Jupyter笔记本中管理扩展:<code class="eh li lj lk ll b">%reload_ext</code>和<code class="eh li lj lk ll b">%unload_ext</code>分别用于卸载、重新导入和加载扩展以及卸载扩展。</p><p id="3828" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，在其他语言中，神奇命令中的语法元素可能有某种含义。</p><p id="c860" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">R内核，IRKernel，没有魔法系统。例如，为了执行bash命令，您将使用R函数(如<code class="eh li lj lk ll b">system()</code>)来调用OS命令。例如<code class="eh li lj lk ll b">system("head -5 *.csv", intern=TRUE)</code>。请注意，通过包含<code class="eh li lj lk ll b">intern</code>参数，您指定了要将命令的输出捕获为r中的一个字符向量。</p><p id="f430" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样，Julia Kernel <strong class="it hv"> IJulia </strong>也不使用“魔法”。相反，在Julia中，实现相同目标的其他语法更自然，可以在IJulia代码单元之外的环境中工作，并且通常更强大。然而，IJulia内核的开发人员已经确保，无论何时您在IJulia代码单元中输入IPython magic命令，您都会看到一个带有帮助的打印输出，解释如何在Julia中实现类似的效果(如果可能)。</p><p id="98b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">比如IPython的<code class="eh li lj lk ll b">%load</code>在IJulia的类比就是<code class="eh li lj lk ll b">IJulia.load()</code>。</p><p id="458a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一方面，像Scala内核<strong class="it hv"> IScala </strong>这样的内核确实支持神奇的命令，类似于IPython。然而，这套魔术是不同的，因为它必须匹配Scala和JVM的细节。魔术命令由百分号<code class="eh li lj lk ll b">%</code>组成，后跟标识符和魔术的可选输入。一些最著名的魔术是:</p><pre class="ln lo lp lq fq mm ll mn mo aw mp dt"><span id="f4c4" class="ku js hu ll b fv mq mr l ms mt"># Type Information <br/>%type 1 </span><span id="483a" class="ku js hu ll b fv mu mr l ms mt"># Library Management <br/>%libraryDependencies <br/>%update</span></pre><p id="88a7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如您在上面读到的，<code class="eh li lj lk ll b">sparkmagic</code>库还提供了一组Scala和Python内核，允许您自动连接到远程Spark集群，运行代码和SQL查询，管理Livy服务器和Spark作业配置，并生成自动可视化。这不需要任何代码！</p><p id="c90d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，您可以使用<code class="eh li lj lk ll b">%%sql</code>轻松执行SparkSQL查询，或者通过<code class="eh li lj lk ll b">%%info magic</code>访问Spark应用程序信息和日志。</p><p id="5a6f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您正在使用另一个内核，并且您想知道是否可以使用神奇的命令，那么知道有一些内核构建在<a class="ae jq" href="https://github.com/Calysto/metakernel/tree/master/metakernel/magics" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">元内核</strong> </a>项目之上，并且在大多数情况下将使用与您在IPython内核中找到的相同的神奇命令可能会很方便。你可以在这里找到元内核魔法列表。元内核是一个Jupyter/IPython内核模板，它包含了核心的魔法函数。</p><p id="697a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一些例子:</p><p id="de89" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这意味着，例如，当您使用MATLAB内核时，您将拥有以下可用的魔法:</p><pre class="ln lo lp lq fq mm ll mn mo aw mp dt"><span id="f09c" class="ku js hu ll b fv mq mr l ms mt">Available line magics: %cd %connect_info %download %edit %get %help %html %install %install_magic %javascript %kernel %kx %latex %load %ls %lsmagic %magic %parallel %plot %pmap %px %python %reload_magics %restart %run %set %shell %spell </span><span id="083b" class="ku js hu ll b fv mu mr l ms mt">Available cell magics: %%debug %%file %%help %%html %%javascript %%kx %%latex %%processing %%px %%python %%shell %%show %%spell</span></pre><p id="3205" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你看看上面打印的内容，你会发现其中一些神奇的命令看起来非常熟悉。对于那些不太了解魔术的人来说，将上面的块与IPython内核中默认可用的魔术进行比较，您会发现有些魔术是相同的:</p><pre class="ln lo lp lq fq mm ll mn mo aw mp dt"><span id="f079" class="ku js hu ll b fv mq mr l ms mt">Available line magics: %alias %alias_magic %autocall %automagic %autosave %bookmark %cat %cd %clear %colors %config %connect_info %cp %debug %dhist %dirs %doctest_mode %ed %edit %env %gui %hist %history %killbgscripts %ldir %less %lf %lk %ll %load %load_ext %loadpy %logoff %logon %logstart %logstate %logstop %ls %lsmagic %lx %macro %magic %man %matplotlib %mkdir %more %mv %notebook %page %pastebin %pdb %pdef %pdoc %pfile %pinfo %pinfo2 %popd %pprint %precision %profile %prun %psearch %psource %pushd %pwd %pycat %pylab %qtconsole %quickref %recall %rehashx %reload_ext %rep %rerun %reset %reset_selective %rm %rmdir %run %save %sc %set_env %store %sx %system %tb %time %timeit %unalias %unload_ext %who %who_ls %whos %xdel %xmode </span><span id="88e7" class="ku js hu ll b fv mu mr l ms mt">Available cell magics: %%! %%HTML %%SVG %%bash %%capture %%debug %%file %%html %%javascript %%js %%latex %%perl %%prun %%pypy %%python %%python2 %%python3 %%ruby %%script %%sh %%svg %%sx %%system %%time %%timeit %%writefile</span></pre><p id="ad1d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本质上，您可以用一个问题来区分哪些是IPython特有的，哪些可以在其他内核中使用:这个功能是Python特有的，还是也可以在您正在使用的语言中使用的通用功能？</p><p id="1185" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，<code class="eh li lj lk ll b">%pdb</code>或Python调试器或<code class="eh li lj lk ll b">%matplotlib</code>是Python特有的东西，当你使用JavaScript内核时，它们就没有意义了。然而，用<code class="eh li lj lk ll b">%cd</code>改变目录通常是非常通用的，应该在任何语言中都能工作，因为它是这样一个“通用”命令。所以，这可能是一个可以在其他内核中使用的魔法。当然，您仍然需要知道您的内核是否使用了魔法。</p><h2 id="8eb6" class="ku js hu bd jt kv kw kx jx ky kz la kb jc lb lc kf jg ld le kj jk lf lg kn lh dt translated"><strong class="ak">转换和格式化笔记本？</strong></h2><p id="d299" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">转换和格式化笔记本是Jupyter生态系统中的功能。对于这些任务，您通常会找到两个工具<code class="eh li lj lk ll b"><a class="ae jq" href="https://github.com/jupyter/nbconvert" rel="noopener ugc nofollow" target="_blank">nbconvert</a></code>和<code class="eh li lj lk ll b"><a class="ae jq" href="https://github.com/jupyter/nbformat" rel="noopener ugc nofollow" target="_blank">nbformat</a></code>。</p><p id="934f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以使用前者将笔记本转换为各种其他格式，以熟悉的格式呈现信息，发布研究成果并将笔记本嵌入论文中，与他人协作以及与更多受众共享内容。</p><p id="65eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">后者基本上包含Jupyter notebook格式，是理解Notebook文件是简单的JSON文档的关键，这些文档包含:元数据(如内核或语言信息)、Notebook格式的版本(主要和次要)以及包含所有文本、代码等的单元格。已存储。</p><h2 id="c23b" class="ku js hu bd jt kv kw kx jx ky kz la kb jc lb lc kf jg ld le kj jk lf lg kn lh dt translated">保存和加载笔记本？</h2><p id="08f2" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">保存和加载笔记本是Jupyter笔记本应用程序的一个特性。您可以加载保存为文件的笔记本。ipynb文件扩展名，这是其他人通过下载并在Jupyter应用程序中打开该文件而创建的。更具体地说，您可以创建一个新笔记本，然后通过单击“文件”选项卡，单击“打开”并选择您下载的笔记本来选择打开文件。</p><p id="8687" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">相反，您也可以通过单击相同的“文件”选项卡并选择“下载为”来保存您自己的笔记本文件，或者您也可以选择保存文件并设置检查点。当你想做一些小的版本控制，或者恢复到笔记本的早期版本时，这是非常方便的。当然，您的修改会每隔几分钟自动保存一次，所以并不总是需要明确地执行这个操作。</p><p id="e524" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，您也可以选择不保存对原始笔记本的任何更改，方法是制作一份副本并将所有更改保存到该副本中！</p><h2 id="4b57" class="ku js hu bd jt kv kw kx jx ky kz la kb jc lb lc kf jg ld le kj jk lf lg kn lh dt translated">键盘快捷键和多光标支持？</h2><p id="6aed" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">选择多个单元、切换单元输出、插入新单元等。对于所有这些操作，Jupyter笔记本中都有键盘快捷键。你可以在顶部的菜单下找到键盘快捷键列表:进入“帮助”选项卡，选择“键盘快捷键”。</p><p id="8b10" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，多光标支持是Jupyter笔记本的一个特性！</p><h2 id="3bb1" class="ku js hu bd jt kv kw kx jx ky kz la kb jc lb lc kf jg ld le kj jk lf lg kn lh dt translated">并行计算？</h2><p id="e9ae" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">并行计算网络是IPython项目的一部分，但是从4.0开始，它是一个名为<code class="eh li lj lk ll b"><a class="ae jq" href="https://ipyparallel.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">ipyparallel</a></code>的独立包。这个包基本上是用于控制Jupyter集群的CLI脚本的集合。</p><p id="7974" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尽管它是独立的，但它仍然是IPython生态系统的一个强大组件，这一点通常被忽略了；它如此强大是因为它允许你在许多机器上启动许多分布式内核，而不是运行一个Python内核。</p><p id="ec94" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh li lj lk ll b">ipyparallel</code>的典型用例是，例如，您需要多次运行模型来估计其输出的分布或它们如何随输入参数变化。当模型的运行是独立的时，您可以通过在集群中的多台计算机上并行运行它们来加速该过程。想想<a class="ae jq" href="http://activisiongamescience.github.io/2016/04/19/IPython-Parallel-Introduction/" rel="noopener ugc nofollow" target="_blank">分布式模型训练</a>或者<a class="ae jq" href="http://davidmasad.com/blog/simulation-with-ipyparallel/" rel="noopener ugc nofollow" target="_blank">模拟</a>。</p><figure class="ln lo lp lq fq lr fe ff paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="fe ff lm"><img src="../Images/2cb699f62460bdf1ce92ec3cb2308705.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IzECtJAszbIbqSsu.png"/></div></div></figure><h2 id="1b7f" class="ku js hu bd jt kv kw kx jx ky kz la kb jc lb lc kf jg ld le kj jk lf lg kn lh dt translated">终端？</h2><p id="fb20" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">这个特性是Jupyter生态系统的一部分:你有Jupyter控制台和一个Jupyter终端应用程序。然而，从一开始，IPython就被用来表示Python最初的交互式命令行终端。它提供了一个增强的读取-评估-打印循环(REPL)环境，特别适合科学计算。这是2011年之前的标准，当时笔记本工具被引入，并开始为Python提供现代而强大的web接口。</p><p id="2efd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，您还有IPython控制台，它启动了两个进程:原始的IPython终端shell和默认的概要文件或内核，如果没有特别说明，它们就会启动。默认情况下，这是Python。</p><p id="0c68" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">IPython控制台现在已经过时，如果您想启动它，您需要使用Jupyter控制台，这是一个基于终端的Jupyter内核控制台前端。此代码基于单进程IPython终端。Jupyter控制台在终端提供IPython的交互式客户端体验，但是能够连接到任何Jupyter内核，而不仅仅是IPython。</p><p id="0c25" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这让您可以测试您可能已经安装在终端上的任何Jupyter内核，而不需要为它启动一个完整的笔记本。控制台允许与其他Jupyter内核进行基于控制台的交互，比如IJulia、IRKernel。</p><p id="90e7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，Jupyter Notebook应用程序还有一个终端应用程序:一个运行在浏览器中的简单bash shell终端。当您启动应用程序并从下拉菜单中选择一个新的终端时，您可以很容易地找到它。</p><h2 id="778d" class="ku js hu bd jt kv kw kx jx ky kz la kb jc lb lc kf jg ld le kj jk lf lg kn lh dt translated">Qt控制台？</h2><p id="4e32" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">Qt控制台曾经是IPython项目的一部分，但现在已经转移到了Jupyter项目中。这是一个轻量级的应用程序，很大程度上感觉像一个终端，但提供了许多只有在GUI中才有的增强功能，如内嵌图形、带语法突出显示的正确的多行编辑、图形呼叫提示等等。Qt控制台可以使用任何Jupyter内核。</p><p id="b315" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">今天的博客文章是对DataCamp权威指南的补充，更详细地介绍了计算笔记本的历史，以及IPython和Jupyter项目的一些主要特性，以便您可以更清楚地了解两者的发展和差异。我们的目标是看到，如果你不考虑这两个项目的历史观点，这两者之间的区别有时是很难的。在某些情况下，有一个灰色地带，一个“中间地带”，这是不容易归类的。</p></div><div class="ab cl mv mw hc mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="hn ho hp hq hr"><p id="f3ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">最初发表于</em><a class="ae jq" href="http://www.datacamp.com/community/blog/ipython-jupyter" rel="noopener ugc nofollow" target="_blank"><em class="jp">【www.datacamp.com】</em></a><em class="jp">。</em></p><div class="ln lo lp lq fq ab cb"><figure class="nc lr nd ne nf ng nh paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nc lr nd ne nf ng nh paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nc lr nd ne nf ng nh paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ni nj nk"><p id="f922" class="ir is jp it b iu iv iw ix iy iz ja jb nl jd je jf nm jh ji jj nn jl jm jn jo hn dt translated"><a class="ae jq" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jq" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jq" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jq" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is jp it b iu iv iw ix iy iz ja jb nl jd je jf nm jh ji jj nn jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jq" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jq" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ln lo lp lq fq lr fe ff paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="fe ff no"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="ln lo lp lq fq lr"><div class="bz el l di"><div class="np nq l"/></div></figure></div></div>    
</body>
</html>