<html>
<head>
<title>Javascript Coercion Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript强制解释</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/javascript-coercion-explained-545c895213d3?source=collection_archive---------15-----------------------#2017-10-10">https://medium.com/hackernoon/javascript-coercion-explained-545c895213d3?source=collection_archive---------15-----------------------#2017-10-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="2c95" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">以及一些实际的例子</h2></div><p id="903c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt kf translated"><span class="l kg kh ki bm kj kk kl km kn di"> B </span>在我们开始JS强制探索之前，值得注意的是这篇文章的存在，因为JS是一种<a class="ae ko" href="https://hassan4u.wordpress.com/2010/12/11/typed-vs-untyped-languages/" rel="noopener ugc nofollow" target="_blank">非类型化语言</a>(根据您的定义，可能是弱类型)。</p><figure class="kp kq kr ks fq kt"><div class="bz el l di"><div class="ku kv l"/></div></figure><h2 id="b074" class="kw kx hu bd ky kz la lb lc ld le lf lg js lh li lj jw lk ll lm ka ln lo lp lq dt translated">打字语言</h2><blockquote class="lr ls lt"><p id="04b0" class="jj jk lu jl b jm jn iv jo jp jq iy jr lv jt ju jv lw jx jy jz lx kb kc kd ke hn dt translated">强<strong class="jl hv">类型的</strong>编程<strong class="jl hv">语言</strong>是这样一种语言，其中每种<strong class="jl hv">类型的</strong>数据(如整数、字符、十六进制、打包十进制等)都被预定义为编程<strong class="jl hv">语言</strong>的一部分，并且为给定程序定义的所有常量或变量都必须用其中一种数据类型来描述。</p><p id="d962" class="jj jk lu jl b jm jn iv jo jp jq iy jr lv jt ju jv lw jx jy jz lx kb kc kd ke hn dt translated">— <a class="ae ko" href="http://whatis.techtarget.com/definition/strongly-typed" rel="noopener ugc nofollow" target="_blank">来源哟</a></p></blockquote></div><div class="ab cl ly lz hc ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hn ho hp hq hr"><p id="b858" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于我们这些JS用户来说，这意味着这种语言可能会被迫在编译时做出某些基于<a class="ae ko" href="http://delapouite.com/ramblings/javascript-coercion-rules.html" rel="noopener ugc nofollow" target="_blank">规则的</a>类型的决定。在这篇文章中，我们将提到两种不同类型的强迫，<strong class="jl hv">显性</strong>和<strong class="jl hv">隐性</strong>。</p><p id="70f9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">显式强制是作者将一种类型的值转换为另一种类型的明显尝试。隐式强制作为另一个操作的不太明显的副作用出现。参见下面的例子(<a class="ae ko" href="https://gist.github.com/btg5679/f0f456357ec8571f599e7d6ccbec2308" rel="noopener ugc nofollow" target="_blank">要点</a>):</p><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="fe ff mf"><img src="../Images/2f1b9fbf10de5181da9d734048a3523e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*stdZQImftgMzyMur_5qXcg.png"/></div></div><figcaption class="mm mn fg fe ff mo mp bd b be z ek">implicit/explicit coercion</figcaption></figure><p id="1b3c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">请注意，在上面的例子中，隐式和显式的两种方法都导致了相同的结果，有趣的是<em class="lu">如何</em>导致了一些争论。即可读性是争论的焦点。几乎总是有人，而不是你，会阅读你的代码。以上方法哪个可读性更强？</p><p id="8d8f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">说了这么多，让我们看看JS如何使用<code class="eh mq mr ms mt b">==</code>和<code class="eh mq mr ms mt b">===</code>处理数据类型之间的比较，以及使用<code class="eh mq mr ms mt b">null</code>和<code class="eh mq mr ms mt b">undefined</code>时的比较。</p></div><div class="ab cl ly lz hc ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hn ho hp hq hr"><h2 id="2dbc" class="kw kx hu bd ky kz la lb lc ld le lf lg js lh li lj jw lk ll lm ka ln lo lp lq dt translated">空与未定义</h2><p id="90d9" class="pw-post-body-paragraph jj jk hu jl b jm mu iv jo jp mv iy jr js mw ju jv jw mx jy jz ka my kc kd ke hn dt translated">下面是一些代码示例，将在下面详细解释(<a class="ae ko" href="https://gist.github.com/btg5679/61eb19e762ab05cc2be26339c8cff8a2" rel="noopener ugc nofollow" target="_blank">要点</a>):</p><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="fe ff mz"><img src="../Images/6ce48ffe26927dd6f9ec31df08d0b8d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ku-MoMX5u2yyvqf4EoA0gw.png"/></div></div><figcaption class="mm mn fg fe ff mo mp bd b be z ek">null vs undefined types</figcaption></figure><p id="a836" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">上述代码的主要优点是:</p><ul class=""><li id="b7ed" class="na nb hu jl b jm jn jp jq js nc jw nd ka ne ke nf ng nh ni dt translated"><code class="eh mq mr ms mt b">null</code>是一个<em class="lu">对象</em></li><li id="0724" class="na nb hu jl b jm nj jp nk js nl jw nm ka nn ke nf ng nh ni dt translated"><code class="eh mq mr ms mt b">undefined</code>是它自己独特的类型<em class="lu">未定义</em></li></ul></div><div class="ab cl ly lz hc ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hn ho hp hq hr"><h2 id="d419" class="kw kx hu bd ky kz la lb lc ld le lf lg js lh li lj jw lk ll lm ka ln lo lp lq dt translated">比较</h2><p id="cb7d" class="pw-post-body-paragraph jj jk hu jl b jm mu iv jo jp mv iy jr js mw ju jv jw mx jy jz ka my kc kd ke hn dt translated">我们现在来看看使用<a class="ae ko" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators" rel="noopener ugc nofollow" target="_blank">相等</a> <code class="eh mq mr ms mt b"><a class="ae ko" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators" rel="noopener ugc nofollow" target="_blank">==</a></code> <a class="ae ko" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators" rel="noopener ugc nofollow" target="_blank">和严格相等</a> <code class="eh mq mr ms mt b"><a class="ae ko" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators" rel="noopener ugc nofollow" target="_blank">===</a></code> <a class="ae ko" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators" rel="noopener ugc nofollow" target="_blank">比较来比较不同类型的值的结果。</a></p><p id="cc23" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">好，让我们强迫JS解释器对我们的意图进行一些猜测:</p><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="fe ff no"><img src="../Images/91fb294374aa4a79f2282690f0c16b77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*abGotxTnQsToqbBC74Ez4Q.png"/></div></div><figcaption class="mm mn fg fe ff mo mp bd b be z ek">undefined/null</figcaption></figure><p id="4ab8" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">请注意，<code class="eh mq mr ms mt b">undefined</code>和<code class="eh mq mr ms mt b">null</code>在相等比较(4–5)中彼此相等，但在严格相等比较(8–9)中不相等</p><p id="a226" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们来看一些<strong class="jl hv">字符串</strong>、<strong class="jl hv">数字</strong>和<strong class="jl hv">布尔</strong>的比较:</p><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="fe ff np"><img src="../Images/fde7b677e165555ef2e8c100d28316cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IF-Usxxw9SvoLbyA_GCPpw.png"/></div></div><figcaption class="mm mn fg fe ff mo mp bd b be z ek">string/number/bool</figcaption></figure><p id="58a5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在你可能注意到了一个模式。当使用相等比较来比较不同类型的val时，JS可能会正确地强制这些值。虽然准确性是通过严格的比较来实现的。</p><h2 id="6d4c" class="kw kx hu bd ky kz la lb lc ld le lf lg js lh li lj jw lk ll lm ka ln lo lp lq dt translated">结论</h2><p id="21f2" class="pw-post-body-paragraph jj jk hu jl b jm mu iv jo jp mv iy jr js mw ju jv jw mx jy jz ka my kc kd ke hn dt translated">最后，强制是非类型化语言的一种必然的邪恶。</p><p id="2b8f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我的建议是:</p><blockquote class="lr ls lt"><p id="32a7" class="jj jk lu jl b jm jn iv jo jp jq iy jr lv jt ju jv lw jx jy jz lx kb kc kd ke hn dt translated">当你写代码时<strong class="jl hv">总是</strong>使用严格比较，除非你能证明不这样做是合理的。</p></blockquote><div class="nq nr fm fo ns nt"><a rel="noopener follow" target="_blank" href="/@reasoncode/javascript-es6-arrow-functions-and-lexical-this-f2a3e2a5e8c4"><div class="nu ab ej"><div class="nv ab nw cl cj nx"><h2 class="bd hv fv z el ny eo ep nz er et ht dt translated">Javascript ES6 —箭头函数和词汇“this”</h2><div class="oa l"><h3 class="bd b fv z el ny eo ep nz er et ek translated">ES6 Javascript标准中最令人期待的新特性之一是箭头函数表达式。它承诺…</h3></div><div class="ob l"><p class="bd b gc z el ny eo ep nz er et ek translated">medium.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh mk nt"/></div></div></a></div><p id="db29" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一如既往，让我们知道你的想法和问题，请在推特上关注我们。坚持下去。</p><h2 id="558e" class="kw kx hu bd ky kz la lb lc ld le lf lg js lh li lj jw lk ll lm ka ln lo lp lq dt translated">如果这篇文章有帮助，请点击拍手👏按钮下面几下，以示支持！⬇⬇</h2></div></div>    
</body>
</html>