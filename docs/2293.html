<html>
<head>
<title>Replacing the angular 1 router with Elm — Part 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Elm替换angular 1路由器—第4部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/replacing-the-angular-1-router-with-elm-part-4-f0ace653d93c?source=collection_archive---------19-----------------------#2017-01-17">https://medium.com/hackernoon/replacing-the-angular-1-router-with-elm-part-4-f0ace653d93c?source=collection_archive---------19-----------------------#2017-01-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="6e99" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是系列文章的第四部分。你也要看<a class="ae jp" rel="noopener" href="/@julianjelfs_61852/replacing-the-angular-1-router-with-elm-d71753e74e32#.q661pucta">第一部</a>、<a class="ae jp" rel="noopener" href="/@julianjelfs_61852/replacing-the-angular-1-router-with-elm-part-2-bf9c84934abf#.kdib3ce9i">第二部</a>和<a class="ae jp" rel="noopener" href="/@julianjelfs_61852/replacing-the-angular-1-router-with-elm-part-3-d56e40bf251#.tp2toln2g">第三部</a>。</p><p id="5034" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以我们至少还有一个主要问题。当Elm作为路由更改的一部分删除组件树的根节点时，我们可能会删除angular控制下的一个大的子树，而不通知angular，也不给它执行正常清理操作的机会。这可能并且确实会导致内存泄漏并最终崩溃。您不会在示例代码中注意到这一点，因为效果可能太小了。</p><p id="8ce4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">概括地说，当Elm改变路由时，我们触发一个摘要循环，如下所示:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="09e3" class="jz ka hu jv b fv kb kc l kd ke">function triggerDigest() {<br/>    if(!compile) {<br/>        return;<br/>    }<br/>    var $body = angular.element(document.body);            <br/>    var $rootScope = $body.injector().get('$rootScope');  <br/>    var $location = $body.injector().get('$location');  <br/>    var $compile = $body.injector().get('$compile');</span><span id="15ac" class="jz ka hu jv b fv kf kc l kd ke">    $location.$$parseLinkUrl(window.location.href);<br/>    $rootScope.$apply(function() {<br/>        $compile($body)($rootScope);<br/>    });<br/>    observer.disconnect();<br/>    listenForRouteChanges = true;<br/>}</span></pre><p id="f49d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了保持angular的$destroy行为，并希望避免内存泄漏，我们需要做一些不同的事情。我们必须每次从$rootScope创建一个<em class="kg">新的</em>作用域，然后根据这个新的作用域编译我们的根节点。然后在下一次迭代中，如果我们创建的范围存在，我们将在用下一个新范围覆盖它之前调用$destroy。这样，angular将通过作用域层次结构向下级联$destroy调用，所有需要清理的内容都将被清理。所以上面的代码现在看起来像这样:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="56c2" class="jz ka hu jv b fv kb kc l kd ke"><strong class="jv hv">let activeScope = null;</strong></span><span id="d121" class="jz ka hu jv b fv kf kc l kd ke">function triggerDigest() {<br/>    <strong class="jv hv">if(activeScope) {<br/>        activeScope.$destroy();<br/>    }</strong></span><span id="3ab9" class="jz ka hu jv b fv kf kc l kd ke">    if(!compile) {<br/>        return;<br/>    }<br/>    var $body = angular.element(document.body);            <br/>    var $rootScope = $body.injector().get('$rootScope');  <br/>    var $location = $body.injector().get('$location');  <br/>    var $compile = $body.injector().get('$compile');</span><span id="5f61" class="jz ka hu jv b fv kf kc l kd ke">    <strong class="jv hv">activeScope = $rootScope.$new();</strong></span><span id="40ab" class="jz ka hu jv b fv kf kc l kd ke">    $location.$$parseLinkUrl(window.location.href);<br/>    <strong class="jv hv">activeScope.$apply(function() {<br/>        $compile($body)(activeScope);<br/>    });</strong><br/>    observer.disconnect();<br/>    listenForRouteChanges = true;<br/>}</span></pre><p id="8ac2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用AngularJS chrome插件，现在很容易看到，正如我们所期望的那样，范围层次结构在每次路由更改时都被修剪了，内存泄漏问题有望消失(或者至少不会比使用常规angular时更糟)。</p><p id="29d4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">和以前一样，可以在<a class="ae jp" href="https://github.com/travelrepublic/elm-angular-router" rel="noopener ugc nofollow" target="_blank">这里</a>找到这个概念证明的完整来源。</p></div></div>    
</body>
</html>