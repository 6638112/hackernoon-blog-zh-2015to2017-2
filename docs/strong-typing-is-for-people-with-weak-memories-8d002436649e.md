# 强打字是给记忆力差的人用的

> 原文：<https://medium.com/hackernoon/strong-typing-is-for-people-with-weak-memories-8d002436649e>

我是软件世界中的一个“老家伙”，老到不得不在穿孔卡上输入代码，被迫翻阅 12 英寸厚的扇形折叠打印输出来调试汇编。在我在 IBM 的第一份真正的工作中，和我一起工作的一位程序员(即使在当时他也是一个“老家伙”)给了我一份现在被称为“迷因”的纸质副本。它的标题是“真正的程序员不写规范”(这是我在网上能找到的最接近的东西:[http://multicians.org/thvv/realprogs.html](http://multicians.org/thvv/realprogs.html))。当静态与动态语言的“辩论”抬头时，最后一句妙语总是浮现在脑海中:

*   真正的程序员不会用 PASCAL、BLISS、ADA 或任何一种左倾的计算机科学语言来写。强打字是给记忆力差的人用的。

有人记得布利斯吗？有人吗？布勒？

不管怎样，这个总是值得一笑。我不完全同意这一点，但就像最好的幽默一样，有一个隐藏在那里的坚硬的真理内核。静态类型分析当然是一个有用的工具，通常的免责声明是效用是问题的函数。我确实认为我们忽略了一点，即支持静态分析的主要论点是做一些事情，比如捕捉与函数签名不匹配的函数调用。确保正确的函数调用不是软件质量帐篷中的长杆。更广泛地说，我们需要更多地认识到我们可用的一系列工具，以及它们所代表的权衡，而不是专注于任何一种方法。当应用于正确的问题时，静态类型系统可以是一个有用的工具，但它们不是唯一的工具，也永远不会是一个完整的解决方案(是的，对图灵完整性的间接引用绝对是有意的)。

TL；这里的 dr 是软件质量通常是关于强制约束的，约束本身才是重要的，而不是它们如何应用于特定问题的细节。我做了几年的研究物理学家。物理学花了很多时间关注“对称性”，即我可以改变一些东西，而其他量保持不变。一般来说，对称性意味着“守恒定律”，例如，描述星系中物质运动的方程在旋转下是不变的。旋转不变性反过来意味着角动量守恒。守恒定律可以成为解决问题的一个约束。例如，考虑一个大的球状物质云的运动，像一个原星系，有一些净角动量，经历内部摩擦。为了解决物质分布如何随时间演化，我们应用角动量守恒的约束，发现球状云演化为旋转的圆盘。用来找到那个解的特定算法并不重要，只要它提供的解满足我们的约束。

所以约束很重要。在星系的例子中，这个约束引导我们找到一个描述星系中物质最终分布的特殊函数。软件工程实际上是关于约束的。程序实际上是一种计算函数的方式，其中一些输入值导致特定的输出值。假设像图灵机模型一样，我们有一个完整的函数空间，可以(理论上)用计算机程序来表达。但是这些函数中只有一部分对我们有用，“有用”意味着它们满足约束条件，这些约束条件定义了我们试图解决的任何问题。这些约束可能很简单，比如这个函数接受两个整数并返回一个整数；或者他们可以有更复杂的领域信息:输入今天的日期，并向我们数据库中所有生日是那天的客户发送电子邮件，处理闰年等。

静态类型和相关的静态分析显然是表达和实施约束的一种方式。从某种意义上说，这是最有力的方法，因为“静态分析”意味着我们可以为所有可能的输入证明关于程序的某些命题。这是静态类型的警笛之歌:静态类型提供了关于代码的某些命题的绝对确定性。如果我们知道代码片段，像函数一样，满足我们的约束，我们也可以推断出这些片段的组合也将满足这些约束——或者不满足，编译器会告诉你。

在应用静态类型的地方，它是一个强大的工具。问题是，你可以从数学上证明静态分析对于图灵完备语言来说是内在受限的。反过来说，用来表达类型的语言不一定是图灵完备的，否则你就不能进行静态分析。Haskell 中的单子就是一个有趣的例子。单子是类型(或者更准确地说，*类型类*)，Haskell 有自己的嵌入式子语言来指定类型。使用 monads 编写的代码可以被静态验证，即使它经常包含在其他语言中被认为是“副作用”的东西，即超出编译器验证范围的东西。所以这很酷。但是当你写你自己的单子类型时，Haskell 不能静态地验证你的单子是否满足单子定律。这取决于你，要么观察它并说服你自己，要么也许做模拟测试至少有一定程度的信心。这不是 Haskell 的不足。在一般情况下，这在数学上是不可能的，因为 Haskell 是图灵完备的。

验证代码约束的其他选择是什么？如果你想，从总体上说，停留在绝对确定性的领域，在那里对代码的推理变成了逻辑推理，你唯一的选择就是放弃图灵完全性(至少，我不知道还有其他选择)。这并不像表面上听起来那么疯狂。SQL，可以说是最成功的语言之一，最初并不是图灵完全的。这反过来允许强大的查询优化器，它可以分析数学上等价的查询形式，并选择执行效率最高的查询，这至少部分地推动了 RDBMS 系统几十年来的发展和主导地位。后来对 SQL 的扩展使它成为图灵完全的，不管是好是坏。另一种查询语言 Datalog 基于 Prolog 的子集，它允许编写保证终止的逻辑程序(尽管不一定在合理的时间内终止)。如果你搜索一下谷歌，你可能会找到其他非图灵完整的 DSL 的例子，用于定义配置任务(例如 [Dhall](http://www.haskellforall.com/2017/10/why-do-our-programs-need-to-read-input.html) )等。切线:如果你正在考虑为你的产品编写一个面向客户的 DSL，允许编写脚本或者做一些其他的定制，不要让它成为图灵完整的。如果你这样做了，你还不如用 Javascript 或 C#来摆脱它们。不管怎样，你给他们的都是一箱手榴弹。所有的针都拔出来了。

一个非常有趣的想法是*全功能编程*。我们仍在放弃图灵完备性，但作为回报，我们得到了对代码更强的静态保证。关键的认识是，图灵完全语言不一定指定用这些语言表达的整个函数域。在 Haskell 或任何其他静态类型的图灵完整语言中，您可以将函数的签名指定为`int -> int -> int`，但是所能保证的是**如果**曾经返回值，它将是一个`int`。你不能保证函数会停止，或者它不会因为被零除这样的错误而终止。全函数式语言需要完整的函数定义域规范，并且只允许可以静态验证终止的简化形式的递归。好的一面是，您可以更有力地保证您的代码符合您的约束。例如，太常见和可怕的缓冲区溢出消失了。也就是说，你必须在工具本身的约束下工作，特别是迭代算法需要更多的麻烦。当然，你放弃了图灵完备性，但是正如[原始论文](http://www.jucs.org/jucs_10_7/total_functional_programming/jucs_10_07_0751_0768_turner.pdf)所主张的，那可能不是可怕的限制。以太坊正朝着使用一种总的语言来进行合同规范的方向发展，这看起来很有说服力，因为如果用来定义合同的语言不是 100%可验证的，我看不出你怎么能有一个系统来验证受合同约束的交易。

如果不想放弃图灵完备性，可以放弃确定性。我们的约束不再是 100%可验证的，但是我们可以告知信任度，我们的代码尊重约束。单元测试是这种方法的一个例子，尽管是一个相当弱的例子。单元测试将验证一组输入会产生“正确的”输出。因此，现在您至少有一个数据点，这增加了您对代码对于所有输入都是正确的信念。模拟测试(例如 Haskell QuickCheck)更进一步，测试了大量不同的输入值。现在你有了大量的数据，输入的生成器可以被调整以确保它们达到“有趣”的点。采用`int`的函数可能应该用整数值的大范围采样来测试，并且包括典型的“问题”点，比如零和特定整数表示的最小/最大值。这种基于测试的方法可以用其他工具来扩充，比如测试覆盖率，它进一步告诉你代码将满足所有可能输入的约束。

我想我们可以开始了解为什么“静态与动态”的语言辩论如此两极化。静态分析以数学为基础，并给出明确的答案，一些人无疑会觉得这非常有说服力。我记得在 StackOverflow 之类的地方看到过一个评论，说使用单子而不使用静态类型是“疯狂”，或者类似的话。我的经历更像是[这个家伙的](http://blog.muhuk.com/2015/10/01/who_in_their_right_mind_would_use_monads_in_clojure.html)。正如 Brian Beckman 所说，类型单子显然有一些优势，你只需在计算中“排列类型”。但是我在 Clojure 中用单子处理过一些非常复杂的东西，即使没有类型，它也被证明是一种有用的模式。我想我可能在脑子里做了很多类型分析。也许那些被动态语言吸引的人可能有那种将大量代码映射到他们大脑中的约束的技能。

这给我们留下了什么？静态类型和相关的分析给出了关于我们的代码和代码应该遵守的约束的一些命题的确切答案。因此，它提供了一种对纯粹演绎逻辑的代码进行推理的方法，因此可以由计算机来执行。问题是相对较少的命题可以用这种方式证明。然后我们转向不太精确的方法，像单元测试(弱的)或模拟测试(更好的)，它们至少给我们一些证据，证明我们的约束得到了满足，从而将我们的推理过程从演绎转向推理。这种推理目前主要是在人们的头脑中完成的，而不是用软件工具，用精确性和透明性来换取对更广泛的约束进行推理的能力。我们如何改善这种情况？当然，一种方法是用像全函数编程这样的方法尽可能地扩大演绎方法的范围。但我很少(曾经？)看到任何关于将推理方法放在更坚实的定量基础上，增加透明度，允许更多自动化工具来执行这种推理，而不是让它在某人的大脑中晃动的讨论。

我这里要描述的，纯粹是天马行空的吐槽，但我觉得值得探讨。为了激发这种信念，我再举一个我从事天体物理学研究时的例子。我的很多工作都是围绕伽马射线望远镜的图像重建。伽马射线望远镜，比如康普顿望远镜，通过量子光学工作。你不能用镜头将伽马射线光子聚焦在一个漂亮的像素阵列上，然后拍摄一张照片。相反，你必须测量伽马射线光子与探测器中物质的量子相互作用，然后试图还原光子的原始方向和能量。此外，天文学的一般规则是，能量越高，可用的光子越少，除此之外，你还必须在空间(或近空间)进行观测，在那里非光子宇宙射线背景会添加大量背景噪声。因此，还原伽马射线天空的图像是一个相当困难的统计逆问题，必须利用类似于神经网络常用的[的正则化技术](http://neuralnetworksanddeeplearning.com/chap3.html)。

问题是(就像神经网络一样)正则化的选择是任意的，与手边的科学问题无关。例如，康普顿尔进行的一项科学工作是试图确定铝-26 衰变产生的 1.6 兆电子伏伽马射线的分布。铝-26 是铝的放射性同位素，可以通过各种恒星过程如超新星产生。这些各种各样的来源在星系中有不同的空间分布(如“块状”、“光滑”)，如果你能分析来自银河系的 1.6 兆电子伏伽马辐射的空间分布，你就会获得大量关于重元素核合成的信息。很棒的东西，除了选择一些任意的正则化技术现在给你一个旋钮来旋转，这样重建的伽马射线图像就可以像你想要的那样平滑或结块，没有真正的方法来围绕重元素核合成的各种假设提出一个可量化的科学问题。

我在进入工业界之前的最后一个研究项目就是试图解决这个问题。你猜怎么着？它包含了应用约束的想法。这些约束条件可以从相互竞争的科学假设中导出，用于(通过最大熵方法)导出伽马射线空间分布的先验，这导致类似比较不同假设的后验比值比分析的事情。这些限制的特殊形式与量化描述天空中伽马射线强度的函数的规则性有关。这种“正则性”与用于稳定统计逆问题的“正则化”密切相关，正则化过程本质上只是对派生函数施加约束的一种方式，其中“正则性”是对相似函数进行分类的一些定量度量。我特别选择了 Besov 范数，它可以被认为是一个函数有多“光滑”(真的可微)的广义度量。Besov 范数在图像的小波系数方面具有相当简单的表达式，这又导致良好的封闭形式的先验分布。

无论如何，这是一个很长的，超级极客的题外话，但我保证我有一个观点，那就是我有预感这个正则性的概念-->先验-->后验可能是一条通向量化程序推理的道路。想一想在模拟测试中产生信心的心理过程，在这种情况下，您最终可能会遇到很小一部分可能的输入，但会坚定地认为您的代码通常满足期望的约束。这个过程的一个关键是对程序中函数的规律性的假设。再来看看我们简单的`int -> int -> int`函数。假设 64 位整数，有 2 个⁸可能的输入，也许你测试，我不知道，一百万左右？相信你的代码对所有 2 个⁸可能性都是正确的，意味着你强烈相信你的函数的正则性，也就是说你觉得它对所有输入的行为大致相同，不会因为某个特殊值而爆炸。用于测试该函数的生成器反映了这一点，这就是为什么零和 min/max `int`值以很高的概率生成，并且通常代码中常见的值(如+/- 1)可能比某些其他特定值(如 188366531)以更高的概率生成。如果您可以量化规律性信念，那么您可以从理论上推导出一个先验，当它与来自模拟测试的“数据”结合时，会导致您的函数是正确的后验概率。对单个函数这样做，现在可以对函数的组合进行推理，最终对整个程序进行推理。我认为您甚至可以将这与静态分析结合起来，最终导致对代码正确性的更高程度的信任。事实上，它会给你一个静态类型给你的代码带来的好处的量化评估。

诚然，在这一点上，一切都是举手之劳。但是我认为这种基于推理的方法是另一种值得研究的途径，因为我们已经知道演绎法在本质上是有局限性的。量化这种推理使其更加强大，从而导致自动化工具，并避免错误和偏见，如果人类只是通过直觉进行推理，这些错误和偏见是不可避免的。最后，作为应对即将到来的量子计算革命的一种方式，我们无论如何都可能被迫采用这种方法。