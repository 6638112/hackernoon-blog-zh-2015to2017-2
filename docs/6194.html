<html>
<head>
<title>7 Quick Tips for Java Programmers Starting C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java程序员开始使用C++的7个快速技巧</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/7-quick-tips-for-java-programmers-starting-c-67103c8f3bd1?source=collection_archive---------3-----------------------#2017-09-07">https://medium.com/hackernoon/7-quick-tips-for-java-programmers-starting-c-67103c8f3bd1?source=collection_archive---------3-----------------------#2017-09-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/f122f77ebe199c1d2bad15c3a7251b9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aSYzSjG3vMo36ZtGx10AZw.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/tNALoIZhqVM?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">fireskystudios.com</a> on <a class="ae jg" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="382d" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">1.避免使用新关键字</h1><p id="72ce" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">在Java中，对象是使用<code class="eh ld le lf lg b">new</code>关键字实例化的，因此很自然地认为我们应该以同样的方式在C++中使用<code class="eh ld le lf lg b">new</code>:</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Java</figcaption></figure><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">C++</figcaption></figure><p id="db37" class="pw-post-body-paragraph kf kg hu kh b ki ln kk kl km lo ko kp kq lp ks kt ku lq kw kx ky lr la lb lc hn dt translated">然而，与Java不同，用<code class="eh ld le lf lg b">new</code>实例化的C++变量是<em class="ls">非托管的</em>，这意味着你必须记住在使用后释放内存。</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">C++</figcaption></figure><p id="f9ee" class="pw-post-body-paragraph kf kg hu kh b ki ln kk kl km lo ko kp kq lp ks kt ku lq kw kx ky lr la lb lc hn dt translated">这可以用<code class="eh ld le lf lg b">delete</code>关键字来完成。从Java世界来看，这看起来最不方便，最糟糕的是非常容易出错！为什么C++版本需要额外的语句，而Java版本是如此简洁？</p><p id="df70" class="pw-post-body-paragraph kf kg hu kh b ki ln kk kl km lo ko kp kq lp ks kt ku lq kw kx ky lr la lb lc hn dt translated">在C++中，有多种方法可以实例化一个对象，首选的方法是直接在堆栈上。</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">C++</figcaption></figure><p id="8425" class="pw-post-body-paragraph kf kg hu kh b ki ln kk kl km lo ko kp kq lp ks kt ku lq kw kx ky lr la lb lc hn dt translated">当变量被分配到堆栈上时，一旦它们超出范围，就会被自动删除。这非常简洁，并且具有很大的性能特征。</p><h1 id="9e90" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">2.C++的<code class="eh ld le lf lg b">const</code>比Java的<code class="eh ld le lf lg b">final</code>更强大</h1><p id="40e1" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">设计大型应用程序时的一个常见模式是使值不可变。这通过减少应用程序的活动部件的数量来降低复杂性。</p><p id="0018" class="pw-post-body-paragraph kf kg hu kh b ki ln kk kl km lo ko kp kq lp ks kt ku lq kw kx ky lr la lb lc hn dt translated">在Java中，我们可以使用<code class="eh ld le lf lg b">final</code>关键字将<em class="ls">引用</em>标记为不可变的。但是，指向的数据可能会发生变化。例如:</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Java</figcaption></figure><p id="00a7" class="pw-post-body-paragraph kf kg hu kh b ki ln kk kl km lo ko kp kq lp ks kt ku lq kw kx ky lr la lb lc hn dt translated">因此，为了创建真正不可变的类型，Java开发人员必须将类中的所有字段标记为<code class="eh ld le lf lg b">final</code>:</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Java</figcaption></figure><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Java</figcaption></figure><p id="4f48" class="pw-post-body-paragraph kf kg hu kh b ki ln kk kl km lo ko kp kq lp ks kt ku lq kw kx ky lr la lb lc hn dt translated">在C++中，我们有<code class="eh ld le lf lg b">const</code>关键字，它要强大得多。如果一个实例被标记为<code class="eh ld le lf lg b">const</code>，那么它的任何成员都不能改变，即使它们在类定义中没有被标记为<code class="eh ld le lf lg b">const</code>！</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">C++</figcaption></figure><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">C++</figcaption></figure><h1 id="d24b" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">3.当心栈切片！</h1><p id="5252" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">在Java中，所有对象的语义都是它们在堆上(由于JVM所做的优化，现实要复杂一些，但这是一个很好的基本理解)。</p><p id="f718" class="pw-post-body-paragraph kf kg hu kh b ki ln kk kl km lo ko kp kq lp ks kt ku lq kw kx ky lr la lb lc hn dt translated">C++非常不同，因为它允许用户决定对象应该放在堆上还是堆栈上。一般来说，我们应该更喜欢堆栈。它给出了可预测的(和快速的！)性能，但是它有一个很大的局限性，因为每个变量的大小在编译时必须是已知的。这是使用继承时的一个大问题。</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">C++</figcaption></figure><p id="c84a" class="pw-post-body-paragraph kf kg hu kh b ki ln kk kl km lo ko kp kq lp ks kt ku lq kw kx ky lr la lb lc hn dt translated">在这个例子中，我们有两个类<code class="eh ld le lf lg b">A</code>和<code class="eh ld le lf lg b">B</code>，其中<code class="eh ld le lf lg b">B</code>是<code class="eh ld le lf lg b">A</code>的子类。每个都有一个返回类名的函数<code class="eh ld le lf lg b">what</code>。</p><p id="046e" class="pw-post-body-paragraph kf kg hu kh b ki ln kk kl km lo ko kp kq lp ks kt ku lq kw kx ky lr la lb lc hn dt translated">给定这些定义，你认为下面会做什么？</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">C++</figcaption></figure><p id="e926" class="pw-post-body-paragraph kf kg hu kh b ki ln kk kl km lo ko kp kq lp ks kt ku lq kw kx ky lr la lb lc hn dt translated">如果您来自Java世界，答案可能会让您大吃一惊！原来当<code class="eh ld le lf lg b">y</code>被强制转换为类型<code class="eh ld le lf lg b">A</code>并赋值给<code class="eh ld le lf lg b">z</code>时，它采用了类<code class="eh ld le lf lg b">A</code>的<code class="eh ld le lf lg b">what</code>方法。</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="c234" class="pw-post-body-paragraph kf kg hu kh b ki ln kk kl km lo ko kp kq lp ks kt ku lq kw kx ky lr la lb lc hn dt translated">在C++中，当一个堆栈变量被赋给一个超类时，它会获取该超类的成员和方法实现。这是因为变量值的大小不能超过其类型的大小。对于栈变量，编译器只是“切片”掉子类的额外信息。</p><p id="3f04" class="pw-post-body-paragraph kf kg hu kh b ki ln kk kl km lo ko kp kq lp ks kt ku lq kw kx ky lr la lb lc hn dt translated">为了防止这种情况，变量可以由<em class="ls">指向</em>。一个指针(或<a class="ae jg" href="https://en.wikipedia.org/wiki/Reference_(C%2B%2B)" rel="noopener ugc nofollow" target="_blank">引用</a> <a class="ae jg" href="https://en.wikipedia.org/wiki/Reference_(C%2B%2B)))" rel="noopener ugc nofollow" target="_blank"> ) </a>总是有相同的大小，不管被指向的值的大小。</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">C++</figcaption></figure><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div></figure><h2 id="0387" class="lt ji hu bd jj lu lv lw jn lx ly lz jr kq ma mb jv ku mc md jz ky me mf kd mg dt translated">快速旁白:value_ptr</h2><p id="fe8e" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">我们发布了一个名为<code class="eh ld le lf lg b">value_ptr</code>的新智能指针，使得在堆上保存值语义变得更加容易。参见:</p><div class="mh mi fm fo mj mk"><a href="https://hackernoon.com/value-ptr-the-missing-c-smart-pointer-1f515664153e" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab ej"><div class="mm ab mn cl cj mo"><h2 class="bd hv fv z el mp eo ep mq er et ht dt translated">value_ptr —丢失的C++智能指针</h2><div class="mr l"><h3 class="bd b fv z el mp eo ep mq er et ek translated">TL；速度三角形定位法(dead reckoning)</h3></div><div class="ms l"><p class="bd b gc z el mp eo ep mq er et ek translated">hackernoon.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my ja mk"/></div></div></a></div><h1 id="8304" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">4.过载你的操作员！</h1><p id="754b" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">Java不允许你定义类似于<code class="eh ld le lf lg b">int</code>和<code class="eh ld le lf lg b">boolean</code>的自定义值类型和操作符。因此，向量和矩阵的实现可能相当麻烦！</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Java</figcaption></figure><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Java</figcaption></figure><p id="b88d" class="pw-post-body-paragraph kf kg hu kh b ki ln kk kl km lo ko kp kq lp ks kt ku lq kw kx ky lr la lb lc hn dt translated">在C++中，我们可以重载<code class="eh ld le lf lg b">+</code>操作符:</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">C++</figcaption></figure><p id="5fe9" class="pw-post-body-paragraph kf kg hu kh b ki ln kk kl km lo ko kp kq lp ks kt ku lq kw kx ky lr la lb lc hn dt translated">这使得矢量可以和<code class="eh ld le lf lg b">+</code>一起使用，就像内置的原语一样。</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">C++</figcaption></figure><h1 id="408a" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">5.利用编译时编程</h1><p id="40d3" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">Java的泛型非常简单，大部分只对集合类型有用。C++模板极大地扩展了编译时编程的可能性，在某些方面更类似于Java的注释。</p><p id="1899" class="pw-post-body-paragraph kf kg hu kh b ki ln kk kl km lo ko kp kq lp ks kt ku lq kw kx ky lr la lb lc hn dt translated">回忆一下我们之前的<code class="eh ld le lf lg b">Vector2</code>课。如果我们想用Java实现一个三维版本，那么我们需要创建一个新的类:</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Java</figcaption></figure><p id="ac88" class="pw-post-body-paragraph kf kg hu kh b ki ln kk kl km lo ko kp kq lp ks kt ku lq kw kx ky lr la lb lc hn dt translated">在C++中，我们可以将它作为类型的一个参数，并编写只处理一次所有大小的通用代码！代码是在编译时生成的，因此通用代码的效率不亚于手写代码。</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">C++</figcaption></figure><p id="64f8" class="pw-post-body-paragraph kf kg hu kh b ki ln kk kl km lo ko kp kq lp ks kt ku lq kw kx ky lr la lb lc hn dt translated">有了这个通用定义，我们可以很容易地创建任意长度的向量:</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">C++</figcaption></figure><p id="3165" class="pw-post-body-paragraph kf kg hu kh b ki ln kk kl km lo ko kp kq lp ks kt ku lq kw kx ky lr la lb lc hn dt translated">模板甚至可以加快编译速度！请看下面我们的对比:</p><div class="mh mi fm fo mj mk"><a href="https://hackernoon.com/comparing-the-compilation-times-of-templates-and-macros-d0a1b7264a17" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab ej"><div class="mm ab mn cl cj mo"><h2 class="bd hv fv z el mp eo ep mq er et ht dt translated">比较C++模板和宏的编译时间</h2><div class="mr l"><h3 class="bd b fv z el mp eo ep mq er et ek translated">TL；速度三角形定位法(dead reckoning)</h3></div><div class="ms l"><p class="bd b gc z el mp eo ep mq er et ek translated">hackernoon.com</p></div></div><div class="mt l"><div class="mz l mv mw mx mt my ja mk"/></div></div></a></div><h1 id="3bf7" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">6.使用auto！</h1><p id="f220" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">Java著名的<a class="ae jg" href="http://openjdk.java.net/jeps/286" rel="noopener ugc nofollow" target="_blank">缺少一个可变类型推理关键字</a>，比如<code class="eh ld le lf lg b">auto</code> (C++)、<code class="eh ld le lf lg b">var</code> (C#)、<code class="eh ld le lf lg b">val</code> (Kotlin)或者<code class="eh ld le lf lg b">let</code> (OCaml)。这可能会使Java代码变得非常冗长，特别是当像<a class="ae jg" href="https://docs.spring.io/spring/docs/2.5.x/javadoc-api/org/springframework/aop/config/SimpleBeanFactoryAwareAspectInstanceFactory.html" rel="noopener ugc nofollow" target="_blank">SimpleBeanFactoryAwareAspectInstanceFactory</a>这样的类处于混乱状态时！</p><p id="4160" class="pw-post-body-paragraph kf kg hu kh b ki ln kk kl km lo ko kp kq lp ks kt ku lq kw kx ky lr la lb lc hn dt translated">有了C++，编译器可以为你找出许多类型，节省你一些打字和使代码更可读。</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">C++</figcaption></figure><h1 id="e21a" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">7.准备使用更多的库</h1><p id="9dfc" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">不管是好是坏，JVM为您提供了许多现成的平台抽象。相比之下，C++非常精简。它缺乏对文件系统、网络和图形的内置支持。相反，C++开发人员必须利用库来实现这一功能。</p><p id="f4e7" class="pw-post-body-paragraph kf kg hu kh b ki ln kk kl km lo ko kp kq lp ks kt ku lq kw kx ky lr la lb lc hn dt translated">一个好的库也会抽象平台差异，给出一组通用的可移植函数，就像Java一样。严格来说，这两种方法都不更好。Java开发人员受益于更加统一的生态系统，因为每个人都在使用相同的底层API。C++开发人员不再受他们不需要的功能的束缚，但他们也必须对使用什么做出更多的决定，并花费更多的时间来集成它。参见:</p><div class="mh mi fm fo mj mk"><a href="https://hackernoon.com/approaches-to-c-dependency-management-or-why-we-built-buckaroo-26049d4646e7" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab ej"><div class="mm ab mn cl cj mo"><h2 class="bd hv fv z el mp eo ep mq er et ht dt translated">C++依赖管理的方法，或者我们为什么要建立Buckaroo</h2><div class="mr l"><h3 class="bd b fv z el mp eo ep mq er et ek translated">C++是一种不寻常的语言，因为它还没有一个占主导地位的包管理器(我们正在努力！).结果是…</h3></div><div class="ms l"><p class="bd b gc z el mp eo ep mq er et ek translated">hackernoon.com</p></div></div><div class="mt l"><div class="na l mv mw mx mt my ja mk"/></div></div></a></div><h1 id="5092" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">牛仔</h1><p id="162c" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">我们创建了<a class="ae jg" href="https://github.com/LoopPerfect/buckaroo" rel="noopener ugc nofollow" target="_blank"> Buckaroo </a>来使集成C++库变得更容易。如果你想尝试一下，最好从文档开始。您可以在<a class="ae jg" href="https://buckaroo.pm/" rel="noopener ugc nofollow" target="_blank"> Buckaroo.pm </a>上浏览现有套餐，或者在<a class="ae jg" href="https://github.com/LoopPerfect/buckaroo-wishlist" rel="noopener ugc nofollow" target="_blank">愿望清单</a>上请求更多套餐。</p></div></div>    
</body>
</html>