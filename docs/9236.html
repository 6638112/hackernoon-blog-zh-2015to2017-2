<html>
<head>
<title>How To: Dockerize WSO2 products</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何:对WSO2产品进行分类</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-dockerize-wso2-products-22b8328661fc?source=collection_archive---------15-----------------------#2017-12-31">https://medium.com/hackernoon/how-to-dockerize-wso2-products-22b8328661fc?source=collection_archive---------15-----------------------#2017-12-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="b612" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我曾经认为<strong class="it hv"><em class="jp"/></strong>对接是一个艰难的过程，但当我真正尝试过之后，我意识到这一点也不难。好吧，dockerizing并不是一个真正的名字，但它是一种使用docker来容器化一个设置的简单方法。我没有想到这个名字，但我的同事们想到了，我只是用它，因为它实际上更容易这样称呼它:)。</p><p id="f985" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">无论如何，正如我前面提到的，一旦你真正开始做，它看起来一点也不难。让我用docker和WSO2产品一步一步地指导你。</p><p id="cdb4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，在你的电脑中安装<strong class="it hv"> docker </strong>和<strong class="it hv"> docker-compose </strong>。我不会详细讲述这个过程，因为你可以在网上找到几十篇解释如何做的文章。完成这一步后，创建一个文件夹(我称之为<em class="jp"> service_root </em>)并将WSO2产品的zip文件复制到其中。在<em class="jp"> service_root，</em>中创建一个名为<em class="jp"> Dockerfile </em>的文件，并将其留空。我将在本文的后面解释在这个文件中放什么。然后在<em class="jp"> service_root </em>中创建另一个目录，并将所有更改过的配置文件复制到该目录中(从现在开始，我将把该目录称为“资源”)。进入resources目录，在该目录下创建一个名为product-setup.sh的文件(您可以随意命名:)</p><p id="33e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">完成初始框架后，在文本编辑器中打开product-setup.sh文件，使用<em class="jp"> apt-get install </em>命令在容器中安装所有需要的包。例如，在这种情况下，您需要unzip程序来提取容器中的产品zip文件。在运行安装命令之前运行<em class="jp"> apt-get update </em>命令以确保软件包管理器缓存得到更新也很重要。一个非常简单的示例product-setup.sh文件如下所示。</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="61a2" class="jz ka hu jv b fv kb kc l kd ke">apt-get update<br/>apt-get install -y unzip</span><span id="6088" class="jz ka hu jv b fv kf kc l kd ke">unzip /tmp/wso2ei-6.1.1.zip -d /wso2</span><span id="0ce9" class="jz ka hu jv b fv kf kc l kd ke">mv -f /tmp/resources/changed_config_files /wso2/wso2ei-6.1.1/path_to_the_relevant_config</span></pre><p id="01b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不要担心产品zip文件是如何进入/tmp的，我将在本文后面解释它。由此，您必须记住的主要思想是，首先您需要安装相关的应用程序，然后将产品zip解压缩到所需的文件夹，并用您放入resources目录的更新配置文件覆盖产品发行版中的相关配置文件。将“changed_config_files”重命名为文件名，将“path_to_the_relevant_config”重命名为分发中文件的路径。</p><p id="b8d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">完成product-setup.sh文件后，让我们看看<em class="jp">docker文件</em>。<em class="jp"> </em>这是docker在构建docker映像时调用的文件。在这个文件中，我们还可以指定docker映像的启动脚本。我先举一个适合当前语境的例子，逐行解释。</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="08b2" class="jz ka hu jv b fv kb kc l kd ke">FROM airdock/oracle-jdk:1.8</span><span id="a6fd" class="jz ka hu jv b fv kf kc l kd ke">COPY wso2ei-6.1.1.zip /tmp<br/>ADD resources /tmp/resources</span><span id="d22f" class="jz ka hu jv b fv kf kc l kd ke">RUN chmod +x /tmp/resources/product-setup.sh &amp;&amp; /tmp/resources/product-setup.sh<br/>RUN chmod +x /tmp/resources/wait.sh</span><span id="9cfc" class="jz ka hu jv b fv kf kc l kd ke">CMD ["sh", "/wso2/wso2ei-6.1.1/bin/integrator.sh"]</span></pre><p id="8722" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">来自''的第一个'<em class="jp">'命令指定要用于当前停靠图像的基本停靠图像。这可以根据需求而改变。因为我试图在docker容器上运行一个需要java的产品，所以我选择了一个带有java的图像。如果您需要其他服务，那么您可以使用不同的预构建映像。请访问<a class="ae kg" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> docker-hub </a>浏览可用的预建图像。您只需从这里选择一个图像，然后找到导入地址，然后使用来自</em>的<em class="jp">命令来使用这个预先构建的图像。</em></p><p id="ff52" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">‘复制’</em>命令用于将<em class="jp"> </em>产品分发复制到docker图像中。在这里，我将它复制到容器内的<em class="jp"> /tmp </em>文件夹中。然后将资源目录添加到容器中。这些路径在product-setup.sh文件中用于执行各种任务。然后授予对product-setup.sh的执行权限并运行它。"<em class="jp"> CMD" </em>命令指定<em class="jp">integrator . sh</em><strong class="it hv"/>必须在容器启动时运行。</p><p id="5b21" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们已经完成了<em class="jp"> product-setup.sh </em>和<em class="jp"> Dockerfile，</em>我们可以继续定义我们需要运行的任何其他服务。从包含<em class="jp"> Dockerfile </em>的目录中出来，为其余的服务创建文件夹，以我们之前所做的相同方式，您也可以定义其余的服务。在定义了所有服务的设置之后，我们可以使用docker-compose来构建和运行这些服务。首先，我们需要在<em class="jp"> service_root </em>目录之外定义<em class="jp"> docker-compose.yml </em>文件。你可以参考<a class="ae kg" href="https://docs.docker.com/compose/compose-file/compose-file-v2/#blkio_config" rel="noopener ugc nofollow" target="_blank"> <em class="jp">这个</em> </a> <em class="jp"> </em>文档来更好地了解<em class="jp"> docker-compose.yml. </em>在这篇文章中我将简要解释你如何使用docker-compose来构建和运行这些定义的容器。请参见下面的示例<em class="jp"> docker-compose.yml </em>文件。</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="68d0" class="jz ka hu jv b fv kb kc l kd ke">version: '2'</span><span id="a574" class="jz ka hu jv b fv kf kc l kd ke">services:<br/>  integrator-service:<br/>    image: integrator-img<br/>    container_name: integrator-svc<br/>    build: ./ei-setup<br/>    depends_on:<br/>      - analytics-service<br/>      - mb-service<br/>    ports:<br/>      - 9443:9443<br/>      - 8243:8243<br/>      - 8280:8280</span></pre><p id="61c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第一行指定了我们使用的docker-compose定义的版本。然后在services下，您可以定义您想要构建的服务的详细信息，并开始使用docker-compose。在这个文件中，在<em class="jp"> services </em>下，我们为我们的服务命名(在本例中为“<em class="jp"> integrator-service </em>”)。“Image”指定构建映像的名称，“container_name”指定容器的名称，“build”指定特定服务的文件夹名称，“depends_on”指定在当前服务启动之前需要启动哪些服务。不过这有点棘手，因为当您列出一组需要首先启动的服务时，docker-compose会确保在当前服务之前启动它们，但不会确保在启动当前服务之前这些服务已经启动并运行。因此，如果使用依赖服务，您可能会遇到问题，但是在这种情况下，您只需在服务的启动脚本中添加一行，等待这些依赖服务启动并运行。然后在“ports”部分，您可以指定哪些端口需要对外公开(<em class="jp">product _ port:container _ port</em>是公开端口的语法。</p><p id="4d69" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另外很重要的一点是，如果你想在这些服务之间进行通信，你可以把它们称为<strong class="it hv"> <em class="jp">协议://service_name:port </em> </strong>。协议可以是http、tcp等。服务名和端口必须在<em class="jp"> docker-compose.yml </em>中定义。</p><p id="10c6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，您已经设置好了，您可以运行命令<strong class="it hv"><em class="jp">docker-compose build&amp;&amp;docker-compose up，</em> </strong>来构建并运行docker容器。</p><p id="a748" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我希望这篇文章有助于理解如何使用docker封装WSO2产品。如果您在试用时遇到任何问题，请在评论区提出。我会尽快回答所有的问题。</p></div></div>    
</body>
</html>