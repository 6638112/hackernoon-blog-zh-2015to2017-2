<html>
<head>
<title>On Good Domain Decomposition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于好的区域分解</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/on-good-domain-decomposition-385ee8ce5a3?source=collection_archive---------6-----------------------#2017-09-16">https://medium.com/hackernoon/on-good-domain-decomposition-385ee8ce5a3?source=collection_archive---------6-----------------------#2017-09-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="f795" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">或者如何制作可以工作的物品</h2></div><p id="2988" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我用一些特征来检查我的软件。大概最主要的是<a class="ae kf" href="http://www.codemanship.co.uk/parlezuml/blog/?postid=934" rel="noopener ugc nofollow" target="_blank">复用抽象原则</a>。它说只有当有多个实现时，你的抽象才是好的。换句话说，它认为抽象应该是抽象的。</p><p id="10d8" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">马克·西曼有一篇关于解决方案空间方法的很好的<a class="ae kf" href="http://blog.ploeh.dk/2010/12/03/Towardsbetterabstractions/" rel="noopener ugc nofollow" target="_blank">文章</a>，可以带来更好的抽象。</p><p id="7039" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是OOP比你开始写代码要早得多。当你和你的领域专家交谈时，它就开始了。</p><h2 id="1e71" class="kg kh hu bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la dt translated">了解你的问题</h2><p id="4884" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated">柏拉图在他的<a class="ae kf" href="https://en.wikipedia.org/wiki/Phaedrus_(dialogue)" rel="noopener ugc nofollow" target="_blank">菲德鲁斯</a>对话中<a class="ae kf" href="http://www.perseus.tufts.edu/hopper/text?doc=Perseus%3Atext%3A1999.01.0174%3Atext%3DPhaedrus%3Apage%3D265" rel="noopener ugc nofollow" target="_blank">说</a>我们的设计应该是领域驱动的，应该从问题空间开始。他对这一原则描述如下:</p><blockquote class="lg lh li"><p id="c678" class="jj jk lj jl b jm jn iv jo jp jq iy jr lk jt ju jv ll jx jy jz lm kb kc kd ke hn dt translated">感知并把分散的细节集中在一个想法中的原则，这样一个人就可以通过定义来明确他想要解释的特定事物；就像现在，在谈到爱<em class="hu">【我想这里指的是厄洛斯】</em>，<strong class="jl hv">我们说了他是什么，并定义了它，无论是好是坏</strong>。当然，通过这种方式，话语获得了清晰和一致性。</p></blockquote><p id="f4a8" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这与帕纳斯将系统分解成模块的方法产生了共鸣。</p><h2 id="372c" class="kg kh hu bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la dt translated">分解你的问题空间</h2><p id="3408" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated">当我弄清楚我的领域后，我开始分解。<a class="ae kf" href="http://www.perseus.tufts.edu/hopper/text?doc=Perseus%3Atext%3A1999.01.0174%3Atext%3DPhaedrus%3Asection%3D265e" rel="noopener ugc nofollow" target="_blank">柏拉图描述了</a>分解必须具备的主要特征:</p><blockquote class="lg lh li"><p id="beee" class="jj jk lj jl b jm jn iv jo jp jq iy jr lk jt ju jv ll jx jy jz lm kb kc kd ke hn dt translated">[原则]再次将事物分类，在自然连接处，而不是试图打破任何部分，就像一个糟糕的雕刻师那样。</p></blockquote><p id="e91a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">事实证明，过程化编程对于良好的分解来说并不是一个好的指南。数据和程序都不适合这个目的。但是什么会呢？好吧，既然我们在这里做OOP，答案是行为就不足为奇了。上面提到的自然关节是物体的边界。<br/>顺便说一下，同样的原理也适用于<a class="ae kf" rel="noopener" href="/@wrong.about/how-to-define-service-boundaries-251c4fc0f205">识别服务边界</a>。</p><h2 id="9793" class="kg kh hu bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la dt translated">实际后果</h2><p id="f7c3" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated">第一个是右分解产生的元素是可组合的，而抽象的数量相对较少。这不是一个科学的说法，更像是经验性的。看化学:元素周期表不到130个元素。<a class="ae kf" href="https://en.wikipedia.org/wiki/Euclidean_geometry" rel="noopener ugc nofollow" target="_blank">欧几里德几何</a> : 13条公理。代数:10个数和一堆运算。重用抽象原则自然得到满足。</p><p id="e10d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">可组合性意味着实体共享相同的接口。意味着我们身边有很多可替代的东西。我不在乎哪辆公共汽车带我去办公室，我只在乎它的号码。我不在乎穿什么牛仔裤——尺码可能是唯一的标准。或者我用什么椅子，桌子，笔。</p><h2 id="a650" class="kg kh hu bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la dt translated">隐喻引导你寻找物品</h2><p id="2093" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated"><a class="ae kf" href="http://davewest.us" rel="noopener ugc nofollow" target="_blank">大卫·韦斯特</a>在他的书<a class="ae kf" href="https://www.amazon.com/Object-Thinking-Developer-Reference-David/dp/0735619654" rel="noopener ugc nofollow" target="_blank">对象思维</a>中描述了一些有用的隐喻来描述权利分解。它们都适用于问题空间，即领域。</p><p id="8a1d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">第一个是乐高。乐高里有很多零件，但是零件的种类却少得多。所有的部分都是高度可组合的。<br/>第二个是人称隐喻。我在读这本书之前用过它，所以它对我来说是最自然的。更具体地说，我想象的不仅仅是一个人，而是一个成年人，他能做决定，分辨是非，决定如何做他或她应该做的任何事情。<br/>第三个是剧场。每个演员都知道如何扮演自己的角色，而且每个演员都不介意替换一些同事。我喜欢的对象协作的比喻是蚂蚁。科学证明(甚至有一本书里有链接！)认为绝对没有蚂蚁的编排。他们都是平等的。物体也应该如此。</p><h2 id="2022" class="kg kh hu bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la dt translated">例子</h2><p id="1009" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated">我试图在设计<a class="ae kf" href="https://github.com/wrong-about-everything/ooDateTime" rel="noopener ugc nofollow" target="_blank"> DateTime </a>库时应用这些原则。<br/>我基本上需要两件事:从任意格式创建datetime对象，并以任意格式输出它们。因此有两个接口— <a class="ae kf" href="https://github.com/wrong-about-everything/ooDateTime/blob/master/src/ISO8601DateTime.php" rel="noopener ugc nofollow" target="_blank">格式化日期时间</a>和<a class="ae kf" href="https://github.com/wrong-about-everything/ooDateTime/blob/master/src/FormattedDateTime.php" rel="noopener ugc nofollow" target="_blank">格式化日期时间</a>。此外，我需要一个界面与间隔工作。三个目录对应于这些接口。<br/>我还需要一种相对指定约会时间的可能性。所以我有一个时间轴目录与三个类:过去，现在和未来。<br/>最后，我想要一个比较能力，我用两个类来表达它:<a class="ae kf" href="https://github.com/wrong-about-everything/ooDateTime/blob/master/src/comparison/Min.php" rel="noopener ugc nofollow" target="_blank"> Min </a>和<a class="ae kf" href="https://github.com/wrong-about-everything/ooDateTime/blob/master/src/comparison/Max.php" rel="noopener ugc nofollow" target="_blank"> Max </a>。可以实现与它们的任何比较。</p><p id="3adb" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">下面是一个可以用此库表示的内容示例:</p><pre class="ln lo lp lq fq lr ls lt lu aw lv dt"><span id="cf1e" class="kg kh hu ls b fv lw lx l ly lz">// outputs true<br/><br/>var_dump(<br/>    (new Max(<br/>        new Future(<br/>            new Past(<br/>                new FromMilliseconds(<br/>                    (new ToMilliseconds(<br/>                        new FromISO8601('2017-08-18T15:08:13+04:00')<br/>                    ))<br/>                        -&gt;value()<br/>                ),<br/>                new ISO8601Interval('P1Y2M21DT24H56M26S')<br/>            ),<br/>            new ISO8601Interval('PT23H')<br/>        ),<br/>        new Now()<br/>    ))<br/>        -&gt;equalsTo(new Now())<br/>);</span></pre><p id="cef1" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对象是可组合的，类比接口多得多。所以我的目标实现了。</p><p id="2137" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个库目前还只是一个实验，它缺乏一些功能，并且已经存在一些问题(我不喜欢<code class="eh ma mb mc ls b">equalsTo()</code>方法中的复制粘贴)，但是整个分解过程似乎很好。</p><h2 id="7802" class="kg kh hu bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la dt translated">总结一下</h2><p id="d88b" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated">所以从问题空间开始——你的领域。使用行为作为分解标准。记住这些比喻。让可组合性成为你的目标。</p></div></div>    
</body>
</html>