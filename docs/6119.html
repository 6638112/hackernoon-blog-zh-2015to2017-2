<html>
<head>
<title>Dive Into GraphQL Part I: What’s Wrong With REST?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入GraphQL第一部分:休息怎么了？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/dive-into-graphql-part-i-whats-wrong-with-rest-709ebcb898dc?source=collection_archive---------11-----------------------#2017-09-04">https://medium.com/hackernoon/dive-into-graphql-part-i-whats-wrong-with-rest-709ebcb898dc?source=collection_archive---------11-----------------------#2017-09-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/fa14568c804b397982937005dd615765.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pRMUjeAXKr_Tvq_djPSELg.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">REST in peace</figcaption></figure><p id="c015" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这是GraphQL系列的第一篇文章。令人惊讶的是，这篇文章并没有谈论<a class="ae ke" href="https://hackernoon.com/tagged/graphql" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>本身，而是谈论它所解决的问题。他们大多归结为休息。</p><p id="20fe" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">更新25/09/17:修正多个HTTP请求影响浏览器性能的不准确性，以及遗漏的HTTP/2提及。</p><h1 id="f5ed" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">REST解锁的API中心架构</h1><p id="564b" class="pw-post-body-paragraph jg jh hu ji b jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz lh kb kc kd hn dt translated">首先，休息<em class="li">本身</em>没有问题。REST是构建以API为中心的架构的完美解决方案。在REST之前，公开(SOAP) web服务需要复杂的工具、数小时的配置和大量的手册。消费这样的web服务需要专有的SDK、资源密集型的准备和验证，还需要大量的手册。当时，除了微软的，从浏览器消费网络服务甚至是不可想象的(想想用JavaScript解析XML WSDL)<a class="ae ke" href="https://msdn.microsoft.com/en-us/library/windows/apps/ms531063(v=vs.85).aspx" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lj"><img src="../Images/896e571f09c5c8a6c536135728833505.png" data-original-src="https://miro.medium.com/v2/resize:fit:594/format:webp/1*d-A9fcbv3vam2RKTRRhZfQ.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">API-centric architecture</figcaption></figure><p id="3bf6" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">2000年发明的REST和2007年普及的<a class="ae ke" href="http://weblog.rubyonrails.org/2007/1/19/rails-1-2-rest-admiration-http-lovefest-and-utf-8-celebrations/" rel="noopener ugc nofollow" target="_blank"/>因其简单的语法而大放异彩。REST使得请求和响应易于构建和解析，这就是为什么世界各地的前端和后端开发人员迅速采用它的原因。REST也是无状态和可缓存的，这使得伸缩变得轻而易举。它工作得如此之好，以至于今天，以API为中心的架构无处不在，REST是首选的工具。</p><p id="9495" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">但自2007年以来，世界已经发生了变化。REST的一些缺点，在当时是一个很好的权衡，现在却成了生产率、性能和可维护性的一大难题。</p><p id="3b0b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们来看看为什么。</p><h1 id="712c" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">互联网现在是移动的</h1><p id="8fd5" class="pw-post-body-paragraph jg jh hu ji b jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz lh kb kc kd hn dt translated">2015年，谷歌宣布<a class="ae ke" href="http://searchengineland.com/its-official-google-says-more-searches-now-on-mobile-than-on-desktop-220369" rel="noopener ugc nofollow" target="_blank">首次从移动设备获得的搜索量超过了桌面</a>。自那以后，随着发展中国家跳上移动互联网的潮流，完全跳过有线连接，移动互联网消费稳步增长。所以让我们面对现实:我们今天构建的网络应用程序将主要在移动设备上使用，而不是在WiFi上。</p><p id="8159" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">4G或3G上的移动设备比WiFi上的慢，因为<a class="ae ke" href="https://hpbn.co/optimizing-for-mobile-networks/#anticipate-network-latency-overhead" rel="noopener ugc nofollow" target="_blank">无线电通信的延迟开销</a>在4G上在100毫秒和600毫秒之间波动(在3G上高达3500毫秒)，还因为移动连接的质量变化很大，除了延迟之外，还会影响吞吐量。</p><p id="373f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">对于单个HTTP请求，响应时间危险地接近1秒，根据UX专家Jakob Nielsen的说法，这是用户思想流动的极限。这意味着一个移动应用程序在不失去用户注意力的情况下可以发出的HTTP请求的最大数量是<em class="li">一个</em>。</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div class="fe ff lo"><img src="../Images/390d61b4f01afdce2e78641d01a5997c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/0*7jCD07DVMNtrBkbn.jpg"/></div></figure><p id="b8a3" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们不要忘记电池寿命。无线电通信非常耗电，因此移动设备会尽快关闭设备无线电，失去与无线电塔建立的频道。为了进行新的HTTP请求，移动设备必须唤醒无线电，并向无线电塔请求一些带宽。如果应用程序设计者不考虑他们的HTTP请求，这会很快耗尽电池。</p><p id="694d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在移动设备上，以API为中心的应用程序特别容易受到延迟和电池寿命的影响，因为它们会疯狂地查询REST后端。</p><h1 id="3d96" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">面向服务的架构糟透了(对客户来说)</h1><p id="83f7" class="pw-post-body-paragraph jg jh hu ji b jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz lh kb kc kd hn dt translated">想象一下，一个类似Twitter的移动应用程序使用REST API作为后端。让我们列出应用程序显示主页必须获取的资源:</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lp"><img src="../Images/f8bdac95604ceaf2359f111a7e8aa5ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2xvdUQ47wAg_1_tF.png"/></div></div></figure><p id="29d9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">REST后端为每个端点暴露<em class="li">一个资源。因此，移动应用程序必须向几个端点发送请求:</em></p><ol class=""><li id="1eca" class="lq lr hu ji b jj jk jn jo jr ls jv lt jz lu kd lv lw lx ly dt translated"><code class="eh lz ma mb mc b">GET /user</code>抓取当前用户名和头像</li><li id="2aab" class="lq lr hu ji b jj md jn me jr mf jv mg jz mh kd lv lw lx ly dt translated"><code class="eh lz ma mb mc b">GET /notifications</code>获取未读通知的数量</li><li id="e633" class="lq lr hu ji b jj md jn me jr mf jv mg jz mh kd lv lw lx ly dt translated"><code class="eh lz ma mb mc b">GET /tweets</code>获取最近20条推文的列表</li><li id="c0d2" class="lq lr hu ji b jj md jn me jr mf jv mg jz mh kd lv lw lx ly dt translated"><code class="eh lz ma mb mc b">GET /users?ids=[123,456,789,...]</code>获取最近20条推文作者的简介</li><li id="929d" class="lq lr hu ji b jj md jn me jr mf jv mg jz mh kd lv lw lx ly dt translated"><code class="eh lz ma mb mc b">GET /tweet_stats?ids=[123,456,789,...]</code>获取最近20条推文的统计数据</li><li id="ceb9" class="lq lr hu ji b jj md jn me jr mf jv mg jz mh kd lv lw lx ly dt translated"><code class="eh lz ma mb mc b">POST /views</code>发送屏幕上显示的推文的浏览统计数据</li></ol><p id="e286" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这是6个HTTP请求——这还不包括对头像图像或嵌入媒体的请求。请求4和5必须等待请求3的返回。因此，这个简单的页面需要1秒以上的时间来获取所需的数据，尽管移动浏览器可以发出4到6个并发HTTP请求。</p><p id="9b32" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">此外，网络和移动应用倾向于使用不止一个<em class="li">服务提供商</em>(理解:不止一个HTTP域)。应用程序依赖不同的REST提供者进行<a class="ae ke" href="https://developer.github.com/v3/oauth_authorizations/" rel="noopener ugc nofollow" target="_blank">认证</a>、<a class="ae ke" href="https://en.gravatar.com/site/implement/" rel="noopener ugc nofollow" target="_blank">头像</a>、<a class="ae ke" href="https://disqus.com/api/docs/" rel="noopener ugc nofollow" target="_blank">评论</a>、<a class="ae ke" href="https://developers.google.com/analytics/" rel="noopener ugc nofollow" target="_blank">分析</a>等等，这是很常见的。在这种情况下，延迟问题变得更加棘手，因为每个新域都需要特定的DNS查找，而HTTP客户端无法在域之间共享keepalive连接。</p><p id="01f9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">总而言之，REST的主要缺点是默认情况下会使客户端变慢，尤其是在移动设备上。</p><h1 id="0a5d" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">分组请求需要工作</h1><p id="f15d" class="pw-post-body-paragraph jg jh hu ji b jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz lh kb kc kd hn dt translated">一种解决方案称为<a class="ae ke" href="http://jsonapi.org/format/#fetching-includes" rel="noopener ugc nofollow" target="_blank"> <em class="li">数据包含</em> </a>。这个想法是从一个端点请求几个相关的资源，希望服务器知道两者之间的关系。类似于:</p><p id="9c40" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh lz ma mb mc b">GET /tweets?include=authors,stats</code></p><p id="101d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这允许合并请求3、4和5，但仅此而已。数据包含不允许请求不相关数据的<em class="li">集合</em>(比如推文和通知)。</p><p id="dffe" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">2013年，脸书推出了另一种解决方案。他们称之为<a class="ae ke" href="https://developers.facebook.com/docs/graph-api/making-multiple-requests" rel="noopener ugc nofollow" target="_blank">批次终点</a>。它是一个REST端点，在这里您可以在<code class="eh lz ma mb mc b">batch</code>查询参数中发送几个子请求:</p><pre class="lk ll lm ln fq mi mc mj mk aw ml dt"><span id="13ca" class="mm kg hu mc b fv mn mo l mp mq">curl \<br/>    -F 'access_token=...' \<br/>    -F 'batch=[{"method":"GET", "relative_url":"me"},{"method":"GET", "relative_url":"me/friends?limit=50"}]' \<br/>    https://graph.facebook.com</span></pre><p id="0765" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在内部，脸书服务器查询其数据存储，并将结果分组到单个JSON响应中:</p><pre class="lk ll lm ln fq mi mc mj mk aw ml dt"><span id="d9f5" class="mm kg hu mc b fv mn mo l mp mq">[<br/>    { "code": 200,<br/>      "headers":[<br/>          { "name": "Content-Type",<br/>            "value": "text/javascript; charset=UTF-8" }<br/>      ],<br/>      "body": "{\"id\":\"…\"}"},<br/>    { "code": 200,<br/>      "headers":[<br/>          { "name":"Content-Type",<br/>            "value":"text/javascript; charset=UTF-8"}<br/>      ],<br/>      "body":"{\"data\": [{…}]}}<br/>]</span></pre><p id="1ae9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">对于纯粹主义者来说，这个批处理端点根本不是RESTful的，因为它没有真正公开一个<em class="li">资源</em>。此外，当您需要将一个调用的响应(例如，tweet列表)传递给另一个调用(tweet作者简介)时，它不起作用。</p><p id="57db" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">最后，实现批处理端点策略需要时间。基本上就像开发一个<em class="li">代理服务器</em>。我知道这一点，因为marmelab开发了一个Node.js中间件，名为<a class="ae ke" href="https://github.com/marmelab/koa-multifetch" rel="noopener ugc nofollow" target="_blank"> koa-multifetch </a>。这是每个应用程序开发人员都应该包含在他们的REST服务器中的一个组件，以便达到一个不错的性能水平。这就是开发一个快速移动应用程序如此昂贵的原因。</p><h1 id="95a8" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">没有标准意味着标准太多</h1><p id="ad74" class="pw-post-body-paragraph jg jh hu ji b jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz lh kb kc kd hn dt translated">REST不是一个标准，它是一种架构风格，一套松散的原则。这些原则给开发人员留下了很大的实现空间。例如，<a class="ae ke" href="https://stackoverflow.com/questions/2342579/http-status-code-for-update-and-delete" rel="noopener ugc nofollow" target="_blank">删除请求</a>的推荐HTTP响应代码可以是200或204。至于分页，您可以使用一个<code class="eh lz ma mb mc b">page</code>查询参数，一个<code class="eh lz ma mb mc b">Content-Range</code>头，或者，为什么不呢，<code class="eh lz ma mb mc b">limit</code>和<code class="eh lz ma mb mc b">offset</code>。查询和响应缺乏唯一的REST标准导致REST标准激增:Open API、OData、Hydra、JSend等。</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/941cca98ae276c8245fc057e86137435.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*go_d9UZVDPyx5LiQ.png"/></div></figure><p id="c735" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">当你需要查询一个web服务的时候，你不能只使用一个标准的REST客户端，因为<em class="li">没有标准的REST客户端</em>。您必须从头构建一个定制的REST客户端，或者调整<a class="ae ke" href="https://github.com/mgonto/restangular" rel="noopener ugc nofollow" target="_blank">一个高度可配置和高度复杂的通用REST客户端</a>。不管怎样，这都需要时间。而当你需要开发一个web服务后端的时候，你不能只使用你语言的REST框架。您必须首先花一周时间与您周围的所有开发人员和软件架构师进行讨论，并尝试决定您应该使用哪种REST风格。哦，不要让我开始内容类型协商或<a class="ae ke" href="https://jeffknupp.com/blog/2014/06/03/why-i-hate-hateoas/" rel="noopener ugc nofollow" target="_blank"> HATEOAS </a>。</p><p id="192d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">开源热潮只是加速了这一趋势:今天，如果你需要一个REST库，你必须从一大堆选项中选择。仅JavaScript一项，就有超过900个rest客户端npm包<a class="ae ke" href="https://www.npmjs.com/search?q=rest%20client&amp;page=1&amp;ranking=optimal" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="3297" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">所以，是的，自由导致多样性，但在互联网数据通信的情况下，多样性意味着浪费。REST标准的缺乏极大地影响了开发速度。</p><h1 id="ed49" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">前端和后端开发人员需要一份合同</h1><p id="6d87" class="pw-post-body-paragraph jg jh hu ji b jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz lh kb kc kd hn dt translated">REST没有schema的概念，schema是一个确切描述web服务应该返回什么的契约。就像上面的标准一样，模式的缺失导致了可能的文档格式的多样性:JSON模式、RAML、Swagger等。</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/734dac8a9b930bcdb6d97bf4f8b213a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/0*sHs99SmspjdD2OSK.png"/></div></figure><p id="b4e7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在许多公司中，后端开发人员仍然使用Word文档来描述他们的API的资源和字段。一个API契约中要描述的东西太多了，手工制作的规范往往是不完整的。它们缺乏对错误情况、数据类型、参数边界等的描述。而且他们要花很长时间来写，所以他们总是过时。</p><p id="29ae" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">问题是，没有描述API的明确契约，前端和后端开发人员必须做出假设，直到他们将他们的组件连接在一起。他们做的假设越多，整合阶段持续的时间就越长。</p><p id="f78a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">REST中缺少单一模式会导致开发延迟，让开发人员感到沮丧。</p><h1 id="0441" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">敏捷导致臃肿的响应</h1><p id="0016" class="pw-post-body-paragraph jg jh hu ji b jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz lh kb kc kd hn dt translated">API往往会随着时间而变化。但是如果服务器API改变了，所有的消费者都会崩溃。</p><p id="7b98" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">通常的解决方案被称为<em class="li">版本控制</em>:服务器公开几个版本的web服务，对于一个给定的版本，API从不改变。当然，【REST版本控制没有标准，但是我们已经讨论过了。至于服务消费者，他们应该被告知新版本，并花时间更新他们的API调用。</p><p id="3bfd" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">然而，敏捷软件开发导致更短的发布周期。如今，<a class="ae ke" href="https://developer.github.com/changes/" rel="noopener ugc nofollow" target="_blank">一个流行的网络服务一个月可以很容易地改变几次</a>。要求开发人员如此频繁地更改他们的服务消费者的代码是不可取的。</p><p id="3c8b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这就是为什么有些API不使用版本控制而是用<a class="ae ke" href="https://www.mnot.net/blog/2012/12/04/api-evolution" rel="noopener ugc nofollow" target="_blank"> <em class="li">进化</em> </a>来代替。这个想法是<em class="li">永远不要删除或修改</em>资源响应中的字段，而是<em class="li">总是添加</em>一个新字段。例如，假设您已经为一个<code class="eh lz ma mb mc b">GET /users/:id</code>请求开发了如下响应:</p><pre class="lk ll lm ln fq mi mc mj mk aw ml dt"><span id="4695" class="mm kg hu mc b fv mn mo l mp mq">{<br/>    "id": 123,<br/>    "name": "John Doe"<br/>}</span></pre><p id="2b62" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">然后一个产品经理来了，要求能够在平板电脑上显示中间名——但是我们仍然需要在移动设备上显示和以前一样的名字。没问题，只需<em class="li">添加</em>一个新字段:</p><pre class="lk ll lm ln fq mi mc mj mk aw ml dt"><span id="19d5" class="mm kg hu mc b fv mn mo l mp mq">{<br/>    "id": 123,<br/>    "name": "John Doe",<br/>    "full_name": "John W. Doe"<br/>}</span></pre><p id="9181" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">直到一个新的产品经理(他们每6个月换一次)为了支持名字后缀把UI彻底改了，因为新老板坚持要叫埃德温·丹尼森·洛厄尔三世。随着最终用户逐渐升级他们的应用程序，支持以前的名称格式也很重要。好了，我们来添加更多的字段。</p><pre class="lk ll lm ln fq mi mc mj mk aw ml dt"><span id="4c88" class="mm kg hu mc b fv mn mo l mp mq">{<br/>    "id": 123,<br/>    "name": "John Doe",<br/>    "full_name": "John W. Doe",<br/>    "full_full_name": "John W. Doe Sr."<br/>}</span></pre><p id="41b7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">你明白了。</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div class="fe ff mt"><img src="../Images/1ca4593936728d1d993ab6be82b54fd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oaTbgMy2KXvIjwy2.jpg"/></div></figure><p id="7701" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">问题是web服务存在的时间越长，资源就越多。在Twitter API中，一条tweet由超过30个字段组成，如果你想在会议室的电视机上显示关于你公司的热门tweet，其中大部分是不需要的。</p><p id="ad51" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">但是REST只包含资源的概念——没有<em class="li">字段</em>的概念，例如，您可以使用它将响应限制为您需要的细节。缓解这种情况的尝试(<a class="ae ke" href="http://jsonapi.org/format/#fetching-sparse-fieldsets" rel="noopener ugc nofollow" target="_blank">稀疏字段集</a>，<a class="ae ke" href="https://developers.google.com/google-apps/tasks/performance#partial" rel="noopener ugc nofollow" target="_blank">部分响应</a>)是存在的，但它们总是可选的。REST中的默认规则是需要整个资源，包括所有字段。所以REST web服务随着时间变得越来越慢，因为它们的响应越来越重。</p><h1 id="d475" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">仅HTTP CRUD</h1><p id="2ef8" class="pw-post-body-paragraph jg jh hu ji b jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz lh kb kc kd hn dt translated">REST是仿照HTTP的。它使用了HTTP动词(<code class="eh lz ma mb mc b">GET</code>、<code class="eh lz ma mb mc b">POST</code>、<code class="eh lz ma mb mc b">PUT</code>等)。)，需要HTTP传输，并且存在与HTTP相同的性能和安全问题。即使Roy Fielding最初的REST论文<a class="ae ke" href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_3_2" rel="noopener ugc nofollow" target="_blank">将REST描述为协议不可知的</a>，REST实际上<em class="li">只是HTTP。</em></p><p id="c223" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">此外，大多数关于REST的讨论只描述了CRUD(创建、检索、更新、删除)交互。对于其他通信场景(文件上传、命令、远程过程调用等)，您只能靠自己了。</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mu"><img src="../Images/15ce847001c2601fb376ce299e5341d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sqvMJ8rRqsfO-fV7.jpg"/></div></div></figure><p id="5d15" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">例如，许多现代应用程序需要实时更新。HTTP通信是基于一个请求和一个响应的，它不是为没有任何请求就推送更新而设计的。因此，在REST中处理发布/订阅场景需要一种相当复杂的方法:</p><ol class=""><li id="7c83" class="lq lr hu ji b jj jk jn jo jr ls jv lt jz lu kd lv lw lx ly dt translated">客户端A大约每10秒钟向中央服务器发送一个<code class="eh lz ma mb mc b">GET /events</code>请求。</li><li id="7e1f" class="lq lr hu ji b jj md jn me jr mf jv mg jz mh kd lv lw lx ly dt translated">一天，客户端B向中央服务器发送一个<code class="eh lz ma mb mc b">POST /events</code>请求，请求体中包含一个事件</li><li id="2944" class="lq lr hu ji b jj md jn me jr mf jv mg jz mh kd lv lw lx ly dt translated">下一次客户机A向中央服务器发送<code class="eh lz ma mb mc b">GET /events</code>请求时，它接收客户机B发出的事件</li></ol><p id="f89d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">太浪费资源了(尤其是在移动端)！HTTP REST领域的唯一解决方案是将客户机A变成服务器:</p><ol class=""><li id="3a96" class="lq lr hu ji b jj jk jn jo jr ls jv lt jz lu kd lv lw lx ly dt translated">服务器A向中央服务器发送一个<code class="eh lz ma mb mc b">POST /subscriptions</code>请求，回调URL<code class="eh lz ma mb mc b">http://serverA.com/remote_events</code>作为参数。</li><li id="43b5" class="lq lr hu ji b jj md jn me jr mf jv mg jz mh kd lv lw lx ly dt translated">客户端B向中央服务器发送一个<code class="eh lz ma mb mc b">POST /events</code>请求，请求体中包含一个事件。</li><li id="4123" class="lq lr hu ji b jj md jn me jr mf jv mg jz mh kd lv lw lx ly dt translated">中央服务器发送一个<code class="eh lz ma mb mc b">POST /remote_events</code>到服务器A，事件在主体中。</li></ol><p id="9f60" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">但是，如果客户端A是一个移动设备，您如何做到这一点呢？这是否意味着将每部智能手机都变成网络服务器？这不是一个可行的解决方案。</p><p id="f6d4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">像WebSockets或HTTP/2这样的现代协议解决了问题的一部分(协议)，但是它们没有指定要使用的数据交换格式。对于这些协议的发布/订阅来说，REST是不合适的。例如，WebSockets没有像HTTP那样的动词概念——只有消息。因此，除了REST之外，应用程序经常使用其他架构(如<a class="ae ke" href="http://wamp-proto.org/faq/" rel="noopener ugc nofollow" target="_blank"> WAMP </a>)来处理这些场景。</p><h1 id="e976" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">解决方案</h1><p id="248a" class="pw-post-body-paragraph jg jh hu ji b jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz lh kb kc kd hn dt translated">总而言之，其余的<a class="ae ke" href="https://hackernoon.com/tagged/architecture" rel="noopener ugc nofollow" target="_blank">架构</a>使得应用程序开发缓慢、困难、昂贵，并且功能过于有限。这些问题是真实存在的。许多公司苦于休息，许多公司试图找到更好的替代方案。</p><p id="8246" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">也许我们可以通过添加REST缺少的所有东西来修补REST:用于请求多路复用的<a class="ae ke" href="https://hpbn.co/http2/#request-and-response-multiplexing" rel="noopener ugc nofollow" target="_blank">HTTP/2</a>、<a class="ae ke" href="https://github.com/marmelab/koa-multifetch" rel="noopener ugc nofollow" target="_blank">批处理端点</a>、<a class="ae ke" href="http://jsonapi.org/format/#fetching-sparse-fieldsets" rel="noopener ugc nofollow" target="_blank">稀疏字段集选择器</a>、<a class="ae ke" href="https://github.com/OAI/OpenAPI-Specification" rel="noopener ugc nofollow" target="_blank">模式</a>、<a class="ae ke" href="https://swagger.io/" rel="noopener ugc nofollow" target="_blank"> Swagger文档</a>等。有像<a class="ae ke" href="https://api-platform.com/" rel="noopener ugc nofollow" target="_blank"> API平台</a>这样的完整框架致力于这项任务。我的观点是，这就像试图用叉子喝汤。你可能最终会设法做到，但这真的是个好主意吗？我认为REST并不真正符合现代web应用程序的需求。考虑到Marmelab，我的公司，在REST上投资了多少，这是很不幸的。</p><p id="9d18" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">为什么不用SQL over HTTP？SQL有<code class="eh lz ma mb mc b">UNION</code>、<code class="eh lz ma mb mc b">JOIN</code>、<code class="eh lz ma mb mc b">HAVING</code>、<code class="eh lz ma mb mc b">GROUP BY</code>，而且是标准化的。根据数据库模式验证查询。但是SQL将可能的操作限制为<code class="eh lz ma mb mc b">SELECT</code>、<code class="eh lz ma mb mc b">CREATE</code>、<code class="eh lz ma mb mc b">UPDATE</code>和<code class="eh lz ma mb mc b">DELETE</code>，所以在用例方面还是太有限了。SQL也有很强的关系偏向，这使得它对于查询文档或图形数据库来说很不理想。但是让我们保留使用声明式查询语言的想法。</p><p id="6a69" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果您认为可以通过使用普通的远程过程调用(RPC)来解决功能有限的缺点，那么您的思路就对了。但是风险是退回到<a class="ae ke" href="https://en.wikipedia.org/wiki/SOAP" rel="noopener ugc nofollow" target="_blank">肥皂</a>，没有人想再次陷入<a class="ae ke" href="http://web.archive.org/web/20070113213839/http://www.loudthinking.com/arc/000602.html" rel="noopener ugc nofollow" target="_blank">极度复杂的坑</a>。</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mv"><img src="../Images/2b2ec75b9b0574d34e3b5bea00dca5a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*15xDYApa1OHfbKc9.jpg"/></div></div></figure><p id="a23a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">Google发明了<a class="ae ke" href="https://developers.google.com/protocol-buffers/" rel="noopener ugc nofollow" target="_blank">协议缓冲区</a>来解决性能和模式的痛点，并于2008年将其公之于众。它是一种语言中立、平台中立的可扩展机制，用于序列化结构化数据。这是一个很好的解决方案，但是它没有解决复杂查询和聚合的问题。另一个RPC二进制协议Apache Thrift 也没有。</p><p id="8645" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">更接近圣杯的是网飞在2015年年中开源的Falcor。Falcor既是服务器中间件，也是客户端SDK。但它是工具，不是架构。而且是纯JavaScript的；如果你做的是Objective-C或者Kotlin，那你就不走运了。Falcor不提供模式和静态类型，并且它缺乏强大的查询语言。</p><h1 id="7a0b" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">结论</h1><p id="2244" class="pw-post-body-paragraph jg jh hu ji b jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz lh kb kc kd hn dt translated">一定有更好的办法。我们真正需要的是用一种新的架构来取代REST，这种架构允许:</p><ol class=""><li id="851e" class="lq lr hu ji b jj jk jn jo jr ls jv lt jz lu kd lv lw lx ly dt translated">查询资源的集合(例如，在一个往返行程中的tweets和profile)，甚至来自不同的域</li><li id="a2a6" class="lq lr hu ji b jj md jn me jr mf jv mg jz mh kd lv lw lx ly dt translated">查询明确的字段列表，而不是完整的资源</li><li id="d6ee" class="lq lr hu ji b jj md jn me jr mf jv mg jz mh kd lv lw lx ly dt translated">提供描述请求和响应语法的模式</li><li id="d490" class="lq lr hu ji b jj md jn me jr mf jv mg jz mh kd lv lw lx ly dt translated">成为一个标准，但不要太依赖于HTTP协议</li><li id="ceda" class="lq lr hu ji b jj md jn me jr mf jv mg jz mh kd lv lw lx ly dt translated">支持现成的发布/订阅场景</li><li id="8f10" class="lq lr hu ji b jj md jn me jr mf jv mg jz mh kd lv lw lx ly dt translated">将重点从服务器转移到客户端。</li></ol><p id="64e4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我相信脸书最近发布的一个创新工具解决了这个问题(提示:它以G开头)。阅读本系列的下一篇文章来发现它的样子。</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mw"><img src="../Images/25b0c1a164430ff33d9e6457149907cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VLJZhsuPVTL1RvJ9.jpg"/></div></div></figure><p id="ead2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果你想阅读其他作者关于这个主题的更多内容，我推荐以下文章:</p><ul class=""><li id="e9b6" class="lq lr hu ji b jj jk jn jo jr ls jv lt jz lu kd mx lw lx ly dt translated"><a class="ae ke" href="https://0x2a.sh/from-rest-to-graphql-b4e95e94c26b" rel="noopener ugc nofollow" target="_blank">从休息到写作</a>，作者雅各布·吉莱斯皮</li><li id="a525" class="lq lr hu ji b jj md jn me jr mf jv mg jz mh kd mx lw lx ly dt translated"><a class="ae ke" href="https://www.howtographql.com/basics/1-graphql-is-the-better-rest/" rel="noopener ugc nofollow" target="_blank"> GraphQL是GraphCool团队开发的更好的REST </a></li><li id="0175" class="lq lr hu ji b jj md jn me jr mf jv mg jz mh kd mx lw lx ly dt translated">阿波罗团队的GraphQL与REST </li><li id="cdf6" class="lq lr hu ji b jj md jn me jr mf jv mg jz mh kd mx lw lx ly dt translated">萨梅尔·布纳的《安息API是安息API》</li></ul></div><div class="ab cl my mz hc na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="hn ho hp hq hr"><p id="dfc2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="li">原载于2017年9月4日marmelab.com</em><a class="ae ke" href="https://marmelab.com/blog/2017/09/04/dive-into-graphql-part-i-what-s-wrong-with-rest.html" rel="noopener ugc nofollow" target="_blank"><em class="li"/></a><em class="li">。</em></p><figure class="lk ll lm ln fq iv"><div class="bz el l di"><div class="nf ng l"/></div></figure></div></div>    
</body>
</html>