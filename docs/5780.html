<html>
<head>
<title>Repatch — the simplified Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重新修补—简化的Redux</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/repatch-the-simplified-redux-2c4aa5c25fa9?source=collection_archive---------3-----------------------#2017-08-16">https://medium.com/hackernoon/repatch-the-simplified-redux-2c4aa5c25fa9?source=collection_archive---------3-----------------------#2017-08-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="74af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我已经参与<a class="ae jp" href="https://www.npmjs.com/package/react" rel="noopener ugc nofollow" target="_blank"> react </a> - <a class="ae jp" href="https://www.npmjs.com/package/redux" rel="noopener ugc nofollow" target="_blank"> redux </a>项目好几年了。在我第一次见到flux之后，我对它的表达能力印象深刻，它描述了与其他数据流概念相反的复杂用例，当项目的复杂性增加时，它会引起许多麻烦。</p><p id="90b0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">动作控制数据流概念简单明了。</strong>数据更改可以被描述为具有最小负载的动作。这些操作为应用程序的生命周期创建了一个确定的、与时间无关的历史。应用程序在给定点的状态可以通过在链中选择一个动作来还原。</p><p id="19f3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Redux的概念有许多理论原理和优点，但我不打算谈论它们。不可变性只有一个主要缺点:它的成本。但是<strong class="it hv">我们必须为不可变数据处理付出的代价是通过避免React应用程序中的重渲染和重排版得到的多重回报。我们总是可以跟踪两个连续状态之间的差异，这就是为什么我不能把不变性列为Redux的缺点。</strong></p><h1 id="227c" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">动机</h1><p id="61e5" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">Redux还有一个缺点:令人痛苦的冗长。</p><p id="8bd7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设我们想要创建一个异步动作，该动作获取用户并将其保存在Redux store实例中。我们需要3个动作定义:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="7498" class="lc jr hu ky b fv ld le l lf lg">const START_FETCHING_USERS = "START_FETCHING_USERS"; <br/>const RESOLVE_FETCHING_USERS = "RESOLVE_FETCHING_USERS"; <br/>const REJECT_FETCHING_USERS = "REJECT_FETCHING_USERS";</span></pre><p id="2213" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第一个动作类型<code class="eh lh li lj ky b">START_FETCHING_USERS</code>启动流程，<code class="eh lh li lj ky b">RESOLVE_FETCHING_USERS</code>提供新的一组用户，如果获取过程中出现错误，则发出<code class="eh lh li lj ky b">REJECT_FETCHING_USERS</code>。</p><p id="61df" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们看看动作创作者:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="3e64" class="lc jr hu ky b fv ld le l lf lg"><strong class="ky hv">const</strong> startFetchingUsers = () =&gt; ({ type: START_FETCHING_USERS });  <br/><strong class="ky hv">const</strong> resolveFetchingUsers = users =&gt; ({ type: RESOLVE_FETCHING_USERS, users });  <br/><strong class="ky hv">const</strong> rejectFetchingUsers = error =&gt; ({ type: RESOLVE_FETCHING_USERS, error });</span></pre><p id="4e9d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">减速器:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="3e42" class="lc jr hu ky b fv ld le l lf lg"><strong class="ky hv">const</strong> initState = {  <br/> isFetching: false,<br/> users: [],<br/> error: null<br/>}</span><span id="0926" class="lc jr hu ky b fv lk le l lf lg"><strong class="ky hv">const</strong> reducer = (state = initState, action) =&gt; {  <br/> <strong class="ky hv">switch</strong> (action.type) {<br/>   <strong class="ky hv">case</strong> START_FETCHING_USERS: <strong class="ky hv">return</strong> {<br/>     ...state,<br/>     isFetching: true<br/>   };<br/>   <strong class="ky hv">case</strong> RESOLVE_FETCHING_USERS: <strong class="ky hv">return</strong> {<br/>     ...state,<br/>     isFetching: false,<br/>     users: action.users<br/>   };<br/>   <strong class="ky hv">case</strong> REJECT_FETCHING_USERS: <strong class="ky hv">return</strong> {<br/>     ...state,<br/>     isFetching: false,<br/>     error: action.error<br/>   };<br/>   <strong class="ky hv">default</strong>: <strong class="ky hv">return</strong> state;<br/> }<br/>}</span></pre><p id="d0e6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">剩下的工作就是实现async <a class="ae jp" href="https://www.npmjs.com/package/redux-thunk" rel="noopener ugc nofollow" target="_blank"> thunk </a>动作创建器:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="9674" class="lc jr hu ky b fv ld le l lf lg"><strong class="ky hv">const</strong> fetchUsers = () =&gt; <strong class="ky hv">async</strong> (dispatch, getState, { api }) =&gt; {  <br/> dispatch(startFetchingUsers());<br/> <strong class="ky hv">try</strong> {<br/>   <strong class="ky hv">const</strong> users = <strong class="ky hv">await</strong> api.get('/users');<br/>   dispatch(resolveFetchingUsers(users));<br/> } <strong class="ky hv">catch</strong> (error) {<br/>   dispatch(rejectFetchingUsers(error.message));<br/> }<br/>}</span></pre><p id="78b2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好了，我们完成了冗余部分&amp;我们快完成了。现在我们只需要将动作创建者和状态连接到React组件，我们就可以开始了！</p><p id="6f90" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于这个简单的特性，我们需要输入许多行</p><ul class=""><li id="383c" class="ll lm hu it b iu iv iy iz jc ln jg lo jk lp jo lq lr ls lt dt translated">动作类型，</li><li id="f6e6" class="ll lm hu it b iu lu iy lv jc lw jg lx jk ly jo lq lr ls lt dt translated">动作创作者，</li><li id="233f" class="ll lm hu it b iu lu iy lv jc lw jg lx jk ly jo lq lr ls lt dt translated">减速器中的动作处理器、</li></ul><p id="037e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还没有编写任何视图组件。</p><p id="25af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们参与开发一个具有数千个动作类型、动作创建者和子缩减者的大型应用程序时，这尤其不方便。这也导致了进一步的困难，因为这些资源被分离在不同的位置的许多文件中。因此，如果我们想跟踪一个动作的效果，我们必须跟踪许多文件的数据流，这很容易丢失。</p><p id="e9ba" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过查看<a class="ae jp" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a>，我们最有可能找到一堆库/助手/中间件，它们帮助我们避免打字，但是使用它们会引入一些其他类型的打字开销，因为我们需要在每个文件中导入它们。</p><p id="e355" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也许我们应该想一个更简单的办法，考虑一下Redux到底需要哪些功能。</p><p id="33d8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">1) <strong class="it hv">我们必须保持数据不变吗？可变性是通往地狱的高速公路。所以这不是办法。尤其是在反应应用中。</strong></p><p id="49fc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2) <strong class="it hv">我们一定要知道一个动作的名字吗？</strong>在大多数情况下，动作只在单个地方使用。我们不需要保持它们的可复制性。如果您有方法调度匿名操作呢？这太好了。</p><p id="a538" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">3) <strong class="it hv">我们必须能够序列化动作吗？</strong>在一些用例中，您绝对需要可序列化，但是在大多数应用程序中，您并不需要。所以让我们继续假设这不是现在的要求。</p><p id="86cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们应该坚持第一个限制，同时我们可以放心地忘记其他限制。</p><p id="c430" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们应该转换Redux概念，使我们能够简单地创建动作。我们想把一个动作描述成一个单一的功能，要么就地。</p><h1 id="9a5e" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">重新修补</h1><p id="d1d2" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated"><a class="ae jp" href="https://www.npmjs.com/package/repatch" rel="noopener ugc nofollow" target="_blank"> Repatch </a>从定义集中删除动作类型和动作创建者，并回答问题:“如果reducers是动作的有效负载会怎样？”。这个图书馆的信条是:</p><p id="a18e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">调度减速器</strong></p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="74e3" class="lc jr hu ky b fv ld le l lf lg">store.dispatch(state =&gt; ({ ...state, counter: state.counter + 1 }));</span></pre><p id="25bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">在这个术语中，动作是一个返回缩减器的函数:</strong></p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="b013" class="lc jr hu ky b fv ld le l lf lg"><strong class="ky hv">const</strong> increment = amount =&gt; state =&gt; ({  <br/>  ...state,<br/>  counter: state.counter + amount<br/>});</span><span id="a952" class="lc jr hu ky b fv lk le l lf lg">store.dispatch(increment(42));</span></pre><p id="ace5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Repatch还有一个<code class="eh lh li lj ky b">Store</code>类，我们可以用初始状态实例化它:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="7d98" class="lc jr hu ky b fv ld le l lf lg"><strong class="ky hv">import</strong> Store <strong class="ky hv">from</strong> 'repatch';</span><span id="4cb2" class="lc jr hu ky b fv lk le l lf lg"><strong class="ky hv">const</strong> store = <strong class="ky hv">new</strong> Store(initialState);</span></pre><p id="0861" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Repatch的接口与<a class="ae jp" href="https://www.npmjs.com/package/redux" rel="noopener ugc nofollow" target="_blank"> redux </a>的接口非常相似，因此我们可以将它与<a class="ae jp" href="https://www.npmjs.com/package/react-redux" rel="noopener ugc nofollow" target="_blank"> react-redux </a>库一起使用。<code class="eh lh li lj ky b">dispatch</code>和<code class="eh lh li lj ky b">subscribe</code>方法与Redux的<code class="eh lh li lj ky b">Store</code>方法具有相同的签名。</p><h1 id="bf9a" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">中间件和异步操作</h1><p id="eafd" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">Repatch还有一个链接中间件的接口。这对于使用您喜欢的异步操作中间件来说很方便。这个包提供了一个<code class="eh lh li lj ky b">thunk</code>中间件——类似于<a class="ae jp" href="https://www.npmjs.com/package/redux-thunk" rel="noopener ugc nofollow" target="_blank">redux-thunk</a>——对于创建异步动作很有用。如果你的reducer返回一个函数，中间件会自动认为它是一个异步动作。商店实例将把<code class="eh lh li lj ky b">dispatch</code>和<code class="eh lh li lj ky b">getState</code>函数作为参数传递给它。您可以设置中间件为。例如，您可以使用它来注入您的客户端API库。</p><p id="42a6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们看看下面与我们的用例相关的例子:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="47bc" class="lc jr hu ky b fv ld le l lf lg"><strong class="ky hv">const</strong> fetchUsers = () =&gt; _ =&gt; <strong class="ky hv">async</strong> (dispatch, getState, { api }) =&gt; {  <br/> dispatch(state =&gt; ({ ...state, isFetching: true }));<br/> <strong class="ky hv">try</strong> {<br/>   <strong class="ky hv">const</strong> users = <strong class="ky hv">await</strong> api.get('/users');<br/>   dispatch(state =&gt; ({ ...state, users }));<br/> } <strong class="ky hv">catch</strong> (error) {<br/>   dispatch(state =&gt; ({ ...state, error: error.message }));<br/> } <strong class="ky hv">finally</strong> {<br/>   dispatch(state =&gt; ({ ...state, isFetching: false }))<br/> }<br/>}</span></pre><p id="acd9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用这个<code class="eh lh li lj ky b">thunk</code>中间件展示了repatch的真正威力，因为我们只用几行代码就可以描述异步操作。如您所见，我们不需要在reducer中定义详细的动作类型、动作创建者和动作处理者，因为我们可以简单地分派一个适当定义的箭头函数，从而创建一个<strong class="it hv">匿名动作</strong>。多酷啊。这使得动作也可以从组件中创建。</p><p id="6b18" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">剩下的就是初始状态的<code class="eh lh li lj ky b">Store</code>实例化:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="2e3d" class="lc jr hu ky b fv ld le l lf lg"><strong class="ky hv">const</strong> store = <strong class="ky hv">new</strong> Store({  <br/> isFetching: false,<br/> users: [],<br/> error: null<br/>});</span></pre><p id="c5d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在某个地方分派行动:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="7bce" class="lc jr hu ky b fv ld le l lf lg">store.dispatch(fetchUsers())</span></pre><p id="1d43" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们看另一个例子:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="dece" class="lc jr hu ky b fv ld le l lf lg"><strong class="ky hv">const</strong> updateUser = delta =&gt; state =&gt; <strong class="ky hv">async</strong> (dispatch, getState, { api }) =&gt; {  <br/> <strong class="ky hv">try</strong> {<br/>   <strong class="ky hv">const</strong> editedUserId = getState().editedUser;<br/>   dispatch(toggleSpinner(true));<br/>   <strong class="ky hv">await</strong> api.put(`/users/${editedUserId}`, { body: delta });<br/>   <strong class="ky hv">await</strong> dispatch(fetchUsers());<br/>   dispatch(toggleSpinner(false));<br/> } <strong class="ky hv">catch</strong> (error) {<br/>   dispatch(state =&gt; ({ ...state, isFetching: false, error: error.message }));<br/> }<br/>};</span></pre><p id="9c25" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以从函数签名中看到，在这个例子中，额外的参数是我们的客户端API对象，正如我前面提到的。另外，请注意，reducer的<code class="eh lh li lj ky b">state</code>参数对于读取状态并不总是令人满意的，因为它是从动作被触发时开始的一个瞬时表示。因此我们需要使用<code class="eh lh li lj ky b">getState</code>函数来代替<code class="eh lh li lj ky b">state</code>。</p><p id="7402" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个例子中，<code class="eh lh li lj ky b">toggleSpinner</code>是一个常规的同步动作，我们可以<code class="eh lh li lj ky b">dispatch</code>。<code class="eh lh li lj ky b">api.put</code>方法是一个简单的调用API的异步方法，对它来说没有任何障碍。线<code class="eh lh li lj ky b">await dispatch(fetchUsers())</code>更有趣一点。使用<a class="ae jp" href="https://www.npmjs.com/package/redux-thunk" rel="noopener ugc nofollow" target="_blank"> redux-thunk </a>我们习惯于在彼此内部嵌入异步动作并等待它们。</p><h1 id="5815" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">Redux中的子减速器</h1><p id="6182" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">Redux的reducers可以组成一个层次结构。这样，我们不需要定义一个巨大的减速器，相反，我们可以将它们分成更小的嵌套减速器。组合reducer并不神奇，我们只是创建了一个reducer，使用它们的子状态将部分一个接一个地还原为一个对象。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="0244" class="lc jr hu ky b fv ld le l lf lg"><strong class="ky hv">const</strong> rootReducer = (state, action) =&gt; ({  <br/> foo: fooReducer(state.foo, action),<br/> bar: barReducer(state.bar, action)<br/>});</span></pre><p id="05e6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">相当于</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="e53c" class="lc jr hu ky b fv ld le l lf lg"><strong class="ky hv">const</strong> rootReducer = redux.combineReducers({  <br/>  foo: fooReducer,<br/>  bar: barReducer<br/>});</span></pre><h1 id="0407" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">重新修补中的子减速器</h1><p id="f1a9" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">Repatch还提供了一种组合子减速器的方法。我们只是定义了一个函数，它将一个嵌套的reducer作为参数，并返回一个缩减整个状态的reducer:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="b477" class="lc jr hu ky b fv ld le l lf lg"><strong class="ky hv">const</strong> reduceFoo = fooReducer =&gt; state =&gt; ({  <br/> ...state,<br/> foo: fooReducer(state.foo)<br/>});</span></pre><p id="6f75" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在减少<code class="eh lh li lj ky b">foo</code>属性很容易。假设我们想在<code class="eh lh li lj ky b">foo</code>对象中设置一个<code class="eh lh li lj ky b">x</code>属性:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="a69f" class="lc jr hu ky b fv ld le l lf lg"><strong class="ky hv">const</strong> setX = x =&gt; reduceFoo(state =&gt; ({ ...state, x }));</span></pre><p id="0189" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果sub-reducer描述了一个深度嵌套的属性，这将非常有用:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="d43a" class="lc jr hu ky b fv ld le l lf lg"><strong class="ky hv">const</strong> reduceFoo = reducer =&gt; state =&gt; ({  <br/>  ...state,<br/>  bar: {<br/>    ...state.bar,<br/>    foo: reducer(state.bar.foo)<br/>  }<br/>});</span></pre><h1 id="e995" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">测试</h1><p id="7757" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">测试怎么样？为一个缩减器编写单元测试很简单:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="1252" class="lc jr hu ky b fv ld le l lf lg"><strong class="ky hv">import</strong> * <strong class="ky hv">as</strong> assert <strong class="ky hv">from</strong> 'assert';  <br/><strong class="ky hv">import</strong> { changeName } <strong class="ky hv">from</strong> './actions';</span><span id="7f36" class="lc jr hu ky b fv lk le l lf lg">// ...</span><span id="efac" class="lc jr hu ky b fv lk le l lf lg">it('changeName', () =&gt; {  <br/> <strong class="ky hv">const</strong> state = { name: 'john' };<br/> <strong class="ky hv">const</strong> nextState = changeName('jack')(state);<br/> assert.strictEqual(nextState.name, 'jack');<br/>});</span></pre><p id="b37b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">异步操作稍微复杂一点，因为它们的生效依赖于外部资源，比如store实例和其他API。但是外部资源在所有环境下总是需要被嘲讽的。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="be71" class="lc jr hu ky b fv ld le l lf lg"><strong class="ky hv">import</strong> Store, { thunk } <strong class="ky hv">from</strong> 'repatch';  <br/><strong class="ky hv">import</strong> * <strong class="ky hv">as</strong> assert <strong class="ky hv">from</strong> 'assert';</span><span id="6cd5" class="lc jr hu ky b fv lk le l lf lg"><strong class="ky hv">const</strong> mockUsers = [{ username: 'john' }];  <br/><strong class="ky hv">const</strong> mockApi = {  <br/> getUsers: () =&gt; <strong class="ky hv">Promise</strong>.resolve(mockUsers)<br/>}</span><span id="676a" class="lc jr hu ky b fv lk le l lf lg">// ...</span><span id="403d" class="lc jr hu ky b fv lk le l lf lg">it('fetchUsers', <strong class="ky hv">async</strong> () =&gt; {  <br/> <strong class="ky hv">const</strong> state = { users: [] };<br/> <strong class="ky hv">const</strong> store = <strong class="ky hv">new</strong> Store(state)<br/>   .addMiddleware(thunk.withExtraArgument({ api: mockApi }));<br/> <strong class="ky hv">await</strong> store.dispatch(fetchUsers());<br/> <strong class="ky hv">const</strong> nextState = store.getState();<br/> assert.deepEqual(nextState.users, mockUsers);<br/>});</span></pre><h1 id="f3e3" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">待办事项应用程序</h1><p id="b6c6" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">每个javascript库都有一个todo示例，所以repatch也有<a class="ae jp" href="https://community.risingstack.com/repatch-the-simplified-redux/(https://github.com/jaystack/repatch-example-electron-app)" rel="noopener ugc nofollow" target="_blank">一个</a>。如果您正在寻找TypeScript示例，您可以在这里找到它<a class="ae jp" href="https://github.com/jaystack/repatch-example-electron-app-ts" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl ma mb hc mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hn ho hp hq hr"><p id="b155" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="lz">这篇由</em> <a class="ae jp" href="https://twitter.com/hasyee04" rel="noopener ugc nofollow" target="_blank">彼得·豪斯克内希特</a> <em class="lz">撰写的客座博文，原载于2017年8月16日</em><a class="ae jp" href="https://community.risingstack.com/repatch-the-simplified-redux/" rel="noopener ugc nofollow" target="_blank"><em class="lz">community.risingstack.com</em></a><em class="lz">。</em></p></div></div>    
</body>
</html>