<html>
<head>
<title>How does Angular2 work? Part 1 — Application Refs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular2是如何工作的？第1部分—应用参考</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-deep-dive-into-angular2-part-1-application-refs-b15d62a86246?source=collection_archive---------0-----------------------#2016-09-21">https://medium.com/hackernoon/a-deep-dive-into-angular2-part-1-application-refs-b15d62a86246?source=collection_archive---------0-----------------------#2016-09-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="2734" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated"><strong class="ak">前进</strong></h1><p id="1d36" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我是一名<a class="ae kn" href="https://hackernoon.com/tagged/angular" rel="noopener ugc nofollow" target="_blank"> Angular </a> 1.x开发者。我每天都在Angular 1.x中工作，我可以说我了解消化周期。对于Angular 1.x，我采取了一种“边学边用”的方法，而对于Angular 2，我会更加务实一些。</p><p id="7ed9" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">为了从<a class="ae kn" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> javascript </a>到屏幕上的DOM元素，我将尝试分离并记录Angular 2应用程序经历的每个步骤和部分。</p><h1 id="8e91" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">设置</h1><p id="dddc" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我的应用程序，被亲切地称为“客户端”，是从哪里开始的。我安装了angular-cli包并简单地调用了</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="5e95" class="lc is hu ky b fv ld le l lf lg">&gt; ng init</span></pre><p id="fa7e" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">相当复杂的设置，实际上我真的很喜欢这个初学者应用程序。与耗时费力的手动设置相比，这是一种非常好的快速入门方式。</p><p id="b4d6" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">现在，大多数编译/打包步骤都包含在angular-cli附带的blackbox webpack系统中，所以我们将从src/main.ts开始。</p><p id="1cf4" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">main.ts导入了一些polyfills和基本内容，typescript编译器和angular需要这些内容才能在浏览器中正常运行。</p><p id="32fa" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">现在让我们进入一些真正的肉。</p><h1 id="7896" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">就这样开始了……一路都是海龟。</h1><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="1749" class="lc is hu ky b fv ld le l lf lg">platformBrowserDynamic().bootstrapModule(AppModule);</span></pre><p id="3b8f" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">这到底是什么意思？让我们开始挖掘，首先我们进入<a class="ae kn" href="https://github.com/angular/angular/blob/2b20db6c5acd60721e8a5dae2b50cdb1292f8db1/modules/%40angular/platform-browser-dynamic/src/platform-browser-dynamic.ts" rel="noopener ugc nofollow" target="_blank">这里</a>，这是platformBrowserDynamic的声明。在里面，我们发现我们看到了</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="188b" class="lc is hu ky b fv ld le l lf lg">export const platformBrowserDynamic = createPlatformFactory(        <br/>  platformCoreDynamic, <br/>  'browserDynamic',<br/>  INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS<br/>);</span></pre><p id="d9c0" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">现在我们已经确定了有一种东西叫做平台(以及平台工厂)。)在这个调用之后，我们被重定向到一个名为<a class="ae kn" href="https://github.com/angular/angular/blob/2b20db6c5acd60721e8a5dae2b50cdb1292f8db1/modules/%40angular/core/src/application_ref.ts#L84" rel="noopener ugc nofollow" target="_blank"> application_ref.ts </a>的文件。我们看到参数名依次是</p><ul class=""><li id="8387" class="lh li hu jr b js ko jw kp ka lj ke lk ki ll km lm ln lo lp dt translated">parentPlaformFactory:(extra providers？:Provider[]) =&gt; PlatformRef</li><li id="ed7f" class="lh li hu jr b js lq jw lr ka ls ke lt ki lu km lm ln lo lp dt translated">名称:字符串</li><li id="7648" class="lh li hu jr b js lq jw lr ka ls ke lt ki lu km lm ln lo lp dt translated">提供者:提供者[] = []</li></ul><p id="c719" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">这些名字似乎不言自明。首先要注意的是INTERNAL _ BROWSER _ DYNAMIC _ PLATFORM _ PROVIDERS。你可以在这里找到所有提供<a class="ae kn" href="https://github.com/angular/angular/blob/979657989bab4fb93faf6a207d30760faa9bd696/modules/%40angular/platform-browser/src/private_export.ts#L18" rel="noopener ugc nofollow" target="_blank">的东西</a>，或者如果你只是想让我告诉你，它是做<strong class="jr hv">浏览器特定渲染</strong>所必需的所有模块。这基本上是这些调用的平台特定部分。其他的都是核心。</p><p id="0290" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">让我们深入研究第一个论点，“parentPlatformFactory”。就starter应用程序而言，我们可以看到这是platformCoreDynamic，我们从<a class="ae kn" href="https://github.com/angular/angular/tree/2b20db6c5acd60721e8a5dae2b50cdb1292f8db1/modules/%40angular/compiler" rel="noopener ugc nofollow" target="_blank">编译器模块</a>获得。你可能会问，这里躺着什么？<a class="ae kn" href="https://github.com/angular/angular/blob/42a287fabf6b035d51e00cf3006c27fec00f054a/modules/%40angular/compiler/src/compiler.ts#L138" rel="noopener ugc nofollow" target="_blank">更多平台工厂</a>！一路上都是乌龟。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="08f8" class="lc is hu ky b fv ld le l lf lg">export const platformCoreDynamic = createPlatformFactory(<br/>  platformCore, <br/>  'coreDynamic', <br/>  [{<br/>    provide: COMPILER_OPTIONS, <br/>    useValue: {}, <br/>    multi: true<br/>  }, {<br/>    provide: CompilerFactory, <br/>    useClass: RuntimeCompilerFactory<br/>  }, {<br/>    provide: PLATFORM_INITIALIZER, <br/>    useValue: _initReflector, <br/>    multi: true<br/>  }]);</span></pre><p id="9982" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">因此，现在我们有了另一个基于“平台核心”的平台，我们将在稍后深入研究。请注意，看起来我们提供了很多与编译器相关的模块。这些都与获取角度代码和模板并将其编译成可渲染的组件有关。这里最值得注意的是，RuntimeCompilerFactory是作为CompilerFactory提供的。这意味着我们正在进行JIT编译，而不是提前编译angular应用程序。</p><p id="63c7" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">platformCore。你是什么？让我们看看。它来自角/核心，我们发现…</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="f2c7" class="lc is hu ky b fv ld le l lf lg">export const platformCore = createPlatformFactory(<br/>  null, <br/>  'core', <br/>  _CORE_PLATFORM_PROVIDERS<br/>);</span></pre><p id="c0a5" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">不过，我们已经走到了尽头，爷爷的平台工厂。核心。它甚至有一个伟大的名字，它是核心。最后一个。中心。如果你看看什么是_ CORE _ PLATFORM _ PROVIDERS，它们看起来是一堆非常普通的东西，反射器，控制台，通常是为任何应用程序提供基本功能的提供者。</p><p id="5712" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">太好了，让我们放松一下，回到我们最初对createPlatformFactory的调用，弄清楚这一切意味着什么。createPlatformFactory的第一行如下所示；</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="44b8" class="lc is hu ky b fv ld le l lf lg">const marker = new OpaqueToken(`Platform: ${name}`);</span></pre><p id="15f9" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">OpaqueToken只是一个名称容器，基本上是Angular2版本的符号。到目前为止还不错。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="6bbd" class="lc is hu ky b fv ld le l lf lg">return (extraProviders: Provider[] = []) =&gt; {    <br/>  if (!getPlatform()) {      <br/>    if (parentPlaformFactory) {        <br/>      parentPlaformFactory(               <br/>        providers.concat(extraProviders).concat({<br/>          provide: marker, useValue: true<br/>        }));      <br/>    } else {                <br/>      createPlatform(ReflectiveInjector.resolveAndCreate(            <br/>        providers.concat(extraProviders).concat({<br/>          provide: marker, useValue: true<br/>        })));      <br/>    }    <br/>  }    </span><span id="7d84" class="lc is hu ky b fv lv le l lf lg">  return assertPlatform(marker);  <br/>};</span></pre><p id="480a" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">第一条语句getPlatform()检查createPlatform()是否被调用过，即是否有一个被分配的平台。我们第一次调用createPlatform(回到核心)，我们根据创建的注入器创建一个平台。<a class="ae kn" href="https://github.com/angular/angular/blob/566d4361e22a3d8a4ce8619a762115abf97aaee2/modules/%40angular/core/src/platform_core_providers.ts#L20" rel="noopener ugc nofollow" target="_blank">我们再看看那个文件</a>。正如我们所看到的，PlatformRef已经从application_ref文件中分配给了PlatformRef。回到那里，<a class="ae kn" href="https://github.com/angular/angular/blob/df4254ae89ccc6c3f358e4722ecaf8643cc320e2/modules/%40angular/core/src/application_ref.ts#L238" rel="noopener ugc nofollow" target="_blank">我们看到</a>是抽象类<a class="ae kn" href="https://github.com/angular/angular/blob/df4254ae89ccc6c3f358e4722ecaf8643cc320e2/modules/%40angular/core/src/application_ref.ts#L342" rel="noopener ugc nofollow" target="_blank">平台参考</a>的实现。</p><blockquote class="lw lx ly"><p id="12c5" class="jp jq lz jr b js ko ju jv jw kp jy jz ma kq kc kd mb kr kg kh mc ks kk kl km hn dt translated">Angular平台是网页上Angular的入口点。每个页面只有一个平台，页面上运行的每个Angular应用程序共有的服务(比如反射)都被绑定在它的范围内。* *当调用{@link bootstrap}()时，页面的平台被隐式初始化，或者*通过调用{@link createPlatform}()显式初始化。</p></blockquote><p id="4247" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">我们终于实现了角度应用。在下一部分中，我们将研究当您调用bootstrapModule时实际发生了什么。</p><blockquote class="lw lx ly"><p id="7a7d" class="jp jq lz jr b js ko ju jv jw kp jy jz ma kq kc kd mb kr kg kh mc ks kk kl km hn dt translated"><a class="ae kn" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kn" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kn" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae kn" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="jp jq lz jr b js ko ju jv jw kp jy jz ma kq kc kd mb kr kg kh mc ks kk kl km hn dt translated">要了解更多信息，请<a class="ae kn" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae kn" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae kn" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="jp jq lz jr b js ko ju jv jw kp jy jz ma kq kc kd mb kr kg kh mc ks kk kl km hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kn" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kn" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kt ku kv kw fq md"><div class="bz el l di"><div class="me mf l"/></div></figure></div></div>    
</body>
</html>