<html>
<head>
<title>How to migrate an application from AngularJS to React and Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将应用从AngularJS迁移到React和Redux</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-migrate-an-application-from-angularjs-to-react-and-redux-de0e2d1f70aa?source=collection_archive---------5-----------------------#2017-10-20">https://medium.com/hackernoon/how-to-migrate-an-application-from-angularjs-to-react-and-redux-de0e2d1f70aa?source=collection_archive---------5-----------------------#2017-10-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/c0d924a4af5b6d64eae8a0afa4af0f8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-lLRGp1g5biW5-yCcpTYZA.png"/></div></div></figure><div class=""/><p id="f2b4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从今年开始，我受雇于<a class="ae ka" href="https://ben.productplacement.com/" rel="noopener ugc nofollow" target="_blank"> BEN Group </a>，主要目标是帮助他们将一个遗留应用从<em class="kb"> AngularJS </em>迁移到<em class="kb"> React </em>和<em class="kb"> Redux </em>。从那以后，我们一直在项目内部创建解决方案，到目前为止效果很好。</p><p id="d304" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这篇文章中，我打算展示我们遵循的主要方法，并分享我们创建的一些解决方案，以允许我们逐步迁移项目，而不会失去理智。</p><blockquote class="kc kd ke"><p id="6e8d" class="jc jd kb je b jf jg jh ji jj jk jl jm kf jo jp jq kg js jt ju kh jw jx jy jz hn dt translated"><strong class="je ig">免责声明</strong>:我们这里的重点不是重构遗留代码，而是尽快移除它。我们避免为了让遗留代码“更漂亮”而花费太多时间或精力的解决方案。也就是说，我们会编写高质量的新代码。</p></blockquote><h1 id="f5fe" class="ki kj if bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">将内部版本移动到webpack。</h1><p id="4725" class="pw-post-body-paragraph jc jd if je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">这一步，我认为是整个过程中最重要的，一旦有了<em class="kb"> Webpack </em>，你就可以开始使用指令<strong class="je ig"> import </strong>来获取你的依赖项和模块，你就可以开始摆脱Angular的依赖注入(DI)了。这也是在应用程序中开始编写<em class="kb"> React </em>代码所必需的。</p><blockquote class="kc kd ke"><p id="94fc" class="jc jd kb je b jf jg jh ji jj jk jl jm kf jo jp jq kg js jt ju kh jw jx jy jz hn dt translated">如果你使用Angular的模板缓存，Pug(Jade)或者其他任何影响构建的东西，不用担心，Webpack会为它们每一个都准备一个加载器。不要忘记让您的网络包配置为transpile ES2015和JSX。</p></blockquote><p id="12a4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这一步的重点不是将所有的DI转移到导入，而是让您的构建与<em class="kb"> Webpack </em>一起工作。记住这一点很重要，以避免在这个任务中停留数周，并在几十个文件中引起冲突。</p><p id="1795" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<em class="kb"> AngularJS </em>中，通常情况下，构建过程会从<code class="eh ll lm ln lo b">node_modules</code>中获取你需要的所有依赖项，并将它们插入到包中。我们也需要在新版本中保持这种行为。</p><blockquote class="kc kd ke"><p id="faed" class="jc jd kb je b jf jg jh ji jj jk jl jm kf jo jp jq kg js jt ju kh jw jx jy jz hn dt translated">您需要将遗留代码视为需要击败的敌人。我们需要谨慎行事，需要有战略眼光。这也意味着，在某些时候，我们需要做一些不愉快的事情。</p></blockquote><p id="4093" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了解决这个问题，我们创建了一个文件<code class="eh ll lm ln lo b">vendor.js</code>，并在其中导入了所有的依赖项:</p><figure class="lp lq lr ls fq hw"><div class="bz el l di"><div class="lt lu l"/></div></figure><p id="9b98" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">大多数依赖关系在导入时会在<em class="kb">窗口</em>对象中进行全局注册。所以，我们只需要像上面的例子那样导入它们。虽然，他们中的一些不这样做，我们需要手动操作。下面我们举一个例子来说明我们与<strong class="je ig"> <em class="kb">时刻</em> </strong>和<strong class="je ig"> <em class="kb"> jQuery </em> </strong>:</p><figure class="lp lq lr ls fq hw"><div class="bz el l di"><div class="lt lu l"/></div></figure><p id="1e70" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种做法可能很奇怪，但是，你需要考虑到大多数依赖依赖于<code class="eh ll lm ln lo b">window.$</code>，其他依赖于<code class="eh ll lm ln lo b">window.jQuery</code>，甚至其他依赖于<code class="eh ll lm ln lo b">window.jquery.</code></p><p id="c6e0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">创建vendors文件后，将其导入应用程序的入口点，这样，您的所有依赖项都将包含在包中:</p><pre class="lp lq lr ls fq lv lo lw lx aw ly dt"><span id="fe0d" class="lz kj if lo b fv ma mb l mc md">require('./vendors');</span></pre><p id="f14f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一个步骤是确保所有应用程序的文件都在包中。理想的情况是让每个模块都有一个索引文件，导入控制器、工厂、视图等..这样，您只需要在应用程序的入口点导入这些索引，就像您对供应商所做的一样，如下例所示:</p><figure class="lp lq lr ls fq hw"><div class="bz el l di"><div class="lt lu l"/></div></figure><p id="0d20" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您没有索引，您可以尝试遵循一个稍微大胆的解决方案，虽然不太建议。那就是找到一个正则表达式来匹配所有的文件，并使用<strong class="je ig"> require.context </strong>导入它们，如下例所示:</p><figure class="lp lq lr ls fq hw"><div class="bz el l di"><div class="lt lu l"/></div></figure><p id="22d6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面的代码，将强制<em class="kb"> Webpack </em>在捆绑包中包含<code class="eh ll lm ln lo b">/app</code>文件夹及其子文件夹中的所有<code class="eh ll lm ln lo b">.js</code>和<code class="eh ll lm ln lo b">.jsx</code>文件。如果你决定这样做，不要忘记你可能有<code class="eh ll lm ln lo b">.test.js</code>、<code class="eh ll lm ln lo b">.spec.js</code>甚至<code class="eh ll lm ln lo b">.stories.js</code>文件，你将不得不在正则表达式中排除它们。</p><p id="d979" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此外，请记住，在某些情况下，<em class="kb"> Angular </em>依赖于文件加载的顺序，因此，这个解决方案可能最终完全不起作用。</p><p id="6793" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当您最终让您的构建工作起来时，赶快创建一个针对您的主分支的拉请求。除了<em class="kb"> React </em>之外，将构建转移到<em class="kb"> Webpack </em>已经是您的应用程序的一个优势。Angular的DI使得应用程序具有强耦合性，而<em class="kb"> Webpack </em>是我们的盟友</p><h1 id="dfb6" class="ki kj if bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">渲染AngularJS内部的React组件</h1><p id="3167" class="pw-post-body-paragraph jc jd if je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">第二个最重要的步骤，因为没有它就不可能逐渐迁移。这里的想法是，你可以在<em class="kb"> Angular </em>中使用<em class="kb"> React </em>组件，就像它们是指令一样。为了实现这一点，我们目前在我们的项目中使用了<a class="ae ka" href="https://github.com/ngReact/ngReact" rel="noopener ugc nofollow" target="_blank"><em class="kb">n react</em></a><em class="kb"/>。</p><blockquote class="kc kd ke"><p id="9894" class="jc jd kb je b jf jg jh ji jj jk jl jm kf jo jp jq kg js jt ju kh jw jx jy jz hn dt translated">n反应报告建议使用库<a class="ae ka" href="https://github.com/coatue-oss/react2angular" rel="noopener ugc nofollow" target="_blank"> <em class="if">反应2角</em> </a>。然而，我们在我们的应用程序中使用Angular 1.5.8，我们最终在尝试使用另一个库时遇到了一些问题。我已经在另一个项目中使用了react2Angular，他们使用的是更新的Angular版本，我没有遇到任何问题。也就是说，ngReact即使不再更新，也具有将组件转换成指令所需的所有特性。我的建议是:选择适合你的库，然后继续，两者非常相似</p></blockquote><p id="aee2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要将<em class="kb">n react</em>集成到项目中，您可以从npm安装它:</p><pre class="lp lq lr ls fq lv lo lw lx aw ly dt"><span id="c7ac" class="lz kj if lo b fv ma mb l mc md">$ npm i --save ngreact</span></pre><p id="b232" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后将其导入您的供应商:</p><pre class="lp lq lr ls fq lv lo lw lx aw ly dt"><span id="59fa" class="lz kj if lo b fv ma mb l mc md">require('<strong class="lo ig">ngreact</strong>');</span></pre><p id="3533" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您还需要在您的项目中安装<em class="kb"> react </em>和<em class="kb"> react-dom </em>:</p><pre class="lp lq lr ls fq lv lo lw lx aw ly dt"><span id="443b" class="lz kj if lo b fv ma mb l mc md">npm i --save <strong class="lo ig">react</strong> <strong class="lo ig">react-dom</strong></span></pre><p id="b4c4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，将<strong class="je ig">反应</strong>模块注册为<em class="kb">角度</em>:</p><pre class="lp lq lr ls fq lv lo lw lx aw ly dt"><span id="189e" class="lz kj if lo b fv ma mb l mc md">angular.module('app', ['<strong class="lo ig">react</strong>']);</span></pre><p id="6c7f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">完成后，我们可以创建一个<strong class="je ig">按钮</strong>组件，就像我们在常规<em class="kb"> React </em>应用程序中创建的一样:</p><figure class="lp lq lr ls fq hw"><div class="bz el l di"><div class="lt lu l"/></div></figure><p id="2f97" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，我们定义了一个指令，作为<strong class="je ig">按钮</strong>的包装器:</p><figure class="lp lq lr ls fq hw"><div class="bz el l di"><div class="lt lu l"/></div></figure><p id="633f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在指令文件中，我们必须定义<strong class="je ig">按钮</strong>使用的所有道具的名称，以便<em class="kb">n react</em>理解它应该传递给组件什么。</p><p id="d8a1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">指令定义后，我们需要在<em class="kb">角度</em>中注册它:</p><figure class="lp lq lr ls fq hw"><div class="bz el l di"><div class="lt lu l"/></div></figure><blockquote class="kc kd ke"><p id="845f" class="jc jd kb je b jf jg jh ji jj jk jl jm kf jo jp jq kg js jt ju kh jw jx jy jz hn dt translated">Angular的模块，你要用来注册它并不重要，只要确保它在应用程序中注册。</p></blockquote><p id="867c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦注册，我们现在可以在任何angular的视图中使用该指令，如下例所示:</p><pre class="lp lq lr ls fq lv lo lw lx aw ly dt"><span id="aeed" class="lz kj if lo b fv ma mb l mc md">&lt;div&gt;<br/>  &lt;<strong class="lo ig">react-button</strong> class-name="btn"&gt;&lt;/<strong class="lo ig">react-button</strong>&gt;<br/>&lt;/div&gt;</span></pre><p id="c8bf" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，在这里，我们使用破折号来拆分单词，而不是驼峰式大小写。在这种情况下，reactButton变成react-button，而<code class="eh ll lm ln lo b">className</code>变成<code class="eh ll lm ln lo b">class-name</code>。记住这一点很重要，因为这是一个常见的错误，可能需要几个小时来调试。</p><p id="f65e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用<em class="kb">n react</em>来渲染<em class="kb"> AngularJS </em>应用程序中的小组件很常见，但是效率不高。</p><p id="5640" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="kb"> Angular </em> <em class="kb"> UI路由器，</em>允许我们在路由配置中传递一个参数模板。为了探索这一点，可以为每个应用程序的屏幕创建一个包装器组件，然后使用这些包装器，如下例所示:</p><figure class="lp lq lr ls fq hw"><div class="bz el l di"><div class="lt lu l"/></div></figure><p id="a514" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在上面的例子中，我们定义了一个登录路由，并将其传递给一个组件，这个组件就是整个登录屏幕。这样，我们可以一次迁移整个屏幕，而不是一个组件一个组件地迁移。</p><p id="5afe" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我这里的黄金奉劝，就是在项目中安装<a class="ae ka" href="https://storybook.js.org/" rel="noopener ugc nofollow" target="_blank"> <em class="kb">故事书</em> </a> <em class="kb"> </em>，创建并测试小组件。这种方式更容易构建可靠的组件，然后将它们一起放入屏幕中。</p><blockquote class="kc kd ke"><p id="b7e6" class="jc jd kb je b jf jg jh ji jj jk jl jm kf jo jp jq kg js jt ju kh jw jx jy jz hn dt translated">屏幕:也称为页面，它们是每个路由的根组件。</p></blockquote><h1 id="7d65" class="ki kj if bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">共享依赖关系</h1><p id="8790" class="pw-post-body-paragraph jc jd if je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">定义一整个屏幕是惊人的。然而，当我们走到这一步时，我们还需要与<em class="kb"> React </em>共享一些<em class="kb"> Angular </em>依赖关系。</p><p id="634a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在BEN的例子中，我们需要的依赖项，只有在Angular初始化之后，在它执行了providers、config等之后才准备好...鉴于此，不可能使用<strong class="je ig"> export </strong>关键字导出它们。为了解决这个问题，我们创建了一个对象和一个助手函数来注入依赖关系。为了实现这个解决方案，我们只需要用下面的代码创建一个名为<code class="eh ll lm ln lo b">ngDeps.js</code>的文件:</p><figure class="lp lq lr ls fq hw"><div class="bz el l di"><div class="lt lu l"/></div></figure><p id="20c4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们在Angular的<a class="ae ka" href="https://docs.angularjs.org/api/ng/type/angular.Module#run" rel="noopener ugc nofollow" target="_blank"> <strong class="je ig"> run </strong> </a>流程中调用<strong class="je ig">injectingdeps</strong>，如下例:</p><figure class="lp lq lr ls fq hw"><div class="bz el l di"><div class="lt lu l"/></div></figure><p id="ece2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们这样做是因为我们想尽快访问依赖项，而<strong class="je ig"> run </strong>是初始化中首先执行的进程之一。<strong class="je ig"> injectNgDeps </strong>接受一个对象作为参数，并将其与<strong class="je ig"> ngDeps </strong>对象合并。</p><p id="43ae" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当您需要一个<em class="kb"> React </em>组件内的任何依赖时，您只需要做如下操作:</p><figure class="lp lq lr ls fq hw"><div class="bz el l di"><div class="lt lu l"/></div></figure><p id="4d31" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，我们做的第一件事是导入<strong class="je ig"> ngDeps </strong>。如果您试图在<strong class="je ig">导入</strong>之后立即访问<code class="eh ll lm ln lo b">ngDeps.$state</code>，结果将是<code class="eh ll lm ln lo b">undefined</code>，因为<strong class="je ig">运行</strong>进程还没有运行。出于这个原因，我们访问组件的<strong class="je ig">构造器</strong>方法中的值，因为组件只有在<em class="kb">角度</em>初始化后才会被实例化。</p><p id="c8fd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们从<strong class="je ig"> ngDeps </strong>中提取依赖项，并将它们分配给对象<strong class="je ig"> this </strong>，因为这样我们可以在任何类的方法中访问<code class="eh ll lm ln lo b">this.$state</code></p><p id="881d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这样就有可能与<em class="kb">反应</em>组件共享任何角度的依赖性。然而，尽量少用<strong class="je ig"> ngDeps </strong>。请记住:我可以使用<strong class="je ig">导出</strong>来导出这个依赖关系吗？如果答案是肯定的，你总是选择使用导出，否则你使用<strong class="je ig"> ngDeps </strong>。</p><p id="8564" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一个需要强调的是，保持对<strong class="je ig"> ngDeps </strong>的访问仅限于树中的顶层组件是很重要的。这意味着屏幕，可能还有一些容器。然后，通过道具传给孩子。这样，到时候就更容易移除<strong class="je ig"> ngDeps </strong>了。</p><h1 id="0895" class="ki kj if bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">在应用程序中集成Redux</h1><p id="565c" class="pw-post-body-paragraph jc jd if je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">在解决了双方共享依赖关系的问题后，我们可以继续将<em class="kb"> Redux </em>集成到应用程序中。做到这一点并不难，但也有一些特殊性。</p><p id="4472" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，按照<a class="ae ka" href="http://redux.js.org/" rel="noopener ugc nofollow" target="_blank">文档的说明</a>配置商店，就像在任何应用程序中一样。然而，一旦你创建了对象<strong class="je ig">商店</strong>，你必须按如下方式导出它:</p><pre class="lp lq lr ls fq lv lo lw lx aw ly dt"><span id="d3f4" class="lz kj if lo b fv ma mb l mc md"><strong class="lo ig">export</strong> const <strong class="lo ig">store</strong> = createStore(rootReducer);</span></pre><p id="0fad" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这将允许我们访问应用程序中其他文件中的<strong class="je ig">存储</strong>对象</p><p id="9d19" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在一个常规应用程序中，我们使用来自<a class="ae ka" href="https://github.com/reactjs/react-redux" rel="noopener ugc nofollow" target="_blank"> react-redux </a>的<strong class="je ig"> connect </strong>方法，将我们的容器集成到<strong class="je ig">存储</strong>中。尽管如此，这只是因为我们在应用程序中插入了带有<strong class="je ig">存储</strong>的<strong class="je ig">提供者</strong>作为根组件，正如我们在lib的文档中看到的:</p><pre class="lp lq lr ls fq lv lo lw lx aw ly dt"><span id="53d1" class="lz kj if lo b fv ma mb l mc md">ReactDOM.render(<br/>  &lt;<strong class="lo ig">Provider</strong> store={<strong class="lo ig">store</strong>}&gt;<br/>    &lt;MyAppRootComponent /&gt;<br/>  &lt;/<strong class="lo ig">Provider</strong>&gt;,<br/>  rootEl<br/>)</span></pre><p id="0c86" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">问题是我们的应用程序中不能只有一个根组件，我们有很多。我们一直手动控制哪些组件应该包含提供者，哪些不包含，这是不切实际的。为了解决这个问题，我们创建了一个高阶组件，它抽象了逻辑，并在必要时将提供者作为包装器插入。为了方便使用，我在<a class="ae ka" href="https://github.com/viniciusdacal/redux-connect-standalone" rel="noopener ugc nofollow" target="_blank"> Github </a>和<a class="ae ka" href="https://www.npmjs.com/package/redux-connect-standalone" rel="noopener ugc nofollow" target="_blank"> NPM </a>上以<a class="ae ka" href="https://github.com/viniciusdacal/redux-connect-standalone" rel="noopener ugc nofollow" target="_blank">redux-connect-standalone</a>发布了它。</p><p id="b0f7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由NPM安装:</p><pre class="lp lq lr ls fq lv lo lw lx aw ly dt"><span id="8d6e" class="lz kj if lo b fv ma mb l mc md">npm i --save redux-connect-standalone</span></pre><p id="271b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，我们可以创建我们的连接文件并使用以下代码:</p><figure class="lp lq lr ls fq hw"><div class="bz el l di"><div class="lt lu l"/></div></figure><p id="4004" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在您的组件内部，不是从<em class="kb"> react-redux </em>导入<strong class="je ig"> connect </strong>方法，而是从您刚刚创建的文件中导入它。并像使用原始方法一样使用它:</p><figure class="lp lq lr ls fq hw"><div class="bz el l di"><div class="lt lu l"/></div></figure><p id="00c5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于我们尊重来自原始方法的相同签名，当您将<strong class="je ig"> Provider </strong>作为应用程序的根组件时，您将只需要在导入方法中执行搜索替换，将其替换为:</p><pre class="lp lq lr ls fq lv lo lw lx aw ly dt"><span id="f166" class="lz kj if lo b fv ma mb l mc md">import { connect } from 'react-redux';</span></pre><blockquote class="kc kd ke"><p id="3754" class="jc jd kb je b jf jg jh ji jj jk jl jm kf jo jp jq kg js jt ju kh jw jx jy jz hn dt translated">如果您在应用程序中使用或打算使用redux-form，我还创建并发布了一个针对reduxForm的方法，即<a class="ae ka" href="https://goo.gl/4XgxwZ" rel="noopener ugc nofollow" target="_blank">redux-form-connect-standalone</a>。他的用法和我们上面看到的HOC很像。</p></blockquote><h1 id="d02b" class="ki kj if bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">最后的话</h1><p id="d370" class="pw-post-body-paragraph jc jd if je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">有了这些方法，就有可能逐步迁移您的应用程序。然而，在迁移应用程序的基础技术时，总会出现其他复杂的问题。重要的是要记住，上述所有解决方案都是角度和反应之间的中间地带。最终目标是摆脱所有这些，并使用<em class="kb"> React </em>和<em class="kb"> Redux的</em>惯例和良好实践。<strong class="je ig">所以，每当你想出一个解决方案时，想想以后要把它去掉会有多难</strong>。</p><p id="65f6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您发现任何有趣的解决方案或问题，请与我们分享。</p><p id="4afe" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你喜欢这篇文章，请帮助我们让更多的人继续发展和改进他们的应用程序。</p></div></div>    
</body>
</html>